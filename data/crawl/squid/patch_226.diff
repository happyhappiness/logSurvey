@@ -1,7 +1,9 @@
-Special thanks go to people who have volunteered their time, effort,
-and ideas to make this software available.
+This file contains a list of Squid contributors: people and organizations that
+have volunteered their time, effort, code, and ideas to make Squid software.
+Thank you!
 
     'noloader' <noloader@gmail.com>
+    <mgd@swarm.org>
     Adam Ciarcinski
     Adrian Chadd <adrian@squid-cache.org>
     Alan Mizrahi <alan@mizrahi.com.ve>
@@ -153,6 +155,7 @@ and ideas to make this software available.
     Markus Rietzler <markus.rietzler@rzf.fin-nrw.de>
     Markus Stumpf <maex@Space.NET>
     Martin Hamilton <martin@mrrl.lut.ac.uk>
+    Martin Hamilton <martinh@gnu.org>
     Martin Huter <m.huter@phion.com>
     Martin Stolle <martin.stolle@ekom21.de>
     Masashi Fujita <objectx@bandit.co.jp>
@@ -179,6 +182,7 @@ and ideas to make this software available.
     Niall Doherty <ndoherty@eei.ericsson.se>
     Nick Rogers <ncrogers@gmail.com>
     Nikolai Gorchilov <niki@x3me.net>
+    Olivier Montanuy
     Oskar Pearson <oskar@is.co.za>
     Paul Z <paulz42@gmail.com>
     Pawel Worach <pawel.worach@gmail.com>
@@ -200,11 +204,13 @@ and ideas to make this software available.
     Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
     Ralph Loader <loader@maths.ox.ac.uk>
     Regardt van de Vyver <squid@vdvyver.net>
+    Regents of the University of California (UCSD)
     Reinhard Sojka <reinhard.sojka@parlament.gv.at>
     Rene Geile <rene.geile@t-online.de>
     Reuben Farrelly <reuben@reub.net>
     Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>
     Richard Wall <richard.wall@appliansys.com>
+    Robert Collins <rbtcollins@hotmail.com>
     Robert Collins <robertc@robertcollins.net>
     Robert Forster
     Rodrigo Campos (rodrigo@geekbunker.org)
@@ -213,6 +219,7 @@ and ideas to make this software available.
     Russell Street <r.street@auckland.ac.nz>
     Russell Vincent <vincent@ucthpx.uct.ac.za>
     Ryan Troll <ryan+@andrew.cmu.edu>
+    Samba Project
     Scott Schram <scott@schram.net>
     Sebastien Wenske <sebastien@wenske.fr>
     Sergio Rabellino <rabellino@di.unito.it>
@@ -231,6 +238,7 @@ and ideas to make this software available.
     Svenx <svensven@gmail.com>
     Taavi Talvik <taavi@uninet.ee>
     Taketo Kabe <kabe@shiratori.riec.tohoku.ac.jp>
+    The Measurement Factory <info@measurement-factory.com>
     Thomas De Schampheleire <thomas.de.schampheleire@gmail.com>
     Thomas Hozza <thozza@redhat.com>
     Thomas Ristic <thr@bootet.net>
@@ -1,25 +0,0 @@
-By accepting this notice, you agree to be bound by the following
-agreements:
-
-This software product, SQUID, is developed by a team of individuals,
-and copyrighted (C) 2001 by the Regents of the University of
-California, with all rights reserved.  UCSD administered the NLANR
-Cache grants, NCR 9616602 and NCR 9521745 under which most of this
-code was developed.
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License (version 2) as
-published by the Free Software Foundation.  It is distributed in the
-hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along
-with this program; if not, write to:
-
-        		The Free Software Foundation
-        		59 Temple Place
-			Suite 330
-			Boston, MA 02111, USA
-
-Or contact info@squid-cache.org
@@ -1,35 +1,11 @@
-==============================================================================
-
-SQUID Internet Object Cache  http://www.squid-cache.org
---------------------------------------------------------
-
-  Squid is the result of efforts by numerous individuals from the
-  Internet community.  Development is led by Duane Wessels of the
-  National Laboratory for Applied Network Research and funded by
-  the National Science Foundation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-  
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-  
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
-  MA 02110-1301, USA.
-
-Squid is derived from the ``cached'' software from the ARPA-funded
-Harvest research project.  The Harvest home page is
-http://harvest.cs.colorado.edu/.
-
-Squid is originally derived from the Harvest Information Discovery and
-Access System.  The Harvest copyright text follows to acknowledge the origin:
+This file contains copyright and licensing information for 3rd party software
+imported into Squid. Squid software itself is copyrighted by The Squid
+Software Foundation and contributors. Please see the COPYING and CONTRIBUTORS
+files for details.
 
+==============================================================================
+Squid is derived from the ``cached'' software developed by the ARPA-funded
+research project called The Harvest Information Discovery and Access System:
 
 /*
  * Copyright (c) 1994, 1995.  All rights reserved.
@@ -108,109 +84,277 @@ Access System.  The Harvest copyright text follows to acknowledge the origin:
 
 ==============================================================================
 
-lib/base64.c::base64_encode():
+acinclude/ax_cxx_0x_types.m4:
 
-Adopted from http://ftp.sunet.se/pub2/gnu/vm/base64-encode.c.
-Modified to work with strings instead of files.
+##
+## AX_CXX_TYPE_NULLPTR shamelessly copied from the DUNE sources under GPL version 2
+##
 
 ==============================================================================
 
-lib/snmplib/*:
-include/{asn1.h,parse.h,snmp*}:
+acinclude/ax_cxx_compile_stdcxx_11.m4:
 
-The SNMP library code is developed by Carnegie Mellon University.
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014 Alexey Sokolov <sokolov@google.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
 
-/***************************************************************************
+==============================================================================
+
+acinclude/ax_with_prog.m4:
+
+dnl   Copyright (c) 2008 Francesco Salvestrini <salvestrini@users.sourceforge.net>
+dnl   Copyright (c) 2008 Dustin J. Mitchell <dustin@cs.uchicago.edu>
+dnl
+dnl   Copying and distribution of this file, with or without modification, are
+dnl   permitted in any medium without royalty provided the copyright notice
+dnl   and this notice are preserved.
+
+==============================================================================
+
+acinclude/pkg.m4:
+
+# Copyright Â© 2004 Scott James Remnant <scott@netsplit.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+==============================================================================
+
+compat/os/opensolaris_10_netdb.h:
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+/*      Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T     */
+/*        All Rights Reserved   */
+
+/*
+ * BIND 4.9.3:
  *
- *           Copyright 1997 by Carnegie Mellon University
- * 
- *                       All Rights Reserved
- * 
- * Permission to use, copy, modify, and distribute this software and its
- * documentation for any purpose and without fee is hereby granted,
- * provided that the above copyright notice appear in all copies and that
- * both that copyright notice and this permission notice appear in
- * supporting documentation, and that the name of CMU not be
- * used in advertising or publicity pertaining to distribution of the
- * software without specific, written prior permission.
- * 
- * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
- * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
- * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
- * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
- * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * Copyright (c) 1980, 1983, 1988, 1993
+ *      The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * -
+ * Portions Copyright (c) 1993 by Digital Equipment Corporation.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies, and that
+ * the name of Digital Equipment Corporation not be used in advertising or
+ * publicity pertaining to distribution of the document or software without
+ * specific, written prior permission.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
+ * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
+ * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
- * 
- ***************************************************************************/
+ * --Copyright--
+ *
+ * End BIND 4.9.3
+ */
 
 ==============================================================================
 
-lib/GNUregex.c:
+compat/eui64_aton.h:
 
-/* Extended regular expression matching and search library,
- * version 0.12.
- * (Implements POSIX draft P10003.2/D11.2, except for
- * internationalization features.)
+/*      $NetBSD: eui64.h,v 1.1 2005/07/11 15:35:25 kiyohara Exp $       */
+/*-
+ * Copyright 2004 The Aerospace Corporation.  All rights reserved.
  *
- * Copyright (C) 1993 Free Software Foundation, Inc.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions, and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions, and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  The name of The Aerospace Corporation may not be used to endorse or
+ *     promote products derived from this software.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * THIS SOFTWARE IS PROVIDED BY THE AEROSPACE CORPORATION "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AEROSPACE CORPORATION BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
+ * $FreeBSD: /repoman/r/ncvs/src/sys/sys/eui64.h,v 1.2 2005/01/07 02:29:23 imp Exp $
+ */
 
 ==============================================================================
 
-lib/md5.c:
+compat/eui64_aton.c:
 
+/*      $NetBSD: eui64.c,v 1.1 2005/07/11 15:35:25 kiyohara Exp $       */
 /*
- * This code implements the MD5 message-digest algorithm.
- * The algorithm is due to Ron Rivest.  This code was
- * written by Colin Plumb in 1993, no copyright is claimed.
- * This code is in the public domain; do with it what you wish.
+ * Copyright 2004 The Aerospace Corporation.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
  *
- * Equivalent code is available from RSA Data Security, Inc.
- * This code has been tested against that, and is equivalent,
- * except that you don't need to include two pages of legalese
- * with every copy.
- *
- * To compute the message digest of a chunk of bytes, declare an
- * SquidMD5Context structure, pass it to SquidMD5Init, call
- * SquidMD5Update as needed on buffers full of bytes, and then call
- * SquidMD5Final, which will fill a supplied 16-byte array with the
- * digest.
- *
- * Changed so as no longer to depend on Colin Plumb's `usual.h' header
- * definitions; now uses stuff from dpkg's config.h.
- *  - Ian Jackson <ian@chiark.greenend.org.uk>.
- * Still in the public domain.
- *
- * Changed SquidMD5Update to take a void * for easier use and some
- * other minor cleanup. - Henrik Nordstrom <henrik@henriknordstrom.net>.
- * Still in the public domain.
- *
- * Prefixed all symbols with "Squid" so they don't collide with
- * other libraries.  Duane Wessels <wessels@squid-cache.org>.
- * Still in the public domain.
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions, and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions, and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  The name of The Aerospace Corporation may not be used to endorse or
+ *     promote products derived from this software.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AEROSPACE CORPORATION "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AEROSPACE CORPORATION BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Copyright (c) 1995
+ *      Bill Paul <wpaul@ctr.columbia.edu>.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by Bill Paul.
+ * 4. Neither the name of the author nor the names of any co-contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * EUI-64 conversion and lookup routines
+ *
+ *
+ * Converted from ether_addr.c rev
+ * FreeBSD: src/lib/libc/net/eui64.c,v 1.15 2002/04/08 07:51:10 ru Exp
+ * by Brooks Davis
+ *
+ * Written by Bill Paul <wpaul@ctr.columbia.edu>
+ * Center for Telecommunications Research
+ * Columbia University, New York City
  */
 
 ==============================================================================
 
-lib/radix.c:
+compat/getaddrinfo.h,
+compat/getaddrinfo.c:
 
 /*
- * Copyright (c) 1988, 1989, 1993
- *      The Regents of the University of California.  All rights reserved.
+ *  This file is part of libESMTP, a library for submission of RFC 2822
+ *  formatted electronic mail messages using the SMTP protocol described
+ *  in RFC 2821.
+ *
+ *  Copyright (C) 2001,2002  Brian Stafford  <brian@stafford.uklinux.net>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Structure and prototypes taken from RFC 2553 */
+
+==============================================================================
+
+compat/getnameinfo.c:
+
+/*      KAME: getnameinfo.c,v 1.72 2005/01/13 04:12:03 itojun Exp       */
+
+/*
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -220,68 +364,133 @@ lib/radix.c:
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- *
- *      @(#)radix.c     8.4 (Berkeley) 11/2/94
  */
 
 ==============================================================================
 
-lib/tempnam.c:
+compat/GnuRegex.h:
+
+ * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+
+==============================================================================
+
+compat/GnuRegex.c:
+
+ * Copyright (C) 1993 Free Software Foundation, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
 
-/* A reasonably functional tmpnam. */
+==============================================================================
 
-/* Originally by Tom Hageman, tom@basil.icce.rug.nl */
+compat/inet_ntop.c:
 
 /*
- * This tmpnam() was changed by Gerben_Wierda@RnA.nl to serve as
- * tempnam() for squid-1.1.6. It ignores the directory parameter, every
- * temp file is written in /tmp.
+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 ==============================================================================
 
-lib/drand48.c:
+compat/inet_pton.c:
 
-From Linux libc-5.4.46.
+/*
+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1996,1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
 
 ==============================================================================
 
-lib/eui64_aton.h lib/eui64_aton.c:
+compat/strtoll.c:
 
 /*-
- * Copyright 2004 The Aerospace Corporation.  All rights reserved.
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
  *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions, and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions, and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 3.  The name of The Aerospace Corporation may not be used to endorse or
- *     promote products derived from this software.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AEROSPACE CORPORATION "AS IS" AND
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AEROSPACE CORPORATION BE LIABLE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
@@ -293,18 +502,45 @@ lib/eui64_aton.h lib/eui64_aton.c:
 
 ==============================================================================
 
-mcast_encode() in src/access_log.c is derived from Mark Atkinson's
-(mark_a@cix.compulink.co.uk) "Tiny Encryption Algorithm".
-http://www.io.com/~paulhart/game/algorithms/tea.html
+compat/tempnam.h:
+
+ * Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
+ * This file is part of the GNU C Library.
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with the GNU C Library; see the file COPYING.LIB.  If
+ * not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+ * Cambridge, MA 02139, USA.
+
+==============================================================================
+
+compat/tempnam.c:
+
+/* Originally by Tom Hageman, tom@basil.icce.rug.nl */
+
+/*
+ * This tmpnam() was changed by Gerben_Wierda@RnA.nl to serve as
+ * tempnam() for squid-1.1.6. It ignores the directory parameter, every
+ * temp file is written in /tmp.
+ */
 
 ==============================================================================
 
-lib/strnstr.cc:
+compat/strnstr.cc:
 
 /*-
  * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
  * Copyright (c) 1990, 1993
- *	The Regents of the University of California.  All rights reserved.
+ *      The Regents of the University of California.  All rights reserved.
  *
  * This code is derived from software contributed to Berkeley by
  * Chris Torek.
@@ -333,14 +569,14 @@ lib/strnstr.cc:
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#)strstr.c	8.1 (Berkeley) 6/4/93
+ * @(#)strstr.c 8.1 (Berkeley) 6/4/93
  * $FreeBSD: src/lib/libc/string/strnstr.c,v 1.2.2.1 2001/12/09 06:50:03 mike Exp $
  * $DragonFly: src/lib/libc/string/strnstr.c,v 1.4 2006/03/20 17:24:20 dillon Exp $
  */
 
 ==============================================================================
 
-lib/xstrto.cc:
+compat/xstrto.cc:
 
 /*
  * (C) 2000-2006 by the netfilter coreteam <coreteam@netfilter.org>:
@@ -362,6 +598,251 @@ lib/xstrto.cc:
 
 ==============================================================================
 
+icons/silk/:
+
+  Silk icon set 1.3
+  _________________________________________
+  Mark James
+  http://www.famfamfam.com/lab/icons/silk/
+  _________________________________________
+
+  This work is licensed under a
+  Creative Commons Attribution 2.5 License.
+  [ http://creativecommons.org/licenses/by/2.5/ ]
+
+  This means you may use it for any purpose,
+  and make any changes you like.
+  All I ask is that you include a link back
+  to this page in your credits.
+
+  Are you using this icon set? Send me an email
+  (including a link or picture if available) to
+  mjames@gmail.com
+
+  Any other questions about this icon set please
+  contact mjames@gmail.com
+
+
+  The icons can also be used under Creative Commons Attribution 3.0 License
+  (Hi Debian folks!) with the following requirements:
+
+    As an author, I would appreciate a reference to my authorship of
+    the Silk icon set contents within a readme file or equivalent
+    documentation for the software which includes the set or a subset
+    of the icons contained within. 
+
+==============================================================================
+
+icons/SN.png:
+
+  Squid NOW icon - copyright Squid Project
+
+  This work is licensed under the
+  Creative Commons Attribution-ShareAlike 3.0 Unported Liscence (CC BY-SA 3.0)
+  [ http://creativecommons.org/licenses/by-sa/3.0/ ]
+
+==============================================================================
+
+include/asn1.h,
+include/snmp_api_error.h,
+include/snmp_api_util.h,
+include/snmp_coexist.h,
+include/snmp_error.h,
+include/snmp-internal.h,
+include/snmp-mib.h,
+include/snmp_msg.h,
+include/snmp_pdu.h,
+include/snmp_session.h,
+include/snmp_vars.h,
+include/snmp.h:
+
+ *           Copyright 1997 by Carnegie Mellon University
+ *
+ *                       All Rights Reserved
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of CMU not be
+ * used in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.
+ *
+ * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+
+==============================================================================
+
+include/heap.h,
+lib/heap.cc:
+
+ * Copyright (C) 1999 by Hewlett Packard
+
+==============================================================================
+
+include/md5.h,
+lib/md5.c:
+
+ * The algorithm is due to Ron Rivest.  This code was
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+
+==============================================================================
+
+include/parse.h,
+include/snmp_api.h:
+
+/***********************************************************
+        Copyright 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+==============================================================================
+
+include/radix.h,
+lib/radix.c:
+
+ * Copyright (c) 1988, 1989, 1993
+ *      The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+
+==============================================================================
+
+include/rfc2617.h:
+
+ * The source in this file is derived from the reference implementation
+ * in RFC 2617.
+ * RFC 2617 is Copyright (C) The Internet Society (1999).  All Rights Reserved.
+
+==============================================================================
+
+include/snmp_client.h,
+include/snmp_impl.h:
+
+/***********************************************************
+        Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+==============================================================================
+
+include/snmp_util.h:
+
+ * Copyright (c) 1997 FT/CNET/DES/GRL Olivier Montanuy
+
+==============================================================================
+
+lib/base64.c::base64_encode():
+
+Adopted from http://ftp.sunet.se/pub2/gnu/vm/base64-encode.c.
+Modified to work with strings instead of files.
+
+==============================================================================
+
+lib/snmplib/*:
+
+The SNMP library code is developed by Carnegie Mellon University.
+
+/***************************************************************************
+ *
+ *           Copyright 1997 by Carnegie Mellon University
+ * 
+ *                       All Rights Reserved
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of CMU not be
+ * used in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.
+ * 
+ * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ * 
+ ***************************************************************************/
+
+==============================================================================
+
+lib/drand48.c:
+
+From Linux libc-5.4.46.
+
+==============================================================================
+
+mcast_encode() in src/access_log.c is derived from Mark Atkinson's
+(mark_a@cix.compulink.co.uk) "Tiny Encryption Algorithm".
+http://www.io.com/~paulhart/game/algorithms/tea.html
+
+==============================================================================
+
 lib/getopt.c:
 
 /*
@@ -475,14 +956,6 @@ helpers/url_rewrite/fake/ fake.cc, url_fake_rewrite.sh:
 
 ==============================================================================
 
-include/rfc3596.h lib/rfc3596.cc:
-
- This code is copyright (C) 2007-2009 by Treehouse Networks Ltd
- of New Zealand. It is published and Licensed as an extension of
- squid under the same conditions as the main squid application.
-
-==============================================================================
-
 helpers/negotiate_auth/kerberos/ *
 
 /*
@@ -545,51 +1018,6 @@ helpers/log_daemon/DB/log_db_daemon.pl.in:
 
 ==============================================================================
 
-icons/SN.png:
-
-  Squid NOW icon - copyright Squid Project
-
-  This work is licensed under the
-  Creative Commons Attribution-ShareAlike 3.0 Unported Liscence (CC BY-SA 3.0)
-  [ http://creativecommons.org/licenses/by-sa/3.0/ ]
-
-==============================================================================
-
-icons/silk/:
-
-  Silk icon set 1.3
-  _________________________________________
-  Mark James
-  http://www.famfamfam.com/lab/icons/silk/
-  _________________________________________
-
-  This work is licensed under a
-  Creative Commons Attribution 2.5 License.
-  [ http://creativecommons.org/licenses/by/2.5/ ]
-
-  This means you may use it for any purpose,
-  and make any changes you like.
-  All I ask is that you include a link back
-  to this page in your credits.
-
-  Are you using this icon set? Send me an email
-  (including a link or picture if available) to
-  mjames@gmail.com
-
-  Any other questions about this icon set please
-  contact mjames@gmail.com
-
-
-  The icons can also be used under Creative Commons Attribution 3.0 License
-  (Hi Debian folks!) with the following requirements:
-
-    As an author, I would appreciate a reference to my authorship of
-    the Silk icon set contents within a readme file or equivalent
-    documentation for the software which includes the set or a subset
-    of the icons contained within. 
-
-==============================================================================
-
 shm_portable_segment_name_is_path() implementation:
 
   Derived from boost/interprocess/shared_memory_object.hpp and
@@ -38,7 +38,6 @@ EXTRA_DIST = \
 	ChangeLog \
 	CONTRIBUTORS \
 	COPYING \
-	COPYRIGHT \
 	CREDITS \
 	INSTALL \
 	QUICKSTART \
@@ -1,6 +1,12 @@
 
-SQUID Web Proxy Cache        http://www.squid-cache.org/
---------------------------------------------------------
+SQUID Web Proxy Cache                         http://www.squid-cache.org/
+-------------------------------------------------------------------------
+
+Copyright (C) 1996-2013 The Squid Software Foundation and contributors
+
+Squid software is distributed under GPLv2+ license and includes 
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -13,12 +19,7 @@ SQUID Web Proxy Cache        http://www.squid-cache.org/
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
-Squid is derived from the ``cached'' software from the ARPA-funded
-Harvest research project.   Squid includes software copyrighted
-by others.  See the COPYRIGHT file for details.
+  along with this program. If not, see http://www.gnu.org/licenses/.
 
 Please use our mailing lists for questions, feedback and bug fixes:
 
@@ -1,6 +1,5 @@
-In addition to the numerous volunteer developers (see CONTRIBUTORS),
-the following organizations have provided non-financial support for
-the Squid Project:
+The following organizations have supported the Squid Project by providing
+their resources or funding various Squid development activities:
 
 @Squid-3.4:
 LaunchPad - http://launchpad.net/
@@ -1,4 +1,12 @@
-## Shamelessly copied from the DUNE sources under GPL version 2
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+##
+## AX_CXX_TYPE_NULLPTR shamelessly copied from the DUNE sources under GPL version 2
 ## 
 AC_DEFUN([AX_CXX_TYPE_NULLPTR],[
   AC_REQUIRE([AC_PROG_CXX])
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 # ============================================================================
 #  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.html
 # ============================================================================
@@ -0,0 +1,78 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+dnl ===========================================================================
+dnl              http://autoconf-archive.cryp.to/ax_with_prog.html
+dnl ===========================================================================
+dnl
+dnl SYNOPSIS
+dnl
+dnl   AX_WITH_PROG([VARIABLE],[program],[VALUE-IF-NOT-FOUND],[PATH])
+dnl
+dnl DESCRIPTION
+dnl
+dnl   Locates an installed program binary, placing the result in the precious
+dnl   variable VARIABLE. Accepts a present VARIABLE, then --with-program, and
+dnl   failing that searches for program in the given path (which defaults to
+dnl   the system path). If program is found, VARIABLE is set to the full path
+dnl   of the binary; if it is not found VARIABLE is set to VALUE-IF-NOT-FOUND
+dnl   if provided, unchanged otherwise.
+dnl
+dnl   A typical example could be the following one:
+dnl
+dnl         AX_WITH_PROG(PERL,perl)
+dnl
+dnl   NOTE: This macro is based upon the original AX_WITH_PYTHON macro from
+dnl   Dustin J. Mitchell <dustin@cs.uchicago.edu>.
+dnl
+dnl LAST MODIFICATION
+dnl
+dnl   2008-05-05
+dnl
+dnl COPYLEFT
+dnl
+dnl   Copyright (c) 2008 Francesco Salvestrini <salvestrini@users.sourceforge.net>
+dnl   Copyright (c) 2008 Dustin J. Mitchell <dustin@cs.uchicago.edu>
+dnl
+dnl   Copying and distribution of this file, with or without modification, are
+dnl   permitted in any medium without royalty provided the copyright notice
+dnl   and this notice are preserved.
+dnl
+AC_DEFUN([AX_WITH_PROG],[
+    AC_PREREQ([2.61])
+
+    pushdef([VARIABLE],$1)
+    pushdef([EXECUTABLE],$2)
+    pushdef([VALUE_IF_NOT_FOUND],$3)
+    pushdef([PATH_PROG],$4)
+
+    AC_ARG_VAR(VARIABLE,Absolute path to EXECUTABLE executable)
+
+    AS_IF(test -z "$VARIABLE",[
+    	AC_MSG_CHECKING(whether EXECUTABLE executable path has been provided)
+        AC_ARG_WITH(EXECUTABLE,AS_HELP_STRING([--with-EXECUTABLE=[[[[PATH]]]]],absolute path to EXECUTABLE executable), [
+	    AS_IF([test "$withval" != "yes"],[
+	        VARIABLE="$withval"
+		AC_MSG_RESULT($VARIABLE)
+	    ],[
+		VARIABLE=""
+	        AC_MSG_RESULT([no])
+	    ])
+	],[
+	    AC_MSG_RESULT([no])
+	])
+
+        AS_IF(test -z "$VARIABLE",[
+	    AC_PATH_PROG([]VARIABLE[],[]EXECUTABLE[],[]VALUE_IF_NOT_FOUND[],[]PATH_PROG[])
+        ])
+    ])
+
+    popdef([PATH_PROG])
+    popdef([VALUE_IF_NOT_FOUND])
+    popdef([EXECUTABLE])
+    popdef([VARIABLE])
+])
@@ -1,31 +1,9 @@
-dnl 
-dnl AUTHOR: Francesco Chemolli
-dnl
-dnl SQUID Web Proxy Cache          http://www.squid-cache.org/
-dnl ----------------------------------------------------------
-dnl Squid is the result of efforts by numerous individuals from
-dnl the Internet community; see the CONTRIBUTORS file for full
-dnl details.   Many organizations have provided support for Squid's
-dnl development; see the SPONSORS file for full details.  Squid is
-dnl Copyrighted (C) 2001 by the Regents of the University of
-dnl California; see the COPYRIGHT file for full details.  Squid
-dnl incorporates software developed and/or copyrighted by other
-dnl sources; see the CREDITS file for full details.
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 # check if the compiler accepts a supplied flag
 # first argument is the variable containing the result 
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 dnl This encapsulates the nasty mess of headers we need to check when 
 dnl checking types.
 AC_DEFUN([SQUID_DEFAULT_INCLUDES],[[
@@ -60,75 +67,3 @@ SQUID_DEFAULT_INCLUDES
 #include <netinet/ip_fil.h>
 #endif
 ])
-
-dnl ===========================================================================
-dnl              http://autoconf-archive.cryp.to/ax_with_prog.html
-dnl ===========================================================================
-dnl
-dnl SYNOPSIS
-dnl
-dnl   AX_WITH_PROG([VARIABLE],[program],[VALUE-IF-NOT-FOUND],[PATH])
-dnl
-dnl DESCRIPTION
-dnl
-dnl   Locates an installed program binary, placing the result in the precious
-dnl   variable VARIABLE. Accepts a present VARIABLE, then --with-program, and
-dnl   failing that searches for program in the given path (which defaults to
-dnl   the system path). If program is found, VARIABLE is set to the full path
-dnl   of the binary; if it is not found VARIABLE is set to VALUE-IF-NOT-FOUND
-dnl   if provided, unchanged otherwise.
-dnl
-dnl   A typical example could be the following one:
-dnl
-dnl         AX_WITH_PROG(PERL,perl)
-dnl
-dnl   NOTE: This macro is based upon the original AX_WITH_PYTHON macro from
-dnl   Dustin J. Mitchell <dustin@cs.uchicago.edu>.
-dnl
-dnl LAST MODIFICATION
-dnl
-dnl   2008-05-05
-dnl
-dnl COPYLEFT
-dnl
-dnl   Copyright (c) 2008 Francesco Salvestrini <salvestrini@users.sourceforge.net>
-dnl   Copyright (c) 2008 Dustin J. Mitchell <dustin@cs.uchicago.edu>
-dnl
-dnl   Copying and distribution of this file, with or without modification, are
-dnl   permitted in any medium without royalty provided the copyright notice
-dnl   and this notice are preserved.
-dnl
-AC_DEFUN([AX_WITH_PROG],[
-    AC_PREREQ([2.61])
-
-    pushdef([VARIABLE],$1)
-    pushdef([EXECUTABLE],$2)
-    pushdef([VALUE_IF_NOT_FOUND],$3)
-    pushdef([PATH_PROG],$4)
-
-    AC_ARG_VAR(VARIABLE,Absolute path to EXECUTABLE executable)
-
-    AS_IF(test -z "$VARIABLE",[
-    	AC_MSG_CHECKING(whether EXECUTABLE executable path has been provided)
-        AC_ARG_WITH(EXECUTABLE,AS_HELP_STRING([--with-EXECUTABLE=[[[[PATH]]]]],absolute path to EXECUTABLE executable), [
-	    AS_IF([test "$withval" != "yes"],[
-	        VARIABLE="$withval"
-		AC_MSG_RESULT($VARIABLE)
-	    ],[
-		VARIABLE=""
-	        AC_MSG_RESULT([no])
-	    ])
-	],[
-	    AC_MSG_RESULT([no])
-	])
-
-        AS_IF(test -z "$VARIABLE",[
-	    AC_PATH_PROG([]VARIABLE[],[]EXECUTABLE[],[]VALUE_IF_NOT_FOUND[],[]PATH_PROG[])
-        ])
-    ])
-
-    popdef([PATH_PROG])
-    popdef([VALUE_IF_NOT_FOUND])
-    popdef([EXECUTABLE])
-    popdef([VARIABLE])
-])
@@ -1,30 +1,9 @@
-dnl 
-dnl AUTHOR: Squid Web Cache team
-dnl
-dnl SQUID Web Proxy Cache          http://www.squid-cache.org/
-dnl ----------------------------------------------------------
-dnl Squid is the result of efforts by numerous individuals from
-dnl the Internet community; see the CONTRIBUTORS file for full
-dnl details.   Many organizations have provided support for Squid's
-dnl development; see the SPONSORS file for full details.  Squid is
-dnl Copyrighted (C) 2001 by the Regents of the University of
-dnl California; see the COPYRIGHT file for full details.  Squid
-dnl incorporates software developed and/or copyrighted by other
-dnl sources; see the CREDITS file for full details.
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 dnl these checks must be performed in the same order as here defined,
 dnl and have mostly been lifted out of an inlined configure.ac.
@@ -140,22 +119,26 @@ dnl checks that gssapi is ok, and sets squid_cv_working_gssapi accordingly
 AC_DEFUN([SQUID_CHECK_WORKING_GSSAPI], [
   AC_CACHE_CHECK([for working gssapi], squid_cv_working_gssapi, [
     AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#ifdef HAVE_HEIMDAL_KERBEROS
-#ifdef HAVE_GSSAPI_GSSAPI_H
+#if USE_HEIMDAL_KRB5
+#if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
-#elif defined(HAVE_GSSAPI_H)
+#elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif
+#elif USE_GNUGSS
+#if HAVE_GSS_H
+#include <gss.h>
+#endif
 #else
-#ifdef HAVE_GSSAPI_GSSAPI_H
+#if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
-#elif defined(HAVE_GSSAPI_H)
+#elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif
-#ifdef HAVE_GSSAPI_GSSAPI_KRB5_H
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
 #include <gssapi/gssapi_krb5.h>
 #endif
-#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
+#if HAVE_GSSAPI_GSSAPI_GENERIC_H
 #include <gssapi/gssapi_generic.h>
 #endif
 #endif
@@ -170,29 +153,35 @@ main(void)
         return 0;
 }
   ]])],  [ squid_cv_working_gssapi=yes ], [ squid_cv_working_gssapi=no ], [:])])
+if test "x$squid_cv_working_gssapi" = "xno" -a `echo $LIBS | grep -i -c "\-L"` -gt 0; then
+  AC_MSG_NOTICE([Check Runtime library path !])
+fi
 ])
 
-
 dnl check for a working spnego, and set squid_cv_have_spnego
 AC_DEFUN([SQUID_CHECK_SPNEGO_SUPPORT], [
   AC_CACHE_CHECK([for spnego support], squid_cv_have_spnego, [
     AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#ifdef HAVE_HEIMDAL_KERBEROS
-#ifdef HAVE_GSSAPI_GSSAPI_H
+#if USE_HEIMDAL_KRB5
+#if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
-#elif defined(HAVE_GSSAPI_H)
+#elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif
+#elif USE_GNUGSS
+#if HAVE_GSS_H
+#include <gss.h>
+#endif
 #else
-#ifdef HAVE_GSSAPI_GSSAPI_H
+#if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
-#elif defined(HAVE_GSSAPI_H)
+#elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif
-#ifdef HAVE_GSSAPI_GSSAPI_KRB5_H
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
 #include <gssapi/gssapi_krb5.h>
 #endif
-#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
+#if HAVE_GSSAPI_GSSAPI_GENERIC_H
 #include <gssapi/gssapi_generic.h>
 #endif
 #endif
@@ -223,7 +212,7 @@ dnl checks that krb5 is functional. Sets squid_cv_working_krb5
 AC_DEFUN([SQUID_CHECK_WORKING_KRB5],[
   AC_CACHE_CHECK([for working krb5], squid_cv_working_krb5, [
     AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#ifdef HAVE_KRB5_H
+#if HAVE_KRB5_H
 #if HAVE_BROKEN_SOLARIS_KRB5_H
 #if defined(__cplusplus)
 #define KRB5INT_BEGIN_DECLS     extern "C" {
@@ -250,4 +239,83 @@ main(void)
         return 0;
 }
   ]])], [ squid_cv_working_krb5=yes ], [ squid_cv_working_krb5=no ],[:])])
+if test "x$squid_cv_working_krb5" = "xno" -a `echo $LIBS | grep -i -c "\-L"` -gt 0; then
+  AC_MSG_NOTICE([Check Runtime library path !])
+fi
+])
+
+
+dnl checks for existence of krb5 functions
+AC_DEFUN([SQUID_CHECK_KRB5_FUNCS],[
+
+  AC_CHECK_LIB(krb5,krb5_get_err_text,
+    AC_DEFINE(HAVE_KRB5_GET_ERR_TEXT,1,
+      [Define to 1 if you have krb5_get_err_text]),)
+  AC_CHECK_LIB(krb5,krb5_get_error_message,
+    AC_DEFINE(HAVE_KRB5_GET_ERROR_MESSAGE,1,
+      [Define to 1 if you have krb5_get_error_message]),)
+  AC_CHECK_DECLS(krb5_kt_free_entry,,,[#include <krb5.h>])
+  AC_CHECK_TYPE(krb5_pac,
+    AC_DEFINE(HAVE_KRB5_PAC,1,
+      [Define to 1 if you have krb5_pac]),,
+      [#include <krb5.h>])
+  AC_CHECK_LIB(krb5,krb5_kt_free_entry,
+    AC_DEFINE(HAVE_KRB5_KT_FREE_ENTRY,1,
+      [Define to 1 if you have krb5_kt_free_entry]),)
+  AC_CHECK_LIB(krb5,krb5_get_init_creds_keytab,
+    AC_DEFINE(HAVE_GET_INIT_CREDS_KEYTAB,1,
+      [Define to 1 if you have krb5_get_init_creds_keytab]),)
+  AC_CHECK_LIB(krb5,krb5_get_max_time_skew,
+    AC_DEFINE(HAVE_KRB5_GET_MAX_TIME_SKEW,1,
+      [Define to 1 if you have krb5_get_max_time_skew]),)
+  AC_CHECK_LIB(krb5,krb5_get_profile,
+    AC_DEFINE(HAVE_KRB5_GET_PROFILE,1,
+      [Define to 1 if you have krb5_get_profile]),)
+  AC_CHECK_LIB(krb5,profile_get_integer,
+    AC_DEFINE(HAVE_PROFILE_GET_INTEGER,1,
+      [Define to 1 if you have profile_get_integer]),)
+  AC_CHECK_LIB(krb5,profile_release,
+    AC_DEFINE(HAVE_PROFILE_RELEASE,1,
+      [Define to 1 if you have profile_release]),)
+  AC_CHECK_LIB(krb5,krb5_get_renewed_creds,
+    AC_DEFINE(HAVE_KRB5_GET_RENEWED_CREDS,1,
+      [Define to 1 if you have krb5_get_renewed_creds]),)
+  AC_CHECK_LIB(krb5,krb5_principal_get_realm,
+    AC_DEFINE(HAVE_KRB5_PRINCIPAL_GET_REALM,1,
+      [Define to 1 if you have krb5_principal_get_realm]),)
+  AC_CHECK_LIB(krb5, krb5_get_init_creds_opt_alloc,
+    AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC,1,
+      [Define to 1 if you have krb5_get_init_creds_opt_alloc]),)
+  AC_MSG_CHECKING([for krb5_get_init_creds_free requires krb5_context])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	#include <krb5.h>
+    ]],[[krb5_context context;
+	 krb5_get_init_creds_opt *options;
+	 krb5_get_init_creds_opt_free(context, options)]])],[
+	AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT,1,
+		  [Define to 1 if you krb5_get_init_creds_free requires krb5_context])
+	AC_MSG_RESULT(yes)
+    ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
+
+
+  AC_CHECK_FUNCS(gss_map_name_to_any,
+    AC_DEFINE(HAVE_GSS_MAP_ANY_TO_ANY,1,
+      [Define to 1 if you have gss_map_name_to_any]),)
+  AC_CHECK_FUNCS(gsskrb5_extract_authz_data_from_sec_context,
+    AC_DEFINE(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT,1,
+      [Define to 1 if you have gsskrb5_extract_authz_data_from_sec_context]),)
+
+  SQUID_CHECK_KRB5_CONTEXT_MEMORY_CACHE
+  SQUID_DEFINE_BOOL(HAVE_KRB5_MEMORY_CACHE,$squid_cv_memory_cache,
+       [Define if kerberos has MEMORY: cache support])
+
+  SQUID_CHECK_WORKING_GSSAPI
+  SQUID_DEFINE_BOOL(HAVE_GSSAPI,$squid_cv_working_gssapi,[GSSAPI support])
+
+  SQUID_CHECK_SPNEGO_SUPPORT
+  SQUID_DEFINE_BOOL(HAVE_SPNEGO,$squid_cv_have_spnego,[SPNEGO support])
+
+  SQUID_CHECK_WORKING_KRB5
+  SQUID_DEFINE_BOOL(HAVE_KRB5,$squid_cv_working_krb5,[KRB5 support])
 ])
+
@@ -1,31 +1,9 @@
-dnl 
-dnl AUTHOR: Squid Web Cache team
-dnl
-dnl SQUID Web Proxy Cache          http://www.squid-cache.org/
-dnl ----------------------------------------------------------
-dnl Squid is the result of efforts by numerous individuals from
-dnl the Internet community; see the CONTRIBUTORS file for full
-dnl details.   Many organizations have provided support for Squid's
-dnl development; see the SPONSORS file for full details.  Squid is
-dnl Copyrighted (C) 2001 by the Regents of the University of
-dnl California; see the COPYRIGHT file for full details.  Squid
-dnl incorporates software developed and/or copyrighted by other
-dnl sources; see the CREDITS file for full details.
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 dnl checks whether dbopen needs -ldb to be added to libs
 dnl sets ac_cv_dbopen_libdb to either "yes" or "no"
@@ -1,31 +1,9 @@
-dnl 
-dnl AUTHOR: Squid Web Cache team
-dnl
-dnl SQUID Web Proxy Cache          http://www.squid-cache.org/
-dnl ----------------------------------------------------------
-dnl Squid is the result of efforts by numerous individuals from
-dnl the Internet community; see the CONTRIBUTORS file for full
-dnl details.   Many organizations have provided support for Squid's
-dnl development; see the SPONSORS file for full details.  Squid is
-dnl Copyrighted (C) 2001 by the Regents of the University of
-dnl California; see the COPYRIGHT file for full details.  Squid
-dnl incorporates software developed and/or copyrighted by other
-dnl sources; see the CREDITS file for full details.
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 dnl check that strnstr() works fine. On Macos X it can cause a buffer overrun
 dnl sets squid_cv_func_strnstr to "yes" or "no", and defines HAVE_STRNSTR
@@ -180,7 +158,7 @@ AC_DEFUN([SQUID_CHECK_FUNCTIONAL_LIBCAP2],[
 ])
 
 
-dnl Ripped from Samba. Thanks!
+dnl From Samba. Thanks!
 dnl check that we have Unix sockets. Sets squid_cv_unixsocket to either yes or no depending on the check
 
 AC_DEFUN([SQUID_CHECK_UNIX_SOCKET],[
@@ -1,33 +1,9 @@
-dnl 
-dnl AUTHOR: Francesco Chemolli <kinkie@squid-cache.org>
-dnl
-dnl SQUID Web Proxy Cache          http://www.squid-cache.org/
-dnl ----------------------------------------------------------
-dnl Squid is the result of efforts by numerous individuals from
-dnl the Internet community; see the CONTRIBUTORS file for full
-dnl details.   Many organizations have provided support for Squid's
-dnl development; see the SPONSORS file for full details.  Squid is
-dnl Copyrighted (C) 2001 by the Regents of the University of
-dnl California; see the COPYRIGHT file for full details.  Squid
-dnl incorporates software developed and/or copyrighted by other
-dnl sources; see the CREDITS file for full details.
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
-
-
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 dnl check whether PAM's struct pam_conv takes a const (linux-style) or
 dnl non-const (solaris-style) parametrs to the conv function.
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 # pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
 # serial 1 (pkg-config-0.24)
 # 
@@ -1,30 +1,9 @@
-dnl 
-dnl AUTHOR: Francesco Chemolli
-dnl
-dnl SQUID Web Proxy Cache          http://www.squid-cache.org/
-dnl ----------------------------------------------------------
-dnl Squid is the result of efforts by numerous individuals from
-dnl the Internet community; see the CONTRIBUTORS file for full
-dnl details.   Many organizations have provided support for Squid's
-dnl development; see the SPONSORS file for full details.  Squid is
-dnl Copyrighted (C) 2001 by the Regents of the University of
-dnl California; see the COPYRIGHT file for full details.  Squid
-dnl incorporates software developed and/or copyrighted by other
-dnl sources; see the CREDITS file for full details.
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 dnl save main environment variables to variables to the namespace defined by the
 dnl first argument (prefix)
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /* Extended regular expression matching and search library,
  * version 0.12.
  * (Implements POSIX draft P10003.2/D11.2, except for
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_REGEXP_LIBRARY_H
 #define SQUID_REGEXP_LIBRARY_H
 
@@ -1,3 +1,9 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+
 #
 #  Makefile for the Squid Portability Library
 #
@@ -1,32 +1,9 @@
 /*
- * AUTHOR: Henrik Nordstrom
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
@@ -1,33 +1,11 @@
 /*
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
+
 #ifndef SQUID_ASSERT_H
 #define SQUID_ASSERT_H
 
@@ -1,9 +1,18 @@
 /*
- * Compatibility-layer for CMSG_
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
+
 #ifndef SQUID_COMPAT_CMSG_H
 #define SQUID_COMPAT_CMSG_H
 
+/*
+ * Compatibility-layer for CMSG_
+ */
+
 // cmsg.h is found through sys/socket.h
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat.h"
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_H
 #define _SQUID_COMPAT_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_SHARED_H
 #define _SQUID_COMPAT_SHARED_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_CPPUNIT_H
 #define SQUID_COMPAT_CPPUNIT_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_CPU_H
 #define SQUID_COMPAT_CPU_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat/debug.h"
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef COMPAT_DEBUG_H
 #define COMPAT_DEBUG_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 
 /* borrowed from libc/misc/drand48.c in Linux libc-5.4.46 this quick
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_DRAND48_H
 #define _SQUID_DRAND48_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  * Squid Change History:
  *
@@ -1,3 +1,14 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_COMPAT_EUI64_ATON_H
+#define SQUID_COMPAT_EUI64_ATON_H
+
 /* If we have this system file use it. Otherwise use the below definitions. */
 #if HAVE_SYS_EUI64_H
 #include <sys/eui64.h>
@@ -42,7 +53,7 @@
  */
 #ifndef _SYS_EUI64_H
 #define _SYS_EUI64_H
-#ifdef __cplusplus
+#if defined(__cplusplus)
 extern "C" {
 #endif
 
@@ -66,9 +77,10 @@ extern "C" {
     };
 
     int eui64_aton(const char *a, struct eui64 *e);
-#ifdef __cplusplus
+#if defined(__cplusplus)
 }
 #endif
 
 #endif /* !_SYS_EUI64_H */
 #endif /* HAVE_SYS_EUI64_H */
+#endif /* SQUID_COMPAT_EUI64_ATON_H */
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_FDSETSIZE_H
 #define SQUID_FDSETSIZE_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  *  Shamelessly duplicated from the fetchmail public sources
  *  for use by the Squid Project under GNU Public License.
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _getaddrinfo_h
 #define _getaddrinfo_h
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  *  Shamelessly duplicated from the fetchmail public sources
  *  for use by the Squid Project under GNU Public License.
@@ -1,12 +1,18 @@
-#ifndef _getnameinfo_h
-#define _getnameinfo_h
 /*
- * Reconstructed from KAME getnameinfo.c (in lib/)
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
+#ifndef _getnameinfo_h
+#define _getnameinfo_h
+
 #if !HAVE_GETNAMEINFO
 
-/* RFC 2553 / Posix resolver */
+// RFC 2553 / Posix resolver
+// Reconstructed from KAME getnameinfo.c
 SQUIDCEXTERN int xgetnameinfo(const struct sockaddr *sa,
                               socklen_t salen,
                               char *host,
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  *  Shamelessly duplicated from the bind9 public sources
  *  for use by the Squid Project under ISC written permission
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _INC_INET_NTOP_H
 #define _INC_INET_NTOP_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  *  Shamelessly duplicated from the bind9 public sources
  *  for use by the Squid Project under ISC written permission
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _INC_INET_PTON_H
 #define _INC_INET_PTON_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat/initgroups.h"
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_INITGROUPS_H
 #define SQUID_INITGROUPS_H
 
@@ -1,36 +1,15 @@
 /*
- * Windows support
- * AUTHOR: Guido Serassio <serassio@squid-cache.org>
- * inspired by previous work by Romeo Anghelache & Eric Stern.
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
+/* Windows support
+ * AUTHOR: Guido Serassio <serassio@squid-cache.org>
+ * Inspired by previous work by Romeo Anghelache & Eric Stern. */
+
 #include "squid.h"
 
 // The following code section is part of an EXPERIMENTAL native Windows NT/2000 Squid port.
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_AIX_H
 #define SQUID_OS_AIX_H
 
@@ -1,3 +1,10 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
 #ifndef SQUID_OS_ANDROID_H
 #define SQUID_OS_ANDROID_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_DRAGONFLY_H
 #define SQUID_OS_DRAGONFLY_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_FREEBSD_H
 #define SQUID_OS_FREEBSD_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_HPUX_H
 #define SQUID_OS_HPUX_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_LINUX_H
 #define SQUID_OS_LINUX_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_MACOSX_H
 #define SQUID_OS_MACOSX_H
 
@@ -1,39 +1,27 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  * AUTHOR: Andrey Shorin <tolsty@tushino.com>
  * AUTHOR: Guido Serassio <serassio@squid-cache.org>
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
  */
+
 #ifndef SQUID_OS_MSWINDOWS_H
 #define SQUID_OS_MSWINDOWS_H
 
 #if _SQUID_WINDOWS_
 
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
 /* we target Windows XP and later - some API are missing otherwise */
 #if _SQUID_MINGW_
 #if WINVER < 0x0501
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_NETBSD_H
 #define SQUID_OS_NETBSD_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_NEXT_H
 #define SQUID_OS_NEXT_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_OPENBSD_H
 #define SQUID_OS_OPENBSD_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  * Copied from OpenSolaris 10 public sources
  * http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/head/netdb.h
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_OS2_H
 #define SQUID_OS_OS2_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_QNX_H
 #define SQUID_OS_QNX_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_SGI_H
 #define SQUID_OS_SGI_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_SOLARIS_H
 #define SQUID_OS_SOLARIS_H
 
@@ -64,12 +72,6 @@ SQUIDCEXTERN int gethostname(char *, int);
 #define __FUNCTION__ ""
 #endif
 
-/* Exclude CPPUnit tests from the allocator restrictions. */
-/* BSD implementation uses these still */
-#if defined(SQUID_UNIT_TEST)
-#define SQUID_NO_STRING_BUFFER_PROTECT 1
-#endif
-
 /* Bug 2500: Solaris 10/11 require s6_addr* defines. */
 //#define s6_addr8   _S6_un._S6_u8
 //#define s6_addr16  _S6_un._S6_u16
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_OS_SUNOS_H
 #define SQUID_OS_SUNOS_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_OSDETECT_H
 #define SQUID_COMPAT_OSDETECT_H
 
@@ -1,7 +1,11 @@
 /*
- * Author:   Jens-S. V?ckler <voeckler@rvs.uni-hannover.de>
- * Ripped from Purge tool implementation.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
+
 #include "squid.h"
 #include "psignal.h"
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef __SQUID_PSIGNAL_H
 #define __SQUID_PSIGNAL_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat/shm.h"
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_SHM_H
 #define SQUID_COMPAT_SHM_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_STDIO_H
 #define _SQUID_COMPAT_STDIO_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_STDVARARGS_H
 #define _SQUID_STDVARARGS_H
 
@@ -1,33 +1,9 @@
 /*
- * DEBUG:
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
@@ -1,31 +1,9 @@
 /*
- * strnrchr.c
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
@@ -1,31 +1,9 @@
 /*
- * strnrchr.h
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef COMPAT_STRNRCHR_H_
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_STRNSTR_CC_
 #define SQUID_COMPAT_STRNSTR_CC_
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_STRTOLL_H
 #define _SQUID_COMPAT_STRTOLL_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /* A reasonably functional tmpnam. */
 
 /* Originally by Tom Hageman, tom@basil.icce.rug.nl */
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  * Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
  * This file is part of the GNU C Library.
@@ -1,10 +1,16 @@
-#define SQUID_UNIT_TEST 1
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
+#include "testPreCompiler.h"
 
 #include <cassert>
 
-#include "testPreCompiler.h"
-
 CPPUNIT_TEST_SUITE_REGISTRATION( testPreCompiler );
 
 /**
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_TESTS_TESTPRECOMPILER_H
 #define SQUID_COMPAT_TESTS_TESTPRECOMPILER_H
 
@@ -1,48 +1,15 @@
 /*
- * * * * * * * * Legal stuff * * * * * * *
- *
- * (C) 2000 Francesco Chemolli <kinkie@kame.usr.dsi.unimi.it>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * * * * * * * * Declaration of intents * * * * * * *
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_TYPES_H
+#define SQUID_TYPES_H
+
+/*
  * Here are defined several known-width types, obtained via autoconf
  * from system locations or various attempts. This is just a convenience
  * header to include which takes care of proper preprocessor stuff
@@ -51,9 +18,6 @@
  * not include directly.
  */
 
-#ifndef SQUID_TYPES_H
-#define SQUID_TYPES_H
-
 /* This should be in synch with what we have in acinclude.m4 */
 #if HAVE_SYS_TYPES_H
 #include <sys/types.h>
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_VALGRIND_H
 #define SQUID_VALGRIND_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat/xalloc.h"
 #include "profiler/Profiler.h"
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_XALLOC_H
 #define _SQUID_COMPAT_XALLOC_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_XIS_H
 #define _SQUID_COMPAT_XIS_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat/xstrerror.h"
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_COMPAT_XSTRERROR_H
 #define _SQUID_COMPAT_XSTRERROR_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #include "squid.h"
 #include "compat/xalloc.h"
 #include "compat/xstring.h"
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_COMPAT_XSTRING_H
 #define SQUID_COMPAT_XSTRING_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_XSTRTO_C_
 #define SQUID_XSTRTO_C_
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_XSTRTO_H
 #define _SQUID_XSTRTO_H
 
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 AC_INIT([Squid Web Proxy],[3.HEAD-BZR],[http://bugs.squid-cache.org/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
@@ -8,6 +15,7 @@ AC_REVISION($Revision$)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AM_MAINTAINER_MODE
 
+m4_include([acinclude/ax_with_prog.m4])
 m4_include([acinclude/init.m4])
 m4_include([acinclude/squid-util.m4])
 m4_include([acinclude/compiler-flags.m4])
@@ -1347,186 +1355,861 @@ AC_MSG_NOTICE([OpenSSL library support: ${with_openssl:=no} ${LIBOPENSSL_PATH} $
 AM_CONDITIONAL(ENABLE_SSL,[ test "x$with_openssl" = "xyes" ])
 AC_SUBST(SSLLIB)
 
-AC_ARG_ENABLE(forw-via-db,
-  AS_HELP_STRING([--enable-forw-via-db],[Enable Forw/Via database]), [
-  SQUID_YESNO([$enableval],[unrecognized argument to --enable-forw-via-db: $enableval])
+dnl User may specify MIT Kerberos is needed from a non-standard location
+AC_ARG_WITH(mit-krb5,
+  AS_HELP_STRING([--without-mit-krb5],
+		 [Compile without MIT Kerberos support.]), [
+case "$with_mit_krb5" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      AC_MSG_ERROR([--with-mit-krb5 path does not point to a directory])
+    fi
+    if test -d "$with_mit_krb5/lib64" ; then
+      LIB_KRB5_PATH="-L$with_mit_krb5/lib64 -L$with_mit_krb5/lib"
+    else
+      LIB_KRB5_PATH="-L$with_mit_krb5/lib"
+    fi
+    CXXFLAGS="-I$with_mit_krb5/include $CXXFLAGS"
+    krb5confpath="$with_mit_krb5/bin"
+    with_mit_krb5=yes
+esac
 ])
-SQUID_DEFINE_BOOL(USE_FORW_VIA_DB,${enable_forw_via_db:=no},
-                      [Enable Forw/Via database])
-AC_MSG_NOTICE([Forw/Via database enabled: $enable_forw_via_db])
+AH_TEMPLATE(USE_MIT_KRB5,[MIT Kerberos support is available])
+AH_TEMPLATE(USE_SOLARIS_KRB5,[Solaris Kerberos support is available])
 
-AC_ARG_ENABLE(cache-digests,
-  AS_HELP_STRING([--enable-cache-digests],
-   [Use Cache Digests. See http://wiki.squid-cache.org/SquidFaq/CacheDigests]),
-[
- SQUID_YESNO($enableval,
-   [unrecognized argument to --enable-cache-digests: $enableval])
+dnl User may specify Heimdal Kerberos is needed from a non-standard location
+AC_ARG_WITH(heimdal-krb5,
+  AS_HELP_STRING([--without-heimdal-krb5],
+		 [Compile without Heimdal Kerberos support.]), [
+case "$with_heimdal_krb5" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      AC_MSG_ERROR([--with-heimdal-krb5 path does not point to a directory])
+    fi
+    if test -d "$with_heimdal_krb5/lib64" ; then
+      LIB_KRB5_PATH="-L$with_heimdal_krb5/lib64 -L$with_heimdal_krb5/lib"
+    else 
+      LIB_KRB5_PATH="-L$with_heimdal_krb5/lib"
+    fi
+    CXXFLAGS="-I$with_heimdal_krb5/include $CXXFLAGS"
+    krb5confpath="$with_heimdal_krb5/bin"
+    with_heimdal_krb5=yes
+esac
 ])
-SQUID_DEFINE_BOOL(USE_CACHE_DIGESTS,${enable_cache_digests:=no},
-  [Use Cache Digests for locating objects in neighbor caches.])
-AC_MSG_NOTICE([Cache Digests enabled: $enable_cache_digests])
+AH_TEMPLATE(USE_HEIMDAL_KRB5,[Heimdal Kerberos support is available])
 
 
-################################
-# check for netio plugin stuff #
-################################
-dnl order of these options handling is relevant in case the user
-dnl supplies more than one --enable option. Options handled later
-dnl override those handled earlier for io loop method manual override
-AC_ARG_ENABLE(select,
-  AS_HELP_STRING([--disable-select],[Disable select(2) support.]),
-[
-SQUID_YESNO($enableval,[--disable-select takes no extra argument])
-if test "x$enableval" = "xyes"; then
-  if test "x$squid_host_os" = "xmingw"; then
-    squid_opt_io_loop_engine="select_win32"
-  else
-    squid_opt_io_loop_engine="select"
+
+dnl User may specify GNU gss is needed from a non-standard location
+AC_ARG_WITH(gnugss,
+  AS_HELP_STRING([--without-gnugss],
+		 [Compile without the GNU gss libraries.]), [
+case "$with_gnugss" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      AC_MSG_ERROR([--with-gnugss path does not point to a directory])
+    fi
+    if test ! -d "$with_gnugss/lib64" ; then
+      LIB_KRB5_PATH="-L$with_gnugss/lib64 -L$with_gnugss/lib"
+    else
+      LIB_KRB5_PATH="-L$with_gnugss/lib"
+    fi
+    CXXFLAGS="-I$with_gnugss/include $CXXFLAGS"
+    krb5confpath=
+    with_gnugss=yes
+esac
+])
+AH_TEMPLATE(USE_GNUGSS,[GNU gss support is available])
+
+# determine krb5 conflicts
+ac_with_krb5_count=0
+if test "x$with_mit_krb5" = "xyes"; then
+ ac_with_krb5_count=`expr $ac_with_krb5_count + 1`
+fi
+if test "x$with_heimdal_krb5" = "xyes"; then
+ ac_with_krb5_count=`expr $ac_with_krb5_count + 1`
+fi
+if test "x$with_gnugss" = "xyes"; then
+ ac_with_krb5_count=`expr $ac_with_krb5_count + 1`
+fi
+
+if test $ac_with_krb5_count -gt 1 ; then
+  AC_MSG_ERROR([Please choose only one Kerberos library.])
+elif test $ac_with_krb5_count -eq 0 ; then
+  # find installed libs via pkg-config or krb5-config
+  PKG_CHECK_EXISTS(gssapi-krb5 krb5, [with_mit_krb5=yes])
+  PKG_CHECK_EXISTS(heimdal-gssapi, [with_heimdal_krb5=yes])
+  PKG_CHECK_EXISTS(gss, [with_gnugss=yes])
+  if test "x$with_mit_krb5" = "xyes"; then
+    ac_with_krb5_count=`expr $ac_with_krb5_count + 1`
+  fi
+  if test "x$with_heimdal_krb5" = "xyes"; then
+    ac_with_krb5_count=`expr $ac_with_krb5_count + 1`
+  fi
+  if test "x$with_gnugss" = "xyes"; then
+    ac_with_krb5_count=`expr $ac_with_krb5_count + 1`
+  fi
+  if test $ac_with_krb5_count -gt 1 ; then
+    AC_MSG_ERROR([pkg-config found multiple Kerberos library. Please select one with --with-<kerberos package>])
+  elif test $ac_with_krb5_count -eq 0 -a "$cross_compiling" = "no"; then
+    # Look for krb5-config (unless cross-compiling)
+    AC_PATH_PROG(krb5_config,krb5-config,no)
+    if test "x$ac_cv_path_krb5_config" != "xno" ; then
+      krb5confpath="`dirname $ac_cv_path_krb5_config`"
+      ac_heimdal="`$ac_cv_path_krb5_config --version 2>/dev/null | grep -c -i heimdal`"
+      ac_solaris="`$ac_cv_path_krb5_config --version 2>/dev/null | grep -c -i solaris`"
+      if test $ac_heimdal -gt 0 ; then
+	with_heimdal_krb5=yes
+        ac_with_krb5_count=1
+      fi
+      if test $ac_solaris -gt 0 ; then
+	with_solaris_krb5=yes
+        ac_with_krb5_count=1
+      fi
+      if test $ac_heimdal -eq 0 && test $ac_solaris -eq 0 ; then
+	with_mit_krb5=yes
+        ac_with_krb5_count=1
+      fi
+    else
+      AC_MSG_WARN([Could not find krb5-config in path])
+    fi
   fi
 fi
-])
-AC_MSG_NOTICE([enabling select syscall for net I/O: ${enable_select:=auto}])
 
-AC_ARG_ENABLE(poll,
-  AS_HELP_STRING([--disable-poll],[Disable poll(2) support.]),
-[
-SQUID_YESNO($enableval,[--disable-poll takes no extra argument])
-test "x$enableval" = "xyes" && squid_opt_io_loop_engine="poll"
-])
-AC_MSG_NOTICE([enabling poll syscall for net I/O: ${enable_poll:=auto}])
+if test "x$with_mit_krb5" = "xyes"; then
+  SQUID_STATE_SAVE([squid_krb5_save])
+  LIBS="$LIBS $LIB_KRB5_PATH"
 
-AC_ARG_ENABLE(kqueue,
-  AS_HELP_STRING([--disable-kqueue],
-                 [Disable kqueue(2) support.]), [
-SQUID_YESNO($enableval,[--enable-kqueue takes no extra argument])
-])
-if test "x${enable_kqueue:=auto}" != "xno" ; then
-  AC_CHECK_HEADERS([sys/event.h],[],[
-    if test "x${enable_kqueue}" = "xyes" ; then
-      AC_MSG_ERROR([kqueue support requires sys/event.h header file.])
+  # auto-detect using pkg-config
+  PKG_CHECK_MODULES([LIB_KRB5],[gssapi-krb5 krb5],,[
+    # look for krb5-config (unless cross-compiling)
+    if test "$cross_compiling" = "no"; then
+      if test "x$krb5confpath" = "x" ; then
+        AC_PATH_PROG(krb5_config,krb5-config,no)
+        if test "x$ac_cv_path_krb5_config" != "xno" ; then
+          ac_krb5_config="$ac_cv_path_krb5_config"
+        fi
+      else
+        ac_krb5_config="$krb5confpath/krb5-config"
+      fi
     fi
-  ])
-  AC_CHECK_FUNCS(kqueue,[],[
-    if test "x${enable_kqueue}" = "xyes" ; then
-      AC_MSG_ERROR([kqueue support missing in libc library.])
+    if test "x$ac_krb5_config" != "x" && test -x "$ac_krb5_config"; then
+      # Get libs, etc
+      AC_MSG_NOTICE([Use krb5-config to get CXXFLAGS and LIBS])
+      LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags krb5 2>/dev/null`"
+      LIB_KRB5_LIBS="`$ac_krb5_config --libs krb5 2>/dev/null`"
+      LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
+      LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+    else
+      ## For some OS pkg-config is broken or unavailable.
+      ## Detect libraries the hard way.
+
+      AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
+      AC_CHECK_LIB(com_err, [main], [LIB_KRB5_LIBS="-lcom_err $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'com_err' is required for MIT Kerberos])
+      ])
+      AC_CHECK_LIB(k5crypto, [main], [LIB_KRB5_LIBS="-lk5crypto $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'k5crypto' is required for MIT Kerberos])
+      ])
+      AC_CHECK_LIB(krb5, [main], [LIB_KRB5_LIBS="-lkrb5 $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'krb5' is required for MIT Kerberos])
+      ])
+      AC_CHECK_LIB(gssapi_krb5, [main], [LIB_KRB5_LIBS="-lgssapi_krb5 $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'gssapi_krb5' is required for MIT Kerberos])
+      ])
     fi
+
   ])
-  if test "x$ac_cv_func_kqueue" = "xyes" -a "x$ac_cv_header_sys_event_h" = "xyes" ; then
-    squid_opt_io_loop_engine="kqueue"
-  else
-    enable_kqueue="no"
+
+  if test "x$LIB_KRB5_LIBS" != "x"; then
+    KRB5LIBS="$LIB_KRB5_PATH $LIB_KRB5_LIBS $KRB5LIBS"
+    KRB5INCS="$LIB_KRB5_CFLAGS"
+    AC_DEFINE(USE_MIT_KRB5,1,[MIT Kerberos support is available])
+    KRB5_FLAVOUR="MIT" 
+    
+    # check for other specific broken implementations
+    CXXFLAGS="$CXXFLAGS $KRB5INCS"
+    LIBS="$LIBS $KRB5LIBS"
+
+    AC_MSG_NOTICE([Try to find Kerberos headers in given path])
+    AC_CHECK_HEADERS(gssapi.h gssapi/gssapi.h gssapi/gssapi_krb5.h)
+    AC_CHECK_HEADERS(gssapi/gssapi_generic.h)
+    AC_CHECK_HEADERS(krb5.h com_err.h et/com_err.h)
+    AC_CHECK_HEADERS(profile.h)
+
+    if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
+      AC_CHECK_LIB(com_err,error_message,
+        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
+          [Define to 1 if you have error_message]),)
+    elif test  "x$ac_com_error_message" = "xyes" ; then
+      AC_CHECK_LIB(krb5,error_message,
+        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
+          [Define to 1 if you have error_message]),)
+    fi
+
+    SQUID_CHECK_KRB5_FUNCS
+
+  fi
+  if test "x$KRB5LIBS" = "x"; then
+    AC_MSG_ERROR([Required Kerberos library not found])
+    ac_with_krb5_count=0
   fi
-fi
-AC_MSG_NOTICE([enabling kqueue for net I/O: ${enable_kqueue:=auto}])
 
-dnl Enable epoll()
-AC_ARG_ENABLE(epoll,
-  AS_HELP_STRING([--disable-epoll],[Disable Linux epoll(2) support.]),
-[
-SQUID_YESNO($enableval,[--disable-epoll takes no extra argument])
-test "x$enableval" = "xyes" && squid_opt_io_loop_engine="epoll"
-])
-AC_MSG_NOTICE([enabling epoll syscall for net I/O: ${enable_epoll:=auto}])
+  SQUID_STATE_ROLLBACK([squid_krb5_save])
+fi
 
-# auto-detect and verify epoll header and library present and working
-# logic mapping and loop method selection are performed later
-if test "x$enable_epoll" != "xno" ; then
+if test "x$with_solaris_krb5" = "xyes"; then
+  SQUID_STATE_SAVE([squid_krb5_save])
+  LIBS="$LIBS $LIB_KRB5_PATH"
 
-  # check if libs are needed to support epoll
-  # note: this code block seems quite generic. Could it be extracted
-  #   into a squid specific configure function?
-  SQUID_STATE_SAVE(squid_epoll_state)
-  AC_SEARCH_LIBS(epoll_ctl,[epoll])
-  if test "x$ac_cv_search_epoll_ctl" = "xno" ; then
-    enable_epoll=no #disable. Needed code not found
-  elif test "x$ac_cv_search_epoll_ctl" = "xnone required" ; then
-    EPOLL_LIBS=""
-  else
-    EPOLL_LIBS=$ac_cv_search_epoll_ctl
+  # no pkg-config for solaris native Kerberos
+  # look for krb5-config (unless cross-compiling)
+  if test "$cross_compiling" = "no"; then
+    if test "x$krb5confpath" = "x" ; then
+      AC_PATH_PROG(krb5_config,krb5-config,no)
+      if test "x$ac_cv_path_krb5_config" != "xno" ; then
+        ac_krb5_config="$ac_cv_path_krb5_config"
+      fi
+    else
+      ac_krb5_config="$krb5confpath/krb5-config"
+    fi
   fi
-  AC_SUBST(EPOLL_LIBS)
-  SQUID_STATE_ROLLBACK(squid_epoll_state) #de-pollute LIBS
+  if test "x$ac_krb5_config" != "x" && test -x "$ac_krb5_config"; then
+    # Get libs, etc
+    AC_MSG_NOTICE([Use krb5-config to get CXXFLAGS and LIBS])
+    LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags krb5 2>/dev/null`"
+    LIB_KRB5_LIBS="`$ac_krb5_config --libs krb5 2>/dev/null`"
+    LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
+    LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+  else
+    ## For some OS pkg-config is broken or unavailable.
+    ## Detect libraries the hard way.
 
-  # epoll requires sys/epoll.h
-  AC_CHECK_HEADERS([sys/epoll.h])
+    CXXFLAGS="-I/usr/include/kerberosv5 $CXXFLAGS"
 
-  dnl Verify that epoll really works
-  if test "x$ac_cv_search_epoll_ctl" != 'xno' ; then
-    SQUID_CHECK_EPOLL
+    AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
+    AC_CHECK_LIB(krb5, [main], [LIB_KRB5_LIBS="-lkrb5 $LIB_KRB5_LIBS"],[
+      AC_MSG_ERROR([library 'krb5' is required for Solaris Kerberos])
+    ])
+    AC_CHECK_LIB(gss, [main], [LIB_KRB5_LIBS="-lgss $LIB_KRB5_LIBS"],[
+      AC_MSG_ERROR([library 'gss' is required for Solaris Kerberos])
+    ])
   fi
 
-  if test "x$enable_epoll" = "xyes" -a "x$squid_cv_epoll_works" = "xno" ; then
-    AC_MSG_ERROR([Epoll does not work. Force-enabling it is not going to help.])
+  if test "x$LIB_KRB5_LIBS" != "x"; then
+    KRB5LIBS="$LIB_KRB5_PATH $LIB_KRB5_LIBS $KRB5LIBS"
+    KRB5INCS="$LIB_KRB5_CFLAGS"
+    AC_DEFINE(USE_SOLARIS_KRB5,1,[Solaris Kerberos support is available])
+    KRB5_FLAVOUR="Solaris" 
+    
+    # check for other specific broken implementations
+    CXXFLAGS="$CXXFLAGS $KRB5INCS"
+    LIBS="$LIBS $KRB5LIBS"
+
+    AC_MSG_NOTICE([Try to find Kerberos headers in given path])
+    AC_CHECK_HEADERS(gssapi/gssapi.h gssapi/gssapi_ext.h)
+    AC_CHECK_HEADERS(krb5.h com_err.h)
+
+    SQUID_CHECK_KRB5_SOLARIS_BROKEN_KRB5_H
+    if test "x$squid_cv_broken_krb5_h" = "xyes"; then
+      AC_DEFINE(HAVE_BROKEN_SOLARIS_KRB5_H, 1, [Define to 1 if Solaris krb5.h is broken for C++])
+      AC_MSG_WARN([You have a broken Solaris <krb5.h> system include.])
+      AC_MSG_WARN([Please see http://bugs.opensolaris.org/bugdatabase/view_bug.do?bug_id=6837512])
+      AC_MSG_WARN([If you need Kerberos support you will have to patch])
+      AC_MSG_WARN([your system. See contrib/solaris/solaris-krb5-include.patch])
+    fi
+
+    SQUID_CHECK_KRB5_FUNCS
+
+  fi
+  if test "x$KRB5LIBS" = "x"; then
+    AC_MSG_ERROR([Required Kerberos library not found])
+    ac_with_krb5_count=0
   fi
+
+  SQUID_STATE_ROLLBACK([squid_krb5_save])
 fi
 
-dnl Enable /dev/poll
-AC_ARG_ENABLE(devpoll,
-  AS_HELP_STRING([--disable-devpoll],[Disable Solaris /dev/poll support.]),
-[
-SQUID_YESNO($enableval,[--disable-devpoll takes no extra argument])
-test "x$enableval" = "xyes" && squid_opt_io_loop_engine="devpoll"
-])
-AC_MSG_NOTICE([enabling /dev/poll for net I/O: ${enable_devpoll:=auto}])
+if test "x$with_heimdal_krb5" = "xyes"; then
+  SQUID_STATE_SAVE([squid_krb5_save])
+  LIBS="$LIBS $LIB_KRB5_PATH"
 
-## auto-detect and verify devpoll header and library present and working
-if test "x$enable_devpoll" != "xno"; then
+  # auto-detect using pkg-config
+  PKG_CHECK_MODULES([LIB_KRB5],[heimdal-gssapi],,[
+    # look for krb5-config (unless cross-compiling)
+    if test "$cross_compiling" = "no"; then
+      if test "x$krb5confpath" = "x" ; then
+        AC_PATH_PROG(krb5_config,krb5-config,no)
+        if test "x$ac_cv_path_krb5_config" != "xno" ; then
+          ac_krb5_config="$ac_cv_path_krb5_config"
+        fi
+      else
+        ac_krb5_config="$krb5confpath/krb5-config"
+      fi
+    fi
+    if test "x$ac_krb5_config" != "x" && test -x "$ac_krb5_config"; then
+      # Get libs, etc
+      AC_MSG_NOTICE([Use krb5-config to get CXXFLAGS and LIBS])
+      LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags krb5 2>/dev/null`"
+      LIB_KRB5_LIBS="`$ac_krb5_config --libs krb5 2>/dev/null`"
+      LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
+      LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+    else
+      ## For some OS pkg-config is broken or unavailable.
+      ## Detect libraries the hard way.
 
-  # /dev/poll requires ioctl() and write()
-  AC_CHECK_FUNCS(ioctl)
-  AC_CHECK_FUNCS(write)
+      AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
+      AC_CHECK_LIB(resolv, [main], [LIB_KRB5_LIBS="-lresolv $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'resolv' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(crypt, [main], [LIB_KRB5_LIBS="-lcrypt $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'crypt' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(roken, [main], [LIB_KRB5_LIBS="-lroken $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'roken' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(heimbase, [main], [LIB_KRB5_LIBS="-lheimbase $LIB_KRB5_LIBS"],[
+        AC_MSG_WARN([library 'heimbase' may be required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(wind, [main], [LIB_KRB5_LIBS="-lwind $LIB_KRB5_LIBS"],[
+        AC_MSG_WARN([library 'wind' may be required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(crypto, [main], [LIB_KRB5_LIBS="-lcrypto $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'crypto' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(com_err, [main], [LIB_KRB5_LIBS="-lcom_err $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'com_err' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(hx509, [main], [LIB_KRB5_LIBS="-lhx509 $LIB_KRB5_LIBS"],[
+        AC_MSG_WARN([library 'hx509' may be required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(asn1, [main], [LIB_KRB5_LIBS="-lasn1 $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'asn1' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(krb5, [main], [LIB_KRB5_LIBS="-lkrb5 $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'krb5' is required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(heimntlm, [main], [LIB_KRB5_LIBS="-lheimntlm $LIB_KRB5_LIBS"],[
+        AC_MSG_WARN([library 'heimntlm' may be required for Heimdal Kerberos])
+      ])
+      AC_CHECK_LIB(gssapi, [main], [LIB_KRB5_LIBS="-lgssapi $LIB_KRB5_LIBS"],[
+        AC_MSG_ERROR([library 'gssapi' is required for Heimdal Kerberos])
+      ])
+    fi
 
-  # /dev/poll requires sys/devpoll.h
-  AC_CHECK_HEADERS([sys/devpoll.h],,[
-        if test "x$enable_devpoll" = "xyes"; then
-            AC_MSG_ERROR([--enable-devpoll specified but /dev/poll headers not found])
-        fi
-        enable_devpoll=no])
+  ])
+  if test "x$LIB_KRB5_LIBS" != "x"; then
+    KRB5LIBS="$LIB_KRB5_PATH $LIB_KRB5_LIBS $KRB5LIBS"
+    KRB5INCS="$LIB_KRB5_CFLAGS"
+    AC_DEFINE(USE_HEIMDAL_KRB5,1,[Heimdal Kerberos support is available])
+    KRB5_FLAVOUR="Heimdal" 
+    
+    # check for other specific broken implementations
+    CXXFLAGS="$CXXFLAGS $KRB5INCS"
+    LIBS="$LIBS $KRB5LIBS"
 
-  # Verify that /dev/poll really works
-  if test "x$enable_devpoll" != 'xno' ; then
-    SQUID_CHECK_DEVPOLL
-  fi
+    AC_MSG_NOTICE([Try to find Kerberos headers in given path])
+    AC_CHECK_HEADERS(gssapi.h gssapi/gssapi.h gssapi/gssapi_krb5.h)
+    AC_CHECK_HEADERS(krb5.h com_err.h et/com_err.h)
+
+    SQUID_CHECK_KRB5_HEIMDAL_BROKEN_KRB5_H
+    if test "x$squid_cv_broken_heimdal_krb5_h" = "xyes"; then
+      AC_DEFINE(HAVE_BROKEN_HEIMDAL_KRB5_H, 1, [Define to 1 if Heimdal krb5.h is broken for C++])
+    fi
+
+    if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
+      AC_CHECK_LIB(com_err,error_message,
+        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
+          [Define to 1 if you have error_message]),)
+    elif test  "x$ac_com_error_message" = "xyes" ; then
+      AC_CHECK_LIB(krb5,error_message,
+        AC_DEFINE(HAVE_ERROR_MESSAGE,1,
+          [Define to 1 if you have error_message]),)
+    fi
+
+    SQUID_CHECK_KRB5_FUNCS
 
-  if test "x$enable_devpoll" = "xyes" -a "x$squid_cv_devpoll_works" = "xno" ; then
-    AC_MSG_ERROR([/dev/poll does not work. Force-enabling it is not going to help.])
   fi
+  if test "x$KRB5LIBS" = "x"; then
+    AC_MSG_ERROR([Required Kerberos library not found])
+    ac_with_krb5_count=0
+  fi
+
+  SQUID_STATE_ROLLBACK([squid_krb5_save])
 fi
 
+if test "x$with_gnugss" = "xyes"; then
+  SQUID_STATE_SAVE([squid_krb5_save])
+  LIBS="$LIBS $LIB_KRB5_PATH"
 
-AC_ARG_ENABLE(http-violations,
-  AS_HELP_STRING([--disable-http-violations],
-                 [This allows you to remove code which is known to
-                  violate the HTTP protocol specification.]), [
-  SQUID_YESNO([$enableval],
-         [unrecognized argument to --disable-http-violations: $enableval])
-])
-SQUID_DEFINE_BOOL(USE_HTTP_VIOLATIONS, ${enable_http_violations:=yes},
-  [Define to enable code which volates the HTTP standard specification])
-AC_MSG_NOTICE([HTTP violations support enabled: $enable_http_violations])
+  # auto-detect using pkg-config
+  PKG_CHECK_MODULES([LIB_KRB5],[gss],,[
+    ## For some OS pkg-config is broken or unavailable.
+    ## Detect libraries the hard way.
 
-# IPFW Transparent Proxy
-AC_ARG_ENABLE(ipfw-transparent,
-  AS_HELP_STRING([--enable-ipfw-transparent],
-                 [Enable Transparent Proxy support for systems
-                  using FreeBSD IPFW-style firewalling.]), [
-  SQUID_YESNO([$enableval],
-      [unrecognized argument to --enable-ipfw-transparent: $enableval])
-])
-SQUID_DEFINE_BOOL(IPFW_TRANSPARENT,${enable_ipfw_transparent:=no},
-  [Enable support for Transparent Proxy on systems using FreeBSD IPFW-style firewalling.])
-AC_MSG_NOTICE([FreeBSD IPFW-based transparent proxying enabled: $enable_ipfw_transparent])
+    AC_MSG_NOTICE([Try to find Kerberos libraries in given path])
+    AC_CHECK_LIB(gss, [main], [LIB_KRB5_LIBS="-lgss $LIB_KRB5_LIBS"],[
+      AC_MSG_ERROR([library 'com_err' is required for GNU Kerberos])
+    ])
 
-# IP-Filter Transparent Proxy
-AC_ARG_ENABLE(ipf-transparent,
-  AS_HELP_STRING([--enable-ipf-transparent],
-     [Enable Transparent Proxy support using IPFilter-style firewalling]), [
-  SQUID_YESNO([$enableval],
-      [unrecognized argument to --enable-ipf-transparent: $enableval])
-])
-#will be AC_DEFINEd later, after checking for appropriate infrastructure
-#IPF currently broken. Default-disabled for now.
-AC_MSG_NOTICE([IPF-based transparent proxying requested: ${enable_ipf_transparent:=no}])
+  ])
+
+  if test "x$LIB_KRB5_LIBS" != "x"; then
+    KRB5LIBS="$LIB_KRB5_PATH $LIB_KRB5_LIBS $KRB5LIBS"
+    KRB5INCS="$LIB_KRB5_CFLAGS"
+    AC_DEFINE(USE_GNUGSS,1,[GNU Kerberos support is available])
+    KRB5_FLAVOUR="GNU GSS" 
+
+    # check for other specific broken implementations
+    CXXFLAGS="$CXXFLAGS $KRB5INCS"
+    LIBS="$LIBS $KRB5LIBS"
+
+    AC_MSG_NOTICE([Try to find Kerbeors headers in given path])
+    AC_CHECK_HEADERS(gss.h)
+
+    SQUID_CHECK_WORKING_GSSAPI
+    SQUID_DEFINE_BOOL(HAVE_GSSAPI,$squid_cv_working_gssapi,[GSSAPI support])
+
+    SQUID_CHECK_SPNEGO_SUPPORT
+    SQUID_DEFINE_BOOL(HAVE_SPNEGO,$squid_cv_have_spnego,[SPNEGO support])
+
+    SQUID_CHECK_WORKING_KRB5
+    SQUID_DEFINE_BOOL(HAVE_KRB5,$squid_cv_working_krb5,[KRB5 support])
+
+  fi
+  if test "x$KRB5LIBS" = "x"; then
+    AC_MSG_ERROR([Required Kerberos library not found])
+    ac_with_krb5_count=0
+  fi
+
+  SQUID_STATE_ROLLBACK([squid_krb5_save])
+fi
+if test $ac_with_krb5_count -gt 0 ; then
+  with_krb5=yes
+fi
+AC_MSG_NOTICE([$KRB5_FLAVOUR Kerberos library support: ${with_krb5:=no} ${LIB_KRB5_PATH} ${LIB_KRB5_LIBS}])
+AC_SUBST(KRB5INCS)
+AC_SUBST(KRB5LIBS)
+AM_CONDITIONAL(HAVE_SPNEGO, test x"$squid_cv_have_spnego" = x"yes" )
+
+dnl On MinGW OpenLDAP is not available, so LDAP helpers can be linked 
+dnl only with Windows LDAP libraries using -lwldap32
+case "$squid_host_os" in
+	mingw)
+		LDAPLIB="-lwldap32"
+		LBERLIB=""
+		;;
+	*)
+		AC_CHECK_LIB(ldap, ldap_init, [LDAPLIB="-lldap"])
+		dnl LDAP helpers need to know if -llber is needed or not
+		AC_CHECK_LIB(lber, ber_init, [LBERLIB="-llber"])
+		dnl if no ldap lib found check for mozilla version
+		if test "x$ac_cv_lib_ldap_ldap_init" != x""yes; then
+		        oLIBS=$LIBS
+		        LIBS="$LIBPTHREADS"
+			AC_CHECK_LIB(ldap60, ldap_init, [LDAPLIB="-lldap60"])
+		        LIBS="$LDAPLIB $LIBPTHREADS"
+			AC_CHECK_LIB(prldap60, prldap_init, [LDAPLIB="-lprldap60 $LDAPLIB"])
+		        LIBS="$LDAPLIB $LIBPTHREADS"
+			AC_CHECK_LIB(ssldap60, ldapssl_init, [LDAPLIB="-lssldap60 $LDAPLIB"])
+		        LIBS=$oLIBS
+		fi
+
+		AC_CHECK_HEADERS(ldap.h lber.h)
+		AC_CHECK_HEADERS(mozldap/ldap.h)
+
+		dnl
+		dnl Check for LDAP_OPT_DEBUG_LEVEL
+		dnl
+		AC_MSG_CHECKING([for LDAP_OPT_DEBUG_LEVEL])
+		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#                   include <ldap.h>
+		]],[[
+                    int i=LDAP_OPT_DEBUG_LEVEL
+		]])],
+		[ AC_MSG_RESULT(yes) ],
+		[ AC_MSG_RESULT(no) ])
+
+		dnl
+		dnl Check for working ldap
+		dnl
+		oLIBS=$LIBS
+		LIBS="$LDAPLIB $LBERLIB $LIBPTHREADS"
+		AC_MSG_CHECKING([for working ldap])
+		AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#                   define  LDAP_DEPRECATED 1
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   elif HAVE_MOZLDAP_LDAP_H
+#                   include <mozldap/ldap.h>
+#                   endif
+                    int
+                    main(void)
+                    {
+                        char host[]="";
+                        int port;
+
+                        ldap_init((const char *)&host, port);
+
+                        return 0;
+                    }
+		]])], 
+		[ AC_DEFINE(HAVE_LDAP, 1, [LDAP support]) 
+		  AC_MSG_RESULT(yes) ],
+		[ AC_MSG_RESULT(no) ],
+		[ AC_MSG_RESULT(cross-compiler cant tell) ])
+		LIBS=$oLIBS
+
+		dnl
+		dnl Check for ldap vendor
+		dnl
+		AC_MSG_CHECKING([for OpenLDAP])
+		AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   endif
+#                   include <string.h>
+                    int
+                    main(void)
+                    {
+                        return strcmp(LDAP_VENDOR_NAME,"OpenLDAP");
+                    }
+		]])], 
+		[ AC_DEFINE(HAVE_OPENLDAP, 1, [OpenLDAP support]) 
+		  AC_MSG_RESULT(yes) ],
+		[ AC_MSG_RESULT(no) ],
+		[ AC_MSG_RESULT(cross-compiler cant tell) ])
+
+		AC_MSG_CHECKING([for Sun LDAP SDK])
+		AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   endif
+#                   include <string.h>
+                    int
+                    main(void)
+                    {
+                        return strcmp(LDAP_VENDOR_NAME,"Sun Microsystems Inc.");
+                    }
+		]])], 
+		[ AC_DEFINE(HAVE_SUN_LDAP_SDK, 1, [Sun LDAP SDK support])
+		  AC_MSG_RESULT(yes) ],
+		[ AC_MSG_RESULT(no) ],
+		[ AC_MSG_RESULT(cross-compiler cant tell) ])
+
+		AC_MSG_CHECKING([for Mozilla LDAP SDK])
+		AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   elif HAVE_MOZLDAP_LDAP_H
+#                   include <mozldap/ldap.h>
+#                   endif
+#                   include <string.h>
+                    int
+                    main(void)
+                    {
+                        return strcmp(LDAP_VENDOR_NAME,"mozilla.org");
+                    }
+		]])], 
+		[ AC_DEFINE(HAVE_MOZILLA_LDAP_SDK, 1, [Mozilla LDAP SDK support])
+		  AC_MSG_RESULT(yes) ],
+		[ AC_MSG_RESULT(no)],
+		[ AC_MSG_RESULT(cross-compiler cant tell) ])
+
+		dnl
+		dnl Check for LDAP_REBINDPROC_CALLBACK
+		dnl
+                AC_MSG_CHECKING([for LDAP_REBINDPROC_CALLBACK])
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   elif HAVE_MOZLDAP_LDAP_H
+#                   include <mozldap/ldap.h>
+#                   endif
+                ]],[[
+                    LDAP_REBINDPROC_CALLBACK ldap_rebind;
+                ]])],
+                [ AC_DEFINE(HAVE_LDAP_REBINDPROC_CALLBACK,1,[Define to 1 if you have LDAP_REBINDPROC_CALLBACK])
+                  AC_MSG_RESULT(yes) ],
+                [ AC_MSG_RESULT(no) ])
+
+		dnl
+		dnl Check for LDAP_REBIND_PROC
+		dnl
+                AC_MSG_CHECKING([for LDAP_REBIND_PROC])
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   elif HAVE_MOZLDAP_LDAP_H
+#                   include <mozldap/ldap.h>
+#                   endif
+                ]],[[
+                    LDAP_REBIND_PROC ldap_rebind;
+                ]])],
+                [ AC_DEFINE(HAVE_LDAP_REBIND_PROC,1,[Define to 1 if you have LDAP_REBIND_PROC])
+                  AC_MSG_RESULT(yes) ],
+                [ AC_MSG_RESULT(no) ])
+
+		dnl
+		dnl Check for LDAP_REBIND_FUNCTION
+		dnl
+                AC_MSG_CHECKING([for LDAP_REBIND_FUNCTION])
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#                   define LDAP_REFERRALS
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   elif HAVE_MOZLDAP_LDAP_H
+#                   include <mozldap/ldap.h>
+#                   endif
+                ]],[[
+                    LDAP_REBIND_FUNCTION ldap_rebind;
+                ]])],
+                [ AC_DEFINE(HAVE_LDAP_REBIND_FUNCTION,1,[Define to 1 if you have LDAP_REBIND_FUNCTION])
+                  AC_MSG_RESULT(yes) ],
+                [ AC_MSG_RESULT(no) ])
+
+		dnl
+		dnl Check for LDAP_SCOPE_DEFAULT
+		dnl
+                AC_MSG_CHECKING([for LDAP_SCOPE_DEFAULT])
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#                   if HAVE_LDAP_H
+#                   include <ldap.h>
+#                   elif HAVE_MOZLDAP_LDAP_H
+#                   include <mozldap/ldap.h>
+#                   endif
+                ]],[[
+                    int i=LDAP_SCOPE_DEFAULT;
+                ]])],
+                [ AC_DEFINE(HAVE_LDAP_SCOPE_DEFAULT,1,[Define to 1 if you have LDAP_SCOPE_DEFAULT])
+                  AC_MSG_RESULT(yes) ],
+                [ AC_MSG_RESULT(no) ])
+
+		dnl
+		dnl Check for ldap_url_desc.lud_scheme
+		dnl
+		AC_CHECK_MEMBER(struct ldap_url_desc.lud_scheme,
+		  AC_DEFINE(HAVE_LDAP_URL_LUD_SCHEME,1,
+		    [Define to 1 if you have LDAPURLDesc.lud_scheme]),,[#include <ldap.h>])
+
+		dnl
+		dnl Check for ldapssl_client_init
+		dnl
+		AC_CHECK_LIB(ldap,ldapssl_client_init,
+		  AC_DEFINE(HAVE_LDAPSSL_CLIENT_INIT,1,[Define to 1 if you have ldapssl_client_init]),)
+
+		dnl
+		dnl Check for ldap_url_desc2str
+		dnl
+		AC_CHECK_LIB(ldap,ldap_url_desc2str,
+		  AC_DEFINE(HAVE_LDAP_URL_DESC2STR,1,[Define to 1 if you have ldap_url_desc2str]),)
+
+		dnl
+		dnl Check for ldap_url_parse
+		dnl
+		AC_CHECK_LIB(ldap,ldap_url_parse,
+		  AC_DEFINE(HAVE_LDAP_URL_PARSE,1,[Define to 1 if you have ldap_url_parse]),)
+
+		dnl
+		dnl Check for ldap_start_tls_s
+		dnl
+		AC_CHECK_LIB(ldap,ldap_start_tls_s,
+		  AC_DEFINE(HAVE_LDAP_START_TLS_S,1,[Define to 1 if you have ldap_start_tls_s]),)
+		;;
+esac
+
+AC_SUBST(LDAPLIB)
+AC_SUBST(LBERLIB)
+
+AC_ARG_ENABLE(forw-via-db,
+  AS_HELP_STRING([--enable-forw-via-db],[Enable Forw/Via database]), [
+  SQUID_YESNO([$enableval],[unrecognized argument to --enable-forw-via-db: $enableval])
+])
+SQUID_DEFINE_BOOL(USE_FORW_VIA_DB,${enable_forw_via_db:=no},
+                      [Enable Forw/Via database])
+AC_MSG_NOTICE([Forw/Via database enabled: $enable_forw_via_db])
+
+AC_ARG_ENABLE(cache-digests,
+  AS_HELP_STRING([--enable-cache-digests],
+   [Use Cache Digests. See http://wiki.squid-cache.org/SquidFaq/CacheDigests]),
+[
+ SQUID_YESNO($enableval,
+   [unrecognized argument to --enable-cache-digests: $enableval])
+])
+SQUID_DEFINE_BOOL(USE_CACHE_DIGESTS,${enable_cache_digests:=no},
+  [Use Cache Digests for locating objects in neighbor caches.])
+AC_MSG_NOTICE([Cache Digests enabled: $enable_cache_digests])
+
+
+################################
+# check for netio plugin stuff #
+################################
+dnl order of these options handling is relevant in case the user
+dnl supplies more than one --enable option. Options handled later
+dnl override those handled earlier for io loop method manual override
+AC_ARG_ENABLE(select,
+  AS_HELP_STRING([--disable-select],[Disable select(2) support.]),
+[
+SQUID_YESNO($enableval,[--disable-select takes no extra argument])
+if test "x$enableval" = "xyes"; then
+  if test "x$squid_host_os" = "xmingw"; then
+    squid_opt_io_loop_engine="select_win32"
+  else
+    squid_opt_io_loop_engine="select"
+  fi
+fi
+])
+AC_MSG_NOTICE([enabling select syscall for net I/O: ${enable_select:=auto}])
+
+AC_ARG_ENABLE(poll,
+  AS_HELP_STRING([--disable-poll],[Disable poll(2) support.]),
+[
+SQUID_YESNO($enableval,[--disable-poll takes no extra argument])
+test "x$enableval" = "xyes" && squid_opt_io_loop_engine="poll"
+])
+AC_MSG_NOTICE([enabling poll syscall for net I/O: ${enable_poll:=auto}])
+
+AC_ARG_ENABLE(kqueue,
+  AS_HELP_STRING([--disable-kqueue],
+                 [Disable kqueue(2) support.]), [
+SQUID_YESNO($enableval,[--enable-kqueue takes no extra argument])
+])
+if test "x${enable_kqueue:=auto}" != "xno" ; then
+  AC_CHECK_HEADERS([sys/event.h],[],[
+    if test "x${enable_kqueue}" = "xyes" ; then
+      AC_MSG_ERROR([kqueue support requires sys/event.h header file.])
+    fi
+  ])
+  AC_CHECK_FUNCS(kqueue,[],[
+    if test "x${enable_kqueue}" = "xyes" ; then
+      AC_MSG_ERROR([kqueue support missing in libc library.])
+    fi
+  ])
+  if test "x$ac_cv_func_kqueue" = "xyes" -a "x$ac_cv_header_sys_event_h" = "xyes" ; then
+    squid_opt_io_loop_engine="kqueue"
+  else
+    enable_kqueue="no"
+  fi
+fi
+AC_MSG_NOTICE([enabling kqueue for net I/O: ${enable_kqueue:=auto}])
+
+dnl Enable epoll()
+AC_ARG_ENABLE(epoll,
+  AS_HELP_STRING([--disable-epoll],[Disable Linux epoll(2) support.]),
+[
+SQUID_YESNO($enableval,[--disable-epoll takes no extra argument])
+test "x$enableval" = "xyes" && squid_opt_io_loop_engine="epoll"
+])
+AC_MSG_NOTICE([enabling epoll syscall for net I/O: ${enable_epoll:=auto}])
+
+# auto-detect and verify epoll header and library present and working
+# logic mapping and loop method selection are performed later
+if test "x$enable_epoll" != "xno" ; then
+
+  # check if libs are needed to support epoll
+  # note: this code block seems quite generic. Could it be extracted
+  #   into a squid specific configure function?
+  SQUID_STATE_SAVE(squid_epoll_state)
+  AC_SEARCH_LIBS(epoll_ctl,[epoll])
+  if test "x$ac_cv_search_epoll_ctl" = "xno" ; then
+    enable_epoll=no #disable. Needed code not found
+  elif test "x$ac_cv_search_epoll_ctl" = "xnone required" ; then
+    EPOLL_LIBS=""
+  else
+    EPOLL_LIBS=$ac_cv_search_epoll_ctl
+  fi
+  AC_SUBST(EPOLL_LIBS)
+  SQUID_STATE_ROLLBACK(squid_epoll_state) #de-pollute LIBS
+
+  # epoll requires sys/epoll.h
+  AC_CHECK_HEADERS([sys/epoll.h])
+
+  dnl Verify that epoll really works
+  if test "x$ac_cv_search_epoll_ctl" != 'xno' ; then
+    SQUID_CHECK_EPOLL
+  fi
+
+  if test "x$enable_epoll" = "xyes" -a "x$squid_cv_epoll_works" = "xno" ; then
+    AC_MSG_ERROR([Epoll does not work. Force-enabling it is not going to help.])
+  fi
+fi
+
+dnl Enable /dev/poll
+AC_ARG_ENABLE(devpoll,
+  AS_HELP_STRING([--disable-devpoll],[Disable Solaris /dev/poll support.]),
+[
+SQUID_YESNO($enableval,[--disable-devpoll takes no extra argument])
+test "x$enableval" = "xyes" && squid_opt_io_loop_engine="devpoll"
+])
+AC_MSG_NOTICE([enabling /dev/poll for net I/O: ${enable_devpoll:=auto}])
+
+## auto-detect and verify devpoll header and library present and working
+if test "x$enable_devpoll" != "xno"; then
+
+  # /dev/poll requires ioctl() and write()
+  AC_CHECK_FUNCS(ioctl)
+  AC_CHECK_FUNCS(write)
+
+  # /dev/poll requires sys/devpoll.h
+  AC_CHECK_HEADERS([sys/devpoll.h],,[
+        if test "x$enable_devpoll" = "xyes"; then
+            AC_MSG_ERROR([--enable-devpoll specified but /dev/poll headers not found])
+        fi
+        enable_devpoll=no])
+
+  # Verify that /dev/poll really works
+  if test "x$enable_devpoll" != 'xno' ; then
+    SQUID_CHECK_DEVPOLL
+  fi
+
+  if test "x$enable_devpoll" = "xyes" -a "x$squid_cv_devpoll_works" = "xno" ; then
+    AC_MSG_ERROR([/dev/poll does not work. Force-enabling it is not going to help.])
+  fi
+fi
+
+
+AC_ARG_ENABLE(http-violations,
+  AS_HELP_STRING([--disable-http-violations],
+                 [This allows you to remove code which is known to
+                  violate the HTTP protocol specification.]), [
+  SQUID_YESNO([$enableval],
+         [unrecognized argument to --disable-http-violations: $enableval])
+])
+SQUID_DEFINE_BOOL(USE_HTTP_VIOLATIONS, ${enable_http_violations:=yes},
+  [Define to enable code which volates the HTTP standard specification])
+AC_MSG_NOTICE([HTTP violations support enabled: $enable_http_violations])
+
+# IPFW Transparent Proxy
+AC_ARG_ENABLE(ipfw-transparent,
+  AS_HELP_STRING([--enable-ipfw-transparent],
+                 [Enable Transparent Proxy support for systems
+                  using FreeBSD IPFW-style firewalling.]), [
+  SQUID_YESNO([$enableval],
+      [unrecognized argument to --enable-ipfw-transparent: $enableval])
+])
+SQUID_DEFINE_BOOL(IPFW_TRANSPARENT,${enable_ipfw_transparent:=no},
+  [Enable support for Transparent Proxy on systems using FreeBSD IPFW-style firewalling.])
+AC_MSG_NOTICE([FreeBSD IPFW-based transparent proxying enabled: $enable_ipfw_transparent])
+
+# IP-Filter Transparent Proxy
+AC_ARG_ENABLE(ipf-transparent,
+  AS_HELP_STRING([--enable-ipf-transparent],
+     [Enable Transparent Proxy support using IPFilter-style firewalling]), [
+  SQUID_YESNO([$enableval],
+      [unrecognized argument to --enable-ipf-transparent: $enableval])
+])
+#will be AC_DEFINEd later, after checking for appropriate infrastructure
+#IPF currently broken. Default-disabled for now.
+AC_MSG_NOTICE([IPF-based transparent proxying requested: ${enable_ipf_transparent:=no}])
 
 dnl Enable PF Transparent Proxy
 AC_ARG_ENABLE(pf-transparent,
@@ -1815,198 +2498,32 @@ AC_ARG_ENABLE(auth-digest,
       Not providing an explicit list of helpers will attempt build of
       all possible helpers. Default is to do so.
       To disable the Digest authentication scheme, use --disable-auth-digest.
-      To enable but build no helpers, specify "none".
-      To see available helpers, see the helpers/digest_auth directory. ]),[
-#nothing to do, really
-])
-m4_include([helpers/digest_auth/modules.m4])
-
-dnl Authentication libraries to build
-dnl This list will not be needed when each auth library has its own Makefile
-dnl this is to be placed AFTER each auth module's handler
-AUTH_LIBS_TO_BUILD=
-for module in $AUTH_MODULES; do
-    AUTH_LIBS_TO_BUILD="$AUTH_LIBS_TO_BUILD ${module}/lib${module}.la"
-done
-AC_SUBST(AUTH_MODULES)
-AC_SUBST(AUTH_LIBS_TO_BUILD)
-
-dnl Select logging daemon helpers to build
-AC_ARG_ENABLE(log-daemon-helpers,
-  AS_HELP_STRING([--enable-log-daemon-helpers="list of helpers"],
-                 [This option selects which logging daemon helpers to 
-                  build and install as part of the normal build process
-                  For a list of available helpers see the helpers/log_daemon
-                  directory.]),[
-#nothing to do, really
-])
-m4_include([helpers/log_daemon/modules.m4])
-
-dnl
-dnl Check Kerberos/GSSAPI/SPNEGO
-dnl
-SQUID_STATE_SAVE([krbsave])
-
-AC_ARG_WITH(krb5-config,
-  AS_HELP_STRING([--with-krb5-config=PATH],
-                 [specify path to krb5-config (default=detect)]), [
-case "$withval" in
-  yes) unset krb5confpath ;;
-  no)  krb5confpath=no ;;
-  *)   krb5confpath=$withval ;;
-esac
-])
-if test x"$krb5confpath" != "xno"; then
-    if test "x$krb5confpath" != "x"; then
-        if ! test -x "$krb5confpath"; then
-            AC_MSG_WARN([krb5-config '$krb5confpath' not executable, ignoring])
-            AC_CHECK_PROG(ac_krb5_config, krb5-config, yes, no)
-            krb5confpath=krb5-config
-        fi
-        krb5_config_path=`dirname $krb5confpath`
-        AC_CHECK_PROG(ac_krb5_config, krb5-config, yes, no, $krb5_config_path)
-    else
-    AC_CHECK_PROG(ac_krb5_config,krb5-config,yes,no)
-        krb5confpath=krb5-config
-    fi
-fi
-if test "x$ac_krb5_config" = "xyes" ; then
-  ac_heimdal="`$krb5confpath --version 2>/dev/null | grep -i heimdal`"
-  ac_solaris="`$krb5confpath --version 2>/dev/null | grep -i solaris`"
-  if test "x$ac_heimdal" != "x" ; then
-    AC_DEFINE(HAVE_HEIMDAL_KERBEROS,1,[Define to 1 if you have Heimdal Kerberos])
-  else
-    AC_DEFINE(HAVE_MIT_KERBEROS,1,[Define to 1 if you have MIT Kerberos])
-  fi
-  if test "x$ac_solaris" != "x" ; then
-    KRB5INCS="`$krb5confpath --cflags krb5 2>/dev/null`"
-    KRB5LIBS="`$krb5confpath --libs krb5 2>/dev/null`"
-    KRB5INCS="-I/usr/include/gssapi $KRB5INCS"
-    KRB5LIBS="-L/usr/lib -R/usr/lib -lgss -lresolv -lsocket -lnsl $KRB5LIBS"
-  else
-    KRB5INCS="`$krb5confpath --cflags krb5 2>/dev/null`"
-    KRB5LIBS="`$krb5confpath --libs krb5 2>/dev/null`"
-    KRB5INCS="`$krb5confpath --cflags gssapi 2>/dev/null` $KRB5INCS"
-    KRB5LIBS="`$krb5confpath --libs gssapi 2>/dev/null` $KRB5LIBS"
-  fi
-  CPPFLAGS="$CPPFLAGS $KRB5INCS"
-  LIBS="$LIBS $KRB5LIBS"
-  AC_CHECK_HEADERS(gssapi.h gssapi/gssapi.h gssapi/gssapi_krb5.h)
-  if test "x$ac_heimdal" = "x" ; then
-    AC_CHECK_HEADERS(gssapi/gssapi_generic.h)
-    AC_CHECK_HEADERS(profile.h)
-  fi
-
-  SQUID_CHECK_KRB5_SOLARIS_BROKEN_KRB5_H
-  if test "x$squid_cv_broken_krb5_h" = "xyes"; then
-    AC_DEFINE(HAVE_BROKEN_SOLARIS_KRB5_H, 1, [Define to 1 if Solaris krb5.h is broken for C++])
-    AC_MSG_WARN([You have a broken Solaris <krb5.h> system include.])
-    AC_MSG_WARN([Please see http://bugs.opensolaris.org/bugdatabase/view_bug.do?bug_id=6837512])
-    AC_MSG_WARN([If you need Kerberos support you'll have to patch])
-    AC_MSG_WARN([your system. See contrib/solaris/solaris-krb5-include.patch])
-  fi
-  SQUID_CHECK_KRB5_HEIMDAL_BROKEN_KRB5_H
-  if test "x$squid_cv_broken_heimdal_krb5_h" = "xyes"; then
-    AC_DEFINE(HAVE_BROKEN_HEIMDAL_KRB5_H, 1, [Define to 1 if Heimdal krb5.h is broken for C++])
-  fi
-  AC_CHECK_HEADERS(krb5.h com_err.h et/com_err.h)
-
-  ac_com_error_message=no
-  if test "x$ac_cv_header_com_err_h" = "xyes" ; then
-      AC_EGREP_HEADER(error_message,com_err.h,ac_com_error_message=yes)
-  elif test "x$ac_cv_header_et_com_err_h" = "xyes" ; then
-      AC_EGREP_HEADER(error_message,et/com_err.h,ac_com_error_message=yes)
-  fi
+      To enable but build no helpers, specify "none".
+      To see available helpers, see the helpers/digest_auth directory. ]),[
+#nothing to do, really
+])
+m4_include([helpers/digest_auth/modules.m4])
 
-  SQUID_CHECK_MAX_SKEW_IN_KRB5_CONTEXT
-  if test "x$squid_cv_max_skew_context" = "xyes"; then
-    AC_DEFINE(HAVE_MAX_SKEW_IN_KRB5_CONTEXT, 1, [Define to 1 if max_skew in struct krb5_context])
-  fi
+dnl Authentication libraries to build
+dnl This list will not be needed when each auth library has its own Makefile
+dnl this is to be placed AFTER each auth module's handler
+AUTH_LIBS_TO_BUILD=
+for module in $AUTH_MODULES; do
+    AUTH_LIBS_TO_BUILD="$AUTH_LIBS_TO_BUILD ${module}/lib${module}.la"
+done
+AC_SUBST(AUTH_MODULES)
+AC_SUBST(AUTH_LIBS_TO_BUILD)
 
-  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
-    AC_CHECK_LIB(com_err,error_message,
-      AC_DEFINE(HAVE_ERROR_MESSAGE,1,
-        [Define to 1 if you have error_message]),)
-  elif test  "x$ac_com_error_message" = "xyes" ; then
-    AC_CHECK_LIB(krb5,error_message,
-      AC_DEFINE(HAVE_ERROR_MESSAGE,1,
-        [Define to 1 if you have error_message]),)
-  fi
-  AC_CHECK_LIB(krb5,krb5_get_err_text,
-    AC_DEFINE(HAVE_KRB5_GET_ERR_TEXT,1,
-      [Define to 1 if you have krb5_get_err_text]),)
-  AC_CHECK_LIB(krb5,krb5_get_error_message,
-    AC_DEFINE(HAVE_KRB5_GET_ERROR_MESSAGE,1,
-      [Define to 1 if you have krb5_get_error_message]),)
-  AC_CHECK_DECLS(krb5_kt_free_entry,,,[#include <krb5.h>])
-  AC_CHECK_TYPE(krb5_pac,
-    AC_DEFINE(HAVE_KRB5_PAC,1,
-      [Define to 1 if you have krb5_pac]),,
-      [#include <krb5.h>])
-  AC_CHECK_LIB(krb5,krb5_kt_free_entry,
-    AC_DEFINE(HAVE_KRB5_KT_FREE_ENTRY,1,
-      [Define to 1 if you have krb5_kt_free_entry]),)
-  AC_CHECK_LIB(krb5,krb5_get_init_creds_keytab,
-    AC_DEFINE(HAVE_GET_INIT_CREDS_KEYTAB,1,
-      [Define to 1 if you have krb5_get_init_creds_keytab]),)
-  AC_CHECK_LIB(krb5,krb5_get_max_time_skew,
-    AC_DEFINE(HAVE_KRB5_GET_MAX_TIME_SKEW,1,
-      [Define to 1 if you have krb5_get_max_time_skew]),)
-  AC_CHECK_LIB(krb5,krb5_get_profile,
-    AC_DEFINE(HAVE_KRB5_GET_PROFILE,1,
-      [Define to 1 if you have krb5_get_profile]),)
-  AC_CHECK_LIB(krb5,profile_get_integer,
-    AC_DEFINE(HAVE_PROFILE_GET_INTEGER,1,
-      [Define to 1 if you have profile_get_integer]),)
-  AC_CHECK_LIB(krb5,profile_release,
-    AC_DEFINE(HAVE_PROFILE_RELEASE,1,
-      [Define to 1 if you have profile_release]),)
-  AC_CHECK_LIB(krb5,krb5_get_renewed_creds,
-    AC_DEFINE(HAVE_KRB5_GET_RENEWED_CREDS,1,
-      [Define to 1 if you have krb5_get_renewed_creds]),)
-  AC_CHECK_LIB(krb5,krb5_principal_get_realm,
-    AC_DEFINE(HAVE_KRB5_PRINCIPAL_GET_REALM,1,
-      [Define to 1 if you have krb5_principal_get_realm]),)
-  AC_CHECK_LIB(krb5, krb5_get_init_creds_opt_alloc,
-    AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC,1,
-      [Define to 1 if you have krb5_get_init_creds_opt_alloc]),)
-  AC_MSG_CHECKING([for krb5_get_init_creds_free requires krb5_context])
-  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-	#include <krb5.h>
-    ]],[[krb5_context context;
-	 krb5_get_init_creds_opt *options;
-	 krb5_get_init_creds_opt_free(context, options)]])],[
-	AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT,1,
-		  [Define to 1 if you krb5_get_init_creds_free requires krb5_context])
-	AC_MSG_RESULT(yes)
-    ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
-
-
-  AC_CHECK_FUNCS(gss_map_name_to_any,
-    AC_DEFINE(HAVE_GSS_MAP_ANY_TO_ANY,1,
-      [Define to 1 if you have gss_map_name_to_any]),)
-  AC_CHECK_FUNCS(gsskrb5_extract_authz_data_from_sec_context,
-    AC_DEFINE(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT,1,
-      [Define to 1 if you have gsskrb5_extract_authz_data_from_sec_context]),)
-
-  SQUID_CHECK_KRB5_CONTEXT_MEMORY_CACHE
-  SQUID_DEFINE_BOOL(HAVE_KRB5_MEMORY_CACHE,$squid_cv_memory_cache,
-       [Define if kerberos has MEMORY: cache support])
-
-  SQUID_CHECK_WORKING_GSSAPI
-  SQUID_DEFINE_BOOL(HAVE_GSSAPI,$squid_cv_working_gssapi,[GSSAPI support])
-
-  SQUID_CHECK_SPNEGO_SUPPORT
-  SQUID_DEFINE_BOOL(HAVE_SPNEGO,$squid_cv_have_spnego,[SPNEGO support])
-
-  SQUID_CHECK_WORKING_KRB5
-  SQUID_DEFINE_BOOL(HAVE_KRB5,$squid_cv_working_krb5,[KRB5 support])
-
-  AC_SUBST(KRB5INCS)
-  AC_SUBST(KRB5LIBS)
-fi
-SQUID_STATE_ROLLBACK([krbsave])
-AM_CONDITIONAL(HAVE_SPNEGO, test x"$squid_cv_have_spnego" = x"yes" )
+dnl Select logging daemon helpers to build
+AC_ARG_ENABLE(log-daemon-helpers,
+  AS_HELP_STRING([--enable-log-daemon-helpers="list of helpers"],
+                 [This option selects which logging daemon helpers to 
+                  build and install as part of the normal build process
+                  For a list of available helpers see the helpers/log_daemon
+                  directory.]),[
+#nothing to do, really
+])
+m4_include([helpers/log_daemon/modules.m4])
 
 AC_ARG_ENABLE(external-acl-helpers,
   AS_HELP_STRING([--enable-external-acl-helpers="list of helpers"],
@@ -2636,235 +3153,6 @@ case "$host" in
 		;;
 esac
 
-dnl On MinGW OpenLDAP is not available, so LDAP helpers can be linked 
-dnl only with Windows LDAP libraries using -lwldap32
-case "$squid_host_os" in
-	mingw)
-		LDAPLIB="-lwldap32"
-		LBERLIB=""
-		;;
-	*)
-		AC_CHECK_LIB(ldap, ldap_init, [LDAPLIB="-lldap"])
-		dnl LDAP helpers need to know if -llber is needed or not
-		AC_CHECK_LIB(lber, ber_init, [LBERLIB="-llber"])
-		dnl if no ldap lib found check for mozilla version
-		if test "x$ac_cv_lib_ldap_ldap_init" != x""yes; then
-		        oLIBS=$LIBS
-		        LIBS="$LIBPTHREADS"
-			AC_CHECK_LIB(ldap60, ldap_init, [LDAPLIB="-lldap60"])
-		        LIBS="$LDAPLIB $LIBPTHREADS"
-			AC_CHECK_LIB(prldap60, prldap_init, [LDAPLIB="-lprldap60 $LDAPLIB"])
-		        LIBS="$LDAPLIB $LIBPTHREADS"
-			AC_CHECK_LIB(ssldap60, ldapssl_init, [LDAPLIB="-lssldap60 $LDAPLIB"])
-		        LIBS=$oLIBS
-		fi
-
-		AC_CHECK_HEADERS(ldap.h lber.h)
-		AC_CHECK_HEADERS(mozldap/ldap.h)
-
-		dnl
-		dnl Check for LDAP_OPT_DEBUG_LEVEL
-		dnl
-		AC_MSG_CHECKING([for LDAP_OPT_DEBUG_LEVEL])
-		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#                   include <ldap.h>
-		]],[[
-                    int i=LDAP_OPT_DEBUG_LEVEL
-		]])],
-		[ AC_MSG_RESULT(yes) ],
-		[ AC_MSG_RESULT(no) ])
-
-		dnl
-		dnl Check for working ldap
-		dnl
-		oLIBS=$LIBS
-		LIBS="$LDAPLIB $LBERLIB $LIBPTHREADS"
-		AC_MSG_CHECKING([for working ldap])
-		AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#                   define  LDAP_DEPRECATED 1
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   elif HAVE_MOZLDAP_LDAP_H
-#                   include <mozldap/ldap.h>
-#                   endif
-                    int
-                    main(void)
-                    {
-                        char host[]="";
-                        int port;
-
-                        ldap_init((const char *)&host, port);
-
-                        return 0;
-                    }
-		]])], 
-		[ AC_DEFINE(HAVE_LDAP, 1, [LDAP support]) 
-		  AC_MSG_RESULT(yes) ],
-		[ AC_MSG_RESULT(no) ],
-		[ AC_MSG_RESULT(cross-compiler cant tell) ])
-		LIBS=$oLIBS
-
-		dnl
-		dnl Check for ldap vendor
-		dnl
-		AC_MSG_CHECKING([for OpenLDAP])
-		AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   endif
-#                   include <string.h>
-                    int
-                    main(void)
-                    {
-                        return strcmp(LDAP_VENDOR_NAME,"OpenLDAP");
-                    }
-		]])], 
-		[ AC_DEFINE(HAVE_OPENLDAP, 1, [OpenLDAP support]) 
-		  AC_MSG_RESULT(yes) ],
-		[ AC_MSG_RESULT(no) ],
-		[ AC_MSG_RESULT(cross-compiler cant tell) ])
-
-		AC_MSG_CHECKING([for Sun LDAP SDK])
-		AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   endif
-#                   include <string.h>
-                    int
-                    main(void)
-                    {
-                        return strcmp(LDAP_VENDOR_NAME,"Sun Microsystems Inc.");
-                    }
-		]])], 
-		[ AC_DEFINE(HAVE_SUN_LDAP_SDK, 1, [Sun LDAP SDK support])
-		  AC_MSG_RESULT(yes) ],
-		[ AC_MSG_RESULT(no) ],
-		[ AC_MSG_RESULT(cross-compiler cant tell) ])
-
-		AC_MSG_CHECKING([for Mozilla LDAP SDK])
-		AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   elif HAVE_MOZLDAP_LDAP_H
-#                   include <mozldap/ldap.h>
-#                   endif
-#                   include <string.h>
-                    int
-                    main(void)
-                    {
-                        return strcmp(LDAP_VENDOR_NAME,"mozilla.org");
-                    }
-		]])], 
-		[ AC_DEFINE(HAVE_MOZILLA_LDAP_SDK, 1, [Mozilla LDAP SDK support])
-		  AC_MSG_RESULT(yes) ],
-		[ AC_MSG_RESULT(no)],
-		[ AC_MSG_RESULT(cross-compiler cant tell) ])
-
-		dnl
-		dnl Check for LDAP_REBINDPROC_CALLBACK
-		dnl
-                AC_MSG_CHECKING([for LDAP_REBINDPROC_CALLBACK])
-                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   elif HAVE_MOZLDAP_LDAP_H
-#                   include <mozldap/ldap.h>
-#                   endif
-                ]],[[
-                    LDAP_REBINDPROC_CALLBACK ldap_rebind;
-                ]])],
-                [ AC_DEFINE(HAVE_LDAP_REBINDPROC_CALLBACK,1,[Define to 1 if you have LDAP_REBINDPROC_CALLBACK])
-                  AC_MSG_RESULT(yes) ],
-                [ AC_MSG_RESULT(no) ])
-
-		dnl
-		dnl Check for LDAP_REBIND_PROC
-		dnl
-                AC_MSG_CHECKING([for LDAP_REBIND_PROC])
-                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   elif HAVE_MOZLDAP_LDAP_H
-#                   include <mozldap/ldap.h>
-#                   endif
-                ]],[[
-                    LDAP_REBIND_PROC ldap_rebind;
-                ]])],
-                [ AC_DEFINE(HAVE_LDAP_REBIND_PROC,1,[Define to 1 if you have LDAP_REBIND_PROC])
-                  AC_MSG_RESULT(yes) ],
-                [ AC_MSG_RESULT(no) ])
-
-		dnl
-		dnl Check for LDAP_REBIND_FUNCTION
-		dnl
-                AC_MSG_CHECKING([for LDAP_REBIND_FUNCTION])
-                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#                   define LDAP_REFERRALS
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   elif HAVE_MOZLDAP_LDAP_H
-#                   include <mozldap/ldap.h>
-#                   endif
-                ]],[[
-                    LDAP_REBIND_FUNCTION ldap_rebind;
-                ]])],
-                [ AC_DEFINE(HAVE_LDAP_REBIND_FUNCTION,1,[Define to 1 if you have LDAP_REBIND_FUNCTION])
-                  AC_MSG_RESULT(yes) ],
-                [ AC_MSG_RESULT(no) ])
-
-		dnl
-		dnl Check for LDAP_SCOPE_DEFAULT
-		dnl
-                AC_MSG_CHECKING([for LDAP_SCOPE_DEFAULT])
-                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#                   if HAVE_LDAP_H
-#                   include <ldap.h>
-#                   elif HAVE_MOZLDAP_LDAP_H
-#                   include <mozldap/ldap.h>
-#                   endif
-                ]],[[
-                    int i=LDAP_SCOPE_DEFAULT;
-                ]])],
-                [ AC_DEFINE(HAVE_LDAP_SCOPE_DEFAULT,1,[Define to 1 if you have LDAP_SCOPE_DEFAULT])
-                  AC_MSG_RESULT(yes) ],
-                [ AC_MSG_RESULT(no) ])
-
-		dnl
-		dnl Check for ldap_url_desc.lud_scheme
-		dnl
-		AC_CHECK_MEMBER(struct ldap_url_desc.lud_scheme,
-		  AC_DEFINE(HAVE_LDAP_URL_LUD_SCHEME,1,
-		    [Define to 1 if you have LDAPURLDesc.lud_scheme]),,[#include <ldap.h>])
-
-		dnl
-		dnl Check for ldapssl_client_init
-		dnl
-		AC_CHECK_LIB(ldap,ldapssl_client_init,
-		  AC_DEFINE(HAVE_LDAPSSL_CLIENT_INIT,1,[Define to 1 if you have ldapssl_client_init]),)
-
-		dnl
-		dnl Check for ldap_url_desc2str
-		dnl
-		AC_CHECK_LIB(ldap,ldap_url_desc2str,
-		  AC_DEFINE(HAVE_LDAP_URL_DESC2STR,1,[Define to 1 if you have ldap_url_desc2str]),)
-
-		dnl
-		dnl Check for ldap_url_parse
-		dnl
-		AC_CHECK_LIB(ldap,ldap_url_parse,
-		  AC_DEFINE(HAVE_LDAP_URL_PARSE,1,[Define to 1 if you have ldap_url_parse]),)
-
-		dnl
-		dnl Check for ldap_start_tls_s
-		dnl
-		AC_CHECK_LIB(ldap,ldap_start_tls_s,
-		  AC_DEFINE(HAVE_LDAP_START_TLS_S,1,[Define to 1 if you have ldap_start_tls_s]),)
-		;;
-esac
-
-AC_SUBST(LDAPLIB)
-AC_SUBST(LBERLIB)
-
 dnl Check for libdb
 dnl this is not fully functional if db.h is for a differend db version
 DBLIB=
@@ -3459,8 +3747,11 @@ AC_CONFIG_FILES([
 	scripts/Makefile
 	src/Makefile
 	src/anyp/Makefile
+	src/ftp/Makefile
 	src/base/Makefile
 	src/acl/Makefile
+	src/clients/Makefile
+	src/servers/Makefile
 	src/fs/Makefile
 	src/repl/Makefile
 	src/auth/Makefile
@@ -67,6 +67,7 @@ section 30    Ident (RFC 931)
 section 31    Hypertext Caching Protocol
 section 32    Asynchronous Disk I/O
 section 33    Client-side Routines
+section 33    Transfer protocol servers
 section 35    FQDN Cache
 section 37    ICMP Routines
 section 38    Network Measurement Database
@@ -32,6 +32,24 @@ Although this release is deemed good enough for use in many setups, please note
 <p>
 The 3.5 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.5/changesets/" name="viewed here">.
 
+<sect1>Copyright disclaimer adjustments
+<p>Squid sources are now administered by the Squid Software Foundation on
+   behalf of the Squid Project and community.
+
+<p>This version of Squid contains initial changes to streamline copyright
+   declarations in Squid sources and related metafiles. No functionality
+   or licensing changes are intended.
+
+<p>Once completed, the changes will consistently declare Squid contributors
+   (listed in CONTRIBUTORS and represented by the Squid Software Foundation) as
+   Squid copyright owners while referring the reader to the COPYING file for GPL
+   licensing details. The boilerplate with the above information is provided.
+
+<p>These changes do not affect copyright rights of individuals or organizations.
+   We are simply confirming the fact that there are many Squid copyright owners,
+   just like there are many Linux kernel copyright owners. We are also providing
+   a simple, consistent way to document that fact.
+
 
 <sect>Major new features since Squid-3.4
 <p>Squid 3.5 represents a new feature release above 3.4.
@@ -43,6 +61,7 @@ The 3.5 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Support named services
 	<item>Upgraded squidclient tool
 	<item>Helper support for concurrency channels
+	<item>Native FTP Relay
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -163,6 +182,48 @@ Most user-facing changes are reflected in squid.conf (see below).
    With these helpers concurrency may now be set to 0 or any higher number as desired.
 
 
+<sect1>Native FTP Relay
+<p>Details at <url url="http://wiki.squid-cache.org/Features/FtpRelay">.
+
+<p>Squid is now capable of accepting native FTP commands and relaying native
+   FTP messages between FTP clients and FTP servers. Native FTP commands
+   accepted at ftp_port are internally converted or wrapped into HTTP-like
+   messages. The same happens to Native FTP responses received from FTP origin
+   servers. Those HTTP-like messages are shoveled through regular access
+   control and adaptation layers between the FTP client and the FTP origin
+   server. This allows Squid to examine, adapt, block, and log FTP exchanges.
+   Squid reuses most HTTP mechanisms when shoveling wrapped FTP messages. For
+   example, http_access and adaptation_access directives are used.
+
+<p>FTP Relay is a new, experimental, complex feature that has seen limited
+   production exposure. Some Squid modules (e.g., caching) do not currently
+   work with native FTP proxying, and many features have not even been tested
+   for compatibility. Test well before deploying!
+
+<p>Native FTP proxying differs substantially from proxying HTTP requests with
+   <em>ftp://</em> URIs because Squid works as an FTP server and receives
+   actual FTP commands (rather than HTTP requests with FTP URLs).
+
+<p>FTP Relay highlights:</p>
+
+<itemize>
+    <item>Added ftp_port directive telling Squid to relay native FTP commands.
+    <item>Active and passive FTP support on the user-facing side; require
+	  passive connections to come from the control connection source IP
+	  address.
+    <item>IPv6 support (EPSV and, on the user-facing side, EPRT).
+    <item>Intelligent adaptation of relayed FTP FEAT responses.
+    <item>Relaying of multi-line FTP control responses using various formats.
+    <item>Support relaying of FTP MLSD and MLST commands (RFC 3659).
+    <item>Several Microsoft FTP server compatibility features.
+    <item>ICAP/eCAP support (at individual FTP command/response level).
+    <item>Optional "current FTP directory" tracking with the assistance of
+	  injected (by Squid) PWD commands (cannot be 100% reliable due to
+	  symbolic links and such, but is helpful in some common use cases).
+    <item>No caching support -- no reliable Request URIs for that (see above).
+</itemize>
+
+
 <sect>Changes to squid.conf since Squid-3.4
 <p>
 There have been changes to Squid's configuration file since Squid-3.4.
@@ -228,6 +289,22 @@ This section gives a thorough account of those changes in three categories:
 	</verb>
 	<p>The default value for extras is: "%>a/%>A %un %>rm myip=%la myport=%lp"
 
+	<tag>ftp_port</tag>
+
+	<p>New configuration directive to accept and relay native FTP
+	   commands. Typically used for port 21 traffic.  By default, native
+	   FTP commands are not accepted.
+
+	<tag>ftp_client_idle_timeout</tag>
+
+	<p>This new configuration directive controls how long Squid should
+	   wait for an FTP request on a connection to an ftp_port.  Many FTP
+	   clients do not deal with idle connection closures well,
+	   necessitating a longer default timeout (30 minutes) than
+	   client_idle_pconn_timeout used for incoming HTTP requests (2
+	   minutes). The current default may be changed as we get more
+	   experience with FTP relaying.
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -351,6 +428,21 @@ This section gives an account of those changes in three categories:
 	   Use of this library is auto-enabled if v3.1.5 or later is available.
 	<p>It is currently only used by the squidclient tool.
 
+	<tag>--without-mit-krb5</tag>
+	<p>New option to explicitly disable use of MIT Kerberos library.
+	   Default is to auto-detect and use if possible.
+	<p>Only one Kerberos library may be built against.
+
+	<tag>--without-heimdal-krb5</tag>
+	<p>New option to explicitly disable use of Hiemdal Kerberos library.
+	   Default is to auto-detect and use if possible.
+	<p>Only one Kerberos library may be built against.
+
+	<tag>--without-gnugss</tag>
+	<p>New option to explicitly disable use of GNU GSSAPI library for Kerberos.
+	   Default is to auto-detect and use if possible.
+	<p>Only one Kerberos library may be built against.
+
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
@@ -378,6 +470,11 @@ This section gives an account of those changes in three categories:
 	<p>The COSS cache type has been removed.
 	   It has been replaced by <em>rock</em> cache type.
 
+	<tag>--with-krb5-config</tag>
+	<p>Removed. The Kerberos library is auto-detected now.
+	<p>Use <em>--with/--without-mit-krb5</em>, <em>--with/--without-heimdal-krb5</em>, or
+	   <em>--with/--without-gnugss</em> options for specific library selection if necesary.
+
 </descrip>
 
 
@@ -34,7 +34,7 @@
 #include "rfc1738.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 #include <cctype>
@@ -165,7 +165,6 @@ main(int argc, char *const argv[])
     char *user, *domain, *group;
     char *up=NULL, *dp=NULL, *np=NULL;
     char *nuser, *nuser8 = NULL, *netbios;
-    char *c;
     int opt;
     struct main_args margs;
 
@@ -296,6 +295,7 @@ main(int argc, char *const argv[])
         exit(1);
     }
     while (1) {
+        char *c;
         if (fgets(buf, sizeof(buf) - 1, stdin) == NULL) {
             if (ferror(stdin)) {
                 debug((char *) "%s| %s: FATAL: fgets() failed! dying..... errno=%d (%s)\n", LogTime(), PROGRAM, ferror(stdin),
@@ -1,2 +1,4 @@
-AC_CHECK_HEADERS([ldap.h],[BUILD_HELPER="kerberos_ldap_group"])
-SQUID_CHECK_SASL
+if test "x$with_krb5" == "xyes"; then
+  BUILD_HELPER="kerberos_ldap_group"
+  SQUID_CHECK_SASL
+fi
@@ -47,7 +47,7 @@ extern "C" {
 
 #if HAVE_COM_ERR_H
 #include <com_err.h>
-#elif HAVE_HEIMDAL_KERBEROS
+#elif USE_HEIMDAL_KRB5
 #define error_message(code) krb5_get_err_text(kparam.context,code)
 #endif /* HAVE_COM_ERR_H */
 
@@ -162,7 +162,7 @@ size_t get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, s
 size_t get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name);
 size_t free_hostname_list(struct hstruct **hlist, size_t nhosts);
 
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 int tool_sasl_bind(LDAP * ld, char *binddn, char *ssl);
 #endif
 
@@ -26,7 +26,7 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 
@@ -61,10 +61,9 @@ char *
 utf8dup(struct main_args *margs)
 {
     size_t c = 0;
-    unsigned char s;
     size_t n;
     char *src;
-    unsigned char *p, *dupp;
+    unsigned char *p;
 
     src = margs->glist;
     if (!src)
@@ -73,9 +72,11 @@ utf8dup(struct main_args *margs)
         if ((unsigned char) src[n] > 127)
             ++c;
     if (c != 0) {
+        unsigned char *dupp;
         p = (unsigned char *) xmalloc(strlen(src) + c);
         dupp = p;
         for (n = 0; n < strlen(src); ++n) {
+            unsigned char s;
             s = (unsigned char) src[n];
             if (s > 127 && s < 192) {
                 *p = 194;
@@ -25,13 +25,12 @@
 #include "squid.h"
 #include "util.h"
 
-#if defined(HAVE_LDAP) && defined(HAVE_KRB5)
+#if HAVE_LDAP && HAVE_KRB5
 
 #include "support.h"
 
 struct kstruct {
     krb5_context context;
-    char *mem_cache_env;
     krb5_ccache cc;
 };
 
@@ -115,12 +114,12 @@ krb5_create_cache(char *domain)
 
         principal_list = (krb5_principal *) xrealloc(principal_list, sizeof(krb5_principal) * (nprinc + 1));
         krb5_copy_principal(kparam.context, entry.principal, &principal_list[nprinc++]);
-#ifdef HAVE_HEIMDAL_KERBEROS
+#if USE_HEIMDAL_KRB5
         debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, entry.principal->realm);
 #else
         debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, krb5_princ_realm(kparam.context, entry.principal)->data);
 #endif
-#ifdef HAVE_HEIMDAL_KERBEROS
+#if USE_HEIMDAL_KRB5
         if (!strcasecmp(domain, entry.principal->realm))
 #else
         if (!strcasecmp(domain, krb5_princ_realm(kparam.context, entry.principal)->data))
@@ -134,7 +133,7 @@ krb5_create_cache(char *domain)
                 found = 1;
             }
         }
-#if defined(HAVE_HEIMDAL_KERBEROS) || ( defined(HAVE_KRB5_KT_FREE_ENTRY) && HAVE_DECL_KRB5_KT_FREE_ENTRY==1)
+#if USE_HEIMDAL_KRB5 || ( HAVE_KRB5_KT_FREE_ENTRY && HAVE_DECL_KRB5_KT_FREE_ENTRY )
         code = krb5_kt_free_entry(kparam.context, &entry);
 #else
         code = krb5_free_keytab_entry_contents(kparam.context, &entry);
@@ -162,7 +161,7 @@ krb5_create_cache(char *domain)
     /*
      * prepare memory credential cache
      */
-#if  !defined(HAVE_KRB5_MEMORY_CACHE) || defined(HAVE_SUN_LDAP_SDK)
+#if  !HAVE_KRB5_MEMORY_CACHE || HAVE_SUN_LDAP_SDK
     mem_cache = (char *) xmalloc(strlen("FILE:/tmp/squid_ldap_") + 16);
     snprintf(mem_cache, strlen("FILE:/tmp/squid_ldap_") + 16, "FILE:/tmp/squid_ldap_%d", (int) getpid());
 #else
@@ -226,7 +225,7 @@ krb5_create_cache(char *domain)
             }
             if (creds->server)
                 krb5_free_principal(kparam.context, creds->server);
-#ifdef HAVE_HEIMDAL_KERBEROS
+#if USE_HEIMDAL_KRB5
             service = (char *) xmalloc(strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3);
             snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3, "krbtgt/%s@%s", domain, principal_list[i]->realm);
 #else
@@ -260,7 +259,6 @@ krb5_create_cache(char *domain)
 
         }
 
-        safe_free(principal_name);
         if (creds)
             krb5_free_creds(kparam.context, creds);
         creds = NULL;
@@ -42,20 +42,24 @@ LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 
 #define FILTER "(memberuid=%s)"
 #define ATTRIBUTE "cn"
+#define ATTRIBUTE_DN "distinguishedName"
 #define FILTER_UID "(uid=%s)"
 #define FILTER_GID "(&(gidNumber=%s)(objectclass=posixgroup))"
 #define ATTRIBUTE_GID "gidNumber"
+#define ATTRIBUTE_GID_AD "primaryGroupID"
+#define ATTRIBUTE_SID "objectSID"
 
 #define FILTER_AD "(samaccountname=%s)"
 #define ATTRIBUTE_AD "memberof"
 
 size_t get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
+size_t get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val , int **out_len /* OUT (caller frees) */ );
 int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth);
 
-#if defined(HAVE_SUN_LDAP_SDK) || defined(HAVE_MOZILLA_LDAP_SDK)
-#ifdef HAVE_LDAP_REBINDPROC_CALLBACK
+#if HAVE_SUN_LDAP_SDK || HAVE_MOZILLA_LDAP_SDK
+#if HAVE_LDAP_REBINDPROC_CALLBACK
 
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 static LDAP_REBINDPROC_CALLBACK ldap_sasl_rebind;
 
 static int LDAP_CALL LDAP_CALLBACK
@@ -94,8 +98,8 @@ ldap_simple_rebind(
     freeit = freeit;
     return ldap_bind_s(ld, cp->dn, cp->pw, LDAP_AUTH_SIMPLE);
 }
-#elif defined(HAVE_LDAP_REBIND_PROC)
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#elif HAVE_LDAP_REBIND_PROC
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 static LDAP_REBIND_PROC ldap_sasl_rebind;
 
 static int
@@ -125,11 +129,11 @@ ldap_simple_rebind(
     return ldap_bind_s(ld, cp->dn, cp->pw, LDAP_AUTH_SIMPLE);
 }
 
-#elif defined(HAVE_LDAP_REBIND_FUNCTION)
+#elif HAVE_LDAP_REBIND_FUNCTION
 #ifndef LDAP_REFERRALS
 #define LDAP_REFERRALS
 #endif
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 static LDAP_REBIND_FUNCTION ldap_sasl_rebind;
 
 static int
@@ -172,7 +176,7 @@ ldap_simple_rebind(
 #error "No rebind functione defined"
 #endif
 #else /* HAVE_SUN_LDAP_SDK */
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 static LDAP_REBIND_PROC ldap_sasl_rebind;
 
 static int
@@ -333,6 +337,7 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
     size_t max_attr = 0;
     char *filter = NULL;
     char *search_exp = NULL;
+    size_t se_len = 0;
     int rc = 0, retval = 0;
     int ldepth;
     char *ldap_filter_esc = NULL;
@@ -351,8 +356,9 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
 
     ldap_filter_esc = escape_filter(ldap_group);
 
-    search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
-    snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
+    se_len = strlen(filter) + strlen(ldap_filter_esc) + 1;
+    search_exp = (char *) xmalloc(se_len);
+    snprintf(search_exp, se_len, filter, ldap_filter_esc);
 
     xfree(ldap_filter_esc);
 
@@ -369,7 +375,6 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
 
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
-        ldap_unbind_s(ld);
         return 0;
     }
     debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
@@ -449,7 +454,7 @@ int
 ldap_set_defaults(LDAP * ld)
 {
     int val, rc = 0;
-#ifdef LDAP_OPT_NETWORK_TIMEOUT
+#if LDAP_OPT_NETWORK_TIMEOUT
     struct timeval tv;
 #endif
     val = LDAP_VERSION3;
@@ -463,7 +468,7 @@ ldap_set_defaults(LDAP * ld)
         debug((char *) "%s| %s: DEBUG: Error while setting referrals off: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         return rc;
     }
-#ifdef LDAP_OPT_NETWORK_TIMEOUT
+#if LDAP_OPT_NETWORK_TIMEOUT
     tv.tv_sec = CONNECT_TIMEOUT;
     tv.tv_usec = 0;
     rc = ldap_set_option(ld, LDAP_OPT_NETWORK_TIMEOUT, &tv);
@@ -478,16 +483,16 @@ ldap_set_defaults(LDAP * ld)
 int
 ldap_set_ssl_defaults(struct main_args *margs)
 {
-#if defined(HAVE_OPENLDAP) || defined(HAVE_LDAPSSL_CLIENT_INIT)
+#if HAVE_OPENLDAP || HAVE_LDAPSSL_CLIENT_INIT
     int rc = 0;
 #endif
-#ifdef HAVE_OPENLDAP
+#if HAVE_OPENLDAP
     int val;
-#elif defined(HAVE_LDAPSSL_CLIENT_INIT)
+#elif HAVE_LDAPSSL_CLIENT_INIT
     char *ssl_certdbpath = NULL;
 #endif
 
-#ifdef HAVE_OPENLDAP
+#if HAVE_OPENLDAP
     if (!margs->rc_allow) {
         char *ssl_cacertfile = NULL;
         int free_path;
@@ -522,7 +527,7 @@ ldap_set_ssl_defaults(struct main_args *margs)
             return rc;
         }
     }
-#elif defined(HAVE_LDAPSSL_CLIENT_INIT)
+#elif HAVE_LDAPSSL_CLIENT_INIT
     /*
      *  Solaris SSL ldap calls require path to certificate database
      */
@@ -556,32 +561,26 @@ size_t
 get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
 {
 
-    LDAPMessage *msg;
-    char **attr_value = NULL;
+    char **attr_value = *ret_value;
     size_t max_attr = 0;
 
-    attr_value = *ret_value;
     /*
      * loop over attributes
      */
     debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n", LogTime(), PROGRAM, attribute);
-    for (msg = ldap_first_entry(ld, res); msg; msg = ldap_next_entry(ld, msg)) {
-
-        BerElement *b;
-        char *attr;
+    for (LDAPMessage *msg = ldap_first_entry(ld, res); msg; msg = ldap_next_entry(ld, msg)) {
 
         switch (ldap_msgtype(msg)) {
 
-        case LDAP_RES_SEARCH_ENTRY:
-
-            for (attr = ldap_first_attribute(ld, msg, &b); attr;
+        case LDAP_RES_SEARCH_ENTRY: {
+            BerElement *b = NULL;
+            for (char *attr = ldap_first_attribute(ld, msg, &b); attr;
                     attr = ldap_next_attribute(ld, msg, b)) {
                 if (strcasecmp(attr, attribute) == 0) {
                     struct berval **values;
-                    int il;
 
                     if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
-                        for (il = 0; values[il] != NULL; ++il) {
+                        for (int il = 0; values[il] != NULL; ++il) {
 
                             attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
                             if (!attr_value)
@@ -598,7 +597,73 @@ get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_
                 ldap_memfree(attr);
             }
             ber_free(b, 0);
+        }
+        break;
+        case LDAP_RES_SEARCH_REFERENCE:
+            debug((char *) "%s| %s: DEBUG: Received a search reference message\n", LogTime(), PROGRAM);
+            break;
+        case LDAP_RES_SEARCH_RESULT:
+            debug((char *) "%s| %s: DEBUG: Received a search result message\n", LogTime(), PROGRAM);
+            break;
+        default:
             break;
+        }
+    }
+
+    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
+
+    *ret_value = attr_value;
+    return max_attr;
+}
+
+size_t
+get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value, int **ret_len)
+{
+
+    char **attr_value = *ret_value;
+    int *attr_len = *ret_len;
+    size_t max_attr = 0;
+
+    /*
+     * loop over attributes
+     */
+    debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n", LogTime(), PROGRAM, attribute);
+    for (  LDAPMessage *msg = ldap_first_entry(ld, res); msg; msg = ldap_next_entry(ld, msg)) {
+
+        switch (ldap_msgtype(msg)) {
+
+        case LDAP_RES_SEARCH_ENTRY: {
+            BerElement *b = NULL;
+            for (char *attr = ldap_first_attribute(ld, msg, &b); attr;
+                    attr = ldap_next_attribute(ld, msg, b)) {
+                if (strcasecmp(attr, attribute) == 0) {
+                    struct berval **values;
+
+                    if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
+                        for (int il = 0; values[il] != NULL; ++il) {
+
+                            attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
+                            if (!attr_value)
+                                break;
+
+                            attr_len = (int *) xrealloc(attr_len, (max_attr + 1) * sizeof(int));
+                            if (!attr_len)
+                                break;
+
+                            attr_value[max_attr] = (char *) xmalloc(values[il]->bv_len + 1);
+                            memcpy(attr_value[max_attr], values[il]->bv_val, values[il]->bv_len);
+                            attr_value[max_attr][values[il]->bv_len] = 0;
+                            attr_len[max_attr]=values[il]->bv_len;
+                            max_attr++;
+                        }
+                    }
+                    ber_bvecfree(values);
+                }
+                ldap_memfree(attr);
+            }
+            ber_free(b, 0);
+        }
+        break;
         case LDAP_RES_SEARCH_REFERENCE:
             debug((char *) "%s| %s: DEBUG: Received a search reference message\n", LogTime(), PROGRAM);
             break;
@@ -613,6 +678,7 @@ get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_
     debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
 
     *ret_value = attr_value;
+    *ret_len = attr_len;
     return max_attr;
 }
 
@@ -623,7 +689,7 @@ LDAP *
 tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 {
     LDAP *ld;
-#ifdef HAVE_OPENLDAP
+#if HAVE_OPENLDAP
     LDAPURLDesc *url = NULL;
     char *ldapuri = NULL;
 #endif
@@ -633,25 +699,25 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
      * Use ldap open here to check if TCP connection is possible. If possible use it.
      * (Not sure if this is the best way)
      */
-#ifdef HAVE_OPENLDAP
+#if HAVE_OPENLDAP
     url = (LDAPURLDesc *) xmalloc(sizeof(*url));
     memset(url, 0, sizeof(*url));
-#ifdef HAVE_LDAP_URL_LUD_SCHEME
+#if HAVE_LDAP_URL_LUD_SCHEME
     if (ssl)
         url->lud_scheme = xstrdup("ldaps");
     else
         url->lud_scheme = xstrdup("ldap");
 #endif
     url->lud_host = xstrdup(host);
     url->lud_port = port;
-#ifdef HAVE_LDAP_SCOPE_DEFAULT
+#if HAVE_LDAP_SCOPE_DEFAULT
     url->lud_scope = LDAP_SCOPE_DEFAULT;
 #else
     url->lud_scope = LDAP_SCOPE_SUBTREE;
 #endif
-#ifdef HAVE_LDAP_URL_DESC2STR
+#if HAVE_LDAP_URL_DESC2STR
     ldapuri = ldap_url_desc2str(url);
-#elif defined(HAVE_LDAP_URL_PARSE)
+#elif HAVE_LDAP_URL_PARSE
     rc = ldap_url_parse(ldapuri, &url);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
@@ -693,7 +759,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             ld = NULL;
             return NULL;
         }
-#ifdef HAVE_OPENLDAP
+#if HAVE_OPENLDAP
         /*
          *  Use tls if possible
          */
@@ -704,19 +770,19 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             ld = NULL;
             url = (LDAPURLDesc *) xmalloc(sizeof(*url));
             memset(url, 0, sizeof(*url));
-#ifdef HAVE_LDAP_URL_LUD_SCHEME
+#if HAVE_LDAP_URL_LUD_SCHEME
             url->lud_scheme = xstrdup("ldaps");
 #endif
             url->lud_host = xstrdup(host);
             url->lud_port = port;
-#ifdef HAVE_LDAP_SCOPE_DEFAULT
+#if HAVE_LDAP_SCOPE_DEFAULT
             url->lud_scope = LDAP_SCOPE_DEFAULT;
 #else
             url->lud_scope = LDAP_SCOPE_SUBTREE;
 #endif
-#ifdef HAVE_LDAP_URL_DESC2STR
+#if HAVE_LDAP_URL_DESC2STR
             ldapuri = ldap_url_desc2str(url);
-#elif defined(HAVE_LDAP_URL_PARSE)
+#elif HAVE_LDAP_URL_PARSE
             rc = ldap_url_parse(ldapuri, &url);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
@@ -744,7 +810,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
                 return NULL;
             }
         }
-#elif defined(HAVE_LDAPSSL_CLIENT_INIT)
+#elif HAVE_LDAPSSL_CLIENT_INIT
         ld = ldapssl_init(host, port, 1);
         if (!ld) {
             error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
@@ -774,13 +840,14 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 {
     LDAP *ld = NULL;
     LDAPMessage *res;
-#ifndef HAVE_SUN_LDAP_SDK
+#if !HAVE_SUN_LDAP_SDK
     int ldap_debug = 0;
 #endif
     struct ldap_creds *lcreds = NULL;
     char *bindp = NULL;
     char *filter = NULL;
     char *search_exp;
+    size_t se_len = 0;
     struct timeval searchtime;
     int rc = 0, kc = 1;
     int retval;
@@ -798,7 +865,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     if (domain) {
         debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n", LogTime(), PROGRAM);
 
-#ifdef HAVE_KRB5
+#if HAVE_KRB5
         kc = krb5_create_cache(domain);
         if (kc) {
             error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
@@ -809,14 +876,14 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 #endif
     }
 
-    if (kc && (!margs->lurl || !margs->luser | !margs->lpass)) {
+    if (kc && (!margs->lurl || !margs->luser || !margs->lpass)) {
         /*
          * If Kerberos fails and no url given exit here
          */
         retval = 0;
         goto cleanup;
     }
-#ifndef HAVE_SUN_LDAP_SDK
+#if !HAVE_SUN_LDAP_SDK
     /*
      * Initialise ldap
      */
@@ -850,7 +917,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
              * ldap bind with SASL/GSSAPI authentication (only possible if a domain was part of the username)
              */
 
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
             debug((char *) "%s| %s: DEBUG: Bind to ldap server with SASL/GSSAPI\n", LogTime(), PROGRAM);
 
             rc = tool_sasl_bind(ld, bindp, margs->ssl);
@@ -860,7 +927,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 ld = NULL;
                 continue;
             }
-            lcreds = (ldap_creds *) xmalloc(sizeof(struct ldap_creds));
+            lcreds = (struct ldap_creds *) xmalloc(sizeof(struct ldap_creds));
             lcreds->dn = NULL;
             lcreds->pw = margs->ssl ? xstrdup(margs->ssl) : NULL;
             ldap_set_rebind_proc(ld, ldap_sasl_rebind, (char *) lcreds);
@@ -925,7 +992,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 ld = NULL;
                 continue;
             }
-            lcreds = (ldap_creds *) xmalloc(sizeof(struct ldap_creds));
+            lcreds = (struct ldap_creds *) xmalloc(sizeof(struct ldap_creds));
             lcreds->dn = xstrdup(margs->luser);
             lcreds->pw = xstrdup(margs->lpass);
             ldap_set_rebind_proc(ld, ldap_simple_rebind, (char *) lcreds);
@@ -968,8 +1035,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
     ldap_filter_esc = escape_filter(user);
 
-    search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
-    snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
+    se_len = strlen(filter) + strlen(ldap_filter_esc) + 1;
+    search_exp = (char *) xmalloc(se_len);
+    snprintf(search_exp, se_len, filter, ldap_filter_esc);
 
     xfree(ldap_filter_esc);
 
@@ -1075,17 +1143,21 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         retval = 0;
     }
 
-    if (!margs->AD && retval == 0) {
+    if (retval == 0) {
         /*
          * Check for primary Group membership
          */
         debug((char *) "%s| %s: DEBUG: Search for primary group membership: \"%s\"\n", LogTime(), PROGRAM, group);
-        filter = (char *) FILTER_UID;
+        if (margs->AD)
+            filter = (char *) FILTER_AD;
+        else
+            filter = (char *) FILTER_UID;
 
         ldap_filter_esc = escape_filter(user);
 
-        search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
-        snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
+        se_len = strlen(filter) + strlen(ldap_filter_esc) + 1;
+        search_exp = (char *) xmalloc(se_len);
+        snprintf(search_exp, se_len, filter, ldap_filter_esc);
 
         xfree(ldap_filter_esc);
 
@@ -1097,43 +1169,156 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
         debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
-        max_attr = get_attributes(ld, res, ATTRIBUTE_GID, &attr_value);
+        max_attr = 0;
+        if (!rc) {
+            if (margs->AD)
+                max_attr = get_attributes(ld, res, ATTRIBUTE_GID_AD, &attr_value);
+            else
+                max_attr = get_attributes(ld, res, ATTRIBUTE_GID, &attr_value);
+        }
 
         if (max_attr == 1) {
             char **attr_value_2 = NULL;
             size_t max_attr_2 = 0;
 
-            ldap_msgfree(res);
-            filter = (char *) FILTER_GID;
+            if (margs->AD) {
+                char **attr_value_3 = NULL;
+                int *attr_len_3 = NULL;
+                size_t max_attr_3 = 0;
+                uint32_t gid=atoi(attr_value[0]);
+
+                /* Get objectsid and search for group
+                 * with objectsid = domain(objectsid) + primarygroupid  */
+                debug((char *) "%s| %s: DEBUG: Got primaryGroupID %u\n", LogTime(), PROGRAM, gid);
+                max_attr_3 = get_bin_attributes(ld, res, ATTRIBUTE_SID, &attr_value_3, &attr_len_3);
+                ldap_msgfree(res);
+                if (max_attr_3 == 1) {
+                    int len=attr_len_3[0];
+                    if (len < 4) {
+                        debug((char *) "%s| %s: ERROR: Length %d is too short for objectSID\n", LogTime(), PROGRAM, len);
+                        rc = 1;
+                    } else {
+                        char *se=NULL;
+                        attr_value_3[0][len-1]=((gid>>24) & 0xff);
+                        attr_value_3[0][len-2]=((gid>>16) & 0xff);
+                        attr_value_3[0][len-3]=((gid>>8) & 0xff);
+                        attr_value_3[0][len-4]=((gid>>0) & 0xff);
+
+#define FILTER_SID_1 "(objectSID="
+#define FILTER_SID_2 ")"
+
+                        se_len = strlen(FILTER_SID_1) + len*3 + strlen(FILTER_SID_2) + 1;
+                        search_exp = (char *) xmalloc(se_len);
+                        snprintf(search_exp, se_len, "%s", FILTER_SID_1 );
+
+                        for (int j=0; j<len; j++) {
+                            se=strdup(search_exp);
+                            snprintf(search_exp, se_len, "%s\\%02x", se, attr_value_3[0][j] & 0xFF);
+                            xfree(se);
+                        }
+                        se=strdup(search_exp);
+                        snprintf(search_exp, se_len, "%s%s", se, FILTER_SID_2 );
+                        xfree(se);
 
-            ldap_filter_esc = escape_filter(attr_value[0]);
+                        debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
+                        rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
+                                               search_exp, NULL, 0,
+                                               NULL, NULL, &searchtime, 0, &res);
+                        xfree(search_exp);
 
-            search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
-            snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
+                        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
-            xfree(ldap_filter_esc);
+                    }
+                } else {
+                    rc = 1;
+                }
+                if (attr_value_3) {
+                    size_t j;
+                    for (j = 0; j < max_attr_3; ++j) {
+                        xfree(attr_value_3[j]);
+                    }
+                    safe_free(attr_value_3);
+                }
+                if (attr_len_3) {
+                    xfree(attr_len_3);
+                }
+            } else {
+                ldap_msgfree(res);
+                filter = (char *) FILTER_GID;
+
+                ldap_filter_esc = escape_filter(attr_value[0]);
+
+                se_len = strlen(filter) + strlen(ldap_filter_esc) + 1;
+                search_exp = (char *) xmalloc(se_len);
+                snprintf(search_exp, se_len, filter, ldap_filter_esc);
 
-            debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
-            rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
-                                   search_exp, NULL, 0,
-                                   NULL, NULL, &searchtime, 0, &res);
-            xfree(search_exp);
+                xfree(ldap_filter_esc);
 
-            max_attr_2 = get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
+                debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
+                rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
+                                       search_exp, NULL, 0,
+                                       NULL, NULL, &searchtime, 0, &res);
+                xfree(search_exp);
+            }
+
+            if (!rc) {
+                if (margs->AD)
+                    max_attr_2 = get_attributes(ld, res, ATTRIBUTE_DN, &attr_value_2);
+                else
+                    max_attr_2 = get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
+                ldap_msgfree(res);
+            } else {
+                ldap_msgfree(res);
+            }
             /*
              * Compare group names
              */
             retval = 0;
             if (max_attr_2 == 1) {
                 /* Compare first CN= value assuming it is the same as the group name itself */
                 char *av = attr_value_2[0];
+                if (!strncasecmp("CN=", av, 3)) {
+                    char *avp = NULL;
+                    av += 3;
+                    if ((avp = strchr(av, ','))) {
+                        *avp = '\0';
+                    }
+                }
                 if (!strcasecmp(group, av)) {
                     retval = 1;
                     debug((char *) "%s| %s: DEBUG: \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, av, group);
                 } else
                     debug((char *) "%s| %s: DEBUG: \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, av, group);
 
             }
+            /*
+             * Do recursive group search for AD only since posixgroups can not contain other groups
+             */
+            if (!retval && margs->AD) {
+                if (debug_enabled && max_attr_2 > 0) {
+                    debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
+                }
+                for (size_t j = 0; j < max_attr_2; ++j) {
+                    char *av = NULL;
+
+                    av = attr_value_2[j];
+                    if (search_group_tree(margs, ld, bindp, av, group, 1)) {
+                        retval = 1;
+                        if (!strncasecmp("CN=", av, 3)) {
+                            char *avp = NULL;
+                            av += 3;
+                            if ((avp = strchr(av, ','))) {
+                                *avp = '\0';
+                            }
+                        }
+                        if (debug_enabled) {
+                            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                        } else {
+                            break;
+                        }
+                    }
+                }
+            }
             /*
              * Cleanup
              */
@@ -1144,7 +1329,6 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 }
                 safe_free(attr_value_2);
             }
-            ldap_msgfree(res);
 
             debug((char *) "%s| %s: DEBUG: Users primary group %s %s\n", LogTime(), PROGRAM, retval ? "matches" : "does not match", group);
 
@@ -1169,7 +1353,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     }
     debug((char *) "%s| %s: DEBUG: Unbind ldap server\n", LogTime(), PROGRAM);
 cleanup:
-#ifdef HAVE_KRB5
+#if HAVE_KRB5
     if (domain)
         krb5_cleanup();
 #endif
@@ -24,7 +24,7 @@
 
 #include "squid.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 #include <ctime>
@@ -25,7 +25,7 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 struct lsstruct *init_ls(void);
@@ -25,7 +25,7 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 
@@ -25,7 +25,7 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 
@@ -25,20 +25,20 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 #include <cerrno>
-#ifdef HAVE_NETDB_H
+#if HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#ifdef HAVE_NETINET_IN_H
+#if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#ifdef HAVE_RESOLV_H
+#if HAVE_RESOLV_H
 #include <resolv.h>
 #endif
-#ifdef HAVE_ARPA_NAMESER_H
+#if HAVE_ARPA_NAMESER_H
 #include <arpa/nameser.h>
 #endif
 
@@ -25,15 +25,15 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 
-#ifdef HAVE_SASL_H
+#if HAVE_SASL_H
 #include <sasl.h>
-#elif defined(HAVE_SASL_SASL_H)
+#elif HAVE_SASL_SASL_H
 #include <sasl/sasl.h>
-#elif defined(HAVE_SASL_DARWIN)
+#elif HAVE_SASL_DARWIN
 typedef struct sasl_interact {
     unsigned long id;		/* same as client/user callback ID */
     const char *challenge;	/* presented to user (e.g. OTP challenge) */
@@ -52,7 +52,7 @@ typedef struct sasl_interact {
 #define SASL_CB_LIST_END   0	/* end of list */
 #endif
 
-#if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
+#if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 void *lutil_sasl_defaults(
     LDAP * ld,
     char *mech,
@@ -216,7 +216,7 @@ tool_sasl_bind(LDAP * ld, char *binddn, char *ssl)
     /*
      * Avoid SASL messages
      */
-#ifdef HAVE_SUN_LDAP_SDK
+#if HAVE_SUN_LDAP_SDK
     unsigned sasl_flags = LDAP_SASL_INTERACTIVE;
 #else
     unsigned sasl_flags = LDAP_SASL_QUIET;
@@ -58,13 +58,25 @@ extern "C" {
 #endif
 #endif /* HAVE_KRB5_H */
 
+#if USE_HEIMDAL_KRB5
+#if HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#elif HAVE_GSSAPI_H
+#include <gssapi.h>
+#endif
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
+#include <gssapi/gssapi_krb5.h>
+#endif
+#elif USE_GNUGSS
+#if HAVE_GSS_H
+#include <gss.h>
+#endif
+#else
 #if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
 #elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif
-
-#if !HAVE_HEIMDAL_KERBEROS
 #if HAVE_GSSAPI_GSSAPI_KRB5_H
 #include <gssapi/gssapi_krb5.h>
 #endif
@@ -74,10 +86,6 @@ extern "C" {
 #if HAVE_GSSAPI_GSSAPI_EXT_H
 #include <gssapi/gssapi_ext.h>
 #endif
-#else
-#if HAVE_GSSAPI_GSSAPI_KRB5_H
-#include <gssapi/gssapi_krb5.h>
-#endif
 #endif
 
 #ifndef gss_nt_service_name
@@ -119,7 +127,7 @@ int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
 
 char *gethost_name(void);
 
-#if (defined(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT) || defined(HAVE_GSS_MAP_NAME_TO_ANY)) && HAVE_KRB5_PAC
+#if (HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT || HAVE_GSS_MAP_NAME_TO_ANY) && HAVE_KRB5_PAC
 #define HAVE_PAC_SUPPORT 1
 #define MAX_PAC_GROUP_SIZE 200*60
 typedef struct {
@@ -149,7 +149,7 @@ main(int argc, char *const argv[])
     krb5_context context = NULL;
     krb5_error_code ret;
     krb5_pac pac;
-#if HAVE_HEIMDAL_KERBEROS
+#if USE_HEIMDAL_KRB5
     gss_buffer_desc data_set = GSS_C_EMPTY_BUFFER;
 #else
     gss_buffer_desc type_id = GSS_C_EMPTY_BUFFER;
@@ -396,7 +396,7 @@ main(int argc, char *const argv[])
 #if HAVE_PAC_SUPPORT
             ret = krb5_init_context(&context);
             if (!check_k5_err(context, "krb5_init_context", ret)) {
-#if HAVE_HEIMDAL_KERBEROS
+#if USE_HEIMDAL_KRB5
 #define ADWIN2KPAC 128
                 major_status = gsskrb5_extract_authz_data_from_sec_context(&minor_status,
                                gss_context, ADWIN2KPAC, &data_set);
@@ -42,13 +42,22 @@
 #include "base64.h"
 #include "util.h"
 
+#if USE_HEIMDAL_KRB5
+#if HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#elif HAVE_GSSAPI_H
+#include <gssapi.h>
+#endif
+#elif USE_GNUGSS
+#if HAVE_GSS_H
+#include <gss.h>
+#endif
+#else
 #if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
 #elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif
-
-#if !HAVE_HEIMDAL_KERBEROS
 #if HAVE_GSSAPI_GSSAPI_KRB5_H
 #include <gssapi/gssapi_krb5.h>
 #endif
@@ -355,7 +355,7 @@ get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac)
     char **Rids=NULL;
     int l=0;
 
-    ad_data = (krb5_data *)xmalloc(sizeof(krb5_data));
+    ad_data = (krb5_data *)xcalloc(1,sizeof(krb5_data));
 
 #define KERB_LOGON_INFO 1
     ret = krb5_pac_get_buffer(context, pac, KERB_LOGON_INFO, ad_data);
@@ -1,2 +1,3 @@
-# FIXME: use other kerberos library checks from main configure.ac
-AC_CHECK_HEADERS([gssapi/gssapi.h gssapi.h kerberosV/gssapi.h],[BUILD_HELPER="kerberos"])
+if test "x$with_krb5" == "xyes"; then
+  BUILD_HELPER="kerberos"
+fi
@@ -1,30 +1,9 @@
 /*
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_LIST_H
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _MEM_POOL_H_
 #define _MEM_POOL_H_
 
@@ -42,9 +50,7 @@
 #endif
 
 /// \ingroup MemPoolsAPI
-#define MB ((size_t)1024*1024)
-/// \ingroup MemPoolsAPI
-#define toMB(size) ( ((double) size) / MB )
+#define toMB(size) ( ((double) size) / ((double)(1024*1024)) )
 /// \ingroup MemPoolsAPI
 #define toKB(size) ( (size + 1024 - 1) / 1024 )
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _MEM_POOL_CHUNKED_H_
 #define _MEM_POOL_CHUNKED_H_
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _MEM_POOL_MALLOC_H_
 #define _MEM_POOL_MALLOC_H_
 
@@ -1,31 +1,9 @@
 /*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_RANGE_H
@@ -1,33 +1,11 @@
 /*
- * AUTHOR: Harvest Derived
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
+
 #ifndef SQUID_NEW_H
 #define SQUID_NEW_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_ASN1_H
 #define SQUID_SNMP_ASN1_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_BASE64_H
 #define _SQUID_BASE64_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_CACHE_SNMP_H
 #define SQUID_CACHE_SNMP_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_CHARSET_H
 #define _SQUID_CHARSET_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_GETFULLHOSTNAME_H
 #define _SQUID_GETFULLHOSTNAME_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_HASH_H
 #define SQUID_HASH_H
 
@@ -1,32 +1,13 @@
 /*
- * AUTHOR: John Dilley, Hewlett Packard
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/*
+ * AUTHOR: John Dilley, Hewlett Packard
  */
 
 /****************************************************************************
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_HTML_QUOTE_H
 #define _SQUID_HTML_QUOTE_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_LEAKCHECK_H
 #define _SQUID_LEAKCHECK_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_MD5_H
 #define SQUID_MD5_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _MEM_METER_H_
 #define _MEM_METER_H_
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_PARSE_H
 #define SQUID_PARSE_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_RADIX_H
 #define	SQUID_RADIX_H
 
@@ -1,33 +1,11 @@
 /*
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
+
 #ifndef SQUID_RFC1035_H
 #define SQUID_RFC1035_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_RFC1123_H
 #define _SQUID_RFC1123_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_INCLUDE_RFC1738_H
 #define _SQUID_INCLUDE_RFC1738_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_INCLUDE_RFC1123_H
 #define _SQUID_INCLUDE_RFC1123_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /* The source in this file is derived from the reference implementation
  * in RFC 2617.
  * RFC 2617 is Copyright (C) The Internet Society (1999).  All Rights Reserved.
@@ -12,37 +20,6 @@
  * to prevent squid knowing the users password (idea suggested in RFC 2617).
  */
 
-/*
- * DEBUG:
- * AUTHOR: RFC 2617 & Robert Collins
- *
- * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from the
- *  Internet community.  Development is led by Duane Wessels of the
- *  National Laboratory for Applied Network Research and funded by the
- *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
- *  the Regents of the University of California.  Please see the
- *  COPYRIGHT file for full details.  Squid incorporates software
- *  developed and/or copyrighted by other sources.  Please see the
- *  CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
 #ifndef SQUID_RFC2617_H
 #define SQUID_RFC2617_H
 
@@ -1,36 +1,9 @@
 /*
- * AUTHOR: Amos Jeffries
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This code is copyright (C) 2007 by Treehouse Networks Ltd of
- *  New Zealand. It is published and Lisenced as an extension of
- *  squid under the same conditions as the main squid application.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_RFC2671_H
@@ -1,36 +1,9 @@
 /*
- * AUTHOR: Amos Jeffries, Rafael Martinez Torres
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This code is copyright (C) 2007 by Treehouse Networks Ltd of
- *  New Zealand. It is published and Lisenced as an extension of
- *  squid under the same conditions as the main squid application.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_RFC3596_H
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_INTERNAL_H
 #define SQUID_SNMP_INTERNAL_H
 
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_MIB_H
 #define SQUID_SNMP_MIB_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_H
 #define SQUID_SNMP_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_API_H
 #define SQUID_SNMP_API_H
 
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_API_ERROR_H
 #define SQUID_SNMP_API_ERROR_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_API_UTIL_H
 #define SQUID_SNMP_API_UTIL_H
 
@@ -1,9 +1,14 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_CLIENT_H
 #define SQUID_SNMP_CLIENT_H
 
-/*
- * snmp_client.h
- */
 /***********************************************************
 	Copyright 1988, 1989 by Carnegie Mellon University
 
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_COEXISTANCE_H
 #define SQUID_SNMP_COEXISTANCE_H
 
@@ -39,4 +46,4 @@ extern "C" {
 }
 #endif
 
-#endif				/* SQUID_SNMP_COEXISTANCE_H */
+#endif /* SQUID_SNMP_COEXISTANCE_H */
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_DEBUG_H
 #define SQUID_SNMP_DEBUG_H
 
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_ERROR_H
 #define SQUID_SNMP_ERROR_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_IMPL_H
 #define SQUID_SNMP_IMPL_H
 
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_MSG_H
 #define SQUID_SNMP_MSG_H
 
@@ -1,11 +1,18 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_PDU_H
 #define SQUID_SNMP_PDU_H
 
 /* required for oid typedef */
 #include "asn1.h"
 
 #if HAVE_NETINET_IN_H
-/* required for sockaddr_in definition */
 #include <netinet/in.h>
 #endif
 
@@ -1,4 +1,11 @@
-/* -*- c++ -*- */
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_SESSION_H
 #define SQUID_SNMP_SESSION_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_UTIL_H
 #define SQUID_SNMP_UTIL_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SNMP_VARS_H
 #define SQUID_SNMP_VARS_H
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef SQUID_SPLAY_H
 #define SQUID_SPLAY_H
 
@@ -1,32 +1,9 @@
 /*
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_CONFIG_H
@@ -1,32 +1,13 @@
 /*
- * AUTHOR: Alan Barrett
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/*
+ * AUTHOR: Alan Barrett
  */
 
 #ifndef SQUID_ENDIAN_H
@@ -1,34 +1,16 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  * AUTHOR: Guido Serassio <serassio@squid-cache.org>
  * Based on previous work of Francesco Chemolli, Robert Collins and Andrew Doran
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
  */
+
 #ifndef _LIBSSPWIN32_H_
 #define _LIBSSPWIN32_H_
 
@@ -1,32 +1,9 @@
 /*
- * AUTHOR: Harvest Derived
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_UTIL_H
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _SQUID_UUDECODE_H
 #define _SQUID_UUDECODE_H
 
@@ -1,15 +1,20 @@
 /*
- *  SQUID_VERSION - String for version id of this distribution
- */
-
-/*
- * SQUID_VERSION is now the automake "VERSION" string.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef SQUID_RELEASE_TIME
 #define SQUID_RELEASE_TIME squid_curtime
 #endif
 
+/*
+ * String for version id of this distribution
+ * is now the automake "VERSION" string.
+ */
+
 #ifndef APP_SHORTNAME
 #define APP_SHORTNAME "squid"
 #endif
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 #ifndef _INC_XUSLEEP_H
 #define _INC_XUSLEEP_H
 
@@ -113,8 +113,8 @@ MemPools::idleLimit() const
  * all pools - including those used before main() starts where
  * MemPools::GetInstance().setDefaultPoolChunking() can be called.
  */
-MemPools::MemPools() : pools(NULL), mem_idle_limit(2 * MB),
-        poolCount (0), defaultIsChunked (USE_CHUNKEDMEMPOOLS && !RUNNING_ON_VALGRIND)
+MemPools::MemPools() : pools(NULL), mem_idle_limit(2 << 20 /* 2 MB */),
+        poolCount(0), defaultIsChunked(USE_CHUNKEDMEMPOOLS && !RUNNING_ON_VALGRIND)
 {
     char *cfg = getenv("MEMPOOLS");
     if (cfg)
@@ -1 +0,0 @@
-Robert Collins <rbtcollins@hotmail.com>
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
@@ -1 +0,0 @@
-TODO: Fill this out
@@ -1,229 +0,0 @@
-Copyright 1994, 1995, 1996, 1999, 2000, 2001, 2002 Free Software
-Foundation, Inc.
-
-   This file is free documentation; the Free Software Foundation gives
-unlimited permission to copy, distribute and modify it.
-
-Basic Installation
-==================
-
-   These are generic installation instructions.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, and a
-file `config.log' containing compiler output (useful mainly for
-debugging `configure').
-
-   It can also use an optional file (typically called `config.cache'
-and enabled with `--cache-file=config.cache' or simply `-C') that saves
-the results of its tests to speed up reconfiguring.  (Caching is
-disabled by default to prevent problems with accidental use of stale
-cache files.)
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If you are using the cache, and at
-some point `config.cache' contains results you don't want to keep, you
-may remove or edit it.
-
-   The file `configure.ac' is used to create
-`configure' by a program called `autoconf'.  You only need
-`configure.ac' if you want to change it or regenerate `configure' using
-a newer version of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.  If you're
-     using `csh' on an old version of System V, you might need to type
-     `sh ./configure' instead to prevent `csh' from trying to execute
-     `configure' itself.
-
-     Running `configure' takes awhile.  While running, it prints some
-     messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Optionally, type `make check' to run any self-tests that come with
-     the package.
-
-  4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  To also remove the
-     files that `configure' created (so you can compile the package for
-     a different kind of computer), type `make distclean'.  There is
-     also a `make maintainer-clean' target, but that is intended mainly
-     for the package's developers.  If you use it, you may have to get
-     all sorts of other programs in order to regenerate files that came
-     with the distribution.
-
-Compilers and Options
-=====================
-
-   Some systems require unusual options for compilation or linking that
-the `configure' script does not know about.  Run `./configure --help'
-for details on some of the pertinent environment variables.
-
-   You can give `configure' initial values for configuration parameters
-by setting variables in the command line or in the environment.  Here
-is an example:
-
-     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
-
-   *Note Defining Variables::, for more details.
-
-Compiling For Multiple Architectures
-====================================
-
-   You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you must use a version of `make' that
-supports the `VPATH' variable, such as GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   If you have to use a `make' that does not support the `VPATH'
-variable, you have to compile the package for one architecture at a
-time in the source code directory.  After you have installed the
-package for one architecture, use `make distclean' before reconfiguring
-for another architecture.
-
-Installation Names
-==================
-
-   By default, `make install' will install the package's files in
-`/usr/local/bin', `/usr/local/man', etc.  You can specify an
-installation prefix other than `/usr/local' by giving `configure' the
-option `--prefix=PATH'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-give `configure' the option `--exec-prefix=PATH', the package will use
-PATH as the prefix for installing programs and libraries.
-Documentation and other data files will still use the regular prefix.
-
-   In addition, if you use an unusual directory layout you can give
-options like `--bindir=PATH' to specify different values for particular
-kinds of files.  Run `configure --help' for a list of the directories
-you can set and what kinds of files go in them.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-   Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-   There may be some features `configure' cannot figure out
-automatically, but needs to determine by the type of machine the package
-will run on.  Usually, assuming the package is built to be run on the
-_same_ architectures, `configure' can figure that out, but if it prints
-a message saying it cannot guess the machine type, give it the
-`--build=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name which has the form:
-
-     CPU-COMPANY-SYSTEM
-
-where SYSTEM can have one of these forms:
-
-     OS KERNEL-OS
-
-   See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the machine type.
-
-   If you are _building_ compiler tools for cross-compiling, you should
-use the `--target=TYPE' option to select the type of system they will
-produce code for.
-
-   If you want to _use_ a cross compiler, that generates code for a
-platform different from the build platform, you should specify the
-"host" platform (i.e., that on which the generated programs will
-eventually be run) with `--host=TYPE'.
-
-Sharing Defaults
-================
-
-   If you want to set default values for `configure' scripts to share,
-you can create a site shell script called `config.site' that gives
-default values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Defining Variables
-==================
-
-   Variables not defined in a site shell script can be set in the
-environment passed to `configure'.  However, some packages may run
-configure again during the build, and the customized values of these
-variables may be lost.  In order to avoid this problem, you should set
-them in the `configure' command line, using `VAR=value'.  For example:
-
-     ./configure CC=/usr/local2/bin/gcc
-
-will cause the specified gcc to be used as the C compiler (unless it is
-overridden in the site shell script).
-
-`configure' Invocation
-======================
-
-   `configure' recognizes the following options to control how it
-operates.
-
-`--help'
-`-h'
-     Print a summary of the options to `configure', and exit.
-
-`--version'
-`-V'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`--cache-file=FILE'
-     Enable the cache: use and save the results of the tests in FILE,
-     traditionally `config.cache'.  FILE defaults to `/dev/null' to
-     disable caching.
-
-`--config-cache'
-`-C'
-     Alias for `--cache-file=config.cache'.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.  To
-     suppress all normal output, redirect it to `/dev/null' (any error
-     messages will still be shown).
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`configure' also accepts some other, not widely useful, options.  Run
-`configure --help' for more details.
-
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
@@ -1,20 +1,9 @@
 /*
- * Copyright (c) 2002,2003 Robert Collins <rbtcollins@hotmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
@@ -1,20 +1,9 @@
 /*
- * Copyright (c) 2002,2003 Robert Collins <rbtcollins@hotmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef   LIBTRIE_SQUID_H
@@ -1,20 +1,9 @@
 /*
- * Copyright (c) 2003 Robert Collins <rbtcollins@hotmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef   LIBTRIE_TRIECHARTRANSFORM_H
@@ -1,20 +1,9 @@
 /*
- * Copyright (c) 2002,2003 Robert Collins <rbtcollins@hotmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
@@ -1,20 +1,9 @@
 /*
- * Copyright (c) 2002,2003 Robert Collins <rbtcollins@hotmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #ifndef   LIBTRIE_TRIENODE_H
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 include $(top_srcdir)/src/Common.am
 
 AM_CPPFLAGS += -I$(top_srcdir)/include
@@ -1,20 +1,9 @@
 /*
- * Copyright (c) 2002,2003 Robert Collins <rbtcollins@hotmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
  *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
 #include "squid.h"
@@ -10,6 +10,7 @@ typedef enum {
     XPROF_HttpHeader_getCc,
     XPROF_HttpMsg_httpMsgParseStep,
     XPROF_HttpParserParseReqLine,
+    XPROF_HttpServer_parseOneRequest,
     XPROF_HttpStateData_processReplyBody,
     XPROF_HttpStateData_processReplyHeader,
     XPROF_HttpStateData_readReply,
@@ -60,7 +61,6 @@ typedef enum {
     XPROF_httpStart,
     XPROF_malloc,
     XPROF_mem_hdr_write,
-    XPROF_parseHttpRequest,
     XPROF_read,
     XPROF_realloc,
     XPROF_recv,
@@ -21,7 +21,6 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 
-#define SQUID_NO_STRING_BUFFER_PROTECT 1
 #include "squid.h"
 
 #if HAVE_UNISTD_H
@@ -1,10 +1,8 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
+#include "testRFC1035.h"
 
 #include <cassert>
 
-#include "testRFC1035.h"
-
 /* Being a C library code it is best bodily included and tested with C++ type-safe techniques. */
 #include "lib/rfc1035.c"
 #include "lib/rfc2671.c"
@@ -1,10 +1,8 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
+#include "testRFC1738.h"
 
 #include <cassert>
 
-#include "testRFC1738.h"
-
 /* Being a C library code it is best bodily included and tested with C++ type-safe techniques. */
 #include "lib/rfc1738.c"
 
@@ -0,0 +1,337 @@
+#!/usr/bin/perl -w
+
+# Adds or adjusts the source file boilerplate, such as a Copyright statement.
+# The boilerplate is meant to remain constant from one source file to another.
+#
+# The old boilerplate is assumed to be the first /* comment */ in a source 
+# file, before the first #include statement other than #include "squid.h".
+# Common old boilerplates are removed, with copyright-related claims contained
+# in them logged on stdout for recording in CONTRIBUTORS or some such.
+# Copyright and (C) (but not AUTHOR-like) lines are left in sources except
+# when we have a permission to move them to CONTRIBUTORS.
+#
+# The new boilerplate comment is placed at the very beginning of the file,
+# followed by old copyright lines, "inspired by" lines, and DEBUG section
+# comments (if any were found in the old boilerplate).
+#
+# The script tries hard to detect files with unusual old boilerplates. When
+# detected, the script warns about the problem and leaves the file "as is".
+
+use strict;
+use warnings;
+
+die("usage: $0 <boilerplate-file> <source-file> ...\n") unless @ARGV >= 2;
+my ($BoilerName, @FileNames) = @ARGV;
+
+my $CorrectBoiler = `cat $BoilerName` or
+	die("cannot load boilerplate from $BoilerName: $!, stopped");
+$CorrectBoiler = &trimL(&trimR($CorrectBoiler)) . "\n\n";
+
+# the first /* comment */
+my $reComment = qr{
+	/\*.*?\*/
+}xs;
+
+# Debugging section inside a boilerplate comment.
+my $reDebug = qr{
+	^[\s*]*(DEBUG:.*?)$
+}mx;
+
+# Same as $reDebug, but does not match empty DEBUG: statements.
+my $reDebugFull = qr{
+	^[\s*]*(DEBUG:[^\S\n]*\S.*?)\s*$
+}mx;
+
+# Copyright-related claims inside a boilerplate comment
+my $reClaims = qr{
+	(
+		(?:
+		 AUTHOR\b(?:.|\n)*?\*[/\s]*$|	# all authors until an "empty" line
+		 ORIGINAL\s+AUTHOR\b|	# or not the latest author
+		 COPYRIGHT\b(?!\sfile)|	# or copyright (except "COPYRIGHT file")
+		 Portions\scopyright|	# or partial copyright
+		 (?<!Squid.is.Copyrighted.)\(C\)\s|	# or (C) (except "Squid is ...")
+		 Based.upon.original.+code.by\s*\n|	# or this common pearl
+		 Modified\sby\s|		# or this
+		 BASED\sON:\s			# or this
+		)		
+		.*?							# and the claim content itself
+	)$
+}xmi;
+
+# removes common claim prefixes to minimize claim noise
+my $reClaimPrefix = qr{
+	(?:ORIGINAL\s)?AUTHOR:?|
+	based\son\s|
+	based\supon\s|
+	Portions\s
+}xi;
+
+# We have persmission to move these frequent claims to CONTRIBUTORS.
+my $reClaimsOkToMove = qr{
+	Robert.Collins|<robertc\@squid-cache.org>|<rbtcollins\@hotmail.com>|
+
+	Duane.Wessels|
+
+	Francesco.Chemolli|<kinkie\@squid-cache.org>|<kinkie\@kame.usr.dsi.unimi.it>|
+
+	Amos.Jeffries|<amosjeffries\@squid-cache.org>|<squid3\@treenet.co.nz>|
+	Treehouse.Networks.Ltd.|
+	GPL.version.2,..C.2007-2013|
+
+	Henrik.Nordstrom|<henrik\@henriknordstrom.net>|
+	MARA.Systems.AB|
+}xi;
+
+# inspirations are not copyright claims but should be preserved
+my $reInspiration = qr/^[\s*]*(inspired by previous work.*?)$/mi;
+
+# The most common GPL text, with some address variations.
+my $strGpl = 
+	"This program is free software; you can redistribute it and/or modify".
+	"([^*]|[*][^/])+". # not a /* comment */ closure
+	"Foundation, Inc., [^\\n]+MA\\s+[-\\d]+, USA\\.";
+my $reGpl = qr{$strGpl}s;
+
+# Two most common Squid (C) statements.
+my $strSqCopyStart1 =
+	"SQUID Web Proxy Cache\\s+http://www.squid-cache.org/";
+my $strSqCopyStart2 =
+	"SQUID Internet Object Cache\\s+http://squid.nlanr.net/Squid/";
+my $strSqCopyEnd =
+	"([^*]|[*][^/])+".
+	"numerous individuals".
+	"([^*]|[*][^/])+".
+	"file for full details.";
+my $reSquidCopy = qr{($strSqCopyStart1|$strSqCopyStart2)$strSqCopyEnd}s;
+
+
+my $FileName; # for Warn()ings
+my %ReportedClaims; # to minimize noise in claims reporting
+$| = 1; # report claims ASAP (but on STDOUT)
+
+# process each file in-place; do not touch files on known failures
+foreach my $fname (@FileNames) {
+
+	$FileName = $fname;
+	my $code = &readFile($fname) or next;
+	my $virginCode = $code;
+
+	&WarnQuiet("Correct boilerplate already present, skipping:", $code), next if
+			$code =~ /\Q$CorrectBoiler\E/s;
+
+	my $boiler;
+
+	if ($code =~ m/$reComment/) {
+		my $beforeComment = $`;
+		my $comment = $&;
+
+		# Is the matched comment a boilerplate?
+		if ($comment !~ m/\n/) {
+			# A single line comment is not a boilerplate.
+		} elsif ($beforeComment =~ m/^\s*\#\s*include\s+(?!"squid.h")/m) {
+			# A comment after include is not a boilerplate,
+			# but we make an exception for #include "squid.h" common in lib/
+		} elsif ($comment =~ m@^/\*\*\s@){
+			# A Doxygen comment is not a boilerplate.
+		} elsif ($comment =~ m/internal declarations|stub file|unit test/i) {
+			# These relatively common comments are not boilerplates.
+		} elsif (&digestable($comment)) {
+			# Something we can safely replace.
+			$boiler = $comment;
+		} else {
+			&Warn("Unrecognized boilerplate, skipping:", $comment);
+			next;
+		}
+	}
+
+	my $extras = ''; # DEBUG section, inspired by ..., etc.
+
+	if (defined $boiler) {
+		my $copyClaims = ''; # formatted Copyright claims extraced from sources
+		my $preserveClaims = 0; # whether to preserve them or not
+
+		if (my @rawClaims = ($boiler =~ m/$reClaims/g)) {
+			my @claims = map { &claimList($_) } @rawClaims;
+			my $count = 0;
+			foreach my $claim (@claims) {
+				$claim =~ s/\n+/ /gs;		# streamline multiline claims
+				$claim =~ s@\*/?@ @g;		# clean comment leftovers
+				$claim =~ s/$reClaimPrefix/ /g; # remove common prefixes
+				# this one is sucked in from the old standard boilerplate
+				$claim =~ s/by the Regents of the University of//;
+				$claim =~ s/\s\s+/ /gs;		# clean excessive whitespace
+				$claim =~ s/^\s+|\s+$//gs;	# remove excessive whitespace
+				next unless length $claim;
+
+				# preserve Copyright claims
+				if ($claim =~ m/Copyright|\(c\)/i) {
+					$copyClaims .= sprintf(" * %s\n", $claim);
+
+					# Ignore certain claims, assuming we have their permission.
+					my $c = $claim;
+					$c =~ s/^\s*(Copyright)?[:\s]*([(c)]+)?\s*([0-9,-]+)?\s*(by)?\s*//i; # prefix
+					$c =~ s/$reClaimsOkToMove/ /g;
+					$c =~ s/[,]//g; # markup leftovers
+
+					# But if one claim is preserved, all must be preserved.
+					$preserveClaims = 1 if $c =~ /\S/;
+warn($c) if $c =~ /\S/;
+				}
+
+				next if exists $ReportedClaims{$claim};
+				print("$fname: INFO: Found new claim(s):\n") unless $count++;
+				print("Claim: $claim\n");
+				$ReportedClaims{$claim} = $fname;
+			}
+		}
+		
+		if ($preserveClaims) {
+			die("Internal error: $copyClaims") unless length($copyClaims);
+			my $prefix = " * Portions of this code are copyrighted and released under GPLv2+ by:";
+			my $suffix = " * Please add new claims to the CONTRIBUTORS file instead.";
+			$extras .= sprintf("/*\n%s\n%s%s\n */\n\n",
+				$prefix, $copyClaims, $suffix);
+		}
+
+		if ($boiler =~ m/$reInspiration/) {
+			$extras .= sprintf("/* %s */\n\n", ucfirst($1));
+		}
+
+		if ($boiler =~ m/$reDebugFull/) {
+			$extras .= "/* $1 */\n\n";
+		}
+
+		$code =~ s/\s*$reComment\s*/\n\n/ or
+			die("internal error: failed to remove expected comment, stopped");
+		&digestable($&) or
+			die("internal error: unsafe comment removal, stopped");
+
+	} else { # no boilerplate found
+		#&Warn("Cannot find old boilerplate, adding new boilerplate.", $code);
+	}
+
+	# Some files have license declarations way down in the code so we may not
+	# find a boilerplate at all or find an "empty" boilerplate preceeding them.
+	my $license =
+		"Copyright|".
+		"This program is free software|".
+		"Permission to use|".
+		"Redistribution and use";
+	if ($code =~ m@/\*.*?($license).*?\*/@is) {
+		# If we replaced what we thought is an old boiler, do not use $` for
+		# context because it is based on modified $code and will often mislead.
+		my $context = defined $boiler ? $& : ($` . $&);
+		&Warn("Suspected boilerplate in an unusual location, skipping:",
+			$context);
+		next;
+	}
+
+	$code = $CorrectBoiler . $extras . &trimL($code);
+	&writeFile($fname, $code) unless $code eq $virginCode;
+	undef $FileName;
+}
+
+exit(0);
+
+sub readFile() {
+	my ($fname) = @_;
+
+	if (!-f $fname) {
+		&Warn("Skipping directory or a special file.");
+		return undef();
+	}
+
+	my $code = '';
+	open(IF, "<$fname") or die("cannot open $fname: $!, stopped");
+	while (<IF>) {
+		$code .= $_;
+	}
+	close(IF);
+
+	&Warn("empty file") unless length $code;
+	return $code;
+}
+
+sub writeFile() {
+	my ($fname, $code) = @_;
+	open(OF, ">$fname") or die("cannot open $fname for writing: $!, stopped");
+
+	print(OF $code) or die("cannot write to $fname: $!, stopped");
+
+	close(OF) or die("cannot finish updating $fname: $!, stopped");
+}
+
+# split multiclaim claims into an array of single claims
+sub claimList() {
+	my $multiClaim = shift;
+
+	$multiClaim =~ s/$reDebug//g; # may pretend to continue AUTHORs list
+	$multiClaim =~ s/$reInspiration//g; # does not affect (C) claims
+
+	# remove \n that is not used to separate two claims
+	$multiClaim =~ s/(Based.upon.original.+code.by\s*)\n/$1 /g;
+
+	return split(/\n/, $multiClaim);
+	# return grep { /\S/ } split($reClaimSplitter, $multiClaim);
+}
+
+# checks whether a comment contains nothing but the stuff we can either
+# safely remove, replace, or move (e.g., DEBUG sections and copyright claims)
+sub digestable() {
+	my $comment = shift;
+
+	# Remove common text to detect an otherwise empty boilerplate.
+	$comment =~ s/$reDebug//;
+	$comment =~ s/$reClaims//g;
+	$comment =~ s/^[\s*]*(Created on.*?)$//mig;
+	$comment =~ s/^[\s*]*(Windows support\s*)$//mig;
+	$comment =~ s/^[\s*]*(History added by .*)$//mig;
+	$comment =~ s/$reGpl//;
+	$comment =~ s/$reSquidCopy//;
+	$comment =~ s/$reInspiration//g;
+	$comment =~ s/\* Stubs for.*?$//m; # e.g., Stubs for calls to stuff defined in...
+	$comment =~ s/\$Id(:.*)?\$//g; # CVS tags
+	$comment =~ s/-{60,}//g; # decorations such as -----------...---------
+	$comment =~ s/\b\w+\.(h|c|cc|cci)\b//; # Next to last step: a file name.
+	$comment =~ s@[\s*/]@@sg; # Last step: whitespace and comment characters.
+	return !length($comment);
+}
+
+# removes all opening whitespace
+sub trimL() {
+	my ($code) = @_;
+	$code =~ s/^\n[\n\s]*//s;
+	return $code;
+}
+
+# removes all trailing whitespace
+sub trimR() {
+	my ($code) = @_;
+	$code =~ s/\n[\n\s]*$//s;
+	return $code;
+}
+
+sub Warn() {
+	my ($msg, $context) = @_;
+
+	if (defined $context) {
+		my $MaxLen = 1000;
+		$context =~ s/$reGpl/... [GPL] .../;
+		$context =~ s/$reSquidCopy/... [Standard Squid "numerous individuals" text] .../;
+		$context = substr($context, 0, $MaxLen);
+		$context = &trimR($context);
+		$context .= "\n\n";
+	} else {
+		$context = '';
+	}
+	$msg = sprintf("%s: WARNING: %s\n%s", $FileName, $msg, $context) if defined $FileName;
+	warn($msg);
+}
+
+sub WarnQuiet() {
+	my ($msg, $context) = @_;
+
+	$msg = sprintf("%s: WARNING: %s\n", $FileName, $msg) if defined $FileName;
+	warn($msg);
+}
@@ -0,0 +1,7 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
@@ -7,7 +7,7 @@
 # by the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
-# The ldap_manager library is distributed in the hope that it will be useful,
+# Distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 # Library General Public License for more details.
@@ -16,7 +16,7 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 #
-# See LICENSE or http://www.gnu.org/licenses/gpl.html for details .
+# See COPYING or http://www.gnu.org/licenses/gpl.html for details.
 #
 
 
@@ -139,7 +139,7 @@ for FILENAME in `ls -1`; do
 
     Makefile.am)
 
-    	perl -i -p -e 's/@([A-Z0-9_]+)@/\$($1)/g' <${FILENAME} >${FILENAME}.styled
+    	perl -p -e 's/@([A-Z0-9_]+)@/\$($1)/g' <${FILENAME} >${FILENAME}.styled
 	mv ${FILENAME}.styled ${FILENAME}
 	;;
 
@@ -39,6 +39,7 @@
 #include "CacheManager.h"
 #include "CachePeer.h"
 #include "client_side.h"
+#include "clients/forward.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "comm/Loops.h"
@@ -47,7 +48,6 @@
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
-#include "ftp.h"
 #include "FwdState.h"
 #include "globals.h"
 #include "gopher.h"
@@ -719,6 +719,10 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, in
     }
 #endif
 
+    // should reach ConnStateData before the dispatched Client job starts
+    CallJobHere1(17, 4, request->clientConnectionManager, ConnStateData,
+                 ConnStateData::notePeerConnection, serverConnection());
+
     dispatch();
 }
 
@@ -813,7 +817,7 @@ FwdState::connectStart()
         debugs(17,7, "pinned peer connection: " << pinned_connection);
         // pinned_connection may become nil after a pconn race
         if (pinned_connection)
-            serverConn = pinned_connection->validatePinnedConnection(request, serverDestinations[0]->getPeer());
+            serverConn = pinned_connection->borrowPinnedConnection(request, serverDestinations[0]->getPeer());
         else
             serverConn = NULL;
         if (Comm::IsConnOpen(serverConn)) {
@@ -995,7 +999,10 @@ FwdState::dispatch()
             break;
 
         case AnyP::PROTO_FTP:
-            ftpStart(this);
+            if (request->flags.ftpNative)
+                Ftp::StartRelay(this);
+            else
+                Ftp::StartGateway(this);
             break;
 
         case AnyP::PROTO_CACHE_OBJECT:
@@ -75,8 +75,10 @@ class HttpHdrCc
     //manipulation for Cache-Control: private header
     bool hasPrivate() const {return isSet(CC_PRIVATE);}
     const String &Private() const {return private_;}
-    void Private(String &v) {
+    void Private(const String &v) {
         setMask(CC_PRIVATE,true);
+        if (!v.size())
+            return;
         // uses append for multi-line headers
         if (private_.size() > 0)
             private_.append(",");
@@ -87,10 +89,12 @@ class HttpHdrCc
     //manipulation for Cache-Control: no-cache header
     bool hasNoCache() const {return isSet(CC_NO_CACHE);}
     const String &noCache() const {return no_cache;}
-    void noCache(String &v) {
+    void noCache(const String &v) {
         setMask(CC_NO_CACHE,true);
+        if (!v.size())
+            return;
         // uses append for multi-line headers
-        if (no_cache.size() > 0)
+        if (no_cache.size() > 0 && v.size() > 0)
             no_cache.append(",");
         no_cache.append(v);
     }
@@ -170,6 +170,11 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] = {
     {"Surrogate-Capability", HDR_SURROGATE_CAPABILITY, ftStr},
     {"Surrogate-Control", HDR_SURROGATE_CONTROL, ftPSc},
     {"Front-End-Https", HDR_FRONT_END_HTTPS, ftStr},
+    {"FTP-Command", HDR_FTP_COMMAND, ftStr},
+    {"FTP-Arguments", HDR_FTP_ARGUMENTS, ftStr},
+    {"FTP-Pre", HDR_FTP_PRE, ftStr},
+    {"FTP-Status", HDR_FTP_STATUS, ftInt},
+    {"FTP-Reason", HDR_FTP_REASON, ftStr},
     {"Other:", HDR_OTHER, ftStr}	/* ':' will not allow matches */
 };
 
@@ -772,23 +777,37 @@ HttpHeader::packInto(Packer * p, bool mask_sensitive_info) const
     HttpHeaderPos pos = HttpHeaderInitPos;
     const HttpHeaderEntry *e;
     assert(p);
-    debugs(55, 7, "packing hdr: (" << this << ")");
+    debugs(55, 7, this << " into " << p <<
+           (mask_sensitive_info ? " while masking" : ""));
     /* pack all entries one by one */
     while ((e = getEntry(&pos))) {
         if (!mask_sensitive_info) {
             e->packInto(p);
             continue;
         }
+
+        bool maskThisEntry = false;
         switch (e->id) {
         case HDR_AUTHORIZATION:
         case HDR_PROXY_AUTHORIZATION:
-            packerAppend(p, e->name.rawBuf(), e->name.size());
-            packerAppend(p, ": ** NOT DISPLAYED **\r\n", 23);
+            maskThisEntry = true;
             break;
+
+        case HDR_FTP_ARGUMENTS:
+            if (const HttpHeaderEntry *cmd = findEntry(HDR_FTP_COMMAND))
+                maskThisEntry = (cmd->value == "PASS");
+            break;
+
         default:
-            e->packInto(p);
             break;
         }
+        if (maskThisEntry) {
+            packerAppend(p, e->name.rawBuf(), e->name.size());
+            packerAppend(p, ": ** NOT DISPLAYED **\r\n", 23);
+        } else {
+            e->packInto(p);
+        }
+
     }
     /* Pack in the "special" entries */
 
@@ -45,6 +45,7 @@ class HttpHdrRange;
 class HttpHdrSc;
 class Packer;
 class StoreEntry;
+class SBuf;
 
 /* constant attributes of http header fields */
 
@@ -148,6 +149,11 @@ typedef enum {
     HDR_SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
     HDR_SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
     HDR_FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
+    HDR_FTP_COMMAND,                    /**< Internal header for FTP command */
+    HDR_FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
+    HDR_FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
+    HDR_FTP_STATUS,                     /**< Internal header for FTP reply status */
+    HDR_FTP_REASON,                     /**< Internal header for FTP reply reason */
     HDR_OTHER,                          /**< internal tag value for "unknown" headers */
     HDR_ENUM_END
 } http_hdr_type;
@@ -298,6 +304,10 @@ class HttpHeader
 };
 
 int httpHeaderParseQuotedString(const char *start, const int len, String *val);
+
+/// quotes string using RFC 7230 quoted-string rules
+SBuf httpHeaderQuoteString(const char *raw);
+
 int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
 void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
 void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
@@ -1,16 +1,9 @@
-/*
- * HttpHeaderStat.h
- *
- *  Created on: Dec 9, 2011
- *      Author: kinkie
- */
-
 #ifndef HTTPHEADERSTAT_H_
 #define HTTPHEADERSTAT_H_
 
-/* per header statistics */
-
 #include "StatHist.h"
+
+/// per header statistics
 class HttpHeaderStat
 {
 public:
@@ -297,6 +297,37 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
     return 1;
 }
 
+SBuf
+httpHeaderQuoteString(const char *raw)
+{
+    assert(raw);
+
+    // TODO: Optimize by appending a sequence of characters instead of a char.
+    // This optimization may be easier with Tokenizer after raw becomes SBuf.
+
+    // RFC 7230 says a "sender SHOULD NOT generate a quoted-pair in a
+    // quoted-string except where necessary" (i.e., DQUOTE and backslash)
+    bool needInnerQuote = false;
+    for (const char *s = raw; !needInnerQuote &&  *s; ++s)
+        needInnerQuote = *s == '"' || *s == '\\';
+
+    SBuf quotedStr;
+    quotedStr.append('"');
+
+    if (needInnerQuote) {
+        for (const char *s = raw; *s; ++s) {
+            if (*s == '"' || *s == '\\')
+                quotedStr.append('\\');
+            quotedStr.append(*s);
+        }
+    } else {
+        quotedStr.append(raw);
+    }
+
+    quotedStr.append('"');
+    return quotedStr;
+}
+
 /**
  * Checks the anonymizer (header_access) configuration.
  *
@@ -131,6 +131,8 @@ class HttpReply: public HttpMsg
     /// Remove Warnings with warn-date different from Date value
     void removeStaleWarnings();
 
+    virtual void hdrCacheInit();
+
 private:
     /** initialize */
     void init();
@@ -161,8 +163,6 @@ class HttpReply: public HttpMsg
     virtual void packFirstLineInto(Packer * p, bool) const { sline.packInto(p); }
 
     virtual bool parseFirstLine(const char *start, const char *end);
-
-    virtual void hdrCacheInit();
 };
 
 MEMPROXY_CLASS_INLINE(HttpReply);
@@ -46,8 +46,8 @@ LOADABLE_MODULES_SOURCES = \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS	= base anyp parser comm eui acl format fs repl
-DIST_SUBDIRS = base anyp parser comm eui acl format fs repl
+SUBDIRS	= base anyp ftp parser comm eui acl format clients servers fs repl
+DIST_SUBDIRS = base anyp ftp parser comm eui acl format clients servers fs repl
 
 if ENABLE_AUTH
 SUBDIRS += auth
@@ -312,6 +312,7 @@ squid_SOURCES = \
 	ClientRequestContext.h \
 	clientStream.cc \
 	clientStream.h \
+	clientStreamForward.h \
 	CollapsedForwarding.cc \
 	CollapsedForwarding.h \
 	CompletionDispatcher.cc \
@@ -363,8 +364,6 @@ squid_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	Generic.h \
@@ -636,6 +635,9 @@ squid_LDADD = \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
+	clients/libclients.la \
+	servers/libservers.la \
+	ftp/libftp.la \
 	$(XTRA_OBJS) \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS) \
@@ -671,12 +673,15 @@ squid_DEPENDENCIES = \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
+	clients/libclients.la \
+	ftp/libftp.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	format/libformat.la \
 	ipc/libipc.la \
-	mgr/libmgr.la
+	mgr/libmgr.la \
+	servers/libservers.la
 
 if ENABLE_LOADABLE_MODULES
 squid_SOURCES += $(LOADABLE_MODULES_SOURCES)
@@ -1465,8 +1470,6 @@ tests_testCacheManager_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -1604,11 +1607,15 @@ nodist_tests_testCacheManager_SOURCES = \
 	$(DISKIO_GEN_SOURCE)
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
+	clients/libclients.la \
+	servers/libservers.la \
 	http/libsquid-http.la \
+	ftp/libftp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	parser/libsquid-parser.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -1884,8 +1891,6 @@ tests_testEvent_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2038,11 +2043,15 @@ nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEvent_LDADD = \
+	clients/libclients.la \
+	servers/libservers.la \
 	http/libsquid-http.la \
+	ftp/libftp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	parser/libsquid-parser.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2134,8 +2143,6 @@ tests_testEventLoop_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2288,11 +2295,15 @@ nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEventLoop_LDADD = \
+	clients/libclients.la \
+	servers/libservers.la \
 	http/libsquid-http.la \
+	ftp/libftp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	parser/libsquid-parser.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2380,8 +2391,6 @@ tests_test_http_range_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2531,11 +2540,15 @@ nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_test_http_range_LDADD = \
+	clients/libclients.la \
+	servers/libservers.la \
 	http/libsquid-http.la \
+	ftp/libftp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	parser/libsquid-parser.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2688,8 +2701,6 @@ tests_testHttpRequest_SOURCES = \
 	fde.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2823,10 +2834,14 @@ tests_testHttpRequest_SOURCES = \
 nodist_tests_testHttpRequest_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testHttpRequest_LDADD = \
+	clients/libclients.la \
+	servers/libservers.la \
+	ftp/libftp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	parser/libsquid-parser.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -3508,8 +3523,6 @@ tests_testURL_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
-	ftp.h \
-	ftp.cc \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -3664,13 +3677,17 @@ tests_testURL_SOURCES = \
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
+	clients/libclients.la \
+	servers/libservers.la \
 	http/libsquid-http.la \
+	ftp/libftp.la \
 	anyp/libanyp.la \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	parser/libsquid-parser.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -127,6 +127,8 @@ class RequestFlags
     bool done_follow_x_forwarded_for :1;
     /** set for ssl-bumped requests */
     bool sslBumped :1;
+    /// carries a representation of an FTP command [received on ftp_port]
+    bool ftpNative :1;
     bool destinationIpLookedUp:1;
     /** request to reset the TCP stream */
     bool resetTcp:1;
@@ -237,6 +237,12 @@ SBuf::append(const char * S, size_type Ssize)
     return lowAppend(S, Ssize);
 }
 
+SBuf &
+SBuf::append(const char c)
+{
+    return lowAppend(&c, 1);
+}
+
 SBuf&
 SBuf::Printf(const char *fmt, ...)
 {
@@ -834,34 +840,30 @@ SBufStats::dump(std::ostream& os) const
     return os;
 }
 
-SBuf
-SBuf::toLower() const
+void
+SBuf::toLower()
 {
     debugs(24, 8, "\"" << *this << "\"");
-    SBuf rv(*this);
     for (size_type j = 0; j < length(); ++j) {
         const int c = (*this)[j];
         if (isupper(c))
-            rv.setAt(j, tolower(c)); //will cow() if needed
+            setAt(j, tolower(c));
     }
-    debugs(24, 8, "result: \"" << rv << "\"");
+    debugs(24, 8, "result: \"" << *this << "\"");
     ++stats.caseChange;
-    return rv;
 }
 
-SBuf
-SBuf::toUpper() const
+void
+SBuf::toUpper()
 {
     debugs(24, 8, "\"" << *this << "\"");
-    SBuf rv(*this);
     for (size_type j = 0; j < length(); ++j) {
         const int c = (*this)[j];
         if (islower(c))
-            rv.setAt(j, toupper(c)); //will cow() if needed
+            setAt(j, toupper(c));
     }
-    debugs(24, 8, "result: \"" << rv << "\"");
+    debugs(24, 8, "result: \"" << *this << "\"");
     ++stats.caseChange;
-    return rv;
 }
 
 /**
@@ -182,6 +182,9 @@ class SBuf
      */
     SBuf& append(const SBuf & S);
 
+    /// Append a single character. The character may be NUL (\0).
+    SBuf& append(const char c);
+
     /** Append operation for C-style strings.
      *
      * Append the supplied c-string to the SBuf; extend storage
@@ -543,19 +546,11 @@ class SBuf
      */
     int scanf(const char *format, ...);
 
-    /** Lower-case SBuf
-     *
-     * Returns a lower-cased COPY of the SBuf
-     * \see man tolower(3)
-     */
-    SBuf toLower() const;
+    /// converts all characters to lower case; \see man tolower(3)
+    void toLower();
 
-    /** Upper-case SBuf
-     *
-     * Returns an upper-cased COPY of the SBuf
-     * \see man toupper(3)
-     */
-    SBuf toUpper() const;
+    /// converts all characters to upper case; \see man toupper(3)
+    void toUpper();
 
     /** String export function
      * converts the SBuf to a legacy String, by copy.
@@ -628,4 +623,20 @@ operator <<(std::ostream& os, const SBuf& S)
     return S.print(os);
 }
 
+/// Returns a lower-cased copy of its parameter.
+inline SBuf
+ToUpper(SBuf buf)
+{
+    buf.toUpper();
+    return buf;
+}
+
+/// Returns an upper-cased copy of its parameter.
+inline SBuf
+ToLower(SBuf buf)
+{
+    buf.toLower();
+    return buf;
+}
+
 #endif /* SQUID_SBUF_H */
@@ -831,10 +831,11 @@ ServerStateData::handleAdaptationCompleted()
     debugs(11,5, HERE << "handleAdaptationCompleted");
     cleanAdaptation();
 
-    // We stop reading origin response because we have no place to put it and
+    // We stop reading origin response because we have no place to put it(*) and
     // cannot use it. If some origin servers do not like that or if we want to
     // reuse more pconns, we can add code to discard unneeded origin responses.
-    if (!doneWithServer()) {
+    // (*) TODO: Is it possible that the adaptation xaction is still running?
+    if (mayReadVirginReplyBody()) {
         debugs(11,3, HERE << "closing origin conn due to ICAP completion");
         closeServer();
     }
@@ -127,6 +127,8 @@ class ServerStateData:
 
     virtual void closeServer() = 0;            /**< end communication with the server */
     virtual bool doneWithServer() const = 0;   /**< did we end communication? */
+    /// whether we may receive more virgin response body bytes
+    virtual bool mayReadVirginReplyBody() const = 0;
 
     /// Entry-dependent callbacks use this check to quit if the entry went bad
     bool abortOnBadEntry(const char *abortReason);
@@ -108,6 +108,7 @@ class SquidConfig
         time_t request;
         time_t clientIdlePconn;
         time_t serverIdlePconn;
+        time_t ftpClientIdle;
         time_t siteSelect;
         time_t deadPeer;
         int icp_query;      /* msec */
@@ -97,6 +97,8 @@ class StoreEntry : public hash_link
     virtual void complete();
     virtual store_client_t storeClientType() const;
     virtual char const *getSerialisedMetaData();
+    /// Store a prepared error response. MemObject locks the reply object.
+    void storeErrorResponse(HttpReply *reply);
     void replaceHttpReply(HttpReply *, bool andStartWriting = true);
     void startWriting(); ///< pack and write reply headers and, maybe, body
     /// whether we may start writing to disk (now or in the future)
@@ -1,6 +1,3 @@
-#ifndef ACLADDRESS_H_
-#define ACLADDRESS_H_
-#include "Acl.h"
 /*
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -29,6 +26,9 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  */
 
+#ifndef ACLADDRESS_H_
+#define ACLADDRESS_H_
+
 #include "acl/Acl.h"
 #include "ip/Address.h"
 
@@ -21,6 +21,9 @@ class Tree;
 
 } // namespace Acl
 
+class allow_t;
+typedef void ACLCB(allow_t, void *);
+
 #define ACL_NAME_SZ 64
 
 // TODO: Consider renaming all users and removing. Cons: hides the difference
@@ -13,6 +13,7 @@ AnyP::PortCfgPointer HttpPortList;
 #if USE_OPENSSL
 AnyP::PortCfgPointer HttpsPortList;
 #endif
+AnyP::PortCfgPointer FtpPortList;
 
 int NHttpSockets = 0;
 int HttpSockets[MAXTCPLISTENPORTS];
@@ -29,6 +30,7 @@ AnyP::PortCfg::PortCfg() :
         actAsOrigin(false),
         ignore_cc(false),
         connection_auth_disabled(false),
+        ftp_track_dirs(false),
         vport(0),
         disable_pmtu_discovery(0),
         listenConn()
@@ -105,6 +107,7 @@ AnyP::PortCfg::clone() const
     b->vhost = vhost;
     b->vport = vport;
     b->connection_auth_disabled = connection_auth_disabled;
+    b->ftp_track_dirs = ftp_track_dirs;
     b->disable_pmtu_discovery = disable_pmtu_discovery;
     b->tcp_keepalive = tcp_keepalive;
 
@@ -185,19 +188,3 @@ AnyP::PortCfg::configureSslServerContext()
     }
 }
 #endif
-
-void
-AnyP::PortCfg::setTransport(const char *aProtocol)
-{
-    // HTTP/1.0 not supported because we are version 1.1 which contains a superset of 1.0
-    // and RFC 2616 requires us to upgrade 1.0 to 1.1
-
-    if (strcasecmp("http", aProtocol) == 0 || strcmp("HTTP/1.1", aProtocol) == 0)
-        transport = AnyP::ProtocolVersion(AnyP::PROTO_HTTP, 1,1);
-
-    else if (strcasecmp("https", aProtocol) == 0 || strcmp("HTTPS/1.1", aProtocol) == 0)
-        transport = AnyP::ProtocolVersion(AnyP::PROTO_HTTPS, 1,1);
-
-    else
-        fatalf("http(s)_port protocol=%s is not supported\n", aProtocol);
-}
@@ -24,13 +24,6 @@ class PortCfg : public RefCountable
     void configureSslServerContext();
 #endif
 
-    /**
-     * Set this ports transport type from a string representation.
-     * Unknown transport type representations will halt Squid.
-     * Supports: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1.
-     */
-    void setTransport(const char *aProtocol);
-
     PortCfgPointer next;
 
     Ip::Address s;
@@ -47,6 +40,8 @@ class PortCfg : public RefCountable
 
     bool connection_auth_disabled; ///< Don't support connection oriented auth
 
+    bool ftp_track_dirs; ///< whether transactions should track FTP directories
+
     int vport;               ///< virtual port support. -1 if dynamic, >0 static
     int disable_pmtu_discovery;
 
@@ -106,6 +101,9 @@ extern AnyP::PortCfgPointer HttpPortList;
 extern AnyP::PortCfgPointer HttpsPortList;
 #endif
 
+/// list of Squid ftp_port configured
+extern AnyP::PortCfgPointer FtpPortList;
+
 #if !defined(MAXTCPLISTENPORTS)
 // Max number of TCP listening ports
 #define MAXTCPLISTENPORTS 128
@@ -1,6 +1,9 @@
 #include "squid.h"
 #include "CharacterSet.h"
 
+#include <algorithm>
+#include <functional>
+
 CharacterSet &
 CharacterSet::operator +=(const CharacterSet &src)
 {
@@ -44,6 +47,16 @@ CharacterSet::addRange(unsigned char low, unsigned char high)
     return *this;
 }
 
+CharacterSet
+CharacterSet::complement(const char *label) const
+{
+    CharacterSet result((label ? label : "complement_of_some_other_set"), "");
+    // negate each of our elements and add them to the result storage
+    std::transform(chars_.begin(), chars_.end(), result.chars_.begin(),
+                   std::logical_not<Storage::value_type>());
+    return result;
+}
+
 CharacterSet::CharacterSet(const char *label, const char * const c) :
         name(label == NULL ? "anonymous" : label),
         chars_(Storage(256,0))
@@ -33,6 +33,12 @@ class CharacterSet
     /// return a new CharacterSet containing the union of two sets
     CharacterSet operator +(const CharacterSet &src) const;
 
+    /// return a new CharacterSet containing characters not in this set
+    CharacterSet complement(const char *complementLabel = NULL) const;
+
+    /// change name; handy in const declarations that use operators
+    CharacterSet &rename(const char *label) { name = label; return *this; }
+
     /// optional set label for debugging (default: "anonymous")
     const char * name;
 
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "base/CharacterSet.h"
 #include "testCharacterSet.h"
@@ -1,8 +1,6 @@
 #ifndef SQUID_BASE_TESTCHARACTERSET_H
 #define SQUID_BASE_TESTCHARACTERSET_H
 
-#define SQUID_UNIT_TEST 1
-
 #include <cppunit/extensions/HelperMacros.h>
 
 class testCharacterSet : public CPPUNIT_NS::TestFixture
@@ -52,6 +52,7 @@
 #include "eui/Config.h"
 #include "ExternalACL.h"
 #include "format/Format.h"
+#include "ftp/Elements.h"
 #include "globals.h"
 #include "HttpHeaderTools.h"
 #include "HttpRequestMethod.h"
@@ -3566,21 +3567,42 @@ parsePortSpecification(const AnyP::PortCfgPointer &s, char *token)
     }
 }
 
+/// parses the protocol= option of the *_port directive, returning parsed value
+/// unsupported option values result in a fatal error message
+/// upper case values required; caller may convert for backward compatibility
+static AnyP::ProtocolVersion
+parsePortProtocol(const SBuf &value)
+{
+    // HTTP/1.0 not supported because we are version 1.1 which contains a superset of 1.0
+    // and RFC 2616 requires us to upgrade 1.0 to 1.1
+    if (value.cmp("HTTP") == 0 || value.cmp("HTTP/1.1") == 0)
+        return AnyP::ProtocolVersion(AnyP::PROTO_HTTP, 1,1);
+
+    if (value.cmp("HTTPS") == 0 || value.cmp("HTTPS/1.1") == 0)
+        return AnyP::ProtocolVersion(AnyP::PROTO_HTTPS, 1,1);
+
+    if (value.cmp("FTP") == 0)
+        return Ftp::ProtocolVersion();
+
+    fatalf("%s directive does not support protocol=" SQUIDSBUFPH "\n", cfg_directive, SQUIDSBUFPRINT(value));
+    return AnyP::ProtocolVersion(); // not reached
+}
+
 static void
 parse_port_option(AnyP::PortCfgPointer &s, char *token)
 {
     /* modes first */
 
     if (strcmp(token, "accel") == 0) {
         if (s->flags.isIntercepted()) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: Accelerator mode requires its own port. It cannot be shared with other modes.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": Accelerator mode requires its own port. It cannot be shared with other modes.");
             self_destruct();
         }
         s->flags.accelSurrogate = true;
         s->vhost = true;
     } else if (strcmp(token, "transparent") == 0 || strcmp(token, "intercept") == 0) {
         if (s->flags.accelSurrogate || s->flags.tproxyIntercept) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: Intercept mode requires its own interception port. It cannot be shared with other modes.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": Intercept mode requires its own interception port. It cannot be shared with other modes.");
             self_destruct();
         }
         s->flags.natIntercept = true;
@@ -3590,7 +3612,7 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (interception enabled)");
     } else if (strcmp(token, "tproxy") == 0) {
         if (s->flags.natIntercept || s->flags.accelSurrogate) {
-            debugs(3,DBG_CRITICAL, "FATAL: http(s)_port: TPROXY option requires its own interception port. It cannot be shared with other modes.");
+            debugs(3,DBG_CRITICAL, "FATAL: " << cfg_directive << ": TPROXY option requires its own interception port. It cannot be shared with other modes.");
             self_destruct();
         }
         s->flags.tproxyIntercept = true;
@@ -3599,61 +3621,61 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (TPROXY enabled)");
 
         if (!Ip::Interceptor.ProbeForTproxy(s->s)) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: TPROXY support in the system does not work.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": TPROXY support in the system does not work.");
             self_destruct();
         }
 
     } else if (strncmp(token, "defaultsite=", 12) == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: defaultsite option requires Acceleration mode flag.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": defaultsite option requires Acceleration mode flag.");
             self_destruct();
         }
         safe_free(s->defaultsite);
         s->defaultsite = xstrdup(token + 12);
     } else if (strcmp(token, "vhost") == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "WARNING: http(s)_port: vhost option is deprecated. Use 'accel' mode flag instead.");
+            debugs(3, DBG_CRITICAL, "WARNING: " << cfg_directive << ": vhost option is deprecated. Use 'accel' mode flag instead.");
         }
         s->flags.accelSurrogate = true;
         s->vhost = true;
     } else if (strcmp(token, "no-vhost") == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_IMPORTANT, "ERROR: http(s)_port: no-vhost option requires Acceleration mode flag.");
+            debugs(3, DBG_IMPORTANT, "ERROR: " << cfg_directive << ": no-vhost option requires Acceleration mode flag.");
         }
         s->vhost = false;
     } else if (strcmp(token, "vport") == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: vport option requires Acceleration mode flag.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": vport option requires Acceleration mode flag.");
             self_destruct();
         }
         s->vport = -1;
     } else if (strncmp(token, "vport=", 6) == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: vport option requires Acceleration mode flag.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": vport option requires Acceleration mode flag.");
             self_destruct();
         }
         s->vport = xatos(token + 6);
     } else if (strncmp(token, "protocol=", 9) == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: protocol option requires Acceleration mode flag.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": protocol option requires Acceleration mode flag.");
             self_destruct();
         }
-        s->setTransport(token + 9);
+        s->transport = parsePortProtocol(ToUpper(SBuf(token + 9)));
     } else if (strcmp(token, "allow-direct") == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: allow-direct option requires Acceleration mode flag.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": allow-direct option requires Acceleration mode flag.");
             self_destruct();
         }
         s->allow_direct = true;
     } else if (strcmp(token, "act-as-origin") == 0) {
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_IMPORTANT, "ERROR: http(s)_port: act-as-origin option requires Acceleration mode flag.");
+            debugs(3, DBG_IMPORTANT, "ERROR: " << cfg_directive << ": act-as-origin option requires Acceleration mode flag.");
         } else
             s->actAsOrigin = true;
     } else if (strcmp(token, "ignore-cc") == 0) {
 #if !USE_HTTP_VIOLATIONS
         if (!s->flags.accelSurrogate) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: ignore-cc option requires Acceleration mode flag.");
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": ignore-cc option requires Acceleration mode flag.");
             self_destruct();
         }
 #endif
@@ -3680,7 +3702,7 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
             self_destruct();
     } else if (strcmp(token, "ipv4") == 0) {
         if ( !s->s.setIPv4() ) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot be used as IPv4-Only. " << s->s );
+            debugs(3, DBG_CRITICAL, "FATAL: " << cfg_directive << ": IPv6 addresses cannot be used as IPv4-Only. " << s->s );
             self_destruct();
         }
     } else if (strcmp(token, "tcpkeepalive") == 0) {
@@ -3702,7 +3724,7 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
 #if USE_OPENSSL
     } else if (strcmp(token, "sslBump") == 0) {
         debugs(3, DBG_CRITICAL, "WARNING: '" << token << "' is deprecated " <<
-               "in http_port. Use 'ssl-bump' instead.");
+               "in " << cfg_directive << ". Use 'ssl-bump' instead.");
         s->flags.tunnelSslBumping = true;
     } else if (strcmp(token, "ssl-bump") == 0) {
         s->flags.tunnelSslBumping = true;
@@ -3752,8 +3774,10 @@ parse_port_option(AnyP::PortCfgPointer &s, char *token)
     } else if (strncmp(token, "dynamic_cert_mem_cache_size=", 28) == 0) {
         parseBytesOptionValue(&s->dynamicCertMemCacheSize, B_BYTES_STR, token + 28);
 #endif
+    } else if (strcmp(token, "ftp-track-dirs") == 0) {
+        s->ftp_track_dirs = true;
     } else {
-        debugs(3, DBG_CRITICAL, "FATAL: Unknown http(s)_port option '" << token << "'.");
+        debugs(3, DBG_CRITICAL, "FATAL: Unknown " << cfg_directive << " option '" << token << "'.");
         self_destruct();
     }
 }
@@ -3762,7 +3786,7 @@ void
 add_http_port(char *portspec)
 {
     AnyP::PortCfgPointer s = new AnyP::PortCfg();
-    s->setTransport("HTTP");
+    s->transport = parsePortProtocol(SBuf("HTTP"));
     parsePortSpecification(s, portspec);
     // we may need to merge better if the above returns a list with clones
     assert(s->next == NULL);
@@ -3773,13 +3797,15 @@ add_http_port(char *portspec)
 static void
 parsePortCfg(AnyP::PortCfgPointer *head, const char *optionName)
 {
-    const char *protocol = NULL;
+    SBuf protoName;
     if (strcmp(optionName, "http_port") == 0 ||
             strcmp(optionName, "ascii_port") == 0)
-        protocol = "http";
+        protoName = "HTTP";
     else if (strcmp(optionName, "https_port") == 0)
-        protocol = "https";
-    if (!protocol) {
+        protoName = "HTTPS";
+    else if (strcmp(optionName, "ftp_port") == 0)
+        protoName = "FTP";
+    if (protoName.isEmpty()) {
         self_destruct();
         return;
     }
@@ -3792,7 +3818,7 @@ parsePortCfg(AnyP::PortCfgPointer *head, const char *optionName)
     }
 
     AnyP::PortCfgPointer s = new AnyP::PortCfg();
-    s->setTransport(protocol);
+    s->transport = parsePortProtocol(protoName); // default; protocol=... overwrites
     parsePortSpecification(s, token);
 
     /* parse options ... */
@@ -3812,6 +3838,12 @@ parsePortCfg(AnyP::PortCfgPointer *head, const char *optionName)
             debugs(3, DBG_CRITICAL, "FATAL: tproxy/intercept on https_port requires ssl-bump which is missing.");
             self_destruct();
         }
+    } else if (protoName.cmp("FTP") == 0) {
+        /* ftp_port does not support ssl-bump */
+        if (s->flags.tunnelSslBumping) {
+            debugs(3, DBG_CRITICAL, "FATAL: ssl-bump is not supported for ftp_port.");
+            self_destruct();
+        }
     }
 #endif
 
@@ -916,7 +916,7 @@ DOC_START
 	acl aclname localport 3128 ...	      # TCP port the client connected to [fast]
 	                                      # NP: for interception mode this is usually '80'
 
-	acl aclname myportname 3128 ...       # http(s)_port name [fast]
+	acl aclname myportname 3128 ...       # *_port name [fast]
 
 	acl aclname proto HTTP FTP ...        # request protocol [fast]
  
@@ -1304,7 +1304,7 @@ DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 DOC_START
 	Allowing or Denying access based on defined access lists
 
-	Access to the HTTP port:
+	To allow or deny a message received on an HTTP, HTTPS, or FTP port:
 	http_access allow|deny [!]aclname ...
 
 	NOTE on default values:
@@ -1935,6 +1935,70 @@ DOC_START
 	See http_port for a list of available options.
 DOC_END
 
+NAME: ftp_port
+TYPE: PortCfg
+DEFAULT: none
+LOC: FtpPortList
+DOC_START
+	Enables Native FTP proxy by specifying the socket address where Squid
+	listens for FTP client requests. See http_port directive for various
+	ways to specify the listening address and mode.
+
+	Usage: ftp_port address [mode] [options]
+
+	WARNING: This is a new, experimental, complex feature that has seen
+	limited production exposure. Some Squid modules (e.g., caching) do not
+	currently work with native FTP proxying, and many features have not
+	even been tested for compatibility. Test well before deploying!
+
+	Native FTP proxying differs substantially from proxying HTTP requests
+	with ftp:// URIs because Squid works as an FTP server and receives
+	actual FTP commands (rather than HTTP requests with FTP URLs).
+
+	Native FTP commands accepted at ftp_port are internally converted or
+	wrapped into HTTP-like messages. The same happens to Native FTP
+	responses received from FTP origin servers. Those HTTP-like messages
+	are shoveled through regular access control and adaptation layers
+	between the FTP client and the FTP origin server. This allows Squid to
+	examine, adapt, block, and log FTP exchanges. Squid reuses most HTTP
+	mechanisms when shoveling wrapped FTP messages. For example,
+	http_access and adaptation_access directives are used.
+
+	Modes:
+
+	   intercept	Same as http_port intercept. The FTP origin address is
+			determined based on the intended destination of the
+			intercepted connection.
+
+	   tproxy	Support Linux TPROXY for spoofing outgoing
+			connections using the client IP address.
+			NP: disables authentication and maybe IPv6 on the port.
+
+	By default (i.e., without an explicit mode option), Squid extracts the
+	FTP origin address from the login@origin parameter of the FTP USER
+	command. Many popular FTP clients support such native FTP proxying.
+
+	Options:
+
+	   name=token	Specifies an internal name for the port. Defaults to
+			the port address. Usable with myportname ACL.
+
+	   ftp-track-dirs
+			Enables tracking of FTP directories by injecting extra
+			PWD commands and adjusting Request-URI (in wrapping
+			HTTP requests) to reflect the current FTP server
+			directory. Tracking is disabled by default.
+
+	   protocol=FTP	Protocol to reconstruct accelerated and intercepted
+			requests with. Defaults to FTP. No other accepted
+			values have been tested with. An unsupported value
+			results in a FATAL error. Accepted values are FTP,
+			HTTP (or HTTP/1.1), and HTTPS (or HTTPS/1.1).
+
+	Other http_port modes and options that are not specific to HTTP and
+	HTTPS may also work.
+DOC_END
+
 NAME: tcp_outgoing_tos tcp_outgoing_ds tcp_outgoing_dscp
 TYPE: acl_tos
 DEFAULT: none
@@ -5901,6 +5965,17 @@ DOC_START
 	client connection after the previous request completes.
 DOC_END
 
+NAME: ftp_client_idle_timeout
+TYPE: time_t
+LOC: Config.Timeout.ftpClientIdle
+DEFAULT: 30 minutes
+DOC_START
+	How long to wait for an FTP request on a connection to Squid ftp_port.
+	Many FTP clients do not deal with idle connection closures well,
+	necessitating a longer default timeout than client_idle_pconn_timeout
+	used for incoming HTTP requests.
+DOC_END
+
 NAME: client_lifetime
 COMMENT: time-units
 TYPE: time_t
@@ -33,6 +33,7 @@
 #define SQUID_CLIENTSTREAM_H
 
 #include "base/RefCount.h"
+#include "clientStreamForward.h"
 #include "dlink.h"
 #include "StoreIOBuffer.h"
 
@@ -95,28 +96,6 @@
  \li		Because of the callback nature of squid, every node would have to keep these parameters in their context anyway, so this reduces programmer overhead.
  */
 
-/// \ingroup ClientStreamAPI
-typedef RefCount<Lock> ClientStreamData;
-
-class clientStreamNode;
-class ClientHttpRequest;
-class HttpReply;
-
-/* client stream read callback */
-/// \ingroup ClientStreamAPI
-typedef void CSCB(clientStreamNode *, ClientHttpRequest *, HttpReply *, StoreIOBuffer);
-
-/* client stream read */
-/// \ingroup ClientStreamAPI
-typedef void CSR(clientStreamNode *, ClientHttpRequest *);
-
-/* client stream detach */
-/// \ingroup ClientStreamAPI
-typedef void CSD(clientStreamNode *, ClientHttpRequest *);
-
-/// \ingroup ClientStreamAPI
-typedef clientStream_status_t CSS(clientStreamNode *, ClientHttpRequest *);
-
 /// \ingroup ClientStreamAPI
 class clientStreamNode
 {
@@ -0,0 +1,29 @@
+#ifndef SQUID_CLIENTSTREAM_FORWARD_H
+#define SQUID_CLIENTSTREAM_FORWARD_H
+
+#include "enums.h" /* for clientStream_status_t */
+
+class Lock;
+template <class C> class RefCount;
+
+typedef RefCount<Lock> ClientStreamData;
+
+/* Callbacks for ClientStreams API */
+
+class clientStreamNode;
+class ClientHttpRequest;
+class HttpReply;
+class StoreIOBuffer;
+
+/// client stream read callback
+typedef void CSCB(clientStreamNode *, ClientHttpRequest *, HttpReply *, StoreIOBuffer);
+
+/// client stream read
+typedef void CSR(clientStreamNode *, ClientHttpRequest *);
+
+/// client stream detach
+typedef void CSD(clientStreamNode *, ClientHttpRequest *);
+
+typedef clientStream_status_t CSS(clientStreamNode *, ClientHttpRequest *);
+
+#endif /* SQUID_CLIENTSTREAM_FORWARD_H */
@@ -121,6 +121,7 @@
 #include "mime_header.h"
 #include "profiler/Profiler.h"
 #include "rfc1738.h"
+#include "servers/forward.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -197,14 +198,9 @@ static IOACB httpAccept;
 static IOACB httpsAccept;
 #endif
 static CTCB clientLifetimeTimeout;
-static ClientSocketContext *parseHttpRequestAbort(ConnStateData * conn, const char *uri);
-static ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, Http::ProtocolVersion *);
 #if USE_IDENT
 static IDCB clientIdentDone;
 #endif
-static CSCB clientSocketRecipient;
-static CSD clientSocketDetach;
-static void clientSetKeepaliveFlag(ClientHttpRequest *);
 static int clientIsContentLengthValid(HttpRequest * r);
 static int clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength);
 
@@ -216,7 +212,6 @@ void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 #ifndef PURIFY
 static bool connIsUsable(ConnStateData * conn);
 #endif
-static int responseFinishedOrFailed(HttpReply * rep, StoreIOBuffer const &receivedData);
 static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
 static void clientUpdateSocketStats(LogTags logType, size_t size);
 
@@ -238,6 +233,12 @@ ClientSocketContext::getClientReplyContext() const
     return (clientStreamNode *)http->client_stream.tail->prev->data;
 }
 
+ConnStateData *
+ClientSocketContext::getConn() const
+{
+    return http->getConn();
+}
+
 /**
  * This routine should be called to grow the in.buf and then
  * call Comm::Read().
@@ -350,28 +351,16 @@ ClientSocketContext::ClientSocketContext(const Comm::ConnectionPointer &aConn, C
 void
 ClientSocketContext::writeControlMsg(HttpControlMsg &msg)
 {
-    const HttpReply::Pointer rep(msg.reply);
+    HttpReply::Pointer rep(msg.reply);
     Must(rep != NULL);
 
-    // apply selected clientReplyContext::buildReplyHeader() mods
-    // it is not clear what headers are required for control messages
-    rep->header.removeHopByHopEntries();
-    rep->header.putStr(HDR_CONNECTION, "keep-alive");
-    httpHdrMangleList(&rep->header, http->request, ROR_REPLY);
-
     // remember the callback
     cbControlMsgSent = msg.cbSuccess;
 
-    MemBuf *mb = rep->pack();
-
-    debugs(11, 2, "HTTP Client " << clientConnection);
-    debugs(11, 2, "HTTP Client CONTROL MSG:\n---------\n" << mb->buf << "\n----------");
-
     AsyncCall::Pointer call = commCbCall(33, 5, "ClientSocketContext::wroteControlMsg",
                                          CommIoCbPtrFun(&WroteControlMsg, this));
-    Comm::Write(clientConnection, mb, call);
 
-    delete mb;
+    getConn()->writeControlMsgAndCall(this, rep.getRaw(), call);
 }
 
 /// called when we wrote the 1xx response
@@ -393,6 +382,9 @@ ClientSocketContext::wroteControlMsg(const Comm::ConnectionPointer &conn, char *
     // close on 1xx errors to be conservative and to simplify the code
     // (if we do not close, we must notify the source of a failure!)
     conn->close();
+
+    // XXX: writeControlMsgAndCall() should handle writer-specific writing
+    // results, including errors and then call us with success/failure outcome.
 }
 
 /// wroteControlMsg() wrapper: ClientSocketContext is not an AsyncJob
@@ -617,7 +609,7 @@ ClientHttpRequest::logRequest()
 
     debugs(33, 9, "clientLogRequest: http.code='" << al->http.code << "'");
 
-    if (loggingEntry() && loggingEntry()->mem_obj)
+    if (loggingEntry() && loggingEntry()->mem_obj && loggingEntry()->objectLen() >= 0)
         al->cache.objectSize = loggingEntry()->contentLen(); // payload duplicate ?? with or without TE ?
 
     al->http.clientRequestSz.header = req_sz;
@@ -846,7 +838,7 @@ ConnStateData::swanSong()
     assert(areAllContextsForThisConnection());
     freeAllContexts();
 
-    unpinConnection();
+    unpinConnection(true);
 
     if (Comm::IsConnOpen(clientConnection))
         clientConnection->close();
@@ -893,7 +885,7 @@ ConnStateData::~ConnStateData()
  * to set this relatively early in the request processing
  * to handle hacks for broken servers and clients.
  */
-static void
+void
 clientSetKeepaliveFlag(ClientHttpRequest * http)
 {
     HttpRequest *request = http->request;
@@ -966,15 +958,6 @@ ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply *
     return;
 }
 
-int
-responseFinishedOrFailed(HttpReply * rep, StoreIOBuffer const & receivedData)
-{
-    if (rep == NULL && receivedData.data == NULL && receivedData.length == 0)
-        return 1;
-
-    return 0;
-}
-
 bool
 ClientSocketContext::startOfOutput() const
 {
@@ -1471,7 +1454,7 @@ ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
  *   data context is not NULL
  *   There are no more entries in the stream chain.
  */
-static void
+void
 clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
                       HttpReply * rep, StoreIOBuffer receivedData)
 {
@@ -1491,30 +1474,10 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
 
     /* TODO: check offset is what we asked for */
 
-    if (context != http->getConn()->getCurrentContext()) {
+    if (context != http->getConn()->getCurrentContext())
         context->deferRecipientForLater(node, rep, receivedData);
-        PROF_stop(clientSocketRecipient);
-        return;
-    }
-
-    // After sending Transfer-Encoding: chunked (at least), always send
-    // the last-chunk if there was no error, ignoring responseFinishedOrFailed.
-    const bool mustSendLastChunk = http->request->flags.chunkedReply &&
-                                   !http->request->flags.streamError && !context->startOfOutput();
-    if (responseFinishedOrFailed(rep, receivedData) && !mustSendLastChunk) {
-        context->writeComplete(context->clientConnection, NULL, 0, Comm::OK);
-        PROF_stop(clientSocketRecipient);
-        return;
-    }
-
-    if (!context->startOfOutput())
-        context->sendBody(rep, receivedData);
-    else {
-        assert(rep);
-        http->al->reply = rep;
-        HTTPMSGLOCK(http->al->reply);
-        context->sendStartOfMessage(rep, receivedData);
-    }
+    else
+        http->getConn()->handleReply(rep, receivedData);
 
     PROF_stop(clientSocketRecipient);
 }
@@ -1564,7 +1527,7 @@ ConnStateData::readNextRequest()
     typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall = JobCallback(33, 5,
                                      TimeoutDialer, this, ConnStateData::requestTimeout);
-    commSetConnTimeout(clientConnection, Config.Timeout.clientIdlePconn, timeoutCall);
+    commSetConnTimeout(clientConnection, idleTimeout(), timeoutCall);
 
     readSomeData();
     /** Please don't do anything with the FD past here! */
@@ -1943,21 +1906,15 @@ ClientSocketContext::writeComplete(const Comm::ConnectionPointer &conn, char *bu
     }
 }
 
-SQUIDCEXTERN CSR clientGetMoreData;
-SQUIDCEXTERN CSS clientReplyStatus;
-SQUIDCEXTERN CSD clientReplyDetach;
-
-static ClientSocketContext *
-parseHttpRequestAbort(ConnStateData * csd, const char *uri)
+ClientSocketContext *
+ConnStateData::abortRequestParsing(const char *const uri)
 {
-    ClientHttpRequest *http;
-    ClientSocketContext *context;
-    StoreIOBuffer tempBuffer;
-    http = new ClientHttpRequest(csd);
-    http->req_sz = csd->in.buf.length();
+    ClientHttpRequest *http = new ClientHttpRequest(this);
+    http->req_sz = in.buf.length();
     http->uri = xstrdup(uri);
     setLogUri (http, uri);
-    context = new ClientSocketContext(csd->clientConnection, http);
+    ClientSocketContext *context = new ClientSocketContext(clientConnection, http);
+    StoreIOBuffer tempBuffer;
     tempBuffer.data = context->reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
     clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,
@@ -2082,7 +2039,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
 
         if (!url) {
             hp->request_parse_status = Http::scBadRequest;
-            return parseHttpRequestAbort(conn, "error:invalid-request");
+            return conn->abortRequestParsing("error:invalid-request");
         }
 #endif
 
@@ -2134,7 +2091,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
                  AnyP::UriScheme(conn->port->transport.protocol).c_str(), conn->port->defaultsite, vportStr, url);
         debugs(33, 5, "ACCEL DEFAULTSITE REWRITE: '" << http->uri <<"'");
     } else if (vport > 0 /* && (!vhost || no Host:) */) {
-        debugs(33, 5, "ACCEL VPORT REWRITE: http_port IP + vport=" << vport);
+        debugs(33, 5, "ACCEL VPORT REWRITE: *_port IP + vport=" << vport);
         /* Put the local socket IP address as the hostname, with whatever vport we found  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
@@ -2188,7 +2145,7 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
  *  \return NULL on incomplete requests,
  *          a ClientSocketContext structure on success or failure.
  */
-static ClientSocketContext *
+ClientSocketContext *
 parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_p, Http::ProtocolVersion *http_ver)
 {
     char *req_hdr = NULL;
@@ -2210,7 +2167,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     } else if ( (size_t)hp->bufsiz >= Config.maxRequestHeaderSize && headersEnd(hp->buf, Config.maxRequestHeaderSize) == 0) {
         debugs(33, 5, "parseHttpRequest: Too large request");
         hp->request_parse_status = Http::scHeaderTooLarge;
-        return parseHttpRequestAbort(csd, "error:request-too-large");
+        return csd->abortRequestParsing("error:request-too-large");
     }
 
     /* Attempt to parse the first line; this'll define the method, url, version and header begin */
@@ -2222,7 +2179,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     }
 
     if (r == -1) {
-        return parseHttpRequestAbort(csd, "error:invalid-request");
+        return csd->abortRequestParsing("error:invalid-request");
     }
 
     /* Request line is valid here .. */
@@ -2255,7 +2212,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     if (req_sz >= Config.maxRequestHeaderSize) {
         debugs(33, 5, "parseHttpRequest: Too large request");
         hp->request_parse_status = Http::scHeaderTooLarge;
-        return parseHttpRequestAbort(csd, "error:request-too-large");
+        return csd->abortRequestParsing("error:request-too-large");
     }
 
     /* Set method_p */
@@ -2267,14 +2224,14 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "WARNING: for request: " << hp->buf);
         hp->request_parse_status = Http::scMethodNotAllowed;
-        return parseHttpRequestAbort(csd, "error:method-not-allowed");
+        return csd->abortRequestParsing("error:method-not-allowed");
     }
 
     if (*method_p == Http::METHOD_NONE) {
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "clientParseRequestMethod: Unsupported method in request '" << hp->buf << "'");
         hp->request_parse_status = Http::scMethodNotAllowed;
-        return parseHttpRequestAbort(csd, "error:unsupported-request-method");
+        return csd->abortRequestParsing("error:unsupported-request-method");
     }
 
     /*
@@ -2442,32 +2399,18 @@ ConnStateData::connFinishedWithConn(int size)
 }
 
 void
-connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount)
+ConnStateData::consumeInput(const size_t byteCount)
 {
-    assert(byteCount > 0 && byteCount <= conn->in.buf.length());
-    conn->in.buf.consume(byteCount);
-    debugs(33, 5, "conn->in.buf has " << conn->in.buf.length() << " bytes unused.");
+    assert(byteCount > 0 && byteCount <= in.buf.length());
+    in.buf.consume(byteCount);
+    debugs(33, 5, "in.buf has " << in.buf.length() << " unused bytes");
 }
 
-/// respond with ERR_TOO_BIG if request header exceeds request_header_max_size
+// TODO: Remove when renaming ConnStateData
 void
-ConnStateData::checkHeaderLimits()
+connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount)
 {
-    if (in.buf.length() < Config.maxRequestHeaderSize)
-        return; // can accumulte more header data
-
-    debugs(33, 3, "Request header is too large (" << in.buf.length() << " > " <<
-           Config.maxRequestHeaderSize << " bytes)");
-
-    ClientSocketContext *context = parseHttpRequestAbort(this, "error:request-too-large");
-    clientStreamNode *node = context->getClientReplyContext();
-    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-    assert (repContext);
-    repContext->setReplyToError(ERR_TOO_BIG,
-                                Http::scBadRequest, Http::METHOD_NONE, NULL,
-                                clientConnection->remote, NULL, NULL, NULL);
-    context->registerWithConn();
-    context->pullData();
+    conn->consumeInput(byteCount);
 }
 
 void
@@ -2583,6 +2526,23 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
 #endif // USE_OPENSSL
 
 static void
+clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request)
+{
+    /*
+     * DPW 2007-05-18
+     * Moved the TCP_RESET feature from clientReplyContext::sendMoreData
+     * to here because calling comm_reset_close() causes http to
+     * be freed and the above connNoteUseOfBuffer() would hit an
+     * assertion, not to mention that we were accessing freed memory.
+     */
+    if (request != NULL && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
+        debugs(33, 3, HERE << "Sending TCP RST on " << conn->clientConnection);
+        conn->flags.readMore = false;
+        comm_reset_close(conn->clientConnection);
+    }
+}
+
+void
 clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod& method, Http::ProtocolVersion http_ver)
 {
     ClientHttpRequest *http = context->http;
@@ -2593,85 +2553,103 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     bool unsupportedTe = false;
     bool expectBody = false;
 
-    /* We have an initial client stream in place should it be needed */
-    /* setup our private context */
-    context->registerWithConn();
+    // temporary hack to avoid splitting this huge function with sensitive code
+    const bool isFtp = !hp;
+    if (isFtp) {
+        // In FTP, case, we already have the request parsed and checked, so we
+        // only need to go through the final body/conn setup to doCallouts().
+        assert(http->request);
+        request = http->request;
+        notedUseOfBuffer = true;
+    } else {
 
-    if (context->flags.parsed_ok == 0) {
-        clientStreamNode *node = context->getClientReplyContext();
-        debugs(33, 2, "clientProcessRequest: Invalid Request");
-        conn->quitAfterError(NULL);
-        // setLogUri should called before repContext->setReplyToError
-        setLogUri(http, http->uri,  true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        switch (hp->request_parse_status) {
-        case Http::scHeaderTooLarge:
-            repContext->setReplyToError(ERR_TOO_BIG, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
-            break;
-        case Http::scMethodNotAllowed:
-            repContext->setReplyToError(ERR_UNSUP_REQ, Http::scMethodNotAllowed, method, http->uri,
-                                        conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
-            break;
-        default:
-            repContext->setReplyToError(ERR_INVALID_REQ, hp->request_parse_status, method, http->uri,
-                                        conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
+        if (context->flags.parsed_ok == 0) {
+            clientStreamNode *node = context->getClientReplyContext();
+            debugs(33, 2, "clientProcessRequest: Invalid Request");
+            conn->quitAfterError(NULL);
+            // setLogUri should called before repContext->setReplyToError
+            setLogUri(http, http->uri,  true);
+            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+            assert (repContext);
+            switch (hp->request_parse_status) {
+            case Http::scHeaderTooLarge:
+                repContext->setReplyToError(ERR_TOO_BIG, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
+                break;
+            case Http::scMethodNotAllowed:
+                repContext->setReplyToError(ERR_UNSUP_REQ, Http::scMethodNotAllowed, method, http->uri,
+                                            conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
+                break;
+            default:
+                repContext->setReplyToError(ERR_INVALID_REQ, hp->request_parse_status, method, http->uri,
+                                            conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
+            }
+            assert(context->http->out.offset == 0);
+            context->pullData();
+            connNoteUseOfBuffer(conn, http->req_sz);
+            return;
         }
-        assert(context->http->out.offset == 0);
-        context->pullData();
-        goto finish;
-    }
 
-    if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, method)) == NULL) {
-        clientStreamNode *node = context->getClientReplyContext();
-        debugs(33, 5, "Invalid URL: " << http->uri);
-        conn->quitAfterError(request.getRaw());
-        // setLogUri should called before repContext->setReplyToError
-        setLogUri(http, http->uri,  true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
-        goto finish;
-    }
+        if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, method)) == NULL) {
+            clientStreamNode *node = context->getClientReplyContext();
+            debugs(33, 5, "Invalid URL: " << http->uri);
+            conn->quitAfterError(request.getRaw());
+            // setLogUri should called before repContext->setReplyToError
+            setLogUri(http, http->uri,  true);
+            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+            assert (repContext);
+            repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
+            assert(context->http->out.offset == 0);
+            context->pullData();
+            connNoteUseOfBuffer(conn, http->req_sz);
+            return;
+        }
 
-    /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
-    /* We currently only support 0.9, 1.0, 1.1 properly */
-    if ( (http_ver.major == 0 && http_ver.minor != 9) ||
-            (http_ver.major > 1) ) {
+        /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
+        /* We currently only support 0.9, 1.0, 1.1 properly */
+        /* TODO: move HTTP-specific processing into servers/HttpServer and such */
+        if ( (http_ver.major == 0 && http_ver.minor != 9) ||
+                (http_ver.major > 1) ) {
 
-        clientStreamNode *node = context->getClientReplyContext();
-        debugs(33, 5, "Unsupported HTTP version discovered. :\n" << HttpParserHdrBuf(hp));
-        conn->quitAfterError(request.getRaw());
-        // setLogUri should called before repContext->setReplyToError
-        setLogUri(http, http->uri,  true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, method, http->uri,
-                                    conn->clientConnection->remote, NULL, HttpParserHdrBuf(hp), NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
-        goto finish;
-    }
+            clientStreamNode *node = context->getClientReplyContext();
+            debugs(33, 5, "Unsupported HTTP version discovered. :\n" << HttpParserHdrBuf(hp));
+            conn->quitAfterError(request.getRaw());
+            // setLogUri should called before repContext->setReplyToError
+            setLogUri(http, http->uri,  true);
+            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+            assert (repContext);
+            repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, method, http->uri,
+                                        conn->clientConnection->remote, NULL, HttpParserHdrBuf(hp), NULL);
+            assert(context->http->out.offset == 0);
+            context->pullData();
+            connNoteUseOfBuffer(conn, http->req_sz);
+            clientProcessRequestFinished(conn, request);
+            return;
+        }
 
-    /* compile headers */
-    /* we should skip request line! */
-    /* XXX should actually know the damned buffer size here */
-    if (http_ver.major >= 1 && !request->parseHeader(HttpParserHdrBuf(hp), HttpParserHdrSz(hp))) {
-        clientStreamNode *node = context->getClientReplyContext();
-        debugs(33, 5, "Failed to parse request headers:\n" << HttpParserHdrBuf(hp));
-        conn->quitAfterError(request.getRaw());
-        // setLogUri should called before repContext->setReplyToError
-        setLogUri(http, http->uri,  true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
-        goto finish;
+        /* compile headers */
+        /* we should skip request line! */
+        /* XXX should actually know the damned buffer size here */
+        if (http_ver.major >= 1 && !request->parseHeader(HttpParserHdrBuf(hp), HttpParserHdrSz(hp))) {
+            clientStreamNode *node = context->getClientReplyContext();
+            debugs(33, 5, "Failed to parse request headers:\n" << HttpParserHdrBuf(hp));
+            conn->quitAfterError(request.getRaw());
+            // setLogUri should called before repContext->setReplyToError
+            setLogUri(http, http->uri,  true);
+            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+            assert (repContext);
+            repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
+            assert(context->http->out.offset == 0);
+            context->pullData();
+            connNoteUseOfBuffer(conn, http->req_sz);
+            clientProcessRequestFinished(conn, request);
+            return;
+        }
     }
 
+    // Some blobs below are still HTTP-specific, but we would have to rewrite
+    // this entire function to remove them from the FTP code path. Connection
+    // setup and body_pipe preparation blobs are needed for FTP.
+
     request->clientConnectionManager = conn;
 
     request->flags.accelerated = http->flags.accel;
@@ -2759,7 +2737,9 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
                                     conn->clientConnection->remote, request.getRaw(), NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
-        goto finish;
+        connNoteUseOfBuffer(conn, http->req_sz);
+        clientProcessRequestFinished(conn, request);
+        return;
     }
 
     if (!chunked && !clientIsContentLengthValid(request.getRaw())) {
@@ -2772,7 +2752,9 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
                                     conn->clientConnection->remote, request.getRaw(), NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
-        goto finish;
+        connNoteUseOfBuffer(conn, http->req_sz);
+        clientProcessRequestFinished(conn, request);
+        return;
     }
 
     if (request->header.has(HDR_EXPECT)) {
@@ -2787,14 +2769,18 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
                                         conn->clientConnection->remote, request.getRaw(), NULL, NULL);
             assert(context->http->out.offset == 0);
             context->pullData();
-            goto finish;
+            connNoteUseOfBuffer(conn, http->req_sz);
+            clientProcessRequestFinished(conn, request);
+            return;
         }
     }
 
-    http->request = request.getRaw();
-    HTTPMSGLOCK(http->request);
-    clientSetKeepaliveFlag(http);
+    if (!isFtp) {
+        http->request = request.getRaw();
+        HTTPMSGLOCK(http->request);
+    }
 
+    clientSetKeepaliveFlag(http);
     // Let tunneling code be fully responsible for CONNECT requests
     if (http->request->method == Http::METHOD_CONNECT) {
         context->mayUseConnection(true);
@@ -2806,8 +2792,12 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     }
 
 #if USE_OPENSSL
-    if (conn->switchedToHttps() && conn->serveDelayedError(context))
-        goto finish;
+    if (conn->switchedToHttps() && conn->serveDelayedError(context)) {
+        if (!notedUseOfBuffer)
+            connNoteUseOfBuffer(conn, http->req_sz);
+        clientProcessRequestFinished(conn, request);
+        return;
+    }
 #endif
 
     /* Do we expect a request-body? */
@@ -2816,9 +2806,11 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
         request->body_pipe = conn->expectRequestBody(
                                  chunked ? -1 : request->content_length);
 
-        // consume header early so that body pipe gets just the body
-        connNoteUseOfBuffer(conn, http->req_sz);
-        notedUseOfBuffer = true;
+        if (!isFtp) {
+            // consume header early so that body pipe gets just the body
+            connNoteUseOfBuffer(conn, http->req_sz);
+            notedUseOfBuffer = true;
+        }
 
         /* Is it too large? */
         if (!chunked && // if chunked, we will check as we accumulate
@@ -2832,41 +2824,34 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
                                         conn->clientConnection->remote, http->request, NULL, NULL);
             assert(context->http->out.offset == 0);
             context->pullData();
-            goto finish;
+            clientProcessRequestFinished(conn, request);
+            return;
         }
 
-        // We may stop producing, comm_close, and/or call setReplyToError()
-        // below, so quit on errors to avoid http->doCallouts()
-        if (!conn->handleRequestBodyData())
-            goto finish;
+        if (!isFtp) {
+            // We may stop producing, comm_close, and/or call setReplyToError()
+            // below, so quit on errors to avoid http->doCallouts()
+            if (!conn->handleRequestBodyData()) {
+                clientProcessRequestFinished(conn, request);
+                return;
+            }
 
-        if (!request->body_pipe->productionEnded()) {
-            debugs(33, 5, HERE << "need more request body");
-            context->mayUseConnection(true);
-            assert(conn->flags.readMore);
+            if (!request->body_pipe->productionEnded()) {
+                debugs(33, 5, "need more request body");
+                context->mayUseConnection(true);
+                assert(conn->flags.readMore);
+            }
         }
     }
 
     http->calloutContext = new ClientRequestContext(http);
 
     http->doCallouts();
 
-finish:
     if (!notedUseOfBuffer)
         connNoteUseOfBuffer(conn, http->req_sz);
 
-    /*
-     * DPW 2007-05-18
-     * Moved the TCP_RESET feature from clientReplyContext::sendMoreData
-     * to here because calling comm_reset_close() causes http to
-     * be freed and the above connNoteUseOfBuffer() would hit an
-     * assertion, not to mention that we were accessing freed memory.
-     */
-    if (request != NULL && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
-        debugs(33, 3, HERE << "Sending TCP RST on " << conn->clientConnection);
-        conn->flags.readMore = false;
-        comm_reset_close(conn->clientConnection);
-    }
+    clientProcessRequestFinished(conn, request);
 }
 
 static void
@@ -2878,6 +2863,12 @@ connStripBufferWhitespace (ConnStateData * conn)
     }
 }
 
+int
+ConnStateData::pipelinePrefetchMax() const
+{
+    return Config.pipeline_max_prefetch;
+}
+
 /**
  * Limit the number of concurrent requests.
  * \return true  when there are available position(s) in the pipeline queue for another request.
@@ -2890,7 +2881,7 @@ ConnStateData::concurrentRequestQueueFilled() const
 
     // default to the configured pipeline size.
     // add 1 because the head of pipeline is counted in concurrent requests and not prefetch queue
-    const int concurrentRequestLimit = Config.pipeline_max_prefetch + 1;
+    const int concurrentRequestLimit = pipelinePrefetchMax() + 1;
 
     // when queue filled already we cant add more.
     if (existingRequestCount >= concurrentRequestLimit) {
@@ -2904,13 +2895,12 @@ ConnStateData::concurrentRequestQueueFilled() const
 
 /**
  * Attempt to parse one or more requests from the input buffer.
- * If a request is successfully parsed, even if the next request
- * is only partially parsed, it will return TRUE.
+ * Returns true after completing parsing of at least one request [header]. That
+ * includes cases where parsing ended with an error (e.g., a huge request).
  */
 bool
 ConnStateData::clientParseRequests()
 {
-    HttpRequestMethod method;
     bool parsed_req = false;
 
     debugs(33, 5, HERE << clientConnection << ": attempting to parse");
@@ -2928,38 +2918,28 @@ ConnStateData::clientParseRequests()
         if (concurrentRequestQueueFilled())
             break;
 
-        /* Begin the parsing */
-        PROF_start(parseHttpRequest);
-        HttpParserInit(&parser_, in.buf.c_str(), in.buf.length());
-
-        /* Process request */
         Http::ProtocolVersion http_ver;
-        ClientSocketContext *context = parseHttpRequest(this, &parser_, &method, &http_ver);
-        PROF_stop(parseHttpRequest);
-
-        /* partial or incomplete request */
-        if (!context) {
-            // TODO: why parseHttpRequest can just return parseHttpRequestAbort
-            // (which becomes context) but checkHeaderLimits cannot?
-            checkHeaderLimits();
-            break;
-        }
-
-        /* status -1 or 1 */
-        if (context) {
-            debugs(33, 5, HERE << clientConnection << ": parsed a request");
+        if (ClientSocketContext *context = parseOneRequest(http_ver)) {
+            debugs(33, 5, clientConnection << ": done parsing a request");
             AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "clientLifetimeTimeout",
                                              CommTimeoutCbPtrFun(clientLifetimeTimeout, context->http));
             commSetConnTimeout(clientConnection, Config.Timeout.lifetime, timeoutCall);
 
-            clientProcessRequest(this, &parser_, context, method, http_ver);
+            context->registerWithConn();
+
+            processParsedRequest(context, http_ver);
 
             parsed_req = true; // XXX: do we really need to parse everything right NOW ?
 
             if (context->mayUseConnection()) {
                 debugs(33, 3, HERE << "Not parsing new requests, as this request may need the connection");
                 break;
             }
+        } else {
+            debugs(33, 5, clientConnection << ": not enough request data: " <<
+                   in.buf.length() << " < " << Config.maxRequestHeaderSize);
+            Must(in.buf.length() < Config.maxRequestHeaderSize);
+            break;
         }
     }
 
@@ -3208,27 +3188,14 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
     flags.readMore = false;
 }
 
-void
-ConnStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer )
-{
-    if (!handleRequestBodyData())
-        return;
-
-    // too late to read more body
-    if (!isOpen() || stoppedReceiving())
-        return;
-
-    readSomeData();
-}
-
 void
 ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer )
 {
     // request reader may get stuck waiting for space if nobody consumes body
     if (bodyPipe != NULL)
         bodyPipe->enableAutoConsumption();
 
-    stopReceiving("virgin request body consumer aborted"); // closes ASAP
+    // kids extend
 }
 
 /** general lifetime handler for HTTP requests */
@@ -3259,7 +3226,7 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
 }
 
 ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
-        AsyncJob("ConnStateData"),
+        AsyncJob("ConnStateData"), // kids overwrite
 #if USE_OPENSSL
         sslBumpMode(Ssl::bumpEnd),
         switchedToHttps_(false),
@@ -3281,6 +3248,15 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
     log_addr = xact->tcpClient->remote;
     log_addr.applyMask(Config.Addrs.client_netmask);
 
+    flags.readMore = true; // kids may overwrite
+}
+
+void
+ConnStateData::start()
+{
+    BodyProducer::start();
+    HttpControlMsgSink::start();
+
     // ensure a buffer is present for this connection
     in.maybeMakeSpaceAvailable();
 
@@ -3310,54 +3286,17 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
 #if USE_IDENT
     if (Ident::TheConfig.identLookup) {
         ACLFilledChecklist identChecklist(Ident::TheConfig.identLookup, NULL, NULL);
-        identChecklist.src_addr = xact->tcpClient->remote;
-        identChecklist.my_addr = xact->tcpClient->local;
+        identChecklist.src_addr = clientConnection->remote;
+        identChecklist.my_addr = clientConnection->local;
         if (identChecklist.fastCheck() == ACCESS_ALLOWED)
-            Ident::Start(xact->tcpClient, clientIdentDone, this);
+            Ident::Start(clientConnection, clientIdentDone, this);
     }
 #endif
 
     clientdbEstablished(clientConnection->remote, 1);
 
-    flags.readMore = true;
-}
-
-/** Handle a new connection on HTTP socket. */
-void
-httpAccept(const CommAcceptCbParams &params)
-{
-    MasterXaction::Pointer xact = params.xaction;
-    AnyP::PortCfgPointer s = xact->squidPort;
-
-    // NP: it is possible the port was reconfigured when the call or accept() was queued.
-
-    if (params.flag != Comm::OK) {
-        // Its possible the call was still queued when the client disconnected
-        debugs(33, 2, "httpAccept: " << s->listenConn << ": accept failure: " << xstrerr(params.xerrno));
-        return;
-    }
-
-    debugs(33, 4, HERE << params.conn << ": accepted");
-    fd_note(params.conn->fd, "client http connect");
-
-    if (s->tcp_keepalive.enabled) {
-        commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
-    }
-
-    ++ incoming_sockets_accepted;
-
-    // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = new ConnStateData(xact);
-
-    typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
-    AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
-                                      TimeoutDialer, connState, ConnStateData::requestTimeout);
-    commSetConnTimeout(params.conn, Config.Timeout.request, timeoutCall);
-
-    connState->readSomeData();
-
 #if USE_DELAY_POOLS
-    fd_table[params.conn->fd].clientInfo = NULL;
+    fd_table[clientConnection->fd].clientInfo = NULL;
 
     if (Config.onoff.client_db) {
         /* it was said several times that client write limiter does not work if client_db is disabled */
@@ -3368,8 +3307,8 @@ httpAccept(const CommAcceptCbParams &params)
         // TODO: we check early to limit error response bandwith but we
         // should recheck when we can honor delay_pool_uses_indirect
         // TODO: we should also pass the port details for myportname here.
-        ch.src_addr = params.conn->remote;
-        ch.my_addr = params.conn->local;
+        ch.src_addr = clientConnection->remote;
+        ch.my_addr = clientConnection->local;
 
         for (unsigned int pool = 0; pool < pools.size(); ++pool) {
 
@@ -3381,11 +3320,11 @@ httpAccept(const CommAcceptCbParams &params)
 
                     /*  request client information from db after we did all checks
                         this will save hash lookup if client failed checks */
-                    ClientInfo * cli = clientdbGetInfo(params.conn->remote);
+                    ClientInfo * cli = clientdbGetInfo(clientConnection->remote);
                     assert(cli);
 
                     /* put client info in FDE */
-                    fd_table[params.conn->fd].clientInfo = cli;
+                    fd_table[clientConnection->fd].clientInfo = cli;
 
                     /* setup write limiter for this request */
                     const double burst = floor(0.5 +
@@ -3399,6 +3338,36 @@ httpAccept(const CommAcceptCbParams &params)
         }
     }
 #endif
+
+    // kids must extend to actually start doing something (e.g., reading)
+}
+
+/** Handle a new connection on an HTTP socket. */
+void
+httpAccept(const CommAcceptCbParams &params)
+{
+    MasterXaction::Pointer xact = params.xaction;
+    AnyP::PortCfgPointer s = xact->squidPort;
+
+    // NP: it is possible the port was reconfigured when the call or accept() was queued.
+
+    if (params.flag != Comm::OK) {
+        // Its possible the call was still queued when the client disconnected
+        debugs(33, 2, s->listenConn << ": accept failure: " << xstrerr(params.xerrno));
+        return;
+    }
+
+    debugs(33, 4, params.conn << ": accepted");
+    fd_note(params.conn->fd, "client http connect");
+
+    if (s->tcp_keepalive.enabled)
+        commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
+
+    ++incoming_sockets_accepted;
+
+    // Socket is ready, setup the connection manager to start using it
+    ConnStateData *connState = Http::NewServer(xact);
+    AsyncJob::Start(connState); // usually async-calls readSomeData()
 }
 
 #if USE_OPENSSL
@@ -3661,34 +3630,38 @@ httpsAccept(const CommAcceptCbParams &params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = new ConnStateData(xact);
+    ConnStateData *connState = Https::NewServer(xact);
+    AsyncJob::Start(connState); // usually async-calls postHttpsAccept()
+}
 
-    if (s->flags.tunnelSslBumping) {
-        debugs(33, 5, "httpsAccept: accept transparent connection: " << params.conn);
+void
+ConnStateData::postHttpsAccept()
+{
+    if (port->flags.tunnelSslBumping) {
+        debugs(33, 5, "accept transparent connection: " << clientConnection);
 
         if (!Config.accessList.ssl_bump) {
-            httpsSslBumpAccessCheckDone(ACCESS_DENIED, connState);
+            httpsSslBumpAccessCheckDone(ACCESS_DENIED, this);
             return;
         }
 
         // Create a fake HTTP request for ssl_bump ACL check,
         // using tproxy/intercept provided destination IP and port.
         HttpRequest *request = new HttpRequest();
         static char ip[MAX_IPSTRLEN];
-        assert(params.conn->flags & (COMM_TRANSPARENT | COMM_INTERCEPTION));
-        request->SetHost(params.conn->local.toStr(ip, sizeof(ip)));
-        request->port = params.conn->local.port();
-        request->myportname = s->name;
+        assert(clientConnection->flags & (COMM_TRANSPARENT | COMM_INTERCEPTION));
+        request->SetHost(clientConnection->local.toStr(ip, sizeof(ip)));
+        request->port = clientConnection->local.port();
+        request->myportname = port->name;
 
         ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(Config.accessList.ssl_bump, request, NULL);
-        acl_checklist->conn(connState);
-        acl_checklist->src_addr = params.conn->remote;
-        acl_checklist->my_addr = s->s;
-        acl_checklist->nonBlockingCheck(httpsSslBumpAccessCheckDone, connState);
+        acl_checklist->src_addr = clientConnection->remote;
+        acl_checklist->my_addr = port->s;
+        acl_checklist->nonBlockingCheck(httpsSslBumpAccessCheckDone, this);
         return;
     } else {
-        SSL_CTX *sslContext = s->staticSslContext.get();
-        httpsEstablish(connState, sslContext, Ssl::bumpNone);
+        SSL_CTX *sslContext = port->staticSslContext.get();
+        httpsEstablish(this, sslContext, Ssl::bumpNone);
     }
 }
 
@@ -4293,6 +4266,31 @@ clientHttpsConnectionsOpen(void)
 }
 #endif
 
+void
+clientStartListeningOn(AnyP::PortCfgPointer &port, const RefCount< CommCbFunPtrCallT<CommAcceptCbPtrFun> > &subCall, const Ipc::FdNoteId fdNote)
+{
+    // Fill out a Comm::Connection which IPC will open as a listener for us
+    port->listenConn = new Comm::Connection;
+    port->listenConn->local = port->s;
+    port->listenConn->flags =
+        COMM_NONBLOCKING |
+        (port->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
+        (port->flags.natIntercept ? COMM_INTERCEPTION : 0);
+
+    // route new connections to subCall
+    typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
+    Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
+    AsyncCall::Pointer listenCall =
+        asyncCall(33, 2, "clientListenerConnectionOpened",
+                  ListeningStartedDialer(&clientListenerConnectionOpened,
+                                         port, fdNote, sub));
+    Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, port->listenConn, fdNote, listenCall);
+
+    assert(NHttpSockets < MAXTCPLISTENPORTS);
+    HttpSockets[NHttpSockets] = -1;
+    ++NHttpSockets;
+}
+
 /// process clientHttpConnectionsOpen result
 static void
 clientListenerConnectionOpened(AnyP::PortCfgPointer &s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
@@ -4325,13 +4323,14 @@ clientOpenListenSockets(void)
 #if USE_OPENSSL
     clientHttpsConnectionsOpen();
 #endif
+    Ftp::StartListening();
 
     if (NHttpSockets < 1)
-        fatal("No HTTP or HTTPS ports configured");
+        fatal("No HTTP, HTTPS, or FTP ports configured");
 }
 
 void
-clientHttpConnectionsClose(void)
+clientConnectionsClose()
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL) {
@@ -4351,6 +4350,8 @@ clientHttpConnectionsClose(void)
     }
 #endif
 
+    Ftp::StopListening();
+
     // TODO see if we can drop HttpSockets array entirely */
     for (int i = 0; i < NHttpSockets; ++i) {
         HttpSockets[i] = -1;
@@ -4437,8 +4438,6 @@ clientAclChecklistCreate(const acl_access * acl, ClientHttpRequest * http)
     return ch;
 }
 
-CBDATA_CLASS_INIT(ConnStateData);
-
 bool
 ConnStateData::transparent() const
 {
@@ -4588,31 +4587,37 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
     assert(pinning.serverConnection == io.conn);
     pinning.closeHandler = NULL; // Comm unregisters handlers before calling
     const bool sawZeroReply = pinning.zeroReply; // reset when unpinning
-    unpinConnection();
+    unpinConnection(false);
+
     if (sawZeroReply && clientConnection != NULL) {
         debugs(33, 3, "Closing client connection on pinned zero reply.");
         clientConnection->close();
     }
+
 }
 
 void
-ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, CachePeer *aPeer, bool auth)
+ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, CachePeer *aPeer, bool auth, bool monitor)
 {
-    char desc[FD_DESC_SZ];
+    if (!Comm::IsConnOpen(pinning.serverConnection) ||
+            pinning.serverConnection->fd != pinServer->fd)
+        pinNewConnection(pinServer, request, aPeer, auth);
 
-    if (Comm::IsConnOpen(pinning.serverConnection)) {
-        if (pinning.serverConnection->fd == pinServer->fd) {
-            startPinnedConnectionMonitoring();
-            return;
-        }
-    }
+    if (monitor)
+        startPinnedConnectionMonitoring();
+}
 
-    unpinConnection(); // closes pinned connection, if any, and resets fields
+void
+ConnStateData::pinNewConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, CachePeer *aPeer, bool auth)
+{
+    unpinConnection(true); // closes pinned connection, if any, and resets fields
 
     pinning.serverConnection = pinServer;
 
     debugs(33, 3, HERE << pinning.serverConnection);
 
+    Must(pinning.serverConnection != NULL);
+
     // when pinning an SSL bumped connection, the request may be NULL
     const char *pinnedHost = "[unknown]";
     if (request) {
@@ -4627,6 +4632,7 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
         pinning.peer = cbdataReference(aPeer);
     pinning.auth = auth;
     char stmp[MAX_IPSTRLEN];
+    char desc[FD_DESC_SZ];
     snprintf(desc, FD_DESC_SZ, "%s pinned connection for %s (%d)",
              (auth || !aPeer) ? pinnedHost : aPeer->name,
              clientConnection->remote.toUrl(stmp,MAX_IPSTRLEN),
@@ -4641,11 +4647,10 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
     Params &params = GetCommParams<Params>(pinning.closeHandler);
     params.conn = pinning.serverConnection;
     comm_add_close_handler(pinning.serverConnection->fd, pinning.closeHandler);
-
-    startPinnedConnectionMonitoring();
 }
 
-/// Assign a read handler to an idle pinned connection so that we can detect connection closures.
+/// [re]start monitoring pinned connection for peer closures so that we can
+/// propagate them to an _idle_ client pinned to that peer
 void
 ConnStateData::startPinnedConnectionMonitoring()
 {
@@ -4712,14 +4717,24 @@ ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *a
 
     if (!valid) {
         /* The pinning info is not safe, remove any pinning info */
-        unpinConnection();
+        unpinConnection(true);
     }
 
     return pinning.serverConnection;
 }
 
+Comm::ConnectionPointer
+ConnStateData::borrowPinnedConnection(HttpRequest *request, const CachePeer *aPeer)
+{
+    debugs(33, 7, pinning.serverConnection);
+    if (validatePinnedConnection(request, aPeer) != NULL)
+        stopPinnedConnectionMonitoring();
+
+    return pinning.serverConnection; // closed if validation failed
+}
+
 void
-ConnStateData::unpinConnection()
+ConnStateData::unpinConnection(const bool andClose)
 {
     debugs(33, 3, HERE << pinning.serverConnection);
 
@@ -4731,9 +4746,13 @@ ConnStateData::unpinConnection()
             comm_remove_close_handler(pinning.serverConnection->fd, pinning.closeHandler);
             pinning.closeHandler = NULL;
         }
-        /// also close the server side socket, we should not use it for any future requests...
-        // TODO: do not close if called from our close handler?
-        pinning.serverConnection->close();
+
+        stopPinnedConnectionMonitoring();
+
+        // close the server side socket if requested
+        if (andClose)
+            pinning.serverConnection->close();
+        pinning.serverConnection = NULL;
     }
 
     safe_free(pinning.host);
@@ -33,9 +33,11 @@
 #ifndef SQUID_CLIENTSIDE_H
 #define SQUID_CLIENTSIDE_H
 
+#include "clientStreamForward.h"
 #include "comm.h"
 #include "HttpControlMsg.h"
 #include "HttpParser.h"
+#include "ipc/FdNotes.h"
 #include "SBuf.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -137,6 +139,7 @@ class ClientSocketContext : public RefCountable
     void buildRangeHeader(HttpReply * rep);
     clientStreamNode * getTail() const;
     clientStreamNode * getClientReplyContext() const;
+    ConnStateData *getConn() const;
     void connIsFinished();
     void removeFromConnectionList(ConnStateData * conn);
     void deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData);
@@ -193,7 +196,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
 
 public:
     explicit ConnStateData(const MasterXaction::Pointer &xact);
-    ~ConnStateData();
+    virtual ~ConnStateData();
 
     void readSomeData();
     bool areAllContextsForThisConnection() const;
@@ -206,7 +209,6 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     void addContextToQueue(ClientSocketContext * context);
     int getConcurrentRequestCount() const;
     bool isOpen() const;
-    void checkHeaderLimits();
 
     // HttpControlMsgSink API
     virtual void sendControlMsg(HttpControlMsg msg);
@@ -268,6 +270,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         int port;               /* port of pinned connection */
         bool pinned;             /* this connection was pinned */
         bool auth;               /* pinned for www authentication */
+        bool reading;   ///< we are monitoring for peer connection closure
         bool zeroReply; ///< server closed w/o response (ERR_ZERO_SIZE_OBJECT)
         CachePeer *peer;             /* CachePeer the connection goes via */
         AsyncCall::Pointer readHandler; ///< detects serverConnection closure
@@ -292,21 +295,21 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
 
     void expectNoForwarding(); ///< cleans up virgin request [body] forwarding state
 
+    /* BodyPipe API */
     BodyPipe::Pointer expectRequestBody(int64_t size);
-    virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
-    virtual void noteBodyConsumerAborted(BodyPipe::Pointer);
+    virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer) = 0;
+    virtual void noteBodyConsumerAborted(BodyPipe::Pointer) = 0;
 
     bool handleReadData();
     bool handleRequestBodyData();
 
-    /**
-     * Correlate the current ConnStateData object with the pinning_fd socket descriptor.
-     */
-    void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth);
-    /**
-     * Decorrelate the ConnStateData object from its pinned CachePeer
-     */
-    void unpinConnection();
+    /// Forward future client requests using the given server connection.
+    /// Optionally, monitor pinned server connection for server-side closures.
+    void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth, bool monitor = true);
+    /// Undo pinConnection() and, optionally, close the pinned connection.
+    void unpinConnection(const bool andClose);
+    /// Returns validated pinnned server connection (and stops its monitoring).
+    Comm::ConnectionPointer borrowPinnedConnection(HttpRequest *request, const CachePeer *aPeer);
     /**
      * Checks if there is pinning info if it is valid. It can close the server side connection
      * if pinned info is not valid.
@@ -321,15 +324,20 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     CachePeer *pinnedPeer() const {return pinning.peer;}
     bool pinnedAuth() const {return pinning.auth;}
 
+    /// called just before a FwdState-dispatched job starts using connection
+    virtual void notePeerConnection(Comm::ConnectionPointer) {}
+
     // pining related comm callbacks
-    void clientPinnedConnectionClosed(const CommCloseCbParams &io);
+    virtual void clientPinnedConnectionClosed(const CommCloseCbParams &io);
 
     // comm callbacks
     void clientReadRequest(const CommIoCbParams &io);
+    void clientReadFtpData(const CommIoCbParams &io);
     void connStateClosed(const CommCloseCbParams &io);
     void requestTimeout(const CommTimeoutCbParams &params);
 
     // AsyncJob API
+    virtual void start();
     virtual bool doneAll() const { return BodyProducer::doneAll() && false;}
     virtual void swanSong();
 
@@ -341,6 +349,9 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     void stopPinnedConnectionMonitoring();
 
 #if USE_OPENSSL
+    /// the second part of old httpsAccept, waiting for future HttpsServer home
+    void postHttpsAccept();
+
     /// Initializes and starts a peek-and-splice negotiation with the SSL client
     void startPeekAndSplice();
     /// Called when the initialization of peek-and-splice negotiation finidhed
@@ -393,6 +404,21 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     const SBuf &connectionTag() const { return connectionTag_; }
     void connectionTag(const char *aTag) { connectionTag_ = aTag; }
 
+    /// handle a control message received by context from a peer and call back
+    virtual void writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &call) = 0;
+
+    /// ClientStream calls this to supply response header (once) and data
+    /// for the current ClientSocketContext.
+    virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData) = 0;
+
+    /// remove no longer needed leading bytes from the input buffer
+    void consumeInput(const size_t byteCount);
+
+    /* TODO: Make the methods below (at least) non-public when possible. */
+
+    /// stop parsing the request and create context for relaying error info
+    ClientSocketContext *abortRequestParsing(const char *const errUri);
+
 protected:
     void startDechunkingRequest();
     void finishDechunkingRequest(bool withSuccess);
@@ -402,20 +428,34 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     void startPinnedConnectionMonitoring();
     void clientPinnedConnectionRead(const CommIoCbParams &io);
 
+    /// parse input buffer prefix into a single transfer protocol request
+    /// return NULL to request more header bytes (after checking any limits)
+    /// use abortRequestParsing() to handle parsing errors w/o creating request
+    virtual ClientSocketContext *parseOneRequest(Http::ProtocolVersion &ver) = 0;
+
+    /// start processing a freshly parsed request
+    virtual void processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &ver) = 0;
+
+    /// returning N allows a pipeline of 1+N requests (see pipeline_prefetch)
+    virtual int pipelinePrefetchMax() const;
+
+    /// timeout to use when waiting for the next request
+    virtual time_t idleTimeout() const = 0;
+
+    BodyPipe::Pointer bodyPipe; ///< set when we are reading request body
+
 private:
     int connFinishedWithConn(int size);
     void clientAfterReadingRequests();
     bool concurrentRequestQueueFilled() const;
 
+    void pinNewConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, CachePeer *aPeer, bool auth);
+
 #if USE_AUTH
     /// some user details that can be used to perform authentication on this connection
     Auth::UserRequest::Pointer auth_;
 #endif
 
-    HttpParser parser_;
-
-    // XXX: CBDATA plays with public/private and leaves the following 'private' fields all public... :(
-
 #if USE_OPENSSL
     bool switchedToHttps_;
     /// The SSL server host name appears in CONNECT request or the server ip address for the intercepted requests
@@ -434,11 +474,8 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     const char *stoppedReceiving_;
 
     AsyncCall::Pointer reader; ///< set when we are reading
-    BodyPipe::Pointer bodyPipe; // set when we are reading request body
 
     SBuf connectionTag_; ///< clt_conn_tag=Tag annotation for client connection
-
-    CBDATA_CLASS2(ConnStateData);
 };
 
 void setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl = false);
@@ -447,8 +484,26 @@ const char *findTrailingHTTPVersion(const char *uriAndHTTPVersion, const char *e
 
 int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
 
+/// accept requests to a given port and inform subCall about them
+void clientStartListeningOn(AnyP::PortCfgPointer &port, const RefCount< CommCbFunPtrCallT<CommAcceptCbPtrFun> > &subCall, const Ipc::FdNoteId noteId);
+
 void clientOpenListenSockets(void);
-void clientHttpConnectionsClose(void);
+void clientConnectionsClose(void);
 void httpRequestFree(void *);
 
+/// decide whether to expect multiple requests on the corresponding connection
+void clientSetKeepaliveFlag(ClientHttpRequest *http);
+
+/* misplaced declaratrions of Stream callbacks provided/used by client side */
+SQUIDCEXTERN CSR clientGetMoreData;
+SQUIDCEXTERN CSS clientReplyStatus;
+SQUIDCEXTERN CSD clientReplyDetach;
+CSCB clientSocketRecipient;
+CSD clientSocketDetach;
+
+/* TODO: Move to HttpServer. Warning: Move requires large code nonchanges! */
+ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, Http::ProtocolVersion *);
+void clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod& method, Http::ProtocolVersion http_ver);
+void clientPostHttpsAccept(ConnStateData *connState);
+
 #endif /* SQUID_CLIENTSIDE_H */
@@ -141,6 +141,24 @@ void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorS
     /* Now the caller reads to get this */
 }
 
+void
+clientReplyContext::setReplyToReply(HttpReply *futureReply)
+{
+    Must(futureReply);
+    http->al->http.code = futureReply->sline.status();
+
+    HttpRequestMethod method;
+    if (http->request) { // nil on responses to unparsable requests
+        http->request->ignoreRange("responding with a Squid-generated reply");
+        method = http->request->method;
+    }
+
+    createStoreEntry(method, RequestFlags());
+
+    http->storeEntry()->storeErrorResponse(futureReply);
+    /* Now the caller reads to get futureReply */
+}
+
 // Assumes that the entry contains an error response without Content-Range.
 // To use with regular entries, make HTTP Range header removal conditional.
 void clientReplyContext::setReplyToStoreEntry(StoreEntry *entry, const char *reason)
@@ -31,6 +31,7 @@
 #ifndef SQUID_CLIENTSIDEREPLY_H
 #define SQUID_CLIENTSIDEREPLY_H
 
+#include "acl/forward.h"
 #include "client_side_request.h"
 #include "ip/forward.h"
 #include "RequestFlags.h"
@@ -78,6 +79,8 @@ class clientReplyContext : public RefCountable, public StoreClient
 #endif
     /// creates a store entry for the reply and appends err to it
     void setReplyToError(const HttpRequestMethod& method, ErrorState *err);
+    /// creates a store entry for the reply and appends error reply to it
+    void setReplyToReply(HttpReply *reply);
     void createStoreEntry(const HttpRequestMethod& m, RequestFlags flags);
     void removeStoreReference(store_client ** scp, StoreEntry ** ep);
     void removeClientStoreReference(store_client **scp, ClientHttpRequest *http);
@@ -0,0 +1,1126 @@
+/*
+ * DEBUG: section 09    File Transfer Protocol (FTP)
+ *
+ */
+
+#include "squid.h"
+#include "acl/FilledChecklist.h"
+#include "client_side.h"
+#include "clients/FtpClient.h"
+#include "comm/ConnOpener.h"
+#include "comm/Read.h"
+#include "comm/TcpAcceptor.h"
+#include "comm/Write.h"
+#include "errorpage.h"
+#include "fd.h"
+#include "ftp/Parsing.h"
+#include "ip/tools.h"
+#include "Mem.h"
+#include "SquidConfig.h"
+#include "SquidString.h"
+#include "StatCounters.h"
+#include "tools.h"
+#include "wordlist.h"
+
+#include <set>
+
+namespace Ftp
+{
+
+const char *const crlf = "\r\n";
+
+static char *
+escapeIAC(const char *buf)
+{
+    int n;
+    char *ret;
+    unsigned const char *p;
+    unsigned char *r;
+
+    for (p = (unsigned const char *)buf, n = 1; *p; ++n, ++p)
+        if (*p == 255)
+            ++n;
+
+    ret = (char *)xmalloc(n);
+
+    for (p = (unsigned const char *)buf, r=(unsigned char *)ret; *p; ++p) {
+        *r = *p;
+        ++r;
+
+        if (*p == 255) {
+            *r = 255;
+            ++r;
+        }
+    }
+
+    *r = '\0';
+    ++r;
+    assert((r - (unsigned char *)ret) == n );
+    return ret;
+}
+
+/* Ftp::Channel */
+
+/// configures the channel with a descriptor and registers a close handler
+void
+Ftp::Channel::opened(const Comm::ConnectionPointer &newConn,
+                     const AsyncCall::Pointer &aCloser)
+{
+    assert(!Comm::IsConnOpen(conn));
+    assert(closer == NULL);
+
+    assert(Comm::IsConnOpen(newConn));
+    assert(aCloser != NULL);
+
+    conn = newConn;
+    closer = aCloser;
+    comm_add_close_handler(conn->fd, closer);
+}
+
+/// planned close: removes the close handler and calls comm_close
+void
+Ftp::Channel::close()
+{
+    // channels with active listeners will be closed when the listener handler dies.
+    if (Comm::IsConnOpen(conn)) {
+        comm_remove_close_handler(conn->fd, closer);
+        conn->close(); // we do not expect to be called back
+    }
+    clear();
+}
+
+void
+Ftp::Channel::forget()
+{
+    if (Comm::IsConnOpen(conn)) {
+        commUnsetConnTimeout(conn);
+        comm_remove_close_handler(conn->fd, closer);
+    }
+    clear();
+}
+
+void
+Ftp::Channel::clear()
+{
+    conn = NULL;
+    closer = NULL;
+}
+
+/* Ftp::CtrlChannel */
+
+Ftp::CtrlChannel::CtrlChannel():
+        buf(NULL),
+        size(0),
+        offset(0),
+        message(NULL),
+        last_command(NULL),
+        last_reply(NULL),
+        replycode(0)
+{
+    buf = static_cast<char*>(memAllocBuf(4096, &size));
+}
+
+Ftp::CtrlChannel::~CtrlChannel()
+{
+    memFreeBuf(size, buf);
+    if (message)
+        wordlistDestroy(&message);
+    safe_free(last_command);
+    safe_free(last_reply);
+}
+
+/* Ftp::DataChannel */
+
+Ftp::DataChannel::DataChannel():
+        readBuf(NULL),
+        host(NULL),
+        port(0),
+        read_pending(false)
+{
+}
+
+Ftp::DataChannel::~DataChannel()
+{
+    delete readBuf;
+}
+
+void
+Ftp::DataChannel::addr(const Ip::Address &import)
+{
+    static char addrBuf[MAX_IPSTRLEN];
+    import.toStr(addrBuf, sizeof(addrBuf));
+    xfree(host);
+    host = xstrdup(addrBuf);
+    port = import.port();
+}
+
+/* Ftp::Client */
+
+Ftp::Client::Client(FwdState *fwdState):
+        AsyncJob("Ftp::Client"),
+        ::ServerStateData(fwdState),
+        ctrl(),
+        data(),
+        state(BEGIN),
+        old_request(NULL),
+        old_reply(NULL),
+        shortenReadTimeout(false)
+{
+    ++statCounter.server.all.requests;
+    ++statCounter.server.ftp.requests;
+
+    ctrl.last_command = xstrdup("Connect to server");
+
+    typedef CommCbMemFunT<Client, CommCloseCbParams> Dialer;
+    const AsyncCall::Pointer closer = JobCallback(9, 5, Dialer, this,
+                                      Ftp::Client::ctrlClosed);
+    ctrl.opened(fwdState->serverConnection(), closer);
+}
+
+Ftp::Client::~Client()
+{
+    if (data.opener != NULL) {
+        data.opener->cancel("Ftp::Client destructed");
+        data.opener = NULL;
+    }
+    data.close();
+
+    safe_free(old_request);
+    safe_free(old_reply);
+    fwd = NULL; // refcounted
+}
+
+void
+Ftp::Client::start()
+{
+    scheduleReadControlReply(0);
+}
+
+void
+Ftp::Client::initReadBuf()
+{
+    if (data.readBuf == NULL) {
+        data.readBuf = new MemBuf;
+        data.readBuf->init(4096, SQUID_TCP_SO_RCVBUF);
+    }
+}
+
+/**
+ * Close the FTP server connection(s). Used by serverComplete().
+ */
+void
+Ftp::Client::closeServer()
+{
+    if (Comm::IsConnOpen(ctrl.conn)) {
+        debugs(9, 3, "closing FTP server FD " << ctrl.conn->fd << ", this " << this);
+        fwd->unregister(ctrl.conn);
+        ctrl.close();
+    }
+
+    if (Comm::IsConnOpen(data.conn)) {
+        debugs(9, 3, "closing FTP data FD " << data.conn->fd << ", this " << this);
+        data.close();
+    }
+
+    debugs(9, 3, "FTP ctrl and data connections closed. this " << this);
+}
+
+/**
+ * Did we close all FTP server connection(s)?
+ *
+ \retval true  Both server control and data channels are closed. And not waiting for a new data connection to open.
+ \retval false Either control channel or data is still active.
+ */
+bool
+Ftp::Client::doneWithServer() const
+{
+    return !Comm::IsConnOpen(ctrl.conn) && !Comm::IsConnOpen(data.conn);
+}
+
+void
+Ftp::Client::failed(err_type error, int xerrno)
+{
+    debugs(9, 3, "entry-null=" << (entry?entry->isEmpty():0) << ", entry=" << entry);
+
+    const char *command, *reply;
+    const Http::StatusCode httpStatus = failedHttpStatus(error);
+    ErrorState *const ftperr = new ErrorState(error, httpStatus, fwd->request);
+    ftperr->xerrno = xerrno;
+
+    ftperr->ftp.server_msg = ctrl.message;
+    ctrl.message = NULL;
+
+    if (old_request)
+        command = old_request;
+    else
+        command = ctrl.last_command;
+
+    if (command && strncmp(command, "PASS", 4) == 0)
+        command = "PASS <yourpassword>";
+
+    if (old_reply)
+        reply = old_reply;
+    else
+        reply = ctrl.last_reply;
+
+    if (command)
+        ftperr->ftp.request = xstrdup(command);
+
+    if (reply)
+        ftperr->ftp.reply = xstrdup(reply);
+
+    fwd->request->detailError(error, xerrno);
+    fwd->fail(ftperr);
+
+    closeServer(); // we failed, so no serverComplete()
+}
+
+Http::StatusCode
+Ftp::Client::failedHttpStatus(err_type &error)
+{
+    if (error == ERR_NONE)
+        error = ERR_FTP_FAILURE;
+    return error == ERR_READ_TIMEOUT ? Http::scGatewayTimeout :
+           Http::scBadGateway;
+}
+
+/**
+ * DPW 2007-04-23
+ * Looks like there are no longer anymore callers that set
+ * buffered_ok=1.  Perhaps it can be removed at some point.
+ */
+void
+Ftp::Client::scheduleReadControlReply(int buffered_ok)
+{
+    debugs(9, 3, ctrl.conn);
+
+    if (buffered_ok && ctrl.offset > 0) {
+        /* We've already read some reply data */
+        handleControlReply();
+    } else {
+        /*
+         * Cancel the timeout on the Data socket (if any) and
+         * establish one on the control socket.
+         */
+        if (Comm::IsConnOpen(data.conn)) {
+            commUnsetConnTimeout(data.conn);
+        }
+
+        const time_t tout = shortenReadTimeout ?
+                            min(Config.Timeout.connect, Config.Timeout.read):
+                            Config.Timeout.read;
+        shortenReadTimeout = false; // we only need to do this once, after PASV
+
+        typedef CommCbMemFunT<Client, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer timeoutCall = JobCallback(9, 5, TimeoutDialer, this, Ftp::Client::timeout);
+        commSetConnTimeout(ctrl.conn, tout, timeoutCall);
+
+        typedef CommCbMemFunT<Client, CommIoCbParams> Dialer;
+        AsyncCall::Pointer reader = JobCallback(9, 5, Dialer, this, Ftp::Client::readControlReply);
+        comm_read(ctrl.conn, ctrl.buf + ctrl.offset, ctrl.size - ctrl.offset, reader);
+    }
+}
+
+void
+Ftp::Client::readControlReply(const CommIoCbParams &io)
+{
+    debugs(9, 3, "FD " << io.fd << ", Read " << io.size << " bytes");
+
+    if (io.size > 0) {
+        kb_incr(&(statCounter.server.all.kbytes_in), io.size);
+        kb_incr(&(statCounter.server.ftp.kbytes_in), io.size);
+    }
+
+    if (io.flag == Comm::ERR_CLOSING)
+        return;
+
+    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
+        abortTransaction("entry aborted during control reply read");
+        return;
+    }
+
+    assert(ctrl.offset < ctrl.size);
+
+    if (io.flag == Comm::OK && io.size > 0) {
+        fd_bytes(io.fd, io.size, FD_READ);
+    }
+
+    if (io.flag != Comm::OK) {
+        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
+               "FTP control reply read error: " << xstrerr(io.xerrno));
+
+        if (ignoreErrno(io.xerrno)) {
+            scheduleReadControlReply(0);
+        } else {
+            failed(ERR_READ_ERROR, io.xerrno);
+            /* failed closes ctrl.conn and frees ftpState */
+        }
+        return;
+    }
+
+    if (io.size == 0) {
+        if (entry->store_status == STORE_PENDING) {
+            failed(ERR_FTP_FAILURE, 0);
+            /* failed closes ctrl.conn and frees ftpState */
+            return;
+        }
+
+        /* XXX this may end up having to be serverComplete() .. */
+        abortTransaction("zero control reply read");
+        return;
+    }
+
+    unsigned int len =io.size + ctrl.offset;
+    ctrl.offset = len;
+    assert(len <= ctrl.size);
+    if (Comm::IsConnOpen(ctrl.conn))
+        commUnsetConnTimeout(ctrl.conn); // we are done waiting for ctrl reply
+    handleControlReply();
+}
+
+void
+Ftp::Client::handleControlReply()
+{
+    debugs(9, 3, status());
+
+    size_t bytes_used = 0;
+    wordlistDestroy(&ctrl.message);
+
+    if (!parseControlReply(bytes_used)) {
+        /* didn't get complete reply yet */
+
+        if (ctrl.offset == ctrl.size) {
+            ctrl.buf = static_cast<char*>(memReallocBuf(ctrl.buf, ctrl.size << 1, &ctrl.size));
+        }
+
+        scheduleReadControlReply(0);
+        return;
+    }
+
+    assert(ctrl.message); // the entire FTP server response, line by line
+    assert(ctrl.replycode >= 0); // FTP status code (from the last line)
+    assert(ctrl.last_reply); // FTP reason (from the last line)
+
+    if (ctrl.offset == bytes_used) {
+        /* used it all up */
+        ctrl.offset = 0;
+    } else {
+        /* Got some data past the complete reply */
+        assert(bytes_used < ctrl.offset);
+        ctrl.offset -= bytes_used;
+        memmove(ctrl.buf, ctrl.buf + bytes_used, ctrl.offset);
+    }
+
+    debugs(9, 3, "state=" << state << ", code=" << ctrl.replycode);
+}
+
+bool
+Ftp::Client::handlePasvReply(Ip::Address &srvAddr)
+{
+    int code = ctrl.replycode;
+    char *buf;
+    debugs(9, 3, status());
+
+    if (code != 227) {
+        debugs(9, 2, "PASV not supported by remote end");
+        return false;
+    }
+
+    /*  227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).  */
+    /*  ANSI sez [^0-9] is undefined, it breaks on Watcom cc */
+    debugs(9, 5, "scanning: " << ctrl.last_reply);
+
+    buf = ctrl.last_reply + strcspn(ctrl.last_reply, "0123456789");
+
+    const char *forceIp = Config.Ftp.sanitycheck ?
+                          fd_table[ctrl.conn->fd].ipaddr : NULL;
+    if (!Ftp::ParseIpPort(buf, forceIp, srvAddr)) {
+        debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
+               ctrl.conn->remote << ": " << ctrl.last_reply);
+        return false;
+    }
+
+    data.addr(srvAddr);
+
+    return true;
+}
+
+bool
+Ftp::Client::handleEpsvReply(Ip::Address &remoteAddr)
+{
+    int code = ctrl.replycode;
+    char *buf;
+    debugs(9, 3, status());
+
+    if (code != 229 && code != 522) {
+        if (code == 200) {
+            /* handle broken servers (RFC 2428 says OK code for EPSV MUST be 229 not 200) */
+            /* vsftpd for one send '200 EPSV ALL ok.' without even port info.
+             * Its okay to re-send EPSV 1/2 but nothing else. */
+            debugs(9, DBG_IMPORTANT, "Broken FTP Server at " << ctrl.conn->remote << ". Wrong accept code for EPSV");
+        } else {
+            debugs(9, 2, "EPSV not supported by remote end");
+        }
+        return sendPassive();
+    }
+
+    if (code == 522) {
+        /* Peer responded with a list of supported methods:
+         *   522 Network protocol not supported, use (1)
+         *   522 Network protocol not supported, use (1,2)
+         *   522 Network protocol not supported, use (2)
+         * TODO: Handle the (1,2) case which may happen after EPSV ALL. Close
+         * data + control without self-destructing and re-open from scratch.
+         */
+        debugs(9, 5, "scanning: " << ctrl.last_reply);
+        buf = ctrl.last_reply;
+        while (buf != NULL && *buf != '\0' && *buf != '\n' && *buf != '(')
+            ++buf;
+        if (buf != NULL && *buf == '\n')
+            ++buf;
+
+        if (buf == NULL || *buf == '\0') {
+            /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
+            debugs(9, DBG_IMPORTANT, "Broken FTP Server at " << ctrl.conn->remote << ". 522 error missing protocol negotiation hints");
+            return sendPassive();
+        } else if (strcmp(buf, "(1)") == 0) {
+            state = SENT_EPSV_2; /* simulate having sent and failed EPSV 2 */
+            return sendPassive();
+        } else if (strcmp(buf, "(2)") == 0) {
+            if (Ip::EnableIpv6) {
+                /* If server only supports EPSV 2 and we have already tried that. Go straight to EPRT */
+                if (state == SENT_EPSV_2) {
+                    return sendEprt();
+                } else {
+                    /* or try the next Passive mode down the chain. */
+                    return sendPassive();
+                }
+            } else {
+                /* Server only accept EPSV in IPv6 traffic. */
+                state = SENT_EPSV_1; /* simulate having sent and failed EPSV 1 */
+                return sendPassive();
+            }
+        } else {
+            /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
+            debugs(9, DBG_IMPORTANT, "WARNING: Server at " << ctrl.conn->remote << " sent unknown protocol negotiation hint: " << buf);
+            return sendPassive();
+        }
+        failed(ERR_FTP_FAILURE, 0);
+        return false;
+    }
+
+    /*  229 Entering Extended Passive Mode (|||port|) */
+    /*  ANSI sez [^0-9] is undefined, it breaks on Watcom cc */
+    debugs(9, 5, "scanning: " << ctrl.last_reply);
+
+    buf = ctrl.last_reply + strcspn(ctrl.last_reply, "(");
+
+    char h1, h2, h3, h4;
+    unsigned short port;
+    int n = sscanf(buf, "(%c%c%c%hu%c)", &h1, &h2, &h3, &port, &h4);
+
+    if (n < 4 || h1 != h2 || h1 != h3 || h1 != h4) {
+        debugs(9, DBG_IMPORTANT, "Invalid EPSV reply from " <<
+               ctrl.conn->remote << ": " <<
+               ctrl.last_reply);
+
+        return sendPassive();
+    }
+
+    if (0 == port) {
+        debugs(9, DBG_IMPORTANT, "Unsafe EPSV reply from " <<
+               ctrl.conn->remote << ": " <<
+               ctrl.last_reply);
+
+        return sendPassive();
+    }
+
+    if (Config.Ftp.sanitycheck) {
+        if (port < 1024) {
+            debugs(9, DBG_IMPORTANT, "Unsafe EPSV reply from " <<
+                   ctrl.conn->remote << ": " <<
+                   ctrl.last_reply);
+
+            return sendPassive();
+        }
+    }
+
+    remoteAddr = ctrl.conn->remote;
+    remoteAddr.port(port);
+    data.addr(remoteAddr);
+    return true;
+}
+
+// FTP clients do not support EPRT and PORT commands yet.
+// The Ftp::Client::sendEprt() will fail because of the unimplemented
+// openListenSocket() or sendPort() methods
+bool
+Ftp::Client::sendEprt()
+{
+    if (!Config.Ftp.eprt) {
+        /* Disabled. Switch immediately to attempting old PORT command. */
+        debugs(9, 3, "EPRT disabled by local administrator");
+        return sendPort();
+    }
+
+    debugs(9, 3, status());
+
+    if (!openListenSocket()) {
+        failed(ERR_FTP_FAILURE, 0);
+        return false;
+    }
+
+    debugs(9, 3, "Listening for FTP data connection with FD " << data.conn);
+    if (!Comm::IsConnOpen(data.conn)) {
+        // TODO: Set error message.
+        failed(ERR_FTP_FAILURE, 0);
+        return false;
+    }
+
+    static MemBuf mb;
+    mb.reset();
+    char buf[MAX_IPSTRLEN];
+    /* RFC 2428 defines EPRT as IPv6 equivalent to IPv4 PORT command. */
+    /* Which can be used by EITHER protocol. */
+    debugs(9, 3, "Listening for FTP data connection on port" << comm_local_port(data.conn->fd) << " or port?" << data.conn->local.port());
+    mb.Printf("EPRT |%d|%s|%d|%s",
+              ( data.conn->local.isIPv6() ? 2 : 1 ),
+              data.conn->local.toStr(buf,MAX_IPSTRLEN),
+              comm_local_port(data.conn->fd), Ftp::crlf );
+
+    state = SENT_EPRT;
+    writeCommand(mb.content());
+    return true;
+}
+
+bool
+Ftp::Client::sendPort()
+{
+    failed(ERR_FTP_FAILURE, 0);
+    return false;
+}
+
+bool
+Ftp::Client::sendPassive()
+{
+    debugs(9, 3, status());
+
+    /** \par
+      * Checks for EPSV ALL special conditions:
+      * If enabled to be sent, squid MUST NOT request any other connect methods.
+      * If 'ALL' is sent and fails the entire FTP Session fails.
+      * NP: By my reading exact EPSV protocols maybe attempted, but only EPSV method. */
+    if (Config.Ftp.epsv_all && state == SENT_EPSV_1 ) {
+        // We are here because the last "EPSV 1" failed, but because of epsv_all
+        // no other method allowed.
+        debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
+        failed(ERR_FTP_FAILURE, 0);
+        return false;
+    }
+
+    /// Closes any old FTP-Data connection which may exist. */
+    data.close();
+
+    /** \par
+      * Checks for previous EPSV/PASV failures on this server/session.
+      * Diverts to EPRT immediately if they are not working. */
+    if (!Config.Ftp.passive || state == SENT_PASV) {
+        sendEprt();
+        return true;
+    }
+
+    static MemBuf mb;
+    mb.reset();
+    /** \par
+      * Send EPSV (ALL,2,1) or PASV on the control channel.
+      *
+      *  - EPSV ALL  is used if enabled.
+      *  - EPSV 2    is used if ALL is disabled and IPv6 is available and ctrl channel is IPv6.
+      *  - EPSV 1    is used if EPSV 2 (IPv6) fails or is not available or ctrl channel is IPv4.
+      *  - PASV      is used if EPSV 1 fails.
+      */
+    switch (state) {
+    case SENT_EPSV_ALL: /* EPSV ALL resulted in a bad response. Try ther EPSV methods. */
+        if (ctrl.conn->local.isIPv6()) {
+            debugs(9, 5, "FTP Channel is IPv6 (" << ctrl.conn->remote << ") attempting EPSV 2 after EPSV ALL has failed.");
+            mb.Printf("EPSV 2%s", Ftp::crlf);
+            state = SENT_EPSV_2;
+            break;
+        }
+        // else fall through to skip EPSV 2
+
+    case SENT_EPSV_2: /* EPSV IPv6 failed. Try EPSV IPv4 */
+        if (ctrl.conn->local.isIPv4()) {
+            debugs(9, 5, "FTP Channel is IPv4 (" << ctrl.conn->remote << ") attempting EPSV 1 after EPSV ALL has failed.");
+            mb.Printf("EPSV 1%s", Ftp::crlf);
+            state = SENT_EPSV_1;
+            break;
+        } else if (Config.Ftp.epsv_all) {
+            debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
+            failed(ERR_FTP_FAILURE, 0);
+            return false;
+        }
+        // else fall through to skip EPSV 1
+
+    case SENT_EPSV_1: /* EPSV options exhausted. Try PASV now. */
+        debugs(9, 5, "FTP Channel (" << ctrl.conn->remote << ") rejects EPSV connection attempts. Trying PASV instead.");
+        mb.Printf("PASV%s", Ftp::crlf);
+        state = SENT_PASV;
+        break;
+
+    default: {
+        bool doEpsv = true;
+        if (Config.accessList.ftp_epsv) {
+            ACLFilledChecklist checklist(Config.accessList.ftp_epsv, fwd->request, NULL);
+            doEpsv = (checklist.fastCheck() == ACCESS_ALLOWED);
+        }
+        if (!doEpsv) {
+            debugs(9, 5, "EPSV support manually disabled. Sending PASV for FTP Channel (" << ctrl.conn->remote <<")");
+            mb.Printf("PASV%s", Ftp::crlf);
+            state = SENT_PASV;
+        } else if (Config.Ftp.epsv_all) {
+            debugs(9, 5, "EPSV ALL manually enabled. Attempting with FTP Channel (" << ctrl.conn->remote <<")");
+            mb.Printf("EPSV ALL%s", Ftp::crlf);
+            state = SENT_EPSV_ALL;
+        } else {
+            if (ctrl.conn->local.isIPv6()) {
+                debugs(9, 5, "FTP Channel (" << ctrl.conn->remote << "). Sending default EPSV 2");
+                mb.Printf("EPSV 2%s", Ftp::crlf);
+                state = SENT_EPSV_2;
+            }
+            if (ctrl.conn->local.isIPv4()) {
+                debugs(9, 5, "Channel (" << ctrl.conn->remote <<"). Sending default EPSV 1");
+                mb.Printf("EPSV 1%s", Ftp::crlf);
+                state = SENT_EPSV_1;
+            }
+        }
+        break;
+    }
+    }
+
+    if (ctrl.message)
+        wordlistDestroy(&ctrl.message);
+    ctrl.message = NULL; //No message to return to client.
+    ctrl.offset = 0; //reset readed response, to make room read the next response
+
+    writeCommand(mb.content());
+
+    shortenReadTimeout = true;
+    return true;
+}
+
+void
+Ftp::Client::connectDataChannel()
+{
+    safe_free(ctrl.last_command);
+
+    safe_free(ctrl.last_reply);
+
+    ctrl.last_command = xstrdup("Connect to server data port");
+
+    // Generate a new data channel descriptor to be opened.
+    Comm::ConnectionPointer conn = new Comm::Connection;
+    conn->setAddrs(ctrl.conn->local, data.host);
+    conn->local.port(0);
+    conn->remote.port(data.port);
+    conn->tos = ctrl.conn->tos;
+    conn->nfmark = ctrl.conn->nfmark;
+
+    debugs(9, 3, "connecting to " << conn->remote);
+
+    typedef CommCbMemFunT<Client, CommConnectCbParams> Dialer;
+    data.opener = JobCallback(9, 3, Dialer, this, Ftp::Client::dataChannelConnected);
+    Comm::ConnOpener *cs = new Comm::ConnOpener(conn, data.opener, Config.Timeout.connect);
+    cs->setHost(data.host);
+    AsyncJob::Start(cs);
+}
+
+bool
+Ftp::Client::openListenSocket()
+{
+    return false;
+}
+
+/// creates a data channel Comm close callback
+AsyncCall::Pointer
+Ftp::Client::dataCloser()
+{
+    typedef CommCbMemFunT<Client, CommCloseCbParams> Dialer;
+    return JobCallback(9, 5, Dialer, this, Ftp::Client::dataClosed);
+}
+
+/// handler called by Comm when FTP data channel is closed unexpectedly
+void
+Ftp::Client::dataClosed(const CommCloseCbParams &io)
+{
+    debugs(9, 4, status());
+    if (data.listenConn != NULL) {
+        data.listenConn->close();
+        data.listenConn = NULL;
+        // NP clear() does the: data.fd = -1;
+    }
+    data.clear();
+}
+
+void
+Ftp::Client::writeCommand(const char *buf)
+{
+    char *ebuf;
+    /* trace FTP protocol communications at level 2 */
+    debugs(9, 2, "ftp<< " << buf);
+
+    if (Config.Ftp.telnet)
+        ebuf = escapeIAC(buf);
+    else
+        ebuf = xstrdup(buf);
+
+    safe_free(ctrl.last_command);
+
+    safe_free(ctrl.last_reply);
+
+    ctrl.last_command = ebuf;
+
+    if (!Comm::IsConnOpen(ctrl.conn)) {
+        debugs(9, 2, "cannot send to closing ctrl " << ctrl.conn);
+        // TODO: assert(ctrl.closer != NULL);
+        return;
+    }
+
+    typedef CommCbMemFunT<Client, CommIoCbParams> Dialer;
+    AsyncCall::Pointer call = JobCallback(9, 5, Dialer, this,
+                                          Ftp::Client::writeCommandCallback);
+    Comm::Write(ctrl.conn, ctrl.last_command, strlen(ctrl.last_command), call, NULL);
+
+    scheduleReadControlReply(0);
+}
+
+void
+Ftp::Client::writeCommandCallback(const CommIoCbParams &io)
+{
+
+    debugs(9, 5, "wrote " << io.size << " bytes");
+
+    if (io.size > 0) {
+        fd_bytes(io.fd, io.size, FD_WRITE);
+        kb_incr(&(statCounter.server.all.kbytes_out), io.size);
+        kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
+    }
+
+    if (io.flag == Comm::ERR_CLOSING)
+        return;
+
+    if (io.flag) {
+        debugs(9, DBG_IMPORTANT, "FTP command write error: " << io.conn << ": " << xstrerr(io.xerrno));
+        failed(ERR_WRITE_ERROR, io.xerrno);
+        /* failed closes ctrl.conn and frees ftpState */
+        return;
+    }
+}
+
+/// handler called by Comm when FTP control channel is closed unexpectedly
+void
+Ftp::Client::ctrlClosed(const CommCloseCbParams &io)
+{
+    debugs(9, 4, status());
+    ctrl.clear();
+    mustStop("Ftp::Client::ctrlClosed");
+}
+
+void
+Ftp::Client::timeout(const CommTimeoutCbParams &io)
+{
+    debugs(9, 4, io.conn << ": '" << entry->url() << "'" );
+
+    if (abortOnBadEntry("entry went bad while waiting for a timeout"))
+        return;
+
+    failed(ERR_READ_TIMEOUT, 0);
+    /* failed() closes ctrl.conn and frees ftpState */
+}
+
+const Comm::ConnectionPointer &
+Ftp::Client::dataConnection() const
+{
+    return data.conn;
+}
+
+void
+Ftp::Client::maybeReadVirginBody()
+{
+    // too late to read
+    if (!Comm::IsConnOpen(data.conn) || fd_table[data.conn->fd].closing())
+        return;
+
+    if (data.read_pending)
+        return;
+
+    initReadBuf();
+
+    const int read_sz = replyBodySpace(*data.readBuf, 0);
+
+    debugs(9, 9, "FTP may read up to " << read_sz << " bytes");
+
+    if (read_sz < 2) // see http.cc
+        return;
+
+    data.read_pending = true;
+
+    typedef CommCbMemFunT<Client, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
+                                      TimeoutDialer, this, Ftp::Client::timeout);
+    commSetConnTimeout(data.conn, Config.Timeout.read, timeoutCall);
+
+    debugs(9,5,"queueing read on FD " << data.conn->fd);
+
+    typedef CommCbMemFunT<Client, CommIoCbParams> Dialer;
+    entry->delayAwareRead(data.conn, data.readBuf->space(), read_sz,
+                          JobCallback(9, 5, Dialer, this, Ftp::Client::dataRead));
+}
+
+void
+Ftp::Client::dataRead(const CommIoCbParams &io)
+{
+    int j;
+    int bin;
+
+    data.read_pending = false;
+
+    debugs(9, 3, "FD " << io.fd << " Read " << io.size << " bytes");
+
+    if (io.size > 0) {
+        kb_incr(&(statCounter.server.all.kbytes_in), io.size);
+        kb_incr(&(statCounter.server.ftp.kbytes_in), io.size);
+    }
+
+    if (io.flag == Comm::ERR_CLOSING)
+        return;
+
+    assert(io.fd == data.conn->fd);
+
+    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
+        abortTransaction("entry aborted during dataRead");
+        return;
+    }
+
+    if (io.flag == Comm::OK && io.size > 0) {
+        debugs(9, 5, "appended " << io.size << " bytes to readBuf");
+        data.readBuf->appended(io.size);
+#if USE_DELAY_POOLS
+        DelayId delayId = entry->mem_obj->mostBytesAllowed();
+        delayId.bytesIn(io.size);
+#endif
+        ++ IOStats.Ftp.reads;
+
+        for (j = io.size - 1, bin = 0; j; ++bin)
+            j >>= 1;
+
+        ++ IOStats.Ftp.read_hist[bin];
+    }
+
+    if (io.flag != Comm::OK) {
+        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
+               "FTP data read error: " << xstrerr(io.xerrno));
+
+        if (ignoreErrno(io.xerrno)) {
+            maybeReadVirginBody();
+        } else {
+            failed(ERR_READ_ERROR, 0);
+            /* failed closes ctrl.conn and frees ftpState */
+            return;
+        }
+    } else if (io.size == 0) {
+        debugs(9, 3, "Calling dataComplete() because io.size == 0");
+        /*
+         * DPW 2007-04-23
+         * Dangerous curves ahead.  This call to dataComplete was
+         * calling scheduleReadControlReply, handleControlReply,
+         * and then ftpReadTransferDone.  If ftpReadTransferDone
+         * gets unexpected status code, it closes down the control
+         * socket and our FtpStateData object gets destroyed.   As
+         * a workaround we no longer set the 'buffered_ok' flag in
+         * the scheduleReadControlReply call.
+         */
+        dataComplete();
+    }
+
+    processReplyBody();
+}
+
+void
+Ftp::Client::dataComplete()
+{
+    debugs(9, 3,status());
+
+    /* Connection closed; transfer done. */
+
+    /// Close data channel, if any, to conserve resources while we wait.
+    data.close();
+
+    /* expect the "transfer complete" message on the control socket */
+    /*
+     * DPW 2007-04-23
+     * Previously, this was the only place where we set the
+     * 'buffered_ok' flag when calling scheduleReadControlReply().
+     * It caused some problems if the FTP server returns an unexpected
+     * status code after the data command.  FtpStateData was being
+     * deleted in the middle of dataRead().
+     */
+    /* AYJ: 2011-01-13: Bug 2581.
+     * 226 status is possibly waiting in the ctrl buffer.
+     * The connection will hang if we DONT send buffered_ok.
+     * This happens on all transfers which can be completly sent by the
+     * server before the 150 started status message is read in by Squid.
+     * ie all transfers of about one packet hang.
+     */
+    scheduleReadControlReply(1);
+}
+
+/**
+ * Quickly abort the transaction
+ *
+ \todo destruction should be sufficient as the destructor should cleanup,
+ * including canceling close handlers
+ */
+void
+Ftp::Client::abortTransaction(const char *reason)
+{
+    debugs(9, 3, "aborting transaction for " << reason <<
+           "; FD " << (ctrl.conn!=NULL?ctrl.conn->fd:-1) << ", Data FD " << (data.conn!=NULL?data.conn->fd:-1) << ", this " << this);
+    if (Comm::IsConnOpen(ctrl.conn)) {
+        ctrl.conn->close();
+        return;
+    }
+
+    fwd->handleUnregisteredServerEnd();
+    mustStop("Ftp::Client::abortTransaction");
+}
+
+/**
+ * Cancel the timeout on the Control socket and establish one
+ * on the data socket
+ */
+void
+Ftp::Client::switchTimeoutToDataChannel()
+{
+    commUnsetConnTimeout(ctrl.conn);
+
+    typedef CommCbMemFunT<Client, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall = JobCallback(9, 5, TimeoutDialer, this,
+                                     Ftp::Client::timeout);
+    commSetConnTimeout(data.conn, Config.Timeout.read, timeoutCall);
+}
+
+void
+Ftp::Client::sentRequestBody(const CommIoCbParams &io)
+{
+    if (io.size > 0)
+        kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
+    ::ServerStateData::sentRequestBody(io);
+}
+
+/**
+ * called after we wrote the last byte of the request body
+ */
+void
+Ftp::Client::doneSendingRequestBody()
+{
+    ::ServerStateData::doneSendingRequestBody();
+    debugs(9, 3, status());
+    dataComplete();
+    /* NP: RFC 959  3.3.  DATA CONNECTION MANAGEMENT
+     * if transfer type is 'stream' call dataComplete()
+     * otherwise leave open. (reschedule control channel read?)
+     */
+}
+
+/// Parses FTP server control response into ctrl structure fields,
+/// setting bytesUsed and returning true on success.
+bool
+Ftp::Client::parseControlReply(size_t &bytesUsed)
+{
+    char *s;
+    char *sbuf;
+    char *end;
+    int usable;
+    int complete = 0;
+    wordlist *head = NULL;
+    wordlist *list;
+    wordlist **tail = &head;
+    size_t linelen;
+    debugs(9, 3, status());
+    /*
+     * We need a NULL-terminated buffer for scanning, ick
+     */
+    const size_t len = ctrl.offset;
+    sbuf = (char *)xmalloc(len + 1);
+    xstrncpy(sbuf, ctrl.buf, len + 1);
+    end = sbuf + len - 1;
+
+    while (*end != '\r' && *end != '\n' && end > sbuf)
+        --end;
+
+    usable = end - sbuf;
+
+    debugs(9, 3, "usable = " << usable);
+
+    if (usable == 0) {
+        debugs(9, 3, "didn't find end of line");
+        safe_free(sbuf);
+        return false;
+    }
+
+    debugs(9, 3, len << " bytes to play with");
+    ++end;
+    s = sbuf;
+    s += strspn(s, crlf);
+
+    for (; s < end; s += strcspn(s, crlf), s += strspn(s, crlf)) {
+        if (complete)
+            break;
+
+        debugs(9, 5, "s = {" << s << "}");
+
+        linelen = strcspn(s, crlf) + 1;
+
+        if (linelen < 2)
+            break;
+
+        if (linelen > 3)
+            complete = (*s >= '0' && *s <= '9' && *(s + 3) == ' ');
+
+        list = new wordlist();
+
+        list->key = (char *)xmalloc(linelen);
+
+        xstrncpy(list->key, s, linelen);
+
+        /* trace the FTP communication chat at level 2 */
+        debugs(9, 2, "ftp>> " << list->key);
+
+        if (complete) {
+            // use list->key for last_reply because s contains the new line
+            ctrl.last_reply = xstrdup(list->key + 4);
+            ctrl.replycode = atoi(list->key);
+        }
+
+        *tail = list;
+
+        tail = &list->next;
+    }
+
+    bytesUsed = static_cast<size_t>(s - sbuf);
+    safe_free(sbuf);
+
+    if (!complete) {
+        wordlistDestroy(&head);
+        return false;
+    }
+
+    ctrl.message = head;
+    assert(ctrl.replycode >= 0);
+    assert(ctrl.last_reply);
+    assert(ctrl.message);
+    return true;
+}
+
+}; // namespace Ftp
@@ -0,0 +1,193 @@
+/*
+ * DEBUG: section 09    File Transfer Protocol (FTP)
+ *
+ */
+
+#ifndef SQUID_FTP_CLIENT_H
+#define SQUID_FTP_CLIENT_H
+
+#include "Server.h"
+
+class String;
+namespace Ftp
+{
+
+extern const char *const crlf;
+
+/// Common code for FTP server control and data channels.
+/// Does not own the channel descriptor, which is managed by Ftp::Client.
+class Channel
+{
+public:
+    /// called after the socket is opened, sets up close handler
+    void opened(const Comm::ConnectionPointer &conn, const AsyncCall::Pointer &aCloser);
+
+    /** Handles all operations needed to properly close the active channel FD.
+     * clearing the close handler, clearing the listen socket properly, and calling comm_close
+     */
+    void close();
+
+    void forget(); /// remove the close handler, leave connection open
+
+    void clear(); ///< just drops conn and close handler. does not close active connections.
+
+    Comm::ConnectionPointer conn; ///< channel descriptor
+
+    /** A temporary handle to the connection being listened on.
+     * Closing this will also close the waiting Data channel acceptor.
+     * If a data connection has already been accepted but is still waiting in the event queue
+     * the callback will still happen and needs to be handled (usually dropped).
+     */
+    Comm::ConnectionPointer listenConn;
+
+    AsyncCall::Pointer opener; ///< Comm opener handler callback.
+private:
+    AsyncCall::Pointer closer; ///< Comm close handler callback
+};
+
+/// FTP channel for control commands.
+/// This channel is opened once per transaction.
+class CtrlChannel: public Ftp::Channel
+{
+public:
+    CtrlChannel();
+    ~CtrlChannel();
+
+    char *buf;
+    size_t size;
+    size_t offset;
+    wordlist *message;
+    char *last_command;
+    char *last_reply;
+    int replycode;
+
+private:
+    CtrlChannel(const CtrlChannel &); // not implemented
+    CtrlChannel &operator =(const CtrlChannel &); // not implemented
+};
+
+/// FTP channel for data exchanges.
+/// This channel may be opened/closed a few times.
+class DataChannel: public Ftp::Channel
+{
+public:
+    DataChannel();
+    ~DataChannel();
+
+    void addr(const Ip::Address &addr); ///< import host and port
+
+public:
+    MemBuf *readBuf;
+    char *host;
+    unsigned short port;
+    bool read_pending;
+};
+
+/// FTP client functionality shared among FTP Gateway and Relay clients.
+class Client: public ::ServerStateData
+{
+public:
+    explicit Client(FwdState *fwdState);
+    virtual ~Client();
+
+    /// handle a fatal transaction error, closing the control connection
+    virtual void failed(err_type error = ERR_NONE, int xerrno = 0);
+
+    /// read timeout handler
+    virtual void timeout(const CommTimeoutCbParams &io);
+
+    /* ServerStateData API */
+    virtual void maybeReadVirginBody();
+
+    void writeCommand(const char *buf);
+
+    /// extracts remoteAddr from PASV response, validates it,
+    /// sets data address details, and returns true on success
+    bool handlePasvReply(Ip::Address &remoteAddr);
+    bool handleEpsvReply(Ip::Address &remoteAddr);
+
+    bool sendEprt();
+    bool sendPort();
+    bool sendPassive();
+    void connectDataChannel();
+    bool openListenSocket();
+    void switchTimeoutToDataChannel();
+
+    CtrlChannel ctrl; ///< FTP control channel state
+    DataChannel data; ///< FTP data channel state
+
+    enum {
+        BEGIN,
+        SENT_USER,
+        SENT_PASS,
+        SENT_TYPE,
+        SENT_MDTM,
+        SENT_SIZE,
+        SENT_EPRT,
+        SENT_PORT,
+        SENT_EPSV_ALL,
+        SENT_EPSV_1,
+        SENT_EPSV_2,
+        SENT_PASV,
+        SENT_CWD,
+        SENT_LIST,
+        SENT_NLST,
+        SENT_REST,
+        SENT_RETR,
+        SENT_STOR,
+        SENT_QUIT,
+        READING_DATA,
+        WRITING_DATA,
+        SENT_MKDIR,
+        SENT_FEAT,
+        SENT_PWD,
+        SENT_CDUP,
+        SENT_DATA_REQUEST, // LIST, NLST or RETR requests..
+        SENT_COMMAND, // General command
+        END
+    } ftp_state_t;
+
+    int state;
+    char *old_request;
+    char *old_reply;
+
+protected:
+    /* AsyncJob API */
+    virtual void start();
+
+    /* ServerStateData API */
+    virtual void closeServer();
+    virtual bool doneWithServer() const;
+    virtual const Comm::ConnectionPointer & dataConnection() const;
+    virtual void abortTransaction(const char *reason);
+
+    virtual Http::StatusCode failedHttpStatus(err_type &error);
+    void ctrlClosed(const CommCloseCbParams &io);
+    void scheduleReadControlReply(int buffered_ok);
+    void readControlReply(const CommIoCbParams &io);
+    virtual void handleControlReply();
+    void writeCommandCallback(const CommIoCbParams &io);
+    virtual void dataChannelConnected(const CommConnectCbParams &io) = 0;
+    void dataRead(const CommIoCbParams &io);
+    void dataComplete();
+    AsyncCall::Pointer dataCloser();
+    virtual void dataClosed(const CommCloseCbParams &io);
+    void initReadBuf();
+
+    // sending of the request body to the server
+    virtual void sentRequestBody(const CommIoCbParams &io);
+    virtual void doneSendingRequestBody();
+
+private:
+    bool parseControlReply(size_t &bytesUsed);
+
+    /// XXX: An old hack for FTP servers like ftp.netscape.com that may not
+    /// respond to PASV. Use faster connect timeout instead of read timeout.
+    bool shortenReadTimeout;
+
+    CBDATA_CLASS2(Client);
+};
+
+} // namespace Ftp
+
+#endif /* SQUID_FTP_CLIENT_H */
@@ -32,11 +32,12 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
+#include "clients/forward.h"
+#include "clients/FtpClient.h"
 #include "comm.h"
 #include "comm/ConnOpener.h"
 #include "comm/Read.h"
 #include "comm/TcpAcceptor.h"
-#include "comm/Write.h"
 #include "CommCalls.h"
 #include "compat/strtoll.h"
 #include "errorpage.h"
@@ -71,46 +72,10 @@
 
 #include <cerrno>
 
-/**
- \defgroup ServerProtocolFTPInternal Server-Side FTP Internals
- \ingroup ServerProtocolFTPAPI
- */
-
-/// \ingroup ServerProtocolFTPInternal
-static const char *const crlf = "\r\n";
-
-#define CTRL_BUFLEN 1024
-/// \ingroup ServerProtocolFTPInternal
-static char cbuf[CTRL_BUFLEN];
+namespace Ftp
+{
 
-/// \ingroup ServerProtocolFTPInternal
-typedef enum {
-    BEGIN,
-    SENT_USER,
-    SENT_PASS,
-    SENT_TYPE,
-    SENT_MDTM,
-    SENT_SIZE,
-    SENT_EPRT,
-    SENT_PORT,
-    SENT_EPSV_ALL,
-    SENT_EPSV_1,
-    SENT_EPSV_2,
-    SENT_PASV,
-    SENT_CWD,
-    SENT_LIST,
-    SENT_NLST,
-    SENT_REST,
-    SENT_RETR,
-    SENT_STOR,
-    SENT_QUIT,
-    READING_DATA,
-    WRITING_DATA,
-    SENT_MKDIR
-} ftp_state_t;
-
-/// \ingroup ServerProtocolFTPInternal
-struct _ftp_flags {
+struct GatewayFlags {
 
     /* passive mode */
     bool pasv_supported;  ///< PASV command is allowed
@@ -142,48 +107,17 @@ struct _ftp_flags {
     bool completed_forwarding;
 };
 
-class FtpStateData;
-
-/// \ingroup ServerProtocolFTPInternal
-typedef void (FTPSM) (FtpStateData *);
-
-/// common code for FTP control and data channels
-/// does not own the channel descriptor, which is managed by FtpStateData
-class FtpChannel
-{
-public:
-    FtpChannel() {};
-
-    /// called after the socket is opened, sets up close handler
-    void opened(const Comm::ConnectionPointer &conn, const AsyncCall::Pointer &aCloser);
-
-    /** Handles all operations needed to properly close the active channel FD.
-     * clearing the close handler, clearing the listen socket properly, and calling comm_close
-     */
-    void close();
-
-    void clear(); ///< just drops conn and close handler. does not close active connections.
-
-    Comm::ConnectionPointer conn; ///< channel descriptor
+class Gateway;
+typedef void (StateMethod)(Ftp::Gateway *);
 
-    /** A temporary handle to the connection being listened on.
-     * Closing this will also close the waiting Data channel acceptor.
-     * If a data connection has already been accepted but is still waiting in the event queue
-     * the callback will still happen and needs to be handled (usually dropped).
-     */
-    Comm::ConnectionPointer listenConn;
-
-    AsyncCall::Pointer opener; ///< Comm opener handler callback.
-private:
-    AsyncCall::Pointer closer; ///< Comm close handler callback
-};
-
-/// \ingroup ServerProtocolFTPInternal
-class FtpStateData : public ServerStateData
+/// FTP Gateway: An FTP client that takes an HTTP request with an ftp:// URI,
+/// converts it into one or more FTP commands, and then
+/// converts one or more FTP responses into the final HTTP response.
+class Gateway : public Ftp::Client
 {
 public:
-    FtpStateData(FwdState *, const Comm::ConnectionPointer &conn);
-    ~FtpStateData();
+    Gateway(FwdState *);
+    virtual ~Gateway();
     char user[MAX_URL];
     char password[MAX_URL];
     int password_url;
@@ -194,7 +128,6 @@ class FtpStateData : public ServerStateData
     String base_href;
     int conn_att;
     int login_att;
-    ftp_state_t state;
     time_t mdtm;
     int64_t theSize;
     wordlist *pathcomps;
@@ -204,109 +137,71 @@ class FtpStateData : public ServerStateData
     char *proxy_host;
     size_t list_width;
     String cwd_message;
-    char *old_request;
-    char *old_reply;
     char *old_filepath;
     char typecode;
     MemBuf listing;		///< FTP directory listing in HTML format.
 
-    // \todo: optimize ctrl and data structs member order, to minimize size
-    /// FTP control channel info; the channel is opened once per transaction
-    struct CtrlChannel: public FtpChannel {
-        char *buf;
-        size_t size;
-        size_t offset;
-        wordlist *message;
-        char *last_command;
-        char *last_reply;
-        int replycode;
-    } ctrl;
-
-    /// FTP data channel info; the channel may be opened/closed a few times
-    struct DataChannel: public FtpChannel {
-        MemBuf *readBuf;
-        char *host;
-        unsigned short port;
-        bool read_pending;
-    } data;
-
-    struct _ftp_flags flags;
+    GatewayFlags flags;
 
 public:
     // these should all be private
     virtual void start();
+    virtual Http::StatusCode failedHttpStatus(err_type &error);
     void loginParser(const char *, int escaped);
     int restartable();
     void appendSuccessHeader();
-    void hackShortcut(FTPSM * nextState);
-    void failed(err_type, int xerrno);
-    void failedErrorMessage(err_type, int xerrno);
+    void hackShortcut(StateMethod *nextState);
     void unhack();
-    void scheduleReadControlReply(int);
-    void handleControlReply();
     void readStor();
     void parseListing();
     MemBuf *htmlifyListEntry(const char *line);
     void completedListing(void);
-    void dataComplete();
-    void dataRead(const CommIoCbParams &io);
 
-    /// ignore timeout on CTRL channel. set read timeout on DATA channel.
-    void switchTimeoutToDataChannel();
     /// create a data channel acceptor and start listening.
-    void listenForDataChannel(const Comm::ConnectionPointer &conn, const char *note);
+    void listenForDataChannel(const Comm::ConnectionPointer &conn);
 
     int checkAuth(const HttpHeader * req_hdr);
     void checkUrlpath();
     void buildTitleUrl();
     void writeReplyBody(const char *, size_t len);
     void printfReplyBody(const char *fmt, ...);
-    virtual const Comm::ConnectionPointer & dataConnection() const;
-    virtual void maybeReadVirginBody();
-    virtual void closeServer();
     virtual void completeForwarding();
-    virtual void abortTransaction(const char *reason);
     void processHeadResponse();
     void processReplyBody();
-    void writeCommand(const char *buf);
     void setCurrentOffset(int64_t offset) { currentOffset = offset; }
     int64_t getCurrentOffset() const { return currentOffset; }
 
-    static CNCB ftpPasvCallback;
+    virtual void dataChannelConnected(const CommConnectCbParams &io);
     static PF ftpDataWrite;
-    void ftpTimeout(const CommTimeoutCbParams &io);
-    void ctrlClosed(const CommCloseCbParams &io);
-    void dataClosed(const CommCloseCbParams &io);
-    void ftpReadControlReply(const CommIoCbParams &io);
-    void ftpWriteCommandCallback(const CommIoCbParams &io);
+    virtual void timeout(const CommTimeoutCbParams &io);
     void ftpAcceptDataConnection(const CommAcceptCbParams &io);
 
     static HttpReply *ftpAuthRequired(HttpRequest * request, const char *realm);
     const char *ftpRealm(void);
     void loginFailed(void);
-    static wordlist *ftpParseControlReply(char *, size_t, int *, size_t *);
-
-    // sending of the request body to the server
-    virtual void sentRequestBody(const CommIoCbParams&);
-    virtual void doneSendingRequestBody();
 
     virtual void haveParsedReplyHeaders();
 
-    virtual bool doneWithServer() const;
     virtual bool haveControlChannel(const char *caller_name) const;
-    AsyncCall::Pointer dataCloser(); /// creates a Comm close callback
-    AsyncCall::Pointer dataOpener(); /// creates a Comm connect callback
+
+protected:
+    virtual void handleControlReply();
+    virtual void dataClosed(const CommCloseCbParams &io);
 
 private:
+    virtual bool mayReadVirginReplyBody() const;
     // BodyConsumer for HTTP: consume request body.
     virtual void handleRequestBodyProducerAborted();
 
-    CBDATA_CLASS2(FtpStateData);
+    CBDATA_CLASS2(Gateway);
 };
 
-CBDATA_CLASS_INIT(FtpStateData);
+} // namespace Ftp
+
+typedef Ftp::StateMethod FTPSM; // to avoid lots of non-changes
+
+CBDATA_NAMESPACED_CLASS_INIT(Ftp, Gateway);
 
-/// \ingroup ServerProtocolFTPInternal
 typedef struct {
     char type;
     int64_t size;
@@ -316,12 +211,13 @@ typedef struct {
     char *link;
 } ftpListParts;
 
-/// \ingroup ServerProtocolFTPInternal
 #define FTP_LOGIN_ESCAPED	1
 
-/// \ingroup ServerProtocolFTPInternal
 #define FTP_LOGIN_NOT_ESCAPED	0
 
+#define CTRL_BUFLEN 1024
+static char cbuf[CTRL_BUFLEN];
+
 /*
  * State machine functions
  * send == state transition
@@ -412,7 +308,6 @@ DataTransferDone	Quit
 Quit			-
 ************************************************/
 
-/// \ingroup ServerProtocolFTPInternal
 FTPSM *FTP_SM_FUNCS[] = {
     ftpReadWelcome,		/* BEGIN */
     ftpReadUser,		/* SENT_USER */
@@ -435,29 +330,19 @@ FTPSM *FTP_SM_FUNCS[] = {
     ftpReadQuit,		/* SENT_QUIT */
     ftpReadTransferDone,	/* READING_DATA (RETR,LIST,NLST) */
     ftpWriteTransferDone,	/* WRITING_DATA (STOR) */
-    ftpReadMkdir		/* SENT_MKDIR */
+    ftpReadMkdir,		/* SENT_MKDIR */
+    NULL,			/* SENT_FEAT */
+    NULL,			/* SENT_PWD */
+    NULL,			/* SENT_CDUP*/
+    NULL,			/* SENT_DATA_REQUEST */
+    NULL			/* SENT_COMMAND */
 };
 
-/// handler called by Comm when FTP control channel is closed unexpectedly
-void
-FtpStateData::ctrlClosed(const CommCloseCbParams &io)
-{
-    debugs(9, 4, HERE);
-    ctrl.clear();
-    mustStop("FtpStateData::ctrlClosed");
-}
-
 /// handler called by Comm when FTP data channel is closed unexpectedly
 void
-FtpStateData::dataClosed(const CommCloseCbParams &io)
+Ftp::Gateway::dataClosed(const CommCloseCbParams &io)
 {
-    debugs(9, 4, HERE);
-    if (data.listenConn != NULL) {
-        data.listenConn->close();
-        data.listenConn = NULL;
-        // NP clear() does the: data.fd = -1;
-    }
-    data.clear();
+    Ftp::Client::dataClosed(io);
     failed(ERR_FTP_FAILURE, 0);
     /* failed closes ctrl.conn and frees ftpState */
 
@@ -467,12 +352,12 @@ FtpStateData::dataClosed(const CommCloseCbParams &io)
      */
 }
 
-FtpStateData::FtpStateData(FwdState *theFwdState, const Comm::ConnectionPointer &conn) : AsyncJob("FtpStateData"), ServerStateData(theFwdState)
+Ftp::Gateway::Gateway(FwdState *fwdState):
+        AsyncJob("FtpStateData"),
+        Ftp::Client(fwdState)
 {
     const char *url = entry->url();
     debugs(9, 3, HERE << "'" << url << "'" );
-    ++ statCounter.server.all.requests;
-    ++ statCounter.server.ftp.requests;
     theSize = -1;
     mdtm = -1;
 
@@ -481,62 +366,31 @@ FtpStateData::FtpStateData(FwdState *theFwdState, const Comm::ConnectionPointer
 
     flags.rest_supported = 1;
 
-    typedef CommCbMemFunT<FtpStateData, CommCloseCbParams> Dialer;
-    AsyncCall::Pointer closer = JobCallback(9, 5, Dialer, this, FtpStateData::ctrlClosed);
-    ctrl.opened(conn, closer);
-
     if (request->method == Http::METHOD_PUT)
         flags.put = 1;
+
+    initReadBuf();
 }
 
-FtpStateData::~FtpStateData()
+Ftp::Gateway::~Gateway()
 {
     debugs(9, 3, HERE << entry->url()  );
 
-    if (reply_hdr) {
-        memFree(reply_hdr, MEM_8K_BUF);
-        reply_hdr = NULL;
-    }
-
-    if (data.opener != NULL) {
-        data.opener->cancel("FtpStateData destructed");
-        data.opener = NULL;
-    }
-    data.close();
-
     if (Comm::IsConnOpen(ctrl.conn)) {
-        debugs(9, DBG_IMPORTANT, HERE << "Internal bug: FtpStateData left " <<
-               "open control channel " << ctrl.conn);
-    }
-
-    if (ctrl.buf) {
-        memFreeBuf(ctrl.size, ctrl.buf);
-        ctrl.buf = NULL;
+        debugs(9, DBG_IMPORTANT, "Internal bug: FTP Gateway left open " <<
+               "control channel " << ctrl.conn);
     }
 
-    if (data.readBuf) {
-        if (!data.readBuf->isNull())
-            data.readBuf->clean();
-
-        delete data.readBuf;
+    if (reply_hdr) {
+        memFree(reply_hdr, MEM_8K_BUF);
+        reply_hdr = NULL;
     }
 
     if (pathcomps)
         wordlistDestroy(&pathcomps);
 
-    if (ctrl.message)
-        wordlistDestroy(&ctrl.message);
-
     cwd_message.clean();
 
-    safe_free(ctrl.last_reply);
-
-    safe_free(ctrl.last_command);
-
-    safe_free(old_request);
-
-    safe_free(old_reply);
-
     safe_free(old_filepath);
 
     title_url.clean();
@@ -546,18 +400,14 @@ FtpStateData::~FtpStateData()
     safe_free(filepath);
 
     safe_free(dirpath);
-
-    safe_free(data.host);
-
-    fwd = NULL;	// refcounted
 }
 
 /**
  * Parse a possible login username:password pair.
  * Produces filled member variables user, password, password_url if anything found.
  */
 void
-FtpStateData::loginParser(const char *login, int escaped)
+Ftp::Gateway::loginParser(const char *login, int escaped)
 {
     const char *u = NULL; // end of the username sub-string
     int len;              // length of the current sub-string to handle.
@@ -609,29 +459,16 @@ FtpStateData::loginParser(const char *login, int escaped)
     debugs(9, 9, HERE << ": OUT: login='" << login << "', escaped=" << escaped << ", user=" << user << ", password=" << password);
 }
 
-/**
- * Cancel the timeout on the Control socket and establish one
- * on the data socket
- */
 void
-FtpStateData::switchTimeoutToDataChannel()
-{
-    commUnsetConnTimeout(ctrl.conn);
-
-    typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-    AsyncCall::Pointer timeoutCall = JobCallback(9, 5, TimeoutDialer, this, FtpStateData::ftpTimeout);
-    commSetConnTimeout(data.conn, Config.Timeout.read, timeoutCall);
-}
-
-void
-FtpStateData::listenForDataChannel(const Comm::ConnectionPointer &conn, const char *note)
+Ftp::Gateway::listenForDataChannel(const Comm::ConnectionPointer &conn)
 {
     assert(!Comm::IsConnOpen(data.conn));
 
-    typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> AcceptDialer;
+    typedef CommCbMemFunT<Gateway, CommAcceptCbParams> AcceptDialer;
     typedef AsyncCallT<AcceptDialer> AcceptCall;
-    RefCount<AcceptCall> call = static_cast<AcceptCall*>(JobCallback(11, 5, AcceptDialer, this, FtpStateData::ftpAcceptDataConnection));
+    RefCount<AcceptCall> call = static_cast<AcceptCall*>(JobCallback(11, 5, AcceptDialer, this, Ftp::Gateway::ftpAcceptDataConnection));
     Subscription::Pointer sub = new CallSubscription<AcceptCall>(call);
+    const char *note = entry->url();
 
     /* open the conn if its not already open */
     if (!Comm::IsConnOpen(conn)) {
@@ -655,17 +492,12 @@ FtpStateData::listenForDataChannel(const Comm::ConnectionPointer &conn, const ch
 }
 
 void
-FtpStateData::ftpTimeout(const CommTimeoutCbParams &io)
+Ftp::Gateway::timeout(const CommTimeoutCbParams &io)
 {
-    debugs(9, 4, HERE << io.conn << ": '" << entry->url() << "'" );
-
-    if (abortOnBadEntry("entry went bad while waiting for a timeout"))
-        return;
-
     if (SENT_PASV == state) {
         /* stupid ftp.netscape.com, of FTP server behind stupid firewall rules */
         flags.pasv_supported = false;
-        debugs(9, DBG_IMPORTANT, "ftpTimeout: timeout in SENT_PASV state" );
+        debugs(9, DBG_IMPORTANT, "FTP Gateway timeout in SENT_PASV state");
 
         // cancel the data connection setup.
         if (data.opener != NULL) {
@@ -675,17 +507,14 @@ FtpStateData::ftpTimeout(const CommTimeoutCbParams &io)
         data.close();
     }
 
-    failed(ERR_READ_TIMEOUT, 0);
-    /* failed() closes ctrl.conn and frees ftpState */
+    Ftp::Client::timeout(io);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static const char *Month[] = {
     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
 };
 
-/// \ingroup ServerProtocolFTPInternal
 static int
 is_month(const char *buf)
 {
@@ -698,7 +527,6 @@ is_month(const char *buf)
     return 0;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
 ftpListPartsFree(ftpListParts ** parts)
 {
@@ -709,12 +537,10 @@ ftpListPartsFree(ftpListParts ** parts)
     safe_free(*parts);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 #define MAX_TOKENS 64
 
-/// \ingroup ServerProtocolFTPInternal
 static ftpListParts *
-ftpListParseParts(const char *buf, struct _ftp_flags flags)
+ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
 {
     ftpListParts *p = NULL;
     char *t = NULL;
@@ -944,7 +770,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
 }
 
 MemBuf *
-FtpStateData::htmlifyListEntry(const char *line)
+Ftp::Gateway::htmlifyListEntry(const char *line)
 {
     char icon[2048];
     char href[2048 + 40];
@@ -1081,7 +907,7 @@ FtpStateData::htmlifyListEntry(const char *line)
 }
 
 void
-FtpStateData::parseListing()
+Ftp::Gateway::parseListing()
 {
     char *buf = data.readBuf->content();
     char *sbuf;			/* NULL-terminated copy of termedBuf */
@@ -1163,150 +989,10 @@ FtpStateData::parseListing()
     xfree(sbuf);
 }
 
-const Comm::ConnectionPointer &
-FtpStateData::dataConnection() const
-{
-    return data.conn;
-}
-
-void
-FtpStateData::dataComplete()
-{
-    debugs(9, 3,HERE);
-
-    /* Connection closed; transfer done. */
-
-    /// Close data channel, if any, to conserve resources while we wait.
-    data.close();
-
-    /* expect the "transfer complete" message on the control socket */
-    /*
-     * DPW 2007-04-23
-     * Previously, this was the only place where we set the
-     * 'buffered_ok' flag when calling scheduleReadControlReply().
-     * It caused some problems if the FTP server returns an unexpected
-     * status code after the data command.  FtpStateData was being
-     * deleted in the middle of dataRead().
-     */
-    /* AYJ: 2011-01-13: Bug 2581.
-     * 226 status is possibly waiting in the ctrl buffer.
-     * The connection will hang if we DONT send buffered_ok.
-     * This happens on all transfers which can be completly sent by the
-     * server before the 150 started status message is read in by Squid.
-     * ie all transfers of about one packet hang.
-     */
-    scheduleReadControlReply(1);
-}
-
-void
-FtpStateData::maybeReadVirginBody()
-{
-    // too late to read
-    if (!Comm::IsConnOpen(data.conn) || fd_table[data.conn->fd].closing())
-        return;
-
-    if (data.read_pending)
-        return;
-
-    const int read_sz = replyBodySpace(*data.readBuf, 0);
-
-    debugs(11,9, HERE << "FTP may read up to " << read_sz << " bytes");
-
-    if (read_sz < 2)	// see http.cc
-        return;
-
-    data.read_pending = true;
-
-    typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-    AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
-                                      TimeoutDialer, this, FtpStateData::ftpTimeout);
-    commSetConnTimeout(data.conn, Config.Timeout.read, timeoutCall);
-
-    debugs(9,5,HERE << "queueing read on FD " << data.conn->fd);
-
-    typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
-    entry->delayAwareRead(data.conn, data.readBuf->space(), read_sz,
-                          JobCallback(9, 5, Dialer, this, FtpStateData::dataRead));
-}
-
-void
-FtpStateData::dataRead(const CommIoCbParams &io)
-{
-    int j;
-    int bin;
-
-    data.read_pending = false;
-
-    debugs(9, 3, HERE << "ftpDataRead: FD " << io.fd << " Read " << io.size << " bytes");
-
-    if (io.size > 0) {
-        kb_incr(&(statCounter.server.all.kbytes_in), io.size);
-        kb_incr(&(statCounter.server.ftp.kbytes_in), io.size);
-    }
-
-    if (io.flag == Comm::ERR_CLOSING)
-        return;
-
-    assert(io.fd == data.conn->fd);
-
-    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
-        abortTransaction("entry aborted during dataRead");
-        return;
-    }
-
-    if (io.flag == Comm::OK && io.size > 0) {
-        debugs(9,5,HERE << "appended " << io.size << " bytes to readBuf");
-        data.readBuf->appended(io.size);
-#if USE_DELAY_POOLS
-        DelayId delayId = entry->mem_obj->mostBytesAllowed();
-        delayId.bytesIn(io.size);
-#endif
-        ++ IOStats.Ftp.reads;
-
-        for (j = io.size - 1, bin = 0; j; ++bin)
-            j >>= 1;
-
-        ++ IOStats.Ftp.read_hist[bin];
-    }
-
-    if (io.flag != Comm::OK) {
-        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
-               "ftpDataRead: read error: " << xstrerr(io.xerrno));
-
-        if (ignoreErrno(io.xerrno)) {
-            typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-            AsyncCall::Pointer timeoutCall = JobCallback(9, 5,
-                                             TimeoutDialer, this, FtpStateData::ftpTimeout);
-            commSetConnTimeout(io.conn, Config.Timeout.read, timeoutCall);
-
-            maybeReadVirginBody();
-        } else {
-            failed(ERR_READ_ERROR, 0);
-            /* failed closes ctrl.conn and frees ftpState */
-            return;
-        }
-    } else if (io.size == 0) {
-        debugs(9,3, HERE << "Calling dataComplete() because io.size == 0");
-        /*
-         * DPW 2007-04-23
-         * Dangerous curves ahead.  This call to dataComplete was
-         * calling scheduleReadControlReply, handleControlReply,
-         * and then ftpReadTransferDone.  If ftpReadTransferDone
-         * gets unexpected status code, it closes down the control
-         * socket and our FtpStateData object gets destroyed.   As
-         * a workaround we no longer set the 'buffered_ok' flag in
-         * the scheduleReadControlReply call.
-         */
-        dataComplete();
-    }
-
-    processReplyBody();
-}
-
 void
-FtpStateData::processReplyBody()
+Ftp::Gateway::processReplyBody()
 {
-    debugs(9, 3, HERE << "FtpStateData::processReplyBody starting.");
+    debugs(9, 3, status());
 
     if (request->method == Http::METHOD_HEAD && (flags.isdir || theSize != -1)) {
         serverComplete();
@@ -1329,7 +1015,7 @@ FtpStateData::processReplyBody()
 #if USE_ADAPTATION
 
     if (adaptationAccessCheckPending) {
-        debugs(9,3, HERE << "returning from FtpStateData::processReplyBody due to adaptationAccessCheckPending");
+        debugs(9, 3, "returning from Ftp::Gateway::processReplyBody due to adaptationAccessCheckPending");
         return;
     }
 
@@ -1371,7 +1057,7 @@ FtpStateData::processReplyBody()
  \retval 0	if something is missing.
  */
 int
-FtpStateData::checkAuth(const HttpHeader * req_hdr)
+Ftp::Gateway::checkAuth(const HttpHeader * req_hdr)
 {
     /* default username */
     xstrncpy(user, "anonymous", MAX_URL);
@@ -1416,7 +1102,7 @@ FtpStateData::checkAuth(const HttpHeader * req_hdr)
 
 static String str_type_eq;
 void
-FtpStateData::checkUrlpath()
+Ftp::Gateway::checkUrlpath()
 {
     int l;
     size_t t;
@@ -1454,7 +1140,7 @@ FtpStateData::checkUrlpath()
 }
 
 void
-FtpStateData::buildTitleUrl()
+Ftp::Gateway::buildTitleUrl()
 {
     title_url = "ftp://";
 
@@ -1496,15 +1182,8 @@ FtpStateData::buildTitleUrl()
     base_href.append("/");
 }
 
-/// \ingroup ServerProtocolFTPAPI
-void
-ftpStart(FwdState * fwd)
-{
-    AsyncJob::Start(new FtpStateData(fwd, fwd->serverConnection()));
-}
-
 void
-FtpStateData::start()
+Ftp::Gateway::start()
 {
     if (!checkAuth(&request->header)) {
         /* create appropriate reply */
@@ -1518,334 +1197,34 @@ FtpStateData::start()
     buildTitleUrl();
     debugs(9, 5, HERE << "FD " << ctrl.conn->fd << " : host=" << request->GetHost() <<
            ", path=" << request->urlpath << ", user=" << user << ", passwd=" << password);
-
     state = BEGIN;
-    ctrl.last_command = xstrdup("Connect to server");
-    ctrl.buf = (char *)memAllocBuf(4096, &ctrl.size);
-    ctrl.offset = 0;
-    data.readBuf = new MemBuf;
-    data.readBuf->init(4096, SQUID_TCP_SO_RCVBUF);
-    scheduleReadControlReply(0);
+    Ftp::Client::start();
 }
 
 /* ====================================================================== */
 
-/// \ingroup ServerProtocolFTPInternal
-static char *
-escapeIAC(const char *buf)
-{
-    int n;
-    char *ret;
-    unsigned const char *p;
-    unsigned char *r;
-
-    for (p = (unsigned const char *)buf, n = 1; *p; ++n, ++p)
-        if (*p == 255)
-            ++n;
-
-    ret = (char *)xmalloc(n);
-
-    for (p = (unsigned const char *)buf, r=(unsigned char *)ret; *p; ++p) {
-        *r = *p;
-        ++r;
-
-        if (*p == 255) {
-            *r = 255;
-            ++r;
-        }
-    }
-
-    *r = '\0';
-    ++r;
-    assert((r - (unsigned char *)ret) == n );
-    return ret;
-}
-
-void
-FtpStateData::writeCommand(const char *buf)
-{
-    char *ebuf;
-    /* trace FTP protocol communications at level 2 */
-    debugs(9, 2, "ftp<< " << buf);
-
-    if (Config.Ftp.telnet)
-        ebuf = escapeIAC(buf);
-    else
-        ebuf = xstrdup(buf);
-
-    safe_free(ctrl.last_command);
-
-    safe_free(ctrl.last_reply);
-
-    ctrl.last_command = ebuf;
-
-    if (!Comm::IsConnOpen(ctrl.conn)) {
-        debugs(9, 2, HERE << "cannot send to closing ctrl " << ctrl.conn);
-        // TODO: assert(ctrl.closer != NULL);
-        return;
-    }
-
-    typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
-    AsyncCall::Pointer call = JobCallback(9, 5, Dialer, this, FtpStateData::ftpWriteCommandCallback);
-    Comm::Write(ctrl.conn, ctrl.last_command, strlen(ctrl.last_command), call, NULL);
-
-    scheduleReadControlReply(0);
-}
-
 void
-FtpStateData::ftpWriteCommandCallback(const CommIoCbParams &io)
+Ftp::Gateway::handleControlReply()
 {
+    Ftp::Client::handleControlReply();
+    if (ctrl.message == NULL)
+        return; // didn't get complete reply yet
 
-    debugs(9, 5, "ftpWriteCommandCallback: wrote " << io.size << " bytes");
-
-    if (io.size > 0) {
-        fd_bytes(io.fd, io.size, FD_WRITE);
-        kb_incr(&(statCounter.server.all.kbytes_out), io.size);
-        kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
-    }
-
-    if (io.flag == Comm::ERR_CLOSING)
-        return;
-
-    if (io.flag) {
-        debugs(9, DBG_IMPORTANT, "ftpWriteCommandCallback: " << io.conn << ": " << xstrerr(io.xerrno));
-        failed(ERR_WRITE_ERROR, io.xerrno);
-        /* failed closes ctrl.conn and frees ftpState */
-        return;
-    }
-}
-
-wordlist *
-FtpStateData::ftpParseControlReply(char *buf, size_t len, int *codep, size_t *used)
-{
-    char *s;
-    char *sbuf;
-    char *end;
-    int usable;
-    int complete = 0;
-    wordlist *head = NULL;
-    wordlist *list;
-    wordlist **tail = &head;
-    size_t offset;
-    size_t linelen;
-    int code = -1;
-    debugs(9, 3, HERE);
-    /*
-     * We need a NULL-terminated buffer for scanning, ick
+    /* Copy the message except for the last line to cwd_message to be
+     * printed in error messages.
      */
-    sbuf = (char *)xmalloc(len + 1);
-    xstrncpy(sbuf, buf, len + 1);
-    end = sbuf + len - 1;
-
-    while (*end != '\r' && *end != '\n' && end > sbuf)
-        --end;
-
-    usable = end - sbuf;
-
-    debugs(9, 3, HERE << "usable = " << usable);
-
-    if (usable == 0) {
-        debugs(9, 3, HERE << "didn't find end of line");
-        safe_free(sbuf);
-        return NULL;
+    for (wordlist *w = ctrl.message; w && w->next; w = w->next) {
+        cwd_message.append('\n');
+        cwd_message.append(w->key);
     }
 
-    debugs(9, 3, HERE << len << " bytes to play with");
-    ++end;
-    s = sbuf;
-    s += strspn(s, crlf);
-
-    for (; s < end; s += strcspn(s, crlf), s += strspn(s, crlf)) {
-        if (complete)
-            break;
-
-        debugs(9, 5, HERE << "s = {" << s << "}");
-
-        linelen = strcspn(s, crlf) + 1;
-
-        if (linelen < 2)
-            break;
-
-        if (linelen > 3)
-            complete = (*s >= '0' && *s <= '9' && *(s + 3) == ' ');
-
-        if (complete)
-            code = atoi(s);
-
-        offset = 0;
-
-        if (linelen > 3)
-            if (*s >= '0' && *s <= '9' && (*(s + 3) == '-' || *(s + 3) == ' '))
-                offset = 4;
-
-        list = new wordlist();
-
-        list->key = (char *)xmalloc(linelen - offset);
-
-        xstrncpy(list->key, s + offset, linelen - offset);
-
-        /* trace the FTP communication chat at level 2 */
-        debugs(9, 2, "ftp>> " << code << " " << list->key);
-
-        *tail = list;
-
-        tail = &list->next;
-    }
-
-    *used = (size_t) (s - sbuf);
-    safe_free(sbuf);
-
-    if (!complete)
-        wordlistDestroy(&head);
-
-    if (codep)
-        *codep = code;
-
-    return head;
-}
-
-/**
- * DPW 2007-04-23
- * Looks like there are no longer anymore callers that set
- * buffered_ok=1.  Perhaps it can be removed at some point.
- */
-void
-FtpStateData::scheduleReadControlReply(int buffered_ok)
-{
-    debugs(9, 3, HERE << ctrl.conn);
-
-    if (buffered_ok && ctrl.offset > 0) {
-        /* We've already read some reply data */
-        handleControlReply();
-    } else {
-        /*
-         * Cancel the timeout on the Data socket (if any) and
-         * establish one on the control socket.
-         */
-        if (Comm::IsConnOpen(data.conn)) {
-            commUnsetConnTimeout(data.conn);
-        }
-
-        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer timeoutCall = JobCallback(9, 5, TimeoutDialer, this, FtpStateData::ftpTimeout);
-        commSetConnTimeout(ctrl.conn, Config.Timeout.read, timeoutCall);
-
-        typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
-        AsyncCall::Pointer reader = JobCallback(9, 5, Dialer, this, FtpStateData::ftpReadControlReply);
-        comm_read(ctrl.conn, ctrl.buf + ctrl.offset, ctrl.size - ctrl.offset, reader);
-    }
-}
-
-void FtpStateData::ftpReadControlReply(const CommIoCbParams &io)
-{
-    debugs(9, 3, "ftpReadControlReply: FD " << io.fd << ", Read " << io.size << " bytes");
-
-    if (io.size > 0) {
-        kb_incr(&(statCounter.server.all.kbytes_in), io.size);
-        kb_incr(&(statCounter.server.ftp.kbytes_in), io.size);
-    }
-
-    if (io.flag == Comm::ERR_CLOSING)
-        return;
-
-    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
-        abortTransaction("entry aborted during control reply read");
-        return;
-    }
-
-    assert(ctrl.offset < ctrl.size);
-
-    if (io.flag == Comm::OK && io.size > 0) {
-        fd_bytes(io.fd, io.size, FD_READ);
-    }
-
-    if (io.flag != Comm::OK) {
-        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
-               "ftpReadControlReply: read error: " << xstrerr(io.xerrno));
-
-        if (ignoreErrno(io.xerrno)) {
-            scheduleReadControlReply(0);
-        } else {
-            failed(ERR_READ_ERROR, io.xerrno);
-            /* failed closes ctrl.conn and frees ftpState */
-        }
-        return;
-    }
-
-    if (io.size == 0) {
-        if (entry->store_status == STORE_PENDING) {
-            failed(ERR_FTP_FAILURE, 0);
-            /* failed closes ctrl.conn and frees ftpState */
-            return;
-        }
-
-        /* XXX this may end up having to be serverComplete() .. */
-        abortTransaction("zero control reply read");
-        return;
-    }
-
-    unsigned int len =io.size + ctrl.offset;
-    ctrl.offset = len;
-    assert(len <= ctrl.size);
-    handleControlReply();
-}
-
-void
-FtpStateData::handleControlReply()
-{
-    wordlist **W;
-    size_t bytes_used = 0;
-    wordlistDestroy(&ctrl.message);
-    ctrl.message = ftpParseControlReply(ctrl.buf,
-                                        ctrl.offset, &ctrl.replycode, &bytes_used);
-
-    if (ctrl.message == NULL) {
-        /* didn't get complete reply yet */
-
-        if (ctrl.offset == ctrl.size) {
-            ctrl.buf = (char *)memReallocBuf(ctrl.buf, ctrl.size << 1, &ctrl.size);
-        }
-
-        scheduleReadControlReply(0);
-        return;
-    } else if (ctrl.offset == bytes_used) {
-        /* used it all up */
-        ctrl.offset = 0;
-    } else {
-        /* Got some data past the complete reply */
-        assert(bytes_used < ctrl.offset);
-        ctrl.offset -= bytes_used;
-        memmove(ctrl.buf, ctrl.buf + bytes_used, ctrl.offset);
-    }
-
-    /* Move the last line of the reply message to ctrl.last_reply */
-    for (W = &ctrl.message; (*W)->next; W = &(*W)->next);
-    safe_free(ctrl.last_reply);
-
-    ctrl.last_reply = xstrdup((*W)->key);
-
-    wordlistDestroy(W);
-
-    /* Copy the rest of the message to cwd_message to be printed in
-     * error messages
-     */
-    if (ctrl.message) {
-        for (wordlist *w = ctrl.message; w; w = w->next) {
-            cwd_message.append('\n');
-            cwd_message.append(w->key);
-        }
-    }
-
-    debugs(9, 3, HERE << "state=" << state << ", code=" << ctrl.replycode);
-
     FTP_SM_FUNCS[state] (this);
 }
 
 /* ====================================================================== */
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadWelcome(FtpStateData * ftpState)
+ftpReadWelcome(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -1876,7 +1255,7 @@ ftpReadWelcome(FtpStateData * ftpState)
  * its NOT a general failure. But a correct FTP response type.
  */
 void
-FtpStateData::loginFailed()
+Ftp::Gateway::loginFailed()
 {
     ErrorState *err = NULL;
     const char *command, *reply;
@@ -1940,7 +1319,7 @@ FtpStateData::loginFailed()
 }
 
 const char *
-FtpStateData::ftpRealm()
+Ftp::Gateway::ftpRealm()
 {
     static char realm[8192];
 
@@ -1955,9 +1334,8 @@ FtpStateData::ftpRealm()
     return realm;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendUser(FtpStateData * ftpState)
+ftpSendUser(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendUser"))
@@ -1972,12 +1350,11 @@ ftpSendUser(FtpStateData * ftpState)
 
     ftpState->writeCommand(cbuf);
 
-    ftpState->state = SENT_USER;
+    ftpState->state = Ftp::Client::SENT_USER;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadUser(FtpStateData * ftpState)
+ftpReadUser(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -1991,22 +1368,20 @@ ftpReadUser(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendPass(FtpStateData * ftpState)
+ftpSendPass(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendPass"))
         return;
 
     snprintf(cbuf, CTRL_BUFLEN, "PASS %s\r\n", ftpState->password);
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_PASS;
+    ftpState->state = Ftp::Client::SENT_PASS;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadPass(FtpStateData * ftpState)
+ftpReadPass(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE << "code=" << code);
@@ -2018,9 +1393,8 @@ ftpReadPass(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendType(FtpStateData * ftpState)
+ftpSendType(Ftp::Gateway * ftpState)
 {
     const char *t;
     const char *filename;
@@ -2068,12 +1442,11 @@ ftpSendType(FtpStateData * ftpState)
 
     ftpState->writeCommand(cbuf);
 
-    ftpState->state = SENT_TYPE;
+    ftpState->state = Ftp::Client::SENT_TYPE;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadType(FtpStateData * ftpState)
+ftpReadType(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     char *path;
@@ -2112,9 +1485,8 @@ ftpReadType(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpTraverseDirectory(FtpStateData * ftpState)
+ftpTraverseDirectory(Ftp::Gateway * ftpState)
 {
     wordlist *w;
     debugs(9, 4, HERE << (ftpState->filepath ? ftpState->filepath : "<NULL>"));
@@ -2150,9 +1522,8 @@ ftpTraverseDirectory(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendCwd(FtpStateData * ftpState)
+ftpSendCwd(Ftp::Gateway * ftpState)
 {
     char *path = NULL;
 
@@ -2174,12 +1545,11 @@ ftpSendCwd(FtpStateData * ftpState)
 
     ftpState->writeCommand(cbuf);
 
-    ftpState->state = SENT_CWD;
+    ftpState->state = Ftp::Client::SENT_CWD;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadCwd(FtpStateData * ftpState)
+ftpReadCwd(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -2208,9 +1578,8 @@ ftpReadCwd(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendMkdir(FtpStateData * ftpState)
+ftpSendMkdir(Ftp::Gateway * ftpState)
 {
     char *path = NULL;
 
@@ -2222,12 +1591,11 @@ ftpSendMkdir(FtpStateData * ftpState)
     debugs(9, 3, HERE << "with path=" << path);
     snprintf(cbuf, CTRL_BUFLEN, "MKD %s\r\n", path);
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_MKDIR;
+    ftpState->state = Ftp::Client::SENT_MKDIR;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadMkdir(FtpStateData * ftpState)
+ftpReadMkdir(Ftp::Gateway * ftpState)
 {
     char *path = ftpState->filepath;
     int code = ftpState->ctrl.replycode;
@@ -2247,18 +1615,16 @@ ftpReadMkdir(FtpStateData * ftpState)
         ftpSendReply(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpGetFile(FtpStateData * ftpState)
+ftpGetFile(Ftp::Gateway * ftpState)
 {
     assert(*ftpState->filepath != '\0');
     ftpState->flags.isdir = 0;
     ftpSendMdtm(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpListDir(FtpStateData * ftpState)
+ftpListDir(Ftp::Gateway * ftpState)
 {
     if (ftpState->flags.dir_slash) {
         debugs(9, 3, HERE << "Directory path did not end in /");
@@ -2269,9 +1635,8 @@ ftpListDir(FtpStateData * ftpState)
     ftpSendPassive(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendMdtm(FtpStateData * ftpState)
+ftpSendMdtm(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendMdtm"))
@@ -2280,12 +1645,11 @@ ftpSendMdtm(FtpStateData * ftpState)
     assert(*ftpState->filepath != '\0');
     snprintf(cbuf, CTRL_BUFLEN, "MDTM %s\r\n", ftpState->filepath);
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_MDTM;
+    ftpState->state = Ftp::Client::SENT_MDTM;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadMdtm(FtpStateData * ftpState)
+ftpReadMdtm(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -2301,9 +1665,8 @@ ftpReadMdtm(FtpStateData * ftpState)
     ftpSendSize(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendSize(FtpStateData * ftpState)
+ftpSendSize(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendSize"))
@@ -2317,15 +1680,14 @@ ftpSendSize(FtpStateData * ftpState)
         assert(*ftpState->filepath != '\0');
         snprintf(cbuf, CTRL_BUFLEN, "SIZE %s\r\n", ftpState->filepath);
         ftpState->writeCommand(cbuf);
-        ftpState->state = SENT_SIZE;
+        ftpState->state = Ftp::Client::SENT_SIZE;
     } else
         /* Skip to next state no non-binary transfers */
         ftpSendPassive(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadSize(FtpStateData * ftpState)
+ftpReadSize(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -2348,148 +1710,24 @@ ftpReadSize(FtpStateData * ftpState)
     ftpSendPassive(ftpState);
 }
 
-/**
- \ingroup ServerProtocolFTPInternal
- */
 static void
-ftpReadEPSV(FtpStateData* ftpState)
+ftpReadEPSV(Ftp::Gateway* ftpState)
 {
-    int code = ftpState->ctrl.replycode;
-    Ip::Address ipa_remote;
-    char *buf;
-    debugs(9, 3, HERE);
-
-    if (code != 229 && code != 522) {
-        if (code == 200) {
-            /* handle broken servers (RFC 2428 says OK code for EPSV MUST be 229 not 200) */
-            /* vsftpd for one send '200 EPSV ALL ok.' without even port info.
-             * Its okay to re-send EPSV 1/2 but nothing else. */
-            debugs(9, DBG_IMPORTANT, "Broken FTP Server at " << ftpState->ctrl.conn->remote << ". Wrong accept code for EPSV");
-        } else {
-            debugs(9, 2, "EPSV not supported by remote end");
-            ftpState->state = SENT_EPSV_1; /* simulate having failed EPSV 1 (last EPSV to try before shifting to PASV) */
-        }
-        ftpSendPassive(ftpState);
-        return;
-    }
-
-    if (code == 522) {
-        /* server response with list of supported methods   */
-        /*   522 Network protocol not supported, use (1)    */
-        /*   522 Network protocol not supported, use (1,2)  */
-        /*   522 Network protocol not supported, use (2)  */
-        /* TODO: handle the (1,2) case. We might get it back after EPSV ALL
-         * which means close data + control without self-destructing and re-open from scratch. */
-        debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
-        buf = ftpState->ctrl.last_reply;
-        while (buf != NULL && *buf != '\0' && *buf != '\n' && *buf != '(')
-            ++buf;
-        if (buf != NULL && *buf == '\n')
-            ++buf;
-
-        if (buf == NULL || *buf == '\0') {
-            /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
-            debugs(9, DBG_IMPORTANT, "Broken FTP Server at " << ftpState->ctrl.conn->remote << ". 522 error missing protocol negotiation hints");
-            ftpSendPassive(ftpState);
-        } else if (strcmp(buf, "(1)") == 0) {
-            ftpState->state = SENT_EPSV_2; /* simulate having sent and failed EPSV 2 */
-            ftpSendPassive(ftpState);
-        } else if (strcmp(buf, "(2)") == 0) {
-            if (Ip::EnableIpv6) {
-                /* If server only supports EPSV 2 and we have already tried that. Go straight to EPRT */
-                if (ftpState->state == SENT_EPSV_2) {
-                    ftpSendEPRT(ftpState);
-                } else {
-                    /* or try the next Passive mode down the chain. */
-                    ftpSendPassive(ftpState);
-                }
-            } else {
-                /* Server only accept EPSV in IPv6 traffic. */
-                ftpState->state = SENT_EPSV_1; /* simulate having sent and failed EPSV 1 */
-                ftpSendPassive(ftpState);
-            }
-        } else {
-            /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
-            debugs(9, DBG_IMPORTANT, "WARNING: Server at " << ftpState->ctrl.conn->remote << " sent unknown protocol negotiation hint: " << buf);
-            ftpSendPassive(ftpState);
-        }
-        return;
-    }
-
-    /*  229 Entering Extended Passive Mode (|||port|) */
-    /*  ANSI sez [^0-9] is undefined, it breaks on Watcom cc */
-    debugs(9, 5, "scanning: " << ftpState->ctrl.last_reply);
-
-    buf = ftpState->ctrl.last_reply + strcspn(ftpState->ctrl.last_reply, "(");
-
-    char h1, h2, h3, h4;
-    unsigned short port;
-    int n = sscanf(buf, "(%c%c%c%hu%c)", &h1, &h2, &h3, &port, &h4);
-
-    if (n < 4 || h1 != h2 || h1 != h3 || h1 != h4) {
-        debugs(9, DBG_IMPORTANT, "Invalid EPSV reply from " <<
-               ftpState->ctrl.conn->remote << ": " <<
-               ftpState->ctrl.last_reply);
-
-        ftpSendPassive(ftpState);
-        return;
-    }
-
-    if (0 == port) {
-        debugs(9, DBG_IMPORTANT, "Unsafe EPSV reply from " <<
-               ftpState->ctrl.conn->remote << ": " <<
-               ftpState->ctrl.last_reply);
-
-        ftpSendPassive(ftpState);
-        return;
-    }
-
-    if (Config.Ftp.sanitycheck) {
-        if (port < 1024) {
-            debugs(9, DBG_IMPORTANT, "Unsafe EPSV reply from " <<
-                   ftpState->ctrl.conn->remote << ": " <<
-                   ftpState->ctrl.last_reply);
+    Ip::Address srvAddr; // unused
+    if (ftpState->handleEpsvReply(srvAddr)) {
+        if (ftpState->ctrl.message == NULL)
+            return; // didn't get complete reply yet
 
-            ftpSendPassive(ftpState);
-            return;
-        }
+        ftpState->connectDataChannel();
     }
-
-    ftpState->data.port = port;
-
-    safe_free(ftpState->data.host);
-    ftpState->data.host = xstrdup(fd_table[ftpState->ctrl.conn->fd].ipaddr);
-
-    safe_free(ftpState->ctrl.last_command);
-
-    safe_free(ftpState->ctrl.last_reply);
-
-    ftpState->ctrl.last_command = xstrdup("Connect to server data port");
-
-    // Generate a new data channel descriptor to be opened.
-    Comm::ConnectionPointer conn = new Comm::Connection;
-    conn->setAddrs(ftpState->ctrl.conn->local, ftpState->ctrl.conn->remote);
-    conn->local.port(0);
-    conn->remote.port(port);
-    conn->tos = ftpState->ctrl.conn->tos;
-    conn->nfmark = ftpState->ctrl.conn->nfmark;
-
-    debugs(9, 3, HERE << "connecting to " << conn->remote);
-
-    ftpState->data.opener = commCbCall(9,3, "FtpStateData::ftpPasvCallback", CommConnectCbPtrFun(FtpStateData::ftpPasvCallback, ftpState));
-    Comm::ConnOpener *cs = new Comm::ConnOpener(conn, ftpState->data.opener, Config.Timeout.connect);
-    cs->setHost(ftpState->data.host);
-    AsyncJob::Start(cs);
 }
 
-/** \ingroup ServerProtocolFTPInternal
- *
- * Send Passive connection request.
+/** Send Passive connection request.
  * Default method is to use modern EPSV request.
  * The failover mechanism should check for previous state and re-call with alternates on failure.
  */
 static void
-ftpSendPassive(FtpStateData * ftpState)
+ftpSendPassive(Ftp::Gateway * ftpState)
 {
     /** Checks the server control channel is still available before running. */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendPassive"))
@@ -2498,126 +1736,29 @@ ftpSendPassive(FtpStateData * ftpState)
     debugs(9, 3, HERE);
 
     /** \par
-      * Checks for EPSV ALL special conditions:
-      * If enabled to be sent, squid MUST NOT request any other connect methods.
-      * If 'ALL' is sent and fails the entire FTP Session fails.
-      * NP: By my reading exact EPSV protocols maybe attempted, but only EPSV method. */
-    if (Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent && ftpState->state == SENT_EPSV_1 ) {
-        debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
-        ftpFail(ftpState);
-        return;
-    }
-
-    /** \par
-      * Checks for 'HEAD' method request and passes off for special handling by FtpStateData::processHeadResponse(). */
+      * Checks for 'HEAD' method request and passes off for special handling by Ftp::Gateway::processHeadResponse(). */
     if (ftpState->request->method == Http::METHOD_HEAD && (ftpState->flags.isdir || ftpState->theSize != -1)) {
         ftpState->processHeadResponse(); // may call serverComplete
         return;
     }
 
-    /// Closes any old FTP-Data connection which may exist. */
-    ftpState->data.close();
-
-    /** \par
-      * Checks for previous EPSV/PASV failures on this server/session.
-      * Diverts to EPRT immediately if they are not working. */
-    if (!ftpState->flags.pasv_supported) {
-        ftpSendEPRT(ftpState);
-        return;
-    }
-
-    /** \par
-      * Send EPSV (ALL,2,1) or PASV on the control channel.
-      *
-      *  - EPSV ALL  is used if enabled.
-      *  - EPSV 2    is used if ALL is disabled and IPv6 is available and ctrl channel is IPv6.
-      *  - EPSV 1    is used if EPSV 2 (IPv6) fails or is not available or ctrl channel is IPv4.
-      *  - PASV      is used if EPSV 1 fails.
-      */
-    switch (ftpState->state) {
-    case SENT_EPSV_ALL: /* EPSV ALL resulted in a bad response. Try ther EPSV methods. */
-        ftpState->flags.epsv_all_sent = true;
-        if (ftpState->ctrl.conn->local.isIPv6()) {
-            debugs(9, 5, HERE << "FTP Channel is IPv6 (" << ftpState->ctrl.conn->remote << ") attempting EPSV 2 after EPSV ALL has failed.");
-            snprintf(cbuf, CTRL_BUFLEN, "EPSV 2\r\n");
-            ftpState->state = SENT_EPSV_2;
-            break;
-        }
-        // else fall through to skip EPSV 2
-
-    case SENT_EPSV_2: /* EPSV IPv6 failed. Try EPSV IPv4 */
-        if (ftpState->ctrl.conn->local.isIPv4()) {
-            debugs(9, 5, HERE << "FTP Channel is IPv4 (" << ftpState->ctrl.conn->remote << ") attempting EPSV 1 after EPSV ALL has failed.");
-            snprintf(cbuf, CTRL_BUFLEN, "EPSV 1\r\n");
-            ftpState->state = SENT_EPSV_1;
-            break;
-        } else if (ftpState->flags.epsv_all_sent) {
-            debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
-            ftpFail(ftpState);
-            return;
-        }
-        // else fall through to skip EPSV 1
-
-    case SENT_EPSV_1: /* EPSV options exhausted. Try PASV now. */
-        debugs(9, 5, HERE << "FTP Channel (" << ftpState->ctrl.conn->remote << ") rejects EPSV connection attempts. Trying PASV instead.");
-        snprintf(cbuf, CTRL_BUFLEN, "PASV\r\n");
-        ftpState->state = SENT_PASV;
-        break;
-
-    default: {
-        bool doEpsv = true;
-        if (Config.accessList.ftp_epsv) {
-            ACLFilledChecklist checklist(Config.accessList.ftp_epsv, ftpState->fwd->request, NULL);
-            doEpsv = (checklist.fastCheck() == ACCESS_ALLOWED);
-        }
-        if (!doEpsv) {
-            debugs(9, 5, HERE << "EPSV support manually disabled. Sending PASV for FTP Channel (" << ftpState->ctrl.conn->remote <<")");
-            snprintf(cbuf, CTRL_BUFLEN, "PASV\r\n");
-            ftpState->state = SENT_PASV;
-        } else if (Config.Ftp.epsv_all) {
-            debugs(9, 5, HERE << "EPSV ALL manually enabled. Attempting with FTP Channel (" << ftpState->ctrl.conn->remote <<")");
-            snprintf(cbuf, CTRL_BUFLEN, "EPSV ALL\r\n");
-            ftpState->state = SENT_EPSV_ALL;
-            /* block other non-EPSV connections being attempted */
+    if (ftpState->sendPassive()) {
+        // SENT_EPSV_ALL blocks other non-EPSV connections being attempted
+        if (ftpState->state == Ftp::Client::SENT_EPSV_ALL)
             ftpState->flags.epsv_all_sent = true;
-        } else {
-            if (ftpState->ctrl.conn->local.isIPv6()) {
-                debugs(9, 5, HERE << "FTP Channel (" << ftpState->ctrl.conn->remote << "). Sending default EPSV 2");
-                snprintf(cbuf, CTRL_BUFLEN, "EPSV 2\r\n");
-                ftpState->state = SENT_EPSV_2;
-            }
-            if (ftpState->ctrl.conn->local.isIPv4()) {
-                debugs(9, 5, HERE << "Channel (" << ftpState->ctrl.conn->remote <<"). Sending default EPSV 1");
-                snprintf(cbuf, CTRL_BUFLEN, "EPSV 1\r\n");
-                ftpState->state = SENT_EPSV_1;
-            }
-        }
-    }
-    break;
     }
-
-    ftpState->writeCommand(cbuf);
-
-    /*
-     * ugly hack for ftp servers like ftp.netscape.com that sometimes
-     * dont acknowledge PASV commands. Use connect timeout to be faster then read timeout (minutes).
-     */
-    typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-    AsyncCall::Pointer timeoutCall =  JobCallback(9, 5,
-                                      TimeoutDialer, ftpState, FtpStateData::ftpTimeout);
-    commSetConnTimeout(ftpState->ctrl.conn, Config.Timeout.connect, timeoutCall);
 }
 
 void
-FtpStateData::processHeadResponse()
+Ftp::Gateway::processHeadResponse()
 {
     debugs(9, 5, HERE << "handling HEAD response");
     ftpSendQuit(this);
     appendSuccessHeader();
 
     /*
      * On rare occasions I'm seeing the entry get aborted after
-     * ftpReadControlReply() and before here, probably when
+     * readControlReply() and before here, probably when
      * trying to write to the client.
      */
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
@@ -2636,133 +1777,42 @@ FtpStateData::processHeadResponse()
     processReplyBody();
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadPasv(FtpStateData * ftpState)
+ftpReadPasv(Ftp::Gateway * ftpState)
 {
-    int code = ftpState->ctrl.replycode;
-    int h1, h2, h3, h4;
-    int p1, p2;
-    int n;
-    unsigned short port;
-    Ip::Address ipa_remote;
-    char *buf;
-    LOCAL_ARRAY(char, ipaddr, 1024);
-    debugs(9, 3, HERE);
-
-    if (code != 227) {
-        debugs(9, 2, "PASV not supported by remote end");
-        ftpSendEPRT(ftpState);
-        return;
-    }
-
-    /*  227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).  */
-    /*  ANSI sez [^0-9] is undefined, it breaks on Watcom cc */
-    debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
-
-    buf = ftpState->ctrl.last_reply + strcspn(ftpState->ctrl.last_reply, "0123456789");
-
-    n = sscanf(buf, "%d,%d,%d,%d,%d,%d", &h1, &h2, &h3, &h4, &p1, &p2);
-
-    if (n != 6 || p1 < 0 || p2 < 0 || p1 > 255 || p2 > 255) {
-        debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
-               ftpState->ctrl.conn->remote << ": " <<
-               ftpState->ctrl.last_reply);
-
+    Ip::Address srvAddr; // unused
+    if (ftpState->handlePasvReply(srvAddr))
+        ftpState->connectDataChannel();
+    else {
         ftpSendEPRT(ftpState);
         return;
     }
-
-    snprintf(ipaddr, 1024, "%d.%d.%d.%d", h1, h2, h3, h4);
-
-    ipa_remote = ipaddr;
-
-    if ( ipa_remote.isAnyAddr() ) {
-        debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
-               ftpState->ctrl.conn->remote << ": " <<
-               ftpState->ctrl.last_reply);
-
-        ftpSendEPRT(ftpState);
-        return;
-    }
-
-    port = ((p1 << 8) + p2);
-
-    if (0 == port) {
-        debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
-               ftpState->ctrl.conn->remote << ": " <<
-               ftpState->ctrl.last_reply);
-
-        ftpSendEPRT(ftpState);
-        return;
-    }
-
-    if (Config.Ftp.sanitycheck) {
-        if (port < 1024) {
-            debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
-                   ftpState->ctrl.conn->remote << ": " <<
-                   ftpState->ctrl.last_reply);
-
-            ftpSendEPRT(ftpState);
-            return;
-        }
-    }
-
-    ftpState->data.port = port;
-
-    safe_free(ftpState->data.host);
-    if (Config.Ftp.sanitycheck)
-        ftpState->data.host = xstrdup(fd_table[ftpState->ctrl.conn->fd].ipaddr);
-    else
-        ftpState->data.host = xstrdup(ipaddr);
-
-    safe_free(ftpState->ctrl.last_command);
-
-    safe_free(ftpState->ctrl.last_reply);
-
-    ftpState->ctrl.last_command = xstrdup("Connect to server data port");
-
-    Comm::ConnectionPointer conn = new Comm::Connection;
-    conn->setAddrs(ftpState->ctrl.conn->local, ipaddr);
-    conn->local.port(0);
-    conn->remote.port(port);
-    conn->tos = ftpState->ctrl.conn->tos;
-    conn->nfmark = ftpState->ctrl.conn->nfmark;
-
-    debugs(9, 3, HERE << "connecting to " << conn->remote);
-
-    ftpState->data.opener = commCbCall(9,3, "FtpStateData::ftpPasvCallback", CommConnectCbPtrFun(FtpStateData::ftpPasvCallback, ftpState));
-    Comm::ConnOpener *cs = new Comm::ConnOpener(conn, ftpState->data.opener, Config.Timeout.connect);
-    cs->setHost(ftpState->data.host);
-    AsyncJob::Start(cs);
 }
 
 void
-FtpStateData::ftpPasvCallback(const Comm::ConnectionPointer &conn, Comm::Flag status, int xerrno, void *data)
+Ftp::Gateway::dataChannelConnected(const CommConnectCbParams &io)
 {
-    FtpStateData *ftpState = (FtpStateData *)data;
     debugs(9, 3, HERE);
-    ftpState->data.opener = NULL;
+    data.opener = NULL;
 
-    if (status != Comm::OK) {
+    if (io.flag != Comm::OK) {
         debugs(9, 2, HERE << "Failed to connect. Retrying via another method.");
 
         // ABORT on timeouts. server may be waiting on a broken TCP link.
-        if (status == Comm::TIMEOUT)
-            ftpState->writeCommand("ABOR");
+        if (io.xerrno == Comm::TIMEOUT)
+            writeCommand("ABOR");
 
         // try another connection attempt with some other method
-        ftpSendPassive(ftpState);
+        ftpSendPassive(this);
         return;
     }
 
-    ftpState->data.opened(conn, ftpState->dataCloser());
-    ftpRestOrList(ftpState);
+    data.opened(io.conn, dataCloser());
+    ftpRestOrList(this);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
+ftpOpenListenSocket(Ftp::Gateway * ftpState, int fallback)
 {
     /// Close old data channels, if any. We may open a new one below.
     if (ftpState->data.conn != NULL) {
@@ -2795,12 +1845,11 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
         temp->local.port(0);
     }
 
-    ftpState->listenForDataChannel(temp, ftpState->entry->url());
+    ftpState->listenForDataChannel(temp);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendPORT(FtpStateData * ftpState)
+ftpSendPORT(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendPort"))
@@ -2840,14 +1889,13 @@ ftpSendPORT(FtpStateData * ftpState)
              addrptr[0], addrptr[1], addrptr[2], addrptr[3],
              portptr[0], portptr[1]);
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_PORT;
+    ftpState->state = Ftp::Client::SENT_PORT;
 
     Ip::Address::FreeAddrInfo(AI);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadPORT(FtpStateData * ftpState)
+ftpReadPORT(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -2861,9 +1909,8 @@ ftpReadPORT(FtpStateData * ftpState)
     ftpRestOrList(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendEPRT(FtpStateData * ftpState)
+ftpSendEPRT(Ftp::Gateway * ftpState)
 {
     if (Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent) {
         debugs(9, DBG_IMPORTANT, "FTP does not allow EPRT method after 'EPSV ALL' has been sent.");
@@ -2898,11 +1945,11 @@ ftpSendEPRT(FtpStateData * ftpState)
              ftpState->data.listenConn->local.port() );
 
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_EPRT;
+    ftpState->state = Ftp::Client::SENT_EPRT;
 }
 
 static void
-ftpReadEPRT(FtpStateData * ftpState)
+ftpReadEPRT(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -2917,15 +1964,12 @@ ftpReadEPRT(FtpStateData * ftpState)
     ftpRestOrList(ftpState);
 }
 
-/**
- \ingroup ServerProtocolFTPInternal
- \par
- * "read" handler to accept FTP data connections.
+/** "read" handler to accept FTP data connections.
  *
  \param io    comm accept(2) callback parameters
  */
 void
-FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
+Ftp::Gateway::ftpAcceptDataConnection(const CommAcceptCbParams &io)
 {
     debugs(9, 3, HERE);
 
@@ -2982,9 +2026,7 @@ FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
     /** On Comm::OK start using the accepted data socket and discard the temporary listen socket. */
     data.close();
     data.opened(io.conn, dataCloser());
-    static char ntoapeer[MAX_IPSTRLEN];
-    io.conn->remote.toStr(ntoapeer,sizeof(ntoapeer));
-    data.host = xstrdup(ntoapeer);
+    data.addr(io.conn->remote);
 
     debugs(9, 3, HERE << "Connected data socket on " <<
            io.conn << ". FD table says: " <<
@@ -2997,9 +2039,8 @@ FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
     // Ctrl channel operations will determine what happens to this data connection
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpRestOrList(FtpStateData * ftpState)
+ftpRestOrList(Ftp::Gateway * ftpState)
 {
     debugs(9, 3, HERE);
 
@@ -3021,9 +2062,8 @@ ftpRestOrList(FtpStateData * ftpState)
         ftpSendRetr(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendStor(FtpStateData * ftpState)
+ftpSendStor(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendStor"))
@@ -3035,27 +2075,26 @@ ftpSendStor(FtpStateData * ftpState)
         /* Plain file upload */
         snprintf(cbuf, CTRL_BUFLEN, "STOR %s\r\n", ftpState->filepath);
         ftpState->writeCommand(cbuf);
-        ftpState->state = SENT_STOR;
+        ftpState->state = Ftp::Client::SENT_STOR;
     } else if (ftpState->request->header.getInt64(HDR_CONTENT_LENGTH) > 0) {
         /* File upload without a filename. use STOU to generate one */
         snprintf(cbuf, CTRL_BUFLEN, "STOU\r\n");
         ftpState->writeCommand(cbuf);
-        ftpState->state = SENT_STOR;
+        ftpState->state = Ftp::Client::SENT_STOR;
     } else {
         /* No file to transfer. Only create directories if needed */
         ftpSendReply(ftpState);
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 /// \deprecated use ftpState->readStor() instead.
 static void
-ftpReadStor(FtpStateData * ftpState)
+ftpReadStor(Ftp::Gateway * ftpState)
 {
     ftpState->readStor();
 }
 
-void FtpStateData::readStor()
+void Ftp::Gateway::readStor()
 {
     int code = ctrl.replycode;
     debugs(9, 3, HERE);
@@ -3083,16 +2122,15 @@ void FtpStateData::readStor()
     } else if (code == 150) {
         /* When client code is 150 with no data channel, Accept data channel. */
         debugs(9, 3, "ftpReadStor: accepting data channel");
-        listenForDataChannel(data.conn, data.host);
+        listenForDataChannel(data.conn);
     } else {
         debugs(9, DBG_IMPORTANT, HERE << "Unexpected reply code "<< std::setfill('0') << std::setw(3) << code);
         ftpFail(this);
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendRest(FtpStateData * ftpState)
+ftpSendRest(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendRest"))
@@ -3102,11 +2140,11 @@ ftpSendRest(FtpStateData * ftpState)
 
     snprintf(cbuf, CTRL_BUFLEN, "REST %" PRId64 "\r\n", ftpState->restart_offset);
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_REST;
+    ftpState->state = Ftp::Client::SENT_REST;
 }
 
 int
-FtpStateData::restartable()
+Ftp::Gateway::restartable()
 {
     if (restart_offset > 0)
         return 1;
@@ -3132,9 +2170,8 @@ FtpStateData::restartable()
     return 1;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadRest(FtpStateData * ftpState)
+ftpReadRest(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -3152,9 +2189,8 @@ ftpReadRest(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendList(FtpStateData * ftpState)
+ftpSendList(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendList"))
@@ -3169,12 +2205,11 @@ ftpSendList(FtpStateData * ftpState)
     }
 
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_LIST;
+    ftpState->state = Ftp::Client::SENT_LIST;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendNlst(FtpStateData * ftpState)
+ftpSendNlst(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendNlst"))
@@ -3191,12 +2226,11 @@ ftpSendNlst(FtpStateData * ftpState)
     }
 
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_NLST;
+    ftpState->state = Ftp::Client::SENT_NLST;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadList(FtpStateData * ftpState)
+ftpReadList(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -3206,12 +2240,12 @@ ftpReadList(FtpStateData * ftpState)
         debugs(9, 3, HERE << "begin data transfer from " << ftpState->data.conn->remote << " (" << ftpState->data.conn->local << ")");
         ftpState->switchTimeoutToDataChannel();
         ftpState->maybeReadVirginBody();
-        ftpState->state = READING_DATA;
+        ftpState->state = Ftp::Client::READING_DATA;
         return;
     } else if (code == 150) {
         /* Accept data channel */
         debugs(9, 3, HERE << "accept data channel from " << ftpState->data.conn->remote << " (" << ftpState->data.conn->local << ")");
-        ftpState->listenForDataChannel(ftpState->data.conn, ftpState->data.host);
+        ftpState->listenForDataChannel(ftpState->data.conn);
         return;
     } else if (!ftpState->flags.tried_nlst && code > 300) {
         ftpSendNlst(ftpState);
@@ -3221,9 +2255,8 @@ ftpReadList(FtpStateData * ftpState)
     }
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendRetr(FtpStateData * ftpState)
+ftpSendRetr(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendRetr"))
@@ -3234,12 +2267,11 @@ ftpSendRetr(FtpStateData * ftpState)
     assert(ftpState->filepath != NULL);
     snprintf(cbuf, CTRL_BUFLEN, "RETR %s\r\n", ftpState->filepath);
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_RETR;
+    ftpState->state = Ftp::Client::SENT_RETR;
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadRetr(FtpStateData * ftpState)
+ftpReadRetr(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -3249,10 +2281,10 @@ ftpReadRetr(FtpStateData * ftpState)
         debugs(9, 3, HERE << "begin data transfer from " << ftpState->data.conn->remote << " (" << ftpState->data.conn->local << ")");
         ftpState->switchTimeoutToDataChannel();
         ftpState->maybeReadVirginBody();
-        ftpState->state = READING_DATA;
+        ftpState->state = Ftp::Client::READING_DATA;
     } else if (code == 150) {
         /* Accept data channel */
-        ftpState->listenForDataChannel(ftpState->data.conn, ftpState->data.host);
+        ftpState->listenForDataChannel(ftpState->data.conn);
     } else if (code >= 300) {
         if (!ftpState->flags.try_slash_hack) {
             /* Try this as a directory missing trailing slash... */
@@ -3270,10 +2302,10 @@ ftpReadRetr(FtpStateData * ftpState)
  * directory listing display.
  */
 void
-FtpStateData::completedListing()
+Ftp::Gateway::completedListing()
 {
     assert(entry);
-    entry->lock("FtpStateData");
+    entry->lock("Ftp::Gateway");
     ErrorState ferr(ERR_DIR_LISTING, Http::scOkay, request);
     ferr.ftp.listing = &listing;
     ferr.ftp.cwd_msg = xstrdup(cwd_message.size()? cwd_message.termedBuf() : "");
@@ -3282,12 +2314,11 @@ FtpStateData::completedListing()
     entry->replaceHttpReply( ferr.BuildHttpReply() );
     EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
     entry->flush();
-    entry->unlock("FtpStateData");
+    entry->unlock("Ftp::Gateway");
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpReadTransferDone(FtpStateData * ftpState)
+ftpReadTransferDone(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -3309,27 +2340,15 @@ ftpReadTransferDone(FtpStateData * ftpState)
 
 // premature end of the request body
 void
-FtpStateData::handleRequestBodyProducerAborted()
+Ftp::Gateway::handleRequestBodyProducerAborted()
 {
     ServerStateData::handleRequestBodyProducerAborted();
     debugs(9, 3, HERE << "ftpState=" << this);
     failed(ERR_READ_ERROR, 0);
 }
 
-/**
- * This will be called when the put write is completed
- */
-void
-FtpStateData::sentRequestBody(const CommIoCbParams &io)
-{
-    if (io.size > 0)
-        kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
-    ServerStateData::sentRequestBody(io);
-}
-
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpWriteTransferDone(FtpStateData * ftpState)
+ftpWriteTransferDone(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     debugs(9, 3, HERE);
@@ -3344,34 +2363,29 @@ ftpWriteTransferDone(FtpStateData * ftpState)
     ftpSendReply(ftpState);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendQuit(FtpStateData * ftpState)
+ftpSendQuit(Ftp::Gateway * ftpState)
 {
     /* check the server control channel is still available */
     if (!ftpState || !ftpState->haveControlChannel("ftpSendQuit"))
         return;
 
     snprintf(cbuf, CTRL_BUFLEN, "QUIT\r\n");
     ftpState->writeCommand(cbuf);
-    ftpState->state = SENT_QUIT;
+    ftpState->state = Ftp::Client::SENT_QUIT;
 }
 
-/**
- * \ingroup ServerProtocolFTPInternal
- *
- *  This completes a client FTP operation with success or other page
+/** Completes a client FTP operation with success or other page
  *  generated and stored in the entry field by the code issuing QUIT.
  */
 static void
-ftpReadQuit(FtpStateData * ftpState)
+ftpReadQuit(Ftp::Gateway * ftpState)
 {
     ftpState->serverComplete();
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpTrySlashHack(FtpStateData * ftpState)
+ftpTrySlashHack(Ftp::Gateway * ftpState)
 {
     char *path;
     ftpState->flags.try_slash_hack = 1;
@@ -3399,7 +2413,7 @@ ftpTrySlashHack(FtpStateData * ftpState)
  * Forget hack status. Next error is shown to the user
  */
 void
-FtpStateData::unhack()
+Ftp::Gateway::unhack()
 {
     debugs(9, 3, HERE);
 
@@ -3410,7 +2424,7 @@ FtpStateData::unhack()
 }
 
 void
-FtpStateData::hackShortcut(FTPSM * nextState)
+Ftp::Gateway::hackShortcut(FTPSM * nextState)
 {
     /* Clear some unwanted state */
     setCurrentOffset(0);
@@ -3433,9 +2447,8 @@ FtpStateData::hackShortcut(FTPSM * nextState)
     nextState(this);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpFail(FtpStateData *ftpState)
+ftpFail(Ftp::Gateway *ftpState)
 {
     debugs(9, 6, HERE << "flags(" <<
            (ftpState->flags.isdir?"IS_DIR,":"") <<
@@ -3451,9 +2464,9 @@ ftpFail(FtpStateData *ftpState)
 
         switch (ftpState->state) {
 
-        case SENT_CWD:
+        case Ftp::Client::SENT_CWD:
 
-        case SENT_RETR:
+        case Ftp::Client::SENT_RETR:
             /* Try the / hack */
             ftpState->hackShortcut(ftpTrySlashHack);
             return;
@@ -3467,101 +2480,43 @@ ftpFail(FtpStateData *ftpState)
     /* failed() closes ctrl.conn and frees this */
 }
 
-void
-FtpStateData::failed(err_type error, int xerrno)
+Http::StatusCode
+Ftp::Gateway::failedHttpStatus(err_type &error)
 {
-    debugs(9,3,HERE << "entry-null=" << (entry?entry->isEmpty():0) << ", entry=" << entry);
-    if (entry->isEmpty())
-        failedErrorMessage(error, xerrno);
-
-    serverComplete();
-}
-
-void
-FtpStateData::failedErrorMessage(err_type error, int xerrno)
-{
-    ErrorState *ftperr = NULL;
-    const char *command, *reply;
-
-    /* Translate FTP errors into HTTP errors */
-    switch (error) {
-
-    case ERR_NONE:
-
+    if (error == ERR_NONE) {
         switch (state) {
 
         case SENT_USER:
 
         case SENT_PASS:
 
-            if (ctrl.replycode > 500)
-                if (password_url)
-                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd->request);
-                else
-                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
-
-            else if (ctrl.replycode == 421)
-                ftperr = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd->request);
-
+            if (ctrl.replycode > 500) {
+                error = ERR_FTP_FORBIDDEN;
+                return password_url ? Http::scForbidden : Http::scUnauthorized;
+            } else if (ctrl.replycode == 421) {
+                error = ERR_FTP_UNAVAILABLE;
+                return Http::scServiceUnavailable;
+            }
             break;
 
         case SENT_CWD:
 
         case SENT_RETR:
-            if (ctrl.replycode == 550)
-                ftperr = new ErrorState(ERR_FTP_NOT_FOUND, Http::scNotFound, fwd->request);
-
+            if (ctrl.replycode == 550) {
+                error = ERR_FTP_NOT_FOUND;
+                return Http::scNotFound;
+            }
             break;
 
         default:
             break;
         }
-
-        break;
-
-    case ERR_READ_TIMEOUT:
-        ftperr = new ErrorState(error, Http::scGatewayTimeout, fwd->request);
-        break;
-
-    default:
-        ftperr = new ErrorState(error, Http::scBadGateway, fwd->request);
-        break;
     }
-
-    if (ftperr == NULL)
-        ftperr = new ErrorState(ERR_FTP_FAILURE, Http::scBadGateway, fwd->request);
-
-    ftperr->xerrno = xerrno;
-
-    ftperr->ftp.server_msg = ctrl.message;
-    ctrl.message = NULL;
-
-    if (old_request)
-        command = old_request;
-    else
-        command = ctrl.last_command;
-
-    if (command && strncmp(command, "PASS", 4) == 0)
-        command = "PASS <yourpassword>";
-
-    if (old_reply)
-        reply = old_reply;
-    else
-        reply = ctrl.last_reply;
-
-    if (command)
-        ftperr->ftp.request = xstrdup(command);
-
-    if (reply)
-        ftperr->ftp.reply = xstrdup(reply);
-
-    entry->replaceHttpReply( ftperr->BuildHttpReply() );
-    delete ftperr;
+    return Ftp::Client::failedHttpStatus(error);
 }
 
-/// \ingroup ServerProtocolFTPInternal
 static void
-ftpSendReply(FtpStateData * ftpState)
+ftpSendReply(Ftp::Gateway * ftpState)
 {
     int code = ftpState->ctrl.replycode;
     Http::StatusCode http_code;
@@ -3606,7 +2561,7 @@ ftpSendReply(FtpStateData * ftpState)
 }
 
 void
-FtpStateData::appendSuccessHeader()
+Ftp::Gateway::appendSuccessHeader()
 {
     const char *mime_type = NULL;
     const char *mime_enc = NULL;
@@ -3687,7 +2642,7 @@ FtpStateData::appendSuccessHeader()
 }
 
 void
-FtpStateData::haveParsedReplyHeaders()
+Ftp::Gateway::haveParsedReplyHeaders()
 {
     ServerStateData::haveParsedReplyHeaders();
 
@@ -3708,7 +2663,7 @@ FtpStateData::haveParsedReplyHeaders()
 }
 
 HttpReply *
-FtpStateData::ftpAuthRequired(HttpRequest * request, const char *realm)
+Ftp::Gateway::ftpAuthRequired(HttpRequest * request, const char *realm)
 {
     ErrorState err(ERR_CACHE_ACCESS_DENIED, Http::scUnauthorized, request);
     HttpReply *newrep = err.BuildHttpReply();
@@ -3719,20 +2674,8 @@ FtpStateData::ftpAuthRequired(HttpRequest * request, const char *realm)
     return newrep;
 }
 
-/**
- \ingroup ServerProtocolFTPAPI
- \todo Should be a URL class API call.
- *
- *  Construct an URI with leading / in PATH portion for use by CWD command
- *  possibly others. FTP encodes absolute paths as beginning with '/'
- *  after the initial URI path delimiter, which happens to be / itself.
- *  This makes FTP absolute URI appear as:  ftp:host:port//root/path
- *  To encompass older software which compacts multiple // to / in transit
- *  We use standard URI-encoding on the second / making it
- *  ftp:host:port/%2froot/path  AKA 'the FTP %2f hack'.
- */
 const char *
-ftpUrlWith2f(HttpRequest * request)
+Ftp::UrlWith2f(HttpRequest * request)
 {
     String newbuf = "%2f";
 
@@ -3753,7 +2696,7 @@ ftpUrlWith2f(HttpRequest * request)
 }
 
 void
-FtpStateData::printfReplyBody(const char *fmt, ...)
+Ftp::Gateway::printfReplyBody(const char *fmt, ...)
 {
     va_list args;
     va_start (args, fmt);
@@ -3769,35 +2712,20 @@ FtpStateData::printfReplyBody(const char *fmt, ...)
  * which should be sent to either StoreEntry, or to ICAP...
  */
 void
-FtpStateData::writeReplyBody(const char *dataToWrite, size_t dataLength)
+Ftp::Gateway::writeReplyBody(const char *dataToWrite, size_t dataLength)
 {
     debugs(9, 5, HERE << "writing " << dataLength << " bytes to the reply");
     addVirginReplyBody(dataToWrite, dataLength);
 }
 
-/**
- * called after we wrote the last byte of the request body
- */
-void
-FtpStateData::doneSendingRequestBody()
-{
-    ServerStateData::doneSendingRequestBody();
-    debugs(9,3, HERE);
-    dataComplete();
-    /* NP: RFC 959  3.3.  DATA CONNECTION MANAGEMENT
-     * if transfer type is 'stream' call dataComplete()
-     * otherwise leave open. (reschedule control channel read?)
-     */
-}
-
 /**
  * A hack to ensure we do not double-complete on the forward entry.
  *
- \todo FtpStateData logic should probably be rewritten to avoid
+ \todo Ftp::Gateway logic should probably be rewritten to avoid
  *	double-completion or FwdState should be rewritten to allow it.
  */
 void
-FtpStateData::completeForwarding()
+Ftp::Gateway::completeForwarding()
 {
     if (fwd == NULL || flags.completed_forwarding) {
         debugs(9, 3, HERE << "completeForwarding avoids " <<
@@ -3810,46 +2738,14 @@ FtpStateData::completeForwarding()
     ServerStateData::completeForwarding();
 }
 
-/**
- * Close the FTP server connection(s). Used by serverComplete().
- */
-void
-FtpStateData::closeServer()
-{
-    if (Comm::IsConnOpen(ctrl.conn)) {
-        debugs(9,3, HERE << "closing FTP server FD " << ctrl.conn->fd << ", this " << this);
-        fwd->unregister(ctrl.conn);
-        ctrl.close();
-    }
-
-    if (Comm::IsConnOpen(data.conn)) {
-        debugs(9,3, HERE << "closing FTP data FD " << data.conn->fd << ", this " << this);
-        data.close();
-    }
-
-    debugs(9,3, HERE << "FTP ctrl and data connections closed. this " << this);
-}
-
-/**
- * Did we close all FTP server connection(s)?
- *
- \retval true	Both server control and data channels are closed. And not waiting for a new data connection to open.
- \retval false	Either control channel or data is still active.
- */
-bool
-FtpStateData::doneWithServer() const
-{
-    return !Comm::IsConnOpen(ctrl.conn) && !Comm::IsConnOpen(data.conn);
-}
-
 /**
  * Have we lost the FTP server control channel?
  *
  \retval true	The server control channel is available.
  \retval false	The server control channel is not available.
  */
 bool
-FtpStateData::haveControlChannel(const char *caller_name) const
+Ftp::Gateway::haveControlChannel(const char *caller_name) const
 {
     if (doneWithServer())
         return false;
@@ -3864,64 +2760,15 @@ FtpStateData::haveControlChannel(const char *caller_name) const
     return true;
 }
 
-/**
- * Quickly abort the transaction
- *
- \todo destruction should be sufficient as the destructor should cleanup,
- *	including canceling close handlers
- */
-void
-FtpStateData::abortTransaction(const char *reason)
-{
-    debugs(9, 3, HERE << "aborting transaction for " << reason <<
-           "; FD " << (ctrl.conn!=NULL?ctrl.conn->fd:-1) << ", Data FD " << (data.conn!=NULL?data.conn->fd:-1) << ", this " << this);
-    if (Comm::IsConnOpen(ctrl.conn)) {
-        ctrl.conn->close();
-        return;
-    }
-
-    fwd->handleUnregisteredServerEnd();
-    mustStop("FtpStateData::abortTransaction");
-}
-
-/// creates a data channel Comm close callback
-AsyncCall::Pointer
-FtpStateData::dataCloser()
-{
-    typedef CommCbMemFunT<FtpStateData, CommCloseCbParams> Dialer;
-    return JobCallback(9, 5, Dialer, this, FtpStateData::dataClosed);
-}
-
-/// configures the channel with a descriptor and registers a close handler
-void
-FtpChannel::opened(const Comm::ConnectionPointer &newConn, const AsyncCall::Pointer &aCloser)
-{
-    assert(!Comm::IsConnOpen(conn));
-    assert(closer == NULL);
-
-    assert(Comm::IsConnOpen(newConn));
-    assert(aCloser != NULL);
-
-    conn = newConn;
-    closer = aCloser;
-    comm_add_close_handler(conn->fd, closer);
-}
-
-/// planned close: removes the close handler and calls comm_close
-void
-FtpChannel::close()
+bool
+Ftp::Gateway::mayReadVirginReplyBody() const
 {
-    // channels with active listeners will be closed when the listener handler dies.
-    if (Comm::IsConnOpen(conn)) {
-        comm_remove_close_handler(conn->fd, closer);
-        conn->close(); // we do not expect to be called back
-    }
-    clear();
+    // TODO: Can we do what Ftp::Relay::mayReadVirginReplyBody() does instead?
+    return !doneWithServer();
 }
 
-void
-FtpChannel::clear()
+AsyncJob::Pointer
+Ftp::StartGateway(FwdState *const fwdState)
 {
-    conn = NULL;
-    closer = NULL;
+    return AsyncJob::Start(new Ftp::Gateway(fwdState));
 }
@@ -0,0 +1,700 @@
+/*
+ * DEBUG: section 09    File Transfer Protocol (FTP)
+ *
+ */
+
+#include "squid.h"
+#include "anyp/PortCfg.h"
+#include "client_side.h"
+#include "clients/forward.h"
+#include "clients/FtpClient.h"
+#include "ftp/Elements.h"
+#include "ftp/Parsing.h"
+#include "HttpHdrCc.h"
+#include "HttpRequest.h"
+#include "SBuf.h"
+#include "Server.h"
+#include "servers/FtpServer.h"
+#include "SquidTime.h"
+#include "Store.h"
+#include "wordlist.h"
+
+namespace Ftp
+{
+
+/// An FTP client receiving native FTP commands from our FTP server
+/// (Ftp::Server), forwarding them to the next FTP hop,
+/// and then relaying FTP replies back to our FTP server.
+class Relay: public Ftp::Client
+{
+public:
+    explicit Relay(FwdState *const fwdState);
+    virtual ~Relay();
+
+protected:
+    const Ftp::MasterState &master() const;
+    Ftp::MasterState &updateMaster();
+    Ftp::ServerState serverState() const { return master().serverState; }
+    void serverState(const Ftp::ServerState newState);
+
+    /* Ftp::Client API */
+    virtual void failed(err_type error = ERR_NONE, int xerrno = 0);
+    virtual void dataChannelConnected(const CommConnectCbParams &io);
+
+    /* ServerStateData API */
+    virtual void serverComplete();
+    virtual void handleControlReply();
+    virtual void processReplyBody();
+    virtual void handleRequestBodyProducerAborted();
+    virtual bool mayReadVirginReplyBody() const;
+    virtual void completeForwarding();
+
+    /* AsyncJob API */
+    virtual void start();
+
+    void forwardReply();
+    void forwardError(err_type error = ERR_NONE, int xerrno = 0);
+    void failedErrorMessage(err_type error, int xerrno);
+    HttpReply *createHttpReply(const Http::StatusCode httpStatus, const int64_t clen = 0);
+    void handleDataRequest();
+    void startDataDownload();
+    void startDataUpload();
+    bool startDirTracking();
+    void stopDirTracking();
+    bool weAreTrackingDir() const {return savedReply.message != NULL;}
+
+    typedef void (Relay::*PreliminaryCb)();
+    void forwardPreliminaryReply(const PreliminaryCb cb);
+    void proceedAfterPreliminaryReply();
+    PreliminaryCb thePreliminaryCb;
+
+    typedef void (Relay::*SM_FUNC)();
+    static const SM_FUNC SM_FUNCS[];
+    void readGreeting();
+    void sendCommand();
+    void readReply();
+    void readFeatReply();
+    void readPasvReply();
+    void readDataReply();
+    void readTransferDoneReply();
+    void readEpsvReply();
+    void readCwdOrCdupReply();
+    void readUserOrPassReply();
+
+    void scheduleReadControlReply();
+
+    bool forwardingCompleted; ///< completeForwarding() has been called
+
+    struct {
+        wordlist *message; ///< reply message, one  wordlist entry per message line
+        char *lastCommand; ///< the command caused the reply
+        char *lastReply; ///< last line of reply: reply status plus message
+        int replyCode; ///< the reply status
+    } savedReply; ///< set and delayed while we are tracking using PWD
+
+    CBDATA_CLASS2(Relay);
+};
+
+} // namespace Ftp
+
+CBDATA_NAMESPACED_CLASS_INIT(Ftp, Relay);
+
+const Ftp::Relay::SM_FUNC Ftp::Relay::SM_FUNCS[] = {
+    &Ftp::Relay::readGreeting, // BEGIN
+    &Ftp::Relay::readUserOrPassReply, // SENT_USER
+    &Ftp::Relay::readUserOrPassReply, // SENT_PASS
+    NULL,/* &Ftp::Relay::readReply */ // SENT_TYPE
+    NULL,/* &Ftp::Relay::readReply */ // SENT_MDTM
+    NULL,/* &Ftp::Relay::readReply */ // SENT_SIZE
+    NULL, // SENT_EPRT
+    NULL, // SENT_PORT
+    &Ftp::Relay::readEpsvReply, // SENT_EPSV_ALL
+    &Ftp::Relay::readEpsvReply, // SENT_EPSV_1
+    &Ftp::Relay::readEpsvReply, // SENT_EPSV_2
+    &Ftp::Relay::readPasvReply, // SENT_PASV
+    &Ftp::Relay::readCwdOrCdupReply,  // SENT_CWD
+    NULL,/* &Ftp::Relay::readDataReply, */ // SENT_LIST
+    NULL,/* &Ftp::Relay::readDataReply, */ // SENT_NLST
+    NULL,/* &Ftp::Relay::readReply */ // SENT_REST
+    NULL,/* &Ftp::Relay::readDataReply */ // SENT_RETR
+    NULL,/* &Ftp::Relay::readReply */ // SENT_STOR
+    NULL,/* &Ftp::Relay::readReply */ // SENT_QUIT
+    &Ftp::Relay::readTransferDoneReply, // READING_DATA
+    &Ftp::Relay::readReply, // WRITING_DATA
+    NULL,/* &Ftp::Relay::readReply */ // SENT_MKDIR
+    &Ftp::Relay::readFeatReply, // SENT_FEAT
+    NULL,/* &Ftp::Relay::readPwdReply */ // SENT_PWD
+    &Ftp::Relay::readCwdOrCdupReply, // SENT_CDUP
+    &Ftp::Relay::readDataReply,// SENT_DATA_REQUEST
+    &Ftp::Relay::readReply, // SENT_COMMAND
+    NULL
+};
+
+Ftp::Relay::Relay(FwdState *const fwdState):
+        AsyncJob("Ftp::Relay"),
+        Ftp::Client(fwdState),
+        forwardingCompleted(false)
+{
+    savedReply.message = NULL;
+    savedReply.lastCommand = NULL;
+    savedReply.lastReply = NULL;
+    savedReply.replyCode = 0;
+
+    // Nothing we can do at request creation time can mark the response as
+    // uncachable, unfortunately. This prevents "found KEY_PRIVATE" WARNINGs.
+    entry->releaseRequest();
+}
+
+Ftp::Relay::~Relay()
+{
+    closeServer(); // TODO: move to Server.cc?
+    if (savedReply.message)
+        wordlistDestroy(&savedReply.message);
+
+    xfree(savedReply.lastCommand);
+    xfree(savedReply.lastReply);
+}
+
+void
+Ftp::Relay::start()
+{
+    if (!master().clientReadGreeting)
+        Ftp::Client::start();
+    else if (serverState() == fssHandleDataRequest ||
+             serverState() == fssHandleUploadRequest)
+        handleDataRequest();
+    else
+        sendCommand();
+}
+
+/// Keep control connection for future requests, after we are done with it.
+/// Similar to COMPLETE_PERSISTENT_MSG handling in http.cc.
+void
+Ftp::Relay::serverComplete()
+{
+    CbcPointer<ConnStateData> &mgr = fwd->request->clientConnectionManager;
+    if (mgr.valid()) {
+        if (Comm::IsConnOpen(ctrl.conn)) {
+            debugs(9, 7, "completing FTP server " << ctrl.conn <<
+                   " after " << ctrl.replycode);
+            fwd->unregister(ctrl.conn);
+            if (ctrl.replycode == 221) { // Server sends FTP 221 before closing
+                mgr->unpinConnection(false);
+                ctrl.close();
+            } else {
+                mgr->pinConnection(ctrl.conn, fwd->request,
+                                   ctrl.conn->getPeer(),
+                                   fwd->request->flags.connectionAuth);
+                ctrl.forget();
+            }
+        }
+    }
+    Ftp::Client::serverComplete();
+}
+
+/// Safely returns the master state,
+/// with safety checks in case the Ftp::Server side of the master xact is gone.
+Ftp::MasterState &
+Ftp::Relay::updateMaster()
+{
+    CbcPointer<ConnStateData> &mgr = fwd->request->clientConnectionManager;
+    if (mgr.valid()) {
+        if (Ftp::Server *srv = dynamic_cast<Ftp::Server*>(mgr.get()))
+            return *srv->master;
+    }
+    // this code will not be necessary once the master is inside MasterXaction
+    debugs(9, 3, "our server side is gone: " << mgr);
+    static Ftp::MasterState Master;
+    Master = Ftp::MasterState();
+    return Master;
+}
+
+/// A const variant of updateMaster().
+const Ftp::MasterState &
+Ftp::Relay::master() const
+{
+    return const_cast<Ftp::Relay*>(this)->updateMaster(); // avoid code dupe
+}
+
+/// Changes server state and debugs about that important event.
+void
+Ftp::Relay::serverState(const Ftp::ServerState newState)
+{
+    Ftp::ServerState &cltState = updateMaster().serverState;
+    debugs(9, 3, "client state was " << cltState << " now: " << newState);
+    cltState = newState;
+}
+
+/**
+ * Ensure we do not double-complete on the forward entry.
+ * We complete forwarding when the response adaptation is over
+ * (but we may still be waiting for 226 from the FTP server) and
+ * also when we get that 226 from the server (and adaptation is done).
+ *
+ \todo Rewrite FwdState to ignore double completion?
+ */
+void
+Ftp::Relay::completeForwarding()
+{
+    debugs(9, 5, forwardingCompleted);
+    if (forwardingCompleted)
+        return;
+    forwardingCompleted = true;
+    Ftp::Client::completeForwarding();
+}
+
+void
+Ftp::Relay::failed(err_type error, int xerrno)
+{
+    if (!doneWithServer())
+        serverState(fssError);
+
+    // TODO: we need to customize ErrorState instead
+    if (entry->isEmpty())
+        failedErrorMessage(error, xerrno); // as a reply
+
+    Ftp::Client::failed(error, xerrno);
+}
+
+void
+Ftp::Relay::failedErrorMessage(err_type error, int xerrno)
+{
+    const Http::StatusCode httpStatus = failedHttpStatus(error);
+    HttpReply *const reply = createHttpReply(httpStatus);
+    entry->replaceHttpReply(reply);
+    EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
+    fwd->request->detailError(error, xerrno);
+}
+
+void
+Ftp::Relay::processReplyBody()
+{
+    debugs(9, 3, status());
+
+    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
+        /*
+         * probably was aborted because content length exceeds one
+         * of the maximum size limits.
+         */
+        abortTransaction("entry aborted after calling appendSuccessHeader()");
+        return;
+    }
+
+#if USE_ADAPTATION
+
+    if (adaptationAccessCheckPending) {
+        debugs(9, 3, "returning due to adaptationAccessCheckPending");
+        return;
+    }
+
+#endif
+
+    if (data.readBuf != NULL && data.readBuf->hasContent()) {
+        const mb_size_t csize = data.readBuf->contentSize();
+        debugs(9, 5, "writing " << csize << " bytes to the reply");
+        addVirginReplyBody(data.readBuf->content(), csize);
+        data.readBuf->consume(csize);
+    }
+
+    entry->flush();
+
+    maybeReadVirginBody();
+}
+
+void
+Ftp::Relay::handleControlReply()
+{
+    if (!request->clientConnectionManager.valid()) {
+        debugs(9, 5, "client connection gone");
+        closeServer();
+        return;
+    }
+
+    Ftp::Client::handleControlReply();
+    if (ctrl.message == NULL)
+        return; // didn't get complete reply yet
+
+    assert(state < END);
+    assert(this->SM_FUNCS[state] != NULL);
+    (this->*SM_FUNCS[state])();
+}
+
+void
+Ftp::Relay::handleRequestBodyProducerAborted()
+{
+    ::ServerStateData::handleRequestBodyProducerAborted();
+
+    failed(ERR_READ_ERROR);
+}
+
+bool
+Ftp::Relay::mayReadVirginReplyBody() const
+{
+    // TODO: move this method to the regular FTP server?
+    return Comm::IsConnOpen(data.conn);
+}
+
+void
+Ftp::Relay::forwardReply()
+{
+    assert(entry->isEmpty());
+    EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
+
+    HttpReply *const reply = createHttpReply(Http::scNoContent);
+
+    setVirginReply(reply);
+    adaptOrFinalizeReply();
+
+    serverComplete();
+}
+
+void
+Ftp::Relay::forwardPreliminaryReply(const PreliminaryCb cb)
+{
+    debugs(9, 5, "forwarding preliminary reply to client");
+
+    // we must prevent concurrent ConnStateData::sendControlMsg() calls
+    Must(thePreliminaryCb == NULL);
+    thePreliminaryCb = cb;
+
+    const HttpReply::Pointer reply = createHttpReply(Http::scContinue);
+
+    // the Sink will use this to call us back after writing 1xx to the client
+    typedef NullaryMemFunT<Relay> CbDialer;
+    const AsyncCall::Pointer call = JobCallback(11, 3, CbDialer, this,
+                                    Ftp::Relay::proceedAfterPreliminaryReply);
+
+    CallJobHere1(9, 4, request->clientConnectionManager, ConnStateData,
+                 ConnStateData::sendControlMsg, HttpControlMsg(reply, call));
+}
+
+void
+Ftp::Relay::proceedAfterPreliminaryReply()
+{
+    debugs(9, 5, "proceeding after preliminary reply to client");
+
+    Must(thePreliminaryCb != NULL);
+    const PreliminaryCb cb = thePreliminaryCb;
+    thePreliminaryCb = NULL;
+    (this->*cb)();
+}
+
+void
+Ftp::Relay::forwardError(err_type error, int xerrno)
+{
+    failed(error, xerrno);
+}
+
+HttpReply *
+Ftp::Relay::createHttpReply(const Http::StatusCode httpStatus, const int64_t clen)
+{
+    HttpReply *const reply = Ftp::HttpReplyWrapper(ctrl.replycode, ctrl.last_reply, httpStatus, clen);
+    if (ctrl.message) {
+        for (wordlist *W = ctrl.message; W && W->next; W = W->next)
+            reply->header.putStr(HDR_FTP_PRE, httpHeaderQuoteString(W->key).c_str());
+        // no hdrCacheInit() is needed for after HDR_FTP_PRE addition
+    }
+    return reply;
+}
+
+void
+Ftp::Relay::handleDataRequest()
+{
+    data.addr(master().clientDataAddr);
+    connectDataChannel();
+}
+
+void
+Ftp::Relay::startDataDownload()
+{
+    assert(Comm::IsConnOpen(data.conn));
+
+    debugs(9, 3, "begin data transfer from " << data.conn->remote <<
+           " (" << data.conn->local << ")");
+
+    HttpReply *const reply = createHttpReply(Http::scOkay, -1);
+    EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
+    setVirginReply(reply);
+    adaptOrFinalizeReply();
+
+    maybeReadVirginBody();
+    state = READING_DATA;
+}
+
+void
+Ftp::Relay::startDataUpload()
+{
+    assert(Comm::IsConnOpen(data.conn));
+
+    debugs(9, 3, "begin data transfer to " << data.conn->remote <<
+           " (" << data.conn->local << ")");
+
+    if (!startRequestBodyFlow()) { // register to receive body data
+        failed();
+        return;
+    }
+
+    state = WRITING_DATA;
+}
+
+void
+Ftp::Relay::readGreeting()
+{
+    assert(!master().clientReadGreeting);
+
+    switch (ctrl.replycode) {
+    case 220:
+        updateMaster().clientReadGreeting = true;
+        if (serverState() == fssBegin)
+            serverState(fssConnected);
+
+        // Do not forward server greeting to the user because our FTP Server
+        // has greeted the user already. Also, an original origin greeting may
+        // confuse a user that has changed the origin mid-air.
+
+        start();
+        break;
+    case 120:
+        if (NULL != ctrl.message)
+            debugs(9, DBG_IMPORTANT, "FTP server is busy: " << ctrl.message->key);
+        forwardPreliminaryReply(&Ftp::Relay::scheduleReadControlReply);
+        break;
+    default:
+        failed();
+        break;
+    }
+}
+
+void
+Ftp::Relay::sendCommand()
+{
+    if (!fwd->request->header.has(HDR_FTP_COMMAND)) {
+        abortTransaction("Internal error: FTP relay request with no command");
+        return;
+    }
+
+    HttpHeader &header = fwd->request->header;
+    assert(header.has(HDR_FTP_COMMAND));
+    const String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
+    assert(header.has(HDR_FTP_ARGUMENTS));
+    const String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+
+    if (params.size() > 0)
+        debugs(9, 5, "command: " << cmd << ", parameters: " << params);
+    else
+        debugs(9, 5, "command: " << cmd << ", no parameters");
+
+    if (serverState() == fssHandlePasv ||
+            serverState() == fssHandleEpsv ||
+            serverState() == fssHandleEprt ||
+            serverState() == fssHandlePort) {
+        sendPassive();
+        return;
+    }
+
+    SBuf buf;
+    if (params.size() > 0)
+        buf.Printf("%s %s%s", cmd.termedBuf(), params.termedBuf(), Ftp::crlf);
+    else
+        buf.Printf("%s%s", cmd.termedBuf(), Ftp::crlf);
+
+    writeCommand(buf.c_str());
+
+    state =
+        serverState() == fssHandleCdup ? SENT_CDUP :
+        serverState() == fssHandleCwd ? SENT_CWD :
+        serverState() == fssHandleFeat ? SENT_FEAT :
+        serverState() == fssHandleDataRequest ? SENT_DATA_REQUEST :
+        serverState() == fssHandleUploadRequest ? SENT_DATA_REQUEST :
+        serverState() == fssConnected ? SENT_USER :
+        serverState() == fssHandlePass ? SENT_PASS :
+        SENT_COMMAND;
+}
+
+void
+Ftp::Relay::readReply()
+{
+    assert(serverState() == fssConnected ||
+           serverState() == fssHandleUploadRequest);
+
+    if (100 <= ctrl.replycode && ctrl.replycode < 200)
+        forwardPreliminaryReply(&Ftp::Relay::scheduleReadControlReply);
+    else
+        forwardReply();
+}
+
+void
+Ftp::Relay::readFeatReply()
+{
+    assert(serverState() == fssHandleFeat);
+
+    if (100 <= ctrl.replycode && ctrl.replycode < 200)
+        return; // ignore preliminary replies
+
+    forwardReply();
+}
+
+void
+Ftp::Relay::readPasvReply()
+{
+    assert(serverState() == fssHandlePasv || serverState() == fssHandleEpsv || serverState() == fssHandlePort || serverState() == fssHandleEprt);
+
+    if (100 <= ctrl.replycode && ctrl.replycode < 200)
+        return; // ignore preliminary replies
+
+    if (handlePasvReply(updateMaster().clientDataAddr))
+        forwardReply();
+    else
+        forwardError();
+}
+
+void
+Ftp::Relay::readEpsvReply()
+{
+    if (100 <= ctrl.replycode && ctrl.replycode < 200)
+        return; // ignore preliminary replies
+
+    if (handleEpsvReply(updateMaster().clientDataAddr)) {
+        if (ctrl.message == NULL)
+            return; // didn't get complete reply yet
+
+        forwardReply();
+    } else
+        forwardError();
+}
+
+void
+Ftp::Relay::readDataReply()
+{
+    assert(serverState() == fssHandleDataRequest ||
+           serverState() == fssHandleUploadRequest);
+
+    if (ctrl.replycode == 125 || ctrl.replycode == 150) {
+        if (serverState() == fssHandleDataRequest)
+            forwardPreliminaryReply(&Ftp::Relay::startDataDownload);
+        else // serverState() == fssHandleUploadRequest
+            forwardPreliminaryReply(&Ftp::Relay::startDataUpload);
+    } else
+        forwardReply();
+}
+
+bool
+Ftp::Relay::startDirTracking()
+{
+    if (!fwd->request->clientConnectionManager->port->ftp_track_dirs)
+        return false;
+
+    debugs(9, 5, "start directory tracking");
+    savedReply.message = ctrl.message;
+    savedReply.lastCommand = ctrl.last_command;
+    savedReply.lastReply = ctrl.last_reply;
+    savedReply.replyCode = ctrl.replycode;
+
+    ctrl.last_command = NULL;
+    ctrl.last_reply = NULL;
+    ctrl.message = NULL;
+    ctrl.offset = 0;
+    writeCommand("PWD\r\n");
+    return true;
+}
+
+void
+Ftp::Relay::stopDirTracking()
+{
+    debugs(9, 5, "got code from pwd: " << ctrl.replycode << ", msg: " << ctrl.last_reply);
+
+    if (ctrl.replycode == 257)
+        updateMaster().workingDir = Ftp::UnescapeDoubleQuoted(ctrl.last_reply);
+
+    wordlistDestroy(&ctrl.message);
+    safe_free(ctrl.last_command);
+    safe_free(ctrl.last_reply);
+
+    ctrl.message = savedReply.message;
+    ctrl.last_command = savedReply.lastCommand;
+    ctrl.last_reply = savedReply.lastReply;
+    ctrl.replycode = savedReply.replyCode;
+
+    savedReply.message = NULL;
+    savedReply.lastReply = NULL;
+    savedReply.lastCommand = NULL;
+}
+
+void
+Ftp::Relay::readCwdOrCdupReply()
+{
+    assert(serverState() == fssHandleCwd ||
+           serverState() == fssHandleCdup);
+
+    debugs(9, 5, "got code " << ctrl.replycode << ", msg: " << ctrl.last_reply);
+
+    if (100 <= ctrl.replycode && ctrl.replycode < 200)
+        return;
+
+    if (weAreTrackingDir()) { // we are tracking
+        stopDirTracking(); // and forward the delayed response below
+    } else if (startDirTracking())
+        return;
+
+    forwardReply();
+}
+
+void
+Ftp::Relay::readUserOrPassReply()
+{
+    if (100 <= ctrl.replycode && ctrl.replycode < 200)
+        return; //Just ignore
+
+    if (weAreTrackingDir()) { // we are tracking
+        stopDirTracking(); // and forward the delayed response below
+    } else if (ctrl.replycode == 230) { // successful login
+        if (startDirTracking())
+            return;
+    }
+
+    forwardReply();
+}
+
+void
+Ftp::Relay::readTransferDoneReply()
+{
+    debugs(9, 3, status());
+
+    if (ctrl.replycode != 226 && ctrl.replycode != 250) {
+        debugs(9, DBG_IMPORTANT, "got FTP code " << ctrl.replycode <<
+               " after reading response data");
+    }
+
+    serverComplete();
+}
+
+void
+Ftp::Relay::dataChannelConnected(const CommConnectCbParams &io)
+{
+    debugs(9, 3, status());
+    data.opener = NULL;
+
+    if (io.flag != Comm::OK) {
+        debugs(9, 2, "failed to connect FTP server data channel");
+        forwardError(ERR_CONNECT_FAIL, io.xerrno);
+        return;
+    }
+
+    debugs(9, 2, "connected FTP server data channel: " << io.conn);
+
+    data.opened(io.conn, dataCloser());
+
+    sendCommand();
+}
+
+void
+Ftp::Relay::scheduleReadControlReply()
+{
+    Ftp::Client::scheduleReadControlReply(0);
+}
+
+AsyncJob::Pointer
+Ftp::StartRelay(FwdState *const fwdState)
+{
+    return AsyncJob::Start(new Ftp::Relay(fwdState));
+}
@@ -0,0 +1,11 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libclients.la
+
+libclients_la_SOURCES = \
+	FtpClient.cc \
+	FtpClient.h \
+	FtpGateway.cc \
+	FtpRelay.cc \
+	forward.h
@@ -0,0 +1,34 @@
+#ifndef SQUID_CLIENTS_FORWARD_H
+#define SQUID_CLIENTS_FORWARD_H
+
+class FwdState;
+class HttpRequest;
+
+class AsyncJob;
+template <class Cbc> class CbcPointer;
+typedef CbcPointer<AsyncJob> AsyncJobPointer;
+
+namespace Ftp
+{
+
+/// A new FTP Gateway job
+AsyncJobPointer StartGateway(FwdState *const fwdState);
+
+/// A new FTP Relay job
+AsyncJobPointer StartRelay(FwdState *const fwdState);
+
+/** Construct an URI with leading / in PATH portion for use by CWD command
+ *  possibly others. FTP encodes absolute paths as beginning with '/'
+ *  after the initial URI path delimiter, which happens to be / itself.
+ *  This makes FTP absolute URI appear as:  ftp:host:port//root/path
+ *  To encompass older software which compacts multiple // to / in transit
+ *  We use standard URI-encoding on the second / making it
+ *  ftp:host:port/%2froot/path  AKA 'the FTP %2f hack'.
+ *
+ * \todo Should be a URL class API call.
+ */
+const char *UrlWith2f(HttpRequest *);
+
+} // namespace Ftp
+
+#endif /* SQUID_CLIENTS_FORWARD_H */
@@ -31,13 +31,13 @@
  */
 #include "squid.h"
 #include "cache_cf.h"
+#include "clients/forward.h"
 #include "comm/Connection.h"
 #include "comm/Write.h"
 #include "disk.h"
 #include "err_detail_type.h"
 #include "errorpage.h"
 #include "fde.h"
-#include "ftp.h"
 #include "html_quote.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -643,14 +643,7 @@ errorAppendEntry(StoreEntry * entry, ErrorState * err)
         }
     }
 
-    entry->lock("errorAppendEntry");
-    entry->buffer();
-    entry->replaceHttpReply( err->BuildHttpReply() );
-    entry->flush();
-    entry->complete();
-    entry->negativeCache();
-    entry->releaseRequest();
-    entry->unlock("errorAppendEntry");
+    entry->storeErrorResponse(err->BuildHttpReply());
     delete err;
 }
 
@@ -831,7 +824,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'B':
         if (building_deny_info_url) break;
-        p = request ? ftpUrlWith2f(request) : "[no URL]";
+        p = request ? Ftp::UrlWith2f(request) : "[no URL]";
         break;
 
     case 'c':
@@ -274,130 +274,125 @@ Format::Token::parse(const char *def, Quoting *quoting)
             --l;
         }
 
-        goto done;
-    }
-
-    if (!*cur)
-        goto done;
-
-    ++cur;
-
-    // select quoting style for his particular token
-    switch (*cur) {
-
-    case '"':
-        quote = LOG_QUOTE_QUOTES;
-        ++cur;
-        break;
+    } else if (*cur) {
 
-    case '\'':
-        quote = LOG_QUOTE_RAW;
         ++cur;
-        break;
 
-    case '[':
-        quote = LOG_QUOTE_MIMEBLOB;
-        ++cur;
-        break;
+        // select quoting style for his particular token
+        switch (*cur) {
 
-    case '#':
-        quote = LOG_QUOTE_URL;
-        ++cur;
-        break;
-
-    default:
-        quote = *quoting;
-        break;
-    }
+        case '"':
+            quote = LOG_QUOTE_QUOTES;
+            ++cur;
+            break;
 
-    if (*cur == '-') {
-        left = true;
-        ++cur;
-    }
+        case '\'':
+            quote = LOG_QUOTE_RAW;
+            ++cur;
+            break;
 
-    if (*cur == '0') {
-        zero = true;
-        ++cur;
-    }
+        case '[':
+            quote = LOG_QUOTE_MIMEBLOB;
+            ++cur;
+            break;
 
-    char *endp;
-    if (xisdigit(*cur)) {
-        widthMin = strtol(cur, &endp, 10);
-        cur = endp;
-    }
+        case '#':
+            quote = LOG_QUOTE_URL;
+            ++cur;
+            break;
 
-    if (*cur == '.' && xisdigit(*(++cur))) {
-        widthMax = strtol(cur, &endp, 10);
-        cur = endp;
-    }
+        default:
+            quote = *quoting;
+            break;
+        }
 
-    if (*cur == '{') {
-        char *cp;
-        ++cur;
-        l = strcspn(cur, "}");
-        cp = (char *)xmalloc(l + 1);
-        xstrncpy(cp, cur, l + 1);
-        data.string = cp;
-        cur += l;
+        if (*cur == '-') {
+            left = true;
+            ++cur;
+        }
 
-        if (*cur == '}')
+        if (*cur == '0') {
+            zero = true;
             ++cur;
-    }
+        }
 
-    type = LFT_NONE;
-
-    // Scan each registered token namespace
-    debugs(46, 9, HERE << "check for token in " << TheConfig.tokens.size() << " namespaces.");
-    for (std::list<TokenNamespace>::const_iterator itr = TheConfig.tokens.begin(); itr != TheConfig.tokens.end(); ++itr) {
-        debugs(46, 7, HERE << "check for possible " << itr->prefix << ":: token");
-        const size_t len = itr->prefix.size();
-        if (itr->prefix.cmp(cur, len) == 0 && cur[len] == ':' && cur[len+1] == ':') {
-            debugs(46, 5, HERE << "check for " << itr->prefix << ":: token in '" << cur << "'");
-            const char *old = cur;
-            cur = scanForToken(itr->tokenSet, cur+len+2);
-            if (old != cur) // found
-                break;
-            else // reset to start of namespace
-                cur = cur - len - 2;
+        char *endp;
+        if (xisdigit(*cur)) {
+            widthMin = strtol(cur, &endp, 10);
+            cur = endp;
         }
-    }
 
-    if (type == LFT_NONE) {
-        // For upward compatibility, assume "http::" prefix as default prefix
-        // for all log access formatting codes, except those starting with a
-        // "%" or a known namespace. (ie "icap::", "adapt::")
-        if (strncmp(cur,"http::", 6) == 0 && *(cur+6) != '%' )
-            cur += 6;
+        if (*cur == '.' && xisdigit(*(++cur))) {
+            widthMax = strtol(cur, &endp, 10);
+            cur = endp;
+        }
 
-        // NP: scan the sets of tokens in decreasing size to guarantee no
-        //     mistakes made with overlapping names. (Bug 3310)
+        if (*cur == '{') {
+            char *cp;
+            ++cur;
+            l = strcspn(cur, "}");
+            cp = (char *)xmalloc(l + 1);
+            xstrncpy(cp, cur, l + 1);
+            data.string = cp;
+            cur += l;
+
+            if (*cur == '}')
+                ++cur;
+        }
 
-        // Scan for various long tokens
-        debugs(46, 5, HERE << "scan for possible Misc token");
-        cur = scanForToken(TokenTableMisc, cur);
-        // scan for 2-char tokens
-        if (type == LFT_NONE) {
-            debugs(46, 5, HERE << "scan for possible 2C token");
-            cur = scanForToken(TokenTable2C, cur);
+        type = LFT_NONE;
+
+        // Scan each registered token namespace
+        debugs(46, 9, HERE << "check for token in " << TheConfig.tokens.size() << " namespaces.");
+        for (std::list<TokenNamespace>::const_iterator itr = TheConfig.tokens.begin(); itr != TheConfig.tokens.end(); ++itr) {
+            debugs(46, 7, HERE << "check for possible " << itr->prefix << ":: token");
+            const size_t len = itr->prefix.size();
+            if (itr->prefix.cmp(cur, len) == 0 && cur[len] == ':' && cur[len+1] == ':') {
+                debugs(46, 5, HERE << "check for " << itr->prefix << ":: token in '" << cur << "'");
+                const char *old = cur;
+                cur = scanForToken(itr->tokenSet, cur+len+2);
+                if (old != cur) // found
+                    break;
+                else // reset to start of namespace
+                    cur = cur - len - 2;
+            }
         }
-        // finally scan for 1-char tokens.
+
         if (type == LFT_NONE) {
-            debugs(46, 5, HERE << "scan for possible 1C token");
-            cur = scanForToken(TokenTable1C, cur);
+            // For upward compatibility, assume "http::" prefix as default prefix
+            // for all log access formatting codes, except those starting with a
+            // "%" or a known namespace. (ie "icap::", "adapt::")
+            if (strncmp(cur,"http::", 6) == 0 && *(cur+6) != '%' )
+                cur += 6;
+
+            // NP: scan the sets of tokens in decreasing size to guarantee no
+            //     mistakes made with overlapping names. (Bug 3310)
+
+            // Scan for various long tokens
+            debugs(46, 5, HERE << "scan for possible Misc token");
+            cur = scanForToken(TokenTableMisc, cur);
+            // scan for 2-char tokens
+            if (type == LFT_NONE) {
+                debugs(46, 5, HERE << "scan for possible 2C token");
+                cur = scanForToken(TokenTable2C, cur);
+            }
+            // finally scan for 1-char tokens.
+            if (type == LFT_NONE) {
+                debugs(46, 5, HERE << "scan for possible 1C token");
+                cur = scanForToken(TokenTable1C, cur);
+            }
         }
-    }
 
-    if (type == LFT_NONE) {
-        fatalf("Can't parse configuration token: '%s'\n", def);
-    }
+        if (type == LFT_NONE) {
+            fatalf("Can't parse configuration token: '%s'\n", def);
+        }
 
-    if (*cur == ' ') {
-        space = true;
-        ++cur;
+        if (*cur == ' ') {
+            space = true;
+            ++cur;
+        }
     }
 
-done:
-
     switch (type) {
 
 #if USE_ADAPTATION
@@ -1,48 +0,0 @@
-/*
- * DEBUG: section 09    File Transfer Protocol (FTP)
- * AUTHOR: Harvest Derived
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#ifndef SQUID_FTP_H_
-#define SQUID_FTP_H_
-
-class FwdState;
-
-/**
- * \defgroup ServerProtocolFTPAPI Server-Side FTP API
- * \ingroup ServerProtocol
- */
-
-/// \ingroup ServerProtocolFTPAPI
-void ftpStart(FwdState *);
-/// \ingroup ServerProtocolFTPAPI
-const char *ftpUrlWith2f(HttpRequest *);
-
-#endif /* SQUID_FTP_H_ */
@@ -0,0 +1,187 @@
+/*
+ * DEBUG: section 09    File Transfer Protocol (FTP)
+ */
+
+#include "squid.h"
+#include "ftp/Elements.h"
+#include "HttpHdrCc.h"
+#include "HttpReply.h"
+#include "SBuf.h"
+
+// FTP does not have a notion of a "protocol version" but we need something for
+// compatibility with the current HttpMsg wrapping layer. We use version 1.1:
+// * some ICAP services probably expect /1.0 or /1.1 when parsing HTTP headers;
+// * FTP commands are sent on a "persistent by default" connection, just like
+//   HTTP/1.1. Using 1.1 leads to fewer exceptions in current code shared by
+//   HTTP and FTP.
+AnyP::ProtocolVersion
+Ftp::ProtocolVersion()
+{
+    return AnyP::ProtocolVersion(AnyP::PROTO_FTP, 1, 1);
+}
+
+HttpReply *
+Ftp::HttpReplyWrapper(const int ftpStatus, const char *ftpReason, const Http::StatusCode httpStatus, const int64_t clen)
+{
+    HttpReply *const reply = new HttpReply;
+
+    Http::ProtocolVersion httpVersion = Http::ProtocolVersion(
+                                            Ftp::ProtocolVersion().major, Ftp::ProtocolVersion().minor);
+    reply->sline.set(httpVersion, httpStatus);
+
+    HttpHeader &header = reply->header;
+    header.putTime(HDR_DATE, squid_curtime);
+    {
+        HttpHdrCc cc;
+        cc.Private(String());
+        header.putCc(&cc);
+    }
+    if (ftpStatus > 0)
+        header.putInt(HDR_FTP_STATUS, ftpStatus);
+    if (ftpReason)
+        header.putStr(HDR_FTP_REASON, ftpReason);
+    if (clen >= 0)
+        header.putInt64(HDR_CONTENT_LENGTH, clen);
+    reply->hdrCacheInit();
+    return reply;
+}
+
+const SBuf &
+Ftp::cmdAppe()
+{
+    static const SBuf cmd("APPE");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdAuth()
+{
+    static const SBuf cmd("AUTH");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdCwd()
+{
+    static const SBuf cmd("CWD");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdDele()
+{
+    static const SBuf cmd("DELE");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdEprt()
+{
+    static const SBuf cmd("EPRT");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdEpsv()
+{
+    static const SBuf cmd("EPSV");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdList()
+{
+    static const SBuf cmd("LIST");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdMkd()
+{
+    static const SBuf cmd("MKD");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdMlsd()
+{
+    static const SBuf cmd("MLSD");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdMlst()
+{
+    static const SBuf cmd("MLST");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdNlst()
+{
+    static const SBuf cmd("NLST");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdRetr()
+{
+    static const SBuf cmd("RETR");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdRmd()
+{
+    static const SBuf cmd("RMD");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdRnfr()
+{
+    static const SBuf cmd("RNFR");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdRnto()
+{
+    static const SBuf cmd("RNTO");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdSmnt()
+{
+    static const SBuf cmd("SMNT");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdStat()
+{
+    static const SBuf cmd("STAT");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdStor()
+{
+    static const SBuf cmd("STOR");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdStou()
+{
+    static const SBuf cmd("STOU");
+    return cmd;
+}
+
+const SBuf &
+Ftp::cmdUser()
+{
+    static const SBuf cmd("USER");
+    return cmd;
+}
@@ -0,0 +1,47 @@
+#ifndef SQUID_FTP_ELEMENTS_H
+#define SQUID_FTP_ELEMENTS_H
+
+#include "http/StatusCode.h"
+
+class SBuf;
+class HttpReply;
+
+namespace AnyP
+{
+class ProtocolVersion;
+}
+
+namespace Ftp
+{
+
+/// Protocol version to use in HttpMsg structures wrapping FTP messages.
+AnyP::ProtocolVersion ProtocolVersion();
+
+/// Create an internal HttpReply structure to house FTP control response info.
+HttpReply *HttpReplyWrapper(const int ftpStatus, const char *ftpReason, const Http::StatusCode httpStatus, const int64_t clen);
+
+/* FTP Commands used by Squid. ALLCAPS case. Safe for static initializaton. */
+const SBuf &cmdAppe();
+const SBuf &cmdAuth();
+const SBuf &cmdCwd();
+const SBuf &cmdDele();
+const SBuf &cmdEprt();
+const SBuf &cmdEpsv();
+const SBuf &cmdList();
+const SBuf &cmdMkd();
+const SBuf &cmdMlsd();
+const SBuf &cmdMlst();
+const SBuf &cmdNlst();
+const SBuf &cmdRetr();
+const SBuf &cmdRmd();
+const SBuf &cmdRnfr();
+const SBuf &cmdRnto();
+const SBuf &cmdSmnt();
+const SBuf &cmdStat();
+const SBuf &cmdStor();
+const SBuf &cmdStou();
+const SBuf &cmdUser();
+
+} // namespace Ftp
+
+#endif /* SQUID_FTP_ELEMENTS_H */
@@ -0,0 +1,10 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libftp.la
+
+libftp_la_SOURCES = \
+	Elements.cc \
+	Elements.h \
+	Parsing.cc \
+	Parsing.h
@@ -0,0 +1,108 @@
+/*
+ * DEBUG: section 09    File Transfer Protocol (FTP)
+ */
+
+#include "squid.h"
+#include "ftp/Parsing.h"
+#include "ip/Address.h"
+#include "MemBuf.h"
+#include "SquidConfig.h"
+
+bool
+Ftp::ParseIpPort(const char *buf, const char *forceIp, Ip::Address &addr)
+{
+    int h1, h2, h3, h4;
+    int p1, p2;
+    const int n = sscanf(buf, "%d,%d,%d,%d,%d,%d",
+                         &h1, &h2, &h3, &h4, &p1, &p2);
+
+    if (n != 6 || p1 < 0 || p2 < 0 || p1 > 255 || p2 > 255)
+        return false;
+
+    if (forceIp) {
+        addr = forceIp; // but the above code still validates the IP we got
+    } else {
+        static char ipBuf[1024];
+        snprintf(ipBuf, sizeof(ipBuf), "%d.%d.%d.%d", h1, h2, h3, h4);
+        addr = ipBuf;
+
+        if (addr.isAnyAddr())
+            return false;
+    }
+
+    const int port = ((p1 << 8) + p2);
+
+    if (port <= 0)
+        return false;
+
+    if (Config.Ftp.sanitycheck && port < 1024)
+        return false;
+
+    addr.port(port);
+    return true;
+}
+
+bool
+Ftp::ParseProtoIpPort(const char *buf, Ip::Address &addr)
+{
+
+    const char delim = *buf;
+    const char *s = buf + 1;
+    const char *e = s;
+    const int proto = strtol(s, const_cast<char**>(&e), 10);
+    if ((proto != 1 && proto != 2) || *e != delim)
+        return false;
+
+    s = e + 1;
+    e = strchr(s, delim);
+    char ip[MAX_IPSTRLEN];
+    if (static_cast<size_t>(e - s) >= sizeof(ip))
+        return false;
+    strncpy(ip, s, e - s);
+    ip[e - s] = '\0';
+    addr = ip;
+
+    if (addr.isAnyAddr())
+        return false;
+
+    if ((proto == 2) != addr.isIPv6()) // proto ID mismatches address version
+        return false;
+
+    s = e + 1; // skip port delimiter
+    const int port = strtol(s, const_cast<char**>(&e), 10);
+    if (port < 0 || *e != '|')
+        return false;
+
+    if (Config.Ftp.sanitycheck && port < 1024)
+        return false;
+
+    addr.port(port);
+    return true;
+}
+
+const char *
+Ftp::UnescapeDoubleQuoted(const char *quotedPath)
+{
+    static MemBuf path;
+    path.reset();
+    const char *s = quotedPath;
+    if (*s == '"') {
+        ++s;
+        bool parseDone = false;
+        while (!parseDone) {
+            if (const char *e = strchr(s, '"')) {
+                path.append(s, e - s);
+                s = e + 1;
+                if (*s == '"') {
+                    path.append(s, 1);
+                    ++s;
+                } else
+                    parseDone = true;
+            } else { //parse error
+                parseDone = true;
+                path.reset();
+            }
+        }
+    }
+    return path.content();
+}
@@ -0,0 +1,21 @@
+#ifndef SQUID_FTP_PARSING_H
+#define SQUID_FTP_PARSING_H
+
+#include "ip/forward.h"
+
+namespace Ftp
+{
+
+/// parses and validates "A1,A2,A3,A4,P1,P2" IP,port sequence
+bool ParseIpPort(const char *buf, const char *forceIp, Ip::Address &addr);
+
+/// parses and validates EPRT "<d><net-prt><d><net-addr><d><tcp-port><d>"
+/// proto,IP,port sequence
+bool ParseProtoIpPort(const char *buf, Ip::Address &addr);
+
+/// parses an FTP-quoted quote-escaped path
+const char *UnescapeDoubleQuoted(const char *quotedPath);
+
+} // namespace Ftp
+
+#endif /* SQUID_FTP_PARSING_H */
@@ -930,6 +930,7 @@ HttpStateData::haveParsedReplyHeaders()
     if (neighbors_do_private_keys)
         httpMaybeRemovePublic(entry, rep->sline.status());
 
+    bool varyFailure = false;
     if (rep->header.has(HDR_VARY)
 #if X_ACCELERATOR_VARY
             || rep->header.has(HDR_X_ACCELERATOR_VARY)
@@ -941,48 +942,46 @@ HttpStateData::haveParsedReplyHeaders()
             entry->makePrivate();
             if (!fwd->reforwardableStatus(rep->sline.status()))
                 EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
-            goto no_cache;
+            varyFailure = true;
+        } else {
+            entry->mem_obj->vary_headers = xstrdup(vary);
         }
-
-        entry->mem_obj->vary_headers = xstrdup(vary);
     }
 
-    /*
-     * If its not a reply that we will re-forward, then
-     * allow the client to get it.
-     */
-    if (!fwd->reforwardableStatus(rep->sline.status()))
-        EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
+    if (!varyFailure) {
+        /*
+         * If its not a reply that we will re-forward, then
+         * allow the client to get it.
+         */
+        if (!fwd->reforwardableStatus(rep->sline.status()))
+            EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
 
-    switch (cacheableReply()) {
+        switch (cacheableReply()) {
 
-    case 1:
-        entry->makePublic();
-        break;
+        case 1:
+            entry->makePublic();
+            break;
 
-    case 0:
-        entry->makePrivate();
-        break;
+        case 0:
+            entry->makePrivate();
+            break;
 
-    case -1:
+        case -1:
 
 #if USE_HTTP_VIOLATIONS
-        if (Config.negativeTtl > 0)
-            entry->cacheNegatively();
-        else
+            if (Config.negativeTtl > 0)
+                entry->cacheNegatively();
+            else
 #endif
-            entry->makePrivate();
-
-        break;
-
-    default:
-        assert(0);
+                entry->makePrivate();
+            break;
 
-        break;
+        default:
+            assert(0);
+            break;
+        }
     }
 
-no_cache:
-
     if (!ignoreCacheControl) {
         if (rep->cache_control) {
             // We are required to revalidate on many conditions.
@@ -1494,6 +1493,15 @@ HttpStateData::processReplyBody()
     maybeReadVirginBody();
 }
 
+bool
+HttpStateData::mayReadVirginReplyBody() const
+{
+    // TODO: Be more precise here. For example, if/when reading trailer, we may
+    // not be doneWithServer() yet, but we should return false. Similarly, we
+    // could still be writing the request body after receiving the whole reply.
+    return !doneWithServer();
+}
+
 void
 HttpStateData::maybeReadVirginBody()
 {
@@ -110,6 +110,7 @@ class HttpStateData : public ServerStateData
     virtual void closeServer(); // end communication with the server
     virtual bool doneWithServer() const; // did we end communication?
     virtual void abortTransaction(const char *reason); // abnormal termination
+    virtual bool mayReadVirginReplyBody() const;
 
     // consuming request body
     virtual void handleMoreRequestBodyAvailable();
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #define SQUID_HELPER 1
 
 #include "squid.h"
@@ -1,8 +1,6 @@
 #ifndef SQUID_SRC_TEST_URL_H
 #define SQUID_SRC_TEST_URL_H
 
-#define SQUID_UNIT_TEST 1
-
 #include "Icmp.h"
 #include <cppunit/extensions/HelperMacros.h>
 
@@ -37,7 +37,7 @@ class Intercept
      * Detects IPv6 and IPv4 level of support matches the address being listened on
      * and if the compiled v2/v4 is usable as far down as a bind()ing.
      *
-     * \param test    Address set on the http(s)_port being checked.
+     * \param test    Address set on the squid.conf *_port being checked.
      * \retval true   TPROXY is available.
      * \retval false  TPROXY is not available.
      */
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
@@ -14,6 +14,7 @@ Ipc::FdNote(int fdNoteId)
         "None", // fdnNone
         "HTTP Socket", // fdnHttpSocket
         "HTTPS Socket", // fdnHttpsSocket
+        "FTP Socket", // fdnFtpSocket
 #if SQUID_SNMP
         "Incoming SNMP Socket", // fdnInSnmpSocket
         "Outgoing SNMP Socket", // fdnOutSnmpSocket
@@ -12,7 +12,7 @@ namespace Ipc
 /// We cannot send char* FD notes to other processes. Pass int IDs and convert.
 
 /// fd_note() label ID
-typedef enum { fdnNone, fdnHttpSocket, fdnHttpsSocket,
+typedef enum { fdnNone, fdnHttpSocket, fdnHttpsSocket, fdnFtpSocket,
 #if SQUID_SNMP
                fdnInSnmpSocket, fdnOutSnmpSocket,
 #endif
@@ -511,8 +511,10 @@ mainParseOptions(int argc, char *argv[])
                 const SBuf t(optarg);
                 ::Parser::Tokenizer tok(t);
                 const CharacterSet chr = CharacterSet::ALPHA+CharacterSet::DIGIT;
-                if (!tok.prefix(service_name, chr) || !tok.atEnd())
-                    fatalf("Expected alphanumeric service name for the -n option but got: " SQUIDSBUFPH, SQUIDSBUFPRINT(service_name));
+                if (!tok.prefix(service_name, chr))
+                    fatalf("Expected alphanumeric service name for the -n option but got: %s", optarg);
+                if (!tok.atEnd())
+                    fatalf("Garbage after alphanumeric service name in the -n option value: %s", optarg);
                 if (service_name.length() > 32)
                     fatalf("Service name (-n option) must be limited to 32 characters but got %u", service_name.length());
                 opt_signal_service = true;
@@ -730,7 +732,7 @@ serverConnectionsClose(void)
 #endif
     }
     if (IamWorkerProcess()) {
-        clientHttpConnectionsClose();
+        clientConnectionsClose();
         icpConnectionShutdown();
 #if USE_HTCP
         htcpSocketShutdown();
@@ -28,20 +28,35 @@
 #endif
 #endif
 
+/// convenience method: consumes up to n bytes, counts, and returns them
+SBuf
+Parser::Tokenizer::consume(const SBuf::size_type n)
+{
+    // careful: n may be npos!
+    const SBuf result = buf_.consume(n);
+    parsed_ += result.length();
+    return result;
+}
+
+/// convenience method: consume()s up to n bytes and returns their count
+SBuf::size_type
+Parser::Tokenizer::success(const SBuf::size_type n)
+{
+    return consume(n).length();
+}
+
 bool
 Parser::Tokenizer::token(SBuf &returnedToken, const CharacterSet &delimiters)
 {
-    const SBuf savebuf(buf_);
-    skip(delimiters);
+    const Tokenizer saved(*this);
+    skipAll(delimiters);
     const SBuf::size_type tokenLen = buf_.findFirstOf(delimiters); // not found = npos => consume to end
-    if (tokenLen == SBuf::npos && !delimiters['\0']) {
-        // no delimiter found, nor is NUL/EOS/npos acceptible as one
-        buf_ = savebuf;
+    if (tokenLen == SBuf::npos) {
+        *this = saved;
         return false;
     }
-    const SBuf retval = buf_.consume(tokenLen);
-    skip(delimiters);
-    returnedToken = retval;
+    returnedToken = consume(tokenLen); // cannot be empty
+    skipAll(delimiters);
     return true;
 }
 
@@ -51,37 +66,42 @@ Parser::Tokenizer::prefix(SBuf &returnedToken, const CharacterSet &tokenChars, c
     const SBuf::size_type prefixLen = buf_.substr(0,limit).findFirstNotOf(tokenChars);
     if (prefixLen == 0)
         return false;
-    returnedToken = buf_.consume(prefixLen);
+    if (prefixLen == SBuf::npos && (atEnd() || limit == 0))
+        return false;
+    returnedToken = consume(prefixLen); // cannot be empty after the npos check
     return true;
 }
 
-bool
-Parser::Tokenizer::skip(const CharacterSet &tokenChars)
+SBuf::size_type
+Parser::Tokenizer::skipAll(const CharacterSet &tokenChars)
 {
     const SBuf::size_type prefixLen = buf_.findFirstNotOf(tokenChars);
     if (prefixLen == 0)
-        return false;
-    buf_.consume(prefixLen);
-    return true;
+        return 0;
+    return success(prefixLen);
+}
+
+bool
+Parser::Tokenizer::skipOne(const CharacterSet &chars)
+{
+    if (!buf_.isEmpty() && chars[buf_[0]])
+        return success(1);
+    return false;
 }
 
 bool
 Parser::Tokenizer::skip(const SBuf &tokenToSkip)
 {
-    if (buf_.startsWith(tokenToSkip)) {
-        buf_.consume(tokenToSkip.length());
-        return true;
-    }
+    if (buf_.startsWith(tokenToSkip))
+        return success(tokenToSkip.length());
     return false;
 }
 
 bool
 Parser::Tokenizer::skip(const char tokenChar)
 {
-    if (buf_[0] == tokenChar) {
-        buf_.consume(1);
-        return true;
-    }
+    if (!buf_.isEmpty() && buf_[0] == tokenChar)
+        return success(1);
     return false;
 }
 
@@ -156,6 +176,5 @@ Parser::Tokenizer::int64(int64_t & result, int base)
         acc = -acc;
 
     result = acc;
-    buf_.consume(s - buf_.rawContent() -1);
-    return true;
+    return success(s - buf_.rawContent() - 1);
 }
@@ -21,10 +21,13 @@ namespace Parser
 class Tokenizer
 {
 public:
-    explicit Tokenizer(const SBuf &inBuf) : buf_(inBuf) {}
+    explicit Tokenizer(const SBuf &inBuf) : buf_(inBuf), parsed_(0) {}
 
-    // return a copy the current contents of the parse buffer
-    const SBuf buf() const { return buf_; }
+    /// yet unparsed data
+    SBuf buf() const { return buf_; }
+
+    /// number of parsed bytes, including skipped ones
+    SBuf::size_type parsedSize() const { return parsed_; }
 
     /// whether the end of the buffer has been reached
     bool atEnd() const { return buf_.isEmpty(); }
@@ -33,35 +36,32 @@ class Tokenizer
     const SBuf& remaining() const { return buf_; }
 
     /// reinitialize processing for a new buffer
-    void reset(const SBuf &newBuf) { buf_ = newBuf; }
+    void reset(const SBuf &newBuf) { buf_ = newBuf; parsed_ = 0; }
 
     /** Basic strtok(3):
      *  Skips all leading delimiters (if any),
-     *  accumulates all characters up to the next delimiter (a token), and
-     *  skips all trailing delimiters.
+     *  extracts all characters up to the next delimiter (a token), and
+     *  skips all trailing delimiters (at least one must be present).
      *
      *  Want to extract delimiters? Use prefix() instead.
      *
-     * At least one terminating delimiter is required. \0 may be passed
-     * as a delimiter to treat end of buffer content as the end of token.
+     *  Note that Tokenizer cannot tell whether the trailing delimiters will
+     *  continue when/if more input data becomes available later.
      *
-     * \return false if no terminal delimiter is found.
+     * \return true if found a non-empty token followed by a delimiter
      */
     bool token(SBuf &returnedToken, const CharacterSet &delimiters);
 
-    /** Accumulates all sequential permitted characters up to an optional length limit.
+    /** Extracts all sequential permitted characters up to an optional length limit.
+     *
+     *  Note that Tokenizer cannot tell whether the prefix will
+     *  continue when/if more input data becomes available later.
      *
      * \retval true one or more characters were found, the sequence (string) is placed in returnedToken
      * \retval false no characters from the permitted set were found
      */
     bool prefix(SBuf &returnedToken, const CharacterSet &tokenChars, SBuf::size_type limit = SBuf::npos);
 
-    /** skips all sequential characters from the set, in any order
-     *
-     * \return whether one or more characters in the set were found
-     */
-    bool skip(const CharacterSet &tokenChars);
-
     /** skips a given character sequence (string)
      *
      * \return whether the exact character sequence was found and skipped
@@ -70,11 +70,23 @@ class Tokenizer
 
     /** skips a given single character
      *
-     * \return whether the character was found and skipped
+     * \return whether the character was skipped
      */
     bool skip(const char tokenChar);
 
-    /** parse an unsigned int64_t at the beginning of the buffer
+    /** Skips a single character from the set.
+     *
+     * \return whether a character was skipped
+     */
+    bool skipOne(const CharacterSet &discardables);
+
+    /** Skips all sequential characters from the set, in any order.
+     *
+     * \returns the number of skipped characters
+     */
+    SBuf::size_type skipAll(const CharacterSet &discardables);
+
+    /** Extracts an unsigned int64_t at the beginning of the buffer.
      *
      * strtoll(3)-alike function: tries to parse unsigned 64-bit integer
      * at the beginning of the parse buffer, in the base specified by the user
@@ -88,8 +100,13 @@ class Tokenizer
      */
     bool int64(int64_t &result, int base = 0);
 
+protected:
+    SBuf consume(const SBuf::size_type n);
+    SBuf::size_type success(const SBuf::size_type n);
+
 private:
     SBuf buf_; ///< yet unparsed input
+    SBuf::size_type parsed_; ///< bytes successfully parsed, including skipped
 };
 
 } /* namespace Parser */
@@ -18,9 +18,26 @@ const CharacterSet numbers("numbers","0123456789");
 void
 testTokenizer::testTokenizerPrefix()
 {
+    const SBuf canary("This text should not be changed.");
+
     Parser::Tokenizer t(text);
     SBuf s;
 
+    CharacterSet all(whitespace);
+    all += alpha;
+    all += crlf;
+    all += numbers;
+    all.add(':').add('.').add('/');
+
+    // an empty prefix should return false (the full output buffer case)
+    s = canary;
+    const SBuf before = t.remaining();
+    CPPUNIT_ASSERT(!t.prefix(s, all, 0));
+    // ... and a false return value means no parameter changes
+    CPPUNIT_ASSERT_EQUAL(canary, s);
+    // ... and a false return value means no input buffer changes
+    CPPUNIT_ASSERT_EQUAL(before, t.remaining());
+
     // successful prefix tokenization
     CPPUNIT_ASSERT(t.prefix(s,alpha));
     CPPUNIT_ASSERT_EQUAL(SBuf("GET"),s);
@@ -40,13 +57,14 @@ testTokenizer::testTokenizerPrefix()
     CPPUNIT_ASSERT_EQUAL(SBuf("http"),s); //output SBuf left untouched
 
     // match until the end of the sample
-    CharacterSet all(whitespace);
-    all += alpha;
-    all += crlf;
-    all += numbers;
-    all.add(':').add('.').add('/');
     CPPUNIT_ASSERT(t.prefix(s,all));
     CPPUNIT_ASSERT_EQUAL(SBuf(),t.remaining());
+
+    // empty prefix should return false (the empty input buffer case)
+    s = canary;
+    CPPUNIT_ASSERT(!t.prefix(s, all));
+    // ... and a false return value means no parameter changes
+    CPPUNIT_ASSERT_EQUAL(canary, s);
 }
 
 void
@@ -60,8 +78,8 @@ testTokenizer::testTokenizerSkip()
     CPPUNIT_ASSERT(t.prefix(s,alpha));
     CPPUNIT_ASSERT_EQUAL(SBuf("GET"),s);
 
-    // test skip testing character set
-    CPPUNIT_ASSERT(t.skip(whitespace));
+    // test skipping one character from a character set
+    CPPUNIT_ASSERT(t.skipOne(whitespace));
     // check that skip was right
     CPPUNIT_ASSERT(t.prefix(s,alpha));
     CPPUNIT_ASSERT_EQUAL(SBuf("http"),s);
@@ -73,10 +91,14 @@ testTokenizer::testTokenizerSkip()
     CPPUNIT_ASSERT_EQUAL(SBuf("resource"),s);
 
     // no skip
-    CPPUNIT_ASSERT(!t.skip(alpha));
+    CPPUNIT_ASSERT(!t.skipOne(alpha));
     CPPUNIT_ASSERT(!t.skip(SBuf("://")));
     CPPUNIT_ASSERT(!t.skip('a'));
 
+    // test skipping all characters from a character set while looking at .com
+    CPPUNIT_ASSERT(t.skip('.'));
+    CPPUNIT_ASSERT_EQUAL(static_cast<SBuf::size_type>(3), t.skipAll(alpha));
+    CPPUNIT_ASSERT(t.remaining().startsWith(SBuf("/path")));
 }
 
 void
@@ -61,6 +61,7 @@ extern "C" {
 #elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif				/* HAVE_GSSAPI_H */
+#if !USE_HEIMDAL_KRB5
 #if HAVE_GSSAPI_GSSAPI_EXT_H
 #include <gssapi/gssapi_ext.h>
 #endif				/* HAVE_GSSAPI_GSSAPI_EXT_H */
@@ -70,15 +71,16 @@ extern "C" {
 #if HAVE_GSSAPI_GSSAPI_GENERIC_H
 #include <gssapi/gssapi_generic.h>
 #endif				/* HAVE_GSSAPI_GSSAPI_GENERIC_H */
+#endif				/* !USE_HEIMDAL_KRB5 */
 
 #ifndef gss_nt_service_name
 #define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
 #endif
 
-#if !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERR_TEXT
-#define error_message(code) krb5_get_err_text(kparam.context,code)
-#elif  !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERROR_MESSAGE
+#if !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERR_MESSAGE
 #define error_message(code) krb5_get_error_message(kparam.context,code)
+#elif !HAVE_ERROR_MESSAGE && HAVE_KRB5_GET_ERROR_TEXT
+#define error_message(code) krb5_get_err_text(kparam.context,code)
 #elif !HAVE_ERROR_MESSAGE
     static char err_code[17];
     const char *KRB5_CALLCONV
@@ -94,7 +96,7 @@ extern "C" {
     gss_OID gss_mech_spnego = &_gss_mech_spnego;
 #endif
 
-#if HAVE_NAS_KERBEROS
+#if USE_IBM_KERBEROS
 #include <ibm_svc/krb5_svc.h>
     const char *KRB5_CALLCONV error_message(long code) {
         char *msg = NULL;
@@ -210,7 +212,7 @@ extern "C" {
         static krb5_keytab_entry entry;
         static krb5_kt_cursor cursor;
         static krb5_creds *creds = NULL;
-#if HAVE_HEIMDAL_KERBEROS && !HAVE_KRB5_GET_RENEWED_CREDS
+#if USE_HEIMDAL_KRB5 && !HAVE_KRB5_GET_RENEWED_CREDS
         static krb5_creds creds2;
 #endif
         static krb5_principal principal = NULL;
@@ -226,7 +228,7 @@ extern "C" {
 #if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE
         profile_t profile;
 #endif
-#if HAVE_HEIMDAL_KERBEROS && !HAVE_KRB5_GET_RENEWED_CREDS
+#if USE_HEIMDAL_KRB5 && !HAVE_KRB5_GET_RENEWED_CREDS
         krb5_kdc_flags flags;
 #if HAVE_KRB5_PRINCIPAL_GET_REALM
         const char *client_realm;
@@ -329,9 +331,9 @@ extern "C" {
                        error_message(code));
                 return (1);
             }
-#elif HAVE_KRB5_GET_MAX_TIME_SKEW && HAVE_HEIMDAL_KERBEROS
+#elif USE_HEIMDAL_KRB5 && HAVE_KRB5_GET_MAX_TIME_SKEW
             skew = krb5_get_max_time_skew(kparam.context);
-#elif HAVE_MAX_SKEW_IN_KRB5_CONTEXT && HAVE_HEIMDAL_KERBEROS
+#elif USE_HEIMDAL_KRB5 && HAVE_MAX_SKEW_IN_KRB5_CONTEXT
             skew = kparam.context->max_skew;
 #else
             skew = DEFAULT_SKEW;
@@ -384,7 +386,7 @@ extern "C" {
                            error_message(code));
                     return (1);
                 }
-#if HAVE_HEIMDAL_KERBEROS || ( HAVE_KRB5_KT_FREE_ENTRY && HAVE_DECL_KRB5_KT_FREE_ENTRY)
+#if USE_HEIMDAL_KRB5 || ( HAVE_KRB5_KT_FREE_ENTRY && HAVE_DECL_KRB5_KT_FREE_ENTRY)
                 code = krb5_kt_free_entry(kparam.context, &entry);
 #else
                 code = krb5_free_keytab_entry_contents(kparam.context, &entry);
@@ -0,0 +1,1689 @@
+/*
+ * DEBUG: section 33    Transfer protocol servers
+ */
+
+#include "squid.h"
+#include "base/CharacterSet.h"
+#include "base/RefCount.h"
+#include "base/Subscription.h"
+#include "client_side_reply.h"
+#include "client_side_request.h"
+#include "clientStream.h"
+#include "comm/ConnOpener.h"
+#include "comm/Read.h"
+#include "comm/TcpAcceptor.h"
+#include "comm/Write.h"
+#include "errorpage.h"
+#include "fd.h"
+#include "ftp/Elements.h"
+#include "ftp/Parsing.h"
+#include "globals.h"
+#include "HttpHdrCc.h"
+#include "ip/tools.h"
+#include "ipc/FdNotes.h"
+#include "parser/Tokenizer.h"
+#include "servers/forward.h"
+#include "servers/FtpServer.h"
+#include "SquidConfig.h"
+#include "StatCounters.h"
+#include "tools.h"
+
+#include <set>
+#include <map>
+
+CBDATA_NAMESPACED_CLASS_INIT(Ftp, Server);
+
+namespace Ftp
+{
+static void PrintReply(MemBuf &mb, const HttpReply *reply, const char *const prefix = "");
+static bool SupportedCommand(const SBuf &name);
+static bool CommandHasPathParameter(const SBuf &cmd);
+};
+
+Ftp::Server::Server(const MasterXaction::Pointer &xact):
+        AsyncJob("Ftp::Server"),
+        ConnStateData(xact),
+        master(new MasterState),
+        uri(),
+        host(),
+        gotEpsvAll(false),
+        onDataAcceptCall(),
+        dataListenConn(),
+        dataConn(),
+        uploadAvailSize(0),
+        listener(),
+        connector(),
+        reader()
+{
+    flags.readMore = false; // we need to announce ourselves first
+}
+
+Ftp::Server::~Server()
+{
+    closeDataConnection();
+}
+
+int
+Ftp::Server::pipelinePrefetchMax() const
+{
+    return 0; // no support for concurrent FTP requests
+}
+
+time_t
+Ftp::Server::idleTimeout() const
+{
+    return Config.Timeout.ftpClientIdle;
+}
+
+void
+Ftp::Server::start()
+{
+    ConnStateData::start();
+
+    if (transparent()) {
+        char buf[MAX_IPSTRLEN];
+        clientConnection->local.toUrl(buf, MAX_IPSTRLEN);
+        host = buf;
+        calcUri(NULL);
+        debugs(33, 5, "FTP transparent URL: " << uri);
+    }
+
+    writeEarlyReply(220, "Service ready");
+}
+
+/// schedules another data connection read if needed
+void
+Ftp::Server::maybeReadUploadData()
+{
+    if (reader != NULL)
+        return;
+
+    const size_t availSpace = sizeof(uploadBuf) - uploadAvailSize;
+    if (availSpace <= 0)
+        return;
+
+    debugs(33, 4, dataConn << ": reading FTP data...");
+
+    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
+    reader = JobCallback(33, 5, Dialer, this, Ftp::Server::readUploadData);
+    comm_read(dataConn, uploadBuf + uploadAvailSize, availSpace,
+              reader);
+}
+
+/// react to the freshly parsed request
+void
+Ftp::Server::doProcessRequest()
+{
+    // zero pipelinePrefetchMax() ensures that there is only parsed request
+    ClientSocketContext::Pointer context = getCurrentContext();
+    Must(context != NULL);
+    Must(getConcurrentRequestCount() == 1);
+
+    ClientHttpRequest *const http = context->http;
+    assert(http != NULL);
+
+    HttpRequest *const request = http->request;
+    Must(http->storeEntry() || request);
+    const bool mayForward = !http->storeEntry() && handleRequest(request);
+
+    if (http->storeEntry() != NULL) {
+        debugs(33, 4, "got an immediate response");
+        clientSetKeepaliveFlag(http);
+        context->pullData();
+    } else if (mayForward) {
+        debugs(33, 4, "forwarding request to server side");
+        assert(http->storeEntry() == NULL);
+        clientProcessRequest(this, NULL /*parser*/, context.getRaw(),
+                             request->method, request->http_ver);
+    } else {
+        debugs(33, 4, "will resume processing later");
+    }
+}
+
+void
+Ftp::Server::processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &)
+{
+    Must(getConcurrentRequestCount() == 1);
+
+    // Process FTP request asynchronously to make sure FTP
+    // data connection accept callback is fired first.
+    CallJobHere(33, 4, CbcPointer<Server>(this),
+                Ftp::Server, doProcessRequest);
+}
+
+/// imports more upload data from the data connection
+void
+Ftp::Server::readUploadData(const CommIoCbParams &io)
+{
+    debugs(33, 5, io.conn << " size " << io.size);
+    Must(reader != NULL);
+    reader = NULL;
+
+    assert(Comm::IsConnOpen(dataConn));
+    assert(io.conn->fd == dataConn->fd);
+
+    if (io.flag == Comm::OK && bodyPipe != NULL) {
+        if (io.size > 0) {
+            kb_incr(&(statCounter.client_http.kbytes_in), io.size);
+
+            char *const current_buf = uploadBuf + uploadAvailSize;
+            if (io.buf != current_buf)
+                memmove(current_buf, io.buf, io.size);
+            uploadAvailSize += io.size;
+            shovelUploadData();
+        } else if (io.size == 0) {
+            debugs(33, 5, io.conn << " closed");
+            closeDataConnection();
+            if (uploadAvailSize <= 0)
+                finishDechunkingRequest(true);
+        }
+    } else { // not Comm::Flags::OK or unexpected read
+        debugs(33, 5, io.conn << " closed");
+        closeDataConnection();
+        finishDechunkingRequest(false);
+    }
+
+}
+
+/// shovel upload data from the internal buffer to the body pipe if possible
+void
+Ftp::Server::shovelUploadData()
+{
+    assert(bodyPipe != NULL);
+
+    debugs(33, 5, "handling FTP request data for " << clientConnection);
+    const size_t putSize = bodyPipe->putMoreData(uploadBuf,
+                           uploadAvailSize);
+    if (putSize > 0) {
+        uploadAvailSize -= putSize;
+        if (uploadAvailSize > 0)
+            memmove(uploadBuf, uploadBuf + putSize, uploadAvailSize);
+    }
+
+    if (Comm::IsConnOpen(dataConn))
+        maybeReadUploadData();
+    else if (uploadAvailSize <= 0)
+        finishDechunkingRequest(true);
+}
+
+void
+Ftp::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
+{
+    shovelUploadData();
+}
+
+void
+Ftp::Server::noteBodyConsumerAborted(BodyPipe::Pointer ptr)
+{
+    ConnStateData::noteBodyConsumerAborted(ptr);
+    closeDataConnection();
+}
+
+/// accept a new FTP control connection and hand it to a dedicated Server
+void
+Ftp::Server::AcceptCtrlConnection(const CommAcceptCbParams &params)
+{
+    MasterXaction::Pointer xact = params.xaction;
+    AnyP::PortCfgPointer s = xact->squidPort;
+
+    // NP: it is possible the port was reconfigured when the call or accept() was queued.
+
+    if (params.flag != Comm::OK) {
+        // Its possible the call was still queued when the client disconnected
+        debugs(33, 2, s->listenConn << ": FTP accept failure: " << xstrerr(params.xerrno));
+        return;
+    }
+
+    debugs(33, 4, params.conn << ": accepted");
+    fd_note(params.conn->fd, "client ftp connect");
+
+    if (s->tcp_keepalive.enabled)
+        commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
+
+    ++incoming_sockets_accepted;
+
+    AsyncJob::Start(new Server(xact));
+}
+
+void
+Ftp::StartListening()
+{
+    for (AnyP::PortCfgPointer s = FtpPortList; s != NULL; s = s->next) {
+        if (MAXTCPLISTENPORTS == NHttpSockets) {
+            debugs(1, DBG_IMPORTANT, "Ignoring ftp_port lines exceeding the" <<
+                   " limit of " << MAXTCPLISTENPORTS << " ports.");
+            break;
+        }
+
+        // direct new connections accepted by listenConn to Accept()
+        typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
+        RefCount<AcceptCall> subCall = commCbCall(5, 5, "Ftp::Server::AcceptCtrlConnection",
+                                       CommAcceptCbPtrFun(Ftp::Server::AcceptCtrlConnection,
+                                                          CommAcceptCbParams(NULL)));
+        clientStartListeningOn(s, subCall, Ipc::fdnFtpSocket);
+    }
+}
+
+void
+Ftp::StopListening()
+{
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
+        if (s->listenConn != NULL) {
+            debugs(1, DBG_IMPORTANT, "Closing FTP port " << s->listenConn->local);
+            s->listenConn->close();
+            s->listenConn = NULL;
+        }
+    }
+}
+
+void
+Ftp::Server::notePeerConnection(Comm::ConnectionPointer conn)
+{
+    // find request
+    ClientSocketContext::Pointer context = getCurrentContext();
+    Must(context != NULL);
+    ClientHttpRequest *const http = context->http;
+    Must(http != NULL);
+    HttpRequest *const request = http->request;
+    Must(request != NULL);
+
+    // this is not an idle connection, so we do not want I/O monitoring
+    const bool monitor = false;
+
+    // make FTP peer connection exclusive to our request
+    pinConnection(conn, request, conn->getPeer(), false, monitor);
+}
+
+void
+Ftp::Server::clientPinnedConnectionClosed(const CommCloseCbParams &io)
+{
+    ConnStateData::clientPinnedConnectionClosed(io);
+
+    // if the server control connection is gone, reset state to login again
+    resetLogin("control connection closure");
+
+    // XXX: Reseting is not enough. FtpRelay::sendCommand() will not re-login
+    // because FtpRelay::serverState() is not going to be fssConnected.
+}
+
+/// clear client and server login-related state after the old login is gone
+void
+Ftp::Server::resetLogin(const char *reason)
+{
+    debugs(33, 5, "will need to re-login due to " << reason);
+    master->clientReadGreeting = false;
+    changeState(fssBegin, reason);
+}
+
+/// computes uri member from host and, if tracked, working dir with file name
+void
+Ftp::Server::calcUri(const SBuf *file)
+{
+    uri = "ftp://";
+    uri.append(host);
+    if (port->ftp_track_dirs && master->workingDir.length()) {
+        if (master->workingDir[0] != '/')
+            uri.append("/");
+        uri.append(master->workingDir);
+    }
+
+    if (uri[uri.length() - 1] != '/')
+        uri.append("/");
+
+    if (port->ftp_track_dirs && file) {
+        static const CharacterSet Slash("/", "/");
+        Parser::Tokenizer tok(*file);
+        tok.skipAll(Slash);
+        uri.append(tok.remaining());
+    }
+}
+
+/// Starts waiting for a data connection. Returns listening port.
+/// On errors, responds with an error and returns zero.
+unsigned int
+Ftp::Server::listenForDataConnection()
+{
+    closeDataConnection();
+
+    Comm::ConnectionPointer conn = new Comm::Connection;
+    conn->flags = COMM_NONBLOCKING;
+    conn->local = transparent() ? port->s : clientConnection->local;
+    conn->local.port(0);
+    const char *const note = uri.c_str();
+    comm_open_listener(SOCK_STREAM, IPPROTO_TCP, conn, note);
+    if (!Comm::IsConnOpen(conn)) {
+        debugs(5, DBG_CRITICAL, "comm_open_listener failed for FTP data: " <<
+               conn->local << " error: " << errno);
+        writeCustomReply(451, "Internal error");
+        return 0;
+    }
+
+    typedef CommCbMemFunT<Server, CommAcceptCbParams> AcceptDialer;
+    typedef AsyncCallT<AcceptDialer> AcceptCall;
+    RefCount<AcceptCall> call = static_cast<AcceptCall*>(JobCallback(5, 5, AcceptDialer, this, Ftp::Server::acceptDataConnection));
+    Subscription::Pointer sub = new CallSubscription<AcceptCall>(call);
+    listener = call.getRaw();
+    dataListenConn = conn;
+    AsyncJob::Start(new Comm::TcpAcceptor(conn, note, sub));
+
+    const unsigned int listeningPort = comm_local_port(conn->fd);
+    conn->local.port(listeningPort);
+    return listeningPort;
+}
+
+void
+Ftp::Server::acceptDataConnection(const CommAcceptCbParams &params)
+{
+    if (params.flag != Comm::OK) {
+        // Its possible the call was still queued when the client disconnected
+        debugs(33, 2, dataListenConn << ": accept "
+               "failure: " << xstrerr(params.xerrno));
+        return;
+    }
+
+    debugs(33, 4, "accepted " << params.conn);
+    fd_note(params.conn->fd, "passive client ftp data");
+    ++incoming_sockets_accepted;
+
+    if (!clientConnection) {
+        debugs(33, 5, "late data connection?");
+        closeDataConnection(); // in case we are still listening
+        params.conn->close();
+    } else if (params.conn->remote != clientConnection->remote) {
+        debugs(33, 2, "rogue data conn? ctrl: " << clientConnection->remote);
+        params.conn->close();
+        // Some FTP servers close control connection here, but it may make
+        // things worse from DoS p.o.v. and no better from data stealing p.o.v.
+    } else {
+        closeDataConnection();
+        dataConn = params.conn;
+        uploadAvailSize = 0;
+        debugs(33, 7, "ready for data");
+        if (onDataAcceptCall != NULL) {
+            AsyncCall::Pointer call = onDataAcceptCall;
+            onDataAcceptCall = NULL;
+            // If we got an upload request, start reading data from the client.
+            if (master->serverState == fssHandleUploadRequest)
+                maybeReadUploadData();
+            else
+                Must(master->serverState == fssHandleDataRequest);
+            MemBuf mb;
+            mb.init();
+            mb.Printf("150 Data connection opened.\r\n");
+            Comm::Write(clientConnection, &mb, call);
+        }
+    }
+}
+
+void
+Ftp::Server::closeDataConnection()
+{
+    if (listener != NULL) {
+        listener->cancel("no longer needed");
+        listener = NULL;
+    }
+
+    if (Comm::IsConnOpen(dataListenConn)) {
+        debugs(33, 5, "FTP closing client data listen socket: " <<
+               *dataListenConn);
+        dataListenConn->close();
+    }
+    dataListenConn = NULL;
+
+    if (reader != NULL) {
+        // Comm::ReadCancel can deal with negative FDs
+        Comm::ReadCancel(dataConn->fd, reader);
+        reader = NULL;
+    }
+
+    if (Comm::IsConnOpen(dataConn)) {
+        debugs(33, 5, "FTP closing client data connection: " <<
+               *dataConn);
+        dataConn->close();
+    }
+    dataConn = NULL;
+}
+
+/// Writes FTP [error] response before we fully parsed the FTP request and
+/// created the corresponding HTTP request wrapper for that FTP request.
+void
+Ftp::Server::writeEarlyReply(const int code, const char *msg)
+{
+    debugs(33, 7, code << ' ' << msg);
+    assert(99 < code && code < 1000);
+
+    MemBuf mb;
+    mb.init();
+    mb.Printf("%i %s\r\n", code, msg);
+
+    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
+    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteEarlyReply);
+    Comm::Write(clientConnection, &mb, call);
+
+    flags.readMore = false;
+
+    // TODO: Create master transaction. Log it in wroteEarlyReply().
+}
+
+void
+Ftp::Server::writeReply(MemBuf &mb)
+{
+    debugs(9, 2, "FTP Client " << clientConnection);
+    debugs(9, 2, "FTP Client REPLY:\n---------\n" << mb.buf <<
+           "\n----------");
+
+    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
+    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteReply);
+    Comm::Write(clientConnection, &mb, call);
+}
+
+void
+Ftp::Server::writeCustomReply(const int code, const char *msg, const HttpReply *reply)
+{
+    debugs(33, 7, code << ' ' << msg);
+    assert(99 < code && code < 1000);
+
+    const bool sendDetails = reply != NULL &&
+                             reply->header.has(HDR_FTP_STATUS) && reply->header.has(HDR_FTP_REASON);
+
+    MemBuf mb;
+    mb.init();
+    if (sendDetails) {
+        mb.Printf("%i-%s\r\n", code, msg);
+        mb.Printf(" Server reply:\r\n");
+        Ftp::PrintReply(mb, reply, " ");
+        mb.Printf("%i \r\n", code);
+    } else
+        mb.Printf("%i %s\r\n", code, msg);
+
+    writeReply(mb);
+}
+
+void
+Ftp::Server::changeState(const ServerState newState, const char *reason)
+{
+    if (master->serverState == newState) {
+        debugs(33, 3, "client state unchanged at " << master->serverState <<
+               " because " << reason);
+        master->serverState = newState;
+    } else {
+        debugs(33, 3, "client state was " << master->serverState <<
+               ", now " << newState << " because " << reason);
+        master->serverState = newState;
+    }
+}
+
+/// whether the given FTP command has a pathname parameter
+static bool
+Ftp::CommandHasPathParameter(const SBuf &cmd)
+{
+    static std::set<SBuf> PathedCommands;
+    if (!PathedCommands.size()) {
+        PathedCommands.insert(cmdMlst());
+        PathedCommands.insert(cmdMlsd());
+        PathedCommands.insert(cmdStat());
+        PathedCommands.insert(cmdNlst());
+        PathedCommands.insert(cmdList());
+        PathedCommands.insert(cmdMkd());
+        PathedCommands.insert(cmdRmd());
+        PathedCommands.insert(cmdDele());
+        PathedCommands.insert(cmdRnto());
+        PathedCommands.insert(cmdRnfr());
+        PathedCommands.insert(cmdAppe());
+        PathedCommands.insert(cmdStor());
+        PathedCommands.insert(cmdRetr());
+        PathedCommands.insert(cmdSmnt());
+        PathedCommands.insert(cmdCwd());
+    }
+
+    return PathedCommands.find(cmd) != PathedCommands.end();
+}
+
+/// creates a context filled with an error message for a given early error
+ClientSocketContext *
+Ftp::Server::earlyError(const EarlyErrorKind eek)
+{
+    /* Default values, to be updated by the switch statement below */
+    int scode = 421;
+    const char *reason = "Internal error";
+    const char *errUri = "error:ftp-internal-early-error";
+
+    switch (eek) {
+    case eekHugeRequest:
+        scode = 421;
+        reason = "Huge request";
+        errUri = "error:ftp-huge-request";
+        break;
+
+    case eekMissingLogin:
+        scode = 530;
+        reason = "Must login first";
+        errUri = "error:ftp-must-login-first";
+        break;
+
+    case eekMissingUsername:
+        scode = 501;
+        reason = "Missing username";
+        errUri = "error:ftp-missing-username";
+        break;
+
+    case eekMissingHost:
+        scode = 501;
+        reason = "Missing host";
+        errUri = "error:ftp-missing-host";
+        break;
+
+    case eekUnsupportedCommand:
+        scode = 502;
+        reason = "Unknown or unsupported command";
+        errUri = "error:ftp-unsupported-command";
+        break;
+
+    case eekInvalidUri:
+        scode = 501;
+        reason = "Invalid URI";
+        errUri = "error:ftp-invalid-uri";
+        break;
+
+    case eekMalformedCommand:
+        scode = 421;
+        reason = "Malformed command";
+        errUri = "error:ftp-malformed-command";
+        break;
+
+        // no default so that a compiler can check that we have covered all cases
+    }
+
+    ClientSocketContext *context = abortRequestParsing(errUri);
+    clientStreamNode *node = context->getClientReplyContext();
+    Must(node);
+    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+
+    // We cannot relay FTP scode/reason via HTTP-specific ErrorState.
+    // TODO: When/if ErrorState can handle native FTP errors, use it instead.
+    HttpReply *reply = Ftp::HttpReplyWrapper(scode, reason, Http::scBadRequest, -1);
+    repContext->setReplyToReply(reply);
+    return context;
+}
+
+/// Parses a single FTP request on the control connection.
+/// Returns a new ClientSocketContext on valid requests and all errors.
+/// Returns NULL on incomplete requests that may still succeed given more data.
+ClientSocketContext *
+Ftp::Server::parseOneRequest(Http::ProtocolVersion &ver)
+{
+    flags.readMore = false; // common for all but one case below
+
+    // OWS <command> [ RWS <parameter> ] OWS LF
+
+    // InlineSpaceChars are isspace(3) or RFC 959 Section 3.1.1.5.2, except
+    // for the LF character that we must exclude here (but see FullWhiteSpace).
+    static const char * const InlineSpaceChars = " \f\r\t\v";
+    static const CharacterSet InlineSpace = CharacterSet("Ftp::Inline", InlineSpaceChars);
+    static const CharacterSet FullWhiteSpace = (InlineSpace + CharacterSet::LF).rename("Ftp::FWS");
+    static const CharacterSet CommandChars = FullWhiteSpace.complement("Ftp::Command");
+    static const CharacterSet TailChars = CharacterSet::LF.complement("Ftp::Tail");
+
+    // This set is used to ignore empty commands without allowing an attacker
+    // to keep us endlessly busy by feeding us whitespace or empty commands.
+    static const CharacterSet &LeadingSpace = FullWhiteSpace;
+
+    SBuf cmd;
+    SBuf params;
+
+    Parser::Tokenizer tok(in.buf);
+
+    (void)tok.skipAll(LeadingSpace); // leading OWS and empty commands
+    const bool parsed = tok.prefix(cmd, CommandChars); // required command
+
+    // note that the condition below will eat either RWS or trailing OWS
+    if (parsed && tok.skipAll(InlineSpace) && tok.prefix(params, TailChars)) {
+        // now params may include trailing OWS
+        // TODO: Support right-trimming using CharacterSet in Tokenizer instead
+        static const SBuf bufWhiteSpace(InlineSpaceChars);
+        params.trim(bufWhiteSpace, false, true);
+    }
+
+    // Why limit command line and parameters size? Did not we just parse them?
+    // XXX: Our good old String cannot handle very long strings.
+    const SBuf::size_type tokenMax = min(
+                                         static_cast<SBuf::size_type>(32*1024), // conservative
+                                         static_cast<SBuf::size_type>(Config.maxRequestHeaderSize));
+    if (cmd.length() > tokenMax || params.length() > tokenMax) {
+        changeState(fssError, "huge req token");
+        quitAfterError(NULL);
+        return earlyError(eekHugeRequest);
+    }
+
+    // technically, we may skip multiple NLs below, but that is OK
+    if (!parsed || !tok.skipAll(CharacterSet::LF)) { // did not find terminating LF yet
+        // we need more data, but can we buffer more?
+        if (in.buf.length() >= Config.maxRequestHeaderSize) {
+            changeState(fssError, "huge req");
+            quitAfterError(NULL);
+            return earlyError(eekHugeRequest);
+        } else {
+            flags.readMore = true;
+            debugs(33, 5, "Waiting for more, up to " <<
+                   (Config.maxRequestHeaderSize - in.buf.length()));
+            return NULL;
+        }
+    }
+
+    Must(parsed && cmd.length());
+    consumeInput(tok.parsedSize()); // TODO: Would delaying optimize copying?
+
+    debugs(33, 2, ">>ftp " << cmd << (params.isEmpty() ? "" : " ") << params);
+
+    cmd.toUpper(); // this should speed up and simplify future comparisons
+
+    // interception cases do not need USER to calculate the uri
+    if (!transparent()) {
+        if (!master->clientReadGreeting) {
+            // the first command must be USER
+            if (!pinning.pinned && cmd != cmdUser())
+                return earlyError(eekMissingLogin);
+        }
+
+        // process USER request now because it sets FTP peer host name
+        if (cmd == cmdUser()) {
+            if (ClientSocketContext *errCtx = handleUserRequest(cmd, params))
+                return errCtx;
+        }
+    }
+
+    if (!Ftp::SupportedCommand(cmd))
+        return earlyError(eekUnsupportedCommand);
+
+    const HttpRequestMethod method =
+        cmd == cmdAppe() || cmd == cmdStor() || cmd == cmdStou() ?
+        Http::METHOD_PUT : Http::METHOD_GET;
+
+    const SBuf *path = (params.length() && CommandHasPathParameter(cmd)) ?
+                       &params : NULL;
+    calcUri(path);
+    char *newUri = xstrdup(uri.c_str());
+    HttpRequest *const request = HttpRequest::CreateFromUrlAndMethod(newUri, method);
+    if (!request) {
+        debugs(33, 5, "Invalid FTP URL: " << uri);
+        uri.clear();
+        safe_free(newUri);
+        return earlyError(eekInvalidUri);
+    }
+
+    ver = Http::ProtocolVersion(Ftp::ProtocolVersion().major, Ftp::ProtocolVersion().minor);
+    request->flags.ftpNative = true;
+    request->http_ver = ver;
+
+    // Our fake Request-URIs are not distinctive enough for caching to work
+    request->flags.cachable = false; // XXX: reset later by maybeCacheable()
+    request->flags.noCache = true;
+
+    request->header.putStr(HDR_FTP_COMMAND, cmd.c_str());
+    request->header.putStr(HDR_FTP_ARGUMENTS, params.c_str()); // may be ""
+    if (method == Http::METHOD_PUT) {
+        request->header.putStr(HDR_EXPECT, "100-continue");
+        request->header.putStr(HDR_TRANSFER_ENCODING, "chunked");
+    }
+
+    ClientHttpRequest *const http = new ClientHttpRequest(this);
+    http->request = request;
+    HTTPMSGLOCK(http->request);
+    http->req_sz = tok.parsedSize();
+    http->uri = newUri;
+
+    ClientSocketContext *const result =
+        new ClientSocketContext(clientConnection, http);
+
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = result->reqbuf;
+    tempBuffer.length = HTTP_REQBUF_SZ;
+
+    ClientStreamData newServer = new clientReplyContext(http);
+    ClientStreamData newClient = result;
+    clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,
+                     clientReplyStatus, newServer, clientSocketRecipient,
+                     clientSocketDetach, newClient, tempBuffer);
+
+    result->flags.parsed_ok = 1;
+    return result;
+}
+
+void
+Ftp::Server::handleReply(HttpReply *reply, StoreIOBuffer data)
+{
+    // the caller guarantees that we are dealing with the current context only
+    ClientSocketContext::Pointer context = getCurrentContext();
+    assert(context != NULL);
+
+    if (context->http && context->http->al != NULL &&
+            !context->http->al->reply && reply) {
+        context->http->al->reply = reply;
+        HTTPMSGLOCK(context->http->al->reply);
+    }
+
+    static ReplyHandler handlers[] = {
+        NULL, // fssBegin
+        NULL, // fssConnected
+        &Ftp::Server::handleFeatReply, // fssHandleFeat
+        &Ftp::Server::handlePasvReply, // fssHandlePasv
+        &Ftp::Server::handlePortReply, // fssHandlePort
+        &Ftp::Server::handleDataReply, // fssHandleDataRequest
+        &Ftp::Server::handleUploadReply, // fssHandleUploadRequest
+        &Ftp::Server::handleEprtReply,// fssHandleEprt
+        &Ftp::Server::handleEpsvReply,// fssHandleEpsv
+        NULL, // fssHandleCwd
+        NULL, // fssHandlePass
+        NULL, // fssHandleCdup
+        &Ftp::Server::handleErrorReply // fssError
+    };
+    const Server &server = dynamic_cast<const Ftp::Server&>(*context->getConn());
+    if (const ReplyHandler handler = handlers[server.master->serverState])
+        (this->*handler)(reply, data);
+    else
+        writeForwardedReply(reply);
+}
+
+void
+Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
+{
+    if (getCurrentContext()->http->request->errType != ERR_NONE) {
+        writeCustomReply(502, "Server does not support FEAT", reply);
+        return;
+    }
+
+    HttpReply *filteredReply = reply->clone();
+    HttpHeader &filteredHeader = filteredReply->header;
+
+    // Remove all unsupported commands from the response wrapper.
+    int deletedCount = 0;
+    HttpHeaderPos pos = HttpHeaderInitPos;
+    bool hasEPRT = false;
+    bool hasEPSV = false;
+    int prependSpaces = 1;
+    while (const HttpHeaderEntry *e = filteredHeader.getEntry(&pos)) {
+        if (e->id == HDR_FTP_PRE) {
+            // assume RFC 2389 FEAT response format, quoted by Squid:
+            // <"> SP NAME [SP PARAMS] <">
+            // but accommodate MS servers sending four SPs before NAME
+
+            // command name ends with (SP parameter) or quote
+            static const CharacterSet AfterFeatNameChars("AfterFeatName", " \"");
+            static const CharacterSet FeatNameChars = AfterFeatNameChars.complement("FeatName");
+
+            Parser::Tokenizer tok(SBuf(e->value.termedBuf()));
+            if (!tok.skip('"') && !tok.skip(' '))
+                continue;
+
+            // optional spaces; remember their number to accomodate MS servers
+            prependSpaces = 1 + tok.skipAll(CharacterSet::SP);
+
+            SBuf cmd;
+            if (!tok.prefix(cmd, FeatNameChars))
+                continue;
+            cmd.toUpper();
+
+            if (!Ftp::SupportedCommand(cmd))
+                filteredHeader.delAt(pos, deletedCount);
+
+            if (cmd == cmdEprt())
+                hasEPRT = true;
+            else if (cmd == cmdEpsv())
+                hasEPSV = true;
+        }
+    }
+
+    char buf[256];
+    int insertedCount = 0;
+    if (!hasEPRT) {
+        snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPRT");
+        filteredHeader.putStr(HDR_FTP_PRE, buf);
+        ++insertedCount;
+    }
+    if (!hasEPSV) {
+        snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPSV");
+        filteredHeader.putStr(HDR_FTP_PRE, buf);
+        ++insertedCount;
+    }
+
+    if (deletedCount || insertedCount) {
+        filteredHeader.refreshMask();
+        debugs(33, 5, "deleted " << deletedCount << " inserted " << insertedCount);
+    }
+
+    writeForwardedReply(filteredReply);
+}
+
+void
+Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
+{
+    ClientSocketContext::Pointer context = getCurrentContext();
+    assert(context != NULL);
+
+    if (context->http->request->errType != ERR_NONE) {
+        writeCustomReply(502, "Server does not support PASV", reply);
+        return;
+    }
+
+    const unsigned short localPort = listenForDataConnection();
+    if (!localPort)
+        return;
+
+    char addr[MAX_IPSTRLEN];
+    // remote server in interception setups and local address otherwise
+    const Ip::Address &server = transparent() ?
+                                clientConnection->local : dataListenConn->local;
+    server.toStr(addr, MAX_IPSTRLEN, AF_INET);
+    addr[MAX_IPSTRLEN - 1] = '\0';
+    for (char *c = addr; *c != '\0'; ++c) {
+        if (*c == '.')
+            *c = ',';
+    }
+
+    // In interception setups, we combine remote server address with a
+    // local port number and hope that traffic will be redirected to us.
+    // Do not use "227 =a,b,c,d,p1,p2" format or omit parens: some nf_ct_ftp
+    // versions block responses that use those alternative syntax rules!
+    MemBuf mb;
+    mb.init();
+    mb.Printf("227 Entering Passive Mode (%s,%i,%i).\r\n",
+              addr,
+              static_cast<int>(localPort / 256),
+              static_cast<int>(localPort % 256));
+    debugs(9, 3, Raw("writing", mb.buf, mb.size));
+    writeReply(mb);
+}
+
+void
+Ftp::Server::handlePortReply(const HttpReply *reply, StoreIOBuffer)
+{
+    if (getCurrentContext()->http->request->errType != ERR_NONE) {
+        writeCustomReply(502, "Server does not support PASV (converted from PORT)", reply);
+        return;
+    }
+
+    writeCustomReply(200, "PORT successfully converted to PASV.");
+
+    // and wait for RETR
+}
+
+void
+Ftp::Server::handleErrorReply(const HttpReply *reply, StoreIOBuffer)
+{
+    if (!pinning.pinned) // we failed to connect to server
+        uri.clear();
+    // 421: we will close due to fssError
+    writeErrorReply(reply, 421);
+}
+
+void
+Ftp::Server::handleDataReply(const HttpReply *reply, StoreIOBuffer data)
+{
+    if (reply != NULL && reply->sline.status() != Http::scOkay) {
+        writeForwardedReply(reply);
+        if (Comm::IsConnOpen(dataConn)) {
+            debugs(33, 3, "closing " << dataConn << " on KO reply");
+            closeDataConnection();
+        }
+        return;
+    }
+
+    if (!dataConn) {
+        // We got STREAM_COMPLETE (or error) and closed the client data conn.
+        debugs(33, 3, "ignoring FTP srv data response after clt data closure");
+        return;
+    }
+
+    if (!checkDataConnPost()) {
+        writeCustomReply(425, "Data connection is not established.");
+        closeDataConnection();
+        return;
+    }
+
+    debugs(33, 7, data.length);
+
+    if (data.length <= 0) {
+        replyDataWritingCheckpoint(); // skip the actual write call
+        return;
+    }
+
+    MemBuf mb;
+    mb.init(data.length + 1, data.length + 1);
+    mb.append(data.data, data.length);
+
+    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
+    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteReplyData);
+    Comm::Write(dataConn, &mb, call);
+
+    getCurrentContext()->noteSentBodyBytes(data.length);
+}
+
+/// called when we are done writing a chunk of the response data
+void
+Ftp::Server::wroteReplyData(const CommIoCbParams &io)
+{
+    if (io.flag == Comm::ERR_CLOSING)
+        return;
+
+    if (io.flag != Comm::OK) {
+        debugs(33, 3, "FTP reply data writing failed: " << xstrerr(io.xerrno));
+        closeDataConnection();
+        writeCustomReply(426, "Data connection error; transfer aborted");
+        return;
+    }
+
+    assert(getCurrentContext()->http);
+    getCurrentContext()->http->out.size += io.size;
+    replyDataWritingCheckpoint();
+}
+
+/// ClientStream checks after (actual or skipped) reply data writing
+void
+Ftp::Server::replyDataWritingCheckpoint()
+{
+    switch (getCurrentContext()->socketState()) {
+    case STREAM_NONE:
+        debugs(33, 3, "Keep going");
+        getCurrentContext()->pullData();
+        return;
+    case STREAM_COMPLETE:
+        debugs(33, 3, "FTP reply data transfer successfully complete");
+        writeCustomReply(226, "Transfer complete");
+        break;
+    case STREAM_UNPLANNED_COMPLETE:
+        debugs(33, 3, "FTP reply data transfer failed: STREAM_UNPLANNED_COMPLETE");
+        writeCustomReply(451, "Server error; transfer aborted");
+        break;
+    case STREAM_FAILED:
+        debugs(33, 3, "FTP reply data transfer failed: STREAM_FAILED");
+        writeCustomReply(451, "Server error; transfer aborted");
+        break;
+    default:
+        fatal("unreachable code");
+    }
+
+    closeDataConnection();
+}
+
+void
+Ftp::Server::handleUploadReply(const HttpReply *reply, StoreIOBuffer)
+{
+    writeForwardedReply(reply);
+    // note that the client data connection may already be closed by now
+}
+
+void
+Ftp::Server::writeForwardedReply(const HttpReply *reply)
+{
+    assert(reply != NULL);
+    const HttpHeader &header = reply->header;
+    // adaptation and forwarding errors lack HDR_FTP_STATUS
+    if (!header.has(HDR_FTP_STATUS)) {
+        writeForwardedForeign(reply); // will get to Ftp::Server::wroteReply
+        return;
+    }
+
+    typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
+    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteReply);
+    writeForwardedReplyAndCall(reply, call);
+}
+
+void
+Ftp::Server::handleEprtReply(const HttpReply *reply, StoreIOBuffer)
+{
+    if (getCurrentContext()->http->request->errType != ERR_NONE) {
+        writeCustomReply(502, "Server does not support PASV (converted from EPRT)", reply);
+        return;
+    }
+
+    writeCustomReply(200, "EPRT successfully converted to PASV.");
+
+    // and wait for RETR
+}
+
+void
+Ftp::Server::handleEpsvReply(const HttpReply *reply, StoreIOBuffer)
+{
+    if (getCurrentContext()->http->request->errType != ERR_NONE) {
+        writeCustomReply(502, "Cannot connect to server", reply);
+        return;
+    }
+
+    const unsigned short localPort = listenForDataConnection();
+    if (!localPort)
+        return;
+
+    // In interception setups, we use a local port number and hope that data
+    // traffic will be redirected to us.
+    MemBuf mb;
+    mb.init();
+    mb.Printf("229 Entering Extended Passive Mode (|||%u|)\r\n", localPort);
+
+    debugs(9, 3, Raw("writing", mb.buf, mb.size));
+    writeReply(mb);
+}
+
+/// writes FTP error response with given status and reply-derived error details
+void
+Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
+{
+    const HttpRequest *request = getCurrentContext()->http->request;
+    assert(request);
+
+    MemBuf mb;
+    mb.init();
+
+    if (request->errType != ERR_NONE)
+        mb.Printf("%i-%s\r\n", scode, errorPageName(request->errType));
+
+    if (request->errDetail > 0) {
+        // XXX: > 0 may not always mean that this is an errno
+        mb.Printf("%i-Error: (%d) %s\r\n", scode,
+                  request->errDetail,
+                  strerror(request->errDetail));
+    }
+
+#if USE_ADAPTATION
+    // XXX: Remove hard coded names. Use an error page template instead.
+    const Adaptation::History::Pointer ah = request->adaptHistory();
+    if (ah != NULL) { // XXX: add adapt::<all_h but use lastMeta here
+        const String info = ah->allMeta.getByName("X-Response-Info");
+        const String desc = ah->allMeta.getByName("X-Response-Desc");
+        if (info.size())
+            mb.Printf("%i-Information: %s\r\n", scode, info.termedBuf());
+        if (desc.size())
+            mb.Printf("%i-Description: %s\r\n", scode, desc.termedBuf());
+    }
+#endif
+
+    assert(reply != NULL);
+    const char *reason = reply->header.has(HDR_FTP_REASON) ?
+                         reply->header.getStr(HDR_FTP_REASON):
+                         reply->sline.reason();
+
+    mb.Printf("%i %s\r\n", scode, reason); // error terminating line
+
+    // TODO: errorpage.cc should detect FTP client and use
+    // configurable FTP-friendly error templates which we should
+    // write to the client "as is" instead of hiding most of the info
+
+    writeReply(mb);
+}
+
+/// writes FTP response based on HTTP reply that is not an FTP-response wrapper
+/// for example, internally-generated Squid "errorpages" end up here (for now)
+void
+Ftp::Server::writeForwardedForeign(const HttpReply *reply)
+{
+    changeState(fssConnected, "foreign reply");
+    closeDataConnection();
+    // 451: We intend to keep the control connection open.
+    writeErrorReply(reply, 451);
+}
+
+void
+Ftp::Server::writeControlMsgAndCall(ClientSocketContext *context, HttpReply *reply, AsyncCall::Pointer &call)
+{
+    // the caller guarantees that we are dealing with the current context only
+    // the caller should also make sure reply->header.has(HDR_FTP_STATUS)
+    writeForwardedReplyAndCall(reply, call);
+}
+
+void
+Ftp::Server::writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Pointer &call)
+{
+    assert(reply != NULL);
+    const HttpHeader &header = reply->header;
+
+    // without status, the caller must use the writeForwardedForeign() path
+    Must(header.has(HDR_FTP_STATUS));
+    Must(header.has(HDR_FTP_REASON));
+    const int scode = header.getInt(HDR_FTP_STATUS);
+    debugs(33, 7, "scode: " << scode);
+
+    // Status 125 or 150 implies upload or data request, but we still check
+    // the state in case the server is buggy.
+    if ((scode == 125 || scode == 150) &&
+            (master->serverState == fssHandleUploadRequest ||
+             master->serverState == fssHandleDataRequest)) {
+        if (checkDataConnPost()) {
+            // If the data connection is ready, start reading data (here)
+            // and forward the response to client (further below).
+            debugs(33, 7, "data connection established, start data transfer");
+            if (master->serverState == fssHandleUploadRequest)
+                maybeReadUploadData();
+        } else {
+            // If we are waiting to accept the data connection, keep waiting.
+            if (Comm::IsConnOpen(dataListenConn)) {
+                debugs(33, 7, "wait for the client to establish a data connection");
+                onDataAcceptCall = call;
+                // TODO: Add connect timeout for passive connections listener?
+                // TODO: Remember server response so that we can forward it?
+            } else {
+                // Either the connection was establised and closed after the
+                // data was transferred OR we failed to establish an active
+                // data connection and already sent the error to the client.
+                // In either case, there is nothing more to do.
+                debugs(33, 7, "done with data OR active connection failed");
+            }
+            return;
+        }
+    }
+
+    MemBuf mb;
+    mb.init();
+    Ftp::PrintReply(mb, reply);
+
+    debugs(9, 2, "FTP Client " << clientConnection);
+    debugs(9, 2, "FTP Client REPLY:\n---------\n" << mb.buf <<
+           "\n----------");
+
+    Comm::Write(clientConnection, &mb, call);
+}
+
+static void
+Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const prefix)
+{
+    const HttpHeader &header = reply->header;
+
+    HttpHeaderPos pos = HttpHeaderInitPos;
+    while (const HttpHeaderEntry *e = header.getEntry(&pos)) {
+        if (e->id == HDR_FTP_PRE) {
+            String raw;
+            if (httpHeaderParseQuotedString(e->value.rawBuf(), e->value.size(), &raw))
+                mb.Printf("%s\r\n", raw.termedBuf());
+        }
+    }
+
+    if (header.has(HDR_FTP_STATUS)) {
+        const char *reason = header.getStr(HDR_FTP_REASON);
+        mb.Printf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
+                  (reason ? reason : 0));
+    }
+}
+
+void
+Ftp::Server::wroteEarlyReply(const CommIoCbParams &io)
+{
+    if (io.flag == Comm::ERR_CLOSING)
+        return;
+
+    if (io.flag != Comm::OK) {
+        debugs(33, 3, "FTP reply writing failed: " << xstrerr(io.xerrno));
+        io.conn->close();
+        return;
+    }
+
+    ClientSocketContext::Pointer context = getCurrentContext();
+    if (context != NULL && context->http) {
+        context->http->out.size += io.size;
+        context->http->out.headers_sz += io.size;
+    }
+
+    flags.readMore = true;
+    readSomeData();
+}
+
+void
+Ftp::Server::wroteReply(const CommIoCbParams &io)
+{
+    if (io.flag == Comm::ERR_CLOSING)
+        return;
+
+    if (io.flag != Comm::OK) {
+        debugs(33, 3, "FTP reply writing failed: " << xstrerr(io.xerrno));
+        io.conn->close();
+        return;
+    }
+
+    ClientSocketContext::Pointer context = getCurrentContext();
+    assert(context->http);
+    context->http->out.size += io.size;
+    context->http->out.headers_sz += io.size;
+
+    if (master->serverState == fssError) {
+        debugs(33, 5, "closing on FTP server error");
+        io.conn->close();
+        return;
+    }
+
+    const clientStream_status_t socketState = context->socketState();
+    debugs(33, 5, "FTP client stream state " << socketState);
+    switch (socketState) {
+    case STREAM_UNPLANNED_COMPLETE:
+    case STREAM_FAILED:
+        io.conn->close();
+        return;
+
+    case STREAM_NONE:
+    case STREAM_COMPLETE:
+        flags.readMore = true;
+        changeState(fssConnected, "Ftp::Server::wroteReply");
+        if (in.bodyParser)
+            finishDechunkingRequest(false);
+        context->keepaliveNextRequest();
+        return;
+    }
+}
+
+bool
+Ftp::Server::handleRequest(HttpRequest *request)
+{
+    debugs(33, 9, request);
+    Must(request);
+
+    HttpHeader &header = request->header;
+    Must(header.has(HDR_FTP_COMMAND));
+    String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
+    Must(header.has(HDR_FTP_ARGUMENTS));
+    String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+
+    if (do_debug(9, 2)) {
+        MemBuf mb;
+        Packer p;
+        mb.init();
+        packerToMemInit(&p, &mb);
+        request->pack(&p);
+        packerClean(&p);
+
+        debugs(9, 2, "FTP Client " << clientConnection);
+        debugs(9, 2, "FTP Client REQUEST:\n---------\n" << mb.buf <<
+               "\n----------");
+    }
+
+    // TODO: When HttpHeader uses SBuf, change keys to SBuf
+    typedef std::map<const std::string, RequestHandler> RequestHandlers;
+    static RequestHandlers handlers;
+    if (!handlers.size()) {
+        handlers["LIST"] = &Ftp::Server::handleDataRequest;
+        handlers["NLST"] = &Ftp::Server::handleDataRequest;
+        handlers["MLSD"] = &Ftp::Server::handleDataRequest;
+        handlers["FEAT"] = &Ftp::Server::handleFeatRequest;
+        handlers["PASV"] = &Ftp::Server::handlePasvRequest;
+        handlers["PORT"] = &Ftp::Server::handlePortRequest;
+        handlers["RETR"] = &Ftp::Server::handleDataRequest;
+        handlers["EPRT"] = &Ftp::Server::handleEprtRequest;
+        handlers["EPSV"] = &Ftp::Server::handleEpsvRequest;
+        handlers["CWD"] = &Ftp::Server::handleCwdRequest;
+        handlers["PASS"] = &Ftp::Server::handlePassRequest;
+        handlers["CDUP"] = &Ftp::Server::handleCdupRequest;
+    }
+
+    RequestHandler handler = NULL;
+    if (request->method == Http::METHOD_PUT)
+        handler = &Ftp::Server::handleUploadRequest;
+    else {
+        const RequestHandlers::const_iterator hi = handlers.find(cmd.termedBuf());
+        if (hi != handlers.end())
+            handler = hi->second;
+    }
+
+    if (!handler) {
+        debugs(9, 7, "forwarding " << cmd << " as is, no post-processing");
+        return true;
+    }
+
+    return (this->*handler)(cmd, params);
+}
+
+/// Called to parse USER command, which is required to create an HTTP request
+/// wrapper. W/o request, the errors are handled by returning earlyError().
+ClientSocketContext *
+Ftp::Server::handleUserRequest(const SBuf &cmd, SBuf &params)
+{
+    if (params.isEmpty())
+        return earlyError(eekMissingUsername);
+
+    // find the [end of] user name
+    const SBuf::size_type eou = params.rfind('@');
+    if (eou == SBuf::npos || eou + 1 >= params.length())
+        return earlyError(eekMissingHost);
+
+    // Determine the intended destination.
+    host = params.substr(eou + 1, params.length());
+    // If we can parse it as raw IPv6 address, then surround with "[]".
+    // Otherwise (domain, IPv4, [bracketed] IPv6, garbage, etc), use as is.
+    if (host.find(':') != SBuf::npos) {
+        const Ip::Address ipa(host.c_str());
+        if (!ipa.isAnyAddr()) {
+            char ipBuf[MAX_IPSTRLEN];
+            ipa.toHostStr(ipBuf, MAX_IPSTRLEN);
+            host = ipBuf;
+        }
+    }
+
+    // const SBuf login = params.substr(0, eou);
+    params.chop(0, eou); // leave just the login part for the peer
+
+    SBuf oldUri;
+    if (master->clientReadGreeting)
+        oldUri = uri;
+
+    master->workingDir.clear();
+    calcUri(NULL);
+
+    if (!master->clientReadGreeting) {
+        debugs(9, 3, "set URI to " << uri);
+    } else if (oldUri.caseCmp(uri) == 0) {
+        debugs(9, 5, "kept URI as " << oldUri);
+    } else {
+        debugs(9, 3, "reset URI from " << oldUri << " to " << uri);
+        closeDataConnection();
+        unpinConnection(true); // close control connection to peer
+        resetLogin("URI reset");
+    }
+
+    return NULL; // no early errors
+}
+
+bool
+Ftp::Server::handleFeatRequest(String &cmd, String &params)
+{
+    changeState(fssHandleFeat, "handleFeatRequest");
+    return true;
+}
+
+bool
+Ftp::Server::handlePasvRequest(String &cmd, String &params)
+{
+    if (gotEpsvAll) {
+        setReply(500, "Bad PASV command");
+        return false;
+    }
+
+    if (params.size() > 0) {
+        setReply(501, "Unexpected parameter");
+        return false;
+    }
+
+    changeState(fssHandlePasv, "handlePasvRequest");
+    // no need to fake PASV request via setDataCommand() in true PASV case
+    return true;
+}
+
+/// [Re]initializes dataConn for active data transfers. Does not connect.
+bool
+Ftp::Server::createDataConnection(Ip::Address cltAddr)
+{
+    assert(clientConnection != NULL);
+    assert(!clientConnection->remote.isAnyAddr());
+
+    if (cltAddr != clientConnection->remote) {
+        debugs(33, 2, "rogue PORT " << cltAddr << " request? ctrl: " << clientConnection->remote);
+        // Closing the control connection would not help with attacks because
+        // the client is evidently able to connect to us. Besides, closing
+        // makes retrials easier for the client and more damaging to us.
+        setReply(501, "Prohibited parameter value");
+        return false;
+    }
+
+    closeDataConnection();
+
+    Comm::ConnectionPointer conn = new Comm::Connection();
+    conn->flags |= COMM_DOBIND;
+
+    // Use local IP address of the control connection as the source address
+    // of the active data connection, or some clients will refuse to accept.
+    conn->setAddrs(clientConnection->local, cltAddr);
+    // RFC 959 requires active FTP connections to originate from port 20
+    // but that would preclude us from supporting concurrent transfers! (XXX?)
+    conn->local.port(0);
+
+    debugs(9, 3, "will actively connect from " << conn->local << " to " <<
+           conn->remote);
+
+    dataConn = conn;
+    uploadAvailSize = 0;
+    return true;
+}
+
+bool
+Ftp::Server::handlePortRequest(String &cmd, String &params)
+{
+    // TODO: Should PORT errors trigger closeDataConnection() cleanup?
+
+    if (gotEpsvAll) {
+        setReply(500, "Rejecting PORT after EPSV ALL");
+        return false;
+    }
+
+    if (!params.size()) {
+        setReply(501, "Missing parameter");
+        return false;
+    }
+
+    Ip::Address cltAddr;
+    if (!Ftp::ParseIpPort(params.termedBuf(), NULL, cltAddr)) {
+        setReply(501, "Invalid parameter");
+        return false;
+    }
+
+    if (!createDataConnection(cltAddr))
+        return false;
+
+    changeState(fssHandlePort, "handlePortRequest");
+    setDataCommand();
+    return true; // forward our fake PASV request
+}
+
+bool
+Ftp::Server::handleDataRequest(String &cmd, String &params)
+{
+    if (!checkDataConnPre())
+        return false;
+
+    changeState(fssHandleDataRequest, "handleDataRequest");
+
+    return true;
+}
+
+bool
+Ftp::Server::handleUploadRequest(String &cmd, String &params)
+{
+    if (!checkDataConnPre())
+        return false;
+
+    changeState(fssHandleUploadRequest, "handleDataRequest");
+
+    return true;
+}
+
+bool
+Ftp::Server::handleEprtRequest(String &cmd, String &params)
+{
+    debugs(9, 3, "Process an EPRT " << params);
+
+    if (gotEpsvAll) {
+        setReply(500, "Rejecting EPRT after EPSV ALL");
+        return false;
+    }
+
+    if (!params.size()) {
+        setReply(501, "Missing parameter");
+        return false;
+    }
+
+    Ip::Address cltAddr;
+    if (!Ftp::ParseProtoIpPort(params.termedBuf(), cltAddr)) {
+        setReply(501, "Invalid parameter");
+        return false;
+    }
+
+    if (!createDataConnection(cltAddr))
+        return false;
+
+    changeState(fssHandleEprt, "handleEprtRequest");
+    setDataCommand();
+    return true; // forward our fake PASV request
+}
+
+bool
+Ftp::Server::handleEpsvRequest(String &cmd, String &params)
+{
+    debugs(9, 3, "Process an EPSV command with params: " << params);
+    if (params.size() <= 0) {
+        // treat parameterless EPSV as "use the protocol of the ctrl conn"
+    } else if (params.caseCmp("ALL") == 0) {
+        setReply(200, "EPSV ALL ok");
+        gotEpsvAll = true;
+        return false;
+    } else if (params.cmp("2") == 0) {
+        if (!Ip::EnableIpv6) {
+            setReply(522, "Network protocol not supported, use (1)");
+            return false;
+        }
+    } else if (params.cmp("1") != 0) {
+        setReply(501, "Unsupported EPSV parameter");
+        return false;
+    }
+
+    changeState(fssHandleEpsv, "handleEpsvRequest");
+    setDataCommand();
+    return true; // forward our fake PASV request
+}
+
+bool
+Ftp::Server::handleCwdRequest(String &cmd, String &params)
+{
+    changeState(fssHandleCwd, "handleCwdRequest");
+    return true;
+}
+
+bool
+Ftp::Server::handlePassRequest(String &cmd, String &params)
+{
+    changeState(fssHandlePass, "handlePassRequest");
+    return true;
+}
+
+bool
+Ftp::Server::handleCdupRequest(String &cmd, String &params)
+{
+    changeState(fssHandleCdup, "handleCdupRequest");
+    return true;
+}
+
+// Convert user PORT, EPRT, PASV, or EPSV data command to Squid PASV command.
+// Squid FTP client decides what data command to use with peers.
+void
+Ftp::Server::setDataCommand()
+{
+    ClientHttpRequest *const http = getCurrentContext()->http;
+    assert(http != NULL);
+    HttpRequest *const request = http->request;
+    assert(request != NULL);
+    HttpHeader &header = request->header;
+    header.delById(HDR_FTP_COMMAND);
+    header.putStr(HDR_FTP_COMMAND, "PASV");
+    header.delById(HDR_FTP_ARGUMENTS);
+    header.putStr(HDR_FTP_ARGUMENTS, "");
+    debugs(9, 5, "client data command converted to fake PASV");
+}
+
+/// check that client data connection is ready for future I/O or at least
+/// has a chance of becoming ready soon.
+bool
+Ftp::Server::checkDataConnPre()
+{
+    if (Comm::IsConnOpen(dataConn))
+        return true;
+
+    if (Comm::IsConnOpen(dataListenConn)) {
+        // We are still waiting for a client to connect to us after PASV.
+        // Perhaps client's data conn handshake has not reached us yet.
+        // After we talk to the server, checkDataConnPost() will recheck.
+        debugs(33, 3, "expecting clt data conn " << dataListenConn);
+        return true;
+    }
+
+    if (!dataConn || dataConn->remote.isAnyAddr()) {
+        debugs(33, 5, "missing " << dataConn);
+        // TODO: use client address and default port instead.
+        setReply(425, "Use PORT or PASV first");
+        return false;
+    }
+
+    // active transfer: open a data connection from Squid to client
+    typedef CommCbMemFunT<Server, CommConnectCbParams> Dialer;
+    connector = JobCallback(17, 3, Dialer, this, Ftp::Server::connectedForData);
+    Comm::ConnOpener *cs = new Comm::ConnOpener(dataConn, connector,
+            Config.Timeout.connect);
+    AsyncJob::Start(cs);
+    return false; // ConnStateData::processFtpRequest waits handleConnectDone
+}
+
+/// Check that client data connection is ready for immediate I/O.
+bool
+Ftp::Server::checkDataConnPost() const
+{
+    if (!Comm::IsConnOpen(dataConn)) {
+        debugs(33, 3, "missing client data conn: " << dataConn);
+        return false;
+    }
+    return true;
+}
+
+/// Done establishing a data connection to the user.
+void
+Ftp::Server::connectedForData(const CommConnectCbParams &params)
+{
+    connector = NULL;
+
+    if (params.flag != Comm::OK) {
+        /* it might have been a timeout with a partially open link */
+        if (params.conn != NULL)
+            params.conn->close();
+        setReply(425, "Cannot open data connection.");
+        ClientSocketContext::Pointer context = getCurrentContext();
+        Must(context->http);
+        Must(context->http->storeEntry() != NULL);
+    } else {
+        Must(dataConn == params.conn);
+        Must(Comm::IsConnOpen(params.conn));
+        fd_note(params.conn->fd, "active client ftp data");
+    }
+
+    doProcessRequest();
+}
+
+void
+Ftp::Server::setReply(const int code, const char *msg)
+{
+    ClientSocketContext::Pointer context = getCurrentContext();
+    ClientHttpRequest *const http = context->http;
+    assert(http != NULL);
+    assert(http->storeEntry() == NULL);
+
+    HttpReply *const reply = Ftp::HttpReplyWrapper(code, msg, Http::scNoContent, 0);
+
+    setLogUri(http, urlCanonicalClean(http->request));
+
+    clientStreamNode *const node = context->getClientReplyContext();
+    clientReplyContext *const repContext =
+        dynamic_cast<clientReplyContext *>(node->data.getRaw());
+    assert(repContext != NULL);
+
+    RequestFlags reqFlags;
+    reqFlags.cachable = false; // force releaseRequest() in storeCreateEntry()
+    reqFlags.noCache = true;
+    repContext->createStoreEntry(http->request->method, reqFlags);
+    http->storeEntry()->replaceHttpReply(reply);
+}
+
+/// Whether Squid FTP Relay supports a named feature (e.g., a command).
+static bool
+Ftp::SupportedCommand(const SBuf &name)
+{
+    static std::set<SBuf> BlackList;
+    if (BlackList.empty()) {
+        /* Add FTP commands that Squid cannot relay correctly. */
+
+        // We probably do not support AUTH TLS.* and AUTH SSL,
+        // but let's disclaim all AUTH support to KISS, for now.
+        BlackList.insert(cmdAuth());
+    }
+
+    // we claim support for all commands that we do not know about
+    return BlackList.find(name) == BlackList.end();
+}
+
@@ -0,0 +1,169 @@
+/*
+ * DEBUG: section 33    Client-side Routines
+ */
+
+#ifndef SQUID_SERVERS_FTP_SERVER_H
+#define SQUID_SERVERS_FTP_SERVER_H
+
+#include "base/Lock.h"
+#include "client_side.h"
+
+namespace Ftp
+{
+
+typedef enum {
+    fssBegin,
+    fssConnected,
+    fssHandleFeat,
+    fssHandlePasv,
+    fssHandlePort,
+    fssHandleDataRequest,
+    fssHandleUploadRequest,
+    fssHandleEprt,
+    fssHandleEpsv,
+    fssHandleCwd,
+    fssHandlePass,
+    fssHandleCdup,
+    fssError
+} ServerState;
+
+// TODO: This should become a part of MasterXaction when we start sending
+// master transactions to the clients/ code.
+/// Transaction information shared among our FTP client and server jobs.
+class MasterState: public RefCountable
+{
+public:
+    typedef RefCount<MasterState> Pointer;
+
+    MasterState(): serverState(fssBegin), clientReadGreeting(false) {}
+
+    Ip::Address clientDataAddr; ///< address of our FTP client data connection
+    SBuf workingDir; ///< estimated current working directory for URI formation
+    ServerState serverState; ///< what our FTP server is doing
+    bool clientReadGreeting; ///< whether our FTP client read their FTP server greeting
+};
+
+/// Manages a control connection from an FTP client.
+class Server: public ConnStateData
+{
+public:
+    explicit Server(const MasterXaction::Pointer &xact);
+    virtual ~Server();
+
+    // This is a pointer in hope to minimize future changes when MasterState
+    // becomes a part of MasterXaction. Guaranteed not to be nil.
+    MasterState::Pointer master; ///< info shared among our FTP client and server jobs
+
+protected:
+    friend void StartListening();
+
+    // errors detected before it is possible to create an HTTP request wrapper
+    typedef enum {
+        eekHugeRequest,
+        eekMissingLogin,
+        eekMissingUsername,
+        eekMissingHost,
+        eekUnsupportedCommand,
+        eekInvalidUri,
+        eekMalformedCommand
+    } EarlyErrorKind;
+
+    /* ConnStateData API */
+    virtual ClientSocketContext *parseOneRequest(Http::ProtocolVersion &ver);
+    virtual void processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &ver);
+    virtual void notePeerConnection(Comm::ConnectionPointer conn);
+    virtual void clientPinnedConnectionClosed(const CommCloseCbParams &io);
+    virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData);
+    virtual int pipelinePrefetchMax() const;
+    virtual void writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &call);
+    virtual time_t idleTimeout() const;
+
+    /* BodyPipe API */
+    virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
+    virtual void noteBodyConsumerAborted(BodyPipe::Pointer ptr);
+
+    /* AsyncJob API */
+    virtual void start();
+
+    /* Comm callbacks */
+    static void AcceptCtrlConnection(const CommAcceptCbParams &params);
+    void acceptDataConnection(const CommAcceptCbParams &params);
+    void readUploadData(const CommIoCbParams &io);
+    void wroteEarlyReply(const CommIoCbParams &io);
+    void wroteReply(const CommIoCbParams &io);
+    void wroteReplyData(const CommIoCbParams &io);
+    void connectedForData(const CommConnectCbParams &params);
+
+    unsigned int listenForDataConnection();
+    bool createDataConnection(Ip::Address cltAddr);
+    void closeDataConnection();
+
+    void calcUri(const SBuf *file);
+    void changeState(const Ftp::ServerState newState, const char *reason);
+    ClientSocketContext *handleUserRequest(const SBuf &cmd, SBuf &params);
+    bool checkDataConnPost() const;
+    void replyDataWritingCheckpoint();
+    void maybeReadUploadData();
+
+    void setReply(const int code, const char *msg);
+    void writeCustomReply(const int code, const char *msg, const HttpReply *reply = NULL);
+    void writeEarlyReply(const int code, const char *msg);
+    void writeErrorReply(const HttpReply *reply, const int status);
+    void writeForwardedForeign(const HttpReply *reply);
+    void writeForwardedReply(const HttpReply *reply);
+    void writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Pointer &call);
+    void writeReply(MemBuf &mb);
+
+    ClientSocketContext *earlyError(const EarlyErrorKind eek);
+    bool handleRequest(HttpRequest *);
+    void setDataCommand();
+    bool checkDataConnPre();
+
+    /// a method handling an FTP command; selected by handleRequest()
+    typedef bool (Ftp::Server::*RequestHandler)(String &cmd, String &params);
+    bool handleFeatRequest(String &cmd, String &params);
+    bool handlePasvRequest(String &cmd, String &params);
+    bool handlePortRequest(String &cmd, String &params);
+    bool handleDataRequest(String &cmd, String &params);
+    bool handleUploadRequest(String &cmd, String &params);
+    bool handleEprtRequest(String &cmd, String &params);
+    bool handleEpsvRequest(String &cmd, String &params);
+    bool handleCwdRequest(String &cmd, String &params);
+    bool handlePassRequest(String &cmd, String &params);
+    bool handleCdupRequest(String &cmd, String &params);
+
+    /// a method handling an FTP response; selected by handleReply()
+    typedef void (Ftp::Server::*ReplyHandler)(const HttpReply *reply, StoreIOBuffer data);
+    void handleFeatReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handlePasvReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handlePortReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handleErrorReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handleDataReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handleUploadReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handleEprtReply(const HttpReply *header, StoreIOBuffer receivedData);
+    void handleEpsvReply(const HttpReply *header, StoreIOBuffer receivedData);
+
+private:
+    void doProcessRequest();
+    void shovelUploadData();
+    void resetLogin(const char *reason);
+
+    SBuf uri; ///< a URI reconstructed from various FTP message details
+    SBuf host; ///< intended dest. of a transparently intercepted FTP conn
+    bool gotEpsvAll; ///< restrict data conn setup commands to just EPSV
+    AsyncCall::Pointer onDataAcceptCall; ///< who to call upon data conn acceptance
+    Comm::ConnectionPointer dataListenConn; ///< data connection listening socket
+    Comm::ConnectionPointer dataConn; ///< data connection
+    char uploadBuf[CLIENT_REQ_BUF_SZ]; ///< data connection input buffer
+    size_t uploadAvailSize; ///< number of yet unused uploadBuf bytes
+
+    AsyncCall::Pointer listener; ///< set when we are passively listening
+    AsyncCall::Pointer connector; ///< set when we are actively connecting
+    AsyncCall::Pointer reader; ///< set when we are reading FTP data
+
+    CBDATA_CLASS2(Server);
+};
+
+} // namespace Ftp
+
+#endif /* SQUID_SERVERS_FTP_SERVER_H */
@@ -0,0 +1,191 @@
+/*
+ * DEBUG: section 33    Client-side Routines
+ */
+
+#include "squid.h"
+#include "client_side.h"
+#include "client_side_request.h"
+#include "comm/Write.h"
+#include "HttpHeaderTools.h"
+#include "profiler/Profiler.h"
+#include "servers/forward.h"
+#include "SquidConfig.h"
+
+namespace Http
+{
+
+/// Manages a connection from an HTTP client.
+class Server: public ConnStateData
+{
+public:
+    Server(const MasterXaction::Pointer &xact, const bool beHttpsServer);
+    virtual ~Server() {}
+
+    void readSomeHttpData();
+
+protected:
+    /* ConnStateData API */
+    virtual ClientSocketContext *parseOneRequest(Http::ProtocolVersion &ver);
+    virtual void processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &ver);
+    virtual void handleReply(HttpReply *rep, StoreIOBuffer receivedData);
+    virtual void writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &call);
+    virtual time_t idleTimeout() const;
+
+    /* BodyPipe API */
+    virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
+    virtual void noteBodyConsumerAborted(BodyPipe::Pointer);
+
+    /* AsyncJob API */
+    virtual void start();
+
+private:
+    void processHttpRequest(ClientSocketContext *const context);
+    void handleHttpRequestData();
+
+    HttpParser parser_;
+    HttpRequestMethod method_; ///< parsed HTTP method
+
+    /// temporary hack to avoid creating a true HttpsServer class
+    const bool isHttpsServer;
+
+    CBDATA_CLASS2(Server);
+};
+
+} // namespace Http
+
+CBDATA_NAMESPACED_CLASS_INIT(Http, Server);
+
+Http::Server::Server(const MasterXaction::Pointer &xact, bool beHttpsServer):
+        AsyncJob("Http::Server"),
+        ConnStateData(xact),
+        isHttpsServer(beHttpsServer)
+{
+}
+
+time_t
+Http::Server::idleTimeout() const
+{
+    return Config.Timeout.clientIdlePconn;
+}
+
+void
+Http::Server::start()
+{
+    ConnStateData::start();
+
+#if USE_OPENSSL
+    // XXX: Until we create an HttpsServer class, use this hack to allow old
+    // client_side.cc code to manipulate ConnStateData object directly
+    if (isHttpsServer) {
+        postHttpsAccept();
+        return;
+    }
+#endif
+
+    typedef CommCbMemFunT<Server, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
+                                      TimeoutDialer, this, Http::Server::requestTimeout);
+    commSetConnTimeout(clientConnection, Config.Timeout.request, timeoutCall);
+    readSomeData();
+}
+
+void
+Http::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
+{
+    if (!handleRequestBodyData())
+        return;
+
+    // too late to read more body
+    if (!isOpen() || stoppedReceiving())
+        return;
+
+    readSomeData();
+}
+
+ClientSocketContext *
+Http::Server::parseOneRequest(Http::ProtocolVersion &ver)
+{
+    ClientSocketContext *context = NULL;
+    PROF_start(HttpServer_parseOneRequest);
+    HttpParserInit(&parser_, in.buf.c_str(), in.buf.length());
+    context = parseHttpRequest(this, &parser_, &method_, &ver);
+    PROF_stop(HttpServer_parseOneRequest);
+    return context;
+}
+
+void
+Http::Server::processParsedRequest(ClientSocketContext *context, const Http::ProtocolVersion &ver)
+{
+    clientProcessRequest(this, &parser_, context, method_, ver);
+}
+
+void
+Http::Server::noteBodyConsumerAborted(BodyPipe::Pointer ptr)
+{
+    ConnStateData::noteBodyConsumerAborted(ptr);
+    stopReceiving("virgin request body consumer aborted"); // closes ASAP
+}
+
+void
+Http::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
+{
+    // the caller guarantees that we are dealing with the current context only
+    ClientSocketContext::Pointer context = getCurrentContext();
+    Must(context != NULL);
+    const ClientHttpRequest *http = context->http;
+    Must(http != NULL);
+
+    // After sending Transfer-Encoding: chunked (at least), always send
+    // the last-chunk if there was no error, ignoring responseFinishedOrFailed.
+    const bool mustSendLastChunk = http->request->flags.chunkedReply &&
+                                   !http->request->flags.streamError &&
+                                   !context->startOfOutput();
+    const bool responseFinishedOrFailed = !rep &&
+                                          !receivedData.data &&
+                                          !receivedData.length;
+    if (responseFinishedOrFailed && !mustSendLastChunk) {
+        context->writeComplete(context->clientConnection, NULL, 0, Comm::OK);
+        return;
+    }
+
+    if (!context->startOfOutput()) {
+        context->sendBody(rep, receivedData);
+        return;
+    }
+
+    assert(rep);
+    http->al->reply = rep;
+    HTTPMSGLOCK(http->al->reply);
+    context->sendStartOfMessage(rep, receivedData);
+}
+
+void
+Http::Server::writeControlMsgAndCall(ClientSocketContext *context, HttpReply *rep, AsyncCall::Pointer &call)
+{
+    // apply selected clientReplyContext::buildReplyHeader() mods
+    // it is not clear what headers are required for control messages
+    rep->header.removeHopByHopEntries();
+    rep->header.putStr(HDR_CONNECTION, "keep-alive");
+    httpHdrMangleList(&rep->header, getCurrentContext()->http->request, ROR_REPLY);
+
+    MemBuf *mb = rep->pack();
+
+    debugs(11, 2, "HTTP Client " << clientConnection);
+    debugs(11, 2, "HTTP Client CONTROL MSG:\n---------\n" << mb->buf << "\n----------");
+
+    Comm::Write(context->clientConnection, mb, call);
+
+    delete mb;
+}
+
+ConnStateData *
+Http::NewServer(MasterXactionPointer &xact)
+{
+    return new Server(xact, false);
+}
+
+ConnStateData *
+Https::NewServer(MasterXactionPointer &xact)
+{
+    return new Http::Server(xact, true);
+}
@@ -0,0 +1,10 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libservers.la
+
+libservers_la_SOURCES = \
+	FtpServer.cc \
+	FtpServer.h \
+	HttpServer.cc \
+	forward.h
@@ -0,0 +1,36 @@
+#ifndef SQUID_SERVERS_FORWARD_H
+#define SQUID_SERVERS_FORWARD_H
+
+class MasterXaction;
+template <class C> class RefCount;
+typedef RefCount<MasterXaction> MasterXactionPointer;
+
+class ConnStateData;
+
+namespace Http
+{
+
+/// create a new HTTP connection handler; never returns NULL
+ConnStateData *NewServer(MasterXactionPointer &xact);
+
+} // namespace Http
+
+namespace Https
+{
+
+/// create a new HTTPS connection handler; never returns NULL
+ConnStateData *NewServer(MasterXactionPointer &xact);
+
+} // namespace Https
+
+namespace Ftp
+{
+
+/// accept connections on all configured ftp_ports
+void StartListening();
+/// reject new connections to any configured ftp_port
+void StopListening();
+
+} // namespace Ftp
+
+#endif /* SQUID_SERVERS_FORWARD_H */
@@ -90,6 +90,7 @@ void Ssl::GlobalContextStorage::reconfigureFinish()
         for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); ++i) {
             std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.find(i->first);
             if (conf_i == configureStorage.end() || conf_i->second <= 0) {
+                delete i->second;
                 storage.erase(i);
             } else {
                 i->second->setMemLimit(conf_i->second);
@@ -250,11 +250,12 @@ std::string & Ssl::CertificateProperties::dbKey() const
     return certKey;
 }
 
-// Copy certificate extensions from cert to mimicCert.
+/// Copy certificate extensions from cert to mimicCert.
+/// Returns the number of extensions copied.
 // Currently only extensions which are reported by the users that required are
 // mimicked. More safe to mimic extensions would be added here if users request
 // them.
-static void
+static int
 mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
 {
     static int extensions[]= {
@@ -279,12 +280,14 @@ mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
 
     int mimicAlgo = OBJ_obj2nid(mimicCert.get()->cert_info->key->algor->algorithm);
 
+    int added = 0;
     int nid;
     for (int i = 0; (nid = extensions[i]) != 0; ++i) {
         const int pos = X509_get_ext_by_NID(mimicCert.get(), nid, -1);
         if (X509_EXTENSION *ext = X509_get_ext(mimicCert.get(), pos)) {
             // Mimic extension exactly.
-            X509_add_ext(cert.get(), ext, -1);
+            if (X509_add_ext(cert.get(), ext, -1))
+                ++added;
             if ( nid == NID_key_usage && mimicAlgo != NID_rsaEncryption ) {
                 // NSS does not requre the KeyEncipherment flag on EC keys
                 // but it does require it for RSA keys.  Since ssl-bump
@@ -304,6 +307,8 @@ mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
 
     // We could also restrict mimicking of the CA extension to CA:FALSE
     // because Squid does not generate valid fake CA certificates.
+
+    return added;
 }
 
 static bool buildCertificate(Ssl::X509_Pointer & cert, Ssl::CertificateProperties const &properties)
@@ -363,22 +368,24 @@ static bool buildCertificate(Ssl::X509_Pointer & cert, Ssl::CertificatePropertie
             X509_alias_set1(cert.get(), alStr, alLen);
         }
 
+        int addedExtensions = 0;
+
         // Mimic subjectAltName unless we used a configured CN: browsers reject
         // certificates with CN unrelated to subjectAltNames.
         if (!properties.setCommonName) {
             int pos=X509_get_ext_by_NID (properties.mimicCert.get(), OBJ_sn2nid("subjectAltName"), -1);
             X509_EXTENSION *ext=X509_get_ext(properties.mimicCert.get(), pos);
             if (ext) {
-                X509_add_ext(cert.get(), ext, -1);
-                /* According the RFC 5280 using extensions requires version 3
-                   certificate.
-                   Set version value to 2 for version 3 certificates.
-                 */
-                X509_set_version(cert.get(), 2);
+                if (X509_add_ext(cert.get(), ext, -1))
+                    ++addedExtensions;
             }
         }
 
-        mimicExtensions(cert, properties.mimicCert);
+        addedExtensions += mimicExtensions(cert, properties.mimicCert);
+
+        // According to RFC 5280, using extensions requires v3 certificate.
+        if (addedExtensions)
+            X509_set_version(cert.get(), 2); // value 2 means v3
     }
 
     return true;
@@ -1,7 +1,3 @@
-/*
- * 2009/01/17
- */
-
 #ifndef SQUID_SSL_GADGETS_H
 #define SQUID_SSL_GADGETS_H
 
@@ -1846,6 +1846,19 @@ storeSwapFileNumberSet(StoreEntry * e, sfileno filn)
 
 #endif
 
+void
+StoreEntry::storeErrorResponse(HttpReply *reply)
+{
+    lock("StoreEntry::storeErrorResponse");
+    buffer();
+    replaceHttpReply(reply);
+    flush();
+    complete();
+    negativeCache();
+    releaseRequest();
+    unlock("StoreEntry::storeErrorResponse");
+}
+
 /*
  * Replace a store entry with
  * a new reply. This eats the reply.
@@ -55,6 +55,6 @@ SBuf::size_type SBuf::rfind(const SBuf &str, size_type endPos) const STUB_RETVAL
 SBuf::size_type SBuf::findFirstOf(const CharacterSet &set, size_type startPos) const STUB_RETVAL(SBuf::npos)
 SBuf::size_type SBuf::findFirstNotOf(const CharacterSet &set, size_type startPos) const STUB_RETVAL(SBuf::npos)
 int SBuf::scanf(const char *format, ...) STUB_RETVAL(-1)
-SBuf SBuf::toLower() const STUB_RETVAL(*this)
-SBuf SBuf::toUpper() const STUB_RETVAL(*this)
+void SBuf::toLower() STUB
+void SBuf::toUpper() STUB
 String SBuf::toString() const STUB_RETVAL(String(""))
@@ -37,7 +37,6 @@ void ConnStateData::readNextRequest() STUB
 void ConnStateData::addContextToQueue(ClientSocketContext * context) STUB
 int ConnStateData::getConcurrentRequestCount() const STUB_RETVAL(0)
 bool ConnStateData::isOpen() const STUB_RETVAL(false)
-void ConnStateData::checkHeaderLimits() STUB
 void ConnStateData::sendControlMsg(HttpControlMsg msg) STUB
 int64_t ConnStateData::mayNeedToReadMoreBody() const STUB_RETVAL(0)
 #if USE_AUTH
@@ -53,8 +52,8 @@ void ConnStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer) STUB
 void ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer) STUB
 bool ConnStateData::handleReadData() STUB_RETVAL(false)
 bool ConnStateData::handleRequestBodyData() STUB_RETVAL(false)
-void ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth) STUB
-void ConnStateData::unpinConnection() STUB
+void ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth, bool monitor) STUB
+void ConnStateData::unpinConnection(const bool andClose) STUB
 const Comm::ConnectionPointer ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *peer) STUB_RETVAL(NULL)
 void ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io) STUB
 void ConnStateData::clientReadRequest(const CommIoCbParams &io) STUB
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #if USE_AUTH
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 
 #if USE_AUTH
@@ -1,6 +1,4 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
-
 #include "testBoilerplate.h"
 
 #include <stdexcept>
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "CacheManager.h"
 #include "Mem.h"
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 #include "ConfigParser.h"
 #include "event.h"
@@ -1,6 +1,4 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
-
 #include "DiskIO/DiskIOModule.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #include <cppunit/TestAssert.h>
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #include <cppunit/TestAssert.h>
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #include <cppunit/TestAssert.h>
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 #include <cppunit/TestAssert.h>
 
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #include <cppunit/TestAssert.h>
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include <cppunit/TestAssert.h>
 
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #include <cppunit/BriefTestProgressListener.h>
@@ -1,6 +1,4 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
-
 #include "ConfigParser.h"
 #include "DiskIO/DiskIOModule.h"
 #include "fs/rock/RockSwapDir.h"
@@ -784,7 +784,7 @@ testSBuf::testCopy()
 void
 testSBuf::testStringOps()
 {
-    SBuf sng(literal.toLower()),
+    SBuf sng(ToLower(literal)),
     ref("the quick brown fox jumped over the lazy dog");
     CPPUNIT_ASSERT_EQUAL(ref,sng);
     sng=literal;
@@ -820,7 +820,7 @@ testSBuf::testStartsWith()
 
     // case-insensitive checks
     CPPUNIT_ASSERT(literal.startsWith(casebuf,caseInsensitive));
-    casebuf=SBuf(fox1).toUpper();
+    casebuf=ToUpper(SBuf(fox1));
     CPPUNIT_ASSERT(literal.startsWith(casebuf,caseInsensitive));
     CPPUNIT_ASSERT(literal.startsWith(SBuf(fox1),caseInsensitive));
     casebuf = "tha quick";
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 #include "StatHist.h"
 #include "testStatHist.h"
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "Store.h"
 #include "testStore.h"
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "Mem.h"
 #include "MemObject.h"
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "CapturingStoreEntry.h"
 #include "Mem.h"
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "Mem.h"
 #include "MemObject.h"
@@ -30,8 +30,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 #include "event.h"
 #include "EventLoop.h"
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 #include "event.h"
 #include "Mem.h"
@@ -1,4 +1,3 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
 
 #include <cppunit/TestAssert.h>
@@ -1,6 +1,4 @@
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
-
 #include "DiskIO/DiskIOModule.h"
 #include "fs/ufs/UFSSwapDir.h"
 #include "globals.h"
@@ -1,5 +1,3 @@
-#define SQUID_UNIT_TEST 1
-
 #include "squid.h"
 
 #include <cppunit/TestAssert.h>
@@ -29,23 +29,12 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-#define SQUID_UNIT_TEST 1
 #include "squid.h"
-
-#if 0
-//#include "Store.h"
-//#include "client_side_request.h"
-#endif
-
-/** \todo CLEANUP: This file shoudl be called something_stub.cc */
-
 #include "HttpHeader.h"
 #include "HttpHeaderRange.h"
 #include "Mem.h"
 
-#if 0
-#include "acl/Checklist.h"
-#endif
+/** \todo CLEANUP: This file should be called something_stub.cc */
 
 void httpHeaderPutStr(HttpHeader * hdr, http_hdr_type type, const char *str)
 {
@@ -102,8 +102,8 @@ releaseServerSockets(void)
 {
     // Release the main ports as early as possible
 
-    // clear both http_port and https_port lists.
-    clientHttpConnectionsClose();
+    // clear http_port, https_port, and ftp_port lists
+    clientConnectionsClose();
 
     // clear icp_port's
     icpClosePorts();
@@ -1151,6 +1151,14 @@ getMyPort(void)
     }
 #endif
 
+    if ((p = FtpPortList) != NULL) {
+        // skip any special interception ports
+        while (p != NULL && p->flags.isIntercepted())
+            p = p->next;
+        if (p != NULL)
+            return p->s.port();
+    }
+
     debugs(21, DBG_CRITICAL, "ERROR: No forward-proxy ports configured.");
     return 0; // Invalid port. This will result in invalid URLs on bad configurations.
 }
@@ -3,13 +3,22 @@
 
 #if HAVE_GSSAPI
 
+#if USE_HEIMDAL_KRB5
+#if HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#elif HAVE_GSSAPI_H
+#include <gssapi.h>
+#endif /* HAVE_GSSAPI_GSSAPI_H/HAVE_GSSAPI_H */
+#elif USE_GNUGSS
+#if HAVE_GSS_H
+#include <gss.h>
+#endif
+#else
 #if HAVE_GSSAPI_GSSAPI_H
 #include <gssapi/gssapi.h>
 #elif HAVE_GSSAPI_H
 #include <gssapi.h>
 #endif /* HAVE_GSSAPI_GSSAPI_H/HAVE_GSSAPI_H */
-
-#if !HAVE_HEIMDAL_KERBEROS
 #if HAVE_GSSAPI_GSSAPI_KRB5_H
 #include <gssapi/gssapi_krb5.h>
 #endif