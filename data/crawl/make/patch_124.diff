diff --git a/ChangeLog b/ChangeLog
index 358d654..3986793 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,30 @@
+2006-04-09  Paul D. Smith  <psmith@gnu.org>
+
+	* maintMakefile: Add some extra warning options (GCC 4.1 only?)
+
+	* expand.c, implicit.c, main.c, read.c: Rename variables so that
+	inner-scope variables don't mask outer-scope variables.
+
+	* ar.c, arscan.c, commands.c, default.c, dir.c, expand.c, file.c:
+	* function.c, getloadavg.c, implicit.c, job.c, main.c, misc.c, read.c:
+	* remake.c, remote-cstms.c, rule.c, strcache.c, variable.c:
+	* vmsfunctions.c, vmsify.c, vpath.c: Remove all casts of returned
+	values from memory allocation functions: they return void* and so
+	don't need to be cast.  Also remove (char *) casts of arguments to
+	xrealloc().
+
+	* configure.in: Remove checks for memcpy/memmove/strchr.
+
+	* make.h: Remove bcmp/bcopy/bzero/strchr/strrchr macros.
+
+	* ar.c, arscan.c, commands.c, dir.c: Convert all bzero/bcopy/bcmp
+	calls to memset/memcpy/memmove/memcmp calls.
+	* expand.c, file.c, function.c, getloadavg.c, implicit.c: Ditto.
+	* job.c, main.c, misc.c, read.c, remake.c, rule.c: Ditto.
+	* variable.c, vpath.c: Ditto.
+
+	* make.h (EXIT_FAILURE): Should be 1, not 0.
+
 2006-04-06  Paul D. Smith  <psmith@gnu.org>
 
 	* configure.in: Removed AM_C_PROTOTYPES.  Starting now on we
diff --git a/ar.c b/ar.c
index 956432e..9487146 100644
--- a/ar.c
+++ b/ar.c
@@ -216,7 +216,7 @@ ar_glob_match (int desc UNUSED, char *mem, int truncated UNUSED,
   if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
     {
       /* We have a match.  Add it to the chain.  */
-      struct nameseq *new = (struct nameseq *) xmalloc (state->size);
+      struct nameseq *new = xmalloc (state->size);
       new->name = concat (state->arname, mem, ")");
       new->next = state->chain;
       state->chain = new;
@@ -276,8 +276,8 @@ ar_glob (char *arname, char *member_pattern, unsigned int size)
   /* Scan the archive for matches.
      ar_glob_match will accumulate them in STATE.chain.  */
   i = strlen (arname);
-  state.arname = (char *) alloca (i + 2);
-  bcopy (arname, state.arname, i);
+  state.arname = alloca (i + 2);
+  memcpy (state.arname, arname, i);
   state.arname[i] = '(';
   state.arname[i + 1] = '\0';
   state.pattern = member_pattern;
@@ -290,13 +290,13 @@ ar_glob (char *arname, char *member_pattern, unsigned int size)
     return 0;
 
   /* Now put the names into a vector for sorting.  */
-  names = (char **) alloca (state.n * sizeof (char *));
+  names = alloca (state.n * sizeof (char *));
   i = 0;
   for (n = state.chain; n != 0; n = n->next)
     names[i++] = n->name;
 
   /* Sort them alphabetically.  */
-  qsort ((char *) names, i, sizeof (*names), alpha_compare);
+  qsort (names, i, sizeof (*names), alpha_compare);
 
   /* Put them back into the chain in the sorted order.  */
   i = 0;
diff --git a/arscan.c b/arscan.c
index 07cf751..97649a8 100644
--- a/arscan.c
+++ b/arscan.c
@@ -320,7 +320,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
   {
     char buf[SARMAG];
     register int nread = read (desc, buf, SARMAG);
-    if (nread != SARMAG || bcmp (buf, ARMAG, SARMAG))
+    if (nread != SARMAG || memcmp (buf, ARMAG, SARMAG))
       {
 	(void) close (desc);
 	return -2;
@@ -329,7 +329,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 #else
 #ifdef AIAMAG
   {
-    register int nread = read (desc, (char *) &fl_header, FL_HSZ);
+    register int nread = read (desc, &fl_header, FL_HSZ);
 
     if (nread != FL_HSZ)
       {
@@ -339,7 +339,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 #ifdef AIAMAGBIG
     /* If this is a "big" archive, then set the flag and
        re-read the header into the "big" structure. */
-    if (!bcmp (fl_header.fl_magic, AIAMAGBIG, SAIAMAG))
+    if (!memcmp (fl_header.fl_magic, AIAMAGBIG, SAIAMAG))
       {
 	big_archive = 1;
 
@@ -351,7 +351,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 	  }
 
 	/* re-read the header into the "big" structure */
-	nread = read (desc, (char *) &fl_header_big, FL_HSZ_BIG);
+	nread = read (desc, &fl_header_big, FL_HSZ_BIG);
 	if (nread != FL_HSZ_BIG)
 	  {
 	    (void) close (desc);
@@ -361,7 +361,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
     else
 #endif
        /* Check to make sure this is a "normal" archive. */
-      if (bcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
+      if (memcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
 	{
           (void) close (desc);
           return -2;
@@ -455,7 +455,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 #ifdef AIAMAGBIG
 	if (big_archive)
 	  {
-	    nread = read (desc, (char *) &member_header_big,
+	    nread = read (desc, &member_header_big,
 			  AR_MEMHDR_SZ(member_header_big) );
 
 	    if (nread != AR_MEMHDR_SZ(member_header_big))
@@ -487,7 +487,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 	else
 #endif
 	  {
-	    nread = read (desc, (char *) &member_header,
+	    nread = read (desc, &member_header,
 			  AR_MEMHDR_SZ(member_header) );
 
 	    if (nread != AR_MEMHDR_SZ(member_header))
@@ -525,7 +525,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 		       eltmode, arg);
 
 #else	/* Not AIAMAG.  */
-	nread = read (desc, (char *) &member_header, AR_HDR_SIZE);
+	nread = read (desc, &member_header, AR_HDR_SIZE);
 	if (nread == 0)
 	  /* No data left means end of file; that is OK.  */
 	  break;
@@ -534,13 +534,13 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 #if defined(ARFMAG) || defined(ARFZMAG)
 	    || (
 # ifdef ARFMAG
-                bcmp (member_header.ar_fmag, ARFMAG, 2)
+                memcmp (member_header.ar_fmag, ARFMAG, 2)
 # else
                 1
 # endif
                 &&
 # ifdef ARFZMAG
-                bcmp (member_header.ar_fmag, ARFZMAG, 2)
+                memcmp (member_header.ar_fmag, ARFZMAG, 2)
 # else
                 1
 # endif
@@ -553,7 +553,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
 	  }
 
 	name = namebuf;
-	bcopy (member_header.ar_name, name, sizeof member_header.ar_name);
+	memcpy (name, member_header.ar_name, sizeof member_header.ar_name);
 	{
 	  register char *p = name + sizeof member_header.ar_name;
 	  do
@@ -593,7 +593,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
  	    {
  	      int namesize = atoi (name + 3);
 
- 	      name = (char *) alloca (namesize + 1);
+ 	      name = alloca (namesize + 1);
  	      nread = read (desc, name, namesize);
  	      if (nread != namesize)
  		{
@@ -664,7 +664,7 @@ ar_scan (char *archive, long int (*function)(), long int arg)
  	    char *clear;
  	    char *limit;
 
- 	    namemap = (char *) alloca (eltsize);
+ 	    namemap = alloca (eltsize);
  	    nread = read (desc, namemap, eltsize);
  	    if (nread != eltsize)
  	      {
@@ -775,12 +775,12 @@ ar_member_touch (char *arname, char *memname)
   /* Read in this member's header */
   if (lseek (fd, pos, 0) < 0)
     goto lose;
-  if (AR_HDR_SIZE != read (fd, (char *) &ar_hdr, AR_HDR_SIZE))
+  if (AR_HDR_SIZE != read (fd, &ar_hdr, AR_HDR_SIZE))
     goto lose;
   /* Write back the header, thus touching the archive file.  */
   if (lseek (fd, pos, 0) < 0)
     goto lose;
-  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
+  if (AR_HDR_SIZE != write (fd, &ar_hdr, AR_HDR_SIZE))
     goto lose;
   /* The file's mtime is the time we we want.  */
   EINTRLOOP (i, fstat (fd, &statbuf));
@@ -800,7 +800,7 @@ ar_member_touch (char *arname, char *memname)
   /* Write back this member's header */
   if (lseek (fd, pos, 0) < 0)
     goto lose;
-  if (AR_HDR_SIZE != write (fd, (char *) &ar_hdr, AR_HDR_SIZE))
+  if (AR_HDR_SIZE != write (fd, &ar_hdr, AR_HDR_SIZE))
     goto lose;
   close (fd);
   return 0;
diff --git a/commands.c b/commands.c
index 053aac2..923dc7c 100644
--- a/commands.c
+++ b/commands.c
@@ -57,12 +57,12 @@ set_file_variables (struct file *file)
       char *p;
 
       p = strchr (file->name, '(');
-      at = (char *) alloca (p - file->name + 1);
-      bcopy (file->name, at, p - file->name);
+      at = alloca (p - file->name + 1);
+      memcpy (at, file->name, p - file->name);
       at[p - file->name] = '\0';
       len = strlen (p + 1);
-      percent = (char *) alloca (len);
-      bcopy (p + 1, percent, len - 1);
+      percent = alloca (len);
+      memcpy (percent, p + 1, len - 1);
       percent[len - 1] = '\0';
     }
   else
@@ -78,7 +78,6 @@ set_file_variables (struct file *file)
       /* In Unix make, $* is set to the target name with
 	 any suffix in the .SUFFIXES list stripped off for
 	 explicit rules.  We store this in the `stem' member.  */
-      register struct dep *d;
       char *name;
       unsigned int len;
 
@@ -176,7 +175,7 @@ set_file_variables (struct file *file)
 #endif
             len = strlen (c);
 
-          bcopy (c, cp, len);
+          memcpy (cp, c, len);
           cp += len;
           *cp++ = FILE_LIST_SEPARATOR;
           if (! d->changed)
@@ -229,18 +228,18 @@ set_file_variables (struct file *file)
 
         if (d->ignore_mtime)
           {
-	    bcopy (c, bp, len);
+	    memcpy (bp, c, len);
 	    bp += len;
 	    *bp++ = FILE_LIST_SEPARATOR;
 	  }
 	else
 	  {
-            bcopy (c, cp, len);
+            memcpy (cp, c, len);
             cp += len;
             *cp++ = FILE_LIST_SEPARATOR;
             if (d->changed)
               {
-                bcopy (c, qp, len);
+                memcpy (qp, c, len);
                 qp += len;
                 *qp++ = FILE_LIST_SEPARATOR;
               }
@@ -283,7 +282,7 @@ chop_commands (struct commands *cmds)
 	 and the CMDS->any_recurse flag.  */
 
   nlines = 5;
-  lines = (char **) xmalloc (5 * sizeof (char *));
+  lines = xmalloc (5 * sizeof (char *));
   idx = 0;
   p = cmds->commands;
   while (*p != '\0')
@@ -309,8 +308,7 @@ chop_commands (struct commands *cmds)
       if (idx == nlines)
         {
           nlines += 2;
-          lines = (char **) xrealloc ((char *) lines,
-                                      nlines * sizeof (char *));
+          lines = xrealloc (lines, nlines * sizeof (char *));
         }
       lines[idx++] = savestring (p, end - p);
       p = end;
@@ -321,15 +319,14 @@ chop_commands (struct commands *cmds)
   if (idx != nlines)
     {
       nlines = idx;
-      lines = (char **) xrealloc ((char *) lines,
-                                  nlines * sizeof (char *));
+      lines = xrealloc (lines, nlines * sizeof (char *));
     }
 
   cmds->ncommand_lines = nlines;
   cmds->command_lines = lines;
 
   cmds->any_recurse = 0;
-  cmds->lines_flags = (char *) xmalloc (nlines);
+  cmds->lines_flags = xmalloc (nlines);
   for (idx = 0; idx < nlines; ++idx)
     {
       int flags = 0;
@@ -580,7 +577,7 @@ delete_child_targets (struct child *child)
     return;
 
   /* Delete the target file if it changed.  */
-  delete_target (child->file, (char *) 0);
+  delete_target (child->file, 0);
 
   /* Also remove any non-precious targets listed in the `also_make' member.  */
   for (d = child->file->also_make; d != 0; d = d->next)
diff --git a/configure.in b/configure.in
index 6b417f0..c842ac5 100644
--- a/configure.in
+++ b/configure.in
@@ -146,7 +146,7 @@ if test "$ac_cv_func_gettimeofday" = yes; then
 	    [Define if you have a standard gettimeofday function])
 fi
 
-AC_CHECK_FUNCS(	memcpy memmove strchr strdup mkstemp mktemp fdopen \
+AC_CHECK_FUNCS( strdup mkstemp mktemp fdopen \
 	        bsd_signal dup2 getcwd realpath sigsetmask sigaction \
                 getgroups seteuid setegid setlinebuf setreuid setregid \
                 getrlimit setrlimit setvbuf pipe strerror strsignal \
diff --git a/default.c b/default.c
index 86f719a..ada0a8a 100644
--- a/default.c
+++ b/default.c
@@ -555,7 +555,7 @@ install_default_suffix_rules (void)
       /* Don't clobber cmds given in a makefile if there were any.  */
       if (f->cmds == 0)
 	{
-	  f->cmds = (struct commands *) xmalloc (sizeof (struct commands));
+	  f->cmds = xmalloc (sizeof (struct commands));
 	  f->cmds->fileinfo.filenm = 0;
 	  f->cmds->commands = s[1];
 	  f->cmds->command_lines = 0;
diff --git a/dir.c b/dir.c
index d88d097..b6c18a6 100644
--- a/dir.c
+++ b/dir.c
@@ -450,7 +450,7 @@ find_directory (char *name)
       /* The directory was not found.  Create a new entry for it.  */
 
       p = name + strlen (name);
-      dir = (struct directory *) xmalloc (sizeof (struct directory));
+      dir = xmalloc (sizeof (struct directory));
       dir->name = savestring (name, p - name);
       hash_insert_at (&directories, dir, dir_slot);
       /* The directory is not in the name hash table.
@@ -561,7 +561,7 @@ find_directory (char *name)
 		  if (open_directories == MAX_OPEN_DIRECTORIES)
 		    /* We have too many directories open already.
 		       Read the entire directory and then close it.  */
-		    (void) dir_contents_file_exists_p (dc, (char *) 0);
+		    (void) dir_contents_file_exists_p (dc, 0);
 		}
 	    }
 
@@ -702,7 +702,7 @@ dir_contents_file_exists_p (struct directory_contents *dir, char *filename)
       if (! rehash || HASH_VACANT (*dirfile_slot))
 #endif
 	{
-	  df = (struct dirfile *) xmalloc (sizeof (struct dirfile));
+	  df = xmalloc (sizeof (struct dirfile));
 	  df->name = savestring (d->d_name, len);
 	  df->length = len;
 	  df->impossible = 0;
@@ -755,7 +755,7 @@ file_exists_p (char *name)
   dirend = strrchr (name, ']');
   if (dirend == 0)
     dirend = strrchr (name, ':');
-  if (dirend == (char *)0)
+  if (dirend == 0)
     return dir_file_exists_p ("[]", name);
 #else /* !VMS */
   dirend = strrchr (name, '/');
@@ -789,8 +789,8 @@ file_exists_p (char *name)
 	  (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
 	dirend++;
 #endif
-      dirname = (char *) alloca (dirend - name + 1);
-      bcopy (name, dirname, dirend - name);
+      dirname = alloca (dirend - name + 1);
+      memcpy (dirname, name, dirend - name);
       dirname[dirend - name] = '\0';
     }
   return dir_file_exists_p (dirname, slash + 1);
@@ -849,8 +849,8 @@ file_impossible (char *filename)
 	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
 	    dirend++;
 #endif
-	  dirname = (char *) alloca (dirend - p + 1);
-	  bcopy (p, dirname, dirend - p);
+	  dirname = alloca (dirend - p + 1);
+	  memcpy (dirname, p, dirend - p);
 	  dirname[dirend - p] = '\0';
 	}
       dir = find_directory (dirname);
@@ -863,7 +863,7 @@ file_impossible (char *filename)
 	 structure for it, but leave it out of the contents hash table.  */
       dir->contents = (struct directory_contents *)
 	xmalloc (sizeof (struct directory_contents));
-      bzero ((char *) dir->contents, sizeof (struct directory_contents));
+      memset (dir->contents, '\0', sizeof (struct directory_contents));
     }
 
   if (dir->contents->dirfiles.ht_vec == 0)
@@ -874,7 +874,7 @@ file_impossible (char *filename)
 
   /* Make a new entry and put it in the table.  */
 
-  new = (struct dirfile *) xmalloc (sizeof (struct dirfile));
+  new = xmalloc (sizeof (struct dirfile));
   new->name = xstrdup (filename);
   new->length = strlen (filename);
   new->impossible = 1;
@@ -930,8 +930,8 @@ file_impossible_p (char *filename)
 	      (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
 	    dirend++;
 #endif
-	  dirname = (char *) alloca (dirend - filename + 1);
-	  bcopy (p, dirname, dirend - p);
+	  dirname = alloca (dirend - filename + 1);
+	  memcpy (dirname, p, dirend - p);
 	  dirname[dirend - p] = '\0';
 	}
       dir = find_directory (dirname)->contents;
@@ -1099,7 +1099,7 @@ static __ptr_t
 open_dirstream (const char *directory)
 {
   struct dirstream *new;
-  struct directory *dir = find_directory ((char *)directory);
+  struct directory *dir = find_directory (directory);
 
   if (dir->contents == 0 || dir->contents->dirfiles.ht_vec == 0)
     /* DIR->contents is nil if the directory could not be stat'd.
@@ -1109,9 +1109,9 @@ open_dirstream (const char *directory)
   /* Read all the contents of the directory now.  There is no benefit
      in being lazy, since glob will want to see every file anyway.  */
 
-  (void) dir_contents_file_exists_p (dir->contents, (char *) 0);
+  dir_contents_file_exists_p (dir->contents, 0);
 
-  new = (struct dirstream *) xmalloc (sizeof (struct dirstream));
+  new = xmalloc (sizeof (struct dirstream));
   new->contents = dir->contents;
   new->dirfile_slot = (struct dirfile **) new->contents->dirfiles.ht_vec;
 
diff --git a/expand.c b/expand.c
index 5aa0de9..7ca0b92 100644
--- a/expand.c
+++ b/expand.c
@@ -65,12 +65,11 @@ variable_buffer_output (char *ptr, char *string, unsigned int length)
       variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
 				? newlen + 100
 				: 2 * variable_buffer_length);
-      variable_buffer = (char *) xrealloc (variable_buffer,
-					   variable_buffer_length);
+      variable_buffer = xrealloc (variable_buffer, variable_buffer_length);
       ptr = variable_buffer + offset;
     }
 
-  bcopy (string, ptr, length);
+  memcpy (ptr, string, length);
   return ptr + length;
 }
 
@@ -84,7 +83,7 @@ initialize_variable_output (void)
   if (variable_buffer == 0)
     {
       variable_buffer_length = 200;
-      variable_buffer = (char *) xmalloc (variable_buffer_length);
+      variable_buffer = xmalloc (variable_buffer_length);
       variable_buffer[0] = '\0';
     }
 
@@ -196,8 +195,8 @@ reference_variable (char *o, char *name, unsigned int length)
 char *
 variable_expand_string (char *line, char *string, long length)
 {
-  register struct variable *v;
-  register char *p, *o, *p1;
+  struct variable *v;
+  char *p, *o, *p1;
   char save_char = '\0';
   unsigned int line_offset;
 
@@ -333,15 +332,14 @@ variable_expand_string (char *line, char *string, long length)
                         /* Copy the pattern and the replacement.  Add in an
                            extra % at the beginning to use in case there
                            isn't one in the pattern.  */
-                        pattern = (char *) alloca (subst_end - subst_beg + 2);
+                        pattern = alloca (subst_end - subst_beg + 2);
                         *(pattern++) = '%';
-                        bcopy (subst_beg, pattern, subst_end - subst_beg);
+                        memcpy (pattern, subst_beg, subst_end - subst_beg);
                         pattern[subst_end - subst_beg] = '\0';
 
-                        replace = (char *) alloca (replace_end
-                                                   - replace_beg + 2);
+                        replace = alloca (replace_end - replace_beg + 2);
                         *(replace++) = '%';
-                        bcopy (replace_beg, replace,
+                        memcpy (replace, replace_beg,
                                replace_end - replace_beg);
                         replace[replace_end - replace_beg] = '\0';
 
@@ -433,10 +431,10 @@ expand_argument (const char *str, const char *end)
     return xstrdup("");
 
   if (!end || *end == '\0')
-    return allocated_variable_expand ((char *)str);
+    return allocated_variable_expand (str);
 
-  tmp = (char *) alloca (end - str + 1);
-  bcopy (str, tmp, end - str);
+  tmp = alloca (end - str + 1);
+  memcpy (tmp, str, end - str);
   tmp[end - str] = '\0';
 
   return allocated_variable_expand (tmp);
diff --git a/file.c b/file.c
index 90dd123..b2f95e8 100644
--- a/file.c
+++ b/file.c
@@ -78,7 +78,7 @@ lookup_file (char *name)
   register struct file *f;
   struct file file_key;
 #if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
-  register char *lname, *ln;
+  char *lname, *ln;
 #endif
 
   assert (*name != '\0');
@@ -90,8 +90,8 @@ lookup_file (char *name)
 # ifndef WANT_CASE_SENSITIVE_TARGETS
   if (*name != '.')
     {
-      register char *n;
-      lname = (char *) malloc (strlen (name) + 1);
+      char *n;
+      lname = xmalloc (strlen (name) + 1);
       for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
         *ln = isupper ((unsigned char)*n) ? tolower ((unsigned char)*n) : *n;
       *ln = '\0';
@@ -147,8 +147,8 @@ enter_file (char *name)
 #if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
   if (*name != '.')
     {
-      register char *n;
-      lname = (char *) malloc (strlen (name) + 1);
+      char *n;
+      lname = xmalloc (strlen (name) + 1);
       for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
         {
           if (isupper ((unsigned char)*n))
@@ -176,8 +176,8 @@ enter_file (char *name)
       return f;
     }
 
-  new = (struct file *) xmalloc (sizeof (struct file));
-  bzero ((char *) new, sizeof (struct file));
+  new = xmalloc (sizeof (struct file));
+  memset (new, '\0', sizeof (struct file));
   new->name = new->hname = name;
   new->update_status = -1;
 
@@ -539,7 +539,7 @@ expand_deps (struct file *f)
                      will always be empty.  */
                   if (d->stem[0] == '\0')
                     /* This needs memmove() in ISO C.  */
-                    bcopy (percent+1, percent, strlen (percent));
+                    memmove (percent, percent+1, strlen (percent));
                   else
                     {
                       char *o = patsubst_expand (buffer, d->stem, pattern,
@@ -1030,7 +1030,7 @@ build_target_list (char *value)
                 p = &value[off];
               }
 
-            bcopy (f->name, p, l);
+            memcpy (p, f->name, l);
             p += l;
             *(p++) = ' ';
           }
diff --git a/function.c b/function.c
index 0bc9921..39ad2fe 100644
--- a/function.c
+++ b/function.c
@@ -284,8 +284,8 @@ pattern_matches (char *pattern, char *percent, char *str)
   if (percent == 0)
     {
       unsigned int len = strlen (pattern) + 1;
-      char *new_chars = (char *) alloca (len);
-      bcopy (pattern, new_chars, len);
+      char *new_chars = alloca (len);
+      memcpy (new_chars, pattern, len);
       pattern = new_chars;
       percent = find_percent (pattern);
       if (percent == 0)
@@ -357,7 +357,7 @@ string_glob (char *line)
   if (result == 0)
     {
       length = 100;
-      result = (char *) xmalloc (100);
+      result = xmalloc (100);
     }
 
   idx = 0;
@@ -367,7 +367,7 @@ string_glob (char *line)
       unsigned int len = strlen (name);
 
       struct nameseq *next = chain->next;
-      free ((char *) chain);
+      free (chain);
       chain = next;
 
       /* multi_glob will pass names without globbing metacharacters
@@ -377,9 +377,9 @@ string_glob (char *line)
 	  if (idx + len + 1 > length)
 	    {
 	      length += (len + 1) * 2;
-	      result = (char *) xrealloc (result, length);
+	      result = xrealloc (result, length);
 	    }
-	  bcopy (name, &result[idx], len);
+	  memcpy (&result[idx], name, len);
 	  idx += len;
 	  result[idx++] = ' ';
 	}
@@ -732,7 +732,7 @@ strip_whitespace (const char **begpp, const char **endpp)
 }
 
 static void
-check_numeric (const char *s, const char *message)
+check_numeric (const char *s, const char *msg)
 {
   const char *end = s + strlen (s) - 1;
   const char *beg = s;
@@ -743,7 +743,7 @@ check_numeric (const char *s, const char *message)
       break;
 
   if (s <= end || end - beg < 0)
-    fatal (*expanding_var, "%s: '%s'", message, beg);
+    fatal (*expanding_var, "%s: '%s'", msg, beg);
 }
 
 
@@ -853,7 +853,7 @@ func_foreach (char *o, char **argv, const char *funcname UNUSED)
 
 	p[len] = '\0';
 	free (var->value);
-	var->value = (char *) xstrdup ((char*) p);
+	var->value = xstrdup ((char*) p);
 	p[len] = save;
       }
 
@@ -941,7 +941,7 @@ func_filter_filterout (char *o, char **argv, const char *funcname)
   pattail = &pathead;
   while ((p = find_next_token (&pat_iterator, &len)) != 0)
     {
-      struct a_pattern *pat = (struct a_pattern *) alloca (sizeof (struct a_pattern));
+      struct a_pattern *pat = alloca (sizeof (struct a_pattern));
 
       *pattail = pat;
       pattail = &pat->next;
@@ -964,7 +964,7 @@ func_filter_filterout (char *o, char **argv, const char *funcname)
   wordtail = &wordhead;
   while ((p = find_next_token (&word_iterator, &len)) != 0)
     {
-      struct a_word *word = (struct a_word *) alloca (sizeof (struct a_word));
+      struct a_word *word = alloca (sizeof (struct a_word));
 
       *wordtail = word;
       wordtail = &word->next;
@@ -1091,7 +1091,7 @@ func_error (char *o, char **argv, const char *funcname)
   for (len=0, argvp=argv; *argvp != 0; ++argvp)
     len += strlen (*argvp) + 2;
 
-  p = msg = (char *) alloca (len + 1);
+  p = msg = alloca (len + 1);
 
   for (argvp=argv; argvp[1] != 0; ++argvp)
     {
@@ -1145,8 +1145,7 @@ func_sort (char *o, char **argv, const char *funcname UNUSED)
       if (wordi >= nwords - 1)
 	{
 	  nwords = (2 * nwords) + 5;
-	  words = (char **) xrealloc ((char *) words,
-				      nwords * sizeof (char *));
+	  words = xrealloc (words, nwords * sizeof (char *));
 	}
       words[wordi++] = savestring (p, len);
     }
@@ -1155,7 +1154,7 @@ func_sort (char *o, char **argv, const char *funcname UNUSED)
     return o;
 
   /* Now sort the list of words.  */
-  qsort ((char *) words, wordi, sizeof (char *), alpha_compare);
+  qsort (words, wordi, sizeof (char *), alpha_compare);
 
   /* Now write the sorted list.  */
   for (i = 0; i < wordi; ++i)
@@ -1612,7 +1611,7 @@ func_shell (char *o, char **argv, const char *funcname UNUSED)
   /* For error messages.  */
   if (reading_file && reading_file->filenm)
     {
-      error_prefix = (char *) alloca (strlen (reading_file->filenm)+11+4);
+      error_prefix = alloca (strlen (reading_file->filenm)+11+4);
       sprintf (error_prefix,
 	       "%s:%lu: ", reading_file->filenm, reading_file->lineno);
     }
@@ -1682,16 +1681,16 @@ func_shell (char *o, char **argv, const char *funcname UNUSED)
 
       /* Free the storage only the child needed.  */
       free (command_argv[0]);
-      free ((char *) command_argv);
+      free (command_argv);
 
       /* Close the write side of the pipe.  */
-      (void) close (pipedes[1]);
+      close (pipedes[1]);
 #endif
 
       /* Set up and read from the pipe.  */
 
       maxlen = 200;
-      buffer = (char *) xmalloc (maxlen + 1);
+      buffer = xmalloc (maxlen + 1);
 
       /* Read from the pipe until it gets EOF.  */
       for (i = 0; ; i += cc)
@@ -1699,7 +1698,7 @@ func_shell (char *o, char **argv, const char *funcname UNUSED)
 	  if (i == maxlen)
 	    {
 	      maxlen += 512;
-	      buffer = (char *) xrealloc (buffer, maxlen + 1);
+	      buffer = xrealloc (buffer, maxlen + 1);
 	    }
 
 	  EINTRLOOP (cc, read (pipedes[0], &buffer[i], maxlen - i));
@@ -1826,7 +1825,7 @@ func_shell (char *o, char **argv, const char *funcname)
       if (i == maxlen)
 	{
 	  maxlen += 512;
-	  buffer = (char *) xrealloc (buffer, maxlen + 1);
+	  buffer = xrealloc (buffer, maxlen + 1);
 	}
 
       cc = Read (child_stdout, &buffer[i], maxlen - i);
@@ -2166,7 +2165,7 @@ handle_function (char **op, char **stringp)
   *stringp = end;
 
   /* Get some memory to store the arg pointers.  */
-  argvp = argv = (char **) alloca (sizeof (char *) * (nargs + 2));
+  argvp = argv = alloca (sizeof (char *) * (nargs + 2));
 
   /* Chop the string into arguments, then a nul.  As soon as we hit
      MAXIMUM_ARGS (if it's >0) assume the rest of the string is part of the
@@ -2280,7 +2279,7 @@ func_call (char *o, char **argv, const char *funcname UNUSED)
   if (v == 0 || *v->value == '\0')
     return o;
 
-  body = (char *) alloca (flen + 4);
+  body = alloca (flen + 4);
   body[0] = '$';
   body[1] = '(';
   memcpy (body + 2, fname, flen);
diff --git a/getloadavg.c b/getloadavg.c
index 9367e47..2c29191 100644
--- a/getloadavg.c
+++ b/getloadavg.c
@@ -704,7 +704,7 @@ getloadavg (double loadavg[], int nelem)
       for (i = 0; i < conf.config_maxclass; ++i)
 	{
 	  struct class_stats stats;
-	  bzero ((char *) &stats, sizeof stats);
+	  memset (&stats, '\0', sizeof stats);
 
 	  desc.sd_type = CPUTYPE_CLASS;
 	  desc.sd_objid = i;
diff --git a/implicit.c b/implicit.c
index 1cfd58c..d239952 100644
--- a/implicit.c
+++ b/implicit.c
@@ -222,30 +222,27 @@ pattern_search (struct file *file, int archive,
   unsigned int remove_explicit_deps = 0;
 
   /* Names of possible dependencies are constructed in this buffer.  */
-  register char *depname = (char *) alloca (namelen + max_pattern_dep_length);
+  char *depname = alloca (namelen + max_pattern_dep_length);
 
   /* The start and length of the stem of FILENAME for the current rule.  */
-  register char *stem = 0;
-  register unsigned int stemlen = 0;
-  register unsigned int fullstemlen = 0;
+  char *stem = 0;
+  unsigned int stemlen = 0;
+  unsigned int fullstemlen = 0;
 
   /* Buffer in which we store all the rules that are possibly applicable.  */
-  struct rule **tryrules
-    = (struct rule **) xmalloc (num_pattern_rules * max_pattern_targets
-                                * sizeof (struct rule *));
+  struct rule **tryrules = xmalloc (num_pattern_rules * max_pattern_targets
+                                    * sizeof (struct rule *));
 
   /* Number of valid elements in TRYRULES.  */
   unsigned int nrules;
 
   /* The numbers of the rule targets of each rule
      in TRYRULES that matched the target file.  */
-  unsigned int *matches
-    = (unsigned int *) alloca (num_pattern_rules * sizeof (unsigned int));
+  unsigned int *matches = alloca (num_pattern_rules * sizeof (unsigned int));
 
   /* Each element is nonzero if LASTSLASH was used in
      matching the corresponding element of TRYRULES.  */
-  char *checked_lastslash
-    = (char *) alloca (num_pattern_rules * sizeof (char));
+  char *checked_lastslash = alloca (num_pattern_rules * sizeof (char));
 
   /* The index in TRYRULES of the rule we found.  */
   unsigned int foundrule;
@@ -257,7 +254,7 @@ pattern_search (struct file *file, int archive,
      that is not just `%'.  */
   int specific_rule_matched = 0;
 
-  unsigned int i = 0;  /* uninit checks OK */
+  unsigned int ri;  /* uninit checks OK */
   struct rule *rule;
   struct dep *dep, *expl_d;
 
@@ -306,6 +303,8 @@ pattern_search (struct file *file, int archive,
   nrules = 0;
   for (rule = pattern_rules; rule != 0; rule = rule->next)
     {
+      unsigned int ti;
+
       /* If the pattern rule has deps but no commands, ignore it.
 	 Users cancel built-in rules by redefining them without commands.  */
       if (rule->deps != 0 && rule->cmds == 0)
@@ -319,10 +318,10 @@ pattern_search (struct file *file, int archive,
 	  continue;
 	}
 
-      for (i = 0; rule->targets[i] != 0; ++i)
+      for (ti = 0; rule->targets[ti] != 0; ++ti)
 	{
-	  char *target = rule->targets[i];
-	  char *suffix = rule->suffixes[i];
+	  char *target = rule->targets[ti];
+	  char *suffix = rule->suffixes[ti];
 	  int check_lastslash;
 
 	  /* Rules that can match any filename and are not terminal
@@ -331,14 +330,14 @@ pattern_search (struct file *file, int archive,
 	  if (recursions > 0 && target[1] == '\0' && !rule->terminal)
 	    continue;
 
-	  if (rule->lens[i] > namelen)
+	  if (rule->lens[ti] > namelen)
 	    /* It can't possibly match.  */
 	    continue;
 
 	  /* From the lengths of the filename and the pattern parts,
 	     find the stem: the part of the filename that matches the %.  */
 	  stem = filename + (suffix - target - 1);
-	  stemlen = namelen - rule->lens[i] + 1;
+	  stemlen = namelen - rule->lens[ti] + 1;
 
 	  /* Set CHECK_LASTSLASH if FILENAME contains a directory
 	     prefix and the target pattern does not contain a slash.  */
@@ -404,7 +403,7 @@ pattern_search (struct file *file, int archive,
 	     target in MATCHES.  If several targets of the same rule match,
 	     that rule will be in TRYRULES more than once.  */
 	  tryrules[nrules] = rule;
-	  matches[nrules] = i;
+	  matches[nrules] = ti;
 	  checked_lastslash[nrules] = check_lastslash;
 	  ++nrules;
 	}
@@ -413,15 +412,15 @@ pattern_search (struct file *file, int archive,
   /* If we have found a matching rule that won't match all filenames,
      retroactively reject any non-"terminal" rules that do always match.  */
   if (specific_rule_matched)
-    for (i = 0; i < nrules; ++i)
-      if (!tryrules[i]->terminal)
+    for (ri = 0; ri < nrules; ++ri)
+      if (!tryrules[ri]->terminal)
 	{
-	  register unsigned int j;
-	  for (j = 0; tryrules[i]->targets[j] != 0; ++j)
-	    if (tryrules[i]->targets[j][1] == '\0')
+	  unsigned int j;
+	  for (j = 0; tryrules[ri]->targets[j] != 0; ++j)
+	    if (tryrules[ri]->targets[j][1] == '\0')
 	      break;
-	  if (tryrules[i]->targets[j] != 0)
-	    tryrules[i] = 0;
+	  if (tryrules[ri]->targets[j] != 0)
+	    tryrules[ri] = 0;
 	}
 
   /* We are going to do second expansion so initialize file variables
@@ -435,14 +434,14 @@ pattern_search (struct file *file, int archive,
 	 If it does, expand its dependencies (as substituted)
 	 and chain them in DEPS.  */
 
-      for (i = 0; i < nrules; i++)
+      for (ri = 0; ri < nrules; ri++)
 	{
           struct file *f;
           unsigned int failed = 0;
 	  int check_lastslash;
           int file_variables_set = 0;
 
-	  rule = tryrules[i];
+	  rule = tryrules[ri];
 
           remove_explicit_deps = 0;
 
@@ -463,9 +462,9 @@ pattern_search (struct file *file, int archive,
 	  /* From the lengths of the filename and the matching pattern parts,
 	     find the stem: the part of the filename that matches the %.  */
 	  stem = filename
-	    + (rule->suffixes[matches[i]] - rule->targets[matches[i]]) - 1;
-	  stemlen = namelen - rule->lens[matches[i]] + 1;
-	  check_lastslash = checked_lastslash[i];
+	    + (rule->suffixes[matches[ri]] - rule->targets[matches[ri]]) - 1;
+	  stemlen = namelen - rule->lens[matches[ri]] + 1;
+	  check_lastslash = checked_lastslash[ri];
 	  if (check_lastslash)
 	    {
 	      stem += lastslash - filename + 1;
@@ -532,10 +531,10 @@ pattern_search (struct file *file, int archive,
 
                       if (p2 < p + len)
                         {
-                          register unsigned int i = p2 - p;
-                          bcopy (p, depname, i);
-                          bcopy ("$*", depname + i, 2);
-                          bcopy (p2 + 1, depname + i + 2, len - i - 1);
+                          unsigned int i = p2 - p;
+                          memcpy (depname, p, i);
+                          memcpy (depname + i, "$*", 2);
+                          memcpy (depname + i + 2, p2 + 1, len - i - 1);
                           depname[len + 2 - 1] = '\0';
 
                           if (check_lastslash)
@@ -545,7 +544,7 @@ pattern_search (struct file *file, int archive,
                         }
                       else
                         {
-                          bcopy (p, depname, len);
+                          memcpy (depname, p, len);
                           depname[len] = '\0';
                         }
 
@@ -564,10 +563,10 @@ pattern_search (struct file *file, int archive,
                     {
                        if (p2 < p + len)
                         {
-                          register unsigned int i = p2 - p;
-                          bcopy (p, depname, i);
-                          bcopy (stem_str, depname + i, stemlen);
-                          bcopy (p2 + 1, depname + i + stemlen, len - i - 1);
+                          unsigned int i = p2 - p;
+                          memcpy (depname, p, i);
+                          memcpy (depname + i, stem_str, stemlen);
+                          memcpy (depname + i + stemlen, p2 + 1, len - i - 1);
                           depname[len + stemlen - 1] = '\0';
 
                           if (check_lastslash)
@@ -577,7 +576,7 @@ pattern_search (struct file *file, int archive,
                         }
                       else
                         {
-                          bcopy (p, depname, len);
+                          memcpy (depname, p, len);
                           depname[len] = '\0';
                         }
 
@@ -615,14 +614,14 @@ pattern_search (struct file *file, int archive,
 
                               if (add_dir)
                                 {
-                                  char *p = d->name;
+                                  char *n = d->name;
 
-                                  d->name = xmalloc (strlen (p) + l + 1);
+                                  d->name = xmalloc (strlen (n) + l + 1);
 
-                                  bcopy (filename, d->name, l);
-                                  bcopy (p, d->name + l, strlen (p) + 1);
+                                  memcpy (d->name, filename, l);
+                                  memcpy (d->name + l, n, strlen (n) + 1);
 
-                                  free (p);
+                                  free (n);
                                 }
 
                               if (had_stem)
@@ -666,7 +665,7 @@ pattern_search (struct file *file, int archive,
                         ? _("Rejecting impossible implicit prerequisite `%s'.\n")
                         : _("Rejecting impossible rule prerequisite `%s'.\n"),
                         name));
-                  tryrules[i] = 0;
+                  tryrules[ri] = 0;
 
                   failed = 1;
                   break;
@@ -722,14 +721,13 @@ pattern_search (struct file *file, int archive,
               if (intermed_ok)
                 {
                   if (intermediate_file == 0)
-                    intermediate_file
-                      = (struct file *) alloca (sizeof (struct file));
+                    intermediate_file = alloca (sizeof (struct file));
 
                   DBS (DB_IMPLICIT,
                        (_("Looking for a rule with intermediate file `%s'.\n"),
                         name));
 
-                  bzero ((char *) intermediate_file, sizeof (struct file));
+                  memset (intermediate_file, '\0', sizeof (struct file));
                   intermediate_file->name = name;
                   if (pattern_search (intermediate_file,
                                       0,
@@ -777,7 +775,7 @@ pattern_search (struct file *file, int archive,
 
       /* If we found an applicable rule without
 	 intermediate files, don't try with them.  */
-      if (i < nrules)
+      if (ri < nrules)
 	break;
 
       rule = 0;
@@ -788,7 +786,7 @@ pattern_search (struct file *file, int archive,
   if (rule == 0)
     goto done;
 
-  foundrule = i;
+  foundrule = ri;
 
   /* If we are recursing, store the pattern that matched
      FILENAME in FILE->name for use in upper levels.  */
@@ -922,9 +920,9 @@ pattern_search (struct file *file, int archive,
       /* We want to prepend the directory from
 	 the original FILENAME onto the stem.  */
       fullstemlen = dirlen + stemlen;
-      file->stem = (char *) xmalloc (fullstemlen + 1);
-      bcopy (filename, file->stem, dirlen);
-      bcopy (stem, file->stem + dirlen, stemlen);
+      file->stem = xmalloc (fullstemlen + 1);
+      memcpy (file->stem, filename, dirlen);
+      memcpy (file->stem + dirlen, stem, stemlen);
       file->stem[fullstemlen] = '\0';
     }
 
@@ -942,26 +940,26 @@ pattern_search (struct file *file, int archive,
      `also_make' member.  */
 
   if (rule->targets[1] != 0)
-    for (i = 0; rule->targets[i] != 0; ++i)
-      if (i != matches[foundrule])
+    for (ri = 0; rule->targets[ri] != 0; ++ri)
+      if (ri != matches[foundrule])
 	{
 	  struct file *f;
 	  struct dep *new = alloc_dep ();
 
 	  /* GKM FIMXE: handle '|' here too */
-	  new->name = p = (char *) xmalloc (rule->lens[i] + fullstemlen + 1);
-	  bcopy (rule->targets[i], p,
-		 rule->suffixes[i] - rule->targets[i] - 1);
-	  p += rule->suffixes[i] - rule->targets[i] - 1;
-	  bcopy (file->stem, p, fullstemlen);
+	  new->name = p = xmalloc (rule->lens[ri] + fullstemlen + 1);
+	  memcpy (p, rule->targets[ri],
+                  rule->suffixes[ri] - rule->targets[ri] - 1);
+	  p += rule->suffixes[ri] - rule->targets[ri] - 1;
+	  memcpy (p, file->stem, fullstemlen);
 	  p += fullstemlen;
-	  bcopy (rule->suffixes[i], p,
-		 rule->lens[i] - (rule->suffixes[i] - rule->targets[i]) + 1);
+	  memcpy (p, rule->suffixes[ri],
+                  rule->lens[ri] - (rule->suffixes[ri] - rule->targets[ri])+1);
 	  new->file = enter_file (new->name);
 	  new->next = file->also_make;
 
 	  /* Set precious flag. */
-	  f = lookup_file (rule->targets[i]);
+	  f = lookup_file (rule->targets[ri]);
 	  if (f && f->precious)
             new->file->precious = 1;
 
diff --git a/job.c b/job.c
index 0923c5a..50c6d8f 100644
--- a/job.c
+++ b/job.c
@@ -301,7 +301,7 @@ create_batch_file (char const *base, int unixy, int *fd)
       else
         {
           const unsigned final_size = path_size + size + 1;
-          char *const path = (char *) xmalloc (final_size);
+          char *const path = xmalloc (final_size);
           memcpy (path, temp_path, final_size);
           *fd = _open_osfhandle ((long)h, 0);
           if (unixy)
@@ -875,7 +875,7 @@ free_child (struct child *child)
       register unsigned int i;
       for (i = 0; i < child->file->cmds->ncommand_lines; ++i)
 	free (child->command_lines[i]);
-      free ((char *) child->command_lines);
+      free (child->command_lines);
     }
 
   if (child->environment != 0)
@@ -883,10 +883,10 @@ free_child (struct child *child)
       register char **ep = child->environment;
       while (*ep != 0)
 	free (*ep++);
-      free ((char *) child->environment);
+      free (child->environment);
     }
 
-  free ((char *) child);
+  free (child);
 }
 
 #ifdef POSIX
@@ -931,7 +931,7 @@ set_child_handler_action_flags (int set_handler, int set_alarm)
   signal (SIGCHLD, SIG_DFL);
 #endif
 
-  bzero ((char *) &sa, sizeof sa);
+  memset (&sa, '\0', sizeof sa);
   sa.sa_handler = child_handler;
   sa.sa_flags = set_handler ? 0 : SA_RESTART;
 #if defined SIGCHLD
@@ -1037,7 +1037,7 @@ start_job_command (struct child *child)
     {
 #ifndef VMS
       free (argv[0]);
-      free ((char *) argv);
+      free (argv);
 #endif
       child->file->update_status = 1;
       notice_finished_file (child->file);
@@ -1052,7 +1052,7 @@ start_job_command (struct child *child)
       if (argv)
         {
           free (argv[0]);
-          free ((char *) argv);
+          free (argv);
         }
 #endif
       argv = 0;
@@ -1113,7 +1113,7 @@ start_job_command (struct child *child)
       && argv[3] == NULL)
     {
       free (argv[0]);
-      free ((char *) argv);
+      free (argv);
       goto next_command;
     }
 #endif  /* !VMS && !_AMIGA */
@@ -1124,7 +1124,7 @@ start_job_command (struct child *child)
     {
 #ifndef VMS
       free (argv[0]);
-      free ((char *) argv);
+      free (argv);
 #endif
       goto next_command;
     }
@@ -1402,7 +1402,7 @@ start_job_command (struct child *child)
   /* Free the storage used by the child's argument list.  */
 #ifndef VMS
   free (argv[0]);
-  free ((char *) argv);
+  free (argv);
 #endif
 
   return;
@@ -1500,7 +1500,7 @@ new_job (struct file *file)
   chop_commands (cmds);
 
   /* Expand the command lines and store the results in LINES.  */
-  lines = (char **) xmalloc (cmds->ncommand_lines * sizeof (char *));
+  lines = xmalloc (cmds->ncommand_lines * sizeof (char *));
   for (i = 0; i < cmds->ncommand_lines; ++i)
     {
       /* Collapse backslash-newline combinations that are inside variable
@@ -1526,7 +1526,7 @@ new_job (struct file *file)
 	    /* Copy the text between the end of the last chunk
 	       we processed (where IN points) and the new chunk
 	       we are about to process (where REF points).  */
-	    bcopy (in, out, ref - in);
+	    memmove (out, in, ref - in);
 
 	  /* Move both pointers past the boring stuff.  */
 	  out += ref - in;
@@ -1604,8 +1604,8 @@ new_job (struct file *file)
   /* Start the command sequence, record it in a new
      `struct child', and add that to the chain.  */
 
-  c = (struct child *) xmalloc (sizeof (struct child));
-  bzero ((char *)c, sizeof (struct child));
+  c = xmalloc (sizeof (struct child));
+  memset (c, '\0', sizeof (struct child));
   c->file = file;
   c->command_lines = lines;
   c->sh_batch_file = NULL;
@@ -2115,7 +2115,7 @@ exec_command (char **argv, char **envp)
           ++argc;
 # endif
 
-	new_argv = (char **) alloca ((1 + argc + 1) * sizeof (char *));
+	new_argv = alloca ((1 + argc + 1) * sizeof (char *));
 	new_argv[0] = shell;
 
 # ifdef __EMX__
@@ -2308,9 +2308,9 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
                              "shift", "switch", "test", "times", "trap",
                              "umask", "wait", "while", 0 };
 #endif
-  register int i;
-  register char *p;
-  register char *ap;
+  int i;
+  char *p;
+  char *ap;
   char *end;
   int instring, word_has_equals, seen_nonequals, last_argument_was_empty;
   char **new_argv = 0;
@@ -2342,10 +2342,10 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 #ifdef WINDOWS32
   else if (strcmp (shell, default_shell))
   {
-    char *s1 = _fullpath(NULL, shell, 0);
-    char *s2 = _fullpath(NULL, default_shell, 0);
+    char *s1 = _fullpath (NULL, shell, 0);
+    char *s2 = _fullpath (NULL, default_shell, 0);
 
-    slow_flag = strcmp((s1 ? s1 : ""), (s2 ? s2 : ""));
+    slow_flag = strcmp ((s1 ? s1 : ""), (s2 ? s2 : ""));
 
     if (s1)
       free (s1);
@@ -2398,10 +2398,10 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
   i = strlen (line) + 1;
 
   /* More than 1 arg per character is impossible.  */
-  new_argv = (char **) xmalloc (i * sizeof (char *));
+  new_argv = xmalloc (i * sizeof (char *));
 
   /* All the args can fit in a buffer as big as LINE is.   */
-  ap = new_argv[0] = argstr = (char *) xmalloc (i);
+  ap = new_argv[0] = argstr = xmalloc (i);
   end = ap + i;
 
   /* I is how many complete arguments have been found.  */
@@ -2618,7 +2618,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     {
       /* Line was empty.  */
       free (argstr);
-      free ((char *)new_argv);
+      free (new_argv);
       return 0;
     }
 
@@ -2631,7 +2631,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     {
       /* Free the old argument list we were working on.  */
       free (argstr);
-      free ((char *)new_argv);
+      free (new_argv);
     }
 
 #ifdef __MSDOS__
@@ -2644,7 +2644,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     char *buffer;
     char *dptr;
 
-    buffer = (char *)xmalloc (strlen (line)+1);
+    buffer = xmalloc (strlen (line)+1);
 
     ptr = line;
     for (dptr=buffer; *ptr; )
@@ -2661,7 +2661,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     }
     *dptr = 0;
 
-    new_argv = (char **) xmalloc (2 * sizeof (char *));
+    new_argv = xmalloc (2 * sizeof (char *));
     new_argv[0] = buffer;
     new_argv[1] = 0;
   }
@@ -2697,8 +2697,8 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 #endif
     unsigned int line_len = strlen (line);
 
-    char *new_line = (char *) alloca (shell_len + (sizeof (minus_c) - 1)
-				      + (line_len * 2) + 1);
+    char *new_line = alloca (shell_len + (sizeof (minus_c)-1)
+                             + (line_len*2) + 1);
     char *command_ptr = NULL; /* used for batch_mode_shell mode */
 
 # ifdef __EMX__ /* is this necessary? */
@@ -2707,9 +2707,9 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 # endif
 
     ap = new_line;
-    bcopy (shell, ap, shell_len);
+    memcpy (ap, shell, shell_len);
     ap += shell_len;
-    bcopy (minus_c, ap, sizeof (minus_c) - 1);
+    memcpy (ap, minus_c, sizeof (minus_c) - 1);
     ap += sizeof (minus_c) - 1;
     command_ptr = ap;
     for (p = line; *p != '\0'; ++p)
@@ -2773,7 +2773,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     if (just_print_flag) {
       /* Need to allocate new_argv, although it's unused, because
         start_job_command will want to free it and its 0'th element.  */
-      new_argv = (char **) xmalloc(2 * sizeof (char *));
+      new_argv = xmalloc(2 * sizeof (char *));
       new_argv[0] = xstrdup ("");
       new_argv[1] = NULL;
     } else if ((no_default_sh_exe || batch_mode_shell) && batch_filename_ptr) {
@@ -2800,7 +2800,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
       fclose (batch);
 
       /* create argv */
-      new_argv = (char **) xmalloc(3 * sizeof (char *));
+      new_argv = xmalloc(3 * sizeof (char *));
       if (unixy_shell) {
         new_argv[0] = xstrdup (shell);
         new_argv[1] = *batch_filename_ptr; /* only argv[0] gets freed later */
@@ -2812,9 +2812,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     } else
 #endif /* WINDOWS32 */
     if (unixy_shell)
-      new_argv = construct_command_argv_internal (new_line, (char **) NULL,
-                                                  (char *) 0, (char *) 0,
-                                                  (char **) 0);
+      new_argv = construct_command_argv_internal (new_line, 0, 0, 0, 0);
 #ifdef __EMX__
     else if (!unixy_shell)
       {
@@ -2872,10 +2870,10 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
           size_t sh_len = strlen (shell);
 
           /* exactly 3 arguments + NULL */
-          new_argv = (char **) xmalloc (4 * sizeof (char *));
+          new_argv = xmalloc (4 * sizeof (char *));
           /* Exactly strlen(shell) + strlen("/c") + strlen(line) + 3 times
              the trailing '\0' */
-          new_argv[0] = (char *) malloc (sh_len + line_len + 5);
+          new_argv[0] = xmalloc (sh_len + line_len + 5);
           memcpy (new_argv[0], shell, sh_len + 1);
           new_argv[1] = new_argv[0] + sh_len + 1;
           memcpy (new_argv[1], "/c", 3);
@@ -2890,7 +2888,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
         /* With MSDOS shells, we must construct the command line here
            instead of recursively calling ourselves, because we
            cannot backslash-escape the special characters (see above).  */
-        new_argv = (char **) xmalloc (sizeof (char *));
+        new_argv = xmalloc (sizeof (char *));
         line_len = strlen (new_line) - shell_len - sizeof (minus_c) + 1;
         new_argv[0] = xmalloc (line_len + 1);
         strncpy (new_argv[0],
@@ -2948,7 +2946,7 @@ construct_command_argv (char *line, char **restp, struct file *file,
       argc++;
     }
 
-  argv = (char **)malloc (argc * sizeof (char *));
+  argv = xmalloc (argc * sizeof (char *));
   if (argv == 0)
     abort ();
 
diff --git a/main.c b/main.c
index 32f50fa..126c914 100644
--- a/main.c
+++ b/main.c
@@ -895,10 +895,7 @@ main (int argc, char **argv, char **envp)
 #endif
 {
   static char *stdin_nm = 0;
-  struct file *f;
-  int i;
   int makefile_status = MAKE_SUCCESS;
-  char **p;
   struct dep *read_makefiles;
   PATH_VAR (current_directory);
   unsigned int restarts = 0;
@@ -1021,7 +1018,7 @@ main (int argc, char **argv, char **envp)
   setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
 # else	/* setvbuf not reversed.  */
   /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
-  setvbuf (stdout, (char *) 0, _IOLBF, BUFSIZ);
+  setvbuf (stdout, 0, _IOLBF, BUFSIZ);
 # endif	/* setvbuf reversed.  */
 #elif HAVE_SETLINEBUF
   setlinebuf (stdout);
@@ -1129,57 +1126,63 @@ main (int argc, char **argv, char **envp)
      from the environment.  */
 
 #ifndef _AMIGA
-  for (i = 0; envp[i] != 0; ++i)
-    {
-      int do_not_define = 0;
-      char *ep = envp[i];
+  {
+    unsigned int i;
+
+    for (i = 0; envp[i] != 0; ++i)
+      {
+        int do_not_define = 0;
+        char *ep = envp[i];
 
-      while (*ep != '\0' && *ep != '=')
-        ++ep;
+        while (*ep != '\0' && *ep != '=')
+          ++ep;
 #ifdef WINDOWS32
-      if (!unix_path && strneq(envp[i], "PATH=", 5))
-        unix_path = ep+1;
-      else if (!strnicmp(envp[i], "Path=", 5)) {
-        do_not_define = 1; /* it gets defined after loop exits */
-        if (!windows32_path)
-          windows32_path = ep+1;
-      }
+        if (!unix_path && strneq(envp[i], "PATH=", 5))
+          unix_path = ep+1;
+        else if (!strnicmp(envp[i], "Path=", 5)) {
+          do_not_define = 1; /* it gets defined after loop exits */
+          if (!windows32_path)
+            windows32_path = ep+1;
+        }
 #endif
-      /* The result of pointer arithmetic is cast to unsigned int for
-	 machines where ptrdiff_t is a different size that doesn't widen
-	 the same.  */
-      if (!do_not_define)
-        {
-          struct variable *v;
-
-          v = define_variable (envp[i], (unsigned int) (ep - envp[i]),
-                               ep + 1, o_env, 1);
-          /* Force exportation of every variable culled from the environment.
-             We used to rely on target_environment's v_default code to do this.
-             But that does not work for the case where an environment variable
-             is redefined in a makefile with `override'; it should then still
-             be exported, because it was originally in the environment.  */
-          v->export = v_export;
-
-          /* Another wrinkle is that POSIX says the value of SHELL set in the
-             makefile won't change the value of SHELL given to subprocesses  */
-          if (streq (v->name, "SHELL"))
-            {
+        /* The result of pointer arithmetic is cast to unsigned int for
+           machines where ptrdiff_t is a different size that doesn't widen
+           the same.  */
+        if (!do_not_define)
+          {
+            struct variable *v;
+
+            v = define_variable (envp[i], (unsigned int) (ep - envp[i]),
+                                 ep + 1, o_env, 1);
+            /* Force exportation of every variable culled from the
+               environment.  We used to rely on target_environment's
+               v_default code to do this.  But that does not work for the
+               case where an environment variable is redefined in a makefile
+               with `override'; it should then still be exported, because it
+               was originally in the environment.  */
+            v->export = v_export;
+
+            /* Another wrinkle is that POSIX says the value of SHELL set in
+               the makefile won't change the value of SHELL given to
+               subprocesses.  */
+            if (streq (v->name, "SHELL"))
+              {
 #ifndef __MSDOS__
-              v->export = v_noexport;
+                v->export = v_noexport;
 #endif
-              shell_var.name = "SHELL";
-              shell_var.value = xstrdup (ep + 1);
-            }
+                shell_var.name = "SHELL";
+                shell_var.value = xstrdup (ep + 1);
+              }
 
-          /* If MAKE_RESTARTS is set, remember it but don't export it.  */
-          if (streq (v->name, "MAKE_RESTARTS"))
-            {
-              v->export = v_noexport;
-              restarts = (unsigned int) atoi (ep + 1);
-            }
-        }
-    }
+            /* If MAKE_RESTARTS is set, remember it but don't export it.  */
+            if (streq (v->name, "MAKE_RESTARTS"))
+              {
+                v->export = v_noexport;
+                restarts = (unsigned int) atoi (ep + 1);
+              }
+          }
+      }
+  }
 #ifdef WINDOWS32
     /* If we didn't find a correctly spelled PATH we define PATH as
      * either the first mispelled value or an empty string
@@ -1328,7 +1331,7 @@ main (int argc, char **argv, char **envp)
 	}
 
       /* Now allocate a buffer big enough and fill it.  */
-      p = value = (char *) alloca (len);
+      p = value = alloca (len);
       for (cv = command_variables; cv != 0; cv = cv->next)
 	{
 	  v = cv->variable;
@@ -1358,31 +1361,34 @@ main (int argc, char **argv, char **envp)
 
   /* If there were -C flags, move ourselves about.  */
   if (directories != 0)
-    for (i = 0; directories->list[i] != 0; ++i)
-      {
-	char *dir = directories->list[i];
-        char *expanded = 0;
-	if (dir[0] == '~')
-	  {
-            expanded = tilde_expand (dir);
-	    if (expanded != 0)
-	      dir = expanded;
-	  }
-#ifdef WINDOWS32
-        /* WINDOWS32 chdir() doesn't work if the directory has a trailing '/'
-           But allow -C/ just in case someone wants that.  */
+    {
+      unsigned int i;
+      for (i = 0; directories->list[i] != 0; ++i)
         {
-          char *p = dir + strlen (dir) - 1;
-          while (p > dir && (p[0] == '/' || p[0] == '\\'))
-            --p;
-          p[1] = '\0';
-        }
+          char *dir = directories->list[i];
+          char *expanded = 0;
+          if (dir[0] == '~')
+            {
+              expanded = tilde_expand (dir);
+              if (expanded != 0)
+                dir = expanded;
+            }
+#ifdef WINDOWS32
+          /* WINDOWS32 chdir() doesn't work if the directory has a trailing '/'
+             But allow -C/ just in case someone wants that.  */
+          {
+            char *p = dir + strlen (dir) - 1;
+            while (p > dir && (p[0] == '/' || p[0] == '\\'))
+              --p;
+            p[1] = '\0';
+          }
 #endif
-	if (chdir (dir) < 0)
-	  pfatal_with_name (dir);
-	if (expanded)
-	  free (expanded);
-      }
+          if (chdir (dir) < 0)
+            pfatal_with_name (dir);
+          if (expanded)
+            free (expanded);
+        }
+    }
 
 #ifdef WINDOWS32
   /*
@@ -1420,8 +1426,8 @@ main (int argc, char **argv, char **envp)
 
   /* Construct the list of include directories to search.  */
 
-  construct_include_path (include_directories == 0 ? (char **) 0
-			  : include_directories->list);
+  construct_include_path (include_directories == 0
+                          ? 0 : include_directories->list);
 
   /* Figure out where we are now, after chdir'ing.  */
   if (directories == 0)
@@ -1452,7 +1458,7 @@ main (int argc, char **argv, char **envp)
 
   if (makefiles != 0)
     {
-      register unsigned int i;
+      unsigned int i;
       for (i = 0; i < makefiles->idx; ++i)
 	if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
 	  {
@@ -1485,8 +1491,7 @@ main (int argc, char **argv, char **envp)
                )
 	      tmpdir = DEFAULT_TMPDIR;
 
-            template = (char *) alloca (strlen (tmpdir)
-                                        + sizeof (DEFAULT_TMPFILE) + 1);
+            template = alloca (strlen (tmpdir) + sizeof (DEFAULT_TMPFILE) + 1);
 	    strcpy (template, tmpdir);
 
 #ifdef HAVE_DOS_PATHS
@@ -1510,21 +1515,23 @@ main (int argc, char **argv, char **envp)
 		if (n > 0 && fwrite (buf, 1, n, outfile) != n)
 		  pfatal_with_name (_("fwrite (temporary file)"));
 	      }
-	    (void) fclose (outfile);
+	    fclose (outfile);
 
 	    /* Replace the name that read_all_makefiles will
 	       see with the name of the temporary file.  */
             makefiles->list[i] = xstrdup (stdin_nm);
 
 	    /* Make sure the temporary file will not be remade.  */
-	    f = enter_file (stdin_nm);
-	    f->updated = 1;
-	    f->update_status = 0;
-	    f->command_state = cs_finished;
- 	    /* Can't be intermediate, or it'll be removed too early for
-               make re-exec.  */
- 	    f->intermediate = 0;
-	    f->dontcare = 0;
+            {
+              struct file *f = enter_file (stdin_nm);
+              f->updated = 1;
+              f->update_status = 0;
+              f->command_state = cs_finished;
+              /* Can't be intermediate, or it'll be removed too early for
+                 make re-exec.  */
+              f->intermediate = 0;
+              f->dontcare = 0;
+            }
 	  }
     }
 
@@ -1593,7 +1600,7 @@ main (int argc, char **argv, char **envp)
   /* Read all the makefiles.  */
 
   read_makefiles
-    = read_all_makefiles (makefiles == 0 ? (char **) 0 : makefiles->list);
+    = read_all_makefiles (makefiles == 0 ? 0 : makefiles->list);
 
 #ifdef WINDOWS32
   /* look one last time after reading all Makefiles */
@@ -1729,7 +1736,7 @@ main (int argc, char **argv, char **envp)
 
       jobserver_fds = (struct stringlist *)
                         xmalloc (sizeof (struct stringlist));
-      jobserver_fds->list = (char **) xmalloc (sizeof (char *));
+      jobserver_fds->list = xmalloc (sizeof (char *));
       jobserver_fds->list[0] = xmalloc ((sizeof ("1024")*2)+1);
 
       sprintf (jobserver_fds->list[0], "%d,%d", job_fds[0], job_fds[1]);
@@ -1782,20 +1789,24 @@ main (int argc, char **argv, char **envp)
      as possible into the future).  If restarts is set we'll do -W later.  */
 
   if (old_files != 0)
-    for (p = old_files->list; *p != 0; ++p)
-      {
-	f = enter_command_line_file (*p);
-	f->last_mtime = f->mtime_before_update = OLD_MTIME;
-	f->updated = 1;
-	f->update_status = 0;
-	f->command_state = cs_finished;
-      }
+    {
+      char **p;
+      for (p = old_files->list; *p != 0; ++p)
+        {
+          struct file *f = enter_command_line_file (*p);
+          f->last_mtime = f->mtime_before_update = OLD_MTIME;
+          f->updated = 1;
+          f->update_status = 0;
+          f->command_state = cs_finished;
+        }
+    }
 
   if (!restarts && new_files != 0)
     {
+      char **p;
       for (p = new_files->list; *p != 0; ++p)
 	{
-	  f = enter_command_line_file (*p);
+	  struct file *f = enter_command_line_file (*p);
 	  f->last_mtime = f->mtime_before_update = NEW_MTIME;
 	}
     }
@@ -1827,7 +1838,7 @@ main (int argc, char **argv, char **envp)
 	d = read_makefiles;
 	while (d != 0)
 	  {
-	    register struct file *f = d->file;
+	    struct file *f = d->file;
 	    if (f->double_colon)
 	      for (f = f->double_colon; f != NULL; f = f->prev)
 		{
@@ -1860,9 +1871,9 @@ main (int argc, char **argv, char **envp)
 		}
 	    if (f == NULL || !f->double_colon)
 	      {
-                makefile_mtimes = (FILE_TIMESTAMP *)
-                  xrealloc ((char *) makefile_mtimes,
-                            (mm_idx + 1) * sizeof (FILE_TIMESTAMP));
+                makefile_mtimes = xrealloc (makefile_mtimes,
+                                            (mm_idx+1)
+                                            * sizeof (FILE_TIMESTAMP));
 		makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
 		last = d;
 		d = d->next;
@@ -1991,8 +2002,8 @@ main (int argc, char **argv, char **envp)
           /* Add -o option for the stdin temporary file, if necessary.  */
           if (stdin_nm)
             {
-              nargv = (char **) xmalloc ((nargc + 2) * sizeof (char *));
-              bcopy ((char *) argv, (char *) nargv, argc * sizeof (char *));
+              nargv = xmalloc ((nargc + 2) * sizeof (char *));
+              memcpy (nargv, argv, argc * sizeof (char *));
               nargv[nargc++] = concat ("-o", stdin_nm, "");
               nargv[nargc] = 0;
             }
@@ -2028,28 +2039,24 @@ main (int argc, char **argv, char **envp)
 	    }
 
 #ifndef _AMIGA
-	  for (p = environ; *p != 0; ++p)
-            {
-              if (strneq (*p, MAKELEVEL_NAME, MAKELEVEL_LENGTH)
-                  && (*p)[MAKELEVEL_LENGTH] == '=')
-                {
-                  /* The SGI compiler apparently can't understand
-                     the concept of storing the result of a function
-                     in something other than a local variable.  */
-                  char *sgi_loses;
-                  sgi_loses = (char *) alloca (40);
-                  *p = sgi_loses;
-                  sprintf (*p, "%s=%u", MAKELEVEL_NAME, makelevel);
-                }
-              if (strneq (*p, "MAKE_RESTARTS=", 14))
-                {
-                  char *sgi_loses;
-                  sgi_loses = (char *) alloca (40);
-                  *p = sgi_loses;
-                  sprintf (*p, "MAKE_RESTARTS=%u", restarts);
-                  restarts = 0;
-                }
-            }
+          {
+            char **p;
+            for (p = environ; *p != 0; ++p)
+              {
+                if (strneq (*p, MAKELEVEL_NAME, MAKELEVEL_LENGTH)
+                    && (*p)[MAKELEVEL_LENGTH] == '=')
+                  {
+                    *p = alloca (40);
+                    sprintf (*p, "%s=%u", MAKELEVEL_NAME, makelevel);
+                  }
+                if (strneq (*p, "MAKE_RESTARTS=", 14))
+                  {
+                    *p = alloca (40);
+                    sprintf (*p, "MAKE_RESTARTS=%u", restarts);
+                    restarts = 0;
+                  }
+              }
+          }
 #else /* AMIGA */
 	  {
 	    char buffer[256];
@@ -2115,7 +2122,7 @@ main (int argc, char **argv, char **envp)
 
       /* Free the makefile mtimes (if we allocated any).  */
       if (makefile_mtimes)
-        free ((char *) makefile_mtimes);
+        free (makefile_mtimes);
     }
 
   /* Set up `MAKEFLAGS' again for the normal targets.  */
@@ -2127,9 +2134,10 @@ main (int argc, char **argv, char **envp)
   /* If restarts is set we haven't set up -W files yet, so do that now.  */
   if (restarts && new_files != 0)
     {
+      char **p;
       for (p = new_files->list; *p != 0; ++p)
 	{
-	  f = enter_command_line_file (*p);
+	  struct file *f = enter_command_line_file (*p);
 	  f->last_mtime = f->mtime_before_update = NEW_MTIME;
 	}
     }
@@ -2315,7 +2323,7 @@ handle_non_switch_argument (char *arg, int env)
           break;
 
       if (! cv) {
-        cv = (struct command_variable *) xmalloc (sizeof (*cv));
+        cv = xmalloc (sizeof (*cv));
         cv->variable = v;
         cv->next = command_variables;
         command_variables = cv;
@@ -2344,23 +2352,23 @@ handle_non_switch_argument (char *arg, int env)
 
       {
         /* Add this target name to the MAKECMDGOALS variable. */
-        struct variable *v;
+        struct variable *gv;
         char *value;
 
-        v = lookup_variable (STRING_SIZE_TUPLE ("MAKECMDGOALS"));
-        if (v == 0)
+        gv = lookup_variable (STRING_SIZE_TUPLE ("MAKECMDGOALS"));
+        if (gv == 0)
           value = f->name;
         else
           {
             /* Paste the old and new values together */
             unsigned int oldlen, newlen;
 
-            oldlen = strlen (v->value);
+            oldlen = strlen (gv->value);
             newlen = strlen (f->name);
-            value = (char *) alloca (oldlen + 1 + newlen + 1);
-            bcopy (v->value, value, oldlen);
+            value = alloca (oldlen + 1 + newlen + 1);
+            memcpy (value, gv->value, oldlen);
             value[oldlen] = ' ';
-            bcopy (f->name, &value[oldlen + 1], newlen + 1);
+            memcpy (&value[oldlen + 1], f->name, newlen + 1);
           }
         define_variable ("MAKECMDGOALS", 12, value, o_default, 0);
       }
@@ -2475,15 +2483,14 @@ decode_switches (int argc, char **argv, int env)
 			xmalloc (sizeof (struct stringlist));
 		      sl->max = 5;
 		      sl->idx = 0;
-		      sl->list = (char **) xmalloc (5 * sizeof (char *));
+		      sl->list = xmalloc (5 * sizeof (char *));
 		      *(struct stringlist **) cs->value_ptr = sl;
 		    }
 		  else if (sl->idx == sl->max - 1)
 		    {
 		      sl->max += 5;
-		      sl->list = (char **)
-			xrealloc ((char *) sl->list,
-				  sl->max * sizeof (char *));
+		      sl->list = xrealloc (sl->list,
+                                           sl->max * sizeof (char *));
 		    }
 		  sl->list[sl->idx++] = optarg;
 		  sl->list[sl->idx] = 0;
@@ -2570,7 +2577,7 @@ decode_switches (int argc, char **argv, int env)
 static void
 decode_env_switches (char *envar, unsigned int len)
 {
-  char *varref = (char *) alloca (2 + len + 2);
+  char *varref = alloca (2 + len + 2);
   char *value, *p;
   int argc;
   char **argv;
@@ -2578,7 +2585,7 @@ decode_env_switches (char *envar, unsigned int len)
   /* Get the variable's value.  */
   varref[0] = '$';
   varref[1] = '(';
-  bcopy (envar, &varref[2], len);
+  memcpy (&varref[2], envar, len);
   varref[2 + len] = ')';
   varref[2 + len + 1] = '\0';
   value = variable_expand (varref);
@@ -2590,12 +2597,12 @@ decode_env_switches (char *envar, unsigned int len)
     return;
 
   /* Allocate a vector that is definitely big enough.  */
-  argv = (char **) alloca ((1 + len + 1) * sizeof (char *));
+  argv = alloca ((1 + len + 1) * sizeof (char *));
 
   /* Allocate a buffer to copy the value into while we split it into words
      and unquote it.  We must use permanent storage for this because
      decode_switches may store pointers into the passed argument words.  */
-  p = (char *) xmalloc (2 * len);
+  p = xmalloc (2 * len);
 
   /* getopt will look at the arguments starting at ARGV[1].
      Prepend a spacer word.  */
@@ -2683,7 +2690,7 @@ define_makeflags (int all, int makefile)
   unsigned int flagslen = 0;
 #define	ADD_FLAG(ARG, LEN) \
   do {									      \
-    struct flag *new = (struct flag *) alloca (sizeof (struct flag));	      \
+    struct flag *new = alloca (sizeof (struct flag));                         \
     new->cs = cs;							      \
     new->arg = (ARG);							      \
     new->next = flags;							      \
@@ -2731,7 +2738,7 @@ define_makeflags (int all, int makefile)
 		ADD_FLAG ("1", 1);
 	      else
 		{
-		  char *buf = (char *) alloca (30);
+		  char *buf = alloca (30);
 		  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
 		  ADD_FLAG (buf, strlen (buf));
 		}
@@ -2752,7 +2759,7 @@ define_makeflags (int all, int makefile)
 		ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
 	      else
 		{
-		  char *buf = (char *) alloca (100);
+		  char *buf = alloca (100);
 		  sprintf (buf, "%g", *(double *) cs->value_ptr);
 		  ADD_FLAG (buf, strlen (buf));
 		}
@@ -2783,8 +2790,8 @@ define_makeflags (int all, int makefile)
 
   /* Construct the value in FLAGSTRING.
      We allocate enough space for a preceding dash and trailing null.  */
-  flagstring = (char *) alloca (1 + flagslen + 1);
-  bzero (flagstring, 1 + flagslen + 1);
+  flagstring = alloca (1 + flagslen + 1);
+  memset (flagstring, '\0', 1 + flagslen + 1);
   p = flagstring;
   words = 1;
   *p++ = '-';
@@ -2876,12 +2883,12 @@ define_makeflags (int all, int makefile)
       /* Copy in the string.  */
       if (posix_pedantic)
 	{
-	  bcopy (posixref, p, sizeof posixref - 1);
+	  memcpy (p, posixref, sizeof posixref - 1);
 	  p += sizeof posixref - 1;
 	}
       else
 	{
-	  bcopy (ref, p, sizeof ref - 1);
+	  memcpy (p, ref, sizeof ref - 1);
 	  p += sizeof ref - 1;
 	}
     }
diff --git a/maintMakefile b/maintMakefile
index 2bafbc2..457a39e 100644
--- a/maintMakefile
+++ b/maintMakefile
@@ -3,7 +3,10 @@
 # tree, not a dist copy.
 
 # We like mondo-warnings!
-AM_CFLAGS += -Wall -W
+AM_CFLAGS += -Wall -Wextra -Wdeclaration-after-statement -Wshadow -Wpointer-arith -Wbad-function-cast
+
+# I want this one but I have to wait for the const cleanup!
+# -Wwrite-strings
 
 # Find the glob source files... this might be dangerous, but we're maintainers!
 globsrc := $(wildcard glob/*.c)
diff --git a/make.h b/make.h
index 5914dd8..949f35a 100644
--- a/make.h
+++ b/make.h
@@ -141,7 +141,7 @@ extern int errno;
 #else
 # define NEED_GET_PATH_MAX 1
 # define GET_PATH_MAX   (get_path_max ())
-# define PATH_VAR(var)  char *var = (char *) alloca (GET_PATH_MAX)
+# define PATH_VAR(var)  char *var = alloca (GET_PATH_MAX)
 unsigned int get_path_max (void);
 #endif
 
@@ -218,9 +218,9 @@ unsigned int get_path_max (void);
 # ifdef HAVE_STDLIB_H
 #  include <stdlib.h>
 # else
-char *malloc (int);
-char *realloc (char *, int);
-void free (char *);
+void *malloc (int);
+void *realloc (void *, int);
+void free (void *);
 
 void abort (void) __attribute__ ((noreturn));
 void exit (int) __attribute__ ((noreturn));
@@ -233,37 +233,10 @@ void exit (int) __attribute__ ((noreturn));
 # define EXIT_SUCCESS 0
 #endif
 #ifndef EXIT_FAILURE
-# define EXIT_FAILURE 0
+# define EXIT_FAILURE 1
 #endif
 
-#ifdef  ANSI_STRING
-
-# ifndef bcmp
-#  define bcmp(s1, s2, n)   memcmp ((s1), (s2), (n))
-# endif
-# ifndef bzero
-#  define bzero(s, n)       memset ((s), 0, (n))
-# endif
-# if defined(HAVE_MEMMOVE) && !defined(bcopy)
-#  define bcopy(s, d, n)    memmove ((d), (s), (n))
-# endif
-
-#else   /* Not ANSI_STRING.  */
-
-# ifndef HAVE_STRCHR
-#  define strchr(s, c)      index((s), (c))
-#  define strrchr(s, c)     rindex((s), (c))
-# endif
-
-# ifndef bcmp
-int bcmp (const char *, const char *, int);
-# endif
-# ifndef bzero
-void bzero (char *, int);
-#endif
-# ifndef bcopy
-void bcopy (const char *b1, char *b2, int);
-# endif
+#ifndef  ANSI_STRING
 
 /* SCO Xenix has a buggy macro definition in <string.h>.  */
 #undef  strerror
@@ -407,8 +380,8 @@ void pfatal_with_name (const char *) __attribute__ ((noreturn));
 void perror_with_name (const char *, const char *);
 char *savestring (const char *, unsigned int);
 char *concat (const char *, const char *, const char *);
-char *xmalloc (unsigned int);
-char *xrealloc (char *, unsigned int);
+void *xmalloc (unsigned int);
+void *xrealloc (void *, unsigned int);
 char *xstrdup (const char *);
 char *find_next_token (char **, unsigned int *);
 char *next_token (const char *);
diff --git a/misc.c b/misc.c
index 07f3c01..47703d9 100644
--- a/misc.c
+++ b/misc.c
@@ -171,14 +171,14 @@ concat (const char *s1, const char *s2, const char *s3)
   len2 = *s2 != '\0' ? strlen (s2) : 0;
   len3 = *s3 != '\0' ? strlen (s3) : 0;
 
-  result = (char *) xmalloc (len1 + len2 + len3 + 1);
+  result = xmalloc (len1 + len2 + len3 + 1);
 
   if (*s1 != '\0')
-    bcopy (s1, result, len1);
+    memcpy (result, s1, len1);
   if (*s2 != '\0')
-    bcopy (s2, result + len1, len2);
+    memcpy (result + len1, s2, len2);
   if (*s3 != '\0')
-    bcopy (s3, result + len1 + len2, len3);
+    memcpy (result + len1 + len2, s3, len3);
   *(result + len1 + len2 + len3) = '\0';
 
   return result;
@@ -335,21 +335,21 @@ pfatal_with_name (const char *name)
 #undef xrealloc
 #undef xstrdup
 
-char *
+void *
 xmalloc (unsigned int size)
 {
   /* Make sure we don't allocate 0, for pre-ANSI libraries.  */
-  char *result = (char *) malloc (size ? size : 1);
+  void *result = malloc (size ? size : 1);
   if (result == 0)
     fatal (NILF, _("virtual memory exhausted"));
   return result;
 }
 
 
-char *
-xrealloc (char *ptr, unsigned int size)
+void *
+xrealloc (void *ptr, unsigned int size)
 {
-  char *result;
+  void *result;
 
   /* Some older implementations of realloc() don't conform to ANSI.  */
   if (! size)
@@ -369,7 +369,7 @@ xstrdup (const char *ptr)
 #ifdef HAVE_STRDUP
   result = strdup (ptr);
 #else
-  result = (char *) malloc (strlen (ptr) + 1);
+  result = malloc (strlen (ptr) + 1);
 #endif
 
   if (result == 0)
@@ -378,7 +378,7 @@ xstrdup (const char *ptr)
 #ifdef HAVE_STRDUP
   return result;
 #else
-  return strcpy(result, ptr);
+  return strcpy (result, ptr);
 #endif
 }
 
@@ -387,9 +387,9 @@ xstrdup (const char *ptr)
 char *
 savestring (const char *str, unsigned int length)
 {
-  register char *out = (char *) xmalloc (length + 1);
+  char *out = xmalloc (length + 1);
   if (length > 0)
-    bcopy (str, out, length);
+    memcpy (out, str, length);
   out[length] = '\0';
   return out;
 }
@@ -485,8 +485,8 @@ find_next_token (char **ptr, unsigned int *lengthptr)
 struct dep *
 alloc_dep ()
 {
-  struct dep *d = (struct dep *) xmalloc (sizeof (struct dep));
-  bzero ((char *) d, sizeof (struct dep));
+  struct dep *d = xmalloc (sizeof (struct dep));
+  memset (d, '\0', sizeof (struct dep));
   return d;
 }
 
@@ -502,7 +502,7 @@ free_dep (struct dep *d)
   if (d->stem != 0)
     free (d->stem);
 
-  free ((char *)d);
+  free (d);
 }
 
 /* Copy a chain of `struct dep', making a new chain
@@ -517,8 +517,8 @@ copy_dep_chain (const struct dep *d)
 
   while (d != 0)
     {
-      c = (struct dep *) xmalloc (sizeof (struct dep));
-      bcopy ((char *) d, (char *) c, sizeof (struct dep));
+      c = xmalloc (sizeof (struct dep));
+      memcpy (c, d, sizeof (struct dep));
 
       if (c->name != 0)
 	c->name = xstrdup (c->name);
diff --git a/read.c b/read.c
index e380d02..b7b5bc7 100644
--- a/read.c
+++ b/read.c
@@ -274,7 +274,7 @@ install_conditionals (struct conditionals *new)
 {
   struct conditionals *save = conditionals;
 
-  bzero ((char *) new, sizeof (*new));
+  memset (new, '\0', sizeof (*new));
   conditionals = new;
 
   return save;
@@ -506,7 +506,7 @@ eval (struct ebuffer *ebuf, int set_default)
     {
       unsigned int linelen;
       char *line;
-      int len;
+      unsigned int wlen;
       char *p;
       char *p2;
 
@@ -552,7 +552,7 @@ eval (struct ebuffer *ebuf, int set_default)
 		  commands_len = (linelen + 1 + commands_idx) * 2;
 		  commands = xrealloc (commands, commands_len);
 		}
-	      bcopy (line, &commands[commands_idx], linelen);
+	      memcpy (&commands[commands_idx], line, linelen);
 	      commands_idx += linelen;
 	      commands[commands_idx++] = '\n';
 
@@ -568,8 +568,8 @@ eval (struct ebuffer *ebuf, int set_default)
 	{
 	  collapsed_length = linelen+1;
           if (collapsed)
-            free ((char *)collapsed);
-	  collapsed = (char *) xmalloc (collapsed_length);
+            free (collapsed);
+	  collapsed = xmalloc (collapsed_length);
 	}
       strcpy (collapsed, line);
       /* Collapse continuation lines.  */
@@ -577,7 +577,7 @@ eval (struct ebuffer *ebuf, int set_default)
       remove_comments (collapsed);
 
       /* Compare a word, both length and contents. */
-#define	word1eq(s) 	(len == sizeof(s)-1 && strneq (s, p, sizeof(s)-1))
+#define	word1eq(s) 	(wlen == sizeof(s)-1 && strneq (s, p, sizeof(s)-1))
       p = collapsed;
       while (isspace ((unsigned char)*p))
 	++p;
@@ -592,7 +592,7 @@ eval (struct ebuffer *ebuf, int set_default)
        */
       for (p2 = p+1; *p2 != '\0' && !isspace ((unsigned char)*p2); ++p2)
         ;
-      len = p2 - p;
+      wlen = p2 - p;
 
       /* Find the start of the second token.  If it looks like a target or
          variable definition it can't be a preprocessor token so skip
@@ -615,7 +615,7 @@ eval (struct ebuffer *ebuf, int set_default)
 
       if (!in_ignored_define)
 	{
- 	  int i = conditional_line (p, len, fstart);
+ 	  int i = conditional_line (p, wlen, fstart);
           if (i != -2)
             {
               if (i == -1)
@@ -707,20 +707,19 @@ eval (struct ebuffer *ebuf, int set_default)
                 v->export = v_export;
               else
                 {
-                  unsigned int len;
+                  unsigned int l;
                   char *ap;
 
                   /* Expand the line so we can use indirect and constructed
                      variable names in an export command.  */
                   p2 = ap = allocated_variable_expand (p2);
 
-                  for (p = find_next_token (&p2, &len); p != 0;
-                       p = find_next_token (&p2, &len))
+                  for (p = find_next_token (&p2, &l); p != 0;
+                       p = find_next_token (&p2, &l))
                     {
-                      v = lookup_variable (p, len);
+                      v = lookup_variable (p, l);
                       if (v == 0)
-                        v = define_variable_loc (p, len, "", o_file, 0,
-                                                 fstart);
+                        v = define_variable_loc (p, l, "", o_file, 0, fstart);
                       v->export = v_export;
                     }
 
@@ -736,7 +735,7 @@ eval (struct ebuffer *ebuf, int set_default)
 	    export_all_variables = 0;
           else
             {
-              unsigned int len;
+              unsigned int l;
               struct variable *v;
               char *ap;
 
@@ -744,12 +743,12 @@ eval (struct ebuffer *ebuf, int set_default)
                  variable names in an unexport command.  */
               p2 = ap = allocated_variable_expand (p2);
 
-              for (p = find_next_token (&p2, &len); p != 0;
-                   p = find_next_token (&p2, &len))
+              for (p = find_next_token (&p2, &l); p != 0;
+                   p = find_next_token (&p2, &l))
                 {
-                  v = lookup_variable (p, len);
+                  v = lookup_variable (p, l);
                   if (v == 0)
-                    v = define_variable_loc (p, len, "", o_file, 0, fstart);
+                    v = define_variable_loc (p, l, "", o_file, 0, fstart);
 
                   v->export = v_noexport;
                 }
@@ -762,23 +761,23 @@ eval (struct ebuffer *ebuf, int set_default)
  skip_conditionals:
       if (word1eq ("vpath"))
 	{
-	  char *pattern;
-	  unsigned int len;
+	  char *vpat;
+	  unsigned int l;
 	  p2 = variable_expand (p2);
-	  p = find_next_token (&p2, &len);
+	  p = find_next_token (&p2, &l);
 	  if (p != 0)
 	    {
-	      pattern = savestring (p, len);
-	      p = find_next_token (&p2, &len);
+	      vpat = savestring (p, l);
+	      p = find_next_token (&p2, &l);
 	      /* No searchpath means remove all previous
 		 selective VPATH's with the same pattern.  */
 	    }
 	  else
 	    /* No pattern means remove all previous selective VPATH's.  */
-	    pattern = 0;
-	  construct_vpath_list (pattern, p);
-	  if (pattern != 0)
-	    free (pattern);
+	    vpat = 0;
+	  construct_vpath_list (vpat, p);
+	  if (vpat != 0)
+	    free (vpat);
 
           goto rule_complete;
 	}
@@ -826,7 +825,7 @@ eval (struct ebuffer *ebuf, int set_default)
 	      char *name = files->name;
               int r;
 
-	      free ((char *)files);
+	      free (files);
 	      files = next;
 
               r = eval_makefile (name, (RM_INCLUDED | RM_NO_TILDE
@@ -867,7 +866,7 @@ eval (struct ebuffer *ebuf, int set_default)
         enum variable_origin v_origin;
         int exported;
         char *cmdleft, *semip, *lb_next;
-        unsigned int len, plen = 0;
+        unsigned int plen = 0;
         char *colonp;
         const char *end, *beg; /* Helpers for whitespace stripping. */
 
@@ -896,7 +895,7 @@ eval (struct ebuffer *ebuf, int set_default)
            variable we don't want to expand it.  So, walk from the
            beginning, expanding as we go, and looking for "interesting"
            chars.  The first word is always expandable.  */
-        wtype = get_next_mword(line, NULL, &lb_next, &len);
+        wtype = get_next_mword(line, NULL, &lb_next, &wlen);
         switch (wtype)
           {
           case w_eol:
@@ -917,11 +916,11 @@ eval (struct ebuffer *ebuf, int set_default)
             break;
           }
 
-        p2 = variable_expand_string(NULL, lb_next, len);
+        p2 = variable_expand_string(NULL, lb_next, wlen);
 
         while (1)
           {
-            lb_next += len;
+            lb_next += wlen;
             if (cmdleft == 0)
               {
                 /* Look for a semicolon in the expanded line.  */
@@ -966,13 +965,13 @@ eval (struct ebuffer *ebuf, int set_default)
             if (colonp != 0)
               break;
 
-            wtype = get_next_mword(lb_next, NULL, &lb_next, &len);
+            wtype = get_next_mword(lb_next, NULL, &lb_next, &wlen);
             if (wtype == w_eol)
               break;
 
             p2 += strlen(p2);
             *(p2++) = ' ';
-            p2 = variable_expand_string(p2, lb_next, len);
+            p2 = variable_expand_string(p2, lb_next, wlen);
             /* We don't need to worry about cmdleft here, because if it was
                found in the variable_buffer the entire buffer has already
                been expanded... we'll never get here.  */
@@ -1027,15 +1026,14 @@ eval (struct ebuffer *ebuf, int set_default)
           {
             unsigned int l = p2 - variable_buffer;
             plen = strlen (p2);
-            (void) variable_buffer_output (p2+plen,
-                                           lb_next, strlen (lb_next)+1);
+            variable_buffer_output (p2+plen, lb_next, strlen (lb_next)+1);
             p2 = variable_buffer + l;
           }
 
         /* See if it's an "override" or "export" keyword; if so see if what
            comes after it looks like a variable definition.  */
 
-        wtype = get_next_mword (p2, NULL, &p, &len);
+        wtype = get_next_mword (p2, NULL, &p, &wlen);
 
         v_origin = o_file;
         exported = 0;
@@ -1044,17 +1042,17 @@ eval (struct ebuffer *ebuf, int set_default)
             if (word1eq ("override"))
               {
                 v_origin = o_override;
-                wtype = get_next_mword (p+len, NULL, &p, &len);
+                wtype = get_next_mword (p+wlen, NULL, &p, &wlen);
               }
             else if (word1eq ("export"))
               {
                 exported = 1;
-                wtype = get_next_mword (p+len, NULL, &p, &len);
+                wtype = get_next_mword (p+wlen, NULL, &p, &wlen);
               }
           }
 
         if (wtype != w_eol)
-          wtype = get_next_mword (p+len, NULL, NULL, NULL);
+          wtype = get_next_mword (p+wlen, NULL, NULL, NULL);
 
         if (wtype == w_varassign)
           {
@@ -1129,7 +1127,6 @@ eval (struct ebuffer *ebuf, int set_default)
 #ifdef HAVE_DOS_PATHS
         {
           int check_again;
-
           do {
             check_again = 0;
             /* For DOS-style paths, skip a "C:\..." or a "C:/..." */
@@ -1155,7 +1152,7 @@ eval (struct ebuffer *ebuf, int set_default)
             pattern_percent = find_percent (pattern);
             if (pattern_percent == 0)
               fatal (fstart, _("target pattern contains no `%%'"));
-            free ((char *)target);
+            free (target);
           }
         else
           pattern = 0;
@@ -1178,18 +1175,18 @@ eval (struct ebuffer *ebuf, int set_default)
         if (cmdleft != 0)
           {
             /* Semicolon means rest of line is a command.  */
-            unsigned int len = strlen (cmdleft);
+            unsigned int l = strlen (cmdleft);
 
             cmds_started = fstart->lineno;
 
             /* Add this command line to the buffer.  */
-            if (len + 2 > commands_len)
+            if (l + 2 > commands_len)
               {
-                commands_len = (len + 2) * 2;
-                commands = (char *) xrealloc (commands, commands_len);
+                commands_len = (l + 2) * 2;
+                commands = xrealloc (commands, commands_len);
               }
-            bcopy (cmdleft, commands, len);
-            commands_idx += len;
+            memcpy (commands, cmdleft, l);
+            commands_idx += l;
             commands[commands_idx++] = '\n';
           }
 
@@ -1246,10 +1243,10 @@ eval (struct ebuffer *ebuf, int set_default)
                       }
                     for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
                       {
-                        register unsigned int len = strlen (dep_name (d2));
-                        if (!strneq (name, dep_name (d2), len))
+                        unsigned int l = strlen (dep_name (d2));
+                        if (!strneq (name, dep_name (d2), l))
                           continue;
-                        if (streq (name + len, dep_name (d)))
+                        if (streq (name + l, dep_name (d)))
                           {
                             reject = 1;
                             break;
@@ -1288,8 +1285,8 @@ eval (struct ebuffer *ebuf, int set_default)
   record_waiting_files ();
 
   if (collapsed)
-    free ((char *) collapsed);
-  free ((char *) commands);
+    free (collapsed);
+  free (commands);
 
   return 1;
 }
@@ -1322,13 +1319,13 @@ do_define (char *name, unsigned int namelen,
   long nlines = 0;
   int nlevels = 1;
   unsigned int length = 100;
-  char *definition = (char *) xmalloc (length);
+  char *definition = xmalloc (length);
   unsigned int idx = 0;
   char *p;
 
   /* Expand the variable name.  */
-  char *var = (char *) alloca (namelen + 1);
-  bcopy (name, var, namelen);
+  char *var = alloca (namelen + 1);
+  memcpy (var, name, namelen);
   var[namelen] = '\0';
   var = variable_expand (var);
 
@@ -1397,10 +1394,10 @@ do_define (char *name, unsigned int namelen,
       if (idx + len + 1 > length)
         {
           length = (idx + len) * 2;
-          definition = (char *) xrealloc (definition, length + 1);
+          definition = xrealloc (definition, length + 1);
         }
 
-      bcopy (line, &definition[idx], len);
+      memcpy (&definition[idx], line, len);
       idx += len;
       /* Separate lines with a newline.  */
       definition[idx++] = '\n';
@@ -1527,18 +1524,18 @@ conditional_line (char *line, int len, const struct floc *flocp)
   if (conditionals->allocated == 0)
     {
       conditionals->allocated = 5;
-      conditionals->ignoring = (char *) xmalloc (conditionals->allocated);
-      conditionals->seen_else = (char *) xmalloc (conditionals->allocated);
+      conditionals->ignoring = xmalloc (conditionals->allocated);
+      conditionals->seen_else = xmalloc (conditionals->allocated);
     }
 
   o = conditionals->if_cmds++;
   if (conditionals->if_cmds > conditionals->allocated)
     {
       conditionals->allocated += 5;
-      conditionals->ignoring = (char *)
-	xrealloc (conditionals->ignoring, conditionals->allocated);
-      conditionals->seen_else = (char *)
-	xrealloc (conditionals->seen_else, conditionals->allocated);
+      conditionals->ignoring = xrealloc (conditionals->ignoring,
+                                         conditionals->allocated);
+      conditionals->seen_else = xrealloc (conditionals->seen_else,
+                                          conditionals->allocated);
     }
 
   /* Record that we have seen an `if...' but no `else' so far.  */
@@ -1582,9 +1579,9 @@ conditional_line (char *line, int len, const struct floc *flocp)
     }
   else
     {
-      /* "Ifeq" or "ifneq".  */
+      /* "ifeq" or "ifneq".  */
       char *s1, *s2;
-      unsigned int len;
+      unsigned int l;
       char termin = *line == '(' ? ',' : *line;
 
       if (termin != ',' && termin != '"' && termin != '\'')
@@ -1624,9 +1621,9 @@ conditional_line (char *line, int len, const struct floc *flocp)
       s2 = variable_expand (s1);
       /* We must allocate a new copy of the expanded string because
 	 variable_expand re-uses the same buffer.  */
-      len = strlen (s2);
-      s1 = (char *) alloca (len + 1);
-      bcopy (s2, s1, len + 1);
+      l = strlen (s2);
+      s1 = alloca (l + 1);
+      memcpy (s1, s2, l + 1);
 
       if (termin != ',')
 	/* Find the start of the second string.  */
@@ -1639,7 +1636,7 @@ conditional_line (char *line, int len, const struct floc *flocp)
       /* Find the end of the second string.  */
       if (termin == ')')
 	{
-	  register int count = 0;
+	  int count = 0;
 	  s2 = next_token (line);
 	  for (line = s2; *line != '\0'; ++line)
 	    {
@@ -1778,7 +1775,7 @@ record_target_var (struct nameseq *filenames, char *defn,
       struct pattern_var *p;
 
       nextf = filenames->next;
-      free ((char *) filenames);
+      free (filenames);
 
       /* If it's a pattern target, then add it to the pattern-specific
          variable list.  */
@@ -1886,7 +1883,7 @@ record_files (struct nameseq *filenames, char *pattern, char *pattern_percent,
 
   if (commands_idx > 0)
     {
-      cmds = (struct commands *) xmalloc (sizeof (struct commands));
+      cmds = xmalloc (sizeof (struct commands));
       cmds->fileinfo.filenm = flocp->filenm;
       cmds->fileinfo.lineno = cmds_started;
       cmds->commands = savestring (commands, commands_idx);
@@ -1927,18 +1924,16 @@ record_files (struct nameseq *filenames, char *pattern, char *pattern_percent,
 	  if (targets == 0)
 	    {
 	      max_targets = 5;
-	      targets = (char **) xmalloc (5 * sizeof (char *));
-	      target_percents = (char **) xmalloc (5 * sizeof (char *));
+	      targets = xmalloc (5 * sizeof (char *));
+	      target_percents = xmalloc (5 * sizeof (char *));
 	      target_idx = 0;
 	    }
 	  else if (target_idx == max_targets - 1)
 	    {
 	      max_targets += 5;
-	      targets = (char **) xrealloc ((char *) targets,
-					    max_targets * sizeof (char *));
-	      target_percents
-		= (char **) xrealloc ((char *) target_percents,
-				      max_targets * sizeof (char *));
+	      targets = xrealloc (targets, max_targets * sizeof (char *));
+	      target_percents = xrealloc (target_percents,
+                                          max_targets * sizeof (char *));
 	    }
 	  targets[target_idx] = name;
 	  target_percents[target_idx] = implicit_percent;
@@ -2124,7 +2119,7 @@ record_files (struct nameseq *filenames, char *pattern, char *pattern_percent,
       if (deps)
         deps->need_2nd_expansion = second_expansion;
       create_pattern_rule (targets, target_percents, two_colon, deps, cmds, 1);
-      free ((char *) target_percents);
+      free (target_percents);
     }
 }
 
@@ -2201,7 +2196,7 @@ find_char_unquote (char *string, int stop1, int stop2, int blank,
       if (p > string && p[-1] == '\\')
 	{
 	  /* Search for more backslashes.  */
-	  register int i = -2;
+	  int i = -2;
 	  while (&p[i] >= string && p[i] == '\\')
 	    --i;
 	  ++i;
@@ -2210,8 +2205,8 @@ find_char_unquote (char *string, int stop1, int stop2, int blank,
 	    string_len = strlen (string);
 	  /* The number of backslashes is now -I.
 	     Copy P over itself to swallow half of them.  */
-	  bcopy (&p[i / 2], &p[i], (string_len - (p - string)) - (i / 2) + 1);
-	  p += i / 2;
+	  memmove (&p[i], &p[i/2], (string_len - (p - string)) - (i/2) + 1);
+	  p += i/2;
 	  if (i % 2 == 0)
 	    /* All the backslashes quoted each other; the STOPCHAR was
 	       unquoted.  */
@@ -2360,7 +2355,7 @@ parse_file_seq (char **stringp, int stopchar, unsigned int size, int strip)
 #endif
 
       /* Add it to the front of the chain.  */
-      new1 = (struct nameseq *) xmalloc (size);
+      new1 = xmalloc (size);
       new1->name = name;
       new1->next = new;
       new = new1;
@@ -2403,8 +2398,8 @@ parse_file_seq (char **stringp, int stopchar, unsigned int size, int strip)
 
 	    /* Copy "lib(" into LIBNAME.  */
 	    ++paren;
-	    libname = (char *) alloca (paren - n->name + 1);
-	    bcopy (n->name, libname, paren - n->name);
+	    libname = alloca (paren - n->name + 1);
+	    memcpy (libname, n->name, paren - n->name);
 	    libname[paren - n->name] = '\0';
 
 	    if (*paren == '\0')
@@ -2413,7 +2408,7 @@ parse_file_seq (char **stringp, int stopchar, unsigned int size, int strip)
 		   Edit it out of the chain and free its storage.  */
 		lastn->next = n->next;
 		free (n->name);
-		free ((char *) n);
+		free (n);
 		/* LASTN->next is the new stopping elt for the loop below.  */
 		n = lastn->next;
 	      }
@@ -2436,7 +2431,7 @@ parse_file_seq (char **stringp, int stopchar, unsigned int size, int strip)
 		lastn = new1;
 		new1 = new1->next;
 		free (lastn->name);
-		free ((char *) lastn);
+		free (lastn);
 	      }
 	    else
 	      {
@@ -2622,8 +2617,7 @@ readline (struct ebuffer *ebuf)
       {
         unsigned long off = p - start;
         ebuf->size *= 2;
-        start = ebuf->buffer = ebuf->bufstart = (char *) xrealloc (start,
-                                                                   ebuf->size);
+        start = ebuf->buffer = ebuf->bufstart = xrealloc (start, ebuf->size);
         p = start + off;
         end = start + ebuf->size;
         *p = '\0';
@@ -2834,11 +2828,11 @@ construct_include_path (char **arg_dirs)
 #endif
   /* Table to hold the dirs.  */
 
-  register unsigned int defsize = (sizeof (default_include_directories)
-				   / sizeof (default_include_directories[0]));
-  register unsigned int max = 5;
-  register char **dirs = (char **) xmalloc ((5 + defsize) * sizeof (char *));
-  register unsigned int idx = 0;
+  unsigned int defsize = (sizeof (default_include_directories)
+                          / sizeof (default_include_directories[0]));
+  unsigned int max = 5;
+  char **dirs = xmalloc ((5 + defsize) * sizeof (char *));
+  unsigned int idx = 0;
 
 #ifdef  __MSDOS__
   defsize++;
@@ -2866,8 +2860,7 @@ construct_include_path (char **arg_dirs)
 	    if (idx == max - 1)
 	      {
 		max += 5;
-		dirs = (char **)
-		  xrealloc ((char *) dirs, (max + defsize) * sizeof (char *));
+		dirs = xrealloc (dirs, (max + defsize) * sizeof (char *));
 	      }
 	    dirs[idx++] = dir;
 	  }
@@ -2885,7 +2878,7 @@ construct_include_path (char **arg_dirs)
 
     if (djdir)
       {
-	char *defdir = (char *) xmalloc (strlen (djdir->value) + 8 + 1);
+	char *defdir = xmalloc (strlen (djdir->value) + 8 + 1);
 
 	strcat (strcpy (defdir, djdir->value), "/include");
 	dirs[idx++] = defdir;
@@ -3075,15 +3068,14 @@ multi_glob (struct nameseq *chain, unsigned int size)
 			/* No matches.  Use MEMNAME as-is.  */
 			unsigned int alen = strlen (gl.gl_pathv[i]);
 			unsigned int mlen = strlen (memname);
-			struct nameseq *elt
-			  = (struct nameseq *) xmalloc (size);
+			struct nameseq *elt = xmalloc (size);
                         if (size > sizeof (struct nameseq))
-                          bzero (((char *) elt) + sizeof (struct nameseq),
-                                 size - sizeof (struct nameseq));
-			elt->name = (char *) xmalloc (alen + 1 + mlen + 2);
-			bcopy (gl.gl_pathv[i], elt->name, alen);
+                          memset (((char *)elt)+sizeof (struct nameseq), '\0',
+                                  size - sizeof (struct nameseq));
+			elt->name = xmalloc (alen + 1 + mlen + 2);
+			memcpy (elt->name, gl.gl_pathv[i], alen);
 			elt->name[alen] = '(';
-			bcopy (memname, &elt->name[alen + 1], mlen);
+			memcpy (&elt->name[alen + 1], memname, mlen);
 			elt->name[alen + 1 + mlen] = ')';
 			elt->name[alen + 1 + mlen + 1] = '\0';
 			elt->next = new;
@@ -3107,10 +3099,10 @@ multi_glob (struct nameseq *chain, unsigned int size)
 		else
 #endif /* !NO_ARCHIVES */
 		  {
-		    struct nameseq *elt = (struct nameseq *) xmalloc (size);
+		    struct nameseq *elt = xmalloc (size);
                     if (size > sizeof (struct nameseq))
-                      bzero (((char *) elt) + sizeof (struct nameseq),
-                             size - sizeof (struct nameseq));
+                      memset (((char *)elt)+sizeof (struct nameseq), '\0',
+                              size - sizeof (struct nameseq));
 		    elt->name = xstrdup (gl.gl_pathv[i]);
 		    elt->next = new;
 		    new = elt;
@@ -3118,7 +3110,7 @@ multi_glob (struct nameseq *chain, unsigned int size)
 	      }
 	    globfree (&gl);
 	    free (old->name);
-	    free ((char *)old);
+	    free (old);
 	    break;
 	  }
 
diff --git a/remake.c b/remake.c
index 044b49e..363b929 100644
--- a/remake.c
+++ b/remake.c
@@ -238,7 +238,7 @@ update_goal_chain (struct dep *goals)
 		lastgoal->next = g->next;
 
 	      /* Free the storage.  */
-	      free ((char *) g);
+	      free (g);
 
 	      g = lastgoal == 0 ? goals : lastgoal->next;
 
@@ -1061,7 +1061,7 @@ touch_file (struct file *file)
       else
 	{
 	  struct stat statbuf;
-	  char buf;
+	  char buf = 'x';
           int e;
 
           EINTRLOOP (e, fstat (fd, &statbuf));
@@ -1191,10 +1191,10 @@ f_mtime (struct file *file, int search)
 
 	  /* free (file->name); */
 
-	  name = (char *) xmalloc (arlen + 1 + memlen + 2);
-	  bcopy (arname, name, arlen);
+	  name = xmalloc (arlen + 1 + memlen + 2);
+	  memcpy (name, arname, arlen);
 	  name[arlen] = '(';
-	  bcopy (memname, name + arlen + 1, memlen);
+	  memcpy (name + arlen + 1, memname, memlen);
 	  name[arlen + 1 + memlen] = ')';
 	  name[arlen + 1 + memlen + 1] = '\0';
 
diff --git a/remote-cstms.c b/remote-cstms.c
index e90635a..5728a80 100644
--- a/remote-cstms.c
+++ b/remote-cstms.c
@@ -98,7 +98,7 @@ start_remote_job_p (int first_p)
 	  /* Normalize the current directory path name to something
 	     that should work on all machines exported to.  */
 
-	  normalized_cwd = (char *) xmalloc (GET_PATH_MAX);
+	  normalized_cwd = xmalloc (GET_PATH_MAX);
 	  strcpy (normalized_cwd, starting_directory);
 	  if (Customs_NormPath (normalized_cwd, GET_PATH_MAX) < 0)
 	    /* Path normalization failure means using Customs
diff --git a/rule.c b/rule.c
index 27cf3c9..ee96ec1 100644
--- a/rule.c
+++ b/rule.c
@@ -124,9 +124,9 @@ count_implicit_rule_limits (void)
 		  if (name != 0)
 		    free (name);
 		  namelen = p - dep->name;
-		  name = (char *) xmalloc (namelen + 1);
+		  name = xmalloc (namelen + 1);
 		}
-	      bcopy (dep->name, name, p - dep->name);
+	      memcpy (name, dep->name, p - dep->name);
 	      name[p - dep->name] = '\0';
 
 	      /* In the deps of an implicit rule the `changed' flag
@@ -182,12 +182,12 @@ convert_suffix_rule (char *target, char *source, struct commands *cmds)
       len = strlen (target);
       targname = xmalloc (1 + len + 1);
       targname[0] = '%';
-      bcopy (target, targname + 1, len + 1);
+      memcpy (targname + 1, target, len + 1);
       targpercent = targname;
     }
 
-  names = (char **) xmalloc (2 * sizeof (char *));
-  percents = (char **) alloca (2 * sizeof (char *));
+  names = xmalloc (2 * sizeof (char *));
+  percents = alloca (2 * sizeof (char *));
   names[0] = targname;
   percents[0] = targpercent;
   names[1] = percents[1] = 0;
@@ -200,7 +200,7 @@ convert_suffix_rule (char *target, char *source, struct commands *cmds)
       len = strlen (source);
       depname = xmalloc (1 + len + 1);
       depname[0] = '%';
-      bcopy (source, depname + 1, len + 1);
+      memcpy (depname + 1, source, len + 1);
       deps = alloc_dep ();
       deps->name = depname;
     }
@@ -230,13 +230,13 @@ convert_to_pattern (void)
 	maxsuffix = namelen;
     }
 
-  rulename = (char *) alloca ((maxsuffix * 2) + 1);
+  rulename = alloca ((maxsuffix * 2) + 1);
 
   for (d = suffix_file->deps; d != 0; d = d->next)
     {
       /* Make a rule that is just the suffix, with no deps or commands.
 	 This rule exists solely to disqualify match-anything rules.  */
-      convert_suffix_rule (dep_name (d), (char *) 0, (struct commands *) 0);
+      convert_suffix_rule (dep_name (d), 0, 0);
 
       f = d->file;
       if (f->cmds != 0)
@@ -245,7 +245,7 @@ convert_to_pattern (void)
 
       /* Record a pattern for each of this suffix's two-suffix rules.  */
       slen = strlen (dep_name (d));
-      bcopy (dep_name (d), rulename, slen);
+      memcpy (rulename, dep_name (d), slen);
       for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
 	{
 	  s2len = strlen (dep_name (d2));
@@ -253,7 +253,7 @@ convert_to_pattern (void)
 	  if (slen == s2len && streq (dep_name (d), dep_name (d2)))
 	    continue;
 
-	  bcopy (dep_name (d2), rulename + slen, s2len + 1);
+	  memcpy (rulename + slen, dep_name (d2), s2len + 1);
 	  f = lookup_file (rulename);
 	  if (f == 0 || f->cmds == 0)
 	    continue;
@@ -261,7 +261,7 @@ convert_to_pattern (void)
 	  if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
 	    /* A suffix rule `.X.a:' generates the pattern rule `(%.o): %.X'.
 	       It also generates a normal `%.a: %.X' rule below.  */
-	    convert_suffix_rule ((char *) 0, /* Indicates `(%.o)'.  */
+	    convert_suffix_rule (NULL, /* Indicates `(%.o)'.  */
 				 dep_name (d),
 				 f->cmds);
 
@@ -362,11 +362,11 @@ install_pattern_rule (struct pspec *p, int terminal)
   register struct rule *r;
   char *ptr;
 
-  r = (struct rule *) xmalloc (sizeof (struct rule));
+  r = xmalloc (sizeof (struct rule));
 
-  r->targets = (char **) xmalloc (2 * sizeof (char *));
-  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
-  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
+  r->targets = xmalloc (2 * sizeof (char *));
+  r->suffixes = xmalloc (2 * sizeof (char *));
+  r->lens = xmalloc (2 * sizeof (unsigned int));
 
   r->targets[1] = 0;
   r->suffixes[1] = 0;
@@ -391,7 +391,7 @@ install_pattern_rule (struct pspec *p, int terminal)
   if (new_pattern_rule (r, 0))
     {
       r->terminal = terminal;
-      r->cmds = (struct commands *) xmalloc (sizeof (struct commands));
+      r->cmds = xmalloc (sizeof (struct commands));
       r->cmds->fileinfo.filenm = 0;
       r->cmds->fileinfo.lineno = 0;
       /* These will all be string literals, but we malloc space for them
@@ -429,9 +429,9 @@ freerule (struct rule *rule, struct rule *lastrule)
       dep = t;
     }
 
-  free ((char *) rule->targets);
-  free ((char *) rule->suffixes);
-  free ((char *) rule->lens);
+  free (rule->targets);
+  free (rule->suffixes);
+  free (rule->lens);
 
   /* We can't free the storage for the commands because there
      are ways that they could be in more than one place:
@@ -444,7 +444,7 @@ freerule (struct rule *rule, struct rule *lastrule)
        be discarded here, but both would contain the same `struct commands'
        pointer from the `struct file' for the suffix rule.  */
 
-  free ((char *) rule);
+  free (rule);
 
   if (pattern_rules == rule)
     if (lastrule != 0)
@@ -474,24 +474,22 @@ create_pattern_rule (char **targets, char **target_percents,
                      struct commands *commands, int override)
 {
   unsigned int max_targets, i;
-  struct rule *r = (struct rule *) xmalloc (sizeof (struct rule));
+  struct rule *r = xmalloc (sizeof (struct rule));
 
   r->cmds = commands;
   r->deps = deps;
   r->targets = targets;
 
   max_targets = 2;
-  r->lens = (unsigned int *) xmalloc (2 * sizeof (unsigned int));
-  r->suffixes = (char **) xmalloc (2 * sizeof (char *));
+  r->lens = xmalloc (2 * sizeof (unsigned int));
+  r->suffixes = xmalloc (2 * sizeof (char *));
   for (i = 0; targets[i] != 0; ++i)
     {
       if (i == max_targets - 1)
 	{
 	  max_targets += 5;
-	  r->lens = (unsigned int *)
-	    xrealloc ((char *) r->lens, max_targets * sizeof (unsigned int));
-	  r->suffixes = (char **)
-	    xrealloc ((char *) r->suffixes, max_targets * sizeof (char *));
+	  r->lens = xrealloc (r->lens, max_targets * sizeof (unsigned int));
+	  r->suffixes = xrealloc (r->suffixes, max_targets * sizeof (char *));
 	}
       r->lens[i] = strlen (targets[i]);
       r->suffixes[i] = (target_percents == 0 ? find_percent (targets[i])
@@ -502,10 +500,8 @@ create_pattern_rule (char **targets, char **target_percents,
 
   if (i < max_targets - 1)
     {
-      r->lens = (unsigned int *) xrealloc ((char *) r->lens,
-					   (i + 1) * sizeof (unsigned int));
-      r->suffixes = (char **) xrealloc ((char *) r->suffixes,
-					(i + 1) * sizeof (char *));
+      r->lens = xrealloc (r->lens, (i + 1) * sizeof (unsigned int));
+      r->suffixes = xrealloc (r->suffixes, (i + 1) * sizeof (char *));
     }
 
   if (new_pattern_rule (r, override))
diff --git a/strcache.c b/strcache.c
index 6cfae42..33dcaf1 100644
--- a/strcache.c
+++ b/strcache.c
@@ -43,7 +43,7 @@ static struct strcache *
 new_cache()
 {
   struct strcache *new;
-  new = (struct strcache *) xmalloc (sizeof (*new) + bufsize);
+  new = xmalloc (sizeof (*new) + bufsize);
   new->end = new->buffer;
   new->count = 0;
   new->bytesfree = bufsize;
@@ -118,7 +118,7 @@ static const char *
 add_hash (const char *str, int len)
 {
   /* Look up the string in the hash.  If it's there, return it.  */
-  char **slot = (char **) hash_find_slot (&strings, str);
+  char *const *slot = (char *const *) hash_find_slot (&strings, str);
   const char *key = *slot;
 
   if (!HASH_VACANT (key))
diff --git a/variable.c b/variable.c
index f23f7d1..37d3f72 100644
--- a/variable.c
+++ b/variable.c
@@ -44,8 +44,7 @@ static struct pattern_var *last_pattern_var;
 struct pattern_var *
 create_pattern_var (char *target, char *suffix)
 {
-  register struct pattern_var *p
-    = (struct pattern_var *) xmalloc (sizeof (struct pattern_var));
+  register struct pattern_var *p = xmalloc (sizeof (struct pattern_var));
 
   if (last_pattern_var != 0)
     last_pattern_var->next = p;
@@ -206,7 +205,7 @@ define_variable_in_set (const char *name, unsigned int length,
 
   /* Create a new variable definition and add it to the hash table.  */
 
-  v = (struct variable *) xmalloc (sizeof (struct variable));
+  v = xmalloc (sizeof (struct variable));
   v->name = savestring (name, length);
   v->length = length;
   hash_insert_at (&set->table, v, var_slot);
@@ -314,7 +313,7 @@ handle_special_var (struct variable *var)
                 p = &var->value[off];
               }
 
-            bcopy (v->name, p, l);
+            memcpy (p, v->name, l);
             p += l;
             *(p++) = ' ';
           }
@@ -450,7 +449,7 @@ initialize_file_variables (struct file *file, int reading)
     {
       l = (struct variable_set_list *)
 	xmalloc (sizeof (struct variable_set_list));
-      l->set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
+      l->set = xmalloc (sizeof (struct variable_set));
       hash_init (&l->set->table, PERFILE_VARIABLE_BUCKETS,
                  variable_hash_1, variable_hash_2, variable_hash_cmp);
       file->variables = l;
@@ -545,7 +544,7 @@ create_new_variable_set (void)
   register struct variable_set_list *setlist;
   register struct variable_set *set;
 
-  set = (struct variable_set *) xmalloc (sizeof (struct variable_set));
+  set = xmalloc (sizeof (struct variable_set));
   hash_init (&set->table, SMALL_SCOPE_VARIABLE_BUCKETS,
 	     variable_hash_1, variable_hash_2, variable_hash_cmp);
 
@@ -570,8 +569,8 @@ free_variable_set (struct variable_set_list *list)
 {
   hash_map (&list->set->table, free_variable_name_and_value);
   hash_free (&list->set->table, 1);
-  free ((char *) list->set);
-  free ((char *) list);
+  free (list->set);
+  free (list);
 }
 
 /* Create a new variable set and push it on the current setlist.
@@ -627,10 +626,10 @@ pop_variable_scope (void)
     }
 
   /* Free the one we no longer need.  */
-  free ((char *) setlist);
+  free (setlist);
   hash_map (&set->table, free_variable_name_and_value);
   hash_free (&set->table, 1);
-  free ((char *) set);
+  free (set);
 }
 
 /* Merge FROM_SET into TO_SET, freeing unused storage in FROM_SET.  */
@@ -942,7 +941,7 @@ target_environment (struct file *file)
   makelevel_key.length = MAKELEVEL_LENGTH;
   hash_delete (&table, &makelevel_key);
 
-  result = result_0 = (char **) xmalloc ((table.ht_fill + 2) * sizeof (char *));
+  result = result_0 = xmalloc ((table.ht_fill + 2) * sizeof (char *));
 
   v_slot = (struct variable **) table.ht_vec;
   v_end = v_slot + table.ht_size;
@@ -977,8 +976,8 @@ target_environment (struct file *file)
 	  }
       }
 
-  *result = (char *) xmalloc (100);
-  (void) sprintf (*result, "%s=%u", MAKELEVEL_NAME, makelevel + 1);
+  *result = xmalloc (100);
+  sprintf (*result, "%s=%u", MAKELEVEL_NAME, makelevel + 1);
   *++result = 0;
 
   hash_free (&table, 0);
@@ -1076,10 +1075,10 @@ do_variable_definition (const struct floc *flocp, const char *varname,
 
             oldlen = strlen (v->value);
             vallen = strlen (val);
-            p = (char *) alloca (oldlen + 1 + vallen + 1);
-            bcopy (v->value, p, oldlen);
+            p = alloca (oldlen + 1 + vallen + 1);
+            memcpy (p, v->value, oldlen);
             p[oldlen] = ' ';
-            bcopy (val, &p[oldlen + 1], vallen + 1);
+            memcpy (&p[oldlen + 1], val, vallen + 1);
           }
       }
     }
@@ -1105,7 +1104,7 @@ do_variable_definition (const struct floc *flocp, const char *varname,
       extern char * __dosexec_find_on_path (const char *, char *[], char *);
 
       /* See if we can find "/bin/sh.exe", "/bin/sh.com", etc.  */
-      if (__dosexec_find_on_path (p, (char **)0, shellpath))
+      if (__dosexec_find_on_path (p, NULL, shellpath))
 	{
 	  char *p;
 
@@ -1141,11 +1140,11 @@ do_variable_definition (const struct floc *flocp, const char *varname,
 	     executable extensions) along the $PATH.  */
 	  if (pathv)
 	    pathlen = strlen (pathv->value);
-	  path_string = (char *)xmalloc (5 + pathlen + 2 + 1);
+	  path_string = xmalloc (5 + pathlen + 2 + 1);
 	  /* On MSDOS, current directory is considered as part of $PATH.  */
 	  sprintf (path_string, "PATH=.;%s", pathv ? pathv->value : "");
 	  fake_env[0] = path_string;
-	  fake_env[1] = (char *)0;
+	  fake_env[1] = 0;
 	  if (__dosexec_find_on_path (shellbase, fake_env, shellpath))
 	    {
 	      char *p;
@@ -1307,8 +1306,8 @@ parse_variable_definition (struct variable *v, char *line)
   v->value = p;
 
   /* Expand the name, so "$(foo)bar = baz" works.  */
-  name = (char *) alloca (end - beg + 1);
-  bcopy (beg, name, end - beg);
+  name = alloca (end - beg + 1);
+  memcpy (name, beg, end - beg);
   name[end - beg] = '\0';
   v->name = allocated_variable_expand (name);
 
@@ -1359,8 +1358,8 @@ try_variable_definition (const struct floc *flocp, char *line,
 static void
 print_variable (const void *item, void *arg)
 {
-  const struct variable *v = (struct variable *) item;
-  const char *prefix = (char *) arg;
+  const struct variable *v = item;
+  const char *prefix = arg;
   const char *origin;
 
   switch (v->origin)
diff --git a/vmsfunctions.c b/vmsfunctions.c
index 8cb0ddd..589a721 100644
--- a/vmsfunctions.c
+++ b/vmsfunctions.c
@@ -37,7 +37,7 @@ opendir (char *dspec)
   struct DIR *dir  = (struct DIR *)xmalloc (sizeof (struct DIR));
   struct NAM *dnam = (struct NAM *)xmalloc (sizeof (struct NAM));
   struct FAB *dfab = &dir->fab;
-  char *searchspec = (char *)xmalloc (MAXNAMLEN + 1);
+  char *searchspec = xmalloc (MAXNAMLEN + 1);
 
   memset (dir, 0, sizeof *dir);
 
diff --git a/vmsify.c b/vmsify.c
index ac82942..d9f7df4 100644
--- a/vmsify.c
+++ b/vmsify.c
@@ -134,7 +134,7 @@ trnlog (char *name)
     }
   reslt[resltlen] = '\0';
 
-  s = (char *)malloc (resltlen+1);
+  s = malloc (resltlen+1);
   if (s == 0)
     return "";
   strcpy (s, reslt);
diff --git a/vpath.c b/vpath.c
index 85e8c0a..7f6f316 100644
--- a/vpath.c
+++ b/vpath.c
@@ -196,8 +196,8 @@ construct_vpath_list (char *pattern, char *dirpath)
 
 	      /* Free its unused storage.  */
 	      free (path->pattern);
-	      free ((char *) path->searchpath);
-	      free ((char *) path);
+	      free (path->searchpath);
+	      free (path);
 	    }
 	  else
 	    lastpath = path;
@@ -224,7 +224,7 @@ construct_vpath_list (char *pattern, char *dirpath)
     if (*p++ == PATH_SEPARATOR_CHAR || isblank ((unsigned char)*p))
       ++maxelem;
 
-  vpath = (char **) xmalloc (maxelem * sizeof (char *));
+  vpath = xmalloc (maxelem * sizeof (char *));
   maxvpath = 0;
 
   /* Skip over any initial separators and blanks.  */
@@ -285,14 +285,13 @@ construct_vpath_list (char *pattern, char *dirpath)
 	 entry, to where the nil-pointer terminator goes.
 	 Usually this is maxelem - 1.  If not, shrink down.  */
       if (elem < (maxelem - 1))
-	vpath = (char **) xrealloc ((char *) vpath,
-				    (elem + 1) * sizeof (char *));
+	vpath = xrealloc (vpath, (elem+1) * sizeof (char *));
 
       /* Put the nil-pointer terminator on the end of the VPATH list.  */
       vpath[elem] = 0;
 
       /* Construct the vpath structure and put it into the linked list.  */
-      path = (struct vpath *) xmalloc (sizeof (struct vpath));
+      path = xmalloc (sizeof (struct vpath));
       path->searchpath = vpath;
       path->maxlen = maxvpath;
       path->next = vpaths;
@@ -306,7 +305,7 @@ construct_vpath_list (char *pattern, char *dirpath)
   else
     {
       /* There were no entries, so free whatever space we allocated.  */
-      free ((char *) vpath);
+      free (vpath);
       if (pattern != 0)
 	free (pattern);
     }
@@ -414,7 +413,7 @@ selective_vpath_search (struct vpath *path, char **file,
      a slash, the directory prefix that came with *FILE,
      another slash (although this one may not always be
      necessary), the filename, and a null terminator.  */
-  name = (char *) xmalloc (maxvpath + 1 + name_dplen + 1 + flen + 1);
+  name = xmalloc (maxvpath + 1 + name_dplen + 1 + flen + 1);
 
   /* Try each VPATH entry.  */
   for (i = 0; vpath[i] != 0; ++i)
@@ -425,7 +424,7 @@ selective_vpath_search (struct vpath *path, char **file,
 
       /* Put the next VPATH entry into NAME at N and increment N past it.  */
       vlen = strlen (vpath[i]);
-      bcopy (vpath[i], n, vlen);
+      memcpy (n, vpath[i], vlen);
       n += vlen;
 
       /* Add the directory prefix already in *FILE.  */
@@ -434,7 +433,7 @@ selective_vpath_search (struct vpath *path, char **file,
 #ifndef VMS
 	  *n++ = '/';
 #endif
-	  bcopy (*file, n, name_dplen);
+	  memcpy (n, *file, name_dplen);
 	  n += name_dplen;
 	}
 
@@ -448,11 +447,11 @@ selective_vpath_search (struct vpath *path, char **file,
       if (n != name && n[-1] != '/')
 	{
 	  *n = '/';
-	  bcopy (filename, n + 1, flen + 1);
+	  memcpy (n + 1, filename, flen + 1);
 	}
       else
 #endif
-	bcopy (filename, n, flen + 1);
+	memcpy (n, filename, flen + 1);
 
       /* Check if the file is mentioned in a makefile.  If *FILE is not
 	 a target, that is enough for us to decide this file exists.
-- 
cgit v1.0-41-gc330

