----++++src/security/PeerOptions.cc
@@ -28,17 +28,39 @@ Security::PeerOptions::PeerOptions(const Security::PeerOptions &amp;p) :
     sslCipher(p.sslCipher),
     sslFlags(p.sslFlags),
     sslDomain(p.sslDomain),
-    parsedOptions(p.parsedOptions),
     parsedFlags(p.parsedFlags),
     certs(p.certs),
     caFiles(p.caFiles),
     parsedCrl(p.parsedCrl),
     sslVersion(p.sslVersion),
     encryptTransport(p.encryptTransport)
 {
+    if (!sslOptions.isEmpty())
+        parseOptions(parsedOptions); // re-parse after sslOptions copied.
     memcpy(&amp;flags, &amp;p.flags, sizeof(flags));
 }
 
+Security::PeerOptions &amp;
+Security::PeerOptions::operator =(const Security::PeerOptions &amp;p)
+{
+    sslOptions = p.sslOptions;
+    if (!sslOptions.isEmpty())
+        parseOptions(parsedOptions); // re-parse after sslOptions copied.
+    caDir = p.caDir;
+    crlFile = p.crlFile;
+    sslCipher = p.sslCipher;
+    sslFlags = p.sslFlags;
+    sslDomain = p.sslDomain;
+    parsedFlags = p.parsedFlags;
+    certs = p.certs;
+    caFiles = p.caFiles;
+    parsedCrl = p.parsedCrl;
+    sslVersion = p.sslVersion;
+    encryptTransport = p.encryptTransport;
+    memcpy(&amp;flags, &amp;p.flags, sizeof(flags));
+    return *this;
+}
+
 void
 Security::PeerOptions::parse(const char *token)
 {
@@ -71,7 +93,7 @@ Security::PeerOptions::parse(const char *token)
         tlsMinVersion = SBuf(token + 12);
     } else if (strncmp(token, &quot;options=&quot;, 8) == 0) {
         sslOptions = SBuf(token + 8);
-        parsedOptions = parseOptions();
+        parseOptions(parsedOptions);
     } else if (strncmp(token, &quot;cipher=&quot;, 7) == 0) {
         sslCipher = SBuf(token + 7);
     } else if (strncmp(token, &quot;cafile=&quot;, 7) == 0) {
@@ -167,49 +189,85 @@ Security::PeerOptions::updateTlsVersionLimits()
         if (tok.skip(&#39;1&#39;) &amp;&amp; tok.skip(&#39;.&#39;) &amp;&amp; tok.int64(v, 10, false, 1) &amp;&amp; v &lt;= 3) {
             // only account for TLS here - SSL versions are handled by options= parameter
             // avoid affecting options= parameter in cachemgr config report
+#if USE_OPENSSL
 #if SSL_OP_NO_TLSv1
             if (v &gt; 0)
-                parsedOptions |= SSL_OP_NO_TLSv1;
+                *parsedOptions |= SSL_OP_NO_TLSv1;
 #endif
 #if SSL_OP_NO_TLSv1_1
             if (v &gt; 1)
-                parsedOptions |= SSL_OP_NO_TLSv1_1;
+                *parsedOptions |= SSL_OP_NO_TLSv1_1;
 #endif
 #if SSL_OP_NO_TLSv1_2
             if (v &gt; 2)
-                parsedOptions |= SSL_OP_NO_TLSv1_2;
+                *parsedOptions |= SSL_OP_NO_TLSv1_2;
+#endif
+
+#elif USE_GNUTLS
+            // XXX: update parsedOptions directly to avoid polluting &#39;options=&#39; dumps
+            SBuf add;
+            if (v &gt; 0)
+                add.append(&quot;:-VERS-TLS1.0&quot;);
+            if (v &gt; 1)
+                add.append(&quot;:-VERS-TLS1.1&quot;);
+            if (v &gt; 2)
+                add.append(&quot;:-VERS-TLS1.2&quot;);
+
+            if (sslOptions.isEmpty())
+                add.chop(1); // remove the initial &#39;:&#39;
+            sslOptions.append(add);
 #endif
 
         } else {
             debugs(0, DBG_PARSE_NOTE(1), &quot;WARNING: Unknown TLS minimum version: &quot; &lt;&lt; tlsMinVersion);
         }
 
-    } else if (sslVersion &gt; 2) {
+        return;
+    }
+
+     if (sslVersion &gt; 2) {
         // backward compatibility hack for sslversion= configuration
         // only use if tls-min-version=N.N is not present
         // values 0-2 for auto and SSLv2 are not supported any longer.
         // Do it this way so we DO cause changes to options= in cachemgr config report
         const char *add = NULL;
         switch (sslVersion) {
         case 3:
-            add = &quot;NO_TLSv1,NO_TLSv1_1,NO_TLSv1_2&quot;;
+#if USE_OPENSSL
+            add = &quot;,NO_TLSv1,NO_TLSv1_1,NO_TLSv1_2&quot;;
+#elif USE_GNUTLS
+            add = &quot;:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-TLS1.2&quot;;
+#endif
             break;
         case 4:
-            add = &quot;NO_SSLv3,NO_TLSv1_1,NO_TLSv1_2&quot;;
+#if USE_OPENSSL
+            add = &quot;,NO_SSLv3,NO_TLSv1_1,NO_TLSv1_2&quot;;
+#elif USE_GNUTLS
+            add = &quot;:+VERS-TLS1.0:-VERS-TLS1.1:-VERS-TLS1.2&quot;;
+#endif
             break;
         case 5:
-            add = &quot;NO_SSLv3,NO_TLSv1,NO_TLSv1_2&quot;;
+#if USE_OPENSSL
+            add = &quot;,NO_SSLv3,NO_TLSv1,NO_TLSv1_2&quot;;
+#elif USE_GNUTLS
+            add = &quot;:-VERS-TLS1.0:+VERS-TLS1.1:-VERS-TLS1.2&quot;;
+#endif
             break;
         case 6:
-            add = &quot;NO_SSLv3,NO_TLSv1,NO_TLSv1_1&quot;;
+#if USE_OPENSSL
+            add = &quot;,NO_SSLv3,NO_TLSv1,NO_TLSv1_1&quot;;
+#elif USE_GNUTLS
+            add = &quot;:-VERS-TLS1.0:-VERS-TLS1.1&quot;;
+#endif
             break;
         default: // nothing
             break;
         }
         if (add) {
-            if (!sslOptions.isEmpty())
-                sslOptions.append(&quot;,&quot;,1);
-            sslOptions.append(add, strlen(add));
+            if (sslOptions.isEmpty())
+                sslOptions.append(add+1, strlen(add+1));
+            else
+                sslOptions.append(add, strlen(add));
         }
         sslVersion = 0; // prevent sslOptions being repeatedly appended
     }
@@ -257,8 +315,11 @@ Security::PeerOptions::createClientContext(bool setOptions)
     Security::ContextPointer t(createBlankContext());
     if (t) {
 #if USE_OPENSSL
+        // NP: GnuTLS uses &#39;priorities&#39; which are set per-session instead.
+        SSL_CTX_set_options(t.get(), (setOptions ? *parsedOptions : 0));
+
         // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
-        Ssl::InitClientContext(t, *this, (setOptions ? parsedOptions : 0), parsedFlags);
+        Ssl::InitClientContext(t, *this, parsedFlags);
 #endif
         updateContextNpn(t);
         updateContextCa(t);
@@ -268,6 +329,7 @@ Security::PeerOptions::createClientContext(bool setOptions)
     return t;
 }
 
+#if USE_OPENSSL
 /// set of options we can parse and what they map to
 static struct ssl_option {
     const char *name;
@@ -397,16 +459,18 @@ static struct ssl_option {
         NULL, 0
     }
 };
+#endif /* USE_OPENSSL */
 
 /**
  * Pre-parse TLS options= parameter to be applied when the TLS objects created.
  * Options must not used in the case of peek or stare bump mode.
  */
-long
-Security::PeerOptions::parseOptions()
+void
+Security::PeerOptions::parseOptions(Security::ParsedOptionsPointer &amp;theOut)
 {
-    long op = 0;
+#if USE_OPENSSL
     ::Parser::Tokenizer tok(sslOptions);
+    long op;
 
     do {
         enum {
@@ -467,7 +531,19 @@ Security::PeerOptions::parseOptions()
     // compliance with RFC 6176: Prohibiting Secure Sockets Layer (SSL) Version 2.0
     op = op | SSL_OP_NO_SSLv2;
 #endif
-    return op;
+    theOut = new long(op);
+
+#elif USE_GNUTLS
+    const char *err = nullptr;
+    const char *priorities = (sslOptions.isEmpty() ? nullptr : sslOptions.c_str());
+    gnutls_priority_t op;
+    int x = gnutls_priority_init(&amp;op, priorities, &amp;err);
+    if (x != GNUTLS_E_SUCCESS) {
+        fatalf(&quot;Unknown TLS option &#39;%s&#39;&quot;, err);
+    }
+    theOut.reset(op);
+
+#endif
 }
 
 /**
@@ -641,6 +717,26 @@ Security::PeerOptions::updateContextCrl(Security::ContextPointer &amp;ctx)
 #endif /* USE_OPENSSL */
 }
 
+void
+Security::PeerOptions::updateSessionOptions(Security::SessionPointer &amp;s)
+{
+    // &#39;options=&#39; value being set to session is a GnuTLS specific thing.
+#if !USE_OPENSSL &amp;&amp; USE_GNUTLS
+    int x;
+    if (!parsedOptions) {
+        debugs(83, 5, &quot;set GnuTLS default priority/options for session=&quot; &lt;&lt; s);
+        x = gnutls_set_default_priority(s.get());
+    } else {
+        debugs(83, 5, &quot;set GnuTLS options &#39;&quot; &lt;&lt; sslOptions &lt;&lt; &quot;&#39; for session=&quot; &lt;&lt; s);
+        x = gnutls_priority_set(s.get(), parsedOptions.get());
+    }
+
+    if (x != GNUTLS_E_SUCCESS) {
+        debugs(83, 1, &quot;Failed to set TLS options. error: &quot; &lt;&lt; Security::ErrorString(x));
+    }
+#endif
+}
+
 void
 parse_securePeerOptions(Security::PeerOptions *opt)
 {
----++++src/security/PeerOptions.h
@@ -22,9 +22,10 @@ namespace Security
 class PeerOptions
 {
 public:
-    PeerOptions() : parsedOptions(0), parsedFlags(0), sslVersion(0), encryptTransport(false) {}
+    PeerOptions() = default;
     PeerOptions(const PeerOptions &amp;);
-    virtual ~PeerOptions() = default;
+    PeerOptions &amp;operator =(const PeerOptions &amp;);
+    virtual ~PeerOptions() {}
 
     /// parse a TLS squid.conf option
     virtual void parse(const char *);
@@ -50,11 +51,14 @@ class PeerOptions
     /// setup the CRL details for the given context
     void updateContextCrl(Security::ContextPointer &amp;);
 
+    /// setup any library-specific options that can be set for the given session
+    void updateSessionOptions(Security::SessionPointer &amp;);
+
     /// output squid.conf syntax with &#39;pfx&#39; prefix on parameters for the stored settings
     virtual void dumpCfg(Packable *, const char *pfx) const;
 
 private:
-    long parseOptions();
+    void parseOptions(Security::ParsedOptionsPointer &amp;); ///&lt; parsed value of sslOptions
     long parseFlags();
     void loadCrlFile();
 
@@ -69,15 +73,15 @@ class PeerOptions
 
     SBuf tlsMinVersion;  ///&lt; version label for minimum TLS version to permit
 
-    long parsedOptions; ///&lt; parsed value of sslOptions
-    long parsedFlags;   ///&lt; parsed value of sslFlags
+    Security::ParsedOptionsPointer parsedOptions; ///&lt; parsed value of sslOptions
+    long parsedFlags = 0;   ///&lt; parsed value of sslFlags
 
     std::list&lt;Security::KeyData&gt; certs; ///&lt; details from the cert= and file= config parameters
     std::list&lt;SBuf&gt; caFiles;  ///&lt; paths of files containing trusted Certificate Authority
     Security::CertRevokeList parsedCrl; ///&lt; CRL to use when verifying the remote end certificate
 
 protected:
-    int sslVersion;
+    int sslVersion = 0;
 
     /// flags governing Squid internal TLS operations
     struct flags_ {
@@ -92,7 +96,7 @@ class PeerOptions
 
 public:
     /// whether transport encryption (TLS/SSL) is to be used on connections to the peer
-    bool encryptTransport;
+    bool encryptTransport = false;
 };
 
 /// configuration options for DIRECT server access
----++++src/ssl/PeekingPeerConnector.cc
@@ -185,7 +185,7 @@ Ssl::PeekingPeerConnector::initialize(Security::SessionPointer &amp;serverSession)
             }
         } else {
             // Set client SSL options
-            SSL_set_options(serverSession.get(), ::Security::ProxyOutgoingConfig.parsedOptions);
+            SSL_set_options(serverSession.get(), *::Security::ProxyOutgoingConfig.parsedOptions);
 
             // Use SNI TLS extension only when we connect directly
             // to the origin server and we know the server host name.
----++++src/ssl/support.cc
@@ -494,7 +494,7 @@ static bool
 configureSslContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
 {
     int ssl_error;
-    SSL_CTX_set_options(ctx.get(), port.secure.parsedOptions);
+    SSL_CTX_set_options(ctx.get(), *port.secure.parsedOptions);
 
 #if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
     SSL_CTX_set_info_callback(ctx.get(), ssl_info_cb);
@@ -621,13 +621,11 @@ Ssl::InitServerContext(Security::ContextPointer &amp;ctx, AnyP::PortCfg &amp;port)
 }
 
 bool
-Ssl::InitClientContext(Security::ContextPointer &amp;ctx, Security::PeerOptions &amp;peer, long options, long fl)
+Ssl::InitClientContext(Security::ContextPointer &amp;ctx, Security::PeerOptions &amp;peer, long fl)
 {
     if (!ctx)
         return false;
 
-    SSL_CTX_set_options(ctx.get(), options);
-
 #if defined(SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)
     SSL_CTX_set_info_callback(ctx.get(), ssl_info_cb);
 #endif
----++++src/ssl/support.h
@@ -81,7 +81,7 @@ extern const char *SessionCacheName;
 bool InitServerContext(Security::ContextPointer &amp;, AnyP::PortCfg &amp;);
 
 /// initialize a TLS client context with OpenSSL specific settings
-bool InitClientContext(Security::ContextPointer &amp;, Security::PeerOptions &amp;, long options, long flags);
+bool InitClientContext(Security::ContextPointer &amp;, Security::PeerOptions &amp;, long flags);
 
 #if defined(CRYPTO_LOCK_X509)
 // portability wrapper for OpenSSL 1.0 vs 1.1
----++++src/tests/stub_libsecurity.cc
@@ -68,15 +68,15 @@ void PeerConnector::recordNegotiationDetails() STUB
 
 #include &quot;security/PeerOptions.h&quot;
 Security::PeerOptions Security::ProxyOutgoingConfig;
+Security::PeerOptions &amp;Security::PeerOptions::operator =(const Security::PeerOptions &amp;) STUB_RETVAL(*this)
 void Security::PeerOptions::parse(char const*) STUB
 Security::ContextPointer Security::PeerOptions::createClientContext(bool) STUB_RETVAL(Security::ContextPointer())
 void Security::PeerOptions::updateTlsVersionLimits() STUB
 Security::ContextPointer Security::PeerOptions::createBlankContext() const STUB_RETVAL(Security::ContextPointer())
 void Security::PeerOptions::updateContextCa(Security::ContextPointer &amp;) STUB
 void Security::PeerOptions::updateContextCrl(Security::ContextPointer &amp;) STUB
+void Security::PeerOptions::updateSessionOptions(Security::SessionPointer &amp;) STUB
 void Security::PeerOptions::dumpCfg(Packable*, char const*) const STUB
-long Security::PeerOptions::parseOptions() STUB_RETVAL(0)
-long Security::PeerOptions::parseFlags() STUB_RETVAL(0)
 void parse_securePeerOptions(Security::PeerOptions *) STUB
 
 #include &quot;security/ServerOptions.h&quot;
----++++src/tests/stub_libsslsquid.cc
@@ -51,7 +51,7 @@ const String &amp; Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 namespace Ssl
 {
 bool InitServerContext(Security::ContextPointer &amp;, AnyP::PortCfg &amp;) STUB_RETVAL(false)
-bool InitClientContext(Security::ContextPointer &amp;, Security::PeerOptions &amp;, long, const char *) STUB_RETVAL(false)
+bool InitClientContext(Security::ContextPointer &amp;, Security::PeerOptions &amp;, const char *) STUB_RETVAL(false)
 } // namespace Ssl
 const char *sslGetUserEmail(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
----++++GitHub