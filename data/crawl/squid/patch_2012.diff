@@ -1,3 +1,10 @@
+
+Changes to squid-1.1.alpha2:
+
+	- Added Support for RFC931/ident
+
+==============================================================================
+
 Changes to squid-1.0.beta1 (Apr 19, 1996) from Harvest cached-1.4.pl3:
 
 	- Added a "server mode" to ftpget.  Now the (much smaller)
@@ -121,7 +128,22 @@ Changes to squid-1.0.beta5:
 	- Fixed cachemgr to send 'HTTP/1.0' on request so it works
 	  with beta4 fixes to icp.c.
 
+Changes to squid-1.0.beta6:
 
-Changes to squid-1.1.alpha2:
-
-	- Support for RFC931/ident
+	- Fixed null error message coredump in ftpget.
+	- Added -m Method option to `client'.
+	- Fixed ftpget server bug with missing trailing slash.
+	- Removed 'connect_ports' from config, use general ACLs instead.
+	- Changed requested listen queue length to 1/4 of getMaxFD().
+	- Rewrote SSL/CONNECT handlers.  Now doesn't use a StoreEntry.
+	- Fixed some aborted objects getting stuck in VM bug.
+	- Fixed ftpget PASV reply sscanf to work for VMS ftpd.
+	- Changed FTP URL parsing to use urlParse().
+	- Changed ftpget to skip RETR command if URLs ends with '/'.
+	- Changed ftpget to display README at the bottom if there are other
+	  server messages.
+	- Changed ftpget to not reopen a new data connection
+  	  if one is already open.
+	- Fixed handling of FTP URLs with spaces (and other unsafe characters)
+	- Changed ftpget to only generate BASE HREF if the FTP URL does
+	  not end with '/'.
@@ -517,7 +517,7 @@ fi
 
 
 
-# From configure.in Revision: 1.18.2.3 
+# From configure.in Revision: 1.19 
 ac_aux_dir=
 for ac_dir in aux $srcdir/aux; do
   if test -f $ac_dir/install-sh; then
@@ -565,25 +565,15 @@ host_os=`echo $host | sed 's/^\(.*\)-\(.*\)-\(.*\)$/\3/'`
 echo "$ac_t""$host" 1>&6
 
 
-
-if test -n "$prefix"; then
-  myprefix="$prefix";
-else
-  myprefix="$ac_default_prefix"
-fi
-
-INSTALL_TOPDIR="$myprefix";
-INSTALL_LIBDIR="$myprefix/lib";
-INSTALL_BINDIR="$myprefix/bin";
-INSTALL_MANDIR="$myprefix/man";
-
-eval "sysconfdirval=$sysconfdir"
-eval "bindirval=$bindir"
-
-THIS_HOST="`hostname`"
 XTRA_CFLAGS=''
 CRYPT_LIB=''
 
+if test "$libexecdir" = '${exec_prefix}/libexec'; then
+	libexecdir='${bindir}'
+	localstatedir='${prefix}'
+
+fi
+
 if test -z "$CACHE_HTTP_PORT"; then
 	CACHE_HTTP_PORT="3128"
 fi
@@ -599,14 +589,6 @@ fi
 
 
 
-
-
-
-
-
-
-
-
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
@@ -712,7 +694,7 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 716 "configure"
+#line 698 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
@@ -726,7 +708,7 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 730 "configure"
+#line 712 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
@@ -985,37 +967,35 @@ fi
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-if eval "test \"`echo '$''{'ac_cv_path_CMD_PERL'+set}'`\" = set"; then
+if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
-  case "$CMD_PERL" in
+  case "$PERL" in
   /*)
-  ac_cv_path_CMD_PERL="$CMD_PERL" # Let the user override the test with a path.
+  ac_cv_path_PERL="$PERL" # Let the user override the test with a path.
   ;;
   *)
   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
   for ac_dir in $PATH; do
     test -z "$ac_dir" && ac_dir=.
     if test -f $ac_dir/$ac_word; then
-      ac_cv_path_CMD_PERL="$ac_dir/$ac_word"
+      ac_cv_path_PERL="$ac_dir/$ac_word"
       break
     fi
   done
   IFS="$ac_save_ifs"
-  test -z "$ac_cv_path_CMD_PERL" && ac_cv_path_CMD_PERL="/usr/local/bin/perl"
+  test -z "$ac_cv_path_PERL" && ac_cv_path_PERL="/usr/local/bin/perl"
   ;;
 esac
 fi
-CMD_PERL="$ac_cv_path_CMD_PERL"
-if test -n "$CMD_PERL"; then
-  echo "$ac_t""$CMD_PERL" 1>&6
+PERL="$ac_cv_path_PERL"
+if test -n "$PERL"; then
+  echo "$ac_t""$PERL" 1>&6
 else
   echo "$ac_t""no" 1>&6
 fi
 
 
-PERL="$CMD_PERL"
-
 
 ac_header_dirent=no
 for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
@@ -1026,7 +1006,7 @@ if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1030 "configure"
+#line 1010 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
@@ -1066,7 +1046,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1070 "configure"
+#line 1050 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1101,7 +1081,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1105 "configure"
+#line 1085 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1138,7 +1118,7 @@ else
   ac_cv_c_cross=yes
 else
 cat > conftest.$ac_ext <<EOF
-#line 1142 "configure"
+#line 1122 "configure"
 #include "confdefs.h"
 main(){return(0);}
 EOF
@@ -1160,7 +1140,7 @@ if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1164 "configure"
+#line 1144 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
@@ -1182,7 +1162,7 @@ rm -f conftest*
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 1186 "configure"
+#line 1166 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -1200,7 +1180,7 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 1204 "configure"
+#line 1184 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -1221,7 +1201,7 @@ if test "$cross_compiling" = yes; then
   :
 else
 cat > conftest.$ac_ext <<EOF
-#line 1225 "configure"
+#line 1205 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -1281,7 +1261,7 @@ if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1285 "configure"
+#line 1265 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
@@ -1312,7 +1292,7 @@ done
 
 echo $ac_n "checking for tm->tm_gmtoff""... $ac_c" 1>&6
 cat > conftest.$ac_ext <<EOF
-#line 1316 "configure"
+#line 1296 "configure"
 #include "confdefs.h"
 #include <time.h>
 #include <sys/time.h>
@@ -1338,7 +1318,7 @@ rm -f conftest*
 
 echo $ac_n "checking for extended mallinfo""... $ac_c" 1>&6
 cat > conftest.$ac_ext <<EOF
-#line 1342 "configure"
+#line 1322 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <malloc.h>
@@ -1371,7 +1351,7 @@ EOF
 echo "$ac_t""yes" 1>&6
 else
 cat > conftest.$ac_ext <<EOF
-#line 1375 "configure"
+#line 1355 "configure"
 #include "confdefs.h"
 void handle(s) int s; { return; }
 main(){signal(15,handle);kill(getpid(),15);kill(getpid(),15);exit(0);}
@@ -1397,7 +1377,7 @@ else
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
 cat > conftest.$ac_ext <<EOF
-#line 1401 "configure"
+#line 1381 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -1431,7 +1411,7 @@ else
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
 cat > conftest.$ac_ext <<EOF
-#line 1435 "configure"
+#line 1415 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -1465,7 +1445,7 @@ if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1469 "configure"
+#line 1449 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() { return 0; }
@@ -1497,7 +1477,7 @@ if eval "test \"`echo '$''{'ac_cv_func_alloca'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1501 "configure"
+#line 1481 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -1556,7 +1536,7 @@ if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1560 "configure"
+#line 1540 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -1585,7 +1565,7 @@ if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1589 "configure"
+#line 1569 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -1639,7 +1619,7 @@ else
   ac_cv_c_stack_direction=0
 else
 cat > conftest.$ac_ext <<EOF
-#line 1643 "configure"
+#line 1623 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -1684,7 +1664,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1688 "configure"
+#line 1668 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1724,7 +1704,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1728 "configure"
+#line 1708 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1758,7 +1738,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1762 "configure"
+#line 1742 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1798,7 +1778,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1802 "configure"
+#line 1782 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1838,7 +1818,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lbsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1842 "configure"
+#line 1822 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1879,7 +1859,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-l44bsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1883 "configure"
+#line 1863 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1913,7 +1893,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1917 "configure"
+#line 1897 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1948,7 +1928,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1952 "configure"
+#line 1932 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -2012,7 +1992,7 @@ if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2016 "configure"
+#line 1996 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -2062,7 +2042,7 @@ if test "$cross_compiling" = yes; then
   SQUID_FD_SETSIZE=256
 else
 cat > conftest.$ac_ext <<EOF
-#line 2066 "configure"
+#line 2046 "configure"
 #include "confdefs.h"
 
 #include <unistd.h>
@@ -2274,7 +2254,7 @@ trap 'rm -fr `echo "\
 	./scripts/RunCache \
 	./scripts/RunAccel \
 	./src/Makefile \
-	./src/squid.conf \
+	./src/squid.conf.pre \
  include/autoconf.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
@@ -2310,17 +2290,10 @@ s%@host_alias@%$host_alias%g
 s%@host_cpu@%$host_cpu%g
 s%@host_vendor@%$host_vendor%g
 s%@host_os@%$host_os%g
-s%@INSTALL_TOPDIR@%$INSTALL_TOPDIR%g
-s%@INSTALL_LIBDIR@%$INSTALL_LIBDIR%g
-s%@INSTALL_BINDIR@%$INSTALL_BINDIR%g
-s%@INSTALL_MANDIR@%$INSTALL_MANDIR%g
 s%@XTRA_CFLAGS@%$XTRA_CFLAGS%g
-s%@THIS_HOST@%$THIS_HOST%g
 s%@CACHE_HTTP_PORT@%$CACHE_HTTP_PORT%g
 s%@CACHE_ICP_PORT@%$CACHE_ICP_PORT%g
 s%@CACHE_FTP_PORT@%$CACHE_FTP_PORT%g
-s%@sysconfdirval@%$sysconfdirval%g
-s%@bindirval@%$bindirval%g
 s%@CC@%$CC%g
 s%@CPP@%$CPP%g
 s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
@@ -2331,7 +2304,6 @@ s%@RM@%$RM%g
 s%@MV@%$MV%g
 s%@MKDIR@%$MKDIR%g
 s%@LN@%$LN%g
-s%@CMD_PERL@%$CMD_PERL%g
 s%@PERL@%$PERL%g
 s%@ALLOCA@%$ALLOCA%g
 s%@CRYPT_LIB@%$CRYPT_LIB%g
@@ -2352,7 +2324,7 @@ CONFIG_FILES=\${CONFIG_FILES-"\
 	./scripts/RunCache \
 	./scripts/RunAccel \
 	./src/Makefile \
-	./src/squid.conf \
+	./src/squid.conf.pre \
 "}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
@@ -1,40 +1,30 @@
 dnl
 dnl  Configuration input file for Squid
 dnl
-dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.7)
+dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.19 1996/05/01 22:36:19 wessels Exp $
+dnl  $Id: configure.in,v 1.20 1996/05/03 22:56:16 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.19 $)dnl
+AC_REVISION($Revision: 1.20 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(aux)
 
 AC_CANONICAL_HOST
 
-dnl Build a copy of prefix
-
-if test -n "$prefix"; then
-  myprefix="$prefix";
-else
-  myprefix="$ac_default_prefix"
-fi
-
-INSTALL_TOPDIR="$myprefix";
-INSTALL_LIBDIR="$myprefix/lib";
-INSTALL_BINDIR="$myprefix/bin";
-INSTALL_MANDIR="$myprefix/man";
-
-eval "sysconfdirval=$sysconfdir"
-eval "bindirval=$bindir"
-
-THIS_HOST="`hostname`"
 XTRA_CFLAGS=''
 CRYPT_LIB=''
 
+dnl use directory structure of cached as default (hack)
+if test "$libexecdir" = '${exec_prefix}/libexec'; then
+	libexecdir='${bindir}'
+	localstatedir='${prefix}'
+
+fi
+
 if test -z "$CACHE_HTTP_PORT"; then
 	CACHE_HTTP_PORT="3128"
 fi
@@ -46,18 +36,10 @@ if test -z "$CACHE_FTP_PORT"; then
 fi
 
 dnl Subsitutions
-AC_SUBST(INSTALL_TOPDIR)
-AC_SUBST(INSTALL_LIBDIR)
-AC_SUBST(INSTALL_BINDIR)
-AC_SUBST(INSTALL_MANDIR)
-AC_SUBST(DEFS)
 AC_SUBST(XTRA_CFLAGS)
-AC_SUBST(THIS_HOST)
 AC_SUBST(CACHE_HTTP_PORT)
 AC_SUBST(CACHE_ICP_PORT)
 AC_SUBST(CACHE_FTP_PORT)
-AC_SUBST(sysconfdirval)
-AC_SUBST(bindirval)
 
 dnl Check for GNU cc
 AC_PROG_CC
@@ -86,11 +68,8 @@ AC_PATH_PROG(RM, rm, /bin/false)
 AC_PATH_PROG(MV, mv, /bin/false)
 AC_PATH_PROG(MKDIR, mkdir, /bin/false)
 AC_PATH_PROG(LN, ln, cp)
-AC_PATH_PROG(CMD_PERL, perl, /usr/local/bin/perl)
+AC_PATH_PROG(PERL, perl, /usr/local/bin/perl)
 
-dnl Set PERL too
-PERL="$CMD_PERL"
-AC_SUBST(PERL)
 
 dnl Check for headers
 AC_HEADER_DIRENT
@@ -327,5 +306,5 @@ AC_OUTPUT(\
 	./scripts/RunCache \
 	./scripts/RunAccel \
 	./src/Makefile \
-	./src/squid.conf \
+	./src/squid.conf.pre \
 )
@@ -1,10 +1,12 @@
-/* $Id: util.c,v 1.6 1996/04/15 04:23:42 wessels Exp $ */
+/* $Id: util.c,v 1.7 1996/05/03 22:56:18 wessels Exp $ */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#ifndef _SQUID_FREEBSD_		/* "Obsolete" Markus Stumpf <maex@Space.NET> */
 #include <malloc.h>
+#endif
 #include <errno.h>
 
 void (*failure_notify) () = NULL;
@@ -21,9 +21,9 @@ LN_S		= @LN_S@
 all: 
 
 install:	
-	@if test ! -d $(prefix); then \
-		echo "mkdir $(prefix)"; \
-		mkdir $(prefix); \
+	@if test ! -d $(exec_prefix); then \
+		echo "mkdir $(exec_prefix)"; \
+		mkdir $(exec_prefix); \
 	fi
 	@if test ! -d $(bindir); then \
 		echo "mkdir $(bindir)"; \
@@ -1,20 +1,22 @@
 #!/bin/sh
 #
-#  $Id: RunAccel.in,v 1.2 1996/04/16 16:37:53 wessels Exp $
+#  $Id: RunAccel.in,v 1.3 1996/05/03 22:56:19 wessels Exp $
 
 # enable HTTP requests on port 80
-set port="-a 80"
+port="-a 80"
 
-PATH=@prefix@/bin:/bin
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+PATH=@bindir@:/bin
 export PATH
 
-if test $#argv = 1 ; then
+if test $# = 1 ; then
 	conf="-f $1"
-	shift;
+	shift
 fi
 
 failcount=0
-while test 1 ; do
+while : ; do
 	echo "Running: squid $port -s $conf >> squid.out 2>&1"
 	start=`date '+%d%H%M%S'`
 	squid $port -s $conf >> squid.out 2>&1
@@ -26,7 +28,7 @@ while test 1 ; do
 		failcount=0
 	fi
 	if test $failcount -gt 5 ; then
-		echo "RunCache: EXITING DUE TO REPEATED, FREQUENT FAILURES"
+              echo "RunCache: EXITING DUE TO REPEATED, FREQUENT FAILURES" >&2
 		exit 1
 	fi
 	sleep 10
@@ -1,18 +1,20 @@
 #!/bin/sh
 #
-#  $Id: RunCache.in,v 1.4 1996/05/01 22:36:22 wessels Exp $
+#  $Id: RunCache.in,v 1.5 1996/05/03 22:56:19 wessels Exp $
 
-PATH=@prefix@/bin:/bin
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+PATH=@bindir@:/bin
 export PATH
 
 conf=""
 if test "$1" ; then
 	conf="-f $1"
-	shift;
+	shift
 fi
 
 failcount=0
-while test 1 ; do
+while : ; do
 	echo "Running: squid -s $conf >> squid.out 2>&1"
 	start=`date '+%d%H%M%S'`
 	squid -s $conf >> squid.out 2>&1
@@ -24,7 +26,7 @@ while test 1 ; do
 		failcount=0
 	fi
 	if test $failcount -gt 5 ; then
-		echo "RunCache: EXITING DUE TO REPEATED, FREQUENT FAILURES"
+              echo "RunCache: EXITING DUE TO REPEATED, FREQUENT FAILURES" >&2
 		exit 1
 	fi
 	sleep 10
@@ -1,29 +1,39 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.24 1996/05/01 22:38:55 wessels Exp $
+#  $Id: Makefile.in,v 1.25 1996/05/03 22:56:20 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
-LOG_OPT		= # -DNO_LOGGGING
 HOST_OPT	= # -DCACHEMGR_HOSTNAME="getfullhostname()"
-DEFINES		= $(LOG_OPT) $(HOST_OPT)
+DEFINES         = $(HOST_OPT)
 
 prefix		= @prefix@
 exec_prefix	= @exec_prefix@
 top_srcdir	= @top_srcdir@
 bindir		= @bindir@
+libexecdir      = @libexecdir@
 sysconfdir	= @sysconfdir@
+localstatedir   = @localstatedir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
+DEFAULT_CONFIG_FILE     = $(sysconfdir)/squid.conf
+DEFAULT_FTPGET          = $(libexecdir)/ftpget
+DEFAULT_DNSSERVER       = $(libexecdir)/dnsserver
+DEFAULT_CACHE_LOG       = $(localstatedir)/logs/cache.log
+DEFAULT_ACCESS_LOG      = $(localstatedir)/logs/access.log
+DEFAULT_HIERARCHY_LOG   = $(localstatedir)/logs/hierarchy.log
+DEFAULT_STORE_LOG       = $(localstatedir)/logs/store.log
+DEFAULT_SWAP_DIR        = $(localstatedir)/cache
+
 CC		= @CC@
 INSTALL		= @INSTALL@
 INSTALL_BIN 	= @INSTALL_PROGRAM@
 INSTALL_FILE 	= @INSTALL_DATA@
 RANLIB		= @RANLIB@
 LN_S		= @LN_S@
-PERL		= @CMD_PERL@
+PERL            = @PERL@
 CRYPT_LIB	= @CRYPT_LIB@
 STD_CFLAGS	= @STD_CFLAGS@
 STD_LDFLAGS	= @STD_LDFLAGS@
@@ -39,29 +49,29 @@ LDFLAGS         = $(STD_LDFLAGS)
 LIBS		= -L../lib -lregex -lutil $(XTRA_LIBS)
 CLIENT_LIBS	= -L../lib -lutil $(XTRA_LIBS)
 
-PROGS		= squid 
-UTILS		= client dnsserver ftpget
+PROGS           = squid client
+UTILS           = dnsserver ftpget
 CGIPROGS	= cachemgr.cgi
 OBJS	 	= acl.o background.o cache_cf.o errorpage.o comm.o \
-		connect.o debug.o disk.o dynamic_array.o \
+		debug.o disk.o dynamic_array.o \
 		fdstat.o filemap.o ftp.o gopher.o \
 		hash.o http.o icp.o ident.o ipcache.o \
 		main.o mime.o neighbors.o objcache.o \
-		proto.o send-announce.o stack.o stat.o stmem.o \
+		proto.o send-announce.o ssl.o stack.o stat.o stmem.o \
 		store.o storetoString.o tools.o ttl.o \
 		url.o wais.o $(XTRA_OBJS)
 
 DEFAULTS        = \
-	-DDEFAULT_CONFIG_FILE=\"$(sysconfdir)/squid.conf\" \
-	-DDEFAULT_FTPGET=\"$(bindir)/ftpget\" \
-	-DDEFAULT_DNSSERVER=\"$(bindir)/dnsserver\" \
-	-DDEFAULT_CACHE_LOG=\"$(prefix)/logs/cache.log\" \
-	-DDEFAULT_ACCESS_LOG=\"$(prefix)/logs/access.log\" \
-	-DDEFAULT_HIERARCHY_LOG=\"$(prefix)/logs/hierarchy.log\" \
-	-DDEFAULT_STORE_LOG=\"$(prefix)/logs/store.log\" \
-	-DDEFAULT_SWAP_DIR=\"$(prefix)/cache\"
+	-DDEFAULT_CONFIG_FILE=\"$(DEFAULT_CONFIG_FILE)\" \
+	-DDEFAULT_FTPGET=\"$(DEFAULT_FTPGET)\" \
+	-DDEFAULT_DNSSERVER=\"$(DEFAULT_DNSSERVER)\" \
+	-DDEFAULT_CACHE_LOG=\"$(DEFAULT_CACHE_LOG)\" \
+	-DDEFAULT_ACCESS_LOG=\"$(DEFAULT_ACCESS_LOG)\" \
+	-DDEFAULT_HIERARCHY_LOG=\"$(DEFAULT_HIERARCHY_LOG)\" \
+	-DDEFAULT_STORE_LOG=\"$(DEFAULT_STORE_LOG)\" \
+	-DDEFAULT_SWAP_DIR=\"$(DEFAULT_SWAP_DIR)\"
 
-all:	$(PROGS) $(UTILS) $(CGIPROGS)
+all:    squid.conf $(PROGS) $(UTILS) $(CGIPROGS)
 
 squid:	$(OBJS)
 	$(CC) -o $@ $(LDFLAGS) $(OBJS) $(CRYPT_LIB) $(LIBS)
@@ -81,6 +91,17 @@ cachemgr.cgi:	cachemgr.o
 ftpget: ftpget.o
 	$(CC) -o $@ $(LDFLAGS) ftpget.o $(LIBS)
 
+squid.conf: squid.conf.pre
+	sed "\
+	s%@DEFAULT_CONFIG_FILE@%$(DEFAULT_CONFIG_FILE)%g;\
+	s%@DEFAULT_FTPGET@%$(DEFAULT_FTPGET)%g;\
+	s%@DEFAULT_DNSSERVER@%$(DEFAULT_DNSSERVER)%g;\
+	s%@DEFAULT_CACHE_LOG@%$(DEFAULT_CACHE_LOG)%g;\
+	s%@DEFAULT_ACCESS_LOG@%$(DEFAULT_ACCESS_LOG)%g;\
+	s%@DEFAULT_HIERARCHY_LOG@%$(DEFAULT_HIERARCHY_LOG)%g;\
+	s%@DEFAULT_STORE_LOG@%$(DEFAULT_STORE_LOG)%g;\
+	s%@DEFAULT_SWAP_DIR@%$(DEFAULT_SWAP_DIR)%g" <$? >$@
+
 install-mkdirs:
 	@if test ! -d $(prefix); then \
 		echo "mkdir $(prefix)"; \
@@ -94,13 +115,21 @@ install-mkdirs:
 		echo "mkdir $(bindir)"; \
 		mkdir $(bindir); \
 	fi
+	@if test ! -d $(libexecdir); then \
+		echo "mkdir $(libexecdir)"; \
+		mkdir $(libexecdir); \
+	fi
 	@if test ! -d $(sysconfdir); then \
 		echo "mkdir $(sysconfdir)"; \
 		mkdir $(sysconfdir); \
 	fi
-	@if test ! -d $(exec_prefix)/logs; then \
-		echo "mkdir $(exec_prefix)/logs"; \
-		mkdir $(exec_prefix)/logs; \
+	@if test ! -d $(localstatedir); then \
+		echo "mkdir $(localstatedir)"; \
+		mkdir $(localstatedir); \
+	fi
+	@if test ! -d $(localstatedir)/logs; then \
+		echo "mkdir $(localstatedir)/logs"; \
+		mkdir $(localstatedir)/logs; \
 	fi
 
 install: all install-mkdirs
@@ -109,12 +138,12 @@ install: all install-mkdirs
 		$(INSTALL_BIN) $$f $(bindir); \
 	done
 	@for f in $(UTILS); do \
-		echo $(INSTALL_BIN) $$f $(bindir); \
-		$(INSTALL_BIN) $$f $(bindir); \
+		echo $(INSTALL_BIN) $$f $(libexecdir); \
+		$(INSTALL_BIN) $$f $(libexecdir); \
 	done
 	@for f in $(CGIPROGS); do \
-		echo $(INSTALL_BIN) $$f $(bindir); \
-		$(INSTALL_BIN) $$f $(bindir); \
+		echo $(INSTALL_BIN) $$f $(libexecdir); \
+		$(INSTALL_BIN) $$f $(libexecdir); \
 	done
 	$(INSTALL_FILE) squid.conf $(sysconfdir)/squid.conf.default
 	@if test -f $(sysconfdir)/squid.conf ; then \
@@ -128,4 +157,4 @@ clean:
 	-rm -rf *.o *pure_* core $(PROGS) $(UTILS) $(CGIPROGS)
 
 realclean:	clean
-	-rm -f Makefile squid.conf
+	-rm -f Makefile squid.conf squid.conf.pre
@@ -1,4 +1,4 @@
-/* "$Id: acl.cc,v 1.13 1996/05/01 22:36:23 wessels Exp $" */
+/* "$Id: acl.cc,v 1.14 1996/05/03 22:56:21 wessels Exp $" */
 
 /*
  * DEBUG: Section 28          acl
@@ -329,6 +329,7 @@ void aclParseAclLine()
 	debug(28, 0, "aclParseAclLine: Invalid ACL type '%s'\n", t);
 	xfree(A);
 	return;
+	/* NOTREACHED */
 	break;
     }
     A->cfgline = xstrdup(config_input_line);
@@ -500,29 +501,36 @@ static int aclMatchAcl(acl, c, m, pr, h, po, r)
     switch (acl->type) {
     case ACL_SRC_IP:
 	return aclMatchIp(acl->data, c);
+	/* NOTREACHED */
 	break;
     case ACL_DST_DOMAIN:
 	return aclMatchWord(acl->data, h);
+	/* NOTREACHED */
 	break;
     case ACL_TIME:
 	return aclMatchTime(acl->data, squid_curtime);
-	return 0;
+	/* NOTREACHED */
 	break;
     case ACL_URL_REGEX:
 	return aclMatchRegex(acl->data, r);
+	/* NOTREACHED */
 	break;
     case ACL_URL_PORT:
 	return aclMatchInteger(acl->data, po);
+	/* NOTREACHED */
 	break;
     case ACL_USER:
 	debug(28, 0, "aclMatchAcl: ACL_USER unimplemented\n");
 	return 0;
+	/* NOTREACHED */
 	break;
     case ACL_PROTO:
 	return aclMatchInteger(acl->data, pr);
+	/* NOTREACHED */
 	break;
     case ACL_METHOD:
 	return aclMatchInteger(acl->data, m);
+	/* NOTREACHED */
 	break;
     case ACL_NONE:
     default:
@@ -1,4 +1,4 @@
-/* $Id: cache_cf.cc,v 1.54 1996/05/01 22:36:24 wessels Exp $ */
+/* $Id: cache_cf.cc,v 1.55 1996/05/03 22:56:21 wessels Exp $ */
 
 /* DEBUG: Section 3             cache_cf: Configuration file parsing */
 
@@ -892,14 +892,47 @@ static void parseBindAddressLine()
     wordlistAdd(&Config.bind_addr_list, token);
 }
 
+static void parseLocalDomainFile(fname)
+     char *fname;
+{
+    char tmp_line[BUFSIZ];
+    FILE *fp = NULL;
+    char *t = NULL;
+
+    if ((fp = fopen(fname, "r")) == NULL) {
+	debug(3, 1, "parseLocalDomainFile: %s: %s\n", fname, xstrerror());
+	return;
+    }
+    memset(tmp_line, '\0', BUFSIZ);
+    while (fgets(tmp_line, BUFSIZ, fp)) {
+	if (tmp_line[0] == '#')
+	    continue;
+	if (tmp_line[0] == '\0')
+	    continue;
+	if (tmp_line[0] == '\n')
+	    continue;
+	for (t = strtok(tmp_line, w_space); t; t = strtok(NULL, w_space)) {
+	    debug(3, 1, "parseLocalDomainFileLine: adding %s\n", t);
+	    wordlistAdd(&Config.local_domain_list, t);
+	}
+    }
+    fclose(fp);
+}
+
 static void parseLocalDomainLine()
 {
-    char *token;
+    char *token = NULL;
+    struct stat sb;
     while ((token = strtok(NULL, w_space))) {
-	wordlistAdd(&Config.local_domain_list, token);
+	if (stat(token, &sb) < 0) {
+	    wordlistAdd(&Config.local_domain_list, token);
+	} else {
+	    parseLocalDomainFile(token);
+	}
     }
 }
 
+
 static void parseInsideFirewallLine()
 {
     char *token;
@@ -1628,6 +1661,7 @@ static void configFreeMemory()
     safe_free(Config.Log.log);
     safe_free(Config.Log.access);
     safe_free(Config.Log.hierarchy);
+    safe_free(Config.Log.store);
     safe_free(Config.adminEmail);
     safe_free(Config.effectiveUser);
     safe_free(Config.effectiveGroup);
@@ -1,7 +1,8 @@
-/* $Id: cachemgr.cc,v 1.8 1996/05/01 22:36:25 wessels Exp $ */
+/* $Id: cachemgr.cc,v 1.9 1996/05/03 22:56:22 wessels Exp $ */
 
 #include "config.h"
 #include "autoconf.h"
+#include "version.h"
 
 #include <unistd.h>
 #include <stdlib.h>
@@ -11,7 +12,9 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <grp.h>
+#ifndef _SQUID_FREEBSD_		/* "Obsolete" Markus Stumpf <maex@Space.NET> */
 #include <malloc.h>
+#endif
 #include <memory.h>
 #include <netdb.h>
 #include <pwd.h>
@@ -51,8 +54,13 @@
 
 #define MAX_ENTRIES 10000
 
+#ifndef FALSE
 #define FALSE 0
+#endif
+#ifndef TRUE
 #define TRUE !FALSE
+#endif
+
 #define LF 10
 #define CR 13
 
@@ -196,7 +204,7 @@ char *fmakeword(FILE * f, char stop, int *cl)
     ll = 0;
     word = (char *) malloc(sizeof(char) * (wsize + 1));
 
-    while (1) {
+    for (;;) {
 	word[ll] = (char) fgetc(f);
 	if (ll == wsize) {
 	    word[ll + 1] = '\0';
@@ -348,7 +356,7 @@ int main(int argc, char *argv[])
     int len;
     int bytesWritten;
     int portnum = CACHE_HTTP_PORT;
-    int op;
+    int op = 0;
     int p_state;
     int n_loops;
     int cpy_ind;
@@ -670,6 +678,7 @@ int main(int argc, char *argv[])
     (void) close(conn);
     exit(0);
     /* NOTREACHED */
+    return 0;
 }
 
 static int client_comm_connect(sock, dest_host, dest_port)
@@ -1,5 +1,5 @@
 
-/* $Id: client.cc,v 1.5 1996/05/01 22:36:25 wessels Exp $ */
+/* $Id: client.cc,v 1.6 1996/05/03 22:56:22 wessels Exp $ */
 
 #include "squid.h"
 
@@ -128,6 +128,7 @@ int main(argc, argv)
     (void) close(conn);		/* done with socket */
     exit(0);
     /*NOTREACHED */
+    return 0;
 }
 
 static int client_comm_connect(sock, dest_host, dest_port)
@@ -1,5 +1,5 @@
 
-/* $Id: comm.cc,v 1.31 1996/05/01 22:36:26 wessels Exp $ */
+/* $Id: comm.cc,v 1.32 1996/05/03 22:56:23 wessels Exp $ */
 
 /* DEBUG: Section 5             comm: socket level functions */
 
@@ -168,7 +168,7 @@ int comm_open(io_type, port, handler, note)
 }
 
    /*
-    * NOTE: set the listen queue to 50 and rely on the kernel to      
+    * NOTE: set the listen queue to getMaxFD()/4 and rely on the kernel to      
     * impose an upper limit.  Solaris' listen(3n) page says it has   
     * no limit on this parameter, but sys/socket.h sets SOMAXCONN 
     * to 5.  HP-UX currently has a limit of 20.  SunOS is 5 and
@@ -178,8 +178,9 @@ int comm_listen(sock)
      int sock;
 {
     int x;
-    if ((x = listen(sock, 50)) < 0) {
-	debug(5, 0, "comm_listen: listen(%d, 50): %s\n",
+    if ((x = listen(sock, getMaxFD() >> 2)) < 0) {
+	debug(5, 0, "comm_listen: listen(%d, %d): %s\n",
+	    getMaxFD() >> 2,
 	    sock, xstrerror());
 	return x;
     }
@@ -364,7 +365,7 @@ int comm_close(fd)
     conn = &fd_table[fd];
 
     comm_set_fd_lifetime(fd, -1);	/* invalidate the lifetime */
-    debug(5, 10, "comm_close: FD %d\n", fd);
+    debug(5, 5, "comm_close: FD %d\n", fd);
     /* update fdstat */
     fdstat_close(fd);
     if (conn->close_handler)
@@ -569,7 +570,7 @@ int comm_select(sec, failtime)
 	    FD_CLR(theAsciiConnection, &readfds);
 	}
 	if (shutdown_pending || reread_pending)
-	    debug(5, 1, "comm_select: Still waiting on %d FDs\n", nfds);
+	    debug(5, 2, "comm_select: Still waiting on %d FDs\n", nfds);
 	if (nfds == 0)
 	    return COMM_SHUTDOWN;
 	while (1) {
@@ -1,4 +1,4 @@
-/* $Id: dnsserver.cc,v 1.5 1996/04/16 05:05:20 wessels Exp $ */
+/* $Id: dnsserver.cc,v 1.6 1996/05/03 22:56:24 wessels Exp $ */
 
 #include "squid.h"
 
@@ -199,4 +199,5 @@ int main(argc, argv)
 
     exit(0);
     /*NOTREACHED */
+    return 0;
 }
@@ -1,4 +1,4 @@
-/* $Id: ftp.cc,v 1.38 1996/05/01 22:36:29 wessels Exp $ */
+/* $Id: ftp.cc,v 1.39 1996/05/03 22:56:25 wessels Exp $ */
 
 /*
  * DEBUG: Section 9           ftp: FTP
@@ -18,11 +18,9 @@ static int ftpget_server_pipe = -1;
 
 typedef struct _Ftpdata {
     StoreEntry *entry;
-    char host[SQUIDHOSTNAMELEN + 1];
-    char request[MAX_URL];
+    request_t *request;
     char user[MAX_URL];
     char password[MAX_URL];
-    int port;
     char *reply_hdr;
     int ftp_fd;
     char *icp_page_ptr;		/* Used to send proxy-http request: 
@@ -35,6 +33,21 @@ typedef struct _Ftpdata {
     int reply_hdr_state;
 } FtpData;
 
+
+/* Local functions */
+static int ftpStateFree _PARAMS((int fd, FtpData * ftpState));
+static void ftpProcessReplyHeader _PARAMS((FtpData * data, char *buf, int size));
+static void ftpServerClosed _PARAMS((int fd, void *nodata));
+static void ftp_login_parser _PARAMS((char *login, FtpData * data));
+
+/* Global functions not declared in ftp.h */
+void ftpLifetimeExpire _PARAMS((int fd, FtpData * data));
+int ftpReadReply _PARAMS((int fd, FtpData * data));
+void ftpSendComplete _PARAMS((int fd, char *buf, int size, int errflag, FtpData * data));
+void ftpSendRequest _PARAMS((int fd, FtpData * data));
+void ftpConnInProgress _PARAMS((int fd, FtpData * data));
+void ftpServerClose _PARAMS((void));
+
 static int ftpStateFree(fd, ftpState)
      int fd;
      FtpData *ftpState;
@@ -55,69 +68,27 @@ static int ftpStateFree(fd, ftpState)
     return 0;
 }
 
-int ftp_url_parser(url, data)
-     char *url;
+static void ftp_login_parser(login, data)
+     char *login;
      FtpData *data;
 {
-    static char proto[MAX_URL];
-    static char hostbuf[MAX_URL];
-    char *s = NULL;
-    int t;
-    char *host = data->host;
-    char *request = data->request;
     char *user = data->user;
     char *password = data->password;
+    char *s = NULL;
 
-    debug(9, 3, "ftp_url_parser: parsing '%s'\n", url);
-
-    /* initialize everything */
-    proto[0] = hostbuf[0] = '\0';
-
-    t = sscanf(url, "%[a-zA-Z]://%[^/]%s", proto, hostbuf, request);
-    if (t < 2)
-	return -1;
-    if (strcasecmp(proto, "ftp") && strcasecmp(proto, "file"))
-	return -1;
-    if (t == 2)			/* no request */
-	strcpy(request, "/");
-    (void) url_convert_hex(request, 0);		/* convert %xx to char */
-
-    /* hostbuf is of the format  userid:password@host:port  */
-
-    /* separate into user-part and host-part */
-    if ((s = strchr(hostbuf, '@'))) {
-	*s = '\0';
-	strcpy(user, hostbuf);
-	strcpy(hostbuf, s + 1);
-    }
-    /* separate into user and password */
-    if ((s = strchr(user, ':'))) {
-	*s = '\0';
+    strcpy(user, login);
+    s = strchr(user, ':');
+    if (s) {
+	*s = 0;
 	strcpy(password, s + 1);
+    } else {
+	strcpy(password, "");
     }
-    /* separate into host and port */
-    if ((s = strchr(hostbuf, ':'))) {
-	*s = '\0';
-	data->port = atoi(s + 1);
-    }
-    strncpy(host, hostbuf, SQUIDHOSTNAMELEN);
-    if (*user == '\0')
+
+    if (!*user && !*password) {
 	strcpy(user, "anonymous");
-    if (*password == '\0')
 	strcpy(password, getFtpUser());
-
-    /* we need to convert user and password for URL encodings */
-    (void) url_convert_hex(user, 0);
-
-    (void) url_convert_hex(password, 0);
-
-    debug(9, 5, "ftp_url_parser: proto = %s\n", proto);
-    debug(9, 5, "ftp_url_parser:  user = %s\n", data->user);
-    debug(9, 5, "ftp_url_parser:  pass = %s\n", data->password);
-    debug(9, 5, "ftp_url_parser:  host = %s\n", data->host);
-    debug(9, 5, "ftp_url_parser:  port = %d\n", data->port);
-
-    return 0;
+    }
 }
 
 int ftpCachable(url)
@@ -451,12 +422,12 @@ void ftpSendRequest(fd, data)
 
     debug(9, 5, "ftpSendRequest: FD %d\n", fd);
 
-    buflen = strlen(data->request) + 256;
+    buflen = strlen(data->request->urlpath) + 256;
     buf = (char *) get_free_8k_page();
     data->icp_page_ptr = buf;
     memset(buf, '\0', buflen);
 
-    path = data->request;
+    path = data->request->urlpath;
     l = strlen(path);
     if (path[l - 1] == '/')
 	mode = ftpASCII;
@@ -470,13 +441,15 @@ void ftpSendRequest(fd, data)
 	    mode = ftpBinary;
     }
 
+#ifdef NO_NEED_TO_DO_THIS
     /* Remove leading slash from FTP url-path so that we can
      *  handle ftp://user:pw@host/path objects where path and /path
      *  are quite different.         -DW */
     if (!strcmp(path, "/"))
 	*path = '.';
     if (*path == '/')
 	path++;
+#endif
 
     /* Start building the buffer ... */
 
@@ -500,13 +473,13 @@ void ftpSendRequest(fd, data)
 	sprintf(tbuf, "-n %d ", getNegativeTTL());
 	strcat(buf, tbuf);
     }
-    if (data->port) {
-	sprintf(tbuf, "-P %d ", data->port);
+    if (data->request->port) {
+	sprintf(tbuf, "-P %d ", data->request->port);
 	strcat(buf, tbuf);
     }
     strcat(buf, "-h ");		/* httpify */
     strcat(buf, "- ");		/* stdout */
-    strcat(buf, data->host);
+    strcat(buf, data->request->host);
     strcat(buf, space);
     strcat(buf, *path ? path : "\"\"");
     strcat(buf, space);
@@ -533,7 +506,7 @@ void ftpConnInProgress(fd, data)
 
     debug(9, 5, "ftpConnInProgress: FD %d\n", fd);
 
-    if (comm_connect(fd, localhost, CACHE_FTP_PORT) != COMM_OK)
+    if (comm_connect(fd, localhost, CACHE_FTP_PORT) != COMM_OK) {
 	switch (errno) {
 	case EINPROGRESS:
 	case EALREADY:
@@ -543,14 +516,12 @@ void ftpConnInProgress(fd, data)
 		(PF) ftpConnInProgress,
 		(void *) data);
 	    return;
-	case EISCONN:
-	    debug(9, 5, "ftpConnInProgress: FD %d is now connected.", fd);
-	    break;		/* cool, we're connected */
 	default:
 	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    comm_close(fd);
 	    return;
 	}
+    }
     /* Call the real write handler, now that we're fully connected */
     comm_set_select_handler(fd,
 	COMM_SELECT_WRITE,
@@ -559,9 +530,10 @@ void ftpConnInProgress(fd, data)
 }
 
 
-int ftpStart(unusedfd, url, entry)
+int ftpStart(unusedfd, url, request, entry)
      int unusedfd;
      char *url;
+     request_t *request;
      StoreEntry *entry;
 {
     FtpData *data = NULL;
@@ -571,15 +543,14 @@ int ftpStart(unusedfd, url, entry)
 
     data = (FtpData *) xcalloc(1, sizeof(FtpData));
     data->entry = entry;
+    data->request = request;
 
-    /* Parse url. */
-    if (ftp_url_parser(url, data)) {
-	squid_error_entry(entry, ERR_INVALID_URL, NULL);
-	safe_free(data);
-	return COMM_ERROR;
-    }
-    debug(9, 5, "FtpStart: FD %d, host=%s, request=%s, user=%s, passwd=%s\n",
-	unusedfd, data->host, data->request, data->user, data->password);
+    /* Parse login info. */
+    ftp_login_parser(request->login, data);
+
+    debug(9, 5, "FtpStart: FD %d, host=%s, path=%s, user=%s, passwd=%s\n",
+	unusedfd, data->request->host, data->request->urlpath,
+	data->user, data->password);
 
     data->ftp_fd = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (data->ftp_fd == COMM_ERROR) {
@@ -592,7 +563,7 @@ int ftpStart(unusedfd, url, entry)
     /* register close handler */
     comm_set_select_handler(data->ftp_fd,
 	COMM_SELECT_CLOSE,
-	ftpStateFree,
+	(PF) ftpStateFree,
 	(void *) data);
 
     /* Now connect ... */
@@ -1,4 +1,4 @@
-/* $Id: gopher.cc,v 1.29 1996/05/01 22:36:31 wessels Exp $ */
+/* $Id: gopher.cc,v 1.30 1996/05/03 22:56:27 wessels Exp $ */
 
 /*
  * DEBUG: Section 10          gopher: GOPHER
@@ -874,7 +874,7 @@ int gopherStart(unusedfd, url, entry)
     }
     comm_set_select_handler(sock,
 	COMM_SELECT_CLOSE,
-	gopherStateFree,
+	(PF) gopherStateFree,
 	(void *) data);
 
     /* check if IP is already in cache. It must be. 
@@ -1,4 +1,4 @@
-/* $Id: http.cc,v 1.57 1996/05/01 22:36:31 wessels Exp $ */
+/* $Id: http.cc,v 1.58 1996/05/03 22:56:27 wessels Exp $ */
 
 /*
  * DEBUG: Section 11          http: HTTP
@@ -474,7 +474,7 @@ static void httpConnInProgress(fd, data)
     debug(11, 5, "httpConnInProgress: FD %d data=%p\n", fd, data);
 
     if (comm_connect(fd, req->host, req->port) != COMM_OK) {
-	debug(11, 5, "httpConnInProgress: FD %d errno=%d\n", fd, errno);
+	debug(11, 5, "httpConnInProgress: FD %d: %s\n", fd, xstrerror());
 	switch (errno) {
 	case EINPROGRESS:
 	case EALREADY:
@@ -484,8 +484,6 @@ static void httpConnInProgress(fd, data)
 		(PF) httpConnInProgress,
 		(void *) data);
 	    return;
-	case EISCONN:
-	    break;		/* cool, we're connected */
 	default:
 	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    comm_close(fd);
@@ -531,7 +529,7 @@ int proxyhttpStart(e, url, entry)
     /* register the handler to free HTTP state data when the FD closes */
     comm_set_select_handler(sock,
 	COMM_SELECT_CLOSE,
-	httpStateFree,
+	(PF) httpStateFree,
 	(void *) data);
 
     request->method = entry->method;
@@ -602,7 +600,7 @@ int httpStart(unusedfd, url, request, req_hdr, entry)
     data->request = request;
     comm_set_select_handler(sock,
 	COMM_SELECT_CLOSE,
-	httpStateFree,
+	(PF) httpStateFree,
 	(void *) data);
 
     /* check if IP is already in cache. It must be. 
@@ -1,4 +1,4 @@
-/* $Id: ipcache.cc,v 1.27 1996/05/01 22:36:33 wessels Exp $ */
+/* $Id: ipcache.cc,v 1.28 1996/05/03 22:56:29 wessels Exp $ */
 
 /*
  * DEBUG: Section 14          ipcache: IP Cache
@@ -831,7 +831,7 @@ int ipcache_parsebuffer(buf, offset, data)
 				    break;
 				}
 				e->entry.h_addr_list[i] = (char *) xcalloc(1, e->entry.h_length);
-				*((unsigned long *) e->entry.h_addr_list[i]) = inet_addr(line_cur->line);
+				*((unsigned long *) (void *) e->entry.h_addr_list[i]) = inet_addr(line_cur->line);
 				line_cur = line_cur->next;
 				i++;
 			    }
@@ -1064,10 +1064,16 @@ void ipcacheOpenServers()
     int i;
     int dnssocket;
     static char fd_note_buf[FD_ASCII_NOTE_SZ];
+    static int NChildrenAlloc = 0;
 
-    /* start up companion process */
-    safe_free(dns_child_table);
+    /* free old structures if present */
+    if (dns_child_table) {
+	for (i = 0; i < NChildrenAlloc; i++)
+	    safe_free(dns_child_table[i]->ip_inbuf);
+	safe_free(dns_child_table);
+    }
     dns_child_table = (dnsserver_entry **) xcalloc(N, sizeof(dnsserver_entry));
+    NChildrenAlloc = N;
     dns_child_alive = 0;
     debug(14, 1, "ipcacheOpenServers: Starting %d 'dns_server' processes\n", N);
     for (i = 0; i < N; i++) {
@@ -1233,7 +1239,7 @@ struct hostent *ipcache_gethostbyname(name)
 	}
 	/* check if it's already a IP address in text form. */
 	if (sscanf(name, "%u.%u.%u.%u", &a1, &a2, &a3, &a4) == 4) {
-	    *((unsigned long *) static_result->h_addr_list[0]) = inet_addr(name);
+	    *((unsigned long *) (void *) static_result->h_addr_list[0]) = inet_addr(name);
 	    strncpy(static_result->h_name, name, MAX_HOST_NAME);
 	    return static_result;
 	} else {
@@ -1,4 +1,4 @@
-/* $Id: main.cc,v 1.45 1996/05/01 22:36:34 wessels Exp $ */
+/* $Id: main.cc,v 1.46 1996/05/03 22:56:29 wessels Exp $ */
 
 /* DEBUG: Section 1             main: startup and main loop */
 
@@ -41,7 +41,7 @@ Usage: %s [-Rsehvz] [-f config-file] [-[apu] port]\n\
                  %s\n\
        -a port	 Specify ASCII port number (default: %d).\n\
        -u port	 Specify UDP port number (default: %d).\n",
-	appname, DEFAULT_CONFIG_FILE, CACHE_HTTP_PORT, CACHE_ICP_PORT);
+	appname, DefaultConfigFile, CACHE_HTTP_PORT, CACHE_ICP_PORT);
     exit(1);
 }
 
@@ -73,7 +73,6 @@ static void mainParseOptions(argc, argv)
 	case 's':
 	    syslog_enable = 0;
 	    break;
-	    break;
 	case 'R':
 	    do_reuse = 0;
 	    break;
@@ -322,7 +321,7 @@ int main(argc, argv)
     /* main loop */
     if (getCleanRate() > 0)
 	next_cleaning = time(NULL) + getCleanRate();
-    while (1) {
+    for (;;) {
 	loop_delay = (time_t) 60;
 	/* maintain cache storage */
 	if (squid_curtime > last_maintain) {
@@ -382,4 +381,5 @@ int main(argc, argv)
     }
     /* NOTREACHED */
     exit(0);
+    return 0;
 }
@@ -1,8 +1,9 @@
 
-/* $Id: squid.h,v 1.20 1996/05/01 22:36:37 wessels Exp $ */
+/* $Id: squid.h,v 1.21 1996/05/03 22:56:31 wessels Exp $ */
 
 #include "config.h"
 #include "autoconf.h"
+#include "version.h"
 
 #if SQUID_FD_SETSIZE > 256
 #define FD_SETSIZE SQUID_FD_SETSIZE
@@ -16,7 +17,9 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <grp.h>
+#ifndef _SQUID_FREEBSD_		/* "Obsolete" Markus Stumpf <maex@Space.NET> */
 #include <malloc.h>
+#endif
 #include <memory.h>
 #include <netdb.h>
 #include <pwd.h>
@@ -73,6 +76,10 @@
 #define SQUIDHOSTNAMELEN MAXHOSTNAMELEN
 #endif
 
+#ifndef BUFSIZ
+#define BUFSIZ  4096		/* make reasonable guess */
+#endif
+
 typedef struct sentry StoreEntry;
 typedef struct mem_hdr *mem_ptr;
 typedef struct _edge edge;
@@ -120,7 +127,7 @@ typedef unsigned long u_num32;
 #include "ftp.h"
 #include "gopher.h"
 #include "wais.h"
-#include "connect.h"
+#include "ssl.h"
 #include "objcache.h"
 #include "send-announce.h"
 #include "acl.h"
@@ -0,0 +1,405 @@
+/*
+ *  $Id: ssl.cc,v 1.2 1996/05/03 22:56:31 wessels Exp $ 
+ *
+ * DEBUG: Section 26                    ssl
+ */
+#include "squid.h"
+
+#define SSL_BUFSIZ (1<<14)
+
+typedef struct {
+    char *url;
+    request_t *request;
+    char *mime_hdr;
+    struct {
+	int fd;
+	int len;
+	int offset;
+	char *buf;
+    } client, server;
+    time_t timeout;
+    int *size_ptr;		/* pointer to size in an icpStateData for logging */
+} SslStateData;
+
+static char conn_established[] = "HTTP/1.0 200 Connection established\r\n\r\n";
+
+static void sslLifetimeExpire _PARAMS((int fd, SslStateData * sslState));
+static void sslReadTimeout _PARAMS((int fd, SslStateData * sslState));
+static void sslReadServer _PARAMS((int fd, SslStateData * sslState));
+static void sslReadClient _PARAMS((int fd, SslStateData * sslState));
+static void sslWriteServer _PARAMS((int fd, SslStateData * sslState));
+static void sslWriteClient _PARAMS((int fd, SslStateData * sslState));
+static void sslConnected _PARAMS((int fd, SslStateData * sslState));
+static void sslConnInProgress _PARAMS((int fd, SslStateData * sslState));
+
+static int sslStateFree(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    debug(26, 3, "sslStateFree: FD %d, sslState=%p\n", fd, sslState);
+    if (sslState == NULL)
+	return 1;
+    if (fd != sslState->server.fd)
+	fatal_dump("sslStateFree: FD mismatch!\n");
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_READ,
+	NULL,
+	NULL);
+    safe_free(sslState->server.buf);
+    safe_free(sslState->client.buf);
+    xfree(sslState->url);
+    memset(sslState, '\0', sizeof(SslStateData));
+    safe_free(sslState);
+    return 0;
+}
+
+/* This will be called when the server lifetime is expired. */
+static void sslLifetimeExpire(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    debug(26, 4, "sslLifeTimeExpire: FD %d: URL '%s'>\n",
+	fd, sslState->url);
+    comm_close(sslState->client.fd);	/* close client first */
+    comm_close(sslState->server.fd);
+}
+
+/* Read from server side and queue it for writing to the client */
+static void sslReadServer(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    len = read(sslState->server.fd, sslState->server.buf, 4096);
+    debug(26, 5, "sslReadServer FD %d, read %d bytes\n", fd, len);
+    if (len < 0) {
+	debug(26, 1, "sslReadServer: FD %d: read failure: %s\n",
+	    sslState->server.fd, xstrerror());
+	if (errno == EAGAIN || errno == EWOULDBLOCK) {
+	    /* reinstall handlers */
+	    /* XXX This may loop forever */
+	    comm_set_select_handler(sslState->server.fd,
+		COMM_SELECT_READ,
+		(PF) sslReadServer,
+		(void *) sslState);
+	    comm_set_select_handler_plus_timeout(sslState->server.fd,
+		COMM_SELECT_TIMEOUT,
+		(PF) sslReadTimeout,
+		(void *) sslState,
+		sslState->timeout);
+	} else {
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	}
+    } else if (len == 0) {
+	/* Connection closed; retrieval done. */
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+    } else {
+	sslState->server.offset = 0;
+	sslState->server.len = len;
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteClient,
+	    (void *) sslState);
+	comm_set_select_handler_plus_timeout(sslState->server.fd,
+	    COMM_SELECT_TIMEOUT,
+	    (PF) sslReadTimeout,
+	    (void *) sslState,
+	    sslState->timeout);
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadServer,
+	    (void *) sslState);
+    }
+}
+
+/* Read from client side and queue it for writing to the server */
+static void sslReadClient(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    len = read(sslState->client.fd, sslState->client.buf, 4096);
+    debug(26, 5, "sslReadClient FD %d, read %d bytes\n",
+	sslState->client.fd, len);
+    if (len < 0) {
+	debug(26, 1, "sslReadClient: FD %d: read failure: %s\n",
+	    fd, xstrerror());
+	if (errno == EAGAIN || errno == EWOULDBLOCK) {
+	    /* reinstall handlers */
+	    /* XXX This may loop forever */
+	    comm_set_select_handler(sslState->client.fd,
+		COMM_SELECT_READ,
+		(PF) sslReadServer,
+		(void *) sslState);
+	    comm_set_select_handler_plus_timeout(sslState->client.fd,
+		COMM_SELECT_TIMEOUT,
+		(PF) sslReadTimeout,
+		(void *) sslState,
+		sslState->timeout);
+	} else {
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	}
+    } else if (len == 0) {
+	/* Connection closed; retrieval done. */
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+    } else {
+	sslState->client.offset = 0;
+	sslState->client.len = len;
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteServer,
+	    (void *) sslState);
+	comm_set_select_handler_plus_timeout(sslState->client.fd, COMM_SELECT_TIMEOUT,
+	    (PF) sslReadTimeout,
+	    (void *) sslState,
+	    sslState->timeout);
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadServer,
+	    (void *) sslState);
+    }
+}
+
+/* Writes data from the client buffer to the server side */
+static void sslWriteServer(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    len = write(sslState->server.fd,
+	sslState->client.buf + sslState->client.offset,
+	sslState->client.len - sslState->client.offset);
+    debug(26, 5, "sslWriteServer FD %d, wrote %d bytes\n", fd, len);
+    if (len < 0) {
+	debug(26, 2, "sslWriteServer: FD %d: write failure: %s.\n",
+	    sslState->server.fd, xstrerror());
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+	return;
+    }
+    if ((sslState->client.offset += len) >= sslState->client.len) {
+	/* Done writing, read more */
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadClient,
+	    (void *) sslState);
+    } else {
+	/* still have more to write */
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteServer,
+	    (void *) sslState);
+    }
+}
+
+/* Writes data from the server buffer to the client side */
+static void sslWriteClient(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    debug(26, 5, "sslWriteClient FD %d len=%d offset=%d\n",
+	fd,
+	sslState->server.len,
+	sslState->server.offset);
+    len = write(sslState->client.fd,
+	sslState->server.buf + sslState->server.offset,
+	sslState->server.len - sslState->server.offset);
+    debug(26, 5, "sslWriteClient FD %d, wrote %d bytes\n", fd, len);
+    if (len < 0) {
+	debug(26, 2, "sslWriteClient: FD %d: write failure: %s.\n",
+	    sslState->client.fd, xstrerror());
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+	return;
+    }
+    if (sslState->size_ptr)
+	*sslState->size_ptr += len;	/* increment total object size */
+    if ((sslState->server.offset += len) >= sslState->server.len) {
+	/* Done writing, read more */
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadServer,
+	    (void *) sslState);
+    } else {
+	/* still have more to write */
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteClient,
+	    (void *) sslState);
+    }
+}
+
+static void sslReadTimeout(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    if (fd != sslState->server.fd)
+	fatal_dump("sslReadTimeout: FD mismatch!\n");
+    debug(26, 3, "sslReadTimeout: FD %d\n", fd);
+    comm_close(sslState->client.fd);
+    comm_close(sslState->server.fd);
+}
+
+static void sslConnected(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    debug(26, 3, "sslConnected: FD %d sslState=%p\n", fd, sslState);
+    strcpy(sslState->server.buf, conn_established);
+    sslState->server.len = strlen(conn_established);
+    sslState->server.offset = 0;
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_WRITE,
+	(PF) sslWriteClient,
+	(void *) sslState);
+    comm_set_fd_lifetime(fd, -1);	/* disable lifetime */
+    comm_set_select_handler_plus_timeout(sslState->server.fd,
+	COMM_SELECT_TIMEOUT,
+	(PF) sslReadTimeout,
+	(void *) sslState,
+	sslState->timeout);
+    comm_set_select_handler(sslState->server.fd,
+	COMM_SELECT_READ,
+	(PF) sslReadServer,
+	(void *) sslState);
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_READ,
+	(PF) sslReadClient,
+	(void *) sslState);
+}
+
+
+static void sslConnInProgress(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    request_t *req = sslState->request;
+    debug(26, 5, "sslConnInProgress: FD %d sslState=%p\n", fd, sslState);
+
+    if (comm_connect(fd, req->host, req->port) != COMM_OK) {
+	debug(26, 5, "sslConnInProgress: FD %d: %s", fd, xstrerror());
+	switch (errno) {
+#if EINPROGRESS != EALREADY
+	case EINPROGRESS:
+#endif
+	case EALREADY:
+	    /* We are not connected yet. schedule this handler again */
+	    comm_set_select_handler(fd, COMM_SELECT_WRITE,
+		(PF) sslConnInProgress,
+		(void *) sslState);
+	    return;
+	default:
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	    return;
+	}
+    }
+    /* We are now fully connected */
+    sslConnected(fd, sslState);
+    return;
+}
+
+
+int sslStart(fd, url, request, mime_hdr, size_ptr)
+     int fd;
+     char *url;
+     request_t *request;
+     char *mime_hdr;
+     int *size_ptr;
+{
+    /* Create state structure. */
+    int sock, status;
+    SslStateData *sslState = NULL;
+
+    debug(26, 3, "sslStart: '%s %s'\n",
+	RequestMethodStr[request->method], url);
+
+    /* Create socket. */
+    sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
+    if (sock == COMM_ERROR) {
+	debug(26, 4, "sslStart: Failed because we're out of sockets.\n");
+	squid_error_url(url,
+	    request->method,
+	    ERR_NO_FDS,
+	    fd_table[fd].ipaddr,
+	    500,
+	    xstrerror());
+	return COMM_ERROR;
+    }
+    sslState = (SslStateData *) xcalloc(1, sizeof(SslStateData));
+    sslState->url = xstrdup(url);
+    sslState->request = request;
+    sslState->mime_hdr = mime_hdr;
+    sslState->timeout = getReadTimeout();
+    sslState->size_ptr = size_ptr;
+    sslState->client.fd = fd;
+    sslState->server.fd = sock;
+    sslState->server.buf = xmalloc(SSL_BUFSIZ);
+    sslState->client.buf = xmalloc(SSL_BUFSIZ);
+    comm_set_select_handler(sslState->server.fd,
+	COMM_SELECT_CLOSE,
+	(PF) sslStateFree,
+	(void *) sslState);
+
+    /* check if IP is already in cache. It must be. 
+     * It should be done before this route is called. 
+     * Otherwise, we cannot check return code for ssl. */
+    if (!ipcache_gethostbyname(request->host)) {
+	debug(26, 4, "sslstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	squid_error_url(url,
+	    request->method,
+	    ERR_DNS_FAIL,
+	    fd_table[fd].ipaddr,
+	    500,
+	    dns_error_message);
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+	return COMM_ERROR;
+    }
+    debug(26, 5, "sslStart: client=%d server=%d\n",
+	sslState->client.fd,
+	sslState->server.fd);
+    /* Install lifetime handler */
+    comm_set_select_handler(sslState->server.fd,
+	COMM_SELECT_LIFETIME,
+	(PF) sslLifetimeExpire,
+	(void *) sslState);
+    /* NOTE this changes the lifetime handler for the client side.
+     * It used to be asciiConnLifetimeHandle, but it does funny things
+     * like looking for read handlers and assuming it was still reading
+     * the HTTP request.  sigh... */
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_LIFETIME,
+	(PF) sslLifetimeExpire,
+	(void *) sslState);
+    /* Open connection. */
+    if ((status = comm_connect(sock, request->host, request->port))) {
+	if (status != EINPROGRESS) {
+	    squid_error_url(url,
+		request->method,
+		ERR_CONNECT_FAIL,
+		fd_table[fd].ipaddr,
+		500,
+		xstrerror());
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	    return COMM_ERROR;
+	} else {
+	    debug(26, 5, "sslStart: conn %d EINPROGRESS\n", sock);
+	    /* The connection is in progress, install ssl handler */
+	    comm_set_select_handler(sslState->server.fd,
+		COMM_SELECT_WRITE,
+		(PF) sslConnInProgress,
+		(void *) sslState);
+	    return COMM_OK;
+	}
+    }
+    /* We got immediately connected. (can this happen?) */
+    sslConnected(sslState->server.fd, sslState);
+    return COMM_OK;
+}
@@ -1,5 +1,5 @@
 
-/* $Id: store.cc,v 1.64 1996/05/01 22:37:14 wessels Exp $ */
+/* $Id: store.cc,v 1.65 1996/05/03 22:56:33 wessels Exp $ */
 
 /*
  * DEBUG: Section 20          store
@@ -435,13 +435,14 @@ int storeUnlockObject(e)
 {
     int e_lock_count;
 
-    debug(20, 3, "storeUnlockObject: key '%s' count=%d\n", e->key, e->lock_count);
 
     if ((int) e->lock_count > 0)
 	e->lock_count--;
     else if (e->lock_count == 0) {
 	debug(20, 0, "Entry lock count %d is out-of-whack\n", e->lock_count);
     }
+    debug(20, 3, "storeUnlockObject: key '%s' count=%d\n", e->key, e->lock_count);
+
     /* Prevent UMR if we end up freeing the entry */
     e_lock_count = (int) e->lock_count;
 
@@ -512,18 +513,22 @@ char *storeGeneratePublicKey(url, method)
     switch (method) {
     case METHOD_GET:
 	return url;
+	/* NOTREACHED */
 	break;
     case METHOD_POST:
 	sprintf(key_temp_buffer, "/post/%s", url);
 	return key_temp_buffer;
+	/* NOTREACHED */
 	break;
     case METHOD_HEAD:
 	sprintf(key_temp_buffer, "/head/%s", url);
 	return key_temp_buffer;
+	/* NOTREACHED */
 	break;
     case METHOD_CONNECT:
 	sprintf(key_temp_buffer, "/connect/%s", url);
 	return key_temp_buffer;
+	/* NOTREACHED */
 	break;
     default:
 	fatal_dump("storeGeneratePublicKey: Unsupported request method");
@@ -1491,9 +1496,9 @@ void storeStartRebuildFromDisk()
 
     /* Start reading the log file */
     runInBackground("storeRebuild",
-	storeDoRebuildFromDisk,
+	(int (*)(void *)) storeDoRebuildFromDisk,
 	data,
-	storeRebuiltFromDisk);
+	(void (*)(void *)) storeRebuiltFromDisk);
 }
 
 /* return current swap size in kilo-bytes */
@@ -0,0 +1,405 @@
+/*
+ *  $Id: tunnel.cc,v 1.2 1996/05/03 22:56:31 wessels Exp $ 
+ *
+ * DEBUG: Section 26                    ssl
+ */
+#include "squid.h"
+
+#define SSL_BUFSIZ (1<<14)
+
+typedef struct {
+    char *url;
+    request_t *request;
+    char *mime_hdr;
+    struct {
+	int fd;
+	int len;
+	int offset;
+	char *buf;
+    } client, server;
+    time_t timeout;
+    int *size_ptr;		/* pointer to size in an icpStateData for logging */
+} SslStateData;
+
+static char conn_established[] = "HTTP/1.0 200 Connection established\r\n\r\n";
+
+static void sslLifetimeExpire _PARAMS((int fd, SslStateData * sslState));
+static void sslReadTimeout _PARAMS((int fd, SslStateData * sslState));
+static void sslReadServer _PARAMS((int fd, SslStateData * sslState));
+static void sslReadClient _PARAMS((int fd, SslStateData * sslState));
+static void sslWriteServer _PARAMS((int fd, SslStateData * sslState));
+static void sslWriteClient _PARAMS((int fd, SslStateData * sslState));
+static void sslConnected _PARAMS((int fd, SslStateData * sslState));
+static void sslConnInProgress _PARAMS((int fd, SslStateData * sslState));
+
+static int sslStateFree(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    debug(26, 3, "sslStateFree: FD %d, sslState=%p\n", fd, sslState);
+    if (sslState == NULL)
+	return 1;
+    if (fd != sslState->server.fd)
+	fatal_dump("sslStateFree: FD mismatch!\n");
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_READ,
+	NULL,
+	NULL);
+    safe_free(sslState->server.buf);
+    safe_free(sslState->client.buf);
+    xfree(sslState->url);
+    memset(sslState, '\0', sizeof(SslStateData));
+    safe_free(sslState);
+    return 0;
+}
+
+/* This will be called when the server lifetime is expired. */
+static void sslLifetimeExpire(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    debug(26, 4, "sslLifeTimeExpire: FD %d: URL '%s'>\n",
+	fd, sslState->url);
+    comm_close(sslState->client.fd);	/* close client first */
+    comm_close(sslState->server.fd);
+}
+
+/* Read from server side and queue it for writing to the client */
+static void sslReadServer(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    len = read(sslState->server.fd, sslState->server.buf, 4096);
+    debug(26, 5, "sslReadServer FD %d, read %d bytes\n", fd, len);
+    if (len < 0) {
+	debug(26, 1, "sslReadServer: FD %d: read failure: %s\n",
+	    sslState->server.fd, xstrerror());
+	if (errno == EAGAIN || errno == EWOULDBLOCK) {
+	    /* reinstall handlers */
+	    /* XXX This may loop forever */
+	    comm_set_select_handler(sslState->server.fd,
+		COMM_SELECT_READ,
+		(PF) sslReadServer,
+		(void *) sslState);
+	    comm_set_select_handler_plus_timeout(sslState->server.fd,
+		COMM_SELECT_TIMEOUT,
+		(PF) sslReadTimeout,
+		(void *) sslState,
+		sslState->timeout);
+	} else {
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	}
+    } else if (len == 0) {
+	/* Connection closed; retrieval done. */
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+    } else {
+	sslState->server.offset = 0;
+	sslState->server.len = len;
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteClient,
+	    (void *) sslState);
+	comm_set_select_handler_plus_timeout(sslState->server.fd,
+	    COMM_SELECT_TIMEOUT,
+	    (PF) sslReadTimeout,
+	    (void *) sslState,
+	    sslState->timeout);
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadServer,
+	    (void *) sslState);
+    }
+}
+
+/* Read from client side and queue it for writing to the server */
+static void sslReadClient(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    len = read(sslState->client.fd, sslState->client.buf, 4096);
+    debug(26, 5, "sslReadClient FD %d, read %d bytes\n",
+	sslState->client.fd, len);
+    if (len < 0) {
+	debug(26, 1, "sslReadClient: FD %d: read failure: %s\n",
+	    fd, xstrerror());
+	if (errno == EAGAIN || errno == EWOULDBLOCK) {
+	    /* reinstall handlers */
+	    /* XXX This may loop forever */
+	    comm_set_select_handler(sslState->client.fd,
+		COMM_SELECT_READ,
+		(PF) sslReadServer,
+		(void *) sslState);
+	    comm_set_select_handler_plus_timeout(sslState->client.fd,
+		COMM_SELECT_TIMEOUT,
+		(PF) sslReadTimeout,
+		(void *) sslState,
+		sslState->timeout);
+	} else {
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	}
+    } else if (len == 0) {
+	/* Connection closed; retrieval done. */
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+    } else {
+	sslState->client.offset = 0;
+	sslState->client.len = len;
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteServer,
+	    (void *) sslState);
+	comm_set_select_handler_plus_timeout(sslState->client.fd, COMM_SELECT_TIMEOUT,
+	    (PF) sslReadTimeout,
+	    (void *) sslState,
+	    sslState->timeout);
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadServer,
+	    (void *) sslState);
+    }
+}
+
+/* Writes data from the client buffer to the server side */
+static void sslWriteServer(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    len = write(sslState->server.fd,
+	sslState->client.buf + sslState->client.offset,
+	sslState->client.len - sslState->client.offset);
+    debug(26, 5, "sslWriteServer FD %d, wrote %d bytes\n", fd, len);
+    if (len < 0) {
+	debug(26, 2, "sslWriteServer: FD %d: write failure: %s.\n",
+	    sslState->server.fd, xstrerror());
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+	return;
+    }
+    if ((sslState->client.offset += len) >= sslState->client.len) {
+	/* Done writing, read more */
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadClient,
+	    (void *) sslState);
+    } else {
+	/* still have more to write */
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteServer,
+	    (void *) sslState);
+    }
+}
+
+/* Writes data from the server buffer to the client side */
+static void sslWriteClient(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    int len;
+    debug(26, 5, "sslWriteClient FD %d len=%d offset=%d\n",
+	fd,
+	sslState->server.len,
+	sslState->server.offset);
+    len = write(sslState->client.fd,
+	sslState->server.buf + sslState->server.offset,
+	sslState->server.len - sslState->server.offset);
+    debug(26, 5, "sslWriteClient FD %d, wrote %d bytes\n", fd, len);
+    if (len < 0) {
+	debug(26, 2, "sslWriteClient: FD %d: write failure: %s.\n",
+	    sslState->client.fd, xstrerror());
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+	return;
+    }
+    if (sslState->size_ptr)
+	*sslState->size_ptr += len;	/* increment total object size */
+    if ((sslState->server.offset += len) >= sslState->server.len) {
+	/* Done writing, read more */
+	comm_set_select_handler(sslState->server.fd,
+	    COMM_SELECT_READ,
+	    (PF) sslReadServer,
+	    (void *) sslState);
+    } else {
+	/* still have more to write */
+	comm_set_select_handler(sslState->client.fd,
+	    COMM_SELECT_WRITE,
+	    (PF) sslWriteClient,
+	    (void *) sslState);
+    }
+}
+
+static void sslReadTimeout(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    if (fd != sslState->server.fd)
+	fatal_dump("sslReadTimeout: FD mismatch!\n");
+    debug(26, 3, "sslReadTimeout: FD %d\n", fd);
+    comm_close(sslState->client.fd);
+    comm_close(sslState->server.fd);
+}
+
+static void sslConnected(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    debug(26, 3, "sslConnected: FD %d sslState=%p\n", fd, sslState);
+    strcpy(sslState->server.buf, conn_established);
+    sslState->server.len = strlen(conn_established);
+    sslState->server.offset = 0;
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_WRITE,
+	(PF) sslWriteClient,
+	(void *) sslState);
+    comm_set_fd_lifetime(fd, -1);	/* disable lifetime */
+    comm_set_select_handler_plus_timeout(sslState->server.fd,
+	COMM_SELECT_TIMEOUT,
+	(PF) sslReadTimeout,
+	(void *) sslState,
+	sslState->timeout);
+    comm_set_select_handler(sslState->server.fd,
+	COMM_SELECT_READ,
+	(PF) sslReadServer,
+	(void *) sslState);
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_READ,
+	(PF) sslReadClient,
+	(void *) sslState);
+}
+
+
+static void sslConnInProgress(fd, sslState)
+     int fd;
+     SslStateData *sslState;
+{
+    request_t *req = sslState->request;
+    debug(26, 5, "sslConnInProgress: FD %d sslState=%p\n", fd, sslState);
+
+    if (comm_connect(fd, req->host, req->port) != COMM_OK) {
+	debug(26, 5, "sslConnInProgress: FD %d: %s", fd, xstrerror());
+	switch (errno) {
+#if EINPROGRESS != EALREADY
+	case EINPROGRESS:
+#endif
+	case EALREADY:
+	    /* We are not connected yet. schedule this handler again */
+	    comm_set_select_handler(fd, COMM_SELECT_WRITE,
+		(PF) sslConnInProgress,
+		(void *) sslState);
+	    return;
+	default:
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	    return;
+	}
+    }
+    /* We are now fully connected */
+    sslConnected(fd, sslState);
+    return;
+}
+
+
+int sslStart(fd, url, request, mime_hdr, size_ptr)
+     int fd;
+     char *url;
+     request_t *request;
+     char *mime_hdr;
+     int *size_ptr;
+{
+    /* Create state structure. */
+    int sock, status;
+    SslStateData *sslState = NULL;
+
+    debug(26, 3, "sslStart: '%s %s'\n",
+	RequestMethodStr[request->method], url);
+
+    /* Create socket. */
+    sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
+    if (sock == COMM_ERROR) {
+	debug(26, 4, "sslStart: Failed because we're out of sockets.\n");
+	squid_error_url(url,
+	    request->method,
+	    ERR_NO_FDS,
+	    fd_table[fd].ipaddr,
+	    500,
+	    xstrerror());
+	return COMM_ERROR;
+    }
+    sslState = (SslStateData *) xcalloc(1, sizeof(SslStateData));
+    sslState->url = xstrdup(url);
+    sslState->request = request;
+    sslState->mime_hdr = mime_hdr;
+    sslState->timeout = getReadTimeout();
+    sslState->size_ptr = size_ptr;
+    sslState->client.fd = fd;
+    sslState->server.fd = sock;
+    sslState->server.buf = xmalloc(SSL_BUFSIZ);
+    sslState->client.buf = xmalloc(SSL_BUFSIZ);
+    comm_set_select_handler(sslState->server.fd,
+	COMM_SELECT_CLOSE,
+	(PF) sslStateFree,
+	(void *) sslState);
+
+    /* check if IP is already in cache. It must be. 
+     * It should be done before this route is called. 
+     * Otherwise, we cannot check return code for ssl. */
+    if (!ipcache_gethostbyname(request->host)) {
+	debug(26, 4, "sslstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	squid_error_url(url,
+	    request->method,
+	    ERR_DNS_FAIL,
+	    fd_table[fd].ipaddr,
+	    500,
+	    dns_error_message);
+	comm_close(sslState->client.fd);
+	comm_close(sslState->server.fd);
+	return COMM_ERROR;
+    }
+    debug(26, 5, "sslStart: client=%d server=%d\n",
+	sslState->client.fd,
+	sslState->server.fd);
+    /* Install lifetime handler */
+    comm_set_select_handler(sslState->server.fd,
+	COMM_SELECT_LIFETIME,
+	(PF) sslLifetimeExpire,
+	(void *) sslState);
+    /* NOTE this changes the lifetime handler for the client side.
+     * It used to be asciiConnLifetimeHandle, but it does funny things
+     * like looking for read handlers and assuming it was still reading
+     * the HTTP request.  sigh... */
+    comm_set_select_handler(sslState->client.fd,
+	COMM_SELECT_LIFETIME,
+	(PF) sslLifetimeExpire,
+	(void *) sslState);
+    /* Open connection. */
+    if ((status = comm_connect(sock, request->host, request->port))) {
+	if (status != EINPROGRESS) {
+	    squid_error_url(url,
+		request->method,
+		ERR_CONNECT_FAIL,
+		fd_table[fd].ipaddr,
+		500,
+		xstrerror());
+	    comm_close(sslState->client.fd);
+	    comm_close(sslState->server.fd);
+	    return COMM_ERROR;
+	} else {
+	    debug(26, 5, "sslStart: conn %d EINPROGRESS\n", sock);
+	    /* The connection is in progress, install ssl handler */
+	    comm_set_select_handler(sslState->server.fd,
+		COMM_SELECT_WRITE,
+		(PF) sslConnInProgress,
+		(void *) sslState);
+	    return COMM_OK;
+	}
+    }
+    /* We got immediately connected. (can this happen?) */
+    sslConnected(sslState->server.fd, sslState);
+    return COMM_OK;
+}
@@ -1,4 +1,4 @@
-/* $Id: url.cc,v 1.20 1996/05/01 22:36:42 wessels Exp $ */
+/* $Id: url.cc,v 1.21 1996/05/03 22:56:33 wessels Exp $ */
 
 /* 
  * DEBUG: Section 23          url
@@ -161,13 +161,14 @@ request_t *urlParse(method, url)
      char *url;
 {
     static char proto[MAX_URL + 1];
+    static char login[MAX_URL + 1];
     static char host[MAX_URL + 1];
     static char urlpath[MAX_URL + 1];
     request_t *request = NULL;
     char *t = NULL;
     int port;
     protocol_t protocol = PROTO_NONE;
-    proto[0] = host[0] = urlpath[0] = '\0';
+    proto[0] = host[0] = urlpath[0] = login[0] = '\0';
 
     if (method == METHOD_CONNECT) {
 	port = CONNECT_PORT;
@@ -178,6 +179,13 @@ request_t *urlParse(method, url)
 	    return NULL;
 	protocol = urlParseProtocol(proto);
 	port = urlDefaultPort(protocol);
+	/* Is there any login informaiton? */
+	if ((t = strrchr(host, '@'))) {
+	    strcpy(login, host);
+	    t = strrchr(login, '@');
+	    *t = 0;
+	    strcpy(host, t + 1);
+	}
 	if ((t = strrchr(host, ':')) && *(t + 1) != '\0') {
 	    *t = '\0';
 	    port = atoi(t + 1);
@@ -193,6 +201,7 @@ request_t *urlParse(method, url)
     request->method = method;
     request->protocol = protocol;
     strncpy(request->host, host, SQUIDHOSTNAMELEN);
+    strncpy(request->login, login, MAX_LOGIN_SZ);
     request->port = port;
     strncpy(request->urlpath, urlpath, MAX_URL);
     return request;
@@ -214,8 +223,10 @@ char *urlCanonical(request, buf)
 	portbuf[0] = '\0';
 	if (request->port != urlDefaultPort(request->protocol))
 	    sprintf(portbuf, ":%d", request->port);
-	sprintf(buf, "%s://%s%s%s",
+	sprintf(buf, "%s://%s%s%s%s%s",
 	    ProtocolStr[request->protocol],
+	    request->login,
+	    *request->login ? "@" : "",
 	    request->host,
 	    portbuf,
 	    request->urlpath);
@@ -1,4 +1,4 @@
-/* $Id: wais.cc,v 1.29 1996/05/01 22:36:43 wessels Exp $ */
+/* $Id: wais.cc,v 1.30 1996/05/03 22:56:34 wessels Exp $ */
 
 /*
  * DEBUG: Section 24          wais
@@ -258,7 +258,7 @@ int waisStart(unusedfd, url, method, mime_hdr, entry)
     data->mime_hdr = mime_hdr;
     comm_set_select_handler(sock,
 	COMM_SELECT_CLOSE,
-	waisStateFree,
+	(PF) waisStateFree,
 	(void *) data);
 
     /* check if IP is already in cache. It must be. 