----++++src/Instance.cc
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include &quot;squid.h&quot;
+#include &quot;base/File.h&quot;
+#include &quot;fs_io.h&quot;
+#include &quot;Instance.h&quot;
+#include &quot;parser/Tokenizer.h&quot;
+#include &quot;sbuf/Stream.h&quot;
+#include &quot;SquidConfig.h&quot;
+#include &quot;tools.h&quot;
+
+#include &lt;cerrno&gt;
+
+/* To support concurrent PID files, convert local statics into PidFile class */
+
+/// Describes the (last) instance PID file being processed.
+/// This hack shortens reporting code while keeping its messages consistent.
+static SBuf TheFile;
+
+/// PidFilename() helper
+/// \returns PID file name or, if PID signaling was disabled, an empty SBuf
+static SBuf
+PidFilenameCalc()
+{
+    if (!Config.pidFilename || strcmp(Config.pidFilename, &quot;none&quot;) == 0)
+        return SBuf();
+
+    // If chroot has been requested, then we first read the PID file before
+    // chroot() and then create/update it inside a chrooted environment.
+    // TODO: Consider removing half-baked chroot support from Squid.
+    extern bool Chrooted;
+    if (!Config.chroot_dir || Chrooted) // no need to compensate
+        return SBuf(Config.pidFilename);
+
+    SBuf filename;
+    filename.append(Config.chroot_dir);
+    filename.append(&quot;/&quot;);
+    filename.append(Config.pidFilename);
+    debugs(50, 3, &quot;outside chroot: &quot; &lt;&lt; filename);
+    return filename;
+}
+
+/// \returns PID file description for debugging messages and error reporting
+static SBuf
+PidFileDescription(const SBuf &amp;filename)
+{
+    return ToSBuf(&quot;PID file (&quot;, filename, &#39;)&#39;);
+}
+
+/// Instance entry points are expected to call this first.
+/// \returns PidFilenameCalc() result while updating TheFile context
+static SBuf
+PidFilename()
+{
+    const auto name = PidFilenameCalc();
+    TheFile = PidFileDescription(name);
+    return name;
+}
+
+/// \returns the PID of another Squid instance (or throws)
+static pid_t
+GetOtherPid(File &amp;pidFile)
+{
+    const auto input = pidFile.readSmall(1, 32);
+    int64_t rawPid = -1;
+
+    Parser::Tokenizer tok(input);
+    if (!(tok.int64(rawPid, 10, false) &amp;&amp; // PID digits
+            (tok.skipOne(CharacterSet::CR)||true) &amp;&amp; // optional CR (Windows/etc.)
+            tok.skipOne(CharacterSet::LF) &amp;&amp; // required end of line
+            tok.atEnd())) { // no trailing garbage
+        throw TexcHere(ToSBuf(&quot;Malformed &quot;, TheFile));
+    }
+
+    debugs(50, 7, &quot;found PID &quot; &lt;&lt; rawPid &lt;&lt; &quot; in &quot; &lt;&lt; TheFile);
+
+    if (rawPid &lt;= 1)
+        throw TexcHere(ToSBuf(&quot;Bad &quot;, TheFile, &quot; contains unreasonably small PID value: &quot;, rawPid));
+    const auto finalPid = static_cast&lt;pid_t&gt;(rawPid);
+    if (static_cast&lt;int64_t&gt;(finalPid) != rawPid)
+        throw TexcHere(ToSBuf(&quot;Bad &quot;, TheFile, &quot; contains unreasonably large PID value: &quot;, rawPid));
+
+    return finalPid;
+}
+
+/// determines whether a given process is running at the time of the call
+static bool
+ProcessIsRunning(const pid_t pid)
+{
+    const auto result = kill(pid, 0);
+    const auto savedErrno = errno;
+    if (result != 0)
+        debugs(50, 3, &quot;kill(&quot; &lt;&lt; pid &lt;&lt; &quot;, 0) failed: &quot; &lt;&lt; xstrerr(savedErrno));
+    // if we do not have permissions to signal the process, then it is running
+    return (result == 0 || savedErrno == EPERM);
+}
+
+/// quits if another Squid instance (that owns the given PID file) is running
+static void
+ThrowIfAlreadyRunningWith(File &amp;pidFile)
+{
+    bool running = false;
+    SBuf description;
+    try {
+        const auto pid = GetOtherPid(pidFile);
+        description = ToSBuf(TheFile, &quot; with PID &quot;, pid);
+        running = ProcessIsRunning(pid);
+    }
+    catch (const std::exception &amp;ex) {
+        debugs(50, 5, &quot;assuming no other Squid instance: &quot; &lt;&lt; ex.what());
+        return;
+    }
+
+    if (running)
+        throw TexcHere(ToSBuf(&quot;Squid is already running: Found fresh instance &quot;, description));
+
+    debugs(50, 5, &quot;assuming stale instance &quot; &lt;&lt; description);
+}
+
+pid_t
+Instance::Other()
+{
+    const auto filename = PidFilename();
+    if (filename.isEmpty())
+        throw TexcHere(&quot;no pid_filename configured&quot;);
+
+    File pidFile(filename, File::Be::ReadOnly().locked());
+    return GetOtherPid(pidFile);
+}
+
+void
+Instance::ThrowIfAlreadyRunning()
+{
+    const auto filename = PidFilename();
+    if (filename.isEmpty())
+        return; // the check is impossible
+
+    if (const auto filePtr = File::Optional(filename, File::Be::ReadOnly().locked())) {
+        const std::unique_ptr&lt;File&gt; pidFile(filePtr);
+        ThrowIfAlreadyRunningWith(*pidFile);
+    } else {
+        // It is best to assume then to check because checking without a lock
+        // might lead to false positives that lead to no Squid starting at all!
+        debugs(50, 5, &quot;cannot lock &quot; &lt;&lt; TheFile &lt;&lt; &quot;; assuming no other Squid is running&quot;);
+        // If our assumption is false, we will fail to _create_ the PID file,
+        // and, hence, will not start, allowing that other Squid to run.
+    }
+}
+
+/// ties Instance::WriteOurPid() scheduler and RemoveInstance(void) handler
+static SBuf ThePidFileToRemove;
+
+/// atexit() handler; removes the PID file created with Instance::WriteOurPid()
+static void
+RemoveInstance()
+{
+    if (ThePidFileToRemove.isEmpty()) // not the PidFilename()!
+        return; // nothing to do
+
+    debugs(50, DBG_IMPORTANT, &quot;Removing &quot; &lt;&lt; PidFileDescription(ThePidFileToRemove));
+    const char *filename = ThePidFileToRemove.c_str(); // avoid complex operations inside enter_suid()
+    enter_suid();
+    safeunlink(filename, 0);
+    leave_suid();
+
+    ThePidFileToRemove.clear();
+}
+
+/// creates a PID file; throws on error
+void
+Instance::WriteOurPid()
+{
+    // Instance code assumes that we do not support PID filename reconfiguration
+    static bool called = false;
+    Must(!called);
+    called = true;
+
+    const auto filename = PidFilename();
+    if (filename.isEmpty())
+        return; // nothing to do
+
+    File pidFile(filename, File::Be::ReadWrite().locked().createdIfMissing().openedByRoot());
+
+    // another instance may have started after the caller checked (if it did)
+    ThrowIfAlreadyRunningWith(pidFile);
+
+    /* now we know that we own the PID file created and/or locked above */
+
+    // Cleanup is scheduled through atexit() to ensure both:
+    // - cleanup upon fatal() and similar &quot;unplanned&quot; exits and
+    // - enter_suid() existence and proper logging support during cleanup.
+    // Even without PID filename reconfiguration support, we have to remember
+    // the file name we have used because Config.pidFilename may change!
+    (void)std::atexit(&amp;RemoveInstance); // failures leave the PID file on disk
+    ThePidFileToRemove = filename;
+
+    /* write our PID to the locked file */
+    SBuf pidBuf;
+    pidBuf.Printf(&quot;%d\n&quot;, static_cast&lt;int&gt;(getpid()));
+    pidFile.truncate();
+    pidFile.writeAll(pidBuf);
+
+    // We must fsync before releasing the lock or other Squid processes may not see
+    // our written PID (and decide that they are dealing with a corrupted PID file).
+    pidFile.synchronize();
+
+    debugs(50, DBG_IMPORTANT, &quot;Created &quot; &lt;&lt; TheFile);
+}
+
----++++src/Instance.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_INSTANCE_H
+#define SQUID_INSTANCE_H
+
+#if HAVE_SYS_TYPES_H
+#include &lt;sys/types.h&gt;
+#endif
+
+/// code related to Squid Instance and PID file management
+namespace Instance {
+
+/// Usually throws if another Squid instance is running. False positives are
+/// highly unlikely, but the caller must tolerate false negatives well:
+/// We may not detect another running instance and, hence, may not throw.
+/// Does nothing if PID file maintenance is disabled.
+void ThrowIfAlreadyRunning();
+
+/// Creates or updates the PID file for the current process.
+/// Does nothing if PID file maintenance is disabled.
+void WriteOurPid();
+
+/// \returns another Squid instance PID
+/// Throws if PID file maintenance is disabled.
+pid_t Other();
+
+} // namespace Instance
+
+#endif
+
----++++src/Makefile.am
@@ -351,6 +351,8 @@ squid_SOURCES = \
 	icp_opcode.h \
 	icp_v2.cc \
 	icp_v3.cc \
+	Instance.h \
+	Instance.cc \
 	int.h \
 	int.cc \
 	internal.h \
@@ -1156,6 +1158,7 @@ tests_testBoilerplate_SOURCES = \
 	tests/testBoilerplate.h \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
+	tests/stub_SBuf.cc \
 	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	tests/stub_cbdata.cc \
@@ -1179,7 +1182,8 @@ nodist_tests_testCharacterSet_SOURCES = \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
-	tests/stub_MemBuf.cc
+	tests/stub_MemBuf.cc \
+	tests/stub_SBuf.cc
 tests_testCharacterSet_LDFLAGS = $(LIBADD_DL)
 tests_testCharacterSet_LDADD= \
 	base/libbase.la \
@@ -2624,6 +2628,7 @@ nodist_tests_testIcmp_SOURCES = \
 	SquidTime.h \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
+	tests/stub_SBuf.cc \
 	time.cc \
 	globals.cc
 tests_testIcmp_LDFLAGS = $(LIBADD_DL)
@@ -2642,6 +2647,7 @@ nodist_tests_testNetDb_SOURCES = \
 	SquidTime.h \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
+	tests/stub_SBuf.cc \
 	time.cc \
 	globals.cc
 tests_testNetDb_LDFLAGS = $(LIBADD_DL)
@@ -3600,6 +3606,7 @@ tests_testEnumIterator_SOURCES = \
 	base/EnumIterator.h \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
+	tests/stub_SBuf.cc \
 	tests/testEnumIterator.h \
 	tests/testEnumIterator.cc
 nodist_tests_testEnumIterator_SOURCES = \
@@ -3618,6 +3625,7 @@ nodist_tests_testYesNoNone_SOURCES = \
 	tests/STUB.h \
 	tests/stub_debug.cc \
 	tests/stub_libmem.cc \
+	tests/stub_SBuf.cc \
 	base/YesNoNone.h
 tests_testYesNoNone_LDADD= \
 	base/libbase.la \
@@ -3631,6 +3639,7 @@ tests_testMem_SOURCES = \
 	tests/testMem.h
 nodist_tests_testMem_SOURCES = \
 	tests/stub_debug.cc \
+	tests/stub_SBuf.cc \
 	tests/stub_time.cc \
 	$(TESTSOURCES)
 tests_testMem_LDADD= \
----++++GitHub