diff --git a/ChangeLog b/ChangeLog
index cd135ef..ad6f6e8 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,24 @@
+1999-10-15  Paul D. Smith  <psmith@gnu.org>
+
+	* main.c (quote_for_env): Rename from quote_as_word().
+
+	* make.h, *.c: Prefer strchr() and strrchr() in the code
+	rather than index() and rindex().  Define strchr/strrchr in terms
+	of index/rindex if the former aren't supported.
+
+	* default.c (CHECKOUT,v): Replace the fancy, complicated
+	patsubst/filter expression with a simple $(if ...) expression.
+
+	* main.c (print_usage): Add the bug reporting mailing address to
+	the --help output, as per the GNU coding standards.
+	Reported by Paul Eggert <eggert@twinsun.com>.
+
+	* README.customs: Installed information on running Customs-ized
+	GNU make and setuid root, collected by Ted Stern <stern@tera.com>.
+
+	* read.c (read_all_makefiles): PR/1394: Mark the end of the next
+	token in the MAKEFILES value string _before_ we dup it.
+
 1999-10-13  Paul D. Smith  <psmith@gnu.org>
 
 	* configure.in (make_cv_sys_gnu_glob): We used to add the -Iglob
@@ -29,6 +50,25 @@
 	this--we need this to set up the chain properly for
 	target-specific variables.
 
+1999-09-29  Paul Eggert  <eggert@twinsun.com>
+
+	* main.c (quote_as_word): Always quote for decode_env_switches
+        instead of for the shell, so that arguments with strange
+        characters are are passed to submakes correctly.  Remove
+        double_dollars arg; we always double dollars now.  All callers
+        changed.
+        (decode_env_switches): Don't run off the end of an environment
+        variable whose contents ends in a unescaped backslash.
+
+1999-09-23  Paul D. Smith  <psmith@gnu.org>
+
+	* commands.c, function.c, job.c, read.c: Cast arguments to
+	ctype.h functions/macros to _unsigned_ char for portability.
+
+	* remake.c, function.c: Compiler warning fixes: the second
+	argument to find_next_token() should be an _unsigned_ int*.
+	Reported by Han-Wen Nienhuys <hanwen@cs.uu.nl>.
+
 1999-09-23  Paul D. Smith  <psmith@gnu.org>
 
 	* Version 3.78.1 released.
diff --git a/NEWS b/NEWS
index 6cc6fb9..77bf66f 100644
--- a/NEWS
+++ b/NEWS
@@ -8,10 +8,26 @@ See the end for copying conditions.
 All changes mentioned here are more fully described in the GNU make
 manual, which is contained in this distribution as the file make.texinfo.
 
-Please send GNU make bug reports to bug-make@gnu.org.
+Please send GNU make bug reports to <bug-make@gnu.org>.
 See the README file and the GNU make manual for details on sending bug
 reports.
 
+Version 3.78.2
+
+* Previously, GNU make quoted variables such as MAKEFLAGS and
+  MAKEOVERRIDES for proper parsing by the shell.  This allowed them to
+  be used within make build scripts.  However, using them there is not
+  proper behavior: they are meant to be passed to subshells via the
+  environment.  Unfortunately the values were not quoted properly to be
+  passed through the environment.  This meant that some invocations of
+  make didn't properly pass values to submakes.
+
+  With this version we change that behavior: now these variables are
+  quoted properly for passing through the environment, which is the
+  correct way to do it.  If you previously used these variables
+  explicitly within a make rule you may need to re-examine your use for
+  correctness given this change.
+
 Version 3.78
 
 * Two new functions, $(error ...) and $(warning ...) are available.  The
diff --git a/README.customs b/README.customs
index 9ad21f6..1976943 100644
--- a/README.customs
+++ b/README.customs
@@ -56,6 +56,28 @@ See the documentation for Customs for information on starting and
 configuring Customs.
 
 
+INVOKING CUSTOMS-IZED GNU MAKE
+-----------------------------
+
+One thing you should be aware of is that the default build environment
+for Customs requires root permissions.  Practically, this means that GNU
+make must be installed setuid root to use Customs.
+
+If you don't want to do this, you can build Customs such that root
+permissions are not necessary.  Andreas Stolcke <stolcke@speech.sri.com>
+writes:
+
+ > pmake, gnumake or any other customs client program is not required to
+ > be suid root if customs was compiled WITHOUT the USE_RESERVED_PORTS
+ > option in customs/config.h.  Make sure the "customs" service in
+ > /etc/services is defined accordingly (port 8231 instead of 1001).
+
+ > Not using USE_RESERVED_PORTS means that a user with programming
+ > skills could impersonate another user by writing a fake customs
+ > client that pretends to be someone other than himself.  See the
+ > discussion in etc/SECURITY.
+
+
 PROBLEMS
 --------
 
diff --git a/ar.c b/ar.c
index 2e16435..3827f40 100644
--- a/ar.c
+++ b/ar.c
@@ -41,7 +41,7 @@ int
 ar_name (name)
      char *name;
 {
-  char *p = index (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
 
   if (p == 0 || p == name || *end != ')')
     return 0;
@@ -61,7 +61,7 @@ void
 ar_parse_name (name, arname_p, memname_p)
      char *name, **arname_p, **memname_p;
 {
-  char *p = index (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
 
   if (arname_p != 0)
     *arname_p = savestring (name, p - name);
diff --git a/arscan.c b/arscan.c
index 25e739a..6ff2715 100644
--- a/arscan.c
+++ b/arscan.c
@@ -37,8 +37,6 @@ USA.  */
 #include <lbr$routines.h>
 #endif
 
-#define uppercasify(str) {char *str1; for (str1 = str; *str1; str1++) *str1 = _toupper(*str1);}
-
 static void *VMS_lib_idx;
 
 static char *VMS_saved_memname;
@@ -83,7 +81,7 @@ VMS_get_member_info (module, rfa)
   val = decc$fix_time (&mhd->mhd$l_datim);
 
   for (i = 0; i < module->dsc$w_length; i++)
-    filename[i] = _tolower (module->dsc$a_pointer[i]);
+    filename[i] = _tolower ((unsigned char)module->dsc$a_pointer[i]);
 
   filename[i] = '\0';
 
@@ -172,7 +170,7 @@ ar_scan (archive, function, arg)
 
   /* For comparison, delete .obj from arg name.  */
 
-  p = rindex (VMS_saved_memname, '.');
+  p = strrchr (VMS_saved_memname, '.');
   if (p)
     *p = '\0';
 
@@ -698,7 +696,7 @@ ar_name_equal (name, mem, truncated)
 {
   char *p;
 
-  p = rindex (name, '/');
+  p = strrchr (name, '/');
   if (p != 0)
     name = p + 1;
 
diff --git a/commands.c b/commands.c
index 88ae022..8a8d227 100644
--- a/commands.c
+++ b/commands.c
@@ -46,7 +46,7 @@ set_file_variables (file)
   if (ar_name (file->name))
     {
       unsigned int len;
-      p = index (file->name, '(');
+      p = strchr (file->name, '(');
       at = (char *) alloca (p - file->name + 1);
       bcopy (file->name, at, p - file->name);
       at[p - file->name] = '\0';
@@ -75,7 +75,7 @@ set_file_variables (file)
 #ifndef	NO_ARCHIVES
       if (ar_name (file->name))
 	{
-	  name = index (file->name, '(') + 1;
+	  name = strchr (file->name, '(') + 1;
 	  len = strlen (name) - 1;
 	}
       else
@@ -146,7 +146,7 @@ set_file_variables (file)
 #ifndef	NO_ARCHIVES
 	if (ar_name (c))
 	  {
-	    c = index (c, '(') + 1;
+	    c = strchr (c, '(') + 1;
 	    len = strlen (c) - 1;
 	  }
 	else
@@ -188,7 +188,7 @@ set_file_variables (file)
 #ifndef	NO_ARCHIVES
 	if (ar_name (c))
 	  {
-	    c = index (c, '(') + 1;
+	    c = strchr (c, '(') + 1;
 	    len = strlen (c) - 1;
 	  }
 	else
@@ -255,7 +255,7 @@ chop_commands (cmds)
     {
       char *end = p;
     find_end:;
-      end = index (end, '\n');
+      end = strchr (end, '\n');
       if (end == 0)
         end = p + strlen (p);
       else if (end > p && end[-1] == '\\')
@@ -341,7 +341,7 @@ execute_file_commands (file)
      the commands are nothing but whitespace.  */
 
   for (p = file->cmds->commands; *p != '\0'; ++p)
-    if (!isspace (*p) && *p != '-' && *p != '@')
+    if (!isspace ((unsigned char)*p) && *p != '-' && *p != '@')
       break;
   if (*p == '\0')
     {
@@ -548,10 +548,10 @@ print_commands (cmds)
     {
       char *end;
 
-      while (isspace (*s))
+      while (isspace ((unsigned char)*s))
 	++s;
 
-      end = index (s, '\n');
+      end = strchr (s, '\n');
       if (end == 0)
 	end = s + strlen (s);
 
diff --git a/configure.in b/configure.in
index ccfd3a0..01e70dc 100644
--- a/configure.in
+++ b/configure.in
@@ -60,7 +60,7 @@ AC_MSG_RESULT($ac_cv_check_symbol_$1)])dnl
 # clock_gettime is in -lposix4 in Solaris 2.6.
 AC_CHECK_LIB(posix4, clock_gettime)
 
-AC_CHECK_FUNCS(memmove strdup psignal mktemp pstat_getdynamic \
+AC_CHECK_FUNCS(memmove strchr memcpy strdup psignal mktemp pstat_getdynamic \
 	       clock_gettime dup2 getcwd sigsetmask sigaction getgroups \
 	       setlinebuf seteuid setegid setreuid setregid pipe \
 	       strerror strsignal)
diff --git a/default.c b/default.c
index 79f313e..8ad37e1 100644
--- a/default.c
+++ b/default.c
@@ -328,8 +328,7 @@ static char *default_variables[] =
     /* This expands to $(CO) $(COFLAGS) $< $@ if $@ does not exist,
        and to the empty string if $@ does exist.  */
     "CHECKOUT,v",
-    "+$(patsubst $@-noexist,$(CO) $(COFLAGS) $< $@,\
-		 $(filter-out $@,$(firstword $(wildcard $@) $@-noexist)))",
+    "+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)",
 
     "CO", "co",
     "CPP", "$(CC) -E",
diff --git a/dir.c b/dir.c
index cb25c18..5fa1d34 100644
--- a/dir.c
+++ b/dir.c
@@ -84,7 +84,7 @@ dosify (filename)
 
   /* First, transform the name part.  */
   for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
-    *df++ = tolower (*filename++);
+    *df++ = tolower ((unsigned char)*filename++);
 
   /* Now skip to the next dot.  */
   while (*filename != '\0' && *filename != '.')
@@ -93,7 +93,7 @@ dosify (filename)
     {
       *df++ = *filename++;
       for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
-	*df++ = tolower (*filename++);
+	*df++ = tolower ((unsigned char)*filename++);
     }
 
   /* Look for more dots.  */
@@ -135,7 +135,7 @@ downcase (filename)
   /* First, transform the name part.  */
   for (i = 0; *filename != '\0'; ++i)
   {
-    *df++ = tolower (*filename);
+    *df++ = tolower ((unsigned char)*filename);
     ++filename;
   }
 
@@ -635,16 +635,16 @@ file_exists_p (name)
 #endif
 
 #ifdef VMS
-  dirend = rindex (name, ']');
+  dirend = strrchr (name, ']');
   dirend++;
   if (dirend == (char *)1)
     return dir_file_exists_p ("[]", name);
 #else /* !VMS */
-  dirend = rindex (name, '/');
+  dirend = strrchr (name, '/');
 #if defined (WINDOWS32) || defined (__MSDOS__)
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    char *bslash = rindex(name, '\\');
+    char *bslash = strrchr(name, '\\');
     if (!dirend || bslash > dirend)
       dirend = bslash;
     /* The case of "d:file".  */
@@ -693,16 +693,16 @@ file_impossible (filename)
   register struct dirfile *new;
 
 #ifdef VMS
-  dirend = rindex (p, ']');
+  dirend = strrchr (p, ']');
   dirend++;
   if (dirend == (char *)1)
     dir = find_directory ("[]");
 #else
-  dirend = rindex (p, '/');
+  dirend = strrchr (p, '/');
 #if defined (WINDOWS32) || defined (__MSDOS__)
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    char *bslash = rindex(p, '\\');
+    char *bslash = strrchr(p, '\\');
     if (!dirend || bslash > dirend)
       dirend = bslash;
     /* The case of "d:file".  */
@@ -796,15 +796,15 @@ file_impossible_p (filename)
   register struct dirfile *next;
 
 #ifdef VMS
-  dirend = rindex (filename, ']');
+  dirend = strrchr (filename, ']');
   if (dirend == 0)
     dir = find_directory ("[]")->contents;
 #else
-  dirend = rindex (filename, '/');
+  dirend = strrchr (filename, '/');
 #if defined (WINDOWS32) || defined (__MSDOS__)
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    char *bslash = rindex(filename, '\\');
+    char *bslash = strrchr(filename, '\\');
     if (!dirend || bslash > dirend)
       dirend = bslash;
     /* The case of "d:file".  */
diff --git a/expand.c b/expand.c
index aebbe3f..edf6c9c 100644
--- a/expand.c
+++ b/expand.c
@@ -189,7 +189,7 @@ variable_expand_string (line, string, length)
          variable output buffer, and skip them.  Uninteresting chars end
 	 at the next $ or the end of the input.  */
 
-      p1 = index (p, '$');
+      p1 = strchr (p, '$');
 
       o = variable_buffer_output (o, p, p1 != 0 ? p1 - p : strlen (p) + 1);
 
@@ -229,7 +229,7 @@ variable_expand_string (line, string, length)
 	    /* Is there a variable reference inside the parens or braces?
 	       If so, expand it before expanding the entire reference.  */
 
-	    end = index (beg, closeparen);
+	    end = strchr (beg, closeparen);
 	    if (end == 0)
               /* Unterminated variable reference.  */
               fatal (reading_file, _("unterminated variable reference"));
@@ -253,7 +253,7 @@ variable_expand_string (line, string, length)
 		  {
 		    beg = expand_argument (beg, p); /* Expand the name.  */
 		    free_beg = 1; /* Remember to free BEG when finished.  */
-		    end = index (beg, '\0');
+		    end = strchr (beg, '\0');
 		  }
 	      }
 	    else
@@ -273,7 +273,7 @@ variable_expand_string (line, string, length)
 		char *subst_beg, *subst_end, *replace_beg, *replace_end;
 
 		subst_beg = colon + 1;
-		subst_end = index (subst_beg, '=');
+		subst_end = strchr (subst_beg, '=');
 		if (subst_end == 0)
 		  /* There is no = in sight.  Punt on the substitution
 		     reference and treat this as a variable name containing
diff --git a/file.c b/file.c
index 8fa759c..daf22a5 100644
--- a/file.c
+++ b/file.c
@@ -67,7 +67,7 @@ lookup_file (name)
 #ifdef VMS
   lname = (char *)malloc(strlen(name) + 1);
   for (n=name, ln=lname; *n != '\0'; ++n, ++ln)
-    *ln = isupper(*n) ? tolower(*n) : *n;
+    *ln = isupper((unsigned char)*n) ? tolower((unsigned char)*n) : *n;
   *ln = '\0';
   name = lname;
 
@@ -133,8 +133,8 @@ enter_file (name)
   lname = (char *)malloc (strlen (name) + 1);
   for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
     {
-      if (isupper(*n))
-	*ln = tolower(*n);
+      if (isupper((unsigned char)*n))
+	*ln = tolower((unsigned char)*n);
       else
 	*ln = *n;
     }
diff --git a/function.c b/function.c
index f6f482a..1a08845 100644
--- a/function.c
+++ b/function.c
@@ -551,7 +551,7 @@ func_basename_dir(o, argv, funcname)
   char *p3 = argv[0];
   char *p2=0;
   int doneany=0;
-  int len=0;
+  unsigned int len=0;
   char *p=0;
   int is_basename= streq(funcname, "basename");
   int is_dir= !is_basename;
@@ -611,9 +611,9 @@ func_addsuffix_addprefix(o, argv, funcname)
   int is_addprefix = streq (funcname, "addprefix");
   int is_addsuffix = !is_addprefix;
 
-  int doneany =0;
-  char *p=0;
-  int len =0;
+  int doneany = 0;
+  char *p;
+  unsigned int len;
 
   while ((p = find_next_token (&list_iterator, &len)) != 0)
     {
@@ -652,8 +652,8 @@ func_firstword(o, argv, funcname)
      char **argv;
      const char *funcname;
 {
-  int i=0;
-  char *words = argv[0];
+  unsigned int i;
+  char *words = argv[0];    /* Use a temp variable for find_next_token */
   char *p = find_next_token (&words, &i);
 
   if (p != 0)
@@ -688,9 +688,9 @@ strip_whitespace (begpp, endpp)
      char **begpp;
      char **endpp;
 {
-  while (isspace (**begpp) && *begpp <= *endpp)
+  while (isspace ((unsigned char)**begpp) && *begpp <= *endpp)
     (*begpp) ++;
-  while (isspace (**endpp) && *endpp >= *begpp)
+  while (isspace ((unsigned char)**endpp) && *endpp >= *begpp)
     (*endpp) --;
   return *begpp;
 }
@@ -818,11 +818,11 @@ func_foreach (o, argv, funcname)
   char *list = expand_argument (argv[1], argv[2] -1);
   char *body = savestring (argv[2], argv[3] - argv[2] - 1);
 
-  int len =0;
+  int doneany = 0;
   char *list_iterator = list;
   char *p;
-  register struct variable *var=0;
-  int doneany =0;
+  unsigned int len;
+  register struct variable *var;
 
   push_new_variable_scope ();
   var = define_variable (varname, strlen (varname), "", o_automatic, 0);
@@ -874,16 +874,15 @@ func_filter_filterout (o, argv, funcname)
      char **argv;
      const char *funcname;
 {
-  struct  a_word   *wordhead =0;
-  struct  a_word *wordtail =0;
+  struct a_word *wordhead = 0;
+  struct a_word *wordtail = 0;
 
   int is_filter = streq (funcname, "filter");
   char *patterns = argv[0];
-
+  char *word_iterator = argv[1];
 
   char *p;
-  int len;
-  char *word_iterator = argv[1];
+  unsigned int len;
 
   /* Chop ARGV[1] up into words and then run each pattern through.  */
   while ((p = find_next_token (&word_iterator, &len)) != 0)
@@ -904,13 +903,12 @@ func_filter_filterout (o, argv, funcname)
 
   if (wordhead != 0)
     {
-      struct  a_word *wp =0;
       char *pat_iterator = patterns;
       int doneany = 0;
+      struct a_word *wp;
 
       wordtail->next = 0;
 
-
       /* Run each pattern through the words, killing words.  */
       while ((p = find_next_token (&pat_iterator, &len)) != 0)
 	{
@@ -958,10 +956,10 @@ func_strip(o, argv, funcname)
       int i=0;
       char *word_start=0;
 
-      while (isspace(*p))
+      while (isspace ((unsigned char)*p))
 	++p;
       word_start = p;
-      for (i=0; *p != '\0' && !isspace(*p); ++p, ++i)
+      for (i=0; *p != '\0' && !isspace ((unsigned char)*p); ++p, ++i)
 	{}
       if (!i)
 	break;
@@ -1031,15 +1029,15 @@ func_sort (o, argv, funcname)
 
   /* Chop ARGV[0] into words and put them in WORDS.  */
   char *t = argv[0];
-  char *p=0;
-  int len;
+  char *p;
+  unsigned int len;
   int i;
 
   while ((p = find_next_token (&t, &len)) != 0)
     {
       if (wordi >= nwords - 1)
 	{
-	  nwords = 2* nwords + 5;
+	  nwords = (2 * nwords) + 5;
 	  words = (char **) xrealloc ((char *) words,
 				      nwords * sizeof (char *));
 	}
@@ -1599,7 +1597,7 @@ func_not (char* o, char **argv, char *funcname)
 {
   char * s = argv[0];
   int result = 0;
-  while (isspace (*s))
+  while (isspace ((unsigned char)*s))
     s++;
   result = ! (*s);
   o = variable_buffer_output (o,  result ? "1" : "", result);
@@ -1814,7 +1812,7 @@ func_call (o, argv, funcname)
 
   flen = strlen (argv[0]);
   fname = argv[0] + flen - 1;
-  while (isspace (*fname))
+  while (isspace ((unsigned char)*fname))
     --fname;
   fname[1] = '\0';
 
diff --git a/implicit.c b/implicit.c
index 5ff7e18..c60cbe3 100644
--- a/implicit.c
+++ b/implicit.c
@@ -88,7 +88,7 @@ pattern_search (file, archive, depth, recursions)
      unsigned int recursions;
 {
   /* Filename we are searching for a rule for.  */
-  char *filename = archive ? index (file->name, '(') : file->name;
+  char *filename = archive ? strchr (file->name, '(') : file->name;
 
   /* Length of FILENAME.  */
   unsigned int namelen = strlen (filename);
@@ -165,14 +165,14 @@ pattern_search (file, archive, depth, recursions)
 	 but not counting any slash at the end.  (foo/bar/ counts as
 	 bar/ in directory foo/, not empty in directory foo/bar/.)  */
 #ifdef VMS
-      lastslash = rindex (filename, ']');
+      lastslash = strrchr (filename, ']');
 #else
-      lastslash = rindex (filename, '/');
+      lastslash = strrchr (filename, '/');
 #if defined(__MSDOS__) || defined(WINDOWS32)
       /* Handle backslashes (possibly mixed with forward slashes)
 	 and the case of "d:file".  */
       {
-	char *bslash = rindex (filename, '\\');
+	char *bslash = strrchr (filename, '\\');
 	if (lastslash == 0 || bslash > lastslash)
 	  lastslash = bslash;
 	if (lastslash == 0 && filename[0] && filename[1] == ':')
@@ -228,9 +228,9 @@ pattern_search (file, archive, depth, recursions)
 	     prefix and the target pattern does not contain a slash.  */
 
 #ifdef VMS
-	  check_lastslash = lastslash != 0 && index (target, ']') == 0;
+	  check_lastslash = lastslash != 0 && strchr (target, ']') == 0;
 #else
-	  check_lastslash = lastslash != 0 && index (target, '/') == 0;
+	  check_lastslash = lastslash != 0 && strchr (target, '/') == 0;
 #endif
 	  if (check_lastslash)
 	    {
@@ -346,7 +346,7 @@ pattern_search (file, archive, depth, recursions)
               struct file *fp;
 
 	      /* If the dependency name has a %, substitute the stem.  */
-	      p = index (dep_name (dep), '%');
+	      p = strchr (dep_name (dep), '%');
 	      if (p != 0)
 		{
 		  register unsigned int i;
diff --git a/job.c b/job.c
index 263bc3d..4213dec 100644
--- a/job.c
+++ b/job.c
@@ -1257,7 +1257,7 @@ new_job (file)
 	 IN gets ahead of OUT.  */
 
       in = out = cmds->command_lines[i];
-      while ((ref = index (in, '$')) != 0)
+      while ((ref = strchr (in, '$')) != 0)
 	{
 	  ++ref;		/* Move past the $.  */
 
@@ -2099,12 +2099,12 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
 	     If we see any of those, punt.
 	     But on MSDOS, if we use COMMAND.COM, double and single
 	     quotes have the same effect.  */
-	  else if (instring == '"' && index ("\\$`", *p) != 0 && unixy_shell)
+	  else if (instring == '"' && strchr ("\\$`", *p) != 0 && unixy_shell)
 	    goto slow;
 	  else
 	    *ap++ = *p;
 	}
-      else if (index (sh_chars, *p) != 0)
+      else if (strchr (sh_chars, *p) != 0)
 	/* Not inside a string, but it's a special char.  */
 	goto slow;
 #ifdef  __MSDOS__
@@ -2181,8 +2181,9 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
                   }
                 else
 #endif
-                  if (p[1] != '\\' && p[1] != '\'' && !isspace (p[1])
-                      && (index (sh_chars_sh, p[1]) == 0))
+                  if (p[1] != '\\' && p[1] != '\''
+                      && !isspace ((unsigned char)p[1])
+                      && (strchr (sh_chars_sh, p[1]) == 0))
                     /* back up one notch, to copy the backslash */
                     --p;
 
@@ -2330,7 +2331,7 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
    */
 
   /* Make sure not to bother processing an empty line.  */
-  while (isspace (*line))
+  while (isspace ((unsigned char)*line))
     ++line;
   if (*line == '\0')
     return 0;
@@ -2347,14 +2348,14 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
 
     char *new_line = (char *) alloca (shell_len + (sizeof (minus_c) - 1)
 				      + (line_len * 2) + 1);
-    char* command_ptr = NULL; /* used for batch_mode_shell mode */
+    char *command_ptr = NULL; /* used for batch_mode_shell mode */
 
     ap = new_line;
     bcopy (shell, ap, shell_len);
     ap += shell_len;
     bcopy (minus_c, ap, sizeof (minus_c) - 1);
     ap += sizeof (minus_c) - 1;
-	command_ptr = ap;
+    command_ptr = ap;
     for (p = line; *p != '\0'; ++p)
       {
 	if (restp != NULL && *p == '\n')
@@ -2387,8 +2388,8 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
         /* DOS shells don't know about backslash-escaping.  */
 	if (unixy_shell && !batch_mode_shell &&
             (*p == '\\' || *p == '\'' || *p == '"'
-             || isspace (*p)
-             || index (sh_chars, *p) != 0))
+             || isspace ((unsigned char)*p)
+             || strchr (sh_chars, *p) != 0))
 	  *ap++ = '\\';
 #ifdef __MSDOS__
         else if (unixy_shell && strneq (p, "...", 3))
@@ -2447,7 +2448,7 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
       fclose (batch);
 
       /* create argv */
-      new_argv = (char **) xmalloc(3 * sizeof(char *));
+      new_argv = (char **) xmalloc(3 * sizeof (char *));
       if (unixy_shell) {
         new_argv[0] = xstrdup (shell);
         new_argv[1] = *batch_filename_ptr; /* only argv[0] gets freed later */
@@ -2461,7 +2462,7 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
     if (unixy_shell)
       new_argv = construct_command_argv_internal (new_line, (char **) NULL,
                                                   (char *) 0, (char *) 0,
-                                                  (char *) 0);
+                                                  (char **) 0);
 #ifdef  __MSDOS__
     else
       {
diff --git a/main.c b/main.c
index 4065265..4ea4f66 100644
--- a/main.c
+++ b/main.c
@@ -73,7 +73,7 @@ static void print_version PARAMS ((void));
 static void decode_switches PARAMS ((int argc, char **argv, int env));
 static void decode_env_switches PARAMS ((char *envar, unsigned int len));
 static void define_makeflags PARAMS ((int all, int makefile));
-static char *quote_as_word PARAMS ((char *out, char *in, int double_dollars));
+static char *quote_for_env PARAMS ((char *out, char *in));
 
 /* The structure that describes an accepted command switch.  */
 
@@ -784,18 +784,18 @@ int main (int argc, char ** argv)
   else
     {
 #ifdef VMS
-      program = rindex (argv[0], ']');
+      program = strrchr (argv[0], ']');
 #else
-      program = rindex (argv[0], '/');
+      program = strrchr (argv[0], '/');
 #endif
 #ifdef __MSDOS__
       if (program == 0)
-	program = rindex (argv[0], '\\');
+	program = strrchr (argv[0], '\\');
       else
 	{
 	  /* Some weird environments might pass us argv[0] with
 	     both kinds of slashes; we must find the rightmost.  */
-	  char *p = rindex (argv[0], '\\');
+	  char *p = strrchr (argv[0], '\\');
 	  if (p && p > program)
 	    program = p;
 	}
@@ -983,7 +983,7 @@ int main (int argc, char ** argv)
     argv[0] = concat (current_directory, "/", argv[0]);
 #else  /* !__MSDOS__ */
   if (current_directory[0] != '\0'
-      && argv[0] != 0 && argv[0][0] != '/' && index (argv[0], '/') != 0)
+      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0)
     argv[0] = concat (current_directory, "/", argv[0]);
 #endif /* !__MSDOS__ */
 #endif /* WINDOWS32 */
@@ -1010,7 +1010,8 @@ int main (int argc, char ** argv)
 	  if (! v->recursive)
 	    ++len;
 	  ++len;
-	  len += 3 * strlen (v->value);
+	  len += 2 * strlen (v->value);
+	  ++len;
 	}
 
       /* Now allocate a buffer big enough and fill it.  */
@@ -1018,11 +1019,11 @@ int main (int argc, char ** argv)
       for (cv = command_variables; cv != 0; cv = cv->next)
 	{
 	  v = cv->variable;
-	  p = quote_as_word (p, v->name, 0);
+	  p = quote_for_env (p, v->name);
 	  if (! v->recursive)
 	    *p++ = ':';
 	  *p++ = '=';
-	  p = quote_as_word (p, v->value, 0);
+	  p = quote_for_env (p, v->value);
 	  *p++ = ' ';
 	}
       p[-1] = '\0';		/* Kill the final space and terminate.  */
@@ -2012,6 +2013,8 @@ print_usage (bad)
 	       - DESCRIPTION_COLUMN,
 	       buf, cs->description);
     }
+
+  fprintf (usageto, _("\nReport bugs to <bug-make@gnu.org>.\n"));
 }
 
 /* Decode switches from ARGC and ARGV.
@@ -2211,7 +2214,7 @@ decode_env_switches (envar, len)
   argv[argc] = p;
   while (*value != '\0')
     {
-      if (*value == '\\')
+      if (*value == '\\' && value[1] != '\0')
 	++value;		/* Skip the backslash.  */
       else if (isblank (*value))
 	{
@@ -2228,7 +2231,7 @@ decode_env_switches (envar, len)
   *p = '\0';
   argv[++argc] = 0;
 
-  if (argv[1][0] != '-' && index (argv[1], '=') == 0)
+  if (argv[1][0] != '-' && strchr (argv[1], '=') == 0)
     /* The first word doesn't start with a dash and isn't a variable
        definition.  Add a dash and pass it along to decode_switches.  We
        need permanent storage for this in case decode_switches saves
@@ -2240,27 +2243,21 @@ decode_env_switches (envar, len)
 }
 
 /* Quote the string IN so that it will be interpreted as a single word with
-   no magic by the shell; if DOUBLE_DOLLARS is nonzero, also double dollar
-   signs to avoid variable expansion in make itself.  Write the result into
-   OUT, returning the address of the next character to be written.
-   Allocating space for OUT twice the length of IN (thrice if
-   DOUBLE_DOLLARS is nonzero) is always sufficient.  */
+   no magic by decode_env_switches; also double dollar signs to avoid
+   variable expansion in make itself.  Write the result into OUT, returning
+   the address of the next character to be written.
+   Allocating space for OUT twice the length of IN is always sufficient.  */
 
 static char *
-quote_as_word (out, in, double_dollars)
+quote_for_env (out, in)
      char *out, *in;
-     int double_dollars;
 {
   while (*in != '\0')
     {
-#ifdef VMS
-      if (index ("^;'\"*?$<>(){}|&~`\\ \t\r\n\f\v", *in) != 0)
-#else
-      if (index ("^;'\"*?[]$<>(){}|&~`\\ \t\r\n\f\v", *in) != 0)
-#endif
-	*out++ = '\\';
-      if (double_dollars && *in == '$')
+      if (*in == '$')
 	*out++ = '$';
+      else if (isblank (*in) || *in == '\\')
+        *out++ = '\\';
       *out++ = *in++;
     }
 
@@ -2429,7 +2426,7 @@ define_makeflags (all, makefile)
 	    {
 	      /* Add its argument too.  */
 	      *p++ = !short_option (flags->cs->c) ? '=' : ' ';
-	      p = quote_as_word (p, flags->arg, 1);
+	      p = quote_for_env (p, flags->arg);
 	    }
 	  ++words;
 	  /* Write a following space and dash, for the next flag.  */
diff --git a/make.h b/make.h
index 73935e9..67ded3e 100644
--- a/make.h
+++ b/make.h
@@ -240,24 +240,8 @@ extern void exit PARAMS ((int)) __attribute__ ((noreturn));
 
 #endif /* Standard headers.  */
 
-#if ST_MTIM_NSEC
-# if HAVE_INTTYPES_H
-#  include <inttypes.h>
-# endif
-# define FILE_TIMESTAMP uintmax_t
-#else
-# define FILE_TIMESTAMP time_t
-#endif
-
 #ifdef  ANSI_STRING
 
-# ifndef index
-#  define index(s, c)       strchr((s), (c))
-# endif
-# ifndef rindex
-#  define rindex(s, c)      strrchr((s), (c))
-# endif
-
 # ifndef bcmp
 #  define bcmp(s1, s2, n)   memcmp ((s1), (s2), (n))
 # endif
@@ -270,6 +254,11 @@ extern void exit PARAMS ((int)) __attribute__ ((noreturn));
 
 #else   /* Not ANSI_STRING.  */
 
+# ifndef HAVE_STRCHR
+#  define strchr(s, c)      index((s), (c))
+#  define strrchr(s, c)     rindex((s), (c))
+# endif
+
 # ifndef bcmp
 extern int bcmp PARAMS ((const char *, const char *, int));
 # endif
@@ -303,6 +292,15 @@ extern char *alloca ();
 # endif /* HAVE_ALLOCA_H.  */
 #endif /* GCC.  */
 
+#if ST_MTIM_NSEC
+# if HAVE_INTTYPES_H
+#  include <inttypes.h>
+# endif
+# define FILE_TIMESTAMP uintmax_t
+#else
+# define FILE_TIMESTAMP time_t
+#endif
+
 /* ISDIGIT offers the following features:
    - Its arg may be any int or unsigned int; it need not be an unsigned char.
    - It's guaranteed to evaluate its argument exactly once.
@@ -321,8 +319,9 @@ extern char *alloca ();
 # ifdef HAVE_CASE_INSENSITIVE_FS
 /* This is only used on Windows/DOS platforms, so we assume strcmpi().  */
 #  define strieq(a, b) \
-    ((a) == (b) || \
-     (tolower(*(a)) == tolower(*(b)) && (*(a) == '\0' || !strcmpi ((a) + 1, (b) + 1))))
+    ((a) == (b) \
+     || (tolower((unsigned char)*(a)) == tolower((unsigned char)*(b)) \
+         && (*(a) == '\0' || !strcmpi ((a) + 1, (b) + 1))))
 # else
 #  define strieq(a, b) streq(a, b)
 # endif
@@ -338,7 +337,7 @@ extern char *alloca ();
   ((var += (c)), (var = ((var) << 7) + ((var) >> 20)))
 #ifdef HAVE_CASE_INSENSITIVE_FS /* Fold filenames */
 # define HASHI(var, c) \
-   ((var += tolower((c))), (var = ((var) << 7) + ((var) >> 20)))
+   ((var += tolower((unsigned char)(c))), (var = ((var) << 7) + ((var) >> 20)))
 #else
 # define HASHI(var, c) HASH(var,c)
 #endif
diff --git a/misc.c b/misc.c
index c1d43fc..2447bc5 100644
--- a/misc.c
+++ b/misc.c
@@ -81,7 +81,7 @@ collapse_continuations (line)
   register int backslash;
   register unsigned int bs_write;
 
-  in = index (line, '\n');
+  in = strchr (line, '\n');
   if (in == 0)
     return;
 
diff --git a/read.c b/read.c
index ed9a2b0..e8dcee4 100644
--- a/read.c
+++ b/read.c
@@ -177,9 +177,9 @@ read_all_makefiles (makefiles)
 
     while ((name = find_next_token (&p, &length)) != 0)
       {
-        name = xstrdup (name);
 	if (*p != '\0')
 	  *p++ = '\0';
+        name = xstrdup (name);
 	if (read_makefile (name,
                            RM_NO_DEFAULT_GOAL|RM_INCLUDED|RM_DONTCARE) < 2)
           free (name);
@@ -478,7 +478,7 @@ read_makefile (filename, flags)
       /* Compare a word, both length and contents. */
 #define	word1eq(s, l) 	(len == l && strneq (s, p, l))
       p = collapsed;
-      while (isspace (*p))
+      while (isspace ((unsigned char)*p))
 	++p;
       if (*p == '\0')
 	/* This line is completely empty.  */
@@ -488,7 +488,7 @@ read_makefile (filename, flags)
        * ":" here since we compare tokens by length (so "export" will never
        * be equal to "export:").
        */
-      for (p2 = p+1; *p2 != '\0' && !isspace(*p2); ++p2)
+      for (p2 = p+1; *p2 != '\0' && !isspace ((unsigned char)*p2); ++p2)
         {}
       len = p2 - p;
 
@@ -496,7 +496,7 @@ read_makefile (filename, flags)
          since it can't be a preprocessor token--this allows targets named
          `ifdef', `export', etc. */
       reading_target = 0;
-      while (isspace (*p2))
+      while (isspace ((unsigned char)*p2))
         ++p2;
       if (*p2 == '\0')
         p2 = NULL;
@@ -546,7 +546,7 @@ read_makefile (filename, flags)
 		 with trailing blanks stripped (comments have already been
 		 removed), so it could be a complex variable/function
 		 reference that might contain blanks.  */
-	      p = index (p2, '\0');
+	      p = strchr (p2, '\0');
 	      while (isblank (p[-1]))
 		--p;
 	      do_define (p2, p - p2, o_file, infile, &fileinfo);
@@ -573,7 +573,7 @@ read_makefile (filename, flags)
 		     with trailing blanks stripped (comments have already been
 		     removed), so it could be a complex variable/function
 		     reference that might contain blanks.  */
-		  p = index (p2, '\0');
+		  p = strchr (p2, '\0');
 		  while (isblank (p[-1]))
 		    --p;
 		  do_define (p2, p - p2, o_override, infile, &fileinfo);
@@ -837,8 +837,8 @@ read_makefile (filename, flags)
 		 are whitespace and a left paren.  If others are possible,
 		 they should be added to the string in the call to index.  */
 	      while (colonp && (colonp[1] == '/' || colonp[1] == '\\') &&
-		     colonp > p2 && isalpha(colonp[-1]) &&
-		     (colonp == p2 + 1 || index(" \t(", colonp[-2]) != 0))
+		     colonp > p2 && isalpha ((unsigned char)colonp[-1]) &&
+		     (colonp == p2 + 1 || strchr (" \t(", colonp[-2]) != 0))
 		colonp = find_char_unquote(colonp + 1, ":", 0);
 #endif
               if (colonp != 0)
@@ -957,7 +957,7 @@ read_makefile (filename, flags)
             }
 
 	  /* Is this a static pattern rule: `target: %targ: %dep; ...'?  */
-	  p = index (p2, ':');
+	  p = strchr (p2, ':');
 	  while (p != 0 && p[-1] == '\\')
 	    {
 	      register char *q = &p[-1];
@@ -965,7 +965,7 @@ read_makefile (filename, flags)
 	      while (*q-- == '\\')
 		backslash = !backslash;
 	      if (backslash)
-		p = index (p + 1, ':');
+		p = strchr (p + 1, ':');
 	      else
 		break;
 	    }
@@ -982,7 +982,8 @@ read_makefile (filename, flags)
 	    The rule is that it's only a target, if there are TWO :'s
 	    OR a space around the :.
 	  */
-	  if (p && !(isspace(p[1]) || !p[1] || isspace(p[-1])))
+	  if (p && !(isspace ((unsigned char)p[1]) || !p[1]
+                     || isspace ((unsigned char)p[-1])))
 	    p = 0;
 #endif
 #if defined (WINDOWS32) || defined (__MSDOS__)
@@ -990,9 +991,9 @@ read_makefile (filename, flags)
             check_again = 0;
             /* For MSDOS and WINDOWS32, skip a "C:\..." or a "C:/..." */
             if (p != 0 && (p[1] == '\\' || p[1] == '/') &&
-		isalpha(p[-1]) &&
-		(p == p2 + 1 || index(" \t:(", p[-2]) != 0)) {
-              p = index(p + 1, ':');
+		isalpha ((unsigned char)p[-1]) &&
+		(p == p2 + 1 || strchr (" \t:(", p[-2]) != 0)) {
+              p = strchr (p + 1, ':');
               check_again = 1;
             }
           } while (check_again);
@@ -1741,9 +1742,9 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
       /* See if this is first target seen whose name does
 	 not start with a `.', unless it contains a slash.  */
       if (default_goal_file == 0 && set_default
-	  && (*name != '.' || index (name, '/') != 0
+	  && (*name != '.' || strchr (name, '/') != 0
 #if defined(__MSDOS__) || defined(WINDOWS32)
-			   || index (name, '\\') != 0
+			   || strchr (name, '\\') != 0
 #endif
 	      ))
 	{
@@ -1806,7 +1807,7 @@ find_char_unquote (string, stopchars, blank)
 
   while (1)
     {
-      while (*p != '\0' && index (stopchars, *p) == 0
+      while (*p != '\0' && strchr (stopchars, *p) == 0
 	     && (!blank || !isblank (*p)))
 	++p;
       if (*p == '\0')
@@ -1905,8 +1906,9 @@ parse_file_seq (stringp, stopchar, size, strip)
 	*p =' ';
 #endif
 #ifdef _AMIGA
-      if (stopchar == ':' && p && *p == ':' &&
-	!(isspace(p[1]) || !p[1] || isspace(p[-1])))
+      if (stopchar == ':' && p && *p == ':'
+          && !(isspace ((unsigned char)p[1]) || !p[1]
+               || isspace ((unsigned char)p[-1])))
       {
 	p = find_char_unquote (p+1, stopchars, 1);
       }
@@ -1917,8 +1919,8 @@ parse_file_seq (stringp, stopchar, size, strip)
        Note that tokens separated by spaces should be treated as separate
        tokens since make doesn't allow path names with spaces */
     if (stopchar == ':')
-      while (p != 0 && !isspace(*p) &&
-             (p[1] == '\\' || p[1] == '/') && isalpha (p[-1]))
+      while (p != 0 && !isspace ((unsigned char)*p) &&
+             (p[1] == '\\' || p[1] == '/') && isalpha ((unsigned char)p[-1]))
         p = find_char_unquote (p + 1, stopchars, 1);
 #endif
       if (p == 0)
@@ -2000,14 +2002,14 @@ parse_file_seq (stringp, stopchar, size, strip)
   while (new1 != 0)
     if (new1->name[0] != '('	/* Don't catch "(%)" and suchlike.  */
 	&& new1->name[strlen (new1->name) - 1] == ')'
-	&& index (new1->name, '(') == 0)
+	&& strchr (new1->name, '(') == 0)
       {
 	/* NEW1 ends with a `)' but does not contain a `('.
 	   Look back for an elt with an opening `(' but no closing `)'.  */
 
 	struct nameseq *n = new1->next, *lastn = new1;
 	char *paren = 0;
-	while (n != 0 && (paren = index (n->name, '(')) == 0)
+	while (n != 0 && (paren = strchr (n->name, '(')) == 0)
 	  {
 	    lastn = n;
 	    n = n->next;
@@ -2288,7 +2290,7 @@ get_next_mword (buffer, delim, startp, length)
         }
 
     default:
-      if (delim && index(delim, c))
+      if (delim && strchr (delim, c))
         wtype = w_static;
       break;
     }
@@ -2325,9 +2327,9 @@ get_next_mword (buffer, delim, startp, length)
 	  /* A word CAN include a colon in its drive spec.  The drive
 	     spec is allowed either at the beginning of a word, or as part
 	     of the archive member name, like in "libfoo.a(d:/foo/bar.o)".  */
-	  if (!(p - beg >= 2 &&
-		(*p == '/' || *p == '\\') && isalpha (p[-2]) &&
-		(p - beg == 2 || p[-3] == '(')))
+	  if (!(p - beg >= 2
+		&& (*p == '/' || *p == '\\') && isalpha ((unsigned char)p[-2])
+		&& (p - beg == 2 || p[-3] == '(')))
 #endif
 	  goto done_word;
 
@@ -2379,7 +2381,7 @@ get_next_mword (buffer, delim, startp, length)
           break;
 
         default:
-          if (delim && index(delim, c))
+          if (delim && strchr (delim, c))
             goto done_word;
           break;
         }
@@ -2550,7 +2552,7 @@ tilde_expand (name)
   else
     {
       struct passwd *pwent;
-      char *userend = index (name + 1, '/');
+      char *userend = strchr (name + 1, '/');
       if (userend != 0)
 	*userend = '\0';
       pwent = getpwnam (name + 1);
diff --git a/remake.c b/remake.c
index 1d7ac08..a3653f3 100644
--- a/remake.c
+++ b/remake.c
@@ -744,9 +744,11 @@ notice_finished_file (file)
          would have been updated. */
 
       if (question_flag || just_print_flag)
-        for (i = file->cmds->ncommand_lines; i > 0; --i)
-          if (! (file->cmds->lines_flags[i-1] & COMMANDS_RECURSE))
-            break;
+        {
+          for (i = file->cmds->ncommand_lines; i > 0; --i)
+            if (! (file->cmds->lines_flags[i-1] & COMMANDS_RECURSE))
+              break;
+        }
 
       /* If there were no commands at all, it's always new. */
 
@@ -1232,7 +1234,7 @@ library_search (lib, mtime_ptr)
 
   /* Loop variables for the libpatterns value.  */
   char *p, *p2;
-  int len;
+  unsigned int len;
 
   char *file, **dp;
 
diff --git a/rule.c b/rule.c
index 4983325..90e04e3 100644
--- a/rule.c
+++ b/rule.c
@@ -108,11 +108,11 @@ count_implicit_rule_limits ()
 	  unsigned int len = strlen (dep->name);
 
 #ifdef VMS
-	  char *p = rindex (dep->name, ']');
+	  char *p = strrchr (dep->name, ']');
 #else
-	  char *p = rindex (dep->name, '/');
+	  char *p = strrchr (dep->name, '/');
 #endif
-	  char *p2 = p != 0 ? index (dep->name, '%') : 0;
+	  char *p2 = p != 0 ? strchr (dep->name, '%') : 0;
 	  ndeps++;
 
 	  if (len > max_pattern_dep_length)
diff --git a/tests/ChangeLog b/tests/ChangeLog
index 6c6387d..002b93c 100644
--- a/tests/ChangeLog
+++ b/tests/ChangeLog
@@ -1,3 +1,9 @@
+1999-10-15  Paul D. Smith  <psmith@gnu.org>
+
+	* scripts/variables/MAKEFILES: This was really broken: it didn't
+	test anything at all, really.  Rewrote it, plus added a test for
+	PR/1394.
+
 1999-10-13  Paul D. Smith  <psmith@gnu.org>
 
 	* scripts/options/dash-n: Add a test for PR/1379: "-n doesn't
diff --git a/tests/scripts/variables/CURDIR b/tests/scripts/variables/CURDIR
index a4054bc..ee7cacb 100644
--- a/tests/scripts/variables/CURDIR
+++ b/tests/scripts/variables/CURDIR
@@ -1,3 +1,5 @@
+#                                                                    -*-perl-*-
+
 $description = "This tests the CURDIR varaible.";
 
 $details = "Echo CURDIR both with and without -C.  Also ensure overrides work.";
diff --git a/tests/scripts/variables/MAKEFILES b/tests/scripts/variables/MAKEFILES
index d42909c..3be284b 100644
--- a/tests/scripts/variables/MAKEFILES
+++ b/tests/scripts/variables/MAKEFILES
@@ -1,37 +1,34 @@
-$description = "The following test creates a makefile to test ";
+#                                                                    -*-perl-*-
+
+$description = "Test the MAKEFILES variable.";
 
 $makefile2 = &get_tmpfile;
+$makefile3 = &get_tmpfile;
 
 open(MAKEFILE,"> $makefile");
-# The Contents of the MAKEFILE ...
-print MAKEFILE "MAKEFILES = work/MAKEFILES_variable.mk.2\n\n";
-print MAKEFILE "all:\n";
-print MAKEFILE "\t\@echo THIS IS THE DEFAULT RULE\n";
-# END of Contents of MAKEFILE
+print MAKEFILE 'all: ; @echo DEFAULT RULE: M2=$(M2) M3=$(M3)', "\n";
 close(MAKEFILE);
 
 
 open(MAKEFILE,"> $makefile2");
-print MAKEFILE "NDEF:\n";
-print MAKEFILE "\t\@echo THIS IS THE RULE FROM MAKEFILE 2\n";
+print MAKEFILE <<EOF;
+M2 = m2
+NDEF: ; \@echo RULE FROM MAKEFILE 2
+EOF
 close(MAKEFILE);
 
-&run_make_with_options($makefile,"",&get_logfile);
-
-
-# Create the answer to what should be produced by this Makefile
-$answer = "THIS IS THE DEFAULT RULE\n";
 
-# COMPARE RESULTS
+open(MAKEFILE,"> $makefile3");
+print MAKEFILE <<EOF;
+M3 = m3
+NDEF3: ; \@echo RULE FROM MAKEFILE 3
+EOF
+close(MAKEFILE);
 
-# In this call to compare output, you should use the call &get_logfile(1)
-# to send the name of the last logfile created.
 
+&run_make_with_options($makefile, "MAKEFILES='$makefile2 $makefile3'",
+                       &get_logfile);
+$answer = "DEFAULT RULE: M2=m2 M3=m3\n";
 &compare_output($answer,&get_logfile(1));
 
-# If you wish to stop if the compare fails, then add
-# a "|| &error ("abort")" to the
-# end of the previous line.
-
-# This tells the test driver that the perl test script executed properly.
 1;
diff --git a/variable.c b/variable.c
index 4eebb37..47e9da8 100644
--- a/variable.c
+++ b/variable.c
@@ -878,8 +878,8 @@ try_variable_definition (flocp, line, origin)
 	  char *fake_env[2];
 	  size_t pathlen = 0;
 
-	  shellbase = rindex (value, '/');
-	  bslash = rindex (value, '\\');
+	  shellbase = strrchr (value, '/');
+	  bslash = strrchr (value, '\\');
 	  if (!shellbase || bslash > shellbase)
 	    shellbase = bslash;
 	  if (!shellbase && value[1] == ':')
@@ -987,7 +987,7 @@ print_variable (v, prefix)
   fputs (prefix, stdout);
 
   /* Is this a `define'?  */
-  if (v->recursive && index (v->value, '\n') != 0)
+  if (v->recursive && strchr (v->value, '\n') != 0)
     printf ("define %s\n%s\nendef\n", v->name, v->value);
   else
     {
diff --git a/vmsfunctions.c b/vmsfunctions.c
index 2bc93bd..8356165 100644
--- a/vmsfunctions.c
+++ b/vmsfunctions.c
@@ -76,8 +76,8 @@ opendir (dspec)
     { \
       char *tmp; \
       for (tmp = (str); *tmp != '\0'; tmp++) \
-        if (islower (*tmp)) \
-          *tmp = toupper (*tmp); \
+        if (islower ((unsigned char)*tmp)) \
+          *tmp = toupper ((unsigned char)*tmp); \
     } \
   while (0)
 
diff --git a/vmsify.c b/vmsify.c
index b8b86a6..350ce15 100644
--- a/vmsify.c
+++ b/vmsify.c
@@ -78,8 +78,8 @@ copyto (char **to, char **from, char upto, int as_dir)
 	}
       else
 	{
-	  if (islower (**from))
-	    **to = toupper (**from);
+	  if (islower ((unsigned char)**from))
+	    **to = toupper ((unsigned char)**from);
 	  else
 	    **to = **from;
 	}
diff --git a/vpath.c b/vpath.c
index 56a967f..3401327 100644
--- a/vpath.c
+++ b/vpath.c
@@ -402,11 +402,11 @@ selective_vpath_search (path, file, mtime_ptr)
      NAME_DPLEN gets the length of the prefix; FILENAME gets the
      pointer to the name-within-directory and FLEN is its length.  */
 
-  n = rindex (*file, '/');
+  n = strrchr (*file, '/');
 #if defined (WINDOWS32) || defined (__MSDOS__)
   /* We need the rightmost slash or backslash.  */
   {
-    char *bslash = rindex(*file, '\\');
+    char *bslash = strrchr(*file, '\\');
     if (!n || bslash > n)
       n = bslash;
   }
-- 
cgit v1.0-41-gc330

