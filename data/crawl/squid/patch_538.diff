@@ -2,6 +2,7 @@
 #include "AccessLogEntry.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #include "ssl/support.h"
 
 #if USE_SSL
@@ -35,6 +35,7 @@
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
+#include "icp_opcode.h"
 #include "ip/Address.h"
 #include "HttpRequestMethod.h"
 #if ICAP_CLIENT
@@ -274,7 +275,7 @@ class ACLChecklist;
 class StoreEntry;
 
 /* Should be in 'AccessLog.h' as the driver */
-extern void accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
+extern void accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
 extern void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
 extern void accessLogRotate(void);
 extern void accessLogClose(void);
@@ -1,3 +1,5 @@
+#ifndef SQUID_CACHEDIGEST_H_
+#define SQUID_CACHEDIGEST_H_
 /*
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -30,13 +32,23 @@
  *
  */
 
-#ifndef SQUID_CACHEDIGEST_H_
-#define SQUID_CACHEDIGEST_H_
-
+/* for cache_key */
 #include "typedefs.h"
+
 class CacheDigestGuessStats;
 class StoreEntry;
 
+class CacheDigest {
+public:
+    /* public, read-only */
+    char *mask;         /* bit mask */
+    int mask_size;      /* mask size in bytes */
+    int capacity;       /* expected maximum for .count, not a hard limit */
+    int bits_per_entry;     /* number of bits allocated for each entry from capacity */
+    int count;          /* number of digested entries */
+    int del_count;      /* number of deletions performed so far */
+};
+
 extern CacheDigest *cacheDigestCreate(int capacity, int bpe);
 extern void cacheDigestDestroy(CacheDigest * cd);
 extern CacheDigest *cacheDigestClone(const CacheDigest * cd);
@@ -48,6 +48,7 @@
  */
 
 class HttpRequest;
+class CacheMgrPasswd;
 /**
  \ingroup CacheManagerAPI
  * a CacheManager - the menu system for interacting with squid.
@@ -83,7 +84,7 @@ class CacheManager
     Mgr::CommandPointer ParseUrl(const char *url);
     void ParseHeaders(const HttpRequest * request, Mgr::ActionParams &params);
     int CheckPassword(const Mgr::Command &cmd);
-    char *PasswdGet(cachemgr_passwd *, const char *);
+    char *PasswdGet(CacheMgrPasswd *, const char *);
 
     void registerProfile(const Mgr::ActionProfilePointer &profile);
 
@@ -0,0 +1,36 @@
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "CacheMgrPasswd.h"
+
+
@@ -0,0 +1,47 @@
+#ifndef SQUID_CACHEMGRPASSWD_H_
+#define SQUID_CACHEMGRPASSWD_H_
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class wordlist;
+
+//TODO: this class is misnamed and C-ish. Split into CacheMgrPasswd and
+// CacheMgrPasswdList (std::list-derived)
+class CacheMgrPasswd {
+public:
+    char *passwd;
+    wordlist *actions;
+    CacheMgrPasswd *next;
+};
+
+
+#endif /* SQUID_CACHEMGRPASSWD_H_ */
@@ -0,0 +1,206 @@
+#ifndef SQUID_CACHEPEER_H_
+#define SQUID_CACHEPEER_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "enums.h"
+#include "icp_opcode.h"
+#include "ip/Address.h"
+
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
+
+class domain_ping;
+class domain_type;
+class acl_access;
+class PeerDigest;
+
+class CachePeer {
+public:
+    u_int index;
+    char *name;
+    char *host;
+    peer_t type;
+
+    Ip::Address in_addr;
+
+    struct {
+        int pings_sent;
+        int pings_acked;
+        int fetches;
+        int rtt;
+        int ignored_replies;
+        int n_keepalives_sent;
+        int n_keepalives_recv;
+        time_t probe_start;
+        time_t last_query;
+        time_t last_reply;
+        time_t last_connect_failure;
+        time_t last_connect_probe;
+        int logged_state;   /* so we can print dead/revived msgs */
+        int conn_open;      /* current opened connections */
+    } stats;
+
+    struct {
+        int version;
+        int counts[ICP_END+1];
+        unsigned short port;
+    } icp;
+
+#if USE_HTCP
+    struct {
+        double version;
+        int counts[2];
+        unsigned short port;
+    } htcp;
+#endif
+
+    unsigned short http_port;
+    domain_ping *peer_domain;
+    domain_type *typelist;
+    acl_access *access;
+
+    struct {
+        unsigned int proxy_only:1;
+        unsigned int no_query:1;
+        unsigned int background_ping:1;
+        unsigned int no_digest:1;
+        unsigned int default_parent:1;
+        unsigned int roundrobin:1;
+        unsigned int weighted_roundrobin:1;
+        unsigned int mcast_responder:1;
+        unsigned int closest_only:1;
+#if USE_HTCP
+        unsigned int htcp:1;
+        unsigned int htcp_oldsquid:1;
+        unsigned int htcp_no_clr:1;
+        unsigned int htcp_no_purge_clr:1;
+        unsigned int htcp_only_clr:1;
+        unsigned int htcp_forward_clr:1;
+#endif
+        unsigned int no_netdb_exchange:1;
+#if USE_DELAY_POOLS
+        unsigned int no_delay:1;
+#endif
+        unsigned int allow_miss:1;
+        unsigned int carp:1;
+        struct {
+            unsigned int set:1; //If false, whole url is to be used. Overrides others
+            unsigned int scheme:1;
+            unsigned int host:1;
+            unsigned int port:1;
+            unsigned int path:1;
+            unsigned int params:1;
+        } carp_key;
+#if USE_AUTH
+        unsigned int userhash:1;
+#endif
+        unsigned int sourcehash:1;
+        unsigned int originserver:1;
+        unsigned int no_tproxy:1;
+#if PEER_MULTICAST_SIBLINGS
+        unsigned int mcast_siblings:1;
+#endif
+    } options;
+
+    int weight;
+    int basetime;
+
+    struct {
+        double avg_n_members;
+        int n_times_counted;
+        int n_replies_expected;
+        int ttl;
+        int id;
+
+        struct {
+            unsigned int count_event_pending:1;
+            unsigned int counting:1;
+        } flags;
+    } mcast;
+#if USE_CACHE_DIGESTS
+
+    PeerDigest *digest;
+    char *digest_url;
+#endif
+
+    int tcp_up;         /* 0 if a connect() fails */
+
+    Ip::Address addresses[10];
+    int n_addresses;
+    int rr_count;
+    CachePeer *next;
+    int testing_now;
+
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } carp;
+#if USE_AUTH
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } userhash;
+#endif
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } sourcehash;
+
+    char *login;        /* Proxy authorization */
+    time_t connect_timeout;
+    int connect_fail_limit;
+    int max_conn;
+    char *domain;       /* Forced domain */
+#if USE_SSL
+
+    int use_ssl;
+    char *sslcert;
+    char *sslkey;
+    int sslversion;
+    char *ssloptions;
+    char *sslcipher;
+    char *sslcafile;
+    char *sslcapath;
+    char *sslcrlfile;
+    char *sslflags;
+    char *ssldomain;
+    SSL_CTX *sslContext;
+    SSL_SESSION *sslSession;
+#endif
+
+    int front_end_https;
+    int connection_auth;
+};
+
+#endif /* SQUID_CACHEPEER_H_ */
@@ -9,6 +9,7 @@
 #include "CpuAffinitySet.h"
 #include "Debug.h"
 #include "globals.h"
+#include "SquidConfig.h"
 #include "structs.h"
 #include "tools.h"
 
@@ -39,6 +39,7 @@
 #if USE_DELAY_POOLS
 #include "DelayBucket.h"
 #include "DelaySpec.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 void
@@ -48,6 +48,7 @@
 #include "DelayPool.h"
 #include "DelayPools.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 
 DelayId::DelayId () : pool_ (0), compositeId(NULL), markedAsNoDelay(false)
 {}
@@ -41,6 +41,7 @@
 #include "fd.h"
 #include "Store.h"
 #include "StatCounters.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 #include "unlinkd.h"
@@ -38,8 +38,8 @@
 #include "DiskThreadsIOStrategy.h"
 #include "fde.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
-/* for statfs */
 #include "Store.h"
 
 void
@@ -36,16 +36,17 @@
 
 #include "squid.h"
 #include "DiskThreads.h"
-
-#include	<stdio.h>
-#include	<sys/stat.h>
-#include	<fcntl.h>
-#include	<pthread.h>
-#include	<errno.h>
-#include	<dirent.h>
-#include	<signal.h>
+#include "SquidConfig.h"
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <errno.h>
+#include <dirent.h>
+#include <signal.h>
 #if HAVE_SCHED_H
-#include	<sched.h>
+#include <sched.h>
 #endif
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "SquidTime.h"
@@ -36,15 +36,16 @@
 #include "squid_windows.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "DiskThreads.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
-#include	<stdio.h>
-#include	<sys/stat.h>
-#include	<fcntl.h>
-#include	<errno.h>
-#include	<dirent.h>
-#include	<signal.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <signal.h>
 
 #define RIDICULOUS_LENGTH	4096
 
@@ -18,6 +18,7 @@
 #include "ipc/Queue.h"
 #include "ipc/StrandSearch.h"
 #include "ipc/UdsOp.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "tools.h"
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "base/StringArea.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "HttpHdrCc.h"
@@ -37,6 +37,8 @@
 #include "squid.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
+#include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "Store.h"
@@ -64,6 +66,7 @@ static const HttpHeaderFieldAttrs ScAttrs[SC_ENUM_END] = {
     {"Other,", (http_hdr_type)SC_OTHER}	/* ',' will protect from matches */
 };
 
+class HttpHeaderFieldInfo;
 HttpHeaderFieldInfo *ScFieldsInfo = NULL;
 
 http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader)
@@ -36,6 +36,7 @@
 #include "HttpHdrContRange.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "MemBuf.h"
@@ -45,6 +46,7 @@
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "TimeOrTag.h"
 
@@ -161,6 +163,7 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] = {
     {"Other:", HDR_OTHER, ftStr}	/* ':' will not allow matches */
 };
 
+class HttpHeaderFieldInfo;
 static HttpHeaderFieldInfo *Headers = NULL;
 
 http_hdr_type &operator++ (http_hdr_type &aHeader)
@@ -178,7 +178,8 @@ typedef enum {
     hoEnd
 } http_hdr_owner_type;
 
-struct _HttpHeaderFieldAttrs {
+class HttpHeaderFieldAttrs {
+public:
     const char *name;
     http_hdr_type id;
     field_type type;
@@ -0,0 +1,49 @@
+#ifndef SQUID_HTTPHEADERFIELDINFO_H_
+#define SQUID_HTTPHEADERFIELDINFO_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "SquidString.h"
+#include "HttpHeaderFieldStat.h"
+
+/* compiled version of HttpHeaderFieldAttrs plus stats */
+class HttpHeaderFieldInfo
+{
+public:
+    HttpHeaderFieldInfo() : id (HDR_ACCEPT), type (ftInvalid) {}
+
+    http_hdr_type id;
+    String name;
+    field_type type;
+    HttpHeaderFieldStat stat;
+};
+
+
+
+#endif /* SQUID_HTTPHEADERFIELDINFO_H_ */
@@ -0,0 +1,51 @@
+#ifndef SQUID_HTTPHEADERFIELDSTAT_H_
+#define SQUID_HTTPHEADERFIELDSTAT_H_
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// per field statistics
+class HttpHeaderFieldStat
+{
+public:
+    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0) {}
+
+    int aliveCount;     /* created but not destroyed (count) */
+    int seenCount;      /* #fields we've seen */
+    int parsCount;      /* #parsing attempts */
+    int errCount;       /* #pasring errors */
+    int repCount;       /* #repetitons */
+};
+
+
+
+
+#endif /* SQUID_HTTPHEADERFIELDSTAT_H_ */
@@ -40,9 +40,11 @@
 #include "fde.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderTools.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StrList.h"
 
@@ -19,11 +19,11 @@ class HeaderWithAcl;
 typedef std::list<HeaderWithAcl> HeaderWithAclList;
 
 class acl_access;
-struct _header_mangler {
+class header_mangler {
+public:
     acl_access *access_list;
     char *replacement;
 };
-typedef struct _header_mangler header_mangler;
 
 class StoreEntry;
 
@@ -94,10 +94,10 @@ class HeaderWithAcl
 
 extern int httpHeaderParseOffset(const char *start, int64_t * off);
 
-class HttpHeaderFieldInfo;
 class String;
 class HttpHeader;
 class HttpRequest;
+class HttpHeaderFieldInfo;
 
 extern HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
 extern void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
@@ -38,6 +38,7 @@
 #include "MemBuf.h"
 #include "mime_header.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
         cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
@@ -1,8 +1,9 @@
 #include "squid.h"
 #include "Debug.h"
 #include "HttpParser.h"
-#include "structs.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
+#include "structs.h"
 
 void
 HttpParser::clear()
@@ -41,6 +41,7 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
@@ -45,6 +45,7 @@
 #include "HttpRequest.h"
 #include "log/Config.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 
@@ -419,27 +420,6 @@ HttpRequest::hdrCacheInit()
     range = header.getRange();
 }
 
-/* request_flags */
-bool
-request_flags::resetTCP() const
-{
-    return reset_tcp != 0;
-}
-
-void
-request_flags::setResetTCP()
-{
-    debugs(73, 9, "request_flags::setResetTCP");
-    reset_tcp = 1;
-}
-
-void
-request_flags::clearResetTCP()
-{
-    debugs(73, 9, "request_flags::clearResetTCP");
-    reset_tcp = 0;
-}
-
 #if ICAP_CLIENT
 Adaptation::Icap::History::Pointer
 HttpRequest::icapHistory() const
@@ -492,27 +472,6 @@ HttpRequest::multipartRangeRequest() const
     return (range && range->specs.count > 1);
 }
 
-void
-request_flags::destinationIPLookupCompleted()
-{
-    destinationIPLookedUp_ = true;
-}
-
-bool
-request_flags::destinationIPLookedUp() const
-{
-    return destinationIPLookedUp_;
-}
-
-request_flags
-request_flags::cloneAdaptationImmune() const
-{
-    // At the time of writing, all flags where either safe to copy after
-    // adaptation or were not set at the time of the adaptation. If there
-    // are flags that are different, they should be cleared in the clone.
-    return *this;
-}
-
 bool
 HttpRequest::bodyNibbled() const
 {
@@ -622,7 +581,7 @@ HttpRequest::cacheable() const
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoof_client_ip))
+    if (!flags.hostVerified() && (flags.intercepted() || flags.spoofClientIp()))
         return false;
 
     if (protocol == AnyP::PROTO_HTTP)
@@ -652,7 +611,7 @@ HttpRequest::cacheable() const
 bool
 HttpRequest::conditional() const
 {
-    return flags.ims ||
+    return flags.hasIMS() ||
            header.has(HDR_IF_MATCH) ||
            header.has(HDR_IF_NONE_MATCH);
 }
@@ -33,9 +33,11 @@
 
 #include "base/CbcPointer.h"
 #include "Debug.h"
+#include "err_type.h"
 #include "HierarchyLogEntry.h"
 #include "HttpMsg.h"
 #include "HttpRequestMethod.h"
+#include "RequestFlags.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -161,7 +163,7 @@ class HttpRequest: public HttpMsg
 
     char *canonical;
 
-    request_flags flags;
+    RequestFlags flags;
 
     HttpHdrRange *range;
 
@@ -34,6 +34,8 @@
 #include "SquidString.h"
 #include "structs.h"
 
+class SquidConfig;
+
 #include <iosfwd>
 
 enum _method_t {
@@ -76,6 +76,8 @@ struct _icp_common_t {
     icp_opcode getOpCode() const;
 #endif
 };
+typedef struct _icp_common_t icp_common_t;
+
 
 #ifdef __cplusplus
 
@@ -258,6 +258,7 @@ libsquid_la_SOURCES = \
 	CommCalls.h \
 	DescriptorSet.cc \
 	DescriptorSet.h \
+	SquidConfig.h \
 	SquidConfig.cc
 
 squid_SOURCES = \
@@ -268,10 +269,16 @@ squid_SOURCES = \
 	AsyncEngine.h \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	cache_manager.cc \
+	CachePeer.h \
 	CacheManager.h \
 	carp.h \
 	carp.cc \
@@ -362,6 +369,7 @@ squid_SOURCES = \
 	HttpStatusCode.h \
 	HttpStatusLine.cc \
 	HttpStatusLine.h \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -377,6 +385,7 @@ squid_SOURCES = \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
 	HttpHeaderRange.h \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpBody.h \
@@ -388,6 +397,8 @@ squid_SOURCES = \
 	HttpParser.h \
 	HttpReply.cc \
 	HttpReply.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequest.h \
 	HttpRequestMethod.cc \
@@ -1106,6 +1117,7 @@ tests_testHttpReply_SOURCES=\
 	ETag.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1119,6 +1131,7 @@ tests_testHttpReply_SOURCES=\
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpControlMsg.h \
@@ -1131,6 +1144,8 @@ tests_testHttpReply_SOURCES=\
 	HttpStatusLine.h \
 	Mem.h \
 	mem.cc \
+	RegexList.h \
+	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
 	mime_header.h \
@@ -1145,6 +1160,7 @@ tests_testHttpReply_SOURCES=\
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -1207,10 +1223,12 @@ tests_testACLMaxUserIP_SOURCES= \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1253,6 +1271,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
@@ -1349,6 +1368,8 @@ tests_testCacheManager_SOURCES = \
 	debug.cc \
 	HttpParser.cc \
 	HttpParser.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
@@ -1365,6 +1386,11 @@ tests_testCacheManager_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
@@ -1420,8 +1446,10 @@ tests_testCacheManager_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1593,13 +1621,15 @@ tests_testDiskIO_SOURCES = \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHdrRange.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -1622,6 +1652,8 @@ tests_testDiskIO_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -1653,6 +1685,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc \
@@ -1748,6 +1781,11 @@ tests_testEvent_SOURCES = \
 	CacheDigest.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	cache_manager.cc \
 	carp.h \
@@ -1806,8 +1844,10 @@ tests_testEvent_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1819,6 +1859,8 @@ tests_testEvent_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -1981,6 +2023,11 @@ tests_testEventLoop_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	carp.h \
 	carp.cc \
@@ -2038,8 +2085,10 @@ tests_testEventLoop_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2051,6 +2100,8 @@ tests_testEventLoop_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -2209,6 +2260,11 @@ tests_test_http_range_SOURCES = \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
@@ -2265,6 +2321,7 @@ tests_test_http_range_SOURCES = \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2274,12 +2331,15 @@ tests_test_http_range_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -2440,6 +2500,7 @@ tests_testHttpParser_SOURCES = \
 	String.cc \
 	structs.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -2473,6 +2534,8 @@ tests_testHttpRequest_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	HttpParser.cc \
 	HttpParser.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
@@ -2492,6 +2555,11 @@ tests_testHttpRequest_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	debug.cc \
 	CacheDigest.h \
@@ -2544,8 +2612,10 @@ tests_testHttpRequest_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2712,19 +2782,23 @@ tests_testStore_SOURCES= \
 	EventLoop.cc \
 	FileMap.h \
 	filemap.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpRequestMethod.cc \
+	RequestFlags.cc \
+	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
@@ -2769,6 +2843,7 @@ tests_testStore_SOURCES= \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_side_request.cc \
@@ -2867,6 +2942,7 @@ tests_testString_SOURCES = \
 	tests/testString.cc \
 	tests/testString.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -2943,6 +3019,8 @@ tests_testUfs_SOURCES = \
 	HttpStatusLine.cc \
 	int.h \
 	int.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MemObject.cc \
@@ -2980,6 +3058,7 @@ tests_testUfs_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -2991,6 +3070,7 @@ tests_testUfs_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3001,6 +3081,7 @@ tests_testUfs_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3090,6 +3171,7 @@ tests_testRock_SOURCES = \
 	fd.cc \
 	FileMap.h \
 	filemap.cc \
+	HttpHeaderFieldStat.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHdrCc.cc \
@@ -3099,6 +3181,7 @@ tests_testRock_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
@@ -3117,6 +3200,8 @@ tests_testRock_SOURCES = \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
+	RequestFlags.cc \
+	RequestFlags.h \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -3152,6 +3237,7 @@ tests_testRock_SOURCES = \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	client_db.h \
@@ -3288,6 +3374,7 @@ tests_testCoss_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -3298,6 +3385,7 @@ tests_testCoss_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3308,6 +3396,7 @@ tests_testCoss_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3439,6 +3528,7 @@ tests_testNull_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -3451,6 +3541,7 @@ tests_testNull_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3461,6 +3552,7 @@ tests_testNull_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3530,6 +3622,11 @@ tests_testURL_SOURCES = \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
+	CacheMgrPasswd.h \
+	CacheMgrPasswd.cc \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
@@ -3585,6 +3682,7 @@ tests_testURL_SOURCES = \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3594,12 +3692,15 @@ tests_testURL_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -3681,8 +3782,8 @@ tests_testURL_SOURCES = \
 	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
-    StrList.h \
-    StrList.cc \
+	StrList.h \
+	StrList.cc \
 	SwapDir.cc \
 	MemStore.cc \
 	tests/stub_debug.cc \
@@ -3765,6 +3866,7 @@ tests_testConfigParser_SOURCES = \
 	tests/testConfigParser.cc \
 	tests/testConfigParser.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -40,6 +40,7 @@
 #include "MemBuf.h"
 #include "MemObject.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
@@ -11,6 +11,7 @@
 #include "MemObject.h"
 #include "MemStore.h"
 #include "mime_header.h"
+#include "SquidConfig.h"
 #include "StoreStats.h"
 #include "tools.h"
 
@@ -38,7 +38,8 @@
 /* for CacheDigestGuessStats */
 #include "StatCounters.h"
 
-struct _Version {
+class Version {
+public:
     short int current;		/* current version */
     short int required;		/* minimal version that can safely handle current version */
 };
@@ -59,7 +60,8 @@ class StoreDigestCBlock
     int reserved[32 - 6];
 };
 
-struct _DigestFetchState {
+class DigestFetchState {
+public:
     PeerDigest *pd;
     StoreEntry *entry;
     StoreEntry *old_entry;
@@ -90,7 +92,7 @@ class PeerDigest
     void *operator new (size_t);
     void operator delete(void *);
 
-    struct peer *peer;          /**< pointer back to peer structure, argh */
+    CachePeer *peer;          /**< pointer back to peer structure, argh */
     CacheDigest *cd;            /**< actual digest structure */
     String host;                /**< copy of peer->host */
     const char *req_result;     /**< text status of the last request */
@@ -129,7 +131,7 @@ class PeerDigest
 
 extern const Version CacheDigestVer;
 
-extern PeerDigest *peerDigestCreate(peer * p);
+extern PeerDigest *peerDigestCreate(CachePeer * p);
 extern void peerDigestNeeded(PeerDigest * pd);
 extern void peerDigestNotePeerGone(PeerDigest * pd);
 extern void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
@@ -51,18 +51,18 @@ SQUIDCEXTERN void peerSelect(Comm::ConnectionList *, HttpRequest *, StoreEntry *
 SQUIDCEXTERN void peerSelectInit(void);
 
 /**
- * A peer which has been selected as a possible destination.
+ * A CachePeer which has been selected as a possible destination.
  * Listed as pointers here so as to prevent duplicates being added but will
  * be converted to a set of IP address path options before handing back out
  * to the caller.
  *
  * Certain connection flags and outgoing settings will also be looked up and
- * set based on the received request and peer settings before handing back.
+ * set based on the received request and CachePeer settings before handing back.
  */
 class FwdServer
 {
 public:
-    peer *_peer;                /* NULL --> origin server */
+    CachePeer *_peer;                /* NULL --> origin server */
     hier_code code;
     FwdServer *next;
 };
@@ -86,21 +86,21 @@ class ps_state
     FwdServer *servers;    ///< temporary linked list of peers we will pass back.
 
     /*
-     * Why are these Ip::Address instead of peer *?  Because a
-     * peer structure can become invalid during the peer selection
+     * Why are these Ip::Address instead of CachePeer *?  Because a
+     * CachePeer structure can become invalid during the CachePeer selection
      * phase, specifically after a reconfigure.  Thus we need to lookup
-     * the peer * based on the address when we are finally ready to
-     * reference the peer structure.
+     * the CachePeer * based on the address when we are finally ready to
+     * reference the CachePeer structure.
      */
 
     Ip::Address first_parent_miss;
 
     Ip::Address closest_parent_miss;
     /*
-     * ->hit can be peer* because it should only be
+     * ->hit can be CachePeer* because it should only be
      * accessed during the thread when it is set
      */
-    peer *hit;
+    CachePeer *hit;
     peer_t hit_type;
     ping_data ping;
     ACLChecklist *acl_checklist;
@@ -0,0 +1,60 @@
+#ifndef SQUID_REFRESHPATTERN_H_
+#define SQUID_REFRESHPATTERN_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class RefreshPattern {
+public:
+    const char *pattern;
+    regex_t compiled_pattern;
+    time_t min;
+    double pct;
+    time_t max;
+    RefreshPattern *next;
+
+    struct {
+        unsigned int icase:1;
+        unsigned int refresh_ims:1;
+        unsigned int store_stale:1;
+#if USE_HTTP_VIOLATIONS
+        unsigned int override_expire:1;
+        unsigned int override_lastmod:1;
+        unsigned int reload_into_ims:1;
+        unsigned int ignore_reload:1;
+        unsigned int ignore_no_cache:1;
+        unsigned int ignore_no_store:1;
+        unsigned int ignore_must_revalidate:1;
+        unsigned int ignore_private:1;
+        unsigned int ignore_auth:1;
+#endif
+    } flags;
+    int max_stale;
+};
+
+#endif /* SQUID_REFRESHPATTERN_H_ */
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "RegexList.h"
+
@@ -0,0 +1,43 @@
+#ifndef SQUID_REGEXLIST_H_
+#define SQUID_REGEXLIST_H_
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class RegexList {
+public:
+    int flags;
+    char *pattern;
+    regex_t regex;
+    RegexList *next;
+};
+
+#endif /* SQUID_REGEXLIST_H_ */
@@ -0,0 +1,97 @@
+/*
+ * DEBUG: section 73    HTTP Request
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "Debug.h"
+#include "RequestFlags.h"
+
+// TODO: move to .cci
+/* RequestFlags */
+bool
+RequestFlags::resetTCP() const
+{
+    return resetTCP_;
+}
+
+void
+RequestFlags::setResetTCP()
+{
+    debugs(73, 9, "request_flags::setResetTCP");
+    resetTCP_ = true;
+}
+
+void
+RequestFlags::clearResetTCP()
+{
+    debugs(73, 9, "request_flags::clearResetTCP");
+    resetTCP_ = false;
+}
+
+void
+RequestFlags::destinationIPLookupCompleted()
+{
+    destinationIPLookedUp_ = true;
+}
+
+bool
+RequestFlags::destinationIPLookedUp() const
+{
+    return destinationIPLookedUp_;
+}
+
+bool
+RequestFlags::isRanged() const
+{
+    return isRanged_;
+}
+
+void
+RequestFlags::setRanged()
+{
+    isRanged_ = true;
+}
+
+void
+RequestFlags::clearRanged()
+{
+    isRanged_ = false;
+}
+
+
+RequestFlags
+RequestFlags::cloneAdaptationImmune() const
+{
+    // At the time of writing, all flags where either safe to copy after
+    // adaptation or were not set at the time of the adaptation. If there
+    // are flags that are different, they should be cleared in the clone.
+    return *this;
+}
@@ -0,0 +1,232 @@
+#ifndef SQUID_REQUESTFLAGS_H_
+#define SQUID_REQUESTFLAGS_H_
+/*
+ * DEBUG: section 73    HTTP Request
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class RequestFlags {
+public:
+    RequestFlags():
+        nocache(false), ims(false), auth_(false), cachable(false),
+        hierarchical_(false), loopdetect(false), proxy_keepalive(false), proxying_(false),
+        refresh_(false), redirected(false), need_validation(false),
+        fail_on_validation_err(false), stale_if_hit(false), nocache_hack(false), accelerated_(false),
+        ignore_cc(false), intercepted_(false), hostVerified_(false), spoof_client_ip(false),
+        internal(false), internalclient(false), must_keepalive(false), connection_auth_wanted(false), connection_auth_disabled(false), connection_proxy_auth(false), pinned_(false),
+        canRePin_(false), authSent_(false), noDirect_(false), chunkedReply_(false),
+        streamError_(false), sslPeek_(false),
+        doneFollowXForwardedFor(!FOLLOW_X_FORWARDED_FOR),
+        sslBumped_(false), destinationIPLookedUp_(false), resetTCP_(false),
+        isRanged_(false)
+    {}
+
+    // When adding new flags, please update cloneAdaptationImmune() as needed.
+    bool resetTCP() const;
+    void setResetTCP();
+    void clearResetTCP();
+    void destinationIPLookupCompleted();
+    bool destinationIPLookedUp() const;
+    // returns a partial copy of the flags that includes only those flags
+    // that are safe for a related (e.g., ICAP-adapted) request to inherit
+    RequestFlags cloneAdaptationImmune() const;
+
+    bool isRanged() const;
+    void setRanged();
+    void clearRanged();
+
+    bool sslBumped() const { return sslBumped_; }
+    void setSslBumped(bool newValue=true) { sslBumped_=newValue; }
+    void clearSslBumpeD() { sslBumped_=false; }
+
+    bool doneFollowXFF() const { return doneFollowXForwardedFor; }
+    void setDoneFollowXFF() {
+        doneFollowXForwardedFor = true;
+    }
+    void clearDoneFollowXFF() {
+        /* do not allow clearing if FOLLOW_X_FORWARDED_FOR is unset */
+        doneFollowXForwardedFor = false || !FOLLOW_X_FORWARDED_FOR;
+    }
+
+    bool sslPeek() const { return sslPeek_; }
+    void setSslPeek() { sslPeek_=true; }
+    void clearSslPeek() { sslPeek_=false; }
+
+    bool hadStreamError() const { return streamError_; }
+    void setStreamError() { streamError_ = true; }
+    void clearStreamError() { streamError_ = false; }
+
+    bool isReplyChunked() const { return chunkedReply_; }
+    void markReplyChunked() { chunkedReply_ = true; }
+
+    void setNoDirect() { noDirect_=true; }
+    bool noDirect() const{ return noDirect_; }
+
+    bool authSent() const { return authSent_; }
+    void markAuthSent() { authSent_=true;}
+
+    bool canRePin() const { return canRePin_; }
+    void allowRepinning() { canRePin_=true; }
+
+    void markPinned() { pinned_ = true; }
+    void clearPinned() { pinned_ = false; }
+    bool pinned() const { return pinned_; }
+
+    //XXX: oddly this is set in client_side_request.cc, but never checked.
+    bool wantConnectionProxyAuth() const { return connection_proxy_auth; }
+    void requestConnectionProxyAuth() { connection_proxy_auth=true; }
+
+    void disableConnectionAuth() { connection_auth_disabled=true; }
+    bool connectionAuthDisabled() const { return connection_auth_disabled; }
+
+    void wantConnectionAuth() { connection_auth_wanted=true; }
+    bool connectionAuthWanted() const { return connection_auth_wanted; }
+
+    void setMustKeepalive() { must_keepalive = true; }
+    bool mustKeepalive() const { return must_keepalive; }
+
+    //XXX: oddly this is set in client_side_request.cc but never checked.
+    void setInternalClient() { internalclient=true;}
+
+    void markInternal() { internal=true; }
+    bool isInternal() const { return internal; }
+
+    bool spoofClientIp() const { return spoof_client_ip; }
+    void setSpoofClientIp() { spoof_client_ip = true; }
+
+    bool hostVerified() const { return hostVerified_; }
+    void markHostVerified() { hostVerified_=true; }
+
+    bool intercepted() const { return intercepted_;  }
+    void markIntercepted() { intercepted_=true; }
+
+    bool ignoringCacheControl() const { return ignore_cc; }
+    void ignoreCacheControl() { ignore_cc=true; }
+
+    bool accelerated() const { return accelerated_; }
+    void markAccelerated() { accelerated_ = true; }
+
+    /* nocache_hack is only enabled if USE_HTTP_VIOLATIONS is set at build-time.
+     * Compilers will have an easy time optimizing to a NOP otherwise. */
+    void hackNocache() { if (USE_HTTP_VIOLATIONS) nocache_hack=true; }
+    bool noCacheHackEnabled() const { return USE_HTTP_VIOLATIONS && nocache_hack; }
+
+    void setStaleIfHit() { stale_if_hit=true; }
+    void clearStaleIfHit() { stale_if_hit=false; }
+    bool staleIfHit() const { return stale_if_hit; }
+
+    void setFailOnValidationError() { fail_on_validation_err=true; }
+    bool failOnValidationError() const { return fail_on_validation_err; }
+
+    bool validationNeeded() const { return need_validation; }
+    void setNeedValidation()  { need_validation=true; }
+
+    bool isRedirected() const { return redirected; }
+    void markRedirected() { redirected=true; }
+
+    bool refresh() const { return refresh_; }
+    void setRefresh() { refresh_ = true; }
+
+    bool proxying() const { return proxying_; }
+    void setProxying() { proxying_ = true; }
+    void clearProxying() { proxying_ = false; }
+
+    bool proxyKeepalive() const { return proxy_keepalive; }
+    void setProxyKeepalive() { proxy_keepalive=true;}
+    void clearProxyKeepalive() { proxy_keepalive=false; }
+
+    bool loopDetect() const { return loopdetect; }
+    void setLoopDetect() { loopdetect = 1; }
+
+    bool hierarchical() const { return hierarchical_; }
+    void setHierarchical() { hierarchical_=true; }
+    void clearHierarchical() { hierarchical_=true; }
+
+    bool isCachable() const { return cachable; }
+    void setCachable(bool newValue=true) { cachable = newValue; }
+    void setNotCachable() { cachable = false; }
+
+    bool hasAuth() const { return auth_; }
+    void markAuth() { auth_=true; }
+
+    bool hasIMS() const { return ims; }
+    void setIMS() { ims=true; }
+    void clearIMS() { ims=false; }
+
+    bool noCache() const { return nocache; }
+    void setNocache() { nocache=true;}
+private:
+    bool nocache :1; ///< whether the response to this request may be READ from cache
+    bool ims :1;
+    bool auth_ :1;
+    bool cachable :1; ///< whether the response to thie request may be stored in the cache
+    bool hierarchical_ :1;
+    bool loopdetect :1;
+    bool proxy_keepalive :1;
+    bool proxying_ :1; /* this should be killed, also in httpstateflags */
+    bool refresh_ :1;
+    bool redirected :1;
+    bool need_validation :1;
+    bool fail_on_validation_err :1; ///< whether we should fail if validation fails
+    bool stale_if_hit :1; ///< reply is stale if it is a hit
+    /* for changing/ignoring no-cache requests. Unused unless USE_HTTP_VIOLATIONS */
+    bool nocache_hack :1;
+    bool accelerated_ :1; ///<request is accelerated
+    bool ignore_cc :1; ///< ignore Cache-Control
+    bool intercepted_ :1; ///< intercepted request
+    bool hostVerified_ :1; ///< whether the Host: header passed verification
+    bool spoof_client_ip :1; ///< spoof client ip if possible
+    bool internal :1;
+    bool internalclient :1;
+    bool must_keepalive :1;
+    bool connection_auth_wanted :1; /** Request wants connection oriented auth */
+    bool connection_auth_disabled :1; ///< Connection oriented auth can't be supported
+    bool connection_proxy_auth :1; ///< Request wants connection oriented auth
+    bool pinned_ :1; ///< Request sent on a pinned connection
+    bool canRePin_ :1; ///< OK to reopen a failed pinned connection
+    bool authSent_ :1; ///< Authentication was forwarded
+    /** Deny direct forwarding unless overriden by always_direct.
+     * Used in accelerator mode */
+    bool noDirect_ :1;
+    bool chunkedReply_ :1; ///< Reply with chunked transfer encoding
+    bool streamError_ :1; ///< Whether stream error has occured
+    bool sslPeek_ :1; ///< internal ssl-bump request to get server cert
+    /* doneFollowXForwardedFor is set by default to the opposite of
+     * compilation option FOLLOW_X_FORWARDED_FOR (so that it returns
+     * always "done" if the build option is disabled).
+     */
+    bool doneFollowXForwardedFor :1;
+    bool sslBumped_ :1; /**< ssl-bumped request*/
+    bool destinationIPLookedUp_:1;
+    bool resetTCP_:1;                ///< request to reset the TCP stream
+    bool isRanged_ :1;
+};
+
+#endif /* SQUID_REQUESTFLAGS_H_ */
@@ -53,6 +53,7 @@
 #include "adaptation/Answer.h"
 #include "adaptation/Iterator.h"
 #include "base/AsyncCall.h"
+#include "SquidConfig.h"
 #endif
 
 // implemented in client_side_reply.cc until sides have a common parent
@@ -1,12 +1,7 @@
-/*
- * $Id$
- */
-
 #include "squid.h"
-#include "ip/Address.h"
-// just for the global definition of Config and Config2
-#include "structs.h"
+#include "SquidConfig.h"
 
 struct SquidConfig Config;
 
 struct SquidConfig2 Config2;
+
@@ -0,0 +1,555 @@
+#ifndef SQUID_SQUIDCONFIG_H_
+#define SQUID_SQUIDCONFIG_H_
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "acl/AclAddress.h"
+#include "ClientDelayConfig.h"
+#include "DelayConfig.h"
+#include "HttpHeaderTools.h"
+#include "icmp/IcmpConfig.h"
+#include "ip/Address.h"
+#include "RefCount.h"
+#include "structs.h"
+#include "YesNoNone.h"
+
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
+
+class acl_access;
+class acl_size_t;
+class AclDenyInfoList;
+class CacheMgrPasswd;
+class HeaderManglers;
+class RefreshPattern;
+class RemovalPolicySettings;
+class SwapDir;
+
+namespace AnyP {
+class PortCfg;
+}
+
+class SquidConfig {
+public:
+    struct {
+        /* These should be for the Store::Root instance.
+        * this needs pluggable parsing to be done smoothly.
+        */
+        int highWaterMark;
+        int lowWaterMark;
+    } Swap;
+
+    YesNoNone memShared; ///< whether the memory cache is shared among workers
+    size_t memMaxSize;
+
+    struct {
+        int64_t min;
+        int pct;
+        int64_t max;
+    } quickAbort;
+    int64_t readAheadGap;
+    RemovalPolicySettings *replPolicy;
+    RemovalPolicySettings *memPolicy;
+#if USE_HTTP_VIOLATIONS
+    time_t negativeTtl;
+#endif
+    time_t maxStale;
+    time_t negativeDnsTtl;
+    time_t positiveDnsTtl;
+    time_t shutdownLifetime;
+    time_t backgroundPingRate;
+
+    struct {
+        time_t read;
+        time_t write;
+        time_t lifetime;
+        time_t connect;
+        time_t forward;
+        time_t peer_connect;
+        time_t request;
+        time_t clientIdlePconn;
+        time_t serverIdlePconn;
+        time_t siteSelect;
+        time_t deadPeer;
+        int icp_query;      /* msec */
+        int icp_query_max;  /* msec */
+        int icp_query_min;  /* msec */
+        int mcast_icp_query;    /* msec */
+
+#if !USE_DNSHELPER
+        time_msec_t idns_retransmit;
+        time_msec_t idns_query;
+#endif
+
+    } Timeout;
+    size_t maxRequestHeaderSize;
+    int64_t maxRequestBodySize;
+    int64_t maxChunkedRequestBodySize;
+    size_t maxRequestBufferSize;
+    size_t maxReplyHeaderSize;
+    acl_size_t *ReplyBodySize;
+
+    struct {
+        unsigned short icp;
+#if USE_HTCP
+
+        unsigned short htcp;
+#endif
+#if SQUID_SNMP
+
+        unsigned short snmp;
+#endif
+    } Port;
+
+    struct {
+        AnyP::PortCfg *http;
+#if USE_SSL
+        AnyP::PortCfg *https;
+#endif
+    } Sockaddr;
+#if SQUID_SNMP
+
+    struct {
+        char *configFile;
+        char *agentInfo;
+    } Snmp;
+#endif
+#if USE_WCCP
+
+    struct {
+        Ip::Address router;
+        Ip::Address address;
+        int version;
+    } Wccp;
+#endif
+#if USE_WCCPv2
+
+    struct {
+        Ip::Address_list *router;
+        Ip::Address address;
+        int forwarding_method;
+        int return_method;
+        int assignment_method;
+        int weight;
+        int rebuildwait;
+        void *info;
+    } Wccp2;
+#endif
+
+#if USE_ICMP
+    IcmpConfig pinger;
+#endif
+
+    char *as_whois_server;
+
+    struct {
+        char *store;
+        char *swap;
+        CustomLog *accesslogs;
+#if ICAP_CLIENT
+        CustomLog *icaplogs;
+#endif
+        int rotateNumber;
+    } Log;
+    char *adminEmail;
+    char *EmailFrom;
+    char *EmailProgram;
+    char *effectiveUser;
+    char *visible_appname_string;
+    char *effectiveGroup;
+
+    struct {
+#if USE_DNSHELPER
+        char *dnsserver;
+#endif
+
+        wordlist *redirect;
+#if USE_UNLINKD
+
+        char *unlinkd;
+#endif
+
+        char *diskd;
+#if USE_SSL
+
+        char *ssl_password;
+#endif
+
+    } Program;
+#if USE_DNSHELPER
+    HelperChildConfig dnsChildren;
+#endif
+
+    HelperChildConfig redirectChildren;
+    time_t authenticateGCInterval;
+    time_t authenticateTTL;
+    time_t authenticateIpTTL;
+
+    struct {
+        char *surrogate_id;
+    } Accel;
+    char *appendDomain;
+    size_t appendDomainLen;
+    char *pidFilename;
+    char *netdbFilename;
+    char *mimeTablePathname;
+    char *etcHostsPath;
+    char *visibleHostname;
+    char *uniqueHostname;
+    wordlist *hostnameAliases;
+    char *errHtmlText;
+
+    struct {
+        char *host;
+        char *file;
+        time_t period;
+        unsigned short port;
+    } Announce;
+
+    struct {
+
+        Ip::Address udp_incoming;
+        Ip::Address udp_outgoing;
+#if SQUID_SNMP
+        Ip::Address snmp_incoming;
+        Ip::Address snmp_outgoing;
+#endif
+        /* FIXME INET6 : this should really be a CIDR value */
+        Ip::Address client_netmask;
+    } Addrs;
+    size_t tcpRcvBufsz;
+    size_t udpMaxHitObjsz;
+    wordlist *hierarchy_stoplist;
+    wordlist *mcast_group_list;
+    wordlist *dns_nameservers;
+    CachePeer *peers;
+    int npeers;
+
+    struct {
+        int size;
+        int low;
+        int high;
+    } ipcache;
+
+    struct {
+        int size;
+    } fqdncache;
+    int minDirectHops;
+    int minDirectRtt;
+    CacheMgrPasswd *passwd_list;
+
+    struct {
+        int objectsPerBucket;
+        int64_t avgObjectSize;
+        int64_t maxObjectSize;
+        int64_t minObjectSize;
+        size_t maxInMemObjSize;
+    } Store;
+
+    struct {
+        int high;
+        int low;
+        time_t period;
+    } Netdb;
+
+    struct {
+        int log_udp;
+        int res_defnames;
+        int anonymizer;
+        int client_db;
+        int query_icmp;
+        int icp_hit_stale;
+        int buffered_logs;
+        int common_log;
+        int log_mime_hdrs;
+        int log_fqdn;
+        int announce;
+        int mem_pools;
+        int test_reachability;
+        int half_closed_clients;
+        int refresh_all_ims;
+#if USE_HTTP_VIOLATIONS
+
+        int reload_into_ims;
+#endif
+
+        int offline;
+        int redir_rewrites_host;
+        int prefer_direct;
+        int nonhierarchical_direct;
+        int strip_query_terms;
+        int redirector_bypass;
+        int ignore_unknown_nameservers;
+        int client_pconns;
+        int server_pconns;
+        int error_pconns;
+#if USE_CACHE_DIGESTS
+
+        int digest_generation;
+#endif
+
+        int ie_refresh;
+        int vary_ignore_expire;
+        int pipeline_prefetch;
+        int surrogate_is_remote;
+        int request_entities;
+        int detect_broken_server_pconns;
+        int balance_on_multiple_ip;
+        int relaxed_header_parser;
+        int check_hostnames;
+        int allow_underscore;
+        int via;
+        int emailErrData;
+        int httpd_suppress_version_string;
+        int global_internal_static;
+
+#if FOLLOW_X_FORWARDED_FOR
+        int acl_uses_indirect_client;
+        int delay_pool_uses_indirect_client;
+        int log_uses_indirect_client;
+#if LINUX_NETFILTER
+        int tproxy_uses_indirect_client;
+#endif
+#endif /* FOLLOW_X_FORWARDED_FOR */
+
+        int WIN32_IpAddrChangeMonitor;
+        int memory_cache_first;
+        int memory_cache_disk;
+        int hostStrictVerify;
+        int client_dst_passthru;
+    } onoff;
+
+    int forward_max_tries;
+    int connect_retries;
+
+    class ACL *aclList;
+
+    struct {
+        acl_access *http;
+        acl_access *adapted_http;
+        acl_access *icp;
+        acl_access *miss;
+        acl_access *NeverDirect;
+        acl_access *AlwaysDirect;
+        acl_access *ASlists;
+        acl_access *noCache;
+        acl_access *log;
+#if SQUID_SNMP
+
+        acl_access *snmp;
+#endif
+#if USE_HTTP_VIOLATIONS
+        acl_access *brokenPosts;
+#endif
+        acl_access *redirector;
+        acl_access *reply;
+        AclAddress *outgoing_address;
+#if USE_HTCP
+
+        acl_access *htcp;
+        acl_access *htcp_clr;
+#endif
+
+#if USE_SSL
+        acl_access *ssl_bump;
+#endif
+#if FOLLOW_X_FORWARDED_FOR
+        acl_access *followXFF;
+#endif /* FOLLOW_X_FORWARDED_FOR */
+
+#if ICAP_CLIENT
+        acl_access* icap;
+#endif
+    } accessList;
+    AclDenyInfoList *denyInfoList;
+
+    struct {
+        size_t list_width;
+        int list_wrap;
+        char *anon_user;
+        int passive;
+        int epsv_all;
+        int epsv;
+        int eprt;
+        int sanitycheck;
+        int telnet;
+    } Ftp;
+    RefreshPattern *Refresh;
+
+    struct _cacheSwap {
+        RefCount<SwapDir> *swapDirs;
+        int n_allocated;
+        int n_configured;
+        /// number of disk processes required to support all cache_dirs
+        int n_strands;
+    } cacheSwap;
+    /*
+     * I'm sick of having to keep doing this ..
+     */
+#define INDEXSD(i)   (Config.cacheSwap.swapDirs[(i)].getRaw())
+
+    struct {
+        char *directory;
+        int use_short_names;
+    } icons;
+    char *errorDirectory;
+#if USE_ERR_LOCALES
+    char *errorDefaultLanguage;
+    int errorLogMissingLanguages;
+#endif
+    char *errorStylesheet;
+
+    struct {
+        int onerror;
+    } retry;
+
+    struct {
+        int64_t limit;
+    } MemPools;
+#if USE_DELAY_POOLS
+
+    DelayConfig Delay;
+    ClientDelayConfig ClientDelay;
+#endif
+
+    struct {
+        struct {
+            int average;
+            int min_poll;
+        } dns, udp, tcp;
+    } comm_incoming;
+    int max_open_disk_fds;
+    int uri_whitespace;
+    acl_size_t *rangeOffsetLimit;
+#if MULTICAST_MISS_STREAM
+
+    struct {
+
+        Ip::Address addr;
+        int ttl;
+        unsigned short port;
+        char *encode_key;
+    } mcast_miss;
+#endif
+
+    /// request_header_access and request_header_replace
+    HeaderManglers *request_header_access;
+    /// reply_header_access and reply_header_replace
+    HeaderManglers *reply_header_access;
+    ///request_header_add access list
+    HeaderWithAclList *request_header_add;
+    char *coredump_dir;
+    char *chroot_dir;
+#if USE_CACHE_DIGESTS
+
+    struct {
+        int bits_per_entry;
+        time_t rebuild_period;
+        time_t rewrite_period;
+        size_t swapout_chunk_size;
+        int rebuild_chunk_percentage;
+    } digest;
+#endif
+#if USE_SSL
+
+    struct {
+        int unclean_shutdown;
+        char *ssl_engine;
+    } SSL;
+#endif
+
+    wordlist *ext_methods;
+
+    struct {
+        int high_rptm;
+        int high_pf;
+        size_t high_memory;
+    } warnings;
+    char *store_dir_select_algorithm;
+    int sleep_after_fork;   /* microseconds */
+    time_t minimum_expiry_time; /* seconds */
+    external_acl *externalAclHelperList;
+
+#if USE_SSL
+
+    struct {
+        char *cert;
+        char *key;
+        int version;
+        char *options;
+        char *cipher;
+        char *cafile;
+        char *capath;
+        char *crlfile;
+        char *flags;
+        acl_access *cert_error;
+        SSL_CTX *sslContext;
+        sslproxy_cert_sign *cert_sign;
+        sslproxy_cert_adapt *cert_adapt;
+    } ssl_client;
+#endif
+
+    char *accept_filter;
+    int umask;
+    int max_filedescriptors;
+    int workers;
+    CpuAffinityMap *cpuAffinityMap;
+
+#if USE_LOADABLE_MODULES
+    wordlist *loadable_module_names;
+#endif
+
+    int client_ip_max_connections;
+
+    struct {
+        int v4_first;       ///< Place IPv4 first in the order of DNS results.
+        ssize_t packet_max; ///< maximum size EDNS advertised for DNS replies.
+    } dns;
+
+};
+
+extern SquidConfig Config;
+
+
+struct SquidConfig2 {
+    struct {
+        int enable_purge;
+        int mangle_request_headers;
+    } onoff;
+    uid_t effectiveUserID;
+    gid_t effectiveGroupID;
+};
+
+extern SquidConfig2 Config2;
+
+#endif /* SQUID_SQUIDCONFIG_H_ */
@@ -42,6 +42,7 @@
 #include "Range.h"
 #include "RefCount.h"
 #include "RemovalPolicy.h"
+#include "RequestFlags.h"
 #include "StoreIOBuffer.h"
 #include "StoreStats.h"
 
@@ -378,7 +379,8 @@ SQUIDCEXTERN StoreEntry *storeGetPublicByRequest(HttpRequest * request);
 SQUIDCEXTERN StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeCreateEntry(const char *, const char *, request_flags, const HttpRequestMethod&);
+class RequestFlags;
+extern StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&);
 
 /// \ingroup StoreAPI
 SQUIDCEXTERN void storeInit(void);
@@ -36,6 +36,7 @@
 #include "ConfigOption.h"
 #include "globals.h"
 #include "Parsing.h"
+#include "SquidConfig.h"
 #include "StoreFileSystem.h"
 #include "SwapDir.h"
 #include "tools.h"
@@ -30,6 +30,7 @@
 #ifndef SQUID_SWAPDIR_H
 #define SQUID_SWAPDIR_H
 
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreIOState.h"
 
@@ -0,0 +1,43 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "YesNoNone.h"
+
+YesNoNone::operator void*() const
+{
+    assert(option != 0); // must call configure() first
+    return option > 0 ? (void*)this : NULL;
+}
+
+void
+YesNoNone::configure(bool beSet)
+{
+    option = beSet ? +1 : -1;
+}
@@ -0,0 +1,56 @@
+#ifndef SQUID_YESNONONE_H_
+#define SQUID_YESNONONE_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// Used for boolean enabled/disabled options with complex default logic.
+/// Allows Squid to compute the right default after configuration.
+/// Checks that not-yet-defined option values are not used.
+class YesNoNone
+{
+// TODO: generalize to non-boolean option types
+public:
+    YesNoNone(): option(0) {}
+
+    /// returns true iff enabled; asserts if the option has not been configured
+    operator void *() const; // TODO: use a fancy/safer version of the operator
+
+    /// enables or disables the option;
+    void configure(bool beSet);
+
+    /// whether the option was enabled or disabled, by user or Squid
+    bool configured() const { return option != 0; }
+
+private:
+    enum { optUnspecified = -1, optDisabled = 0, optEnabled = 1 };
+    int option; ///< configured value or zero
+};
+
+
+#endif /* SQUID_YESNONONE_H_ */
@@ -37,6 +37,7 @@
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
+#include "SquidConfig.h"
 
 const char *AclMatchedName = NULL;
 
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "squid.h"
+#include "AclAddress.h"
+
+//TODO: fill in
@@ -0,0 +1,42 @@
+#ifndef ACLADDRESS_H_
+#define ACLADDRESS_H_
+#include "Acl.h"
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "ip/Address.h"
+#include "acl/Acl.h"
+
+struct AclAddress {
+    AclAddress *next;
+    ACLList *aclList;
+
+    Ip::Address addr;
+};
+
+#endif /* ACLADDRESS_H_ */
@@ -0,0 +1,47 @@
+#ifndef SQUID_ACLDENYINFOLIST_H_
+#define SQUID_ACLDENYINFOLIST_H_
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "err_type.h"
+#include "acl/AclNameList.h"
+
+class AclDenyInfoList {
+public:
+    err_type err_page_id;
+    char *err_page_name;
+    AclNameList *acl_list;
+    AclDenyInfoList *next;
+};
+
+
+#endif /* SQUID_ACLDENYINFOLIST_H_ */
@@ -0,0 +1,40 @@
+#ifndef SQUID_ACL_ACLNAMELIST_H_
+#define SQUID_ACL_ACLNAMELIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "defines.h"
+//TODO: convert to a std::list<string>
+class AclNameList {
+public:
+    char name[ACL_NAME_SZ];
+    AclNameList *next;
+};
+
+#endif /* SQUID_ACLNAMELIST_H_ */
@@ -32,21 +32,23 @@
  */
 
 #include "squid.h"
-#include "mgr/Registration.h"
-#include "radix.h"
-#include "HttpRequest.h"
-#include "StoreClient.h"
-#include "Store.h"
 #include "acl/Acl.h"
 #include "acl/Asn.h"
 #include "acl/Checklist.h"
-#include "acl/SourceAsn.h"
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
+#include "acl/SourceAsn.h"
 #include "cache_cf.h"
+#include "forward.h"
 #include "HttpReply.h"
+#include "HttpRequest.h"
 #include "ipcache.h"
-#include "forward.h"
+#include "mgr/Registration.h"
+#include "radix.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
+#include "Store.h"
+#include "StoreClient.h"
 #include "StoreClient.h"
 #include "wordlist.h"
 
@@ -247,7 +249,7 @@ asnCacheStart(int as)
     asState->request = HTTPMSGLOCK(req);
 
     if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
-        e = storeCreateEntry(asres, asres, request_flags(), METHOD_GET);
+        e = storeCreateEntry(asres, asres, RequestFlags(), METHOD_GET);
         asState->sc = storeClientListAdd(e, asState);
         FwdState::fwdStart(Comm::ConnectionPointer(), e, asState->request);
     } else {
@@ -37,6 +37,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #include "structs.h"
 
 char const *
@@ -55,7 +56,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
     if (Config.onoff.client_dst_passthru && checklist->request &&
-            (checklist->request->flags.intercepted || checklist->request->flags.spoof_client_ip)) {
+            (checklist->request->flags.intercepted() || checklist->request->flags.spoofClientIp())) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -5,6 +5,7 @@
 #include "comm/forward.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #include "auth/AclProxyAuth.h"
@@ -9,8 +9,9 @@
 #include "ssl/support.h"
 #endif
 
-class ExternalACLEntry;
+class CachePeer;
 class ConnStateData;
+class ExternalACLEntry;
 class HttpRequest;
 
 /** \ingroup ACLAPI
@@ -52,7 +53,7 @@ class ACLFilledChecklist: public ACLChecklist
     Ip::Address src_addr;
     Ip::Address dst_addr;
     Ip::Address my_addr;
-    struct peer *dst_peer;
+    CachePeer *dst_peer;
     char *dst_rdns;
 
     HttpRequest *request;
@@ -38,6 +38,8 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
+#include "acl/AclNameList.h"
+#include "acl/AclDenyInfoList.h"
 #include "acl/Checklist.h"
 #include "acl/Strategised.h"
 #include "acl/Gadgets.h"
@@ -49,14 +51,14 @@
 
 /* does name lookup, returns page_id */
 err_type
-aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed)
+aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed)
 {
-    acl_deny_info_list *A = NULL;
+    AclDenyInfoList *A = NULL;
 
     debugs(28, 8, HERE << "got called for " << name);
 
     for (A = *head; A; A = A->next) {
-        acl_name_list *L = NULL;
+        AclNameList *L = NULL;
 
         if (!redirect_allowed && strchr(A->err_page_name, ':') ) {
             debugs(28, 8, HERE << "Skip '" << A->err_page_name << "' 30x redirects not allowed as response here.");
@@ -106,14 +108,14 @@ aclIsProxyAuth(const char *name)
  */
 
 void
-aclParseDenyInfoLine(acl_deny_info_list ** head)
+aclParseDenyInfoLine(AclDenyInfoList ** head)
 {
     char *t = NULL;
-    acl_deny_info_list *A = NULL;
-    acl_deny_info_list *B = NULL;
-    acl_deny_info_list **T = NULL;
-    acl_name_list *L = NULL;
-    acl_name_list **Tail = NULL;
+    AclDenyInfoList *A = NULL;
+    AclDenyInfoList *B = NULL;
+    AclDenyInfoList **T = NULL;
+    AclNameList *L = NULL;
+    AclNameList **Tail = NULL;
 
     /* first expect a page name */
 
@@ -123,15 +125,15 @@ aclParseDenyInfoLine(acl_deny_info_list ** head)
         return;
     }
 
-    A = (acl_deny_info_list *)memAllocate(MEM_ACL_DENY_INFO_LIST);
+    A = (AclDenyInfoList *)memAllocate(MEM_ACL_DENY_INFO_LIST);
     A->err_page_id = errorReservePageId(t);
     A->err_page_name = xstrdup(t);
-    A->next = (acl_deny_info_list *) NULL;
+    A->next = (AclDenyInfoList *) NULL;
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
 
     while ((t = strtok(NULL, w_space))) {
-        L = (acl_name_list *)memAllocate(MEM_ACL_NAME_LIST);
+        L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
         xstrncpy(L->name, t, ACL_NAME_SZ);
         *Tail = L;
         Tail = &L->next;
@@ -280,15 +282,15 @@ aclDestroyAccessList(acl_access ** list)
 }
 
 /* maex@space.net (06.09.1996)
- *    destroy an acl_deny_info_list */
+ *    destroy an AclDenyInfoList */
 
 void
-aclDestroyDenyInfoList(acl_deny_info_list ** list)
+aclDestroyDenyInfoList(AclDenyInfoList ** list)
 {
-    acl_deny_info_list *a = NULL;
-    acl_deny_info_list *a_next = NULL;
-    acl_name_list *l = NULL;
-    acl_name_list *l_next = NULL;
+    AclDenyInfoList *a = NULL;
+    AclDenyInfoList *a_next = NULL;
+    AclNameList *l = NULL;
+    AclNameList *l_next = NULL;
 
     debugs(28, 8, "aclDestroyDenyInfoList: invoked");
 
@@ -4,12 +4,12 @@
 #include "err_type.h"
 
 struct dlink_list;
-class StoreEntry;
-class ConfigParser;
 class acl_access;
 class ACL;
+class AclDenyInfoList;
 class ACLList;
-struct acl_deny_info_list;
+class ConfigParser;
+class StoreEntry;
 class wordlist;
 
 /// \ingroup ACLAPI
@@ -25,11 +25,11 @@ extern void aclParseAclList(ConfigParser &parser, ACLList **);
 /// \ingroup ACLAPI
 extern int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
-extern err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed);
+extern err_type aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed);
 /// \ingroup ACLAPI
-extern void aclParseDenyInfoLine(acl_deny_info_list **);
+extern void aclParseDenyInfoLine(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern void aclDestroyDenyInfoList(acl_deny_info_list **);
+extern void aclDestroyDenyInfoList(AclDenyInfoList **);
 /// \ingroup ACLAPI
 extern wordlist *aclDumpGeneric(const ACL *);
 /// \ingroup ACLAPI
@@ -19,7 +19,9 @@ libstate_la_SOURCES = \
 	Strategised.h \
 	\
 	FilledChecklist.cc \
-	FilledChecklist.h
+	FilledChecklist.h \
+	AclAddress.h \
+	AclAddress.cc
 
 ## data-specific ACLs
 libacls_la_SOURCES = \
@@ -105,6 +107,8 @@ libacls_la_SOURCES = \
 	UserData.cc \
 	UserData.h \
 	\
+	AclNameList.h \
+	AclDenyInfoList.h \
 	Gadgets.cc \
 	Gadgets.h
 
@@ -38,6 +38,7 @@
 #include "cache_cf.h"
 #include "client_db.h"
 #include "Debug.h"
+#include "SquidConfig.h"
 #include "wordlist.h"
 
 ACL *
@@ -3,6 +3,7 @@
 #include "acl/RegexData.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
+#include "CachePeer.h"
 
 int
 ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
@@ -41,12 +41,13 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "Mem.h"
+#include "RegexList.h"
 #include "wordlist.h"
 
 static void
-aclDestroyRegexList(relist * data)
+aclDestroyRegexList(RegexList * data)
 {
-    relist *next = NULL;
+    RegexList *next = NULL;
 
     for (; data; data = next) {
         next = data->next;
@@ -69,13 +70,13 @@ ACLRegexData::match(char const *word)
 
     debugs(28, 3, "aclRegexData::match: checking '" << word << "'");
 
-    relist *first, *prev;
+    RegexList *first, *prev;
 
     first = data;
 
     prev = NULL;
 
-    relist *current = first;
+    RegexList *current = first;
 
     while (current) {
         debugs(28, 3, "aclRegexData::match: looking for '" << current->pattern << "'");
@@ -104,7 +105,7 @@ wordlist *
 ACLRegexData::dump()
 {
     wordlist *W = NULL;
-    relist *temp = data;
+    RegexList *temp = data;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     while (temp != NULL) {
@@ -152,11 +153,11 @@ removeUnnecessaryWildcards(char * t)
     return t;
 }
 
-static relist **
-compileRE(relist **Tail, char * RE, int flags)
+static RegexList **
+compileRE(RegexList **Tail, char * RE, int flags)
 {
     int errcode;
-    relist *q;
+    RegexList *q;
     regex_t comp;
 
     if (RE == NULL  ||  *RE == '\0')
@@ -171,7 +172,7 @@ compileRE(relist **Tail, char * RE, int flags)
     }
     debugs(28, 2, "compileRE: compiled '" << RE << "' with flags " << flags );
 
-    q = (relist *) memAllocate(MEM_RELIST);
+    q = (RegexList *) memAllocate(MEM_RELIST);
     q->pattern = xstrdup(RE);
     q->regex = comp;
     q->flags = flags;
@@ -186,11 +187,11 @@ compileRE(relist **Tail, char * RE, int flags)
  * called only once per ACL.
  */
 static int
-compileOptimisedREs(relist **curlist, wordlist * wl)
+compileOptimisedREs(RegexList **curlist, wordlist * wl)
 {
-    relist **Tail;
-    relist *newlist;
-    relist **newlistp;
+    RegexList **Tail;
+    RegexList *newlist;
+    RegexList **newlistp;
     int numREs = 0;
     int flags = REG_EXTENDED | REG_NOSUB;
     int largeREindex = 0;
@@ -288,10 +289,10 @@ compileOptimisedREs(relist **curlist, wordlist * wl)
 }
 
 static void
-compileUnoptimisedREs(relist **curlist, wordlist * wl)
+compileUnoptimisedREs(RegexList **curlist, wordlist * wl)
 {
-    relist **Tail;
-    relist **newTail;
+    RegexList **Tail;
+    RegexList **newTail;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     for (Tail = curlist; *Tail != NULL; Tail = &((*Tail)->next))
@@ -314,7 +315,7 @@ compileUnoptimisedREs(relist **curlist, wordlist * wl)
 }
 
 static void
-aclParseRegexList(relist **curlist)
+aclParseRegexList(RegexList **curlist)
 {
     char *t;
     wordlist *wl = NULL;
@@ -35,8 +35,7 @@
 #include "acl/Data.h"
 #include "MemPool.h"
 
-/** \todo CLEANUP: break out relist, we don't need the rest. */
-#include "structs.h"
+class RegexList;
 
 class ACLRegexData : public ACLData<char const *>
 {
@@ -52,7 +51,7 @@ class ACLRegexData : public ACLData<char const *>
     virtual ACLData<char const *> *clone() const;
 
 private:
-    relist *data;
+    RegexList *data;
 };
 
 MEMPROXY_CLASS_INLINE(ACLRegexData);
@@ -38,6 +38,7 @@
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
+#include "SquidConfig.h"
 #include "wordlist.h"
 
 Adaptation::Icap::Config Adaptation::Icap::TheConfig;
@@ -17,6 +17,7 @@
 #include "globals.h"
 #include "HttpReply.h"
 #include "ip/tools.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
@@ -24,6 +24,7 @@
 #include "ipcache.h"
 #include "Mem.h"
 #include "pconn.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 //CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, Xaction);
@@ -1,15 +1,17 @@
 #include "squid.h"
 #include "icap_log.h"
 #include "AccessLogEntry.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 
 int IcapLogfileStatus = LOG_DISABLE;
 
 void
 icapLogOpen()
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->type == Log::Format::CLF_NONE)
@@ -24,7 +26,7 @@ icapLogOpen()
 void
 icapLogClose()
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
@@ -37,7 +39,7 @@ icapLogClose()
 void
 icapLogRotate()
 {
-    for (customlog* log = Config.Log.icaplogs; log; log = log->next) {
+    for (CustomLog* log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
             logfileRotate(log->logfile);
         }
@@ -24,17 +24,17 @@ AuthenticateAcl(ACLChecklist *ch)
     if (NULL == request) {
         fatal ("requiresRequest SHOULD have been true for this ACL!!");
         return ACCESS_DENIED;
-    } else if (request->flags.sslBumped) {
+    } else if (request->flags.sslBumped()) {
         debugs(28, 5, "SslBumped request: It is an encapsulated request do not authenticate");
         checklist->auth_user_request = checklist->conn() != NULL ? checklist->conn()->auth_user_request : request->auth_user_request;
         if (checklist->auth_user_request != NULL)
             return ACCESS_ALLOWED;
         else
             return ACCESS_DENIED;
-    } else if (request->flags.accelerated) {
+    } else if (request->flags.accelerated()) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
+    } else if (request->flags.intercepted() || request->flags.spoofClientIp()) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
@@ -40,6 +40,7 @@
 #include "acl/Gadgets.h"
 #include "event.h"
 #include "globals.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
@@ -2,6 +2,7 @@
 #include "auth/basic/auth_basic.h"
 #include "auth/basic/User.h"
 #include "Debug.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "structs.h"
 
@@ -3,6 +3,7 @@
 #include "auth/digest/User.h"
 #include "Debug.h"
 #include "dlink.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "structs.h"
 
@@ -91,6 +91,7 @@ static const HttpHeaderFieldAttrs DigestAttrs[DIGEST_ENUM_END] = {
     {"response", (http_hdr_type)DIGEST_RESPONSE},
 };
 
+class HttpHeaderFieldInfo;
 static HttpHeaderFieldInfo *DigestFieldsInfo = NULL;
 
 /*
@@ -286,8 +286,8 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *re
             ++arg;
         }
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.must_keepalive = 1;
-        if (lm_request->request->flags.proxy_keepalive) {
+        lm_request->request->flags.setMustKeepalive();
+        if (lm_request->request->flags.proxyKeepalive()) {
             lm_request->server_blob = xstrdup(blob);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
@@ -218,7 +218,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         return;
 
     /* Need keep-alive */
-    if (!request->flags.proxy_keepalive && request->flags.must_keepalive)
+    if (!request->flags.proxyKeepalive() && request->flags.mustKeepalive())
         return;
 
     /* New request, no user details */
@@ -229,7 +229,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         if (!keep_alive) {
             /* drop the connection */
             rep->header.delByName("keep-alive");
-            request->flags.proxy_keepalive = 0;
+            request->flags.clearProxyKeepalive();
         }
     } else {
         Auth::Negotiate::UserRequest *negotiate_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
@@ -241,7 +241,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
             rep->header.delByName("keep-alive");
-            request->flags.proxy_keepalive = 0;
+            request->flags.clearProxyKeepalive();
             /* fall through */
 
         case Auth::Ok:
@@ -269,8 +269,8 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, void *lastserver, char *reply)
     if (strncasecmp(reply, "TT ", 3) == 0) {
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.must_keepalive = 1;
-        if (lm_request->request->flags.proxy_keepalive) {
+        lm_request->request->flags.setMustKeepalive();
+        if (lm_request->request->flags.proxyKeepalive()) {
             lm_request->server_blob = xstrdup(blob);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
@@ -205,7 +205,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         return;
 
     /* Need keep-alive */
-    if (!request->flags.proxy_keepalive && request->flags.must_keepalive)
+    if (!request->flags.proxyKeepalive() && request->flags.mustKeepalive())
         return;
 
     /* New request, no user details */
@@ -215,7 +215,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
 
         if (!keep_alive) {
             /* drop the connection */
-            request->flags.proxy_keepalive = 0;
+            request->flags.clearProxyKeepalive();
         }
     } else {
         Auth::Ntlm::UserRequest *ntlm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
@@ -226,7 +226,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         case Auth::Failed:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            request->flags.proxy_keepalive = 0;
+            request->flags.clearProxyKeepalive();
             /* fall through */
 
         case Auth::Ok:
@@ -32,11 +32,16 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
+#include "acl/AclAddress.h"
+#include "acl/AclDenyInfoList.h"
+#include "acl/AclNameList.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
 #include "anyp/PortCfg.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
+#include "CacheMgrPasswd.h"
+#include "CachePeer.h"
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "CpuAffinityMap.h"
@@ -53,12 +58,15 @@
 #include "ip/tools.h"
 #include "ipc/Kids.h"
 #include "log/Config.h"
+#include "log/CustomLog.h"
 #include "Mem.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "Parsing.h"
 #include "PeerDigest.h"
+#include "RefreshPattern.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "Store.h"
 #include "StoreFileSystem.h"
@@ -148,7 +156,7 @@ static void free_ecap_service_type(Adaptation::Ecap::Config *);
 
 static peer_t parseNeighborType(const char *s);
 
-CBDATA_TYPE(peer);
+CBDATA_TYPE(CachePeer);
 
 static const char *const T_MILLISECOND_STR = "millisecond";
 static const char *const T_SECOND_STR = "second";
@@ -168,14 +176,14 @@ static const char *const B_GBYTES_STR = "GB";
 
 static const char *const list_sep = ", \t\n\r";
 
-static void parse_access_log(customlog ** customlog_definitions);
-static int check_null_access_log(customlog *customlog_definitions);
-static void dump_access_log(StoreEntry * entry, const char *name, customlog * definitions);
-static void free_access_log(customlog ** definitions);
+static void parse_access_log(CustomLog ** customlog_definitions);
+static int check_null_access_log(CustomLog *customlog_definitions);
+static void dump_access_log(StoreEntry * entry, const char *name, CustomLog * definitions);
+static void free_access_log(CustomLog ** definitions);
 
 static void update_maxobjsize(void);
 static void configDoConfigure(void);
-static void parse_refreshpattern(refresh_t **);
+static void parse_refreshpattern(RefreshPattern **);
 static uint64_t parseTimeUnits(const char *unit,  bool allowMsec);
 static void parseTimeLine(time_msec_t * tptr, const char *units, bool allowMsec);
 static void parse_u_short(unsigned short * var);
@@ -208,9 +216,9 @@ static void parse_http_header_replace(HeaderManglers **manglers);
 static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderWithAclList *headers);
 static void parse_HeaderWithAclList(HeaderWithAclList **header);
 static void free_HeaderWithAclList(HeaderWithAclList **header);
-static void parse_denyinfo(acl_deny_info_list ** var);
-static void dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var);
-static void free_denyinfo(acl_deny_info_list ** var);
+static void parse_denyinfo(AclDenyInfoList ** var);
+static void dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var);
+static void free_denyinfo(AclDenyInfoList ** var);
 
 #if USE_WCCPv2
 static void parse_IpAddress_list(Ip::Address_list **);
@@ -759,7 +767,7 @@ configDoConfigure(void)
 #if USE_HTTP_VIOLATIONS
 
     {
-        const refresh_t *R;
+        const RefreshPattern *R;
 
         for (R = Config.Refresh; R; R = R->next) {
             if (!R->flags.override_expire)
@@ -918,7 +926,7 @@ configDoConfigure(void)
 
     Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath, Config.ssl_client.crlfile);
 
-    for (peer *p = Config.peers; p != NULL; p = p->next) {
+    for (CachePeer *p = Config.peers; p != NULL; p = p->next) {
         if (p->use_ssl) {
             debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " SSL context");
             p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
@@ -1360,13 +1368,13 @@ free_address(Ip::Address *addr)
     addr->SetEmpty();
 }
 
-CBDATA_TYPE(acl_address);
+CBDATA_TYPE(AclAddress);
 
 static void
-dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
+dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
 {
     char buf[MAX_IPSTRLEN];
-    acl_address *l;
+    AclAddress *l;
 
     for (l = head; l; l = l->next) {
         if (!l->addr.IsAnyAddr())
@@ -1383,17 +1391,17 @@ dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
 static void
 freed_acl_address(void *data)
 {
-    acl_address *l = static_cast<acl_address *>(data);
+    AclAddress *l = static_cast<AclAddress *>(data);
     aclDestroyAclList(&l->aclList);
 }
 
 static void
-parse_acl_address(acl_address ** head)
+parse_acl_address(AclAddress ** head)
 {
-    acl_address *l;
-    acl_address **tail = head;	/* sane name below */
-    CBDATA_INIT_TYPE_FREECB(acl_address, freed_acl_address);
-    l = cbdataAlloc(acl_address);
+    AclAddress *l;
+    AclAddress **tail = head;	/* sane name below */
+    CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
+    l = cbdataAlloc(AclAddress);
     parse_address(&l->addr);
     aclParseAclList(LegacyParser, &l->aclList);
 
@@ -1404,10 +1412,10 @@ parse_acl_address(acl_address ** head)
 }
 
 static void
-free_acl_address(acl_address ** head)
+free_acl_address(AclAddress ** head)
 {
     while (*head) {
-        acl_address *l = *head;
+        AclAddress *l = *head;
         *head = l->next;
         cbdataFree(l);
     }
@@ -1965,7 +1973,7 @@ peer_type_str(const peer_t type)
 }
 
 static void
-dump_peer(StoreEntry * entry, const char *name, peer * p)
+dump_peer(StoreEntry * entry, const char *name, CachePeer * p)
 {
     domain_ping *d;
     domain_type *t;
@@ -2065,12 +2073,12 @@ GetUdpService(void)
 }
 
 static void
-parse_peer(peer ** head)
+parse_peer(CachePeer ** head)
 {
     char *token = NULL;
-    peer *p;
-    CBDATA_INIT_TYPE_FREECB(peer, peerDestroy);
-    p = cbdataAlloc(peer);
+    CachePeer *p;
+    CBDATA_INIT_TYPE_FREECB(CachePeer, peerDestroy);
+    p = cbdataAlloc(CachePeer);
     p->http_port = CACHE_HTTP_PORT;
     p->icp.port = CACHE_ICP_PORT;
     p->weight = 1;
@@ -2344,9 +2352,9 @@ parse_peer(peer ** head)
 }
 
 static void
-free_peer(peer ** P)
+free_peer(CachePeer ** P)
 {
-    peer *p;
+    CachePeer *p;
 
     while ((p = *P) != NULL) {
         *P = p->next;
@@ -2362,7 +2370,7 @@ free_peer(peer ** P)
 }
 
 static void
-dump_cachemgrpasswd(StoreEntry * entry, const char *name, cachemgr_passwd * list)
+dump_cachemgrpasswd(StoreEntry * entry, const char *name, CacheMgrPasswd * list)
 {
     wordlist *w;
 
@@ -2382,15 +2390,15 @@ dump_cachemgrpasswd(StoreEntry * entry, const char *name, cachemgr_passwd * list
 }
 
 static void
-parse_cachemgrpasswd(cachemgr_passwd ** head)
+parse_cachemgrpasswd(CacheMgrPasswd ** head)
 {
     char *passwd = NULL;
     wordlist *actions = NULL;
-    cachemgr_passwd *p;
-    cachemgr_passwd **P;
+    CacheMgrPasswd *p;
+    CacheMgrPasswd **P;
     parse_string(&passwd);
     parse_wordlist(&actions);
-    p = static_cast<cachemgr_passwd *>(xcalloc(1, sizeof(cachemgr_passwd)));
+    p = new CacheMgrPasswd;
     p->passwd = passwd;
     p->actions = actions;
 
@@ -2399,7 +2407,7 @@ parse_cachemgrpasswd(cachemgr_passwd ** head)
          * See if any of the actions from this line already have a
          * password from previous lines.  The password checking
          * routines in cache_manager.c take the the password from
-         * the first cachemgr_passwd struct that contains the
+         * the first CacheMgrPasswd struct that contains the
          * requested action.  Thus, we should warn users who might
          * think they can have two passwords for the same action.
          */
@@ -2420,9 +2428,9 @@ parse_cachemgrpasswd(cachemgr_passwd ** head)
 }
 
 static void
-free_cachemgrpasswd(cachemgr_passwd ** head)
+free_cachemgrpasswd(CacheMgrPasswd ** head)
 {
-    cachemgr_passwd *p;
+    CacheMgrPasswd *p;
 
     while ((p = *head) != NULL) {
         *head = p->next;
@@ -2433,9 +2441,9 @@ free_cachemgrpasswd(cachemgr_passwd ** head)
 }
 
 static void
-dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var)
+dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var)
 {
-    acl_name_list *a;
+    AclNameList *a;
 
     while (var != NULL) {
         storeAppendPrintf(entry, "%s %s", name, var->err_page_name);
@@ -2450,18 +2458,18 @@ dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var)
 }
 
 static void
-parse_denyinfo(acl_deny_info_list ** var)
+parse_denyinfo(AclDenyInfoList ** var)
 {
     aclParseDenyInfoLine(var);
 }
 
 void
-free_denyinfo(acl_deny_info_list ** list)
+free_denyinfo(AclDenyInfoList ** list)
 {
-    acl_deny_info_list *a = NULL;
-    acl_deny_info_list *a_next = NULL;
-    acl_name_list *l = NULL;
-    acl_name_list *l_next = NULL;
+    AclDenyInfoList *a = NULL;
+    AclDenyInfoList *a_next = NULL;
+    AclNameList *l = NULL;
+    AclNameList *l_next = NULL;
 
     for (a = *list; a; a = a_next) {
         for (l = a->acl_list; l; l = l_next) {
@@ -2482,7 +2490,7 @@ static void
 parse_peer_access(void)
 {
     char *host = NULL;
-    peer *p;
+    CachePeer *p;
 
     if (!(host = strtok(NULL, w_space)))
         self_destruct();
@@ -2507,7 +2515,7 @@ parse_hostdomain(void)
     while ((domain = strtok(NULL, list_sep))) {
         domain_ping *l = NULL;
         domain_ping **L = NULL;
-        peer *p;
+        CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
@@ -2545,7 +2553,7 @@ parse_hostdomaintype(void)
     while ((domain = strtok(NULL, list_sep))) {
         domain_type *l = NULL;
         domain_type **L = NULL;
-        peer *p;
+        CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
@@ -2637,7 +2645,7 @@ parse_tristate(int *var)
 #define free_tristate free_int
 
 static void
-dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
+dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 {
     while (head != NULL) {
         storeAppendPrintf(entry, "%s%s %s %d %d%% %d",
@@ -2695,7 +2703,7 @@ dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
 }
 
 static void
-parse_refreshpattern(refresh_t ** head)
+parse_refreshpattern(RefreshPattern ** head)
 {
     char *token;
     char *pattern;
@@ -2720,7 +2728,7 @@ parse_refreshpattern(refresh_t ** head)
 #endif
 
     int i;
-    refresh_t *t;
+    RefreshPattern *t;
     regex_t comp;
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
@@ -2825,7 +2833,7 @@ parse_refreshpattern(refresh_t ** head)
 
     pct = pct < 0.0 ? 0.0 : pct;
     max = max < 0 ? 0 : max;
-    t = static_cast<refresh_t *>(xcalloc(1, sizeof(refresh_t)));
+    t = static_cast<RefreshPattern *>(xcalloc(1, sizeof(RefreshPattern)));
     t->pattern = (char *) xstrdup(pattern);
     t->compiled_pattern = comp;
     t->min = min;
@@ -2885,9 +2893,9 @@ parse_refreshpattern(refresh_t ** head)
 }
 
 static void
-free_refreshpattern(refresh_t ** head)
+free_refreshpattern(RefreshPattern ** head)
 {
-    refresh_t *t;
+    RefreshPattern *t;
 
     while ((t = *head) != NULL) {
         *head = t->next;
@@ -3294,18 +3302,6 @@ dump_removalpolicy(StoreEntry * entry, const char *name, RemovalPolicySettings *
     storeAppendPrintf(entry, "\n");
 }
 
-void
-YesNoNone::configure(bool beSet)
-{
-    option = beSet ? +1 : -1;
-}
-
-YesNoNone::operator void*() const
-{
-    assert(option != 0); // must call configure() first
-    return option > 0 ? (void*)this : NULL;
-}
-
 inline void
 free_YesNoNone(YesNoNone *)
 {
@@ -3981,11 +3977,11 @@ strtokFile(void)
 #include "AccessLogEntry.h"
 
 static void
-parse_access_log(customlog ** logs)
+parse_access_log(CustomLog ** logs)
 {
     const char *filename, *logdef_name;
 
-    customlog *cl = (customlog *)xcalloc(1, sizeof(*cl));
+    CustomLog *cl = (CustomLog *)xcalloc(1, sizeof(*cl));
 
     if ((filename = strtok(NULL, w_space)) == NULL) {
         self_destruct();
@@ -4055,15 +4051,15 @@ parse_access_log(customlog ** logs)
 }
 
 static int
-check_null_access_log(customlog *customlog_definitions)
+check_null_access_log(CustomLog *customlog_definitions)
 {
     return customlog_definitions == NULL;
 }
 
 static void
-dump_access_log(StoreEntry * entry, const char *name, customlog * logs)
+dump_access_log(StoreEntry * entry, const char *name, CustomLog * logs)
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = logs; log; log = log->next) {
         storeAppendPrintf(entry, "%s ", name);
@@ -4115,10 +4111,10 @@ dump_access_log(StoreEntry * entry, const char *name, customlog * logs)
 }
 
 static void
-free_access_log(customlog ** definitions)
+free_access_log(CustomLog ** definitions)
 {
     while (*definitions) {
-        customlog *log = *definitions;
+        CustomLog *log = *definitions;
         *definitions = log->next;
 
         log->logFormat = NULL;
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "base/TextException.h"
+#include "CacheMgrPasswd.h"
 #include "CacheManager.h"
 #include "comm/Connection.h"
 #include "Debug.h"
@@ -49,6 +50,7 @@
 #include "mgr/QueryParams.h"
 #include "protos.h"
 #include "tools.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
@@ -458,12 +460,12 @@ CacheManager::ActionProtection(const Mgr::ActionProfile::Pointer &profile)
 }
 
 /*
- \ingroup CacheManagerInternal
+ * \ingroup CacheManagerInternal
  * gets from the global Config the password the user would need to supply
  * for the action she queried
  */
 char *
-CacheManager::PasswdGet(cachemgr_passwd * a, const char *action)
+CacheManager::PasswdGet(CacheMgrPasswd * a, const char *action)
 {
     wordlist *w;
 
@@ -33,9 +33,11 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 #include "URLScheme.h"
@@ -47,14 +49,14 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_carp_peers = 0;
-static peer **carp_peers = NULL;
+static CachePeer **carp_peers = NULL;
 static OBJH carpCachemgr;
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -71,8 +73,8 @@ carpInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -105,7 +107,7 @@ carpInit(void)
     if (n_carp_peers == 0)
         return;
 
-    carp_peers = (peer **)xcalloc(n_carp_peers, sizeof(*carp_peers));
+    carp_peers = (CachePeer **)xcalloc(n_carp_peers, sizeof(*carp_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = carp_peers, p = Config.peers; p; p = p->next) {
@@ -167,12 +169,12 @@ carpInit(void)
     }
 }
 
-peer *
+CachePeer *
 carpSelectParent(HttpRequest * request)
 {
     int k;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -184,7 +186,7 @@ carpSelectParent(HttpRequest * request)
     /* calculate hash key */
     debugs(39, 2, "carpSelectParent: Calculating hash for " << urlCanonical(request));
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_carp_peers; ++k) {
         String key;
         tp = carp_peers[k];
@@ -250,7 +252,7 @@ carpSelectParent(HttpRequest * request)
 static void
 carpCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -33,10 +33,10 @@
 #ifndef SQUID_CARP_H_
 #define SQUID_CARP_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
 extern void carpInit(void);
-extern peer *carpSelectParent(HttpRequest *);
+extern CachePeer *carpSelectParent(HttpRequest *);
 
 #endif /* SQUID_CARP_H_ */
@@ -40,6 +40,7 @@
 #include "log/access_log.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -83,6 +83,7 @@
 #include "anyp/PortCfg.h"
 #include "base/Subscription.h"
 #include "base/TextException.h"
+#include "CachePeer.h"
 #include "ChunkedCodingParser.h"
 #include "client_db.h"
 #include "client_side_reply.h"
@@ -120,6 +121,7 @@
 #include "mime_header.h"
 #include "profiler/Profiler.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "StatHist.h"
@@ -847,7 +849,10 @@ clientSetKeepaliveFlag(ClientHttpRequest * http)
            RequestMethodStr(request->method));
 
     // TODO: move to HttpRequest::hdrCacheInit, just like HttpReply.
-    request->flags.proxy_keepalive = request->persistent() ? 1 : 0;
+    if (request->persistent())
+        request->flags.setProxyKeepalive();
+    else
+        request->flags.clearProxyKeepalive();
 }
 
 static int
@@ -983,7 +988,7 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
 {
     assert(rep == NULL);
 
-    if (!multipartRangeRequest() && !http->request->flags.chunked_reply) {
+    if (!multipartRangeRequest() && !http->request->flags.isReplyChunked()) {
         size_t length = lengthToSend(bodyData.range());
         noteSentBodyBytes (length);
         AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteBodyComplete",
@@ -1267,7 +1272,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     else if (rep->content_length != http->memObject()->getReply()->content_length)
         range_err = "INCONSISTENT length";	/* a bug? */
 
-    /* hits only - upstream peer determines correct behaviour on misses, and client_side_reply determines
+    /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates
      */
     else if (logTypeIsATcpHit(http->logType) && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
@@ -1392,7 +1397,7 @@ ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
     if (bodyData.data && bodyData.length) {
         if (multipartRangeRequest())
             packRange(bodyData, mb);
-        else if (http->request->flags.chunked_reply) {
+        else if (http->request->flags.isReplyChunked()) {
             packChunk(bodyData, *mb);
         } else {
             size_t length = lengthToSend(bodyData.range());
@@ -1447,8 +1452,9 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
 
     // After sending Transfer-Encoding: chunked (at least), always send
     // the last-chunk if there was no error, ignoring responseFinishedOrFailed.
-    const bool mustSendLastChunk = http->request->flags.chunked_reply &&
-                                   !http->request->flags.stream_error && !context->startOfOutput();
+    const bool mustSendLastChunk = http->request->flags.isReplyChunked() &&
+                                   !http->request->flags.hadStreamError() &&
+                                   !context->startOfOutput();
     if (responseFinishedOrFailed(rep, receivedData) && !mustSendLastChunk) {
         context->writeComplete(context->clientConnection, NULL, 0, COMM_OK);
         PROF_stop(clientSocketRecipient);
@@ -1736,7 +1742,7 @@ ClientSocketContext::socketState()
                 debugs(33, 5, HERE << "Range request at end of returnable " <<
                        "range sequence on " << clientConnection);
 
-                if (http->request->flags.proxy_keepalive)
+                if (http->request->flags.proxyKeepalive())
                     return STREAM_COMPLETE;
                 else
                     return STREAM_UNPLANNED_COMPLETE;
@@ -1753,7 +1759,7 @@ ClientSocketContext::socketState()
             // did we get at least what we expected, based on range specs?
 
             if (bytesSent == bytesExpected) { // got everything
-                if (http->request->flags.proxy_keepalive)
+                if (http->request->flags.proxyKeepalive())
                     return STREAM_COMPLETE;
                 else
                     return STREAM_UNPLANNED_COMPLETE;
@@ -1763,7 +1769,7 @@ ClientSocketContext::socketState()
             // expected why would persistency matter? Should not this
             // always be an error?
             if (bytesSent > bytesExpected) { // got extra
-                if (http->request->flags.proxy_keepalive)
+                if (http->request->flags.proxyKeepalive())
                     return STREAM_COMPLETE;
                 else
                     return STREAM_UNPLANNED_COMPLETE;
@@ -2469,7 +2475,7 @@ ConnStateData::quitAfterError(HttpRequest *request)
     // at the client-side, but many such errors do require closure and the
     // client-side code is bad at handling errors so we play it safe.
     if (request)
-        request->flags.proxy_keepalive = 0;
+        request->flags.clearProxyKeepalive();
     flags.readMore = false;
     debugs(33,4, HERE << "Will close after error: " << clientConnection);
 }
@@ -2649,15 +2655,19 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
 
     request->clientConnectionManager = conn;
 
-    request->flags.accelerated = http->flags.accel;
-    request->flags.sslBumped = conn->switchedToHttps();
-    request->flags.canRePin = request->flags.sslBumped && conn->pinning.pinned;
-    request->flags.ignore_cc = conn->port->ignore_cc;
+    if (http->flags.accel)
+        request->flags.markAccelerated();
+    request->flags.setSslBumped(conn->switchedToHttps());
+    if (request->flags.sslBumped() && conn->pinning.pinned)
+        request->flags.allowRepinning();
+    if (conn->port->ignore_cc)
+        request->flags.ignoreCacheControl();
     // TODO: decouple http->flags.accel from request->flags.sslBumped
-    request->flags.no_direct = (request->flags.accelerated && !request->flags.sslBumped) ?
-                               !conn->port->allow_direct : 0;
+    if (request->flags.accelerated() && !request->flags.sslBumped())
+        if (!conn->port->allow_direct)
+            request->flags.setNoDirect();
 #if USE_AUTH
-    if (request->flags.sslBumped) {
+    if (request->flags.sslBumped()) {
         if (conn->auth_user_request != NULL)
             request->auth_user_request = conn->auth_user_request;
     }
@@ -2668,8 +2678,10 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      * from the port settings to the request.
      */
     if (http->clientConnection != NULL) {
-        request->flags.intercepted = ((http->clientConnection->flags & COMM_INTERCEPTION) != 0);
-        request->flags.spoof_client_ip = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        if ((http->clientConnection->flags & COMM_INTERCEPTION) != 0)
+            request->flags.markIntercepted();
+        if ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 )
+            request->flags.setSpoofClientIp();
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
@@ -2688,7 +2700,8 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
         request->login[0] = '\0';
     }
 
-    request->flags.internal = http->flags.internal;
+    if (http->flags.internal)
+        request->flags.markInternal();
     setLogUri (http, urlCanonicalClean(request));
     request->client_addr = conn->clientConnection->remote; // XXX: remove reuest->client_addr member.
 #if FOLLOW_X_FORWARDED_FOR
@@ -3146,7 +3159,7 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
         repContext->setReplyToError(error, scode,
                                     repContext->http->request->method,
                                     repContext->http->uri,
-                                    peer,
+                                    CachePeer,
                                     repContext->http->request,
                                     in.buf, NULL);
         context->pullData();
@@ -3215,7 +3228,7 @@ ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         repContext->setReplyToError(ERR_LIFETIME_EXP,
-                                    HTTP_REQUEST_TIMEOUT, METHOD_NONE, "N/A", &peer.sin_addr,
+                                    HTTP_REQUEST_TIMEOUT, METHOD_NONE, "N/A", &CachePeer.sin_addr,
                                     NULL, NULL, NULL);
         /* No requests can be outstanded */
         assert(chr == NULL);
@@ -3578,8 +3591,10 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
         fakeRequest->indirect_client_addr = connState->clientConnection->remote;
 #endif
         fakeRequest->my_addr = connState->clientConnection->local;
-        fakeRequest->flags.spoof_client_ip = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
-        fakeRequest->flags.intercepted = ((connState->clientConnection->flags & COMM_INTERCEPTION) != 0);
+        if ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0)
+            fakeRequest->flags.setSpoofClientIp();
+        if ((connState->clientConnection->flags & COMM_INTERCEPTION) != 0)
+            fakeRequest->flags.markIntercepted();
         debugs(33, 4, HERE << details << " try to generate a Dynamic SSL CTX");
         connState->switchToHttps(fakeRequest, bumpMode);
     }
@@ -3889,7 +3904,7 @@ ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew)
 
     // commSetConnTimeout() was called for this request before we switched.
 
-    // Disable the client read handler until peer selection is complete
+    // Disable the client read handler until CachePeer selection is complete
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, clientNegotiateSSL, this, 0);
     switchedToHttps_ = true;
@@ -3911,7 +3926,7 @@ ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode)
     // and now want to switch to SSL to send the error to the client
     // without even peeking at the origin server certificate.
     if (bumpServerMode == Ssl::bumpServerFirst && !sslServerBump) {
-        request->flags.sslPeek = 1;
+        request->flags.setSslPeek();
         sslServerBump = new Ssl::ServerBump(request);
 
         // will call httpsPeeked() with certificate and connection, eventually
@@ -4416,7 +4431,7 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
 }
 
 void
-ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, struct peer *aPeer, bool auth)
+ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, CachePeer *aPeer, bool auth)
 {
     char desc[FD_DESC_SZ];
 
@@ -4462,7 +4477,7 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
 }
 
 const Comm::ConnectionPointer
-ConnStateData::validatePinnedConnection(HttpRequest *request, const struct peer *aPeer)
+ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *aPeer)
 {
     debugs(33, 7, HERE << pinning.serverConnection);
 
@@ -259,7 +259,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         int port;               /* port of pinned connection */
         bool pinned;             /* this connection was pinned */
         bool auth;               /* pinned for www authentication */
-        struct peer *peer;             /* peer the connection goes via */
+        CachePeer *peer;             /* CachePeer the connection goes via */
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
@@ -290,23 +290,23 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /**
      * Correlate the current ConnStateData object with the pinning_fd socket descriptor.
      */
-    void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, struct peer *peer, bool auth);
+    void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth);
     /**
-     * Decorrelate the ConnStateData object from its pinned peer
+     * Decorrelate the ConnStateData object from its pinned CachePeer
      */
     void unpinConnection();
     /**
      * Checks if there is pinning info if it is valid. It can close the server side connection
      * if pinned info is not valid.
      \param request   if it is not NULL also checks if the pinning info refers to the request client side HttpRequest
-     \param peer      if it is not NULL also check if the peer is the pinning peer
+     \param CachePeer      if it is not NULL also check if the CachePeer is the pinning CachePeer
      \return          The details of the server side connection (may be closed if failures were present).
      */
-    const Comm::ConnectionPointer validatePinnedConnection(HttpRequest *request, const struct peer *peer);
+    const Comm::ConnectionPointer validatePinnedConnection(HttpRequest *request, const CachePeer *peer);
     /**
-     * returts the pinned peer if exists, NULL otherwise
+     * returts the pinned CachePeer if exists, NULL otherwise
      */
-    struct peer *pinnedPeer() const {return pinning.peer;}
+    CachePeer *pinnedPeer() const {return pinning.peer;}
     bool pinnedAuth() const {return pinning.auth;}
 
     // pining related comm callbacks
@@ -54,6 +54,8 @@
 #include "mime_header.h"
 #include "neighbors.h"
 #include "refresh.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -127,11 +129,11 @@ void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorS
 {
     if (errstate->httpStatus == HTTP_NOT_IMPLEMENTED && http->request)
         /* prevent confusion over whether we default to persistent or not */
-        http->request->flags.proxy_keepalive = 0;
+        http->request->flags.clearProxyKeepalive();
 
     http->al->http.code = errstate->httpStatus;
 
-    createStoreEntry(method, request_flags());
+    createStoreEntry(method, RequestFlags());
     assert(errstate->callback_data == NULL);
     errorAppendEntry(http->storeEntry(), errstate);
     /* Now the caller reads to get this */
@@ -225,7 +227,7 @@ clientReplyContext::restoreState()
 void
 clientReplyContext::startError(ErrorState * err)
 {
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
     triggerInitialStoreRead();
     errorAppendEntry(http->storeEntry(), err);
 }
@@ -271,7 +273,7 @@ clientReplyContext::processExpired()
         return;
     }
 
-    http->request->flags.refresh = 1;
+    http->request->flags.setRefresh();
 #if STORE_CLIENT_LIST_DEBUG
     /* Prevent a race with the store client memory free routines
      */
@@ -388,15 +390,15 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
     // origin replied 304
     if (status == HTTP_NOT_MODIFIED) {
         http->logType = LOG_TCP_REFRESH_UNMODIFIED;
-        http->request->flags.stale_if_hit = 0; // old_entry is no longer stale
+        http->request->flags.clearStaleIfHit(); // old_entry is no longer stale
 
         // update headers on existing entry
         old_rep->updateOnNotModified(http->storeEntry()->getReply());
         old_entry->timestampsSet();
 
         // if client sent IMS
 
-        if (http->request->flags.ims && !old_entry->modifiedSince(http->request)) {
+        if (http->request->flags.hasIMS() && !old_entry->modifiedSince(http->request)) {
             // forward the 304 from origin
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and forwarding 304 to client");
             sendClientUpstreamResponse();
@@ -417,7 +419,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
     }
 
     // origin replied with an error
-    else if (http->request->flags.fail_on_validation_err) {
+    else if (http->request->flags.failOnValidationError()) {
         http->logType = LOG_TCP_REFRESH_FAIL_ERR;
         debugs(88, 3, "handleIMSReply: origin replied with error " << status <<
                ", forwarding to client due to fail_on_validation_err");
@@ -539,10 +541,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
         return;
     }
 
-    if (e->checkNegativeHit()
-#if USE_HTTP_VIOLATIONS
-            && !r->flags.nocache_hack
-#endif
+    if (e->checkNegativeHit() && !r->flags.noCacheHackEnabled()
        ) {
         http->logType = LOG_TCP_NEGATIVE_HIT;
         sendMoreData(result);
@@ -558,7 +557,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
          * request.  Otherwise two siblings could generate a loop if
          * both have a stale version of the object.
          */
-        r->flags.need_validation = 1;
+        r->flags.setNeedValidation();
 
         if (e->lastmod < 0) {
             /*
@@ -567,7 +566,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
              */
             http->logType = LOG_TCP_MISS;
             processMiss();
-        } else if (r->flags.nocache) {
+        } else if (r->flags.noCache()) {
             /*
              * This did not match a refresh pattern that overrides no-cache
              * we should honour the client no-cache header.
@@ -652,10 +651,10 @@ clientReplyContext::processMiss()
     }
 
     /// Deny loops
-    if (r->flags.loopdetect) {
+    if (r->flags.loopDetect()) {
         http->al->http.code = HTTP_FORBIDDEN;
         err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
-        createStoreEntry(r->method, request_flags());
+        createStoreEntry(r->method, RequestFlags());
         errorAppendEntry(http->storeEntry(), err);
         triggerInitialStoreRead();
         return;
@@ -730,7 +729,7 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
     if (r.header.has(HDR_IF_NONE_MATCH)) {
         if (!e->hasIfNoneMatchEtag(r)) {
             // RFC 2616: ignore IMS if If-None-Match did not match
-            r.flags.ims = 0;
+            r.flags.clearIMS();
             r.ims = -1;
             r.imslen = 0;
             r.header.delById(HDR_IF_MODIFIED_SINCE);
@@ -739,7 +738,7 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
             return;
         }
 
-        if (!r.flags.ims) {
+        if (!r.flags.hasIMS()) {
             // RFC 2616: if If-None-Match matched and there is no IMS,
             // reply with 304 Not Modified or 412 Precondition Failed
             sendNotModifiedOrPreconditionFailedError();
@@ -750,7 +749,7 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
         matchedIfNoneMatch = true;
     }
 
-    if (r.flags.ims) {
+    if (r.flags.hasIMS()) {
         // handle If-Modified-Since requests from the client
         if (e->modifiedSince(&r)) {
             http->logType = LOG_TCP_IMS_HIT;
@@ -993,7 +992,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
     /* FIXME: This doesn't need to go through the store. Simply
      * push down the client chain
      */
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
 
     triggerInitialStoreRead();
 
@@ -1008,7 +1007,7 @@ clientReplyContext::traceReply(clientStreamNode * node)
 {
     clientStreamNode *nextNode = (clientStreamNode *)node->node.next->data;
     StoreIOBuffer localTempBuffer;
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
     localTempBuffer.offset = nextNode->readBuffer.offset + headers_sz;
     localTempBuffer.length = nextNode->readBuffer.length;
     localTempBuffer.data = nextNode->readBuffer.data;
@@ -1040,7 +1039,7 @@ clientReplyContext::checkTransferDone()
     if (http->flags.done_copying)
         return 1;
 
-    if (http->request->flags.chunked_reply && !flags.complete) {
+    if (http->request->flags.isReplyChunked() && !flags.complete) {
         // last-chunk was not sent
         return 0;
     }
@@ -1184,7 +1183,7 @@ clientReplyContext::replyStatus()
 
         const int64_t expectedBodySize =
             http->storeEntry()->getReply()->bodySize(http->request->method);
-        if (!http->request->flags.proxy_keepalive && expectedBodySize < 0) {
+        if (!http->request->flags.proxyKeepalive() && expectedBodySize < 0) {
             debugs(88, 5, "clientReplyStatus: closing, content_length < 0");
             return STREAM_FAILED;
         }
@@ -1199,7 +1198,7 @@ clientReplyContext::replyStatus()
             return STREAM_UNPLANNED_COMPLETE;
         }
 
-        if (http->request->flags.proxy_keepalive) {
+        if (http->request->flags.proxyKeepalive()) {
             debugs(88, 5, "clientReplyStatus: stream complete and can keepalive");
             return STREAM_COMPLETE;
         }
@@ -1374,9 +1373,9 @@ clientReplyContext::buildReplyHeader()
     }
 
     // add Warnings required by RFC 2616 if serving a stale hit
-    if (http->request->flags.stale_if_hit && logTypeIsATcpHit(http->logType)) {
+    if (http->request->flags.staleIfHit() && logTypeIsATcpHit(http->logType)) {
         hdr->putWarning(110, "Response is stale");
-        if (http->request->flags.need_validation)
+        if (http->request->flags.validationNeeded())
             hdr->putWarning(111, "Revalidation failed");
     }
 
@@ -1399,12 +1398,12 @@ clientReplyContext::buildReplyHeader()
                         ||
                         (strncasecmp(value, "Kerberos", 8) == 0 &&
                          (value[8] == '\0' || value[8] == ' '))) {
-                    if (request->flags.connection_auth_disabled) {
+                    if (request->flags.connectionAuthDisabled()) {
                         hdr->delAt(pos, connection_auth_blocked);
                         continue;
                     }
-                    request->flags.must_keepalive = 1;
-                    if (!request->flags.accelerated && !request->flags.intercepted) {
+                    request->flags.setMustKeepalive();
+                    if (!request->flags.accelerated() && !request->flags.intercepted()) {
                         httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
                           We send "[Proxy-]Connection: Proxy-Support" header to mark
@@ -1461,36 +1460,36 @@ clientReplyContext::buildReplyHeader()
                                      (request->http_ver >= HttpVersion(1, 1));
 
     /* Check whether we should send keep-alive */
-    if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.must_keepalive) {
+    if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.mustKeepalive()) {
         debugs(33, 3, "clientBuildReplyHeader: Error, don't keep-alive");
-        request->flags.proxy_keepalive = 0;
-    } else if (!Config.onoff.client_pconns && !request->flags.must_keepalive) {
+        request->flags.clearProxyKeepalive();
+    } else if (!Config.onoff.client_pconns && !request->flags.mustKeepalive()) {
         debugs(33, 2, "clientBuildReplyHeader: Connection Keep-Alive not requested by admin or client");
-        request->flags.proxy_keepalive = 0;
-    } else if (request->flags.proxy_keepalive && shutting_down) {
+        request->flags.clearProxyKeepalive();
+    } else if (request->flags.proxyKeepalive() && shutting_down) {
         debugs(88, 3, "clientBuildReplyHeader: Shutting down, don't keep-alive.");
-        request->flags.proxy_keepalive = 0;
-    } else if (request->flags.connection_auth && !reply->keep_alive) {
+        request->flags.clearProxyKeepalive();
+    } else if (request->flags.connectionAuthWanted() && !reply->keep_alive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection oriented auth but server side non-persistent");
-        request->flags.proxy_keepalive = 0;
+        request->flags.clearProxyKeepalive();
     } else if (reply->bodySize(request->method) < 0 && !maySendChunkedReply) {
         debugs(88, 3, "clientBuildReplyHeader: can't keep-alive, unknown body size" );
-        request->flags.proxy_keepalive = 0;
-    } else if (fdUsageHigh()&& !request->flags.must_keepalive) {
+        request->flags.clearProxyKeepalive();
+    } else if (fdUsageHigh()&& !request->flags.mustKeepalive()) {
         debugs(88, 3, "clientBuildReplyHeader: Not many unused FDs, can't keep-alive");
-        request->flags.proxy_keepalive = 0;
-    } else if (request->flags.sslBumped && !reply->persistent()) {
+        request->flags.clearProxyKeepalive();
+    } else if (request->flags.sslBumped() && !reply->persistent()) {
         // We do not really have to close, but we pretend we are a tunnel.
         debugs(88, 3, "clientBuildReplyHeader: bumped reply forces close");
-        request->flags.proxy_keepalive = 0;
+        request->flags.clearProxyKeepalive();
     }
 
     // Decide if we send chunked reply
     if (maySendChunkedReply &&
-            request->flags.proxy_keepalive &&
+            request->flags.proxyKeepalive() &&
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
-        request->flags.chunked_reply = 1;
+        request->flags.markReplyChunked();
         hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
     }
 
@@ -1508,7 +1507,7 @@ clientReplyContext::buildReplyHeader()
         hdr->putStr(HDR_VIA, strVia.termedBuf());
     }
     /* Signal keep-alive or close explicitly */
-    hdr->putStr(HDR_CONNECTION, request->flags.proxy_keepalive ? "keep-alive" : "close");
+    hdr->putStr(HDR_CONNECTION, request->flags.proxyKeepalive() ? "keep-alive" : "close");
 
 #if ADD_X_REQUEST_URI
     /*
@@ -1556,7 +1555,7 @@ clientReplyContext::identifyStoreObject()
 {
     HttpRequest *r = http->request;
 
-    if (r->flags.cachable || r->flags.internal) {
+    if (r->flags.isCachable() || r->flags.isInternal()) {
         lookingforstore = 5;
         StoreEntry::getPublicByRequest (this, r);
     } else {
@@ -1587,7 +1586,7 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
     /** \li If the request has no-cache flag set or some no_cache HACK in operation we
       * 'invalidate' the cached IP entries for this request ???
       */
-    if (r->flags.nocache) {
+    if (r->flags.noCache()) {
 
 #if USE_DNSHELPER
         ipcacheInvalidate(r->GetHost());
@@ -1597,19 +1596,13 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
 
     }
 
-#if USE_HTTP_VIOLATIONS
-
-    else if (r->flags.nocache_hack) {
-
+    else if (r->flags.noCacheHackEnabled()) {
 #if USE_DNSHELPER
         ipcacheInvalidate(r->GetHost());
 #else
         ipcacheInvalidateNegative(r->GetHost());
 #endif /* USE_DNSHELPER */
-
     }
-
-#endif /* USE_HTTP_VIOLATIONS */
 #if USE_CACHE_DIGESTS
 
     lookup_type = http->storeEntry() ? "HIT" : "MISS";
@@ -1657,7 +1650,7 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
         return;
     }
 
-    if (r->flags.nocache) {
+    if (r->flags.noCache()) {
         debugs(85, 3, "clientProcessRequest2: no-cache REFRESH MISS");
         http->storeEntry(NULL);
         http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
@@ -1827,7 +1820,7 @@ clientReplyContext::sendStreamError(StoreIOBuffer const &result)
     debugs(88, 5, "clientReplyContext::sendStreamError: A stream error has occured, marking as complete and sending no data.");
     StoreIOBuffer localTempBuffer;
     flags.complete = 1;
-    http->request->flags.stream_error = 1;
+    http->request->flags.setStreamError();
     localTempBuffer.flags.error = result.flags.error;
     clientStreamCallback((clientStreamNode*)http->client_stream.head->data, http, NULL,
                          localTempBuffer);
@@ -1898,7 +1891,7 @@ clientReplyContext::sendNotModified()
     HttpReply *const temprep = e->getReply()->make304();
     http->logType = LOG_TCP_IMS_HIT;
     removeClientStoreReference(&sc, http);
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
     e = http->storeEntry();
     // Copy timestamp from the original entry so the 304
     // reply has a meaningful Age: header.
@@ -2160,7 +2153,7 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
 /* Using this breaks the client layering just a little!
  */
 void
-clientReplyContext::createStoreEntry(const HttpRequestMethod& m, request_flags reqFlags)
+clientReplyContext::createStoreEntry(const HttpRequestMethod& m, RequestFlags reqFlags)
 {
     assert(http != NULL);
     /*
@@ -31,11 +31,12 @@
 #ifndef SQUID_CLIENTSIDEREPLY_H
 #define SQUID_CLIENTSIDEREPLY_H
 
-#include "RefCount.h"
-#include "HttpHeader.h"
+#include "client_side_request.h"
 #include "clientStream.h"
+#include "HttpHeader.h"
+#include "RefCount.h"
+#include "RequestFlags.h"
 #include "StoreClient.h"
-#include "client_side_request.h"
 
 class ErrorState;
 #include "ip/forward.h"
@@ -82,7 +83,7 @@ class clientReplyContext : public RefCountable, public StoreClient
 #endif
     /// creates a store entry for the reply and appends err to it
     void setReplyToError(const HttpRequestMethod& method, ErrorState *err);
-    void createStoreEntry(const HttpRequestMethod& m, request_flags flags);
+    void createStoreEntry(const HttpRequestMethod& m, RequestFlags flags);
     void removeStoreReference(store_client ** scp, StoreEntry ** ep);
     void removeClientStoreReference(store_client **scp, ClientHttpRequest *http);
     void startError(ErrorState * err);
@@ -67,6 +67,7 @@
 #include "MemObject.h"
 #include "Parsing.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
@@ -386,9 +387,10 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
     /*
      * build new header list *? TODO
      */
-    request->flags.accelerated = http->flags.accel;
+    if (http->flags.accel)
+        request->flags.markAccelerated();
 
-    request->flags.internalclient = 1;
+    request->flags.setInternalClient();
 
     /* this is an internally created
      * request, not subject to acceleration
@@ -533,7 +535,7 @@ clientFollowXForwardedForCheck(allow_t answer, void *data)
         conn->log_addr = request->indirect_client_addr;
     }
     request->x_forwarded_for_iterator.clean();
-    request->flags.done_follow_x_forwarded_for = 1;
+    request->flags.setDoneFollowXFF();
 
     if (answer != ACCESS_ALLOWED && answer != ACCESS_DENIED) {
         debugs(28, DBG_CRITICAL, "ERROR: Processing X-Forwarded-For. Stopping at IP address: " << request->indirect_client_addr );
@@ -564,7 +566,7 @@ ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLooku
         for (int i = 0; i < ia->count; ++i) {
             if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                 debugs(85, 3, HERE << "validate IP " << clientConn->local << " possible from Host:");
-                http->request->flags.hostVerified = 1;
+                http->request->flags.markHostVerified();
                 http->doCallouts();
                 return;
             }
@@ -586,9 +588,9 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
 
         // NP: it is tempting to use 'flags.nocache' but that is all about READing cache data.
         // The problems here are about WRITE for new cache content, which means flags.cachable
-        http->request->flags.cachable = 0; // MUST NOT cache (for now)
+        http->request->flags.setNotCachable(); // MUST NOT cache (for now)
         // XXX: when we have updated the cache key to base on raw-IP + URI this cacheable limit can go.
-        http->request->flags.hierarchical = 0; // MUST NOT pass to peers (for now)
+        http->request->flags.clearHierarchical(); // MUST NOT pass to peers (for now)
         // XXX: when we have sorted out the best way to relay requests properly to peers this hierarchical limit can go.
         http->doCallouts();
         return;
@@ -632,7 +634,7 @@ ClientRequestContext::hostHeaderVerify()
         return;
     }
 
-    if (http->request->flags.internal) {
+    if (http->request->flags.isInternal()) {
         // TODO: kill this when URL handling allows partial URLs out of accel mode
         //       and we no longer screw with the URL just to add our internal host there
         debugs(85, 6, HERE << "validate skipped due to internal composite URL.");
@@ -663,7 +665,7 @@ ClientRequestContext::hostHeaderVerify()
     }
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
-    if (http->request->flags.intercepted || http->request->flags.spoof_client_ip) {
+    if (http->request->flags.intercepted() || http->request->flags.spoofClientIp()) {
         // verify the Host: port (if any) matches the apparent destination
         if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
             debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
@@ -698,7 +700,7 @@ ClientRequestContext::hostHeaderVerify()
     } else {
         // Okay no problem.
         debugs(85, 3, HERE << "validate passed.");
-        http->request->flags.hostVerified = 1;
+        http->request->flags.markHostVerified();
         http->doCallouts();
     }
     safe_free(hostB);
@@ -708,8 +710,9 @@ ClientRequestContext::hostHeaderVerify()
 void
 ClientRequestContext::clientAccessCheck()
 {
-#if FOLLOW_X_FORWARDED_FOR
-    if (!http->request->flags.done_follow_x_forwarded_for &&
+    /* NOP if !FOLLOW_X_FORWARDED_FOR */
+    if (FOLLOW_X_FORWARDED_FOR &&
+            !http->request->flags.doneFollowXFF() &&
             Config.accessList.followXFF &&
             http->request->header.has(HDR_X_FORWARDED_FOR)) {
 
@@ -725,7 +728,6 @@ ClientRequestContext::clientAccessCheck()
         acl_checklist->nonBlockingCheck(clientFollowXForwardedForCheck, this);
         return;
     }
-#endif /* FOLLOW_X_FORWARDED_FOR */
 
     if (Config.accessList.http) {
         acl_checklist = clientAclChecklistCreate(Config.accessList.http, http);
@@ -809,7 +811,7 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 
         if (auth_challenge) {
 #if USE_AUTH
-            if (http->request->flags.sslBumped) {
+            if (http->request->flags.sslBumped()) {
                 /*SSL Bumped request, authentication is not possible*/
                 status = HTTP_FORBIDDEN;
             } else if (!http->flags.accel) {
@@ -923,22 +925,22 @@ clientHierarchical(ClientHttpRequest * http)
     const wordlist *p = NULL;
 
     // intercepted requests MUST NOT (yet) be sent to peers unless verified
-    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.spoof_client_ip))
+    if (!request->flags.hostVerified() && (request->flags.intercepted() || request->flags.spoofClientIp()))
         return 0;
 
     /*
      * IMS needs a private key, so we can use the hierarchy for IMS only if our
      * neighbors support private keys
      */
 
-    if (request->flags.ims && !neighbors_do_private_keys)
+    if (request->flags.hasIMS() && !neighbors_do_private_keys)
         return 0;
 
     /*
      * This is incorrect: authenticating requests can be sent via a hierarchy
      * (they can even be cached if the correct headers are set on the reply)
      */
-    if (request->flags.auth)
+    if (request->flags.hasAuth())
         return 0;
 
     if (method == METHOD_TRACE)
@@ -952,7 +954,7 @@ clientHierarchical(ClientHttpRequest * http)
         if (strstr(url, p->key))
             return 0;
 
-    if (request->flags.loopdetect)
+    if (request->flags.loopDetect())
         return 0;
 
     if (request->protocol == AnyP::PROTO_HTTP)
@@ -980,26 +982,27 @@ clientCheckPinning(ClientHttpRequest * http)
     if (!http_conn)
         return;
 
-    request->flags.connection_auth_disabled = http_conn->port->connection_auth_disabled;
-    if (!request->flags.connection_auth_disabled) {
+    if (http_conn->port->connection_auth_disabled)
+        request->flags.disableConnectionAuth();
+    if (!request->flags.connectionAuthDisabled()) {
         if (Comm::IsConnOpen(http_conn->pinning.serverConnection)) {
             if (http_conn->pinning.auth) {
-                request->flags.connection_auth = 1;
-                request->flags.auth = 1;
+                request->flags.wantConnectionAuth();
+                request->flags.markAuth();
             } else {
-                request->flags.connection_proxy_auth = 1;
+                request->flags.requestConnectionProxyAuth();
             }
             // These should already be linked correctly.
             assert(request->clientConnectionManager == http_conn);
         }
     }
 
     /* check if connection auth is used, and flag as candidate for pinning
-     * in such case.
+     * in such case.;
      * Note: we may need to set flags.connection_auth even if the connection
      * is already pinned if it was pinned earlier due to proxy auth
      */
-    if (!request->flags.connection_auth) {
+    if (!request->flags.connectionAuthWanted()) {
         if (req_hdr->has(HDR_AUTHORIZATION) || req_hdr->has(HDR_PROXY_AUTHORIZATION)) {
             HttpHeaderPos pos = HttpHeaderInitPos;
             HttpHeaderEntry *e;
@@ -1013,10 +1016,10 @@ clientCheckPinning(ClientHttpRequest * http)
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
                         if (e->id == HDR_AUTHORIZATION) {
-                            request->flags.connection_auth = 1;
+                            request->flags.wantConnectionAuth();
                             may_pin = 1;
                         } else {
-                            request->flags.connection_proxy_auth = 1;
+                            request->flags.requestConnectionProxyAuth();
                             may_pin = 1;
                         }
                     }
@@ -1042,9 +1045,9 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
-        request->flags.ims = 1;
+        request->flags.setIMS();
 
-    if (!request->flags.ignore_cc) {
+    if (!request->flags.ignoringCacheControl()) {
         if (req_hdr->has(HDR_PRAGMA)) {
             String s = req_hdr->getList(HDR_PRAGMA);
 
@@ -1066,7 +1069,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         * SP1 or not so all 5.5 versions are treated 'normally').
         */
         if (Config.onoff.ie_refresh) {
-            if (http->flags.accel && request->flags.ims) {
+            if (http->flags.accel && request->flags.hasIMS()) {
                 if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
                     if (strstr(str, "MSIE 5.01") != NULL)
                         no_cache=true;
@@ -1089,13 +1092,13 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 #if USE_HTTP_VIOLATIONS
 
         if (Config.onoff.reload_into_ims)
-            request->flags.nocache_hack = 1;
+            request->flags.hackNocache();
         else if (refresh_nocache_hack)
-            request->flags.nocache_hack = 1;
+            request->flags.hackNocache();
         else
 #endif
 
-            request->flags.nocache = 1;
+            request->flags.setNocache();
     }
 
     /* ignore range header in non-GETs or non-HEADs */
@@ -1105,7 +1108,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
             request->range = req_hdr->getRange();
 
         if (request->range) {
-            request->flags.range = 1;
+            request->flags.setRanged();
             clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->data;
             /* XXX: This is suboptimal. We should give the stream the range set,
              * and thereby let the top of the stream set the offset when the
@@ -1131,12 +1134,12 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     }
 
     if (req_hdr->has(HDR_AUTHORIZATION))
-        request->flags.auth = 1;
+        request->flags.markAuth();
 
     clientCheckPinning(http);
 
     if (request->login[0] != '\0')
-        request->flags.auth = 1;
+        request->flags.markAuth();
 
     if (req_hdr->has(HDR_VIA)) {
         String s = req_hdr->getList(HDR_VIA);
@@ -1149,7 +1152,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         if (strListIsSubstr(&s, ThisCache2, ',')) {
             debugObj(33, 1, "WARNING: Forwarding loop detected for:\n",
                      request, (ObjPackMethod) & httpRequestPack);
-            request->flags.loopdetect = 1;
+            request->flags.setLoopDetect();
         }
 
 #if USE_FORW_VIA_DB
@@ -1170,17 +1173,17 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 
 #endif
 
-    request->flags.cachable = http->request->cacheable();
+    request->flags.setCachable(http->request->cacheable());
 
     if (clientHierarchical(http))
-        request->flags.hierarchical = 1;
+        request->flags.setHierarchical();
 
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_NOCACHE = " <<
-           (request->flags.nocache ? "SET" : "NOT SET"));
+           (request->flags.noCache() ? "SET" : "NOT SET"));
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_CACHABLE = " <<
-           (request->flags.cachable ? "SET" : "NOT SET"));
+           (request->flags.isCachable() ? "SET" : "NOT SET"));
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_HIERARCHICAL = " <<
-           (request->flags.hierarchical ? "SET" : "NOT SET"));
+           (request->flags.hierarchical() ? "SET" : "NOT SET"));
 
 }
 
@@ -1228,7 +1231,7 @@ ClientRequestContext::clientRedirectDone(char *result)
                 debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
 
                 // update the new request to flag the re-writing was done on it
-                new_request->flags.redirected = 1;
+                new_request->flags.markRedirected();
 
                 // unlink bodypipe from the old request. Not needed there any longer.
                 if (old_request->body_pipe != NULL) {
@@ -1290,7 +1293,8 @@ void
 ClientRequestContext::checkNoCacheDone(const allow_t &answer)
 {
     acl_checklist = NULL;
-    http->request->flags.cachable = (answer == ACCESS_ALLOWED);
+    if (answer == ACCESS_ALLOWED)
+        http->request->flags.setCachable();
     http->doCallouts();
 }
 
@@ -1598,7 +1602,7 @@ ClientHttpRequest::doCallouts()
         if (!calloutContext->no_cache_done) {
             calloutContext->no_cache_done = true;
 
-            if (Config.accessList.noCache && request->flags.cachable) {
+            if (Config.accessList.noCache && request->flags.isCachable()) {
                 debugs(83, 3, HERE << "Doing calloutContext->checkNoCache()");
                 calloutContext->checkNoCache();
                 return;
@@ -59,6 +59,7 @@
 #include "MemBuf.h"
 #include "pconn.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "StoreIOBuffer.h"
@@ -3,6 +3,7 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "comm/ConnOpener.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
@@ -12,12 +13,15 @@
 #include "globals.h"
 #include "icmp/net_db.h"
 #include "ipcache.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
+class CachePeer;
+
 CBDATA_NAMESPACED_CLASS_INIT(Comm, ConnOpener);
 
 Comm::ConnOpener::ConnOpener(Comm::ConnectionPointer &c, AsyncCall::Pointer &handler, time_t ctimeout) :
@@ -203,11 +207,11 @@ Comm::ConnOpener::connected()
 
     /*
      * stats.conn_open is used to account for the number of
-     * connections that we have open to the peer, so we can limit
+     * connections that we have open to the CachePeer, so we can limit
      * based on the max-conn option.  We need to increment here,
      * even if the connection may fail.
      */
-    if (peer *peer=(conn_->getPeer()))
+    if (CachePeer *peer=(conn_->getPeer()))
         ++peer->stats.conn_open;
 
     lookupLocalAddress();
@@ -1,10 +1,12 @@
 #include "squid.h"
+#include "CachePeer.h"
 #include "cbdata.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
 #include "SquidTime.h"
 
+class CachePeer;
 bool
 Comm::IsConnOpen(const Comm::ConnectionPointer &conn)
 {
@@ -18,7 +20,7 @@ Comm::Connection::Connection() :
         fd(-1),
         tos(0),
         flags(COMM_NONBLOCKING),
-        _peer(NULL)
+        peer_(NULL)
 {
     *rfc931 = 0; // quick init the head. the rest does not matter.
 }
@@ -32,7 +34,7 @@ Comm::Connection::~Connection()
         close();
     }
 
-    cbdataReferenceDone(_peer);
+    cbdataReferenceDone(peer_);
 }
 
 Comm::ConnectionPointer
@@ -49,8 +51,8 @@ Comm::Connection::copyDetails() const
     // ensure FD is not open in the new copy.
     c->fd = -1;
 
-    // ensure we have a cbdata reference to _peer not a straight ptr copy.
-    c->_peer = cbdataReference(getPeer());
+    // ensure we have a cbdata reference to peer_ not a straight ptr copy.
+    c->peer_ = cbdataReference(getPeer());
 
     return c;
 }
@@ -61,29 +63,29 @@ Comm::Connection::close()
     if (isOpen()) {
         comm_close(fd);
         fd = -1;
-        if (peer *p=getPeer())
+        if (CachePeer *p=getPeer())
             -- p->stats.conn_open;
     }
 }
 
-peer *
+CachePeer *
 Comm::Connection::getPeer() const
 {
-    if (cbdataReferenceValid(_peer))
-        return _peer;
+    if (cbdataReferenceValid(peer_))
+        return peer_;
 
     return NULL;
 }
 
 void
-Comm::Connection::setPeer(peer *p)
+Comm::Connection::setPeer(CachePeer *p)
 {
     /* set to self. nothing to do. */
     if (getPeer() == p)
         return;
 
-    cbdataReferenceDone(_peer);
+    cbdataReferenceDone(peer_);
     if (p) {
-        _peer = cbdataReference(p);
+        peer_ = cbdataReference(p);
     }
 }
@@ -56,7 +56,7 @@
 #include <ostream>
 #endif
 
-struct peer;
+class CachePeer;
 
 namespace Comm
 {
@@ -108,16 +108,16 @@ class Connection : public RefCountable
     /** determine whether this object describes an active connection or not. */
     bool isOpen() const { return (fd >= 0); }
 
-    /** retrieve the peer pointer for use.
+    /** retrieve the CachePeer pointer for use.
      * The caller is responsible for all CBDATA operations regarding the
      * used of the pointer returned.
      */
-    peer * getPeer() const;
+    CachePeer * getPeer() const;
 
-    /** alter the stored peer pointer.
-     * Perform appropriate CBDATA operations for locking the peer pointer
+    /** alter the stored CachePeer pointer.
+     * Perform appropriate CBDATA operations for locking the CachePeer pointer
      */
-    void setPeer(peer * p);
+    void setPeer(CachePeer * p);
 
 private:
     /** These objects may not be exactly duplicated. Use copyDetails() instead. */
@@ -156,12 +156,8 @@ class Connection : public RefCountable
 #endif
 
 private:
-    // XXX: we need to call this member peer_ but the struct peer_ global type
-    //      behind peer* clashes despite our private Comm:: namespace
-    //      (it being global gets inherited here too).
-
     /** cache_peer data object (if any) */
-    peer *_peer;
+    CachePeer *peer_;
 };
 
 }; // namespace Comm
@@ -40,6 +40,7 @@
 #include "ICP.h"
 #include "mgr/Registration.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -43,6 +43,7 @@
 #include "StatCounters.h"
 #include "StatHist.h"
 #include "Store.h"
+#include "SquidConfig.h"
 
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
@@ -46,6 +46,7 @@
 #include "globals.h"
 #include "ip/Intercept.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 
@@ -32,11 +32,12 @@
  */
 
 #include "squid.h"
+#include "helper.h"
+#include "mgr/Registration.h"
+#include "SquidConfig.h"
+#include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
-#include "SquidTime.h"
-#include "mgr/Registration.h"
-#include "helper.h"
 
 /* MS VisualStudio Projects are monolitich, so we need the following
    #if to include the external DNS code in compile process when
@@ -45,6 +45,7 @@
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc3596.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "tools.h"
@@ -46,6 +46,7 @@
 #include "fde.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "URL.h"
 #include "URLScheme.h"
 #include "URL.h"
@@ -60,6 +60,7 @@
 #include "Mem.h"
 #include "MemBuf.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 /* quick reference on behaviour here.
  * The ESI specification 1.0 requires the ESI processor to be able to
@@ -55,6 +55,7 @@
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -34,6 +34,10 @@
 #include "ip/Address.h"
 #include "structs.h"
 
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
+
 #if USE_DELAY_POOLS
 class ClientInfo;
 #endif
@@ -383,8 +383,8 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_LOCAL_LISTENING_IP: {
             // avoid logging a dash if we have reliable info
             const bool interceptedAtKnownPort = al->request ?
-                                                (al->request->flags.spoof_client_ip ||
-                                                 al->request->flags.intercepted) && al->cache.port :
+                                                (al->request->flags.spoofClientIp() ||
+                                                 al->request->flags.intercepted()) && al->cache.port :
                                                 false;
             if (interceptedAtKnownPort) {
                 const bool portAddressConfigured = !al->cache.port->s.IsAnyAddr();
@@ -2,6 +2,7 @@
 #include "format/Config.h"
 #include "format/Token.h"
 #include "format/TokenTableEntry.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 const char *Format::log_tags[] = {
@@ -32,9 +32,11 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
+#include "acl/AclAddress.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
+#include "CachePeer.h"
 #include "CacheManager.h"
 #include "client_side.h"
 #include "comm/Connection.h"
@@ -63,6 +65,7 @@
 #include "neighbors.h"
 #include "pconn.h"
 #include "PeerSelectState.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -370,7 +373,7 @@ FwdState::startConnectionOrFail()
             fail(anErr);
         } // else use actual error from last connection attempt
 #if USE_SSL
-        if (request->flags.sslPeek && request->clientConnectionManager.valid()) {
+        if (request->flags.sslPeek() && request->clientConnectionManager.valid()) {
             errorAppendEntry(entry, err); // will free err
             err = NULL;
             CallJobHere1(17, 4, request->clientConnectionManager, ConnStateData,
@@ -718,7 +721,7 @@ FwdState::negotiateSSL(int fd)
             // a user-entered address (a host name or a user-entered IP).
             const bool isConnectRequest = !request->clientConnectionManager->port->spoof_client_ip &&
                                           !request->clientConnectionManager->port->intercepted;
-            if (request->flags.sslPeek && !isConnectRequest) {
+            if (request->flags.sslPeek() && !isConnectRequest) {
                 if (X509 *srvX509 = errDetails->peerCert()) {
                     if (const char *name = Ssl::CommonHostName(srvX509)) {
                         request->SetHost(name);
@@ -767,7 +770,7 @@ FwdState::initiateSSL()
 {
     SSL *ssl;
     SSL_CTX *sslContext = NULL;
-    const peer *peer = serverConnection()->getPeer();
+    const CachePeer *peer = serverConnection()->getPeer();
     int fd = serverConnection()->fd;
 
     if (peer) {
@@ -815,7 +818,7 @@ FwdState::initiateSSL()
         const bool hostnameIsIp = request->GetHostIsNumeric();
         const bool isConnectRequest = !request->clientConnectionManager->port->spoof_client_ip &&
                                       !request->clientConnectionManager->port->intercepted;
-        if (!request->flags.sslPeek || isConnectRequest)
+        if (!request->flags.sslPeek() || isConnectRequest)
             SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
 
         // Use SNI TLS extension only when we connect directly
@@ -879,20 +882,20 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
         peerConnectSucceded(serverConnection()->getPeer());
 
     // some requests benefit from pinning but do not require it and can "repin"
-    const bool rePin = request->flags.canRePin &&
+    const bool rePin = request->flags.canRePin() &&
                        request->clientConnectionManager.valid();
     if (rePin) {
         debugs(17, 3, HERE << "repinning " << serverConn);
         request->clientConnectionManager->pinConnection(serverConn,
-                request, serverConn->getPeer(), request->flags.auth);
-        request->flags.pinned = 1;
+                request, serverConn->getPeer(), request->flags.hasAuth());
+        request->flags.markPinned();
     }
 
 #if USE_SSL
-    if (!request->flags.pinned || rePin) {
+    if (!request->flags.pinned() || rePin) {
         if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
                 (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS) ||
-                request->flags.sslPeek) {
+                request->flags.sslPeek()) {
             initiateSSL();
             return;
         }
@@ -956,15 +959,15 @@ FwdState::connectStart()
     if (ftimeout < ctimeout)
         ctimeout = ftimeout;
 
-    if (serverDestinations[0]->getPeer() && request->flags.sslBumped == true) {
+    if (serverDestinations[0]->getPeer() && request->flags.sslBumped() == true) {
         debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parrent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, HTTP_SERVICE_UNAVAILABLE, request);
         fail(anErr);
         self = NULL; // refcounted
         return;
     }
 
-    request->flags.pinned = 0; // XXX: what if the ConnStateData set this to flag existing credentials?
+    request->flags.clearPinned(); // XXX: what if the ConnStateData set this to flag existing credentials?
     // XXX: answer: the peer selection *should* catch it and give us only the pinned peer. so we reverse the =0 step below.
     // XXX: also, logs will now lie if pinning is broken and leads to an error message.
     if (serverDestinations[0]->peerType == PINNED) {
@@ -981,9 +984,9 @@ FwdState::connectStart()
                 serverConn->peerType = HIER_DIRECT;
 #endif
             ++n_tries;
-            request->flags.pinned = 1;
+            request->flags.markPinned();
             if (pinned_connection->pinnedAuth())
-                request->flags.auth = 1;
+                request->flags.markAuth();
             comm_add_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
             // the server may close the pinned connection before this request
             pconnRace = racePossible;
@@ -992,7 +995,7 @@ FwdState::connectStart()
         }
         /* Failure. Fall back on next path unless we can re-pin */
         debugs(17,2,HERE << "Pinned connection failed: " << pinned_connection);
-        if (pconnRace != raceHappened || !request->flags.canRePin) {
+        if (pconnRace != raceHappened || !request->flags.canRePin()) {
             serverDestinations.shift();
             pconnRace = raceImpossible;
             startConnectionOrFail();
@@ -1125,7 +1128,7 @@ FwdState::dispatch()
 #endif
 
 #if USE_SSL
-    if (request->flags.sslPeek) {
+    if (request->flags.sslPeek()) {
         CallJobHere1(17, 4, request->clientConnectionManager, ConnStateData,
                      ConnStateData::httpsPeeked, serverConnection());
         unregister(serverConn); // async call owns it now
@@ -1140,7 +1143,7 @@ FwdState::dispatch()
         request->peer_domain = serverConnection()->getPeer()->domain;
         httpStart(this);
     } else {
-        assert(!request->flags.sslPeek);
+        assert(!request->flags.sslPeek());
         request->peer_login = NULL;
         request->peer_domain = NULL;
 
@@ -1254,7 +1257,7 @@ FwdState::reforward()
 ErrorState *
 FwdState::makeConnectingError(const err_type type) const
 {
-    return new ErrorState(type, request->flags.need_validation ?
+    return new ErrorState(type, request->flags.validationNeeded() ?
                           HTTP_GATEWAY_TIMEOUT : HTTP_SERVICE_UNAVAILABLE, request);
 }
 
@@ -1400,7 +1403,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
         conn->local.SetIPv4();
 
     // maybe use TPROXY client address
-    if (request && request->flags.spoof_client_ip) {
+    if (request && request->flags.spoofClientIp()) {
         if (!conn->getPeer() || !conn->getPeer()->options.no_tproxy) {
 #if FOLLOW_X_FORWARDED_FOR && LINUX_NETFILTER
             if (Config.onoff.tproxy_uses_indirect_client)
@@ -1427,7 +1430,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     // TODO use the connection details in ACL.
     // needs a bit of rework in ACLFilledChecklist to use Comm::Connection instead of ConnStateData
 
-    acl_address *l;
+    AclAddress *l;
     for (l = Config.accessList.outgoing_address; l; l = l->next) {
 
         /* check if the outgoing address is usable to the destination */
@@ -4,6 +4,7 @@
 #include "Array.h"
 #include "comm.h"
 #include "comm/Connection.h"
+#include "err_type.h"
 #include "fde.h"
 #include "ip/Address.h"
 #include "RefCount.h"
@@ -36,6 +36,7 @@
 #include "event.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -52,6 +52,7 @@
 #include "store_key_md5.h"
 #include "swap_log_op.h"
 #include "store_rebuild.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 
 #if HAVE_ERRNO_H
@@ -76,7 +77,7 @@ struct _RebuildState {
         unsigned int clean:1;
     } flags;
 
-    struct _store_rebuild_data counts;
+    StoreRebuildData counts;
 };
 
 static char *storeCossDirSwapLogFile(SwapDir *, const char *);
@@ -33,13 +33,14 @@
 
 #include "squid.h"
 #include "CossSwapDir.h"
-#include "Store.h"
-#include "store_coss.h"
-#include "MemObject.h"
+#include "DiskIO/DiskIOStrategy.h"
 #include "fde.h"
-#include "SwapDir.h"
+#include "MemObject.h"
+#include "SquidConfig.h"
+#include "store_coss.h"
+#include "Store.h"
 #include "StoreFScoss.h"
-#include "DiskIO/DiskIOStrategy.h"
+#include "SwapDir.h"
 
 CBDATA_TYPE(CossMemBuf);
 
@@ -2,7 +2,8 @@
 #define SQUID_FS_ROCK_REBUILD_H
 
 #include "base/AsyncJob.h"
-#include "structs.h"
+#include "cbdata.h"
+#include "store_rebuild.h"
 
 namespace Rock
 {
@@ -39,7 +40,7 @@ class Rebuild: public AsyncJob
     int64_t dbOffset;
     int filen;
 
-    struct _store_rebuild_data counts;
+    StoreRebuildData counts;
 
     static void Steps(void *data);
 
@@ -17,6 +17,7 @@
 #include "ipc/mem/Pages.h"
 #include "MemObject.h"
 #include "Parsing.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "tools.h"
 
@@ -34,6 +34,7 @@
 #include "disk.h"
 #include "globals.h"
 #include "RebuildState.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "store_key_md5.h"
 #include "store_rebuild.h"
@@ -32,8 +32,8 @@
 
 #include "RefCount.h"
 #include "UFSSwapDir.h"
-#include "structs.h"
 #include "UFSSwapLogParser.h"
+#include "store_rebuild.h"
 
 class StoreEntry;
 
@@ -76,7 +76,7 @@ class RebuildState : public RefCountable
     char fullpath[MAXPATHLEN];
     char fullfilename[MAXPATHLEN];
 
-    struct _store_rebuild_data counts;
+    StoreRebuildData counts;
 
 private:
     CBDATA_CLASS2(RebuildState);
@@ -46,6 +46,7 @@
 #include "store_key_md5.h"
 #include "StoreSearchUFS.h"
 #include "StoreSwapLogData.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "tools.h"
@@ -53,6 +53,7 @@
 #include "mime.h"
 #include "rfc1738.h"
 #include "Server.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -40,6 +40,8 @@
 #include "defines.h"
 
 /* for iostats */
+#include "acl/AclDenyInfoList.h"
+#include "CacheDigest.h"
 #include "structs.h"
 
 extern char *ConfigFile;	/* NULL */
@@ -87,7 +89,7 @@ extern int DnsSocketB;		/* -1 */
 extern int n_disk_objects;	/* 0 */
 extern iostats IOStats;
 
-extern struct acl_deny_info_list *DenyInfoList;	/* NULL */
+extern AclDenyInfoList *DenyInfoList;	/* NULL */
 
 extern struct timeval squid_start;
 extern int starting_up;	/* 1 */
@@ -43,6 +43,7 @@
 #include "MemBuf.h"
 #include "mime.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -35,6 +35,7 @@
 #include "AccessLogEntry.h"
 #include "acl/Acl.h"
 #include "acl/FilledChecklist.h"
+#include "CachePeer.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
@@ -49,6 +50,7 @@
 #include "md5.h"
 #include "MemBuf.h"
 #include "refresh.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "store_key_md5.h"
@@ -1307,7 +1309,7 @@ htcpHandleClr(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 static void
 htcpForwardClr(char *buf, int sz)
 {
-    peer *p;
+    CachePeer *p;
 
     for (p = Config.peers; p; p = p->next) {
         if (!p->options.htcp) {
@@ -1550,7 +1552,7 @@ htcpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int)
 }
 
 int
-htcpQuery(StoreEntry * e, HttpRequest * req, peer * p)
+htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
 {
     cache_key *save_key;
     static char pkt[8192];
@@ -1603,10 +1605,10 @@ htcpQuery(StoreEntry * e, HttpRequest * req, peer * p)
 }
 
 /*
- * Send an HTCP CLR message for a specified item to a given peer.
+ * Send an HTCP CLR message for a specified item to a given CachePeer.
  */
 void
-htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, peer * p, htcp_clr_reason reason)
+htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, CachePeer * p, htcp_clr_reason reason)
 {
     static char pkt[8192];
     ssize_t pktlen;
@@ -79,10 +79,10 @@ SQUIDCEXTERN void htcpOpenPorts(void);
  * 		Don't wait for a reply or count in stats as sent.
  * \retval -1   Error sending request.
  */
-SQUIDCEXTERN int htcpQuery(StoreEntry * e, HttpRequest * req, peer * p);
+SQUIDCEXTERN int htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, peer * p, htcp_clr_reason reason);
+SQUIDCEXTERN void htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, CachePeer * p, htcp_clr_reason reason);
 
 /// \ingroup ServerProtocolHTCP
 SQUIDCEXTERN void htcpSocketShutdown(void);
@@ -39,6 +39,7 @@
 #include "base64.h"
 #include "base/AsyncJobCalls.h"
 #include "base/TextException.h"
+#include "CachePeer.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "comm/Write.h"
@@ -64,7 +65,9 @@
 #include "peer_proxy_negotiate_auth.h"
 #include "profiler/Profiler.h"
 #include "refresh.h"
+#include "RefreshPattern.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -117,7 +120,7 @@ HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"),
         _peer = cbdataReference(fwd->serverConnection()->getPeer());         /* might be NULL */
 
     if (_peer) {
-        request->flags.proxying = 1;
+        request->flags.setProxying();
         /*
          * This NEIGHBOR_PROXY_ONLY check probably shouldn't be here.
          * We might end up getting the object from somewhere else if,
@@ -294,7 +297,7 @@ httpMaybeRemovePublic(StoreEntry * e, http_status status)
 void
 HttpStateData::processSurrogateControl(HttpReply *reply)
 {
-    if (request->flags.accelerated && reply->surrogate_control) {
+    if (request->flags.accelerated() && reply->surrogate_control) {
         HttpHdrScTarget *sctusable = reply->surrogate_control->getMergedTarget(Config.Accel.surrogate_id);
 
         if (sctusable) {
@@ -335,7 +338,7 @@ HttpStateData::cacheableReply()
     const char *v;
 #if USE_HTTP_VIOLATIONS
 
-    const refresh_t *R = NULL;
+    const RefreshPattern *R = NULL;
 
     /* This strange looking define first looks up the refresh pattern
      * and then checks if the specified flag is set. The main purpose
@@ -376,7 +379,7 @@ HttpStateData::cacheableReply()
         }
     }
 
-    if (request->flags.auth || request->flags.auth_sent) {
+    if (request->flags.hasAuth() || request->flags.authSent()) {
         /*
          * Responses to requests with authorization may be cached
          * only if a Cache-Control: public reply header is present.
@@ -713,7 +716,7 @@ HttpStateData::processReplyHeader()
     }
 
     if (!peerSupportsConnectionPinning())
-        request->flags.connection_auth_disabled = 1;
+        request->flags.disableConnectionAuth();
 
     HttpReply *vrep = setVirginReply(newrep);
     flags.headers_parsed = 1;
@@ -834,7 +837,7 @@ bool HttpStateData::peerSupportsConnectionPinning() const
         return true;
 
     /*if the connections it is already pinned it is OK*/
-    if (request->flags.pinned)
+    if (request->flags.pinned())
         return true;
 
     /*Allow pinned connections only if the Proxy-support header exists in
@@ -1234,7 +1237,7 @@ HttpStateData::continueAfterParsingHeader()
             debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Headers did not parse at all for " << entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
         } else {
             error = ERR_ZERO_SIZE_OBJECT;
-            debugs(11, (request->flags.accelerated?DBG_IMPORTANT:2), "WARNING: HTTP: Invalid Response: No object data received for " <<
+            debugs(11, (request->flags.accelerated()?DBG_IMPORTANT:2), "WARNING: HTTP: Invalid Response: No object data received for " <<
                    entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
         }
     }
@@ -1383,18 +1386,18 @@ HttpStateData::processReplyBody()
             closeHandler = NULL;
             fwd->unregister(serverConnection);
 
-            if (request->flags.spoof_client_ip)
+            if (request->flags.spoofClientIp())
                 client_addr = request->client_addr;
 
-            if (request->flags.pinned) {
+            if (request->flags.pinned()) {
                 ispinned = true;
-            } else if (request->flags.connection_auth && request->flags.auth_sent) {
+            } else if (request->flags.connectionAuthWanted() && request->flags.authSent()) {
                 ispinned = true;
             }
 
             if (request->pinnedConnection() && ispinned) {
                 request->pinnedConnection()->pinConnection(serverConnection, request, _peer,
-                        (request->flags.connection_auth != 0));
+                        request->flags.connectionAuthWanted());
             } else {
                 fwd->pconnPush(serverConnection, request->peer_host ? request->peer_host : request->GetHost());
             }
@@ -1527,7 +1530,7 @@ httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHe
     http_hdr_type header = flags.originpeer ? HDR_AUTHORIZATION : HDR_PROXY_AUTHORIZATION;
 
     /* Nothing to do unless we are forwarding to a peer */
-    if (!request->flags.proxying)
+    if (!request->flags.proxying())
         return;
 
     /* Needs to be explicitly enabled */
@@ -1645,11 +1648,11 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
      */
     if (!we_do_ranges && request->multipartRangeRequest()) {
         /* don't cache the result */
-        request->flags.cachable = 0;
+        request->flags.setNotCachable();
         /* pretend it's not a range request */
         delete request->range;
         request->range = NULL;
-        request->flags.range = 0;
+        request->flags.clearRanged();
     }
 
     /* append Via */
@@ -1664,7 +1667,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
         strVia.clean();
     }
 
-    if (request->flags.accelerated) {
+    if (request->flags.accelerated()) {
         /* Append Surrogate-Capabilities */
         String strSurrogate(hdr_in->getList(HDR_SURROGATE_CAPABILITY));
 #if USE_SQUID_ESI
@@ -1733,7 +1736,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Authorization if known in URL, not in header and going direct */
     if (!hdr_out->has(HDR_AUTHORIZATION)) {
-        if (!request->flags.proxying && request->login && *request->login) {
+        if (!request->flags.proxying() && request->login && *request->login) {
             httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
                               old_base64_encode(request->login));
         }
@@ -1867,7 +1870,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          */
         if (request->peer_domain)
             hdr_out->putStr(HDR_HOST, request->peer_domain);
-        else if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
+        else if (request->flags.isRedirected() && !Config.onoff.redir_rewrites_host)
             hdr_out->addEntry(e->clone());
         else {
             /* use port# only if not default */
@@ -1984,13 +1987,13 @@ HttpStateData::decideIfWeDoRanges (HttpRequest * request)
 
     int64_t roffLimit = request->getRangeOffsetLimit();
 
-    if (NULL == request->range || !request->flags.cachable
-            || request->range->offsetLimitExceeded(roffLimit) || request->flags.connection_auth)
+    if (NULL == request->range || !request->flags.isCachable()
+            || request->range->offsetLimitExceeded(roffLimit) || request->flags.connectionAuthWanted())
         result = false;
 
     debugs(11, 8, "decideIfWeDoRanges: range specs: " <<
            request->range << ", cachable: " <<
-           request->flags.cachable << "; we_do_ranges: " << result);
+           request->flags.isCachable() << "; we_do_ranges: " << result);
 
     return result;
 }
@@ -2018,10 +2021,10 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
         Packer p;
         httpBuildRequestHeader(request, entry, fwd->al, &hdr, flags);
 
-        if (request->flags.pinned && request->flags.connection_auth)
-            request->flags.auth_sent = 1;
+        if (request->flags.pinned() && request->flags.connectionAuthWanted())
+            request->flags.markAuthSent();
         else if (hdr.has(HDR_AUTHORIZATION))
-            request->flags.auth_sent = 1;
+            request->flags.markAuthSent();
 
         packerToMemInit(&p, mb);
         hdr.packInto(&p);
@@ -2088,7 +2091,7 @@ HttpStateData::sendRequest()
     /*
      * Is keep-alive okay for all request methods?
      */
-    if (request->flags.must_keepalive)
+    if (request->flags.mustKeepalive())
         flags.keepalive = 1;
     else if (!Config.onoff.server_pconns)
         flags.keepalive = 0;
@@ -61,7 +61,7 @@ class HttpStateData : public ServerStateData
     virtual void maybeReadVirginBody(); // read response data from the network
     int cacheableReply();
 
-    peer *_peer;		/* peer request made to */
+    CachePeer *_peer;		/* CachePeer request made to */
     int eof;			/* reached end-of-object? */
     int lastChunk;		/* reached last chunk of a chunk-encoded reply */
     http_state_flags flags;
@@ -37,6 +37,7 @@
 #include "icmp/IcmpSquid.h"
 #include "icmp/net_db.h"
 #include "ip/tools.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 
@@ -39,6 +39,7 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "cbdata.h"
 #include "disk.h"
 #include "event.h"
@@ -81,7 +82,7 @@ typedef enum {
 } netdb_conn_state_t;
 
 typedef struct {
-    peer *p;
+    CachePeer *p;
     StoreEntry *e;
     store_client *sc;
     HttpRequest *r;
@@ -105,7 +106,7 @@ static void netdbHostDelete(const net_db_name * x);
 static void netdbPurgeLRU(void);
 static netdbEntry *netdbLookupHost(const char *key);
 static net_db_peer *netdbPeerByName(const netdbEntry * n, const char *);
-static net_db_peer *netdbPeerAdd(netdbEntry * n, peer * e);
+static net_db_peer *netdbPeerAdd(netdbEntry * n, CachePeer * e);
 static const char *netdbPeerName(const char *name);
 static IPH netdbSendPing;
 static QS sortPeerByRtt;
@@ -116,7 +117,7 @@ static FREE netdbFreeNetdbEntry;
 static STCB netdbExchangeHandleReply;
 static void netdbExchangeDone(void *);
 
-/* We have to keep a local list of peer names.  The Peers structure
+/* We have to keep a local list of CachePeer names.  The Peers structure
  * gets freed during a reconfigure.  We want this database to
  * remain persisitent, so _net_db_peer->peername points into this
  * linked list */
@@ -421,7 +422,7 @@ netdbPeerByName(const netdbEntry * n, const char *peername)
 }
 
 static net_db_peer *
-netdbPeerAdd(netdbEntry * n, peer * e)
+netdbPeerAdd(netdbEntry * n, CachePeer * e)
 {
     net_db_peer *p;
     net_db_peer *o;
@@ -1123,7 +1124,7 @@ netdbHostData(const char *host, int *samp, int *rtt, int *hops)
 }
 
 void
-netdbUpdatePeer(HttpRequest * r, peer * e, int irtt, int ihops)
+netdbUpdatePeer(HttpRequest * r, CachePeer * e, int irtt, int ihops)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -1159,7 +1160,7 @@ netdbUpdatePeer(HttpRequest * r, peer * e, int irtt, int ihops)
 }
 
 void
-netdbExchangeUpdatePeer(Ip::Address &addr, peer * e, double rtt, double hops)
+netdbExchangeUpdatePeer(Ip::Address &addr, CachePeer * e, double rtt, double hops)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -1313,7 +1314,7 @@ void
 netdbExchangeStart(void *data)
 {
 #if USE_ICMP
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
     char *uri;
     netdbExchangeState *ex;
     StoreIOBuffer tempBuffer;
@@ -1334,7 +1335,7 @@ netdbExchangeStart(void *data)
     assert(NULL != ex->r);
     ex->r->http_ver = HttpVersion(1,1);
     ex->connstate = STATE_HEADER;
-    ex->e = storeCreateEntry(uri, uri, request_flags(), METHOD_GET);
+    ex->e = storeCreateEntry(uri, uri, RequestFlags(), METHOD_GET);
     ex->buf_sz = NETDB_REQBUF_SZ;
     assert(NULL != ex->e);
     ex->sc = storeClientListAdd(ex->e, ex);
@@ -1343,7 +1344,7 @@ netdbExchangeStart(void *data)
     tempBuffer.data = ex->buf;
     storeClientCopy(ex->sc, ex->e, tempBuffer,
                     netdbExchangeHandleReply, ex);
-    ex->r->flags.loopdetect = 1;	/* cheat! -- force direct */
+    ex->r->flags.setLoopDetect();	/* cheat! -- force direct */
 
     if (p->login)
         xstrncpy(ex->r->login, p->login, MAX_LOGIN_SZ);
@@ -1355,11 +1356,11 @@ netdbExchangeStart(void *data)
 #endif
 }
 
-peer *
+CachePeer *
 netdbClosestParent(HttpRequest * request)
 {
 #if USE_ICMP
-    peer *p = NULL;
+    CachePeer *p = NULL;
     netdbEntry *n;
     const ipcache_addrs *ia;
     net_db_peer *h;
@@ -9,7 +9,7 @@ class Address;
 class StoreEntry;
 class HttpRequest;
 
-/* for struct peer */
+/* for CachePeer */
 #include "structs.h"
 
 SQUIDCEXTERN void netdbInit(void);
@@ -21,14 +21,14 @@ void netdbDump(StoreEntry *);
 SQUIDCEXTERN void netdbFreeMemory(void);
 SQUIDCEXTERN int netdbHostHops(const char *host);
 SQUIDCEXTERN int netdbHostRtt(const char *host);
-SQUIDCEXTERN void netdbUpdatePeer(HttpRequest *, peer * e, int rtt, int hops);
+SQUIDCEXTERN void netdbUpdatePeer(HttpRequest *, CachePeer * e, int rtt, int hops);
 
 SQUIDCEXTERN void netdbDeleteAddrNetwork(Ip::Address &addr);
 SQUIDCEXTERN void netdbBinaryExchange(StoreEntry *);
 SQUIDCEXTERN void netdbExchangeStart(void *);
 
-SQUIDCEXTERN void netdbExchangeUpdatePeer(Ip::Address &, peer *, double, double);
-SQUIDCEXTERN peer *netdbClosestParent(HttpRequest *);
+SQUIDCEXTERN void netdbExchangeUpdatePeer(Ip::Address &, CachePeer *, double, double);
+SQUIDCEXTERN CachePeer *netdbClosestParent(HttpRequest *);
 SQUIDCEXTERN void netdbHostData(const char *host, int *samp, int *rtt, int *hops);
 
 #endif /* ICMP_NET_DB_H */
@@ -56,6 +56,7 @@
 #include "neighbors.h"
 #include "refresh.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -40,6 +40,7 @@
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "tools.h"
 #include "URL.h"
@@ -36,6 +36,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "ip/Address.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "tools.h"
 #include "rfc1738.h"
@@ -7,6 +7,7 @@
 #include "globals.h"
 #include "ipc/Kids.h"
 #include "tools.h"
+#include "SquidConfig.h"
 #include "structs.h"
 
 Kids TheKids;
@@ -38,6 +38,7 @@
 #include "fde.h"
 #include "ip/Address.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 #include "tools.h"
@@ -41,6 +41,7 @@
 #include "Mem.h"
 #include "mgr/Registration.h"
 #include "rfc3596.h"
+#include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -0,0 +1,31 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#include "squid.h"
+#include "CustomLog.h"
+
@@ -0,0 +1,48 @@
+#ifndef SQUID_CUSTOMLOG_H_
+#define SQUID_CUSTOMLOG_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#include "format/Format.h"
+#include "log/Formats.h"
+
+class ACLList;
+class Logfile;
+
+class CustomLog {
+public:
+    char *filename;
+    ACLList *aclList;
+    Format::Format *logFormat;
+    Logfile *logfile;
+    CustomLog *next;
+    Log::Format::log_type type;
+};
+
+
+#endif /* SQUID_CUSTOMLOG_H_ */
@@ -38,6 +38,7 @@
 #include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -37,6 +37,7 @@
 #include "globals.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -32,12 +32,13 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "MemBuf.h"
 
 void
-Log::Format::SquidCustom(const AccessLogEntry::Pointer &al, customlog * log)
+Log::Format::SquidCustom(const AccessLogEntry::Pointer &al, CustomLog * log)
 {
     static MemBuf mb;
     mb.reset();
@@ -40,6 +40,7 @@
 #include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -37,6 +37,7 @@
 #include "globals.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -5,6 +5,7 @@
 
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
+class CustomLog;
 class Logfile;
 
 namespace Log
@@ -40,7 +41,7 @@ void SquidUserAgent(const AccessLogEntryPointer &al, Logfile * logfile);
 void SquidReferer(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Log with a local custom format
-void SquidCustom(const AccessLogEntryPointer &al, customlog * log);
+void SquidCustom(const AccessLogEntryPointer &al, CustomLog * log);
 
 /// Log with Apache httpd common format
 void HttpdCommon(const AccessLogEntryPointer &al, Logfile * logfile);
@@ -27,5 +27,7 @@ liblog_la_SOURCES = \
 	ModTcp.cc \
 	ModTcp.h \
 	ModUdp.cc \
-	ModUdp.h
+	ModUdp.h \
+	CustomLog.h \
+	CustomLog.cc
 
@@ -39,6 +39,7 @@
 #include "log/File.h"
 #include "log/ModDaemon.h"
 #include "SquidIpc.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 #if HAVE_ERRNO_H
@@ -37,6 +37,7 @@
 #include "globals.h"
 #include "log/File.h"
 #include "log/ModStdio.h"
+#include "SquidConfig.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -40,6 +40,7 @@
 #include "log/ModTcp.h"
 #include "Parsing.h"
 #include "structs.h"
+#include "SquidConfig.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -39,6 +39,7 @@
 #include "log/ModUdp.h"
 #include "Parsing.h"
 #include "structs.h"
+#include "SquidConfig.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -32,10 +32,10 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "Store.h"
-#include "errorpage.h"
-#include "err_detail_type.h"
 #include "acl/Checklist.h"
+#include "CachePeer.h"
+#include "err_detail_type.h"
+#include "errorpage.h"
 #include "errorpage.h"
 #include "format/Token.h"
 #include "globals.h"
@@ -44,12 +44,15 @@
 #include "HttpRequest.h"
 #include "log/access_log.h"
 #include "log/Config.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
+#include "Store.h"
 
 #if USE_SQUID_EUI
 #include "eui/Eui48.h"
@@ -88,7 +91,7 @@ static void fvdbRegisterWithCacheManager();
 int LogfileStatus = LOG_DISABLE;
 
 void
-accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist * checklist)
+accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 {
 
     if (al->url == NULL)
@@ -201,7 +204,7 @@ accessLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 void
 accessLogRotate(void)
 {
-    customlog *log;
+    CustomLog *log;
 #if USE_FORW_VIA_DB
 
     fvdbClear();
@@ -223,7 +226,7 @@ accessLogRotate(void)
 void
 accessLogClose(void)
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.accesslogs; log; log = log->next) {
         if (log->logfile) {
@@ -298,7 +301,7 @@ accessLogRegisterWithCacheManager(void)
 void
 accessLogInit(void)
 {
-    customlog *log;
+    CustomLog *log;
 
     accessLogRegisterWithCacheManager();
 
@@ -83,6 +83,7 @@
 #include "send-announce.h"
 #include "store_log.h"
 #include "tools.h"
+#include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "stat.h"
@@ -31,13 +31,18 @@
  */
 
 #include "squid.h"
-#include "event.h"
+#include "acl/AclDenyInfoList.h"
+#include "acl/AclNameList.h"
+#include "CacheDigest.h"
 #include "ClientInfo.h"
-#include "Mem.h"
+#include "event.h"
 #include "md5.h"
+#include "Mem.h"
 #include "MemBuf.h"
 #include "memMeter.h"
 #include "mgr/Registration.h"
+#include "RegexList.h"
+#include "SquidConfig.h"
 #include "SquidList.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -448,9 +453,9 @@ Mem::Init(void)
     memDataInit(MEM_16K_BUF, "16K Buffer", 16384, 10, false);
     memDataInit(MEM_32K_BUF, "32K Buffer", 32768, 10, false);
     memDataInit(MEM_64K_BUF, "64K Buffer", 65536, 10, false);
-    memDataInit(MEM_ACL_DENY_INFO_LIST, "acl_deny_info_list",
-                sizeof(acl_deny_info_list), 0);
-    memDataInit(MEM_ACL_NAME_LIST, "acl_name_list", sizeof(acl_name_list), 0);
+    memDataInit(MEM_ACL_DENY_INFO_LIST, "AclDenyInfoList",
+                sizeof(AclDenyInfoList), 0);
+    memDataInit(MEM_ACL_NAME_LIST, "acl_name_list", sizeof(AclNameList), 0);
 #if USE_CACHE_DIGESTS
 
     memDataInit(MEM_CACHE_DIGEST, "CacheDigest", sizeof(CacheDigest), 0);
@@ -463,7 +468,7 @@ Mem::Init(void)
     memDataInit(MEM_HTTP_HDR_CONTENT_RANGE, "HttpHdrContRange", sizeof(HttpHdrContRange), 0);
     memDataInit(MEM_NETDBENTRY, "netdbEntry", sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, "net_db_name", sizeof(net_db_name), 0);
-    memDataInit(MEM_RELIST, "relist", sizeof(relist), 0);
+    memDataInit(MEM_RELIST, "RegexList", sizeof(RegexList), 0);
     memDataInit(MEM_CLIENT_INFO, "ClientInfo", sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, "MD5 digest", SQUID_MD5_DIGEST_LENGTH, 0);
     MemPools[MEM_MD5_DIGEST]->setChunkSize(512 * 1024);
@@ -9,6 +9,7 @@
 #include "HttpRequestMethod.h"
 #include "ipc/forward.h"
 #include "mgr/QueryParams.h"
+#include "RequestFlags.h"
 
 namespace Mgr
 {
@@ -26,7 +27,7 @@ class ActionParams
     /* details of the client HTTP request that caused the action */
     String httpUri; ///< HTTP request URI
     _method_t httpMethod; ///< HTTP request method
-    request_flags httpFlags; ///< HTTP request flags
+    RequestFlags httpFlags; ///< HTTP request flags
     String httpOrigin;       ///< HTTP Origin: header (if any)
 
     /* action parameters extracted from the client HTTP request */
@@ -12,6 +12,7 @@
 #include "mgr/Registration.h"
 #include "protos.h"
 #include "Store.h"
+#include "SquidConfig.h"
 
 Mgr::IndexAction::Pointer
 Mgr::IndexAction::Create(const Command::Pointer &cmd)
@@ -24,13 +24,13 @@ Mgr::IoActionData&
 Mgr::IoActionData::operator += (const IoActionData& stats)
 {
     http_reads += stats.http_reads;
-    for (int i = 0; i < _iostats::histSize; ++i)
+    for (int i = 0; i < iostats::histSize; ++i)
         http_read_hist[i] += stats.http_read_hist[i];
     ftp_reads += stats.ftp_reads;
-    for (int i = 0; i < _iostats::histSize; ++i)
+    for (int i = 0; i < iostats::histSize; ++i)
         ftp_read_hist[i] += stats.ftp_read_hist[i];
     gopher_reads += stats.gopher_reads;
-    for (int i = 0; i < _iostats::histSize; ++i)
+    for (int i = 0; i < iostats::histSize; ++i)
         gopher_read_hist[i] += stats.gopher_read_hist[i];
 
     return *this;
@@ -7,7 +7,7 @@
 #define SQUID_MGR_IO_ACTION_H
 
 #include "mgr/Action.h"
-#include "structs.h" /* _iostats::histSize */
+#include "structs.h" /* iostats::histSize */
 
 namespace Mgr
 {
@@ -23,9 +23,9 @@ class IoActionData
     double http_reads;
     double ftp_reads;
     double gopher_reads;
-    double http_read_hist[_iostats::histSize];
-    double ftp_read_hist[_iostats::histSize];
-    double gopher_read_hist[_iostats::histSize];
+    double http_read_hist[iostats::histSize];
+    double ftp_read_hist[iostats::histSize];
+    double gopher_read_hist[iostats::histSize];
 };
 
 /// implement aggregated 'io' action
@@ -43,6 +43,8 @@
 #include "MemBuf.h"
 #include "mime.h"
 #include "MemObject.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
@@ -430,7 +432,7 @@ MimeIcon::created (StoreEntry *newEntry)
 
     int n;
 
-    request_flags flags;
+    RequestFlags flags;
 
     struct stat sb;
 
@@ -453,7 +455,7 @@ MimeIcon::created (StoreEntry *newEntry)
         return;
     }
 
-    flags.cachable = 1;
+    flags.setCachable();
     StoreEntry *e = storeCreateEntry(url,
                                      url,
                                      flags,
@@ -34,6 +34,7 @@
 #include "acl/FilledChecklist.h"
 #include "anyp/PortCfg.h"
 #include "CacheDigest.h"
+#include "CachePeer.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
@@ -53,6 +54,8 @@
 #include "neighbors.h"
 #include "PeerDigest.h"
 #include "PeerSelectState.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "stat.h"
@@ -64,35 +67,35 @@
 /* count mcast group peers every 15 minutes */
 #define MCAST_COUNT_RATE 900
 
-bool peerAllowedToUse(const peer *, HttpRequest *);
-static int peerWouldBePinged(const peer *, HttpRequest *);
-static void neighborRemove(peer *);
-static void neighborAlive(peer *, const MemObject *, const icp_common_t *);
+bool peerAllowedToUse(const CachePeer *, HttpRequest *);
+static int peerWouldBePinged(const CachePeer *, HttpRequest *);
+static void neighborRemove(CachePeer *);
+static void neighborAlive(CachePeer *, const MemObject *, const icp_common_t *);
 #if USE_HTCP
-static void neighborAliveHtcp(peer *, const MemObject *, const htcpReplyData *);
+static void neighborAliveHtcp(CachePeer *, const MemObject *, const htcpReplyData *);
 #endif
-static void neighborCountIgnored(peer *);
+static void neighborCountIgnored(CachePeer *);
 static void peerRefreshDNS(void *);
 static IPH peerDNSConfigure;
-static bool peerProbeConnect(peer *);
+static bool peerProbeConnect(CachePeer *);
 static CNCB peerProbeConnectDone;
 static void peerCountMcastPeersDone(void *data);
 static void peerCountMcastPeersStart(void *data);
-static void peerCountMcastPeersSchedule(peer * p, time_t when);
+static void peerCountMcastPeersSchedule(CachePeer * p, time_t when);
 static IRCB peerCountHandleIcpReply;
 
 static void neighborIgnoreNonPeer(const Ip::Address &, icp_opcode);
 static OBJH neighborDumpPeers;
 static OBJH neighborDumpNonPeers;
-static void dump_peers(StoreEntry * sentry, peer * peers);
+static void dump_peers(StoreEntry * sentry, CachePeer * peers);
 
 static unsigned short echo_port;
 
 static int NLateReplies = 0;
-static peer *first_ping = NULL;
+static CachePeer *first_ping = NULL;
 
 const char *
-neighborTypeStr(const peer * p)
+neighborTypeStr(const CachePeer * p)
 {
     if (p->type == PEER_NONE)
         return "Non-Peer";
@@ -106,12 +109,12 @@ neighborTypeStr(const peer * p)
     return "Parent";
 }
 
-peer *
+CachePeer *
 whichPeer(const Ip::Address &from)
 {
     int j;
 
-    peer *p = NULL;
+    CachePeer *p = NULL;
     debugs(15, 3, "whichPeer: from " << from);
 
     for (p = Config.peers; p; p = p->next) {
@@ -126,10 +129,10 @@ whichPeer(const Ip::Address &from)
 }
 
 peer_t
-neighborType(const peer * p, const HttpRequest * request)
+neighborType(const CachePeer * p, const HttpRequest * request)
 {
 
-    const struct _domain_type *d = NULL;
+    const domain_type *d = NULL;
 
     for (d = p->typelist; d; d = d->next) {
         if (0 == matchDomainName(request->GetHost(), d->domain))
@@ -149,33 +152,33 @@ neighborType(const peer * p, const HttpRequest * request)
  * \return Whether it is appropriate to fetch REQUEST from PEER.
  */
 bool
-peerAllowedToUse(const peer * p, HttpRequest * request)
+peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 {
 
-    const struct _domain_ping *d = NULL;
+    const domain_ping *d = NULL;
     assert(request != NULL);
 
     if (neighborType(p, request) == PEER_SIBLING) {
 #if PEER_MULTICAST_SIBLINGS
         if (p->type == PEER_MULTICAST && p->options.mcast_siblings &&
-                (request->flags.nocache || request->flags.refresh || request->flags.loopdetect || request->flags.need_validation))
+                (request->flags.noCache() || request->flags.refresh() || request->flags.loopDetect() || request->flags.validationNeeded()))
             debugs(15, 2, "peerAllowedToUse(" << p->name << ", " << request->GetHost() << ") : multicast-siblings optimization match");
 #endif
-        if (request->flags.nocache)
+        if (request->flags.noCache())
             return false;
 
-        if (request->flags.refresh)
+        if (request->flags.refresh())
             return false;
 
-        if (request->flags.loopdetect)
+        if (request->flags.loopDetect())
             return false;
 
-        if (request->flags.need_validation)
+        if (request->flags.validationNeeded())
             return false;
     }
 
     // CONNECT requests are proxy requests. Not to be forwarded to origin servers.
-    // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this peer.
+    // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this CachePeer.
     if (p->options.originserver && request->method == METHOD_CONNECT && request->port != p->in_addr.GetPort())
         return false;
 
@@ -205,9 +208,9 @@ peerAllowedToUse(const peer * p, HttpRequest * request)
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
-/* Return TRUE if it is okay to send an ICP request to this peer.   */
+/* Return TRUE if it is okay to send an ICP request to this CachePeer.   */
 static int
-peerWouldBePinged(const peer * p, HttpRequest * request)
+peerWouldBePinged(const CachePeer * p, HttpRequest * request)
 {
     if (p->icp.port == 0)
         return 0;
@@ -227,7 +230,7 @@ peerWouldBePinged(const peer * p, HttpRequest * request)
     /* the case below seems strange, but can happen if the
      * URL host is on the other side of a firewall */
     if (p->type == PEER_SIBLING)
-        if (!request->flags.hierarchical)
+        if (!request->flags.hierarchical())
             return 0;
 
     if (!peerAllowedToUse(p, request))
@@ -243,9 +246,9 @@ peerWouldBePinged(const peer * p, HttpRequest * request)
     return 1;
 }
 
-/* Return TRUE if it is okay to send an HTTP request to this peer. */
+/* Return TRUE if it is okay to send an HTTP request to this CachePeer. */
 int
-peerHTTPOkay(const peer * p, HttpRequest * request)
+peerHTTPOkay(const CachePeer * p, HttpRequest * request)
 {
     if (p->max_conn)
         if (p->stats.conn_open >= p->max_conn)
@@ -263,7 +266,7 @@ peerHTTPOkay(const peer * p, HttpRequest * request)
 int
 neighborsCount(HttpRequest * request)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
     int count = 0;
 
     for (p = Config.peers; p; p = p->next)
@@ -275,10 +278,10 @@ neighborsCount(HttpRequest * request)
     return count;
 }
 
-peer *
+CachePeer *
 getFirstUpParent(HttpRequest * request)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (!neighborUp(p))
@@ -297,11 +300,11 @@ getFirstUpParent(HttpRequest * request)
     return p;
 }
 
-peer *
+CachePeer *
 getRoundRobinParent(HttpRequest * request)
 {
-    peer *p;
-    peer *q = NULL;
+    CachePeer *p;
+    CachePeer *q = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (!p->options.roundrobin)
@@ -336,11 +339,11 @@ getRoundRobinParent(HttpRequest * request)
     return q;
 }
 
-peer *
+CachePeer *
 getWeightedRoundRobinParent(HttpRequest * request)
 {
-    peer *p;
-    peer *q = NULL;
+    CachePeer *p;
+    CachePeer *q = NULL;
     int weighted_rtt;
 
     for (p = Config.peers; p; p = p->next) {
@@ -403,7 +406,7 @@ peerClearRRLoop(void *data)
 }
 
 /**
- * This gets called on startup and restart to kick off the peer round-robin
+ * This gets called on startup and restart to kick off the CachePeer round-robin
  * maintenance event. It ensures that no matter how many times its called
  * no more than one event is scheduled.
  */
@@ -421,23 +424,23 @@ peerClearRRStart(void)
  * Called whenever the round-robin counters need to be reset to a sane state.
  * So far those times are:
  *  - On startup and reconfigure - to set the counters to sane initial settings.
- *  -  When a peer has revived from dead, to prevent the revived peer being
+ *  -  When a CachePeer has revived from dead, to prevent the revived CachePeer being
  *     flooded with requests which it has 'missed' during the down period.
  */
 void
 peerClearRR()
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
     for (p = Config.peers; p; p = p->next) {
         p->rr_count = 0;
     }
 }
 
 /**
- * Perform all actions when a peer is detected revived.
+ * Perform all actions when a CachePeer is detected revived.
  */
 void
-peerAlive(peer *p)
+peerAlive(CachePeer *p)
 {
     if (p->stats.logged_state == PEER_DEAD && p->tcp_up) {
         debugs(15, DBG_IMPORTANT, "Detected REVIVED " << neighborTypeStr(p) << ": " << p->name);
@@ -449,10 +452,10 @@ peerAlive(peer *p)
     p->stats.probe_start = 0;
 }
 
-peer *
+CachePeer *
 getDefaultParent(HttpRequest * request)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (neighborType(p, request) != PEER_PARENT)
@@ -473,23 +476,23 @@ getDefaultParent(HttpRequest * request)
     return NULL;
 }
 
-peer *
-getNextPeer(peer * p)
+CachePeer *
+getNextPeer(CachePeer * p)
 {
     return p->next;
 }
 
-peer *
+CachePeer *
 getFirstPeer(void)
 {
     return Config.peers;
 }
 
 static void
-neighborRemove(peer * target)
+neighborRemove(CachePeer * target)
 {
-    peer *p = NULL;
-    peer **P = NULL;
+    CachePeer *p = NULL;
+    CachePeer **P = NULL;
     p = Config.peers;
     P = &Config.peers;
 
@@ -530,8 +533,8 @@ neighbors_init(void)
 {
     struct servent *sep = NULL;
     const char *me = getMyHostname();
-    peer *thisPeer = NULL;
-    peer *next = NULL;
+    CachePeer *thisPeer = NULL;
+    CachePeer *next = NULL;
 
     neighborsRegisterWithCacheManager();
 
@@ -577,7 +580,7 @@ neighborsUdpPing(HttpRequest * request,
 {
     const char *url = entry->url();
     MemObject *mem = entry->mem_obj;
-    peer *p = NULL;
+    CachePeer *p = NULL;
     int i;
     int reqnum = 0;
     int flags;
@@ -608,7 +611,7 @@ neighborsUdpPing(HttpRequest * request,
         debugs(15, 5, "neighborsUdpPing: Peer " << p->host);
 
         if (!peerWouldBePinged(p, request))
-            continue;		/* next peer */
+            continue;		/* next CachePeer */
 
         ++peers_pinged;
 
@@ -687,8 +690,8 @@ neighborsUdpPing(HttpRequest * request,
         p->stats.last_query = squid_curtime;
 
         /*
-         * keep probe_start == 0 for a multicast peer,
-         * so neighborUp() never says this peer is dead.
+         * keep probe_start == 0 for a multicast CachePeer,
+         * so neighborUp() never says this CachePeer is dead.
          */
 
         if ((p->type != PEER_MULTICAST) && (p->stats.probe_start == 0))
@@ -730,9 +733,9 @@ neighborsUdpPing(HttpRequest * request,
     return peers_pinged;
 }
 
-/* lookup the digest of a given peer */
+/* lookup the digest of a given CachePeer */
 lookup_t
-peerDigestLookup(peer * p, HttpRequest * request)
+peerDigestLookup(CachePeer * p, HttpRequest * request)
 {
 #if USE_CACHE_DIGESTS
     const cache_key *key = request ? storeKeyPublicByRequest(request) : NULL;
@@ -772,21 +775,21 @@ peerDigestLookup(peer * p, HttpRequest * request)
     return LOOKUP_NONE;
 }
 
-/* select best peer based on cache digests */
-peer *
+/* select best CachePeer based on cache digests */
+CachePeer *
 neighborsDigestSelect(HttpRequest * request)
 {
-    peer *best_p = NULL;
+    CachePeer *best_p = NULL;
 #if USE_CACHE_DIGESTS
 
     int best_rtt = 0;
     int choice_count = 0;
     int ichoice_count = 0;
-    peer *p;
+    CachePeer *p;
     int p_rtt;
     int i;
 
-    if (!request->flags.hierarchical)
+    if (!request->flags.hierarchical())
         return NULL;
 
     storeKeyPublicByRequest(request);
@@ -814,7 +817,7 @@ neighborsDigestSelect(HttpRequest * request)
 
         debugs(15, 5, "neighborsDigestSelect: peer " << p->host << " rtt: " << p_rtt);
 
-        /* is this peer better than others in terms of rtt ? */
+        /* is this CachePeer better than others in terms of rtt ? */
         if (!best_p || (p_rtt && p_rtt < best_rtt)) {
             best_p = p;
             best_rtt = p_rtt;
@@ -837,7 +840,7 @@ neighborsDigestSelect(HttpRequest * request)
 }
 
 void
-peerNoteDigestLookup(HttpRequest * request, peer * p, lookup_t lookup)
+peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup)
 {
 #if USE_CACHE_DIGESTS
     if (p)
@@ -851,7 +854,7 @@ peerNoteDigestLookup(HttpRequest * request, peer * p, lookup_t lookup)
 }
 
 static void
-neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
+neighborAlive(CachePeer * p, const MemObject * mem, const icp_common_t * header)
 {
     peerAlive(p);
     ++ p->stats.pings_acked;
@@ -863,7 +866,7 @@ neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
 }
 
 static void
-neighborUpdateRtt(peer * p, MemObject * mem)
+neighborUpdateRtt(CachePeer * p, MemObject * mem)
 {
     int rtt, rtt_av_factor;
 
@@ -888,7 +891,7 @@ neighborUpdateRtt(peer * p, MemObject * mem)
 
 #if USE_HTCP
 static void
-neighborAliveHtcp(peer * p, const MemObject * mem, const htcpReplyData * htcp)
+neighborAliveHtcp(CachePeer * p, const MemObject * mem, const htcpReplyData * htcp)
 {
     peerAlive(p);
     ++ p->stats.pings_acked;
@@ -899,7 +902,7 @@ neighborAliveHtcp(peer * p, const MemObject * mem, const htcpReplyData * htcp)
 #endif
 
 static void
-neighborCountIgnored(peer * p)
+neighborCountIgnored(CachePeer * p)
 {
     if (p == NULL)
         return;
@@ -909,12 +912,12 @@ neighborCountIgnored(peer * p)
     ++NLateReplies;
 }
 
-static peer *non_peers = NULL;
+static CachePeer *non_peers = NULL;
 
 static void
 neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
 {
-    peer *np;
+    CachePeer *np;
 
     for (np = non_peers; np; np = np->next) {
         if (np->in_addr != from)
@@ -927,7 +930,7 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
     }
 
     if (np == NULL) {
-        np = (peer *)xcalloc(1, sizeof(peer));
+        np = (CachePeer *)xcalloc(1, sizeof(CachePeer));
         np->in_addr = from;
         np->icp.port = from.GetPort();
         np->type = PEER_NONE;
@@ -946,11 +949,11 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
 /* ignoreMulticastReply
  *
  * * We want to ignore replies from multicast peers if the
- * * cache_host_domain rules would normally prevent the peer
+ * * cache_host_domain rules would normally prevent the CachePeer
  * * from being used
  */
 static int
-ignoreMulticastReply(peer * p, MemObject * mem)
+ignoreMulticastReply(CachePeer * p, MemObject * mem)
 {
     if (p == NULL)
         return 0;
@@ -974,7 +977,7 @@ ignoreMulticastReply(peer * p, MemObject * mem)
 void
 neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address &from)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
     StoreEntry *entry;
     MemObject *mem = NULL;
     peer_t ntype = PEER_NONE;
@@ -1086,10 +1089,10 @@ neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address
     }
 }
 
-peer *
+CachePeer *
 peerFindByName(const char *name)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (!strcasecmp(name, p->name))
@@ -1099,10 +1102,10 @@ peerFindByName(const char *name)
     return p;
 }
 
-peer *
+CachePeer *
 peerFindByNameAndPort(const char *name, unsigned short port)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (strcasecmp(name, p->name))
@@ -1118,17 +1121,17 @@ peerFindByNameAndPort(const char *name, unsigned short port)
 }
 
 int
-neighborUp(const peer * p)
+neighborUp(const CachePeer * p)
 {
     if (!p->tcp_up) {
-        if (!peerProbeConnect((peer *) p)) {
+        if (!peerProbeConnect((CachePeer *) p)) {
             debugs(15, 8, "neighborUp: DOWN (probed): " << p->host << " (" << p->in_addr << ")");
             return 0;
         }
     }
 
     /*
-     * The peer can not be UP if we don't have any IP addresses
+     * The CachePeer can not be UP if we don't have any IP addresses
      * for it.
      */
     if (0 == p->n_addresses) {
@@ -1154,14 +1157,14 @@ neighborUp(const peer * p)
 void
 peerDestroy(void *data)
 {
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
 
     if (p == NULL)
         return;
 
-    struct _domain_ping *nl = NULL;
+    domain_ping *nl = NULL;
 
-    for (struct _domain_ping *l = p->peer_domain; l; l = nl) {
+    for (domain_ping *l = p->peer_domain; l; l = nl) {
         nl = l->next;
         safe_free(l->domain);
         xfree(l);
@@ -1177,7 +1180,7 @@ peerDestroy(void *data)
 }
 
 void
-peerNoteDigestGone(peer * p)
+peerNoteDigestGone(CachePeer * p)
 {
 #if USE_CACHE_DIGESTS
     cbdataReferenceDone(p->digest);
@@ -1187,7 +1190,7 @@ peerNoteDigestGone(peer * p)
 static void
 peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 {
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
 
     int j;
 
@@ -1236,7 +1239,7 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 static void
 peerRefreshDNS(void *data)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     if (eventFind(peerRefreshDNS, NULL))
         eventDelete(peerRefreshDNS, NULL);
@@ -1255,7 +1258,7 @@ peerRefreshDNS(void *data)
 }
 
 static void
-peerConnectFailedSilent(peer * p)
+peerConnectFailedSilent(CachePeer * p)
 {
     p->stats.last_connect_failure = squid_curtime;
 
@@ -1274,14 +1277,14 @@ peerConnectFailedSilent(peer * p)
 }
 
 void
-peerConnectFailed(peer *p)
+peerConnectFailed(CachePeer *p)
 {
     debugs(15, DBG_IMPORTANT, "TCP connection to " << p->host << "/" << p->http_port << " failed");
     peerConnectFailedSilent(p);
 }
 
 void
-peerConnectSucceded(peer * p)
+peerConnectSucceded(CachePeer * p)
 {
     if (!p->tcp_up) {
         debugs(15, 2, "TCP connection to " << p->host << "/" << p->http_port << " succeded");
@@ -1297,7 +1300,7 @@ peerConnectSucceded(peer * p)
 * peerProbeConnect will be called on dead peers by neighborUp
 */
 static bool
-peerProbeConnect(peer * p)
+peerProbeConnect(CachePeer * p)
 {
     time_t ctimeout = p->connect_timeout > 0 ? p->connect_timeout : Config.Timeout.peer_connect;
     bool ret = (squid_curtime - p->stats.last_connect_failure) > (ctimeout * 10);
@@ -1308,7 +1311,7 @@ peerProbeConnect(peer * p)
     if (squid_curtime - p->stats.last_connect_probe == 0)
         return ret;/* don't probe to often */
 
-    /* for each IP address of this peer. find one that we can connect to and probe it. */
+    /* for each IP address of this CachePeer. find one that we can connect to and probe it. */
     for (int i = 0; i < p->n_addresses; ++i) {
         Comm::ConnectionPointer conn = new Comm::Connection;
         conn->remote = p->addresses[i];
@@ -1331,7 +1334,7 @@ peerProbeConnect(peer * p)
 static void
 peerProbeConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno, void *data)
 {
-    peer *p = (peer*)data;
+    CachePeer *p = (CachePeer*)data;
 
     if (status == COMM_OK) {
         peerConnectSucceded(p);
@@ -1345,7 +1348,7 @@ peerProbeConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int
 }
 
 static void
-peerCountMcastPeersSchedule(peer * p, time_t when)
+peerCountMcastPeersSchedule(CachePeer * p, time_t when)
 {
     if (p->mcast.flags.count_event_pending)
         return;
@@ -1361,7 +1364,7 @@ peerCountMcastPeersSchedule(peer * p, time_t when)
 static void
 peerCountMcastPeersStart(void *data)
 {
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
     ps_state *psstate;
     StoreEntry *fake;
     MemObject *mem;
@@ -1373,7 +1376,7 @@ peerCountMcastPeersStart(void *data)
     snprintf(url, MAX_URL, "http://");
     p->in_addr.ToURL(url+7, MAX_URL -8 );
     strcat(url, "/");
-    fake = storeCreateEntry(url, url, request_flags(), METHOD_GET);
+    fake = storeCreateEntry(url, url, RequestFlags(), METHOD_GET);
     HttpRequest *req = HttpRequest::CreateFromUrl(url);
     psstate = new ps_state;
     psstate->request = HTTPMSGLOCK(req);
@@ -1407,7 +1410,7 @@ peerCountMcastPeersDone(void *data)
     StoreEntry *fake = psstate->entry;
 
     if (cbdataReferenceValid(psstate->callback_data)) {
-        peer *p = (peer *)psstate->callback_data;
+        CachePeer *p = (CachePeer *)psstate->callback_data;
         p->mcast.flags.counting = 0;
         p->mcast.avg_n_members = Math::doubleAverage(p->mcast.avg_n_members, (double) psstate->ping.n_recv, ++p->mcast.n_times_counted, 10);
         debugs(15, DBG_IMPORTANT, "Group " << p->host  << ": " << psstate->ping.n_recv  <<
@@ -1426,7 +1429,7 @@ peerCountMcastPeersDone(void *data)
 }
 
 static void
-peerCountHandleIcpReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *hdrnotused, void *data)
+peerCountHandleIcpReply(CachePeer * p, peer_t type, AnyP::ProtocolType proto, void *hdrnotused, void *data)
 {
     int rtt_av_factor;
 
@@ -1459,7 +1462,7 @@ neighborDumpNonPeers(StoreEntry * sentry)
 }
 
 void
-dump_peer_options(StoreEntry * sentry, peer * p)
+dump_peer_options(StoreEntry * sentry, CachePeer * p)
 {
     if (p->options.proxy_only)
         storeAppendPrintf(sentry, " proxy-only");
@@ -1577,11 +1580,11 @@ dump_peer_options(StoreEntry * sentry, peer * p)
 }
 
 static void
-dump_peers(StoreEntry * sentry, peer * peers)
+dump_peers(StoreEntry * sentry, CachePeer * peers)
 {
-    peer *e = NULL;
+    CachePeer *e = NULL;
     char ntoabuf[MAX_IPSTRLEN];
-    struct _domain_ping *d = NULL;
+    domain_ping *d = NULL;
     icp_opcode op;
     int i;
 
@@ -1688,7 +1691,7 @@ neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const Ip::Addres
 {
     StoreEntry *e = Store::Root().get(key);
     MemObject *mem = NULL;
-    peer *p;
+    CachePeer *p;
     peer_t ntype = PEER_NONE;
     debugs(15, 6, "neighborsHtcpReply: " <<
            (htcp->hit ? "HIT" : "MISS") << " " <<
@@ -1753,7 +1756,7 @@ neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const Ip::Addres
 void
 neighborsHtcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, htcp_clr_reason reason)
 {
-    peer *p;
+    CachePeer *p;
     char buf[128];
 
     for (p = Config.peers; p; p = p->next) {
@@ -34,54 +34,53 @@
 #define SQUID_NEIGHBORS_H_
 
 #include "enums.h"
-#include "HttpRequestMethod.h"
+#include "ICP.h"
 #include "lookup_t.h"
-#include "ip/Address.h"
-#include "typedefs.h"
 
 class HttpRequest;
-class peer;
+class HttpRequestMethod;
+class CachePeer;
 class StoreEntry;
 
-SQUIDCEXTERN peer *getFirstPeer(void);
-SQUIDCEXTERN peer *getFirstUpParent(HttpRequest *);
-SQUIDCEXTERN peer *getNextPeer(peer *);
-SQUIDCEXTERN peer *getSingleParent(HttpRequest *);
-SQUIDCEXTERN int neighborsCount(HttpRequest *);
-SQUIDCEXTERN int neighborsUdpPing(HttpRequest *,
+extern CachePeer *getFirstPeer(void);
+extern CachePeer *getFirstUpParent(HttpRequest *);
+extern CachePeer *getNextPeer(CachePeer *);
+extern CachePeer *getSingleParent(HttpRequest *);
+extern int neighborsCount(HttpRequest *);
+extern int neighborsUdpPing(HttpRequest *,
                                   StoreEntry *,
                                   IRCB * callback,
                                   void *data,
                                   int *exprep,
                                   int *timeout);
-SQUIDCEXTERN void neighborAddAcl(const char *, const char *);
+extern void neighborAddAcl(const char *, const char *);
 
-SQUIDCEXTERN void neighborsUdpAck(const cache_key *, icp_common_t *, const Ip::Address &);
-SQUIDCEXTERN void neighborAdd(const char *, const char *, int, int, int, int, int);
-SQUIDCEXTERN void neighbors_init(void);
+extern void neighborsUdpAck(const cache_key *, icp_common_t *, const Ip::Address &);
+extern void neighborAdd(const char *, const char *, int, int, int, int, int);
+extern void neighbors_init(void);
 #if USE_HTCP
-SQUIDCEXTERN void neighborsHtcpClear(StoreEntry *, const char *, HttpRequest *, const HttpRequestMethod &, htcp_clr_reason);
+extern void neighborsHtcpClear(StoreEntry *, const char *, HttpRequest *, const HttpRequestMethod &, htcp_clr_reason);
 #endif
-SQUIDCEXTERN peer *peerFindByName(const char *);
-SQUIDCEXTERN peer *peerFindByNameAndPort(const char *, unsigned short);
-SQUIDCEXTERN peer *getDefaultParent(HttpRequest * request);
-SQUIDCEXTERN peer *getRoundRobinParent(HttpRequest * request);
-SQUIDCEXTERN peer *getWeightedRoundRobinParent(HttpRequest * request);
-SQUIDCEXTERN void peerClearRRStart(void);
-SQUIDCEXTERN void peerClearRR(void);
-SQUIDCEXTERN lookup_t peerDigestLookup(peer * p, HttpRequest * request);
-SQUIDCEXTERN peer *neighborsDigestSelect(HttpRequest * request);
-SQUIDCEXTERN void peerNoteDigestLookup(HttpRequest * request, peer * p, lookup_t lookup);
-SQUIDCEXTERN void peerNoteDigestGone(peer * p);
-SQUIDCEXTERN int neighborUp(const peer * e);
-SQUIDCEXTERN CBDUNL peerDestroy;
-SQUIDCEXTERN const char *neighborTypeStr(const peer * e);
-SQUIDCEXTERN peer_t neighborType(const peer *, const HttpRequest *);
-SQUIDCEXTERN void peerConnectFailed(peer *);
-SQUIDCEXTERN void peerConnectSucceded(peer *);
-SQUIDCEXTERN void dump_peer_options(StoreEntry *, peer *);
-SQUIDCEXTERN int peerHTTPOkay(const peer *, HttpRequest *);
+extern CachePeer *peerFindByName(const char *);
+extern CachePeer *peerFindByNameAndPort(const char *, unsigned short);
+extern CachePeer *getDefaultParent(HttpRequest * request);
+extern CachePeer *getRoundRobinParent(HttpRequest * request);
+extern CachePeer *getWeightedRoundRobinParent(HttpRequest * request);
+extern void peerClearRRStart(void);
+extern void peerClearRR(void);
+extern lookup_t peerDigestLookup(CachePeer * p, HttpRequest * request);
+extern CachePeer *neighborsDigestSelect(HttpRequest * request);
+extern void peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup);
+extern void peerNoteDigestGone(CachePeer * p);
+extern int neighborUp(const CachePeer * e);
+extern CBDUNL peerDestroy;
+extern const char *neighborTypeStr(const CachePeer * e);
+extern peer_t neighborType(const CachePeer *, const HttpRequest *);
+extern void peerConnectFailed(CachePeer *);
+extern void peerConnectSucceded(CachePeer *);
+extern void dump_peer_options(StoreEntry *, CachePeer *);
+extern int peerHTTPOkay(const CachePeer *, HttpRequest *);
 
-SQUIDCEXTERN peer *whichPeer(const Ip::Address &from);
+extern CachePeer *whichPeer(const Ip::Address &from);
 
 #endif /* SQUID_NEIGHBORS_H_ */
@@ -38,6 +38,7 @@
 #include "globals.h"
 #include "mgr/Registration.h"
 #include "pconn.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 #define PCONN_FDS_SZ	8	/* pconn set size, increase for better memcache hit rate */
@@ -34,6 +34,7 @@
 #include "squid.h"
 #if USE_CACHE_DIGESTS
 #include "CacheDigest.h"
+#include "CachePeer.h"
 #include "event.h"
 #include "forward.h"
 #include "globals.h"
@@ -90,7 +91,7 @@ static time_t pd_last_req_time = 0;	/* last call to Check */
 
 /* initialize peer digest */
 static void
-peerDigestInit(PeerDigest * pd, peer * p)
+peerDigestInit(PeerDigest * pd, CachePeer * p)
 {
     assert(pd && p);
 
@@ -137,7 +138,7 @@ PeerDigest::operator delete (void *address)
 
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
-peerDigestCreate(peer * p)
+peerDigestCreate(CachePeer * p)
 {
     PeerDigest *pd;
     assert(p);
@@ -164,7 +165,7 @@ peerDigestDestroy(PeerDigest * pd)
      * tell it that the digest is gone.
      */
     if (cbdataReferenceValidDone(peerTmp, &p))
-        peerNoteDigestGone((peer *)p);
+        peerNoteDigestGone((CachePeer *)p);
 
     peerDigestClean(pd);
 
@@ -312,7 +313,7 @@ CBDATA_TYPE(DigestFetchState);
 static void
 peerDigestRequest(PeerDigest * pd)
 {
-    peer *p = pd->peer;
+    CachePeer *p = pd->peer;
     StoreEntry *e, *old_e;
     char *url;
     const cache_key *key;
@@ -369,10 +370,10 @@ peerDigestRequest(PeerDigest * pd)
 
     pd_last_req_time = squid_curtime;
 
-    req->flags.cachable = 1;
+    req->flags.setCachable();
 
     /* the rest is based on clientProcessExpired() */
-    req->flags.refresh = 1;
+    req->flags.setRefresh();
 
     old_e = fetch->old_entry = Store::Root().get(key);
 
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
+#include "CachePeer.h"
 #include "carp.h"
 #include "client_side.h"
 #include "DnsLookupDetails.h"
@@ -50,6 +51,7 @@
 #include "peer_sourcehash.h"
 #include "peer_userhash.h"
 #include "PeerSelectState.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
@@ -68,18 +70,18 @@ static void peerSelectFoo(ps_state *);
 static void peerPingTimeout(void *data);
 static IRCB peerHandlePingReply;
 static void peerSelectStateFree(ps_state * psstate);
-static void peerIcpParentMiss(peer *, icp_common_t *, ps_state *);
+static void peerIcpParentMiss(CachePeer *, icp_common_t *, ps_state *);
 #if USE_HTCP
-static void peerHtcpParentMiss(peer *, htcpReplyData *, ps_state *);
-static void peerHandleHtcpReply(peer *, peer_t, htcpReplyData *, void *);
+static void peerHtcpParentMiss(CachePeer *, htcpReplyData *, ps_state *);
+static void peerHandleHtcpReply(CachePeer *, peer_t, htcpReplyData *, void *);
 #endif
 static int peerCheckNetdbDirect(ps_state * psstate);
 static void peerGetSomeNeighbor(ps_state *);
 static void peerGetSomeNeighborReplies(ps_state *);
 static void peerGetSomeDirect(ps_state *);
 static void peerGetSomeParent(ps_state *);
 static void peerGetAllParents(ps_state *);
-static void peerAddFwdServer(FwdServer **, peer *, hier_code);
+static void peerAddFwdServer(FwdServer **, CachePeer *, hier_code);
 static void peerSelectPinned(ps_state * ps);
 static void peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data);
 
@@ -124,7 +126,7 @@ peerSelectIcpPing(HttpRequest * request, int direct, StoreEntry * entry)
     assert(direct != DIRECT_YES);
     debugs(44, 3, "peerSelectIcpPing: " << entry->url()  );
 
-    if (!request->flags.hierarchical && direct != DIRECT_NO)
+    if (!request->flags.hierarchical() && direct != DIRECT_NO)
         return 0;
 
     if (EBIT_TEST(entry->flags, KEY_PRIVATE) && !neighbors_do_private_keys)
@@ -231,9 +233,9 @@ peerSelectDnsPaths(ps_state *psstate)
     // To resolve this we must use only the original client destination when going DIRECT
     // on intercepted traffic which failed Host verification
     const HttpRequest *req = psstate->request;
-    const bool isIntercepted = !req->flags.redirected &&
-                               (req->flags.intercepted || req->flags.spoof_client_ip);
-    const bool useOriginalDst = Config.onoff.client_dst_passthru || !req->flags.hostVerified;
+    const bool isIntercepted = !req->flags.isRedirected() &&
+                               (req->flags.intercepted() || req->flags.spoofClientIp());
+    const bool useOriginalDst = Config.onoff.client_dst_passthru || !req->flags.hostVerified();
     const bool choseDirect = fs && fs->code == HIER_DIRECT;
     if (isIntercepted && useOriginalDst && choseDirect) {
         // construct a "result" adding the ORIGINAL_DST to the set instead of DIRECT
@@ -337,7 +339,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
                 break;
 
             // for TPROXY we must skip unusable addresses.
-            if (psstate->request->flags.spoof_client_ip && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
+            if (psstate->request->flags.spoofClientIp() && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
                 if (ia->in_addrs[n].IsIPv4() != psstate->request->client_addr.IsIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
                     continue;
@@ -380,7 +382,7 @@ static int
 peerCheckNetdbDirect(ps_state * psstate)
 {
 #if USE_ICMP
-    peer *p;
+    CachePeer *p;
     int myrtt;
     int myhops;
 
@@ -427,26 +429,26 @@ peerSelectFoo(ps_state * ps)
     HttpRequest *request = ps->request;
     debugs(44, 3, "peerSelectFoo: '" << RequestMethodStr(request->method) << " " << request->GetHost() << "'");
 
-    /** If we don't know whether DIRECT is permitted ... */
+    /* If we don't know whether DIRECT is permitted ... */
     if (ps->direct == DIRECT_UNKNOWN) {
         if (ps->always_direct == ACCESS_DUNNO) {
             debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (always_direct to be checked)");
-            /** check always_direct; */
+            /* check always_direct; */
             ps->acl_checklist = new ACLFilledChecklist(Config.accessList.AlwaysDirect, request, NULL);
             ps->acl_checklist->nonBlockingCheck(peerCheckAlwaysDirectDone, ps);
             return;
         } else if (ps->never_direct == ACCESS_DUNNO) {
             debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (never_direct to be checked)");
-            /** check never_direct; */
+            /* check never_direct; */
             ps->acl_checklist = new ACLFilledChecklist(Config.accessList.NeverDirect, request, NULL);
             ps->acl_checklist->nonBlockingCheck(peerCheckNeverDirectDone, ps);
             return;
-        } else if (request->flags.no_direct) {
-            /** if we are accelerating, direct is not an option. */
+        } else if (request->flags.noDirect()) {
+            /* if we are accelerating, direct is not an option. */
             ps->direct = DIRECT_NO;
             debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (forced non-direct)");
-        } else if (request->flags.loopdetect) {
-            /** if we are in a forwarding-loop, direct is not an option. */
+        } else if (request->flags.loopDetect()) {
+            /* if we are in a forwarding-loop, direct is not an option. */
             ps->direct = DIRECT_YES;
             debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (forwarding loop detected)");
         } else if (peerCheckNetdbDirect(ps)) {
@@ -490,7 +492,7 @@ peerSelectFoo(ps_state * ps)
         if (Config.onoff.prefer_direct)
             peerGetSomeDirect(ps);
 
-        if (request->flags.hierarchical || !Config.onoff.nonhierarchical_direct) {
+        if (request->flags.hierarchical() || !Config.onoff.nonhierarchical_direct) {
             peerGetSomeParent(ps);
             peerGetAllParents(ps);
         }
@@ -505,7 +507,7 @@ peerSelectFoo(ps_state * ps)
     peerSelectDnsPaths(ps);
 }
 
-bool peerAllowedToUse(const peer * p, HttpRequest * request);
+bool peerAllowedToUse(const CachePeer * p, HttpRequest * request);
 
 /**
  * peerSelectPinned
@@ -518,7 +520,7 @@ peerSelectPinned(ps_state * ps)
     HttpRequest *request = ps->request;
     if (!request->pinnedConnection())
         return;
-    peer *pear = request->pinnedConnection()->pinnedPeer();
+    CachePeer *pear = request->pinnedConnection()->pinnedPeer();
     if (Comm::IsConnOpen(request->pinnedConnection()->validatePinnedConnection(request, pear))) {
         if (pear && peerAllowedToUse(pear, request)) {
             peerAddFwdServer(&ps->servers, pear, PINNED);
@@ -547,7 +549,7 @@ peerGetSomeNeighbor(ps_state * ps)
 {
     StoreEntry *entry = ps->entry;
     HttpRequest *request = ps->request;
-    peer *p;
+    CachePeer *p;
     hier_code code = HIER_NONE;
     assert(entry->ping_status == PING_NONE);
 
@@ -611,7 +613,7 @@ static void
 peerGetSomeNeighborReplies(ps_state * ps)
 {
     HttpRequest *request = ps->request;
-    peer *p = NULL;
+    CachePeer *p = NULL;
     hier_code code = HIER_NONE;
     assert(ps->entry->ping_status == PING_WAITING);
     assert(ps->direct != DIRECT_YES);
@@ -662,7 +664,7 @@ peerGetSomeDirect(ps_state * ps)
 static void
 peerGetSomeParent(ps_state * ps)
 {
-    peer *p;
+    CachePeer *p;
     HttpRequest *request = ps->request;
     hier_code code = HIER_NONE;
     debugs(44, 3, "peerGetSomeParent: " << RequestMethodStr(request->method) << " " << request->GetHost());
@@ -699,7 +701,7 @@ peerGetSomeParent(ps_state * ps)
 static void
 peerGetAllParents(ps_state * ps)
 {
-    peer *p;
+    CachePeer *p;
     HttpRequest *request = ps->request;
     /* Add all alive parents */
 
@@ -759,7 +761,7 @@ peerSelectInit(void)
 }
 
 static void
-peerIcpParentMiss(peer * p, icp_common_t * header, ps_state * ps)
+peerIcpParentMiss(CachePeer * p, icp_common_t * header, ps_state * ps)
 {
     int rtt;
 
@@ -800,7 +802,7 @@ peerIcpParentMiss(peer * p, icp_common_t * header, ps_state * ps)
 }
 
 static void
-peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
+peerHandleIcpReply(CachePeer * p, peer_t type, icp_common_t * header, void *data)
 {
     ps_state *psstate = (ps_state *)data;
     icp_opcode op = header->getOpCode();
@@ -834,7 +836,7 @@ peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
 
 #if USE_HTCP
 static void
-peerHandleHtcpReply(peer * p, peer_t type, htcpReplyData * htcp, void *data)
+peerHandleHtcpReply(CachePeer * p, peer_t type, htcpReplyData * htcp, void *data)
 {
     ps_state *psstate = (ps_state *)data;
     debugs(44, 3, "peerHandleHtcpReply: " <<
@@ -859,7 +861,7 @@ peerHandleHtcpReply(peer * p, peer_t type, htcpReplyData * htcp, void *data)
 }
 
 static void
-peerHtcpParentMiss(peer * p, htcpReplyData * htcp, ps_state * ps)
+peerHtcpParentMiss(CachePeer * p, htcpReplyData * htcp, ps_state * ps)
 {
     int rtt;
 
@@ -900,7 +902,7 @@ peerHtcpParentMiss(peer * p, htcpReplyData * htcp, ps_state * ps)
 #endif
 
 static void
-peerHandlePingReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *pingdata, void *data)
+peerHandlePingReply(CachePeer * p, peer_t type, AnyP::ProtocolType proto, void *pingdata, void *data)
 {
     if (proto == AnyP::PROTO_ICP)
         peerHandleIcpReply(p, type, (icp_common_t *)pingdata, data);
@@ -917,7 +919,7 @@ peerHandlePingReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *pingd
 }
 
 static void
-peerAddFwdServer(FwdServer ** FSVR, peer * p, hier_code code)
+peerAddFwdServer(FwdServer ** FSVR, CachePeer * p, hier_code code)
 {
     FwdServer *fs = (FwdServer *)memAllocate(MEM_FWD_SERVER);
     debugs(44, 5, "peerAddFwdServer: adding " <<
@@ -33,9 +33,11 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 #if HAVE_MATH_H
@@ -45,15 +47,15 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_sourcehash_peers = 0;
-static peer **sourcehash_peers = NULL;
+static CachePeer **sourcehash_peers = NULL;
 static OBJH peerSourceHashCachemgr;
 static void peerSourceHashRegisterWithCacheManager(void);
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -64,8 +66,8 @@ peerSourceHashInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -96,7 +98,7 @@ peerSourceHashInit(void)
     if (n_sourcehash_peers == 0)
         return;
 
-    sourcehash_peers = (peer **)xcalloc(n_sourcehash_peers, sizeof(*sourcehash_peers));
+    sourcehash_peers = (CachePeer **)xcalloc(n_sourcehash_peers, sizeof(*sourcehash_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = sourcehash_peers, p = Config.peers; p; p = p->next) {
@@ -164,13 +166,13 @@ peerSourceHashRegisterWithCacheManager(void)
                         peerSourceHashCachemgr, 0, 1);
 }
 
-peer *
+CachePeer *
 peerSourceHashSelectParent(HttpRequest * request)
 {
     int k;
     const char *c;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -189,7 +191,7 @@ peerSourceHashSelectParent(HttpRequest * request)
     for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_sourcehash_peers; ++k) {
         tp = sourcehash_peers[k];
         combined_hash = (user_hash ^ tp->sourcehash.hash);
@@ -214,7 +216,7 @@ peerSourceHashSelectParent(HttpRequest * request)
 static void
 peerSourceHashCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -34,10 +34,10 @@
 #ifndef SQUID_PEER_SOURCEHASH_H_
 #define SQUID_PEER_SOURCEHASH_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
 extern void peerSourceHashInit(void);
-extern peer * peerSourceHashSelectParent(HttpRequest * request);
+extern CachePeer * peerSourceHashSelectParent(HttpRequest * request);
 
 #endif /* SQUID_PEER_SOURCEHASH_H_ */
@@ -37,10 +37,12 @@
 #if USE_AUTH
 
 #include "auth/UserRequest.h"
+#include "CachePeer.h"
 #include "globals.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 #if HAVE_MATH_H
@@ -50,15 +52,15 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_userhash_peers = 0;
-static peer **userhash_peers = NULL;
+static CachePeer **userhash_peers = NULL;
 static OBJH peerUserHashCachemgr;
 static void peerUserHashRegisterWithCacheManager(void);
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -69,8 +71,8 @@ peerUserHashInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -101,7 +103,7 @@ peerUserHashInit(void)
     if (n_userhash_peers == 0)
         return;
 
-    userhash_peers = (peer **)xcalloc(n_userhash_peers, sizeof(*userhash_peers));
+    userhash_peers = (CachePeer **)xcalloc(n_userhash_peers, sizeof(*userhash_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = userhash_peers, p = Config.peers; p; p = p->next) {
@@ -169,13 +171,13 @@ peerUserHashRegisterWithCacheManager(void)
                         0, 1);
 }
 
-peer *
+CachePeer *
 peerUserHashSelectParent(HttpRequest * request)
 {
     int k;
     const char *c;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -197,7 +199,7 @@ peerUserHashSelectParent(HttpRequest * request)
     for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_userhash_peers; ++k) {
         tp = userhash_peers[k];
         combined_hash = (user_hash ^ tp->userhash.hash);
@@ -222,7 +224,7 @@ peerUserHashSelectParent(HttpRequest * request)
 static void
 peerUserHashCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -34,10 +34,10 @@
 #ifndef SQUID_PEER_USERHASH_H_
 #define SQUID_PEER_USERHASH_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
 extern void peerUserHashInit(void);
-extern peer * peerUserHashSelectParent(HttpRequest * request);
+extern CachePeer * peerUserHashSelectParent(HttpRequest * request);
 
 #endif /* SQUID_PEER_USERHASH_H_ */
@@ -44,6 +44,7 @@
 #include "mgr/Registration.h"
 #include "redirect.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -41,7 +41,9 @@
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "MemObject.h"
+#include "RefreshPattern.h"
 #include "SquidTime.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 
@@ -108,16 +110,16 @@ refreshCounts[rcCount];
 #define REFRESH_DEFAULT_PCT	0.20
 #define REFRESH_DEFAULT_MAX	(time_t)259200
 
-static const refresh_t *refreshUncompiledPattern(const char *);
+static const RefreshPattern *refreshUncompiledPattern(const char *);
 static OBJH refreshStats;
-static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const refresh_t * R, stale_flags * sf);
+static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf);
 
-static refresh_t DefaultRefresh;
+static RefreshPattern DefaultRefresh;
 
-const refresh_t *
+const RefreshPattern *
 refreshLimits(const char *url)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
 
     for (R = Config.Refresh; R; R = R->next) {
         if (!regexec(&(R->compiled_pattern), url, 0, 0, 0))
@@ -127,10 +129,10 @@ refreshLimits(const char *url)
     return NULL;
 }
 
-static const refresh_t *
+static const RefreshPattern *
 refreshUncompiledPattern(const char *pat)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
 
     for (R = Config.Refresh; R; R = R->next) {
         if (0 == strcmp(R->pattern, pat))
@@ -156,7 +158,7 @@ refreshUncompiledPattern(const char *pat)
  * times.
  */
 static int
-refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const refresh_t * R, stale_flags * sf)
+refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf)
 {
     /** \par
      * Check for an explicit expiration time (Expires: header).
@@ -230,7 +232,7 @@ refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age,
 static int
 refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
     const char *uri = NULL;
     time_t age = 0;
     time_t check_time = squid_curtime + delta;
@@ -265,7 +267,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 
     debugs(22, 3, "\tentry->timestamp:\t" << mkrfc1123(entry->timestamp));
 
-    if (request && !request->flags.ignore_cc) {
+    if (request && !request->flags.ignoringCacheControl()) {
         const HttpHdrCc *const cc = request->cache_control;
         if (cc && cc->hasMinFresh()) {
             const int32_t minFresh=cc->minFresh();
@@ -291,7 +293,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
             entry->mem_obj->getReply()->cache_control->staleIfError() < staleness) {
 
         debugs(22, 3, "refreshCheck: stale-if-error period expired.");
-        request->flags.fail_on_validation_err = 1;
+        request->flags.setFailOnValidationError();
     }
 
     if (EBIT_TEST(entry->flags, ENTRY_REVALIDATE) && staleness > -1
@@ -301,23 +303,23 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
        ) {
         debugs(22, 3, "refreshCheck: YES: Must revalidate stale response");
         if (request)
-            request->flags.fail_on_validation_err = 1;
+            request->flags.setFailOnValidationError();
         return STALE_MUST_REVALIDATE;
     }
 
     /* request-specific checks */
-    if (request && !request->flags.ignore_cc) {
+    if (request && !request->flags.ignoringCacheControl()) {
         HttpHdrCc *cc = request->cache_control;
 
-        if (request->flags.ims && (R->flags.refresh_ims || Config.onoff.refresh_all_ims)) {
+        if (request->flags.hasIMS() && (R->flags.refresh_ims || Config.onoff.refresh_all_ims)) {
             /* The clients no-cache header is changed into a IMS query */
             debugs(22, 3, "refreshCheck: YES: refresh-ims");
             return STALE_FORCED_RELOAD;
         }
 
 #if USE_HTTP_VIOLATIONS
 
-        if (!request->flags.nocache_hack) {
+        if (!request->flags.noCacheHackEnabled()) {
             (void) 0;
         } else if (R->flags.ignore_reload) {
             /* The clients no-cache header is ignored */
@@ -329,7 +331,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
         } else {
             /* The clients no-cache header is not overridden on this request */
             debugs(22, 3, "refreshCheck: YES: client reload");
-            request->flags.nocache = 1;
+            request->flags.setNocache();
             return STALE_FORCED_RELOAD;
         }
 
@@ -396,7 +398,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
     if ( max_stale >= 0 && staleness > max_stale) {
         debugs(22, 3, "refreshCheck: YES: max-stale limit");
         if (request)
-            request->flags.fail_on_validation_err = 1;
+            request->flags.setFailOnValidationError();
         return STALE_MAX_STALE;
     }
 
@@ -492,7 +494,8 @@ refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
     int reason = refreshCheck(entry, request, 0);
     ++ refreshCounts[rcHTTP].total;
     ++ refreshCounts[rcHTTP].status[reason];
-    request->flags.stale_if_hit = refreshIsStaleIfHit(reason);
+    if (refreshIsStaleIfHit(reason))
+        request->flags.setStaleIfHit();
     return (Config.onoff.offline || reason < 200) ? 0 : 1;
 }
 
@@ -534,7 +537,7 @@ refreshCheckDigest(const StoreEntry * entry, time_t delta)
 time_t
 getMaxAge(const char *url)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
     debugs(22, 3, "getMaxAge: '" << url << "'");
 
     if ((R = refreshLimits(url)))
@@ -33,6 +33,8 @@
 #ifndef SQUID_REFRESH_H_
 #define SQUID_REFRESH_H_
 
+class RefreshPattern;
+
 extern void refreshAddToList(const char *, int, time_t, int, time_t);
 extern int refreshIsCachable(const StoreEntry *);
 extern int refreshCheckHTTP(const StoreEntry *, HttpRequest *);
@@ -41,6 +43,6 @@ extern int refreshCheckHTCP(const StoreEntry *, HttpRequest *);
 extern int refreshCheckDigest(const StoreEntry *, time_t delta);
 extern time_t getMaxAge(const char *url);
 extern void refreshInit(void);
-extern const refresh_t *refreshLimits(const char *url);
+extern const RefreshPattern *refreshLimits(const char *url);
 
 #endif /* SQUID_REFRESH_H_ */
@@ -39,6 +39,7 @@
 #include "globals.h"
 #include "ICP.h"
 #include "ipcache.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "tools.h"
 
@@ -31,6 +31,7 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "cache_snmp.h"
 #include "globals.h"
 #include "mem_node.h"
@@ -39,6 +40,7 @@
 #include "snmp_core.h"
 #include "StatCounters.h"
 #include "StatHist.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "stat.h"
@@ -207,7 +209,7 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
 
     Ip::Address laddr;
     char *cp = NULL;
-    peer *p = NULL;
+    CachePeer *p = NULL;
     int cnt = 0;
     debugs(49, 5, "snmp_meshPtblFn: peer " << Var->name[LEN_SQ_MESH + 3] << " requested!");
     *ErrP = SNMP_ERR_NOERROR;
@@ -32,6 +32,7 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "base/CbcPointer.h"
+#include "CachePeer.h"
 #include "client_db.h"
 #include "comm.h"
 #include "comm/Connection.h"
@@ -42,6 +43,7 @@
 #include "snmp_agent.h"
 #include "snmp_core.h"
 #include "snmp/Forwarder.h"
+#include "SquidConfig.h"
 #include "tools.h"
 
 static void snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo);
@@ -747,7 +749,7 @@ static oid *
 peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
 {
     oid *instance = NULL;
-    peer *peers = Config.peers;
+    CachePeer *peers = Config.peers;
 
     if (peers == NULL) {
         debugs(49, 6, "snmp peer_Inst: No Peers.");
@@ -9,6 +9,9 @@
 #if HAVE_LIMITS
 #include <limits>
 #endif
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
 
 Ssl::CertificateStorageAction::CertificateStorageAction(const Mgr::Command::Pointer &cmd)
         :   Mgr::Action(cmd)
@@ -17,6 +17,8 @@
 #if HAVE_LIST
 #include <list>
 #endif
+#include <openssl/ssl.h>
+
 
 /// TODO: Replace on real size.
 #define SSL_CTX_SIZE 1024
@@ -1,7 +1,3 @@
-/*
- * 2008/11/14
- */
-
 #include "squid.h"
 #include "anyp/PortCfg.h"
 #include "ssl/Config.h"
@@ -10,6 +6,7 @@
 #include "SquidTime.h"
 #include "SwapDir.h"
 #include "wordlist.h"
+#include "SquidConfig.h"
 
 Ssl::Helper * Ssl::Helper::GetInstance()
 {
@@ -42,6 +42,7 @@
 #include "anyp/PortCfg.h"
 #include "fde.h"
 #include "globals.h"
+#include "SquidConfig.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/support.h"
 #include "ssl/gadgets.h"
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "CacheDigest.h"
+#include "CachePeer.h"
 #include "client_side_request.h"
 #include "client_side.h"
 #include "comm/Connection.h"
@@ -53,6 +54,7 @@
 #include "mgr/ServiceTimesAction.h"
 #include "neighbors.h"
 #include "PeerDigest.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -219,19 +221,19 @@ GetIoStats(Mgr::IoActionData& stats)
 
     stats.http_reads = IOStats.Http.reads;
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < iostats::histSize; ++i) {
         stats.http_read_hist[i] = IOStats.Http.read_hist[i];
     }
 
     stats.ftp_reads = IOStats.Ftp.reads;
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < iostats::histSize; ++i) {
         stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];
     }
 
     stats.gopher_reads = IOStats.Gopher.reads;
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < iostats::histSize; ++i) {
         stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];
     }
 }
@@ -245,7 +247,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.http_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < iostats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -258,7 +260,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.ftp_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < iostats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -271,7 +273,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.gopher_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < iostats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -1810,7 +1812,7 @@ statPeerSelect(StoreEntry * sentry)
 {
 #if USE_CACHE_DIGESTS
     StatCounters *f = &statCounter;
-    peer *peer;
+    CachePeer *peer;
     const int tot_used = f->cd.times_used + f->icp.times_used;
 
     /* totals */
@@ -48,6 +48,8 @@
 #include "mgr/StoreIoAction.h"
 #include "profiler/Profiler.h"
 #include "repl_modules.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Stack.h"
 #include "StatCounters.h"
@@ -816,7 +818,7 @@ StoreEntry::setPublicKey()
 }
 
 StoreEntry *
-storeCreateEntry(const char *url, const char *log_url, request_flags flags, const HttpRequestMethod& method)
+storeCreateEntry(const char *url, const char *log_url, const RequestFlags &flags, const HttpRequestMethod& method)
 {
     StoreEntry *e = NULL;
     MemObject *mem = NULL;
@@ -827,12 +829,12 @@ storeCreateEntry(const char *url, const char *log_url, request_flags flags, cons
     mem = e->mem_obj;
     mem->method = method;
 
-    if (neighbors_do_private_keys || !flags.hierarchical)
+    if (neighbors_do_private_keys || !flags.hierarchical())
         e->setPrivateKey();
     else
         e->setPublicKey();
 
-    if (flags.cachable) {
+    if (flags.isCachable()) {
         EBIT_SET(e->flags, ENTRY_CACHABLE);
         EBIT_CLR(e->flags, RELEASE_REQUEST);
     } else {
@@ -1965,7 +1967,7 @@ StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 {
     const String reqETags = request.header.getList(HDR_IF_NONE_MATCH);
     // weak comparison is allowed only for HEAD or full-body GET requests
-    const bool allowWeakMatch = !request.flags.range &&
+    const bool allowWeakMatch = !request.flags.isRanged() &&
                                 (request.method == METHOD_GET || request.method == METHOD_HEAD);
     return hasOneOfEtags(reqETags, allowWeakMatch);
 }
@@ -40,6 +40,7 @@
 #include "MemObject.h"
 #include "mime_header.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
 #include "StoreClient.h"
 #include "Store.h"
@@ -790,7 +791,7 @@ CheckQuickAbort2(StoreEntry * entry)
     assert(mem);
     debugs(90, 3, "CheckQuickAbort2: entry=" << entry << ", mem=" << mem);
 
-    if (mem->request && !mem->request->flags.cachable) {
+    if (mem->request && !mem->request->flags.isCachable()) {
         debugs(90, 3, "CheckQuickAbort2: YES !mem->request->flags.cachable");
         return 1;
     }
@@ -51,6 +51,7 @@
 #include "MemObject.h"
 #include "PeerDigest.h"
 #include "refresh.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreSearch.h"
@@ -376,7 +377,7 @@ storeDigestRebuildStep(void *datanotused)
 static void
 storeDigestRewriteStart(void *datanotused)
 {
-    request_flags flags;
+    RequestFlags flags;
     char *url;
     StoreEntry *e;
 
@@ -391,7 +392,7 @@ storeDigestRewriteStart(void *datanotused)
     debugs(71, 2, "storeDigestRewrite: start rewrite #" << sd_state.rewrite_count + 1);
     /* make new store entry */
     url = internalLocalUri("/squid-internal-periodic/", StoreDigestFileName);
-    flags.cachable = 1;
+    flags.setCachable();
     e = storeCreateEntry(url, url, flags, METHOD_GET);
     assert(e);
     sd_state.rewrite_lock = e;
@@ -37,6 +37,7 @@
 #include "MemObject.h"
 #include "MemStore.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -1,6 +1,7 @@
 #include "squid.h"
 #include "Store.h"
 #include "MemObject.h"
+#include "SquidConfig.h"
 #include "SwapDir.h"
 
 StoreIoStats store_io_stats;
@@ -38,6 +38,7 @@
 #include "mgr/Registration.h"
 #include "Store.h"
 #include "store_log.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 static const char *storeLogTags[] = {
@@ -41,12 +41,13 @@
 #include "store_digest.h"
 #include "store_rebuild.h"
 #include "StoreSearch.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
-static struct _store_rebuild_data counts;
+static StoreRebuildData counts;
 
 static struct timeval rebuild_start;
 static void storeCleanup(void *);
@@ -136,7 +137,7 @@ storeCleanup(void *datanotused)
 /* meta data recreated from disk image in swap directory */
 void
 
-storeRebuildComplete(struct _store_rebuild_data *dc)
+storeRebuildComplete(StoreRebuildData *dc)
 {
     double dt;
     counts.objcount += dc->objcount;
@@ -294,7 +295,7 @@ struct InitStoreEntry : public unary_function<StoreMeta, void> {
 
 bool
 storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf,
-                      struct _store_rebuild_data &counts)
+                      StoreRebuildData &counts)
 {
     if (fd < 0)
         return false;
@@ -316,7 +317,7 @@ storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf,
 
 bool
 storeRebuildParseEntry(MemBuf &buf, StoreEntry &tmpe, cache_key *key,
-                       struct _store_rebuild_data &counts,
+                       StoreRebuildData &counts,
                        uint64_t expectedSize)
 {
     int swap_hdr_len = 0;
@@ -382,7 +383,7 @@ storeRebuildParseEntry(MemBuf &buf, StoreEntry &tmpe, cache_key *key,
 
 bool
 storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key,
-                      struct _store_rebuild_data &counts)
+                      StoreRebuildData &counts)
 {
     /* this needs to become
      * 1) unpack url
@@ -31,16 +31,29 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
+class StoreRebuildData {
+public:
+    int objcount;       /* # objects successfully reloaded */
+    int expcount;       /* # objects expired */
+    int scancount;      /* # entries scanned or read from state file */
+    int clashcount;     /* # swapfile clashes avoided */
+    int dupcount;       /* # duplicates purged */
+    int cancelcount;        /* # SWAP_LOG_DEL objects purged */
+    int invalid;        /* # bad lines */
+    int badflags;       /* # bad e->flags */
+    int bad_log_op;
+    int zero_object_sz;
+};
 
 extern void storeRebuildStart(void);
-extern void storeRebuildComplete(struct _store_rebuild_data *);
+extern void storeRebuildComplete(StoreRebuildData *);
 extern void storeRebuildProgress(int sd_index, int total, int sofar);
 
 /// loads entry from disk; fills supplied memory buffer on success
-extern bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, struct _store_rebuild_data &counts);
+extern bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, StoreRebuildData &counts);
 /// parses entry buffer and validates entry metadata; fills e on success
-extern bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, struct _store_rebuild_data &counts, uint64_t expectedSize);
+extern bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, StoreRebuildData &counts, uint64_t expectedSize);
 /// checks whether the loaded entry should be kept; updates counters
-extern bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, struct _store_rebuild_data &counts);
+extern bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, StoreRebuildData &counts);
 
 #endif /* SQUID_STORE_REBUILD_H_ */
@@ -39,6 +39,7 @@
 /* FIXME: Abstract the use of this more */
 #include "mem_node.h"
 #include "MemObject.h"
+#include "SquidConfig.h"
 #include "SwapDir.h"
 #include "StatCounters.h"
 #include "store_log.h"
@@ -29,45 +29,25 @@
 #ifndef SQUID_STRUCTS_H
 #define SQUID_STRUCTS_H
 
-#include "RefCount.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
-#include "err_type.h"
 #include "hash.h"
 #include "ip/Address.h"
 
 /* needed for the global config */
 #include "HttpHeader.h"
 #include "HttpHeaderTools.h"
 
-/* for ICP_END */
-#include "icp_opcode.h"
-
-#if USE_SSL
-#include <openssl/ssl.h>
-#endif
-
 #define PEER_MULTICAST_SIBLINGS 1
 
-struct acl_name_list {
-    char name[ACL_NAME_SZ];
-    acl_name_list *next;
-};
-
-struct acl_deny_info_list {
-    err_type err_page_id;
-    char *err_page_name;
-    acl_name_list *acl_list;
-    acl_deny_info_list *next;
-};
-
 class ACLChecklist;
 
 #if SQUID_SNMP
 
 #include "snmp_session.h"
-struct _snmp_request_t {
+class snmp_request_t {
+public:
     u_char *buf;
     u_char *outbuf;
     int len;
@@ -88,13 +68,6 @@ struct _snmp_request_t {
 
 class ACLList;
 
-struct acl_address {
-    acl_address *next;
-    ACLList *aclList;
-
-    Ip::Address addr;
-};
-
 struct acl_tos {
     acl_tos *next;
     ACLList *aclList;
@@ -113,18 +86,6 @@ struct acl_size_t {
     int64_t size;
 };
 
-struct ushortlist {
-    unsigned short i;
-    ushortlist *next;
-};
-
-struct relist {
-    int flags;
-    char *pattern;
-    regex_t regex;
-    relist *next;
-};
-
 #if USE_DELAY_POOLS
 #include "DelayConfig.h"
 #include "ClientDelayConfig.h"
@@ -142,533 +103,23 @@ class CpuAffinityMap;
 class RemovalPolicySettings;
 class external_acl;
 class Store;
+class CustomLog;
+class CacheMgrPasswd;
 namespace AnyP
 {
 struct PortCfg;
 }
 class SwapDir;
 
-/// Used for boolean enabled/disabled options with complex default logic.
-/// Allows Squid to compute the right default after configuration.
-/// Checks that not-yet-defined option values are not used.
-class YesNoNone
-{
-// TODO: generalize to non-boolean option types
+class close_handler {
 public:
-    YesNoNone(): option(0) {}
-
-    /// returns true iff enabled; asserts if the option has not been configured
-    operator void *() const; // TODO: use a fancy/safer version of the operator
-
-    /// enables or disables the option;
-    void configure(bool beSet);
-
-    /// whether the option was enabled or disabled, by user or Squid
-    bool configured() const { return option != 0; }
-
-private:
-    enum { optUnspecified = -1, optDisabled = 0, optEnabled = 1 };
-    int option; ///< configured value or zero
-};
-
-struct SquidConfig {
-
-    struct {
-        /* These should be for the Store::Root instance.
-        * this needs pluggable parsing to be done smoothly.
-        */
-        int highWaterMark;
-        int lowWaterMark;
-    } Swap;
-
-    YesNoNone memShared; ///< whether the memory cache is shared among workers
-    size_t memMaxSize;
-
-    struct {
-        int64_t min;
-        int pct;
-        int64_t max;
-    } quickAbort;
-    int64_t readAheadGap;
-    RemovalPolicySettings *replPolicy;
-    RemovalPolicySettings *memPolicy;
-#if USE_HTTP_VIOLATIONS
-    time_t negativeTtl;
-#endif
-    time_t maxStale;
-    time_t negativeDnsTtl;
-    time_t positiveDnsTtl;
-    time_t shutdownLifetime;
-    time_t backgroundPingRate;
-
-    struct {
-        time_t read;
-        time_t write;
-        time_t lifetime;
-        time_t connect;
-        time_t forward;
-        time_t peer_connect;
-        time_t request;
-        time_t clientIdlePconn;
-        time_t serverIdlePconn;
-        time_t siteSelect;
-        time_t deadPeer;
-        int icp_query;		/* msec */
-        int icp_query_max;	/* msec */
-        int icp_query_min;	/* msec */
-        int mcast_icp_query;	/* msec */
-
-#if !USE_DNSHELPER
-        time_msec_t idns_retransmit;
-        time_msec_t idns_query;
-#endif
-
-    } Timeout;
-    size_t maxRequestHeaderSize;
-    int64_t maxRequestBodySize;
-    int64_t maxChunkedRequestBodySize;
-    size_t maxRequestBufferSize;
-    size_t maxReplyHeaderSize;
-    acl_size_t *ReplyBodySize;
-
-    struct {
-        unsigned short icp;
-#if USE_HTCP
-
-        unsigned short htcp;
-#endif
-#if SQUID_SNMP
-
-        unsigned short snmp;
-#endif
-    } Port;
-
-    struct {
-        AnyP::PortCfg *http;
-#if USE_SSL
-        AnyP::PortCfg *https;
-#endif
-    } Sockaddr;
-#if SQUID_SNMP
-
-    struct {
-        char *configFile;
-        char *agentInfo;
-    } Snmp;
-#endif
-#if USE_WCCP
-
-    struct {
-        Ip::Address router;
-        Ip::Address address;
-        int version;
-    } Wccp;
-#endif
-#if USE_WCCPv2
-
-    struct {
-        Ip::Address_list *router;
-        Ip::Address address;
-        int forwarding_method;
-        int return_method;
-        int assignment_method;
-        int weight;
-        int rebuildwait;
-        void *info;
-    } Wccp2;
-#endif
-
-#if USE_ICMP
-    IcmpConfig pinger;
-#endif
-
-    char *as_whois_server;
-
-    struct {
-        char *store;
-        char *swap;
-        customlog *accesslogs;
-#if ICAP_CLIENT
-        customlog *icaplogs;
-#endif
-        int rotateNumber;
-    } Log;
-    char *adminEmail;
-    char *EmailFrom;
-    char *EmailProgram;
-    char *effectiveUser;
-    char *visible_appname_string;
-    char *effectiveGroup;
-
-    struct {
-#if USE_DNSHELPER
-        char *dnsserver;
-#endif
-
-        wordlist *redirect;
-#if USE_UNLINKD
-
-        char *unlinkd;
-#endif
-
-        char *diskd;
-#if USE_SSL
-
-        char *ssl_password;
-#endif
-
-    } Program;
-#if USE_DNSHELPER
-    HelperChildConfig dnsChildren;
-#endif
-
-    HelperChildConfig redirectChildren;
-    time_t authenticateGCInterval;
-    time_t authenticateTTL;
-    time_t authenticateIpTTL;
-
-    struct {
-        char *surrogate_id;
-    } Accel;
-    char *appendDomain;
-    size_t appendDomainLen;
-    char *pidFilename;
-    char *netdbFilename;
-    char *mimeTablePathname;
-    char *etcHostsPath;
-    char *visibleHostname;
-    char *uniqueHostname;
-    wordlist *hostnameAliases;
-    char *errHtmlText;
-
-    struct {
-        char *host;
-        char *file;
-        time_t period;
-        unsigned short port;
-    } Announce;
-
-    struct {
-
-        Ip::Address udp_incoming;
-        Ip::Address udp_outgoing;
-#if SQUID_SNMP
-        Ip::Address snmp_incoming;
-        Ip::Address snmp_outgoing;
-#endif
-        /* FIXME INET6 : this should really be a CIDR value */
-        Ip::Address client_netmask;
-    } Addrs;
-    size_t tcpRcvBufsz;
-    size_t udpMaxHitObjsz;
-    wordlist *hierarchy_stoplist;
-    wordlist *mcast_group_list;
-    wordlist *dns_nameservers;
-    peer *peers;
-    int npeers;
-
-    struct {
-        int size;
-        int low;
-        int high;
-    } ipcache;
-
-    struct {
-        int size;
-    } fqdncache;
-    int minDirectHops;
-    int minDirectRtt;
-    cachemgr_passwd *passwd_list;
-
-    struct {
-        int objectsPerBucket;
-        int64_t avgObjectSize;
-        int64_t maxObjectSize;
-        int64_t minObjectSize;
-        size_t maxInMemObjSize;
-    } Store;
-
-    struct {
-        int high;
-        int low;
-        time_t period;
-    } Netdb;
-
-    struct {
-        int log_udp;
-        int res_defnames;
-        int anonymizer;
-        int client_db;
-        int query_icmp;
-        int icp_hit_stale;
-        int buffered_logs;
-        int common_log;
-        int log_mime_hdrs;
-        int log_fqdn;
-        int announce;
-        int mem_pools;
-        int test_reachability;
-        int half_closed_clients;
-        int refresh_all_ims;
-#if USE_HTTP_VIOLATIONS
-
-        int reload_into_ims;
-#endif
-
-        int offline;
-        int redir_rewrites_host;
-        int prefer_direct;
-        int nonhierarchical_direct;
-        int strip_query_terms;
-        int redirector_bypass;
-        int ignore_unknown_nameservers;
-        int client_pconns;
-        int server_pconns;
-        int error_pconns;
-#if USE_CACHE_DIGESTS
-
-        int digest_generation;
-#endif
-
-        int ie_refresh;
-        int vary_ignore_expire;
-        int pipeline_prefetch;
-        int surrogate_is_remote;
-        int request_entities;
-        int detect_broken_server_pconns;
-        int balance_on_multiple_ip;
-        int relaxed_header_parser;
-        int check_hostnames;
-        int allow_underscore;
-        int via;
-        int emailErrData;
-        int httpd_suppress_version_string;
-        int global_internal_static;
-
-#if FOLLOW_X_FORWARDED_FOR
-        int acl_uses_indirect_client;
-        int delay_pool_uses_indirect_client;
-        int log_uses_indirect_client;
-#if LINUX_NETFILTER
-        int tproxy_uses_indirect_client;
-#endif
-#endif /* FOLLOW_X_FORWARDED_FOR */
-
-        int WIN32_IpAddrChangeMonitor;
-        int memory_cache_first;
-        int memory_cache_disk;
-        int hostStrictVerify;
-        int client_dst_passthru;
-    } onoff;
-
-    int forward_max_tries;
-    int connect_retries;
-
-    class ACL *aclList;
-
-    struct {
-        acl_access *http;
-        acl_access *adapted_http;
-        acl_access *icp;
-        acl_access *miss;
-        acl_access *NeverDirect;
-        acl_access *AlwaysDirect;
-        acl_access *ASlists;
-        acl_access *noCache;
-        acl_access *log;
-#if SQUID_SNMP
-
-        acl_access *snmp;
-#endif
-#if USE_HTTP_VIOLATIONS
-        acl_access *brokenPosts;
-#endif
-        acl_access *redirector;
-        acl_access *reply;
-        acl_address *outgoing_address;
-#if USE_HTCP
-
-        acl_access *htcp;
-        acl_access *htcp_clr;
-#endif
-
-#if USE_SSL
-        acl_access *ssl_bump;
-#endif
-#if FOLLOW_X_FORWARDED_FOR
-        acl_access *followXFF;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-
-#if ICAP_CLIENT
-        acl_access* icap;
-#endif
-    } accessList;
-    acl_deny_info_list *denyInfoList;
-
-    struct {
-        size_t list_width;
-        int list_wrap;
-        char *anon_user;
-        int passive;
-        int epsv_all;
-        int epsv;
-        int eprt;
-        int sanitycheck;
-        int telnet;
-    } Ftp;
-    refresh_t *Refresh;
-
-    struct _cacheSwap {
-        RefCount<SwapDir> *swapDirs;
-        int n_allocated;
-        int n_configured;
-        /// number of disk processes required to support all cache_dirs
-        int n_strands;
-    } cacheSwap;
-    /*
-     * I'm sick of having to keep doing this ..
-     */
-#define INDEXSD(i)   (Config.cacheSwap.swapDirs[(i)].getRaw())
-
-    struct {
-        char *directory;
-        int use_short_names;
-    } icons;
-    char *errorDirectory;
-#if USE_ERR_LOCALES
-    char *errorDefaultLanguage;
-    int errorLogMissingLanguages;
-#endif
-    char *errorStylesheet;
-
-    struct {
-        int onerror;
-    } retry;
-
-    struct {
-        int64_t limit;
-    } MemPools;
-#if USE_DELAY_POOLS
-
-    DelayConfig Delay;
-    ClientDelayConfig ClientDelay;
-#endif
-
-    struct {
-        struct {
-            int average;
-            int min_poll;
-        } dns, udp, tcp;
-    } comm_incoming;
-    int max_open_disk_fds;
-    int uri_whitespace;
-    acl_size_t *rangeOffsetLimit;
-#if MULTICAST_MISS_STREAM
-
-    struct {
-
-        Ip::Address addr;
-        int ttl;
-        unsigned short port;
-        char *encode_key;
-    } mcast_miss;
-#endif
-
-    /// request_header_access and request_header_replace
-    HeaderManglers *request_header_access;
-    /// reply_header_access and reply_header_replace
-    HeaderManglers *reply_header_access;
-    ///request_header_add access list
-    HeaderWithAclList *request_header_add;
-    char *coredump_dir;
-    char *chroot_dir;
-#if USE_CACHE_DIGESTS
-
-    struct {
-        int bits_per_entry;
-        time_t rebuild_period;
-        time_t rewrite_period;
-        size_t swapout_chunk_size;
-        int rebuild_chunk_percentage;
-    } digest;
-#endif
-#if USE_SSL
-
-    struct {
-        int unclean_shutdown;
-        char *ssl_engine;
-    } SSL;
-#endif
-
-    wordlist *ext_methods;
-
-    struct {
-        int high_rptm;
-        int high_pf;
-        size_t high_memory;
-    } warnings;
-    char *store_dir_select_algorithm;
-    int sleep_after_fork;	/* microseconds */
-    time_t minimum_expiry_time;	/* seconds */
-    external_acl *externalAclHelperList;
-
-#if USE_SSL
-
-    struct {
-        char *cert;
-        char *key;
-        int version;
-        char *options;
-        char *cipher;
-        char *cafile;
-        char *capath;
-        char *crlfile;
-        char *flags;
-        acl_access *cert_error;
-        SSL_CTX *sslContext;
-        sslproxy_cert_sign *cert_sign;
-        sslproxy_cert_adapt *cert_adapt;
-    } ssl_client;
-#endif
-
-    char *accept_filter;
-    int umask;
-    int max_filedescriptors;
-    int workers;
-    CpuAffinityMap *cpuAffinityMap;
-
-#if USE_LOADABLE_MODULES
-    wordlist *loadable_module_names;
-#endif
-
-    int client_ip_max_connections;
-
-    struct {
-        int v4_first;       ///< Place IPv4 first in the order of DNS results.
-        ssize_t packet_max; ///< maximum size EDNS advertised for DNS replies.
-    } dns;
-};
-
-SQUIDCEXTERN SquidConfig Config;
-
-struct SquidConfig2 {
-    struct {
-        int enable_purge;
-        int mangle_request_headers;
-    } onoff;
-    uid_t effectiveUserID;
-    gid_t effectiveGroupID;
-};
-
-SQUIDCEXTERN SquidConfig2 Config2;
-
-struct _close_handler {
     PF *handler;
     void *data;
     close_handler *next;
 };
 
-struct _dread_ctrl {
+class dread_ctrl {
+public:
     int fd;
     off_t offset;
     int req_len;
@@ -678,7 +129,8 @@ struct _dread_ctrl {
     void *client_data;
 };
 
-struct _dwrite_q {
+class dwrite_q {
+public:
     off_t file_offset;
     char *buf;
     size_t len;
@@ -695,37 +147,9 @@ struct _fde_disk {
     off_t offset;
 };
 
-/* per field statistics */
-
-class HttpHeaderFieldStat
-{
 
+class http_state_flags {
 public:
-    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0) {}
-
-    int aliveCount;		/* created but not destroyed (count) */
-    int seenCount;		/* #fields we've seen */
-    int parsCount;		/* #parsing attempts */
-    int errCount;		/* #pasring errors */
-    int repCount;		/* #repetitons */
-};
-
-/* compiled version of HttpHeaderFieldAttrs plus stats */
-#include "SquidString.h"
-
-class HttpHeaderFieldInfo
-{
-
-public:
-    HttpHeaderFieldInfo() : id (HDR_ACCEPT), type (ftInvalid) {}
-
-    http_hdr_type id;
-    String name;
-    field_type type;
-    HttpHeaderFieldStat stat;
-};
-
-struct _http_state_flags {
     unsigned int proxying:1;
     unsigned int keepalive:1;
     unsigned int only_if_cached:1;
@@ -743,194 +167,42 @@ struct _http_state_flags {
     unsigned int sentLastChunk:1; ///< do not try to write last-chunk again
 };
 
-struct _domain_ping {
+class domain_ping {
+public:
     char *domain;
     int do_ping;		/* boolean */
     domain_ping *next;
 };
 
-struct _domain_type {
+class domain_type {
+public:
     char *domain;
     peer_t type;
     domain_type *next;
 };
 
 class PeerDigest;
 
-struct peer {
-    u_int index;
-    char *name;
-    char *host;
-    peer_t type;
-
-    Ip::Address in_addr;
-
-    struct {
-        int pings_sent;
-        int pings_acked;
-        int fetches;
-        int rtt;
-        int ignored_replies;
-        int n_keepalives_sent;
-        int n_keepalives_recv;
-        time_t probe_start;
-        time_t last_query;
-        time_t last_reply;
-        time_t last_connect_failure;
-        time_t last_connect_probe;
-        int logged_state;	/* so we can print dead/revived msgs */
-        int conn_open;		/* current opened connections */
-    } stats;
-
-    struct {
-        int version;
-        int counts[ICP_END+1];
-        unsigned short port;
-    } icp;
-
-#if USE_HTCP
-    struct {
-        double version;
-        int counts[2];
-        unsigned short port;
-    } htcp;
-#endif
-
-    unsigned short http_port;
-    domain_ping *peer_domain;
-    domain_type *typelist;
-    acl_access *access;
-
-    struct {
-        unsigned int proxy_only:1;
-        unsigned int no_query:1;
-        unsigned int background_ping:1;
-        unsigned int no_digest:1;
-        unsigned int default_parent:1;
-        unsigned int roundrobin:1;
-        unsigned int weighted_roundrobin:1;
-        unsigned int mcast_responder:1;
-        unsigned int closest_only:1;
-#if USE_HTCP
-        unsigned int htcp:1;
-        unsigned int htcp_oldsquid:1;
-        unsigned int htcp_no_clr:1;
-        unsigned int htcp_no_purge_clr:1;
-        unsigned int htcp_only_clr:1;
-        unsigned int htcp_forward_clr:1;
-#endif
-        unsigned int no_netdb_exchange:1;
-#if USE_DELAY_POOLS
-        unsigned int no_delay:1;
-#endif
-        unsigned int allow_miss:1;
-        unsigned int carp:1;
-        struct {
-            unsigned int set:1; //If false, whole url is to be used. Overrides others
-            unsigned int scheme:1;
-            unsigned int host:1;
-            unsigned int port:1;
-            unsigned int path:1;
-            unsigned int params:1;
-        } carp_key;
-#if USE_AUTH
-        unsigned int userhash:1;
-#endif
-        unsigned int sourcehash:1;
-        unsigned int originserver:1;
-        unsigned int no_tproxy:1;
-#if PEER_MULTICAST_SIBLINGS
-        unsigned int mcast_siblings:1;
-#endif
-    } options;
-
-    int weight;
-    int basetime;
-
-    struct {
-        double avg_n_members;
-        int n_times_counted;
-        int n_replies_expected;
-        int ttl;
-        int id;
-
-        struct {
-            unsigned int count_event_pending:1;
-            unsigned int counting:1;
-        } flags;
-    } mcast;
-#if USE_CACHE_DIGESTS
-
-    PeerDigest *digest;
-    char *digest_url;
-#endif
-
-    int tcp_up;			/* 0 if a connect() fails */
-
-    Ip::Address addresses[10];
-    int n_addresses;
-    int rr_count;
-    peer *next;
-    int testing_now;
-
-    struct {
-        unsigned int hash;
-        double load_multiplier;
-        double load_factor;	/* normalized weight value */
-    } carp;
-#if USE_AUTH
-    struct {
-        unsigned int hash;
-        double load_multiplier;
-        double load_factor;	/* normalized weight value */
-    } userhash;
-#endif
-    struct {
-        unsigned int hash;
-        double load_multiplier;
-        double load_factor;	/* normalized weight value */
-    } sourcehash;
-
-    char *login;		/* Proxy authorization */
-    time_t connect_timeout;
-    int connect_fail_limit;
-    int max_conn;
-    char *domain;		/* Forced domain */
-#if USE_SSL
-
-    int use_ssl;
-    char *sslcert;
-    char *sslkey;
-    int sslversion;
-    char *ssloptions;
-    char *sslcipher;
-    char *sslcafile;
-    char *sslcapath;
-    char *sslcrlfile;
-    char *sslflags;
-    char *ssldomain;
-    SSL_CTX *sslContext;
-    SSL_SESSION *sslSession;
-#endif
 
-    int front_end_https;
-    int connection_auth;
-};
+class netdbEntry;
 
-struct _net_db_name {
+class net_db_name {
+public:
     hash_link hash;		/* must be first */
     net_db_name *next;
     netdbEntry *net_db_entry;
 };
 
-struct _net_db_peer {
+class net_db_peer {
+public:
     const char *peername;
     double hops;
     double rtt;
     time_t expires;
 };
 
-struct _netdbEntry {
+class netdbEntry {
+public:
     hash_link hash;		/* must be first */
     char network[MAX_IPSTRLEN];
     int pings_sent;
@@ -946,9 +218,11 @@ struct _netdbEntry {
     int n_peers;
 };
 
-struct _iostats {
+class iostats {
+public:
+    static const int histSize=16;
 
-    enum { histSize = 16 };
+//    enum { histSize = 16 };
 
     struct {
         int reads;
@@ -961,131 +235,6 @@ struct _iostats {
     Http, Ftp, Gopher;
 };
 
-struct request_flags {
-    request_flags(): range(0),nocache(0),ims(0),auth(0),cachable(0),hierarchical(0),loopdetect(0),proxy_keepalive(0),proxying(0),refresh(0),redirected(0),need_validation(0),fail_on_validation_err(0),stale_if_hit(0),accelerated(0),ignore_cc(0),intercepted(0),hostVerified(0),spoof_client_ip(0),internal(0),internalclient(0),must_keepalive(0),pinned(0),canRePin(0),chunked_reply(0),stream_error(0),sslPeek(0),sslBumped(0),destinationIPLookedUp_(0) {
-#if USE_HTTP_VIOLATIONS
-        nocache_hack = 0;
-#endif
-#if FOLLOW_X_FORWARDED_FOR
-        done_follow_x_forwarded_for = 0;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-    }
-
-    unsigned int range:1;
-    unsigned int nocache:1;            ///< whether the response to this request may be READ from cache
-    unsigned int ims:1;
-    unsigned int auth:1;
-    unsigned int cachable:1;           ///< whether the response to thie request may be stored in the cache
-    unsigned int hierarchical:1;
-    unsigned int loopdetect:1;
-    unsigned int proxy_keepalive:1;
-unsigned int proxying:
-    1;	/* this should be killed, also in httpstateflags */
-    unsigned int refresh:1;
-    unsigned int redirected:1;
-    unsigned int need_validation:1;
-    unsigned int fail_on_validation_err:1; ///< whether we should fail if validation fails
-    unsigned int stale_if_hit:1; ///< reply is stale if it is a hit
-#if USE_HTTP_VIOLATIONS
-    unsigned int nocache_hack:1;	/* for changing/ignoring no-cache requests */
-#endif
-    unsigned int accelerated:1;
-    unsigned int ignore_cc:1;
-    unsigned int intercepted:1;        ///< intercepted request
-    unsigned int hostVerified:1;       ///< whether the Host: header passed verification
-    unsigned int spoof_client_ip:1;  /**< spoof client ip if possible */
-    unsigned int internal:1;
-    unsigned int internalclient:1;
-    unsigned int must_keepalive:1;
-    unsigned int connection_auth:1; /** Request wants connection oriented auth */
-    unsigned int connection_auth_disabled:1; /** Connection oriented auth can not be supported */
-    unsigned int connection_proxy_auth:1; /** Request wants connection oriented auth */
-    unsigned int pinned:1;      /* Request sent on a pinned connection */
-    unsigned int canRePin:1; ///< OK to reopen a failed pinned connection
-    unsigned int auth_sent:1;   /* Authentication forwarded */
-    unsigned int no_direct:1;	/* Deny direct forwarding unless overriden by always_direct. Used in accelerator mode */
-    unsigned int chunked_reply:1; /**< Reply with chunked transfer encoding */
-    unsigned int stream_error:1; /**< Whether stream error has occured */
-    unsigned int sslPeek:1; ///< internal ssl-bump request to get server cert
-    unsigned int sslBumped:1; /**< ssl-bumped request*/
-
-    // When adding new flags, please update cloneAdaptationImmune() as needed.
-
-    bool resetTCP() const;
-    void setResetTCP();
-    void clearResetTCP();
-    void destinationIPLookupCompleted();
-    bool destinationIPLookedUp() const;
-
-    // returns a partial copy of the flags that includes only those flags
-    // that are safe for a related (e.g., ICAP-adapted) request to inherit
-    request_flags cloneAdaptationImmune() const;
-
-#if FOLLOW_X_FORWARDED_FOR
-    unsigned int done_follow_x_forwarded_for;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-private:
-
-    unsigned int reset_tcp:1;
-    unsigned int destinationIPLookedUp_:1;
-};
-
-struct _cachemgr_passwd {
-    char *passwd;
-    wordlist *actions;
-    cachemgr_passwd *next;
-};
-
-struct _refresh_t {
-    const char *pattern;
-    regex_t compiled_pattern;
-    time_t min;
-    double pct;
-    time_t max;
-    refresh_t *next;
-
-    struct {
-        unsigned int icase:1;
-        unsigned int refresh_ims:1;
-        unsigned int store_stale:1;
-#if USE_HTTP_VIOLATIONS
-        unsigned int override_expire:1;
-        unsigned int override_lastmod:1;
-        unsigned int reload_into_ims:1;
-        unsigned int ignore_reload:1;
-        unsigned int ignore_no_cache:1;
-        unsigned int ignore_no_store:1;
-        unsigned int ignore_must_revalidate:1;
-        unsigned int ignore_private:1;
-        unsigned int ignore_auth:1;
-#endif
-    } flags;
-    int max_stale;
-};
-
-struct _CacheDigest {
-    /* public, read-only */
-    char *mask;			/* bit mask */
-    int mask_size;		/* mask size in bytes */
-    int capacity;		/* expected maximum for .count, not a hard limit */
-    int bits_per_entry;		/* number of bits allocated for each entry from capacity */
-    int count;			/* number of digested entries */
-    int del_count;		/* number of deletions performed so far */
-};
-
-struct _store_rebuild_data {
-    int objcount;		/* # objects successfully reloaded */
-    int expcount;		/* # objects expired */
-    int scancount;		/* # entries scanned or read from state file */
-    int clashcount;		/* # swapfile clashes avoided */
-    int dupcount;		/* # duplicates purged */
-    int cancelcount;		/* # SWAP_LOG_DEL objects purged */
-    int invalid;		/* # bad lines */
-    int badflags;		/* # bad e->flags */
-    int bad_log_op;
-    int zero_object_sz;
-};
-
 #if USE_SSL
 struct _sslproxy_cert_sign {
     int alg;
@@ -1101,17 +250,4 @@ struct _sslproxy_cert_adapt {
 };
 #endif
 
-class Logfile;
-
-#include "format/Format.h"
-#include "log/Formats.h"
-struct _customlog {
-    char *filename;
-    ACLList *aclList;
-    Format::Format *logFormat;
-    Logfile *logfile;
-    customlog *next;
-    Log::Format::log_type type;
-};
-
 #endif /* SQUID_STRUCTS_H */
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "ConfigParser.h"
 #include "wordlist.h"
+#include "YesNoNone.h"
 
 #define STUB_API "cache_cf.cc"
 #include "tests/STUB.h"
@@ -17,8 +17,8 @@ Comm::Connection::Connection() STUB
 Comm::Connection::~Connection() STUB
 Comm::ConnectionPointer Comm::Connection::copyDetails() const STUB_RETVAL(NULL)
 void Comm::Connection::close() STUB
-peer * Comm::Connection::getPeer() const STUB_RETVAL(NULL)
-void Comm::Connection::setPeer(peer * p) STUB
+CachePeer * Comm::Connection::getPeer() const STUB_RETVAL(NULL)
+void Comm::Connection::setPeer(CachePeer * p) STUB
 
 #include "comm/ConnOpener.h"
 CBDATA_NAMESPACED_CLASS_INIT(Comm, ConnOpener);
@@ -22,10 +22,10 @@ void netdbDump(StoreEntry *) STUB
 void netdbFreeMemory(void) STUB
 int netdbHostHops(const char *host) STUB_RETVAL(-1)
 int netdbHostRtt(const char *host) STUB_RETVAL(-1)
-void netdbUpdatePeer(HttpRequest *, peer * e, int rtt, int hops) STUB
+void netdbUpdatePeer(HttpRequest *, CachePeer * e, int rtt, int hops) STUB
 void netdbDeleteAddrNetwork(Ip::Address &addr) STUB
 void netdbBinaryExchange(StoreEntry *) STUB
 void netdbExchangeStart(void *) STUB
-void netdbExchangeUpdatePeer(Ip::Address &, peer *, double, double) STUB
-peer *netdbClosestParent(HttpRequest *) STUB_RETVAL(NULL)
+void netdbExchangeUpdatePeer(Ip::Address &, CachePeer *, double, double) STUB
+CachePeer *netdbClosestParent(HttpRequest *) STUB_RETVAL(NULL)
 void netdbHostData(const char *host, int *samp, int *rtt, int *hops) STUB
@@ -1,4 +1,5 @@
 #include "squid.h"
+#include "RequestFlags.h"
 
 #define STUB_API "store.cc"
 #include "tests/STUB.h"
@@ -115,7 +116,7 @@ void storeEntryReplaceObject(StoreEntry *, HttpReply *) STUB
 SQUIDCEXTERN StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method) STUB_RETVAL(NULL)
 SQUIDCEXTERN StoreEntry *storeGetPublicByRequest(HttpRequest * request) STUB_RETVAL(NULL)
 SQUIDCEXTERN StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method) STUB_RETVAL(NULL)
-SQUIDCEXTERN StoreEntry *storeCreateEntry(const char *, const char *, request_flags, const HttpRequestMethod&) STUB_RETVAL(NULL)
+extern StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&) STUB_RETVAL(NULL)
 SQUIDCEXTERN void storeInit(void) STUB
 SQUIDCEXTERN void storeConfigure(void) STUB
 SQUIDCEXTERN void storeFreeMemory(void) STUB
@@ -32,15 +32,16 @@
 
 #include "squid.h"
 #include "MemBuf.h"
+#include "store_rebuild.h"
 
 #define STUB_API "stub_store_rebuild.cc"
 #include "tests/STUB.h"
 
 void storeRebuildProgress(int sd_index, int total, int sofar) STUB
-void storeRebuildComplete(struct _store_rebuild_data *dc) STUB_NOP
-bool storeRebuildLoadEntry(int, int, MemBuf&, _store_rebuild_data&)
+void storeRebuildComplete(StoreRebuildData *dc) STUB_NOP
+bool storeRebuildLoadEntry(int, int, MemBuf&, StoreRebuildData&)
 {
     return false;
 }
-bool storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key, struct _store_rebuild_data &counts) STUB_RETVAL(false)
-bool storeRebuildParseEntry(MemBuf &, StoreEntry &, cache_key *, struct _store_rebuild_data &, uint64_t) STUB_RETVAL(false)
+bool storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key, StoreRebuildData &counts) STUB_RETVAL(false)
+bool storeRebuildParseEntry(MemBuf &, StoreEntry &, cache_key *, StoreRebuildData &, uint64_t) STUB_RETVAL(false)
@@ -9,8 +9,10 @@
 #include "MemObject.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
+#include "RequestFlags.h"
 #include "StoreFileSystem.h"
 #include "testStoreSupport.h"
+#include "SquidConfig.h"
 
 #if HAVE_STDEXCEPT
 #include <stdexcept>
@@ -187,8 +189,8 @@ testCoss::testCossSearch()
     /* add an entry */
     {
         /* Create "vary" base object */
-        request_flags flags;
-        flags.cachable = 1;
+        RequestFlags flags;
+        flags.setCachable();
         StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
         HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
         rep->setHeaders(HTTP_OK, "dummy test object", "x-squid-internal/test", -1, -1, squid_curtime + 100000);
@@ -8,6 +8,7 @@
 #include "Mem.h"
 #include "MemBuf.h"
 #include "structs.h"
+#include "SquidConfig.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpParser );
 
@@ -7,10 +7,11 @@
 #include "HttpReply.h"
 #include "Mem.h"
 #include "mime_header.h"
+#include "SquidConfig.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpReply );
 
-struct SquidConfig Config;
+class SquidConfig Config;
 
 /* stub functions to link successfully */
 
@@ -9,6 +9,8 @@
 #include "MemObject.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "StoreFileSystem.h"
 #include "testStoreSupport.h"
 
@@ -158,8 +160,8 @@ testNull::testNullSearch()
     /* add an entry */
     {
         /* Create "vary" base object */
-        request_flags flags;
-        flags.cachable = 1;
+        RequestFlags flags;
+        flags.setCachable();
         StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
         /* We are allowed to do this typecast */
         HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
@@ -8,6 +8,8 @@
 #include "HttpReply.h"
 #include "Mem.h"
 #include "MemObject.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreFileSystem.h"
 #include "StoreSearch.h"
@@ -162,8 +164,8 @@ testRock::storeInit()
 StoreEntry *
 testRock::createEntry(const int i)
 {
-    request_flags flags;
-    flags.cachable = 1;
+    RequestFlags flags;
+    flags.setCachable();
     char url[64];
     snprintf(url, sizeof(url), "dummy url %i", i);
     url[sizeof(url) - 1] = '\0';
@@ -6,6 +6,7 @@
 #include "SwapDir.h"
 #include "TestSwapDir.h"
 #include "Mem.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StoreSearch.h"
 
@@ -8,6 +8,7 @@
 #include "StoreHashIndex.h"
 #include "Mem.h"
 #include "StoreSearch.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testStoreHashIndex );
@@ -8,6 +8,8 @@
 #include "HttpReply.h"
 #include "Mem.h"
 #include "MemObject.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "SwapDir.h"
 #include "testStoreSupport.h"
@@ -139,8 +141,8 @@ testUfs::testUfsSearch()
     /* add an entry */
     {
         /* Create "vary" base object */
-        request_flags flags;
-        flags.cachable = 1;
+        RequestFlags flags;
+        flags.setCachable();
         StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
         HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
         rep->setHeaders(HTTP_OK, "dummy test object", "x-squid-internal/test", -1, -1, squid_curtime + 100000);
@@ -42,6 +42,7 @@
 #include "ip/QosConfig.h"
 #include "MemBuf.h"
 #include "anyp/PortCfg.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "ipc/Kids.h"
@@ -32,23 +32,24 @@
  */
 
 #include "squid.h"
-#include "errorpage.h"
-#include "HttpRequest.h"
-#include "fde.h"
+#include "acl/FilledChecklist.h"
 #include "Array.h"
+#include "CachePeer.h"
+#include "client_side_request.h"
+#include "client_side.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "comm/Write.h"
-#include "client_side_request.h"
-#include "acl/FilledChecklist.h"
-#include "client_side.h"
-#include "MemBuf.h"
+#include "errorpage.h"
+#include "fde.h"
 #include "http.h"
+#include "HttpRequest.h"
+#include "MemBuf.h"
 #include "PeerSelectState.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
 #include "tools.h"
-
 #if USE_DELAY_POOLS
 #include "DelayId.h"
 #endif
@@ -530,7 +531,7 @@ tunnelConnected(const Comm::ConnectionPointer &server, void *data)
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << server << ", tunnelState=" << tunnelState);
 
-    if (tunnelState->request && (tunnelState->request->flags.spoof_client_ip || tunnelState->request->flags.intercepted))
+    if (tunnelState->request && (tunnelState->request->flags.spoofClientIp() || tunnelState->request->flags.intercepted()))
         tunnelStartShoveling(tunnelState); // ssl-bumped connection, be quiet
     else {
         AsyncCall::Pointer call = commCbCall(5,5, "tunnelConnectedWriteDone",
@@ -604,13 +605,16 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
     debugs(26, 4, HERE << "determine post-connect handling pathway.");
     if (conn->getPeer()) {
         tunnelState->request->peer_login = conn->getPeer()->login;
-        tunnelState->request->flags.proxying = (conn->getPeer()->options.originserver?0:1);
+        if (conn->getPeer()->options.originserver)
+            tunnelState->request->flags.setProxying();
+        else
+            tunnelState->request->flags.clearProxying();
     } else {
         tunnelState->request->peer_login = NULL;
-        tunnelState->request->flags.proxying = 0;
+        tunnelState->request->flags.clearProxying();
     }
 
-    if (tunnelState->request->flags.proxying)
+    if (tunnelState->request->flags.proxying())
         tunnelRelayConnectRequest(conn, tunnelState);
     else {
         tunnelConnected(conn, tunnelState);
@@ -694,7 +698,7 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     http_state_flags flags;
     debugs(26, 3, HERE << srv << ", tunnelState=" << tunnelState);
     memset(&flags, '\0', sizeof(flags));
-    flags.proxying = tunnelState->request->flags.proxying;
+    flags.proxying = tunnelState->request->flags.proxying();
     MemBuf mb;
     mb.init();
     mb.Printf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
@@ -45,48 +45,8 @@ typedef struct {
     size_t kb;
 } kb_t;
 
-typedef struct _close_handler close_handler;
-
-typedef struct _dread_ctrl dread_ctrl;
-
-typedef struct _dwrite_q dwrite_q;
-
-typedef struct _HttpHeaderFieldAttrs HttpHeaderFieldAttrs;
-
-typedef struct _domain_ping domain_ping;
-
-typedef struct _domain_type domain_type;
-
-typedef struct _DigestFetchState DigestFetchState;
-
-typedef struct _net_db_name net_db_name;
-
-typedef struct _net_db_peer net_db_peer;
-
-typedef struct _netdbEntry netdbEntry;
-
-typedef struct _icp_common_t icp_common_t;
-
-typedef struct _iostats iostats;
-
-typedef struct _http_state_flags http_state_flags;
-
-typedef struct _header_mangler header_mangler;
-
-typedef struct _cachemgr_passwd cachemgr_passwd;
-
-typedef struct _refresh_t refresh_t;
-
 typedef struct _CommWriteStateData CommWriteStateData;
 
-typedef struct _storeSwapLogData storeSwapLogData;
-
-typedef struct _CacheDigest CacheDigest;
-
-typedef struct _Version Version;
-
-typedef struct _customlog customlog;
-
 #if USE_SSL
 typedef struct _sslproxy_cert_sign sslproxy_cert_sign;
 
@@ -97,8 +57,6 @@ typedef struct _sslproxy_cert_adapt sslproxy_cert_adapt;
 #include "snmp_vars.h"
 #include "cache_snmp.h"
 typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
-
-typedef struct _snmp_request_t snmp_request_t;
 #endif
 
 typedef void FREE(void *);
@@ -120,7 +78,8 @@ typedef void FQDNH(const char *, const DnsLookupDetails &details, void *);
 typedef void IDCB(const char *ident, void *data);
 
 #include "anyp/ProtocolType.h"
-typedef void IRCB(struct peer *, peer_t, AnyP::ProtocolType, void *, void *data);
+class CachePeer;
+typedef void IRCB(CachePeer *, peer_t, AnyP::ProtocolType, void *, void *data);
 
 typedef void RH(void *data, char *);
 /* in wordlist.h */
@@ -35,6 +35,7 @@
 #include "globals.h"
 #include "HttpRequest.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "URL.h"
 #include "URLScheme.h"
@@ -40,6 +40,7 @@
 #include "icmp/net_db.h"
 #include "MemBuf.h"
 #include "mime_header.h"
+#include "RequestFlags.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -256,7 +257,7 @@ UrnState::created(StoreEntry *newEntry)
     urlres_e = newEntry;
 
     if (urlres_e->isNull()) {
-        urlres_e = storeCreateEntry(urlres, urlres, request_flags(), METHOD_GET);
+        urlres_e = storeCreateEntry(urlres, urlres, RequestFlags(), METHOD_GET);
         sc = storeClientListAdd(urlres_e, this);
         FwdState::fwdStart(Comm::ConnectionPointer(), urlres_e, urlres_r);
     } else {
@@ -37,6 +37,7 @@
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "event.h"
+#include "SquidConfig.h"
 #include "structs.h"
 
 #define WCCP_PORT 2048
@@ -39,6 +39,7 @@
 #include "HttpRequest.h"
 #include "HttpRequest.h"
 #include "forward.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
 #include "Store.h"
 #include "tools.h"