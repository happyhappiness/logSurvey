@@ -0,0 +1,16 @@
+Special thanks go to people who have volunteered their time, effort, 
+and ideas to make this software available.
+
+	Henrik Nordstrom <henrik.nordstrom@ida.his.se>
+	Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
+	Edward Moy <moy@parc.xerox.com>
+	Jean-Francois Micouleau <Jean-Francois.Micouleau@utc.fr>
+	Wojtek Sylwestrzak <W.Sylwestrzak@icm.edu.pl>
+
+
+Development of this caching software is funded by the National Science
+Foundation.  Paid staff members on the caching project are:
+
+	Duane Wessels <wessels@nlanr.net>
+	K Claffy <kc@nlanr.net>
+	Hans-Werner Braun <hwb@nlanr.net>
@@ -1,107 +1,122 @@
-Changes from version Harvest cached-1.4.pl3
+Changes to squid-1.0.beta1 (Apr 19, 1996) from Harvest cached-1.4.pl3:
 
-	- Added squid_error_*() functions for error handling instead
-	  of using CACHED_RETRIEVE_ERROR_MSG everywhere.
-	- Fixed discrepancy with setting "fd_note" for dnsservers.
-	- Fixed bug where cache process would "spin" on large objects
-	  being deferred.
 	- Added a "server mode" to ftpget.  Now the (much smaller)
 	  ftpget process forks for each FTP request.
-	- Removed the command line -d (debug) option.
-
-	# config file changes
+	- Added support for If-Modified-Since GET requests.
+	- Added support for SSL and https objects.
+	- Added background processing for rebuilding the disk store
+	  while serving requests.  Cache can now serve requests immediately.
+	- Added a 'reconfigure' feature activated by SIGHUP.  The config
+	  file is re-read and most changes will take effect.
+	- Added an internal flag for using private keys with ICP queries
+	  to neighbors.  If any neighbor returns a reqnum field of zero,
+	  then disable using private keys.  But still use private
+	  keys for things with bypass the ICP query step (such as POST
+	  and IMS-GET).
+	- Added a function to verify content-lengths.  Objects with
+	  mismatched (but non-zero) content lenghts will be ejected.
+	- Added clean shutdown mode.  On SIGTERM the incoming HTTP socket
+	  is closed.  Active clients are given a lifetime of 30 seconds
+	  (configurable).  Process exits when all sockets are closed.
+	- Added support for large POST objects.
+	- Added "store.log" which logs RELEASE/SWAPIN/SWAPOUT events.
+	- Added announce feature to squid; no longer external program.
+	  If enabled, a running cache will announce itself every 24 hrs.
+	- Added support for FTP URLs with non-default ports.
+	- Added new Access Control List scheme.
+	- Added Forwarded: header to proxy HTTP requests (HTTP/1.1 feature).
+	- Added weights neighbors.
+	- Added urlParse() which strips off default ports and 
+	  makes hostnames all lowercase.
 	- Added (section,level) debugging and 'debug_options' config line.
 	- Added 'pid_filename' to configuration file.
-	- Added 'visible_hostname' config option.
-
+	- Added 'visible_hostname' to configuration file.
+	- added 'ftp_user' to configuration file.
+	- added 'dns_positive_ttl' to configuration file.
+	- added 'dns_negative_ttl' to configuration file.
+	- Added 'shutdown_lifetime' to configuration file.
+	- Fixed bug where cache process would "spin" on large objects
+	  being deferred.
+	- Fixed byte order conversion bug on setting echo port.
 	- Changed meaning of command line -b (buffered logs) option.
 	  Now the default behaviour is unbuffered logs, use -b to make
 	  them buffered.
-	- Fixed byte order conversion bug on setting echo port.
-	- Removed all code and references to binary port.
 	- Changed WAIS code to always be fully compiled in.
-	- Added the notion of private and public keys.  Requests
-	  are now private until the reply headers have been read.
-	- Added support for If-Modified-Since GET requests.
-	- Added urlParse() which strips off default ports and 
-	  makes hostnames all lowercase.
-
-	- Fixed logging:  Now logging to "access.log" occurs when the
-	  client data structure gets destroyed. This should mean that
-	  every client connection results in a log entry. The
-	  ``TCP_DONE'' tag is no longer used. Instead ``TCP_MISS'' is
-	  logged with a valid size. ``TCP_MISS_TTL'' has been changed
-	  to ``TCP_EXPIRED.'' Because logging occurs when the client
-	  connection is closed all connections should have a valid
-	  size. Note we're only logging the client side. It might be
-	  useful to also log the server side to get really accurate
-	  numbers for the traffic comming into and out of the cache.
+	- Changed the storage manager to use the notion of private and
+	  public keys.  Requests are now private until the reply headers
+	  have been read.
+	- Changed access logging significantly.  Entries to "access.log"
+	  are written when the client connection closes.  Every connection
+	  is logged exactly once, always with a valid size.
 	- Changed access log format (non-common) to include request
 	  method and sub-second timestamps.
-	- removed special case for ECONNRESET (and warning message)
-	- Significant change to storage manager.  Now only add objects
-	  to the hash table if they are public.  This means some 
-	  StoreEntry's will be around with null keys.
-	- Had to add a flag for using private keys with ICP queries to
-	  neighbors.  If any neighbor returns a reqnum field of zero,
-	  then disable using private keys.  But still use private
-	  keys for things with bypass the ICP query step (such as
-	  POST and IMS-GET).
-	- eliminated dual logging to stderr/debug_log
-	- added 'ftp_user' to config
-	- added improved IP ACL routines; now handles netmasks.
-	- Added storeEntryValidLength().  Objects with invalid 
-	  content lengths will be ejected.
-	- Added clean shutdown mode.  On SIGTERM, close incoming and 
-	  dnsserver sockets.  When no sockets left in select loop
-	  return and exit.
-	- Added support for shttp and CONNECT urls.
-	- Added support for large POST objects.
-	- Started arranging for HUP to re-read config file.
-	- Created struct _http_reply to hold reply fields.
-	  Elmininates need for storeMatchMime() in ttl.c.
-	- fixed use of storeSetPublicKey() in ftp/gopher/wais.  Now
-	  call at end of *SendRequest().
-	- Fixed converting gopher to HTML bug, removed html_request
-	  field of gopherData;
-	- Open server sockets _after_ storeRebuild() so many incoming
-	  connections don't stack up on the listen queue.
-	- Created "store.log" which logs RELEASE/SWAPIN/SWAPOUT events.
-	- Added announce to squid; no longer external program.
-	- Added ftpProcessReplyHeader() (a twin of the one in http.c).
-	- Fixed bad free() in ipcacheShtudownServers()
-	- Cleaned up FTP url parsing; support port.
-	- SIGHUP reconfigures the cache
-	- SIGUSR1 rotates logfiles.
-	- New ACLs
-	- added dns_positive_ttl
-	- Added Forwarded: header to proxy HTTP requests
-	- Fixed reqnum bug (was using ntohs instead of ntohl).
-	- Fixed double free() bug caused by setting flag=0 in
-	  storeAddFromDisk().
-	- Fixed memory leaks.
-	- Check specifically for tm_gmtoff and set HAVE_TM_GMTOFF
-	- Fixed memory problem for colon but no port ("http://foo.com:/")
-	- Added support for weighted neighbors.
-	- fixed SSL/CONNECT
-	- Added background processing for rebuilding store
-	- Removed check for "\r\n" in icpRead, use 'immed' flag instead
-	- Invented request_t struct and urlParse to avoid sscanf'ing
-	  the URL string too often.
-
-alpha19
-	- Fixed problem with free()'ing config_file.
-	- use negative TTL value as UDP_HIT threshold so we never return
-	  HIT on neg-cache objects
-	- Fixed swaplog lock bug
-	- change ftpget to use select(2) on I/O for timeouts.  ftpget
+	- Changed handing of ECONNRESET (connection reset) errors.
+	  Now treated like any other read error.
+	- Changed 'rotate logs' to be activated by SIGUSR1.
+	- Changed configure script to look specifically for tm_gmtoff
+	  and set HAVE_TM_GMTOFF.
+	- Changed configure script to look specifically extended mallinfo
+	  structure and set HAVE_EXT_MALLINFO
+	- Changed ICP reply code to use negative TTL value as UDP_HIT
+	  threshold so we never return a HIT on neg-cached objects.
+	- Changed ftpget to use select(2) on I/O for timeouts.  ftpget
 	  now exits immediately if stdin goes away.
-	- note # connections in shutdown message
-	- Added close handler to be called from comm_close().  Now
-	  all the *CloseAndFree() calls have been changed back to
-	  comm_close() which calls *StateFree, etc.
-	- Fixed comm_select to actually get to select() during background
-	  processing.
-	- Fixed rebuild bug which unlinked swap files of already-in-use
-	  file numbers.
-	- Added configurable shutdown lifetime (30 sec default)
+	- Changed handling of '-z' option.  Now only execute 'rm -rf ...' if
+	  -U option also given.
+	- Removed the command line -d (debug) option.  Use 'debug_options'
+	  in config file.
+	- Removed all code and references to binary port.
+	- Removed dual logging to stderr/cache.log.
+	- Removed old IP access controls ('proxy_allow', etc.)
+
+Changes to 1.0.beta2:
+
+	- Fixed /bin/csh "$#argv" leftover in RunCache.
+	- Fixed ACL day-of-week bitmask bug.
+	- Fixed missing checks for WAIS in some places.
+	- Fixed chdir(swappath(0)) bug; do chdir() after storeInit().
+	- Changed enumerated structure members to be defined outside
+	  of the structure itself (for AIX).
+	- Changed ftpget to fork before reading the request and make
+	  sure the entire request is read.
+
+Changes to 1.0.beta3:
+
+	- Added ftpget '-C minport:maxport' option
+	- Fixed PROTO_MAX fencepost bug in stat_init().
+	- Fixed Fixed CheckQuickAbort() coredump.
+	- Fixed disabling store.log and hierarchy.log when set to "none"
+	- Fixed numerous problems related to setuid().
+	- Fixed 'check_cache.pl' to use new swaplog format (without "FILE").
+	- Fixed ACL coredumps when checking NULL words.
+	- Changed pid_filename to be written and unlinked as root.
+	- Added "-i seconds" option to 'client' for testing IMS GET.
+	- Fixed a bug where an IMS request caused the valid object to
+	  get ejected from the cache.
+	- Fixed continual DEAD_PARENT/REVIVE bug
+	- Fixed ERR_INVALID_URL bug for URLs with a password field.
+	- Added to Release-Notes info about converting 'cache/log' and
+	  difference between stoplists and ttl_pattern.
+
+Changes to squid-1.0.beta4:
+
+	- Added a handler to restart the ftpget server.
+	- Fixed access checks for ICP by parsing the requested URL.
+	- Added "magic marker" to ftpget-generated errors so they can
+	  be negative-cached.
+	- Added a small run-time check to configure to see if signal
+	  handlers should be restarted after invocation (ala SYSV).
+	- Determine Maximum filedescriptors in configure and change
+	  FD_SETSIZE if needed.
+	- Changed read stall algorithm for HTTP.  No don't wait until
+	  the object is in DELETE_BEHIND mode to stall the server read
+	  and wait for the client to catch up.  Also changed from 4k to
+	  16k read buffer.
+	- Fixed HTTP request parsing to check for blank line at the
+	  end of all requests.  Symptoms were "connection reset"
+	  messages.
+
+Changes to squid-1.0.beta5:
+
+	- Fixed cachemgr to send 'HTTP/1.0' on request so it works
+	  with beta4 fixes to icp.c.
@@ -1,25 +1,10 @@
-This is a special distribution that contains only the Harvest object
-cache.  The cache is an element of the Harvest Information Discovery and
-Access System, offering high performance proxy caching for Mosaic,
-Netscape, Lynx, and other World Wide Web clients.  It supports URLs via
-HTTP, FTP, and Gopher.
 
-The Harvest cache outperforms other popular Internet caches (such as the
-CERN cache) by a factor of 10-100, because the Harvest cache never
-forks, is implemented with non-blocking I/O, keeps meta data and
-especially hot objects cached in RAM, caches DNS lookups, supports
-non-blocking DNS lookups, and implements negative caching both of
-objects and of DNS lookups.  A technical paper discussing the Harvest
-cache and providing performance comparisions is available from
-ftp://ftp.cs.colorado.edu/pub/cs/techreports/schwartz/HarvestCache.ps.Z
+This is the Squid Internet Object Cache developed by the National
+Laboratory for Applied Networking Research (NLANR) and Internet
+volunteers.  This software is freely available for anyone to use.
+The Squid home page is http://www.nlanr.net/Squid/.
 
-The Harvest cache may also be run as an ``accelerator'' for HTTP servers, as
-described in http://harvest.cs.colorado.edu/harvest/httpd_accel.html
+This software is based on the Harvest Object Cache developed by
+the University of Colorado and the University of Southern California.
+The Harvest home page is http://harvest.cs.colorado.edu/.
 
-You can learn more about the overall Harvest system starting from the
-Harvest Home Page at http://harvest.cs.colorado.edu/
-
-Harvest documentation is on-line at
-http://harvest.cs.colorado.edu/harvest/doc.html
-
-For further assistance, see http://harvest.cs.colorado.edu/support.html.
@@ -517,7 +517,7 @@ fi
 
 
 
-# From configure.in Revision: 1.17 
+# From configure.in Revision: 1.18.2.3 
 ac_aux_dir=
 for ac_dir in aux $srcdir/aux; do
   if test -f $ac_dir/install-sh; then
@@ -1269,6 +1269,7 @@ for ac_hdr in \
 	sys/select.h\
 	sys/time.h \
 	sys/types.h \
+	sys/syscall.h \
 	unistd.h \
 	regex.h \
 	syslog.h \
@@ -1280,7 +1281,7 @@ if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1284 "configure"
+#line 1285 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
@@ -1311,7 +1312,7 @@ done
 
 echo $ac_n "checking for tm->tm_gmtoff""... $ac_c" 1>&6
 cat > conftest.$ac_ext <<EOF
-#line 1315 "configure"
+#line 1316 "configure"
 #include "confdefs.h"
 #include <time.h>
 #include <sys/time.h>
@@ -1337,7 +1338,7 @@ rm -f conftest*
 
 echo $ac_n "checking for extended mallinfo""... $ac_c" 1>&6
 cat > conftest.$ac_ext <<EOF
-#line 1341 "configure"
+#line 1342 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <malloc.h>
@@ -1361,6 +1362,33 @@ fi
 rm -f conftest*
 
 
+echo $ac_n "checking if signal handlers need to be reset""... $ac_c" 1>&6
+if test "$cross_compiling" = yes; then
+  cat >> confdefs.h <<\EOF
+#define RESET_SIGNAL_HANDLER 1
+EOF
+
+echo "$ac_t""yes" 1>&6
+else
+cat > conftest.$ac_ext <<EOF
+#line 1375 "configure"
+#include "confdefs.h"
+void handle(s) int s; { return; }
+main(){signal(15,handle);kill(getpid(),15);kill(getpid(),15);exit(0);}
+EOF
+eval $ac_link
+if test -s conftest && (./conftest; exit) 2>/dev/null; then
+  echo "$ac_t""no" 1>&6
+else
+  cat >> confdefs.h <<\EOF
+#define RESET_SIGNAL_HANDLER 1
+EOF
+
+echo "$ac_t""yes" 1>&6
+fi
+fi
+rm -fr conftest*
+
 echo $ac_n "checking size of int""... $ac_c" 1>&6
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1369,7 +1397,7 @@ else
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
 cat > conftest.$ac_ext <<EOF
-#line 1373 "configure"
+#line 1401 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -1403,7 +1431,7 @@ else
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
 cat > conftest.$ac_ext <<EOF
-#line 1407 "configure"
+#line 1435 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -1437,7 +1465,7 @@ if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1441 "configure"
+#line 1469 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() { return 0; }
@@ -1469,7 +1497,7 @@ if eval "test \"`echo '$''{'ac_cv_func_alloca'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1473 "configure"
+#line 1501 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -1528,7 +1556,7 @@ if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1532 "configure"
+#line 1560 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -1557,7 +1585,7 @@ if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1561 "configure"
+#line 1589 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -1611,7 +1639,7 @@ else
   ac_cv_c_stack_direction=0
 else
 cat > conftest.$ac_ext <<EOF
-#line 1615 "configure"
+#line 1643 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -1656,7 +1684,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1660 "configure"
+#line 1688 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1696,7 +1724,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1700 "configure"
+#line 1728 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1730,7 +1758,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1734 "configure"
+#line 1762 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1770,7 +1798,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1774 "configure"
+#line 1802 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1810,7 +1838,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lbsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1814 "configure"
+#line 1842 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1851,7 +1879,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-l44bsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1855 "configure"
+#line 1883 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1885,7 +1913,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1889 "configure"
+#line 1917 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1920,7 +1948,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1924 "configure"
+#line 1952 "configure"
 #include "confdefs.h"
 
 int main() { return 0; }
@@ -1969,20 +1997,22 @@ for ac_func in \
 	regcomp \
 	regexec \
 	regfree \
+	seteuid \
+	setresuid \
 	setrlimit \
 	strdup \
 	strerror \
 	sysconf \
 	syslog \
-	timegm\
+	timegm \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1986 "configure"
+#line 2016 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -2027,6 +2057,73 @@ fi
 done
 
 
+echo $ac_n "checking Maximum number of filedescriptors we can open""... $ac_c" 1>&6
+if test "$cross_compiling" = yes; then
+  SQUID_FD_SETSIZE=256
+else
+cat > conftest.$ac_ext <<EOF
+#line 2066 "configure"
+#include "confdefs.h"
+
+#include <unistd.h>
+#include <sys/param.h>
+#include <sys/resource.h>
+main() {
+	int i,j;
+#if HAVE_SETRLIMIT
+    struct rlimit rl;
+#if defined(RLIMIT_NOFILE)
+    if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
+        perror("getrlimit: RLIMIT_NOFILE");
+    } else {
+        rl.rlim_cur = rl.rlim_max;      /* set it to the max */
+        if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
+            perror("setrlimit: RLIMIT_NOFILE");
+        }
+    }
+#elif defined(RLIMIT_OFILE)
+    if (getrlimit(RLIMIT_OFILE, &rl) < 0) {
+        perror("getrlimit: RLIMIT_OFILE");
+    } else {
+        rl.rlim_cur = rl.rlim_max;      /* set it to the max */
+        if (setrlimit(RLIMIT_OFILE, &rl) < 0) {
+            perror("setrlimit: RLIMIT_OFILE");
+        }
+    }
+#endif /* RLIMIT_NOFILE */
+#endif /* HAVE_SETRLIMIT */
+#if HAVE_SYSCONF && defined(_SC_OPEN_MAX)
+        i = sysconf(_SC_OPEN_MAX);
+#elif HAVE_GETDTABLESIZE
+        i = getdtablesize();
+#elif defined(OPEN_MAX)
+        i = OPEN_MAX;
+#elif defined(NOFILE)
+        i = NOFILE;
+#elif defined(_NFILE)
+        i = _NFILE;
+#else
+	while((j=open("/dev/null", 0)) > 0) i=j;
+#endif
+	fprintf (fopen("conftestval", "w"), "%d\n", i);
+	exit(0);
+}
+
+EOF
+eval $ac_link
+if test -s conftest && (./conftest; exit) 2>/dev/null; then
+  SQUID_FD_SETSIZE=`cat conftestval`
+else
+  SQUID_FD_SETSIZE=256
+fi
+fi
+rm -fr conftest*
+echo "$ac_t""$SQUID_FD_SETSIZE" 1>&6
+cat >> confdefs.h <<EOF
+#define SQUID_FD_SETSIZE $SQUID_FD_SETSIZE
+EOF
+
+
 XTRA_OBJS=''
 if test "$HAVE_LIBMALLOC" = "yes" ; then
 	if test -r /usr/lib/debug/malloc.o ; then
@@ -3,13 +3,13 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.7)
 dnl
-dnl  $Id: configure.in,v 1.18 1996/04/16 18:34:09 wessels Exp $
+dnl  $Id: configure.in,v 1.19 1996/05/01 22:36:19 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.18 $)dnl
+AC_REVISION($Revision: 1.19 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(aux)
 
@@ -113,6 +113,7 @@ AC_CHECK_HEADERS( \
 	sys/select.h\
 	sys/time.h \
 	sys/types.h \
+	sys/syscall.h \
 	unistd.h \
 	regex.h \
 	syslog.h \
@@ -136,6 +137,16 @@ foo.mxfast = 0;],
 AC_MSG_RESULT(yes)],
 AC_MSG_RESULT(no))
 
+AC_MSG_CHECKING(if signal handlers need to be reset)
+AC_TRY_RUN([void handle(s) int s; { return; }
+main(){signal(15,handle);kill(getpid(),15);kill(getpid(),15);exit(0);}],
+AC_MSG_RESULT(no),
+[AC_DEFINE(RESET_SIGNAL_HANDLER)
+AC_MSG_RESULT(yes)],
+dnl default
+[AC_DEFINE(RESET_SIGNAL_HANDLER)
+AC_MSG_RESULT(yes)],)
+
 dnl Check for typedefs
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
@@ -185,14 +196,68 @@ AC_CHECK_FUNCS(\
 	regcomp \
 	regexec \
 	regfree \
+	seteuid \
+	setresuid \
 	setrlimit \
 	strdup \
 	strerror \
 	sysconf \
 	syslog \
-	timegm\
+	timegm \
 )
 
+AC_MSG_CHECKING(Maximum number of filedescriptors we can open)
+AC_TRY_RUN([
+#include <unistd.h>
+#include <sys/param.h>
+#include <sys/resource.h>
+main() {
+	int i,j;
+#if HAVE_SETRLIMIT
+    struct rlimit rl;
+#if defined(RLIMIT_NOFILE)
+    if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
+        perror("getrlimit: RLIMIT_NOFILE");
+    } else {
+        rl.rlim_cur = rl.rlim_max;      /* set it to the max */
+        if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
+            perror("setrlimit: RLIMIT_NOFILE");
+        }
+    }
+#elif defined(RLIMIT_OFILE)
+    if (getrlimit(RLIMIT_OFILE, &rl) < 0) {
+        perror("getrlimit: RLIMIT_OFILE");
+    } else {
+        rl.rlim_cur = rl.rlim_max;      /* set it to the max */
+        if (setrlimit(RLIMIT_OFILE, &rl) < 0) {
+            perror("setrlimit: RLIMIT_OFILE");
+        }
+    }
+#endif /* RLIMIT_NOFILE */
+#endif /* HAVE_SETRLIMIT */
+#if HAVE_SYSCONF && defined(_SC_OPEN_MAX)
+        i = sysconf(_SC_OPEN_MAX);
+#elif HAVE_GETDTABLESIZE
+        i = getdtablesize();
+#elif defined(OPEN_MAX)
+        i = OPEN_MAX;
+#elif defined(NOFILE)
+        i = NOFILE;
+#elif defined(_NFILE)
+        i = _NFILE;
+#else
+	while((j=open("/dev/null", 0)) > 0) i=j;
+#endif
+	fprintf (fopen("conftestval", "w"), "%d\n", i);
+	exit(0);
+}
+],
+SQUID_FD_SETSIZE=`cat conftestval`,
+SQUID_FD_SETSIZE=256,
+SQUID_FD_SETSIZE=256)
+AC_MSG_RESULT($SQUID_FD_SETSIZE)
+AC_DEFINE_UNQUOTED(SQUID_FD_SETSIZE, $SQUID_FD_SETSIZE)
+
 dnl Need the debugging version of malloc if available
 XTRA_OBJS=''
 if test "$HAVE_LIBMALLOC" = "yes" ; then
@@ -25,12 +25,18 @@
 /* Define if you have the ANSI C header files.  */
 #undef STDC_HEADERS
 
-/* Define struct tm has tm_gmtoff member */
+/* Define if struct tm has tm_gmtoff member */
 #undef HAVE_TM_GMTOFF
 
-/* Define struct mallinfo has mxfast member */
+/* Define if struct mallinfo has mxfast member */
 #undef HAVE_EXT_MALLINFO
 
+/* Define if signal handlers must be reset after invocation */
+#undef RESET_SIGNAL_HANDLER
+
+/* Maximum number of open filedescriptors */
+#undef SQUID_FD_SETSIZE
+
 /* The number of bytes in a int.  */
 #undef SIZEOF_INT
 
@@ -55,6 +61,12 @@
 /* Define if you have the regfree function.  */
 #undef HAVE_REGFREE
 
+/* Define if you have the seteuid function.  */
+#undef HAVE_SETEUID
+
+/* Define if you have the setresuid function.  */
+#undef HAVE_SETRESUID
+
 /* Define if you have the setrlimit function.  */
 #undef HAVE_SETRLIMIT
 
@@ -127,6 +139,9 @@
 /* Define if you have the <sys/select.h> header file.  */
 #undef HAVE_SYS_SELECT_H
 
+/* Define if you have the <sys/syscall.h> header file.  */
+#undef HAVE_SYS_SYSCALL_H
+
 /* Define if you have the <sys/time.h> header file.  */
 #undef HAVE_SYS_TIME_H
 
@@ -3,12 +3,12 @@
 #
 #  Darren Hardy, hardy@cs.colorado.edu, April 1994
 #
-#  $Id: Makefile.in,v 1.7 1996/03/26 05:12:07 wessels Exp $
+#  $Id: Makefile.in,v 1.8 1996/05/01 22:36:21 wessels Exp $
 #
-prefix = @prefix@
-INSTALL_BINDIR	= $(prefix)/bin
-INSTALL_LIBDIR	= $(prefix)/lib
-INSTALL_MANDIR 	= $(prefix)/man
+prefix		= @prefix@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
 
 CC		= @CC@
 INSTALL		= @INSTALL@
@@ -20,7 +20,7 @@ STD_LDFLAGS	= @STD_LDFLAGS@
 XTRA_LIBS	= @XTRA_LIBS@
 XTRA_CFLAGS     = @XTRA_CFLAGS@
 
-INCLUDE		= -I../include
+INCLUDE		= -I../include -I$(srcdir)/../include
 UTILOBJS	= rfc850.o \
 		  rfc1738.o \
 		  util.o \
@@ -3,10 +3,13 @@
 #  Cache Manager is a manager program for Internet Object Cache.
 #
 
-prefix = @prefix@
-INSTALL_BINDIR	= $(prefix)/bin
-INSTALL_LIBDIR	= $(prefix)/lib
-INSTALL_MANDIR 	= $(prefix)/man
+prefix		= @prefix@
+exec_prefix     = @exec_prefix@
+top_srcdir      = @top_srcdir@
+bindir          = @bindir@
+sysconfdir      = @sysconfdir@
+srcdir          = @srcdir@
+VPATH           = @srcdir@
 
 CC		= @CC@
 INSTALL		= @INSTALL@
@@ -22,12 +25,12 @@ install:
 		echo "mkdir $(prefix)"; \
 		mkdir $(prefix); \
 	fi
-	@if test ! -d $(INSTALL_BINDIR); then \
-		echo "mkdir $(INSTALL_BINDIR)"; \
-		mkdir $(INSTALL_BINDIR); \
+	@if test ! -d $(bindir); then \
+		echo "mkdir $(bindir)"; \
+		mkdir $(bindir); \
 	fi
-	$(INSTALL_BIN) RunCache $(INSTALL_BINDIR)
-	$(INSTALL_BIN) RunAccel $(INSTALL_BINDIR)
+	$(INSTALL_BIN) RunCache $(bindir)
+	$(INSTALL_BIN) RunAccel $(bindir)
 
 clean:
 
@@ -1,11 +1,12 @@
 #!/bin/sh
 #
-#  $Id: RunCache.in,v 1.3 1996/04/16 05:48:20 wessels Exp $
+#  $Id: RunCache.in,v 1.4 1996/05/01 22:36:22 wessels Exp $
 
 PATH=@prefix@/bin:/bin
 export PATH
 
-if test $#argv = 1 ; then
+conf=""
+if test "$1" ; then
 	conf="-f $1"
 	shift;
 fi
@@ -7,7 +7,7 @@
 # Version 1 did all this in memory, but the log file can be a
 # little on the large side... 8-(
 
-# $Id: check_cache.pl,v 1.1 1996/02/22 06:23:57 wessels Exp $
+# $Id: check_cache.pl,v 1.2 1996/05/01 22:36:22 wessels Exp $
 
 require "getopts.pl";
 &Getopts("c:dl:rt:v");
@@ -22,7 +22,7 @@
 chdir($tmpdir);
 
 # snarf filenames from Harvest log & sort em
-system("cut -f2 -d' ' $logfile >pl$$");
+system("cut -f1 -d' ' $logfile >pl$$");
 system("sort -T $tmpdir pl$$ >spl$$; rm pl$$");
 
 # get list of files in cache & sort em
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.22 1996/04/16 20:53:32 wessels Exp $
+#  $Id: Makefile.in,v 1.23 1996/05/01 22:36:23 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -14,6 +14,8 @@ exec_prefix	= @exec_prefix@
 top_srcdir	= @top_srcdir@
 bindir		= @bindir@
 sysconfdir	= @sysconfdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
 
 CC		= @CC@
 INSTALL		= @INSTALL@
@@ -31,7 +33,7 @@ XTRA_OBJS 	= @XTRA_OBJS@
 SHELL		= /bin/sh
 
 
-INCLUDE		= -I. -I../include	# MUST use -I. first
+INCLUDE		= -I. -I../include -I$(srcdir)/../include
 CFLAGS 		= $(STD_CFLAGS) $(XTRA_CFLAGS) $(INCLUDE) $(DEFINES)
 LDFLAGS         = $(STD_LDFLAGS)
 LIBS		= -L../lib -lregex -lutil $(XTRA_LIBS)
@@ -65,7 +67,7 @@ squid:	$(OBJS)
 	$(CC) -o $@ $(LDFLAGS) $(OBJS) $(CRYPT_LIB) $(LIBS)
 
 cache_cf.o: cache_cf.c
-	$(CC) -c cache_cf.c $(CFLAGS) $(DEFAULTS)
+	$(CC) -c $< $(CFLAGS) $(DEFAULTS)
 
 client:	client.o
 	$(CC) -o $@ $(LDFLAGS) $@.o $(CLIENT_LIBS)
@@ -1,4 +1,4 @@
-#ident "$Id: acl.cc,v 1.12 1996/04/16 05:05:17 wessels Exp $"
+/* "$Id: acl.cc,v 1.13 1996/05/01 22:36:23 wessels Exp $" */
 
 /*
  * DEBUG: Section 28          acl
@@ -426,6 +426,8 @@ int aclMatchWord(data, word)
      wordlist *data;
      char *word;
 {
+    if (word == NULL)
+	return 0;
     debug(28, 3, "aclMatchWord: checking '%s'\n", word);
     while (data) {
 	debug(28, 3, "aclMatchWord: looking for '%s'\n", data->key);
@@ -439,6 +441,8 @@ int aclMatchRegex(data, word)
      relist *data;
      char *word;
 {
+    if (word == NULL)
+	return 0;
     debug(28, 3, "aclMatchRegex: checking '%s'\n", word);
     while (data) {
 	debug(28, 3, "aclMatchRegex: looking for '%s'\n", data->pattern);
@@ -478,7 +482,7 @@ int aclMatchTime(data, when)
     t = (time_t) (tm.tm_hour * 60 + tm.tm_min);
     if (t < data->start || t > data->stop)
 	return 0;
-    return data->weekbits & tm.tm_wday ? 1 : 0;
+    return data->weekbits & (1 << tm.tm_wday) ? 1 : 0;
 }
 
 static int aclMatchAcl(acl, c, m, pr, h, po, r)
@@ -1,4 +1,4 @@
-/* $Id: cache_cf.cc,v 1.53 1996/04/17 23:46:17 wessels Exp $ */
+/* $Id: cache_cf.cc,v 1.54 1996/05/01 22:36:24 wessels Exp $ */
 
 /* DEBUG: Section 3             cache_cf: Configuration file parsing */
 
@@ -86,10 +86,10 @@ static struct {
 
 #define DefaultMemMaxSize 	(16 << 20)	/* 16 MB */
 #define DefaultMemHighWatherMark 90	/* 90% */
-#define DefaultMemLowWatherMark  60	/* 60% */
+#define DefaultMemLowWatherMark  75	/* 75% */
 #define DefaultSwapMaxSize	(100 << 10)	/* 100 MB (100*1024 kbytes) */
 #define DefaultSwapHighWaterMark 90	/* 90% */
-#define DefaultSwapLowWaterMark  60	/* 60% */
+#define DefaultSwapLowWaterMark  75	/* 75% */
 
 #define DefaultFtpDefaultTtl	(7 * 24 * 60 * 60)	/* 1 week */
 #define DefaultFtpMaxObjSize	(4 << 20)	/* 4 MB */
@@ -107,13 +107,13 @@ static struct {
 #define DefaultPositiveDnsTtl	(360 * 60)	/* 6 hours */
 #define DefaultReadTimeout	(15 * 60)	/* 15 min */
 #define DefaultLifetimeDefault	(200 * 60)	/* 3+ hours */
-#define DefaultLifetimeShutdown	30		/* 30 seconds */
+#define DefaultLifetimeShutdown	30	/* 30 seconds */
 #define DefaultConnectTimeout	(2 * 60)	/* 2 min */
 #define DefaultDefaultAgeMax	(3600 * 24 * 30)	/* 30 days */
 #define DefaultCleanRate	-1	/* disabled */
 #define DefaultDnsChildren	5	/* 3 processes */
 #define DefaultDnsChildrenMax	32	/* 32 processes */
-#define DefaultMaxRequestSize	(102400)	/* 100Kb */
+#define DefaultMaxRequestSize	(100 << 10)	/* 100Kb */
 #define DefaultHotVmFactor	0.0	/* disabled */
 
 #define DefaultAsciiPortNum	CACHE_HTTP_PORT
@@ -141,7 +141,7 @@ static struct {
 #define DefaultCommonLogFormat	1	/* default on */
 #define DefaultQuickAbort	0	/* default off */
 #define DefaultNeighborTimeout  2	/* 2 seconds */
-#define DefaultStallDelay	3	/* 3 seconds */
+#define DefaultStallDelay	1	/* 1 seconds */
 #define DefaultSingleParentBypass 0	/* default off */
 #define DefaultPidFilename      (char *)NULL	/* default NONE */
 #define DefaultVisibleHostname  (char *)NULL	/* default NONE */
@@ -151,20 +151,6 @@ static struct {
 #define DefaultAnnounceFile	(char *)NULL	/* default NONE */
 #define DefaultAnnounceRate	86400	/* every 24 hours */
 
- /* default CONNECT ports */
-intlist snews =
-{
-    563,
-    NULL
-};
-intlist https =
-{
-    443,
-    &snews
-};
-intlist *connect_port_list = &https;
-
-
 ip_acl *local_ip_list = NULL;
 
 int zap_disk_store = 0;		/* off, try to rebuild from disk */
@@ -371,29 +357,6 @@ void intlistDestroy(list)
     *list = NULL;
 }
 
-static void intlistAdd(list, str)
-     intlist **list;
-     char *str;
-{
-    intlist *p = NULL;
-    intlist *q = NULL;
-
-    if (!(*list)) {
-	/* empty list */
-	*list = (intlist *) xcalloc(1, sizeof(intlist));
-	(*list)->i = atoi(str);
-	(*list)->next = NULL;
-    } else {
-	p = *list;
-	while (p->next)
-	    p = p->next;
-	q = (intlist *) xcalloc(1, sizeof(intlist));
-	q->i = atoi(str);
-	q->next = NULL;
-	p->next = q;
-    }
-}
-
 
 /* Use this #define in all the parse*() functions.  Assumes 
  * ** char *token is defined
@@ -435,6 +398,8 @@ static void parseCacheHostLine()
 	    self_destruct();
 	}
     }
+    if (weight < 1)
+	weight = 1;
     neighbors_cf_add(hostname, type, ascii_port, udp_port, proxy_only, weight);
 }
 
@@ -1027,19 +992,6 @@ static void parseFtpUserLine()
     Config.ftpUser = xstrdup(token);
 }
 
-static void parseConnectPortsLine()
-{
-    char *token;
-    static char origPortList = 1;
-    if (origPortList) {
-	connect_port_list = NULL;
-	origPortList = 0;
-    }
-    while ((token = strtok(NULL, w_space))) {
-	intlistAdd(&connect_port_list, token);
-    }
-}
-
 static void parseCacheAnnounceLine()
 {
     char *token;
@@ -1084,7 +1036,8 @@ int parseConfigFile(file_name)
     aclDestroyAccessList(&ICPAccessList);
 
     if ((fp = fopen(file_name, "r")) == NULL) {
-	sprintf(fatal_str, "Unable to open configuration file: %s", file_name);
+	sprintf(fatal_str, "Unable to open configuration file: %s: %s",
+	    file_name, xstrerror());
 	fatal(fatal_str);
     }
     cfg_filename = file_name;
@@ -1338,9 +1291,6 @@ int parseConfigFile(file_name)
 	else if (!strcmp(token, "ftp_user"))
 	    parseFtpUserLine();
 
-	else if (!strcmp(token, "connect_ports"))
-	    parseConnectPortsLine();
-
 	else if (!strcmp(token, "cache_announce"))
 	    parseCacheAnnounceLine();
 
@@ -1,26 +1,97 @@
-/* $Id: cachemgr.cc,v 1.7 1996/04/16 16:35:26 wessels Exp $ */
+/* $Id: cachemgr.cc,v 1.8 1996/05/01 22:36:25 wessels Exp $ */
+
+#include "config.h"
+#include "autoconf.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <malloc.h>
+#include <memory.h>
+#include <netdb.h>
+#include <pwd.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/param.h>
+#include <sys/time.h>
+#include <sys/resource.h>	/* needs sys/time.h above it */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+
+#if HAVE_BSTRING_H
+#include <bstring.h>
+#endif
+
+#ifdef HAVE_CRYPT_H
+#include <crypt.h>
+#endif
 
-#include "squid.h"
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
 
-static int client_comm_connect();
+#include "util.h"
 
 #define MAX_ENTRIES 10000
-#define INFO        0
-#define CACHED      1
-#define SERVER      2
-#define LOG         3
-#define STATS_G     4
-#define STATS_O     5
-#define STATS_U     6
-#define PARAM       7
-#define RESPT       8
-#define SHUTDOWN    9
-#define REFRESH     10
+
+#define FALSE 0
+#define TRUE !FALSE
+#define LF 10
+#define CR 13
+
+typedef enum {
+    INFO,
+    CACHED,
+    SERVER,
+    LOG,
+    PARAM,
+    STATS_G,
+    STATS_O,
+    STATS_VM,
+    STATS_U,
+    SHUTDOWN,
+    REFRESH,
 #ifdef REMOVE_OBJECT
-#define REMOVE      11
+    REMOVE,
 #endif
-#define FALSE       0
-#define TRUE        1
+    MAXOP
+} op_t;
+
+static char *op_cmds[] =
+{
+    "info",
+    "squid.conf",
+    "server_list",
+    "log",
+    "parameter",
+    "stats/general",
+    "stats/objects",
+    "stats/vm_objects",
+    "stats/utilization",
+    "shutdown",
+    "<refresh>",
+#ifdef REMOVE_OBJECT
+    "<remove>",
+#endif
+    "<maxop>"
+};
 
 typedef struct {
     char *name;
@@ -32,8 +103,7 @@ int hasTables = FALSE;
 char *script_name = "/cgi-bin/cachemgr.cgi";
 char *progname = NULL;
 
-#define LF 10
-#define CR 13
+static int client_comm_connect _PARAMS((int, char *, int));
 
 void print_trailer()
 {
@@ -76,9 +146,6 @@ void noargs_html()
     printf("<OPTION SELECTED VALUE=\"info\">Cache Information\n");
     printf("<OPTION VALUE=\"squid.conf\">Cache Configuration File\n");
     printf("<OPTION VALUE=\"parameter\">Cache Parameters\n");
-#ifdef MENU_RESPONSETIME
-    printf("<OPTION VALUE=\"responsetime\">Cache Response Time Histogram\n");
-#endif
 #ifdef MENU_SHOW_LOG
     printf("<OPTION VALUE=\"log\">Cache Log\n");
 #endif
@@ -350,67 +417,80 @@ int main(int argc, char *argv[])
     }
     close(0);
 
-    if (!strncmp(operation, "info", 4) ||
-	!strncmp(operation, "Cache Information", 17)) {
+    if (!strcmp(operation, "info") ||
+	!strcmp(operation, "Cache Information")) {
 	op = INFO;
-	sprintf(msg, "GET cache_object://%s/info\r\n", hostname);
-    } else if (!strncmp(operation, "squid.conf", 10) ||
-	!strncmp(operation, "Cache Configuration File", 24)) {
+    } else if (!strcmp(operation, "squid.conf") ||
+	!strcmp(operation, "Cache Configuration File")) {
 	op = CACHED;
-	sprintf(msg, "GET cache_object://%s/squid.conf\r\n", hostname);
-    } else if (!strncmp(operation, "server_list", 11) ||
-	!strncmp(operation, "Cache Server List", 17)) {
+    } else if (!strcmp(operation, "server_list") ||
+	!strcmp(operation, "Cache Server List")) {
 	op = SERVER;
-	sprintf(msg, "GET cache_object://%s/server_list\r\n", hostname);
 #ifdef MENU_SHOW_LOG
-    } else if (!strncmp(operation, "log", 3) ||
-	!strncmp(operation, "Cache Log", 9)) {
+    } else if (!strcmp(operation, "log") ||
+	!strcmp(operation, "Cache Log")) {
 	op = LOG;
-	sprintf(msg, "GET cache_object://%s/log\r\n", hostname);
 #endif
-    } else if (!strncmp(operation, "parameter", 9) ||
-	!strncmp(operation, "Cache Parameters", 16)) {
+    } else if (!strcmp(operation, "parameter") ||
+	!strcmp(operation, "Cache Parameters")) {
 	op = PARAM;
-	sprintf(msg, "GET cache_object://%s/parameter\r\n", hostname);
-#ifdef MENU_RESPONSETIME
-    } else if (!strncmp(operation, "responsetime", 11) ||
-	!strncmp(operation, "Cache Response Time Histogram", 28)) {
-	op = RESPT;
-	sprintf(msg, "GET cache_object://%s/responsetime\r\n", hostname);
-#endif
-    } else if (!strncmp(operation, "stats/general", 13) ||
-	!strncmp(operation, "General Statistics", 18)) {
+    } else if (!strcmp(operation, "stats/general") ||
+	!strcmp(operation, "General Statistics")) {
 	op = STATS_G;
-	sprintf(msg, "GET cache_object://%s/stats/general\r\n", hostname);
-    } else if (!strncmp(operation, "stats/vm_objects", 16)) {
-	op = STATS_O;
-	sprintf(msg, "GET cache_object://%s/stats/vm_objects\r\n", hostname);
-    } else if (!strncmp(operation, "stats/objects", 13) ||
-	!strncmp(operation, "Objects", 7)) {
+    } else if (!strcmp(operation, "stats/vm_objects") ||
+	!strcmp(operation, "VM_Objects")) {
+	op = STATS_VM;
+    } else if (!strcmp(operation, "stats/objects") ||
+	!strcmp(operation, "Objects")) {
 	op = STATS_O;
-	sprintf(msg, "GET cache_object://%s/stats/objects\r\n", hostname);
-    } else if (!strncmp(operation, "stats/utilization", 17) ||
-	!strncmp(operation, "Utilization", 11)) {
+    } else if (!strcmp(operation, "stats/utilization") ||
+	!strcmp(operation, "Utilization")) {
 	op = STATS_U;
-	sprintf(msg, "GET cache_object://%s/stats/utilization\r\n", hostname);
-    } else if (!strncmp(operation, "shutdown", 8)) {
+    } else if (!strcmp(operation, "shutdown")) {
 	op = SHUTDOWN;
-	sprintf(msg, "GET cache_object://%s/shutdown@%s\r\n", hostname, password);
-    } else if (!strncmp(operation, "refresh", 7)) {
+    } else if (!strcmp(operation, "refresh")) {
 	op = REFRESH;
-	sprintf(msg, "GET %s HTTP/1.0\r\nPragma: no-cache\r\nAccept: */*\r\n\r\n", url);
 #ifdef REMOVE_OBJECT
-    } else if (!strncmp(operation, "remove", 6)) {
+    } else if (!strcmp(operation, "remove")) {
 	op = REMOVE;
-	/* Peter: not sure what to do here - depends what you do at your end! */
-	sprintf(msg, "REMOVE %s HTTP/1.0\r\nPragma: no-cache\r\nAccept: */*\r\n\r\n", url);
 #endif
-
     } else {
 	printf("Unknown operation: %s\n", operation);
 	exit(0);
     }
 
+    switch (op) {
+    case INFO:
+    case CACHED:
+    case SERVER:
+    case LOG:
+    case PARAM:
+    case STATS_G:
+    case STATS_O:
+    case STATS_VM:
+    case STATS_U:
+	sprintf(msg, "GET cache_object://%s/%s HTTP/1.0\r\n\r\n",
+	    hostname, op_cmds[op]);
+	break;
+    case SHUTDOWN:
+	sprintf(msg, "GET cache_object://%s/%s@%s HTTP/1.0\r\n\r\n",
+	    hostname, op_cmds[op], password);
+	break;
+    case REFRESH:
+	sprintf(msg, "GET %s HTTP/1.0\r\nPragma: no-cache\r\nAccept: */*\r\n\r\n", url);
+	break;
+#ifdef REMOVE_OBJECT
+    case REMOVE:
+	printf("Remove not yet supported\n");
+	exit(0);
+	/* NOTREACHED */
+#endif
+    default:
+    case MAXOP:
+	printf("Unknown operation: %s\n", operation);
+	exit(0);
+	/* NOTREACHED */
+    }
 
     time_val = time(NULL);
     time_string = ctime(&time_val);
@@ -423,9 +503,6 @@ int main(int argc, char *argv[])
     printf("<OPTION VALUE=\"info\">Cache Information\n");
     printf("<OPTION VALUE=\"squid.conf\">Cache Configuration File\n");
     printf("<OPTION VALUE=\"parameter\">Cache Parameters\n");
-#ifdef MENU_RESPONSETIME
-    printf("<OPTION VALUE=\"responsetime\">Cache Response Time Histogram\n");
-#endif
 #ifdef MENU_SHOW_LOG
     printf("<OPTION VALUE=\"log\">Cache Log\n");
 #endif
@@ -473,6 +550,7 @@ int main(int argc, char *argv[])
     case LOG:
     case STATS_G:
     case STATS_O:
+    case STATS_VM:
     case SHUTDOWN:
     case REFRESH:
 	break;
@@ -484,14 +562,6 @@ int main(int argc, char *argv[])
 	    printf("<B>\n %20s %10s %s</B><HR>\n", "Parameter", "Value", "Description");
 	}
 	break;
-    case RESPT:
-	if (hasTables) {
-	    printf("<table border=1><td><B>Time (msec)</B><td><B>Frequency</B><tr>\n");
-	    in_table = 1;
-	} else {
-	    printf("<B>\n %20s %10s </B><HR>\n", "Time (msec)", "Frequency");
-	}
-	break;
     case STATS_U:
 	if (hasTables) {
 	    printf("<table border=1><td><B>Protocol</B><td><B>Count</B><td><B>Max KB</B><td><B>Current KB</B><td><B>Min KB</B><td><B>Hit Ratio</B><td><B>Transfer Rate</B><td><B>References</B><td><B>Transfered KB</B><tr>\n");
@@ -561,16 +631,6 @@ int main(int argc, char *argv[])
 		    else
 			printf(" %20s %10d %s\n", s1, d1, s2 + 2);
 		    break;
-		case RESPT:
-		    p_state = 1;
-		    memset(s1, '\0', 255);
-		    d1 = 0;
-		    sscanf(reserve, "%s %d", s1, &d1);
-		    if (hasTables)
-			printf("<tr><td><B>%s</B><td>%d\n", s1, d1);
-		    else
-			printf(" %20s %10d\n", s1, d1);
-		    break;
 		case STATS_U:
 		    p_state = 1;
 		    sscanf(reserve, "%s %d %d %d %d %f %d %d %d",
@@ -583,6 +643,7 @@ int main(int argc, char *argv[])
 			    s1, d1, d2, d3, d4, f1, d5, d6, d7);
 		    break;
 		case STATS_O:
+		case STATS_VM:
 		    if (!in_list) {
 			in_list = 1;
 			printf("<OL>\n");
@@ -1,5 +1,5 @@
 
-/* $Id: client.cc,v 1.4 1996/03/27 01:45:56 wessels Exp $ */
+/* $Id: client.cc,v 1.5 1996/05/01 22:36:25 wessels Exp $ */
 
 #include "squid.h"
 
@@ -21,6 +21,7 @@ Options:\n\
     -s         Silent.  Do not print data to stdout.\n\
     -h host    Retrieve URL from cache on hostname.  Default is localhost.\n\
     -p port    Port number of cache.  Default is %d.\n\
+    -m method  Request method, default is GET\n\
 ", progname, CACHE_HTTP_PORT);
     exit(1);
 }
@@ -32,7 +33,9 @@ int main(argc, argv)
     int conn, c, len, bytesWritten;
     int port, to_stdout, reload;
     char url[BUFSIZ], msg[BUFSIZ], buf[BUFSIZ], hostname[BUFSIZ];
+    char *method = "GET";
     extern char *optarg;
+    time_t ims = 0;
 
     /* set the defaults */
     strcpy(hostname, "localhost");
@@ -46,7 +49,7 @@ int main(argc, argv)
 	strcpy(url, argv[argc - 1]);
 	if (url[0] == '-')
 	    usage(argv[0]);
-	while ((c = getopt(argc, argv, "fsrnp:c:h:?")) != -1)
+	while ((c = getopt(argc, argv, "fsrnp:c:h:i:m:?")) != -1)
 	    switch (c) {
 	    case 'h':		/* host:arg */
 	    case 'c':		/* backward compat */
@@ -65,6 +68,12 @@ int main(argc, argv)
 		if (port < 1)
 		    port = CACHE_HTTP_PORT;	/* default */
 		break;
+	    case 'i':		/* IMS */
+		ims = (time_t) atoi(optarg);
+		break;
+	    case 'm':
+		method = xstrdup(optarg);
+		break;
 	    case '?':		/* usage */
 	    default:
 		usage(argv[0]);
@@ -88,11 +97,19 @@ int main(argc, argv)
 	exit(1);
     }
     /* Build the HTTP request */
+    sprintf(msg, "%s %s HTTP/1.0\r\n", method, url);
     if (reload) {
-	sprintf(msg, "GET %s HTTP/1.0\r\nPragma: no-cache\r\nAccept: */*\r\n\r\n", url);
-    } else {
-	sprintf(msg, "GET %s HTTP/1.0\r\nAccept: */*\r\n\r\n", url);
+	sprintf(buf, "Pragma: no-cache\r\n");
+	strcat(msg, buf);
+    }
+    sprintf(buf, "Accept: */*\r\n");
+    strcat(msg, buf);
+    if (ims) {
+	sprintf(buf, "If-Modified-Since: %s\r\n", mkrfc850(&ims));
+	strcat(msg, buf);
     }
+    sprintf(buf, "\r\n");
+    strcat(msg, buf);
 
     /* Send the HTTP request */
     bytesWritten = write(conn, msg, strlen(msg));
@@ -1,5 +1,5 @@
 
-/* $Id: comm.cc,v 1.30 1996/04/17 23:48:38 wessels Exp $ */
+/* $Id: comm.cc,v 1.31 1996/05/01 22:36:26 wessels Exp $ */
 
 /* DEBUG: Section 5             comm: socket level functions */
 
@@ -568,6 +568,8 @@ int comm_select(sec, failtime)
 	if (!fdstat_are_n_free_fd(RESERVED_FD)) {
 	    FD_CLR(theAsciiConnection, &readfds);
 	}
+	if (shutdown_pending || reread_pending)
+	    debug(5, 1, "comm_select: Still waiting on %d FDs\n", nfds);
 	if (nfds == 0)
 	    return COMM_SHUTDOWN;
 	while (1) {
@@ -1016,15 +1018,15 @@ static void checkLifetimes()
 	    }
 	    if (tmp_local) {
 		if (use_lifetime_handler) {
-		    debug(5, 2, "comm_select: FD %d lifetime expire: %d < %d (Lifetime handler %p)\n",
+		    debug(5, 2, "checkLifetimes: FD %d lifetime expire: %d < %d (Lifetime handler %p)\n",
 			fd, lft, squid_curtime, tmp_local);
 		} else {
-		    debug(5, 2, "comm_select: FD %d lifetime expire: %d < %d (%s handler %p)\n",
+		    debug(5, 2, "checkLifetimes: FD %d lifetime expire: %d < %d (%s handler %p)\n",
 			fd, lft, squid_curtime,
 			use_read ? "read" : "write", tmp_local);
 		}
 	    } else {
-		debug(5, 1, "comm_select: FD %d lifetime expire: %d < %d (handler not available.)\n",
+		debug(5, 1, "checkLifetimes: FD %d lifetime expire: %d < %d (handler not available.)\n",
 		    fd, lft, squid_curtime);
 	    }
 
@@ -1037,25 +1039,26 @@ static void checkLifetimes()
 		     *  deallocates the structure.
 		     */
 		    (void) close(fd);
+		    debug(5, 0, "checkLifetimes: Forcing close on FD %d\n", fd);
 		    tmp_local(fd, use_read ? fd_table[fd].read_data :
 			fd_table[fd].write_data);
 		}
 		if (fd_table[fd].openned) {
 		    /* hmm.. still openned. do full comm_close */
-		    debug(5, 5, "comm_select: FD %d lifetime expire: %d < %d : Handler did not close the socket.\n comm_select will do.\n",
+		    debug(5, 5, "checkLifetimes: FD %d lifetime expire: %d < %d : Handler did not close the socket.\n comm_select will do.\n",
 			fd, lft, squid_curtime);
 		    comm_close(fd);
 		} else {
 		    /* seems like handle closed it. 
 		     * clean up fd_table just to make sure */
-		    debug(5, 5, "comm_select: FD %d lifetime expire: %d : Handler closed the socket.\n",
+		    debug(5, 5, "checkLifetimes: FD %d lifetime expire: %d : Handler closed the socket.\n",
 			fd, lft);
 		    /* just to make sure here */
 		    comm_cleanup_fd_entry(fd);
 		}
 	    } else {
 		/* no handle. do full comm_close */
-		debug(5, 5, "comm_select: FD %d lifetime expire: %d < %d : No handler to close the socket.\n comm_select will do.\n",
+		debug(5, 5, "checkLifetimes: FD %d lifetime expire: %d < %d : No handler to close the socket.\n comm_select will do.\n",
 		    fd, lft, squid_curtime);
 		comm_close(fd);
 	    }
@@ -1,4 +1,4 @@
-/* $Id: disk.cc,v 1.11 1996/04/17 17:15:23 wessels Exp $ */
+/* $Id: disk.cc,v 1.12 1996/05/01 22:36:27 wessels Exp $ */
 
 /* DEBUG: Section 6             disk: disk I/O routines */
 
@@ -474,7 +474,9 @@ int diskHandleRead(fd, ctrl_dat)
 
     /* reschedule if need more data. */
     if (ctrl_dat->cur_len < ctrl_dat->req_len) {
-	comm_set_select_handler(fd, COMM_SELECT_READ, (PF) diskHandleRead,
+	comm_set_select_handler(fd,
+	    COMM_SELECT_READ,
+	    (PF) diskHandleRead,
 	    (void *) ctrl_dat);
 	return DISK_OK;
     } else {
@@ -513,7 +515,9 @@ int file_read(fd, buf, req_len, offset, handler, client_data)
     ctrl_dat->handler = handler;
     ctrl_dat->client_data = client_data;
 
-    comm_set_select_handler(fd, COMM_SELECT_READ, (PF) diskHandleRead,
+    comm_set_select_handler(fd,
+	COMM_SELECT_READ,
+	(PF) diskHandleRead,
 	(void *) ctrl_dat);
 
     return DISK_OK;
@@ -1,4 +1,4 @@
-/* $Id: errorpage.cc,v 1.20 1996/04/16 05:05:20 wessels Exp $ */
+/* $Id: errorpage.cc,v 1.21 1996/05/01 22:36:28 wessels Exp $ */
 
 /* DEBUG: Section 4             errorpage: Error printing routines */
 
@@ -86,15 +86,9 @@ error_data ErrorData[] =
     {"ERR_DISK_IO",
 	"Cache Disk I/O Failure",
 	"The system disk is out of space or failing."},
-    {"ERR_URL_BLOCKED",
-	"Access Denied",
-	"You are not allowed to access this URL."},
     {"ERR_ZERO_SIZE_OBJECT",
 	"No Object Data",
-	"The remote server closed the connection before sending any data."},
-    {"ERR_MAX"
-	"",
-	""}
+	"The remote server closed the connection before sending any data."}
 };
 
 /* GLOBAL */
@@ -154,7 +148,7 @@ char *squid_error_url(url, method, type, address, code, msg)
     int index;
 
     *tmp_error_buf = '\0';
-    if (type == ERR_MIN || type > ERR_MAX)
+    if (type < ERR_MIN || type > ERR_MAX)
 	fatal_dump("squid_error_url: type out of range.");
     index = (int) (type - ERR_MIN);
     sprintf(tmp_error_buf, "HTTP/1.0 %d Cache Detected Error\r\nContent-type: text/html\r\n\r\n", code);
@@ -200,7 +194,7 @@ char *squid_error_request(request, type, address, code)
     int index;
 
     *tmp_error_buf = '\0';
-    if (type == ERR_MIN || type > ERR_MAX)
+    if (type < ERR_MIN || type > ERR_MAX)
 	fatal_dump("squid_error_url: type out of range.");
     index = (int) (type - ERR_MIN);
 
@@ -1,4 +1,4 @@
-/* $Id: ftp.cc,v 1.37 1996/04/17 18:06:24 wessels Exp $ */
+/* $Id: ftp.cc,v 1.38 1996/05/01 22:36:29 wessels Exp $ */
 
 /*
  * DEBUG: Section 9           ftp: FTP
@@ -11,8 +11,10 @@
 #define MAGIC_MARKER    "\004\004\004"	/* No doubt this should be more configurable */
 #define MAGIC_MARKER_SZ 3
 
-static char *ftpASCII = "A";
-static char *ftpBinary = "I";
+static char ftpASCII[] = "A";
+static char ftpBinary[] = "I";
+static char localhost[] = "127.0.0.1";
+static int ftpget_server_pipe = -1;
 
 typedef struct _Ftpdata {
     StoreEntry *entry;
@@ -252,22 +254,22 @@ static void ftpProcessReplyHeader(data, buf, size)
 	case 410:		/* Gone */
 	    /* These can be cached for a long time, make the key public */
 	    entry->expires = squid_curtime + ttlSet(entry);
-	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	    if (BIT_TEST(entry->flag, CACHABLE))
 		storeSetPublicKey(entry);
 	    break;
+	case 304:		/* Not Modified */
 	case 401:		/* Unauthorized */
 	case 407:		/* Proxy Authentication Required */
 	    /* These should never be cached at all */
-	    if (BIT_TEST(entry->flag, ENTRY_PRIVATE))
-		storeSetPrivateKey(entry);
+	    storeSetPrivateKey(entry);
 	    storeExpireNow(entry);
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
 	    break;
 	default:
 	    /* These can be negative cached, make key public */
 	    entry->expires = squid_curtime + getNegativeTTL();
-	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	    if (BIT_TEST(entry->flag, CACHABLE))
 		storeSetPublicKey(entry);
 	    break;
 	}
@@ -506,23 +508,21 @@ void ftpSendRequest(fd, data)
     strcat(buf, "- ");		/* stdout */
     strcat(buf, data->host);
     strcat(buf, space);
-    strcat(buf, path);
+    strcat(buf, *path ? path : "\"\"");
     strcat(buf, space);
     strcat(buf, mode);		/* A or I */
     strcat(buf, space);
-    strcat(buf, data->user);
-    strcat(buf, space);
-    strcat(buf, data->password);
+    strcat(buf, *data->user ? data->user : "\"\"");
     strcat(buf, space);
+    strcat(buf, *data->password ? data->password : "\"\"");
+    strcat(buf, "\n");
     debug(9, 5, "ftpSendRequest: FD %d: buf '%s'\n", fd, buf);
     data->icp_rwd_ptr = icpWrite(fd,
 	buf,
 	strlen(buf),
 	30,
 	ftpSendComplete,
 	(void *) data);
-    if (!BIT_TEST(data->entry->flag, ENTRY_PRIVATE))
-	storeSetPublicKey(data->entry);		/* Make it public */
 }
 
 void ftpConnInProgress(fd, data)
@@ -533,7 +533,7 @@ void ftpConnInProgress(fd, data)
 
     debug(9, 5, "ftpConnInProgress: FD %d\n", fd);
 
-    if (comm_connect(fd, "localhost", CACHE_FTP_PORT) != COMM_OK)
+    if (comm_connect(fd, localhost, CACHE_FTP_PORT) != COMM_OK)
 	switch (errno) {
 	case EINPROGRESS:
 	case EALREADY:
@@ -596,7 +596,7 @@ int ftpStart(unusedfd, url, entry)
 	(void *) data);
 
     /* Now connect ... */
-    if ((status = comm_connect(data->ftp_fd, "localhost", CACHE_FTP_PORT))) {
+    if ((status = comm_connect(data->ftp_fd, localhost, CACHE_FTP_PORT))) {
 	if (status != EINPROGRESS) {
 	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    comm_close(data->ftp_fd);
@@ -629,6 +629,37 @@ int ftpStart(unusedfd, url, entry)
     return COMM_OK;
 }
 
+static void ftpServerClosed(fd, nodata)
+     int fd;
+     void *nodata;
+{
+    static time_t last_restart = 0;
+    comm_close(fd);
+    if (squid_curtime - last_restart < 2) {
+	debug(9, 0, "ftpget server failing too rapidly\n");
+	debug(9, 0, "WARNING: FTP access is disabled!\n");
+	return;
+    }
+    last_restart = squid_curtime;
+    debug(9, 1, "Restarting ftpget server...\n");
+    (void) ftpInitialize();
+}
+
+void ftpServerClose()
+{
+    if (ftpget_server_pipe < 0)
+	return;
+
+    comm_set_select_handler(ftpget_server_pipe,
+	COMM_SELECT_EXCEPT,
+	(PF) NULL,
+	(void *) NULL);
+    fdstat_close(ftpget_server_pipe);
+    close(ftpget_server_pipe);
+    ftpget_server_pipe = -1;
+}
+
+
 int ftpInitialize()
 {
     int pid;
@@ -650,9 +681,18 @@ int ftpInitialize()
 	fdstat_open(p[1], Pipe);
 	fd_note(p[1], "ftpget -S");
 	fcntl(p[1], F_SETFD, 1);	/* set close-on-exec */
+	/* if ftpget -S goes away, this handler should get called */
+	comm_set_select_handler(p[1],
+	    COMM_SELECT_EXCEPT,
+	    (PF) ftpServerClosed,
+	    (void *) NULL);
+	ftpget_server_pipe = p[1];
 	return 0;
     }
     /* child */
+    /* give up all extra priviligies */
+    no_suid();
+    /* set up stdin,stdout */
     dup2(p[0], 0);
     dup2(fileno(debug_log), 2);
     close(p[0]);
@@ -1,4 +1,4 @@
-/* $Id: gopher.cc,v 1.28 1996/04/17 18:06:25 wessels Exp $ */
+/* $Id: gopher.cc,v 1.29 1996/05/01 22:36:31 wessels Exp $ */
 
 /*
  * DEBUG: Section 10          gopher: GOPHER
@@ -840,7 +840,7 @@ void gopherSendRequest(fd, data)
 	30,
 	gopherSendComplete,
 	(void *) data);
-    if (!BIT_TEST(data->entry->flag, ENTRY_PRIVATE))
+    if (BIT_TEST(data->entry->flag, CACHABLE))
 	storeSetPublicKey(data->entry);		/* Make it public */
 }
 
@@ -1,13 +1,13 @@
-/* $Id: http.cc,v 1.56 1996/04/17 21:03:14 wessels Exp $ */
+/* $Id: http.cc,v 1.57 1996/05/01 22:36:31 wessels Exp $ */
 
 /*
  * DEBUG: Section 11          http: HTTP
  */
 
 #include "squid.h"
 
-#define HTTP_DELETE_GAP   (64*1024)
-#define READBUFSIZ	4096
+#define READBUFSIZ	(1<<14)
+#define HTTP_DELETE_GAP   (1<<18)
 
 typedef struct _httpdata {
     StoreEntry *entry;
@@ -200,22 +200,22 @@ static void httpProcessReplyHeader(data, buf, size)
 	case 410:		/* Gone */
 	    /* These can be cached for a long time, make the key public */
 	    entry->expires = squid_curtime + ttlSet(entry);
-	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	    if (BIT_TEST(entry->flag, CACHABLE))
 		storeSetPublicKey(entry);
 	    break;
+	case 304:		/* Not Modified */
 	case 401:		/* Unauthorized */
 	case 407:		/* Proxy Authentication Required */
 	    /* These should never be cached at all */
-	    if (BIT_TEST(entry->flag, ENTRY_PRIVATE))
-		storeSetPrivateKey(entry);
+	    storeSetPrivateKey(entry);
 	    storeExpireNow(entry);
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
 	    break;
 	default:
 	    /* These can be negative cached, make key public */
 	    entry->expires = squid_curtime + getNegativeTTL();
-	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	    if (BIT_TEST(entry->flag, CACHABLE))
 		storeSetPublicKey(entry);
 	    break;
 	}
@@ -237,37 +237,34 @@ static void httpReadReply(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    if (entry->flag & DELETE_BEHIND) {
-	if (storeClientWaiting(entry)) {
-	    /* check if we want to defer reading */
-	    clen = entry->mem_obj->e_current_len;
-	    off = entry->mem_obj->e_lowest_offset;
-	    if ((clen - off) > HTTP_DELETE_GAP) {
-		debug(11, 3, "httpReadReply: Read deferred for Object: %s\n",
-		    entry->url);
-		debug(11, 3, "                Current Gap: %d bytes\n", clen - off);
-		/* reschedule, so it will be automatically reactivated
-		 * when Gap is big enough. */
-		comm_set_select_handler(fd,
-		    COMM_SELECT_READ,
-		    (PF) httpReadReply,
-		    (void *) data);
-		/* don't install read timeout until we are below the GAP */
-		comm_set_select_handler_plus_timeout(fd,
-		    COMM_SELECT_TIMEOUT,
-		    (PF) NULL,
-		    (void *) NULL,
-		    (time_t) 0);
-		/* dont try reading again for a while */
-		comm_set_stall(fd, getStallDelay());
-		return;
-	    }
-	} else {
-	    /* we can terminate connection right now */
-	    squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
-	    comm_close(fd);
-	    return;
-	}
+    if (entry->flag & DELETE_BEHIND && !storeClientWaiting(entry)) {
+	/* we can terminate connection right now */
+	squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
+	comm_close(fd);
+	return;
+    }
+    /* check if we want to defer reading */
+    clen = entry->mem_obj->e_current_len;
+    off = storeGetLowestReaderOffset(entry);
+    if ((clen - off) > HTTP_DELETE_GAP) {
+	debug(11, 3, "httpReadReply: Read deferred for Object: %s\n",
+	    entry->url);
+	debug(11, 3, "                Current Gap: %d bytes\n", clen - off);
+	/* reschedule, so it will be automatically reactivated
+	 * when Gap is big enough. */
+	comm_set_select_handler(fd,
+	    COMM_SELECT_READ,
+	    (PF) httpReadReply,
+	    (void *) data);
+	/* don't install read timeout until we are below the GAP */
+	comm_set_select_handler_plus_timeout(fd,
+	    COMM_SELECT_TIMEOUT,
+	    (PF) NULL,
+	    (void *) NULL,
+	    (time_t) 0);
+	/* dont try reading again for a while */
+	comm_set_stall(fd, getStallDelay());
+	return;
     }
     errno = 0;
     len = read(fd, buf, READBUFSIZ);
@@ -310,8 +307,7 @@ static void httpReadReply(fd, data)
 	comm_set_select_handler_plus_timeout(fd,
 	    COMM_SELECT_TIMEOUT,
 	    (PF) httpReadReplyTimeout,
-	    (void *) data,
-	    getReadTimeout());
+	    (void *) data, getReadTimeout());
     } else if (entry->flag & CLIENT_ABORT_REQUEST) {
 	/* append the last bit of info we get */
 	storeAppend(entry, buf, len);
@@ -385,7 +381,7 @@ static void httpSendRequest(fd, data)
     char *t = NULL;
     char *post_buf = NULL;
     static char *crlf = "\r\n";
-    static char *VIA_PROXY_TEXT = "via Sqiud Cache version";
+    static char *VIA_PROXY_TEXT = "via Squid Cache version";
     int len = 0;
     int buflen;
     int cfd = -1;
@@ -1,4 +1,4 @@
-/* $Id: ipcache.cc,v 1.26 1996/04/17 23:48:23 wessels Exp $ */
+/* $Id: ipcache.cc,v 1.27 1996/05/01 22:36:33 wessels Exp $ */
 
 /*
  * DEBUG: Section 14          ipcache: IP Cache
@@ -106,7 +106,7 @@ int ipcache_create_dnsserver(command)
     int pid;
     struct sockaddr_un addr;
     static int n_dnsserver = 0;
-    char socketname[256];
+    char *socketname = NULL;
     int cfd;			/* socket for child (dnsserver) */
     int sfd;			/* socket for server (squid) */
     int fd;
@@ -119,13 +119,15 @@ int ipcache_create_dnsserver(command)
     fd_note(cfd, "socket to dnsserver");
     memset(&addr, '\0', sizeof(addr));
     addr.sun_family = AF_UNIX;
-    sprintf(socketname, "dns/dns%d.%d", (int) getpid(), n_dnsserver++);
+    socketname = tempnam(NULL, "dns");
+    /* sprintf(socketname, "dns/dns%d.%d", (int) getpid(), n_dnsserver++); */
     strcpy(addr.sun_path, socketname);
     debug(14, 4, "ipcache_create_dnsserver: path is %s\n", addr.sun_path);
 
     if (bind(cfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 	close(cfd);
 	debug(14, 0, "ipcache_create_dnsserver: bind: %s\n", xstrerror());
+	xfree(socketname);
 	return -1;
     }
     debug(14, 4, "ipcache_create_dnsserver: bind to local host.\n");
@@ -134,6 +136,7 @@ int ipcache_create_dnsserver(command)
     if ((pid = fork()) < 0) {
 	debug(14, 0, "ipcache_create_dnsserver: fork: %s\n", xstrerror());
 	close(cfd);
+	xfree(socketname);
 	return -1;
     }
     if (pid > 0) {		/* parent */
@@ -142,12 +145,14 @@ int ipcache_create_dnsserver(command)
 	/* open new socket for parent process */
 	if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
 	    debug(14, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
+	    xfree(socketname);
 	    return -1;
 	}
 	fcntl(sfd, F_SETFD, 1);	/* set close-on-exec */
 	memset(&addr, '\0', sizeof(addr));
 	addr.sun_family = AF_UNIX;
 	strcpy(addr.sun_path, socketname);
+	xfree(socketname);
 	if (connect(sfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 	    close(sfd);
 	    debug(14, 0, "ipcache_create_dnsserver: connect: %s\n", xstrerror());
@@ -159,13 +164,17 @@ int ipcache_create_dnsserver(command)
     }
     /* child */
 
+    /* give up extra priviliges */
+    no_suid();
+
+    /* setup filedescriptors */
     dup2(cfd, 3);
     for (fd = getMaxFD(); fd > 3; fd--) {
 	(void) close(fd);
     }
 
     execlp(command, "(dnsserver)", "-p", socketname, NULL);
-    perror(command);
+    debug(14, 0, "ipcache_create_dnsserver: %s: %s\n", command, xstrerror());
     _exit(1);
     return (0);			/* NOTREACHED */
 }
@@ -1056,9 +1065,6 @@ void ipcacheOpenServers()
     int dnssocket;
     static char fd_note_buf[FD_ASCII_NOTE_SZ];
 
-    if (mkdir("dns", 0755) < 0 && errno != EEXIST)
-	debug(14, 0, "ipcacheOpenServers: mkdir %s\n", xstrerror());
-
     /* start up companion process */
     safe_free(dns_child_table);
     dns_child_table = (dnsserver_entry **) xcalloc(N, sizeof(dnsserver_entry));
@@ -1,4 +1,4 @@
-/* $Id: main.cc,v 1.44 1996/04/17 21:39:55 wessels Exp $ */
+/* $Id: main.cc,v 1.45 1996/05/01 22:36:34 wessels Exp $ */
 
 /* DEBUG: Section 1             main: startup and main loop */
 
@@ -107,6 +107,10 @@ static void mainParseOptions(argc, argv)
 
 void serverConnectionsOpen()
 {
+    /* Get our real priviliges */
+    get_suid();
+
+    /* Open server ports */
     theAsciiConnection = comm_open(COMM_NONBLOCKING,
 	getAsciiPortNum(),
 	0,
@@ -140,6 +144,8 @@ void serverConnectionsOpen()
 		theUdpConnection);
 	}
     }
+    /* And restore our priviliges to normal */
+    check_suid();
 }
 
 void serverConnectionsClose()
@@ -179,6 +185,7 @@ static void mainReinitialize()
     neighbors_init();
     ipcacheOpenServers();
     serverConnectionsOpen();
+    (void) ftpInitialize();
     if (theUdpConnection >= 0 && (!httpd_accel_mode || getAccelWithProxy()))
 	neighbors_open(theUdpConnection);
     debug(1, 0, "Ready to serve requests.\n");
@@ -209,20 +216,21 @@ static void mainInitialize()
     fd_note(fileno(debug_log), getCacheLogFile());
 
     debug(1, 0, "Starting Squid Cache (version %s)...\n", version_string);
+    debug(1, 1, "With %d file descriptors available\n", getMaxFD());
 
     if (first_time) {
-	disk_init();	/* disk_init must go before ipcache_init() */
+	disk_init();		/* disk_init must go before ipcache_init() */
+	writePidFile();		/* write PID file before setuid() */
     }
-
     ipcache_init();
     neighbors_init();
-    ftpInitialize();
+    (void) ftpInitialize();
 
 #if defined(MALLOC_DBG)
     malloc_debug(0, malloc_debug_level);
 #endif
 
-    /* do suid checking here */
+    /* do suid checking */
     check_suid();
 
     if (first_time) {
@@ -232,8 +240,15 @@ static void mainInitialize()
 	stat_init(&CacheInfo, getAccessLogFile());
 	storeInit();
 	stmemInit();
-	writePidFile();
 
+	if (getEffectiveUser()) {
+	    /* we were probably started as root, so cd to a swap
+	     * directory in case we dump core */
+	    if (chdir(swappath(0)) < 0) {
+		debug(1, 0, "%s: %s\n", swappath(0), xstrerror());
+		fatal_dump("Cannot cd to swap directory?");
+	    }
+	}
 	/* after this point we want to see the mallinfo() output */
 	do_mallinfo = 1;
     }
@@ -319,11 +334,11 @@ int main(argc, argv)
 	    loop_delay = (time_t) 0;
 	switch (comm_select(loop_delay, next_cleaning)) {
 	case COMM_OK:
-	    /* do nothing */
+	    errcount = 0;	/* reset if successful */
 	    break;
 	case COMM_ERROR:
 	    errcount++;
-	    debug(1, 0, "Select loop Error. Retry. %d\n", errcount);
+	    debug(1, 0, "Select loop Error. Retry %d\n", errcount);
 	    if (errcount == 10)
 		fatal_dump("Select Loop failed!");
 	    break;
@@ -1,4 +1,4 @@
-/* $Id: neighbors.cc,v 1.22 1996/04/16 18:29:40 wessels Exp $ */
+/* $Id: neighbors.cc,v 1.23 1996/05/01 22:36:35 wessels Exp $ */
 
 /* TODO:
  * - change 'neighbor' to 'sibling'
@@ -104,15 +104,17 @@ void hierarchy_log_append(url, code, timeout, cache_host)
 	}
     } else {
 	if (cache_host) {
-	    fprintf(cache_hierarchy_log, "%d %s %s%s %s\n",
-		(int) squid_curtime,
+	    fprintf(cache_hierarchy_log, "%d.%03d %s %s%s %s\n",
+		(int) current_time.tv_sec,
+		(int) current_time.tv_usec / 1000,
 		url,
 		timeout ? "TIMEOUT_" : "",
 		hier_strings[code],
 		cache_host);
 	} else {
-	    fprintf(cache_hierarchy_log, "%d %s %s%s\n",
-		(int) squid_curtime,
+	    fprintf(cache_hierarchy_log, "%d.%03d %s %s%s\n",
+		(int) current_time.tv_sec,
+		(int) current_time.tv_usec / 1000,
 		url,
 		timeout ? "TIMEOUT_" : "",
 		hier_strings[code]);
@@ -233,22 +235,25 @@ void neighborsDestroy()
 static void neighborsOpenLog(fname)
      char *fname;
 {
-    int log_fd;
-
+    int log_fd = -1;
     /* Close and reopen the log.  It may have been renamed "manually"
      * before HUP'ing us. */
     if (cache_hierarchy_log) {
 	file_close(fileno(cache_hierarchy_log));
 	fclose(cache_hierarchy_log);
+	cache_hierarchy_log = NULL;
     }
-    log_fd = file_open(fname, NULL, O_WRONLY | O_CREAT | O_APPEND);
-    if (log_fd < 0) {
-	debug(15, 0, "rotate_logs: %s: %s\n", fname, xstrerror());
-	debug(15, 1, "Hierachical logging is disabled.\n");
-    } else if ((cache_hierarchy_log = fdopen(log_fd, "a")) == NULL) {
-	debug(15, 0, "rotate_logs: %s: %s\n", fname, xstrerror());
-	debug(15, 1, "Hierachical logging is disabled.\n");
+    if (strcmp(fname, "none") != 0) {
+	log_fd = file_open(fname, NULL, O_WRONLY | O_CREAT | O_APPEND);
+	if (log_fd < 0) {
+	    debug(15, 0, "neighborsOpenLog: %s: %s\n", fname, xstrerror());
+	} else if ((cache_hierarchy_log = fdopen(log_fd, "a")) == NULL) {
+	    file_close(log_fd);
+	    debug(15, 0, "neighborsOpenLog: %s: %s\n", fname, xstrerror());
+	}
     }
+    if (log_fd < 0 || cache_hierarchy_log == NULL)
+	debug(15, 1, "Hierachical logging is disabled.\n");
 }
 
 void neighbors_open(fd)
@@ -1,4 +1,4 @@
-/* $Id: send-announce.cc,v 1.10 1996/04/16 16:35:30 wessels Exp $ */
+/* $Id: send-announce.cc,v 1.11 1996/05/01 22:36:36 wessels Exp $ */
 
 /*
  * DEBUG: Section 27          send-announce
@@ -20,30 +20,32 @@ void send_announce()
     int l;
     int n;
 
-    sndbuf[0] = '\0';
+    host = getAnnounceHost();
+    port = getAnnouncePort();
 
+    if ((hp = ipcache_gethostbyname(host)) == NULL) {
+	debug(27, 1, "send_announce: Unknown host '%s'\n", host);
+	return;
+    }
+    sndbuf[0] = '\0';
     sprintf(tbuf, "cache_version SQUID/%s\n", version_string);
     strcat(sndbuf, tbuf);
     sprintf(tbuf, "Running on %s %d %d\n",
 	getMyHostname(),
 	getAsciiPortNum(),
 	getUdpPortNum());
     strcat(sndbuf, tbuf);
+    if (getAdminEmail()) {
+	sprintf(tbuf, "cache_admin: %s\n", getAdminEmail());
+	strcat(sndbuf, tbuf);
+    }
     sprintf(tbuf, "generated %d [%s]\n",
 	(int) squid_curtime,
 	mkhttpdlogtime(&squid_curtime));
     strcat(sndbuf, tbuf);
     l = strlen(sndbuf);
 
-    host = getAnnounceHost();
-    port = getAnnouncePort();
-
-    if ((hp = ipcache_gethostbyname(host)) == NULL) {
-	debug(27, 1, "send_announce: Unknown host '%s'\n", host);
-	return;
-    }
     if ((file = getAnnounceFile())) {
-	/* XXX could block */
 	fd = file_open(file, NULL, O_RDONLY);
 	if (fd > -1 && (n = read(fd, sndbuf + l, BUFSIZ - l - 1)) > 0) {
 	    l += n;
@@ -1,9 +1,13 @@
 
-/* $Id: squid.h,v 1.19 1996/04/16 05:13:37 wessels Exp $ */
+/* $Id: squid.h,v 1.20 1996/05/01 22:36:37 wessels Exp $ */
 
 #include "config.h"
 #include "autoconf.h"
 
+#if SQUID_FD_SETSIZE > 256
+#define FD_SETSIZE SQUID_FD_SETSIZE
+#endif
+
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -25,10 +29,13 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <sys/stat.h>
-#include <sys/syscall.h>
 #include <sys/un.h>
 #include <sys/wait.h>
 
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
+
 #ifdef HAVE_STRING_H
 #include <string.h>
 #endif
@@ -1,13 +1,13 @@
-/* $Id: stat.cc,v 1.30 1996/04/18 20:28:55 wessels Exp $ */
+/* $Id: stat.cc,v 1.31 1996/05/01 22:36:38 wessels Exp $ */
 
 /*
  * DEBUG: Section 18          stat
  */
 
+
 #include "squid.h"
 
 #ifdef _SQUID_HPUX_
-#include <sys/syscall.h>
 #define getrusage(a, b)  syscall(SYS_GETRUSAGE, a, b)
 #define getpagesize( )   sysconf(_SC_PAGE_SIZE)
 #endif /* _SQUID_HPUX_ */
@@ -53,6 +53,7 @@ void stat_utilization_get(obj, sentry)
 
     storeAppendPrintf(sentry, "{\n");
 
+    strcpy(p->protoname, "TOTAL");
     p->object_count = 0;
     p->kb.max = 0;
     p->kb.min = 0;
@@ -383,26 +384,23 @@ void info_get(obj, sentry)
 
     /* -------------------------------------------------- */
 
-    sprintf(line, "{Connection information for %s:}\n", appname);
-    storeAppend(sentry, line, strlen(line));
-
-    sprintf(line, "{\tNumber of TCP connections:\t%lu}\n", ntcpconn);
-    storeAppend(sentry, line, strlen(line));
-
-    sprintf(line, "{\tNumber of UDP connections:\t%lu}\n", ndupconn);
-    storeAppend(sentry, line, strlen(line));
+    storeAppendPrintf(sentry, "{Connection information for %s:}\n",
+	appname);
+    storeAppendPrintf(sentry, "{\tNumber of TCP connections:\t%lu}\n",
+	ntcpconn);
+    storeAppendPrintf(sentry, "{\tNumber of UDP connections:\t%lu}\n",
+	nudpconn);
 
     {
 	float f;
 	f = squid_curtime - squid_starttime;
-	storeAppendPrintf(sentry, "{\tConnections per hour:\t%.1f}\n", f == 0.0 ? 0.0 :
-	    (nconn / (f / 3600)));
+	storeAppendPrintf(sentry, "{\tConnections per hour:\t%.1f}\n",
+		f == 0.0 ? 0.0 :
+	    ((ntcpconn + nudpconn) / (f / 3600)));
     }
 
     /* -------------------------------------------------- */
 
-
-
     storeAppendPrintf(sentry, "{Cache information for %s:}\n", appname);
 
     storeAppendPrintf(sentry, "{\tStorage Swap size:\t%d MB}\n", storeGetSwapSize() >> 10);
@@ -874,8 +872,7 @@ void stat_init(object, logfilename)
     memcpy(obj->logfilename, logfilename, (int) (strlen(logfilename) + 1) % 256);
     obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
     if (obj->logfile_fd == DISK_ERROR) {
-	debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
-	obj->logfile_status = LOG_DISABLE;
+	debug(18, 0, "%s: %s\n", obj->logfilename, xstrerror());
 	fatal("Cannot open logfile.");
     }
     obj->logfile_access = file_write_lock(obj->logfile_fd);
@@ -888,7 +885,7 @@ void stat_init(object, logfilename)
     obj->proto_miss = proto_miss;
     obj->NotImplement = dummyhandler;
 
-    for (i = 0; i < PROTO_MAX; i++) {
+    for (i = 0; i <= PROTO_MAX; i++) {
 	switch (i) {
 	case PROTO_HTTP:
 	    strcpy(obj->proto_stat_data[i].protoname, "HTTP");
@@ -899,6 +896,9 @@ void stat_init(object, logfilename)
 	case PROTO_FTP:
 	    strcpy(obj->proto_stat_data[i].protoname, "FTP");
 	    break;
+	case PROTO_WAIS:
+	    strcpy(obj->proto_stat_data[i].protoname, "WAIS");
+	    break;
 	case PROTO_CACHEOBJ:
 	    strcpy(obj->proto_stat_data[i].protoname, "CACHE_OBJ");
 	    break;
@@ -934,7 +934,7 @@ char *stat_describe(entry)
     static char state[256];
 
     state[0] = '\0';
-    switch (entry->status) {
+    switch (entry->store_status) {
     case STORE_OK:
 	strncat(state, "STORE-OK", sizeof(state));
 	break;
@@ -1,6 +1,5 @@
 
-/* $Id: store.cc,v 1.62 1996/04/18 20:02:02 wessels Exp $ */
-#ident "$Id: store.cc,v 1.62 1996/04/18 20:02:02 wessels Exp $"
+/* $Id: store.cc,v 1.63 1996/05/01 22:36:39 wessels Exp $ */
 
 /*
  * DEBUG: Section 20          store
@@ -229,7 +228,7 @@ int storeHashDelete(hash_ptr)
 
 /*
  * maintain the in-mem hash table according to the changes of mem_status
- * This routine replaces the instruction "e->status = status;"
+ * This routine replaces the instruction "e->store_status = status;"
  */
 
 void storeSetMemStatus(e, status)
@@ -394,7 +393,7 @@ int storeLockObject(e)
 
     if ((e->mem_status == NOT_IN_MEMORY) &&	/* Not in memory */
 	(e->swap_status != SWAP_OK) &&	/* Not on disk */
-	(e->status != STORE_PENDING)	/* Not being fetched */
+	(e->store_status != STORE_PENDING)	/* Not being fetched */
 	) {
 	debug(20, 0, "storeLockObject: NOT_IN_MEMORY && !SWAP_OK && !STORE_PENDING conflict: <URL:%s>. aborting...\n", e->url);
 	/* If this sanity check fails, we should just ... */
@@ -568,6 +567,7 @@ void storeSetPublicKey(e)
     StoreEntry *e2 = NULL;
     hash_link *table_entry = NULL;
     char *newkey = NULL;
+    int loop_detect = 0;
 
     if (e->key && !BIT_TEST(e->flag, KEY_PRIVATE))
 	return;			/* is already public */
@@ -578,6 +578,9 @@ void storeSetPublicKey(e)
 	e2 = (StoreEntry *) table_entry;
 	storeSetPrivateKey(e2);
 	storeReleaseRequest(e2);
+	if (loop_detect++ == 10)
+	    fatal_dump("storeSetPublicKey() is looping!!");
+	newkey = storeGeneratePublicKey(e->url, e->method);
     }
     if (e->key)
 	storeHashDelete(e);
@@ -617,23 +620,25 @@ StoreEntry *storeCreateEntry(url, req_hdr, flags, method)
 	m->mime_hdr = xstrdup(req_hdr);
     if (BIT_TEST(flags, REQ_NOCACHE))
 	BIT_SET(e->flag, REFRESH_REQUEST);
-    if (BIT_TEST(flags, REQ_PUBLIC)) {
+    if (BIT_TEST(flags, REQ_CACHABLE)) {
 	BIT_SET(e->flag, CACHABLE);
 	BIT_RESET(e->flag, RELEASE_REQUEST);
-	BIT_RESET(e->flag, ENTRY_PRIVATE);
     } else {
 	BIT_RESET(e->flag, CACHABLE);
 	storeReleaseRequest(e);
-	BIT_SET(e->flag, ENTRY_PRIVATE);
     }
-    if (neighbors_do_private_keys || !BIT_TEST(flags, REQ_PUBLIC))
+    if (BIT_TEST(flags, REQ_HIERARCHICAL))
+	BIT_SET(e->flag, HIERARCHICAL);
+    else
+	BIT_RESET(e->flag, HIERARCHICAL);
+    if (neighbors_do_private_keys || !BIT_TEST(flags, REQ_HIERARCHICAL))
 	storeSetPrivateKey(e);
     else
 	storeSetPublicKey(e);
     if (BIT_TEST(flags, REQ_HTML))
 	BIT_SET(e->flag, ENTRY_HTML);
 
-    e->status = STORE_PENDING;
+    e->store_status = STORE_PENDING;
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->swap_status = NO_SWAP;
     e->swap_file_number = -1;
@@ -680,13 +685,12 @@ StoreEntry *storeAddDiskRestore(url, file_number, size, expires, timestamp)
 
     e = new_StoreEntry(WITHOUT_MEMOBJ);
     e->url = xstrdup(url);
-    BIT_RESET(e->flag, ENTRY_PRIVATE);
     e->method = METHOD_GET;
     storeSetPublicKey(e);
     BIT_SET(e->flag, CACHABLE);
     BIT_RESET(e->flag, RELEASE_REQUEST);
     BIT_SET(e->flag, ENTRY_HTML);
-    e->status = STORE_OK;
+    e->store_status = STORE_OK;
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->swap_status = SWAP_OK;
     e->swap_file_number = file_number;
@@ -796,47 +800,46 @@ int storeUnregister(e, fd)
     return freed;
 }
 
+int storeGetLowestReaderOffset(entry)
+     StoreEntry *entry;
+{
+    MemObject *m = entry->mem_obj;
+    int lowest = m->e_current_len;
+    int i;
+    for (i = 0; i < m->client_list_size; i++) {
+	if (m->client_list[i] == NULL)
+	    continue;
+	if (m->client_list[i]->last_offset < lowest)
+	    lowest = m->client_list[i]->last_offset;
+    }
+    return lowest;
+}
+
+
 /* Call to delete behind upto "target lowest offset"
- * also, it update e_lowest_offset.
- */
+ * also, update e_lowest_offset  */
 void storeDeleteBehind(e)
      StoreEntry *e;
 {
+    MemObject *m = e->mem_obj;
     int free_up_to;
     int target_offset;
-    int n_client = 0;
-    int i;
 
     debug(20, 3, "storeDeleteBehind: Object: %s\n", e->key);
-    debug(20, 3, "storeDeleteBehind:\tOriginal Lowest Offset: %d \n", e->mem_obj->e_lowest_offset);
-
-    free_up_to = e->mem_obj->e_lowest_offset;
-    target_offset = 0;
+    debug(20, 3, "storeDeleteBehind: Original Lowest Offset: %d\n",
+	m->e_lowest_offset);
 
-    for (i = 0; i < e->mem_obj->client_list_size; ++i) {
-	if (e->mem_obj->client_list[i] == NULL)
-	    continue;
-	if (((e->mem_obj->client_list[i]->last_offset < target_offset) ||
-		(target_offset == 0))) {
-	    n_client++;
-	    target_offset = e->mem_obj->client_list[i]->last_offset;
-	}
-    }
+    free_up_to = m->e_lowest_offset;
+    target_offset = storeGetLowestReaderOffset(e);
 
-    if (n_client == 0) {
-	debug(20, 3, "storeDeleteBehind:\tThere is no client in the list.\n");
-	debug(20, 3, "\t\tTry to delete as fast as possible.\n");
-	target_offset = e->mem_obj->e_current_len;
-    }
-    debug(20, 3, "storeDeleteBehind:\tThe target offset is : %d\n", target_offset);
+    debug(20, 3, "storeDeleteBehind: target offset: %d\n", target_offset);
     if (target_offset) {
-	free_up_to = (int) e->mem_obj->data->mem_free_data_upto(e->mem_obj->data,
-	    target_offset);
-	debug(20, 3, "                   Object is freed upto : %d\n", free_up_to);
-	store_mem_size -= free_up_to - e->mem_obj->e_lowest_offset;
+	free_up_to = (int) m->data->mem_free_data_upto(m->data, target_offset);
+	debug(20, 3, "--> Object is freed upto : %d\n", free_up_to);
+	store_mem_size -= free_up_to - m->e_lowest_offset;
     }
-    debug(20, 3, "storeDeleteBehind:\tOutgoing Lowest Offset : %d\n", free_up_to);
-    e->mem_obj->e_lowest_offset = free_up_to;
+    debug(20, 3, "storeDeleteBehind: New lowest offset: %d\n", free_up_to);
+    m->e_lowest_offset = free_up_to;
 }
 
 /* Call handlers waiting for  data to be appended to E. */
@@ -918,7 +921,7 @@ void storeAppend(e, data, len)
 	debug(20, 8, "storeAppend: e_current_len = %d\n",
 	    e->mem_obj->e_current_len);
     }
-    if ((e->status != STORE_ABORTED) && !(e->flag & DELAY_SENDING))
+    if ((e->store_status != STORE_ABORTED) && !(e->flag & DELAY_SENDING))
 	InvokeHandlers(e);
 }
 
@@ -1509,9 +1512,7 @@ static int storeCheckSwapable(e)
      StoreEntry *e;
 {
 
-    if (BIT_TEST(e->flag, ENTRY_PRIVATE)) {
-	debug(20, 2, "storeCheckSwapable: NO: private entry\n");
-    } else if (e->expires <= squid_curtime) {
+    if (e->expires <= squid_curtime) {
 	debug(20, 2, "storeCheckSwapable: NO: already expired\n");
     } else if (e->method != METHOD_GET) {
 	debug(20, 2, "storeCheckSwapable: NO: non-GET method\n");
@@ -1540,7 +1541,7 @@ void storeComplete(e)
     e->object_len = e->mem_obj->e_current_len;
     InvokeHandlers(e);
     e->lastref = squid_curtime;
-    e->status = STORE_OK;
+    e->store_status = STORE_OK;
     storeSetMemStatus(e, IN_MEMORY);
     e->swap_status = NO_SWAP;
     if (storeCheckSwapable(e))
@@ -1566,7 +1567,7 @@ int storeAbort(e, msg)
 
     debug(20, 6, "storeAbort: '%s'\n", e->key);
     e->expires = squid_curtime + getNegativeTTL();
-    e->status = STORE_ABORTED;
+    e->store_status = STORE_ABORTED;
     storeSetMemStatus(e, IN_MEMORY);
     /* No DISK swap for negative cached object */
     e->swap_status = NO_SWAP;
@@ -1701,7 +1702,7 @@ int removeOldEntry(e, data)
     debug(20, 6, "removeOldEntry:   *  time-to-live: %8ld\n",
 	e->expires - squid_curtime);
 
-    if ((squid_curtime > e->expires) && (e->status != STORE_PENDING)) {
+    if ((squid_curtime > e->expires) && (e->store_status != STORE_PENDING)) {
 	return (storeRelease(e) == 0 ? 1 : 0);
     }
     return 0;
@@ -1761,7 +1762,7 @@ int storeGetMemSpace(size, check_vm_number)
 
 	n_inmem++;
 
-	if (e->status == STORE_PENDING) {
+	if (e->store_status == STORE_PENDING) {
 	    if (!(e->flag & DELETE_BEHIND)) {
 		/* it's not deleting behind, we can do something about it. */
 		insert_dynamic_array(pending_entry_list, e);
@@ -1778,7 +1779,7 @@ int storeGetMemSpace(size, check_vm_number)
 	if ((e->swap_status == SWAP_OK) && (e->mem_status != SWAPPING_IN) &&
 	    (e->lock_count == 0)) {
 	    insert_dynamic_array(LRU_list, e);
-	} else if (((e->status == STORE_ABORTED) ||
+	} else if (((e->store_status == STORE_ABORTED) ||
 		    (e->swap_status == NO_SWAP)) &&
 	    (e->lock_count == 0)) {
 	    n_aborted++;
@@ -1814,7 +1815,7 @@ int storeGetMemSpace(size, check_vm_number)
 	/* look for vm slot */
 	for (i = 0; (i < LRU_list->index) && (meta_data.hot_vm > store_hotobj_low); ++i) {
 	    if ((LRU = (StoreEntry *) LRU_list->collection[i]))
-		if ((LRU->status != STORE_PENDING) && (LRU->swap_status == NO_SWAP)) {
+		if ((LRU->store_status != STORE_PENDING) && (LRU->swap_status == NO_SWAP)) {
 		    n_released++;
 		    storeRelease(LRU);
 		} else {
@@ -1826,7 +1827,7 @@ int storeGetMemSpace(size, check_vm_number)
 	/* look for space */
 	for (i = 0; (i < LRU_list->index) && ((store_mem_size + size) > store_mem_low); ++i) {
 	    if ((LRU = (StoreEntry *) LRU_list->collection[i]))
-		if ((LRU->status != STORE_PENDING) && (LRU->swap_status == NO_SWAP)) {
+		if ((LRU->store_status != STORE_PENDING) && (LRU->swap_status == NO_SWAP)) {
 		    n_released++;
 		    storeRelease(LRU);
 		} else {
@@ -1997,7 +1998,7 @@ int storeGetSwapSpace(size)
 	    e = (StoreEntry *) link_ptr;
 
 	    /* Identify objects that aren't locked, for replacement */
-	    if ((e->status != STORE_PENDING) &&		/* We're still fetching the object */
+	    if ((e->store_status != STORE_PENDING) &&	/* We're still fetching the object */
 		(e->swap_status == SWAP_OK) &&	/* Only release it if it is on disk */
 		(e->lock_count == 0) &&		/* Be overly cautious */
 		(e->mem_status != SWAPPING_IN)) {	/* Not if it's being faulted into memory */
@@ -2192,7 +2193,7 @@ int storeEntryLocked(e)
 	fatal_dump(NULL);
     }
     return ((e->lock_count) ||
-	(e->status == STORE_PENDING) ||
+	(e->store_status == STORE_PENDING) ||
 	(e->swap_status == SWAPPING_OUT) ||
 	(e->mem_status == SWAPPING_IN)
 	);
@@ -2352,7 +2353,7 @@ int storeEntryValidToSend(e)
 {
     if (squid_curtime < e->expires)
 	return 1;
-    if (e->expires == 0 && e->status == STORE_PENDING)
+    if (e->expires == 0 && e->store_status == STORE_PENDING)
 	return 1;
     return 0;
 }
@@ -2427,7 +2428,7 @@ static int storeVerifySwapDirs(clean)
 	    debug(20, 1, "storeVerifySwapDirs: Created swap directory %s\n", path);
 	    directory_created = 1;
 	}
-	if (clean) {
+	if (clean && opt_unlink_on_reload) {
 	    debug(20, 1, "storeVerifySwapDirs: Zapping all objects on disk storage.\n");
 	    /* This could be dangerous, second copy of cache can destroy
 	     * the existing swap files of the previous cache. We may
@@ -2465,8 +2466,14 @@ int storeInit()
 {
     int dir_created;
     wordlist *w = NULL;
+    char *fname = NULL;
 
-    storelog_fd = file_open(getStoreLogFile(), NULL, O_WRONLY | O_APPEND | O_CREAT);
+    if (strcmp((fname = getStoreLogFile()), "none") == 0)
+	storelog_fd = -1;
+    else
+	storelog_fd = file_open(fname, NULL, O_WRONLY | O_APPEND | O_CREAT);
+    if (storelog_fd < 0)
+	debug(20, 1, "Store logging disabled\n");
 
     for (w = getCacheDirs(); w; w = w->next)
 	storeAddSwapDisk(w->key);
@@ -2721,9 +2728,16 @@ void storeRotateLog()
     static char from[MAXPATHLEN];
     static char to[MAXPATHLEN];
 
+    if (storelog_fd > -1) {
+	file_close(storelog_fd);
+	storelog_fd = -1;
+    }
     if ((fname = getStoreLogFile()) == NULL)
 	return;
 
+    if (strcmp(fname, "none") == 0)
+	return;
+
     debug(20, 1, "storeRotateLog: Rotating.\n");
 
     /* Rotate numbers 0 through N up one */
@@ -2738,7 +2752,9 @@ void storeRotateLog()
 	sprintf(to, "%s.%d", fname, 0);
 	rename(fname, to);
     }
-    if (storelog_fd > -1)
-	file_close(storelog_fd);
-    storelog_fd = file_open(getStoreLogFile(), NULL, O_WRONLY | O_APPEND | O_CREAT);
+    storelog_fd = file_open(fname, NULL, O_WRONLY | O_APPEND | O_CREAT);
+    if (storelog_fd < 0) {
+	debug(20, 0, "storeRotateLog: %s: %s\n", fname, xstrerror());
+	debug(20, 1, "Store logging disabled\n");
+    }
 }
@@ -1,5 +1,5 @@
 
-/* $Id: tools.cc,v 1.41 1996/04/18 20:28:56 wessels Exp $ */
+/* $Id: tools.cc,v 1.42 1996/05/01 22:36:41 wessels Exp $ */
 
 /*
  * DEBUG: Section 21          tools
@@ -19,7 +19,7 @@ The Squid Cache (version %s) died.\n\
 You've encountered a fatal error in the Squid Cache version %s.\n\
 If a core file was created (possibly in the swap directory),\n\
 please execute 'gdb squid core' or 'dbx squid core', then type 'where',\n\
-and report the trace back to squid@nlanr.net.\n\
+and report the trace back to squid-bugs@nlanr.net.\n\
 \n\
 Thanks!\n"
 
@@ -146,16 +146,19 @@ void rotate_logs(sig)
     neighbors_rotate_log();
     stat_rotate_log();
     _db_rotate_log();
-#if defined(_SQUID_SYSV_SIGNALS_)
+#if RESET_SIGNAL_HANDLER
     signal(sig, rotate_logs);
 #endif
 }
 
 void normal_shutdown()
 {
     debug(21, 1, "Shutting down...\n");
-    if (getPidFilename())
+    if (getPidFilename()) {
+	get_suid();
 	safeunlink(getPidFilename(), 0);
+	check_suid();
+    }
     storeWriteCleanLog();
     PrintRusage(NULL, debug_log);
     debug(21, 0, "Squid Cache (Version %s): Exiting normally.\n",
@@ -168,9 +171,11 @@ void shut_down(sig)
     int i;
     int lft = getShutdownLifetime();
     FD_ENTRY *f;
-    debug(21, 1, "Preparing for shutdown after %d connections\n", ntcpconn);
+    debug(21, 1, "Preparing for shutdown after %d connections\n",
+	ntcpconn + nudpconn);
     serverConnectionsClose();
     ipcacheShutdownServers();
+    ftpServerClose();
     for (i = fdstat_biggest_fd(); i >= 0; i--) {
 	f = &fd_table[i];
 	if (f->read_handler || f->write_handler || f->except_handler)
@@ -237,11 +242,12 @@ void sig_child(sig)
     if ((pid = waitpid(-1, &status, WNOHANG)) > 0)
 	debug(21, 3, "sig_child: Ate pid %d\n", pid);
 
-#if defined(_SQUID_SYSV_SIGNALS_)
+#if RESET_SIGNAL_HANDLER
     signal(sig, sig_child);
 #endif
 }
 
+#ifdef OLD_CODE
 /*
  *  getMaxFD - returns the file descriptor table size
  */
@@ -250,9 +256,9 @@ int getMaxFD()
     static int i = -1;
 
     if (i == -1) {
-#if defined(HAVE_SYSCONF) && defined(_SC_OPEN_MAX)
+#if HAVE_SYSCONF && defined(_SC_OPEN_MAX)
 	i = sysconf(_SC_OPEN_MAX);	/* prefered method */
-#elif defined(HAVE_GETDTABLESIZE)
+#elif HAVE_GETDTABLESIZE
 	i = getdtablesize();	/* the BSD way */
 #elif defined(OPEN_MAX)
 	i = OPEN_MAX;
@@ -267,6 +273,12 @@ int getMaxFD()
     }
     return (i);
 }
+#else
+int getMaxFD()
+{
+    return FD_SETSIZE;
+}
+#endif
 
 char *getMyHostname()
 {
@@ -340,17 +352,40 @@ void check_suid()
 	return;
     if ((pwd = getpwnam(getEffectiveUser())) == NULL)
 	return;
-    /* change current directory to swap space so we can get core */
-    if (chdir(swappath(0)) < 0) {
-	debug(21, 0, "%s: %s\n", swappath(0), xstrerror());
-	fatal_dump("Cannot cd to swap directory?");
-    }
     if (getEffectiveGroup() && (grp = getgrnam(getEffectiveGroup()))) {
 	setgid(grp->gr_gid);
     } else {
 	setgid(pwd->pw_gid);
     }
+#if HAVE_SETRESUID
+    setresuid(pwd->pw_uid, pwd->pw_uid, 0);
+#elif HAVE_SETEUID
+    seteuid(pwd->pw_uid);
+#else
     setuid(pwd->pw_uid);
+#endif
+}
+
+void get_suid()
+{
+#if HAVE_SETRESUID
+    setresuid(-1, 0, -1);
+#else
+    setuid(0);
+#endif
+}
+
+void no_suid()
+{
+    uid_t uid;
+    check_suid();
+    uid = geteuid();
+#if HAVE_SETRESUID
+    setresuid(uid, uid, uid);
+#else
+    setuid(0);
+    setuid(uid);
+#endif
 }
 
 void writePidFile()
@@ -372,30 +407,31 @@ void writePidFile()
 
 void setMaxFD()
 {
-#if defined(HAVE_SETRLIMIT)
+#if HAVE_SETRLIMIT
     /* try to use as many file descriptors as possible */
     /* System V uses RLIMIT_NOFILE and BSD uses RLIMIT_OFILE */
     struct rlimit rl;
 #if defined(RLIMIT_NOFILE)
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
-	perror("getrlimit: RLIMIT_NOFILE");
+	debug(21, 0, "setrlimit: RLIMIT_NOFILE: %s", xstrerror());
     } else {
-	rl.rlim_cur = rl.rlim_max;	/* set it to the max */
+	rl.rlim_cur = FD_SETSIZE;
 	if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
-	    perror("setrlimit: RLIMIT_NOFILE");
+	    sprintf(tmp_error_buf, "setrlimit: RLIMIT_NOFILE: %s", xstrerror());
+	    fatal_dump(tmp_error_buf);
 	}
     }
 #elif defined(RLIMIT_OFILE)
     if (getrlimit(RLIMIT_OFILE, &rl) < 0) {
-	perror("getrlimit: RLIMIT_OFILE");
+	debug(21, 0, "setrlimit: RLIMIT_NOFILE: %s", xstrerror());
     } else {
-	rl.rlim_cur = rl.rlim_max;	/* set it to the max */
+	rl.rlim_cur = FD_SETSIZE;
 	if (setrlimit(RLIMIT_OFILE, &rl) < 0) {
-	    perror("setrlimit: RLIMIT_OFILE");
+	    sprintf(tmp_error_buf, "setrlimit: RLIMIT_OFILE: %s", xstrerror());
+	    fatal_dump(tmp_error_buf);
 	}
     }
 #endif
-    debug(21, 1, "setMaxFD: Using %d file descriptors\n", rl.rlim_max);
 #else /* HAVE_SETRLIMIT */
     debug(21, 1, "setMaxFD: Cannot increase: setrlimit() not supported on this system");
 #endif
@@ -417,14 +453,15 @@ void reconfigure(sig)
     debug(21, 1, "reconfigure: SIGHUP received.\n");
     serverConnectionsClose();
     ipcacheShutdownServers();
+    ftpServerClose();
     reread_pending = 1;
     for (i = fdstat_biggest_fd(); i >= 0; i--) {
 	f = &fd_table[i];
 	if (f->read_handler || f->write_handler || f->except_handler)
 	    if (fdstatGetType(i) == Socket)
 		comm_set_fd_lifetime(i, lft);
     }
-#if defined(_SQUID_SYSV_SIGNALS_)
+#if RESET_SIGNAL_HANDLER
     signal(sig, reconfigure);
 #endif
 }
@@ -1,4 +1,4 @@
-/* $Id: url.cc,v 1.19 1996/04/16 18:28:47 wessels Exp $ */
+/* $Id: url.cc,v 1.20 1996/05/01 22:36:42 wessels Exp $ */
 
 /* 
  * DEBUG: Section 23          url
@@ -23,9 +23,6 @@ char *ProtocolStr[] =
     "gopher",
     "wais",
     "cache_object",
-#ifdef NEED_PROTO_CONNECT
-    "connect",
-#endif
     "TOTAL"
 };
 
@@ -130,14 +127,12 @@ protocol_t urlParseProtocol(s)
 #endif
     if (strncasecmp(s, "gopher", 6) == 0)
 	return PROTO_GOPHER;
+    if (strncasecmp(s, "wais", 4) == 0)
+	return PROTO_WAIS;
     if (strncasecmp(s, "cache_object", 12) == 0)
 	return PROTO_CACHEOBJ;
     if (strncasecmp(s, "file", 4) == 0)
 	return PROTO_FTP;
-#ifdef NEED_PROTO_CONNECT
-    if (strncasecmp(s, "connect", 7) == 0)
-	return PROTO_CONNECT;
-#endif
     return PROTO_NONE;
 }
 
@@ -152,12 +147,10 @@ int urlDefaultPort(p)
 	return 21;
     case PROTO_GOPHER:
 	return 70;
+    case PROTO_WAIS:
+	return 210;
     case PROTO_CACHEOBJ:
 	return CACHE_HTTP_PORT;
-#ifdef NEED_PROTO_CONNECT
-    case PROTO_CONNECT:
-	return CONNECT_PORT;
-#endif
     default:
 	return 0;
     }
@@ -180,14 +173,12 @@ request_t *urlParse(method, url)
 	port = CONNECT_PORT;
 	if (sscanf(url, "%[^:]:%d", host, &port) < 1)
 	    return NULL;
-	if (!aclMatchInteger(connect_port_list, port))
-	    return NULL;
     } else {
 	if (sscanf(url, "%[^:]://%[^/]%s", proto, host, urlpath) < 2)
 	    return NULL;
 	protocol = urlParseProtocol(proto);
 	port = urlDefaultPort(protocol);
-	if ((t = strchr(host, ':')) && *(t + 1) != '\0') {
+	if ((t = strrchr(host, ':')) && *(t + 1) != '\0') {
 	    *t = '\0';
 	    port = atoi(t + 1);
 	}
@@ -1,4 +1,4 @@
-/* $Id: wais.cc,v 1.28 1996/04/17 18:06:25 wessels Exp $ */
+/* $Id: wais.cc,v 1.29 1996/05/01 22:36:43 wessels Exp $ */
 
 /*
  * DEBUG: Section 24          wais
@@ -219,7 +219,7 @@ void waisSendRequest(fd, data)
 	30,
 	waisSendComplete,
 	(void *) data);
-    if (!BIT_TEST(data->entry->flag, ENTRY_PRIVATE))
+    if (BIT_TEST(data->entry->flag, CACHABLE))
 	storeSetPublicKey(data->entry);		/* Make it public */
 }
 
@@ -243,15 +243,13 @@ int waisStart(unusedfd, url, method, mime_hdr, entry)
 	squid_error_entry(entry, ERR_NO_RELAY, NULL);
 	return COMM_ERROR;
     }
-
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
 	debug(24, 4, "waisStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	return COMM_ERROR;
     }
-
     data = (WAISData *) xcalloc(1, sizeof(WAISData));
     data->entry = entry;
     data->method = method;