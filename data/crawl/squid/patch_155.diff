@@ -102,7 +102,7 @@
 #endif
 
 ACL::Prototype ACLBrowser::RegistryProtoype(&ACLBrowser::RegistryEntry_, "browser");
-ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_USER_AGENT>::Instance(), "browser");
+ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>::Instance(), "browser");
 ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
 ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&ACLDestinationDomain::LiteralRegistryEntry_, "dstdomain");
 ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain", DestinationDomainFlags);
@@ -144,11 +144,11 @@ ACLStrategised<AnyP::ProtocolType> ACLProtocol::RegistryEntry_(new ACLProtocolDa
 ACL::Prototype ACLRandom::RegistryProtoype(&ACLRandom::RegistryEntry_, "random");
 ACLRandom ACLRandom::RegistryEntry_("random");
 ACL::Prototype ACLReferer::RegistryProtoype(&ACLReferer::RegistryEntry_, "referer_regex");
-ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_REFERER>::Instance(), "referer_regex");
+ACLStrategised<char const *> ACLReferer::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::REFERER>::Instance(), "referer_regex");
 ACL::Prototype ACLReplyMIMEType::RegistryProtoype(&ACLReplyMIMEType::RegistryEntry_, "rep_mime_type");
-ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::Instance(), "rep_mime_type");
+ACLStrategised<char const *> ACLReplyMIMEType::RegistryEntry_(new ACLRegexData, ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "rep_mime_type");
 ACL::Prototype ACLRequestMIMEType::RegistryProtoype(&ACLRequestMIMEType::RegistryEntry_, "req_mime_type");
-ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::Instance(), "req_mime_type");
+ACLStrategised<char const *> ACLRequestMIMEType::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::Instance(), "req_mime_type");
 ACL::Prototype ACLSourceDomain::LiteralRegistryProtoype(&ACLSourceDomain::LiteralRegistryEntry_, "srcdomain");
 ACLStrategised<char const *> ACLSourceDomain::LiteralRegistryEntry_(new ACLDomainData, ACLSourceDomainStrategy::Instance(), "srcdomain");
 ACL::Prototype ACLSourceDomain::RegexRegistryProtoype(&ACLSourceDomain::RegexRegistryEntry_, "srcdom_regex");
@@ -9,6 +9,7 @@
 /* DEBUG: section 65    HTTP Cache Control Header */
 
 #include "squid.h"
+#include "base/LookupTable.h"
 #include "HttpHdrCc.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldStat.h"
@@ -21,75 +22,48 @@
 #include "util.h"
 
 #include <map>
-
-/* a row in the table used for parsing cache control header and statistics */
-class HttpHeaderCcFields
-{
-public:
-    HttpHeaderCcFields() : name(NULL), id(CC_BADHDR), stat() {}
-    HttpHeaderCcFields(const char *aName, http_hdr_cc_type aTypeId) : name(aName), id(aTypeId) {}
-    HttpHeaderCcFields(const HttpHeaderCcFields &f) : name(f.name), id(f.id) {}
-    // nothing to do as name is a pointer to global static string
-    ~HttpHeaderCcFields() {}
-
-    const char *name;
-    http_hdr_cc_type id;
-    HttpHeaderFieldStat stat;
-
-private:
-    HttpHeaderCcFields &operator =(const HttpHeaderCcFields &); // not implemented
-};
-
-/* order must match that of enum http_hdr_cc_type. The constraint is verified at initialization time */
-static HttpHeaderCcFields CcAttrs[CC_ENUM_END] = {
-    HttpHeaderCcFields("public", CC_PUBLIC),
-    HttpHeaderCcFields("private", CC_PRIVATE),
-    HttpHeaderCcFields("no-cache", CC_NO_CACHE),
-    HttpHeaderCcFields("no-store", CC_NO_STORE),
-    HttpHeaderCcFields("no-transform", CC_NO_TRANSFORM),
-    HttpHeaderCcFields("must-revalidate", CC_MUST_REVALIDATE),
-    HttpHeaderCcFields("proxy-revalidate", CC_PROXY_REVALIDATE),
-    HttpHeaderCcFields("max-age", CC_MAX_AGE),
-    HttpHeaderCcFields("s-maxage", CC_S_MAXAGE),
-    HttpHeaderCcFields("max-stale", CC_MAX_STALE),
-    HttpHeaderCcFields("min-fresh", CC_MIN_FRESH),
-    HttpHeaderCcFields("only-if-cached", CC_ONLY_IF_CACHED),
-    HttpHeaderCcFields("stale-if-error", CC_STALE_IF_ERROR),
-    HttpHeaderCcFields("Other,", CC_OTHER) /* ',' will protect from matches */
+#include <vector>
+#include <ostream>
+
+// invariant: row[j].id == j
+static LookupTable<HttpHdrCcType>::Record CcAttrs[] = {
+    {"public", HttpHdrCcType::CC_PUBLIC},
+    {"private", HttpHdrCcType::CC_PRIVATE},
+    {"no-cache", HttpHdrCcType::CC_NO_CACHE},
+    {"no-store", HttpHdrCcType::CC_NO_STORE},
+    {"no-transform", HttpHdrCcType::CC_NO_TRANSFORM},
+    {"must-revalidate", HttpHdrCcType::CC_MUST_REVALIDATE},
+    {"proxy-revalidate", HttpHdrCcType::CC_PROXY_REVALIDATE},
+    {"max-age", HttpHdrCcType::CC_MAX_AGE},
+    {"s-maxage", HttpHdrCcType::CC_S_MAXAGE},
+    {"max-stale", HttpHdrCcType::CC_MAX_STALE},
+    {"min-fresh", HttpHdrCcType::CC_MIN_FRESH},
+    {"only-if-cached", HttpHdrCcType::CC_ONLY_IF_CACHED},
+    {"stale-if-error", HttpHdrCcType::CC_STALE_IF_ERROR},
+    {"Other,", HttpHdrCcType::CC_OTHER}, /* ',' will protect from matches */
+    {nullptr, HttpHdrCcType::CC_ENUM_END}
 };
-
-/// Map an header name to its type, to expedite parsing
-typedef std::map<const SBuf,http_hdr_cc_type> CcNameToIdMap_t;
-static CcNameToIdMap_t CcNameToIdMap;
+LookupTable<HttpHdrCcType> ccLookupTable(HttpHdrCcType::CC_OTHER,CcAttrs);
+std::vector<HttpHeaderFieldStat> ccHeaderStats(HttpHdrCcType::CC_ENUM_END);
 
 /// used to walk a table of http_header_cc_type structs
-http_hdr_cc_type &operator++ (http_hdr_cc_type &aHeader)
+HttpHdrCcType &operator++ (HttpHdrCcType &aHeader)
 {
     int tmp = (int)aHeader;
-    aHeader = (http_hdr_cc_type)(++tmp);
+    aHeader = (HttpHdrCcType)(++tmp);
     return aHeader;
 }
 
 /// Module initialization hook
 void
 httpHdrCcInitModule(void)
 {
-    /* build lookup and accounting structures */
-    for (int32_t i = 0; i < CC_ENUM_END; ++i) {
-        const HttpHeaderCcFields &f=CcAttrs[i];
-        assert(i == f.id); /* verify assumption: the id is the key into the array */
-        const SBuf k(f.name);
-        CcNameToIdMap[k]=f.id;
+    // check invariant on initialization table
+    for (unsigned int j = 0; CcAttrs[j].name != nullptr; ++j) {
+        assert (static_cast<int>(CcAttrs[j].id) == j);
     }
 }
 
-/// Module cleanup hook.
-void
-httpHdrCcCleanModule(void)
-{
-    // HdrCcNameToIdMap is self-cleaning
-}
-
 void
 HttpHdrCc::clear()
 {
@@ -102,7 +76,6 @@ HttpHdrCc::parse(const String & str)
     const char *item;
     const char *p;      /* '=' parameter */
     const char *pos = NULL;
-    http_hdr_cc_type type;
     int ilen;
     int nlen;
 
@@ -119,25 +92,21 @@ HttpHdrCc::parse(const String & str)
         }
 
         /* find type */
-        const CcNameToIdMap_t::const_iterator i=CcNameToIdMap.find(SBuf(item,nlen));
-        if (i==CcNameToIdMap.end())
-            type=CC_OTHER;
-        else
-            type=i->second;
+        const HttpHdrCcType type = ccLookupTable.lookup(SBuf(item,nlen));
 
         // ignore known duplicate directives
         if (isSet(type)) {
-            if (type != CC_OTHER) {
+            if (type != HttpHdrCcType::CC_OTHER) {
                 debugs(65, 2, "hdr cc: ignoring duplicate cache-directive: near '" << item << "' in '" << str << "'");
-                ++CcAttrs[type].stat.repCount;
+                ++ ccHeaderStats[type].repCount;
                 continue;
             }
         }
 
         /* special-case-parsing and attribute-setting */
         switch (type) {
 
-        case CC_MAX_AGE:
+        case HttpHdrCcType::CC_MAX_AGE:
             if (!p || !httpHeaderParseInt(p, &max_age) || max_age < 0) {
                 debugs(65, 2, "cc: invalid max-age specs near '" << item << "'");
                 clearMaxAge();
@@ -146,7 +115,7 @@ HttpHdrCc::parse(const String & str)
             }
             break;
 
-        case CC_S_MAXAGE:
+        case HttpHdrCcType::CC_S_MAXAGE:
             if (!p || !httpHeaderParseInt(p, &s_maxage) || s_maxage < 0) {
                 debugs(65, 2, "cc: invalid s-maxage specs near '" << item << "'");
                 clearSMaxAge();
@@ -155,7 +124,7 @@ HttpHdrCc::parse(const String & str)
             }
             break;
 
-        case CC_MAX_STALE:
+        case HttpHdrCcType::CC_MAX_STALE:
             if (!p || !httpHeaderParseInt(p, &max_stale) || max_stale < 0) {
                 debugs(65, 2, "cc: max-stale directive is valid without value");
                 maxStale(MAX_STALE_ANY);
@@ -164,7 +133,7 @@ HttpHdrCc::parse(const String & str)
             }
             break;
 
-        case CC_MIN_FRESH:
+        case HttpHdrCcType::CC_MIN_FRESH:
             if (!p || !httpHeaderParseInt(p, &min_fresh) || min_fresh < 0) {
                 debugs(65, 2, "cc: invalid min-fresh specs near '" << item << "'");
                 clearMinFresh();
@@ -173,7 +142,7 @@ HttpHdrCc::parse(const String & str)
             }
             break;
 
-        case CC_STALE_IF_ERROR:
+        case HttpHdrCcType::CC_STALE_IF_ERROR:
             if (!p || !httpHeaderParseInt(p, &stale_if_error) || stale_if_error < 0) {
                 debugs(65, 2, "cc: invalid stale-if-error specs near '" << item << "'");
                 clearStaleIfError();
@@ -182,7 +151,7 @@ HttpHdrCc::parse(const String & str)
             }
             break;
 
-        case CC_PRIVATE: {
+        case HttpHdrCcType::CC_PRIVATE: {
             String temp;
             if (!p)  {
                 // Value parameter is optional.
@@ -197,7 +166,7 @@ HttpHdrCc::parse(const String & str)
         }
         break;
 
-        case CC_NO_CACHE: {
+        case HttpHdrCcType::CC_NO_CACHE: {
             String temp;
             if (!p) {
                 // On Requests, missing value parameter is expected syntax.
@@ -215,26 +184,26 @@ HttpHdrCc::parse(const String & str)
         }
         break;
 
-        case CC_PUBLIC:
+        case HttpHdrCcType::CC_PUBLIC:
             Public(true);
             break;
-        case CC_NO_STORE:
+        case HttpHdrCcType::CC_NO_STORE:
             noStore(true);
             break;
-        case CC_NO_TRANSFORM:
+        case HttpHdrCcType::CC_NO_TRANSFORM:
             noTransform(true);
             break;
-        case CC_MUST_REVALIDATE:
+        case HttpHdrCcType::CC_MUST_REVALIDATE:
             mustRevalidate(true);
             break;
-        case CC_PROXY_REVALIDATE:
+        case HttpHdrCcType::CC_PROXY_REVALIDATE:
             proxyRevalidate(true);
             break;
-        case CC_ONLY_IF_CACHED:
+        case HttpHdrCcType::CC_ONLY_IF_CACHED:
             onlyIfCached(true);
             break;
 
-        case CC_OTHER:
+        case HttpHdrCcType::CC_OTHER:
             if (other.size())
                 other.append(", ");
 
@@ -257,31 +226,31 @@ HttpHdrCc::packInto(Packable * p) const
     if (mask==0)
         return;
 
-    http_hdr_cc_type flag;
+    HttpHdrCcType flag;
     int pcount = 0;
     assert(p);
 
-    for (flag = CC_PUBLIC; flag < CC_ENUM_END; ++flag) {
-        if (isSet(flag) && flag != CC_OTHER) {
+    for (flag = HttpHdrCcType::CC_PUBLIC; flag < HttpHdrCcType::CC_ENUM_END; ++flag) {
+        if (isSet(flag) && flag != HttpHdrCcType::CC_OTHER) {
 
             /* print option name for all options */
             p->appendf((pcount ? ", %s": "%s") , CcAttrs[flag].name);
 
             /* for all options having values, "=value" after the name */
             switch (flag) {
-            case CC_MAX_AGE:
+            case HttpHdrCcType::CC_MAX_AGE:
                 p->appendf("=%d", maxAge());
                 break;
-            case CC_S_MAXAGE:
+            case HttpHdrCcType::CC_S_MAXAGE:
                 p->appendf("=%d", sMaxAge());
                 break;
-            case CC_MAX_STALE:
+            case HttpHdrCcType::CC_MAX_STALE:
                 /* max-stale's value is optional.
                   If we didn't receive it, don't send it */
                 if (maxStale()!=MAX_STALE_ANY)
                     p->appendf("=%d", maxStale());
                 break;
-            case CC_MIN_FRESH:
+            case HttpHdrCcType::CC_MIN_FRESH:
                 p->appendf("=%d", minFresh());
                 break;
             default:
@@ -300,10 +269,9 @@ HttpHdrCc::packInto(Packable * p) const
 void
 httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist)
 {
-    http_hdr_cc_type c;
     assert(cc);
 
-    for (c = CC_PUBLIC; c < CC_ENUM_END; ++c)
+    for (HttpHdrCcType c = HttpHdrCcType::CC_PUBLIC; c < HttpHdrCcType::CC_ENUM_END; ++c)
         if (cc->isSet(c))
             hist->count(c);
 }
@@ -312,15 +280,26 @@ void
 httpHdrCcStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     extern const HttpHeaderStat *dump_stat; /* argh! */
-    const int id = (int) val;
-    const int valid_id = id >= 0 && id < CC_ENUM_END;
+    const int id = static_cast<int>(val);
+    const bool valid_id = id < HttpHdrCcType::CC_ENUM_END;
     const char *name = valid_id ? CcAttrs[id].name : "INVALID";
 
     if (count || valid_id)
         storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
                           id, name, count, xdiv(count, dump_stat->ccParsedCount));
 }
 
+std::ostream &
+operator<< (std::ostream &s, HttpHdrCcType c)
+{
+    const unsigned char ic = static_cast<int>(c);
+    if (c >= HttpHdrCcType::CC_PUBLIC && c < HttpHdrCcType::CC_ENUM_END)
+        s << CcAttrs[ic].name << '[' << ic << ']' ;
+    else
+        s << "*invalid hdrcc* [" << ic << ']';
+    return s;
+}
+
 #if !_USE_INLINE_
 #include "HttpHdrCc.cci"
 #endif
@@ -12,14 +12,14 @@
 #include "defines.h"
 
 bool
-HttpHdrCc::isSet(http_hdr_cc_type id) const
+HttpHdrCc::isSet(HttpHdrCcType id) const
 {
-    assert(id>=CC_PUBLIC && id < CC_ENUM_END);
+    assert(id>=HttpHdrCcType::CC_PUBLIC && id < HttpHdrCcType::CC_ENUM_END);
     return EBIT_TEST(mask,id);
 }
 
 void
-HttpHdrCc::setMask(http_hdr_cc_type id, bool newval)
+HttpHdrCc::setMask(HttpHdrCcType id, bool newval)
 {
     if (newval)
         EBIT_SET(mask,id);
@@ -30,7 +30,7 @@ HttpHdrCc::setMask(http_hdr_cc_type id, bool newval)
 /// set a data member to a new value, and set the corresponding mask-bit.
 /// if setting is false, then the mask-bit is cleared.
 void
-HttpHdrCc::setValue(int32_t &value, int32_t new_value, http_hdr_cc_type hdr, bool setting)
+HttpHdrCc::setValue(int32_t &value, int32_t new_value, HttpHdrCcType hdr, bool setting)
 {
     if (setting) {
         if (new_value < 0) {
@@ -9,12 +9,31 @@
 #ifndef SQUID_HTTPHDRCC_H
 #define SQUID_HTTPHDRCC_H
 
-#include "enums.h"
+#include "dlink.h"
 #include "mem/forward.h"
 #include "SquidString.h"
+#include <iosfwd>
 
 class Packable;
 
+enum HttpHdrCcType : unsigned char {
+    CC_PUBLIC = 0,
+    CC_PRIVATE,
+    CC_NO_CACHE,
+    CC_NO_STORE,
+    CC_NO_TRANSFORM,
+    CC_MUST_REVALIDATE,
+    CC_PROXY_REVALIDATE,
+    CC_MAX_AGE,
+    CC_S_MAXAGE,
+    CC_MAX_STALE,
+    CC_MIN_FRESH,
+    CC_ONLY_IF_CACHED,
+    CC_STALE_IF_ERROR,
+    CC_OTHER,
+    CC_ENUM_END /* also used to mean "invalid" */
+};
+
 /** Http Cache-Control header representation
  *
  * Store and parse the Cache-Control HTTP header.
@@ -45,104 +64,104 @@ class HttpHdrCc
     bool parse(const String & s);
 
     //manipulation for Cache-Control: public header
-    bool hasPublic() const {return isSet(CC_PUBLIC);}
-    bool Public() const {return isSet(CC_PUBLIC);}
-    void Public(bool v) {setMask(CC_PUBLIC,v);}
-    void clearPublic() {setMask(CC_PUBLIC,false);}
+    bool hasPublic() const {return isSet(HttpHdrCcType::CC_PUBLIC);}
+    bool Public() const {return isSet(HttpHdrCcType::CC_PUBLIC);}
+    void Public(bool v) {setMask(HttpHdrCcType::CC_PUBLIC,v);}
+    void clearPublic() {setMask(HttpHdrCcType::CC_PUBLIC,false);}
 
     //manipulation for Cache-Control: private header
-    bool hasPrivate() const {return isSet(CC_PRIVATE);}
+    bool hasPrivate() const {return isSet(HttpHdrCcType::CC_PRIVATE);}
     const String &Private() const {return private_;}
     void Private(const String &v) {
-        setMask(CC_PRIVATE,true);
+        setMask(HttpHdrCcType::CC_PRIVATE,true);
         if (!v.size())
             return;
         // uses append for multi-line headers
         if (private_.size() > 0)
             private_.append(",");
         private_.append(v);
     }
-    void clearPrivate() {setMask(CC_PRIVATE,false); private_.clean();}
+    void clearPrivate() {setMask(HttpHdrCcType::CC_PRIVATE,false); private_.clean();}
 
     //manipulation for Cache-Control: no-cache header
-    bool hasNoCache() const {return isSet(CC_NO_CACHE);}
+    bool hasNoCache() const {return isSet(HttpHdrCcType::CC_NO_CACHE);}
     const String &noCache() const {return no_cache;}
     void noCache(const String &v) {
-        setMask(CC_NO_CACHE,true);
+        setMask(HttpHdrCcType::CC_NO_CACHE,true);
         if (!v.size())
             return;
         // uses append for multi-line headers
         if (no_cache.size() > 0 && v.size() > 0)
             no_cache.append(",");
         no_cache.append(v);
     }
-    void clearNoCache() {setMask(CC_NO_CACHE,false); no_cache.clean();}
+    void clearNoCache() {setMask(HttpHdrCcType::CC_NO_CACHE,false); no_cache.clean();}
 
     //manipulation for Cache-Control: no-store header
-    bool hasNoStore() const {return isSet(CC_NO_STORE);}
-    bool noStore() const {return isSet(CC_NO_STORE);}
-    void noStore(bool v) {setMask(CC_NO_STORE,v);}
-    void clearNoStore() {setMask(CC_NO_STORE,false);}
+    bool hasNoStore() const {return isSet(HttpHdrCcType::CC_NO_STORE);}
+    bool noStore() const {return isSet(HttpHdrCcType::CC_NO_STORE);}
+    void noStore(bool v) {setMask(HttpHdrCcType::CC_NO_STORE,v);}
+    void clearNoStore() {setMask(HttpHdrCcType::CC_NO_STORE,false);}
 
     //manipulation for Cache-Control: no-transform header
-    bool hasNoTransform() const {return isSet(CC_NO_TRANSFORM);}
-    bool noTransform() const {return isSet(CC_NO_TRANSFORM);}
-    void noTransform(bool v) {setMask(CC_NO_TRANSFORM,v);}
-    void clearNoTransform() {setMask(CC_NO_TRANSFORM,false);}
+    bool hasNoTransform() const {return isSet(HttpHdrCcType::CC_NO_TRANSFORM);}
+    bool noTransform() const {return isSet(HttpHdrCcType::CC_NO_TRANSFORM);}
+    void noTransform(bool v) {setMask(HttpHdrCcType::CC_NO_TRANSFORM,v);}
+    void clearNoTransform() {setMask(HttpHdrCcType::CC_NO_TRANSFORM,false);}
 
     //manipulation for Cache-Control: must-revalidate header
-    bool hasMustRevalidate() const {return isSet(CC_MUST_REVALIDATE);}
-    bool mustRevalidate() const {return isSet(CC_MUST_REVALIDATE);}
-    void mustRevalidate(bool v) {setMask(CC_MUST_REVALIDATE,v);}
-    void clearMustRevalidate() {setMask(CC_MUST_REVALIDATE,false);}
+    bool hasMustRevalidate() const {return isSet(HttpHdrCcType::CC_MUST_REVALIDATE);}
+    bool mustRevalidate() const {return isSet(HttpHdrCcType::CC_MUST_REVALIDATE);}
+    void mustRevalidate(bool v) {setMask(HttpHdrCcType::CC_MUST_REVALIDATE,v);}
+    void clearMustRevalidate() {setMask(HttpHdrCcType::CC_MUST_REVALIDATE,false);}
 
     //manipulation for Cache-Control: proxy-revalidate header
-    bool hasProxyRevalidate() const {return isSet(CC_PROXY_REVALIDATE);}
-    bool proxyRevalidate() const {return isSet(CC_PROXY_REVALIDATE);}
-    void proxyRevalidate(bool v) {setMask(CC_PROXY_REVALIDATE,v);}
-    void clearProxyRevalidate() {setMask(CC_PROXY_REVALIDATE,false);}
+    bool hasProxyRevalidate() const {return isSet(HttpHdrCcType::CC_PROXY_REVALIDATE);}
+    bool proxyRevalidate() const {return isSet(HttpHdrCcType::CC_PROXY_REVALIDATE);}
+    void proxyRevalidate(bool v) {setMask(HttpHdrCcType::CC_PROXY_REVALIDATE,v);}
+    void clearProxyRevalidate() {setMask(HttpHdrCcType::CC_PROXY_REVALIDATE,false);}
 
     //manipulation for Cache-Control: max-age header
-    bool hasMaxAge() const {return isSet(CC_MAX_AGE);}
+    bool hasMaxAge() const {return isSet(HttpHdrCcType::CC_MAX_AGE);}
     int32_t maxAge() const { return max_age;}
-    void maxAge(int32_t v) {setValue(max_age,v,CC_MAX_AGE); }
-    void clearMaxAge() {setValue(max_age,MAX_AGE_UNKNOWN,CC_MAX_AGE,false);}
+    void maxAge(int32_t v) {setValue(max_age,v,HttpHdrCcType::CC_MAX_AGE); }
+    void clearMaxAge() {setValue(max_age,MAX_AGE_UNKNOWN,HttpHdrCcType::CC_MAX_AGE,false);}
 
     //manipulation for Cache-Control: s-maxage header
-    bool hasSMaxAge() const {return isSet(CC_S_MAXAGE);}
+    bool hasSMaxAge() const {return isSet(HttpHdrCcType::CC_S_MAXAGE);}
     int32_t sMaxAge() const { return s_maxage;}
-    void sMaxAge(int32_t v) {setValue(s_maxage,v,CC_S_MAXAGE); }
-    void clearSMaxAge() {setValue(s_maxage,MAX_AGE_UNKNOWN,CC_S_MAXAGE,false);}
+    void sMaxAge(int32_t v) {setValue(s_maxage,v,HttpHdrCcType::CC_S_MAXAGE); }
+    void clearSMaxAge() {setValue(s_maxage,MAX_AGE_UNKNOWN,HttpHdrCcType::CC_S_MAXAGE,false);}
 
     //manipulation for Cache-Control: max-stale header
-    bool hasMaxStale() const {return isSet(CC_MAX_STALE);}
+    bool hasMaxStale() const {return isSet(HttpHdrCcType::CC_MAX_STALE);}
     int32_t maxStale() const { return max_stale;}
     // max-stale has a special value (MAX_STALE_ANY) which correspond to having
     // the directive without a numeric specification, and directs to consider the object
     // as always-expired.
-    void maxStale(int32_t v) {setValue(max_stale,v,CC_MAX_STALE);}
-    void clearMaxStale() {setValue(max_stale,MAX_STALE_UNKNOWN,CC_MAX_STALE,false);}
+    void maxStale(int32_t v) {setValue(max_stale,v,HttpHdrCcType::CC_MAX_STALE);}
+    void clearMaxStale() {setValue(max_stale,MAX_STALE_UNKNOWN,HttpHdrCcType::CC_MAX_STALE,false);}
 
     //manipulation for Cache-Control:min-fresh header
-    bool hasMinFresh() const {return isSet(CC_MIN_FRESH);}
+    bool hasMinFresh() const {return isSet(HttpHdrCcType::CC_MIN_FRESH);}
     int32_t minFresh() const { return min_fresh;}
-    void minFresh(int32_t v) {if (v < 0) return; setValue(min_fresh,v,CC_MIN_FRESH); }
-    void clearMinFresh() {setValue(min_fresh,MIN_FRESH_UNKNOWN,CC_MIN_FRESH,false);}
+    void minFresh(int32_t v) {if (v < 0) return; setValue(min_fresh,v,HttpHdrCcType::CC_MIN_FRESH); }
+    void clearMinFresh() {setValue(min_fresh,MIN_FRESH_UNKNOWN,HttpHdrCcType::CC_MIN_FRESH,false);}
 
     //manipulation for Cache-Control: only-if-cached header
-    bool hasOnlyIfCached() const {return isSet(CC_ONLY_IF_CACHED);}
-    bool onlyIfCached() const {return isSet(CC_ONLY_IF_CACHED);}
-    void onlyIfCached(bool v) {setMask(CC_ONLY_IF_CACHED,v);}
-    void clearOnlyIfCached() {setMask(CC_ONLY_IF_CACHED,false);}
+    bool hasOnlyIfCached() const {return isSet(HttpHdrCcType::CC_ONLY_IF_CACHED);}
+    bool onlyIfCached() const {return isSet(HttpHdrCcType::CC_ONLY_IF_CACHED);}
+    void onlyIfCached(bool v) {setMask(HttpHdrCcType::CC_ONLY_IF_CACHED,v);}
+    void clearOnlyIfCached() {setMask(HttpHdrCcType::CC_ONLY_IF_CACHED,false);}
 
     //manipulation for Cache-Control: stale-if-error header
-    bool hasStaleIfError() const {return isSet(CC_STALE_IF_ERROR);}
+    bool hasStaleIfError() const {return isSet(HttpHdrCcType::CC_STALE_IF_ERROR);}
     int32_t staleIfError() const { return stale_if_error;}
-    void staleIfError(int32_t v) {setValue(stale_if_error,v,CC_STALE_IF_ERROR); }
-    void clearStaleIfError() {setValue(stale_if_error,STALE_IF_ERROR_UNKNOWN,CC_STALE_IF_ERROR,false);}
+    void staleIfError(int32_t v) {setValue(stale_if_error,v,HttpHdrCcType::CC_STALE_IF_ERROR); }
+    void clearStaleIfError() {setValue(stale_if_error,STALE_IF_ERROR_UNKNOWN,HttpHdrCcType::CC_STALE_IF_ERROR,false);}
 
     /// check whether the attribute value supplied by id is set
-    _SQUID_INLINE_ bool isSet(http_hdr_cc_type id) const;
+    _SQUID_INLINE_ bool isSet(HttpHdrCcType id) const;
 
     void packInto(Packable * p) const;
 
@@ -162,8 +181,8 @@ class HttpHdrCc
     String no_cache; ///< List of headers sent as value for CC:no-cache="...". May be empty/undefined if the value is missing.
 
     /// low-level part of the public set method, performs no checks
-    _SQUID_INLINE_ void setMask(http_hdr_cc_type id, bool newval=true);
-    _SQUID_INLINE_ void setValue(int32_t &value, int32_t new_value, http_hdr_cc_type hdr, bool setting=true);
+    _SQUID_INLINE_ void setMask(HttpHdrCcType id, bool newval=true);
+    _SQUID_INLINE_ void setValue(int32_t &value, int32_t new_value, HttpHdrCcType hdr, bool setting=true);
 
 public:
     /**comma-separated representation of the header values which were
@@ -176,10 +195,12 @@ class StatHist;
 class StoreEntry;
 
 void httpHdrCcInitModule(void);
-void httpHdrCcCleanModule(void);
 void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
 void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
+std::ostream&
+operator<< (std::ostream &, HttpHdrCcType);
+
 #if _USE_INLINE_
 #include "HttpHdrCc.cci"
 #endif
@@ -9,9 +9,10 @@
 /* DEBUG: section 90    HTTP Cache Control Header */
 
 #include "squid.h"
-#include "HttpHdrSc.h"
+#include "base/LookupTable.h"
+//#include "HttpHdrSc.h" // pulled in by HttpHdrScTarget.h
+#include "HttpHdrScTarget.h"
 #include "HttpHeader.h"
-#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
@@ -20,52 +21,36 @@
 #include "util.h"
 
 #include <map>
-
-/* a row in the table used for parsing surrogate-control header and statistics */
-typedef struct {
-    const char *name;
-    http_hdr_sc_type id;
-    HttpHeaderFieldStat stat;
-} HttpHeaderScFields;
+#include <vector>
 
 /* this table is used for parsing surrogate control header */
 /* order must match that of enum http_hdr_sc_type. The constraint is verified at initialization time */
 //todo: implement constraint
-static const HttpHeaderFieldAttrs ScAttrs[SC_ENUM_END] = {
-    HttpHeaderFieldAttrs("no-store", (http_hdr_type)SC_NO_STORE),
-    HttpHeaderFieldAttrs("no-store-remote", (http_hdr_type)SC_NO_STORE_REMOTE),
-    HttpHeaderFieldAttrs("max-age", (http_hdr_type)SC_MAX_AGE),
-    HttpHeaderFieldAttrs("content", (http_hdr_type)SC_CONTENT),
-    HttpHeaderFieldAttrs("Other,", (http_hdr_type)SC_OTHER) /* ',' will protect from matches */
+static const LookupTable<http_hdr_sc_type>::Record ScAttrs[] {
+    {"no-store", SC_NO_STORE},
+    {"no-store-remote", SC_NO_STORE_REMOTE},
+    {"max-age", SC_MAX_AGE},
+    {"content", SC_CONTENT},
+    {"Other,", SC_OTHER}, /* ',' will protect from matches */
+    {nullptr, SC_ENUM_END} /* SC_ENUM_END taken as invalid value */
 };
+LookupTable<http_hdr_sc_type> scLookupTable(SC_ENUM_END, ScAttrs);
+std::vector<HttpHeaderFieldStat> scHeaderStats(SC_ENUM_END);
 
-HttpHeaderFieldInfo *ScFieldsInfo = NULL;
-
+// used when iterating over flags
 http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader)
 {
-    int tmp = (int)aHeader;
-    aHeader = (http_hdr_sc_type)(++tmp);
+    int tmp = static_cast<int>(aHeader);
+    aHeader = static_cast<http_hdr_sc_type>(++tmp);
     return aHeader;
 }
 
-int operator - (http_hdr_sc_type const &anSc, http_hdr_sc_type const &anSc2)
-{
-    return (int)anSc - (int)anSc2;
-}
-
-/* module initialization */
-
 void
 httpHdrScInitModule(void)
 {
-    ScFieldsInfo = httpHeaderBuildFieldsInfo(ScAttrs, SC_ENUM_END);
-}
-
-void
-httpHdrScCleanModule(void)
-{
-    httpHeaderDestroyFieldsInfo(ScFieldsInfo, SC_ENUM_END);
-    ScFieldsInfo = NULL;
+    // check invariant on ScAttrs
+    for (int i = 0; ScAttrs[i].name != nullptr; ++i)
+        assert(i == ScAttrs[i].id);
 }
 
 /* implementation */
@@ -94,7 +79,7 @@ HttpHdrSc::parse(const String * str)
     const char *pos = NULL;
     const char *target = NULL; /* ;foo */
     const char *temp = NULL; /* temp buffer */
-    int type;
+    http_hdr_sc_type type;
     int ilen, vlen;
     int initiallen;
     HttpHdrScTarget *sct;
@@ -120,11 +105,9 @@ HttpHdrSc::parse(const String * str)
         }
 
         /* find type */
-        /* TODO: use a type-safe map-based lookup */
-        type = httpHeaderIdByName(item, ilen,
-                                  ScFieldsInfo, SC_ENUM_END);
+        type = scLookupTable.lookup(SBuf(item,ilen));
 
-        if (type < 0) {
+        if (type == SC_ENUM_END) {
             debugs(90, 2, "hdr sc: unknown control-directive: near '" << item << "' in '" << str << "'");
             type = SC_OTHER;
         }
@@ -147,11 +130,11 @@ HttpHdrSc::parse(const String * str)
 
         safe_free (temp);
 
-        if (sct->isSet(static_cast<http_hdr_sc_type>(type))) {
+        if (sct->isSet(type)) {
             if (type != SC_OTHER)
                 debugs(90, 2, "hdr sc: ignoring duplicate control-directive: near '" << item << "' in '" << str << "'");
 
-            ++ ScFieldsInfo[type].stat.repCount;
+            ++ scHeaderStats[type].repCount;
 
             continue;
         }
@@ -245,8 +228,7 @@ HttpHdrScTarget::packInto(Packable * p) const
         if (isSet(flag) && flag != SC_OTHER) {
 
             /* print option name */
-            p->appendf((pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                       SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
+            p->appendf((pcount ? ", %s" : "%s"), ScAttrs[flag].name);
 
             /* handle options with values */
 
@@ -307,8 +289,8 @@ httpHdrScTargetStatDumper(StoreEntry * sentry, int, double val, double, int coun
 {
     extern const HttpHeaderStat *dump_stat;     /* argh! */
     const int id = (int) val;
-    const int valid_id = id >= 0 && id < SC_ENUM_END;
-    const char *name = valid_id ? ScFieldsInfo[id].name.termedBuf() : "INVALID";
+    const bool valid_id = id >= 0 && id < SC_ENUM_END;
+    const char *name = valid_id ? ScAttrs[id].name : "INVALID";
 
     if (count || valid_id)
         storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
@@ -320,8 +302,8 @@ httpHdrScStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     extern const HttpHeaderStat *dump_stat; /* argh! */
     const int id = (int) val;
-    const int valid_id = id >= 0 && id < SC_ENUM_END;
-    const char *name = valid_id ? ScFieldsInfo[id].name.termedBuf() : "INVALID";
+    const bool valid_id = id >= 0 && id < SC_ENUM_END;
+    const char *name = valid_id ? ScAttrs[id].name : "INVALID";
 
     if (count || valid_id)
         storeAppendPrintf(sentry, "%2d\t %-20s\t %5d\t %6.2f\n",
@@ -369,3 +351,13 @@ HttpHdrSc::getMergedTarget(const char *ourtarget)
     return NULL;
 }
 
+void
+HttpHdrSc::addTarget(HttpHdrScTarget *t) {
+    dlinkAdd(t, &t->node, &targets);
+}
+
+void
+HttpHdrSc::addTargetAtTail(HttpHdrScTarget *t) {
+    dlinkAddTail (t, &t->node, &targets);
+}
+
@@ -9,12 +9,25 @@
 #ifndef SQUID_HTTPHDRSURROGATECONTROL_H
 #define SQUID_HTTPHDRSURROGATECONTROL_H
 
-#include "HttpHdrScTarget.h"
+#include "dlink.h"
+#include "mem/forward.h"
+#include "SquidString.h"
 
+class HttpHdrScTarget;
+class Packable;
 class StatHist;
+class StoreEntry;
 
-/* http surogate control header field */
+typedef enum {
+    SC_NO_STORE,
+    SC_NO_STORE_REMOTE,
+    SC_MAX_AGE,
+    SC_CONTENT,
+    SC_OTHER,
+    SC_ENUM_END /* also used to mean "invalid" */
+} http_hdr_sc_type;
 
+/* http surogate control header field */
 class HttpHdrSc
 {
     MEMPROXY_CLASS(HttpHdrSc);
@@ -29,12 +42,8 @@ class HttpHdrSc
     void updateStats(StatHist *) const;
     HttpHdrScTarget * getMergedTarget (const char *ourtarget); //todo: make const?
     void setMaxAge(char const *target, int max_age);
-    void addTarget(HttpHdrScTarget *t) {
-        dlinkAdd(t, &t->node, &targets);
-    }
-    void addTargetAtTail(HttpHdrScTarget *t) {
-        dlinkAddTail (t, &t->node, &targets);
-    }
+    void addTarget(HttpHdrScTarget *t);
+    void addTargetAtTail(HttpHdrScTarget *t);
 
     dlink_list targets;
 private:
@@ -45,7 +54,6 @@ class HttpHdrSc
 /* Http Surrogate Control Header Field */
 void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 void httpHdrScInitModule (void);
-void httpHdrScCleanModule (void);
 HttpHdrSc *httpHdrScParseCreate(String const &);
 void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
 
@@ -9,7 +9,7 @@
 /* DEBUG: section 90    HTTP Cache Control Header */
 
 #include "squid.h"
-#include "HttpHdrSc.h"
+#include "HttpHdrScTarget.h"
 #include "StatHist.h"
 
 http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader);
@@ -9,11 +9,8 @@
 #ifndef SQUID_HTTPHDRSURROGATECONTROLTARGET_H
 #define SQUID_HTTPHDRSURROGATECONTROLTARGET_H
 
-#include "defines.h"
-#include "dlink.h"
-#include "mem/forward.h"
-#include "SquidString.h"
-#include "typedefs.h"
+#include "defines.h" //for bit mask operations
+#include "HttpHdrSc.h"
 
 class Packable;
 class StatHist;
@@ -9,11 +9,12 @@
 /* DEBUG: section 55    HTTP Header */
 
 #include "squid.h"
+//#include "base/LookupTable.h" // pulled by HttpHdrCc.h
 #include "base64.h"
 #include "globals.h"
 #include "HttpHdrCc.h"
 #include "HttpHdrContRange.h"
-#include "HttpHdrSc.h"
+#include "HttpHdrScTarget.h" // also includes HttpHdrSc.h
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderStat.h"
@@ -23,7 +24,7 @@
 #include "profiler/Profiler.h"
 #include "rfc1123.h"
 #include "SquidConfig.h"
-#include "SquidString.h"
+//#include "SquidString.h" // pulled by HttpHdrCc.h
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
@@ -59,266 +60,160 @@
  * local constants and vars
  */
 
-/*
- * A table with major attributes for every known field.
- * We calculate name lengths and reorganize this array on start up.
- * After reorganization, field id can be used as an index to the table.
- */
-static const HttpHeaderFieldAttrs HeadersAttrs[] = {
-    HttpHeaderFieldAttrs("Accept", HDR_ACCEPT, ftStr),
-
-    HttpHeaderFieldAttrs("Accept-Charset", HDR_ACCEPT_CHARSET, ftStr),
-    HttpHeaderFieldAttrs("Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr),
-    HttpHeaderFieldAttrs("Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr),
-    HttpHeaderFieldAttrs("Accept-Ranges", HDR_ACCEPT_RANGES, ftStr),
-    HttpHeaderFieldAttrs("Age", HDR_AGE, ftInt),
-    HttpHeaderFieldAttrs("Allow", HDR_ALLOW, ftStr),
-    HttpHeaderFieldAttrs("Alternate-Protocol", HDR_ALTERNATE_PROTOCOL, ftStr),
-    HttpHeaderFieldAttrs("Authorization", HDR_AUTHORIZATION, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("Cache-Control", HDR_CACHE_CONTROL, ftPCc),
-    HttpHeaderFieldAttrs("Connection", HDR_CONNECTION, ftStr),
-    HttpHeaderFieldAttrs("Content-Base", HDR_CONTENT_BASE, ftStr),
-    HttpHeaderFieldAttrs("Content-Disposition", HDR_CONTENT_DISPOSITION, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("Content-Encoding", HDR_CONTENT_ENCODING, ftStr),
-    HttpHeaderFieldAttrs("Content-Language", HDR_CONTENT_LANGUAGE, ftStr),
-    HttpHeaderFieldAttrs("Content-Length", HDR_CONTENT_LENGTH, ftInt64),
-    HttpHeaderFieldAttrs("Content-Location", HDR_CONTENT_LOCATION, ftStr),
-    HttpHeaderFieldAttrs("Content-MD5", HDR_CONTENT_MD5, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("Content-Range", HDR_CONTENT_RANGE, ftPContRange),
-    HttpHeaderFieldAttrs("Content-Type", HDR_CONTENT_TYPE, ftStr),
-    HttpHeaderFieldAttrs("Cookie", HDR_COOKIE, ftStr),
-    HttpHeaderFieldAttrs("Cookie2", HDR_COOKIE2, ftStr),
-    HttpHeaderFieldAttrs("Date", HDR_DATE, ftDate_1123),
-    HttpHeaderFieldAttrs("ETag", HDR_ETAG, ftETag),
-    HttpHeaderFieldAttrs("Expect", HDR_EXPECT, ftStr),
-    HttpHeaderFieldAttrs("Expires", HDR_EXPIRES, ftDate_1123),
-    HttpHeaderFieldAttrs("Forwarded", HDR_FORWARDED, ftStr),
-    HttpHeaderFieldAttrs("From", HDR_FROM, ftStr),
-    HttpHeaderFieldAttrs("Host", HDR_HOST, ftStr),
-    HttpHeaderFieldAttrs("HTTP2-Settings", HDR_HTTP2_SETTINGS, ftStr), /* for now */
-    HttpHeaderFieldAttrs("If-Match", HDR_IF_MATCH, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123),
-    HttpHeaderFieldAttrs("If-None-Match", HDR_IF_NONE_MATCH, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag),
-    HttpHeaderFieldAttrs("If-Unmodified-Since", HDR_IF_UNMODIFIED_SINCE, ftDate_1123),
-    HttpHeaderFieldAttrs("Keep-Alive", HDR_KEEP_ALIVE, ftStr),
-    HttpHeaderFieldAttrs("Key", HDR_KEY, ftStr),
-    HttpHeaderFieldAttrs("Last-Modified", HDR_LAST_MODIFIED, ftDate_1123),
-    HttpHeaderFieldAttrs("Link", HDR_LINK, ftStr),
-    HttpHeaderFieldAttrs("Location", HDR_LOCATION, ftStr),
-    HttpHeaderFieldAttrs("Max-Forwards", HDR_MAX_FORWARDS, ftInt64),
-    HttpHeaderFieldAttrs("Mime-Version", HDR_MIME_VERSION, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("Negotiate", HDR_NEGOTIATE, ftStr),
-    HttpHeaderFieldAttrs("Origin", HDR_ORIGIN, ftStr),
-    HttpHeaderFieldAttrs("Pragma", HDR_PRAGMA, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Authenticate", HDR_PROXY_AUTHENTICATE, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Authentication-Info", HDR_PROXY_AUTHENTICATION_INFO, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Authorization", HDR_PROXY_AUTHORIZATION, ftStr),
-    HttpHeaderFieldAttrs("Proxy-Connection", HDR_PROXY_CONNECTION, ftStr),
-    HttpHeaderFieldAttrs("Proxy-support", HDR_PROXY_SUPPORT, ftStr),
-    HttpHeaderFieldAttrs("Public", HDR_PUBLIC, ftStr),
-    HttpHeaderFieldAttrs("Range", HDR_RANGE, ftPRange),
-    HttpHeaderFieldAttrs("Referer", HDR_REFERER, ftStr),
-    HttpHeaderFieldAttrs("Request-Range", HDR_REQUEST_RANGE, ftPRange), /* usually matches HDR_RANGE */
-    HttpHeaderFieldAttrs("Retry-After", HDR_RETRY_AFTER, ftStr),    /* for now (ftDate_1123 or ftInt!) */
-    HttpHeaderFieldAttrs("Server", HDR_SERVER, ftStr),
-    HttpHeaderFieldAttrs("Set-Cookie", HDR_SET_COOKIE, ftStr),
-    HttpHeaderFieldAttrs("Set-Cookie2", HDR_SET_COOKIE2, ftStr),
-    HttpHeaderFieldAttrs("TE", HDR_TE, ftStr),
-    HttpHeaderFieldAttrs("Title", HDR_TITLE, ftStr),
-    HttpHeaderFieldAttrs("Trailer", HDR_TRAILER, ftStr),
-    HttpHeaderFieldAttrs("Transfer-Encoding", HDR_TRANSFER_ENCODING, ftStr),
-    HttpHeaderFieldAttrs("Translate", HDR_TRANSLATE, ftStr),    /* for now. may need to crop */
-    HttpHeaderFieldAttrs("Unless-Modified-Since", HDR_UNLESS_MODIFIED_SINCE, ftStr),  /* for now ignore. may need to crop */
-    HttpHeaderFieldAttrs("Upgrade", HDR_UPGRADE, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("User-Agent", HDR_USER_AGENT, ftStr),
-    HttpHeaderFieldAttrs("Vary", HDR_VARY, ftStr),  /* for now */
-    HttpHeaderFieldAttrs("Via", HDR_VIA, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("Warning", HDR_WARNING, ftStr),    /* for now */
-    HttpHeaderFieldAttrs("WWW-Authenticate", HDR_WWW_AUTHENTICATE, ftStr),
-    HttpHeaderFieldAttrs("Authentication-Info", HDR_AUTHENTICATION_INFO, ftStr),
-    HttpHeaderFieldAttrs("X-Cache", HDR_X_CACHE, ftStr),
-    HttpHeaderFieldAttrs("X-Cache-Lookup", HDR_X_CACHE_LOOKUP, ftStr),
-    HttpHeaderFieldAttrs("X-Forwarded-For", HDR_X_FORWARDED_FOR, ftStr),
-    HttpHeaderFieldAttrs("X-Request-URI", HDR_X_REQUEST_URI, ftStr),
-    HttpHeaderFieldAttrs("X-Squid-Error", HDR_X_SQUID_ERROR, ftStr),
-#if X_ACCELERATOR_VARY
-    HttpHeaderFieldAttrs("X-Accelerator-Vary", HDR_X_ACCELERATOR_VARY, ftStr),
-#endif
-#if USE_ADAPTATION
-    HttpHeaderFieldAttrs("X-Next-Services", HDR_X_NEXT_SERVICES, ftStr),
-#endif
-    HttpHeaderFieldAttrs("Surrogate-Capability", HDR_SURROGATE_CAPABILITY, ftStr),
-    HttpHeaderFieldAttrs("Surrogate-Control", HDR_SURROGATE_CONTROL, ftPSc),
-    HttpHeaderFieldAttrs("Front-End-Https", HDR_FRONT_END_HTTPS, ftStr),
-    HttpHeaderFieldAttrs("FTP-Command", HDR_FTP_COMMAND, ftStr),
-    HttpHeaderFieldAttrs("FTP-Arguments", HDR_FTP_ARGUMENTS, ftStr),
-    HttpHeaderFieldAttrs("FTP-Pre", HDR_FTP_PRE, ftStr),
-    HttpHeaderFieldAttrs("FTP-Status", HDR_FTP_STATUS, ftInt),
-    HttpHeaderFieldAttrs("FTP-Reason", HDR_FTP_REASON, ftStr),
-    HttpHeaderFieldAttrs("Other:", HDR_OTHER, ftStr)    /* ':' will not allow matches */
-};
-
-static HttpHeaderFieldInfo *Headers = NULL;
-
-http_hdr_type &operator++ (http_hdr_type &aHeader)
-{
-    int tmp = (int)aHeader;
-    aHeader = (http_hdr_type)(++tmp);
-    return aHeader;
-}
+// statistics counters for headers. clients must not allow Http::HdrType::BAD_HDR to be counted
+std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::ENUM_END);
 
 /*
  * headers with field values defined as #(values) in HTTP/1.1
  * Headers that are currently not recognized, are commented out.
  */
 static HttpHeaderMask ListHeadersMask;  /* set run-time using  ListHeadersArr */
-static http_hdr_type ListHeadersArr[] = {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET,
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_LANGUAGE,
-    HDR_ACCEPT_RANGES,
-    HDR_ALLOW,
-    HDR_CACHE_CONTROL,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONNECTION,
-    HDR_EXPECT,
-    HDR_IF_MATCH,
-    HDR_IF_NONE_MATCH,
-    HDR_KEY,
-    HDR_LINK,
-    HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_PROXY_SUPPORT,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_VARY,
-    HDR_VIA,
-    HDR_WARNING,
-    HDR_WWW_AUTHENTICATE,
-    HDR_AUTHENTICATION_INFO,
-    HDR_PROXY_AUTHENTICATION_INFO,
-    /* HDR_TE, HDR_TRAILER */
+static Http::HdrType ListHeadersArr[] = {
+    Http::HdrType::ACCEPT,
+    Http::HdrType::ACCEPT_CHARSET,
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_LANGUAGE,
+    Http::HdrType::ACCEPT_RANGES,
+    Http::HdrType::ALLOW,
+    Http::HdrType::CACHE_CONTROL,
+    Http::HdrType::CONTENT_ENCODING,
+    Http::HdrType::CONTENT_LANGUAGE,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::EXPECT,
+    Http::HdrType::IF_MATCH,
+    Http::HdrType::IF_NONE_MATCH,
+    Http::HdrType::KEY,
+    Http::HdrType::LINK,
+    Http::HdrType::PRAGMA,
+    Http::HdrType::PROXY_CONNECTION,
+    Http::HdrType::PROXY_SUPPORT,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    Http::HdrType::VARY,
+    Http::HdrType::VIA,
+    Http::HdrType::WARNING,
+    Http::HdrType::WWW_AUTHENTICATE,
+    Http::HdrType::AUTHENTICATION_INFO,
+    Http::HdrType::PROXY_AUTHENTICATION_INFO,
+    /* Http::HdrType::TE, Http::HdrType::TRAILER */
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+    Http::HdrType::HDR_X_ACCELERATOR_VARY,
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,
+    Http::HdrType::X_NEXT_SERVICES,
 #endif
-    HDR_SURROGATE_CAPABILITY,
-    HDR_SURROGATE_CONTROL,
-    HDR_FORWARDED,
-    HDR_X_FORWARDED_FOR
+    Http::HdrType::SURROGATE_CAPABILITY,
+    Http::HdrType::SURROGATE_CONTROL,
+    Http::HdrType::FORWARDED,
+    Http::HdrType::X_FORWARDED_FOR
 };
 
 /* general-headers */
-static http_hdr_type GeneralHeadersArr[] = {
-    HDR_CACHE_CONTROL,
-    HDR_CONNECTION,
-    HDR_DATE,
-    HDR_FORWARDED,
-    HDR_X_FORWARDED_FOR,
-    HDR_MIME_VERSION,
-    HDR_PRAGMA,
-    HDR_PROXY_CONNECTION,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    /* HDR_TRAILER, */
-    HDR_VIA,
+static Http::HdrType GeneralHeadersArr[] = {
+    Http::HdrType::CACHE_CONTROL,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::DATE,
+    Http::HdrType::FORWARDED,
+    Http::HdrType::X_FORWARDED_FOR,
+    Http::HdrType::MIME_VERSION,
+    Http::HdrType::PRAGMA,
+    Http::HdrType::PROXY_CONNECTION,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    /* Http::HdrType::TRAILER, */
+    Http::HdrType::VIA,
 };
 
 /* entity-headers */
-static http_hdr_type EntityHeadersArr[] = {
-    HDR_ALLOW,
-    HDR_CONTENT_BASE,
-    HDR_CONTENT_ENCODING,
-    HDR_CONTENT_LANGUAGE,
-    HDR_CONTENT_LENGTH,
-    HDR_CONTENT_LOCATION,
-    HDR_CONTENT_MD5,
-    HDR_CONTENT_RANGE,
-    HDR_CONTENT_TYPE,
-    HDR_ETAG,
-    HDR_EXPIRES,
-    HDR_LAST_MODIFIED,
-    HDR_LINK,
-    HDR_OTHER
+static Http::HdrType EntityHeadersArr[] = {
+    Http::HdrType::ALLOW,
+    Http::HdrType::CONTENT_BASE,
+    Http::HdrType::CONTENT_ENCODING,
+    Http::HdrType::CONTENT_LANGUAGE,
+    Http::HdrType::CONTENT_LENGTH,
+    Http::HdrType::CONTENT_LOCATION,
+    Http::HdrType::CONTENT_MD5,
+    Http::HdrType::CONTENT_RANGE,
+    Http::HdrType::CONTENT_TYPE,
+    Http::HdrType::ETAG,
+    Http::HdrType::EXPIRES,
+    Http::HdrType::LAST_MODIFIED,
+    Http::HdrType::LINK,
+    Http::HdrType::OTHER
 };
 
 /* request-only headers */
 static HttpHeaderMask RequestHeadersMask;   /* set run-time using RequestHeaders */
-static http_hdr_type RequestHeadersArr[] = {
-    HDR_ACCEPT,
-    HDR_ACCEPT_CHARSET,
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_LANGUAGE,
-    HDR_AUTHORIZATION,
-    HDR_EXPECT,
-    HDR_FROM,
-    HDR_HOST,
-    HDR_HTTP2_SETTINGS,
-    HDR_IF_MATCH,
-    HDR_IF_MODIFIED_SINCE,
-    HDR_IF_NONE_MATCH,
-    HDR_IF_RANGE,
-    HDR_IF_UNMODIFIED_SINCE,
-    HDR_MAX_FORWARDS,
-    HDR_ORIGIN,
-    HDR_PROXY_AUTHORIZATION,
-    HDR_RANGE,
-    HDR_REFERER,
-    HDR_REQUEST_RANGE,
-    HDR_TE,
-    HDR_USER_AGENT,
-    HDR_SURROGATE_CAPABILITY
+static Http::HdrType RequestHeadersArr[] = {
+    Http::HdrType::ACCEPT,
+    Http::HdrType::ACCEPT_CHARSET,
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_LANGUAGE,
+    Http::HdrType::AUTHORIZATION,
+    Http::HdrType::EXPECT,
+    Http::HdrType::FROM,
+    Http::HdrType::HOST,
+    Http::HdrType::HTTP2_SETTINGS,
+    Http::HdrType::IF_MATCH,
+    Http::HdrType::IF_MODIFIED_SINCE,
+    Http::HdrType::IF_NONE_MATCH,
+    Http::HdrType::IF_RANGE,
+    Http::HdrType::IF_UNMODIFIED_SINCE,
+    Http::HdrType::MAX_FORWARDS,
+    Http::HdrType::ORIGIN,
+    Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::RANGE,
+    Http::HdrType::REFERER,
+    Http::HdrType::REQUEST_RANGE,
+    Http::HdrType::TE,
+    Http::HdrType::USER_AGENT,
+    Http::HdrType::SURROGATE_CAPABILITY
 };
 
 /* reply-only headers */
 static HttpHeaderMask ReplyHeadersMask;     /* set run-time using ReplyHeaders */
-static http_hdr_type ReplyHeadersArr[] = {
-    HDR_ACCEPT_ENCODING,
-    HDR_ACCEPT_RANGES,
-    HDR_AGE,
-    HDR_KEY,
-    HDR_LOCATION,
-    HDR_PROXY_AUTHENTICATE,
-    HDR_PUBLIC,
-    HDR_RETRY_AFTER,
-    HDR_SERVER,
-    HDR_SET_COOKIE,
-    HDR_SET_COOKIE2,
-    HDR_VARY,
-    HDR_WARNING,
-    HDR_WWW_AUTHENTICATE,
-    HDR_X_CACHE,
-    HDR_X_CACHE_LOOKUP,
-    HDR_X_REQUEST_URI,
+static Http::HdrType ReplyHeadersArr[] = {
+    Http::HdrType::ACCEPT_ENCODING,
+    Http::HdrType::ACCEPT_RANGES,
+    Http::HdrType::AGE,
+    Http::HdrType::KEY,
+    Http::HdrType::LOCATION,
+    Http::HdrType::PROXY_AUTHENTICATE,
+    Http::HdrType::PUBLIC,
+    Http::HdrType::RETRY_AFTER,
+    Http::HdrType::SERVER,
+    Http::HdrType::SET_COOKIE,
+    Http::HdrType::SET_COOKIE2,
+    Http::HdrType::VARY,
+    Http::HdrType::WARNING,
+    Http::HdrType::WWW_AUTHENTICATE,
+    Http::HdrType::X_CACHE,
+    Http::HdrType::X_CACHE_LOOKUP,
+    Http::HdrType::X_REQUEST_URI,
 #if X_ACCELERATOR_VARY
-    HDR_X_ACCELERATOR_VARY,
+    Http::HdrType::HDR_X_ACCELERATOR_VARY,
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,
+    Http::HdrType::X_NEXT_SERVICES,
 #endif
-    HDR_X_SQUID_ERROR,
-    HDR_SURROGATE_CONTROL
+    Http::HdrType::X_SQUID_ERROR,
+    Http::HdrType::SURROGATE_CONTROL
 };
 
 /* hop-by-hop headers */
 static HttpHeaderMask HopByHopHeadersMask;
-static http_hdr_type HopByHopHeadersArr[] = {
-    HDR_ALTERNATE_PROTOCOL,
-    HDR_CONNECTION,
-    HDR_HTTP2_SETTINGS,
-    HDR_KEEP_ALIVE,
-    /*HDR_PROXY_AUTHENTICATE, // removal handled specially for peer login */
-    HDR_PROXY_AUTHORIZATION,
-    HDR_TE,
-    HDR_TRAILER,
-    HDR_TRANSFER_ENCODING,
-    HDR_UPGRADE,
-    HDR_PROXY_CONNECTION
+static Http::HdrType HopByHopHeadersArr[] = {
+    Http::HdrType::ALTERNATE_PROTOCOL,
+    Http::HdrType::CONNECTION,
+    Http::HdrType::HTTP2_SETTINGS,
+    Http::HdrType::KEEP_ALIVE,
+    /*Http::HdrType::PROXY_AUTHENTICATE, // removal handled specially for peer login */
+    Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::TE,
+    Http::HdrType::TRAILER,
+    Http::HdrType::TRANSFER_ENCODING,
+    Http::HdrType::UPGRADE,
+    Http::HdrType::PROXY_CONNECTION
 };
 
 /* header accounting */
@@ -344,12 +239,9 @@ static int HeaderEntryParsedCount = 0;
  */
 
 class StoreEntry;
-#define assert_eid(id) assert((id) >= 0 && (id) < HDR_ENUM_END)
-
-static void httpHeaderNoteParsedEntry(http_hdr_type id, String const &value, int error);
 
+static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, int error);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
-
 /** store report about current header usage and other stats */
 static void httpHeaderStoreReport(StoreEntry * e);
 
@@ -369,14 +261,13 @@ void
 httpHeaderInitModule(void)
 {
     /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= HDR_ENUM_END);
-    /* all headers must be described */
-    assert(countof(HeadersAttrs) == HDR_ENUM_END);
+    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::ENUM_END);
 
-    if (!Headers)
-        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
+    // check invariant: for each index in headerTable, (int)headerTable[index] = index
+    for (int i = 0; Http::HeaderTable[i].name; ++i)
+        assert(Http::HeaderTable[i].id == i);
 
-    /* create masks */
+    /* create masks. XXX: migrate to std::vector<bool>? */
     httpHeaderMaskInit(&ListHeadersMask, 0);
     httpHeaderCalcMask(&ListHeadersMask, ListHeadersArr, countof(ListHeadersArr));
 
@@ -403,15 +294,6 @@ httpHeaderInitModule(void)
     httpHeaderRegisterWithCacheManager();
 }
 
-void
-httpHeaderCleanModule(void)
-{
-    httpHeaderDestroyFieldsInfo(Headers, HDR_ENUM_END);
-    Headers = NULL;
-    httpHdrCcCleanModule();
-    httpHdrScCleanModule();
-}
-
 /*
  * HttpHeader Implementation
  */
@@ -480,11 +362,10 @@ HttpHeader::clean()
         HttpHeaderStats[owner].busyDestroyedCount += entries.size() > 0;
     } // if (owner <= hoReply)
 
-    for (std::vector<HttpHeaderEntry *>::iterator i = entries.begin(); i != entries.end(); ++i) {
-        HttpHeaderEntry *e = *i;
-        if (e == NULL)
+    for(HttpHeaderEntry *e : entries) {
+        if (e == nullptr)
             continue;
-        if (e->id < 0 || e->id >= HDR_ENUM_END) {
+        if (!Http::any_valid_header(e->id)) {
             debugs(55, DBG_CRITICAL, "BUG: invalid entry (" << e->id << "). Ignored.");
         } else {
             if (owner <= hoReply)
@@ -531,25 +412,25 @@ HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
     assert(this != fresh);
 
     while ((e = fresh->getEntry(&pos))) {
-        /* deny bad guys (ok to check for HDR_OTHER) here */
+        /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        if (e->id != HDR_OTHER)
+        if (e->id != Http::HdrType::OTHER)
             delById(e->id);
         else
             delByName(e->name.termedBuf());
     }
 
     pos = HttpHeaderInitPos;
     while ((e = fresh->getEntry(&pos))) {
-        /* deny bad guys (ok to check for HDR_OTHER) here */
+        /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        debugs(55, 7, "Updating header '" << HeadersAttrs[e->id].name << "' in cached entry");
+        debugs(55, 7, "Updating header '" << Http::HeaderTable[e->id].name << "' in cached entry");
 
         addEntry(e->clone());
     }
@@ -673,7 +554,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
             return reset();
         }
 
-        if (e->id == HDR_CONTENT_LENGTH && (e2 = findEntry(e->id)) != NULL) {
+        if (e->id == Http::HdrType::CONTENT_LENGTH && (e2 = findEntry(e->id)) != nullptr) {
             if (e->value != e2->value) {
                 int64_t l1, l2;
                 debugs(55, warnOnError, "WARNING: found two conflicting content-length headers in {" <<
@@ -710,7 +591,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
             }
         }
 
-        if (e->id == HDR_OTHER && stringHasWhitespace(e->name.termedBuf())) {
+        if (e->id == Http::HdrType::OTHER && stringHasWhitespace(e->name.termedBuf())) {
             debugs(55, warnOnError, "WARNING: found whitespace in HTTP header name {" <<
                    getStringPrefix(field_start, field_end-field_start) << "}");
 
@@ -726,7 +607,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
 
     if (chunked()) {
         // RFC 2616 section 4.4: ignore Content-Length with Transfer-Encoding
-        delById(HDR_CONTENT_LENGTH);
+        delById(Http::HdrType::CONTENT_LENGTH);
     }
 
     PROF_stop(HttpHeaderParse);
@@ -751,13 +632,13 @@ HttpHeader::packInto(Packable * p, bool mask_sensitive_info) const
 
         bool maskThisEntry = false;
         switch (e->id) {
-        case HDR_AUTHORIZATION:
-        case HDR_PROXY_AUTHORIZATION:
+        case Http::HdrType::AUTHORIZATION:
+        case Http::HdrType::PROXY_AUTHORIZATION:
             maskThisEntry = true;
             break;
 
-        case HDR_FTP_ARGUMENTS:
-            if (const HttpHeaderEntry *cmd = findEntry(HDR_FTP_COMMAND))
+        case Http::HdrType::FTP_ARGUMENTS:
+            if (const HttpHeaderEntry *cmd = findEntry(Http::HdrType::FTP_COMMAND))
                 maskThisEntry = (cmd->value == "PASS");
             break;
 
@@ -798,11 +679,11 @@ HttpHeader::getEntry(HttpHeaderPos * pos) const
  * "list" headers
  */
 HttpHeaderEntry *
-HttpHeader::findEntry(http_hdr_type id) const
+HttpHeader::findEntry(Http::HdrType id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
-    assert_eid(id);
+    assert(any_registered_header(id));
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
@@ -826,12 +707,12 @@ HttpHeader::findEntry(http_hdr_type id) const
  * same as httpHeaderFindEntry
  */
 HttpHeaderEntry *
-HttpHeader::findLastEntry(http_hdr_type id) const
+HttpHeader::findLastEntry(Http::HdrType id) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
     HttpHeaderEntry *result = NULL;
-    assert_eid(id);
+    assert(any_registered_header(id));
     assert(!CBIT_TEST(ListHeadersMask, id));
 
     /* check mask first */
@@ -873,14 +754,13 @@ HttpHeader::delByName(const char *name)
 
 /* deletes all entries with a given id, returns the #entries deleted */
 int
-HttpHeader::delById(http_hdr_type id)
+HttpHeader::delById(Http::HdrType id)
 {
     int count = 0;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
     debugs(55, 8, this << " del-by-id " << id);
-    assert_eid(id);
-    assert(id != HDR_OTHER);        /* does not make sense */
+    assert(any_registered_header(id));
 
     if (!CBIT_TEST(mask, id))
         return 0;
@@ -948,15 +828,18 @@ void
 HttpHeader::addEntry(HttpHeaderEntry * e)
 {
     assert(e);
-    assert_eid(e->id);
+    assert(any_HdrType_enum_value(e->id));
     assert(e->name.size());
 
     debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
-    if (CBIT_TEST(mask, e->id))
-        ++ Headers[e->id].stat.repCount;
-    else
-        CBIT_SET(mask, e->id);
+    if (e->id != Http::HdrType::BAD_HDR) {
+        if (CBIT_TEST(mask, e->id)) {
+            ++ headerStatsTable[e->id].repCount;
+        } else {
+            CBIT_SET(mask, e->id);
+        }
+    }
 
     entries.push_back(e);
 
@@ -971,14 +854,16 @@ void
 HttpHeader::insertEntry(HttpHeaderEntry * e)
 {
     assert(e);
-    assert_eid(e->id);
+    assert(any_valid_header(e->id));
 
     debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
-    if (CBIT_TEST(mask, e->id))
-        ++ Headers[e->id].stat.repCount;
-    else
+    // Http::HdrType::BAD_HDR is filtered out by assert_any_valid_header
+    if (CBIT_TEST(mask, e->id)) {
+        ++ headerStatsTable[e->id].repCount;
+    } else {
         CBIT_SET(mask, e->id);
+    }
 
     entries.insert(entries.begin(),e);
 
@@ -987,7 +872,7 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
 }
 
 bool
-HttpHeader::getList(http_hdr_type id, String *s) const
+HttpHeader::getList(Http::HdrType id, String *s) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -1010,7 +895,7 @@ HttpHeader::getList(http_hdr_type id, String *s) const
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s->size())
-        debugs(55, 3, "empty list header: " << Headers[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -1019,7 +904,7 @@ HttpHeader::getList(http_hdr_type id, String *s) const
 
 /* return a list of entries with the same id separated by ',' and ws */
 String
-HttpHeader::getList(http_hdr_type id) const
+HttpHeader::getList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -1044,7 +929,7 @@ HttpHeader::getList(http_hdr_type id) const
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s.size())
-        debugs(55, 3, "empty list header: " << Headers[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -1053,7 +938,7 @@ HttpHeader::getList(http_hdr_type id) const
 
 /* return a string or list of entries with the same id separated by ',' and ws */
 String
-HttpHeader::getStrOrList(http_hdr_type id) const
+HttpHeader::getStrOrList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
 
@@ -1081,16 +966,16 @@ HttpHeader::getByName(const char *name) const
 bool
 HttpHeader::getByNameIfPresent(const char *name, String &result) const
 {
-    http_hdr_type id;
+    Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry *e;
 
     assert(name);
 
     /* First try the quick path */
-    id = httpHeaderIdByNameDef(name, strlen(name));
+    id = Http::HeaderLookupTable.lookup(SBuf(name));
 
-    if (id != -1) {
+    if (id != Http::HdrType::BAD_HDR) {
         if (!has(id))
             return false;
         result = getStrOrList(id);
@@ -1100,7 +985,7 @@ HttpHeader::getByNameIfPresent(const char *name, String &result) const
     /* Sorry, an unknown header name. Do linear search */
     bool found = false;
     while ((e = getEntry(&pos))) {
-        if (e->id == HDR_OTHER && e->name.caseCmp(name) == 0) {
+        if (e->id == Http::HdrType::OTHER && e->name.caseCmp(name) == 0) {
             found = true;
             strListAdd(&result, e->value.termedBuf(), ',');
         }
@@ -1141,15 +1026,15 @@ HttpHeader::getByNameListMember(const char *name, const char *member, const char
  * returns a the value of the specified list member, if any.
  */
 String
-HttpHeader::getListMember(http_hdr_type id, const char *member, const char separator) const
+HttpHeader::getListMember(Http::HdrType id, const char *member, const char separator) const
 {
     String header;
     const char *pos = NULL;
     const char *item;
     int ilen;
     int mlen = strlen(member);
 
-    assert(id >= 0);
+    assert(any_registered_header(id));
 
     header = getStrOrList(id);
     String result;
@@ -1167,55 +1052,54 @@ HttpHeader::getListMember(http_hdr_type id, const char *member, const char separ
 
 /* test if a field is present */
 int
-HttpHeader::has(http_hdr_type id) const
+HttpHeader::has(Http::HdrType id) const
 {
-    assert_eid(id);
-    assert(id != HDR_OTHER);
+    assert(any_registered_header(id));
     debugs(55, 9, this << " lookup for " << id);
     return CBIT_TEST(mask, id);
 }
 
 void
-HttpHeader::putInt(http_hdr_type id, int number)
+HttpHeader::putInt(Http::HdrType id, int number)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt);  /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xitoa(number)));
 }
 
 void
-HttpHeader::putInt64(http_hdr_type id, int64_t number)
+HttpHeader::putInt64(Http::HdrType id, int64_t number)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt64);    /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xint64toa(number)));
 }
 
 void
-HttpHeader::putTime(http_hdr_type id, time_t htime)
+HttpHeader::putTime(Http::HdrType id, time_t htime)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);    /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
 void
-HttpHeader::insertTime(http_hdr_type id, time_t htime)
+HttpHeader::insertTime(Http::HdrType id, time_t htime)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);    /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     insertEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
 void
-HttpHeader::putStr(http_hdr_type id, const char *str)
+HttpHeader::putStr(Http::HdrType id, const char *str)
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);  /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
     assert(str);
     addEntry(new HttpHeaderEntry(id, NULL, str));
 }
@@ -1224,21 +1108,21 @@ void
 HttpHeader::putAuth(const char *auth_scheme, const char *realm)
 {
     assert(auth_scheme && realm);
-    httpHeaderPutStrf(this, HDR_WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
+    httpHeaderPutStrf(this, Http::HdrType::WWW_AUTHENTICATE, "%s realm=\"%s\"", auth_scheme, realm);
 }
 
 void
 HttpHeader::putCc(const HttpHdrCc * cc)
 {
     assert(cc);
     /* remove old directives if any */
-    delById(HDR_CACHE_CONTROL);
+    delById(Http::HdrType::CACHE_CONTROL);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     cc->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_CACHE_CONTROL, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::CACHE_CONTROL, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1248,13 +1132,13 @@ HttpHeader::putContRange(const HttpHdrContRange * cr)
 {
     assert(cr);
     /* remove old directives if any */
-    delById(HDR_CONTENT_RANGE);
+    delById(Http::HdrType::CONTENT_RANGE);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     httpHdrContRangePackInto(cr, &mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_CONTENT_RANGE, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::CONTENT_RANGE, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1264,13 +1148,13 @@ HttpHeader::putRange(const HttpHdrRange * range)
 {
     assert(range);
     /* remove old directives if any */
-    delById(HDR_RANGE);
+    delById(Http::HdrType::RANGE);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     range->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_RANGE, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::RANGE, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1280,13 +1164,13 @@ HttpHeader::putSc(HttpHdrSc *sc)
 {
     assert(sc);
     /* remove old directives if any */
-    delById(HDR_SURROGATE_CONTROL);
+    delById(Http::HdrType::SURROGATE_CONTROL);
     /* pack into mb */
     MemBuf mb;
     mb.init();
     sc->packInto(&mb);
     /* put */
-    addEntry(new HttpHeaderEntry(HDR_SURROGATE_CONTROL, NULL, mb.buf));
+    addEntry(new HttpHeaderEntry(Http::HdrType::SURROGATE_CONTROL, NULL, mb.buf));
     /* cleanup */
     mb.clean();
 }
@@ -1296,7 +1180,7 @@ HttpHeader::putWarning(const int code, const char *const text)
 {
     char buf[512];
     snprintf(buf, sizeof(buf), "%i %s \"%s\"", code, visible_appname_string, text);
-    putStr(HDR_WARNING, buf);
+    putStr(Http::HdrType::WARNING, buf);
 }
 
 /* add extension header (these fields are not parsed/analyzed/joined, etc.) */
@@ -1305,14 +1189,14 @@ HttpHeader::putExt(const char *name, const char *value)
 {
     assert(name && value);
     debugs(55, 8, this << " adds ext entry " << name << " : " << value);
-    addEntry(new HttpHeaderEntry(HDR_OTHER, name, value));
+    addEntry(new HttpHeaderEntry(Http::HdrType::OTHER, name, value));
 }
 
 int
-HttpHeader::getInt(http_hdr_type id) const
+HttpHeader::getInt(Http::HdrType id) const
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt);  /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1322,10 +1206,10 @@ HttpHeader::getInt(http_hdr_type id) const
 }
 
 int64_t
-HttpHeader::getInt64(http_hdr_type id) const
+HttpHeader::getInt64(Http::HdrType id) const
 {
-    assert_eid(id);
-    assert(Headers[id].type == ftInt64);    /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1335,12 +1219,12 @@ HttpHeader::getInt64(http_hdr_type id) const
 }
 
 time_t
-HttpHeader::getTime(http_hdr_type id) const
+HttpHeader::getTime(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     time_t value = -1;
-    assert_eid(id);
-    assert(Headers[id].type == ftDate_1123);    /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         value = parse_rfc1123(e->value.termedBuf());
@@ -1352,11 +1236,11 @@ HttpHeader::getTime(http_hdr_type id) const
 
 /* sync with httpHeaderGetLastStr */
 const char *
-HttpHeader::getStr(http_hdr_type id) const
+HttpHeader::getStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);  /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
@@ -1368,11 +1252,11 @@ HttpHeader::getStr(http_hdr_type id) const
 
 /* unusual */
 const char *
-HttpHeader::getLastStr(http_hdr_type id) const
+HttpHeader::getLastStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
-    assert_eid(id);
-    assert(Headers[id].type == ftStr);  /* must be of an appropriate type */
+    assert(any_registered_header(id));
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findLastEntry(id))) {
         httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
@@ -1385,12 +1269,12 @@ HttpHeader::getLastStr(http_hdr_type id) const
 HttpHdrCc *
 HttpHeader::getCc() const
 {
-    if (!CBIT_TEST(mask, HDR_CACHE_CONTROL))
+    if (!CBIT_TEST(mask, Http::HdrType::CACHE_CONTROL))
         return NULL;
     PROF_start(HttpHeader_getCc);
 
     String s;
-    getList(HDR_CACHE_CONTROL, &s);
+    getList(Http::HdrType::CACHE_CONTROL, &s);
 
     HttpHdrCc *cc=new HttpHdrCc();
 
@@ -1404,7 +1288,7 @@ HttpHeader::getCc() const
     if (cc)
         httpHdrCcUpdateStats(cc, &HttpHeaderStats[owner].ccTypeDistr);
 
-    httpHeaderNoteParsedEntry(HDR_CACHE_CONTROL, s, !cc);
+    httpHeaderNoteParsedEntry(Http::HdrType::CACHE_CONTROL, s, !cc);
 
     PROF_stop(HttpHeader_getCc);
 
@@ -1421,8 +1305,8 @@ HttpHeader::getRange() const
      * this "if" should work correctly in both cases;
      * hopefully no clients send mismatched headers! */
 
-    if ((e = findEntry(HDR_RANGE)) ||
-            (e = findEntry(HDR_REQUEST_RANGE))) {
+    if ((e = findEntry(Http::HdrType::RANGE)) ||
+            (e = findEntry(Http::HdrType::REQUEST_RANGE))) {
         r = HttpHdrRange::ParseCreate(&e->value);
         httpHeaderNoteParsedEntry(e->id, e->value, !r);
     }
@@ -1433,12 +1317,12 @@ HttpHeader::getRange() const
 HttpHdrSc *
 HttpHeader::getSc() const
 {
-    if (!CBIT_TEST(mask, HDR_SURROGATE_CONTROL))
+    if (!CBIT_TEST(mask, Http::HdrType::SURROGATE_CONTROL))
         return NULL;
 
     String s;
 
-    (void) getList(HDR_SURROGATE_CONTROL, &s);
+    (void) getList(Http::HdrType::SURROGATE_CONTROL, &s);
 
     HttpHdrSc *sc = httpHdrScParseCreate(s);
 
@@ -1447,7 +1331,7 @@ HttpHeader::getSc() const
     if (sc)
         sc->updateStats(&HttpHeaderStats[owner].scTypeDistr);
 
-    httpHeaderNoteParsedEntry(HDR_SURROGATE_CONTROL, s, !sc);
+    httpHeaderNoteParsedEntry(Http::HdrType::SURROGATE_CONTROL, s, !sc);
 
     return sc;
 }
@@ -1458,7 +1342,7 @@ HttpHeader::getContRange() const
     HttpHdrContRange *cr = NULL;
     HttpHeaderEntry *e;
 
-    if ((e = findEntry(HDR_CONTENT_RANGE))) {
+    if ((e = findEntry(Http::HdrType::CONTENT_RANGE))) {
         cr = httpHdrContRangeParseCreate(e->value.termedBuf());
         httpHeaderNoteParsedEntry(e->id, e->value, !cr);
     }
@@ -1467,7 +1351,7 @@ HttpHeader::getContRange() const
 }
 
 const char *
-HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
+HttpHeader::getAuth(Http::HdrType id, const char *auth_scheme) const
 {
     const char *field;
     int l;
@@ -1506,11 +1390,11 @@ HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
 }
 
 ETag
-HttpHeader::getETag(http_hdr_type id) const
+HttpHeader::getETag(Http::HdrType id) const
 {
     ETag etag = {NULL, -1};
     HttpHeaderEntry *e;
-    assert(Headers[id].type == ftETag);     /* must be of an appropriate type */
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
 
     if ((e = findEntry(id)))
         etagParseInit(&etag, e->value.termedBuf());
@@ -1519,11 +1403,11 @@ HttpHeader::getETag(http_hdr_type id) const
 }
 
 TimeOrTag
-HttpHeader::getTimeOrTag(http_hdr_type id) const
+HttpHeader::getTimeOrTag(Http::HdrType id) const
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
-    assert(Headers[id].type == ftDate_1123_or_ETag);    /* must be of an appropriate type */
+    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
 
     if ((e = findEntry(id))) {
@@ -1549,39 +1433,34 @@ HttpHeader::getTimeOrTag(http_hdr_type id) const
  * HttpHeaderEntry
  */
 
-HttpHeaderEntry::HttpHeaderEntry(http_hdr_type anId, const char *aName, const char *aValue)
+HttpHeaderEntry::HttpHeaderEntry(Http::HdrType anId, const char *aName, const char *aValue)
 {
-    assert_eid(anId);
+    assert(any_HdrType_enum_value(anId));
     id = anId;
 
-    if (id != HDR_OTHER)
-        name = Headers[id].name;
+    if (id != Http::HdrType::OTHER)
+        name = Http::HeaderTable[id].name;
     else
         name = aName;
 
     value = aValue;
 
-    ++ Headers[id].stat.aliveCount;
+    if (id != Http::HdrType::BAD_HDR)
+        ++ headerStatsTable[id].aliveCount;
 
     debugs(55, 9, "created HttpHeaderEntry " << this << ": '" << name << " : " << value );
 }
 
 HttpHeaderEntry::~HttpHeaderEntry()
 {
-    assert_eid(id);
     debugs(55, 9, "destroying entry " << this << ": '" << name << ": " << value << "'");
-    /* clean name if needed */
 
-    if (id == HDR_OTHER)
-        name.clean();
-
-    value.clean();
-
-    assert(Headers[id].stat.aliveCount);
-
-    -- Headers[id].stat.aliveCount;
+    if (id != Http::HdrType::BAD_HDR) {
+        assert(headerStatsTable[id].aliveCount);
+        -- headerStatsTable[id].aliveCount;
+        id = Http::HdrType::BAD_HDR; // it already is BAD_HDR, no sense in resetting it
+    }
 
-    id = HDR_BAD_HDR;
 }
 
 /* parses and inits header entry, returns true/false */
@@ -1623,22 +1502,21 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     debugs(55, 9, "parsing HttpHeaderEntry: near '" <<  getStringPrefix(field_start, field_end-field_start) << "'");
 
     /* is it a "known" field? */
-    http_hdr_type id = httpHeaderIdByName(field_start, name_len, Headers, HDR_ENUM_END);
+    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(field_start,name_len));
+    debugs(55, 9, "got hdr-id=" << id);
 
     String name;
 
     String value;
 
-    if (id < 0)
-        id = HDR_OTHER;
-
-    assert_eid(id);
+    if (id == Http::HdrType::BAD_HDR)
+        id = Http::HdrType::OTHER;
 
     /* set field name */
-    if (id == HDR_OTHER)
+    if (id == Http::HdrType::OTHER)
         name.limitInit(field_start, name_len);
     else
-        name = Headers[id].name;
+        name = Http::HeaderTable[id].name;
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
@@ -1651,7 +1529,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
         /* String must be LESS THAN 64K and it adds a terminating NULL */
         debugs(55, DBG_IMPORTANT, "WARNING: ignoring '" << name << "' header of " << (field_end - value_start) << " bytes");
 
-        if (id == HDR_OTHER)
+        if (id == Http::HdrType::OTHER)
             name.clean();
 
         return NULL;
@@ -1660,7 +1538,8 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     /* set field value */
     value.limitInit(value_start, field_end - value_start);
 
-    ++ Headers[id].stat.seenCount;
+    if (id != Http::HdrType::BAD_HDR)
+        ++ headerStatsTable[id].seenCount;
 
     debugs(55, 9, "parsed HttpHeaderEntry: '" << name << ": " << value << "'");
 
@@ -1686,8 +1565,6 @@ HttpHeaderEntry::packInto(Packable * p) const
 int
 HttpHeaderEntry::getInt() const
 {
-    assert_eid (id);
-    assert (Headers[id].type == ftInt);
     int val = -1;
     int ok = httpHeaderParseInt(value.termedBuf(), &val);
     httpHeaderNoteParsedEntry(id, value, !ok);
@@ -1700,8 +1577,6 @@ HttpHeaderEntry::getInt() const
 int64_t
 HttpHeaderEntry::getInt64() const
 {
-    assert_eid (id);
-    assert (Headers[id].type == ftInt64);
     int64_t val = -1;
     int ok = httpHeaderParseOffset(value.termedBuf(), &val);
     httpHeaderNoteParsedEntry(id, value, !ok);
@@ -1712,13 +1587,15 @@ HttpHeaderEntry::getInt64() const
 }
 
 static void
-httpHeaderNoteParsedEntry(http_hdr_type id, String const &context, int error)
+httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, int error)
 {
-    ++ Headers[id].stat.parsCount;
+    if (id != Http::HdrType::BAD_HDR)
+        ++ headerStatsTable[id].parsCount;
 
     if (error) {
-        ++ Headers[id].stat.errCount;
-        debugs(55, 2, "cannot parse hdr field: '" << Headers[id].name << ": " << context << "'");
+        if (id != Http::HdrType::BAD_HDR)
+            ++ headerStatsTable[id].errCount;
+        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderTable[id].name << ": " << context << "'");
     }
 }
 
@@ -1733,9 +1610,9 @@ const HttpHeaderStat *dump_stat = NULL;
 void
 httpHeaderFieldStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
-    const int id = (int) val;
-    const int valid_id = id >= 0 && id < HDR_ENUM_END;
-    const char *name = valid_id ? Headers[id].name.termedBuf() : "INVALID";
+    const int id = static_cast<int>(val);
+    const bool valid_id = Http::any_valid_header(static_cast<Http::HdrType>(id));
+    const char *name = valid_id ? Http::HeaderTable[id].name : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
 
@@ -1759,7 +1636,8 @@ httpHeaderFldsPerHdrDumper(StoreEntry * sentry, int idx, double val, double, int
 static void
 httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
 {
-    assert(hs && e);
+    assert(hs);
+    assert(e);
 
     dump_stat = hs;
     storeAppendPrintf(e, "\nHeader Stats: %s\n", hs->label);
@@ -1787,7 +1665,6 @@ void
 httpHeaderStoreReport(StoreEntry * e)
 {
     int i;
-    http_hdr_type ht;
     assert(e);
 
     HttpHeaderStats[0].parsedCount =
@@ -1809,12 +1686,15 @@ httpHeaderStoreReport(StoreEntry * e)
     storeAppendPrintf(e, "%2s\t %-25s\t %5s\t %6s\t %6s\n",
                       "id", "name", "#alive", "%err", "%repeat");
 
-    for (ht = (http_hdr_type)0; ht < HDR_ENUM_END; ++ht) {
-        HttpHeaderFieldInfo *f = Headers + ht;
+    // scan heaaderTable and output
+    for (int j = 0; Http::HeaderTable[j].name != nullptr; ++j) {
+        auto stats = headerStatsTable[j];
         storeAppendPrintf(e, "%2d\t %-25s\t %5d\t %6.3f\t %6.3f\n",
-                          f->id, f->name.termedBuf(), f->stat.aliveCount,
-                          xpercent(f->stat.errCount, f->stat.parsCount),
-                          xpercent(f->stat.repCount, f->stat.seenCount));
+                          Http::HeaderTable[j].id,
+                          Http::HeaderTable[j].name,
+                          stats.aliveCount,
+                          xpercent(stats.errCount, stats.parsCount),
+                          xpercent(stats.repCount, stats.seenCount));
     }
 
     storeAppendPrintf(e, "Headers Parsed: %d + %d = %d\n",
@@ -1824,52 +1704,16 @@ httpHeaderStoreReport(StoreEntry * e)
     storeAppendPrintf(e, "Hdr Fields Parsed: %d\n", HeaderEntryParsedCount);
 }
 
-http_hdr_type
-httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * info, int end)
-{
-    if (name_len > 0) {
-        for (int i = 0; i < end; ++i) {
-            if (name_len != info[i].name.size())
-                continue;
-
-            if (!strncasecmp(name, info[i].name.rawBuf(), name_len))
-                return info[i].id;
-        }
-    }
-
-    return HDR_BAD_HDR;
-}
-
-http_hdr_type
-httpHeaderIdByNameDef(const char *name, int name_len)
-{
-    if (!Headers)
-        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-
-    return httpHeaderIdByName(name, name_len, Headers, HDR_ENUM_END);
-}
-
-const char *
-httpHeaderNameById(int id)
-{
-    if (!Headers)
-        Headers = httpHeaderBuildFieldsInfo(HeadersAttrs, HDR_ENUM_END);
-
-    assert(id >= 0 && id < HDR_ENUM_END);
-
-    return Headers[id].name.termedBuf();
-}
-
 int
-HttpHeader::hasListMember(http_hdr_type id, const char *member, const char separator) const
+HttpHeader::hasListMember(Http::HdrType id, const char *member, const char separator) const
 {
     int result = 0;
     const char *pos = NULL;
     const char *item;
     int ilen;
     int mlen = strlen(member);
 
-    assert(id >= 0);
+    assert(any_registered_header(id));
 
     String header (getStrOrList(id));
 
@@ -1917,7 +1761,7 @@ HttpHeader::removeHopByHopEntries()
     HttpHeaderPos pos = HttpHeaderInitPos;
     int headers_deleted = 0;
     while ((e = getEntry(&pos))) {
-        int id = e->id;
+        Http::HdrType id = e->id;
         if (CBIT_TEST(HopByHopHeadersMask, id)) {
             delAt(pos, headers_deleted);
             CBIT_CLR(mask, id);
@@ -1928,11 +1772,11 @@ HttpHeader::removeHopByHopEntries()
 void
 HttpHeader::removeConnectionHeaderEntries()
 {
-    if (has(HDR_CONNECTION)) {
+    if (has(Http::HdrType::CONNECTION)) {
         /* anything that matches Connection list member will be deleted */
         String strConnection;
 
-        (void) getList(HDR_CONNECTION, &strConnection);
+        (void) getList(Http::HdrType::CONNECTION, &strConnection);
         const HttpHeaderEntry *e;
         HttpHeaderPos pos = HttpHeaderInitPos;
         /*
@@ -9,6 +9,7 @@
 #ifndef SQUID_HTTPHEADER_H
 #define SQUID_HTTPHEADER_H
 
+#include "base/LookupTable.h"
 #include "http/RegisteredHeaders.h"
 /* because we pass a spec by value */
 #include "HttpHeaderMask.h"
@@ -23,24 +24,8 @@ class HttpHdrContRange;
 class HttpHdrRange;
 class HttpHdrSc;
 class Packable;
-class StoreEntry;
 class SBuf;
 
-/** possible types for http header fields */
-typedef enum {
-    ftInvalid = HDR_ENUM_END,   /**< to catch nasty errors with hdr_id<->fld_type clashes */
-    ftInt,
-    ftInt64,
-    ftStr,
-    ftDate_1123,
-    ftETag,
-    ftPCc,
-    ftPContRange,
-    ftPRange,
-    ftPSc,
-    ftDate_1123_or_ETag
-} field_type;
-
 /** Possible owners of http header */
 typedef enum {
     hoNone =0,
@@ -55,23 +40,6 @@ typedef enum {
     hoEnd
 } http_hdr_owner_type;
 
-class HttpHeaderFieldAttrs
-{
-public:
-    HttpHeaderFieldAttrs() : name(NULL), id(HDR_BAD_HDR), type(ftInvalid) {}
-    HttpHeaderFieldAttrs(const char *aName, http_hdr_type anId, field_type aType = ftInvalid) : name(aName), id(anId), type(aType) {}
-#if __cplusplus >= 201103L
-    HttpHeaderFieldAttrs(const HttpHeaderFieldAttrs &) = default;
-    HttpHeaderFieldAttrs(HttpHeaderFieldAttrs &&) = default;
-#endif
-    // nothing to do as name is a pointer to global const string
-    ~HttpHeaderFieldAttrs() {}
-
-    const char *name;
-    http_hdr_type id;
-    field_type type;
-};
-
 /** Iteration for headers; use HttpHeaderPos as opaque type, do not interpret */
 typedef ssize_t HttpHeaderPos;
 
@@ -83,15 +51,15 @@ class HttpHeaderEntry
     MEMPROXY_CLASS(HttpHeaderEntry);
 
 public:
-    HttpHeaderEntry(http_hdr_type id, const char *name, const char *value);
+    HttpHeaderEntry(Http::HdrType id, const char *name, const char *value);
     ~HttpHeaderEntry();
     static HttpHeaderEntry *parse(const char *field_start, const char *field_end);
     HttpHeaderEntry *clone() const;
     void packInto(Packable *p) const;
     int getInt() const;
     int64_t getInt64() const;
 
-    http_hdr_type id;
+    Http::HdrType id;
     String name;
     String value;
 };
@@ -119,47 +87,47 @@ class HttpHeader
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
-    HttpHeaderEntry *findEntry(http_hdr_type id) const;
+    HttpHeaderEntry *findEntry(Http::HdrType id) const;
     int delByName(const char *name);
-    int delById(http_hdr_type id);
+    int delById(Http::HdrType id);
     void delAt(HttpHeaderPos pos, int &headers_deleted);
     void refreshMask();
     void addEntry(HttpHeaderEntry * e);
     void insertEntry(HttpHeaderEntry * e);
-    String getList(http_hdr_type id) const;
-    bool getList(http_hdr_type id, String *s) const;
-    String getStrOrList(http_hdr_type id) const;
+    String getList(Http::HdrType id) const;
+    bool getList(Http::HdrType id, String *s) const;
+    String getStrOrList(Http::HdrType id) const;
     String getByName(const char *name) const;
     /// sets value and returns true iff a [possibly empty] named field is there
     bool getByNameIfPresent(const char *name, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
-    String getListMember(http_hdr_type id, const char *member, const char separator) const;
-    int has(http_hdr_type id) const;
-    void putInt(http_hdr_type id, int number);
-    void putInt64(http_hdr_type id, int64_t number);
-    void putTime(http_hdr_type id, time_t htime);
-    void insertTime(http_hdr_type id, time_t htime);
-    void putStr(http_hdr_type id, const char *str);
+    String getListMember(Http::HdrType id, const char *member, const char separator) const;
+    int has(Http::HdrType id) const;
+    void putInt(Http::HdrType id, int number);
+    void putInt64(Http::HdrType id, int64_t number);
+    void putTime(Http::HdrType id, time_t htime);
+    void insertTime(Http::HdrType id, time_t htime);
+    void putStr(Http::HdrType id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
     void putContRange(const HttpHdrContRange * cr);
     void putRange(const HttpHdrRange * range);
     void putSc(HttpHdrSc *sc);
     void putWarning(const int code, const char *const text); ///< add a Warning header
     void putExt(const char *name, const char *value);
-    int getInt(http_hdr_type id) const;
-    int64_t getInt64(http_hdr_type id) const;
-    time_t getTime(http_hdr_type id) const;
-    const char *getStr(http_hdr_type id) const;
-    const char *getLastStr(http_hdr_type id) const;
+    int getInt(Http::HdrType id) const;
+    int64_t getInt64(Http::HdrType id) const;
+    time_t getTime(Http::HdrType id) const;
+    const char *getStr(Http::HdrType id) const;
+    const char *getLastStr(Http::HdrType id) const;
     HttpHdrCc *getCc() const;
     HttpHdrRange *getRange() const;
     HttpHdrSc *getSc() const;
     HttpHdrContRange *getContRange() const;
-    const char *getAuth(http_hdr_type id, const char *auth_scheme) const;
-    ETag getETag(http_hdr_type id) const;
-    TimeOrTag getTimeOrTag(http_hdr_type id) const;
-    int hasListMember(http_hdr_type id, const char *member, const char separator) const;
+    const char *getAuth(Http::HdrType id, const char *auth_scheme) const;
+    ETag getETag(Http::HdrType id) const;
+    TimeOrTag getTimeOrTag(Http::HdrType id) const;
+    int hasListMember(Http::HdrType id, const char *member, const char separator) const;
     int hasByNameListMember(const char *name, const char *member, const char separator) const;
     void removeHopByHopEntries();
     inline bool chunked() const; ///< whether message uses chunked Transfer-Encoding
@@ -175,7 +143,7 @@ class HttpHeader
     void removeConnectionHeaderEntries();
 
 private:
-    HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
+    HttpHeaderEntry *findLastEntry(Http::HdrType id) const;
 };
 
 int httpHeaderParseQuotedString(const char *start, const int len, String *val);
@@ -185,17 +153,16 @@ SBuf httpHeaderQuoteString(const char *raw);
 
 int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
 void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
-void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
+void httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
 {
-    return has(HDR_TRANSFER_ENCODING) &&
-           hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
+    return has(Http::HdrType::TRANSFER_ENCODING) &&
+           hasListMember(Http::HdrType::TRANSFER_ENCODING, "chunked", ',');
 }
 
 void httpHeaderInitModule(void);
-void httpHeaderCleanModule(void);
 
 #endif /* SQUID_HTTPHEADER_H */
 
@@ -9,18 +9,19 @@
 #ifndef SQUID_HTTPHEADERFIELDINFO_H_
 #define SQUID_HTTPHEADERFIELDINFO_H_
 
+#include "http/RegisteredHeaders.h"
 #include "HttpHeaderFieldStat.h"
 #include "SquidString.h"
 
 /// compiled version of HttpHeaderFieldAttrs plus stats. Currently a POD.
 class HttpHeaderFieldInfo
 {
 public:
-    HttpHeaderFieldInfo() : id(HDR_ACCEPT), type(ftInvalid) {}
+    HttpHeaderFieldInfo() : id(Http::HdrType::ACCEPT), type(Http::HdrFieldType::ftInvalid) {}
 
-    http_hdr_type id;
+    Http::HdrType id;
     String name;
-    field_type type;
+    Http::HdrFieldType type;
     HttpHeaderFieldStat stat;
 };
 
@@ -9,6 +9,8 @@
 #ifndef HTTPHEADERSTAT_H_
 #define HTTPHEADERSTAT_H_
 
+#include "HttpHdrCc.h"
+#include "HttpHdrSc.h"
 #include "StatHist.h"
 
 /// HTTP per header statistics
@@ -25,8 +27,8 @@ class HttpHeaderStat
         busyDestroyedCount(0)
     {
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(HDR_ENUM_END);
-        ccTypeDistr.enumInit(CC_ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
 
@@ -41,8 +43,8 @@ class HttpHeaderStat
     {
         assert(label);
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(HDR_ENUM_END);
-        ccTypeDistr.enumInit(CC_ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
 
@@ -18,6 +18,7 @@
 #include "ConfigParser.h"
 #include "fde.h"
 #include "globals.h"
+#include "http/RegisteredHeaders.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
@@ -36,45 +37,7 @@
 #include <cerrno>
 #include <string>
 
-static void httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs);
-
-HttpHeaderFieldInfo *
-httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count)
-{
-    int i;
-    HttpHeaderFieldInfo *table = NULL;
-    assert(attrs && count);
-
-    /* allocate space */
-    table = new HttpHeaderFieldInfo[count];
-
-    for (i = 0; i < count; ++i) {
-        const http_hdr_type id = attrs[i].id;
-        HttpHeaderFieldInfo *info = table + id;
-        /* sanity checks */
-        assert(id >= 0 && id < count);
-        assert(attrs[i].name);
-        assert(info->id == HDR_ACCEPT && info->type == ftInvalid);  /* was not set before */
-        /* copy and init fields */
-        info->id = id;
-        info->type = attrs[i].type;
-        info->name = attrs[i].name;
-        assert(info->name.size());
-    }
-
-    return table;
-}
-
-void
-httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * table, int count)
-{
-    int i;
-
-    for (i = 0; i < count; ++i)
-        table[i].name.clean();
-
-    delete [] table;
-}
+static void httpHeaderPutStrvf(HttpHeader * hdr, Http::HdrType id, const char *fmt, va_list vargs);
 
 void
 httpHeaderMaskInit(HttpHeaderMask * mask, int value)
@@ -84,7 +47,7 @@ httpHeaderMaskInit(HttpHeaderMask * mask, int value)
 
 /** calculates a bit mask of a given array; does not reset mask! */
 void
-httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count)
+httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count)
 {
     size_t i;
     const int * enums = (const int *) http_hdr_type_enums;
@@ -99,7 +62,7 @@ httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], s
 
 /* same as httpHeaderPutStr, but formats the string using snprintf first */
 void
-httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...)
+httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
@@ -110,7 +73,7 @@ httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...)
 
 /* used by httpHeaderPutStrf */
 static void
-httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs)
+httpHeaderPutStrvf(HttpHeader * hdr, Http::HdrType id, const char *fmt, va_list vargs)
 {
     MemBuf mb;
     mb.init();
@@ -132,8 +95,8 @@ httpHeaderAddContRange(HttpHeader * hdr, HttpHdrRangeSpec spec, int64_t ent_len)
 
 /**
  * return true if a given directive is found in at least one of
- * the "connection" header-fields note: if HDR_PROXY_CONNECTION is
- * present we ignore HDR_CONNECTION.
+ * the "connection" header-fields note: if Http::HdrType::PROXY_CONNECTION is
+ * present we ignore Http::HdrType::CONNECTION.
  */
 int
 httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
@@ -143,12 +106,12 @@ httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
     /* what type of header do we have? */
 
 #if USE_HTTP_VIOLATIONS
-    if (hdr->has(HDR_PROXY_CONNECTION))
-        list = hdr->getList(HDR_PROXY_CONNECTION);
+    if (hdr->has(Http::HdrType::PROXY_CONNECTION))
+        list = hdr->getList(Http::HdrType::PROXY_CONNECTION);
     else
 #endif
-        if (hdr->has(HDR_CONNECTION))
-            list = hdr->getList(HDR_CONNECTION);
+        if (hdr->has(Http::HdrType::CONNECTION))
+            list = hdr->getList(Http::HdrType::CONNECTION);
         else
             return 0;
 
@@ -411,7 +374,7 @@ HeaderManglers::HeaderManglers()
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i)
+    for (int i = 0; i < Http::HdrType::ENUM_END; ++i)
         header_mangler_clean(known[i]);
 
     typedef ManglersByName::iterator MBNI;
@@ -424,9 +387,8 @@ HeaderManglers::~HeaderManglers()
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i) {
-        header_mangler_dump_access(entry, name, known[i],
-                                   httpHeaderNameById(i));
+    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
+        header_mangler_dump_access(entry, name, known[i], Http::HeaderTable[i].name);
     }
 
     typedef ManglersByName::const_iterator MBNCI;
@@ -439,9 +401,8 @@ HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; ++i) {
-        header_mangler_dump_replacement(entry, name, known[i],
-                                        httpHeaderNameById(i));
+    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
+        header_mangler_dump_replacement(entry, name, known[i],Http::HeaderTable[i].name);
     }
 
     typedef ManglersByName::const_iterator MBNCI;
@@ -456,22 +417,22 @@ HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 headerMangler *
 HeaderManglers::track(const char *name)
 {
-    int id = httpHeaderIdByNameDef(name, strlen(name));
+    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name));
 
-    if (id == HDR_BAD_HDR) { // special keyword or a custom header
+    if (id == Http::HdrType::BAD_HDR) { // special keyword or a custom header
         if (strcmp(name, "All") == 0)
-            id = HDR_ENUM_END;
+            id = Http::HdrType::ENUM_END;
         else if (strcmp(name, "Other") == 0)
-            id = HDR_OTHER;
+            id = Http::HdrType::OTHER;
     }
 
     headerMangler *m = NULL;
-    if (id == HDR_ENUM_END) {
+    if (id == Http::HdrType::ENUM_END) {
         m = &all;
-    } else if (id == HDR_BAD_HDR) {
+    } else if (id == Http::HdrType::BAD_HDR) {
         m = &custom[name];
     } else {
-        m = &known[id]; // including HDR_OTHER
+        m = &known[id]; // including Http::HdrType::OTHER
     }
 
     assert(m);
@@ -493,12 +454,12 @@ const headerMangler *
 HeaderManglers::find(const HttpHeaderEntry &e) const
 {
     // a known header with a configured ACL list
-    if (e.id != HDR_OTHER && 0 <= e.id && e.id < HDR_ENUM_END &&
+    if (e.id != Http::HdrType::OTHER && Http::any_HdrType_enum_value(e.id) &&
             known[e.id].access_list)
         return &known[e.id];
 
     // a custom header
-    if (e.id == HDR_OTHER) {
+    if (e.id == Http::HdrType::OTHER) {
         // does it have an ACL list configured?
         // Optimize: use a name type that we do not need to convert to here
         const ManglersByName::const_iterator i = custom.find(e.name.termedBuf());
@@ -507,8 +468,8 @@ HeaderManglers::find(const HttpHeaderEntry &e) const
     }
 
     // Next-to-last resort: "Other" rules match any custom header
-    if (e.id == HDR_OTHER && known[HDR_OTHER].access_list)
-        return &known[HDR_OTHER];
+    if (e.id == Http::HdrType::OTHER && known[Http::HdrType::OTHER].access_list)
+        return &known[Http::HdrType::OTHER];
 
     // Last resort: "All" rules match any header
     if (all.access_list)
@@ -24,7 +24,6 @@
 
 class HeaderWithAcl;
 class HttpHeader;
-class HttpHeaderFieldInfo;
 class HttpRequest;
 class StoreEntry;
 class String;
@@ -75,7 +74,7 @@ class HeaderManglers
     typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
-    headerMangler known[HDR_ENUM_END];
+    headerMangler known[static_cast<int>(Http::HdrType::ENUM_END)];
 
     /// one mangler for each custom header
     ManglersByName custom;
@@ -92,7 +91,7 @@ class HeaderManglers
 class HeaderWithAcl
 {
 public:
-    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(HDR_BAD_HDR), quoted(false) {}
+    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(Http::HdrType::BAD_HDR), quoted(false) {}
 
     /// HTTP header field name
     std::string fieldName;
@@ -107,22 +106,17 @@ class HeaderWithAcl
     Format::Format *valueFormat;
 
     /// internal ID for "known" headers or HDR_OTHER
-    http_hdr_type fieldId;
+    Http::HdrType fieldId;
 
     /// whether fieldValue may contain macros
     bool quoted;
 };
 
 int httpHeaderParseOffset(const char *start, int64_t * off);
 
-HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
-void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
-http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
-http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
-const char *httpHeaderNameById(int id);
 int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
 int httpHeaderParseInt(const char *start, int *val);
-void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
+void httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...) PRINTF_FORMAT_ARG3;
 
 const char *getStringPrefix(const char *str, size_t len);
 
@@ -292,8 +292,8 @@ HttpMsg::httpMsgParseError()
 void
 HttpMsg::setContentLength(int64_t clen)
 {
-    header.delById(HDR_CONTENT_LENGTH); // if any
-    header.putInt64(HDR_CONTENT_LENGTH, clen);
+    header.delById(Http::HdrType::CONTENT_LENGTH); // if any
+    header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     content_length = clen;
 }
 
@@ -321,7 +321,7 @@ void HttpMsg::packInto(Packable *p, bool full_uri) const
 
 void HttpMsg::hdrCacheInit()
 {
-    content_length = header.getInt64(HDR_CONTENT_LENGTH);
+    content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
     assert(NULL == cache_control);
     cache_control = header.getCc();
 }
@@ -40,13 +40,13 @@
  *     all entity-headers except Expires and Content-Location
  */
 static HttpHeaderMask Denied304HeadersMask;
-static http_hdr_type Denied304HeadersArr[] = {
+static Http::HdrType Denied304HeadersArr[] = {
     // hop-by-hop headers
-    HDR_CONNECTION, HDR_KEEP_ALIVE, HDR_PROXY_AUTHENTICATE, HDR_PROXY_AUTHORIZATION,
-    HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE,
+    Http::HdrType::CONNECTION, Http::HdrType::KEEP_ALIVE, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrType::PROXY_AUTHORIZATION,
+    Http::HdrType::TE, Http::HdrType::TRAILER, Http::HdrType::TRANSFER_ENCODING, Http::HdrType::UPGRADE,
     // entity headers
-    HDR_ALLOW, HDR_CONTENT_ENCODING, HDR_CONTENT_LANGUAGE, HDR_CONTENT_LENGTH,
-    HDR_CONTENT_MD5, HDR_CONTENT_RANGE, HDR_CONTENT_TYPE, HDR_LAST_MODIFIED
+    Http::HdrType::ALLOW, Http::HdrType::CONTENT_ENCODING, Http::HdrType::CONTENT_LANGUAGE, Http::HdrType::CONTENT_LENGTH,
+    Http::HdrType::CONTENT_MD5, Http::HdrType::CONTENT_RANGE, Http::HdrType::CONTENT_TYPE, Http::HdrType::LAST_MODIFIED
 };
 
 /* module initialization */
@@ -135,7 +135,7 @@ HttpReply::pack()
 HttpReply *
 HttpReply::make304() const
 {
-    static const http_hdr_type ImsEntries[] = {HDR_DATE, HDR_CONTENT_TYPE, HDR_EXPIRES, HDR_LAST_MODIFIED, /* eof */ HDR_OTHER};
+    static const Http::HdrType ImsEntries[] = {Http::HdrType::DATE, Http::HdrType::CONTENT_TYPE, Http::HdrType::EXPIRES, Http::HdrType::LAST_MODIFIED, /* eof */ Http::HdrType::OTHER};
 
     HttpReply *rv = new HttpReply;
     int t;
@@ -151,7 +151,7 @@ HttpReply::make304() const
     /* rv->keep_alive */
     rv->sline.set(Http::ProtocolVersion(), Http::scNotModified, NULL);
 
-    for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
+    for (t = 0; ImsEntries[t] != Http::HdrType::OTHER; ++t)
         if ((e = header.findEntry(ImsEntries[t])))
             rv->header.addEntry(e->clone());
 
@@ -178,24 +178,24 @@ HttpReply::setHeaders(Http::StatusCode status, const char *reason,
     HttpHeader *hdr;
     sline.set(Http::ProtocolVersion(), status, reason);
     hdr = &header;
-    hdr->putStr(HDR_SERVER, visible_appname_string);
-    hdr->putStr(HDR_MIME_VERSION, "1.0");
-    hdr->putTime(HDR_DATE, squid_curtime);
+    hdr->putStr(Http::HdrType::SERVER, visible_appname_string);
+    hdr->putStr(Http::HdrType::MIME_VERSION, "1.0");
+    hdr->putTime(Http::HdrType::DATE, squid_curtime);
 
     if (ctype) {
-        hdr->putStr(HDR_CONTENT_TYPE, ctype);
+        hdr->putStr(Http::HdrType::CONTENT_TYPE, ctype);
         content_type = ctype;
     } else
         content_type = String();
 
     if (clen >= 0)
-        hdr->putInt64(HDR_CONTENT_LENGTH, clen);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, clen);
 
     if (expiresTime >= 0)
-        hdr->putTime(HDR_EXPIRES, expiresTime);
+        hdr->putTime(Http::HdrType::EXPIRES, expiresTime);
 
     if (lmt > 0)        /* this used to be lmt != 0 @?@ */
-        hdr->putTime(HDR_LAST_MODIFIED, lmt);
+        hdr->putTime(Http::HdrType::LAST_MODIFIED, lmt);
 
     date = squid_curtime;
 
@@ -212,10 +212,10 @@ HttpReply::redirect(Http::StatusCode status, const char *loc)
     HttpHeader *hdr;
     sline.set(Http::ProtocolVersion(), status, NULL);
     hdr = &header;
-    hdr->putStr(HDR_SERVER, APP_FULLNAME);
-    hdr->putTime(HDR_DATE, squid_curtime);
-    hdr->putInt64(HDR_CONTENT_LENGTH, 0);
-    hdr->putStr(HDR_LOCATION, loc);
+    hdr->putStr(Http::HdrType::SERVER, APP_FULLNAME);
+    hdr->putTime(Http::HdrType::DATE, squid_curtime);
+    hdr->putInt64(Http::HdrType::CONTENT_LENGTH, 0);
+    hdr->putStr(Http::HdrType::LOCATION, loc);
     date = squid_curtime;
     content_length = 0;
 }
@@ -239,9 +239,9 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
         return 0;
 
     /* ETag */
-    one = header.getStrOrList(HDR_ETAG);
+    one = header.getStrOrList(Http::HdrType::ETAG);
 
-    two = otherRep->header.getStrOrList(HDR_ETAG);
+    two = otherRep->header.getStrOrList(Http::HdrType::ETAG);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
@@ -253,9 +253,9 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
         return 0;
 
     /* MD5 */
-    one = header.getStrOrList(HDR_CONTENT_MD5);
+    one = header.getStrOrList(Http::HdrType::CONTENT_MD5);
 
-    two = otherRep->header.getStrOrList(HDR_CONTENT_MD5);
+    two = otherRep->header.getStrOrList(Http::HdrType::CONTENT_MD5);
 
     if (one.size()==0 || two.size()==0 || one.caseCmp(two)!=0 ) {
         one.clean();
@@ -311,16 +311,16 @@ HttpReply::hdrExpirationTime()
     }
 
     if (Config.onoff.vary_ignore_expire &&
-            header.has(HDR_VARY)) {
-        const time_t d = header.getTime(HDR_DATE);
-        const time_t e = header.getTime(HDR_EXPIRES);
+            header.has(Http::HdrType::VARY)) {
+        const time_t d = header.getTime(Http::HdrType::DATE);
+        const time_t e = header.getTime(Http::HdrType::EXPIRES);
 
         if (d == e)
             return -1;
     }
 
-    if (header.has(HDR_EXPIRES)) {
-        const time_t e = header.getTime(HDR_EXPIRES);
+    if (header.has(Http::HdrType::EXPIRES)) {
+        const time_t e = header.getTime(Http::HdrType::EXPIRES);
         /*
          * HTTP/1.0 says that robust implementations should consider
          * bad or malformed Expires header as equivalent to "expires
@@ -339,13 +339,13 @@ HttpReply::hdrCacheInit()
     HttpMsg::hdrCacheInit();
 
     http_ver = sline.version;
-    content_length = header.getInt64(HDR_CONTENT_LENGTH);
-    date = header.getTime(HDR_DATE);
-    last_modified = header.getTime(HDR_LAST_MODIFIED);
+    content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
+    date = header.getTime(Http::HdrType::DATE);
+    last_modified = header.getTime(Http::HdrType::LAST_MODIFIED);
     surrogate_control = header.getSc();
     content_range = header.getContRange();
     keep_alive = persistent() ? 1 : 0;
-    const char *str = header.getStr(HDR_CONTENT_TYPE);
+    const char *str = header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (str)
         content_type.limitInit(str, strcspn(str, ";\t "));
@@ -593,14 +593,14 @@ bool HttpReply::inheritProperties(const HttpMsg *aMsg)
 void HttpReply::removeStaleWarnings()
 {
     String warning;
-    if (header.getList(HDR_WARNING, &warning)) {
+    if (header.getList(Http::HdrType::WARNING, &warning)) {
         const String newWarning = removeStaleWarningValues(warning);
         if (warning.size() && warning.size() == newWarning.size())
             return; // some warnings are there and none changed
-        header.delById(HDR_WARNING);
+        header.delById(Http::HdrType::WARNING);
         if (newWarning.size()) { // some warnings left
             HttpHeaderEntry *const e =
-                new HttpHeaderEntry(HDR_WARNING, NULL, newWarning.termedBuf());
+                new HttpHeaderEntry(Http::HdrType::WARNING, NULL, newWarning.termedBuf());
             header.addEntry(e);
         }
     }
@@ -593,8 +593,8 @@ bool
 HttpRequest::conditional() const
 {
     return flags.ims ||
-           header.has(HDR_IF_MATCH) ||
-           header.has(HDR_IF_NONE_MATCH);
+           header.has(Http::HdrType::IF_MATCH) ||
+           header.has(Http::HdrType::IF_NONE_MATCH);
 }
 
 void
@@ -653,8 +653,8 @@ bool
 HttpRequest::canHandle1xx() const
 {
     // old clients do not support 1xx unless they sent Expect: 100-continue
-    // (we reject all other HDR_EXPECT values so just check for HDR_EXPECT)
-    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(HDR_EXPECT))
+    // (we reject all other Http::HdrType::EXPECT values so just check for Http::HdrType::EXPECT)
+    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(Http::HdrType::EXPECT))
         return false;
 
     // others must support 1xx control messages
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_USER_AGENT>;
+template class ACLRequestHeaderStrategy<Http::HdrType::USER_AGENT>;
 
@@ -25,7 +25,7 @@
  * TODO: This can be generalised by making the type of the regex_rule into a
  * template parameter - so that we can use different rules types in future.
  */
-ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(HDR_BAD_HDR), regex_rule(new ACLRegexData)
+ACLHTTPHeaderData::ACLHTTPHeaderData() : hdrId(Http::HdrType::BAD_HDR), regex_rule(new ACLRegexData)
 {}
 
 ACLHTTPHeaderData::~ACLHTTPHeaderData()
@@ -42,7 +42,7 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
     debugs(28, 3, "aclHeaderData::match: checking '" << hdrName << "'");
 
     String value;
-    if (hdrId != HDR_BAD_HDR) {
+    if (hdrId != Http::HdrType::BAD_HDR) {
         if (!hdr->has(hdrId))
             return false;
         value = hdr->getStrOrList(hdrId);
@@ -76,14 +76,14 @@ ACLHTTPHeaderData::parse()
     char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
-    hdrId = httpHeaderIdByNameDef(hdrName.rawBuf(), hdrName.size());
+    hdrId = Http::HeaderLookupTable.lookup(SBuf(hdrName));
     regex_rule->parse();
 }
 
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == HDR_BAD_HDR && hdrName.size()==0) || regex_rule->empty();
+    return (hdrId == Http::HdrType::BAD_HDR && hdrName.size()==0) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *
@@ -27,7 +27,7 @@ class ACLHTTPHeaderData : public ACLData<HttpHeader*>
     virtual ACLData<HttpHeader*> *clone() const;
 
 private:
-    http_hdr_type hdrId;                /**< set if header is known */
+    Http::HdrType hdrId;                /**< set if header is known */
     String hdrName;                     /**< always set */
     ACLData<char const *> * regex_rule;
 };
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_REFERER>;
+template class ACLRequestHeaderStrategy<Http::HdrType::REFERER>;
 
@@ -17,7 +17,7 @@ class ACLChecklist;
 #include "acl/Strategy.h"
 #include "HttpReply.h"
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
@@ -38,7 +38,7 @@ class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
     ACLReplyHeaderStrategy&operator=(ACLReplyHeaderStrategy const &);
 };
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 int
 ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
@@ -50,7 +50,7 @@ ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledC
     return data->match(theHeader);
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLReplyHeaderStrategy<header> *
 ACLReplyHeaderStrategy<header>::Instance()
 {
@@ -60,7 +60,7 @@ ACLReplyHeaderStrategy<header>::Instance()
     return Instance_;
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLReplyHeaderStrategy<header> * ACLReplyHeaderStrategy<header>::Instance_ = NULL;
 
 #endif /* SQUID_REPLYHEADERSTRATEGY_H */
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>;
+template class ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
 
@@ -28,9 +28,9 @@ class ACLReplyMIMEType
 
 template <>
 inline int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLReplyHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->reply->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
@@ -14,8 +14,7 @@
 #include "acl/Strategy.h"
 #include "HttpRequest.h"
 
-template <http_hdr_type header>
-
+template <Http::HdrType header>
 class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
 
@@ -36,7 +35,7 @@ class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
     ACLRequestHeaderStrategy&operator=(ACLRequestHeaderStrategy const &);
 };
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 int
 ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
@@ -48,7 +47,7 @@ ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFille
     return data->match(theHeader);
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLRequestHeaderStrategy<header> *
 ACLRequestHeaderStrategy<header>::Instance()
 {
@@ -58,7 +57,7 @@ ACLRequestHeaderStrategy<header>::Instance()
     return Instance_;
 }
 
-template <http_hdr_type header>
+template <Http::HdrType header>
 ACLRequestHeaderStrategy<header> * ACLRequestHeaderStrategy<header>::Instance_ = NULL;
 
 #endif /* SQUID_REQUESTHEADERSTRATEGY_H */
@@ -15,5 +15,5 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>;
+template class ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>;
 
@@ -28,9 +28,9 @@ class ACLRequestMIMEType
 
 template <>
 inline int
-ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLRequestHeaderStrategy<Http::HdrType::CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
+    char const *theHeader = checklist->request->header.getStr(Http::HdrType::CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
@@ -38,12 +38,12 @@ Adaptation::Ecap::Host::Host()
     // assign our host-specific IDs to well-known names
     // this code can run only once
 
-    libecap::headerTransferEncoding.assignHostId(HDR_TRANSFER_ENCODING);
-    libecap::headerReferer.assignHostId(HDR_REFERER);
-    libecap::headerContentLength.assignHostId(HDR_CONTENT_LENGTH);
-    libecap::headerVia.assignHostId(HDR_VIA);
-    // TODO: libecap::headerXClientIp.assignHostId(HDR_X_CLIENT_IP);
-    // TODO: libecap::headerXServerIp.assignHostId(HDR_X_SERVER_IP);
+    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);
+    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);
+    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);
+    libecap::headerVia.assignHostId(Http::HdrType::VIA);
+    // TODO: libecap::headerXClientIp.assignHostId(Http::HdrType::X_CLIENT_IP);
+    // TODO: libecap::headerXServerIp.assignHostId(Http::HdrType::X_SERVER_IP);
 
     libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);
     libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);
@@ -32,18 +32,18 @@ Adaptation::Ecap::HeaderRep::HeaderRep(HttpMsg &aMessage): theHeader(aMessage.he
 bool
 Adaptation::Ecap::HeaderRep::hasAny(const Name &name) const
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
+    const Http::HdrType squidId = TranslateHeaderId(name);
     // XXX: optimize to remove getByName: we do not need the value here
-    return squidId == HDR_OTHER ?
+    return squidId == Http::HdrType::OTHER ?
            theHeader.getByName(name.image().c_str()).size() > 0:
            (bool)theHeader.has(squidId);
 }
 
 Adaptation::Ecap::HeaderRep::Value
 Adaptation::Ecap::HeaderRep::value(const Name &name) const
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
-    const String value = squidId == HDR_OTHER ?
+    const Http::HdrType squidId = TranslateHeaderId(name);
+    const String value = squidId == Http::HdrType::OTHER ?
                          theHeader.getByName(name.image().c_str()) :
                          theHeader.getStrOrList(squidId);
     return value.size() > 0 ?
@@ -53,26 +53,26 @@ Adaptation::Ecap::HeaderRep::value(const Name &name) const
 void
 Adaptation::Ecap::HeaderRep::add(const Name &name, const Value &value)
 {
-    const http_hdr_type squidId = TranslateHeaderId(name); // HDR_OTHER OK
+    const Http::HdrType squidId = TranslateHeaderId(name); // Http::HdrType::OTHER OK
     HttpHeaderEntry *e = new HttpHeaderEntry(squidId, name.image().c_str(),
             value.toString().c_str());
     theHeader.addEntry(e);
 
-    if (squidId == HDR_CONTENT_LENGTH)
-        theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
+    if (squidId == Http::HdrType::CONTENT_LENGTH)
+        theMessage.content_length = theHeader.getInt64(Http::HdrType::CONTENT_LENGTH);
 }
 
 void
 Adaptation::Ecap::HeaderRep::removeAny(const Name &name)
 {
-    const http_hdr_type squidId = TranslateHeaderId(name);
-    if (squidId == HDR_OTHER)
+    const Http::HdrType squidId = TranslateHeaderId(name);
+    if (squidId == Http::HdrType::OTHER)
         theHeader.delByName(name.image().c_str());
     else
         theHeader.delById(squidId);
 
-    if (squidId == HDR_CONTENT_LENGTH)
-        theMessage.content_length = theHeader.getInt64(HDR_CONTENT_LENGTH);
+    if (squidId == Http::HdrType::CONTENT_LENGTH)
+        theMessage.content_length = theHeader.getInt64(Http::HdrType::CONTENT_LENGTH);
 }
 
 void
@@ -103,12 +103,12 @@ Adaptation::Ecap::HeaderRep::parse(const Area &buf)
     Must(theMessage.parse(buf.start, buf.size, true, &error));
 }
 
-http_hdr_type
+Http::HdrType
 Adaptation::Ecap::HeaderRep::TranslateHeaderId(const Name &name)
 {
     if (name.assignedHostId())
-        return static_cast<http_hdr_type>(name.hostId());
-    return HDR_OTHER;
+        return static_cast<Http::HdrType>(name.hostId());
+    return Http::HdrType::OTHER;
 }
 
 /* FirstLineRep */
@@ -51,7 +51,7 @@ class HeaderRep: public libecap::Header
     virtual void parse(const Area &buf); // throws on failures
 
 protected:
-    static http_hdr_type TranslateHeaderId(const Name &name);
+    static Http::HdrType TranslateHeaderId(const Name &name);
 
 private:
     HttpHeader &theHeader; // the header being translated to libecap
@@ -833,12 +833,12 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // update the adaptation plan if needed (all status codes!)
     if (service().cfg().routing) {
         String services;
-        if (icapReply->header.getList(HDR_X_NEXT_SERVICES, &services)) {
+        if (icapReply->header.getList(Http::HdrType::X_NEXT_SERVICES, &services)) {
             Adaptation::History::Pointer ah = request->adaptHistory(true);
             if (ah != NULL)
                 ah->updateNextServices(services);
         }
-    } // TODO: else warn (occasionally!) if we got HDR_X_NEXT_SERVICES
+    } // TODO: else warn (occasionally!) if we got Http::HdrType::X_NEXT_SERVICES
 
     // We need to store received ICAP headers for <icapLastHeader logformat option.
     // If we already have stored headers from previous ICAP transaction related to this
@@ -1341,12 +1341,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
-    if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
+    if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getByName("Proxy-Authenticate");
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
-    if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
+    if (virgin.header->header.has(Http::HdrType::PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
         buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
@@ -1553,7 +1553,7 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
     // end cloning
 
     // remove all hop-by-hop headers from the clone
-    headClone->header.delById(HDR_PROXY_AUTHENTICATE);
+    headClone->header.delById(Http::HdrType::PROXY_AUTHENTICATE);
     headClone->header.removeHopByHopEntries();
 
     // pack polished HTTP header
@@ -117,15 +117,15 @@ void Adaptation::Icap::Options::configure(const HttpReply *reply)
 
     cfgIntHeader(h, "Options-TTL", theTTL);
 
-    theTimestamp = h->getTime(HDR_DATE);
+    theTimestamp = h->getTime(Http::HdrType::DATE);
 
     if (theTimestamp < 0)
         theTimestamp = squid_curtime;
 
-    if (h->hasListMember(HDR_ALLOW, "204", ','))
+    if (h->hasListMember(Http::HdrType::ALLOW, "204", ','))
         allow204 = true;
 
-    if (h->hasListMember(HDR_ALLOW, "206", ','))
+    if (h->hasListMember(Http::HdrType::ALLOW, "206", ','))
         allow206 = true;
 
     cfgIntHeader(h, "Preview", preview);
@@ -28,7 +28,7 @@ AuthenticateAcl(ACLChecklist *ch)
 {
     ACLFilledChecklist *checklist = Filled(ch);
     HttpRequest *request = checklist->request;
-    http_hdr_type headertype;
+    Http::HdrType headertype;
 
     if (NULL == request) {
         fatal ("requiresRequest SHOULD have been true for this ACL!!");
@@ -42,13 +42,13 @@ AuthenticateAcl(ACLChecklist *ch)
             return ACCESS_DENIED;
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
-        headertype = HDR_AUTHORIZATION;
+        headertype = Http::HdrType::AUTHORIZATION;
     } else if (request->flags.intercepted || request->flags.interceptTproxy) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
         /* Proxy authorization on proxy requests */
-        headertype = HDR_PROXY_AUTHORIZATION;
+        headertype = Http::HdrType::PROXY_AUTHORIZATION;
     }
 
     /* get authed here */
@@ -20,7 +20,7 @@ class HttpReply;
 class HttpRequest;
 class wordlist;
 
-/* for http_hdr_type parameters-by-value */
+/* for Http::HdrType parameters-by-value */
 #include "HttpHeader.h"
 
 namespace Format
@@ -106,7 +106,7 @@ class Config
     virtual bool dump(StoreEntry *, const char *, Config *) const;
 
     /** add headers as needed when challenging for auth */
-    virtual void fixHeader(UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *) = 0;
+    virtual void fixHeader(UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *) = 0;
 
     /// Find any existing user credentials in the authentication cache by name and type.
     virtual Auth::User::Pointer findUserInCache(const char *nameKey, Auth::Type type);
@@ -218,7 +218,7 @@ Auth::UserRequest::connLastHeader()
  * This is basically a handle approach.
  */
 static void
-authenticateAuthenticateUser(Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, ConnStateData * conn, http_hdr_type type)
+authenticateAuthenticateUser(Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, ConnStateData * conn, Http::HdrType type)
 {
     assert(auth_user_request.getRaw() != NULL);
 
@@ -271,7 +271,7 @@ authTryGetUser(Auth::UserRequest::Pointer auth_user_request, ConnStateData * con
  * Caller is responsible for locking and unlocking their *auth_user_request!
  */
 AuthAclState
-Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
+Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
 {
     const char *proxy_auth;
     assert(headertype != 0);
@@ -433,7 +433,7 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
 }
 
 AuthAclState
-Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer * aUR, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
+Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer * aUR, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al)
 {
     // If we have already been called, return the cached value
     Auth::UserRequest::Pointer t = authTryGetUser(*aUR, conn, request);
@@ -464,24 +464,24 @@ void
 Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal)
 /* send the auth types we are configured to support (and have compiled in!) */
 {
-    http_hdr_type type;
+    Http::HdrType type;
 
     switch (rep->sline.status()) {
 
     case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
-        type = HDR_PROXY_AUTHENTICATE;
+        type = Http::HdrType::PROXY_AUTHENTICATE;
         break;
 
     case Http::scUnauthorized:
         /* WWW Authorisation needed */
-        type = HDR_WWW_AUTHENTICATE;
+        type = Http::HdrType::WWW_AUTHENTICATE;
         break;
 
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
-        type = HDR_ENUM_END;
+        type = Http::HdrType::ENUM_END;
         break;
     }
 
@@ -126,7 +126,7 @@ class UserRequest : public RefCountable
      */
     bool valid() const;
 
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type) = 0;
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type) = 0;
 
     /* template method - what needs to be done next? advertise schemes, challenge, handle error, nothing? */
     virtual Direction module_direction() = 0;
@@ -162,7 +162,7 @@ class UserRequest : public RefCountable
      *
      * \return Some AUTH_ACL_* state
      */
-    static AuthAclState tryToAuthenticateAndSetAuthUser(UserRequest::Pointer *aUR, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &);
+    static AuthAclState tryToAuthenticateAndSetAuthUser(UserRequest::Pointer *aUR, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &);
 
     /// Add the appropriate [Proxy-]Authenticate header to the given reply
     static void addReplyAuthHeader(HttpReply * rep, UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal);
@@ -218,7 +218,7 @@ class UserRequest : public RefCountable
 
 private:
 
-    static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
+    static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, Http::HdrType headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
 
     /** return a message on the 407 error pages */
     char *message;
@@ -72,7 +72,7 @@ Auth::Basic::Config::type() const
 }
 
 void
-Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
+Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)
 {
     if (authenticateProgram) {
         debugs(29, 9, "Sending type:" << hdrType << " header: 'Basic realm=\"" << realm << "\"'");
@@ -30,7 +30,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     void decode(char const *httpAuthHeader, Auth::UserRequest::Pointer);
@@ -50,7 +50,7 @@ Auth::Basic::UserRequest::credentialsStr()
 /* log a basic user in
  */
 void
-Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, http_hdr_type)
+Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, Http::HdrType)
 {
     assert(user() != NULL);
 
@@ -31,7 +31,7 @@ class UserRequest : public Auth::UserRequest
     virtual ~UserRequest() { assert(LockCount()==0); }
 
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData *conn, Http::HdrType type);
     virtual Auth::Direction module_direction();
     virtual void startHelperLookup(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
@@ -509,7 +509,7 @@ Auth::Digest::Config::configured() const
 
 /* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */
 void
-Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
+Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)
 {
     if (!authenticateProgram)
         return;
@@ -79,7 +79,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);
@@ -78,7 +78,7 @@ Auth::Digest::UserRequest::credentialsStr()
 /** log a digest user in
  */
 void
-Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, http_hdr_type)
+Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, Http::HdrType)
 {
     HASHHEX SESSIONKEY;
     HASHHEX HA2 = "";
@@ -145,7 +145,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *,
                 digest_request->setDenyMessage("Incorrect password");
                 return;
             } else {
-                const char *useragent = request->header.getStr(HDR_USER_AGENT);
+                const char *useragent = request->header.getStr(Http::HdrType::USER_AGENT);
 
                 static Ip::Address last_broken_addr;
                 static int seen_broken_client = 0;
@@ -223,14 +223,14 @@ Auth::Digest::UserRequest::module_direction()
 void
 Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
 {
-    http_hdr_type type;
+    Http::HdrType type;
 
     /* don't add to authentication error pages */
     if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
             || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
+    type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
 #if WAITING_FOR_TE
     /* test for http/1.1 transfer chunked encoding */
@@ -272,7 +272,7 @@ Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int acc
             || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
+    type = accel ? Http::HdrType::AUTHENTICATION_INFO : Http::HdrType::PROXY_AUTHENTICATION_INFO;
 
     if ((static_cast<Auth::Digest::Config*>(digestScheme::GetInstance()->getConfig())->authenticate) && authDigestNonceLastRequest(nonce)) {
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
@@ -32,7 +32,7 @@ class UserRequest : public Auth::UserRequest
     virtual ~UserRequest();
 
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
 #if WAITING_FOR_TE
@@ -174,7 +174,7 @@ Auth::Negotiate::Config::configured() const
 /* Negotiate Scheme */
 
 void
-Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type reqType, HttpRequest * request)
+Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType reqType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;
@@ -30,7 +30,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);
@@ -181,7 +181,7 @@ Auth::Negotiate::UserRequest::releaseAuthServer()
 }
 
 void
-Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
+Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, Http::HdrType type)
 {
     /* Check that we are in the client side, where we can generate
      * auth challenges */
@@ -30,7 +30,7 @@ class UserRequest : public Auth::UserRequest
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Direction module_direction();
     virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
@@ -164,7 +164,7 @@ Auth::Ntlm::Config::configured() const
 /* NTLM Scheme */
 
 void
-Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest * request)
+Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;
@@ -33,7 +33,7 @@ class Config : public Auth::Config
     virtual void done();
     virtual void rotateHelpers();
     virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;
-    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *);
+    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);
     virtual void init(Auth::Config *);
     virtual void parse(Auth::Config *, int, char *);
     virtual void registerWithCacheManager(void);
@@ -175,7 +175,7 @@ Auth::Ntlm::UserRequest::releaseAuthServer()
 }
 
 void
-Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
+Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, Http::HdrType type)
 {
     /* Check that we are in the client side, where we can generate
      * auth challenges */
@@ -29,7 +29,7 @@ class UserRequest : public Auth::UserRequest
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
-    virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
+    virtual void authenticate(HttpRequest * request, ConnStateData * conn, Http::HdrType type);
     virtual Auth::Direction module_direction();
     virtual void startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
@@ -14,11 +14,27 @@
 #include <map>
 
 /**
- * SBuf -> enum lookup table
+ * a record in the initializer list for a LookupTable
+ *
+ * In case it is wished to extend the structure of a LookupTable's initializer
+ * list, it can be done by using a custom struct which must match
+ * LookupTableRecord's signature plus any extra custom fields the user may
+ * wish to add; the extended record type must then be passed as RecordType
+ * template parameter to LookupTable.
+ */
+template <typename EnumType>
+struct LookupTableRecord
+{
+    const char *name;
+    EnumType id;
+};
+
+/**
+ * SBuf -> case-insensitive enum lookup table
  *
  * How to use:
  * enum enum_type { ... };
- * static const LookupTable<enum_type>::Record initializerTable[] {
+ * static const LookupTable<enum_type>::Record initializerTable[] = {
  *   {"key1", ENUM_1}, {"key2", ENUM_2}, ... {nullptr, ENUM_INVALID_VALUE}
  * };
  * LookupTable<enum_type> lookupTableInstance(ENUM_INVALID_VALUE, initializerTable);
@@ -29,15 +45,20 @@
  * if (item != ENUM_INVALID_VALUE) { // do stuff }
  *
  */
-template<typename EnumType>
+
+class SBufCaseInsensitiveLess : public std::binary_function<SBuf, SBuf, bool> {
+public:
+    bool operator() (const SBuf &x, const SBuf &y) const {
+        return x.caseCmp(y) < 0;
+    }
+};
+
+template<typename EnumType, typename RecordType = LookupTableRecord<EnumType> >
 class LookupTable
 {
 public:
     /// element of the lookup table initialization list
-    typedef struct {
-        const char *name;
-        EnumType id;
-    } Record;
+    typedef RecordType Record;
 
     LookupTable(const EnumType theInvalid, const Record data[]) :
         invalidValue(theInvalid)
@@ -46,6 +67,7 @@ class LookupTable
             lookupTable[SBuf(data[i].name)] = data[i].id;
         }
     }
+
     EnumType lookup(const SBuf &key) const {
         auto r = lookupTable.find(key);
         if (r == lookupTable.end())
@@ -54,7 +76,7 @@ class LookupTable
     }
 
 private:
-    typedef std::map<const SBuf, EnumType> lookupTable_t;
+    typedef std::map<const SBuf, EnumType, SBufCaseInsensitiveLess> lookupTable_t;
     lookupTable_t lookupTable;
     EnumType invalidValue;
 };
@@ -4608,9 +4608,9 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
     }
     HeaderWithAcl hwa;
     hwa.fieldName = fn;
-    hwa.fieldId = httpHeaderIdByNameDef(fn, strlen(fn));
-    if (hwa.fieldId == HDR_BAD_HDR)
-        hwa.fieldId = HDR_OTHER;
+    hwa.fieldId = Http::HeaderLookupTable.lookup(SBuf(fn));
+    if (hwa.fieldId == Http::HdrType::BAD_HDR)
+        hwa.fieldId = Http::HdrType::OTHER;
 
     Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
     ConfigParser::EnableMacros();
@@ -243,7 +243,7 @@ CacheManager::ParseHeaders(const HttpRequest * request, Mgr::ActionParams &param
     // TODO: use the authentication system decode to retrieve these details properly.
 
     /* base 64 _decoded_ user:passwd pair */
-    const char *basic_cookie = request->header.getAuth(HDR_AUTHORIZATION, "Basic");
+    const char *basic_cookie = request->header.getAuth(Http::HdrType::AUTHORIZATION, "Basic");
 
     if (!basic_cookie)
         return;
@@ -356,8 +356,8 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
         rep->header.putAuth("Basic", actionName);
 #endif
         // Allow cachemgr and other XHR scripts access to our version string
-        if (request->header.has(HDR_ORIGIN)) {
-            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
+        if (request->header.has(Http::HdrType::ORIGIN)) {
+            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(Http::HdrType::ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif
@@ -374,8 +374,8 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
         return;
     }
 
-    if (request->header.has(HDR_ORIGIN)) {
-        cmd->params.httpOrigin = request->header.getStr(HDR_ORIGIN);
+    if (request->header.has(Http::HdrType::ORIGIN)) {
+        cmd->params.httpOrigin = request->header.getStr(Http::HdrType::ORIGIN);
     }
 
     debugs(16, 2, "CacheManager: " <<
@@ -391,8 +391,8 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
         if (strncmp(rep->body.content(),"Internal Error:", 15) == 0)
             rep->sline.set(Http::ProtocolVersion(1,1), Http::scNotFound);
         // Allow cachemgr and other XHR scripts access to our version string
-        if (request->header.has(HDR_ORIGIN)) {
-            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
+        if (request->header.has(Http::HdrType::ORIGIN)) {
+            rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(Http::HdrType::ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif
@@ -1047,8 +1047,8 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
 
     /* stuff the header with required entries and pack it */
 
-    if (rep->header.has(HDR_CONTENT_TYPE))
-        hdr.putStr(HDR_CONTENT_TYPE, rep->header.getStr(HDR_CONTENT_TYPE));
+    if (rep->header.has(Http::HdrType::CONTENT_TYPE))
+        hdr.putStr(Http::HdrType::CONTENT_TYPE, rep->header.getStr(Http::HdrType::CONTENT_TYPE));
 
     httpHeaderAddContRange(&hdr, *spec, rep->content_length);
 
@@ -1191,15 +1191,15 @@ ClientHttpRequest::mRangeCLen()
 static int
 clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
 {
-    const TimeOrTag spec = http->request->header.getTimeOrTag(HDR_IF_RANGE);
+    const TimeOrTag spec = http->request->header.getTimeOrTag(Http::HdrType::IF_RANGE);
     /* check for parsing falure */
 
     if (!spec.valid)
         return 0;
 
     /* got an ETag? */
     if (spec.tag.str) {
-        ETag rep_tag = rep->header.getETag(HDR_ETAG);
+        ETag rep_tag = rep->header.getETag(Http::HdrType::ETAG);
         debugs(33, 3, "clientIfRangeMatch: ETags: " << spec.tag.str << " and " <<
                (rep_tag.str ? rep_tag.str : "<none>"));
 
@@ -1253,7 +1253,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         range_err = "no [parse-able] reply";
     else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
         range_err = "wrong status code";
-    else if (hdr->has(HDR_CONTENT_RANGE))
+    else if (hdr->has(Http::HdrType::CONTENT_RANGE))
         range_err = "origin server does ranges";
     else if (rep->content_length < 0)
         range_err = "unknown length";
@@ -1263,7 +1263,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates
      */
-    else if (http->logType.isTcpHit() && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
+    else if (http->logType.isTcpHit() && http->request->header.has(Http::HdrType::IF_RANGE) && !clientIfRangeMatch(http, rep))
         range_err = "If-Range match failed";
     else if (!http->request->range->canonize(rep))
         range_err = "canonization failed";
@@ -1299,7 +1299,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
 
         if (spec_count == 1) {
             if (!replyMatchRequest) {
-                hdr->delById(HDR_CONTENT_RANGE);
+                hdr->delById(Http::HdrType::CONTENT_RANGE);
                 hdr->putContRange(rep->content_range);
                 actual_clen = rep->content_length;
                 //http->range_iter.pos = rep->content_range->spec.begin();
@@ -1311,7 +1311,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
                 assert(*pos);
                 /* append Content-Range */
 
-                if (!hdr->has(HDR_CONTENT_RANGE)) {
+                if (!hdr->has(Http::HdrType::CONTENT_RANGE)) {
                     /* No content range, so this was a full object we are
                      * sending parts of.
                      */
@@ -1327,8 +1327,8 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
             /* generate boundary string */
             http->range_iter.boundary = http->rangeBoundaryStr();
             /* delete old Content-Type, add ours */
-            hdr->delById(HDR_CONTENT_TYPE);
-            httpHeaderPutStrf(hdr, HDR_CONTENT_TYPE,
+            hdr->delById(Http::HdrType::CONTENT_TYPE);
+            httpHeaderPutStrf(hdr, Http::HdrType::CONTENT_TYPE,
                               "multipart/byteranges; boundary=\"" SQUIDSTRINGPH "\"",
                               SQUIDSTRINGPRINT(http->range_iter.boundary));
             /* Content-Length is not required in multipart responses
@@ -1341,9 +1341,9 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         /* replace Content-Length header */
         assert(actual_clen >= 0);
 
-        hdr->delById(HDR_CONTENT_LENGTH);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
 
-        hdr->putInt64(HDR_CONTENT_LENGTH, actual_clen);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, actual_clen);
 
         debugs(33, 3, "clientBuildRangeHeader: actual content length: " << actual_clen);
 
@@ -2609,14 +2609,14 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
 
     if (request->header.chunked()) {
         chunked = true;
-    } else if (request->header.has(HDR_TRANSFER_ENCODING)) {
-        const String te = request->header.getList(HDR_TRANSFER_ENCODING);
+    } else if (request->header.has(Http::HdrType::TRANSFER_ENCODING)) {
+        const String te = request->header.getList(Http::HdrType::TRANSFER_ENCODING);
         // HTTP/1.1 requires chunking to be the last encoding if there is one
         unsupportedTe = te.size() && te != "identity";
     } // else implied identity coding
 
     mustReplyToOptions = (request->method == Http::METHOD_OPTIONS) &&
-                         (request->header.getInt64(HDR_MAX_FORWARDS) == 0);
+                         (request->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0);
     if (!urlCheckRequest(request.getRaw()) || mustReplyToOptions || unsupportedTe) {
         clientStreamNode *node = context->getClientReplyContext();
         conn->quitAfterError(request.getRaw());
@@ -4556,11 +4556,11 @@ int
 varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
 {
     const char *vary = request->vary_headers;
-    int has_vary = entry->getReply()->header.has(HDR_VARY);
+    int has_vary = entry->getReply()->header.has(Http::HdrType::VARY);
 #if X_ACCELERATOR_VARY
 
     has_vary |=
-        entry->getReply()->header.has(HDR_X_ACCELERATOR_VARY);
+        entry->getReply()->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 #endif
 
     if (!has_vary || !entry->mem_obj->vary_headers) {
@@ -297,7 +297,7 @@ clientReplyContext::processExpired()
 
     http->request->lastmod = old_entry->lastmod;
 
-    if (!http->request->header.has(HDR_IF_NONE_MATCH)) {
+    if (!http->request->header.has(Http::HdrType::IF_NONE_MATCH)) {
         ETag etag = {NULL, -1}; // TODO: make that a default ETag constructor
         if (old_entry->hasEtag(etag) && !etag.weak)
             http->request->etag = etag.str;
@@ -743,20 +743,20 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
 
     HttpRequest &r = *http->request;
 
-    if (r.header.has(HDR_IF_MATCH) && !e->hasIfMatchEtag(r)) {
+    if (r.header.has(Http::HdrType::IF_MATCH) && !e->hasIfMatchEtag(r)) {
         // RFC 2616: reply with 412 Precondition Failed if If-Match did not match
         sendPreconditionFailedError();
         return;
     }
 
     bool matchedIfNoneMatch = false;
-    if (r.header.has(HDR_IF_NONE_MATCH)) {
+    if (r.header.has(Http::HdrType::IF_NONE_MATCH)) {
         if (!e->hasIfNoneMatchEtag(r)) {
             // RFC 2616: ignore IMS if If-None-Match did not match
             r.flags.ims = false;
             r.ims = -1;
             r.imslen = 0;
-            r.header.delById(HDR_IF_MODIFIED_SINCE);
+            r.header.delById(Http::HdrType::IF_MODIFIED_SINCE);
             http->logType = LOG_TCP_MISS;
             sendMoreData(result);
             return;
@@ -1318,13 +1318,13 @@ clientReplyContext::buildReplyHeader()
 #endif
 
     if (is_hit)
-        hdr->delById(HDR_SET_COOKIE);
+        hdr->delById(Http::HdrType::SET_COOKIE);
     // TODO: RFC 2965 : Must honour Cache-Control: no-cache="set-cookie2" and remove header.
 
     // if there is not configured a peer proxy with login=PASS or login=PASSTHRU option enabled
     // remove the Proxy-Authenticate header
     if ( !request->peer_login || (strcmp(request->peer_login,"PASS") != 0 && strcmp(request->peer_login,"PASSTHRU") != 0))
-        reply->header.delById(HDR_PROXY_AUTHENTICATE);
+        reply->header.delById(Http::HdrType::PROXY_AUTHENTICATE);
 
     reply->header.removeHopByHopEntries();
 
@@ -1340,27 +1340,27 @@ clientReplyContext::buildReplyHeader()
          * (note that the existing header is passed along unmodified
          * on cache misses)
          */
-        hdr->delById(HDR_AGE);
+        hdr->delById(Http::HdrType::AGE);
         /*
          * This adds the calculated object age. Note that the details of the
          * age calculation is performed by adjusting the timestamp in
          * StoreEntry::timestampsSet(), not here.
          */
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
-            hdr->delById(HDR_DATE);
-            hdr->insertTime(HDR_DATE, squid_curtime);
+            hdr->delById(Http::HdrType::DATE);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
-            HttpHeaderEntry *h = hdr->findEntry(HDR_DATE);
+            HttpHeaderEntry *h = hdr->findEntry(Http::HdrType::DATE);
             if (h)
                 hdr->putExt("X-Origin-Date", h->value.termedBuf());
-            hdr->delById(HDR_DATE);
-            hdr->insertTime(HDR_DATE, squid_curtime);
-            h = hdr->findEntry(HDR_EXPIRES);
+            hdr->delById(Http::HdrType::DATE);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            h = hdr->findEntry(Http::HdrType::EXPIRES);
             if (h && http->storeEntry()->expires >= 0) {
                 hdr->putExt("X-Origin-Expires", h->value.termedBuf());
-                hdr->delById(HDR_EXPIRES);
-                hdr->insertTime(HDR_EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
+                hdr->delById(Http::HdrType::EXPIRES);
+                hdr->insertTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
@@ -1369,7 +1369,7 @@ clientReplyContext::buildReplyHeader()
                 hdr->putExt("X-Cache-Age", age);
             }
         } else if (http->storeEntry()->timestamp <= squid_curtime) {
-            hdr->putInt(HDR_AGE,
+            hdr->putInt(Http::HdrType::AGE,
                         squid_curtime - http->storeEntry()->timestamp);
             /* Signal old objects.  NB: rfc 2616 is not clear,
              * by implication, on whether we should do this to all
@@ -1385,7 +1385,7 @@ clientReplyContext::buildReplyHeader()
                 snprintf (tbuf, sizeof(tbuf), "%s %s %s",
                           "113", ThisCache,
                           "This cache hit is still fresh and more than 1 day old");
-                hdr->putStr(HDR_WARNING, tbuf);
+                hdr->putStr(Http::HdrType::WARNING, tbuf);
             }
         }
     }
@@ -1397,11 +1397,11 @@ clientReplyContext::buildReplyHeader()
      *
      * NP: done after Age: to prevent ENTRY_SPECIAL double-handling this header.
      */
-    if ( !hdr->has(HDR_DATE) ) {
+    if ( !hdr->has(Http::HdrType::DATE) ) {
         if (!http->storeEntry())
-            hdr->insertTime(HDR_DATE, squid_curtime);
+            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
         else if (http->storeEntry()->timestamp > 0)
-            hdr->insertTime(HDR_DATE, http->storeEntry()->timestamp);
+            hdr->insertTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
         else {
             debugs(88,DBG_IMPORTANT,"BUG 3279: HTTP reply without Date:");
             /* dump something useful about the problem */
@@ -1418,13 +1418,13 @@ clientReplyContext::buildReplyHeader()
 
     /* Filter unproxyable authentication types */
     if (http->logType.oldType != LOG_TCP_DENIED &&
-            hdr->has(HDR_WWW_AUTHENTICATE)) {
+            hdr->has(Http::HdrType::WWW_AUTHENTICATE)) {
         HttpHeaderPos pos = HttpHeaderInitPos;
         HttpHeaderEntry *e;
 
         int connection_auth_blocked = 0;
         while ((e = hdr->getEntry(&pos))) {
-            if (e->id == HDR_WWW_AUTHENTICATE) {
+            if (e->id == Http::HdrType::WWW_AUTHENTICATE) {
                 const char *value = e->value.rawBuf();
 
                 if ((strncasecmp(value, "NTLM", 4) == 0 &&
@@ -1441,14 +1441,14 @@ clientReplyContext::buildReplyHeader()
                     }
                     request->flags.mustKeepalive = true;
                     if (!request->flags.accelerated && !request->flags.intercepted) {
-                        httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
+                        httpHeaderPutStrf(hdr, Http::HdrType::PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
                           We send "Connection: Proxy-Support" header to mark
                           Proxy-Support as a hop-by-hop header for intermediaries that do not
                           understand the semantics of this header. The RFC should have included
                           this recommendation.
                         */
-                        httpHeaderPutStrf(hdr, HDR_CONNECTION, "Proxy-support");
+                        httpHeaderPutStrf(hdr, Http::HdrType::CONNECTION, "Proxy-support");
                     }
                     break;
                 }
@@ -1477,12 +1477,12 @@ clientReplyContext::buildReplyHeader()
 #endif
 
     /* Append X-Cache */
-    httpHeaderPutStrf(hdr, HDR_X_CACHE, "%s from %s",
+    httpHeaderPutStrf(hdr, Http::HdrType::X_CACHE, "%s from %s",
                       is_hit ? "HIT" : "MISS", getMyHostname());
 
 #if USE_CACHE_DIGESTS
     /* Append X-Cache-Lookup: -- temporary hack, to be removed @?@ @?@ */
-    httpHeaderPutStrf(hdr, HDR_X_CACHE_LOOKUP, "%s from %s:%d",
+    httpHeaderPutStrf(hdr, Http::HdrType::X_CACHE_LOOKUP, "%s from %s:%d",
                       lookup_type ? lookup_type : "NONE",
                       getMyHostname(), getMyPort());
 
@@ -1534,24 +1534,24 @@ clientReplyContext::buildReplyHeader()
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
         request->flags.chunkedReply = true;
-        hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
+        hdr->putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     /* Append VIA */
     if (Config.onoff.via) {
         LOCAL_ARRAY(char, bbuf, MAX_URL + 32);
         String strVia;
-        hdr->getList(HDR_VIA, &strVia);
+        hdr->getList(Http::HdrType::VIA, &strVia);
         snprintf(bbuf, MAX_URL + 32, "%d.%d %s",
                  reply->sline.version.major,
                  reply->sline.version.minor,
                  ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        hdr->delById(HDR_VIA);
-        hdr->putStr(HDR_VIA, strVia.termedBuf());
+        hdr->delById(Http::HdrType::VIA);
+        hdr->putStr(Http::HdrType::VIA, strVia.termedBuf());
     }
     /* Signal keep-alive or close explicitly */
-    hdr->putStr(HDR_CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
+    hdr->putStr(Http::HdrType::CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
 
 #if ADD_X_REQUEST_URI
     /*
@@ -1560,15 +1560,15 @@ clientReplyContext::buildReplyHeader()
      * but X-Request-URI is likely to be the very last header to ease use from a
      * debugger [hdr->entries.count-1].
      */
-    hdr->putStr(HDR_X_REQUEST_URI,
+    hdr->putStr(Http::HdrType::X_REQUEST_URI,
                 http->memOjbect()->url ? http->memObject()->url : http->uri);
 
 #endif
 
     /* Surrogate-Control requires Surrogate-Capability from upstream to pass on */
-    if ( hdr->has(HDR_SURROGATE_CONTROL) ) {
-        if (!request->header.has(HDR_SURROGATE_CAPABILITY)) {
-            hdr->delById(HDR_SURROGATE_CONTROL);
+    if ( hdr->has(Http::HdrType::SURROGATE_CONTROL) ) {
+        if (!request->header.has(Http::HdrType::SURROGATE_CAPABILITY)) {
+            hdr->delById(Http::HdrType::SURROGATE_CONTROL);
         }
         /* TODO: else case: drop any controls intended specifically for our surrogate ID */
     }
@@ -1753,7 +1753,7 @@ clientGetMoreData(clientStreamNode * aNode, ClientHttpRequest * http)
     // OPTIONS with Max-Forwards:0 handled in clientProcessRequest()
 
     if (context->http->request->method == Http::METHOD_TRACE) {
-        if (context->http->request->header.getInt64(HDR_MAX_FORWARDS) == 0) {
+        if (context->http->request->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0) {
             context->traceReply(aNode);
             return;
         }
@@ -573,7 +573,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
 
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: Host header forgery detected on " <<
            http->getConn()->clientConnection << " (" << A << " does not match " << B << ")");
-    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(HDR_USER_AGENT));
+    debugs(85, DBG_IMPORTANT, "SECURITY ALERT: By user agent: " << http->request->header.getStr(Http::HdrType::USER_AGENT));
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: on URL: " << http->request->effectiveRequestUri());
 
     // IP address validation for Host: failed. reject the connection.
@@ -599,7 +599,7 @@ void
 ClientRequestContext::hostHeaderVerify()
 {
     // Require a Host: header.
-    const char *host = http->request->header.getStr(HDR_HOST);
+    const char *host = http->request->header.getStr(Http::HdrType::HOST);
 
     if (!host) {
         // TODO: dump out the HTTP/1.1 error about missing host header.
@@ -696,14 +696,14 @@ ClientRequestContext::clientAccessCheck()
 #if FOLLOW_X_FORWARDED_FOR
     if (!http->request->flags.doneFollowXff() &&
             Config.accessList.followXFF &&
-            http->request->header.has(HDR_X_FORWARDED_FOR)) {
+            http->request->header.has(Http::HdrType::X_FORWARDED_FOR)) {
 
         /* we always trust the direct client address for actual use */
         http->request->indirect_client_addr = http->request->client_addr;
         http->request->indirect_client_addr.port(0);
 
         /* setup the XFF iterator for processing */
-        http->request->x_forwarded_for_iterator = http->request->header.getList(HDR_X_FORWARDED_FOR);
+        http->request->x_forwarded_for_iterator = http->request->header.getList(Http::HdrType::X_FORWARDED_FOR);
 
         /* begin by checking to see if we trust direct client enough to walk XFF */
         acl_checklist = clientAclChecklistCreate(Config.accessList.followXFF, http);
@@ -1016,19 +1016,19 @@ clientCheckPinning(ClientHttpRequest * http)
      * is already pinned if it was pinned earlier due to proxy auth
      */
     if (!request->flags.connectionAuth) {
-        if (req_hdr->has(HDR_AUTHORIZATION) || req_hdr->has(HDR_PROXY_AUTHORIZATION)) {
+        if (req_hdr->has(Http::HdrType::AUTHORIZATION) || req_hdr->has(Http::HdrType::PROXY_AUTHORIZATION)) {
             HttpHeaderPos pos = HttpHeaderInitPos;
             HttpHeaderEntry *e;
             int may_pin = 0;
             while ((e = req_hdr->getEntry(&pos))) {
-                if (e->id == HDR_AUTHORIZATION || e->id == HDR_PROXY_AUTHORIZATION) {
+                if (e->id == Http::HdrType::AUTHORIZATION || e->id == Http::HdrType::PROXY_AUTHORIZATION) {
                     const char *value = e->value.rawBuf();
                     if (strncasecmp(value, "NTLM ", 5) == 0
                             ||
                             strncasecmp(value, "Negotiate ", 10) == 0
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
-                        if (e->id == HDR_AUTHORIZATION) {
+                        if (e->id == Http::HdrType::AUTHORIZATION) {
                             request->flags.connectionAuth = true;
                             may_pin = 1;
                         } else {
@@ -1055,7 +1055,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     const char *str;
 
     request->imslen = -1;
-    request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
+    request->ims = req_hdr->getTime(Http::HdrType::IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
         request->flags.ims = true;
@@ -1066,8 +1066,8 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
                 no_cache=true;
 
             // RFC 2616: treat Pragma:no-cache as if it was Cache-Control:no-cache when Cache-Control is missing
-        } else if (req_hdr->has(HDR_PRAGMA))
-            no_cache = req_hdr->hasListMember(HDR_PRAGMA,"no-cache",',');
+        } else if (req_hdr->has(Http::HdrType::PRAGMA))
+            no_cache = req_hdr->hasListMember(Http::HdrType::PRAGMA,"no-cache",',');
 
         /*
         * Work around for supporting the Reload button in IE browsers when Squid
@@ -1078,7 +1078,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         */
         if (Config.onoff.ie_refresh) {
             if (http->flags.accel && request->flags.ims) {
-                if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
+                if ((str = req_hdr->getStr(Http::HdrType::USER_AGENT))) {
                     if (strstr(str, "MSIE 5.01") != NULL)
                         no_cache=true;
                     else if (strstr(str, "MSIE 5.0") != NULL)
@@ -1136,21 +1136,21 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
      * If these headers appear on any other type of request, delete them now.
      */
     else {
-        req_hdr->delById(HDR_RANGE);
-        req_hdr->delById(HDR_REQUEST_RANGE);
+        req_hdr->delById(Http::HdrType::RANGE);
+        req_hdr->delById(Http::HdrType::REQUEST_RANGE);
         request->ignoreRange("neither HEAD nor GET");
     }
 
-    if (req_hdr->has(HDR_AUTHORIZATION))
+    if (req_hdr->has(Http::HdrType::AUTHORIZATION))
         request->flags.auth = true;
 
     clientCheckPinning(http);
 
     if (!request->url.userInfo().isEmpty())
         request->flags.auth = true;
 
-    if (req_hdr->has(HDR_VIA)) {
-        String s = req_hdr->getList(HDR_VIA);
+    if (req_hdr->has(Http::HdrType::VIA)) {
+        String s = req_hdr->getList(Http::HdrType::VIA);
         /*
          * ThisCache cannot be a member of Via header, "1.1 ThisCache" can.
          * Note ThisCache2 has a space prepended to the hostname so we don't
@@ -1173,8 +1173,8 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 
 #if USE_FORW_VIA_DB
 
-    if (req_hdr->has(HDR_X_FORWARDED_FOR)) {
-        String s = req_hdr->getList(HDR_X_FORWARDED_FOR);
+    if (req_hdr->has(Http::HdrType::X_FORWARDED_FOR)) {
+        String s = req_hdr->getList(Http::HdrType::X_FORWARDED_FOR);
         fvdbCountForw(s.termedBuf());
         s.clean();
     }
@@ -449,7 +449,7 @@ sameUrlHosts(const char *url1, const char *url2)
 
 // purges entries that match the value of a given HTTP [response] header
 static void
-purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hdr_type hdr)
+purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, Http::HdrType hdr)
 {
     const char *hdrUrl, *absUrl;
 
@@ -497,8 +497,8 @@ Client::maybePurgeOthers()
     const char *reqUrl = tmp.c_str();
     debugs(88, 5, "maybe purging due to " << request->method << ' ' << tmp);
     purgeEntriesByUrl(request, reqUrl);
-    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
-    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, Http::HdrType::LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, Http::HdrType::CONTENT_LOCATION);
 }
 
 /// called when we have final (possibly adapted) reply headers; kids extend
@@ -1045,7 +1045,7 @@ Ftp::Gateway::checkAuth(const HttpHeader * req_hdr)
 
 #if HAVE_AUTH_MODULE_BASIC
     /* Check HTTP Authorization: headers (better than defaults, but less than URL) */
-    const SBuf auth(req_hdr->getAuth(HDR_AUTHORIZATION, "Basic"));
+    const SBuf auth(req_hdr->getAuth(Http::HdrType::AUTHORIZATION, "Basic"));
     if (!auth.isEmpty()) {
         flags.authenticated = 1;
         loginParser(auth, false);
@@ -2045,7 +2045,7 @@ ftpSendStor(Ftp::Gateway * ftpState)
         snprintf(cbuf, CTRL_BUFLEN, "STOR %s\r\n", ftpState->filepath);
         ftpState->writeCommand(cbuf);
         ftpState->state = Ftp::Client::SENT_STOR;
-    } else if (ftpState->request->header.getInt64(HDR_CONTENT_LENGTH) > 0) {
+    } else if (ftpState->request->header.getInt64(Http::HdrType::CONTENT_LENGTH) > 0) {
         /* File upload without a filename. use STOU to generate one */
         snprintf(cbuf, CTRL_BUFLEN, "STOU\r\n");
         ftpState->writeCommand(cbuf);
@@ -2605,7 +2605,7 @@ Ftp::Gateway::appendSuccessHeader()
 
     /* additional info */
     if (mime_enc)
-        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
     setVirginReply(reply);
     adaptOrFinalizeReply();
@@ -396,8 +396,8 @@ Ftp::Relay::createHttpReply(const Http::StatusCode httpStatus, const int64_t cle
     HttpReply *const reply = Ftp::HttpReplyWrapper(ctrl.replycode, ctrl.last_reply, httpStatus, clen);
     if (ctrl.message) {
         for (wordlist *W = ctrl.message; W && W->next; W = W->next)
-            reply->header.putStr(HDR_FTP_PRE, httpHeaderQuoteString(W->key).c_str());
-        // no hdrCacheInit() is needed for after HDR_FTP_PRE addition
+            reply->header.putStr(Http::HdrType::FTP_PRE, httpHeaderQuoteString(W->key).c_str());
+        // no hdrCacheInit() is needed for after Http::HdrType::FTP_PRE addition
     }
     return reply;
 }
@@ -473,16 +473,16 @@ Ftp::Relay::readGreeting()
 void
 Ftp::Relay::sendCommand()
 {
-    if (!fwd->request->header.has(HDR_FTP_COMMAND)) {
+    if (!fwd->request->header.has(Http::HdrType::FTP_COMMAND)) {
         abortTransaction("Internal error: FTP relay request with no command");
         return;
     }
 
     HttpHeader &header = fwd->request->header;
-    assert(header.has(HDR_FTP_COMMAND));
-    const String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
-    assert(header.has(HDR_FTP_ARGUMENTS));
-    const String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+    assert(header.has(Http::HdrType::FTP_COMMAND));
+    const String &cmd = header.findEntry(Http::HdrType::FTP_COMMAND)->value;
+    assert(header.has(Http::HdrType::FTP_ARGUMENTS));
+    const String &params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)->value;
 
     if (params.size() > 0)
         debugs(9, 5, "command: " << cmd << ", parameters: " << params);
@@ -31,34 +31,6 @@ typedef enum {
     PEER_MULTICAST
 } peer_t;
 
-typedef enum {
-    CC_BADHDR = -1,
-    CC_PUBLIC = 0,
-    CC_PRIVATE,
-    CC_NO_CACHE,
-    CC_NO_STORE,
-    CC_NO_TRANSFORM,
-    CC_MUST_REVALIDATE,
-    CC_PROXY_REVALIDATE,
-    CC_MAX_AGE,
-    CC_S_MAXAGE,
-    CC_MAX_STALE,
-    CC_MIN_FRESH,
-    CC_ONLY_IF_CACHED,
-    CC_STALE_IF_ERROR,
-    CC_OTHER,
-    CC_ENUM_END
-} http_hdr_cc_type;
-
-typedef enum {
-    SC_NO_STORE,
-    SC_NO_STORE_REMOTE,
-    SC_MAX_AGE,
-    SC_CONTENT,
-    SC_OTHER,
-    SC_ENUM_END
-} http_hdr_sc_type;
-
 typedef enum _mem_status_t {
     NOT_IN_MEMORY,
     IN_MEMORY
@@ -418,7 +418,7 @@ TemplateFile::loadFor(const HttpRequest *request)
     if (loaded()) // already loaded?
         return true;
 
-    if (!request || !request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr) )
+    if (!request || !request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr) )
         return false;
 
     char lang[256];
@@ -1149,10 +1149,10 @@ ErrorState::BuildHttpReply()
             MemBuf redirect_location;
             redirect_location.init();
             DenyInfoLocation(name, request, redirect_location);
-            httpHeaderPutStrf(&rep->header, HDR_LOCATION, "%s", redirect_location.content() );
+            httpHeaderPutStrf(&rep->header, Http::HdrType::LOCATION, "%s", redirect_location.content() );
         }
 
-        httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
+        httpHeaderPutStrf(&rep->header, Http::HdrType::X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
     } else {
         MemBuf *content = BuildContent();
         rep->setHeaders(httpStatus, NULL, "text/html;charset=utf-8", content->contentSize(), 0, -1);
@@ -1164,7 +1164,7 @@ ErrorState::BuildHttpReply()
          * might want to know. Someone _will_ want to know OTOH, the first
          * X-CACHE-MISS entry should tell us who.
          */
-        httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d", name, xerrno);
+        httpHeaderPutStrf(&rep->header, Http::HdrType::X_SQUID_ERROR, "%s %d", name, xerrno);
 
 #if USE_ERR_LOCALES
         /*
@@ -1175,20 +1175,20 @@ ErrorState::BuildHttpReply()
          */
         if (!Config.errorDirectory) {
             /* We 'negotiated' this ONLY from the Accept-Language. */
-            rep->header.delById(HDR_VARY);
-            rep->header.putStr(HDR_VARY, "Accept-Language");
+            rep->header.delById(Http::HdrType::VARY);
+            rep->header.putStr(Http::HdrType::VARY, "Accept-Language");
         }
 
         /* add the Content-Language header according to RFC section 14.12 */
         if (err_language) {
-            rep->header.putStr(HDR_CONTENT_LANGUAGE, err_language);
+            rep->header.putStr(Http::HdrType::CONTENT_LANGUAGE, err_language);
         } else
 #endif /* USE_ERROR_LOCALES */
         {
             /* default templates are in English */
             /* language is known unless error_directory override used */
             if (!Config.errorDirectory)
-                rep->header.putStr(HDR_CONTENT_LANGUAGE, "en");
+                rep->header.putStr(Http::HdrType::CONTENT_LANGUAGE, "en");
         }
 
         rep->body.setMb(content);
@@ -839,10 +839,10 @@ ESIContextNew (HttpReply *rep, clientStreamNode *thisNode, ClientHttpRequest *ht
         /* remove specific headers for ESI to prevent
          * downstream cache confusion */
         HttpHeader *hdr = &rep->header;
-        hdr->delById(HDR_ACCEPT_RANGES);
-        hdr->delById(HDR_ETAG);
-        hdr->delById(HDR_CONTENT_LENGTH);
-        hdr->delById(HDR_CONTENT_MD5);
+        hdr->delById(Http::HdrType::ACCEPT_RANGES);
+        hdr->delById(Http::HdrType::ETAG);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
+        hdr->delById(Http::HdrType::CONTENT_MD5);
         rv->tree = new esiSequence (rv, true);
         rv->thisNode = thisNode;
         rv->http = http;
@@ -319,8 +319,8 @@ ESIVariableUserAgent::ESIVariableUserAgent(ESIVarState &state)
      * In future, this may be better implemented as a regexp.
      */
 
-    if (state.header().has(HDR_USER_AGENT)) {
-        char const *s = state.header().getStr(HDR_USER_AGENT);
+    if (state.header().has(Http::HdrType::USER_AGENT)) {
+        char const *s = state.header().getStr(Http::HdrType::USER_AGENT);
         UserOs = identifyOs(s);
         char const *t, *t1;
 
@@ -376,11 +376,11 @@ ESIVariableCookie::eval (ESIVarState &state, char const *subref, char const *fou
     const char *s = NULL;
     state.cookieUsed();
 
-    if (state.header().has(HDR_COOKIE)) {
+    if (state.header().has(Http::HdrType::COOKIE)) {
         if (!subref)
-            s = state.header().getStr (HDR_COOKIE);
+            s = state.header().getStr (Http::HdrType::COOKIE);
         else {
-            String S = state.header().getListMember (HDR_COOKIE, subref, ';');
+            String S = state.header().getListMember (Http::HdrType::COOKIE, subref, ';');
 
             if (S.size())
                 ESISegment::ListAppend (state.getOutput(), S.rawBuf(), S.size());
@@ -400,8 +400,8 @@ ESIVariableHost::eval (ESIVarState &state, char const *subref, char const *found
     const char *s = NULL;
     state.hostUsed();
 
-    if (!subref && state.header().has(HDR_HOST)) {
-        s = state.header().getStr (HDR_HOST);
+    if (!subref && state.header().has(Http::HdrType::HOST)) {
+        s = state.header().getStr (Http::HdrType::HOST);
     } else
         s = found_default;
 
@@ -414,12 +414,12 @@ ESIVariableLanguage::eval (ESIVarState &state, char const *subref, char const *f
     char const *s = NULL;
     state.languageUsed();
 
-    if (state.header().has(HDR_ACCEPT_LANGUAGE)) {
+    if (state.header().has(Http::HdrType::ACCEPT_LANGUAGE)) {
         if (!subref) {
-            String S (state.header().getList (HDR_ACCEPT_LANGUAGE));
+            String S (state.header().getList (Http::HdrType::ACCEPT_LANGUAGE));
             ESISegment::ListAppend (state.getOutput(), S.rawBuf(), S.size());
         } else {
-            if (state.header().hasListMember (HDR_ACCEPT_LANGUAGE, subref, ',')) {
+            if (state.header().hasListMember (Http::HdrType::ACCEPT_LANGUAGE, subref, ',')) {
                 s = "true";
             } else {
                 s = "false";
@@ -463,8 +463,8 @@ ESIVariableReferer::eval (ESIVarState &state, char const *subref, char const *fo
     const char *s = NULL;
     state.refererUsed();
 
-    if (!subref && state.header().has(HDR_REFERER))
-        s = state.header().getStr (HDR_REFERER);
+    if (!subref && state.header().has(Http::HdrType::REFERER))
+        s = state.header().getStr (Http::HdrType::REFERER);
     else
         s = found_default;
 
@@ -477,9 +477,9 @@ ESIVariableUserAgent::eval (ESIVarState &state, char const *subref, char const *
     char const *s = NULL;
     state.useragentUsed();
 
-    if (state.header().has(HDR_USER_AGENT)) {
+    if (state.header().has(Http::HdrType::USER_AGENT)) {
         if (!subref)
-            s = state.header().getStr (HDR_USER_AGENT);
+            s = state.header().getStr (Http::HdrType::USER_AGENT);
         else {
             if (!strcmp (subref, "os")) {
                 s = esiUserOs[UserOs];
@@ -830,10 +830,10 @@ ESIVarState::buildVary (HttpReply *rep)
     if (!tempstr[0])
         return;
 
-    String strVary (rep->header.getList (HDR_VARY));
+    String strVary (rep->header.getList (Http::HdrType::VARY));
 
     if (!strVary.size() || strVary[0] != '*') {
-        rep->header.putStr (HDR_VARY, tempstr);
+        rep->header.putStr (Http::HdrType::VARY, tempstr);
     }
 }
 
@@ -73,7 +73,7 @@ class external_acl_format : public RefCountable
 public:
     typedef RefCount<external_acl_format> Pointer;
 
-    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(HDR_BAD_HDR) {}
+    external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(Http::HdrType::BAD_HDR) {}
     ~external_acl_format() {
         xfree(header);
         xfree(member);
@@ -84,7 +84,7 @@ class external_acl_format : public RefCountable
     char *header;
     char *member;
     char separator;
-    http_hdr_type header_id;
+    Http::HdrType header_id;
 };
 
 class external_acl
@@ -244,7 +244,7 @@ parse_header_token(external_acl_format::Pointer format, char *header, const Form
     }
 
     format->header = xstrdup(header);
-    format->header_id = httpHeaderIdByNameDef(header, strlen(header));
+    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header));
 }
 
 void
@@ -1010,15 +1010,15 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
         break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER:
-            if (format->header_id == -1)
+            if (format->header_id == Http::HdrType::BAD_HDR)
                 sb = request->header.getByName(format->header);
             else
                 sb = request->header.getStrOrList(format->header_id);
             str = sb.termedBuf();
             break;
 
         case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-            if (format->header_id == -1)
+            if (format->header_id == Http::HdrType::BAD_HDR)
                 sb = request->header.getByNameListMember(format->header, format->member, format->separator);
             else
                 sb = request->header.getListMember(format->header_id, format->member, format->separator);
@@ -1027,7 +1027,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
         case Format::LFT_REPLY_HEADER:
             if (reply) {
-                if (format->header_id == -1)
+                if (format->header_id == Http::HdrType::BAD_HDR)
                     sb = reply->header.getByName(format->header);
                 else
                     sb = reply->header.getStrOrList(format->header_id);
@@ -1037,7 +1037,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
         case Format::LFT_REPLY_HEADER_ELEM:
             if (reply) {
-                if (format->header_id == -1)
+                if (format->header_id == Http::HdrType::BAD_HDR)
                     sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
                 else
                     sb = reply->header.getListMember(format->header_id, format->member, format->separator);
@@ -36,18 +36,18 @@ Ftp::HttpReplyWrapper(const int ftpStatus, const char *ftpReason, const Http::St
     reply->sline.set(httpVersion, httpStatus);
 
     HttpHeader &header = reply->header;
-    header.putTime(HDR_DATE, squid_curtime);
+    header.putTime(Http::HdrType::DATE, squid_curtime);
     {
         HttpHdrCc cc;
         cc.Private(String());
         header.putCc(&cc);
     }
     if (ftpStatus > 0)
-        header.putInt(HDR_FTP_STATUS, ftpStatus);
+        header.putInt(Http::HdrType::FTP_STATUS, ftpStatus);
     if (ftpReason)
-        header.putStr(HDR_FTP_REASON, ftpReason);
+        header.putStr(Http::HdrType::FTP_REASON, ftpReason);
     if (clen >= 0)
-        header.putInt64(HDR_CONTENT_LENGTH, clen);
+        header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     reply->hdrCacheInit();
     return reply;
 }
@@ -243,7 +243,7 @@ gopherMimeCreate(GopherStateData * gopherState)
     entry->buffer();
     reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, -1, -1, -2);
     if (mime_enc)
-        reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
+        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
     entry->replaceHttpReply(reply);
 }
@@ -843,9 +843,9 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         stuff.S.req_hdrs = spec->req_hdrs;
         stuff.S.reqHdrsSz = spec->reqHdrsSz;
         if (e)
-            hdr.putInt(HDR_AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
+            hdr.putInt(Http::HdrType::AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
         else
-            hdr.putInt(HDR_AGE, 0);
+            hdr.putInt(Http::HdrType::AGE, 0);
         MemBuf mb;
         mb.init();
         hdr.packInto(&mb);
@@ -856,10 +856,10 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         hdr.reset();
 
         if (e && e->expires > -1)
-            hdr.putTime(HDR_EXPIRES, e->expires);
+            hdr.putTime(Http::HdrType::EXPIRES, e->expires);
 
         if (e && e->lastmod > -1)
-            hdr.putTime(HDR_LAST_MODIFIED, e->lastmod);
+            hdr.putTime(Http::HdrType::LAST_MODIFIED, e->lastmod);
 
         hdr.packInto(&mb);
 
@@ -439,7 +439,7 @@ HttpStateData::cacheableReply()
      * continuous push replies.  These are generally dynamic and
      * probably should not be cachable
      */
-    if ((v = hdr->getStr(HDR_CONTENT_TYPE)))
+    if ((v = hdr->getStr(Http::HdrType::CONTENT_TYPE)))
         if (!strncasecmp(v, "multipart/x-mixed-replace", 25)) {
             debugs(22, 3, HERE << "NO because Content-Type:multipart/x-mixed-replace");
             return 0;
@@ -586,7 +586,7 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
     static String vstr;
 
     vstr.clean();
-    vary = reply->header.getList(HDR_VARY);
+    vary = reply->header.getList(Http::HdrType::VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -619,7 +619,7 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
 #if X_ACCELERATOR_VARY
 
     pos = NULL;
-    vary = reply->header.getList(HDR_X_ACCELERATOR_VARY);
+    vary = reply->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
         char *name = (char *)xmalloc(ilen + 1);
@@ -912,10 +912,10 @@ bool HttpStateData::peerSupportsConnectionPinning() const
       reply and has in its list the "Session-Based-Authentication"
       which means that the peer supports connection pinning.
      */
-    if (!hdr->has(HDR_PROXY_SUPPORT))
+    if (!hdr->has(Http::HdrType::PROXY_SUPPORT))
         return false;
 
-    header = hdr->getStrOrList(HDR_PROXY_SUPPORT);
+    header = hdr->getStrOrList(Http::HdrType::PROXY_SUPPORT);
     /* XXX This ought to be done in a case-insensitive manner */
     rc = (strstr(header.termedBuf(), "Session-Based-Authentication") != NULL);
 
@@ -941,9 +941,9 @@ HttpStateData::haveParsedReplyHeaders()
         httpMaybeRemovePublic(entry, rep->sline.status());
 
     bool varyFailure = false;
-    if (rep->header.has(HDR_VARY)
+    if (rep->header.has(Http::HdrType::VARY)
 #if X_ACCELERATOR_VARY
-            || rep->header.has(HDR_X_ACCELERATOR_VARY)
+            || rep->header.has(Http::HdrType::HDR_X_ACCELERATOR_VARY)
 #endif
        ) {
         const char *vary = httpMakeVaryMark(request, rep);
@@ -1018,8 +1018,8 @@ HttpStateData::haveParsedReplyHeaders()
 
             /* HACK: Pragma: no-cache in _replies_ is not documented in HTTP,
              * but servers like "Active Imaging Webcast/2.0" sure do use it */
-            if (rep->header.has(HDR_PRAGMA) &&
-                    rep->header.hasListMember(HDR_PRAGMA,"no-cache",','))
+            if (rep->header.has(Http::HdrType::PRAGMA) &&
+                    rep->header.hasListMember(Http::HdrType::PRAGMA,"no-cache",','))
                 EBIT_SET(entry->flags, ENTRY_REVALIDATE);
         }
 #endif
@@ -1655,7 +1655,7 @@ HttpStateData::doneWithServer() const
 static void
 httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHeader * hdr_out, const HttpStateFlags &flags)
 {
-    http_hdr_type header = flags.originpeer ? HDR_AUTHORIZATION : HDR_PROXY_AUTHORIZATION;
+    Http::HdrType header = flags.originpeer ? Http::HdrType::AUTHORIZATION : Http::HdrType::PROXY_AUTHORIZATION;
 
     /* Nothing to do unless we are forwarding to a peer */
     if (!request->flags.proxying)
@@ -1674,8 +1674,8 @@ httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHe
         return;
 
     /* PROXYPASS is a special case, single-signon to servers with the proxy password (basic only) */
-    if (flags.originpeer && strcmp(request->peer_login, "PROXYPASS") == 0 && hdr_in->has(HDR_PROXY_AUTHORIZATION)) {
-        const char *auth = hdr_in->getStr(HDR_PROXY_AUTHORIZATION);
+    if (flags.originpeer && strcmp(request->peer_login, "PROXYPASS") == 0 && hdr_in->has(Http::HdrType::PROXY_AUTHORIZATION)) {
+        const char *auth = hdr_in->getStr(Http::HdrType::PROXY_AUTHORIZATION);
 
         if (auth && strncasecmp(auth, "basic ", 6) == 0) {
             hdr_out->putStr(header, auth);
@@ -1767,18 +1767,18 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* use our IMS header if the cached entry has Last-Modified time */
     if (request->lastmod > -1)
-        hdr_out->putTime(HDR_IF_MODIFIED_SINCE, request->lastmod);
+        hdr_out->putTime(Http::HdrType::IF_MODIFIED_SINCE, request->lastmod);
 
     // Add our own If-None-Match field if the cached entry has a strong ETag.
     // copyOneHeaderFromClientsideRequestToUpstreamRequest() adds client ones.
     if (request->etag.size() > 0) {
-        hdr_out->addEntry(new HttpHeaderEntry(HDR_IF_NONE_MATCH, NULL,
+        hdr_out->addEntry(new HttpHeaderEntry(Http::HdrType::IF_NONE_MATCH, NULL,
                                               request->etag.termedBuf()));
     }
 
     bool we_do_ranges = decideIfWeDoRanges (request);
 
-    String strConnection (hdr_in->getList(HDR_CONNECTION));
+    String strConnection (hdr_in->getList(Http::HdrType::CONNECTION));
 
     while ((e = hdr_in->getEntry(&pos)))
         copyOneHeaderFromClientsideRequestToUpstreamRequest(e, strConnection, request, hdr_out, we_do_ranges, flags);
@@ -1797,31 +1797,31 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     /* append Via */
     if (Config.onoff.via) {
         String strVia;
-        strVia = hdr_in->getList(HDR_VIA);
+        strVia = hdr_in->getList(Http::HdrType::VIA);
         snprintf(bbuf, BBUF_SZ, "%d.%d %s",
                  request->http_ver.major,
                  request->http_ver.minor, ThisCache);
         strListAdd(&strVia, bbuf, ',');
-        hdr_out->putStr(HDR_VIA, strVia.termedBuf());
+        hdr_out->putStr(Http::HdrType::VIA, strVia.termedBuf());
         strVia.clean();
     }
 
     if (request->flags.accelerated) {
         /* Append Surrogate-Capabilities */
-        String strSurrogate(hdr_in->getList(HDR_SURROGATE_CAPABILITY));
+        String strSurrogate(hdr_in->getList(Http::HdrType::SURROGATE_CAPABILITY));
 #if USE_SQUID_ESI
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0 ESI/1.0\"", Config.Accel.surrogate_id);
 #else
         snprintf(bbuf, BBUF_SZ, "%s=\"Surrogate/1.0\"", Config.Accel.surrogate_id);
 #endif
         strListAdd(&strSurrogate, bbuf, ',');
-        hdr_out->putStr(HDR_SURROGATE_CAPABILITY, strSurrogate.termedBuf());
+        hdr_out->putStr(Http::HdrType::SURROGATE_CAPABILITY, strSurrogate.termedBuf());
     }
 
     /** \pre Handle X-Forwarded-For */
     if (strcmp(opt_forwarded_for, "delete") != 0) {
 
-        String strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
+        String strFwd = hdr_in->getList(Http::HdrType::X_FORWARDED_FOR);
 
         if (strFwd.size() > 65536/2) {
             // There is probably a forwarding loop with Via detection disabled.
@@ -1855,22 +1855,22 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
                 strFwd = request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN);
         }
         if (strFwd.size() > 0)
-            hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.termedBuf());
+            hdr_out->putStr(Http::HdrType::X_FORWARDED_FOR, strFwd.termedBuf());
     }
     /** If set to DELETE - do not copy through. */
 
     /* append Host if not there already */
-    if (!hdr_out->has(HDR_HOST)) {
+    if (!hdr_out->has(Http::HdrType::HOST)) {
         if (request->peer_domain) {
-            hdr_out->putStr(HDR_HOST, request->peer_domain);
+            hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);
         } else {
             SBuf authority = request->url.authority();
-            hdr_out->putStr(HDR_HOST, authority.c_str());
+            hdr_out->putStr(Http::HdrType::HOST, authority.c_str());
         }
     }
 
     /* append Authorization if known in URL, not in header and going direct */
-    if (!hdr_out->has(HDR_AUTHORIZATION)) {
+    if (!hdr_out->has(Http::HdrType::AUTHORIZATION)) {
         if (!request->flags.proxying && !request->url.userInfo().isEmpty()) {
             static uint8_t result[base64_encode_len(MAX_URL*2)]; // should be big enough for a single URI segment
             struct base64_encode_ctx ctx;
@@ -1879,7 +1879,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
             blen += base64_encode_final(&ctx, result+blen);
             result[blen] = '\0';
             if (blen)
-                httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %.*s", (int)blen, result);
+                httpHeaderPutStrf(hdr_out, Http::HdrType::AUTHORIZATION, "Basic %.*s", (int)blen, result);
         }
     }
 
@@ -1896,7 +1896,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 #if 0 /* see bug 2330 */
         /* Set no-cache if determined needed but not found */
         if (request->flags.nocache)
-            EBIT_SET(cc->mask, CC_NO_CACHE);
+            EBIT_SET(cc->mask, HttpHdrCcType::CC_NO_CACHE);
 #endif
 
         /* Add max-age only without no-cache */
@@ -1917,19 +1917,19 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* maybe append Connection: keep-alive */
     if (flags.keepalive) {
-        hdr_out->putStr(HDR_CONNECTION, "keep-alive");
+        hdr_out->putStr(Http::HdrType::CONNECTION, "keep-alive");
     }
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
         if (flags.front_end_https == 1 || request->url.getScheme() == AnyP::PROTO_HTTPS)
-            hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
+            hdr_out->putStr(Http::HdrType::FRONT_END_HTTPS, "On");
     }
 
     if (flags.chunked_request) {
         // Do not just copy the original value so that if the client-side
         // starts decode other encodings, this code may remain valid.
-        hdr_out->putStr(HDR_TRANSFER_ENCODING, "chunked");
+        hdr_out->putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     /* Now mangle the headers. */
@@ -1955,7 +1955,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
     /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid should not pass on. */
 
-    case HDR_PROXY_AUTHORIZATION:
+    case Http::HdrType::PROXY_AUTHORIZATION:
         /** \par Proxy-Authorization:
          * Only pass on proxy authentication to peers for which
          * authentication forwarding is explicitly enabled
@@ -1970,18 +1970,18 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
     /** \par RFC 2616 sect 13.5.1 - Hop-by-Hop headers which Squid does not pass on. */
 
-    case HDR_CONNECTION:          /** \par Connection: */
-    case HDR_TE:                  /** \par TE: */
-    case HDR_KEEP_ALIVE:          /** \par Keep-Alive: */
-    case HDR_PROXY_AUTHENTICATE:  /** \par Proxy-Authenticate: */
-    case HDR_TRAILER:             /** \par Trailer: */
-    case HDR_UPGRADE:             /** \par Upgrade: */
-    case HDR_TRANSFER_ENCODING:   /** \par Transfer-Encoding: */
+    case Http::HdrType::CONNECTION:          /** \par Connection: */
+    case Http::HdrType::TE:                  /** \par TE: */
+    case Http::HdrType::KEEP_ALIVE:          /** \par Keep-Alive: */
+    case Http::HdrType::PROXY_AUTHENTICATE:  /** \par Proxy-Authenticate: */
+    case Http::HdrType::TRAILER:             /** \par Trailer: */
+    case Http::HdrType::UPGRADE:             /** \par Upgrade: */
+    case Http::HdrType::TRANSFER_ENCODING:   /** \par Transfer-Encoding: */
         break;
 
     /** \par OTHER headers I haven't bothered to track down yet. */
 
-    case HDR_AUTHORIZATION:
+    case Http::HdrType::AUTHORIZATION:
         /** \par WWW-Authorization:
          * Pass on WWW authentication */
 
@@ -2001,25 +2001,25 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
         break;
 
-    case HDR_HOST:
+    case Http::HdrType::HOST:
         /** \par Host:
          * Normally Squid rewrites the Host: header.
          * However, there is one case when we don't: If the URL
          * went through our redirector and the admin configured
          * 'redir_rewrites_host' to be off.
          */
         if (request->peer_domain)
-            hdr_out->putStr(HDR_HOST, request->peer_domain);
+            hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);
         else if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
             hdr_out->addEntry(e->clone());
         else {
             SBuf authority = request->url.authority();
-            hdr_out->putStr(HDR_HOST, authority.c_str());
+            hdr_out->putStr(Http::HdrType::HOST, authority.c_str());
         }
 
         break;
 
-    case HDR_IF_MODIFIED_SINCE:
+    case Http::HdrType::IF_MODIFIED_SINCE:
         /** \par If-Modified-Since:
          * append unless we added our own,
          * but only if cache_miss_revalidate is enabled, or
@@ -2028,13 +2028,13 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          * \note at most one client's If-Modified-Since header can pass through
          */
         // XXX: need to check and cleanup the auth case so cacheable auth requests get cached.
-        if (hdr_out->has(HDR_IF_MODIFIED_SINCE))
+        if (hdr_out->has(Http::HdrType::IF_MODIFIED_SINCE))
             break;
         else if (Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_IF_NONE_MATCH:
+    case Http::HdrType::IF_NONE_MATCH:
         /** \par If-None-Match:
          * append if the wildcard '*' special case value is present, or
          *   cache_miss_revalidate is disabled, or
@@ -2043,23 +2043,23 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          * \note this header lists a set of responses for the server to elide sending. Squid added values are extending that set.
          */
         // XXX: need to check and cleanup the auth case so cacheable auth requests get cached.
-        if (hdr_out->hasListMember(HDR_IF_MATCH, "*", ',') || Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
+        if (hdr_out->hasListMember(Http::HdrType::IF_MATCH, "*", ',') || Config.onoff.cache_miss_revalidate || !request->flags.cachable || request->flags.auth)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_MAX_FORWARDS:
+    case Http::HdrType::MAX_FORWARDS:
         /** \par Max-Forwards:
          * pass only on TRACE or OPTIONS requests */
         if (request->method == Http::METHOD_TRACE || request->method == Http::METHOD_OPTIONS) {
             const int64_t hops = e->getInt64();
 
             if (hops > 0)
-                hdr_out->putInt64(HDR_MAX_FORWARDS, hops - 1);
+                hdr_out->putInt64(Http::HdrType::MAX_FORWARDS, hops - 1);
         }
 
         break;
 
-    case HDR_VIA:
+    case Http::HdrType::VIA:
         /** \par Via:
          * If Via is disabled then forward any received header as-is.
          * Otherwise leave for explicit updated addition later. */
@@ -2069,37 +2069,37 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
 
         break;
 
-    case HDR_RANGE:
+    case Http::HdrType::RANGE:
 
-    case HDR_IF_RANGE:
+    case Http::HdrType::IF_RANGE:
 
-    case HDR_REQUEST_RANGE:
+    case Http::HdrType::REQUEST_RANGE:
         /** \par Range:, If-Range:, Request-Range:
          * Only pass if we accept ranges */
         if (!we_do_ranges)
             hdr_out->addEntry(e->clone());
 
         break;
 
-    case HDR_PROXY_CONNECTION: // SHOULD ignore. But doing so breaks things.
+    case Http::HdrType::PROXY_CONNECTION: // SHOULD ignore. But doing so breaks things.
         break;
 
-    case HDR_CONTENT_LENGTH:
+    case Http::HdrType::CONTENT_LENGTH:
         // pass through unless we chunk; also, keeping this away from default
         // prevents request smuggling via Connection: Content-Length tricks
         if (!flags.chunked_request)
             hdr_out->addEntry(e->clone());
         break;
 
-    case HDR_X_FORWARDED_FOR:
+    case Http::HdrType::X_FORWARDED_FOR:
 
-    case HDR_CACHE_CONTROL:
+    case Http::HdrType::CACHE_CONTROL:
         /** \par X-Forwarded-For:, Cache-Control:
          * handled specially by Squid, so leave off for now.
          * append these after the loop if needed */
         break;
 
-    case HDR_FRONT_END_HTTPS:
+    case Http::HdrType::FRONT_END_HTTPS:
         /** \par Front-End-Https:
          * Pass thru only if peer is configured with front-end-https */
         if (!flags.front_end_https)
@@ -2175,7 +2175,7 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
 
         if (request->flags.pinned && request->flags.connectionAuth)
             request->flags.authSent = true;
-        else if (hdr.has(HDR_AUTHORIZATION))
+        else if (hdr.has(Http::HdrType::AUTHORIZATION))
             request->flags.authSent = true;
 
         hdr.packInto(mb);
@@ -19,6 +19,7 @@ libsquid_http_la_SOURCES = \
 	MethodType.h \
 	ProtocolVersion.h \
 	RegisteredHeaders.h \
+	RegisteredHeaders.cc \
 	RequestMethod.cc \
 	RequestMethod.h \
 	StatusCode.cc \
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "RegisteredHeaders.h"
+
+#include <ostream>
+
+namespace Http
+{
+/*
+ * A table with major attributes for every known field.
+ *
+ * Invariant on this table:
+ * for each index in HeaderTable, (int)HeaderTable[index] = index
+ *
+ * To be kept in sync with Http::HdrType
+ */
+const HeaderTableRecord HeaderTable[] = {
+    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr},
+    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr},
+    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr},
+    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr},
+    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr},
+    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt},
+    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr},
+    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr},
+    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
+    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr},    /* for now */
+    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc},
+    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr},
+    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr},
+    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr},  /* for now */
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr},
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr},
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64},
+    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr},
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr},    /* for now */
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange},
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr},
+    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr},
+    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr},
+    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123},
+    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag},
+    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr},
+    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123},
+    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr},
+    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr},
+    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr},
+    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr}, /* for now */
+    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr},  /* for now */
+    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
+    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr},    /* for now */
+    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag},
+    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr},
+    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr},
+    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123},
+    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr},
+    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr},
+    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64},
+    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr},  /* for now */
+    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr},
+    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr},
+    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr},
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr},
+    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr},
+    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr},
+    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr},
+    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr},
+    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange},
+    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr},
+    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange}, /* usually matches Http::HdrType::RANGE */
+    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr},    /* for now (Http::HdrFieldType::ftDate_1123 or Http::HdrFieldType::ftInt!} */
+    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr},
+    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr},
+    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr},
+    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr},
+    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr},
+    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr},
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr},
+    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr},    /* for now. may need to crop */
+    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr},  /* for now ignore. may need to crop */
+    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr},    /* for now */
+    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr},
+    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr},  /* for now */
+    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr},    /* for now */
+    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr},    /* for now */
+    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr},
+    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr},
+    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr},
+    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr},
+    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr},
+    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr},
+#if X_ACCELERATOR_VARY
+    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr},
+#endif
+#if USE_ADAPTATION
+    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr},
+#endif
+    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr},
+    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc},
+    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr},
+    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr},
+    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr},
+    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr},
+    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt},
+    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr},
+    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr},    /* ':' will not allow matches */
+    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid}, /* ':' will not allow matches */
+    {nullptr, Http::HdrType::ENUM_END, Http::HdrFieldType::ftInvalid}    /* end of table */
+};
+
+const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable(Http::HdrType::BAD_HDR, HeaderTable);
+
+}; /* namespace Http */
+
+std::ostream&
+operator<< (std::ostream &s, Http::HdrType id)
+{
+	if (Http::any_HdrType_enum_value(id))
+		s << Http::HeaderTable[id].name << '[' << static_cast<int>(id) << ']';
+	else
+		s << "Invalid-Header[" << static_cast<int>(id) << ']';
+	return s;
+}
@@ -9,115 +9,183 @@
 #ifndef SQUID_HTTP_REGISTEREDHEADERS_H
 #define SQUID_HTTP_REGISTEREDHEADERS_H
 
+#include "base/LookupTable.h"
+#include <iosfwd>
+
+namespace Http
+{
 /// recognized or "known" header fields; and the RFC which defines them (or not)
 /// http://www.iana.org/assignments/message-headers/message-headers.xhtml
-typedef enum {
-    HDR_BAD_HDR = -1,
-    HDR_ACCEPT = 0,                     /**< RFC 7231 */
-    HDR_ACCEPT_CHARSET,                 /**< RFC 7231 */
-    HDR_ACCEPT_ENCODING,                /**< RFC 7231 */
-    /*HDR_ACCEPT_FEATURES,*/            /* RFC 2295 */
-    HDR_ACCEPT_LANGUAGE,                /**< RFC 7231 */
-    HDR_ACCEPT_RANGES,                  /**< RFC 7233 */
-    HDR_AGE,                            /**< RFC 7234 */
-    HDR_ALLOW,                          /**< RFC 7231 */
-    HDR_ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
-    HDR_AUTHENTICATION_INFO,            /**< RFC 2617 */
-    HDR_AUTHORIZATION,                  /**< RFC 7235, 4559 */
-    HDR_CACHE_CONTROL,                  /**< RFC 7234 */
-    HDR_CONNECTION,                     /**< RFC 7230 */
-    HDR_CONTENT_BASE,                   /**< obsoleted RFC 2068 */
-    HDR_CONTENT_DISPOSITION,            /**< RFC 2183, 6266 */
-    HDR_CONTENT_ENCODING,               /**< RFC 7231 */
-    HDR_CONTENT_LANGUAGE,               /**< RFC 7231 */
-    HDR_CONTENT_LENGTH,                 /**< RFC 7230 */
-    HDR_CONTENT_LOCATION,               /**< RFC 7231 */
-    HDR_CONTENT_MD5,                    /**< deprecated, RFC 2616 */
-    HDR_CONTENT_RANGE,                  /**< RFC 7233 */
-    HDR_CONTENT_TYPE,                   /**< RFC 7231 */
-    HDR_COOKIE,                         /**< RFC 6265 header we may need to erase */
-    HDR_COOKIE2,                        /**< obsolete RFC 2965 header we may need to erase */
-    HDR_DATE,                           /**< RFC 7231 */
-    /*HDR_DAV,*/                        /* RFC 2518 */
-    /*HDR_DEPTH,*/                      /* RFC 2518 */
-    /*HDR_DERIVED_FROM,*/               /* deprecated RFC 2068 */
-    /*HDR_DESTINATION,*/                /* RFC 2518 */
-    HDR_ETAG,                           /**< RFC 7232 */
-    HDR_EXPECT,                         /**< RFC 7231 */
-    HDR_EXPIRES,                        /**< RFC 7234 */
-    HDR_FORWARDED,                      /**< RFC 7239 */
-    HDR_FROM,                           /**< RFC 7231 */
-    HDR_HOST,                           /**< RFC 7230 */
-    HDR_HTTP2_SETTINGS,                 /**< RFC 7540 */
-    /*HDR_IF,*/                         /* RFC 2518 */
-    HDR_IF_MATCH,                       /**< RFC 7232 */
-    HDR_IF_MODIFIED_SINCE,              /**< RFC 7232 */
-    HDR_IF_NONE_MATCH,                  /**< RFC 7232 */
-    HDR_IF_RANGE,                       /**< RFC 7233 */
-    HDR_IF_UNMODIFIED_SINCE,            /**< RFC 7232 */
-    HDR_KEEP_ALIVE,                     /**< obsoleted RFC 2068 header we may need to erase */
-    HDR_KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
-    HDR_LAST_MODIFIED,                  /**< RFC 7232 */
-    HDR_LINK,                           /**< RFC 5988 */
-    HDR_LOCATION,                       /**< RFC 7231 */
-    /*HDR_LOCK_TOKEN,*/                 /* RFC 2518 */
-    HDR_MAX_FORWARDS,                   /**< RFC 7231 */
-    HDR_MIME_VERSION,                   /**< RFC 2045, 7231 */
-    HDR_NEGOTIATE,                      /**< experimental RFC 2295. Why only this one from 2295? */
-    /*HDR_OVERWRITE,*/                  /* RFC 2518 */
-    HDR_ORIGIN,                         /* CORS Draft specification (see http://www.w3.org/TR/cors/) */
-    HDR_PRAGMA,                         /**< RFC 7234 */
-    HDR_PROXY_AUTHENTICATE,             /**< RFC 7235 */
-    HDR_PROXY_AUTHENTICATION_INFO,      /**< RFC 2617 */
-    HDR_PROXY_AUTHORIZATION,            /**< RFC 7235 */
-    HDR_PROXY_CONNECTION,               /**< obsolete Netscape header we may need to erase. */
-    HDR_PROXY_SUPPORT,                  /**< RFC 4559 */
-    HDR_PUBLIC,                         /**<  RFC 2068 */
-    HDR_RANGE,                          /**< RFC 7233 */
-    HDR_REFERER,                        /**< RFC 7231 */
-    HDR_REQUEST_RANGE,                  /**< some clients use this, sigh */
-    HDR_RETRY_AFTER,                    /**< RFC 7231 */
-    HDR_SERVER,                         /**< RFC 7231 */
-    HDR_SET_COOKIE,                     /**< RFC 6265 header we may need to erase */
-    HDR_SET_COOKIE2,                    /**< obsoleted RFC 2965 header we may need to erase */
-    /*HDR_STATUS_URI,*/                 /* RFC 2518 */
-    /*HDR_TCN,*/                        /* experimental RFC 2295 */
-    HDR_TE,                             /**< RFC 7230 */
-    /*HDR_TIMEOUT,*/                    /* RFC 2518 */
-    HDR_TITLE,                          /* obsolete draft suggested header */
-    HDR_TRAILER,                        /**< RFC 7230 */
-    HDR_TRANSFER_ENCODING,              /**< RFC 7230 */
-    HDR_TRANSLATE,                      /**< IIS custom header we may need to erase */
-    HDR_UNLESS_MODIFIED_SINCE,          /**< IIS custom header we may need to erase */
-    HDR_UPGRADE,                        /**< RFC 7230 */
-    HDR_USER_AGENT,                     /**< RFC 7231 */
-    /*HDR_VARIANT_VARY,*/               /* experimental RFC 2295 */
-    HDR_VARY,                           /**< RFC 7231 */
-    HDR_VIA,                            /**< RFC 7230 */
-    HDR_WARNING,                        /**< RFC 7234 */
-    HDR_WWW_AUTHENTICATE,               /**< RFC 7235, 4559 */
-    HDR_X_CACHE,                        /**< Squid custom header */
-    HDR_X_CACHE_LOOKUP,                 /**< Squid custom header. temporary hack that became de-facto. TODO remove */
-    HDR_X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
-    HDR_X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
-    HDR_X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
+enum HdrType {
+    ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
+    ACCEPT_CHARSET,                 /**< RFC 7231 */
+    ACCEPT_ENCODING,                /**< RFC 7231 */
+    /*ACCEPT_FEATURES,*/            /* RFC 2295 */
+    ACCEPT_LANGUAGE,                /**< RFC 7231 */
+    ACCEPT_RANGES,                  /**< RFC 7233 */
+    AGE,                            /**< RFC 7234 */
+    ALLOW,                          /**< RFC 7231 */
+    ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
+    AUTHENTICATION_INFO,            /**< RFC 2617 */
+    AUTHORIZATION,                  /**< RFC 7235, 4559 */
+    CACHE_CONTROL,                  /**< RFC 7234 */
+    CONNECTION,                     /**< RFC 7230 */
+    CONTENT_BASE,                   /**< obsoleted RFC 2068 */
+    CONTENT_DISPOSITION,            /**< RFC 2183, 6266 */
+    CONTENT_ENCODING,               /**< RFC 7231 */
+    CONTENT_LANGUAGE,               /**< RFC 7231 */
+    CONTENT_LENGTH,                 /**< RFC 7230 */
+    CONTENT_LOCATION,               /**< RFC 7231 */
+    CONTENT_MD5,                    /**< deprecated, RFC 2616 */
+    CONTENT_RANGE,                  /**< RFC 7233 */
+    CONTENT_TYPE,                   /**< RFC 7231 */
+    COOKIE,                         /**< RFC 6265 header we may need to erase */
+    COOKIE2,                        /**< obsolete RFC 2965 header we may need to erase */
+    DATE,                           /**< RFC 7231 */
+    /*DAV,*/                        /* RFC 2518 */
+    /*DEPTH,*/                      /* RFC 2518 */
+    /*DERIVED_FROM,*/               /* deprecated RFC 2068 */
+    /*DESTINATION,*/                /* RFC 2518 */
+    ETAG,                           /**< RFC 7232 */
+    EXPECT,                         /**< RFC 7231 */
+    EXPIRES,                        /**< RFC 7234 */
+    FORWARDED,                      /**< RFC 7239 */
+    FROM,                           /**< RFC 7231 */
+    HOST,                           /**< RFC 7230 */
+    HTTP2_SETTINGS,                 /**< RFC 7540 */
+    /*IF,*/                         /* RFC 2518 */
+    IF_MATCH,                       /**< RFC 7232 */
+    IF_MODIFIED_SINCE,              /**< RFC 7232 */
+    IF_NONE_MATCH,                  /**< RFC 7232 */
+    IF_RANGE,                       /**< RFC 7233 */
+    IF_UNMODIFIED_SINCE,            /**< RFC 7232 */
+    KEEP_ALIVE,                     /**< obsoleted RFC 2068 header we may need to erase */
+    KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
+    LAST_MODIFIED,                  /**< RFC 7232 */
+    LINK,                           /**< RFC 5988 */
+    LOCATION,                       /**< RFC 7231 */
+    /*LOCK_TOKEN,*/                 /* RFC 2518 */
+    MAX_FORWARDS,                   /**< RFC 7231 */
+    MIME_VERSION,                   /**< RFC 2045, 7231 */
+    NEGOTIATE,                      /**< experimental RFC 2295. Why only this one from 2295? */
+    /*OVERWRITE,*/                  /* RFC 2518 */
+    ORIGIN,                         /* CORS Draft specification (see http://www.w3.org/TR/cors/) */
+    PRAGMA,                         /**< RFC 7234 */
+    PROXY_AUTHENTICATE,             /**< RFC 7235 */
+    PROXY_AUTHENTICATION_INFO,      /**< RFC 2617 */
+    PROXY_AUTHORIZATION,            /**< RFC 7235 */
+    PROXY_CONNECTION,               /**< obsolete Netscape header we may need to erase. */
+    PROXY_SUPPORT,                  /**< RFC 4559 */
+    PUBLIC,                         /**<  RFC 2068 */
+    RANGE,                          /**< RFC 7233 */
+    REFERER,                        /**< RFC 7231 */
+    REQUEST_RANGE,                  /**< some clients use this, sigh */
+    RETRY_AFTER,                    /**< RFC 7231 */
+    SERVER,                         /**< RFC 7231 */
+    SET_COOKIE,                     /**< RFC 6265 header we may need to erase */
+    SET_COOKIE2,                    /**< obsoleted RFC 2965 header we may need to erase */
+    /*STATUS_URI,*/                 /* RFC 2518 */
+    /*TCN,*/                        /* experimental RFC 2295 */
+    TE,                             /**< RFC 7230 */
+    /*TIMEOUT,*/                    /* RFC 2518 */
+    TITLE,                          /* obsolete draft suggested header */
+    TRAILER,                        /**< RFC 7230 */
+    TRANSFER_ENCODING,              /**< RFC 7230 */
+    TRANSLATE,                      /**< IIS custom header we may need to erase */
+    UNLESS_MODIFIED_SINCE,          /**< IIS custom header we may need to erase */
+    UPGRADE,                        /**< RFC 7230 */
+    USER_AGENT,                     /**< RFC 7231 */
+    /*VARIANT_VARY,*/               /* experimental RFC 2295 */
+    VARY,                           /**< RFC 7231 */
+    VIA,                            /**< RFC 7230 */
+    WARNING,                        /**< RFC 7234 */
+    WWW_AUTHENTICATE,               /**< RFC 7235, 4559 */
+    X_CACHE,                        /**< Squid custom header */
+    X_CACHE_LOOKUP,                 /**< Squid custom header. temporary hack that became de-facto. TODO remove */
+    X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
+    X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
+    X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
 #if X_ACCELERATOR_VARY
     HDR_X_ACCELERATOR_VARY,             /**< obsolete Squid custom header. */
 #endif
 #if USE_ADAPTATION
-    HDR_X_NEXT_SERVICES,                /**< Squid custom ICAP header */
+    X_NEXT_SERVICES,                /**< Squid custom ICAP header */
 #endif
-    HDR_SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
-    HDR_SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
-    HDR_FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
-    HDR_FTP_COMMAND,                    /**< Internal header for FTP command */
-    HDR_FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
-    HDR_FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
-    HDR_FTP_STATUS,                     /**< Internal header for FTP reply status */
-    HDR_FTP_REASON,                     /**< Internal header for FTP reply reason */
-    HDR_OTHER,                          /**< internal tag value for "unknown" headers */
-    HDR_ENUM_END
-} http_hdr_type;
+    SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
+    SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
+    FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
+    FTP_COMMAND,                    /**< Internal header for FTP command */
+    FTP_ARGUMENTS,                  /**< Internal header for FTP command arguments */
+    FTP_PRE,                        /**< Internal header containing leading FTP control response lines */
+    FTP_STATUS,                     /**< Internal header for FTP reply status */
+    FTP_REASON,                     /**< Internal header for FTP reply reason */
+    OTHER,                          /**< internal tag value for "unknown" headers */
+    BAD_HDR,                        /**< Invalid header. Must be after ENUM_END */
+    ENUM_END                        /**< internal tag for end-of-headers */
+};
+
+/** possible types for http header fields */
+enum class HdrFieldType {
+    ftInvalid,  /**< to catch nasty errors with hdr_id<->fld_type clashes */
+    ftInt,
+    ftInt64,
+    ftStr,
+    ftDate_1123,
+    ftETag,
+    ftPCc,
+    ftPContRange,
+    ftPRange,
+    ftPSc,
+    ftDate_1123_or_ETag
+};
+
+/* POD for HeaderTable */
+class HeaderTableRecord {
+public:
+    const char *name;
+    Http::HdrType id;
+    Http::HdrFieldType type;
+};
+
+/// header ID->namelookup table.
+extern const HeaderTableRecord HeaderTable[];
+
+/** LookupTable for HTTP Header name -> Http::HdrType lookup.
+ *
+ * use as HeaderLookupTable.lookup(header-as-sbuf).
+ * It will return Http::HdrType::HDR_BAD if the header is unknown/not registered,
+ * including the case of Http::HdrType::OTHER, which will have to be handled
+ * by the caller.
+ */
+extern const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable;
+
+/// match any known header type, including OTHER and BAD
+inline bool
+any_HdrType_enum_value (const Http::HdrType id)
+{
+    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END);
+}
+
+/// match any valid header type, including OTHER but not BAD
+inline bool
+any_valid_header (const Http::HdrType id)
+{
+    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::BAD_HDR);
+}
+
+/// match any registered header type (headers squid knows how to handle),
+///  thus excluding OTHER and BAD
+inline bool
+any_registered_header (const Http::HdrType id)
+{
+    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::OTHER);
+}
+
+}; /* namespace Http */
+
+/* ostream output for Http::HdrType */
+std::ostream &
+operator<< (std::ostream&, Http::HdrType);
 
 #endif /* SQUID_HTTP_REGISTEREDHEADERS_H */
 
@@ -32,8 +32,8 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
         if (al->request->auth_user_request != NULL)
             user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
 #endif
-        referer = al->request->header.getStr(HDR_REFERER);
-        agent = al->request->header.getStr(HDR_USER_AGENT);
+        referer = al->request->header.getStr(Http::HdrType::REFERER);
+        agent = al->request->header.getStr(Http::HdrType::USER_AGENT);
     }
 
     if (!referer || *referer == '\0')
@@ -20,7 +20,7 @@ Log::Format::SquidReferer(const AccessLogEntry::Pointer &al, Logfile *logfile)
 {
     const char *referer = NULL;
     if (al->request)
-        referer = al->request->header.getStr(HDR_REFERER);
+        referer = al->request->header.getStr(Http::HdrType::REFERER);
 
     if (!referer || *referer == '\0')
         referer = "-";
@@ -21,7 +21,7 @@ Log::Format::SquidUserAgent(const AccessLogEntry::Pointer &al, Logfile * logfile
     const char *agent = NULL;
 
     if (al->request)
-        agent = al->request->header.getStr(HDR_USER_AGENT);
+        agent = al->request->header.getStr(Http::HdrType::USER_AGENT);
 
     if (!agent || *agent == '\0')
         agent = "-";
@@ -2010,7 +2010,6 @@ SquidShutdown()
     fqdncacheFreeMemory();
     asnFreeMemory();
     clientdbFreeMemory();
-    httpHeaderCleanModule();
     statFreeMemory();
     eventFreeMemory();
     mimeFreeMemory();
@@ -83,7 +83,7 @@ Mgr::Inquirer::start()
     } else {
         std::unique_ptr<HttpReply> reply(new HttpReply);
         reply->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
-        reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
+        reply->header.putStr(Http::HdrType::CONNECTION, "close"); // until we chunk response
         replyBuf.reset(reply->pack());
     }
     writer = asyncCall(16, 5, "Mgr::Inquirer::noteWroteHeader",
@@ -343,9 +343,9 @@ peerDigestRequest(PeerDigest * pd)
     /* add custom headers */
     assert(!req->header.len);
 
-    req->header.putStr(HDR_ACCEPT, StoreDigestMimeStr);
+    req->header.putStr(Http::HdrType::ACCEPT, StoreDigestMimeStr);
 
-    req->header.putStr(HDR_ACCEPT, "text/html");
+    req->header.putStr(Http::HdrType::ACCEPT, "text/html");
 
     if (p->login &&
             p->login[0] != '*' &&
@@ -492,7 +492,7 @@ Ftp::Server::writeCustomReply(const int code, const char *msg, const HttpReply *
     assert(99 < code && code < 1000);
 
     const bool sendDetails = reply != NULL &&
-                             reply->header.has(HDR_FTP_STATUS) && reply->header.has(HDR_FTP_REASON);
+                             reply->header.has(Http::HdrType::FTP_STATUS) && reply->header.has(Http::HdrType::FTP_REASON);
 
     MemBuf mb;
     mb.init();
@@ -727,11 +727,11 @@ Ftp::Server::parseOneRequest()
     request->flags.cachable = false; // XXX: reset later by maybeCacheable()
     request->flags.noCache = true;
 
-    request->header.putStr(HDR_FTP_COMMAND, cmd.c_str());
-    request->header.putStr(HDR_FTP_ARGUMENTS, params.c_str()); // may be ""
+    request->header.putStr(Http::HdrType::FTP_COMMAND, cmd.c_str());
+    request->header.putStr(Http::HdrType::FTP_ARGUMENTS, params.c_str()); // may be ""
     if (method == Http::METHOD_PUT) {
-        request->header.putStr(HDR_EXPECT, "100-continue");
-        request->header.putStr(HDR_TRANSFER_ENCODING, "chunked");
+        request->header.putStr(Http::HdrType::EXPECT, "100-continue");
+        request->header.putStr(Http::HdrType::TRANSFER_ENCODING, "chunked");
     }
 
     ClientHttpRequest *const http = new ClientHttpRequest(this);
@@ -808,11 +808,11 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
     bool hasEPSV = false;
     int prependSpaces = 1;
 
-    featReply->header.putStr(HDR_FTP_PRE, "\"211-Features:\"");
-    const int scode = serverReplyHeader.getInt(HDR_FTP_STATUS);
+    featReply->header.putStr(Http::HdrType::FTP_PRE, "\"211-Features:\"");
+    const int scode = serverReplyHeader.getInt(Http::HdrType::FTP_STATUS);
     if (scode == 211) {
         while (const HttpHeaderEntry *e = serverReplyHeader.getEntry(&pos)) {
-            if (e->id == HDR_FTP_PRE) {
+            if (e->id == Http::HdrType::FTP_PRE) {
                 // assume RFC 2389 FEAT response format, quoted by Squid:
                 // <"> SP NAME [SP PARAMS] <">
                 // but accommodate MS servers sending four SPs before NAME
@@ -848,11 +848,11 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
     char buf[256];
     if (!hasEPRT) {
         snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPRT");
-        featReply->header.putStr(HDR_FTP_PRE, buf);
+        featReply->header.putStr(Http::HdrType::FTP_PRE, buf);
     }
     if (!hasEPSV) {
         snprintf(buf, sizeof(buf), "\"%*s\"", prependSpaces + 4, "EPSV");
-        featReply->header.putStr(HDR_FTP_PRE, buf);
+        featReply->header.putStr(Http::HdrType::FTP_PRE, buf);
     }
 
     featReply->header.refreshMask();
@@ -1023,8 +1023,8 @@ Ftp::Server::writeForwardedReply(const HttpReply *reply)
 {
     assert(reply != NULL);
     const HttpHeader &header = reply->header;
-    // adaptation and forwarding errors lack HDR_FTP_STATUS
-    if (!header.has(HDR_FTP_STATUS)) {
+    // adaptation and forwarding errors lack Http::HdrType::FTP_STATUS
+    if (!header.has(Http::HdrType::FTP_STATUS)) {
         writeForwardedForeign(reply); // will get to Ftp::Server::wroteReply
         return;
     }
@@ -1103,8 +1103,8 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
 #endif
 
     assert(reply != NULL);
-    const char *reason = reply->header.has(HDR_FTP_REASON) ?
-                         reply->header.getStr(HDR_FTP_REASON):
+    const char *reason = reply->header.has(Http::HdrType::FTP_REASON) ?
+                         reply->header.getStr(Http::HdrType::FTP_REASON):
                          reply->sline.reason();
 
     mb.appendf("%i %s\r\n", scode, reason); // error terminating line
@@ -1131,7 +1131,7 @@ void
 Ftp::Server::writeControlMsgAndCall(ClientSocketContext *, HttpReply *reply, AsyncCall::Pointer &call)
 {
     // the caller guarantees that we are dealing with the current context only
-    // the caller should also make sure reply->header.has(HDR_FTP_STATUS)
+    // the caller should also make sure reply->header.has(Http::HdrType::FTP_STATUS)
     writeForwardedReplyAndCall(reply, call);
 }
 
@@ -1142,9 +1142,9 @@ Ftp::Server::writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Point
     const HttpHeader &header = reply->header;
 
     // without status, the caller must use the writeForwardedForeign() path
-    Must(header.has(HDR_FTP_STATUS));
-    Must(header.has(HDR_FTP_REASON));
-    const int scode = header.getInt(HDR_FTP_STATUS);
+    Must(header.has(Http::HdrType::FTP_STATUS));
+    Must(header.has(Http::HdrType::FTP_REASON));
+    const int scode = header.getInt(Http::HdrType::FTP_STATUS);
     debugs(33, 7, "scode: " << scode);
 
     // Status 125 or 150 implies upload or data request, but we still check
@@ -1194,16 +1194,16 @@ Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const)
 
     HttpHeaderPos pos = HttpHeaderInitPos;
     while (const HttpHeaderEntry *e = header.getEntry(&pos)) {
-        if (e->id == HDR_FTP_PRE) {
+        if (e->id == Http::HdrType::FTP_PRE) {
             String raw;
             if (httpHeaderParseQuotedString(e->value.rawBuf(), e->value.size(), &raw))
                 mb.appendf("%s\r\n", raw.termedBuf());
         }
     }
 
-    if (header.has(HDR_FTP_STATUS)) {
-        const char *reason = header.getStr(HDR_FTP_REASON);
-        mb.appendf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
+    if (header.has(Http::HdrType::FTP_STATUS)) {
+        const char *reason = header.getStr(Http::HdrType::FTP_REASON);
+        mb.appendf("%i %s\r\n", header.getInt(Http::HdrType::FTP_STATUS),
                    (reason ? reason : 0));
     }
 }
@@ -1279,10 +1279,10 @@ Ftp::Server::handleRequest(HttpRequest *request)
     Must(request);
 
     HttpHeader &header = request->header;
-    Must(header.has(HDR_FTP_COMMAND));
-    String &cmd = header.findEntry(HDR_FTP_COMMAND)->value;
-    Must(header.has(HDR_FTP_ARGUMENTS));
-    String &params = header.findEntry(HDR_FTP_ARGUMENTS)->value;
+    Must(header.has(Http::HdrType::FTP_COMMAND));
+    String &cmd = header.findEntry(Http::HdrType::FTP_COMMAND)->value;
+    Must(header.has(Http::HdrType::FTP_ARGUMENTS));
+    String &params = header.findEntry(Http::HdrType::FTP_ARGUMENTS)->value;
 
     if (do_debug(9, 2)) {
         MemBuf mb;
@@ -1596,10 +1596,10 @@ Ftp::Server::setDataCommand()
     HttpRequest *const request = http->request;
     assert(request != NULL);
     HttpHeader &header = request->header;
-    header.delById(HDR_FTP_COMMAND);
-    header.putStr(HDR_FTP_COMMAND, "PASV");
-    header.delById(HDR_FTP_ARGUMENTS);
-    header.putStr(HDR_FTP_ARGUMENTS, "");
+    header.delById(Http::HdrType::FTP_COMMAND);
+    header.putStr(Http::HdrType::FTP_COMMAND, "PASV");
+    header.delById(Http::HdrType::FTP_ARGUMENTS);
+    header.putStr(Http::HdrType::FTP_ARGUMENTS, "");
     debugs(9, 5, "client data command converted to fake PASV");
 }
 
@@ -193,8 +193,8 @@ Http::One::Server::processParsedRequest(ClientSocketContext *context)
     ClientHttpRequest *http = context->http;
     HttpRequest::Pointer request = http->request;
 
-    if (request->header.has(HDR_EXPECT)) {
-        const String expect = request->header.getList(HDR_EXPECT);
+    if (request->header.has(Http::HdrType::EXPECT)) {
+        const String expect = request->header.getList(Http::HdrType::EXPECT);
         const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
         if (!supportedExpect) {
             clientStreamNode *node = context->getClientReplyContext();
@@ -276,7 +276,7 @@ Http::One::Server::writeControlMsgAndCall(ClientSocketContext *context, HttpRepl
     // apply selected clientReplyContext::buildReplyHeader() mods
     // it is not clear what headers are required for control messages
     rep->header.removeHopByHopEntries();
-    rep->header.putStr(HDR_CONNECTION, "keep-alive");
+    rep->header.putStr(Http::HdrType::CONNECTION, "keep-alive");
     httpHdrMangleList(&rep->header, getCurrentContext()->http->request, ROR_REPLY);
 
     MemBuf *mb = rep->pack();
@@ -127,7 +127,7 @@ Ssl::ErrorDetailsManager::getErrorDetail(Ssl::ssl_error_t value, const HttpReque
 {
 #if USE_ERR_LOCALES
     String hdr;
-    if (request != NULL && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr)) {
+    if (request != NULL && request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr)) {
         ErrorDetailsList::Pointer errDetails = NULL;
         //Try to retrieve from cache
         size_t pos = 0;
@@ -721,20 +721,20 @@ StoreEntry::setPublicKey()
             /* We are allowed to do this typecast */
             HttpReply *rep = new HttpReply;
             rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
-            vary = mem_obj->getReply()->header.getList(HDR_VARY);
+            vary = mem_obj->getReply()->header.getList(Http::HdrType::VARY);
 
             if (vary.size()) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_VARY, vary.termedBuf());
+                rep->header.putStr(Http::HdrType::VARY, vary.termedBuf());
                 vary.clean();
             }
 
 #if X_ACCELERATOR_VARY
-            vary = mem_obj->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
+            vary = mem_obj->getReply()->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
 
             if (vary.size() > 0) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.termedBuf());
+                rep->header.putStr(Http::HdrType::HDR_X_ACCELERATOR_VARY, vary.termedBuf());
                 vary.clean();
             }
 
@@ -1597,7 +1597,7 @@ StoreEntry::timestampsSet()
 {
     const HttpReply *reply = getReply();
     time_t served_date = reply->date;
-    int age = reply->header.getInt(HDR_AGE);
+    int age = reply->header.getInt(Http::HdrType::AGE);
     /* Compute the timestamp, mimicking RFC2616 section 13.2.3. */
     /* make sure that 0 <= served_date <= squid_curtime */
 
@@ -2049,7 +2049,7 @@ bool
 StoreEntry::hasEtag(ETag &etag) const
 {
     if (const HttpReply *reply = getReply()) {
-        etag = reply->header.getETag(HDR_ETAG);
+        etag = reply->header.getETag(Http::HdrType::ETAG);
         if (etag.str)
             return true;
     }
@@ -2059,14 +2059,14 @@ StoreEntry::hasEtag(ETag &etag) const
 bool
 StoreEntry::hasIfMatchEtag(const HttpRequest &request) const
 {
-    const String reqETags = request.header.getList(HDR_IF_MATCH);
+    const String reqETags = request.header.getList(Http::HdrType::IF_MATCH);
     return hasOneOfEtags(reqETags, false);
 }
 
 bool
 StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 {
-    const String reqETags = request.header.getList(HDR_IF_NONE_MATCH);
+    const String reqETags = request.header.getList(Http::HdrType::IF_NONE_MATCH);
     // weak comparison is allowed only for HEAD or full-body GET requests
     const bool allowWeakMatch = !request.flags.isRanged &&
                                 (request.method == Http::METHOD_GET || request.method == Http::METHOD_HEAD);
@@ -2077,7 +2077,7 @@ StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 bool
 StoreEntry::hasOneOfEtags(const String &reqETags, const bool allowWeakMatch) const
 {
-    const ETag repETag = getReply()->header.getETag(HDR_ETAG);
+    const ETag repETag = getReply()->header.getETag(Http::HdrType::ETAG);
     if (!repETag.str)
         return strListIsMember(&reqETags, "*", ',');
 
@@ -71,8 +71,8 @@ void Auth::UserRequest::addAuthenticationInfoHeader(HttpReply *, int) STUB
 void Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply *, int) STUB
 void Auth::UserRequest::releaseAuthServer() STUB
 const char * Auth::UserRequest::connLastHeader() STUB_RETVAL("stub")
-AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
-AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, http_hdr_type, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
+AuthAclState Auth::UserRequest::authenticate(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
+AuthAclState Auth::UserRequest::tryToAuthenticateAndSetAuthUser(Auth::UserRequest::Pointer *, Http::HdrType, HttpRequest *, ConnStateData *, Ip::Address &, AccessLogEntry::Pointer &) STUB_RETVAL(AUTH_AUTHENTICATED)
 void Auth::UserRequest::addReplyAuthHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int) STUB
 void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int) STUB
@@ -15,7 +15,7 @@
 
 /** \todo CLEANUP: This file should be called something_stub.cc */
 
-void httpHeaderPutStr(HttpHeader * hdr, http_hdr_type type, const char *str)
+void httpHeaderPutStr(HttpHeader * hdr, Http::HdrType type, const char *str)
 {
     fatal ("dummy function\n");
 }
@@ -26,13 +26,13 @@ HttpHeaderEntry *httpHeaderGetEntry(const HttpHeader * hdr, HttpHeaderPos * pos)
     return NULL;
 }
 
-String httpHeaderGetList(const HttpHeader * hdr, http_hdr_type id)
+String httpHeaderGetList(const HttpHeader * hdr, Http::HdrType id)
 {
     fatal ("dummy function\n");
     return String();
 }
 
-int httpHeaderHas(const HttpHeader * hdr, http_hdr_type type)
+int httpHeaderHas(const HttpHeader * hdr, Http::HdrType type)
 {
     fatal ("dummy function\n");
     return 0;
@@ -760,7 +760,7 @@ urlCheckRequest(const HttpRequest * r)
     // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)
     // we also support forwarding OPTIONS and TRACE, except for the *-URI ones
     if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)
-        return (r->header.getInt64(HDR_MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
+        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != URL::Asterisk());
 
     if (r->method == Http::METHOD_PURGE)
         return 1;
@@ -163,7 +163,7 @@ UrnState::setUriResFromRequest(HttpRequest *r)
         return;
     }
 
-    urlres_r->header.putStr(HDR_ACCEPT, "text/plain");
+    urlres_r->header.putStr(Http::HdrType::ACCEPT, "text/plain");
 }
 
 void
@@ -371,7 +371,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
     if (urnState->flags.force_menu) {
         debugs(51, 3, "urnHandleReply: forcing menu");
     } else if (min_u) {
-        rep->header.putStr(HDR_LOCATION, min_u->url);
+        rep->header.putStr(Http::HdrType::LOCATION, min_u->url);
     }
 
     rep->body.setMb(mb);