@@ -2,18 +2,16 @@ This file contains a list of Squid contributors: people and organizations that
 have volunteered their time, effort, code, and ideas to make Squid software.
 Thank you!
 
-    'noloader' <noloader@gmail.com>
-    <mgd@swarm.org>
     Adam Ciarcinski
     Adrian Chadd <adrian@squid-cache.org>
     Alan Mizrahi <alan@mizrahi.com.ve>
-    Alex Rousskov <rousskov@measurement-factory.com>
     Alexander B. Demenshin <aldem@barnet.kharkov.ua>
     Alexander Komyagin <komyagin@altell.ru>
     Alexander Lukyanov <lav@yar.ru>
     Alexandre Chappaz <alexandrechappaz@gmail.com>
     Alexey Veselovsky <alexey.veselovsky@eykontech.com>
     Alexis Robert <alexis.robert@gmail.com>
+    Alex Rousskov <rousskov@measurement-factory.com>
     Alin Nastac <mrness@gentoo.org>
     Alter <alter@alter.org.ua>
     Amos Jeffries <amosjeffries@squid-cache.org>
@@ -26,13 +24,12 @@ Thank you!
     Andrew Beverley <andy@andybev.com>
     Andrew Doran <ad@interlude.eu.org>
     Andrew Hoying <andrew_hoying@blm.gov>
-    Andrey Shorin <tolsty@tushino.com>
     Andrew Tridgell
+    Andrey Shorin <tolsty@tushino.com>
     Anonymous <redskilldough@gmail.com>
     Ansgar Hockmann <Ansgar.Hockmann@hrz.uni-dortmund.de>
     Anthony Baxter <arb@connect.com.au>
     Antonino Iannella
-    Arjan de Vet <Arjan.deVet@adv.IAEhv.nl>
     Arjan de Vet <Arjan.deVet@adv.iae.nl>
     Arkin <arkin.yang@gmail.com>
     Arno Streuli <astreuli@gmail.com>
@@ -41,21 +38,22 @@ Thank you!
     Automatic source maintenance <squidadm@squid-cache.org>
     Axel Westerhold <ml.awesterhold@dts.de>
     Benjamin Kerensa <bkerensa@ubuntu.com>
+    benno@jeamland.net
     Benno Rice <benno@squid-cache.org>
     Bernard <fli4l.charrier@free.fr>
     Bertrand Jacquin <beber@meleeweb.net>
     Bill Welliver
     Bojan Smojver <bojan@rexursive.com>
     Brad Smith <brad@comstyle.com>
-    Brian <hiryuu@envisiongames.net>
     Brian Degenhardt <bmd@mp3.com>
     Brian Denehy <B-Denehy@adfa.oz.au>
+    Brian <hiryuu@envisiongames.net>
     Bruce Murphy <pack-squid@rattus.net>
     Carson Gaspar (carson@lehman.com, carson@cs.columbia.edu)
     Changming <me@sunchangming.com>
     Chris Hills <chaz@chaz6.com>
-    Christoph Lechleitner <lech@ibcl.at>
     Christopher Kerr
+    Christoph Lechleitner <lech@ibcl.at>
     Christos Tsantilas <chtsanti@users.sourceforge.net>
     Cloyce <cloyce.spradling@sun.com>
     Constantin Rack
@@ -64,17 +62,17 @@ Thank you!
     Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
     David Isaacs <david.isaacs@sbhs.nsw.edu.au>
     David J N Begley
-    David Luyer <luyer@ucs.uwa.edu.au>
     David Luyer <david@luyer.net>
+    David Luyer <luyer@ucs.uwa.edu.au>
     Dennis Glatting
     Dhaval Varia
     Diego Woitasen <diegows@xtech.com.ar>
     Dmitry Kurochkin
     Don Hopkins <dhopkins@DonHopkins.com>
     Doug Dixon <doug.dixon@gmail.com>
     Doug Urner <dlu@bsdi.com>
-    Dr. Tilmann Bubeck <t.bubeck@reinform.de>
     Dragutin Cirkovic <painkiller@gromnet.net>
+    Dr. Tilmann Bubeck <t.bubeck@reinform.de>
     Duane Wessels <wessels@squid-cache.org>
     Dustin J. Mitchell
     Ed Knowles <ed@fatboy.geog.unsw.edu.au>
@@ -84,16 +82,18 @@ Thank you!
     Emilio Casbas <ecasbas@unav.es>
     Endre Balint Nagy <bne@CareNet.hu>
     Eray Aslan <eray.aslan@caf.com.tr>
-    Erik Hofman <erik.hofman@a1.nl>
     Eric Stern <estern@logisense.com>
+    Erik Hofman <erik.hofman@a1.nl>
     Eugene Gladchenko <eugene@donpac.ru>
     Evan Jones <ejones@uwaterloo.ca>
     Eygene Ryabinkin <rea@freebsd.org>
+    fancyrabbit <fancyrabbit@gmail.com>
     Felix Meschberger <felix.meschberger@day.com>
     Finn Thain <fthain@telegraphics.com.au>
     Flavio Pescuma <flavio@marasystems.com>
-    Francesco <kinkie@squid-cache.org>
+    folkert <folkert@vanheusden.com>
     Francesco Chemolli <kinkie@squid-cache.org>
+    Francesco <kinkie@squid-cache.org>
     Francesco Salvestrini
     Francis Daly <francis@daoine.org>
     Francois Cami <fcami@winsoft.fr>
@@ -108,9 +108,9 @@ Thank you!
     Giancarlo Razzolini <linux-fan@onda.com.br>
     Gilles Espinasse <g.esp@free.fr>
     Glen Gibb <grg@ridley.unimelb.edu.au>
+    Glenn Chisholm <glenn@ircache.net>
     Glen Newton <glen.newton@nrc.ca>
     Glenn Newton <gnewton@wapiti.cisti.nrc.ca>
-    Glenn Chisholm <glenn@ircache.net>
     Golub Mikhail
     Gonzalo Arana <gonzalo.arana@gmail.com>
     Graham Keeling <graham@equiinet.com>
@@ -122,11 +122,11 @@ Thank you!
     Henrik Nordstrom <henrik@henriknordstrom.net>
     Henrik Nordstrom <hno@squid-cache.org>
     Hide Nagaoka <hide@cc.meisei-u.ac.jp>
+    hno
     Ian Castle <ian.castle@coldcomfortfarm.net>
     Ian Turner <vectro@pipeline.com>
     Igor Vinokurov <igor@cs.ibank.ru>
     Isnard <isnardjaquet@gmail.com>
-    JPP <jpp1@frws.com>
     Jakob Bohm <jb-debbugs@wisemo.com>
     Jakub Wilk <ubanus@users.sf.net>
     James Brotchie <brotchie@gmail.com>
@@ -144,45 +144,48 @@ Thank you!
     Joao Alves Neto <alves_joao@hotmail.com>
     Jochen Obalek
     Jochen Voss <voss@seehuhn.de>
-    Joe Ramey <ramey@jello.csc.ti.com>
     Joe Ramey <ramey@csc.ti.com>
+    Joe Ramey <ramey@jello.csc.ti.com>
+    Johnathan Conley <johnathan.conley@gmail.com>
     John Dilley <jad@hpl.hp.com>
     John Saunders <johns@rd.scitec.com.au>
     John Xue <xgxjohn@gmail.com>
-    Johnathan Conley <johnathan.conley@gmail.com>
+    Jonathan Larmour <JLarmour@origin-at.co.uk>
     Jon Kinred
     Jon Thackray <jrmt@uk.gdscorp.com>
-    Jonathan Larmour <JLarmour@origin-at.co.uk>
     Joshua Root <josh+squid@root.id.au>
+    JPP <jpp1@frws.com>
     Juerg Michel
     Kieran Whitbread <k.j.whitbread@qmul.ac.uk>
     Kinkie <kinkie@squid-cache.org>
+    kinkie@squid-cache.org
     Klaubert Herr <klaubert@gmail.com>
     Klaus Singvogel <kssingvo@suse.de>
     Kolics Bertold <bertold@tohotom.vein.hu>
     Kostas Anagnostakis <kanag@csi.forth.gr>
     Lab10 <lab10@bt-anlagenbau.at>
     Laszlo Attilla Toth <panther@balabit.hu>
     Leeann Bent <lbent@cs.ucsd.edu>
+    libit <sambabug.lb@gmail.com>
     Luigi Gangitano <luigi@debian.org>
     Luke Howard <lukeh@vurt.schnet.edu.au>
     Lutz Donnerhacke <lutz@iks-jena.de>
     Manu Garg <manugarg@gmail.com>
+    Marcus Kool
+    Marc van Selm <selm@cistron.nl>
     Marin Stavrev <mstavrev@gmail.com>
     Marios Makassikis <mmakassikis@gmail.com>
     Mark Bergsma <mark@nedworks.org>
     Mark Nottingham <mnot@pobox.com>
-    Mark Treacy <mark@aone.com.au>
-    Marcus Kool
-    Marc van Selm <selm@cistron.nl>
-    Marko <mr_4u2@yahoo.com>
     Marko Cupac <marko.cupac@mimar.rs>
+    Marko <mr_4u2@yahoo.com>
+    Mark Treacy <mark@aone.com.au>
     Markus Gyger <mgyger@itr.ch>
     Markus Moeller <huaraz@moeller.plus.com>
     Markus Rietzler <markus.rietzler@rzf.fin-nrw.de>
     Markus Stumpf <maex@Space.NET>
-    Martin Hamilton <martin@mrrl.lut.ac.uk>
     Martin Hamilton <martinh@gnu.org>
+    Martin Hamilton <martin@mrrl.lut.ac.uk>
     Martin Huter <m.huter@phion.com>
     Martin Stolle <martin.stolle@ekom21.de>
     Masashi Fujita <objectx@bandit.co.jp>
@@ -191,6 +194,7 @@ Thank you!
     Matthias Pitzl <silamael@coronamundi.de>
     Max Okumoto <okumoto@ucsd.edu>
     Merik Karman
+    <mgd@swarm.org>
     Michael Cunningham <m.cunningham@xpedite.com>
     Michael Lupp <mike@nemesis.saar.de>
     Michael Mansour <mic@shell.gnxs.com.au>
@@ -211,6 +215,7 @@ Thank you!
     Niall Doherty <ndoherty@eei.ericsson.se>
     Nick Rogers <ncrogers@gmail.com>
     Nikolai Gorchilov <niki@x3me.net>
+    'noloader' <noloader@gmail.com>
     Oliver Hookins
     Olivier Montanuy
     Oskar Pearson <oskar@is.co.za>
@@ -224,8 +229,8 @@ Thank you!
     Philip Allison <philip.allison@smoothwall.net>
     Philippe Lantin <plantin@cobaltgroup.com>
     Pierangelo Masarati <ando@sys-net.it>
-    Pierre-Louis BRENAC <brenacp@esiee.fr>
     Pierre-Louis Brenac <brenacp@esiee.fr>
+    Pierre-Louis BRENAC <brenacp@esiee.fr>
     Poul-Henning Kamp <phk@login.dknet.dk>
     Priyanka Gupta <priyanka@icelero.com>
     Przemek Czerkas <pczerkas@mgmnet.pl>
@@ -241,19 +246,20 @@ Thank you!
     Reinhard Sojka <reinhard.sojka@parlament.gv.at>
     Rene Geile <rene.geile@t-online.de>
     Reuben Farrelly <reuben@reub.net>
-    Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>
     Richard Huveneers <richard@hekkihek.hacom.nl>
+    Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>
     Richard Sharpe
     Richard Wall <richard.wall@appliansys.com>
     Robert Collins <rbtcollins@hotmail.com>
     Robert Collins <robertc@robertcollins.net>
     Robert Forster
     Robin Elfrink <robin@a1.nl>
-    Rodrigo Campos (rodrigo@geekbunker.org)
     Rodrigo Campos <rodrigo@geekbunker.org>
+    Rodrigo Campos (rodrigo@geekbunker.org)
     Rodrigo Rubira Branco <rodrigo@kernelhacking.com>
     Rodrigo Rubira Branco <rrbranco@br.ibm.com>
     Ron Gomes <rrg@ny.ubs.com>
+    rousskov
     Russell Street <r.street@auckland.ac.nz>
     Russell Vincent <vincent@ucthpx.uct.ac.za>
     Ryan Troll <ryan+@andrew.cmu.edu>
@@ -263,13 +269,14 @@ Thank you!
     Sergio Rabellino <rabellino@di.unito.it>
     Shigechika Aikawa <shige@luck.imasy.or.jp>
     Silamael <Silamael@coronamundi.de>
+    squidadm@squid-cache.org
     Stefan Fritsch <sf@sfritsch.de>
     Stefano Cordibella <stefano.cordibella@edalab.it>
     Stephen R. van den Berg <srb@cuci.nl>
     Steve Bennett <S.Bennett@lancaster.ac.uk>
     Steve Hill <steve@opendium.com>
-    Steve Snyder <swsnyder@snydernet.net>
     Steven Wilton <swilton@q-net.net.au>
+    Steve Snyder <swsnyder@snydernet.net>
     Stewart Forster <slf@connect.com.au>
     Stuart Henderson <sthen@openbsd.org>
     Susant Sahani <ssahani@redhat.com>
@@ -279,31 +286,24 @@ Thank you!
     The Measurement Factory <info@measurement-factory.com>
     Thomas De Schampheleire <thomas.de.schampheleire@gmail.com>
     Thomas Hozza <thozza@redhat.com>
+    Thomas-Martin Seck <tmseck@netcologne.de>
     Thomas Ristic <thr@bootet.net>
     Thomas Weber <x@4t2.com>
-    Thomas-Martin Seck <tmseck@netcologne.de>
     Tianyin Xu <tixu@cs.ucsd.edu>
     Tim Starling <tstarling@wikimedia.org>
     Todd C. Miller <Todd.Miller@courtesan.com>
     Tomas Hozza <thozza@redhat.com>
     Tony Lorimer <tlorimer@au.mdis.com>
-    Unknown - NetBSD Project
     Unknown FreeBSD Contributor
+    Unknown - NetBSD Project
     Vince Brimhall
     Vincent Regnard
     Vitaliy Matytsyn (main) <vm@if.bank.gov.ua>
     Vitaliy Matytsyn <vm@if.bank.gov.ua>
+    vollkommen <vollkommen@gmx.net>
     Wesha <wesha@iname.com>
     Will Roberts <squid@bigwillystyle42.com>
     Wojtek Sylwestrzak <W.Sylwestrzak@icm.edu.pl>
     Wolfgang Breyha <wbreyha@gmx.net>
     Wolfgang Nothdurft <wolfgang@linogate.de>
     Zhanpeng Chen <lowstz@gmail.com>
-    benno@jeamland.net
-    fancyrabbit <fancyrabbit@gmail.com>
-    folkert <folkert@vanheusden.com>
-    hno
-    kinkie@squid-cache.org
-    libit <sambabug.lb@gmail.com>
-    rousskov
-    vollkommen <vollkommen@gmx.net>
@@ -1,3 +1,88 @@
+Changes to squid-3.5.0.2 (31 Oct 2014):
+
+	- Fix FTP socket opening during reconfigure
+	- ... and all changes from 3.4.9
+	- ... and some build errors in rarely used code
+	- ... and several documentation updates
+
+Changes to squid-3.5.0.1 (17 Oct 2014):
+
+	- Port from 2.7: redirector and logging urlgroup feature
+	- Bug 4093: source-maintenance.sh bad perl -i option
+	- Bug 3608: per-service name for workers UDS sockets
+	- Bug 2554: 32-bit wrap in AUFS counters
+	- Bug 1961 pt1: URL handling redesign
+	- Bug 1202 pt1: documentation for refresh_pattern algorithms
+	- Update Squid boilerplate copyright/license
+	- Update the http(s)_port directives protocol= parameter
+	- Update forward_max_tries to permit 25 server paths
+	- Update Kerberos library detection and build options
+	- Support ACLs on ftp_epsv directive
+	- Support >32KB objects in cache_dir rock storage
+	- Support client connection annotation by helpers via clt_conn_tag=TAG
+	- Support native FTP Relay
+	- Support libgnugss Kerberos library
+	- Support libecap v1.0
+	- Support SSL Peek and Splice feature
+	- Support receiving PROXY protocol version 1 and 2
+	- Replace --enable-ssl build option with --with-openssl
+	- Enable -n service name command line option for all Squid builds
+	- Enable ICAP client by default
+	- Fix configuration file parsing bugs, related to quoted strings
+	- Fix Windows MinGW build errors
+	- Fix multiple TCP outgoing TOS/DiffServ bugs
+	- Fix Cygwin /etc/resolv.conf parsing
+	- Fix crash when sending %ssl::cert_subject to external ACL w/o certificate
+	- Fix crash reading malformed config files
+	- Send selected SSL version and cipher to the certificate validation helper
+	- Validate server certificates without bumping
+	- Add zero-copy string buffer support
+	- Add automated squid.conf parser testing with squid -k parse
+	- Add adaptation_service ACL
+	- Add logformat code %tS to log transaction start time
+	- Add logformat code %>rd to log client URL domain name
+	- Add key_extras to proxy authentication
+	- Add url_rewrite_extras and store_id_extras directives
+	- Add send_hit and store_miss directives
+	- Add collapsed_forwarding directive
+	- Add sslproxy_cert_sign_hash directive
+	- Add SMP SSL session cache
+	- Add cache_peer standby connections
+	- Add helper ext_delayer_acl
+	- Add TCP_TUNNEL log code for CONNECT tunnels which are not SSL-bumped
+	- Add BUILDCXX and BUILDCXXFLAGS configure options for cross-compile
+	- Remove COSS storage in favour of Rock storage
+	- Remove dnsserver and external DNS helper API in favour of mDNS
+	- Remove broken mallinfo() accounting and memory tracing
+	- Remove hierarchy_stoplist in favour of always_direct
+	- Deprecate tag ACL type in favour of note ACL type
+	- Deprecate urlgroup feature in favour of note ACL type
+	- HTTP/1.1: method names are case-sensitive
+	- HTTP/1.1: register new headers from RFC 723x
+	- squidclient: polish and update help display
+	- squidclient: support TLS with GnuTLS 3.1.5+
+	- squidclient: support verbosity levels
+	- squidclient: --ping mode module support
+	- url_fake_rewrite: support concurrency
+	- storeid_file_rewrite: support concurrency
+	- digest_file_auth: support concurrency
+	- digest_edirectory_auth: support concurrency
+	- digest_ldap_auth: support concurrency
+	- ... and many error page translation updates
+	- ... and much code cleanup and polishing
+
+Changes to squid-3.4.9 (31 Oct 2014):
+
+	- Regression fix: ext_kerberos_ldap_group_acl typo in 3.4.7 update
+	- Bug 4102: sslbump cert contains only a dot character in key usage extension
+	- Bug 4093: source-maintenance.sh errors and warnings due to wrong tools/options
+	- Bug 4088: memory leak in external_acl_type helper with cache=0 or ttl=0
+	- Bug 4024: Bad host/IP ::1 when using IPv4-only environment
+	- Bug 3803: ident leaks memory on failure
+	- kerberos_ldap_group/cert_tool: Remove ksh dependency
+	- ... and some automated code style updates
+	- ... and some documentation updates
+
 Changes to squid-3.4.8 (15 Sep 2014):
 
 	- Fix off by one in SNMP subsystem
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \defgroup compat Portability Library
 
@@ -129,6 +129,7 @@ if test "x$ac_cv_path_PERL" = "xnone"; then
   AC_MSG_FAILURE([Perl is required to compile Squid. Please install Perl and then re-run configure ])
 fi
 AC_PATH_PROG(POD2MAN, pod2man, $FALSE)
+AM_CONDITIONAL(ENABLE_POD2MAN_DOC, test "x${ac_cv_path_POD2MAN}" != "x$FALSE")
 
 dnl set $(AR) if not provided by the build environment
 if test "x$AR" = "x"; then
@@ -222,7 +223,7 @@ case "$squid_host_os" in
 mingw)
   AC_PATH_PROG(WIN32_PSAPI, psapi.dll, none)
   CFLAGS="$CFLAGS -mthreads"
-  CXXFLAGS="$CXXFLAGS -mthreads"
+  CXXFLAGS="$CXXFLAGS -mthreads -static-libgcc -static-libstdc++"
   if test "x$ac_cv_path_WIN32_PSAPI" = "xnone"; then
     AC_MSG_NOTICE([PSAPI.DLL is recommended to run Squid on Windows NT Platform])
     AC_MSG_NOTICE([Please see PSAPI.DLL section on doc/win32-relnotes.html.])
@@ -3849,6 +3850,7 @@ AC_CONFIG_FILES([
 	helpers/storeid_rewrite/Makefile
 	helpers/storeid_rewrite/file/Makefile
 	tools/Makefile
+	tools/helper-mux/Makefile
 	tools/squidclient/Makefile
 	tools/purge/Makefile
 ])
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 #
 # Makefile for installing Squid startup files on systems
 # using a SVR4-based startup mechanism/file system layout
@@ -1,3 +1,9 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 SUBDIRS = manuals
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \mainpage Squid 3.x Developer Programming Guide
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \page Conventions Coding and Other Conventions used in Squid
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \ingroup Component
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \page 05_TypicalRequestFlow Flow of a Typical Request
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \defgroup ACLAPI Access Controls
 \ingroup Components
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \defgroup AuthAPIBasic Basic Authentication
 \ingroup AuthAPI
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \page 10_DelayPools Delay Pools
 
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
  \defgroup POD              POD Classes
  *
@@ -1,3 +1,9 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 all:
 	dyn-docs
@@ -1,4 +1,12 @@
-\**
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/**
  \defgroup StorageManager Storage Manager
  \ingroup Components
  *
@@ -1,3 +1,10 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
 
 section 00    Announcement Server
 section 00    Client Database
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 ##
 ## None of the .po or .pot are distributed for builds at this stage.
 ##
@@ -1,3 +1,9 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
 ## DEFAULT_MIME_TABLE      = $(sysconfdir)/mime.conf
 ## DEFAULT_ERROR_DIR       = $(datadir)/errors
@@ -1,3 +1,10 @@
+##
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 TRANSLATE_LANGUAGES= \
     ar.lang \
     cs.lang \
@@ -1,6 +1,13 @@
-all: release-3.5.html
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 
-DOC= release-3.5
+all: release-3.6.html
+
+DOC= release-3.6
 
 $(DOC).ps: $(DOC).sgml
 	linuxdoc -B latex -o ps $(DOC)
@@ -1080,4 +1080,12 @@ See the accf_http(9) man page.
 
 </descrip>
 
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
 </article>
@@ -1777,4 +1777,12 @@ This section gives an account of those changes in three categories:
 
 </descrip>
 
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
 </article>
@@ -1114,4 +1114,13 @@ This section gives an account of those changes in three categories:
 	<p>Not yet ported from 2.7
 	
 </descrip>
+
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
 </article>
@@ -361,4 +361,12 @@ This section gives an account of those changes in three categories:
 	
 </descrip>
 
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
 </article>
@@ -1,573 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<HTML>
-<HEAD>
- <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
- <TITLE>Squid 3.4.0.0 release notes</TITLE>
-</HEAD>
-<BODY>
-<H1>Squid 3.4.0.0 release notes</H1>
-
-<H2>Squid Developers</H2>
-<HR>
-<EM>This document contains the release notes for version 3.4 of Squid.
-Squid is a WWW Cache application developed by the National Laboratory
-for Applied Network Research and members of the Web Caching community.</EM>
-<HR>
-<P>
-<H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
-
-<UL>
-<LI><A NAME="toc1.1">1.1</A> <A HREF="#ss1.1">Known issues</A>
-<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-3.4</A>
-</UL>
-<P>
-<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></H2>
-
-<UL>
-<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
-<LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
-<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">Store-ID</A>
-<LI><A NAME="toc2.4">2.4</A> <A HREF="#ss2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
-<LI><A NAME="toc2.5">2.5</A> <A HREF="#ss2.5">Transaction Annotations</A>
-<LI><A NAME="toc2.6">2.6</A> <A HREF="#ss2.6">Multicast DNS</A>
-</UL>
-<P>
-<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
-
-<UL>
-<LI><A NAME="toc3.1">3.1</A> <A HREF="#ss3.1">New tags</A>
-<LI><A NAME="toc3.2">3.2</A> <A HREF="#ss3.2">Changes to existing tags</A>
-<LI><A NAME="toc3.3">3.3</A> <A HREF="#ss3.3">Removed tags</A>
-</UL>
-<P>
-<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.3</A></H2>
-
-<UL>
-<LI><A NAME="toc4.1">4.1</A> <A HREF="#ss4.1">New options</A>
-<LI><A NAME="toc4.2">4.2</A> <A HREF="#ss4.2">Changes to existing options</A>
-<LI><A NAME="toc4.3">4.3</A> <A HREF="#ss4.3">Removed options</A>
-</UL>
-<P>
-<H2><A NAME="toc5">5.</A> <A HREF="#s5">Regressions since Squid-2.7</A></H2>
-
-<UL>
-<LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Missing squid.conf options available in Squid-2.7</A>
-</UL>
-
-<HR>
-<H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
-
-<P>The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.</P>
-<P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the
-<A HREF="http://www.squid-cache.org/Mirrors/http-mirrors.html">mirrors</A>.</P>
-<P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
-<P>We welcome feedback and bug reports. If you find a bug, please see 
-<A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
-for how to submit a report with a stack trace.</P>
-
-<H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
-</H2>
-
-<P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4">open bugs against Squid-3.4</A>.</P>
-
-
-<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.4</A>
-</H2>
-
-<P>The 3.4 change history can be 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/changesets/">viewed here</A>.</P>
-
-<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></H2>
-
-<P>Squid 3.4 represents a new feature release above 3.3.</P>
-
-<P>The most important of these new features are:
-<UL>
-<LI>Helper protocol extensions</LI>
-<LI>SSL Server Certificate Validator</LI>
-<LI>Store-ID</LI>
-<LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
-<LI>Transaction Annotations</LI>
-<LI>Multicast DNS</LI>
-</UL>
-</P>
-<P>Most user-facing changes are reflected in squid.conf (see below).</P>
-
-
-<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Helper protocol extensions</A>
-</H2>
-
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
-
-<P>The Squid helper protocol used to communicate with authenticators,
-URL-rewriters, Redirectors, and External ACL helpers has been updated
-and extended.</P>
-
-<P><EM>BH</EM> status code is now accepted from all helpers to report
-internal error events separate from <EM>ERR</EM> rejection code.
-Permitting Squid to perform recovery operations specific to
-helper failure instead of a blanket client rejection.</P>
-
-<P>Arbitrary key-value pairs can be returned from any helper.
-Allowing future helpers to be forward- and backward- compatible
-with this and future version of Squid.</P>
-
-
-<H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</A>
-</H2>
-
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/SslServerCertValidator">http://wiki.squid-cache.org/Features/SslServerCertValidator</A>.</P>
-
-<P>The helper consulted after the internal OpenSSL validation, regardless of the
-validation results. The helper will receive:</P>
-<P>
-<UL>
-<LI>the origin server certificate (chain),</LI>
-<LI>the intended domain name, and</LI>
-<LI>a list of OpenSSL validation errors (if any).</LI>
-</UL>
-</P>
-
-<P>If the helper decides to honor an OpenSSL error or report another validation 
-error(s), the helper will return:</P>
-<P>
-<UL>
-<LI>A list of certificates.</LI>
-<LI>A list of items consists the the validation error name (see <EM>%err_name</EM>
-error page macro and <EM>%err_details</EM> code for <EM>logformat</EM>), error reason
-(<EM>%ssl_lib_error macro</EM>), and the offending certificate.</LI>
-</UL>
-</P>
-
-<P>The returned information mimics what the internal OpenSSL-based validation code
-collects now. Returned errors, if any, are fed to <EM>sslproxy_cert_error</EM>,
-triggering the existing SSL error processing code.</P>
-
-<P>The helper invocation controlled by the <EM>sslcrtvalidator_program</EM> and
-<EM>sslcrtvalidator_children</EM> configurations options which are similar to the
-<EM>ssl_crtd</EM> related options. </P>
-
-
-<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">Store-ID</A>
-</H2>
-
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/StoreID">http://wiki.squid-cache.org/Features/StoreID</A>.</P>
-
-<P>This feature is a redesigned equivalent to the Squid-2.7 feature known as StoreURL-rewrite.</P>
-
-<P><EM>Notice</EM> that this is not a direct portage of the Squid-2.7 feature so behaviour
-differences do exist. Although the new feature works in similar enough ways that the old
-helper scripts used for Squid-2.7 are expected to work in this and later versions of Squid.</P>
-
-<P>Squid traditionally uses the requested URL as an index key ID to locate objects in cache.
-It is not the only key possible and the Store-ID feature exposes an API for external
-helpers to provide Squid with an alternative key name for any URL.</P>
-
-<P>When any client request is received which requires a cache lookup the URL is passed to
-a helper specified with the <EM>store_id_program</EM> directive to check for an alternative
-Store ID. This allows the helper to identify URLs which refer to duplicate resources and
-de-duplicate the cache content. <EM>store_id_access</EM> is provided to allow ACL-based
-tuning of which traffic gets sent to the helper and reduce overheads.</P>
-
-<P>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
-this feature is that <EM>refresh_pattern</EM> applies its regex argument against the Store
-ID key and not the transaction URL. So using the Store-ID feature to alter the value
-affects which <EM>refresh_pattern</EM> directive will be matched.</P>
-
-<P>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
-options which is added in this version. Currently there is a <EM>file</EM> helper
-provided.</P>
-
-
-<H2><A NAME="ss2.4">2.4</A> <A HREF="#toc2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
-</H2>
-
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf</A>.</P>
-
-<P>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
-using several very simple methods. One of which is the <EM>divert-to</EM> rule type
-which acts as a simple routing diversion instead of performing NAT packet alterations.</P>
-
-<P>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.</P>
-
-<P>This version of Squid adds support for these features through the ./configure
-options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
-systems with the required support. No special extras are required to enable
-<EM>http_port ... tproxy</EM> configuration to work.</P>
-
-<P>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
-<EM>./configure --enable-pf-transparent</EM> has been altered and is expected to
-break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
-which do not yet support the getsockname() API.
-These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
-
-
-<H2><A NAME="ss2.5">2.5</A> <A HREF="#toc2.5">Transaction Annotations</A>
-</H2>
-
-<P>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
-or external ACL <EM>tag=</EM> result code. Each of which had only limited possibilities
-for use and little or no correlation.</P>
-
-<P>It is now possible to add annotations to a client transaction from several sources:
-<UL>
-<LI>    Directly from squid.conf using the <EM>note</EM> directive with
-ACL-based selection of which annotation is linked to any
-particular transaction.
-</LI>
-<LI>    By configured helper processes returning a key=value pair.
-The key name becomes the annotation name.</LI>
-</UL>
-</P>
-
-<P>Annotations on the transaction can be passed to ICAP services or eCAP modules using the
-<EM>adaptation_meta</EM> directive to send them as headers.
-They can also be logged using the <EM>%note</EM> log format code in custom logs. With
-the new helper response syntax changes this means all helper response key=value details
-such as URL-rewrite or store-id changes, external ACL tag etc. are now able to be logged.</P>
-
-<P>Annotations which are already assigned to a transaction can be checked using an ACL test
-of the new <EM>note</EM> ACL type. This can match a particular note by name and value,
-of for any notes with a given name.</P>
-
-<P>NOTE: not all helper interfaces are yet enabled to convert key=value into annotations
-and the external ACL interface does not yet send annotations to the helper.</P>
-
-
-<H2><A NAME="ss2.6">2.6</A> <A HREF="#toc2.6">Multicast DNS</A>
-</H2>
-
-<P>The internal DNS component fof Squid now supports multicast DNS (mDNS) resolution in
-accordance with RFC 6762.</P>
-
-<P>There is no additional or special configuration required. The multicast DNS group IP
-addresses for IPv4 and IPv6 resolving are added to the set of available DNS resolvers
-and used automatically for domain names ending in <EM>.local</EM> before attempting a
-secondary resolution on the configured resolvers. Domains without <EM>.local</EM> are
-resolved using only the configured DNS resolvers.</P>
-
-<P>Statistics for multicast DNS resolution can be found on the <EM>idns</EM> cache manager
-report.</P>
-
-
-<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
-
-<P>There have been changes to Squid's configuration file since Squid-3.3.</P>
-
-<P>Squid supports reading configuration option parameters from external
-files using the syntax <EM>parameters("/path/filename")</EM>. For example:
-<PRE>
-    acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
-</PRE>
-</P>
-
-<P>There hasve also been changes to individual directives in the config file.</P>
-<P>This section gives a thorough account of those changes in three categories:</P>
-<P>
-<UL>
-<LI>
-<A HREF="#newtags">New tags</A></LI>
-<LI>
-<A HREF="#modifiedtags">Changes to existing tags</A></LI>
-<LI>
-<A HREF="#removedtags">Removed tags</A></LI>
-</UL>
-</P>
-
-
-<H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>configuration_includes_quoted_values</B><DD>
-<P>Whether Squid supports directive parameters with spaces, quotes, and other
-special characters. Surround such parameters with "double quotes".</P>
-
-<DT><B>note</B><DD>
-<P>Use ACLs to annotate a transaction with customized annotations
-which can be logged in access.log</P>
-
-<DT><B>spoof_client_ip</B><DD>
-<P>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.</P>
-
-<DT><B>sslcrtvalidator_children</B><DD>
-<P>Specifies the settings for how many SSL server certificate
-validator helpers are run and when they are started.</P>
-
-<DT><B>sslcrtvalidator_program</B><DD>
-<P>Specifies the location of a SSL server certificate validator helper.</P>
-
-<DT><B>store_id_access</B><DD>
-<P>Whether the URL for a given request is passed to the Store-ID helper process.
-Used to improve StoreID performance by quickly eliminating helper delays using ACL tests.</P>
-<P>Ported equivalent to <EM>storeurl_access</EM> from 2.7</P>
-
-<DT><B>store_id_bypass</B><DD>
-<P>Whether the StoreID helper may be bypassed when overloaded.</P>
-
-<DT><B>store_id_children</B><DD>
-<P>Controls the number of StoreID helper processes.</P>
-<P>Options <EM>startup=N</EM>, <EM>idle=N</EM>, <EM>concurrency=N</EM>
-<UL>
-<LI>startup=N allow finer tuning of how many helpers are started initially.</LI>
-<LI>idle=N allow fine tuning of how many helper to retain as buffer against sudden traffic loads.</LI>
-<LI>concurrency=N was previously called url_rewrite_concurrency as a distinct directive.</LI>
-</UL>
-</P>
-
-<DT><B>storeurl_rewrite_program</B><DD>
-<P>A helper program to provide cache storage internal key ID value for a request.</P>
-<P>Ported equivalent to <EM>storeurl_rewrite_program</EM> from 2.7</P>
-
-</DL>
-</P>
-
-<H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Changes to existing tags</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>access_log</B><DD>
-<P>Configuration syntax extended to support name=value options.
-<EM>New Syntax:</EM> access_log module:place [option ...] [acl ...]</P>
-<P>New option <EM>logformat=</EM> to specify the logging format name.</P>
-<P>New option <EM>buffer-size=</EM> to specify how large the log buffer
-for this log is to be when <EM>buffered_logs</EM> is enabled.</P>
-<P>New option <EM>on-error=</EM> to specify what handling is to be done
-if the logging module encounters a non-recoverable error writing logs.
-With the value <EM>die</EM> (the default) Squid halts operation.
-With the value <EM>drop</EM> Squid drops log lines and continue running.</P>
-
-<DT><B>acl</B><DD>
-<P>New test type <EM>server_cert_fingerprint</EM> to match against 
-server SSL certificate fingerprint.</P>
-<P>New test type <EM>note</EM> to match against transaction annotations
-by name and value, or just by name.</P>
-<P>New test type <EM>any-of</EM> to match if any one of a set of named ACLs.</P>
-<P>New test type <EM>all-of</EM> to match against all of a set of named ACLs.</P>
-
-<DT><B>auth_param</B><DD>
-<P>New result code <EM>BH</EM> to signal helper internal errors
-available in all authentication schemes.</P>
-<P>New key <EM>message=</EM> for error message details in all authentication schemes.</P>
-<P>New result code <EM>OK</EM> and key <EM>ha1=</EM> in Digest authentication.</P>
-<P>New result codes <EM>OK</EM>, <EM>ERR</EM> replace result codes <EM>AF</EM>,
-and <EM>NA</EM> in NTLM and Negotiate authentication.</P>
-<P>New key <EM>token=</EM> for NTLM and Negotiate authentication <EM>OK</EM> responses.</P>
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
-
-<DT><B>external_acl_type</B><DD>
-<P>Deprecated <EM>protocol=3.0</EM> option. No longer necessary.</P>
-<P>New result code <EM>BH</EM> to signal helper internal errors</P>
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
-
-<DT><B>http_port</B><DD>
-<P>Support IPv6 for <EM>intercept</EM> mode. Requires ip6tables support on Linux,
-PF support on OpenBSD and IPFW support on FreeBSD. Squid will no longer complain
-about misconfiguration if IPv6 support is missing, we now rely on the firewall
-tools reporting misconfiguration when the NAT rules are created.</P>
-<P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
-(OpenBSD 5+, FreeBSD 9+ so far).</P>
-<P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
-see <EM>--enable-pf-transparent</EM> for more details.</P>
-
-<DT><B>logformat</B><DD>
-<P>New format code <EM>%note</EM> to log a transaction annotation linked to the
-transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
-<P>New format code <EM>%&gt;qos</EM> to log client connection TOS/DSCP value set by Squid.</P>
-<P>New format code <EM>%&lt;qos</EM> to log server connection TOS/DSCP value set by Squid.</P>
-<P>New format code <EM>%&gt;nfmark</EM> to log client connection netfilter mark set by Squid.</P>
-<P>New format code <EM>%&lt;nfmark</EM> to log server connection netfilter mark set by Squid.</P>
-
-<DT><B>pipeline_prefetch</B><DD>
-<P>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.</P>
-
-<DT><B>refresh_pattern</B><DD>
-<P><EM>NOTE:</EM> the regular expression pattern operates on the cache Store-ID value.
-Which by default is identical to the requested URL, but may differ for some
-objects if the Store-ID feature is in use.</P>
-
-<DT><B>unlinkd_program</B><DD>
-<P>New helper response format utilizing result codes <EM>OK</EM> and <EM>BH</EM>,
-to signal helper lookup results. Also, key-value response values to return
-multiple values to Squid.</P>
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
-
-<DT><B>url_rewrite_program</B><DD>
-<P>New helper response format utilizing result codes <EM>OK</EM>, <EM>ERR</EM>,
-and <EM>BH</EM> to signal helper lookup results. Also, key-value response
-values to return multiple values to Squid.</P>
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
-
-</DL>
-</P>
-
-<H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed tags</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>storeurl_access</B><DD>
-<P>Replaced by <EM>store_id_access</EM>.</P>
-
-<DT><B>storeurl_rewrite_children</B><DD>
-<P>Replaced by <EM>store_id_children</EM>.</P>
-
-<DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Replaced by <EM>store_id_children</EM> with <EM>concurrency=N</EM> option.</P>
-
-<DT><B>storeurl_rewrite_program</B><DD>
-<P>Replaced by <EM>store_id_program</EM>.</P>
-
-</DL>
-</P>
-
-
-<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.3</A></H2>
-
-<P>There have been some changes to Squid's build configuration since Squid-3.3.</P>
-<P>This section gives an account of those changes in three categories:</P>
-<P>
-<UL>
-<LI>
-<A HREF="#newoptions">New options</A></LI>
-<LI>
-<A HREF="#modifiedoptions">Changes to existing options</A></LI>
-<LI>
-<A HREF="#removedoptions">Removed options</A></LI>
-</UL>
-</P>
-
-
-<H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New options</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>--enable-storeid-rewrite-helpers</B><DD>
-<P>New option to control which Store-ID helpers are built. As with other
-helper options use --disable-* to prevent any helpers building and
-omit to get all helper auto-detected.</P>
-<P>Currenly only a helper using <EM>file</EM> for backend is provided.</P>
-
-<DT><B>--with-nat-pf</B><DD>
-<P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
-in squid.conf.</P>
-<P>When this option is used Squid performs the /dev/pf lookups required to
-support PF <EM>rdr-to</EM> rules. Otherwise Squid will perform perform the
-getsockname() API calls to support PF <EM>divert-to</EM> rules.</P>
-<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
-the getsockname() API in recent PF versions require this option.</P>
-
-</DL>
-</P>
-
-<H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Changes to existing options</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>--enable-pf-transparent</B><DD>
-<P>NAT table support updated to use the getsockname() API provided by the
-latest PF versions <EM>divert-to</EM>. This allows <EM>http_port</EM>
-in squid.conf to support both <EM>intercept</EM> and <EM>tproxy</EM> traffic
-and to silence NAT lookup failure messages on recent BSD.</P>
-<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
-the getsockname() API in recent PF versions require <EM>--with-nat-devpf</EM>
-to re-enable /dev/pf support when using PF firewall.</P>
-
-</DL>
-</P>
-<H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Removed options</A>
-</H2>
-
-<P>
-<DL>
-<P><EM>There are no removed ./configure options in Squid-3.4.</EM></P>
-
-</DL>
-</P>
-
-
-<H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
-
-<P>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.4</P>
-
-<P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
-
-<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options available in Squid-2.7</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>broken_vary_encoding</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>cache_dir</B><DD>
-<P><EM>COSS</EM> storage type is lacking stability fixes from 2.6</P>
-<P>COSS <EM>overwrite-percent=</EM> option not yet ported from 2.6</P>
-<P>COSS <EM>max-stripe-waste=</EM> option not yet ported from 2.6</P>
-<P>COSS <EM>membufs=</EM> option not yet ported from 2.6</P>
-<P>COSS <EM>maxfullbufs=</EM> option not yet ported from 2.6</P>
-
-<DT><B>cache_peer</B><DD>
-<P><EM>idle=</EM> not yet ported from 2.7</P>
-<P><EM>monitorinterval=</EM> not yet ported from 2.6</P>
-<P><EM>monitorsize=</EM> not yet ported from 2.6</P>
-<P><EM>monitortimeout=</EM> not yet ported from 2.6</P>
-<P><EM>monitorurl=</EM> not yet ported from 2.6</P>
-
-<DT><B>cache_vary</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>collapsed_forwarding</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>error_map</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>external_refresh_check</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>ignore_ims_on_miss</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>location_rewrite_access</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>location_rewrite_children</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>location_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>location_rewrite_program</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>refresh_pattern</B><DD>
-<P><EM>stale-while-revalidate=</EM> not yet ported from 2.7</P>
-<P><EM>ignore-stale-while-revalidate=</EM> not yet ported from 2.7</P>
-<P><EM>negative-ttl=</EM> not yet ported from 2.7</P>
-
-<DT><B>refresh_stale_hit</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>update_headers</B><DD>
-<P>Not yet ported from 2.7</P>
-
-</DL>
-</P>
-
-</BODY>
-</HTML>
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.8 release notes</title>
+<title>Squid 3.4.9 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,14 +13,15 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.8 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.9 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
-While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
+<p>Some interesting new features adding system flexibility have been added along with general improvements all around.
+   While this release is not fully bug-free we believe it is ready for use in production on many systems.
 
-We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
+<p>We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
  for how to submit a report with a stack trace.
 
 <sect1>Known issues
@@ -492,4 +493,12 @@ This section gives an account of those changes in three categories:
 
 </descrip>
 
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
 </article>
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.0.0 release notes</title>
+<title>Squid 3.5.0.2 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,15 +13,15 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.0.0 for testing.
+The Squid Team are pleased to announce the release of Squid-3.5.0.2 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
-While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
+<p>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
 
-We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
- for how to submit a report with a stack trace.
+<p>We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
+   for how to submit a report with a stack trace.
 
 <sect1>Known issues
 <p>
@@ -69,7 +69,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 
 
 <sect1>Support libecap v1.0
-<p>Details at <url url="http://wiki.squid-cache.org/Features/BLAH">.
+<p>Details at <url url="http://wiki.squid-cache.org/Features/eCAP">.
 
 <p>The new libecap version allows Squid to better check the version of
   the eCAP adapter being loaded as well as the version of the eCAP library
@@ -117,6 +117,8 @@ Most user-facing changes are reflected in squid.conf (see below).
 
 
 <sect1>Upgraded squidclient tool
+<p>Details at <url="http://www.squid-cache.org/Versions/v3/3.5/manuals/squidclient.html">.
+
 <p>The <em>squidclient</em> has begun the process of upgrading to support
    protocols other than HTTP.
 
@@ -205,8 +207,7 @@ Most user-facing changes are reflected in squid.conf (see below).
    <em>ftp://</em> URIs because Squid works as an FTP server and receives
    actual FTP commands (rather than HTTP requests with FTP URLs).
 
-<p>FTP Relay highlights:</p>
-
+<p>FTP Relay highlights:
 <itemize>
     <item>Added ftp_port directive telling Squid to relay native FTP commands.
     <item>Active and passive FTP support on the user-facing side; require
@@ -245,25 +246,25 @@ Most user-facing changes are reflected in squid.conf (see below).
    trusted to send correct client details.
 
 <p>Forward-proxy traffic from a client proxy:
-<verbatim>
+<verb>
  acl frontend src 192.0.2.1
  http_port 3128 require-proxy-header
  proxy_protocol_access allow frontend
-</verbatim>
+</verb>
 
 <p>Intercepted traffic from a client proxy or tunnel:
-<verbatim>
+<verb>
  acl frontend src 192.0.2.2
  http_port 3128 intercept require-proxy-header
  proxy_protocol_access allow frontend
-</verbatim>
+</verb>
 
 <p>Reverse-proxy traffic from a frontend load balancer sending PROXY protocol:
-<verbatim>
+<verb>
  acl frontend src 192.0.2.3
  http_port 3128 accel require-proxy-header
  proxy_protocol_access allow frontend
-</verbatim>
+</verb>
 
 <p><em>Known Issue:</em>
    Use of <em>require-proxy-header</em> on <em>https_port</em> and <em>ftp_port</em> is not supported.
@@ -279,7 +280,7 @@ There have been changes to Squid's configuration file since Squid-3.4.
     acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
 </verb>
 
-<p>The squid.conf macro ${service_name} is added to provide the service name
+<p>The squid.conf macro <em>${service_name}</em> is added to provide the service name
    of the process parsing the config.
 
 <p>There have also been changes to individual directives in the config file.
@@ -300,6 +301,24 @@ This section gives a thorough account of those changes in three categories:
 	<p>Ported from Squid-2 with no configuration or visible behaviour changes.
            Collapsing of requests is performed across SMP workers.
 
+	<tag>ftp_client_idle_timeout</tag>
+	<p>This new configuration directive controls how long Squid should
+	   wait for an FTP request on a connection to an ftp_port.  Many FTP
+	   clients do not deal with idle connection closures well,
+	   necessitating a longer default timeout (30 minutes) than
+	   client_idle_pconn_timeout used for incoming HTTP requests (2
+	   minutes). The current default may be changed as we get more
+	   experience with FTP relaying.
+
+	<tag>ftp_client_idle_timeout</tag>
+	<p>New directive controlling how long to wait for an FTP request on a
+	   client connection to Squid <em>ftp_port</em>.
+
+	<tag>ftp_port</tag>
+	<p>New configuration directive to accept and relay native FTP
+	   commands. Typically used for port 21 traffic.  By default, native
+	   FTP commands are not accepted.
+
 	<tag>proxy_protocol_access</tag>
 	<p>New directive to control which clients are permitted to open PROXY
 	   protocol connections on a port flagged with <em>require-proxy-header</em>.
@@ -309,6 +328,9 @@ This section gives a thorough account of those changes in three categories:
 	   based on ACL selection. ACL can be based on client request or cached
 	   response details.
 
+	<tag>sslproxy_cert_sign_hash</tag>
+	<p>New directive to set the hashing algorithm to use when signing generated certificates.
+
 	<tag>sslproxy_session_cache_size</tag>
 	<p>New directive which sets the cache size to use for TLS/SSL sessions cache.
 
@@ -322,7 +344,7 @@ This section gives a thorough account of those changes in three categories:
 	<verb>
          [channel-ID] url [extras]
 	</verb>
-	<p>The default value for extras is: "%&gt;a/%>A %un %>rm myip=%la myport=%lp"
+	<p>The default value for extras is: "%&gt;a/%&gt;A %un %&gt;rm myip=%la myport=%lp"
 
 	<tag>store_miss</tag>
 	<p>New configuration directive to enable/disable caching of MISS responses.
@@ -336,34 +358,22 @@ This section gives a thorough account of those changes in three categories:
 	<verb>
          [channel-ID] url [extras]
 	</verb>
-	<p>The default value for extras is: "%>a/%>A %un %>rm myip=%la myport=%lp"
-
-	<tag>ftp_port</tag>
-
-	<p>New configuration directive to accept and relay native FTP
-	   commands. Typically used for port 21 traffic.  By default, native
-	   FTP commands are not accepted.
-
-	<tag>ftp_client_idle_timeout</tag>
-
-	<p>This new configuration directive controls how long Squid should
-	   wait for an FTP request on a connection to an ftp_port.  Many FTP
-	   clients do not deal with idle connection closures well,
-	   necessitating a longer default timeout (30 minutes) than
-	   client_idle_pconn_timeout used for incoming HTTP requests (2
-	   minutes). The current default may be changed as we get more
-	   experience with FTP relaying.
+	<p>The default value for extras is: "%&gt;a/%&gt;A %un %&gt;rm myip=%la myport=%lp"
 
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
 	<tag>acl</tag>
+	<p>Deprecated type <em>tag</em>. Use type <em>note</em> with 'tag' key
+	   name instead.
 	<p>New type <em>adaptation_service</em> to match the name of any
 	   icap_service, ecap_service, adaptation_service_set, or
 	   adaptation_service_chain that Squid has used (or attempted to use)
 	   for the HTTP transaction so far.
+	<p>New type <em>at_step</em> to match the current SSL-Bump processing step.
+	   Never matches and should not be used outside of <em>ssl_bump</em>.
 
 	<tag>auth_param</tag>
 	<p>New parameter <em>key_extras</em> to send additional parameters to
@@ -377,6 +387,8 @@ This section gives a thorough account of those changes in three categories:
 	   maximum slot size is 32KB.
 	<p>Removal of old rock cache dir followed by <em>squid -z</em> is required
 	   when upgrading from earlier versions of Squid.
+	<p><em>COSS</em> storage type is formally replaced by Rock storage type.
+	   COSS storage type and all COSS specific options are removed.
 
 	<tag>cache_peer</tag>
 	<p>New <em>standby=N</em> option to retain a set of N open and unused
@@ -386,6 +398,16 @@ This section gives a thorough account of those changes in three categories:
 	   have not been used for HTTP messaging (and may never be). They may be
 	   turned into persistent connections after their first use subject to the
 	   same keep-alive critera any HTTP connection is checked for.
+	<p>Squid-2 option <em>idle=</em> replaced by <em>standby=</em>.
+	<p>NOTE that standby connections are started earlier and available in
+	   more circumstances than squid-2 idle connections were. They are
+	   also spread over all IPs of the peer.
+
+	<tag>external_acl_type</tag>
+	<p>New format code <em>%ssl::&gt;sni</em> to send SSL client SNI.
+	<p>New format code <em>%ssl::&lt;cert_subject</em> to send SSL server certificate DN.
+	<p>New format code <em>%ssl::&lt;cert_issuer</em> to send SSL server certificate issuer DN.
+	<p>New response kv-pair <em>clt_conn_tag=</em> to associates a given tag with the client TCP connection.
 
 	<tag>forward_max_tries</tag>
 	<p>Default value increased to <em>25 destinations</em> to allow better
@@ -402,40 +424,49 @@ This section gives a thorough account of those changes in three categories:
 	<tag>http_port</tag>
 	<p><em>protocol=</em> option altered to accept protocol version details.
 	   Currently supported values are: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1
-	<p><em>New option <em>require-proxy-header</em> to mark ports receiving PROXY
+	<p>New option <em>require-proxy-header</em> to mark ports receiving PROXY
 	   protocol version 1 or 2 traffic.
 
 	<tag>https_port</tag>
 	<p><em>protocol=</em> option altered to accept protocol version details.
 	   Currently supported values are: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1
 
 	<tag>logformat</tag>
-	<p>New format code <em>%credentials</em> to log the client credentials
-	   token.
+	<p>New format code <em>%credentials</em> to log the client credentials token.
+	<p>New format code <em>%ssl::&gt;sni</em> to TLS client SNI sent to Squid.
 	<p>New format code <em>%tS</em> to log transaction start time in
 	   "seconds.milliseconds" format, similar to the existing access.log
 	   "current time" field (%ts.%03tu) which logs the corresponding
 	   transaction finish time.
+	<p>New format codes <em>%&lt;rs</em> and <em>%&gt;rs</em> to log request URL
+	   scheme from client or sent to server/peer respectively.
+	<p>New format codes <em>%&lt;rd</em> and <em>%&gt;rd</em> to log request URL
+	   domain from client or sent to server/peer respectively.
+	<p>New format codes <em>%&lt;rP</em> and <em>%&gt;rP</em> to log request URL
+	   port from client or sent to server/peer respectively.
+
+	<tag>ssl_bump</tag>
+	<p>Bumping 'modes' redesigned as 'actions' and ACLs evaluated repeatedly in a number of steps.
+	<p>Renamed <em>server-first</em> as <em>bump</em> action.
+	<p>Renamed <em>none</em> as <em>splice</em> action.
+	<p>New actions <em>peek</em> and <em>stare</em> to receive client or server
+	   certificate while preserving the ability to later decide between bumping
+	   or splicing the connections later.
+	<p>New action <em>terminate</em> to close the client and server connections.
+
+	<tag>url_rewrite_program</tag>
+	<p>New response kv-pair <em>clt_conn_tag=</em> to associates a given tag with the client TCP connection.
 
 </descrip>
 
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
-	<tag>cache_dir</tag>
-	<p><em>COSS</em> storage type is formally replaced by Rock storage type.
-
 	<tag>cache_dns_program</tag>
 	<p>DNS external helper interface has been removed. It was no longer
 	   able to provide high performance service and the internal DNS
 	   client library with multicast DNS cover all modern use-cases.
 
-	<tag>cache_peer</tag>
-	<p><em>idle=</em> replaced by <em>standby=</em>.
-	<p>NOTE that standby connections are started earlier and available in
-	   more circumstances than squid-2 idle connections were. They are
-	   also spread over all IPs of the peer.
-
 	<tag>dns_children</tag>
 	<p>DNS external helper interface has been removed.
 
@@ -581,4 +612,12 @@ This section gives an account of those changes in three categories:
 
 </descrip>
 
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
 </article>
@@ -0,0 +1,251 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
+ <TITLE>Squid 3.6.0.0 release notes</TITLE>
+</HEAD>
+<BODY>
+<H1>Squid 3.6.0.0 release notes</H1>
+
+<H2>Squid Developers</H2>
+<HR>
+<EM>This document contains the release notes for version 3.6 of Squid.
+Squid is a WWW Cache application developed by the National Laboratory
+for Applied Network Research and members of the Web Caching community.</EM>
+<HR>
+<P>
+<H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
+
+<UL>
+<LI><A NAME="toc1.1">1.1</A> <A HREF="#ss1.1">Known issues</A>
+<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-3.6</A>
+</UL>
+<P>
+<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.5</A></H2>
+
+<UL>
+<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">BLAH</A>
+</UL>
+<P>
+<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.5</A></H2>
+
+<UL>
+<LI><A NAME="toc3.1">3.1</A> <A HREF="#ss3.1">New tags</A>
+<LI><A NAME="toc3.2">3.2</A> <A HREF="#ss3.2">Changes to existing tags</A>
+<LI><A NAME="toc3.3">3.3</A> <A HREF="#ss3.3">Removed tags</A>
+</UL>
+<P>
+<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.5</A></H2>
+
+<UL>
+<LI><A NAME="toc4.1">4.1</A> <A HREF="#ss4.1">New options</A>
+<LI><A NAME="toc4.2">4.2</A> <A HREF="#ss4.2">Changes to existing options</A>
+<LI><A NAME="toc4.3">4.3</A> <A HREF="#ss4.3">Removed options</A>
+</UL>
+<P>
+<H2><A NAME="toc5">5.</A> <A HREF="#s5">Regressions since Squid-2.7</A></H2>
+
+<UL>
+<LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Missing squid.conf options available in Squid-2.7</A>
+</UL>
+<P>
+<H2><A NAME="toc6">6.</A> <A HREF="#s6">Copyright</A></H2>
+
+
+<HR>
+<H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
+
+<P>The Squid Team are pleased to announce the release of Squid-3.6.0.0 for testing.</P>
+<P>This new release is available for download from 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.6/">http://www.squid-cache.org/Versions/v3/3.6/</A> or the
+<A HREF="http://www.squid-cache.org/Mirrors/http-mirrors.html">mirrors</A>.</P>
+
+<P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
+
+<P>We welcome feedback and bug reports. If you find a bug, please see 
+<A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
+for how to submit a report with a stack trace.</P>
+
+<H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
+</H2>
+
+<P>Although this release is deemed good enough for use in many setups, please note the existence of 
+<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.6">open bugs against Squid-3.6</A>.</P>
+
+<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.6</A>
+</H2>
+
+<P>The 3.6 change history can be 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.6/changesets/">viewed here</A>.</P>
+
+
+<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.5</A></H2>
+
+<P>Squid 3.6 represents a new feature release above 3.5.</P>
+
+<P>The most important of these new features are:
+<UL>
+<LI>BLAH</LI>
+</UL>
+</P>
+<P>Most user-facing changes are reflected in squid.conf (see below).</P>
+
+
+<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">BLAH</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/BLAH">http://wiki.squid-cache.org/Features/BLAH</A>.</P>
+
+
+<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.5</A></H2>
+
+<P>There have been changes to Squid's configuration file since Squid-3.5.</P>
+<P>This section gives a thorough account of those changes in three categories:</P>
+<P>
+<UL>
+<LI>
+<A HREF="#newtags">New tags</A></LI>
+<LI>
+<A HREF="#modifiedtags">Changes to existing tags</A></LI>
+<LI>
+<A HREF="#removedtags">Removed tags</A></LI>
+</UL>
+</P>
+
+
+<H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A>
+</H2>
+
+<P>
+<DL>
+
+</DL>
+</P>
+
+<H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Changes to existing tags</A>
+</H2>
+
+<P>
+<DL>
+
+</DL>
+</P>
+
+<H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed tags</A>
+</H2>
+
+<P>
+<DL>
+
+</DL>
+</P>
+
+
+<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.5</A></H2>
+
+<P>There have been some changes to Squid's build configuration since Squid-3.5.</P>
+<P>This section gives an account of those changes in three categories:</P>
+<P>
+<UL>
+<LI>
+<A HREF="#newoptions">New options</A></LI>
+<LI>
+<A HREF="#modifiedoptions">Changes to existing options</A></LI>
+<LI>
+<A HREF="#removedoptions">Removed options</A></LI>
+</UL>
+</P>
+
+
+<H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New options</A>
+</H2>
+
+<P>
+<DL>
+
+</DL>
+</P>
+
+<H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Changes to existing options</A>
+</H2>
+
+<P>
+<DL>
+
+</DL>
+</P>
+<H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Removed options</A>
+</H2>
+
+<P>
+<DL>
+
+</DL>
+</P>
+
+
+<H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
+
+<P>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.6</P>
+
+<P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
+
+<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options available in Squid-2.7</A>
+</H2>
+
+<P>
+<DL>
+<DT><B>broken_vary_encoding</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>cache_peer</B><DD>
+<P><EM>monitorinterval=</EM> not yet ported from 2.6</P>
+<P><EM>monitorsize=</EM> not yet ported from 2.6</P>
+<P><EM>monitortimeout=</EM> not yet ported from 2.6</P>
+<P><EM>monitorurl=</EM> not yet ported from 2.6</P>
+
+<DT><B>cache_vary</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>error_map</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>external_refresh_check</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>location_rewrite_access</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>location_rewrite_children</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>location_rewrite_concurrency</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>location_rewrite_program</B><DD>
+<P>Not yet ported from 2.6</P>
+
+<DT><B>refresh_pattern</B><DD>
+<P><EM>stale-while-revalidate=</EM> not yet ported from 2.7</P>
+<P><EM>ignore-stale-while-revalidate=</EM> not yet ported from 2.7</P>
+<P><EM>negative-ttl=</EM> not yet ported from 2.7</P>
+
+<DT><B>refresh_stale_hit</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>update_headers</B><DD>
+<P>Not yet ported from 2.7</P>
+
+</DL>
+</P>
+
+<H2><A NAME="s6">6.</A> <A HREF="#toc6">Copyright</A></H2>
+
+<P>Copyright (C) 1996-2014 The Squid Software Foundation and contributors</P>
+<P>Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.</P>
+
+</BODY>
+</HTML>
@@ -0,0 +1,176 @@
+<!doctype linuxdoc system>
+<article>
+<title>Squid 3.6.0.0 release notes</title>
+<author>Squid Developers</author>
+
+<abstract>
+This document contains the release notes for version 3.6 of Squid.
+Squid is a WWW Cache application developed by the National Laboratory
+for Applied Network Research and members of the Web Caching community.
+</abstract>
+
+<toc>
+
+<sect>Notice
+<p>
+The Squid Team are pleased to announce the release of Squid-3.6.0.0 for testing.
+
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.6/"> or the
+ <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+
+<p>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
+
+<p>We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
+   for how to submit a report with a stack trace.
+
+<sect1>Known issues
+<p>
+Although this release is deemed good enough for use in many setups, please note the existence of 
+<url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.6" name="open bugs against Squid-3.6">.
+
+<sect1>Changes since earlier releases of Squid-3.6
+<p>
+The 3.6 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.6/changesets/" name="viewed here">.
+
+
+<sect>Major new features since Squid-3.5
+<p>Squid 3.6 represents a new feature release above 3.5.
+
+<p>The most important of these new features are:
+<itemize>
+	<item>BLAH
+</itemize>
+
+Most user-facing changes are reflected in squid.conf (see below).
+
+
+<sect1>BLAH
+<p>Details at <url url="http://wiki.squid-cache.org/Features/BLAH">.
+
+
+<sect>Changes to squid.conf since Squid-3.5
+<p>
+There have been changes to Squid's configuration file since Squid-3.5.
+
+This section gives a thorough account of those changes in three categories:
+
+<itemize>
+	<item><ref id="newtags" name="New tags">
+	<item><ref id="modifiedtags" name="Changes to existing tags">
+	<item><ref id="removedtags" name="Removed tags">
+</itemize>
+<p>
+
+<sect1>New tags<label id="newtags">
+<p>
+<descrip>
+
+</descrip>
+
+<sect1>Changes to existing tags<label id="modifiedtags">
+<p>
+<descrip>
+
+</descrip>
+
+<sect1>Removed tags<label id="removedtags">
+<p>
+<descrip>
+
+</descrip>
+
+
+<sect>Changes to ./configure options since Squid-3.5
+<p>
+There have been some changes to Squid's build configuration since Squid-3.5.
+
+This section gives an account of those changes in three categories:
+
+<itemize>
+	<item><ref id="newoptions" name="New options">
+	<item><ref id="modifiedoptions" name="Changes to existing options">
+	<item><ref id="removedoptions" name="Removed options">
+</itemize>
+
+
+<sect1>New options<label id="newoptions">
+<p>
+<descrip>
+
+</descrip>
+
+<sect1>Changes to existing options<label id="modifiedoptions">
+<p>
+<descrip>
+
+</descrip>
+</p>
+
+<sect1>Removed options<label id="removedoptions">
+<p>
+<descrip>
+
+</descrip>
+
+
+<sect>Regressions since Squid-2.7
+
+<p>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.6
+
+<p>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.
+
+<sect1>Missing squid.conf options available in Squid-2.7
+<p>
+<descrip>
+	<tag>broken_vary_encoding</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>cache_peer</tag>
+	<p><em>monitorinterval=</em> not yet ported from 2.6
+	<p><em>monitorsize=</em> not yet ported from 2.6
+	<p><em>monitortimeout=</em> not yet ported from 2.6
+	<p><em>monitorurl=</em> not yet ported from 2.6
+
+	<tag>cache_vary</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>error_map</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>external_refresh_check</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>location_rewrite_access</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>location_rewrite_children</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>location_rewrite_concurrency</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>location_rewrite_program</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>refresh_pattern</tag>
+	<p><em>stale-while-revalidate=</em> not yet ported from 2.7
+	<p><em>ignore-stale-while-revalidate=</em> not yet ported from 2.7
+	<p><em>negative-ttl=</em> not yet ported from 2.7
+
+	<tag>refresh_stale_hit</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>update_headers</tag>
+	<p>Not yet ported from 2.7
+
+</descrip>
+
+<sect>Copyright
+<p>
+Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+<p>
+Squid software is distributed under GPLv2+ license and includes
+contributions from numerous individuals and organizations.
+Please see the COPYING and CONTRIBUTORS files for details.
+
+</article>
@@ -1,4 +1,12 @@
 #!/bin/sh
+#
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 #
 # Generate Symlinks for a set of aliases.
 # Our base content is the bundled .po translation output
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 # 3.0 Still published with the old language namings.
 # we leave these alone in case any are configured...
 az	Azerbaijani
@@ -1,3 +1,10 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 ar	ar-ae ar-bh ar-dz ar-eg ar-iq ar-jo ar-kw ar-lb ar-ly ar-ma ar-om ar-qa ar-sa ar-sy ar-tn ar-ye
 az	az-az
 bg	bg-bg
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /*
  Stylesheet for Squid Error pages
  Adapted from design by Free CSS Templates
@@ -1,3 +1,10 @@
+##
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 TRANSLATE_LANGUAGES= \
     af.lang \
     ar.lang \
@@ -1,3 +1,10 @@
+##
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 ERROR_TEMPLATES= \
     templates/ERR_ACCESS_DENIED \
     templates/ERR_ACL_TIME_QUOTA_EXCEEDED \
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!--
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>Web Browser Configuration</title>
 <style type="text/css"><!--
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>Web Browser Configuration</title>
 <style type="text/css"><!--
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: Cache Access Denied</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: Cache Manager Access Denied</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" CONTENT="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>Directory: %U</title>
 <style type="text/css"><!--
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>FTP PUT Successful.</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: FTP upload failed</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>FTP PUT Successful.</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URN could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,5 +1,6 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
 <html><head>
+<meta type="copyright" content="Copyright (C) 1996-2014 The Squid Software Foundation and contributors">
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <title>ERROR: The requested URL could not be retrieved</title>
 <style type="text/css"><!-- 
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_ldap_auth 8 "14 January 2005"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_ldap_auth
-.if !'po4a'hide' \-
-LDAP authentication helper for Squid
+basic_ldap_auth \- LDAP authentication helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_ldap_auth
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_ncsa_auth 8 "May 16, 2006"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_ncsa_auth
-.if !'po4a'hide' \-
-NCSA httpd-style password file authentication helper for Squid
+basic_ncsa_auth \- NCSA httpd-style password file authentication helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_ncsa_auth
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_pam_auth 8 "5 Sep 2003"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_pam_auth
-.if !'po4a'hide' \-
-Squid PAM Basic authentication helper
+basic_pam_auth \- PAM Basic authentication helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B "basic_pam_auth [\-n \""
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_radius_auth 8 "7 August 2004"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_radius_auth
-.if !'po4a'hide' \-
-Squid RADIUS authentication helper
+basic_radius_auth \- Squid RADIUS authentication helper
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_radius_auth
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_sasl_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B basic_sasl_auth
-.if !'po4a'hide' \-
-Basic Authentication using SASL (specifically the cyrus-sasl authentication method)
+basic_sasl_auth \- Basic Authentication using SASL (specifically the cyrus-sasl authentication method)
 .PP
 Version 1.0
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_sspi_auth.exe 8
 .
 .SH NAME
-.if !'po4a'hide' .B basic_sspi_auth.exe
-.if !'po4a'hide' \-
-Basic authentication protocol 
+basic_sspi_auth.exe \- Basic authentication protocol 
 .PP
 Version 2.0
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH basic_getpwnam_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B basic_getpwnam_auth
-.if !'po4a'hide' \-
-Local Users auth helper for Squid
+basic_getpwnam_auth \- Local Users auth helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_getpwnam_auth
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH digest_file_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B digest_file_auth
-.if !'po4a'hide' \-
-File based digest authentication helper for Squid.
+digest_file_auth \- File based digest authentication helper for Squid.
 .PP
 Version 1.1
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_ad_group_acl.exe 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_ad_group_acl.exe 
-.if !'po4a'hide' \-
-Squid external ACL helper to check Windows users group membership.
+ext_ad_group_acl.exe \- Squid external ACL helper to check Windows users group membership.
 .PP
 Version 2.0
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_ldap_group_acl 8 "30 January 2005"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_ldap_group_acl
-.if !'po4a'hide' \-
-Squid LDAP external acl group helper
+ext_ldap_group_acl \- Squid LDAP external acl group helper
 .PP
 Version 2.17
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_lm_group_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_lm_group_acl
-.if !'po4a'hide' \-
-Squid external ACL helper to check Windows users group membership.
+ext_lm_group_acl \- Squid external ACL helper to check Windows users group membership.
 .PP
 Version 1.22
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_edirectory_userip_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_edirectory_userip_acl
-.if !'po4a'hide' \-
-Squid eDirectory IP Lookup Helper
+ext_edirectory_userip_acl \- Squid eDirectory IP Lookup Helper
 .PP
 Version 2.0
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_file_userip_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_file_userip_acl
-.if !'po4a'hide' \-
-Restrict users to certain IP addresses, using a text file backend.
+ext_file_userip_acl \- Restrict users to certain IP addresses, using a text file backend.
 .PP
 Version 1.0
 .
@@ -1,4 +1,4 @@
-#!/bin/ksh
+#!/bin/sh
 #
 ## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
 ##
@@ -70,9 +70,9 @@ QUIT
 # Create database for Sun ldap and pem file for Openldap 
 #
 rm ${server}_[0-9]*.pem 2>/dev/null
-let i=0
- ls ${server}_[0-9]*.cert | while read file; do
- let i=i+1
+i=0
+ls ${server}_[0-9]*.cert | while read file; do
+ i=$(($i+1))
  cat  $file  >> ${server}_$i.pem
  CA=`openssl x509 -noout -text -in  ${server}_$i.pem | grep -i "CA:.*true"`
  if [ -n "$CA" ]; then
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_kerberos_ldap_group_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_kerberos_ldap_group_acl
-.if !'po4a'hide' \-
-Squid LDAP external acl group helper for Kerberos or NTLM credentials.
+ext_kerberos_ldap_group_acl \- Squid LDAP external acl group helper for Kerberos or NTLM credentials.
 .PP
 Version 1.3.0sq
 .
@@ -45,6 +45,10 @@
 #include "support.h"
 #include <cctype>
 
+#if HAVE_KRB5
+struct kstruct kparam;
+#endif
+
 void
 init_args(struct main_args *margs)
 {
@@ -61,6 +65,7 @@ init_args(struct main_args *margs)
     margs->rc_allow = 0;
     margs->AD = 0;
     margs->mdepth = 5;
+    margs->nokerberos = 0;
     margs->ddomain = NULL;
     margs->groups = NULL;
     margs->ndoms = NULL;
@@ -173,13 +178,18 @@ main(int argc, char *const argv[])
     char *nuser, *nuser8 = NULL, *netbios;
     int opt;
     struct main_args margs;
+#if HAVE_KRB5
+    krb5_error_code code = 0;
+
+    kparam.context = NULL;
+#endif
 
     setbuf(stdout, NULL);
     setbuf(stdin, NULL);
 
     init_args(&margs);
 
-    while (-1 != (opt = getopt(argc, argv, "diasg:D:N:S:u:U:t:T:p:l:b:m:h"))) {
+    while (-1 != (opt = getopt(argc, argv, "diasng:D:N:S:u:U:t:T:p:l:b:m:h"))) {
         switch (opt) {
         case 'd':
             debug_enabled = 1;
@@ -193,6 +203,9 @@ main(int argc, char *const argv[])
         case 's':
             margs.ssl = (char *) "yes";
             break;
+        case 'n':
+            margs.nokerberos = 1;
+            break;
         case 'g':
             margs.glist = xstrdup(optarg);
             break;
@@ -236,6 +249,7 @@ main(int argc, char *const argv[])
             fprintf(stderr, "squid_kerb_ldap [-d] [-i] -g group list [-D domain] [-N netbios domain map] [-s] [-u ldap user] [-p ldap user password] [-l ldap url] [-b ldap bind path] [-a] [-m max depth] [-h]\n");
             fprintf(stderr, "-d full debug\n");
             fprintf(stderr, "-i informational messages\n");
+            fprintf(stderr, "-n do not use Kerberos to authenticate to AD. Requires -u , -p and -l option\n");
             fprintf(stderr, "-g group list\n");
             fprintf(stderr, "-t group list (only group name hex UTF-8 format)\n");
             fprintf(stderr, "-T group list (all in hex UTF-8 format - except seperator @)\n");
@@ -280,7 +294,7 @@ main(int argc, char *const argv[])
     if (create_gd(&margs)) {
         if ( margs.glist != NULL ) {
             debug((char *) "%s| %s: FATAL: Error in group list: %s\n", LogTime(), PROGRAM, margs.glist ? margs.glist : "NULL");
-            SEND_ERR("");
+            SEND_BH("");
             clean_args(&margs);
             exit(1);
         } else {
@@ -290,44 +304,70 @@ main(int argc, char *const argv[])
     }
     if (create_nd(&margs)) {
         debug((char *) "%s| %s: FATAL: Error in netbios list: %s\n", LogTime(), PROGRAM, margs.nlist ? margs.nlist : "NULL");
-        SEND_ERR("");
+        SEND_BH("");
         clean_args(&margs);
         exit(1);
     }
     if (create_ls(&margs)) {
         debug((char *) "%s| %s: Error in ldap server list: %s\n", LogTime(), PROGRAM, margs.llist ? margs.llist : "NULL");
-        SEND_ERR("");
+        SEND_BH("");
         clean_args(&margs);
         exit(1);
     }
+
+#if HAVE_KRB5
+    /*
+     * Initialise Kerberos
+     */
+
+    code = krb5_init_context(&kparam.context);
+    for (int i=0; i<MAX_DOMAINS; i++) {
+        kparam.mem_ccache[i]=NULL;
+        kparam.cc[i]=NULL;
+        kparam.ncache=0;
+    }
+    if (code) {
+        error((char *) "%s| %s: ERROR: Error while initialising Kerberos library : %s\n", LogTime(), PROGRAM, error_message(code));
+        SEND_BH("");
+        clean_args(&margs);
+        exit(1);
+    }
+#endif
+
     while (1) {
         char *c;
         if (fgets(buf, sizeof(buf) - 1, stdin) == NULL) {
             if (ferror(stdin)) {
                 debug((char *) "%s| %s: FATAL: fgets() failed! dying..... errno=%d (%s)\n", LogTime(), PROGRAM, ferror(stdin),
                       strerror(ferror(stdin)));
 
-                SEND_ERR("");
+                SEND_BH(strerror(ferror(stdin)));
                 clean_args(&margs);
+#if HAVE_KRB5
+                krb5_cleanup();
+#endif
                 exit(1);	/* BIIG buffer */
             }
-            SEND_ERR("");
+            SEND_BH("fgets NULL");
             clean_args(&margs);
+#if HAVE_KRB5
+            krb5_cleanup();
+#endif
             exit(0);
         }
         c = (char *) memchr(buf, '\n', sizeof(buf) - 1);
         if (c) {
             *c = '\0';
         } else {
-            SEND_ERR("Invalid input. CR missing");
+            SEND_BH("Invalid input. CR missing");
             debug((char *) "%s| %s: ERR\n", LogTime(), PROGRAM);
             continue;
         }
 
         user = strtok(buf, " \n");
         if (!user) {
             debug((char *) "%s| %s: INFO: No Username given\n", LogTime(), PROGRAM);
-            SEND_ERR("Invalid request. No Username");
+            SEND_BH("Invalid request. No Username");
             continue;
         }
         rfc1738_unescape(user);
@@ -381,6 +421,10 @@ main(int argc, char *const argv[])
         safe_free(dp);
         if (!strcmp(user, "QQ") && domain && !strcmp(domain, "QQ")) {
             clean_args(&margs);
+#if HAVE_KRB5
+            krb5_cleanup();
+#endif
+
             exit(-1);
         }
         if (gopt) {
@@ -393,12 +437,12 @@ main(int argc, char *const argv[])
                 }
                 margs.glist = xstrdup(group);
                 if (create_gd(&margs)) {
-                    SEND_ERR("Error in group list");
+                    SEND_BH("Error in group list");
                     debug((char *) "%s| %s: FATAL: Error in group list: %s\n", LogTime(), PROGRAM, margs.glist ? margs.glist : "NULL");
                     continue;
                 }
             } else {
-                SEND_ERR("No group list received on stdin");
+                SEND_BH("No group list received on stdin");
                 debug((char *) "%s| %s: FATAL: No group list received on stdin\n", LogTime(), PROGRAM);
                 continue;
             }
@@ -30,7 +30,7 @@
  * -----------------------------------------------------------------------------
  */
 
-#define KERBEROS_LDAP_GROUP_VERSION "1.3.1sq"
+#define KERBEROS_LDAP_GROUP_VERSION "1.4.0sq"
 
 #include <cstring>
 
@@ -60,16 +60,16 @@ extern "C" {
 #endif /* HAVE_COM_ERR_H */
 
 #define LDAP_DEPRECATED 1
-#ifdef HAVE_LDAP_REBIND_FUNCTION
+#if HAVE_LDAP_REBIND_FUNCTION
 #define LDAP_REFERRALS
 #endif
-#ifdef HAVE_LBER_H
+#if HAVE_LBER_H
 #include <lber.h>
 #endif
-#ifdef HAVE_LDAP_H
+#if HAVE_LDAP_H
 #include <ldap.h>
 #endif
-#ifdef HAVE_MOZLDAP_LDAP_H
+#if HAVE_MOZLDAP_LDAP_H
 #include <mozldap/ldap.h>
 #endif
 
@@ -103,6 +103,7 @@ struct main_args {
     int rc_allow;
     int AD;
     int mdepth;
+    int nokerberos;
     char *ddomain;
     struct gdstruct *groups;
     struct ndstruct *ndoms;
@@ -161,11 +162,6 @@ int create_gd(struct main_args *margs);
 int create_nd(struct main_args *margs);
 int create_ls(struct main_args *margs);
 
-#ifdef HAVE_KRB5
-int krb5_create_cache(char *domain);
-void krb5_cleanup(void);
-#endif
-
 size_t get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nhosts, char *domain);
 size_t get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name);
 size_t free_hostname_list(struct hstruct **hlist, size_t nhosts);
@@ -174,4 +170,17 @@ size_t free_hostname_list(struct hstruct **hlist, size_t nhosts);
 int tool_sasl_bind(LDAP * ld, char *binddn, char *ssl);
 #endif
 
+#if HAVE_KRB5
+#define MAX_DOMAINS 16
+#define MAX_SKEW 300
+struct kstruct {
+    krb5_context context;
+    krb5_ccache cc[MAX_DOMAINS];
+    char* mem_ccache[MAX_DOMAINS];
+    int ncache;
+};
+int krb5_create_cache(char *domain);
+void krb5_cleanup(void);
+#endif
+
 #define PROGRAM "kerberos_ldap_group"
@@ -37,23 +37,22 @@
 
 #include "support.h"
 
-struct kstruct {
-    krb5_context context;
-    krb5_ccache cc;
-};
-
-static struct kstruct kparam;
+#if HAVE_KRB5
+extern struct kstruct kparam;
+#endif
 
 #define KT_PATH_MAX 256
 
 void
 krb5_cleanup()
 {
-    if (kparam.context) {
-        if (kparam.cc)
-            krb5_cc_destroy(kparam.context, kparam.cc);
-        krb5_free_context(kparam.context);
-    }
+    if (kparam.context)
+        for (int i=0; i<MAX_DOMAINS; i++) {
+            if (kparam.cc[i])
+                krb5_cc_destroy(kparam.context, kparam.cc[i]);
+            safe_free(kparam.mem_ccache[i]);
+        }
+    krb5_free_context(kparam.context);
 }
 /*
  * create Kerberos memory cache
@@ -62,9 +61,10 @@ int
 krb5_create_cache(char *domain)
 {
 
-    krb5_keytab keytab = 0;
+    krb5_keytab keytab = NULL;
     krb5_keytab_entry entry;
     krb5_kt_cursor cursor;
+    krb5_cc_cursor ccursor;
     krb5_creds *creds = NULL;
     krb5_principal *principal_list = NULL;
     krb5_principal principal = NULL;
@@ -74,272 +74,397 @@ krb5_create_cache(char *domain)
     size_t j,nprinc = 0;
     int retval = 0;
     krb5_error_code code = 0;
-
-    kparam.context = NULL;
+    int ccindex=-1;
 
     if (!domain || !strcmp(domain, ""))
         return (1);
 
-    /*
-     * Initialise Kerberos
-     */
-
-    code = krb5_init_context(&kparam.context);
-    if (code) {
-        error((char *) "%s| %s: ERROR: Error while initialising Kerberos library : %s\n", LogTime(), PROGRAM, error_message(code));
-        retval = 1;
-        goto cleanup;
-    }
     /*
      * prepare memory credential cache
      */
 #if  !HAVE_KRB5_MEMORY_CACHE || HAVE_SUN_LDAP_SDK
-    mem_cache = (char *) xmalloc(strlen("FILE:/tmp/squid_ldap_") + 16);
-    snprintf(mem_cache, strlen("FILE:/tmp/squid_ldap_") + 16, "FILE:/tmp/squid_ldap_%d", (int) getpid());
+    mem_cache = (char *) xmalloc(strlen("FILE:/tmp/squid_ldap_") + strlen(domain) + 1 + 16);
+    snprintf(mem_cache, strlen("FILE:/tmp/squid_ldap_") + strlen(domain) + 1 + 16, "FILE:/tmp/squid_ldap_%s_%d", domain, (int) getpid());
 #else
-    mem_cache = (char *) xmalloc(strlen("MEMORY:squid_ldap_") + 16);
-    snprintf(mem_cache, strlen("MEMORY:squid_ldap_") + 16, "MEMORY:squid_ldap_%d", (int) getpid());
+    mem_cache = (char *) xmalloc(strlen("MEMORY:squid_ldap_") + strlen(domain) + 1 + 16);
+    snprintf(mem_cache, strlen("MEMORY:squid_ldap_") + strlen(domain) + 1 + 16, "MEMORY:squid_ldap_%s_%d", domain, (int) getpid());
 #endif
 
     setenv("KRB5CCNAME", mem_cache, 1);
     debug((char *) "%s| %s: DEBUG: Set credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
-    code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc);
-    if (code) {
-        error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
-        retval = 1;
-        goto cleanup;
+    for (int i=0; i<MAX_DOMAINS; i++) {
+        if (kparam.mem_ccache[i] && !strcmp(mem_cache,kparam.mem_ccache[i])) {
+            ccindex=i;
+            break;
+        }
+    }
+    if ( ccindex == -1 ) {
+        kparam.mem_ccache[kparam.ncache]=xstrdup(mem_cache);
+        ccindex=kparam.ncache;
+        kparam.ncache++;
+        if ( kparam.ncache == MAX_DOMAINS ) {
+            error((char *) "%s| %s: ERROR: Too many domains to support: # domains %d\n", LogTime(), PROGRAM, kparam.ncache);
+            retval = 1;
+            goto cleanup;
+        }
+        code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
+        if (code) {
+            error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+            retval = 1;
+            goto cleanup;
+        }
     }
     /*
-     * getting default keytab name
+     * getting default principal from cache
      */
 
-    debug((char *) "%s| %s: DEBUG: Get default keytab file name\n", LogTime(), PROGRAM);
-    krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
-    p = strchr(buf, ':');	/* Find the end if "FILE:" */
-    if (p)
-        ++p;			/* step past : */
-    keytab_name = xstrdup(p ? p : buf);
-    debug((char *) "%s| %s: DEBUG: Got default keytab file name %s\n", LogTime(), PROGRAM, keytab_name);
-
-    code = krb5_kt_resolve(kparam.context, keytab_name, &keytab);
+    code = krb5_cc_get_principal(kparam.context, kparam.cc[ccindex], &principal);
     if (code) {
-        error((char *) "%s| %s: ERROR: Error while resolving keytab %s : %s\n", LogTime(), PROGRAM, keytab_name, error_message(code));
-        retval = 1;
-        goto cleanup;
+        if (principal)
+            krb5_free_principal(kparam.context, principal);
+        principal = NULL;
+        debug((char *) "%s| %s: DEBUG: No default principal found in ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+
+    } else {
+        /*
+         * Look for krbtgt and check if it is expired (or soon to be expired)
+         */
+        code = krb5_cc_start_seq_get(kparam.context, kparam.cc[ccindex], &ccursor);
+        if (code) {
+            error((char *) "%s| %s: ERROR: Error while starting ccache scan : %s\n", LogTime(), PROGRAM, error_message(code));
+            code = krb5_cc_close (kparam.context, kparam.cc[ccindex]);
+            if (code) {
+                error((char *) "%s| %s: ERROR: while closing ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+            }
+            if (kparam.cc[ccindex]) {
+                code = krb5_cc_destroy(kparam.context, kparam.cc[ccindex]);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: while destroying ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                }
+            }
+        } else {
+            krb5_error_code code2 = 0;
+            creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
+            while ((krb5_cc_next_cred(kparam.context, kparam.cc[ccindex], &ccursor, creds)) == 0) {
+                code2 = krb5_unparse_name(kparam.context, creds->server, &principal_name);
+                if (code2) {
+                    error((char *) "%s| %s: ERROR: Error while unparsing principal : %s\n", LogTime(), PROGRAM, error_message(code2));
+                    code = krb5_cc_destroy(kparam.context, kparam.cc[ccindex]);
+                    if (code) {
+                        error((char *) "%s| %s: ERROR: while destroying ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                    }
+                    if (creds)
+                        krb5_free_creds(kparam.context, creds);
+                    creds = NULL;
+                    safe_free(principal_name);
+                    debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
+                    code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
+                    if (code) {
+                        error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                        retval = 1;
+                        goto cleanup;
+                    }
+                    code =1;
+                    break;
+                }
+                if (!strncmp(KRB5_TGS_NAME,principal_name,KRB5_TGS_NAME_SIZE)) {
+                    time_t now;
+                    static krb5_deltat skew=MAX_SKEW;
+
+                    debug((char *) "%s| %s: DEBUG: Found %s in cache : %s\n", LogTime(), PROGRAM,KRB5_TGS_NAME,principal_name);
+                    /*
+                     * Check time
+                     */
+                    time(&now);
+                    debug((char *) "%s| %s: DEBUG: credential time diff %d\n", LogTime(), PROGRAM, (int)(creds->times.endtime - now));
+                    if (creds->times.endtime - now < 2*skew) {
+                        debug((char *) "%s| %s: DEBUG: credential will soon expire %d\n", LogTime(), PROGRAM, (int)(creds->times.endtime - now));
+                        if (principal)
+                            krb5_free_principal(kparam.context, principal);
+                        principal = NULL;
+                        code = krb5_cc_destroy(kparam.context, kparam.cc[ccindex]);
+                        if (code) {
+                            error((char *) "%s| %s: ERROR: while destroying ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                        }
+                        if (creds)
+                            krb5_free_creds(kparam.context, creds);
+                        creds = NULL;
+                        safe_free(principal_name);
+                        debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
+                        code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
+                        if (code) {
+                            error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                            retval = 1;
+                            goto cleanup;
+                        }
+                        code = 1;
+                    } else {
+                        safe_free(principal_name);
+                    }
+                    break;
+                }
+                if (creds)
+                    krb5_free_creds(kparam.context, creds);
+                creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
+                safe_free(principal_name);
+            }
+            if (creds)
+                krb5_free_creds(kparam.context, creds);
+            creds = NULL;
+            code2 = krb5_cc_end_seq_get(kparam.context, kparam.cc[ccindex], &ccursor);
+            if (code2) {
+                error((char *) "%s| %s: ERROR: Error while ending ccache scan : %s\n", LogTime(), PROGRAM, error_message(code));
+                retval = 1;
+                goto cleanup;
+            }
+        }
     }
-    code = krb5_kt_start_seq_get(kparam.context, keytab, &cursor);
     if (code) {
-        error((char *) "%s| %s: ERROR: Error while starting keytab scan : %s\n", LogTime(), PROGRAM, error_message(code));
-        retval = 1;
-        goto cleanup;
-    }
-    debug((char *) "%s| %s: DEBUG: Get principal name from keytab %s\n", LogTime(), PROGRAM, keytab_name);
+        /*
+         * getting default keytab name
+         */
 
-    nprinc = 0;
-    while ((code = krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor)) == 0) {
-        int found = 0;
+        debug((char *) "%s| %s: DEBUG: Get default keytab file name\n", LogTime(), PROGRAM);
+        krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
+        p = strchr(buf, ':');	/* Find the end if "FILE:" */
+        if (p)
+            ++p;			/* step past : */
+        keytab_name = xstrdup(p ? p : buf);
+        debug((char *) "%s| %s: DEBUG: Got default keytab file name %s\n", LogTime(), PROGRAM, keytab_name);
 
-        principal_list = (krb5_principal *) xrealloc(principal_list, sizeof(krb5_principal) * (nprinc + 1));
-        krb5_copy_principal(kparam.context, entry.principal, &principal_list[nprinc++]);
+        code = krb5_kt_resolve(kparam.context, keytab_name, &keytab);
+        if (code) {
+            error((char *) "%s| %s: ERROR: Error while resolving keytab %s : %s\n", LogTime(), PROGRAM, keytab_name, error_message(code));
+            retval = 1;
+            goto cleanup;
+        }
+        code = krb5_kt_start_seq_get(kparam.context, keytab, &cursor);
+        if (code) {
+            error((char *) "%s| %s: ERROR: Error while starting keytab scan : %s\n", LogTime(), PROGRAM, error_message(code));
+            retval = 1;
+            goto cleanup;
+        }
+        debug((char *) "%s| %s: DEBUG: Get principal name from keytab %s\n", LogTime(), PROGRAM, keytab_name);
+
+        nprinc = 0;
+        while ((code = krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor)) == 0) {
+            int found = 0;
+
+            principal_list = (krb5_principal *) xrealloc(principal_list, sizeof(krb5_principal) * (nprinc + 1));
+            krb5_copy_principal(kparam.context, entry.principal, &principal_list[nprinc++]);
 #if USE_HEIMDAL_KRB5
-        debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, entry.principal->realm);
+            debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, entry.principal->realm);
 #else
-        debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, krb5_princ_realm(kparam.context, entry.principal)->data);
+            debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, krb5_princ_realm(kparam.context, entry.principal)->data);
 #endif
 #if USE_HEIMDAL_KRB5
-        if (!strcasecmp(domain, entry.principal->realm))
+            if (!strcasecmp(domain, entry.principal->realm))
 #else
-        if (!strcasecmp(domain, krb5_princ_realm(kparam.context, entry.principal)->data))
+            if (!strcasecmp(domain, krb5_princ_realm(kparam.context, entry.principal)->data))
 #endif
-        {
-            code = krb5_unparse_name(kparam.context, entry.principal, &principal_name);
-            if (code) {
-                error((char *) "%s| %s: ERROR: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
-            } else {
-                debug((char *) "%s| %s: DEBUG: Found principal name: %s\n", LogTime(), PROGRAM, principal_name);
-                found = 1;
+            {
+                code = krb5_unparse_name(kparam.context, entry.principal, &principal_name);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
+                } else {
+                    debug((char *) "%s| %s: DEBUG: Found principal name: %s\n", LogTime(), PROGRAM, principal_name);
+                    found = 1;
+                }
             }
-        }
 #if USE_HEIMDAL_KRB5 || ( HAVE_KRB5_KT_FREE_ENTRY && HAVE_DECL_KRB5_KT_FREE_ENTRY )
-        code = krb5_kt_free_entry(kparam.context, &entry);
+            code = krb5_kt_free_entry(kparam.context, &entry);
 #else
-        code = krb5_free_keytab_entry_contents(kparam.context, &entry);
+            code = krb5_free_keytab_entry_contents(kparam.context, &entry);
 #endif
-        if (code) {
-            error((char *) "%s| %s: ERROR: Error while freeing keytab entry : %s\n", LogTime(), PROGRAM, error_message(code));
-            retval = 1;
-            break;
-        }
-        if (found) {
-            debug((char *) "%s| %s: DEBUG: Got principal name %s\n", LogTime(), PROGRAM, principal_name);
-            /*
-             * build principal
-             */
-            code = krb5_parse_name(kparam.context, principal_name, &principal);
             if (code) {
-                error((char *) "%s| %s: ERROR: Error while parsing name %s : %s\n", LogTime(), PROGRAM, principal_name, error_message(code));
-                safe_free(principal_name);
-                if (principal)
-                    krb5_free_principal(kparam.context, principal);
-                found = 0;
-                continue;
+                error((char *) "%s| %s: ERROR: Error while freeing keytab entry : %s\n", LogTime(), PROGRAM, error_message(code));
+                retval = 1;
+                break;
             }
-            creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
+            if (found) {
+                debug((char *) "%s| %s: DEBUG: Got principal name %s\n", LogTime(), PROGRAM, principal_name);
+                /*
+                 * build principal
+                 */
+                code = krb5_parse_name(kparam.context, principal_name, &principal);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while parsing name %s : %s\n", LogTime(), PROGRAM, principal_name, error_message(code));
+                    safe_free(principal_name);
+                    if (principal)
+                        krb5_free_principal(kparam.context, principal);
+                    found = 0;
+                    continue;
+                }
+                creds = (krb5_creds *) xcalloc(1,sizeof(*creds));
 
-            /*
-             * get credentials
-             */
+                /*
+                 * get credentials
+                 */
 #if HAVE_GET_INIT_CREDS_KEYTAB
-            code = krb5_get_init_creds_keytab(kparam.context, creds, principal, keytab, 0, NULL, NULL);
+                code = krb5_get_init_creds_keytab(kparam.context, creds, principal, keytab, 0, NULL, NULL);
 #else
-            service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
-            snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
-            creds->client = principal;
-            code = krb5_parse_name(kparam.context, service, &creds->server);
-            xfree(service);
-            code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
+                service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
+                snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
+                creds->client = principal;
+                code = krb5_parse_name(kparam.context, service, &creds->server);
+                xfree(service);
+                code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
 
-            if (code) {
-                error((char *) "%s| %s: ERROR: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
-                safe_free(principal_name);
-                if (principal)
-                    krb5_free_principal(kparam.context, principal);
-                if (creds)
-                    krb5_free_creds(kparam.context, creds);
-                creds = NULL;
-                found = 0;
-                continue;
-            }
-            code = krb5_cc_initialize(kparam.context, kparam.cc, principal);
-            if (code) {
-                error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
-                safe_free(principal_name);
-                if (principal)
-                    krb5_free_principal(kparam.context, principal);
-                if (creds)
-                    krb5_free_creds(kparam.context, creds);
-                creds = NULL;
-                found = 0;
-                continue;
-            }
-            code = krb5_cc_store_cred(kparam.context, kparam.cc, creds);
-            if (code) {
-                error((char *) "%s| %s: ERROR: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
-                if (principal)
-                    krb5_free_principal(kparam.context, principal);
-                safe_free(principal_name);
-                if (creds)
-                    krb5_free_creds(kparam.context, creds);
-                creds = NULL;
-                found = 0;
-                continue;
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+                    safe_free(principal_name);
+                    if (principal)
+                        krb5_free_principal(kparam.context, principal);
+                    if (creds)
+                        krb5_free_creds(kparam.context, creds);
+                    creds = NULL;
+                    found = 0;
+                    continue;
+                }
+                code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
+                    safe_free(principal_name);
+                    if (principal)
+                        krb5_free_principal(kparam.context, principal);
+                    if (creds)
+                        krb5_free_creds(kparam.context, creds);
+                    creds = NULL;
+                    found = 0;
+                    continue;
+                }
+                code = krb5_cc_store_cred(kparam.context, kparam.cc[ccindex], creds);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                    if (principal)
+                        krb5_free_principal(kparam.context, principal);
+                    safe_free(principal_name);
+                    if (creds)
+                        krb5_free_creds(kparam.context, creds);
+                    creds = NULL;
+                    found = 0;
+                    continue;
+                }
+                debug((char *) "%s| %s: DEBUG: Stored credentials\n", LogTime(), PROGRAM);
+                break;
             }
-            debug((char *) "%s| %s: DEBUG: Stored credentials\n", LogTime(), PROGRAM);
-            break;
         }
-    }
 
-    if (code && code != KRB5_KT_END) {
-        error((char *) "%s| %s: ERROR: Error while scanning keytab : %s\n", LogTime(), PROGRAM, error_message(code));
-        retval = 1;
-        goto cleanup;
-    }
-    code = krb5_kt_end_seq_get(kparam.context, keytab, &cursor);
-    if (code) {
-        error((char *) "%s| %s: ERROR: Error while ending keytab scan : %s\n", LogTime(), PROGRAM, error_message(code));
-        retval = 1;
-        goto cleanup;
-    }
+        if (code && code != KRB5_KT_END) {
+            error((char *) "%s| %s: ERROR: Error while scanning keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+            retval = 1;
+            goto cleanup;
+        }
+        code = krb5_kt_end_seq_get(kparam.context, keytab, &cursor);
+        if (code) {
+            error((char *) "%s| %s: ERROR: Error while ending keytab scan : %s\n", LogTime(), PROGRAM, error_message(code));
+            retval = 1;
+            goto cleanup;
+        }
 
-    /*
-     * if no principal name found in keytab for domain use the prinipal name which can get a TGT
-     */
-    if (!principal_name) {
-        size_t i;
-        debug((char *) "%s| %s: DEBUG: Did not find a principal in keytab for domain %s.\n", LogTime(), PROGRAM, domain);
-        debug((char *) "%s| %s: DEBUG: Try to get principal of trusted domain.\n", LogTime(), PROGRAM);
+        /*
+         * if no principal name found in keytab for domain use the prinipal name which can get a TGT
+         */
+        if (!principal_name) {
+            size_t i;
+            debug((char *) "%s| %s: DEBUG: Did not find a principal in keytab for domain %s.\n", LogTime(), PROGRAM, domain);
+            debug((char *) "%s| %s: DEBUG: Try to get principal of trusted domain.\n", LogTime(), PROGRAM);
 
-        for (i = 0; i < nprinc; ++i) {
-            krb5_creds *tgt_creds = NULL;
-            creds = (krb5_creds *) xmalloc(sizeof(*creds));
-            memset(creds, 0, sizeof(*creds));
-            /*
-             * get credentials
-             */
-            code = krb5_unparse_name(kparam.context, principal_list[i], &principal_name);
-            if (code) {
-                debug((char *) "%s| %s: DEBUG: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
-                goto loop_end;
-            }
-            debug((char *) "%s| %s: DEBUG: Keytab entry has principal: %s\n", LogTime(), PROGRAM, principal_name);
+            for (i = 0; i < nprinc; ++i) {
+                krb5_creds *tgt_creds = NULL;
+                creds = (krb5_creds *) xmalloc(sizeof(*creds));
+                memset(creds, 0, sizeof(*creds));
+                /*
+                 * get credentials
+                 */
+                code = krb5_unparse_name(kparam.context, principal_list[i], &principal_name);
+                if (code) {
+                    debug((char *) "%s| %s: DEBUG: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
+                    goto loop_end;
+                }
+                debug((char *) "%s| %s: DEBUG: Keytab entry has principal: %s\n", LogTime(), PROGRAM, principal_name);
 
 #if HAVE_GET_INIT_CREDS_KEYTAB
-            code = krb5_get_init_creds_keytab(kparam.context, creds, principal_list[i], keytab, 0, NULL, NULL);
+                code = krb5_get_init_creds_keytab(kparam.context, creds, principal_list[i], keytab, 0, NULL, NULL);
 #else
-            service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
-            snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
-            creds->client = principal_list[i];
-            code = krb5_parse_name(kparam.context, service, &creds->server);
-            xfree(service);
-            code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
+                service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
+                snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
+                creds->client = principal_list[i];
+                code = krb5_parse_name(kparam.context, service, &creds->server);
+                xfree(service);
+                code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
-            if (code) {
-                debug((char *) "%s| %s: DEBUG: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
-                goto loop_end;
-            }
-            code = krb5_cc_initialize(kparam.context, kparam.cc, principal_list[i]);
-            if (code) {
-                error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
-                goto loop_end;
-            }
-            code = krb5_cc_store_cred(kparam.context, kparam.cc, creds);
-            if (code) {
-                debug((char *) "%s| %s: DEBUG: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
-                goto loop_end;
-            }
-            if (creds->server)
-                krb5_free_principal(kparam.context, creds->server);
+                if (code) {
+                    debug((char *) "%s| %s: DEBUG: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+                    goto loop_end;
+                }
+                code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal_list[i]);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
+                    goto loop_end;
+                }
+                code = krb5_cc_store_cred(kparam.context, kparam.cc[ccindex], creds);
+                if (code) {
+                    debug((char *) "%s| %s: DEBUG: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                    goto loop_end;
+                }
+                if (creds->server)
+                    krb5_free_principal(kparam.context, creds->server);
 #if USE_HEIMDAL_KRB5
-            service = (char *) xmalloc(strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3);
-            snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3, "krbtgt/%s@%s", domain, principal_list[i]->realm);
+                service = (char *) xmalloc(strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3);
+                snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3, "krbtgt/%s@%s", domain, principal_list[i]->realm);
 #else
-            service = (char *) xmalloc(strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3);
-            snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3, "krbtgt/%s@%s", domain, krb5_princ_realm(kparam.context, principal_list[i])->data);
+                service = (char *) xmalloc(strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3);
+                snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3, "krbtgt/%s@%s", domain, krb5_princ_realm(kparam.context, principal_list[i])->data);
 #endif
-            code = krb5_parse_name(kparam.context, service, &creds->server);
-            xfree(service);
-            if (code) {
-                error((char *) "%s| %s: ERROR: Error while initialising TGT credentials : %s\n", LogTime(), PROGRAM, error_message(code));
-                goto loop_end;
-            }
-            code = krb5_get_credentials(kparam.context, 0, kparam.cc, creds, &tgt_creds);
-            if (code) {
-                debug((char *) "%s| %s: DEBUG: Error while getting tgt : %s\n", LogTime(), PROGRAM, error_message(code));
-                goto loop_end;
-            } else {
-                debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
+                code = krb5_parse_name(kparam.context, service, &creds->server);
+                xfree(service);
+                if (code) {
+                    error((char *) "%s| %s: ERROR: Error while initialising TGT credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                    goto loop_end;
+                }
+                code = krb5_get_credentials(kparam.context, 0, kparam.cc[ccindex], creds, &tgt_creds);
+                if (code) {
+                    debug((char *) "%s| %s: DEBUG: Error while getting tgt : %s\n", LogTime(), PROGRAM, error_message(code));
+                    goto loop_end;
+                } else {
+                    debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
+                    if (tgt_creds)
+                        krb5_free_creds(kparam.context, tgt_creds);
+                    tgt_creds = NULL;
+                    break;
+                }
+
+loop_end:
+                safe_free(principal_name);
                 if (tgt_creds)
                     krb5_free_creds(kparam.context, tgt_creds);
                 tgt_creds = NULL;
-                break;
+                if (creds)
+                    krb5_free_creds(kparam.context, creds);
+                creds = NULL;
+
             }
 
-loop_end:
-            safe_free(principal_name);
-            if (tgt_creds)
-                krb5_free_creds(kparam.context, tgt_creds);
-            tgt_creds = NULL;
             if (creds)
                 krb5_free_creds(kparam.context, creds);
             creds = NULL;
-
         }
-
-        if (creds)
-            krb5_free_creds(kparam.context, creds);
-        creds = NULL;
+    } else {
+        debug((char *) "%s| %s: DEBUG: Got principal from ccache\n", LogTime(), PROGRAM);
+        /*
+         * get credentials
+         */
+        code = krb5_unparse_name(kparam.context, principal, &principal_name);
+        if (code) {
+            debug((char *) "%s| %s: DEBUG: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
+            retval = 1;
+            goto cleanup;
+        }
+        debug((char *) "%s| %s: DEBUG: ccache has principal: %s\n", LogTime(), PROGRAM, principal_name);
     }
+
     if (!principal_name) {
         debug((char *) "%s| %s: DEBUG: Got no principal name\n", LogTime(), PROGRAM);
         retval = 1;
@@ -359,7 +484,6 @@ krb5_create_cache(char *domain)
     xfree(principal_list);
     if (creds)
         krb5_free_creds(kparam.context, creds);
-
     return (retval);
 }
 #endif
@@ -47,7 +47,7 @@
 #include "squid.h"
 #include "util.h"
 
-#ifdef HAVE_LDAP
+#if HAVE_LDAP
 
 #include "support.h"
 #include <cerrno>
@@ -888,9 +888,14 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n", LogTime(), PROGRAM);
 
 #if HAVE_KRB5
-        kc = krb5_create_cache(domain);
-        if (kc) {
-            error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
+        if (margs->nokerberos) {
+            kc = 1;
+            debug((char *) "%s| %s: DEBUG: Kerberos is disabled. Use username/password with ldap url instead\n", LogTime(), PROGRAM);
+        } else {
+            kc = krb5_create_cache(domain);
+            if (kc) {
+                error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
+            }
         }
 #else
         kc = 1;
@@ -1234,11 +1239,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                         snprintf(search_exp, se_len, "%s", FILTER_SID_1 );
 
                         for (int j=0; j<len; j++) {
-                            se=strdup(search_exp);
+                            se=xstrdup(search_exp);
                             snprintf(search_exp, se_len, "%s\\%02x", se, attr_value_3[0][j] & 0xFF);
                             xfree(se);
                         }
-                        se=strdup(search_exp);
+                        se=xstrdup(search_exp);
                         snprintf(search_exp, se_len, "%s%s", se, FILTER_SID_2 );
                         xfree(se);
 
@@ -1375,10 +1380,6 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     }
     debug((char *) "%s| %s: DEBUG: Unbind ldap server\n", LogTime(), PROGRAM);
 cleanup:
-#if HAVE_KRB5
-    if (domain)
-        krb5_cleanup();
-#endif
     if (lcreds) {
         xfree(lcreds->dn);
         xfree(lcreds->pw);
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_session_acl 8 "9 October 2011"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_session_acl
-.if !'po4a'hide' \-
-Squid session tracking external acl helper.
+ext_session_acl \- Squid session tracking external acl helper.
 .PP
 Version 1.2
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_time_quota_acl 8 "22 March 2011"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_time_quota_acl
-.if !'po4a'hide' \-
-Squid time quota external acl helper.
+ext_time_quota_acl \- Squid time quota external acl helper.
 .PP
 Version 1.0
 .
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ext_unix_group_acl 8 "12 August 2002"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_unix_group_acl
-.if !'po4a'hide' \-
-Squid UNIX Group ACL helper
+ext_unix_group_acl \- Squid UNIX Group ACL helper
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B "ext_unix_group_acl [\-d] [\-g "
@@ -1,3 +1,10 @@
+-- Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+--
+-- Squid software is distributed under GPLv2+ license and includes
+-- contributions from numerous individuals and organizations.
+-- Please see the COPYING and CONTRIBUTORS files for details.
+--
+
 -- we need a separate column to store the date and time of the request
 ALTER TABLE access_log ADD COLUMN date_day DATE;
 ALTER TABLE access_log ADD COLUMN date_time TIME;
@@ -1,3 +1,10 @@
+-- Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+--
+-- Squid software is distributed under GPLv2+ license and includes
+-- contributions from numerous individuals and organizations.
+-- Please see the COPYING and CONTRIBUTORS files for details.
+--
+
 --
 -- Sample views
 --
@@ -106,7 +106,7 @@ extern "C" {
 #define MAX_AUTHTOKEN_LEN   65535
 #endif
 #ifndef SQUID_KERB_AUTH_VERSION
-#define SQUID_KERB_AUTH_VERSION "3.0.4sq"
+#define SQUID_KERB_AUTH_VERSION "3.1.0sq"
 #endif
 
 char *gethost_name(void);
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH negotiate_kerberos_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B negotiate_kerberos_auth
-.if !'po4a'hide' \-
-Squid kerberos based authentication helper
+negotiate_kerberos_auth \- Squid kerberos based authentication helper
 .PP
 Version 3.0.4sq
 .
@@ -432,12 +432,16 @@ main(int argc, char *const argv[])
                 debug((char *) "%s| %s: DEBUG: Groups %s\n", LogTime(), PROGRAM, ag);
             }
 #endif
-            fprintf(stdout, "AF %s %s\n", token, user);
             rfc_user = rfc1738_escape(user);
+#if HAVE_PAC_SUPPORT
+            fprintf(stdout, "AF %s %s %s\n", token, rfc_user, ag?ag:"group=");
+#else
+            fprintf(stdout, "AF %s %s\n", token, rfc_user);
+#endif
             debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc_user);
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
-                        PROGRAM, rfc1738_escape(user));
+                        PROGRAM, rfc_user);
             goto cleanup;
         } else {
             if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
@@ -468,12 +472,16 @@ main(int argc, char *const argv[])
             if (norealm && (p = strchr(user, '@')) != NULL) {
                 *p = '\0';
             }
-            fprintf(stdout, "AF %s %s\n", "AA==", user);
-            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, "AA==", rfc1738_escape(user));
+            rfc_user = rfc1738_escape(user);
+#if HAVE_PAC_SUPPORT
+            fprintf(stdout, "AF %s %s %s\n", "AA==", rfc_user, ag?ag:"group=");
+#else
+            fprintf(stdout, "AF %s %s\n", "AA==", rfc_user);
+#endif
+	    debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, "AA==", rfc_user);
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
-                        PROGRAM, rfc1738_escape(user));
-
+                        PROGRAM, rfc_user);
         }
 cleanup:
         gss_release_buffer(&minor_status, &input_token);
@@ -62,7 +62,7 @@ check_k5_err(krb5_context context, const char *function, krb5_error_code code)
 #elif HAVE_KRB5_FREE_ERROR_STRING
         krb5_free_error_string(context, (char *)errmsg);
 #else
-	xfree(errmsg);
+        xfree(errmsg);
 #endif
     }
     return code;
@@ -1,10 +1,7 @@
 .if !'po4a'hide' .TH ntlm_sspi_auth.exe 8
 .
 .SH NAME
-.if !'po4a'hide' .B ntlm_sspi_auth.exe
-.if !'po4a'hide' \-
-Native Windows NTLM/NTLMv2 authenticator for Squid with
-automatic support for NTLM NEGOTIATE packets.
+ntlm_sspi_auth.exe \- Native Windows NTLM/NTLMv2 authenticator for Squid
 .PP
 Version 1.22
 .
@@ -5,11 +5,11 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-include $(top_srcdir)/icons/list
+include $(top_srcdir)/icons/icon.list
 
 icondir = $(datadir)/icons/silk
 icon_DATA = $(ICONS)
-EXTRA_DIST = $(ICONS) list SN.png
+EXTRA_DIST = $(ICONS) icon.list SN.png
 DISTCLEANFILES = 
 
 install-data-local: SN.png install-iconDATA
@@ -1,3 +1,10 @@
+##
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 ICONS= \
     silk/application.png \
     silk/arrow_up.png \
@@ -284,43 +284,26 @@ class MemAllocatorProxy
 /* help for classes */
 
 /**
- \ingroup MemPoolsAPI
- \hideinitializer
+ * \ingroup MemPoolsAPI
+ * \hideinitializer
  *
+ * Pool and account the memory used for the CLASS object.
  * This macro is intended for use within the declaration of a class.
  */
 #define MEMPROXY_CLASS(CLASS) \
-    inline void *operator new(size_t); \
-    inline void operator delete(void *); \
-    static inline MemAllocatorProxy &Pool()
-
-/**
- \ingroup MemPoolsAPI
- \hideinitializer
- *
- * This macro is intended for use within the .h or .cci of a class as appropriate.
- */
-#define MEMPROXY_CLASS_INLINE(CLASS) \
-MemAllocatorProxy& CLASS::Pool() \
-{ \
-    static MemAllocatorProxy thePool(#CLASS, sizeof (CLASS)); \
-    return thePool; \
-} \
-\
-void * \
-CLASS::operator new (size_t byteCount) \
-{ \
-    /* derived classes with different sizes must implement their own new */ \
-    assert (byteCount == sizeof (CLASS)); \
-\
-    return Pool().alloc(); \
-}  \
-\
-void \
-CLASS::operator delete (void *address) \
-{ \
-    Pool().freeOne(address); \
-}
+    private: \
+    static inline MemAllocatorProxy &Pool() { \
+        static MemAllocatorProxy thePool(#CLASS, sizeof(CLASS)); \
+        return thePool; \
+    } \
+    public: \
+    void *operator new(size_t byteCount) { \
+        /* derived classes with different sizes must implement their own new */ \
+        assert (byteCount == sizeof(CLASS)); \
+        return Pool().alloc(); \
+    } \
+    void operator delete(void *address) {Pool().freeOne(address);} \
+    private:
 
 /// \ingroup MemPoolsAPI
 class MemImplementingAllocator : public MemAllocator
@@ -1,9 +1,16 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
 #ifndef _PROFILER_XPROF_TYPE_H_
 #define _PROFILER_XPROF_TYPE_H_
 /* AUTO-GENERATED FILE */
 #if USE_XPROF_STATS
 typedef enum {
-XPROF_PROF_UNACCOUNTED,
+  XPROF_PROF_UNACCOUNTED,
 XPROF_aclCheckFast,
 XPROF_ACL_matches,
 XPROF_calloc,
@@ -44,7 +51,6 @@ XPROF_HttpServer_parseOneRequest,
 XPROF_httpStart,
 XPROF_HttpStateData_processReplyBody,
 XPROF_HttpStateData_processReplyHeader,
-XPROF_HttpStateData_readReply,
 XPROF_InvokeHandlers,
 XPROF_malloc,
 XPROF_MemBuf_append,
@@ -87,7 +87,7 @@ inst $tmpdir/${name}.tar.gz	$dst/${name}.tar.gz
 inst $tmpdir/${name}.tar.bz2	$dst/${name}.tar.bz2
 inst $tmpdir/CONTRIBUTORS	$dst/CONTRIBUTORS.txt
 inst $tmpdir/COPYING		$dst/COPYING.txt
-inst $tmpdir/COPYRIGHT		$dst/COPYRIGHT.txt
+inst $tmpdir/README		$dst/README.txt
 inst $tmpdir/CREDITS		$dst/CREDITS.txt
 inst $tmpdir/SPONSORS		$dst/SPONSORS.txt
 inst $tmpdir/ChangeLog		$dst/ChangeLog.txt
@@ -32,8 +32,8 @@ fi
 ROOT=`bzr root`
 
 ASVER=`astyle --version 2>&1 | grep -o -E "[0-9.]+"`
-if test "${ASVER}" != "1.23" ; then
-	echo "Astyle version problem. You have ${ASVER} instead of 1.23";
+if test "${ASVER}" != "2.03" ; then
+	echo "Astyle version problem. You have ${ASVER} instead of 2.03";
 else
 	echo "Found astyle ${ASVER}. Formatting..."
 fi
@@ -46,12 +46,15 @@ PWD=`pwd`
 #
 # Scan for incorrect use of #ifdef/#ifndef
 #
-grep -E "ifn?def .*_SQUID_" ./*.* | grep -v -E "_H$" | while read f; do echo "PROBLEM?: ${PWD} ${f}"; done
+bzr grep --no-recursive "ifn?def .*_SQUID_" |
+    grep -v -E "_H$" |
+    while read f; do echo "PROBLEM?: ${PWD} ${f}"; done
 
 #
 # Scan for file-specific actions
 #
-for FILENAME in `ls -1`; do
+for FILENAME in `bzr ls --versioned`; do
+    skip_copyright_check=""
 
     case ${FILENAME} in
 
@@ -152,17 +155,27 @@ for FILENAME in `ls -1`; do
 	mv ${FILENAME}.styled ${FILENAME}
 	;;
 
+    */ChangeLog|*.list|*.png|*.po|*.pot|*.txt|*test-suite/squidconf/empty)
+        # we do not enforce copyright blurbs in:
+        #
+        #  images,
+        #  translation PO/POT
+        #  auto-generated .list files,
+        #  (imported) plain-text documentation files and ChangeLogs
+        #
+        skip_copyright_check=1
+        ;;
     esac
 
     # check for Foundation copyright blurb
-    if test -f ${PWD}/${FILENAME}; then
+    if test -f ${PWD}/${FILENAME} -a "x$skip_copyright_check" = "x"; then
         BLURB=`grep "The Squid Software Foundation and contributors" ${FILENAME}`;
         if test "x${BLURB}" = "x"; then
             echo "CHECK COPYRIGHT for ${PWD}/${FILENAME}"
         fi
     fi
 
-    if test "$FILENAME" = "libltdl" ; then
+    if test "$FILENAME" = "libltdl/" ; then
         :
     elif test -d $FILENAME ; then
 	cd $FILENAME
@@ -174,31 +187,36 @@ done
 }
 
 # Build XPROF types file from current sources
-echo "#ifndef _PROFILER_XPROF_TYPE_H_" >${ROOT}/lib/profiler/list
-echo "#define _PROFILER_XPROF_TYPE_H_" >>${ROOT}/lib/profiler/list
-echo "/* AUTO-GENERATED FILE */" >>${ROOT}/lib/profiler/list
-echo "#if USE_XPROF_STATS" >>${ROOT}/lib/profiler/list
-echo "typedef enum {" >>${ROOT}/lib/profiler/list
-echo "XPROF_PROF_UNACCOUNTED," >>${ROOT}/lib/profiler/list
-grep -R -h "PROF_start.*" ./* | grep -v probename | sed -e 's/ //g; s/PROF_start(/XPROF_/; s/);/,/' | sort -u >>${ROOT}/lib/profiler/list
-echo "  XPROF_LAST } xprof_type;" >>${ROOT}/lib/profiler/list
-echo "#endif" >>${ROOT}/lib/profiler/list
-echo "#endif" >>${ROOT}/lib/profiler/list
+(
+cat scripts/boilerplate.h
+echo "#ifndef _PROFILER_XPROF_TYPE_H_"
+echo "#define _PROFILER_XPROF_TYPE_H_"
+echo "/* AUTO-GENERATED FILE */"
+echo "#if USE_XPROF_STATS"
+echo "typedef enum {"
+echo "  XPROF_PROF_UNACCOUNTED,"
+grep -R -h "PROF_start.*" ./* | grep -v probename | sed -e 's/ //g; s/PROF_start(/XPROF_/; s/);/,/' | sort -u
+echo "  XPROF_LAST } xprof_type;"
+echo "#endif"
+echo "#endif"
+) >${ROOT}/lib/profiler/list
 mv ${ROOT}/lib/profiler/list ${ROOT}/lib/profiler/xprof_type.h
 
 # Build icons install include from current icons available
 (
+sed -e 's%\ \*%##%' -e 's%/\*%##%' -e 's%##/%##%' <scripts/boilerplate.h
 echo -n "ICONS="
 for f in `ls -1 ${ROOT}/icons/silk/* | sort -u`
 do
 	echo " \\"
 	echo -n "    ${f}"
 done
 echo " "
-)| sed s%${ROOT}/icons/%%g >${ROOT}/icons/list
+)| sed s%${ROOT}/icons/%%g >${ROOT}/icons/icon.list
 
 # Build templates install include from current templates available
 (
+sed -e 's%\ \*%##%' -e 's%/\*%##%' -e 's%##/%##%' <scripts/boilerplate.h
 echo -n "ERROR_TEMPLATES="
 for f in `ls -1 ${ROOT}/errors/templates/ERR_* | sort -u`
 do
@@ -210,6 +228,7 @@ echo " "
 
 # Build errors translation install include from current .PO available
 (
+sed -e 's%\ \*%##%' -e 's%/\*%##%' -e 's%##/%##%' <scripts/boilerplate.h
 echo -n "TRANSLATE_LANGUAGES="
 for f in `ls -1 ${ROOT}/errors/*.po | sort -u`
 do
@@ -221,6 +240,7 @@ echo " "
 
 # Build manuals translation install include from current .PO available
 (
+sed -e 's%\ \*%##%' -e 's%/\*%##%' -e 's%##/%##%' <scripts/boilerplate.h
 echo -n "TRANSLATE_LANGUAGES="
 for f in `ls -1 ${ROOT}/doc/manuals/*.po | sort -u`
 do
@@ -232,6 +252,7 @@ echo " "
 
 # Build STUB framework include from current stub_* available
 (
+sed -e 's%\ \*%##%' -e 's%/\*%##%' -e 's%##/%##%' <scripts/boilerplate.h
 echo -n "STUB_SOURCE= tests/STUB.h"
 for f in `ls -1 ${ROOT}/src/tests/stub_*.cc | sort -u`
 do
@@ -244,5 +265,6 @@ echo " "
 # Run formating
 echo "" >${ROOT}/doc/debug-sections.tmp
 srcformat || exit 1
-sort -u <${ROOT}/doc/debug-sections.tmp | sort -n >${ROOT}/doc/debug-sections.txt
-rm ${ROOT}/doc/debug-sections.tmp
+sort -u <${ROOT}/doc/debug-sections.tmp | sort -n >${ROOT}/doc/debug-sections.tmp2
+cat scripts/boilerplate.h ${ROOT}/doc/debug-sections.tmp2 >${ROOT}/doc/debug-sections.txt
+rm ${ROOT}/doc/debug-sections.tmp ${ROOT}/doc/debug-sections.tmp2
@@ -1310,12 +1310,10 @@ EXPAND_AS_DEFINED      = AsyncCallWrapper \
                          AsyncCall \
                          AsyncCallEnter \
                          AsyncCallExit \
-                         CBDATA_CLASS2 \
+                         CBDATA_CLASS \
                          CBDATA_CLASS_INIT \
                          CBDATA_NAMESPACED_CLASS_INIT \
-                         MEMPROXY_CLASS_INLINE \
                          MEMPROXY_CLASS \
-                         MEMPROXY_CLASS_INIT \
                          STUB \
                          STUB_NOP \
                          STUB_RETVAL
@@ -17,6 +17,8 @@ CBDATA_CLASS_INIT(BodyPipe);
 // data from a BodyPipe
 class BodySink: public BodyConsumer
 {
+    CBDATA_CLASS(BodySink);
+
 public:
     BodySink(const BodyPipe::Pointer &bp): AsyncJob("BodySink"), body_pipe(bp) {}
     virtual ~BodySink() { assert(!body_pipe); }
@@ -35,8 +37,6 @@ class BodySink: public BodyConsumer
 
 private:
     BodyPipe::Pointer body_pipe; ///< the pipe we are consuming from
-
-    CBDATA_CLASS2(BodySink);
 };
 
 CBDATA_CLASS_INIT(BodySink);
@@ -89,6 +89,8 @@ class BodyPipeCheckout
  */
 class BodyPipe: public RefCountable
 {
+    CBDATA_CLASS(BodyPipe);
+
 public:
     typedef RefCount<BodyPipe> Pointer;
     typedef BodyProducer Producer;
@@ -164,8 +166,6 @@ class BodyPipe: public RefCountable
     bool mustAutoConsume; // consume when there is no consumer
     bool abortedConsumption; ///< called BodyProducer::noteBodyConsumerAborted
     bool isCheckedOut; // to keep track of checkout violations
-
-    CBDATA_CLASS2(BodyPipe);
 };
 
 #endif /* SQUID_BODY_PIPE_H */
@@ -88,6 +88,8 @@ class ClientInfo
 // a queue of Comm clients waiting for I/O quota controlled by delay pools
 class CommQuotaQueue
 {
+    CBDATA_CLASS(CommQuotaQueue);
+
 public:
     CommQuotaQueue(ClientInfo *info);
     ~CommQuotaQueue();
@@ -108,8 +110,6 @@ class CommQuotaQueue
     // TODO: optimize using a Ring- or List-based store?
     typedef std::deque<int> Store;
     Store fds; ///< descriptor queue
-
-    CBDATA_CLASS2(CommQuotaQueue);
 };
 #endif /* USE_DELAY_POOLS */
 
@@ -25,6 +25,7 @@ class ErrorState;
 
 class ClientRequestContext : public RefCountable
 {
+    CBDATA_CLASS(ClientRequestContext);
 
 public:
     ClientRequestContext(ClientHttpRequest *);
@@ -89,9 +90,6 @@ class ClientRequestContext : public RefCountable
 #endif
     ErrorState *error; ///< saved error page for centralized/delayed processing
     bool readNextRequest; ///< whether Squid should read after error handling
-
-private:
-    CBDATA_CLASS2(ClientRequestContext);
 };
 
 #endif /* SQUID_CLIENTREQUESTCONTEXT_H */
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \defgroup Comm Comm Module
 \ingroup Components
@@ -11,7 +11,7 @@
 #ifndef COMMREAD_H
 #define COMMREAD_H
 
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "comm.h"
 #include "comm/forward.h"
 #include "CommCalls.h"
@@ -20,6 +20,7 @@ class AIODiskIOStrategy;
 
 class AIODiskFile : public DiskFile
 {
+    CBDATA_CLASS(AIODiskFile);
 
 public:
 
@@ -53,7 +54,6 @@ class AIODiskFile : public DiskFile
     RefCount<IORequestor> ioRequestor;
     bool closed;
     bool error_;
-    CBDATA_CLASS2(AIODiskFile);
 };
 
 #endif /* USE_DISKIO_AIO */
@@ -17,6 +17,7 @@
 
 class BlockingFile : public DiskFile
 {
+    CBDATA_CLASS(BlockingFile);
 
 public:
     BlockingFile(char const *path);
@@ -46,8 +47,6 @@ class BlockingFile : public DiskFile
     void doClose();
     void readDone(int fd, const char *buf, int len, int errflag);
     void writeDone(int fd, int errflag, size_t len);
-
-    CBDATA_CLASS2(BlockingFile);
 };
 
 #endif /* SQUID_BLOCKINGFILE_H */
@@ -23,6 +23,7 @@ struct diomsg;
  */
 class DiskdFile : public DiskFile
 {
+    CBDATA_CLASS(DiskdFile);
 
 public:
     DiskdFile(char const *path, DiskdIOStrategy *);
@@ -58,8 +59,6 @@ class DiskdFile : public DiskFile
     void ioAway();
     void ioCompleted();
     size_t inProgressIOs;
-
-    CBDATA_CLASS2(DiskdFile);
 };
 
 #endif
@@ -16,6 +16,7 @@
 
 class DiskThreadsDiskFile : public DiskFile
 {
+    CBDATA_CLASS(DiskThreadsDiskFile);
 
 public:
     DiskThreadsDiskFile(char const *path, DiskThreadsIOStrategy *);
@@ -60,24 +61,20 @@ class DiskThreadsDiskFile : public DiskFile
 
     void readDone(int fd, const char *buf, int len, int errflag, RefCount<ReadRequest> request);
     void writeDone(int fd, int errflag, size_t len, RefCount<WriteRequest> request);
-
-    CBDATA_CLASS2(DiskThreadsDiskFile);
 };
 
 #include "DiskIO/ReadRequest.h"
 
 template <class RT>
 class IoResult
 {
+    CBDATA_CLASS(IoResult);
 
 public:
     IoResult(RefCount<DiskThreadsDiskFile> aFile, RefCount<RT> aRequest) : file(aFile), request(aRequest) {}
 
     RefCount<DiskThreadsDiskFile> file;
     RefCount<RT> request;
-
-private:
-    CBDATA_CLASS2(IoResult);
 };
 
 template <class RT>
@@ -57,6 +57,7 @@ class IpcIoPendingRequest;
 
 class IpcIoFile: public DiskFile
 {
+    CBDATA_CLASS(IpcIoFile);
 
 public:
     typedef RefCount<IpcIoFile> Pointer;
@@ -143,8 +144,6 @@ class IpcIoFile: public DiskFile
 
     /// whether we are waiting for an event to handle still queued I/O requests
     static bool DiskerHandleMoreRequestsScheduled;
-
-    CBDATA_CLASS2(IpcIoFile);
 };
 
 /// keeps original I/O request parameters while disker is handling the request
@@ -15,6 +15,7 @@
 
 class MmappedFile : public DiskFile
 {
+    CBDATA_CLASS(MmappedFile);
 
 public:
     MmappedFile(char const *path);
@@ -45,8 +46,6 @@ class MmappedFile : public DiskFile
     bool error_;
 
     void doClose();
-
-    CBDATA_CLASS2(MmappedFile);
 };
 
 #endif /* SQUID_MMAPPEDFILE_H */
@@ -14,6 +14,7 @@
 
 class ReadRequest : public RefCountable
 {
+    CBDATA_CLASS(ReadRequest);
 
 public:
     typedef RefCount<ReadRequest> Pointer;
@@ -23,9 +24,6 @@ class ReadRequest : public RefCountable
     char *buf;
     off_t offset;
     size_t len;
-
-private:
-    CBDATA_CLASS2(ReadRequest);
 };
 
 #endif /* SQUID_READREQUEST_H */
@@ -14,6 +14,7 @@
 
 class WriteRequest : public RefCountable
 {
+    CBDATA_CLASS(WriteRequest);
 
 public:
     typedef RefCount<WriteRequest> Pointer;
@@ -24,9 +25,6 @@ class WriteRequest : public RefCountable
     off_t offset;
     size_t len;
     FREE *free_func;
-
-private:
-    CBDATA_CLASS2(WriteRequest);
 };
 
 #endif /* SQUID_WRITEREQUEST_H */
@@ -1,7 +1,16 @@
 #!/bin/sh
+#
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
 echo "/* automatically generated by $0 $*"
 echo " * do not edit"
 echo " */"
+cat `dirname $0`/../../scripts/boilerplate.h
 echo "#include \"squid.h\""
 echo "#include \"DiskIO/DiskIOModule.h\""
 for module in "$@"; do
@@ -38,10 +38,9 @@ class ExternalACLLookup : public ACLChecklist::AsyncState
 
 class ACLExternal : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLExternal);
 
+public:
     static void ExternalAclLookup(ACLChecklist * ch, ACLExternal *);
 
     ACLExternal(char const *);
@@ -70,8 +69,6 @@ class ACLExternal : public ACL
     char const *class_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLExternal);
-
 void parse_externalAclHelper(external_acl **);
 void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 void free_externalAclHelper(external_acl **);
@@ -48,11 +48,13 @@ class ExternalACLEntryData
 
 /*******************************************************************
  * external_acl cache entry
- * Used opaqueue in the interface
+ * Used opaque in the interface
  */
 
 class ExternalACLEntry: public hash_link, public RefCountable
 {
+    MEMPROXY_CLASS(ExternalACLEntry);
+
 public:
     ExternalACLEntry();
     ~ExternalACLEntry();
@@ -73,10 +75,6 @@ class ExternalACLEntry: public hash_link, public RefCountable
     String tag;
     String log;
     external_acl *def;
-
-    MEMPROXY_CLASS(ExternalACLEntry);
 };
 
-MEMPROXY_CLASS_INLINE(ExternalACLEntry);
-
 #endif
@@ -57,6 +57,8 @@ class HelperReply;
 
 class FwdState : public RefCountable
 {
+    CBDATA_CLASS(FwdState);
+
 public:
     typedef RefCount<FwdState> Pointer;
     ~FwdState();
@@ -153,9 +155,6 @@ class FwdState : public RefCountable
     /// possible pconn race states
     typedef enum { raceImpossible, racePossible, raceHappened } PconnRace;
     PconnRace pconnRace; ///< current pconn race state
-
-    // NP: keep this last. It plays with private/public
-    CBDATA_CLASS2(FwdState);
 };
 
 void getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn);
@@ -21,6 +21,7 @@ class Packer;
  */
 class HttpHdrCc
 {
+    MEMPROXY_CLASS(HttpHdrCc);
 
 public:
     static const int32_t MAX_AGE_UNKNOWN=-1; //max-age is unset
@@ -145,8 +146,6 @@ class HttpHdrCc
 
     void packInto(Packer * p) const;
 
-    MEMPROXY_CLASS(HttpHdrCc);
-
     /** bit-mask representing what header values are set among those
      * recognized by squid.
      *
@@ -173,8 +172,6 @@ class HttpHdrCc
     String other;
 };
 
-MEMPROXY_CLASS_INLINE(HttpHdrCc);
-
 class StatHist;
 class StoreEntry;
 
@@ -17,6 +17,7 @@ class StatHist;
 
 class HttpHdrSc
 {
+    MEMPROXY_CLASS(HttpHdrSc);
 
 public:
     HttpHdrSc(const HttpHdrSc &);
@@ -35,15 +36,12 @@ class HttpHdrSc
         dlinkAddTail (t, &t->node, &targets);
     }
 
-    MEMPROXY_CLASS(HttpHdrSc);
     dlink_list targets;
 private:
     HttpHdrScTarget * findTarget (const char *target);
 
 };
 
-MEMPROXY_CLASS_INLINE(HttpHdrSc);
-
 /* Http Surrogate Control Header Field */
 void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 void httpHdrScInitModule (void);
@@ -25,6 +25,8 @@ class StoreEntry;
  */
 class HttpHdrScTarget
 {
+    MEMPROXY_CLASS(HttpHdrScTarget);
+
     // parsing is done in HttpHdrSc, need to grant them access.
     friend class HttpHdrSc;
 public:
@@ -83,7 +85,6 @@ class HttpHdrScTarget
     void packInto (Packer *p) const;
     void updateStats(StatHist *) const;
 
-    MEMPROXY_CLASS(HttpHdrScTarget);
 private:
     bool isSet(http_hdr_sc_type id) const {
         assert (id >= SC_NO_STORE && id < SC_ENUM_END);
@@ -103,8 +104,6 @@ class HttpHdrScTarget
     dlink_node node;
 };
 
-MEMPROXY_CLASS_INLINE(HttpHdrScTarget);
-
 void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROLTARGET_H */
@@ -72,6 +72,7 @@ typedef ssize_t HttpHeaderPos;
 
 class HttpHeaderEntry
 {
+    MEMPROXY_CLASS(HttpHeaderEntry);
 
 public:
     HttpHeaderEntry(http_hdr_type id, const char *name, const char *value);
@@ -81,14 +82,12 @@ class HttpHeaderEntry
     void packInto(Packer *p) const;
     int getInt() const;
     int64_t getInt64() const;
-    MEMPROXY_CLASS(HttpHeaderEntry);
+
     http_hdr_type id;
     String name;
     String value;
 };
 
-MEMPROXY_CLASS_INLINE(HttpHeaderEntry);
-
 class ETag;
 class TimeOrTag;
 
@@ -21,9 +21,9 @@ class HttpReply;
 
 class HttpHdrRangeSpec
 {
+    MEMPROXY_CLASS(HttpHdrRangeSpec);
 
 public:
-    MEMPROXY_CLASS(HttpHdrRangeSpec);
     typedef Range<int64_t, uint64_t> HttpRange;
     static int64_t const UnknownPosition;
 
@@ -39,19 +39,16 @@ class HttpHdrRangeSpec
     int64_t length;
 };
 
-MEMPROXY_CLASS_INLINE(HttpHdrRangeSpec);
-
 /**
  * There may be more than one byte range specified in the request.
  * This object holds all range specs in order of their appearence
  * in the request because we SHOULD preserve that order.
  */
 class HttpHdrRange
 {
-
-public:
     MEMPROXY_CLASS(HttpHdrRange);
 
+public:
     static size_t ParsedCount;
     /* Http Range Header Field */
     static HttpHdrRange *ParseCreate(const String * range_spec);
@@ -89,8 +86,6 @@ class HttpHdrRange
     int64_t clen;
 };
 
-MEMPROXY_CLASS_INLINE(HttpHdrRange);
-
 /**
  * Data for iterating thru range specs
  */
@@ -24,11 +24,11 @@ class HttpHdrSc;
 
 class HttpReply: public HttpMsg
 {
+    MEMPROXY_CLASS(HttpReply);
 
 public:
     typedef RefCount<HttpReply> Pointer;
 
-    MEMPROXY_CLASS(HttpReply);
     HttpReply();
     ~HttpReply();
 
@@ -144,6 +144,4 @@ class HttpReply: public HttpMsg
     virtual bool parseFirstLine(const char *start, const char *end);
 };
 
-MEMPROXY_CLASS_INLINE(HttpReply);
-
 #endif /* SQUID_HTTPREPLY_H */
@@ -70,7 +70,6 @@ HttpRequest::init()
     method = Http::METHOD_NONE;
     url.clear();
     urlpath = NULL;
-    login[0] = '\0';
     host[0] = '\0';
     host_is_numeric = -1;
 #if USE_AUTH
@@ -185,7 +184,7 @@ HttpRequest::clone() const
     copy->pstate = pstate; // TODO: should we assert a specific state here?
     copy->body_pipe = body_pipe;
 
-    strncpy(copy->login, login, sizeof(login)); // MAX_LOGIN_SZ
+    copy->url.userInfo(url.userInfo());
     strncpy(copy->host, host, sizeof(host)); // SQUIDHOSTNAMELEN
     copy->host_addr = host_addr;
 
@@ -43,11 +43,11 @@ class DnsLookupDetails;
 
 class HttpRequest: public HttpMsg
 {
+    MEMPROXY_CLASS(HttpRequest);
 
 public:
     typedef RefCount<HttpRequest> Pointer;
 
-    MEMPROXY_CLASS(HttpRequest);
     HttpRequest();
     HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
     ~HttpRequest();
@@ -116,9 +116,7 @@ class HttpRequest: public HttpMsg
     HttpRequestMethod method;
 
     // TODO expand to include all URI parts
-    URL url; ///< the request URI (scheme only)
-
-    char login[MAX_LOGIN_SZ];
+    URL url; ///< the request URI (scheme and userinfo only)
 
 private:
     char host[SQUIDHOSTNAMELEN];
@@ -263,6 +261,4 @@ class HttpRequest: public HttpMsg
     virtual bool inheritProperties(const HttpMsg *aMsg);
 };
 
-MEMPROXY_CLASS_INLINE(HttpRequest);
-
 #endif /* SQUID_HTTPREQUEST_H */
@@ -578,7 +578,6 @@ EXTRA_squid_SOURCES = \
 
 noinst_HEADERS = \
 	client_side_request.cci \
-	MemBuf.cci \
 	MemBuf.h \
 	StoreEntryStream.h \
 	String.cci \
@@ -726,7 +725,6 @@ ufsdump_SOURCES = \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
-	MemBuf.cci \
 	MemBuf.h \
 	Parsing.h \
 	store_key_md5.h \
@@ -44,12 +44,12 @@ class MemBlobStats
  */
 class MemBlob: public RefCountable
 {
+    MEMPROXY_CLASS(MemBlob);
+
 public:
     typedef RefCount<MemBlob> Pointer;
     typedef uint32_t size_type;
 
-    MEMPROXY_CLASS(MemBlob);
-
     /// obtain a const view of class-wide statistics
     static const MemBlobStats& GetStats();
 
@@ -120,6 +120,4 @@ class MemBlob: public RefCountable
     MemBlob& operator =(const MemBlob &);
 };
 
-MEMPROXY_CLASS_INLINE(MemBlob);
-
 #endif /* SQUID_MEMBLOB_H_ */
@@ -399,7 +399,3 @@ memBufReport(MemBuf * mb)
     assert(mb);
     mb->Printf("memBufReport is not yet implemented @?@\n");
 }
-
-#if !_USE_INLINE_
-#include "MemBuf.cci"
-#endif
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 59    auto-growing Memory Buffer with printf */
-
-MemBuf::MemBuf() : buf (NULL), size (0), max_capacity (0), capacity(0), stolen(0)
-{}
-
-MemBuf::~MemBuf()
-{
-    if (!stolen && buf)
-        clean();
-}
@@ -14,15 +14,24 @@
 
 /**
  * Auto-growing memory-resident buffer with printf interface
- *
- \todo XXX: convert global memBuf*() functions into methods
+ * \deprecated Use SBuf instead.
  */
 class MemBuf
 {
+    CBDATA_CLASS(MemBuf);
 
 public:
-    _SQUID_INLINE_ MemBuf();
-    _SQUID_INLINE_ ~MemBuf();
+    MemBuf():
+        buf(NULL),
+        size(0),
+        max_capacity(0),
+        capacity(0),
+        stolen(0)
+    {}
+    ~MemBuf() {
+        if (!stolen && buf)
+            clean();
+    }
 
     /// start of the added data
     char *content() { return buf; }
@@ -122,23 +131,23 @@ class MemBuf
      \deprecated use space*() and content*() methods to access safely instead.
      * public, read-only.
      *
-     \todo XXX: hide these members completely and remove 0-termination
+     * TODO: hide these members completely and remove 0-termination
      *          so that consume() does not need to memmove all the time
      */
     char *buf;          // available content
     mb_size_t size;     // used space, does not count 0-terminator
 
     /**
      * when grows: assert(new_capacity <= max_capacity)
-     \deprecated Use interface function instead
-     \todo XXX: make these private after converting memBuf*() functions to methods
+     * \deprecated Use interface function instead
+     * TODO: make these private after converting memBuf*() functions to methods
      */
     mb_size_t max_capacity;
 
     /**
      * allocated space
-     \deprecated Use interface function instead
-     \todo XXX: make these private after converting memBuf*() functions to methods
+     * \deprecated Use interface function instead
+     * TODO: make these private after converting memBuf*() functions to methods
      */
     mb_size_t capacity;
 
@@ -148,18 +157,11 @@ class MemBuf
 
     unsigned valid:1;		/* to be used for debugging only! */
 #endif
-
-private:
-    CBDATA_CLASS2(MemBuf);
 };
 
-#if _USE_INLINE_
-#include "MemBuf.cci"
-#endif
-
 /** returns free() function to be used, _freezes_ the object! */
 void memBufReport(MemBuf * mb);
 /** pack content into a mem buf. */
 void packerToMemInit(Packer * p, MemBuf * mb);
 
-#endif /* SQUID_MEM_H */
+#endif /* SQUID_MEMBUF_H */
@@ -29,10 +29,10 @@ class HttpReply;
 
 class MemObject
 {
+    MEMPROXY_CLASS(MemObject);
 
 public:
     static size_t inUseCount();
-    MEMPROXY_CLASS(MemObject);
 
     void dump() const;
     MemObject();
@@ -181,8 +181,6 @@ class MemObject
     DeferredReadManager deferredReads;
 };
 
-MEMPROXY_CLASS_INLINE(MemObject);
-
 /** global current memory removal policy */
 extern RemovalPolicy *mem_policy;
 
@@ -10,8 +10,8 @@
 #define SQUID_NOTES_H
 
 #include "acl/forward.h"
+#include "base/CbDataList.h"
 #include "base/RefCount.h"
-#include "CbDataList.h"
 #include "format/Format.h"
 #include "MemPool.h"
 #include "SquidString.h"
@@ -128,11 +128,11 @@ class NotePairs: public RefCountable
      */
     class Entry
     {
+        MEMPROXY_CLASS(Entry);
     public:
         Entry(const char *aKey, const char *aValue): name(aKey), value(aValue) {}
         String name;
         String value;
-        MEMPROXY_CLASS(Entry);
     };
 
     NotePairs() {}
@@ -208,8 +208,6 @@ class NotePairs: public RefCountable
     NotePairs(NotePairs const &); // Not implemented
 };
 
-MEMPROXY_CLASS_INLINE(NotePairs::Entry);
-
 class AccessLogEntry;
 /**
  * Keep in sync HttpRequest and the corresponding AccessLogEntry objects
@@ -70,6 +70,7 @@ class DigestFetchState
 
 class PeerDigest
 {
+    CBDATA_CLASS(PeerDigest);
 
 public:
     CachePeer *peer;          /**< pointer back to peer structure, argh */
@@ -104,9 +105,6 @@ class PeerDigest
             kb_t kbytes;
         } sent, recv;
     } stats;
-
-private:
-    CBDATA_CLASS2(PeerDigest);
 };
 
 extern const Version CacheDigestVer;
@@ -26,6 +26,8 @@ class PeerConnectorAnswer;
 /// Maintains an fixed-size "standby" PconnPool for a single CachePeer.
 class PeerPoolMgr: public AsyncJob
 {
+    CBDATA_CLASS(PeerPoolMgr);
+
 public:
     typedef CbcPointer<PeerPoolMgr> Pointer;
 
@@ -70,8 +72,6 @@ class PeerPoolMgr: public AsyncJob
     AsyncCall::Pointer securer; ///< whether we are securing a connection
     AsyncCall::Pointer closer; ///< monitors conn while we are securing it
     unsigned int addrUsed; ///< counter for cycling through peer addresses
-
-    CBDATA_CLASS2(PeerPoolMgr);
 };
 
 #endif /* SQUID_PEERPOOLMGR_H */
@@ -45,6 +45,7 @@ class FwdServer
 
 class ps_state
 {
+    CBDATA_CLASS(ps_state);
 
 public:
     ps_state();
@@ -86,8 +87,6 @@ class ps_state
     peer_t hit_type;
     ping_data ping;
     ACLChecklist *acl_checklist;
-private:
-    CBDATA_CLASS2(ps_state);
 };
 
 #endif /* SQUID_PEERSELECTSTATE_H */
@@ -35,6 +35,8 @@ class RemovalPolicyNode
 
 class RemovalPolicy
 {
+    CBDATA_CLASS(RemovalPolicy);
+
 public:
     const char *_type;
     void *_data;
@@ -46,31 +48,29 @@ class RemovalPolicy
     RemovalPolicyWalker *(*WalkInit) (RemovalPolicy * policy);
     RemovalPurgeWalker *(*PurgeInit) (RemovalPolicy * policy, int max_scan);
     void (*Stats) (RemovalPolicy * policy, StoreEntry * entry);
-private:
-    CBDATA_CLASS2(RemovalPolicy);
 };
 
 class RemovalPolicyWalker
 {
+    CBDATA_CLASS(RemovalPolicyWalker);
+
 public:
     RemovalPolicy *_policy;
     void *_data;
     const StoreEntry *(*Next) (RemovalPolicyWalker * walker);
     void (*Done) (RemovalPolicyWalker * walker);
-private:
-    CBDATA_CLASS2(RemovalPolicyWalker);
 };
 
 class RemovalPurgeWalker
 {
+    CBDATA_CLASS(RemovalPurgeWalker);
+
 public:
     RemovalPolicy *_policy;
     void *_data;
     int scanned, max_scan, locked;
     StoreEntry *(*Next) (RemovalPurgeWalker * walker);
     void (*Done) (RemovalPurgeWalker * walker);
-private:
-    CBDATA_CLASS2(RemovalPurgeWalker);
 };
 
 RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
@@ -34,6 +34,7 @@ class StoreClient
 
 class store_client
 {
+    CBDATA_CLASS(store_client);
 
 public:
     store_client(StoreEntry *);
@@ -97,9 +98,6 @@ class store_client
         STCB *callback_handler;
         void *callback_data;
     } _callback;
-
-private:
-    CBDATA_CLASS2(store_client);
 };
 
 void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
@@ -70,6 +70,7 @@ class StoreHashIndexEntry : public StoreEntry
 
 class StoreSearchHashIndex : public StoreSearch
 {
+    CBDATA_CLASS(StoreSearchHashIndex);
 
 public:
     StoreSearchHashIndex(RefCount<StoreHashIndex> sd);
@@ -95,9 +96,6 @@ class StoreSearchHashIndex : public StoreSearch
     bool _done;
     int bucket;
     std::vector<StoreEntry *> entries;
-
-    // keep this last. it plays with private/public
-    CBDATA_CLASS2(StoreSearchHashIndex);
 };
 
 #endif /* SQUID_STOREHASHINDEX_H */
@@ -9,19 +9,16 @@
 #ifndef SQUID_STOREMETAMD5_H
 #define SQUID_STOREMETAMD5_H
 
-/* for inheritance */
-#include "StoreMeta.h"
-/* for MEMPROXY_CLASS() macros */
 #include "MemPool.h"
+#include "StoreMeta.h"
 /* for STORE_META_KEY_MD5 */
 #include "enums.h"
 
 class StoreMetaMD5 : public StoreMeta
 {
-
-public:
     MEMPROXY_CLASS(StoreMetaMD5);
 
+public:
     char getType() const {return STORE_META_KEY_MD5;}
 
     bool validLength(int) const;
@@ -31,6 +28,4 @@ class StoreMetaMD5 : public StoreMeta
     static int md5_mismatches;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaMD5);
-
 #endif /* SQUID_STOREMETAMD5_H */
@@ -14,13 +14,10 @@
 
 class StoreMetaObjSize : public StoreMeta
 {
-
-public:
     MEMPROXY_CLASS(StoreMetaObjSize);
 
+public:
     char getType() const {return STORE_META_OBJSIZE;}
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaObjSize);
-
 #endif /* SQUID_STOREMETAOBJSIZE_H */
@@ -9,22 +9,18 @@
 #ifndef SQUID_STOREMETASTD_H
 #define SQUID_STOREMETASTD_H
 
-#include "StoreMeta.h"
-/* for MEMPROXY_CLASS() macros */
 #include "MemPool.h"
+#include "StoreMeta.h"
 
 class StoreMetaSTD : public StoreMeta
 {
-
-public:
     MEMPROXY_CLASS(StoreMetaSTD);
 
+public:
     char getType() const {return STORE_META_STD;}
 
     bool validLength(int) const;
     //    bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaSTD);
-
 #endif /* SQUID_STOREMETASTD_H */
@@ -9,22 +9,18 @@
 #ifndef SQUID_STOREMETASTDLFS_H
 #define SQUID_STOREMETASTDLFS_H
 
-/* for inheritance */
-#include "StoreMeta.h"
-/* for MEMPROXY() macros */
 #include "MemPool.h"
+#include "StoreMeta.h"
 
 class StoreMetaSTDLFS : public StoreMeta
 {
-public:
     MEMPROXY_CLASS(StoreMetaSTDLFS);
 
+public:
     char getType() const {return STORE_META_STD_LFS;}
 
     bool validLength(int) const;
     //    bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaSTDLFS);
-
 #endif /* SQUID_STOREMETASTDLFS_H */
@@ -9,21 +9,17 @@
 #ifndef SQUID_STOREMETAURL_H
 #define SQUID_STOREMETAURL_H
 
-/* for inheritance */
-#include "StoreMeta.h"
-/* for MEMPROXY_CLASS() macros */
 #include "MemPool.h"
+#include "StoreMeta.h"
 
 class StoreMetaURL : public StoreMeta
 {
-public:
     MEMPROXY_CLASS(StoreMetaURL);
 
+public:
     char getType() const {return STORE_META_URL;}
 
     bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaURL);
-
 #endif /* SQUID_STOREMETAURL_H */
@@ -9,21 +9,17 @@
 #ifndef SQUID_STOREMETAVARY_H
 #define SQUID_STOREMETAVARY_H
 
-/* for inheritance */
-#include "StoreMeta.h"
-/* for MEMPROXY_CLASS() macros */
 #include "MemPool.h"
+#include "StoreMeta.h"
 
 class StoreMetaVary : public StoreMeta
 {
-public:
     MEMPROXY_CLASS(StoreMetaVary);
 
+public:
     char getType() const {return STORE_META_VARY_HEADERS;}
 
     bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaVary);
-
 #endif /* SQUID_STOREMETAVARY_H */
@@ -84,10 +84,9 @@ operator <<(std::ostream &os, const SwapChecksum24 &sum)
  */
 class StoreSwapLogData
 {
-
-public:
     MEMPROXY_CLASS(StoreSwapLogData);
 
+public:
     /// type to use for storing time-related members; must be signed
     typedef int64_t SwappedTime;
 
@@ -177,8 +176,6 @@ class StoreSwapLogData
     unsigned char key[SQUID_MD5_DIGEST_LENGTH];
 };
 
-MEMPROXY_CLASS_INLINE(StoreSwapLogData);
-
 /// \ingroup FileFormatSwapStateAPI
 /// Swap log starts with this binary structure.
 class StoreSwapLogHeader
@@ -11,16 +11,16 @@
 
 #include "anyp/UriScheme.h"
 #include "MemPool.h"
+#include "SBuf.h"
 
 /**
- \ingroup POD
- *
  * The URL class represents a Uniform Resource Location
  */
 class URL
 {
-public:
     MEMPROXY_CLASS(URL);
+
+public:
     URL() : scheme_() {}
     URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme) {}
 
@@ -33,6 +33,9 @@ class URL
     /// convert the URL scheme to that given
     void setScheme(const AnyP::ProtocolType &p) {scheme_=p;}
 
+    void userInfo(const SBuf &s) {userInfo_=s;}
+    const SBuf &userInfo() const {return userInfo_;}
+
 private:
     /**
      \par
@@ -55,9 +58,9 @@ class URL
      * and immutable, only settable at construction time,
      */
     AnyP::UriScheme scheme_;
-};
 
-MEMPROXY_CLASS_INLINE(URL);
+    SBuf userInfo_; // aka 'URL-login'
+};
 
 class HttpRequest;
 class HttpRequestMethod;
@@ -209,16 +209,14 @@ operator <<(std::ostream &o, const allow_t a)
 /// \ingroup ACLAPI
 class acl_proxy_auth_match_cache
 {
+    MEMPROXY_CLASS(acl_proxy_auth_match_cache);
 
 public:
-    MEMPROXY_CLASS(acl_proxy_auth_match_cache);
     dlink_node link;
     int matchrv;
     void *acl_data;
 };
 
-MEMPROXY_CLASS_INLINE(acl_proxy_auth_match_cache);
-
 /// \ingroup ACLAPI
 /// XXX: find a way to remove or at least use a refcounted ACL pointer
 extern const char *AclMatchedName;	/* NULL */
@@ -19,9 +19,9 @@ namespace Acl
 /// acl all-of lines are always ORed together.
 class AllOf: public Acl::InnerNode
 {
-public:
     MEMPROXY_CLASS(AllOf);
 
+public:
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
@@ -35,7 +35,6 @@ class AllOf: public Acl::InnerNode
     static Prototype RegistryProtoype;
     static AllOf RegistryEntry_;
 };
-MEMPROXY_CLASS_INLINE(Acl::AllOf);
 
 } // namespace Acl
 
@@ -17,9 +17,9 @@ namespace Acl
 /// Configurable any-of ACL. Each ACL line is a disjuction of ACLs.
 class AnyOf: public Acl::OrNode
 {
-public:
     MEMPROXY_CLASS(AnyOf);
 
+public:
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
@@ -29,7 +29,6 @@ class AnyOf: public Acl::OrNode
     static Prototype RegistryProtoype;
     static AnyOf RegistryEntry_;
 };
-MEMPROXY_CLASS_INLINE(Acl::AnyOf);
 
 } // namespace Acl
 
@@ -21,10 +21,9 @@ class Eui48;
 /// \ingroup ACLAPI
 class ACLARP : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLARP);
 
+public:
     ACLARP(char const *);
     ACLARP(ACLARP const &);
     ~ACLARP();
@@ -44,6 +43,4 @@ class ACLARP : public ACL
     char const *class_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLARP);
-
 #endif /* SQUID_ACLARP_H */
@@ -67,6 +67,8 @@ struct as_info {
 
 class ASState
 {
+    CBDATA_CLASS(ASState);
+
 public:
     ASState();
     ~ASState();
@@ -79,8 +81,6 @@ class ASState
     int reqofs;
     char reqbuf[AS_REQBUF_SZ];
     bool dataRead;
-private:
-    CBDATA_CLASS2(ASState);
 };
 
 CBDATA_CLASS_INIT(ASState);
@@ -12,7 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "ip/Address.h"
 
 int asnMatchIp(CbDataList<int> *, Ip::Address &);
@@ -26,10 +26,9 @@ void asnFreeMemory(void);
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
 {
-
-public:
     MEMPROXY_CLASS(ACLASN);
 
+public:
     virtual ~ACLASN();
 
     virtual bool match(Ip::Address);
@@ -47,6 +46,4 @@ class ACLASN : public ACLData<Ip::Address>
     CbDataList<int> *data;
 };
 
-MEMPROXY_CLASS_INLINE(ACLASN);
-
 #endif /* SQUID_ACLASN_H */
@@ -13,17 +13,16 @@
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "ssl/support.h"
 
 #include <list>
 
 class ACLAtStepData : public ACLData<Ssl::BumpStep>
 {
-
-public:
     MEMPROXY_CLASS(ACLAtStepData);
 
+public:
     ACLAtStepData();
     ACLAtStepData(ACLAtStepData const &);
     ACLAtStepData &operator= (ACLAtStepData const &);
@@ -37,8 +36,6 @@ class ACLAtStepData : public ACLData<Ssl::BumpStep>
     std::list<Ssl::BumpStep> values;
 };
 
-MEMPROXY_CLASS_INLINE(ACLAtStepData);
-
 #endif /* USE_OPENSSL */
 
 #endif /* SQUID_ACLSSL_ERRORDATA_H */
@@ -21,9 +21,9 @@ namespace Acl
 /// Implements the "not" or "!" operator.
 class NotNode: public InnerNode
 {
-public:
     MEMPROXY_CLASS(NotNode);
 
+public:
     explicit NotNode(ACL *acl);
 
 private:
@@ -36,16 +36,15 @@ class NotNode: public InnerNode
     /* Acl::InnerNode API */
     virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
 };
-MEMPROXY_CLASS_INLINE(Acl::NotNode);
 
 /// An inner ACL expression tree node representing a boolean conjuction (AND)
 /// operator applied to a list of child tree nodes.
 /// For example, conditions expressed on a single http_access line are ANDed.
 class AndNode: public InnerNode
 {
-public:
     MEMPROXY_CLASS(AndNode);
 
+public:
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
@@ -54,16 +53,15 @@ class AndNode: public InnerNode
 private:
     virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
 };
-MEMPROXY_CLASS_INLINE(Acl::AndNode);
 
 /// An inner ACL expression tree node representing a boolean disjuction (OR)
 /// operator applied to a list of child tree nodes.
 /// For example, conditions expressed by multiple http_access lines are ORed.
 class OrNode: public InnerNode
 {
-public:
     MEMPROXY_CLASS(OrNode);
 
+public:
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
@@ -75,7 +73,6 @@ class OrNode: public InnerNode
 private:
     virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
 };
-MEMPROXY_CLASS_INLINE(Acl::OrNode);
 
 } // namespace Acl
 
@@ -20,10 +20,9 @@
 /// \ingroup ACLAPI
 class ACLCertificateData : public ACLData<X509 *>
 {
-
-public:
     MEMPROXY_CLASS(ACLCertificateData);
 
+public:
     ACLCertificateData(Ssl::GETX509ATTRIBUTE *, const char *attributes, bool optionalAttr = false);
     ACLCertificateData(ACLCertificateData const &);
     ACLCertificateData &operator= (ACLCertificateData const &);
@@ -51,6 +50,4 @@ class ACLCertificateData : public ACLData<X509 *>
     Ssl::GETX509ATTRIBUTE *sslAttributeCall;
 };
 
-MEMPROXY_CLASS_INLINE(ACLCertificateData);
-
 #endif /* SQUID_ACLCERTIFICATEDATA_H */
@@ -8,6 +8,7 @@
 
 #ifndef SQUID_ACLDESTINATIONIP_H
 #define SQUID_ACLDESTINATIONIP_H
+
 #include "acl/Checklist.h"
 #include "acl/Ip.h"
 #include "ipcache.h"
@@ -26,10 +27,9 @@ class DestinationIPLookup : public ACLChecklist::AsyncState
 
 class ACLDestinationIP : public ACLIP
 {
-
-public:
     MEMPROXY_CLASS(ACLDestinationIP);
 
+public:
     ACLDestinationIP(): ACLIP(ACLDestinationIP::SupportedFlags) {}
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
@@ -43,6 +43,4 @@ class ACLDestinationIP : public ACLIP
     static ACLDestinationIP RegistryEntry_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLDestinationIP);
-
 #endif /* SQUID_ACLDESTINATIONIP_H */
@@ -13,13 +13,11 @@
 #include "acl/Data.h"
 #include "splay.h"
 
-/// \ingroup ACLAPI
 class ACLDomainData : public ACLData<char const *>
 {
-
-public:
     MEMPROXY_CLASS(ACLDomainData);
 
+public:
     virtual ~ACLDomainData();
     bool match(char const *);
     virtual SBufList dump() const;
@@ -30,6 +28,4 @@ class ACLDomainData : public ACLData<char const *>
     SplayNode<char *> *domains;
 };
 
-MEMPROXY_CLASS_INLINE(ACLDomainData);
-
 #endif /* SQUID_ACLDOMAINDATA_H */
@@ -18,13 +18,11 @@ namespace Eui
 class Eui64;
 };
 
-/// \ingroup ACLAPI
 class ACLEui64 : public ACL
 {
+    MEMPROXY_CLASS(ACLEui64);
 
 public:
-    MEMPROXY_CLASS(ACLEUI64);
-
     ACLEui64(char const *);
     ACLEui64(ACLEui64 const &);
     ~ACLEui64();
@@ -44,6 +42,4 @@ class ACLEui64 : public ACL
     char const *class_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLEui64);
-
 #endif /* SQUID_ACLEUI64_H */
@@ -15,13 +15,11 @@
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 
-/// \ingroup ACLAPI
 class ACLExtUser : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLExtUser);
 
+public:
     ACLExtUser(ACLData<char const *> *newData, char const *);
     ACLExtUser (ACLExtUser const &old);
     ACLExtUser & operator= (ACLExtUser const &rhs);
@@ -44,7 +42,5 @@ class ACLExtUser : public ACL
     char const *type_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLExtUser);
-
 #endif /* USE_AUTH */
 #endif /* SQUID_EXTUSER_H */
@@ -28,9 +28,12 @@ class HttpReply;
 
 /** \ingroup ACLAPI
     ACLChecklist filled with specific data, representing Squid and transaction
-    state for access checks along with some data-specific checking methods */
+    state for access checks along with some data-specific checking methods
+ */
 class ACLFilledChecklist: public ACLChecklist
 {
+    CBDATA_CLASS(ACLFilledChecklist);
+
 public:
     ACLFilledChecklist();
     ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
@@ -97,8 +100,6 @@ class ACLFilledChecklist: public ACLChecklist
     ACLFilledChecklist(const ACLFilledChecklist &);
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
-
-    CBDATA_CLASS2(ACLFilledChecklist);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
@@ -11,16 +11,15 @@
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "hier_code.h"
 
 /// \ingroup ACLAPI
 class ACLHierCodeData : public ACLData<hier_code>
 {
-
-public:
     MEMPROXY_CLASS(ACLHierCodeData);
 
+public:
     ACLHierCodeData();
     ACLHierCodeData(ACLHierCodeData const &);
     ACLHierCodeData &operator= (ACLHierCodeData const &);
@@ -35,6 +34,4 @@ class ACLHierCodeData : public ACLData<hier_code>
     bool values[HIER_MAX];
 };
 
-MEMPROXY_CLASS_INLINE(ACLHierCodeData);
-
 #endif /* SQUID_ACLHIERCODEDATA_H */
@@ -9,25 +9,16 @@
 #ifndef SQUID_ACLHTTPHEADERDATA_H
 #define SQUID_ACLHTTPHEADERDATA_H
 
-class HttpHeader;
-class wordlist;
-
-/* becaue we inherit from it */
 #include "acl/Data.h"
-/* for String field */
-#include "SquidString.h"
-/* for http_hdr_type field */
 #include "HttpHeader.h"
-/* because weuse its MEMPROXY_CLASS() macros */
 #include "MemPool.h"
+#include "SquidString.h"
 
-/// \ingroup ACLAPI
 class ACLHTTPHeaderData : public ACLData<HttpHeader*>
 {
-
-public:
     MEMPROXY_CLASS(ACLHTTPHeaderData);
 
+public:
     ACLHTTPHeaderData();
     virtual ~ACLHTTPHeaderData();
     virtual bool match(HttpHeader* hdr);
@@ -42,6 +33,4 @@ class ACLHTTPHeaderData : public ACLData<HttpHeader*>
     ACLData<char const *> * regex_rule;
 };
 
-MEMPROXY_CLASS_INLINE(ACLHTTPHeaderData);
-
 #endif /* SQUID_ACLHTTPHEADERDATA_H */
@@ -26,10 +26,9 @@ struct acl_httpstatus_data {
 /// \ingroup ACLAPI
 class ACLHTTPStatus : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLHTTPStatus);
 
+public:
     ACLHTTPStatus(char const *);
     ACLHTTPStatus(ACLHTTPStatus const &);
     ~ACLHTTPStatus();
@@ -50,6 +49,4 @@ class ACLHTTPStatus : public ACL
     char const *class_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLHTTPStatus);
-
 #endif /* SQUID_ACLHTTPSTATUS_H */
@@ -10,7 +10,7 @@
 #define SQUID_ACLINTRANGE_H
 
 #include "acl/Data.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "Range.h"
 
 /// \ingroup ACLAPI
@@ -384,10 +384,15 @@ acl_ip_data::FactoryParse(const char *t)
 
         int errcode = getaddrinfo(addr1,NULL,&hints,&hp);
         if (hp == NULL) {
-            debugs(28, DBG_CRITICAL, "aclIpParseIpData: Bad host/IP: '" << addr1 <<
-                   "' in '" << t << "', flags=" << hints.ai_flags <<
-                   " : (" << errcode << ") " << gai_strerror(errcode) );
-            self_destruct();
+            if (strcmp(addr1, "::1") == 0) {
+                debugs(28, DBG_IMPORTANT, "aclIpParseIpData: IPv6 has not been enabled in host DNS resolver.");
+                delete q;
+            } else {
+                debugs(28, DBG_CRITICAL, "aclIpParseIpData: Bad host/IP: '" << addr1 <<
+                       "' in '" << t << "', flags=" << hints.ai_flags <<
+                       " : (" << errcode << ") " << gai_strerror(errcode) );
+                self_destruct();
+            }
             return NULL;
         }
 
@@ -14,12 +14,11 @@
 #include "ip/Address.h"
 #include "splay.h"
 
-/// \ingroup ACLAPI
 class acl_ip_data
 {
+    MEMPROXY_CLASS(acl_ip_data);
 
 public:
-    MEMPROXY_CLASS(acl_ip_data);
     static acl_ip_data *FactoryParse(char const *);
     static int NetworkCompare(acl_ip_data * const & a, acl_ip_data * const &b);
 
@@ -42,12 +41,8 @@ class acl_ip_data
     static bool DecodeMask(const char *asc, Ip::Address &mask, int string_format_type);
 };
 
-MEMPROXY_CLASS_INLINE(acl_ip_data);
-
-/// \ingroup ACLAPI
 class ACLIP : public ACL
 {
-
 public:
     void *operator new(size_t);
     void operator delete(void *);
@@ -14,9 +14,9 @@
 /// \ingroup ACLAPI
 class ACLLocalIP : public ACLIP
 {
+    MEMPROXY_CLASS(ACLLocalIP);
 
 public:
-    MEMPROXY_CLASS(ACLLocalIP);
     static ACLLocalIP const &RegistryEntry();
 
     virtual char const *typeString() const;
@@ -28,6 +28,4 @@ class ACLLocalIP : public ACLIP
     static ACLLocalIP RegistryEntry_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLLocalIP);
-
 #endif /* SQUID_ACLLOCALIP_H */
@@ -15,10 +15,9 @@
 /// \ingroup ACLAPI
 class ACLMaxConnection : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLMaxConnection);
 
+public:
     ACLMaxConnection(char const *);
     ACLMaxConnection(ACLMaxConnection const &);
     ~ACLMaxConnection();
@@ -40,6 +39,4 @@ class ACLMaxConnection : public ACL
     int limit;
 };
 
-MEMPROXY_CLASS_INLINE(ACLMaxConnection);
-
 #endif /* SQUID_ACLMAXCONNECTION_H */
@@ -11,16 +11,14 @@
 
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "http/RequestMethod.h"
 
-/// \ingroup ACLAPI
 class ACLMethodData : public ACLData<HttpRequestMethod>
 {
-
-public:
     MEMPROXY_CLASS(ACLMethodData);
 
+public:
     ACLMethodData();
     ACLMethodData(ACLMethodData const &);
     ACLMethodData &operator= (ACLMethodData const &);
@@ -36,6 +34,4 @@ class ACLMethodData : public ACLData<HttpRequestMethod>
     static int ThePurgeCount; ///< PURGE methods seen by parse()
 };
 
-MEMPROXY_CLASS_INLINE(ACLMethodData);
-
 #endif /* SQUID_ACLMETHODDATA_H */
@@ -19,9 +19,9 @@ class NotePairs;
 /// \ingroup ACLAPI
 class ACLNoteData : public ACLData<HttpRequest *>
 {
-public:
     MEMPROXY_CLASS(ACLNoteData);
 
+public:
     ACLNoteData();
     virtual ~ACLNoteData();
     virtual bool match(HttpRequest* request);
@@ -36,6 +36,4 @@ class ACLNoteData : public ACLData<HttpRequest *>
     ACLData<char const *> *values; ///< if set, at least one value must match
 };
 
-MEMPROXY_CLASS_INLINE(ACLNoteData);
-
 #endif /* SQUID_ACLNOTEDATA_H */
@@ -12,14 +12,13 @@
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "anyp/ProtocolType.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 
 class ACLProtocolData : public ACLData<AnyP::ProtocolType>
 {
-
-public:
     MEMPROXY_CLASS(ACLProtocolData);
 
+public:
     ACLProtocolData();
     ACLProtocolData(ACLProtocolData const &);
     ACLProtocolData &operator= (ACLProtocolData const &);
@@ -33,6 +32,4 @@ class ACLProtocolData : public ACLData<AnyP::ProtocolType>
     CbDataList<AnyP::ProtocolType> *values;
 };
 
-MEMPROXY_CLASS_INLINE(ACLProtocolData);
-
 #endif /* SQUID_ACLPROTOCOLDATA_H */
@@ -12,13 +12,11 @@
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 
-/// \ingroup ACLAPI
 class ACLRandom : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLRandom);
 
+public:
     ACLRandom(char const *);
     ACLRandom(ACLRandom const &);
     ~ACLRandom();
@@ -40,6 +38,4 @@ class ACLRandom : public ACL
     char const *class_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLRandom);
-
 #endif /* SQUID_ACL_RANDOM_H */
@@ -16,10 +16,9 @@ class RegexList;
 
 class ACLRegexData : public ACLData<char const *>
 {
-
-public:
     MEMPROXY_CLASS(ACLRegexData);
 
+public:
     virtual ~ACLRegexData();
     virtual bool match(char const *user);
     virtual SBufList dump() const;
@@ -31,6 +30,4 @@ class ACLRegexData : public ACLData<char const *>
     RegexList *data;
 };
 
-MEMPROXY_CLASS_INLINE(ACLRegexData);
-
 #endif /* SQUID_ACLREGEXDATA_H */
@@ -8,14 +8,14 @@
 
 #ifndef SQUID_ACLSOURCEIP_H
 #define SQUID_ACLSOURCEIP_H
+
 #include "acl/Ip.h"
 
 class ACLSourceIP : public ACLIP
 {
-
-public:
     MEMPROXY_CLASS(ACLSourceIP);
 
+public:
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
     virtual ACL *clone()const;
@@ -25,6 +25,4 @@ class ACLSourceIP : public ACLIP
     static ACLSourceIP RegistryEntry_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLSourceIP);
-
 #endif /* SQUID_ACLSOURCEIP_H */
@@ -8,19 +8,19 @@
 
 #ifndef SQUID_ACLSSL_ERRORDATA_H
 #define SQUID_ACLSSL_ERRORDATA_H
+
 #include "acl/Acl.h"
 #include "acl/Data.h"
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/support.h"
 #include <vector>
 
 class ACLSslErrorData : public ACLData<const Ssl::CertErrors *>
 {
-
-public:
     MEMPROXY_CLASS(ACLSslErrorData);
 
+public:
     ACLSslErrorData();
     ACLSslErrorData(ACLSslErrorData const &);
     ACLSslErrorData &operator= (ACLSslErrorData const &);
@@ -34,6 +34,4 @@ class ACLSslErrorData : public ACLData<const Ssl::CertErrors *>
     Ssl::Errors *values;
 };
 
-MEMPROXY_CLASS_INLINE(ACLSslErrorData);
-
 #endif /* SQUID_ACLSSL_ERRORDATA_H */
@@ -8,16 +8,16 @@
 
 #ifndef SQUID_ACLSTRINGDATA_H
 #define SQUID_ACLSTRINGDATA_H
+
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "splay.h"
 
 class ACLStringData : public ACLData<char const *>
 {
-
-public:
     MEMPROXY_CLASS(ACLStringData);
 
+public:
     ACLStringData();
     ACLStringData(ACLStringData const &);
     ACLStringData &operator= (ACLStringData const &);
@@ -33,8 +33,4 @@ class ACLStringData : public ACLData<char const *>
     SplayNode<char *> *values;
 };
 
-/* TODO move into .cci files */
-
-MEMPROXY_CLASS_INLINE(ACLStringData);
-
 #endif /* SQUID_ACLSTRINGDATA_H */
@@ -8,16 +8,16 @@
 
 #ifndef SQUID_ACLTIMEDATA_H
 #define SQUID_ACLTIMEDATA_H
+
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "splay.h"
 
 class ACLTimeData : public ACLData<time_t>
 {
-
-public:
     MEMPROXY_CLASS(ACLTimeData);
 
+public:
     ACLTimeData();
     ACLTimeData(ACLTimeData const &);
     ACLTimeData&operator=(ACLTimeData const &);
@@ -35,6 +35,4 @@ class ACLTimeData : public ACLData<time_t>
     ACLTimeData *next;
 };
 
-MEMPROXY_CLASS_INLINE(ACLTimeData);
-
 #endif /* SQUID_ACLTIMEDATA_H */
@@ -19,6 +19,10 @@ namespace Acl
 /// unique properties: cbdata protection and optional rule actions.
 class Tree: public OrNode
 {
+    // XXX: We should use refcounting instead, but it requires making ACLs
+    // refcounted as well. Otherwise, async lookups will reach deleted ACLs.
+    CBDATA_CLASS(Tree);
+
 public:
     /// dumps <name, action, rule, new line> tuples
     /// action.kind is mapped to a string using the supplied conversion table
@@ -41,11 +45,6 @@ class Tree: public OrNode
     /// if not empty, contains actions corresponding to InnerNode::nodes
     typedef std::vector<allow_t> Actions;
     Actions actions;
-
-private:
-    // XXX: We should use refcounting instead, but it requires making ACLs
-    // refcounted as well. Otherwise, async lookups will reach deleted ACLs.
-    CBDATA_CLASS2(Tree);
 };
 
 } // namespace Acl
@@ -16,13 +16,19 @@
 #include "rfc1738.h"
 
 int
-ACLUrlLoginStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLUrlLoginStrategy::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    char *esc_buf = xstrdup(checklist->request->login);
-    rfc1738_unescape(esc_buf);
-    int result = data->match(esc_buf);
-    safe_free(esc_buf);
-    return result;
+    if (checklist->request->url.userInfo().isEmpty()) {
+        debugs(28, 5, "URL has no user-info details. cannot match");
+        return 0; // nothing can match
+    }
+
+    static char str[MAX_URL]; // should be big enough for a single URI segment
+
+    const SBuf::size_type len = checklist->request->url.userInfo().copy(str, sizeof(str)-1);
+    str[len] = '\0';
+    rfc1738_unescape(str);
+    return data->match(str);
 }
 
 ACLUrlLoginStrategy *
@@ -8,16 +8,16 @@
 
 #ifndef SQUID_ACLUSERDATA_H
 #define SQUID_ACLUSERDATA_H
+
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "splay.h"
 
 class ACLUserData : public ACLData<char const *>
 {
-
-public:
     MEMPROXY_CLASS(ACLUserData);
 
+public:
     virtual ~ACLUserData();
     bool match(char const *user);
     virtual SBufList dump() const;
@@ -33,6 +33,4 @@ class ACLUserData : public ACLData<char const *>
     } flags;
 };
 
-MEMPROXY_CLASS_INLINE(ACLUserData);
-
 #endif /* SQUID_ACLUSERDATA_H */
@@ -29,6 +29,8 @@ class AccessRule;
 // checks adaptation_access rules to find a matching adaptation service
 class AccessCheck: public virtual AsyncJob
 {
+    CBDATA_CLASS(AccessCheck);
+
 public:
     typedef void AccessCheckCallback(ServiceGroupPointer group, void *data);
 
@@ -67,9 +69,6 @@ class AccessCheck: public virtual AsyncJob
 
     bool usedDynamicRules();
     void check();
-
-private:
-    CBDATA_CLASS2(AccessCheck);
 };
 
 } // namespace Adaptation
@@ -32,6 +32,8 @@ namespace Adaptation
 /// iterates services in ServiceGroup, starting adaptation launchers
 class Iterator: public Initiate, public Initiator
 {
+    CBDATA_CLASS(Iterator);
+
 public:
     Iterator(HttpMsg *virginHeader, HttpRequest *virginCause,
              AccessLogEntry::Pointer &alp,
@@ -71,8 +73,6 @@ class Iterator: public Initiate, public Initiator
     CbcPointer<Adaptation::Initiate> theLauncher; ///< current transaction launcher
     int iterations; ///< number of steps initiated
     bool adapted; ///< whether the virgin message has been replaced
-
-    CBDATA_CLASS2(Iterator);
 };
 
 } // namespace Adaptation
@@ -32,6 +32,8 @@ namespace Ecap
 class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
         public BodyConsumer, public BodyProducer
 {
+    CBDATA_CLASS(XactionRep);
+
 public:
     XactionRep(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, const Adaptation::ServicePointer &service);
     virtual ~XactionRep();
@@ -69,7 +71,7 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
     virtual void noteBodyProductionEnded(RefCount<BodyPipe> bp);
     virtual void noteBodyProducerAborted(RefCount<BodyPipe> bp);
 
-    //  Initiate API
+    // Initiate API
     virtual void noteInitiatorAborted();
 
     // AsyncJob API (via Initiate)
@@ -121,8 +123,6 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
     bool abProductionFinished; // whether adapter has finished producing ab
     bool abProductionAtEnd;    // whether adapter produced a complete ab
     AccessLogEntry::Pointer al; ///< Master transaction AccessLogEntry
-
-    CBDATA_CLASS2(XactionRep);
 };
 
 } // namespace Ecap
@@ -108,6 +108,7 @@ class Preview
 
 class ModXact: public Xaction, public BodyProducer, public BodyConsumer
 {
+    CBDATA_CLASS(ModXact);
 
 public:
     ModXact(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, ServiceRep::Pointer &s);
@@ -316,13 +317,14 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
     } state;
 
     AccessLogEntry::Pointer alMaster; ///< Master transaction AccessLogEntry
-    CBDATA_CLASS2(ModXact);
 };
 
 // An Launcher that stores ModXact construction info and
 // creates ModXact when needed
 class ModXactLauncher: public Launcher
 {
+    CBDATA_CLASS(ModXactLauncher);
+
 public:
     ModXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, Adaptation::ServicePointer s);
 
@@ -337,9 +339,6 @@ class ModXactLauncher: public Launcher
     InOut virgin;
 
     AccessLogEntry::Pointer al;
-
-private:
-    CBDATA_CLASS2(ModXactLauncher);
 };
 
 } // namespace Icap
@@ -24,6 +24,7 @@ namespace Icap
 
 class OptXact: public Xaction
 {
+    CBDATA_CLASS(OptXact);
 
 public:
     OptXact(ServiceRep::Pointer &aService);
@@ -46,22 +47,19 @@ class OptXact: public Xaction
     virtual void finalizeLogInfo();
 
     bool readAll; ///< read the entire OPTIONS response
-
-    CBDATA_CLASS2(OptXact);
 };
 
 // An Launcher that stores OptXact construction info and
 // creates OptXact when needed
 class OptXactLauncher: public Launcher
 {
+    CBDATA_CLASS(OptXactLauncher);
+
 public:
     OptXactLauncher(Adaptation::ServicePointer aService);
 
 protected:
     virtual Xaction *createXaction();
-
-private:
-    CBDATA_CLASS2(OptXactLauncher);
 };
 
 } // namespace Icap
@@ -59,6 +59,7 @@ class OptXact;
 class ServiceRep : public RefCountable, public Adaptation::Service,
         public Adaptation::Initiator
 {
+    CBDATA_CLASS(ServiceRep);
 
 public:
     typedef RefCount<ServiceRep> Pointer;
@@ -182,7 +183,6 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
 
     mutable bool wasAnnouncedUp; // prevent sequential same-state announcements
     bool isDetached;
-    CBDATA_CLASS2(ServiceRep);
 };
 
 class ModXact;
@@ -164,7 +164,6 @@ class Xaction: public Adaptation::Initiate
 
 private:
     Comm::ConnOpener *cs;
-    //CBDATA_CLASS2(Xaction);
 };
 
 } // namespace Icap
@@ -15,12 +15,11 @@
 #include "acl/Checklist.h"
 #include "auth/UserRequest.h"
 
-/// \ingroup ACLAPI
 class ACLMaxUserIP : public ACL
 {
-public:
     MEMPROXY_CLASS(ACLMaxUserIP);
 
+public:
     ACLMaxUserIP(char const *theClass);
     ACLMaxUserIP(ACLMaxUserIP const &old);
     ~ACLMaxUserIP();
@@ -49,7 +48,5 @@ class ACLMaxUserIP : public ACL
     int maximum;
 };
 
-MEMPROXY_CLASS_INLINE(ACLMaxUserIP);
-
 #endif /* USE_AUTH */
 #endif /* SQUID_ACLMAXUSERIP_H */
@@ -29,9 +29,9 @@ class ProxyAuthLookup : public ACLChecklist::AsyncState
 
 class ACLProxyAuth : public ACL
 {
-public:
     MEMPROXY_CLASS(ACLProxyAuth);
 
+public:
     ~ACLProxyAuth();
     ACLProxyAuth(ACLData<char const *> *, char const *);
     ACLProxyAuth(ACLProxyAuth const &);
@@ -60,7 +60,5 @@ class ACLProxyAuth : public ACL
     char const *type_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLProxyAuth);
-
 #endif /* USE_AUTH */
 #endif /* SQUID_ACLPROXYAUTH_H */
@@ -30,11 +30,9 @@
  */
 class AuthUserHashPointer : public hash_link
 {
-    /* first two items must be same as hash_link */
-
-public:
     MEMPROXY_CLASS(AuthUserHashPointer);
 
+public:
     AuthUserHashPointer(Auth::User::Pointer);
     ~AuthUserHashPointer() { auth_user = NULL; };
 
@@ -44,8 +42,6 @@ class AuthUserHashPointer : public hash_link
     Auth::User::Pointer auth_user;
 };
 
-MEMPROXY_CLASS_INLINE(AuthUserHashPointer);
-
 namespace Auth
 {
 class Scheme;
@@ -24,6 +24,7 @@ namespace Auth
  */
 class QueueNode
 {
+    MEMPROXY_CLASS(Auth::QueueNode);
 
 private:
     // we store CBDATA here, copy is not safe
@@ -50,12 +51,8 @@ class QueueNode
     Auth::UserRequest::Pointer auth_user_request;
     AUTHCB *handler;
     void *data;
-
-    MEMPROXY_CLASS(Auth::QueueNode);
 };
 
-MEMPROXY_CLASS_INLINE(Auth::QueueNode);
-
 } // namespace Auth
 
 #endif /* SQUID_SRC_AUTH_QUEUENODE_H */
@@ -22,6 +22,8 @@ namespace Auth
  */
 class StateData
 {
+    CBDATA_CLASS(StateData);
+
 public:
     StateData(const UserRequest::Pointer &r, AUTHCB *h, void *d) :
             data(cbdataReference(d)),
@@ -36,9 +38,6 @@ class StateData
     void *data;
     UserRequest::Pointer auth_user_request;
     AUTHCB *handler;
-
-private:
-    CBDATA_CLASS2(StateData);
 };
 
 } // namespace Auth
@@ -36,6 +36,8 @@ class HttpRequest;
  */
 class AuthUserIP
 {
+    MEMPROXY_CLASS(AuthUserIP);
+
 public:
     AuthUserIP(const Ip::Address &ip, time_t t) : ipaddr(ip), ip_expiretime(t) {}
 
@@ -49,12 +51,8 @@ class AuthUserIP
      * (user,IP) pair plus authenticate_ip_ttl seconds
      */
     time_t ip_expiretime;
-
-    MEMPROXY_CLASS(AuthUserIP);
 };
 
-MEMPROXY_CLASS_INLINE(AuthUserIP);
-
 // TODO: make auth schedule AsyncCalls?
 typedef void AUTHCB(void*);
 
@@ -24,9 +24,9 @@ namespace Basic
 /** User credentials for the Basic authentication protocol */
 class User : public Auth::User
 {
-public:
     MEMPROXY_CLASS(Auth::Basic::User);
 
+public:
     User(Auth::Config *, const char *requestRealm);
     ~User();
     bool authenticated() const;
@@ -44,8 +44,6 @@ class User : public Auth::User
     Auth::UserRequest::Pointer currentRequest;
 };
 
-MEMPROXY_CLASS_INLINE(Auth::Basic::User);
-
 } // namespace Basic
 } // namespace Auth
 
@@ -25,9 +25,9 @@ namespace Basic
 
 class UserRequest : public Auth::UserRequest
 {
-public:
     MEMPROXY_CLASS(Auth::Basic::UserRequest);
 
+public:
     UserRequest() {}
     virtual ~UserRequest() { assert(LockCount()==0); }
 
@@ -44,6 +44,4 @@ class UserRequest : public Auth::UserRequest
 } // namespace Basic
 } // namespace Auth
 
-MEMPROXY_CLASS_INLINE(Auth::Basic::UserRequest);
-
 #endif /* _SQUID_SRC_AUTH_BASIC_USERREQUEST_H */
@@ -19,9 +19,9 @@ namespace Digest
 /** User credentials for the Digest authentication protocol */
 class User : public Auth::User
 {
-public:
     MEMPROXY_CLASS(Auth::Digest::User);
 
+public:
     User(Auth::Config *, const char *requestRealm);
     ~User();
     int authenticated() const;
@@ -37,8 +37,6 @@ class User : public Auth::User
     digest_nonce_h * currentNonce();
 };
 
-MEMPROXY_CLASS_INLINE(Auth::Digest::User);
-
 } // namespace Digest
 } // namespace Auth
 
@@ -26,10 +26,9 @@ namespace Digest
  */
 class UserRequest : public Auth::UserRequest
 {
-
-public:
     MEMPROXY_CLASS(Auth::Digest::UserRequest);
 
+public:
     UserRequest();
     virtual ~UserRequest();
 
@@ -69,6 +68,4 @@ class UserRequest : public Auth::UserRequest
 } // namespace Digest
 } // namespace Auth
 
-MEMPROXY_CLASS_INLINE(Auth::Digest::UserRequest);
-
 #endif /* _SQUID_SRC_AUTH_DIGEST_USERREQUEST_H */
@@ -22,17 +22,16 @@ namespace Negotiate
 /** User credentials for the Negotiate authentication protocol */
 class User : public Auth::User
 {
-public:
     MEMPROXY_CLASS(Auth::Negotiate::User);
+
+public:
     User(Auth::Config *, const char *requestRealm);
     ~User();
     virtual int32_t ttl() const;
 
     dlink_list proxy_auth_list;
 };
 
-MEMPROXY_CLASS_INLINE(Auth::Negotiate::User);
-
 } // namespace Negotiate
 } // namespace Auth
 
@@ -25,10 +25,9 @@ namespace Negotiate
 /// \ingroup AuthNegotiateAPI
 class UserRequest : public Auth::UserRequest
 {
-
-public:
     MEMPROXY_CLASS(Auth::Negotiate::UserRequest);
 
+public:
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
@@ -66,6 +65,4 @@ class UserRequest : public Auth::UserRequest
 } // namespace Negotiate
 } // namespace Auth
 
-MEMPROXY_CLASS_INLINE(Auth::Negotiate::UserRequest);
-
 #endif /* _SQUID_SRC_AUTH_NEGOTIATE_USERREQUEST_H */
@@ -22,8 +22,9 @@ namespace Ntlm
 /** User credentials for the NTLM authentication protocol */
 class User : public Auth::User
 {
-public:
     MEMPROXY_CLASS(Auth::Ntlm::User);
+
+public:
     User(Auth::Config *, const char *requestRealm);
     ~User();
 
@@ -32,8 +33,6 @@ class User : public Auth::User
     dlink_list proxy_auth_list;
 };
 
-MEMPROXY_CLASS_INLINE(Auth::Ntlm::User);
-
 } // namespace Ntlm
 } // namespace Auth
 
@@ -24,10 +24,9 @@ namespace Ntlm
 
 class UserRequest : public Auth::UserRequest
 {
-
-public:
     MEMPROXY_CLASS(Auth::Ntlm::UserRequest);
 
+public:
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
@@ -61,6 +60,4 @@ class UserRequest : public Auth::UserRequest
 } // namespace Ntlm
 } // namespace Auth
 
-MEMPROXY_CLASS_INLINE(Auth::Ntlm::UserRequest);
-
 #endif /* _SQUID_SRC_AUTH_NTLM_USERREQUEST_H */
@@ -38,7 +38,7 @@ class AsyncCallQueue;
 
 /**
  \todo add unique call IDs
- \todo CBDATA_CLASS2 kids
+ \todo CBDATA_CLASS kids
  \ingroup AsyncCallsAPI
  */
 class AsyncCall: public RefCountable
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \defgroup AsyncCalls Asynchronous Calls
 \ingroup Components
@@ -1,3 +1,11 @@
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
 /**
 \defgroup AsyncJobs Asynchronous Jobs
 \ingroup Components
@@ -6,19 +6,18 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_LIST_H
-#define SQUID_LIST_H
+#ifndef SQUID_CBDATALIST_H
+#define SQUID_CBDATALIST_H
 
-/** \todo FUBAR: cbdata.h is over in src/ */
-#include "../src/cbdata.h"
+#include "cbdata.h"
 
-/// \ingroup POD
 template <class C>
 class CbDataList
 {
+    CBDATA_CLASS(CbDataList);
 
 public:
-    CbDataList (C const &);
+    CbDataList(C const &);
     ~CbDataList();
 
     /// If element is already in the list, returns false.
@@ -32,12 +31,8 @@ class CbDataList
     CbDataList *next;
     C element;
     bool empty() const { return this == NULL; }
-
-private:
-    CBDATA_CLASS2(CbDataList);
 };
 
-/// \ingroup POD
 template<class C>
 class CbDataListContainer
 {
@@ -52,7 +47,6 @@ class CbDataListContainer
     CbDataList<C> *head;
 };
 
-/// \ingroup POD
 template<class C>
 class CbDataListIterator
 {
@@ -72,8 +66,6 @@ class CbDataListIterator
     CbDataList<C> *next_entry;
 };
 
-/* implementation follows */
-
 /** \cond AUTODOCS_IGNORE */
 template <class C>
 cbdata_type CbDataList<C>::CBDATA_CbDataList = CBDATA_UNKNOWN;
@@ -203,4 +195,4 @@ CbDataListContainer<C>::empty() const
     return head == NULL;
 }
 
-#endif /* SQUID_LIST_H */
+#endif /* SQUID_CBDATALIST_H */
@@ -19,18 +19,19 @@ libbase_la_SOURCES = \
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
+	CbcPointer.h \
+	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
-	TidyPointer.h \
-	CbcPointer.h \
 	InstanceId.h \
 	Lock.h \
 	LruMap.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
-	TextException.h
+	TextException.h \
+	TidyPointer.h
 
 EXTRA_PROGRAMS = \
 	testCharacterSet
@@ -63,6 +63,14 @@ class CBDataCall
 /// \ingroup CBDATAInternal
 class cbdata
 {
+#if !HASHED_CBDATA
+public:
+    void *operator new(size_t size, void *where);
+    void operator delete(void *where, void *where2);
+#else
+    MEMPROXY_CLASS(cbdata);
+#endif
+
     /** \todo examine making cbdata templated on this - so we get type
      * safe access to data - RBC 20030902 */
 public:
@@ -75,13 +83,6 @@ class cbdata
     void dump(StoreEntry *)const;
 #endif
 
-#if !HASHED_CBDATA
-    void *operator new(size_t size, void *where);
-    void operator delete(void *where, void *where2);
-#else
-    MEMPROXY_CLASS(cndata);
-#endif
-
     ~cbdata();
     int valid;
     int32_t locks;
@@ -145,8 +146,6 @@ cbdata::MakeOffset()
     void **dataOffset = &zero->data;
     return (long)dataOffset;
 }
-#else
-MEMPROXY_CLASS_INLINE(cbdata);
 #endif
 
 static OBJH cbdataDump;
@@ -260,11 +259,7 @@ cbdataRegisterWithCacheManager(void)
 }
 
 void *
-#if USE_CBDATA_DEBUG
-cbdataInternalAllocDbg(cbdata_type type, const char *file, int line)
-#else
-cbdataInternalAlloc(cbdata_type type)
-#endif
+cbdataInternalAlloc(cbdata_type type, const char *file, int line)
 {
     cbdata *c;
     void *p;
@@ -303,11 +298,7 @@ cbdataInternalAlloc(cbdata_type type)
 }
 
 void *
-#if USE_CBDATA_DEBUG
-cbdataInternalFreeDbg(void *p, const char *file, int line)
-#else
-cbdataInternalFree(void *p)
-#endif
+cbdataInternalFree(void *p, const char *file, int line)
 {
     cbdata *c;
 #if HASHED_CBDATA
@@ -434,8 +425,15 @@ cbdataInternalUnlock(const void *p)
 
     -- c->locks;
 
-    if (c->valid || c->locks)
+    if (c->locks)
+        return;
+
+    if (c->valid) {
+#if USE_CBDATA_DEBUG
+        debugs(45, DBG_IMPORTANT, "CBDATA memory leak. cbdata=" << p << " " << file << ":" << line);
+#endif
         return;
+    }
 
     --cbdataCount;
 
@@ -26,7 +26,6 @@
  *      possible. It is not suitable or intended as a generic RefCount
  *      memory allocator.
  *
- \todo CODE: make cbdata a template or class-inheritance system instead of Macros.
  *
  \section Examples Examples
  \par
@@ -159,44 +158,11 @@
  *
  \par
  *	To add new module specific data types to the allocator one uses the
- *	macros CBDATA_TYPE() and CBDATA_INIT_TYPE(). These creates a local cbdata
- *	definition (file or block scope). Any cbdataAlloc() calls must be made
- *	within this scope. However, cbdataFree() might be called from anywhere.
- *
- \par
- *	First the cbdata type needs to be defined in the module. This
- *	is usually done at file scope, but it can also be local to a
- *	function or block..
- \code
-	CBDATA_TYPE(type_of_data);
- \endcode
- *	Then in the code somewhere before the first allocation
- *	(can be called multiple times with only a minimal overhead)
- \code
-	CBDATA_INIT_TYPE(type_of_data);
- \endcode
- *	Or if a free function is associated with the data type. This
- *	function is responsible for cleaning up any dependencies etc
- *	referenced by the structure and is called on cbdataFree() or
- *	when the last reference is deleted by cbdataReferenceDone() /
- *	cbdataReferenceValidDone()
- \code
-	CBDATA_INIT_TYPE_FREECB(type_of_data, free_function);
- \endcode
- *
- \subsection AddingGlobalCBDATATypes Adding a new cbdata registered data type globally
- *
- \par
- *	To add new global data types that can be allocated from anywhere
- *	within the code one have to add them to the cbdata_type enum in
- *	enums.h, and a corresponding CREATE_CBDATA() call in
- *	cbdata.c:cbdataInit(). Or alternatively add a CBDATA_GLOBAL_TYPE()
- *	definition to globals.h as shown below and use CBDATA_INIT_TYPE() at
- *	the appropriate location(s) as described above.
- *
- \code
-	extern CBDATA_GLOBAL_TYPE(type_of_data);	// CBDATA_UNDEF
- \endcode
+ *	macro CBDATA_CLASS() in the class private section, and CBDATA_CLASS_INIT()
+ *      or CBDATA_NAMESPACED_CLASS_INIT() in the .cc file.
+ *      This creates new(), delete() and toCbdata() methods
+ *	definition in class scope. Any allocate calls must be made with
+ *      new() and destruction with delete(), they may be called from anywhere.
  */
 
 /**
@@ -211,86 +177,41 @@ static const cbdata_type CBDATA_UNKNOWN = 0;
 /// \ingroup CBDATAAPI
 void cbdataRegisterWithCacheManager(void);
 
-#if USE_CBDATA_DEBUG
-void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
-void *cbdataInternalFreeDbg(void *p, const char *, int);
-void cbdataInternalLockDbg(const void *p, const char *, int);
-void cbdataInternalUnlockDbg(const void *p, const char *, int);
-int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
-#else
-
-/// \ingroup CBDATAAPI
-void *cbdataInternalAlloc(cbdata_type type);
-
-/// \ingroup CBDATAAPI
-void *cbdataInternalFree(void *p);
-
-/// \ingroup CBDATAAPI
-void cbdataInternalLock(const void *p);
-
-/// \ingroup CBDATAAPI
-void cbdataInternalUnlock(const void *p);
-
-/// \ingroup CBDATAAPI
-int cbdataInternalReferenceDoneValid(void **p, void **tp);
-
-#endif /* !CBDATA_DEBUG */
-
-/**
- \ingroup CBDATAAPI
- *
- \param p	A cbdata entry reference pointer.
- *
- \retval 0	A reference is stale. The pointer refers to a entry freed by cbdataFree().
- \retval true	The reference is valid and active.
- */
-int cbdataReferenceValid(const void *p);
-
-/// \ingroup CBDATAAPI
-cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
-
-/* cbdata macros */
-#if USE_CBDATA_DEBUG
-#define cbdataAlloc(type)	((type *)cbdataInternalAllocDbg(CBDATA_##type,__FILE__,__LINE__))
-#define cbdataFree(var)		do {if (var) {cbdataInternalFreeDbg(var,__FILE__,__LINE__); var = NULL;}} while(0)
-#define cbdataInternalLock(a)		cbdataInternalLockDbg(a,__FILE__,__LINE__)
-#define cbdataInternalUnlock(a)		cbdataInternalUnlockDbg(a,__FILE__,__LINE__)
-#define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValidDbg((void **)&(var), (ptr), __FILE__,__LINE__)
-#define CBDATA_CLASS2(type)	\
-	private: \
-	static cbdata_type CBDATA_##type; \
-	public: \
-		void *operator new(size_t size) { \
-		  assert(size == sizeof(type)); \
-		  if (!CBDATA_##type) \
-                      CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), NULL); \
-		  return cbdataInternalAllocDbg(CBDATA_##type,__FILE__,__LINE__); \
-		} \
-  		void operator delete (void *address) { \
-		  if (address) cbdataInternalFreeDbg(address,__FILE__,__LINE__); \
-		} \
-                void *toCbdata() { return this; }
-#else /* USE_CBDATA_DEBUG */
-
 /**
- \ingroup CBDATAAPI
  * Allocates a new entry of a registered CBDATA type.
+ * \deprecated use CBDATA_CLASS() instead
  */
-#define cbdataAlloc(type) ((type *)cbdataInternalAlloc(CBDATA_##type))
+void *cbdataInternalAlloc(cbdata_type type, const char *, int);
+/// \deprecated use CBDATA_CLASS() instead
+#define cbdataAlloc(type) ((type *)cbdataInternalAlloc(CBDATA_##type,__FILE__,__LINE__))
 
 /**
- \ingroup CBDATAAPI
- \par
- *    Frees a entry allocated by cbdataAlloc().
+ * Frees a entry allocated by cbdataAlloc().
  *
  \note  If there are active references to the entry then the entry
  *      will be freed with the last reference is removed. However,
  *      cbdataReferenceValid() will return false for those references.
+ * \deprecated use CBDATA_CLASS() instead
  */
-#define cbdataFree(var)		do {if (var) {cbdataInternalFree(var); var = NULL;}} while(0)
+void *cbdataInternalFree(void *p, const char *, int);
+/// \deprecated use CBDATA_CLASS() instead
+#define cbdataFree(var)		do {if (var) {cbdataInternalFree(var,__FILE__,__LINE__); var = NULL;}} while(0)
+
+#if USE_CBDATA_DEBUG
+void cbdataInternalLockDbg(const void *p, const char *, int);
+#define cbdataInternalLock(a)		cbdataInternalLockDbg(a,__FILE__,__LINE__)
+
+void cbdataInternalUnlockDbg(const void *p, const char *, int);
+#define cbdataInternalUnlock(a)		cbdataInternalUnlockDbg(a,__FILE__,__LINE__)
+
+int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
+#define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValidDbg((void **)&(var), (ptr), __FILE__,__LINE__)
+
+#else
+void cbdataInternalLock(const void *p);
+void cbdataInternalUnlock(const void *p);
 
 /**
- \ingroup CBDATAAPI
  * Removes a reference created by cbdataReference() and checks
  * it for validity. Meant to be used on the last dereference,
  * usually to make a callback.
@@ -305,31 +226,42 @@ cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size,
  \param var	The reference variable. Will be automatically cleared to NULL.
  \param ptr	A temporary pointer to the referenced data (if valid).
  */
+int cbdataInternalReferenceDoneValid(void **p, void **tp);
 #define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValid((void **)&(var), (ptr))
 
+#endif /* !CBDATA_DEBUG */
+
 /**
- * \ingroup CBDATAAPI
+ * \param p	A cbdata entry reference pointer.
  *
- * This needs to be defined LAST in the class definition. It plays with private/public states in C++.
+ * \retval 0	A reference is stale. The pointer refers to a entry freed by cbdataFree().
+ * \retval true	The reference is valid and active.
  */
-#define CBDATA_CLASS2(type)	\
-	private: \
-	static cbdata_type CBDATA_##type; \
+int cbdataReferenceValid(const void *p);
+
+/// \ingroup CBDATAAPI
+cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
+
+/**
+ * This needs to be defined FIRST in the class definition.
+ * It plays with private/public states in C++.
+ */
+#define CBDATA_CLASS(type)	\
 	public: \
 		void *operator new(size_t size) { \
 		  assert(size == sizeof(type)); \
 		  if (!CBDATA_##type) \
                       CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), NULL); \
-		  return (type *)cbdataInternalAlloc(CBDATA_##type); \
+		  return (type *)cbdataInternalAlloc(CBDATA_##type,__FILE__,__LINE__); \
 		} \
   		void operator delete (void *address) { \
-		  if (address) cbdataInternalFree(address);\
+		  if (address) cbdataInternalFree(address,__FILE__,__LINE__);\
 		} \
-                void *toCbdata() { return this; }
-#endif /* !CBDATA_DEBUG */
+                void *toCbdata() { return this; } \
+	private: \
+	static cbdata_type CBDATA_##type;
 
 /**
- \ingroup CBDATAAPI
  \par
  *    Creates a new reference to a cbdata entry. Used when you need to
  *    store a reference in another structure. The reference can later
@@ -356,33 +288,16 @@ cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size,
 #define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
- \ingroup CBDATAAPI
  * Macro that defines a new cbdata datatype. Similar to a variable
  * or struct definition. Scope is always local to the file/block
  * where it is defined and all calls to cbdataAlloc() for this type
  * must be within the same scope as the CBDATA_TYPE declaration.
  * Allocated entries may be referenced or freed anywhere with no
  * restrictions on scope.
+ * \deprecated Use CBDATA_CLASS() instead
  */
 #define CBDATA_TYPE(type)	static cbdata_type CBDATA_##type = CBDATA_UNKNOWN
 
-/**
- \ingroup CBDATAAPI
- * Defines a global cbdata type that can be referenced anywhere in the code.
- *
- \code
-        external CBDATA_GLOBAL_TYPE(datatype);
- \endcode
- * Should be added to the module *.h header file.
- *
- \code
-        CBDATA_GLOBAL_TYPE(datatype);
- \endcode
- *
- *  Should be added to the module main *.cc file.
- */
-#define CBDATA_GLOBAL_TYPE(type)	cbdata_type CBDATA_##type
-
 /**
  \ingroup CBDATAAPI
  *
@@ -397,14 +312,14 @@ cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size,
 #define CBDATA_INIT_TYPE_FREECB(type, free_func) do { if (!CBDATA_##type) CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), free_func); } while (false)
 
 /**
- \ingroup CBDATAAPI
- *
  * Initializes the cbdatatype. Must be called prior to the first use of cbdataAlloc() for the type.
  *
  \par
  * Alternative to CBDATA_INIT_TYPE_FREECB()
  *
  \param type		Type being initialized
+ *
+ * \deprecated Use CBDATA_CLASS() instead
  */
 #define CBDATA_INIT_TYPE(type)	CBDATA_INIT_TYPE_FREECB(type, NULL)
 
@@ -417,6 +332,8 @@ cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size,
  */
 class generic_cbdata
 {
+    CBDATA_CLASS(generic_cbdata);
+
 public:
 
     generic_cbdata(void * aData) : data(aData) {}
@@ -434,9 +351,6 @@ class generic_cbdata
      \todo CODE: make this a private field.
      */
     void *data; /* the wrapped data */
-
-private:
-    CBDATA_CLASS2(generic_cbdata);
 };
 
 #endif /* SQUID_CBDATA_H */
@@ -3988,7 +3988,7 @@ DOC_START
 		[http::]>rs	Request URL scheme from client
 		[http::]<rs	Request URL scheme sent to server or peer
 		[http::]>rd	Request URL domain from client
-		[http::]>rd	Request URL domain sent to server or peer
+		[http::]<rd	Request URL domain sent to server or peer
 		[http::]>rP	Request URL port from client
 		[http::]<rP	Request URL port sent to server or peer
 		[http::]rp	Request URL path excluding hostname
@@ -2077,9 +2077,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
         } // else nothing to alter port-wise.
         const int url_sz = hp->requestUri().length() + 32 + Config.appendDomainLen + strlen(host);
         http->uri = (char *)xcalloc(url_sz, 1);
-        const char *protocol = switchedToHttps ?
-                               "https" : AnyP::UriScheme(conn->port->transport.protocol).c_str();
-        snprintf(http->uri, url_sz, "%s://%s" SQUIDSBUFPH, protocol, host, SQUIDSBUFPRINT(url));
+        snprintf(http->uri, url_sz, "%s://%s" SQUIDSBUFPH, AnyP::UriScheme(conn->transferProtocol.protocol).c_str(), host, SQUIDSBUFPRINT(url));
         debugs(33, 5, "ACCEL VHOST REWRITE: " << http->uri);
     } else if (conn->port->defaultsite /* && !vhost */) {
         debugs(33, 5, "ACCEL DEFAULTSITE REWRITE: defaultsite=" << conn->port->defaultsite << " + vport=" << vport);
@@ -2092,7 +2090,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
             snprintf(vportStr, sizeof(vportStr),":%d",vport);
         }
         snprintf(http->uri, url_sz, "%s://%s%s" SQUIDSBUFPH,
-                 AnyP::UriScheme(conn->port->transport.protocol).c_str(), conn->port->defaultsite, vportStr, SQUIDSBUFPRINT(url));
+                 AnyP::UriScheme(conn->transferProtocol.protocol).c_str(), conn->port->defaultsite, vportStr, SQUIDSBUFPRINT(url));
         debugs(33, 5, "ACCEL DEFAULTSITE REWRITE: " << http->uri);
     } else if (vport > 0 /* && (!vhost || no Host:) */) {
         debugs(33, 5, "ACCEL VPORT REWRITE: *_port IP + vport=" << vport);
@@ -2101,7 +2099,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
         http->uri = (char *)xcalloc(url_sz, 1);
         http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d" SQUIDSBUFPH,
-                 AnyP::UriScheme(conn->port->transport.protocol).c_str(),
+                 AnyP::UriScheme(conn->transferProtocol.protocol).c_str(),
                  ipbuf, vport, SQUIDSBUFPRINT(url));
         debugs(33, 5, "ACCEL VPORT REWRITE: " << http->uri);
     }
@@ -2121,7 +2119,7 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
                      strlen(host);
         http->uri = (char *)xcalloc(url_sz, 1);
         snprintf(http->uri, url_sz, "%s://%s" SQUIDSBUFPH,
-             AnyP::UriScheme(conn->port->transport.protocol).c_str(), host, SQUIDSBUFPRINT(hp->requestUri()));
+             AnyP::UriScheme(conn->transferProtocol.protocol).c_str(), host, SQUIDSBUFPRINT(hp->requestUri()));
         debugs(33, 5, "TRANSPARENT HOST REWRITE: " << http->uri);
     } else {
         /* Put the local socket IP address as the hostname.  */
@@ -2130,7 +2128,7 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
         static char ipbuf[MAX_IPSTRLEN];
         http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d" SQUIDSBUFPH,
-                 AnyP::UriScheme(http->getConn()->port->transport.protocol).c_str(),
+                 AnyP::UriScheme(http->getConn()->transferProtocol.protocol).c_str(),
                  ipbuf, http->getConn()->clientConnection->local.port(), SQUIDSBUFPRINT(hp->requestUri()));
         debugs(33, 5, "TRANSPARENT REWRITE: " << http->uri);
     }
@@ -2181,7 +2179,7 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
 
     /* deny CONNECT via accelerated ports */
     if (hp->method() == Http::METHOD_CONNECT && csd->port != NULL && csd->port->flags.accelSurrogate) {
-        debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->transport.protocol << " Accelerator port " << csd->port->s.port());
+        debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->transferProtocol << " Accelerator port " << csd->port->s.port());
         debugs(33, DBG_IMPORTANT, "WARNING: for request: " << hp->method() << " " << hp->requestUri() << " " << hp->messageProtocol());
         hp->request_parse_status = Http::scMethodNotAllowed;
         return csd->abortRequestParsing("error:method-not-allowed");
@@ -2625,9 +2623,6 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
                    ':' << request->port << " (not this proxy)");
     }
 
-    if (http->flags.internal)
-        request->login[0] = '\0';
-
     request->flags.internal = http->flags.internal;
     setLogUri (http, urlCanonicalClean(request.getRaw()));
     request->client_addr = conn->clientConnection->remote; // XXX: remove reuest->client_addr member.
@@ -3428,6 +3423,7 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
     // store the details required for creating more MasterXaction objects as new requests come in
     clientConnection = xact->tcpClient;
     port = xact->squidPort;
+    transferProtocol = port->transport; // default to the *_port protocol= setting. may change later.
     log_addr = xact->tcpClient->remote;
     log_addr.applyMask(Config.Addrs.client_netmask);
 }
@@ -4121,6 +4117,10 @@ ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode)
     flags.readMore = true;
     debugs(33, 5, HERE << "converting " << clientConnection << " to SSL");
 
+    // keep version major.minor details the same.
+    // but we are now performing the HTTPS handshake traffic
+    transferProtocol.protocol = AnyP::PROTO_HTTPS;
+
     // If sslServerBump is set, then we have decided to deny CONNECT
     // and now want to switch to SSL to send the error to the client
     // without even peeking at the origin server certificate.
@@ -4234,6 +4234,9 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
         fd_table[connState->clientConnection->fd].write_method = &default_write_method;
 
         if (connState->transparent()) {
+            // set the current protocol to something sensible (was "HTTPS" for the bumping process)
+            // we are sending a faked-up HTTP/1.1 message wrapper, so go with that.
+            connState->transferProtocol = Http::ProtocolVersion();
             // fake a CONNECT request to force connState to tunnel
             static char ip[MAX_IPSTRLEN];
             connState->clientConnection->local.toUrl(ip, sizeof(ip));
@@ -4247,6 +4250,10 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
                 connState->clientConnection->close();
             }
         } else {
+            // XXX: assuming that there was an HTTP/1.1 CONNECT to begin with...
+
+            // reset the current protocol to HTTP/1.1 (was "HTTPS" for the bumping process)
+            connState->transferProtocol = Http::ProtocolVersion();
             // in.buf still has the "CONNECT ..." request data, reset it to SSL hello message
             connState->in.buf.append(rbuf.content(), rbuf.contentSize());
             ClientSocketContext::Pointer context = connState->getCurrentContext();
@@ -67,6 +67,7 @@ class PortCfg;
  */
 class ClientSocketContext : public RefCountable
 {
+    CBDATA_CLASS(ClientSocketContext);
 
 public:
     typedef RefCount<ClientSocketContext> Pointer;
@@ -144,8 +145,6 @@ class ClientSocketContext : public RefCountable
 
     bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
     bool connRegistered_;
-
-    CBDATA_CLASS2(ClientSocketContext);
 };
 
 class ConnectionDetail;
@@ -194,6 +193,13 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     // Client TCP connection details from comm layer.
     Comm::ConnectionPointer clientConnection;
 
+    /**
+     * The transfer protocol currently being spoken on this connection.
+     * HTTP/1 CONNECT and HTTP/2 SETTINGS offers the ability to change
+     * protocols on the fly.
+     */
+    AnyP::ProtocolVersion transferProtocol;
+
     struct In {
         In();
         ~In();
@@ -21,6 +21,7 @@ class ErrorState;
 
 class clientReplyContext : public RefCountable, public StoreClient
 {
+    CBDATA_CLASS(clientReplyContext);
 
 public:
     static STCB CacheHit;
@@ -132,8 +133,6 @@ class clientReplyContext : public RefCountable, public StoreClient
     StoreEntry *old_entry;
     store_client *old_sc;	/* ... for entry to be validated */
     bool deleting;
-
-    CBDATA_CLASS2(clientReplyContext);
 };
 
 #endif /* SQUID_CLIENTSIDEREPLY_H */
@@ -1129,7 +1129,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 
     clientCheckPinning(http);
 
-    if (request->login[0] != '\0')
+    if (!request->url.userInfo().isEmpty())
         request->flags.auth = true;
 
     if (req_hdr->has(HDR_VIA)) {
@@ -35,6 +35,7 @@ class ClientHttpRequest
         public BodyConsumer     // to receive reply bodies in request satisf. mode
 #endif
 {
+    CBDATA_CLASS(ClientHttpRequest);
 
 public:
     ClientHttpRequest(ConnStateData *csd);
@@ -167,9 +168,6 @@ class ClientHttpRequest
     bool request_satisfaction_mode;
     int64_t request_satisfaction_offset;
 #endif
-
-private:
-    CBDATA_CLASS2(ClientHttpRequest);
 };
 
 /* client http based routines */
@@ -91,6 +91,8 @@ class DataChannel: public Ftp::Channel
 /// FTP client functionality shared among FTP Gateway and Relay clients.
 class Client: public ::Client
 {
+    CBDATA_CLASS(Client);
+
 public:
     explicit Client(FwdState *fwdState);
     virtual ~Client();
@@ -189,8 +191,6 @@ class Client: public ::Client
     /// XXX: An old hack for FTP servers like ftp.netscape.com that may not
     /// respond to PASV. Use faster connect timeout instead of read timeout.
     bool shortenReadTimeout;
-
-    CBDATA_CLASS2(Client);
 };
 
 } // namespace Ftp
@@ -92,6 +92,8 @@ typedef void (StateMethod)(Ftp::Gateway *);
 /// converts one or more FTP responses into the final HTTP response.
 class Gateway : public Ftp::Client
 {
+    CBDATA_CLASS(Gateway);
+
 public:
     Gateway(FwdState *);
     virtual ~Gateway();
@@ -124,7 +126,6 @@ class Gateway : public Ftp::Client
     // these should all be private
     virtual void start();
     virtual Http::StatusCode failedHttpStatus(err_type &error);
-    void loginParser(const char *, int escaped);
     int restartable();
     void appendSuccessHeader();
     void hackShortcut(StateMethod *nextState);
@@ -170,7 +171,7 @@ class Gateway : public Ftp::Client
     // BodyConsumer for HTTP: consume request body.
     virtual void handleRequestBodyProducerAborted();
 
-    CBDATA_CLASS2(Gateway);
+    void loginParser(const SBuf &login, bool escaped);
 };
 
 } // namespace Ftp
@@ -188,10 +189,6 @@ typedef struct {
     char *link;
 } ftpListParts;
 
-#define FTP_LOGIN_ESCAPED	1
-
-#define FTP_LOGIN_NOT_ESCAPED	0
-
 #define CTRL_BUFLEN 1024
 static char cbuf[CTRL_BUFLEN];
 
@@ -393,58 +390,54 @@ Ftp::Gateway::~Gateway()
 /**
  * Parse a possible login username:password pair.
  * Produces filled member variables user, password, password_url if anything found.
+ *
+ * \param login    a decoded Basic authentication credential token or URI user-info token
+ * \param escaped  whether to URL-decode the token after extracting user and password
  */
 void
-Ftp::Gateway::loginParser(const char *login, int escaped)
+Ftp::Gateway::loginParser(const SBuf &login, bool escaped)
 {
-    const char *u = NULL; // end of the username sub-string
-    int len;              // length of the current sub-string to handle.
+    debugs(9, 4, "login=" << login << ", escaped=" << escaped);
+    debugs(9, 9, "IN : login=" << login << ", escaped=" << escaped << ", user=" << user << ", password=" << password);
 
-    int total_len = strlen(login);
-
-    debugs(9, 4, HERE << ": login='" << login << "', escaped=" << escaped);
-    debugs(9, 9, HERE << ": IN : login='" << login << "', escaped=" << escaped << ", user=" << user << ", password=" << password);
-
-    if ((u = strchr(login, ':'))) {
+    if (login.isEmpty())
+        return;
 
-        /* if there was a username part */
-        if (u > login) {
-            len = u - login;
-            ++u; // jump off the delimiter.
-            if (len > MAX_URL)
-                len = MAX_URL-1;
-            xstrncpy(user, login, len +1);
-            debugs(9, 9, HERE << ": found user='" << user << "'(" << len <<"), escaped=" << escaped);
-            if (escaped)
-                rfc1738_unescape(user);
-            debugs(9, 9, HERE << ": found user='" << user << "'(" << len <<") unescaped.");
-        }
+    const SBuf::size_type colonPos = login.find(':');
 
-        /* if there was a password part */
-        len = login + total_len - u;
-        if ( len > 0) {
-            if (len > MAX_URL)
-                len = MAX_URL -1;
-            xstrncpy(password, u, len +1);
-            debugs(9, 9, HERE << ": found password='" << password << "'(" << len <<"), escaped=" << escaped);
-            if (escaped) {
-                rfc1738_unescape(password);
-                password_url = 1;
-            }
-            debugs(9, 9, HERE << ": found password='" << password << "'(" << len <<") unescaped.");
-        }
-    } else if (login[0]) {
-        /* no password, just username */
-        if (total_len > MAX_URL)
-            total_len = MAX_URL -1;
-        xstrncpy(user, login, total_len +1);
-        debugs(9, 9, HERE << ": found user='" << user << "'(" << total_len <<"), escaped=" << escaped);
+    /* If there was a username part with at least one character use it.
+     * Ignore 0-length username portion, retain what we have already.
+     */
+    if (colonPos == SBuf::npos || colonPos > 0) {
+        const SBuf userName = login.substr(0, colonPos);
+        SBuf::size_type upto = userName.copy(user, sizeof(user)-1);
+        user[upto]='\0';
+        debugs(9, 9, "found user=" << userName << ' ' <<
+               (upto != userName.length() ? ", truncated-to=" : ", length=") << upto <<
+               ", escaped=" << escaped);
         if (escaped)
             rfc1738_unescape(user);
-        debugs(9, 9, HERE << ": found user='" << user << "'(" << total_len <<") unescaped.");
+        debugs(9, 9, "found user=" << user << " (" << strlen(user) << ") unescaped.");
+    }
+
+    /* If there was a password part.
+     * For 0-length password clobber what we have already, this means explicitly none
+     */
+    if (colonPos != SBuf::npos) {
+        const SBuf pass = login.substr(colonPos+1, SBuf::npos);
+        SBuf::size_type upto = pass.copy(password, sizeof(password)-1);
+        password[upto]='\0';
+        debugs(9, 9, "found password=" << pass << " " <<
+               (upto != pass.length() ? ", truncated-to=" : ", length=") << upto <<
+               ", escaped=" << escaped);
+        if (escaped) {
+            rfc1738_unescape(password);
+            password_url = 1;
+        }
+        debugs(9, 9, "found password=" << password << " (" << strlen(password) << ") unescaped.");
     }
 
-    debugs(9, 9, HERE << ": OUT: login='" << login << "', escaped=" << escaped << ", user=" << user << ", password=" << password);
+    debugs(9, 9, "OUT: login=" << login << ", escaped=" << escaped << ", user=" << user << ", password=" << password);
 }
 
 void
@@ -1052,16 +1045,16 @@ Ftp::Gateway::checkAuth(const HttpHeader * req_hdr)
 
 #if HAVE_AUTH_MODULE_BASIC
     /* Check HTTP Authorization: headers (better than defaults, but less than URL) */
-    const char *auth;
-    if ( (auth = req_hdr->getAuth(HDR_AUTHORIZATION, "Basic")) ) {
+    const SBuf auth(req_hdr->getAuth(HDR_AUTHORIZATION, "Basic"));
+    if (!auth.isEmpty()) {
         flags.authenticated = 1;
-        loginParser(auth, FTP_LOGIN_NOT_ESCAPED);
+        loginParser(auth, false);
     }
     /* we fail with authorization-required error later IFF the FTP server requests it */
 #endif
 
     /* Test URL login syntax. Overrides any headers received. */
-    loginParser(request->login, FTP_LOGIN_ESCAPED);
+    loginParser(request->url.userInfo(), true);
 
     /* name is missing. thats fatal. */
     if (!user[0])
@@ -31,6 +31,8 @@ namespace Ftp
 /// and then relaying FTP replies back to our FTP server.
 class Relay: public Ftp::Client
 {
+    CBDATA_CLASS(Relay);
+
 public:
     explicit Relay(FwdState *const fwdState);
     virtual ~Relay();
@@ -95,8 +97,6 @@ class Relay: public Ftp::Client
         char *lastReply; ///< last line of reply: reply status plus message
         int replyCode; ///< the reply status
     } savedReply; ///< set and delayed while we are tracking using PWD
-
-    CBDATA_CLASS2(Relay);
 };
 
 } // namespace Ftp
@@ -24,6 +24,8 @@ namespace Comm
  */
 class ConnOpener : public AsyncJob
 {
+    CBDATA_CLASS(ConnOpener);
+
 protected:
     virtual void start();
     virtual void swanSong();
@@ -85,8 +87,6 @@ class ConnOpener : public AsyncJob
         /// [that we can cancel], but it will probably become one eventually.
         bool sleep_;
     } calls_;
-
-    CBDATA_CLASS2(ConnOpener);
 };
 
 }; // namespace Comm
@@ -59,9 +59,9 @@ namespace Comm
  */
 class Connection : public RefCountable
 {
-public:
     MEMPROXY_CLASS(Comm::Connection);
 
+public:
     Connection();
 
     /** Clear the connection properties and close any open socket. */
@@ -144,8 +144,6 @@ class Connection : public RefCountable
 
 }; // namespace Comm
 
-MEMPROXY_CLASS_INLINE(Comm::Connection);
-
 // NP: Order and namespace here is very important.
 //     * The second define inlines the first.
 //     * Stream inheritance overloading is searched in the global scope first.
@@ -37,6 +37,8 @@ class AcceptLimiter;
  */
 class TcpAcceptor : public AsyncJob
 {
+    CBDATA_CLASS(TcpAcceptor);
+
 public:
     typedef CbcPointer<Comm::TcpAcceptor> Pointer;
 
@@ -102,8 +104,6 @@ class TcpAcceptor : public AsyncJob
     Comm::Flag oldAccept(Comm::ConnectionPointer &details);
     void setListen();
     void handleClosure(const CommCloseCbParams &io);
-
-    CBDATA_CLASS2(TcpAcceptor);
 };
 
 } // namespace Comm
@@ -73,6 +73,8 @@ class MemBuf;
 /// \ingroup ErrorPageAPI
 class ErrorState
 {
+    CBDATA_CLASS(ErrorState);
+
 public:
     ErrorState(err_type type, Http::StatusCode, HttpRequest * request);
     ErrorState(); // not implemented.
@@ -166,8 +168,6 @@ class ErrorState
     /// type-specific detail about the transaction error;
     /// overwrites xerrno; overwritten by detail, if any.
     int detailCode;
-private:
-    CBDATA_CLASS2(ErrorState);
 };
 
 /**
@@ -15,12 +15,9 @@
 #include "esi/VarState.h"
 #include "SquidString.h"
 
-/* ESIVariableExpression */
-/* This is a variable that is itself and expression */
-
+/** This is a variable that is itself an expression */
 class ESIVariableExpression : public ESIVarState::Variable
 {
-
 public:
     ~ESIVariableExpression();
     ESIVariableExpression (String const &value);
@@ -30,15 +27,13 @@ class ESIVariableExpression : public ESIVarState::Variable
     String expression;
 };
 
-/* ESIAssign */
-
 class ESIContext;
 
 class ESIAssign : public ESIElement
 {
+    MEMPROXY_CLASS(ESIAssign);
 
 public:
-    MEMPROXY_CLASS(ESIAssign);
     ESIAssign (esiTreeParentPtr, int, const char **, ESIContext *);
     ESIAssign (ESIAssign const &);
     ESIAssign &operator=(ESIAssign const &);
@@ -61,6 +56,4 @@ class ESIAssign : public ESIElement
     String unevaluatedVariable;
 };
 
-MEMPROXY_CLASS_INLINE(ESIAssign);
-
 #endif /* SQUID_ESIASSIGN_H */
@@ -22,6 +22,7 @@ class ClientHttpRequest;
 
 class ESIContext : public esiTreeParent, public ESIParserClient
 {
+    CBDATA_CLASS(ESIContext);
 
 public:
     typedef RefCount<ESIContext> Pointer;
@@ -155,8 +156,6 @@ class ESIContext : public esiTreeParent, public ESIParserClient
     virtual void parserDefault (const char *s, int len);
     virtual void parserComment (const char *s);
     bool processing;
-
-    CBDATA_CLASS2(ESIContext);
 };
 
 #endif /* SQUID_ESICONTEXT_H */
@@ -81,10 +81,11 @@ typedef ESIContext::esiKick_t esiKick_t;
 
 /* some core operators */
 
-/* esiComment */
-
-struct esiComment : public ESIElement {
+class esiComment : public ESIElement
+{
     MEMPROXY_CLASS(esiComment);
+
+public:
     ~esiComment();
     esiComment();
     Pointer makeCacheable() const;
@@ -94,8 +95,6 @@ struct esiComment : public ESIElement {
     void finish();
 };
 
-MEMPROXY_CLASS_INLINE(esiComment);
-
 #include "esi/Literal.h"
 
 #include "esi/Sequence.h"
@@ -123,11 +122,11 @@ CBDATA_TYPE (esiRemove);
 static FREE esiRemoveFree;
 static ESIElement * esiRemoveNew(void);
 
-/* esiTry */
-
-struct esiTry : public ESIElement {
+class esiTry : public ESIElement
+{
     MEMPROXY_CLASS(esiTry);
 
+public:
     esiTry(esiTreeParentPtr aParent);
     ~esiTry();
 
@@ -158,15 +157,13 @@ struct esiTry : public ESIElement {
     esiProcessResult_t bestAttemptRV() const;
 };
 
-MEMPROXY_CLASS_INLINE(esiTry);
-
 #include "esi/Var.h"
 
-/* esiChoose */
-
-struct esiChoose : public ESIElement {
+class esiChoose : public ESIElement
+{
     MEMPROXY_CLASS(esiChoose);
 
+public:
     esiChoose(esiTreeParentPtr);
     ~esiChoose();
 
@@ -194,12 +191,11 @@ struct esiChoose : public ESIElement {
     void selectElement();
 };
 
-MEMPROXY_CLASS_INLINE(esiChoose);
-
-/* esiWhen */
-
-struct esiWhen : public esiSequence {
+class esiWhen : public esiSequence
+{
     MEMPROXY_CLASS(esiWhen);
+
+public:
     esiWhen(esiTreeParentPtr aParent, int attributes, const char **attr, ESIVarState *);
     ~esiWhen();
     Pointer makeCacheable() const;
@@ -217,10 +213,6 @@ struct esiWhen : public esiSequence {
     void evaluate();
 };
 
-MEMPROXY_CLASS_INLINE(esiWhen);
-
-/* esiOtherwise */
-
 struct esiOtherwise : public esiSequence {
     //    void *operator new (size_t byteCount);
     //    void operator delete (void *address);
@@ -20,6 +20,7 @@ typedef RefCount<ESIInclude> ESIIncludePtr;
 
 class ESIStreamContext : public RefCountable
 {
+    CBDATA_CLASS(ESIStreamContext);
 
 public:
     typedef RefCount<ESIStreamContext> Pointer;
@@ -30,19 +31,13 @@ class ESIStreamContext : public RefCountable
     ESIIncludePtr include;
     ESISegment::Pointer localbuffer;
     ESISegment::Pointer buffer;
-
-private:
-    CBDATA_CLASS2(ESIStreamContext);
 };
 
-/* ESIInclude */
-
 class ESIInclude : public ESIElement
 {
-
-public:
     MEMPROXY_CLASS(ESIInclude);
 
+public:
     ESIInclude(esiTreeParentPtr, int attributes, const char **attr, ESIContext *);
     ~ESIInclude();
     void render(ESISegment::Pointer);
@@ -76,6 +71,4 @@ class ESIInclude : public ESIElement
     void prepareRequestHeaders(HttpHeader &tempheaders, ESIVarState *vars);
 };
 
-MEMPROXY_CLASS_INLINE(ESIInclude);
-
 #endif /* SQUID_ESIINCLUDE_H */
@@ -14,11 +14,12 @@
 #include "esi/Element.h"
 
 class ESIContext;
-/* esiLiteral */
 
-struct esiLiteral : public ESIElement {
+class esiLiteral : public ESIElement
+{
     MEMPROXY_CLASS(esiLiteral);
 
+public:
     esiLiteral(ESISegment::Pointer);
     esiLiteral(ESIContext *, const char *s, int len);
     ~esiLiteral();
@@ -41,6 +42,4 @@ struct esiLiteral : public ESIElement {
     esiLiteral(esiLiteral const &);
 };
 
-MEMPROXY_CLASS_INLINE(esiLiteral);
-
 #endif /* SQUID_ESILITERAL_H */
@@ -19,10 +19,9 @@
 
 class esiSequence : public ESIElement
 {
-
-public:
     MEMPROXY_CLASS(esiSequence);
 
+public:
     esiSequence(esiTreeParentPtr, bool = false);
     ~esiSequence();
 
@@ -65,6 +64,4 @@ class esiSequence : public ESIElement
     void processStep(int dovars);
 };
 
-MEMPROXY_CLASS_INLINE(esiSequence);
-
 #endif /* SQUID_ESISEQUENCE_H */
@@ -27,11 +27,11 @@ int eventFind(EVH *, void *);
 
 class ev_entry
 {
+    MEMPROXY_CLASS(ev_entry);
 
 public:
     ev_entry(char const * name, EVH * func, void *arg, double when, int weight, bool cbdata=true);
     ~ev_entry();
-    MEMPROXY_CLASS(ev_entry);
     const char *name;
     EVH *func;
     void *arg;
@@ -43,8 +43,6 @@ class ev_entry
     ev_entry *next;
 };
 
-MEMPROXY_CLASS_INLINE(ev_entry);
-
 // manages time-based events
 class EventScheduler : public AsyncEngine
 {
@@ -68,9 +68,10 @@ static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const
 
 class external_acl_format : public RefCountable
 {
+    MEMPROXY_CLASS(external_acl_format);
+
 public:
     typedef RefCount<external_acl_format> Pointer;
-    MEMPROXY_CLASS(external_acl_format);
 
     external_acl_format() : type(Format::LFT_NONE), header(NULL), member(NULL), separator(' '), header_id(HDR_BAD_HDR) {}
     ~external_acl_format() {
@@ -86,8 +87,6 @@ class external_acl_format : public RefCountable
     http_hdr_type header_id;
 };
 
-MEMPROXY_CLASS_INLINE(external_acl_format);
-
 class external_acl
 {
 
@@ -18,20 +18,19 @@ class DiskFile;
 namespace Rock
 {
 
-/// \ingroup Rock
 class ReadRequest: public ::ReadRequest
 {
+    CBDATA_CLASS(ReadRequest);
+
 public:
     ReadRequest(const ::ReadRequest &base, const IoState::Pointer &anSio);
     IoState::Pointer sio;
-
-private:
-    CBDATA_CLASS2(ReadRequest);
 };
 
-/// \ingroup Rock
 class WriteRequest: public ::WriteRequest
 {
+    CBDATA_CLASS(WriteRequest);
+
 public:
     WriteRequest(const ::WriteRequest &base, const IoState::Pointer &anSio);
     IoState::Pointer sio;
@@ -44,9 +43,6 @@ class WriteRequest: public ::WriteRequest
 
     /// whether this is the last request for the entry
     bool eof;
-
-private:
-    CBDATA_CLASS2(WriteRequest);
 };
 
 } // namespace Rock
@@ -23,6 +23,8 @@ class SwapDir;
 /// \ingroup Rock
 class IoState: public ::StoreIOState
 {
+    MEMPROXY_CLASS(IoState);
+
 public:
     typedef RefCount<IoState> Pointer;
 
@@ -45,8 +47,6 @@ class IoState: public ::StoreIOState
     /// called by SwapDir::writeCompleted() after the last write and on error
     void finishedWriting(const int errFlag);
 
-    MEMPROXY_CLASS(IoState);
-
     /* one and only one of these will be set and locked; access via *Anchor() */
     const Ipc::StoreMapAnchor *readableAnchor_; ///< starting point for reading
     Ipc::StoreMapAnchor *writeableAnchor_; ///< starting point for writing
@@ -74,8 +74,6 @@ class IoState: public ::StoreIOState
     MemBlob theBuf; // use for write content accumulation only
 };
 
-MEMPROXY_CLASS_INLINE(IoState);
-
 } // namespace Rock
 
 #endif /* SQUID_FS_ROCK_IO_STATE_H */
@@ -24,6 +24,8 @@ class LoadingEntry;
 /// manages store rebuild process: loading meta information from db on disk
 class Rebuild: public AsyncJob
 {
+    CBDATA_CLASS(Rebuild);
+
 public:
     Rebuild(SwapDir *dir);
     ~Rebuild();
@@ -76,8 +78,6 @@ class Rebuild: public AsyncJob
     StoreRebuildData counts;
 
     static void Steps(void *data);
-
-    CBDATA_CLASS2(Rebuild);
 };
 
 } // namespace Rock
@@ -21,9 +21,10 @@ namespace Fs
 namespace Ufs
 {
 
-/// \ingroup UFS
 class RebuildState : public RefCountable
 {
+    CBDATA_CLASS(RebuildState);
+
 public:
     static EVH RebuildStep;
 
@@ -59,7 +60,6 @@ class RebuildState : public RefCountable
     StoreRebuildData counts;
 
 private:
-    CBDATA_CLASS2(RebuildState);
     void rebuildFromDirectory();
     void rebuildFromSwapLog();
     void rebuildStep();
@@ -17,9 +17,10 @@ namespace Fs
 namespace Ufs
 {
 
-/// \ingroup UFS
 class StoreSearchUFS : public StoreSearch
 {
+    CBDATA_CLASS(StoreSearchUFS);
+
 public:
     StoreSearchUFS(RefCount<UFSSwapDir> sd);
     virtual ~StoreSearchUFS();
@@ -45,7 +46,6 @@ class StoreSearchUFS : public StoreSearch
     RemovalPolicyWalker *walker;
 
 private:
-    CBDATA_CLASS2(StoreSearchUFS);
     /// \bug (callback) should be hidden behind a proper human readable name
     void (callback)(void *cbdata);
     void *cbdata;
@@ -17,9 +17,11 @@ namespace Fs
 {
 namespace Ufs
 {
-/// \ingroup UFS
+
 class UFSStoreState : public StoreIOState, public IORequestor
 {
+    CBDATA_CLASS(UFSStoreState);
+
 public:
     UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB * callback_, void *callback_data_);
     ~UFSStoreState();
@@ -44,8 +46,8 @@ class UFSStoreState : public StoreIOState, public IORequestor
 
     class _queued_read
     {
-    public:
         MEMPROXY_CLASS(UFSStoreState::_queued_read);
+    public:
         char *buf;
         size_t size;
         off_t offset;
@@ -56,8 +58,8 @@ class UFSStoreState : public StoreIOState, public IORequestor
 
     class _queued_write
     {
-    public:
         MEMPROXY_CLASS(UFSStoreState::_queued_write);
+    public:
         char const *buf;
         size_t size;
         off_t offset;
@@ -96,12 +98,8 @@ class UFSStoreState : public StoreIOState, public IORequestor
     void openDone();
     void freePending();
     void doWrite();
-    CBDATA_CLASS2(UFSStoreState);
 };
 
-MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_read);
-MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_write);
-
 } //namespace Ufs
 } //namespace Fs
 
@@ -34,75 +34,75 @@
 #include "MemObject.h"
 #endif
 
-/**
- \defgroup ServerProtocolGopherInternal Server-Side Gopher Internals
- \ingroup ServerProtocolGopherAPI
- * Gopher is somewhat complex and gross because it must convert from
- * the Gopher protocol to HTTP.
- */
-
 /* gopher type code from rfc. Anawat. */
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_FILE         '0'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_DIRECTORY    '1'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_CSO          '2'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_ERROR        '3'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_MACBINHEX    '4'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_DOSBIN       '5'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_UUENCODED    '6'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_INDEX        '7'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_TELNET       '8'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_BIN          '9'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_REDUNT       '+'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_3270         'T'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_GIF          'g'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_IMAGE        'I'
 
-/// \ingroup ServerProtocolGopherInternal
-#define GOPHER_HTML         'h'	/* HTML */
-/// \ingroup ServerProtocolGopherInternal
+#define GOPHER_HTML         'h'
 #define GOPHER_INFO         'i'
-/**
-  \ingroup ServerProtocolGopherInternal
-  W3 address
- */
+
+///  W3 address
 #define GOPHER_WWW          'w'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_SOUND        's'
 
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_PLUS_IMAGE   ':'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_PLUS_MOVIE   ';'
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_PLUS_SOUND   '<'
 
-/// \ingroup ServerProtocolGopherInternal
 #define GOPHER_PORT         70
 
-/// \ingroup ServerProtocolGopherInternal
 #define TAB                 '\t'
-/// \ingroup ServerProtocolGopherInternal
-/// \todo CODE: should this be a protocol-specific thing?
+
+// TODO CODE: should this be a protocol-specific thing?
 #define TEMP_BUF_SIZE       4096
-/// \ingroup ServerProtocolGopherInternal
+
 #define MAX_CSO_RESULT      1024
 
-/// \ingroup ServerProtocolGopherInternal
-typedef struct gopher_ds {
+/**
+ * Gopher Gateway Internals
+ *
+ * Gopher is somewhat complex and gross because it must convert from
+ * the Gopher protocol to HTTP.
+ */
+class GopherStateData
+{
+    CBDATA_CLASS(GopherStateData);
+
+public:
+    GopherStateData(FwdState *aFwd) :
+        entry(aFwd->entry),
+        conversion(NORMAL),
+        HTML_header_added(0),
+        HTML_pre(0),
+        type_id(GOPHER_FILE /* '0' */),
+        cso_recno(0),
+        len(0),
+        buf(NULL),
+        fwd(aFwd)
+    {
+        *request = 0;
+        buf = (char *)memAllocate(MEM_4K_BUF);
+        entry->lock("gopherState");
+        *replybuf = 0;
+    }
+
+    /* AsyncJob API emulated */
+    void deleteThis(const char *aReason);
+    void swanSong();
+
+public:
     StoreEntry *entry;
     enum {
         NORMAL,
@@ -120,10 +120,11 @@ typedef struct gopher_ds {
     int len;
     char *buf;			/* pts to a 4k page */
     Comm::ConnectionPointer serverConn;
-    HttpRequest *req;
     FwdState::Pointer fwd;
     char replybuf[BUFSIZ];
-} GopherStateData;
+};
+
+CBDATA_CLASS_INIT(GopherStateData);
 
 static CLCB gopherStateFree;
 static void gopherMimeCreate(GopherStateData *);
@@ -137,13 +138,10 @@ static IOCB gopherReadReply;
 static IOCB gopherSendComplete;
 static PF gopherSendRequest;
 
-/// \ingroup ServerProtocolGopherInternal
 static char def_gopher_bin[] = "www/unknown";
 
-/// \ingroup ServerProtocolGopherInternal
 static char def_gopher_text[] = "text/plain";
 
-/// \ingroup ServerProtocolGopherInternal
 static void
 gopherStateFree(const CommCloseCbParams &params)
 {
@@ -152,21 +150,27 @@ gopherStateFree(const CommCloseCbParams &params)
     if (gopherState == NULL)
         return;
 
-    if (gopherState->entry) {
-        gopherState->entry->unlock("gopherState");
-    }
+    gopherState->deleteThis("gopherStateFree");
+}
 
-    HTTPMSGUNLOCK(gopherState->req);
+void
+GopherStateData::deleteThis(const char *reason)
+{
+    swanSong();
+    delete this;
+}
 
-    gopherState->fwd = NULL;	// refcounted
+void
+GopherStateData::swanSong()
+{
+    if (entry)
+        entry->unlock("gopherState");
 
-    memFree(gopherState->buf, MEM_4K_BUF);
-    gopherState->buf = NULL;
-    cbdataFree(gopherState);
+    if (buf)
+        memFree(buf, MEM_4K_BUF);
 }
 
 /**
- \ingroup ServerProtocolGopherInternal
  * Create MIME Header for Gopher Data
  */
 static void
@@ -245,7 +249,6 @@ gopherMimeCreate(GopherStateData * gopherState)
 }
 
 /**
- \ingroup ServerProtocolGopherInternal
  * Parse a gopher request into components.  By Anawat.
  */
 static void
@@ -274,12 +277,11 @@ gopher_request_parse(const HttpRequest * req, char *type_id, char *request)
 }
 
 /**
- \ingroup ServerProtocolGopherAPI
  * Parse the request to determine whether it is cachable.
  *
- \param req	Request data.
- \retval 0	Not cachable.
- \retval 1	Cachable.
+ * \param req	Request data.
+ * \retval 0	Not cachable.
+ * \retval 1	Cachable.
  */
 int
 gopherCachable(const HttpRequest * req)
@@ -310,7 +312,6 @@ gopherCachable(const HttpRequest * req)
     return cachable;
 }
 
-/// \ingroup ServerProtocolGopherInternal
 static void
 gopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)
 {
@@ -324,7 +325,6 @@ gopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)
     storeAppendPrintf(e, "</H1>\n");
 }
 
-/// \ingroup ServerProtocolGopherInternal
 static void
 gopherHTMLFooter(StoreEntry * e)
 {
@@ -337,7 +337,6 @@ gopherHTMLFooter(StoreEntry * e)
     storeAppendPrintf(e, "</ADDRESS></BODY></HTML>\n");
 }
 
-/// \ingroup ServerProtocolGopherInternal
 static void
 gopherEndHTML(GopherStateData * gopherState)
 {
@@ -354,9 +353,8 @@ gopherEndHTML(GopherStateData * gopherState)
 }
 
 /**
- \ingroup ServerProtocolGopherInternal
  * Convert Gopher to HTML.
- \par
+ *
  * Borrow part of code from libwww2 came with Mosaic distribution.
  */
 static void
@@ -381,7 +379,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 
     entry = gopherState->entry;
 
-    if (gopherState->conversion == gopher_ds::HTML_INDEX_PAGE) {
+    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {
         char *html_url = html_quote(entry->url());
         gopherHTMLHeader(entry, "Gopher Index %s", html_url);
         storeAppendPrintf(entry,
@@ -396,7 +394,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
         return;
     }
 
-    if (gopherState->conversion == gopher_ds::HTML_CSO_PAGE) {
+    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {
         char *html_url = html_quote(entry->url());
         gopherHTMLHeader(entry, "CSO Search of %s", html_url);
         storeAppendPrintf(entry,
@@ -414,7 +412,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
     String outbuf;
 
     if (!gopherState->HTML_header_added) {
-        if (gopherState->conversion == gopher_ds::HTML_CSO_RESULT)
+        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)
             gopherHTMLHeader(entry, "CSO Search Result", NULL);
         else
             gopherHTMLHeader(entry, "Gopher Menu", NULL);
@@ -471,9 +469,9 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 
         switch (gopherState->conversion) {
 
-        case gopher_ds::HTML_INDEX_RESULT:
+        case GopherStateData::HTML_INDEX_RESULT:
 
-        case gopher_ds::HTML_DIR: {
+        case GopherStateData::HTML_DIR: {
             tline = line;
             gtype = *tline;
             ++tline;
@@ -618,7 +616,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
             break;
         }			/* HTML_DIR, HTML_INDEX_RESULT */
 
-        case gopher_ds::HTML_CSO_RESULT: {
+        case GopherStateData::HTML_CSO_RESULT: {
             if (line[0] == '-') {
                 int code, recno;
                 char *s_code, *s_recno, *result;
@@ -699,7 +697,6 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
     return;
 }
 
-/// \ingroup ServerProtocolGopherInternal
 static void
 gopherTimeout(const CommTimeoutCbParams &io)
 {
@@ -713,7 +710,6 @@ gopherTimeout(const CommTimeoutCbParams &io)
 }
 
 /**
- \ingroup ServerProtocolGopherInternal
  * This will be called when data is ready to be read from fd.
  * Read until error or connection closed.
  */
@@ -796,15 +792,15 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm
         /* Connection closed; retrieval done. */
         /* flush the rest of data in temp buf if there is one. */
 
-        if (gopherState->conversion != gopher_ds::NORMAL)
+        if (gopherState->conversion != GopherStateData::NORMAL)
             gopherEndHTML(gopherState);
 
         entry->timestampsSet();
         entry->flush();
         gopherState->fwd->complete();
         gopherState->serverConn->close();
     } else {
-        if (gopherState->conversion != gopher_ds::NORMAL) {
+        if (gopherState->conversion != GopherStateData::NORMAL) {
             gopherToHTML(gopherState, buf, len);
         } else {
             entry->append(buf, len);
@@ -816,7 +812,6 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm
 }
 
 /**
- \ingroup ServerProtocolGopherInternal
  * This will be called when request write is complete. Schedule read of reply.
  */
 static void
@@ -859,25 +854,25 @@ gopherSendComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size,
 
     case GOPHER_DIRECTORY:
         /* we got to convert it first */
-        gopherState->conversion = gopher_ds::HTML_DIR;
+        gopherState->conversion = GopherStateData::HTML_DIR;
         gopherState->HTML_header_added = 0;
         break;
 
     case GOPHER_INDEX:
         /* we got to convert it first */
-        gopherState->conversion = gopher_ds::HTML_INDEX_RESULT;
+        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;
         gopherState->HTML_header_added = 0;
         break;
 
     case GOPHER_CSO:
         /* we got to convert it first */
-        gopherState->conversion = gopher_ds::HTML_CSO_RESULT;
+        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;
         gopherState->cso_recno = 0;
         gopherState->HTML_header_added = 0;
         break;
 
     default:
-        gopherState->conversion = gopher_ds::NORMAL;
+        gopherState->conversion = GopherStateData::NORMAL;
         entry->flush();
     }
 
@@ -891,7 +886,6 @@ gopherSendComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size,
 }
 
 /**
- \ingroup ServerProtocolGopherInternal
  * This will be called when connect completes. Write request.
  */
 static void
@@ -928,25 +922,12 @@ gopherSendRequest(int fd, void *data)
     gopherState->entry->makePublic();
 }
 
-/// \ingroup ServerProtocolGopherInternal
-CBDATA_TYPE(GopherStateData);
-
-/// \ingroup ServerProtocolGopherAPI
 void
 gopherStart(FwdState * fwd)
 {
-    StoreEntry *entry = fwd->entry;
-    GopherStateData *gopherState;
-    CBDATA_INIT_TYPE(GopherStateData);
-    gopherState = cbdataAlloc(GopherStateData);
-    gopherState->buf = (char *)memAllocate(MEM_4K_BUF);
-
-    entry->lock("gopherState");
-    gopherState->entry = entry;
-
-    gopherState->fwd = fwd;
+    GopherStateData *gopherState = new GopherStateData(fwd);
 
-    debugs(10, 3, "gopherStart: " << entry->url()  );
+    debugs(10, 3, gopherState->entry->url());
 
     ++ statCounter.server.all.requests;
 
@@ -965,12 +946,12 @@ gopherStart(FwdState * fwd)
         gopherMimeCreate(gopherState);
 
         if (gopherState->type_id == GOPHER_INDEX) {
-            gopherState->conversion = gopher_ds::HTML_INDEX_PAGE;
+            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;
         } else {
             if (gopherState->type_id == GOPHER_CSO) {
-                gopherState->conversion = gopher_ds::HTML_CSO_PAGE;
+                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;
             } else {
-                gopherState->conversion = gopher_ds::HTML_INDEX_PAGE;
+                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;
             }
         }
 
@@ -22,6 +22,8 @@
 
 class helper
 {
+    CBDATA_CLASS(helper);
+
 public:
     inline helper(const char *name) :
             cmdline(NULL),
@@ -52,24 +54,20 @@ class helper
         int queue_size;
         int avg_svc_time;
     } stats;
-
-private:
-    CBDATA_CLASS2(helper);
 };
 
 class statefulhelper : public helper
 {
+    CBDATA_CLASS(statefulhelper);
+
 public:
-    inline statefulhelper(const char *name) : helper(name), datapool(NULL), IsAvailable(NULL), OnEmptyQueue(NULL) {};
-    inline ~statefulhelper() {};
+    inline statefulhelper(const char *name) : helper(name), datapool(NULL), IsAvailable(NULL), OnEmptyQueue(NULL) {}
+    inline ~statefulhelper() {}
 
 public:
     MemAllocator *datapool;
     HLPSAVAIL *IsAvailable;
     HLPSONEQ *OnEmptyQueue;
-
-private:
-    CBDATA_CLASS2(statefulhelper);
 };
 
 /**
@@ -132,19 +130,20 @@ class MemBuf;
 
 class helper_server : public HelperServerBase
 {
+    CBDATA_CLASS(helper_server);
+
 public:
     MemBuf *wqueue;
     MemBuf *writebuf;
 
     helper *parent;
     Helper::Request **requests;
-
-private:
-    CBDATA_CLASS2(helper_server);
 };
 
 class helper_stateful_server : public HelperServerBase
 {
+    CBDATA_CLASS(helper_stateful_server);
+
 public:
     /* MemBuf wqueue; */
     /* MemBuf writebuf; */
@@ -153,9 +152,6 @@ class helper_stateful_server : public HelperServerBase
     Helper::Request *request;
 
     void *data;			/* State data used by the calling routines */
-
-private:
-    CBDATA_CLASS2(helper_stateful_server);
 };
 
 /* helper.c */
@@ -16,6 +16,8 @@ namespace Helper
 
 class Request
 {
+    MEMPROXY_CLASS(Helper::Request);
+
 public:
     Request(HLPCB *c, void *d, const char *b) :
             buf(b ? xstrdup(b) : NULL),
@@ -31,7 +33,6 @@ class Request
         xfree(buf);
     }
 
-    MEMPROXY_CLASS(Helper::Request);
     char *buf;
     HLPCB *callback;
     void *data;
@@ -42,6 +43,4 @@ class Request
 
 } // namespace Helper
 
-MEMPROXY_CLASS_INLINE(Helper::Request);
-
 #endif /* _SQUID_SRC_HELPER_REQUEST_H */
@@ -135,10 +135,9 @@ struct _htcpAuthHeader {
 
 class htcpSpecifier : public StoreClient
 {
-
-public:
     MEMPROXY_CLASS(htcpSpecifier);
 
+public:
     void created (StoreEntry *newEntry);
     void checkHit();
     void checkedHit(StoreEntry *e);
@@ -159,8 +158,6 @@ class htcpSpecifier : public StoreClient
     htcpDataHeader *dhdr;
 };
 
-MEMPROXY_CLASS_INLINE(htcpSpecifier);
-
 struct _htcpDetail {
     char *resp_hdrs;
     size_t respHdrsSz;
@@ -1100,22 +1100,6 @@ HttpStateData::persistentConnStatus() const
     return statusIfComplete();
 }
 
-/*
- * This is the callback after some data has been read from the network
- */
-/*
-void
-HttpStateData::ReadReplyWrapper(int fd, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
-{
-    HttpStateData *httpState = static_cast<HttpStateData *>(data);
-    assert (fd == httpState->serverConnection->fd);
-    // assert(buf == readBuf->content());
-    PROF_start(HttpStateData_readReply);
-    httpState->readReply(len, flag, xerrno);
-    PROF_stop(HttpStateData_readReply);
-}
-*/
-
 /* XXX this function is too long! */
 void
 HttpStateData::readReply(const CommIoCbParams &io)
@@ -1806,9 +1790,10 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Authorization if known in URL, not in header and going direct */
     if (!hdr_out->has(HDR_AUTHORIZATION)) {
-        if (!request->flags.proxying && request->login[0] != '\0') {
-            httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
-                              old_base64_encode(request->login));
+        if (!request->flags.proxying && !request->url.userInfo().isEmpty()) {
+            static char result[MAX_URL*2]; // should be big enough for a single URI segment
+            if (base64_encode_str(result, sizeof(result)-1, request->url.userInfo().rawContent(), request->url.userInfo().length()) < static_cast<int>(sizeof(result)-1))
+                httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s", result);
         }
     }
 
@@ -19,6 +19,7 @@ class HttpHeader;
 
 class HttpStateData : public Client
 {
+    CBDATA_CLASS(HttpStateData);
 
 public:
     HttpStateData(FwdState *);
@@ -110,8 +111,6 @@ class HttpStateData : public Client
     bool peerSupportsConnectionPinning() const;
 
     ChunkedCodingParser *httpChunkDecoder;
-private:
-    CBDATA_CLASS2(HttpStateData);
 };
 
 int httpCachable(const HttpRequestMethod&);
@@ -1307,8 +1307,9 @@ netdbExchangeStart(void *data)
                     netdbExchangeHandleReply, ex);
     ex->r->flags.loopDetected = true;	/* cheat! -- force direct */
 
+    // XXX: send as Proxy-Authenticate instead
     if (p->login)
-        xstrncpy(ex->r->login, p->login, MAX_LOGIN_SZ);
+        ex->r->url.userInfo(SBuf(p->login));
 
     urlCanonical(ex->r);
 
@@ -32,10 +32,9 @@ class IdentLookup : public ACLChecklist::AsyncState
 /// \ingroup ACLAPI
 class ACLIdent : public ACL
 {
-
-public:
     MEMPROXY_CLASS(ACLIdent);
 
+public:
     ACLIdent(ACLData<char const *> *newData, char const *);
     ACLIdent (ACLIdent const &old);
     ACLIdent & operator= (ACLIdent const &rhs);
@@ -59,7 +58,5 @@ class ACLIdent : public ACL
     char const *type_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLIdent);
-
 #endif /* USE_IDENT */
 #endif /* SQUID_IDENT_ACLIDENT_H */
@@ -36,13 +36,28 @@ typedef struct _IdentClient {
     struct _IdentClient *next;
 } IdentClient;
 
-typedef struct _IdentStateData {
+class IdentStateData
+{
+public:
     hash_link hash;		/* must be first */
+private:
+    CBDATA_CLASS(IdentStateData);
+
+public:
+    /* AsyncJob API emulated */
+    void deleteThis(const char *aReason);
+    void swanSong();
+
+    /// notify all waiting IdentClient callbacks
+    void notify(const char *result);
+
     Comm::ConnectionPointer conn;
     MemBuf queryMsg;  ///< the lookup message sent to IDENT server
     IdentClient *clients;
     char buf[IDENT_BUFSIZE];
-} IdentStateData;
+};
+
+CBDATA_CLASS_INIT(IdentStateData);
 
 // TODO: make these all a series of Async job calls. They are self-contained callbacks now.
 static IOCB ReadReply;
@@ -52,25 +67,39 @@ static CTCB Timeout;
 static CNCB ConnectDone;
 static hash_table *ident_hash = NULL;
 static void ClientAdd(IdentStateData * state, IDCB * callback, void *callback_data);
-static void identCallback(IdentStateData * state, char *result);
 
 } // namespace Ident
 
 Ident::IdentConfig Ident::TheConfig;
 
-/**** PRIVATE FUNCTIONS ****/
+void
+Ident::IdentStateData::deleteThis(const char *aReason)
+{
+    swanSong();
+    delete this;
+}
 
 void
-Ident::identCallback(IdentStateData * state, char *result)
+Ident::IdentStateData::swanSong()
 {
-    IdentClient *client;
+    if (clients != NULL)
+        notify(NULL);
 
-    if (result && *result == '\0')
-        result = NULL;
+    if (Comm::IsConnOpen(conn)) {
+        comm_remove_close_handler(conn->fd, Ident::Close, this);
+        conn->close();
+    }
 
-    while ((client = state->clients)) {
+    hash_remove_link(ident_hash, (hash_link *) this);
+    xfree(hash.key);
+}
+
+void
+Ident::IdentStateData::notify(const char *result)
+{
+    while (IdentClient *client = clients) {
         void *cbdata;
-        state->clients = client->next;
+        clients = client->next;
 
         if (cbdataReferenceValidDone(client->callback_data, &cbdata))
             client->callback(result, cbdata);
@@ -83,18 +112,15 @@ void
 Ident::Close(const CommCloseCbParams &params)
 {
     IdentStateData *state = (IdentStateData *)params.data;
-    identCallback(state, NULL);
-    state->conn->close();
-    hash_remove_link(ident_hash, (hash_link *) state);
-    xfree(state->hash.key);
-    cbdataFree(state);
+    state->deleteThis("connection closed");
 }
 
 void
 Ident::Timeout(const CommTimeoutCbParams &io)
 {
     debugs(30, 3, HERE << io.conn);
-    io.conn->close();
+    IdentStateData *state = (IdentStateData *)io.data;
+    state->deleteThis("timeout");
 }
 
 void
@@ -105,12 +131,10 @@ Ident::ConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int x
     if (status != Comm::OK) {
         if (status == Comm::TIMEOUT)
             debugs(30, 3, "IDENT connection timeout to " << state->conn->remote);
-        Ident::identCallback(state, NULL);
+        state->deleteThis(status == Comm::TIMEOUT ? "connect timeout" : "connect error");
         return;
     }
 
-    assert(conn != NULL && conn == state->conn);
-
     /*
      * see if any of our clients still care
      */
@@ -121,11 +145,11 @@ Ident::ConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int x
     }
 
     if (c == NULL) {
-        /* no clients care */
-        conn->close();
+        state->deleteThis("client(s) aborted");
         return;
     }
 
+    assert(conn != NULL && conn == state->conn);
     comm_add_close_handler(conn->fd, Ident::Close, state);
 
     AsyncCall::Pointer writeCall = commCbCall(5,4, "Ident::WriteFeedback",
@@ -147,7 +171,8 @@ Ident::WriteFeedback(const Comm::ConnectionPointer &conn, char *buf, size_t len,
     // TODO handle write errors better. retry or abort?
     if (flag != Comm::OK) {
         debugs(30, 2, HERE << conn << " err-flags=" << flag << " IDENT write error: " << xstrerr(xerrno));
-        conn->close();
+        IdentStateData *state = (IdentStateData *)data;
+        state->deleteThis("write error");
     }
 }
 
@@ -162,7 +187,7 @@ Ident::ReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Com
     assert(conn->fd == state->conn->fd);
 
     if (flag != Comm::OK || len <= 0) {
-        state->conn->close();
+        state->deleteThis("read error");
         return;
     }
 
@@ -184,11 +209,13 @@ Ident::ReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Com
     if (strstr(buf, "USERID")) {
         if ((ident = strrchr(buf, ':'))) {
             while (xisspace(*++ident));
-            Ident::identCallback(state, ident);
+            if (ident && *ident == '\0')
+                ident = NULL;
+            state->notify(ident);
         }
     }
 
-    state->conn->close();
+    state->deleteThis("completed");
 }
 
 void
@@ -203,10 +230,6 @@ Ident::ClientAdd(IdentStateData * state, IDCB * callback, void *callback_data)
     *C = c;
 }
 
-CBDATA_TYPE(IdentStateData);
-
-/**** PUBLIC FUNCTIONS ****/
-
 /*
  * start a TCP connection to the peer host on port 113
  */
@@ -230,8 +253,7 @@ Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
         return;
     }
 
-    CBDATA_INIT_TYPE(IdentStateData);
-    state = cbdataAlloc(IdentStateData);
+    state = new IdentStateData;
     state->hash.key = xstrdup(key);
 
     // copy the conn details. We dont want the original FD to be re-used by IDENT.
@@ -29,6 +29,8 @@ namespace Ipc
 ///  Coordinates shared activities of Strands (Squid processes or threads)
 class Coordinator: public Port
 {
+    CBDATA_CLASS(Coordinator);
+
 public:
     static Coordinator* Instance();
 
@@ -77,8 +79,6 @@ class Coordinator: public Port
 private:
     Coordinator(const Coordinator&); // not implemented
     Coordinator& operator =(const Coordinator&); // not implemented
-
-    CBDATA_CLASS2(Coordinator);
 };
 
 } // namespace Ipc
@@ -27,6 +27,8 @@ namespace Ipc
  */
 class Forwarder: public AsyncJob
 {
+    CBDATA_CLASS(Forwarder);
+
 public:
     Forwarder(Request::Pointer aRequest, double aTimeout);
     virtual ~Forwarder();
@@ -64,8 +66,6 @@ class Forwarder: public AsyncJob
     static RequestsMap TheRequestsMap; ///< pending Coordinator requests
 
     static unsigned int LastRequestId; ///< last requestId used
-
-    CBDATA_CLASS2(Forwarder);
 };
 
 } // namespace Ipc
@@ -26,6 +26,8 @@ namespace Ipc
 /// aggregating individual strand responses and dumping the result if needed
 class Inquirer: public AsyncJob
 {
+    CBDATA_CLASS(Inquirer);
+
 public:
     Inquirer(Request::Pointer aRequest, const Ipc::StrandCoords& coords, double aTimeout);
     virtual ~Inquirer();
@@ -78,8 +80,6 @@ class Inquirer: public AsyncJob
     static RequestsMap TheRequestsMap; ///< pending strand requests
 
     static unsigned int LastRequestId; ///< last requestId used
-
-    CBDATA_CLASS2(Inquirer);
 };
 
 } // namespace Ipc
@@ -26,6 +26,8 @@ class StrandCoord;
 /// Receives coordination messages on behalf of its process or thread
 class Strand: public Port
 {
+    CBDATA_CLASS(Strand);
+
 public:
     Strand();
 
@@ -51,8 +53,6 @@ class Strand: public Port
 private:
     Strand(const Strand&); // not implemented
     Strand& operator =(const Strand&); // not implemented
-
-    CBDATA_CLASS2(Strand);
 };
 
 }
@@ -66,6 +66,8 @@ struct sockaddr_un PathToAddress(const String &pathAddr);
 /// attempts to send an IPC message a few times, with a timeout
 class UdsSender: public UdsOp
 {
+    CBDATA_CLASS(UdsSender);
+
 public:
     UdsSender(const String& pathAddr, const TypedMsgHdr& aMessage);
 
@@ -94,8 +96,6 @@ class UdsSender: public UdsOp
 private:
     UdsSender(const UdsSender&); // not implemented
     UdsSender& operator= (const UdsSender&); // not implemented
-
-    CBDATA_CLASS2(UdsSender);
 };
 
 void SendMessage(const String& toAddress, const TypedMsgHdr& message);
@@ -26,6 +26,8 @@ namespace Log
  */
 class TcpLogger : public AsyncJob
 {
+    CBDATA_CLASS(TcpLogger);
+
 public:
     typedef CbcPointer<TcpLogger> Pointer;
 
@@ -103,8 +105,6 @@ class TcpLogger : public AsyncJob
 
     uint64_t connectFailures; ///< number of sequential connection failures
     uint64_t drops; ///< number of records dropped during the current outage
-
-    CBDATA_CLASS2(TcpLogger);
 };
 
 } // namespace Log
@@ -122,6 +122,9 @@
 #endif
 
 #include <cerrno>
+#if HAVE_GETOPT_H
+#include <getopt.h>
+#endif
 #if HAVE_PATHS_H
 #include <paths.h>
 #endif
@@ -256,16 +259,18 @@ static void
 usage(void)
 {
     fprintf(stderr,
-            "Usage: %s [-cdhvzCFNRVYX] [-n name] [-s | -l facility] [-f config-file] [-[au] port] [-k signal]"
+            "Usage: %s [-cdzCFNRVYX] [-n name] [-s | -l facility] [-f config-file] [-[au] port] [-k signal]"
 #if USE_WIN32_SERVICE
             "[-ir] [-O CommandLine]"
 #endif
+            "\n"
+            "    -h | --help       Print help message.\n"
+            "    -v | --version    Print version details.\n"
             "\n"
             "       -a port   Specify HTTP port number (default: %d).\n"
             "       -d level  Write debugging to stderr also.\n"
             "       -f file   Use given config-file instead of\n"
             "                 %s\n"
-            "       -h        Print help message.\n"
 #if USE_WIN32_SERVICE
             "       -i        Installs as a Windows Service (see -n option).\n"
 #endif
@@ -284,7 +289,6 @@ usage(void)
             "       -s | -l facility\n"
             "                 Enable logging to syslog.\n"
             "       -u port   Specify ICP port number (default: %d), disable with 0.\n"
-            "       -v        Print version.\n"
             "       -z        Create missing swap directories and then exit.\n"
             "       -C        Do not catch fatal signals.\n"
             "       -D        OBSOLETE. Scheduled for removal.\n"
@@ -305,21 +309,30 @@ usage(void)
 /**
  * Parse the parameters received via command line interface.
  *
- \param argc   Number of options received on command line
- \param argv   List of parameters received on command line
+ * \param argc   Number of options received on command line
+ * \param argv   List of parameters received on command line
  */
 static void
 mainParseOptions(int argc, char *argv[])
 {
-    extern char *optarg;
-    int c;
+    int optIndex = 0;
 
+    // short options
+    const char *shortOpStr =
 #if USE_WIN32_SERVICE
-    while ((c = getopt(argc, argv, "CDFNO:RSVYXa:d:f:hik:m::n:rsl:u:vz?")) != -1)
-#else
-    while ((c = getopt(argc, argv, "CDFNRSYXa:d:f:hk:m::n:sl:u:vz?")) != -1)
+                            "O:Vir"
 #endif
-    {
+                            "CDFNRSYXa:d:f:hk:m::n:sl:u:vz?";
+
+    // long options
+    static struct option squidOptions[] = {
+        {"help",    no_argument, 0, 'h'},
+        {"version", no_argument, 0, 'v'},
+        {0, 0, 0, 0}
+    };
+
+    int c;
+    while ((c = getopt_long(argc, argv, shortOpStr, squidOptions, &optIndex)) != -1) {
 
         switch (c) {
 
@@ -400,7 +413,7 @@ mainParseOptions(int argc, char *argv[])
 
         case 'd':
             /** \par d
-             * Set global option Debug::log_stderr to the number given follwoign the option */
+             * Set global option Debug::log_stderr to the number given following the option */
             Debug::log_stderr = atoi(optarg);
             break;
 
@@ -16,12 +16,12 @@
 
 class mem_node
 {
+    MEMPROXY_CLASS(mem_node);
 
 public:
     static size_t InUseCount();
     static size_t StoreMemSize();
 
-    MEMPROXY_CLASS(mem_node);
     mem_node(int64_t);
     ~mem_node();
     size_t space() const;
@@ -38,8 +38,6 @@ class mem_node
     bool write_pending;
 };
 
-MEMPROXY_CLASS_INLINE(mem_node);
-
 inline std::ostream &
 operator << (std::ostream &os, mem_node &aNode)
 {
@@ -21,6 +21,8 @@ namespace Mgr
 /// Comm-writes it using parent StoreToCommWriter.
 class ActionWriter: public StoreToCommWriter
 {
+    CBDATA_CLASS(ActionWriter);
+
 public:
     ActionWriter(const Action::Pointer &anAction, const Comm::ConnectionPointer &conn);
 
@@ -30,8 +32,6 @@ class ActionWriter: public StoreToCommWriter
 
 private:
     Action::Pointer action; ///< action that fills the entry
-
-    CBDATA_CLASS2(ActionWriter);
 };
 
 } // namespace Mgr
@@ -21,6 +21,8 @@ namespace Mgr
 /// provides Coordinator with a local cache manager response
 class Filler: public StoreToCommWriter
 {
+    CBDATA_CLASS(Filler);
+
 public:
     Filler(const Action::Pointer &anAction, const Comm::ConnectionPointer &conn, unsigned int aRequestId);
 
@@ -32,8 +34,6 @@ class Filler: public StoreToCommWriter
 private:
     Action::Pointer action; ///< action that will run() and sendResponse()
     unsigned int requestId; ///< the ID of the Request we are responding to
-
-    CBDATA_CLASS2(Filler);
 };
 
 } // namespace Mgr
@@ -29,6 +29,8 @@ namespace Mgr
  */
 class Forwarder: public Ipc::Forwarder
 {
+    CBDATA_CLASS(Forwarder);
+
 public:
     Forwarder(const Comm::ConnectionPointer &aConn, const ActionParams &aParams, HttpRequest* aRequest,
               StoreEntry* anEntry);
@@ -51,8 +53,6 @@ class Forwarder: public Ipc::Forwarder
     StoreEntry* entry; ///< Store entry expecting the response
     Comm::ConnectionPointer conn; ///< HTTP client connection descriptor
     AsyncCall::Pointer closer; ///< comm_close handler for the HTTP connection
-
-    CBDATA_CLASS2(Forwarder);
 };
 
 } // namespace Mgr
@@ -25,6 +25,8 @@ namespace Mgr
 /// aggregating individual strand responses and dumping the result if needed
 class Inquirer: public Ipc::Inquirer
 {
+    CBDATA_CLASS(Inquirer);
+
 public:
     Inquirer(Action::Pointer anAction, const Request &aCause,
              const Ipc::StrandCoords &coords);
@@ -52,8 +54,6 @@ class Inquirer: public Ipc::Inquirer
 
     AsyncCall::Pointer writer; ///< comm_write callback
     AsyncCall::Pointer closer; ///< comm_close handler
-
-    CBDATA_CLASS2(Inquirer);
 };
 
 } // namespace Mgr
@@ -27,6 +27,8 @@ namespace Mgr
 /// for the given StoreEntry and client FD
 class StoreToCommWriter: public AsyncJob
 {
+    CBDATA_CLASS(StoreToCommWriter);
+
 public:
     StoreToCommWriter(const Comm::ConnectionPointer &conn, StoreEntry *anEntry);
     virtual ~StoreToCommWriter();
@@ -64,8 +66,6 @@ class StoreToCommWriter: public AsyncJob
 
     AsyncCall::Pointer closer; ///< comm_close handler
     char buffer[HTTP_REQBUF_SZ]; ///< action results; Store fills, Comm writes
-
-    CBDATA_CLASS2(StoreToCommWriter);
 };
 
 } // namespace Mgr
@@ -35,31 +35,32 @@ static char const *mimeGetIcon(const char *fn);
 
 class MimeIcon : public StoreClient
 {
+    MEMPROXY_CLASS(MimeIcon);
+
 public:
     explicit MimeIcon(const char *aName);
     ~MimeIcon();
     void setName(char const *);
     char const * getName() const;
     void load();
     void created(StoreEntry *newEntry);
-    MEMPROXY_CLASS(MimeIcon);
 
 private:
     const char *icon_;
     char *url_;
 };
-MEMPROXY_CLASS_INLINE(MimeIcon);
 
 class MimeEntry
 {
+    MEMPROXY_CLASS(MimeEntry);
+
 public:
     explicit MimeEntry(const char *aPattern, const regex_t &compiledPattern,
                        const char *aContentType,
                        const char *aContentEncoding, const char *aTransferMode,
                        bool optionViewEnable, bool optionDownloadEnable,
                        const char *anIconName);
     ~MimeEntry();
-    MEMPROXY_CLASS(MimeEntry);
 
     const char *pattern;
     regex_t compiled_pattern;
@@ -71,7 +72,6 @@ class MimeEntry
     MimeIcon theIcon;
     MimeEntry *next;
 };
-MEMPROXY_CLASS_INLINE(MimeEntry);
 
 static MimeEntry *MimeTable = NULL;
 static MimeEntry **MimeTableTail = &MimeTable;
@@ -1,16 +1,17 @@
-# This file associates filename extensions (for servers or services
-# that don't automatically include them - like ftp) with a mime type
-# and a graphical icon.
-#
-#
-# This file has the format :
-# regex content-type icon content-encoding transfer-mode
-#-----------------------------------------------------------------------------------
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 #
+# This file associates URL patterns for servers or services
+# that don't automatically include Content-Type (like ftp) with a mime type
+# and a graphical icon.
 #
 # Content-Encodings are taken from section 3.1 of RFC2068 (HTTP/1.1)
 #
-#
+# This file has the format :
 #
 # regexp	content-type			icon				encoding mode	actions
 #--------------------------------------------------------------------------------------------------------
@@ -190,6 +191,6 @@ README		text/plain			silk/information.png		-	ascii	+download
 \.xml$		text/xml			silk/page_world.png		-	ascii	+download
 \.xsl$		text/xml			silk/layout.png			-	ascii	+download
 \.xyz$		chemical/x-xyz			silk/chart_line.png		-	image	+download
-
+#
 # the default
 .		text/plain			silk/bullet_red.png		-	image	+download +view
@@ -22,9 +22,7 @@
 class PconnPool;
 class PeerPoolMgr;
 
-/* for CBDATA_CLASS2() macros */
 #include "cbdata.h"
-/* for hash_link */
 #include "hash.h"
 /* for IOCB */
 #include "comm.h"
@@ -37,6 +35,8 @@ class PeerPoolMgr;
  */
 class IdleConnList
 {
+    CBDATA_CLASS(IdleConnList);
+
 public:
     IdleConnList(const char *key, PconnPool *parent);
     ~IdleConnList();
@@ -92,8 +92,6 @@ class IdleConnList
     PconnPool *parent_;
 
     char fakeReadBuf_[4096]; // TODO: kill magic number.
-
-    CBDATA_CLASS2(IdleConnList);
 };
 
 #include "ip/forward.h"
@@ -314,7 +314,7 @@ peerDigestRequest(PeerDigest * pd)
             strcmp(p->login, "PASSTHRU") != 0 &&
             strcmp(p->login, "NEGOTIATE") != 0 &&
             strcmp(p->login, "PROXYPASS") != 0) {
-        xstrncpy(req->login, p->login, MAX_LOGIN_SZ);
+        req->url.userInfo(SBuf(p->login)); // XXX: performance regression make peer login SBuf as well.
     }
     /* create fetch state structure */
     CBDATA_INIT_TYPE(DigestFetchState);
@@ -38,6 +38,8 @@
 
 class RedirectStateData
 {
+    CBDATA_CLASS(RedirectStateData);
+
 public:
     explicit RedirectStateData(const char *url);
     ~RedirectStateData();
@@ -46,9 +48,6 @@ class RedirectStateData
     SBuf orig_url;
 
     HLPCB *handler;
-
-private:
-    CBDATA_CLASS2(RedirectStateData);
 };
 
 static HLPCB redirectHandleReply;
@@ -274,7 +274,7 @@ Ftp::StartListening()
 void
 Ftp::StopListening()
 {
-    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
+    for (AnyP::PortCfgPointer s = FtpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, DBG_IMPORTANT, "Closing FTP port " << s->listenConn->local);
             s->listenConn->close();
@@ -52,6 +52,8 @@ class MasterState: public RefCountable
 /// Manages a control connection from an FTP client.
 class Server: public ConnStateData
 {
+    CBDATA_CLASS(Server);
+
 public:
     explicit Server(const MasterXaction::Pointer &xact);
     virtual ~Server();
@@ -166,8 +168,6 @@ class Server: public ConnStateData
     AsyncCall::Pointer listener; ///< set when we are passively listening
     AsyncCall::Pointer connector; ///< set when we are actively connecting
     AsyncCall::Pointer reader; ///< set when we are reading FTP data
-
-    CBDATA_CLASS2(Server);
 };
 
 } // namespace Ftp
@@ -24,6 +24,8 @@ namespace Http
 /// Manages a connection from an HTTP client.
 class Server: public ConnStateData
 {
+    CBDATA_CLASS(Server);
+
 public:
     Server(const MasterXaction::Pointer &xact, const bool beHttpsServer);
     virtual ~Server() {}
@@ -54,8 +56,6 @@ class Server: public ConnStateData
 
     /// temporary hack to avoid creating a true HttpsServer class
     const bool isHttpsServer;
-
-    CBDATA_CLASS2(Server);
 };
 
 } // namespace Http
@@ -26,6 +26,8 @@ namespace Snmp
  */
 class Forwarder: public Ipc::Forwarder
 {
+    CBDATA_CLASS(Forwarder);
+
 public:
     Forwarder(const Pdu& aPdu, const Session& aSession, int aFd,
               const Ip::Address& anAddress);
@@ -43,8 +45,6 @@ class Forwarder: public Ipc::Forwarder
 private:
     int fd; ///< client connection descriptor
     AsyncCall::Pointer closer; ///< comm_close handler for the connection
-
-    CBDATA_CLASS2(Forwarder);
 };
 
 void SendResponse(unsigned int requestId, const Pdu& pdu);
@@ -25,6 +25,8 @@ namespace Snmp
 /// aggregates strand responses and send back the result to client
 class Inquirer: public Ipc::Inquirer
 {
+    CBDATA_CLASS(Inquirer);
+
 public:
     Inquirer(const Request& aRequest, const Ipc::StrandCoords& coords);
 
@@ -48,8 +50,6 @@ class Inquirer: public Ipc::Inquirer
 
     AsyncCall::Pointer writer; ///< comm_write callback
     AsyncCall::Pointer closer; ///< comm_close handler
-
-    CBDATA_CLASS2(Inquirer);
 };
 
 } // namespace Snmp
@@ -240,20 +240,11 @@ see CREDITS for a list of major code contributing copyright holders.
 .
 .SH COPYRIGHT
 .PP
-This software product, SQUID, is developed by a team of individuals,
-and copyrighted (C) 2001 by the Regents of the University of
-California, with all rights reserved.  UCSD administered the NLANR
-Cache grants, NCR 9616602 and NCR 9521745 under which most of this
-code was developed.
-.PP
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License (version 2) as
-published by the Free Software Foundation.  It is distributed in the
-hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU General Public License for more details.
-.PP
-see the CREDITS file for further copyright licensing of third-party code contributions.
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
 .
 .SH QUESTIONS
 Questions on the usage of this program can be sent to the
@@ -69,6 +69,8 @@ class PeerConnectorAnswer
 */
 class PeerConnector: virtual public AsyncJob
 {
+    CBDATA_CLASS(PeerConnector);
+
 public:
     /// Callback dialier API to allow PeerConnector to set the answer.
     class CbDialer
@@ -171,8 +173,6 @@ class PeerConnector: virtual public AsyncJob
     time_t negotiationTimeout; ///< the ssl connection timeout to use
     time_t startTime; ///< when the peer connector negotiation started
     bool splice; ///< Whether we are going to splice or not
-
-    CBDATA_CLASS2(PeerConnector);
 };
 
 std::ostream &operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &a);
@@ -22,11 +22,12 @@ namespace Ssl
 {
 
 /**
-  \ingroup ServerProtocolSSLAPI
  * Maintains bump-server-first related information.
  */
 class ServerBump
 {
+    CBDATA_CLASS(ServerBump);
+
 public:
     explicit ServerBump(HttpRequest *fakeRequest, StoreEntry *e = NULL, Ssl::BumpMode mode = Ssl::bumpServerFirst);
     ~ServerBump();
@@ -46,8 +47,6 @@ class ServerBump
 
 private:
     store_client *sc; ///< dummy client to prevent entry trimming
-
-    CBDATA_CLASS2(ServerBump);
 };
 
 } // namespace Ssl
@@ -312,7 +312,21 @@ mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
                 if ((ext = X509_get_ext(cert.get(), p)) != NULL) {
                     ASN1_BIT_STRING *keyusage = (ASN1_BIT_STRING *)X509V3_EXT_d2i(ext);
                     ASN1_BIT_STRING_set_bit(keyusage, KeyEncipherment, 1);
-                    X509_EXTENSION_set_data( ext, (ASN1_OCTET_STRING*)keyusage );
+
+                    //Build the ASN1_OCTET_STRING
+                    const X509V3_EXT_METHOD *method = X509V3_EXT_get(ext);
+                    assert(method && method->it);
+                    unsigned char *ext_der = NULL;
+                    int ext_len = ASN1_item_i2d((ASN1_VALUE *)keyusage,
+                                                &ext_der, 
+                                                (const ASN1_ITEM *)ASN1_ITEM_ptr(method->it));
+
+                    ASN1_OCTET_STRING *ext_oct = M_ASN1_OCTET_STRING_new();
+                    ext_oct->data = ext_der;
+                    ext_oct->length = ext_len;
+                    X509_EXTENSION_set_data(ext, ext_oct);
+
+                    M_ASN1_OCTET_STRING_free(ext_oct);
                     ASN1_BIT_STRING_free(keyusage);
                 }
             }
@@ -204,12 +204,15 @@ void Ssl::CertValidationHelper::Shutdown()
     HelperCache = NULL;
 }
 
-struct submitData {
+class submitData
+{
+    CBDATA_CLASS(submitData);
+
+public:
     std::string query;
     Ssl::CertValidationHelper::CVHCB *callback;
     void *data;
     SSL *ssl;
-    CBDATA_CLASS2(submitData);
 };
 CBDATA_CLASS_INIT(submitData);
 
@@ -1,9 +1,7 @@
 .if !'po4a'hide' .TH ssl_crtd 8
 .
 .SH NAME
-.if !'po4a'hide' .B ssl_crtd
-.if !'po4a'hide' \-
-SSL certificate generator.
+ssl_crtd \- SSL certificate generator for Squid.
 .PP
 Version 1.0
 .
@@ -150,9 +148,12 @@ This manual was written by
 .if !'po4a'hide' .I Amos Jeffries <squid3@treenet.co.nz>
 .
 .SH COPYRIGHT
-This program and documentation is copyright to the authors named above.
 .PP
-Distributed under the GNU General Public License (GNU GPL) version 2 or later (GPLv2+).
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
 .
 .SH QUESTIONS
 Questions on the usage of this program can be sent to the
@@ -11,7 +11,7 @@
 #ifndef SQUID_SSL_SUPPORT_H
 #define SQUID_SSL_SUPPORT_H
 
-#include "CbDataList.h"
+#include "base/CbDataList.h"
 #include "ssl/gadgets.h"
 
 #if HAVE_OPENSSL_SSL_H
@@ -65,14 +65,12 @@ typedef int STOBJFLT(const StoreEntry *);
 
 class StatObjectsState
 {
+    CBDATA_CLASS(StatObjectsState);
 
 public:
     StoreEntry *sentry;
     STOBJFLT *filter;
     StoreSearchPointer theSearch;
-
-private:
-    CBDATA_CLASS2(StatObjectsState);
 };
 
 /* LOCALS */
@@ -16,10 +16,9 @@
 
 class CapturingStoreEntry : public StoreEntry
 {
-
-public:
     MEMPROXY_CLASS(CapturingStoreEntry);
 
+public:
     CapturingStoreEntry() : _buffer_calls(0), _flush_calls(0) {}
 
     String _appended_text;
@@ -39,6 +38,4 @@ class CapturingStoreEntry : public StoreEntry
     }
 };
 
-MEMPROXY_CLASS_INLINE(CapturingStoreEntry);
-
 #endif
@@ -1,3 +1,10 @@
+##
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
 STUB_SOURCE= tests/STUB.h \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
@@ -28,9 +28,5 @@ void MemBuf::Printf(const char *fmt,...) STUB
 void MemBuf::vPrintf(const char *fmt, va_list ap) STUB
 FREE *MemBuf::freeFunc() STUB_RETVAL(NULL)
 
-#if !_USE_INLINE_
-#include "MemBuf.cci"
-#endif
-
 void memBufReport(MemBuf * mb) STUB
 void packerToMemInit(Packer * p, MemBuf * mb) STUB
@@ -14,15 +14,13 @@
 
 void cbdataRegisterWithCacheManager(void) STUB
 
+void *cbdataInternalAlloc(cbdata_type type, const char *, int) STUB_RETVAL(NULL)
+void *cbdataInternalFree(void *p, const char *, int) STUB_RETVAL(NULL)
 #if USE_CBDATA_DEBUG
-void *cbdataInternalAllocDbg(cbdata_type type, const char *, int) STUB_RETVAL(NULL)
-void *cbdataInternalFreeDbg(void *p, const char *, int) STUB_RETVAL(NULL)
 void cbdataInternalLockDbg(const void *p, const char *, int) STUB
 void cbdataInternalUnlockDbg(const void *p, const char *, int) STUB
 int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int) STUB_RETVAL(0)
 #else
-void *cbdataInternalAlloc(cbdata_type type) STUB_RETVAL(NULL)
-void *cbdataInternalFree(void *p) STUB_RETVAL(NULL)
 void cbdataInternalLock(const void *p) STUB
 void cbdataInternalUnlock(const void *p) STUB
 int cbdataInternalReferenceDoneValid(void **p, void **tp) STUB_RETVAL(0)
@@ -21,11 +21,8 @@ int eventFind(EVH *, void *) STUB_RETVAL(-1)
 
 // ev_entry::ev_entry(char const * name, EVH * func, void *arg, double when, int weight, bool cbdata) STUB
 // ev_entry::~ev_entry() STUB
-//    MEMPROXY_CLASS(ev_entry);
 //    EVH *func;
 
-//MEMPROXY_CLASS_INLINE(ev_entry);
-
 EventScheduler::EventScheduler() STUB
 EventScheduler::~EventScheduler() STUB
 void EventScheduler::cancel(EVH * func, void * arg) STUB
@@ -61,6 +61,7 @@
  */
 class TunnelStateData
 {
+    CBDATA_CLASS(TunnelStateData);
 
 public:
     TunnelStateData();
@@ -185,7 +186,7 @@ class TunnelStateData
     void connectedToPeer(Ssl::PeerConnectorAnswer &answer);
 #endif
 
-    CBDATA_CLASS2(TunnelStateData);
+public:
     bool keepGoingAfterRead(size_t len, Comm::Flag errcode, int xerrno, Connection &from, Connection &to);
     void copy(size_t len, Connection &from, Connection &to, IOCB *);
     void handleConnectResponse(const size_t chunkSize);
@@ -20,7 +20,7 @@ static HttpRequest *urlParseFinish(const HttpRequestMethod& method,
                                    const AnyP::ProtocolType protocol,
                                    const char *const urlpath,
                                    const char *const host,
-                                   const char *const login,
+                                   const SBuf &login,
                                    const int port,
                                    HttpRequest *request);
 static HttpRequest *urnParse(const HttpRequestMethod& method, char *urn, HttpRequest *request);
@@ -218,7 +218,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
                strcmp(url, "*") == 0) {
         protocol = AnyP::PROTO_HTTP;
         port = urlDefaultPort(protocol);
-        return urlParseFinish(method, protocol, url, host, login, port, request);
+        return urlParseFinish(method, protocol, url, host, SBuf(), port, request);
     } else if (!strncmp(url, "urn:", 4)) {
         return urnParse(method, url, request);
     } else {
@@ -423,7 +423,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         }
     }
 
-    return urlParseFinish(method, protocol, urlpath, host, login, port, request);
+    return urlParseFinish(method, protocol, urlpath, host, SBuf(login), port, request);
 }
 
 /**
@@ -436,7 +436,7 @@ urlParseFinish(const HttpRequestMethod& method,
                const AnyP::ProtocolType protocol,
                const char *const urlpath,
                const char *const host,
-               const char *const login,
+               const SBuf &login,
                const int port,
                HttpRequest *request)
 {
@@ -448,7 +448,7 @@ urlParseFinish(const HttpRequestMethod& method,
     }
 
     request->SetHost(host);
-    xstrncpy(request->login, login, MAX_LOGIN_SZ);
+    request->url.userInfo(login);
     request->port = (unsigned short) port;
     return request;
 }
@@ -491,10 +491,10 @@ urlCanonical(HttpRequest * request)
             if (request->port != urlDefaultPort(request->url.getScheme()))
                 snprintf(portbuf, 32, ":%d", request->port);
 
-            snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
+            snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s%s" SQUIDSTRINGPH,
                      request->url.getScheme().c_str(),
-                     request->login,
-                     *request->login ? "@" : null_string,
+                     SQUIDSBUFPRINT(request->url.userInfo()),
+                     !request->url.userInfo().isEmpty() ? "@" : "",
                      request->GetHost(),
                      portbuf,
                      SQUIDSTRINGPRINT(request->urlpath));
@@ -514,7 +514,6 @@ urlCanonicalClean(const HttpRequest * request)
 {
     LOCAL_ARRAY(char, buf, MAX_URL);
     LOCAL_ARRAY(char, portbuf, 32);
-    LOCAL_ARRAY(char, loginbuf, MAX_LOGIN_SZ + 1);
     char *t;
 
     if (request->url.getScheme() == AnyP::PROTO_URN) {
@@ -533,20 +532,10 @@ urlCanonicalClean(const HttpRequest * request)
             if (request->port != urlDefaultPort(request->url.getScheme()))
                 snprintf(portbuf, 32, ":%d", request->port);
 
-            loginbuf[0] = '\0';
-
-            if ((int) strlen(request->login) > 0) {
-                strcpy(loginbuf, request->login);
-
-                if ((t = strchr(loginbuf, ':')))
-                    *t = '\0';
-
-                strcat(loginbuf, "@");
-            }
-
-            snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
+            snprintf(buf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s%s" SQUIDSTRINGPH,
                      request->url.getScheme().c_str(),
-                     loginbuf,
+                     SQUIDSBUFPRINT(request->url.userInfo()),
+                     (request->url.userInfo().isEmpty() ? "" : "@"),
                      request->GetHost(),
                      portbuf,
                      SQUIDSTRINGPRINT(request->urlpath));
@@ -556,7 +545,7 @@ urlCanonicalClean(const HttpRequest * request)
                 if ((t = strchr(buf, '?')))
                     *(++t) = '\0';
         }
-        }
+        } // switch
     }
 
     if (stringHasCntl(buf))
@@ -644,18 +633,18 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
     size_t urllen;
 
     if (req->port != urlDefaultPort(req->url.getScheme())) {
-        urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s:%d",
+        urllen = snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s:%d",
                           req->url.getScheme().c_str(),
-                          req->login,
-                          *req->login ? "@" : null_string,
+                          SQUIDSBUFPRINT(req->url.userInfo()),
+                          !req->url.userInfo().isEmpty() ? "@" : "",
                           req->GetHost(),
                           req->port
                          );
     } else {
-        urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s",
+        urllen = snprintf(urlbuf, MAX_URL, "%s://" SQUIDSBUFPH "%s%s",
                           req->url.getScheme().c_str(),
-                          req->login,
-                          *req->login ? "@" : null_string,
+                          SQUIDSBUFPRINT(req->url.userInfo()),
+                          !req->url.userInfo().isEmpty() ? "@" : "",
                           req->GetHost()
                          );
     }
@@ -30,6 +30,7 @@
 
 class UrnState : public StoreClient
 {
+    CBDATA_CLASS(UrnState);
 
 public:
     void created (StoreEntry *newEntry);
@@ -56,8 +57,6 @@ class UrnState : public StoreClient
 
 private:
     char *urlres;
-
-    CBDATA_CLASS2(UrnState);
 };
 
 typedef struct {
@@ -27,6 +27,8 @@
 
 class WhoisState
 {
+    CBDATA_CLASS(WhoisState);
+
 public:
     void readReply(const Comm::ConnectionPointer &, char *aBuffer, size_t aBufferLength, Comm::Flag flag, int xerrno);
     void setReplyToOK(StoreEntry *sentry);
@@ -35,9 +37,6 @@ class WhoisState
     FwdState::Pointer fwd;
     char buf[BUFSIZ+1];		/* readReply adds terminating NULL */
     bool dataWritten;
-
-private:
-    CBDATA_CLASS2(WhoisState);
 };
 
 CBDATA_CLASS_INIT(WhoisState);