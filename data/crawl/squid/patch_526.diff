@@ -2,6 +2,7 @@
 #include "AccessLogEntry.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #include "ssl/support.h"
 
 #if USE_SSL
@@ -35,6 +35,7 @@
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
+#include "icp_opcode.h"
 #include "ip/Address.h"
 #include "HttpRequestMethod.h"
 #if ICAP_CLIENT
@@ -48,6 +49,7 @@
 /* forward decls */
 class HttpReply;
 class HttpRequest;
+class CustomLog;
 
 class AccessLogEntry: public RefCountable
 {
@@ -274,11 +276,11 @@ class ACLChecklist;
 class StoreEntry;
 
 /* Should be in 'AccessLog.h' as the driver */
-extern void accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
-extern void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
-extern void accessLogRotate(void);
-extern void accessLogClose(void);
-extern void accessLogInit(void);
-extern const char *accessLogTime(time_t);
+void accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
+void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
+void accessLogRotate(void);
+void accessLogClose(void);
+void accessLogInit(void);
+const char *accessLogTime(time_t);
 
 #endif /* SQUID_HTTPACCESSLOGENTRY_H */
@@ -1,8 +1,7 @@
 #ifndef SQUID_AUTHREG_H_
 #define SQUID_AUTHREG_H_
 /*
- * DEBUG: section
- * AUTHOR:
+ * DEBUG: section 29    Authenticator
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -41,7 +41,6 @@
 #if USE_CACHE_DIGESTS
 
 #include "CacheDigest.h"
-#include "structs.h"
 
 /* local types */
 
@@ -1,3 +1,5 @@
+#ifndef SQUID_CACHEDIGEST_H_
+#define SQUID_CACHEDIGEST_H_
 /*
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -30,25 +32,37 @@
  *
  */
 
-#ifndef SQUID_CACHEDIGEST_H_
-#define SQUID_CACHEDIGEST_H_
-
+/* for cache_key */
 #include "typedefs.h"
+
 class CacheDigestGuessStats;
 class StoreEntry;
 
-extern CacheDigest *cacheDigestCreate(int capacity, int bpe);
-extern void cacheDigestDestroy(CacheDigest * cd);
-extern CacheDigest *cacheDigestClone(const CacheDigest * cd);
-extern void cacheDigestClear(CacheDigest * cd);
-extern void cacheDigestChangeCap(CacheDigest * cd, int new_cap);
-extern int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
-extern void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
-extern void cacheDigestDel(CacheDigest * cd, const cache_key * key);
-extern size_t cacheDigestCalcMaskSize(int cap, int bpe);
-extern int cacheDigestBitUtil(const CacheDigest * cd);
-extern void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
-extern void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
-extern void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
+// currently a POD
+class CacheDigest
+{
+public:
+    /* public, read-only */
+    char *mask;         /* bit mask */
+    int mask_size;      /* mask size in bytes */
+    int capacity;       /* expected maximum for .count, not a hard limit */
+    int bits_per_entry;     /* number of bits allocated for each entry from capacity */
+    int count;          /* number of digested entries */
+    int del_count;      /* number of deletions performed so far */
+};
+
+CacheDigest *cacheDigestCreate(int capacity, int bpe);
+void cacheDigestDestroy(CacheDigest * cd);
+CacheDigest *cacheDigestClone(const CacheDigest * cd);
+void cacheDigestClear(CacheDigest * cd);
+void cacheDigestChangeCap(CacheDigest * cd, int new_cap);
+int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
+void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
+void cacheDigestDel(CacheDigest * cd, const cache_key * key);
+size_t cacheDigestCalcMaskSize(int cap, int bpe);
+int cacheDigestBitUtil(const CacheDigest * cd);
+void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
+void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
+void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
 
 #endif /* SQUID_CACHEDIGEST_H_ */
@@ -37,6 +37,8 @@
 #include "mgr/ActionProfile.h"
 #include "mgr/Command.h"
 #include "mgr/forward.h"
+#include "typedefs.h"
+
 #include <vector>
 
 /**
@@ -48,6 +50,9 @@
  */
 
 class HttpRequest;
+namespace Mgr {
+class ActionPasswordList;
+} //namespace Mgr
 /**
  \ingroup CacheManagerAPI
  * a CacheManager - the menu system for interacting with squid.
@@ -83,7 +88,7 @@ class CacheManager
     Mgr::CommandPointer ParseUrl(const char *url);
     void ParseHeaders(const HttpRequest * request, Mgr::ActionParams &params);
     int CheckPassword(const Mgr::Command &cmd);
-    char *PasswdGet(cachemgr_passwd *, const char *);
+    char *PasswdGet(Mgr::ActionPasswordList *, const char *);
 
     void registerProfile(const Mgr::ActionProfilePointer &profile);
 
@@ -0,0 +1,211 @@
+#ifndef SQUID_CACHEPEER_H_
+#define SQUID_CACHEPEER_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "enums.h"
+#include "icp_opcode.h"
+#include "ip/Address.h"
+
+//TODO: remove, it is unconditionally defined and always used.
+#define PEER_MULTICAST_SIBLINGS 1
+
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
+
+class acl_access;
+class CachePeerDomainList;
+class NeighborTypeDomainList;
+class PeerDigest;
+
+// currently a POD
+class CachePeer
+{
+public:
+    u_int index;
+    char *name;
+    char *host;
+    peer_t type;
+
+    Ip::Address in_addr;
+
+    struct {
+        int pings_sent;
+        int pings_acked;
+        int fetches;
+        int rtt;
+        int ignored_replies;
+        int n_keepalives_sent;
+        int n_keepalives_recv;
+        time_t probe_start;
+        time_t last_query;
+        time_t last_reply;
+        time_t last_connect_failure;
+        time_t last_connect_probe;
+        int logged_state;   /* so we can print dead/revived msgs */
+        int conn_open;      /* current opened connections */
+    } stats;
+
+    struct {
+        int version;
+        int counts[ICP_END+1];
+        unsigned short port;
+    } icp;
+
+#if USE_HTCP
+    struct {
+        double version;
+        int counts[2];
+        unsigned short port;
+    } htcp;
+#endif
+
+    unsigned short http_port;
+    CachePeerDomainList *peer_domain;
+    NeighborTypeDomainList *typelist;
+    acl_access *access;
+
+    struct {
+        unsigned int proxy_only:1;
+        unsigned int no_query:1;
+        unsigned int background_ping:1;
+        unsigned int no_digest:1;
+        unsigned int default_parent:1;
+        unsigned int roundrobin:1;
+        unsigned int weighted_roundrobin:1;
+        unsigned int mcast_responder:1;
+        unsigned int closest_only:1;
+#if USE_HTCP
+        unsigned int htcp:1;
+        unsigned int htcp_oldsquid:1;
+        unsigned int htcp_no_clr:1;
+        unsigned int htcp_no_purge_clr:1;
+        unsigned int htcp_only_clr:1;
+        unsigned int htcp_forward_clr:1;
+#endif
+        unsigned int no_netdb_exchange:1;
+#if USE_DELAY_POOLS
+        unsigned int no_delay:1;
+#endif
+        unsigned int allow_miss:1;
+        unsigned int carp:1;
+        struct {
+            unsigned int set:1; //If false, whole url is to be used. Overrides others
+            unsigned int scheme:1;
+            unsigned int host:1;
+            unsigned int port:1;
+            unsigned int path:1;
+            unsigned int params:1;
+        } carp_key;
+#if USE_AUTH
+        unsigned int userhash:1;
+#endif
+        unsigned int sourcehash:1;
+        unsigned int originserver:1;
+        unsigned int no_tproxy:1;
+#if PEER_MULTICAST_SIBLINGS
+        unsigned int mcast_siblings:1;
+#endif
+    } options;
+
+    int weight;
+    int basetime;
+
+    struct {
+        double avg_n_members;
+        int n_times_counted;
+        int n_replies_expected;
+        int ttl;
+        int id;
+
+        struct {
+            unsigned int count_event_pending:1;
+            unsigned int counting:1;
+        } flags;
+    } mcast;
+#if USE_CACHE_DIGESTS
+
+    PeerDigest *digest;
+    char *digest_url;
+#endif
+
+    int tcp_up;         /* 0 if a connect() fails */
+
+    Ip::Address addresses[10];
+    int n_addresses;
+    int rr_count;
+    CachePeer *next;
+    int testing_now;
+
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } carp;
+#if USE_AUTH
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } userhash;
+#endif
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } sourcehash;
+
+    char *login;        /* Proxy authorization */
+    time_t connect_timeout;
+    int connect_fail_limit;
+    int max_conn;
+    char *domain;       /* Forced domain */
+#if USE_SSL
+
+    int use_ssl;
+    char *sslcert;
+    char *sslkey;
+    int sslversion;
+    char *ssloptions;
+    char *sslcipher;
+    char *sslcafile;
+    char *sslcapath;
+    char *sslcrlfile;
+    char *sslflags;
+    char *ssldomain;
+    SSL_CTX *sslContext;
+    SSL_SESSION *sslSession;
+#endif
+
+    int front_end_https;
+    int connection_auth;
+};
+
+#endif /* SQUID_CACHEPEER_H_ */
@@ -0,0 +1,41 @@
+#ifndef SQUID_CACHEPEERDOMAINLIST_H_
+#define SQUID_CACHEPEERDOMAINLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// representation of the cache_peer_domain list. POD.
+class CachePeerDomainList
+{
+public:
+    char *domain;
+    bool do_ping;
+    CachePeerDomainList *next;
+};
+
+#endif /* SQUID_CACHEPEERDOMAINLIST_H_ */
@@ -30,11 +30,11 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-class StoreEntry;
-
 /* for Vector<> */
 #include "Array.h"
 
+class StoreEntry;
+
 /* cache option parsers */
 
 class ConfigOption
@@ -35,6 +35,7 @@
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
+#include "fatal.h"
 #include "globals.h"
 
 void
@@ -78,6 +78,6 @@ class ConfigParser
     static char * strtokFile();
 };
 
-extern int parseConfigFile(const char *file_name);
+int parseConfigFile(const char *file_name);
 
 #endif /* SQUID_CONFIGPARSER_H */
@@ -9,7 +9,7 @@
 #include "CpuAffinitySet.h"
 #include "Debug.h"
 #include "globals.h"
-#include "structs.h"
+#include "SquidConfig.h"
 #include "tools.h"
 
 #include <algorithm>
@@ -59,8 +59,8 @@
 
 /* context-based debugging, the actual type is subject to change */
 typedef int Ctx;
-extern Ctx ctx_enter(const char *descr);
-extern void ctx_exit(Ctx ctx);
+Ctx ctx_enter(const char *descr);
+void ctx_exit(Ctx ctx);
 
 /* defined debug section limits */
 #define MAX_DEBUG_SECTIONS 100
@@ -141,9 +141,9 @@ inline std::ostream& operator <<(std::ostream &os, const uint8_t d)
 #define old_debug(SECTION, LEVEL)  if do_debug((SECTION), (LEVEL)) _db_print
 
 /* Legacy debug function definitions */
-extern void _db_init(const char *logfile, const char *options);
-extern void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
-extern void _db_set_syslog(const char *facility);
-extern void _db_rotate_log(void);
+void _db_init(const char *logfile, const char *options);
+void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
+void _db_set_syslog(const char *facility);
+void _db_rotate_log(void);
 
 #endif /* SQUID_DEBUG_H */
@@ -39,6 +39,7 @@
 #if USE_DELAY_POOLS
 #include "DelayBucket.h"
 #include "DelaySpec.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 void
@@ -48,6 +48,7 @@
 #include "DelayPool.h"
 #include "DelayPools.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 
 DelayId::DelayId () : pool_ (0), compositeId(NULL), markedAsNoDelay(false)
 {}
@@ -41,6 +41,7 @@
 #include "fd.h"
 #include "Store.h"
 #include "StatCounters.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 #include "unlinkd.h"
@@ -38,8 +38,8 @@
 #include "DiskThreadsIOStrategy.h"
 #include "fde.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
-/* for statfs */
 #include "Store.h"
 
 void
@@ -36,16 +36,17 @@
 
 #include "squid.h"
 #include "DiskThreads.h"
-
-#include	<stdio.h>
-#include	<sys/stat.h>
-#include	<fcntl.h>
-#include	<pthread.h>
-#include	<errno.h>
-#include	<dirent.h>
-#include	<signal.h>
+#include "SquidConfig.h"
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <errno.h>
+#include <dirent.h>
+#include <signal.h>
 #if HAVE_SCHED_H
-#include	<sched.h>
+#include <sched.h>
 #endif
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "SquidTime.h"
@@ -36,15 +36,16 @@
 #include "squid_windows.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "DiskThreads.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
-#include	<stdio.h>
-#include	<sys/stat.h>
-#include	<fcntl.h>
-#include	<errno.h>
-#include	<dirent.h>
-#include	<signal.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <signal.h>
 
 #define RIDICULOUS_LENGTH	4096
 
@@ -18,6 +18,7 @@
 #include "ipc/Queue.h"
 #include "ipc/StrandSearch.h"
 #include "ipc/UdsOp.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "tools.h"
@@ -5,7 +5,6 @@
 #ifndef SQUID_DNS_LOOKUP_DETAILS_H
 #define SQUID_DNS_LOOKUP_DETAILS_H
 
-#include "typedefs.h"
 #include "SquidString.h"
 
 /// encapsulates DNS lookup results
@@ -14,10 +14,10 @@ class ETag
 };
 
 /* ETag */
-SQUIDCEXTERN int etagParseInit(ETag * etag, const char *str);
+int etagParseInit(ETag * etag, const char *str);
 /// whether etags are strong-equal
-SQUIDCEXTERN bool etagIsStrongEqual(const ETag &tag1, const ETag &tag2);
+bool etagIsStrongEqual(const ETag &tag1, const ETag &tag2);
 /// whether etags are weak-equal
-SQUIDCEXTERN bool etagIsWeakEqual(const ETag &tag1, const ETag &tag2);
+bool etagIsWeakEqual(const ETag &tag1, const ETag &tag2);
 
 #endif /* _SQUIDETAG_H */
@@ -31,9 +31,11 @@
  */
 
 #include "squid.h"
+#include "AsyncEngine.h"
 #include "Debug.h"
 #include "EventLoop.h"
 #include "base/AsyncCallQueue.h"
+#include "SquidTime.h"
 
 EventLoop::EventLoop() : errcount(0), last_loop(false), timeService(NULL),
         primaryEngine(NULL)
@@ -32,11 +32,12 @@
 #define SQUID_EVENTLOOP_H
 
 #include "Array.h"
-#include "AsyncEngine.h"
-#include "SquidTime.h"
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
+class AsyncEngine;
+class TimeEngine;
+
 /** An event loop. An event loop is the core inner loop of squid.
  * The event loop can be run until exit, or once. After it finishes control
  * returns to the caller. If desired it can be run again.
@@ -33,6 +33,8 @@
 #define SQUID_EXTERNALACL_H
 
 #include "acl/Checklist.h"
+class external_acl;
+class StoreEntry;
 
 /** \todo CLEANUP: kill this typedef. */
 typedef struct _external_acl_data external_acl_data;
@@ -91,15 +93,12 @@ class ACLExternal : public ACL
 
 MEMPROXY_CLASS_INLINE(ACLExternal);
 
-class ACLChecklist;
-class StoreEntry;
-
-extern void parse_externalAclHelper(external_acl **);
-extern void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
-extern void free_externalAclHelper(external_acl **);
+void parse_externalAclHelper(external_acl **);
+void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
+void free_externalAclHelper(external_acl **);
 typedef void EAH(void *data, void *result);
-extern void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
-extern void externalAclInit(void);
-extern void externalAclShutdown(void);
+void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
+void externalAclInit(void);
+void externalAclShutdown(void);
 
 #endif /* SQUID_EXTERNALACL_H */
@@ -44,7 +44,10 @@
 
 #include "acl/Acl.h"
 #include "cbdata.h"
+#include "hash.h"
+#include "SquidString.h"
 
+class external_acl;
 /******************************************************************
  * ExternalACLEntryData
  * Core data that ExternalACLEntry manages.
@@ -34,6 +34,7 @@
 
 #include "comm/Connection.h"
 #include "hier_code.h"
+#include "HttpStatusCode.h"
 #include "lookup_t.h"
 #include "rfc2181.h"
 #include "PingData.h"
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "base/StringArea.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "HttpHdrCc.h"
@@ -34,9 +34,10 @@
 
 #include "enums.h"
 #include "MemPool.h"
-#include "Packer.h"
 #include "SquidString.h"
 
+class Packer;
+
 /** Http Cache-Control header representation
  *
  * Store and parse the Cache-Control HTTP header.
@@ -181,10 +182,10 @@ MEMPROXY_CLASS_INLINE(HttpHdrCc);
 class StatHist;
 class StoreEntry;
 
-extern void httpHdrCcInitModule(void);
-extern void httpHdrCcCleanModule(void);
-extern void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
-extern void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrCcInitModule(void);
+void httpHdrCcCleanModule(void);
+void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
+void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #if _USE_INLINE_
 #include "HttpHdrCc.cci"
@@ -46,15 +46,15 @@ class HttpHdrContRange
 
 /** \todo CLEANUP: Move httpHdrContRange* functions into the class methods */
 
-SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeCreate(void);
-SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
+HttpHdrContRange *httpHdrContRangeCreate(void);
+HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
 /** returns true if range is valid; inits HttpHdrContRange */
-SQUIDCEXTERN int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
-SQUIDCEXTERN void httpHdrContRangeDestroy(HttpHdrContRange * crange);
-SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
-SQUIDCEXTERN void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
+int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
+void httpHdrContRangeDestroy(HttpHdrContRange * crange);
+HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
+void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
 /** inits with given spec */
-SQUIDCEXTERN void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
-SQUIDCEXTERN void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
+void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
+void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
 
 #endif /* SQUID_HTTPHDRCONTRANGE_H */
@@ -36,6 +36,7 @@
 #include "HttpHeaderRange.h"
 #include "client_side_request.h"
 #include "HttpReply.h"
+#include "HttpHeaderTools.h"
 #include "StrList.h"
 
 /*
@@ -37,6 +37,8 @@
 #include "squid.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
+#include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "Store.h"
@@ -69,10 +69,10 @@ class HttpHdrSc
 MEMPROXY_CLASS_INLINE(HttpHdrSc);
 
 /* Http Surrogate Control Header Field */
-extern void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
-extern void httpHdrScInitModule (void);
-extern void httpHdrScCleanModule (void);
-extern HttpHdrSc *httpHdrScParseCreate(String const &);
-extern void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
+void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrScInitModule (void);
+void httpHdrScCleanModule (void);
+HttpHdrSc *httpHdrScParseCreate(String const &);
+void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROL_H */
@@ -126,6 +126,6 @@ class HttpHdrScTarget
 
 MEMPROXY_CLASS_INLINE(HttpHdrScTarget);
 
-extern void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROLTARGET_H */
@@ -36,6 +36,7 @@
 #include "HttpHdrContRange.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "MemBuf.h"
@@ -45,6 +46,7 @@
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "TimeOrTag.h"
 
@@ -32,16 +32,16 @@
 #define SQUID_HTTPHEADER_H
 
 /* because we pass a spec by value */
-#include "HttpHeaderRange.h"
-/* HttpHeader holds a HttpHeaderMask */
 #include "HttpHeaderMask.h"
+#include "MemPool.h"
+#include "SquidString.h"
 
 /* class forward declarations */
-class HttpHdrContRange;
 class HttpHdrCc;
-class HttpHdrSc;
+class HttpHdrContRange;
 class HttpHdrRange;
-class String;
+class HttpHdrSc;
+class Packer;
 class StoreEntry;
 
 /* constant attributes of http header fields */
@@ -178,7 +178,10 @@ typedef enum {
     hoEnd
 } http_hdr_owner_type;
 
-struct _HttpHeaderFieldAttrs {
+// currently a POD
+class HttpHeaderFieldAttrs
+{
+public:
     const char *name;
     http_hdr_type id;
     field_type type;
@@ -289,10 +292,10 @@ class HttpHeader
     HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
 };
 
-extern int httpHeaderParseQuotedString(const char *start, const int len, String *val);
-extern int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-extern void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
-extern void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
+int httpHeaderParseQuotedString(const char *start, const int len, String *val);
+int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
+void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
+void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
@@ -301,7 +304,7 @@ HttpHeader::chunked() const
            hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
 }
 
-extern void httpHeaderInitModule(void);
-extern void httpHeaderCleanModule(void);
+void httpHeaderInitModule(void);
+void httpHeaderCleanModule(void);
 
 #endif /* SQUID_HTTPHEADER_H */
@@ -0,0 +1,47 @@
+#ifndef SQUID_HTTPHEADERFIELDINFO_H_
+#define SQUID_HTTPHEADERFIELDINFO_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "SquidString.h"
+#include "HttpHeaderFieldStat.h"
+
+/// compiled version of HttpHeaderFieldAttrs plus stats. Currently a POD.
+class HttpHeaderFieldInfo
+{
+public:
+    HttpHeaderFieldInfo() : id(HDR_ACCEPT), type(ftInvalid) {}
+
+    http_hdr_type id;
+    String name;
+    field_type type;
+    HttpHeaderFieldStat stat;
+};
+
+#endif /* SQUID_HTTPHEADERFIELDINFO_H_ */
@@ -0,0 +1,45 @@
+#ifndef SQUID_HTTPHEADERFIELDSTAT_H_
+#define SQUID_HTTPHEADERFIELDSTAT_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// per field statistics. Currently a POD.
+class HttpHeaderFieldStat
+{
+public:
+    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0) {}
+
+    int aliveCount;     /* created but not destroyed (count) */
+    int seenCount;      /* number of fields we've seen */
+    int parsCount;      /* number of parsing attempts */
+    int errCount;       /* number of pasring errors */
+    int repCount;       /* number of repetitons */
+};
+
+#endif /* SQUID_HTTPHEADERFIELDSTAT_H_ */
@@ -33,6 +33,6 @@
 /* big mask for http headers */
 typedef char HttpHeaderMask[12];
 
-SQUIDCEXTERN void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
+void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
 
 #endif /* SQUID_HTTPHEADERMASK_H */
@@ -32,10 +32,10 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "MemPool.h"
-#include "Range.h"
 #include "Array.h"
+#include "MemPool.h"
 #include "Packer.h"
+#include "Range.h"
 #include "SquidString.h"
 
 class HttpReply;
@@ -40,9 +40,11 @@
 #include "fde.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderTools.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StrList.h"
 
@@ -325,7 +327,7 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
     if (!hms)
         return 1;
 
-    const header_mangler *hm = hms->find(*e);
+    const headerMangler *hm = hms->find(*e);
 
     /* mangler or checklist went away. default allow */
     if (!hm || !hm->access_list) {
@@ -369,15 +371,15 @@ httpHdrMangleList(HttpHeader * l, HttpRequest * request, int req_or_rep)
 }
 
 static
-void header_mangler_clean(header_mangler &m)
+void header_mangler_clean(headerMangler &m)
 {
     aclDestroyAccessList(&m.access_list);
     safe_free(m.replacement);
 }
 
 static
 void header_mangler_dump_access(StoreEntry * entry, const char *option,
-                                const header_mangler &m, const char *name)
+                                const headerMangler &m, const char *name)
 {
     if (m.access_list != NULL) {
         storeAppendPrintf(entry, "%s ", option);
@@ -387,7 +389,7 @@ void header_mangler_dump_access(StoreEntry * entry, const char *option,
 
 static
 void header_mangler_dump_replacement(StoreEntry * entry, const char *option,
-                                     const header_mangler &m, const char *name)
+                                     const headerMangler &m, const char *name)
 {
     if (m.replacement)
         storeAppendPrintf(entry, "%s %s %s\n", option, name, m.replacement);
@@ -443,7 +445,7 @@ HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
     header_mangler_dump_replacement(entry, name, all, "All");
 }
 
-header_mangler *
+headerMangler *
 HeaderManglers::track(const char *name)
 {
     int id = httpHeaderIdByNameDef(name, strlen(name));
@@ -455,7 +457,7 @@ HeaderManglers::track(const char *name)
             id = HDR_OTHER;
     }
 
-    header_mangler *m = NULL;
+    headerMangler *m = NULL;
     if (id == HDR_ENUM_END) {
         m = &all;
     } else if (id == HDR_BAD_HDR) {
@@ -473,13 +475,13 @@ HeaderManglers::setReplacement(const char *name, const char *value)
 {
     // for backword compatibility, we allow replacements to be configured
     // for headers w/o access rules, but such replacements are ignored
-    header_mangler *m = track(name);
+    headerMangler *m = track(name);
 
     safe_free(m->replacement); // overwrite old value if any
     m->replacement = xstrdup(value);
 }
 
-const header_mangler *
+const headerMangler *
 HeaderManglers::find(const HttpHeaderEntry &e) const
 {
     // a known header with a configured ACL list
@@ -15,30 +15,37 @@
 #include <string>
 #endif
 
+class acl_access;
+class ACLList;
 class HeaderWithAcl;
+class HttpHeader;
+class HttpHeaderFieldInfo;
+class HttpRequest;
+class StoreEntry;
+class String;
+
 typedef std::list<HeaderWithAcl> HeaderWithAclList;
 
-class acl_access;
-struct _header_mangler {
+// Currently a POD
+class headerMangler
+{
+public:
     acl_access *access_list;
     char *replacement;
 };
-typedef struct _header_mangler header_mangler;
-
-class StoreEntry;
 
-/// A collection of header_mangler objects for a given message kind.
+/// A collection of headerMangler objects for a given message kind.
 class HeaderManglers
 {
 public:
     HeaderManglers();
     ~HeaderManglers();
 
     /// returns a header mangler for field e or nil if none was specified
-    const header_mangler *find(const HttpHeaderEntry &e) const;
+    const headerMangler *find(const HttpHeaderEntry &e) const;
 
     /// returns a mangler for the named header (known or custom)
-    header_mangler *track(const char *name);
+    headerMangler *track(const char *name);
 
     /// updates mangler for the named header with a replacement value
     void setReplacement(const char *name, const char *replacementValue);
@@ -50,24 +57,23 @@ class HeaderManglers
 
 private:
     /// a name:mangler map; optimize: use unordered map or some such
-    typedef std::map<std::string, header_mangler> ManglersByName;
+    typedef std::map<std::string, headerMangler> ManglersByName;
 
     /// one mangler for each known header
-    header_mangler known[HDR_ENUM_END];
+    headerMangler known[HDR_ENUM_END];
 
     /// one mangler for each custom header
     ManglersByName custom;
 
     /// configured if some mangling ACL applies to all header names
-    header_mangler all;
+    headerMangler all;
 
 private:
     /* not implemented */
     HeaderManglers(const HeaderManglers &);
     HeaderManglers &operator =(const HeaderManglers &);
 };
 
-class ACLList;
 class HeaderWithAcl
 {
 public:
@@ -92,24 +98,19 @@ class HeaderWithAcl
     bool quoted;
 };
 
-extern int httpHeaderParseOffset(const char *start, int64_t * off);
-
-class HttpHeaderFieldInfo;
-class String;
-class HttpHeader;
-class HttpRequest;
+int httpHeaderParseOffset(const char *start, int64_t * off);
 
-extern HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
-extern void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
-extern http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
-extern http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
-extern const char *httpHeaderNameById(int id);
-extern int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
-extern int httpHeaderParseInt(const char *start, int *val);
-extern void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
+HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
+void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
+http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
+http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
+const char *httpHeaderNameById(int id);
+int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
+int httpHeaderParseInt(const char *start, int *val);
+void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
 
-extern const char *getStringPrefix(const char *str, const char *end);
+const char *getStringPrefix(const char *str, const char *end);
 
-extern void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
+void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
 
 #endif
@@ -38,6 +38,7 @@
 #include "MemBuf.h"
 #include "mime_header.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
         cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
@@ -1,8 +1,8 @@
 #include "squid.h"
 #include "Debug.h"
 #include "HttpParser.h"
-#include "structs.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 void
 HttpParser::clear()
@@ -79,14 +79,14 @@ class HttpParser
 
 // Legacy functions
 #define HttpParserInit(h,b,l) (h)->reset((b),(l))
-extern int HttpParserParseReqLine(HttpParser *hp);
+int HttpParserParseReqLine(HttpParser *hp);
 
 #define MSGDODEBUG 0
 #if MSGDODEBUG
-extern int HttpParserReqSz(HttpParser *);
-extern int HttpParserHdrSz(HttpParser *);
-extern const char * HttpParserHdrBuf(HttpParser *);
-extern int HttpParserRequestLen(HttpParser *hp);
+int HttpParserReqSz(HttpParser *);
+int HttpParserHdrSz(HttpParser *);
+const char * HttpParserHdrBuf(HttpParser *);
+int HttpParserRequestLen(HttpParser *hp);
 #else
 #define HttpParserReqSz(hp)     ( (hp)->req.end - (hp)->req.start + 1 )
 #define HttpParserHdrSz(hp)     ( (hp)->hdr_end - (hp)->hdr_start + 1 )
@@ -32,6 +32,7 @@
  */
 
 #include "squid.h"
+#include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "globals.h"
 #include "HttpBody.h"
@@ -41,6 +42,7 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
@@ -596,7 +598,7 @@ HttpReply::calcMaxBodySize(HttpRequest& request)
 
     ACLFilledChecklist ch(NULL, &request, NULL);
     ch.reply = HTTPMSGLOCK(this); // XXX: this lock makes method non-const
-    for (acl_size_t *l = Config.ReplyBodySize; l; l = l -> next) {
+    for (AclSizeLimit *l = Config.ReplyBodySize; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this size value */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
             debugs(58, 4, HERE << "bodySizeMax=" << bodySizeMax);
@@ -35,11 +35,11 @@
 #include "HttpRequest.h"
 #include "HttpStatusLine.h"
 
-extern void httpReplyInitModule(void);
+void httpReplyInitModule(void);
 
 #if DEAD_CODE
 /** do everything in one call: init, set, pack, clean, return MemBuf */
-extern MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
+MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
 #endif
 
 /* Sync changes here with HttpReply.cc */
@@ -33,6 +33,7 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
+#include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "DnsLookupDetails.h"
@@ -45,6 +46,7 @@
 #include "HttpRequest.h"
 #include "log/Config.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 
@@ -419,27 +421,6 @@ HttpRequest::hdrCacheInit()
     range = header.getRange();
 }
 
-/* request_flags */
-bool
-request_flags::resetTCP() const
-{
-    return reset_tcp != 0;
-}
-
-void
-request_flags::setResetTCP()
-{
-    debugs(73, 9, "request_flags::setResetTCP");
-    reset_tcp = 1;
-}
-
-void
-request_flags::clearResetTCP()
-{
-    debugs(73, 9, "request_flags::clearResetTCP");
-    reset_tcp = 0;
-}
-
 #if ICAP_CLIENT
 Adaptation::Icap::History::Pointer
 HttpRequest::icapHistory() const
@@ -492,27 +473,6 @@ HttpRequest::multipartRangeRequest() const
     return (range && range->specs.count > 1);
 }
 
-void
-request_flags::destinationIPLookupCompleted()
-{
-    destinationIPLookedUp_ = true;
-}
-
-bool
-request_flags::destinationIPLookedUp() const
-{
-    return destinationIPLookedUp_;
-}
-
-request_flags
-request_flags::cloneAdaptationImmune() const
-{
-    // At the time of writing, all flags where either safe to copy after
-    // adaptation or were not set at the time of the adaptation. If there
-    // are flags that are different, they should be cleared in the clone.
-    return *this;
-}
-
 bool
 HttpRequest::bodyNibbled() const
 {
@@ -622,7 +582,7 @@ HttpRequest::cacheable() const
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoof_client_ip))
+    if (!flags.hostVerified && (flags.intercepted || flags.spoofClientIp))
         return false;
 
     if (protocol == AnyP::PROTO_HTTP)
@@ -683,7 +643,7 @@ HttpRequest::getRangeOffsetLimit()
     ch.src_addr = client_addr;
     ch.my_addr =  my_addr;
 
-    for (acl_size_t *l = Config.rangeOffsetLimit; l; l = l -> next) {
+    for (AclSizeLimit *l = Config.rangeOffsetLimit; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this limit value */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
             debugs(58, 4, HERE << "rangeOffsetLimit=" << rangeOffsetLimit);
@@ -33,9 +33,11 @@
 
 #include "base/CbcPointer.h"
 #include "Debug.h"
+#include "err_type.h"
 #include "HierarchyLogEntry.h"
 #include "HttpMsg.h"
 #include "HttpRequestMethod.h"
+#include "RequestFlags.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -55,7 +57,7 @@ class ConnStateData;
 
 /*  Http Request */
 //DEAD?: extern int httpRequestHdrAllowedByName(http_hdr_type id);
-extern void httpRequestPack(void *obj, Packer *p);
+void httpRequestPack(void *obj, Packer *p);
 
 class HttpHdrRange;
 class DnsLookupDetails;
@@ -161,7 +163,7 @@ class HttpRequest: public HttpMsg
 
     char *canonical;
 
-    request_flags flags;
+    RequestFlags flags;
 
     HttpHdrRange *range;
 
@@ -32,7 +32,8 @@
 #define SQUID_HTTPREQUESTMETHOD_H
 
 #include "SquidString.h"
-#include "structs.h"
+
+class SquidConfig;
 
 #include <iosfwd>
 
@@ -0,0 +1,53 @@
+#ifndef SQUID_HTTPSTATEFLAGS_H_
+#define SQUID_HTTPSTATEFLAGS_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+// POD
+class HttpStateFlags
+{
+public:
+    bool proxying:1;
+    bool keepalive:1;
+    bool only_if_cached:1;
+    bool handling1xx:1; ///< we are ignoring or forwarding 1xx response
+    bool headers_parsed:1;
+    unsigned int front_end_https:2; //XXX: huh?
+    bool originpeer:1;
+    bool keepalive_broken:1;
+    bool abuse_detected:1;
+    bool request_sent:1;
+    bool do_next_read:1;
+    bool consume_body_data:1; //XXX: seems unused
+    bool chunked:1; ///< reading a chunked response; TODO: rename
+    bool chunked_request:1; ///< writing a chunked request
+    bool sentLastChunk:1; ///< do not try to write last-chunk again
+};
+
+#endif /* SQUID_HTTPSTATEFLAGS_H_ */
@@ -76,6 +76,7 @@ struct _icp_common_t {
     icp_opcode getOpCode() const;
 #endif
 };
+typedef struct _icp_common_t icp_common_t;
 
 #ifdef __cplusplus
 
@@ -131,51 +132,51 @@ extern Comm::ConnectionPointer icpOutgoingConn;
 extern Ip::Address theIcpPublicHostID;
 
 /// \ingroup ServerProtocolICPAPI
-extern HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
+HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-extern bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
+bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
+void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-extern icp_opcode icpGetCommonOpcode();
+icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN log_type icpLogFromICPCode(icp_opcode opcode);
+log_type icpLogFromICPCode(icp_opcode opcode);
 
 /// \ingroup ServerProtocolICPAPI
 void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN PF icpHandleUdp;
+PF icpHandleUdp;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN PF icpUdpSendQueue;
+PF icpUdpSendQueue;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpHandleIcpV3(int, Ip::Address &, char *, int);
+void icpHandleIcpV3(int, Ip::Address &, char *, int);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
+int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpOpenPorts(void);
+void icpOpenPorts(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionShutdown(void);
+void icpConnectionShutdown(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpClosePorts(void);
+void icpClosePorts(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpSetCacheKey(const cache_key * key);
+int icpSetCacheKey(const cache_key * key);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN const cache_key *icpGetCacheKey(const char *url, int reqnum);
+const cache_key *icpGetCacheKey(const char *url, int reqnum);
 
 #endif /* SQUID_ICP_H */
@@ -0,0 +1,48 @@
+#ifndef SQUID_IOSTATS_H_
+#define SQUID_IOSTATS_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// IO statistics. Currently a POD.
+class IoStats
+{
+public:
+    static const int histSize=16;
+
+    struct {
+        int reads;
+        int reads_deferred;
+        int read_hist[histSize];
+        int writes;
+        int write_hist[histSize];
+    }
+    Http, Ftp, Gopher;
+};
+
+#endif /* SQUID_IOSTATS_H_ */
@@ -5,6 +5,6 @@
 // TODO: add reconfiguration support
 
 class wordlist;
-extern void LoadableModulesConfigure(const wordlist *names);
+void LoadableModulesConfigure(const wordlist *names);
 
 #endif /* SQUID_LOADABLE_MODULES_H */
@@ -57,6 +57,7 @@ endif
 DIST_SUBDIRS += ssl
 
 SNMP_ALL_SOURCE = \
+	SnmpRequest.h \
 	snmp_core.h \
 	snmp_core.cc \
 	snmp_agent.h \
@@ -258,6 +259,7 @@ libsquid_la_SOURCES = \
 	CommCalls.h \
 	DescriptorSet.cc \
 	DescriptorSet.h \
+	SquidConfig.h \
 	SquidConfig.cc
 
 squid_SOURCES = \
@@ -268,10 +270,16 @@ squid_SOURCES = \
 	AsyncEngine.h \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	cache_manager.cc \
+	NeighborTypeDomainList.h \
+	CachePeerDomainList.h \
+	CachePeer.h \
 	CacheManager.h \
 	carp.h \
 	carp.cc \
@@ -357,11 +365,13 @@ squid_SOURCES = \
 	hier_code.h \
 	HierarchyLogEntry.h \
 	$(HTCPSOURCE) \
+	HttpStateFlags.h \
 	http.cc \
 	http.h \
 	HttpStatusCode.h \
 	HttpStatusLine.cc \
 	HttpStatusLine.h \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -377,6 +387,7 @@ squid_SOURCES = \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
 	HttpHeaderRange.h \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpBody.h \
@@ -388,6 +399,8 @@ squid_SOURCES = \
 	HttpParser.h \
 	HttpReply.cc \
 	HttpReply.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequest.h \
 	HttpRequestMethod.cc \
@@ -457,6 +470,7 @@ squid_SOURCES = \
 	SquidMath.h \
 	SquidMath.cc \
 	SquidNew.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -515,7 +529,6 @@ squid_SOURCES = \
 	StoreSwapLogData.h \
 	Server.cc \
 	Server.h \
-	structs.h \
 	swap_log_op.h \
 	SwapDir.cc \
 	SwapDir.h \
@@ -704,7 +717,6 @@ recv_announce_SOURCES = recv-announce.cc
 ## mem.cc wants ClientInfo.h
 ## libbase.la wants cbdata.*
 ## libbase.la wants MemBuf.*
-## structs.h wants HelperChildConfig.* (stub it)
 ufsdump_SOURCES = \
 	ClientInfo.h \
 	cbdata.h \
@@ -1106,6 +1118,7 @@ tests_testHttpReply_SOURCES=\
 	ETag.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1119,6 +1132,7 @@ tests_testHttpReply_SOURCES=\
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpControlMsg.h \
@@ -1131,6 +1145,8 @@ tests_testHttpReply_SOURCES=\
 	HttpStatusLine.h \
 	Mem.h \
 	mem.cc \
+	RegexList.h \
+	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
 	mime_header.h \
@@ -1145,6 +1161,7 @@ tests_testHttpReply_SOURCES=\
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -1207,10 +1224,12 @@ tests_testACLMaxUserIP_SOURCES= \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1253,6 +1272,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
@@ -1349,6 +1369,8 @@ tests_testCacheManager_SOURCES = \
 	debug.cc \
 	HttpParser.cc \
 	HttpParser.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
@@ -1365,6 +1387,9 @@ tests_testCacheManager_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
@@ -1415,13 +1440,16 @@ tests_testCacheManager_SOURCES = \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
 	$(HTCPSOURCE) \
+	HttpStateFlags.h \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1473,6 +1501,7 @@ tests_testCacheManager_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -1593,13 +1622,15 @@ tests_testDiskIO_SOURCES = \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHdrRange.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -1622,6 +1653,8 @@ tests_testDiskIO_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -1653,6 +1686,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc \
@@ -1748,6 +1782,9 @@ tests_testEvent_SOURCES = \
 	CacheDigest.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	cache_manager.cc \
 	carp.h \
@@ -1806,8 +1843,10 @@ tests_testEvent_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1819,6 +1858,8 @@ tests_testEvent_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -1867,6 +1908,7 @@ tests_testEvent_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -1981,6 +2023,9 @@ tests_testEventLoop_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	carp.h \
 	carp.cc \
@@ -2038,8 +2083,10 @@ tests_testEventLoop_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2051,6 +2098,8 @@ tests_testEventLoop_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -2097,6 +2146,7 @@ tests_testEventLoop_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -2209,6 +2259,9 @@ tests_test_http_range_SOURCES = \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
@@ -2265,6 +2318,7 @@ tests_test_http_range_SOURCES = \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2274,12 +2328,15 @@ tests_test_http_range_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -2326,6 +2383,7 @@ tests_test_http_range_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -2428,7 +2486,6 @@ tests_test_http_range_LDFLAGS = $(LIBADD_DL)
 tests_test_http_range_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
-
 tests_testHttpParser_SOURCES = \
 	Debug.h \
 	HttpParser.cc \
@@ -2438,8 +2495,8 @@ tests_testHttpParser_SOURCES = \
 	Mem.h \
 	mem.cc \
 	String.cc \
-	structs.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -2473,6 +2530,8 @@ tests_testHttpRequest_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	HttpParser.cc \
 	HttpParser.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
@@ -2492,6 +2551,9 @@ tests_testHttpRequest_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	debug.cc \
 	CacheDigest.h \
@@ -2544,8 +2606,10 @@ tests_testHttpRequest_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2597,6 +2661,7 @@ tests_testHttpRequest_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -2712,19 +2777,23 @@ tests_testStore_SOURCES= \
 	EventLoop.cc \
 	FileMap.h \
 	filemap.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpRequestMethod.cc \
+	RequestFlags.cc \
+	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
@@ -2769,6 +2838,7 @@ tests_testStore_SOURCES= \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_side_request.cc \
@@ -2867,6 +2937,7 @@ tests_testString_SOURCES = \
 	tests/testString.cc \
 	tests/testString.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -2943,6 +3014,8 @@ tests_testUfs_SOURCES = \
 	HttpStatusLine.cc \
 	int.h \
 	int.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MemObject.cc \
@@ -2980,6 +3053,7 @@ tests_testUfs_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -2991,6 +3065,7 @@ tests_testUfs_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3001,6 +3076,7 @@ tests_testUfs_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3090,6 +3166,7 @@ tests_testRock_SOURCES = \
 	fd.cc \
 	FileMap.h \
 	filemap.cc \
+	HttpHeaderFieldStat.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHdrCc.cc \
@@ -3099,6 +3176,7 @@ tests_testRock_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
@@ -3117,6 +3195,8 @@ tests_testRock_SOURCES = \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
+	RequestFlags.cc \
+	RequestFlags.h \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -3152,6 +3232,7 @@ tests_testRock_SOURCES = \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	client_db.h \
@@ -3288,6 +3369,7 @@ tests_testCoss_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -3298,6 +3380,7 @@ tests_testCoss_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3308,6 +3391,7 @@ tests_testCoss_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3439,6 +3523,7 @@ tests_testNull_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -3451,6 +3536,7 @@ tests_testNull_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3461,6 +3547,7 @@ tests_testNull_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3530,6 +3617,9 @@ tests_testURL_SOURCES = \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
@@ -3585,6 +3675,7 @@ tests_testURL_SOURCES = \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3594,12 +3685,15 @@ tests_testURL_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -3646,6 +3740,7 @@ tests_testURL_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -3681,8 +3776,8 @@ tests_testURL_SOURCES = \
 	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
-    StrList.h \
-    StrList.cc \
+	StrList.h \
+	StrList.cc \
 	SwapDir.cc \
 	MemStore.cc \
 	tests/stub_debug.cc \
@@ -3765,6 +3860,7 @@ tests_testConfigParser_SOURCES = \
 	tests/testConfigParser.cc \
 	tests/testConfigParser.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -62,21 +62,21 @@ class Mem
 
 extern const size_t squidSystemPageSize;
 
-extern void memClean(void);
-extern void memInitModule(void);
-extern void memCleanModule(void);
-extern void memConfigure(void);
-extern void *memAllocate(mem_type);
-extern void *memAllocString(size_t net_size, size_t * gross_size);
-extern void *memAllocBuf(size_t net_size, size_t * gross_size);
-extern void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
-extern void memFree(void *, int type);
-extern void memFreeString(size_t size, void *);
-extern void memFreeBuf(size_t size, void *);
-extern FREE *memFreeBufFunc(size_t size);
-extern int memInUse(mem_type);
-extern void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
-extern void memCheckInit(void);
-extern void memConfigure(void);
+void memClean(void);
+void memInitModule(void);
+void memCleanModule(void);
+void memConfigure(void);
+void *memAllocate(mem_type);
+void *memAllocString(size_t net_size, size_t * gross_size);
+void *memAllocBuf(size_t net_size, size_t * gross_size);
+void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
+void memFree(void *, int type);
+void memFreeString(size_t size, void *);
+void memFreeBuf(size_t size, void *);
+FREE *memFreeBufFunc(size_t size);
+int memInUse(mem_type);
+void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
+void memCheckInit(void);
+void memConfigure(void);
 
 #endif /* SQUID_MEM */
@@ -40,6 +40,7 @@
 #include "MemBuf.h"
 #include "MemObject.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
@@ -31,20 +31,23 @@
 #ifndef SQUID_MEMOBJECT_H
 #define SQUID_MEMOBJECT_H
 
-#include "StoreIOBuffer.h"
-#include "StoreIOState.h"
-#include "stmem.h"
 #include "CommRead.h"
-#include "RemovalPolicy.h"
+#include "dlink.h"
 #include "HttpRequestMethod.h"
+#include "RemovalPolicy.h"
+#include "stmem.h"
+#include "StoreIOBuffer.h"
+#include "StoreIOState.h"
+
+#if USE_DELAY_POOLS
+#include "DelayId.h"
+#endif
 
 typedef void STMCB (void *data, StoreIOBuffer wroteBuffer);
 
 class store_client;
 class HttpRequest;
-#if USE_DELAY_POOLS
-#include "DelayId.h"
-#endif
+class HttpReply;
 
 class MemObject
 {
@@ -11,6 +11,7 @@
 #include "MemObject.h"
 #include "MemStore.h"
 #include "mime_header.h"
+#include "SquidConfig.h"
 #include "StoreStats.h"
 #include "tools.h"
 
@@ -0,0 +1,41 @@
+#ifndef SQUID_NEIGHBORTYPEDOMAINLIST_H_
+#define SQUID_NEIGHBORTYPEDOMAINLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// representation of a neighbor_type_domain configuration directive. A POD
+class NeighborTypeDomainList
+{
+public:
+    char *domain;
+    peer_t type;
+    NeighborTypeDomainList *next;
+};
+
+#endif /* SQUID_NEIGHBORTYPEDOMAINLIST_H_ */
@@ -36,34 +36,34 @@
 
 #include "ip/Address.h"
 
-extern double xatof(const char *token);
-extern int xatoi(const char *token);
-extern long xatol(const char *token);
-extern unsigned short xatos(const char *token);
+double xatof(const char *token);
+int xatoi(const char *token);
+long xatol(const char *token);
+unsigned short xatos(const char *token);
 
 /**
  * Parse a 64-bit integer value.
  */
-extern int64_t GetInteger64(void);
+int64_t GetInteger64(void);
 
 /**
  * Parses an integer value.
  * Uses a method that obeys hexadecimal 0xN syntax needed for certain bitmasks.
  */
-extern int GetInteger(void);
+int GetInteger(void);
 
-extern unsigned short GetShort(void);
+unsigned short GetShort(void);
 
 // on success, returns true and sets *p (if any) to the end of the integer
-extern bool StringToInt(const char *str, int &result, const char **p, int base);
-extern bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
+bool StringToInt(const char *str, int &result, const char **p, int base);
+bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
 
 /**
  * Parse a socket address (host:port), fill the given Ip::Address object
  * \retval false     Failure.
  * \retval true      Success.
  * Destroys token during parse.
  */
-extern bool GetHostWithPort(char *token, Ip::Address *ipa);
+bool GetHostWithPort(char *token, Ip::Address *ipa);
 
 #endif /* SQUID_PARSING_H */
@@ -38,7 +38,9 @@
 /* for CacheDigestGuessStats */
 #include "StatCounters.h"
 
-struct _Version {
+class Version
+{
+public:
     short int current;		/* current version */
     short int required;		/* minimal version that can safely handle current version */
 };
@@ -59,7 +61,10 @@ class StoreDigestCBlock
     int reserved[32 - 6];
 };
 
-struct _DigestFetchState {
+class PeerDigest;
+class DigestFetchState
+{
+public:
     PeerDigest *pd;
     StoreEntry *entry;
     StoreEntry *old_entry;
@@ -90,7 +95,7 @@ class PeerDigest
     void *operator new (size_t);
     void operator delete(void *);
 
-    struct peer *peer;          /**< pointer back to peer structure, argh */
+    CachePeer *peer;          /**< pointer back to peer structure, argh */
     CacheDigest *cd;            /**< actual digest structure */
     String host;                /**< copy of peer->host */
     const char *req_result;     /**< text status of the last request */
@@ -129,10 +134,10 @@ class PeerDigest
 
 extern const Version CacheDigestVer;
 
-extern PeerDigest *peerDigestCreate(peer * p);
-extern void peerDigestNeeded(PeerDigest * pd);
-extern void peerDigestNotePeerGone(PeerDigest * pd);
-extern void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
+PeerDigest *peerDigestCreate(CachePeer * p);
+void peerDigestNeeded(PeerDigest * pd);
+void peerDigestNotePeerGone(PeerDigest * pd);
+void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
 
 #endif /* USE_CACHE_DIGESTS */
 
@@ -51,18 +51,18 @@ SQUIDCEXTERN void peerSelect(Comm::ConnectionList *, HttpRequest *, StoreEntry *
 SQUIDCEXTERN void peerSelectInit(void);
 
 /**
- * A peer which has been selected as a possible destination.
+ * A CachePeer which has been selected as a possible destination.
  * Listed as pointers here so as to prevent duplicates being added but will
  * be converted to a set of IP address path options before handing back out
  * to the caller.
  *
  * Certain connection flags and outgoing settings will also be looked up and
- * set based on the received request and peer settings before handing back.
+ * set based on the received request and CachePeer settings before handing back.
  */
 class FwdServer
 {
 public:
-    peer *_peer;                /* NULL --> origin server */
+    CachePeer *_peer;                /* NULL --> origin server */
     hier_code code;
     FwdServer *next;
 };
@@ -86,21 +86,21 @@ class ps_state
     FwdServer *servers;    ///< temporary linked list of peers we will pass back.
 
     /*
-     * Why are these Ip::Address instead of peer *?  Because a
-     * peer structure can become invalid during the peer selection
+     * Why are these Ip::Address instead of CachePeer *?  Because a
+     * CachePeer structure can become invalid during the CachePeer selection
      * phase, specifically after a reconfigure.  Thus we need to lookup
-     * the peer * based on the address when we are finally ready to
-     * reference the peer structure.
+     * the CachePeer * based on the address when we are finally ready to
+     * reference the CachePeer structure.
      */
 
     Ip::Address first_parent_miss;
 
     Ip::Address closest_parent_miss;
     /*
-     * ->hit can be peer* because it should only be
+     * ->hit can be CachePeer* because it should only be
      * accessed during the thread when it is set
      */
-    peer *hit;
+    CachePeer *hit;
     peer_t hit_type;
     ping_data ping;
     ACLChecklist *acl_checklist;
@@ -0,0 +1,62 @@
+#ifndef SQUID_REFRESHPATTERN_H_
+#define SQUID_REFRESHPATTERN_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// a representation of a refresh pattern. Currently a POD.
+class RefreshPattern
+{
+public:
+    const char *pattern;
+    regex_t compiled_pattern;
+    time_t min;
+    double pct;
+    time_t max;
+    RefreshPattern *next;
+
+    struct {
+        unsigned int icase:1;
+        unsigned int refresh_ims:1;
+        unsigned int store_stale:1;
+#if USE_HTTP_VIOLATIONS
+        unsigned int override_expire:1;
+        unsigned int override_lastmod:1;
+        unsigned int reload_into_ims:1;
+        unsigned int ignore_reload:1;
+        unsigned int ignore_no_cache:1;
+        unsigned int ignore_no_store:1;
+        unsigned int ignore_must_revalidate:1;
+        unsigned int ignore_private:1;
+        unsigned int ignore_auth:1;
+#endif
+    } flags;
+    int max_stale;
+};
+
+#endif /* SQUID_REFRESHPATTERN_H_ */
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "RegexList.h"
+
@@ -0,0 +1,42 @@
+#ifndef SQUID_REGEXLIST_H_
+#define SQUID_REGEXLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// list of regular expressions. Currently a POD.
+class RegexList
+{
+public:
+    int flags;
+    char *pattern;
+    regex_t regex;
+    RegexList *next;
+};
+
+#endif /* SQUID_REGEXLIST_H_ */
@@ -97,7 +97,7 @@ class RemovalPurgeWalker
     CBDATA_CLASS2(RemovalPurgeWalker);
 };
 
-extern RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
+RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
 
 typedef RemovalPolicy *REMOVALPOLICYCREATE(wordlist * args);
 
@@ -0,0 +1,46 @@
+/*
+ * DEBUG: section 73    HTTP Request
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "RequestFlags.h"
+
+// When adding new flags, please update cloneAdaptationImmune() as needed.
+// returns a partial copy of the flags that includes only those flags
+// that are safe for a related (e.g., ICAP-adapted) request to inherit
+RequestFlags
+RequestFlags::cloneAdaptationImmune() const
+{
+    // At the time of writing, all flags where either safe to copy after
+    // adaptation or were not set at the time of the adaptation. If there
+    // are flags that are different, they should be cleared in the clone.
+    return *this;
+}
@@ -0,0 +1,150 @@
+#ifndef SQUID_REQUESTFLAGS_H_
+#define SQUID_REQUESTFLAGS_H_
+/*
+ * DEBUG: section 73    HTTP Request
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/** request-related flags
+ *
+ * The bit-field contains both flags marking a request's current state,
+ * and flags requesting some processing to be done at a later stage.
+ * TODO: better distinguish the two cases.
+ */
+class RequestFlags
+{
+public:
+    RequestFlags() {
+        memset(this,0,sizeof(RequestFlags));
+    }
+
+    /** true if the response to this request may not be READ from cache */
+    bool noCache :1;
+    /** request is if-modified-since */
+    bool ims :1;
+    /** request is authenticated */
+    bool auth :1;
+    /** he response to the request may be stored in the cache */
+    bool cachable :1;
+    /** the request can be forwarded through the hierarchy */
+    bool hierarchical :1;
+    /** a loop was detected on this request */
+    bool loopDetected :1;
+    /** the connection can be kept alive */
+    bool proxyKeepalive :1;
+    /* this should be killed, also in httpstateflags */
+    bool proxying :1;
+    /** content has expired, need to refresh it */
+    bool refresh :1;
+    /** request was redirected by redirectors */
+    bool redirected :1;
+    /** the requested object needs to be validated. See client_side_reply.cc
+     * for further information.
+     */
+    bool needValidation :1;
+    /** whether we should fail if validation fails */
+    bool failOnValidationError :1;
+    /** reply is stale if it is a hit */
+    bool staleIfHit :1;
+    /** request to override no-cache directives
+     *
+     * always use noCacheHack() for reading.
+     * \note only meaningful if USE_HTTP_VIOLATIONS is defined at build time
+     */
+    bool nocacheHack :1;
+    /** this request is accelerated (reverse-proxy) */
+    bool accelerated :1;
+    /** if set, ignore Cache-Control headers */
+    bool ignoreCc :1;
+    /** set for intercepted requests */
+    bool intercepted :1;
+    /** set if the Host: header passed verification */
+    bool hostVerified :1;
+    /** request to spoof the client ip */
+    bool spoofClientIp :1;
+    /** set if the request is internal (\see ClientHttpRequest::flags.internal)*/
+    bool internal :1;
+    /** set for internally-generated requests */
+    //XXX this is set in in clientBeginRequest, but never tested.
+    bool internalClient :1;
+    /** if set, request to try very hard to keep the connection alive */
+    bool mustKeepalive :1;
+    /** set if the rquest wants connection oriented auth */
+    bool connectionAuth :1;
+    /** set if connection oriented auth can not be supported */
+    bool connectionAuthDisabled :1;
+    /** Request wants connection oriented auth */
+    // XXX This is set in clientCheckPinning but never tested
+    bool connectionProxyAuth :1;
+    /** set if the request was sent on a pinned connection */
+    bool pinned :1;
+    /** OK to reopen a failed pinned connection */
+    bool canRePin :1;
+    /** Authentication was already sent upstream (e.g. due tcp-level auth) */
+    bool authSent :1;
+    /** Deny direct forwarding unless overriden by always_direct
+     * Used in accelerator mode */
+    bool noDirect :1;
+    /** Reply with chunked transfer encoding */
+    bool chunkedReply :1;
+    /** set if stream error has occured */
+    bool streamError :1;
+    /** internal ssl-bump request to get server cert */
+    bool sslPeek :1;
+    /** set if X-Forwarded-For checking is complete
+     *
+     * do not read directly; use doneFollowXff for reading
+     */
+    bool done_follow_x_forwarded_for :1;
+    /** set for ssl-bumped requests */
+    bool sslBumped :1;
+    bool destinationIpLookedUp:1;
+    /** request to reset the TCP stream */
+    bool resetTcp:1;
+    /** set if the request is ranged */
+    bool isRanged :1;
+
+    /** clone the flags, resetting to default those which are not safe in
+     *  a related (e.g. ICAP-adapted) request.
+     */
+    RequestFlags cloneAdaptationImmune() const;
+
+    // if FOLLOW_X_FORWARDED_FOR is not set, we always return "done".
+    bool doneFollowXff() const {
+        return done_follow_x_forwarded_for || !FOLLOW_X_FORWARDED_FOR;
+    }
+
+    // if USE_HTTP_VIOLATIONS is not set, never allow this
+    bool noCacheHack() const {
+        return USE_HTTP_VIOLATIONS && nocacheHack;
+    }
+};
+
+#endif /* SQUID_REQUESTFLAGS_H_ */
@@ -53,6 +53,7 @@
 #include "adaptation/Answer.h"
 #include "adaptation/Iterator.h"
 #include "base/AsyncCall.h"
+#include "SquidConfig.h"
 #endif
 
 // implemented in client_side_reply.cc until sides have a common parent
@@ -43,6 +43,7 @@
 #endif
 
 class HttpMsg;
+class HttpReply;
 
 /**
  * ServerStateData is a common base for server-side classes such as
@@ -0,0 +1,60 @@
+#ifndef SQUID_SNMPREQUEST_H_
+#define SQUID_SNMPREQUEST_H_
+/*
+ * DEBUG: section 
+ * AUTHOR: 
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#if SQUID_SNMP
+#include "snmp_session.h"
+
+// POD
+class SnmpRequest
+{
+public:
+    u_char *buf;
+    u_char *outbuf;
+    int len;
+    int sock;
+    long reqid;
+    int outlen;
+
+    Ip::Address from;
+
+    struct snmp_pdu *PDU;
+    ACLChecklist *acl_checklist;
+    u_char *community;
+
+    struct snmp_session session;
+};
+
+#endif /* SQUID_SNMP */
+
+#endif /* SQUID_SNMPREQUEST_H_ */
@@ -1,12 +1,7 @@
-/*
- * $Id$
- */
-
 #include "squid.h"
-#include "ip/Address.h"
-// just for the global definition of Config and Config2
-#include "structs.h"
+#include "SquidConfig.h"
 
 struct SquidConfig Config;
 
 struct SquidConfig2 Config2;
+
@@ -0,0 +1,560 @@
+#ifndef SQUID_SQUIDCONFIG_H_
+#define SQUID_SQUIDCONFIG_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "acl/AclAddress.h"
+#include "ClientDelayConfig.h"
+#include "DelayConfig.h"
+#include "HelperChildConfig.h"
+#include "HttpHeaderTools.h"
+#include "icmp/IcmpConfig.h"
+#include "ip/Address.h"
+#include "RefCount.h"
+#include "YesNoNone.h"
+
+#if USE_SSL
+#include <openssl/ssl.h>
+class sslproxy_cert_sign;
+class sslproxy_cert_adapt;
+#endif
+
+class acl_access;
+class AclSizeLimit;
+class AclDenyInfoList;
+namespace Mgr {
+class ActionPasswordList;
+} // namespace Mgr
+class CustomLog;
+class CpuAffinityMap;
+class external_acl;
+class HeaderManglers;
+class RefreshPattern;
+class RemovalPolicySettings;
+class SwapDir;
+
+namespace AnyP {
+class PortCfg;
+}
+
+/// the representation of the configuration. POD.
+class SquidConfig
+{
+public:
+    struct {
+        /* These should be for the Store::Root instance.
+        * this needs pluggable parsing to be done smoothly.
+        */
+        int highWaterMark;
+        int lowWaterMark;
+    } Swap;
+
+    YesNoNone memShared; ///< whether the memory cache is shared among workers
+    size_t memMaxSize;
+
+    struct {
+        int64_t min;
+        int pct;
+        int64_t max;
+    } quickAbort;
+    int64_t readAheadGap;
+    RemovalPolicySettings *replPolicy;
+    RemovalPolicySettings *memPolicy;
+#if USE_HTTP_VIOLATIONS
+    time_t negativeTtl;
+#endif
+    time_t maxStale;
+    time_t negativeDnsTtl;
+    time_t positiveDnsTtl;
+    time_t shutdownLifetime;
+    time_t backgroundPingRate;
+
+    struct {
+        time_t read;
+        time_t write;
+        time_t lifetime;
+        time_t connect;
+        time_t forward;
+        time_t peer_connect;
+        time_t request;
+        time_t clientIdlePconn;
+        time_t serverIdlePconn;
+        time_t siteSelect;
+        time_t deadPeer;
+        int icp_query;      /* msec */
+        int icp_query_max;  /* msec */
+        int icp_query_min;  /* msec */
+        int mcast_icp_query;    /* msec */
+
+#if !USE_DNSHELPER
+        time_msec_t idns_retransmit;
+        time_msec_t idns_query;
+#endif
+
+    } Timeout;
+    size_t maxRequestHeaderSize;
+    int64_t maxRequestBodySize;
+    int64_t maxChunkedRequestBodySize;
+    size_t maxRequestBufferSize;
+    size_t maxReplyHeaderSize;
+    AclSizeLimit *ReplyBodySize;
+
+    struct {
+        unsigned short icp;
+#if USE_HTCP
+
+        unsigned short htcp;
+#endif
+#if SQUID_SNMP
+
+        unsigned short snmp;
+#endif
+    } Port;
+
+    struct {
+        AnyP::PortCfg *http;
+#if USE_SSL
+        AnyP::PortCfg *https;
+#endif
+    } Sockaddr;
+#if SQUID_SNMP
+
+    struct {
+        char *configFile;
+        char *agentInfo;
+    } Snmp;
+#endif
+#if USE_WCCP
+
+    struct {
+        Ip::Address router;
+        Ip::Address address;
+        int version;
+    } Wccp;
+#endif
+#if USE_WCCPv2
+
+    struct {
+        Ip::Address_list *router;
+        Ip::Address address;
+        int forwarding_method;
+        int return_method;
+        int assignment_method;
+        int weight;
+        int rebuildwait;
+        void *info;
+    } Wccp2;
+#endif
+
+#if USE_ICMP
+    IcmpConfig pinger;
+#endif
+
+    char *as_whois_server;
+
+    struct {
+        char *store;
+        char *swap;
+        CustomLog *accesslogs;
+#if ICAP_CLIENT
+        CustomLog *icaplogs;
+#endif
+        int rotateNumber;
+    } Log;
+    char *adminEmail;
+    char *EmailFrom;
+    char *EmailProgram;
+    char *effectiveUser;
+    char *visible_appname_string;
+    char *effectiveGroup;
+
+    struct {
+#if USE_DNSHELPER
+        char *dnsserver;
+#endif
+
+        wordlist *redirect;
+#if USE_UNLINKD
+
+        char *unlinkd;
+#endif
+
+        char *diskd;
+#if USE_SSL
+
+        char *ssl_password;
+#endif
+
+    } Program;
+#if USE_DNSHELPER
+    HelperChildConfig dnsChildren;
+#endif
+
+    HelperChildConfig redirectChildren;
+    time_t authenticateGCInterval;
+    time_t authenticateTTL;
+    time_t authenticateIpTTL;
+
+    struct {
+        char *surrogate_id;
+    } Accel;
+    char *appendDomain;
+    size_t appendDomainLen;
+    char *pidFilename;
+    char *netdbFilename;
+    char *mimeTablePathname;
+    char *etcHostsPath;
+    char *visibleHostname;
+    char *uniqueHostname;
+    wordlist *hostnameAliases;
+    char *errHtmlText;
+
+    struct {
+        char *host;
+        char *file;
+        time_t period;
+        unsigned short port;
+    } Announce;
+
+    struct {
+
+        Ip::Address udp_incoming;
+        Ip::Address udp_outgoing;
+#if SQUID_SNMP
+        Ip::Address snmp_incoming;
+        Ip::Address snmp_outgoing;
+#endif
+        /* FIXME INET6 : this should really be a CIDR value */
+        Ip::Address client_netmask;
+    } Addrs;
+    size_t tcpRcvBufsz;
+    size_t udpMaxHitObjsz;
+    wordlist *hierarchy_stoplist;
+    wordlist *mcast_group_list;
+    wordlist *dns_nameservers;
+    CachePeer *peers;
+    int npeers;
+
+    struct {
+        int size;
+        int low;
+        int high;
+    } ipcache;
+
+    struct {
+        int size;
+    } fqdncache;
+    int minDirectHops;
+    int minDirectRtt;
+    Mgr::ActionPasswordList *passwd_list;
+
+    struct {
+        int objectsPerBucket;
+        int64_t avgObjectSize;
+        int64_t maxObjectSize;
+        int64_t minObjectSize;
+        size_t maxInMemObjSize;
+    } Store;
+
+    struct {
+        int high;
+        int low;
+        time_t period;
+    } Netdb;
+
+    struct {
+        int log_udp;
+        int res_defnames;
+        int anonymizer;
+        int client_db;
+        int query_icmp;
+        int icp_hit_stale;
+        int buffered_logs;
+        int common_log;
+        int log_mime_hdrs;
+        int log_fqdn;
+        int announce;
+        int mem_pools;
+        int test_reachability;
+        int half_closed_clients;
+        int refresh_all_ims;
+#if USE_HTTP_VIOLATIONS
+
+        int reload_into_ims;
+#endif
+
+        int offline;
+        int redir_rewrites_host;
+        int prefer_direct;
+        int nonhierarchical_direct;
+        int strip_query_terms;
+        int redirector_bypass;
+        int ignore_unknown_nameservers;
+        int client_pconns;
+        int server_pconns;
+        int error_pconns;
+#if USE_CACHE_DIGESTS
+
+        int digest_generation;
+#endif
+
+        int ie_refresh;
+        int vary_ignore_expire;
+        int pipeline_prefetch;
+        int surrogate_is_remote;
+        int request_entities;
+        int detect_broken_server_pconns;
+        int balance_on_multiple_ip;
+        int relaxed_header_parser;
+        int check_hostnames;
+        int allow_underscore;
+        int via;
+        int emailErrData;
+        int httpd_suppress_version_string;
+        int global_internal_static;
+
+#if FOLLOW_X_FORWARDED_FOR
+        int acl_uses_indirect_client;
+        int delay_pool_uses_indirect_client;
+        int log_uses_indirect_client;
+#if LINUX_NETFILTER
+        int tproxy_uses_indirect_client;
+#endif
+#endif /* FOLLOW_X_FORWARDED_FOR */
+
+        int WIN32_IpAddrChangeMonitor;
+        int memory_cache_first;
+        int memory_cache_disk;
+        int hostStrictVerify;
+        int client_dst_passthru;
+    } onoff;
+
+    int forward_max_tries;
+    int connect_retries;
+
+    class ACL *aclList;
+
+    struct {
+        acl_access *http;
+        acl_access *adapted_http;
+        acl_access *icp;
+        acl_access *miss;
+        acl_access *NeverDirect;
+        acl_access *AlwaysDirect;
+        acl_access *ASlists;
+        acl_access *noCache;
+        acl_access *log;
+#if SQUID_SNMP
+
+        acl_access *snmp;
+#endif
+#if USE_HTTP_VIOLATIONS
+        acl_access *brokenPosts;
+#endif
+        acl_access *redirector;
+        acl_access *reply;
+        AclAddress *outgoing_address;
+#if USE_HTCP
+
+        acl_access *htcp;
+        acl_access *htcp_clr;
+#endif
+
+#if USE_SSL
+        acl_access *ssl_bump;
+#endif
+#if FOLLOW_X_FORWARDED_FOR
+        acl_access *followXFF;
+#endif /* FOLLOW_X_FORWARDED_FOR */
+
+#if ICAP_CLIENT
+        acl_access* icap;
+#endif
+    } accessList;
+    AclDenyInfoList *denyInfoList;
+
+    struct {
+        size_t list_width;
+        int list_wrap;
+        char *anon_user;
+        int passive;
+        int epsv_all;
+        int epsv;
+        int eprt;
+        int sanitycheck;
+        int telnet;
+    } Ftp;
+    RefreshPattern *Refresh;
+
+    struct _cacheSwap {
+        RefCount<SwapDir> *swapDirs;
+        int n_allocated;
+        int n_configured;
+        /// number of disk processes required to support all cache_dirs
+        int n_strands;
+    } cacheSwap;
+    /*
+     * I'm sick of having to keep doing this ..
+     */
+#define INDEXSD(i)   (Config.cacheSwap.swapDirs[(i)].getRaw())
+
+    struct {
+        char *directory;
+        int use_short_names;
+    } icons;
+    char *errorDirectory;
+#if USE_ERR_LOCALES
+    char *errorDefaultLanguage;
+    int errorLogMissingLanguages;
+#endif
+    char *errorStylesheet;
+
+    struct {
+        int onerror;
+    } retry;
+
+    struct {
+        int64_t limit;
+    } MemPools;
+#if USE_DELAY_POOLS
+
+    DelayConfig Delay;
+    ClientDelayConfig ClientDelay;
+#endif
+
+    struct {
+        struct {
+            int average;
+            int min_poll;
+        } dns, udp, tcp;
+    } comm_incoming;
+    int max_open_disk_fds;
+    int uri_whitespace;
+    AclSizeLimit *rangeOffsetLimit;
+#if MULTICAST_MISS_STREAM
+
+    struct {
+
+        Ip::Address addr;
+        int ttl;
+        unsigned short port;
+        char *encode_key;
+    } mcast_miss;
+#endif
+
+    /// request_header_access and request_header_replace
+    HeaderManglers *request_header_access;
+    /// reply_header_access and reply_header_replace
+    HeaderManglers *reply_header_access;
+    ///request_header_add access list
+    HeaderWithAclList *request_header_add;
+    char *coredump_dir;
+    char *chroot_dir;
+#if USE_CACHE_DIGESTS
+
+    struct {
+        int bits_per_entry;
+        time_t rebuild_period;
+        time_t rewrite_period;
+        size_t swapout_chunk_size;
+        int rebuild_chunk_percentage;
+    } digest;
+#endif
+#if USE_SSL
+
+    struct {
+        int unclean_shutdown;
+        char *ssl_engine;
+    } SSL;
+#endif
+
+    wordlist *ext_methods;
+
+    struct {
+        int high_rptm;
+        int high_pf;
+        size_t high_memory;
+    } warnings;
+    char *store_dir_select_algorithm;
+    int sleep_after_fork;   /* microseconds */
+    time_t minimum_expiry_time; /* seconds */
+    external_acl *externalAclHelperList;
+
+#if USE_SSL
+
+    struct {
+        char *cert;
+        char *key;
+        int version;
+        char *options;
+        char *cipher;
+        char *cafile;
+        char *capath;
+        char *crlfile;
+        char *flags;
+        acl_access *cert_error;
+        SSL_CTX *sslContext;
+        sslproxy_cert_sign *cert_sign;
+        sslproxy_cert_adapt *cert_adapt;
+    } ssl_client;
+#endif
+
+    char *accept_filter;
+    int umask;
+    int max_filedescriptors;
+    int workers;
+    CpuAffinityMap *cpuAffinityMap;
+
+#if USE_LOADABLE_MODULES
+    wordlist *loadable_module_names;
+#endif
+
+    int client_ip_max_connections;
+
+    struct {
+        int v4_first;       ///< Place IPv4 first in the order of DNS results.
+        ssize_t packet_max; ///< maximum size EDNS advertised for DNS replies.
+    } dns;
+
+};
+
+extern SquidConfig Config;
+
+struct SquidConfig2 {
+    struct {
+        int enable_purge;
+        int mangle_request_headers;
+    } onoff;
+    uid_t effectiveUserID;
+    gid_t effectiveGroupID;
+};
+
+extern SquidConfig2 Config2;
+
+#endif /* SQUID_SQUIDCONFIG_H_ */
@@ -7,16 +7,16 @@ class Address;
 }
 
 // generic DNS API
-extern void dnsInit(void);
-extern void dnsShutdown(void);
+void dnsInit(void);
+void dnsShutdown(void);
 
 #if USE_DNSHELPER
 // external DNS helper API
-extern void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
+void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
 #else
 // internal DNS client API
-extern void idnsALookup(const char *, IDNSCB *, void *);
-extern void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
+void idnsALookup(const char *, IDNSCB *, void *);
+void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
 #endif
 
 #endif /* SQUID_DNS_H */
@@ -36,13 +36,13 @@ namespace Ip
 {
 class Address;
 }
-extern pid_t ipcCreate(int type,
-                       const char *prog,
-                       const char *const args[],
-                       const char *name,
-                       Ip::Address &local_addr,
-                       int *rfd,
-                       int *wfd,
-                       void **hIpc);
+pid_t ipcCreate(int type,
+                const char *prog,
+                const char *const args[],
+                const char *name,
+                Ip::Address &local_addr,
+                int *rfd,
+                int *wfd,
+                void **hIpc);
 
 #endif /* SQUID_SQUIDIPC_H_ */
@@ -39,7 +39,7 @@ class link_list
     link_list *next;
 };
 
-extern void linklistPush(link_list **, void *);
-extern void *linklistShift(link_list **);
+void linklistPush(link_list **, void *);
+void *linklistShift(link_list **);
 
 #endif /* SQUID_SQUIDLIST_H_ */
@@ -5,11 +5,11 @@
 namespace Math
 {
 
-extern int intPercent(const int a, const int b);
-extern int64_t int64Percent(const int64_t a, const int64_t b);
-extern double doublePercent(const double, const double);
-extern int intAverage(const int, const int, int, const int);
-extern double doubleAverage(const double, const double, int, const int);
+int intPercent(const int a, const int b);
+int64_t int64Percent(const int64_t a, const int64_t b);
+double doublePercent(const double, const double);
+int intAverage(const int, const int, int, const int);
+double doubleAverage(const double, const double, int, const int);
 
 } // namespace Math
 
@@ -181,9 +181,9 @@ _SQUID_INLINE_ bool operator<(const String &a, const String &b);
 #include "String.cci"
 #endif
 
-extern const char *checkNullString(const char *p);
-extern int stringHasWhitespace(const char *);
-extern int stringHasCntl(const char *);
-extern char *strwordtok(char *buf, char **t);
+const char *checkNullString(const char *p);
+int stringHasWhitespace(const char *);
+int stringHasCntl(const char *);
+char *strwordtok(char *buf, char **t);
 
 #endif /* SQUID_STRING_H */
@@ -31,6 +31,7 @@
  */
 
 #include "MemObject.h"
+#include "HttpReply.h"
 
 /**
  \retval true	Store contains 0 bytes of data.
@@ -37,8 +37,9 @@
 
 #include "comm/forward.h"
 #include "CommRead.h"
+#include "hash.h"
+#include "HttpReply.h"
 #include "HttpRequestMethod.h"
-#include "Packer.h"
 #include "Range.h"
 #include "RefCount.h"
 #include "RemovalPolicy.h"
@@ -56,6 +57,8 @@
 class AsyncCall;
 class HttpRequest;
 class MemObject;
+class Packer;
+class RequestFlags;
 class StoreClient;
 class StoreSearch;
 class SwapDir;
@@ -360,62 +363,62 @@ class Store : public RefCountable
 typedef RefCount<Store> StorePointer;
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN size_t storeEntryInUse();
+size_t storeEntryInUse();
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN const char *storeEntryFlags(const StoreEntry *);
+const char *storeEntryFlags(const StoreEntry *);
 
 /// \ingroup StoreAPI
-extern void storeEntryReplaceObject(StoreEntry *, HttpReply *);
+void storeEntryReplaceObject(StoreEntry *, HttpReply *);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method);
+StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeGetPublicByRequest(HttpRequest * request);
+StoreEntry *storeGetPublicByRequest(HttpRequest * request);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeCreateEntry(const char *, const char *, request_flags, const HttpRequestMethod&);
+StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeInit(void);
+void storeInit(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeConfigure(void);
+void storeConfigure(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeFreeMemory(void);
+void storeFreeMemory(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN int expiresMoreThan(time_t, time_t);
+int expiresMoreThan(time_t, time_t);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeAppendPrintf(StoreEntry *, const char *,...) PRINTF_FORMAT_ARG2;
+void storeAppendPrintf(StoreEntry *, const char *,...) PRINTF_FORMAT_ARG2;
 
 /// \ingroup StoreAPI
-extern void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
+void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN int storeTooManyDiskFilesOpen(void);
+int storeTooManyDiskFilesOpen(void);
 
 class SwapDir;
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeHeapPositionUpdate(StoreEntry *, SwapDir *);
+void storeHeapPositionUpdate(StoreEntry *, SwapDir *);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeSwapFileNumberSet(StoreEntry * e, sfileno filn);
+void storeSwapFileNumberSet(StoreEntry * e, sfileno filn);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeFsInit(void);
+void storeFsInit(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeFsDone(void);
+void storeFsDone(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeReplAdd(const char *, REMOVALPOLICYCREATE *);
+void storeReplAdd(const char *, REMOVALPOLICYCREATE *);
 
 /// \ingroup StoreAPI
 extern FREE destroyStoreEntry;
@@ -424,10 +427,10 @@ extern FREE destroyStoreEntry;
  \ingroup StoreAPI
  \todo should be a subclass of Packer perhaps ?
  */
-SQUIDCEXTERN void packerToStoreInit(Packer * p, StoreEntry * e);
+void packerToStoreInit(Packer * p, StoreEntry * e);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeGetMemSpace(int size);
+void storeGetMemSpace(int size);
 
 #if _USE_INLINE_
 #include "Store.cci"
@@ -125,11 +125,11 @@ class store_client
     CBDATA_CLASS(store_client);
 };
 
-extern void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
-extern store_client* storeClientListAdd(StoreEntry * e, void *data);
-extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
-extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
-extern int storePendingNClients(const StoreEntry * e);
-extern int storeClientIsThisAClient(store_client * sc, void *someClient);
+void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
+store_client* storeClientListAdd(StoreEntry * e, void *data);
+int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
+int storeUnregister(store_client * sc, StoreEntry * e, void *data);
+int storePendingNClients(const StoreEntry * e);
+int storeClientIsThisAClient(store_client * sc, void *someClient);
 
 #endif /* SQUID_STORECLIENT_H */
@@ -35,9 +35,9 @@
 
 class String;
 
-extern void strListAdd(String * str, const char *item, char del);
-extern int strListIsMember(const String * str, const char *item, char del);
-extern int strListIsSubstr(const String * list, const char *s, char del);
-extern int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
+void strListAdd(String * str, const char *item, char del);
+int strListIsMember(const String * str, const char *item, char del);
+int strListIsSubstr(const String * list, const char *s, char del);
+int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
 
 #endif /* SQUID_STRLIST_H_ */
@@ -36,6 +36,7 @@
 #include "ConfigOption.h"
 #include "globals.h"
 #include "Parsing.h"
+#include "SquidConfig.h"
 #include "StoreFileSystem.h"
 #include "SwapDir.h"
 #include "tools.h"
@@ -30,6 +30,7 @@
 #ifndef SQUID_SWAPDIR_H
 #define SQUID_SWAPDIR_H
 
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreIOState.h"
 
@@ -97,25 +98,25 @@ class StoreController : public Store
 };
 
 /* migrating from the Config based list of swapdirs */
-extern void allocate_new_swapdir(SquidConfig::_cacheSwap *);
-extern void free_cachedir(SquidConfig::_cacheSwap * swap);
-SQUIDCEXTERN OBJH storeDirStats;
-SQUIDCEXTERN char *storeDirSwapLogFile(int, const char *);
-SQUIDCEXTERN char *storeSwapFullPath(int, char *);
-SQUIDCEXTERN char *storeSwapSubSubDir(int, char *);
-SQUIDCEXTERN const char *storeSwapPath(int);
-SQUIDCEXTERN int storeDirWriteCleanLogs(int reopen);
-SQUIDCEXTERN STDIRSELECT *storeDirSelectSwapDir;
-SQUIDCEXTERN int storeVerifySwapDirs(void);
-SQUIDCEXTERN void storeDirCloseSwapLogs(void);
-SQUIDCEXTERN void storeDirCloseTmpSwapLog(int dirn);
-SQUIDCEXTERN void storeDirDiskFull(sdirno);
-SQUIDCEXTERN void storeDirOpenSwapLogs(void);
-SQUIDCEXTERN void storeDirSwapLog(const StoreEntry *, int op);
-SQUIDCEXTERN void storeDirLRUDelete(StoreEntry *);
-SQUIDCEXTERN void storeDirLRUAdd(StoreEntry *);
-SQUIDCEXTERN int storeDirGetBlkSize(const char *path, int *blksize);
-SQUIDCEXTERN int storeDirGetUFSStats(const char *, int *, int *, int *, int *);
+void allocate_new_swapdir(SquidConfig::_cacheSwap *);
+void free_cachedir(SquidConfig::_cacheSwap * swap);
+extern OBJH storeDirStats;
+char *storeDirSwapLogFile(int, const char *);
+char *storeSwapFullPath(int, char *);
+char *storeSwapSubSubDir(int, char *);
+const char *storeSwapPath(int);
+int storeDirWriteCleanLogs(int reopen);
+extern STDIRSELECT *storeDirSelectSwapDir;
+int storeVerifySwapDirs(void);
+void storeDirCloseSwapLogs(void);
+void storeDirCloseTmpSwapLog(int dirn);
+void storeDirDiskFull(sdirno);
+void storeDirOpenSwapLogs(void);
+void storeDirSwapLog(const StoreEntry *, int op);
+void storeDirLRUDelete(StoreEntry *);
+void storeDirLRUAdd(StoreEntry *);
+int storeDirGetBlkSize(const char *path, int *blksize);
+int storeDirGetUFSStats(const char *, int *, int *, int *, int *);
 
 /// manages a single cache_dir
 class SwapDir : public Store
@@ -79,20 +79,20 @@ MEMPROXY_CLASS_INLINE(URL);
 class HttpRequest;
 class HttpRequestMethod;
 
-extern AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
-extern void urlInitialize(void);
-extern HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
-extern const char *urlCanonical(HttpRequest *);
-extern char *urlCanonicalClean(const HttpRequest *);
-extern const char *urlCanonicalFakeHttps(const HttpRequest * request);
-extern bool urlIsRelative(const char *);
-extern char *urlMakeAbsolute(const HttpRequest *, const char *);
-extern char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
-extern char *urlInternal(const char *dir, const char *name);
-extern int matchDomainName(const char *host, const char *domain);
-extern int urlCheckRequest(const HttpRequest *);
-extern int urlDefaultPort(AnyP::ProtocolType p);
-extern char *urlHostname(const char *url);
-extern void urlExtMethodConfigure(void);
+AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
+void urlInitialize(void);
+HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
+const char *urlCanonical(HttpRequest *);
+char *urlCanonicalClean(const HttpRequest *);
+const char *urlCanonicalFakeHttps(const HttpRequest * request);
+bool urlIsRelative(const char *);
+char *urlMakeAbsolute(const HttpRequest *, const char *);
+char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
+char *urlInternal(const char *dir, const char *name);
+int matchDomainName(const char *host, const char *domain);
+int urlCheckRequest(const HttpRequest *);
+int urlDefaultPort(AnyP::ProtocolType p);
+char *urlHostname(const char *url);
+void urlExtMethodConfigure(void);
 
 #endif /* SQUID_SRC_URL_H_H */
@@ -33,12 +33,12 @@
  */
 
 #if _SQUID_WINDOWS_
-extern int WIN32_Subsystem_Init(int *, char ***);
-extern void WIN32_sendSignal(int);
-extern void WIN32_SetServiceCommandLine(void);
-extern void WIN32_InstallService(void);
-extern void WIN32_RemoveService(void);
-extern int SquidMain(int, char **);
+int WIN32_Subsystem_Init(int *, char ***);
+void WIN32_sendSignal(int);
+void WIN32_SetServiceCommandLine(void);
+void WIN32_InstallService(void);
+void WIN32_RemoveService(void);
+int SquidMain(int, char **);
 #else /* _SQUID_WINDOWS_ */
 inline int WIN32_Subsystem_Init(int *foo, char ***bar) {return 0; } /* NOP */
 inline void WIN32_sendSignal(int foo) { return; } /* NOP */
@@ -0,0 +1,43 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "YesNoNone.h"
+
+YesNoNone::operator void*() const
+{
+    assert(option != 0); // must call configure() first
+    return option > 0 ? (void*)this : NULL;
+}
+
+void
+YesNoNone::configure(bool beSet)
+{
+    option = beSet ? +1 : -1;
+}
@@ -0,0 +1,55 @@
+#ifndef SQUID_YESNONONE_H_
+#define SQUID_YESNONONE_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// Used for boolean enabled/disabled options with complex default logic.
+/// Allows Squid to compute the right default after configuration.
+/// Checks that not-yet-defined option values are not used.
+class YesNoNone
+{
+// TODO: generalize to non-boolean option types
+public:
+    YesNoNone(): option(0) {}
+
+    /// returns true iff enabled; asserts if the option has not been configured
+    operator void *() const; // TODO: use a fancy/safer version of the operator
+
+    /// enables or disables the option;
+    void configure(bool beSet);
+
+    /// whether the option was enabled or disabled, by user or Squid
+    bool configured() const { return option != 0; }
+
+private:
+    enum { optUnspecified = -1, optDisabled = 0, optEnabled = 1 };
+    int option; ///< configured value or zero
+};
+
+#endif /* SQUID_YESNONONE_H_ */
@@ -37,6 +37,7 @@
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
+#include "SquidConfig.h"
 
 const char *AclMatchedName = NULL;
 
@@ -38,14 +38,14 @@
 #include "defines.h"
 #include "dlink.h"
 #include "MemPool.h"
-#include "structs.h"
 
 #if HAVE_OSTREAM
 #include <ostream>
 #endif
 
 class ConfigParser;
 class ACLChecklist;
+class ACLList;
 
 /// \ingroup ACLAPI
 class ACL
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "squid.h"
+#include "AclAddress.h"
+
+//TODO: fill in
@@ -0,0 +1,45 @@
+#ifndef ACLADDRESS_H_
+#define ACLADDRESS_H_
+#include "Acl.h"
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "ip/Address.h"
+#include "acl/Acl.h"
+
+/// list of address-based ACLs. Currently a POD.
+class AclAddress
+{
+public:
+    AclAddress *next;
+    ACLList *aclList;
+
+    Ip::Address addr;
+};
+
+#endif /* ACLADDRESS_H_ */
@@ -0,0 +1,46 @@
+#ifndef SQUID_ACLDENYINFOLIST_H_
+#define SQUID_ACLDENYINFOLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "err_type.h"
+
+class AclNameList;
+
+/// deny_info representation. Currently a POD.
+class AclDenyInfoList
+{
+public:
+    err_type err_page_id;
+    char *err_page_name;
+    AclNameList *acl_list;
+    AclDenyInfoList *next;
+};
+
+#endif /* SQUID_ACLDENYINFOLIST_H_ */
@@ -0,0 +1,43 @@
+#ifndef SQUID_ACL_ACLNAMELIST_H_
+#define SQUID_ACL_ACLNAMELIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "defines.h"
+
+/// list of name-based ACLs. Currently a POD.
+class AclNameList
+{
+public:
+    char name[ACL_NAME_SZ];
+    AclNameList *next;
+};
+// TODO: convert to a std::list<string>
+
+#endif /* SQUID_ACLNAMELIST_H_ */
@@ -0,0 +1,42 @@
+#ifndef SQUID_ACLSIZELIMIT_H_
+#define SQUID_ACLSIZELIMIT_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class ACLList;
+/// representation of a class of Size-limit ACLs
+// a POD. TODO: convert to new ACL framework
+class AclSizeLimit {
+public:
+    AclSizeLimit *next;
+    ACLList *aclList;
+    int64_t size;
+};
+
+#endif /* SQUID_ACLSIZELIMIT_H_ */
@@ -32,21 +32,23 @@
  */
 
 #include "squid.h"
-#include "mgr/Registration.h"
-#include "radix.h"
-#include "HttpRequest.h"
-#include "StoreClient.h"
-#include "Store.h"
 #include "acl/Acl.h"
 #include "acl/Asn.h"
 #include "acl/Checklist.h"
-#include "acl/SourceAsn.h"
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
+#include "acl/SourceAsn.h"
 #include "cache_cf.h"
+#include "forward.h"
 #include "HttpReply.h"
+#include "HttpRequest.h"
 #include "ipcache.h"
-#include "forward.h"
+#include "mgr/Registration.h"
+#include "radix.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
+#include "Store.h"
+#include "StoreClient.h"
 #include "StoreClient.h"
 #include "wordlist.h"
 
@@ -247,7 +249,7 @@ asnCacheStart(int as)
     asState->request = HTTPMSGLOCK(req);
 
     if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
-        e = storeCreateEntry(asres, asres, request_flags(), METHOD_GET);
+        e = storeCreateEntry(asres, asres, RequestFlags(), METHOD_GET);
         asState->sc = storeClientListAdd(e, asState);
         FwdState::fwdStart(Comm::ConnectionPointer(), e, asState->request);
     } else {
@@ -639,7 +641,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
 
         return 0;
 
-    } else if (!checklist->request->flags.destinationIPLookedUp()) {
+    } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         /* XXX FIXME: allow accessing the acl name here */
         debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
@@ -38,13 +38,13 @@
 #include "acl/Checklist.h"
 #include "ip/Address.h"
 
-SQUIDCEXTERN int asnMatchIp(CbDataList<int> *, Ip::Address &);
+int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void asnInit(void);
+void asnInit(void);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void asnFreeMemory(void);
+void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
@@ -37,7 +37,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "HttpRequest.h"
-#include "structs.h"
+#include "SquidConfig.h"
 
 char const *
 ACLDestinationIP::typeString() const
@@ -55,7 +55,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
     if (Config.onoff.client_dst_passthru && checklist->request &&
-            (checklist->request->flags.intercepted || checklist->request->flags.spoof_client_ip)) {
+            (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -71,7 +71,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
         }
 
         return 0;
-    } else if (!checklist->request->flags.destinationIPLookedUp()) {
+    } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << name << "' ACL for '" << checklist->request->GetHost() << "'");
         checklist->changeState (DestinationIPLookup::Instance());
@@ -102,7 +102,7 @@ DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &d
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     assert (checklist->asyncState() == DestinationIPLookup::Instance());
-    checklist->request->flags.destinationIPLookupCompleted();
+    checklist->request->flags.destinationIpLookedUp=true;
     checklist->request->recordLookup(details);
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
@@ -5,6 +5,7 @@
 #include "comm/forward.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #include "auth/AclProxyAuth.h"
@@ -2,16 +2,19 @@
 #define SQUID_ACLFILLED_CHECKLIST_H
 
 #include "acl/Checklist.h"
+#include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
 #if USE_SSL
 #include "ssl/support.h"
 #endif
 
-class ExternalACLEntry;
+class CachePeer;
 class ConnStateData;
+class ExternalACLEntry;
 class HttpRequest;
+class HttpReply;
 
 /** \ingroup ACLAPI
     ACLChecklist filled with specific data, representing Squid and transaction
@@ -53,7 +56,7 @@ class ACLFilledChecklist: public ACLChecklist
     Ip::Address src_addr;
     Ip::Address dst_addr;
     Ip::Address my_addr;
-    struct peer *dst_peer;
+    CachePeer *dst_peer;
     char *dst_rdns;
 
     HttpRequest *request;
@@ -38,6 +38,8 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
+#include "acl/AclNameList.h"
+#include "acl/AclDenyInfoList.h"
 #include "acl/Checklist.h"
 #include "acl/Strategised.h"
 #include "acl/Gadgets.h"
@@ -49,14 +51,14 @@
 
 /* does name lookup, returns page_id */
 err_type
-aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed)
+aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed)
 {
-    acl_deny_info_list *A = NULL;
+    AclDenyInfoList *A = NULL;
 
     debugs(28, 8, HERE << "got called for " << name);
 
     for (A = *head; A; A = A->next) {
-        acl_name_list *L = NULL;
+        AclNameList *L = NULL;
 
         if (!redirect_allowed && strchr(A->err_page_name, ':') ) {
             debugs(28, 8, HERE << "Skip '" << A->err_page_name << "' 30x redirects not allowed as response here.");
@@ -106,14 +108,14 @@ aclIsProxyAuth(const char *name)
  */
 
 void
-aclParseDenyInfoLine(acl_deny_info_list ** head)
+aclParseDenyInfoLine(AclDenyInfoList ** head)
 {
     char *t = NULL;
-    acl_deny_info_list *A = NULL;
-    acl_deny_info_list *B = NULL;
-    acl_deny_info_list **T = NULL;
-    acl_name_list *L = NULL;
-    acl_name_list **Tail = NULL;
+    AclDenyInfoList *A = NULL;
+    AclDenyInfoList *B = NULL;
+    AclDenyInfoList **T = NULL;
+    AclNameList *L = NULL;
+    AclNameList **Tail = NULL;
 
     /* first expect a page name */
 
@@ -123,15 +125,15 @@ aclParseDenyInfoLine(acl_deny_info_list ** head)
         return;
     }
 
-    A = (acl_deny_info_list *)memAllocate(MEM_ACL_DENY_INFO_LIST);
+    A = (AclDenyInfoList *)memAllocate(MEM_ACL_DENY_INFO_LIST);
     A->err_page_id = errorReservePageId(t);
     A->err_page_name = xstrdup(t);
-    A->next = (acl_deny_info_list *) NULL;
+    A->next = (AclDenyInfoList *) NULL;
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
 
     while ((t = strtok(NULL, w_space))) {
-        L = (acl_name_list *)memAllocate(MEM_ACL_NAME_LIST);
+        L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
         xstrncpy(L->name, t, ACL_NAME_SZ);
         *Tail = L;
         Tail = &L->next;
@@ -280,15 +282,15 @@ aclDestroyAccessList(acl_access ** list)
 }
 
 /* maex@space.net (06.09.1996)
- *    destroy an acl_deny_info_list */
+ *    destroy an AclDenyInfoList */
 
 void
-aclDestroyDenyInfoList(acl_deny_info_list ** list)
+aclDestroyDenyInfoList(AclDenyInfoList ** list)
 {
-    acl_deny_info_list *a = NULL;
-    acl_deny_info_list *a_next = NULL;
-    acl_name_list *l = NULL;
-    acl_name_list *l_next = NULL;
+    AclDenyInfoList *a = NULL;
+    AclDenyInfoList *a_next = NULL;
+    AclNameList *l = NULL;
+    AclNameList *l_next = NULL;
 
     debugs(28, 8, "aclDestroyDenyInfoList: invoked");
 
@@ -4,39 +4,39 @@
 #include "err_type.h"
 
 struct dlink_list;
-class StoreEntry;
-class ConfigParser;
 class acl_access;
 class ACL;
+class AclDenyInfoList;
 class ACLList;
-struct acl_deny_info_list;
+class ConfigParser;
+class StoreEntry;
 class wordlist;
 
 /// \ingroup ACLAPI
-extern void aclDestroyAccessList(acl_access **list);
+void aclDestroyAccessList(acl_access **list);
 /// \ingroup ACLAPI
-extern void aclDestroyAcls(ACL **);
+void aclDestroyAcls(ACL **);
 /// \ingroup ACLAPI
-extern void aclDestroyAclList(ACLList **);
+void aclDestroyAclList(ACLList **);
 /// \ingroup ACLAPI
-extern void aclParseAccessLine(ConfigParser &parser, acl_access **);
+void aclParseAccessLine(ConfigParser &parser, acl_access **);
 /// \ingroup ACLAPI
-extern void aclParseAclList(ConfigParser &parser, ACLList **);
+void aclParseAclList(ConfigParser &parser, ACLList **);
 /// \ingroup ACLAPI
-extern int aclIsProxyAuth(const char *name);
+int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
-extern err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed);
+err_type aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed);
 /// \ingroup ACLAPI
-extern void aclParseDenyInfoLine(acl_deny_info_list **);
+void aclParseDenyInfoLine(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern void aclDestroyDenyInfoList(acl_deny_info_list **);
+void aclDestroyDenyInfoList(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern wordlist *aclDumpGeneric(const ACL *);
+wordlist *aclDumpGeneric(const ACL *);
 /// \ingroup ACLAPI
-extern void aclCacheMatchFlush(dlink_list * cache);
+void aclCacheMatchFlush(dlink_list * cache);
 /// \ingroup ACLAPI
-extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
+void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
 /// \ingroup ACLAPI
-extern void dump_acl_list(StoreEntry * entry, ACLList * head);
+void dump_acl_list(StoreEntry * entry, ACLList * head);
 
 #endif /* SQUID_ACL_GADGETS_H */
@@ -17,9 +17,10 @@ libstate_la_SOURCES = \
 	Strategy.h \
 	Strategised.cc \
 	Strategised.h \
-	\
 	FilledChecklist.cc \
-	FilledChecklist.h
+	FilledChecklist.h \
+	AclAddress.h \
+	AclAddress.cc
 
 ## data-specific ACLs
 libacls_la_SOURCES = \
@@ -33,7 +34,6 @@ libacls_la_SOURCES = \
 	Time.h \
 	TimeData.cc \
 	TimeData.h \
-	\
 	Asn.cc \
 	Asn.h \
 	Browser.cc \
@@ -104,9 +104,11 @@ libacls_la_SOURCES = \
 	UrlPort.h \
 	UserData.cc \
 	UserData.h \
-	\
+	AclNameList.h \
+	AclDenyInfoList.h \
 	Gadgets.cc \
-	Gadgets.h
+	Gadgets.h \
+	AclSizeLimit.h
 
 ## Add conditional sources
 ## TODO: move these to their respectful dirs when those dirs are created
@@ -38,6 +38,7 @@
 #include "cache_cf.h"
 #include "client_db.h"
 #include "Debug.h"
+#include "SquidConfig.h"
 #include "wordlist.h"
 
 ACL *
@@ -3,6 +3,7 @@
 #include "acl/RegexData.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
+#include "CachePeer.h"
 
 int
 ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
@@ -41,12 +41,13 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "Mem.h"
+#include "RegexList.h"
 #include "wordlist.h"
 
 static void
-aclDestroyRegexList(relist * data)
+aclDestroyRegexList(RegexList * data)
 {
-    relist *next = NULL;
+    RegexList *next = NULL;
 
     for (; data; data = next) {
         next = data->next;
@@ -69,13 +70,13 @@ ACLRegexData::match(char const *word)
 
     debugs(28, 3, "aclRegexData::match: checking '" << word << "'");
 
-    relist *first, *prev;
+    RegexList *first, *prev;
 
     first = data;
 
     prev = NULL;
 
-    relist *current = first;
+    RegexList *current = first;
 
     while (current) {
         debugs(28, 3, "aclRegexData::match: looking for '" << current->pattern << "'");
@@ -104,7 +105,7 @@ wordlist *
 ACLRegexData::dump()
 {
     wordlist *W = NULL;
-    relist *temp = data;
+    RegexList *temp = data;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     while (temp != NULL) {
@@ -152,11 +153,11 @@ removeUnnecessaryWildcards(char * t)
     return t;
 }
 
-static relist **
-compileRE(relist **Tail, char * RE, int flags)
+static RegexList **
+compileRE(RegexList **Tail, char * RE, int flags)
 {
     int errcode;
-    relist *q;
+    RegexList *q;
     regex_t comp;
 
     if (RE == NULL  ||  *RE == '\0')
@@ -171,7 +172,7 @@ compileRE(relist **Tail, char * RE, int flags)
     }
     debugs(28, 2, "compileRE: compiled '" << RE << "' with flags " << flags );
 
-    q = (relist *) memAllocate(MEM_RELIST);
+    q = (RegexList *) memAllocate(MEM_RELIST);
     q->pattern = xstrdup(RE);
     q->regex = comp;
     q->flags = flags;
@@ -186,11 +187,11 @@ compileRE(relist **Tail, char * RE, int flags)
  * called only once per ACL.
  */
 static int
-compileOptimisedREs(relist **curlist, wordlist * wl)
+compileOptimisedREs(RegexList **curlist, wordlist * wl)
 {
-    relist **Tail;
-    relist *newlist;
-    relist **newlistp;
+    RegexList **Tail;
+    RegexList *newlist;
+    RegexList **newlistp;
     int numREs = 0;
     int flags = REG_EXTENDED | REG_NOSUB;
     int largeREindex = 0;
@@ -288,10 +289,10 @@ compileOptimisedREs(relist **curlist, wordlist * wl)
 }
 
 static void
-compileUnoptimisedREs(relist **curlist, wordlist * wl)
+compileUnoptimisedREs(RegexList **curlist, wordlist * wl)
 {
-    relist **Tail;
-    relist **newTail;
+    RegexList **Tail;
+    RegexList **newTail;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     for (Tail = curlist; *Tail != NULL; Tail = &((*Tail)->next))
@@ -314,7 +315,7 @@ compileUnoptimisedREs(relist **curlist, wordlist * wl)
 }
 
 static void
-aclParseRegexList(relist **curlist)
+aclParseRegexList(RegexList **curlist)
 {
     char *t;
     wordlist *wl = NULL;
@@ -35,8 +35,7 @@
 #include "acl/Data.h"
 #include "MemPool.h"
 
-/** \todo CLEANUP: break out relist, we don't need the rest. */
-#include "structs.h"
+class RegexList;
 
 class ACLRegexData : public ACLData<char const *>
 {
@@ -52,7 +51,7 @@ class ACLRegexData : public ACLData<char const *>
     virtual ACLData<char const *> *clone() const;
 
 private:
-    relist *data;
+    RegexList *data;
 };
 
 MEMPROXY_CLASS_INLINE(ACLRegexData);
@@ -34,6 +34,7 @@
 
 #include "squid.h"
 #include "acl/Strategised.h"
+#include "HttpHeader.h"
 
 /*
  *  moved template instantiation into ACLStrategized.cc
@@ -12,7 +12,6 @@
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-#include "structs.h"
 
 /** \cond AUTODOCS-IGNORE */
 cbdata_type Adaptation::AccessCheck::CBDATA_AccessCheck = CBDATA_UNKNOWN;
@@ -1,10 +1,9 @@
 #include "squid.h"
-#include "structs.h"
-#include "ConfigParser.h"
 #include "acl/Gadgets.h"
 #include "adaptation/AccessRule.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 
 int Adaptation::AccessRule::LastId = 0;
@@ -35,9 +35,9 @@ class AccessRule
 };
 
 typedef Vector<Adaptation::AccessRule*> AccessRules;
-extern AccessRules &AllRules();
-extern AccessRule *FindRule(const AccessRule::Id &id);
-extern AccessRule *FindRuleByGroupId(const String &groupId);
+AccessRules &AllRules();
+AccessRule *FindRule(const AccessRule::Id &id);
+AccessRule *FindRuleByGroupId(const String &groupId);
 
 } // namespace Adaptation
 
@@ -42,7 +42,6 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Store.h"
-#include "structs.h"
 
 bool Adaptation::Config::Enabled = false;
 char *Adaptation::Config::masterx_shared_name = NULL;
@@ -39,8 +39,8 @@ namespace Adaptation
 namespace Icap
 {
 
-extern void InitModule();
-extern void CleanModule();
+void InitModule();
+void CleanModule();
 
 } // namespace Icap
 } // namespace Adaptation
@@ -38,6 +38,7 @@
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
+#include "SquidConfig.h"
 #include "wordlist.h"
 
 Adaptation::Icap::Config Adaptation::Icap::TheConfig;
@@ -17,6 +17,7 @@
 #include "globals.h"
 #include "HttpReply.h"
 #include "ip/tools.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
@@ -24,6 +24,7 @@
 #include "ipcache.h"
 #include "Mem.h"
 #include "pconn.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 //CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, Xaction);
@@ -1,15 +1,17 @@
 #include "squid.h"
 #include "icap_log.h"
 #include "AccessLogEntry.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 
 int IcapLogfileStatus = LOG_DISABLE;
 
 void
 icapLogOpen()
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->type == Log::Format::CLF_NONE)
@@ -24,7 +26,7 @@ icapLogOpen()
 void
 icapLogClose()
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
@@ -37,7 +39,7 @@ icapLogClose()
 void
 icapLogRotate()
 {
-    for (customlog* log = Config.Log.icaplogs; log; log = log->next) {
+    for (CustomLog* log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
             logfileRotate(log->logfile);
         }
@@ -34,7 +34,7 @@ AuthenticateAcl(ACLChecklist *ch)
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
+    } else if (request->flags.intercepted || request->flags.spoofClientIp) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
@@ -11,7 +11,7 @@
 
 class ACLChecklist;
 /// \ingroup AuthAPI
-extern allow_t AuthenticateAcl(ACLChecklist *ch);
+allow_t AuthenticateAcl(ACLChecklist *ch);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_ACL_H */
@@ -82,7 +82,7 @@ class StoreEntry;
 typedef void AUTHSSTATS(StoreEntry *);
 
 /// \ingroup AuthAPI
-extern void authenticateInit(Auth::ConfigVector *);
+void authenticateInit(Auth::ConfigVector *);
 
 /** \ingroup AuthAPI
  * Remove all idle authentication state. Intended for use by reconfigure.
@@ -94,19 +94,19 @@ extern void authenticateInit(Auth::ConfigVector *);
  * authentication unless something causes the global config to be rebuilt.
  * Such as a configure load action adding config and re-running authenticateInit().
  */
-extern void authenticateReset(void);
+void authenticateReset(void);
 
-extern void authenticateRotate(void);
+void authenticateRotate(void);
 
 /// \ingroup AuthAPI
-extern void authenticateFreeProxyAuthUserACLResults(void *data);
+void authenticateFreeProxyAuthUserACLResults(void *data);
 /// \ingroup AuthAPI
-extern int authenticateActiveSchemeCount(void);
+int authenticateActiveSchemeCount(void);
 /// \ingroup AuthAPI
-extern int authenticateSchemeCount(void);
+int authenticateSchemeCount(void);
 
 /// \ingroup AuthAPI
-extern void authenticateOnCloseConnection(ConnStateData * conn);
+void authenticateOnCloseConnection(ConnStateData * conn);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_GADGETS_H */
@@ -40,6 +40,7 @@
 #include "acl/Gadgets.h"
 #include "event.h"
 #include "globals.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
@@ -227,20 +227,20 @@ class UserRequest : public RefCountable
 /* AuthUserRequest */
 
 /// \ingroup AuthAPI
-extern void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int);
+void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int);
 /// \ingroup AuthAPI
-extern void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int);
+void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int);
 
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &);
+void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &);
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer);
+void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer);
 /// \ingroup AuthAPI
-extern int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer);
+int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer);
 
 /// \ingroup AuthAPI
 /// See Auth::UserRequest::authenticated()
-extern int authenticateUserAuthenticated(Auth::UserRequest::Pointer);
+int authenticateUserAuthenticated(Auth::UserRequest::Pointer);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTHUSERREQUEST_H */
@@ -2,8 +2,8 @@
 #include "auth/basic/auth_basic.h"
 #include "auth/basic/User.h"
 #include "Debug.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
-#include "structs.h"
 
 Auth::Basic::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
@@ -3,8 +3,8 @@
 #include "auth/digest/User.h"
 #include "Debug.h"
 #include "dlink.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
-#include "structs.h"
 
 Auth::Digest::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
@@ -91,6 +91,7 @@ static const HttpHeaderFieldAttrs DigestAttrs[DIGEST_ENUM_END] = {
     {"response", (http_hdr_type)DIGEST_RESPONSE},
 };
 
+class HttpHeaderFieldInfo;
 static HttpHeaderFieldInfo *DigestFieldsInfo = NULL;
 
 /*
@@ -50,12 +50,12 @@ struct _digest_nonce_h : public hash_link {
     } flags;
 };
 
-extern void authDigestNonceUnlink(digest_nonce_h * nonce);
-extern int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
-extern const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
-extern int authDigestNonceLastRequest(digest_nonce_h * nonce);
-extern void authenticateDigestNonceShutdown(void);
-extern void authDigestNoncePurge(digest_nonce_h * nonce);
+void authDigestNonceUnlink(digest_nonce_h * nonce);
+int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
+const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
+int authDigestNonceLastRequest(digest_nonce_h * nonce);
+void authenticateDigestNonceShutdown(void);
+void authDigestNoncePurge(digest_nonce_h * nonce);
 
 namespace Auth
 {
@@ -286,8 +286,8 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *re
             ++arg;
         }
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.must_keepalive = 1;
-        if (lm_request->request->flags.proxy_keepalive) {
+        lm_request->request->flags.mustKeepalive = 1;
+        if (lm_request->request->flags.proxyKeepalive) {
             lm_request->server_blob = xstrdup(blob);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
@@ -218,7 +218,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         return;
 
     /* Need keep-alive */
-    if (!request->flags.proxy_keepalive && request->flags.must_keepalive)
+    if (!request->flags.proxyKeepalive && request->flags.mustKeepalive)
         return;
 
     /* New request, no user details */
@@ -229,7 +229,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         if (!keep_alive) {
             /* drop the connection */
             rep->header.delByName("keep-alive");
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
         }
     } else {
         Auth::Negotiate::UserRequest *negotiate_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
@@ -241,7 +241,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
             rep->header.delByName("keep-alive");
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
             /* fall through */
 
         case Auth::Ok:
@@ -269,8 +269,8 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, void *lastserver, char *reply)
     if (strncasecmp(reply, "TT ", 3) == 0) {
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.must_keepalive = 1;
-        if (lm_request->request->flags.proxy_keepalive) {
+        lm_request->request->flags.mustKeepalive = 1;
+        if (lm_request->request->flags.proxyKeepalive) {
             lm_request->server_blob = xstrdup(blob);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
@@ -205,7 +205,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         return;
 
     /* Need keep-alive */
-    if (!request->flags.proxy_keepalive && request->flags.must_keepalive)
+    if (!request->flags.proxyKeepalive && request->flags.mustKeepalive)
         return;
 
     /* New request, no user details */
@@ -215,7 +215,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
 
         if (!keep_alive) {
             /* drop the connection */
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
         }
     } else {
         Auth::Ntlm::UserRequest *ntlm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
@@ -226,7 +226,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         case Auth::Failed:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
             /* fall through */
 
         case Auth::Ok:
@@ -3,6 +3,7 @@
  */
 
 #include "squid.h"
+#include "AsyncCall.h"
 #include "base/AsyncCall.h"
 #include "base/AsyncCallQueue.h"
 #include "cbdata.h"
@@ -5,10 +5,9 @@
 #ifndef SQUID_ASYNCCALL_H
 #define SQUID_ASYNCCALL_H
 
-//#include "cbdata.h"
 #include "base/InstanceId.h"
 #include "event.h"
-//#include "TextException.h"
+#include "RefCount.h"
 
 /**
  \defgroup AsynCallsAPI Async-Calls API
@@ -157,7 +156,7 @@ asyncCall(int aDebugSection, int aDebugLevel, const char *aName,
 }
 
 /** Call scheduling helper. Use ScheduleCallHere if you can. */
-extern bool ScheduleCall(const char *fileName, int fileLine, AsyncCall::Pointer &call);
+bool ScheduleCall(const char *fileName, int fileLine, AsyncCall::Pointer &call);
 
 /** Call scheduling helper. */
 #define ScheduleCallHere(call) ScheduleCall(__FILE__, __LINE__, (call))
@@ -71,7 +71,7 @@ class FileNameHashCacheUser
                                          (FileNameHashCached(__FILE__)<<14) | (__LINE__ & 0x3FFF))
 #endif
 
-extern void Throw(const char *message, const char *fileName, int lineNo, unsigned int id);
+void Throw(const char *message, const char *fileName, int lineNo, unsigned int id);
 
 // Must(condition) is like assert(condition) but throws an exception instead
 #if !defined(Must)
@@ -32,11 +32,18 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
+#include "acl/AclAddress.h"
+#include "acl/AclDenyInfoList.h"
+#include "acl/AclNameList.h"
+#include "acl/AclSizeLimit.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
 #include "anyp/PortCfg.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
+#include "mgr/ActionPasswordList.h"
+#include "CachePeer.h"
+#include "CachePeerDomainList.h"
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "CpuAffinityMap.h"
@@ -53,16 +60,20 @@
 #include "ip/tools.h"
 #include "ipc/Kids.h"
 #include "log/Config.h"
+#include "log/CustomLog.h"
 #include "Mem.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
+#include "NeighborTypeDomainList.h"
 #include "Parsing.h"
 #include "PeerDigest.h"
+#include "RefreshPattern.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
+#include "ssl/ProxyCerts.h"
 #include "Store.h"
 #include "StoreFileSystem.h"
-#include "structs.h"
 #include "SwapDir.h"
 #include "wordlist.h"
 #include "neighbors.h"
@@ -148,7 +159,7 @@ static void free_ecap_service_type(Adaptation::Ecap::Config *);
 
 static peer_t parseNeighborType(const char *s);
 
-CBDATA_TYPE(peer);
+CBDATA_TYPE(CachePeer);
 
 static const char *const T_MILLISECOND_STR = "millisecond";
 static const char *const T_SECOND_STR = "second";
@@ -168,14 +179,14 @@ static const char *const B_GBYTES_STR = "GB";
 
 static const char *const list_sep = ", \t\n\r";
 
-static void parse_access_log(customlog ** customlog_definitions);
-static int check_null_access_log(customlog *customlog_definitions);
-static void dump_access_log(StoreEntry * entry, const char *name, customlog * definitions);
-static void free_access_log(customlog ** definitions);
+static void parse_access_log(CustomLog ** customlog_definitions);
+static int check_null_access_log(CustomLog *customlog_definitions);
+static void dump_access_log(StoreEntry * entry, const char *name, CustomLog * definitions);
+static void free_access_log(CustomLog ** definitions);
 
 static void update_maxobjsize(void);
 static void configDoConfigure(void);
-static void parse_refreshpattern(refresh_t **);
+static void parse_refreshpattern(RefreshPattern **);
 static uint64_t parseTimeUnits(const char *unit,  bool allowMsec);
 static void parseTimeLine(time_msec_t * tptr, const char *units, bool allowMsec);
 static void parse_u_short(unsigned short * var);
@@ -208,9 +219,9 @@ static void parse_http_header_replace(HeaderManglers **manglers);
 static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderWithAclList *headers);
 static void parse_HeaderWithAclList(HeaderWithAclList **header);
 static void free_HeaderWithAclList(HeaderWithAclList **header);
-static void parse_denyinfo(acl_deny_info_list ** var);
-static void dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var);
-static void free_denyinfo(acl_deny_info_list ** var);
+static void parse_denyinfo(AclDenyInfoList ** var);
+static void dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var);
+static void free_denyinfo(AclDenyInfoList ** var);
 
 #if USE_WCCPv2
 static void parse_IpAddress_list(Ip::Address_list **);
@@ -759,7 +770,7 @@ configDoConfigure(void)
 #if USE_HTTP_VIOLATIONS
 
     {
-        const refresh_t *R;
+        const RefreshPattern *R;
 
         for (R = Config.Refresh; R; R = R->next) {
             if (!R->flags.override_expire)
@@ -918,7 +929,7 @@ configDoConfigure(void)
 
     Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath, Config.ssl_client.crlfile);
 
-    for (peer *p = Config.peers; p != NULL; p = p->next) {
+    for (CachePeer *p = Config.peers; p != NULL; p = p->next) {
         if (p->use_ssl) {
             debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " SSL context");
             p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
@@ -1360,13 +1371,13 @@ free_address(Ip::Address *addr)
     addr->SetEmpty();
 }
 
-CBDATA_TYPE(acl_address);
+CBDATA_TYPE(AclAddress);
 
 static void
-dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
+dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
 {
     char buf[MAX_IPSTRLEN];
-    acl_address *l;
+    AclAddress *l;
 
     for (l = head; l; l = l->next) {
         if (!l->addr.IsAnyAddr())
@@ -1383,17 +1394,17 @@ dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
 static void
 freed_acl_address(void *data)
 {
-    acl_address *l = static_cast<acl_address *>(data);
+    AclAddress *l = static_cast<AclAddress *>(data);
     aclDestroyAclList(&l->aclList);
 }
 
 static void
-parse_acl_address(acl_address ** head)
+parse_acl_address(AclAddress ** head)
 {
-    acl_address *l;
-    acl_address **tail = head;	/* sane name below */
-    CBDATA_INIT_TYPE_FREECB(acl_address, freed_acl_address);
-    l = cbdataAlloc(acl_address);
+    AclAddress *l;
+    AclAddress **tail = head;	/* sane name below */
+    CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
+    l = cbdataAlloc(AclAddress);
     parse_address(&l->addr);
     aclParseAclList(LegacyParser, &l->aclList);
 
@@ -1404,10 +1415,10 @@ parse_acl_address(acl_address ** head)
 }
 
 static void
-free_acl_address(acl_address ** head)
+free_acl_address(AclAddress ** head)
 {
     while (*head) {
-        acl_address *l = *head;
+        AclAddress *l = *head;
         *head = l->next;
         cbdataFree(l);
     }
@@ -1554,12 +1565,12 @@ free_acl_nfmark(acl_nfmark ** head)
 }
 #endif /* SO_MARK */
 
-CBDATA_TYPE(acl_size_t);
+CBDATA_TYPE(AclSizeLimit);
 
 static void
-dump_acl_b_size_t(StoreEntry * entry, const char *name, acl_size_t * head)
+dump_acl_b_size_t(StoreEntry * entry, const char *name, AclSizeLimit * head)
 {
-    acl_size_t *l;
+    AclSizeLimit *l;
 
     for (l = head; l; l = l->next) {
         if (l->size != -1)
@@ -1576,19 +1587,19 @@ dump_acl_b_size_t(StoreEntry * entry, const char *name, acl_size_t * head)
 static void
 freed_acl_b_size_t(void *data)
 {
-    acl_size_t *l = static_cast<acl_size_t *>(data);
+    AclSizeLimit *l = static_cast<AclSizeLimit *>(data);
     aclDestroyAclList(&l->aclList);
 }
 
 static void
-parse_acl_b_size_t(acl_size_t ** head)
+parse_acl_b_size_t(AclSizeLimit ** head)
 {
-    acl_size_t *l;
-    acl_size_t **tail = head;	/* sane name below */
+    AclSizeLimit *l;
+    AclSizeLimit **tail = head;	/* sane name below */
 
-    CBDATA_INIT_TYPE_FREECB(acl_size_t, freed_acl_b_size_t);
+    CBDATA_INIT_TYPE_FREECB(AclSizeLimit, freed_acl_b_size_t);
 
-    l = cbdataAlloc(acl_size_t);
+    l = cbdataAlloc(AclSizeLimit);
 
     parse_b_int64_t(&l->size);
 
@@ -1601,10 +1612,10 @@ parse_acl_b_size_t(acl_size_t ** head)
 }
 
 static void
-free_acl_b_size_t(acl_size_t ** head)
+free_acl_b_size_t(AclSizeLimit ** head)
 {
     while (*head) {
-        acl_size_t *l = *head;
+        AclSizeLimit *l = *head;
         *head = l->next;
         l->next = NULL;
         cbdataFree(l);
@@ -1727,7 +1738,7 @@ parse_http_header_access(HeaderManglers **pm)
     if (!*pm)
         *pm = new HeaderManglers;
     HeaderManglers *manglers = *pm;
-    header_mangler *mangler = manglers->track(t);
+    headerMangler *mangler = manglers->track(t);
     assert(mangler);
     parse_acl_access(&mangler->access_list);
 }
@@ -1965,10 +1976,10 @@ peer_type_str(const peer_t type)
 }
 
 static void
-dump_peer(StoreEntry * entry, const char *name, peer * p)
+dump_peer(StoreEntry * entry, const char *name, CachePeer * p)
 {
-    domain_ping *d;
-    domain_type *t;
+    CachePeerDomainList *d;
+    NeighborTypeDomainList *t;
     LOCAL_ARRAY(char, xname, 128);
 
     while (p != NULL) {
@@ -2065,12 +2076,12 @@ GetUdpService(void)
 }
 
 static void
-parse_peer(peer ** head)
+parse_peer(CachePeer ** head)
 {
     char *token = NULL;
-    peer *p;
-    CBDATA_INIT_TYPE_FREECB(peer, peerDestroy);
-    p = cbdataAlloc(peer);
+    CachePeer *p;
+    CBDATA_INIT_TYPE_FREECB(CachePeer, peerDestroy);
+    p = cbdataAlloc(CachePeer);
     p->http_port = CACHE_HTTP_PORT;
     p->icp.port = CACHE_ICP_PORT;
     p->weight = 1;
@@ -2344,9 +2355,9 @@ parse_peer(peer ** head)
 }
 
 static void
-free_peer(peer ** P)
+free_peer(CachePeer ** P)
 {
-    peer *p;
+    CachePeer *p;
 
     while ((p = *P) != NULL) {
         *P = p->next;
@@ -2362,7 +2373,7 @@ free_peer(peer ** P)
 }
 
 static void
-dump_cachemgrpasswd(StoreEntry * entry, const char *name, cachemgr_passwd * list)
+dump_cachemgrpasswd(StoreEntry * entry, const char *name, Mgr::ActionPasswordList * list)
 {
     wordlist *w;
 
@@ -2382,15 +2393,15 @@ dump_cachemgrpasswd(StoreEntry * entry, const char *name, cachemgr_passwd * list
 }
 
 static void
-parse_cachemgrpasswd(cachemgr_passwd ** head)
+parse_cachemgrpasswd(Mgr::ActionPasswordList ** head)
 {
     char *passwd = NULL;
     wordlist *actions = NULL;
-    cachemgr_passwd *p;
-    cachemgr_passwd **P;
+    Mgr::ActionPasswordList *p;
+    Mgr::ActionPasswordList **P;
     parse_string(&passwd);
     parse_wordlist(&actions);
-    p = static_cast<cachemgr_passwd *>(xcalloc(1, sizeof(cachemgr_passwd)));
+    p = new Mgr::ActionPasswordList;
     p->passwd = passwd;
     p->actions = actions;
 
@@ -2399,7 +2410,7 @@ parse_cachemgrpasswd(cachemgr_passwd ** head)
          * See if any of the actions from this line already have a
          * password from previous lines.  The password checking
          * routines in cache_manager.c take the the password from
-         * the first cachemgr_passwd struct that contains the
+         * the first Mgr::ActionPasswordList that contains the
          * requested action.  Thus, we should warn users who might
          * think they can have two passwords for the same action.
          */
@@ -2420,9 +2431,9 @@ parse_cachemgrpasswd(cachemgr_passwd ** head)
 }
 
 static void
-free_cachemgrpasswd(cachemgr_passwd ** head)
+free_cachemgrpasswd(Mgr::ActionPasswordList ** head)
 {
-    cachemgr_passwd *p;
+    Mgr::ActionPasswordList *p;
 
     while ((p = *head) != NULL) {
         *head = p->next;
@@ -2433,9 +2444,9 @@ free_cachemgrpasswd(cachemgr_passwd ** head)
 }
 
 static void
-dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var)
+dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var)
 {
-    acl_name_list *a;
+    AclNameList *a;
 
     while (var != NULL) {
         storeAppendPrintf(entry, "%s %s", name, var->err_page_name);
@@ -2450,18 +2461,18 @@ dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var)
 }
 
 static void
-parse_denyinfo(acl_deny_info_list ** var)
+parse_denyinfo(AclDenyInfoList ** var)
 {
     aclParseDenyInfoLine(var);
 }
 
 void
-free_denyinfo(acl_deny_info_list ** list)
+free_denyinfo(AclDenyInfoList ** list)
 {
-    acl_deny_info_list *a = NULL;
-    acl_deny_info_list *a_next = NULL;
-    acl_name_list *l = NULL;
-    acl_name_list *l_next = NULL;
+    AclDenyInfoList *a = NULL;
+    AclDenyInfoList *a_next = NULL;
+    AclNameList *l = NULL;
+    AclNameList *l_next = NULL;
 
     for (a = *list; a; a = a_next) {
         for (l = a->acl_list; l; l = l_next) {
@@ -2482,7 +2493,7 @@ static void
 parse_peer_access(void)
 {
     char *host = NULL;
-    peer *p;
+    CachePeer *p;
 
     if (!(host = strtok(NULL, w_space)))
         self_destruct();
@@ -2505,20 +2516,20 @@ parse_hostdomain(void)
         self_destruct();
 
     while ((domain = strtok(NULL, list_sep))) {
-        domain_ping *l = NULL;
-        domain_ping **L = NULL;
-        peer *p;
+        CachePeerDomainList *l = NULL;
+        CachePeerDomainList **L = NULL;
+        CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
             continue;
         }
 
-        l = static_cast<domain_ping *>(xcalloc(1, sizeof(domain_ping)));
-        l->do_ping = 1;
+        l = static_cast<CachePeerDomainList *>(xcalloc(1, sizeof(CachePeerDomainList)));
+        l->do_ping = true;
 
         if (*domain == '!') {	/* check for !.edu */
-            l->do_ping = 0;
+            l->do_ping = false;
             ++domain;
         }
 
@@ -2543,16 +2554,16 @@ parse_hostdomaintype(void)
         self_destruct();
 
     while ((domain = strtok(NULL, list_sep))) {
-        domain_type *l = NULL;
-        domain_type **L = NULL;
-        peer *p;
+        NeighborTypeDomainList *l = NULL;
+        NeighborTypeDomainList **L = NULL;
+        CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
             return;
         }
 
-        l = static_cast<domain_type *>(xcalloc(1, sizeof(domain_type)));
+        l = static_cast<NeighborTypeDomainList *>(xcalloc(1, sizeof(NeighborTypeDomainList)));
         l->type = parseNeighborType(type);
         l->domain = xstrdup(domain);
 
@@ -2637,7 +2648,7 @@ parse_tristate(int *var)
 #define free_tristate free_int
 
 static void
-dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
+dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 {
     while (head != NULL) {
         storeAppendPrintf(entry, "%s%s %s %d %d%% %d",
@@ -2695,7 +2706,7 @@ dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
 }
 
 static void
-parse_refreshpattern(refresh_t ** head)
+parse_refreshpattern(RefreshPattern ** head)
 {
     char *token;
     char *pattern;
@@ -2720,7 +2731,7 @@ parse_refreshpattern(refresh_t ** head)
 #endif
 
     int i;
-    refresh_t *t;
+    RefreshPattern *t;
     regex_t comp;
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
@@ -2825,7 +2836,7 @@ parse_refreshpattern(refresh_t ** head)
 
     pct = pct < 0.0 ? 0.0 : pct;
     max = max < 0 ? 0 : max;
-    t = static_cast<refresh_t *>(xcalloc(1, sizeof(refresh_t)));
+    t = static_cast<RefreshPattern *>(xcalloc(1, sizeof(RefreshPattern)));
     t->pattern = (char *) xstrdup(pattern);
     t->compiled_pattern = comp;
     t->min = min;
@@ -2885,9 +2896,9 @@ parse_refreshpattern(refresh_t ** head)
 }
 
 static void
-free_refreshpattern(refresh_t ** head)
+free_refreshpattern(RefreshPattern ** head)
 {
-    refresh_t *t;
+    RefreshPattern *t;
 
     while ((t = *head) != NULL) {
         *head = t->next;
@@ -3294,18 +3305,6 @@ dump_removalpolicy(StoreEntry * entry, const char *name, RemovalPolicySettings *
     storeAppendPrintf(entry, "\n");
 }
 
-void
-YesNoNone::configure(bool beSet)
-{
-    option = beSet ? +1 : -1;
-}
-
-YesNoNone::operator void*() const
-{
-    assert(option != 0); // must call configure() first
-    return option > 0 ? (void*)this : NULL;
-}
-
 inline void
 free_YesNoNone(YesNoNone *)
 {
@@ -3981,11 +3980,11 @@ strtokFile(void)
 #include "AccessLogEntry.h"
 
 static void
-parse_access_log(customlog ** logs)
+parse_access_log(CustomLog ** logs)
 {
     const char *filename, *logdef_name;
 
-    customlog *cl = (customlog *)xcalloc(1, sizeof(*cl));
+    CustomLog *cl = (CustomLog *)xcalloc(1, sizeof(*cl));
 
     if ((filename = strtok(NULL, w_space)) == NULL) {
         self_destruct();
@@ -4055,15 +4054,15 @@ parse_access_log(customlog ** logs)
 }
 
 static int
-check_null_access_log(customlog *customlog_definitions)
+check_null_access_log(CustomLog *customlog_definitions)
 {
     return customlog_definitions == NULL;
 }
 
 static void
-dump_access_log(StoreEntry * entry, const char *name, customlog * logs)
+dump_access_log(StoreEntry * entry, const char *name, CustomLog * logs)
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = logs; log; log = log->next) {
         storeAppendPrintf(entry, "%s ", name);
@@ -4115,10 +4114,10 @@ dump_access_log(StoreEntry * entry, const char *name, customlog * logs)
 }
 
 static void
-free_access_log(customlog ** definitions)
+free_access_log(CustomLog ** definitions)
 {
     while (*definitions) {
-        customlog *log = *definitions;
+        CustomLog *log = *definitions;
         *definitions = log->next;
 
         log->logFormat = NULL;
@@ -35,17 +35,17 @@
 
 class wordlist;
 
-extern void configFreeMemory(void);
-extern void self_destruct(void);
-extern void add_http_port(char *portspec);
+void configFreeMemory(void);
+void self_destruct(void);
+void add_http_port(char *portspec);
 
 /* extra functions from cache_cf.c useful for lib modules */
-extern void parse_int(int *var);
-extern void parse_onoff(int *var);
-extern void parse_eol(char *volatile *var);
-extern void parse_wordlist(wordlist ** list);
-extern void requirePathnameExists(const char *name, const char *path);
-extern void parse_time_t(time_t * var);
-extern char *strtokFile(void);
+void parse_int(int *var);
+void parse_onoff(int *var);
+void parse_eol(char *volatile *var);
+void parse_wordlist(wordlist ** list);
+void requirePathnameExists(const char *name, const char *path);
+void parse_time_t(time_t * var);
+char *strtokFile(void);
 
 #endif /* SQUID_CACHE_CF_H_ */
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "base/TextException.h"
+#include "mgr/ActionPasswordList.h"
 #include "CacheManager.h"
 #include "comm/Connection.h"
 #include "Debug.h"
@@ -49,6 +50,7 @@
 #include "mgr/QueryParams.h"
 #include "protos.h"
 #include "tools.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
@@ -458,12 +460,12 @@ CacheManager::ActionProtection(const Mgr::ActionProfile::Pointer &profile)
 }
 
 /*
- \ingroup CacheManagerInternal
+ * \ingroup CacheManagerInternal
  * gets from the global Config the password the user would need to supply
  * for the action she queried
  */
 char *
-CacheManager::PasswdGet(cachemgr_passwd * a, const char *action)
+CacheManager::PasswdGet(Mgr::ActionPasswordList * a, const char *action)
 {
     wordlist *w;
 
@@ -33,9 +33,11 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 #include "URLScheme.h"
@@ -47,14 +49,14 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_carp_peers = 0;
-static peer **carp_peers = NULL;
+static CachePeer **carp_peers = NULL;
 static OBJH carpCachemgr;
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -71,8 +73,8 @@ carpInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -105,7 +107,7 @@ carpInit(void)
     if (n_carp_peers == 0)
         return;
 
-    carp_peers = (peer **)xcalloc(n_carp_peers, sizeof(*carp_peers));
+    carp_peers = (CachePeer **)xcalloc(n_carp_peers, sizeof(*carp_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = carp_peers, p = Config.peers; p; p = p->next) {
@@ -167,12 +169,12 @@ carpInit(void)
     }
 }
 
-peer *
+CachePeer *
 carpSelectParent(HttpRequest * request)
 {
     int k;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -184,7 +186,7 @@ carpSelectParent(HttpRequest * request)
     /* calculate hash key */
     debugs(39, 2, "carpSelectParent: Calculating hash for " << urlCanonical(request));
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_carp_peers; ++k) {
         String key;
         tp = carp_peers[k];
@@ -250,7 +252,7 @@ carpSelectParent(HttpRequest * request)
 static void
 carpCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -33,10 +33,10 @@
 #ifndef SQUID_CARP_H_
 #define SQUID_CARP_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
-extern void carpInit(void);
-extern peer *carpSelectParent(HttpRequest *);
+void carpInit(void);
+CachePeer *carpSelectParent(HttpRequest *);
 
 #endif /* SQUID_CARP_H_ */
@@ -234,30 +234,30 @@ typedef enum {
 } cbdata_type;
 
 /// \ingroup CBDATAAPI
-extern void cbdataRegisterWithCacheManager(void);
+void cbdataRegisterWithCacheManager(void);
 
 #if USE_CBDATA_DEBUG
-extern void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
-extern void *cbdataInternalFreeDbg(void *p, const char *, int);
-extern void cbdataInternalLockDbg(const void *p, const char *, int);
-extern void cbdataInternalUnlockDbg(const void *p, const char *, int);
-extern int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
+void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
+void *cbdataInternalFreeDbg(void *p, const char *, int);
+void cbdataInternalLockDbg(const void *p, const char *, int);
+void cbdataInternalUnlockDbg(const void *p, const char *, int);
+int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
 #else
 
 /// \ingroup CBDATAAPI
-extern void *cbdataInternalAlloc(cbdata_type type);
+void *cbdataInternalAlloc(cbdata_type type);
 
 /// \ingroup CBDATAAPI
-extern void *cbdataInternalFree(void *p);
+void *cbdataInternalFree(void *p);
 
 /// \ingroup CBDATAAPI
-extern void cbdataInternalLock(const void *p);
+void cbdataInternalLock(const void *p);
 
 /// \ingroup CBDATAAPI
-extern void cbdataInternalUnlock(const void *p);
+void cbdataInternalUnlock(const void *p);
 
 /// \ingroup CBDATAAPI
-extern int cbdataInternalReferenceDoneValid(void **p, void **tp);
+int cbdataInternalReferenceDoneValid(void **p, void **tp);
 
 #endif /* !CBDATA_DEBUG */
 
@@ -269,10 +269,10 @@ extern int cbdataInternalReferenceDoneValid(void **p, void **tp);
  \retval 0	A reference is stale. The pointer refers to a entry freed by cbdataFree().
  \retval true	The reference is valid and active.
  */
-extern int cbdataReferenceValid(const void *p);
+int cbdataReferenceValid(const void *p);
 
 /// \ingroup CBDATAAPI
-extern cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
+cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
 
 /* cbdata macros */
 #if USE_CBDATA_DEBUG
@@ -40,6 +40,7 @@
 #include "log/access_log.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -36,24 +36,27 @@
 #include "anyp/ProtocolType.h"
 #include "enums.h"
 #include "ip/Address.h"
+namespace Ip {
+class Address;
+}
 
 class StoreEntry;
 class ClientInfo;
 
-extern void clientdbInit(void);
-extern void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
-extern int clientdbCutoffDenied(const Ip::Address &);
-extern void clientdbDump(StoreEntry *);
-extern void clientdbFreeMemory(void);
-extern int clientdbEstablished(const Ip::Address &, int);
+void clientdbInit(void);
+void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
+int clientdbCutoffDenied(const Ip::Address &);
+void clientdbDump(StoreEntry *);
+void clientdbFreeMemory(void);
+int clientdbEstablished(const Ip::Address &, int);
 
 #if USE_DELAY_POOLS
-extern void clientdbSetWriteLimiter(ClientInfo * info, const int writeSpeedLimit,const double initialBurst,const double highWatermark);
-extern ClientInfo * clientdbGetInfo(const Ip::Address &addr);
+void clientdbSetWriteLimiter(ClientInfo * info, const int writeSpeedLimit,const double initialBurst,const double highWatermark);
+ClientInfo * clientdbGetInfo(const Ip::Address &addr);
 #endif
 
 #if SQUID_SNMP
-extern Ip::Address *client_entry(Ip::Address *current);
+Ip::Address *client_entry(Ip::Address *current);
 #endif
 
 #endif /* SQUID_CLIENT_DB_H_ */
@@ -83,6 +83,7 @@
 #include "anyp/PortCfg.h"
 #include "base/Subscription.h"
 #include "base/TextException.h"
+#include "CachePeer.h"
 #include "ChunkedCodingParser.h"
 #include "client_db.h"
 #include "client_side_reply.h"
@@ -120,6 +121,7 @@
 #include "mime_header.h"
 #include "profiler/Profiler.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "StatHist.h"
@@ -135,6 +137,7 @@
 #include "ClientInfo.h"
 #endif
 #if USE_SSL
+#include "ssl/ProxyCerts.h"
 #include "ssl/context_storage.h"
 #include "ssl/helper.h"
 #include "ssl/ServerBump.h"
@@ -831,7 +834,7 @@ ConnStateData::~ConnStateData()
 }
 
 /**
- * clientSetKeepaliveFlag() sets request->flags.proxy_keepalive.
+ * clientSetKeepaliveFlag() sets request->flags.proxyKeepalive.
  * This is the client-side persistent connection flag.  We need
  * to set this relatively early in the request processing
  * to handle hacks for broken servers and clients.
@@ -847,7 +850,7 @@ clientSetKeepaliveFlag(ClientHttpRequest * http)
            RequestMethodStr(request->method));
 
     // TODO: move to HttpRequest::hdrCacheInit, just like HttpReply.
-    request->flags.proxy_keepalive = request->persistent() ? 1 : 0;
+    request->flags.proxyKeepalive = request->persistent() ? 1 : 0;
 }
 
 static int
@@ -983,7 +986,7 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
 {
     assert(rep == NULL);
 
-    if (!multipartRangeRequest() && !http->request->flags.chunked_reply) {
+    if (!multipartRangeRequest() && !http->request->flags.chunkedReply) {
         size_t length = lengthToSend(bodyData.range());
         noteSentBodyBytes (length);
         AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteBodyComplete",
@@ -1267,7 +1270,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     else if (rep->content_length != http->memObject()->getReply()->content_length)
         range_err = "INCONSISTENT length";	/* a bug? */
 
-    /* hits only - upstream peer determines correct behaviour on misses, and client_side_reply determines
+    /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
      * hits candidates
      */
     else if (logTypeIsATcpHit(http->logType) && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
@@ -1392,7 +1395,7 @@ ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
     if (bodyData.data && bodyData.length) {
         if (multipartRangeRequest())
             packRange(bodyData, mb);
-        else if (http->request->flags.chunked_reply) {
+        else if (http->request->flags.chunkedReply) {
             packChunk(bodyData, *mb);
         } else {
             size_t length = lengthToSend(bodyData.range());
@@ -1447,8 +1450,8 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
 
     // After sending Transfer-Encoding: chunked (at least), always send
     // the last-chunk if there was no error, ignoring responseFinishedOrFailed.
-    const bool mustSendLastChunk = http->request->flags.chunked_reply &&
-                                   !http->request->flags.stream_error && !context->startOfOutput();
+    const bool mustSendLastChunk = http->request->flags.chunkedReply &&
+                                   !http->request->flags.streamError && !context->startOfOutput();
     if (responseFinishedOrFailed(rep, receivedData) && !mustSendLastChunk) {
         context->writeComplete(context->clientConnection, NULL, 0, COMM_OK);
         PROF_stop(clientSocketRecipient);
@@ -1736,7 +1739,7 @@ ClientSocketContext::socketState()
                 debugs(33, 5, HERE << "Range request at end of returnable " <<
                        "range sequence on " << clientConnection);
 
-                if (http->request->flags.proxy_keepalive)
+                if (http->request->flags.proxyKeepalive)
                     return STREAM_COMPLETE;
                 else
                     return STREAM_UNPLANNED_COMPLETE;
@@ -1753,7 +1756,7 @@ ClientSocketContext::socketState()
             // did we get at least what we expected, based on range specs?
 
             if (bytesSent == bytesExpected) { // got everything
-                if (http->request->flags.proxy_keepalive)
+                if (http->request->flags.proxyKeepalive)
                     return STREAM_COMPLETE;
                 else
                     return STREAM_UNPLANNED_COMPLETE;
@@ -1763,7 +1766,7 @@ ClientSocketContext::socketState()
             // expected why would persistency matter? Should not this
             // always be an error?
             if (bytesSent > bytesExpected) { // got extra
-                if (http->request->flags.proxy_keepalive)
+                if (http->request->flags.proxyKeepalive)
                     return STREAM_COMPLETE;
                 else
                     return STREAM_UNPLANNED_COMPLETE;
@@ -2469,7 +2472,7 @@ ConnStateData::quitAfterError(HttpRequest *request)
     // at the client-side, but many such errors do require closure and the
     // client-side code is bad at handling errors so we play it safe.
     if (request)
-        request->flags.proxy_keepalive = 0;
+        request->flags.proxyKeepalive = 0;
     flags.readMore = false;
     debugs(33,4, HERE << "Will close after error: " << clientConnection);
 }
@@ -2648,11 +2651,11 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     request->clientConnectionManager = conn;
 
     request->flags.accelerated = http->flags.accel;
-    request->flags.sslBumped = conn->switchedToHttps();
+    request->flags.sslBumped=conn->switchedToHttps();
     request->flags.canRePin = request->flags.sslBumped && conn->pinning.pinned;
-    request->flags.ignore_cc = conn->port->ignore_cc;
+    request->flags.ignoreCc = conn->port->ignore_cc;
     // TODO: decouple http->flags.accel from request->flags.sslBumped
-    request->flags.no_direct = (request->flags.accelerated && !request->flags.sslBumped) ?
+    request->flags.noDirect = (request->flags.accelerated && !request->flags.sslBumped) ?
                                !conn->port->allow_direct : 0;
 #if USE_AUTH
     if (request->flags.sslBumped) {
@@ -2667,7 +2670,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      */
     if (http->clientConnection != NULL) {
         request->flags.intercepted = ((http->clientConnection->flags & COMM_INTERCEPTION) != 0);
-        request->flags.spoof_client_ip = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        request->flags.spoofClientIp = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
@@ -2819,7 +2822,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      * be freed and the above connNoteUseOfBuffer() would hit an
      * assertion, not to mention that we were accessing freed memory.
      */
-    if (request && request->flags.resetTCP() && Comm::IsConnOpen(conn->clientConnection)) {
+    if (request && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
         debugs(33, 3, HERE << "Sending TCP RST on " << conn->clientConnection);
         conn->flags.readMore = false;
         comm_reset_close(conn->clientConnection);
@@ -3144,7 +3147,7 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
         repContext->setReplyToError(error, scode,
                                     repContext->http->request->method,
                                     repContext->http->uri,
-                                    peer,
+                                    CachePeer,
                                     repContext->http->request,
                                     in.buf, NULL);
         context->pullData();
@@ -3213,7 +3216,7 @@ ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         repContext->setReplyToError(ERR_LIFETIME_EXP,
-                                    HTTP_REQUEST_TIMEOUT, METHOD_NONE, "N/A", &peer.sin_addr,
+                                    HTTP_REQUEST_TIMEOUT, METHOD_NONE, "N/A", &CachePeer.sin_addr,
                                     NULL, NULL, NULL);
         /* No requests can be outstanded */
         assert(chr == NULL);
@@ -3576,7 +3579,7 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
         fakeRequest->indirect_client_addr = connState->clientConnection->remote;
 #endif
         fakeRequest->my_addr = connState->clientConnection->local;
-        fakeRequest->flags.spoof_client_ip = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        fakeRequest->flags.spoofClientIp = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
         fakeRequest->flags.intercepted = ((connState->clientConnection->flags & COMM_INTERCEPTION) != 0);
         debugs(33, 4, HERE << details << " try to generate a Dynamic SSL CTX");
         connState->switchToHttps(fakeRequest, bumpMode);
@@ -3887,7 +3890,7 @@ ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew)
 
     // commSetConnTimeout() was called for this request before we switched.
 
-    // Disable the client read handler until peer selection is complete
+    // Disable the client read handler until CachePeer selection is complete
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, clientNegotiateSSL, this, 0);
     switchedToHttps_ = true;
@@ -4414,7 +4417,7 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
 }
 
 void
-ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, struct peer *aPeer, bool auth)
+ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpRequest *request, CachePeer *aPeer, bool auth)
 {
     char desc[FD_DESC_SZ];
 
@@ -4460,7 +4463,7 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
 }
 
 const Comm::ConnectionPointer
-ConnStateData::validatePinnedConnection(HttpRequest *request, const struct peer *aPeer)
+ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *aPeer)
 {
     debugs(33, 7, HERE << pinning.serverConnection);
 
@@ -53,6 +53,9 @@ class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
 class ChunkedCodingParser;
+namespace AnyP {
+    class PortCfg;
+} // namespace Anyp
 
 /**
  * Badly named.
@@ -259,7 +262,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         int port;               /* port of pinned connection */
         bool pinned;             /* this connection was pinned */
         bool auth;               /* pinned for www authentication */
-        struct peer *peer;             /* peer the connection goes via */
+        CachePeer *peer;             /* CachePeer the connection goes via */
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
@@ -290,23 +293,23 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /**
      * Correlate the current ConnStateData object with the pinning_fd socket descriptor.
      */
-    void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, struct peer *peer, bool auth);
+    void pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth);
     /**
-     * Decorrelate the ConnStateData object from its pinned peer
+     * Decorrelate the ConnStateData object from its pinned CachePeer
      */
     void unpinConnection();
     /**
      * Checks if there is pinning info if it is valid. It can close the server side connection
      * if pinned info is not valid.
      \param request   if it is not NULL also checks if the pinning info refers to the request client side HttpRequest
-     \param peer      if it is not NULL also check if the peer is the pinning peer
+     \param CachePeer      if it is not NULL also check if the CachePeer is the pinning CachePeer
      \return          The details of the server side connection (may be closed if failures were present).
      */
-    const Comm::ConnectionPointer validatePinnedConnection(HttpRequest *request, const struct peer *peer);
+    const Comm::ConnectionPointer validatePinnedConnection(HttpRequest *request, const CachePeer *peer);
     /**
-     * returts the pinned peer if exists, NULL otherwise
+     * returts the pinned CachePeer if exists, NULL otherwise
      */
-    struct peer *pinnedPeer() const {return pinning.peer;}
+    CachePeer *pinnedPeer() const {return pinning.peer;}
     bool pinnedAuth() const {return pinning.auth;}
 
     // pining related comm callbacks
@@ -405,19 +408,14 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     CBDATA_CLASS2(ConnStateData);
 };
 
-/* convenience class while splitting up body handling */
-/* temporary existence only - on stack use expected */
-
 void setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl = false);
 
 const char *findTrailingHTTPVersion(const char *uriAndHTTPVersion, const char *end = NULL);
 
-/* Vary support functions */
-extern int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
+int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
 
-/* client_side.c - FD related client side routines */
-extern void clientOpenListenSockets(void);
-extern void clientHttpConnectionsClose(void);
-extern void httpRequestFree(void *);
+void clientOpenListenSockets(void);
+void clientHttpConnectionsClose(void);
+void httpRequestFree(void *);
 
 #endif /* SQUID_CLIENTSIDE_H */
@@ -54,6 +54,8 @@
 #include "mime_header.h"
 #include "neighbors.h"
 #include "refresh.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -127,11 +129,11 @@ void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorS
 {
     if (errstate->httpStatus == HTTP_NOT_IMPLEMENTED && http->request)
         /* prevent confusion over whether we default to persistent or not */
-        http->request->flags.proxy_keepalive = 0;
+        http->request->flags.proxyKeepalive = 0;
 
     http->al->http.code = errstate->httpStatus;
 
-    createStoreEntry(method, request_flags());
+    createStoreEntry(method, RequestFlags());
     assert(errstate->callback_data == NULL);
     errorAppendEntry(http->storeEntry(), errstate);
     /* Now the caller reads to get this */
@@ -225,7 +227,7 @@ clientReplyContext::restoreState()
 void
 clientReplyContext::startError(ErrorState * err)
 {
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
     triggerInitialStoreRead();
     errorAppendEntry(http->storeEntry(), err);
 }
@@ -388,7 +390,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
     // origin replied 304
     if (status == HTTP_NOT_MODIFIED) {
         http->logType = LOG_TCP_REFRESH_UNMODIFIED;
-        http->request->flags.stale_if_hit = 0; // old_entry is no longer stale
+        http->request->flags.staleIfHit = 0; // old_entry is no longer stale
 
         // update headers on existing entry
         old_rep->updateOnNotModified(http->storeEntry()->getReply());
@@ -417,7 +419,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
     }
 
     // origin replied with an error
-    else if (http->request->flags.fail_on_validation_err) {
+    else if (http->request->flags.failOnValidationError) {
         http->logType = LOG_TCP_REFRESH_FAIL_ERR;
         debugs(88, 3, "handleIMSReply: origin replied with error " << status <<
                ", forwarding to client due to fail_on_validation_err");
@@ -540,9 +542,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
     }
 
     if (e->checkNegativeHit()
-#if USE_HTTP_VIOLATIONS
-            && !r->flags.nocache_hack
-#endif
+            && !r->flags.noCacheHack()
        ) {
         http->logType = LOG_TCP_NEGATIVE_HIT;
         sendMoreData(result);
@@ -552,13 +552,13 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
          * We hold a stale copy; it needs to be validated
          */
         /*
-         * The 'need_validation' flag is used to prevent forwarding
+         * The 'needValidation' flag is used to prevent forwarding
          * loops between siblings.  If our copy of the object is stale,
          * then we should probably only use parents for the validation
          * request.  Otherwise two siblings could generate a loop if
          * both have a stale version of the object.
          */
-        r->flags.need_validation = 1;
+        r->flags.needValidation = 1;
 
         if (e->lastmod < 0) {
             /*
@@ -567,7 +567,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
              */
             http->logType = LOG_TCP_MISS;
             processMiss();
-        } else if (r->flags.nocache) {
+        } else if (r->flags.noCache) {
             /*
              * This did not match a refresh pattern that overrides no-cache
              * we should honour the client no-cache header.
@@ -652,10 +652,10 @@ clientReplyContext::processMiss()
     }
 
     /// Deny loops
-    if (r->flags.loopdetect) {
+    if (r->flags.loopDetected) {
         http->al->http.code = HTTP_FORBIDDEN;
         err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
-        createStoreEntry(r->method, request_flags());
+        createStoreEntry(r->method, RequestFlags());
         errorAppendEntry(http->storeEntry(), err);
         triggerInitialStoreRead();
         return;
@@ -993,7 +993,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
     /* FIXME: This doesn't need to go through the store. Simply
      * push down the client chain
      */
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
 
     triggerInitialStoreRead();
 
@@ -1008,7 +1008,7 @@ clientReplyContext::traceReply(clientStreamNode * node)
 {
     clientStreamNode *nextNode = (clientStreamNode *)node->node.next->data;
     StoreIOBuffer localTempBuffer;
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
     localTempBuffer.offset = nextNode->readBuffer.offset + headers_sz;
     localTempBuffer.length = nextNode->readBuffer.length;
     localTempBuffer.data = nextNode->readBuffer.data;
@@ -1040,7 +1040,7 @@ clientReplyContext::checkTransferDone()
     if (http->flags.done_copying)
         return 1;
 
-    if (http->request->flags.chunked_reply && !flags.complete) {
+    if (http->request->flags.chunkedReply && !flags.complete) {
         // last-chunk was not sent
         return 0;
     }
@@ -1184,7 +1184,7 @@ clientReplyContext::replyStatus()
 
         const int64_t expectedBodySize =
             http->storeEntry()->getReply()->bodySize(http->request->method);
-        if (!http->request->flags.proxy_keepalive && expectedBodySize < 0) {
+        if (!http->request->flags.proxyKeepalive && expectedBodySize < 0) {
             debugs(88, 5, "clientReplyStatus: closing, content_length < 0");
             return STREAM_FAILED;
         }
@@ -1199,7 +1199,7 @@ clientReplyContext::replyStatus()
             return STREAM_UNPLANNED_COMPLETE;
         }
 
-        if (http->request->flags.proxy_keepalive) {
+        if (http->request->flags.proxyKeepalive) {
             debugs(88, 5, "clientReplyStatus: stream complete and can keepalive");
             return STREAM_COMPLETE;
         }
@@ -1374,9 +1374,9 @@ clientReplyContext::buildReplyHeader()
     }
 
     // add Warnings required by RFC 2616 if serving a stale hit
-    if (http->request->flags.stale_if_hit && logTypeIsATcpHit(http->logType)) {
+    if (http->request->flags.staleIfHit && logTypeIsATcpHit(http->logType)) {
         hdr->putWarning(110, "Response is stale");
-        if (http->request->flags.need_validation)
+        if (http->request->flags.needValidation)
             hdr->putWarning(111, "Revalidation failed");
     }
 
@@ -1399,11 +1399,11 @@ clientReplyContext::buildReplyHeader()
                         ||
                         (strncasecmp(value, "Kerberos", 8) == 0 &&
                          (value[8] == '\0' || value[8] == ' '))) {
-                    if (request->flags.connection_auth_disabled) {
+                    if (request->flags.connectionAuthDisabled) {
                         hdr->delAt(pos, connection_auth_blocked);
                         continue;
                     }
-                    request->flags.must_keepalive = 1;
+                    request->flags.mustKeepalive = 1;
                     if (!request->flags.accelerated && !request->flags.intercepted) {
                         httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
@@ -1452,45 +1452,41 @@ clientReplyContext::buildReplyHeader()
 
 #endif
 
-    // XXX: chunking a Content-Range response may not violate specs, but our
-    // ClientSocketContext::writeComplete() confuses the end of ClientStream
-    // with the end of to-client writing and may quit before writing last-chunk
-    const bool maySendChunkedReply = !reply->content_range &&
-                                     !request->multipartRangeRequest() &&
+    const bool maySendChunkedReply = !request->multipartRangeRequest() &&
                                      reply->sline.protocol == AnyP::PROTO_HTTP && // response is HTTP
                                      (request->http_ver >= HttpVersion(1, 1));
 
     /* Check whether we should send keep-alive */
-    if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.must_keepalive) {
+    if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.mustKeepalive) {
         debugs(33, 3, "clientBuildReplyHeader: Error, don't keep-alive");
-        request->flags.proxy_keepalive = 0;
-    } else if (!Config.onoff.client_pconns && !request->flags.must_keepalive) {
+        request->flags.proxyKeepalive = 0;
+    } else if (!Config.onoff.client_pconns && !request->flags.mustKeepalive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection Keep-Alive not requested by admin or client");
-        request->flags.proxy_keepalive = 0;
-    } else if (request->flags.proxy_keepalive && shutting_down) {
+        request->flags.proxyKeepalive = 0;
+    } else if (request->flags.proxyKeepalive && shutting_down) {
         debugs(88, 3, "clientBuildReplyHeader: Shutting down, don't keep-alive.");
-        request->flags.proxy_keepalive = 0;
-    } else if (request->flags.connection_auth && !reply->keep_alive) {
+        request->flags.proxyKeepalive = 0;
+    } else if (request->flags.connectionAuth && !reply->keep_alive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection oriented auth but server side non-persistent");
-        request->flags.proxy_keepalive = 0;
+        request->flags.proxyKeepalive = 0;
     } else if (reply->bodySize(request->method) < 0 && !maySendChunkedReply) {
         debugs(88, 3, "clientBuildReplyHeader: can't keep-alive, unknown body size" );
-        request->flags.proxy_keepalive = 0;
-    } else if (fdUsageHigh()&& !request->flags.must_keepalive) {
+        request->flags.proxyKeepalive = 0;
+    } else if (fdUsageHigh()&& !request->flags.mustKeepalive) {
         debugs(88, 3, "clientBuildReplyHeader: Not many unused FDs, can't keep-alive");
-        request->flags.proxy_keepalive = 0;
+        request->flags.proxyKeepalive = 0;
     } else if (request->flags.sslBumped && !reply->persistent()) {
         // We do not really have to close, but we pretend we are a tunnel.
         debugs(88, 3, "clientBuildReplyHeader: bumped reply forces close");
-        request->flags.proxy_keepalive = 0;
+        request->flags.proxyKeepalive = 0;
     }
 
     // Decide if we send chunked reply
     if (maySendChunkedReply &&
-            request->flags.proxy_keepalive &&
+            request->flags.proxyKeepalive &&
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
-        request->flags.chunked_reply = 1;
+        request->flags.chunkedReply = 1;
         hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
     }
 
@@ -1508,7 +1504,7 @@ clientReplyContext::buildReplyHeader()
         hdr->putStr(HDR_VIA, strVia.termedBuf());
     }
     /* Signal keep-alive or close explicitly */
-    hdr->putStr(HDR_CONNECTION, request->flags.proxy_keepalive ? "keep-alive" : "close");
+    hdr->putStr(HDR_CONNECTION, request->flags.proxyKeepalive ? "keep-alive" : "close");
 
 #if ADD_X_REQUEST_URI
     /*
@@ -1587,19 +1583,15 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
     /** \li If the request has no-cache flag set or some no_cache HACK in operation we
       * 'invalidate' the cached IP entries for this request ???
       */
-    if (r->flags.nocache) {
+    if (r->flags.noCache) {
 
 #if USE_DNSHELPER
         ipcacheInvalidate(r->GetHost());
 #else
         ipcacheInvalidateNegative(r->GetHost());
 #endif /* USE_DNSHELPER */
 
-    }
-
-#if USE_HTTP_VIOLATIONS
-
-    else if (r->flags.nocache_hack) {
+    } else if (r->flags.noCacheHack()) {
 
 #if USE_DNSHELPER
         ipcacheInvalidate(r->GetHost());
@@ -1609,11 +1601,8 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
 
     }
 
-#endif /* USE_HTTP_VIOLATIONS */
 #if USE_CACHE_DIGESTS
-
     lookup_type = http->storeEntry() ? "HIT" : "MISS";
-
 #endif
 
     if (NULL == http->storeEntry()) {
@@ -1657,7 +1646,7 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
         return;
     }
 
-    if (r->flags.nocache) {
+    if (r->flags.noCache) {
         debugs(85, 3, "clientProcessRequest2: no-cache REFRESH MISS");
         http->storeEntry(NULL);
         http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
@@ -1827,7 +1816,7 @@ clientReplyContext::sendStreamError(StoreIOBuffer const &result)
     debugs(88, 5, "clientReplyContext::sendStreamError: A stream error has occured, marking as complete and sending no data.");
     StoreIOBuffer localTempBuffer;
     flags.complete = 1;
-    http->request->flags.stream_error = 1;
+    http->request->flags.streamError = 1;
     localTempBuffer.flags.error = result.flags.error;
     clientStreamCallback((clientStreamNode*)http->client_stream.head->data, http, NULL,
                          localTempBuffer);
@@ -1898,7 +1887,7 @@ clientReplyContext::sendNotModified()
     HttpReply *const temprep = e->getReply()->make304();
     http->logType = LOG_TCP_IMS_HIT;
     removeClientStoreReference(&sc, http);
-    createStoreEntry(http->request->method, request_flags());
+    createStoreEntry(http->request->method, RequestFlags());
     e = http->storeEntry();
     // Copy timestamp from the original entry so the 304
     // reply has a meaningful Age: header.
@@ -2160,7 +2149,7 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
 /* Using this breaks the client layering just a little!
  */
 void
-clientReplyContext::createStoreEntry(const HttpRequestMethod& m, request_flags reqFlags)
+clientReplyContext::createStoreEntry(const HttpRequestMethod& m, RequestFlags reqFlags)
 {
     assert(http != NULL);
     /*
@@ -31,11 +31,12 @@
 #ifndef SQUID_CLIENTSIDEREPLY_H
 #define SQUID_CLIENTSIDEREPLY_H
 
-#include "RefCount.h"
-#include "HttpHeader.h"
+#include "client_side_request.h"
 #include "clientStream.h"
+#include "HttpHeader.h"
+#include "RefCount.h"
+#include "RequestFlags.h"
 #include "StoreClient.h"
-#include "client_side_request.h"
 
 class ErrorState;
 #include "ip/forward.h"
@@ -82,7 +83,7 @@ class clientReplyContext : public RefCountable, public StoreClient
 #endif
     /// creates a store entry for the reply and appends err to it
     void setReplyToError(const HttpRequestMethod& method, ErrorState *err);
-    void createStoreEntry(const HttpRequestMethod& m, request_flags flags);
+    void createStoreEntry(const HttpRequestMethod& m, RequestFlags flags);
     void removeStoreReference(store_client ** scp, StoreEntry ** ep);
     void removeClientStoreReference(store_client **scp, ClientHttpRequest *http);
     void startError(ErrorState * err);
@@ -67,6 +67,7 @@
 #include "MemObject.h"
 #include "Parsing.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
@@ -388,7 +389,7 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
      */
     request->flags.accelerated = http->flags.accel;
 
-    request->flags.internalclient = 1;
+    request->flags.internalClient = 1;
 
     /* this is an internally created
      * request, not subject to acceleration
@@ -533,7 +534,7 @@ clientFollowXForwardedForCheck(allow_t answer, void *data)
         conn->log_addr = request->indirect_client_addr;
     }
     request->x_forwarded_for_iterator.clean();
-    request->flags.done_follow_x_forwarded_for = 1;
+    request->flags.done_follow_x_forwarded_for=true;
 
     if (answer != ACCESS_ALLOWED && answer != ACCESS_DENIED) {
         debugs(28, DBG_CRITICAL, "ERROR: Processing X-Forwarded-For. Stopping at IP address: " << request->indirect_client_addr );
@@ -584,7 +585,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
         debugs(85, 3, "SECURITY ALERT: Host header forgery detected on " << http->getConn()->clientConnection <<
                " (" << A << " does not match " << B << ") on URL: " << urlCanonical(http->request));
 
-        // NP: it is tempting to use 'flags.nocache' but that is all about READing cache data.
+        // NP: it is tempting to use 'flags.noCache' but that is all about READing cache data.
         // The problems here are about WRITE for new cache content, which means flags.cachable
         http->request->flags.cachable = 0; // MUST NOT cache (for now)
         // XXX: when we have updated the cache key to base on raw-IP + URI this cacheable limit can go.
@@ -663,7 +664,7 @@ ClientRequestContext::hostHeaderVerify()
     }
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
-    if (http->request->flags.intercepted || http->request->flags.spoof_client_ip) {
+    if (http->request->flags.intercepted || http->request->flags.spoofClientIp) {
         // verify the Host: port (if any) matches the apparent destination
         if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
             debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
@@ -709,7 +710,7 @@ void
 ClientRequestContext::clientAccessCheck()
 {
 #if FOLLOW_X_FORWARDED_FOR
-    if (!http->request->flags.done_follow_x_forwarded_for &&
+    if (!http->request->flags.doneFollowXff() &&
             Config.accessList.followXFF &&
             http->request->header.has(HDR_X_FORWARDED_FOR)) {
 
@@ -725,7 +726,7 @@ ClientRequestContext::clientAccessCheck()
         acl_checklist->nonBlockingCheck(clientFollowXForwardedForCheck, this);
         return;
     }
-#endif /* FOLLOW_X_FORWARDED_FOR */
+#endif
 
     if (Config.accessList.http) {
         acl_checklist = clientAclChecklistCreate(Config.accessList.http, http);
@@ -923,7 +924,7 @@ clientHierarchical(ClientHttpRequest * http)
     const wordlist *p = NULL;
 
     // intercepted requests MUST NOT (yet) be sent to peers unless verified
-    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.spoof_client_ip))
+    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.spoofClientIp))
         return 0;
 
     /*
@@ -952,7 +953,7 @@ clientHierarchical(ClientHttpRequest * http)
         if (strstr(url, p->key))
             return 0;
 
-    if (request->flags.loopdetect)
+    if (request->flags.loopDetected)
         return 0;
 
     if (request->protocol == AnyP::PROTO_HTTP)
@@ -980,14 +981,14 @@ clientCheckPinning(ClientHttpRequest * http)
     if (!http_conn)
         return;
 
-    request->flags.connection_auth_disabled = http_conn->port->connection_auth_disabled;
-    if (!request->flags.connection_auth_disabled) {
+    request->flags.connectionAuthDisabled = http_conn->port->connection_auth_disabled;
+    if (!request->flags.connectionAuthDisabled) {
         if (Comm::IsConnOpen(http_conn->pinning.serverConnection)) {
             if (http_conn->pinning.auth) {
-                request->flags.connection_auth = 1;
+                request->flags.connectionAuth = 1;
                 request->flags.auth = 1;
             } else {
-                request->flags.connection_proxy_auth = 1;
+                request->flags.connectionProxyAuth = 1;
             }
             // These should already be linked correctly.
             assert(request->clientConnectionManager == http_conn);
@@ -996,10 +997,10 @@ clientCheckPinning(ClientHttpRequest * http)
 
     /* check if connection auth is used, and flag as candidate for pinning
      * in such case.
-     * Note: we may need to set flags.connection_auth even if the connection
+     * Note: we may need to set flags.connectionAuth even if the connection
      * is already pinned if it was pinned earlier due to proxy auth
      */
-    if (!request->flags.connection_auth) {
+    if (!request->flags.connectionAuth) {
         if (req_hdr->has(HDR_AUTHORIZATION) || req_hdr->has(HDR_PROXY_AUTHORIZATION)) {
             HttpHeaderPos pos = HttpHeaderInitPos;
             HttpHeaderEntry *e;
@@ -1013,10 +1014,10 @@ clientCheckPinning(ClientHttpRequest * http)
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
                         if (e->id == HDR_AUTHORIZATION) {
-                            request->flags.connection_auth = 1;
+                            request->flags.connectionAuth = 1;
                             may_pin = 1;
                         } else {
-                            request->flags.connection_proxy_auth = 1;
+                            request->flags.connectionProxyAuth = 1;
                             may_pin = 1;
                         }
                     }
@@ -1044,7 +1045,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     if (request->ims > 0)
         request->flags.ims = 1;
 
-    if (!request->flags.ignore_cc) {
+    if (!request->flags.ignoreCc) {
         if (req_hdr->has(HDR_PRAGMA)) {
             String s = req_hdr->getList(HDR_PRAGMA);
 
@@ -1089,13 +1090,13 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 #if USE_HTTP_VIOLATIONS
 
         if (Config.onoff.reload_into_ims)
-            request->flags.nocache_hack = 1;
+            request->flags.nocacheHack = 1;
         else if (refresh_nocache_hack)
-            request->flags.nocache_hack = 1;
+            request->flags.nocacheHack = 1;
         else
 #endif
 
-            request->flags.nocache = 1;
+            request->flags.noCache = 1;
     }
 
     /* ignore range header in non-GETs or non-HEADs */
@@ -1105,7 +1106,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
             request->range = req_hdr->getRange();
 
         if (request->range) {
-            request->flags.range = 1;
+            request->flags.isRanged=true;
             clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->data;
             /* XXX: This is suboptimal. We should give the stream the range set,
              * and thereby let the top of the stream set the offset when the
@@ -1149,7 +1150,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         if (strListIsSubstr(&s, ThisCache2, ',')) {
             debugObj(33, 1, "WARNING: Forwarding loop detected for:\n",
                      request, (ObjPackMethod) & httpRequestPack);
-            request->flags.loopdetect = 1;
+            request->flags.loopDetected = 1;
         }
 
 #if USE_FORW_VIA_DB
@@ -1176,7 +1177,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         request->flags.hierarchical = 1;
 
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_NOCACHE = " <<
-           (request->flags.nocache ? "SET" : "NOT SET"));
+           (request->flags.noCache ? "SET" : "NOT SET"));
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_CACHABLE = " <<
            (request->flags.cachable ? "SET" : "NOT SET"));
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_HIERARCHICAL = " <<
@@ -36,22 +36,22 @@
 #include "AccessLogEntry.h"
 #include "dlink.h"
 #include "base/AsyncJob.h"
+#include "HttpHeaderRange.h"
 
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
-
 class HttpMsg;
 #endif
 
-/* client_side_request.c - client side request related routines (pure logic) */
-extern int clientBeginRequest(const HttpRequestMethod&, char const *, CSCB *, CSD *, ClientStreamData, HttpHeader const *, char *, size_t);
-
-class MemObject;
-
+class acl_access;
+class ACLFilledChecklist;
+class ClientRequestContext;
 class ConnStateData;
+class MemObject;
 
-class ClientRequestContext;
+/* client_side_request.c - client side request related routines (pure logic) */
+int clientBeginRequest(const HttpRequestMethod&, char const *, CSCB *, CSD *, ClientStreamData, HttpHeader const *, char *, size_t);
 
 class ClientHttpRequest
 #if USE_ADAPTATION
@@ -199,16 +199,15 @@ class ClientHttpRequest
 };
 
 /* client http based routines */
-extern char *clientConstructTraceEcho(ClientHttpRequest *);
+char *clientConstructTraceEcho(ClientHttpRequest *);
 
-class ACLFilledChecklist;
-extern ACLFilledChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
-extern int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
-extern void clientAccessCheck(ClientHttpRequest *);
+ACLFilledChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
+int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
+void clientAccessCheck(ClientHttpRequest *);
 
 /* ones that should be elsewhere */
-extern void redirectStart(ClientHttpRequest *, RH *, void *);
-extern void tunnelStart(ClientHttpRequest *, int64_t *, int *);
+void redirectStart(ClientHttpRequest *, RH *, void *);
+void tunnelStart(ClientHttpRequest *, int64_t *, int *);
 
 #if _USE_INLINE_
 #include "Store.h"
@@ -59,6 +59,7 @@
 #include "MemBuf.h"
 #include "pconn.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "StoreIOBuffer.h"
@@ -113,7 +114,6 @@ static void commSetTcpNoDelay(int);
 #endif
 static void commSetTcpRcvbuf(int, int);
 
-static MemAllocator *conn_close_pool = NULL;
 fd_debug_t *fdd_table = NULL;
 
 bool
@@ -1461,8 +1461,6 @@ comm_init(void)
      * Since Squid_MaxFD can be as high as several thousand, don't waste them */
     RESERVED_FD = min(100, Squid_MaxFD / 4);
 
-    conn_close_pool = memPoolCreate("close_handler", sizeof(close_handler));
-
     TheHalfClosed = new DescriptorSet;
 
     /* setup the select loop module */
@@ -6,32 +6,34 @@
 #include "CommCalls.h"
 #include "comm_err_t.h"
 #include "comm/IoCallback.h"
-#include "ip/Address.h"
 #include "StoreIOBuffer.h"
 
-/* comm.c */
-extern bool comm_iocallbackpending(void); /* inline candidate */
+namespace Ip {
+class Address;
+}
 
-SQUIDCEXTERN int commSetNonBlocking(int fd);
-SQUIDCEXTERN int commUnsetNonBlocking(int fd);
-SQUIDCEXTERN void commSetCloseOnExec(int fd);
-SQUIDCEXTERN void commSetTcpKeepalive(int fd, int idle, int interval, int timeout);
-extern void _comm_close(int fd, char const *file, int line);
+bool comm_iocallbackpending(void); /* inline candidate */
+
+int commSetNonBlocking(int fd);
+int commUnsetNonBlocking(int fd);
+void commSetCloseOnExec(int fd);
+void commSetTcpKeepalive(int fd, int idle, int interval, int timeout);
+void _comm_close(int fd, char const *file, int line);
 #define comm_close(x) (_comm_close((x), __FILE__, __LINE__))
-SQUIDCEXTERN void old_comm_reset_close(int fd);
-SQUIDCEXTERN void comm_reset_close(const Comm::ConnectionPointer &conn);
+void old_comm_reset_close(int fd);
+void comm_reset_close(const Comm::ConnectionPointer &conn);
 #if LINGERING_CLOSE
-SQUIDCEXTERN void comm_lingering_close(int fd);
+void comm_lingering_close(int fd);
 #endif
 
-SQUIDCEXTERN int comm_connect_addr(int sock, const Ip::Address &addr);
-SQUIDCEXTERN void comm_init(void);
-SQUIDCEXTERN void comm_exit(void);
+int comm_connect_addr(int sock, const Ip::Address &addr);
+void comm_init(void);
+void comm_exit(void);
 
-SQUIDCEXTERN int comm_open(int, int, Ip::Address &, int, const char *note);
-SQUIDCEXTERN int comm_open_uds(int sock_type, int proto, struct sockaddr_un* addr, int flags);
+int comm_open(int, int, Ip::Address &, int, const char *note);
+int comm_open_uds(int sock_type, int proto, struct sockaddr_un* addr, int flags);
 /// update Comm state after getting a comm_open() FD from another process
-SQUIDCEXTERN void comm_import_opened(const Comm::ConnectionPointer &, const char *note, struct addrinfo *AI);
+void comm_import_opened(const Comm::ConnectionPointer &, const char *note, struct addrinfo *AI);
 
 /**
  * Open a port specially bound for listening or sending through a specific port.
@@ -48,53 +50,53 @@ SQUIDCEXTERN void comm_import_opened(const Comm::ConnectionPointer &, const char
  * (in debugs or cachemgr) will occur in Native IPv4 format.
  * A reconfigure is needed to reset the stored IP in most cases and attempt a port re-open.
  */
-extern int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note);
-extern void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note);
+int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note);
+void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note);
 
-SQUIDCEXTERN int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *);
-SQUIDCEXTERN unsigned short comm_local_port(int fd);
+int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *);
+unsigned short comm_local_port(int fd);
 
-SQUIDCEXTERN int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
-SQUIDCEXTERN void commCallCloseHandlers(int fd);
+int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
+void commCallCloseHandlers(int fd);
 
 /// clear a timeout handler by FD number
-extern void commUnsetFdTimeout(int fd);
+void commUnsetFdTimeout(int fd);
 
 /**
  * Set or clear the timeout for some action on an active connection.
  * API to replace commSetTimeout() when a Comm::ConnectionPointer is available.
  */
-extern int commSetConnTimeout(const Comm::ConnectionPointer &conn, int seconds, AsyncCall::Pointer &callback);
-extern int commUnsetConnTimeout(const Comm::ConnectionPointer &conn);
+int commSetConnTimeout(const Comm::ConnectionPointer &conn, int seconds, AsyncCall::Pointer &callback);
+int commUnsetConnTimeout(const Comm::ConnectionPointer &conn);
 
-SQUIDCEXTERN int ignoreErrno(int);
-SQUIDCEXTERN void commCloseAllSockets(void);
-SQUIDCEXTERN void checkTimeouts(void);
+int ignoreErrno(int);
+void commCloseAllSockets(void);
+void checkTimeouts(void);
 
 //typedef void IOACB(int fd, int nfd, Comm::ConnectionPointer details, comm_err_t flag, int xerrno, void *data);
-extern void comm_add_close_handler(int fd, CLCB *, void *);
-extern void comm_add_close_handler(int fd, AsyncCall::Pointer &);
-extern void comm_remove_close_handler(int fd, CLCB *, void *);
-extern void comm_remove_close_handler(int fd, AsyncCall::Pointer &);
-
-extern int comm_has_pending_read_callback(int fd);
-extern bool comm_monitors_read(int fd);
-//extern void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, IOCB *handler, void *data);
-extern void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, AsyncCall::Pointer &callback);
-extern void comm_read_cancel(int fd, IOCB *callback, void *data);
-extern void comm_read_cancel(int fd, AsyncCall::Pointer &callback);
-extern int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from);
-extern int comm_udp_recv(int fd, void *buf, size_t len, int flags);
-extern ssize_t comm_udp_send(int s, const void *buf, size_t len, int flags);
-extern bool comm_has_incomplete_write(int);
+void comm_add_close_handler(int fd, CLCB *, void *);
+void comm_add_close_handler(int fd, AsyncCall::Pointer &);
+void comm_remove_close_handler(int fd, CLCB *, void *);
+void comm_remove_close_handler(int fd, AsyncCall::Pointer &);
+
+int comm_has_pending_read_callback(int fd);
+bool comm_monitors_read(int fd);
+//void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, IOCB *handler, void *data);
+void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, AsyncCall::Pointer &callback);
+void comm_read_cancel(int fd, IOCB *callback, void *data);
+void comm_read_cancel(int fd, AsyncCall::Pointer &callback);
+int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from);
+int comm_udp_recv(int fd, void *buf, size_t len, int flags);
+ssize_t comm_udp_send(int s, const void *buf, size_t len, int flags);
+bool comm_has_incomplete_write(int);
 
 /** The read channel has closed and the caller does not expect more data
  * but needs to detect connection aborts. The current detection method uses
  * 0-length reads: We read until the error occurs or the writer closes
  * the connection. If there is a read error, we close the connection.
  */
-extern void commStartHalfClosedMonitor(int fd);
-extern bool commHasHalfClosedMonitor(int fd);
+void commStartHalfClosedMonitor(int fd);
+bool commHasHalfClosedMonitor(int fd);
 // XXX: remove these wrappers which minimize client_side.cc changes in a commit
 inline void commMarkHalfClosed(int fd) { commStartHalfClosedMonitor(fd); }
 inline bool commIsHalfClosed(int fd) { return commHasHalfClosedMonitor(fd); }
@@ -3,6 +3,7 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "comm/ConnOpener.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
@@ -12,12 +13,15 @@
 #include "globals.h"
 #include "icmp/net_db.h"
 #include "ipcache.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
+class CachePeer;
+
 CBDATA_NAMESPACED_CLASS_INIT(Comm, ConnOpener);
 
 Comm::ConnOpener::ConnOpener(Comm::ConnectionPointer &c, AsyncCall::Pointer &handler, time_t ctimeout) :
@@ -203,11 +207,11 @@ Comm::ConnOpener::connected()
 
     /*
      * stats.conn_open is used to account for the number of
-     * connections that we have open to the peer, so we can limit
+     * connections that we have open to the CachePeer, so we can limit
      * based on the max-conn option.  We need to increment here,
      * even if the connection may fail.
      */
-    if (peer *peer=(conn_->getPeer()))
+    if (CachePeer *peer=(conn_->getPeer()))
         ++peer->stats.conn_open;
 
     lookupLocalAddress();
@@ -1,10 +1,12 @@
 #include "squid.h"
+#include "CachePeer.h"
 #include "cbdata.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
 #include "SquidTime.h"
 
+class CachePeer;
 bool
 Comm::IsConnOpen(const Comm::ConnectionPointer &conn)
 {
@@ -18,7 +20,7 @@ Comm::Connection::Connection() :
         fd(-1),
         tos(0),
         flags(COMM_NONBLOCKING),
-        _peer(NULL)
+        peer_(NULL)
 {
     *rfc931 = 0; // quick init the head. the rest does not matter.
 }
@@ -32,7 +34,7 @@ Comm::Connection::~Connection()
         close();
     }
 
-    cbdataReferenceDone(_peer);
+    cbdataReferenceDone(peer_);
 }
 
 Comm::ConnectionPointer
@@ -49,8 +51,8 @@ Comm::Connection::copyDetails() const
     // ensure FD is not open in the new copy.
     c->fd = -1;
 
-    // ensure we have a cbdata reference to _peer not a straight ptr copy.
-    c->_peer = cbdataReference(getPeer());
+    // ensure we have a cbdata reference to peer_ not a straight ptr copy.
+    c->peer_ = cbdataReference(getPeer());
 
     return c;
 }
@@ -61,29 +63,29 @@ Comm::Connection::close()
     if (isOpen()) {
         comm_close(fd);
         fd = -1;
-        if (peer *p=getPeer())
+        if (CachePeer *p=getPeer())
             -- p->stats.conn_open;
     }
 }
 
-peer *
+CachePeer *
 Comm::Connection::getPeer() const
 {
-    if (cbdataReferenceValid(_peer))
-        return _peer;
+    if (cbdataReferenceValid(peer_))
+        return peer_;
 
     return NULL;
 }
 
 void
-Comm::Connection::setPeer(peer *p)
+Comm::Connection::setPeer(CachePeer *p)
 {
     /* set to self. nothing to do. */
     if (getPeer() == p)
         return;
 
-    cbdataReferenceDone(_peer);
+    cbdataReferenceDone(peer_);
     if (p) {
-        _peer = cbdataReference(p);
+        peer_ = cbdataReference(p);
     }
 }
@@ -56,7 +56,7 @@
 #include <ostream>
 #endif
 
-struct peer;
+class CachePeer;
 
 namespace Comm
 {
@@ -108,16 +108,16 @@ class Connection : public RefCountable
     /** determine whether this object describes an active connection or not. */
     bool isOpen() const { return (fd >= 0); }
 
-    /** retrieve the peer pointer for use.
+    /** retrieve the CachePeer pointer for use.
      * The caller is responsible for all CBDATA operations regarding the
      * used of the pointer returned.
      */
-    peer * getPeer() const;
+    CachePeer * getPeer() const;
 
-    /** alter the stored peer pointer.
-     * Perform appropriate CBDATA operations for locking the peer pointer
+    /** alter the stored CachePeer pointer.
+     * Perform appropriate CBDATA operations for locking the CachePeer pointer
      */
-    void setPeer(peer * p);
+    void setPeer(CachePeer * p);
 
 private:
     /** These objects may not be exactly duplicated. Use copyDetails() instead. */
@@ -156,12 +156,8 @@ class Connection : public RefCountable
 #endif
 
 private:
-    // XXX: we need to call this member peer_ but the struct peer_ global type
-    //      behind peer* clashes despite our private Comm:: namespace
-    //      (it being global gets inherited here too).
-
     /** cache_peer data object (if any) */
-    peer *_peer;
+    CachePeer *peer_;
 };
 
 }; // namespace Comm
@@ -63,8 +63,8 @@ class CbEntry
 /// Callbacks which might be scheduled in future are stored in fd_table.
 extern CbEntry *iocb_table;
 
-extern void CallbackTableInit();
-extern void CallbackTableDestruct();
+void CallbackTableInit();
+void CallbackTableDestruct();
 
 #define COMMIO_FD_READCB(fd)    (&Comm::iocb_table[(fd)].readcb)
 #define COMMIO_FD_WRITECB(fd)   (&Comm::iocb_table[(fd)].writecb)
@@ -16,20 +16,20 @@ namespace Comm
 {
 
 /// Initialize the module on Squid startup
-extern void SelectLoopInit(void);
+void SelectLoopInit(void);
 
 /// Mark an FD to be watched for its IO status.
-extern void SetSelect(int, unsigned int, PF *, void *, time_t);
+void SetSelect(int, unsigned int, PF *, void *, time_t);
 
 /// reset/undo/unregister the watch for an FD which was set by Comm::SetSelect()
-extern void ResetSelect(int);
+void ResetSelect(int);
 
 /** Perform a select() or equivalent call.
  * This is used by the main select loop engine to check for FD with IO available.
  */
-extern comm_err_t DoSelect(int);
+comm_err_t DoSelect(int);
 
-extern void QuickPollRequired(void);
+void QuickPollRequired(void);
 
 /**
  * Max number of UDP messages to receive per call to the UDP receive poller.
@@ -40,6 +40,7 @@
 #include "ICP.h"
 #include "mgr/Registration.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -43,6 +43,7 @@
 #include "StatCounters.h"
 #include "StatHist.h"
 #include "Store.h"
+#include "SquidConfig.h"
 
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
@@ -46,6 +46,7 @@
 #include "globals.h"
 #include "ip/Intercept.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 
@@ -11,6 +11,6 @@ struct _fd_debug_t {
 typedef struct _fd_debug_t fd_debug_t;
 extern fd_debug_t *fdd_table;
 
-extern bool isOpen(const int fd);
+bool isOpen(const int fd);
 
 #endif
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "comm/Loops.h"
+#include "disk.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
@@ -37,8 +37,33 @@
 
 class MemBuf;
 
-extern int file_open(const char *path, int mode);
-extern void file_close(int fd);
+// POD
+class dread_ctrl
+{
+public:
+    int fd;
+    off_t offset;
+    int req_len;
+    char *buf;
+    int end_of_file;
+    DRCB *handler;
+    void *client_data;
+};
+
+// POD
+class dwrite_q
+{
+public:
+    off_t file_offset;
+    char *buf;
+    size_t len;
+    size_t buf_offset;
+    dwrite_q *next;
+    FREE *free_func;
+};
+
+int file_open(const char *path, int mode);
+void file_close(int fd);
 
 /* Adapter file_write for object callbacks */
 template <class O>
@@ -49,11 +74,11 @@ FreeObject(void *address)
     delete anObject;
 }
 
-extern void file_write(int, off_t, void const *, int len, DWCB *, void *, FREE *);
-extern void file_write_mbuf(int fd, off_t, MemBuf mb, DWCB * handler, void *handler_data);
-extern void file_read(int, char *, int, off_t, DRCB *, void *);
-extern void disk_init(void);
-extern void safeunlink(const char *path, int quiet);
-extern int xrename(const char *from, const char *to); //disk.cc
+void file_write(int, off_t, void const *, int len, DWCB *, void *, FREE *);
+void file_write_mbuf(int fd, off_t, MemBuf mb, DWCB * handler, void *handler_data);
+void file_read(int, char *, int, off_t, DRCB *, void *);
+void disk_init(void);
+void safeunlink(const char *path, int quiet);
+int xrename(const char *from, const char *to); //disk.cc
 
 #endif /* SQUID_DISK_H_ */
@@ -48,11 +48,11 @@ struct dlink_list {
 
 extern dlink_list ClientActiveRequests;
 
-SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkAddTail(void *data, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkDelete(dlink_node * m, dlink_list * list);
-SQUIDCEXTERN void dlinkNodeDelete(dlink_node * m);
-SQUIDCEXTERN dlink_node *dlinkNodeNew(void);
+void dlinkAdd(void *data, dlink_node *, dlink_list *);
+void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
+void dlinkAddTail(void *data, dlink_node *, dlink_list *);
+void dlinkDelete(dlink_node * m, dlink_list * list);
+void dlinkNodeDelete(dlink_node * m);
+dlink_node *dlinkNodeNew(void);
 
 #endif /* SQUID_DLINK_H */
@@ -32,11 +32,12 @@
  */
 
 #include "squid.h"
+#include "helper.h"
+#include "mgr/Registration.h"
+#include "SquidConfig.h"
+#include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
-#include "SquidTime.h"
-#include "mgr/Registration.h"
-#include "helper.h"
 
 /* MS VisualStudio Projects are monolitich, so we need the following
    #if to include the external DNS code in compile process when
@@ -45,6 +45,7 @@
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc3596.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "tools.h"
@@ -32,8 +32,6 @@
 #ifndef SQUID_ENUMS_H
 #define SQUID_ENUMS_H
 
-#include "HttpStatusCode.h"
-
 typedef enum {
     LOG_TAG_NONE,
     LOG_TCP_HIT,
@@ -192,8 +190,7 @@ enum {
     SNMP_C_USER,
     SNMP_C_COMMUNITY
 };
-
-#endif
+#endif /* SQUID_SNMP */
 
 typedef enum {
     MEM_NONE,
@@ -318,7 +315,7 @@ enum {
     _WIN_OS_WINLON,
     _WIN_OS_WIN7
 };
-#endif
+#endif /* _SQUID_WINDOWS_ */
 
 enum {
     DISABLE_PMTU_OFF,
@@ -334,6 +331,6 @@ typedef enum {
     HTCP_CLR_PURGE,
     HTCP_CLR_INVALIDATION
 } htcp_clr_reason;
-#endif
+#endif /* USE_HTCP */
 
 #endif /* SQUID_ENUMS_H */
@@ -46,6 +46,7 @@
 #include "fde.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "URL.h"
 #include "URLScheme.h"
 #include "URL.h"
@@ -630,7 +631,7 @@ errorAppendEntry(StoreEntry * entry, ErrorState * err)
     if (err->page_id == TCP_RESET) {
         if (err->request) {
             debugs(4, 2, "RSTing this reply");
-            err->request->flags.setResetTCP();
+            err->request->flags.resetTcp=true;
         }
     }
 
@@ -38,12 +38,11 @@
 #include "comm/forward.h"
 #include "err_detail_type.h"
 #include "err_type.h"
+#include "HttpStatusCode.h"
 #include "ip/Address.h"
-#include "MemBuf.h"
 #include "SquidString.h"
-#if USE_AUTH
+/* auth/UserRequest.h is empty unless USE_AUTH is defined */
 #include "auth/UserRequest.h"
-#endif
 #if USE_SSL
 #include "ssl/ErrorDetail.h"
 #endif
@@ -36,6 +36,7 @@
 #include "esi/Element.h"
 #include "clientStream.h"
 #include "err_type.h"
+#include "HttpStatusCode.h"
 
 class ESIVarState;
 class ClientHttpRequest;
@@ -60,6 +60,7 @@
 #include "Mem.h"
 #include "MemBuf.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 /* quick reference on behaviour here.
  * The ESI specification 1.0 requires the ESI processor to be able to
@@ -39,6 +39,6 @@ extern CSR esiStreamRead;
 extern CSCB esiProcessStream;
 extern CSD esiStreamDetach;
 extern CSS esiStreamStatus;
-extern int esiEnableProcessing (HttpReply *);
+int esiEnableProcessing (HttpReply *);
 
 #endif /* SQUID_ESI_H */
@@ -4,8 +4,8 @@
 namespace Esi
 {
 
-extern void Init();
-extern void Clean();
+void Init();
+void Clean();
 
 } // namespace Esi
 
@@ -72,6 +72,6 @@ class ESISegment : public RefCountable
     void dumpOne() const;
 };
 
-extern void ESISegmentFreeList (ESISegment::Pointer &head);
+void ESISegmentFreeList (ESISegment::Pointer &head);
 
 #endif /* SQUID_ESISEGMENT_H */
@@ -37,6 +37,8 @@
 #include "Array.h"
 #include "HttpHeader.h"
 
+class HttpReply;
+
 /* esi variable replacement logic */
 
 typedef enum {
@@ -35,22 +35,19 @@
 #include "Array.h"
 #include "AsyncEngine.h"
 #include "MemPool.h"
-#include "RefCount.h"
-
-/* forward decls */
 
 class StoreEntry;
 
 /* event scheduling facilities - run a callback after a given time period. */
 
 typedef void EVH(void *);
 
-extern void eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata=true);
-SQUIDCEXTERN void eventAddIsh(const char *name, EVH * func, void *arg, double delta_ish, int);
-SQUIDCEXTERN void eventDelete(EVH * func, void *arg);
-SQUIDCEXTERN void eventInit(void);
-SQUIDCEXTERN void eventFreeMemory(void);
-SQUIDCEXTERN int eventFind(EVH *, void *);
+void eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata=true);
+void eventAddIsh(const char *name, EVH * func, void *arg, double delta_ish, int);
+void eventDelete(EVH * func, void *arg);
+void eventInit(void);
+void eventFreeMemory(void);
+int eventFind(EVH *, void *);
 
 class ev_entry
 {
@@ -55,6 +55,7 @@
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -33,12 +33,12 @@
 #ifndef SQUID_FD_H_
 #define SQUID_FD_H_
 
-extern void fd_close(int fd);
-extern void fd_open(int fd, unsigned int type, const char *);
-extern void fd_note(int fd, const char *);
-extern void fd_bytes(int fd, int len, unsigned int type);
-extern void fdDumpOpen(void);
-extern int fdUsageHigh(void);
-extern void fdAdjustReserved(void);
+void fd_close(int fd);
+void fd_open(int fd, unsigned int type, const char *);
+void fd_note(int fd, const char *);
+void fd_bytes(int fd, int len, unsigned int type);
+void fdDumpOpen(void);
+int fdUsageHigh(void);
+void fdAdjustReserved(void);
 
 #endif /* SQUID_FD_H_ */
@@ -31,13 +31,27 @@
 #define SQUID_FDE_H
 
 #include "comm.h"
+#include "defines.h"
 #include "ip/Address.h"
-#include "structs.h"
+
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
 
 #if USE_DELAY_POOLS
 class ClientInfo;
 #endif
+
 class PconnPool;
+class dwrite_q;
+class _fde_disk {
+public:
+    DWCB *wrt_handle;
+    void *wrt_handle_data;
+    dwrite_q *write_q;
+    dwrite_q *write_q_tail;
+    off_t offset;
+};
 
 class fde
 {
@@ -383,7 +383,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_LOCAL_LISTENING_IP: {
             // avoid logging a dash if we have reliable info
             const bool interceptedAtKnownPort = al->request ?
-                                                (al->request->flags.spoof_client_ip ||
+                                                (al->request->flags.spoofClientIp ||
                                                  al->request->flags.intercepted) && al->cache.port :
                                                 false;
             if (interceptedAtKnownPort) {
@@ -6,13 +6,13 @@ namespace Format
 
 /// Safely URL-encode a username.
 /// Accepts NULL or empty strings.
-extern char * QuoteUrlEncodeUsername(const char *name);
+char * QuoteUrlEncodeUsername(const char *name);
 
 /** URL-style encoding on a MIME headers blob.
  * May accept NULL or empty strings.
  * \return A dynamically allocated string. recipient is responsible for free()'ing
  */
-extern char *QuoteMimeBlob(const char *header);
+char *QuoteMimeBlob(const char *header);
 
 }; // namespace Format
 
@@ -2,6 +2,7 @@
 #include "format/Config.h"
 #include "format/Token.h"
 #include "format/TokenTableEntry.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 const char *Format::log_tags[] = {
@@ -32,9 +32,11 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
+#include "acl/AclAddress.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
+#include "CachePeer.h"
 #include "CacheManager.h"
 #include "client_side.h"
 #include "comm/Connection.h"
@@ -63,6 +65,7 @@
 #include "neighbors.h"
 #include "pconn.h"
 #include "PeerSelectState.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -144,7 +147,7 @@ void FwdState::start(Pointer aSelf)
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must force DIRECT and only to the original client destination.
-    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.spoof_client_ip);
+    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.spoofClientIp);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || (request && !request->flags.hostVerified);
     if (isIntercepted && useOriginalDst) {
         selectPeerForIntercepted();
@@ -560,12 +563,6 @@ FwdState::checkRetry()
 bool
 FwdState::checkRetriable()
 {
-    // Optimize: A compliant proxy may retry PUTs, but Squid lacks the [rather
-    // complicated] code required to protect the PUT request body from being
-    // nibbled during the first try. Thus, Squid cannot retry some PUTs today.
-    if (request->body_pipe != NULL)
-        return false;
-
     /* RFC2616 9.1 Safe and Idempotent Methods */
     switch (request->method.id()) {
         /* 9.1.1 Safe Methods */
@@ -765,7 +762,7 @@ FwdState::initiateSSL()
 {
     SSL *ssl;
     SSL_CTX *sslContext = NULL;
-    const peer *peer = serverConnection()->getPeer();
+    const CachePeer *peer = serverConnection()->getPeer();
     int fd = serverConnection()->fd;
 
     if (peer) {
@@ -953,7 +950,7 @@ FwdState::connectStart()
     if (ftimeout < ctimeout)
         ctimeout = ftimeout;
 
-    if (serverDestinations[0]->getPeer() && request->flags.sslBumped == true) {
+    if (serverDestinations[0]->getPeer() && request->flags.sslBumped) {
         debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parrent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, HTTP_SERVICE_UNAVAILABLE, request);
         fail(anErr);
@@ -1251,7 +1248,7 @@ FwdState::reforward()
 ErrorState *
 FwdState::makeConnectingError(const err_type type) const
 {
-    return new ErrorState(type, request->flags.need_validation ?
+    return new ErrorState(type, request->flags.needValidation ?
                           HTTP_GATEWAY_TIMEOUT : HTTP_SERVICE_UNAVAILABLE, request);
 }
 
@@ -1397,7 +1394,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
         conn->local.SetIPv4();
 
     // maybe use TPROXY client address
-    if (request && request->flags.spoof_client_ip) {
+    if (request && request->flags.spoofClientIp) {
         if (!conn->getPeer() || !conn->getPeer()->options.no_tproxy) {
 #if FOLLOW_X_FORWARDED_FOR && LINUX_NETFILTER
             if (Config.onoff.tproxy_uses_indirect_client)
@@ -1424,7 +1421,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     // TODO use the connection details in ACL.
     // needs a bit of rework in ACLFilledChecklist to use Comm::Connection instead of ConnStateData
 
-    acl_address *l;
+    AclAddress *l;
     for (l = Config.accessList.outgoing_address; l; l = l->next) {
 
         /* check if the outgoing address is usable to the destination */
@@ -4,7 +4,9 @@
 #include "Array.h"
 #include "comm.h"
 #include "comm/Connection.h"
+#include "err_type.h"
 #include "fde.h"
+#include "HttpStatusCode.h"
 #include "ip/Address.h"
 #include "RefCount.h"
 
@@ -123,6 +125,6 @@ class FwdState : public RefCountable
     CBDATA_CLASS2(FwdState);
 };
 
-extern void getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn);
+void getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn);
 
 #endif /* SQUID_FORWARD_H */
@@ -36,6 +36,7 @@
 #include "event.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -39,17 +39,17 @@
 class StoreEntry;
 class wordlist;
 
-extern void fqdncache_init(void);
+void fqdncache_init(void);
 void fqdnStats(StoreEntry *);
 //extern void fqdncacheReleaseInvalid(const char *);
 //extern int fqdncacheQueueDrain(void);
-extern void fqdncacheFreeMemory(void);
-extern void fqdncache_restart(void);
-extern void fqdncache_purgelru(void *);
-extern void fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames);
+void fqdncacheFreeMemory(void);
+void fqdncache_restart(void);
+void fqdncache_purgelru(void *);
+void fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames);
 
-extern const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
+const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
 //extern const char *fqdnFromAddr(const Ip::Address &);
-extern void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
+void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
 
 #endif /* SQUID_FQDNCACHE_H_ */
@@ -4,8 +4,8 @@
 namespace Fs
 {
 
-extern void Init();
-extern void Clean();
+void Init();
+void Clean();
 
 } // namespace Fs
 
@@ -105,11 +105,11 @@ class CossSwapDir : public SwapDir, public IORequestor
 };
 
 /// \ingroup COSS
-extern void storeCossAdd(CossSwapDir *, StoreEntry *);
+void storeCossAdd(CossSwapDir *, StoreEntry *);
 /// \ingroup COSS
-extern void storeCossRemove(CossSwapDir *, StoreEntry *);
+void storeCossRemove(CossSwapDir *, StoreEntry *);
 /// \ingroup COSS
-extern void storeCossStartMembuf(CossSwapDir * SD);
+void storeCossStartMembuf(CossSwapDir * SD);
 
 #include "StoreSearch.h"
 
@@ -52,6 +52,7 @@
 #include "store_key_md5.h"
 #include "swap_log_op.h"
 #include "store_rebuild.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 
 #if HAVE_ERRNO_H
@@ -76,7 +77,7 @@ struct _RebuildState {
         unsigned int clean:1;
     } flags;
 
-    struct _store_rebuild_data counts;
+    StoreRebuildData counts;
 };
 
 static char *storeCossDirSwapLogFile(SwapDir *, const char *);
@@ -33,13 +33,14 @@
 
 #include "squid.h"
 #include "CossSwapDir.h"
-#include "Store.h"
-#include "store_coss.h"
-#include "MemObject.h"
+#include "DiskIO/DiskIOStrategy.h"
 #include "fde.h"
-#include "SwapDir.h"
+#include "MemObject.h"
+#include "SquidConfig.h"
+#include "store_coss.h"
+#include "Store.h"
 #include "StoreFScoss.h"
-#include "DiskIO/DiskIOStrategy.h"
+#include "SwapDir.h"
 
 CBDATA_TYPE(CossMemBuf);
 
@@ -2,7 +2,8 @@
 #define SQUID_FS_ROCK_REBUILD_H
 
 #include "base/AsyncJob.h"
-#include "structs.h"
+#include "cbdata.h"
+#include "store_rebuild.h"
 
 namespace Rock
 {
@@ -39,7 +40,7 @@ class Rebuild: public AsyncJob
     int64_t dbOffset;
     int filen;
 
-    struct _store_rebuild_data counts;
+    StoreRebuildData counts;
 
     static void Steps(void *data);
 
@@ -17,6 +17,7 @@
 #include "ipc/mem/Pages.h"
 #include "MemObject.h"
 #include "Parsing.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "tools.h"
 
@@ -34,6 +34,7 @@
 #include "disk.h"
 #include "globals.h"
 #include "RebuildState.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "store_key_md5.h"
 #include "store_rebuild.h"
@@ -32,8 +32,8 @@
 
 #include "RefCount.h"
 #include "UFSSwapDir.h"
-#include "structs.h"
 #include "UFSSwapLogParser.h"
+#include "store_rebuild.h"
 
 class StoreEntry;
 
@@ -76,7 +76,7 @@ class RebuildState : public RefCountable
     char fullpath[MAXPATHLEN];
     char fullfilename[MAXPATHLEN];
 
-    struct _store_rebuild_data counts;
+    StoreRebuildData counts;
 
 private:
     CBDATA_CLASS2(RebuildState);
@@ -46,6 +46,7 @@
 #include "store_key_md5.h"
 #include "StoreSearchUFS.h"
 #include "StoreSwapLogData.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "tools.h"
@@ -53,6 +53,7 @@
 #include "mime.h"
 #include "rfc1738.h"
 #include "Server.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -41,8 +41,8 @@ class FwdState;
  */
 
 /// \ingroup ServerProtocolFTPAPI
-extern void ftpStart(FwdState *);
+void ftpStart(FwdState *);
 /// \ingroup ServerProtocolFTPAPI
-extern const char *ftpUrlWith2f(HttpRequest *);
+const char *ftpUrlWith2f(HttpRequest *);
 
 #endif /* SQUID_FTP_H_ */
@@ -30,18 +30,17 @@
 #ifndef SQUID_GLOBALS_H
 #define SQUID_GLOBALS_H
 
+#include "acl/AclDenyInfoList.h"
+#include "CacheDigest.h"
+#include "defines.h"
+#include "hash.h"
+#include "IoStats.h"
+#include "rfc2181.h"
+
 #if HAVE_STDIO_H
 #include <stdio.h>
 #endif
 
-#include "rfc2181.h"
-
-/* for ERROR_BUF_SZ, BUFSIZ */
-#include "defines.h"
-
-/* for iostats */
-#include "structs.h"
-
 extern char *ConfigFile;	/* NULL */
 extern char *IcpOpcodeStr[];
 extern char tmp_error_buf[ERROR_BUF_SZ];
@@ -85,9 +84,9 @@ extern int syslog_enable;	/* 0 */
 extern int DnsSocketA;		/* -1 */
 extern int DnsSocketB;		/* -1 */
 extern int n_disk_objects;	/* 0 */
-extern iostats IOStats;
+extern IoStats IOStats;
 
-extern struct acl_deny_info_list *DenyInfoList;	/* NULL */
+extern AclDenyInfoList *DenyInfoList;	/* NULL */
 
 extern struct timeval squid_start;
 extern int starting_up;	/* 1 */
@@ -43,6 +43,7 @@
 #include "MemBuf.h"
 #include "mime.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -42,9 +42,9 @@ class HttpRequest;
  */
 
 /// \ingroup ServerProtocolGopherAPI
-extern void gopherStart(FwdState *);
+void gopherStart(FwdState *);
 
 /// \ingroup ServerProtocolGopherAPI
-extern int gopherCachable(const HttpRequest *);
+int gopherCachable(const HttpRequest *);
 
 #endif /* SQUID_GOPHER_H_ */
@@ -35,6 +35,7 @@
 #include "AccessLogEntry.h"
 #include "acl/Acl.h"
 #include "acl/FilledChecklist.h"
+#include "CachePeer.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
@@ -44,11 +45,13 @@
 #include "htcp.h"
 #include "http.h"
 #include "HttpRequest.h"
+#include "HttpStateFlags.h"
 #include "icmp/net_db.h"
 #include "ip/tools.h"
 #include "md5.h"
 #include "MemBuf.h"
 #include "refresh.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "store_key_md5.h"
@@ -1307,7 +1310,7 @@ htcpHandleClr(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 static void
 htcpForwardClr(char *buf, int sz)
 {
-    peer *p;
+    CachePeer *p;
 
     for (p = Config.peers; p; p = p->next) {
         if (!p->options.htcp) {
@@ -1550,7 +1553,7 @@ htcpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int)
 }
 
 int
-htcpQuery(StoreEntry * e, HttpRequest * req, peer * p)
+htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
 {
     cache_key *save_key;
     static char pkt[8192];
@@ -1560,7 +1563,7 @@ htcpQuery(StoreEntry * e, HttpRequest * req, peer * p)
     HttpHeader hdr(hoRequest);
     Packer pa;
     MemBuf mb;
-    http_state_flags flags;
+    HttpStateFlags flags;
 
     if (!Comm::IsConnOpen(htcpIncomingConn))
         return 0;
@@ -1603,10 +1606,10 @@ htcpQuery(StoreEntry * e, HttpRequest * req, peer * p)
 }
 
 /*
- * Send an HTCP CLR message for a specified item to a given peer.
+ * Send an HTCP CLR message for a specified item to a given CachePeer.
  */
 void
-htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, peer * p, htcp_clr_reason reason)
+htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, CachePeer * p, htcp_clr_reason reason)
 {
     static char pkt[8192];
     ssize_t pktlen;
@@ -1615,7 +1618,7 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
     HttpHeader hdr(hoRequest);
     Packer pa;
     MemBuf mb;
-    http_state_flags flags;
+    HttpStateFlags flags;
 
     if (!Comm::IsConnOpen(htcpIncomingConn))
         return;
@@ -61,10 +61,10 @@ class HtcpReplyData
 typedef class HtcpReplyData htcpReplyData;
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void neighborsHtcpReply(const cache_key *, htcpReplyData *, const Ip::Address &);
+void neighborsHtcpReply(const cache_key *, htcpReplyData *, const Ip::Address &);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpOpenPorts(void);
+void htcpOpenPorts(void);
 
 /**
  * \ingroup ServerProtocolHTCP
@@ -79,16 +79,16 @@ SQUIDCEXTERN void htcpOpenPorts(void);
  * 		Don't wait for a reply or count in stats as sent.
  * \retval -1   Error sending request.
  */
-SQUIDCEXTERN int htcpQuery(StoreEntry * e, HttpRequest * req, peer * p);
+int htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, peer * p, htcp_clr_reason reason);
+void htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, CachePeer * p, htcp_clr_reason reason);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpSocketShutdown(void);
+void htcpSocketShutdown(void);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpClosePorts(void);
+void htcpClosePorts(void);
 
 #endif /* USE_HTCP */
 
@@ -39,6 +39,8 @@
 #include "base64.h"
 #include "base/AsyncJobCalls.h"
 #include "base/TextException.h"
+#include "CachePeer.h"
+#include "ChunkedCodingParser.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "comm/Write.h"
@@ -56,6 +58,7 @@
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "HttpStateFlags.h"
 #include "log/access_log.h"
 #include "MemBuf.h"
 #include "MemObject.h"
@@ -64,7 +67,9 @@
 #include "peer_proxy_negotiate_auth.h"
 #include "profiler/Profiler.h"
 #include "refresh.h"
+#include "RefreshPattern.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -94,7 +99,7 @@ static const char *const crlf = "\r\n";
 
 static void httpMaybeRemovePublic(StoreEntry *, http_status);
 static void copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, const String strConnection, const HttpRequest * request,
-        HttpHeader * hdr_out, const int we_do_ranges, const http_state_flags);
+        HttpHeader * hdr_out, const int we_do_ranges, const HttpStateFlags &);
 //Declared in HttpHeaderTools.cc
 void httpHdrAdd(HttpHeader *heads, HttpRequest *request, const AccessLogEntryPointer &al, HeaderWithAclList &headers_add);
 
@@ -335,7 +340,7 @@ HttpStateData::cacheableReply()
     const char *v;
 #if USE_HTTP_VIOLATIONS
 
-    const refresh_t *R = NULL;
+    const RefreshPattern *R = NULL;
 
     /* This strange looking define first looks up the refresh pattern
      * and then checks if the specified flag is set. The main purpose
@@ -376,7 +381,7 @@ HttpStateData::cacheableReply()
         }
     }
 
-    if (request->flags.auth || request->flags.auth_sent) {
+    if (request->flags.auth || request->flags.authSent) {
         /*
          * Responses to requests with authorization may be cached
          * only if a Cache-Control: public reply header is present.
@@ -618,7 +623,7 @@ HttpStateData::keepaliveAccounting(HttpReply *reply)
                 && reply->bodySize(request->method) == -1 && !flags.chunked) {
             debugs(11, DBG_IMPORTANT, "keepaliveAccounting: Impossible keep-alive header from '" << entry->url() << "'" );
             // debugs(11, 2, "GOT HTTP REPLY HDR:\n---------\n" << readBuf->content() << "\n----------" );
-            flags.keepalive_broken = 1;
+            flags.keepalive_broken = true;
         }
     }
 }
@@ -674,7 +679,7 @@ HttpStateData::processReplyHeader()
     } else {
         if (!parsed && error > 0) { // unrecoverable parsing error
             debugs(11, 3, "processReplyHeader: Non-HTTP-compliant header: '" <<  readBuf->content() << "'");
-            flags.headers_parsed = 1;
+            flags.headers_parsed = true;
             newrep->sline.version = HttpVersion(1,1);
             newrep->sline.status = error;
             HttpReply *vrep = setVirginReply(newrep);
@@ -706,17 +711,17 @@ HttpStateData::processReplyHeader()
         return;
     }
 
-    flags.chunked = 0;
+    flags.chunked = false;
     if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->header.chunked()) {
-        flags.chunked = 1;
+        flags.chunked = true;
         httpChunkDecoder = new ChunkedCodingParser;
     }
 
     if (!peerSupportsConnectionPinning())
-        request->flags.connection_auth_disabled = 1;
+        request->flags.connectionAuthDisabled = 1;
 
     HttpReply *vrep = setVirginReply(newrep);
-    flags.headers_parsed = 1;
+    flags.headers_parsed = true;
 
     keepaliveAccounting(vrep);
 
@@ -1060,7 +1065,7 @@ HttpStateData::readReply(const CommIoCbParams &io)
     int clen;
     int len = io.size;
 
-    flags.do_next_read = 0;
+    flags.do_next_read = false;
 
     debugs(11, 5, HERE << io.conn << ": len " << len << ".");
 
@@ -1080,12 +1085,12 @@ HttpStateData::readReply(const CommIoCbParams &io)
         debugs(11, 2, HERE << io.conn << ": read failure: " << xstrerror() << ".");
 
         if (ignoreErrno(io.xerrno)) {
-            flags.do_next_read = 1;
+            flags.do_next_read = true;
         } else {
             ErrorState *err = new ErrorState(ERR_READ_ERROR, HTTP_BAD_GATEWAY, fwd->request);
             err->xerrno = io.xerrno;
             fwd->fail(err);
-            flags.do_next_read = 0;
+            flags.do_next_read = false;
             serverConnection->close();
         }
 
@@ -1128,7 +1133,7 @@ HttpStateData::readReply(const CommIoCbParams &io)
 
     if (len == 0) { // reached EOF?
         eof = 1;
-        flags.do_next_read = 0;
+        flags.do_next_read = false;
 
         /* Bug 2879: Replies may terminate with \r\n then EOF instead of \r\n\r\n
          * Ensure here that we have at minimum two \r\n when EOF is seen.
@@ -1192,7 +1197,7 @@ HttpStateData::continueAfterParsingHeader()
 
     if (!flags.headers_parsed && !eof) {
         debugs(11, 9, HERE << "needs more at " << readBuf->contentSize());
-        flags.do_next_read = 1;
+        flags.do_next_read = true;
         /** \retval false If we have not finished parsing the headers and may get more data.
          *                Schedules more reads to retrieve the missing data.
          */
@@ -1238,7 +1243,7 @@ HttpStateData::continueAfterParsingHeader()
     assert(error != ERR_NONE);
     entry->reset();
     fwd->fail(new ErrorState(error, HTTP_BAD_GATEWAY, fwd->request));
-    flags.do_next_read = 0;
+    flags.do_next_read = false;
     serverConnection->close();
     return false; // quit on error
 }
@@ -1301,7 +1306,7 @@ HttpStateData::decodeAndWriteReplyBody()
     addVirginReplyBody(data, len);
     if (doneParsing) {
         lastChunk = 1;
-        flags.do_next_read = 0;
+        flags.do_next_read = false;
     }
     SQUID_EXIT_THROWING_CODE(wasThereAnException);
     return wasThereAnException;
@@ -1321,7 +1326,7 @@ HttpStateData::processReplyBody()
     bool ispinned = false;
 
     if (!flags.headers_parsed) {
-        flags.do_next_read = 1;
+        flags.do_next_read = true;
         maybeReadVirginBody();
         return;
     }
@@ -1341,7 +1346,7 @@ HttpStateData::processReplyBody()
     if (entry->isAccepting()) {
         if (flags.chunked) {
             if (!decodeAndWriteReplyBody()) {
-                flags.do_next_read = 0;
+                flags.do_next_read = false;
                 serverComplete();
                 return;
             }
@@ -1365,32 +1370,32 @@ HttpStateData::processReplyBody()
                 commSetConnTimeout(serverConnection, Config.Timeout.read, nil);
             }
 
-            flags.do_next_read = 1;
+            flags.do_next_read = true;
         }
         break;
 
         case COMPLETE_PERSISTENT_MSG:
             debugs(11, 5, "processReplyBody: COMPLETE_PERSISTENT_MSG from " << serverConnection);
             /* yes we have to clear all these! */
             commUnsetConnTimeout(serverConnection);
-            flags.do_next_read = 0;
+            flags.do_next_read = false;
 
             comm_remove_close_handler(serverConnection->fd, closeHandler);
             closeHandler = NULL;
             fwd->unregister(serverConnection);
 
-            if (request->flags.spoof_client_ip)
+            if (request->flags.spoofClientIp)
                 client_addr = request->client_addr;
 
             if (request->flags.pinned) {
                 ispinned = true;
-            } else if (request->flags.connection_auth && request->flags.auth_sent) {
+            } else if (request->flags.connectionAuth && request->flags.authSent) {
                 ispinned = true;
             }
 
             if (request->pinnedConnection() && ispinned) {
                 request->pinnedConnection()->pinConnection(serverConnection, request, _peer,
-                        (request->flags.connection_auth != 0));
+                        (request->flags.connectionAuth != 0));
             } else {
                 fwd->pconnPush(serverConnection, request->peer_host ? request->peer_host : request->GetHost());
             }
@@ -1434,7 +1439,7 @@ HttpStateData::maybeReadVirginBody()
         return;
 
     if (flags.do_next_read) {
-        flags.do_next_read = 0;
+        flags.do_next_read = false;
         typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
         entry->delayAwareRead(serverConnection, readBuf->space(read_size), read_size,
                               JobCallback(11, 5, Dialer, this,  HttpStateData::readReply));
@@ -1488,9 +1493,7 @@ HttpStateData::sendComplete()
                                       TimeoutDialer, this, HttpStateData::httpTimeout);
 
     commSetConnTimeout(serverConnection, Config.Timeout.read, timeoutCall);
-
-    flags.request_sent = 1;
-
+    flags.request_sent = true;
     request->hier.peer_http_request_sent = current_time;
 }
 
@@ -1518,7 +1521,7 @@ HttpStateData::doneWithServer() const
  * Fixup authentication request headers for special cases
  */
 static void
-httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHeader * hdr_out, http_state_flags flags)
+httpFixupAuthentication(HttpRequest * request, const HttpHeader * hdr_in, HttpHeader * hdr_out, const HttpStateFlags &flags)
 {
     http_hdr_type header = flags.originpeer ? HDR_AUTHORIZATION : HDR_PROXY_AUTHORIZATION;
 
@@ -1614,7 +1617,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
                                       StoreEntry * entry,
                                       const AccessLogEntryPointer &al,
                                       HttpHeader * hdr_out,
-                                      const http_state_flags flags)
+                                      const HttpStateFlags &flags)
 {
     /* building buffer for complex strings */
 #define BBUF_SZ (MAX_URL+32)
@@ -1645,7 +1648,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
         /* pretend it's not a range request */
         delete request->range;
         request->range = NULL;
-        request->flags.range = 0;
+        request->flags.isRanged=false;
     }
 
     /* append Via */
@@ -1800,7 +1803,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
  * to our outgoing fetch request.
  */
 void
-copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, const String strConnection, const HttpRequest * request, HttpHeader * hdr_out, const int we_do_ranges, const http_state_flags flags)
+copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, const String strConnection, const HttpRequest * request, HttpHeader * hdr_out, const int we_do_ranges, const HttpStateFlags &flags)
 {
     debugs(11, 5, "httpBuildRequestHeader: " << e->name << ": " << e->value );
 
@@ -1981,7 +1984,7 @@ HttpStateData::decideIfWeDoRanges (HttpRequest * request)
     int64_t roffLimit = request->getRangeOffsetLimit();
 
     if (NULL == request->range || !request->flags.cachable
-            || request->range->offsetLimitExceeded(roffLimit) || request->flags.connection_auth)
+            || request->range->offsetLimitExceeded(roffLimit) || request->flags.connectionAuth)
         result = false;
 
     debugs(11, 8, "decideIfWeDoRanges: range specs: " <<
@@ -2014,10 +2017,10 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
         Packer p;
         httpBuildRequestHeader(request, entry, fwd->al, &hdr, flags);
 
-        if (request->flags.pinned && request->flags.connection_auth)
-            request->flags.auth_sent = 1;
+        if (request->flags.pinned && request->flags.connectionAuth)
+            request->flags.authSent = 1;
         else if (hdr.has(HDR_AUTHORIZATION))
-            request->flags.auth_sent = 1;
+            request->flags.authSent = 1;
 
         packerToMemInit(&p, mb);
         hdr.packInto(&p);
@@ -2047,7 +2050,7 @@ HttpStateData::sendRequest()
     AsyncCall::Pointer timeoutCall =  JobCallback(11, 5,
                                       TimeoutDialer, this, HttpStateData::httpTimeout);
     commSetConnTimeout(serverConnection, Config.Timeout.lifetime, timeoutCall);
-    flags.do_next_read = 1;
+    flags.do_next_read = true;
     maybeReadVirginBody();
 
     if (request->body_pipe != NULL) {
@@ -2060,7 +2063,7 @@ HttpStateData::sendRequest()
         Must(!flags.chunked_request);
         // use chunked encoding if we do not know the length
         if (request->content_length < 0)
-            flags.chunked_request = 1;
+            flags.chunked_request = true;
     } else {
         assert(!requestBodySource);
         typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
@@ -2070,31 +2073,31 @@ HttpStateData::sendRequest()
 
     if (_peer != NULL) {
         if (_peer->options.originserver) {
-            flags.proxying = 0;
-            flags.originpeer = 1;
+            flags.proxying = false;
+            flags.originpeer = true;
         } else {
-            flags.proxying = 1;
-            flags.originpeer = 0;
+            flags.proxying = false;
+            flags.originpeer = false;
         }
     } else {
-        flags.proxying = 0;
-        flags.originpeer = 0;
+        flags.proxying = false;
+        flags.originpeer = false;
     }
 
     /*
      * Is keep-alive okay for all request methods?
      */
-    if (request->flags.must_keepalive)
-        flags.keepalive = 1;
+    if (request->flags.mustKeepalive)
+        flags.keepalive = true;
     else if (!Config.onoff.server_pconns)
-        flags.keepalive = 0;
+        flags.keepalive = false;
     else if (_peer == NULL)
-        flags.keepalive = 1;
+        flags.keepalive = true;
     else if (_peer->stats.n_keepalives_sent < 10)
-        flags.keepalive = 1;
+        flags.keepalive = true;
     else if ((double) _peer->stats.n_keepalives_recv /
              (double) _peer->stats.n_keepalives_sent > 0.50)
-        flags.keepalive = 1;
+        flags.keepalive = true;
 
     if (_peer) {
         /*The old code here was
@@ -2110,7 +2113,7 @@ HttpStateData::sendRequest()
          */
         if (neighborType(_peer, request) == PEER_SIBLING &&
                 !_peer->options.allow_miss)
-            flags.only_if_cached = 1;
+            flags.only_if_cached = true;
 
         flags.front_end_https = _peer->front_end_https;
     }
@@ -2270,7 +2273,7 @@ HttpStateData::handleMoreRequestBodyAvailable()
         // XXX: why does not this trigger a debug message on every request?
 
         if (flags.headers_parsed && !flags.abuse_detected) {
-            flags.abuse_detected = 1;
+            flags.abuse_detected = true;
             debugs(11, DBG_IMPORTANT, "http handleMoreRequestBodyAvailable: Likely proxy abuse detected '" << request->client_addr << "' -> '" << entry->url() << "'" );
 
             if (virginReply()->sline.status == HTTP_INVALID_HEADER) {
@@ -32,12 +32,13 @@
 #ifndef SQUID_HTTP_H
 #define SQUID_HTTP_H
 
-#include "StoreIOBuffer.h"
 #include "comm.h"
-#include "comm/forward.h"
-#include "forward.h"
+#include "HttpStateFlags.h"
 #include "Server.h"
-#include "ChunkedCodingParser.h"
+
+class ChunkedCodingParser;
+class FwdState;
+class HttpHeader;
 
 class HttpStateData : public ServerStateData
 {
@@ -50,7 +51,7 @@ class HttpStateData : public ServerStateData
                                        StoreEntry * entry,
                                        const AccessLogEntryPointer &al,
                                        HttpHeader * hdr_out,
-                                       const http_state_flags flags);
+                                       const HttpStateFlags &flags);
 
     virtual const Comm::ConnectionPointer & dataConnection() const;
     /* should be private */
@@ -61,10 +62,10 @@ class HttpStateData : public ServerStateData
     virtual void maybeReadVirginBody(); // read response data from the network
     int cacheableReply();
 
-    peer *_peer;		/* peer request made to */
+    CachePeer *_peer;		/* CachePeer request made to */
     int eof;			/* reached end-of-object? */
     int lastChunk;		/* reached last chunk of a chunk-encoded reply */
-    http_state_flags flags;
+    HttpStateFlags flags;
     size_t read_sz;
     int header_bytes_read;	// to find end of response,
     int64_t reply_bytes_read;	// without relying on StoreEntry
@@ -133,8 +134,8 @@ class HttpStateData : public ServerStateData
     CBDATA_CLASS2(HttpStateData);
 };
 
-extern int httpCachable(const HttpRequestMethod&);
-extern void httpStart(FwdState *);
-extern const char *httpMakeVaryMark(HttpRequest * request, HttpReply const * reply);
+int httpCachable(const HttpRequestMethod&);
+void httpStart(FwdState *);
+const char *httpMakeVaryMark(HttpRequest * request, HttpReply const * reply);
 
 #endif /* SQUID_HTTP_H */
@@ -66,7 +66,7 @@ struct icmpEchoData {
     char payload[MAX_PAYLOAD];
 };
 
-SQUIDCEXTERN int icmp_pkts_sent;
+extern int icmp_pkts_sent;
 
 #endif /* USE_ICMP */
 
@@ -37,6 +37,7 @@
 #include "icmp/IcmpSquid.h"
 #include "icmp/net_db.h"
 #include "ip/tools.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 
@@ -39,6 +39,7 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "cbdata.h"
 #include "disk.h"
 #include "event.h"
@@ -81,7 +82,7 @@ typedef enum {
 } netdb_conn_state_t;
 
 typedef struct {
-    peer *p;
+    CachePeer *p;
     StoreEntry *e;
     store_client *sc;
     HttpRequest *r;
@@ -105,7 +106,7 @@ static void netdbHostDelete(const net_db_name * x);
 static void netdbPurgeLRU(void);
 static netdbEntry *netdbLookupHost(const char *key);
 static net_db_peer *netdbPeerByName(const netdbEntry * n, const char *);
-static net_db_peer *netdbPeerAdd(netdbEntry * n, peer * e);
+static net_db_peer *netdbPeerAdd(netdbEntry * n, CachePeer * e);
 static const char *netdbPeerName(const char *name);
 static IPH netdbSendPing;
 static QS sortPeerByRtt;
@@ -116,7 +117,7 @@ static FREE netdbFreeNetdbEntry;
 static STCB netdbExchangeHandleReply;
 static void netdbExchangeDone(void *);
 
-/* We have to keep a local list of peer names.  The Peers structure
+/* We have to keep a local list of CachePeer names.  The Peers structure
  * gets freed during a reconfigure.  We want this database to
  * remain persisitent, so _net_db_peer->peername points into this
  * linked list */
@@ -421,7 +422,7 @@ netdbPeerByName(const netdbEntry * n, const char *peername)
 }
 
 static net_db_peer *
-netdbPeerAdd(netdbEntry * n, peer * e)
+netdbPeerAdd(netdbEntry * n, CachePeer * e)
 {
     net_db_peer *p;
     net_db_peer *o;
@@ -1123,7 +1124,7 @@ netdbHostData(const char *host, int *samp, int *rtt, int *hops)
 }
 
 void
-netdbUpdatePeer(HttpRequest * r, peer * e, int irtt, int ihops)
+netdbUpdatePeer(HttpRequest * r, CachePeer * e, int irtt, int ihops)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -1159,7 +1160,7 @@ netdbUpdatePeer(HttpRequest * r, peer * e, int irtt, int ihops)
 }
 
 void
-netdbExchangeUpdatePeer(Ip::Address &addr, peer * e, double rtt, double hops)
+netdbExchangeUpdatePeer(Ip::Address &addr, CachePeer * e, double rtt, double hops)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -1313,7 +1314,7 @@ void
 netdbExchangeStart(void *data)
 {
 #if USE_ICMP
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
     char *uri;
     netdbExchangeState *ex;
     StoreIOBuffer tempBuffer;
@@ -1334,7 +1335,7 @@ netdbExchangeStart(void *data)
     assert(NULL != ex->r);
     ex->r->http_ver = HttpVersion(1,1);
     ex->connstate = STATE_HEADER;
-    ex->e = storeCreateEntry(uri, uri, request_flags(), METHOD_GET);
+    ex->e = storeCreateEntry(uri, uri, RequestFlags(), METHOD_GET);
     ex->buf_sz = NETDB_REQBUF_SZ;
     assert(NULL != ex->e);
     ex->sc = storeClientListAdd(ex->e, ex);
@@ -1343,7 +1344,7 @@ netdbExchangeStart(void *data)
     tempBuffer.data = ex->buf;
     storeClientCopy(ex->sc, ex->e, tempBuffer,
                     netdbExchangeHandleReply, ex);
-    ex->r->flags.loopdetect = 1;	/* cheat! -- force direct */
+    ex->r->flags.loopDetected = 1;	/* cheat! -- force direct */
 
     if (p->login)
         xstrncpy(ex->r->login, p->login, MAX_LOGIN_SZ);
@@ -1355,11 +1356,11 @@ netdbExchangeStart(void *data)
 #endif
 }
 
-peer *
+CachePeer *
 netdbClosestParent(HttpRequest * request)
 {
 #if USE_ICMP
-    peer *p = NULL;
+    CachePeer *p = NULL;
     netdbEntry *n;
     const ipcache_addrs *ia;
     net_db_peer *h;
@@ -1,34 +1,72 @@
 #ifndef ICMP_NET_DB_H
 #define ICMP_NET_DB_H
 
+#include "hash.h"
+
+class CachePeer;
+class HttpRequest;
+class netdbEntry;
+class StoreEntry;
 namespace Ip
 {
 class Address;
 };
 
-class StoreEntry;
-class HttpRequest;
+// POD
+class net_db_name
+{
+public:
+    hash_link hash;     /* must be first */
+    net_db_name *next;
+    netdbEntry *net_db_entry;
+};
+
+// POD
+class net_db_peer
+{
+public:
+    const char *peername;
+    double hops;
+    double rtt;
+    time_t expires;
+};
 
-/* for struct peer */
-#include "structs.h"
+// POD
+class netdbEntry
+{
+public:
+    hash_link hash;     /* must be first */
+    char network[MAX_IPSTRLEN];
+    int pings_sent;
+    int pings_recv;
+    double hops;
+    double rtt;
+    time_t next_ping_time;
+    time_t last_use_time;
+    int link_count;
+    net_db_name *hosts;
+    net_db_peer *peers;
+    int n_peers_alloc;
+    int n_peers;
+};
 
-SQUIDCEXTERN void netdbInit(void);
+void netdbInit(void);
 
-SQUIDCEXTERN void netdbHandlePingReply(const Ip::Address &from, int hops, int rtt);
-SQUIDCEXTERN void netdbPingSite(const char *hostname);
+void netdbHandlePingReply(const Ip::Address &from, int hops, int rtt);
+void netdbPingSite(const char *hostname);
 void netdbDump(StoreEntry *);
 
-SQUIDCEXTERN void netdbFreeMemory(void);
-SQUIDCEXTERN int netdbHostHops(const char *host);
-SQUIDCEXTERN int netdbHostRtt(const char *host);
-SQUIDCEXTERN void netdbUpdatePeer(HttpRequest *, peer * e, int rtt, int hops);
+void netdbFreeMemory(void);
+int netdbHostHops(const char *host);
+int netdbHostRtt(const char *host);
+void netdbUpdatePeer(HttpRequest *, CachePeer * e, int rtt, int hops);
 
-SQUIDCEXTERN void netdbDeleteAddrNetwork(Ip::Address &addr);
-SQUIDCEXTERN void netdbBinaryExchange(StoreEntry *);
-SQUIDCEXTERN void netdbExchangeStart(void *);
+void netdbDeleteAddrNetwork(Ip::Address &addr);
+void netdbBinaryExchange(StoreEntry *);
+void netdbExchangeStart(void *);
 
-SQUIDCEXTERN void netdbExchangeUpdatePeer(Ip::Address &, peer *, double, double);
-SQUIDCEXTERN peer *netdbClosestParent(HttpRequest *);
-SQUIDCEXTERN void netdbHostData(const char *host, int *samp, int *rtt, int *hops);
+void netdbExchangeUpdatePeer(Ip::Address &, CachePeer *, double, double);
+CachePeer *netdbClosestParent(HttpRequest *);
+void netdbHostData(const char *host, int *samp, int *rtt, int *hops);
 
 #endif /* ICMP_NET_DB_H */
@@ -56,6 +56,7 @@
 #include "neighbors.h"
 #include "refresh.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -32,6 +32,6 @@
  *
  */
 
-extern int isPowTen(int); //int.cc
+int isPowTen(int); //int.cc
 
 #endif /* SQUID_INT_H_ */
@@ -40,6 +40,7 @@
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "tools.h"
 #include "URL.h"
@@ -37,12 +37,12 @@
 class HttpRequest;
 class StoreEntry;
 
-extern void internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest *, StoreEntry *);
-extern int internalCheck(const char *urlpath);
-extern int internalStaticCheck(const char *urlpath);
-extern char *internalLocalUri(const char *dir, const char *name);
-extern char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
-extern const char *internalHostname(void);
-extern int internalHostnameIs(const char *);
+void internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest *, StoreEntry *);
+int internalCheck(const char *urlpath);
+int internalStaticCheck(const char *urlpath);
+char *internalLocalUri(const char *dir, const char *name);
+char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
+const char *internalHostname(void);
+int internalHostnameIs(const char *);
 
 #endif /* SQUID_INTERNAL_H_ */
@@ -16,9 +16,28 @@
 #include <limits>
 #endif
 
-// Forward-declaration
+class ACLList;
 class fde;
 
+// TODO: move to new ACL framework
+// not integrated in namespace, as this class uses a strange CBDATA definition
+// POD
+class acl_tos {
+public:
+    acl_tos *next;
+    ACLList *aclList;
+    tos_t tos;
+};
+// TODO: move to new ACL framework
+// not integrated in namespace, as this class uses a strange CBDATA definition
+// POD
+class acl_nfmark {
+public:
+    acl_nfmark *next;
+    ACLList *aclList;
+    nfmark_t nfmark;
+};
+
 namespace Ip
 {
 
@@ -36,6 +36,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "ip/Address.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "tools.h"
 #include "rfc1738.h"
@@ -7,8 +7,10 @@
 #define SQUID_IPC_FORWARDER_H
 
 #include "base/AsyncJob.h"
-#include "mgr/ActionParams.h"
+#include "cbdata.h"
 #include "ipc/Request.h"
+#include "mgr/ActionParams.h"
+
 #include <map>
 
 namespace Ipc
@@ -7,7 +7,7 @@
 #include "globals.h"
 #include "ipc/Kids.h"
 #include "tools.h"
-#include "structs.h"
+#include "SquidConfig.h"
 
 Kids TheKids;
 KidName TheKidName;
@@ -8,7 +8,6 @@
 #include "base/RunnersRegistry.h"
 #include "ipc/mem/PagePool.h"
 #include "ipc/mem/Pages.h"
-#include "structs.h"
 #include "SwapDir.h"
 #include "tools.h"
 
@@ -38,6 +38,7 @@
 #include "fde.h"
 #include "ip/Address.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 #include "tools.h"
@@ -41,6 +41,7 @@
 #include "Mem.h"
 #include "mgr/Registration.h"
 #include "rfc3596.h"
+#include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -18,19 +18,19 @@ typedef struct _ipcache_addrs {
 
 typedef void IPH(const ipcache_addrs *, const DnsLookupDetails &details, void *);
 
-extern void ipcache_purgelru(void *);
-extern void ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData);
-extern const ipcache_addrs *ipcache_gethostbyname(const char *, int flags);
-extern void ipcacheInvalidate(const char *);
-extern void ipcacheInvalidateNegative(const char *);
-extern void ipcache_init(void);
-extern void ipcacheCycleAddr(const char *name, ipcache_addrs *);
-extern void ipcacheMarkBadAddr(const char *name, const Ip::Address &);
-extern void ipcacheMarkGoodAddr(const char *name, const Ip::Address &);
-extern void ipcacheMarkAllGood(const char *name);
-extern void ipcacheFreeMemory(void);
-extern ipcache_addrs *ipcacheCheckNumeric(const char *name);
-extern void ipcache_restart(void);
-extern int ipcacheAddEntryFromHosts(const char *name, const char *ipaddr);
+void ipcache_purgelru(void *);
+void ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData);
+const ipcache_addrs *ipcache_gethostbyname(const char *, int flags);
+void ipcacheInvalidate(const char *);
+void ipcacheInvalidateNegative(const char *);
+void ipcache_init(void);
+void ipcacheCycleAddr(const char *name, ipcache_addrs *);
+void ipcacheMarkBadAddr(const char *name, const Ip::Address &);
+void ipcacheMarkGoodAddr(const char *name, const Ip::Address &);
+void ipcacheMarkAllGood(const char *name);
+void ipcacheFreeMemory(void);
+ipcache_addrs *ipcacheCheckNumeric(const char *name);
+void ipcache_restart(void);
+int ipcacheAddEntryFromHosts(const char *name, const char *ipaddr);
 
 #endif /* _SQUID_IPCACHE_H */
@@ -0,0 +1,31 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#include "squid.h"
+#include "CustomLog.h"
+
@@ -0,0 +1,52 @@
+#ifndef SQUID_CUSTOMLOG_H_
+#define SQUID_CUSTOMLOG_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+//#include "format/Format.h"
+#include "log/Formats.h"
+
+class ACLList;
+class Logfile;
+namespace Format {
+class Format;
+}
+
+/// representaiton of a custom log directive. Currently a POD.
+class CustomLog
+{
+public:
+    char *filename;
+    ACLList *aclList;
+    Format::Format *logFormat;
+    Logfile *logfile;
+    CustomLog *next;
+    Log::Format::log_type type;
+};
+
+#endif /* SQUID_CUSTOMLOG_H_ */
@@ -38,6 +38,7 @@
 #include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -37,6 +37,7 @@
 #include "globals.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -32,12 +32,14 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
+#include "format/Format.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "MemBuf.h"
 
 void
-Log::Format::SquidCustom(const AccessLogEntry::Pointer &al, customlog * log)
+Log::Format::SquidCustom(const AccessLogEntry::Pointer &al, CustomLog * log)
 {
     static MemBuf mb;
     mb.reset();
@@ -40,6 +40,7 @@
 #include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -37,6 +37,7 @@
 #include "globals.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 void
@@ -1,10 +1,12 @@
 #ifndef _SQUID_LOG_FORMATS_H
 #define _SQUID_LOG_FORMATS_H
 
+#include "AccessLogEntry.h"
 #include "RefCount.h"
 
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
+class CustomLog;
 class Logfile;
 
 namespace Log
@@ -40,7 +42,7 @@ void SquidUserAgent(const AccessLogEntryPointer &al, Logfile * logfile);
 void SquidReferer(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Log with a local custom format
-void SquidCustom(const AccessLogEntryPointer &al, customlog * log);
+void SquidCustom(const AccessLogEntryPointer &al, CustomLog * log);
 
 /// Log with Apache httpd common format
 void HttpdCommon(const AccessLogEntryPointer &al, Logfile * logfile);
@@ -27,5 +27,7 @@ liblog_la_SOURCES = \
 	ModTcp.cc \
 	ModTcp.h \
 	ModUdp.cc \
-	ModUdp.h
+	ModUdp.h \
+	CustomLog.h \
+	CustomLog.cc
 
@@ -39,6 +39,7 @@
 #include "log/File.h"
 #include "log/ModDaemon.h"
 #include "SquidIpc.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 #if HAVE_ERRNO_H
@@ -37,6 +37,7 @@
 #include "globals.h"
 #include "log/File.h"
 #include "log/ModStdio.h"
+#include "SquidConfig.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -39,7 +39,7 @@
 #include "log/File.h"
 #include "log/ModTcp.h"
 #include "Parsing.h"
-#include "structs.h"
+#include "SquidConfig.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -38,7 +38,7 @@
 #include "log/File.h"
 #include "log/ModUdp.h"
 #include "Parsing.h"
-#include "structs.h"
+#include "SquidConfig.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -32,10 +32,10 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "Store.h"
-#include "errorpage.h"
-#include "err_detail_type.h"
 #include "acl/Checklist.h"
+#include "CachePeer.h"
+#include "err_detail_type.h"
+#include "errorpage.h"
 #include "errorpage.h"
 #include "format/Token.h"
 #include "globals.h"
@@ -44,12 +44,15 @@
 #include "HttpRequest.h"
 #include "log/access_log.h"
 #include "log/Config.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
+#include "Store.h"
 
 #if USE_SQUID_EUI
 #include "eui/Eui48.h"
@@ -88,7 +91,7 @@ static void fvdbRegisterWithCacheManager();
 int LogfileStatus = LOG_DISABLE;
 
 void
-accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist * checklist)
+accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 {
 
     if (al->url == NULL)
@@ -201,7 +204,7 @@ accessLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 void
 accessLogRotate(void)
 {
-    customlog *log;
+    CustomLog *log;
 #if USE_FORW_VIA_DB
 
     fvdbClear();
@@ -223,7 +226,7 @@ accessLogRotate(void)
 void
 accessLogClose(void)
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.accesslogs; log; log = log->next) {
         if (log->logfile) {
@@ -298,7 +301,7 @@ accessLogRegisterWithCacheManager(void)
 void
 accessLogInit(void)
 {
-    customlog *log;
+    CustomLog *log;
 
     accessLogRegisterWithCacheManager();
 
@@ -83,6 +83,7 @@
 #include "send-announce.h"
 #include "store_log.h"
 #include "tools.h"
+#include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "stat.h"
@@ -31,13 +31,20 @@
  */
 
 #include "squid.h"
-#include "event.h"
+#include "acl/AclDenyInfoList.h"
+#include "acl/AclNameList.h"
+#include "CacheDigest.h"
 #include "ClientInfo.h"
-#include "Mem.h"
+#include "disk.h"
+#include "event.h"
 #include "md5.h"
+#include "Mem.h"
 #include "MemBuf.h"
 #include "memMeter.h"
 #include "mgr/Registration.h"
+#include "icmp/net_db.h"
+#include "RegexList.h"
+#include "SquidConfig.h"
 #include "SquidList.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -448,9 +455,9 @@ Mem::Init(void)
     memDataInit(MEM_16K_BUF, "16K Buffer", 16384, 10, false);
     memDataInit(MEM_32K_BUF, "32K Buffer", 32768, 10, false);
     memDataInit(MEM_64K_BUF, "64K Buffer", 65536, 10, false);
-    memDataInit(MEM_ACL_DENY_INFO_LIST, "acl_deny_info_list",
-                sizeof(acl_deny_info_list), 0);
-    memDataInit(MEM_ACL_NAME_LIST, "acl_name_list", sizeof(acl_name_list), 0);
+    memDataInit(MEM_ACL_DENY_INFO_LIST, "AclDenyInfoList",
+                sizeof(AclDenyInfoList), 0);
+    memDataInit(MEM_ACL_NAME_LIST, "acl_name_list", sizeof(AclNameList), 0);
 #if USE_CACHE_DIGESTS
 
     memDataInit(MEM_CACHE_DIGEST, "CacheDigest", sizeof(CacheDigest), 0);
@@ -463,7 +470,7 @@ Mem::Init(void)
     memDataInit(MEM_HTTP_HDR_CONTENT_RANGE, "HttpHdrContRange", sizeof(HttpHdrContRange), 0);
     memDataInit(MEM_NETDBENTRY, "netdbEntry", sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, "net_db_name", sizeof(net_db_name), 0);
-    memDataInit(MEM_RELIST, "relist", sizeof(relist), 0);
+    memDataInit(MEM_RELIST, "RegexList", sizeof(RegexList), 0);
     memDataInit(MEM_CLIENT_INFO, "ClientInfo", sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, "MD5 digest", SQUID_MD5_DIGEST_LENGTH, 0);
     MemPools[MEM_MD5_DIGEST]->setChunkSize(512 * 1024);
@@ -9,6 +9,7 @@
 #include "HttpRequestMethod.h"
 #include "ipc/forward.h"
 #include "mgr/QueryParams.h"
+#include "RequestFlags.h"
 
 namespace Mgr
 {
@@ -26,7 +27,7 @@ class ActionParams
     /* details of the client HTTP request that caused the action */
     String httpUri; ///< HTTP request URI
     _method_t httpMethod; ///< HTTP request method
-    request_flags httpFlags; ///< HTTP request flags
+    RequestFlags httpFlags; ///< HTTP request flags
     String httpOrigin;       ///< HTTP Origin: header (if any)
 
     /* action parameters extracted from the client HTTP request */
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "mgr/ActionPasswordList.h"
+
@@ -0,0 +1,47 @@
+#ifndef SQUID_MGR_CACHEMGRPASSWD_H_
+#define SQUID_MGR_CACHEMGRPASSWD_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class wordlist;
+
+namespace Mgr {
+//TODO: refactor into a std::list
+/// list of cachemgr password authorization definitions. Currently a POD.
+class ActionPasswordList
+{
+public:
+    char *passwd;
+    wordlist *actions;
+    ActionPasswordList *next;
+};
+
+} //namespace Mgr
+
+#endif /* SQUID_MGR_CACHEMGRPASSWD_H_ */
@@ -12,6 +12,7 @@
 #include "mgr/Registration.h"
 #include "protos.h"
 #include "Store.h"
+#include "SquidConfig.h"
 
 Mgr::IndexAction::Pointer
 Mgr::IndexAction::Create(const Command::Pointer &cmd)
@@ -5,6 +5,7 @@
 
 #include "squid.h"
 #include "base/TextException.h"
+#include "IoStats.h"
 #include "ipc/Messages.h"
 #include "ipc/TypedMsgHdr.h"
 #include "mgr/IoAction.h"
@@ -24,13 +25,13 @@ Mgr::IoActionData&
 Mgr::IoActionData::operator += (const IoActionData& stats)
 {
     http_reads += stats.http_reads;
-    for (int i = 0; i < _iostats::histSize; ++i)
+    for (int i = 0; i < IoStats::histSize; ++i)
         http_read_hist[i] += stats.http_read_hist[i];
     ftp_reads += stats.ftp_reads;
-    for (int i = 0; i < _iostats::histSize; ++i)
+    for (int i = 0; i < IoStats::histSize; ++i)
         ftp_read_hist[i] += stats.ftp_read_hist[i];
     gopher_reads += stats.gopher_reads;
-    for (int i = 0; i < _iostats::histSize; ++i)
+    for (int i = 0; i < IoStats::histSize; ++i)
         gopher_read_hist[i] += stats.gopher_read_hist[i];
 
     return *this;
@@ -7,7 +7,7 @@
 #define SQUID_MGR_IO_ACTION_H
 
 #include "mgr/Action.h"
-#include "structs.h" /* _iostats::histSize */
+#include "IoStats.h"
 
 namespace Mgr
 {
@@ -23,9 +23,9 @@ class IoActionData
     double http_reads;
     double ftp_reads;
     double gopher_reads;
-    double http_read_hist[_iostats::histSize];
-    double ftp_read_hist[_iostats::histSize];
-    double gopher_read_hist[_iostats::histSize];
+    double http_read_hist[IoStats::histSize];
+    double ftp_read_hist[IoStats::histSize];
+    double gopher_read_hist[IoStats::histSize];
 };
 
 /// implement aggregated 'io' action
@@ -9,6 +9,8 @@ libmgr_la_SOURCES = \
 	Action.h \
 	ActionParams.cc \
 	ActionParams.h \
+	ActionPasswordList.h \
+	ActionPasswordList.cc \
 	ActionProfile.h \
 	ActionWriter.cc \
 	ActionWriter.h \
@@ -43,6 +43,8 @@
 #include "MemBuf.h"
 #include "mime.h"
 #include "MemObject.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
@@ -430,7 +432,7 @@ MimeIcon::created (StoreEntry *newEntry)
 
     int n;
 
-    request_flags flags;
+    RequestFlags flags;
 
     struct stat sb;
 
@@ -1,6 +1,6 @@
 /*
- * DEBUG: section
- * AUTHOR:
+ * DEBUG: section 25    MIME Parsing and Internal Icons
+ * AUTHOR: Harvest Derived
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -33,12 +33,12 @@
 #ifndef SQUID_MIME_H_
 #define SQUID_MIME_H_
 
-extern void mimeInit(char *filename);
-extern char *mimeGetContentEncoding(const char *fn);
-extern char *mimeGetContentType(const char *fn);
-extern const char *mimeGetIconURL(const char *fn);
-extern char mimeGetTransferMode(const char *fn);
-extern int mimeGetDownloadOption(const char *fn);
-extern int mimeGetViewOption(const char *fn);
+void mimeInit(char *filename);
+char *mimeGetContentEncoding(const char *fn);
+char *mimeGetContentType(const char *fn);
+const char *mimeGetIconURL(const char *fn);
+char mimeGetTransferMode(const char *fn);
+int mimeGetDownloadOption(const char *fn);
+int mimeGetViewOption(const char *fn);
 
 #endif /* SQUID_MIME_H_ */
@@ -33,8 +33,8 @@
 #ifndef SQUID_MIME_HEADER_H_
 #define SQUID_MIME_HEADER_H_
 
-extern char *mime_get_header(const char *mime, const char *header);
-extern char *mime_get_header_field(const char *mime, const char *name, const char *prefix);
-extern size_t headersEnd(const char *, size_t);
+char *mime_get_header(const char *mime, const char *header);
+char *mime_get_header_field(const char *mime, const char *name, const char *prefix);
+size_t headersEnd(const char *, size_t);
 
 #endif /* SQUID_MIME_HEADER_H_ */
@@ -1,4 +1,3 @@
-
 /*
  * DEBUG: section 07    Multicast
  * AUTHOR: Martin Hamilton
@@ -1,6 +1,6 @@
 /*
- * DEBUG: section
- * AUTHOR:
+ * DEBUG: section 07    Multicast
+ * AUTHOR: Martin Hamilton
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -35,7 +35,7 @@
 
 #include "ipcache.h"
 
-extern int mcastSetTtl(int, int);
+int mcastSetTtl(int, int);
 extern IPH mcastJoinGroups;
 
 #endif /* SQUID_MULTICAST_H_ */
@@ -34,6 +34,8 @@
 #include "acl/FilledChecklist.h"
 #include "anyp/PortCfg.h"
 #include "CacheDigest.h"
+#include "CachePeer.h"
+#include "CachePeerDomainList.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
@@ -50,9 +52,12 @@
 #include "MemObject.h"
 #include "mgr/Registration.h"
 #include "multicast.h"
+#include "NeighborTypeDomainList.h"
 #include "neighbors.h"
 #include "PeerDigest.h"
 #include "PeerSelectState.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "stat.h"
@@ -64,35 +69,35 @@
 /* count mcast group peers every 15 minutes */
 #define MCAST_COUNT_RATE 900
 
-bool peerAllowedToUse(const peer *, HttpRequest *);
-static int peerWouldBePinged(const peer *, HttpRequest *);
-static void neighborRemove(peer *);
-static void neighborAlive(peer *, const MemObject *, const icp_common_t *);
+bool peerAllowedToUse(const CachePeer *, HttpRequest *);
+static int peerWouldBePinged(const CachePeer *, HttpRequest *);
+static void neighborRemove(CachePeer *);
+static void neighborAlive(CachePeer *, const MemObject *, const icp_common_t *);
 #if USE_HTCP
-static void neighborAliveHtcp(peer *, const MemObject *, const htcpReplyData *);
+static void neighborAliveHtcp(CachePeer *, const MemObject *, const htcpReplyData *);
 #endif
-static void neighborCountIgnored(peer *);
+static void neighborCountIgnored(CachePeer *);
 static void peerRefreshDNS(void *);
 static IPH peerDNSConfigure;
-static bool peerProbeConnect(peer *);
+static bool peerProbeConnect(CachePeer *);
 static CNCB peerProbeConnectDone;
 static void peerCountMcastPeersDone(void *data);
 static void peerCountMcastPeersStart(void *data);
-static void peerCountMcastPeersSchedule(peer * p, time_t when);
+static void peerCountMcastPeersSchedule(CachePeer * p, time_t when);
 static IRCB peerCountHandleIcpReply;
 
 static void neighborIgnoreNonPeer(const Ip::Address &, icp_opcode);
 static OBJH neighborDumpPeers;
 static OBJH neighborDumpNonPeers;
-static void dump_peers(StoreEntry * sentry, peer * peers);
+static void dump_peers(StoreEntry * sentry, CachePeer * peers);
 
 static unsigned short echo_port;
 
 static int NLateReplies = 0;
-static peer *first_ping = NULL;
+static CachePeer *first_ping = NULL;
 
 const char *
-neighborTypeStr(const peer * p)
+neighborTypeStr(const CachePeer * p)
 {
     if (p->type == PEER_NONE)
         return "Non-Peer";
@@ -106,12 +111,12 @@ neighborTypeStr(const peer * p)
     return "Parent";
 }
 
-peer *
+CachePeer *
 whichPeer(const Ip::Address &from)
 {
     int j;
 
-    peer *p = NULL;
+    CachePeer *p = NULL;
     debugs(15, 3, "whichPeer: from " << from);
 
     for (p = Config.peers; p; p = p->next) {
@@ -126,10 +131,10 @@ whichPeer(const Ip::Address &from)
 }
 
 peer_t
-neighborType(const peer * p, const HttpRequest * request)
+neighborType(const CachePeer * p, const HttpRequest * request)
 {
 
-    const struct _domain_type *d = NULL;
+    const NeighborTypeDomainList *d = NULL;
 
     for (d = p->typelist; d; d = d->next) {
         if (0 == matchDomainName(request->GetHost(), d->domain))
@@ -149,33 +154,33 @@ neighborType(const peer * p, const HttpRequest * request)
  * \return Whether it is appropriate to fetch REQUEST from PEER.
  */
 bool
-peerAllowedToUse(const peer * p, HttpRequest * request)
+peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 {
 
-    const struct _domain_ping *d = NULL;
+    const CachePeerDomainList *d = NULL;
     assert(request != NULL);
 
     if (neighborType(p, request) == PEER_SIBLING) {
 #if PEER_MULTICAST_SIBLINGS
         if (p->type == PEER_MULTICAST && p->options.mcast_siblings &&
-                (request->flags.nocache || request->flags.refresh || request->flags.loopdetect || request->flags.need_validation))
+                (request->flags.noCache || request->flags.refresh || request->flags.loopDetected || request->flags.needValidation))
             debugs(15, 2, "peerAllowedToUse(" << p->name << ", " << request->GetHost() << ") : multicast-siblings optimization match");
 #endif
-        if (request->flags.nocache)
+        if (request->flags.noCache)
             return false;
 
         if (request->flags.refresh)
             return false;
 
-        if (request->flags.loopdetect)
+        if (request->flags.loopDetected)
             return false;
 
-        if (request->flags.need_validation)
+        if (request->flags.needValidation)
             return false;
     }
 
     // CONNECT requests are proxy requests. Not to be forwarded to origin servers.
-    // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this peer.
+    // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this CachePeer.
     if (p->options.originserver && request->method == METHOD_CONNECT && request->port != p->in_addr.GetPort())
         return false;
 
@@ -205,9 +210,9 @@ peerAllowedToUse(const peer * p, HttpRequest * request)
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
-/* Return TRUE if it is okay to send an ICP request to this peer.   */
+/* Return TRUE if it is okay to send an ICP request to this CachePeer.   */
 static int
-peerWouldBePinged(const peer * p, HttpRequest * request)
+peerWouldBePinged(const CachePeer * p, HttpRequest * request)
 {
     if (p->icp.port == 0)
         return 0;
@@ -243,9 +248,9 @@ peerWouldBePinged(const peer * p, HttpRequest * request)
     return 1;
 }
 
-/* Return TRUE if it is okay to send an HTTP request to this peer. */
+/* Return TRUE if it is okay to send an HTTP request to this CachePeer. */
 int
-peerHTTPOkay(const peer * p, HttpRequest * request)
+peerHTTPOkay(const CachePeer * p, HttpRequest * request)
 {
     if (p->max_conn)
         if (p->stats.conn_open >= p->max_conn)
@@ -263,7 +268,7 @@ peerHTTPOkay(const peer * p, HttpRequest * request)
 int
 neighborsCount(HttpRequest * request)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
     int count = 0;
 
     for (p = Config.peers; p; p = p->next)
@@ -275,10 +280,10 @@ neighborsCount(HttpRequest * request)
     return count;
 }
 
-peer *
+CachePeer *
 getFirstUpParent(HttpRequest * request)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (!neighborUp(p))
@@ -297,11 +302,11 @@ getFirstUpParent(HttpRequest * request)
     return p;
 }
 
-peer *
+CachePeer *
 getRoundRobinParent(HttpRequest * request)
 {
-    peer *p;
-    peer *q = NULL;
+    CachePeer *p;
+    CachePeer *q = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (!p->options.roundrobin)
@@ -336,11 +341,11 @@ getRoundRobinParent(HttpRequest * request)
     return q;
 }
 
-peer *
+CachePeer *
 getWeightedRoundRobinParent(HttpRequest * request)
 {
-    peer *p;
-    peer *q = NULL;
+    CachePeer *p;
+    CachePeer *q = NULL;
     int weighted_rtt;
 
     for (p = Config.peers; p; p = p->next) {
@@ -403,7 +408,7 @@ peerClearRRLoop(void *data)
 }
 
 /**
- * This gets called on startup and restart to kick off the peer round-robin
+ * This gets called on startup and restart to kick off the CachePeer round-robin
  * maintenance event. It ensures that no matter how many times its called
  * no more than one event is scheduled.
  */
@@ -421,23 +426,23 @@ peerClearRRStart(void)
  * Called whenever the round-robin counters need to be reset to a sane state.
  * So far those times are:
  *  - On startup and reconfigure - to set the counters to sane initial settings.
- *  -  When a peer has revived from dead, to prevent the revived peer being
+ *  -  When a CachePeer has revived from dead, to prevent the revived CachePeer being
  *     flooded with requests which it has 'missed' during the down period.
  */
 void
 peerClearRR()
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
     for (p = Config.peers; p; p = p->next) {
         p->rr_count = 0;
     }
 }
 
 /**
- * Perform all actions when a peer is detected revived.
+ * Perform all actions when a CachePeer is detected revived.
  */
 void
-peerAlive(peer *p)
+peerAlive(CachePeer *p)
 {
     if (p->stats.logged_state == PEER_DEAD && p->tcp_up) {
         debugs(15, DBG_IMPORTANT, "Detected REVIVED " << neighborTypeStr(p) << ": " << p->name);
@@ -449,10 +454,10 @@ peerAlive(peer *p)
     p->stats.probe_start = 0;
 }
 
-peer *
+CachePeer *
 getDefaultParent(HttpRequest * request)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (neighborType(p, request) != PEER_PARENT)
@@ -473,23 +478,23 @@ getDefaultParent(HttpRequest * request)
     return NULL;
 }
 
-peer *
-getNextPeer(peer * p)
+CachePeer *
+getNextPeer(CachePeer * p)
 {
     return p->next;
 }
 
-peer *
+CachePeer *
 getFirstPeer(void)
 {
     return Config.peers;
 }
 
 static void
-neighborRemove(peer * target)
+neighborRemove(CachePeer * target)
 {
-    peer *p = NULL;
-    peer **P = NULL;
+    CachePeer *p = NULL;
+    CachePeer **P = NULL;
     p = Config.peers;
     P = &Config.peers;
 
@@ -530,8 +535,8 @@ neighbors_init(void)
 {
     struct servent *sep = NULL;
     const char *me = getMyHostname();
-    peer *thisPeer = NULL;
-    peer *next = NULL;
+    CachePeer *thisPeer = NULL;
+    CachePeer *next = NULL;
 
     neighborsRegisterWithCacheManager();
 
@@ -577,7 +582,7 @@ neighborsUdpPing(HttpRequest * request,
 {
     const char *url = entry->url();
     MemObject *mem = entry->mem_obj;
-    peer *p = NULL;
+    CachePeer *p = NULL;
     int i;
     int reqnum = 0;
     int flags;
@@ -608,7 +613,7 @@ neighborsUdpPing(HttpRequest * request,
         debugs(15, 5, "neighborsUdpPing: Peer " << p->host);
 
         if (!peerWouldBePinged(p, request))
-            continue;		/* next peer */
+            continue;		/* next CachePeer */
 
         ++peers_pinged;
 
@@ -687,8 +692,8 @@ neighborsUdpPing(HttpRequest * request,
         p->stats.last_query = squid_curtime;
 
         /*
-         * keep probe_start == 0 for a multicast peer,
-         * so neighborUp() never says this peer is dead.
+         * keep probe_start == 0 for a multicast CachePeer,
+         * so neighborUp() never says this CachePeer is dead.
          */
 
         if ((p->type != PEER_MULTICAST) && (p->stats.probe_start == 0))
@@ -730,9 +735,9 @@ neighborsUdpPing(HttpRequest * request,
     return peers_pinged;
 }
 
-/* lookup the digest of a given peer */
+/* lookup the digest of a given CachePeer */
 lookup_t
-peerDigestLookup(peer * p, HttpRequest * request)
+peerDigestLookup(CachePeer * p, HttpRequest * request)
 {
 #if USE_CACHE_DIGESTS
     const cache_key *key = request ? storeKeyPublicByRequest(request) : NULL;
@@ -772,17 +777,17 @@ peerDigestLookup(peer * p, HttpRequest * request)
     return LOOKUP_NONE;
 }
 
-/* select best peer based on cache digests */
-peer *
+/* select best CachePeer based on cache digests */
+CachePeer *
 neighborsDigestSelect(HttpRequest * request)
 {
-    peer *best_p = NULL;
+    CachePeer *best_p = NULL;
 #if USE_CACHE_DIGESTS
 
     int best_rtt = 0;
     int choice_count = 0;
     int ichoice_count = 0;
-    peer *p;
+    CachePeer *p;
     int p_rtt;
     int i;
 
@@ -814,7 +819,7 @@ neighborsDigestSelect(HttpRequest * request)
 
         debugs(15, 5, "neighborsDigestSelect: peer " << p->host << " rtt: " << p_rtt);
 
-        /* is this peer better than others in terms of rtt ? */
+        /* is this CachePeer better than others in terms of rtt ? */
         if (!best_p || (p_rtt && p_rtt < best_rtt)) {
             best_p = p;
             best_rtt = p_rtt;
@@ -837,7 +842,7 @@ neighborsDigestSelect(HttpRequest * request)
 }
 
 void
-peerNoteDigestLookup(HttpRequest * request, peer * p, lookup_t lookup)
+peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup)
 {
 #if USE_CACHE_DIGESTS
     if (p)
@@ -851,7 +856,7 @@ peerNoteDigestLookup(HttpRequest * request, peer * p, lookup_t lookup)
 }
 
 static void
-neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
+neighborAlive(CachePeer * p, const MemObject * mem, const icp_common_t * header)
 {
     peerAlive(p);
     ++ p->stats.pings_acked;
@@ -863,7 +868,7 @@ neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
 }
 
 static void
-neighborUpdateRtt(peer * p, MemObject * mem)
+neighborUpdateRtt(CachePeer * p, MemObject * mem)
 {
     int rtt, rtt_av_factor;
 
@@ -888,7 +893,7 @@ neighborUpdateRtt(peer * p, MemObject * mem)
 
 #if USE_HTCP
 static void
-neighborAliveHtcp(peer * p, const MemObject * mem, const htcpReplyData * htcp)
+neighborAliveHtcp(CachePeer * p, const MemObject * mem, const htcpReplyData * htcp)
 {
     peerAlive(p);
     ++ p->stats.pings_acked;
@@ -899,7 +904,7 @@ neighborAliveHtcp(peer * p, const MemObject * mem, const htcpReplyData * htcp)
 #endif
 
 static void
-neighborCountIgnored(peer * p)
+neighborCountIgnored(CachePeer * p)
 {
     if (p == NULL)
         return;
@@ -909,12 +914,12 @@ neighborCountIgnored(peer * p)
     ++NLateReplies;
 }
 
-static peer *non_peers = NULL;
+static CachePeer *non_peers = NULL;
 
 static void
 neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
 {
-    peer *np;
+    CachePeer *np;
 
     for (np = non_peers; np; np = np->next) {
         if (np->in_addr != from)
@@ -927,7 +932,7 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
     }
 
     if (np == NULL) {
-        np = (peer *)xcalloc(1, sizeof(peer));
+        np = (CachePeer *)xcalloc(1, sizeof(CachePeer));
         np->in_addr = from;
         np->icp.port = from.GetPort();
         np->type = PEER_NONE;
@@ -946,11 +951,11 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
 /* ignoreMulticastReply
  *
  * * We want to ignore replies from multicast peers if the
- * * cache_host_domain rules would normally prevent the peer
+ * * cache_host_domain rules would normally prevent the CachePeer
  * * from being used
  */
 static int
-ignoreMulticastReply(peer * p, MemObject * mem)
+ignoreMulticastReply(CachePeer * p, MemObject * mem)
 {
     if (p == NULL)
         return 0;
@@ -974,7 +979,7 @@ ignoreMulticastReply(peer * p, MemObject * mem)
 void
 neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address &from)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
     StoreEntry *entry;
     MemObject *mem = NULL;
     peer_t ntype = PEER_NONE;
@@ -1086,10 +1091,10 @@ neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address
     }
 }
 
-peer *
+CachePeer *
 peerFindByName(const char *name)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (!strcasecmp(name, p->name))
@@ -1099,10 +1104,10 @@ peerFindByName(const char *name)
     return p;
 }
 
-peer *
+CachePeer *
 peerFindByNameAndPort(const char *name, unsigned short port)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     for (p = Config.peers; p; p = p->next) {
         if (strcasecmp(name, p->name))
@@ -1118,17 +1123,17 @@ peerFindByNameAndPort(const char *name, unsigned short port)
 }
 
 int
-neighborUp(const peer * p)
+neighborUp(const CachePeer * p)
 {
     if (!p->tcp_up) {
-        if (!peerProbeConnect((peer *) p)) {
+        if (!peerProbeConnect((CachePeer *) p)) {
             debugs(15, 8, "neighborUp: DOWN (probed): " << p->host << " (" << p->in_addr << ")");
             return 0;
         }
     }
 
     /*
-     * The peer can not be UP if we don't have any IP addresses
+     * The CachePeer can not be UP if we don't have any IP addresses
      * for it.
      */
     if (0 == p->n_addresses) {
@@ -1154,14 +1159,14 @@ neighborUp(const peer * p)
 void
 peerDestroy(void *data)
 {
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
 
     if (p == NULL)
         return;
 
-    struct _domain_ping *nl = NULL;
+    CachePeerDomainList *nl = NULL;
 
-    for (struct _domain_ping *l = p->peer_domain; l; l = nl) {
+    for (CachePeerDomainList *l = p->peer_domain; l; l = nl) {
         nl = l->next;
         safe_free(l->domain);
         xfree(l);
@@ -1177,7 +1182,7 @@ peerDestroy(void *data)
 }
 
 void
-peerNoteDigestGone(peer * p)
+peerNoteDigestGone(CachePeer * p)
 {
 #if USE_CACHE_DIGESTS
     cbdataReferenceDone(p->digest);
@@ -1187,7 +1192,7 @@ peerNoteDigestGone(peer * p)
 static void
 peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 {
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
 
     int j;
 
@@ -1236,7 +1241,7 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 static void
 peerRefreshDNS(void *data)
 {
-    peer *p = NULL;
+    CachePeer *p = NULL;
 
     if (eventFind(peerRefreshDNS, NULL))
         eventDelete(peerRefreshDNS, NULL);
@@ -1255,7 +1260,7 @@ peerRefreshDNS(void *data)
 }
 
 static void
-peerConnectFailedSilent(peer * p)
+peerConnectFailedSilent(CachePeer * p)
 {
     p->stats.last_connect_failure = squid_curtime;
 
@@ -1274,14 +1279,14 @@ peerConnectFailedSilent(peer * p)
 }
 
 void
-peerConnectFailed(peer *p)
+peerConnectFailed(CachePeer *p)
 {
     debugs(15, DBG_IMPORTANT, "TCP connection to " << p->host << "/" << p->http_port << " failed");
     peerConnectFailedSilent(p);
 }
 
 void
-peerConnectSucceded(peer * p)
+peerConnectSucceded(CachePeer * p)
 {
     if (!p->tcp_up) {
         debugs(15, 2, "TCP connection to " << p->host << "/" << p->http_port << " succeded");
@@ -1297,7 +1302,7 @@ peerConnectSucceded(peer * p)
 * peerProbeConnect will be called on dead peers by neighborUp
 */
 static bool
-peerProbeConnect(peer * p)
+peerProbeConnect(CachePeer * p)
 {
     time_t ctimeout = p->connect_timeout > 0 ? p->connect_timeout : Config.Timeout.peer_connect;
     bool ret = (squid_curtime - p->stats.last_connect_failure) > (ctimeout * 10);
@@ -1308,7 +1313,7 @@ peerProbeConnect(peer * p)
     if (squid_curtime - p->stats.last_connect_probe == 0)
         return ret;/* don't probe to often */
 
-    /* for each IP address of this peer. find one that we can connect to and probe it. */
+    /* for each IP address of this CachePeer. find one that we can connect to and probe it. */
     for (int i = 0; i < p->n_addresses; ++i) {
         Comm::ConnectionPointer conn = new Comm::Connection;
         conn->remote = p->addresses[i];
@@ -1331,7 +1336,7 @@ peerProbeConnect(peer * p)
 static void
 peerProbeConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno, void *data)
 {
-    peer *p = (peer*)data;
+    CachePeer *p = (CachePeer*)data;
 
     if (status == COMM_OK) {
         peerConnectSucceded(p);
@@ -1345,7 +1350,7 @@ peerProbeConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int
 }
 
 static void
-peerCountMcastPeersSchedule(peer * p, time_t when)
+peerCountMcastPeersSchedule(CachePeer * p, time_t when)
 {
     if (p->mcast.flags.count_event_pending)
         return;
@@ -1361,7 +1366,7 @@ peerCountMcastPeersSchedule(peer * p, time_t when)
 static void
 peerCountMcastPeersStart(void *data)
 {
-    peer *p = (peer *)data;
+    CachePeer *p = (CachePeer *)data;
     ps_state *psstate;
     StoreEntry *fake;
     MemObject *mem;
@@ -1373,7 +1378,7 @@ peerCountMcastPeersStart(void *data)
     snprintf(url, MAX_URL, "http://");
     p->in_addr.ToURL(url+7, MAX_URL -8 );
     strcat(url, "/");
-    fake = storeCreateEntry(url, url, request_flags(), METHOD_GET);
+    fake = storeCreateEntry(url, url, RequestFlags(), METHOD_GET);
     HttpRequest *req = HttpRequest::CreateFromUrl(url);
     psstate = new ps_state;
     psstate->request = HTTPMSGLOCK(req);
@@ -1407,7 +1412,7 @@ peerCountMcastPeersDone(void *data)
     StoreEntry *fake = psstate->entry;
 
     if (cbdataReferenceValid(psstate->callback_data)) {
-        peer *p = (peer *)psstate->callback_data;
+        CachePeer *p = (CachePeer *)psstate->callback_data;
         p->mcast.flags.counting = 0;
         p->mcast.avg_n_members = Math::doubleAverage(p->mcast.avg_n_members, (double) psstate->ping.n_recv, ++p->mcast.n_times_counted, 10);
         debugs(15, DBG_IMPORTANT, "Group " << p->host  << ": " << psstate->ping.n_recv  <<
@@ -1426,7 +1431,7 @@ peerCountMcastPeersDone(void *data)
 }
 
 static void
-peerCountHandleIcpReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *hdrnotused, void *data)
+peerCountHandleIcpReply(CachePeer * p, peer_t type, AnyP::ProtocolType proto, void *hdrnotused, void *data)
 {
     int rtt_av_factor;
 
@@ -1459,7 +1464,7 @@ neighborDumpNonPeers(StoreEntry * sentry)
 }
 
 void
-dump_peer_options(StoreEntry * sentry, peer * p)
+dump_peer_options(StoreEntry * sentry, CachePeer * p)
 {
     if (p->options.proxy_only)
         storeAppendPrintf(sentry, " proxy-only");
@@ -1577,11 +1582,11 @@ dump_peer_options(StoreEntry * sentry, peer * p)
 }
 
 static void
-dump_peers(StoreEntry * sentry, peer * peers)
+dump_peers(StoreEntry * sentry, CachePeer * peers)
 {
-    peer *e = NULL;
+    CachePeer *e = NULL;
     char ntoabuf[MAX_IPSTRLEN];
-    struct _domain_ping *d = NULL;
+    CachePeerDomainList *d = NULL;
     icp_opcode op;
     int i;
 
@@ -1688,7 +1693,7 @@ neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const Ip::Addres
 {
     StoreEntry *e = Store::Root().get(key);
     MemObject *mem = NULL;
-    peer *p;
+    CachePeer *p;
     peer_t ntype = PEER_NONE;
     debugs(15, 6, "neighborsHtcpReply: " <<
            (htcp->hit ? "HIT" : "MISS") << " " <<
@@ -1753,7 +1758,7 @@ neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const Ip::Addres
 void
 neighborsHtcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, htcp_clr_reason reason)
 {
-    peer *p;
+    CachePeer *p;
     char buf[128];
 
     for (p = Config.peers; p; p = p->next) {
@@ -34,54 +34,53 @@
 #define SQUID_NEIGHBORS_H_
 
 #include "enums.h"
-#include "HttpRequestMethod.h"
+#include "ICP.h"
 #include "lookup_t.h"
-#include "ip/Address.h"
-#include "typedefs.h"
 
 class HttpRequest;
-class peer;
+class HttpRequestMethod;
+class CachePeer;
 class StoreEntry;
 
-SQUIDCEXTERN peer *getFirstPeer(void);
-SQUIDCEXTERN peer *getFirstUpParent(HttpRequest *);
-SQUIDCEXTERN peer *getNextPeer(peer *);
-SQUIDCEXTERN peer *getSingleParent(HttpRequest *);
-SQUIDCEXTERN int neighborsCount(HttpRequest *);
-SQUIDCEXTERN int neighborsUdpPing(HttpRequest *,
-                                  StoreEntry *,
-                                  IRCB * callback,
-                                  void *data,
-                                  int *exprep,
-                                  int *timeout);
-SQUIDCEXTERN void neighborAddAcl(const char *, const char *);
+CachePeer *getFirstPeer(void);
+CachePeer *getFirstUpParent(HttpRequest *);
+CachePeer *getNextPeer(CachePeer *);
+CachePeer *getSingleParent(HttpRequest *);
+int neighborsCount(HttpRequest *);
+int neighborsUdpPing(HttpRequest *,
+                StoreEntry *,
+                IRCB * callback,
+                void *data,
+                int *exprep,
+                int *timeout);
+void neighborAddAcl(const char *, const char *);
 
-SQUIDCEXTERN void neighborsUdpAck(const cache_key *, icp_common_t *, const Ip::Address &);
-SQUIDCEXTERN void neighborAdd(const char *, const char *, int, int, int, int, int);
-SQUIDCEXTERN void neighbors_init(void);
+void neighborsUdpAck(const cache_key *, icp_common_t *, const Ip::Address &);
+void neighborAdd(const char *, const char *, int, int, int, int, int);
+void neighbors_init(void);
 #if USE_HTCP
-SQUIDCEXTERN void neighborsHtcpClear(StoreEntry *, const char *, HttpRequest *, const HttpRequestMethod &, htcp_clr_reason);
+void neighborsHtcpClear(StoreEntry *, const char *, HttpRequest *, const HttpRequestMethod &, htcp_clr_reason);
 #endif
-SQUIDCEXTERN peer *peerFindByName(const char *);
-SQUIDCEXTERN peer *peerFindByNameAndPort(const char *, unsigned short);
-SQUIDCEXTERN peer *getDefaultParent(HttpRequest * request);
-SQUIDCEXTERN peer *getRoundRobinParent(HttpRequest * request);
-SQUIDCEXTERN peer *getWeightedRoundRobinParent(HttpRequest * request);
-SQUIDCEXTERN void peerClearRRStart(void);
-SQUIDCEXTERN void peerClearRR(void);
-SQUIDCEXTERN lookup_t peerDigestLookup(peer * p, HttpRequest * request);
-SQUIDCEXTERN peer *neighborsDigestSelect(HttpRequest * request);
-SQUIDCEXTERN void peerNoteDigestLookup(HttpRequest * request, peer * p, lookup_t lookup);
-SQUIDCEXTERN void peerNoteDigestGone(peer * p);
-SQUIDCEXTERN int neighborUp(const peer * e);
-SQUIDCEXTERN CBDUNL peerDestroy;
-SQUIDCEXTERN const char *neighborTypeStr(const peer * e);
-SQUIDCEXTERN peer_t neighborType(const peer *, const HttpRequest *);
-SQUIDCEXTERN void peerConnectFailed(peer *);
-SQUIDCEXTERN void peerConnectSucceded(peer *);
-SQUIDCEXTERN void dump_peer_options(StoreEntry *, peer *);
-SQUIDCEXTERN int peerHTTPOkay(const peer *, HttpRequest *);
+CachePeer *peerFindByName(const char *);
+CachePeer *peerFindByNameAndPort(const char *, unsigned short);
+CachePeer *getDefaultParent(HttpRequest * request);
+CachePeer *getRoundRobinParent(HttpRequest * request);
+CachePeer *getWeightedRoundRobinParent(HttpRequest * request);
+void peerClearRRStart(void);
+void peerClearRR(void);
+lookup_t peerDigestLookup(CachePeer * p, HttpRequest * request);
+CachePeer *neighborsDigestSelect(HttpRequest * request);
+void peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup);
+void peerNoteDigestGone(CachePeer * p);
+int neighborUp(const CachePeer * e);
+CBDUNL peerDestroy;
+const char *neighborTypeStr(const CachePeer * e);
+peer_t neighborType(const CachePeer *, const HttpRequest *);
+void peerConnectFailed(CachePeer *);
+void peerConnectSucceded(CachePeer *);
+void dump_peer_options(StoreEntry *, CachePeer *);
+int peerHTTPOkay(const CachePeer *, HttpRequest *);
 
-SQUIDCEXTERN peer *whichPeer(const Ip::Address &from);
+CachePeer *whichPeer(const Ip::Address &from);
 
 #endif /* SQUID_NEIGHBORS_H_ */
@@ -38,6 +38,7 @@
 #include "globals.h"
 #include "mgr/Registration.h"
 #include "pconn.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 #define PCONN_FDS_SZ	8	/* pconn set size, increase for better memcache hit rate */
@@ -34,6 +34,7 @@
 #include "squid.h"
 #if USE_CACHE_DIGESTS
 #include "CacheDigest.h"
+#include "CachePeer.h"
 #include "event.h"
 #include "forward.h"
 #include "globals.h"
@@ -90,7 +91,7 @@ static time_t pd_last_req_time = 0;	/* last call to Check */
 
 /* initialize peer digest */
 static void
-peerDigestInit(PeerDigest * pd, peer * p)
+peerDigestInit(PeerDigest * pd, CachePeer * p)
 {
     assert(pd && p);
 
@@ -137,7 +138,7 @@ PeerDigest::operator delete (void *address)
 
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
-peerDigestCreate(peer * p)
+peerDigestCreate(CachePeer * p)
 {
     PeerDigest *pd;
     assert(p);
@@ -164,7 +165,7 @@ peerDigestDestroy(PeerDigest * pd)
      * tell it that the digest is gone.
      */
     if (cbdataReferenceValidDone(peerTmp, &p))
-        peerNoteDigestGone((peer *)p);
+        peerNoteDigestGone((CachePeer *)p);
 
     peerDigestClean(pd);
 
@@ -312,7 +313,7 @@ CBDATA_TYPE(DigestFetchState);
 static void
 peerDigestRequest(PeerDigest * pd)
 {
-    peer *p = pd->peer;
+    CachePeer *p = pd->peer;
     StoreEntry *e, *old_e;
     char *url;
     const cache_key *key;
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
+#include "CachePeer.h"
 #include "carp.h"
 #include "client_side.h"
 #include "DnsLookupDetails.h"
@@ -50,6 +51,7 @@
 #include "peer_sourcehash.h"
 #include "peer_userhash.h"
 #include "PeerSelectState.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
@@ -68,18 +70,18 @@ static void peerSelectFoo(ps_state *);
 static void peerPingTimeout(void *data);
 static IRCB peerHandlePingReply;
 static void peerSelectStateFree(ps_state * psstate);
-static void peerIcpParentMiss(peer *, icp_common_t *, ps_state *);
+static void peerIcpParentMiss(CachePeer *, icp_common_t *, ps_state *);
 #if USE_HTCP
-static void peerHtcpParentMiss(peer *, htcpReplyData *, ps_state *);
-static void peerHandleHtcpReply(peer *, peer_t, htcpReplyData *, void *);
+static void peerHtcpParentMiss(CachePeer *, htcpReplyData *, ps_state *);
+static void peerHandleHtcpReply(CachePeer *, peer_t, htcpReplyData *, void *);
 #endif
 static int peerCheckNetdbDirect(ps_state * psstate);
 static void peerGetSomeNeighbor(ps_state *);
 static void peerGetSomeNeighborReplies(ps_state *);
 static void peerGetSomeDirect(ps_state *);
 static void peerGetSomeParent(ps_state *);
 static void peerGetAllParents(ps_state *);
-static void peerAddFwdServer(FwdServer **, peer *, hier_code);
+static void peerAddFwdServer(FwdServer **, CachePeer *, hier_code);
 static void peerSelectPinned(ps_state * ps);
 static void peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data);
 
@@ -232,7 +234,7 @@ peerSelectDnsPaths(ps_state *psstate)
     // on intercepted traffic which failed Host verification
     const HttpRequest *req = psstate->request;
     const bool isIntercepted = !req->flags.redirected &&
-                               (req->flags.intercepted || req->flags.spoof_client_ip);
+                               (req->flags.intercepted || req->flags.spoofClientIp);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || !req->flags.hostVerified;
     const bool choseDirect = fs && fs->code == HIER_DIRECT;
     if (isIntercepted && useOriginalDst && choseDirect) {
@@ -337,7 +339,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
                 break;
 
             // for TPROXY we must skip unusable addresses.
-            if (psstate->request->flags.spoof_client_ip && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
+            if (psstate->request->flags.spoofClientIp && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
                 if (ia->in_addrs[n].IsIPv4() != psstate->request->client_addr.IsIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
                     continue;
@@ -380,7 +382,7 @@ static int
 peerCheckNetdbDirect(ps_state * psstate)
 {
 #if USE_ICMP
-    peer *p;
+    CachePeer *p;
     int myrtt;
     int myhops;
 
@@ -441,11 +443,11 @@ peerSelectFoo(ps_state * ps)
             ps->acl_checklist = new ACLFilledChecklist(Config.accessList.NeverDirect, request, NULL);
             ps->acl_checklist->nonBlockingCheck(peerCheckNeverDirectDone, ps);
             return;
-        } else if (request->flags.no_direct) {
+        } else if (request->flags.noDirect) {
             /** if we are accelerating, direct is not an option. */
             ps->direct = DIRECT_NO;
             debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (forced non-direct)");
-        } else if (request->flags.loopdetect) {
+        } else if (request->flags.loopDetected) {
             /** if we are in a forwarding-loop, direct is not an option. */
             ps->direct = DIRECT_YES;
             debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (forwarding loop detected)");
@@ -505,7 +507,7 @@ peerSelectFoo(ps_state * ps)
     peerSelectDnsPaths(ps);
 }
 
-bool peerAllowedToUse(const peer * p, HttpRequest * request);
+bool peerAllowedToUse(const CachePeer * p, HttpRequest * request);
 
 /**
  * peerSelectPinned
@@ -518,7 +520,7 @@ peerSelectPinned(ps_state * ps)
     HttpRequest *request = ps->request;
     if (!request->pinnedConnection())
         return;
-    peer *pear = request->pinnedConnection()->pinnedPeer();
+    CachePeer *pear = request->pinnedConnection()->pinnedPeer();
     if (Comm::IsConnOpen(request->pinnedConnection()->validatePinnedConnection(request, pear))) {
         if (pear && peerAllowedToUse(pear, request)) {
             peerAddFwdServer(&ps->servers, pear, PINNED);
@@ -547,7 +549,7 @@ peerGetSomeNeighbor(ps_state * ps)
 {
     StoreEntry *entry = ps->entry;
     HttpRequest *request = ps->request;
-    peer *p;
+    CachePeer *p;
     hier_code code = HIER_NONE;
     assert(entry->ping_status == PING_NONE);
 
@@ -611,7 +613,7 @@ static void
 peerGetSomeNeighborReplies(ps_state * ps)
 {
     HttpRequest *request = ps->request;
-    peer *p = NULL;
+    CachePeer *p = NULL;
     hier_code code = HIER_NONE;
     assert(ps->entry->ping_status == PING_WAITING);
     assert(ps->direct != DIRECT_YES);
@@ -662,7 +664,7 @@ peerGetSomeDirect(ps_state * ps)
 static void
 peerGetSomeParent(ps_state * ps)
 {
-    peer *p;
+    CachePeer *p;
     HttpRequest *request = ps->request;
     hier_code code = HIER_NONE;
     debugs(44, 3, "peerGetSomeParent: " << RequestMethodStr(request->method) << " " << request->GetHost());
@@ -699,7 +701,7 @@ peerGetSomeParent(ps_state * ps)
 static void
 peerGetAllParents(ps_state * ps)
 {
-    peer *p;
+    CachePeer *p;
     HttpRequest *request = ps->request;
     /* Add all alive parents */
 
@@ -759,7 +761,7 @@ peerSelectInit(void)
 }
 
 static void
-peerIcpParentMiss(peer * p, icp_common_t * header, ps_state * ps)
+peerIcpParentMiss(CachePeer * p, icp_common_t * header, ps_state * ps)
 {
     int rtt;
 
@@ -800,7 +802,7 @@ peerIcpParentMiss(peer * p, icp_common_t * header, ps_state * ps)
 }
 
 static void
-peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
+peerHandleIcpReply(CachePeer * p, peer_t type, icp_common_t * header, void *data)
 {
     ps_state *psstate = (ps_state *)data;
     icp_opcode op = header->getOpCode();
@@ -834,7 +836,7 @@ peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
 
 #if USE_HTCP
 static void
-peerHandleHtcpReply(peer * p, peer_t type, htcpReplyData * htcp, void *data)
+peerHandleHtcpReply(CachePeer * p, peer_t type, htcpReplyData * htcp, void *data)
 {
     ps_state *psstate = (ps_state *)data;
     debugs(44, 3, "peerHandleHtcpReply: " <<
@@ -859,7 +861,7 @@ peerHandleHtcpReply(peer * p, peer_t type, htcpReplyData * htcp, void *data)
 }
 
 static void
-peerHtcpParentMiss(peer * p, htcpReplyData * htcp, ps_state * ps)
+peerHtcpParentMiss(CachePeer * p, htcpReplyData * htcp, ps_state * ps)
 {
     int rtt;
 
@@ -900,7 +902,7 @@ peerHtcpParentMiss(peer * p, htcpReplyData * htcp, ps_state * ps)
 #endif
 
 static void
-peerHandlePingReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *pingdata, void *data)
+peerHandlePingReply(CachePeer * p, peer_t type, AnyP::ProtocolType proto, void *pingdata, void *data)
 {
     if (proto == AnyP::PROTO_ICP)
         peerHandleIcpReply(p, type, (icp_common_t *)pingdata, data);
@@ -917,7 +919,7 @@ peerHandlePingReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *pingd
 }
 
 static void
-peerAddFwdServer(FwdServer ** FSVR, peer * p, hier_code code)
+peerAddFwdServer(FwdServer ** FSVR, CachePeer * p, hier_code code)
 {
     FwdServer *fs = (FwdServer *)memAllocate(MEM_FWD_SERVER);
     debugs(44, 5, "peerAddFwdServer: adding " <<
@@ -33,9 +33,11 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 #if HAVE_MATH_H
@@ -45,15 +47,15 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_sourcehash_peers = 0;
-static peer **sourcehash_peers = NULL;
+static CachePeer **sourcehash_peers = NULL;
 static OBJH peerSourceHashCachemgr;
 static void peerSourceHashRegisterWithCacheManager(void);
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -64,8 +66,8 @@ peerSourceHashInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -96,7 +98,7 @@ peerSourceHashInit(void)
     if (n_sourcehash_peers == 0)
         return;
 
-    sourcehash_peers = (peer **)xcalloc(n_sourcehash_peers, sizeof(*sourcehash_peers));
+    sourcehash_peers = (CachePeer **)xcalloc(n_sourcehash_peers, sizeof(*sourcehash_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = sourcehash_peers, p = Config.peers; p; p = p->next) {
@@ -164,13 +166,13 @@ peerSourceHashRegisterWithCacheManager(void)
                         peerSourceHashCachemgr, 0, 1);
 }
 
-peer *
+CachePeer *
 peerSourceHashSelectParent(HttpRequest * request)
 {
     int k;
     const char *c;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -189,7 +191,7 @@ peerSourceHashSelectParent(HttpRequest * request)
     for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_sourcehash_peers; ++k) {
         tp = sourcehash_peers[k];
         combined_hash = (user_hash ^ tp->sourcehash.hash);
@@ -214,7 +216,7 @@ peerSourceHashSelectParent(HttpRequest * request)
 static void
 peerSourceHashCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -34,10 +34,10 @@
 #ifndef SQUID_PEER_SOURCEHASH_H_
 #define SQUID_PEER_SOURCEHASH_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
-extern void peerSourceHashInit(void);
-extern peer * peerSourceHashSelectParent(HttpRequest * request);
+void peerSourceHashInit(void);
+CachePeer * peerSourceHashSelectParent(HttpRequest * request);
 
 #endif /* SQUID_PEER_SOURCEHASH_H_ */
@@ -37,10 +37,12 @@
 #if USE_AUTH
 
 #include "auth/UserRequest.h"
+#include "CachePeer.h"
 #include "globals.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 #if HAVE_MATH_H
@@ -50,15 +52,15 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_userhash_peers = 0;
-static peer **userhash_peers = NULL;
+static CachePeer **userhash_peers = NULL;
 static OBJH peerUserHashCachemgr;
 static void peerUserHashRegisterWithCacheManager(void);
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -69,8 +71,8 @@ peerUserHashInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -101,7 +103,7 @@ peerUserHashInit(void)
     if (n_userhash_peers == 0)
         return;
 
-    userhash_peers = (peer **)xcalloc(n_userhash_peers, sizeof(*userhash_peers));
+    userhash_peers = (CachePeer **)xcalloc(n_userhash_peers, sizeof(*userhash_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = userhash_peers, p = Config.peers; p; p = p->next) {
@@ -169,13 +171,13 @@ peerUserHashRegisterWithCacheManager(void)
                         0, 1);
 }
 
-peer *
+CachePeer *
 peerUserHashSelectParent(HttpRequest * request)
 {
     int k;
     const char *c;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -197,7 +199,7 @@ peerUserHashSelectParent(HttpRequest * request)
     for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_userhash_peers; ++k) {
         tp = userhash_peers[k];
         combined_hash = (user_hash ^ tp->userhash.hash);
@@ -222,7 +224,7 @@ peerUserHashSelectParent(HttpRequest * request)
 static void
 peerUserHashCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -34,10 +34,10 @@
 #ifndef SQUID_PEER_USERHASH_H_
 #define SQUID_PEER_USERHASH_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
-extern void peerUserHashInit(void);
-extern peer * peerUserHashSelectParent(HttpRequest * request);
+void peerUserHashInit(void);
+CachePeer * peerUserHashSelectParent(HttpRequest * request);
 
 #endif /* SQUID_PEER_USERHASH_H_ */
@@ -29,8 +29,8 @@
 #ifndef SQUID_PROTOS_H
 #define SQUID_PROTOS_H
 
-extern void shut_down(int);
-extern void rotate_logs(int);
-extern void reconfigure(int);
+void shut_down(int);
+void rotate_logs(int);
+void reconfigure(int);
 
 #endif /* SQUID_PROTOS_H */
@@ -44,6 +44,7 @@
 #include "mgr/Registration.h"
 #include "redirect.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -33,7 +33,7 @@
  *
  */
 
-extern void redirectInit(void);
-extern void redirectShutdown(void);
+void redirectInit(void);
+void redirectShutdown(void);
 
 #endif /* SQUID_REDIRECT_H_ */
@@ -41,7 +41,9 @@
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "MemObject.h"
+#include "RefreshPattern.h"
 #include "SquidTime.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 
@@ -108,16 +110,16 @@ refreshCounts[rcCount];
 #define REFRESH_DEFAULT_PCT	0.20
 #define REFRESH_DEFAULT_MAX	(time_t)259200
 
-static const refresh_t *refreshUncompiledPattern(const char *);
+static const RefreshPattern *refreshUncompiledPattern(const char *);
 static OBJH refreshStats;
-static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const refresh_t * R, stale_flags * sf);
+static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf);
 
-static refresh_t DefaultRefresh;
+static RefreshPattern DefaultRefresh;
 
-const refresh_t *
+const RefreshPattern *
 refreshLimits(const char *url)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
 
     for (R = Config.Refresh; R; R = R->next) {
         if (!regexec(&(R->compiled_pattern), url, 0, 0, 0))
@@ -127,10 +129,10 @@ refreshLimits(const char *url)
     return NULL;
 }
 
-static const refresh_t *
+static const RefreshPattern *
 refreshUncompiledPattern(const char *pat)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
 
     for (R = Config.Refresh; R; R = R->next) {
         if (0 == strcmp(R->pattern, pat))
@@ -156,7 +158,7 @@ refreshUncompiledPattern(const char *pat)
  * times.
  */
 static int
-refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const refresh_t * R, stale_flags * sf)
+refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf)
 {
     /** \par
      * Check for an explicit expiration time (Expires: header).
@@ -230,7 +232,7 @@ refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age,
 static int
 refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
     const char *uri = NULL;
     time_t age = 0;
     time_t check_time = squid_curtime + delta;
@@ -265,7 +267,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 
     debugs(22, 3, "\tentry->timestamp:\t" << mkrfc1123(entry->timestamp));
 
-    if (request && !request->flags.ignore_cc) {
+    if (request && !request->flags.ignoreCc) {
         const HttpHdrCc *const cc = request->cache_control;
         if (cc && cc->hasMinFresh()) {
             const int32_t minFresh=cc->minFresh();
@@ -291,7 +293,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
             entry->mem_obj->getReply()->cache_control->staleIfError() < staleness) {
 
         debugs(22, 3, "refreshCheck: stale-if-error period expired.");
-        request->flags.fail_on_validation_err = 1;
+        request->flags.failOnValidationError = 1;
     }
 
     if (EBIT_TEST(entry->flags, ENTRY_REVALIDATE) && staleness > -1
@@ -301,12 +303,12 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
        ) {
         debugs(22, 3, "refreshCheck: YES: Must revalidate stale response");
         if (request)
-            request->flags.fail_on_validation_err = 1;
+            request->flags.failOnValidationError = 1;
         return STALE_MUST_REVALIDATE;
     }
 
     /* request-specific checks */
-    if (request && !request->flags.ignore_cc) {
+    if (request && !request->flags.ignoreCc) {
         HttpHdrCc *cc = request->cache_control;
 
         if (request->flags.ims && (R->flags.refresh_ims || Config.onoff.refresh_all_ims)) {
@@ -317,7 +319,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 
 #if USE_HTTP_VIOLATIONS
 
-        if (!request->flags.nocache_hack) {
+        if (!request->flags.noCacheHack()) {
             (void) 0;
         } else if (R->flags.ignore_reload) {
             /* The clients no-cache header is ignored */
@@ -329,7 +331,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
         } else {
             /* The clients no-cache header is not overridden on this request */
             debugs(22, 3, "refreshCheck: YES: client reload");
-            request->flags.nocache = 1;
+            request->flags.noCache = 1;
             return STALE_FORCED_RELOAD;
         }
 
@@ -396,7 +398,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
     if ( max_stale >= 0 && staleness > max_stale) {
         debugs(22, 3, "refreshCheck: YES: max-stale limit");
         if (request)
-            request->flags.fail_on_validation_err = 1;
+            request->flags.failOnValidationError = 1;
         return STALE_MAX_STALE;
     }
 
@@ -492,7 +494,7 @@ refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
     int reason = refreshCheck(entry, request, 0);
     ++ refreshCounts[rcHTTP].total;
     ++ refreshCounts[rcHTTP].status[reason];
-    request->flags.stale_if_hit = refreshIsStaleIfHit(reason);
+    request->flags.staleIfHit = refreshIsStaleIfHit(reason);
     return (Config.onoff.offline || reason < 200) ? 0 : 1;
 }
 
@@ -534,7 +536,7 @@ refreshCheckDigest(const StoreEntry * entry, time_t delta)
 time_t
 getMaxAge(const char *url)
 {
-    const refresh_t *R;
+    const RefreshPattern *R;
     debugs(22, 3, "getMaxAge: '" << url << "'");
 
     if ((R = refreshLimits(url)))
@@ -33,14 +33,16 @@
 #ifndef SQUID_REFRESH_H_
 #define SQUID_REFRESH_H_
 
-extern void refreshAddToList(const char *, int, time_t, int, time_t);
-extern int refreshIsCachable(const StoreEntry *);
-extern int refreshCheckHTTP(const StoreEntry *, HttpRequest *);
-extern int refreshCheckICP(const StoreEntry *, HttpRequest *);
-extern int refreshCheckHTCP(const StoreEntry *, HttpRequest *);
-extern int refreshCheckDigest(const StoreEntry *, time_t delta);
-extern time_t getMaxAge(const char *url);
-extern void refreshInit(void);
-extern const refresh_t *refreshLimits(const char *url);
+class RefreshPattern;
+
+void refreshAddToList(const char *, int, time_t, int, time_t);
+int refreshIsCachable(const StoreEntry *);
+int refreshCheckHTTP(const StoreEntry *, HttpRequest *);
+int refreshCheckICP(const StoreEntry *, HttpRequest *);
+int refreshCheckHTCP(const StoreEntry *, HttpRequest *);
+int refreshCheckDigest(const StoreEntry *, time_t delta);
+time_t getMaxAge(const char *url);
+void refreshInit(void);
+const RefreshPattern *refreshLimits(const char *url);
 
 #endif /* SQUID_REFRESH_H_ */
@@ -33,6 +33,6 @@
  * Note: repl_modules.cc will be autogenerated.
  */
 
-extern void storeReplSetup(void);
+void storeReplSetup(void);
 
 #endif /* SQUID_REPL_MODULES_H_ */
@@ -39,6 +39,7 @@
 #include "globals.h"
 #include "ICP.h"
 #include "ipcache.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "tools.h"
 
@@ -32,6 +32,6 @@
  *
  */
 
-extern void start_announce(void *unused);
+void start_announce(void *unused);
 
 #endif /* SQUID_SEND_ANNOUNCE_H_ */
@@ -31,6 +31,7 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "cache_snmp.h"
 #include "globals.h"
 #include "mem_node.h"
@@ -39,6 +40,7 @@
 #include "snmp_core.h"
 #include "StatCounters.h"
 #include "StatHist.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "stat.h"
@@ -207,7 +209,7 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
 
     Ip::Address laddr;
     char *cp = NULL;
-    peer *p = NULL;
+    CachePeer *p = NULL;
     int cnt = 0;
     debugs(49, 5, "snmp_meshPtblFn: peer " << Var->name[LEN_SQ_MESH + 3] << " requested!");
     *ErrP = SNMP_ERR_NOERROR;
@@ -1,8 +1,8 @@
 #ifndef SQUID_SNMP_AGENT_H_
 #define SQUID_SNMP_AGENT_H_
 /*
- * DEBUG: section
- * AUTHOR:
+ * DEBUG: section 49    SNMP Interface
+ * AUTHOR: Kostas Anagnostakis
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -36,15 +36,15 @@
 
 #include "snmp_vars.h"
 
-extern variable_list *snmp_confFn(variable_list *, snint *);
-extern variable_list *snmp_sysFn(variable_list *, snint *);
-extern variable_list *snmp_prfSysFn(variable_list *, snint *);
-extern variable_list *snmp_prfProtoFn(variable_list *, snint *);
-extern variable_list *snmp_netIpFn(variable_list *, snint *);
-extern variable_list *snmp_netFqdnFn(variable_list *, snint *);
-extern variable_list *snmp_netDnsFn(variable_list *, snint *);
-extern variable_list *snmp_meshPtblFn(variable_list *, snint *);
-extern variable_list *snmp_meshCtblFn(variable_list *, snint *);
+variable_list *snmp_confFn(variable_list *, snint *);
+variable_list *snmp_sysFn(variable_list *, snint *);
+variable_list *snmp_prfSysFn(variable_list *, snint *);
+variable_list *snmp_prfProtoFn(variable_list *, snint *);
+variable_list *snmp_netIpFn(variable_list *, snint *);
+variable_list *snmp_netFqdnFn(variable_list *, snint *);
+variable_list *snmp_netDnsFn(variable_list *, snint *);
+variable_list *snmp_meshPtblFn(variable_list *, snint *);
+variable_list *snmp_meshCtblFn(variable_list *, snint *);
 
 #endif /* SQUID_SNMP */
 #endif /* SQUID_SNMP_AGENT_H_ */
@@ -32,6 +32,7 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "base/CbcPointer.h"
+#include "CachePeer.h"
 #include "client_db.h"
 #include "comm.h"
 #include "comm/Connection.h"
@@ -42,6 +43,8 @@
 #include "snmp_agent.h"
 #include "snmp_core.h"
 #include "snmp/Forwarder.h"
+#include "SnmpRequest.h"
+#include "SquidConfig.h"
 #include "tools.h"
 
 static void snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo);
@@ -62,8 +65,8 @@ static oid *static_Inst(oid * name, snint * len, mib_tree_entry * current, oid_P
 static oid *time_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static oid *peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static oid *client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
-static void snmpDecodePacket(snmp_request_t * rq);
-static void snmpConstructReponse(snmp_request_t * rq);
+static void snmpDecodePacket(SnmpRequest * rq);
+static void snmpConstructReponse(SnmpRequest * rq);
 
 static oid_ParseFn *snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen);
 static oid_ParseFn *snmpTreeGet(oid * Current, snint CurrentLen);
@@ -361,7 +364,7 @@ snmpHandleUdp(int sock, void *not_used)
 {
     LOCAL_ARRAY(char, buf, SNMP_REQUEST_SIZE);
     Ip::Address from;
-    snmp_request_t *snmp_rq;
+    SnmpRequest *snmp_rq;
     int len;
 
     debugs(49, 5, "snmpHandleUdp: Called.");
@@ -380,7 +383,7 @@ snmpHandleUdp(int sock, void *not_used)
         buf[len] = '\0';
         debugs(49, 3, "snmpHandleUdp: FD " << sock << ": received " << len << " bytes from " << from << ".");
 
-        snmp_rq = (snmp_request_t *)xcalloc(1, sizeof(snmp_request_t));
+        snmp_rq = (SnmpRequest *)xcalloc(1, sizeof(SnmpRequest));
         snmp_rq->buf = (u_char *) buf;
         snmp_rq->len = len;
         snmp_rq->sock = sock;
@@ -398,7 +401,7 @@ snmpHandleUdp(int sock, void *not_used)
  * Turn SNMP packet into a PDU, check available ACL's
  */
 static void
-snmpDecodePacket(snmp_request_t * rq)
+snmpDecodePacket(SnmpRequest * rq)
 {
     struct snmp_pdu *PDU;
     u_char *Community;
@@ -445,7 +448,7 @@ snmpDecodePacket(snmp_request_t * rq)
  * Packet OK, ACL Check OK, Create reponse.
  */
 static void
-snmpConstructReponse(snmp_request_t * rq)
+snmpConstructReponse(SnmpRequest * rq)
 {
 
     struct snmp_pdu *RespPDU;
@@ -747,7 +750,7 @@ static oid *
 peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
 {
     oid *instance = NULL;
-    peer *peers = Config.peers;
+    CachePeer *peers = Config.peers;
 
     if (peers == NULL) {
         debugs(49, 6, "snmp peer_Inst: No Peers.");
@@ -36,17 +36,17 @@ struct _mib_tree_entry {
     AggrType aggrType;
 };
 
-extern struct snmp_pdu* snmpAgentResponse(struct snmp_pdu* PDU);
-extern AggrType snmpAggrType(oid* Current, snint CurrentLen);
+struct snmp_pdu* snmpAgentResponse(struct snmp_pdu* PDU);
+AggrType snmpAggrType(oid* Current, snint CurrentLen);
 
 extern Comm::ConnectionPointer snmpOutgoingConn;
 
 extern PF snmpHandleUdp;
-extern void snmpInit(void);
-extern void snmpOpenPorts(void);
-extern void snmpClosePorts(void);
-extern const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
-extern void addr2oid(Ip::Address &addr, oid *Dest);
-extern void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
+void snmpInit(void);
+void snmpOpenPorts(void);
+void snmpClosePorts(void);
+const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
+void addr2oid(Ip::Address &addr, oid *Dest);
+void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
 
 #endif /* SQUID_SNMP_CORE_H */
@@ -29,6 +29,7 @@ libsslsquid_la_SOURCES = \
 	ErrorDetail.h \
 	ErrorDetailManager.cc \
 	ErrorDetailManager.h \
+	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \
 	support.cc \
@@ -0,0 +1,51 @@
+#ifndef SQUID_SSLPROXYCERTS_H_
+#define SQUID_SSLPROXYCERTS_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#if USE_SSL
+class ACLList;
+
+class sslproxy_cert_sign {
+public:
+    int alg;
+    ACLList *aclList;
+    sslproxy_cert_sign *next;
+};
+
+class sslproxy_cert_adapt {
+public:
+    int alg;
+    char *param;
+    ACLList *aclList;
+    sslproxy_cert_adapt *next;
+};
+#endif
+
+#endif /* SQUID_SSLPROXYCERTS_H_ */
@@ -9,6 +9,9 @@
 #if HAVE_LIMITS
 #include <limits>
 #endif
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
 
 Ssl::CertificateStorageAction::CertificateStorageAction(const Mgr::Command::Pointer &cmd)
         :   Mgr::Action(cmd)
@@ -9,6 +9,7 @@
 
 #include "SquidTime.h"
 #include "CacheManager.h"
+#include "ip/Address.h"
 #include "mgr/Action.h"
 #include "mgr/Command.h"
 #if HAVE_MAP
@@ -17,6 +18,7 @@
 #if HAVE_LIST
 #include <list>
 #endif
+#include <openssl/ssl.h>
 
 /// TODO: Replace on real size.
 #define SSL_CTX_SIZE 1024
@@ -1,7 +1,3 @@
-/*
- * 2008/11/14
- */
-
 #include "squid.h"
 #include "anyp/PortCfg.h"
 #include "ssl/Config.h"
@@ -10,6 +6,7 @@
 #include "SquidTime.h"
 #include "SwapDir.h"
 #include "wordlist.h"
+#include "SquidConfig.h"
 
 Ssl::Helper * Ssl::Helper::GetInstance()
 {
@@ -42,6 +42,7 @@
 #include "anyp/PortCfg.h"
 #include "fde.h"
 #include "globals.h"
+#include "SquidConfig.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/support.h"
 #include "ssl/gadgets.h"
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "CacheDigest.h"
+#include "CachePeer.h"
 #include "client_side_request.h"
 #include "client_side.h"
 #include "comm/Connection.h"
@@ -41,6 +42,7 @@
 #include "format/Token.h"
 #include "globals.h"
 #include "HttpRequest.h"
+#include "IoStats.h"
 #include "MemObject.h"
 #include "mem_node.h"
 #include "MemBuf.h"
@@ -53,6 +55,7 @@
 #include "mgr/ServiceTimesAction.h"
 #include "neighbors.h"
 #include "PeerDigest.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -219,19 +222,19 @@ GetIoStats(Mgr::IoActionData& stats)
 
     stats.http_reads = IOStats.Http.reads;
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < IoStats::histSize; ++i) {
         stats.http_read_hist[i] = IOStats.Http.read_hist[i];
     }
 
     stats.ftp_reads = IOStats.Ftp.reads;
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < IoStats::histSize; ++i) {
         stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];
     }
 
     stats.gopher_reads = IOStats.Gopher.reads;
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < IoStats::histSize; ++i) {
         stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];
     }
 }
@@ -245,7 +248,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.http_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < IoStats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -258,7 +261,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.ftp_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < IoStats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -271,7 +274,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.gopher_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; ++i) {
+    for (i = 0; i < IoStats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -1810,7 +1813,7 @@ statPeerSelect(StoreEntry * sentry)
 {
 #if USE_CACHE_DIGESTS
     StatCounters *f = &statCounter;
-    peer *peer;
+    CachePeer *peer;
     const int tot_used = f->cd.times_used + f->icp.times_used;
 
     /* totals */
@@ -33,18 +33,18 @@
 #ifndef SQUID_STAT_H_
 #define SQUID_STAT_H_
 
-extern void statInit(void);
-extern void statFreeMemory(void);
-extern double median_svc_get(int, int);
-extern void pconnHistCount(int, int);
-extern int stat5minClientRequests(void);
-extern double stat5minCPUUsage(void);
-extern double statRequestHitRatio(int minutes);
-extern double statRequestHitMemoryRatio(int minutes);
-extern double statRequestHitDiskRatio(int minutes);
-extern double statByteHitRatio(int minutes);
+void statInit(void);
+void statFreeMemory(void);
+double median_svc_get(int, int);
+void pconnHistCount(int, int);
+int stat5minClientRequests(void);
+double stat5minCPUUsage(void);
+double statRequestHitRatio(int minutes);
+double statRequestHitMemoryRatio(int minutes);
+double statRequestHitDiskRatio(int minutes);
+double statByteHitRatio(int minutes);
 
 class StatCounters;
-extern StatCounters *snmpStatGet(int);
+StatCounters *snmpStatGet(int);
 
 #endif /* SQUID_STAT_H_ */
@@ -48,6 +48,8 @@
 #include "mgr/StoreIoAction.h"
 #include "profiler/Profiler.h"
 #include "repl_modules.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Stack.h"
 #include "StatCounters.h"
@@ -816,7 +818,7 @@ StoreEntry::setPublicKey()
 }
 
 StoreEntry *
-storeCreateEntry(const char *url, const char *log_url, request_flags flags, const HttpRequestMethod& method)
+storeCreateEntry(const char *url, const char *log_url, const RequestFlags &flags, const HttpRequestMethod& method)
 {
     StoreEntry *e = NULL;
     MemObject *mem = NULL;
@@ -1965,7 +1967,7 @@ StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 {
     const String reqETags = request.header.getList(HDR_IF_NONE_MATCH);
     // weak comparison is allowed only for HEAD or full-body GET requests
-    const bool allowWeakMatch = !request.flags.range &&
+    const bool allowWeakMatch = !request.flags.isRanged &&
                                 (request.method == METHOD_GET || request.method == METHOD_HEAD);
     return hasOneOfEtags(reqETags, allowWeakMatch);
 }
@@ -40,6 +40,7 @@
 #include "MemObject.h"
 #include "mime_header.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
 #include "StoreClient.h"
 #include "Store.h"
@@ -51,6 +51,7 @@
 #include "MemObject.h"
 #include "PeerDigest.h"
 #include "refresh.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreSearch.h"
@@ -376,7 +377,7 @@ storeDigestRebuildStep(void *datanotused)
 static void
 storeDigestRewriteStart(void *datanotused)
 {
-    request_flags flags;
+    RequestFlags flags;
     char *url;
     StoreEntry *e;
 
@@ -34,9 +34,9 @@
 
 class StoreEntry;
 
-extern void storeDigestInit(void);
-extern void storeDigestNoteStoreReady(void);
-extern void storeDigestDel(const StoreEntry * entry);
-extern void storeDigestReport(StoreEntry *);
+void storeDigestInit(void);
+void storeDigestNoteStoreReady(void);
+void storeDigestDel(const StoreEntry * entry);
+void storeDigestReport(StoreEntry *);
 
 #endif /* SQUID_STORE_DIGEST_H_ */
@@ -37,6 +37,7 @@
 #include "MemObject.h"
 #include "MemStore.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -1,6 +1,7 @@
 #include "squid.h"
 #include "Store.h"
 #include "MemObject.h"
+#include "SquidConfig.h"
 #include "SwapDir.h"
 
 StoreIoStats store_io_stats;
@@ -39,18 +39,18 @@
 class HttpRequestMethod;
 class HttpRequest;
 
-extern cache_key *storeKeyDup(const cache_key *);
-extern cache_key *storeKeyCopy(cache_key *, const cache_key *);
-extern void storeKeyFree(const cache_key *);
-extern const cache_key *storeKeyScan(const char *);
-extern const char *storeKeyText(const cache_key *);
-extern const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
-extern const cache_key *storeKeyPublicByRequest(HttpRequest *);
-extern const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
-extern const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
-extern int storeKeyHashBuckets(int);
-extern int storeKeyNull(const cache_key *);
-extern void storeKeyInit(void);
+cache_key *storeKeyDup(const cache_key *);
+cache_key *storeKeyCopy(cache_key *, const cache_key *);
+void storeKeyFree(const cache_key *);
+const cache_key *storeKeyScan(const char *);
+const char *storeKeyText(const cache_key *);
+const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
+const cache_key *storeKeyPublicByRequest(HttpRequest *);
+const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
+const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
+int storeKeyHashBuckets(int);
+int storeKeyNull(const cache_key *);
+void storeKeyInit(void);
 
 extern HASHHASH storeKeyHashHash;
 extern HASHCMP storeKeyHashCmp;
@@ -38,6 +38,7 @@
 #include "mgr/Registration.h"
 #include "Store.h"
 #include "store_log.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 static const char *storeLogTags[] = {
@@ -34,9 +34,9 @@
 
 class StoreEntry;
 
-extern void storeLog(int tag, const StoreEntry * e);
-extern void storeLogRotate(void);
-extern void storeLogClose(void);
-extern void storeLogOpen(void);
+void storeLog(int tag, const StoreEntry * e);
+void storeLogRotate(void);
+void storeLogClose(void);
+void storeLogOpen(void);
 
 #endif /* SQUID_STORE_LOG_H_ */
@@ -41,12 +41,13 @@
 #include "store_digest.h"
 #include "store_rebuild.h"
 #include "StoreSearch.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
-static struct _store_rebuild_data counts;
+static StoreRebuildData counts;
 
 static struct timeval rebuild_start;
 static void storeCleanup(void *);
@@ -136,7 +137,7 @@ storeCleanup(void *datanotused)
 /* meta data recreated from disk image in swap directory */
 void
 
-storeRebuildComplete(struct _store_rebuild_data *dc)
+storeRebuildComplete(StoreRebuildData *dc)
 {
     double dt;
     counts.objcount += dc->objcount;
@@ -294,7 +295,7 @@ struct InitStoreEntry : public unary_function<StoreMeta, void> {
 
 bool
 storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf,
-                      struct _store_rebuild_data &counts)
+                      StoreRebuildData &counts)
 {
     if (fd < 0)
         return false;
@@ -316,7 +317,7 @@ storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf,
 
 bool
 storeRebuildParseEntry(MemBuf &buf, StoreEntry &tmpe, cache_key *key,
-                       struct _store_rebuild_data &counts,
+                       StoreRebuildData &counts,
                        uint64_t expectedSize)
 {
     int swap_hdr_len = 0;
@@ -382,7 +383,7 @@ storeRebuildParseEntry(MemBuf &buf, StoreEntry &tmpe, cache_key *key,
 
 bool
 storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key,
-                      struct _store_rebuild_data &counts)
+                      StoreRebuildData &counts)
 {
     /* this needs to become
      * 1) unpack url
@@ -32,15 +32,31 @@
  *
  */
 
-extern void storeRebuildStart(void);
-extern void storeRebuildComplete(struct _store_rebuild_data *);
-extern void storeRebuildProgress(int sd_index, int total, int sofar);
+// currently a POD
+class StoreRebuildData
+{
+public:
+    int objcount;       /* # objects successfully reloaded */
+    int expcount;       /* # objects expired */
+    int scancount;      /* # entries scanned or read from state file */
+    int clashcount;     /* # swapfile clashes avoided */
+    int dupcount;       /* # duplicates purged */
+    int cancelcount;        /* # SWAP_LOG_DEL objects purged */
+    int invalid;        /* # bad lines */
+    int badflags;       /* # bad e->flags */
+    int bad_log_op;
+    int zero_object_sz;
+};
+
+void storeRebuildStart(void);
+void storeRebuildComplete(StoreRebuildData *);
+void storeRebuildProgress(int sd_index, int total, int sofar);
 
 /// loads entry from disk; fills supplied memory buffer on success
-extern bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, struct _store_rebuild_data &counts);
+bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, StoreRebuildData &counts);
 /// parses entry buffer and validates entry metadata; fills e on success
-extern bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, struct _store_rebuild_data &counts, uint64_t expectedSize);
+bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, StoreRebuildData &counts, uint64_t expectedSize);
 /// checks whether the loaded entry should be kept; updates counters
-extern bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, struct _store_rebuild_data &counts);
+bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, StoreRebuildData &counts);
 
 #endif /* SQUID_STORE_REBUILD_H_ */
@@ -33,6 +33,6 @@
  */
 
 class store_client;
-extern void storeSwapInStart(store_client *);
+void storeSwapInStart(store_client *);
 
 #endif /* SQUID_STORE_SWAPIN_H_ */
@@ -39,6 +39,7 @@
 /* FIXME: Abstract the use of this more */
 #include "mem_node.h"
 #include "MemObject.h"
+#include "SquidConfig.h"
 #include "SwapDir.h"
 #include "StatCounters.h"
 #include "store_log.h"
@@ -1,1117 +0,0 @@
-/*
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-#ifndef SQUID_STRUCTS_H
-#define SQUID_STRUCTS_H
-
-#include "RefCount.h"
-#include "cbdata.h"
-#include "defines.h"
-#include "dlink.h"
-#include "err_type.h"
-#include "hash.h"
-#include "ip/Address.h"
-
-/* needed for the global config */
-#include "HttpHeader.h"
-#include "HttpHeaderTools.h"
-
-/* for ICP_END */
-#include "icp_opcode.h"
-
-#if USE_SSL
-#include <openssl/ssl.h>
-#endif
-
-#define PEER_MULTICAST_SIBLINGS 1
-
-struct acl_name_list {
-    char name[ACL_NAME_SZ];
-    acl_name_list *next;
-};
-
-struct acl_deny_info_list {
-    err_type err_page_id;
-    char *err_page_name;
-    acl_name_list *acl_list;
-    acl_deny_info_list *next;
-};
-
-class ACLChecklist;
-
-#if SQUID_SNMP
-
-#include "snmp_session.h"
-struct _snmp_request_t {
-    u_char *buf;
-    u_char *outbuf;
-    int len;
-    int sock;
-    long reqid;
-    int outlen;
-
-    Ip::Address from;
-
-    struct snmp_pdu *PDU;
-    ACLChecklist *acl_checklist;
-    u_char *community;
-
-    struct snmp_session session;
-};
-
-#endif
-
-class ACLList;
-
-struct acl_address {
-    acl_address *next;
-    ACLList *aclList;
-
-    Ip::Address addr;
-};
-
-struct acl_tos {
-    acl_tos *next;
-    ACLList *aclList;
-    tos_t tos;
-};
-
-struct acl_nfmark {
-    acl_nfmark *next;
-    ACLList *aclList;
-    nfmark_t nfmark;
-};
-
-struct acl_size_t {
-    acl_size_t *next;
-    ACLList *aclList;
-    int64_t size;
-};
-
-struct ushortlist {
-    unsigned short i;
-    ushortlist *next;
-};
-
-struct relist {
-    int flags;
-    char *pattern;
-    regex_t regex;
-    relist *next;
-};
-
-#if USE_DELAY_POOLS
-#include "DelayConfig.h"
-#include "ClientDelayConfig.h"
-#endif
-
-#if USE_ICMP
-#include "icmp/IcmpConfig.h"
-#endif
-
-#include "HelperChildConfig.h"
-
-/* forward decl for SquidConfig, see RemovalPolicy.h */
-
-class CpuAffinityMap;
-class RemovalPolicySettings;
-class external_acl;
-class Store;
-namespace AnyP
-{
-struct PortCfg;
-}
-class SwapDir;
-
-/// Used for boolean enabled/disabled options with complex default logic.
-/// Allows Squid to compute the right default after configuration.
-/// Checks that not-yet-defined option values are not used.
-class YesNoNone
-{
-// TODO: generalize to non-boolean option types
-public:
-    YesNoNone(): option(0) {}
-
-    /// returns true iff enabled; asserts if the option has not been configured
-    operator void *() const; // TODO: use a fancy/safer version of the operator
-
-    /// enables or disables the option;
-    void configure(bool beSet);
-
-    /// whether the option was enabled or disabled, by user or Squid
-    bool configured() const { return option != 0; }
-
-private:
-    enum { optUnspecified = -1, optDisabled = 0, optEnabled = 1 };
-    int option; ///< configured value or zero
-};
-
-struct SquidConfig {
-
-    struct {
-        /* These should be for the Store::Root instance.
-        * this needs pluggable parsing to be done smoothly.
-        */
-        int highWaterMark;
-        int lowWaterMark;
-    } Swap;
-
-    YesNoNone memShared; ///< whether the memory cache is shared among workers
-    size_t memMaxSize;
-
-    struct {
-        int64_t min;
-        int pct;
-        int64_t max;
-    } quickAbort;
-    int64_t readAheadGap;
-    RemovalPolicySettings *replPolicy;
-    RemovalPolicySettings *memPolicy;
-#if USE_HTTP_VIOLATIONS
-    time_t negativeTtl;
-#endif
-    time_t maxStale;
-    time_t negativeDnsTtl;
-    time_t positiveDnsTtl;
-    time_t shutdownLifetime;
-    time_t backgroundPingRate;
-
-    struct {
-        time_t read;
-        time_t write;
-        time_t lifetime;
-        time_t connect;
-        time_t forward;
-        time_t peer_connect;
-        time_t request;
-        time_t clientIdlePconn;
-        time_t serverIdlePconn;
-        time_t siteSelect;
-        time_t deadPeer;
-        int icp_query;		/* msec */
-        int icp_query_max;	/* msec */
-        int icp_query_min;	/* msec */
-        int mcast_icp_query;	/* msec */
-
-#if !USE_DNSHELPER
-        time_msec_t idns_retransmit;
-        time_msec_t idns_query;
-#endif
-
-    } Timeout;
-    size_t maxRequestHeaderSize;
-    int64_t maxRequestBodySize;
-    int64_t maxChunkedRequestBodySize;
-    size_t maxRequestBufferSize;
-    size_t maxReplyHeaderSize;
-    acl_size_t *ReplyBodySize;
-
-    struct {
-        unsigned short icp;
-#if USE_HTCP
-
-        unsigned short htcp;
-#endif
-#if SQUID_SNMP
-
-        unsigned short snmp;
-#endif
-    } Port;
-
-    struct {
-        AnyP::PortCfg *http;
-#if USE_SSL
-        AnyP::PortCfg *https;
-#endif
-    } Sockaddr;
-#if SQUID_SNMP
-
-    struct {
-        char *configFile;
-        char *agentInfo;
-    } Snmp;
-#endif
-#if USE_WCCP
-
-    struct {
-        Ip::Address router;
-        Ip::Address address;
-        int version;
-    } Wccp;
-#endif
-#if USE_WCCPv2
-
-    struct {
-        Ip::Address_list *router;
-        Ip::Address address;
-        int forwarding_method;
-        int return_method;
-        int assignment_method;
-        int weight;
-        int rebuildwait;
-        void *info;
-    } Wccp2;
-#endif
-
-#if USE_ICMP
-    IcmpConfig pinger;
-#endif
-
-    char *as_whois_server;
-
-    struct {
-        char *store;
-        char *swap;
-        customlog *accesslogs;
-#if ICAP_CLIENT
-        customlog *icaplogs;
-#endif
-        int rotateNumber;
-    } Log;
-    char *adminEmail;
-    char *EmailFrom;
-    char *EmailProgram;
-    char *effectiveUser;
-    char *visible_appname_string;
-    char *effectiveGroup;
-
-    struct {
-#if USE_DNSHELPER
-        char *dnsserver;
-#endif
-
-        wordlist *redirect;
-#if USE_UNLINKD
-
-        char *unlinkd;
-#endif
-
-        char *diskd;
-#if USE_SSL
-
-        char *ssl_password;
-#endif
-
-    } Program;
-#if USE_DNSHELPER
-    HelperChildConfig dnsChildren;
-#endif
-
-    HelperChildConfig redirectChildren;
-    time_t authenticateGCInterval;
-    time_t authenticateTTL;
-    time_t authenticateIpTTL;
-
-    struct {
-        char *surrogate_id;
-    } Accel;
-    char *appendDomain;
-    size_t appendDomainLen;
-    char *pidFilename;
-    char *netdbFilename;
-    char *mimeTablePathname;
-    char *etcHostsPath;
-    char *visibleHostname;
-    char *uniqueHostname;
-    wordlist *hostnameAliases;
-    char *errHtmlText;
-
-    struct {
-        char *host;
-        char *file;
-        time_t period;
-        unsigned short port;
-    } Announce;
-
-    struct {
-
-        Ip::Address udp_incoming;
-        Ip::Address udp_outgoing;
-#if SQUID_SNMP
-        Ip::Address snmp_incoming;
-        Ip::Address snmp_outgoing;
-#endif
-        /* FIXME INET6 : this should really be a CIDR value */
-        Ip::Address client_netmask;
-    } Addrs;
-    size_t tcpRcvBufsz;
-    size_t udpMaxHitObjsz;
-    wordlist *hierarchy_stoplist;
-    wordlist *mcast_group_list;
-    wordlist *dns_nameservers;
-    peer *peers;
-    int npeers;
-
-    struct {
-        int size;
-        int low;
-        int high;
-    } ipcache;
-
-    struct {
-        int size;
-    } fqdncache;
-    int minDirectHops;
-    int minDirectRtt;
-    cachemgr_passwd *passwd_list;
-
-    struct {
-        int objectsPerBucket;
-        int64_t avgObjectSize;
-        int64_t maxObjectSize;
-        int64_t minObjectSize;
-        size_t maxInMemObjSize;
-    } Store;
-
-    struct {
-        int high;
-        int low;
-        time_t period;
-    } Netdb;
-
-    struct {
-        int log_udp;
-        int res_defnames;
-        int anonymizer;
-        int client_db;
-        int query_icmp;
-        int icp_hit_stale;
-        int buffered_logs;
-        int common_log;
-        int log_mime_hdrs;
-        int log_fqdn;
-        int announce;
-        int mem_pools;
-        int test_reachability;
-        int half_closed_clients;
-        int refresh_all_ims;
-#if USE_HTTP_VIOLATIONS
-
-        int reload_into_ims;
-#endif
-
-        int offline;
-        int redir_rewrites_host;
-        int prefer_direct;
-        int nonhierarchical_direct;
-        int strip_query_terms;
-        int redirector_bypass;
-        int ignore_unknown_nameservers;
-        int client_pconns;
-        int server_pconns;
-        int error_pconns;
-#if USE_CACHE_DIGESTS
-
-        int digest_generation;
-#endif
-
-        int ie_refresh;
-        int vary_ignore_expire;
-        int pipeline_prefetch;
-        int surrogate_is_remote;
-        int request_entities;
-        int detect_broken_server_pconns;
-        int balance_on_multiple_ip;
-        int relaxed_header_parser;
-        int check_hostnames;
-        int allow_underscore;
-        int via;
-        int emailErrData;
-        int httpd_suppress_version_string;
-        int global_internal_static;
-
-#if FOLLOW_X_FORWARDED_FOR
-        int acl_uses_indirect_client;
-        int delay_pool_uses_indirect_client;
-        int log_uses_indirect_client;
-#if LINUX_NETFILTER
-        int tproxy_uses_indirect_client;
-#endif
-#endif /* FOLLOW_X_FORWARDED_FOR */
-
-        int WIN32_IpAddrChangeMonitor;
-        int memory_cache_first;
-        int memory_cache_disk;
-        int hostStrictVerify;
-        int client_dst_passthru;
-    } onoff;
-
-    int forward_max_tries;
-    int connect_retries;
-
-    class ACL *aclList;
-
-    struct {
-        acl_access *http;
-        acl_access *adapted_http;
-        acl_access *icp;
-        acl_access *miss;
-        acl_access *NeverDirect;
-        acl_access *AlwaysDirect;
-        acl_access *ASlists;
-        acl_access *noCache;
-        acl_access *log;
-#if SQUID_SNMP
-
-        acl_access *snmp;
-#endif
-#if USE_HTTP_VIOLATIONS
-        acl_access *brokenPosts;
-#endif
-        acl_access *redirector;
-        acl_access *reply;
-        acl_address *outgoing_address;
-#if USE_HTCP
-
-        acl_access *htcp;
-        acl_access *htcp_clr;
-#endif
-
-#if USE_SSL
-        acl_access *ssl_bump;
-#endif
-#if FOLLOW_X_FORWARDED_FOR
-        acl_access *followXFF;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-
-#if ICAP_CLIENT
-        acl_access* icap;
-#endif
-    } accessList;
-    acl_deny_info_list *denyInfoList;
-
-    struct {
-        size_t list_width;
-        int list_wrap;
-        char *anon_user;
-        int passive;
-        int epsv_all;
-        int epsv;
-        int eprt;
-        int sanitycheck;
-        int telnet;
-    } Ftp;
-    refresh_t *Refresh;
-
-    struct _cacheSwap {
-        RefCount<SwapDir> *swapDirs;
-        int n_allocated;
-        int n_configured;
-        /// number of disk processes required to support all cache_dirs
-        int n_strands;
-    } cacheSwap;
-    /*
-     * I'm sick of having to keep doing this ..
-     */
-#define INDEXSD(i)   (Config.cacheSwap.swapDirs[(i)].getRaw())
-
-    struct {
-        char *directory;
-        int use_short_names;
-    } icons;
-    char *errorDirectory;
-#if USE_ERR_LOCALES
-    char *errorDefaultLanguage;
-    int errorLogMissingLanguages;
-#endif
-    char *errorStylesheet;
-
-    struct {
-        int onerror;
-    } retry;
-
-    struct {
-        int64_t limit;
-    } MemPools;
-#if USE_DELAY_POOLS
-
-    DelayConfig Delay;
-    ClientDelayConfig ClientDelay;
-#endif
-
-    struct {
-        struct {
-            int average;
-            int min_poll;
-        } dns, udp, tcp;
-    } comm_incoming;
-    int max_open_disk_fds;
-    int uri_whitespace;
-    acl_size_t *rangeOffsetLimit;
-#if MULTICAST_MISS_STREAM
-
-    struct {
-
-        Ip::Address addr;
-        int ttl;
-        unsigned short port;
-        char *encode_key;
-    } mcast_miss;
-#endif
-
-    /// request_header_access and request_header_replace
-    HeaderManglers *request_header_access;
-    /// reply_header_access and reply_header_replace
-    HeaderManglers *reply_header_access;
-    ///request_header_add access list
-    HeaderWithAclList *request_header_add;
-    char *coredump_dir;
-    char *chroot_dir;
-#if USE_CACHE_DIGESTS
-
-    struct {
-        int bits_per_entry;
-        time_t rebuild_period;
-        time_t rewrite_period;
-        size_t swapout_chunk_size;
-        int rebuild_chunk_percentage;
-    } digest;
-#endif
-#if USE_SSL
-
-    struct {
-        int unclean_shutdown;
-        char *ssl_engine;
-    } SSL;
-#endif
-
-    wordlist *ext_methods;
-
-    struct {
-        int high_rptm;
-        int high_pf;
-        size_t high_memory;
-    } warnings;
-    char *store_dir_select_algorithm;
-    int sleep_after_fork;	/* microseconds */
-    time_t minimum_expiry_time;	/* seconds */
-    external_acl *externalAclHelperList;
-
-#if USE_SSL
-
-    struct {
-        char *cert;
-        char *key;
-        int version;
-        char *options;
-        char *cipher;
-        char *cafile;
-        char *capath;
-        char *crlfile;
-        char *flags;
-        acl_access *cert_error;
-        SSL_CTX *sslContext;
-        sslproxy_cert_sign *cert_sign;
-        sslproxy_cert_adapt *cert_adapt;
-    } ssl_client;
-#endif
-
-    char *accept_filter;
-    int umask;
-    int max_filedescriptors;
-    int workers;
-    CpuAffinityMap *cpuAffinityMap;
-
-#if USE_LOADABLE_MODULES
-    wordlist *loadable_module_names;
-#endif
-
-    int client_ip_max_connections;
-
-    struct {
-        int v4_first;       ///< Place IPv4 first in the order of DNS results.
-        ssize_t packet_max; ///< maximum size EDNS advertised for DNS replies.
-    } dns;
-};
-
-SQUIDCEXTERN SquidConfig Config;
-
-struct SquidConfig2 {
-    struct {
-        int enable_purge;
-        int mangle_request_headers;
-    } onoff;
-    uid_t effectiveUserID;
-    gid_t effectiveGroupID;
-};
-
-SQUIDCEXTERN SquidConfig2 Config2;
-
-struct _close_handler {
-    PF *handler;
-    void *data;
-    close_handler *next;
-};
-
-struct _dread_ctrl {
-    int fd;
-    off_t offset;
-    int req_len;
-    char *buf;
-    int end_of_file;
-    DRCB *handler;
-    void *client_data;
-};
-
-struct _dwrite_q {
-    off_t file_offset;
-    char *buf;
-    size_t len;
-    size_t buf_offset;
-    dwrite_q *next;
-    FREE *free_func;
-};
-
-struct _fde_disk {
-    DWCB *wrt_handle;
-    void *wrt_handle_data;
-    dwrite_q *write_q;
-    dwrite_q *write_q_tail;
-    off_t offset;
-};
-
-/* per field statistics */
-
-class HttpHeaderFieldStat
-{
-
-public:
-    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0) {}
-
-    int aliveCount;		/* created but not destroyed (count) */
-    int seenCount;		/* #fields we've seen */
-    int parsCount;		/* #parsing attempts */
-    int errCount;		/* #pasring errors */
-    int repCount;		/* #repetitons */
-};
-
-/* compiled version of HttpHeaderFieldAttrs plus stats */
-#include "SquidString.h"
-
-class HttpHeaderFieldInfo
-{
-
-public:
-    HttpHeaderFieldInfo() : id (HDR_ACCEPT), type (ftInvalid) {}
-
-    http_hdr_type id;
-    String name;
-    field_type type;
-    HttpHeaderFieldStat stat;
-};
-
-struct _http_state_flags {
-    unsigned int proxying:1;
-    unsigned int keepalive:1;
-    unsigned int only_if_cached:1;
-    unsigned int handling1xx:1; ///< we are ignoring or forwarding 1xx response
-    unsigned int headers_parsed:1;
-    unsigned int front_end_https:2;
-    unsigned int originpeer:1;
-    unsigned int keepalive_broken:1;
-    unsigned int abuse_detected:1;
-    unsigned int request_sent:1;
-    unsigned int do_next_read:1;
-    unsigned int consume_body_data:1;
-    unsigned int chunked:1; ///< reading a chunked response; TODO: rename
-    unsigned int chunked_request:1; ///< writing a chunked request
-    unsigned int sentLastChunk:1; ///< do not try to write last-chunk again
-};
-
-struct _domain_ping {
-    char *domain;
-    int do_ping;		/* boolean */
-    domain_ping *next;
-};
-
-struct _domain_type {
-    char *domain;
-    peer_t type;
-    domain_type *next;
-};
-
-class PeerDigest;
-
-struct peer {
-    u_int index;
-    char *name;
-    char *host;
-    peer_t type;
-
-    Ip::Address in_addr;
-
-    struct {
-        int pings_sent;
-        int pings_acked;
-        int fetches;
-        int rtt;
-        int ignored_replies;
-        int n_keepalives_sent;
-        int n_keepalives_recv;
-        time_t probe_start;
-        time_t last_query;
-        time_t last_reply;
-        time_t last_connect_failure;
-        time_t last_connect_probe;
-        int logged_state;	/* so we can print dead/revived msgs */
-        int conn_open;		/* current opened connections */
-    } stats;
-
-    struct {
-        int version;
-        int counts[ICP_END+1];
-        unsigned short port;
-    } icp;
-
-#if USE_HTCP
-    struct {
-        double version;
-        int counts[2];
-        unsigned short port;
-    } htcp;
-#endif
-
-    unsigned short http_port;
-    domain_ping *peer_domain;
-    domain_type *typelist;
-    acl_access *access;
-
-    struct {
-        unsigned int proxy_only:1;
-        unsigned int no_query:1;
-        unsigned int background_ping:1;
-        unsigned int no_digest:1;
-        unsigned int default_parent:1;
-        unsigned int roundrobin:1;
-        unsigned int weighted_roundrobin:1;
-        unsigned int mcast_responder:1;
-        unsigned int closest_only:1;
-#if USE_HTCP
-        unsigned int htcp:1;
-        unsigned int htcp_oldsquid:1;
-        unsigned int htcp_no_clr:1;
-        unsigned int htcp_no_purge_clr:1;
-        unsigned int htcp_only_clr:1;
-        unsigned int htcp_forward_clr:1;
-#endif
-        unsigned int no_netdb_exchange:1;
-#if USE_DELAY_POOLS
-        unsigned int no_delay:1;
-#endif
-        unsigned int allow_miss:1;
-        unsigned int carp:1;
-        struct {
-            unsigned int set:1; //If false, whole url is to be used. Overrides others
-            unsigned int scheme:1;
-            unsigned int host:1;
-            unsigned int port:1;
-            unsigned int path:1;
-            unsigned int params:1;
-        } carp_key;
-#if USE_AUTH
-        unsigned int userhash:1;
-#endif
-        unsigned int sourcehash:1;
-        unsigned int originserver:1;
-        unsigned int no_tproxy:1;
-#if PEER_MULTICAST_SIBLINGS
-        unsigned int mcast_siblings:1;
-#endif
-    } options;
-
-    int weight;
-    int basetime;
-
-    struct {
-        double avg_n_members;
-        int n_times_counted;
-        int n_replies_expected;
-        int ttl;
-        int id;
-
-        struct {
-            unsigned int count_event_pending:1;
-            unsigned int counting:1;
-        } flags;
-    } mcast;
-#if USE_CACHE_DIGESTS
-
-    PeerDigest *digest;
-    char *digest_url;
-#endif
-
-    int tcp_up;			/* 0 if a connect() fails */
-
-    Ip::Address addresses[10];
-    int n_addresses;
-    int rr_count;
-    peer *next;
-    int testing_now;
-
-    struct {
-        unsigned int hash;
-        double load_multiplier;
-        double load_factor;	/* normalized weight value */
-    } carp;
-#if USE_AUTH
-    struct {
-        unsigned int hash;
-        double load_multiplier;
-        double load_factor;	/* normalized weight value */
-    } userhash;
-#endif
-    struct {
-        unsigned int hash;
-        double load_multiplier;
-        double load_factor;	/* normalized weight value */
-    } sourcehash;
-
-    char *login;		/* Proxy authorization */
-    time_t connect_timeout;
-    int connect_fail_limit;
-    int max_conn;
-    char *domain;		/* Forced domain */
-#if USE_SSL
-
-    int use_ssl;
-    char *sslcert;
-    char *sslkey;
-    int sslversion;
-    char *ssloptions;
-    char *sslcipher;
-    char *sslcafile;
-    char *sslcapath;
-    char *sslcrlfile;
-    char *sslflags;
-    char *ssldomain;
-    SSL_CTX *sslContext;
-    SSL_SESSION *sslSession;
-#endif
-
-    int front_end_https;
-    int connection_auth;
-};
-
-struct _net_db_name {
-    hash_link hash;		/* must be first */
-    net_db_name *next;
-    netdbEntry *net_db_entry;
-};
-
-struct _net_db_peer {
-    const char *peername;
-    double hops;
-    double rtt;
-    time_t expires;
-};
-
-struct _netdbEntry {
-    hash_link hash;		/* must be first */
-    char network[MAX_IPSTRLEN];
-    int pings_sent;
-    int pings_recv;
-    double hops;
-    double rtt;
-    time_t next_ping_time;
-    time_t last_use_time;
-    int link_count;
-    net_db_name *hosts;
-    net_db_peer *peers;
-    int n_peers_alloc;
-    int n_peers;
-};
-
-struct _iostats {
-
-    enum { histSize = 16 };
-
-    struct {
-        int reads;
-        int reads_deferred;
-        int read_hist[histSize];
-        int writes;
-        int write_hist[histSize];
-    }
-
-    Http, Ftp, Gopher;
-};
-
-struct request_flags {
-    request_flags(): range(0),nocache(0),ims(0),auth(0),cachable(0),hierarchical(0),loopdetect(0),proxy_keepalive(0),proxying(0),refresh(0),redirected(0),need_validation(0),fail_on_validation_err(0),stale_if_hit(0),accelerated(0),ignore_cc(0),intercepted(0),hostVerified(0),spoof_client_ip(0),internal(0),internalclient(0),must_keepalive(0),pinned(0),canRePin(0),chunked_reply(0),stream_error(0),sslPeek(0),sslBumped(0),destinationIPLookedUp_(0) {
-#if USE_HTTP_VIOLATIONS
-        nocache_hack = 0;
-#endif
-#if FOLLOW_X_FORWARDED_FOR
-        done_follow_x_forwarded_for = 0;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-    }
-
-    unsigned int range:1;
-    unsigned int nocache:1;            ///< whether the response to this request may be READ from cache
-    unsigned int ims:1;
-    unsigned int auth:1;
-    unsigned int cachable:1;           ///< whether the response to thie request may be stored in the cache
-    unsigned int hierarchical:1;
-    unsigned int loopdetect:1;
-    unsigned int proxy_keepalive:1;
-unsigned int proxying:
-    1;	/* this should be killed, also in httpstateflags */
-    unsigned int refresh:1;
-    unsigned int redirected:1;
-    unsigned int need_validation:1;
-    unsigned int fail_on_validation_err:1; ///< whether we should fail if validation fails
-    unsigned int stale_if_hit:1; ///< reply is stale if it is a hit
-#if USE_HTTP_VIOLATIONS
-    unsigned int nocache_hack:1;	/* for changing/ignoring no-cache requests */
-#endif
-    unsigned int accelerated:1;
-    unsigned int ignore_cc:1;
-    unsigned int intercepted:1;        ///< intercepted request
-    unsigned int hostVerified:1;       ///< whether the Host: header passed verification
-    unsigned int spoof_client_ip:1;  /**< spoof client ip if possible */
-    unsigned int internal:1;
-    unsigned int internalclient:1;
-    unsigned int must_keepalive:1;
-    unsigned int connection_auth:1; /** Request wants connection oriented auth */
-    unsigned int connection_auth_disabled:1; /** Connection oriented auth can not be supported */
-    unsigned int connection_proxy_auth:1; /** Request wants connection oriented auth */
-    unsigned int pinned:1;      /* Request sent on a pinned connection */
-    unsigned int canRePin:1; ///< OK to reopen a failed pinned connection
-    unsigned int auth_sent:1;   /* Authentication forwarded */
-    unsigned int no_direct:1;	/* Deny direct forwarding unless overriden by always_direct. Used in accelerator mode */
-    unsigned int chunked_reply:1; /**< Reply with chunked transfer encoding */
-    unsigned int stream_error:1; /**< Whether stream error has occured */
-    unsigned int sslPeek:1; ///< internal ssl-bump request to get server cert
-    unsigned int sslBumped:1; /**< ssl-bumped request*/
-
-    // When adding new flags, please update cloneAdaptationImmune() as needed.
-
-    bool resetTCP() const;
-    void setResetTCP();
-    void clearResetTCP();
-    void destinationIPLookupCompleted();
-    bool destinationIPLookedUp() const;
-
-    // returns a partial copy of the flags that includes only those flags
-    // that are safe for a related (e.g., ICAP-adapted) request to inherit
-    request_flags cloneAdaptationImmune() const;
-
-#if FOLLOW_X_FORWARDED_FOR
-    unsigned int done_follow_x_forwarded_for;
-#endif /* FOLLOW_X_FORWARDED_FOR */
-private:
-
-    unsigned int reset_tcp:1;
-    unsigned int destinationIPLookedUp_:1;
-};
-
-struct _cachemgr_passwd {
-    char *passwd;
-    wordlist *actions;
-    cachemgr_passwd *next;
-};
-
-struct _refresh_t {
-    const char *pattern;
-    regex_t compiled_pattern;
-    time_t min;
-    double pct;
-    time_t max;
-    refresh_t *next;
-
-    struct {
-        unsigned int icase:1;
-        unsigned int refresh_ims:1;
-        unsigned int store_stale:1;
-#if USE_HTTP_VIOLATIONS
-        unsigned int override_expire:1;
-        unsigned int override_lastmod:1;
-        unsigned int reload_into_ims:1;
-        unsigned int ignore_reload:1;
-        unsigned int ignore_no_cache:1;
-        unsigned int ignore_no_store:1;
-        unsigned int ignore_must_revalidate:1;
-        unsigned int ignore_private:1;
-        unsigned int ignore_auth:1;
-#endif
-    } flags;
-    int max_stale;
-};
-
-struct _CacheDigest {
-    /* public, read-only */
-    char *mask;			/* bit mask */
-    int mask_size;		/* mask size in bytes */
-    int capacity;		/* expected maximum for .count, not a hard limit */
-    int bits_per_entry;		/* number of bits allocated for each entry from capacity */
-    int count;			/* number of digested entries */
-    int del_count;		/* number of deletions performed so far */
-};
-
-struct _store_rebuild_data {
-    int objcount;		/* # objects successfully reloaded */
-    int expcount;		/* # objects expired */
-    int scancount;		/* # entries scanned or read from state file */
-    int clashcount;		/* # swapfile clashes avoided */
-    int dupcount;		/* # duplicates purged */
-    int cancelcount;		/* # SWAP_LOG_DEL objects purged */
-    int invalid;		/* # bad lines */
-    int badflags;		/* # bad e->flags */
-    int bad_log_op;
-    int zero_object_sz;
-};
-
-#if USE_SSL
-struct _sslproxy_cert_sign {
-    int alg;
-    ACLList *aclList;
-    sslproxy_cert_sign *next;
-};
-
-struct _sslproxy_cert_adapt {
-    int alg;
-    char *param;
-    ACLList *aclList;
-    sslproxy_cert_adapt *next;
-};
-#endif
-
-class Logfile;
-
-#include "format/Format.h"
-#include "log/Formats.h"
-struct _customlog {
-    char *filename;
-    ACLList *aclList;
-    Format::Format *logFormat;
-    Logfile *logfile;
-    customlog *next;
-    Log::Format::log_type type;
-};
-
-#endif /* SQUID_STRUCTS_H */
@@ -31,8 +31,10 @@
  */
 
 #include "squid.h"
+#include "acl/Acl.h"
 #include "ConfigParser.h"
 #include "wordlist.h"
+#include "YesNoNone.h"
 
 #define STUB_API "cache_cf.cc"
 #include "tests/STUB.h"
@@ -1,6 +1,5 @@
 #include "squid.h"
 #include "base/AsyncJob.h"
-#include "structs.h"
 
 #define STUB_API "comm/libcomm.la"
 #include "tests/STUB.h"
@@ -17,8 +16,8 @@ Comm::Connection::Connection() STUB
 Comm::Connection::~Connection() STUB
 Comm::ConnectionPointer Comm::Connection::copyDetails() const STUB_RETVAL(NULL)
 void Comm::Connection::close() STUB
-peer * Comm::Connection::getPeer() const STUB_RETVAL(NULL)
-void Comm::Connection::setPeer(peer * p) STUB
+CachePeer * Comm::Connection::getPeer() const STUB_RETVAL(NULL)
+void Comm::Connection::setPeer(CachePeer * p) STUB
 
 #include "comm/ConnOpener.h"
 CBDATA_NAMESPACED_CLASS_INIT(Comm, ConnOpener);
@@ -22,10 +22,10 @@ void netdbDump(StoreEntry *) STUB
 void netdbFreeMemory(void) STUB
 int netdbHostHops(const char *host) STUB_RETVAL(-1)
 int netdbHostRtt(const char *host) STUB_RETVAL(-1)
-void netdbUpdatePeer(HttpRequest *, peer * e, int rtt, int hops) STUB
+void netdbUpdatePeer(HttpRequest *, CachePeer * e, int rtt, int hops) STUB
 void netdbDeleteAddrNetwork(Ip::Address &addr) STUB
 void netdbBinaryExchange(StoreEntry *) STUB
 void netdbExchangeStart(void *) STUB
-void netdbExchangeUpdatePeer(Ip::Address &, peer *, double, double) STUB
-peer *netdbClosestParent(HttpRequest *) STUB_RETVAL(NULL)
+void netdbExchangeUpdatePeer(Ip::Address &, CachePeer *, double, double) STUB
+CachePeer *netdbClosestParent(HttpRequest *) STUB_RETVAL(NULL)
 void netdbHostData(const char *host, int *samp, int *rtt, int *hops) STUB
@@ -1,4 +1,5 @@
 #include "squid.h"
+#include "RequestFlags.h"
 
 #define STUB_API "store.cc"
 #include "tests/STUB.h"
@@ -109,28 +110,28 @@ std::ostream &operator <<(std::ostream &os, const StoreEntry &)
     return os;
 }
 
-SQUIDCEXTERN size_t storeEntryInUse() STUB_RETVAL(0)
-SQUIDCEXTERN const char *storeEntryFlags(const StoreEntry *) STUB_RETVAL(NULL)
+size_t storeEntryInUse() STUB_RETVAL(0)
+const char *storeEntryFlags(const StoreEntry *) STUB_RETVAL(NULL)
 void storeEntryReplaceObject(StoreEntry *, HttpReply *) STUB
-SQUIDCEXTERN StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method) STUB_RETVAL(NULL)
-SQUIDCEXTERN StoreEntry *storeGetPublicByRequest(HttpRequest * request) STUB_RETVAL(NULL)
-SQUIDCEXTERN StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method) STUB_RETVAL(NULL)
-SQUIDCEXTERN StoreEntry *storeCreateEntry(const char *, const char *, request_flags, const HttpRequestMethod&) STUB_RETVAL(NULL)
-SQUIDCEXTERN void storeInit(void) STUB
-SQUIDCEXTERN void storeConfigure(void) STUB
-SQUIDCEXTERN void storeFreeMemory(void) STUB
-SQUIDCEXTERN int expiresMoreThan(time_t, time_t) STUB_RETVAL(0)
-SQUIDCEXTERN void storeAppendPrintf(StoreEntry *, const char *,...) STUB
+StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method) STUB_RETVAL(NULL)
+StoreEntry *storeGetPublicByRequest(HttpRequest * request) STUB_RETVAL(NULL)
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method) STUB_RETVAL(NULL)
+extern StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&) STUB_RETVAL(NULL)
+void storeInit(void) STUB
+void storeConfigure(void) STUB
+void storeFreeMemory(void) STUB
+int expiresMoreThan(time_t, time_t) STUB_RETVAL(0)
+void storeAppendPrintf(StoreEntry *, const char *,...) STUB
 void storeAppendVPrintf(StoreEntry *, const char *, va_list ap) STUB
-SQUIDCEXTERN int storeTooManyDiskFilesOpen(void) STUB_RETVAL(0)
-SQUIDCEXTERN void storeHeapPositionUpdate(StoreEntry *, SwapDir *) STUB
-SQUIDCEXTERN void storeSwapFileNumberSet(StoreEntry * e, sfileno filn) STUB
-SQUIDCEXTERN void storeFsInit(void) STUB
-SQUIDCEXTERN void storeFsDone(void) STUB
-SQUIDCEXTERN void storeReplAdd(const char *, REMOVALPOLICYCREATE *) STUB
+int storeTooManyDiskFilesOpen(void) STUB_RETVAL(0)
+void storeHeapPositionUpdate(StoreEntry *, SwapDir *) STUB
+void storeSwapFileNumberSet(StoreEntry * e, sfileno filn) STUB
+void storeFsInit(void) STUB
+void storeFsDone(void) STUB
+void storeReplAdd(const char *, REMOVALPOLICYCREATE *) STUB
 void destroyStoreEntry(void *) STUB
-// in Packer.cc !? SQUIDCEXTERN void packerToStoreInit(Packer * p, StoreEntry * e) STUB
-SQUIDCEXTERN void storeGetMemSpace(int size) STUB
+// in Packer.cc !? void packerToStoreInit(Packer * p, StoreEntry * e) STUB
+void storeGetMemSpace(int size) STUB
 
 #if !_USE_INLINE_
 #include "Store.cci"
@@ -32,15 +32,16 @@
 
 #include "squid.h"
 #include "MemBuf.h"
+#include "store_rebuild.h"
 
 #define STUB_API "stub_store_rebuild.cc"
 #include "tests/STUB.h"
 
 void storeRebuildProgress(int sd_index, int total, int sofar) STUB
-void storeRebuildComplete(struct _store_rebuild_data *dc) STUB_NOP
-bool storeRebuildLoadEntry(int, int, MemBuf&, _store_rebuild_data&)
+void storeRebuildComplete(StoreRebuildData *dc) STUB_NOP
+bool storeRebuildLoadEntry(int, int, MemBuf&, StoreRebuildData&)
 {
     return false;
 }
-bool storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key, struct _store_rebuild_data &counts) STUB_RETVAL(false)
-bool storeRebuildParseEntry(MemBuf &, StoreEntry &, cache_key *, struct _store_rebuild_data &, uint64_t) STUB_RETVAL(false)
+bool storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key, StoreRebuildData &counts) STUB_RETVAL(false)
+bool storeRebuildParseEntry(MemBuf &, StoreEntry &, cache_key *, StoreRebuildData &, uint64_t) STUB_RETVAL(false)
@@ -9,8 +9,10 @@
 #include "MemObject.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
+#include "RequestFlags.h"
 #include "StoreFileSystem.h"
 #include "testStoreSupport.h"
+#include "SquidConfig.h"
 
 #if HAVE_STDEXCEPT
 #include <stdexcept>
@@ -187,7 +189,7 @@ testCoss::testCossSearch()
     /* add an entry */
     {
         /* Create "vary" base object */
-        request_flags flags;
+        RequestFlags flags;
         flags.cachable = 1;
         StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
         HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
@@ -4,8 +4,10 @@
 #include <cppunit/TestAssert.h>
 
 #include "testEventLoop.h"
+#include "AsyncEngine.h"
 #include "EventLoop.h"
 #include "Mem.h"
+#include "SquidTime.h"
 #include "stat.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testEventLoop );
@@ -7,7 +7,7 @@
 #include "HttpParser.h"
 #include "Mem.h"
 #include "MemBuf.h"
-#include "structs.h"
+#include "SquidConfig.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpParser );
 
@@ -7,10 +7,11 @@
 #include "HttpReply.h"
 #include "Mem.h"
 #include "mime_header.h"
+#include "SquidConfig.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpReply );
 
-struct SquidConfig Config;
+class SquidConfig Config;
 
 /* stub functions to link successfully */
 
@@ -9,6 +9,8 @@
 #include "MemObject.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "StoreFileSystem.h"
 #include "testStoreSupport.h"
 
@@ -158,7 +160,7 @@ testNull::testNullSearch()
     /* add an entry */
     {
         /* Create "vary" base object */
-        request_flags flags;
+        RequestFlags flags;
         flags.cachable = 1;
         StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
         /* We are allowed to do this typecast */
@@ -8,6 +8,8 @@
 #include "HttpReply.h"
 #include "Mem.h"
 #include "MemObject.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreFileSystem.h"
 #include "StoreSearch.h"
@@ -169,7 +171,7 @@ testRock::storeInit()
 StoreEntry *
 testRock::createEntry(const int i)
 {
-    request_flags flags;
+    RequestFlags flags;
     flags.cachable = 1;
     char url[64];
     snprintf(url, sizeof(url), "dummy url %i", i);