@@ -363,6 +363,26 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.20 (08 Jun 2011):
+
+	- Regression Bug 3545: FreeBSD dnsserver segfaults
+	- Regression Bug 3504: clientside_tos fails to mark traffic
+	- Bug 3539: CONNECT server connection not closed correctly on errors
+	- Bug 3502: client timeout uses server-side read_timeout, not request_timeout
+	- Bug 3466: Adaptation stuck on last single-byte body piece
+	- Bug 3463: dnsserver fails to compile
+	- Bug 3439: correct external_acl_type documented default for ipv4/ipv6 option
+	- Bug 3390: Proxy auth data visible to scripts
+	- Bug 3263: ssl_crtd: undefined references to squid_curtime
+	- Bug 3233: Invalid URL accepted with url host is white spaces
+	- Bug 3133: Memory leak handling requests for sites that don't exist
+	- Bug 3074: Improper URL handling with empty path (RFC 3986)
+	- Bug 3013: segmentation fault on shutdown commSetCloseOnExec at comm.cc:1889
+	- Regression: snmp/udp address directives not resolving hostname
+	- Better helper-to-Squid buffer size management.
+	- Support CoAP over HTTP (coap:// and coaps:// URLs)
+	- Support for 3.2 error template codes
+
 Changes to squid-3.1.19 (06 Feb 2011):
 
 	- Regression Bug 3441: part 2: Prevent further cache size corruption of swap.state
@@ -72,3 +72,25 @@ regex_t t; regcomp(&t,"",0);]])],
     [ squid_cv_regex_works=no ])
   ])
 ])
+
+
+AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
+  AC_CACHE_CHECK([for libIpHlpApi],squid_cv_have_libiphlpapi,[
+    SQUID_STATE_SAVE(iphlpapi)
+    LIBS="$LIBS -liphlpapi"
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <windows.h>
+#include <winsock2.h>
+#include <iphlpapi.h>
+]], [[
+  MIB_IPNETTABLE i;
+  unsigned long isz=sizeof(i);
+  GetIpNetTable(&i,&isz,FALSE);
+    ]])],
+    [squid_cv_have_libiphlpapi=yes
+     SQUID_STATE_COMMIT(iphlpapi)],
+    [squid_cv_have_libiphlpapi=no
+     SQUID_STATE_ROLLBACK(iphlpapi)])
+  ])
+  SQUID_STATE_ROLLBACK(iphlpapi)
+])
@@ -41,7 +41,7 @@ $1_LIBS="${LIBS}"
 $1_CC="${CC}"
 $1_CXX="${CXX}"
 $1_squid_saved_vars="$2"
-for squid_util_var_tosave in $2
+for squid_util_var_tosave in $$1_squid_saved_vars
 do
     squid_util_var_tosave2="$1_${squid_util_var_tosave}"
     eval "${squid_util_var_tosave2}=\"${squid_util_var_tosave}\""
@@ -13,6 +13,7 @@ noinst_LIBRARIES = libcompat-squid.a
 libcompat_squid_a_SOURCES = \
 	assert.cc \
 	assert.h \
+	cmsg.h \
 	compat.cc \
 	compat.h \
 	compat_shared.h \
@@ -0,0 +1,18 @@
+#ifndef SQUID_COMPAT_CMSG_H
+#define SQUID_COMPAT_CMSG_H
+
+// CMSG_SPACE is not constant on some systems (in particular Max OS X),
+// provide a replacement that can be used at build time in that case
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#if HAVE_CONSTANT_CMSG_SPACE
+#define SQUID_CMSG_SPACE CMSG_SPACE
+#else
+// add 16 bytes for header and data alignment
+#define SQUID_CMSG_SPACE(len) (sizeof(struct cmsghdr) + (len) + 16)
+#endif
+
+#endif /* SQUID_COMPAT_CMSG_H */
@@ -18,5 +18,7 @@
 //#define s6_addr16 __u6_addr.__u6_addr16
 #define s6_addr32 __u6_addr.__u6_addr32
 
+#include "compat/cmsg.h"
+
 #endif /* _SQUID_APPLE_ */
 #endif /* SQUID_OS_MACOSX_H */
@@ -122,6 +122,21 @@
 #endif
 #endif
 
+#ifndef PRIuSIZE
+// NP: configure checks for support of %zu and defines where possible
+#if SIZEOF_SIZE_T == 4 && _SQUID_MINGW_
+#define PRIuSIZE "I32u"
+#elif SIZEOF_SIZE_T == 4
+#define PRIuSIZE "u"
+#elif SIZEOF_SIZE_T == 8 && _SQUID_MINGW_
+#define PRIuSIZE "I64u"
+#elif SIZEOF_SIZE_T == 8
+#define PRIuSIZE "lu"
+#else
+#error size_t is not 32-bit or 64-bit
+#endif
+#endif /* PRIuSIZE */
+
 #ifndef HAVE_MODE_T
 typedef unsigned short mode_t;
 #endif
@@ -543,11 +543,18 @@ for module in $squid_disk_module_candidates none; do
   fi
   case "$module" in
     DiskDaemon)
-      AC_MSG_NOTICE([Enabling DiskDaemon DiskIO module])
-      DISK_LIBS="$DISK_LIBS libDiskDaemon.a"
-      DISK_MODULES="$DISK_MODULES DiskDaemon"
-      DISK_PROGRAMS="$DISK_PROGRAMS DiskIO/DiskDaemon/diskd"
-      DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/DiskDaemon/DiskDaemonDiskIOModule.o"
+      case "$squid_host_os" in
+        mingw)
+          AC_MSG_NOTICE(["DiskDaemon not supported on MinGW"])
+          ;;
+        *)
+          AC_MSG_NOTICE([Enabling DiskDaemon DiskIO module])
+          DISK_LIBS="$DISK_LIBS libDiskDaemon.a"
+          DISK_MODULES="$DISK_MODULES DiskDaemon"
+          DISK_PROGRAMS="$DISK_PROGRAMS DiskIO/DiskDaemon/diskd"
+          DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/DiskDaemon/DiskDaemonDiskIOModule.o"
+          ;;
+        esac
       ;;
     DiskThreads)
       squid_opt_use_diskthreads="yes"
@@ -1033,13 +1040,15 @@ dnl   fi
 dnl ])
 
 
+test "x$squid_host_os" = "xmingw" && enable_wccp=no
 AC_ARG_ENABLE(wccp,
   AS_HELP_STRING([--disable-wccp],[Disable Web Cache Coordination Protocol]), [
 SQUID_YESNO([$enableval],[unrecognized argument to --disable-wccp: $enableval])
 ])
 SQUID_DEFINE_BOOL(USE_WCCP, ${enable_wccp:=yes}, [Define to enable WCCP])
 AC_MSG_NOTICE([Web Cache Coordination Protocol enabled: $enable_wccp])
 
+test "x$squid_host_os" = "xmingw" && enable_wccpv2=no
 AC_ARG_ENABLE(wccpv2,
   AS_HELP_STRING([--disable-wccpv2],
                  [Disable Web Cache Coordination V2 Protocol]), [ 
@@ -1135,6 +1144,7 @@ if test "x${enable_eui:=yes}" = "xyes" ; then
 #endif
   ]])
 fi
+AC_SUBST(EUILIB)
 AC_MSG_NOTICE([EUI (MAC address) controls enabled: $enable_eui])
 SQUID_DEFINE_BOOL(USE_SQUID_EUI,$enable_eui,
    [Define this to include code which lets you use ethernet addresses. This code uses API initially defined in 4.4-BSD.])
@@ -2505,6 +2515,8 @@ AC_CHECK_TYPE([bool])
 #need the defines for PRId64
 AC_CHECK_SIZEOF(int64_t)
 AC_CHECK_SIZEOF(long)
+#need the defines for PRIuSIZE
+AC_CHECK_SIZEOF(size_t)
 #need the define for overflow checks
 AC_CHECK_SIZEOF(off_t)
 AC_CHECK_SIZEOF(size_t)
@@ -2540,6 +2552,17 @@ AC_CHECK_TYPE(mtyp_t,AC_DEFINE(HAVE_MTYP_T,1,
 #include <sys/ipc.h>
 #include <sys/msg.h>])
 
+# check for compiler support of %zu printf macro
+AH_TEMPLATE(PRIuSIZE,[Compiler supports %zu printf macro])
+AC_MSG_CHECKING([for compiler %zu support])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <stdio.h>
+  ]],[[size_t n=1;printf("%zu",n);]])],[
+    AC_DEFINE(PRIuSIZE,"zu")
+    AC_MSG_RESULT(yes)
+  ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
+
+
 dnl Check for special functions
 AC_FUNC_ALLOCA
 
@@ -3241,6 +3264,20 @@ if test "x$squid_cv_resuid_works" = "xyes" ; then
   AC_DEFINE(HAVE_SETRESUID,1,[Yay! Another Linux brokenness. Knowing that setresuid() exists is not enough, because RedHat 5.0 declares setresuid() but does not implement it.])
 fi
 
+AC_MSG_CHECKING([for constant CMSG_SPACE])
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+
+  int a[CMSG_SPACE(int)];
+]])], [
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(HAVE_CONSTANT_CMSG_SPACE, 1, [Define to 1 if CMSG_SPACE is constant])
+], [
+  AC_MSG_RESULT(no)
+])
+
 SQUID_CHECK_FUNC_STRNSTR
 SQUID_CHECK_FUNC_VACOPY
 SQUID_CHECK_FUNC___VACOPY
@@ -3558,6 +3595,7 @@ AC_CONFIG_FILES([\
 	helpers/external_acl/LDAP_group/Makefile \
 	helpers/external_acl/LM_group/Makefile \
 	helpers/external_acl/session/Makefile \
+	helpers/external_acl/SQL_session/Makefile \
 	helpers/external_acl/unix_group/Makefile \
 	helpers/external_acl/wbinfo_group/Makefile \
 	helpers/external_acl/time_quota/Makefile \
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.19 release notes</title>
+<title>Squid 3.1.20 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.19
+The Squid Team are pleased to announce the release of Squid-3.1.20
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -1,17 +1,18 @@
+# Arthur Tumanyan <arthurtumanyan@yahoo.com>, 2012.
 msgid ""
 msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2011-07-19 10:53+0200\n"
-"Last-Translator: Arthur <arthurtumanyan@yahoo.com>\n"
-"Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
+"PO-Revision-Date: 2012-06-16 18:26+0400\n"
+"Last-Translator: Arthur Tumanyan <arthurtumanyan@yahoo.com>\n"
+"Language-Team: Arthur Tumanyan\n"
 "Language: hy\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Pootle 2.1.6\n"
+"X-Generator: Virtaal 0.6.1\n"
 
 #: templates/ERR_FTP_FAILURE+html.body.div.blockquote.pre:29
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.blockquote.pre:29
@@ -143,7 +144,7 @@ msgstr ""
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:31
 msgid "All configured parent caches may be currently unreachable."
-msgstr ""
+msgstr "Բոլոր ծնողական քեշերը կարող են զբաղված լինել այս պահին"
 
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:20
 msgid ""
@@ -171,6 +172,7 @@ msgid ""
 "An Internet connection needed to access this domains origin servers may be "
 "down."
 msgstr ""
+"Հնարավոր է, ելակետային սերվերներին միանալու համար անհրաժեշտ կապը խափանվել է"
 
 #: templates/ERR_READ_ERROR+html.body.div.p:28
 msgid ""
@@ -190,7 +192,7 @@ msgstr ""
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Application verification failure"
+msgstr "Կիրառության ստուգումը ձախողվեց"
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -200,23 +202,23 @@ msgstr "HTTP հարցումի նախապայմաններից առնվազն մե
 
 #: templates/error-details.txt+X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH.descr:125
 msgid "Authority and issuer serial number mismatch"
-msgstr "Authority and issuer serial number mismatch"
+msgstr "Սերիական համարների անհամապատասխանություն"
 
 #: templates/error-details.txt+X509_V_ERR_AKID_SKID_MISMATCH.descr:121
 msgid "Authority and subject key identifier mismatch"
-msgstr "Authority and subject key identifier mismatch"
+msgstr "Նույնականացուցիչի անհամապատասխանություն"
 
 #: templates/error-details.txt+X509_V_ERR_CRL_HAS_EXPIRED.descr:49
 msgid "CRL has expired"
-msgstr "CRL has expired"
+msgstr "CRL-ը սպառվել է"
 
 #: templates/error-details.txt+X509_V_ERR_CRL_NOT_YET_VALID.descr:45
 msgid "CRL is not yet valid"
-msgstr "CRL is not yet valid"
+msgstr "CRL -ը սխալ է"
 
 #: templates/error-details.txt+X509_V_ERR_CRL_SIGNATURE_FAILURE.descr:33
 msgid "CRL signature failure"
-msgstr "CRL signature failure"
+msgstr "CRL -ի ստորագրության սխալ"
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.blockquote.p:23
@@ -234,36 +236,35 @@ msgstr "Չհաջողվեց մշակել URN հարցումը"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_CHAIN_TOO_LONG.descr:89
 msgid "Certificate chain too long"
-msgstr "Certificate chain too long"
+msgstr "Սերտիֆիկատների շղթան շատ երկար է"
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.descr:5
-#, fuzzy
 msgid "Certificate does not match domainname"
-msgstr "Certificate is not yet valid"
+msgstr "Սերտիֆիկատը չի համապատասխանում դոմենին"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.descr:41
 msgid "Certificate has expired"
-msgstr "Certificate has expired"
+msgstr "Սերտիֆիկատի ժամկետը սպառվել է"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.descr:37
 msgid "Certificate is not yet valid"
-msgstr "Certificate is not yet valid"
+msgstr "Սերտիֆիկատը սխալ է"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_UNTRUSTED.descr:109
 msgid "Certificate not trusted"
-msgstr "Certificate not trusted"
+msgstr "Սերտիֆիկատը անվստահելի է"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REJECTED.descr:113
 msgid "Certificate rejected"
-msgstr "Certificate rejected"
+msgstr "Սերտիֆիկատը մերժվել է"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_REVOKED.descr:93
 msgid "Certificate revoked"
-msgstr "Certificate revoked"
+msgstr "Սերտիֆիկատը չեղյալ է համարվել"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_SIGNATURE_FAILURE.descr:29
 msgid "Certificate signature failure"
-msgstr "Certificate signature failure"
+msgstr "Սերտիֆիկատի ստորագրության սխալ"
 
 #: templates/ERR_LIFETIME_EXP+html.body.div.blockquote.p:23
 msgid "Connection Lifetime Expired"
@@ -431,19 +432,19 @@ msgstr "Opera բրաուզերի համար այցելեք: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
-msgstr "Format error in CRL's lastUpdate field"
+msgstr "Ֆորմատավորման սխալ CRL -ի lastUpdate դաշտում"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD.descr:65
 msgid "Format error in CRL's nextUpdate field"
-msgstr "Format error in CRL's nextUpdate field"
+msgstr "Ֆորմատավորման սխալ CRL -ի nextUpdate դաշտում"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Format error in certificate's notAfter field"
+msgstr "Ֆորմատավորման սխալ սերտիֆիկատի notAfter դաշտում"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
-msgstr "Format error in certificate's notBefore field"
+msgstr "Ֆորմատավորման սխալ սերտիֆիկատի notBefore դաշտում"
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.blockquote.p:23
 msgid "Forwarding Denied."
@@ -506,7 +507,7 @@ msgstr ""
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.descr:1
 msgid "Handshake with SSL server failed"
-msgstr ""
+msgstr "SSL սերվերի հետ կապի հաստատումը ձախողվեց"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:26
 msgid "Hey, don't expect too much from URNs on %T :)"
@@ -558,7 +559,7 @@ msgstr "Սխալ URL"
 
 #: templates/error-details.txt+X509_V_ERR_KEYUSAGE_NO_CERTSIGN.descr:129
 msgid "Key usage does not include certificate signing"
-msgstr "Key usage does not include certificate signing"
+msgstr "Բանալու կիրառումը չի ներառում սերտիֆիկատի ստորագրությունը"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:30
 msgid "Missing HTTP Identifier (HTTP/1.0)."
@@ -594,11 +595,11 @@ msgstr "Գործողությունը հաջողվեց"
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.descr:69
 msgid "Out of memory"
-msgstr "Out of memory"
+msgstr "Անբավարար հիշողություն"
 
 #: templates/error-details.txt+X509_V_ERR_PATH_LENGTH_EXCEEDED.descr:101
 msgid "Path length constraint exceeded"
-msgstr "Path length constraint exceeded"
+msgstr "Path -ի երկարությունը գերազանցված է"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:28
 msgid ""
@@ -639,33 +640,30 @@ msgstr "Հարցման ծավալը շատ մեծ է"
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
 msgid "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
-msgstr "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
+msgstr "SSL սերտիֆիկատի սխալ: սերտիֆիկատի թողարկողն (CA) անհայտ է: %ssl_ca_name"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.detail:37
 msgid "SSL Certficate is not valid before: %ssl_notbefore"
-msgstr "SSL Certficate is not valid before: %ssl_notbefore"
+msgstr "SSL սերտիֆիկատը վավեր չէ մինչև: %ssl_notbefore"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.detail:41
 msgid "SSL Certificate expired on: %ssl_notafter"
-msgstr "SSL Certificate expired on: %ssl_notafter"
+msgstr "SSL սերտիֆիկատը սպառման ժամկետն է: %ssl_notafter"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.detail:57
 msgid ""
 "SSL Certificate has invalid expiration date (the 'not after' field): "
 "%ssl_subject"
-msgstr ""
-"SSL Certificate has invalid expiration date (the 'not after' field): "
-"%ssl_subject"
+msgstr "SSL սերտիֆիկատի սպառման ժամկետը սխալ է ('not after' դաշտ): %ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.detail:53
 msgid ""
 "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
-msgstr ""
-"SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
+msgstr "SSL սերտիֆիկատի ամսաթիվը սխալ է ('not before'): %ssl_subject"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
 msgid "Select Auto-detect proxy settings for this network"
-msgstr "Ընտրեք Automatically detect settings"
+msgstr "Ընտրեք Auto-detect proxy settings for this network"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
@@ -677,23 +675,23 @@ msgstr "Ընտրեք Use Automatic proxy configuration"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Self signed certificate"
+msgstr "Ինքնագիր սերտիֆիկատ"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Self signed certificate in certificate chain"
+msgstr "Ինքնագիր սերտիֆիկատ սերտիֆիկատների շղթայում"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Self-signed SSL Certificate in chain: %ssl_subject"
+msgstr "Ինքնագիր սերտիֆիկատ սերտիֆիկատների շղթայում: %ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Self-signed SSL Certificate: %ssl_subject"
+msgstr "Ինքնագիր սերտիֆիկատ: %ssl_subject"
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 msgid "Socket Failure"
-msgstr "Socket ձախողում"
+msgstr "Socket -ի ձախողում"
 
 #: templates/ERR_INVALID_URL+html.body.div.p:26
 msgid "Some aspect of the requested URL is incorrect."
@@ -793,12 +791,12 @@ msgstr "ICAP սերվերը անհասանելի է:"
 msgid ""
 "The administrator may not allow this cache to make direct connections to "
 "origin servers."
-msgstr ""
+msgstr "Կառավարիչը կարող է արգելել ուղիղ կապ հաստատել ելակետային սերվերների հետ"
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.ul.li:30
 msgid ""
 "The domain may have moved very recently. Trying again will resolve that."
-msgstr ""
+msgstr "Հնարավոր է, դոմենը տեղափոխվել է․ Կրկին փորձեք"
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:20
 msgid "The following URL could not be retrieved: <a href=\"%U\">%U</a>"
@@ -908,7 +906,7 @@ msgstr "Ստացված պատասխանը: <i>%E</i>"
 msgid ""
 "The website may require you to use a local country-based version. Using your "
 "ISP provided DNS server(s) should resolve that."
-msgstr ""
+msgstr "Օգտագործեք Ձեր պրովայդերի տրամադրած DNS սերվերները"
 
 #: templates/ERR_NO_RELAY+html.body.div.p:26
 msgid ""
@@ -929,8 +927,8 @@ msgstr ""
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.p:26
 msgid "This Squid does not accept the HTTP version you are attempting to use."
 msgstr ""
-"HTTP արձանագրության այն տեսակը,որը Դուք փորձում եք օգտագործել,այս Squid-ը չի "
-"ընդունում:"
+"HTTP արձանագրության այն տեսակը, որը Դուք փորձում եք օգտագործել,այս Squid-ը "
+"չի ընդունում:"
 
 #: templates/ERR_FTP_DISABLED+html.body.div.p:26
 msgid "This cache does not support FTP."
@@ -996,6 +994,7 @@ msgid ""
 "This means the domain name you are trying to access apparently no longer "
 "exists on the machine you are requesting it from."
 msgstr ""
+"Սա նշանակում է, որ դոմեյնը ,որին փորձում եք կապվել, այլևս գոյություն չունի"
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.p:26
 msgid "This means:"
@@ -1031,7 +1030,7 @@ msgstr ""
 msgid ""
 "This request could not be forwarded to the origin server or to any parent "
 "caches."
-msgstr ""
+msgstr "Հարցումը չի կարող վերահասցեագրվել որևէ ծնողական քեշի"
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.blockquote.p:23
 msgid "Time Quota Exceeded."
@@ -1063,23 +1062,23 @@ msgstr ""
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.blockquote.pre:23
 msgid "URI Host Conflict"
-msgstr ""
+msgstr "URI հանգույցի կոնֆլիկտ"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.detail:25
 msgid "Unable to decode issuer (CA) public key: %ssl_ca_name"
-msgstr "Unable to decode issuer (CA) public key: %ssl_ca_name"
+msgstr "Անհնար է դեկոդավորել թողարկողի (CA) հանրային բանալին: %ssl_ca_name"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.descr:25
 msgid "Unable to decode issuer public key"
-msgstr "Unable to decode issuer public key"
+msgstr "Անհնար է դեկոդավորել թողարկողի հանրային բանալին"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE.descr:21
 msgid "Unable to decrypt CRL's signature"
-msgstr "Unable to decrypt CRL's signature"
+msgstr "Անհնար է CRL -ի ստորագրությունը վերծանել"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE.descr:17
 msgid "Unable to decrypt certificate's signature"
-msgstr "Unable to decrypt certificate's signature"
+msgstr "Անհնար է սերտիֆիկատի ստորագրությունը վերծանել"
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
@@ -1091,19 +1090,19 @@ msgstr "Ձեր հարցումը հնարավոր չէ վերահասցեագրե
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
-msgstr "Unable to get certificate CRL"
+msgstr "Անհնար է ստանալ սերտիֆիկատի CRL -ը"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.descr:9
 msgid "Unable to get issuer certificate"
-msgstr "Unable to get issuer certificate"
+msgstr "Անհնար է ստաալ թողարկողի սերտիֆիկատը"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.descr:81
 msgid "Unable to get local issuer certificate"
-msgstr "Unable to get local issuer certificate"
+msgstr "Անհնար է ստանալ լոկալ թողարկողի սերտիֆիկատը "
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE.descr:85
 msgid "Unable to verify the first certificate"
-msgstr "Unable to verify the first certificate"
+msgstr "Անհնար է ստուգել առաջին սերտիֆիկատը"
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
@@ -1116,7 +1115,7 @@ msgstr "Հարցում իրականացնելու մեթոդը և արձանագ
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
-msgstr "Unsupported certificate purpose"
+msgstr "Սերտիֆիկատի նպատակը թույլատրված չէ"
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
 msgid ""
@@ -6,6 +6,7 @@ DIST_SUBDIRS= \
 	LDAP_group \
 	LM_group \
 	session \
+	SQL_session \
 	time_quota \
 	unix_group \
 	wbinfo_group
@@ -0,0 +1,15 @@
+include $(top_srcdir)/src/Common.am
+
+libexec_SCRIPTS	= ext_sql_session_acl
+CLEANFILES += ext_sql_session_acl ext_sql_session_acl.8
+man_MANS = ext_sql_session_acl.8
+EXTRA_DIST= \
+	ext_sql_session_acl.8 \
+	ext_sql_session_acl.pl.in \
+	config.test
+
+ext_sql_session_acl.8: ext_sql_session_acl
+	pod2man ext_sql_session_acl ext_sql_session_acl.8
+
+ext_sql_session_acl: ext_sql_session_acl.pl.in
+	$(subst_perlshell)
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+## Test: do we have perl to build the helper scripts?
+## Test: do we have pod2man to build the manual?
+perl --version >/dev/null && echo | pod2man >/dev/null
+
+exit $?
@@ -0,0 +1,177 @@
+#!@PERL@
+use strict;
+use DBI;
+use Getopt::Long;
+use Pod::Usage;
+$|=1;
+
+=pod
+
+=head1 NAME
+
+ext_sql_session_acl.pl - SQL Database session lookup helper for Squid
+
+=cut
+
+my $dsn = "DBI:mysql:database=squid";
+my $db_user = undef;
+my $db_passwd = undef;
+my $db_table = "passwd";
+my $db_uidcol = "id";
+my $db_usercol = "''";
+my $db_tagcol = "''";
+my $db_cond = "enabled = 1";
+my $persist = 0;
+my $debug = 0;
+
+=pod
+
+=head1 SYNOPSIS
+
+ext_sql_session_acl [options]
+
+=head1 DESCRIPTION
+
+Validates an HTTP requests access authorization with a session database.
+
+Taking an identity token to be validated (as determined by the external_acl_type format)
+it returns a username or tag associated with the identity token passed in.
+
+Common forms of identifiers are IP address, EUI (MAC) address, passwords, or UUID tokens.
+
+This program uses Squid concurrency support.
+
+=over 8
+
+=item	B<--dsn>
+
+Database DSN. Default "DBI:mysql:database=squid"
+
+=item	B<--user>
+
+Database User
+
+=item	B<--password>
+
+Database password
+
+=item	B<--table>
+
+Database table. Default "passwd".
+
+=item	B<--uidcol>
+
+Unique Session Identifier column. Default "id".
+
+=item	B<--usercol>
+
+External ACL user= result column.
+
+=item	B<--tagcol>
+
+External ACL tag= result column.
+
+=item	B<--cond>
+
+Condition, defaults to enabled=1. Specify 1 or "" for no condition
+
+=item	B<--persist>
+
+Keep a persistent database connection open between queries. 
+
+=item	B<--debug>
+
+Print Debug output traces to stderr.
+
+=back
+
+=cut
+
+GetOptions(
+	'dsn=s' => \$dsn,
+	'user=s' => \$db_user,
+	'password=s' => \$db_passwd,
+	'table=s' => \$db_table,
+	'uidcol=s' => \$db_uidcol,
+	'usercol=s' => \$db_usercol,
+	'tagcol=s' => \$db_tagcol,
+	'cond=s' => \$db_cond,
+	'persist' => \$persist,
+	'debug' => \$debug,
+	);
+
+my ($_dbh, $_sth);
+
+sub close_db()
+{
+    return if !defined($_dbh);
+    undef $_sth;
+    $_dbh->disconnect();
+    undef $_dbh;
+}
+
+sub open_db()
+{
+    return $_sth if defined $_sth;
+    $_dbh = DBI->connect($dsn, $db_user, $db_passwd);
+    if (!defined $_dbh) {
+    	warn ("Could not connect to $dsn\n");
+	return undef;
+    }
+    $_sth = $_dbh->prepare("SELECT $db_usercol as 'user', $db_tagcol as 'tag' FROM $db_table WHERE ($db_uidcol = ?) " .
+                           ($db_cond ne "" ? " AND $db_cond" : "")) || die;
+
+    print(stderr "Query: SELECT $db_usercol as 'user', $db_tagcol as 'tag' FROM $db_table WHERE ($db_uidcol = ?) " .
+                           ($db_cond ne "" ? " AND $db_cond" : "")) if ($debug);
+
+    return $_sth;
+}
+
+sub query_db($) {
+    my $uid = @_[0];
+    my ($sth) = open_db() || return undef;
+    print(stderr "UID queried: '".$uid."'\n") if ($debug);
+    if (!$sth->execute($uid)) {
+	close_db();
+	open_db() || return undef;
+	$sth->execute($uid) || return undef;;
+    }
+    return $sth;
+}
+my $status;
+
+while (<>) {
+    my $string = $_;
+    $string =~ m/^(\d+)\s(.*)$/;
+    my ($cid, $uid) = ($1, $2);
+
+    $status = "ERR";
+    $cid =~ s/%(..)/pack("H*", $1)/ge;
+    $uid =~ s/%(..)/pack("H*", $2)/ge;
+
+    print(stderr "Received: Channel=".$cid.", UID='".$uid."'\n") if ($debug);
+
+    $status = $cid . " ERR database error";
+    my $sth = query_db($uid) || next;
+    print(stderr "Rows: ". $sth->rows()."\n") if ($debug);
+    $status = $cid . " ERR unknown UID '".$uid."'";
+    my $row = $sth->fetchrow_hashref() || next;
+    $status = $cid . " OK" . ($row->{'user'} ne "" ? " user=" . $row->{'user'} : "" ) . ($row->{'tag'} ne "" ? " tag=" . $row->{'tag'} : "" );
+    $sth->finish();
+} continue {
+    close_db() if (!$persist);
+    print $status . "\n";
+}
+
+=pod
+
+=head1 COPYRIGHT
+
+Copyright (C) 2012 Amos Jeffries <amosjeffries@squid-cache.org>
+Based on original work in DB_auth by Henrik Nordstrom <henrik@henriknordstrom.net>
+With assistance of Nishant Sharma <codemarauder@gmail.com>
+This program is free software. You may redistribute copies of it under the
+terms of the GNU General Public License version 2, or (at your opinion) any
+later version.
+
+=cut
@@ -242,7 +242,7 @@ local_printfx(const char *msg,...)
         *(dbuf) = '\0';
     } else {
         /* FAIL */
-        debug("local_printfx() FAILURE: %zd\n", x);
+        debug("local_printfx() FAILURE: %" PRIuSIZE "\n", x);
     }
 
     /* stdout needs to be flushed for it to work with Squid */
@@ -475,7 +475,7 @@ DisplayConf()
     DisplayVersion();
     local_printfx("\n");
     local_printfx("Configuration:\n");
-    local_printfx("	EDUI_MAXLEN: %zd\n", EDUI_MAXLEN);
+    local_printfx("	EDUI_MAXLEN: %u\n", EDUI_MAXLEN);
     if (edui_conf.mode & EDUI_MODE_DEBUG)
         local_printfx("	Debug mode: ON\n");
     else
@@ -1261,7 +1261,7 @@ SearchIPLDAP(edui_ldap_t *l)
                     memcpy(bufa, l->val[i]->bv_val, j);
                     z = BinarySplit(bufa, j, '#', bufb, sizeof(bufb));
                     /* BINARY DEBUGGING *
-                                        	  local_printfx("value[%zd]: BinarySplit(", (size_t) i);
+                                        	  local_printfx("value[%" PRIuSIZE "]: BinarySplit(", (size_t) i);
                                         	  for (k = 0; k < z; k++) {
                                         	    c = (int) bufb[k];
                                         	    if (c < 0)
@@ -1275,7 +1275,7 @@ SearchIPLDAP(edui_ldap_t *l)
                                         	      c = c + 256;
                                         	    local_printfx("%02X", c);
                                         	  }
-                                        	  local_printfx("): %zd\n", (size_t) z);
+                                        	  local_printfx("): %" PRIuSIZE "\n", (size_t) z);
                     * BINARY DEBUGGING */
                     z = j - z - 1;
                     j = atoi(bufb);
@@ -1759,7 +1759,7 @@ MainSafe(int argc, char **argv)
             edui_elap = 0;
         k = strlen(bufa);
         /* BINARY DEBUGGING *
-                    local_printfx("while() -> bufa[%zd]: %s", k, bufa);
+                    local_printfx("while() -> bufa[%" PRIuSIZE "]: %s", k, bufa);
                     for (i = 0; i < k; i++)
                       local_printfx("%02X", bufa[i]);
                     local_printfx("\n");
@@ -1866,10 +1866,10 @@ MainSafe(int argc, char **argv)
         /* If we got a group string, split it */
         if (p != NULL) {
             /* Split string */
-            debug("StringSplit(%s, ' ', %s, %zd)\n", bufa, bufb, sizeof(bufb));
+            debug("StringSplit(%s, ' ', %s, %" PRIuSIZE ")\n", bufa, bufb, sizeof(bufb));
             i = StringSplit(bufa, ' ', bufb, sizeof(bufb));
             if (i > 0) {
-                debug("StringSplit(%s, %s) done.  Result: %zd\n", bufa, bufb, i);
+                debug("StringSplit(%s, %s) done.  Result: %" PRIuSIZE "\n", bufa, bufb, i);
                 /* Got a group to match against */
                 x = ConvertIP(&edui_ldap, bufb);
                 if (x < 0) {
@@ -1907,8 +1907,8 @@ MainSafe(int argc, char **argv)
                     }
                 }
             } else {
-                debug("StringSplit() -> Error: %zu\n", i);
-                local_printfx("ERR (StringSplit Error %d)\n", i);
+                debug("StringSplit() -> Error: %" PRIuSIZE "\n", i);
+                local_printfx("ERR (StringSplit Error %" PRIuSIZE ")\n", i);
             }
         } else {
             /* No group to match against, only an IP */
@@ -46,7 +46,6 @@
 
 SQUIDCEXTERN int tvSubUsec(struct timeval, struct timeval);
 SQUIDCEXTERN double tvSubDsec(struct timeval, struct timeval);
-SQUIDCEXTERN size_t xcountws(const char *str);
 SQUIDCEXTERN void Tolower(char *);
 #if defined(__cplusplus)
 /*
@@ -57,7 +56,7 @@ SQUIDCEXTERN void Tolower(char *);
  * for the extern version in squid
  */
 #if !defined(_SQUID_EXTERNNEW_)
-#if defined(__GNUC_STDC_INLINE__)
+#if defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__)
 #define _SQUID_EXTERNNEW_ extern inline __attribute__((gnu_inline))
 #else
 #define _SQUID_EXTERNNEW_ extern inline
@@ -50,7 +50,7 @@ libmiscencoding_la_SOURCES = \
 	uudecode.c
 
 libmisccontainers_la_SOURCES = \
-	hash.c
+	hash.cc
 
 libmiscutil_la_SOURCES = \
 	malloc_trace.cc \
@@ -66,13 +66,13 @@ static void hash_next_bucket(hash_table * hid);
 unsigned int
 hash_string(const void *data, unsigned int size)
 {
-    const char *s = data;
+    const unsigned char *s = static_cast<const unsigned char *>(data);
     unsigned int n = 0;
     unsigned int j = 0;
     unsigned int i = 0;
     while (*s) {
         j++;
-        n ^= 271 * (unsigned) *s++;
+        n ^= 271 * (*s++);
     }
     i = n ^ (j * 271);
     return i % size;
@@ -85,7 +85,7 @@ hash_string(const void *data, unsigned int size)
 unsigned int
 hash4(const void *data, unsigned int size)
 {
-    const char *key = data;
+    const char *key = static_cast<const char *>(data);
     size_t loop;
     unsigned int h;
     size_t len;
@@ -134,29 +134,29 @@ hash4(const void *data, unsigned int size)
     return h % size;
 }
 
-/*
+/**
  *  hash_create - creates a new hash table, uses the cmp_func
  *  to compare keys.  Returns the identification for the hash table;
  *  otherwise returns a negative number on error.
  */
 hash_table *
 hash_create(HASHCMP * cmp_func, int hash_sz, HASHHASH * hash_func)
 {
-    hash_table *hid = xcalloc(1, sizeof(hash_table));
+    hash_table *hid = (hash_table *)xcalloc(1, sizeof(hash_table));
     if (!hash_sz)
         hid->size = (unsigned int) DEFAULT_HASH_SIZE;
     else
         hid->size = (unsigned int) hash_sz;
     /* allocate and null the buckets */
-    hid->buckets = xcalloc(hid->size, sizeof(hash_link *));
+    hid->buckets = (hash_link **)xcalloc(hid->size, sizeof(hash_link *));
     hid->cmp = cmp_func;
     hid->hash = hash_func;
     hid->next = NULL;
     hid->current_slot = 0;
     return hid;
 }
 
-/*
+/**
  *  hash_join - joins a hash_link under its key lnk->key
  *  into the hash table 'hid'.
  *
@@ -172,20 +172,19 @@ hash_join(hash_table * hid, hash_link * lnk)
     hid->count++;
 }
 
-/*
+/**
  *  hash_lookup - locates the item under the key 'k' in the hash table
  *  'hid'.  Returns a pointer to the hash bucket on success; otherwise
  *  returns NULL.
  */
 hash_link *
 hash_lookup(hash_table * hid, const void *k)
 {
-    hash_link *walker;
     int b;
     PROF_start(hash_lookup);
     assert(k != NULL);
     b = hid->hash(k, hid->size);
-    for (walker = hid->buckets[b]; walker != NULL; walker = walker->next) {
+    for (hash_link *walker = hid->buckets[b]; walker != NULL; walker = walker->next) {
         if ((hid->cmp) (k, walker->key) == 0) {
             PROF_stop(hash_lookup);
             return (walker);
@@ -203,7 +202,7 @@ hash_next_bucket(hash_table * hid)
         hid->next = hid->buckets[hid->current_slot];
 }
 
-/*
+/**
  *  hash_first - initializes the hash table for the hash_next()
  *  function.
  */
@@ -217,7 +216,7 @@ hash_first(hash_table * hid)
         hash_next_bucket(hid);
 }
 
-/*
+/**
  *  hash_next - returns the next item in the hash table 'hid'.
  *  Otherwise, returns NULL on error or end of list.
  *
@@ -226,16 +225,16 @@ hash_first(hash_table * hid)
 hash_link *
 hash_next(hash_table * hid)
 {
-    hash_link *this = hid->next;
-    if (NULL == this)
+    hash_link *p = hid->next;
+    if (NULL == p)
         return NULL;
-    hid->next = this->next;
+    hid->next = p->next;
     if (NULL == hid->next)
         hash_next_bucket(hid);
-    return this;
+    return p;
 }
 
-/*
+/**
  *  hash_last - resets hash traversal state to NULL
  *
  */
@@ -247,7 +246,7 @@ hash_last(hash_table * hid)
     hid->current_slot = 0;
 }
 
-/*
+/**
  *  hash_remove_link - deletes the given hash_link node from the
  *  hash table 'hid'.  Does not free the item, only removes it
  *  from the list.
@@ -258,11 +257,9 @@ hash_last(hash_table * hid)
 void
 hash_remove_link(hash_table * hid, hash_link * hl)
 {
-    hash_link **P;
-    int i;
     assert(hl != NULL);
-    i = hid->hash(hl->key, hid->size);
-    for (P = &hid->buckets[i]; *P; P = &(*P)->next) {
+    int i = hid->hash(hl->key, hid->size);
+    for (hash_link **P = &hid->buckets[i]; *P; P = &(*P)->next) {
         if (*P != hl)
             continue;
         *P = hl->next;
@@ -277,7 +274,7 @@ hash_remove_link(hash_table * hid, hash_link * hl)
     assert(0);
 }
 
-/*
+/**
  *  hash_get_bucket - returns the head item of the bucket
  *  in the hash table 'hid'. Otherwise, returns NULL on error.
  */
@@ -293,16 +290,14 @@ void
 hashFreeItems(hash_table * hid, HASHFREE * free_func)
 {
     hash_link *l;
-    hash_link **list;
     int i = 0;
-    int j;
-    list = xcalloc(hid->count, sizeof(hash_link *));
+    hash_link **list = (hash_link **)xcalloc(hid->count, sizeof(hash_link *));
     hash_first(hid);
     while ((l = hash_next(hid)) && i < hid->count) {
         *(list + i) = l;
         i++;
     }
-    for (j = 0; j < i; j++)
+    for (int j = 0; j < i; j++)
         free_func(*(list + j));
     xfree(list);
 }
@@ -336,11 +331,10 @@ int
 hashPrime(int n)
 {
     int I = sizeof(hash_primes) / sizeof(int);
-    int i;
     int best_prime = hash_primes[0];
     double min = fabs(log((double) n) - log((double) hash_primes[0]));
     double d;
-    for (i = 0; i < I; i++) {
+    for (int i = 0; i < I; i++) {
         d = fabs(log((double) n) - log((double) hash_primes[i]));
         if (d > min)
             continue;
@@ -350,7 +344,7 @@ hashPrime(int n)
     return best_prime;
 }
 
-/*
+/**
  * return the key of a hash_link as a const string
  */
 const char *
@@ -361,7 +355,7 @@ hashKeyStr(hash_link * hl)
 
 
 #if USE_HASH_DRIVER
-/*
+/**
  *  hash-driver - Run with a big file as stdin to insert each line into the
  *  hash table, then prints the whole hash table, then deletes a random item,
  *  and prints the table again...
@@ -370,7 +364,6 @@ int
 main(void)
 {
     hash_table *hid;
-    int i;
     LOCAL_ARRAY(char, buf, BUFSIZ);
     LOCAL_ARRAY(char, todelete, BUFSIZ);
     hash_link *walker = NULL;
@@ -395,7 +388,7 @@ main(void)
     }
 
     printf("walking hash table...\n");
-    for (i = 0, walker = hash_first(hid); walker; walker = hash_next(hid)) {
+    for (int i = 0, walker = hash_first(hid); walker; walker = hash_next(hid)) {
         printf("item %5d: key: '%s' item: %p\n", i++, walker->key,
                walker->item);
     }
@@ -407,7 +400,7 @@ main(void)
             printf("hash_delete error\n");
     }
     printf("walking hash table...\n");
-    for (i = 0, walker = hash_first(hid); walker; walker = hash_next(hid)) {
+    for (int i = 0, walker = hash_first(hid); walker; walker = hash_next(hid)) {
         printf("item %5d: key: '%s' item: %p\n", i++, walker->key,
                walker->item);
     }
@@ -73,7 +73,6 @@ typedef enum {
     XPROF_storeWriteComplete,
     XPROF_write,
     XPROF_xcalloc,
-    XPROF_xcountws,
     XPROF_xmalloc,
     XPROF_xrealloc,
     XPROF_LAST
@@ -35,7 +35,6 @@
 #define _etext etext
 
 #include "squid.h"
-#include "profiler/Profiler.h"
 #include "util.h"
 
 #if HAVE_STDIO_H
@@ -79,24 +78,6 @@ tvSubDsec(struct timeval t1, struct timeval t2)
            (double) (t2.tv_usec - t1.tv_usec) / 1000000.0;
 }
 
-/* returns the number of leading white spaces in str; handy in skipping ws */
-size_t
-xcountws(const char *str)
-{
-    size_t count = 0;
-    PROF_start(xcountws);
-
-    if (str) {
-        while (xisspace(*str)) {
-            str++;
-            count++;
-        }
-    }
-
-    PROF_stop(xcountws);
-    return count;
-}
-
 /* somewhat safer calculation of %s */
 double
 xpercent(double part, double whole)
@@ -1,5 +1,4 @@
 #include "squid.h"
-#include "profiler/Profiler.h"
 #include "xusleep.h"
 
 #if HAVE_UNISTD_H
@@ -33,6 +33,7 @@
  */
 
 #include "squid.h"
+#include "squid-old.h"
 #include "comm/Loops.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 
@@ -698,16 +698,29 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 
 /* packs all the entries using supplied packer */
 void
-HttpHeader::packInto(Packer * p) const
+HttpHeader::packInto(Packer * p, bool mask_sensitive_info) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     const HttpHeaderEntry *e;
     assert(p);
     debugs(55, 7, "packing hdr: (" << this << ")");
     /* pack all entries one by one */
-    while ((e = getEntry(&pos)))
-        e->packInto(p);
-
+    while ((e = getEntry(&pos))) {
+        if (!mask_sensitive_info) {
+            e->packInto(p);
+            continue;
+        }
+        switch (e->id) {
+        case HDR_AUTHORIZATION:
+        case HDR_PROXY_AUTHORIZATION:
+            packerAppend(p, e->name.rawBuf(), e->name.size());
+            packerAppend(p, ": ** NOT DISPLAYED **\r\n", 23);
+            break;
+        default:
+            e->packInto(p);
+            break;
+        }
+    }
     /* Pack in the "special" entries */
 
     /* Cache-Control */
@@ -1420,7 +1433,7 @@ HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
         return NULL;
 
     /* skip white space */
-    field += xcountws(field);
+    for (; field && xisspace(*field); field++);
 
     if (!*field)		/* no authorization cookie */
         return NULL;
@@ -234,7 +234,7 @@ class HttpHeader
     void compact();
     int reset();
     int parse(const char *header_start, const char *header_end);
-    void packInto(Packer * p) const;
+    void packInto(Packer * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
     HttpHeaderEntry *findEntry(http_hdr_type id) const;
     int delByName(const char *name);
@@ -595,13 +595,6 @@ HttpReply::calcMaxBodySize(HttpRequest& request)
         return;
 
     ACLFilledChecklist ch(NULL, &request, NULL);
-#if FOLLOW_X_FORWARDED_FOR
-    if (Config.onoff.acl_uses_indirect_client)
-        ch.src_addr = request.indirect_client_addr;
-    else
-#endif
-        ch.src_addr = request.client_addr;
-    ch.my_addr = request.my_addr;
     ch.reply = HTTPMSGLOCK(this); // XXX: this lock makes method non-const
     for (acl_size_t *l = Config.ReplyBodySize; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this size value */
@@ -46,13 +46,17 @@ typedef enum {
     HTTP_UNPROCESSABLE_ENTITY = 422,    /**< RFC2518 section 10.3 */
     HTTP_LOCKED = 423,                  /**< RFC2518 section 10.4 */
     HTTP_FAILED_DEPENDENCY = 424,       /**< RFC2518 section 10.5 */
+    HTTP_PRECONDITION_REQUIRED = 428,   /**< RFC6585 */
+    HTTP_TOO_MANY_REQUESTS = 429,       /**< RFC6585 */
+    HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431, /**< RFC6585 */
     HTTP_INTERNAL_SERVER_ERROR = 500,
     HTTP_NOT_IMPLEMENTED = 501,
     HTTP_BAD_GATEWAY = 502,
     HTTP_SERVICE_UNAVAILABLE = 503,
     HTTP_GATEWAY_TIMEOUT = 504,
     HTTP_HTTP_VERSION_NOT_SUPPORTED = 505,
     HTTP_INSUFFICIENT_STORAGE = 507,    /**< RFC2518 section 10.6 */
+    HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511, /**< RFC6585 */
 
     // The 6xx codes below are for internal use only: Bad requests result
     // in HTTP_BAD_REQUEST; bad responses in HTTP_GATEWAY_TIMEOUT.
@@ -320,6 +320,23 @@ httpStatusString(http_status status)
         p = "HTTP Version not supported";
         break;
 
+        // RFC 6585
+    case HTTP_PRECONDITION_REQUIRED: // 428
+        p = "Precondition Required";
+        break;
+
+    case HTTP_TOO_MANY_REQUESTS: // 429
+        p = "Too Many Requests";
+        break;
+
+    case HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE: // 431
+        p = "Request Header Fields Too Large";
+        break;
+
+    case HTTP_NETWORK_AUTHENTICATION_REQUIRED: // 511
+        p = "Network Authentication Required";
+        break;
+
     default:
         p = "Unknown";
         debugs(57, 3, "Unknown HTTP status code: " << status);
@@ -171,7 +171,9 @@ AIO_WIN32_SOURCES =
 endif
 
 if USE_AIOPS_WIN32
-AIOPS_SOURCE = DiskIO/DiskThreads/aiops_win32.cc
+AIOPS_SOURCE = DiskIO/DiskThreads/aiops_win32.cc \
+	DiskIO/DiskThreads/CommIO.cc \
+	DiskIO/DiskThreads/CommIO.h
 else
 AIOPS_SOURCE = DiskIO/DiskThreads/aiops.cc \
 	DiskIO/DiskThreads/CommIO.cc \
@@ -635,7 +637,9 @@ unlinkd_LDADD = \
 
 ## dnsserver is a standalone helper. Do not link to any internal libraries
 dnsserver_SOURCES = dnsserver.cc
-dnsserver_LDADD = $(COMPAT_LIB)
+dnsserver_LDADD = \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
 
 recv_announce_SOURCES = recv-announce.cc
 
@@ -415,16 +415,17 @@ MemObject::isContiguous() const
 }
 
 int
-MemObject::mostBytesWanted(int max) const
+MemObject::mostBytesWanted(int max, bool ignoreDelayPools) const
 {
 #if USE_DELAY_POOLS
-    /* identify delay id with largest allowance */
-    DelayId largestAllowance = mostBytesAllowed ();
-    return largestAllowance.bytesWanted(0, max);
-#else
+    if (!ignoreDelayPools) {
+        /* identify delay id with largest allowance */
+        DelayId largestAllowance = mostBytesAllowed ();
+        return largestAllowance.bytesWanted(0, max);
+    }
+#endif
 
     return max;
-#endif
 }
 
 void
@@ -476,10 +477,6 @@ MemObject::mostBytesAllowed() const
 
 #endif
 
-        if (sc->getType() != STORE_MEM_CLIENT)
-            /* reading off disk */
-            continue;
-
         j = sc->delayId.bytesWanted(0, sc->copyInto.length);
 
         if (j > jmax) {
@@ -85,7 +85,7 @@ class MemObject
     void trimSwappable();
     void trimUnSwappable();
     bool isContiguous() const;
-    int mostBytesWanted(int max) const;
+    int mostBytesWanted(int max, bool ignoreDelayPools) const;
     void setNoDelay(bool const newValue);
 #if USE_DELAY_POOLS
     DelayId mostBytesAllowed() const;
@@ -734,7 +734,7 @@ ServerStateData::handleMoreAdaptedBodyAvailable()
     if (!contentSize)
         return; // XXX: bytesWanted asserts on zero-size ranges
 
-    const size_t spaceAvailable = entry->bytesWanted(Range<size_t>(0, contentSize));
+    const size_t spaceAvailable = entry->bytesWanted(Range<size_t>(0, contentSize), true);
 
     if (spaceAvailable < contentSize ) {
         // No or partial body data consuming
@@ -130,15 +130,18 @@ StatHist::operator =(const StatHist & src)
 {
     if (this==&src) //handle self-assignment
         return *this;
-    xfree(bins); // xfree can handle NULL pointers, no need to check
-    capacity_=src.capacity_;
-    bins = static_cast<bins_type *>(xcalloc(src.capacity_, sizeof(bins_type)));
+    if (capacity_ != src.capacity_) {
+        xfree(bins); // xfree can handle NULL pointers, no need to check
+        capacity_=src.capacity_;
+        bins = static_cast<bins_type *>(xcalloc(src.capacity_, sizeof(bins_type)));
+    }
     min_=src.min_;
     max_=src.max_;
     scale_=src.scale_;
     val_in=src.val_in;
     val_out=src.val_out;
-    memcpy(bins,src.bins,capacity_*sizeof(*bins));
+    if (bins != NULL)
+        memcpy(bins,src.bins,capacity_*sizeof(*bins));
     return *this;
 }
 
@@ -86,7 +86,7 @@ class StoreEntry : public hash_link
     virtual void write (StoreIOBuffer);
     virtual _SQUID_INLINE_ bool isEmpty() const;
     virtual bool isAccepting() const;
-    virtual size_t bytesWanted(Range<size_t> const) const;
+    virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const;
     virtual void complete();
     virtual store_client_t storeClientType() const;
     virtual char const *getSerialisedMetaData();
@@ -240,7 +240,7 @@ class NullStoreEntry:public StoreEntry
 
     bool isEmpty () const {return true;}
 
-    virtual size_t bytesWanted(Range<size_t> const aRange) const { return aRange.end; }
+    virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const { return aRange.end; }
 
     void operator delete(void *address);
     void complete() {}
@@ -323,7 +323,7 @@ ACLList::matches (ACLChecklist *checklist) const
 {
     assert (_acl);
     // XXX: AclMatchedName does not contain a matched ACL name when the acl
-    // does not match (or contains stale name if no ACLs are checked). In 
+    // does not match (or contains stale name if no ACLs are checked). In
     // either case, we get misleading debugging and possibly incorrect error
     // messages. Unfortunately, deny_info's "when none http_access
     // lines match" exception essentially requires this mess.
@@ -218,7 +218,7 @@ ACLChecklist::matchNodes(const ACLList * head, bool const fast)
 
         if (resultBeforeAsync == nmrMatch)
             continue;
-        
+
         if (resultBeforeAsync == nmrMismatch || resultBeforeAsync == nmrFinished)
             return false;
 
@@ -236,7 +236,7 @@ ACLChecklist::matchNodes(const ACLList * head, bool const fast)
         // This is inefficient and ugly, but fixing all match() code, including
         // the code it calls, such as ipcache_nbgethostbyname(), takes time.
         if (!asyncInProgress()) { // failed to start an async operation
-            
+
             if (finished()) {
                 debugs(28, 3, HERE << this << " finished after failing to go async: " << currentAnswer());
                 return false; // an exceptional case
@@ -294,7 +294,7 @@ ACLChecklist::matchNode(const ACLList &node, bool const fast)
         assert(!needsAsync);
         debugs(28, 3, HERE << this << " exception: " << currentAnswer());
         return nmrFinished;
-     }
+    }
 
     if (!needsAsync) {
         debugs(28, 3, HERE << this << " simple mismatch");
@@ -379,7 +379,7 @@ ACLChecklist::asyncState() const
 void
 ACLChecklist::nonBlockingCheck(ACLCB * callback_, void *callback_data_)
 {
-    preCheck("nonBlocking");
+    preCheck("slow rules");
     callback = callback_;
     callback_data = cbdataReference(callback_data_);
     matchNonBlocking();
@@ -390,13 +390,12 @@ ACLChecklist::fastCheck(const ACLList * list)
 {
     PROF_start(aclCheckFast);
 
-    preCheck("fast single-rule");
+    preCheck("fast ACLs");
 
     // assume DENY/ALLOW on mis/matches due to not having acl_access object
     if (matchAclList(list, true))
         markFinished(ACCESS_ALLOWED, "all ACLs matched");
-    else
-    if (!finished())
+    else if (!finished())
         markFinished(ACCESS_DENIED, "ACL mismatched");
     PROF_stop(aclCheckFast);
     return currentAnswer();
@@ -410,7 +409,7 @@ ACLChecklist::fastCheck()
 {
     PROF_start(aclCheckFast);
 
-    preCheck("fast multi-rule");
+    preCheck("fast rules");
 
     allow_t lastSeenKeyword = ACCESS_DUNNO;
     debugs(28, 5, "aclCheckFast: list: " << accessList);
@@ -442,7 +441,7 @@ ACLChecklist::fastCheck()
 }
 
 /// When no rules matched, the answer is the inversion of the last seen rule
-/// action (or ACCESS_DUNNO if the reversal is not possible). The caller 
+/// action (or ACCESS_DUNNO if the reversal is not possible). The caller
 /// should set lastSeenAction to ACCESS_DUNNO if there were no rules to see.
 void
 ACLChecklist::calcImplicitAnswer(const allow_t &lastSeenAction)
@@ -205,7 +205,7 @@ class ACLChecklist
 private: /* internal methods */
     /// possible outcomes when trying to match a single ACL node in a list
     typedef enum { nmrMatch, nmrMismatch, nmrFinished, nmrNeedsAsync }
-        NodeMatchingResult;
+    NodeMatchingResult;
 
     /// prepare for checking ACLs; called once per check
     void preCheck(const char *what);
@@ -162,6 +162,8 @@ Adaptation::Ecap::FirstLineRep::protocol() const
         return protocolInternal;
     case AnyP::PROTO_ICY:
         return protocolIcy;
+    case AnyP::PROTO_COAP:
+    case AnyP::PROTO_COAPS: // use 'unknown' until libecap supports coap:// and coaps://
     case AnyP::PROTO_UNKNOWN:
         return protocolUnknown; // until we remember the protocol image
     case AnyP::PROTO_NONE:
@@ -144,6 +144,9 @@ Adaptation::Ecap::XactionRep::usernameValue() const
     if (request->auth_user_request != NULL) {
         if (char const *name = request->auth_user_request->username())
             return libecap::Area::FromTempBuffer(name, strlen(name));
+        else if (request->extacl_user.defined() && request->extacl_user.size())
+            return libecap::Area::FromTempBuffer(request->extacl_user.rawBuf(),
+                                                 request->extacl_user.size());
     }
 #endif
     return libecap::Area();
@@ -1332,6 +1332,8 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     if (!TheConfig.reuse_connections)
         buf.Printf("Connection: close\r\n");
 
+    const HttpRequest *request = &virginRequest();
+
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
@@ -1342,10 +1344,14 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
         buf.Printf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
+    } else if (request->extacl_user.defined() && request->extacl_user.size() && request->extacl_passwd.defined() && request->extacl_passwd.size()) {
+        char loginbuf[256];
+        snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
+                 SQUIDSTRINGPRINT(request->extacl_user),
+                 SQUIDSTRINGPRINT(request->extacl_passwd));
+        buf.Printf("Proxy-Authorization: Basic %s\r\n", old_base64_encode(loginbuf));
     }
 
-    const HttpRequest *request = &virginRequest();
-
     // share the cross-transactional database records if needed
     if (Adaptation::Config::masterx_shared_name) {
         Adaptation::History::Pointer ah = request->adaptHistory(false);
@@ -1488,6 +1494,9 @@ void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, M
             const char *value = TheConfig.client_username_encode ? old_base64_encode(name) : name;
             buf.Printf("%s: %s\r\n", TheConfig.client_username_header, value);
         }
+    } else if (request->extacl_user.defined() && request->extacl_user.size()) {
+        const char *value = TheConfig.client_username_encode ? old_base64_encode(request->extacl_user.termedBuf()) : request->extacl_user.termedBuf();
+        buf.Printf("%s: %s\r\n", TheConfig.client_username_header, value);
     }
 #endif
 }
@@ -80,6 +80,7 @@ int
 ACLProxyAuth::match(ACLChecklist *checklist)
 {
     allow_t answer = AuthenticateAcl(checklist);
+
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:
@@ -185,6 +185,8 @@ authenticateDigestNonceNew(void)
     while ((temp = authenticateDigestNonceFindNonce((char const *) (newnonce->key)))) {
         /* create a new nonce */
         newnonce->noncedata.randomdata = squid_random();
+        /* Bug 3526 high performance fix: add 1 second to creationtime to avoid duplication */
+        newnonce->noncedata.creationtime++;
         authDigestNonceEncode(newnonce);
     }
 
@@ -3772,16 +3772,17 @@ add_http_port(char *portspec)
     parsePortSpecification(s, portspec);
     // we may need to merge better if the above returns a list with clones
     assert(s->next == NULL);
-    s->next = Config.Sockaddr.http;
-    Config.Sockaddr.http = s;
+    s->next = cbdataReference(Config.Sockaddr.http);
+    cbdataReferenceDone(Config.Sockaddr.http);
+    Config.Sockaddr.http = cbdataReference(s);
 }
 
 static void
 parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
 {
     const char *protocol = NULL;
     if (strcmp(optionName, "http_port") == 0 ||
-        strcmp(optionName, "ascii_port") == 0)
+            strcmp(optionName, "ascii_port") == 0)
         protocol = "http";
     else if (strcmp(optionName, "https_port") == 0)
         protocol = "https";
@@ -3822,15 +3823,15 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
 
     if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.IsAnyAddr()) {
         // clone the port options from *s to *(s->next)
-        s->next = s->clone();
+        s->next = cbdataReference(s->clone());
         s->next->s.SetIPv4();
         debugs(3, 3, protocol << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
 
     while (*head)
         head = &(*head)->next;
 
-    *head = s;
+    *head = cbdataReference(s);
 }
 
 static void
@@ -3973,7 +3974,7 @@ free_PortCfg(AnyP::PortCfg ** head)
 
     while ((s = *head) != NULL) {
         *head = s->next;
-        delete s;
+        cbdataReferenceDone(s);
     }
 }
 
@@ -2094,7 +2094,6 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
         return; /* already in good shape */
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
-    // BUG 2976: Squid only accepts intercepted HTTP.
 
     if ((host = mime_get_header(req_hdr, "Host")) != NULL) {
         int url_sz = strlen(url) + 32 + Config.appendDomainLen +
@@ -2106,7 +2105,7 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
         /* Put the local socket IP address as the hostname.  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
-        http->getConn()->clientConnection->local.ToHostname(ipbuf,MAX_IPSTRLEN),
+        http->getConn()->clientConnection->local.ToHostname(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
                  http->getConn()->port->protocol,
                  ipbuf, http->getConn()->clientConnection->local.GetPort(), url);
@@ -261,7 +261,7 @@ Comm::ConnOpener::connect()
             doneConnecting(COMM_TIMEOUT, errno);
         } else if (failRetries_ < Config.connect_retries) {
             debugs(5, 5, HERE << conn_ << ": * - try again");
-            eventAdd("Comm::ConnOpener::DelayedConnectRetry", Comm::ConnOpener::DelayedConnectRetry, new Pointer(this), 0.05, 0);
+            eventAdd("Comm::ConnOpener::DelayedConnectRetry", Comm::ConnOpener::DelayedConnectRetry, new Pointer(this), 0.05, 0, false);
             return;
         } else {
             // send ERROR back to the upper layer.
@@ -990,7 +990,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
                       AnyP::ProtocolType_str[request->http_ver.protocol],
                       request->http_ver.major, request->http_ver.minor);
             packerToMemInit(&pck, &mb);
-            request->header.packInto(&pck);
+            request->header.packInto(&pck, true); //hide authorization data
             packerClean(&pck);
         } else if (request_hdrs) {
             p = request_hdrs;
@@ -882,6 +882,7 @@ int
 ACLExternal::match(ACLChecklist *checklist)
 {
     allow_t answer = aclMatchExternal(data, Filled(checklist));
+
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:
@@ -1397,7 +1398,7 @@ void
 ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool inBackground)
 {
     external_acl *def = acl->def;
- 
+
     ACLFilledChecklist *ch = Filled(checklist);
     const char *key = makeExternalAclKey(ch, acl);
     assert(key);
@@ -842,11 +842,13 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
     }
 
 #if USE_SSL
-    if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
-            (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS) ||
-            (request->flags.sslPeek)) {
-        initiateSSL();
-        return;
+    if (!request->flags.pinned) {
+        if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
+                (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS) ||
+                request->flags.sslPeek) {
+            initiateSSL();
+            return;
+        }
     }
 #endif
 
@@ -1378,16 +1380,6 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     // TODO use the connection details in ACL.
     // needs a bit of rework in ACLFilledChecklist to use Comm::Connection instead of ConnStateData
 
-    if (request) {
-#if FOLLOW_X_FORWARDED_FOR
-        if (Config.onoff.acl_uses_indirect_client)
-            ch.src_addr = request->indirect_client_addr;
-        else
-#endif
-            ch.src_addr = request->client_addr;
-        ch.my_addr = request->my_addr;
-    }
-
     acl_address *l;
     for (l = Config.accessList.outgoing_address; l; l = l->next) {
 
@@ -134,9 +134,9 @@ IdentLookup::checkForAsync(ACLChecklist *cl)const
     const ConnStateData *conn = checklist->conn();
     // check that ACLIdent::match() tested this lookup precondition
     assert(conn && Comm::IsConnOpen(conn->clientConnection));
-        debugs(28, 3, HERE << "Doing ident lookup" );
-        checklist->asyncInProgress(true);
-        Ident::Start(checklist->conn()->clientConnection, LookupDone, checklist);
+    debugs(28, 3, HERE << "Doing ident lookup" );
+    checklist->asyncInProgress(true);
+    Ident::Start(checklist->conn()->clientConnection, LookupDone, checklist);
 }
 
 void
@@ -8,6 +8,7 @@
 #ifndef SQUID_IPC_TYPED_MSG_HDR_H
 #define SQUID_IPC_TYPED_MSG_HDR_H
 
+#include "compat/cmsg.h"
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -90,7 +91,8 @@ class TypedMsgHdr: public msghdr
     } data; ///< same as .msg_iov[0].iov_base
 
     struct CtrlBuffer {
-        char raw[CMSG_SPACE(sizeof(int))]; ///< control buffer space for one fd
+        /// control buffer space for one fd
+        char raw[SQUID_CMSG_SPACE(sizeof(int))];
     } ctrl; ///< same as .msg_control
 
     /// data offset for the next get/put*() to start with
@@ -1906,6 +1906,9 @@ SquidShutdown()
     }
 
 #endif
+    // clear StoreController
+    Store::Root(NULL);
+
     fdDumpOpen();
 
     comm_exit();
@@ -50,5 +50,5 @@ libexec_PROGRAMS = \
 
 if USE_SSL_CRTD
 ssl_crtd_SOURCES = ssl_crtd.cc certificate_db.cc certificate_db.h
-ssl_crtd_LDADD = $(SSLLIB) -lsslutil $(COMPAT_LIB)
+ssl_crtd_LDADD = libsslutil.la $(SSLLIB) $(COMPAT_LIB)
 endif
@@ -272,7 +272,7 @@ StoreEntry::delayAwareRead(const Comm::ConnectionPointer &conn, char *buf, int l
 }
 
 size_t
-StoreEntry::bytesWanted (Range<size_t> const aRange) const
+StoreEntry::bytesWanted (Range<size_t> const aRange, bool ignoreDelayPools) const
 {
     if (mem_obj == NULL)
         return aRange.end;
@@ -283,14 +283,10 @@ StoreEntry::bytesWanted (Range<size_t> const aRange) const
 
 #endif
 
-    /* Always read *something* here - we haven't got the header yet */
-    if (EBIT_TEST(flags, ENTRY_FWD_HDR_WAIT))
-        return aRange.end;
-
     if (!mem_obj->readAheadPolicyCanRead())
         return 0;
 
-    return mem_obj->mostBytesWanted(aRange.end);
+    return mem_obj->mostBytesWanted(aRange.end, ignoreDelayPools);
 }
 
 bool
@@ -32,7 +32,7 @@ void MemObject::delayRead(DeferredRead const &aRead) STUB
 bool MemObject::readAheadPolicyCanRead() const STUB_RETVAL(false)
 void MemObject::setNoDelay(bool const newValue) STUB
 MemObject::~MemObject() STUB
-int MemObject::mostBytesWanted(int max) const STUB_RETVAL(-1)
+int MemObject::mostBytesWanted(int max, bool ignoreDelayPools) const STUB_RETVAL(-1)
 #if USE_DELAY_POOLS
 DelayId MemObject::mostBytesAllowed() const STUB_RETVAL(DelayId())
 #endif
@@ -21,7 +21,7 @@ StoreEntry::~StoreEntry() STUB
 HttpReply const *StoreEntry::getReply() const STUB_RETVAL(NULL)
 void StoreEntry::write(StoreIOBuffer) STUB
 bool StoreEntry::isAccepting() const STUB_RETVAL(false)
-size_t StoreEntry::bytesWanted(Range<size_t> const) const STUB_RETVAL(0)
+size_t StoreEntry::bytesWanted(Range<size_t> const, bool) const STUB_RETVAL(0)
 void StoreEntry::complete() STUB
 store_client_t StoreEntry::storeClientType() const STUB_RETVAL(STORE_NON_CLIENT)
 char const *StoreEntry::getSerialisedMetaData() STUB_RETVAL(NULL)
@@ -23,7 +23,7 @@ testHttpParser::globalSetup()
 }
 
 void
-testHttpParser::testParseRequestLine()
+testHttpParser::testParseRequestLineProtocols()
 {
     // ensure MemPools etc exist
     globalSetup();
@@ -55,7 +55,29 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
     input.reset();
 
-    // RFC 1945 and 2616 : HTTP/1.0 full-request
+    // RFC 1945 : invalid HTTP/0.9 simple-request (only GET is valid)
+#if 0
+    input.append("POST /\r\n", 7);
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET /\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start], (output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start], (output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+    input.reset();
+#endif
+
+    // RFC 1945 and 2616 : HTTP/1.0 request
     input.append("GET / HTTP/1.0\r\n", 16);
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
@@ -76,8 +98,7 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
     input.reset();
 
-
-    // RFC 2616 : HTTP/1.1 full-request
+    // RFC 2616 : HTTP/1.1 request
     input.append("GET / HTTP/1.1\r\n", 16);
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
@@ -99,6 +120,29 @@ testHttpParser::testParseRequestLine()
     input.reset();
 
     // RFC 2616 : future version full-request
+    input.append("GET / HTTP/1.2\r\n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.2\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.2", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.v_min);
+    input.reset();
+
+    // RFC 2616 : future version full-request
+    // XXX: IETF HTTPbis WG has made this two-digits format invalid.
     input.append("GET / HTTP/10.12\r\n", 18);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
@@ -120,51 +164,203 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(12, output.req.v_min);
     input.reset();
 
-    // space padded URL
-    input.append("GET  /     HTTP/1.1\r\n", 21);
+    // This stage of the parser does not yet accept non-HTTP protocol names.
+    // violations mode treats them as HTTP/0.9 requests!
+    input.append("GET / FOO/1.0\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
+#if USE_HTTP_VIOLATIONS
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
     CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/ FOO/1.0", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
+#else
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+#endif
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET  /     HTTP/1.1\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT(memcmp("GET / FOO/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("FOO/1.0", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    input.reset();
+
+    // no version
+    input.append("GET / HTTP/\n", 12);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
     CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(11, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(18, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(10, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
     input.reset();
 
-    // space padded version
-    // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
-    // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
-    input.append("GET / HTTP/1.1 \n", 16);
+    // no major version
+    input.append("GET / HTTP/.1\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1 \n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(13, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/ HTTP/1.1", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // no version dot
+    input.append("GET / HTTP/11\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/11\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/11", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // negative major version (bug 3062)
+    input.append("GET / HTTP/-999999.1\n", 21);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/-999999.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/-999999.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
     input.reset();
 
+    // no minor version
+    input.append("GET / HTTP/1.\n", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // negative major version (bug 3062 corollary)
+    input.append("GET / HTTP/1.-999999\n", 21);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.-999999\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.-999999", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+}
+
+void
+testHttpParser::testParseRequestLineStrange()
+{
+    // ensure MemPools etc exist
+    globalSetup();
+
+    MemBuf input;
+    HttpParser output;
+    input.init();
+
+    // space padded URL
+    input.append("GET  /     HTTP/1.1\r\n", 21);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET  /     HTTP/1.1\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(5, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(11, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(18, output.req.v_end);
+    CPPUNIT_ASSERT(memcmp("HTTP/1.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
+    input.reset();
+
     // whitespace inside URI. (nasty but happens)
     input.append("GET /fo o/ HTTP/1.1\n", 20);
     //printf("TEST: '%s'\n",input.content());
@@ -208,6 +404,17 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
     CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
     input.reset();
+}
+
+void
+testHttpParser::testParseRequestLineTerminators()
+{
+    // ensure MemPools etc exist
+    globalSetup();
+
+    MemBuf input;
+    HttpParser output;
+    input.init();
 
     // alternative EOL sequence: NL-only
     input.append("GET / HTTP/1.1\n", 15);
@@ -297,6 +504,110 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
     input.reset();
 
+    // space padded version
+    // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
+    // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
+    input.append("GET / HTTP/1.1 \n", 16);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1 \n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
+    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(13, output.req.u_end);
+    CPPUNIT_ASSERT(memcmp("/ HTTP/1.1", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    // incomplete line at various positions
+
+    input.append("GET", 3);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET ", 4);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET / HT", 8);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET / HTTP/1.1", 14);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+}
+
+void
+testHttpParser::testParseRequestLineMethods()
+{
+    // ensure MemPools etc exist
+    globalSetup();
+
+    MemBuf input;
+    HttpParser output;
+    input.init();
+
     // RFC 2616 : . method
     input.append(". / HTTP/1.1\n", 13);
     //printf("TEST: '%s'\n",input.content());
@@ -363,36 +674,41 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
     input.reset();
 
-    // This stage of the parser does not yet accept non-HTTP protocol names.
-    // violations mode treats them as HTTP/0.9 requests!
-    input.append("GET / FOO/1.0\n", 14);
+    // method-only
+    input.append("A\n", 2);
+    //printf("TEST: '%s'\n",input.content());
+    output.reset(input.content(), input.contentSize());
+    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
+    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
+    CPPUNIT_ASSERT(memcmp("A\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
+    input.reset();
+
+    input.append("GET\n", 4);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
-#if USE_HTTP_VIOLATIONS
-    CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/ FOO/1.0", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
-#else
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-#endif
+    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / FOO/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
+    CPPUNIT_ASSERT(memcmp("GET\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("FOO/1.0", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
+    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
+    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
     input.reset();
 
     // RELAXED space padded method (in strict mode SP is reserved so invalid as a method byte)
@@ -459,95 +775,20 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
     CPPUNIT_ASSERT_EQUAL(1, output.req.v_min);
     input.reset();
+}
 
-    input.append("GET", 3);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    input.append("GET ", 4);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    input.append("GET / HT", 8);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    input.append("GET / HTTP/1.1", 14);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
+void
+testHttpParser::testParseRequestLineInvalid()
+{
+    // ensure MemPools etc exist
+    globalSetup();
 
-    // method-only
-    input.append("A\n", 2);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("A\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
+    MemBuf input;
+    HttpParser output;
+    input.init();
 
     // no method (but in a form which is ambiguous with HTTP/0.9 simple-request)
+    // XXX: Bug: HTTP/0.9 requires method to be "GET"
     input.append("/ HTTP/1.0\n", 11);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
@@ -717,138 +958,6 @@ testHttpParser::testParseRequestLine()
     CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
     input.reset();
 
-    // no version
-    input.append("GET / HTTP/\n", 12);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(10, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    // no major version
-    input.append("GET / HTTP/.1\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    // no version dot
-    input.append("GET / HTTP/11\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/11\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/11", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    // negative major version (bug 3062)
-    input.append("GET / HTTP/-999999.1\n", 21);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/-999999.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/-999999.1", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    // no minor version
-    input.append("GET / HTTP/1.\n", 14);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(12, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
-    // negative major version (bug 3062 corollary)
-    input.append("GET / HTTP/1.-999999\n", 21);
-    //printf("TEST: '%s'\n",input.content());
-    output.reset(input.content(), input.contentSize());
-    CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.start);
-    CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
-    CPPUNIT_ASSERT(memcmp("GET / HTTP/1.-999999\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
-    CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
-    CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(6, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(19, output.req.v_end);
-    CPPUNIT_ASSERT(memcmp("HTTP/1.-999999", &output.buf[output.req.v_start],(output.req.v_end-output.req.v_start+1)) == 0);
-    CPPUNIT_ASSERT_EQUAL(1, output.req.v_maj);
-    CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
-    input.reset();
-
     // binary line
     input.append("\xB\xC\xE\xF\n", 5);
     //printf("TEST: binary-line\n");
@@ -6,12 +6,22 @@
 class testHttpParser : public CPPUNIT_NS::TestFixture
 {
     CPPUNIT_TEST_SUITE( testHttpParser );
-    CPPUNIT_TEST( testParseRequestLine );
+    CPPUNIT_TEST( testParseRequestLineTerminators );
+    CPPUNIT_TEST( testParseRequestLineMethods );
+    CPPUNIT_TEST( testParseRequestLineProtocols );
+    CPPUNIT_TEST( testParseRequestLineStrange );
+    CPPUNIT_TEST( testParseRequestLineInvalid );
     CPPUNIT_TEST_SUITE_END();
 
 protected:
     void globalSetup(); // MemPools init etc.
-    void testParseRequestLine();
+
+    // request-line unit tests
+    void testParseRequestLineTerminators(); // terminator detection correct
+    void testParseRequestLineMethods();     // methoid detection correct
+    void testParseRequestLineProtocols();   // protocol tokens handled correctly
+    void testParseRequestLineStrange();     // strange but valid lines accepted
+    void testParseRequestLineInvalid();     // rejection of invalid lines happens
 };
 
 #endif
@@ -268,8 +268,10 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         src += 3;
 
         /* Then everything until first /; thats host (and port; which we'll look for here later) */
-        /* bug 1881: If we don't get a "/" then we imply it was there */
-        for (dst = host; i < l && *src != '/' && *src != '\0'; i++, src++, dst++) {
+        // bug 1881: If we don't get a "/" then we imply it was there
+        // bug 3074: We could just be given a "?" or "#". These also imply "/"
+        // bug 3233: whitespace is also a hostname delimiter.
+        for (dst = host; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\0' && !xisspace(*src); i++, src++, dst++) {
             *dst = *src;
         }
 
@@ -282,8 +284,15 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
             return NULL;
         *dst = '\0';
 
+        // bug 3074: received 'path' starting with '?', '#', or '\0' implies '/'
+        if (*src == '?' || *src == '#' || *src == '\0') {
+            urlpath[0] = '/';
+            dst = &urlpath[1];
+        } else {
+            dst = urlpath;
+        }
         /* Then everything from / (inclusive) until \r\n or \0 - thats urlpath */
-        for (dst = urlpath; i < l && *src != '\r' && *src != '\n' && *src != '\0'; i++, src++, dst++) {
+        for (; i < l && *src != '\r' && *src != '\n' && *src != '\0'; i++, src++, dst++) {
             *dst = *src;
         }
 