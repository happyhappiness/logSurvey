diff --git a/src/ChangeLog b/src/ChangeLog
index dd1c0ac..d664147 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,5 +1,10 @@
 2005-06-22  Hrvoje Niksic  <hniksic@xemacs.org>
 
+	* all: Use bool instead of int and false/true instead of 0/non-0
+	for boolean variables and values.
+
+2005-06-22  Hrvoje Niksic  <hniksic@xemacs.org>
+
 	* sysdep.h: Include the stdbool.h/_Bool/bool blurb from Autoconf.
 
 2005-06-22  Hrvoje Niksic  <hniksic@xemacs.org>
diff --git a/src/connect.c b/src/connect.c
index 69a2e5e..5ce6f1d 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -165,14 +165,20 @@ sockaddr_size (const struct sockaddr *sa)
     }
 }
 
-static int
+/* Resolve the bind address specified via --bind-address and store it
+   to SA.  The resolved value is stored in a static variable and
+   reused after the first invocation of this function.
+
+   Returns true on success, false on failure.  */
+
+static bool
 resolve_bind_address (struct sockaddr *sa)
 {
   struct address_list *al;
 
   /* Make sure this is called only once.  opt.bind_address doesn't
      change during a Wget run.  */
-  static int called, should_bind;
+  static bool called, should_bind;
   static ip_address ip;
   if (called)
     {
@@ -180,7 +186,7 @@ resolve_bind_address (struct sockaddr *sa)
 	sockaddr_set_data (sa, &ip, 0);
       return should_bind;
     }
-  called = 1;
+  called = true;
 
   al = lookup_host (opt.bind_address, LH_BIND | LH_SILENT);
   if (!al)
@@ -189,8 +195,8 @@ resolve_bind_address (struct sockaddr *sa)
       logprintf (LOG_NOTQUIET,
 		 _("%s: unable to resolve bind address `%s'; disabling bind.\n"),
 		 exec_name, opt.bind_address);
-      should_bind = 0;
-      return 0;
+      should_bind = false;
+      return false;
     }
 
   /* Pick the first address in the list and use it as bind address.
@@ -200,8 +206,8 @@ resolve_bind_address (struct sockaddr *sa)
   address_list_release (al);
 
   sockaddr_set_data (sa, &ip, 0);
-  should_bind = 1;
-  return 1;
+  should_bind = true;
+  return true;
 }
 
 struct cwt_context {
@@ -500,13 +506,13 @@ accept_connection (int local_sock)
 }
 
 /* Get the IP address associated with the connection on FD and store
-   it to IP.  Return 1 on success, 0 otherwise.
+   it to IP.  Return true on success, false otherwise.
 
    If ENDPOINT is ENDPOINT_LOCAL, it returns the address of the local
    (client) side of the socket.  Else if ENDPOINT is ENDPOINT_PEER, it
    returns the address of the remote (peer's) side of the socket.  */
 
-int
+bool
 socket_ip_address (int sock, ip_address *ip, int endpoint)
 {
   struct sockaddr_storage storage;
@@ -521,7 +527,7 @@ socket_ip_address (int sock, ip_address *ip, int endpoint)
   else
     abort ();
   if (ret < 0)
-    return 0;
+    return false;
 
   switch (sockaddr->sa_family)
     {
@@ -535,7 +541,7 @@ socket_ip_address (int sock, ip_address *ip, int endpoint)
 	ADDRESS_IPV6_SCOPE (ip) = sa6->sin6_scope_id;
 #endif
 	DEBUGP (("conaddr is: %s\n", pretty_print_address (ip)));
-	return 1;
+	return true;
       }
 #endif
     case AF_INET:
@@ -544,25 +550,25 @@ socket_ip_address (int sock, ip_address *ip, int endpoint)
 	ip->type = IPV4_ADDRESS;
 	ADDRESS_IPV4_IN_ADDR (ip) = sa->sin_addr;
 	DEBUGP (("conaddr is: %s\n", pretty_print_address (ip)));
-	return 1;
+	return true;
       }
     default:
       abort ();
     }
 }
 
-/* Return non-zero if the error from the connect code can be
-   considered retryable.  Wget normally retries after errors, but the
-   exception are the "unsupported protocol" type errors (possible on
-   IPv4/IPv6 dual family systems) and "connection refused".  */
+/* Return true if the error from the connect code can be considered
+   retryable.  Wget normally retries after errors, but the exception
+   are the "unsupported protocol" type errors (possible on IPv4/IPv6
+   dual family systems) and "connection refused".  */
 
-int
+bool
 retryable_socket_connect_error (int err)
 {
   /* Have to guard against some of these values not being defined.
      Cannot use a switch statement because some of the values might be
      equal.  */
-  if (0
+  if (false
 #ifdef EAFNOSUPPORT
       || err == EAFNOSUPPORT
 #endif
@@ -582,7 +588,7 @@ retryable_socket_connect_error (int err)
 	 instead of EAFNOSUPPORT and such.  */
       || err == EINVAL
       )
-    return 0;
+    return false;
 
   if (!opt.retry_connrefused)
     if (err == ECONNREFUSED
@@ -593,9 +599,9 @@ retryable_socket_connect_error (int err)
 	|| err == EHOSTUNREACH	/* host is unreachable */
 #endif
 	)
-      return 0;
+      return false;
 
-  return 1;
+  return true;
 }
 
 /* Wait for a single descriptor to become available, timing out after
@@ -632,7 +638,7 @@ select_fd (int fd, double maxtime, int wait_for)
   return result;
 }
 
-int
+bool
 test_socket_open (int sock)
 {
   fd_set check_set;
@@ -652,10 +658,10 @@ test_socket_open (int sock)
   if (select (sock + 1, &check_set, NULL, NULL, &to) == 0)
     {
       /* Connection is valid (not EOF), so continue */
-      return 1;
+      return true;
     }
   else
-    return 0;
+    return false;
 }
 
 /* Basic socket operations, mostly EINTR wrappers.  */
@@ -805,7 +811,7 @@ fd_transport_context (int fd)
     }									\
 } while (0)
 
-static int
+static bool
 poll_internal (int fd, struct transport_info *info, int wf, double timeout)
 {
   if (timeout == -1)
@@ -820,9 +826,9 @@ poll_internal (int fd, struct transport_info *info, int wf, double timeout)
       if (test == 0)
 	errno = ETIMEDOUT;
       if (test <= 0)
-	return 0;
+	return false;
     }
-  return 1;
+  return true;
 }
 
 /* Read no more than BUFSIZE bytes of data from FD, storing them to
diff --git a/src/connect.h b/src/connect.h
index 69d68cb..40974f5 100644
--- a/src/connect.h
+++ b/src/connect.h
@@ -48,9 +48,9 @@ enum {
   ENDPOINT_LOCAL,
   ENDPOINT_PEER
 };
-int socket_ip_address (int, ip_address *, int);
+bool socket_ip_address (int, ip_address *, int);
 
-int retryable_socket_connect_error (int);
+bool retryable_socket_connect_error (int);
 
 /* Flags for select_fd's WAIT_FOR argument. */
 enum {
@@ -58,7 +58,7 @@ enum {
   WAIT_FOR_WRITE = 2
 };
 int select_fd (int, double, int);
-int test_socket_open (int);
+bool test_socket_open (int);
 
 typedef int (*fd_reader_t) (int, char *, int, void *);
 typedef int (*fd_writer_t) (int, char *, int, void *);
diff --git a/src/convert.c b/src/convert.c
index 8c1d007..2cb2157 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -462,14 +462,14 @@ write_backup_file (const char *file, downloaded_file_t downloaded_file_return)
     }
 }
 
-static int find_fragment (const char *, int, const char **, const char **);
+static bool find_fragment (const char *, int, const char **, const char **);
 
 /* Replace an attribute's original text with NEW_TEXT. */
 
 static const char *
 replace_attr (const char *p, int size, FILE *fp, const char *new_text)
 {
-  int quote_flag = 0;
+  bool quote_flag = false;
   char quote_char = '\"';	/* use "..." for quoting, unless the
 				   original value is quoted, in which
 				   case reuse its quoting char. */
@@ -485,7 +485,7 @@ replace_attr (const char *p, int size, FILE *fp, const char *new_text)
   if (*p == '\"' || *p == '\'')
     {
       quote_char = *p;
-      quote_flag = 1;
+      quote_flag = true;
       ++p;
       size -= 2;		/* disregard opening and closing quote */
     }
@@ -523,36 +523,36 @@ replace_attr_refresh_hack (const char *p, int size, FILE *fp,
 
 /* Find the first occurrence of '#' in [BEG, BEG+SIZE) that is not
    preceded by '&'.  If the character is not found, return zero.  If
-   the character is found, return 1 and set BP and EP to point to the
-   beginning and end of the region.
+   the character is found, return true and set BP and EP to point to
+   the beginning and end of the region.
 
    This is used for finding the fragment indentifiers in URLs.  */
 
-static int
+static bool
 find_fragment (const char *beg, int size, const char **bp, const char **ep)
 {
   const char *end = beg + size;
-  int saw_amp = 0;
+  bool saw_amp = false;
   for (; beg < end; beg++)
     {
       switch (*beg)
 	{
 	case '&':
-	  saw_amp = 1;
+	  saw_amp = true;
 	  break;
 	case '#':
 	  if (!saw_amp)
 	    {
 	      *bp = beg;
 	      *ep = end;
-	      return 1;
+	      return true;
 	    }
 	  /* fallthrough */
 	default:
-	  saw_amp = 0;
+	  saw_amp = false;
 	}
     }
-  return 0;
+  return false;
 }
 
 /* Quote FILE for use as local reference to an HTML file.
@@ -623,9 +623,9 @@ local_quote_string (const char *file)
     dl_url_file_map = make_string_hash_table (0);	\
 } while (0)
 
-/* Return 1 if S1 and S2 are the same, except for "/index.html".  The
-   three cases in which it returns one are (substitute any substring
-   for "foo"):
+/* Return true if S1 and S2 are the same, except for "/index.html".
+   The three cases in which it returns one are (substitute any
+   substring for "foo"):
 
    m("foo/index.html", "foo/")  ==> 1
    m("foo/", "foo/index.html")  ==> 1
@@ -633,7 +633,7 @@ local_quote_string (const char *file)
    m("foo", "foo/"              ==> 1
    m("foo", "foo")              ==> 1  */
 
-static int
+static bool
 match_except_index (const char *s1, const char *s2)
 {
   int i;
@@ -646,14 +646,14 @@ match_except_index (const char *s1, const char *s2)
     /* Strings differ at the very beginning -- bail out.  We need to
        check this explicitly to avoid `lng - 1' reading outside the
        array.  */
-    return 0;
+    return false;
 
   if (!*s1 && !*s2)
     /* Both strings hit EOF -- strings are equal. */
-    return 1;
+    return true;
   else if (*s1 && *s2)
     /* Strings are randomly different, e.g. "/foo/bar" and "/foo/qux". */
-    return 0;
+    return false;
   else if (*s1)
     /* S1 is the longer one. */
     lng = s1;
@@ -672,7 +672,7 @@ match_except_index (const char *s1, const char *s2)
   if (*lng == '/' && *(lng + 1) == '\0')
     /* foo  */
     /* foo/ */
-    return 1;
+    return true;
 
   return 0 == strcmp (lng, "/index.html");
 }
diff --git a/src/cookies.c b/src/cookies.c
index 2addd18..95a46c1 100644
--- a/src/cookies.c
+++ b/src/cookies.c
@@ -108,7 +108,7 @@ struct cookie {
   unsigned domain_exact :1;	/* whether DOMAIN must match as a
 				   whole. */
 
-  int permanent :1;		/* whether the cookie should outlive
+  unsigned permanent :1;	/* whether the cookie should outlive
 				   the session. */
   time_t expiry_time;		/* time when the cookie expires, 0
 				   means undetermined. */
@@ -140,7 +140,7 @@ cookie_new (void)
 /* Non-zero if the cookie has expired.  Assumes cookies_now has been
    set by one of the entry point functions.  */
 
-static int
+static bool
 cookie_expired_p (const struct cookie *c)
 {
   return c->expiry_time != 0 && c->expiry_time < cookies_now;
@@ -338,10 +338,10 @@ discard_matching_cookie (struct cookie_jar *jar, struct cookie *cookie)
    it will parse the values of the fields it recognizes and fill the
    corresponding fields in COOKIE.
 
-   Returns 1 on success.  Returns zero in case a syntax error is
+   Returns true on success.  Returns false in case a syntax error is
    found; such a cookie should be discarded.  */
 
-static int
+static bool
 update_cookie_field (struct cookie *cookie,
 		     const char *name_b, const char *name_e,
 		     const char *value_b, const char *value_e)
@@ -351,16 +351,16 @@ update_cookie_field (struct cookie *cookie,
   if (!cookie->attr)
     {
       if (!VALUE_EXISTS)
-	return 0;
+	return false;
       cookie->attr = strdupdelim (name_b, name_e);
       cookie->value = strdupdelim (value_b, value_e);
-      return 1;
+      return true;
     }
 
   if (NAME_IS ("domain"))
     {
       if (!VALUE_NON_EMPTY)
-	return 0;
+	return false;
       xfree_null (cookie->domain);
       /* Strictly speaking, we should set cookie->domain_exact if the
 	 domain doesn't begin with a dot.  But many sites set the
@@ -369,15 +369,15 @@ update_cookie_field (struct cookie *cookie,
       if (*value_b == '.')
 	++value_b;
       cookie->domain = strdupdelim (value_b, value_e);
-      return 1;
+      return true;
     }
   else if (NAME_IS ("path"))
     {
       if (!VALUE_NON_EMPTY)
-	return 0;
+	return false;
       xfree_null (cookie->path);
       cookie->path = strdupdelim (value_b, value_e);
-      return 1;
+      return true;
     }
   else if (NAME_IS ("expires"))
     {
@@ -385,7 +385,7 @@ update_cookie_field (struct cookie *cookie,
       time_t expires;
 
       if (!VALUE_NON_EMPTY)
-	return 0;
+	return false;
       BOUNDED_TO_ALLOCA (value_b, value_e, value_copy);
 
       expires = http_atotm (value_copy);
@@ -405,7 +405,7 @@ update_cookie_field (struct cookie *cookie,
       if (cookie->expiry_time < cookies_now)
 	cookie->discard_requested = 1;
 
-      return 1;
+      return true;
     }
   else if (NAME_IS ("max-age"))
     {
@@ -413,13 +413,13 @@ update_cookie_field (struct cookie *cookie,
       char *value_copy;
 
       if (!VALUE_NON_EMPTY)
-	return 0;
+	return false;
       BOUNDED_TO_ALLOCA (value_b, value_e, value_copy);
 
       sscanf (value_copy, "%lf", &maxage);
       if (maxage == -1)
 	/* something went wrong. */
-	return 0;
+	return false;
       cookie->permanent = 1;
       cookie->expiry_time = cookies_now + maxage;
 
@@ -428,22 +428,22 @@ update_cookie_field (struct cookie *cookie,
       if (maxage == 0)
 	cookie->discard_requested = 1;
 
-      return 1;
+      return true;
     }
   else if (NAME_IS ("secure"))
     {
       /* ignore value completely */
       cookie->secure = 1;
-      return 1;
+      return true;
     }
   else
     /* Unrecognized attribute; ignore it. */
-    return 1;
+    return true;
 }
 
 #undef NAME_IS
 
-/* Returns non-zero for characters that are legal in the name of an
+/* Returns true for characters that are legal in the name of an
    attribute.  This used to allow only alphanumerics, '-', and '_',
    but we need to be more lenient because a number of sites wants to
    use weirder attribute names.  rfc2965 "informally specifies"
@@ -469,10 +469,10 @@ update_cookie_field (struct cookie *cookie,
 
 static struct cookie *
 parse_set_cookies (const char *sc,
-		   int (*callback) (struct cookie *,
-				    const char *, const char *,
-				    const char *, const char *),
-		   int silent)
+		   bool (*callback) (struct cookie *,
+				     const char *, const char *,
+				     const char *, const char *),
+		   bool silent)
 {
   struct cookie *cookie = cookie_new ();
 
@@ -603,7 +603,7 @@ parse_set_cookies (const char *sc,
 	  break;
 	case S_ATTR_ACTION:
 	  {
-	    int legal = callback (cookie, name_b, name_e, value_b, value_e);
+	    bool legal = callback (cookie, name_b, name_e, value_b, value_e);
 	    if (!legal)
 	      {
 		if (!silent)
@@ -647,14 +647,14 @@ parse_set_cookies (const char *sc,
 
 #define REQUIRE_DIGITS(p) do {			\
   if (!ISDIGIT (*p))				\
-    return 0;					\
+    return false;				\
   for (++p; ISDIGIT (*p); p++)			\
     ;						\
 } while (0)
 
 #define REQUIRE_DOT(p) do {			\
   if (*p++ != '.')				\
-    return 0;					\
+    return false;				\
 } while (0)
 
 /* Check whether ADDR matches <digits>.<digits>.<digits>.<digits>.
@@ -663,7 +663,7 @@ parse_set_cookies (const char *sc,
    all we need is a check, preferrably one that is small, fast, and
    well-defined.  */
 
-static int
+static bool
 numeric_address_p (const char *addr)
 {
   const char *p = addr;
@@ -677,8 +677,8 @@ numeric_address_p (const char *addr)
   REQUIRE_DIGITS (p);		/* D */
 
   if (*p != '\0')
-    return 0;
-  return 1;
+    return false;
+  return true;
 }
 
 /* Check whether COOKIE_DOMAIN is an appropriate domain for HOST.
@@ -686,7 +686,7 @@ numeric_address_p (const char *addr)
    the sites deviated too often, so I had to fall back to "tail
    matching", as defined by the original Netscape's cookie spec.  */
 
-static int
+static bool
 check_domain_match (const char *cookie_domain, const char *host)
 {
   DEBUGP (("cdm: 1"));
@@ -700,13 +700,13 @@ check_domain_match (const char *cookie_domain, const char *host)
 
   /* For the sake of efficiency, check for exact match first. */
   if (0 == strcasecmp (cookie_domain, host))
-    return 1;
+    return true;
 
   DEBUGP ((" 3"));
 
   /* HOST must match the tail of cookie_domain. */
-  if (!match_tail (host, cookie_domain, 1))
-    return 0;
+  if (!match_tail (host, cookie_domain, true))
+    return false;
 
   /* We know that COOKIE_DOMAIN is a subset of HOST; however, we must
      make sure that somebody is not trying to set the cookie for a
@@ -752,7 +752,7 @@ check_domain_match (const char *cookie_domain, const char *host)
 	case '.':
 	  if (ldcl == 0)
 	    /* Empty domain component found -- the domain is invalid. */
-	    return 0;
+	    return false;
 	  if (*(p + 1) == '\0')
 	    {
 	      /* Tolerate trailing '.' by not treating the domain as
@@ -771,25 +771,25 @@ check_domain_match (const char *cookie_domain, const char *host)
     DEBUGP ((" 5"));
 
     if (dccount < 2)
-      return 0;
+      return false;
 
     DEBUGP ((" 6"));
 
     if (dccount == 2)
       {
 	int i;
-	int known_toplevel = 0;
+	int known_toplevel = false;
 	static const char *known_toplevel_domains[] = {
 	  ".com", ".edu", ".net", ".org", ".gov", ".mil", ".int"
 	};
 	for (i = 0; i < countof (known_toplevel_domains); i++)
-	  if (match_tail (cookie_domain, known_toplevel_domains[i], 1))
+	  if (match_tail (cookie_domain, known_toplevel_domains[i], true))
 	    {
-	      known_toplevel = 1;
+	      known_toplevel = true;
 	      break;
 	    }
 	if (!known_toplevel && nldcl <= 3)
-	  return 0;
+	  return false;
       }
   }
 
@@ -805,22 +805,22 @@ check_domain_match (const char *cookie_domain, const char *host)
       /* desired domain:             bar.com */
       /* '.' must be here in host-> ^        */
       if (hlen > dlen && host[hlen - dlen - 1] != '.')
-	return 0;
+	return false;
     }
 
   DEBUGP ((" 8"));
 
-  return 1;
+  return true;
 }
 
 static int path_matches (const char *, const char *);
 
 /* Check whether PATH begins with COOKIE_PATH. */
 
-static int
+static bool
 check_path_match (const char *cookie_path, const char *path)
 {
-  return path_matches (path, cookie_path);
+  return path_matches (path, cookie_path) != 0;
 }
 
 /* Process the HTTP `Set-Cookie' header.  This results in storing the
@@ -835,7 +835,7 @@ cookie_handle_set_cookie (struct cookie_jar *jar,
   struct cookie *cookie;
   cookies_now = time (NULL);
 
-  cookie = parse_set_cookies (set_cookie, update_cookie_field, 0);
+  cookie = parse_set_cookies (set_cookie, update_cookie_field, false);
   if (!cookie)
     goto out;
 
@@ -996,17 +996,17 @@ path_matches (const char *full_path, const char *prefix)
   return len + 1;
 }
 
-/* Return non-zero iff COOKIE matches the provided parameters of the
-   URL being downloaded: HOST, PORT, PATH, and SECFLAG.
+/* Return true iff COOKIE matches the provided parameters of the URL
+   being downloaded: HOST, PORT, PATH, and SECFLAG.
 
    If PATH_GOODNESS is non-NULL, store the "path goodness" value
    there.  That value is a measure of how closely COOKIE matches PATH,
    used for ordering cookies.  */
 
-static int
+static bool
 cookie_matches_url (const struct cookie *cookie,
 		    const char *host, int port, const char *path,
-		    int secflag, int *path_goodness)
+		    bool secflag, int *path_goodness)
 {
   int pg;
 
@@ -1016,31 +1016,31 @@ cookie_matches_url (const struct cookie *cookie,
        stale cookies will not be saved by `save_cookies'.  On the
        other hand, this function should be as efficient as
        possible.  */
-    return 0;
+    return false;
 
   if (cookie->secure && !secflag)
     /* Don't transmit secure cookies over insecure connections.  */
-    return 0;
+    return false;
   if (cookie->port != PORT_ANY && cookie->port != port)
-    return 0;
+    return false;
 
   /* If exact domain match is required, verify that cookie's domain is
      equal to HOST.  If not, assume success on the grounds of the
      cookie's chain having been found by find_chains_of_host.  */
   if (cookie->domain_exact
       && 0 != strcasecmp (host, cookie->domain))
-    return 0;
+    return false;
 
   pg = path_matches (path, cookie->path);
-  if (!pg)
-    return 0;
+  if (pg == 0)
+    return false;
 
   if (path_goodness)
     /* If the caller requested path_goodness, we return it.  This is
        an optimization, so that the caller doesn't need to call
        path_matches() again.  */
     *path_goodness = pg;
-  return 1;
+  return true;
 }
 
 /* A structure that points to a cookie, along with the additional
@@ -1139,7 +1139,7 @@ goodness_comparator (const void *p1, const void *p2)
 
 char *
 cookie_header (struct cookie_jar *jar, const char *host,
-	       int port, const char *path, int secflag)
+	       int port, const char *path, bool secflag)
 {
   struct cookie **chains;
   int chain_count;
@@ -1528,13 +1528,13 @@ cookie_jar_delete (struct cookie_jar *jar)
 int test_count;
 char *test_results[10];
 
-static int test_parse_cookies_callback (struct cookie *ignored,
-					const char *nb, const char *ne,
-					const char *vb, const char *ve)
+static bool test_parse_cookies_callback (struct cookie *ignored,
+					 const char *nb, const char *ne,
+					 const char *vb, const char *ve)
 {
   test_results[test_count++] = strdupdelim (nb, ne);
   test_results[test_count++] = strdupdelim (vb, ve);
-  return 1;
+  return true;
 }
 
 void
@@ -1574,7 +1574,7 @@ test_cookies (void)
       struct cookie *c;
 
       test_count = 0;
-      c = parse_set_cookies (data, test_parse_cookies_callback, 1);
+      c = parse_set_cookies (data, test_parse_cookies_callback, true);
       if (!c)
 	{
 	  printf ("NULL cookie returned for valid data: %s\n", data);
diff --git a/src/cookies.h b/src/cookies.h
index 981ebe2..562aa9b 100644
--- a/src/cookies.h
+++ b/src/cookies.h
@@ -37,7 +37,8 @@ void cookie_jar_delete (struct cookie_jar *);
 
 void cookie_handle_set_cookie (struct cookie_jar *, const char *, int,
 			       const char *, const char *);
-char *cookie_header (struct cookie_jar *, const char *, int, const char *, int);
+char *cookie_header (struct cookie_jar *, const char *, int,
+		     const char *, bool);
 
 void cookie_jar_load (struct cookie_jar *, const char *);
 void cookie_jar_save (struct cookie_jar *, const char *);
diff --git a/src/ftp.c b/src/ftp.c
index fed0597..e8e9a5a 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -58,7 +58,7 @@ extern LARGE_INT total_downloaded_bytes;
 extern char ftp_last_respline[];
 
 extern FILE *output_stream;
-extern int output_stream_regular;
+extern bool output_stream_regular;
 
 typedef struct
 {
@@ -242,9 +242,9 @@ getftp (struct url *u, wgint *len, wgint restval, ccon *con)
   char *user, *passwd, *respline;
   char *tms, *tmrate;
   int cmd = con->cmd;
-  int pasv_mode_open = 0;
+  bool pasv_mode_open = false;
   wgint expected_bytes = 0;
-  int rest_failed = 0;
+  bool rest_failed = false;
   int flags;
   wgint rd_size;
 
@@ -671,7 +671,7 @@ Error in server response, closing control connection.\n"));
 			  ? CONERROR : CONIMPOSSIBLE);
 		}
 
-	      pasv_mode_open = 1;  /* Flag to avoid accept port */
+	      pasv_mode_open = true;  /* Flag to avoid accept port */
 	      if (!opt.server_response)
 		logputs (LOG_VERBOSE, _("done.    "));
 	    } /* err==FTP_OK */
@@ -765,7 +765,7 @@ Error in server response, closing control connection.\n"));
 	  return err;
 	case FTPRESTFAIL:
 	  logputs (LOG_VERBOSE, _("\nREST failed, starting from scratch.\n"));
-	  rest_failed = 1;
+	  rest_failed = true;
 	  break;
 	case FTPOK:
 	  break;
@@ -927,7 +927,7 @@ Error in server response, closing control connection.\n"));
 	fp = fopen (con->target, "wb");
       else
 	{
-	  fp = fopen_excl (con->target, 1);
+	  fp = fopen_excl (con->target, true);
 	  if (!fp && errno == EEXIST)
 	    {
 	      /* We cannot just invent a new name and use it (which is
@@ -1166,7 +1166,7 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
       /* Print fetch message, if opt.verbose.  */
       if (opt.verbose)
 	{
-	  char *hurl = url_string (u, 1);
+	  char *hurl = url_string (u, true);
 	  char tmp[256];
 	  strcpy (tmp, "        ");
 	  if (count > 1)
@@ -1247,7 +1247,7 @@ ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con)
 	  /* Need to hide the password from the URL.  The `if' is here
              so that we don't do the needless allocation every
              time. */
-	  char *hurl = url_string (u, 1);
+	  char *hurl = url_string (u, true);
 	  logprintf (LOG_NONVERBOSE, "%s URL: %s [%s] -> \"%s\" [%d]\n",
 		     tms, hurl, number_to_static_string (len), locf, count);
 	  xfree (hurl);
@@ -1366,7 +1366,7 @@ ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
   struct fileinfo *orig;
   wgint local_size;
   time_t tml;
-  int dlthis;
+  bool dlthis;
 
   /* Increase the depth.  */
   ++depth;
@@ -1412,7 +1412,7 @@ ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
       con->target = url_file_name (u);
       err = RETROK;
 
-      dlthis = 1;
+      dlthis = true;
       if (opt.timestamping && f->type == FT_PLAINFILE)
         {
 	  struct_stat st;
@@ -1423,8 +1423,8 @@ ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
 	     .orig suffix. */
 	  if (!stat (con->target, &st))
 	    {
-              int eq_size;
-              int cor_val;
+              bool eq_size;
+              bool cor_val;
 	      /* Else, get it from the file.  */
 	      local_size = st.st_size;
 	      tml = st.st_mtime;
@@ -1437,14 +1437,14 @@ ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)
                  values. Assumme sizes being equal for servers that lie
                  about file size.  */
               cor_val = (con->rs == ST_UNIX || con->rs == ST_WINNT);
-              eq_size = cor_val ? (local_size == f->size) : 1 ;
+              eq_size = cor_val ? (local_size == f->size) : true;
 	      if (f->tstamp <= tml && eq_size)
 		{
 		  /* Remote file is older, file sizes can be compared and
                      are both equal. */
                   logprintf (LOG_VERBOSE, _("\
 Remote file no newer than local file `%s' -- not retrieving.\n"), con->target);
-		  dlthis = 0;
+		  dlthis = false;
 		}
 	      else if (eq_size)
                 {
@@ -1494,7 +1494,7 @@ The sizes do not match (local %s) -- retrieving.\n\n"),
 			      logprintf (LOG_VERBOSE, _("\
 Already have correct symlink %s -> %s\n\n"),
 					 con->target, escnonprint (f->linkto));
-                              dlthis = 0;
+                              dlthis = false;
 			      break;
 			    }
 			}
@@ -1659,17 +1659,17 @@ Not descending to `%s' as it is excluded/not-included.\n"),
     return RETROK;
 }
 
-/* Return non-zero if S has a leading '/'  or contains '../' */
-static int
+/* Return true if S has a leading '/'  or contains '../' */
+static bool
 has_insecure_name_p (const char *s)
 {
   if (*s == '/')
-    return 1;
+    return true;
 
   if (strstr (s, "../") != 0)
-    return 1;
+    return true;
 
-  return 0;
+  return false;
 }
 
 /* A near-top-level function to retrieve the files in a directory.
@@ -1842,7 +1842,7 @@ ftp_loop (struct url *u, int *dt, struct url *proxy)
     }
   else
     {
-      int ispattern = 0;
+      bool ispattern = false;
       if (opt.ftp_glob)
 	{
 	  /* Treat the URL as a pattern if the file name part of the
diff --git a/src/host.c b/src/host.c
index fccc0d6..6bf6514 100644
--- a/src/host.c
+++ b/src/host.c
@@ -71,7 +71,7 @@ struct address_list {
   ip_address *addresses;	/* pointer to the string of addresses */
 
   int faulty;			/* number of addresses known not to work. */
-  int connected;		/* whether we were able to connect to
+  bool connected;		/* whether we were able to connect to
 				   one of the addresses in the list,
 				   at least once. */
 
@@ -97,9 +97,9 @@ address_list_address_at (const struct address_list *al, int pos)
   return al->addresses + pos;
 }
 
-/* Return non-zero if AL contains IP, zero otherwise.  */
+/* Return true if AL contains IP, false otherwise.  */
 
-int
+bool
 address_list_contains (const struct address_list *al, const ip_address *ip)
 {
   int i;
@@ -113,9 +113,9 @@ address_list_contains (const struct address_list *al, const ip_address *ip)
 	      && (ADDRESS_IPV4_IN_ADDR (cur).s_addr
 		  ==
 		  ADDRESS_IPV4_IN_ADDR (ip).s_addr))
-	    return 1;
+	    return true;
 	}
-      return 0;
+      return false;
 #ifdef ENABLE_IPV6
     case IPV6_ADDRESS:
       for (i = 0; i < al->count; i++)
@@ -127,9 +127,9 @@ address_list_contains (const struct address_list *al, const ip_address *ip)
 #endif
 	      && IN6_ARE_ADDR_EQUAL (&ADDRESS_IPV6_IN6_ADDR (cur),
 				     &ADDRESS_IPV6_IN6_ADDR (ip)))
-	    return 1;
+	    return true;
 	}
-      return 0;
+      return false;
 #endif /* ENABLE_IPV6 */
     default:
       abort ();
@@ -162,12 +162,12 @@ address_list_set_faulty (struct address_list *al, int index)
 void
 address_list_set_connected (struct address_list *al)
 {
-  al->connected = 1;
+  al->connected = true;
 }
 
 /* Return the value of the "connected" flag. */
 
-int
+bool
 address_list_connected_p (const struct address_list *al)
 {
   return al->connected;
@@ -440,10 +440,10 @@ pretty_print_address (const ip_address *addr)
 
 /* The following two functions were adapted from glibc. */
 
-static int
+static bool
 is_valid_ipv4_address (const char *str, const char *end)
 {
-  int saw_digit = 0;
+  bool saw_digit = false;
   int octets = 0;
   int val = 0;
 
@@ -456,31 +456,31 @@ is_valid_ipv4_address (const char *str, const char *end)
 	  val = val * 10 + (ch - '0');
 
 	  if (val > 255)
-	    return 0;
-	  if (saw_digit == 0)
+	    return false;
+	  if (!saw_digit)
 	    {
 	      if (++octets > 4)
-		return 0;
-	      saw_digit = 1;
+		return false;
+	      saw_digit = true;
 	    }
 	}
-      else if (ch == '.' && saw_digit == 1)
+      else if (ch == '.' && saw_digit)
 	{
 	  if (octets == 4)
-	    return 0;
+	    return false;
 	  val = 0;
-	  saw_digit = 0;
+	  saw_digit = false;
 	}
       else
-	return 0;
+	return false;
     }
   if (octets < 4)
-    return 0;
+    return false;
   
-  return 1;
+  return true;
 }
 
-int
+bool
 is_valid_ipv6_address (const char *str, const char *end)
 {
   /* Use lower-case for these to avoid clash with system headers.  */
@@ -493,25 +493,25 @@ is_valid_ipv6_address (const char *str, const char *end)
   const char *curtok;
   int tp;
   const char *colonp;
-  int saw_xdigit;
+  bool saw_xdigit;
   unsigned int val;
 
   tp = 0;
   colonp = NULL;
 
   if (str == end)
-    return 0;
+    return false;
   
   /* Leading :: requires some special handling. */
   if (*str == ':')
     {
       ++str;
       if (str == end || *str != ':')
-	return 0;
+	return false;
     }
 
   curtok = str;
-  saw_xdigit = 0;
+  saw_xdigit = false;
   val = 0;
 
   while (str < end)
@@ -524,8 +524,8 @@ is_valid_ipv6_address (const char *str, const char *end)
 	  val <<= 4;
 	  val |= XDIGIT_TO_NUM (ch);
 	  if (val > 0xffff)
-	    return 0;
-	  saw_xdigit = 1;
+	    return false;
+	  saw_xdigit = true;
 	  continue;
 	}
 
@@ -533,19 +533,19 @@ is_valid_ipv6_address (const char *str, const char *end)
       if (ch == ':')
 	{
 	  curtok = str;
-	  if (saw_xdigit == 0)
+	  if (!saw_xdigit)
 	    {
 	      if (colonp != NULL)
-		return 0;
+		return false;
 	      colonp = str + tp;
 	      continue;
 	    }
 	  else if (str == end)
-	    return 0;
+	    return false;
 	  if (tp > ns_in6addrsz - ns_int16sz)
-	    return 0;
+	    return false;
 	  tp += ns_int16sz;
-	  saw_xdigit = 0;
+	  saw_xdigit = false;
 	  val = 0;
 	  continue;
 	}
@@ -555,31 +555,31 @@ is_valid_ipv6_address (const char *str, const char *end)
 	  && is_valid_ipv4_address (curtok, end) == 1)
 	{
 	  tp += ns_inaddrsz;
-	  saw_xdigit = 0;
+	  saw_xdigit = false;
 	  break;
 	}
     
-      return 0;
+      return false;
     }
 
-  if (saw_xdigit == 1)
+  if (saw_xdigit)
     {
       if (tp > ns_in6addrsz - ns_int16sz) 
-	return 0;
+	return false;
       tp += ns_int16sz;
     }
 
   if (colonp != NULL)
     {
       if (tp == ns_in6addrsz) 
-	return 0;
+	return false;
       tp = ns_in6addrsz;
     }
 
   if (tp != ns_in6addrsz)
-    return 0;
+    return false;
 
-  return 1;
+  return true;
 }
 
 /* Simple host cache, used by lookup_host to speed up resolving.  The
@@ -675,9 +675,9 @@ struct address_list *
 lookup_host (const char *host, int flags)
 {
   struct address_list *al;
-  int silent = flags & LH_SILENT;
-  int use_cache;
-  int numeric_address = 0;
+  bool silent = !!(flags & LH_SILENT);
+  bool use_cache;
+  bool numeric_address = false;
   double timeout = opt.dns_timeout;
 
 #ifndef ENABLE_IPV6
@@ -706,7 +706,7 @@ lookup_host (const char *host, int flags)
   {
     const char *end = host + strlen (host);
     if (is_valid_ipv4_address (host, end) || is_valid_ipv6_address (host, end))
-      numeric_address = 1;
+      numeric_address = true;
   }
 #endif
 
@@ -715,7 +715,7 @@ lookup_host (const char *host, int flags)
   use_cache = opt.dns_cache;
 #ifdef ENABLE_IPV6
   if ((flags & LH_BIND) || numeric_address)
-    use_cache = 0;
+    use_cache = false;
 #endif
 
   /* Try to find the host in the cache so we don't need to talk to the
@@ -842,21 +842,21 @@ lookup_host (const char *host, int flags)
 
 /* Determine whether a URL is acceptable to be followed, according to
    a list of domains to accept.  */
-int
+bool
 accept_domain (struct url *u)
 {
   assert (u->host != NULL);
   if (opt.domains)
     {
       if (!sufmatch ((const char **)opt.domains, u->host))
-	return 0;
+	return false;
     }
   if (opt.exclude_domains)
     {
       if (sufmatch ((const char **)opt.exclude_domains, u->host))
-	return 0;
+	return false;
     }
-  return 1;
+  return true;
 }
 
 /* Check whether WHAT is matched in LIST, each element of LIST being a
@@ -864,7 +864,7 @@ accept_domain (struct url *u)
    match_backwards() in utils.c).
 
    If an element of LIST matched, 1 is returned, 0 otherwise.  */
-int
+bool
 sufmatch (const char **list, const char *what)
 {
   int i, j, k, lw;
@@ -877,9 +877,9 @@ sufmatch (const char **list, const char *what)
 	  break;
       /* The domain must be first to reach to beginning.  */
       if (j == -1)
-	return 1;
+	return true;
     }
-  return 0;
+  return false;
 }
 
 static int
diff --git a/src/host.h b/src/host.h
index 786a964..c53331e 100644
--- a/src/host.h
+++ b/src/host.h
@@ -99,19 +99,19 @@ struct address_list *lookup_host (const char *, int);
 
 void address_list_get_bounds (const struct address_list *, int *, int *);
 const ip_address *address_list_address_at (const struct address_list *, int);
-int address_list_contains (const struct address_list *, const ip_address *);
+bool address_list_contains (const struct address_list *, const ip_address *);
 void address_list_set_faulty (struct address_list *, int);
 void address_list_set_connected (struct address_list *);
-int address_list_connected_p (const struct address_list *);
+bool address_list_connected_p (const struct address_list *);
 void address_list_release (struct address_list *);
 
 const char *pretty_print_address (const ip_address *);
 #ifdef ENABLE_IPV6
-int is_valid_ipv6_address (const char *, const char *);
+bool is_valid_ipv6_address (const char *, const char *);
 #endif
 
-int accept_domain (struct url *);
-int sufmatch (const char **, const char *);
+bool accept_domain (struct url *);
+bool sufmatch (const char **, const char *);
 
 void host_cleanup (void);
 
diff --git a/src/html-parse.c b/src/html-parse.c
index 19fbd3c..0c2f8db 100644
--- a/src/html-parse.c
+++ b/src/html-parse.c
@@ -153,7 +153,7 @@ struct pool {
   char *contents;		/* pointer to the contents. */
   int size;			/* size of the pool. */
   int tail;			/* next available position index. */
-  int resized;			/* whether the pool has been resized
+  bool resized;			/* whether the pool has been resized
 				   using malloc. */
 
   char *orig_contents;		/* original pool contents, usually
@@ -170,7 +170,7 @@ struct pool {
   P->contents = (initial_storage);				\
   P->size = (initial_size);					\
   P->tail = 0;							\
-  P->resized = 0;						\
+  P->resized = false;						\
   P->orig_contents = P->contents;				\
   P->orig_size = P->size;					\
 } while (0)
@@ -218,7 +218,7 @@ struct pool {
   P->contents = P->orig_contents;		\
   P->size = P->orig_size;			\
   P->tail = 0;					\
-  P->resized = 0;				\
+  P->resized = false;				\
 } while (0)
 
 /* Used for small stack-allocated memory chunks that might grow.  Like
@@ -247,7 +247,7 @@ struct pool {
 	  void *ga_new = xmalloc (ga_newsize * sizeof (type));			\
 	  memcpy (ga_new, basevar, (sizevar) * sizeof (type));			\
 	  (basevar) = ga_new;							\
-	  resized = 1;								\
+	  resized = true;							\
 	}									\
       (sizevar) = ga_newsize;							\
     }										\
@@ -385,7 +385,7 @@ convert_and_copy (struct pool *pool, const char *beg, const char *end, int flags
 	 never lengthen it.  */
       const char *from = beg;
       char *to;
-      int squash_newlines = flags & AP_TRIM_BLANKS;
+      bool squash_newlines = !!(flags & AP_TRIM_BLANKS);
 
       POOL_GROW (pool, end - beg);
       to = pool->contents + pool->tail;
@@ -680,15 +680,15 @@ find_comment_end (const char *beg, const char *end)
   return NULL;
 }
 
-/* Return non-zero of the string inside [b, e) are present in hash
-   table HT.  */
+/* Return true if the string containing of characters inside [b, e) is
+   present in hash table HT.  */
 
-static int
+static bool
 name_allowed (const struct hash_table *ht, const char *b, const char *e)
 {
   char *copy;
   if (!ht)
-    return 1;
+    return true;
   BOUNDED_TO_ALLOCA (b, e, copy);
   return hash_table_get (ht, copy) != NULL;
 }
@@ -753,7 +753,7 @@ map_html_tags (const char *text, int size,
 
   struct attr_pair attr_pair_initial_storage[8];
   int attr_pair_size = countof (attr_pair_initial_storage);
-  int attr_pair_resized = 0;
+  bool attr_pair_resized = false;
   struct attr_pair *pairs = attr_pair_initial_storage;
 
   if (!size)
@@ -765,7 +765,7 @@ map_html_tags (const char *text, int size,
     int nattrs, end_tag;
     const char *tag_name_begin, *tag_name_end;
     const char *tag_start_position;
-    int uninteresting_tag;
+    bool uninteresting_tag;
 
   look_for_tag:
     POOL_REWIND (&pool);
@@ -828,10 +828,10 @@ map_html_tags (const char *text, int size,
     if (!name_allowed (allowed_tags, tag_name_begin, tag_name_end))
       /* We can't just say "goto look_for_tag" here because we need
          the loop below to properly advance over the tag's attributes.  */
-      uninteresting_tag = 1;
+      uninteresting_tag = true;
     else
       {
-	uninteresting_tag = 0;
+	uninteresting_tag = false;
 	convert_and_copy (&pool, tag_name_begin, tag_name_end, AP_DOWNCASE);
       }
 
@@ -890,7 +890,7 @@ map_html_tags (const char *text, int size,
 	    SKIP_WS (p);
 	    if (*p == '\"' || *p == '\'')
 	      {
-		int newline_seen = 0;
+		bool newline_seen = false;
 		char quote_char = *p;
 		attr_raw_value_begin = p;
 		ADVANCE (p);
@@ -908,7 +908,7 @@ map_html_tags (const char *text, int size,
 			   comes first.  Such a tag terminated at `>'
 			   is discarded.  */
 			p = attr_value_begin;
-			newline_seen = 1;
+			newline_seen = true;
 			continue;
 		      }
 		    else if (newline_seen && *p == '>')
diff --git a/src/html-url.c b/src/html-url.c
index b507115..27de1ea 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -252,7 +252,7 @@ struct map_context {
 				   changed through <base href=...>. */
   const char *parent_base;	/* Base of the current document. */
   const char *document_file;	/* File name of this document. */
-  int nofollow;			/* whether NOFOLLOW was specified in a
+  bool nofollow;		/* whether NOFOLLOW was specified in a
                                    <meta name=robots> tag. */
 
   struct urlpos *head, *tail;	/* List of URLs that is being
@@ -541,7 +541,7 @@ tag_handle_meta (int tagid, struct taginfo *tag, struct map_context *ctx)
       if (!content)
 	return;
       if (!strcasecmp (content, "none"))
-	ctx->nofollow = 1;
+	ctx->nofollow = true;
       else
 	{
 	  while (*content)
@@ -554,7 +554,7 @@ tag_handle_meta (int tagid, struct taginfo *tag, struct map_context *ctx)
 	      else
 		end = content + strlen (content);
 	      if (!strncasecmp (content, "nofollow", end - content))
-		ctx->nofollow = 1;
+		ctx->nofollow = true;
 	      content = end;
 	    }
 	}
@@ -582,7 +582,7 @@ collect_tags_mapper (struct taginfo *tag, void *arg)
    <base href=...> and does the right thing.  */
 
 struct urlpos *
-get_urls_html (const char *file, const char *url, int *meta_disallow_follow)
+get_urls_html (const char *file, const char *url, bool *meta_disallow_follow)
 {
   struct file_memory *fm;
   struct map_context ctx;
@@ -602,7 +602,7 @@ get_urls_html (const char *file, const char *url, int *meta_disallow_follow)
   ctx.base = NULL;
   ctx.parent_base = url ? url : opt.base_href;
   ctx.document_file = file;
-  ctx.nofollow = 0;
+  ctx.nofollow = false;
 
   if (!interesting_tags)
     init_interesting ();
diff --git a/src/http-ntlm.c b/src/http-ntlm.c
index c0d2511..8a95cb7 100644
--- a/src/http-ntlm.c
+++ b/src/http-ntlm.c
@@ -114,12 +114,12 @@ so, delete this exception statement from your version.  */
      beginning of the NTLM message, in bytes.
 */
 
-/* return 1 on success, 0 otherwise */
-int
+/* return true on success, false otherwise */
+bool
 ntlm_input (struct ntlmdata *ntlm, const char *header)
 {
   if (0 != strncmp (header, "NTLM", 4))
-    return 0;
+    return false;
 
   header += 4;
   while (*header && ISSPACE(*header))
@@ -147,7 +147,7 @@ ntlm_input (struct ntlmdata *ntlm, const char *header)
 
       size = base64_decode (header, buffer);
       if (size < 0)
-	return 0;		/* malformed base64 from server */
+	return false;		/* malformed base64 from server */
 
       ntlm->state = NTLMSTATE_TYPE2; /* we got a type-2 */
 
@@ -162,14 +162,14 @@ ntlm_input (struct ntlmdata *ntlm, const char *header)
       if (ntlm->state >= NTLMSTATE_TYPE1)
 	{
 	  DEBUGP (("Unexpected empty NTLM message.\n"));
-	  return 0; /* this is an error */
+	  return false; /* this is an error */
 	}
 
       DEBUGP (("Empty NTLM message, starting transaction.\n"));
       ntlm->state = NTLMSTATE_TYPE1; /* we should sent away a type-1 */
     }
 
-  return 1;
+  return true;
 }
 
 /*
@@ -300,7 +300,7 @@ mkhash(const char *password,
 /* this is for creating ntlm header output */
 char *
 ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
-	     int *ready)
+	     bool *ready)
 {
   const char *domain=""; /* empty */
   const char *host=""; /* empty */
@@ -316,7 +316,7 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
      server, which is for a plain host or for a HTTP proxy */
   char *output;
 
-  *ready = 0;
+  *ready = false;
 
   /* not set means empty */
   if(!user)
@@ -554,14 +554,14 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
     output = concat_strings ("NTLM ", base64, (char *) 0);
 
     ntlm->state = NTLMSTATE_TYPE3; /* we sent a type-3 */
-    *ready = 1;
+    *ready = true;
   }
   break;
 
   case NTLMSTATE_TYPE3:
     /* connection is already authenticated,
      * don't send a header in future requests */
-    *ready = 1;
+    *ready = true;
     output = NULL;
     break;
   }
diff --git a/src/http-ntlm.h b/src/http-ntlm.h
index 19d9b6b..aeb192f 100644
--- a/src/http-ntlm.h
+++ b/src/http-ntlm.h
@@ -44,8 +44,8 @@ struct ntlmdata {
 };
 
 /* this is for ntlm header input */
-int ntlm_input (struct ntlmdata *, const char *);
+bool ntlm_input (struct ntlmdata *, const char *);
 
 /* this is for creating ntlm header output */
-char *ntlm_output (struct ntlmdata *, const char *, const char *, int *);
+char *ntlm_output (struct ntlmdata *, const char *, const char *, bool *);
 #endif
diff --git a/src/http.c b/src/http.c
index 007f009..5eb256b 100644
--- a/src/http.c
+++ b/src/http.c
@@ -62,14 +62,14 @@ extern char *version_string;
 extern LARGE_INT total_downloaded_bytes;
 
 extern FILE *output_stream;
-extern int output_stream_regular;
+extern bool output_stream_regular;
 
 #ifndef MIN
 # define MIN(x, y) ((x) > (y) ? (y) : (x))
 #endif
 
 
-static int cookies_loaded_p;
+static bool cookies_loaded_p;
 static struct cookie_jar *wget_cookie_jar;
 
 #define TEXTHTML_S "text/html"
@@ -272,10 +272,10 @@ request_set_user_header (struct request *req, const char *header)
   request_set_header (req, xstrdup (name), (char *) p, rel_name);
 }
 
-/* Remove the header with specified name from REQ.  Returns 1 if the
-   header was actually removed, 0 otherwise.  */
+/* Remove the header with specified name from REQ.  Returns true if
+   the header was actually removed, false otherwise.  */
 
-static int
+static bool
 request_remove_header (struct request *req, char *name)
 {
   int i;
@@ -289,10 +289,10 @@ request_remove_header (struct request *req, char *name)
 	  if (i < req->hcount - 1)
 	    memmove (hdr, hdr + 1, (req->hcount - i - 1) * sizeof (*hdr));
 	  --req->hcount;
-	  return 1;
+	  return true;
 	}
     }
-  return 0;
+  return false;
 }
 
 #define APPEND(p, str) do {			\
@@ -600,12 +600,12 @@ resp_header_locate (const struct response *resp, const char *name, int start,
 
 /* Find and retrieve the header named NAME in the request data.  If
    found, set *BEGPTR to its starting, and *ENDPTR to its ending
-   position, and return 1.  Otherwise return 0.
+   position, and return true.  Otherwise return false.
 
    This function is used as a building block for resp_header_copy
    and resp_header_strdup.  */
 
-static int
+static bool
 resp_header_get (const struct response *resp, const char *name,
 		 const char **begptr, const char **endptr)
 {
@@ -615,26 +615,26 @@ resp_header_get (const struct response *resp, const char *name,
 
 /* Copy the response header named NAME to buffer BUF, no longer than
    BUFSIZE (BUFSIZE includes the terminating 0).  If the header
-   exists, 1 is returned, otherwise 0.  If there should be no limit on
-   the size of the header, use resp_header_strdup instead.
+   exists, true is returned, false otherwise.  If there should be no
+   limit on the size of the header, use resp_header_strdup instead.
 
    If BUFSIZE is 0, no data is copied, but the boolean indication of
    whether the header is present is still returned.  */
 
-static int
+static bool
 resp_header_copy (const struct response *resp, const char *name,
 		  char *buf, int bufsize)
 {
   const char *b, *e;
   if (!resp_header_get (resp, name, &b, &e))
-    return 0;
+    return false;
   if (bufsize)
     {
       int len = MIN (e - b, bufsize - 1);
       memcpy (buf, b, len);
       buf[len] = '\0';
     }
-  return 1;
+  return true;
 }
 
 /* Return the value of header named NAME in RESP, allocated with
@@ -749,8 +749,8 @@ print_server_response (const struct response *resp, const char *prefix)
 }
 
 /* Parse the `Content-Range' header and extract the information it
-   contains.  Returns 1 if successful, -1 otherwise.  */
-static int
+   contains.  Returns true if successful, false otherwise.  */
+static bool
 parse_content_range (const char *hdr, wgint *first_byte_ptr,
 		     wgint *last_byte_ptr, wgint *entity_length_ptr)
 {
@@ -759,7 +759,7 @@ parse_content_range (const char *hdr, wgint *first_byte_ptr,
   /* Ancient versions of Netscape proxy server, presumably predating
      rfc2068, sent out `Content-Range' without the "bytes"
      specifier.  */
-  if (!strncasecmp (hdr, "bytes", 5))
+  if (0 == strncasecmp (hdr, "bytes", 5))
     {
       hdr += 5;
       /* "JavaWebServer/1.1.1" sends "bytes: x-y/z", contrary to the
@@ -769,26 +769,26 @@ parse_content_range (const char *hdr, wgint *first_byte_ptr,
       while (ISSPACE (*hdr))
 	++hdr;
       if (!*hdr)
-	return 0;
+	return false;
     }
   if (!ISDIGIT (*hdr))
-    return 0;
+    return false;
   for (num = 0; ISDIGIT (*hdr); hdr++)
     num = 10 * num + (*hdr - '0');
   if (*hdr != '-' || !ISDIGIT (*(hdr + 1)))
-    return 0;
+    return false;
   *first_byte_ptr = num;
   ++hdr;
   for (num = 0; ISDIGIT (*hdr); hdr++)
     num = 10 * num + (*hdr - '0');
   if (*hdr != '/' || !ISDIGIT (*(hdr + 1)))
-    return 0;
+    return false;
   *last_byte_ptr = num;
   ++hdr;
   for (num = 0; ISDIGIT (*hdr); hdr++)
     num = 10 * num + (*hdr - '0');
   *entity_length_ptr = num;
-  return 1;
+  return true;
 }
 
 /* Read the body of the request, but don't store it anywhere and don't
@@ -797,10 +797,10 @@ parse_content_range (const char *hdr, wgint *first_byte_ptr,
    request.  The response is not useful to the user, but reading it
    allows us to continue using the same connection to the server.
 
-   If reading fails, 0 is returned, non-zero otherwise.  In debug
+   If reading fails, false is returned, true otherwise.  In debug
    mode, the body is displayed for debugging purposes.  */
 
-static int
+static bool
 skip_short_body (int fd, wgint contlen)
 {
   enum {
@@ -817,7 +817,7 @@ skip_short_body (int fd, wgint contlen)
   /* If the body is too large, it makes more sense to simply close the
      connection than to try to read the body.  */
   if (contlen > SKIP_THRESHOLD)
-    return 0;
+    return false;
 
   DEBUGP (("Skipping %s bytes of body: [", number_to_static_string (contlen)));
 
@@ -830,7 +830,7 @@ skip_short_body (int fd, wgint contlen)
 	     optimization that should be invisible to the user.  */
 	  DEBUGP (("] aborting (%s).\n",
 		   ret < 0 ? strerror (errno) : "EOF received"));
-	  return 0;
+	  return false;
 	}
       contlen -= ret;
       /* Safe even if %.*s bogusly expects terminating \0 because
@@ -839,7 +839,7 @@ skip_short_body (int fd, wgint contlen)
     }
 
   DEBUGP (("] done.\n"));
-  return 1;
+  return true;
 }
 
 /* Persistent connections.  Currently, we cache the most recently used
@@ -849,7 +849,7 @@ skip_short_body (int fd, wgint contlen)
    number of these connections.  */
 
 /* Whether a persistent connection is active. */
-static int pconn_active;
+static bool pconn_active;
 
 static struct {
   /* The socket of the connection.  */
@@ -860,13 +860,13 @@ static struct {
   int port;
 
   /* Whether a ssl handshake has occoured on this connection.  */
-  int ssl;
+  bool ssl;
 
   /* Whether the connection was authorized.  This is only done by
      NTLM, which authorizes *connections* rather than individual
      requests.  (That practice is peculiar for HTTP, but it is a
      useful optimization.)  */
-  int authorized;
+  bool authorized;
 
 #ifdef ENABLE_NTLM
   /* NTLM data of the current connection.  */
@@ -882,7 +882,7 @@ static void
 invalidate_persistent (void)
 {
   DEBUGP (("Disabling further reuse of socket %d.\n", pconn.socket));
-  pconn_active = 0;
+  pconn_active = false;
   fd_close (pconn.socket);
   xfree (pconn.host);
   xzero (pconn);
@@ -897,7 +897,7 @@ invalidate_persistent (void)
    If a previous connection was persistent, it is closed. */
 
 static void
-register_persistent (const char *host, int port, int fd, int ssl)
+register_persistent (const char *host, int port, int fd, bool ssl)
 {
   if (pconn_active)
     {
@@ -917,36 +917,36 @@ register_persistent (const char *host, int port, int fd, int ssl)
 	}
     }
 
-  pconn_active = 1;
+  pconn_active = true;
   pconn.socket = fd;
   pconn.host = xstrdup (host);
   pconn.port = port;
   pconn.ssl = ssl;
-  pconn.authorized = 0;
+  pconn.authorized = false;
 
   DEBUGP (("Registered socket %d for persistent reuse.\n", fd));
 }
 
-/* Return non-zero if a persistent connection is available for
-   connecting to HOST:PORT.  */
+/* Return true if a persistent connection is available for connecting
+   to HOST:PORT.  */
 
-static int
-persistent_available_p (const char *host, int port, int ssl,
-			int *host_lookup_failed)
+static bool
+persistent_available_p (const char *host, int port, bool ssl,
+			bool *host_lookup_failed)
 {
   /* First, check whether a persistent connection is active at all.  */
   if (!pconn_active)
-    return 0;
+    return false;
 
   /* If we want SSL and the last connection wasn't or vice versa,
      don't use it.  Checking for host and port is not enough because
      HTTP and HTTPS can apparently coexist on the same port.  */
   if (ssl != pconn.ssl)
-    return 0;
+    return false;
 
   /* If we're not connecting to the same port, we're not interested. */
   if (port != pconn.port)
-    return 0;
+    return false;
 
   /* If the host is the same, we're in business.  If not, there is
      still hope -- read below.  */
@@ -960,7 +960,7 @@ persistent_available_p (const char *host, int port, int ssl,
 	 admittedly unconventional optimization does not contradict
 	 HTTP and works well with popular server software.  */
 
-      int found;
+      bool found;
       ip_address ip;
       struct address_list *al;
 
@@ -968,7 +968,7 @@ persistent_available_p (const char *host, int port, int ssl,
 	/* Don't try to talk to two different SSL sites over the same
 	   secure connection!  (Besides, it's not clear that
 	   name-based virtual hosting is even possible with SSL.)  */
-	return 0;
+	return false;
 
       /* If pconn.socket's peer is one of the IP addresses HOST
 	 resolves to, pconn.socket is for all intents and purposes
@@ -979,20 +979,20 @@ persistent_available_p (const char *host, int port, int ssl,
 	  /* Can't get the peer's address -- something must be very
 	     wrong with the connection.  */
 	  invalidate_persistent ();
-	  return 0;
+	  return false;
 	}
       al = lookup_host (host, 0);
       if (!al)
 	{
-	  *host_lookup_failed = 1;
-	  return 0;
+	  *host_lookup_failed = true;
+	  return false;
 	}
 
       found = address_list_contains (al, &ip);
       address_list_release (al);
 
       if (!found)
-	return 0;
+	return false;
 
       /* The persistent connection's peer address was found among the
 	 addresses HOST resolved to; therefore, pconn.sock is in fact
@@ -1012,10 +1012,10 @@ persistent_available_p (const char *host, int port, int ssl,
          let's invalidate the persistent connection before returning
          0.  */
       invalidate_persistent ();
-      return 0;
+      return false;
     }
 
-  return 1;
+  return true;
 }
 
 /* The idea behind these two CLOSE macros is to distinguish between
@@ -1057,14 +1057,14 @@ persistent_available_p (const char *host, int port, int ssl,
 struct http_stat
 {
   wgint len;			/* received length */
-  wgint contlen;			/* expected length */
-  wgint restval;			/* the restart value */
+  wgint contlen;		/* expected length */
+  wgint restval;		/* the restart value */
   int res;			/* the result of last read */
   char *newloc;			/* new location (redirection) */
   char *remote_time;		/* remote time-stamp string */
   char *error;			/* textual HTTP error */
   int statcode;			/* status code */
-  wgint rd_size;			/* amount of data read from socket */
+  wgint rd_size;		/* amount of data read from socket */
   double dltime;		/* time it took to download the data */
   const char *referer;		/* value of the referer header. */
   char **local_file;		/* local file. */
@@ -1085,9 +1085,9 @@ free_hstat (struct http_stat *hs)
 
 static char *create_authorization_line (const char *, const char *,
 					const char *, const char *,
-					const char *, int *);
+					const char *, bool *);
 static char *basic_authentication_encode (const char *, const char *);
-static int known_authentication_scheme_p (const char *, const char *);
+static bool known_authentication_scheme_p (const char *, const char *);
 
 time_t http_atotm (const char *);
 
@@ -1139,17 +1139,17 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 
   /* Set to 1 when the authorization has failed permanently and should
      not be tried again. */
-  int auth_finished = 0;
+  bool auth_finished = false;
 
   /* Whether NTLM authentication is used for this request. */
-  int ntlm_seen = 0;
+  bool ntlm_seen = false;
 
   /* Whether our connection to the remote host is through SSL.  */
-  int using_ssl = 0;
+  bool using_ssl = false;
 
   /* Whether a HEAD request will be issued (as opposed to GET or
      POST). */
-  int head_only = *dt & HEAD_ONLY;
+  bool head_only = !!(*dt & HEAD_ONLY);
 
   char *head;
   struct response *resp;
@@ -1158,7 +1158,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 
   /* Whether this connection will be kept alive after the HTTP request
      is done. */
-  int keep_alive;
+  bool keep_alive;
 
   /* Whether keep-alive should be inhibited.
 
@@ -1167,13 +1167,13 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
      the Connection header and transfer it to the remote server,
      causing it to not close the connection and leave both the proxy
      and the client hanging.  */
-  int inhibit_keep_alive =
+  bool inhibit_keep_alive =
     !opt.http_keep_alive || opt.ignore_length || proxy != NULL;
 
   /* Headers sent when using POST. */
   wgint post_data_size = 0;
 
-  int host_lookup_failed = 0;
+  bool host_lookup_failed = false;
 
 #ifdef HAVE_SSL
   if (u->scheme == SCHEME_HTTPS)
@@ -1316,7 +1316,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
     /* Whether we need to print the host header with braces around
        host, e.g. "Host: [3ffe:8100:200:2::2]:1234" instead of the
        usual "Host: symbolic-name:1234". */
-    int squares = strchr (u->host, ':') != NULL;
+    bool squares = strchr (u->host, ':') != NULL;
     if (u->port == scheme_default_port (u->scheme))
       request_set_header (req, "Host",
 			  aprintf (squares ? "[%s]" : "%s", u->host),
@@ -1377,7 +1377,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
      without authorization header fails.  (Expected to happen at least
      for the Digest authorization scheme.)  */
 
-  keep_alive = 0;
+  keep_alive = false;
 
   /* Establish the connection.  */
 
@@ -1514,7 +1514,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 	      fd_close (sock);
 	      return CONSSLERR;
 	    }
-	  using_ssl = 1;
+	  using_ssl = true;
 	}
 #endif /* HAVE_SSL */
     }
@@ -1603,11 +1603,11 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
   if (!inhibit_keep_alive && contlen != -1)
     {
       if (resp_header_copy (resp, "Keep-Alive", NULL, 0))
-	keep_alive = 1;
+	keep_alive = true;
       else if (resp_header_copy (resp, "Connection", hdrval, sizeof (hdrval)))
 	{
 	  if (0 == strcasecmp (hdrval, "Keep-Alive"))
-	    keep_alive = 1;
+	    keep_alive = true;
 	}
     }
   if (keep_alive)
@@ -1622,7 +1622,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 	CLOSE_FINISH (sock);
       else
 	CLOSE_INVALIDATE (sock);
-      pconn.authorized = 0;
+      pconn.authorized = false;
       if (!auth_finished && (user && passwd))
 	{
 	  /* IIS sends multiple copies of WWW-Authenticate, one with
@@ -1663,7 +1663,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 							     &auth_finished),
 				  rel_value);
 	      if (BEGINS_WITH (www_authenticate, "NTLM"))
-		ntlm_seen = 1;
+		ntlm_seen = true;
 	      xfree (pth);
 	      goto retry_with_auth;
 	    }
@@ -1676,7 +1676,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
     {
       /* Kludge: if NTLM is used, mark the TCP connection as authorized. */
       if (ntlm_seen)
-	pconn.authorized = 1;
+	pconn.authorized = true;
     }
   request_free (req);
 
@@ -1900,7 +1900,7 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
 	fp = fopen (*hs->local_file, "wb");
       else
 	{
-	  fp = fopen_excl (*hs->local_file, 1);
+	  fp = fopen_excl (*hs->local_file, true);
 	  if (!fp && errno == EEXIST)
 	    {
 	      /* We cannot just invent a new name and use it (which is
@@ -1975,7 +1975,7 @@ http_loop (struct url *u, char **newloc, char **local_file, const char *referer,
 	   int *dt, struct url *proxy)
 {
   int count;
-  int use_ts, got_head = 0;	/* time-stamping info */
+  bool use_ts, got_head = false;/* time-stamping info */
   char *filename_plus_orig_suffix;
   char *local_filename = NULL;
   char *tms, *locf, *tmrate;
@@ -1997,7 +1997,7 @@ http_loop (struct url *u, char **newloc, char **local_file, const char *referer,
       if (opt.cookies_input && !cookies_loaded_p)
 	{
 	  cookie_jar_load (wget_cookie_jar, opt.cookies_input);
-	  cookies_loaded_p = 1;
+	  cookies_loaded_p = true;
 	}
     }
 
@@ -2054,10 +2054,10 @@ File `%s' already there; not retrieving.\n\n"), *hstat.local_file);
       return RETROK;
     }
 
-  use_ts = 0;
+  use_ts = false;
   if (opt.timestamping)
     {
-      int local_dot_orig_file_exists = 0;
+      bool local_dot_orig_file_exists = false;
 
       if (opt.backup_converted)
 	/* If -K is specified, we'll act on the assumption that it was specified
@@ -2099,7 +2099,7 @@ File `%s' already there; not retrieving.\n\n"), *hstat.local_file);
 	   the server has is the same version we already have, allowing us to
 	   skip a download. */
 	{
-	  use_ts = 1;
+	  use_ts = true;
 	  tml = st.st_mtime;
 #ifdef WINDOWS
 	  /* Modification time granularity is 2 seconds for Windows, so
@@ -2107,7 +2107,7 @@ File `%s' already there; not retrieving.\n\n"), *hstat.local_file);
 	  tml++;
 #endif
 	  local_size = st.st_size;
-	  got_head = 0;
+	  got_head = false;
 	}
     }
   /* Reset the counter.  */
@@ -2124,7 +2124,7 @@ File `%s' already there; not retrieving.\n\n"), *hstat.local_file);
       /* Print fetch message, if opt.verbose.  */
       if (opt.verbose)
 	{
-	  char *hurl = url_string (u, 1);
+	  char *hurl = url_string (u, true);
 	  char tmp[256];
 	  strcpy (tmp, "        ");
 	  if (count > 1)
@@ -2272,7 +2272,7 @@ File `%s' already there; not retrieving.\n\n"), *hstat.local_file);
 	  if (!opt.verbose)
 	    {
 	      /* #### Ugly ugly ugly! */
-	      char *hurl = url_string (u, 1);
+	      char *hurl = url_string (u, true);
 	      logprintf (LOG_NONVERBOSE, "%s:\n", hurl);
 	      xfree (hurl);
 	    }
@@ -2305,9 +2305,9 @@ Last-modified header invalid -- time-stamp ignored.\n"));
       /* The time-stamping section.  */
       if (use_ts)
 	{
-	  got_head = 1;
+	  got_head = true;
 	  *dt &= ~HEAD_ONLY;
-	  use_ts = 0;		/* no more time-stamping */
+	  use_ts = false;		/* no more time-stamping */
 	  count = 0;		/* the retrieve count for HEAD is
 				   reset */
 	  if (hstat.remote_time && tmr != (time_t) (-1))
@@ -2583,19 +2583,19 @@ mktime_from_utc (struct tm *t)
    In extended regexp parlance, the function returns 1 if P matches
    "^ *(GMT|[+-][0-9]|$)", 0 otherwise.  P being NULL (which strptime
    can return) is considered a failure and 0 is returned.  */
-static int
+static bool
 check_end (const char *p)
 {
   if (!p)
-    return 0;
+    return false;
   while (ISSPACE (*p))
     ++p;
   if (!*p
       || (p[0] == 'G' && p[1] == 'M' && p[2] == 'T')
       || ((p[0] == '+' || p[0] == '-') && ISDIGIT (p[1])))
-    return 1;
+    return true;
   else
-    return 0;
+    return false;
 }
 
 /* Convert the textual specification of time in TIME_STRING to the
@@ -2907,7 +2907,7 @@ username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"",
    && ((e) - (b) == STRSIZE (literal)			\
        || ISSPACE (b[STRSIZE (literal)])))
 
-static int
+static bool
 known_authentication_scheme_p (const char *hdrbeg, const char *hdrend)
 {
   return STARTS ("Basic", hdrbeg, hdrend)
@@ -2930,25 +2930,25 @@ known_authentication_scheme_p (const char *hdrbeg, const char *hdrend)
 static char *
 create_authorization_line (const char *au, const char *user,
 			   const char *passwd, const char *method,
-			   const char *path, int *finished)
+			   const char *path, bool *finished)
 {
   /* We are called only with known schemes, so we can dispatch on the
      first letter. */
   switch (TOUPPER (*au))
     {
     case 'B':			/* Basic */
-      *finished = 1;
+      *finished = true;
       return basic_authentication_encode (user, passwd);
 #ifdef ENABLE_DIGEST
     case 'D':			/* Digest */
-      *finished = 1;
+      *finished = true;
       return digest_authentication_encode (au, user, passwd, method, path);
 #endif
 #ifdef ENABLE_NTLM
     case 'N':			/* NTLM */
       if (!ntlm_input (&pconn.ntlm, au))
 	{
-	  *finished = 1;
+	  *finished = true;
 	  return NULL;
 	}
       return ntlm_output (&pconn.ntlm, user, passwd, finished);
diff --git a/src/init.c b/src/init.c
index d3d0f9b..c81a67b 100644
--- a/src/init.c
+++ b/src/init.c
@@ -56,10 +56,10 @@ so, delete this exception statement from your version.  */
    otherwise, it will be performed by the shell.  This variable will
    be set by the wgetrc-reading function.  */
 
-static int enable_tilde_expansion;
+static bool enable_tilde_expansion;
 
 
-#define CMD_DECLARE(func) static int func (const char *, const char *, void *)
+#define CMD_DECLARE(func) static bool func (const char *, const char *, void *)
 
 CMD_DECLARE (cmd_boolean);
 CMD_DECLARE (cmd_bytes);
@@ -100,7 +100,7 @@ CMD_DECLARE (cmd_spec_useragent);
 static struct {
   const char *name;
   void *place;
-  int (*action) (const char *, const char *, void *);
+  bool (*action) (const char *, const char *, void *);
 } commands[] = {
   { "accept",		&opt.accepts,		cmd_vector },
   { "addhostdir",	&opt.add_hostdir,	cmd_boolean },
@@ -265,42 +265,42 @@ defaults (void)
 {
   char *tmp;
 
-  /* Most of the default values are 0.  Just reset everything, and
-     fill in the non-zero values.  Note that initializing pointers to
-     NULL this way is technically illegal, but porting Wget to a
-     machine where NULL is not all-zero bit pattern will be the least
-     of the implementors' worries.  */
+  /* Most of the default values are 0 (and 0.0, NULL, and false).
+     Just reset everything, and fill in the non-zero values.  Note
+     that initializing pointers to NULL this way is technically
+     illegal, but porting Wget to a machine where NULL is not all-zero
+     bit pattern will be the least of the implementors' worries.  */
   xzero (opt);
 
-  opt.cookies = 1;
+  opt.cookies = true;
   opt.verbose = -1;
   opt.ntry = 20;
   opt.reclevel = 5;
-  opt.add_hostdir = 1;
-  opt.netrc = 1;
-  opt.ftp_glob = 1;
-  opt.htmlify = 1;
-  opt.http_keep_alive = 1;
-  opt.use_proxy = 1;
+  opt.add_hostdir = true;
+  opt.netrc = true;
+  opt.ftp_glob = true;
+  opt.htmlify = true;
+  opt.http_keep_alive = true;
+  opt.use_proxy = true;
   tmp = getenv ("no_proxy");
   if (tmp)
     opt.no_proxy = sepstring (tmp);
-  opt.allow_cache = 1;
+  opt.allow_cache = true;
 
   opt.read_timeout = 900;
-  opt.use_robots = 1;
+  opt.use_robots = true;
 
-  opt.remove_listing = 1;
+  opt.remove_listing = true;
 
   opt.dot_bytes = 1024;
   opt.dot_spacing = 10;
   opt.dots_in_line = 50;
 
-  opt.dns_cache = 1;
-  opt.ftp_pasv = 1;
+  opt.dns_cache = true;
+  opt.ftp_pasv = true;
 
 #ifdef HAVE_SSL
-  opt.check_cert = 1;
+  opt.check_cert = true;
 #endif
 
   /* The default for file name restriction defaults to the OS type. */
@@ -309,7 +309,7 @@ defaults (void)
 #else
   opt.restrict_files_os = restrict_windows;
 #endif
-  opt.restrict_files_ctrl = 1;
+  opt.restrict_files_ctrl = true;
 }
 
 /* Return the user's home directory (strdup-ed), or NULL if none is
@@ -402,12 +402,12 @@ enum parse_line {
 };
 
 static enum parse_line parse_line (const char *, char **, char **, int *);
-static int setval_internal (int, const char *, const char *);
+static bool setval_internal (int, const char *, const char *);
 
 /* Initialize variables from a wgetrc file.  Returns zero (failure) if
    there were errors in the file.  */
 
-static int
+static bool
 run_wgetrc (const char *file)
 {
   FILE *fp;
@@ -420,9 +420,9 @@ run_wgetrc (const char *file)
     {
       fprintf (stderr, _("%s: Cannot read %s (%s).\n"), exec_name,
 	       file, strerror (errno));
-      return 1;			/* not a fatal error */
+      return true;			/* not a fatal error */
     }
-  enable_tilde_expansion = 1;
+  enable_tilde_expansion = true;
   ln = 1;
   while ((line = read_whole_line (fp)) != NULL)
     {
@@ -461,7 +461,7 @@ run_wgetrc (const char *file)
       xfree (line);
       ++ln;
     }
-  enable_tilde_expansion = 0;
+  enable_tilde_expansion = false;
   fclose (fp);
 
   return errcnt == 0;
@@ -473,7 +473,7 @@ void
 initialize (void)
 {
   char *file;
-  int ok = 1;
+  int ok = true;
 
   /* Load the hard-coded defaults.  */
   defaults ();
@@ -527,7 +527,6 @@ dehyphen (char *s)
 /* Parse the line pointed by line, with the syntax:
    <sp>* command <sp>* = <sp>* value <sp>*
    Uses malloc to allocate space for command and value.
-   If the line is invalid, data is freed and 0 is returned.
 
    Returns one of line_ok, line_empty, line_syntax_error, or
    line_unknown_command.
@@ -596,7 +595,7 @@ parse_line (const char *line, char **com, char **val, int *comind)
 
 /* Run commands[comind].action. */
 
-static int
+static bool
 setval_internal (int comind, const char *com, const char *val)
 {
   assert (0 <= comind && comind < countof (commands));
@@ -659,9 +658,9 @@ struct decode_item {
   const char *name;
   int code;
 };
-static int decode_string (const char *, const struct decode_item *, int, int *);
-static int simple_atoi (const char *, const char *, int *);
-static int simple_atof (const char *, const char *, double *);
+static bool decode_string (const char *, const struct decode_item *, int, int *);
+static bool simple_atoi (const char *, const char *, int *);
+static bool simple_atof (const char *, const char *, double *);
 
 #define CMP1(p, c0) (TOLOWER((p)[0]) == (c0) && (p)[1] == '\0')
 
@@ -677,32 +676,32 @@ static int simple_atof (const char *, const char *, double *);
 
 /* Store the boolean value from VAL to PLACE.  COM is ignored,
    except for error messages.  */
-static int
+static bool
 cmd_boolean (const char *com, const char *val, void *place)
 {
-  int bool_value;
+  bool value;
 
   if (CMP2 (val, 'o', 'n') || CMP3 (val, 'y', 'e', 's') || CMP1 (val, '1'))
     /* "on", "yes" and "1" mean true. */
-    bool_value = 1;
+    value = true;
   else if (CMP3 (val, 'o', 'f', 'f') || CMP2 (val, 'n', 'o') || CMP1 (val, '0'))
     /* "off", "no" and "0" mean false. */
-    bool_value = 0;
+    value = false;
   else
     {
       fprintf (stderr,
 	       _("%s: %s: Invalid boolean `%s'; use `on' or `off'.\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
 
-  *(int *)place = bool_value;
-  return 1;
+  *(bool *) place = value;
+  return true;
 }
 
 /* Set the non-negative integer value from VAL to PLACE.  With
    incorrect specification, the number remains unchanged.  */
-static int
+static bool
 cmd_number (const char *com, const char *val, void *place)
 {
   if (!simple_atoi (val, val + strlen (val), place)
@@ -710,33 +709,33 @@ cmd_number (const char *com, const char *val, void *place)
     {
       fprintf (stderr, _("%s: %s: Invalid number `%s'.\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
-  return 1;
+  return true;
 }
 
 /* Similar to cmd_number(), only accepts `inf' as a synonym for 0.  */
-static int
+static bool
 cmd_number_inf (const char *com, const char *val, void *place)
 {
   if (!strcasecmp (val, "inf"))
     {
-      *(int *)place = 0;
-      return 1;
+      *(int *) place = 0;
+      return true;
     }
   return cmd_number (com, val, place);
 }
 
 /* Copy (strdup) the string at COM to a new location and place a
    pointer to *PLACE.  */
-static int
+static bool
 cmd_string (const char *com, const char *val, void *place)
 {
   char **pstring = (char **)place;
 
   xfree_null (*pstring);
   *pstring = xstrdup (val);
-  return 1;
+  return true;
 }
 
 #ifndef WINDOWS
@@ -748,7 +747,7 @@ cmd_string (const char *com, const char *val, void *place)
 /* Like the above, but handles tilde-expansion when reading a user's
    `.wgetrc'.  In that case, and if VAL begins with `~', the tilde
    gets expanded to the user's home directory.  */
-static int
+static bool
 cmd_file (const char *com, const char *val, void *place)
 {
   char **pstring = (char **)place;
@@ -789,11 +788,11 @@ cmd_file (const char *com, const char *val, void *place)
 	*s = '/';
   }
 #endif
-  return 1;
+  return true;
 }
 
 /* Like cmd_file, but strips trailing '/' characters.  */
-static int
+static bool
 cmd_directory (const char *com, const char *val, void *place)
 {
   char *s, *t;
@@ -802,21 +801,21 @@ cmd_directory (const char *com, const char *val, void *place)
      canonicalization (backslash -> slash under Windows).  These
      things should perhaps be in a separate function.  */
   if (!cmd_file (com, val, place))
-    return 0;
+    return false;
 
   s = *(char **)place;
   t = s + strlen (s);
   while (t > s && *--t == '/')
     *t = '\0';
 
-  return 1;
+  return true;
 }
 
 /* Split VAL by space to a vector of values, and append those values
    to vector pointed to by the PLACE argument.  If VAL is empty, the
    PLACE vector is cleared instead.  */
 
-static int
+static bool
 cmd_vector (const char *com, const char *val, void *place)
 {
   char ***pvec = (char ***)place;
@@ -828,10 +827,10 @@ cmd_vector (const char *com, const char *val, void *place)
       free_vec (*pvec);
       *pvec = NULL;
     }
-  return 1;
+  return true;
 }
 
-static int
+static bool
 cmd_directory_vector (const char *com, const char *val, void *place)
 {
   char ***pvec = (char ***)place;
@@ -859,13 +858,13 @@ cmd_directory_vector (const char *com, const char *val, void *place)
       free_vec (*pvec);
       *pvec = NULL;
     }
-  return 1;
+  return true;
 }
 
 /* Engine for cmd_bytes and cmd_bytes_large: converts a string such as
    "100k" or "2.5G" to a floating point number.  */
 
-static int
+static bool
 parse_bytes_helper (const char *val, double *result)
 {
   double number, mult;
@@ -875,14 +874,14 @@ parse_bytes_helper (const char *val, double *result)
   if (0 == strcmp (val, "inf"))
     {
       *result = 0;
-      return 1;
+      return true;
     }
 
   /* Strip trailing whitespace.  */
   while (val < end && ISSPACE (end[-1]))
     --end;
   if (val == end)
-    return 0;
+    return false;
 
   switch (TOLOWER (end[-1]))
     {
@@ -910,13 +909,13 @@ parse_bytes_helper (const char *val, double *result)
   while (val < end && ISSPACE (end[-1]))
     --end;
   if (val == end)
-    return 0;
+    return false;
 
   if (!simple_atof (val, end, &number) || number < 0)
-    return 0;
+    return false;
 
   *result = number * mult;
-  return 1;
+  return true;
 }
 
 /* Parse VAL as a number and set its value to PLACE (which should
@@ -930,10 +929,10 @@ parse_bytes_helper (const char *val, double *result)
 
    The string "inf" is returned as 0.
 
-   In case of error, 0 is returned and memory pointed to by PLACE
+   In case of error, false is returned and memory pointed to by PLACE
    remains unmodified.  */
 
-static int
+static bool
 cmd_bytes (const char *com, const char *val, void *place)
 {
   double byte_value;
@@ -941,10 +940,10 @@ cmd_bytes (const char *com, const char *val, void *place)
     {
       fprintf (stderr, _("%s: %s: Invalid byte value `%s'\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
   *(wgint *)place = (wgint)byte_value;
-  return 1;
+  return true;
 }
 
 /* Like cmd_bytes, but PLACE is interpreted as a pointer to
@@ -952,7 +951,7 @@ cmd_bytes (const char *com, const char *val, void *place)
    working with values up to 2^53-1 without loss of precision.  This
    value (8192 TB) is large enough to serve for a while.  */
 
-static int
+static bool
 cmd_bytes_large (const char *com, const char *val, void *place)
 {
   double byte_value;
@@ -960,17 +959,17 @@ cmd_bytes_large (const char *com, const char *val, void *place)
     {
       fprintf (stderr, _("%s: %s: Invalid byte value `%s'\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
   *(LARGE_INT *)place = (LARGE_INT)byte_value;
-  return 1;
+  return true;
 }
 
 /* Store the value of VAL to *OUT.  The value is a time period, by
    default expressed in seconds, but also accepting suffixes "m", "h",
    "d", and "w" for minutes, hours, days, and weeks respectively.  */
 
-static int
+static bool
 cmd_time (const char *com, const char *val, void *place)
 {
   double number, mult;
@@ -985,7 +984,7 @@ cmd_time (const char *com, const char *val, void *place)
     err:
       fprintf (stderr, _("%s: %s: Invalid time period `%s'\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
 
   switch (TOLOWER (end[-1]))
@@ -1023,11 +1022,11 @@ cmd_time (const char *com, const char *val, void *place)
     goto err;
 
   *(double *)place = number * mult;
-  return 1;
+  return true;
 }
 
 #ifdef HAVE_SSL
-static int
+static bool
 cmd_cert_type (const char *com, const char *val, void *place)
 {
   static const struct decode_item choices[] = {
@@ -1045,23 +1044,23 @@ cmd_cert_type (const char *com, const char *val, void *place)
 /* Specialized helper functions, used by `commands' to handle some
    options specially.  */
 
-static int check_user_specified_header (const char *);
+static bool check_user_specified_header (const char *);
 
-static int
+static bool
 cmd_spec_dirstruct (const char *com, const char *val, void *place_ignored)
 {
   if (!cmd_boolean (com, val, &opt.dirstruct))
-    return 0;
+    return false;
   /* Since dirstruct behaviour is explicitly changed, no_dirstruct
      must be affected inversely.  */
   if (opt.dirstruct)
-    opt.no_dirstruct = 0;
+    opt.no_dirstruct = false;
   else
-    opt.no_dirstruct = 1;
-  return 1;
+    opt.no_dirstruct = true;
+  return true;
 }
 
-static int
+static bool
 cmd_spec_header (const char *com, const char *val, void *place_ignored)
 {
   /* Empty value means reset the list of headers. */
@@ -1069,54 +1068,54 @@ cmd_spec_header (const char *com, const char *val, void *place_ignored)
     {
       free_vec (opt.user_headers);
       opt.user_headers = NULL;
-      return 1;
+      return true;
     }
 
   if (!check_user_specified_header (val))
     {
       fprintf (stderr, _("%s: %s: Invalid header `%s'.\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
   opt.user_headers = vec_append (opt.user_headers, val);
-  return 1;
+  return true;
 }
 
-static int
+static bool
 cmd_spec_htmlify (const char *com, const char *val, void *place_ignored)
 {
   int flag = cmd_boolean (com, val, &opt.htmlify);
   if (flag && !opt.htmlify)
-    opt.remove_listing = 0;
+    opt.remove_listing = false;
   return flag;
 }
 
 /* Set the "mirror" mode.  It means: recursive download, timestamping,
    no limit on max. recursion depth, and don't remove listings.  */
 
-static int
+static bool
 cmd_spec_mirror (const char *com, const char *val, void *place_ignored)
 {
   int mirror;
 
   if (!cmd_boolean (com, val, &mirror))
-    return 0;
+    return false;
   if (mirror)
     {
-      opt.recursive = 1;
+      opt.recursive = true;
       if (!opt.no_dirstruct)
-	opt.dirstruct = 1;
-      opt.timestamping = 1;
+	opt.dirstruct = true;
+      opt.timestamping = true;
       opt.reclevel = INFINITE_RECURSION;
-      opt.remove_listing = 0;
+      opt.remove_listing = false;
     }
-  return 1;
+  return true;
 }
 
 /* Validate --prefer-family and set the choice.  Allowed values are
    "IPv4", "IPv6", and "none".  */
 
-static int
+static bool
 cmd_spec_prefer_family (const char *com, const char *val, void *place_ignored)
 {
   static const struct decode_item choices[] = {
@@ -1134,41 +1133,41 @@ cmd_spec_prefer_family (const char *com, const char *val, void *place_ignored)
 /* Set progress.type to VAL, but verify that it's a valid progress
    implementation before that.  */
 
-static int
+static bool
 cmd_spec_progress (const char *com, const char *val, void *place_ignored)
 {
   if (!valid_progress_implementation_p (val))
     {
       fprintf (stderr, _("%s: %s: Invalid progress type `%s'.\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
   xfree_null (opt.progress_type);
 
   /* Don't call set_progress_implementation here.  It will be called
      in main() when it becomes clear what the log output is.  */
   opt.progress_type = xstrdup (val);
-  return 1;
+  return true;
 }
 
 /* Set opt.recursive to VAL as with cmd_boolean.  If opt.recursive is
-   set to true, also set opt.dirstruct to 1, unless opt.no_dirstruct
+   set to true, also set opt.dirstruct to true, unless opt.no_dirstruct
    is specified.  */
 
-static int
+static bool
 cmd_spec_recursive (const char *com, const char *val, void *place_ignored)
 {
   if (!cmd_boolean (com, val, &opt.recursive))
-    return 0;
+    return false;
   else
     {
       if (opt.recursive && !opt.no_dirstruct)
-	opt.dirstruct = 1;
+	opt.dirstruct = true;
     }
-  return 1;
+  return true;
 }
 
-static int
+static bool
 cmd_spec_restrict_file_names (const char *com, const char *val, void *place_ignored)
 {
   int restrict_os = opt.restrict_files_os;
@@ -1192,7 +1191,7 @@ cmd_spec_restrict_file_names (const char *com, const char *val, void *place_igno
       fprintf (stderr,
 	       _("%s: %s: Invalid restriction `%s', use `unix' or `windows'.\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
 
 #undef VAL_IS
@@ -1200,18 +1199,18 @@ cmd_spec_restrict_file_names (const char *com, const char *val, void *place_igno
   if (*end)
     {
       if (!strcmp (end + 1, "nocontrol"))
-	restrict_ctrl = 0;
+	restrict_ctrl = false;
       else
 	goto err;
     }
 
   opt.restrict_files_os = restrict_os;
   opt.restrict_files_ctrl = restrict_ctrl;
-  return 1;
+  return true;
 }
 
 #ifdef HAVE_SSL
-static int
+static bool
 cmd_spec_secure_protocol (const char *com, const char *val, void *place)
 {
   static const struct decode_item choices[] = {
@@ -1229,19 +1228,19 @@ cmd_spec_secure_protocol (const char *com, const char *val, void *place)
 
 /* Set all three timeout values. */
 
-static int
+static bool
 cmd_spec_timeout (const char *com, const char *val, void *place_ignored)
 {
   double value;
   if (!cmd_time (com, val, &value))
-    return 0;
+    return false;
   opt.read_timeout = value;
   opt.connect_timeout = value;
   opt.dns_timeout = value;
-  return 1;
+  return true;
 }
 
-static int
+static bool
 cmd_spec_useragent (const char *com, const char *val, void *place_ignored)
 {
   /* Disallow embedded newlines.  */
@@ -1249,24 +1248,24 @@ cmd_spec_useragent (const char *com, const char *val, void *place_ignored)
     {
       fprintf (stderr, _("%s: %s: Invalid value `%s'.\n"),
 	       exec_name, com, val);
-      return 0;
+      return false;
     }
   xfree_null (opt.useragent);
   opt.useragent = xstrdup (val);
-  return 1;
+  return true;
 }
 
 /* Miscellaneous useful routines.  */
 
 /* A very simple atoi clone, more useful than atoi because it works on
-   delimited strings, and has error reportage.  Returns 1 on success,
-   0 on failure.  If successful, stores result to *DEST.  */
+   delimited strings, and has error reportage.  Returns true on success,
+   false on failure.  If successful, stores result to *DEST.  */
 
-static int
+static bool
 simple_atoi (const char *beg, const char *end, int *dest)
 {
   int result = 0;
-  int negative = 0;
+  bool negative = false;
   const char *p = beg;
 
   while (p < end && ISSPACE (*p))
@@ -1277,7 +1276,7 @@ simple_atoi (const char *beg, const char *end, int *dest)
       ++p;
     }
   if (p == end)
-    return 0;
+    return false;
 
   /* Read negative numbers in a separate loop because the most
      negative integer cannot be represented as a positive number.  */
@@ -1287,7 +1286,7 @@ simple_atoi (const char *beg, const char *end, int *dest)
       {
 	int next = (10 * result) + (*p - '0');
 	if (next < result)
-	  return 0;		/* overflow */
+	  return false;		/* overflow */
 	result = next;
       }
   else
@@ -1295,29 +1294,30 @@ simple_atoi (const char *beg, const char *end, int *dest)
       {
 	int next = (10 * result) - (*p - '0');
 	if (next > result)
-	  return 0;		/* underflow */
+	  return false;		/* underflow */
 	result = next;
       }
 
   if (p != end)
-    return 0;
+    return false;
 
   *dest = result;
-  return 1;
+  return true;
 }
 
 /* Trivial atof, with error reporting.  Handles "<digits>[.<digits>]",
-   doesn't handle exponential notation.  Returns 1 on success, 0 on
-   failure.  In case of success, stores its result to *DEST.  */
+   doesn't handle exponential notation.  Returns true on success,
+   false on failure.  In case of success, stores its result to
+   *DEST.  */
 
-static int
+static bool
 simple_atof (const char *beg, const char *end, double *dest)
 {
   double result = 0;
 
-  int negative = 0;
-  int seen_dot = 0;
-  int seen_digit = 0;
+  bool negative = false;
+  bool seen_dot = false;
+  bool seen_digit = false;
   double divider = 1;
 
   const char *p = beg;
@@ -1339,32 +1339,32 @@ simple_atof (const char *beg, const char *end, double *dest)
 	    result = (10 * result) + (ch - '0');
 	  else
 	    result += (ch - '0') / (divider *= 10);
-	  seen_digit = 1;
+	  seen_digit = true;
 	}
       else if (ch == '.')
 	{
 	  if (!seen_dot)
-	    seen_dot = 1;
+	    seen_dot = true;
 	  else
-	    return 0;
+	    return false;
 	}
       else
-	return 0;
+	return false;
     }
   if (!seen_digit)
-    return 0;
+    return false;
   if (negative)
     result = -result;
 
   *dest = result;
-  return 1;
+  return true;
 }
 
 /* Verify that the user-specified header in S is valid.  It must
    contain a colon preceded by non-white-space characters and must not
    contain newlines.  */
 
-static int
+static bool
 check_user_specified_header (const char *s)
 {
   const char *p;
@@ -1373,16 +1373,16 @@ check_user_specified_header (const char *s)
   /* The header MUST contain `:' preceded by at least one
      non-whitespace character.  */
   if (*p != ':' || p == s)
-    return 0;
+    return false;
   /* The header MUST NOT contain newlines.  */
   if (strchr (s, '\n'))
-    return 0;
-  return 1;
+    return false;
+  return true;
 }
 
 /* Decode VAL into a number, according to ITEMS. */
 
-static int
+static bool
 decode_string (const char *val, const struct decode_item *items, int itemcount,
 	       int *place)
 {
@@ -1391,9 +1391,9 @@ decode_string (const char *val, const struct decode_item *items, int itemcount,
     if (0 == strcasecmp (val, items[i].name))
       {
 	*place = items[i].code;
-	return 1;
+	return true;
       }
-  return 0;
+  return false;
 }
 
 
diff --git a/src/log.c b/src/log.c
index d0b5370..8285c7e 100644
--- a/src/log.c
+++ b/src/log.c
@@ -68,18 +68,18 @@ so, delete this exception statement from your version.  */
    logging is inhibited, logfp is set back to NULL. */
 static FILE *logfp;
 
-/* If non-zero, it means logging is inhibited, i.e. nothing is printed
-   or stored.  */
-static int inhibit_logging;
+/* If true, it means logging is inhibited, i.e. nothing is printed or
+   stored.  */
+static bool inhibit_logging;
 
 /* Whether the last output lines are stored for use as context.  */
-static int save_context_p;
+static bool save_context_p;
 
 /* Whether the log is flushed after each command. */
-static int flush_log_p = 1;
+static bool flush_log_p = true;
 
 /* Whether any output has been received while flush_log_p was 0. */
-static int needs_flushing;
+static bool needs_flushing;
 
 /* In the event of a hang-up, and if its output was on a TTY, Wget
    redirects its output to `wget-log'.
@@ -123,7 +123,7 @@ static int log_line_current = -1;
    finish with \n.  This is an important piece of information because
    the code is always careful to append data to trailing lines, rather
    than create new ones.  */
-static int trailing_line;
+static bool trailing_line;
 
 static void check_redirect_output (void);
 
@@ -313,7 +313,7 @@ logputs (enum log_options o, const char *s)
   if (flush_log_p)
     logflush ();
   else
-    needs_flushing = 1;
+    needs_flushing = true;
 }
 
 struct logvprintf_state {
@@ -336,7 +336,7 @@ struct logvprintf_state {
    (An alternative approach would be to use va_copy, but that's not
    portable.)  */
 
-static int
+static bool
 log_vprintf_internal (struct logvprintf_state *state, const char *fmt,
 		      va_list args)
 {
@@ -383,7 +383,7 @@ log_vprintf_internal (struct logvprintf_state *state, const char *fmt,
       int newsize = available_size << 1;
       state->bigmsg = xrealloc (state->bigmsg, newsize);
       state->allocated = newsize;
-      return 0;
+      return false;
     }
   else if (numwritten >= available_size)
     {
@@ -392,7 +392,7 @@ log_vprintf_internal (struct logvprintf_state *state, const char *fmt,
       int newsize = numwritten + 1;
       state->bigmsg = xrealloc (state->bigmsg, newsize);
       state->allocated = newsize;
-      return 0;
+      return false;
     }
 
   /* Writing succeeded. */
@@ -405,9 +405,9 @@ log_vprintf_internal (struct logvprintf_state *state, const char *fmt,
   if (flush_log_p)
     logflush ();
   else
-    needs_flushing = 1;
+    needs_flushing = true;
 
-  return 1;
+  return true;
 }
 
 /* Flush LOGFP.  Useful while flushing is disabled.  */
@@ -417,20 +417,20 @@ logflush (void)
   FILE *fp = get_log_fp ();
   if (fp)
     fflush (fp);
-  needs_flushing = 0;
+  needs_flushing = false;
 }
 
 /* Enable or disable log flushing. */
 void
-log_set_flush (int flush)
+log_set_flush (bool flush)
 {
   if (flush == flush_log_p)
     return;
 
-  if (flush == 0)
+  if (flush == false)
     {
       /* Disable flushing by setting flush_log_p to 0. */
-      flush_log_p = 0;
+      flush_log_p = false;
     }
   else
     {
@@ -438,7 +438,7 @@ log_set_flush (int flush)
 	 flush the log now.  */
       if (needs_flushing)
 	logflush ();
-      flush_log_p = 1;
+      flush_log_p = true;
     }
 }
 
@@ -446,10 +446,10 @@ log_set_flush (int flush)
    status of storing, with which this function can be called again to
    reestablish storing. */
 
-int
-log_set_save_context (int savep)
+bool
+log_set_save_context (bool savep)
 {
-  int old = save_context_p;
+  bool old = save_context_p;
   save_context_p = savep;
   return old;
 }
@@ -463,7 +463,7 @@ logprintf (enum log_options o, const char *fmt, ...)
 {
   va_list args;
   struct logvprintf_state lpstate;
-  int done;
+  bool done;
 
   check_redirect_output ();
   if (inhibit_logging)
@@ -482,7 +482,7 @@ logprintf (enum log_options o, const char *fmt, ...)
 
 #ifdef ENABLE_DEBUG
 /* The same as logprintf(), but does anything only if opt.debug is
-   non-zero.  */
+   true.  */
 void
 debug_logprintf (const char *fmt, ...)
 {
@@ -490,7 +490,7 @@ debug_logprintf (const char *fmt, ...)
     {
       va_list args;
       struct logvprintf_state lpstate;
-      int done;
+      bool done;
 
       check_redirect_output ();
       if (inhibit_logging)
@@ -511,7 +511,7 @@ debug_logprintf (const char *fmt, ...)
 /* Open FILE and set up a logging stream.  If FILE cannot be opened,
    exit with status of 1.  */
 void
-log_init (const char *file, int appendp)
+log_init (const char *file, bool appendp)
 {
   if (file)
     {
@@ -542,7 +542,7 @@ log_init (const char *file, int appendp)
 	     the most recent several messages ("context") and dump
 	     them to a log file in case SIGHUP or SIGUSR1 is received
 	     (or Ctrl+Break is pressed under Windows).  */
-	  save_context_p = 1;
+	  save_context_p = true;
 	}
     }
 }
@@ -557,13 +557,13 @@ log_close (void)
   if (logfp)
     fclose (logfp);
   logfp = NULL;
-  inhibit_logging = 1;
-  save_context_p = 0;
+  inhibit_logging = true;
+  save_context_p = false;
 
   for (i = 0; i < SAVED_LOG_LINES; i++)
     free_log_line (i);
   log_line_current = -1;
-  trailing_line = 0;
+  trailing_line = false;
 }
 
 /* Dump saved lines to logfp. */
@@ -778,7 +778,7 @@ static void
 redirect_output (void)
 {
   char *logfile;
-  logfp = unique_create (DEFAULT_LOGFILE, 0, &logfile);
+  logfp = unique_create (DEFAULT_LOGFILE, false, &logfile);
   if (logfp)
     {
       fprintf (stderr, _("\n%s received, redirecting output to `%s'.\n"),
@@ -794,9 +794,9 @@ redirect_output (void)
       fprintf (stderr, _("\n%s received.\n"), redirect_request_signal_name);
       fprintf (stderr, _("%s: %s; disabling logging.\n"),
 	       logfile, strerror (errno));
-      inhibit_logging = 1;
+      inhibit_logging = true;
     }
-  save_context_p = 0;
+  save_context_p = false;
 }
 
 /* Check whether a signal handler requested the output to be
diff --git a/src/log.h b/src/log.h
index fdc9417..eda2564 100644
--- a/src/log.h
+++ b/src/log.h
@@ -40,10 +40,10 @@ void logprintf (enum log_options, const char *, ...)
 void debug_logprintf (const char *, ...) GCC_FORMAT_ATTR (1, 2);
 void logputs (enum log_options, const char *);
 void logflush (void);
-void log_set_flush (int);
-int log_set_save_context (int);
+void log_set_flush (bool);
+bool log_set_save_context (bool);
 
-void log_init (const char *, int);
+void log_init (const char *, bool);
 void log_close (void);
 void log_cleanup (void);
 void log_request_redirect_output (const char *);
diff --git a/src/main.c b/src/main.c
index 5cb383a..ec8ed32 100644
--- a/src/main.c
+++ b/src/main.c
@@ -660,7 +660,7 @@ main (int argc, char *const *argv)
   char **url, **t;
   int i, ret, longindex;
   int nurl, status;
-  int append_to_log = 0;
+  bool append_to_log = false;
 
   i18n_initialize ();
 
@@ -719,7 +719,7 @@ main (int argc, char *const *argv)
 	  else
 	    {
 	      /* NEG is true for `--no-FOO' style boolean options. */
-	      int neg = val & BOOLEAN_NEG_MARKER;
+	      bool neg = !!(val & BOOLEAN_NEG_MARKER);
 	      setoptval (opt->data, neg ? "0" : "1", opt->long_name);
 	    }
 	  break;
@@ -731,7 +731,7 @@ main (int argc, char *const *argv)
 	  break;
 	case OPT__APPEND_OUTPUT:
 	  setoptval ("logfile", optarg, opt->long_name);
-	  append_to_log = 1;
+	  append_to_log = true;
 	  break;
 	case OPT__EXECUTE:
 	  run_command (optarg);
@@ -775,7 +775,7 @@ main (int argc, char *const *argv)
 	    /* The wgetrc commands are named noparent and noclobber,
 	       so we must revert the meaning of the cmdline options
 	       before passing the value to setoptval.  */
-	    int flag = 1;
+	    bool flag = true;
 	    if (optarg)
 	      flag = (*optarg == '1' || TOLOWER (*optarg) == 'y'
 		      || (TOLOWER (optarg[0]) == 'o'
@@ -877,7 +877,7 @@ Can't timestamp and not clobber old files at the same time.\n"));
   if (opt.output_document)
     {
       extern FILE *output_stream;
-      extern int output_stream_regular;
+      extern bool output_stream_regular;
 
       if (HYPHENP (opt.output_document))
 	output_stream = stdout;
@@ -892,7 +892,7 @@ Can't timestamp and not clobber old files at the same time.\n"));
 	      exit (1);
 	    }
 	  if (fstat (fileno (output_stream), &st) == 0 && S_ISREG (st.st_mode))
-	    output_stream_regular = 1;
+	    output_stream_regular = true;
 	}
     }
 
diff --git a/src/mswindows.c b/src/mswindows.c
index 909c2ab..e61e9b8 100644
--- a/src/mswindows.c
+++ b/src/mswindows.c
@@ -115,7 +115,7 @@ str_to_int64 (const char *nptr, char **endptr, int base)
 #define INT64_UNDERFLOW (-INT64_OVERFLOW - 1)
 
   __int64 result = 0;
-  int negative;
+  bool negative;
 
   if (base != 0 && (base < 2 || base > 36))
     {
@@ -127,16 +127,16 @@ str_to_int64 (const char *nptr, char **endptr, int base)
     ++nptr;
   if (*nptr == '-')
     {
-      negative = 1;
+      negative = true;
       ++nptr;
     }
   else if (*nptr == '+')
     {
-      negative = 0;
+      negative = false;
       ++nptr;
     }
   else
-    negative = 0;
+    negative = false;
 
   /* If base is 0, determine the real base based on the beginning on
      the number; octal numbers begin with "0", hexadecimal with "0x",
@@ -252,7 +252,7 @@ make_section_name (DWORD pid)
 struct fake_fork_info
 {
   HANDLE event;
-  int logfile_changed;
+  bool logfile_changed;
   char lfilename[MAX_PATH + 1];
 };
 
@@ -287,14 +287,14 @@ fake_fork_child (void)
 
   event = info->event;
 
-  info->logfile_changed = 0;
+  info->logfile_changed = false;
   if (!opt.lfilename)
     {
       /* See utils:fork_to_background for explanation. */
-      FILE *new_log_fp = unique_create (DEFAULT_LOGFILE, 0, &opt.lfilename);
+      FILE *new_log_fp = unique_create (DEFAULT_LOGFILE, false, &opt.lfilename);
       if (new_log_fp)
 	{
-	  info->logfile_changed = 1;
+	  info->logfile_changed = true;
 	  strncpy (info->lfilename, opt.lfilename, sizeof (info->lfilename));
 	  info->lfilename[sizeof (info->lfilename) - 1] = '\0';
 	  fclose (new_log_fp);
@@ -677,19 +677,19 @@ thread_helper (void *arg)
 }
 
 /* Call FUN(ARG), but don't allow it to run for more than TIMEOUT
-   seconds.  Returns non-zero if the function was interrupted with a
-   timeout, zero otherwise.
+   seconds.  Returns true if the function was interrupted with a
+   timeout, false otherwise.
 
    This works by running FUN in a separate thread and terminating the
    thread if it doesn't finish in the specified time.  */
 
-int
+bool
 run_with_timeout (double seconds, void (*fun) (void *), void *arg)
 {
   static HANDLE thread_hnd = NULL;
   struct thread_data thread_arg;
   DWORD thread_id;
-  int rc;
+  bool rc;
 
   DEBUGP (("seconds %.2f, ", seconds));
 
@@ -697,7 +697,7 @@ run_with_timeout (double seconds, void (*fun) (void *), void *arg)
     {
     blocking_fallback:
       fun (arg);
-      return 0;
+      return false;
     }
 
   /* Should never happen, but test for recursivety anyway.  */
@@ -721,12 +721,12 @@ run_with_timeout (double seconds, void (*fun) (void *), void *arg)
 	 so the caller can inspect it.  */
       WSASetLastError (thread_arg.ws_error);
       DEBUGP (("Winsock error: %d\n", WSAGetLastError ()));
-      rc = 0;
+      rc = false;
     }
   else
     {
       TerminateThread (thread_hnd, 1);
-      rc = 1;
+      rc = true;
     }
 
   CloseHandle (thread_hnd);	/* Clear-up after TerminateThread().  */
diff --git a/src/openssl.c b/src/openssl.c
index 6fd9d65..2465294 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -154,16 +154,16 @@ key_type_to_ssl_type (enum keyfile_type type)
 /* Create an SSL Context and set default paths etc.  Called the first
    time an HTTP download is attempted.
 
-   Returns 1 on success, 0 otherwise.  */
+   Returns true on success, false otherwise.  */
 
-int
+bool
 ssl_init ()
 {
   SSL_METHOD *meth;
 
   if (ssl_ctx)
     /* The SSL has already been initialized. */
-    return 1;
+    return true;
 
   /* Init the PRNG.  If that fails, bail out.  */
   init_prng ();
@@ -225,13 +225,13 @@ ssl_init ()
      handles them correctly), allow them in OpenSSL.  */
   SSL_CTX_set_mode (ssl_ctx, SSL_MODE_ENABLE_PARTIAL_WRITE);
 
-  return 1;
+  return true;
 
  error:
   if (ssl_ctx)
     SSL_CTX_free (ssl_ctx);
   print_errors ();
-  return 0;
+  return false;
 }
 
 static int
@@ -306,9 +306,9 @@ openssl_close (int fd, void *ctx)
    fd_register_transport, so that subsequent calls to fd_read,
    fd_write, etc., will use the corresponding SSL functions.
 
-   Returns 1 on success, 0 on failure.  */
+   Returns true on success, false on failure.  */
 
-int
+bool
 ssl_connect (int fd) 
 {
   SSL *ssl;
@@ -331,19 +331,19 @@ ssl_connect (int fd)
 			 openssl_peek, openssl_close, ssl);
   DEBUGP (("Handshake successful; connected socket %d to SSL handle 0x%0*lx\n",
 	   fd, PTR_FORMAT (ssl)));
-  return 1;
+  return true;
 
  error:
   DEBUGP (("SSL handshake failed.\n"));
   print_errors ();
   if (ssl)
     SSL_free (ssl);
-  return 0;
+  return false;
 }
 
 #define ASTERISK_EXCLUDES_DOT	/* mandated by rfc2818 */
 
-/* Return 1 is STRING (case-insensitively) matches PATTERN, 0
+/* Return true is STRING (case-insensitively) matches PATTERN, false
    otherwise.  The recognized wildcard character is "*", which matches
    any character in STRING except ".".  Any number of the "*" wildcard
    may be present in the pattern.
@@ -357,7 +357,7 @@ ssl_connect (int fd)
    If the pattern contain no wildcards, pattern_match(a, b) is
    equivalent to !strcasecmp(a, b).  */
 
-static int
+static bool
 pattern_match (const char *pattern, const char *string)
 {
   const char *p = pattern, *n = string;
@@ -369,17 +369,17 @@ pattern_match (const char *pattern, const char *string)
 	  ;
 	for (; *n != '\0'; n++)
 	  if (TOLOWER (*n) == c && pattern_match (p, n))
-	    return 1;
+	    return true;
 #ifdef ASTERISK_EXCLUDES_DOT
 	  else if (*n == '.')
-	    return 0;
+	    return false;
 #endif
 	return c == '\0';
       }
     else
       {
 	if (c != TOLOWER (*n))
-	  return 0;
+	  return false;
       }
   return *n == '\0';
 }
@@ -393,18 +393,18 @@ pattern_match (const char *pattern, const char *string)
    the SSL handshake has been performed and that FD is connected to an
    SSL handle.
 
-   If opt.check_cert is non-zero (the default), this returns 1 if the
+   If opt.check_cert is true (the default), this returns 1 if the
    certificate is valid, 0 otherwise.  If opt.check_cert is 0, the
    function always returns 1, but should still be called because it
    warns the user about any problems with the certificate.  */
 
-int
+bool
 ssl_check_certificate (int fd, const char *host)
 {
   X509 *cert;
   char common_name[256];
   long vresult;
-  int success = 1;
+  bool success = true;
 
   /* If the user has specified --no-check-cert, we still want to warn
      him about problems with the server's certificate.  */
@@ -418,7 +418,7 @@ ssl_check_certificate (int fd, const char *host)
     {
       logprintf (LOG_NOTQUIET, _("%s: No certificate presented by %s.\n"),
 		 severity, escnonprint (host));
-      success = 0;
+      success = false;
       goto no_cert;		/* must bail out since CERT is NULL */
     }
 
@@ -448,7 +448,7 @@ ssl_check_certificate (int fd, const char *host)
 		 _("%s: Certificate verification error for %s: %s\n"),
 		 severity, escnonprint (host),
 		 X509_verify_cert_error_string (vresult));
-      success = 0;
+      success = false;
       /* Fall through, so that the user is warned about *all* issues
 	 with the cert (important with --no-check-certificate.)  */
     }
@@ -475,7 +475,7 @@ ssl_check_certificate (int fd, const char *host)
       logprintf (LOG_NOTQUIET, _("\
 %s: certificate common name `%s' doesn't match requested host name `%s'.\n"),
 		 severity, escnonprint (common_name), escnonprint (host));
-      success = 0;
+      success = false;
     }
 
   if (success)
@@ -490,5 +490,5 @@ To connect to %s insecurely, use `--no-check-certificate'.\n"),
 	       escnonprint (host));
 
   /* Allow --no-check-cert to disable certificate checking. */
-  return opt.check_cert ? success : 1;
+  return opt.check_cert ? success : true;
 }
diff --git a/src/options.h b/src/options.h
index 71182c5..94f7bae 100644
--- a/src/options.h
+++ b/src/options.h
@@ -29,36 +29,36 @@ so, delete this exception statement from your version.  */
 
 struct options
 {
-  int verbose;			/* Are we verbose? */
-  int quiet;			/* Are we quiet? */
+  bool verbose;			/* Are we verbose? */
+  bool quiet;			/* Are we quiet? */
   int ntry;			/* Number of tries per URL */
-  int retry_connrefused;	/* Treat CONNREFUSED as non-fatal. */
-  int background;		/* Whether we should work in background. */
-  int kill_longer;		/* Do we reject messages with *more*
+  bool retry_connrefused;	/* Treat CONNREFUSED as non-fatal. */
+  bool background;		/* Whether we should work in background. */
+  bool kill_longer;		/* Do we reject messages with *more*
 				   data than specified in
 				   content-length? */
-  int ignore_length;		/* Do we heed content-length at all?  */
-  int recursive;		/* Are we recursive? */
-  int spanhost;			/* Do we span across hosts in
+  bool ignore_length;		/* Do we heed content-length at all?  */
+  bool recursive;		/* Are we recursive? */
+  bool spanhost;			/* Do we span across hosts in
 				   recursion? */
-  int relative_only;		/* Follow only relative links. */
-  int no_parent;		/* Restrict access to the parent
+  bool relative_only;		/* Follow only relative links. */
+  bool no_parent;		/* Restrict access to the parent
 				   directory.  */
   int reclevel;			/* Maximum level of recursion */
-  int dirstruct;		/* Do we build the directory structure
+  bool dirstruct;		/* Do we build the directory structure
 				  as we go along? */
-  int no_dirstruct;		/* Do we hate dirstruct? */
+  bool no_dirstruct;		/* Do we hate dirstruct? */
   int cut_dirs;			/* Number of directory components to cut. */
-  int add_hostdir;		/* Do we add hostname directory? */
-  int protocol_directories;	/* Whether to prepend "http"/"ftp" to dirs. */
-  int noclobber;		/* Disables clobbering of existing
+  bool add_hostdir;		/* Do we add hostname directory? */
+  bool protocol_directories;	/* Whether to prepend "http"/"ftp" to dirs. */
+  bool noclobber;		/* Disables clobbering of existing
 				   data. */
   char *dir_prefix;		/* The top of directory tree */
   char *lfilename;		/* Log filename */
   char *input_filename;		/* Input filename */
-  int force_html;		/* Is the input file an HTML file? */
+  bool force_html;		/* Is the input file an HTML file? */
 
-  int spider;			/* Is Wget in spider mode? */
+  bool spider;			/* Is Wget in spider mode? */
 
   char **accepts;		/* List of patterns to accept. */
   char **rejects;		/* List of patterns to reject. */
@@ -68,14 +68,14 @@ struct options
 
   char **domains;		/* See host.c */
   char **exclude_domains;
-  int dns_cache;		/* whether we cache DNS lookups. */
+  bool dns_cache;		/* whether we cache DNS lookups. */
 
   char **follow_tags;           /* List of HTML tags to recursively follow. */
   char **ignore_tags;           /* List of HTML tags to ignore if recursing. */
 
-  int follow_ftp;		/* Are FTP URL-s followed in recursive
+  bool follow_ftp;		/* Are FTP URL-s followed in recursive
 				   retrieving? */
-  int retr_symlinks;		/* Whether we retrieve symlinks in
+  bool retr_symlinks;		/* Whether we retrieve symlinks in
 				   FTP. */
   char *output_document;	/* The output file to which the
 				   documents will be printed.  */
@@ -83,20 +83,20 @@ struct options
   char *user;			/* Generic username */
   char *passwd;			/* Generic password */
   
-  int always_rest;		/* Always use REST. */
+  bool always_rest;		/* Always use REST. */
   char *ftp_user;		/* FTP username */
   char *ftp_passwd;		/* FTP password */
-  int netrc;			/* Whether to read .netrc. */
-  int ftp_glob;			/* FTP globbing */
-  int ftp_pasv;			/* Passive FTP. */
+  bool netrc;			/* Whether to read .netrc. */
+  bool ftp_glob;		/* FTP globbing */
+  bool ftp_pasv;			/* Passive FTP. */
 
   char *http_user;		/* HTTP username. */
   char *http_passwd;		/* HTTP password. */
   char **user_headers;		/* User-defined header(s). */
-  int http_keep_alive;		/* whether we use keep-alive */
+  bool http_keep_alive;		/* whether we use keep-alive */
 
-  int use_proxy;		/* Do we use proxy? */
-  int allow_cache;		/* Do we allow server-side caching? */
+  bool use_proxy;		/* Do we use proxy? */
+  bool allow_cache;		/* Do we allow server-side caching? */
   char *http_proxy, *ftp_proxy, *https_proxy;
   char **no_proxy;
   char *base_href;
@@ -108,42 +108,43 @@ struct options
   double dns_timeout;		/* The DNS timeout. */
   double connect_timeout;	/* The connect timeout. */
 
-  int random_wait;		/* vary from 0 .. wait secs by random()? */
+  bool random_wait;		/* vary from 0 .. wait secs by random()? */
   double wait;			/* The wait period between retrievals. */
   double waitretry;		/* The wait period between retries. - HEH */
-  int use_robots;		/* Do we heed robots.txt? */
+  bool use_robots;		/* Do we heed robots.txt? */
 
   wgint limit_rate;		/* Limit the download rate to this
 				   many bps. */
   LARGE_INT quota;		/* Maximum file size to download and
 				   store. */
+
   int numurls;			/* Number of successfully downloaded
-				   URLs */
+				   URLs #### should be removed because
+				   it's not a setting, but a global var */
 
-  int server_response;		/* Do we print server response? */
-  int save_headers;		/* Do we save headers together with
+  bool server_response;		/* Do we print server response? */
+  bool save_headers;		/* Do we save headers together with
 				   file? */
 
 #ifdef ENABLE_DEBUG
-  int debug;			/* Debugging on/off */
+  bool debug;			/* Debugging on/off */
 #endif
 
-  int timestamping;		/* Whether to use time-stamping. */
+  bool timestamping;		/* Whether to use time-stamping. */
 
-  int backup_converted;		/* Do we save pre-converted files as *.orig? */
-  int backups;			/* Are numeric backups made? */
+  bool backup_converted;	/* Do we save pre-converted files as *.orig? */
+  bool backups;			/* Are numeric backups made? */
 
-  char *useragent;		/* Naughty User-Agent, which can be
-				   set to something other than
-				   Wget. */
+  char *useragent;		/* User-Agent string, which can be set
+				   to something other than Wget. */
   char *referer;		/* Naughty Referer, which can be
 				   set to something other than
 				   NULL. */
-  int convert_links;		/* Will the links be converted
+  bool convert_links;		/* Will the links be converted
 				   locally? */
-  int remove_listing;		/* Do we remove .listing files
+  bool remove_listing;		/* Do we remove .listing files
 				   generated by FTP? */
-  int htmlify;			/* Do we HTML-ify the OS-dependent
+  bool htmlify;			/* Do we HTML-ify the OS-dependent
 				   listings? */
 
   char *dot_style;
@@ -152,12 +153,12 @@ struct options
   int dots_in_line;		/* How many dots in one line. */
   int dot_spacing;		/* How many dots between spacings. */
 
-  int delete_after;		/* Whether the files will be deleted
+  bool delete_after;		/* Whether the files will be deleted
 				   after download. */
 
-  int html_extension;		/* Use ".html" extension on all text/html? */
+  bool html_extension;		/* Use ".html" extension on all text/html? */
 
-  int page_requisites;		/* Whether we need to download all files
+  bool page_requisites;		/* Whether we need to download all files
 				   necessary to display a page properly. */
   char *bind_address;		/* What local IP address to bind to. */
 
@@ -168,7 +169,7 @@ struct options
     secure_protocol_sslv3,
     secure_protocol_tlsv1
   } secure_protocol;		/* type of secure protocol to use. */
-  int check_cert;		/* whether to validate the server's cert */
+  bool check_cert;		/* whether to validate the server's cert */
   char *cert_file;		/* external client certificate to use. */
   char *private_key;		/* private key file (if not internal). */
   enum keyfile_type {
@@ -186,10 +187,10 @@ struct options
   char *egd_file;		/* file name of the egd daemon socket */
 #endif /* HAVE_SSL */
 
-  int   cookies;		/* whether cookies are used. */
+  bool cookies;			/* whether cookies are used. */
   char *cookies_input;		/* file we're loading the cookies from. */
   char *cookies_output;		/* file we're saving the cookies to. */
-  int   keep_session_cookies;	/* whether session cookies should be
+  bool keep_session_cookies;	/* whether session cookies should be
 				   saved and loaded. */
 
   char *post_data;		/* POST query string */
@@ -199,19 +200,19 @@ struct options
     restrict_unix,
     restrict_windows
   } restrict_files_os;		/* file name restriction ruleset. */
-  int restrict_files_ctrl;	/* non-zero if control chars in URLs
+  bool restrict_files_ctrl;	/* non-zero if control chars in URLs
 				   are restricted from appearing in
 				   generated file names. */
 
-  int strict_comments;		/* whether strict SGML comments are
+  bool strict_comments;		/* whether strict SGML comments are
 				   enforced.  */
 
-  int preserve_perm;           /* whether remote permissions are used
+  bool preserve_perm;           /* whether remote permissions are used
 				  or that what is set by umask. */
 
 #ifdef ENABLE_IPV6
-  int ipv4_only;		/* IPv4 connections have been requested. */
-  int ipv6_only;		/* IPv4 connections have been requested. */
+  bool ipv4_only;		/* IPv4 connections have been requested. */
+  bool ipv6_only;		/* IPv4 connections have been requested. */
 #endif
   enum {
     prefer_ipv4,
diff --git a/src/progress.c b/src/progress.c
index 28ad27d..5bb63fc 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -45,7 +45,7 @@ so, delete this exception statement from your version.  */
 
 struct progress_implementation {
   const char *name;
-  int interactive;
+  bool interactive;
   void *(*create) (wgint, wgint);
   void (*update) (void *, wgint, double);
   void (*finish) (void *, double);
@@ -84,10 +84,10 @@ static int current_impl_locked;
 
 #define FALLBACK_PROGRESS_IMPLEMENTATION "dot"
 
-/* Return non-zero if NAME names a valid progress bar implementation.
-   The characters after the first : will be ignored.  */
+/* Return true if NAME names a valid progress bar implementation.  The
+   characters after the first : will be ignored.  */
 
-int
+bool
 valid_progress_implementation_p (const char *name)
 {
   int i;
@@ -97,8 +97,8 @@ valid_progress_implementation_p (const char *name)
 
   for (i = 0; i < countof (implementations); i++, pi++)
     if (!strncmp (pi->name, name, namelen))
-      return 1;
-  return 0;
+      return true;
+  return false;
 }
 
 /* Set the progress implementation to NAME.  */
@@ -163,12 +163,12 @@ progress_create (wgint initial, wgint total)
   return current_impl->create (initial, total);
 }
 
-/* Return non-zero if the progress gauge is "interactive", i.e. if it
-   can profit from being called regularly even in absence of data.
-   The progress bar is interactive because it regularly updates the
-   ETA and current update.  */
+/* Return true if the progress gauge is "interactive", i.e. if it can
+   profit from being called regularly even in absence of data.  The
+   progress bar is interactive because it regularly updates the ETA
+   and current update.  */
 
-int
+bool
 progress_interactive_p (void *progress)
 {
   return current_impl->interactive;
@@ -279,7 +279,7 @@ dot_update (void *progress, wgint howmuch, double dltime)
   int dot_bytes = opt.dot_bytes;
   wgint row_bytes = opt.dot_bytes * opt.dots_in_line;
 
-  log_set_flush (0);
+  log_set_flush (false);
 
   dp->accumulated += howmuch;
   for (; dp->accumulated >= dot_bytes; dp->accumulated -= dot_bytes)
@@ -307,7 +307,7 @@ dot_update (void *progress, wgint howmuch, double dltime)
 	}
     }
 
-  log_set_flush (1);
+  log_set_flush (true);
 }
 
 /* Dot-progress backend for progress_finish. */
@@ -320,7 +320,7 @@ dot_finish (void *progress, double dltime)
   wgint row_bytes = opt.dot_bytes * opt.dots_in_line;
   int i;
 
-  log_set_flush (0);
+  log_set_flush (false);
 
   if (dp->dots == 0)
     logprintf (LOG_VERBOSE, "\n%5ldK", (long) (dp->rows * row_bytes / 1024));
@@ -346,7 +346,7 @@ dot_finish (void *progress, double dltime)
   }
 
   logputs (LOG_VERBOSE, "\n\n");
-  log_set_flush (0);
+  log_set_flush (false);
 
   xfree (dp);
 }
@@ -477,7 +477,7 @@ struct bar_progress {
 				   position. */
   wgint recent_bytes;		/* bytes downloaded so far. */
 
-  int stalled;			/* set when no data arrives for longer
+  bool stalled;			/* set when no data arrives for longer
 				   than STALL_START_TIME, then reset
 				   when new data arrives. */
 
@@ -536,7 +536,7 @@ static void
 bar_update (void *progress, wgint howmuch, double dltime)
 {
   struct bar_progress *bp = progress;
-  int force_screen_update = 0;
+  bool force_screen_update = false;
 
   bp->count += howmuch;
   if (bp->total_length > 0
@@ -564,7 +564,7 @@ bar_update (void *progress, wgint howmuch, double dltime)
 	{
 	  bp->width = screen_width - 1;
 	  bp->buffer = xrealloc (bp->buffer, bp->width + 1);
-	  force_screen_update = 1;
+	  force_screen_update = true;
 	}
       received_sigwinch = 0;
     }
@@ -641,7 +641,7 @@ update_speed_ring (struct bar_progress *bp, wgint howmuch, double dltime)
 	  /* If we're stalling, reset the ring contents because it's
 	     stale and because it will make bar_update stop printing
 	     the (bogus) current bandwidth.  */
-	  bp->stalled = 1;
+	  bp->stalled = true;
 	  xzero (*hist);
 	  bp->recent_bytes = 0;
 	}
@@ -653,7 +653,7 @@ update_speed_ring (struct bar_progress *bp, wgint howmuch, double dltime)
   /* If the stall status was acquired, reset it. */
   if (bp->stalled)
     {
-      bp->stalled = 0;
+      bp->stalled = false;
       /* "recent_age" includes the the entired stalled period, which
 	 could be very long.  Don't update the speed ring with that
 	 value because the current bandwidth would start too small.
@@ -912,7 +912,7 @@ create_image (struct bar_progress *bp, double dl_total_time)
 static void
 display_image (char *buf)
 {
-  int old = log_set_save_context (0);
+  bool old = log_set_save_context (false);
   logputs (LOG_VERBOSE, "\r");
   logputs (LOG_VERBOSE, buf);
   log_set_save_context (old);
diff --git a/src/progress.h b/src/progress.h
index e8e7870..6123180 100644
--- a/src/progress.h
+++ b/src/progress.h
@@ -30,12 +30,12 @@ so, delete this exception statement from your version.  */
 #ifndef PROGRESS_H
 #define PROGRESS_H
 
-int valid_progress_implementation_p (const char *);
+bool valid_progress_implementation_p (const char *);
 void set_progress_implementation (const char *);
 void progress_schedule_redirect (void);
 
 void *progress_create (wgint, wgint);
-int progress_interactive_p (void *);
+bool progress_interactive_p (void *);
 void progress_update (void *, wgint, double);
 void progress_finish (void *, double);
 
diff --git a/src/ptimer.c b/src/ptimer.c
index 672e1e1..7270825 100644
--- a/src/ptimer.c
+++ b/src/ptimer.c
@@ -241,7 +241,7 @@ typedef union {
 
 /* Whether high-resolution timers are used.  Set by ptimer_initialize_once
    the first time ptimer_new is called. */
-static int windows_hires_timers;
+static bool windows_hires_timers;
 
 /* Frequency of high-resolution timers -- number of updates per
    millisecond.  Calculated the first time ptimer_new is called
@@ -256,7 +256,7 @@ windows_init (void)
   QueryPerformanceFrequency (&freq);
   if (freq.QuadPart != 0)
     {
-      windows_hires_timers = 1;
+      windows_hires_timers = true;
       windows_hires_msfreq = (double) freq.QuadPart / 1000.0;
     }
 }
@@ -318,10 +318,10 @@ ptimer_new (void)
 {
   struct ptimer *pt = xnew0 (struct ptimer);
 #ifdef IMPL_init
-  static int init_done;
+  static bool init_done;
   if (!init_done)
     {
-      init_done = 1;
+      init_done = true;
       IMPL_init ();
     }
 #endif
diff --git a/src/recur.c b/src/recur.c
index a00b47a..4975d61 100644
--- a/src/recur.c
+++ b/src/recur.c
@@ -96,7 +96,7 @@ url_queue_delete (struct url_queue *queue)
 
 static void
 url_enqueue (struct url_queue *queue,
-	     const char *url, const char *referer, int depth, int html_allowed)
+	     const char *url, const char *referer, int depth, bool html_allowed)
 {
   struct queue_element *qel = xnew (struct queue_element);
   qel->url = url;
@@ -120,18 +120,18 @@ url_enqueue (struct url_queue *queue,
     queue->head = queue->tail;
 }
 
-/* Take a URL out of the queue.  Return 1 if this operation succeeded,
-   or 0 if the queue is empty.  */
+/* Take a URL out of the queue.  Return true if this operation
+   succeeded, or false if the queue is empty.  */
 
-static int
+static bool
 url_dequeue (struct url_queue *queue,
 	     const char **url, const char **referer, int *depth,
-	     int *html_allowed)
+	     bool *html_allowed)
 {
   struct queue_element *qel = queue->head;
 
   if (!qel)
-    return 0;
+    return false;
 
   queue->head = queue->head->next;
   if (!queue->head)
@@ -148,13 +148,13 @@ url_dequeue (struct url_queue *queue,
   DEBUGP (("Queue count %d, maxcount %d.\n", queue->count, queue->maxcount));
 
   xfree (qel);
-  return 1;
+  return true;
 }
 
-static int download_child_p (const struct urlpos *, struct url *, int,
-			     struct url *, struct hash_table *);
-static int descend_redirect_p (const char *, const char *, int,
-			       struct url *, struct hash_table *);
+static bool download_child_p (const struct urlpos *, struct url *, int,
+			      struct url *, struct hash_table *);
+static bool descend_redirect_p (const char *, const char *, int,
+				struct url *, struct hash_table *);
 
 
 /* Retrieve a part of the web beginning with START_URL.  This used to
@@ -205,15 +205,16 @@ retrieve_tree (const char *start_url)
 
   /* Enqueue the starting URL.  Use start_url_parsed->url rather than
      just URL so we enqueue the canonical form of the URL.  */
-  url_enqueue (queue, xstrdup (start_url_parsed->url), NULL, 0, 1);
+  url_enqueue (queue, xstrdup (start_url_parsed->url), NULL, 0, true);
   string_set_add (blacklist, start_url_parsed->url);
 
   while (1)
     {
-      int descend = 0;
+      bool descend = false;
       char *url, *referer, *file = NULL;
-      int depth, html_allowed;
-      int dash_p_leaf_HTML = 0;
+      int depth;
+      bool html_allowed;
+      bool dash_p_leaf_HTML = false;
 
       if (opt.quota && total_downloaded_bytes > opt.quota)
 	break;
@@ -245,21 +246,21 @@ retrieve_tree (const char *start_url)
 	  if (html_allowed
 	      && downloaded_html_set
 	      && string_set_contains (downloaded_html_set, file))
-	    descend = 1;
+	    descend = true;
 	}
       else
 	{
 	  int dt = 0;
 	  char *redirected = NULL;
-	  int oldrec = opt.recursive;
+	  bool oldrec = opt.recursive;
 
-	  opt.recursive = 0;
+	  opt.recursive = false;
 	  status = retrieve_url (url, &file, &redirected, referer, &dt);
 	  opt.recursive = oldrec;
 
 	  if (html_allowed && file && status == RETROK
 	      && (dt & RETROKF) && (dt & TEXTHTML))
-	    descend = 1;
+	    descend = true;
 
 	  if (redirected)
 	    {
@@ -270,7 +271,7 @@ retrieve_tree (const char *start_url)
 		{
 		  if (!descend_redirect_p (redirected, url, depth,
 					   start_url_parsed, blacklist))
-		    descend = 0;
+		    descend = false;
 		  else
 		    /* Make sure that the old pre-redirect form gets
 		       blacklisted. */
@@ -295,7 +296,7 @@ retrieve_tree (const char *start_url)
 		 one, but we allow one more level so that the leaf
 		 pages that contain frames can be loaded
 		 correctly.  */
-	      dash_p_leaf_HTML = 1;
+	      dash_p_leaf_HTML = true;
 	    }
 	  else
 	    {
@@ -304,7 +305,7 @@ retrieve_tree (const char *start_url)
 		 affords us, so we need to bail out. */
 	      DEBUGP (("Not descending further; at depth %d, max. %d.\n",
 		       depth, opt.reclevel));
-	      descend = 0;
+	      descend = false;
 	    }
 	}
 
@@ -313,7 +314,7 @@ retrieve_tree (const char *start_url)
 
       if (descend)
 	{
-	  int meta_disallow_follow = 0;
+	  bool meta_disallow_follow = false;
 	  struct urlpos *children
 	    = get_urls_html (file, url, &meta_disallow_follow);
 
@@ -381,7 +382,8 @@ retrieve_tree (const char *start_url)
      now.  */
   {
     char *d1, *d2;
-    int d3, d4;
+    int d3;
+    bool d4;
     while (url_dequeue (queue,
 			(const char **)&d1, (const char **)&d2, &d3, &d4))
       {
@@ -411,13 +413,13 @@ retrieve_tree (const char *start_url)
    by storing these URLs to BLACKLIST.  This may or may not help.  It
    will help if those URLs are encountered many times.  */
 
-static int
+static bool
 download_child_p (const struct urlpos *upos, struct url *parent, int depth,
 		  struct url *start_url_parsed, struct hash_table *blacklist)
 {
   struct url *u = upos->url;
   const char *url = u->url;
-  int u_scheme_like_http;
+  bool u_scheme_like_http;
 
   DEBUGP (("Deciding whether to enqueue \"%s\".\n", url));
 
@@ -576,12 +578,12 @@ download_child_p (const struct urlpos *upos, struct url *parent, int depth,
      download queue. */
   DEBUGP (("Decided to load it.\n"));
 
-  return 1;
+  return true;
 
  out:
   DEBUGP (("Decided NOT to load it.\n"));
 
-  return 0;
+  return false;
 }
 
 /* This function determines whether we will consider downloading the
@@ -589,13 +591,13 @@ download_child_p (const struct urlpos *upos, struct url *parent, int depth,
    possibly to another host, etc.  It is needed very rarely, and thus
    it is merely a simple-minded wrapper around download_child_p.  */
 
-static int
+static bool
 descend_redirect_p (const char *redirected, const char *original, int depth,
 		    struct url *start_url_parsed, struct hash_table *blacklist)
 {
   struct url *orig_parsed, *new_parsed;
   struct urlpos *upos;
-  int success;
+  bool success;
 
   orig_parsed = url_parse (original, NULL);
   assert (orig_parsed != NULL);
diff --git a/src/recur.h b/src/recur.h
index e220edb..ffacd91 100644
--- a/src/recur.h
+++ b/src/recur.h
@@ -45,7 +45,7 @@ uerr_t retrieve_tree (const char *);
 
 /* These are really in html-url.c. */
 struct urlpos *get_urls_file (const char *);
-struct urlpos *get_urls_html (const char *, const char *, int *);
+struct urlpos *get_urls_html (const char *, const char *, bool *);
 void free_urlpos (struct urlpos *);
 
 #endif /* RECUR_H */
diff --git a/src/res.c b/src/res.c
index f704d42..5b8ba30 100644
--- a/src/res.c
+++ b/src/res.c
@@ -86,8 +86,8 @@ so, delete this exception statement from your version.  */
 
 struct path_info {
   char *path;
-  int allowedp;
-  int user_agent_exact_p;
+  bool allowedp;
+  bool user_agent_exact_p;
 };
 
 struct robot_specs {
@@ -104,22 +104,22 @@ struct robot_specs {
 
 static void
 match_user_agent (const char *agent, int length,
-		  int *matches, int *exact_match)
+		  bool *matches, bool *exact_match)
 {
   if (length == 1 && *agent == '*')
     {
-      *matches = 1;
-      *exact_match = 0;
+      *matches = true;
+      *exact_match = false;
     }
   else if (BOUNDED_EQUAL_NO_CASE (agent, agent + length, "wget"))
     {
-      *matches = 1;
-      *exact_match = 1;
+      *matches = true;
+      *exact_match = true;
     }
   else
     {
-      *matches = 0;
-      *exact_match = 0;
+      *matches = false;
+      *exact_match = false;
     }
 }
 
@@ -128,7 +128,7 @@ match_user_agent (const char *agent, int length,
 
 static void
 add_path (struct robot_specs *specs, const char *path_b, const char *path_e,
-	  int allowedp, int exactp)
+	  bool allowedp, bool exactp)
 {
   struct path_info pp;
   if (path_b < path_e && *path_b == '/')
@@ -151,8 +151,8 @@ add_path (struct robot_specs *specs, const char *path_b, const char *path_e,
   specs->paths[specs->count - 1] = pp;
 }
 
-/* Recreate SPECS->paths with only those paths that have non-zero
-   user_agent_exact_p.  */
+/* Recreate SPECS->paths with only those paths that have
+   user_agent_exact_p set to true.  */
 
 static void
 prune_non_exact (struct robot_specs *specs)
@@ -222,15 +222,15 @@ res_parse (const char *source, int length)
   const char *p   = source;
   const char *end = source + length;
 
-  /* non-zero if last applicable user-agent field matches Wget. */
-  int user_agent_applies = 0;
+  /* true if last applicable user-agent field matches Wget. */
+  bool user_agent_applies = false;
 
-  /* non-zero if last applicable user-agent field *exactly* matches
+  /* true if last applicable user-agent field *exactly* matches
      Wget.  */
-  int user_agent_exact = 0;
+  bool user_agent_exact = false;
 
   /* whether we ever encountered exact user agent. */
-  int found_exact = 0;
+  bool found_exact = false;
 
   /* count of allow/disallow lines in the current "record", i.e. after
      the last `user-agent' instructions.  */
@@ -320,18 +320,18 @@ res_parse (const char *source, int length)
 	     until it matches, and if that happens, we must not call
 	     it any more, until the next record.  Hence the other part
 	     of the condition.  */
-	  if (record_count != 0 || user_agent_applies == 0)
+	  if (record_count != 0 || user_agent_applies == false)
 	    match_user_agent (value_b, value_e - value_b,
 			      &user_agent_applies, &user_agent_exact);
 	  if (user_agent_exact)
-	    found_exact = 1;
+	    found_exact = true;
 	  record_count = 0;
 	}
       else if (FIELD_IS ("allow"))
 	{
 	  if (user_agent_applies)
 	    {
-	      add_path (specs, value_b, value_e, 1, user_agent_exact);
+	      add_path (specs, value_b, value_e, true, user_agent_exact);
 	    }
 	  ++record_count;
 	}
@@ -339,11 +339,10 @@ res_parse (const char *source, int length)
 	{
 	  if (user_agent_applies)
 	    {
-	      int allowed = 0;
+	      bool allowed = false;
 	      if (value_b == value_e)
-		/* Empty "disallow" line means everything is
-		   *allowed*!  */
-		allowed = 1;
+		/* Empty "disallow" line means everything is *allowed*!  */
+		allowed = true;
 	      add_path (specs, value_b, value_e, allowed, user_agent_exact);
 	    }
 	  ++record_count;
@@ -424,11 +423,11 @@ free_specs (struct robot_specs *specs)
     }								\
 } while (0)
 
-/* The inner matching engine: return non-zero if RECORD_PATH matches
+/* The inner matching engine: return true if RECORD_PATH matches
    URL_PATH.  The rules for matching are described at
    <http://www.robotstxt.org/wc/norobots-rfc.txt>, section 3.2.2.  */
 
-static int
+static bool
 matches (const char *record_path, const char *url_path)
 {
   const char *rp = record_path;
@@ -439,13 +438,13 @@ matches (const char *record_path, const char *url_path)
       char rc = *rp;
       char uc = *up;
       if (!rc)
-	return 1;
+	return true;
       if (!uc)
-	return 0;
+	return false;
       DECODE_MAYBE(rc, rp);
       DECODE_MAYBE(uc, up);
       if (rc != uc)
-	return 0;
+	return false;
     }
 }
 
@@ -453,22 +452,22 @@ matches (const char *record_path, const char *url_path)
    matches, return its allow/reject status.  If none matches,
    retrieval is by default allowed.  */
 
-int
+bool
 res_match_path (const struct robot_specs *specs, const char *path)
 {
   int i;
   if (!specs)
-    return 1;
+    return true;
   for (i = 0; i < specs->count; i++)
     if (matches (specs->paths[i].path, path))
       {
-	int allowedp = specs->paths[i].allowedp;
+	bool allowedp = specs->paths[i].allowedp;
 	DEBUGP (("%s path %s because of rule `%s'.\n",
 		 allowedp ? "Allowing" : "Rejecting",
 		 path, specs->paths[i].path));
 	return allowedp;
       }
-  return 1;
+  return true;
 }
 
 /* Registering the specs. */
@@ -529,9 +528,9 @@ res_get_specs (const char *host, int port)
    serves URL.  The file will be named according to the currently
    active rules, and the file name will be returned in *file.
 
-   Return non-zero if robots were retrieved OK, zero otherwise.  */
+   Return true if robots were retrieved OK, false otherwise.  */
 
-int
+bool
 res_retrieve_file (const char *url, char **file)
 {
   uerr_t err;
diff --git a/src/res.h b/src/res.h
index 7a02762..da626ce 100644
--- a/src/res.h
+++ b/src/res.h
@@ -35,12 +35,12 @@ struct robot_specs;
 struct robot_specs *res_parse (const char *, int);
 struct robot_specs *res_parse_from_file (const char *);
 
-int res_match_path (const struct robot_specs *, const char *);
+bool res_match_path (const struct robot_specs *, const char *);
 
 void res_register_specs (const char *, int, struct robot_specs *);
 struct robot_specs *res_get_specs (const char *, int);
 
-int res_retrieve_file (const char *, char **);
+bool res_retrieve_file (const char *, char **);
 
 void res_cleanup (void);
 
diff --git a/src/retr.c b/src/retr.c
index c328d7b..30b81a8 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -60,7 +60,7 @@ FILE *output_stream;
 
 /* Whether output_document is a regular file we can manipulate,
    i.e. not `-' or a device file. */
-int output_stream_regular;
+bool output_stream_regular;
 
 static struct {
   wgint chunk_bytes;
@@ -206,9 +206,9 @@ fd_read_body (int fd, FILE *out, wgint toread, wgint startpos,
      continually update the display.  When true, smaller timeout
      values are used so that the gauge can update the display when
      data arrives slowly. */
-  int progress_interactive = 0;
+  bool progress_interactive = false;
 
-  int exact = flags & rb_read_exactly;
+  bool exact = !!(flags & rb_read_exactly);
   wgint skip = 0;
 
   /* How much data we've read/written.  */
@@ -496,10 +496,10 @@ fd_read_line (int fd)
 }
 
 /* Return a printed representation of the download rate, as
-   appropriate for the speed.  If PAD is non-zero, strings will be
-   padded to the width of 7 characters (xxxx.xx).  */
+   appropriate for the speed.  If PAD is true, strings will be padded
+   to the width of 7 characters (xxxx.xx).  */
 char *
-retr_rate (wgint bytes, double msecs, int pad)
+retr_rate (wgint bytes, double msecs, bool pad)
 {
   static char res[20];
   static const char *rate_names[] = {"B/s", "KB/s", "MB/s", "GB/s" };
@@ -555,7 +555,7 @@ calc_rate (wgint bytes, double msecs, int *units)
 #define MAX_REDIRECTIONS 20
 
 #define SUSPEND_POST_DATA do {			\
-  post_data_suspended = 1;			\
+  post_data_suspended = true;			\
   saved_post_data = opt.post_data;		\
   saved_post_file_name = opt.post_file_name;	\
   opt.post_data = NULL;				\
@@ -567,7 +567,7 @@ calc_rate (wgint bytes, double msecs, int *units)
     {							\
       opt.post_data = saved_post_data;			\
       opt.post_file_name = saved_post_file_name;	\
-      post_data_suspended = 0;				\
+      post_data_suspended = false;			\
     }							\
 } while (0)
 
@@ -585,14 +585,15 @@ retrieve_url (const char *origurl, char **file, char **newloc,
 {
   uerr_t result;
   char *url;
-  int location_changed, dummy;
+  bool location_changed;
+  int dummy;
   char *mynewloc, *proxy;
   struct url *u, *proxy_url;
   int up_error_code;		/* url parse error code */
   char *local_file;
   int redirection_count = 0;
 
-  int post_data_suspended = 0;
+  bool post_data_suspended = false;
   char *saved_post_data = NULL;
   char *saved_post_file_name = NULL;
 
@@ -662,9 +663,9 @@ retrieve_url (const char *origurl, char **file, char **newloc,
       /* If this is a redirection, we must not allow recursive FTP
 	 retrieval, so we save recursion to oldrec, and restore it
 	 later.  */
-      int oldrec = opt.recursive;
+      bool oldrec = opt.recursive;
       if (redirection_count)
-	opt.recursive = 0;
+	opt.recursive = false;
       result = ftp_loop (u, dt, proxy_url);
       opt.recursive = oldrec;
 
@@ -790,14 +791,14 @@ retrieve_url (const char *origurl, char **file, char **newloc,
   return result;
 }
 
-/* Find the URLs in the file and call retrieve_url() for each of
-   them.  If HTML is non-zero, treat the file as HTML, and construct
-   the URLs accordingly.
+/* Find the URLs in the file and call retrieve_url() for each of them.
+   If HTML is true, treat the file as HTML, and construct the URLs
+   accordingly.
 
    If opt.recursive is set, call retrieve_tree() for each file.  */
 
 uerr_t
-retrieve_from_file (const char *file, int html, int *count)
+retrieve_from_file (const char *file, bool html, int *count)
 {
   uerr_t status;
   struct urlpos *url_list, *cur_url;
@@ -863,12 +864,12 @@ printwhat (int n1, int n2)
 void
 sleep_between_retrievals (int count)
 {
-  static int first_retrieval = 1;
+  static bool first_retrieval = true;
 
   if (first_retrieval)
     {
       /* Don't sleep before the very first retrieval. */
-      first_retrieval = 0;
+      first_retrieval = false;
       return;
     }
 
@@ -941,7 +942,7 @@ rotate_backups(const char *fname)
   rename(fname, to);
 }
 
-static int no_proxy_match (const char *, const char **);
+static bool no_proxy_match (const char *, const char **);
 
 /* Return the URL of the proxy appropriate for url U.  */
 
@@ -990,11 +991,11 @@ getproxy (struct url *u)
 }
 
 /* Should a host be accessed through proxy, concerning no_proxy?  */
-static int
+static bool
 no_proxy_match (const char *host, const char **no_proxy)
 {
   if (!no_proxy)
-    return 1;
+    return true;
   else
     return !sufmatch (no_proxy, host);
 }
diff --git a/src/retr.h b/src/retr.h
index 4bc5504..cabb817 100644
--- a/src/retr.h
+++ b/src/retr.h
@@ -44,9 +44,9 @@ char *fd_read_hunk (int, hunk_terminator_t, long, long);
 char *fd_read_line (int);
 
 uerr_t retrieve_url (const char *, char **, char **, const char *, int *);
-uerr_t retrieve_from_file (const char *, int, int *);
+uerr_t retrieve_from_file (const char *, bool, int *);
 
-char *retr_rate (wgint, double, int);
+char *retr_rate (wgint, double, bool);
 double calc_rate (wgint, double, int *);
 void printwhat (int, int);
 
diff --git a/src/ssl.h b/src/ssl.h
index cd66259..03b6ea1 100644
--- a/src/ssl.h
+++ b/src/ssl.h
@@ -31,8 +31,8 @@ so, delete this exception statement from your version.  */
 #ifndef GEN_SSLFUNC_H
 #define GEN_SSLFUNC_H
 
-int ssl_init (void);
-int ssl_connect (int);
-int ssl_check_certificate (int, const char *);
+bool ssl_init (void);
+bool ssl_connect (int);
+bool ssl_check_certificate (int, const char *);
 
 #endif /* GEN_SSLFUNC_H */
diff --git a/src/url.c b/src/url.c
index 5f722c1..ca7179a 100644
--- a/src/url.c
+++ b/src/url.c
@@ -48,7 +48,7 @@ struct scheme_data
   const char *name;
   const char *leading_string;
   int default_port;
-  int enabled;
+  bool enabled;
 };
 
 /* Supported schemes: */
@@ -66,7 +66,7 @@ static struct scheme_data supported_schemes[] =
 
 /* Forward declarations: */
 
-static int path_simplify (char *);
+static bool path_simplify (char *);
 
 /* Support for escaping and unescaping of URL strings.  */
 
@@ -185,12 +185,12 @@ url_unescape (char *s)
 /* The core of url_escape_* functions.  Escapes the characters that
    match the provided mask in urlchr_table.
 
-   If ALLOW_PASSTHROUGH is non-zero, a string with no unsafe chars
-   will be returned unchanged.  If ALLOW_PASSTHROUGH is zero, a
-   freshly allocated string will be returned in all cases.  */
+   If ALLOW_PASSTHROUGH is true, a string with no unsafe chars will be
+   returned unchanged.  If ALLOW_PASSTHROUGH is false, a freshly
+   allocated string will be returned in all cases.  */
 
 static char *
-url_escape_1 (const char *s, unsigned char mask, int allow_passthrough)
+url_escape_1 (const char *s, unsigned char mask, bool allow_passthrough)
 {
   const char *p1;
   char *p2, *newstr;
@@ -234,7 +234,7 @@ url_escape_1 (const char *s, unsigned char mask, int allow_passthrough)
 char *
 url_escape (const char *s)
 {
-  return url_escape_1 (s, urlchr_unsafe, 0);
+  return url_escape_1 (s, urlchr_unsafe, false);
 }
 
 /* URL-escape the unsafe characters (see urlchr_table) in a given
@@ -243,30 +243,30 @@ url_escape (const char *s)
 static char *
 url_escape_allow_passthrough (const char *s)
 {
-  return url_escape_1 (s, urlchr_unsafe, 1);
+  return url_escape_1 (s, urlchr_unsafe, true);
 }
 
 /* Decide whether the char at position P needs to be encoded.  (It is
    not enough to pass a single char *P because the function may need
    to inspect the surrounding context.)
 
-   Return 1 if the char should be escaped as %XX, 0 otherwise.  */
+   Return true if the char should be escaped as %XX, false otherwise.  */
 
-static inline int
+static inline bool
 char_needs_escaping (const char *p)
 {
   if (*p == '%')
     {
       if (ISXDIGIT (*(p + 1)) && ISXDIGIT (*(p + 2)))
-	return 0;
+	return false;
       else
 	/* Garbled %.. sequence: encode `%'. */
-	return 1;
+	return true;
     }
   else if (URL_UNSAFE_CHAR (*p) && !URL_RESERVED_CHAR (*p))
-    return 1;
+    return true;
   else
-    return 0;
+    return false;
 }
 
 /* Translate a %-escaped (but possibly non-conformant) input string S
@@ -419,14 +419,14 @@ url_scheme (const char *url)
    currently implemented, it returns true if URL begins with
    [-+a-zA-Z0-9]+: .  */
 
-int
+bool
 url_has_scheme (const char *url)
 {
   const char *p = url;
 
   /* The first char must be a scheme char. */
   if (!*p || !SCHEME_CHAR (*p))
-    return 0;
+    return false;
   ++p;
   /* Followed by 0 or more scheme chars. */
   while (*p && SCHEME_CHAR (*p))
@@ -444,7 +444,7 @@ scheme_default_port (enum url_scheme scheme)
 void
 scheme_disable (enum url_scheme scheme)
 {
-  supported_schemes[scheme].enabled = 0;
+  supported_schemes[scheme].enabled = false;
 }
 
 /* Skip the username and password, if present in the URL.  The
@@ -467,18 +467,18 @@ url_skip_credentials (const char *url)
 /* Parse credentials contained in [BEG, END).  The region is expected
    to have come from a URL and is unescaped.  */
 
-static int
+static bool
 parse_credentials (const char *beg, const char *end, char **user, char **passwd)
 {
   char *colon;
   const char *userend;
 
   if (beg == end)
-    return 0;			/* empty user name */
+    return false;		/* empty user name */
 
   colon = memchr (beg, ':', end - beg);
   if (colon == beg)
-    return 0;			/* again empty user name */
+    return false;		/* again empty user name */
 
   if (colon)
     {
@@ -493,7 +493,7 @@ parse_credentials (const char *beg, const char *end, char **user, char **passwd)
     }
   *user = strdupdelim (beg, userend);
   url_unescape (*user);
-  return 1;
+  return true;
 }
 
 /* Used by main.c: detect URLs written using the "shorthand" URL forms
@@ -596,20 +596,20 @@ strpbrk_or_eos (const char *s, const char *accept)
 }
 #endif /* not __GNUC__ or old gcc */
 
-/* Turn STR into lowercase; return non-zero if a character was
-   actually changed. */
+/* Turn STR into lowercase; return true if a character was actually
+   changed. */
 
-static int
+static bool
 lowercase_str (char *str)
 {
-  int change = 0;
+  bool changed = false;
   for (; *str; str++)
     if (ISUPPER (*str))
       {
-	change = 1;
+	changed = true;
 	*str = TOLOWER (*str);
       }
-  return change;
+  return changed;
 }
 
 static const char *parse_errors[] = {
@@ -641,7 +641,7 @@ url_parse (const char *url, int *error)
 {
   struct url *u;
   const char *p;
-  int path_modified, host_modified;
+  bool path_modified, host_modified;
 
   enum url_scheme scheme;
 
@@ -844,7 +844,7 @@ url_parse (const char *url, int *error)
   if (strchr (u->host, '%'))
     {
       url_unescape (u->host);
-      host_modified = 1;
+      host_modified = true;
     }
 
   if (params_b)
@@ -859,7 +859,7 @@ url_parse (const char *url, int *error)
       /* If we suspect that a transformation has rendered what
 	 url_string might return different from URL_ENCODED, rebuild
 	 u->url using url_string.  */
-      u->url = url_string (u, 0);
+      u->url = url_string (u, false);
 
       if (url_encoded != url)
 	xfree ((char *) url_encoded);
@@ -1075,7 +1075,7 @@ sync_path (struct url *u)
 
   /* Regenerate u->url as well.  */
   xfree (u->url);
-  u->url = url_string (u, 0);
+  u->url = url_string (u, false);
 }
 
 /* Mutators.  Code in ftp.c insists on changing u->dir and u->file.
@@ -1295,11 +1295,11 @@ UWC,  C,  C,  C,   C,  C,  C,  C,   /* NUL SOH STX ETX  EOT ENQ ACK BEL */
    the quoted string to DEST.  Each character is quoted as per
    file_unsafe_char and the corresponding table.
 
-   If ESCAPED_P is non-zero, the path element is considered to be
+   If ESCAPED is true, the path element is considered to be
    URL-escaped and will be unescaped prior to inspection.  */
 
 static void
-append_uri_pathel (const char *b, const char *e, int escaped_p,
+append_uri_pathel (const char *b, const char *e, bool escaped,
 		   struct growable *dest)
 {
   const char *p;
@@ -1314,7 +1314,7 @@ append_uri_pathel (const char *b, const char *e, int escaped_p,
     mask |= filechr_control;
 
   /* Copy [b, e) to PATHEL and URL-unescape it. */
-  if (escaped_p)
+  if (escaped)
     {
       char *unescaped;
       BOUNDED_TO_ALLOCA (b, e, unescaped);
@@ -1404,7 +1404,7 @@ append_dir_structure (const struct url *u, struct growable *dest)
 
       if (dest->tail)
 	append_char ('/', dest);
-      append_uri_pathel (pathel, next, 1, dest);
+      append_uri_pathel (pathel, next, true, dest);
     }
 }
 
@@ -1465,14 +1465,14 @@ url_file_name (const struct url *u)
   if (fnres.tail)
     append_char ('/', &fnres);
   u_file = *u->file ? u->file : "index.html";
-  append_uri_pathel (u_file, u_file + strlen (u_file), 0, &fnres);
+  append_uri_pathel (u_file, u_file + strlen (u_file), false, &fnres);
 
   /* Append "?query" to the file name. */
   u_query = u->query && *u->query ? u->query : NULL;
   if (u_query)
     {
       append_char (FN_QUERY_SEP, &fnres);
-      append_uri_pathel (u_query, u_query + strlen (u_query), 1, &fnres);
+      append_uri_pathel (u_query, u_query + strlen (u_query), true, &fnres);
     }
 
   /* Zero-terminate the file name. */
@@ -1493,14 +1493,14 @@ url_file_name (const struct url *u)
       && !(file_exists_p (fname) && !file_non_directory_p (fname)))
     return fname;
 
-  unique = unique_name (fname, 1);
+  unique = unique_name (fname, true);
   if (unique != fname)
     xfree (fname);
   return unique;
 }
 
 /* Resolve "." and ".." elements of PATH by destructively modifying
-   PATH and return non-zero if PATH has been modified, zero otherwise.
+   PATH and return true if PATH has been modified, false otherwise.
 
    The algorithm is in spirit similar to the one described in rfc1808,
    although implemented differently, in one pass.  To recap, path
@@ -1513,7 +1513,7 @@ url_file_name (const struct url *u)
    function, run test_path_simplify to make sure you haven't broken a
    test case.  */
 
-static int
+static bool
 path_simplify (char *path)
 {
   char *h = path;		/* hare */
@@ -1710,7 +1710,7 @@ uri_merge (const char *base, const char *link)
       const char *slash;
       const char *start_insert = NULL; /* for gcc to shut up. */
       const char *pos = base;
-      int seen_slash_slash = 0;
+      bool seen_slash_slash = false;
       /* We're looking for the first slash, but want to ignore
 	 double slash. */
     again:
@@ -1719,7 +1719,7 @@ uri_merge (const char *base, const char *link)
 	if (*(slash + 1) == '/')
 	  {
 	    pos = slash + 2;
-	    seen_slash_slash = 1;
+	    seen_slash_slash = true;
 	    goto again;
 	  }
 
@@ -1760,7 +1760,7 @@ uri_merge (const char *base, const char *link)
 
 	 So, if BASE is "whatever/foo/bar", and LINK is "qux/xyzzy",
 	 our result should be "whatever/foo/qux/xyzzy".  */
-      int need_explicit_slash = 0;
+      bool need_explicit_slash = false;
       int span;
       const char *start_insert;
       const char *last_slash = find_last_char (base, end, '/');
@@ -1775,7 +1775,7 @@ uri_merge (const char *base, const char *link)
 	  /* example: http://host"  */
 	  /*                      ^ */
 	  start_insert = end + 1;
-	  need_explicit_slash = 1;
+	  need_explicit_slash = true;
 	}
       else
 	{
@@ -1811,23 +1811,23 @@ uri_merge (const char *base, const char *link)
 
 /* Recreate the URL string from the data in URL.
 
-   If HIDE is non-zero (as it is when we're calling this on a URL we
-   plan to print, but not when calling it to canonicalize a URL for
-   use within the program), password will be hidden.  Unsafe
-   characters in the URL will be quoted.  */
+   If HIDE is true (as it is when we're calling this on a URL we plan
+   to print, but not when calling it to canonicalize a URL for use
+   within the program), password will be hidden.  Unsafe characters in
+   the URL will be quoted.  */
 
 char *
-url_string (const struct url *url, int hide_password)
+url_string (const struct url *url, bool hide_password)
 {
   int size;
   char *result, *p;
   char *quoted_host, *quoted_user = NULL, *quoted_passwd = NULL;
 
-  int scheme_port  = supported_schemes[url->scheme].default_port;
+  int scheme_port = supported_schemes[url->scheme].default_port;
   const char *scheme_str = supported_schemes[url->scheme].leading_string;
   int fplen = full_path_length (url);
 
-  int brackets_around_host;
+  bool brackets_around_host;
 
   assert (scheme_str != NULL);
 
@@ -1910,22 +1910,22 @@ url_string (const struct url *url, int hide_password)
   return result;
 }
 
-/* Return non-zero if scheme a is similar to scheme b.
+/* Return true if scheme a is similar to scheme b.
  
    Schemes are similar if they are equal.  If SSL is supported, schemes
    are also similar if one is http (SCHEME_HTTP) and the other is https
    (SCHEME_HTTPS).  */
-int
+bool
 schemes_are_similar_p (enum url_scheme a, enum url_scheme b)
 {
   if (a == b)
-    return 1;
+    return true;
 #ifdef HAVE_SSL
   if ((a == SCHEME_HTTP && b == SCHEME_HTTPS)
       || (a == SCHEME_HTTPS && b == SCHEME_HTTP))
-    return 1;
+    return true;
 #endif
-  return 0;
+  return false;
 }
 
 #if 0
@@ -1942,10 +1942,10 @@ ps (char *path)
 }
 
 static void
-run_test (char *test, char *expected_result, int expected_change)
+run_test (char *test, char *expected_result, bool expected_change)
 {
   char *test_copy = xstrdup (test);
-  int modified = path_simplify (test_copy);
+  bool modified = path_simplify (test_copy);
 
   if (0 != strcmp (test_copy, expected_result))
     {
@@ -1954,7 +1954,7 @@ run_test (char *test, char *expected_result, int expected_change)
     }
   if (modified != expected_change)
     {
-      if (expected_change == 1)
+      if (expected_change)
 	printf ("Expected modification with path_simplify(\"%s\").\n",
 		test);
       else
@@ -1969,30 +1969,30 @@ test_path_simplify (void)
 {
   static struct {
     char *test, *result;
-    int should_modify;
+    bool should_modify;
   } tests[] = {
-    { "",			"",		0 },
-    { ".",			"",		1 },
-    { "./",			"",		1 },
-    { "..",			"..",		0 },
-    { "../",			"../",		0 },
-    { "foo",			"foo",		0 },
-    { "foo/bar",		"foo/bar",	0 },
-    { "foo///bar",		"foo///bar",	0 },
-    { "foo/.",			"foo/",		1 },
-    { "foo/./",			"foo/",		1 },
-    { "foo./",			"foo./",	0 },
-    { "foo/../bar",		"bar",		1 },
-    { "foo/../bar/",		"bar/",		1 },
-    { "foo/bar/..",		"foo/",		1 },
-    { "foo/bar/../x",		"foo/x",	1 },
-    { "foo/bar/../x/",		"foo/x/",	1 },
-    { "foo/..",			"",		1 },
-    { "foo/../..",		"..",		1 },
-    { "foo/../../..",		"../..",	1 },
-    { "foo/../../bar/../../baz", "../../baz",	1 },
-    { "a/b/../../c",		"c",		1 },
-    { "./a/../b",		"b",		1 }
+    { "",			"",		false },
+    { ".",			"",		true },
+    { "./",			"",		true },
+    { "..",			"..",		false },
+    { "../",			"../",		false },
+    { "foo",			"foo",		false },
+    { "foo/bar",		"foo/bar",	false },
+    { "foo///bar",		"foo///bar",	false },
+    { "foo/.",			"foo/",		true },
+    { "foo/./",			"foo/",		true },
+    { "foo./",			"foo./",	false },
+    { "foo/../bar",		"bar",		true },
+    { "foo/../bar/",		"bar/",		true },
+    { "foo/bar/..",		"foo/",		true },
+    { "foo/bar/../x",		"foo/x",	true },
+    { "foo/bar/../x/",		"foo/x/",	true },
+    { "foo/..",			"",		true },
+    { "foo/../..",		"..",		true },
+    { "foo/../../..",		"../..",	true },
+    { "foo/../../bar/../../baz", "../../baz",	true },
+    { "a/b/../../c",		"c",		true },
+    { "./a/../b",		"b",		true }
   };
   int i;
 
@@ -2000,7 +2000,7 @@ test_path_simplify (void)
     {
       char *test = tests[i].test;
       char *expected_result = tests[i].result;
-      int   expected_change = tests[i].should_modify;
+      bool  expected_change = tests[i].should_modify;
       run_test (test, expected_result, expected_change);
     }
 }
diff --git a/src/url.h b/src/url.h
index 985ccf8..2e9a4bd 100644
--- a/src/url.h
+++ b/src/url.h
@@ -83,11 +83,11 @@ void url_set_file (struct url *, const char *);
 void url_free (struct url *);
 
 enum url_scheme url_scheme (const char *);
-int url_has_scheme (const char *);
+bool url_has_scheme (const char *);
 int scheme_default_port (enum url_scheme);
 void scheme_disable (enum url_scheme);
 
-char *url_string (const struct url *, int);
+char *url_string (const struct url *, bool);
 char *url_file_name (const struct url *);
 
 char *uri_merge (const char *, const char *);
@@ -95,6 +95,6 @@ char *uri_merge (const char *, const char *);
 int mkalldirs (const char *);
 
 char *rewrite_shorthand_url (const char *);
-int schemes_are_similar_p (enum url_scheme a, enum url_scheme b);
+bool schemes_are_similar_p (enum url_scheme a, enum url_scheme b);
 
 #endif /* URL_H */
diff --git a/src/utils.c b/src/utils.c
index ba7f5a6..33d0eb5 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -292,7 +292,7 @@ fork_to_background (void)
 {
   pid_t pid;
   /* Whether we arrange our own version of opt.lfilename here.  */
-  int logfile_changed = 0;
+  bool logfile_changed = false;
 
   if (!opt.lfilename)
     {
@@ -301,10 +301,10 @@ fork_to_background (void)
 	 use fopen_excl) or lying to the user about the log file name
 	 (which arises from using unique_name, printing the name, and
 	 using fopen_excl later on.)  */
-      FILE *new_log_fp = unique_create (DEFAULT_LOGFILE, 0, &opt.lfilename);
+      FILE *new_log_fp = unique_create (DEFAULT_LOGFILE, false, &opt.lfilename);
       if (new_log_fp)
 	{
-	  logfile_changed = 1;
+	  logfile_changed = true;
 	  fclose (new_log_fp);
 	}
     }
@@ -318,7 +318,7 @@ fork_to_background (void)
   else if (pid != 0)
     {
       /* parent, no error */
-      printf (_("Continuing in background, pid %d.\n"), (int)pid);
+      printf (_("Continuing in background, pid %d.\n"), (int) pid);
       if (logfile_changed)
 	printf (_("Output will be written to `%s'.\n"), opt.lfilename);
       exit (0);			/* #### should we use _exit()? */
@@ -379,7 +379,7 @@ remove_link (const char *file)
    proper way should, of course, be to have a third, error state,
    other than true/false, but that would introduce uncalled-for
    additional complexity to the callers.  */
-int
+bool
 file_exists_p (const char *filename)
 {
 #ifdef HAVE_ACCESS
@@ -392,15 +392,15 @@ file_exists_p (const char *filename)
 
 /* Returns 0 if PATH is a directory, 1 otherwise (any kind of file).
    Returns 0 on error.  */
-int
+bool
 file_non_directory_p (const char *path)
 {
   struct_stat buf;
   /* Use lstat() rather than stat() so that symbolic links pointing to
      directories can be identified correctly.  */
   if (lstat (path, &buf) != 0)
-    return 0;
-  return S_ISDIR (buf.st_mode) ? 0 : 1;
+    return false;
+  return S_ISDIR (buf.st_mode) ? false : true;
 }
 
 /* Return the size of file named by FILENAME, or -1 if it cannot be
@@ -468,7 +468,7 @@ unique_name_1 (const char *prefix)
    (and therefore doesn't need changing).  */
 
 char *
-unique_name (const char *file, int allow_passthrough)
+unique_name (const char *file, bool allow_passthrough)
 {
   /* If the FILE itself doesn't exist, return it without
      modification. */
@@ -486,15 +486,15 @@ unique_name (const char *file, int allow_passthrough)
    opening the file returned by unique_name.  */
 
 FILE *
-unique_create (const char *name, int binary, char **opened_name)
+unique_create (const char *name, bool binary, char **opened_name)
 {
   /* unique file name, based on NAME */
-  char *uname = unique_name (name, 0);
+  char *uname = unique_name (name, false);
   FILE *fp;
   while ((fp = fopen_excl (uname, binary)) == NULL && errno == EEXIST)
     {
       xfree (uname);
-      uname = unique_name (name, 0);
+      uname = unique_name (name, false);
     }
   if (opened_name && fp != NULL)
     {
@@ -522,7 +522,7 @@ unique_create (const char *name, int binary, char **opened_name)
    appropriately.  */
    
 FILE *
-fopen_excl (const char *fname, int binary)
+fopen_excl (const char *fname, bool binary)
 {
   int fd;
 #ifdef O_EXCL
@@ -614,11 +614,11 @@ file_merge (const char *base, const char *file)
   return result;
 }
 
-static int in_acclist (const char *const *, const char *, int);
+static bool in_acclist (const char *const *, const char *, bool);
 
 /* Determine whether a file is acceptable to be followed, according to
    lists of patterns to accept/reject.  */
-int
+bool
 acceptable (const char *s)
 {
   int l = strlen (s);
@@ -630,24 +630,24 @@ acceptable (const char *s)
   if (opt.accepts)
     {
       if (opt.rejects)
-	return (in_acclist ((const char *const *)opt.accepts, s, 1)
-		&& !in_acclist ((const char *const *)opt.rejects, s, 1));
+	return (in_acclist ((const char *const *)opt.accepts, s, true)
+		&& !in_acclist ((const char *const *)opt.rejects, s, true));
       else
-	return in_acclist ((const char *const *)opt.accepts, s, 1);
+	return in_acclist ((const char *const *)opt.accepts, s, true);
     }
   else if (opt.rejects)
-    return !in_acclist ((const char *const *)opt.rejects, s, 1);
-  return 1;
+    return !in_acclist ((const char *const *)opt.rejects, s, true);
+  return true;
 }
 
 /* Compare S1 and S2 frontally; S2 must begin with S1.  E.g. if S1 is
    `/something', frontcmp() will return 1 only if S2 begins with
    `/something'.  Otherwise, 0 is returned.  */
-int
+bool
 frontcmp (const char *s1, const char *s2)
 {
   for (; *s1 && *s2 && (*s1 == *s2); ++s1, ++s2);
-  return !*s1;
+  return *s1 == '\0';
 }
 
 /* Iterate through STRLIST, and return the first element that matches
@@ -679,7 +679,7 @@ proclist (char **strlist, const char *s, enum accd flags)
 
    If FLAGS is ALLABS, the leading `/' is ignored in paths; relative
    and absolute paths may be freely intermixed.  */
-int
+bool
 accdir (const char *directory, enum accd flags)
 {
   /* Remove starting '/'.  */
@@ -688,34 +688,33 @@ accdir (const char *directory, enum accd flags)
   if (opt.includes)
     {
       if (!proclist (opt.includes, directory, flags))
-	return 0;
+	return false;
     }
   if (opt.excludes)
     {
       if (proclist (opt.excludes, directory, flags))
-	return 0;
+	return false;
     }
-  return 1;
+  return true;
 }
 
-/* Return non-zero if STRING ends with TAIL.  For instance:
+/* Return true if STRING ends with TAIL.  For instance:
 
-   match_tail ("abc", "bc", 0)  -> 1
-   match_tail ("abc", "ab", 0)  -> 0
-   match_tail ("abc", "abc", 0) -> 1
+   match_tail ("abc", "bc", false)  -> 1
+   match_tail ("abc", "ab", false)  -> 0
+   match_tail ("abc", "abc", false) -> 1
 
-   If FOLD_CASE_P is non-zero, the comparison will be
-   case-insensitive.  */
+   If FOLD_CASE is true, the comparison will be case-insensitive.  */
 
-int
-match_tail (const char *string, const char *tail, int fold_case_p)
+bool
+match_tail (const char *string, const char *tail, bool fold_case)
 {
   int i, j;
 
   /* We want this to be fast, so we code two loops, one with
      case-folding, one without. */
 
-  if (!fold_case_p)
+  if (!fold_case)
     {
       for (i = strlen (string), j = strlen (tail); i >= 0 && j >= 0; i--, j--)
 	if (string[i] != tail[j])
@@ -730,19 +729,19 @@ match_tail (const char *string, const char *tail, int fold_case_p)
 
   /* If the tail was exhausted, the match was succesful.  */
   if (j == -1)
-    return 1;
+    return true;
   else
-    return 0;
+    return false;
 }
 
 /* Checks whether string S matches each element of ACCEPTS.  A list
    element are matched either with fnmatch() or match_tail(),
    according to whether the element contains wildcards or not.
 
-   If the BACKWARD is 0, don't do backward comparison -- just compare
+   If the BACKWARD is false, don't do backward comparison -- just compare
    them normally.  */
-static int
-in_acclist (const char *const *accepts, const char *s, int backward)
+static bool
+in_acclist (const char *const *accepts, const char *s, bool backward)
 {
   for (; *accepts; accepts++)
     {
@@ -751,23 +750,23 @@ in_acclist (const char *const *accepts, const char *s, int backward)
 	  /* fnmatch returns 0 if the pattern *does* match the
 	     string.  */
 	  if (fnmatch (*accepts, s, 0) == 0)
-	    return 1;
+	    return true;
 	}
       else
 	{
 	  if (backward)
 	    {
 	      if (match_tail (s, *accepts, 0))
-		return 1;
+		return true;
 	    }
 	  else
 	    {
 	      if (!strcmp (s, *accepts))
-		return 1;
+		return true;
 	    }
 	}
     }
-  return 0;
+  return false;
 }
 
 /* Return the location of STR's suffix (file extension).  Examples:
@@ -789,20 +788,21 @@ suffix (const char *str)
     return NULL;
 }
 
-/* Return non-zero if S contains globbing wildcards (`*', `?', `[' or
+/* Return true if S contains globbing wildcards (`*', `?', `[' or
    `]').  */
 
-int
+bool
 has_wildcards_p (const char *s)
 {
   for (; *s; s++)
     if (*s == '*' || *s == '?' || *s == '[' || *s == ']')
-      return 1;
-  return 0;
+      return true;
+  return false;
 }
 
-/* Return non-zero if FNAME ends with a typical HTML suffix.  The
-   following (case-insensitive) suffixes are presumed to be HTML files:
+/* Return true if FNAME ends with a typical HTML suffix.  The
+   following (case-insensitive) suffixes are presumed to be HTML
+   files:
    
      html
      htm
@@ -810,20 +810,20 @@ has_wildcards_p (const char *s)
 
    #### CAVEAT.  This is not necessarily a good indication that FNAME
    refers to a file that contains HTML!  */
-int
+bool
 has_html_suffix_p (const char *fname)
 {
   char *suf;
 
   if ((suf = suffix (fname)) == NULL)
-    return 0;
+    return false;
   if (!strcasecmp (suf, "html"))
-    return 1;
+    return true;
   if (!strcasecmp (suf, "htm"))
-    return 1;
+    return true;
   if (suf[0] && !strcasecmp (suf + 1, "html"))
-    return 1;
-  return 0;
+    return true;
+  return false;
 }
 
 /* Read a line from FP and return the pointer to freshly allocated
@@ -898,14 +898,14 @@ read_file (const char *file)
   int fd;
   struct file_memory *fm;
   long size;
-  int inhibit_close = 0;
+  bool inhibit_close = false;
 
   /* Some magic in the finest tradition of Perl and its kin: if FILE
      is "-", just use stdin.  */
   if (HYPHENP (file))
     {
       fd = fileno (stdin);
-      inhibit_close = 1;
+      inhibit_close = true;
       /* Note that we don't inhibit mmap() in this case.  If stdin is
          redirected from a regular file, mmap() will still work.  */
     }
@@ -1694,8 +1694,8 @@ alarm_cancel (void)
 }
 
 /* Call FUN(ARG), but don't allow it to run for more than TIMEOUT
-   seconds.  Returns non-zero if the function was interrupted with a
-   timeout, zero otherwise.
+   seconds.  Returns true if the function was interrupted with a
+   timeout, false otherwise.
 
    This works by setting up SIGALRM to be delivered in TIMEOUT seconds
    using setitimer() or alarm().  The timeout is enforced by
@@ -1720,7 +1720,7 @@ alarm_cancel (void)
    are normally freed prior to exit from the functions, they will be
    lost in case of timeout.  */
 
-int
+bool
 run_with_timeout (double timeout, void (*fun) (void *), void *arg)
 {
   int saved_errno;
@@ -1728,7 +1728,7 @@ run_with_timeout (double timeout, void (*fun) (void *), void *arg)
   if (timeout == 0)
     {
       fun (arg);
-      return 0;
+      return false;
     }
 
   signal (SIGALRM, abort_run_with_timeout);
@@ -1736,7 +1736,7 @@ run_with_timeout (double timeout, void (*fun) (void *), void *arg)
     {
       /* Longjumped out of FUN with a timeout. */
       signal (SIGALRM, SIG_DFL);
-      return 1;
+      return true;
     }
   alarm_set (timeout);
   fun (arg);
@@ -1747,7 +1747,7 @@ run_with_timeout (double timeout, void (*fun) (void *), void *arg)
   signal (SIGALRM, SIG_DFL);
   errno = saved_errno;
 
-  return 0;
+  return false;
 }
 
 #else  /* not USE_SIGNAL_TIMEOUT */
@@ -1761,7 +1761,7 @@ int
 run_with_timeout (double timeout, void (*fun) (void *), void *arg)
 {
   fun (arg);
-  return 0;
+  return false;
 }
 #endif /* not WINDOWS */
 #endif /* not USE_SIGNAL_TIMEOUT */
diff --git a/src/utils.h b/src/utils.h
index 350f8e3..26364cb 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -55,7 +55,7 @@ char *xstrdup_lower (const char *);
 
 char *strdupdelim (const char *, const char *);
 char **sepstring (const char *);
-int frontcmp (const char *, const char *);
+bool frontcmp (const char *, const char *);
 void fork_to_background (void);
 
 char *aprintf (const char *, ...) GCC_FORMAT_ATTR (1, 2);
@@ -63,22 +63,22 @@ char *concat_strings (const char *, ...);
 
 void touch (const char *, time_t);
 int remove_link (const char *);
-int file_exists_p (const char *);
-int file_non_directory_p (const char *);
+bool file_exists_p (const char *);
+bool file_non_directory_p (const char *);
 wgint file_size (const char *);
 int make_directory (const char *);
-char *unique_name (const char *, int);
-FILE *unique_create (const char *, int, char **);
-FILE *fopen_excl (const char *, int);
+char *unique_name (const char *, bool);
+FILE *unique_create (const char *, bool, char **);
+FILE *fopen_excl (const char *, bool);
 char *file_merge (const char *, const char *);
 
-int acceptable (const char *);
-int accdir (const char *s, enum accd);
+bool acceptable (const char *);
+bool accdir (const char *s, enum accd);
 char *suffix (const char *s);
-int match_tail (const char *, const char *, int);
-int has_wildcards_p (const char *);
+bool match_tail (const char *, const char *, bool);
+bool has_wildcards_p (const char *);
 
-int has_html_suffix_p (const char *);
+bool has_html_suffix_p (const char *);
 
 char *read_whole_line (FILE *);
 struct file_memory *read_file (const char *);
@@ -105,7 +105,7 @@ int determine_screen_width (void);
 int random_number (int);
 double random_float (void);
 
-int run_with_timeout (double, void (*) (void *), void *);
+bool run_with_timeout (double, void (*) (void *), void *);
 void xsleep (double);
 
 /* How many bytes it will take to store LEN bytes in base64.  */
diff --git a/src/xmalloc.c b/src/xmalloc.c
index 96f1d18..268aa74 100644
--- a/src/xmalloc.c
+++ b/src/xmalloc.c
@@ -58,7 +58,7 @@ memfatal (const char *context, long attempted_size)
 {
   /* Make sure we don't try to store part of the log line, and thus
      call malloc.  */
-  log_set_save_context (0);
+  log_set_save_context (false);
   logprintf (LOG_ALWAYS,
 	     _("%s: %s: Failed to allocate %ld bytes; memory exhausted.\n"),
 	     exec_name, context, attempted_size);
@@ -252,15 +252,15 @@ register_ptr (const void *ptr, const char *file, int line)
   malloc_table[i].line = line;
 }
 
-/* Unregister PTR from malloc_table.  Return 0 if PTR is not present
-   in malloc_table.  */
+/* Unregister PTR from malloc_table.  Return false if PTR is not
+   present in malloc_table.  */
 
-static int
+static bool
 unregister_ptr (void *ptr)
 {
   int i = ptr_position (ptr);
   if (malloc_table[i].ptr == NULL)
-    return 0;
+    return false;
   malloc_table[i].ptr = NULL;
 
   /* Relocate malloc_table entries immediately following PTR. */
@@ -279,7 +279,7 @@ unregister_ptr (void *ptr)
     cont_outer:
       ;
     }
-  return 1;
+  return true;
 }
 
 /* Print the malloc debug stats gathered from the above information.
-- 
cgit v1.0-41-gc330

