@@ -1,3 +1,69 @@
+Changes to squid-3.4.0.1 (-- --- 2013):
+
+	- Port from 2.7: StoreURL (renamed Store-ID) support
+	- Bug 3795: fix several mistakes in the MIB file
+	- Bug 3793: configure: improved helper detection
+	- Bug 3722: Invalid markup in Armenian hy ERR_ONLY_IF_CACHED_MISS
+	- Bug 3676: Support GCC 4.7 with -Wshadow option
+	- Bug 3643: NTLM helpers stuck in reserved state by Safari
+	- Bug 3389: Auto-reconnect for tcp access_log
+	- Bug 2066: squid does not do chdir() after chroot()
+	- Fix uninitialized fields in IcapLogEntry
+	- Fix a number of minor issues detected by Coverity Scan
+	- Fix some potential memory leaks detected by Coverity Scan
+	- Fix 64-bit support for Intel compiler suite (ICC) and other similar compilers
+	- Fix ACL matching algorithm to avoid repeating tests
+	- basic_pam_auth: Add -r option to strip NTLM/Negotiate domain from username
+	- squidpurge: fix META TLV parsing issues
+	- squid.conf: enforce all the directive and option names are lower-case
+	- Support EUI on HTTPS and FTP data connections
+	- Support OK/ERR/BH response codes from any helper
+	- Support No-lookup flag (-n) on DNS ACLs
+	- Support -march=native compiler optimization by default
+	- Support forwarding intercepted but not bumped connections to cache_peers
+	- Support IPv6 NAT interception on Linux and some BSD
+	- Deprecate log_icap and log_access configuration directives
+	- HTTP/1.1: improved method invalidation and cacheability detection
+	- HTTP/1.1: support length configuration for pipeline_prefetch queue
+	- Improved TPROXY support for OpenBSD and FreeBSD
+	- Add storeid_file_rewrite helper to perform Store-ID rewrites from a rules file
+	- Add all-of and any-of ACL types for grouping sets of ACL tests
+	- Add note directive for transaction annotations
+	- Add %note log format for transaction annotation logging
+	- Add note ACL type for matching annotated transactions with by annotation name or value
+	- Add kv-pair support to URL-rewrite/redirector interface
+	- Add SSL server certificate validator interface, helper and result cache
+	- Add SSL server certificate fingerprint ACL type
+	- Add spoof_client_ip access control
+	- Add pt-bz (Belize Portuguese) dialect to translations
+	- ... and many Windows portability changes (still incomplete)
+	- ... and many documentation changes
+	- ... and much code cleanup and polishing
+
+Changes to squid-3.3.8 (13 Jul 2013):
+
+	- Bug 3869: assertion failed: MemBuf.cc:272: size < capacity
+	- Improved handling of port values in Host: header validation
+
+Changes to squid-3.3.7 (11 Jul 2013):
+
+	- Bug 3297: Fix openSSL related build failures
+	- Fix build on FreeBSD 9.x platform with clang
+	- Protect against buffer overrun in DNS query generation
+
+Changes to squid-3.3.6 (01 Jul 2013):
+
+	- Bug 3854: pt1: compile errors on AIX
+	- Bug 3802: Fix wrong check inside Format::Format::assemble
+	- Bug 3762: remove bogus WARNING in cache.log
+	- Bug 3717: assertion failed with dstdom_regex with IP based URL
+	- Bug 1991: kqueue causes SSL to hang
+	- Ask for SSL key password when started with -N but without sslpassword_program
+	- Make sure %<tt includes all [failed] connection attempts
+	- Support HTTP reply ACLs in icap_log and log_icap
+	- Fix incorrect external_acl_type codes
+	- Fix ICAP logging request headers and segmentation faults
+	- ... and some documentation polish
 
 Changes to squid-3.3.5 (20 May 2013):
 
@@ -90,6 +156,18 @@ Changes to squid-3.3.0.1 (21 Oct 2012):
 	- ... and many compile error fixes
 	- ... and a very large amount of code polish for faster compilation
 
+Changes to squid-3.2.13 (13 Jul 2013):
+
+	- Bug 3869: assertion failed: MemBuf.cc:272: size < capacity
+	- Improved handling of port values in Host: header validation
+
+Changes to squid-3.2.12 (11 Jul 2013):
+
+	- Protect against buffer overrun in DNS query generation
+	- Avoid !closing assertions when helpers call comm_read during reconfigure.
+	- Fix several minor memory leaks during reconfigure
+	- Remove origin_tries limiter on forwarding and permit large max_forward_tries values
+
 Changes to squid-3.2.11 (30 Apr 2013):
 
 	- Regression Bug 3839: build error: src/tools.h: No such file or directory
@@ -159,6 +159,37 @@ AC_DEFUN([SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS],[
 SQUID_STATE_ROLLBACK(check_SSL_get_certificate)
 ])
 
+dnl Checks whether the  SSL_CTX_new and similar functions require 
+dnl a const 'SSL_METHOD *' argument
+AC_DEFUN([SQUID_CHECK_OPENSSL_CONST_SSL_METHOD],[
+  AH_TEMPLATE(SQUID_USE_CONST_SSL_METHOD, "Define to 1 if the SSL_CTX_new and similar openSSL API functions require 'const SSL_METHOD *'")
+  SQUID_STATE_SAVE(check_const_SSL_METHOD)
+  AC_MSG_CHECKING(whether SSL_CTX_new and similar openSSL API functions require 'const SSL_METHOD *'")
+
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+       const SSL_METHOD *method = NULL;
+       SSL_CTX *sslContext = SSL_CTX_new(method);
+       return (sslContext != NULL);
+    ])
+  ],
+  [
+   AC_DEFINE(SQUID_USE_CONST_SSL_METHOD, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [])
+
+SQUID_STATE_ROLLBACK(check_const_SSL_METHOD)
+]
+)
 
 dnl Try to handle TXT_DB related  problems:
 dnl 1) The type of TXT_DB::data member changed in openSSL-1.0.1 version
@@ -167,11 +198,13 @@ dnl    implemented correctly and causes type conversion errors while compiling s
 
 AC_DEFUN([SQUID_CHECK_OPENSSL_TXTDB],[
   AH_TEMPLATE(SQUID_SSLTXTDB_PSTRINGDATA, "Define to 1 if the TXT_DB uses OPENSSL_PSTRING data member")
+  AH_TEMPLATE(SQUID_STACKOF_PSTRINGDATA_HACK, "Define to 1 to use squid workaround for buggy versions of sk_OPENSSL_PSTRING_value")
   AH_TEMPLATE(SQUID_USE_SSLLHASH_HACK, "Define to 1 to use squid workaround for openssl IMPLEMENT_LHASH_* type conversion errors")
 
   SQUID_STATE_SAVE(check_TXTDB)
 
   LIBS="$LIBS $SSLLIB"
+  squid_cv_check_openssl_pstring="no"
   AC_MSG_CHECKING(whether the TXT_DB use OPENSSL_PSTRING data member)
   AC_COMPILE_IFELSE([
   AC_LANG_PROGRAM(
@@ -187,12 +220,36 @@ AC_DEFUN([SQUID_CHECK_OPENSSL_TXTDB],[
   [
    AC_DEFINE(SQUID_SSLTXTDB_PSTRINGDATA, 1)
    AC_MSG_RESULT([yes])
+   squid_cv_check_openssl_pstring="yes"
   ],
   [
    AC_MSG_RESULT([no])
   ],
   [])
 
+  if test x"$squid_cv_check_openssl_pstring" = "xyes"; then
+     AC_MSG_CHECKING(whether the squid workaround for buggy versions of sk_OPENSSL_PSTRING_value should used)
+     AC_COMPILE_IFELSE([
+     AC_LANG_PROGRAM(
+       [
+        #include <openssl/txt_db.h>
+       ],
+       [
+       TXT_DB *db = NULL;
+       const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db->data, 0));
+       return (current_row != NULL);
+       ])
+     ],
+     [
+      AC_MSG_RESULT([no])
+     ],
+     [
+      AC_DEFINE(SQUID_STACKOF_PSTRINGDATA_HACK, 1)
+      AC_MSG_RESULT([yes])
+     ],
+     [])
+  fi
+
   AC_MSG_CHECKING(whether the workaround for OpenSSL IMPLEMENT_LHASH_  macros should used)
   AC_COMPILE_IFELSE([
   AC_LANG_PROGRAM(
@@ -123,8 +123,7 @@ echo "libtool  ($ltversion) : ${LIBTOOL_BIN}${ltver}"
 echo "libtool path : $ltpath"
 
 for dir in \
-	"" \
-	lib/libTrie
+	"" 
 do
     if [ -z "$dir" ] || [ -d $dir ]; then
 	if (
@@ -195,7 +195,8 @@ AM_CONDITIONAL(ENABLE_WIN32SPECIFIC,
                [test "x$squid_host_os" = "xmingw" -o "x$squid_host_os" = "xcygwin"])
 AM_CONDITIONAL(USE_IPC_WIN32,[test "x$squid_host_os" = "xmingw"])
 
-if test "x$squid_host_os" = "xmingw"; then
+case "$squid_host_os" in
+mingw)
   AC_PATH_PROG(WIN32_PSAPI, psapi.dll, none)
   CFLAGS="$CFLAGS -mthreads"
   CXXFLAGS="$CXXFLAGS -mthreads"
@@ -208,7 +209,16 @@ if test "x$squid_host_os" = "xmingw"; then
   fi
   MINGW_LIBS="-lmingwex"
   AC_SUBST(MINGW_LIBS)
-fi
+  ;;
+freebsd)
+    # FreeBSD places local libraries and packages in /usr/local
+    CFLAGS="$CFLAGS -I/usr/local/include"
+    CXXFLAGS="$CXXFLAGS -I/usr/local/include"
+    LDFLAGS="$LDFLAGS -L/usr/local/lib -Wl,-R/usr/local/lib"
+    ;;
+*)
+    ;;
+esac
 
 dnl Substitutions
 AC_DEFINE_UNQUOTED(CONFIG_HOST_TYPE, "$host",[Host type from configure])
@@ -329,12 +339,6 @@ dnl -Werror -Wmissing-prototypes -Wmissing-declarations
 dnl TODO: check if the problem will be present in any other newer MinGW release.
     SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
     ;;
-  freebsd)
-    # FreeBSD places local libraries and packages in /usr/local
-    CFLAGS="$CFLAGS -I/usr/local/include"
-    CXXFLAGS="$CXXFLAGS -I/usr/local/include"
-    LDFLAGS="$LDFLAGS -L/usr/local/lib -Wl,-R/usr/local/lib"
-    ;;
   *)
     SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow"
     ;;
@@ -1277,6 +1281,7 @@ AC_SUBST(SSLLIB)
 
 if test "x$with_openssl" = "xyes"; then
 SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS
+SQUID_CHECK_OPENSSL_CONST_SSL_METHOD
 SQUID_CHECK_OPENSSL_TXTDB
 fi
 
@@ -1963,6 +1968,18 @@ AC_ARG_ENABLE(url-rewrite-helpers,
 ])
 m4_include([helpers/url_rewrite/modules.m4])
 
+dnl Select storeid_rewrite helpers to build
+AC_ARG_ENABLE(storeid-rewrite-helpers,
+  AS_HELP_STRING([--enable-storeid-rewrite-helpers="list of helpers"],
+                 [This option selects which Store-ID rewrite helpers to
+                  build and install as part of the normal build
+                  process. The default is to attempt the build of all possible
+                  helpers. Use --disable-storeid-rewrite-helpers to build none.
+                  For a list of available helpers see the
+                  helpers/storeid_rewrite directory.]),[
+])
+m4_include([helpers/storeid_rewrite/modules.m4])
+
 AC_ARG_WITH(valgrind-debug,
   AS_HELP_STRING([--with-valgrind-debug],
                  [Include debug instrumentation for use with valgrind]),
@@ -2253,8 +2270,9 @@ AC_CHECK_HEADERS( \
   wchar.h
 )
 
-AC_CHECK_HEADERS(
-  linux/netfilter_ipv4.h
+AC_CHECK_HEADERS( \
+  linux/netfilter_ipv4.h \
+  linux/netfilter_ipv6/ip6_tables.h \
 ,,,
 SQUID_DEFAULT_INCLUDES
 #if HAVE_LIMITS_H
@@ -3373,6 +3391,8 @@ AC_CONFIG_FILES([\
 	compat/Makefile \
 	lib/Makefile \
 	lib/ntlmauth/Makefile \
+	lib/libTrie/Makefile \
+	lib/libTrie/test/Makefile \
 	lib/profiler/Makefile \
 	lib/rfcnb/Makefile \
 	lib/smblib/Makefile \
@@ -3457,12 +3477,12 @@ AC_CONFIG_FILES([\
 	helpers/url_rewrite/Makefile \
 	helpers/url_rewrite/fake/Makefile \
 	helpers/ssl/Makefile \
+	helpers/storeid_rewrite/Makefile \
+	helpers/storeid_rewrite/file/Makefile \
 	tools/Makefile
 	tools/purge/Makefile
 ])
 
-AC_CONFIG_SUBDIRS(lib/libTrie)
-
 # must configure libltdl subdir unconditionally for "make distcheck" to work
 #AC_CONFIG_SUBDIRS(libltdl)
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.11 release notes</title>
+<title>Squid 3.2.13 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.11.
+The Squid Team are pleased to announce the release of Squid-3.2.13.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.5 release notes</title>
+<title>Squid 3.3.8 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.5.
+The Squid Team are pleased to announce the release of Squid-3.3.8.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
 <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -26,7 +26,10 @@ <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></
 <UL>
 <LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
 <LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
-<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">Store-ID</A>
+<LI><A NAME="toc2.4">2.4</A> <A HREF="#ss2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<LI><A NAME="toc2.5">2.5</A> <A HREF="#ss2.5">Transaction Annotations</A>
+<LI><A NAME="toc2.6">2.6</A> <A HREF="#ss2.6">Multicast DNS</A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
@@ -84,7 +87,10 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></
 <UL>
 <LI>Helper protocol extensions</LI>
 <LI>SSL Server Certificate Validator</LI>
+<LI>Store-ID</LI>
 <LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
+<LI>Transaction Annotations</LI>
+<LI>Multicast DNS</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
@@ -146,7 +152,39 @@ <H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</
 <EM>ssl_crtd</EM> related options. </P>
 
 
-<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">Store-ID</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/StoreID">http://wiki.squid-cache.org/Features/StoreID</A>.</P>
+
+<P>This feature is a redesigned equivalent to the Squid-2.7 feature known as StoreURL-rewrite.</P>
+
+<P><EM>Notice</EM> that this is not a direct portage of the Squid-2.7 feature so behaviour
+differences do exist. Although the new feature works in similar enough ways that the old
+helper scripts used for Squid-2.7 are expected to work in this and later versions of Squid.</P>
+
+<P>Squid traditionally uses the requested URL as an index key ID to locate objects in cache.
+It is not the only key possible and the Store-ID feature exposes an API for external
+helpers to provide Squid with an alternative key name for any URL.</P>
+
+<P>When any client request is received which requires a cache lookup the URL is passed to
+a helper specified with the <EM>store_id_program</EM> directive to check for an alternative
+Store ID. This allows the helper to identify URLs which refer to duplicate resources and
+de-duplicate the cache content. <EM>store_id_access</EM> is provided to allow ACL-based
+tuning of which traffic gets sent to the helper and reduce overheads.</P>
+
+<P>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
+this feature is that <EM>refresh_pattern</EM> applies its regex argument against the Store
+ID key and not the transaction URL. So using the Store-ID feature to alter the value
+affects which <EM>refresh_pattern</EM> directive will be matched.</P>
+
+<P>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
+options which is added in this version. Currently there is a <EM>file</EM> helper
+provided.</P>
+
+
+<H2><A NAME="ss2.4">2.4</A> <A HREF="#toc2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
 </H2>
 
 <P>Details at 
@@ -170,9 +208,66 @@ <H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ an
 These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
 
 
+<H2><A NAME="ss2.5">2.5</A> <A HREF="#toc2.5">Transaction Annotations</A>
+</H2>
+
+<P>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
+or external ACL <EM>tag=</EM> result code. Each of which had only limited possibilities
+for use and little or no correlation.</P>
+
+<P>It is now possible to add annotations to a client transaction from several sources:
+<UL>
+<LI>    Directly from squid.conf using the <EM>note</EM> directive with
+ACL-based selection of which annotation is linked to any
+particular transaction.
+</LI>
+<LI>    By configured helper processes returning a key=value pair.
+The key name becomes the annotation name.</LI>
+</UL>
+</P>
+
+<P>Annotations on the transaction can be passed to ICAP services or eCAP modules using the
+<EM>adaptation_meta</EM> directive to send them as headers.
+They can also be logged using the <EM>%note</EM> log format code in custom logs. With
+the new helper response syntax changes this means all helper response key=value details
+such as URL-rewrite or store-id changes, external ACL tag etc. are now able to be logged.</P>
+
+<P>Annotations which are already assigned to a transaction can be checked using an ACL test
+of the new <EM>note</EM> ACL type. This can match a particular note by name and value,
+of for any notes with a given name.</P>
+
+<P>NOTE: not all helper interfaces are yet enabled to convert key=value into annotations
+and the external ACL interface does not yet send annotations to the helper.</P>
+
+
+<H2><A NAME="ss2.6">2.6</A> <A HREF="#toc2.6">Multicast DNS</A>
+</H2>
+
+<P>The internal DNS component fof Squid now supports multicast DNS (mDNS) resolution in
+accordance with RFC 6762.</P>
+
+<P>There is no additional or special configuration required. The multicast DNS group IP
+addresses for IPv4 and IPv6 resolving are added to the set of available DNS resolvers
+and used automatically for domain names ending in <EM>.local</EM> before attempting a
+secondary resolution on the configured resolvers. Domains without <EM>.local</EM> are
+resolved using only the configured DNS resolvers.</P>
+
+<P>Statistics for multicast DNS resolution can be found on the <EM>idns</EM> cache manager
+report.</P>
+
+
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <P>There have been changes to Squid's configuration file since Squid-3.3.</P>
+
+<P>Squid supports reading configuration option parameters from external
+files using the syntax <EM>parameters("/path/filename")</EM>. For example:
+<PRE>
+    acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
+</PRE>
+</P>
+
+<P>There hasve also been changes to individual directives in the config file.</P>
 <P>This section gives a thorough account of those changes in three categories:</P>
 <P>
 <UL>
@@ -191,6 +286,10 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 
 <P>
 <DL>
+<DT><B>configuration_includes_quoted_values</B><DD>
+<P>Whether Squid supports directive parameters with spaces, quotes, and other
+special characters. Surround such parameters with "double quotes".</P>
+
 <DT><B>note</B><DD>
 <P>Use ACLs to annotate a transaction with customized annotations
 which can be logged in access.log</P>
@@ -205,6 +304,28 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 <DT><B>sslcrtvalidator_program</B><DD>
 <P>Specifies the location of a SSL server certificate validator helper.</P>
 
+<DT><B>store_id_access</B><DD>
+<P>Whether the URL for a given request is passed to the Store-ID helper process.
+Used to improve StoreID performance by quickly eliminating helper delays using ACL tests.</P>
+<P>Ported equivalent to <EM>storeurl_access</EM> from 2.7</P>
+
+<DT><B>store_id_bypass</B><DD>
+<P>Whether the StoreID helper may be bypassed when overloaded.</P>
+
+<DT><B>store_id_children</B><DD>
+<P>Controls the number of StoreID helper processes.</P>
+<P>Options <EM>startup=N</EM>, <EM>idle=N</EM>, <EM>concurrency=N</EM>
+<UL>
+<LI>startup=N allow finer tuning of how many helpers are started initially.</LI>
+<LI>idle=N allow fine tuning of how many helper to retain as buffer against sudden traffic loads.</LI>
+<LI>concurrency=N was previously called url_rewrite_concurrency as a distinct directive.</LI>
+</UL>
+</P>
+
+<DT><B>storeurl_rewrite_program</B><DD>
+<P>A helper program to provide cache storage internal key ID value for a request.</P>
+<P>Ported equivalent to <EM>storeurl_rewrite_program</EM> from 2.7</P>
+
 </DL>
 </P>
 
@@ -213,9 +334,24 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 
 <P>
 <DL>
+<DT><B>access_log</B><DD>
+<P>Configuration syntax extended to support name=value options.
+<EM>New Syntax:</EM> access_log module:place [option ...] [acl ...]</P>
+<P>New option <EM>logformat=</EM> to specify the logging format name.</P>
+<P>New option <EM>buffer-size=</EM> to specify how large the log buffer
+for this log is to be when <EM>buffered_logs</EM> is enabled.</P>
+<P>New option <EM>on-error=</EM> to specify what handling is to be done
+if the logging module encounters a non-recoverable error writing logs.
+With the value <EM>die</EM> (the default) Squid halts operation.
+With the value <EM>drop</EM> Squid drops log lines and continue running.</P>
+
 <DT><B>acl</B><DD>
 <P>New test type <EM>server_cert_fingerprint</EM> to match against 
 server SSL certificate fingerprint.</P>
+<P>New test type <EM>note</EM> to match against transaction annotations
+by name and value, or just by name.</P>
+<P>New test type <EM>any-of</EM> to match if any one of a set of named ACLs.</P>
+<P>New test type <EM>all-of</EM> to match against all of a set of named ACLs.</P>
 
 <DT><B>auth_param</B><DD>
 <P>New result code <EM>BH</EM> to signal helper internal errors
@@ -235,6 +371,10 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
 <DT><B>http_port</B><DD>
+<P>Support IPv6 for <EM>intercept</EM> mode. Requires ip6tables support on Linux,
+PF support on OpenBSD and IPFW support on FreeBSD. Squid will no longer complain
+about misconfiguration if IPv6 support is missing, we now rely on the firewall
+tools reporting misconfiguration when the NAT rules are created.</P>
 <P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
 (OpenBSD 5+, FreeBSD 9+ so far).</P>
 <P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
@@ -243,6 +383,18 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <DT><B>logformat</B><DD>
 <P>New format code <EM>%note</EM> to log a transaction annotation linked to the
 transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
+<P>New format code <EM>%&gt;qos</EM> to log client connection TOS/DSCP value set by Squid.</P>
+<P>New format code <EM>%&lt;qos</EM> to log server connection TOS/DSCP value set by Squid.</P>
+<P>New format code <EM>%&gt;nfmark</EM> to log client connection netfilter mark set by Squid.</P>
+<P>New format code <EM>%&lt;nfmark</EM> to log server connection netfilter mark set by Squid.</P>
+
+<DT><B>pipeline_prefetch</B><DD>
+<P>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.</P>
+
+<DT><B>refresh_pattern</B><DD>
+<P><EM>NOTE:</EM> the regular expression pattern operates on the cache Store-ID value.
+Which by default is identical to the requested URL, but may differ for some
+objects if the Store-ID feature is in use.</P>
 
 <DT><B>unlinkd_program</B><DD>
 <P>New helper response format utilizing result codes <EM>OK</EM> and <EM>BH</EM>,
@@ -266,19 +418,17 @@ <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed
 
 <P>
 <DL>
-<P><EM>There are no removed squid.conf tags in Squid-3.4.</EM></P>
-
 <DT><B>storeurl_access</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_access</EM>.</P>
 
 <DT><B>storeurl_rewrite_children</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_children</EM>.</P>
 
 <DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_children</EM> with <EM>concurrency=N</EM> option.</P>
 
 <DT><B>storeurl_rewrite_program</B><DD>
-<P>Not yet ported from 2.7</P>
+<P>Replaced by <EM>store_id_program</EM>.</P>
 
 </DL>
 </P>
@@ -305,6 +455,12 @@ <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New opti
 
 <P>
 <DL>
+<DT><B>--enable-storeid-rewrite-helpers</B><DD>
+<P>New option to control which Store-ID helpers are built. As with other
+helper options use --disable-* to prevent any helpers building and
+omit to get all helper auto-detected.</P>
+<P>Currenly only a helper using <EM>file</EM> for backend is provided.</P>
+
 <DT><B>--with-nat-pf</B><DD>
 <P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
 in squid.conf.</P>
@@ -346,7 +502,7 @@ <H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Remo
 
 <H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
 
-<P>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3</P>
+<P>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.4</P>
 
 <P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
 
@@ -43,6 +43,7 @@ The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Store-ID
 	<item>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
 	<item>Transaction Annotations
+	<item>Multicast DNS
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -110,16 +111,20 @@ Most user-facing changes are reflected in squid.conf (see below).
    helpers to provide Squid with an alternative key name for any URL.
 
 <p>When any client request is received which requires a cache lookup the URL is passed to
-   a helper specified with the <em>store_id_rewrite_program</em> directive to check for
-   an alternative Store ID. This allows the helper to identify URLs which refer to duplicate
-   resources and de-duplicate the cache content. <em>store_id_access</em> is provided to
-   allow ACL-based tuning of which traffic gets sent to the helper and reduce overheads.
+   a helper specified with the <em>store_id_program</em> directive to check for an alternative
+   Store ID. This allows the helper to identify URLs which refer to duplicate resources and
+   de-duplicate the cache content. <em>store_id_access</em> is provided to allow ACL-based
+   tuning of which traffic gets sent to the helper and reduce overheads.
 
 <p>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
    this feature is that <em>refresh_pattern</em> applies its regex argument against the Store
    ID key and not the transaction URL. So using the Store-ID feature to alter the value
    affects which <em>refresh_pattern</em> directive will be matched.
 
+<p>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
+   options which is added in this version. Currently there is a <em>file</em> helper
+   provided.
+
 
 <sect1>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
 <p>Details at <url url="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">.
@@ -141,6 +146,7 @@ Most user-facing changes are reflected in squid.conf (see below).
    which do not yet support the getsockname() API.
    These systems require <em>--with-nat-devpf</em> to enable /dev/pf support when using PF firewall.
 
+
 <sect1>Transaction Annotations
 <p>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
    or external ACL <em>tag=</em> result code. Each of which had only limited possibilities
@@ -170,10 +176,32 @@ Most user-facing changes are reflected in squid.conf (see below).
 	 and the external ACL interface does not yet send annotations to the helper.
 
 
+<sect1>Multicast DNS
+<p>The internal DNS component fof Squid now supports multicast DNS (mDNS) resolution in
+    accordance with RFC 6762.
+
+<p>There is no additional or special configuration required. The multicast DNS group IP
+   addresses for IPv4 and IPv6 resolving are added to the set of available DNS resolvers
+   and used automatically for domain names ending in <em>.local</em> before attempting a
+   secondary resolution on the configured resolvers. Domains without <em>.local</em> are
+   resolved using only the configured DNS resolvers.
+
+<p>Statistics for multicast DNS resolution can be found on the <em>idns</em> cache manager
+   report.
+
+
 <sect>Changes to squid.conf since Squid-3.3
 <p>
 There have been changes to Squid's configuration file since Squid-3.3.
 
+<p>Squid supports reading configuration option parameters from external
+   files using the syntax <em>parameters("/path/filename")</em>. For example:
+<verb>
+    acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
+</verb>
+
+<p>There hasve also been changes to individual directives in the config file.
+
 This section gives a thorough account of those changes in three categories:
 
 <itemize>
@@ -186,6 +214,10 @@ This section gives a thorough account of those changes in three categories:
 <sect1>New tags<label id="newtags">
 <p>
 <descrip>
+	<tag>configuration_includes_quoted_values</tag>
+	<p>Whether Squid supports directive parameters with spaces, quotes, and other
+	   special characters. Surround such parameters with "double quotes".
+
 	<tag>note</tag>
 	<p>Use ACLs to annotate a transaction with customized annotations
 	   which can be logged in access.log
@@ -200,6 +232,27 @@ This section gives a thorough account of those changes in three categories:
 	<tag>sslcrtvalidator_program</tag>
 	<p>Specifies the location of a SSL server certificate validator helper.
 
+	<tag>store_id_access</tag>
+	<p>Whether the URL for a given request is passed to the Store-ID helper process.
+	   Used to improve StoreID performance by quickly eliminating helper delays using ACL tests.
+	<p>Ported equivalent to <em>storeurl_access</em> from 2.7
+
+	<tag>store_id_bypass</tag>
+	<p>Whether the StoreID helper may be bypassed when overloaded.
+
+	<tag>store_id_children</tag>
+	<p>Controls the number of StoreID helper processes.
+        <p>Options <em>startup=N</em>, <em>idle=N</em>, <em>concurrency=N</em>
+        <itemize>
+                <item>startup=N allow finer tuning of how many helpers are started initially.
+                <item>idle=N allow fine tuning of how many helper to retain as buffer against sudden traffic loads.
+                <item>concurrency=N was previously called url_rewrite_concurrency as a distinct directive.
+        </itemize>
+
+	<tag>storeurl_rewrite_program</tag>
+	<p>A helper program to provide cache storage internal key ID value for a request.
+	<p>Ported equivalent to <em>storeurl_rewrite_program</em> from 2.7
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -240,6 +293,10 @@ This section gives a thorough account of those changes in three categories:
 	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
 
 	<tag>http_port</tag>
+	<p>Support IPv6 for <em>intercept</em> mode. Requires ip6tables support on Linux,
+	   PF support on OpenBSD and IPFW support on FreeBSD. Squid will no longer complain
+	   about misconfiguration if IPv6 support is missing, we now rely on the firewall
+	   tools reporting misconfiguration when the NAT rules are created.
 	<p>Support <em>tproxy</em> mode traffic on BSD systems with BINDANY support
 	   (OpenBSD 5+, FreeBSD 9+ so far).
 	<p>Changed build options behind <em>intercept</em> traffic mode handling on BSD.
@@ -248,10 +305,19 @@ This section gives a thorough account of those changes in three categories:
 	<tag>logformat</tag>
 	<p>New format code <em>%note</em> to log a transaction annotation linked to the
 	   transaction by ICAP, eCAP, a helper, or the <em>note</em> squid.conf directive.
+	<p>New format code <em>%&gt;qos</em> to log client connection TOS/DSCP value set by Squid.
+	<p>New format code <em>%&lt;qos</em> to log server connection TOS/DSCP value set by Squid.
+	<p>New format code <em>%&gt;nfmark</em> to log client connection netfilter mark set by Squid.
+	<p>New format code <em>%&lt;nfmark</em> to log server connection netfilter mark set by Squid.
 
 	<tag>pipeline_prefetch</tag>
 	<p>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.
 
+	<tag>refresh_pattern</tag>
+	<p><em>NOTE:</em> the regular expression pattern operates on the cache Store-ID value.
+	   Which by default is identical to the requested URL, but may differ for some
+	   objects if the Store-ID feature is in use.
+
 	<tag>unlinkd_program</tag>
 	<p>New helper response format utilizing result codes <em>OK</em> and <em>BH</em>,
 	   to signal helper lookup results. Also, key-value response values to return
@@ -269,8 +335,18 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
-	<p><em>There are no removed squid.conf tags in Squid-3.4.</em>
+	<tag>storeurl_access</tag>
+	<p>Replaced by <em>store_id_access</em>.
+
+	<tag>storeurl_rewrite_children</tag>
+	<p>Replaced by <em>store_id_children</em>.
+
+	<tag>storeurl_rewrite_concurrency</tag>
+	<p>Replaced by <em>store_id_children</em> with <em>concurrency=N</em> option.
 
+	<tag>storeurl_rewrite_program</tag>
+	<p>Replaced by <em>store_id_program</em>.
+	
 </descrip>
 
 
@@ -290,6 +366,12 @@ This section gives an account of those changes in three categories:
 <sect1>New options<label id="newoptions">
 <p>
 <descrip>
+	<tag>--enable-storeid-rewrite-helpers</tag>
+	<p>New option to control which Store-ID helpers are built. As with other
+	   helper options use --disable-* to prevent any helpers building and
+	   omit to get all helper auto-detected.
+	<p>Currenly only a helper using <em>file</em> for backend is provided.
+
 	<tag>--with-nat-pf</tag>
 	<p>New option to alter the behaviour of <em>http_port ... intercept</em> option
 	   in squid.conf.
@@ -326,7 +408,7 @@ This section gives an account of those changes in three categories:
 
 <sect>Regressions since Squid-2.7
 
-<p>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3
+<p>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.4
 
 <p>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.
 
@@ -385,18 +467,6 @@ This section gives an account of those changes in three categories:
 	<tag>refresh_stale_hit</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>storeurl_access</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>storeurl_rewrite_children</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>storeurl_rewrite_concurrency</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>storeurl_rewrite_program</tag>
-	<p>Not yet ported from 2.7
-	
 	<tag>update_headers</tag>
 	<p>Not yet ported from 2.7
 
@@ -8,15 +8,17 @@ DIST_SUBDIRS = \
 	negotiate_auth \
 	ntlm_auth \
 	url_rewrite \
-	ssl
+	ssl \
+	storeid_rewrite
 
 SUBDIRS = \
 	basic_auth \
 	digest_auth \
 	external_acl \
 	log_daemon \
 	negotiate_auth \
-	url_rewrite
+	url_rewrite \
+	storeid_rewrite
 
 if ENABLE_AUTH_NTLM
 SUBDIRS += ntlm_auth
@@ -0,0 +1,3 @@
+
+DIST_SUBDIRS	= file
+SUBDIRS		= $(STOREID_REWRITE_HELPERS)
@@ -0,0 +1,15 @@
+include $(top_srcdir)/src/Common.am
+
+libexec_SCRIPTS	= storeid_file_rewrite
+CLEANFILES += storeid_file_rewrite storeid_file_rewrite.8
+man_MANS = storeid_file_rewrite.8
+EXTRA_DIST= \
+	storeid_file_rewrite.8 \
+	storeid_file_rewrite.pl.in \
+	required.m4
+
+storeid_file_rewrite.8: storeid_file_rewrite
+	pod2man storeid_file_rewrite storeid_file_rewrite.8
+
+storeid_file_rewrite: storeid_file_rewrite.pl.in
+	$(subst_perlshell)
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="file"
+fi
@@ -0,0 +1,92 @@
+#!@PERL@
+use strict;
+use warnings;
+$|=1;
+
+=pod
+
+=head1 NAME
+
+storeid_file_rewrite - File based Store-ID helper for Squid
+
+=head1 SYNOPSIS
+
+storeid_file_rewrite filepath
+
+=head1 DESCRIPTOIN
+
+This program acts as a store_id helper program, rewriting URLs passed
+by Squid into storage-ids that can be used to achieve better caching
+for websites that use different URLs for the same content.
+
+It takes a text file with two tab separated columns.
+Column 1: Regular expression to match against the URL
+Column 2: Rewrite rule to generate a Store-ID
+Eg:
+^http:\/\/[^\.]+\.dl\.sourceforge\.net\/(.*)	http://dl.sourceforge.net.squid.internal/$1
+
+Rewrite rules are matched in the same order as they appear in the rules file.
+So for best performance, sort it in order of frequency of occurrence.
+
+For more information please see http://wiki.squid-cache.org/Features/StoreID
+
+=cut
+
+my @rules; # array of [regex, replacement string]
+
+die "Usage: $0 <rewrite-file>\n" unless $#ARGV == 0;
+
+# read config file
+open RULES, $ARGV[0] or die "Error opening $ARGV[0]: $!";
+while (<RULES>) {
+	chomp;
+	next if /^\s*#?$/;
+	if (/^\s*([^\t]+?)\s*\t+\s*([^\t]+?)\s*$/) {
+		push(@rules, [qr/$1/, $2]);
+	} else {
+		print STDERR "$0: Parse error in $ARGV[0] (line $.)\n";
+	}
+}
+close RULES;
+
+# read urls from squid and do the replacement
+URL: while (<STDIN>) {
+	chomp;
+	last if $_ eq 'quit';
+	
+	foreach my $rule (@rules) {
+		if (my @match = /$rule->[0]/) {
+			$_ = $rule->[1];
+			
+			for (my $i=1; $i<=scalar(@match); $i++) {
+				s/\$$i/$match[$i-1]/g;
+			}
+			print "OK store-id=$_\n";
+			next URL;
+		}
+	}
+	print "ERR\n";
+}
+
+=pod
+
+=head1 COPYRIGHT
+
+Copyright (C) 2013 Alan Mizrahi <alan@mizrahi.com.ve>
+Based on code from Eliezer Croitoru <eliezer@ngtech.co.il>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+
+=cut
@@ -0,0 +1,40 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_storeid_rewrite_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_storeid_rewrite_helpers:=yes}" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/storeid_rewrite],[enable_storeid_rewrite_helpers])
+fi
+
+enable_storeid_rewrite_helpers="`echo $enable_storeid_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+AC_MSG_NOTICE([Store-ID rewrite helper candidates: $enable_storeid_rewrite_helpers])
+STOREID_REWRITE_HELPERS=""
+if test "x$enable_storeid_rewrite_helpers" != "xno" ; then
+  for helper in $enable_storeid_rewrite_helpers; do
+    dir="$srcdir/helpers/storeid_rewrite/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfile" ; then
+      m4_include([helpers/storeid_rewrite/file/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/storeid_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([Store-ID rewrite helper $helper ... found but cannot be built])
+      else
+        STOREID_REWRITE_HELPERS="$STOREID_REWRITE_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([Store-ID rewrite helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([Store-ID rewrite helpers to be built: $STOREID_REWRITE_HELPERS])
+AC_SUBST(STOREID_REWRITE_HELPERS)
@@ -39,8 +39,6 @@ class CbDataList
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
     CbDataList (C const &);
     ~CbDataList();
 
@@ -57,7 +55,7 @@ class CbDataList
     bool empty() const { return this == NULL; }
 
 private:
-    CBDATA_CLASS(CbDataList);
+    CBDATA_CLASS2(CbDataList);
 };
 
 /// \ingroup POD
@@ -102,24 +100,6 @@ template <class C>
 cbdata_type CbDataList<C>::CBDATA_CbDataList = CBDATA_UNKNOWN;
 /** \endcond */
 
-template <class C>
-void *
-CbDataList<C>::operator new (size_t byteCount)
-{
-    CBDATA_INIT_TYPE(CbDataList);
-
-    CbDataList<C> *result = cbdataAlloc(CbDataList);
-
-    return result;
-}
-
-template <class C>
-void
-CbDataList<C>::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
 template <class C>
 CbDataList<C>::CbDataList(C const &value) : next(NULL), element (value)
 {}
@@ -1,5 +1,17 @@
-## Process this file with automake to produce Makefile.in
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
 
-AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5
-DIST_SUBDIRS = include src test
-SUBDIRS = src test
+DIST_SUBDIRS = test
+SUBDIRS = test
+
+noinst_LIBRARIES = libTrie.a
+
+noinst_HEADERS = Trie.h TrieNode.h TrieCharTransform.h
+
+libTrie_a_SOURCES = Trie.cc \
+	Trie.cci \
+	Trie.h \
+	TrieNode.cc \
+	TrieNode.cci \
+	TrieNode.h \
+	TrieCharTransform.h
@@ -17,7 +17,7 @@
  *
  */
 
-#include "config.h"
+#include "squid.h"
 #include "Trie.h"
 #if HAVE_UNISTD_H
 #include <unistd.h>
@@ -17,7 +17,7 @@
  *
  */
 
-#include "config.h"
+#include "squid.h"
 #include "TrieNode.h"
 #include "TrieCharTransform.h"
 #if HAVE_UNISTD_H
@@ -1 +0,0 @@
-dnl
@@ -1,114 +0,0 @@
-# Process this file with autoconf to produce a configure script.
-AC_INIT(libTrie, 0.1, rbtcollins@squid-cache.org)
-AC_CONFIG_SRCDIR([src/Trie.cc])
-AC_CONFIG_HEADERS([config.h])
-AC_CONFIG_AUX_DIR(cfgaux)
-
-enable_inline=${enable_inline:=yes}
-AC_ARG_ENABLE(optimizations,
-  AC_HELP_STRING([--disable-optimizations],
-                 [Do not compile Squid with compiler optimizations enabled.
-                  Optimization is good for production builds, but not
-                  good for debugging. During development, use
-                  --disable-optimizations to reduce compilation times
-                  and allow easier debugging. This option implicitly
-                  also enabled --disable-inline]), [
-  if test "x$enableval" = "xno" ; then
-        AC_MSG_NOTICE([Disabling compiler optimizations (-O flag)])
-        CFLAGS="`echo $CFLAGS | sed -e 's/-O[[0-9]]*//'`"
-        CXXFLAGS="`echo $CXXFLAGS | sed -e 's/-O[[0-9]]*//'`"
-        enable_inline="no"
-  fi
-])
-
-AC_ARG_ENABLE(inline,
-  AC_HELP_STRING([--disable-inline],
-                 [Do not compile trivial methods as inline. Squid
-                  is coded with much of the code able to be inlined.
-                  Inlining is good for production builds, but not
-                  good for development. During development, use
-                  --disable-inline to reduce compilation times and
-                  allow incremental builds to be quick. For
-                  production builds, or load tests, use
-                  --enable-inline to have squid make all trivial
-                  methods inlinable by the compiler.]), [
-  if test "x${enableval}" = "xno" ; then
-    enable_inline=no
-  fi
-])
-if test "x$enable_inline" = "xyes" ; then
-    AC_DEFINE(_SQUID_INLINE_, inline, 
-      [Keyword used by squid for inlining methods])
-    AC_DEFINE(_USE_INLINE_, 1, [Include inline methods into header file])
-else
-    AC_MSG_NOTICE([Inlining optimization disabled])
-    AC_DEFINE(_SQUID_INLINE_, [] , [Keyword used by squid for inlining methods])
-    AC_DEFINE(_USE_INLINE_, 0, [Include inline methods into header file])
-fi
-
-# Checks for programs.
-AC_PROG_CXX
-AC_PROG_CC
-AC_LANG_CPLUSPLUS
-AC_PROG_MAKE_SET
-# for old automakes - like squid-cache.orgs!
-AM_INIT_AUTOMAKE(libTrie, 0.1)
-AM_MAINTAINER_MODE
-AC_PROG_RANLIB
-
-AC_LIBTOOL_DLOPEN
-AC_LIBLTDL_CONVENIENCE
-AC_PROG_LIBTOOL
-AC_LTDL_DLLIB
-AC_SUBST(INCLTDL)
-AC_SUBST(LIBLTDL)
-
-dnl set useful flags
-TRIE_CFLAGS=
-TRIE_CXXFLAGS=
-if test "$GCC" = "yes"; then
-  TRIE_CFLAGS="-Wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments"
-  TRIE_CXXFLAGS="-Wall -Wpointer-arith -Wwrite-strings -Wcomments"
-
-  AC_ARG_ENABLE(strict-error-checking,
-    AS_HELP_STRING([--disable-strict-error-checking],[By default compile
-                   with all possible static compiler error-checks enabled.
-                   This flag disables the behavior]), [
-    case $enableval in
-      yes|1|true)
-	enable_strict_error_checking=yes
-	;;
-      *)
-	enable_strict_error_checking=no
-	;;
-    esac
-  ])
-  AC_MSG_NOTICE([strict error checking enabled: ${enable_strict_error_checking:=yes}])
-  if test "x${enable_strict_error_checking:=yes}" = "xyes"; then
-     TRIE_CFLAGS="-Werror $TRIE_CFLAGS"
-     TRIE_CXXFLAGS="-Werror $TRIE_CXXFLAGS"
-  fi
-
-fi
-
-AC_SUBST(TRIE_CFLAGS)
-AC_SUBST(TRIE_CXXFLAGS)
-
-# Checks for libraries.
-
-# Checks for header files.
-AC_CHECK_HEADERS( \
-	iostream \
-)
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_TYPE_SIZE_T
-
-# Checks for library functions.
-
-AC_CONFIG_FILES([Makefile
-                 include/Makefile
-                 src/Makefile
-                 test/Makefile])
-AC_OUTPUT
@@ -1 +0,0 @@
-noinst_HEADERS = Trie.h TrieNode.h TrieCharTransform.h
@@ -1,13 +0,0 @@
-
-INCLUDES = -I$(top_srcdir)/include
-
-AM_CFLAGS = $(TRIE_CFLAGS)
-AM_CXXFLAGS = $(TRIE_CXXFLAGS)
-
-noinst_LIBRARIES = libTrie.a
-
-libTrie_a_SOURCES = Trie.cc \
-	TrieNode.cc
-
-noinst_HEADERS = ../include/Trie.cci \
-	../include/TrieNode.cci
@@ -1,16 +1,15 @@
-INCLUDES = -I$(top_srcdir)/include
+include $(top_srcdir)/src/Common.am
 
-AM_CFLAGS = $(TRIE_CFLAGS)
-AM_CXXFLAGS = $(TRIE_CXXFLAGS)
+INCLUDES += -I$(top_srcdir)/include
 
 # TESTS = trie trie-c
-TESTS = trie
+TESTS += trie
 
 # check_PROGRAMS = trie trie-c
-check_PROGRAMS = trie
+check_PROGRAMS += trie
 
 trie_SOURCES = trie.cc
-trie_LDADD = $(top_builddir)/src/libTrie.a
+trie_LDADD = $(top_builddir)/lib/libTrie/libTrie.a
 
 #trie_c_SOURCES = trie-c.c
-#trie_c_LDADD = $(top_builddir)/src/libTrie.a -lm
+#trie_c_LDADD = $(top_builddir)/lib/libTrie/libTrie.a -lm
@@ -17,9 +17,9 @@
  *
  */
 
-#include "config.h"
-#include "Trie.h"
-#include "TrieCharTransform.h"
+#include "squid.h"
+#include "libTrie/Trie.h"
+#include "libTrie/TrieCharTransform.h"
 
 #if HAVE_IOSTREAM
 #include <iostream>
@@ -120,7 +120,7 @@ for FILENAME in `ls -1`; do
 
     esac
 
-    if test "$FILENAME" = "libltdl" -o "$FILENAME" = "libTrie" ; then
+    if test "$FILENAME" = "libltdl" ; then
         :
     elif test -d $FILENAME ; then
 	cd $FILENAME
@@ -20,9 +20,6 @@ class ClientRequestContext : public RefCountable
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ClientRequestContext(ClientHttpRequest *);
     ~ClientRequestContext();
 
@@ -87,7 +84,7 @@ class ClientRequestContext : public RefCountable
     bool readNextRequest; ///< whether Squid should read after error handling
 
 private:
-    CBDATA_CLASS(ClientRequestContext);
+    CBDATA_CLASS2(ClientRequestContext);
 };
 
 #endif /* SQUID_CLIENTREQUESTCONTEXT_H */
@@ -40,10 +40,19 @@ CommCommonCbParams::print(std::ostream &os) const
 /* CommAcceptCbParams */
 
 CommAcceptCbParams::CommAcceptCbParams(void *aData):
-        CommCommonCbParams(aData)
+        CommCommonCbParams(aData), xaction()
 {
 }
 
+void
+CommAcceptCbParams::print(std::ostream &os) const
+{
+    CommCommonCbParams::print(os);
+
+    if (xaction != NULL)
+        os << ", " << xaction->id;
+}
+
 /* CommConnectCbParams */
 
 CommConnectCbParams::CommConnectCbParams(void *aData):
@@ -5,6 +5,7 @@
 #include "base/AsyncJobCalls.h"
 #include "comm_err_t.h"
 #include "comm/forward.h"
+#include "MasterXaction.h"
 
 /* CommCalls implement AsyncCall interface for comm_* callbacks.
  * The classes cover two call dialer kinds:
@@ -89,6 +90,11 @@ class CommAcceptCbParams: public CommCommonCbParams
 {
 public:
     CommAcceptCbParams(void *aData);
+
+    void print(std::ostream &os) const;
+
+    /// Transaction which this call is part of.
+    MasterXaction::Pointer xaction;
 };
 
 // connect parameters
@@ -38,68 +38,98 @@
 #include "fatal.h"
 #include "globals.h"
 
-char *ConfigParser::lastToken = NULL;
-std::queue<std::string> ConfigParser::undo;
+int ConfigParser::RecognizeQuotedValues = true;
+std::stack<ConfigParser::CfgFile *> ConfigParser::CfgFiles;
+ConfigParser::TokenType ConfigParser::LastTokenType = ConfigParser::SimpleToken;
+char *ConfigParser::LastToken = NULL;
+char *ConfigParser::CfgLine = NULL;
+char *ConfigParser::CfgPos = NULL;
+std::queue<std::string> ConfigParser::Undo_;
+bool ConfigParser::AllowMacros_ = false;
 
 void
 ConfigParser::destruct()
 {
     shutting_down = 1;
-    fatalf("Bungled %s line %d: %s",
-           cfg_filename, config_lineno, config_input_line);
+    if (!CfgFiles.empty()) {
+        std::ostringstream message;
+        CfgFile *f = CfgFiles.top();
+        message << "Bungled " << f->filePath << " line " << f->lineNo <<
+        ": " << f->currentLine << std::endl;
+        CfgFiles.pop();
+        delete f;
+        while (!CfgFiles.empty()) {
+            f = CfgFiles.top();
+            message << " included from " << f->filePath << " line " <<
+            f->lineNo << ": " << f->currentLine << std::endl;
+            CfgFiles.pop();
+            delete f;
+        }
+        message << " included from " <<  cfg_filename << " line " <<
+        config_lineno << ": " << config_input_line << std::endl;
+        std::string msg = message.str();
+        fatalf("%s", msg.c_str());
+    } else
+        fatalf("Bungled %s line %d: %s",
+               cfg_filename, config_lineno, config_input_line);
 }
 
 void
-ConfigParser::strtokFileUndo()
+ConfigParser::TokenUndo()
 {
-    assert(lastToken);
-    undo.push(lastToken);
+    assert(LastToken);
+    Undo_.push(LastToken);
 }
 
 void
-ConfigParser::strtokFilePutBack(const char *tok)
+ConfigParser::TokenPutBack(const char *tok)
 {
     assert(tok);
-    undo.push(tok);
+    Undo_.push(tok);
 }
 
 char *
-ConfigParser::strtokFile(void)
+ConfigParser::Undo()
 {
+    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
+    if (!Undo_.empty()) {
+        strncpy(undoToken, Undo_.front().c_str(), sizeof(undoToken));
+        undoToken[sizeof(undoToken) - 1] = '\0';
+        Undo_.pop();
+        return undoToken;
+    }
+    return NULL;
+}
+
+char *
+ConfigParser::strtokFile()
+{
+    if (RecognizeQuotedValues)
+        return ConfigParser::NextToken();
+
     static int fromFile = 0;
     static FILE *wordFile = NULL;
-    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
 
-    char *t, *fn;
+    char *t;
     LOCAL_ARRAY(char, buf, CONFIG_LINE_LIMIT);
 
-    if (!undo.empty()) {
-        strncpy(undoToken, undo.front().c_str(), sizeof(undoToken));
-        undoToken[sizeof(undoToken) - 1] = '\0';
-        undo.pop();
-        return undoToken;
-    }
+    if ((LastToken = ConfigParser::Undo()))
+        return LastToken;
 
-    lastToken = NULL;
     do {
 
         if (!fromFile) {
-            t = (strtok(NULL, w_space));
-
-            if (!t || *t == '#') {
+            ConfigParser::TokenType tokenType;
+            t = ConfigParser::NextElement(tokenType, true);
+            if (!t) {
                 return NULL;
-            } else if (*t == '\"' || *t == '\'') {
+            } else if (tokenType == ConfigParser::QuotedToken) {
                 /* quote found, start reading from file */
-                fn = ++t;
-
-                while (*t && *t != '\"' && *t != '\'')
-                    ++t;
+                debugs(3, 8,"Quoted token found : " << t);
 
-                *t = '\0';
-
-                if ((wordFile = fopen(fn, "r")) == NULL) {
-                    debugs(28, DBG_CRITICAL, "strtokFile: " << fn << " not found");
-                    return (NULL);
+                if ((wordFile = fopen(t, "r")) == NULL) {
+                    debugs(3, DBG_CRITICAL, "Can not open file " << t << " for reading");
+                    return NULL;
                 }
 
 #if _SQUID_WINDOWS_
@@ -108,7 +138,7 @@ ConfigParser::strtokFile(void)
 
                 fromFile = 1;
             } else {
-                return lastToken = t;
+                return LastToken = t;
             }
         }
 
@@ -139,52 +169,182 @@ ConfigParser::strtokFile(void)
         /* skip blank lines */
     } while ( *t == '#' || !*t );
 
-    return lastToken = t;
-}
-
-void
-ConfigParser::ParseQuotedString(char **var, bool *wasQuoted)
-{
-    String sVar;
-    ParseQuotedString(&sVar, wasQuoted);
-    *var = xstrdup(sVar.termedBuf());
+    return LastToken = t;
 }
 
-void
-ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
+char *
+ConfigParser::UnQuote(char *token, char **end)
 {
-    // Get all of the remaining string
-    char *token = strtok(NULL, "");
-    if (token == NULL)
-        self_destruct();
-
-    if (*token != '"') {
-        token = strtok(token, w_space);
-        var->reset(token);
-        if (wasQuoted)
-            *wasQuoted = false;
-        return;
-    } else if (wasQuoted)
-        *wasQuoted = true;
-
+    char quoteChar = *token;
+    assert(quoteChar == '"' || quoteChar == '\'');
     char  *s = token + 1;
     /* scan until the end of the quoted string, unescaping " and \  */
-    while (*s && *s != '"') {
-        if (*s == '\\') {
+    while (*s && *s != quoteChar) {
+        if (*s == '\\' && isalnum(*( s + 1))) {
+            debugs(3, DBG_CRITICAL, "Unsupported escape sequence: " << s);
+            self_destruct();
+        } else if (*s == '$' && quoteChar == '"') {
+            debugs(3, DBG_CRITICAL, "Unsupported cfg macro: " << s);
+            self_destruct();
+        } else if (*s == '%' && quoteChar == '"' && (!AllowMacros_ )) {
+            debugs(3, DBG_CRITICAL, "Macros are not supported here: " << s);
+            self_destruct();
+        } else if (*s == '\\') {
             const char * next = s+1; // may point to 0
             memmove(s, next, strlen(next) + 1);
         }
         ++s;
     }
 
-    if (*s != '"') {
-        debugs(3, DBG_CRITICAL, "ParseQuotedString: missing '\"' at the end of quoted string" );
+    if (*s != quoteChar) {
+        debugs(3, DBG_CRITICAL, "missing '" << quoteChar << "' at the end of quoted string: " << (s-1));
         self_destruct();
     }
-    strtok(s-1, "\""); /*Reset the strtok to point after the "  */
-    *s = '\0';
+    *end = s;
+    return (token+1);
+}
+
+void
+ConfigParser::SetCfgLine(char *line)
+{
+    CfgLine = line;
+    CfgPos = line;
+}
+
+char *
+ConfigParser::TokenParse(char * &nextToken, ConfigParser::TokenType &type, bool legacy)
+{
+    if (!nextToken || *nextToken == '\0')
+        return NULL;
+    type = ConfigParser::SimpleToken;
+    nextToken += strspn(nextToken, w_space);
+    if (*nextToken == '"' || *nextToken == '\'') {
+        type = ConfigParser::QuotedToken;
+        char *token = UnQuote(nextToken, &nextToken);
+        *nextToken = '\0';
+        ++nextToken;
+        return token;
+    }
+
+    char *token = nextToken;
+    if (char *t = strchr(nextToken, '#'))
+        *t = '\0';
+    const char *sep;
+    if (legacy)
+        sep = w_space;
+    else
+        sep = w_space "(";
+    nextToken += strcspn(nextToken, sep);
+
+    if (!legacy && *nextToken == '(')
+        type = ConfigParser::FunctionNameToken;
+    else
+        type = ConfigParser::SimpleToken;
+
+    if (*nextToken != '\0') {
+        *nextToken = '\0';
+        ++nextToken;
+    }
+
+    if (*token == '\0')
+        return NULL;
+
+    return token;
+}
+
+char *
+ConfigParser::NextElement(ConfigParser::TokenType &type, bool legacy)
+{
+    char *token = TokenParse(CfgPos, type, legacy);
+    return token;
+}
+
+char *
+ConfigParser::NextToken()
+{
+    if ((LastToken = ConfigParser::Undo()))
+        return LastToken;
+
+    char *token = NULL;
+    do {
+        while (token == NULL && !CfgFiles.empty()) {
+            ConfigParser::CfgFile *wordfile = CfgFiles.top();
+            token = wordfile->parse(LastTokenType);
+            if (!token) {
+                assert(!wordfile->isOpen());
+                CfgFiles.pop();
+                delete wordfile;
+            }
+        }
+
+        if (!token)
+            token = NextElement(LastTokenType);
 
-    var->reset(token+1);
+        if (token &&  LastTokenType == ConfigParser::FunctionNameToken && strcmp("parameters", token) == 0) {
+            char *path = NextToken();
+            if (LastTokenType != ConfigParser::QuotedToken) {
+                debugs(3, DBG_CRITICAL, "Quoted filename missing: " << token);
+                self_destruct();
+                return NULL;
+            }
+
+            // The next token in current cfg file line must be a ")"
+            char *end = NextToken();
+            if (LastTokenType != ConfigParser::SimpleToken || strcmp(end, ")") != 0) {
+                debugs(3, DBG_CRITICAL, "missing ')' after " << token << "(\"" << path << "\"");
+                self_destruct();
+                return NULL;
+            }
+
+            if (CfgFiles.size() > 16) {
+                debugs(3, DBG_CRITICAL, "WARNING: can't open %s for reading parameters: includes are nested too deeply (>16)!\n" << path);
+                self_destruct();
+                return NULL;
+            }
+
+            ConfigParser::CfgFile *wordfile = new ConfigParser::CfgFile();
+            if (!path || !wordfile->startParse(path)) {
+                debugs(3, DBG_CRITICAL, "Error opening config file: " << token);
+                delete wordfile;
+                self_destruct();
+                return NULL;
+            }
+            CfgFiles.push(wordfile);
+            token = NULL;
+        } else if (token &&  LastTokenType == ConfigParser::FunctionNameToken) {
+            debugs(3, DBG_CRITICAL, "Unknown cfg function: " << token);
+            self_destruct();
+            return NULL;
+        }
+    } while (token == NULL && !CfgFiles.empty());
+
+    return (LastToken = token);
+}
+
+char *
+ConfigParser::NextQuotedOrToEol()
+{
+    char *token;
+
+    if ((token = CfgPos) == NULL) {
+        debugs(3, DBG_CRITICAL, "token is missing");
+        self_destruct();
+        return NULL;
+    }
+    token += strspn(token, w_space);
+
+    if (*token == '\"' || *token == '\'') {
+        //TODO: eat the spaces at the end and check if it is untill the end of file.
+        char *end;
+        token = UnQuote(token, &end);
+        *end = '\0';
+        CfgPos = end + 1;
+        LastTokenType = ConfigParser::QuotedToken;
+    } else
+        LastTokenType = ConfigParser::SimpleToken;
+
+    CfgPos = NULL;
+    return (LastToken = token);
 }
 
 const char *
@@ -210,3 +370,66 @@ ConfigParser::QuoteString(const String &var)
     quotedStr.append('"');
     return quotedStr.termedBuf();
 }
+
+bool
+ConfigParser::CfgFile::startParse(char *path)
+{
+    assert(wordFile == NULL);
+    if ((wordFile = fopen(path, "r")) == NULL) {
+        debugs(3, DBG_CRITICAL, "file :" << path << " not found");
+        return false;
+    }
+
+#if _SQUID_WINDOWS_
+    setmode(fileno(wordFile), O_TEXT);
+#endif
+
+    filePath = path;
+    return getFileLine();
+}
+
+bool
+ConfigParser::CfgFile::getFileLine()
+{
+    // Else get the next line
+    if (fgets(parseBuffer, CONFIG_LINE_LIMIT, wordFile) == NULL) {
+        /* stop reading from file */
+        fclose(wordFile);
+        wordFile = NULL;
+        parseBuffer[0] = '\0';
+        return false;
+    }
+    parsePos = parseBuffer;
+    currentLine = parseBuffer;
+    lineNo++;
+    return true;
+}
+
+char *
+ConfigParser::CfgFile::parse(ConfigParser::TokenType &type)
+{
+    if (!wordFile)
+        return NULL;
+
+    if (!*parseBuffer)
+        return NULL;
+
+    char *token;
+    while (!(token = nextElement(type))) {
+        if (!getFileLine())
+            return NULL;
+    }
+    return token;
+}
+
+char *
+ConfigParser::CfgFile::nextElement(ConfigParser::TokenType &type)
+{
+    return TokenParse(parsePos, type);
+}
+
+ConfigParser::CfgFile::~CfgFile()
+{
+    if (wordFile)
+        fclose(wordFile);
+}
@@ -36,6 +36,7 @@
 
 #include "SquidString.h"
 #include <queue>
+#include <stack>
 #if HAVE_STRING
 #include <string>
 #endif
@@ -65,26 +66,143 @@ class ConfigParser
 {
 
 public:
+    /**
+     * Parsed tokens type: simple tokens, quoted tokens or function
+     * like parameters.
+     */
+    enum TokenType {SimpleToken, QuotedToken, FunctionNameToken};
+
     void destruct();
     static void ParseUShort(unsigned short *var);
     static void ParseBool(bool *var);
-    static void ParseString(char **var);
-    static void ParseString(String *var);
-    /// Parse an unquoted token (no spaces) or a "quoted string" that
-    /// may include spaces. In some contexts, quotes strings may also
-    /// include macros. Quoted strings may escape any character with
-    /// a backslash (\), which is currently only useful for inner
-    /// quotes. TODO: support quoted strings anywhere a token is accepted.
-    static void ParseQuotedString(char **var, bool *wasQuoted = NULL);
-    static void ParseQuotedString(String *var, bool *wasQuoted = NULL);
     static const char *QuoteString(const String &var);
     static void ParseWordList(wordlist **list);
+
+    /**
+     * Backward compatibility wrapper for the ConfigParser::NextToken method.
+     * If the configuration_includes_quoted_values configuration parameter is
+     * set to 'off' this interprets the quoted tokens as filenames.
+     */
     static char * strtokFile();
-    static void strtokFileUndo();
-    static void strtokFilePutBack(const char *);
-private:
-    static char *lastToken;
-    static std::queue<std::string> undo;
+
+    /**
+     * Returns the body of the next element. The element is either a token or
+     * a quoted string with optional escape sequences and/or macros. The body
+     * of a quoted string element does not include quotes or escape sequences.
+     * Future code will want to see Elements and not just their bodies.
+     */
+    static char *NextToken();
+
+    /// \return true if the last parsed token was quoted
+    static bool LastTokenWasQuoted() {return (LastTokenType == ConfigParser::QuotedToken);}
+
+    /**
+     * \return the next quoted string or the raw string data until the end of line.
+     * This method allows %macros in unquoted strings to keep compatibility
+     * for the logformat option.
+     */
+    static char *NextQuotedOrToEol();
+
+    /**
+     * Undo last NextToken call. The next call to NextToken() method will return
+     * again the last parsed element.
+     * Can not be called repeatedly to undo multiple NextToken calls. In this case
+     * the behaviour is undefined.
+     */
+    static void TokenUndo();
+
+    /**
+     * The next NextToken call will return the token as next element
+     * It can be used repeatedly to add more than one tokens in a FIFO list.
+     */
+    static void TokenPutBack(const char *token);
+
+    /// Set the configuration file line to parse.
+    static void SetCfgLine(char *line);
+
+    /// Allow %macros inside quoted strings
+    static void EnableMacros() {AllowMacros_ = true;}
+
+    /// Do not allow %macros inside quoted strings
+    static void DisableMacros() {AllowMacros_ = false;}
+
+    /// configuration_includes_quoted_values in squid.conf
+    static int RecognizeQuotedValues;
+
+protected:
+    /**
+     * Class used to store required information for the current
+     * configuration file.
+     */
+    class CfgFile
+    {
+    public:
+        CfgFile(): wordFile(NULL), parsePos(NULL), lineNo(0) { parseBuffer[0] = '\0';}
+        ~CfgFile();
+        /// True if the configuration file is open
+        bool isOpen() {return wordFile != NULL;}
+
+        /**
+         * Open the file given by 'path' and initializes the CfgFile object
+         * to start parsing
+         */
+        bool startParse(char *path);
+
+        /**
+         * Do the next parsing step:
+         * reads the next line from file if required.
+         * \return the body of next element or a NULL pointer if there are no more token elements in the file.
+         * \param type will be filled with the ConfigParse::TokenType for any element found, or left unchanged if NULL is returned.
+         */
+        char *parse(TokenType &type);
+
+    private:
+        bool getFileLine();   ///< Read the next line from the file
+        /**
+         * Return the body of the next element. If the wasQuoted is given
+         * set to true if the element was quoted.
+         */
+        char *nextElement(TokenType &type);
+        FILE *wordFile; ///< Pointer to the file.
+        char parseBuffer[CONFIG_LINE_LIMIT]; ///< Temporary buffer to store data to parse
+        char *parsePos; ///< The next element position in parseBuffer string
+    public:
+        std::string filePath; ///< The file path
+        std::string currentLine; ///< The current line to parse
+        int lineNo; ///< Current line number
+    };
+
+    /**
+     * Return the last TokenUndo() or TokenPutBack() queued element, or NULL
+     * if none exist
+     */
+    static char *Undo();
+
+    /**
+     * Unquotes the token, which must be quoted.
+     * \param end if it is not NULL, it is set to the end of token.
+     */
+    static char *UnQuote(char *token, char **end = NULL);
+
+    /**
+     * Does the real tokens parsing job: Ignore comments, unquote an
+     * element if required.
+     * \return the next token, or NULL if there are no available tokens in the nextToken string.
+     * \param nextToken updated to point to the pos after parsed token.
+     * \param type      The token type
+     * \param legacy    If it is true function-like parameters are not allowed
+     */
+    static char *TokenParse(char * &nextToken, TokenType &type, bool legacy = false);
+
+    /// Wrapper method for TokenParse.
+    static char *NextElement(TokenType &type, bool legacy = false);
+    static std::stack<CfgFile *> CfgFiles; ///< The stack of open cfg files
+    static TokenType LastTokenType; ///< The type of last parsed element
+    static char *LastToken; ///< Points to the last parsed token
+    static char *CfgLine; ///< The current line to parse
+    static char *CfgPos; ///< Pointer to the next element in cfgLine string
+    static std::queue<std::string> Undo_; ///< The list with TokenUndo() or TokenPutBack() queued elements
+    static bool AllowMacros_;
 };
 
 int parseConfigFile(const char *file_name);
@@ -58,18 +58,6 @@
 #endif
 
 CBDATA_CLASS_INIT(AIODiskFile);
-void *
-AIODiskFile::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(AIODiskFile);
-    return cbdataAlloc(AIODiskFile);
-}
-
-void
-AIODiskFile::operator delete(void *address)
-{
-    cbdataFree(address);
-}
 
 AIODiskFile::AIODiskFile(char const *aPath, AIODiskIOStrategy *aStrategy) : fd(-1), closed(true), error_(false)
 {
@@ -46,8 +46,6 @@ class AIODiskFile : public DiskFile
 public:
 
     friend class AIODiskIOStrategy;
-    void * operator new (size_t);
-    void operator delete (void *);
     AIODiskFile (char const *path, AIODiskIOStrategy *);
     ~AIODiskFile();
 
@@ -77,7 +75,7 @@ class AIODiskFile : public DiskFile
     RefCount<IORequestor> ioRequestor;
     bool closed;
     bool error_;
-    CBDATA_CLASS(AIODiskFile);
+    CBDATA_CLASS2(AIODiskFile);
 };
 
 #endif /* USE_DISKIO_AIO */
@@ -43,24 +43,8 @@
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
-CBDATA_CLASS_INIT(BlockingFile);
-
-void *
-BlockingFile::operator new(size_t sz)
-{
-    CBDATA_INIT_TYPE(BlockingFile);
-    BlockingFile *result = cbdataAlloc(BlockingFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    return result;
-}
 
-void
-BlockingFile::operator delete(void *address)
-{
-    BlockingFile *t = static_cast<BlockingFile *>(address);
-    cbdataFree(t);
-}
+CBDATA_CLASS_INIT(BlockingFile);
 
 BlockingFile::BlockingFile(char const *aPath) : fd (-1), closed (true), error_(false)
 {
@@ -42,8 +42,6 @@ class BlockingFile : public DiskFile
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
     BlockingFile(char const *path);
     ~BlockingFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
@@ -72,7 +70,7 @@ class BlockingFile : public DiskFile
     void readDone(int fd, const char *buf, int len, int errflag);
     void writeDone(int fd, int errflag, size_t len);
 
-    CBDATA_CLASS(BlockingFile);
+    CBDATA_CLASS2(BlockingFile);
 };
 
 #endif /* SQUID_BLOCKINGFILE_H */
@@ -53,25 +53,6 @@
 
 CBDATA_CLASS_INIT(DiskdFile);
 
-void *
-DiskdFile::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(DiskdFile);
-    DiskdFile *result = cbdataAlloc(DiskdFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    debugs(79, 3, "diskdFile with base " << result << " allocating");
-    return result;
-}
-
-void
-DiskdFile::operator delete(void *address)
-{
-    DiskdFile *t = static_cast<DiskdFile *>(address);
-    debugs(79, 3, "diskdFile with base " << t << " deleting");
-    cbdataFree(t);
-}
-
 DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) :
         errorOccured(false),
         IO(anIO),
@@ -48,8 +48,6 @@ class DiskdFile : public DiskFile
 {
 
 public:
-    void * operator new(size_t);
-    void operator delete(void *);
     DiskdFile(char const *path, DiskdIOStrategy *);
     ~DiskdFile();
     virtual void open(int flags, mode_t aMode, RefCount<IORequestor> callback);
@@ -84,7 +82,7 @@ class DiskdFile : public DiskFile
     void ioCompleted();
     size_t inProgressIOs;
 
-    CBDATA_CLASS(DiskdFile);
+    CBDATA_CLASS2(DiskdFile);
 };
 
 #endif
@@ -50,26 +50,6 @@
 /* === PUBLIC =========================================================== */
 
 CBDATA_CLASS_INIT(DiskThreadsDiskFile);
-void *
-DiskThreadsDiskFile::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(DiskThreadsDiskFile);
-    DiskThreadsDiskFile *result = cbdataAlloc(DiskThreadsDiskFile);
-    /*
-     * We used to call squidaio_init() here, but if the first transaction
-     * is to unlink a file (e.g., if Squid starts up over the disk space
-     * limit) then "squidaio" won't be initialized yet.
-     */
-
-    return result;
-}
-
-void
-DiskThreadsDiskFile::operator delete(void *address)
-{
-    DiskThreadsDiskFile *t = static_cast<DiskThreadsDiskFile *>(address);
-    cbdataFree(t);
-}
 
 DiskThreadsDiskFile::DiskThreadsDiskFile(char const *aPath, DiskThreadsIOStrategy *anIO):fd(-1), errorOccured (false), IO(anIO),
         inProgressIOs (0)
@@ -374,19 +354,3 @@ DiskThreadsDiskFile::writeDone(int rvfd, int errflag, size_t len, RefCount<Write
 template <class RT>
 cbdata_type IoResult<RT>::CBDATA_IoResult = CBDATA_UNKNOWN;
 /** \endcond */
-
-template<class RT>
-void *
-IoResult<RT>::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(IoResult);
-    IoResult<RT> *result = cbdataAlloc(IoResult);
-    return result;
-}
-
-template <class RT>
-void
-IoResult<RT>::operator delete(void *address)
-{
-    cbdataFree(address);
-}
@@ -41,8 +41,6 @@ class DiskThreadsDiskFile : public DiskFile
 {
 
 public:
-    void * operator new(size_t);
-    void operator delete(void *);
     DiskThreadsDiskFile(char const *path, DiskThreadsIOStrategy *);
     ~DiskThreadsDiskFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
@@ -86,7 +84,7 @@ class DiskThreadsDiskFile : public DiskFile
     void readDone(int fd, const char *buf, int len, int errflag, RefCount<ReadRequest> request);
     void writeDone(int fd, int errflag, size_t len, RefCount<WriteRequest> request);
 
-    CBDATA_CLASS(DiskThreadsDiskFile);
+    CBDATA_CLASS2(DiskThreadsDiskFile);
 };
 
 #include "DiskIO/ReadRequest.h"
@@ -96,15 +94,13 @@ class IoResult
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     IoResult(RefCount<DiskThreadsDiskFile> aFile, RefCount<RT> aRequest) : file(aFile), request(aRequest) {}
 
     RefCount<DiskThreadsDiskFile> file;
     RefCount<RT> request;
 
 private:
-    CBDATA_CLASS(IoResult);
+    CBDATA_CLASS2(IoResult);
 };
 
 template <class RT>
@@ -49,23 +49,6 @@ class Mmapping
     void *buf; ///< buffer returned by mmap, needed for munmap
 };
 
-void *
-MmappedFile::operator new(size_t sz)
-{
-    CBDATA_INIT_TYPE(MmappedFile);
-    MmappedFile *result = cbdataAlloc(MmappedFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    return result;
-}
-
-void
-MmappedFile::operator delete(void *address)
-{
-    MmappedFile *t = static_cast<MmappedFile *>(address);
-    cbdataFree(t);
-}
-
 MmappedFile::MmappedFile(char const *aPath): fd(-1),
         minOffset(0), maxOffset(-1), error_(false)
 {
@@ -9,8 +9,6 @@ class MmappedFile : public DiskFile
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
     MmappedFile(char const *path);
     ~MmappedFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
@@ -40,7 +38,7 @@ class MmappedFile : public DiskFile
 
     void doClose();
 
-    CBDATA_CLASS(MmappedFile);
+    CBDATA_CLASS2(MmappedFile);
 };
 
 #endif /* SQUID_MMAPPEDFILE_H */
@@ -49,21 +49,6 @@
 
 CBDATA_CLASS_INIT(ExternalACLEntry);
 
-void *
-ExternalACLEntry::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ExternalACLEntry));
-    CBDATA_INIT_TYPE(ExternalACLEntry);
-    return cbdataAlloc(ExternalACLEntry);
-}
-
-void
-ExternalACLEntry::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 ExternalACLEntry::ExternalACLEntry()
 {
     lru.next = lru.prev = NULL;
@@ -81,9 +81,6 @@ class ExternalACLEntry: public hash_link
 {
 
 public:
-    void *operator new (size_t bytesToAllocate);
-    void operator delete (void *address);
-
     ExternalACLEntry();
     ~ExternalACLEntry();
 
@@ -101,7 +98,7 @@ class ExternalACLEntry: public hash_link
     external_acl *def;
 
 private:
-    CBDATA_CLASS(ExternalACLEntry);
+    CBDATA_CLASS2(ExternalACLEntry);
 };
 
 typedef class ExternalACLEntry external_acl_entry;
@@ -1079,7 +1079,7 @@ FwdState::connectStart()
 
     debugs(17, 3, "fwdConnectStart: " << entry->url());
 
-    if (n_tries == 0) // first attempt
+    if (!request->hier.first_conn_start.tv_sec) // first attempt
         request->hier.first_conn_start = current_time;
 
     /* connection timeout */
@@ -1164,13 +1164,13 @@ FwdState::connectStart()
 
         /* Update server side TOS and Netfilter mark on the connection. */
         if (Ip::Qos::TheConfig.isAclTosActive()) {
-            temp->tos = GetTosToServer(request);
-            Ip::Qos::setSockTos(temp, temp->tos);
+            const tos_t tos = GetTosToServer(request);
+            Ip::Qos::setSockTos(temp, tos);
         }
 #if SO_MARK
         if (Ip::Qos::TheConfig.isAclNfmarkActive()) {
-            temp->nfmark = GetNfmarkToServer(request);
-            Ip::Qos::setSockNfmark(temp, temp->nfmark);
+            const nfmark_t nfmark = GetNfmarkToServer(request);
+            Ip::Qos::setSockNfmark(temp, nfmark);
         }
 #endif
 
@@ -1,5 +1,6 @@
 #include "squid.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "HelperChildConfig.h"
 #include "globals.h"
@@ -44,7 +45,7 @@ HelperChildConfig::needNew() const
 void
 HelperChildConfig::parseConfig()
 {
-    char const *token = strtok(NULL, w_space);
+    char const *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
@@ -58,7 +59,7 @@ HelperChildConfig::parseConfig()
     }
 
     /* Parse extension options */
-    for (; (token = strtok(NULL, w_space)) ;) {
+    for (; (token = ConfigParser::NextToken()) ;) {
         if (strncmp(token, "startup=", 8) == 0) {
             n_startup = xatoui(token + 8);
         } else if (strncmp(token, "idle=", 5) == 0) {
@@ -177,6 +177,8 @@ HttpRequest::clean()
 
     extacl_message.clean();
 
+    etag.clean();
+
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
 #endif
@@ -222,19 +224,17 @@ HttpRequest::clone() const
     // XXX: what to do with copy->peer_login?
 
     copy->lastmod = lastmod;
+    copy->etag = etag;
     copy->vary_headers = vary_headers ? xstrdup(vary_headers) : NULL;
     // XXX: what to do with copy->peer_domain?
 
     copy->myportname = myportname;
     copy->tag = tag;
-#if USE_AUTH
-    copy->extacl_user = extacl_user;
-    copy->extacl_passwd = extacl_passwd;
-#endif
     copy->extacl_log = extacl_log;
     copy->extacl_message = extacl_message;
 
-    assert(copy->inheritProperties(this));
+    const bool inheritWorked = copy->inheritProperties(this);
+    assert(inheritWorked);
 
     return copy;
 }
@@ -269,6 +269,8 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     errDetail = aReq->errDetail;
 #if USE_AUTH
     auth_user_request = aReq->auth_user_request;
+    extacl_user = aReq->extacl_user;
+    extacl_passwd = aReq->extacl_passwd;
 #endif
 
     // main property is which connection the request was received on (if any)
@@ -219,6 +219,9 @@ class HttpRequest: public HttpMsg
     String x_forwarded_for_iterator; /* XXX a list of IP addresses */
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
+    /// A strong etag of the cached entry. Used for refreshing that entry.
+    String etag;
+
 public:
     bool multipartRangeRequest() const;
 
@@ -85,7 +85,7 @@ if USE_ESI
 SUBDIRS += esi
 ESI_LOCAL_LIBS = \
 	esi/libesi.la \
-	$(top_builddir)/lib/libTrie/src/libTrie.a
+	$(top_builddir)/lib/libTrie/libTrie.a
 ESI_LIBS = $(ESI_LOCAL_LIBS) \
 	$(XMLLIB) \
 	$(EXPATLIB)
@@ -427,6 +427,8 @@ squid_SOURCES = \
 	LogTags.h \
 	lookup_t.h \
 	main.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
@@ -1257,6 +1259,8 @@ tests_testACLMaxUserIP_SOURCES= \
 	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
@@ -1494,6 +1498,8 @@ tests_testCacheManager_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
@@ -1674,6 +1680,8 @@ tests_testDiskIO_SOURCES = \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
@@ -1910,6 +1918,8 @@ tests_testEvent_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
@@ -2158,6 +2168,8 @@ tests_testEventLoop_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
@@ -2403,6 +2415,8 @@ tests_test_http_range_SOURCES = \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
@@ -2693,6 +2707,8 @@ tests_testHttpRequest_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
@@ -2866,6 +2882,8 @@ tests_testStore_SOURCES= \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
@@ -3091,6 +3109,8 @@ tests_testUfs_SOURCES = \
 	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemObject.cc \
 	StoreSwapLogData.cc \
 	StoreIOState.cc \
@@ -3277,6 +3297,8 @@ tests_testRock_SOURCES = \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
@@ -3661,6 +3683,8 @@ tests_testURL_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	Mem.h \
@@ -0,0 +1,4 @@
+#include "squid.h"
+#include "MasterXaction.h"
+
+InstanceIdDefinitions(MasterXaction, "MXID_");
@@ -0,0 +1,46 @@
+#ifndef SQUID_SRC_MASTERXACTION_H
+#define SQUID_SRC_MASTERXACTION_H
+
+#include "anyp/forward.h"
+#include "base/CbcPointer.h"
+#include "base/InstanceId.h"
+#include "base/Lock.h"
+#include "comm/forward.h"
+
+/** Master transaction details.
+ *
+ * Aggregates historical data from individual related protocol-specific
+ * transactions such as an HTTP client transaction and the corresponding
+ * HTTP or FTP server transaction.
+ *
+ * Individual transaction information worth sending or logging should be
+ * recorded here, ideally without exposing other master transaction users
+ * to internal details of individual transactions. For example, storing an
+ * HTTP client IP address is a good idea but storing a pointer to some
+ * client-side job which maintains that address is not.
+ *
+ * A master transaction is created by a newly accepted client connection,
+ * a new request on the existing client connection, or an internal request
+ * generated by Squid. All client-side protocols, including HTTP, HTCP, ICP,
+ * and SNMP will eventually create master transactions.
+ *
+ * A master transaction is auto-destroyed when its last user is gone.
+ */
+class MasterXaction : public RefCountable
+{
+public:
+    typedef RefCount<MasterXaction> Pointer;
+
+    /// transaction ID.
+    InstanceId<MasterXaction> id;
+
+    /// the listening port which originated this transaction
+    AnyP::PortCfgPointer squidPort;
+
+    /// the client TCP connection which originated this transaction
+    Comm::ConnectionPointer tcpClient;
+
+    // TODO: add state from other Jobs in the transaction
+};
+
+#endif /* SQUID_SRC_MASTERXACTION_H */
@@ -62,9 +62,14 @@ class MemBuf
      */
     bool hasContent() const { return size > 0; }
 
-    /// these space-related methods assume no growth and allow 0-termination
-    char *space() { return buf + size; } // space to add data
-    char *space(mb_size_t required) { if (size + required > capacity) grow(size + required); return buf + size; } // space to add data
+    /// returns buffer after data; does not check space existence
+    char *space() { return buf + size; } ///< space to add data
+
+    /// Returns buffer following data, after possibly growing the buffer to
+    /// accommodate addition of the required bytes PLUS a 0-terminator char.
+    /// The caller is not required to terminate the buffer, but MemBuf does
+    /// terminate internally, trading termination for size calculation bugs.
+    char *space(mb_size_t required) { if (size + required >= capacity) grow(size + required + 1); return buf + size; }
 
     mb_size_t spaceSize() const;
 
@@ -92,9 +92,8 @@ Notes::add(const String &noteKey)
 Note::Pointer
 Notes::parse(ConfigParser &parser)
 {
-    String key, value;
-    ConfigParser::ParseString(&key);
-    ConfigParser::ParseQuotedString(&value);
+    String key = ConfigParser::NextToken();
+    String value = ConfigParser::NextToken();
     Note::Pointer note = add(key);
     Note::Value::Pointer noteValue = note->addValue(value);
 
@@ -122,6 +122,7 @@ class NotePairs: public RefCountable
         MEMPROXY_CLASS(Entry);
     };
 
+    NotePairs() {}
     ~NotePairs();
 
     /**
@@ -171,6 +172,10 @@ class NotePairs: public RefCountable
     bool empty() const {return entries.empty();}
 
     Vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
+
+private:
+    NotePairs &operator = (NotePairs const &); // Not implemented
+    NotePairs(NotePairs const &); // Not implemented
 };
 
 MEMPROXY_CLASS_INLINE(NotePairs::Entry);
@@ -147,7 +147,7 @@ xatos(const char *token)
 int64_t
 GetInteger64(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -162,7 +162,7 @@ GetInteger64(void)
 int
 GetInteger(void)
 {
-    char *token = ConfigParser::strtokFile();
+    char *token = ConfigParser::NextToken();
     int i;
 
     if (token == NULL)
@@ -216,7 +216,7 @@ GetPercentage(void)
 unsigned short
 GetShort(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -95,9 +95,6 @@ class PeerDigest
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete(void *);
-
     CachePeer *peer;          /**< pointer back to peer structure, argh */
     CacheDigest *cd;            /**< actual digest structure */
     String host;                /**< copy of peer->host */
@@ -132,7 +129,7 @@ class PeerDigest
     } stats;
 
 private:
-    CBDATA_CLASS(PeerDigest);
+    CBDATA_CLASS2(PeerDigest);
 };
 
 extern const Version CacheDigestVer;
@@ -71,8 +71,8 @@ class ps_state
 {
 
 public:
-    void *operator new(size_t);
     ps_state();
+    ~ps_state();
 
     // Produce a URL for display identifying the transaction we are
     // trying to locate a peer for.
@@ -110,7 +110,7 @@ class ps_state
     ping_data ping;
     ACLChecklist *acl_checklist;
 private:
-    CBDATA_CLASS(ps_state);
+    CBDATA_CLASS2(ps_state);
 };
 
 #endif /* SQUID_PEERSELECTSTATE_H */
@@ -373,7 +373,7 @@ class SquidConfig
         acl_access *AlwaysDirect;
         acl_access *ASlists;
         acl_access *noCache;
-        acl_access *log;
+        acl_access *stats_collection;
 #if SQUID_SNMP
 
         acl_access *snmp;
@@ -398,10 +398,6 @@ class SquidConfig
         acl_access *followXFF;
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-#if ICAP_CLIENT
-        acl_access* icap;
-#endif
-
         /// spoof_client_ip squid.conf acl.
         /// nil unless configured
         acl_access* spoof_client_ip;
@@ -140,6 +140,8 @@ class StoreEntry : public hash_link
     bool hasIfMatchEtag(const HttpRequest &request) const;
     /// has ETag matching at least one of the If-None-Match etags
     bool hasIfNoneMatchEtag(const HttpRequest &request) const;
+    /// whether this entry has an ETag; if yes, puts ETag value into parameter
+    bool hasEtag(ETag &etag) const;
 
     /** What store does this entry belong too ? */
     virtual RefCount<SwapDir> store() const;
@@ -59,8 +59,6 @@ class store_client
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
     store_client(StoreEntry *);
     ~store_client();
     bool memReaderHasLowerOffset(int64_t) const;
@@ -122,7 +120,7 @@ class store_client
     } _callback;
 
 private:
-    CBDATA_CLASS(store_client);
+    CBDATA_CLASS2(store_client);
 };
 
 void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
@@ -34,6 +34,7 @@
 #include "cache_cf.h"
 #include "compat/strtoll.h"
 #include "ConfigOption.h"
+#include "ConfigParser.h"
 #include "globals.h"
 #include "Parsing.h"
 #include "SquidConfig.h"
@@ -276,7 +277,7 @@ SwapDir::parseOptions(int isaReconfig)
 
     ConfigOption *newOption = getOptionTree();
 
-    while ((name = strtok(NULL, w_space)) != NULL) {
+    while ((name = ConfigParser::NextToken()) != NULL) {
         value = strchr(name, '=');
 
         if (value) {
@@ -73,10 +73,10 @@ ACLFlags::parseFlags()
 
     /*Regex code needs to parse -i file*/
     if ( isSet(ACL_F_REGEX_CASE))
-        ConfigParser::strtokFilePutBack("-i");
+        ConfigParser::TokenPutBack("-i");
 
     if (nextToken != NULL && strcmp(nextToken, "--") != 0 )
-        ConfigParser::strtokFileUndo();
+        ConfigParser::TokenUndo();
 }
 
 const char *
@@ -200,7 +200,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 
     /* snarf the ACL name */
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseAclLine: missing ACL name.");
         parser.destruct();
         return;
@@ -217,7 +217,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
     /* snarf the ACL type */
     const char *theType;
 
-    if ((theType = strtok(NULL, w_space)) == NULL) {
+    if ((theType = ConfigParser::NextToken()) == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseAclLine: missing ACL type.");
         parser.destruct();
         return;
@@ -120,7 +120,7 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
 
     /* first expect a page name */
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseDenyInfoLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseDenyInfoLine: missing 'error page' parameter.");
         return;
@@ -133,7 +133,7 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
 
-    while ((t = strtok(NULL, w_space))) {
+    while ((t = ConfigParser::NextToken())) {
         L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
         xstrncpy(L->name, t, ACL_NAME_SZ-1);
         *Tail = L;
@@ -157,7 +157,7 @@ void
 aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
 {
     /* first expect either 'allow' or 'deny' */
-    const char *t = ConfigParser::strtokFile();
+    const char *t = ConfigParser::NextToken();
 
     if (!t) {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
@@ -264,8 +264,7 @@ Adaptation::Config::DumpServiceGroups(StoreEntry *entry, const char *name)
 void
 Adaptation::Config::ParseAccess(ConfigParser &parser)
 {
-    String groupId;
-    ConfigParser::ParseString(&groupId);
+    String groupId = ConfigParser::NextToken();
     AccessRule *r;
     if (!(r=FindRuleByGroupId(groupId))) {
         r = new AccessRule(groupId);
@@ -61,10 +61,8 @@ Adaptation::ServiceConfig::parseVectPoint(const char *service_configConfig) cons
 bool
 Adaptation::ServiceConfig::parse()
 {
-    String method_point;
-
-    ConfigParser::ParseString(&key);
-    ConfigParser::ParseString(&method_point);
+    key = ConfigParser::NextToken();
+    String method_point = ConfigParser::NextToken();
     method = parseMethod(method_point.termedBuf());
     point = parseVectPoint(method_point.termedBuf());
 
@@ -76,7 +74,7 @@ Adaptation::ServiceConfig::parse()
     bool onOverloadSet = false;
     std::set<std::string> options;
 
-    while (char *option = strtok(NULL, w_space)) {
+    while (char *option = ConfigParser::NextToken()) {
         const char *name = option;
         const char *value = "";
         if (strcmp(option, "0") == 0) { // backward compatibility
@@ -23,7 +23,7 @@ Adaptation::ServiceGroup::~ServiceGroup()
 void
 Adaptation::ServiceGroup::parse()
 {
-    ConfigParser::ParseString(&id);
+    id = ConfigParser::NextToken();
 
     wordlist *names = NULL;
     ConfigParser::ParseWordList(&names);
@@ -3,7 +3,6 @@
  */
 
 #include "squid.h"
-#include "acl/FilledChecklist.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/Launcher.h"
 #include "adaptation/icap/Xaction.h"
@@ -16,7 +15,6 @@
 #include "err_detail_type.h"
 #include "fde.h"
 #include "FwdState.h"
-#include "globals.h"
 #include "HttpMsg.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -550,16 +548,8 @@ void Adaptation::Icap::Xaction::tellQueryAborted()
 void Adaptation::Icap::Xaction::maybeLog()
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
-        ACLFilledChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
-        if (al.reply) {
-            checklist->reply = al.reply;
-            HTTPMSGLOCK(checklist->reply);
-        }
-        if (!::Config.accessList.icap || checklist->fastCheck() == ACCESS_ALLOWED) {
-            finalizeLogInfo();
-            icapLogLog(alep, checklist);
-        }
-        delete checklist;
+        finalizeLogInfo();
+        icapLogLog(alep);
     }
 }
 
@@ -1,6 +1,9 @@
 #include "squid.h"
 #include "icap_log.h"
 #include "AccessLogEntry.h"
+#include "acl/FilledChecklist.h"
+#include "HttpReply.h"
+#include "globals.h"
 #include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
@@ -46,8 +49,14 @@ icapLogRotate()
     }
 }
 
-void icapLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
+void icapLogLog(AccessLogEntry::Pointer &al)
 {
-    if (IcapLogfileStatus == LOG_ENABLE)
-        accessLogLogTo(Config.Log.icaplogs, al, checklist);
+    if (IcapLogfileStatus == LOG_ENABLE) {
+        ACLFilledChecklist checklist(NULL, al->adapted_request, NULL);
+        if (al->reply) {
+            checklist.reply = al->reply;
+            HTTPMSGLOCK(checklist.reply);
+        }
+        accessLogLogTo(Config.Log.icaplogs, al, &checklist);
+    }
 }
@@ -11,7 +11,7 @@ class ACLChecklist;
 void icapLogClose();
 void icapLogOpen();
 void icapLogRotate();
-void icapLogLog(AccessLogEntryPointer &al, ACLChecklist * checklist);
+void icapLogLog(AccessLogEntryPointer &al);
 
 extern int IcapLogfileStatus;
 
@@ -4,6 +4,7 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libanyp.la
 
 libanyp_la_SOURCES = \
+	forward.h \
 	PortCfg.cc \
 	PortCfg.h \
 	ProtocolType.cc \
@@ -1,8 +1,8 @@
 #ifndef SQUID_ANYP_PORTCFG_H
 #define SQUID_ANYP_PORTCFG_H
 
+#include "anyp/forward.h"
 #include "anyp/TrafficMode.h"
-#include "cbdata.h"
 #include "comm/Connection.h"
 
 #if USE_SSL
@@ -0,0 +1,15 @@
+#ifndef _SQUID_SRC_ANYP_FORWARD_H
+#define _SQUID_SRC_ANYP_FORWARD_H
+
+#include "base/CbcPointer.h"
+
+namespace AnyP
+{
+
+class PortCfg;
+typedef CbcPointer<PortCfg> PortCfgPointer;
+
+} // namespace AnyP
+
+#endif /* _SQUID_SRC_ANYP_FORWARD_H */
+
@@ -114,9 +114,6 @@
 #if HAVE_LIST
 #include <list>
 #endif
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
 #if HAVE_PWD_H
 #include <pwd.h>
 #endif
@@ -676,12 +673,6 @@ configDoConfigure(void)
         Config.Store.maxObjectSize = 0x7FFF0000;
     }
 #endif
-    if (0 == Store::Root().maxSize())
-        /* people might want a zero-sized cache on purpose */
-        (void) 0;
-    else if (Store::Root().maxSize() < Config.memMaxSize)
-        /* This is bogus. folk with NULL caches will want this */
-        debugs(3, DBG_CRITICAL, "WARNING cache_mem is larger than total disk cache space!");
 
     if (Config.Announce.period > 0) {
         Config.onoff.announce = 1;
@@ -1011,6 +1002,12 @@ parse_obsolete(const char *name)
         debugs(3, DBG_CRITICAL, "WARNING: url_rewrite_concurrency upgrade overriding url_rewrite_children settings.");
         Config.redirectChildren.concurrency = cval;
     }
+
+    if (!strcmp(name, "log_access"))
+        self_destruct();
+
+    if (!strcmp(name, "log_icap"))
+        self_destruct();
 }
 
 /* Parse a time specification from the config file.  Store the
@@ -1026,7 +1023,7 @@ parseTimeLine(time_msec_t * tptr, const char *units,  bool allowMsec)
     if ((u = parseTimeUnits(units, allowMsec)) == 0)
         self_destruct();
 
-    if ((token = strtok(NULL, w_space)) == NULL)
+    if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
     d = xatof(token);
@@ -1035,7 +1032,7 @@ parseTimeLine(time_msec_t * tptr, const char *units,  bool allowMsec)
 
     if (0 == d)
         (void) 0;
-    else if ((token = strtok(NULL, w_space)) == NULL)
+    else if ((token = ConfigParser::NextToken()) == NULL)
         debugs(3, DBG_CRITICAL, "WARNING: No units on '" <<
                config_input_line << "', assuming " <<
                d << " " << units  );
@@ -1102,7 +1099,7 @@ parseBytesLine64(int64_t * bptr, const char *units)
         return;
     }
 
-    if ((token = strtok(NULL, w_space)) == NULL) {
+    if ((token = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -1118,7 +1115,7 @@ parseBytesLine64(int64_t * bptr, const char *units)
 
     if (0.0 == d)
         (void) 0;
-    else if ((token = strtok(NULL, w_space)) == NULL)
+    else if ((token = ConfigParser::NextToken()) == NULL)
         debugs(3, DBG_CRITICAL, "WARNING: No units on '" <<
                config_input_line << "', assuming " <<
                d << " " <<  units  );
@@ -1149,7 +1146,7 @@ parseBytesLine(size_t * bptr, const char *units)
         return;
     }
 
-    if ((token = strtok(NULL, w_space)) == NULL) {
+    if ((token = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -1165,7 +1162,7 @@ parseBytesLine(size_t * bptr, const char *units)
 
     if (0.0 == d)
         (void) 0;
-    else if ((token = strtok(NULL, w_space)) == NULL)
+    else if ((token = ConfigParser::NextToken()) == NULL)
         debugs(3, DBG_CRITICAL, "WARNING: No units on '" <<
                config_input_line << "', assuming " <<
                d << " " <<  units  );
@@ -1197,7 +1194,7 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
         return;
     }
 
-    if ((token = strtok(NULL, w_space)) == NULL) {
+    if ((token = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -1213,7 +1210,7 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
 
     if (0.0 == d)
         (void) 0;
-    else if ((token = strtok(NULL, w_space)) == NULL)
+    else if ((token = ConfigParser::NextToken()) == NULL)
         debugs(3, DBG_CRITICAL, "WARNING: No units on '" <<
                config_input_line << "', assuming " <<
                d << " " <<  units  );
@@ -1370,7 +1367,7 @@ dump_address(StoreEntry * entry, const char *name, Ip::Address &addr)
 static void
 parse_address(Ip::Address *addr)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (!token) {
         self_destruct();
@@ -1478,7 +1475,7 @@ parse_acl_tos(acl_tos ** head)
     acl_tos *l;
     acl_tos **tail = head;	/* sane name below */
     unsigned int tos;           /* Initially uint for strtoui. Casted to tos_t before return */
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (!token) {
         self_destruct();
@@ -1549,7 +1546,7 @@ parse_acl_nfmark(acl_nfmark ** head)
     acl_nfmark *l;
     acl_nfmark **tail = head;	/* sane name below */
     nfmark_t mark;
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (!token) {
         self_destruct();
@@ -1751,7 +1748,7 @@ parse_http_header_access(HeaderManglers **pm)
 {
     char *t = NULL;
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(3, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(3, DBG_CRITICAL, "parse_http_header_access: missing header name.");
         return;
@@ -1790,7 +1787,7 @@ parse_http_header_replace(HeaderManglers **pm)
 {
     char *t = NULL;
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(3, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(3, DBG_CRITICAL, "parse_http_header_replace: missing header name.");
         return;
@@ -1835,10 +1832,10 @@ parse_authparam(Auth::ConfigVector * config)
     char *type_str;
     char *param_str;
 
-    if ((type_str = strtok(NULL, w_space)) == NULL)
+    if ((type_str = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
-    if ((param_str = strtok(NULL, w_space)) == NULL)
+    if ((param_str = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
     /* find a configuration for the scheme in the currently parsed configs... */
@@ -1909,10 +1906,10 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
     int i;
     int fs;
 
-    if ((type_str = strtok(NULL, w_space)) == NULL)
+    if ((type_str = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
-    if ((path_str = strtok(NULL, w_space)) == NULL)
+    if ((path_str = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
     fs = find_fstype(type_str);
@@ -2067,7 +2064,7 @@ GetService(const char *proto)
 {
     struct servent *port = NULL;
     /** Parses a port number or service name from the squid.conf */
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
     if (token == NULL) {
         self_destruct();
         return 0; /* NEVER REACHED */
@@ -2115,14 +2112,14 @@ parse_peer(CachePeer ** head)
     p->basetime = 0;
     p->stats.logged_state = PEER_ALIVE;
 
-    if ((token = strtok(NULL, w_space)) == NULL)
+    if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
     p->host = xstrdup(token);
 
     p->name = xstrdup(token);
 
-    if ((token = strtok(NULL, w_space)) == NULL)
+    if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
     p->type = parseNeighborType(token);
@@ -2140,7 +2137,7 @@ parse_peer(CachePeer ** head)
     p->icp.port = GetUdpService();
     p->connection_auth = 2;    /* auto */
 
-    while ((token = strtok(NULL, w_space))) {
+    while ((token = ConfigParser::NextToken())) {
         if (!strcmp(token, "proxy-only")) {
             p->options.proxy_only = true;
         } else if (!strcmp(token, "no-query")) {
@@ -2524,7 +2521,7 @@ parse_peer_access(void)
     char *host = NULL;
     CachePeer *p;
 
-    if (!(host = strtok(NULL, w_space)))
+    if (!(host = ConfigParser::NextToken()))
         self_destruct();
 
     if ((p = peerFindByName(host)) == NULL) {
@@ -2543,10 +2540,10 @@ parse_hostdomain(void)
     char *host = NULL;
     char *domain = NULL;
 
-    if (!(host = strtok(NULL, w_space)))
+    if (!(host = ConfigParser::NextToken()))
         self_destruct();
 
-    while ((domain = strtok(NULL, list_sep))) {
+    while ((domain = ConfigParser::NextToken())) {
         CachePeerDomainList *l = NULL;
         CachePeerDomainList **L = NULL;
         CachePeer *p;
@@ -2578,13 +2575,13 @@ parse_hostdomaintype(void)
     char *type = NULL;
     char *domain = NULL;
 
-    if (!(host = strtok(NULL, w_space)))
+    if (!(host = ConfigParser::NextToken()))
         self_destruct();
 
-    if (!(type = strtok(NULL, w_space)))
+    if (!(type = ConfigParser::NextToken()))
         self_destruct();
 
-    while ((domain = strtok(NULL, list_sep))) {
+    while ((domain = ConfigParser::NextToken())) {
         NeighborTypeDomainList *l = NULL;
         NeighborTypeDomainList **L = NULL;
         CachePeer *p;
@@ -2632,7 +2629,7 @@ dump_onoff(StoreEntry * entry, const char *name, int var)
 void
 parse_onoff(int *var)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -2673,7 +2670,7 @@ dump_tristate(StoreEntry * entry, const char *name, int var)
 static void
 parse_tristate(int *var)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -2713,7 +2710,7 @@ parse_pipelinePrefetch(int *var)
         debugs(0, DBG_PARSE_NOTE(2), "WARNING: 'pipeline_prefetch off' is deprecated. Please update to use '0'.");
         *var = 0;
     } else {
-        ConfigParser::strtokFileUndo();
+        ConfigParser::TokenUndo();
         parse_int(var);
     }
 }
@@ -2806,17 +2803,17 @@ parse_refreshpattern(RefreshPattern ** head)
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
 
-    if ((token = strtok(NULL, w_space)) == NULL) {
+    if ((token = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
 
     if (strcmp(token, "-i") == 0) {
         flags |= REG_ICASE;
-        token = strtok(NULL, w_space);
+        token = ConfigParser::NextToken();
     } else if (strcmp(token, "+i") == 0) {
         flags &= ~REG_ICASE;
-        token = strtok(NULL, w_space);
+        token = ConfigParser::NextToken();
     }
 
     if (token == NULL) {
@@ -2859,7 +2856,7 @@ parse_refreshpattern(RefreshPattern ** head)
     max = (time_t) (i * 60);	/* convert minutes to seconds */
 
     /* Options */
-    while ((token = strtok(NULL, w_space)) != NULL) {
+    while ((token = ConfigParser::NextToken()) != NULL) {
         if (!strcmp(token, "refresh-ims")) {
             refresh_ims = 1;
         } else if (!strcmp(token, "store-stale")) {
@@ -2990,7 +2987,7 @@ dump_string(StoreEntry * entry, const char *name, char *var)
 static void
 parse_string(char **var)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
     safe_free(*var);
 
     if (token == NULL)
@@ -2999,23 +2996,6 @@ parse_string(char **var)
     *var = xstrdup(token);
 }
 
-void
-ConfigParser::ParseString(char **var)
-{
-    parse_string(var);
-}
-
-void
-ConfigParser::ParseString(String *var)
-{
-    char *token = strtok(NULL, w_space);
-
-    if (token == NULL)
-        self_destruct();
-
-    var->reset(token);
-}
-
 static void
 free_string(char **var)
 {
@@ -3030,7 +3010,7 @@ parse_eol(char *volatile *var)
         return;
     }
 
-    unsigned char *token = (unsigned char *) strtok(NULL, null_string);
+    unsigned char *token = (unsigned char *) ConfigParser::NextQuotedOrToEol();
     safe_free(*var);
 
     if (!token) {
@@ -3264,9 +3244,7 @@ void
 parse_wordlist(wordlist ** list)
 {
     char *token;
-    char *t = strtok(NULL, "");
-
-    while ((token = strwordtok(NULL, &t)))
+    while ((token = ConfigParser::NextToken()))
         wordlistAdd(list, token);
 }
 
@@ -3291,7 +3269,7 @@ check_null_acl_access(acl_access * a)
 static void
 parse_uri_whitespace(int *var)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (token == NULL)
         self_destruct();
@@ -3404,7 +3382,7 @@ free_memcachemode(SquidConfig * config)
 static void
 parse_memcachemode(SquidConfig * config)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
     if (!token)
         self_destruct();
 
@@ -3474,7 +3452,7 @@ parse_IpAddress_list(Ip::Address_list ** head)
     Ip::Address_list *s;
     Ip::Address ipa;
 
-    while ((token = strtok(NULL, w_space))) {
+    while ((token = ConfigParser::NextToken())) {
         if (GetHostWithPort(token, &ipa)) {
 
             while (*head)
@@ -3619,14 +3597,6 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         /* Log information regarding the port modes under interception. */
         debugs(3, DBG_IMPORTANT, "Starting Authentication on port " << s->s);
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (interception enabled)");
-
-        /* INET6: until transparent REDIRECT works on IPv6 SOCKET, force wildcard to IPv4 */
-        if (Ip::EnableIpv6)
-            debugs(3, DBG_IMPORTANT, "Disabling IPv6 on port " << s->s << " (interception enabled)");
-        if ( !s->s.setIPv4() ) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot NAT intercept (protocol does not provide NAT)" << s->s );
-            self_destruct();
-        }
     } else if (strcmp(token, "tproxy") == 0) {
         if (s->flags.natIntercept || s->flags.accelSurrogate) {
             debugs(3,DBG_CRITICAL, "FATAL: http(s)_port: TPROXY option requires its own interception port. It cannot be shared with other modes.");
@@ -3823,7 +3793,7 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
         return;
     }
 
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (!token) {
         self_destruct();
@@ -3834,7 +3804,7 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
     parsePortSpecification(s, token);
 
     /* parse options ... */
-    while ((token = strtok(NULL, w_space))) {
+    while ((token = ConfigParser::NextToken())) {
         parse_port_option(s, token);
     }
 
@@ -4082,7 +4052,7 @@ parse_access_log(CustomLog ** logs)
 
     /* determine configuration style */
 
-    const char *filename = strtok(NULL, w_space);
+    const char *filename = ConfigParser::NextToken();
     if (!filename) {
         self_destruct();
         return;
@@ -4107,7 +4077,7 @@ parse_access_log(CustomLog ** logs)
         // if logformat name is not recognized,
         // put back the token; it must be an ACL name
         if (!setLogformat(cl, token, false))
-            ConfigParser::strtokFileUndo();
+            ConfigParser::TokenUndo();
     } else { // style #4
         do {
             if (strncasecmp(token, "on-error=", 9) == 0) {
@@ -4126,7 +4096,7 @@ parse_access_log(CustomLog ** logs)
                 setLogformat(cl, token+10, true);
             } else if (!strchr(token, '=')) {
                 // put back the token; it must be an ACL name
-                ConfigParser::strtokFileUndo();
+                ConfigParser::TokenUndo();
                 break; // done with name=value options, now to ACLs
             } else {
                 debugs(3, DBG_CRITICAL, "Unknown access_log option " << token);
@@ -4319,8 +4289,8 @@ parse_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap)
     if (!*cpuAffinityMap)
         *cpuAffinityMap = new CpuAffinityMap;
 
-    const char *const pToken = strtok(NULL, w_space);
-    const char *const cToken = strtok(NULL, w_space);
+    const char *const pToken = ConfigParser::NextToken();
+    const char *const cToken = ConfigParser::NextToken();
     Vector<int> processes, cores;
     if (!parseNamedIntList(pToken, "process_numbers", processes)) {
         debugs(3, DBG_CRITICAL, "FATAL: bad 'process_numbers' parameter " <<
@@ -4452,15 +4422,15 @@ static void parse_icap_service_failure_limit(Adaptation::Icap::Config *cfg)
     time_t m;
     cfg->service_failure_limit = GetInteger();
 
-    if ((token = strtok(NULL, w_space)) == NULL)
+    if ((token = ConfigParser::NextToken()) == NULL)
         return;
 
     if (strcmp(token,"in") != 0) {
         debugs(3, DBG_CRITICAL, "expecting 'in' on'"  << config_input_line << "'");
         self_destruct();
     }
 
-    if ((token = strtok(NULL, w_space)) == NULL) {
+    if ((token = ConfigParser::NextToken()) == NULL) {
         self_destruct();
     }
 
@@ -4470,7 +4440,7 @@ static void parse_icap_service_failure_limit(Adaptation::Icap::Config *cfg)
 
     if (0 == d)
         (void) 0;
-    else if ((token = strtok(NULL, w_space)) == NULL) {
+    else if ((token = ConfigParser::NextToken()) == NULL) {
         debugs(3, DBG_CRITICAL, "No time-units on '" << config_input_line << "'");
         self_destruct();
     } else if ((m = parseTimeUnits(token, false)) == 0)
@@ -4500,7 +4470,7 @@ static void parse_sslproxy_cert_adapt(sslproxy_cert_adapt **cert_adapt)
 {
     char *al;
     sslproxy_cert_adapt *ca = (sslproxy_cert_adapt *) xcalloc(1, sizeof(sslproxy_cert_adapt));
-    if ((al = strtok(NULL, w_space)) == NULL) {
+    if ((al = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -4578,7 +4548,7 @@ static void parse_sslproxy_cert_sign(sslproxy_cert_sign **cert_sign)
 {
     char *al;
     sslproxy_cert_sign *cs = (sslproxy_cert_sign *) xcalloc(1, sizeof(sslproxy_cert_sign));
-    if ((al = strtok(NULL, w_space)) == NULL) {
+    if ((al = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -4670,7 +4640,7 @@ static void parse_sslproxy_ssl_bump(acl_access **ssl_bump)
     static BumpCfgStyle bumpCfgStyleLast = bcsNone;
     BumpCfgStyle bumpCfgStyleNow = bcsNone;
     char *bm;
-    if ((bm = strtok(NULL, w_space)) == NULL) {
+    if ((bm = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -4772,7 +4742,7 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
     if (!*headers) {
         *headers = new HeaderWithAclList;
     }
-    if ((fn = strtok(NULL, w_space)) == NULL) {
+    if ((fn = ConfigParser::NextToken()) == NULL) {
         self_destruct();
         return;
     }
@@ -4782,20 +4752,20 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
     if (hwa.fieldId == HDR_BAD_HDR)
         hwa.fieldId = HDR_OTHER;
 
-    String buf;
-    bool wasQuoted;
-    ConfigParser::ParseQuotedString(&buf, &wasQuoted);
+    Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
+    ConfigParser::EnableMacros();
+    String buf = ConfigParser::NextToken();
+    ConfigParser::DisableMacros();
     hwa.fieldValue = buf.termedBuf();
-    hwa.quoted = wasQuoted;
+    hwa.quoted = ConfigParser::LastTokenWasQuoted();
     if (hwa.quoted) {
-        Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
         if (!nlf->parse(hwa.fieldValue.c_str())) {
             self_destruct();
             return;
         }
         hwa.valueFormat = nlf;
-    }
-
+    } else
+        delete nlf;
     aclParseAclList(LegacyParser, &hwa.aclList, (hwa.fieldName + ':' + hwa.fieldValue).c_str());
     (*headers)->push_back(hwa);
 }
@@ -374,9 +374,6 @@ cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size,
  */
 #define cbdataReferenceDone(var) do {if (var) {cbdataInternalUnlock(var); var = NULL;}} while(0)
 
-/// \ingroup CBDATAAPI
-#define CBDATA_CLASS(type)	static cbdata_type CBDATA_##type
-
 /// \ingroup CBDATAAPI
 #define CBDATA_CLASS_INIT(type) cbdata_type type::CBDATA_##type = CBDATA_UNKNOWN
 #define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
@@ -65,6 +65,19 @@ COMMENT_START
   configuration files.
 
 
+  Values with spaces, quotes, and other special characters
+
+	Squid supports directive parameters with spaces, quotes, and other
+	special characters. Surround such parameters with "double quotes". Use
+	the configuration_includes_quoted_values directive to enable or
+	disable that support.
+
+	Squid supports reading configuration option parameters from external
+	files using the syntax:
+		parameters("/path/filename")
+	For example:
+		acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
+
   Conditional configuration
 
 	If-statements can be used to make configuration directives
@@ -3678,6 +3691,8 @@ DOC_START
 		>eui	Client source EUI (MAC address, EUI-48 or EUI-64 identifier)
 		>la	Local IP address the client connected to
 		>lp	Local port number the client connected to
+		>qos    Client connection TOS/DSCP value set by Squid
+		>nfmark Client connection netfilter mark set by Squid
 
 		la	Local listening IP address the client connection was connected to.
 		lp	Local listening port number the client connection was connected to.
@@ -3687,6 +3702,8 @@ DOC_START
 		<p	Server port number of the last server or peer connection
 		<la	Local IP address of the last server or peer connection
 		<lp     Local port number of the last server or peer connection
+		<qos	Server connection TOS/DSCP value set by Squid
+		<nfmark Server connection netfilter mark set by Squid
 
 	Time related format codes:
 
@@ -4046,31 +4063,31 @@ DOC_START
 DOC_END
 
 NAME: log_access
+TYPE: obsolete
+DOC_START
+	Remove this line. Use acls with access_log directives to control access logging
+DOC_END
+
+NAME: log_icap
+TYPE: obsolete
+DOC_START
+	Remove this line. Use acls with icap_log directives to control icap logging
+DOC_END
+
+NAME: stats_collection
 TYPE: acl_access
-LOC: Config.accessList.log
+LOC: Config.accessList.stats_collection
 DEFAULT: none
 DEFAULT_DOC: Allow logging for all transactions.
 COMMENT: allow|deny acl acl...
 DOC_START
-	This options allows you to control which requests gets logged
-	to access.log (see access_log directive). Requests denied for
-	logging will also not be accounted for in performance counters.
+	This options allows you to control which requests gets accounted
+	in performance counters.
 
 	This clause only supports fast acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
 DOC_END
 
-NAME: log_icap
-TYPE: acl_access
-IFDEF: ICAP_CLIENT
-LOC: Config.accessList.icap
-DEFAULT: none
-DEFAULT_DOC: Allow logging for all ICAP transactions.
-DOC_START
-	This options allows you to control which requests get logged
-	to icap.log. See the icap_log directive for ICAP log details.
-DOC_END
-
 NAME: cache_store_log
 TYPE: string
 DEFAULT: none
@@ -4861,10 +4878,12 @@ DOC_START
 		override-lastmod enforces min age even on objects
 		that were modified recently.
 
-		reload-into-ims changes client no-cache or ``reload''
-		to If-Modified-Since requests. Doing this VIOLATES the
-		HTTP standard. Enabling this feature could make you
-		liable for problems which it causes.
+		reload-into-ims changes a client no-cache or ``reload''
+		request for a cached entry into a conditional request using
+		If-Modified-Since and/or If-None-Match headers, provided the
+		cached entry has a Last-Modified and/or a strong ETag header.
+		Doing this VIOLATES the HTTP standard. Enabling this feature
+		could make you liable for problems which it causes.
 
 		ignore-reload ignores a client no-cache or ``reload''
 		header. Doing this VIOLATES the HTTP standard. Enabling
@@ -8442,6 +8461,19 @@ COMMENT_START
  -----------------------------------------------------------------------------
 COMMENT_END
 
+NAME: configuration_includes_quoted_values
+COMMENT: on|off
+TYPE: onoff
+DEFAULT: on
+LOC: ConfigParser::RecognizeQuotedValues
+DOC_START
+	If set, Squid will recognize each "quoted string" after a configuration
+	directive as a single parameter. The quotes are stripped before the
+	parameter value is interpreted or used.
+	See "Values with spaces, quotes, and other special characters"
+	section for more details.
+DOC_END
+
 NAME: memory_pools
 COMMENT: on|off
 TYPE: onoff
@@ -681,7 +681,8 @@ gen_parse(const EntryList &head, std::ostream &fout)
     "{\n"
     "\tchar\t*token;\n"
     "\tif ((token = strtok(buff, w_space)) == NULL) \n"
-    "\t\treturn 1;\t/* ignore empty lines */\n";
+    "\t\treturn 1;\t/* ignore empty lines */\n"
+    "\tConfigParser::SetCfgLine(strtok(NULL, \"\"));\n";
 
     for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e)
         e->genParse(fout);
@@ -193,21 +193,6 @@ static void clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId
 
 CBDATA_CLASS_INIT(ClientSocketContext);
 
-void *
-ClientSocketContext::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ClientSocketContext));
-    CBDATA_INIT_TYPE(ClientSocketContext);
-    return cbdataAlloc(ClientSocketContext);
-}
-
-void
-ClientSocketContext::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 /* Local functions */
 /* ClientSocketContext */
 static ClientSocketContext *ClientSocketContextNew(const Comm::ConnectionPointer &clientConn, ClientHttpRequest *);
@@ -245,8 +230,6 @@ static void clientUpdateSocketStats(LogTags logType, size_t size);
 char *skipLeadingSpace(char *aString);
 static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
 
-static ConnStateData *connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port);
-
 clientStreamNode *
 ClientSocketContext::getTail() const
 {
@@ -698,27 +681,35 @@ ClientHttpRequest::logRequest()
         }
     }
 
-    ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.log, this);
-
+    ACLFilledChecklist checklist(NULL, request, NULL);
     if (al->reply) {
-        checklist->reply = al->reply;
-        HTTPMSGLOCK(checklist->reply);
+        checklist.reply = al->reply;
+        HTTPMSGLOCK(checklist.reply);
+    }
+
+    if (request) {
+        al->adapted_request = request;
+        HTTPMSGLOCK(al->adapted_request);
     }
+    accessLogLog(al, &checklist);
 
-    if (!Config.accessList.log || checklist->fastCheck() == ACCESS_ALLOWED) {
-        if (request) {
-            al->adapted_request = request;
-            HTTPMSGLOCK(al->adapted_request);
+    bool updatePerformanceCounters = true;
+    if (Config.accessList.stats_collection) {
+        ACLFilledChecklist statsCheck(Config.accessList.stats_collection, request, NULL);
+        if (al->reply) {
+            statsCheck.reply = al->reply;
+            HTTPMSGLOCK(statsCheck.reply);
         }
-        accessLogLog(al, checklist);
+        updatePerformanceCounters = (statsCheck.fastCheck() == ACCESS_ALLOWED);
+    }
+
+    if (updatePerformanceCounters) {
         if (request)
             updateCounters();
 
         if (getConn() != NULL && getConn()->clientConnection != NULL)
             clientdbUpdate(getConn()->clientConnection->remote, logType, AnyP::PROTO_HTTP, out.size);
     }
-
-    delete checklist;
 }
 
 void
@@ -881,7 +872,6 @@ ConnStateData::swanSong()
 
     if (Comm::IsConnOpen(clientConnection))
         clientConnection->close();
-    clientConnection = NULL;
 
 #if USE_AUTH
     // NP: do this bit after closing the connections to avoid side effects from unwanted TCP RST
@@ -2710,10 +2700,9 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
         goto finish;
     }
 
-    /* RFC 2616 section 10.5.6 : handle unsupported HTTP versions cleanly. */
-    /* We currently only accept 0.9, 1.0, 1.1 */
+    /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
+    /* We currently only support 0.9, 1.0, 1.1 properly */
     if ( (http_ver.major == 0 && http_ver.minor != 9) ||
-            (http_ver.major == 1 && http_ver.minor > 1 ) ||
             (http_ver.major > 1) ) {
 
         clientStreamNode *node = context->getClientReplyContext();
@@ -3330,23 +3319,37 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
         io.conn->close();
 }
 
-ConnStateData *
-connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
+ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
+        AsyncJob("ConnStateData"),
+#if USE_SSL
+        sslBumpMode(Ssl::bumpEnd),
+        switchedToHttps_(false),
+        sslServerBump(NULL),
+#endif
+        stoppedSending_(NULL),
+        stoppedReceiving_(NULL)
 {
-    ConnStateData *result = new ConnStateData;
+    pinning.host = NULL;
+    pinning.port = -1;
+    pinning.pinned = false;
+    pinning.auth = false;
+    pinning.zeroReply = false;
+    pinning.peer = NULL;
+
+    // store the details required for creating more MasterXaction objects as new requests come in
+    clientConnection = xact->tcpClient;
+    port = cbdataReference(xact->squidPort.get());
+    log_addr = xact->tcpClient->remote;
+    log_addr.applyMask(Config.Addrs.client_netmask);
 
-    result->clientConnection = client;
-    result->log_addr = client->remote;
-    result->log_addr.applyMask(Config.Addrs.client_netmask);
-    result->in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &result->in.allocatedSize);
-    result->port = cbdataReference(port);
+    in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &in.allocatedSize);
 
     if (port->disable_pmtu_discovery != DISABLE_PMTU_OFF &&
-            (result->transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
+            (transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
         int i = IP_PMTUDISC_DONT;
-        if (setsockopt(client->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0)
-            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << client << " : " << xstrerror());
+        if (setsockopt(clientConnection->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0)
+            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << clientConnection << " : " << xstrerror());
 #else
         static bool reported = false;
 
@@ -3358,33 +3361,39 @@ connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
     }
 
     typedef CommCbMemFunT<ConnStateData, CommCloseCbParams> Dialer;
-    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, result, ConnStateData::connStateClosed);
-    comm_add_close_handler(client->fd, call);
+    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, ConnStateData::connStateClosed);
+    comm_add_close_handler(clientConnection->fd, call);
 
     if (Config.onoff.log_fqdn)
-        fqdncache_gethostbyaddr(client->remote, FQDN_LOOKUP_IF_MISS);
+        fqdncache_gethostbyaddr(clientConnection->remote, FQDN_LOOKUP_IF_MISS);
 
 #if USE_IDENT
     if (Ident::TheConfig.identLookup) {
         ACLFilledChecklist identChecklist(Ident::TheConfig.identLookup, NULL, NULL);
-        identChecklist.src_addr = client->remote;
-        identChecklist.my_addr = client->local;
+        identChecklist.src_addr = xact->tcpClient->remote;
+        identChecklist.my_addr = xact->tcpClient->local;
         if (identChecklist.fastCheck() == ACCESS_ALLOWED)
-            Ident::Start(client, clientIdentDone, result);
+            Ident::Start(xact->tcpClient, clientIdentDone, this);
     }
 #endif
 
-    clientdbEstablished(client->remote, 1);
+    clientdbEstablished(clientConnection->remote, 1);
 
-    result->flags.readMore = true;
-    return result;
+    flags.readMore = true;
 }
 
 /** Handle a new connection on HTTP socket. */
 void
 httpAccept(const CommAcceptCbParams &params)
 {
-    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
+    MasterXaction::Pointer xact = params.xaction;
+    AnyP::PortCfgPointer s = xact->squidPort;
+
+    if (!s.valid()) {
+        // it is possible the call or accept() was still queued when the port was reconfigured
+        debugs(33, 2, "HTTP accept failure: port reconfigured.");
+        return;
+    }
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3402,7 +3411,7 @@ httpAccept(const CommAcceptCbParams &params)
     ++ incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = connStateCreate(params.conn, s);
+    ConnStateData *connState = new ConnStateData(xact);
 
     typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
@@ -3651,7 +3660,7 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
 
 /**
  * A callback function to use with the ACLFilledChecklist callback.
- * In the case of ACCES_ALLOWED answer initializes a bumped SSL connection,
+ * In the case of ACCESS_ALLOWED answer initializes a bumped SSL connection,
  * else reverts the connection to tunnel mode.
  */
 static void
@@ -3693,7 +3702,14 @@ httpsSslBumpAccessCheckDone(allow_t answer, void *data)
 static void
 httpsAccept(const CommAcceptCbParams &params)
 {
-    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
+    MasterXaction::Pointer xact = params.xaction;
+    const AnyP::PortCfgPointer s = xact->squidPort;
+
+    if (!s.valid()) {
+        // it is possible the call or accept() was still queued when the port was reconfigured
+        debugs(33, 2, "HTTPS accept failure: port reconfigured.");
+        return;
+    }
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3711,7 +3727,7 @@ httpsAccept(const CommAcceptCbParams &params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = connStateCreate(params.conn, s);
+    ConnStateData *connState = new ConnStateData(xact);
 
     if (s->flags.tunnelSslBumping) {
         debugs(33, 5, "httpsAccept: accept transparent connection: " << params.conn);
@@ -4310,24 +4326,6 @@ clientAclChecklistCreate(const acl_access * acl, ClientHttpRequest * http)
 
 CBDATA_CLASS_INIT(ConnStateData);
 
-ConnStateData::ConnStateData() :
-        AsyncJob("ConnStateData"),
-#if USE_SSL
-        sslBumpMode(Ssl::bumpEnd),
-        switchedToHttps_(false),
-        sslServerBump(NULL),
-#endif
-        stoppedSending_(NULL),
-        stoppedReceiving_(NULL)
-{
-    pinning.host = NULL;
-    pinning.port = -1;
-    pinning.pinned = false;
-    pinning.auth = false;
-    pinning.zeroReply = false;
-    pinning.peer = NULL;
-}
-
 bool
 ConnStateData::transparent() const
 {
@@ -4545,18 +4543,14 @@ ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *a
     bool valid = true;
     if (!Comm::IsConnOpen(pinning.serverConnection))
         valid = false;
-    if (pinning.auth && request && strcasecmp(pinning.host, request->GetHost()) != 0) {
+    else if (pinning.auth && pinning.host && request && strcasecmp(pinning.host, request->GetHost()) != 0)
         valid = false;
-    }
-    if (request && pinning.port != request->port) {
+    else if (request && pinning.port != request->port)
         valid = false;
-    }
-    if (pinning.peer && !cbdataReferenceValid(pinning.peer)) {
+    else if (pinning.peer && !cbdataReferenceValid(pinning.peer))
         valid = false;
-    }
-    if (aPeer != pinning.peer) {
+    else if (aPeer != pinning.peer)
         valid = false;
-    }
 
     if (!valid) {
         /* The pinning info is not safe, remove any pinning info */
@@ -83,8 +83,6 @@ class ClientSocketContext : public RefCountable
 
 public:
     typedef RefCount<ClientSocketContext> Pointer;
-    void *operator new(size_t);
-    void operator delete(void *);
     ClientSocketContext();
     ~ClientSocketContext();
     bool startOfOutput() const;
@@ -159,7 +157,7 @@ class ClientSocketContext : public RefCountable
     bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
     bool connRegistered_;
 
-    CBDATA_CLASS(ClientSocketContext);
+    CBDATA_CLASS2(ClientSocketContext);
 };
 
 class ConnectionDetail;
@@ -187,8 +185,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
 {
 
 public:
-
-    ConnStateData();
+    explicit ConnStateData(const MasterXaction::Pointer &xact);
     ~ConnStateData();
 
     void readSomeData();
@@ -273,6 +270,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
+    /// Squid listening port details where this connection arrived.
     AnyP::PortCfg *port;
 
     bool transparent() const;
@@ -35,6 +35,7 @@
 #include "anyp/PortCfg.h"
 #include "client_side_reply.h"
 #include "errorpage.h"
+#include "ETag.h"
 #include "fd.h"
 #include "fde.h"
 #include "format/Token.h"
@@ -171,22 +172,6 @@ clientReplyContext::removeClientStoreReference(store_client **scp, ClientHttpReq
     aHttpRequest->storeEntry(reference);
 }
 
-void *
-clientReplyContext::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (clientReplyContext));
-    CBDATA_INIT_TYPE(clientReplyContext);
-    return cbdataAlloc(clientReplyContext);
-}
-
-void
-clientReplyContext::operator delete (void *address)
-{
-    clientReplyContext * tmp = (clientReplyContext *)address;
-    cbdataFree (tmp);
-}
-
 void
 clientReplyContext::saveState()
 {
@@ -287,6 +272,13 @@ clientReplyContext::processExpired()
 #endif
 
     http->request->lastmod = old_entry->lastmod;
+
+    if (!http->request->header.has(HDR_IF_NONE_MATCH)) {
+        ETag etag = {NULL, -1}; // TODO: make that a default ETag constructor
+        if (old_entry->hasEtag(etag) && !etag.weak)
+            http->request->etag = etag.str;
+    }
+
     debugs(88, 5, "clientReplyContext::processExpired : lastmod " << entry->lastmod );
     http->storeEntry(entry);
     assert(http->out.offset == 0);
@@ -44,8 +44,6 @@ class clientReplyContext : public RefCountable, public StoreClient
 {
 
 public:
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
     static STCB CacheHit;
     static STCB HandleIMSReply;
     static STCB SendMoreData;
@@ -152,7 +150,7 @@ class clientReplyContext : public RefCountable, public StoreClient
     store_client *old_sc;	/* ... for entry to be validated */
     bool deleting;
 
-    CBDATA_CLASS(clientReplyContext);
+    CBDATA_CLASS2(clientReplyContext);
 };
 
 #endif /* SQUID_CLIENTSIDEREPLY_H */
@@ -107,22 +107,6 @@ ErrorState *clientBuildError(err_type, Http::StatusCode, char const *url, Ip::Ad
 
 CBDATA_CLASS_INIT(ClientRequestContext);
 
-void *
-ClientRequestContext::operator new (size_t size)
-{
-    assert (size == sizeof(ClientRequestContext));
-    CBDATA_INIT_TYPE(ClientRequestContext);
-    ClientRequestContext *result = cbdataAlloc(ClientRequestContext);
-    return result;
-}
-
-void
-ClientRequestContext::operator delete (void *address)
-{
-    ClientRequestContext *t = static_cast<ClientRequestContext *>(address);
-    cbdataFree(t);
-}
-
 /* Local functions */
 /* other */
 static void clientAccessCheckDoneWrapper(allow_t, void *);
@@ -170,22 +154,6 @@ ClientRequestContext::ClientRequestContext(ClientHttpRequest *anHttp) : http(cbd
 
 CBDATA_CLASS_INIT(ClientHttpRequest);
 
-void *
-ClientHttpRequest::operator new (size_t size)
-{
-    assert (size == sizeof (ClientHttpRequest));
-    CBDATA_INIT_TYPE(ClientHttpRequest);
-    ClientHttpRequest *result = cbdataAlloc(ClientHttpRequest);
-    return result;
-}
-
-void
-ClientHttpRequest::operator delete (void *address)
-{
-    ClientHttpRequest *t = static_cast<ClientHttpRequest *>(address);
-    cbdataFree(t);
-}
-
 ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
 #if USE_ADAPTATION
         AsyncJob("ClientHttpRequest"),
@@ -665,8 +633,16 @@ ClientRequestContext::hostHeaderVerify()
     uint16_t port = 0;
     if (portStr) {
         *portStr = '\0'; // strip the ':'
-        if (*(++portStr) != '\0')
-            port = xatoi(portStr);
+        if (*(++portStr) != '\0') {
+            char *end = NULL;
+            int64_t ret = strtoll(portStr, &end, 10);
+            if (end == portStr || *end != '\0' || ret < 1 || ret > 0xFFFF) {
+                // invalid port details. Replace the ':'
+                *(--portStr) = ':';
+                portStr = NULL;
+            } else
+                port = (ret & 0xFFFF);
+        }
     }
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
@@ -58,11 +58,6 @@ class ClientHttpRequest
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
-#if USE_ADAPTATION
-    void *toCbdata() { return this; }
-#endif
     ClientHttpRequest(ConnStateData *csd);
     ~ClientHttpRequest();
     /* Not implemented - present to prevent synthetic operations */
@@ -196,7 +191,7 @@ class ClientHttpRequest
 #endif
 
 private:
-    CBDATA_CLASS(ClientHttpRequest);
+    CBDATA_CLASS2(ClientHttpRequest);
 };
 
 /* client http based routines */
@@ -47,6 +47,7 @@ Comm::Connection::copyDetails() const
     c->remote = remote;
     c->peerType = peerType;
     c->tos = tos;
+    c->nfmark = nfmark;
     c->flags = flags;
 
     // ensure FD is not open in the new copy.
@@ -33,6 +33,7 @@
  */
 
 #include "squid.h"
+#include "anyp/PortCfg.h"
 #include "base/TextException.h"
 #include "client_db.h"
 #include "comm/AcceptLimiter.h"
@@ -46,6 +47,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "ip/Intercept.h"
+#include "MasterXaction.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
@@ -286,8 +288,10 @@ Comm::TcpAcceptor::notify(const comm_err_t flag, const Comm::ConnectionPointer &
     if (theCallSub != NULL) {
         AsyncCall::Pointer call = theCallSub->callback();
         CommAcceptCbParams &params = GetCommParams<CommAcceptCbParams>(call);
+        params.xaction = new MasterXaction;
+        params.xaction->squidPort = static_cast<AnyP::PortCfg*>(params.data);
         params.fd = conn->fd;
-        params.conn = newConnDetails;
+        params.conn = params.xaction->tcpClient = newConnDetails;
         params.flag = flag;
         params.xerrno = errcode;
         ScheduleCallHere(call);
@@ -196,6 +196,7 @@ static ns *nameservers = NULL;
 static sp *searchpath = NULL;
 static int nns = 0;
 static int nns_alloc = 0;
+static int nns_mdns_count = 0;
 static int npc = 0;
 static int npc_alloc = 0;
 static int ndots = 1;
@@ -276,16 +277,21 @@ idnsCheckMDNS(idns_query *q)
 static void
 idnsAddMDNSNameservers()
 {
-#define MDNS_RESOLVER_COUNT 2
+    nns_mdns_count=0;
 
     // mDNS resolver addresses are explicit multicast group IPs
-    idnsAddNameserver("FF02::FB");
-    nameservers[nns-1].S.port(5353);
-    nameservers[nns-1].mDNSResolver = true;
+    if (Ip::EnableIpv6) {
+        idnsAddNameserver("FF02::FB");
+        nameservers[nns-1].S.port(5353);
+        nameservers[nns-1].mDNSResolver = true;
+        ++nns_mdns_count;
+    }
 
     idnsAddNameserver("224.0.0.251");
     nameservers[nns-1].S.port(5353);
     nameservers[nns-1].mDNSResolver = true;
+
+    ++nns_mdns_count;
 }
 
 static void
@@ -956,7 +962,7 @@ idnsSendQuery(idns_query * q)
     do {
         // only use mDNS resolvers for mDNS compatible queries
         if (!q->permit_mdns)
-            nsn = MDNS_RESOLVER_COUNT + q->nsends % (nns-MDNS_RESOLVER_COUNT);
+            nsn = nns_mdns_count + q->nsends % (nns-nns_mdns_count);
         else
             nsn = q->nsends % nns;
 
@@ -1710,23 +1716,29 @@ idnsSendSlaveAAAAQuery(idns_query *master)
 void
 idnsALookup(const char *name, IDNSCB * callback, void *data)
 {
-    unsigned int i;
-    int nd = 0;
-    idns_query *q;
+    size_t nameLength = strlen(name);
+
+    // Prevent buffer overflow on q->name
+    if (nameLength > NS_MAXDNAME) {
+        debugs(23, DBG_IMPORTANT, "SECURITY ALERT: DNS name too long to perform lookup: '" << name << "'. see access.log for details.");
+        callback(data, NULL, 0, "Internal error");
+        return;
+    }
 
     if (idnsCachedLookup(name, callback, data))
         return;
 
-    q = cbdataAlloc(idns_query);
+    idns_query *q = cbdataAlloc(idns_query);
     // idns_query is POD so no constructors are called after allocation
     q->xact_id.change();
     q->query_id = idnsQueryID();
 
-    for (i = 0; i < strlen(name); ++i)
+    int nd = 0;
+    for (unsigned int i = 0; i < nameLength; ++i)
         if (name[i] == '.')
             ++nd;
 
-    if (Config.onoff.res_defnames && npc > 0 && name[strlen(name)-1] != '.') {
+    if (Config.onoff.res_defnames && npc > 0 && name[nameLength-1] != '.') {
         q->do_searchpath = 1;
     } else {
         q->do_searchpath = 0;
@@ -48,8 +48,6 @@ class ESIContext : public esiTreeParent, public ESIParserClient
 
 public:
     typedef RefCount<ESIContext> Pointer;
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
     ESIContext() :
             thisNode(NULL),
             http(NULL),
@@ -181,7 +179,7 @@ class ESIContext : public esiTreeParent, public ESIParserClient
     virtual void parserComment (const char *s);
     bool processing;
 
-    CBDATA_CLASS(ESIContext);
+    CBDATA_CLASS2(ESIContext);
 };
 
 #endif /* SQUID_ESICONTEXT_H */
@@ -35,8 +35,8 @@
 #include "base/Vector.h"
 #include "esi/CustomParser.h"
 #include "Debug.h"
-#include "Trie.h"
-#include "TrieCharTransform.h"
+#include "libTrie/Trie.h"
+#include "libTrie/TrieCharTransform.h"
 
 Trie *ESICustomParser::SearchTrie=NULL;
 
@@ -276,22 +276,6 @@ ESIStreamContext::ESIStreamContext() : finished(false), include (NULL), localbuf
 /* ESIContext */
 static ESIContext *ESIContextNew(HttpReply *, clientStreamNode *, ClientHttpRequest *);
 
-void *
-ESIContext::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESIContext));
-    CBDATA_INIT_TYPE(ESIContext);
-    ESIContext *result = cbdataAlloc(ESIContext);
-    return result;
-}
-
-void
-ESIContext::operator delete (void *address)
-{
-    ESIContext *t = static_cast<ESIContext *>(address);
-    cbdataFree(t);
-}
-
 void
 ESIContext::setError()
 {
@@ -235,22 +235,6 @@ ESIStreamContext::freeResources()
     include = NULL;
 }
 
-void *
-ESIStreamContext::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESIStreamContext));
-    CBDATA_INIT_TYPE(ESIStreamContext);
-    ESIStreamContext *result = cbdataAlloc(ESIStreamContext);
-    return result;
-}
-
-void
-ESIStreamContext::operator delete (void *address)
-{
-    ESIStreamContext *t = static_cast<ESIStreamContext *>(address);
-    cbdataFree(t);
-}
-
 ESIStreamContext *
 ESIStreamContextNew (ESIIncludePtr include)
 {
@@ -46,8 +46,6 @@ class ESIStreamContext : public RefCountable
 
 public:
     typedef RefCount<ESIStreamContext> Pointer;
-    void *operator new(size_t);
-    void operator delete(void *);
     ESIStreamContext();
     ~ESIStreamContext();
     void freeResources();
@@ -57,7 +55,7 @@ class ESIStreamContext : public RefCountable
     ESISegment::Pointer buffer;
 
 private:
-    CBDATA_CLASS(ESIStreamContext);
+    CBDATA_CLASS2(ESIStreamContext);
 };
 
 /* ESIInclude */
@@ -47,8 +47,3 @@ libesi_la_SOURCES = \
 	Var.h \
 	VarState.cc \
 	VarState.h
-
-INCLUDES += \
-	-I$(top_srcdir)/lib/libTrie/include \
-	-I$(top_builddir)/lib/libTrie/include
-
@@ -33,7 +33,7 @@
 #define SQUID_ESIVARSTATE_H
 
 #include "esi/Segment.h"
-#include "Trie.h"
+#include "libTrie/Trie.h"
 #include "base/Vector.h"
 #include "HttpHeader.h"
 
@@ -63,9 +63,6 @@ struct arpreq {
 #include <Iphlpapi.h>
 #endif
 
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
 #if HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
@@ -44,6 +44,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "comm/Connection.h"
+#include "ConfigParser.h"
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
 #include "fde.h"
@@ -330,14 +331,16 @@ parse_externalAclHelper(external_acl ** list)
     a->local_addr.setLocalhost();
     a->quote = external_acl::QUOTE_METHOD_URL;
 
-    token = strtok(NULL, w_space);
+    token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
 
     a->name = xstrdup(token);
 
-    token = strtok(NULL, w_space);
+    // Allow supported %macros inside quoted tokens
+    ConfigParser::EnableMacros();
+    token = ConfigParser::NextToken();
 
     /* Parse options */
     while (token) {
@@ -386,8 +389,9 @@ parse_externalAclHelper(external_acl ** list)
             break;
         }
 
-        token = strtok(NULL, w_space);
+        token = ConfigParser::NextToken();
     }
+    ConfigParser::DisableMacros();
 
     /* check that child startup value is sane. */
     if (a->children.n_startup > a->children.n_max)
@@ -503,7 +507,7 @@ parse_externalAclHelper(external_acl ** list)
 
         *p = format;
         p = &format->next;
-        token = strtok(NULL, w_space);
+        token = ConfigParser::NextToken();
     }
 
     /* There must be at least one format token */
@@ -37,9 +37,6 @@
 #if HAVE_STDIO_H
 #include <stdio.h>
 #endif
-#if HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
 
 static void
 fatal_common(const char *message)
@@ -42,7 +42,7 @@
 
 // Solaris and possibly others lack MSG_NOSIGNAL optimization
 // TODO: move this into compat/? Use a dedicated compat file to avoid dragging
-// sys/types.h and sys/socket.h into the rest of Squid??
+// sys/socket.h into the rest of Squid??
 #ifndef MSG_NOSIGNAL
 #define MSG_NOSIGNAL 0
 #endif
@@ -35,6 +35,8 @@ typedef enum {
     LFT_CLIENT_LOCAL_IP,
     LFT_CLIENT_LOCAL_PORT,
     /*LFT_CLIENT_LOCAL_FQDN, (rDNS) */
+    LFT_CLIENT_LOCAL_TOS,
+    LFT_CLIENT_LOCAL_NFMARK,
 
     /* client connection local squid.conf details */
     LFT_LOCAL_LISTENING_IP,
@@ -50,6 +52,8 @@ typedef enum {
     LFT_SERVER_LOCAL_IP,
     LFT_SERVER_LOCAL_IP_OLD_27,
     LFT_SERVER_LOCAL_PORT,
+    LFT_SERVER_LOCAL_TOS,
+    LFT_SERVER_LOCAL_NFMARK,
 
     /* original Request-Line details recieved from client */
     LFT_CLIENT_REQ_METHOD,
@@ -1,4 +1,5 @@
 #include "squid.h"
+#include "ConfigParser.h"
 #include "cache_cf.h"
 #include "Debug.h"
 #include "format/Config.h"
@@ -11,10 +12,10 @@ Format::FmtConfig::parseFormats()
 {
     char *name, *def;
 
-    if ((name = strtok(NULL, w_space)) == NULL)
+    if ((name = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
-    if ((def = strtok(NULL, "\r\n")) == NULL) {
+    if ((def = ConfigParser::NextQuotedOrToEol()) == NULL) {
         self_destruct();
         return;
     }
@@ -401,6 +401,20 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             }
             break;
 
+        case LFT_CLIENT_LOCAL_TOS:
+            if (al->tcpClient != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", (uint32_t)al->tcpClient->tos);
+                out = tmp;
+            }
+            break;
+
+        case LFT_CLIENT_LOCAL_NFMARK:
+            if (al->tcpClient != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", al->tcpClient->nfmark);
+                out = tmp;
+            }
+            break;
+
         case LFT_LOCAL_LISTENING_PORT:
             if (al->cache.port) {
                 outint = al->cache.port->s.port();
@@ -430,6 +444,20 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
             break;
 
+        case LFT_SERVER_LOCAL_TOS:
+            if (al->hier.tcpServer != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", (uint32_t)al->hier.tcpServer->tos);
+                out = tmp;
+            }
+            break;
+
+        case LFT_SERVER_LOCAL_NFMARK:
+            if (al->hier.tcpServer != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", al->hier.tcpServer->nfmark);
+                out = tmp;
+            }
+            break;
+
         case LFT_TIME_SECONDS_SINCE_EPOCH:
             // some platforms store time in 32-bit, some 64-bit...
             outoff = static_cast<int64_t>(current_time.tv_sec);
@@ -1046,6 +1074,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             }
             break;
 #endif
+
         case LFT_NOTE:
             if (fmt->data.string) {
 #if USE_ADAPTATION
@@ -2,6 +2,7 @@
 #define _SQUID_FORMAT_FORMAT_H
 
 #include "base/RefCount.h"
+#include "ConfigParser.h"
 /*
  * Squid configuration allows users to define custom formats in
  * several components.
@@ -29,7 +30,7 @@ class Format
 {
 public:
     Format(const char *name);
-    ~Format();
+    virtual ~Format();
 
     /* very inefficent parser, but who cares, this needs to be simple */
     /* First off, let's tokenize, we'll optimize in a second pass.
@@ -46,7 +46,6 @@ static TokenTableEntry TokenTable2C[] = {
     {"<la", LFT_SERVER_LOCAL_IP},
     {"oa", LFT_SERVER_LOCAL_IP_OLD_27},
     {"<lp", LFT_SERVER_LOCAL_PORT},
-    /* {"ot", LFT_PEER_OUTGOING_TOS}, */
 
     {"ts", LFT_TIME_SECONDS_SINCE_EPOCH},
     {"tu", LFT_TIME_SUBSECOND},
@@ -122,6 +121,10 @@ static TokenTableEntry TokenTable2C[] = {
 /// Miscellaneous >2 byte tokens
 static TokenTableEntry TokenTableMisc[] = {
     {">eui", LFT_CLIENT_EUI},
+    {">qos", LFT_CLIENT_LOCAL_TOS},
+    {"<qos", LFT_SERVER_LOCAL_TOS},
+    {">nfmark", LFT_CLIENT_LOCAL_NFMARK},
+    {"<nfmark", LFT_SERVER_LOCAL_NFMARK},
     {"err_code", LFT_SQUID_ERROR },
     {"err_detail", LFT_SQUID_ERROR_DETAIL },
     {"note", LFT_NOTE },
@@ -107,14 +107,12 @@ class CossRead : public ReadRequest
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     CossRead(ReadRequest const &base, StoreIOState::Pointer anSio) : ReadRequest(base) , sio(anSio) {}
 
     StoreIOState::Pointer sio;
 
 private:
-    CBDATA_CLASS(CossRead);
+    CBDATA_CLASS2(CossRead);
 };
 
 #include "DiskIO/WriteRequest.h"
@@ -124,14 +122,12 @@ class CossWrite : public WriteRequest
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     CossWrite(WriteRequest const &base, CossMemBuf *aBuf) : WriteRequest(base) , membuf(aBuf) {}
 
     CossMemBuf *membuf;
 
 private:
-    CBDATA_CLASS(CossWrite);
+    CBDATA_CLASS2(CossWrite);
 };
 
 #endif
@@ -396,34 +396,7 @@ CossSwapDir::storeCossFilenoToMembuf(sfileno f)
 /*  === STATIC =========================================================== */
 
 CBDATA_CLASS_INIT(CossRead);
-void *
-CossRead::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(CossRead);
-    CossRead *result = cbdataAlloc(CossRead);
-    return result;
-}
-
-void
-CossRead::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
 CBDATA_CLASS_INIT(CossWrite);
-void *
-CossWrite::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(CossWrite);
-    CossWrite *result = cbdataAlloc(CossWrite);
-    return result;
-}
-
-void
-CossWrite::operator delete (void *address)
-{
-    cbdataFree(address);
-}
 
 void
 CossState::doCallback(int errflag)
@@ -45,19 +45,6 @@
 
 CBDATA_NAMESPACED_CLASS_INIT(Fs::Ufs,UFSStoreState);
 
-void *
-Fs::Ufs::UFSStoreState::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(UFSStoreState);
-    return cbdataAlloc(UFSStoreState);
-}
-
-void
-Fs::Ufs::UFSStoreState::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
 void
 Fs::Ufs::UFSStoreState::ioCompletedNotification()
 {
@@ -42,8 +42,6 @@ namespace Ufs
 class UFSStoreState : public StoreIOState, public IORequestor
 {
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB * callback_, void *callback_data_);
     ~UFSStoreState();
     virtual void close(int how);
@@ -118,7 +116,7 @@ class UFSStoreState : public StoreIOState, public IORequestor
     void openDone();
     void freePending();
     void doWrite();
-    CBDATA_CLASS(UFSStoreState);
+    CBDATA_CLASS2(UFSStoreState);
 };
 
 MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_read);
@@ -182,12 +182,7 @@ class FtpChannel
 /// \ingroup ServerProtocolFTPInternal
 class FtpStateData : public ServerStateData
 {
-
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
-    void *toCbdata() { return this; }
-
     FtpStateData(FwdState *, const Comm::ConnectionPointer &conn);
     ~FtpStateData();
     char user[MAX_URL];
@@ -238,9 +233,6 @@ class FtpStateData : public ServerStateData
 
     struct _ftp_flags flags;
 
-private:
-    CBDATA_CLASS(FtpStateData);
-
 public:
     // these should all be private
     virtual void start();
@@ -309,25 +301,12 @@ class FtpStateData : public ServerStateData
 private:
     // BodyConsumer for HTTP: consume request body.
     virtual void handleRequestBodyProducerAborted();
+
+    CBDATA_CLASS2(FtpStateData);
 };
 
 CBDATA_CLASS_INIT(FtpStateData);
 
-void *
-FtpStateData::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(FtpStateData);
-    FtpStateData *result = cbdataAlloc(FtpStateData);
-    return result;
-}
-
-void
-FtpStateData::operator delete (void *address)
-{
-    FtpStateData *t = static_cast<FtpStateData *>(address);
-    cbdataFree(t);
-}
-
 /// \ingroup ServerProtocolFTPInternal
 typedef struct {
     char type;
@@ -136,6 +136,7 @@ extern int ssl_ex_index_cert_error_check;	/* -1 */
 extern int ssl_ex_index_ssl_error_detail;      /* -1 */
 extern int ssl_ex_index_ssl_peeked_cert;      /* -1 */
 extern int ssl_ex_index_ssl_errors;   /* -1 */
+extern int ssl_ex_index_ssl_cert_chain;  /* -1 */
 
 extern const char *external_acl_message;      /* NULL */
 extern int opt_send_signal;	/* -1 */
@@ -1703,10 +1703,17 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     HttpHeaderPos pos = HttpHeaderInitPos;
     assert (hdr_out->owner == hoRequest);
 
-    /* append our IMS header */
+    /* use our IMS header if the cached entry has Last-Modified time */
     if (request->lastmod > -1)
         hdr_out->putTime(HDR_IF_MODIFIED_SINCE, request->lastmod);
 
+    // Add our own If-None-Match field if the cached entry has a strong ETag.
+    // copyOneHeaderFromClientsideRequestToUpstreamRequest() adds client ones.
+    if (request->etag.defined()) {
+        hdr_out->addEntry(new HttpHeaderEntry(HDR_IF_NONE_MATCH, NULL,
+                                              request->etag.termedBuf()));
+    }
+
     bool we_do_ranges = decideIfWeDoRanges (request);
 
     String strConnection (hdr_in->getList(HDR_CONNECTION));
@@ -406,7 +406,7 @@ Ip::Address::operator =(const struct sockaddr_storage &s)
 {
     /* some AF_* magic to tell socket types apart and what we need to do */
     if (s.ss_family == AF_INET6) {
-        memcpy(&mSocketAddr_, &s, sizeof(struct sockaddr_in));
+        memcpy(&mSocketAddr_, &s, sizeof(struct sockaddr_in6));
     } else { // convert it to our storage mapping.
         struct sockaddr_in *sin = (struct sockaddr_in*)&s;
         mSocketAddr_.sin6_port = sin->sin_port;
@@ -96,7 +96,21 @@
 /* must be before including netfilter_ipv4.h */
 #include <limits.h>
 #endif
+#include <linux/if.h>
 #include <linux/netfilter_ipv4.h>
+#if HAVE_LINUX_NETFILTER_IPV6_IP6_TABLES_H
+/* 2013-07-01: Pablo the Netfilter maintainer is rejecting patches
+ * which will enable C++ compilers to build the Netfilter public headers.
+ * We can auto-detect its presence and attempt to use in case he ever
+ * changes his mind or things get cleaned up some other way.
+ * But until then are usually forced to hard-code the getsockopt() code
+ * for IPv6 NAT lookups.
+ */
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#endif
+#if !defined(IP6T_SO_ORIGINAL_DST)
+#define IP6T_SO_ORIGINAL_DST	80	// stolen with prejudice from the above file.
+#endif
 #endif /* LINUX_NETFILTER required headers */
 
 // single global instance for access by other components.
@@ -124,22 +138,26 @@ bool
 Ip::Intercept::NetfilterInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
 #if LINUX_NETFILTER
-    struct sockaddr_in lookup;
-    socklen_t len = sizeof(struct sockaddr_in);
-    newConn->local.getSockAddr(lookup);
+    struct sockaddr_storage lookup;
+    socklen_t len = newConn->local.isIPv6() ? sizeof(sockaddr_in6) : sizeof(sockaddr_in);
+    newConn->local.getSockAddr(lookup, AF_UNSPEC);
 
     /** \par
      * Try NAT lookup for REDIRECT or DNAT targets. */
-    if ( getsockopt(newConn->fd, IPPROTO_IP, SO_ORIGINAL_DST, &lookup, &len) != 0) {
+    if ( getsockopt(newConn->fd,
+                    newConn->local.isIPv6() ? IPPROTO_IPV6 : IPPROTO_IP,
+                    newConn->local.isIPv6() ? IP6T_SO_ORIGINAL_DST : SO_ORIGINAL_DST,
+                    &lookup,
+                    &len) != 0) {
         if (!silent) {
-            debugs(89, DBG_IMPORTANT, HERE << " NF getsockopt(SO_ORIGINAL_DST) failed on " << newConn << ": " << xstrerror());
+            debugs(89, DBG_IMPORTANT, "ERROR: NF getsockopt(ORIGINAL_DST) failed on " << newConn << ": " << xstrerror());
             lastReported_ = squid_curtime;
         }
-        debugs(89, 9, HERE << "address: " << newConn);
+        debugs(89, 9, "address: " << newConn);
         return false;
     } else {
         newConn->local = lookup;
-        debugs(89, 5, HERE << "address NAT: " << newConn);
+        debugs(89, 5, "address NAT: " << newConn);
         return true;
     }
 #endif
@@ -359,10 +377,6 @@ Ip::Intercept::Lookup(const Comm::ConnectionPointer &newConn, const Comm::Connec
         if (TproxyTransparent(newConn, silent)) return true;
     }
 
-    /* NAT is only available in IPv4 */
-    if ( !newConn->local.isIPv4()  ) return false;
-    if ( !newConn->remote.isIPv4() ) return false;
-
     if (interceptActive_ && listenConn->flags&COMM_INTERCEPTION) {
         /* NAT methods that use sock-opts to return client address */
         if (NetfilterInterception(newConn, silent)) return true;
@@ -14,6 +14,8 @@ Ip::Qos::setSockTos(const Comm::ConnectionPointer &conn, tos_t tos)
     int x = setsockopt(conn->fd, IPPROTO_IP, IP_TOS, &bTos, sizeof(bTos));
     if (x < 0)
         debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IP_TOS) on " << conn << ": " << xstrerror());
+    else
+        conn->tos = tos;
     return x;
 #else
     debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(IP_TOS) not supported on this platform");
@@ -28,6 +30,8 @@ Ip::Qos::setSockNfmark(const Comm::ConnectionPointer &conn, nfmark_t mark)
     int x = setsockopt(conn->fd, SOL_SOCKET, SO_MARK, &mark, sizeof(nfmark_t));
     if (x < 0)
         debugs(50, 2, "setSockNfmark: setsockopt(SO_MARK) on " << conn << ": " << xstrerror());
+    else
+        conn->nfmark = mark;
     return x;
 #elif USE_LIBCAP
     debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(SO_MARK) not supported on this platform");
@@ -209,7 +209,7 @@ Ip::Qos::Config::parseConfigLine()
     self_destruct();
 #endif
 
-    while ( (token = strtok(NULL, w_space)) ) {
+    while ( (token = ConfigParser::NextToken()) ) {
 
         // Work out TOS or mark. Default to TOS for backwards compatibility
         if (!(mark || tos)) {
@@ -1,5 +1,6 @@
 #include "squid.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "log/Config.h"
 
@@ -10,18 +11,20 @@ Log::LogConfig::parseFormats()
 {
     char *name, *def;
 
-    if ((name = strtok(NULL, w_space)) == NULL)
+    if ((name = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
-    if ((def = strtok(NULL, "\r\n")) == NULL) {
+    ::Format::Format *nlf = new ::Format::Format(name);
+
+    ConfigParser::EnableMacros();
+    if ((def = ConfigParser::NextQuotedOrToEol()) == NULL) {
         self_destruct();
         return;
     }
+    ConfigParser::DisableMacros();
 
     debugs(3, 2, "Log Format for '" << name << "' is '" << def << "'");
 
-    ::Format::Format *nlf = new ::Format::Format(name);
-
     if (!nlf->parse(def)) {
         self_destruct();
         return;
@@ -121,21 +121,6 @@ peerDigestClean(PeerDigest * pd)
 
 CBDATA_CLASS_INIT(PeerDigest);
 
-void *
-PeerDigest::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(PeerDigest);
-    PeerDigest *result = cbdataAlloc(PeerDigest);
-    return result;
-}
-
-void
-PeerDigest::operator delete (void *address)
-{
-    PeerDigest *t = static_cast<PeerDigest *>(address);
-    cbdataFree(t);
-}
-
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
 peerDigestCreate(CachePeer * p)
@@ -71,7 +71,6 @@ static const char *DirectStr[] = {
 static void peerSelectFoo(ps_state *);
 static void peerPingTimeout(void *data);
 static IRCB peerHandlePingReply;
-static void peerSelectStateFree(ps_state * psstate);
 static void peerIcpParentMiss(CachePeer *, icp_common_t *, ps_state *);
 #if USE_HTCP
 static void peerHtcpParentMiss(CachePeer *, HtcpReplyData *, ps_state *);
@@ -89,34 +88,31 @@ static void peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails
 
 CBDATA_CLASS_INIT(ps_state);
 
-static void
-peerSelectStateFree(ps_state * psstate)
+ps_state::~ps_state()
 {
-    if (psstate->entry) {
-        debugs(44, 3, HERE << psstate->entry->url());
+    if (entry) {
+        debugs(44, 3, entry->url());
 
-        if (psstate->entry->ping_status == PING_WAITING)
-            eventDelete(peerPingTimeout, psstate);
+        if (entry->ping_status == PING_WAITING)
+            eventDelete(peerPingTimeout, this);
 
-        psstate->entry->ping_status = PING_DONE;
+        entry->ping_status = PING_DONE;
     }
 
-    if (psstate->acl_checklist) {
-        debugs(44, DBG_IMPORTANT, "calling aclChecklistFree() from peerSelectStateFree");
-        delete (psstate->acl_checklist);
+    if (acl_checklist) {
+        debugs(44, DBG_IMPORTANT, "calling aclChecklistFree() from ps_state destructor");
+        delete acl_checklist;
     }
 
-    HTTPMSGUNLOCK(psstate->request);
+    HTTPMSGUNLOCK(request);
 
-    if (psstate->entry) {
-        assert(psstate->entry->ping_status != PING_WAITING);
-        psstate->entry->unlock();
-        psstate->entry = NULL;
+    if (entry) {
+        assert(entry->ping_status != PING_WAITING);
+        entry->unlock();
+        entry = NULL;
     }
 
-    delete psstate->lastError;
-
-    cbdataFree(psstate);
+    delete lastError;
 }
 
 static int
@@ -313,7 +309,7 @@ peerSelectDnsPaths(ps_state *psstate)
         psstate->lastError = NULL; // FwdState has taken control over the ErrorState object.
     }
 
-    peerSelectStateFree(psstate);
+    delete psstate;
 }
 
 static void
@@ -753,7 +749,7 @@ peerPingTimeout(void *data)
         /* request aborted */
         entry->ping_status = PING_DONE;
         cbdataReferenceDone(psstate->callback_data);
-        peerSelectStateFree(psstate);
+        delete psstate;
         return;
     }
 
@@ -943,13 +939,6 @@ peerAddFwdServer(FwdServer ** FSVR, CachePeer * p, hier_code code)
     *FSVR = fs;
 }
 
-void *
-ps_state::operator new(size_t)
-{
-    CBDATA_INIT_TYPE(ps_state);
-    return cbdataAlloc(ps_state);
-}
-
 ps_state::ps_state() : request (NULL),
         entry (NULL),
         always_direct(Config.accessList.AlwaysDirect?ACCESS_DUNNO:ACCESS_DENIED),
@@ -116,8 +116,12 @@ redirectHandleReply(void *data, const HelperReply &reply)
                 const Http::StatusCode status = static_cast<Http::StatusCode>(atoi(result));
 
                 HelperReply newReply;
-                newReply.result = reply.result;
-                newReply.notes = reply.notes;
+                // BACKWARD COMPATIBILITY 2012-06-15:
+                // We got HelperReply::Unknown reply result but new
+                // redirectStateData handlers require HelperReply::Okay,
+                // else will drop the helper reply
+                newReply.result = HelperReply::Okay;
+                newReply.notes.append(&reply.notes);
 
                 if (status == Http::scMovedPermanently
                         || status == Http::scMovedTemporarily
@@ -1,5 +1,6 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
+#include "globals.h"
 #include "helper.h"
 #include "ssl/support.h"
 #include "ssl/cert_validate_message.h"
@@ -10,7 +11,11 @@ Ssl::CertValidationMsg::composeRequest(CertValidationRequest const &vcert)
 {
     body.clear();
     body += Ssl::CertValidationMsg::param_host + "=" + vcert.domainName;
-    STACK_OF(X509) *peerCerts = SSL_get_peer_cert_chain(vcert.ssl);
+    STACK_OF(X509) *peerCerts = static_cast<STACK_OF(X509) *>(SSL_get_ex_data(vcert.ssl, ssl_ex_index_ssl_cert_chain));
+
+    if (!peerCerts)
+        peerCerts = SSL_get_peer_cert_chain(vcert.ssl);
+
     if (peerCerts) {
         Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
         for (int i = 0; i < sk_X509_num(peerCerts); ++i) {
@@ -167,7 +167,11 @@ void Ssl::CertificateDb::sq_TXT_DB_delete(TXT_DB *db, const char **row)
 
 #if SQUID_SSLTXTDB_PSTRINGDATA
     for (int i = 0; i < sk_OPENSSL_PSTRING_num(db->data); ++i) {
+#if SQUID_STACKOF_PSTRINGDATA_HACK
+        const char ** current_row = ((const char **)sk_value(CHECKED_STACK_OF(OPENSSL_PSTRING, db->data), i));
+#else
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db->data, i));
+#endif
 #else
     for (int i = 0; i < sk_num(db->data); ++i) {
         const char ** current_row = ((const char **)sk_value(db->data, i));
@@ -180,8 +184,7 @@ void Ssl::CertificateDb::sq_TXT_DB_delete(TXT_DB *db, const char **row)
 }
 
 #define countof(arr) (sizeof(arr)/sizeof(*arr))
-void Ssl::CertificateDb::sq_TXT_DB_delete_row(TXT_DB *db, int idx)
-{
+void Ssl::CertificateDb::sq_TXT_DB_delete_row(TXT_DB *db, int idx) {
     char **rrow;
 #if SQUID_SSLTXTDB_PSTRINGDATA
     rrow = (char **)sk_OPENSSL_PSTRING_delete(db->data, idx);
@@ -209,29 +212,25 @@ void Ssl::CertificateDb::sq_TXT_DB_delete_row(TXT_DB *db, int idx)
     }
 }
 
-unsigned long Ssl::CertificateDb::index_serial_hash(const char **a)
-{
+unsigned long Ssl::CertificateDb::index_serial_hash(const char **a) {
     const char *n = a[Ssl::CertificateDb::cnlSerial];
     while (*n == '0')
         ++n;
     return lh_strhash(n);
 }
 
-int Ssl::CertificateDb::index_serial_cmp(const char **a, const char **b)
-{
+int Ssl::CertificateDb::index_serial_cmp(const char **a, const char **b) {
     const char *aa, *bb;
     for (aa = a[Ssl::CertificateDb::cnlSerial]; *aa == '0'; ++aa);
     for (bb = b[Ssl::CertificateDb::cnlSerial]; *bb == '0'; ++bb);
     return strcmp(aa, bb);
 }
 
-unsigned long Ssl::CertificateDb::index_name_hash(const char **a)
-{
+unsigned long Ssl::CertificateDb::index_name_hash(const char **a) {
     return(lh_strhash(a[Ssl::CertificateDb::cnlName]));
 }
 
-int Ssl::CertificateDb::index_name_cmp(const char **a, const char **b)
-{
+int Ssl::CertificateDb::index_name_cmp(const char **a, const char **b) {
     return(strcmp(a[Ssl::CertificateDb::cnlName], b[CertificateDb::cnlName]));
 }
 
@@ -248,23 +247,20 @@ Ssl::CertificateDb::CertificateDb(std::string const & aDb_path, size_t aMax_db_s
         max_db_size(aMax_db_size),
         fs_block_size(aFs_block_size),
         dbLock(db_full),
-        enabled_disk_store(true)
-{
+        enabled_disk_store(true) {
     if (db_path.empty() && !max_db_size)
         enabled_disk_store = false;
     else if ((db_path.empty() && max_db_size) || (!db_path.empty() && !max_db_size))
         throw std::runtime_error("ssl_crtd is missing the required parameter. There should be -s and -M parameters together.");
 }
 
-bool Ssl::CertificateDb::find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey)
-{
+bool Ssl::CertificateDb::find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
     const Locker locker(dbLock, Here);
     load();
     return pure_find(host_name, cert, pkey);
 }
 
-bool Ssl::CertificateDb::purgeCert(std::string const & key)
-{
+bool Ssl::CertificateDb::purgeCert(std::string const & key) {
     const Locker locker(dbLock, Here);
     load();
     if (!db)
@@ -277,8 +273,7 @@ bool Ssl::CertificateDb::purgeCert(std::string const & key)
     return true;
 }
 
-bool Ssl::CertificateDb::addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName)
-{
+bool Ssl::CertificateDb::addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName) {
     const Locker locker(dbLock, Here);
     load();
     if (!db || !cert || !pkey)
@@ -363,8 +358,7 @@ bool Ssl::CertificateDb::addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP
     return true;
 }
 
-void Ssl::CertificateDb::create(std::string const & db_path)
-{
+void Ssl::CertificateDb::create(std::string const & db_path) {
     if (db_path == "")
         throw std::runtime_error("Path to db is empty");
     std::string db_full(db_path + "/" + db_file);
@@ -387,14 +381,12 @@ void Ssl::CertificateDb::create(std::string const & db_path)
         throw std::runtime_error("Cannot open " + db_full + " to open");
 }
 
-void Ssl::CertificateDb::check(std::string const & db_path, size_t max_db_size)
-{
+void Ssl::CertificateDb::check(std::string const & db_path, size_t max_db_size) {
     CertificateDb db(db_path, max_db_size, 0);
     db.load();
 }
 
-bool Ssl::CertificateDb::pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey)
-{
+bool Ssl::CertificateDb::pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
     if (!db)
         return false;
 
@@ -416,23 +408,19 @@ bool Ssl::CertificateDb::pure_find(std::string const & host_name, Ssl::X509_Poin
     return true;
 }
 
-size_t Ssl::CertificateDb::size() const
-{
+size_t Ssl::CertificateDb::size() const {
     return readSize();
 }
 
-void Ssl::CertificateDb::addSize(std::string const & filename)
-{
+void Ssl::CertificateDb::addSize(std::string const & filename) {
     writeSize(readSize() + getFileSize(filename));
 }
 
-void Ssl::CertificateDb::subSize(std::string const & filename)
-{
+void Ssl::CertificateDb::subSize(std::string const & filename) {
     writeSize(readSize() - getFileSize(filename));
 }
 
-size_t Ssl::CertificateDb::readSize() const
-{
+size_t Ssl::CertificateDb::readSize() const {
     std::ifstream ifstr(size_full.c_str());
     if (!ifstr && enabled_disk_store)
         throw std::runtime_error("cannot open for reading: " + size_full);
@@ -442,24 +430,21 @@ size_t Ssl::CertificateDb::readSize() const
     return db_size;
 }
 
-void Ssl::CertificateDb::writeSize(size_t db_size)
-{
+void Ssl::CertificateDb::writeSize(size_t db_size) {
     std::ofstream ofstr(size_full.c_str());
     if (!ofstr && enabled_disk_store)
         throw std::runtime_error("cannot write \"" + size_full + "\" file");
     ofstr << db_size;
 }
 
-size_t Ssl::CertificateDb::getFileSize(std::string const & filename)
-{
+size_t Ssl::CertificateDb::getFileSize(std::string const & filename) {
     std::ifstream file(filename.c_str(), std::ios::binary);
     file.seekg(0, std::ios_base::end);
     size_t file_size = file.tellg();
     return ((file_size + fs_block_size - 1) / fs_block_size) * fs_block_size;
 }
 
-void Ssl::CertificateDb::load()
-{
+void Ssl::CertificateDb::load() {
     // Load db from file.
     Ssl::BIO_Pointer in(BIO_new(BIO_s_file()));
     if (!in || BIO_read_filename(in.get(), db_full.c_str()) <= 0)
@@ -483,8 +468,7 @@ void Ssl::CertificateDb::load()
     db.reset(temp_db.release());
 }
 
-void Ssl::CertificateDb::save()
-{
+void Ssl::CertificateDb::save() {
     if (!db)
         throw std::runtime_error("The certificates database is not loaded");;
 
@@ -498,8 +482,7 @@ void Ssl::CertificateDb::save()
 }
 
 // Normally defined in defines.h file
-void Ssl::CertificateDb::deleteRow(const char **row, int rowIndex)
-{
+void Ssl::CertificateDb::deleteRow(const char **row, int rowIndex) {
     const std::string filename(cert_full + "/" + row[cnlSerial] + ".pem");
     sq_TXT_DB_delete_row(db.get(), rowIndex);
 
@@ -509,15 +492,18 @@ void Ssl::CertificateDb::deleteRow(const char **row, int rowIndex)
         throw std::runtime_error("Failed to remove certficate file " + filename + " from db");
 }
 
-bool Ssl::CertificateDb::deleteInvalidCertificate()
-{
+bool Ssl::CertificateDb::deleteInvalidCertificate() {
     if (!db)
         return false;
 
     bool removed_one = false;
 #if SQUID_SSLTXTDB_PSTRINGDATA
     for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
+#if SQUID_STACKOF_PSTRINGDATA_HACK
+        const char ** current_row = ((const char **)sk_value(CHECKED_STACK_OF(OPENSSL_PSTRING, db.get()->data), i));
+#else
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
+#endif
 #else
     for (int i = 0; i < sk_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_value(db.get()->data, i));
@@ -535,8 +521,7 @@ bool Ssl::CertificateDb::deleteInvalidCertificate()
     return true;
 }
 
-bool Ssl::CertificateDb::deleteOldestCertificate()
-{
+bool Ssl::CertificateDb::deleteOldestCertificate() {
     if (!db)
         return false;
 
@@ -548,7 +533,11 @@ bool Ssl::CertificateDb::deleteOldestCertificate()
         return false;
 
 #if SQUID_SSLTXTDB_PSTRINGDATA
+#if SQUID_STACKOF_PSTRINGDATA_HACK
+    const char **row = ((const char **)sk_value(CHECKED_STACK_OF(OPENSSL_PSTRING, db.get()->data), 0));
+#else
     const char **row = (const char **)sk_OPENSSL_PSTRING_value(db.get()->data, 0);
+#endif
 #else
     const char **row = (const char **)sk_value(db.get()->data, 0);
 #endif
@@ -558,14 +547,17 @@ bool Ssl::CertificateDb::deleteOldestCertificate()
     return true;
 }
 
-bool Ssl::CertificateDb::deleteByHostname(std::string const & host)
-{
+bool Ssl::CertificateDb::deleteByHostname(std::string const & host) {
     if (!db)
         return false;
 
 #if SQUID_SSLTXTDB_PSTRINGDATA
     for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
+#if SQUID_STACKOF_PSTRINGDATA_HACK
+        const char ** current_row = ((const char **)sk_value(CHECKED_STACK_OF(OPENSSL_PSTRING, db.get()->data), i));
+#else
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
+#endif
 #else
     for (int i = 0; i < sk_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_value(db.get()->data, i));
@@ -578,7 +570,6 @@ bool Ssl::CertificateDb::deleteByHostname(std::string const & host)
     return false;
 }
 
-bool Ssl::CertificateDb::IsEnabledDiskStore() const
-{
+bool Ssl::CertificateDb::IsEnabledDiskStore() const {
     return enabled_disk_store;
 }
@@ -26,10 +26,10 @@ namespace Ssl
  because they are used by ssl_crtd.
  */
 
-#if OPENSSL_VERSION_NUMBER < 0x00909000L
-typedef SSL_METHOD * ContextMethod;
-#else
+#if SQUID_USE_CONST_SSL_METHOD
 typedef const SSL_METHOD * ContextMethod;
+#else
+typedef SSL_METHOD * ContextMethod;
 #endif
 
 /**
@@ -242,7 +242,8 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
     if (ok) {
         debugs(83, 5, "SSL Certificate signature OK: " << buffer);
 
-        if (server) {
+        // Check for domain mismatch only if the current certificate is the peer certificate.
+        if (server && peer_cert == X509_STORE_CTX_get_current_cert(ctx)) {
             if (!Ssl::checkX509ServerValidity(peer_cert, server)) {
                 debugs(83, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " << buffer << " does not match domainname " << server);
                 ok = 0;
@@ -298,8 +299,15 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
         }
         // If the certificate validator is used then we need to allow all errors and
         // pass them to certficate validator for more processing
-        else if (Ssl::TheConfig.ssl_crt_validator)
+        else if (Ssl::TheConfig.ssl_crt_validator) {
             ok = 1;
+            // Check if we have stored certificates chain. Store if not.
+            if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
+                STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
+                if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
+                    sk_X509_pop_free(certStack, X509_free);
+            }
+        }
     }
 
     if (!dont_verify_domain && server) {}
@@ -643,6 +651,17 @@ ssl_free_SslErrors(void *, void *ptr, CRYPTO_EX_DATA *,
     delete errs;
 }
 
+/// \ingroup ServerProtocolSSLInternal
+/// Callback handler function to release STACK_OF(X509) "ex" data stored
+/// in an SSL object.
+static void
+ssl_free_CertChain(void *, void *ptr, CRYPTO_EX_DATA *,
+                   int, long, void *)
+{
+    STACK_OF(X509) *certsChain = static_cast <STACK_OF(X509) *>(ptr);
+    sk_X509_pop_free(certsChain,X509_free);
+}
+
 // "free" function for X509 certificates
 static void
 ssl_free_X509(void *, void *ptr, CRYPTO_EX_DATA *,
@@ -693,6 +712,7 @@ ssl_initialize(void)
     ssl_ex_index_ssl_error_detail = SSL_get_ex_new_index(0, (void *) "ssl_error_detail", NULL, NULL, &ssl_free_ErrorDetail);
     ssl_ex_index_ssl_peeked_cert  = SSL_get_ex_new_index(0, (void *) "ssl_peeked_cert", NULL, NULL, &ssl_free_X509);
     ssl_ex_index_ssl_errors =  SSL_get_ex_new_index(0, (void *) "ssl_errors", NULL, NULL, &ssl_free_SslErrors);
+    ssl_ex_index_ssl_cert_chain = SSL_get_ex_new_index(0, (void *) "ssl_cert_chain", NULL, NULL, &ssl_free_CertChain);
 }
 
 /// \ingroup ServerProtocolSSLInternal
@@ -951,12 +971,8 @@ SSL_CTX *
 sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile)
 {
     int ssl_error;
-#if OPENSSL_VERSION_NUMBER < 0x00909000L
-    SSL_METHOD *method;
-#else
-    const SSL_METHOD *method;
-#endif
-    SSL_CTX *sslContext;
+    Ssl::ContextMethod method;
+    SSL_CTX * sslContext;
     long fl = Ssl::parse_flags(flags);
 
     ssl_initialize();
@@ -1968,6 +1968,17 @@ StoreEntry::modifiedSince(HttpRequest * request) const
     }
 }
 
+bool
+StoreEntry::hasEtag(ETag &etag) const
+{
+    if (const HttpReply *reply = getReply()) {
+        etag = reply->header.getETag(HDR_ETAG);
+        if (etag.str)
+            return true;
+    }
+    return false;
+}
+
 bool
 StoreEntry::hasIfMatchEtag(const HttpRequest &request) const
 {
@@ -68,21 +68,6 @@ static void CheckQuickAbort(StoreEntry * entry);
 
 CBDATA_CLASS_INIT(store_client);
 
-void *
-store_client::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(store_client);
-    store_client *result = cbdataAlloc(store_client);
-    return result;
-}
-
-void
-store_client::operator delete (void *address)
-{
-    store_client *t = static_cast<store_client *>(address);
-    cbdataFree(t);
-}
-
 bool
 store_client::memReaderHasLowerOffset(int64_t anOffset) const
 {
@@ -48,7 +48,6 @@ void requirePathnameExists(const char *name, const char *path) STUB_NOP
 void parse_time_t(time_t * var) STUB
 char * strtokFile(void) STUB_RETVAL(NULL)
 void ConfigParser::ParseUShort(unsigned short *var) STUB
-void ConfigParser::ParseString(String*) STUB
 void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head) STUB
 void dump_acl_list(StoreEntry*, ACLList*) STUB
 YesNoNone::operator void*() const { STUB_NOP; return NULL; }
@@ -27,7 +27,6 @@ bool ClientSocketContext::multipartRangeRequest() const STUB_RETVAL(false)
 void ClientSocketContext::registerWithConn() STUB
 void ClientSocketContext::noteIoError(const int xerrno) STUB
 void ClientSocketContext::writeControlMsg(HttpControlMsg &msg) STUB
-void ClientSocketContext::operator delete(void *address) STUB
 
 void ConnStateData::readSomeData() STUB
 int ConnStateData::getAvailableBufferLength() const STUB_RETVAL(0)
@@ -6,6 +6,7 @@
 
 #include "testACLMaxUserIP.h"
 #include "auth/AclMaxUserIp.h"
+#include "ConfigParser.h"
 
 #if HAVE_STDEXCEPT
 #include <stdexcept>
@@ -29,9 +30,9 @@ void
 testACLMaxUserIP::testParseLine()
 {
     /* a config line to pass with a lead-in token to seed the parser. */
-    char * line = xstrdup("token -s 1");
+    char * line = xstrdup("-s 1");
     /* seed the parser */
-    strtok(line, w_space);
+    ConfigParser::SetCfgLine(line);
     ACLMaxUserIP anACL("max_user_ip");
     anACL.parse();
     /* we want a maximum of one, and strict to be true */
@@ -9,6 +9,7 @@
 #include "auth/UserRequest.h"
 #include "auth/Scheme.h"
 #include "auth/Config.h"
+#include "ConfigParser.h"
 #include "Mem.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testAuth );
@@ -92,6 +93,7 @@ setup_scheme(Auth::Config *scheme, char const **params, unsigned param_count)
     for (unsigned position=0; position < param_count; ++position) {
         char *param_str=xstrdup(params[position]);
         strtok(param_str, w_space);
+        ConfigParser::SetCfgLine(strtok(NULL, ""));
         scheme->parse(scheme, config.size(), param_str);
     }
 }
@@ -21,24 +21,15 @@ bool testConfigParser::doParseQuotedTest(const char *s, const char *expectInterp
 {
     char cfgline[2048];
     char cfgparam[2048];
-    snprintf(cfgline, 2048, "Config %s", s);
-
-    // Points to the start of quoted string
-    const char *tmp = strchr(cfgline, ' ');
-
-    if (tmp == NULL) {
-        fprintf(stderr, "Invalid config line: %s\n", s);
-        return false;
-    }
+    snprintf(cfgline, 2048, "%s", s);
 
     // Keep the initial value on cfgparam. The ConfigParser  methods will write on cfgline
-    strncpy(cfgparam, tmp+1, sizeof(cfgparam)-1);
+    strncpy(cfgparam, cfgline, sizeof(cfgparam)-1);
     cfgparam[sizeof(cfgparam)-1] = '\0';
 
     // Initialize parser to point to the start of quoted string
-    strtok(cfgline, w_space);
-    String unEscaped;
-    ConfigParser::ParseQuotedString(&unEscaped);
+    ConfigParser::SetCfgLine(cfgline);
+    String unEscaped = ConfigParser::NextToken();
 
     const bool interpOk = (unEscaped.cmp(expectInterp) == 0);
     if (!interpOk) {
@@ -1,5 +1,6 @@
 #define SQUID_UNIT_TEST 1
 #include "squid.h"
+#include "ConfigParser.h"
 #include "testCoss.h"
 #include "Store.h"
 #include "SwapDir.h"
@@ -91,9 +92,9 @@ testCoss::testCossCreate()
 
     char *path=xstrdup(TESTDIR);
 
-    char *config_line=xstrdup("foo 100 max-size=102400 block-size=512 IOEngine=Blocking");
+    char *config_line=xstrdup("100 max-size=102400 block-size=512 IOEngine=Blocking");
 
-    strtok(config_line, w_space);
+    ConfigParser::SetCfgLine(config_line);
 
     aStore->parse(0, path);
 
@@ -155,9 +156,9 @@ testCoss::testCossSearch()
 
     char *path=xstrdup(TESTDIR);
 
-    char *config_line=xstrdup("foo 100 max-size=102400 block-size=512 IOEngine=Blocking");
+    char *config_line=xstrdup("100 max-size=102400 block-size=512 IOEngine=Blocking");
 
-    strtok(config_line, w_space);
+    ConfigParser::SetCfgLine(config_line);
 
     aStore->parse(0, path);
 
@@ -283,8 +284,8 @@ testCoss::testDefaultEngine()
     commonInit();
 
     char *path=xstrdup(TESTDIR);
-    char *config_line=xstrdup("foo 100 max-size=102400 block-size=512");
-    strtok(config_line, w_space);
+    char *config_line=xstrdup("100 max-size=102400 block-size=512");
+    ConfigParser::SetCfgLine(config_line);
     aStore->parse(0, path);
     safe_free(path);
     safe_free(config_line);
@@ -1,6 +1,7 @@
 #define SQUID_UNIT_TEST 1
 #include "squid.h"
 
+#include "ConfigParser.h"
 #include "DiskIO/DiskIOModule.h"
 #include "fs/rock/RockSwapDir.h"
 #include "globals.h"
@@ -66,9 +67,9 @@ testRock::setUp()
 
     char *path=xstrdup(TESTDIR);
 
-    char *config_line=xstrdup("foo 10 max-size=16384");
+    char *config_line=xstrdup("10 max-size=16384");
 
-    strtok(config_line, w_space);
+    ConfigParser::SetCfgLine(config_line);
 
     store->parse(0, path);
     store_maxobjsize = 1024*1024*2;
@@ -104,11 +104,11 @@ testUfs::testUfsSearch()
 
     char *path=xstrdup(TESTDIR);
 
-    char *config_line=xstrdup("foo 100 1 1");
+    char *config_line=xstrdup("100 1 1");
 
     visible_appname_string = xstrdup(PACKAGE "/" VERSION);
 
-    strtok(config_line, w_space);
+    ConfigParser::SetCfgLine(config_line);
 
     aStore->parse(0, path);
     store_maxobjsize = 1024*1024*2;
@@ -244,8 +244,8 @@ testUfs::testUfsDefaultEngine()
     mem_policy = createRemovalPolicy(Config.replPolicy);
 
     char *path=xstrdup(TESTDIR);
-    char *config_line=xstrdup("foo 100 1 1");
-    strtok(config_line, w_space);
+    char *config_line=xstrdup("100 1 1");
+    ConfigParser::SetCfgLine(config_line);
     aStore->parse(0, path);
     safe_free(path);
     safe_free(config_line);
@@ -31,6 +31,7 @@
  */
 
 #include "squid.h"
+#include "cbdata.h"
 #include "errorpage.h"
 #include "FwdState.h"
 #include "globals.h"
@@ -54,8 +55,6 @@ class UrnState : public StoreClient
 
 public:
     void created (StoreEntry *newEntry);
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
     void start (HttpRequest *, StoreEntry *);
     char *getHost (String &urlpath);
     void setUriResFromRequest(HttpRequest *);
@@ -79,6 +78,8 @@ class UrnState : public StoreClient
 
 private:
     char *urlres;
+
+    CBDATA_CLASS2(UrnState);
 };
 
 typedef struct {
@@ -96,25 +97,9 @@ static url_entry *urnParseReply(const char *inbuf, const HttpRequestMethod&);
 static const char *const crlf = "\r\n";
 static QS url_entry_sort;
 
-CBDATA_TYPE(UrnState);
-void *
-UrnState::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (UrnState));
-    CBDATA_INIT_TYPE(UrnState);
-    return cbdataAlloc(UrnState);
-
-}
-
-void
-UrnState::operator delete (void *address)
-{
-    UrnState * tmp = (UrnState *)address;
-    cbdataFree (tmp);
-}
+CBDATA_CLASS_INIT(UrnState);
 
-UrnState::~UrnState ()
+UrnState::~UrnState()
 {
     safe_free(urlres);
 }
@@ -39,6 +39,7 @@
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "compat/strsep.h"
+#include "ConfigParser.h"
 #include "event.h"
 #include "ip/Address.h"
 #include "md5.h"
@@ -2013,7 +2014,7 @@ parse_wccp2_method(int *method)
     char *t;
 
     /* Snarf the method */
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(80, DBG_CRITICAL, "wccp2_*_method: missing setting.");
         self_destruct();
     }
@@ -2060,7 +2061,7 @@ parse_wccp2_amethod(int *method)
     char *t;
 
     /* Snarf the method */
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(80, DBG_CRITICAL, "wccp2_assignment_method: missing setting.");
         self_destruct();
     }
@@ -2116,7 +2117,7 @@ parse_wccp2_service(void *v)
     }
 
     /* Snarf the type */
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if ((t = ConfigParser::NextToken()) == NULL) {
         debugs(80, DBG_CRITICAL, "wccp2ParseServiceInfo: missing service info type (standard|dynamic)");
         self_destruct();
     }
@@ -2141,7 +2142,7 @@ parse_wccp2_service(void *v)
     memset(wccp_password, 0, sizeof(wccp_password));
     /* Handle password, if any */
 
-    if ((t = strtok(NULL, w_space)) != NULL) {
+    if ((t = ConfigParser::NextToken()) != NULL) {
         if (strncmp(t, "password=", 9) == 0) {
             security_type = WCCP2_MD5_SECURITY;
             strncpy(wccp_password, t + 9, WCCP2_PASSWORD_LEN);
@@ -2317,7 +2318,7 @@ parse_wccp2_service_info(void *v)
     }
 
     /* Next: loop until we don't have any more tokens */
-    while ((t = strtok(NULL, w_space)) != NULL) {
+    while ((t = ConfigParser::NextToken()) != NULL) {
         if (strncmp(t, "flags=", 6) == 0) {
             /* XXX eww, string pointer math */
             flags = parse_wccp2_service_flags(t + 6);
@@ -41,12 +41,6 @@
 #if HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
-#if HAVE_SYS_SELECT_H
-#include <sys/select.h>
-#endif
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
 
 void WIN32_ExceptionHandlerInit(void);
 