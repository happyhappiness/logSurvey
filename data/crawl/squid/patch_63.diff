----++++helpers/basic_auth/NCSA/basic_ncsa_auth.cc
@@ -26,60 +26,30 @@
 
 #include &quot;squid.h&quot;
 #include &quot;crypt_md5.h&quot;
-#include &quot;hash.h&quot;
 #include &quot;helpers/defines.h&quot;
 #include &quot;rfc1738.h&quot;
-#include &quot;util.h&quot;
 
-#include &lt;cerrno&gt;
-#include &lt;cstring&gt;
-#if HAVE_UNISTD_H
-#include &lt;unistd.h&gt;
-#endif
+#include &lt;unordered_map&gt;
 #if HAVE_SYS_STAT_H
 #include &lt;sys/stat.h&gt;
 #endif
 #if HAVE_CRYPT_H
 #include &lt;crypt.h&gt;
 #endif
 
-static hash_table *hash = NULL;
-static HASHFREE my_free;
-
-typedef struct _user_data {
-    /* first two items must be same as hash_link */
-    char *user;
-    struct _user_data *next;
-    char *passwd;
-} user_data;
-
-static void
-my_free(void *p)
-{
-    user_data *u = static_cast&lt;user_data*&gt;(p);
-    xfree(u-&gt;user);
-    xfree(u-&gt;passwd);
-    xfree(u);
-}
+typedef std::unordered_map&lt;std::string, std::string&gt; usermap_t;
+usermap_t usermap;
 
 static void
 read_passwd_file(const char *passwdfile)
 {
     FILE *f;
     char buf[HELPER_INPUT_BUFFER];
-    user_data *u;
     char *user;
     char *passwd;
-    if (hash != NULL) {
-        hashFreeItems(hash, my_free);
-        hashFreeMemory(hash);
-    }
-    /* initial setup */
-    hash = hash_create((HASHCMP *) strcmp, 7921, hash_string);
-    if (NULL == hash) {
-        fprintf(stderr, &quot;FATAL: Cannot create hash table\n&quot;);
-        exit(1);
-    }
+
+    usermap.clear();
+    //TODO: change to c++ streams
     f = fopen(passwdfile, &quot;r&quot;);
     if (NULL == f) {
         fprintf(stderr, &quot;FATAL: %s: %s\n&quot;, passwdfile, xstrerror());
@@ -99,10 +69,7 @@ read_passwd_file(const char *passwdfile)
         }
         passwd = strtok(NULL, &quot;:\n\r&quot;);
         if ((strlen(user) &gt; 0) &amp;&amp; passwd) {
-            u = static_cast&lt;user_data*&gt;(xmalloc(sizeof(*u)));
-            u-&gt;user = xstrdup(user);
-            u-&gt;passwd = xstrdup(passwd);
-            hash_join(hash, (hash_link *) u);
+            usermap[user] = passwd;
         }
     }
     fclose(f);
@@ -115,7 +82,6 @@ main(int argc, char **argv)
     time_t change_time = -1;
     char buf[HELPER_INPUT_BUFFER];
     char *user, *passwd, *p;
-    user_data *u;
     setbuf(stdout, NULL);
     if (argc != 2) {
         fprintf(stderr, &quot;Usage: ncsa_auth &lt;passwordfile&gt;\n&quot;);
@@ -144,47 +110,45 @@ main(int argc, char **argv)
         }
         rfc1738_unescape(user);
         rfc1738_unescape(passwd);
-        u = (user_data *) hash_lookup(hash, user);
-        if (u == NULL) {
+        const auto userpassIterator = usermap.find(user);
+        if (userpassIterator == usermap.end()) {
             SEND_ERR(&quot;No such user&quot;);
             continue;
         }
+        std::string stored_pass = userpassIterator-&gt;second;
+
         char *crypted = NULL;
 #if HAVE_CRYPT
         size_t passwordLength = strlen(passwd);
         // Bug 3831: given algorithms more secure than DES crypt() does not truncate, so we can ignore the bug 3107 length checks below
         // &#39;$1$&#39; = MD5, &#39;$2a$&#39; = Blowfish, &#39;$5$&#39; = SHA256 (Linux), &#39;$6$&#39; = SHA256 (BSD) and SHA512
-        if (passwordLength &gt; 1 &amp;&amp; u-&gt;passwd[0] == '$' &amp;&amp;
-                (crypted = crypt(passwd, u-&gt;passwd)) &amp;&amp; strcmp(u-&gt;passwd, crypted) == 0) {
+        if (passwordLength &gt; 1 &amp;&amp; stored_pass[0] == '$' &amp;&amp;
+                (crypted = crypt(passwd, stored_pass.c_str())) &amp;&amp; stored_pass == crypted) {
             SEND_OK(&quot;&quot;);
             continue;
         }
         // &#39;other&#39; prefixes indicate DES algorithm.
-        if (passwordLength &lt;= 8 &amp;&amp; (crypted = crypt(passwd, u-&gt;passwd)) &amp;&amp; (strcmp(u-&gt;passwd, crypted) == 0)) {
+        if (passwordLength &lt;= 8 &amp;&amp; (crypted = crypt(passwd, stored_pass.c_str())) &amp;&amp; stored_pass == crypted) {
             SEND_OK(&quot;&quot;);
             continue;
         }
-        if (passwordLength &gt; 8 &amp;&amp; (crypted = crypt(passwd, u-&gt;passwd)) &amp;&amp; (strcmp(u-&gt;passwd, crypted) == 0)) {
+        if (passwordLength &gt; 8 &amp;&amp; (crypted = crypt(passwd, stored_pass.c_str())) &amp;&amp; stored_pass == crypted) {
             // Bug 3107: crypt() DES functionality silently truncates long passwords.
             SEND_ERR(&quot;Password too long. Only 8 characters accepted.&quot;);
             continue;
         }
 
 #endif
-        if ( (crypted = crypt_md5(passwd, u-&gt;passwd)) &amp;&amp; strcmp(u-&gt;passwd, crypted) == 0) {
+        if ( (crypted = crypt_md5(passwd, stored_pass.c_str())) &amp;&amp; stored_pass == crypted) {
             SEND_OK(&quot;&quot;);
             continue;
         }
-        if ( (crypted = md5sum(passwd)) &amp;&amp; strcmp(u-&gt;passwd, crypted) == 0) {
+        if ( (crypted = md5sum(passwd)) &amp;&amp; stored_pass == crypted) {
             SEND_OK(&quot;&quot;);
             continue;
         }
         SEND_ERR(&quot;Wrong password&quot;);
     }
-    if (hash != NULL) {
-        hashFreeItems(hash, my_free);
-        hashFreeMemory(hash);
-    }
     exit(0);
 }
 
----++++GitHub