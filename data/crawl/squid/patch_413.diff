@@ -276,11 +276,11 @@ class ACLChecklist;
 class StoreEntry;
 
 /* Should be in 'AccessLog.h' as the driver */
-extern void accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
-extern void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
-extern void accessLogRotate(void);
-extern void accessLogClose(void);
-extern void accessLogInit(void);
-extern const char *accessLogTime(time_t);
+void accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
+void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
+void accessLogRotate(void);
+void accessLogClose(void);
+void accessLogInit(void);
+const char *accessLogTime(time_t);
 
 #endif /* SQUID_HTTPACCESSLOGENTRY_H */
@@ -78,6 +78,6 @@ class ConfigParser
     static char * strtokFile();
 };
 
-extern int parseConfigFile(const char *file_name);
+int parseConfigFile(const char *file_name);
 
 #endif /* SQUID_CONFIGPARSER_H */
@@ -59,8 +59,8 @@
 
 /* context-based debugging, the actual type is subject to change */
 typedef int Ctx;
-extern Ctx ctx_enter(const char *descr);
-extern void ctx_exit(Ctx ctx);
+Ctx ctx_enter(const char *descr);
+void ctx_exit(Ctx ctx);
 
 /* defined debug section limits */
 #define MAX_DEBUG_SECTIONS 100
@@ -141,9 +141,9 @@ inline std::ostream& operator <<(std::ostream &os, const uint8_t d)
 #define old_debug(SECTION, LEVEL)  if do_debug((SECTION), (LEVEL)) _db_print
 
 /* Legacy debug function definitions */
-extern void _db_init(const char *logfile, const char *options);
-extern void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
-extern void _db_set_syslog(const char *facility);
-extern void _db_rotate_log(void);
+void _db_init(const char *logfile, const char *options);
+void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
+void _db_set_syslog(const char *facility);
+void _db_rotate_log(void);
 
 #endif /* SQUID_DEBUG_H */
@@ -182,10 +182,10 @@ MEMPROXY_CLASS_INLINE(HttpHdrCc);
 class StatHist;
 class StoreEntry;
 
-extern void httpHdrCcInitModule(void);
-extern void httpHdrCcCleanModule(void);
-extern void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
-extern void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrCcInitModule(void);
+void httpHdrCcCleanModule(void);
+void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
+void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #if _USE_INLINE_
 #include "HttpHdrCc.cci"
@@ -69,10 +69,10 @@ class HttpHdrSc
 MEMPROXY_CLASS_INLINE(HttpHdrSc);
 
 /* Http Surrogate Control Header Field */
-extern void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
-extern void httpHdrScInitModule (void);
-extern void httpHdrScCleanModule (void);
-extern HttpHdrSc *httpHdrScParseCreate(String const &);
-extern void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
+void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrScInitModule (void);
+void httpHdrScCleanModule (void);
+HttpHdrSc *httpHdrScParseCreate(String const &);
+void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROL_H */
@@ -126,6 +126,6 @@ class HttpHdrScTarget
 
 MEMPROXY_CLASS_INLINE(HttpHdrScTarget);
 
-extern void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROLTARGET_H */
@@ -293,10 +293,10 @@ class HttpHeader
     HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
 };
 
-extern int httpHeaderParseQuotedString(const char *start, const int len, String *val);
-extern int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-extern void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
-extern void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
+int httpHeaderParseQuotedString(const char *start, const int len, String *val);
+int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
+void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
+void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
@@ -305,7 +305,7 @@ HttpHeader::chunked() const
            hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
 }
 
-extern void httpHeaderInitModule(void);
-extern void httpHeaderCleanModule(void);
+void httpHeaderInitModule(void);
+void httpHeaderCleanModule(void);
 
 #endif /* SQUID_HTTPHEADER_H */
@@ -79,14 +79,14 @@ class HttpParser
 
 // Legacy functions
 #define HttpParserInit(h,b,l) (h)->reset((b),(l))
-extern int HttpParserParseReqLine(HttpParser *hp);
+int HttpParserParseReqLine(HttpParser *hp);
 
 #define MSGDODEBUG 0
 #if MSGDODEBUG
-extern int HttpParserReqSz(HttpParser *);
-extern int HttpParserHdrSz(HttpParser *);
-extern const char * HttpParserHdrBuf(HttpParser *);
-extern int HttpParserRequestLen(HttpParser *hp);
+int HttpParserReqSz(HttpParser *);
+int HttpParserHdrSz(HttpParser *);
+const char * HttpParserHdrBuf(HttpParser *);
+int HttpParserRequestLen(HttpParser *hp);
 #else
 #define HttpParserReqSz(hp)     ( (hp)->req.end - (hp)->req.start + 1 )
 #define HttpParserHdrSz(hp)     ( (hp)->hdr_end - (hp)->hdr_start + 1 )
@@ -35,11 +35,11 @@
 #include "HttpRequest.h"
 #include "HttpStatusLine.h"
 
-extern void httpReplyInitModule(void);
+void httpReplyInitModule(void);
 
 #if DEAD_CODE
 /** do everything in one call: init, set, pack, clean, return MemBuf */
-extern MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
+MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
 #endif
 
 /* Sync changes here with HttpReply.cc */
@@ -57,7 +57,7 @@ class ConnStateData;
 
 /*  Http Request */
 //DEAD?: extern int httpRequestHdrAllowedByName(http_hdr_type id);
-extern void httpRequestPack(void *obj, Packer *p);
+void httpRequestPack(void *obj, Packer *p);
 
 class HttpHdrRange;
 class DnsLookupDetails;
@@ -132,51 +132,51 @@ extern Comm::ConnectionPointer icpOutgoingConn;
 extern Ip::Address theIcpPublicHostID;
 
 /// \ingroup ServerProtocolICPAPI
-extern HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
+HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-extern bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
+bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
+void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-extern icp_opcode icpGetCommonOpcode();
+icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN log_type icpLogFromICPCode(icp_opcode opcode);
+log_type icpLogFromICPCode(icp_opcode opcode);
 
 /// \ingroup ServerProtocolICPAPI
 void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN PF icpHandleUdp;
+PF icpHandleUdp;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN PF icpUdpSendQueue;
+PF icpUdpSendQueue;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpHandleIcpV3(int, Ip::Address &, char *, int);
+void icpHandleIcpV3(int, Ip::Address &, char *, int);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
+int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpOpenPorts(void);
+void icpOpenPorts(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionShutdown(void);
+void icpConnectionShutdown(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpClosePorts(void);
+void icpClosePorts(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpSetCacheKey(const cache_key * key);
+int icpSetCacheKey(const cache_key * key);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN const cache_key *icpGetCacheKey(const char *url, int reqnum);
+const cache_key *icpGetCacheKey(const char *url, int reqnum);
 
 #endif /* SQUID_ICP_H */
@@ -5,6 +5,6 @@
 // TODO: add reconfiguration support
 
 class wordlist;
-extern void LoadableModulesConfigure(const wordlist *names);
+void LoadableModulesConfigure(const wordlist *names);
 
 #endif /* SQUID_LOADABLE_MODULES_H */
@@ -62,21 +62,21 @@ class Mem
 
 extern const size_t squidSystemPageSize;
 
-extern void memClean(void);
-extern void memInitModule(void);
-extern void memCleanModule(void);
-extern void memConfigure(void);
-extern void *memAllocate(mem_type);
-extern void *memAllocString(size_t net_size, size_t * gross_size);
-extern void *memAllocBuf(size_t net_size, size_t * gross_size);
-extern void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
-extern void memFree(void *, int type);
-extern void memFreeString(size_t size, void *);
-extern void memFreeBuf(size_t size, void *);
-extern FREE *memFreeBufFunc(size_t size);
-extern int memInUse(mem_type);
-extern void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
-extern void memCheckInit(void);
-extern void memConfigure(void);
+void memClean(void);
+void memInitModule(void);
+void memCleanModule(void);
+void memConfigure(void);
+void *memAllocate(mem_type);
+void *memAllocString(size_t net_size, size_t * gross_size);
+void *memAllocBuf(size_t net_size, size_t * gross_size);
+void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
+void memFree(void *, int type);
+void memFreeString(size_t size, void *);
+void memFreeBuf(size_t size, void *);
+FREE *memFreeBufFunc(size_t size);
+int memInUse(mem_type);
+void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
+void memCheckInit(void);
+void memConfigure(void);
 
 #endif /* SQUID_MEM */
@@ -36,34 +36,34 @@
 
 #include "ip/Address.h"
 
-extern double xatof(const char *token);
-extern int xatoi(const char *token);
-extern long xatol(const char *token);
-extern unsigned short xatos(const char *token);
+double xatof(const char *token);
+int xatoi(const char *token);
+long xatol(const char *token);
+unsigned short xatos(const char *token);
 
 /**
  * Parse a 64-bit integer value.
  */
-extern int64_t GetInteger64(void);
+int64_t GetInteger64(void);
 
 /**
  * Parses an integer value.
  * Uses a method that obeys hexadecimal 0xN syntax needed for certain bitmasks.
  */
-extern int GetInteger(void);
+int GetInteger(void);
 
-extern unsigned short GetShort(void);
+unsigned short GetShort(void);
 
 // on success, returns true and sets *p (if any) to the end of the integer
-extern bool StringToInt(const char *str, int &result, const char **p, int base);
-extern bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
+bool StringToInt(const char *str, int &result, const char **p, int base);
+bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
 
 /**
  * Parse a socket address (host:port), fill the given Ip::Address object
  * \retval false     Failure.
  * \retval true      Success.
  * Destroys token during parse.
  */
-extern bool GetHostWithPort(char *token, Ip::Address *ipa);
+bool GetHostWithPort(char *token, Ip::Address *ipa);
 
 #endif /* SQUID_PARSING_H */
@@ -133,10 +133,10 @@ class PeerDigest
 
 extern const Version CacheDigestVer;
 
-extern PeerDigest *peerDigestCreate(CachePeer * p);
-extern void peerDigestNeeded(PeerDigest * pd);
-extern void peerDigestNotePeerGone(PeerDigest * pd);
-extern void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
+PeerDigest *peerDigestCreate(CachePeer * p);
+void peerDigestNeeded(PeerDigest * pd);
+void peerDigestNotePeerGone(PeerDigest * pd);
+void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
 
 #endif /* USE_CACHE_DIGESTS */
 
@@ -97,7 +97,7 @@ class RemovalPurgeWalker
     CBDATA_CLASS2(RemovalPurgeWalker);
 };
 
-extern RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
+RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
 
 typedef RemovalPolicy *REMOVALPOLICYCREATE(wordlist * args);
 
@@ -7,16 +7,16 @@ class Address;
 }
 
 // generic DNS API
-extern void dnsInit(void);
-extern void dnsShutdown(void);
+void dnsInit(void);
+void dnsShutdown(void);
 
 #if USE_DNSHELPER
 // external DNS helper API
-extern void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
+void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
 #else
 // internal DNS client API
-extern void idnsALookup(const char *, IDNSCB *, void *);
-extern void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
+void idnsALookup(const char *, IDNSCB *, void *);
+void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
 #endif
 
 #endif /* SQUID_DNS_H */
@@ -35,7 +35,7 @@
 namespace Ip {
   class Address;
 }
-extern pid_t ipcCreate(int type,
+pid_t ipcCreate(int type,
                              const char *prog,
                              const char *const args[],
                              const char *name,
@@ -39,7 +39,7 @@ class link_list
     link_list *next;
 };
 
-extern void linklistPush(link_list **, void *);
-extern void *linklistShift(link_list **);
+void linklistPush(link_list **, void *);
+void *linklistShift(link_list **);
 
 #endif /* SQUID_SQUIDLIST_H_ */
@@ -5,11 +5,11 @@
 namespace Math
 {
 
-extern int intPercent(const int a, const int b);
-extern int64_t int64Percent(const int64_t a, const int64_t b);
-extern double doublePercent(const double, const double);
-extern int intAverage(const int, const int, int, const int);
-extern double doubleAverage(const double, const double, int, const int);
+int intPercent(const int a, const int b);
+int64_t int64Percent(const int64_t a, const int64_t b);
+double doublePercent(const double, const double);
+int intAverage(const int, const int, int, const int);
+double doubleAverage(const double, const double, int, const int);
 
 } // namespace Math
 
@@ -183,9 +183,9 @@ _SQUID_INLINE_ bool operator<(const String &a, const String &b);
 #include "String.cci"
 #endif
 
-extern const char *checkNullString(const char *p);
-extern int stringHasWhitespace(const char *);
-extern int stringHasCntl(const char *);
-extern char *strwordtok(char *buf, char **t);
+const char *checkNullString(const char *p);
+int stringHasWhitespace(const char *);
+int stringHasCntl(const char *);
+char *strwordtok(char *buf, char **t);
 
 #endif /* SQUID_STRING_H */
@@ -125,11 +125,11 @@ class store_client
     CBDATA_CLASS(store_client);
 };
 
-extern void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
-extern store_client* storeClientListAdd(StoreEntry * e, void *data);
-extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
-extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
-extern int storePendingNClients(const StoreEntry * e);
-extern int storeClientIsThisAClient(store_client * sc, void *someClient);
+void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
+store_client* storeClientListAdd(StoreEntry * e, void *data);
+int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
+int storeUnregister(store_client * sc, StoreEntry * e, void *data);
+int storePendingNClients(const StoreEntry * e);
+int storeClientIsThisAClient(store_client * sc, void *someClient);
 
 #endif /* SQUID_STORECLIENT_H */
@@ -35,9 +35,9 @@
 
 class String;
 
-extern void strListAdd(String * str, const char *item, char del);
-extern int strListIsMember(const String * str, const char *item, char del);
-extern int strListIsSubstr(const String * list, const char *s, char del);
-extern int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
+void strListAdd(String * str, const char *item, char del);
+int strListIsMember(const String * str, const char *item, char del);
+int strListIsSubstr(const String * list, const char *s, char del);
+int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
 
 #endif /* SQUID_STRLIST_H_ */
@@ -98,25 +98,25 @@ class StoreController : public Store
 };
 
 /* migrating from the Config based list of swapdirs */
-extern void allocate_new_swapdir(SquidConfig::_cacheSwap *);
-extern void free_cachedir(SquidConfig::_cacheSwap * swap);
-SQUIDCEXTERN OBJH storeDirStats;
-SQUIDCEXTERN char *storeDirSwapLogFile(int, const char *);
-SQUIDCEXTERN char *storeSwapFullPath(int, char *);
-SQUIDCEXTERN char *storeSwapSubSubDir(int, char *);
-SQUIDCEXTERN const char *storeSwapPath(int);
-SQUIDCEXTERN int storeDirWriteCleanLogs(int reopen);
-SQUIDCEXTERN STDIRSELECT *storeDirSelectSwapDir;
-SQUIDCEXTERN int storeVerifySwapDirs(void);
-SQUIDCEXTERN void storeDirCloseSwapLogs(void);
-SQUIDCEXTERN void storeDirCloseTmpSwapLog(int dirn);
-SQUIDCEXTERN void storeDirDiskFull(sdirno);
-SQUIDCEXTERN void storeDirOpenSwapLogs(void);
-SQUIDCEXTERN void storeDirSwapLog(const StoreEntry *, int op);
-SQUIDCEXTERN void storeDirLRUDelete(StoreEntry *);
-SQUIDCEXTERN void storeDirLRUAdd(StoreEntry *);
-SQUIDCEXTERN int storeDirGetBlkSize(const char *path, int *blksize);
-SQUIDCEXTERN int storeDirGetUFSStats(const char *, int *, int *, int *, int *);
+void allocate_new_swapdir(SquidConfig::_cacheSwap *);
+void free_cachedir(SquidConfig::_cacheSwap * swap);
+extern OBJH storeDirStats;
+char *storeDirSwapLogFile(int, const char *);
+char *storeSwapFullPath(int, char *);
+char *storeSwapSubSubDir(int, char *);
+const char *storeSwapPath(int);
+int storeDirWriteCleanLogs(int reopen);
+extern STDIRSELECT *storeDirSelectSwapDir;
+int storeVerifySwapDirs(void);
+void storeDirCloseSwapLogs(void);
+void storeDirCloseTmpSwapLog(int dirn);
+void storeDirDiskFull(sdirno);
+void storeDirOpenSwapLogs(void);
+void storeDirSwapLog(const StoreEntry *, int op);
+void storeDirLRUDelete(StoreEntry *);
+void storeDirLRUAdd(StoreEntry *);
+int storeDirGetBlkSize(const char *path, int *blksize);
+int storeDirGetUFSStats(const char *, int *, int *, int *, int *);
 
 /// manages a single cache_dir
 class SwapDir : public Store
@@ -79,20 +79,20 @@ MEMPROXY_CLASS_INLINE(URL);
 class HttpRequest;
 class HttpRequestMethod;
 
-extern AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
-extern void urlInitialize(void);
-extern HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
-extern const char *urlCanonical(HttpRequest *);
-extern char *urlCanonicalClean(const HttpRequest *);
-extern const char *urlCanonicalFakeHttps(const HttpRequest * request);
-extern bool urlIsRelative(const char *);
-extern char *urlMakeAbsolute(const HttpRequest *, const char *);
-extern char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
-extern char *urlInternal(const char *dir, const char *name);
-extern int matchDomainName(const char *host, const char *domain);
-extern int urlCheckRequest(const HttpRequest *);
-extern int urlDefaultPort(AnyP::ProtocolType p);
-extern char *urlHostname(const char *url);
-extern void urlExtMethodConfigure(void);
+AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
+void urlInitialize(void);
+HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
+const char *urlCanonical(HttpRequest *);
+char *urlCanonicalClean(const HttpRequest *);
+const char *urlCanonicalFakeHttps(const HttpRequest * request);
+bool urlIsRelative(const char *);
+char *urlMakeAbsolute(const HttpRequest *, const char *);
+char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
+char *urlInternal(const char *dir, const char *name);
+int matchDomainName(const char *host, const char *domain);
+int urlCheckRequest(const HttpRequest *);
+int urlDefaultPort(AnyP::ProtocolType p);
+char *urlHostname(const char *url);
+void urlExtMethodConfigure(void);
 
 #endif /* SQUID_SRC_URL_H_H */
@@ -33,12 +33,12 @@
  */
 
 #if _SQUID_WINDOWS_
-extern int WIN32_Subsystem_Init(int *, char ***);
-extern void WIN32_sendSignal(int);
-extern void WIN32_SetServiceCommandLine(void);
-extern void WIN32_InstallService(void);
-extern void WIN32_RemoveService(void);
-extern int SquidMain(int, char **);
+int WIN32_Subsystem_Init(int *, char ***);
+void WIN32_sendSignal(int);
+void WIN32_SetServiceCommandLine(void);
+void WIN32_InstallService(void);
+void WIN32_RemoveService(void);
+int SquidMain(int, char **);
 #else /* _SQUID_WINDOWS_ */
 inline int WIN32_Subsystem_Init(int *foo, char ***bar) {return 0; } /* NOP */
 inline void WIN32_sendSignal(int foo) { return; } /* NOP */
@@ -38,13 +38,13 @@
 #include "acl/Checklist.h"
 #include "ip/Address.h"
 
-SQUIDCEXTERN int asnMatchIp(CbDataList<int> *, Ip::Address &);
+int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void asnInit(void);
+void asnInit(void);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void asnFreeMemory(void);
+void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
@@ -13,30 +13,30 @@ class StoreEntry;
 class wordlist;
 
 /// \ingroup ACLAPI
-extern void aclDestroyAccessList(acl_access **list);
+void aclDestroyAccessList(acl_access **list);
 /// \ingroup ACLAPI
-extern void aclDestroyAcls(ACL **);
+void aclDestroyAcls(ACL **);
 /// \ingroup ACLAPI
-extern void aclDestroyAclList(ACLList **);
+void aclDestroyAclList(ACLList **);
 /// \ingroup ACLAPI
-extern void aclParseAccessLine(ConfigParser &parser, acl_access **);
+void aclParseAccessLine(ConfigParser &parser, acl_access **);
 /// \ingroup ACLAPI
-extern void aclParseAclList(ConfigParser &parser, ACLList **);
+void aclParseAclList(ConfigParser &parser, ACLList **);
 /// \ingroup ACLAPI
-extern int aclIsProxyAuth(const char *name);
+int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
-extern err_type aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed);
+err_type aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed);
 /// \ingroup ACLAPI
-extern void aclParseDenyInfoLine(AclDenyInfoList **);
+void aclParseDenyInfoLine(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern void aclDestroyDenyInfoList(AclDenyInfoList **);
+void aclDestroyDenyInfoList(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern wordlist *aclDumpGeneric(const ACL *);
+wordlist *aclDumpGeneric(const ACL *);
 /// \ingroup ACLAPI
-extern void aclCacheMatchFlush(dlink_list * cache);
+void aclCacheMatchFlush(dlink_list * cache);
 /// \ingroup ACLAPI
-extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
+void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
 /// \ingroup ACLAPI
-extern void dump_acl_list(StoreEntry * entry, ACLList * head);
+void dump_acl_list(StoreEntry * entry, ACLList * head);
 
 #endif /* SQUID_ACL_GADGETS_H */
@@ -35,9 +35,9 @@ class AccessRule
 };
 
 typedef Vector<Adaptation::AccessRule*> AccessRules;
-extern AccessRules &AllRules();
-extern AccessRule *FindRule(const AccessRule::Id &id);
-extern AccessRule *FindRuleByGroupId(const String &groupId);
+AccessRules &AllRules();
+AccessRule *FindRule(const AccessRule::Id &id);
+AccessRule *FindRuleByGroupId(const String &groupId);
 
 } // namespace Adaptation
 
@@ -39,8 +39,8 @@ namespace Adaptation
 namespace Icap
 {
 
-extern void InitModule();
-extern void CleanModule();
+void InitModule();
+void CleanModule();
 
 } // namespace Icap
 } // namespace Adaptation
@@ -11,7 +11,7 @@
 
 class ACLChecklist;
 /// \ingroup AuthAPI
-extern allow_t AuthenticateAcl(ACLChecklist *ch);
+allow_t AuthenticateAcl(ACLChecklist *ch);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_ACL_H */
@@ -82,7 +82,7 @@ class StoreEntry;
 typedef void AUTHSSTATS(StoreEntry *);
 
 /// \ingroup AuthAPI
-extern void authenticateInit(Auth::ConfigVector *);
+void authenticateInit(Auth::ConfigVector *);
 
 /** \ingroup AuthAPI
  * Remove all idle authentication state. Intended for use by reconfigure.
@@ -94,19 +94,19 @@ extern void authenticateInit(Auth::ConfigVector *);
  * authentication unless something causes the global config to be rebuilt.
  * Such as a configure load action adding config and re-running authenticateInit().
  */
-extern void authenticateReset(void);
+void authenticateReset(void);
 
-extern void authenticateRotate(void);
+void authenticateRotate(void);
 
 /// \ingroup AuthAPI
-extern void authenticateFreeProxyAuthUserACLResults(void *data);
+void authenticateFreeProxyAuthUserACLResults(void *data);
 /// \ingroup AuthAPI
-extern int authenticateActiveSchemeCount(void);
+int authenticateActiveSchemeCount(void);
 /// \ingroup AuthAPI
-extern int authenticateSchemeCount(void);
+int authenticateSchemeCount(void);
 
 /// \ingroup AuthAPI
-extern void authenticateOnCloseConnection(ConnStateData * conn);
+void authenticateOnCloseConnection(ConnStateData * conn);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_GADGETS_H */
@@ -227,20 +227,20 @@ class UserRequest : public RefCountable
 /* AuthUserRequest */
 
 /// \ingroup AuthAPI
-extern void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int);
+void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int);
 /// \ingroup AuthAPI
-extern void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int);
+void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int);
 
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &);
+void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &);
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer);
+void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer);
 /// \ingroup AuthAPI
-extern int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer);
+int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer);
 
 /// \ingroup AuthAPI
 /// See Auth::UserRequest::authenticated()
-extern int authenticateUserAuthenticated(Auth::UserRequest::Pointer);
+int authenticateUserAuthenticated(Auth::UserRequest::Pointer);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTHUSERREQUEST_H */
@@ -50,12 +50,12 @@ struct _digest_nonce_h : public hash_link {
     } flags;
 };
 
-extern void authDigestNonceUnlink(digest_nonce_h * nonce);
-extern int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
-extern const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
-extern int authDigestNonceLastRequest(digest_nonce_h * nonce);
-extern void authenticateDigestNonceShutdown(void);
-extern void authDigestNoncePurge(digest_nonce_h * nonce);
+void authDigestNonceUnlink(digest_nonce_h * nonce);
+int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
+const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
+int authDigestNonceLastRequest(digest_nonce_h * nonce);
+void authenticateDigestNonceShutdown(void);
+void authDigestNoncePurge(digest_nonce_h * nonce);
 
 namespace Auth
 {
@@ -156,7 +156,7 @@ asyncCall(int aDebugSection, int aDebugLevel, const char *aName,
 }
 
 /** Call scheduling helper. Use ScheduleCallHere if you can. */
-extern bool ScheduleCall(const char *fileName, int fileLine, AsyncCall::Pointer &call);
+bool ScheduleCall(const char *fileName, int fileLine, AsyncCall::Pointer &call);
 
 /** Call scheduling helper. */
 #define ScheduleCallHere(call) ScheduleCall(__FILE__, __LINE__, (call))
@@ -71,7 +71,7 @@ class FileNameHashCacheUser
                                          (FileNameHashCached(__FILE__)<<14) | (__LINE__ & 0x3FFF))
 #endif
 
-extern void Throw(const char *message, const char *fileName, int lineNo, unsigned int id);
+void Throw(const char *message, const char *fileName, int lineNo, unsigned int id);
 
 // Must(condition) is like assert(condition) but throws an exception instead
 #if !defined(Must)
@@ -35,17 +35,17 @@
 
 class wordlist;
 
-extern void configFreeMemory(void);
-extern void self_destruct(void);
-extern void add_http_port(char *portspec);
+void configFreeMemory(void);
+void self_destruct(void);
+void add_http_port(char *portspec);
 
 /* extra functions from cache_cf.c useful for lib modules */
-extern void parse_int(int *var);
-extern void parse_onoff(int *var);
-extern void parse_eol(char *volatile *var);
-extern void parse_wordlist(wordlist ** list);
-extern void requirePathnameExists(const char *name, const char *path);
-extern void parse_time_t(time_t * var);
-extern char *strtokFile(void);
+void parse_int(int *var);
+void parse_onoff(int *var);
+void parse_eol(char *volatile *var);
+void parse_wordlist(wordlist ** list);
+void requirePathnameExists(const char *name, const char *path);
+void parse_time_t(time_t * var);
+char *strtokFile(void);
 
 #endif /* SQUID_CACHE_CF_H_ */
@@ -36,7 +36,7 @@
 class CachePeer;
 class HttpRequest;
 
-extern void carpInit(void);
-extern CachePeer *carpSelectParent(HttpRequest *);
+void carpInit(void);
+CachePeer *carpSelectParent(HttpRequest *);
 
 #endif /* SQUID_CARP_H_ */
@@ -234,30 +234,30 @@ typedef enum {
 } cbdata_type;
 
 /// \ingroup CBDATAAPI
-extern void cbdataRegisterWithCacheManager(void);
+void cbdataRegisterWithCacheManager(void);
 
 #if USE_CBDATA_DEBUG
-extern void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
-extern void *cbdataInternalFreeDbg(void *p, const char *, int);
-extern void cbdataInternalLockDbg(const void *p, const char *, int);
-extern void cbdataInternalUnlockDbg(const void *p, const char *, int);
-extern int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
+void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
+void *cbdataInternalFreeDbg(void *p, const char *, int);
+void cbdataInternalLockDbg(const void *p, const char *, int);
+void cbdataInternalUnlockDbg(const void *p, const char *, int);
+int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
 #else
 
 /// \ingroup CBDATAAPI
-extern void *cbdataInternalAlloc(cbdata_type type);
+void *cbdataInternalAlloc(cbdata_type type);
 
 /// \ingroup CBDATAAPI
-extern void *cbdataInternalFree(void *p);
+void *cbdataInternalFree(void *p);
 
 /// \ingroup CBDATAAPI
-extern void cbdataInternalLock(const void *p);
+void cbdataInternalLock(const void *p);
 
 /// \ingroup CBDATAAPI
-extern void cbdataInternalUnlock(const void *p);
+void cbdataInternalUnlock(const void *p);
 
 /// \ingroup CBDATAAPI
-extern int cbdataInternalReferenceDoneValid(void **p, void **tp);
+int cbdataInternalReferenceDoneValid(void **p, void **tp);
 
 #endif /* !CBDATA_DEBUG */
 
@@ -269,10 +269,10 @@ extern int cbdataInternalReferenceDoneValid(void **p, void **tp);
  \retval 0	A reference is stale. The pointer refers to a entry freed by cbdataFree().
  \retval true	The reference is valid and active.
  */
-extern int cbdataReferenceValid(const void *p);
+int cbdataReferenceValid(const void *p);
 
 /// \ingroup CBDATAAPI
-extern cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
+cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
 
 /* cbdata macros */
 #if USE_CBDATA_DEBUG
@@ -43,20 +43,20 @@ class Address;
 class StoreEntry;
 class ClientInfo;
 
-extern void clientdbInit(void);
-extern void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
-extern int clientdbCutoffDenied(const Ip::Address &);
-extern void clientdbDump(StoreEntry *);
-extern void clientdbFreeMemory(void);
-extern int clientdbEstablished(const Ip::Address &, int);
+void clientdbInit(void);
+void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
+int clientdbCutoffDenied(const Ip::Address &);
+void clientdbDump(StoreEntry *);
+void clientdbFreeMemory(void);
+int clientdbEstablished(const Ip::Address &, int);
 
 #if USE_DELAY_POOLS
-extern void clientdbSetWriteLimiter(ClientInfo * info, const int writeSpeedLimit,const double initialBurst,const double highWatermark);
-extern ClientInfo * clientdbGetInfo(const Ip::Address &addr);
+void clientdbSetWriteLimiter(ClientInfo * info, const int writeSpeedLimit,const double initialBurst,const double highWatermark);
+ClientInfo * clientdbGetInfo(const Ip::Address &addr);
 #endif
 
 #if SQUID_SNMP
-extern Ip::Address *client_entry(Ip::Address *current);
+Ip::Address *client_entry(Ip::Address *current);
 #endif
 
 #endif /* SQUID_CLIENT_DB_H_ */
@@ -408,19 +408,14 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     CBDATA_CLASS2(ConnStateData);
 };
 
-/* convenience class while splitting up body handling */
-/* temporary existence only - on stack use expected */
-
 void setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl = false);
 
 const char *findTrailingHTTPVersion(const char *uriAndHTTPVersion, const char *end = NULL);
 
-/* Vary support functions */
-extern int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
+int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req);
 
-/* client_side.c - FD related client side routines */
-extern void clientOpenListenSockets(void);
-extern void clientHttpConnectionsClose(void);
-extern void httpRequestFree(void *);
+void clientOpenListenSockets(void);
+void clientHttpConnectionsClose(void);
+void httpRequestFree(void *);
 
 #endif /* SQUID_CLIENTSIDE_H */
@@ -46,7 +46,7 @@ class HttpMsg;
 #endif
 
 /* client_side_request.c - client side request related routines (pure logic) */
-extern int clientBeginRequest(const HttpRequestMethod&, char const *, CSCB *, CSD *, ClientStreamData, HttpHeader const *, char *, size_t);
+int clientBeginRequest(const HttpRequestMethod&, char const *, CSCB *, CSD *, ClientStreamData, HttpHeader const *, char *, size_t);
 
 class MemObject;
 
@@ -200,16 +200,16 @@ class ClientHttpRequest
 };
 
 /* client http based routines */
-extern char *clientConstructTraceEcho(ClientHttpRequest *);
+char *clientConstructTraceEcho(ClientHttpRequest *);
 
 class ACLFilledChecklist;
-extern ACLFilledChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
-extern int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
-extern void clientAccessCheck(ClientHttpRequest *);
+ACLFilledChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
+int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
+void clientAccessCheck(ClientHttpRequest *);
 
 /* ones that should be elsewhere */
-extern void redirectStart(ClientHttpRequest *, RH *, void *);
-extern void tunnelStart(ClientHttpRequest *, int64_t *, int *);
+void redirectStart(ClientHttpRequest *, RH *, void *);
+void tunnelStart(ClientHttpRequest *, int64_t *, int *);
 
 #if _USE_INLINE_
 #include "Store.h"
@@ -12,29 +12,28 @@ namespace Ip {
 class Address;
 }
 
-/* comm.c */
-extern bool comm_iocallbackpending(void); /* inline candidate */
-
-SQUIDCEXTERN int commSetNonBlocking(int fd);
-SQUIDCEXTERN int commUnsetNonBlocking(int fd);
-SQUIDCEXTERN void commSetCloseOnExec(int fd);
-SQUIDCEXTERN void commSetTcpKeepalive(int fd, int idle, int interval, int timeout);
-extern void _comm_close(int fd, char const *file, int line);
+bool comm_iocallbackpending(void); /* inline candidate */
+
+int commSetNonBlocking(int fd);
+int commUnsetNonBlocking(int fd);
+void commSetCloseOnExec(int fd);
+void commSetTcpKeepalive(int fd, int idle, int interval, int timeout);
+void _comm_close(int fd, char const *file, int line);
 #define comm_close(x) (_comm_close((x), __FILE__, __LINE__))
-SQUIDCEXTERN void old_comm_reset_close(int fd);
-SQUIDCEXTERN void comm_reset_close(const Comm::ConnectionPointer &conn);
+void old_comm_reset_close(int fd);
+void comm_reset_close(const Comm::ConnectionPointer &conn);
 #if LINGERING_CLOSE
-SQUIDCEXTERN void comm_lingering_close(int fd);
+void comm_lingering_close(int fd);
 #endif
 
-SQUIDCEXTERN int comm_connect_addr(int sock, const Ip::Address &addr);
-SQUIDCEXTERN void comm_init(void);
-SQUIDCEXTERN void comm_exit(void);
+int comm_connect_addr(int sock, const Ip::Address &addr);
+void comm_init(void);
+void comm_exit(void);
 
-SQUIDCEXTERN int comm_open(int, int, Ip::Address &, int, const char *note);
-SQUIDCEXTERN int comm_open_uds(int sock_type, int proto, struct sockaddr_un* addr, int flags);
+int comm_open(int, int, Ip::Address &, int, const char *note);
+int comm_open_uds(int sock_type, int proto, struct sockaddr_un* addr, int flags);
 /// update Comm state after getting a comm_open() FD from another process
-SQUIDCEXTERN void comm_import_opened(const Comm::ConnectionPointer &, const char *note, struct addrinfo *AI);
+void comm_import_opened(const Comm::ConnectionPointer &, const char *note, struct addrinfo *AI);
 
 /**
  * Open a port specially bound for listening or sending through a specific port.
@@ -51,53 +50,53 @@ SQUIDCEXTERN void comm_import_opened(const Comm::ConnectionPointer &, const char
  * (in debugs or cachemgr) will occur in Native IPv4 format.
  * A reconfigure is needed to reset the stored IP in most cases and attempt a port re-open.
  */
-extern int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note);
-extern void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note);
+int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note);
+void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note);
 
-SQUIDCEXTERN int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *);
-SQUIDCEXTERN unsigned short comm_local_port(int fd);
+int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *);
+unsigned short comm_local_port(int fd);
 
-SQUIDCEXTERN int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
-SQUIDCEXTERN void commCallCloseHandlers(int fd);
+int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
+void commCallCloseHandlers(int fd);
 
 /// clear a timeout handler by FD number
-extern void commUnsetFdTimeout(int fd);
+void commUnsetFdTimeout(int fd);
 
 /**
  * Set or clear the timeout for some action on an active connection.
  * API to replace commSetTimeout() when a Comm::ConnectionPointer is available.
  */
-extern int commSetConnTimeout(const Comm::ConnectionPointer &conn, int seconds, AsyncCall::Pointer &callback);
-extern int commUnsetConnTimeout(const Comm::ConnectionPointer &conn);
+int commSetConnTimeout(const Comm::ConnectionPointer &conn, int seconds, AsyncCall::Pointer &callback);
+int commUnsetConnTimeout(const Comm::ConnectionPointer &conn);
 
-SQUIDCEXTERN int ignoreErrno(int);
-SQUIDCEXTERN void commCloseAllSockets(void);
-SQUIDCEXTERN void checkTimeouts(void);
+int ignoreErrno(int);
+void commCloseAllSockets(void);
+void checkTimeouts(void);
 
 //typedef void IOACB(int fd, int nfd, Comm::ConnectionPointer details, comm_err_t flag, int xerrno, void *data);
-extern void comm_add_close_handler(int fd, CLCB *, void *);
-extern void comm_add_close_handler(int fd, AsyncCall::Pointer &);
-extern void comm_remove_close_handler(int fd, CLCB *, void *);
-extern void comm_remove_close_handler(int fd, AsyncCall::Pointer &);
-
-extern int comm_has_pending_read_callback(int fd);
-extern bool comm_monitors_read(int fd);
-//extern void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, IOCB *handler, void *data);
-extern void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, AsyncCall::Pointer &callback);
-extern void comm_read_cancel(int fd, IOCB *callback, void *data);
-extern void comm_read_cancel(int fd, AsyncCall::Pointer &callback);
-extern int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from);
-extern int comm_udp_recv(int fd, void *buf, size_t len, int flags);
-extern ssize_t comm_udp_send(int s, const void *buf, size_t len, int flags);
-extern bool comm_has_incomplete_write(int);
+void comm_add_close_handler(int fd, CLCB *, void *);
+void comm_add_close_handler(int fd, AsyncCall::Pointer &);
+void comm_remove_close_handler(int fd, CLCB *, void *);
+void comm_remove_close_handler(int fd, AsyncCall::Pointer &);
+
+int comm_has_pending_read_callback(int fd);
+bool comm_monitors_read(int fd);
+//void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, IOCB *handler, void *data);
+void comm_read(const Comm::ConnectionPointer &conn, char *buf, int len, AsyncCall::Pointer &callback);
+void comm_read_cancel(int fd, IOCB *callback, void *data);
+void comm_read_cancel(int fd, AsyncCall::Pointer &callback);
+int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from);
+int comm_udp_recv(int fd, void *buf, size_t len, int flags);
+ssize_t comm_udp_send(int s, const void *buf, size_t len, int flags);
+bool comm_has_incomplete_write(int);
 
 /** The read channel has closed and the caller does not expect more data
  * but needs to detect connection aborts. The current detection method uses
  * 0-length reads: We read until the error occurs or the writer closes
  * the connection. If there is a read error, we close the connection.
  */
-extern void commStartHalfClosedMonitor(int fd);
-extern bool commHasHalfClosedMonitor(int fd);
+void commStartHalfClosedMonitor(int fd);
+bool commHasHalfClosedMonitor(int fd);
 // XXX: remove these wrappers which minimize client_side.cc changes in a commit
 inline void commMarkHalfClosed(int fd) { commStartHalfClosedMonitor(fd); }
 inline bool commIsHalfClosed(int fd) { return commHasHalfClosedMonitor(fd); }
@@ -63,8 +63,8 @@ class CbEntry
 /// Callbacks which might be scheduled in future are stored in fd_table.
 extern CbEntry *iocb_table;
 
-extern void CallbackTableInit();
-extern void CallbackTableDestruct();
+void CallbackTableInit();
+void CallbackTableDestruct();
 
 #define COMMIO_FD_READCB(fd)    (&Comm::iocb_table[(fd)].readcb)
 #define COMMIO_FD_WRITECB(fd)   (&Comm::iocb_table[(fd)].writecb)
@@ -16,20 +16,20 @@ namespace Comm
 {
 
 /// Initialize the module on Squid startup
-extern void SelectLoopInit(void);
+void SelectLoopInit(void);
 
 /// Mark an FD to be watched for its IO status.
-extern void SetSelect(int, unsigned int, PF *, void *, time_t);
+void SetSelect(int, unsigned int, PF *, void *, time_t);
 
 /// reset/undo/unregister the watch for an FD which was set by Comm::SetSelect()
-extern void ResetSelect(int);
+void ResetSelect(int);
 
 /** Perform a select() or equivalent call.
  * This is used by the main select loop engine to check for FD with IO available.
  */
-extern comm_err_t DoSelect(int);
+comm_err_t DoSelect(int);
 
-extern void QuickPollRequired(void);
+void QuickPollRequired(void);
 
 /**
  * Max number of UDP messages to receive per call to the UDP receive poller.
@@ -11,6 +11,6 @@ struct _fd_debug_t {
 typedef struct _fd_debug_t fd_debug_t;
 extern fd_debug_t *fdd_table;
 
-extern bool isOpen(const int fd);
+bool isOpen(const int fd);
 
 #endif
@@ -37,8 +37,8 @@
 
 class MemBuf;
 
-extern int file_open(const char *path, int mode);
-extern void file_close(int fd);
+int file_open(const char *path, int mode);
+void file_close(int fd);
 
 /* Adapter file_write for object callbacks */
 template <class O>
@@ -49,11 +49,11 @@ FreeObject(void *address)
     delete anObject;
 }
 
-extern void file_write(int, off_t, void const *, int len, DWCB *, void *, FREE *);
-extern void file_write_mbuf(int fd, off_t, MemBuf mb, DWCB * handler, void *handler_data);
-extern void file_read(int, char *, int, off_t, DRCB *, void *);
-extern void disk_init(void);
-extern void safeunlink(const char *path, int quiet);
-extern int xrename(const char *from, const char *to); //disk.cc
+void file_write(int, off_t, void const *, int len, DWCB *, void *, FREE *);
+void file_write_mbuf(int fd, off_t, MemBuf mb, DWCB * handler, void *handler_data);
+void file_read(int, char *, int, off_t, DRCB *, void *);
+void disk_init(void);
+void safeunlink(const char *path, int quiet);
+int xrename(const char *from, const char *to); //disk.cc
 
 #endif /* SQUID_DISK_H_ */
@@ -48,11 +48,11 @@ struct dlink_list {
 
 extern dlink_list ClientActiveRequests;
 
-SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkAddTail(void *data, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkDelete(dlink_node * m, dlink_list * list);
-SQUIDCEXTERN void dlinkNodeDelete(dlink_node * m);
-SQUIDCEXTERN dlink_node *dlinkNodeNew(void);
+void dlinkAdd(void *data, dlink_node *, dlink_list *);
+void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
+void dlinkAddTail(void *data, dlink_node *, dlink_list *);
+void dlinkDelete(dlink_node * m, dlink_list * list);
+void dlinkNodeDelete(dlink_node * m);
+dlink_node *dlinkNodeNew(void);
 
 #endif /* SQUID_DLINK_H */
@@ -39,6 +39,6 @@ extern CSR esiStreamRead;
 extern CSCB esiProcessStream;
 extern CSD esiStreamDetach;
 extern CSS esiStreamStatus;
-extern int esiEnableProcessing (HttpReply *);
+int esiEnableProcessing (HttpReply *);
 
 #endif /* SQUID_ESI_H */
@@ -4,8 +4,8 @@
 namespace Esi
 {
 
-extern void Init();
-extern void Clean();
+void Init();
+void Clean();
 
 } // namespace Esi
 
@@ -72,6 +72,6 @@ class ESISegment : public RefCountable
     void dumpOne() const;
 };
 
-extern void ESISegmentFreeList (ESISegment::Pointer &head);
+void ESISegmentFreeList (ESISegment::Pointer &head);
 
 #endif /* SQUID_ESISEGMENT_H */
@@ -6,13 +6,13 @@ namespace Format
 
 /// Safely URL-encode a username.
 /// Accepts NULL or empty strings.
-extern char * QuoteUrlEncodeUsername(const char *name);
+char * QuoteUrlEncodeUsername(const char *name);
 
 /** URL-style encoding on a MIME headers blob.
  * May accept NULL or empty strings.
  * \return A dynamically allocated string. recipient is responsible for free()'ing
  */
-extern char *QuoteMimeBlob(const char *header);
+char *QuoteMimeBlob(const char *header);
 
 }; // namespace Format
 
@@ -125,6 +125,6 @@ class FwdState : public RefCountable
     CBDATA_CLASS2(FwdState);
 };
 
-extern void getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn);
+void getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn);
 
 #endif /* SQUID_FORWARD_H */
@@ -39,17 +39,17 @@
 class StoreEntry;
 class wordlist;
 
-extern void fqdncache_init(void);
+void fqdncache_init(void);
 void fqdnStats(StoreEntry *);
 //extern void fqdncacheReleaseInvalid(const char *);
 //extern int fqdncacheQueueDrain(void);
-extern void fqdncacheFreeMemory(void);
-extern void fqdncache_restart(void);
-extern void fqdncache_purgelru(void *);
-extern void fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames);
+void fqdncacheFreeMemory(void);
+void fqdncache_restart(void);
+void fqdncache_purgelru(void *);
+void fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames);
 
-extern const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
+const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
 //extern const char *fqdnFromAddr(const Ip::Address &);
-extern void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
+void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
 
 #endif /* SQUID_FQDNCACHE_H_ */
@@ -4,8 +4,8 @@
 namespace Fs
 {
 
-extern void Init();
-extern void Clean();
+void Init();
+void Clean();
 
 } // namespace Fs
 
@@ -105,11 +105,11 @@ class CossSwapDir : public SwapDir, public IORequestor
 };
 
 /// \ingroup COSS
-extern void storeCossAdd(CossSwapDir *, StoreEntry *);
+void storeCossAdd(CossSwapDir *, StoreEntry *);
 /// \ingroup COSS
-extern void storeCossRemove(CossSwapDir *, StoreEntry *);
+void storeCossRemove(CossSwapDir *, StoreEntry *);
 /// \ingroup COSS
-extern void storeCossStartMembuf(CossSwapDir * SD);
+void storeCossStartMembuf(CossSwapDir * SD);
 
 #include "StoreSearch.h"
 
@@ -41,8 +41,8 @@ class FwdState;
  */
 
 /// \ingroup ServerProtocolFTPAPI
-extern void ftpStart(FwdState *);
+void ftpStart(FwdState *);
 /// \ingroup ServerProtocolFTPAPI
-extern const char *ftpUrlWith2f(HttpRequest *);
+const char *ftpUrlWith2f(HttpRequest *);
 
 #endif /* SQUID_FTP_H_ */
@@ -42,9 +42,9 @@ class HttpRequest;
  */
 
 /// \ingroup ServerProtocolGopherAPI
-extern void gopherStart(FwdState *);
+void gopherStart(FwdState *);
 
 /// \ingroup ServerProtocolGopherAPI
-extern int gopherCachable(const HttpRequest *);
+int gopherCachable(const HttpRequest *);
 
 #endif /* SQUID_GOPHER_H_ */
@@ -132,8 +132,8 @@ class HttpStateData : public ServerStateData
     CBDATA_CLASS2(HttpStateData);
 };
 
-extern int httpCachable(const HttpRequestMethod&);
-extern void httpStart(FwdState *);
-extern const char *httpMakeVaryMark(HttpRequest * request, HttpReply const * reply);
+int httpCachable(const HttpRequestMethod&);
+void httpStart(FwdState *);
+const char *httpMakeVaryMark(HttpRequest * request, HttpReply const * reply);
 
 #endif /* SQUID_HTTP_H */
@@ -66,7 +66,7 @@ struct icmpEchoData {
     char payload[MAX_PAYLOAD];
 };
 
-SQUIDCEXTERN int icmp_pkts_sent;
+extern int icmp_pkts_sent;
 
 #endif /* USE_ICMP */
 
@@ -32,6 +32,6 @@
  *
  */
 
-extern int isPowTen(int); //int.cc
+int isPowTen(int); //int.cc
 
 #endif /* SQUID_INT_H_ */
@@ -37,12 +37,12 @@
 class HttpRequest;
 class StoreEntry;
 
-extern void internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest *, StoreEntry *);
-extern int internalCheck(const char *urlpath);
-extern int internalStaticCheck(const char *urlpath);
-extern char *internalLocalUri(const char *dir, const char *name);
-extern char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
-extern const char *internalHostname(void);
-extern int internalHostnameIs(const char *);
+void internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest *, StoreEntry *);
+int internalCheck(const char *urlpath);
+int internalStaticCheck(const char *urlpath);
+char *internalLocalUri(const char *dir, const char *name);
+char *internalRemoteUri(const char *, unsigned short, const char *, const char *);
+const char *internalHostname(void);
+int internalHostnameIs(const char *);
 
 #endif /* SQUID_INTERNAL_H_ */
@@ -18,19 +18,19 @@ typedef struct _ipcache_addrs {
 
 typedef void IPH(const ipcache_addrs *, const DnsLookupDetails &details, void *);
 
-extern void ipcache_purgelru(void *);
-extern void ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData);
-extern const ipcache_addrs *ipcache_gethostbyname(const char *, int flags);
-extern void ipcacheInvalidate(const char *);
-extern void ipcacheInvalidateNegative(const char *);
-extern void ipcache_init(void);
-extern void ipcacheCycleAddr(const char *name, ipcache_addrs *);
-extern void ipcacheMarkBadAddr(const char *name, const Ip::Address &);
-extern void ipcacheMarkGoodAddr(const char *name, const Ip::Address &);
-extern void ipcacheMarkAllGood(const char *name);
-extern void ipcacheFreeMemory(void);
-extern ipcache_addrs *ipcacheCheckNumeric(const char *name);
-extern void ipcache_restart(void);
-extern int ipcacheAddEntryFromHosts(const char *name, const char *ipaddr);
+void ipcache_purgelru(void *);
+void ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData);
+const ipcache_addrs *ipcache_gethostbyname(const char *, int flags);
+void ipcacheInvalidate(const char *);
+void ipcacheInvalidateNegative(const char *);
+void ipcache_init(void);
+void ipcacheCycleAddr(const char *name, ipcache_addrs *);
+void ipcacheMarkBadAddr(const char *name, const Ip::Address &);
+void ipcacheMarkGoodAddr(const char *name, const Ip::Address &);
+void ipcacheMarkAllGood(const char *name);
+void ipcacheFreeMemory(void);
+ipcache_addrs *ipcacheCheckNumeric(const char *name);
+void ipcache_restart(void);
+int ipcacheAddEntryFromHosts(const char *name, const char *ipaddr);
 
 #endif /* _SQUID_IPCACHE_H */
@@ -33,12 +33,12 @@
 #ifndef SQUID_MIME_H_
 #define SQUID_MIME_H_
 
-extern void mimeInit(char *filename);
-extern char *mimeGetContentEncoding(const char *fn);
-extern char *mimeGetContentType(const char *fn);
-extern const char *mimeGetIconURL(const char *fn);
-extern char mimeGetTransferMode(const char *fn);
-extern int mimeGetDownloadOption(const char *fn);
-extern int mimeGetViewOption(const char *fn);
+void mimeInit(char *filename);
+char *mimeGetContentEncoding(const char *fn);
+char *mimeGetContentType(const char *fn);
+const char *mimeGetIconURL(const char *fn);
+char mimeGetTransferMode(const char *fn);
+int mimeGetDownloadOption(const char *fn);
+int mimeGetViewOption(const char *fn);
 
 #endif /* SQUID_MIME_H_ */
@@ -33,8 +33,8 @@
 #ifndef SQUID_MIME_HEADER_H_
 #define SQUID_MIME_HEADER_H_
 
-extern char *mime_get_header(const char *mime, const char *header);
-extern char *mime_get_header_field(const char *mime, const char *name, const char *prefix);
-extern size_t headersEnd(const char *, size_t);
+char *mime_get_header(const char *mime, const char *header);
+char *mime_get_header_field(const char *mime, const char *name, const char *prefix);
+size_t headersEnd(const char *, size_t);
 
 #endif /* SQUID_MIME_HEADER_H_ */
@@ -35,7 +35,7 @@
 
 #include "ipcache.h"
 
-extern int mcastSetTtl(int, int);
+int mcastSetTtl(int, int);
 extern IPH mcastJoinGroups;
 
 #endif /* SQUID_MULTICAST_H_ */
@@ -37,7 +37,7 @@
 class CachePeer;
 class HttpRequest;
 
-extern void peerSourceHashInit(void);
-extern CachePeer * peerSourceHashSelectParent(HttpRequest * request);
+void peerSourceHashInit(void);
+CachePeer * peerSourceHashSelectParent(HttpRequest * request);
 
 #endif /* SQUID_PEER_SOURCEHASH_H_ */
@@ -37,7 +37,7 @@
 class CachePeer;
 class HttpRequest;
 
-extern void peerUserHashInit(void);
-extern CachePeer * peerUserHashSelectParent(HttpRequest * request);
+void peerUserHashInit(void);
+CachePeer * peerUserHashSelectParent(HttpRequest * request);
 
 #endif /* SQUID_PEER_USERHASH_H_ */
@@ -29,8 +29,8 @@
 #ifndef SQUID_PROTOS_H
 #define SQUID_PROTOS_H
 
-extern void shut_down(int);
-extern void rotate_logs(int);
-extern void reconfigure(int);
+void shut_down(int);
+void rotate_logs(int);
+void reconfigure(int);
 
 #endif /* SQUID_PROTOS_H */
@@ -33,7 +33,7 @@
  *
  */
 
-extern void redirectInit(void);
-extern void redirectShutdown(void);
+void redirectInit(void);
+void redirectShutdown(void);
 
 #endif /* SQUID_REDIRECT_H_ */
@@ -35,14 +35,14 @@
 
 class RefreshPattern;
 
-extern void refreshAddToList(const char *, int, time_t, int, time_t);
-extern int refreshIsCachable(const StoreEntry *);
-extern int refreshCheckHTTP(const StoreEntry *, HttpRequest *);
-extern int refreshCheckICP(const StoreEntry *, HttpRequest *);
-extern int refreshCheckHTCP(const StoreEntry *, HttpRequest *);
-extern int refreshCheckDigest(const StoreEntry *, time_t delta);
-extern time_t getMaxAge(const char *url);
-extern void refreshInit(void);
-extern const RefreshPattern *refreshLimits(const char *url);
+void refreshAddToList(const char *, int, time_t, int, time_t);
+int refreshIsCachable(const StoreEntry *);
+int refreshCheckHTTP(const StoreEntry *, HttpRequest *);
+int refreshCheckICP(const StoreEntry *, HttpRequest *);
+int refreshCheckHTCP(const StoreEntry *, HttpRequest *);
+int refreshCheckDigest(const StoreEntry *, time_t delta);
+time_t getMaxAge(const char *url);
+void refreshInit(void);
+const RefreshPattern *refreshLimits(const char *url);
 
 #endif /* SQUID_REFRESH_H_ */
@@ -33,6 +33,6 @@
  * Note: repl_modules.cc will be autogenerated.
  */
 
-extern void storeReplSetup(void);
+void storeReplSetup(void);
 
 #endif /* SQUID_REPL_MODULES_H_ */
@@ -32,6 +32,6 @@
  *
  */
 
-extern void start_announce(void *unused);
+void start_announce(void *unused);
 
 #endif /* SQUID_SEND_ANNOUNCE_H_ */
@@ -36,15 +36,15 @@
 
 #include "snmp_vars.h"
 
-extern variable_list *snmp_confFn(variable_list *, snint *);
-extern variable_list *snmp_sysFn(variable_list *, snint *);
-extern variable_list *snmp_prfSysFn(variable_list *, snint *);
-extern variable_list *snmp_prfProtoFn(variable_list *, snint *);
-extern variable_list *snmp_netIpFn(variable_list *, snint *);
-extern variable_list *snmp_netFqdnFn(variable_list *, snint *);
-extern variable_list *snmp_netDnsFn(variable_list *, snint *);
-extern variable_list *snmp_meshPtblFn(variable_list *, snint *);
-extern variable_list *snmp_meshCtblFn(variable_list *, snint *);
+variable_list *snmp_confFn(variable_list *, snint *);
+variable_list *snmp_sysFn(variable_list *, snint *);
+variable_list *snmp_prfSysFn(variable_list *, snint *);
+variable_list *snmp_prfProtoFn(variable_list *, snint *);
+variable_list *snmp_netIpFn(variable_list *, snint *);
+variable_list *snmp_netFqdnFn(variable_list *, snint *);
+variable_list *snmp_netDnsFn(variable_list *, snint *);
+variable_list *snmp_meshPtblFn(variable_list *, snint *);
+variable_list *snmp_meshCtblFn(variable_list *, snint *);
 
 #endif /* SQUID_SNMP */
 #endif /* SQUID_SNMP_AGENT_H_ */
@@ -35,17 +35,17 @@ struct _mib_tree_entry {
     AggrType aggrType;
 };
 
-extern struct snmp_pdu* snmpAgentResponse(struct snmp_pdu* PDU);
-extern AggrType snmpAggrType(oid* Current, snint CurrentLen);
+struct snmp_pdu* snmpAgentResponse(struct snmp_pdu* PDU);
+AggrType snmpAggrType(oid* Current, snint CurrentLen);
 
 extern Comm::ConnectionPointer snmpOutgoingConn;
 
 extern PF snmpHandleUdp;
-extern void snmpInit(void);
-extern void snmpOpenPorts(void);
-extern void snmpClosePorts(void);
-extern const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
-extern void addr2oid(Ip::Address &addr, oid *Dest);
-extern void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
+void snmpInit(void);
+void snmpOpenPorts(void);
+void snmpClosePorts(void);
+const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
+void addr2oid(Ip::Address &addr, oid *Dest);
+void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
 
 #endif /* SQUID_SNMP_CORE_H */
@@ -33,18 +33,18 @@
 #ifndef SQUID_STAT_H_
 #define SQUID_STAT_H_
 
-extern void statInit(void);
-extern void statFreeMemory(void);
-extern double median_svc_get(int, int);
-extern void pconnHistCount(int, int);
-extern int stat5minClientRequests(void);
-extern double stat5minCPUUsage(void);
-extern double statRequestHitRatio(int minutes);
-extern double statRequestHitMemoryRatio(int minutes);
-extern double statRequestHitDiskRatio(int minutes);
-extern double statByteHitRatio(int minutes);
+void statInit(void);
+void statFreeMemory(void);
+double median_svc_get(int, int);
+void pconnHistCount(int, int);
+int stat5minClientRequests(void);
+double stat5minCPUUsage(void);
+double statRequestHitRatio(int minutes);
+double statRequestHitMemoryRatio(int minutes);
+double statRequestHitDiskRatio(int minutes);
+double statByteHitRatio(int minutes);
 
 class StatCounters;
-extern StatCounters *snmpStatGet(int);
+StatCounters *snmpStatGet(int);
 
 #endif /* SQUID_STAT_H_ */
@@ -34,9 +34,9 @@
 
 class StoreEntry;
 
-extern void storeDigestInit(void);
-extern void storeDigestNoteStoreReady(void);
-extern void storeDigestDel(const StoreEntry * entry);
-extern void storeDigestReport(StoreEntry *);
+void storeDigestInit(void);
+void storeDigestNoteStoreReady(void);
+void storeDigestDel(const StoreEntry * entry);
+void storeDigestReport(StoreEntry *);
 
 #endif /* SQUID_STORE_DIGEST_H_ */
@@ -39,18 +39,18 @@
 class HttpRequestMethod;
 class HttpRequest;
 
-extern cache_key *storeKeyDup(const cache_key *);
-extern cache_key *storeKeyCopy(cache_key *, const cache_key *);
-extern void storeKeyFree(const cache_key *);
-extern const cache_key *storeKeyScan(const char *);
-extern const char *storeKeyText(const cache_key *);
-extern const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
-extern const cache_key *storeKeyPublicByRequest(HttpRequest *);
-extern const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
-extern const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
-extern int storeKeyHashBuckets(int);
-extern int storeKeyNull(const cache_key *);
-extern void storeKeyInit(void);
+cache_key *storeKeyDup(const cache_key *);
+cache_key *storeKeyCopy(cache_key *, const cache_key *);
+void storeKeyFree(const cache_key *);
+const cache_key *storeKeyScan(const char *);
+const char *storeKeyText(const cache_key *);
+const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
+const cache_key *storeKeyPublicByRequest(HttpRequest *);
+const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
+const cache_key *storeKeyPrivate(const char *, const HttpRequestMethod&, int);
+int storeKeyHashBuckets(int);
+int storeKeyNull(const cache_key *);
+void storeKeyInit(void);
 
 extern HASHHASH storeKeyHashHash;
 extern HASHCMP storeKeyHashCmp;
@@ -34,9 +34,9 @@
 
 class StoreEntry;
 
-extern void storeLog(int tag, const StoreEntry * e);
-extern void storeLogRotate(void);
-extern void storeLogClose(void);
-extern void storeLogOpen(void);
+void storeLog(int tag, const StoreEntry * e);
+void storeLogRotate(void);
+void storeLogClose(void);
+void storeLogOpen(void);
 
 #endif /* SQUID_STORE_LOG_H_ */
@@ -48,15 +48,15 @@ class StoreRebuildData
     int zero_object_sz;
 };
 
-extern void storeRebuildStart(void);
-extern void storeRebuildComplete(StoreRebuildData *);
-extern void storeRebuildProgress(int sd_index, int total, int sofar);
+void storeRebuildStart(void);
+void storeRebuildComplete(StoreRebuildData *);
+void storeRebuildProgress(int sd_index, int total, int sofar);
 
 /// loads entry from disk; fills supplied memory buffer on success
-extern bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, StoreRebuildData &counts);
+bool storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, StoreRebuildData &counts);
 /// parses entry buffer and validates entry metadata; fills e on success
-extern bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, StoreRebuildData &counts, uint64_t expectedSize);
+bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, StoreRebuildData &counts, uint64_t expectedSize);
 /// checks whether the loaded entry should be kept; updates counters
-extern bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, StoreRebuildData &counts);
+bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, StoreRebuildData &counts);
 
 #endif /* SQUID_STORE_REBUILD_H_ */
@@ -33,6 +33,6 @@
  */
 
 class store_client;
-extern void storeSwapInStart(store_client *);
+void storeSwapInStart(store_client *);
 
 #endif /* SQUID_STORE_SWAPIN_H_ */
@@ -41,66 +41,66 @@ class MemBuf;
 
 extern int DebugSignal;
 
-extern void kb_incr(kb_t *, size_t);
-extern void parseEtcHosts(void);
-extern int getMyPort(void);
-extern void setUmask(mode_t mask);
-extern void strwordquote(MemBuf * mb, const char *str);
+void kb_incr(kb_t *, size_t);
+void parseEtcHosts(void);
+int getMyPort(void);
+void setUmask(mode_t mask);
+void strwordquote(MemBuf * mb, const char *str);
 
 /* packs, then prints an object using debugs() */
-extern void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm);
+void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm);
 
-extern const char *getMyHostname(void);
-extern const char *uniqueHostname(void);
+const char *getMyHostname(void);
+const char *uniqueHostname(void);
 
-extern void death(int sig);
-extern void sigusr2_handle(int sig);
-extern void sig_child(int sig);
-extern void sig_shutdown(int sig); ///< handles shutdown notifications from kids
-extern void leave_suid(void);
-extern void enter_suid(void);
-extern void no_suid(void);
-extern void writePidFile(void);
-extern void setMaxFD(void);
-extern void setSystemLimits(void);
-extern void squid_signal(int sig, SIGHDLR *, int flags);
-extern pid_t readPidFile(void);
-extern void keepCapabilities(void);
-extern void BroadcastSignalIfAny(int& sig);
+void death(int sig);
+void sigusr2_handle(int sig);
+void sig_child(int sig);
+void sig_shutdown(int sig); ///< handles shutdown notifications from kids
+void leave_suid(void);
+void enter_suid(void);
+void no_suid(void);
+void writePidFile(void);
+void setMaxFD(void);
+void setSystemLimits(void);
+void squid_signal(int sig, SIGHDLR *, int flags);
+pid_t readPidFile(void);
+void keepCapabilities(void);
+void BroadcastSignalIfAny(int& sig);
 
 /// whether the current process is the parent of all other Squid processes
-extern bool IamMasterProcess();
+bool IamMasterProcess();
 /**
  *   whether the current process is dedicated to doing things that only
  *   a single process should do, such as PID file maintenance and WCCP
  */
-extern bool IamPrimaryProcess();
+bool IamPrimaryProcess();
 /// whether the current process coordinates worker processes
-extern bool IamCoordinatorProcess();
+bool IamCoordinatorProcess();
 /// whether the current process handles HTTP transactions and such
-extern bool IamWorkerProcess();
+bool IamWorkerProcess();
 /// whether the current process is dedicated to managing a cache_dir
-extern bool IamDiskProcess();
+bool IamDiskProcess();
 /// Whether we are running in daemon mode
-extern bool InDaemonMode(); // try using specific Iam*() checks above first
+bool InDaemonMode(); // try using specific Iam*() checks above first
 /// Whether there should be more than one worker process running
-extern bool UsingSmp(); // try using specific Iam*() checks above first
+bool UsingSmp(); // try using specific Iam*() checks above first
 /// number of Kid processes as defined in src/ipc/Kid.h
-extern int NumberOfKids();
+int NumberOfKids();
 /// a string describing this process roles such as worker or coordinator
-extern String ProcessRoles();
+String ProcessRoles();
 
-extern void debug_trap(const char *);
-extern void *xmemset(void *dst, int, size_t);
+void debug_trap(const char *);
+void *xmemset(void *dst, int, size_t);
 
-extern void logsFlush(void);
+void logsFlush(void);
 
-extern void squid_getrusage(struct rusage *r);
-extern double rusage_cputime(struct rusage *r);
-extern int rusage_maxrss(struct rusage *r);
-extern int rusage_pagefaults(struct rusage *r);
-extern void releaseServerSockets(void);
-extern void PrintRusage(void);
-extern void dumpMallocStats(void);
+void squid_getrusage(struct rusage *r);
+double rusage_cputime(struct rusage *r);
+int rusage_maxrss(struct rusage *r);
+int rusage_pagefaults(struct rusage *r);
+void releaseServerSockets(void);
+void PrintRusage(void);
+void dumpMallocStats(void);
 
 #endif /* SQUID_TOOLS_H_ */
@@ -33,10 +33,10 @@
  */
 
 #if USE_UNLINKD
-extern bool unlinkdNeeded(void);
-extern void unlinkdInit(void);
-extern void unlinkdClose(void);
-extern void unlinkdUnlink(const char *);
+bool unlinkdNeeded(void);
+void unlinkdInit(void);
+void unlinkdClose(void);
+void unlinkdUnlink(const char *);
 #else /* USE_UNLINKD */
 
 #if HAVE_UNISTD_H
@@ -36,6 +36,6 @@
 class HttpRequest;
 class StoreEntry;
 
-extern void urnStart(HttpRequest *, StoreEntry *);
+void urnStart(HttpRequest *, StoreEntry *);
 
 #endif /* SQUID_URN_H_ */
@@ -34,9 +34,9 @@
 #define SQUID_WCCP_H_
 
 #if USE_WCCP
-extern void wccpInit(void);
-extern void wccpConnectionOpen(void);
-extern void wccpConnectionClose(void);
+void wccpInit(void);
+void wccpConnectionOpen(void);
+void wccpConnectionClose(void);
 #endif /* USE_WCCP */
 
 #endif /* SQUID_WCCP_H_ */
@@ -37,27 +37,27 @@
 
 class StoreEntry;
 
-extern void wccp2Init(void);
-extern void wccp2ConnectionOpen(void);
-extern void wccp2ConnectionClose(void);
-extern void parse_wccp2_method(int *v);
-extern void free_wccp2_method(int *v);
-extern void dump_wccp2_method(StoreEntry * e, const char *label, int v);
-extern void parse_wccp2_amethod(int *v);
-extern void free_wccp2_amethod(int *v);
-extern void dump_wccp2_amethod(StoreEntry * e, const char *label, int v);
+void wccp2Init(void);
+void wccp2ConnectionOpen(void);
+void wccp2ConnectionClose(void);
+void parse_wccp2_method(int *v);
+void free_wccp2_method(int *v);
+void dump_wccp2_method(StoreEntry * e, const char *label, int v);
+void parse_wccp2_amethod(int *v);
+void free_wccp2_amethod(int *v);
+void dump_wccp2_amethod(StoreEntry * e, const char *label, int v);
 
-extern void parse_wccp2_service(void *v);
-extern void free_wccp2_service(void *v);
-extern void dump_wccp2_service(StoreEntry * e, const char *label, void *v);
+void parse_wccp2_service(void *v);
+void free_wccp2_service(void *v);
+void dump_wccp2_service(StoreEntry * e, const char *label, void *v);
 
-extern int check_null_wccp2_service(void *v);
+int check_null_wccp2_service(void *v);
 
-extern void parse_wccp2_service_info(void *v);
+void parse_wccp2_service_info(void *v);
 
-extern void free_wccp2_service_info(void *v);
+void free_wccp2_service_info(void *v);
 
-extern void dump_wccp2_service_info(StoreEntry * e, const char *label, void *v);
+void dump_wccp2_service_info(StoreEntry * e, const char *label, void *v);
 #endif /* USE_WCCPv2 */
 
 #endif /* WCCP2_H_ */
@@ -39,6 +39,6 @@
  */
 
 /// \ingroup ServerProtocolWhoisAPI
-extern void whoisStart(FwdState *);
+void whoisStart(FwdState *);
 
 #endif /* SQUID_WHOIS_H_ */
@@ -48,13 +48,13 @@
 #include <sys/types.h>
 #endif
 
-extern int WIN32_pipe(int[2]);
+int WIN32_pipe(int[2]);
 
-extern int WIN32_getrusage(int, struct rusage *);
-extern void WIN32_ExceptionHandlerInit(void);
+int WIN32_getrusage(int, struct rusage *);
+void WIN32_ExceptionHandlerInit(void);
 
-extern int Win32__WSAFDIsSet(int fd, fd_set* set);
-extern DWORD WIN32_IpAddrChangeMonitorInit();
+int Win32__WSAFDIsSet(int fd, fd_set* set);
+DWORD WIN32_IpAddrChangeMonitorInit();
 
 #endif
 
@@ -47,11 +47,11 @@ MEMPROXY_CLASS_INLINE(wordlist);
 
 class MemBuf;
 
-extern const char *wordlistAdd(wordlist **, const char *);
-extern void wordlistCat(const wordlist *, MemBuf * mb);
-extern void wordlistAddWl(wordlist **, wordlist *);
-extern void wordlistJoin(wordlist **, wordlist **);
-extern wordlist *wordlistDup(const wordlist *);
-extern void wordlistDestroy(wordlist **);
+const char *wordlistAdd(wordlist **, const char *);
+void wordlistCat(const wordlist *, MemBuf * mb);
+void wordlistAddWl(wordlist **, wordlist *);
+void wordlistJoin(wordlist **, wordlist **);
+wordlist *wordlistDup(const wordlist *);
+void wordlistDestroy(wordlist **);
 
 #endif /* SQUID_WORDLIST_H */