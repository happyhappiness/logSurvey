@@ -39,6 +39,7 @@ and ideas to make this software available.
     Cord Beermann <cord@cc.fh-lippe.de>
     Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
     David Luyer <luyer@ucs.uwa.edu.au>
+    Dhaval Varia
     Diego Woitasen <diegows@xtech.com.ar>
     Dmitry Kurochkin
     Don Hopkins <dhopkins@DonHopkins.com>
@@ -540,9 +540,8 @@ icons/SN.png:
   Squid NOW icon - copyright Squid Project
 
   This work is licensed under the
-  Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported Liscence
-  (CC BY-NC-SA 3.0)
-  [ http://creativecommons.org/licenses/by-nc-sa/3.0/ ]
+  Creative Commons Attribution-ShareAlike 3.0 Unported Liscence (CC BY-SA 3.0)
+  [ http://creativecommons.org/licenses/by-sa/3.0/ ]
 
 ==============================================================================
 
@@ -1,3 +1,38 @@
+
+Changes to squid-3.3.5 (20 May 2013):
+
+	- Bug 3851: Delay Pool class 5 tag:levels displayed incorrectly in cache manager
+	- Bug 3845: http_port tcpkeepalive= option fails parsing
+	- Bug 3840: assertion failed 'sde' in UFS cache loading
+	- Bug 3836: make check failures with automake-1.13
+	- Bug 3827: Remove AccessLogEntry::cache.authuser
+	- Bug 3816 pt2: SSL_get_certificate call inside Ssl::verifySslCertificate crashes
+	- Bug 3780: cachemgr.cgi: output problem in HTTP Header Statistics
+	- Bug 3759: OpenSSL compilation error on stock Fedora17, RHEL, CentOS 6 systems
+	- Bug 3744: squid terminated: FATAL: Bungled (null) line 3: sslproxy_cert_sign signTrusted all
+	- Port from 2.6: external acl %ACL and %DATA tags
+	- Update copyright on SN.png
+	- ... and several minor memory leaks
+	- ... and some documentation polish
+
+Changes to squid-3.3.4 (27 Apr 2013):
+
+	- Bug 3831: basic_ncsa_auth Blowfish and SHA support
+	- Bug 3816: SSL_get_certificate call inside Ssl::verifySslCertificate crashes
+	- Bug 3794: MacOS: workaround compiler errors and case-insensitivity
+	- Bug 3781: Proxy Authentication not sent to cache_peer
+	- Bug 3720 pt1: SourceLayout: shuffle fd_table definition into fde.h
+	- Bug 3720 pt2: Add missing include in /dev/poll I/O module
+	- Bug 3674: Improve compiler detection, better support warnings-as-errors on clang
+	- Add support for TPROXY on BSD
+	- Fix SSL Bump bypass for intercepted traffic
+	- Fix memory leaks in ConnStateData pinning
+	- Fix external_acl.cc "inBackground" assertion on queue overloads
+	- CacheMgr: fix missing column separator in helper stats
+	- OpenBSD: libpthreads requires OpenBSD 5.2 or later
+	- ... and lots of documentation updates
+	- ... and all changes from squid 3.2.10
+
 Changes to squid-3.3.3 (12 Mar 2013):
 
 	- Bug 3720: Add missing include in /dev/poll I/O module (pt2)
@@ -55,6 +90,24 @@ Changes to squid-3.3.0.1 (21 Oct 2012):
 	- ... and many compile error fixes
 	- ... and a very large amount of code polish for faster compilation
 
+Changes to squid-3.2.11 (30 Apr 2013):
+
+	- Regression Bug 3839: build error: src/tools.h: No such file or directory
+	- Update copyright on SN.png
+
+Changes to squid-3.2.10 (27 Apr 2013):
+
+	- Bug 3833: squidclient: Option '-k' is not present in man(1) page
+	- Bug 3825: basic_ncsa_auth: segfaulting with glibc-2.17
+	- Bug 3822: Locate LDAP and SASL headers for BSD support
+	- Bug 3817: Memory leak in SSL cert validate for alt_name peer certs
+	- Bug 3774: 'squid -k reconfigure' drops rock cache
+	- Bug 3565: Resuming postponed accept kills Squid
+	- HTTP/1.1: partial support for no-cache and private controls with parameters
+	- ssl_crtd: fix helpers dying during startup on ARM
+	- GNU Hurd: define MAP_NORESERVE as no-op when missing
+	- BSD: fix enter_suid/leave_suid build errors in ip/Intercept.cc
+
 Changes to squid-3.2.9 (12 Mar 2013):
 
 	- Regression fix: Accept-Language header parse
@@ -2,6 +2,13 @@ In addition to the numerous volunteer developers (see CONTRIBUTORS),
 the following organizations have provided non-financial support for
 the Squid Project:
 
+@Squid-3.3:
+Netbox Blue Pty (http://netboxblue.com/)
+
+	Netbox Blue Pty. contributed development resources towards
+	testing and stabilizing of authentication systems in Squid-3.2
+	and Squid-3.3.
+
 @Squid-3.2:
 iiNet Ltd - http://www.iinet.net.au/
 
@@ -81,15 +81,12 @@ AC_DEFUN([SQUID_CC_REQUIRE_ARGUMENT],[
 #  - sunstudio
 #  - none (undetected)
 # 
-AC_DEFUN([SQUID_CC_GUESS_VARIANT], [
+AC_DEFUN([SQUID_CC_GUESS_VARIANT], [ 
  AC_CACHE_CHECK([what kind of compiler we're using],[squid_cv_compiler],
  [
   AC_REQUIRE([AC_PROG_CC])
-  if test "$GCC" = "yes" ; then
-   squid_cv_compiler="gcc"
-  fi
   dnl repeat the next block for each compiler, changing the
-  dnl preprocessor definition type so that it depends on platform-specific
+  dnl preprocessor definition so that it depends on platform-specific
   dnl predefined macros
   dnl SunPro CC
   if test -z "$squid_cv_compiler" ; then
@@ -109,12 +106,39 @@ AC_DEFUN([SQUID_CC_GUESS_VARIANT], [
 #endif
     ]])],[squid_cv_compiler="icc"],[])
   fi
+  dnl clang
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(__clang__)
+#error "not clang"
+#endif
+    ]])],[squid_cv_compiler="clang"],[])
+  fi
+  dnl microsoft visual c++
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(_MSC_VER)
+#error "not Microsoft VC++"
+#endif
+    ]])],[squid_cv_compiler="msvc"],[])
+  fi
+  dnl gcc. MUST BE LAST as many other compilers also define it for compatibility
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(__GNUC__)
+#error "not gcc"
+#endif
+    ]])],[squid_cv_compiler="gcc"],[])
+  fi
   dnl end of block to be repeated
   if test -z "$squid_cv_compiler" ; then
    squid_cv_compiler="none"
   fi
-  ])
- ])
+  ]) dnl AC_CACHE_CHECK
+ ]) dnl AC_DEFUN
 
 # define the flag to use to have the compiler treat warnings as errors
 # requirs SQUID_CC_GUESS_VARIANT
@@ -145,6 +169,13 @@ AC_DEFUN([SQUID_CC_GUESS_OPTIONS], [
    squid_cv_cc_option_optimize="-fast"
    squid_cv_cc_arg_pipe=""
    ;;
+  clang) 
+   squid_cv_cxx_option_werror="-Werror -Wno-error=parentheses-equality"
+   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
+   squid_cv_cc_option_wall="-Wall"
+   squid_cv_cc_option_optimize="-O2"
+   squid_cv_cc_arg_pipe=""
+   ;;
   icc) 
    squid_cv_cxx_option_werror="-Werror"
    squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
@@ -94,3 +94,129 @@ AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
   ])
   SQUID_STATE_ROLLBACK(iphlpapi)
 ])
+
+dnl Checks whether the OpenSSL SSL_get_certificate crashes squid and if a
+dnl workaround can be used instead of using the SSL_get_certificate
+AC_DEFUN([SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS],[
+  AH_TEMPLATE(SQUID_SSLGETCERTIFICATE_BUGGY, "Define to 1 if the SSL_get_certificate crashes squid")
+  AH_TEMPLATE(SQUID_USE_SSLGETCERTIFICATE_HACK, "Define to 1 to use squid workaround for SSL_get_certificate")
+  SQUID_STATE_SAVE(check_SSL_get_certificate)
+  LIBS="$SSLLIB $LIBS"
+  if test "x$SSLLIBDIR" != "x"; then
+     LIBS="$LIBS -Wl,-rpath -Wl,$SSLLIBDIR"
+  fi
+
+  AC_MSG_CHECKING(whether the SSL_get_certificate is buggy)
+  AC_RUN_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+    SSLeay_add_ssl_algorithms();
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv3_method());
+    SSL *ssl = SSL_new(sslContext);
+    X509* cert = SSL_get_certificate(ssl);
+    return 0;
+    ])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [
+   AC_DEFINE(SQUID_SSLGETCERTIFICATE_BUGGY, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [])
+
+  AC_MSG_CHECKING(whether the workaround for SSL_get_certificate works)
+  AC_RUN_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+    SSLeay_add_ssl_algorithms();
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv3_method());
+    X509 ***pCert = (X509 ***)sslContext->cert;
+    X509 *sslCtxCert = pCert && *pCert ? **pCert : (X509 *)0x1;
+    if (sslCtxCert != NULL)
+        return 1;
+    return 0;
+    ])
+  ],
+  [
+   AC_MSG_RESULT([yes])
+   AC_DEFINE(SQUID_USE_SSLGETCERTIFICATE_HACK, 1)
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+[])
+
+SQUID_STATE_ROLLBACK(check_SSL_get_certificate)
+])
+
+
+dnl Try to handle TXT_DB related  problems:
+dnl 1) The type of TXT_DB::data member changed in openSSL-1.0.1 version
+dnl 2) The IMPLEMENT_LHASH_* openSSL macros in openSSL-1.0.1 and later releases is not
+dnl    implemented correctly and causes type conversion errors while compiling squid
+
+AC_DEFUN([SQUID_CHECK_OPENSSL_TXTDB],[
+  AH_TEMPLATE(SQUID_SSLTXTDB_PSTRINGDATA, "Define to 1 if the TXT_DB uses OPENSSL_PSTRING data member")
+  AH_TEMPLATE(SQUID_USE_SSLLHASH_HACK, "Define to 1 to use squid workaround for openssl IMPLEMENT_LHASH_* type conversion errors")
+
+  SQUID_STATE_SAVE(check_TXTDB)
+
+  LIBS="$LIBS $SSLLIB"
+  AC_MSG_CHECKING(whether the TXT_DB use OPENSSL_PSTRING data member)
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/txt_db.h>
+    ],
+    [
+    TXT_DB *db = NULL;
+    int i = sk_OPENSSL_PSTRING_num(db->data);
+    return 0;
+    ])
+  ],
+  [
+   AC_DEFINE(SQUID_SSLTXTDB_PSTRINGDATA, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [])
+
+  AC_MSG_CHECKING(whether the workaround for OpenSSL IMPLEMENT_LHASH_  macros should used)
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/txt_db.h>
+
+     static unsigned long index_serial_hash(const char **a){}
+     static int index_serial_cmp(const char **a, const char **b){}
+     static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
+     static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
+    ],
+    [
+    TXT_DB *db = NULL;
+    TXT_DB_create_index(db, 1, NULL, LHASH_HASH_FN(index_serial_hash), LHASH_COMP_FN(index_serial_cmp));
+    ])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [
+   AC_MSG_RESULT([yes])
+   AC_DEFINE(SQUID_USE_SSLLHASH_HACK, 1)
+  ],
+[])
+
+SQUID_STATE_ROLLBACK(check_TXTDB)
+])
@@ -249,3 +249,30 @@ AS_IF([test "$ac_res" != no],
       [$4])
 AS_VAR_POPDEF([ac_Search])dnl
 ])
+
+dnl Check for Cyrus SASL
+AC_DEFUN([SQUID_CHECK_SASL],[
+  squid_sasl_present="auto"
+  AC_CHECK_HEADERS([sasl/sasl.h sasl.h])
+  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
+    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
+      squid_sasl_present="no"
+    ])
+  ])
+  case "$squid_host_os" in
+    Darwin)
+      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
+        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
+        echo "checking for MAC Darwin without sasl.h ... yes"
+        squid_sasl_present="yes"
+      else
+        echo "checking for MAC Darwin without sasl.h ... no"
+        squid_sasl_present="no"
+      fi
+      ;;
+  esac
+  if test "x$squid_sasl_present" != "yes"; then
+    AC_MSG_WARN([Neither SASL nor SASL2 found])
+  fi
+  AC_SUBST(LIBSASL)
+])
@@ -148,6 +148,7 @@ gettimeofday(struct timeval *pcur_time, void *tzp)
 }
 #endif /* !HAVE_GETTIMEOFDAY */
 
+#if !_SQUID_MINGW_
 int
 statfs(const char *path, struct statfs *sfs)
 {
@@ -181,6 +182,7 @@ statfs(const char *path, struct statfs *sfs)
     sfs->f_namelen = maxlen;
     return 0;
 }
+#endif
 
 #if !_SQUID_MINGW_
 int
@@ -17,5 +17,10 @@
 #define _XOPEN_SOURCE_EXTENDED 1
 #endif
 
+/* AIX 6.1 does not define recvmsg() flag MSG_DONTWAIT */
+#if !defined(MSG_DONTWAIT)
+#define MSG_DONTWAIT 0
+#endif
+
 #endif /* _SQUID_AIX_ */
 #endif /* SQUID_OS_AIX_H */
@@ -212,6 +212,7 @@ struct group {
     char    **gr_mem;      /* group members */
 };
 
+#if !_SQUID_MINGW_
 struct statfs {
     long    f_type;     /* type of filesystem (see below) */
     long    f_bsize;    /* optimal transfer block size */
@@ -224,6 +225,7 @@ struct statfs {
     long    f_namelen;  /* maximum length of filenames */
     long    f_spare[6]; /* spare for later */
 };
+#endif
 
 #if !HAVE_GETTIMEOFDAY
 struct timezone {
@@ -459,6 +461,9 @@ index(const char *s, int c)
     return (char *)strchr(s,c);
 }
 
+// stdlib <functional> definitions are required before std API redefinitions.
+#include <functional>
+
 /** \cond AUTODOCS-IGNORE */
 namespace Squid
 {
@@ -807,7 +812,9 @@ struct rusage {
 
 SQUIDCEXTERN int chroot(const char *dirname);
 SQUIDCEXTERN int kill(pid_t, int);
+#if !_SQUID_MINGW_
 SQUIDCEXTERN int statfs(const char *, struct statfs *);
+#endif
 SQUIDCEXTERN struct passwd * getpwnam(char *unused);
 SQUIDCEXTERN struct group * getgrnam(char *unused);
 
@@ -35,9 +35,20 @@ AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
-# might be cross-compiling
+# Clang 3.2 on some CPUs requires -march-native to detect correctly
+# GCC 4.3+ can also produce faster executables when its used
+SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+
+# might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
   HOSTCXX="$CXX"
+  if test "x$squid_cv_check_marchnative" = "xyes"; then
+    CXXFLAGS="$CXXFLAGS -march=native"
+  fi
+fi
+if test "x$squid_cv_check_marchnative" = "xyes"; then
+  # always valid for the Host compiler.
+  HOSTCXX="$HOSTCXX -march=native"
 fi
 AC_SUBST(HOSTCXX)
 
@@ -60,8 +71,7 @@ fi
 
 # Check for C++0x compiler support
 AX_CXX_COMPILE_STDCXX_0X
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
-  "x$squid_host_os" != "xmingw" ; then
+if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" ; then
     #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
     # in the system libraries, which makes some c99 methods unavailable
     # (e.g. strtoll), yet configure detects them as avilable.
@@ -259,7 +269,7 @@ case $withval in
 ])
 AC_SUBST(DEFAULT_SWAP_DIR)
 
-if test "x$GCC" = "xyes"; then
+if test "$squid_cv_compiler" = "gcc"; then
   GCCVER=`$CC -v 2>&1 | awk '$2 ==  "version" {print $3}'`
   GCCVER2=`echo $GCCVER | awk '{print $1 * 100}'`
   case "$host" in
@@ -276,7 +286,7 @@ fi
 
 dnl Set Default CFLAGS
 if test "x$PRESET_CFLAGS" = "x"; then
-  if test "x$GCC" = "xyes"; then
+  if test "$squid_cv_compiler" = "gcc"; then
     case "$host" in
       *-sun-sunos*)
         # sunos has too many warnings for this to be useful
@@ -310,7 +320,7 @@ if test "x$PRESET_CFLAGS" = "x"; then
 fi
 
 dnl set squid required flags
-if test "x$GCC" = "xyes"; then
+if test "$squid_cv_compiler" = "gcc"; then
   case "$squid_host_os" in
   mingw)
 dnl Guido Serassio (serassio@squid-cache.org) 20070811
@@ -589,6 +599,16 @@ for module in $squid_disk_module_candidates none; do
               fi
             fi
             ;;
+          openbsd)
+            if test `echo "$squid_host_os_version" | tr -d .` -lt 52 ; then
+                AC_MSG_NOTICE(pthread library requires OpenBSD 5.2 or later)
+                squid_opt_use_diskthreads="no"
+            else
+              SQUID_CFLAGS="$SQUID_CFLAGS -D_REENTRANT"
+              SQUID_CXXFLAGS="$SQUID_CXXFLAGS -D_REENTRANT"
+              LDFLAGS="$LDFLAGS -lpthread"
+            fi
+            ;;
           solaris)
             if test "x$GCC" = "xyes" ; then
               SQUID_CFLAGS="$SQUID_CFLAGS -D_REENTRANT -pthreads"
@@ -1255,6 +1275,10 @@ if test "x$SSLLIBDIR" != "x" ; then
 fi
 AC_SUBST(SSLLIB)
 
+if test "x$with_openssl" = "xyes"; then
+SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS
+SQUID_CHECK_OPENSSL_TXTDB
+fi
 
 AC_ARG_ENABLE(forw-via-db,
   AS_HELP_STRING([--enable-forw-via-db],[Enable Forw/Via database]), [
@@ -1459,7 +1483,17 @@ AC_ARG_ENABLE(pf-transparent,
               [unrecognized argument to --enable-pf-transparent: $enableval])
 ])
 #will be AC_DEFINEd later, after checking for appropriate infrastructure
-AC_MSG_NOTICE([PF-based transparent proxying requested: ${enable_pf_transparent:=auto}])
+AC_MSG_NOTICE([PF-based transparent proxying requested: ${enable_pf_transparent:=no}])
+
+dnl Enable /dev/pf support for older PF Transparent Proxy systems (OpenBSD 4.x and older)
+AC_ARG_WITH(nat-devpf,
+  AS_HELP_STRING([--with-nat-devpf],
+    [Enable /dev/pf support for NAT on older OpenBSD and FreeBSD kernels.]), [
+  SQUID_YESNO([$enableval],
+              [unrecognized argument to --with-nat-devpf: $enableval])
+])
+#will be AC_DEFINEd later, after checking for appropriate infrastructure
+AC_MSG_NOTICE([NAT lookups via /dev/pf: ${with_nat_devpf:=no}])
 
 # Linux Netfilter Transparent Proxy
 AC_ARG_ENABLE(linux-netfilter,
@@ -1549,6 +1583,9 @@ case "$withval" in
 esac
 ])
 
+#hack. Let's early-detect sizeof(long)
+AC_CHECK_SIZEOF(long)
+
 if test "x$squid_opt_enable_large_files" = "xyes" -a "x$buildmodel" = "x"; then
   for model in POSIX_V6_LPBIG_OFFBIG XBS5_LPBIG_OFFBIG POSIX_V6_LP64_OFF64 XBS5_LP64_OFF64 POSIX_V6_ILP32_OFFBIG XBS5_ILP32_OFFBIG; do
     if test "`getconf _$model 2>/dev/null || true`" = 1 || test "`getconf $model 2>/dev/null || true`" ; then
@@ -1561,7 +1598,8 @@ if test "x$squid_opt_enable_large_files" = "xyes" -a "x$buildmodel" = "x"; then
   fi
 fi
 if test "x$buildmodel" = "xdefault" -o "x$buildmodel" = "x"; then
-  if test "x$squid_opt_enable_large_files" = "xyes" ; then
+  # define _FILE_OFFSET_BITS if requested and needed
+  if test "x$squid_opt_enable_large_files" = "xyes" -a $ac_cv_sizeof_long -le 4 ; then
     AC_MSG_NOTICE([Enabling -D_FILE_OFFSET_BITS=64])
     CFLAGS="-D_FILE_OFFSET_BITS=64 $CFLAGS"
     CXXFLAGS="-D_FILE_OFFSET_BITS=64 $CXXFLAGS"
@@ -1706,45 +1744,7 @@ AC_ARG_ENABLE(auth-basic,
       To see available helpers, see the helpers/basic_auth directory. ]),[
 #nothing to do really
 ])
-#not specified. Inherit global
-if test "x$enable_auth_basic" = "x"; then
-    enable_auth_basic=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Basic auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_basic" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
-fi
-#handle the "none" special case
-if test "x$enable_auth_basic" = "xnone" ; then
-    enable_auth_basic=""
-fi
-BASIC_AUTH_HELPERS=""
-#enable_auth_basic contains either "no" or the list of modules to be built
-enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_basic" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES basic"
-    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
-    for helper in $enable_auth_basic
-    do
-    dir="$srcdir/helpers/basic_auth/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xSASL" ; then
-        squid_require_sasl=yes
-      fi
-    elif test -d "$srcdir/helpers/basic_auth/$helper" ; then
-      AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
-    fi
-    done
-fi
-AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
-AC_SUBST(BASIC_AUTH_HELPERS)
+m4_include([helpers/basic_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-ntlm,
   AS_HELP_STRING([--enable-auth-ntlm="list of helpers"],
@@ -1755,38 +1755,7 @@ AC_ARG_ENABLE(auth-ntlm,
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/ntlm_auth directory. ]),[
 ])
-if test "x$enable_auth_ntlm" = "x"; then
-    enable_auth_ntlm=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([NTLM auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_ntlm" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
-fi
-#handle the "none" special case
-if test "x$enable_auth_ntlm" = "xnone" ; then
-    enable_auth_ntlm=""
-fi
-NTLM_AUTH_HELPERS=""
-enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_ntlm" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES ntlm"
-    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
-    for helper in $enable_auth_ntlm ; do
-        dir="$srcdir/helpers/ntlm_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-            AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([NTLM auth helpers built: $NTLM_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
-AC_SUBST(NTLM_AUTH_HELPERS)
+m4_include([helpers/ntlm_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-negotiate,
   AS_HELP_STRING([--enable-auth-negotiate="list of helpers"],
@@ -1800,38 +1769,7 @@ AC_ARG_ENABLE(auth-negotiate,
       To see available helpers, see the helpers/negotiate_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_negotiate" = "x"; then
-    enable_auth_negotiate=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_negotiate" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
-fi
-#handle the "none" special case
-if test "x$enable_auth_negotiate" = "xnone" ; then
-    enable_auth_negotiate=""
-fi
-NEGOTIATE_AUTH_HELPERS=""
-enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_negotiate" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES negotiate"
-    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
-    for helper in $enable_auth_negotiate ; do
-        dir="$srcdir/helpers/negotiate_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/negotiate_auth/$helper" ; then
-            AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
-AC_SUBST(NEGOTIATE_AUTH_HELPERS)
+m4_include([helpers/negotiate_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-digest,
   AS_HELP_STRING([--enable-auth-digest="list of helpers"],
@@ -1843,38 +1781,7 @@ AC_ARG_ENABLE(auth-digest,
       To see available helpers, see the helpers/digest_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_digest" = "x"; then
-    enable_auth_digest=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Digest auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_digest" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
-fi
-#handle the "none" special case
-if test "x$enable_auth_digest" = "xnone" ; then
-    enable_auth_digest=""
-fi
-DIGEST_AUTH_HELPERS=""
-enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_digest" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES digest"
-    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
-    for helper in $enable_auth_digest ; do
-        dir="$srcdir/helpers/digest_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/digest_auth/$helper" ; then
-            AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Digest auth helpers built: $DIGEST_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
-AC_SUBST(DIGEST_AUTH_HELPERS)
+m4_include([helpers/digest_auth/modules.m4])
 
 dnl Authentication libraries to build
 dnl This list will not be needed when each auth library has its own Makefile
@@ -1887,33 +1794,15 @@ AC_SUBST(AUTH_MODULES)
 AC_SUBST(AUTH_LIBS_TO_BUILD)
 
 dnl Select logging daemon helpers to build
-squid_opt_logdaemon_helpers="auto"
 AC_ARG_ENABLE(log-daemon-helpers,
   AS_HELP_STRING([--enable-log-daemon-helpers="list of helpers"],
                  [This option selects which logging daemon helpers to 
                   build and install as part of the normal build process
                   For a list of available helpers see the helpers/log_daemon
                   directory.]),[
-case "$enableval" in
-  yes) : ;;
-  no)  squid_opt_logdaemon_helpers="" ;;
-  *)   squid_opt_logdaemon_helpers="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`" ;;
-  esac
+#nothing to do, really
 ])
-if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
-  squid_opt_logdaemon_helpers=""
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[squid_opt_logdaemon_helpers])
-fi
-for helper in $squid_opt_logdaemon_helpers ; do
-  dir="$srcdir/helpers/log_daemon/$helper"
-  if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-    LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $helper"
-  elif test -d "$srcdir/helpers/log_daemon/$helper" ; then
-    AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
-  fi
-done
-AC_MSG_NOTICE([Log daemon helpers built: $LOG_DAEMON_HELPERS])
-AC_SUBST(LOG_DAEMON_HELPERS)
+m4_include([helpers/log_daemon/modules.m4])
 
 dnl
 dnl Check Kerberos/GSSAPI/SPNEGO
@@ -2060,33 +1949,7 @@ AC_ARG_ENABLE(external-acl-helpers,
                   directory]), [
 #nothing to do, really
 ])
-if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],
-    [enable_external_acl_helpers])
-fi
-if test "x$enable_external_acl_helpers" = "xnone" ; then
-  enable_external_acl_helpers=""
-fi
-EXTERNAL_ACL_HELPERS=""
-enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_external_acl_helpers" != "xno" ; then
-  for helper in $enable_external_acl_helpers ; do
-    dir="$srcdir/helpers/external_acl/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xkerberos_ldap_group" ; then
-        squid_require_sasl=yes
-      fi
-    else
-      AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
-    fi
-  done
-fi
-AC_MSG_NOTICE([External acl helpers built: $EXTERNAL_ACL_HELPERS])
-AC_SUBST(EXTERNAL_ACL_HELPERS)
-
-
+m4_include([helpers/external_acl/modules.m4])
 
 dnl Select url_rewrite helpers to build
 AC_ARG_ENABLE(url-rewrite-helpers,
@@ -2098,28 +1961,7 @@ AC_ARG_ENABLE(url-rewrite-helpers,
                   For a list of available helpers see the
                   helpers/url_rewrite directory.]),[
 ])
-if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],
-                           [enable_url_rewrite_helpers])
-fi
-enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
-URL_REWRITE_HELPERS=""
-if test "x$enable_url_rewrite_helpers" != "xno" ; then
-  for helper in $enable_url_rewrite_helpers; do
-    dir="$srcdir/helpers/url_rewrite/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $helper"
-    elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-      AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
-    else
-      AC_MSG_NOTICE([URL rewrite helper $helper ... not found])
-    fi
-  done
-fi
-AC_MSG_NOTICE([URL rewrite helpers built: $URL_REWRITE_HELPERS])
-AC_SUBST(URL_REWRITE_HELPERS)
-
+m4_include([helpers/url_rewrite/modules.m4])
 
 AC_ARG_WITH(valgrind-debug,
   AS_HELP_STRING([--with-valgrind-debug],
@@ -2164,27 +2006,6 @@ SQUID_DEFINE_BOOL(USE_WIN32_SERVICE,${enable_win32_service:=no},
 AC_MSG_NOTICE([MS Windows service mode enabled: $enable_win32_service])
 
 
-# Check for Cyrus SASL
-if test "x$squid_require_sasl" = "xyes"; then
-  AC_CHECK_HEADERS(sasl/sasl.h sasl.h)
-  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
-    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
-      AC_MSG_ERROR(Neither SASL nor SASL2 found)
-    ])
-  ])
-  case "$squid_host_os" in
-    Darwin)
-      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
-        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
-        echo "checking for MAC Darwin without sasl.h ... yes"
-      else
-        echo "checking for MAC Darwin without sasl.h ... no"
-      fi
-      ;;
-  esac
-  AC_SUBST(LIBSASL)
-fi
-
 # Disable "unlinkd" code
 AC_ARG_ENABLE(unlinkd,
   AS_HELP_STRING([--disable-unlinkd],[Do not use unlinkd]), [
@@ -3349,22 +3170,24 @@ dnl Solaris minor version (8, 9, 10, ...)
   CXXFLAGS="-DSOLARIS2=$solrev $CXXFLAGS" 
 fi
 
-dnl PF support requires a header file.
-if test "x$enable_pf_transparent" != "xno" ; then
+dnl PF /dev/pf support requires a header file.
+if test "x$with_nat_devpf" != "xno" ; then
   if test "x$ac_cv_header_net_pfvar_h" = "xyes" -o \
     "x$ac_cv_header_net_pf_pfvar_h" = "xyes"; then
-    if test "x$enable_pf_transparent" = "xauto" ; then
-      enable_pf_transparent="yes"
+    if test "x$with_nat_devpf" = "xauto" ; then
+      with_nat_devpf="no"
     fi
   else
-    if test "x$enable_pf_transparent" = "xyes" ; then
-      AC_MSG_ERROR([PF-based transparent proxy requested but needed header not found])
+    if test "x$with_nat_devpf" = "xyes" ; then
+      AC_MSG_ERROR([PF /dev/pf based NAT requested but needed header not found])
     fi
-    enable_pf_transparent="no"
+    with_nat_devpf="no"
   fi
 fi
-SQUID_DEFINE_BOOL(PF_TRANSPARENT,$enable_pf_transparent,
+SQUID_DEFINE_BOOL(PF_TRANSPARENT,${enable_pf_transparent:=no},
   [Enable support for PF-style transparent proxying])
+SQUID_DEFINE_BOOL(USE_NAT_DEVPF,${with_nat_devpf:=no},
+  [Enable support for /dev/pf NAT lookups])
 
 if test "x$enable_linux_netfilter" != "xno" ; then
   if test "x$ac_cv_header_linux_netfilter_ipv4_h" = "xyes"; then
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.9 release notes</title>
+<title>Squid 3.2.11 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.9.
+The Squid Team are pleased to announce the release of Squid-3.2.11.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.3 release notes</title>
+<title>Squid 3.3.5 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.3.
+The Squid Team are pleased to announce the release of Squid-3.3.5.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
 <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -206,6 +206,12 @@ This section gives a thorough account of those changes in three categories:
 	   <em>ssl::certUntrusted</em>,
 	   <em>ssl::certSelfSigned</em>.
 
+	<tag>external_acl_type</tag>
+	<p><em>%ACL</em> format tag ported from 2.6.
+	   Sends the name of ACL being tested to the external helper.
+	<p><em>%DATA</em> format tag ported from 2.6.
+	   Inserts the ACL arguments into a particular location of the helper input instead of at the end of the line.
+
 	<tag>logformat</tag>
 	<p>New token <em>%ssl::bump_mode</em> to log the SSL-bump mode type performed on a request.
 	  Logs values of: <em>-</em>, <em>none</em>, <em>client-first</em>, or <em>server-first</em>.
@@ -309,16 +315,9 @@ This section gives an account of those changes in three categories:
 	<tag>error_map</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>external_acl_type</tag>
-	<p><em>%ACL</em> format tag not yet ported from 2.6
-	<p><em>%DATA</em> format tag not yet ported from 2.6
-
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>http_port</tag>
-	<p><em>act-as-origin</em> not yet ported from 2.7
-
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
 
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <HTML>
 <HEAD>
- <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
  <TITLE>Squid 3.4.0.0 release notes</TITLE>
 </HEAD>
 <BODY>
@@ -26,6 +26,7 @@ <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></
 <UL>
 <LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
 <LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
@@ -55,17 +56,19 @@ <H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
 
 <P>The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.</P>
 <P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the
 <A HREF="http://www.squid-cache.org/Mirrors/http-mirrors.html">mirrors</A>.</P>
 <P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
 <P>We welcome feedback and bug reports. If you find a bug, please see 
-<A HREF="http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d">http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d</A> for how to submit a report with a stack trace.</P>
+<A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
+for how to submit a report with a stack trace.</P>
 
 <H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
 </H2>
 
 <P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://www.squid-cache.org/bugs/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.4&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">open bugs against Squid-3.4</A>.</P>
+<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4">open bugs against Squid-3.4</A>.</P>
+
 
 <H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.4</A>
 </H2>
@@ -81,6 +84,7 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></
 <UL>
 <LI>Helper protocol extensions</LI>
 <LI>SSL Server Certificate Validator</LI>
+<LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
@@ -142,6 +146,30 @@ <H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</
 <EM>ssl_crtd</EM> related options. </P>
 
 
+<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf</A>.</P>
+
+<P>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
+using several very simple methods. One of which is the <EM>divert-to</EM> rule type
+which acts as a simple routing diversion instead of performing NAT packet alterations.</P>
+
+<P>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.</P>
+
+<P>This version of Squid adds support for these features through the ./configure
+options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
+systems with the required support. No special extras are required to enable
+<EM>http_port ... tproxy</EM> configuration to work.</P>
+
+<P>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
+<EM>./configure --enable-pf-transparent</EM> has been altered and is expected to
+break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
+which do not yet support the getsockname() API.
+These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
+
+
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <P>There have been changes to Squid's configuration file since Squid-3.3.</P>
@@ -167,6 +195,9 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 <P>Use ACLs to annotate a transaction with customized annotations
 which can be logged in access.log</P>
 
+<DT><B>spoof_client_ip</B><DD>
+<P>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.</P>
+
 <DT><B>sslcrtvalidator_children</B><DD>
 <P>Specifies the settings for how many SSL server certificate
 validator helpers are run and when they are started.</P>
@@ -203,6 +234,12 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <P>Details at 
 <A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
+<DT><B>http_port</B><DD>
+<P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
+(OpenBSD 5+, FreeBSD 9+ so far).</P>
+<P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
+see <EM>--enable-pf-transparent</EM> for more details.</P>
+
 <DT><B>logformat</B><DD>
 <P>New format code <EM>%note</EM> to log a transaction annotation linked to the
 transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
@@ -231,6 +268,18 @@ <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed
 <DL>
 <P><EM>There are no removed squid.conf tags in Squid-3.4.</EM></P>
 
+<DT><B>storeurl_access</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_children</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_concurrency</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_program</B><DD>
+<P>Not yet ported from 2.7</P>
+
 </DL>
 </P>
 
@@ -256,7 +305,14 @@ <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New opti
 
 <P>
 <DL>
-<P><EM>There are no new ./configure options in Squid-3.4.</EM></P>
+<DT><B>--with-nat-pf</B><DD>
+<P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
+in squid.conf.</P>
+<P>When this option is used Squid performs the /dev/pf lookups required to
+support PF <EM>rdr-to</EM> rules. Otherwise Squid will perform perform the
+getsockname() API calls to support PF <EM>divert-to</EM> rules.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require this option.</P>
 
 </DL>
 </P>
@@ -266,7 +322,14 @@ <H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Cha
 
 <P>
 <DL>
-<P><EM>There are no changed ./configure options in Squid-3.4.</EM></P>
+<DT><B>--enable-pf-transparent</B><DD>
+<P>NAT table support updated to use the getsockname() API provided by the
+latest PF versions <EM>divert-to</EM>. This allows <EM>http_port</EM>
+in squid.conf to support both <EM>intercept</EM> and <EM>tproxy</EM> traffic
+and to silence NAT lookup failure messages on recent BSD.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require <EM>--with-nat-devpf</EM>
+to re-enable /dev/pf support when using PF firewall.</P>
 
 </DL>
 </P>
@@ -318,16 +381,9 @@ <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options availab
 <DT><B>error_map</B><DD>
 <P>Not yet ported from 2.6</P>
 
-<DT><B>external_acl_type</B><DD>
-<P><EM>%ACL</EM> format tag not yet ported from 2.6</P>
-<P><EM>%DATA</EM> format tag not yet ported from 2.6</P>
-
 <DT><B>external_refresh_check</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>http_port</B><DD>
-<P><EM>act-as-origin</EM> not yet ported from 2.7</P>
-
 <DT><B>ignore_ims_on_miss</B><DD>
 <P>Not yet ported from 2.7</P>
 
@@ -351,18 +407,6 @@ <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options availab
 <DT><B>refresh_stale_hit</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>storeurl_access</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_children</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_program</B><DD>
-<P>Not yet ported from 2.7</P>
-
 <DT><B>update_headers</B><DD>
 <P>Not yet ported from 2.7</P>
 
@@ -40,6 +40,9 @@ The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 <itemize>
 	<item>Helper protocol extensions
 	<item>SSL Server Certificate Validator
+	<item>Store-ID
+	<item>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
+	<item>Transaction Annotations
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -93,6 +96,80 @@ Most user-facing changes are reflected in squid.conf (see below).
    <em>ssl_crtd</em> related options. 
 
 
+<sect1>Store-ID
+<p>Details at <url url="http://wiki.squid-cache.org/Features/StoreID">.
+
+<p>This feature is a redesigned equivalent to the Squid-2.7 feature known as StoreURL-rewrite.
+
+<p><em>Notice</em> that this is not a direct portage of the Squid-2.7 feature so behaviour
+  differences do exist. Although the new feature works in similar enough ways that the old
+  helper scripts used for Squid-2.7 are expected to work in this and later versions of Squid.
+
+<p>Squid traditionally uses the requested URL as an index key ID to locate objects in cache.
+   It is not the only key possible and the Store-ID feature exposes an API for external
+   helpers to provide Squid with an alternative key name for any URL.
+
+<p>When any client request is received which requires a cache lookup the URL is passed to
+   a helper specified with the <em>store_id_rewrite_program</em> directive to check for
+   an alternative Store ID. This allows the helper to identify URLs which refer to duplicate
+   resources and de-duplicate the cache content. <em>store_id_access</em> is provided to
+   allow ACL-based tuning of which traffic gets sent to the helper and reduce overheads.
+
+<p>Once subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
+   this feature is that <em>refresh_pattern</em> applies its regex argument against the Store
+   ID key and not the transaction URL. So using the Store-ID feature to alter the value
+   affects which <em>refresh_pattern</em> directive will be matched.
+
+
+<sect1>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
+<p>Details at <url url="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">.
+
+<p>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
+   using several very simple methods. One of which is the <em>divert-to</em> rule type
+   which acts as a simple routing diversion instead of performing NAT packet alterations.
+
+<p>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.
+
+<p>This version of Squid adds support for these features through the ./configure
+   options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
+   systems with the required support. No special extras are required to enable
+   <em>http_port ... tproxy</em> configuration to work.
+
+<p>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
+   <em>./configure --enable-pf-transparent</em> has been altered and is expected to
+   break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
+   which do not yet support the getsockname() API.
+   These systems require <em>--with-nat-devpf</em> to enable /dev/pf support when using PF firewall.
+
+<sect1>Transaction Annotations
+<p>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
+   or external ACL <em>tag=</em> result code. Each of which had only limited possibilities
+   for use and little or no correlation.
+
+<p>It is now possible to add annotations to a client transaction from several sources:
+<itemize>
+	<item>	Directly from squid.conf using the <em>note</em> directive with
+		ACL-based selection of which annotation is linked to any
+		particular transaction.
+
+	<item>	By configured helper processes returning a key=value pair.
+		The key name becomes the annotation name.
+</itemize>
+
+<p>Annotations on the transaction can be passed to ICAP services or eCAP modules using the
+   <em>adaptation_meta</em> directive to send them as headers.
+   They can also be logged using the <em>%note</em> log format code in custom logs. With
+   the new helper response syntax changes this means all helper response key=value details
+   such as URL-rewrite or store-id changes, external ACL tag etc. are now able to be logged.
+
+<p>Annotations which are already assigned to a transaction can be checked using an ACL test
+   of the new <em>note</em> ACL type. This can match a particular note by name and value,
+   of for any notes with a given name.
+
+<p>NOTE: not all helper interfaces are yet enabled to convert key=value into annotations
+	 and the external ACL interface does not yet send annotations to the helper.
+
+
 <sect>Changes to squid.conf since Squid-3.3
 <p>
 There have been changes to Squid's configuration file since Squid-3.3.
@@ -113,6 +190,9 @@ This section gives a thorough account of those changes in three categories:
 	<p>Use ACLs to annotate a transaction with customized annotations
 	   which can be logged in access.log
 
+	<tag>spoof_client_ip</tag>
+	<p>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.
+
 	<tag>sslcrtvalidator_children</tag>
 	<p>Specifies the settings for how many SSL server certificate
 	   validator helpers are run and when they are started.
@@ -125,9 +205,24 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
+	<tag>access_log</tag>
+	<p>Configuration syntax extended to support name=value options.
+	  <em>New Syntax:</em> access_log module:place [option ...] [acl ...]
+	<p>New option <em>logformat=</em> to specify the logging format name.
+	<p>New option <em>buffer-size=</em> to specify how large the log buffer
+	   for this log is to be when <em>buffered_logs</em> is enabled.
+	<p>New option <em>on-error=</em> to specify what handling is to be done
+	   if the logging module encounters a non-recoverable error writing logs.
+	   With the value <em>die</em> (the default) Squid halts operation.
+	   With the value <em>drop</em> Squid drops log lines and continue running.
+
 	<tag>acl</tag>
 	<p>New test type <em>server_cert_fingerprint</em> to match against 
 	   server SSL certificate fingerprint.
+	<p>New test type <em>note</em> to match against transaction annotations
+	   by name and value, or just by name.
+	<p>New test type <em>any-of</em> to match if any one of a set of named ACLs.
+	<p>New test type <em>all-of</em> to match against all of a set of named ACLs.
 
 	<tag>auth_param</tag>
 	<p>New result code <em>BH</em> to signal helper internal errors
@@ -144,10 +239,19 @@ This section gives a thorough account of those changes in three categories:
 	<p>New result code <em>BH</em> to signal helper internal errors
 	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
 
+	<tag>http_port</tag>
+	<p>Support <em>tproxy</em> mode traffic on BSD systems with BINDANY support
+	   (OpenBSD 5+, FreeBSD 9+ so far).
+	<p>Changed build options behind <em>intercept</em> traffic mode handling on BSD.
+	   see <em>--enable-pf-transparent</em> for more details.
+
 	<tag>logformat</tag>
 	<p>New format code <em>%note</em> to log a transaction annotation linked to the
 	   transaction by ICAP, eCAP, a helper, or the <em>note</em> squid.conf directive.
 
+	<tag>pipeline_prefetch</tag>
+	<p>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.
+
 	<tag>unlinkd_program</tag>
 	<p>New helper response format utilizing result codes <em>OK</em> and <em>BH</em>,
 	   to signal helper lookup results. Also, key-value response values to return
@@ -186,14 +290,28 @@ This section gives an account of those changes in three categories:
 <sect1>New options<label id="newoptions">
 <p>
 <descrip>
-	<p><em>There are no new ./configure options in Squid-3.4.</em>
+	<tag>--with-nat-pf</tag>
+	<p>New option to alter the behaviour of <em>http_port ... intercept</em> option
+	   in squid.conf.
+	<p>When this option is used Squid performs the /dev/pf lookups required to
+	   support PF <em>rdr-to</em> rules. Otherwise Squid will perform perform the
+	   getsockname() API calls to support PF <em>divert-to</em> rules.
+	<p>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+	   the getsockname() API in recent PF versions require this option.
 
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
 <p>
 <descrip>
-	<p><em>There are no changed ./configure options in Squid-3.4.</em>
+	<tag>--enable-pf-transparent</tag>
+	<p>NAT table support updated to use the getsockname() API provided by the
+	   latest PF versions <em>divert-to</em>. This allows <em>http_port</em>
+	   in squid.conf to support both <em>intercept</em> and <em>tproxy</em> traffic
+	   and to silence NAT lookup failure messages on recent BSD.
+	<p>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+	   the getsockname() API in recent PF versions require <em>--with-nat-devpf</em>
+	   to re-enable /dev/pf support when using PF firewall.
 
 </descrip>
 </p>
@@ -241,16 +359,9 @@ This section gives an account of those changes in three categories:
 	<tag>error_map</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>external_acl_type</tag>
-	<p><em>%ACL</em> format tag not yet ported from 2.6
-	<p><em>%DATA</em> format tag not yet ported from 2.6
-
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>http_port</tag>
-	<p><em>act-as-origin</em> not yet ported from 2.7
-
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
 
@@ -161,3 +161,8 @@ rfc6585.txt
 	429 (Too Many Requests),
 	431 (Request Header Fields Too Large),
 	511 (Network Authentication Required)
+
+rfc6762.txt
+	Multicast DNS
+	Details the DNS requirements on the Squid internal DNS client
+	for resolving URLs in the .local domain.
@@ -24,6 +24,7 @@ ms	ms-my
 nl	nl-nl
 pl	pl-pl
 pt	pt-pt
+pt-br	pt-bz
 ro	ro-ro ro-md
 ru	ru-ru
 sk	sk-sk
@@ -7,7 +7,7 @@ EXTRA_DIST= \
 	basic_db_auth.8 \
 	passwd.sql \
 	basic_db_auth.pl.in \
-	config.test
+	required.m4
 
 basic_db_auth.8: basic_db_auth
 	pod2man basic_db_auth basic_db_auth.8
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 	= basic_ldap_auth
 man_MANS 		= basic_ldap_auth.8
-EXTRA_DIST		= basic_ldap_auth.8 config.test
+EXTRA_DIST		= basic_ldap_auth.8 required.m4
 basic_ldap_auth_SOURCES	= basic_ldap_auth.cc
 
 LDADD = \
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_msnt_multi_domain_auth
-EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt config.test
+EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt required.m4
 CLEANFILES += basic_msnt_multi_domain_auth
 
 basic_msnt_multi_domain_auth: basic_msnt_multi_domain_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="MSNT-multi-domain"
@@ -19,7 +19,7 @@ EXTRA_DIST = \
 	msntauth.conf.default \
 	msntauth-v2.0.lsm \
 	README.html \
-	config.test
+	required.m4
 
 sysconf_DATA = \
 	msntauth.conf.default
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Don't build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 1
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 1
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 1
-fi
-exit 0
@@ -0,0 +1,5 @@
+#
+# DONT build this helper on Windows
+#
+BUILD_HELPER="MSNT"
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
@@ -16,3 +16,5 @@ DIST_SUBDIRS = \
 	SSPI
 
 SUBDIRS	= $(BASIC_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
@@ -3,7 +3,7 @@ include $(top_srcdir)/src/Common.am
 libexec_PROGRAMS	= basic_ncsa_auth
 basic_ncsa_auth_SOURCES	= basic_ncsa_auth.cc crypt_md5.cc crypt_md5.h
 man_MANS 		= basic_ncsa_auth.8
-EXTRA_DIST		= basic_ncsa_auth.8 config.test
+EXTRA_DIST		= basic_ncsa_auth.8 required.m4
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -20,10 +20,18 @@ This password file can be manipulated using
 .PP
 This authenticator accepts:
 .BR
+* Blowfish - for passwords 72 characters or less in length
+.BR
+* SHA256 - with salting and magic strings
+.BR
+* SHA512 - with salting and magic strings
+.BR
 * MD5 - with optional salt and magic strings
 .BR
 * DES - for passwords 8 characters or less in length
 .
+NOTE: Blowfish and SHA algorithms require system-specific support.
+.
 .SH OPTIONS
 The only parameter is the password file.
 It must have permissions to be read by the user that Squid is running as.
@@ -146,21 +146,39 @@ main(int argc, char **argv)
         u = (user_data *) hash_lookup(hash, user);
         if (u == NULL) {
             SEND_ERR("No such user");
+            continue;
+        }
+        char *crypted = NULL;
 #if HAVE_CRYPT
-        } else if (strlen(passwd) <= 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
-            // Bug 3107: crypt() DES functionality silently truncates long passwords.
+        size_t passwordLength = strlen(passwd);
+        // Bug 3831: given algorithms more secure than DES crypt() does not truncate, so we can ignore the bug 3107 length checks below
+        // '$1$' = MD5, '$2a$' = Blowfish, '$5$' = SHA256 (Linux), '$6$' = SHA256 (BSD) and SHA512
+        if (passwordLength > 1 && u->passwd[0] == '$' &&
+                (crypted = crypt(passwd, u->passwd)) && strcmp(u->passwd, crypted) == 0) {
             SEND_OK("");
-        } else if (strlen(passwd) > 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
+            continue;
+        }
+        // 'other' prefixes indicate DES algorithm.
+        if (passwordLength <= 8 && (crypted = crypt(passwd, u->passwd)) && (strcmp(u->passwd, crypted) == 0)) {
+            SEND_OK("");
+            continue;
+        }
+        if (passwordLength > 8 && (crypted = crypt(passwd, u->passwd)) && (strcmp(u->passwd, crypted) == 0)) {
             // Bug 3107: crypt() DES functionality silently truncates long passwords.
             SEND_ERR("Password too long. Only 8 characters accepted.");
+            continue;
+        }
+
 #endif
-        } else if (strcmp(u->passwd, (char *) crypt_md5(passwd, u->passwd)) == 0) {
+        if ( (crypted = crypt_md5(passwd, u->passwd)) && strcmp(u->passwd, crypted) == 0) {
             SEND_OK("");
-        } else if (strcmp(u->passwd, (char *) md5sum(passwd)) == 0) {
+            continue;
+        }
+        if ( (crypted = md5sum(passwd)) && strcmp(u->passwd, crypted) == 0) {
             SEND_OK("");
-        } else {
-            SEND_ERR("Wrong password");
+            continue;
         }
+        SEND_ERR("Wrong password");
     }
     if (hash != NULL) {
         hashFreeItems(hash, my_free);
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="NCSA"
@@ -16,4 +16,4 @@ basic_nis_auth_LDADD = \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/rpcsvc/yp_prot.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([rpcsvc/yp_prot.h],[BUILD_HELPER="NIS"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 man_MANS		= basic_pam_auth.8
-EXTRA_DIST		= basic_pam_auth.8 config.test
+EXTRA_DIST		= basic_pam_auth.8 required.m4
 libexec_PROGRAMS	= basic_pam_auth
 basic_pam_auth_SOURCES	= basic_pam_auth.cc
 
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/security/pam_appl.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([security/pam_appl.h],[BUILD_HELPER="PAM"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_pop3_auth
-EXTRA_DIST = basic_pop3_auth.pl.in config.test
+EXTRA_DIST = basic_pop3_auth.pl.in required.m4
 CLEANFILES += basic_pop3_auth
 
 basic_pop3_auth: basic_pop3_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="POP3"
@@ -5,7 +5,7 @@ INCLUDES += -I$(srcdir)
 
 libexec_PROGRAMS 	= basic_radius_auth
 man_MANS 		= basic_radius_auth.8
-EXTRA_DIST		= basic_radius_auth.8 config.test
+EXTRA_DIST		= basic_radius_auth.8 required.m4
 basic_radius_auth_SOURCES = \
 			basic_radius_auth.cc \
 			radius.h \
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="RADIUS"
@@ -13,4 +13,4 @@ EXTRA_DIST = \
 	basic_sasl_auth.8 \
 	basic_sasl_auth.conf \
 	basic_sasl_auth.pam \
-	config.test
+	required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/sasl.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/sasl/sasl.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,6 @@
+SQUID_CHECK_SASL
+
+# on success, add to the built modules list
+if test "x$squid_check_sasl" = "xyes"; then
+  BUILD_HELPER="SASL"
+fi
@@ -11,4 +11,4 @@ basic_smb_auth_LDADD = \
 		$(COMPAT_LIB) \
 		$(XTRA_LIBS)
 
-EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 config.test
+EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 required.m4
@@ -1,10 +0,0 @@
-#!/bin/sh
-for prefix in /usr/local /opt /opt/samba /usr/local/samba /usr
-do
-    if [ -x ${prefix}/bin/smbclient ]; then
-        exit 0
-    fi
-done
-echo "WARNING: Samba smbclient not found in default location. basic_smb_auth may not work on this machine"
-# allow script install anyway.
-exit 0
@@ -0,0 +1,10 @@
+#
+# The shell script helper require smbclient to be in the environment PATH.
+# We can install anyway, but warn if smbclient not found already
+#
+AC_PATH_PROG(SMBCLIENT, smbclient)
+if test "x$SMBCLIENT" = "x"; then
+  AC_MSG_WARN([Samba smbclient not found in default location. basic_smb_auth may not work on this machine])
+fi
+# allow script install anyway.
+BUILD_HELPER="SMB"
@@ -20,4 +20,4 @@ basic_sspi_auth_LDADD = \
 	$(XTRA_LIBS)
 
 man_MANS = basic_sspi_auth.8
-EXTRA_DIST = basic_sspi_auth.8 config.test
+EXTRA_DIST = basic_sspi_auth.8 required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-	exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -5,4 +5,4 @@ basic_fake_auth_SOURCES = fake.cc
 
 LDADD = $(COMPAT_LIB)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -10,4 +10,4 @@ basic_getpwnam_auth_LDADD = \
 
 man_MANS = basic_getpwnam_auth.8
 
-EXTRA_DIST = basic_getpwnam_auth.8 config.test
+EXTRA_DIST = basic_getpwnam_auth.8 required.m4
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/pwd.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="getpwnam"])
@@ -0,0 +1,92 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_basic list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_basic" = "x"; then
+    enable_auth_basic=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Basic auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_basic" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
+fi
+#handle the "none" special case
+if test "x$enable_auth_basic" = "xnone" ; then
+    enable_auth_basic=""
+fi
+
+BASIC_AUTH_HELPERS=""
+#enable_auth_basic contains either "no" or the list of modules to be built
+enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_basic" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES basic"
+    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
+    for helper in $enable_auth_basic; do
+      dir="$srcdir/helpers/basic_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xDB" ; then
+        m4_include([helpers/basic_auth/DB/required.m4])
+
+      elif test "x$helper" = "xLDAP" ; then
+        m4_include([helpers/basic_auth/LDAP/required.m4])
+
+      elif test "x$helper" = "xMSNT-multi-domain" ; then
+        m4_include([helpers/basic_auth/MSNT-multi-domain/required.m4])
+
+      elif test "x$helper" = "xMSNT" ; then
+        m4_include([helpers/basic_auth/MSNT/required.m4])
+
+      elif test "x$helper" = "xNCSA" ; then
+        m4_include([helpers/basic_auth/NCSA/required.m4])
+
+      elif test "x$helper" = "xNIS" ; then
+        m4_include([helpers/basic_auth/NIS/required.m4])
+
+      elif test "x$helper" = "xPOP3" ; then
+        m4_include([helpers/basic_auth/POP3/required.m4])
+
+      elif test "x$helper" = "xRADIUS" ; then
+        m4_include([helpers/basic_auth/RADIUS/required.m4])
+
+      elif test "x$helper" = "xSASL" ; then
+        m4_include([helpers/basic_auth/SASL/required.m4])
+
+      elif test "x$helper" = "xSMB" ; then
+        m4_include([helpers/basic_auth/SMB/required.m4])
+
+      elif test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/basic_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xfake" ; then
+        m4_include([helpers/basic_auth/fake/required.m4])
+
+      elif test "x$helper" = "xgetpwnam" ; then
+        m4_include([helpers/basic_auth/getpwnam/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/basic_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
+        else
+          BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Basic auth helper $helper ... not found])
+      fi
+    done
+fi
+
+AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
+AC_SUBST(BASIC_AUTH_HELPERS)
@@ -18,4 +18,4 @@ digest_ldap_auth_LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -5,3 +5,5 @@ DIST_SUBDIRS= \
 	LDAP
 
 SUBDIRS= $(DIGEST_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
@@ -21,4 +21,4 @@ digest_edirectory_auth_LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -18,4 +18,4 @@ LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = digest_file_auth.8 config.test
+EXTRA_DIST = digest_file_auth.8 required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="file"
@@ -0,0 +1,60 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_digest list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_digest" = "x"; then
+    enable_auth_digest=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Digest auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_digest" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
+fi
+#handle the "none" special case
+if test "x$enable_auth_digest" = "xnone" ; then
+    enable_auth_digest=""
+fi
+
+DIGEST_AUTH_HELPERS=""
+enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_digest" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES digest"
+    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
+    for helper in $enable_auth_digest; do
+      dir="$srcdir/helpers/digest_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xLDAP" ; then
+        m4_include([helpers/digest_auth/LDAP/required.m4])
+
+      elif test "x$helper" = "xeDirectory" ; then
+        m4_include([helpers/digest_auth/eDirectory/required.m4])
+
+      elif test "x$helper" = "xfile" ; then
+        m4_include([helpers/digest_auth/file/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/digest_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
+        else
+          DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Digest auth helper $helper ... not found])
+      fi
+    done
+fi
+AC_MSG_NOTICE([Digest auth helpers to be built: $DIGEST_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
+AC_SUBST(DIGEST_AUTH_HELPERS)
@@ -8,6 +8,7 @@ man_MANS = ext_ad_group_acl.8
 # Currently activeds and adsiid libraries are not available on MinGW or Cygwin,
 # so the following library list is just a placeholder for future MinGW/Cygwin releases.
 # This helper can be compiled only using Microsoft Visual Studio.
+# TODO: test for these libraries in required.m4
 #
 LDADD = \
 	$(COMPAT_LIB) \
@@ -20,4 +21,4 @@ LDADD = \
 	-ladsiid \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test ext_ad_group_acl.8
+EXTRA_DIST = required.m4 ext_ad_group_acl.8
@@ -1,12 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/w32api/dsrole.h ]; then
-  if grep -q DsRoleGetPrimaryDomainInformation /usr/include/w32api/dsrole.h; then
-	  exit 0
-	fi
-fi
-if [ -f /usr/include/dsrole.h ]; then
-  if grep -q DsRoleGetPrimaryDomainInformation /usr/include/dsrole.h; then
-	  exit 0
-  fi
-fi
-exit 1
@@ -0,0 +1,8 @@
+for hdr in w32api/dsrole.h dsrole.h; do
+  AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[#include <$hdr>]], [[
+      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDSRoleInfo;
+      DWORD ret = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) & pDSRoleInfo);
+    ]])
+  ],[BUILD_HELPER="AD_group"],[])
+done
@@ -4,7 +4,7 @@ libexec_PROGRAMS 		= ext_ldap_group_acl
 ext_ldap_group_acl_SOURCES	= ext_ldap_group_acl.cc
 
 man_MANS 			= ext_ldap_group_acl.8
-EXTRA_DIST			= ext_ldap_group_acl.8 config.test
+EXTRA_DIST			= ext_ldap_group_acl.8 required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP_group"])
@@ -12,4 +12,4 @@ LDADD = \
 
 man_MANS = ext_lm_group_acl.8
 
-EXTRA_DIST = config.test ext_lm_group_acl.8
+EXTRA_DIST = required.m4 ext_lm_group_acl.8
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="LM_group"])
@@ -6,7 +6,7 @@ man_MANS = ext_sql_session_acl.8
 EXTRA_DIST= \
 	ext_sql_session_acl.8 \
 	ext_sql_session_acl.pl.in \
-	config.test
+	required.m4
 
 ext_sql_session_acl.8: ext_sql_session_acl
 	pod2man ext_sql_session_acl ext_sql_session_acl.8
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="SQL_session"
+fi
@@ -13,4 +13,4 @@ ext_edirectory_userip_acl_LDADD = \
 
 man_MANS = ext_edirectory_userip_acl.8
 
-EXTRA_DIST = config.test ext_edirectory_userip_acl.8
+EXTRA_DIST = required.m4 ext_edirectory_userip_acl.8
@@ -1,9 +0,0 @@
-#!/bin/sh
-
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="eDirectory_userip"])
@@ -8,7 +8,7 @@ EXTRA_DIST = \
 	example.conf \
 	example-deny_all_but.conf \
 	ext_file_userip_acl.8 \
-	config.test
+	required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/sys/socket.h ]; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([sys/socket.h],[BUILD_HELPER="file_userip"])
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README config.test cert_tool ext_kerberos_ldap_group_acl.8
+EXTRA_DIST = README required.m4 cert_tool ext_kerberos_ldap_group_acl.8
 SUBDIRS = 
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
@@ -1,23 +0,0 @@
-#!/bin/sh
-# Don't build without gssapi.h
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	# Won't link without SASL as well
-	if [ -f /usr/include/sasl.h -o -f /usr/include/sasl/sasl.h -o -f /usr/local/include/sasl.h -o -f /usr/local/include/sasl/sasl.h ]; then
-		if [ -f /usr/lib/libsasl.a -o -f /usr/lib/libsasl2.a ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib/libsasl.la -o -f /usr/lib/libsasl2.la ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib/libsasl.so -o -f /usr/lib/libsasl2.so ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib64/libsasl.so -o -f /usr/lib64/libsasl2.so ]; then
-			exit 0
-		fi
-		if [ -f  /usr/local/lib/libsasl.so -o -f  /usr/local/lib/libsasl2.so ]; then
-			exit 0
-		fi
-	fi
-fi
-exit 1
@@ -425,6 +425,7 @@ main(int argc, char *const argv[])
             dp = xstrdup(rfc1738_escape(domain));
         if (!domain && margs.ddomain) {
             domain = xstrdup(margs.ddomain);
+            dp = xstrdup(rfc1738_escape(domain));
             if (debug_enabled)
                 debug((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, up, dp);
             else
@@ -0,0 +1,2 @@
+AC_CHECK_HEADERS([ldap.h],[BUILD_HELPER="kerberos_ldap_group"])
+SQUID_CHECK_SASL
@@ -0,0 +1,71 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_external_acl_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],[enable_external_acl_helpers])
+fi
+if test "x$enable_external_acl_helpers" = "xnone" ; then
+  enable_external_acl_helpers=""
+fi
+EXTERNAL_ACL_HELPERS=""
+enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_external_acl_helpers" != "xno" ; then
+  for helper in $enable_external_acl_helpers ; do
+    dir="$srcdir/helpers/external_acl/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xAD_group" ; then
+        m4_include([helpers/external_acl/AD_group/required.m4])
+
+      elif test "x$helper" = "xLDAP_group" ; then
+        m4_include([helpers/external_acl/LDAP_group/required.m4])
+
+      elif test "x$helper" = "xLM_group" ; then
+        m4_include([helpers/external_acl/LM_group/required.m4])
+
+      elif test "x$helper" = "xSQL_session" ; then
+        m4_include([helpers/external_acl/SQL_session/required.m4])
+
+      elif test "x$helper" = "xeDirectory_userip" ; then
+        m4_include([helpers/external_acl/eDirectory_userip/required.m4])
+
+      elif test "x$helper" = "xfile_userip" ; then
+        m4_include([helpers/external_acl/file_userip/required.m4])
+
+      elif test "x$helper" = "xkerberos_ldap_group" ; then
+        m4_include([helpers/external_acl/kerberos_ldap_group/required.m4])
+
+      elif test "x$helper" = "xsession" ; then
+        m4_include([helpers/external_acl/session/required.m4])
+
+      elif test "x$helper" = "xtime_quota" ; then
+        m4_include([helpers/external_acl/time_quota/required.m4])
+
+      elif test "x$helper" = "xunix_group" ; then
+        m4_include([helpers/external_acl/unix_group/required.m4])
+
+      elif test "x$helper" = "xwbinfo_group" ; then
+        m4_include([helpers/external_acl/wbinfo_group/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/external_acl/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
+        else
+          EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([external acl helper $helper ... not found])
+      fi
+  done
+fi
+AC_MSG_NOTICE([External acl helpers to be built: $EXTERNAL_ACL_HELPERS])
+AC_SUBST(EXTERNAL_ACL_HELPERS)
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_session_acl
 man_MANS 			= ext_session_acl.8
-EXTRA_DIST			= ext_session_acl.8 config.test
+EXTRA_DIST			= ext_session_acl.8 required.m4
 ext_session_acl_SOURCES		= ext_session_acl.cc
 
 LDADD = \
@@ -1,6 +0,0 @@
-#!/bin/sh
-
-if [ -f /usr/include/db.h ] && grep db_env_create /usr/include/db.h; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <db.h>]],[[DB_ENV *db_env = NULL; db_env_create(&db_env, 0);]])],[BUILD_HELPER="session"],[])
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_time_quota_acl
 man_MANS 			= ext_time_quota_acl.8
-EXTRA_DIST			= ext_time_quota_acl.8 config.test
+EXTRA_DIST			= ext_time_quota_acl.8 required.m4
 ext_time_quota_acl_SOURCES	= ext_time_quota_acl.cc
 
 DEFS += -DDEFAULT_QUOTA_DB=\"$(localstatedir)/ext_time_quota.db\" 
@@ -1,10 +0,0 @@
-#!/bin/sh
-
-# Actual intended test
-if [ -f /usr/include/db_185.h ]; then
-    exit 0
-fi
-if [ -f /usr/include/db.h ] && grep dbopen /usr/include/db.h; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1,2 @@
+AC_CHECK_HEADERS([db_185.h],[BUILD_HELPER="time_quota"])
+AC_EGREP_HEADER([dbopen],[/usr/include/db.h],[BUILD_HELPER="time_quota"])
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_unix_group_acl
 man_MANS 			= ext_unix_group_acl.8
-EXTRA_DIST			= ext_unix_group_acl.8 config.test
+EXTRA_DIST			= ext_unix_group_acl.8 required.m4
 ext_unix_group_acl_SOURCES	= check_group.cc
 
 LDADD = \
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/pwd.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="unix_group"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS = ext_wbinfo_group_acl
-EXTRA_DIST	= ext_wbinfo_group_acl.pl.in config.test
+EXTRA_DIST	= ext_wbinfo_group_acl.pl.in required.m4
 
 ext_wbinfo_group_acl: ext_wbinfo_group_acl.pl.in
 	$(subst_perlshell)
@@ -1,18 +0,0 @@
-#!/bin/sh
-samba_found="no"
-for sambaprefix in /usr/local /opt /opt/samba /usr/local/samba /usr
-do
-    if [ -x $sambaprefix/bin/wbinfo ]; then
-      samba_found="yes"
-    fi
-done
-if test "$samba_found" = "no"; then
-    echo "WARNING: Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine"
-fi
-for perlprefix in /usr /usr/local /opt /opt/perl
-do
-    if [ -x $perlprefix/bin/perl ]; then
-        exit 0
-    fi
-done
-exit 1
@@ -0,0 +1,13 @@
+#
+# The shell script helper requires wbinfo to be in the environment PATH.
+# We can install anyway, but warn if the tool is missing
+#
+AC_PATH_PROG(WBINFO, wbinfo)
+if test "x$WBINFO" = "x"; then
+  AC_MSG_WARN([Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine])
+fi
+
+# allow script install anyway when perl is present
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="wbinfo_group"
+fi
@@ -4,7 +4,7 @@ libexec_SCRIPTS	= log_db_daemon
 CLEANFILES += log_db_daemon log_db_daemon.8
 man_MANS = log_db_daemon.8
 EXTRA_DIST= \
-	config.test \
+	required.m4 \
 	doc/views.sql \
 	doc/date_day_column.sql \
 	log_db_daemon.8 \
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -41,6 +41,8 @@ Default "DBI:mysql:database=squid"
 
 Write debug messages to Squid stderr or cache.log
 
+=back
+
 =cut
 
 # the first argument to this script is the log file path describing the DSN
@@ -196,6 +198,8 @@ $dbh->disconnect();
 
 __END__
 
+=pod
+
 =head1 DESCRIPTION
 
 This module exploits the new logfile daemon support available in squid 2.7 and 3.2 to store access log entries in a MySQL database.
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
@@ -4,3 +4,4 @@ DIST_SUBDIRS = \
 	file
 
 SUBDIRS	= $(LOG_DAEMON_HELPERS)
+EXTRA_DIST = modules.m4
@@ -5,4 +5,4 @@ log_file_daemon_SOURCES = log_file_daemon.cc
 log_file_daemon_LDADD = \
 	-L$(top_builddir)/lib $(COMPAT_LIB) \
 	$(XTRA_LIBS)
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="file"
@@ -0,0 +1,46 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_log_daemon_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_log_daemon_helpers:=yes}" = "xyes" ;then
+  enable_log_daemon_helpers=""
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[enable_log_daemon_helpers])
+fi
+if test "x$enable_log_daemon_helpers" = "xnone" ; then
+  enable_log_daemon_helpers=""
+fi
+
+LOG_DAEMON_HELPERS=""
+enable_log_daemon_helpers="`echo $enable_log_daemon_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_log_daemon_helpers" != "xno"; then
+  for helper in $enable_log_daemon_helpers ; do
+    dir="$srcdir/helpers/log_daemon/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xDB" ; then
+      m4_include([helpers/log_daemon/DB/required.m4])
+
+    elif test "x$helper" = "xfile" ; then
+      m4_include([helpers/log_daemon/file/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/log_daemon/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
+      else
+       LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([Log daemon helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([Log daemon helpers to be built: $LOG_DAEMON_HELPERS])
+AC_SUBST(LOG_DAEMON_HELPERS)
@@ -10,4 +10,4 @@ LDADD	= \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = readme.txt config.test
+EXTRA_DIST = readme.txt required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README COPYING config.test negotiate_kerberos_auth.8
+EXTRA_DIST = README COPYING required.m4 negotiate_kerberos_auth.8
 SUBDIRS = 
 
 libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
@@ -1,6 +0,0 @@
-#!/bin/sh
-# Don't build without gssapi.h
-if test -f /usr/include/gssapi/gssapi.h || test -f  /usr/include/gssapi.h || test -f /usr/include/kerberosV/gssapi.h ; then
-       exit 0
-fi
-exit 1
@@ -0,0 +1,2 @@
+# FIXME: use other kerberos library checks from main configure.ac
+AC_CHECK_HEADERS([gssapi/gssapi.h gssapi.h kerberosV/gssapi.h],[BUILD_HELPER="kerberos"])
@@ -0,0 +1,61 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_negotiate list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_negotiate" = "x"; then
+    enable_auth_negotiate=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_negotiate" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
+fi
+#handle the "none" special case
+if test "x$enable_auth_negotiate" = "xnone" ; then
+    enable_auth_negotiate=""
+fi
+
+NEGOTIATE_AUTH_HELPERS=""
+enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_negotiate" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES negotiate"
+    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
+    for helper in $enable_auth_negotiate; do
+      dir="$srcdir/helpers/negotiate_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/negotiate_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xkerberos" ; then
+        m4_include([helpers/negotiate_auth/kerberos/required.m4])
+
+      elif test "x$helper" = "xwrapper" ; then
+        m4_include([helpers/negotiate_auth/wrapper/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/negotiate_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
+        else
+          NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Negotiate auth helper $helper ... not found])
+      fi
+    done
+fi
+
+AC_MSG_NOTICE([Negotiate auth helpers to be built: $NEGOTIATE_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
+AC_SUBST(NEGOTIATE_AUTH_HELPERS)
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 
 libexec_PROGRAMS = negotiate_wrapper_auth
 
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="wrapper"
@@ -1,2 +1,3 @@
 DIST_SUBDIRS	= fake smb_lm SSPI
 SUBDIRS		= $(NTLM_AUTH_HELPERS)
+EXTRA_DIST	= modules.m4
@@ -14,4 +14,4 @@ LDADD = \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = ntlm_sspi_auth.8 config.test
+EXTRA_DIST = ntlm_sspi_auth.8 required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -16,5 +16,5 @@ INCLUDES += -I$(top_srcdir)/lib
 ## ntlm_fake_auth.pl: ntlm_fake_auth.pl.in
 ##	$(subst_perlshell)
 
-EXTRA_DIST = config.test \
+EXTRA_DIST = required.m4 \
 	ntlm_fake_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -0,0 +1,61 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_ntlm list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_ntlm" = "x"; then
+    enable_auth_ntlm=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([NTLM auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_ntlm" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
+fi
+#handle the "none" special case
+if test "x$enable_auth_ntlm" = "xnone" ; then
+    enable_auth_ntlm=""
+fi
+
+NTLM_AUTH_HELPERS=""
+#enable_auth_ntlm contains either "no" or the list of modules to be built
+enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_ntlm" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES ntlm"
+    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
+    for helper in $enable_auth_ntlm; do
+      dir="$srcdir/helpers/ntlm_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xfake" ; then
+        m4_include([helpers/ntlm_auth/fake/required.m4])
+
+      elif test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/ntlm_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xsmb_lm" ; then
+        m4_include([helpers/ntlm_auth/smb_lm/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/ntlm_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
+        else
+          NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([NTLM auth helper $helper ... not found])
+      fi
+    done
+fi
+AC_MSG_NOTICE([NTLM auth helpers to be built: $NTLM_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
+AC_SUBST(NTLM_AUTH_HELPERS)
@@ -14,4 +14,4 @@ ntlm_smb_lm_auth_LDADD = \
 
 INCLUDES += -I$(top_srcdir)/lib
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Don't build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 1
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 1
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 1
-fi
-exit 0
@@ -0,0 +1,8 @@
+#
+# DONT build this helper on Windows
+#
+# XXX: do we really need the mingw check?
+if test "$squid_host_os" != "mingw"; then
+  BUILD_HELPER="smb_lm"
+  AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
+fi
@@ -7,4 +7,4 @@ url_fake_rewrite_LDADD = $(COMPAT_LIB)
 
 libexec_SCRIPTS = url_fake_rewrite.sh
 
-EXTRA_DIST = url_fake_rewrite.sh config.test
+EXTRA_DIST = url_fake_rewrite.sh required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -0,0 +1,40 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_url_rewrite_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],[enable_url_rewrite_helpers])
+fi
+
+enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
+URL_REWRITE_HELPERS=""
+if test "x$enable_url_rewrite_helpers" != "xno" ; then
+  for helper in $enable_url_rewrite_helpers; do
+    dir="$srcdir/helpers/url_rewrite/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfake" ; then
+      m4_include([helpers/url_rewrite/fake/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/url_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
+      else
+        URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([URL rewrite helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([URL rewrite helpers to be built: $URL_REWRITE_HELPERS])
+AC_SUBST(URL_REWRITE_HELPERS)
@@ -32,7 +32,7 @@
 #ifndef SQUID_STACK_H
 #define SQUID_STACK_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* RBC: 20030714 Composition might be better long-term, but for now,
  * there's no reason to do so.
@@ -11,13 +11,8 @@ typedef int64_t snint;
 
 #include "snmp.h"
 #include "snmp_impl.h"
-#if 0
-#include "asn1.h"
-#endif
 #include "snmp_api.h"
 
-#include "snmp_vars.h"
-
 /* MIB definitions
  * SQUID-MIB
  *      .iso.org.dod.internet.private.enterprises.nlanr.squid
@@ -37,15 +37,7 @@
 #endif
 
 /* These come first */
-#if 0
-#include "asn1.h"
-#endif
 #include "snmp_error.h"
-#if 0
-#include "mibii.h"
-#include "snmp_extra.h"
-#include "snmp_dump.h"
-#endif
 
 /* I didn't touch this */
 #include "snmp_session.h"
@@ -63,10 +55,6 @@
 /* Other stuff I didn't touch */
 #include "snmp_impl.h"
 #include "snmp_api.h"
-#if 0
-#include "snmp_client.h"
-#include "mib.h"
-#endif
 #include "snmp-internal.h"
 #include "parse.h"
 #include "snmp_debug.h"
@@ -1,8 +1,7 @@
 #ifndef SQUID_SPLAY_H
 #define SQUID_SPLAY_H
 
-#ifndef __cplusplus
-#else
+#if defined(__cplusplus)
 
 #include "Stack.h"
 
@@ -78,8 +78,6 @@ TESTS += tests/testAll
 check_PROGRAMS += tests/testAll
 
 tests_testAll_SOURCES= \
-	tests/testArray.h \
-	tests/testArray.cc \
 	tests/testRFC1035.h \
 	tests/testRFC1035.cc \
 	tests/testRFC1738.h \
@@ -1,7 +1,7 @@
 # Process this file with autoconf to produce a configure script.
 AC_INIT(libTrie, 0.1, rbtcollins@squid-cache.org)
 AC_CONFIG_SRCDIR([src/Trie.cc])
-AM_CONFIG_HEADER([config.h])
+AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_AUX_DIR(cfgaux)
 
 enable_inline=${enable_inline:=yes}
@@ -4,6 +4,7 @@
 #if USE_XPROF_STATS
 typedef enum {
     XPROF_PROF_UNACCOUNTED,
+    XPROF_ACL_matches,
     XPROF_HttpHeaderClean,
     XPROF_HttpHeaderParse,
     XPROF_HttpHeader_getCc,
@@ -27,7 +28,6 @@ typedef enum {
     XPROF_StringInitBuf,
     XPROF_StringReset,
     XPROF_aclCheckFast,
-    XPROF_aclMatchAclList,
     XPROF_calloc,
     XPROF_clientSocketRecipient,
     XPROF_commHandleWrite,
@@ -1,22 +0,0 @@
-#define SQUID_UNIT_TEST 1
-#include "squid.h"
-
-#if HAVE_ASSERT_H
-#include <assert.h>
-#endif
-
-#include "testArray.h"
-#include "Array.h"
-
-CPPUNIT_TEST_SUITE_REGISTRATION( testArray );
-
-void testArray::all()
-{
-    CPPUNIT_ASSERT( 1 == 1 );
-    Vector<int> aArray;
-    CPPUNIT_ASSERT (aArray.size() == 0);
-    aArray.push_back(2);
-    CPPUNIT_ASSERT (aArray.size() == 1);
-    CPPUNIT_ASSERT (aArray.back() == 2);
-    CPPUNIT_ASSERT (aArray.size() == 1);
-}
@@ -23,9 +23,9 @@
 		'AsyncCall.* constructed, this=(\S+)',
 		'AsyncCall.* destruct.*, this=(\S+)',
 	],
-	HttpReq => [
-		'\bHttpRequest.* constructed, this=(\S+)',
-		'\bHttpRequest.* destructed, this=(\S+)',
+	HttpHeaderEntry => [
+		'\bHttpHeaderEntry.* created HttpHeaderEntry (\S+)',
+		'\bHttpHeaderEntry.* destroying entry (\S+)',
 	],
 	ClientSocketContext => [
 		'\bClientSocketContext constructing, this=(\S+)',
@@ -37,7 +37,6 @@ AccessLogEntry::~AccessLogEntry()
 #endif
 
     safe_free(headers.reply);
-    safe_free(cache.authuser);
 
     safe_free(headers.adapted_request);
     HTTPMSGUNLOCK(adapted_request);
@@ -153,7 +153,6 @@ class AccessLogEntry: public RefCountable
                 code (LOG_TAG_NONE),
                 msec(0),
                 rfc931 (NULL),
-                authuser (NULL),
                 extuser(NULL),
 #if USE_SSL
                 ssluser(NULL),
@@ -172,7 +171,6 @@ class AccessLogEntry: public RefCountable
         LogTags code;
         int msec;
         const char *rfc931;
-        const char *authuser;
         const char *extuser;
 #if USE_SSL
 
@@ -232,9 +230,9 @@ class AccessLogEntry: public RefCountable
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
-    /// key:value pairs set by note and adaptation_meta directives
-    /// plus key=value pairs returned from URL rewrite/redirect helper
-    NotePairs notes;
+    /// key:value pairs set by squid.conf note directive and
+    /// key=value pairs returned from URL rewrite/redirect helper
+    NotePairs::Pointer notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
@@ -5,7 +5,8 @@
     does not get linked in, because nobody is using these classes by name.
 */
 
-#include "acl/Acl.h"
+#include "acl/AllOf.h"
+#include "acl/AnyOf.h"
 #if USE_SQUID_EUI
 #include "acl/Arp.h"
 #include "acl/Eui64.h"
@@ -37,6 +38,8 @@
 #include "acl/MethodData.h"
 #include "acl/Method.h"
 #include "acl/MyPortName.h"
+#include "acl/Note.h"
+#include "acl/NoteData.h"
 #include "acl/PeerName.h"
 #include "acl/ProtocolData.h"
 #include "acl/Protocol.h"
@@ -181,3 +184,12 @@ ACLMaxUserIP ACLMaxUserIP::RegistryEntry_("max_user_ip");
 
 ACL::Prototype ACLTag::RegistryProtoype(&ACLTag::RegistryEntry_, "tag");
 ACLStrategised<const char *> ACLTag::RegistryEntry_(new ACLStringData, ACLTagStrategy::Instance(), "tag");
+
+ACL::Prototype Acl::AnyOf::RegistryProtoype(&Acl::AnyOf::RegistryEntry_, "any-of");
+Acl::AnyOf Acl::AnyOf::RegistryEntry_;
+
+ACL::Prototype Acl::AllOf::RegistryProtoype(&Acl::AllOf::RegistryEntry_, "all-of");
+Acl::AllOf Acl::AllOf::RegistryEntry_;
+
+ACL::Prototype ACLNote::RegistryProtoype(&ACLNote::RegistryEntry_, "note");
+ACLStrategised<HttpRequest *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteStrategy::Instance(), "note");
@@ -29,6 +29,7 @@
  *
  */
 
+#include "acl/forward.h"
 #include "enums.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
@@ -40,7 +41,6 @@
 #include <openssl/ssl.h>
 #endif
 
-class acl_access;
 class CachePeerDomainList;
 class NeighborTypeDomainList;
 class PeerDigest;
@@ -83,7 +83,7 @@ void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
     }
 
     --pool;
-    aclParseAccessLine(parser, &pools[pool].access);
+    aclParseAccessLine("client_delay_access", parser, &pools[pool].access);
 }
 
 void ClientDelayConfig::clean()
@@ -1,9 +1,10 @@
 #ifndef SQUID_CLIENTDELAYCONFIG_H
 #define SQUID_CLIENTDELAYCONFIG_H
 
-#include "Array.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
+
 class StoreEntry;
-class acl_access;
 class ConfigParser;
 
 /// \ingroup DelayPoolsAPI
@@ -30,8 +30,7 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-/* for Vector<> */
-#include "Array.h"
+#include "base/Vector.h"
 
 class StoreEntry;
 
@@ -188,7 +188,7 @@ ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
 }
 
 const char *
-ConfigParser::QuoteString(String &var)
+ConfigParser::QuoteString(const String &var)
 {
     static String quotedStr;
     const char *s = var.termedBuf();
@@ -77,7 +77,7 @@ class ConfigParser
     /// quotes. TODO: support quoted strings anywhere a token is accepted.
     static void ParseQuotedString(char **var, bool *wasQuoted = NULL);
     static void ParseQuotedString(String *var, bool *wasQuoted = NULL);
-    static const char *QuoteString(String &var);
+    static const char *QuoteString(const String &var);
     static void ParseWordList(wordlist **list);
     static char * strtokFile();
     static void strtokFileUndo();
@@ -4,7 +4,7 @@
 #ifndef SQUID_CPU_AFFINITY_MAP_H
 #define SQUID_CPU_AFFINITY_MAP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 class CpuAffinitySet;
 
@@ -113,7 +113,7 @@ DelayConfig::parsePoolAccess(ConfigParser &parser)
     }
 
     --pool;
-    aclParseAccessLine(parser, &DelayPools::delay_data[pool].access);
+    aclParseAccessLine("delay_access", parser, &DelayPools::delay_data[pool].access);
 }
 
 void
@@ -39,13 +39,12 @@
 
 #if USE_DELAY_POOLS
 #include "CompositePoolNode.h"
+#include "acl/forward.h"
 
 class StoreEntry;
 
 class CommonPool;
 
-class acl_access;
-
 /// \ingroup DelayPoolsAPI
 class DelayPool
 {
@@ -32,6 +32,12 @@
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
+#include "base/Vector.h"
+
+class DelayPool;
+class Updateable;
+class StoreEntry;
+
 /**
  \defgroup DelayPoolsAPI Delay Pools API
  \ingroup Components
@@ -47,14 +53,6 @@ class Updateable
     virtual void update(int) = 0;
 };
 
-/* forward decls */
-class DelayPool;
-class Updateable;
-class StoreEntry;
-
-/* for Vector<> */
-#include "Array.h"
-
 /// \ingroup DelayPoolsAPI
 class DelayPools
 {
@@ -190,10 +190,10 @@ DelayTaggedBucket::~DelayTaggedBucket()
 }
 
 void
-DelayTaggedBucket::stats (StoreEntry *entry) const
+DelayTaggedBucket::stats(StoreEntry *entry) const
 {
-    storeAppendPrintf(entry, " :" SQUIDSTRINGPH , SQUIDSTRINGPRINT(tag));
-    theBucket.stats (entry);
+    storeAppendPrintf(entry, " " SQUIDSTRINGPH ":", SQUIDSTRINGPRINT(tag));
+    theBucket.stats(entry);
 }
 
 DelayTagged::Id::Id(DelayTagged::Pointer aDelayTagged, String &aTag) : theTagged(aDelayTagged)
@@ -41,7 +41,7 @@
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -42,7 +42,7 @@
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -32,7 +32,7 @@
 #ifndef SQUID_DISKIOMODULE_H
 #define SQUID_DISKIOMODULE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* forward decls */
 
@@ -21,6 +21,11 @@
 #include <errno.h>
 #endif
 
+// Some systems such as Hurd provide mmap() API but do not support MAP_NORESERVE
+#ifndef MAP_NORESERVE
+#define MAP_NORESERVE 0
+#endif
+
 CBDATA_CLASS_INIT(MmappedFile);
 
 // helper class to deal with mmap(2) offset alignment and other low-level specs
@@ -31,7 +31,7 @@
 #ifndef SQUID_EVENTLOOP_H
 #define SQUID_EVENTLOOP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
@@ -1,7 +1,7 @@
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /// Counts events, forgetting old ones. Usefull for "3 errors/minute" limits.
 class FadingCounter
@@ -145,16 +145,15 @@ HelperReply::parseResponseKeys()
         *p = '\0';
         ++p;
 
-        const String key(other().content());
+        const char *key = other().content();
 
         // the value may be a quoted string or a token
         const bool urlDecode = (*p != '"'); // check before moving p.
         char *v = strwordtok(NULL, &p);
         if (v != NULL && urlDecode && (p-v) > 2) // 1-octet %-escaped requires 3 bytes
             rfc1738_unescape(v);
-        const String value(v?v:""); // value can be empty, but must not be NULL
 
-        notes.add(key, value);
+        notes.add(key, v ? v : ""); // value can be empty, but must not be NULL
 
         modifiableOther().consume(p - other().content());
         modifiableOther().consumeWhitespacePrefix();
@@ -184,13 +183,9 @@ operator <<(std::ostream &os, const HelperReply &r)
     }
 
     // dump the helper key=pair "notes" list
-    if (r.notes.notes.size() > 0) {
+    if (!r.notes.empty()) {
         os << ", notes={";
-        for (Notes::NotesList::const_iterator m = r.notes.notes.begin(); m != r.notes.notes.end(); ++m) {
-            for (Note::Values::iterator v = (*m)->values.begin(); v != (*m)->values.end(); ++v) {
-                os << ',' << (*m)->key << '=' << ConfigParser::QuoteString((*v)->value);
-            }
-        }
+        os << r.notes.toString("; ");
         os << "}";
     }
 
@@ -65,7 +65,7 @@ class HelperReply
     } result;
 
     // list of key=value pairs the helper produced
-    Notes notes;
+    NotePairs notes;
 
     /// for stateful replies the responding helper 'server' needs to be preserved across callbacks
     CbcPointer<helper_stateful_server> whichServer;
@@ -32,7 +32,6 @@
 #ifndef SQUID_HTTPHDRSURROGATECONTROL_H
 #define SQUID_HTTPHDRSURROGATECONTROL_H
 
-#include "dlink.h"
 #include "HttpHdrScTarget.h"
 
 class StatHist;
@@ -441,37 +441,37 @@ HttpHeader::clean()
 
     PROF_start(HttpHeaderClean);
 
-    /*
-     * An unfortunate bug.  The entries array is initialized
-     * such that count is set to zero.  httpHeaderClean() seems to
-     * be called both when 'hdr' is created, and destroyed.  Thus,
-     * we accumulate a large number of zero counts for 'hdr' before
-     * it is ever used.  Can't think of a good way to fix it, except
-     * adding a state variable that indicates whether or not 'hdr'
-     * has been used.  As a hack, just never count zero-sized header
-     * arrays.
-     */
-
     if (owner <= hoReply) {
+        /*
+         * An unfortunate bug.  The entries array is initialized
+         * such that count is set to zero.  httpHeaderClean() seems to
+         * be called both when 'hdr' is created, and destroyed.  Thus,
+         * we accumulate a large number of zero counts for 'hdr' before
+         * it is ever used.  Can't think of a good way to fix it, except
+         * adding a state variable that indicates whether or not 'hdr'
+         * has been used.  As a hack, just never count zero-sized header
+         * arrays.
+         */
         if (0 != entries.count)
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
 
         ++ HttpHeaderStats[owner].destroyedCount;
 
         HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
+    } // if (owner <= hoReply)
 
-        while ((e = getEntry(&pos))) {
-            /* tmp hack to try to avoid coredumps */
+    while ((e = getEntry(&pos))) {
+        /* tmp hack to try to avoid coredumps */
 
-            if (e->id < 0 || e->id >= HDR_ENUM_END) {
-                debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
-            } else {
+        if (e->id < 0 || e->id >= HDR_ENUM_END) {
+            debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
+        } else {
+            if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
-                /* yes, this deletion leaves us in an inconsistent state */
-                delete e;
-            }
+            /* yes, this deletion leaves us in an inconsistent state */
+            delete e;
         }
-    } // if (owner <= hoReply)
+    }
     entries.clean();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
@@ -1741,6 +1741,7 @@ httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
     storeAppendPrintf(e, "%2s\t %-5s\t %5s\t %6s\n",
                       "id", "#flds", "count", "%total");
     hs->hdrUCountDistr.dump(e, httpHeaderFldsPerHdrDumper);
+    storeAppendPrintf(e, "\n");
     dump_stat = NULL;
 }
 
@@ -1762,7 +1763,6 @@ httpHeaderStoreReport(StoreEntry * e)
 
     for (i = 1; i < HttpHeaderStatCount; ++i) {
         httpHeaderStatDump(HttpHeaderStats + i, e);
-        storeAppendPrintf(e, "%s\n", "<br>");
     }
 
     /* field stats for all messages */
@@ -176,7 +176,6 @@ typedef enum {
 #if USE_SSL
     hoErrorDetail,
 #endif
-    hoNote,
     hoEnd
 } http_hdr_owner_type;
 
@@ -32,7 +32,7 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "MemPool.h"
 #include "Packer.h"
 #include "Range.h"
@@ -1,10 +1,14 @@
 #ifndef SQUID_HTTPHEADERTOOLS_H
 #define SQUID_HTTPHEADERTOOLS_H
 
+#include "acl/forward.h"
 #include "format/Format.h"
 #include "HttpHeader.h"
 #include "typedefs.h"
 
+#if HAVE_FUNCTIONAL
+#include <functional>
+#endif
 #if HAVE_LIST
 #include <list>
 #endif
@@ -14,9 +18,10 @@
 #if HAVE_STRING
 #include <string>
 #endif
+#if HAVE_STRINGS_H
+#include <strings.h>
+#endif
 
-class acl_access;
-class ACLList;
 class HeaderWithAcl;
 class HttpHeader;
 class HttpHeaderFieldInfo;
@@ -56,8 +61,18 @@ class HeaderManglers
     void dumpReplacement(StoreEntry *entry, const char *optionName) const;
 
 private:
+    /// Case-insensitive std::string "less than" comparison functor.
+    /// Fast version recommended by Meyers' "Effective STL" for ASCII c-strings.
+    class NoCaseLessThan: public std::binary_function<std::string, std::string, bool>
+    {
+    public:
+        bool operator()(const std::string &lhs, const std::string &rhs) const {
+            return strcasecmp(lhs.c_str(), rhs.c_str()) < 0;
+        }
+    };
+
     /// a name:mangler map; optimize: use unordered map or some such
-    typedef std::map<std::string, headerMangler> ManglersByName;
+    typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
     headerMangler known[HDR_ENUM_END];
@@ -37,7 +37,6 @@
 #include "HttpRequestMethod.h"
 #include "http/StatusCode.h"
 #include "http/ProtocolVersion.h"
-#include "typedefs.h"
 
 /// common parts of HttpRequest and HttpReply
 class HttpMsg : public RefCountable
@@ -58,15 +58,13 @@
 #endif
 
 HttpRequest::HttpRequest() :
-        HttpMsg(hoRequest),
-        helperNotes(NULL)
+        HttpMsg(hoRequest)
 {
     init();
 }
 
 HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
-        HttpMsg(hoRequest),
-        helperNotes(NULL)
+        HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
@@ -168,10 +166,7 @@ HttpRequest::clean()
 
     myportname.clean();
 
-    if (helperNotes) {
-        delete helperNotes;
-        helperNotes = NULL;
-    }
+    notes = NULL;
 
     tag.clean();
 #if USE_AUTH
@@ -231,10 +226,6 @@ HttpRequest::clone() const
     // XXX: what to do with copy->peer_domain?
 
     copy->myportname = myportname;
-    if (helperNotes) {
-        copy->helperNotes = new Notes;
-        copy->helperNotes->notes = helperNotes->notes;
-    }
     copy->tag = tag;
 #if USE_AUTH
     copy->extacl_user = extacl_user;
@@ -283,6 +274,7 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
+    notes = aReq->notes;
     return true;
 }
 
@@ -596,7 +588,7 @@ HttpRequest::maybeCacheable()
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoofClientIp))
+    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))
         return false;
 
     switch (protocol) {
@@ -203,7 +203,7 @@ class HttpRequest: public HttpMsg
 
     String myportname; // Internal tag name= value from port this requests arrived in.
 
-    Notes *helperNotes;         ///< collection of meta notes associated with this request by helper lookups.
+    NotePairs::Pointer notes; ///< annotations added by the note directive and helpers
 
     String tag;			/* Internal tag for this request */
 
@@ -620,7 +620,6 @@ squid_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	$(DISK_LIBS) \
@@ -984,7 +983,7 @@ test_cache_digest: test_cache_digest.o CacheDigest.o debug.o globals.o store_key
 cache_cf.o: cf_parser.cci
 
 # cf_gen builds the configuration files.
-cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES)
+cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES) cf_gen_defines.cci
 	$(HOSTCXX) -o $@ $(srcdir)/cf_gen.cc -I$(srcdir) -I$(top_builddir)/include/ -I$(top_builddir)/src
 
 # squid.conf.default is built by cf_gen when making cf_parser.cci
@@ -994,7 +993,9 @@ squid.conf.default squid.conf.documented: cf_parser.cci
 cf_parser.cci: cf.data cf_gen$(EXEEXT)
 	./cf_gen$(EXEEXT) cf.data $(srcdir)/cf.data.depend
 
-cf_gen_defines.cci: $(srcdir)/cf_gen_defines $(srcdir)/cf.data.pre
+# The cf_gen_defines.cci is auto-generated and does not exist when the 
+# dependencies computed. We need to add its include files (autoconf.h) here
+cf_gen_defines.cci: $(srcdir)/cf_gen_defines $(srcdir)/cf.data.pre $(top_builddir)/include/autoconf.h
 	$(AWK) -f $(srcdir)/cf_gen_defines <$(srcdir)/cf.data.pre >$@ || ($(RM) -f $@ && exit 1)
 
 
@@ -1096,6 +1097,7 @@ check_PROGRAMS+=\
 	tests/testSBuf \
 	tests/testConfigParser \
 	tests/testStatHist \
+	tests/testVector \
 	$(STORE_TESTS)
 
 ## NP: required to run the above list. check_PROGRAMS only builds the binaries...
@@ -1290,6 +1292,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
+	tests/stub_client_side.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
@@ -1493,6 +1496,7 @@ tests_testCacheManager_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1587,7 +1591,6 @@ tests_testCacheManager_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -1596,6 +1599,7 @@ tests_testCacheManager_LDADD = \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
+	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
@@ -1729,6 +1733,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
@@ -1769,7 +1774,6 @@ tests_testDiskIO_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	libsquid.la \
@@ -1907,6 +1911,7 @@ tests_testEvent_SOURCES = \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1984,6 +1989,7 @@ tests_testEvent_SOURCES = \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2010,7 +2016,6 @@ tests_testEvent_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2150,6 +2155,7 @@ tests_testEventLoop_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
@@ -2230,6 +2236,7 @@ tests_testEventLoop_SOURCES = \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2256,7 +2263,6 @@ tests_testEventLoop_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2393,6 +2399,7 @@ tests_test_http_range_SOURCES = \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
@@ -2469,6 +2476,7 @@ tests_test_http_range_SOURCES = \
 	SwapDir.cc \
 	tests/test_http_range.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
@@ -2496,7 +2504,6 @@ tests_test_http_range_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2592,6 +2599,7 @@ tests_testHttpRequest_SOURCES = \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	BodyPipe.cc \
@@ -2683,6 +2691,7 @@ tests_testHttpRequest_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -2774,7 +2783,6 @@ tests_testHttpRequest_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2907,6 +2915,7 @@ tests_testStore_SOURCES= \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -2955,7 +2964,6 @@ tests_testStore_LDADD= \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3026,7 +3034,6 @@ SWAP_TEST_DS =\
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3048,6 +3055,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
@@ -3181,7 +3189,6 @@ tests_testUfs_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3324,6 +3331,7 @@ tests_testRock_SOURCES = \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
@@ -3366,7 +3374,6 @@ tests_testRock_LDADD = \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
-	eui/libeui.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	base/libbase.la \
@@ -3395,6 +3402,7 @@ tests_testCoss_SOURCES = \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_pconn.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
@@ -3518,7 +3526,6 @@ tests_testCoss_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3653,6 +3660,7 @@ tests_testURL_SOURCES = \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -3909,6 +3917,21 @@ tests_testStatHist_LDADD = \
 	$(COMPAT_LIB)
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testVector_SOURCES = \
+	tests/testVector.cc \
+	tests/testMain.cc \
+	tests/testVector.h \
+	time.cc
+nodist_tests_testVector_SOURCES = \
+	$(TESTSOURCES)
+tests_testVector_LDADD= \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+tests_testVector_LDFLAGS = $(LIBADD_DL)
+tests_testVector_DEPENDENCIES = \
+	$(SQUID_CPPUNIT_LA)
+
 
 TESTS += testHeaders
 
@@ -29,13 +29,15 @@
 
 #include "squid.h"
 #include "globals.h"
+#include "AccessLogEntry.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "SquidConfig.h"
 #include "Store.h"
+#include "StrList.h"
 
 #include <algorithm>
 #include <string>
@@ -74,59 +76,19 @@ Note::match(HttpRequest *request, HttpReply *reply)
 }
 
 Note::Pointer
-Notes::find(const String &noteKey) const
+Notes::add(const String &noteKey)
 {
-    typedef Notes::NotesList::const_iterator AMLI;
+    typedef Notes::NotesList::iterator AMLI;
     for (AMLI i = notes.begin(); i != notes.end(); ++i) {
         if ((*i)->key == noteKey)
             return (*i);
     }
 
-    return Note::Pointer();
-}
-
-void
-Notes::add(const String &noteKey, const String &noteValue)
-{
-    Note::Pointer key = add(noteKey);
-    key->addValue(noteValue);
-}
-
-Note::Pointer
-Notes::add(const String &noteKey)
-{
-    Note::Pointer note = find(noteKey);
-    if (note == NULL) {
-        note = new Note(noteKey);
-        notes.push_back(note);
-    }
+    Note::Pointer note = new Note(noteKey);
+    notes.push_back(note);
     return note;
 }
 
-void
-Notes::add(const Notes &src)
-{
-    typedef Notes::NotesList::const_iterator AMLI;
-    typedef Note::Values::iterator VLI;
-
-    for (AMLI i = src.notes.begin(); i != src.notes.end(); ++i) {
-
-        // ensure we have a key by that name to fill out values for...
-        // NP: not sharing pointers at the key level since merging other helpers
-        // details later would affect this src objects keys, which is a bad idea.
-        Note::Pointer ourKey = add((*i)->key);
-
-        // known key names, merge the values lists...
-        for (VLI v = (*i)->values.begin(); v != (*i)->values.end(); ++v ) {
-            // 2012-11-29: values are read-only and Pointer can safely be shared
-            // for now we share pointers to save memory and gain speed.
-            // If that ever ceases to be true, convert this to a full copy.
-            ourKey->values.push_back(*v);
-            // TODO: prune/skip duplicates ?
-        }
-    }
-}
-
 Note::Pointer
 Notes::parse(ConfigParser &parser)
 {
@@ -135,7 +97,11 @@ Notes::parse(ConfigParser &parser)
     ConfigParser::ParseQuotedString(&value);
     Note::Pointer note = add(key);
     Note::Value::Pointer noteValue = note->addValue(value);
-    aclParseAclList(parser, &noteValue->aclList);
+
+    String label(key);
+    label.append('=');
+    label.append(value);
+    aclParseAclList(parser, &noteValue->aclList, label.termedBuf());
 
     if (blacklisted) {
         for (int i = 0; blacklisted[i] != NULL; ++i) {
@@ -170,3 +136,98 @@ Notes::clean()
 {
     notes.clean();
 }
+
+NotePairs::~NotePairs()
+{
+    while (!entries.empty())
+        delete entries.pop_back();
+}
+
+const char *
+NotePairs::find(const char *noteKey) const
+{
+    static String value;
+    value.clean();
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        if ((*i)->name.cmp(noteKey) == 0) {
+            if (value.size())
+                value.append(", ");
+            value.append(ConfigParser::QuoteString((*i)->value));
+        }
+    }
+    return value.size() ? value.termedBuf() : NULL;
+}
+
+const char *
+NotePairs::toString(const char *sep) const
+{
+    static String value;
+    value.clean();
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        value.append((*i)->name);
+        value.append(": ");
+        value.append(ConfigParser::QuoteString((*i)->value));
+        value.append(sep);
+    }
+    return value.size() ? value.termedBuf() : NULL;
+}
+
+const char *
+NotePairs::findFirst(const char *noteKey) const
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        if ((*i)->name.cmp(noteKey) == 0)
+            return (*i)->value.termedBuf();
+    }
+    return NULL;
+}
+
+void
+NotePairs::add(const char *key, const char *note)
+{
+    entries.push_back(new NotePairs::Entry(key, note));
+}
+
+void
+NotePairs::addStrList(const char *key, const char *values)
+{
+    String strValues(values);
+    const char *item;
+    const char *pos = NULL;
+    int ilen = 0;
+    while (strListGetItem(&strValues, ',', &item, &ilen, &pos)) {
+        String v;
+        v.append(item, ilen);
+        entries.push_back(new NotePairs::Entry(key, v.termedBuf()));
+    }
+}
+
+bool
+NotePairs::hasPair(const char *key, const char *value) const
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        if ((*i)->name.cmp(key) == 0 || (*i)->value.cmp(value) == 0)
+            return true;
+    }
+    return false;
+}
+
+void
+NotePairs::append(const NotePairs *src)
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+        entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
+    }
+}
+
+NotePairs &
+SyncNotes(AccessLogEntry &ale, HttpRequest &request)
+{
+    if (!ale.notes) {
+        assert(!request.notes);
+        ale.notes = request.notes = new NotePairs;
+    } else {
+        assert(ale.notes == request.notes);
+    }
+    return *ale.notes;
+}
@@ -1,8 +1,12 @@
 #ifndef SQUID_NOTES_H
 #define SQUID_NOTES_H
 
-#include "HttpHeader.h"
-#include "HttpHeaderTools.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
+#include "base/RefCount.h"
+#include "CbDataList.h"
+#include "MemPool.h"
+#include "SquidString.h"
 #include "typedefs.h"
 
 #if HAVE_STRING
@@ -13,10 +17,10 @@ class HttpRequest;
 class HttpReply;
 
 /**
- * Used to store notes. The notes are custom key:value pairs
- * ICAP request headers or ECAP options used to pass
+ * Used to store a note configuration. The notes are custom key:value
+ * pairs ICAP request headers or ECAP options used to pass
  * custom transaction-state related meta information to squid
- * internal subsystems or to addaptation services.
+ * internal subsystems or to adaptation services.
  */
 class Note: public RefCountable
 {
@@ -49,18 +53,13 @@ class Note: public RefCountable
      */
     const char *match(HttpRequest *request, HttpReply *reply);
 
-    /**
-     * Returns the first value for this key or an empty string.
-     */
-    const char *firstValue() const { return (values.size()>0&&values[0]->value.defined()?values[0]->value.termedBuf():""); }
-
     String key; ///< The note key
     Values values; ///< The possible values list for the note
 };
 
 class ConfigParser;
 /**
- * Used to store a notes list.
+ * Used to store a notes configuration list.
  */
 class Notes
 {
@@ -90,29 +89,6 @@ class Notes
     /// return true if the notes list is empty
     bool empty() { return notes.empty(); }
 
-    /**
-     * Adds a note key and value to the notes list.
-     * If the key name already exists in list, add the given value to its set of values.
-     */
-    void add(const String &noteKey, const String &noteValue);
-
-    /**
-     * Adds a set of notes from another notes list to this set.
-     * Creating entries for any new keys needed.
-     * If the key name already exists in list, add the given value to its set of values.
-     *
-     * WARNING:
-     * The list entries are all of shared Pointer type. Altering the src object(s) after
-     * using this function will update both Notes lists. Likewise, altering this
-     * destination NotesList will affect any relevant copies of src still in use.
-     */
-    void add(const Notes &src);
-
-    /**
-     * Returns a pointer to an existing Note with given key name or nil.
-     */
-    Note::Pointer find(const String &noteKey) const;
-
     NotesList notes; ///< The Note::Pointer objects array list
     const char *descr; ///< A short description for notes list
     const char **blacklisted; ///< Null terminated list of blacklisted note keys
@@ -126,22 +102,83 @@ class Notes
     Note::Pointer add(const String &noteKey);
 };
 
-class NotePairs : public HttpHeader
+/**
+ * Used to store list of notes
+ */
+class NotePairs: public RefCountable
 {
 public:
-    NotePairs() : HttpHeader(hoNote) {}
-
-    /// convert a NotesList into a NotesPairs
-    /// appending to any existing entries already present
-    void append(const Notes::NotesList &src) {
-        for (Notes::NotesList::const_iterator m = src.begin(); m != src.end(); ++m)
-            for (Note::Values::iterator v =(*m)->values.begin(); v != (*m)->values.end(); ++v)
-                putExt((*m)->key.termedBuf(), (*v)->value.termedBuf());
-    }
-
-    void append(const NotePairs *src) {
-        HttpHeader::append(dynamic_cast<const HttpHeader*>(src));
-    }
+    typedef RefCount<NotePairs> Pointer;
+
+    /**
+     * Used to store a note key/value pair.
+     */
+    class Entry
+    {
+    public:
+        Entry(const char *aKey, const char *aValue): name(aKey), value(aValue) {}
+        String name;
+        String value;
+        MEMPROXY_CLASS(Entry);
+    };
+
+    ~NotePairs();
+
+    /**
+     * Append the entries of the src NotePairs list to our list.
+     */
+    void append(const NotePairs *src);
+
+    /**
+     * Returns a comma separated list of notes with key 'noteKey'.
+     * Use findFirst instead when a unique kv-pair is needed.
+     */
+    const char *find(const char *noteKey) const;
+
+    /**
+     * Returns the first note value for this key or an empty string.
+     */
+    const char *findFirst(const char *noteKey) const;
+
+    /**
+     * Adds a note key and value to the notes list.
+     * If the key name already exists in list, add the given value to its set
+     * of values.
+     */
+    void add(const char *key, const char *value);
+
+    /**
+     * Adds a note key and values strList to the notes list.
+     * If the key name already exists in list, add the new values to its set
+     * of values.
+     */
+    void addStrList(const char *key, const char *values);
+
+    /**
+     * Return true if the key/value pair is already stored
+     */
+    bool hasPair(const char *key, const char *value) const;
+
+    /**
+     * Convert NotePairs list to a string consist of "Key: Value"
+     * entries separated by sep string.
+     */
+    const char *toString(const char *sep = "\r\n") const;
+
+    /**
+     * True if there are not entries in the list
+     */
+    bool empty() const {return entries.empty();}
+
+    Vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
 };
 
+MEMPROXY_CLASS_INLINE(NotePairs::Entry);
+
+class AccessLogEntry;
+/**
+ * Keep in sync HttpRequest and the corresponding AccessLogEntry objects
+ */
+NotePairs &SyncNotes(AccessLogEntry &ale, HttpRequest &request);
+
 #endif
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "cache_cf.h"
 #include "compat/strtoll.h"
+#include "ConfigParser.h"
 #include "Parsing.h"
 #include "globals.h"
 #include "Debug.h"
@@ -75,9 +76,9 @@ xatoi(const char *token)
 }
 
 unsigned int
-xatoui(const char *token)
+xatoui(const char *token, char eov)
 {
-    int64_t input = xatoll(token, 10);
+    int64_t input = xatoll(token, 10, eov);
     if (input < 0) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The input value '" << token << "' cannot be less than 0.");
         self_destruct();
@@ -107,7 +108,7 @@ xatol(const char *token)
 }
 
 int64_t
-xatoll(const char *token, int base)
+xatoll(const char *token, int base, char eov)
 {
     char *end = NULL;
     int64_t ret = strtoll(token, &end, base);
@@ -117,7 +118,7 @@ xatoll(const char *token, int base)
         self_destruct();
     }
 
-    if (*end) {
+    if (*end != eov) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid value: '" << token << "' is supposed to be a number.");
         self_destruct();
     }
@@ -161,7 +162,7 @@ GetInteger64(void)
 int
 GetInteger(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::strtokFile();
     int i;
 
     if (token == NULL)
@@ -38,9 +38,9 @@
 
 double xatof(const char *token);
 int xatoi(const char *token);
-unsigned int xatoui(const char *token);
+unsigned int xatoui(const char *token, char eov = '\0');
 long xatol(const char *token);
-int64_t xatoll(const char *token, int base);
+int64_t xatoll(const char *token, int base, char eov = '\0');
 unsigned short xatos(const char *token);
 
 /**
@@ -34,7 +34,7 @@
 #define   SQUID_PEERSELECTSTATE_H
 
 #include "acl/Checklist.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
@@ -87,7 +87,11 @@ class RequestFlags
     bool intercepted :1;
     /** set if the Host: header passed verification */
     bool hostVerified :1;
-    /** request to spoof the client ip */
+    /// Set for requests handled by a "tproxy" port.
+    bool interceptTproxy :1;
+    /// The client IP address should be spoofed when connecting to the web server.
+    /// This applies to TPROXY traffic that has not had spoofing disabled through
+    /// the spoof_client_ip squid.conf ACL.
     bool spoofClientIp :1;
     /** set if the request is internal (\see ClientHttpRequest::flags.internal)*/
     bool internal :1;
@@ -29,7 +29,7 @@
  *
  */
 
-#include "acl/AclAddress.h"
+#include "acl/forward.h"
 #include "base/RefCount.h"
 #include "ClientDelayConfig.h"
 #include "DelayConfig.h"
@@ -46,9 +46,6 @@ class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
 
-class acl_access;
-class AclSizeLimit;
-class AclDenyInfoList;
 namespace Mgr
 {
 class ActionPasswordList;
@@ -332,7 +329,6 @@ class SquidConfig
 
         int ie_refresh;
         int vary_ignore_expire;
-        int pipeline_prefetch;
         int surrogate_is_remote;
         int request_entities;
         int detect_broken_server_pconns;
@@ -361,6 +357,8 @@ class SquidConfig
         int client_dst_passthru;
     } onoff;
 
+    int pipeline_max_prefetch;
+
     int forward_max_tries;
     int connect_retries;
 
@@ -403,6 +401,10 @@ class SquidConfig
 #if ICAP_CLIENT
         acl_access* icap;
 #endif
+
+        /// spoof_client_ip squid.conf acl.
+        /// nil unless configured
+        acl_access* spoof_client_ip;
     } accessList;
     AclDenyInfoList *denyInfoList;
 
@@ -31,7 +31,7 @@
 #ifndef SQUID_STOREFILESYSTEM_H
 #define SQUID_STOREFILESYSTEM_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* ****** DOCUMENTATION ***** */
 
@@ -1,6 +1,5 @@
 /*
  * DEBUG: section 28    Access Control
- * AUTHOR: Duane Wessels
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -38,6 +37,7 @@
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
+#include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
 const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
@@ -52,8 +52,9 @@ bool ACLFlags::supported(const ACLFlag f) const
 }
 
 void
-ACLFlags::parseFlags(char * &nextToken)
+ACLFlags::parseFlags()
 {
+    char *nextToken;
     while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
 
         //if token is the "--" break flag
@@ -137,7 +138,8 @@ ACL::Factory (char const *type)
 
 ACL::ACL() :
         cfgline(NULL),
-        next(NULL)
+        next(NULL),
+        registered(false)
 {
     *name = 0;
 }
@@ -147,6 +149,46 @@ bool ACL::valid () const
     return true;
 }
 
+bool
+ACL::matches(ACLChecklist *checklist) const
+{
+    PROF_start(ACL_matches);
+    debugs(28, 5, "checking " << name);
+
+    // XXX: AclMatchedName does not contain a matched ACL name when the acl
+    // does not match. It contains the last (usually leaf) ACL name checked
+    // (or is NULL if no ACLs were checked).
+    AclMatchedName = name;
+
+    int result = 0;
+    if (!checklist->hasRequest() && requiresRequest()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an HTTP request. Assuming mismatch.");
+    } else if (!checklist->hasReply() && requiresReply()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an HTTP response. Assuming mismatch.");
+    } else {
+        // have to cast because old match() API is missing const
+        result = const_cast<ACL*>(this)->match(checklist);
+    }
+
+    const char *extra = checklist->asyncInProgress() ? " async" : "";
+    debugs(28, 3, "checked: " << name << " = " << result << extra);
+    PROF_stop(ACL_matches);
+    return result == 1; // true for match; false for everything else
+}
+
+void
+ACL::context(const char *aName, const char *aCfgLine)
+{
+    name[0] = '\0';
+    if (aName)
+        xstrncpy(name, aName, ACL_NAME_SZ-1);
+    safe_free(cfgline);
+    if (aCfgLine)
+        cfgline = xstrdup(aCfgLine);
+}
+
 void
 ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 {
@@ -215,8 +257,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
     if ((A = FindByName(aclname)) == NULL) {
         debugs(28, 3, "aclParseAclLine: Creating ACL '" << aclname << "'");
         A = ACL::Factory(theType);
-        xstrncpy(A->name, aclname, ACL_NAME_SZ);
-        A->cfgline = xstrdup(config_input_line);
+        A->context(aclname, config_input_line);
         new_acl = 1;
     } else {
         if (strcmp (A->typeString(),theType) ) {
@@ -235,8 +276,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
      */
     AclMatchedName = A->name;	/* ugly */
 
-    char *aTok;
-    A->flags.parseFlags(aTok);
+    A->flags.parseFlags();
 
     /*split the function here */
     A->parse();
@@ -259,6 +299,9 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
     }
 
     /* append */
+    assert(head && *head == Config.aclList);
+    A->registered = true;
+
     while (*head)
         head = &(*head)->next;
 
@@ -271,18 +314,6 @@ ACL::isProxyAuth() const
     return false;
 }
 
-ACLList::ACLList() : op (1), _acl (NULL), next (NULL)
-{}
-
-void
-ACLList::negated(bool isNegated)
-{
-    if (isNegated)
-        op = 0;
-    else
-        op = 1;
-}
-
 /* ACL result caching routines */
 
 int
@@ -359,49 +390,6 @@ ACL::requiresRequest() const
     return false;
 }
 
-int
-ACL::checklistMatches(ACLChecklist *checklist)
-{
-    int rv;
-
-    if (!checklist->hasRequest() && requiresRequest()) {
-        debugs(28, DBG_IMPORTANT, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP request -- not matching.");
-        return 0;
-    }
-
-    if (!checklist->hasReply() && requiresReply()) {
-        debugs(28, DBG_IMPORTANT, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP reply -- not matching.");
-        return 0;
-    }
-
-    debugs(28, 3, "ACL::checklistMatches: checking '" << name << "'");
-    rv= match(checklist);
-    debugs(28, 3, "ACL::ChecklistMatches: result for '" << name << "' is " << rv);
-    return rv;
-}
-
-bool
-ACLList::matches (ACLChecklist *checklist) const
-{
-    assert (_acl);
-    // XXX: AclMatchedName does not contain a matched ACL name when the acl
-    // does not match (or contains stale name if no ACLs are checked). In
-    // either case, we get misleading debugging and possibly incorrect error
-    // messages. Unfortunately, deny_info's "when none http_access
-    // lines match" exception essentially requires this mess.
-    // TODO: Rework by using an acl-free deny_info for the no-match cases?
-    AclMatchedName = _acl->name;
-    debugs(28, 3, "ACLList::matches: checking " << (op ? null_string : "!") << _acl->name);
-
-    if (_acl->checklistMatches(checklist) != op) {
-        debugs(28, 4, "ACLList::matches: result is false");
-        return false;
-    }
-
-    debugs(28, 4, "ACLList::matches: result is true");
-    return true;
-}
-
 /*********************/
 /* Destroy functions */
 /*********************/
@@ -410,25 +398,7 @@ ACL::~ACL()
 {
     debugs(28, 3, "ACL::~ACL: '" << cfgline << "'");
     safe_free(cfgline);
-}
-
-/* to be split into separate files in the future */
-
-CBDATA_CLASS_INIT(acl_access);
-
-void *
-acl_access::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(acl_access);
-    acl_access *result = cbdataAlloc(acl_access);
-    return result;
-}
-
-void
-acl_access::operator delete (void *address)
-{
-    acl_access *t = static_cast<acl_access *>(address);
-    cbdataFree(t);
+    AclMatchedName = NULL; // in case it was pointing to our name
 }
 
 ACL::Prototype::Prototype() : prototype (NULL), typeString (NULL) {}
@@ -33,7 +33,8 @@
 #ifndef SQUID_ACL_H
 #define SQUID_ACL_H
 
-#include "Array.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
@@ -47,8 +48,6 @@
 #endif
 
 class ConfigParser;
-class ACLChecklist;
-class ACLList;
 
 typedef char ACLFlag;
 // ACLData Flags
@@ -70,8 +69,8 @@ class ACLFlags
     void makeSet(const ACLFlag f) { flags_ |= flagToInt(f); } ///< Set the given flag
     /// Return true if the given flag is set
     bool isSet(const ACLFlag f) const { return flags_ & flagToInt(f);}
-    /// Parse a flags given in the form -[A..Z|a..z]
-    void parseFlags(char * &nextToken);
+    /// Parse optional flags given in the form -[A..Z|a..z]
+    void parseFlags();
     const char *flagsStr() const; ///< Convert the flags to a string representation
 
 private:
@@ -90,6 +89,9 @@ class ACLFlags
     static const ACLFlag NoFlags[1]; ///< An empty flags list
 };
 
+/// A configurable condition. A node in the ACL expression tree.
+/// Can evaluate itself in FilledChecklist context.
+/// Does not change during evaluation.
 /// \ingroup ACLAPI
 class ACL
 {
@@ -106,17 +108,25 @@ class ACL
     ACL();
     explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs) { memset(name, '\0', sizeof(name)); }
     virtual ~ACL();
+
+    /// sets user-specified ACL name and squid.conf context
+    void context(const char *name, const char *configuration);
+
+    /// Orchestrates matching checklist against the ACL using match(),
+    /// after checking preconditions and while providing debugging.
+    /// Returns true if and only if there was a successful match.
+    /// Updates the checklist state on match, async, and failure.
+    bool matches(ACLChecklist *checklist) const;
+
     virtual ACL *clone()const = 0;
+
+    /// parses node represenation in squid.conf; dies on failures
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
-    virtual bool requiresRequest() const;
-    virtual bool requiresReply() const;
-    virtual int match(ACLChecklist * checklist) = 0;
     virtual wordlist *dump() const = 0;
     virtual bool empty () const = 0;
     virtual bool valid () const;
-    int checklistMatches(ACLChecklist *);
 
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
@@ -127,6 +137,7 @@ class ACL
     char *cfgline;
     ACL *next;
     ACLFlags flags; ///< The list of given ACL flags
+    bool registered; ///< added to Config.aclList and can be reused via by FindByName()
 
 public:
 
@@ -151,6 +162,15 @@ class ACL
         typedef Vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
+
+private:
+    /// Matches the actual data in checklist against this ACL.
+    virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
+
+    /// whether our (i.e. shallow) match() requires checklist to have a request
+    virtual bool requiresRequest() const;
+    /// whether our (i.e. shallow) match() requires checklist to have a reply
+    virtual bool requiresReply() const;
 };
 
 /// \ingroup ACLAPI
@@ -210,39 +230,6 @@ operator <<(std::ostream &o, const allow_t a)
     return o;
 }
 
-/// \ingroup ACLAPI
-class acl_access
-{
-
-public:
-    void *operator new(size_t);
-    void operator delete(void *);
-    allow_t allow;
-    ACLList *aclList;
-    char *cfgline;
-    acl_access *next;
-
-private:
-    CBDATA_CLASS(acl_access);
-};
-
-/// \ingroup ACLAPI
-class ACLList
-{
-
-public:
-    MEMPROXY_CLASS(ACLList);
-
-    ACLList();
-    void negated(bool isNegated);
-    bool matches (ACLChecklist *)const;
-    int op;
-    ACL *_acl;
-    ACLList *next;
-};
-
-MEMPROXY_CLASS_INLINE(ACLList);
-
 /// \ingroup ACLAPI
 class acl_proxy_auth_match_cache
 {
@@ -29,7 +29,7 @@
  *
  */
 
-#include "defines.h"
+#include "acl/forward.h"
 
 /// list of name-based ACLs. Currently a POD.
 class AclNameList
@@ -29,7 +29,8 @@
  *
  */
 
-class ACLList;
+#include "acl/forward.h"
+
 /// representation of a class of Size-limit ACLs
 // a POD. TODO: convert to new ACL framework
 class AclSizeLimit
@@ -0,0 +1,82 @@
+#include "squid.h"
+#include "acl/AllOf.h"
+#include "acl/Checklist.h"
+#include "acl/BoolOps.h"
+#include "globals.h"
+#include "MemBuf.h"
+
+char const *
+Acl::AllOf::typeString() const
+{
+    return "all-of";
+}
+
+ACL *
+Acl::AllOf::clone() const
+{
+    return new AllOf;
+}
+
+wordlist*
+Acl::AllOf::dump() const
+{
+    return empty() ? NULL : nodes.front()->dump();
+}
+
+int
+Acl::AllOf::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    assert(start == nodes.begin()); // we only have one node
+
+    // avoid dereferencing invalid start
+    if (empty())
+        return 1; // not 0 because in math empty product equals identity
+
+    if (checklist->matchChild(this, start, *start))
+        return 1; // match
+
+    return checklist->keepMatching() ? 0 : -1;
+}
+
+// called once per "acl name all-of name1 name2 ...." line
+void
+Acl::AllOf::parse()
+{
+    Acl::InnerNode *whole = NULL;
+    ACL *oldNode = empty() ? NULL : nodes.front();
+
+    // optimization: this logic reduces subtree hight (number of tree levels)
+    if (Acl::OrNode *oldWhole = dynamic_cast<Acl::OrNode*>(oldNode)) {
+        // this acl saw multiple lines before; add another one to the old node
+        whole = oldWhole;
+    } else if (oldNode) {
+        // this acl saw a single line before; create a new OR inner node
+
+        MemBuf wholeCtx;
+        wholeCtx.init();
+        wholeCtx.Printf("(%s lines)", name);
+        wholeCtx.terminate();
+
+        Acl::OrNode *newWhole = new Acl::OrNode;
+        newWhole->context(wholeCtx.content(), oldNode->cfgline);
+        newWhole->add(oldNode); // old (i.e. first) line
+        nodes.front() = whole = newWhole;
+    } else {
+        // this is the first line for this acl; just use it as is
+        whole = this;
+    }
+
+    assert(whole);
+    const int lineId = whole->childrenCount() + 1;
+
+    MemBuf lineCtx;
+    lineCtx.init();
+    lineCtx.Printf("(%s line #%d)", name, lineId);
+    lineCtx.terminate();
+
+    Acl::AndNode *line = new AndNode;
+    line->context(lineCtx.content(), config_input_line);
+    line->lineParse();
+
+    whole->add(line);
+}
@@ -0,0 +1,34 @@
+#ifndef SQUID_ACL_ALL_OF_H
+#define SQUID_ACL_ALL_OF_H
+
+#include "acl/InnerNode.h"
+
+namespace Acl
+{
+
+/// Configurable all-of ACL. Each ACL line is a conjuction of ACLs.
+/// Uses AndNode and OrNode to handle squid.conf configuration where multiple
+/// acl all-of lines are always ORed together.
+class AllOf: public Acl::InnerNode
+{
+public:
+    MEMPROXY_CLASS(AllOf);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+    virtual wordlist *dump() const;
+
+private:
+    /* Acl::InnerNode API */
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+
+    static Prototype RegistryProtoype;
+    static AllOf RegistryEntry_;
+};
+MEMPROXY_CLASS_INLINE(Acl::AllOf);
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_ALL_OF_H */
@@ -0,0 +1,23 @@
+#include "squid.h"
+#include "acl/AnyOf.h"
+
+char const *
+Acl::AnyOf::typeString() const
+{
+    return "any-of";
+}
+
+ACL *
+Acl::AnyOf::clone() const
+{
+    return new AnyOf;
+}
+
+// called once per "acl name any-of name1 name2 ...." line
+// but since multiple lines are ORed, the line boundary does not matter,
+// so we flatten the tree into one line/level here to minimize overheads
+void
+Acl::AnyOf::parse()
+{
+    lineParse();
+}
@@ -0,0 +1,28 @@
+#ifndef SQUID_ACL_ANY_OF_H
+#define SQUID_ACL_ANY_OF_H
+
+#include "acl/BoolOps.h"
+
+namespace Acl
+{
+
+/// Configurable any-of ACL. Each ACL line is a disjuction of ACLs.
+class AnyOf: public Acl::OrNode
+{
+public:
+    MEMPROXY_CLASS(AnyOf);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+
+private:
+    static Prototype RegistryProtoype;
+    static AnyOf RegistryEntry_;
+};
+MEMPROXY_CLASS_INLINE(Acl::AnyOf);
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_ANY_OF_H */
@@ -39,7 +39,7 @@
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
 #include "cache_cf.h"
-#include "forward.h"
+#include "src/forward.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
@@ -636,16 +636,14 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
 
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
-        /* XXX FIXME: allow accessing the acl name here */
-        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState (DestinationIPLookup::Instance());
-    } else {
-        Ip::Address noaddr;
-        noaddr.SetNoAddr();
-        return data->match(noaddr);
+        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
+        if (checklist->goAsync(DestinationIPLookup::Instance()))
+            return -1;
+        // else fall through to noaddr match, hiding the lookup failure (XXX)
     }
-
-    return 0;
+    Ip::Address noaddr;
+    noaddr.SetNoAddr();
+    return data->match(noaddr);
 }
 
 ACLDestinationASNStrategy *
@@ -0,0 +1,136 @@
+#include "squid.h"
+#include "acl/BoolOps.h"
+#include "acl/Checklist.h"
+#include "Debug.h"
+#include "wordlist.h"
+
+/* Acl::NotNode */
+
+Acl::NotNode::NotNode(ACL *acl)
+{
+    assert(acl);
+    name[0] = '!';
+    strncat(&name[1], acl->name, sizeof(name)-1-1);
+    add(acl);
+}
+
+void
+Acl::NotNode::parse()
+{
+    // Not implemented: by the time an upper level parser discovers
+    // an '!' operator, there is nothing left for us to parse.
+    assert(false);
+}
+
+int
+Acl::NotNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    assert(start == nodes.begin()); // we only have one node
+
+    if (checklist->matchChild(this, start, *start))
+        return 0; // converting match into mismatch
+
+    if (!checklist->keepMatching())
+        return -1; // suspend on async calls and stop on failures
+
+    return 1; // converting mismatch into match
+}
+
+char const *
+Acl::NotNode::typeString() const
+{
+    return "!";
+}
+
+ACL *
+Acl::NotNode::clone() const
+{
+    // Not implemented: we are not a named ACL type in squid.conf so nobody
+    // should try to create a NotNode instance by ACL type name (which is
+    // what clone() API is for -- it does not really clone anything).
+    assert(false);
+    return NULL;
+}
+
+wordlist*
+Acl::NotNode::dump() const
+{
+    wordlist *text = NULL;
+    wordlistAdd(&text, name);
+    return text;
+}
+
+/* Acl::AndNode */
+
+char const *
+Acl::AndNode::typeString() const
+{
+    return "and";
+}
+
+ACL *
+Acl::AndNode::clone() const
+{
+    return new AndNode;
+}
+
+int
+Acl::AndNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    // find the first node that does not match
+    for (Nodes::const_iterator i = start; i != nodes.end(); ++i) {
+        if (!checklist->matchChild(this, i, *i))
+            return checklist->keepMatching() ? 0 : -1;
+    }
+
+    // one and not zero on empty because in math empty product equals identity
+    return 1; // no mismatches found (i.e., all kids matched)
+}
+
+void
+Acl::AndNode::parse()
+{
+    // Not implemented: AndNode cannot be configured directly. See Acl::AllOf.
+    assert(false);
+}
+
+/* Acl::OrNode */
+
+char const *
+Acl::OrNode::typeString() const
+{
+    return "any-of";
+}
+
+ACL *
+Acl::OrNode::clone() const
+{
+    return new OrNode;
+}
+
+int
+Acl::OrNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    lastMatch_ = nodes.end();
+
+    // find the first node that matches, but stop if things go wrong
+    for (Nodes::const_iterator i = start; i != nodes.end(); ++i) {
+        if (checklist->matchChild(this, i, *i)) {
+            lastMatch_ = i;
+            return 1;
+        }
+
+        if (!checklist->keepMatching())
+            return -1; // suspend on async calls and stop on failures
+    }
+
+    // zero and not one on empty because in math empty sum equals zero
+    return 0; // all nodes mismatched
+}
+
+void
+Acl::OrNode::parse()
+{
+    // Not implemented: OrNode cannot be configured directly. See Acl::AnyOf.
+    assert(false);
+}
@@ -0,0 +1,74 @@
+#ifndef SQUID_ACL_LOGIC_H
+#define SQUID_ACL_LOGIC_H
+
+#include "acl/InnerNode.h"
+
+/* ACLs defined here are used internally to construct an ACL expression tree.
+ * They cannot be specified directly in squid.conf because squid.conf ACLs are
+ * more complex than (and are implemented using) these operator-like classes.*/
+
+namespace Acl
+{
+
+/// Implements the "not" or "!" operator.
+class NotNode: public InnerNode
+{
+public:
+    MEMPROXY_CLASS(NotNode);
+
+    explicit NotNode(ACL *acl);
+
+private:
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+    virtual wordlist *dump() const;
+
+    /* Acl::InnerNode API */
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+};
+MEMPROXY_CLASS_INLINE(Acl::NotNode);
+
+/// An inner ACL expression tree node representing a boolean conjuction (AND)
+/// operator applied to a list of child tree nodes.
+/// For example, conditions expressed on a single http_access line are ANDed.
+class AndNode: public InnerNode
+{
+public:
+    MEMPROXY_CLASS(AndNode);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+
+private:
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+};
+MEMPROXY_CLASS_INLINE(Acl::AndNode);
+
+/// An inner ACL expression tree node representing a boolean disjuction (OR)
+/// operator applied to a list of child tree nodes.
+/// For example, conditions expressed by multiple http_access lines are ORed.
+class OrNode: public InnerNode
+{
+public:
+    MEMPROXY_CLASS(OrNode);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+
+protected:
+    mutable Nodes::const_iterator lastMatch_;
+
+private:
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+};
+MEMPROXY_CLASS_INLINE(Acl::OrNode);
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_LOGIC_H */
@@ -1,140 +1,49 @@
 /*
  * DEBUG: section 28    Access Control
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "acl/Checklist.h"
+#include "acl/Tree.h"
 #include "Debug.h"
 #include "profiler/Profiler.h"
 
-void
-ACLChecklist::matchNonBlocking()
+/// common parts of nonBlockingCheck() and resumeNonBlockingCheck()
+bool
+ACLChecklist::prepNonBlocking()
 {
-    if (checking())
-        return;
+    assert(accessList);
 
     if (callerGone()) {
         checkCallback(ACCESS_DUNNO); // the answer does not really matter
-        return;
-    }
-
-    /** The ACL List should NEVER be NULL when calling this method.
-     * Always caller should check for NULL and handle appropriate to its needs first.
-     * We cannot select a sensible default for all callers here. */
-    if (accessList == NULL) {
-        debugs(28, DBG_CRITICAL, "SECURITY ERROR: ACL " << this << " checked with nothing to match against!!");
-        checkCallback(ACCESS_DUNNO);
-        return;
+        return false;
     }
 
-    allow_t lastSeenKeyword = ACCESS_DUNNO;
-    /* NOTE: This holds a cbdata reference to the current access_list
-     * entry, not the whole list.
+    /** \par
+     * If the accessList is no longer valid (i.e. its been
+     * freed because of a reconfigure), then bail with ACCESS_DUNNO.
      */
-    while (accessList != NULL) {
-        /** \par
-         * If the _acl_access is no longer valid (i.e. its been
-         * freed because of a reconfigure), then bail with ACCESS_DUNNO.
-         */
-
-        if (!cbdataReferenceValid(accessList)) {
-            cbdataReferenceDone(accessList);
-            debugs(28, 4, "ACLChecklist::check: " << this << " accessList is invalid");
-            checkCallback(ACCESS_DUNNO);
-            return;
-        }
-
-        checking (true);
-        checkAccessList();
-        checking (false);
-
-        if (asyncInProgress()) {
-            return;
-        }
-
-        if (finished()) {
-            /** \par
-             * Either the request is allowed, denied, requires authentication.
-             */
-            debugs(28, 3, "ACLChecklist::check: " << this << " match found, calling back with " << currentAnswer());
-            cbdataReferenceDone(accessList); /* A */
-            checkCallback(currentAnswer());
-            /* From here on in, this may be invalid */
-            return;
-        }
-
-        lastSeenKeyword = accessList->allow;
-
-        /*
-         * Reference the next access entry
-         */
-        const acl_access *A = accessList;
-
-        assert (A);
 
-        accessList = cbdataReference(A->next);
-
-        cbdataReferenceDone(A);
+    if (!cbdataReferenceValid(accessList)) {
+        cbdataReferenceDone(accessList);
+        debugs(28, 4, "ACLChecklist::check: " << this << " accessList is invalid");
+        checkCallback(ACCESS_DUNNO);
+        return false;
     }
 
-    calcImplicitAnswer(lastSeenKeyword);
-    checkCallback(currentAnswer());
-}
-
-bool
-ACLChecklist::asyncNeeded() const
-{
-    return state_ != NullState::Instance();
-}
-
-bool
-ACLChecklist::asyncInProgress() const
-{
-    return async_;
+    return true;
 }
 
 void
-ACLChecklist::asyncInProgress(bool const newAsync)
+ACLChecklist::completeNonBlocking()
 {
-    assert (!finished() && !(asyncInProgress() && newAsync));
-    async_ = newAsync;
-    debugs(28, 3, "ACLChecklist::asyncInProgress: " << this <<
-           " async set to " << async_);
-}
+    assert(!asyncInProgress());
 
-bool
-ACLChecklist::finished() const
-{
-    return finished_;
+    if (!finished())
+        calcImplicitAnswer();
+
+    cbdataReferenceDone(accessList);
+    checkCallback(currentAnswer());
 }
 
 void
@@ -151,177 +60,106 @@ void
 ACLChecklist::preCheck(const char *what)
 {
     debugs(28, 3, HERE << this << " checking " << what);
+    AclMatchedName = NULL;
     finished_ = false;
 }
 
-void
-ACLChecklist::checkAccessList()
-{
-    debugs(28, 3, HERE << this << " checking '" << accessList->cfgline << "'");
-    /* does the current AND clause match */
-    if (matchAclList(accessList->aclList, false))
-        markFinished(accessList->allow, "first matching rule won");
-
-    // If we are not finished() here, the caller must distinguish between
-    // slow async calls and pure rule mismatches using asyncInProgress().
-}
-
-void
-ACLChecklist::checkForAsync()
-{
-    asyncState()->checkForAsync(this);
-}
-
-// ACLFilledChecklist overwrites this to unclock something before we
-// "delete this"
-void
-ACLChecklist::checkCallback(allow_t answer)
+bool
+ACLChecklist::matchChild(const Acl::InnerNode *current, Acl::Nodes::const_iterator pos, const ACL *child)
 {
-    ACLCB *callback_;
-    void *cbdata_;
-    debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
-
-    callback_ = callback;
-    callback = NULL;
-
-    if (cbdataReferenceValidDone(callback_data, &cbdata_))
-        callback_(answer, cbdata_);
+    assert(current && child);
+
+    // Remember the current tree location to prevent "async loop" cases where
+    // the same child node wants to go async more than once.
+    matchLoc_ = Breadcrumb(current, pos);
+
+    // if there are any breadcrumbs left, then follow them on the way down
+    bool result = false;
+    if (matchPath.empty()) {
+        result = child->matches(this);
+    } else {
+        const Breadcrumb top(matchPath.top());
+        assert(child == top.parent);
+        matchPath.pop();
+        result = top.parent->resumeMatchingAt(this, top.position);
+    }
 
-    delete this;
-}
+    if (asyncInProgress()) {
+        // We get here for node N that called goAsync() and then, as the call
+        // stack unwinds, for the nodes higher in the ACL tree that led to N.
+        matchPath.push(Breadcrumb(current, pos));
+    } else {
+        asyncLoc_.clear();
+    }
 
-/// An ACLChecklist::matchNodes() wrapper to simplify profiling.
-bool
-ACLChecklist::matchAclList(const ACLList * head, bool const fast)
-{
-    // TODO: remove by using object con/destruction-based PROF_* macros.
-    PROF_start(aclMatchAclList);
-    const bool result = matchNodes(head, fast);
-    PROF_stop(aclMatchAclList);
+    matchLoc_.clear();
     return result;
 }
 
-/** Returns true if and only if there was a match. If false is returned:
-    finished() indicates an error or exception of some kind, while
-    !finished() means there was a mismatch or an allowed slow async call.
-    If async calls are allowed (i.e. 'fast' was false), then those last
-    two cases can be distinguished using asyncInProgress().
-*/
 bool
-ACLChecklist::matchNodes(const ACLList * head, bool const fast)
+ACLChecklist::goAsync(AsyncState *state)
 {
-    assert(!finished());
-
-    for (const ACLList *node = head; node; node = node->next) {
-
-        const NodeMatchingResult resultBeforeAsync = matchNode(*node, fast);
-
-        if (resultBeforeAsync == nmrMatch)
-            continue;
-
-        if (resultBeforeAsync == nmrMismatch || resultBeforeAsync == nmrFinished)
-            return false;
+    assert(state);
+    assert(!asyncInProgress());
+    assert(matchLoc_.parent);
 
-        assert(resultBeforeAsync == nmrNeedsAsync);
-
-        // Ideally, this should be inside match() itself, but that requires
-        // prohibiting slow ACLs in options that do not support them.
-        // TODO: rename to maybeStartAsync()?
-        checkForAsync();
-
-        // Some match() code claims that an async lookup is needed, but then
-        // fails to start an async lookup when given a chance. We catch such
-        // cases here and call matchNode() again, hoping that some cached data
-        // prevents us from going async again.
-        // This is inefficient and ugly, but fixing all match() code, including
-        // the code it calls, such as ipcache_nbgethostbyname(), takes time.
-        if (!asyncInProgress()) { // failed to start an async operation
+    // TODO: add a once-in-a-while WARNING about fast directive using slow ACL?
+    if (!asyncCaller_) {
+        debugs(28, 2, this << " a fast-only directive uses a slow ACL!");
+        return false;
+    }
 
-            if (finished()) {
-                debugs(28, 3, HERE << this << " finished after failing to go async: " << currentAnswer());
-                return false; // an exceptional case
-            }
+    // TODO: add a once-in-a-while WARNING about async loops?
+    if (matchLoc_ == asyncLoc_) {
+        debugs(28, 2, this << " a slow ACL resumes by going async again!");
+        return false;
+    }
 
-            const NodeMatchingResult resultAfterAsync = matchNode(*node, true);
-            // the second call disables slow checks so we cannot go async again
-            assert(resultAfterAsync != nmrNeedsAsync);
-            if (resultAfterAsync == nmrMatch)
-                continue;
+    asyncLoc_ = matchLoc_; // prevent async loops
 
-            assert(resultAfterAsync == nmrMismatch || resultAfterAsync == nmrFinished);
-            return false;
-        }
+    asyncStage_ = asyncStarting;
+    changeState(state);
+    state->checkForAsync(this); // this is supposed to go async
 
-        assert(!finished()); // async operation is truly asynchronous
-        debugs(28, 3, HERE << this << " awaiting async operation");
+    // Did AsyncState object actually go async? If not, tell the caller.
+    if (asyncStage_ != asyncStarting) {
+        assert(asyncStage_ == asyncFailed);
+        asyncStage_ = asyncNone; // sanity restored
         return false;
     }
 
-    debugs(28, 3, HERE << this << " success: all ACLs matched");
+    // yes, we must pause until the async callback calls resumeNonBlockingCheck
+    asyncStage_ = asyncRunning;
     return true;
 }
 
-/// Check whether a single ACL matches, returning NodeMatchingResult
-ACLChecklist::NodeMatchingResult
-ACLChecklist::matchNode(const ACLList &node, bool const fast)
+// ACLFilledChecklist overwrites this to unclock something before we
+// "delete this"
+void
+ACLChecklist::checkCallback(allow_t answer)
 {
-    const bool nodeMatched = node.matches(this);
-    const bool needsAsync = asyncNeeded();
-    const bool matchFinished = finished();
-
-    debugs(28, 3, HERE << this <<
-           " matched=" << nodeMatched <<
-           " async=" << needsAsync <<
-           " finished=" << matchFinished);
-
-    /* There are eight possible outcomes of the matches() call based on
-       (matched, async, finished) permutations. We support these four:
-       matched,!async,!finished: a match (must check next rule node)
-       !matched,!async,!finished: a mismatch (whole rule fails to match)
-       !matched,!async,finished: error or special condition (propagate)
-       !matched,async,!finished: ACL needs to make an async call (pause)
-     */
-
-    if (nodeMatched) {
-        // matches() should return false in all special cases
-        assert(!needsAsync && !matchFinished);
-        return nmrMatch;
-    }
-
-    if (matchFinished) {
-        // we cannot be done and need an async call at the same time
-        assert(!needsAsync);
-        debugs(28, 3, HERE << this << " exception: " << currentAnswer());
-        return nmrFinished;
-    }
-
-    if (!needsAsync) {
-        debugs(28, 3, HERE << this << " simple mismatch");
-        return nmrMismatch;
-    }
+    ACLCB *callback_;
+    void *cbdata_;
+    debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
 
-    /* we need an async call */
+    callback_ = callback;
+    callback = NULL;
 
-    if (fast) {
-        changeState(NullState::Instance()); // disable async checks
-        markFinished(ACCESS_DUNNO, "async required but prohibited");
-        debugs(28, 3, HERE << this << " DUNNO because cannot async");
-        return nmrFinished;
-    }
+    if (cbdataReferenceValidDone(callback_data, &cbdata_))
+        callback_(answer, cbdata_);
 
-    debugs(28, 3, HERE << this << " going async");
-    return nmrNeedsAsync;
+    delete this;
 }
 
 ACLChecklist::ACLChecklist() :
         accessList (NULL),
         callback (NULL),
         callback_data (NULL),
-        async_(false),
+        asyncCaller_(false),
         finished_(false),
         allow_(ACCESS_DENIED),
-        state_(NullState::Instance()),
-        checking_(false)
+        asyncStage_(asyncNone),
+        state_(NullState::Instance())
 {
 }
 
@@ -334,12 +172,6 @@ ACLChecklist::~ACLChecklist()
     debugs(28, 4, "ACLChecklist::~ACLChecklist: destroyed " << this);
 }
 
-void
-ACLChecklist::AsyncState::changeState (ACLChecklist *checklist, AsyncState *newState) const
-{
-    checklist->changeState(newState);
-}
-
 ACLChecklist::NullState *
 ACLChecklist::NullState::Instance()
 {
@@ -348,7 +180,9 @@ ACLChecklist::NullState::Instance()
 
 void
 ACLChecklist::NullState::checkForAsync(ACLChecklist *) const
-{}
+{
+    assert(false); // or the Checklist will never get out of the async state
+}
 
 ACLChecklist::NullState ACLChecklist::NullState::_instance;
 
@@ -381,21 +215,92 @@ ACLChecklist::nonBlockingCheck(ACLCB * callback_, void *callback_data_)
     preCheck("slow rules");
     callback = callback_;
     callback_data = cbdataReference(callback_data_);
-    matchNonBlocking();
+    asyncCaller_ = true;
+
+    /** The ACL List should NEVER be NULL when calling this method.
+     * Always caller should check for NULL and handle appropriate to its needs first.
+     * We cannot select a sensible default for all callers here. */
+    if (accessList == NULL) {
+        debugs(28, DBG_CRITICAL, "SECURITY ERROR: ACL " << this << " checked with nothing to match against!!");
+        checkCallback(ACCESS_DUNNO);
+        return;
+    }
+
+    if (prepNonBlocking()) {
+        matchAndFinish(); // calls markFinished() on success
+        if (!asyncInProgress())
+            completeNonBlocking();
+    } // else checkCallback() has been called
+}
+
+void
+ACLChecklist::resumeNonBlockingCheck(AsyncState *state)
+{
+    assert(asyncState() == state);
+    changeState(NullState::Instance());
+
+    if (asyncStage_ == asyncStarting) { // oops, we did not really go async
+        asyncStage_ = asyncFailed; // goAsync() checks for that
+        // Do not fall through to resume checks from the async callback. Let
+        // the still-pending(!) goAsync() notice and notify its caller instead.
+        return;
+    }
+    assert(asyncStage_ == asyncRunning);
+    asyncStage_ = asyncNone;
+
+    assert(!matchPath.empty());
+
+    if (!prepNonBlocking())
+        return; // checkCallback() has been called
+
+    if (!finished())
+        matchAndFinish();
+
+    if (asyncInProgress())
+        assert(!matchPath.empty()); // we have breadcrumbs to resume matching
+    else
+        completeNonBlocking();
+}
+
+/// performs (or resumes) an ACL tree match and, if successful, sets the action
+void
+ACLChecklist::matchAndFinish()
+{
+    bool result = false;
+    if (matchPath.empty()) {
+        result = accessList->matches(this);
+    } else {
+        const Breadcrumb top(matchPath.top());
+        matchPath.pop();
+        result = top.parent->resumeMatchingAt(this, top.position);
+    }
+
+    if (result) // the entire tree matched
+        markFinished(accessList->winningAction(), "match");
 }
 
 allow_t const &
-ACLChecklist::fastCheck(const ACLList * list)
+ACLChecklist::fastCheck(const Acl::Tree * list)
 {
     PROF_start(aclCheckFast);
 
     preCheck("fast ACLs");
+    asyncCaller_ = false;
+
+    // This call is not compatible with a pre-set accessList because we cannot
+    // tell whether this Checklist is used by some other concurent call, which
+    // is not supported.
+    assert(!accessList);
+    accessList = cbdataReference(list);
+
+    // assume DENY/ALLOW on mis/matches due to action-free accessList
+    // matchAndFinish() takes care of the ALLOW case
+    if (accessList && cbdataReferenceValid(accessList))
+        matchAndFinish(); // calls markFinished() on success
+    if (!finished())
+        markFinished(ACCESS_DENIED, "ACLs failed to match");
 
-    // assume DENY/ALLOW on mis/matches due to not having acl_access object
-    if (matchAclList(list, true))
-        markFinished(ACCESS_ALLOWED, "all ACLs matched");
-    else if (!finished())
-        markFinished(ACCESS_DENIED, "ACL mismatched");
+    cbdataReferenceDone(accessList);
     PROF_stop(aclCheckFast);
     return currentAnswer();
 }
@@ -409,14 +314,12 @@ ACLChecklist::fastCheck()
     PROF_start(aclCheckFast);
 
     preCheck("fast rules");
+    asyncCaller_ = false;
 
-    allow_t lastSeenKeyword = ACCESS_DUNNO;
     debugs(28, 5, "aclCheckFast: list: " << accessList);
-    const acl_access *acl = cbdataReference(accessList);
-    while (acl != NULL && cbdataReferenceValid(acl)) {
-        // on a match, finish
-        if (matchAclList(acl->aclList, true))
-            markFinished(acl->allow, "first matching rule won");
+    const Acl::Tree *acl = cbdataReference(accessList);
+    if (acl != NULL && cbdataReferenceValid(acl)) {
+        matchAndFinish(); // calls markFinished() on success
 
         // if finished (on a match or in exceptional cases), stop
         if (finished()) {
@@ -425,50 +328,36 @@ ACLChecklist::fastCheck()
             return currentAnswer();
         }
 
-        // on a mismatch, try the next access rule
-        lastSeenKeyword = acl->allow;
-        const acl_access *A = acl;
-        acl = cbdataReference(acl->next);
-        cbdataReferenceDone(A);
+        // fall through for mismatch handling
     }
 
     // There were no rules to match or no rules matched
-    calcImplicitAnswer(lastSeenKeyword);
+    calcImplicitAnswer();
+    cbdataReferenceDone(acl);
     PROF_stop(aclCheckFast);
 
     return currentAnswer();
 }
 
-/// When no rules matched, the answer is the inversion of the last seen rule
-/// action (or ACCESS_DUNNO if the reversal is not possible). The caller
-/// should set lastSeenAction to ACCESS_DUNNO if there were no rules to see.
+/// When no rules matched, the answer is the inversion of the last rule
+/// action (or ACCESS_DUNNO if the reversal is not possible).
 void
-ACLChecklist::calcImplicitAnswer(const allow_t &lastSeenAction)
+ACLChecklist::calcImplicitAnswer()
 {
+    const allow_t lastAction = (accessList && cbdataReferenceValid(accessList)) ?
+                               accessList->lastAction() : allow_t(ACCESS_DUNNO);
     allow_t implicitRuleAnswer = ACCESS_DUNNO;
-    if (lastSeenAction == ACCESS_DENIED) // reverse last seen "deny"
+    if (lastAction == ACCESS_DENIED) // reverse last seen "deny"
         implicitRuleAnswer = ACCESS_ALLOWED;
-    else if (lastSeenAction == ACCESS_ALLOWED) // reverse last seen "allow"
+    else if (lastAction == ACCESS_ALLOWED) // reverse last seen "allow"
         implicitRuleAnswer = ACCESS_DENIED;
     // else we saw no rules and will respond with ACCESS_DUNNO
 
     debugs(28, 3, HERE << this << " NO match found, last action " <<
-           lastSeenAction << " so returning " << implicitRuleAnswer);
+           lastAction << " so returning " << implicitRuleAnswer);
     markFinished(implicitRuleAnswer, "implicit rule won");
 }
 
-bool
-ACLChecklist::checking() const
-{
-    return checking_;
-}
-
-void
-ACLChecklist::checking (bool const newValue)
-{
-    checking_ = newValue;
-}
-
 bool
 ACLChecklist::callerGone()
 {
@@ -31,7 +31,8 @@
 #ifndef SQUID_ACLCHECKLIST_H
 #define SQUID_ACLCHECKLIST_H
 
-#include "acl/Acl.h"
+#include "acl/InnerNode.h"
+#include <stack>
 
 /// ACL checklist callback
 typedef void ACLCB(allow_t, void *);
@@ -67,9 +68,6 @@ class ACLChecklist
     public:
         virtual void checkForAsync(ACLChecklist *) const = 0;
         virtual ~AsyncState() {}
-
-    protected:
-        void changeState (ACLChecklist *, AsyncState *) const;
     };
 
     class NullState : public AsyncState
@@ -153,25 +151,29 @@ class ACLChecklist
      *
      * If there are no ACLs to check at all, the result becomes ACCESS_ALLOWED.
      */
-    allow_t const & fastCheck(const ACLList * list);
+    allow_t const & fastCheck(const Acl::Tree *list);
+
+    /// If slow lookups are allowed, switches into "async in progress" state.
+    /// Otherwise, returns false; the caller is expected to handle the failure.
+    bool goAsync(AsyncState *);
+
+    /// Matches (or resumes matching of) a child node while maintaning
+    /// resumption breadcrumbs if a [grand]child node goes async.
+    bool matchChild(const Acl::InnerNode *parent, Acl::Nodes::const_iterator pos, const ACL *child);
 
-    // whether the last checked ACL of the current rule needs
-    // an async operation to determine whether there was a match
-    bool asyncNeeded() const;
-    bool asyncInProgress() const;
-    void asyncInProgress(bool const);
+    /// Whether we should continue to match tree nodes or stop/pause.
+    bool keepMatching() const { return !finished() && !asyncInProgress(); }
 
     /// whether markFinished() was called
-    bool finished() const;
+    bool finished() const { return finished_; }
+    /// async call has been started and has not finished (or failed) yet
+    bool asyncInProgress() const { return asyncStage_ != asyncNone; }
     /// called when no more ACLs should be checked; sets the final answer and
     /// prints a debugging message explaining the reason for that answer
     void markFinished(const allow_t &newAnswer, const char *reason);
 
     const allow_t &currentAnswer() const { return allow_; }
 
-    void changeState(AsyncState *);
-    AsyncState *asyncState() const;
-
     // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
     // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
@@ -182,46 +184,59 @@ class ACLChecklist
     /// Calls non-blocking check callback with the answer and destroys self.
     void checkCallback(allow_t answer);
 
-    void checkAccessList();
-    void checkForAsync();
+    void matchAndFinish();
+
+    void changeState(AsyncState *);
+    AsyncState *asyncState() const;
 
 public:
-    const acl_access *accessList;
+    const Acl::Tree *accessList;
 
     ACLCB *callback;
     void *callback_data;
 
-    /**
-     * Performs non-blocking check starting with the current rule.
-     * Used by nonBlockingCheck() to initiate the checks and by
-     * async operation callbacks to resume checks after the async
-     * operation updates the current Squid state. See nonBlockingCheck()
-     * for details on final result determination.
-     */
-    void matchNonBlocking();
+    /// Resumes non-blocking check started by nonBlockingCheck() and
+    /// suspended until some async operation updated Squid state.
+    void resumeNonBlockingCheck(AsyncState *state);
 
 private: /* internal methods */
+    /// Position of a child node within an ACL tree.
+    class Breadcrumb
+    {
+    public:
+        Breadcrumb(): parent(NULL) {}
+        Breadcrumb(const Acl::InnerNode *aParent, Acl::Nodes::const_iterator aPos): parent(aParent), position(aPos) {}
+        bool operator ==(const Breadcrumb &b) const { return parent == b.parent && (!parent || position == b.position); }
+        bool operator !=(const Breadcrumb &b) const { return !this->operator ==(b); }
+        void clear() { parent = NULL; }
+        const Acl::InnerNode *parent; ///< intermediate node in the ACL tree
+        Acl::Nodes::const_iterator position; ///< child position inside parent
+    };
+
     /// possible outcomes when trying to match a single ACL node in a list
     typedef enum { nmrMatch, nmrMismatch, nmrFinished, nmrNeedsAsync }
     NodeMatchingResult;
 
     /// prepare for checking ACLs; called once per check
     void preCheck(const char *what);
-    bool matchAclList(const ACLList * list, bool const fast);
-    bool matchNodes(const ACLList * head, bool const fast);
-    NodeMatchingResult matchNode(const ACLList &node, bool const fast);
-    void calcImplicitAnswer(const allow_t &lastSeenAction);
+    bool prepNonBlocking();
+    void completeNonBlocking();
+    void calcImplicitAnswer();
 
-    bool async_;
+    bool asyncCaller_; ///< whether the caller supports async/slow ACLs
     bool finished_;
     allow_t allow_;
-    AsyncState *state_;
 
-    bool checking_;
-    bool checking() const;
-    void checking (bool const);
+    enum AsyncStage { asyncNone, asyncStarting, asyncRunning, asyncFailed };
+    AsyncStage asyncStage_;
+    AsyncState *state_;
+    Breadcrumb matchLoc_; ///< location of the node running matches() now
+    Breadcrumb asyncLoc_; ///< currentNode_ that called goAsync()
 
     bool callerGone();
+
+    /// suspended (due to an async lookup) matches() in the ACL tree
+    std::stack<Breadcrumb> matchPath;
 };
 
 #endif /* SQUID_ACLCHECKLIST_H */
@@ -53,21 +53,16 @@ void
 DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(checklist->dst_addr, LookupDone, checklist);
 }
 
 void
 DestinationDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == DestinationDomainLookup::Instance());
-
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markDestinationDomainChecked();
     checklist->request->recordLookup(details);
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(DestinationDomainLookup::Instance());
 }
 
 int
@@ -112,8 +107,9 @@ ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledCheckl
     } else if (!checklist->destinationDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState(DestinationDomainLookup::Instance());
-        return 0;
+        if (checklist->goAsync(DestinationDomainLookup::Instance()))
+            return -1;
+        // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
@@ -56,7 +56,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
-    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
+    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.interceptTproxy)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -86,11 +86,12 @@ ACLDestinationIP::match(ACLChecklist *cl)
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << name << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState (DestinationIPLookup::Instance());
-        return 0;
-    } else {
-        return 0;
+        if (checklist->goAsync(DestinationIPLookup::Instance()))
+            return -1;
+        // else fall through to mismatch, hiding the lookup failure (XXX)
     }
+
+    return 0;
 }
 
 DestinationIPLookup DestinationIPLookup::instance_;
@@ -105,20 +106,16 @@ void
 DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    checklist->asyncInProgress(true);
     ipcache_nbgethostbyname(checklist->request->GetHost(), LookupDone, checklist);
 }
 
 void
 DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == DestinationIPLookup::Instance());
     checklist->request->flags.destinationIpLookedUp = true;
     checklist->request->recordLookup(details);
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(DestinationIPLookup::Instance());
 }
 
 ACL *
@@ -13,22 +13,6 @@
 
 CBDATA_CLASS_INIT(ACLFilledChecklist);
 
-void *
-ACLFilledChecklist::operator new (size_t size)
-{
-    assert (size == sizeof(ACLFilledChecklist));
-    CBDATA_INIT_TYPE(ACLFilledChecklist);
-    ACLFilledChecklist *result = cbdataAlloc(ACLFilledChecklist);
-    return result;
-}
-
-void
-ACLFilledChecklist::operator delete (void *address)
-{
-    ACLFilledChecklist *t = static_cast<ACLFilledChecklist *>(address);
-    cbdataFree(t);
-}
-
 ACLFilledChecklist::ACLFilledChecklist() :
         dst_peer(NULL),
         dst_rdns(NULL),
@@ -194,4 +178,3 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
         xstrncpy(rfc931, ident, USER_IDENT_SZ);
 #endif
 }
-
@@ -2,6 +2,7 @@
 #define SQUID_ACLFILLED_CHECKLIST_H
 
 #include "acl/Checklist.h"
+#include "acl/forward.h"
 #include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -22,9 +23,6 @@ class HttpReply;
 class ACLFilledChecklist: public ACLChecklist
 {
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ACLFilledChecklist();
     ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
     ~ACLFilledChecklist();
@@ -89,7 +87,7 @@ class ACLFilledChecklist: public ACLChecklist
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
 
-    CBDATA_CLASS(ACLFilledChecklist);
+    CBDATA_CLASS2(ACLFilledChecklist);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
@@ -41,6 +41,7 @@
 #include "acl/AclNameList.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/Checklist.h"
+#include "acl/Tree.h"
 #include "acl/Strategised.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
@@ -134,7 +135,7 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
 
     while ((t = strtok(NULL, w_space))) {
         L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
-        xstrncpy(L->name, t, ACL_NAME_SZ);
+        xstrncpy(L->name, t, ACL_NAME_SZ-1);
         *Tail = L;
         Tail = &L->next;
     }
@@ -153,84 +154,87 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
 }
 
 void
-aclParseAccessLine(ConfigParser &parser, acl_access ** head)
+aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
 {
-    char *t = NULL;
-    acl_access *A = NULL;
-    acl_access *B = NULL;
-    acl_access **T = NULL;
-
     /* first expect either 'allow' or 'deny' */
+    const char *t = ConfigParser::strtokFile();
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if (!t) {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: missing 'allow' or 'deny'.");
         return;
     }
 
-    A = new acl_access;
-
+    allow_t action = ACCESS_DUNNO;
     if (!strcmp(t, "allow"))
-        A->allow = ACCESS_ALLOWED;
+        action = ACCESS_ALLOWED;
     else if (!strcmp(t, "deny"))
-        A->allow = ACCESS_DENIED;
+        action = ACCESS_DENIED;
     else {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: expecting 'allow' or 'deny', got '" << t << "'.");
-        delete A;
         return;
     }
 
-    aclParseAclList(parser, &A->aclList);
+    const int ruleId = ((treep && *treep) ? (*treep)->childrenCount() : 0) + 1;
+    MemBuf ctxBuf;
+    ctxBuf.init();
+    ctxBuf.Printf("%s#%d", directive, ruleId);
+    ctxBuf.terminate();
 
-    if (A->aclList == NULL) {
-        debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context(ctxBuf.content(), config_input_line);
+    rule->lineParse();
+    if (rule->empty()) {
+        debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: Access line contains no ACL's, skipping");
-        delete A;
+        delete rule;
         return;
     }
 
-    A->cfgline = xstrdup(config_input_line);
     /* Append to the end of this list */
 
-    for (B = *head, T = head; B; T = &B->next, B = B->next);
-    *T = A;
+    assert(treep);
+    if (!*treep) {
+        *treep = new Acl::Tree;
+        (*treep)->context(directive, config_input_line);
+    }
+
+    (*treep)->add(rule, action);
 
     /* We lock _acl_access structures in ACLChecklist::matchNonBlocking() */
 }
 
+// aclParseAclList does not expect or set actions (cf. aclParseAccessLine)
 void
-aclParseAclList(ConfigParser &parser, ACLList ** head)
+aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 {
-    ACLList **Tail = head;	/* sane name in the use below */
-    ACL *a = NULL;
-    char *t;
-
-    /* next expect a list of ACL names, possibly preceeded
-     * by '!' for negation */
-
-    while ((t = strtok(NULL, w_space))) {
-        ACLList *L = new ACLList;
-
-        if (*t == '!') {
-            L->negated (true);
-            ++t;
-        }
-
-        debugs(28, 3, "aclParseAclList: looking for ACL name '" << t << "'");
-        a = ACL::FindByName(t);
-
-        if (a == NULL) {
-            debugs(28, DBG_CRITICAL, "aclParseAclList: ACL name '" << t << "' not found.");
-            delete L;
-            parser.destruct();
-            continue;
-        }
-
-        L->_acl = a;
-        *Tail = L;
-        Tail = &L->next;
-    }
+    // accomodate callers unable to convert their ACL list context to string
+    if (!label)
+        label = "...";
+
+    MemBuf ctxLine;
+    ctxLine.init();
+    ctxLine.Printf("(%s %s line)", cfg_directive, label);
+    ctxLine.terminate();
+
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context(ctxLine.content(), config_input_line);
+    rule->lineParse();
+
+    MemBuf ctxTree;
+    ctxTree.init();
+    ctxTree.Printf("%s %s", cfg_directive, label);
+    ctxTree.terminate();
+
+    // We want a cbdata-protected Tree (despite giving it only one child node).
+    Acl::Tree *tree = new Acl::Tree;
+    tree->add(rule);
+    tree->context(ctxTree.content(), config_input_line);
+
+    assert(treep);
+    assert(!*treep);
+    *treep = tree;
 }
 
 /*********************/
@@ -253,32 +257,20 @@ aclDestroyAcls(ACL ** head)
 }
 
 void
-aclDestroyAclList(ACLList ** head)
+aclDestroyAclList(ACLList **list)
 {
-    ACLList *l;
     debugs(28, 8, "aclDestroyAclList: invoked");
-
-    for (l = *head; l; l = *head) {
-        *head = l->next;
-        delete l;
-    }
+    assert(list);
+    cbdataFree(*list);
 }
 
 void
 aclDestroyAccessList(acl_access ** list)
 {
-    acl_access *l = NULL;
-    acl_access *next = NULL;
-
-    for (l = *list; l; l = next) {
-        debugs(28, 3, "aclDestroyAccessList: '" << l->cfgline << "'");
-        next = l->next;
-        aclDestroyAclList(&l->aclList);
-        safe_free(l->cfgline);
-        cbdataFree(l);
-    }
-
-    *list = NULL;
+    assert(list);
+    if (*list)
+        debugs(28, 3, "destroying: " << *list << ' ' << (*list)->name);
+    cbdataFree(*list);
 }
 
 /* maex@space.net (06.09.1996)
@@ -2,11 +2,12 @@
 #define SQUID_ACL_GADGETS_H
 
 #include "err_type.h"
+#include "acl/forward.h"
+
+#if HAVE_SSTREAM
+#include <sstream>
+#endif
 
-class acl_access;
-class ACL;
-class AclDenyInfoList;
-class ACLList;
 class ConfigParser;
 class dlink_list;
 class StoreEntry;
@@ -18,10 +19,23 @@ void aclDestroyAccessList(acl_access **list);
 void aclDestroyAcls(ACL **);
 /// \ingroup ACLAPI
 void aclDestroyAclList(ACLList **);
-/// \ingroup ACLAPI
-void aclParseAccessLine(ConfigParser &parser, acl_access **);
-/// \ingroup ACLAPI
-void aclParseAclList(ConfigParser &parser, ACLList **);
+/// Parses a single line of a "action followed by acls" directive (e.g., http_access).
+/// \ingroup ACLAPI
+void aclParseAccessLine(const char *directive, ConfigParser &parser, Acl::Tree **);
+/// Parses a single line of a "some context followed by acls" directive (e.g., note n v).
+/// The label parameter identifies the context (for debugging).
+/// \ingroup ACLAPI
+void aclParseAclList(ConfigParser &parser, Acl::Tree **, const char *label);
+/// Template to convert various context lables to strings. \ingroup ACLAPI
+template <class Any>
+inline
+void aclParseAclList(ConfigParser &parser, Acl::Tree **tree, const Any any)
+{
+    std::ostringstream buf;
+    buf << any;
+    aclParseAclList(parser, tree, buf.str().c_str());
+}
+
 /// \ingroup ACLAPI
 int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
@@ -0,0 +1,108 @@
+#include "squid.h"
+#include "acl/Acl.h"
+#include "acl/BoolOps.h"
+#include "acl/Checklist.h"
+#include "acl/InnerNode.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "globals.h"
+#include "wordlist.h"
+#include <algorithm>
+
+// "delete acl" class to use with std::for_each() in InnerNode::~InnerNode()
+class AclDeleter
+{
+public:
+    void operator()(ACL* acl) {
+        // Do not delete explicit ACLs; they are maintained by Config.aclList.
+        if (acl && !acl->registered)
+            delete acl;
+    }
+};
+
+Acl::InnerNode::~InnerNode()
+{
+    std::for_each(nodes.begin(), nodes.end(), AclDeleter());
+}
+
+void
+Acl::InnerNode::prepareForUse()
+{
+    std::for_each(nodes.begin(), nodes.end(), std::mem_fun(&ACL::prepareForUse));
+}
+
+bool
+Acl::InnerNode::empty() const
+{
+    return nodes.empty();
+}
+
+void
+Acl::InnerNode::add(ACL *node)
+{
+    assert(node != NULL);
+    nodes.push_back(node);
+}
+
+// one call parses one "acl name acltype name1 name2 ..." line
+// kids use this method to handle [multiple] parse() calls correctly
+void
+Acl::InnerNode::lineParse()
+{
+    // XXX: not precise, may change when looping or parsing multiple lines
+    if (!cfgline)
+        cfgline = xstrdup(config_input_line);
+
+    // expect a list of ACL names, each possibly preceeded by '!' for negation
+
+    while (const char *t = ConfigParser::strtokFile()) {
+        const bool negated = (*t == '!');
+        if (negated)
+            ++t;
+
+        debugs(28, 3, "looking for ACL " << t);
+        ACL *a = ACL::FindByName(t);
+
+        if (a == NULL) {
+            debugs(28, DBG_CRITICAL, "ACL not found: " << t);
+            self_destruct();
+            return;
+        }
+
+        // append(negated ? new NotNode(a) : a);
+        if (negated)
+            add(new NotNode(a));
+        else
+            add(a);
+    }
+
+    return;
+}
+
+wordlist*
+Acl::InnerNode::dump() const
+{
+    wordlist *values = NULL;
+    for (Nodes::const_iterator i = nodes.begin(); i != nodes.end(); ++i)
+        wordlistAdd(&values, (*i)->name);
+    return values;
+}
+
+int
+Acl::InnerNode::match(ACLChecklist *checklist)
+{
+    return doMatch(checklist, nodes.begin());
+}
+
+bool
+Acl::InnerNode::resumeMatchingAt(ACLChecklist *checklist, Nodes::const_iterator pos) const
+{
+    debugs(28, 5, "checking " << name << " at " << (pos-nodes.begin()));
+    const int result = doMatch(checklist, pos);
+    const char *extra = checklist->asyncInProgress() ? " async" : "";
+    debugs(28, 3, "checked: " << name << " = " << result << extra);
+
+    // merges async and failures (-1) into "not matched"
+    return result == 1;
+}
@@ -0,0 +1,48 @@
+#ifndef SQUID_ACL_INNER_NODE_H
+#define SQUID_ACL_INNER_NODE_H
+
+#include "acl/Acl.h"
+#include <vector>
+
+namespace Acl
+{
+
+typedef std::vector<ACL*> Nodes; ///< a collection of nodes
+
+/// An intermediate ACL tree node. Manages a collection of child tree nodes.
+class InnerNode: public ACL
+{
+public:
+    virtual ~InnerNode();
+
+    /// Resumes matching (suspended by an async call) at the given position.
+    bool resumeMatchingAt(ACLChecklist *checklist, Acl::Nodes::const_iterator pos) const;
+
+    /// the number of children nodes
+    Nodes::size_type childrenCount() const { return nodes.size(); }
+
+    /* ACL API */
+    virtual void prepareForUse();
+    virtual bool empty() const;
+    virtual wordlist *dump() const;
+
+    /// parses one "acl name type acl1 acl2..." line, appending to nodes
+    void lineParse();
+
+    /// appends the node to the collection and takes control over it
+    void add(ACL *node);
+
+protected:
+    /// checks whether the nodes match, starting with the given one
+    /// kids determine what a match means for their type of intermediate nodes
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const = 0;
+
+    /* ACL API */
+    virtual int match(ACLChecklist *checklist);
+
+    std::vector<ACL*> nodes; ///< children nodes of this intermediate node
+};
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_INNER_NODE_H */
@@ -507,14 +507,9 @@ acl_ip_data::FactoryParse(const char *t)
 void
 ACLIP::parse()
 {
-    char *t = NULL;
+    flags.parseFlags();
 
-    flags.parseFlags(t);
-
-    if (!t)
-        return;
-
-    do {
+    while (char *t = strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
@@ -524,7 +519,7 @@ ACLIP::parse()
             data = data->insert(q, acl_ip_data::NetworkCompare);
             q = next_node;
         }
-    } while ((t = strtokFile()));
+    }
 }
 
 ACLIP::~ACLIP()
@@ -7,8 +7,15 @@ noinst_LTLIBRARIES = libapi.la libstate.la libacls.la
 libapi_la_SOURCES = \
 	Acl.cc \
 	Acl.h \
+	BoolOps.cc \
+	BoolOps.h \
 	Checklist.cc \
-	Checklist.h
+	Checklist.h \
+	forward.h \
+	InnerNode.cc \
+	InnerNode.h \
+	Tree.cc \
+	Tree.h
 
 ## Data-dependent Squid/transaction state used by specific ACLs.
 ## Does not refer to specific ACLs to avoid circular dependencies.
@@ -34,6 +41,10 @@ libacls_la_SOURCES = \
 	Time.h \
 	TimeData.cc \
 	TimeData.h \
+	AllOf.cc \
+	AllOf.h \
+	AnyOf.cc \
+	AnyOf.h \
 	Asn.cc \
 	Asn.h \
 	Browser.cc \
@@ -73,6 +84,10 @@ libacls_la_SOURCES = \
 	Method.h \
 	MyPortName.cc \
 	MyPortName.h \
+	Note.h \
+	Note.cc \
+	NoteData.h \
+	NoteData.cc \
 	PeerName.cc \
 	PeerName.h \
 	Protocol.cc \
@@ -0,0 +1,24 @@
+#include "squid.h"
+#include "acl/Note.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Checklist.h"
+#include "HttpRequest.h"
+#include "Notes.h"
+
+int
+ACLNoteStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+{
+    if (checklist->request != NULL)
+        return data->match(checklist->request);
+
+    return 0;
+}
+
+ACLNoteStrategy *
+ACLNoteStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLNoteStrategy ACLNoteStrategy::Instance_;
+
@@ -0,0 +1,39 @@
+#ifndef SQUID_ACLNOTE_H
+#define SQUID_ACLNOTE_H
+
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
+
+class HttpRequest;
+
+/// \ingroup ACLAPI
+class ACLNoteStrategy : public ACLStrategy<HttpRequest *>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual bool requiresRequest() const { return true; }
+
+    static ACLNoteStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLNoteStrategy(ACLNoteStrategy const &);
+
+private:
+    static ACLNoteStrategy Instance_;
+    ACLNoteStrategy() { }
+
+    ACLNoteStrategy& operator = (ACLNoteStrategy const &);
+};
+
+/// \ingroup ACLAPI
+class ACLNote
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<HttpRequest *> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLNOTE_H */
@@ -0,0 +1,87 @@
+#include "squid.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/NoteData.h"
+#include "acl/StringData.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "HttpRequest.h"
+#include "Notes.h"
+#include "wordlist.h"
+
+ACLNoteData::ACLNoteData() : values(new ACLStringData)
+{}
+
+ACLNoteData::~ACLNoteData()
+{
+    delete values;
+}
+
+bool
+ACLNoteData::matchNotes(NotePairs *note)
+{
+    if (note == NULL)
+        return false;
+
+    debugs(28, 3, "Checking " << name);
+
+    if (values->empty())
+        return (note->findFirst(name.termedBuf()) != NULL);
+
+    for (Vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
+        if ((*i)->name.cmp(name.termedBuf()) == 0) {
+            if (values->match((*i)->value.termedBuf()))
+                return true;
+        }
+    }
+    return false;
+}
+
+bool
+ACLNoteData::match(HttpRequest *request)
+{
+    if (request->notes != NULL && matchNotes(request->notes.getRaw()))
+        return true;
+#if USE_ADAPTATION
+    const Adaptation::History::Pointer ah = request->adaptLogHistory();
+    if (ah != NULL && ah->metaHeaders != NULL && matchNotes(ah->metaHeaders.getRaw()))
+        return true;
+#endif
+    return false;
+}
+
+wordlist *
+ACLNoteData::dump()
+{
+    wordlist *W = NULL;
+    wordlistAdd(&W, name.termedBuf());
+    wordlist * dumpR = values->dump();
+    wordlistAddWl(&W, dumpR);
+    wordlistDestroy(&dumpR);
+    return W;
+}
+
+void
+ACLNoteData::parse()
+{
+    char* t = strtokFile();
+    assert (t != NULL);
+    name = t;
+    values->parse();
+}
+
+bool
+ACLNoteData::empty() const
+{
+    return name.undefined();
+}
+
+ACLData<HttpRequest *> *
+ACLNoteData::clone() const
+{
+    ACLNoteData * result = new ACLNoteData;
+    result->values = values->clone();
+    result->name = name;
+    return result;
+}
@@ -0,0 +1,33 @@
+#ifndef SQUID_ACLNOTEDATA_H
+#define SQUID_ACLNOTEDATA_H
+
+#include "acl/Data.h"
+#include "SquidString.h"
+#include "MemPool.h"
+
+class HttpRequest;
+class NotePairs;
+
+/// \ingroup ACLAPI
+class ACLNoteData : public ACLData<HttpRequest *>
+{
+public:
+    MEMPROXY_CLASS(ACLNoteData);
+
+    ACLNoteData();
+    virtual ~ACLNoteData();
+    virtual bool match(HttpRequest* request);
+    virtual wordlist *dump();
+    virtual void parse();
+    virtual bool empty() const;
+    virtual ACLData<HttpRequest *> *clone() const;
+
+private:
+    bool matchNotes(NotePairs *note);
+    String name;                   ///< Note name to check. It is always set
+    ACLData<char const *> *values; ///< if set, at least one value must match
+};
+
+MEMPROXY_CLASS_INLINE(ACLNoteData);
+
+#endif /* SQUID_ACLNOTEDATA_H */
@@ -51,21 +51,16 @@ SourceDomainLookup::Instance()
 void
 SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 {
-    checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(Filled(checklist)->src_addr, LookupDone, checklist);
 }
 
 void
 SourceDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == SourceDomainLookup::Instance());
-
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markSourceDomainChecked();
     checklist->request->recordLookup(details);
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(SourceDomainLookup::Instance());
 }
 
 int
@@ -79,8 +74,9 @@ ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *
     } else if (!checklist->sourceDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->src_addr << "'");
-        checklist->changeState(SourceDomainLookup::Instance());
-        return 0;
+        if (checklist->goAsync(SourceDomainLookup::Instance()))
+            return -1;
+        // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
@@ -0,0 +1,75 @@
+#include "squid.h"
+#include "acl/Tree.h"
+#include "wordlist.h"
+
+CBDATA_NAMESPACED_CLASS_INIT(Acl, Tree);
+
+allow_t
+Acl::Tree::winningAction() const
+{
+    return actionAt(lastMatch_ - nodes.begin());
+}
+
+allow_t
+Acl::Tree::lastAction() const
+{
+    if (actions.empty())
+        return ACCESS_DUNNO;
+    return actions.back();
+}
+
+/// computes action that corresponds to the position of the matched rule
+allow_t
+Acl::Tree::actionAt(const Nodes::size_type pos) const
+{
+    assert(0 <= pos && pos < nodes.size());
+    if (actions.size()) {
+        assert(actions.size() == nodes.size());
+        return actions[pos];
+    }
+    // default for matched rules in trees without actions
+    return ACCESS_ALLOWED;
+}
+
+void
+Acl::Tree::add(ACL *rule, const allow_t &action)
+{
+    // either all rules have actions or none
+    assert(nodes.size() == actions.size());
+    InnerNode::add(rule);
+    actions.push_back(action);
+}
+
+void
+Acl::Tree::add(ACL *rule)
+{
+    // either all rules have actions or none
+    assert(actions.empty());
+    InnerNode::add(rule);
+}
+
+wordlist*
+Acl::Tree::treeDump(const char *prefix, const ActionToString &convert) const
+{
+    wordlist *text = NULL;
+    Actions::const_iterator action = actions.begin();
+    typedef Nodes::const_iterator NCI;
+    for (NCI node = nodes.begin(); node != nodes.end(); ++node) {
+
+        wordlistAdd(&text, prefix);
+
+        if (action != actions.end()) {
+            const char *act = convert ? convert[action->kind] :
+                              (*action == ACCESS_ALLOWED ? "allow" : "deny");
+            wordlistAdd(&text, act ? act : "???");
+            ++action;
+        }
+
+        wordlist *rule = (*node)->dump();
+        wordlistAddWl(&text, rule);
+        wordlistDestroy(&rule);
+
+        wordlistAdd(&text, "\n");
+    }
+    return text;
+}
@@ -0,0 +1,44 @@
+#ifndef SQUID_ACL_TREE_H
+#define SQUID_ACL_TREE_H
+
+#include "acl/BoolOps.h"
+
+namespace Acl
+{
+
+/// An ORed set of rules at the top of the ACL expression tree, providing two
+/// unique properties: cbdata protection and optional rule actions.
+class Tree: public OrNode
+{
+public:
+    /// dumps <name, action, rule, new line> tuples
+    /// action.kind is mapped to a string using the supplied conversion table
+    typedef const char **ActionToString;
+    wordlist* treeDump(const char *name, const ActionToString &convert) const;
+
+    /// Returns the corresponding action after a successful tree match.
+    allow_t winningAction() const;
+
+    /// what action to use if no nodes matched
+    allow_t lastAction() const;
+
+    /// appends and takes control over the rule with a given action
+    void add(ACL *rule, const allow_t &action);
+    void add(ACL *rule); ///< same as InnerNode::add()
+
+protected:
+    allow_t actionAt(const Nodes::size_type pos) const;
+
+    /// if not empty, contains actions corresponding to InnerNode::nodes
+    typedef std::vector<allow_t> Actions;
+    Actions actions;
+
+private:
+    // XXX: We should use refcounting instead, but it requires making ACLs
+    // refcounted as well. Otherwise, async lookups will reach deleted ACLs.
+    CBDATA_CLASS2(Tree);
+};
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_TREE_H */
@@ -0,0 +1,31 @@
+#ifndef SQUID_ACL_FORWARD_H
+#define SQUID_ACL_FORWARD_H
+
+class ACL;
+class ACLChecklist;
+class ACLFilledChecklist;
+class ACLList;
+
+class AclAddress;
+class AclDenyInfoList;
+class AclSizeLimit;
+
+namespace Acl
+{
+
+class InnerNode;
+class NotNode;
+class AndNode;
+class OrNode;
+class Tree;
+
+} // namespace Acl
+
+#define ACL_NAME_SZ 64
+
+// TODO: Consider renaming all users and removing. Cons: hides the difference
+// between ACLList tree without actions and acl_access Tree with actions.
+#define acl_access Acl::Tree
+#define ACLList Acl::Tree
+
+#endif /* SQUID_ACL_FORWARD_H */
@@ -20,7 +20,7 @@ Adaptation::AccessRule::~AccessRule()
 void
 Adaptation::AccessRule::parse(ConfigParser &parser)
 {
-    aclParseAccessLine(parser, &acl);
+    aclParseAccessLine("adaptation_access", parser, &acl);
 }
 
 void
@@ -1,10 +1,10 @@
 #ifndef SQUID_ADAPTATION__ACCESS_RULE_H
 #define SQUID_ADAPTATION__ACCESS_RULE_H
 
-#include "SquidString.h"
+#include "acl/forward.h"
 #include "adaptation/forward.h"
+#include "SquidString.h"
 
-class acl_access;
 class ConfigParser;
 
 namespace Adaptation
@@ -36,7 +36,7 @@
 #include "adaptation/History.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "HttpReply.h"
@@ -2,14 +2,13 @@
 #define SQUID_ADAPTATION__CONFIG_H
 
 #include "event.h"
-#include "acl/Gadgets.h"
+#include "acl/forward.h"
 #include "base/AsyncCall.h"
 #include "adaptation/forward.h"
 #include "adaptation/Elements.h"
 #include "Notes.h"
 #include "SquidString.h"
 
-class acl_access;
 class ConfigParser;
 class HttpRequest;
 class HttpReply;
@@ -1,7 +1,7 @@
 #ifndef SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 #define SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -2,7 +2,7 @@
 #define SQUID_ADAPT_HISTORY_H
 
 #include "adaptation/DynamicGroupCfg.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "HttpHeader.h"
 #include "Notes.h"
@@ -53,7 +53,7 @@ class History: public RefCountable
     HttpHeader allMeta;
     /// key:value pairs set by adaptation_meta, to be added to
     /// AccessLogEntry::notes when ALE becomes available
-    NotePairs metaHeaders;
+    NotePairs::Pointer metaHeaders;
 
     /// sets future services for the Adaptation::AccessCheck to notice
     void setFutureServices(const DynamicGroupCfg &services);
@@ -2,7 +2,7 @@
 #define SQUID_ADAPTATION__SERVICE_GROUPS_H
 
 #include "SquidString.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
 #include "base/RefCount.h"
@@ -231,8 +231,11 @@ Adaptation::Ecap::XactionRep::start()
         typedef Notes::iterator ACAMLI;
         for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
             const char *v = (*i)->match(request, reply);
-            if (v && !ah->metaHeaders.hasByNameListMember((*i)->key.termedBuf(), v, ',')) {
-                ah->metaHeaders.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), v));
+            if (v) {
+                if (ah->metaHeaders == NULL)
+                    ah->metaHeaders = new NotePairs();
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), v))
+                    ah->metaHeaders->add((*i)->key.termedBuf(), v);
             }
         }
     }
@@ -33,7 +33,7 @@
 #include "squid.h"
 #include "ConfigParser.h"
 #include "Store.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
@@ -36,11 +36,10 @@
 
 #include "event.h"
 #include "base/AsyncCall.h"
+#include "acl/forward.h"
 #include "adaptation/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 
-class acl_access;
-
 namespace Adaptation
 {
 namespace Icap
@@ -1432,8 +1432,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         if (const char *value = (*i)->match(r, reply)) {
             buf.Printf("%s: %s\r\n", (*i)->key.termedBuf(), value);
             Adaptation::History::Pointer ah = request->adaptHistory(false);
-            if (ah != NULL && !ah->metaHeaders.hasByNameListMember((*i)->key.termedBuf(), value, ','))
-                ah->metaHeaders.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), value));
+            if (ah != NULL) {
+                if (ah->metaHeaders == NULL)
+                    ah->metaHeaders = new NotePairs;
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), value))
+                    ah->metaHeaders->add((*i)->key.termedBuf(), value);
+            }
         }
     }
 
@@ -17,7 +17,7 @@ icapLogOpen()
         if (log->type == Log::Format::CLF_NONE)
             continue;
 
-        log->logfile = logfileOpen(log->filename, MAX_URL << 1, 1);
+        log->logfile = logfileOpen(log->filename, log->bufferSize, log->fatal);
 
         IcapLogfileStatus = LOG_ENABLE;
     }
@@ -26,15 +26,15 @@ AuthenticateAcl(ACLChecklist *ch)
         return ACCESS_DENIED;
     } else if (request->flags.sslBumped) {
         debugs(28, 5, "SslBumped request: It is an encapsulated request do not authenticate");
-        checklist->auth_user_request = checklist->conn() != NULL ? checklist->conn()->auth_user_request : request->auth_user_request;
+        checklist->auth_user_request = checklist->conn() != NULL ? checklist->conn()->getAuth() : request->auth_user_request;
         if (checklist->auth_user_request != NULL)
             return ACCESS_ALLOWED;
         else
             return ACCESS_DENIED;
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoofClientIp) {
+    } else if (request->flags.intercepted || request->flags.interceptTproxy) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
@@ -58,8 +58,10 @@ AuthenticateAcl(ACLChecklist *ch)
         break;
 
     case AUTH_ACL_HELPER:
-        debugs(28, 4, HERE << "returning " << ACCESS_DUNNO << " sending credentials to helper.");
-        checklist->changeState(ProxyAuthLookup::Instance());
+        if (checklist->goAsync(ProxyAuthLookup::Instance()))
+            debugs(28, 4, "returning " << ACCESS_DUNNO << " sending credentials to helper.");
+        else
+            debugs(28, 2, "cannot go async; returning " << ACCESS_DUNNO);
         return ACCESS_DUNNO; // XXX: break this down into DUNNO, EXPIRED_OK, EXPIRED_BAD states
 
     case AUTH_ACL_CHALLENGE:
@@ -139,8 +139,8 @@ ACLMaxUserIP::match(ACLChecklist *cl)
     case ACCESS_AUTH_REQUIRED:
     default:
         // If the answer is not allowed or denied (matches/not matches) and
-        // async authentication is not needed (asyncNeeded), then we are done.
-        if (!checklist->asyncNeeded())
+        // async authentication is not in progress, then we are done.
+        if (checklist->keepMatching())
             checklist->markFinished(answer, "AuthenticateAcl exception");
         return -1; // other
     }
@@ -92,8 +92,8 @@ ACLProxyAuth::match(ACLChecklist *checklist)
     case ACCESS_AUTH_REQUIRED:
     default:
         // If the answer is not allowed or denied (matches/not matches) and
-        // async authentication is not needed (asyncNeeded), then we are done.
-        if (!checklist->asyncNeeded())
+        // async authentication is not in progress, then we are done.
+        if (checklist->keepMatching())
             checklist->markFinished(answer, "AuthenticateAcl exception");
         return -1; // other
     }
@@ -136,11 +136,10 @@ ProxyAuthLookup::Instance()
 }
 
 void
-ProxyAuthLookup::checkForAsync(ACLChecklist *cl)const
+ProxyAuthLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
-    checklist->asyncInProgress(true);
     debugs(28, 3, HERE << "checking password via authenticator");
 
     /* make sure someone created auth_user_request for us */
@@ -154,22 +153,18 @@ ProxyAuthLookup::LookupDone(void *data)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
 
-    assert (checklist->asyncState() == ProxyAuthLookup::Instance());
-
     if (checklist->auth_user_request == NULL || !checklist->auth_user_request->valid() || checklist->conn() == NULL) {
         /* credentials could not be checked either way
          * restart the whole process */
         /* OR the connection was closed, there's no way to continue */
         checklist->auth_user_request = NULL;
 
         if (checklist->conn() != NULL) {
-            checklist->conn()->auth_user_request = NULL;
+            checklist->conn()->setAuth(NULL, "proxy_auth ACL failure");
         }
     }
 
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(ProxyAuthLookup::Instance());
 }
 
 ACL *
@@ -33,7 +33,7 @@
 
 #if USE_AUTH
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 
 /**
@@ -221,7 +221,7 @@ Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int accelerated
 {}
 
 void
-Auth::UserRequest::onConnectionClose(ConnStateData *)
+Auth::UserRequest::releaseAuthServer()
 {}
 
 const char *
@@ -253,7 +253,7 @@ authTryGetUser(Auth::UserRequest::Pointer auth_user_request, ConnStateData * con
     else if (request != NULL && request->auth_user_request != NULL)
         return request->auth_user_request;
     else if (conn != NULL)
-        return conn->auth_user_request;
+        return conn->getAuth();
     else
         return NULL;
 }
@@ -303,7 +303,7 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
 
         /* connection auth we must reset on auth errors */
         if (conn != NULL) {
-            conn->auth_user_request = NULL;
+            conn->setAuth(NULL, "HTTP request missing credentials");
         }
 
         *auth_user_request = NULL;
@@ -315,13 +315,13 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
      * No check for function required in the if: its compulsory for conn based
      * auth modules
      */
-    if (proxy_auth && conn != NULL && conn->auth_user_request != NULL &&
-            authenticateUserAuthenticated(conn->auth_user_request) &&
-            conn->auth_user_request->connLastHeader() != NULL &&
-            strcmp(proxy_auth, conn->auth_user_request->connLastHeader())) {
+    if (proxy_auth && conn != NULL && conn->getAuth() != NULL &&
+            authenticateUserAuthenticated(conn->getAuth()) &&
+            conn->getAuth()->connLastHeader() != NULL &&
+            strcmp(proxy_auth, conn->getAuth()->connLastHeader())) {
         debugs(29, 2, "WARNING: DUPLICATE AUTH - authentication header on already authenticated connection!. AU " <<
-               conn->auth_user_request << ", Current user '" <<
-               conn->auth_user_request->username() << "' proxy_auth " <<
+               conn->getAuth() << ", Current user '" <<
+               conn->getAuth()->username() << "' proxy_auth " <<
                proxy_auth);
 
         /* remove this request struct - the link is already authed and it can't be to reauth. */
@@ -330,7 +330,7 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
          * authenticateAuthenticate
          */
         assert(*auth_user_request == NULL);
-        conn->auth_user_request = NULL;
+        conn->setAuth(NULL, "changed credentials token");
     }
 
     /* we have a proxy auth header and as far as we know this connection has
@@ -342,20 +342,20 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
             debugs(29, 9, HERE << "This is a new checklist test on:" << conn->clientConnection);
         }
 
-        if (proxy_auth && request->auth_user_request == NULL && conn != NULL && conn->auth_user_request != NULL) {
+        if (proxy_auth && request->auth_user_request == NULL && conn != NULL && conn->getAuth() != NULL) {
             Auth::Config * scheme = Auth::Config::Find(proxy_auth);
 
-            if (conn->auth_user_request->user() == NULL || conn->auth_user_request->user()->config != scheme) {
+            if (conn->getAuth()->user() == NULL || conn->getAuth()->user()->config != scheme) {
                 debugs(29, DBG_IMPORTANT, "WARNING: Unexpected change of authentication scheme from '" <<
-                       conn->auth_user_request->user()->config->type() <<
+                       (conn->getAuth()->user()!=NULL?conn->getAuth()->user()->config->type():"[no user]") <<
                        "' to '" << proxy_auth << "' (client " <<
                        src_addr << ")");
 
-                conn->auth_user_request = NULL;
+                conn->setAuth(NULL, "changed auth scheme");
             }
         }
 
-        if (request->auth_user_request == NULL && (conn == NULL || conn->auth_user_request == NULL)) {
+        if (request->auth_user_request == NULL && (conn == NULL || conn->getAuth() == NULL)) {
             /* beginning of a new request check */
             debugs(29, 4, HERE << "No connection authentication type");
 
@@ -378,15 +378,11 @@ Auth::UserRequest::authenticate(Auth::UserRequest::Pointer * auth_user_request,
             *auth_user_request = request->auth_user_request;
         } else {
             assert (conn != NULL);
-            if (conn->auth_user_request != NULL) {
-                *auth_user_request = conn->auth_user_request;
+            if (conn->getAuth() != NULL) {
+                *auth_user_request = conn->getAuth();
             } else {
                 /* failed connection based authentication */
-                debugs(29, 4, HERE << "Auth user request " <<
-                       *auth_user_request << " conn-auth user request " <<
-                       conn->auth_user_request << " conn type " <<
-                       conn->auth_user_request->user()->auth_type << " authentication failed.");
-
+                debugs(29, 4, HERE << "Auth user request " << *auth_user_request << " conn-auth missing and failed to authenticate.");
                 *auth_user_request = NULL;
                 return AUTH_ACL_CHALLENGE;
             }
@@ -155,7 +155,7 @@ class UserRequest : public RefCountable
     /* add the [Proxy-]Authentication-Info trailer */
     virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel);
 
-    virtual void onConnectionClose(ConnStateData *);
+    virtual void releaseAuthServer();
 
     /**
      * Called when squid is ready to put the request on hold and wait for a callback from the auth module
@@ -306,9 +306,9 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
         assert(digest_user != NULL);
 
-        Note::Pointer ha1Note = reply.notes.find("ha1");
+        const char *ha1Note = reply.notes.findFirst("ha1");
         if (ha1Note != NULL) {
-            CvtBin(ha1Note->firstValue(), digest_user->HA1);
+            CvtBin(ha1Note, digest_user->HA1);
             digest_user->HA1created = 1;
         } else {
             debugs(29, DBG_IMPORTANT, "ERROR: Digest auth helper did not produce a HA1. Using the wrong helper program? received: " << reply);
@@ -332,9 +332,9 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
         digest_request->user()->credentials(Auth::Failed);
         digest_request->flags.invalid_password = true;
 
-        Note::Pointer msgNote = reply.notes.find("message");
+        const char *msgNote = reply.notes.find("message");
         if (msgNote != NULL) {
-            digest_request->setDenyMessage(msgNote->firstValue());
+            digest_request->setDenyMessage(msgNote);
         } else if (reply.other().hasContent()) {
             // old helpers did send ERR result but a bare message string instead of message= key name.
             digest_request->setDenyMessage(reply.other().content());
@@ -129,27 +129,6 @@ Auth::Negotiate::UserRequest::releaseAuthServer()
         debugs(29, 6, HERE << "No Negotiate auth server to release.");
 }
 
-/* clear any connection related authentication details */
-void
-Auth::Negotiate::UserRequest::onConnectionClose(ConnStateData *conn)
-{
-    assert(conn != NULL);
-
-    debugs(29, 8, HERE << "closing connection '" << conn << "' (this is '" << this << "')");
-
-    if (conn->auth_user_request == NULL) {
-        debugs(29, 8, HERE << "no auth_user_request");
-        return;
-    }
-
-    releaseAuthServer();
-
-    /* unlock the connection based lock */
-    debugs(29, 9, HERE << "Unlocking auth_user from the connection '" << conn << "'.");
-
-    conn->auth_user_request = NULL;
-}
-
 void
 Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
 {
@@ -199,8 +178,8 @@ Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData
         user()->credentials(Auth::Pending);
         safe_free(client_blob);
         client_blob=xstrdup(blob);
-        assert(conn->auth_user_request == NULL);
-        conn->auth_user_request = this;
+        assert(conn->getAuth() == NULL);
+        conn->setAuth(this, "new Negotiate handshake request");
         request = aRequest;
         HTTPMSGLOCK(request);
         break;
@@ -268,20 +247,20 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         safe_free(lm_request->server_blob);
         lm_request->request->flags.mustKeepalive = true;
         if (lm_request->request->flags.proxyKeepalive) {
-            Note::Pointer tokenNote = reply.notes.find("token");
-            lm_request->server_blob = xstrdup(tokenNote->firstValue());
+            const char *tokenNote = reply.notes.findFirst("token");
+            lm_request->server_blob = xstrdup(tokenNote);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
-            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << tokenNote->firstValue() << "'");
+            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << tokenNote << "'");
         } else {
             auth_user_request->user()->credentials(Auth::Failed);
             auth_user_request->denyMessage("Negotiate authentication requires a persistent connection");
         }
         break;
 
     case HelperReply::Okay: {
-        Note::Pointer userNote = reply.notes.find("user");
-        Note::Pointer tokenNote = reply.notes.find("token");
+        const char *userNote = reply.notes.findFirst("user");
+        const char *tokenNote = reply.notes.findFirst("token");
         if (userNote == NULL || tokenNote == NULL) {
             // XXX: handle a success with no username better
             /* protocol error */
@@ -290,10 +269,10 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         }
 
         /* we're finished, release the helper */
-        auth_user_request->user()->username(userNote->firstValue());
+        auth_user_request->user()->username(userNote);
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
-        lm_request->server_blob = xstrdup(tokenNote->firstValue());
+        lm_request->server_blob = xstrdup(tokenNote);
         lm_request->releaseAuthServer();
 
         /* connection is authenticated */
@@ -327,18 +306,18 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     break;
 
     case HelperReply::Error: {
-        Note::Pointer messageNote = reply.notes.find("message");
-        Note::Pointer tokenNote = reply.notes.find("token");
+        const char *messageNote = reply.notes.find("message");
+        const char *tokenNote = reply.notes.findFirst("token");
 
         /* authentication failure (wrong password, etc.) */
         if (messageNote != NULL)
-            auth_user_request->denyMessage(messageNote->firstValue());
+            auth_user_request->denyMessage(messageNote);
         else
             auth_user_request->denyMessage("Negotiate Authentication denied with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         if (tokenNote != NULL)
-            lm_request->server_blob = xstrdup(tokenNote->firstValue());
+            lm_request->server_blob = xstrdup(tokenNote);
         lm_request->releaseAuthServer();
         debugs(29, 4, HERE << "Failed validating user via Negotiate. Error returned '" << reply << "'");
     }
@@ -354,11 +333,11 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
          * Authenticate Negotiate start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
-        Note::Pointer errNote = reply.notes.find("message");
+        const char *errNote = reply.notes.find("message");
         if (reply.result == HelperReply::Unknown)
             auth_user_request->denyMessage("Internal Error");
         else if (errNote != NULL)
-            auth_user_request->denyMessage(errNote->firstValue());
+            auth_user_request->denyMessage(errNote);
         else
             auth_user_request->denyMessage("Negotiate Authentication failed with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
@@ -26,7 +26,6 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Direction module_direction();
-    virtual void onConnectionClose(ConnStateData *);
     virtual void module_start(AUTHCB *, void *);
 
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
@@ -122,26 +122,6 @@ Auth::Ntlm::UserRequest::releaseAuthServer()
         debugs(29, 6, HERE << "No NTLM auth server to release.");
 }
 
-void
-Auth::Ntlm::UserRequest::onConnectionClose(ConnStateData *conn)
-{
-    assert(conn != NULL);
-
-    debugs(29, 8, HERE << "closing connection '" << conn << "' (this is '" << this << "')");
-
-    if (conn->auth_user_request == NULL) {
-        debugs(29, 8, HERE << "no auth_user_request");
-        return;
-    }
-
-    releaseAuthServer();
-
-    /* unlock the connection based lock */
-    debugs(29, 9, HERE << "Unlocking auth_user from the connection '" << conn << "'.");
-
-    conn->auth_user_request = NULL;
-}
-
 void
 Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
 {
@@ -192,8 +172,8 @@ Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * co
         user()->credentials(Auth::Pending);
         safe_free(client_blob);
         client_blob=xstrdup(blob);
-        assert(conn->auth_user_request == NULL);
-        conn->auth_user_request = this;
+        assert(conn->getAuth() == NULL);
+        conn->setAuth(this, "new NTLM handshake request");
         request = aRequest;
         HTTPMSGLOCK(request);
         break;
@@ -261,11 +241,11 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         safe_free(lm_request->server_blob);
         lm_request->request->flags.mustKeepalive = true;
         if (lm_request->request->flags.proxyKeepalive) {
-            Note::Pointer serverBlob = reply.notes.find("token");
-            lm_request->server_blob = xstrdup(serverBlob->firstValue());
+            const char *serverBlob = reply.notes.findFirst("token");
+            lm_request->server_blob = xstrdup(serverBlob);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
-            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << serverBlob->firstValue() << "'");
+            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << serverBlob << "'");
         } else {
             auth_user_request->user()->credentials(Auth::Failed);
             auth_user_request->denyMessage("NTLM authentication requires a persistent connection");
@@ -274,13 +254,13 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
 
     case HelperReply::Okay: {
         /* we're finished, release the helper */
-        Note::Pointer userLabel = reply.notes.find("user");
-        auth_user_request->user()->username(userLabel->firstValue());
+        const char *userLabel = reply.notes.findFirst("user");
+        auth_user_request->user()->username(userLabel);
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
 
-        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << userLabel->firstValue() << "'");
+        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << userLabel << "'");
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
         /* see if this is an existing user with a different proxy_auth
@@ -313,15 +293,15 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
 
     case HelperReply::Error: {
         /* authentication failure (wrong password, etc.) */
-        Note::Pointer errNote = reply.notes.find("message");
+        const char *errNote = reply.notes.find("message");
         if (errNote != NULL)
-            auth_user_request->denyMessage(errNote->firstValue());
+            auth_user_request->denyMessage(errNote);
         else
             auth_user_request->denyMessage("NTLM Authentication denied with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, 4, HERE << "Failed validating user via NTLM. Error returned '" << errNote->firstValue() << "'");
+        debugs(29, 4, HERE << "Failed validating user via NTLM. Error returned '" << errNote << "'");
     }
     break;
 
@@ -335,11 +315,11 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
          * Authenticate NTLM start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
-        Note::Pointer errNote = reply.notes.find("message");
+        const char *errNote = reply.notes.find("message");
         if (reply.result == HelperReply::Unknown)
             auth_user_request->denyMessage("Internal Error");
         else if (errNote != NULL)
-            auth_user_request->denyMessage(errNote->firstValue());
+            auth_user_request->denyMessage(errNote);
         else
             auth_user_request->denyMessage("NTLM Authentication failed with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
@@ -26,14 +26,13 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void onConnectionClose(ConnStateData *);
     virtual void module_start(AUTHCB *, void *);
 
     virtual const char * connLastHeader();
 
     /* we need to store the helper server between requests */
     helper_stateful_server *authserver;
-    void releaseAuthServer(void); ///< Release authserver NTLM helpers properly when finished or abandoning.
+    virtual void releaseAuthServer(); ///< Release authserver NTLM helpers properly when finished or abandoning.
 
     /* our current blob to pass to the client */
     char *server_blob;
@@ -59,7 +59,7 @@ template <class EntryValue, size_t EntryCost = sizeof(EntryValue)> class LruMap
     LruMap(LruMap const &);
     LruMap & operator = (LruMap const &);
 
-    bool expired(Entry &e);
+    bool expired(const Entry &e) const;
     void trim();
     void touch(const MapIterator &i);
     bool del(const MapIterator &i);
@@ -110,12 +110,14 @@ LruMap<EntryValue, EntryCost>::findEntry(const char *key, LruMap::MapIterator &i
     index.erase(i->second);
     i->second = index.begin();
 
-    Entry *e = *i->second;
-
-    if (e && expired(*e)) {
-        del(i);
-        e = NULL;
+    if (const Entry *e = *i->second) {
+        if (!expired(*e))
+            return;
+        // else fall through to cleanup
     }
+
+    del(i);
+    i = storage.end();
 }
 
 template <class EntryValue, size_t EntryCost>
@@ -124,9 +126,9 @@ LruMap<EntryValue, EntryCost>::get(const char *key)
 {
     MapIterator i;
     findEntry(key, i);
-    Entry *e = *i->second;
     if (i != storage.end()) {
         touch(i);
+        Entry *e = *i->second;
         return e->value;
     }
     return NULL;
@@ -150,7 +152,7 @@ LruMap<EntryValue, EntryCost>::add(const char *key, EntryValue *t)
 
 template <class EntryValue, size_t EntryCost>
 bool
-LruMap<EntryValue, EntryCost>::expired(LruMap::Entry &entry)
+LruMap<EntryValue, EntryCost>::expired(const LruMap::Entry &entry) const
 {
     if (ttl < 0)
         return false;
@@ -163,9 +165,10 @@ bool
 LruMap<EntryValue, EntryCost>::del(LruMap::MapIterator const &i)
 {
     if (i != storage.end()) {
-        delete *(i->second);
+        Entry *e = *i->second;
         index.erase(i->second);
         storage.erase(i);
+        delete e;
         --entries_;
         return true;
     }
@@ -22,4 +22,6 @@ libbase_la_SOURCES = \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	StringArea.h
+	StringArea.h \
+	Vector.cc \
+	Vector.h
@@ -35,6 +35,7 @@
 #if HAVE_CSTRING
 #include <cstring>
 #endif
+#include <ostream>
 
 /** A char* plus length combination. Useful for temporary storing
  * and quickly looking up strings.
@@ -56,11 +57,20 @@ class StringArea
         return (theLen < s.theLen || (theLen == s.theLen && memcmp(theStart,s.theStart,theLen) < 0)) ;
     }
 
+    void print(std::ostream &os) const { os.write(theStart, theLen); }
+
 private:
     /// pointed to the externally-managed memory area
     const char *theStart;
     /// length of the string
     size_t theLen;
 };
 
+inline std::ostream &
+operator <<(std::ostream &os, const StringArea &a)
+{
+    a.print(os);
+    return os;
+}
+
 #endif /* SQUID_STRINGAREA_H */
@@ -38,7 +38,7 @@
  */
 
 #include "squid.h"
-#include "Array.h"
+#include "base/Vector.h"
 
 #if HAVE_ASSERT_H
 #include <assert.h>
@@ -38,6 +38,7 @@
 #include "acl/AclSizeLimit.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
+#include "acl/Tree.h"
 #include "anyp/PortCfg.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
@@ -180,6 +181,7 @@ static void parse_access_log(CustomLog ** customlog_definitions);
 static int check_null_access_log(CustomLog *customlog_definitions);
 static void dump_access_log(StoreEntry * entry, const char *name, CustomLog * definitions);
 static void free_access_log(CustomLog ** definitions);
+static bool setLogformat(CustomLog *cl, const char *name, const bool dieWhenMissing);
 
 static void update_maxobjsize(void);
 static void configDoConfigure(void);
@@ -300,14 +302,10 @@ update_maxobjsize(void)
 static void
 SetConfigFilename(char const *file_name, bool is_pipe)
 {
-    cfg_filename = file_name;
-
-    char const *token;
-
     if (is_pipe)
         cfg_filename = file_name + 1;
-    else if ((token = strrchr(cfg_filename, '/')))
-        cfg_filename = token + 1;
+    else
+        cfg_filename = file_name;
 }
 
 static const char*
@@ -528,7 +526,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
                 if ((token = strchr(new_file_name, '"')))
                     *token = '\0';
 
-                cfg_filename = new_file_name;
+                SetConfigFilename(new_file_name, false);
             }
 
             config_lineno = new_lineno;
@@ -598,7 +596,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
         fclose(fp);
     }
 
-    cfg_filename = orig_cfg_filename;
+    SetConfigFilename(orig_cfg_filename, false);
     config_lineno = orig_config_lineno;
 
     xfree(tmp_line);
@@ -968,6 +966,16 @@ configDoConfigure(void)
                (uint32_t)Config.maxRequestBufferSize, (uint32_t)Config.maxRequestHeaderSize);
     }
 
+    /*
+     * Disable client side request pipelining if client_persistent_connections OFF.
+     * Waste of resources queueing any pipelined requests when the first will close the connection.
+     */
+    if (Config.pipeline_max_prefetch > 0 && !Config.onoff.client_pconns) {
+        debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: pipeline_prefetch " << Config.pipeline_max_prefetch <<
+               " requires client_persistent_connections ON. Forced pipeline_prefetch 0.");
+        Config.pipeline_max_prefetch = 0;
+    }
+
 #if USE_AUTH
     /*
      * disable client side request pipelining. There is a race with
@@ -976,12 +984,12 @@ configDoConfigure(void)
      * pipelining OFF, the client may fail to authenticate, but squid's
      * state will be preserved.
      */
-    if (Config.onoff.pipeline_prefetch) {
+    if (Config.pipeline_max_prefetch > 0) {
         Auth::Config *nego = Auth::Config::Find("Negotiate");
         Auth::Config *ntlm = Auth::Config::Find("NTLM");
         if ((nego && nego->active()) || (ntlm && ntlm->active())) {
-            debugs(3, DBG_IMPORTANT, "WARNING: pipeline_prefetch breaks NTLM and Negotiate authentication. Forced OFF.");
-            Config.onoff.pipeline_prefetch = 0;
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: pipeline_prefetch breaks NTLM and Negotiate authentication. Forced pipeline_prefetch 0.");
+            Config.pipeline_max_prefetch = 0;
         }
     }
 #endif
@@ -1224,7 +1232,6 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
 }
 #endif
 
-#if USE_SSL
 /**
  * Parse bytes from a string.
  * Similar to the parseBytesLine function but parses the string value instead of
@@ -1260,7 +1267,6 @@ static void parseBytesOptionValue(size_t * bptr, const char *units, char const *
     if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2)
         self_destruct();
 }
-#endif
 
 static size_t
 parseBytesUnits(const char *unit)
@@ -1287,25 +1293,24 @@ parseBytesUnits(const char *unit)
  *****************************************************************************/
 
 static void
-dump_acl(StoreEntry * entry, const char *name, ACL * ae)
+dump_wordlist(StoreEntry * entry, wordlist *words)
 {
-    wordlist *w;
-    wordlist *v;
+    for (wordlist *word = words; word; word = words->next)
+        storeAppendPrintf(entry, "%s ", word->key);
+}
 
+static void
+dump_acl(StoreEntry * entry, const char *name, ACL * ae)
+{
     while (ae != NULL) {
         debugs(3, 3, "dump_acl: " << name << " " << ae->name);
         storeAppendPrintf(entry, "%s %s %s %s ",
                           name,
                           ae->name,
                           ae->typeString(),
                           ae->flags.flagsStr());
-        v = w = ae->dump();
-
-        while (v != NULL) {
-            debugs(3, 3, "dump_acl: " << name << " " << ae->name << " " << v->key);
-            storeAppendPrintf(entry, "%s ", v->key);
-            v = v->next;
-        }
+        wordlist *w = ae->dump();
+        dump_wordlist(entry, w);
 
         storeAppendPrintf(entry, "\n");
         wordlistDestroy(&w);
@@ -1328,33 +1333,23 @@ free_acl(ACL ** ae)
 void
 dump_acl_list(StoreEntry * entry, ACLList * head)
 {
-    ACLList *l;
-
-    for (l = head; l; l = l->next) {
-        storeAppendPrintf(entry, " %s%s",
-                          l->op ? null_string : "!",
-                          l->_acl->name);
-    }
+    wordlist *values = head->dump();
+    dump_wordlist(entry, values);
+    wordlistDestroy(&values);
 }
 
 void
 dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 {
-    acl_access *l;
-
-    for (l = head; l; l = l->next) {
-        storeAppendPrintf(entry, "%s %s",
-                          name,
-                          l->allow ? "Allow" : "Deny");
-        dump_acl_list(entry, l->aclList);
-        storeAppendPrintf(entry, "\n");
-    }
+    wordlist *lines = head->treeDump(name, NULL);
+    dump_wordlist(entry, lines);
+    wordlistDestroy(&lines);
 }
 
 static void
 parse_acl_access(acl_access ** head)
 {
-    aclParseAccessLine(LegacyParser, head);
+    aclParseAccessLine(cfg_directive, LegacyParser, head);
 }
 
 static void
@@ -1431,7 +1426,7 @@ parse_acl_address(AclAddress ** head)
     CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
     l = cbdataAlloc(AclAddress);
     parse_address(&l->addr);
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, l->addr);
 
     while (*tail)
         tail = &(*tail)->next;
@@ -1499,7 +1494,7 @@ parse_acl_tos(acl_tos ** head)
 
     l->tos = (tos_t)tos;
 
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, token);
 
     while (*tail)
         tail = &(*tail)->next;
@@ -1570,7 +1565,7 @@ parse_acl_nfmark(acl_nfmark ** head)
 
     l->nfmark = mark;
 
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, token);
 
     while (*tail)
         tail = &(*tail)->next;
@@ -1628,7 +1623,7 @@ parse_acl_b_size_t(AclSizeLimit ** head)
 
     parse_b_int64_t(&l->size);
 
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, l->size);
 
     while (*tail)
         tail = &(*tail)->next;
@@ -1765,7 +1760,10 @@ parse_http_header_access(HeaderManglers **pm)
     HeaderManglers *manglers = *pm;
     headerMangler *mangler = manglers->track(t);
     assert(mangler);
-    parse_acl_access(&mangler->access_list);
+
+    std::string directive = "http_header_access ";
+    directive += t;
+    aclParseAccessLine(directive.c_str(), LegacyParser, &mangler->access_list);
 }
 
 static void
@@ -1917,8 +1915,10 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
     fs = find_fstype(type_str);
 
-    if (fs < 0)
-        self_destruct();
+    if (fs < 0) {
+        debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: This proxy does not support the '" << type_str << "' cache type. Ignoring.");
+        return;
+    }
 
     /* reconfigure existing dir */
 
@@ -2338,9 +2338,11 @@ parse_peer(CachePeer ** head)
             p->connection_auth = 1;
         } else if (strcmp(token, "connection-auth=auto") == 0) {
             p->connection_auth = 2;
+        } else if (token[0] == '#') {
+            // start of a text comment. stop reading this line.
+            break;
         } else {
-            debugs(3, DBG_CRITICAL, "parse_peer: token='" << token << "'");
-            self_destruct();
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Ignoring unknown cache_peer option '" << token << "'");
         }
     }
 
@@ -2528,7 +2530,9 @@ parse_peer_access(void)
         return;
     }
 
-    aclParseAccessLine(LegacyParser, &p->access);
+    std::string directive = "peer_access ";
+    directive += host;
+    aclParseAccessLine(directive.c_str(), LegacyParser, &p->access);
 }
 
 static void
@@ -2692,6 +2696,29 @@ parse_tristate(int *var)
 
 #define free_tristate free_int
 
+void
+parse_pipelinePrefetch(int *var)
+{
+    char *token = ConfigParser::strtokFile();
+
+    if (token == NULL)
+        self_destruct();
+
+    if (!strcmp(token, "on")) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'pipeline_prefetch on' is deprecated. Please update to use 1 (or a higher number).");
+        *var = 1;
+    } else if (!strcmp(token, "off")) {
+        debugs(0, DBG_PARSE_NOTE(2), "WARNING: 'pipeline_prefetch off' is deprecated. Please update to use '0'.");
+        *var = 0;
+    } else {
+        ConfigParser::strtokFileUndo();
+        parse_int(var);
+    }
+}
+
+#define free_pipelinePrefetch free_int
+#define dump_pipelinePrefetch dump_int
+
 static void
 dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 {
@@ -3606,8 +3633,7 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         s->flags.tproxyIntercept = true;
         Ip::Interceptor.StartTransparency();
         /* Log information regarding the port modes under transparency. */
-        debugs(3, DBG_IMPORTANT, "Starting IP Spoofing on port " << s->s);
-        debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (IP spoofing enabled)");
+        debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (TPROXY enabled)");
 
         if (!Ip::Interceptor.ProbeForTproxy(s->s)) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: TPROXY support in the system does not work.");
@@ -3699,17 +3725,16 @@ parse_port_option(AnyP::PortCfg * s, char *token)
     } else if (strncmp(token, "tcpkeepalive=", 13) == 0) {
         char *t = token + 13;
         s->tcp_keepalive.enabled = true;
-        s->tcp_keepalive.idle = xatoui(t);
+        s->tcp_keepalive.idle = xatoui(t,',');
         t = strchr(t, ',');
         if (t) {
             ++t;
-            s->tcp_keepalive.interval = xatoui(t);
+            s->tcp_keepalive.interval = xatoui(t,',');
             t = strchr(t, ',');
         }
         if (t) {
             ++t;
             s->tcp_keepalive.timeout = xatoui(t);
-            // t = strchr(t, ','); // not really needed, left in as documentation
         }
 #if USE_SSL
     } else if (strcmp(token, "sslBump") == 0) {
@@ -4024,33 +4049,118 @@ strtokFile(void)
 
 #include "AccessLogEntry.h"
 
+/**
+ * We support several access_log configuration styles:
+ *
+ * #1: Deprecated ancient style without an explicit logging module:
+ * access_log /var/log/access.log
+ *
+ * #2: The "none" logging module (i.e., no logging [of matching transactions]):
+ * access_log none [acl ...]
+ *
+ * #3: Configurable logging module without named options:
+ * Logformat or the first ACL name, whichever comes first, may not contain '='.
+ * If no explicit logformat name is given, the first ACL name, if any,
+ * should not be an existing logformat name or it will be treated as such.
+ * access_log module:place [logformat_name] [acl ...]
+ *
+ * #4: Configurable logging module with name=value options such as logformat=x:
+ * The first ACL name may not contain '='.
+ * access_log module:place [option ...] [acl ...]
+ *
+ */
 static void
 parse_access_log(CustomLog ** logs)
 {
-    const char *filename, *logdef_name;
-
     CustomLog *cl = (CustomLog *)xcalloc(1, sizeof(*cl));
 
-    if ((filename = strtok(NULL, w_space)) == NULL) {
+    // default buffer size and fatal settings
+    cl->bufferSize = 8*MAX_URL;
+    cl->fatal = true;
+
+    /* determine configuration style */
+
+    const char *filename = strtok(NULL, w_space);
+    if (!filename) {
         self_destruct();
         return;
     }
 
     if (strcmp(filename, "none") == 0) {
         cl->type = Log::Format::CLF_NONE;
-        aclParseAclList(LegacyParser, &cl->aclList);
+        aclParseAclList(LegacyParser, &cl->aclList, filename);
         while (*logs)
             logs = &(*logs)->next;
         *logs = cl;
         return;
     }
 
-    if ((logdef_name = strtok(NULL, w_space)) == NULL)
-        logdef_name = "squid";
+    cl->filename = xstrdup(filename);
+    cl->type = Log::Format::CLF_UNKNOWN;
+
+    const char *token = ConfigParser::strtokFile();
+    if (!token) { // style #1
+        // no options to deal with
+    } else if (!strchr(token, '=')) { // style #3
+        // if logformat name is not recognized,
+        // put back the token; it must be an ACL name
+        if (!setLogformat(cl, token, false))
+            ConfigParser::strtokFileUndo();
+    } else { // style #4
+        do {
+            if (strncasecmp(token, "on-error=", 9) == 0) {
+                if (strncasecmp(token+9, "die", 3) == 0) {
+                    cl->fatal = true;
+                } else if (strncasecmp(token+9, "drop", 4) == 0) {
+                    cl->fatal = false;
+                } else {
+                    debugs(3, DBG_CRITICAL, "Unknown value for on-error '" <<
+                           token << "' expected 'drop' or 'die'");
+                    self_destruct();
+                }
+            } else if (strncasecmp(token, "buffer-size=", 12) == 0) {
+                parseBytesOptionValue(&cl->bufferSize, B_BYTES_STR, token+12);
+            } else if (strncasecmp(token, "logformat=", 10) == 0) {
+                setLogformat(cl, token+10, true);
+            } else if (!strchr(token, '=')) {
+                // put back the token; it must be an ACL name
+                ConfigParser::strtokFileUndo();
+                break; // done with name=value options, now to ACLs
+            } else {
+                debugs(3, DBG_CRITICAL, "Unknown access_log option " << token);
+                self_destruct();
+            }
+        } while ((token = ConfigParser::strtokFile()) != NULL);
+    }
+
+    // set format if it has not been specified explicitly
+    if (cl->type == Log::Format::CLF_UNKNOWN)
+        setLogformat(cl, "squid", true);
 
-    debugs(3, 9, "Log definition name '" << logdef_name << "' file '" << filename << "'");
+    aclParseAclList(LegacyParser, &cl->aclList, cl->filename);
 
-    cl->filename = xstrdup(filename);
+    while (*logs)
+        logs = &(*logs)->next;
+
+    *logs = cl;
+}
+
+/// sets CustomLog::type and, if needed, CustomLog::lf
+/// returns false iff there is no named log format
+static bool
+setLogformat(CustomLog *cl, const char *logdef_name, const bool dieWhenMissing)
+{
+    assert(cl);
+    assert(logdef_name);
+
+    debugs(3, 9, "possible " << cl->filename << " logformat: " << logdef_name);
+
+    if (cl->type != Log::Format::CLF_UNKNOWN) {
+        debugs(3, DBG_CRITICAL, "Second logformat name in one access_log: " <<
+               logdef_name << " " << cl->type << " ? " << Log::Format::CLF_NONE);
+        self_destruct();
+        return false;
+    }
 
     /* look for the definition pointer corresponding to this name */
     Format::Format *lf = Log::TheConfig.logformats;
@@ -4084,18 +4194,15 @@ parse_access_log(CustomLog ** logs)
         cl->type = Log::Format::CLF_USERAGENT;
     } else if (strcmp(logdef_name, "referrer") == 0) {
         cl->type = Log::Format::CLF_REFERER;
-    } else {
+    } else if (dieWhenMissing) {
         debugs(3, DBG_CRITICAL, "Log format '" << logdef_name << "' is not defined");
         self_destruct();
-        return;
+        return false;
+    } else {
+        return false;
     }
 
-    aclParseAclList(LegacyParser, &cl->aclList);
-
-    while (*logs)
-        logs = &(*logs)->next;
-
-    *logs = cl;
+    return true;
 }
 
 static int
@@ -4432,7 +4539,7 @@ static void parse_sslproxy_cert_adapt(sslproxy_cert_adapt **cert_adapt)
         return;
     }
 
-    aclParseAclList(LegacyParser, &ca->aclList);
+    aclParseAclList(LegacyParser, &ca->aclList, al);
 
     while (*cert_adapt)
         cert_adapt = &(*cert_adapt)->next;
@@ -4486,7 +4593,7 @@ static void parse_sslproxy_cert_sign(sslproxy_cert_sign **cert_sign)
         return;
     }
 
-    aclParseAclList(LegacyParser, &cs->aclList);
+    aclParseAclList(LegacyParser, &cs->aclList, al);
 
     while (*cert_sign)
         cert_sign = &(*cert_sign)->next;
@@ -4572,31 +4679,30 @@ static void parse_sslproxy_ssl_bump(acl_access **ssl_bump)
         sslBumpCfgRr::lastDeprecatedRule = Ssl::bumpEnd;
     }
 
-    acl_access *A = new acl_access;
-    A->allow = allow_t(ACCESS_ALLOWED);
+    allow_t action = allow_t(ACCESS_ALLOWED);
 
     if (strcmp(bm, Ssl::BumpModeStr[Ssl::bumpClientFirst]) == 0) {
-        A->allow.kind = Ssl::bumpClientFirst;
+        action.kind = Ssl::bumpClientFirst;
         bumpCfgStyleNow = bcsNew;
     } else if (strcmp(bm, Ssl::BumpModeStr[Ssl::bumpServerFirst]) == 0) {
-        A->allow.kind = Ssl::bumpServerFirst;
+        action.kind = Ssl::bumpServerFirst;
         bumpCfgStyleNow = bcsNew;
     } else if (strcmp(bm, Ssl::BumpModeStr[Ssl::bumpNone]) == 0) {
-        A->allow.kind = Ssl::bumpNone;
+        action.kind = Ssl::bumpNone;
         bumpCfgStyleNow = bcsNew;
     } else if (strcmp(bm, "allow") == 0) {
         debugs(3, DBG_CRITICAL, "SECURITY NOTICE: auto-converting deprecated "
                "\"ssl_bump allow <acl>\" to \"ssl_bump client-first <acl>\" which "
                "is usually inferior to the newer server-first "
                "bumping mode. Update your ssl_bump rules.");
-        A->allow.kind = Ssl::bumpClientFirst;
+        action.kind = Ssl::bumpClientFirst;
         bumpCfgStyleNow = bcsOld;
         sslBumpCfgRr::lastDeprecatedRule = Ssl::bumpClientFirst;
     } else if (strcmp(bm, "deny") == 0) {
         debugs(3, DBG_CRITICAL, "WARNING: auto-converting deprecated "
                "\"ssl_bump deny <acl>\" to \"ssl_bump none <acl>\". Update "
                "your ssl_bump rules.");
-        A->allow.kind = Ssl::bumpNone;
+        action.kind = Ssl::bumpNone;
         bumpCfgStyleNow = bcsOld;
         sslBumpCfgRr::lastDeprecatedRule = Ssl::bumpNone;
     } else {
@@ -4614,22 +4720,26 @@ static void parse_sslproxy_ssl_bump(acl_access **ssl_bump)
 
     bumpCfgStyleLast = bumpCfgStyleNow;
 
-    aclParseAclList(LegacyParser, &A->aclList);
+    ACL *rule = new Acl::AndNode;
+    rule->parse();
+    // empty rule OK
+    rule->context("(ssl_bump rule)", config_input_line);
 
-    acl_access *B, **T;
-    for (B = *ssl_bump, T = ssl_bump; B; T = &B->next, B = B->next);
-    *T = A;
+    assert(ssl_bump);
+    if (!*ssl_bump) {
+        *ssl_bump = new Acl::Tree;
+        (*ssl_bump)->context("(ssl_bump rules)", config_input_line);
+    }
+
+    (*ssl_bump)->add(rule, action);
 }
 
 static void dump_sslproxy_ssl_bump(StoreEntry *entry, const char *name, acl_access *ssl_bump)
 {
-    acl_access *sb;
-    for (sb = ssl_bump; sb != NULL; sb = sb->next) {
-        storeAppendPrintf(entry, "%s ", name);
-        storeAppendPrintf(entry, "%s ", Ssl::bumpMode(sb->allow.kind));
-        if (sb->aclList)
-            dump_acl_list(entry, sb->aclList);
-        storeAppendPrintf(entry, "\n");
+    if (ssl_bump) {
+        wordlist *lines = ssl_bump->treeDump(name, Ssl::BumpModeStr);
+        dump_wordlist(entry, lines);
+        wordlistDestroy(&lines);
     }
 }
 
@@ -4683,7 +4793,8 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
         }
         hwa.valueFormat = nlf;
     }
-    aclParseAclList(LegacyParser, &hwa.aclList);
+
+    aclParseAclList(LegacyParser, &hwa.aclList, (hwa.fieldName + ':' + hwa.fieldValue).c_str());
     (*headers)->push_back(hwa);
 }
 
@@ -51,6 +51,7 @@ obsolete
 onoff
 peer
 peer_access		cache_peer acl
+pipelinePrefetch
 PortCfg
 QosConfig
 refreshpattern
@@ -336,7 +336,7 @@ DOC_START
 	If you want to use the traditional NCSA proxy authentication, set
 	this line to something like
 
-	auth_param basic program @DEFAULT_PREFIX@/libexec/ncsa_auth @DEFAULT_PREFIX@/etc/passwd
+	auth_param basic program @DEFAULT_PREFIX@/libexec/basic_ncsa_auth @DEFAULT_PREFIX@/etc/passwd
 
 	"utf8" on|off
 	HTTP uses iso-latin-1 as character set, while some authentication
@@ -497,7 +497,7 @@ DOC_START
 	of type proxy_auth.  By default, the NTLM authenticator program
 	is not used.
 
-	auth_param ntlm program @DEFAULT_PREFIX@/bin/ntlm_auth
+	auth_param ntlm program /usr/bin/ntlm_auth
 
 	"children" numberofchildren [startup=N] [idle=N]
 	The maximum number of authenticator processes to spawn (default 5).
@@ -538,7 +538,7 @@ DOC_START
 	The only supported program for this role is the ntlm_auth
 	program distributed as part of Samba, version 4 or later.
 
-	auth_param negotiate program @DEFAULT_PREFIX@/bin/ntlm_auth --helper-protocol=gss-spnego
+	auth_param negotiate program /usr/bin/ntlm_auth --helper-protocol=gss-spnego
 
 	"children" numberofchildren [startup=N] [idle=N]
 	The maximum number of authenticator processes to spawn (default 5).
@@ -709,6 +709,13 @@ DOC_START
 	  		list separator. ; can be any non-alphanumeric
 			character.
 
+	  %ACL		The name of the ACL being tested.
+	  %DATA		The ACL arguments. If not used then any arguments
+			is automatically added at the end of the line
+			sent to the helper.
+			NOTE: this will encode the arguments as one token,
+			whereas the default will pass each separately.
+
 	  %%		The percent sign. Useful for helpers which need
 			an unchanging input format.
 
@@ -1045,6 +1052,15 @@ DOC_START
 	  # effect in rules that affect the reply data stream such as
 	  # http_reply_access.
 
+	acl aclname note name [value ...]
+	  # match transaction annotation [fast]
+	  # Without values, matches any annotation with a given name.
+	  # With value(s), matches any annotation with a given name that
+	  # also has one of the given values.
+	  # Names and values are compared using a string equality test.
+	  # Annotation sources include note and adaptation_meta directives
+	  # as well as helper and eCAP responses.
+
 IF USE_SSL
 	acl aclname ssl_error errorname
 	  # match against SSL certificate validation error [fast]
@@ -1076,6 +1092,29 @@ IF USE_SSL
 	  # The SHA1 digest algorithm is the default and is currently
 	  # the only algorithm supported (-sha1).
 ENDIF
+	acl aclname any-of acl1 acl2 ...
+	  # match any one of the acls [fast or slow]
+	  # The first matching ACL stops further ACL evaluation.
+	  #
+	  # ACLs from multiple any-of lines with the same name are ORed.
+	  # For example, A = (a1 or a2) or (a3 or a4) can be written as
+	  #   acl A any-of a1 a2
+	  #   acl A any-of a3 a4
+	  #
+	  # This group ACL is fast if all evaluated ACLs in the group are fast
+	  # and slow otherwise.
+
+	acl aclname all-of acl1 acl2 ... 
+	  # match all of the acls [fast or slow]
+	  # The first mismatching ACL stops further ACL evaluation.
+	  #
+	  # ACLs from multiple all-of lines with the same name are ORed.
+	  # For example, B = (b1 and b2) or (b3 and b4) can be written as
+	  #   acl B all-of b1 b2
+	  #   acl B all-of b3 b4
+	  #
+	  # This group ACL is fast if all evaluated ACLs in the group are fast
+	  # and slow otherwise.
 
 	Examples:
 		acl macaddress arp 09:00:2b:23:45:67
@@ -1118,6 +1157,7 @@ TYPE: acl_access
 IFDEF: FOLLOW_X_FORWARDED_FOR
 LOC: Config.accessList.followXFF
 DEFAULT_IF_NONE: deny all
+DEFAULT_DOC: X-Forwarded-For header will be ignored.
 DOC_START
 	Allowing or Denying the X-Forwarded-For header to be followed to
 	find the original source of a request.
@@ -1223,10 +1263,31 @@ DOC_START
 	sources is required to prevent abuse of your proxy.
 DOC_END
 
+NAME: spoof_client_ip
+TYPE: acl_access
+LOC: Config.accessList.spoof_client_ip
+DEFAULT: none
+DEFAULT_DOC: Allow spoofing on all TPROXY traffic.
+DOC_START
+	Control client IP address spoofing of TPROXY traffic based on
+	defined access lists.
+
+	spoof_client_ip allow|deny [!]aclname ...
+
+	If there are no "spoof_client_ip" lines present, the default
+	is to "allow" spoofing of any suitable request.
+
+	Note that the cache_peer "no-tproxy" option overrides this ACL.
+
+	This clause supports fast acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+DOC_END
+
 NAME: http_access
 TYPE: acl_access
 LOC: Config.accessList.http
 DEFAULT_IF_NONE: deny all
+DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 DOC_START
 	Allowing or Denying access based on defined access lists
 
@@ -1287,6 +1348,7 @@ NAME: adapted_http_access http_access2
 TYPE: acl_access
 LOC: Config.accessList.adapted_http
 DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 DOC_START
 	Allowing or Denying access based on defined access lists
 
@@ -1301,13 +1363,14 @@ NAME: http_reply_access
 TYPE: acl_access
 LOC: Config.accessList.reply
 DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 DOC_START
 	Allow replies to client requests. This is complementary to http_access.
 
 	http_reply_access allow|deny [!] aclname ...
 
 	NOTE: if there are no access lines present, the default is to allow
-	all replies
+	all replies.
 
 	If none of the access lines cause a match the opposite of the
 	last line will apply. Thus it is good practice to end the rules
@@ -1320,14 +1383,17 @@ DOC_END
 NAME: icp_access
 TYPE: acl_access
 LOC: Config.accessList.icp
-DEFAULT_IF_NONE: deny all
+DEFAULT: none
+DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 DOC_START
 	Allowing or Denying access to the ICP port based on defined
 	access lists
 
 	icp_access  allow|deny [!]aclname ...
 
-	See http_access for details
+	NOTE: The default if no icp_access lines are present is to
+	deny all traffic. This default may cause problems with peers
+	using ICP.
 
 	This clause only supports fast acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
@@ -1341,14 +1407,16 @@ NAME: htcp_access
 IFDEF: USE_HTCP
 TYPE: acl_access
 LOC: Config.accessList.htcp
-DEFAULT_IF_NONE: deny all
+DEFAULT: none
+DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 DOC_START
 	Allowing or Denying access to the HTCP port based on defined
 	access lists
 
 	htcp_access  allow|deny [!]aclname ...
 
-	See http_access for details
+	See also htcp_clr_access for details on access control for
+	cache purge (CLR) HTCP messages.
 
 	NOTE: The default if no htcp_access lines are present is to
 	deny all traffic. This default may cause problems with peers
@@ -1366,43 +1434,44 @@ NAME: htcp_clr_access
 IFDEF: USE_HTCP
 TYPE: acl_access
 LOC: Config.accessList.htcp_clr
-DEFAULT_IF_NONE: deny all
+DEFAULT: none
+DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 DOC_START
 	Allowing or Denying access to purge content using HTCP based
-	on defined access lists
+	on defined access lists.
+	See htcp_access for details on general HTCP access control.
 
 	htcp_clr_access  allow|deny [!]aclname ...
 
-	See http_access for details
-
 	This clause only supports fast acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
 
 # Allow HTCP CLR requests from trusted peers
-acl htcp_clr_peer src 172.16.1.2
+acl htcp_clr_peer src 192.0.2.2 2001:DB8::2
 htcp_clr_access allow htcp_clr_peer
+htcp_clr_access deny all
 DOC_END
 
 NAME: miss_access
 TYPE: acl_access
 LOC: Config.accessList.miss
 DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 DOC_START
 	Determins whether network access is permitted when satisfying a request.
 
 	For example;
 	    to force your neighbors to use you as a sibling instead of
 	    a parent.
 
-		acl localclients src 172.16.0.0/16
-		miss_access allow localclients
+		acl localclients src 192.0.2.0/24 2001:DB8::a:0/64
 		miss_access deny  !localclients
+		miss_access allow all
 
 	This means only your local clients are allowed to fetch relayed/MISS
 	replies from the network and all other clients can only fetch cached
 	objects (HITs).
 
-
 	The default for this setting allows all clients who passed the
 	http_access rules to relay via this proxy.
 
@@ -1413,7 +1482,8 @@ DOC_END
 NAME: ident_lookup_access
 TYPE: acl_access
 IFDEF: USE_IDENT
-DEFAULT_IF_NONE: deny all
+DEFAULT: none
+DEFAULT_DOC: Unless rules exist in squid.conf, IDENT is not fetched.
 LOC: Ident::TheConfig.identLookup
 DOC_START
 	A list of ACL elements which, if matched, cause an ident
@@ -1442,6 +1512,7 @@ NAME: reply_body_max_size
 COMMENT: size [acl acl...]
 TYPE: acl_b_size_t
 DEFAULT: none
+DEFAULT_DOC: No limit is applied.
 LOC: Config.ReplyBodySize
 DOC_START
 	This option specifies the maximum size of a reply body. It can be
@@ -2012,6 +2083,7 @@ DOC_END
 NAME: tcp_outgoing_address
 TYPE: acl_address
 DEFAULT: none
+DEFAULT_DOC: Address selection is performed by the operating system.
 LOC: Config.accessList.outgoing_address
 DOC_START
 	Allows you to map requests to different outgoing IP addresses
@@ -2192,6 +2264,7 @@ DOC_END
 NAME: sslproxy_version
 IFDEF: USE_SSL
 DEFAULT: 1
+DEFAULT_DOC: automatic SSL/TLS version negotiation
 LOC: Config.ssl_client.version
 TYPE: int
 DOC_START
@@ -2272,6 +2345,7 @@ NAME: ssl_bump
 IFDEF: USE_SSL
 TYPE: sslproxy_ssl_bump
 LOC: Config.accessList.ssl_bump
+DEFAULT_DOC: Does not bump unless rules are present in squid.conf
 DEFAULT: none
 DOC_START
 	This option is consulted when a CONNECT request is received on
@@ -2318,7 +2392,7 @@ DOC_START
 
 
 	# Example: Bump all requests except those originating from
-	# localhost and those going to example.com.
+	# localhost or those going to example.com.
 
 	acl broken_sites dstdomain .example.com
 	ssl_bump none localhost
@@ -2342,6 +2416,7 @@ DOC_END
 NAME: sslproxy_cert_error
 IFDEF: USE_SSL
 DEFAULT: none
+DEFAULT_DOC: Server certificate errors terminate the transaction.
 LOC: Config.ssl_client.cert_error
 TYPE: acl_access
 DOC_START
@@ -2360,13 +2435,14 @@ DOC_START
 	Using slow acl types may result in server crashes
 
 	Without this option, all server certificate validation errors
-	terminate the transaction. Bypassing validation errors is dangerous
-	because an error usually implies that the server cannot be trusted and
-	the connection may be insecure.
+	terminate the transaction to protect Squid and the client.
 
-	See also: sslproxy_flags and DONT_VERIFY_PEER.
+	SECURITY WARNING:
+		Bypassing validation errors is dangerous because an
+		error usually implies that the server cannot be trusted
+		and the connection may be insecure.
 
-	Default setting:  sslproxy_cert_error deny all
+	See also: sslproxy_flags and DONT_VERIFY_PEER.
 DOC_END
 
 NAME: sslproxy_cert_sign
@@ -2382,14 +2458,17 @@ DOC_START
         sslproxy_cert_sign <signing algorithm> acl ...
 
         The following certificate signing algorithms are supported:
+
 	   signTrusted
 		Sign using the configured CA certificate which is usually
 		placed in and trusted by end-user browsers. This is the
 		default for trusted origin server certificates.
+
 	   signUntrusted
 		Sign to guarantee an X509_V_ERR_CERT_UNTRUSTED browser error.
 		This is the default for untrusted origin server certificates
 		that are not self-signed (see ssl::certUntrusted).
+
 	   signSelf
 		Sign using a self-signed certificate with the right CN to
 		generate a X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT error in the
@@ -2412,7 +2491,7 @@ DOC_START
 	bump-server-first is used.
 DOC_END
 
-NAME: sslproxy_cert_adapt 
+NAME: sslproxy_cert_adapt
 IFDEF: USE_SSL
 DEFAULT: none
 TYPE: sslproxy_cert_adapt
@@ -2422,12 +2501,15 @@ DOC_START
 	sslproxy_cert_adapt <adaptation algorithm> acl ...
 
 	The following certificate adaptation algorithms are supported:
+
 	   setValidAfter
 		Sets the "Not After" property to the "Not After" property of
 		the CA certificate used to sign generated certificates.
+
 	   setValidBefore
 		Sets the "Not Before" property to the "Not Before" property of
 		the CA certificate used to sign generated certificates.
+
 	   setCommonName or setCommonName{CN}
 		Sets Subject.CN property to the host name specified as a 
 		CN parameter or, if no explicit CN parameter was specified,
@@ -2523,11 +2605,12 @@ DEFAULT: none
 LOC: Ssl::TheConfig.ssl_crt_validator
 DOC_START
 	Specify the location and options of the executable for ssl_crt_validator
-	process. Usage:
-		sslcrtvalidator_program [ttl=n] [cache=n] path ...
+	process.
+
+	Usage:  sslcrtvalidator_program [ttl=n] [cache=n] path ...
 
 	Options:
-	  ttl=n         TTL in seconds for cached results.The default is 60 secs
+	  ttl=n         TTL in seconds for cached results. The default is 60 secs
 	  cache=n       limit the result cache size. The default value is 2048
 DOC_END
 
@@ -2537,7 +2620,7 @@ IFDEF: USE_SSL
 DEFAULT: 32 startup=5 idle=1 concurrency=1
 LOC: Ssl::TheConfig.ssl_crt_validator_Children
 DOC_START
-	The maximum number of processes spawn to service ssl server.
+	The maximum number of processes spawn to service SSL server.
 	The maximum this may be safely set to is 32.
 	
 	The startup= and idle= options allow some measure of skew in your
@@ -2936,6 +3019,7 @@ DOC_START
 	
 	no-tproxy	Do not use the client-spoof TPROXY support when forwarding
 			requests to this peer. Use normal address selection instead.
+			This overrides the spoof_client_ip ACL.
 	
 	proxy-only	objects fetched from the peer will not be stored locally.
 	
@@ -2947,10 +3031,11 @@ DEFAULT: none
 LOC: none
 DOC_START
 	Use to limit the domains for which a neighbor cache will be
-	queried.  Usage:
+	queried.
 
-	cache_peer_domain cache-host domain [domain ...]
-	cache_peer_domain cache-host !domain
+	Usage:
+		cache_peer_domain cache-host domain [domain ...]
+		cache_peer_domain cache-host !domain
 
 	For example, specifying
 
@@ -2981,7 +3066,8 @@ DOC_START
 	Similar to 'cache_peer_domain' but provides more flexibility by
 	using ACL elements.
 
-	cache_peer_access cache-host allow|deny [!]aclname ...
+	Usage:
+		cache_peer_access cache-host allow|deny [!]aclname ...
 
 	The syntax is identical to 'http_access' and the other lists of
 	ACL elements.  See the comments for 'http_access' below, or
@@ -2991,21 +3077,21 @@ DOC_END
 NAME: neighbor_type_domain
 TYPE: hostdomaintype
 DEFAULT: none
+DEFAULT_DOC: The peer type from cache_peer directive is used for all requests to that peer.
 LOC: none
 DOC_START
-	usage: neighbor_type_domain neighbor parent|sibling domain domain ...
+	Modify the cache_peer neighbor type when passing requests
+	about specific domains to the peer.
+
+	Usage:
+		 neighbor_type_domain neighbor parent|sibling domain domain ...
 
-	Modifying the neighbor type for specific domains is now
-	possible.  You can treat some domains differently than the
-	default neighbor type specified on the 'cache_peer' line.
-	Normally it should only be necessary to list domains which
-	should be treated differently because the default neighbor type
-	applies for hostnames which do not match domains listed here.
+	For example:
+		cache_peer foo.example.com parent 3128 3130
+		neighbor_type_domain foo.example.com sibling .au .de
 
-EXAMPLE:
-	cache_peer cache.foo.org parent 3128 3130
-	neighbor_type_domain cache.foo.org sibling .com .net
-	neighbor_type_domain cache.foo.org sibling .au .de
+	The above configuration treats all requests to foo.example.com as a
+	parent proxy unless the request is for a .au or .de ccTLD domain name.
 DOC_END
 
 NAME: dead_peer_timeout
@@ -3149,6 +3235,7 @@ NAME: memory_cache_mode
 TYPE: memcachemode
 LOC: Config
 DEFAULT: always
+DEFAULT_DOC: Keep the most recently fetched objects in memory
 DOC_START
 	Controls which objects to keep in the memory cache (cache_mem)
 
@@ -3169,7 +3256,7 @@ DOC_START
 	The memory replacement policy parameter determines which
 	objects are purged from memory when memory space is needed.
 
-	See cache_replacement_policy for details.
+	See cache_replacement_policy for details on algorithms.
 DOC_END
 
 COMMENT_START
@@ -3190,7 +3277,7 @@ DOC_START
 	    heap LFUDA: Least Frequently Used with Dynamic Aging
 	    heap LRU  : LRU policy implemented using a heap
 
-	Applies to any cache_dir lines listed below this.
+	Applies to any cache_dir lines listed below this directive.
 
 	The LRU policies keeps recently referenced objects.
 
@@ -3220,11 +3307,11 @@ DOC_END
 NAME: cache_dir
 TYPE: cachedir
 DEFAULT: none
+DEFAULT_DOC: No disk cache. Store cache ojects only in memory.
 LOC: Config.cacheSwap
 DOC_START
-	Usage:
-
-	cache_dir Type Directory-Name Fs-specific-data [options]
+	Format:
+		cache_dir Type Directory-Name Fs-specific-data [options]
 
 	You can specify multiple cache_dir lines to spread the
 	cache among different disk partitions.
@@ -3243,12 +3330,14 @@ DOC_START
 	and should use configuration macros or conditionals to give each
 	worker interested in disk caching a dedicated cache directory.
 
-	The ufs store type:
+
+	====  The ufs store type  ====
 
 	"ufs" is the old well-known Squid storage format that has always
 	been there.
 
-	cache_dir ufs Directory-Name Mbytes L1 L2 [options]
+	Usage:
+		cache_dir ufs Directory-Name Mbytes L1 L2 [options]
 
 	'Mbytes' is the amount of disk space (MB) to use under this
 	directory.  The default is 100 MB.  Change this to suit your
@@ -3263,23 +3352,27 @@ DOC_START
 	will be created under each first-level directory.  The default
 	is 256.
 
-	The aufs store type:
+
+	====  The aufs store type  ====
 
 	"aufs" uses the same storage format as "ufs", utilizing
 	POSIX-threads to avoid blocking the main Squid process on
 	disk-I/O. This was formerly known in Squid as async-io.
 
-	cache_dir aufs Directory-Name Mbytes L1 L2 [options]
+	Usage:
+		cache_dir aufs Directory-Name Mbytes L1 L2 [options]
 
 	see argument descriptions under ufs above
 
-	The diskd store type:
+
+	====  The diskd store type  ====
 
 	"diskd" uses the same storage format as "ufs", utilizing a
 	separate process to avoid blocking the main Squid process on
 	disk-I/O.
 
-	cache_dir diskd Directory-Name Mbytes L1 L2 [options] [Q1=n] [Q2=n]
+	Usage:
+		cache_dir diskd Directory-Name Mbytes L1 L2 [options] [Q1=n] [Q2=n]
 
 	see argument descriptions under ufs above
 
@@ -3297,8 +3390,10 @@ DOC_START
 	higher hit ratio at the expense of an increase in response
 	time.
 
-	The rock store type:
 
+	====  The rock store type  ====
+
+	Usage:
 	    cache_dir rock Directory-Name Mbytes <max-size=bytes> [options]
 
 	The Rock Store type is a database-style storage. All cached
@@ -3337,7 +3432,7 @@ DOC_START
 	enforcement. Currently supported by IpcIo module only.
 
 
-	The coss store type:
+	====  The coss store type  ====
 
 	NP: COSS filesystem in Squid-3 has been deemed too unstable for
 	    production use and has thus been removed from this release.
@@ -3355,24 +3450,31 @@ DOC_START
 	called 'stripe' in the directory names in the config - and
 	this will be created by squid -z.
 
-	Common options:
 
-	no-store, no new objects should be stored to this cache_dir
+	==== COMMON OPTIONS ====
 
-	min-size=n, refers to the min object size in bytes this cache_dir
-	will accept.  It's used to restrict a cache_dir to only store
-	large objects (e.g. aufs) while other storedirs are optimized
-	for smaller objects (e.g. COSS). Defaults to 0.
+	no-store	no new objects should be stored to this cache_dir.
+
+	min-size=n	the minimum object size in bytes this cache_dir
+			will accept.  It's used to restrict a cache_dir
+			to only store large objects (e.g. AUFS) while
+			other stores are optimized for smaller objects
+			(e.g. COSS).
+			Defaults to 0.
+
+	max-size=n	the maximum object size in bytes this cache_dir
+			supports.
+			The value in maximum_object_size directive, sets
+			a default unless more specific details are available
+			about the cache_dir (ie a small store capacity).
 
-	max-size=n, refers to the max object size in bytes this cache_dir
-	supports.  It is used to select the cache_dir to store the object.
 	Note: To make optimal use of the max-size limits you should order
-	the cache_dir lines with the smallest max-size value first and the
-	ones with no max-size specification last.
+	the cache_dir lines with the smallest max-size value first.
 
 	Note for coss, max-size must be less than COSS_MEMBUF_SZ,
 	which can be changed with the --with-coss-membuf-size=N configure
 	option.
+
 NOCOMMENT_START
 
 # Uncomment and adjust the following to add a disk cache directory.
@@ -3385,13 +3487,54 @@ TYPE: string
 LOC: Config.store_dir_select_algorithm
 DEFAULT: least-load
 DOC_START
-	Set this to 'round-robin' as an alternative.
+	How Squid selects which cache_dir to use when the response
+	object will fit into more than one.
+
+	Regardless of which algorithm is used the cache_dir min-size
+	and max-size parameters are obeyed. As such they can affect
+	the selection algorithm by limiting the set of considered
+	cache_dir.
+
+	Algorithms:
+
+		least-load
+
+	This algorithm is suited to caches with similar cache_dir
+	sizes and disk speeds.
+
+	The disk with the least I/O pending is selected.
+	When there are multiple disks with the same I/O load ranking
+	the cache_dir with most available capacity is selected.
+
+	When a mix of cache_dir sizes are configured the faster disks
+	have a naturally lower I/O loading and larger disks have more
+	capacity. So space used to store objects and data throughput
+	may be very unbalanced towards larger disks.
+
+
+		round-robin
+
+	This algorithm is suited to caches with unequal cache_dir
+	disk sizes.
+
+	Each cache_dir is selected in a rotation. The next suitable
+	cache_dir is used.
+
+	Available cache_dir capacity is only considered in relation
+	to whether the object will fit and meets the min-size and
+	max-size parameters.
+
+	Disk I/O loading is only considered to prevent overload on slow
+	disks. This algorithm does not spread objects by size, so any
+	I/O loading per-disk may appear very unbalanced and volatile.
+
 DOC_END
 
 NAME: max_open_disk_fds
 TYPE: int
 LOC: Config.max_open_disk_fds
 DEFAULT: 0
+DEFAULT_DOC: no limit
 DOC_START
 	To avoid having disk as the I/O bottleneck Squid can optionally
 	bypass the on-disk cache if more than this amount of disk file
@@ -3404,11 +3547,12 @@ NAME: minimum_object_size
 COMMENT: (bytes)
 TYPE: b_int64_t
 DEFAULT: 0 KB
+DEFAULT_DOC: no limit
 LOC: Config.Store.minObjectSize
 DOC_START
 	Objects smaller than this size will NOT be saved on disk.  The
-	value is specified in kilobytes, and the default is 0 KB, which
-	means there is no minimum.
+	value is specified in bytes, and the default is 0 KB, which
+	means all responses can be stored.
 DOC_END
 
 NAME: maximum_object_size
@@ -3438,16 +3582,28 @@ COMMENT: (percent, 0-100)
 TYPE: int
 DEFAULT: 90
 LOC: Config.Swap.lowWaterMark
-DOC_NONE
+DOC_START
+	The low-water mark for cache object replacement.
+	Replacement begins when the swap (disk) usage is above the
+	low-water mark and attempts to maintain utilization near the
+	low-water mark.  As swap utilization gets close to high-water
+	mark object eviction becomes more aggressive.  If utilization is
+	close to the low-water mark less replacement is done each time.
+
+	Defaults are 90% and 95%. If you have a large cache, 5% could be
+	hundreds of MB. If this is the case you may wish to set these
+	numbers closer together.
+
+	See also cache_swap_high
+DOC_END
 
 NAME: cache_swap_high
 COMMENT: (percent, 0-100)
 TYPE: int
 DEFAULT: 95
 LOC: Config.Swap.highWaterMark
 DOC_START
-
-	The low- and high-water marks for cache object replacement.
+	The high-water mark for cache object replacement.
 	Replacement begins when the swap (disk) usage is above the
 	low-water mark and attempts to maintain utilization near the
 	low-water mark.  As swap utilization gets close to high-water
@@ -3457,6 +3613,8 @@ DOC_START
 	Defaults are 90% and 95%. If you have a large cache, 5% could be
 	hundreds of MB. If this is the case you may wish to set these
 	numbers closer together.
+
+	See also cache_swap_low
 DOC_END
 
 COMMENT_START
@@ -3468,6 +3626,7 @@ NAME: logformat
 TYPE: logformat
 LOC: Log::TheConfig
 DEFAULT: none
+DEFAULT_DOC: The format definitions squid, common, combined, referrer, useragent are built in.
 DOC_START
 	Usage:
 
@@ -3552,9 +3711,15 @@ DOC_START
 
 	HTTP related format codes:
 
-		[http::]>h	Original request header. Optional header name argument
-				on the format header[:[separator]element]
-		[http::]>ha	The HTTP request headers after adaptation and redirection. 
+		[http::]>h	Original received request header. 
+				Usually differs from the request header sent by
+				Squid, although most fields are often preserved.
+				Accepts optional header field name/value filter
+				argument using name[:[separator]element] format.
+		[http::]>ha	Received request header after adaptation and
+				redirection (pre-cache REQMOD vectoring point).
+				Usually differs from the request header sent by
+				Squid, although most fields are often preserved.
 				Optional header name argument as for >h
 		[http::]<h	Reply header. Optional header name argument
 				as for >h
@@ -3692,16 +3857,47 @@ TYPE: access_log
 LOC: Config.Log.accesslogs
 DEFAULT_IF_NONE: daemon:@DEFAULT_ACCESS_LOG@ squid
 DOC_START
-	These files log client request activities. Has a line every HTTP or
-	ICP request. The format is:
+	Configures whether and how Squid logs HTTP and ICP transactions.
+	If access logging is enabled, a single line is logged for every 
+	matching HTTP or ICP request. The recommended directive formats are:
+
+	access_log <module>:<place> [option ...] [acl acl ...]
+	access_log none [acl acl ...]
+
+	The following directive format is accepted but may be deprecated:
 	access_log <module>:<place> [<logformat name> [acl acl ...]]
-	access_log none [acl acl ...]]
+
+        In most cases, the first ACL name must not contain the '=' character
+	and should not be equal to an existing logformat name. You can always
+	start with an 'all' ACL to work around those restrictions.
 	
 	Will log to the specified module:place using the specified format (which
 	must be defined in a logformat directive) those entries which match
 	ALL the acl's specified (which must be defined in acl clauses).
 	If no acl is specified, all requests will be logged to this destination.
 	
+	===== Available options for the recommended directive format =====
+
+	logformat=name		Names log line format (either built-in or
+				defined by a logformat directive). Defaults
+				to 'squid'.
+
+	buffer-size=64KB	Defines approximate buffering limit for log
+				records (see buffered_logs).  Squid should not
+				keep more than the specified size and, hence,
+				should flush records before the buffer becomes
+				full to avoid overflows under normal
+				conditions (the exact flushing algorithm is
+				module-dependent though).  The on-error option
+				controls overflow handling.
+
+	on-error=die|drop	Defines action on unrecoverable errors. The
+				'drop' action ignores (i.e., does not log)
+				affected log records. The default 'die' action
+				kills the affected worker. The drop action 
+				support has not been tested for modules other
+				than tcp.
+
 	===== Modules Currently available =====
 	
 	none	Do not log any requests matching these ACL.
@@ -3732,6 +3928,7 @@ DOC_START
 		Place Format:   //host:port
 
 	tcp	To send each log line as text data to a TCP receiver.
+		Lines may be accumulated before sending (see buffered_logs).
 		Place: The destination host name or IP and port.
 		Place Format:   //host:port
 
@@ -3852,6 +4049,7 @@ NAME: log_access
 TYPE: acl_access
 LOC: Config.accessList.log
 DEFAULT: none
+DEFAULT_DOC: Allow logging for all transactions.
 COMMENT: allow|deny acl acl...
 DOC_START
 	This options allows you to control which requests gets logged
@@ -3867,6 +4065,7 @@ TYPE: acl_access
 IFDEF: ICAP_CLIENT
 LOC: Config.accessList.icap
 DEFAULT: none
+DEFAULT_DOC: Allow logging for all ICAP transactions.
 DOC_START
 	This options allows you to control which requests get logged
 	to icap.log. See the icap_log directive for ICAP log details.
@@ -3895,6 +4094,7 @@ NAME: cache_swap_state cache_swap_log
 TYPE: string
 LOC: Config.Log.swap
 DEFAULT: none
+DEFAULT_DOC: Store the journal inside its cache_dir
 DOC_START
 	Location for the cache "swap.state" file. This index file holds
 	the metadata of objects saved on disk.  It is used to rebuild
@@ -3944,8 +4144,8 @@ DOC_START
 	in the habit of using 'squid -k rotate' instead of 'kill -USR1
 	<pid>'.
 
-	Note, from Squid-3.1 this option has no effect on the cache.log,
-	that log can be rotated separately by using debug_options
+	Note, from Squid-3.1 this option is only a default for cache.log,
+	that log can be rotated separately by using debug_options.
 DOC_END
 
 NAME: emulate_httpd_log
@@ -3965,9 +4165,10 @@ TYPE: string
 DEFAULT: @DEFAULT_MIME_TABLE@
 LOC: Config.mimeTablePathname
 DOC_START
-	Pathname to Squid's MIME table. You shouldn't need to change
-	this, but the default file contains examples and formatting
-	information if you do.
+	Path to Squid's icon configuration file.
+
+	You shouldn't need to change this, but the default file contains
+	examples and formatting information if you do.
 DOC_END
 
 NAME: log_mime_hdrs
@@ -4013,6 +4214,7 @@ NAME: client_netmask
 TYPE: address
 LOC: Config.Addrs.client_netmask
 DEFAULT: no_addr
+DEFAULT_DOC: Log full client IP address
 DOC_START
 	A netmask for client addresses in logfiles and cachemgr output.
 	Change this to protect the privacy of your cache clients.
@@ -4032,7 +4234,10 @@ LOC: Config.onoff.strip_query_terms
 DEFAULT: on
 DOC_START
 	By default, Squid strips query terms from requested URLs before
-	logging.  This protects your user's privacy.
+	logging.  This protects your user's privacy and reduces log size.
+
+	When investigating HIT/MISS or other caching behaviour you
+	will need to disable this to see the full URL used by Squid.
 DOC_END
 
 NAME: buffered_logs
@@ -4041,11 +4246,18 @@ TYPE: onoff
 DEFAULT: off
 LOC: Config.onoff.buffered_logs
 DOC_START
-	cache.log log file is written with stdio functions, and as such
-	it can be buffered or unbuffered. By default it will be unbuffered.
-	Buffering it can speed up the writing slightly (though you are
-	unlikely to need to worry unless you run with tons of debugging
-	enabled in which case performance will suffer badly anyway..).
+	Whether to write/send access_log records ASAP or accumulate them and
+	then write/send them in larger chunks. Buffering may improve
+	performance because it decreases the number of I/Os. However,
+	buffering increases the delay before log records become available to
+	the final recipient (e.g., a disk file or logging daemon) and,
+	hence, increases the risk of log records loss.
+
+	Note that even when buffered_logs are off, Squid may have to buffer
+	records if it cannot write/send them immediately due to pending I/Os
+	(e.g., the I/O writing the previous log record) or connectivity loss.
+
+	Currently honored by 'daemon' and 'tcp' access_log modules only.
 DOC_END
 
 NAME: netdb_filename
@@ -4054,7 +4266,9 @@ DEFAULT: stdio:@DEFAULT_NETDB_FILE@
 LOC: Config.netdbFilename
 IFDEF: USE_ICMP
 DOC_START
-	A filename where Squid stores it's netdb state between restarts.
+	Where Squid stores it's netdb journal.
+	When enabled this journal preserves netdb state between restarts.
+
 	To disable, enter "none".
 DOC_END
 
@@ -4068,14 +4282,17 @@ TYPE: string
 DEFAULT_IF_NONE: @DEFAULT_CACHE_LOG@
 LOC: Debug::cache_log
 DOC_START
-	Cache logging file. This is where general information about
-	your cache's behavior goes. You can increase the amount of data
-	logged to this file and how often its rotated with "debug_options"
+	Squid administrative logging file.
+
+	This is where general information about Squid behavior goes. You can
+	increase the amount of data logged to this file and how often it is
+	rotated with "debug_options"
 DOC_END
 
 NAME: debug_options
 TYPE: eol
 DEFAULT: ALL,1
+DEFAULT_DOC: Log all critical and important messages.
 LOC: Debug::debugOptions
 DOC_START
 	Logging options are set as section,level where each source file
@@ -4084,7 +4301,7 @@ DOC_START
 	log file, so be careful.
 
 	The magic word "ALL" sets debugging levels for all sections.
-	We recommend normally running with "ALL,1".
+	The default is to run with "ALL,1" to record important warnings.
 
 	The rotate=N option can be used to keep more or less of these logs
 	than would otherwise be kept by logfile_rotate.
@@ -4096,6 +4313,7 @@ NAME: coredump_dir
 TYPE: string
 LOC: Config.coredump_dir
 DEFAULT_IF_NONE: none
+DEFAULT_DOC: Use the directory from where Squid was started.
 DOC_START
 	By default Squid leaves core files in the directory from where
 	it was started. If you set 'coredump_dir' to a directory
@@ -4121,13 +4339,13 @@ DEFAULT: Squid@
 LOC: Config.Ftp.anon_user
 DOC_START
 	If you want the anonymous login password to be more informative
-	(and enable the use of picky ftp servers), set this to something
+	(and enable the use of picky FTP servers), set this to something
 	reasonable for your domain, like wwwuser@somewhere.net
 
 	The reason why this is domainless by default is the
 	request can be made on the behalf of a user in any domain,
 	depending on how the cache is used.
-	Some ftp server also validate the email address is valid
+	Some FTP server also validate the email address is valid
 	(for example perl.com).
 DOC_END
 
@@ -4412,11 +4630,11 @@ DOC_END
 NAME: url_rewrite_access redirector_access
 TYPE: acl_access
 DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 LOC: Config.accessList.redirector
 DOC_START
 	If defined, this access list specifies which requests are
-	sent to the redirector processes.  By default all requests
-	are sent.
+	sent to the redirector processes.
 
 	This clause supports both fast and slow acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
@@ -4428,7 +4646,7 @@ LOC: Config.onoff.redirector_bypass
 DEFAULT: off
 DOC_START
 	When this is 'on', a request will not go through the
-	redirector if all redirectors are busy.  If this is 'off'
+	redirector if all the helpers are busy.  If this is 'off'
 	and the redirector queue grows too large, Squid will exit
 	with a FATAL error and ask you to increase the number of
 	redirectors.  You should only enable this if the redirectors
@@ -4535,6 +4753,7 @@ DOC_END
 NAME: store_id_access storeurl_rewrite_access
 TYPE: acl_access
 DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 LOC: Config.accessList.store_id
 DOC_START
 	If defined, this access list specifies which requests are
@@ -4568,6 +4787,7 @@ COMMENT_END
 NAME: cache no_cache
 TYPE: acl_access
 DEFAULT: none
+DEFAULT_DOC: Allow caching, unless rules exist in squid.conf.
 LOC: Config.accessList.noCache
 DOC_START
 	A list of ACL elements which, if matched and denied, cause the request to
@@ -4577,8 +4797,6 @@ DOC_START
 	You must use the words 'allow' or 'deny' to indicate whether items
 	matching the ACL should be allowed or denied into the cache.
 
-	Default is to allow all to be cached.
-
 	This clause supports both fast and slow acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
 DOC_END
@@ -4707,7 +4925,9 @@ DOC_START
 
 NOCOMMENT_START
 
+#
 # Add any of your own refresh_pattern entries above these.
+#
 refresh_pattern ^ftp:		1440	20%	10080
 refresh_pattern ^gopher:	1440	0%	1440
 refresh_pattern -i (/cgi-bin/|\?) 0	0%	0
@@ -4865,13 +5085,15 @@ LOC: Config.minimum_expiry_time
 DEFAULT: 60 seconds
 DOC_START
 	The minimum caching time according to (Expires - Date)
-	Headers Squid honors if the object can't be revalidated
-	defaults to 60 seconds. In reverse proxy environments it
-	might be desirable to honor shorter object lifetimes. It
-	is most likely better to make your server return a
-	meaningful Last-Modified header however. In ESI environments
-	where page fragments often have short lifetimes, this will
-	often be best set to 0.
+	headers Squid honors if the object can't be revalidated.
+	The default is 60 seconds.
+
+	In reverse proxy environments it might be desirable to honor
+	shorter object lifetimes. It is most likely better to make
+	your server return a meaningful Last-Modified header however.
+
+	In ESI environments where page fragments often have short
+	lifetimes, this will often be best set to 0.
 DOC_END
 
 NAME: store_avg_object_size
@@ -4882,6 +5104,14 @@ LOC: Config.Store.avgObjectSize
 DOC_START
 	Average object size, used to estimate number of objects your
 	cache can hold.  The default is 13 KB.
+
+	This is used to pre-seed the cache index memory allocation to
+	reduce expensive reallocate operations while handling clients
+	traffic. Too-large values may result in memory allocation during
+	peak traffic, too-small values will result in wasted memory.
+
+	Check the cache manager 'info' report metrics for the real
+	object sizes seen by your Squid before tuning this.
 DOC_END
 
 NAME: store_objects_per_bucket
@@ -4929,6 +5159,7 @@ NAME: request_body_max_size
 COMMENT: (bytes)
 TYPE: b_int64_t
 DEFAULT: 0 KB
+DEFAULT_DOC: No limit.
 LOC: Config.maxRequestBodySize
 DOC_START
 	This specifies the maximum size for an HTTP request body.
@@ -4937,6 +5168,9 @@ DOC_START
 	than this limit receives an "Invalid Request" error message.
 	If you set this parameter to a zero (the default), there will
 	be no limit imposed.
+
+	See also client_request_buffer_max_size for an alternative
+	limitation on client uploads which can be configured.
 DOC_END
 
 NAME: client_request_buffer_max_size
@@ -4981,6 +5215,7 @@ NAME: broken_posts
 IFDEF: USE_HTTP_VIOLATIONS
 TYPE: acl_access
 DEFAULT: none
+DEFAULT_DOC: Obey RFC 2616.
 LOC: Config.accessList.brokenPosts
 DOC_START
 	A list of ACL elements which, if matched, causes Squid to send
@@ -5089,6 +5324,7 @@ IFDEF: USE_HTTP_VIOLATIONS
 TYPE: http_header_access
 LOC: Config.request_header_access
 DEFAULT: none
+DEFAULT_DOC: No limits.
 DOC_START
 	Usage: request_header_access header_name allow|deny [!]aclname ...
 
@@ -5128,53 +5364,38 @@ DOC_START
 
 		request_header_access From deny all
 		request_header_access Referer deny all
-		request_header_access Server deny all
 		request_header_access User-Agent deny all
-		request_header_access WWW-Authenticate deny all
-		request_header_access Link deny all
 
 	Or, to reproduce the old 'http_anonymizer paranoid' feature
 	you should use:
 
-		request_header_access Allow allow all
 		request_header_access Authorization allow all
-		request_header_access WWW-Authenticate allow all
 		request_header_access Proxy-Authorization allow all
-		request_header_access Proxy-Authenticate allow all
 		request_header_access Cache-Control allow all
-		request_header_access Content-Encoding allow all
 		request_header_access Content-Length allow all
 		request_header_access Content-Type allow all
 		request_header_access Date allow all
-		request_header_access Expires allow all
 		request_header_access Host allow all
 		request_header_access If-Modified-Since allow all
-		request_header_access Last-Modified allow all
-		request_header_access Location allow all
 		request_header_access Pragma allow all
 		request_header_access Accept allow all
 		request_header_access Accept-Charset allow all
 		request_header_access Accept-Encoding allow all
 		request_header_access Accept-Language allow all
-		request_header_access Content-Language allow all
-		request_header_access Mime-Version allow all
-		request_header_access Retry-After allow all
-		request_header_access Title allow all
 		request_header_access Connection allow all
 		request_header_access All deny all
 
-	although many of those are HTTP reply headers, and so should be
-	controlled with the reply_header_access directive.
+	HTTP reply headers are controlled with the reply_header_access directive.
 
-	By default, all headers are allowed (no anonymizing is
-	performed).
+	By default, all headers are allowed (no anonymizing is performed).
 DOC_END
 
 NAME: reply_header_access
 IFDEF: USE_HTTP_VIOLATIONS
 TYPE: http_header_access
 LOC: Config.reply_header_access
 DEFAULT: none
+DEFAULT_DOC: No limits.
 DOC_START
 	Usage: reply_header_access header_name allow|deny [!]aclname ...
 
@@ -5192,45 +5413,33 @@ DOC_START
 	For example, to achieve the same behavior as the old
 	'http_anonymizer standard' option, you should use:
 
-		reply_header_access From deny all
-		reply_header_access Referer deny all
 		reply_header_access Server deny all
-		reply_header_access User-Agent deny all
 		reply_header_access WWW-Authenticate deny all
 		reply_header_access Link deny all
 
 	Or, to reproduce the old 'http_anonymizer paranoid' feature
 	you should use:
 
 		reply_header_access Allow allow all
-		reply_header_access Authorization allow all
 		reply_header_access WWW-Authenticate allow all
-		reply_header_access Proxy-Authorization allow all
 		reply_header_access Proxy-Authenticate allow all
 		reply_header_access Cache-Control allow all
 		reply_header_access Content-Encoding allow all
 		reply_header_access Content-Length allow all
 		reply_header_access Content-Type allow all
 		reply_header_access Date allow all
 		reply_header_access Expires allow all
-		reply_header_access Host allow all
-		reply_header_access If-Modified-Since allow all
 		reply_header_access Last-Modified allow all
 		reply_header_access Location allow all
 		reply_header_access Pragma allow all
-		reply_header_access Accept allow all
-		reply_header_access Accept-Charset allow all
-		reply_header_access Accept-Encoding allow all
-		reply_header_access Accept-Language allow all
 		reply_header_access Content-Language allow all
-		reply_header_access Mime-Version allow all
 		reply_header_access Retry-After allow all
 		reply_header_access Title allow all
+		reply_header_access Content-Disposition allow all
 		reply_header_access Connection allow all
 		reply_header_access All deny all
 
-	although the HTTP request headers won't be usefully controlled
-	by this directive -- see request_header_access for details.
+	HTTP request headers are controlled with the request_header_access directive.
 
 	By default, all headers are allowed (no anonymizing is
 	performed).
@@ -5247,8 +5456,7 @@ DOC_START
 
 	This option allows you to change the contents of headers
 	denied with request_header_access above, by replacing them
-	with some fixed string. This replaces the old fake_user_agent
-	option.
+	with some fixed string.
 
 	This only applies to request headers, not reply headers.
 
@@ -5520,7 +5728,7 @@ DEFAULT: webmaster
 LOC: Config.adminEmail
 DOC_START
 	Email-address of local cache manager who will receive
-	mail if the cache dies.  The default is "webmaster."
+	mail if the cache dies.  The default is "webmaster".
 DOC_END
 
 NAME: mail_from
@@ -5529,9 +5737,9 @@ DEFAULT: none
 LOC: Config.EmailFrom
 DOC_START
 	From: email-address for mail sent when the cache dies.
-	The default is to use 'appname@unique_hostname'.
-	Default appname value is "squid", can be changed into
-	src/globals.h before building squid.
+	The default is to use 'squid@unique_hostname'.
+
+	See also: unique_hostname directive.
 DOC_END
 
 NAME: mail_program
@@ -5561,6 +5769,7 @@ DOC_END
 NAME: cache_effective_group
 TYPE: string
 DEFAULT: none
+DEFAULT_DOC: Use system group memberships of the cache_effective_user account
 LOC: Config.effectiveGroup
 DOC_START
 	Squid sets the GID to the effective user's default group ID
@@ -5593,6 +5802,7 @@ NAME: visible_hostname
 TYPE: string
 LOC: Config.visibleHostname
 DEFAULT: none
+DEFAULT_DOC: Automatically detect the system host name
 DOC_START
 	If you want to present a special hostname in error messages, etc,
 	define this.  Otherwise, the return value of gethostname()
@@ -5605,6 +5815,7 @@ NAME: unique_hostname
 TYPE: string
 LOC: Config.uniqueHostname
 DEFAULT: none
+DEFAULT_DOC: Copy the value from visible_hostname
 DOC_START
 	If you want to have multiple machines with the same
 	'visible_hostname' you must give each machine a different
@@ -5659,10 +5870,9 @@ NAME: announce_period
 TYPE: time_t
 LOC: Config.Announce.period
 DEFAULT: 0
+DEFAULT_DOC: Announcement messages disabled.
 DOC_START
-	This is how frequently to send cache announcements.  The
-	default is `0' which disables sending the announcement
-	messages.
+	This is how frequently to send cache announcements.
 
 	To enable announcing your cache, just set an announce period.
 
@@ -5674,26 +5884,29 @@ NAME: announce_host
 TYPE: string
 DEFAULT: tracker.ircache.net
 LOC: Config.Announce.host
-DOC_NONE
+DOC_START
+	Set the hostname where announce registration messages will be sent.
+
+	See also announce_port and announce_file
+DOC_END
 
 NAME: announce_file
 TYPE: string
 DEFAULT: none
 LOC: Config.Announce.file
-DOC_NONE
+DOC_START
+	The contents of this file will be included in the announce
+	registration messages.
+DOC_END
 
 NAME: announce_port
 TYPE: u_short
 DEFAULT: 3131
 LOC: Config.Announce.port
 DOC_START
-	announce_host and announce_port set the hostname and port
-	number where the registration message will be sent.
+	Set the port where announce registration messages will be sent.
 
-	Hostname will default to 'tracker.ircache.net' and port will
-	default default to 3131.  If the 'filename' argument is given,
-	the contents of that file will be included in the announce
-	message.
+	See also announce_host and announce_file
 DOC_END
 
 COMMENT_START
@@ -5704,14 +5917,13 @@ COMMENT_END
 NAME: httpd_accel_surrogate_id
 TYPE:  string
 DEFAULT: none
+DEFAULT_DOC: visible_hostname is used if no specific ID is set.
 LOC: Config.Accel.surrogate_id
 DOC_START
 	Surrogates (http://www.esi.org/architecture_spec_1.0.html)
 	need an identification token to allow control targeting. Because
 	a farm of surrogates may all perform the same tasks, they may share
 	an identification token.
-
-	The default ID is the visible_hostname
 DOC_END
 
 NAME: http_accel_surrogate_remote
@@ -5720,7 +5932,9 @@ TYPE: onoff
 DEFAULT: off
 LOC: Config.onoff.surrogate_is_remote
 DOC_START
-	Remote surrogates (such as those in a CDN) honour Surrogate-Control: no-store-remote.
+	Remote surrogates (such as those in a CDN) honour the header
+	"Surrogate-Control: no-store-remote".
+
 	Set this to on to have squid behave as a remote surrogate.
 DOC_END
 
@@ -5750,6 +5964,9 @@ DOC_START
 	This represents the number of delay pools to be used.  For example,
 	if you have one class 2 delay pool and one class 3 delays pool, you
 	have a total of 2 delay pools.
+
+	See also delay_parameters, delay_class, delay_access for pool
+	configuration details.
 DOC_END
 
 NAME: delay_class
@@ -5806,11 +6023,17 @@ DOC_START
 
 	NOTE-2: Due to the use of bitmasks in class 2,3,4 pools they only apply to
 		IPv4 traffic. Class 1 and 5 pools may be used with IPv6 traffic.
+
+	This clause only supports fast acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+
+	See also delay_parameters and delay_access.
 DOC_END
 
 NAME: delay_access
 TYPE: delay_pool_access
 DEFAULT: none
+DEFAULT_DOC: Deny using the pool, unless allow rules exist in squid.conf for the pool.
 IFDEF: USE_DELAY_POOLS
 LOC: Config.Delay
 DOC_START
@@ -5824,12 +6047,14 @@ DOC_START
 	For example, if you want some_big_clients in delay
 	pool 1 and lotsa_little_clients in delay pool 2:
 
-Example:
- delay_access 1 allow some_big_clients
- delay_access 1 deny all
- delay_access 2 allow lotsa_little_clients
- delay_access 2 deny all
- delay_access 3 allow authenticated_clients
+		delay_access 1 allow some_big_clients
+		delay_access 1 deny all
+		delay_access 2 allow lotsa_little_clients
+		delay_access 2 deny all
+		delay_access 3 allow authenticated_clients
+
+	See also delay_parameters and delay_class.
+
 DOC_END
 
 NAME: delay_parameters
@@ -5921,6 +6146,10 @@ DOC_START
 	be limited to 128Kbits/sec no matter how many workstations they are logged into.:
 
 		delay_parameters 4 32000/32000 8000/8000 600/64000 16000/16000
+
+
+	See also delay_class and delay_access.
+
 DOC_END
 
 NAME: delay_initial_bucket_level
@@ -5951,8 +6180,10 @@ DOC_START
 	This option specifies the number of client delay pools used. It must
 	preceed other client_delay_* options.
 
-Example:
- client_delay_pools 2
+	Example:
+		client_delay_pools 2
+
+	See also client_delay_parameters and client_delay_access.
 DOC_END
 
 NAME: client_delay_initial_bucket_level
@@ -5971,8 +6202,8 @@ DOC_START
 	buckets are not refilled until their size goes down to max_bucket_size
 	from client_delay_parameters.
 
-Example:
- client_delay_initial_bucket_level 50
+	Example:
+		client_delay_initial_bucket_level 50
 DOC_END
 
 NAME: client_delay_parameters
@@ -5997,18 +6228,21 @@ DOC_START
 	Please see the delay_parameters option for more information and
 	examples.
 
-Example:
- client_delay_parameters 1 1024 2048
- client_delay_parameters 2 51200 16384
+	Example:
+		client_delay_parameters 1 1024 2048
+		client_delay_parameters 2 51200 16384
+
+	See also client_delay_access.
+
 DOC_END
 
 NAME: client_delay_access
 TYPE: client_delay_pool_access
 DEFAULT: none
+DEFAULT_DOC: Deny use of the pool, unless allow rules exist in squid.conf for the pool.
 IFDEF: USE_DELAY_POOLS
 LOC: Config.ClientDelay
 DOC_START
-
 	This option determines the client-side delay pool for the
 	request:
 
@@ -6025,11 +6259,19 @@ DOC_START
 	not used to aggregate clients. Clients are always aggregated
 	based on their source IP addresses (one bucket per source IP).
 
+	This clause only supports fast acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+	Additionally, only the client TCP connection details are available.
+	ACLs testing HTTP properties will not work.
+
 	Please see delay_access for more examples.
 
-Example:
- client_delay_access 1 allow low_rate_network
- client_delay_access 2 allow vips_network
+	Example:
+		client_delay_access 1 allow low_rate_network
+		client_delay_access 2 allow vips_network
+
+
+	See also client_delay_parameters and client_delay_pools.
 DOC_END
 
 COMMENT_START
@@ -6041,6 +6283,7 @@ NAME: wccp_router
 TYPE: address
 LOC: Config.Wccp.router
 DEFAULT: any_addr
+DEFAULT_DOC: WCCP disabled.
 IFDEF: USE_WCCP
 DOC_START
 	Use this option to define your WCCP ``home'' router for
@@ -6058,6 +6301,7 @@ NAME: wccp2_router
 TYPE: IpAddress_list
 LOC: Config.Wccp2.router
 DEFAULT: none
+DEFAULT_DOC: WCCPv2 disabled.
 IFDEF: USE_WCCPv2
 DOC_START
 	Use this option to define your WCCP ``home'' router for
@@ -6157,6 +6401,7 @@ NAME: wccp2_service
 TYPE: wccp2_service
 LOC: Config.Wccp2.info
 DEFAULT_IF_NONE: standard 0
+DEFAULT_DOC: Use the 'web-cache' standard service.
 IFDEF: USE_WCCPv2
 DOC_START
 	WCCP2 allows for multiple traffic services. There are two
@@ -6226,13 +6471,20 @@ NAME: wccp_address
 TYPE: address
 LOC: Config.Wccp.address
 DEFAULT: 0.0.0.0
+DEFAULT_DOC: Address selected by the operating system.
 IFDEF: USE_WCCP
-DOC_NONE
+DOC_START
+	Use this option if you require WCCPv2 to use a specific
+	interface address.
+
+	The default behavior is to not bind to any specific address.
+DOC_END
 
 NAME: wccp2_address
 TYPE: address
 LOC: Config.Wccp2.address
 DEFAULT: 0.0.0.0
+DEFAULT_DOC: Address selected by the operating system.
 IFDEF: USE_WCCPv2
 DOC_START
 	Use this option if you require WCCP to use a specific
@@ -6252,17 +6504,20 @@ NAME: client_persistent_connections
 TYPE: onoff
 LOC: Config.onoff.client_pconns
 DEFAULT: on
-DOC_NONE
+DOC_START
+	Persistent connection support for clients.
+	Squid uses persistent connections (when allowed). You can use
+	this option to disable persistent connections with clients.
+DOC_END
 
 NAME: server_persistent_connections
 TYPE: onoff
 LOC: Config.onoff.server_pconns
 DEFAULT: on
 DOC_START
-	Persistent connection support for clients and servers.  By
-	default, Squid uses persistent connections (when allowed)
-	with its clients and servers.  You can use these options to
-	disable persistent connections with clients and/or servers.
+	Persistent connection support for servers.
+	Squid uses persistent connections (when allowed). You can use
+	this option to disable persistent connections with servers.
 DOC_END
 
 NAME: persistent_connection_after_error
@@ -6370,6 +6625,7 @@ NAME: snmp_port
 TYPE: u_short
 LOC: Config.Port.snmp
 DEFAULT: 0
+DEFAULT_DOC: SNMP disabled.
 IFDEF: SQUID_SNMP
 DOC_START
 	The port number where Squid listens for SNMP requests. To enable
@@ -6384,7 +6640,8 @@ DOC_END
 NAME: snmp_access
 TYPE: acl_access
 LOC: Config.accessList.snmp
-DEFAULT_IF_NONE: deny all
+DEFAULT: none
+DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 IFDEF: SQUID_SNMP
 DOC_START
 	Allowing or denying access to the SNMP port.
@@ -6396,6 +6653,7 @@ DOC_START
 
 	This clause only supports fast acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+
 Example:
  snmp_access allow snmppublic localhost
  snmp_access deny all
@@ -6405,32 +6663,37 @@ NAME: snmp_incoming_address
 TYPE: address
 LOC: Config.Addrs.snmp_incoming
 DEFAULT: any_addr
+DEFAULT_DOC: Accept SNMP packets from all machine interfaces.
 IFDEF: SQUID_SNMP
-DOC_NONE
+DOC_START
+	Just like 'udp_incoming_address', but for the SNMP port.
+
+	snmp_incoming_address	is used for the SNMP socket receiving
+				messages from SNMP agents.
+
+	The default snmp_incoming_address is to listen on all
+	available network interfaces.
+DOC_END
 
 NAME: snmp_outgoing_address
 TYPE: address
 LOC: Config.Addrs.snmp_outgoing
 DEFAULT: no_addr
+DEFAULT_DOC: Use snmp_incoming_address or an address selected by the operating system.
 IFDEF: SQUID_SNMP
 DOC_START
-	Just like 'udp_incoming_address', but for the SNMP port.
+	Just like 'udp_outgoing_address', but for the SNMP port.
 
-	snmp_incoming_address	is used for the SNMP socket receiving
-				messages from SNMP agents.
 	snmp_outgoing_address	is used for SNMP packets returned to SNMP
 				agents.
 
-	The default snmp_incoming_address is to listen on all
-	available network interfaces.
-
 	If snmp_outgoing_address is not set it will use the same socket
 	as snmp_incoming_address. Only change this if you want to have
 	SNMP replies sent using another address than where this Squid
 	listens for SNMP queries.
 
 	NOTE, snmp_incoming_address and snmp_outgoing_address can not have
-	the same value since they both use port 3401.
+	the same value since they both use the same port.
 DOC_END
 
 COMMENT_START
@@ -6441,11 +6704,11 @@ COMMENT_END
 NAME: icp_port udp_port
 TYPE: u_short
 DEFAULT: 0
+DEFAULT_DOC: ICP disabled.
 LOC: Config.Port.icp
 DOC_START
 	The port number where Squid sends and receives ICP queries to
 	and from neighbor caches.  The standard UDP port for ICP is 3130.
-	Default is disabled (0).
 
 	Example:
 		icp_port @DEFAULT_ICP_PORT@
@@ -6455,11 +6718,12 @@ NAME: htcp_port
 IFDEF: USE_HTCP
 TYPE: u_short
 DEFAULT: 0
+DEFAULT_DOC: HTCP disabled.
 LOC: Config.Port.htcp
 DOC_START
 	The port number where Squid sends and receives HTCP queries to
 	and from neighbor caches.  To turn it on you want to set it to
-	4827. By default it is set to "0" (disabled).
+	4827.
 
 	Example:
 		htcp_port 4827
@@ -6480,6 +6744,7 @@ NAME: udp_incoming_address
 TYPE: address
 LOC:Config.Addrs.udp_incoming
 DEFAULT: any_addr
+DEFAULT_DOC: Accept packets from all machine interfaces.
 DOC_START
 	udp_incoming_address	is used for UDP packets received from other
 				caches.
@@ -6502,6 +6767,7 @@ NAME: udp_outgoing_address
 TYPE: address
 LOC: Config.Addrs.udp_outgoing
 DEFAULT: no_addr
+DEFAULT_DOC: Use udp_incoming_address or an address selected by the operating system.
 DOC_START
 	udp_outgoing_address	is used for UDP packets sent out to other
 				caches.
@@ -6547,6 +6813,7 @@ DOC_START
 DOC_END
 
 NAME: minimum_direct_rtt
+COMMENT: (msec)
 TYPE: int
 DEFAULT: 400
 LOC: Config.minDirectRtt
@@ -6559,17 +6826,30 @@ NAME: netdb_low
 TYPE: int
 DEFAULT: 900
 LOC: Config.Netdb.low
-DOC_NONE
+DOC_START
+	The low water mark for the ICMP measurement database.
+
+	Note: high watermark controlled by netdb_high directive.
+
+	These watermarks are counts, not percents.  The defaults are
+	(low) 900 and (high) 1000.  When the high water mark is
+	reached, database entries will be deleted until the low
+	mark is reached.
+DOC_END
 
 NAME: netdb_high
 TYPE: int
 DEFAULT: 1000
 LOC: Config.Netdb.high
 DOC_START
-	The low and high water marks for the ICMP measurement
-	database.  These are counts, not percents.  The defaults are
-	900 and 1000.  When the high water mark is reached, database
-	entries will be deleted until the low mark is reached.
+	The high water mark for the ICMP measurement database.
+
+	Note: low watermark controlled by netdb_low directive.
+
+	These watermarks are counts, not percents.  The defaults are
+	(low) 900 and (high) 1000.  When the high water mark is
+	reached, database entries will be deleted until the low
+	mark is reached.
 DOC_END
 
 NAME: netdb_ping_period
@@ -6615,6 +6895,7 @@ DOC_END
 NAME: icp_query_timeout
 COMMENT: (msec)
 DEFAULT: 0
+DEFAULT_DOC: Dynamic detection.
 TYPE: int
 LOC: Config.Timeout.icp_query
 DOC_START
@@ -6704,6 +6985,7 @@ IFDEF: MULTICAST_MISS_STREAM
 TYPE: address
 LOC: Config.mcast_miss.addr
 DEFAULT: no_addr
+DEFAULT_DOC: disabled.
 DOC_START
 	If you enable this option, every "cache miss" URL will
 	be sent out on the specified multicast address.
@@ -6806,6 +7088,7 @@ NAME: error_directory
 TYPE: string
 LOC: Config.errorDirectory
 DEFAULT: none
+DEFAULT_DOC: Send error pages in the clients preferred language
 DOC_START
 	If you wish to create your own versions of the default
 	error files to customize them to suit your company copy
@@ -6830,6 +7113,7 @@ IFDEF: USE_ERR_LOCALES
 TYPE: string
 LOC: Config.errorDefaultLanguage
 DEFAULT: none
+DEFAULT_DOC: Generate English language pages.
 DOC_START
 	Set the default language which squid will send error pages in
 	if no existing translation matches the clients language
@@ -6971,15 +7255,16 @@ DOC_START
 	(matching hierarchy_stoplist or not cacheable request type) direct
 	to origin servers.
 
-	If you set this to off, Squid will prefer to send these
+	When this is set to "off", Squid will prefer to send these
 	requests to parents.
 
 	Note that in most configurations, by turning this off you will only
 	add latency to these request without any improvement in global hit
 	ratio.
 
-	If you are inside an firewall see never_direct instead of
-	this directive.
+	This option only sets a preference. If the parent is unavailable a
+	direct connection to the origin server may still be attempted. To
+	completely prevent direct connections use never_direct.
 DOC_END
 
 NAME: prefer_direct
@@ -7004,6 +7289,7 @@ NAME: always_direct
 TYPE: acl_access
 LOC: Config.accessList.AlwaysDirect
 DEFAULT: none
+DEFAULT_DOC: Prevent any cache_peer being used for this request.
 DOC_START
 	Usage: always_direct allow|deny [!]aclname ...
 
@@ -7049,6 +7335,7 @@ NAME: never_direct
 TYPE: acl_access
 LOC: Config.accessList.NeverDirect
 DEFAULT: none
+DEFAULT_DOC: Allow DNS results to be used for this request.
 DOC_START
 	Usage: never_direct allow|deny [!]aclname ...
 
@@ -7179,6 +7466,7 @@ NAME: client_ip_max_connections
 TYPE: int
 LOC: Config.client_ip_max_connections
 DEFAULT: -1
+DEFAULT_DOC: No limit.
 DOC_START
 	Set an absolute limit on the number of connections a single
 	client IP can use. Any more than this and Squid will begin to drop
@@ -7197,11 +7485,12 @@ NAME: tcp_recv_bufsize
 COMMENT: (bytes)
 TYPE: b_size_t
 DEFAULT: 0 bytes
+DEFAULT_DOC: Use operating system TCP defaults.
 LOC: Config.tcpRcvBufsz
 DOC_START
 	Size of receive buffer to set for TCP sockets.  Probably just
-	as easy to change your kernel's default.  Set to zero to use
-	the default buffer size.
+	as easy to change your kernel's default.
+	Omit from squid.conf to use the default buffer size.
 DOC_END
 
 COMMENT_START
@@ -7238,15 +7527,14 @@ NAME: icap_io_timeout
 COMMENT: time-units
 TYPE: time_t
 DEFAULT: none
+DEFAULT_DOC: Use read_timeout.
 LOC: Adaptation::Icap::TheConfig.io_timeout_raw
 IFDEF: ICAP_CLIENT
 DOC_START
 	This parameter specifies how long to wait for an I/O activity on
 	an established, active ICAP connection before giving up and
 	either terminating the HTTP transaction or bypassing the
 	failure.
-
-	The default is read_timeout.
 DOC_END
 
 NAME: icap_service_failure_limit
@@ -7326,10 +7614,10 @@ TYPE: int
 IFDEF: ICAP_CLIENT
 LOC: Adaptation::Icap::TheConfig.preview_size
 DEFAULT: -1
+DEFAULT_DOC: No preview sent.
 DOC_START
 	The default size of preview data to be sent to the ICAP server.
-	-1 means no preview. This value might be overwritten on a per server
-	basis by OPTIONS requests.
+	This value might be overwritten on a per server basis by OPTIONS requests.
 DOC_END
 
 NAME: icap_206_enable
@@ -7721,6 +8009,7 @@ TYPE: adaptation_access_type
 IFDEF: USE_ADAPTATION
 LOC: none
 DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 DOC_START
 	Sends an HTTP transaction to an ICAP or eCAP adaptation	service.
 
@@ -7872,9 +8161,9 @@ TYPE: int
 IFDEF: ICAP_CLIENT
 LOC: Adaptation::Icap::TheConfig.repeat_limit
 DEFAULT: 0
+DEFAULT_DOC: No retries are allowed.
 DOC_START
-	Limits the number of retries allowed. When set to zero (default),
-	no retries are allowed.
+	Limits the number of retries allowed.
 
 	Communication errors due to persistent connection race
 	conditions are unavoidable, automatically retried, and do not
@@ -7974,6 +8263,7 @@ DOC_END
 
 NAME: dns_packet_max
 TYPE: b_ssize_t
+DEFAULT_DOC: EDNS disabled
 DEFAULT: none
 LOC: Config.dns.packet_max
 IFDEF: !USE_DNSHELPER
@@ -8004,6 +8294,7 @@ NAME: dns_defnames
 COMMENT: on|off
 TYPE: onoff
 DEFAULT: off
+DEFAULT_DOC: Search for single-label domain names is disabled.
 LOC: Config.onoff.res_defnames
 DOC_START
 	Normally the RES_DEFNAMES resolver option is disabled
@@ -8015,11 +8306,13 @@ DOC_END
 NAME: dns_nameservers
 TYPE: wordlist
 DEFAULT: none
+DEFAULT_DOC: Use operating system definitions
 LOC: Config.dns_nameservers
 DOC_START
 	Use this if you want to specify a list of DNS name servers
 	(IP addresses) to use instead of those given in your
 	/etc/resolv.conf file.
+
 	On Windows platforms, if no value is specified here or in
 	the /etc/resolv.conf file, the list of DNS name servers are
 	taken from the Windows registry, both static and dynamic DHCP
@@ -8061,6 +8354,7 @@ NAME: append_domain
 TYPE: string
 LOC:  Config.appendDomain
 DEFAULT: none
+DEFAULT_DOC: Use operating system definitions
 DOC_START
 	Appends local domain name to hostnames without any dots in
 	them.  append_domain must begin with a period.
@@ -8110,7 +8404,9 @@ COMMENT: (number of entries)
 TYPE: int
 DEFAULT: 1024
 LOC: Config.ipcache.size
-DOC_NONE
+DOC_START
+	Maximum number of DNS IP cache entries.
+DOC_END
 
 NAME: ipcache_low
 COMMENT: (percent)
@@ -8211,6 +8507,7 @@ DOC_END
 NAME: cachemgr_passwd
 TYPE: cachemgrpasswd
 DEFAULT: none
+DEFAULT_DOC: No password. Actions which require password are denied.
 LOC: Config.passwd_list
 DOC_START
 	Specify passwords for cachemgr operations.
@@ -8318,6 +8615,7 @@ NAME: connect_retries
 TYPE: int
 LOC: Config.connect_retries
 DEFAULT: 0
+DEFAULT_DOC: Do not retry failed connections.
 DOC_START
 	This sets the maximum number of connection attempts made for each
 	TCP connection. The connect_retries attempts must all still
@@ -8378,20 +8676,32 @@ DOC_START
 	URI.  Options:
 
 	strip:  The whitespace characters are stripped out of the URL.
-		This is the behavior recommended by RFC2396.
+		This is the behavior recommended by RFC2396 and RFC3986
+		for tolerant handling of generic URI.
+		NOTE: This is one difference between generic URI and HTTP URLs.
+
 	deny:   The request is denied.  The user receives an "Invalid
 		Request" message.
+		This is the behaviour recommended by RFC2616 for safe
+		handling of HTTP request URL.
+
 	allow:  The request is allowed and the URI is not changed.  The
 		whitespace characters remain in the URI.  Note the
 		whitespace is passed to redirector processes if they
 		are in use.
+		Note this may be considered a violation of RFC2616
+		request parsing where whitespace is prohibited in the
+		URL field.
+
 	encode:	The request is allowed and the whitespace characters are
-		encoded according to RFC1738.  This could be considered
-		a violation of the HTTP/1.1
-		RFC because proxies are not allowed to rewrite URI's.
+		encoded according to RFC1738.
+
 	chop:	The request is allowed and the URI is chopped at the
-		first whitespace.  This might also be considered a
-		violation.
+		first whitespace.
+
+
+	NOTE the current Squid implementation of encode and chop violates
+	RFC2616 by not using a 301 redirect after altering the URL.
 DOC_END
 
 NAME: chroot
@@ -8423,17 +8733,23 @@ DOC_START
 DOC_END
 
 NAME: pipeline_prefetch
-TYPE: onoff
-LOC: Config.onoff.pipeline_prefetch
-DEFAULT: off
+TYPE: pipelinePrefetch
+LOC: Config.pipeline_max_prefetch
+DEFAULT: 0
+DEFAULT_DOC: Do not pre-parse pipelined requests.
 DOC_START
-	To boost the performance of pipelined requests to closer
-	match that of a non-proxied environment Squid can try to fetch
-	up to two requests in parallel from a pipeline.
+	HTTP clients may send a pipeline of 1+N requests to Squid using a
+	single connection, without waiting for Squid to respond to the first
+	of those requests. This option limits the number of concurrent
+	requests Squid will try to handle in parallel. If set to N, Squid
+	will try to receive and process up to 1+N requests on the same
+	connection concurrently.
 
-	Defaults to off for bandwidth management and access logging
+	Defaults to 0 (off) for bandwidth management and access logging
 	reasons.
 
+	NOTE: pipelining requires persistent connections to clients.
+
 	WARNING: pipelining breaks NTLM and Negotiate/Kerberos authentication.
 DOC_END
 
@@ -8442,6 +8758,7 @@ TYPE: int
 COMMENT: (msec)
 LOC: Config.warnings.high_rptm
 DEFAULT: 0
+DEFAULT_DOC: disabled.
 DOC_START
 	If the one-minute median response time exceeds this value,
 	Squid prints a WARNING with debug level 0 to get the
@@ -8452,6 +8769,7 @@ NAME: high_page_fault_warning
 TYPE: int
 LOC: Config.warnings.high_pf
 DEFAULT: 0
+DEFAULT_DOC: disabled.
 DOC_START
 	If the one-minute average page fault rate exceeds this
 	value, Squid prints a WARNING with debug level 0 to get
@@ -8463,6 +8781,7 @@ NAME: high_memory_warning
 TYPE: b_size_t
 LOC: Config.warnings.high_memory
 DEFAULT: 0 KB
+DEFAULT_DOC: disabled.
 DOC_START
 	If the memory usage (as determined by mallinfo) exceeds
 	this amount, Squid prints a WARNING with debug level 0 to get
@@ -8514,20 +8833,23 @@ DOC_END
 NAME: max_filedescriptors max_filedesc
 TYPE: int
 DEFAULT: 0
+DEFAULT_DOC: Use operating system limits set by ulimit.
 LOC: Config.max_filedescriptors
 DOC_START
-	The maximum number of filedescriptors supported.
+	Reduce the maximum number of filedescriptors supported below
+	the usual operating system defaults.
 
-	The default "0" means Squid inherits the current ulimit setting.
+	Remove from squid.conf to inherit the current ulimit setting.
 
 	Note: Changing this requires a restart of Squid. Also
-	not all comm loops supports large values.
+	not all I/O types supports large values (eg on Windows).
 DOC_END
 
 NAME: workers
 TYPE: int
 LOC: Config.workers
 DEFAULT: 1
+DEFAULT_DOC: SMP support disabled.
 DOC_START
 	Number of main Squid processes or "workers" to fork and maintain.
 	0: "no daemon" mode, like running "squid -N ..."
@@ -8542,6 +8864,7 @@ NAME: cpu_affinity_map
 TYPE: CpuAffinityMap
 LOC: Config.cpuAffinityMap
 DEFAULT: none
+DEFAULT_DOC: Let operating system decide.
 DOC_START
 	Usage: cpu_affinity_map process_numbers=P1,P2,... cores=C1,C2,...
 
@@ -189,6 +189,13 @@ usage(const char *program_name)
     exit(1);
 }
 
+static void
+errorMsg(const char *filename, int line, const char *detail)
+{
+    std::cerr << "Error in '" << filename << "' on line " << line <<
+              "--> " << detail << std::endl;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -218,7 +225,7 @@ main(int argc, char *argv[])
      *-------------------------------------------------------------------*/
     fp.open(type_depend, std::ifstream::in);
     if (fp.fail()) {
-        std::cerr << "error while opening type dependencies file '" <<
+        std::cerr << "Error while opening type dependencies file '" <<
                   type_depend << "': " << strerror(errno) << std::endl;
         exit(1);
     }
@@ -245,7 +252,7 @@ main(int argc, char *argv[])
     /* Open input file */
     fp.open(input_filename, std::ifstream::in);
     if (fp.fail()) {
-        std::cerr << "error while opening input file '" <<
+        std::cerr << "Error while opening input file '" <<
                   input_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
@@ -262,14 +269,14 @@ main(int argc, char *argv[])
 
         if (strncmp(buff, "IF ", 3) == 0) {
             if ((ptr = strtok(buff + 3, WS)) == NULL) {
-                std::cerr << "Missing IF parameter on line" << linenum << std::endl;
+                errorMsg(input_filename, linenum, "Missing IF parameter");
                 exit(1);
             }
             IFDEFS.push(ptr);
             continue;
         } else if (strcmp(buff, "ENDIF") == 0) {
             if (IFDEFS.size() == 0) {
-                std::cerr << "ENDIF without IF before on line " << linenum << std::endl;
+                errorMsg(input_filename, linenum, "ENDIF without IF first");
                 exit(1);
             }
             IFDEFS.pop();
@@ -285,7 +292,7 @@ main(int argc, char *argv[])
                     char *name, *aliasname;
 
                     if ((name = strtok(buff + 5, WS)) == NULL) {
-                        std::cerr << "Error in input file\n";
+                        errorMsg(input_filename, linenum, buff);
                         exit(1);
                     }
 
@@ -302,8 +309,7 @@ main(int argc, char *argv[])
                     entries.back().loc = "none";
                     state = sDOC;
                 } else {
-                    std::cerr << "Error on line " << linenum << std::endl <<
-                              "--> " << buff << std::endl;
+                    errorMsg(input_filename, linenum, buff);
                     exit(1);
                 }
 
@@ -352,14 +358,14 @@ main(int argc, char *argv[])
                     curr.defaults.docs.push_back(ptr);
                 } else if (!strncmp(buff, "LOC:", 4)) {
                     if ((ptr = strtok(buff + 4, WS)) == NULL) {
-                        std::cerr << "Error on line " << linenum << std::endl;
+                        errorMsg(input_filename, linenum, buff);
                         exit(1);
                     }
 
                     curr.loc = ptr;
                 } else if (!strncmp(buff, "TYPE:", 5)) {
                     if ((ptr = strtok(buff + 5, WS)) == NULL) {
-                        std::cerr << "Error on line " << linenum << std::endl;
+                        errorMsg(input_filename, linenum, buff);
                         exit(1);
                     }
 
@@ -373,7 +379,7 @@ main(int argc, char *argv[])
                     curr.type = ptr;
                 } else if (!strncmp(buff, "IFDEF:", 6)) {
                     if ((ptr = strtok(buff + 6, WS)) == NULL) {
-                        std::cerr << "Error on line " << linenum << std::endl;
+                        errorMsg(input_filename, linenum, buff);
                         exit(1);
                     }
 
@@ -383,7 +389,7 @@ main(int argc, char *argv[])
                 } else if (!strcmp(buff, "DOC_NONE")) {
                     state = sSTART;
                 } else {
-                    std::cerr << "Error on line " << linenum << std::endl;
+                    errorMsg(input_filename, linenum, buff);
                     exit(1);
                 }
             }
@@ -417,7 +423,7 @@ main(int argc, char *argv[])
     }
 
     if (state != sEXIT) {
-        std::cerr << "Error: unexpected EOF\n";
+        errorMsg(input_filename, linenum, "Error: unexpected EOF");
         exit(1);
     }
 
@@ -435,7 +441,7 @@ main(int argc, char *argv[])
 
     std::ofstream fout(output_filename,std::ostream::out);
     if (!fout.good()) {
-        std::cerr << "error while opening output .c file '" <<
+        std::cerr << "Error while opening output .c file '" <<
                   output_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
@@ -466,7 +472,7 @@ main(int argc, char *argv[])
     /* Open output x.conf file */
     fout.open(conf_filename,std::ostream::out);
     if (!fout.good()) {
-        std::cerr << "error while opening output conf file '" <<
+        std::cerr << "Error while opening output conf file '" <<
                   output_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
@@ -477,7 +483,7 @@ main(int argc, char *argv[])
 
     fout.open(conf_filename_short,std::ostream::out);
     if (!fout.good()) {
-        std::cerr << "error while opening output short conf file '" <<
+        std::cerr << "Error while opening output short conf file '" <<
                   output_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
@@ -625,6 +631,7 @@ Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
     fout << "    if (!strcmp(token, \"" << aName << "\")) {" << std::endl;
     if (ifdef.size())
         fout << "#if " << ifdef << std::endl;
+    fout << "        cfg_directive = \"" << aName << "\";" << std::endl;
     fout << "        ";
     if (type.compare("obsolete") == 0) {
         fout << "debugs(0, DBG_CRITICAL, \"ERROR: Directive '" << aName << "' is obsolete.\");\n";
@@ -639,6 +646,7 @@ Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
         fout << "parse_" << type << "(&" << loc << (array_flag ? "[0]" : "") << ");";
     }
     fout << std::endl;
+    fout << "        cfg_directive = NULL;" << std::endl;
     if (ifdef.size()) {
         fout <<
         "#else" << std::endl <<
@@ -79,8 +79,9 @@ static ClientInfo *
 clientdbAdd(const Ip::Address &addr)
 {
     ClientInfo *c;
-    char *buf = new char[MAX_IPSTRLEN];
+    char *buf = static_cast<char*>(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
     c = (ClientInfo *)memAllocate(MEM_CLIENT_INFO);
+    debugs(77, 9, "ClientInfo constructed, this=" << c);
     c->hash.key = addr.NtoA(buf,MAX_IPSTRLEN);
     c->addr = addr;
 #if USE_DELAY_POOLS
@@ -354,6 +355,7 @@ clientdbFreeItem(void *data)
     }
 #endif
 
+    debugs(77, 9, "ClientInfo destructed, this=" << c);
     memFree(c, MEM_CLIENT_INFO);
 }
 
@@ -98,7 +98,6 @@
 #include "comm/Write.h"
 #include "CommCalls.h"
 #include "errorpage.h"
-#include "eui/Config.h"
 #include "fd.h"
 #include "fde.h"
 #include "forward.h"
@@ -598,7 +597,6 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
             packerToMemInit(&p, &mb);
             ah->lastMeta.packInto(&p);
             aLogEntry->adapt.last_meta = xstrdup(mb.buf);
-            aLogEntry->notes.append(&ah->metaHeaders);
         }
 #endif
 
@@ -615,19 +613,10 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
     aLogEntry->http.method = request->method;
     aLogEntry->http.version = request->http_ver;
     aLogEntry->hier = request->hier;
-    if (request->helperNotes)
-        aLogEntry->notes.append(request->helperNotes->notes);
     if (request->content_length > 0) // negative when no body or unknown length
         aLogEntry->cache.requestSize += request->content_length;
     aLogEntry->cache.extuser = request->extacl_user.termedBuf();
 
-#if USE_AUTH
-    if (request->auth_user_request != NULL) {
-        if (request->auth_user_request->username())
-            aLogEntry->cache.authuser = xstrdup(request->auth_user_request->username());
-    }
-#endif
-
     // Adapted request, if any, inherits and then collects all the stats, but
     // the virgin request gets logged instead; copy the stats to log them.
     // TODO: avoid losses by keeping these stats in a shared history object?
@@ -696,11 +685,15 @@ ClientHttpRequest::logRequest()
 
 #endif
 
-    /*Add meta headers*/
+    /*Add notes*/
+    // The al->notes and request->notes must point to the same object.
+    // Enable the following assertion to check for possible bugs.
+    // assert(request->notes == al->notes);
     typedef Notes::iterator ACAMLI;
     for (ACAMLI i = Config.notes.begin(); i != Config.notes.end(); ++i) {
         if (const char *value = (*i)->match(request, al->reply)) {
-            al->notes.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), value));
+            NotePairs &notes = SyncNotes(*al, *request);
+            notes.add((*i)->key.termedBuf(), value);
             debugs(33, 3, HERE << (*i)->key.termedBuf() << " " << value);
         }
     }
@@ -793,6 +786,87 @@ void ConnStateData::connStateClosed(const CommCloseCbParams &io)
     deleteThis("ConnStateData::connStateClosed");
 }
 
+#if USE_AUTH
+void
+ConnStateData::setAuth(const Auth::UserRequest::Pointer &aur, const char *by)
+{
+    if (auth_ == NULL) {
+        if (aur != NULL) {
+            debugs(33, 2, "Adding connection-auth to " << clientConnection << " from " << by);
+            auth_ = aur;
+        }
+        return;
+    }
+
+    // clobered with self-pointer
+    // NP: something nasty is going on in Squid, but harmless.
+    if (aur == auth_) {
+        debugs(33, 2, "WARNING: Ignoring duplicate connection-auth for " << clientConnection << " from " << by);
+        return;
+    }
+
+    /*
+     * Connection-auth relies on a single set of credentials being preserved
+     * for all requests on a connection once they have been setup.
+     * There are several things which need to happen to preserve security
+     * when connection-auth credentials change unexpectedly or are unset.
+     *
+     * 1) auth helper released from any active state
+     *
+     * They can only be reserved by a handshake process which this
+     * connection can now never complete.
+     * This prevents helpers hanging when their connections close.
+     *
+     * 2) pinning is expected to be removed and server conn closed
+     *
+     * The upstream link is authenticated with the same credentials.
+     * Expecting the same level of consistency we should have received.
+     * This prevents upstream being faced with multiple or missing
+     * credentials after authentication.
+     * NP: un-pin is left to the cleanup in ConnStateData::swanSong()
+     *     we just trigger that cleanup here via comm_reset_close() or
+     *     ConnStateData::stopReceiving()
+     *
+     * 3) the connection needs to close.
+     *
+     * This prevents attackers injecting requests into a connection,
+     * or gateways wrongly multiplexing users into a single connection.
+     *
+     * When credentials are missing closure needs to follow an auth
+     * challenge for best recovery by the client.
+     *
+     * When credentials change there is nothing we can do but abort as
+     * fast as possible. Sending TCP RST instead of an HTTP response
+     * is the best-case action.
+     */
+
+    // clobbered with nul-pointer
+    if (aur == NULL) {
+        debugs(33, 2, "WARNING: Graceful closure on " << clientConnection << " due to connection-auth erase from " << by);
+        auth_->releaseAuthServer();
+        auth_ = NULL;
+        // XXX: need to test whether the connection re-auth challenge is sent. If not, how to trigger it from here.
+        // NP: the current situation seems to fix challenge loops in Safari without visible issues in others.
+        // we stop receiving more traffic but can leave the Job running to terminate after the error or challenge is delivered.
+        stopReceiving("connection-auth removed");
+        return;
+    }
+
+    // clobbered with alternative credentials
+    if (aur != auth_) {
+        debugs(33, 2, "ERROR: Closing " << clientConnection << " due to change of connection-auth from " << by);
+        auth_->releaseAuthServer();
+        auth_ = NULL;
+        // this is a fatal type of problem.
+        // Close the connection immediately with TCP RST to abort all traffic flow
+        comm_reset_close(clientConnection);
+        return;
+    }
+
+    /* NOT REACHABLE */
+}
+#endif
+
 // cleans up before destructor is called
 void
 ConnStateData::swanSong()
@@ -802,19 +876,18 @@ ConnStateData::swanSong()
     clientdbEstablished(clientConnection->remote, -1);	/* decrement */
     assert(areAllContextsForThisConnection());
     freeAllContexts();
-#if USE_AUTH
-    if (auth_user_request != NULL) {
-        debugs(33, 4, "ConnStateData::swanSong: freeing auth_user_request '" << auth_user_request << "' (this is '" << this << "')");
-        auth_user_request->onConnectionClose(this);
-    }
-#endif
 
     unpinConnection();
 
     if (Comm::IsConnOpen(clientConnection))
         clientConnection->close();
     clientConnection = NULL;
 
+#if USE_AUTH
+    // NP: do this bit after closing the connections to avoid side effects from unwanted TCP RST
+    setAuth(NULL, "ConnStateData::SwanSong cleanup");
+#endif
+
     BodyProducer::swanSong();
     flags.swanSang = true;
 }
@@ -2539,12 +2612,14 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
             debugs(33, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " <<
                    "does not match domainname " << request->GetHost());
 
-            ACLFilledChecklist check(Config.ssl_client.cert_error, request, dash_str);
-            check.sslErrors = new Ssl::Errors(SQUID_X509_V_ERR_DOMAIN_MISMATCH);
-            const bool allowDomainMismatch =
-                check.fastCheck() == ACCESS_ALLOWED;
-            delete check.sslErrors;
-            check.sslErrors = NULL;
+            bool allowDomainMismatch = false;
+            if (Config.ssl_client.cert_error) {
+                ACLFilledChecklist check(Config.ssl_client.cert_error, request, dash_str);
+                check.sslErrors = new Ssl::Errors(SQUID_X509_V_ERR_DOMAIN_MISMATCH);
+                allowDomainMismatch = (check.fastCheck() == ACCESS_ALLOWED);
+                delete check.sslErrors;
+                check.sslErrors = NULL;
+            }
 
             if (!allowDomainMismatch) {
                 quitAfterError(request);
@@ -2682,8 +2757,8 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
                               !conn->port->allow_direct : 0;
 #if USE_AUTH
     if (request->flags.sslBumped) {
-        if (conn->auth_user_request != NULL)
-            request->auth_user_request = conn->auth_user_request;
+        if (conn->getAuth() != NULL)
+            request->auth_user_request = conn->getAuth();
     }
 #endif
 
@@ -2693,7 +2768,16 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      */
     if (http->clientConnection != NULL) {
         request->flags.intercepted = ((http->clientConnection->flags & COMM_INTERCEPTION) != 0);
-        request->flags.spoofClientIp = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        request->flags.interceptTproxy = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        if (request->flags.interceptTproxy) {
+            if (Config.accessList.spoof_client_ip) {
+                ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.spoof_client_ip, http);
+                request->flags.spoofClientIp = (checklist->fastCheck() == ACCESS_ALLOWED);
+                delete checklist;
+            } else
+                request->flags.spoofClientIp = true;
+        } else
+            request->flags.spoofClientIp = false;
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
@@ -2862,17 +2946,28 @@ connStripBufferWhitespace (ConnStateData * conn)
     }
 }
 
-static int
-connOkToAddRequest(ConnStateData * conn)
+/**
+ * Limit the number of concurrent requests.
+ * \return true  when there are available position(s) in the pipeline queue for another request.
+ * \return false when the pipeline queue is full or disabled.
+ */
+bool
+ConnStateData::concurrentRequestQueueFilled() const
 {
-    int result = conn->getConcurrentRequestCount() < (Config.onoff.pipeline_prefetch ? 2 : 1);
+    const int existingRequestCount = getConcurrentRequestCount();
 
-    if (!result) {
-        debugs(33, 3, HERE << conn->clientConnection << " max concurrent requests reached");
-        debugs(33, 5, HERE << conn->clientConnection << " defering new request until one is done");
+    // default to the configured pipeline size.
+    // add 1 because the head of pipeline is counted in concurrent requests and not prefetch queue
+    const int concurrentRequestLimit = Config.pipeline_max_prefetch + 1;
+
+    // when queue filled already we cant add more.
+    if (existingRequestCount >= concurrentRequestLimit) {
+        debugs(33, 3, clientConnection << " max concurrent requests reached (" << concurrentRequestLimit << ")");
+        debugs(33, 5, clientConnection << " deferring new request until one is done");
+        return true;
     }
 
-    return result;
+    return false;
 }
 
 /**
@@ -2897,10 +2992,9 @@ ConnStateData::clientParseRequests()
         if (in.notYetUsed == 0)
             break;
 
-        /* Limit the number of concurrent requests to 2 */
-        if (!connOkToAddRequest(this)) {
+        /* Limit the number of concurrent requests */
+        if (concurrentRequestQueueFilled())
             break;
-        }
 
         /* Should not be needed anymore */
         /* Terminate the string */
@@ -3335,16 +3429,6 @@ connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
     }
 #endif
 
-#if USE_SQUID_EUI
-    if (Eui::TheConfig.euiLookup) {
-        if (client->remote.IsIPv4()) {
-            result->clientConnection->remoteEui48.lookup(client->remote);
-        } else if (client->remote.IsIPv6()) {
-            result->clientConnection->remoteEui64.lookup(client->remote);
-        }
-    }
-#endif
-
     clientdbEstablished(client->remote, 1);
 
     result->flags.readMore = true;
@@ -3595,7 +3679,7 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
     else {
         char buf[MAX_IPSTRLEN];
         assert(bumpMode != Ssl::bumpNone && bumpMode != Ssl::bumpEnd);
-        HttpRequest *fakeRequest = new HttpRequest;
+        HttpRequest::Pointer fakeRequest(new HttpRequest);
         fakeRequest->SetHost(details->local.NtoA(buf, sizeof(buf)));
         fakeRequest->port = details->local.GetPort();
         fakeRequest->clientConnectionManager = connState;
@@ -3604,10 +3688,19 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
         fakeRequest->indirect_client_addr = connState->clientConnection->remote;
 #endif
         fakeRequest->my_addr = connState->clientConnection->local;
-        fakeRequest->flags.spoofClientIp = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        fakeRequest->flags.interceptTproxy = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
         fakeRequest->flags.intercepted = ((connState->clientConnection->flags & COMM_INTERCEPTION) != 0);
+        fakeRequest->myportname = connState->port->name;
+        if (fakeRequest->flags.interceptTproxy) {
+            if (Config.accessList.spoof_client_ip) {
+                ACLFilledChecklist checklist(Config.accessList.spoof_client_ip, fakeRequest.getRaw(), NULL);
+                fakeRequest->flags.spoofClientIp = (checklist.fastCheck() == ACCESS_ALLOWED);
+            } else
+                fakeRequest->flags.spoofClientIp = true;
+        } else
+            fakeRequest->flags.spoofClientIp = false;
         debugs(33, 4, HERE << details << " try to generate a Dynamic SSL CTX");
-        connState->switchToHttps(fakeRequest, bumpMode);
+        connState->switchToHttps(fakeRequest.getRaw(), bumpMode);
     }
 }
 
@@ -4142,7 +4235,7 @@ clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNot
 
     debugs(1, DBG_IMPORTANT, "Accepting " <<
            (s->flags.natIntercept ? "NAT intercepted " : "") <<
-           (s->flags.tproxyIntercept ? "TPROXY spoofing " : "") <<
+           (s->flags.tproxyIntercept ? "TPROXY intercepted " : "") <<
            (s->flags.tunnelSslBumping ? "SSL bumped " : "") <<
            (s->flags.accelSurrogate ? "reverse-proxy " : "")
            << FdNote(portTypeNote) << " connections at "
@@ -33,15 +33,9 @@
 #ifndef SQUID_CLIENTSIDE_H
 #define SQUID_CLIENTSIDE_H
 
-#include "base/AsyncJob.h"
-#include "base/RefCount.h"
-#include "BodyPipe.h"
 #include "comm.h"
-#include "CommCalls.h"
-#include "HttpRequest.h"
 #include "HttpControlMsg.h"
 #include "HttpParser.h"
-#include "StoreIOBuffer.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
@@ -178,7 +172,7 @@ class ServerBump;
 /**
  * Manages a connection to a client.
  *
- * Multiple requests (up to 2) can be pipelined. This object is responsible for managing
+ * Multiple requests (up to pipeline_prefetch) can be pipelined. This object is responsible for managing
  * which one is currently being fulfilled and what happens to the queue if the current one
  * causes the client connection to be closed early.
  *
@@ -239,10 +233,20 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
 
 #if USE_AUTH
     /**
-     * note this is ONLY connection based because NTLM and Negotiate is against HTTP spec.
-     * the user details for connection based authentication
+     * Fetch the user details for connection based authentication
+     * NOTE: this is ONLY connection based because NTLM and Negotiate is against HTTP spec.
      */
-    Auth::UserRequest::Pointer auth_user_request;
+    const Auth::UserRequest::Pointer &getAuth() const { return auth_; }
+
+    /**
+     * Set the user details for connection-based authentication to use from now until connection closure.
+     *
+     * Any change to existing credentials shows that something invalid has happened. Such as:
+     * - NTLM/Negotiate auth was violated by the per-request headers missing a revalidation token
+     * - NTLM/Negotiate auth was violated by the per-request headers being for another user
+     * - SSL-Bump CONNECT tunnel with persistent credentials has ended
+     */
+    void setAuth(const Auth::UserRequest::Pointer &aur, const char *cause);
 #endif
 
     /**
@@ -382,8 +386,13 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     int connReadWasError(comm_err_t flag, int size, int xerrno);
     int connFinishedWithConn(int size);
     void clientAfterReadingRequests();
+    bool concurrentRequestQueueFilled() const;
+
+#if USE_AUTH
+    /// some user details that can be used to perform authentication on this connection
+    Auth::UserRequest::Pointer auth_;
+#endif
 
-private:
     HttpParser parser_;
 
     // XXX: CBDATA plays with public/private and leaves the following 'private' fields all public... :(
@@ -34,9 +34,6 @@
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
 #include "client_side_reply.h"
-#include "client_side.h"
-#include "clientStream.h"
-#include "dlink.h"
 #include "errorpage.h"
 #include "fd.h"
 #include "fde.h"
@@ -58,7 +55,6 @@
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
-#include "StoreClient.h"
 #include "StrList.h"
 #include "tools.h"
 #include "URL.h"
@@ -31,15 +31,12 @@
 #ifndef SQUID_CLIENTSIDEREPLY_H
 #define SQUID_CLIENTSIDEREPLY_H
 
-#include "base/RefCount.h"
 #include "client_side_request.h"
-#include "clientStream.h"
-#include "HttpHeader.h"
+#include "ip/forward.h"
 #include "RequestFlags.h"
 #include "StoreClient.h"
 
 class ErrorState;
-#include "ip/forward.h"
 
 /* XXX make static method */
 
@@ -616,8 +616,8 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
                                 http->request,
                                 NULL,
 #if USE_AUTH
-                                http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
-                                http->getConn()->auth_user_request : http->request->auth_user_request);
+                                http->getConn() != NULL && http->getConn()->getAuth() != NULL ?
+                                http->getConn()->getAuth() : http->request->auth_user_request);
 #else
                                 NULL);
 #endif
@@ -670,7 +670,7 @@ ClientRequestContext::hostHeaderVerify()
     }
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
-    if (http->request->flags.intercepted || http->request->flags.spoofClientIp) {
+    if (http->request->flags.intercepted || http->request->flags.interceptTproxy) {
         // verify the Host: port (if any) matches the apparent destination
         if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
             debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
@@ -780,13 +780,12 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
     debugs(85, 2, "The request " <<
            RequestMethodStr(http->request->method) << " " <<
            http->uri << " is " << answer <<
-           ", because it matched '" <<
-           (AclMatchedName ? AclMatchedName : "NO ACL's") << "'" );
+           "; last ACL checked: " << (AclMatchedName ? AclMatchedName : "[none]"));
 
 #if USE_AUTH
     char const *proxy_auth_msg = "<null>";
-    if (http->getConn() != NULL && http->getConn()->auth_user_request != NULL)
-        proxy_auth_msg = http->getConn()->auth_user_request->denyMessage("<null>");
+    if (http->getConn() != NULL && http->getConn()->getAuth() != NULL)
+        proxy_auth_msg = http->getConn()->getAuth()->denyMessage("<null>");
     else if (http->request->auth_user_request != NULL)
         proxy_auth_msg = http->request->auth_user_request->denyMessage("<null>");
 #endif
@@ -849,8 +848,8 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 
 #if USE_AUTH
         error->auth_user_request =
-            http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
-            http->getConn()->auth_user_request : http->request->auth_user_request;
+            http->getConn() != NULL && http->getConn()->getAuth() != NULL ?
+            http->getConn()->getAuth() : http->request->auth_user_request;
 #endif
 
         readNextRequest = true;
@@ -970,7 +969,7 @@ clientHierarchical(ClientHttpRequest * http)
     const wordlist *p = NULL;
 
     // intercepted requests MUST NOT (yet) be sent to peers unless verified
-    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.spoofClientIp))
+    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))
         return 0;
 
     /*
@@ -1256,12 +1255,12 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
     assert(redirect_state == REDIRECT_PENDING);
     redirect_state = REDIRECT_DONE;
 
-    // copy the URL rewriter response Notes to the HTTP request for logging
+    // Put helper response Notes into the transaction state record (ALE) eventually
     // do it early to ensure that no matter what the outcome the notes are present.
-    // TODO put them straight into the transaction state record (ALE?) eventually
-    if (!old_request->helperNotes)
-        old_request->helperNotes = new Notes;
-    old_request->helperNotes->add(reply.notes);
+    if (http->al != NULL) {
+        NotePairs &notes = SyncNotes(*http->al, *old_request);
+        notes.append(&reply.notes);
+    }
 
     switch (reply.result) {
     case HelperReply::Unknown:
@@ -1289,8 +1288,8 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
         // #2: redirect with a default status code     OK url="..."
         // #3: re-write the URL                        OK rewrite-url="..."
 
-        Note::Pointer statusNote = reply.notes.find("status");
-        Note::Pointer urlNote = reply.notes.find("url");
+        const char *statusNote = reply.notes.findFirst("status");
+        const char *urlNote = reply.notes.findFirst("url");
 
         if (urlNote != NULL) {
             // HTTP protocol redirect to be done.
@@ -1302,7 +1301,7 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
             // HTTP/1.1 client being diverted by forward-proxy should get 303 (Http::scSeeOther)
             Http::StatusCode status = Http::scMovedTemporarily;
             if (statusNote != NULL) {
-                const char * result = statusNote->firstValue();
+                const char * result = statusNote;
                 status = static_cast<Http::StatusCode>(atoi(result));
             }
 
@@ -1312,21 +1311,21 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
                     || status == Http::scPermanentRedirect
                     || status == Http::scTemporaryRedirect) {
                 http->redirect.status = status;
-                http->redirect.location = xstrdup(urlNote->firstValue());
+                http->redirect.location = xstrdup(urlNote);
                 // TODO: validate the URL produced here is RFC 2616 compliant absolute URI
             } else {
-                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << urlNote->firstValue());
+                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << urlNote);
             }
         } else {
             // URL-rewrite wanted. Ew.
-            urlNote = reply.notes.find("rewrite-url");
+            urlNote = reply.notes.findFirst("rewrite-url");
 
             // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
-            if (urlNote != NULL && strcmp(urlNote->firstValue(), http->uri)) {
+            if (urlNote != NULL && strcmp(urlNote, http->uri)) {
                 // XXX: validate the URL properly *without* generating a whole new request object right here.
                 // XXX: the clone() should be done only AFTER we know the new URL is valid.
                 HttpRequest *new_request = old_request->clone();
-                if (urlParse(old_request->method, const_cast<char*>(urlNote->firstValue()), new_request)) {
+                if (urlParse(old_request->method, const_cast<char*>(urlNote), new_request)) {
                     debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
 
                     // update the new request to flag the re-writing was done on it
@@ -1347,7 +1346,7 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
                     HTTPMSGLOCK(http->request);
                 } else {
                     debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
-                           old_request->method << " " << urlNote->firstValue() << " " << old_request->http_ver);
+                           old_request->method << " " << urlNote << " " << old_request->http_ver);
                     delete new_request;
                 }
             }
@@ -1377,12 +1376,12 @@ ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
     assert(store_id_state == REDIRECT_PENDING);
     store_id_state = REDIRECT_DONE;
 
-    // copy the helper response Notes to the HTTP request for logging
+    // Put helper response Notes into the transaction state record (ALE) eventually
     // do it early to ensure that no matter what the outcome the notes are present.
-    // TODO put them straight into the transaction state record (ALE?) eventually
-    if (!old_request->helperNotes)
-        old_request->helperNotes = new Notes;
-    old_request->helperNotes->add(reply.notes);
+    if (http->al != NULL) {
+        NotePairs &notes = SyncNotes(*http->al, *old_request);
+        notes.append(&reply.notes);
+    }
 
     switch (reply.result) {
     case HelperReply::Unknown:
@@ -1406,14 +1405,14 @@ ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
         break;
 
     case HelperReply::Okay: {
-        Note::Pointer urlNote = reply.notes.find("store-id");
+        const char *urlNote = reply.notes.findFirst("store-id");
 
         // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
-        if (urlNote != NULL && strcmp(urlNote->firstValue(), http->uri) ) {
+        if (urlNote != NULL && strcmp(urlNote, http->uri) ) {
             // Debug section required for some very specific cases.
-            debugs(85, 9, "Setting storeID with: " << urlNote->firstValue() );
-            http->request->store_id = urlNote->firstValue();
-            http->store_id = urlNote->firstValue();
+            debugs(85, 9, "Setting storeID with: " << urlNote );
+            http->request->store_id = urlNote;
+            http->store_id = urlNote;
         }
     }
     break;
@@ -1607,7 +1606,7 @@ ClientHttpRequest::sslBumpEstablish(comm_err_t errflag)
 #if USE_AUTH
     // Preserve authentication info for the ssl-bumped request
     if (request->auth_user_request != NULL)
-        getConn()->auth_user_request = request->auth_user_request;
+        getConn()->setAuth(request->auth_user_request, "SSL-bumped CONNECT");
 #endif
 
     assert(sslBumpNeeded());
@@ -2089,7 +2088,7 @@ ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
                                                 );
 #if USE_AUTH
         calloutContext->error->auth_user_request =
-            c != NULL && c->auth_user_request != NULL ? c->auth_user_request : request->auth_user_request;
+            c != NULL && c->getAuth() != NULL ? c->getAuth() : request->auth_user_request;
 #endif
         calloutContext->error->detailError(errDetail);
         calloutContext->readNextRequest = true;
@@ -30,12 +30,10 @@
 #ifndef SQUID_CLIENTSIDEREQUEST_H
 #define SQUID_CLIENTSIDEREQUEST_H
 
-#include "HttpHeader.h"
+#include "acl/forward.h"
+#include "AccessLogEntry.h"
 #include "clientStream.h"
 #include "client_side.h"
-#include "AccessLogEntry.h"
-#include "dlink.h"
-#include "base/AsyncJob.h"
 #include "HttpHeaderRange.h"
 #include "LogTags.h"
 
@@ -45,8 +43,6 @@
 class HttpMsg;
 #endif
 
-class acl_access;
-class ACLFilledChecklist;
 class ClientRequestContext;
 class ConnStateData;
 class MemObject;
@@ -33,11 +33,7 @@
  */
 
 #include "squid.h"
-#include "base/AsyncCall.h"
-#include "cbdata.h"
-#include "comm.h"
 #include "ClientInfo.h"
-#include "CommCalls.h"
 #include "comm/AcceptLimiter.h"
 #include "comm/comm_internal.h"
 #include "comm/Connection.h"
@@ -53,15 +49,12 @@
 #include "fde.h"
 #include "globals.h"
 #include "icmp/net_db.h"
-#include "ip/Address.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
 #include "ip/tools.h"
-#include "MemBuf.h"
 #include "pconn.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
-#include "SquidTime.h"
 #include "StatCounters.h"
 #include "StoreIOBuffer.h"
 #include "tools.h"
@@ -495,35 +488,46 @@ comm_set_v6only(int fd, int tos)
 }
 
 /**
- * Set the socket IP_TRANSPARENT option for Linux TPROXY v4 support,
- * or set the socket SO_BINDANY option for BSD divert-to support.
+ * Set the socket option required for TPROXY spoofing for:
+ * - Linux TPROXY v4 support,
+ * - OpenBSD divert-to support,
+ * - FreeBSD IPFW TPROXY v4 support.
  */
 void
 comm_set_transparent(int fd)
 {
-#if _SQUID_LINUX_ && defined(IP_TRANSPARENT)
-    int tos = 1;
-    if (setsockopt(fd, SOL_IP, IP_TRANSPARENT, (char *) &tos, sizeof(int)) < 0) {
-        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(IP_TRANSPARENT) on FD " << fd << ": " << xstrerror());
-    } else {
-        /* mark the socket as having transparent options */
-        fd_table[fd].flags.transparent = true;
-    }
+#if _SQUID_LINUX_ && defined(IP_TRANSPARENT) // Linux
+# define soLevel SOL_IP
+# define soFlag  IP_TRANSPARENT
+    bool doneSuid = false;
 
-#elif defined(SO_BINDANY)
-    int tos = 1;
+#elif defined(SO_BINDANY) // OpenBSD 4.7+ and NetBSD with PF
+# define soLevel SOL_SOCKET
+# define soFlag  SO_BINDANY
+    enter_suid();
+    bool doneSuid = true;
+
+#elif defined(IP_BINDANY) // FreeBSD with IPFW
+# define soLevel IPPROTO_IP
+# define soFlag  IP_BINDANY
     enter_suid();
-    if (setsockopt(fd, SOL_SOCKET, SO_BINDANY, (char *) &tos, sizeof(int)) < 0) {
-        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(SO_BINDANY) on FD " << fd << ": " << xstrerror());
+    bool doneSuid = true;
+
+#else
+    debugs(50, DBG_CRITICAL, "WARNING: comm_open: setsockopt(TPROXY) not supported on this platform");
+#endif /* sockopt */
+
+#if defined(soLevel) && defined(soFlag)
+    int tos = 1;
+    if (setsockopt(fd, soLevel, soFlag, (char *) &tos, sizeof(int)) < 0) {
+        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(TPROXY) on FD " << fd << ": " << xstrerror());
     } else {
         /* mark the socket as having transparent options */
         fd_table[fd].flags.transparent = true;
     }
-    leave_suid();
-
-#else
-    debugs(50, DBG_CRITICAL, "WARNING: comm_open: setsockopt(IP_TRANSPARENT) not supported on this platform");
-#endif /* sockopt */
+    if (doneSuid)
+        leave_suid();
+#endif
 }
 
 /**
@@ -1,10 +1,7 @@
 #ifndef __COMM_H__
 #define __COMM_H__
 
-#include "AsyncEngine.h"
-#include "base/AsyncCall.h"
 #include "CommCalls.h"
-#include "comm_err_t.h"
 #include "comm/IoCallback.h"
 #include "StoreIOBuffer.h"
 
@@ -1,7 +1,7 @@
 #ifndef _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 #define _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "comm/TcpAcceptor.h"
 
 namespace Comm
@@ -19,6 +19,7 @@ Comm::Connection::Connection() :
         peerType(HIER_NONE),
         fd(-1),
         tos(0),
+        nfmark(0),
         flags(COMM_NONBLOCKING),
         peer_(NULL)
 {
@@ -37,7 +37,6 @@
 #ifndef _SQUIDCONNECTIONDETAIL_H_
 #define _SQUIDCONNECTIONDETAIL_H_
 
-#include "base/RefCount.h"
 #include "comm/forward.h"
 #include "defines.h"
 #include "hier_code.h"
@@ -197,7 +197,11 @@ Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time
            ", timeout=" << timeout);
 
     if (type & COMM_SELECT_READ) {
+        if (F->flags.read_pending)
+            kq_update_events(fd, EVFILT_WRITE, handler);
+
         kq_update_events(fd, EVFILT_READ, handler);
+
         F->read_handler = handler;
         F->read_data = client_data;
     }
@@ -290,31 +294,24 @@ Comm::DoSelect(int msec)
             continue;        /* XXX! */
         }
 
-        switch (ke[i].filter) {
-
-        case EVFILT_READ:
-
+        if (ke[i].filter == EVFILT_READ || F->flags.read_pending) {
             if ((hdl = F->read_handler) != NULL) {
                 F->read_handler = NULL;
                 F->flags.read_pending = 0;
                 hdl(fd, F->read_data);
             }
+        }
 
-            break;
-
-        case EVFILT_WRITE:
-
+        if (ke[i].filter == EVFILT_WRITE) {
             if ((hdl = F->write_handler) != NULL) {
                 F->write_handler = NULL;
                 hdl(fd, F->write_data);
             }
+        }
 
-            break;
-
-        default:
+        if (ke[i].filter != EVFILT_WRITE && ke[i].filter != EVFILT_READ) {
             /* Bad! -- adrian */
             debugs(5, DBG_IMPORTANT, "comm_select: kevent returned " << ke[i].filter << "!");
-            break;
         }
     }
 
@@ -41,6 +41,7 @@
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "comm/TcpAcceptor.h"
+#include "eui/Config.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
@@ -346,7 +347,11 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     // lookup the local-end details of this new connection
     details->local.InitAddrInfo(gai);
     details->local.SetEmpty();
-    getsockname(sock, gai->ai_addr, &gai->ai_addrlen);
+    if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
+        debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
+        details->local.FreeAddrInfo(gai);
+        return COMM_ERROR;
+    }
     details->local = *gai;
     details->local.FreeAddrInfo(gai);
 
@@ -377,6 +382,16 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
         return COMM_ERROR;
     }
 
+#if USE_SQUID_EUI
+    if (Eui::TheConfig.euiLookup) {
+        if (conn->remote.IsIPv4()) {
+            conn->remoteEui48.lookup(conn->remote);
+        } else if (conn->remote.IsIPv6()) {
+            conn->remoteEui64.lookup(conn->remote);
+        }
+    }
+#endif
+
     PROF_stop(comm_accept);
     return COMM_OK;
 }
@@ -1,7 +1,7 @@
 #ifndef _SQUID_COMM_FORWARD_H
 #define _SQUID_COMM_FORWARD_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 
 namespace Comm
@@ -41,7 +41,6 @@
 #define BUFSIZ  4096            /* make unreasonable guess */
 #endif
 
-#define ACL_NAME_SZ 32
 #define BROWSERNAMELEN 128
 
 #define ACL_SUNDAY	0x01
@@ -42,7 +42,7 @@
 #include "squid.h"
 
 #if USE_DELAY_POOLS
-#include "Array.h"
+#include "base/Vector.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
 #include "CommonPool.h"
@@ -141,6 +141,7 @@ struct _idns_query {
 
     int nsends;
     int need_vc;
+    bool permit_mdns;
     int pending;
 
     struct timeval start_t;
@@ -179,6 +180,7 @@ struct _ns {
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
     int last_seen_edns;
 #endif
+    bool mDNSResolver;
     nsvc *vc;
 };
 
@@ -231,15 +233,16 @@ static int max_shared_edns = RFC1035_DEFAULT_PACKET_SZ;
 
 static OBJH idnsStats;
 static void idnsAddNameserver(const char *buf);
+static void idnsAddMDNSNameservers();
 static void idnsAddPathComponent(const char *buf);
 static void idnsFreeNameservers(void);
 static void idnsFreeSearchpath(void);
-static void idnsParseNameservers(void);
-#if !_SQUID_WINDOWS_
-static void idnsParseResolvConf(void);
+static bool idnsParseNameservers(void);
+#if _SQUID_WINDOWS_
+static bool idnsParseResolvConf(void);
 #endif
 #if _SQUID_WINDOWS_
-static void idnsParseWIN32Registry(void);
+static bool idnsParseWIN32Registry(void);
 static void idnsParseWIN32SearchList(const char *);
 #endif
 static void idnsStartQuery(idns_query * q, IDNSCB * callback, void *data);
@@ -261,6 +264,30 @@ static CLCB idnsVCClosed;
 static unsigned short idnsQueryID(void);
 static void idnsSendSlaveAAAAQuery(idns_query *q);
 
+static void
+idnsCheckMDNS(idns_query *q)
+{
+    size_t slen = strlen(q->name);
+    if (slen > 6 && memcmp(q->name +(slen-6),".local", 6) == 0) {
+        q->permit_mdns = true;
+    }
+}
+
+static void
+idnsAddMDNSNameservers()
+{
+#define MDNS_RESOLVER_COUNT 2
+
+    // mDNS resolver addresses are explicit multicast group IPs
+    idnsAddNameserver("FF02::FB");
+    nameservers[nns-1].S.SetPort(5353);
+    nameservers[nns-1].mDNSResolver = true;
+
+    idnsAddNameserver("224.0.0.251");
+    nameservers[nns-1].S.SetPort(5353);
+    nameservers[nns-1].mDNSResolver = true;
+}
+
 static void
 idnsAddNameserver(const char *buf)
 {
@@ -354,29 +381,31 @@ idnsFreeSearchpath(void)
     npc = npc_alloc = 0;
 }
 
-static void
+static bool
 idnsParseNameservers(void)
 {
-    wordlist *w;
-
-    for (w = Config.dns_nameservers; w; w = w->next) {
+    bool result = false;
+    for (wordlist *w = Config.dns_nameservers; w; w = w->next) {
         debugs(78, DBG_IMPORTANT, "Adding nameserver " << w->key << " from squid.conf");
         idnsAddNameserver(w->key);
+        result = true;
     }
+    return result;
 }
 
 #if !_SQUID_WINDOWS_
-static void
+static bool
 idnsParseResolvConf(void)
 {
     FILE *fp;
     char buf[RESOLV_BUFSZ];
     const char *t;
+    bool result = false;
     fp = fopen(_PATH_RESCONF, "r");
 
     if (fp == NULL) {
         debugs(78, DBG_IMPORTANT, "" << _PATH_RESCONF << ": " << xstrerror());
-        return;
+        return false;
     }
 
 #if _SQUID_CYGWIN_
@@ -397,6 +426,7 @@ idnsParseResolvConf(void)
             debugs(78, DBG_IMPORTANT, "Adding nameserver " << t << " from " << _PATH_RESCONF);
 
             idnsAddNameserver(t);
+            result = true;
         } else if (strcmp(t, "domain") == 0) {
             idnsFreeSearchpath();
             t = strtok(NULL, w_space);
@@ -444,6 +474,7 @@ idnsParseResolvConf(void)
     }
 
     fclose(fp);
+    return result;
 }
 
 #endif
@@ -493,12 +524,13 @@ idnsParseWIN32SearchList(const char * Separator)
     }
 }
 
-static void
+static bool
 idnsParseWIN32Registry(void)
 {
     char *t;
     char *token;
     HKEY hndKey, hndKey2;
+    bool result = false;
 
     switch (WIN32_OS_version) {
 
@@ -518,6 +550,7 @@ idnsParseWIN32Registry(void)
 
                 while (token) {
                     idnsAddNameserver(token);
+                    result = true;
                     debugs(78, DBG_IMPORTANT, "Adding DHCP nameserver " << token << " from Registry");
                     token = strtok(NULL, ",");
                 }
@@ -534,6 +567,7 @@ idnsParseWIN32Registry(void)
                 while (token) {
                     debugs(78, DBG_IMPORTANT, "Adding nameserver " << token << " from Registry");
                     idnsAddNameserver(token);
+                    result = true;
                     token = strtok(NULL, ", ");
                 }
                 xfree(t);
@@ -587,6 +621,7 @@ idnsParseWIN32Registry(void)
                                 while (token) {
                                     debugs(78, DBG_IMPORTANT, "Adding DHCP nameserver " << token << " from Registry");
                                     idnsAddNameserver(token);
+                                    result = true;
                                     token = strtok(NULL, ", ");
                                 }
                                 xfree(t);
@@ -600,6 +635,7 @@ idnsParseWIN32Registry(void)
                                 while (token) {
                                     debugs(78, DBG_IMPORTANT, "Adding nameserver " << token << " from Registry");
                                     idnsAddNameserver(token);
+                                    result = true;
                                     token = strtok(NULL, ", ");
                                 }
 
@@ -644,6 +680,7 @@ idnsParseWIN32Registry(void)
                 while (token) {
                     debugs(78, DBG_IMPORTANT, "Adding nameserver " << token << " from Registry");
                     idnsAddNameserver(token);
+                    result = true;
                     token = strtok(NULL, ", ");
                 }
                 xfree(t);
@@ -656,8 +693,9 @@ idnsParseWIN32Registry(void)
 
     default:
         debugs(78, DBG_IMPORTANT, "Failed to read nameserver from Registry: Unknown System Type.");
-        return;
     }
+
+    return result;
 }
 
 #endif
@@ -690,14 +728,15 @@ idnsStats(StoreEntry * sentry)
         storeAppendPrintf(sentry, "DNS jumbo-grams: not working\n");
 
     storeAppendPrintf(sentry, "\nNameservers:\n");
-    storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES\n");
-    storeAppendPrintf(sentry, "---------------------------------------------- --------- ---------\n");
+    storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES Type\n");
+    storeAppendPrintf(sentry, "---------------------------------------------- --------- --------- --------\n");
 
     for (i = 0; i < nns; ++i) {
-        storeAppendPrintf(sentry, "%-45s %9d %9d\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
+        storeAppendPrintf(sentry, "%-45s %9d %9d %s\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
                           nameservers[i].S.NtoA(buf,MAX_IPSTRLEN),
                           nameservers[i].nqueries,
-                          nameservers[i].nreplies);
+                          nameservers[i].nreplies,
+                          nameservers[i].mDNSResolver?"multicast":"recurse");
     }
 
     storeAppendPrintf(sentry, "\nRcode Matrix:\n");
@@ -915,7 +954,11 @@ idnsSendQuery(idns_query * q)
     int nsn;
 
     do {
-        nsn = q->nsends % nns;
+        // only use mDNS resolvers for mDNS compatible queries
+        if (!q->permit_mdns)
+            nsn = MDNS_RESOLVER_COUNT + q->nsends % (nns-MDNS_RESOLVER_COUNT);
+        else
+            nsn = q->nsends % nns;
 
         if (q->need_vc) {
             idnsSendQueryVC(q, nsn);
@@ -1227,6 +1270,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
 
             q->nsends = 0;
 
+            idnsCheckMDNS(q);
             idnsSendQuery(q);
             if (Ip::EnableIpv6)
                 idnsSendSlaveAAAAQuery(q);
@@ -1531,19 +1575,20 @@ dnsInit(void)
     }
 
     assert(0 == nns);
-    idnsParseNameservers();
+    idnsAddMDNSNameservers();
+    bool nsFound = idnsParseNameservers();
 #if !_SQUID_WINDOWS_
 
-    if (0 == nns)
-        idnsParseResolvConf();
+    if (!nsFound)
+        nsFound = idnsParseResolvConf();
 
 #endif
 #if _SQUID_WINDOWS_
-    if (0 == nns)
-        idnsParseWIN32Registry();
+    if (!nsFound)
+        nsFound = idnsParseWIN32Registry();
 #endif
 
-    if (0 == nns) {
+    if (!nsFound) {
         debugs(78, DBG_IMPORTANT, "Warning: Could not find any nameservers. Trying to use localhost");
 #if _SQUID_WINDOWS_
         debugs(78, DBG_IMPORTANT, "Please check your TCP-IP settings or /etc/resolv.conf file");
@@ -1657,6 +1702,7 @@ idnsSendSlaveAAAAQuery(idns_query *master)
         cbdataFree(q);
         return;
     }
+    idnsCheckMDNS(q);
     master->slave = q;
     idnsSendQuery(q);
 }
@@ -1709,6 +1755,7 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     debugs(78, 3, "idnsALookup: buf is " << q->sz << " bytes for " << q->name <<
            ", id = 0x" << std::hex << q->query_id);
 
+    idnsCheckMDNS(q);
     idnsStartQuery(q, callback, data);
 
     if (Ip::EnableIpv6)
@@ -1757,6 +1804,7 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
     debugs(78, 3, "idnsPTRLookup: buf is " << q->sz << " bytes for " << ip <<
            ", id = 0x" << std::hex << q->query_id);
 
+    q->permit_mdns = true;
     idnsStartQuery(q, callback, data);
 }
 
@@ -32,7 +32,7 @@
  */
 
 #include "squid.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "esi/CustomParser.h"
 #include "Debug.h"
 #include "Trie.h"
@@ -34,7 +34,7 @@
 
 #include "esi/Segment.h"
 #include "Trie.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "HttpHeader.h"
 
 class HttpReply;
@@ -32,7 +32,7 @@
 #ifndef SQUID_EVENT_H
 #define SQUID_EVENT_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "AsyncEngine.h"
 #include "MemPool.h"
 
@@ -194,6 +194,8 @@ struct _external_acl_format {
 #endif
         EXT_ACL_EXT_LOG,
         EXT_ACL_TAG,
+        EXT_ACL_ACLNAME,
+        EXT_ACL_ACLDATA,
         EXT_ACL_PERCENT,
         EXT_ACL_END
     } type;
@@ -482,6 +484,10 @@ parse_externalAclHelper(external_acl ** list)
             format->type = _external_acl_format::EXT_ACL_EXT_LOG;
         else if (strcmp(token, "%TAG") == 0)
             format->type = _external_acl_format::EXT_ACL_TAG;
+        else if (strcmp(token, "%ACL") == 0)
+            format->type = _external_acl_format::EXT_ACL_ACLNAME;
+        else if (strcmp(token, "%DATA") == 0)
+            format->type = _external_acl_format::EXT_ACL_ACLDATA;
         else if (strcmp(token, "%%") == 0)
             format->type = _external_acl_format::EXT_ACL_PERCENT;
         else {
@@ -681,6 +687,7 @@ external_acl::trimCache()
 
 struct _external_acl_data {
     external_acl *def;
+    const char *name;
     wordlist *arguments;
 };
 
@@ -689,6 +696,7 @@ static void
 free_external_acl_data(void *data)
 {
     external_acl_data *p = static_cast<external_acl_data *>(data);
+    safe_free(p->name);
     wordlistDestroy(&p->arguments);
     cbdataReferenceDone(p->def);
 }
@@ -715,6 +723,10 @@ ACLExternal::parse()
     if (!data->def)
         self_destruct();
 
+    // def->name is the name of the external_acl_type.
+    // this is the name of the 'acl' directive being tested
+    data->name = xstrdup(AclMatchedName);
+
     while ((token = strtokFile())) {
         wordlistAdd(&data->arguments, token);
     }
@@ -777,14 +789,17 @@ copyResultsFromEntry(HttpRequest *req, external_acl_entry *entry)
 static allow_t
 aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 {
-    const char *key = "";
     debugs(82, 9, HERE << "acl=\"" << acl->def->name << "\"");
     external_acl_entry *entry = ch->extacl_entry;
 
+    external_acl_message = "MISSING REQUIRED INFORMATION";
+
     if (entry) {
         if (cbdataReferenceValid(entry) && entry->def == acl->def) {
             /* Ours, use it.. if the key matches */
-            key = makeExternalAclKey(ch, acl);
+            const char *key = makeExternalAclKey(ch, acl);
+            if (!key)
+                return ACCESS_DUNNO; // insufficent data to continue
             if (strcmp(key, (char*)entry->key) != 0) {
                 debugs(82, 9, HERE << "entry key='" << (char *)entry->key << "', our key='" << key << "' dont match. Discarded.");
                 // too bad. need a new lookup.
@@ -796,16 +811,14 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
             debugs(82, 9, HERE << "entry " << entry << " not valid or not ours. Discarded.");
             if (entry) {
                 debugs(82, 9, HERE << "entry def=" << entry->def << ", our def=" << acl->def);
-                key = makeExternalAclKey(ch, acl);
+                const char *key = makeExternalAclKey(ch, acl); // may be nil
                 debugs(82, 9, HERE << "entry key='" << (char *)entry->key << "', our key='" << key << "'");
             }
             cbdataReferenceDone(ch->extacl_entry);
             entry = NULL;
         }
     }
 
-    external_acl_message = "MISSING REQUIRED INFORMATION";
-
     if (!entry) {
         debugs(82, 9, HERE << "No helper entry available");
 #if USE_AUTH
@@ -820,7 +833,7 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
             debugs(82, 3, HERE << acl->def->name << " user is authenticated.");
         }
 #endif
-        key = makeExternalAclKey(ch, acl);
+        const char *key = makeExternalAclKey(ch, acl);
 
         if (!key) {
             /* Not sufficient data to process */
@@ -845,9 +858,10 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
             debugs(82, 2, HERE << "\"" << key << "\": entry=@" <<
                    entry << ", age=" << (entry ? (long int) squid_curtime - entry->date : 0));
 
-            if (acl->def->theHelper->stats.queue_size <= (int)acl->def->theHelper->childs.n_active) {
+            if (acl->def->theHelper->stats.queue_size < (int)acl->def->theHelper->childs.n_active) {
                 debugs(82, 2, HERE << "\"" << key << "\": queueing a call.");
-                ch->changeState(ExternalACLLookup::Instance());
+                if (!ch->goAsync(ExternalACLLookup::Instance()))
+                    debugs(82, 2, "\"" << key << "\": no async support!");
                 debugs(82, 2, HERE << "\"" << key << "\": return -1.");
                 return ACCESS_DUNNO; // expired cached or simply absent entry
             } else {
@@ -900,8 +914,8 @@ ACLExternal::match(ACLChecklist *checklist)
     case ACCESS_AUTH_REQUIRED:
     default:
         // If the answer is not allowed or denied (matches/not matches) and
-        // async authentication is not needed (asyncNeeded), then we are done.
-        if (!checklist->asyncNeeded())
+        // async authentication is not in progress, then we are done.
+        if (checklist->keepMatching())
             checklist->markFinished(answer, "aclMatchExternal exception");
         return -1; // other
     }
@@ -952,6 +966,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
     HttpRequest *request = ch->request;
     HttpReply *reply = ch->reply;
     mb.reset();
+    bool data_used = false;
 
     for (format = acl_data->def->format; format; format = format->next) {
         const char *str = NULL;
@@ -974,7 +989,9 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             str = ch->rfc931;
 
             if (!str || !*str) {
-                ch->changeState(IdentLookup::Instance());
+                // if we fail to go async, we still return NULL and the caller
+                // will detect the failure in ACLExternal::match().
+                (void)ch->goAsync(IdentLookup::Instance());
                 return NULL;
             }
 
@@ -1142,6 +1159,29 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
         case _external_acl_format::EXT_ACL_TAG:
             str = request->tag.termedBuf();
             break;
+        case _external_acl_format::EXT_ACL_ACLNAME:
+            str = acl_data->name;
+            break;
+        case _external_acl_format::EXT_ACL_ACLDATA:
+            data_used = true;
+            for (arg = acl_data->arguments; arg; arg = arg->next) {
+                if (!first)
+                    sb.append(" ", 1);
+
+                if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                    const char *quoted = rfc1738_escape(arg->key);
+                    sb.append(quoted, strlen(quoted));
+                } else {
+                    static MemBuf mb2;
+                    mb2.init();
+                    strwordquote(&mb2, arg->key);
+                    sb.append(mb2.buf, mb2.size);
+                    mb2.clean();
+                }
+
+                first = 0;
+            }
+            break;
         case _external_acl_format::EXT_ACL_PERCENT:
             str = "%";
             break;
@@ -1174,18 +1214,20 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
         first = 0;
     }
 
-    for (arg = acl_data->arguments; arg; arg = arg->next) {
-        if (!first)
-            mb.append(" ", 1);
+    if (!data_used) {
+        for (arg = acl_data->arguments; arg; arg = arg->next) {
+            if (!first)
+                mb.append(" ", 1);
 
-        if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-            const char *quoted = rfc1738_escape(arg->key);
-            mb.append(quoted, strlen(quoted));
-        } else {
-            strwordquote(&mb, arg->key);
-        }
+            if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                const char *quoted = rfc1738_escape(arg->key);
+                mb.append(quoted, strlen(quoted));
+            } else {
+                strwordquote(&mb, arg->key);
+            }
 
-        first = 0;
+            first = 0;
+        }
     }
 
     return mb.buf;
@@ -1328,26 +1370,26 @@ externalAclHandleReply(void *data, const HelperReply &reply)
 
     // XXX: make entryData store a proper HelperReply object instead of copying.
 
-    Note::Pointer label = reply.notes.find("tag");
-    if (label != NULL && label->values[0]->value.size() > 0)
-        entryData.tag = label->values[0]->value;
+    const char *label = reply.notes.findFirst("tag");
+    if (label != NULL && *label != '\0')
+        entryData.tag = label;
 
-    label = reply.notes.find("message");
-    if (label != NULL && label->values[0]->value.size() > 0)
-        entryData.message = label->values[0]->value;
+    label = reply.notes.findFirst("message");
+    if (label != NULL && *label != '\0')
+        entryData.message = label;
 
-    label = reply.notes.find("log");
-    if (label != NULL && label->values[0]->value.size() > 0)
-        entryData.log = label->values[0]->value;
+    label = reply.notes.findFirst("log");
+    if (label != NULL && *label != '\0')
+        entryData.log = label;
 
 #if USE_AUTH
-    label = reply.notes.find("user");
-    if (label != NULL && label->values[0]->value.size() > 0)
-        entryData.user = label->values[0]->value;
+    label = reply.notes.findFirst("user");
+    if (label != NULL && *label != '\0')
+        entryData.user = label;
 
-    label = reply.notes.find("password");
-    if (label != NULL && label->values[0]->value.size() > 0)
-        entryData.password = label->values[0]->value;
+    label = reply.notes.findFirst("password");
+    if (label != NULL && *label != '\0')
+        entryData.password = label;
 #endif
 
     dlinkDelete(&state->list, &state->def->queue);
@@ -1392,7 +1434,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
 
     ACLFilledChecklist *ch = Filled(checklist);
     const char *key = makeExternalAclKey(ch, acl);
-    assert(key);
+    assert(key); // XXX: will fail if EXT_ACL_IDENT case needs an async lookup
 
     debugs(82, 2, HERE << (inBackground ? "bg" : "fg") << " lookup in '" <<
            def->name << "' for '" << key << "'");
@@ -1542,7 +1584,6 @@ ExternalACLLookup::checkForAsync(ACLChecklist *checklist)const
     assert(acl);
     ACLExternal *me = dynamic_cast<ACLExternal *> (acl);
     assert (me);
-    checklist->asyncInProgress(true);
     ACLExternal::ExternalAclLookup(checklist, me);
 }
 
@@ -1552,9 +1593,7 @@ ExternalACLLookup::LookupDone(void *data, void *result)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
     checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(ExternalACLLookup::Instance());
 }
 
 /* This registers "external" in the registry. To do dynamic definitions
@@ -383,7 +383,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_LOCAL_LISTENING_IP: {
             // avoid logging a dash if we have reliable info
             const bool interceptedAtKnownPort = al->request ?
-                                                (al->request->flags.spoofClientIp ||
+                                                (al->request->flags.interceptTproxy ||
                                                  al->request->flags.intercepted) && al->cache.port :
                                                 false;
             if (interceptedAtKnownPort) {
@@ -629,7 +629,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_ICAP_REQ_HEADER_ELEM:
-            if (al->request)
+            if (al->icap.request)
                 sb = al->icap.request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
@@ -760,7 +760,10 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_USER_NAME:
-            out = strOrNull(al->cache.authuser);
+#if USE_AUTH
+            if (al->request && al->request->auth_user_request != NULL)
+                out = strOrNull(al->request->auth_user_request->username());
+#endif
             if (!out)
                 out = strOrNull(al->cache.extuser);
 #if USE_SSL
@@ -772,7 +775,10 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_USER_LOGIN:
-            out = strOrNull(al->cache.authuser);
+#if USE_AUTH
+            if (al->request && al->request->auth_user_request != NULL)
+                out = strOrNull(al->request->auth_user_request->username());
+#endif
             break;
 
         case LFT_USER_IDENT:
@@ -1042,17 +1048,31 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 #endif
         case LFT_NOTE:
             if (fmt->data.string) {
-                sb = al->notes.getByName(fmt->data.string);
+#if USE_ADAPTATION
+                Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
+                if (ah != NULL && ah->metaHeaders != NULL) {
+                    if (const char *meta = ah->metaHeaders->find(fmt->data.string))
+                        sb.append(meta);
+                }
+#endif
+                if (al->notes != NULL) {
+                    if (const char *note = al->notes->find(fmt->data.string)) {
+                        if (sb.size())
+                            sb.append(", ");
+                        sb.append(note);
+                    }
+                }
                 out = sb.termedBuf();
                 quote = 1;
             } else {
-                HttpHeaderPos pos = HttpHeaderInitPos;
-                while (const HttpHeaderEntry *e = al->notes.getEntry(&pos)) {
-                    sb.append(e->name);
-                    sb.append(": ");
-                    sb.append(e->value);
-                    sb.append("\r\n");
-                }
+#if USE_ADAPTATION
+                Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
+                if (ah != NULL && ah->metaHeaders != NULL && !ah->metaHeaders->empty())
+                    sb.append(ah->metaHeaders->toString());
+#endif
+                if (al->notes != NULL && !al->notes->empty())
+                    sb.append(al->notes->toString());
+
                 out = sb.termedBuf();
                 quote = 1;
             }
@@ -301,7 +301,7 @@ Format::Token::parse(const char *def, Quoting *quoting)
     }
 
     if (*cur == '0') {
-        zero = false;
+        zero = true;
         ++cur;
     }
 
@@ -151,7 +151,7 @@ void FwdState::start(Pointer aSelf)
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must force DIRECT and only to the original client destination.
-    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.spoofClientIp);
+    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || (request && !request->flags.hostVerified);
     if (isIntercepted && useOriginalDst) {
         selectPeerForIntercepted();
@@ -552,10 +552,7 @@ FwdState::checkRetry()
     if (!entry->isEmpty())
         return false;
 
-    if (n_tries > 10)
-        return false;
-
-    if (origin_tries > 2)
+    if (n_tries > Config.forward_max_tries)
         return false;
 
     if (squid_curtime - start_t > Config.Timeout.forward)
@@ -1163,9 +1160,6 @@ FwdState::connectStart()
         debugs(17, 3, HERE << "reusing pconn " << serverConnection());
         ++n_tries;
 
-        if (!serverConnection()->getPeer())
-            ++origin_tries;
-
         comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
         /* Update server side TOS and Netfilter mark on the connection. */
@@ -1364,9 +1358,6 @@ FwdState::reforward()
     if (n_tries > Config.forward_max_tries)
         return 0;
 
-    if (origin_tries > 1)
-        return 0;
-
     if (request->bodyNibbled())
         return 0;
 
@@ -1,7 +1,7 @@
 #ifndef SQUID_FORWARD_H
 #define SQUID_FORWARD_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "comm.h"
 #include "comm/Connection.h"
@@ -120,7 +120,6 @@ class FwdState : public RefCountable
     Comm::ConnectionPointer clientConn;        ///< a possibly open connection to the client.
     time_t start_t;
     int n_tries;
-    int origin_tries;
 
     // AsyncCalls which we set and may need cancelling.
     struct {
@@ -420,9 +420,14 @@ Fs::Ufs::RebuildState::undoAdd()
     added->releaseRequest();
 
     if (added->swap_filen > -1) {
-        UFSSwapDir *sde = dynamic_cast<UFSSwapDir *>(INDEXSD(added->swap_dirn));
-        assert(sde);
-        sde->undoAddDiskRestore(added);
+        SwapDir *someDir = INDEXSD(added->swap_dirn);
+        assert(someDir);
+        if (UFSSwapDir *ufsDir = dynamic_cast<UFSSwapDir*>(someDir))
+            ufsDir->undoAddDiskRestore(added);
+        // else the entry was loaded from and/or is currently in a non-UFS dir
+        // Thus, there is no use in preserving its disk file (the only purpose
+        // of undoAddDiskRestore!), even if we could. Instead, we release the
+        // the entry and [eventually] unlink its disk file or free its slot.
     }
 
     added->release();
@@ -47,6 +47,8 @@ extern char tmp_error_buf[ERROR_BUF_SZ];
 extern char ThisCache[RFC2181_MAXHOSTNAMELEN << 1];
 extern char ThisCache2[RFC2181_MAXHOSTNAMELEN << 1];
 extern char config_input_line[BUFSIZ];
+/// During parsing, the name of the current squid.conf directive being parsed.
+extern const char *cfg_directive; /* NULL */
 extern const char *DefaultConfigFile;	/* DEFAULT_CONFIG_FILE */
 extern const char *cfg_filename;	/* NULL */
 extern const char *dash_str;	/* "-" */
@@ -36,6 +36,7 @@
 #include "comm/Connection.h"
 #include "comm/Write.h"
 #include "fd.h"
+#include "fde.h"
 #include "format/Quoting.h"
 #include "helper.h"
 #include "Mem.h"
@@ -526,7 +527,7 @@ helperStats(StoreEntry * sentry, helper * hlp, const char *label)
     for (dlink_node *link = hlp->servers.head; link; link = link->next) {
         helper_server *srv = (helper_server*)link->data;
         double tt = 0.001 * (srv->requests[0] ? tvSubMsec(srv->requests[0]->dispatch_time, current_time) : tvSubMsec(srv->dispatch_time, srv->answer_time));
-        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "%c%c%c%c\t%7.3f\t%7d\t%s\n",
+        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c\t%7.3f\t%7d\t%s\n",
                           srv->index + 1,
                           srv->readPipe->fd,
                           srv->pid,
@@ -771,7 +772,7 @@ helperServerFree(helper_server *srv)
     safe_free(srv->requests);
 
     cbdataReferenceDone(srv->parent);
-    cbdataFree(srv);
+    delete srv;
 }
 
 static void
@@ -840,7 +841,7 @@ helperStatefulServerFree(helper_stateful_server *srv)
 
     cbdataReferenceDone(srv->parent);
 
-    cbdataFree(srv);
+    delete srv;
 }
 
 /// Calls back with a pointer to the buffer with the helper output
@@ -957,7 +958,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
         srv->rbuf[srv->roffset] = '\0';
     }
 
-    if (Comm::IsConnOpen(srv->readPipe)) {
+    if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
         int spaceSize = srv->rbuf_sz - srv->roffset - 1;
         assert(spaceSize >= 0);
 
@@ -1078,7 +1079,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
             helperStatefulReleaseServer(srv);
     }
 
-    if (Comm::IsConnOpen(srv->readPipe)) {
+    if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
         int spaceSize = srv->rbuf_sz - srv->roffset - 1;
         assert(spaceSize >= 0);
 
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "comm.h"
 #include "comm/Loops.h"
+#include "defines.h"
 #include "fd.h"
 #include "icmp/IcmpSquid.h"
 #include "icmp/net_db.h"
@@ -431,9 +431,9 @@ icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd)
 bool
 icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request)
 {
-    /* absent an explicit allow, we deny all */
+    /* absent any explicit rules, we deny all */
     if (!Config.accessList.icp)
-        return true;
+        return false;
 
     ACLFilledChecklist checklist(Config.accessList.icp, icp_request, NULL);
     checklist.src_addr = from;
@@ -89,14 +89,18 @@ ACLIdent::match(ACLChecklist *cl)
     } else if (checklist->conn() != NULL && checklist->conn()->clientConnection != NULL && checklist->conn()->clientConnection->rfc931[0]) {
         return data->match(checklist->conn()->clientConnection->rfc931);
     } else if (checklist->conn() != NULL && Comm::IsConnOpen(checklist->conn()->clientConnection)) {
-        debugs(28, 3, HERE << "switching to ident lookup state");
-        checklist->changeState(IdentLookup::Instance());
-        return 0;
+        if (checklist->goAsync(IdentLookup::Instance())) {
+            debugs(28, 3, "switching to ident lookup state");
+            return -1;
+        }
+        // else fall through to ACCESS_DUNNO failure below
     } else {
         debugs(28, DBG_IMPORTANT, HERE << "Can't start ident lookup. No client connection" );
-        checklist->markFinished(ACCESS_DUNNO, "cannot start ident lookup");
-        return -1;
+        // fall through to ACCESS_DUNNO failure below
     }
+
+    checklist->markFinished(ACCESS_DUNNO, "cannot start ident lookup");
+    return -1;
 }
 
 wordlist *
@@ -133,15 +137,13 @@ IdentLookup::checkForAsync(ACLChecklist *cl)const
     // check that ACLIdent::match() tested this lookup precondition
     assert(conn && Comm::IsConnOpen(conn->clientConnection));
     debugs(28, 3, HERE << "Doing ident lookup" );
-    checklist->asyncInProgress(true);
     Ident::Start(checklist->conn()->clientConnection, LookupDone, checklist);
 }
 
 void
 IdentLookup::LookupDone(const char *ident, void *data)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
-    assert(checklist->asyncState() == IdentLookup::Instance());
 
     if (ident) {
         xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
@@ -156,9 +158,7 @@ IdentLookup::LookupDone(const char *ident, void *data)
     if (checklist->conn() != NULL && checklist->conn()->clientConnection != NULL && !checklist->conn()->clientConnection->rfc931[0])
         xstrncpy(checklist->conn()->clientConnection->rfc931, checklist->rfc931, USER_IDENT_SZ);
 
-    checklist->asyncInProgress(false);
-    checklist->changeState(ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(IdentLookup::Instance());
 }
 
 #endif /* USE_IDENT */
@@ -34,6 +34,7 @@
 #include "comm/Connection.h"
 #include "ip/Intercept.h"
 #include "fde.h"
+#include "src/tools.h"
 
 #if IPF_TRANSPARENT
 
@@ -146,9 +147,12 @@ Ip::Intercept::NetfilterInterception(const Comm::ConnectionPointer &newConn, int
 }
 
 bool
-Ip::Intercept::NetfilterTransparent(const Comm::ConnectionPointer &newConn, int silent)
+Ip::Intercept::TproxyTransparent(const Comm::ConnectionPointer &newConn, int silent)
 {
-#if LINUX_NETFILTER
+#if (LINUX_NETFILTER && defined(IP_TRANSPARENT)) || \
+    (PF_TRANSPARENT && defined(SO_BINDANY)) || \
+    (IPFW_TRANSPARENT && defined(IP_BINDANY))
+
     /* Trust the user configured properly. If not no harm done.
      * We will simply attempt a bind outgoing on our own IP.
      */
@@ -164,26 +168,15 @@ bool
 Ip::Intercept::IpfwInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
 #if IPFW_TRANSPARENT
-    struct sockaddr_storage lookup;
-    socklen_t len = sizeof(struct sockaddr_storage);
-    newConn->local.GetSockAddr(lookup, AF_INET);
-
-    /** \par
-     * Try lookup for IPFW interception. */
-    if ( getsockname(newConn->fd, (struct sockaddr*)&lookup, &len) != 0 ) {
-        if ( !silent ) {
-            debugs(89, DBG_IMPORTANT, HERE << " IPFW getsockname(...) failed: " << xstrerror());
-            lastReported_ = squid_curtime;
-        }
-        debugs(89, 9, HERE << "address: " << newConn);
-        return false;
-    } else {
-        newConn->local = lookup;
-        debugs(89, 5, HERE << "address NAT: " << newConn);
-        return true;
-    }
-#endif
+    /* The getsockname() call performed already provided the TCP packet details.
+     * There is no way to identify whether they came from NAT or not.
+     * Trust the user configured properly.
+     */
+    debugs(89, 5, HERE << "address NAT: " << newConn);
+    return true;
+#else
     return false;
+#endif
 }
 
 bool
@@ -277,24 +270,21 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
 }
 
 bool
-Ip::Intercept::PfTransparent(const Comm::ConnectionPointer &newConn, int silent)
+Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
-#if PF_TRANSPARENT && defined(SO_BINDANY)
-    /* Trust the user configured properly. If not no harm done.
-     * We will simply attempt a bind outgoing on our own IP.
+#if PF_TRANSPARENT  /* --enable-pf-transparent */
+
+#if !USE_NAT_DEVPF
+    /* On recent PF versions the getsockname() call performed already provided
+     * the required TCP packet details.
+     * There is no way to identify whether they came from NAT or not.
+     *
+     * Trust the user configured properly.
      */
-    newConn->remote.SetPort(0); // allow random outgoing port to prevent address clashes
-    debugs(89, 5, HERE << "address DIVERT: " << newConn);
+    debugs(89, 5, HERE << "address NAT divert-to: " << newConn);
     return true;
-#else
-    return false;
-#endif
-}
 
-bool
-Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent)
-{
-#if PF_TRANSPARENT  /* --enable-pf-transparent */
+#else /* USE_NAT_DEVPF / --with-nat-devpf */
 
     struct pfioc_natlook nl;
     static int pffd = -1;
@@ -338,7 +328,7 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
         debugs(89, 5, HERE << "address NAT: " << newConn);
         return true;
     }
-
+#endif /* --with-nat-devpf */
 #endif /* --enable-pf-transparent */
     return false;
 }
@@ -366,8 +356,7 @@ Ip::Intercept::Lookup(const Comm::ConnectionPointer &newConn, const Comm::Connec
 
     /* NP: try TPROXY first, its much quieter than NAT when non-matching */
     if (transparentActive_ && listenConn->flags&COMM_TRANSPARENT) {
-        if (NetfilterTransparent(newConn, silent)) return true;
-        if (PfTransparent(newConn, silent)) return true;
+        if (TproxyTransparent(newConn, silent)) return true;
     }
 
     /* NAT is only available in IPv4 */
@@ -394,7 +383,28 @@ Ip::Intercept::Lookup(const Comm::ConnectionPointer &newConn, const Comm::Connec
 bool
 Ip::Intercept::ProbeForTproxy(Ip::Address &test)
 {
-#if defined(IP_TRANSPARENT)
+    bool doneSuid = false;
+
+#if _SQUID_LINUX_ && defined(IP_TRANSPARENT) // Linux
+# define soLevel SOL_IP
+# define soFlag  IP_TRANSPARENT
+
+#elif defined(SO_BINDANY) // OpenBSD 4.7+ and NetBSD with PF
+# define soLevel SOL_SOCKET
+# define soFlag  SO_BINDANY
+    enter_suid();
+    doneSuid = true;
+
+#elif defined(IP_BINDANY) // FreeBSD with IPFW
+# define soLevel IPPROTO_IP
+# define soFlag  IP_BINDANY
+    enter_suid();
+    doneSuid = true;
+
+#endif
+
+#if defined(soLevel) && defined(soFlag)
+
     debugs(3, 3, "Detect TPROXY support on port " << test);
 
     int tos = 1;
@@ -410,11 +420,13 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
         tmp.GetSockAddr(tmp_ip6);
 
         if ( (tmp_sock = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
-                setsockopt(tmp_sock, SOL_IP, IP_TRANSPARENT, (char *)&tos, sizeof(int)) == 0 &&
+                setsockopt(tmp_sock, soLevel, soFlag, (char *)&tos, sizeof(int)) == 0 &&
                 bind(tmp_sock, (struct sockaddr*)&tmp_ip6, sizeof(struct sockaddr_in6)) == 0 ) {
 
             debugs(3, 3, "IPv6 TPROXY support detected. Using.");
             close(tmp_sock);
+            if (doneSuid)
+                leave_suid();
             return true;
         }
         if (tmp_sock >= 0) {
@@ -425,6 +437,8 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
 
     if ( test.IsIPv6() && !test.SetIPv4() ) {
         debugs(3, DBG_CRITICAL, "TPROXY lacks IPv6 support for " << test );
+        if (doneSuid)
+            leave_suid();
         return false;
     }
 
@@ -438,63 +452,25 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
         tmp.GetSockAddr(tmp_ip4);
 
         if ( (tmp_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
-                setsockopt(tmp_sock, SOL_IP, IP_TRANSPARENT, (char *)&tos, sizeof(int)) == 0 &&
+                setsockopt(tmp_sock, soLevel, soFlag, (char *)&tos, sizeof(int)) == 0 &&
                 bind(tmp_sock, (struct sockaddr*)&tmp_ip4, sizeof(struct sockaddr_in)) == 0 ) {
 
             debugs(3, 3, "IPv4 TPROXY support detected. Using.");
             close(tmp_sock);
+            if (doneSuid)
+                leave_suid();
             return true;
         }
         if (tmp_sock >= 0) {
             close(tmp_sock);
         }
     }
 
-#elif defined(SO_BINDANY)
-    debugs(3, 3, "Detect BINDANY support on port " << test);
-
-    int tos = 1;
-    int tmp_sock = -1;
-
-    if (test.IsIPv6()) {
-        debugs(3, 3, "...Probing for IPv6 SO_BINDANY support.");
-
-        struct sockaddr_in6 tmp_ip6;
-        Ip::Address tmp = "::2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip6);
-
-        if ((tmp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP)) >=0 &&
-                (setsockopt(tmp_sock, SOL_SOCKET, SO_BINDANY, (char *)&tos,
-                            sizeof(tos)) == 0) &&
-                (bind(tmp_sock, (struct sockaddr*)&tmp_ip6, sizeof(struct sockaddr_in6)) == 0)) {
-            debugs(3, 3, "IPv6 BINDANY support detected. Using.");
-            close(tmp_sock);
-            return true;
-        }
-    }
-
-    if (test.IsIPv4()) {
-        debugs(3, 3, "...Probing for IPv4 SO_BINDANY support.");
-
-        struct sockaddr_in tmp_ip4;
-        Ip::Address tmp = "127.0.0.2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip4);
-
-        if ((tmp_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) >=0 &&
-                (setsockopt(tmp_sock, SOL_SOCKET, SO_BINDANY, (char *)&tos,
-                            sizeof(tos)) == 0) &&
-                (bind(tmp_sock, (struct sockaddr*)&tmp_ip4, sizeof(struct sockaddr_in)) == 0)) {
-            debugs(3, 3, "IPv4 BINDANY support detected. Using.");
-            close(tmp_sock);
-            return true;
-        }
-    }
-
 #else
     debugs(3, 3, "TPROXY setsockopt() not supported on this platform. Disabling TPROXY.");
 
 #endif
+    if (doneSuid)
+        leave_suid();
     return false;
 }
@@ -88,22 +88,23 @@ class Intercept
 private:
 
     /**
-     * perform Lookups on Netfilter interception targets (REDIRECT, DNAT).
+     * perform Lookups on fully-transparent interception targets (TPROXY).
+     * Supports Netfilter, PF and IPFW.
      *
      * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
      * \param newConn  Details known, to be updated where relevant.
      * \return         Whether successfuly located the new address.
      */
-    bool NetfilterInterception(const Comm::ConnectionPointer &newConn, int silent);
+    bool TproxyTransparent(const Comm::ConnectionPointer &newConn, int silent);
 
     /**
-     * perform Lookups on Netfilter fully-transparent interception targets (TPROXY).
+     * perform Lookups on Netfilter interception targets (REDIRECT, DNAT).
      *
      * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
      * \param newConn  Details known, to be updated where relevant.
      * \return         Whether successfuly located the new address.
      */
-    bool NetfilterTransparent(const Comm::ConnectionPointer &newConn, int silent);
+    bool NetfilterInterception(const Comm::ConnectionPointer &newConn, int silent);
 
     /**
      * perform Lookups on IPFW interception.
@@ -132,15 +133,6 @@ class Intercept
      */
     bool PfInterception(const Comm::ConnectionPointer &newConn, int silent);
 
-    /**
-     * perform Lookups on PF fully-transparent interception target (DIVERT).
-     *
-     * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
-     * \param newConn  Details known, to be updated where relevant.
-     * \return         Whether successfuly located the new address.
-     */
-    bool PfTransparent(const Comm::ConnectionPointer &newConn, int silent);
-
     int transparentActive_;
     int interceptActive_;
     time_t lastReported_; /**< Time of last error report. Throttles NAT error display to 1 per minute */
@@ -1,6 +1,7 @@
 #ifndef SQUID_QOSCONFIG_H
 #define SQUID_QOSCONFIG_H
 
+#include "acl/forward.h"
 #include "hier_code.h"
 #include "ip/forward.h"
 
@@ -16,7 +17,6 @@
 #include <limits>
 #endif
 
-class ACLList;
 class fde;
 
 // TODO: move to new ACL framework
@@ -36,6 +36,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "ip/Address.h"
+#include "ipc/Kid.h"
 #include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "tools.h"
@@ -310,6 +311,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     }
 
     /* child */
+    TheProcessKind = pkHelper;
     no_suid();			/* give up extra priviliges */
 
     /* close shared socket with parent */
@@ -6,7 +6,7 @@
 #ifndef SQUID_IPC_COORDINATOR_H
 #define SQUID_IPC_COORDINATOR_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "ipc/Messages.h"
 #include "ipc/Port.h"
 #include "ipc/SharedListen.h"
@@ -90,6 +90,7 @@ typedef enum {
     pkCoordinator = 1, ///< manages all other kids
     pkWorker = 2, ///< general-purpose worker bee
     pkDisker = 4, ///< cache_dir manager
+    pkHelper = 8  ///< general-purpose helper child
 } ProcessKind;
 
 /// ProcessKind for the current process
@@ -4,7 +4,7 @@
 #ifndef SQUID_IPC_KIDS_H
 #define SQUID_IPC_KIDS_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "ipc/Kid.h"
 
 /// a collection of kids
@@ -4,7 +4,7 @@
 #ifndef SQUID_IPC_QUEUE_H
 #define SQUID_IPC_QUEUE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "Debug.h"
 #include "base/InstanceId.h"
 #include "ipc/AtomicWord.h"
@@ -29,9 +29,9 @@
  *
  */
 //#include "format/Format.h"
+#include "acl/forward.h"
 #include "log/Formats.h"
 
-class ACLList;
 class Logfile;
 namespace Format
 {
@@ -48,6 +48,10 @@ class CustomLog
     Logfile *logfile;
     CustomLog *next;
     Log::Format::log_type type;
+    /// how much to buffer before dropping or dying (access_log buffer-size)
+    size_t bufferSize;
+    /// whether unrecoverable errors (e.g., dropping a log record) kill worker
+    bool fatal;
 };
 
 #endif /* SQUID_CUSTOMLOG_H_ */
@@ -37,7 +37,7 @@
 #include "log/ModStdio.h"
 #include "log/ModSyslog.h"
 #include "log/ModUdp.h"
-#include "log/ModTcp.h"
+#include "log/TcpLogger.h"
 
 CBDATA_TYPE(Logfile);
 
@@ -62,7 +62,7 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
         ret = logfile_mod_daemon_open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "tcp:", 4) == 0) {
         patharg = path + 4;
-        ret = logfile_mod_tcp_open(lf, patharg, bufsz, fatal_flag);
+        ret = Log::TcpLogger::Open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "udp:", 4) == 0) {
         patharg = path + 4;
         ret = logfile_mod_udp_open(lf, patharg, bufsz, fatal_flag);
@@ -72,7 +72,7 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
         ret = logfile_mod_syslog_open(lf, patharg, bufsz, fatal_flag);
 #endif
     } else {
-        debugs(50, DBG_IMPORTANT, "WARNING: log parameters now start with a module name. Use 'stdio:" << patharg << "'");
+        debugs(50, DBG_IMPORTANT, "WARNING: log name now starts with a module name. Use 'stdio:" << patharg << "'");
         snprintf(lf->path, MAXPATHLEN, "stdio:%s", patharg);
         ret = logfile_mod_stdio_open(lf, patharg, bufsz, fatal_flag);
     }
@@ -45,13 +45,15 @@ void
 Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *user_ident = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
-
-    const char *user_auth = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
-
+    const char *user_auth = NULL;
     const char *referer = NULL;
     const char *agent = NULL;
 
     if (al->request) {
+#if USE_AUTH
+        if (al->request->auth_user_request != NULL)
+            user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
         referer = al->request->header.getStr(HDR_REFERER);
         agent = al->request->header.getStr(HDR_USER_AGENT);
     }
@@ -35,6 +35,7 @@
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "globals.h"
+#include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "SquidConfig.h"
@@ -43,7 +44,11 @@
 void
 Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
-    const char *user_auth = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
+    const char *user_auth = NULL;
+#if USE_AUTH
+    if (al->request && al->request->auth_user_request != NULL)
+        user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
     const char *user_ident = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
 
     char clientip[MAX_IPSTRLEN];
@@ -59,7 +59,10 @@ Log::Format::SquidIcap(const AccessLogEntry::Pointer &al, Logfile * logfile)
             client = al->cache.caddr.NtoA(clientbuf, MAX_IPSTRLEN);
     }
 
-    user = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
+#if USE_AUTH
+    if (al->request != NULL && al->request->auth_user_request != NULL)
+        user = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.extuser);