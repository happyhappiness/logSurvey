@@ -39,6 +39,7 @@ and ideas to make this software available.
     Cord Beermann <cord@cc.fh-lippe.de>
     Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
     David Luyer <luyer@ucs.uwa.edu.au>
+    Dhaval Varia
     Diego Woitasen <diegows@xtech.com.ar>
     Dmitry Kurochkin
     Don Hopkins <dhopkins@DonHopkins.com>
@@ -74,6 +74,11 @@ Changes to squid-3.3.0.1 (21 Oct 2012):
 	- ... and many compile error fixes
 	- ... and a very large amount of code polish for faster compilation
 
+Changes to squid-3.2.11 (30 Apr 2013):
+
+	- Regression Bug 3839: build error: src/tools.h: No such file or directory
+	- Update copyright on SN.png
+
 Changes to squid-3.2.10 (27 Apr 2013):
 
 	- Bug 3833: squidclient: Option '-k' is not present in man(1) page
@@ -249,3 +249,30 @@ AS_IF([test "$ac_res" != no],
       [$4])
 AS_VAR_POPDEF([ac_Search])dnl
 ])
+
+dnl Check for Cyrus SASL
+AC_DEFUN([SQUID_CHECK_SASL],[
+  squid_sasl_present="auto"
+  AC_CHECK_HEADERS([sasl/sasl.h sasl.h])
+  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
+    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
+      squid_sasl_present="no"
+    ])
+  ])
+  case "$squid_host_os" in
+    Darwin)
+      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
+        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
+        echo "checking for MAC Darwin without sasl.h ... yes"
+        squid_sasl_present="yes"
+      else
+        echo "checking for MAC Darwin without sasl.h ... no"
+        squid_sasl_present="no"
+      fi
+      ;;
+  esac
+  if test "x$squid_sasl_present" != "yes"; then
+    AC_MSG_WARN([Neither SASL nor SASL2 found])
+  fi
+  AC_SUBST(LIBSASL)
+])
@@ -148,6 +148,7 @@ gettimeofday(struct timeval *pcur_time, void *tzp)
 }
 #endif /* !HAVE_GETTIMEOFDAY */
 
+#if !_SQUID_MINGW_
 int
 statfs(const char *path, struct statfs *sfs)
 {
@@ -181,6 +182,7 @@ statfs(const char *path, struct statfs *sfs)
     sfs->f_namelen = maxlen;
     return 0;
 }
+#endif
 
 #if !_SQUID_MINGW_
 int
@@ -212,6 +212,7 @@ struct group {
     char    **gr_mem;      /* group members */
 };
 
+#if !_SQUID_MINGW_
 struct statfs {
     long    f_type;     /* type of filesystem (see below) */
     long    f_bsize;    /* optimal transfer block size */
@@ -224,6 +225,7 @@ struct statfs {
     long    f_namelen;  /* maximum length of filenames */
     long    f_spare[6]; /* spare for later */
 };
+#endif
 
 #if !HAVE_GETTIMEOFDAY
 struct timezone {
@@ -807,7 +809,9 @@ struct rusage {
 
 SQUIDCEXTERN int chroot(const char *dirname);
 SQUIDCEXTERN int kill(pid_t, int);
+#if !_SQUID_MINGW_
 SQUIDCEXTERN int statfs(const char *, struct statfs *);
+#endif
 SQUIDCEXTERN struct passwd * getpwnam(char *unused);
 SQUIDCEXTERN struct group * getgrnam(char *unused);
 
@@ -1726,45 +1726,7 @@ AC_ARG_ENABLE(auth-basic,
       To see available helpers, see the helpers/basic_auth directory. ]),[
 #nothing to do really
 ])
-#not specified. Inherit global
-if test "x$enable_auth_basic" = "x"; then
-    enable_auth_basic=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Basic auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_basic" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
-fi
-#handle the "none" special case
-if test "x$enable_auth_basic" = "xnone" ; then
-    enable_auth_basic=""
-fi
-BASIC_AUTH_HELPERS=""
-#enable_auth_basic contains either "no" or the list of modules to be built
-enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_basic" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES basic"
-    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
-    for helper in $enable_auth_basic
-    do
-    dir="$srcdir/helpers/basic_auth/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xSASL" ; then
-        squid_require_sasl=yes
-      fi
-    elif test -d "$srcdir/helpers/basic_auth/$helper" ; then
-      AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
-    fi
-    done
-fi
-AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
-AC_SUBST(BASIC_AUTH_HELPERS)
+m4_include([helpers/basic_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-ntlm,
   AS_HELP_STRING([--enable-auth-ntlm="list of helpers"],
@@ -1775,38 +1737,7 @@ AC_ARG_ENABLE(auth-ntlm,
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/ntlm_auth directory. ]),[
 ])
-if test "x$enable_auth_ntlm" = "x"; then
-    enable_auth_ntlm=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([NTLM auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_ntlm" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
-fi
-#handle the "none" special case
-if test "x$enable_auth_ntlm" = "xnone" ; then
-    enable_auth_ntlm=""
-fi
-NTLM_AUTH_HELPERS=""
-enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_ntlm" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES ntlm"
-    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
-    for helper in $enable_auth_ntlm ; do
-        dir="$srcdir/helpers/ntlm_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-            AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([NTLM auth helpers built: $NTLM_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
-AC_SUBST(NTLM_AUTH_HELPERS)
+m4_include([helpers/ntlm_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-negotiate,
   AS_HELP_STRING([--enable-auth-negotiate="list of helpers"],
@@ -1820,38 +1751,7 @@ AC_ARG_ENABLE(auth-negotiate,
       To see available helpers, see the helpers/negotiate_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_negotiate" = "x"; then
-    enable_auth_negotiate=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_negotiate" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
-fi
-#handle the "none" special case
-if test "x$enable_auth_negotiate" = "xnone" ; then
-    enable_auth_negotiate=""
-fi
-NEGOTIATE_AUTH_HELPERS=""
-enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_negotiate" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES negotiate"
-    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
-    for helper in $enable_auth_negotiate ; do
-        dir="$srcdir/helpers/negotiate_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/negotiate_auth/$helper" ; then
-            AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
-AC_SUBST(NEGOTIATE_AUTH_HELPERS)
+m4_include([helpers/negotiate_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-digest,
   AS_HELP_STRING([--enable-auth-digest="list of helpers"],
@@ -1863,38 +1763,7 @@ AC_ARG_ENABLE(auth-digest,
       To see available helpers, see the helpers/digest_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_digest" = "x"; then
-    enable_auth_digest=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Digest auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_digest" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
-fi
-#handle the "none" special case
-if test "x$enable_auth_digest" = "xnone" ; then
-    enable_auth_digest=""
-fi
-DIGEST_AUTH_HELPERS=""
-enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_digest" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES digest"
-    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
-    for helper in $enable_auth_digest ; do
-        dir="$srcdir/helpers/digest_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/digest_auth/$helper" ; then
-            AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Digest auth helpers built: $DIGEST_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
-AC_SUBST(DIGEST_AUTH_HELPERS)
+m4_include([helpers/digest_auth/modules.m4])
 
 dnl Authentication libraries to build
 dnl This list will not be needed when each auth library has its own Makefile
@@ -1920,20 +1789,7 @@ case "$enableval" in
   *)   squid_opt_logdaemon_helpers="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`" ;;
   esac
 ])
-if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
-  squid_opt_logdaemon_helpers=""
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[squid_opt_logdaemon_helpers])
-fi
-for helper in $squid_opt_logdaemon_helpers ; do
-  dir="$srcdir/helpers/log_daemon/$helper"
-  if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-    LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $helper"
-  elif test -d "$srcdir/helpers/log_daemon/$helper" ; then
-    AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
-  fi
-done
-AC_MSG_NOTICE([Log daemon helpers built: $LOG_DAEMON_HELPERS])
-AC_SUBST(LOG_DAEMON_HELPERS)
+m4_include([helpers/log_daemon/modules.m4])
 
 dnl
 dnl Check Kerberos/GSSAPI/SPNEGO
@@ -2080,33 +1936,7 @@ AC_ARG_ENABLE(external-acl-helpers,
                   directory]), [
 #nothing to do, really
 ])
-if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],
-    [enable_external_acl_helpers])
-fi
-if test "x$enable_external_acl_helpers" = "xnone" ; then
-  enable_external_acl_helpers=""
-fi
-EXTERNAL_ACL_HELPERS=""
-enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_external_acl_helpers" != "xno" ; then
-  for helper in $enable_external_acl_helpers ; do
-    dir="$srcdir/helpers/external_acl/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xkerberos_ldap_group" ; then
-        squid_require_sasl=yes
-      fi
-    else
-      AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
-    fi
-  done
-fi
-AC_MSG_NOTICE([External acl helpers built: $EXTERNAL_ACL_HELPERS])
-AC_SUBST(EXTERNAL_ACL_HELPERS)
-
-
+m4_include([helpers/external_acl/modules.m4])
 
 dnl Select url_rewrite helpers to build
 AC_ARG_ENABLE(url-rewrite-helpers,
@@ -2118,28 +1948,7 @@ AC_ARG_ENABLE(url-rewrite-helpers,
                   For a list of available helpers see the
                   helpers/url_rewrite directory.]),[
 ])
-if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],
-                           [enable_url_rewrite_helpers])
-fi
-enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
-URL_REWRITE_HELPERS=""
-if test "x$enable_url_rewrite_helpers" != "xno" ; then
-  for helper in $enable_url_rewrite_helpers; do
-    dir="$srcdir/helpers/url_rewrite/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $helper"
-    elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-      AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
-    else
-      AC_MSG_NOTICE([URL rewrite helper $helper ... not found])
-    fi
-  done
-fi
-AC_MSG_NOTICE([URL rewrite helpers built: $URL_REWRITE_HELPERS])
-AC_SUBST(URL_REWRITE_HELPERS)
-
+m4_include([helpers/url_rewrite/modules.m4])
 
 AC_ARG_WITH(valgrind-debug,
   AS_HELP_STRING([--with-valgrind-debug],
@@ -2184,27 +1993,6 @@ SQUID_DEFINE_BOOL(USE_WIN32_SERVICE,${enable_win32_service:=no},
 AC_MSG_NOTICE([MS Windows service mode enabled: $enable_win32_service])
 
 
-# Check for Cyrus SASL
-if test "x$squid_require_sasl" = "xyes"; then
-  AC_CHECK_HEADERS(sasl/sasl.h sasl.h)
-  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
-    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
-      AC_MSG_ERROR(Neither SASL nor SASL2 found)
-    ])
-  ])
-  case "$squid_host_os" in
-    Darwin)
-      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
-        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
-        echo "checking for MAC Darwin without sasl.h ... yes"
-      else
-        echo "checking for MAC Darwin without sasl.h ... no"
-      fi
-      ;;
-  esac
-  AC_SUBST(LIBSASL)
-fi
-
 # Disable "unlinkd" code
 AC_ARG_ENABLE(unlinkd,
   AS_HELP_STRING([--disable-unlinkd],[Do not use unlinkd]), [
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.10 release notes</title>
+<title>Squid 3.2.11 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.10.
+The Squid Team are pleased to announce the release of Squid-3.2.11.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -7,7 +7,7 @@ EXTRA_DIST= \
 	basic_db_auth.8 \
 	passwd.sql \
 	basic_db_auth.pl.in \
-	config.test
+	required.m4
 
 basic_db_auth.8: basic_db_auth
 	pod2man basic_db_auth basic_db_auth.8
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 	= basic_ldap_auth
 man_MANS 		= basic_ldap_auth.8
-EXTRA_DIST		= basic_ldap_auth.8 config.test
+EXTRA_DIST		= basic_ldap_auth.8 required.m4
 basic_ldap_auth_SOURCES	= basic_ldap_auth.cc
 
 LDADD = \
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_msnt_multi_domain_auth
-EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt config.test
+EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt required.m4
 CLEANFILES += basic_msnt_multi_domain_auth
 
 basic_msnt_multi_domain_auth: basic_msnt_multi_domain_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="MSNT-multi-domain"
@@ -19,7 +19,7 @@ EXTRA_DIST = \
 	msntauth.conf.default \
 	msntauth-v2.0.lsm \
 	README.html \
-	config.test
+	required.m4
 
 sysconf_DATA = \
 	msntauth.conf.default
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Don't build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 1
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 1
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 1
-fi
-exit 0
@@ -0,0 +1,5 @@
+#
+# DONT build this helper on Windows
+#
+BUILD_HELPER="MSNT"
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
@@ -16,3 +16,5 @@ DIST_SUBDIRS = \
 	SSPI
 
 SUBDIRS	= $(BASIC_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
@@ -3,7 +3,7 @@ include $(top_srcdir)/src/Common.am
 libexec_PROGRAMS	= basic_ncsa_auth
 basic_ncsa_auth_SOURCES	= basic_ncsa_auth.cc crypt_md5.cc crypt_md5.h
 man_MANS 		= basic_ncsa_auth.8
-EXTRA_DIST		= basic_ncsa_auth.8 config.test
+EXTRA_DIST		= basic_ncsa_auth.8 required.m4
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="NCSA"
@@ -16,4 +16,4 @@ basic_nis_auth_LDADD = \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/rpcsvc/yp_prot.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([rpcsvc/yp_prot.h],[BUILD_HELPER="NIS"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 man_MANS		= basic_pam_auth.8
-EXTRA_DIST		= basic_pam_auth.8 config.test
+EXTRA_DIST		= basic_pam_auth.8 required.m4
 libexec_PROGRAMS	= basic_pam_auth
 basic_pam_auth_SOURCES	= basic_pam_auth.cc
 
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/security/pam_appl.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([security/pam_appl.h],[BUILD_HELPER="PAM"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_pop3_auth
-EXTRA_DIST = basic_pop3_auth.pl.in config.test
+EXTRA_DIST = basic_pop3_auth.pl.in required.m4
 CLEANFILES += basic_pop3_auth
 
 basic_pop3_auth: basic_pop3_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="POP3"
@@ -5,7 +5,7 @@ INCLUDES += -I$(srcdir)
 
 libexec_PROGRAMS 	= basic_radius_auth
 man_MANS 		= basic_radius_auth.8
-EXTRA_DIST		= basic_radius_auth.8 config.test
+EXTRA_DIST		= basic_radius_auth.8 required.m4
 basic_radius_auth_SOURCES = \
 			basic_radius_auth.cc \
 			radius.h \
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="RADIUS"
@@ -13,4 +13,4 @@ EXTRA_DIST = \
 	basic_sasl_auth.8 \
 	basic_sasl_auth.conf \
 	basic_sasl_auth.pam \
-	config.test
+	required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/sasl.h -o -f /usr/local/include/sasl.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/sasl/sasl.h -o -f /usr/local/include/sasl/sasl.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,6 @@
+SQUID_CHECK_SASL
+
+# on success, add to the built modules list
+if test "x$squid_check_sasl" = "xyes"; then
+  BUILD_HELPER="SASL"
+fi
@@ -11,4 +11,4 @@ basic_smb_auth_LDADD = \
 		$(COMPAT_LIB) \
 		$(XTRA_LIBS)
 
-EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 config.test
+EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 required.m4
@@ -1,10 +0,0 @@
-#!/bin/sh
-for prefix in /usr/local /opt /opt/samba /usr/local/samba /usr
-do
-    if [ -x ${prefix}/bin/smbclient ]; then
-        exit 0
-    fi
-done
-echo "WARNING: Samba smbclient not found in default location. basic_smb_auth may not work on this machine"
-# allow script install anyway.
-exit 0
@@ -0,0 +1,10 @@
+#
+# The shell script helper require smbclient to be in the environment PATH.
+# We can install anyway, but warn if smbclient not found already
+#
+AC_PATH_PROG(SMBCLIENT, smbclient)
+if test "x$SMBCLIENT" = "x"; then
+  AC_MSG_WARN([Samba smbclient not found in default location. basic_smb_auth may not work on this machine])
+fi
+# allow script install anyway.
+BUILD_HELPER="SMB"
@@ -20,4 +20,4 @@ basic_sspi_auth_LDADD = \
 	$(XTRA_LIBS)
 
 man_MANS = basic_sspi_auth.8
-EXTRA_DIST = basic_sspi_auth.8 config.test
+EXTRA_DIST = basic_sspi_auth.8 required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-	exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -5,4 +5,4 @@ basic_fake_auth_SOURCES = fake.cc
 
 LDADD = $(COMPAT_LIB)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -10,4 +10,4 @@ basic_getpwnam_auth_LDADD = \
 
 man_MANS = basic_getpwnam_auth.8
 
-EXTRA_DIST = basic_getpwnam_auth.8 config.test
+EXTRA_DIST = basic_getpwnam_auth.8 required.m4
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/pwd.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="getpwnam"])
@@ -0,0 +1,92 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_basic list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_basic" = "x"; then
+    enable_auth_basic=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Basic auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_basic" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
+fi
+#handle the "none" special case
+if test "x$enable_auth_basic" = "xnone" ; then
+    enable_auth_basic=""
+fi
+
+BASIC_AUTH_HELPERS=""
+#enable_auth_basic contains either "no" or the list of modules to be built
+enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_basic" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES basic"
+    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
+    for helper in $enable_auth_basic; do
+      dir="$srcdir/helpers/basic_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xDB" ; then
+        m4_include([helpers/basic_auth/DB/required.m4])
+
+      elif test "x$helper" = "xLDAP" ; then
+        m4_include([helpers/basic_auth/LDAP/required.m4])
+
+      elif test "x$helper" = "xMSNT-multi-domain" ; then
+        m4_include([helpers/basic_auth/MSNT-multi-domain/required.m4])
+
+      elif test "x$helper" = "xMSNT" ; then
+        m4_include([helpers/basic_auth/MSNT/required.m4])
+
+      elif test "x$helper" = "xNCSA" ; then
+        m4_include([helpers/basic_auth/NCSA/required.m4])
+
+      elif test "x$helper" = "xNIS" ; then
+        m4_include([helpers/basic_auth/NIS/required.m4])
+
+      elif test "x$helper" = "xPOP3" ; then
+        m4_include([helpers/basic_auth/POP3/required.m4])
+
+      elif test "x$helper" = "xRADIUS" ; then
+        m4_include([helpers/basic_auth/RADIUS/required.m4])
+
+      elif test "x$helper" = "xSASL" ; then
+        m4_include([helpers/basic_auth/SASL/required.m4])
+
+      elif test "x$helper" = "xSMB" ; then
+        m4_include([helpers/basic_auth/SMB/required.m4])
+
+      elif test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/basic_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xfake" ; then
+        m4_include([helpers/basic_auth/fake/required.m4])
+
+      elif test "x$helper" = "xgetpwnam" ; then
+        m4_include([helpers/basic_auth/getpwnam/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/basic_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
+        else
+          BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Basic auth helper $helper ... not found])
+      fi
+    done
+fi
+
+AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
+AC_SUBST(BASIC_AUTH_HELPERS)
@@ -18,4 +18,4 @@ digest_ldap_auth_LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -5,3 +5,5 @@ DIST_SUBDIRS= \
 	LDAP
 
 SUBDIRS= $(DIGEST_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
@@ -21,4 +21,4 @@ digest_edirectory_auth_LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -18,4 +18,4 @@ LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = digest_file_auth.8 config.test
+EXTRA_DIST = digest_file_auth.8 required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="file"
@@ -0,0 +1,60 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_digest list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_digest" = "x"; then
+    enable_auth_digest=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Digest auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_digest" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
+fi
+#handle the "none" special case
+if test "x$enable_auth_digest" = "xnone" ; then
+    enable_auth_digest=""
+fi
+
+DIGEST_AUTH_HELPERS=""
+enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_digest" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES digest"
+    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
+    for helper in $enable_auth_digest; do
+      dir="$srcdir/helpers/digest_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xLDAP" ; then
+        m4_include([helpers/digest_auth/LDAP/required.m4])
+
+      elif test "x$helper" = "xeDirectory" ; then
+        m4_include([helpers/digest_auth/eDirectory/required.m4])
+
+      elif test "x$helper" = "xfile" ; then
+        m4_include([helpers/digest_auth/file/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/digest_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
+        else
+          DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Digest auth helper $helper ... not found])
+      fi
+    done
+fi
+AC_MSG_NOTICE([Digest auth helpers to be built: $DIGEST_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
+AC_SUBST(DIGEST_AUTH_HELPERS)
@@ -8,6 +8,7 @@ man_MANS = ext_ad_group_acl.8
 # Currently activeds and adsiid libraries are not available on MinGW or Cygwin,
 # so the following library list is just a placeholder for future MinGW/Cygwin releases.
 # This helper can be compiled only using Microsoft Visual Studio.
+# TODO: test for these libraries in required.m4
 #
 LDADD = \
 	$(COMPAT_LIB) \
@@ -20,4 +21,4 @@ LDADD = \
 	-ladsiid \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test ext_ad_group_acl.8
+EXTRA_DIST = required.m4 ext_ad_group_acl.8
@@ -1,12 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/w32api/dsrole.h ]; then
-  if grep -q DsRoleGetPrimaryDomainInformation /usr/include/w32api/dsrole.h; then
-	  exit 0
-	fi
-fi
-if [ -f /usr/include/dsrole.h ]; then
-  if grep -q DsRoleGetPrimaryDomainInformation /usr/include/dsrole.h; then
-	  exit 0
-  fi
-fi
-exit 1
@@ -0,0 +1,6 @@
+#
+## TODO: make a AC_COMPILE check instead
+#
+for hdr in w32api/dsrole.h dsrole.h; do
+  AC_EGREP_HEADER(/usr/include/$hdr,[DsRoleGetPrimaryDomainInformation],[BUILD_HELPER="AD_group"])
+done
@@ -4,7 +4,7 @@ libexec_PROGRAMS 		= ext_ldap_group_acl
 ext_ldap_group_acl_SOURCES	= ext_ldap_group_acl.cc
 
 man_MANS 			= ext_ldap_group_acl.8
-EXTRA_DIST			= ext_ldap_group_acl.8 config.test
+EXTRA_DIST			= ext_ldap_group_acl.8 required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP_group"])
@@ -12,4 +12,4 @@ LDADD = \
 
 man_MANS = ext_lm_group_acl.8
 
-EXTRA_DIST = config.test ext_lm_group_acl.8
+EXTRA_DIST = required.m4 ext_lm_group_acl.8
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="LM_group"])
@@ -6,7 +6,7 @@ man_MANS = ext_sql_session_acl.8
 EXTRA_DIST= \
 	ext_sql_session_acl.8 \
 	ext_sql_session_acl.pl.in \
-	config.test
+	required.m4
 
 ext_sql_session_acl.8: ext_sql_session_acl
 	pod2man ext_sql_session_acl ext_sql_session_acl.8
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="SQL_session"
+fi
@@ -13,4 +13,4 @@ ext_edirectory_userip_acl_LDADD = \
 
 man_MANS = ext_edirectory_userip_acl.8
 
-EXTRA_DIST = config.test ext_edirectory_userip_acl.8
+EXTRA_DIST = required.m4 ext_edirectory_userip_acl.8
@@ -1,9 +0,0 @@
-#!/bin/sh
-
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="eDirectory_userip"])
@@ -8,7 +8,7 @@ EXTRA_DIST = \
 	example.conf \
 	example-deny_all_but.conf \
 	ext_file_userip_acl.8 \
-	config.test
+	required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/sys/socket.h ]; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([sys/socket.h],[BUILD_HELPER="file_userip"])
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README config.test cert_tool ext_kerberos_ldap_group_acl.8
+EXTRA_DIST = README required.m4 cert_tool ext_kerberos_ldap_group_acl.8
 SUBDIRS = 
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
@@ -1,23 +0,0 @@
-#!/bin/sh
-# Don't build without gssapi.h
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	# Won't link without SASL as well
-	if [ -f /usr/include/sasl.h -o -f /usr/include/sasl/sasl.h -o -f /usr/local/include/sasl.h -o -f /usr/local/include/sasl/sasl.h ]; then
-		if [ -f /usr/lib/libsasl.a -o -f /usr/lib/libsasl2.a ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib/libsasl.la -o -f /usr/lib/libsasl2.la ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib/libsasl.so -o -f /usr/lib/libsasl2.so ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib64/libsasl.so -o -f /usr/lib64/libsasl2.so ]; then
-			exit 0
-		fi
-		if [ -f  /usr/local/lib/libsasl.so -o -f  /usr/local/lib/libsasl2.so ]; then
-			exit 0
-		fi
-	fi
-fi
-exit 1
@@ -425,6 +425,7 @@ main(int argc, char *const argv[])
             dp = xstrdup(rfc1738_escape(domain));
         if (!domain && margs.ddomain) {
             domain = xstrdup(margs.ddomain);
+            dp = xstrdup(rfc1738_escape(domain));
             if (debug_enabled)
                 debug((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, up, dp);
             else
@@ -0,0 +1,2 @@
+AC_CHECK_HEADERS([ldap.h],[BUILD_HELPER="kerberos_ldap_group"])
+SQUID_CHECK_SASL
@@ -0,0 +1,71 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_external_acl_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],[enable_external_acl_helpers])
+fi
+if test "x$enable_external_acl_helpers" = "xnone" ; then
+  enable_external_acl_helpers=""
+fi
+EXTERNAL_ACL_HELPERS=""
+enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_external_acl_helpers" != "xno" ; then
+  for helper in $enable_external_acl_helpers ; do
+    dir="$srcdir/helpers/external_acl/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xAD_group" ; then
+        m4_include([helpers/external_acl/AD_group/required.m4])
+
+      elif test "x$helper" = "xLDAP_group" ; then
+        m4_include([helpers/external_acl/LDAP_group/required.m4])
+
+      elif test "x$helper" = "xLM_group" ; then
+        m4_include([helpers/external_acl/LM_group/required.m4])
+
+      elif test "x$helper" = "xSQL_session" ; then
+        m4_include([helpers/external_acl/SQL_session/required.m4])
+
+      elif test "x$helper" = "xeDirectory_userip" ; then
+        m4_include([helpers/external_acl/eDirectory_userip/required.m4])
+
+      elif test "x$helper" = "xfile_userip" ; then
+        m4_include([helpers/external_acl/file_userip/required.m4])
+
+      elif test "x$helper" = "xkerberos_ldap_group" ; then
+        m4_include([helpers/external_acl/kerberos_ldap_group/required.m4])
+
+      elif test "x$helper" = "xsession" ; then
+        m4_include([helpers/external_acl/session/required.m4])
+
+      elif test "x$helper" = "xtime_quota" ; then
+        m4_include([helpers/external_acl/time_quota/required.m4])
+
+      elif test "x$helper" = "xunix_group" ; then
+        m4_include([helpers/external_acl/unix_group/required.m4])
+
+      elif test "x$helper" = "xwbinfo_group" ; then
+        m4_include([helpers/external_acl/wbinfo_group/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/external_acl/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
+        else
+          EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([external acl helper $helper ... not found])
+      fi
+  done
+fi
+AC_MSG_NOTICE([External acl helpers to be built: $EXTERNAL_ACL_HELPERS])
+AC_SUBST(EXTERNAL_ACL_HELPERS)
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_session_acl
 man_MANS 			= ext_session_acl.8
-EXTRA_DIST			= ext_session_acl.8 config.test
+EXTRA_DIST			= ext_session_acl.8 required.m4
 ext_session_acl_SOURCES		= ext_session_acl.cc
 
 LDADD = \
@@ -1,6 +0,0 @@
-#!/bin/sh
-
-if [ -f /usr/include/db.h ] && grep db_env_create /usr/include/db.h; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_EGREP_HEADER(/usr/include/db.h,db_env_create,[BUILD_HELPER="session"])
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_time_quota_acl
 man_MANS 			= ext_time_quota_acl.8
-EXTRA_DIST			= ext_time_quota_acl.8 config.test
+EXTRA_DIST			= ext_time_quota_acl.8 required.m4
 ext_time_quota_acl_SOURCES	= ext_time_quota_acl.cc
 
 DEFS += -DDEFAULT_QUOTA_DB=\"$(localstatedir)/ext_time_quota.db\" 
@@ -1,10 +0,0 @@
-#!/bin/sh
-
-# Actual intended test
-if [ -f /usr/include/db_185.h ]; then
-    exit 0
-fi
-if [ -f /usr/include/db.h ] && grep dbopen /usr/include/db.h; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1,2 @@
+AC_CHECK_HEADERS([db_185.h],[BUILD_HELPER="time_quota"])
+AC_EGREP_HEADER(/usr/include/db.h,dbopen,[BUILD_HELPER="time_quota"])
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_unix_group_acl
 man_MANS 			= ext_unix_group_acl.8
-EXTRA_DIST			= ext_unix_group_acl.8 config.test
+EXTRA_DIST			= ext_unix_group_acl.8 required.m4
 ext_unix_group_acl_SOURCES	= check_group.cc
 
 LDADD = \
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/pwd.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="unix_group"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS = ext_wbinfo_group_acl
-EXTRA_DIST	= ext_wbinfo_group_acl.pl.in config.test
+EXTRA_DIST	= ext_wbinfo_group_acl.pl.in required.m4
 
 ext_wbinfo_group_acl: ext_wbinfo_group_acl.pl.in
 	$(subst_perlshell)
@@ -1,18 +0,0 @@
-#!/bin/sh
-samba_found="no"
-for sambaprefix in /usr/local /opt /opt/samba /usr/local/samba /usr
-do
-    if [ -x $sambaprefix/bin/wbinfo ]; then
-      samba_found="yes"
-    fi
-done
-if test "$samba_found" = "no"; then
-    echo "WARNING: Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine"
-fi
-for perlprefix in /usr /usr/local /opt /opt/perl
-do
-    if [ -x $perlprefix/bin/perl ]; then
-        exit 0
-    fi
-done
-exit 1
@@ -0,0 +1,13 @@
+#
+# The shell script helper requires wbinfo to be in the environment PATH.
+# We can install anyway, but warn if the tool is missing
+#
+AC_PATH_PROG(WBINFO, wbinfo)
+if test "x$WBINFO" = "x"; then
+  AC_MSG_WARN([Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine])
+fi
+
+# allow script install anyway when perl is present
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="wbinfo_group"
+fi
@@ -4,7 +4,7 @@ libexec_SCRIPTS	= log_db_daemon
 CLEANFILES += log_db_daemon log_db_daemon.8
 man_MANS = log_db_daemon.8
 EXTRA_DIST= \
-	config.test \
+	required.m4 \
 	doc/views.sql \
 	doc/date_day_column.sql \
 	log_db_daemon.8 \
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
@@ -4,3 +4,4 @@ DIST_SUBDIRS = \
 	file
 
 SUBDIRS	= $(LOG_DAEMON_HELPERS)
+EXTRA_DIST = modules.m4
@@ -5,4 +5,4 @@ log_file_daemon_SOURCES = log_file_daemon.cc
 log_file_daemon_LDADD = \
 	-L$(top_builddir)/lib $(COMPAT_LIB) \
 	$(XTRA_LIBS)
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="file"
@@ -0,0 +1,43 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $squid_opt_logdaemon_helpers list containing double entries.
+
+#define list of modules to build
+if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
+  squid_opt_logdaemon_helpers=""
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[squid_opt_logdaemon_helpers])
+fi
+
+LOG_DAEMON_HELPERS=""
+squid_opt_logdaemon_helpers="`echo $squid_opt_logdaemon_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$squid_opt_logdaemon_helpers" = "x"; then
+  for helper in $squid_opt_logdaemon_helpers ; do
+    dir="$srcdir/helpers/log_daemon/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xDB" ; then
+      m4_include([helpers/log_daemon/DB/required.m4])
+
+    elif test "x$helper" = "xfile" ; then
+      m4_include([helpers/log_daemon/file/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/log_daemon/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
+      else
+       LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([Log daemon helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([Log daemon helpers to be built: $LOG_DAEMON_HELPERS])
+AC_SUBST(LOG_DAEMON_HELPERS)
@@ -10,4 +10,4 @@ LDADD	= \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = readme.txt config.test
+EXTRA_DIST = readme.txt required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README COPYING config.test negotiate_kerberos_auth.8
+EXTRA_DIST = README COPYING required.m4 negotiate_kerberos_auth.8
 SUBDIRS = 
 
 libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
@@ -1,6 +0,0 @@
-#!/bin/sh
-# Don't build without gssapi.h
-if test -f /usr/include/gssapi/gssapi.h || test -f  /usr/include/gssapi.h || test -f /usr/include/kerberosV/gssapi.h ; then
-       exit 0
-fi
-exit 1
@@ -0,0 +1,2 @@
+# FIXME: use other kerberos library checks from main configure.ac
+AC_CHECK_HEADERS([gssapi/gssapi.h gssapi.h kerberosV/gssapi.h],[BUILD_HELPER="kerberos"])
@@ -0,0 +1,61 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_negotiate list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_negotiate" = "x"; then
+    enable_auth_negotiate=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_negotiate" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
+fi
+#handle the "none" special case
+if test "x$enable_auth_negotiate" = "xnone" ; then
+    enable_auth_negotiate=""
+fi
+
+NEGOTIATE_AUTH_HELPERS=""
+enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_negotiate" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES negotiate"
+    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
+    for helper in $enable_auth_negotiate; do
+      dir="$srcdir/helpers/negotiate_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/negotiate_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xkerberos" ; then
+        m4_include([helpers/negotiate_auth/kerberos/required.m4])
+
+      elif test "x$helper" = "xwrapper" ; then
+        m4_include([helpers/negotiate_auth/wrapper/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/negotiate_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
+        else
+          NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Negotiate auth helper $helper ... not found])
+      fi
+    done
+fi
+
+AC_MSG_NOTICE([Negotiate auth helpers to be built: $NEGOTIATE_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
+AC_SUBST(NEGOTIATE_AUTH_HELPERS)
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 
 libexec_PROGRAMS = negotiate_wrapper_auth
 
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="wrapper"
@@ -1,2 +1,3 @@
 DIST_SUBDIRS	= fake smb_lm SSPI
 SUBDIRS		= $(NTLM_AUTH_HELPERS)
+EXTRA_DIST	= modules.m4
@@ -14,4 +14,4 @@ LDADD = \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = ntlm_sspi_auth.8 config.test
+EXTRA_DIST = ntlm_sspi_auth.8 required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -16,5 +16,5 @@ INCLUDES += -I$(top_srcdir)/lib
 ## ntlm_fake_auth.pl: ntlm_fake_auth.pl.in
 ##	$(subst_perlshell)
 
-EXTRA_DIST = config.test \
+EXTRA_DIST = required.m4 \
 	ntlm_fake_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -0,0 +1,61 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_ntlm list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_ntlm" = "x"; then
+    enable_auth_ntlm=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([NTLM auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_ntlm" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
+fi
+#handle the "none" special case
+if test "x$enable_auth_ntlm" = "xnone" ; then
+    enable_auth_ntlm=""
+fi
+
+NTLM_AUTH_HELPERS=""
+#enable_auth_ntlm contains either "no" or the list of modules to be built
+enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_ntlm" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES ntlm"
+    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
+    for helper in $enable_auth_ntlm; do
+      dir="$srcdir/helpers/ntlm_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xfake" ; then
+        m4_include([helpers/ntlm_auth/fake/required.m4])
+
+      elif test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/ntlm_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xsmb_lm" ; then
+        m4_include([helpers/ntlm_auth/smb_lm/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/ntlm_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
+        else
+          NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([NTLM auth helper $helper ... not found])
+      fi
+    done
+fi
+AC_MSG_NOTICE([NTLM auth helpers to be built: $NTLM_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
+AC_SUBST(NTLM_AUTH_HELPERS)
@@ -14,4 +14,4 @@ ntlm_smb_lm_auth_LDADD = \
 
 INCLUDES += -I$(top_srcdir)/lib
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Don't build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 1
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 1
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 1
-fi
-exit 0
@@ -0,0 +1,8 @@
+#
+# DONT build this helper on Windows
+#
+# XXX: do we really need the mingw check?
+if test "$squid_host_os" != "mingw"; then
+  BUILD_HELPER="smb_lm"
+  AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
+fi
@@ -7,4 +7,4 @@ url_fake_rewrite_LDADD = $(COMPAT_LIB)
 
 libexec_SCRIPTS = url_fake_rewrite.sh
 
-EXTRA_DIST = url_fake_rewrite.sh config.test
+EXTRA_DIST = url_fake_rewrite.sh required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -0,0 +1,40 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_url_rewrite_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],[enable_url_rewrite_helpers])
+fi
+
+enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
+URL_REWRITE_HELPERS=""
+if test "x$enable_url_rewrite_helpers" != "xno" ; then
+  for helper in $enable_url_rewrite_helpers; do
+    dir="$srcdir/helpers/url_rewrite/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfake" ; then
+      m4_include([helpers/url_rewrite/fake/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/url_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
+      else
+        URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([URL rewrite helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([URL rewrite helpers to be built: $URL_REWRITE_HELPERS])
+AC_SUBST(URL_REWRITE_HELPERS)
@@ -32,7 +32,7 @@
 #ifndef SQUID_STACK_H
 #define SQUID_STACK_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* RBC: 20030714 Composition might be better long-term, but for now,
  * there's no reason to do so.
@@ -1,8 +1,7 @@
 #ifndef SQUID_SPLAY_H
 #define SQUID_SPLAY_H
 
-#ifndef __cplusplus
-#else
+#if defined(__cplusplus)
 
 #include "Stack.h"
 
@@ -78,8 +78,6 @@ TESTS += tests/testAll
 check_PROGRAMS += tests/testAll
 
 tests_testAll_SOURCES= \
-	tests/testArray.h \
-	tests/testArray.cc \
 	tests/testRFC1035.h \
 	tests/testRFC1035.cc \
 	tests/testRFC1738.h \
@@ -1,7 +1,7 @@
 # Process this file with autoconf to produce a configure script.
 AC_INIT(libTrie, 0.1, rbtcollins@squid-cache.org)
 AC_CONFIG_SRCDIR([src/Trie.cc])
-AM_CONFIG_HEADER([config.h])
+AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_AUX_DIR(cfgaux)
 
 enable_inline=${enable_inline:=yes}
@@ -1,22 +0,0 @@
-#define SQUID_UNIT_TEST 1
-#include "squid.h"
-
-#if HAVE_ASSERT_H
-#include <assert.h>
-#endif
-
-#include "testArray.h"
-#include "Array.h"
-
-CPPUNIT_TEST_SUITE_REGISTRATION( testArray );
-
-void testArray::all()
-{
-    CPPUNIT_ASSERT( 1 == 1 );
-    Vector<int> aArray;
-    CPPUNIT_ASSERT (aArray.size() == 0);
-    aArray.push_back(2);
-    CPPUNIT_ASSERT (aArray.size() == 1);
-    CPPUNIT_ASSERT (aArray.back() == 2);
-    CPPUNIT_ASSERT (aArray.size() == 1);
-}
@@ -23,9 +23,9 @@
 		'AsyncCall.* constructed, this=(\S+)',
 		'AsyncCall.* destruct.*, this=(\S+)',
 	],
-	HttpReq => [
-		'\bHttpRequest.* constructed, this=(\S+)',
-		'\bHttpRequest.* destructed, this=(\S+)',
+	HttpHeaderEntry => [
+		'\bHttpHeaderEntry.* created HttpHeaderEntry (\S+)',
+		'\bHttpHeaderEntry.* destroying entry (\S+)',
 	],
 	ClientSocketContext => [
 		'\bClientSocketContext constructing, this=(\S+)',
@@ -37,7 +37,6 @@ AccessLogEntry::~AccessLogEntry()
 #endif
 
     safe_free(headers.reply);
-    safe_free(cache.authuser);
 
     safe_free(headers.adapted_request);
     HTTPMSGUNLOCK(adapted_request);
@@ -153,7 +153,6 @@ class AccessLogEntry: public RefCountable
                 code (LOG_TAG_NONE),
                 msec(0),
                 rfc931 (NULL),
-                authuser (NULL),
                 extuser(NULL),
 #if USE_SSL
                 ssluser(NULL),
@@ -172,7 +171,6 @@ class AccessLogEntry: public RefCountable
         LogTags code;
         int msec;
         const char *rfc931;
-        const char *authuser;
         const char *extuser;
 #if USE_SSL
 
@@ -1,8 +1,9 @@
 #ifndef SQUID_CLIENTDELAYCONFIG_H
 #define SQUID_CLIENTDELAYCONFIG_H
 
-#include "Array.h"
 #include "acl/forward.h"
+#include "base/Vector.h"
+
 class StoreEntry;
 class ConfigParser;
 
@@ -30,8 +30,7 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-/* for Vector<> */
-#include "Array.h"
+#include "base/Vector.h"
 
 class StoreEntry;
 
@@ -4,7 +4,7 @@
 #ifndef SQUID_CPU_AFFINITY_MAP_H
 #define SQUID_CPU_AFFINITY_MAP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 class CpuAffinitySet;
 
@@ -32,6 +32,12 @@
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
+#include "base/Vector.h"
+
+class DelayPool;
+class Updateable;
+class StoreEntry;
+
 /**
  \defgroup DelayPoolsAPI Delay Pools API
  \ingroup Components
@@ -47,14 +53,6 @@ class Updateable
     virtual void update(int) = 0;
 };
 
-/* forward decls */
-class DelayPool;
-class Updateable;
-class StoreEntry;
-
-/* for Vector<> */
-#include "Array.h"
-
 /// \ingroup DelayPoolsAPI
 class DelayPools
 {
@@ -41,7 +41,7 @@
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -42,7 +42,7 @@
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -32,7 +32,7 @@
 #ifndef SQUID_DISKIOMODULE_H
 #define SQUID_DISKIOMODULE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* forward decls */
 
@@ -31,7 +31,7 @@
 #ifndef SQUID_EVENTLOOP_H
 #define SQUID_EVENTLOOP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
@@ -1,7 +1,7 @@
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /// Counts events, forgetting old ones. Usefull for "3 errors/minute" limits.
 class FadingCounter
@@ -185,7 +185,7 @@ operator <<(std::ostream &os, const HelperReply &r)
     // dump the helper key=pair "notes" list
     if (!r.notes.empty()) {
         os << ", notes={";
-	os << r.notes.toString("; ");
+        os << r.notes.toString("; ");
         os << "}";
     }
 
@@ -441,6 +441,7 @@ HttpHeader::clean()
 
     PROF_start(HttpHeaderClean);
 
+    if (owner <= hoReply) {
     /*
      * An unfortunate bug.  The entries array is initialized
      * such that count is set to zero.  httpHeaderClean() seems to
@@ -451,27 +452,26 @@ HttpHeader::clean()
      * has been used.  As a hack, just never count zero-sized header
      * arrays.
      */
-
-    if (owner <= hoReply) {
         if (0 != entries.count)
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
 
         ++ HttpHeaderStats[owner].destroyedCount;
 
         HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
+    } // if (owner <= hoReply)
 
         while ((e = getEntry(&pos))) {
             /* tmp hack to try to avoid coredumps */
 
             if (e->id < 0 || e->id >= HDR_ENUM_END) {
                 debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
             } else {
+                if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
                 /* yes, this deletion leaves us in an inconsistent state */
                 delete e;
             }
         }
-    } // if (owner <= hoReply)
     entries.clean();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
@@ -1741,6 +1741,7 @@ httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
     storeAppendPrintf(e, "%2s\t %-5s\t %5s\t %6s\n",
                       "id", "#flds", "count", "%total");
     hs->hdrUCountDistr.dump(e, httpHeaderFldsPerHdrDumper);
+    storeAppendPrintf(e, "\n");
     dump_stat = NULL;
 }
 
@@ -1762,7 +1763,6 @@ httpHeaderStoreReport(StoreEntry * e)
 
     for (i = 1; i < HttpHeaderStatCount; ++i) {
         httpHeaderStatDump(HttpHeaderStats + i, e);
-        storeAppendPrintf(e, "%s\n", "<br>");
     }
 
     /* field stats for all messages */
@@ -32,7 +32,7 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "MemPool.h"
 #include "Packer.h"
 #include "Range.h"
@@ -590,7 +590,7 @@ HttpRequest::maybeCacheable()
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoofClientIp))
+    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))
         return false;
 
     switch (protocol) {
@@ -615,7 +615,6 @@ squid_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	$(DISK_LIBS) \
@@ -1090,6 +1089,7 @@ check_PROGRAMS+=\
 	tests/testURL \
 	tests/testConfigParser \
 	tests/testStatHist \
+	tests/testVector \
 	$(STORE_TESTS)
 
 ## NP: required to run the above list. check_PROGRAMS only builds the binaries...
@@ -1488,6 +1488,7 @@ tests_testCacheManager_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1582,7 +1583,6 @@ tests_testCacheManager_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -1591,6 +1591,7 @@ tests_testCacheManager_LDADD = \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
+	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
@@ -1724,6 +1725,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
@@ -1764,7 +1766,6 @@ tests_testDiskIO_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	libsquid.la \
@@ -1902,6 +1903,7 @@ tests_testEvent_SOURCES = \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1979,6 +1981,7 @@ tests_testEvent_SOURCES = \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2005,7 +2008,6 @@ tests_testEvent_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2145,6 +2147,7 @@ tests_testEventLoop_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
@@ -2225,6 +2228,7 @@ tests_testEventLoop_SOURCES = \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2251,7 +2255,6 @@ tests_testEventLoop_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2388,6 +2391,7 @@ tests_test_http_range_SOURCES = \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
@@ -2464,6 +2468,7 @@ tests_test_http_range_SOURCES = \
 	SwapDir.cc \
 	tests/test_http_range.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
@@ -2491,7 +2496,6 @@ tests_test_http_range_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2587,6 +2591,7 @@ tests_testHttpRequest_SOURCES = \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	BodyPipe.cc \
@@ -2678,6 +2683,7 @@ tests_testHttpRequest_SOURCES = \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -2769,7 +2775,6 @@ tests_testHttpRequest_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2902,6 +2907,7 @@ tests_testStore_SOURCES= \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -2950,7 +2956,6 @@ tests_testStore_LDADD= \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3021,7 +3026,6 @@ SWAP_TEST_DS =\
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3043,6 +3047,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
@@ -3176,7 +3181,6 @@ tests_testUfs_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3319,6 +3323,7 @@ tests_testRock_SOURCES = \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
@@ -3361,7 +3366,6 @@ tests_testRock_LDADD = \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
-	eui/libeui.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	base/libbase.la \
@@ -3390,6 +3394,7 @@ tests_testCoss_SOURCES = \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_pconn.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
@@ -3513,7 +3518,6 @@ tests_testCoss_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3648,6 +3652,7 @@ tests_testURL_SOURCES = \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -3868,6 +3873,21 @@ tests_testStatHist_LDADD = \
 	$(COMPAT_LIB)
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testVector_SOURCES = \
+	tests/testVector.cc \
+	tests/testMain.cc \
+	tests/testVector.h \
+	time.cc
+nodist_tests_testVector_SOURCES = \
+	$(TESTSOURCES)
+tests_testVector_LDADD= \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+tests_testVector_LDFLAGS = $(LIBADD_DL)
+tests_testVector_DEPENDENCIES = \
+	$(SQUID_CPPUNIT_LA)
+
 
 TESTS += testHeaders
 
@@ -154,7 +154,7 @@ NotePairs::find(const char *noteKey) const
 const char *
 NotePairs::toString(const char *sep) const
 {
-   static String value;
+    static String value;
     value.clean();
     for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         value.append((*i)->name);
@@ -188,7 +188,7 @@ NotePairs::addStrList(const char *key, const char *values)
     const char *item;
     const char *pos = NULL;
     int ilen = 0;
-    while(strListGetItem(&strValues, ',', &item, &ilen, &pos)) {
+    while (strListGetItem(&strValues, ',', &item, &ilen, &pos)) {
         String v;
         v.append(item, ilen);
         entries.push_back(new NotePairs::Entry(key, v.termedBuf()));
@@ -2,7 +2,7 @@
 #define SQUID_NOTES_H
 
 #include "acl/forward.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "CbDataList.h"
 #include "MemPool.h"
@@ -113,9 +113,10 @@ class NotePairs: public RefCountable
     /**
      * Used to store a note key/value pair.
      */
-    class Entry {
+    class Entry
+    {
     public:
-        Entry(const char *aKey, const char *aValue): name(aKey), value(aValue) {} 
+        Entry(const char *aKey, const char *aValue): name(aKey), value(aValue) {}
         String name;
         String value;
         MEMPROXY_CLASS(Entry);
@@ -75,9 +75,9 @@ xatoi(const char *token)
 }
 
 unsigned int
-xatoui(const char *token)
+xatoui(const char *token, char eov)
 {
-    int64_t input = xatoll(token, 10);
+    int64_t input = xatoll(token, 10, eov);
     if (input < 0) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The input value '" << token << "' cannot be less than 0.");
         self_destruct();
@@ -107,7 +107,7 @@ xatol(const char *token)
 }
 
 int64_t
-xatoll(const char *token, int base)
+xatoll(const char *token, int base, char eov)
 {
     char *end = NULL;
     int64_t ret = strtoll(token, &end, base);
@@ -117,7 +117,7 @@ xatoll(const char *token, int base)
         self_destruct();
     }
 
-    if (*end) {
+    if (*end != eov) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid value: '" << token << "' is supposed to be a number.");
         self_destruct();
     }
@@ -38,9 +38,9 @@
 
 double xatof(const char *token);
 int xatoi(const char *token);
-unsigned int xatoui(const char *token);
+unsigned int xatoui(const char *token, char eov = '\0');
 long xatol(const char *token);
-int64_t xatoll(const char *token, int base);
+int64_t xatoll(const char *token, int base, char eov = '\0');
 unsigned short xatos(const char *token);
 
 /**
@@ -34,7 +34,7 @@
 #define   SQUID_PEERSELECTSTATE_H
 
 #include "acl/Checklist.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
@@ -87,7 +87,11 @@ class RequestFlags
     bool intercepted :1;
     /** set if the Host: header passed verification */
     bool hostVerified :1;
-    /** request to spoof the client ip */
+    /// Set for requests handled by a "tproxy" port.
+    bool interceptTproxy :1;
+    /// The client IP address should be spoofed when connecting to the web server.
+    /// This applies to TPROXY traffic that has not had spoofing disabled through
+    /// the spoof_client_ip squid.conf ACL.
     bool spoofClientIp :1;
     /** set if the request is internal (\see ClientHttpRequest::flags.internal)*/
     bool internal :1;
@@ -400,6 +400,10 @@ class SquidConfig
 #if ICAP_CLIENT
         acl_access* icap;
 #endif
+
+        /// spoof_client_ip squid.conf acl.
+        /// nil unless configured
+        acl_access* spoof_client_ip;
     } accessList;
     AclDenyInfoList *denyInfoList;
 
@@ -31,7 +31,7 @@
 #ifndef SQUID_STOREFILESYSTEM_H
 #define SQUID_STOREFILESYSTEM_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* ****** DOCUMENTATION ***** */
 
@@ -52,8 +52,9 @@ bool ACLFlags::supported(const ACLFlag f) const
 }
 
 void
-ACLFlags::parseFlags(char * &nextToken)
+ACLFlags::parseFlags()
 {
+    char *nextToken;
     while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
 
         //if token is the "--" break flag
@@ -275,8 +276,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
      */
     AclMatchedName = A->name;	/* ugly */
 
-    char *aTok;
-    A->flags.parseFlags(aTok);
+    A->flags.parseFlags();
 
     /*split the function here */
     A->parse();
@@ -34,7 +34,7 @@
 #define SQUID_ACL_H
 
 #include "acl/forward.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
@@ -69,8 +69,8 @@ class ACLFlags
     void makeSet(const ACLFlag f) { flags_ |= flagToInt(f); } ///< Set the given flag
     /// Return true if the given flag is set
     bool isSet(const ACLFlag f) const { return flags_ & flagToInt(f);}
-    /// Parse a flags given in the form -[A..Z|a..z]
-    void parseFlags(char * &nextToken);
+    /// Parse optional flags given in the form -[A..Z|a..z]
+    void parseFlags();
     const char *flagsStr() const; ///< Convert the flags to a string representation
 
 private:
@@ -56,7 +56,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
-    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
+    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.interceptTproxy)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -507,14 +507,9 @@ acl_ip_data::FactoryParse(const char *t)
 void
 ACLIP::parse()
 {
-    char *t = NULL;
+    flags.parseFlags();
 
-    flags.parseFlags(t);
-
-    if (!t)
-        return;
-
-    do {
+    while (char *t = strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
@@ -524,7 +519,7 @@ ACLIP::parse()
             data = data->insert(q, acl_ip_data::NetworkCompare);
             q = next_node;
         }
-    } while ((t = strtokFile()));
+    }
 }
 
 ACLIP::~ACLIP()
@@ -36,7 +36,7 @@
 #include "adaptation/History.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "HttpReply.h"
@@ -1,7 +1,7 @@
 #ifndef SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 #define SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -2,7 +2,7 @@
 #define SQUID_ADAPT_HISTORY_H
 
 #include "adaptation/DynamicGroupCfg.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "HttpHeader.h"
 #include "Notes.h"
@@ -2,7 +2,7 @@
 #define SQUID_ADAPTATION__SERVICE_GROUPS_H
 
 #include "SquidString.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
 #include "base/RefCount.h"
@@ -234,7 +234,7 @@ Adaptation::Ecap::XactionRep::start()
             if (v) {
                 if (ah->metaHeaders == NULL)
                     ah->metaHeaders = new NotePairs();
-                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), v)) 
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), v))
                     ah->metaHeaders->add((*i)->key.termedBuf(), v);
             }
         }
@@ -33,7 +33,7 @@
 #include "squid.h"
 #include "ConfigParser.h"
 #include "Store.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
@@ -17,7 +17,7 @@ icapLogOpen()
         if (log->type == Log::Format::CLF_NONE)
             continue;
 
-        log->logfile = logfileOpen(log->filename, MAX_URL << 1, 1);
+        log->logfile = logfileOpen(log->filename, log->bufferSize, log->fatal);
 
         IcapLogfileStatus = LOG_ENABLE;
     }
@@ -34,7 +34,7 @@ AuthenticateAcl(ACLChecklist *ch)
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoofClientIp) {
+    } else if (request->flags.intercepted || request->flags.interceptTproxy) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
@@ -33,7 +33,7 @@
 
 #if USE_AUTH
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 
 /**
@@ -22,4 +22,6 @@ libbase_la_SOURCES = \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	StringArea.h
+	StringArea.h \
+	Vector.cc \
+	Vector.h
@@ -38,7 +38,7 @@
  */
 
 #include "squid.h"
-#include "Array.h"
+#include "base/Vector.h"
 
 #if HAVE_ASSERT_H
 #include <assert.h>
@@ -181,6 +181,7 @@ static void parse_access_log(CustomLog ** customlog_definitions);
 static int check_null_access_log(CustomLog *customlog_definitions);
 static void dump_access_log(StoreEntry * entry, const char *name, CustomLog * definitions);
 static void free_access_log(CustomLog ** definitions);
+static bool setLogformat(CustomLog *cl, const char *name, const bool dieWhenMissing);
 
 static void update_maxobjsize(void);
 static void configDoConfigure(void);
@@ -301,14 +302,10 @@ update_maxobjsize(void)
 static void
 SetConfigFilename(char const *file_name, bool is_pipe)
 {
-    cfg_filename = file_name;
-
-    char const *token;
-
     if (is_pipe)
         cfg_filename = file_name + 1;
-    else if ((token = strrchr(cfg_filename, '/')))
-        cfg_filename = token + 1;
+    else
+        cfg_filename = file_name;
 }
 
 static const char*
@@ -529,7 +526,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
                 if ((token = strchr(new_file_name, '"')))
                     *token = '\0';
 
-                cfg_filename = new_file_name;
+                SetConfigFilename(new_file_name, false);
             }
 
             config_lineno = new_lineno;
@@ -599,7 +596,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
         fclose(fp);
     }
 
-    cfg_filename = orig_cfg_filename;
+    SetConfigFilename(orig_cfg_filename, false);
     config_lineno = orig_config_lineno;
 
     xfree(tmp_line);
@@ -1225,7 +1222,6 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
 }
 #endif
 
-#if USE_SSL
 /**
  * Parse bytes from a string.
  * Similar to the parseBytesLine function but parses the string value instead of
@@ -1261,7 +1257,6 @@ static void parseBytesOptionValue(size_t * bptr, const char *units, char const *
     if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2)
         self_destruct();
 }
-#endif
 
 static size_t
 parseBytesUnits(const char *unit)
@@ -3607,8 +3602,7 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         s->flags.tproxyIntercept = true;
         Ip::Interceptor.StartTransparency();
         /* Log information regarding the port modes under transparency. */
-        debugs(3, DBG_IMPORTANT, "Starting IP Spoofing on port " << s->s);
-        debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (IP spoofing enabled)");
+        debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (TPROXY enabled)");
 
         if (!Ip::Interceptor.ProbeForTproxy(s->s)) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: TPROXY support in the system does not work.");
@@ -3700,17 +3694,16 @@ parse_port_option(AnyP::PortCfg * s, char *token)
     } else if (strncmp(token, "tcpkeepalive=", 13) == 0) {
         char *t = token + 13;
         s->tcp_keepalive.enabled = true;
-        s->tcp_keepalive.idle = xatoui(t);
+        s->tcp_keepalive.idle = xatoui(t,',');
         t = strchr(t, ',');
         if (t) {
             ++t;
-            s->tcp_keepalive.interval = xatoui(t);
+            s->tcp_keepalive.interval = xatoui(t,',');
             t = strchr(t, ',');
         }
         if (t) {
             ++t;
             s->tcp_keepalive.timeout = xatoui(t);
-            // t = strchr(t, ','); // not really needed, left in as documentation
         }
 #if USE_SSL
     } else if (strcmp(token, "sslBump") == 0) {
@@ -4025,14 +4018,39 @@ strtokFile(void)
 
 #include "AccessLogEntry.h"
 
+/**
+ * We support several access_log configuration styles:
+ *
+ * #1: Deprecated ancient style without an explicit logging module:
+ * access_log /var/log/access.log
+ *
+ * #2: The "none" logging module (i.e., no logging [of matching transactions]):
+ * access_log none [acl ...]
+ *
+ * #3: Configurable logging module without named options:
+ * Logformat or the first ACL name, whichever comes first, may not contain '='.
+ * If no explicit logformat name is given, the first ACL name, if any,
+ * should not be an existing logformat name or it will be treated as such.
+ * access_log module:place [logformat_name] [acl ...]
+ *
+ * #4: Configurable logging module with name=value options such as logformat=x:
+ * The first ACL name may not contain '='.
+ * access_log module:place [option ...] [acl ...]
+ *
+ */
 static void
 parse_access_log(CustomLog ** logs)
 {
-    const char *filename, *logdef_name;
-
     CustomLog *cl = (CustomLog *)xcalloc(1, sizeof(*cl));
 
-    if ((filename = strtok(NULL, w_space)) == NULL) {
+    // default buffer size and fatal settings
+    cl->bufferSize = 8*MAX_URL;
+    cl->fatal = true;
+
+    /* determine configuration style */
+
+    const char *filename = strtok(NULL, w_space);
+    if (!filename) {
         self_destruct();
         return;
     }
@@ -4046,12 +4064,72 @@ parse_access_log(CustomLog ** logs)
         return;
     }
 
-    if ((logdef_name = strtok(NULL, w_space)) == NULL)
-        logdef_name = "squid";
+    cl->filename = xstrdup(filename);
+    cl->type = Log::Format::CLF_UNKNOWN;
+
+    const char *token = ConfigParser::strtokFile();
+    if (!token) { // style #1
+        // no options to deal with
+    } else if (!strchr(token, '=')) { // style #3
+        // if logformat name is not recognized,
+        // put back the token; it must be an ACL name
+        if (!setLogformat(cl, token, false))
+            ConfigParser::strtokFileUndo();
+    } else { // style #4
+        do {
+            if (strncasecmp(token, "on-error=", 9) == 0) {
+                if (strncasecmp(token+9, "die", 3) == 0) {
+                    cl->fatal = true;
+                } else if (strncasecmp(token+9, "drop", 4) == 0) {
+                    cl->fatal = false;
+                } else {
+                    debugs(3, DBG_CRITICAL, "Unknown value for on-error '" <<
+                           token << "' expected 'drop' or 'die'");
+                    self_destruct();
+                }
+            } else if (strncasecmp(token, "buffer-size=", 12) == 0) {
+                parseBytesOptionValue(&cl->bufferSize, B_BYTES_STR, token+12);
+            } else if (strncasecmp(token, "logformat=", 10) == 0) {
+                setLogformat(cl, token+10, true);
+            } else if (!strchr(token, '=')) {
+                // put back the token; it must be an ACL name
+                ConfigParser::strtokFileUndo();
+                break; // done with name=value options, now to ACLs
+            } else {
+                debugs(3, DBG_CRITICAL, "Unknown access_log option " << token);
+                self_destruct();
+            }
+        } while ((token = ConfigParser::strtokFile()) != NULL);
+    }
 
-    debugs(3, 9, "Log definition name '" << logdef_name << "' file '" << filename << "'");
+    // set format if it has not been specified explicitly
+    if (cl->type == Log::Format::CLF_UNKNOWN)
+        setLogformat(cl, "squid", true);
 
-    cl->filename = xstrdup(filename);
+    aclParseAclList(LegacyParser, &cl->aclList, cl->filename);
+
+    while (*logs)
+        logs = &(*logs)->next;
+
+    *logs = cl;
+}
+
+/// sets CustomLog::type and, if needed, CustomLog::lf
+/// returns false iff there is no named log format
+static bool
+setLogformat(CustomLog *cl, const char *logdef_name, const bool dieWhenMissing)
+{
+    assert(cl);
+    assert(logdef_name);
+
+    debugs(3, 9, "possible " << cl->filename << " logformat: " << logdef_name);
+
+    if (cl->type != Log::Format::CLF_UNKNOWN) {
+        debugs(3, DBG_CRITICAL, "Second logformat name in one access_log: " <<
+               logdef_name << " " << cl->type << " ? " << Log::Format::CLF_NONE);
+        self_destruct();
+        return false;
+    }
 
     /* look for the definition pointer corresponding to this name */
     Format::Format *lf = Log::TheConfig.logformats;
@@ -4085,18 +4163,15 @@ parse_access_log(CustomLog ** logs)
         cl->type = Log::Format::CLF_USERAGENT;
     } else if (strcmp(logdef_name, "referrer") == 0) {
         cl->type = Log::Format::CLF_REFERER;
-    } else {
+    } else if (dieWhenMissing) {
         debugs(3, DBG_CRITICAL, "Log format '" << logdef_name << "' is not defined");
         self_destruct();
-        return;
+        return false;
+    } else {
+        return false;
     }
 
-    aclParseAclList(LegacyParser, &cl->aclList, filename);
-
-    while (*logs)
-        logs = &(*logs)->next;
-
-    *logs = cl;
+    return true;
 }
 
 static int
@@ -1247,6 +1247,26 @@ DOC_START
 	sources is required to prevent abuse of your proxy.
 DOC_END
 
+NAME: spoof_client_ip
+TYPE: acl_access
+LOC: Config.accessList.spoof_client_ip
+DEFAULT: none
+DEFAULT_DOC: Allow spoofing on all TPROXY traffic.
+DOC_START
+	Control client IP address spoofing of TPROXY traffic based on
+	defined access lists.
+
+	spoof_client_ip allow|deny [!]aclname ...
+
+	If there are no "spoof_client_ip" lines present, the default
+	is to "allow" spoofing of any suitable request.
+
+	Note that the cache_peer "no-tproxy" option overrides this ACL.
+
+	This clause supports fast acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+DOC_END
+
 NAME: http_access
 TYPE: acl_access
 LOC: Config.accessList.http
@@ -2983,6 +3003,7 @@ DOC_START
 	
 	no-tproxy	Do not use the client-spoof TPROXY support when forwarding
 			requests to this peer. Use normal address selection instead.
+			This overrides the spoof_client_ip ACL.
 	
 	proxy-only	objects fetched from the peer will not be stored locally.
 	
@@ -3674,9 +3695,15 @@ DOC_START
 
 	HTTP related format codes:
 
-		[http::]>h	Original request header. Optional header name argument
-				on the format header[:[separator]element]
-		[http::]>ha	The HTTP request headers after adaptation and redirection. 
+		[http::]>h	Original received request header. 
+				Usually differs from the request header sent by
+				Squid, although most fields are often preserved.
+				Accepts optional header field name/value filter
+				argument using name[:[separator]element] format.
+		[http::]>ha	Received request header after adaptation and
+				redirection (pre-cache REQMOD vectoring point).
+				Usually differs from the request header sent by
+				Squid, although most fields are often preserved.
 				Optional header name argument as for >h
 		[http::]<h	Reply header. Optional header name argument
 				as for >h
@@ -3814,16 +3841,47 @@ TYPE: access_log
 LOC: Config.Log.accesslogs
 DEFAULT_IF_NONE: daemon:@DEFAULT_ACCESS_LOG@ squid
 DOC_START
-	These files log client request activities. Has a line every HTTP or
-	ICP request. The format is:
+	Configures whether and how Squid logs HTTP and ICP transactions.
+	If access logging is enabled, a single line is logged for every 
+	matching HTTP or ICP request. The recommended directive formats are:
+
+	access_log <module>:<place> [option ...] [acl acl ...]
+	access_log none [acl acl ...]
+
+	The following directive format is accepted but may be deprecated:
 	access_log <module>:<place> [<logformat name> [acl acl ...]]
-	access_log none [acl acl ...]]
+
+        In most cases, the first ACL name must not contain the '=' character
+	and should not be equal to an existing logformat name. You can always
+	start with an 'all' ACL to work around those restrictions.
 	
 	Will log to the specified module:place using the specified format (which
 	must be defined in a logformat directive) those entries which match
 	ALL the acl's specified (which must be defined in acl clauses).
 	If no acl is specified, all requests will be logged to this destination.
 	
+	===== Available options for the recommended directive format =====
+
+	logformat=name		Names log line format (either built-in or
+				defined by a logformat directive). Defaults
+				to 'squid'.
+
+	buffer-size=64KB	Defines approximate buffering limit for log
+				records (see buffered_logs).  Squid should not
+				keep more than the specified size and, hence,
+				should flush records before the buffer becomes
+				full to avoid overflows under normal
+				conditions (the exact flushing algorithm is
+				module-dependent though).  The on-error option
+				controls overflow handling.
+
+	on-error=die|drop	Defines action on unrecoverable errors. The
+				'drop' action ignores (i.e., does not log)
+				affected log records. The default 'die' action
+				kills the affected worker. The drop action 
+				support has not been tested for modules other
+				than tcp.
+
 	===== Modules Currently available =====
 	
 	none	Do not log any requests matching these ACL.
@@ -3854,6 +3912,7 @@ DOC_START
 		Place Format:   //host:port
 
 	tcp	To send each log line as text data to a TCP receiver.
+		Lines may be accumulated before sending (see buffered_logs).
 		Place: The destination host name or IP and port.
 		Place Format:   //host:port
 
@@ -4182,7 +4241,7 @@ DOC_START
 	records if it cannot write/send them immediately due to pending I/Os
 	(e.g., the I/O writing the previous log record) or connectivity loss.
 
-	Currently honored by 'daemon' access_log module only.
+	Currently honored by 'daemon' and 'tcp' access_log modules only.
 DOC_END
 
 NAME: netdb_filename
@@ -79,8 +79,9 @@ static ClientInfo *
 clientdbAdd(const Ip::Address &addr)
 {
     ClientInfo *c;
-    char *buf = new char[MAX_IPSTRLEN];
+    char *buf = static_cast<char*>(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
     c = (ClientInfo *)memAllocate(MEM_CLIENT_INFO);
+    debugs(77, 9, "ClientInfo constructed, this=" << c);
     c->hash.key = addr.NtoA(buf,MAX_IPSTRLEN);
     c->addr = addr;
 #if USE_DELAY_POOLS
@@ -354,6 +355,7 @@ clientdbFreeItem(void *data)
     }
 #endif
 
+    debugs(77, 9, "ClientInfo destructed, this=" << c);
     memFree(c, MEM_CLIENT_INFO);
 }
 
@@ -98,7 +98,6 @@
 #include "comm/Write.h"
 #include "CommCalls.h"
 #include "errorpage.h"
-#include "eui/Config.h"
 #include "fd.h"
 #include "fde.h"
 #include "forward.h"
@@ -618,13 +617,6 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
         aLogEntry->cache.requestSize += request->content_length;
     aLogEntry->cache.extuser = request->extacl_user.termedBuf();
 
-#if USE_AUTH
-    if (request->auth_user_request != NULL) {
-        if (request->auth_user_request->username())
-            aLogEntry->cache.authuser = xstrdup(request->auth_user_request->username());
-    }
-#endif
-
     // Adapted request, if any, inherits and then collects all the stats, but
     // the virgin request gets logged instead; copy the stats to log them.
     // TODO: avoid losses by keeping these stats in a shared history object?
@@ -2774,7 +2766,16 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      */
     if (http->clientConnection != NULL) {
         request->flags.intercepted = ((http->clientConnection->flags & COMM_INTERCEPTION) != 0);
-        request->flags.spoofClientIp = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        request->flags.interceptTproxy = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        if (request->flags.interceptTproxy) {
+            if (Config.accessList.spoof_client_ip) {
+                ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.spoof_client_ip, http);
+                request->flags.spoofClientIp = (checklist->fastCheck() == ACCESS_ALLOWED);
+                delete checklist;
+            } else
+                request->flags.spoofClientIp = true;
+        } else
+            request->flags.spoofClientIp = false;
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
@@ -3416,16 +3417,6 @@ connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
     }
 #endif
 
-#if USE_SQUID_EUI
-    if (Eui::TheConfig.euiLookup) {
-        if (client->remote.IsIPv4()) {
-            result->clientConnection->remoteEui48.lookup(client->remote);
-        } else if (client->remote.IsIPv6()) {
-            result->clientConnection->remoteEui64.lookup(client->remote);
-        }
-    }
-#endif
-
     clientdbEstablished(client->remote, 1);
 
     result->flags.readMore = true;
@@ -3676,7 +3667,7 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
     else {
         char buf[MAX_IPSTRLEN];
         assert(bumpMode != Ssl::bumpNone && bumpMode != Ssl::bumpEnd);
-        HttpRequest *fakeRequest = new HttpRequest;
+        HttpRequest::Pointer fakeRequest(new HttpRequest);
         fakeRequest->SetHost(details->local.NtoA(buf, sizeof(buf)));
         fakeRequest->port = details->local.GetPort();
         fakeRequest->clientConnectionManager = connState;
@@ -3685,10 +3676,19 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
         fakeRequest->indirect_client_addr = connState->clientConnection->remote;
 #endif
         fakeRequest->my_addr = connState->clientConnection->local;
-        fakeRequest->flags.spoofClientIp = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        fakeRequest->flags.interceptTproxy = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
         fakeRequest->flags.intercepted = ((connState->clientConnection->flags & COMM_INTERCEPTION) != 0);
+        fakeRequest->myportname = connState->port->name;
+        if (fakeRequest->flags.interceptTproxy) {
+            if (Config.accessList.spoof_client_ip) {
+                ACLFilledChecklist checklist(Config.accessList.spoof_client_ip, fakeRequest.getRaw(), NULL);
+                fakeRequest->flags.spoofClientIp = (checklist.fastCheck() == ACCESS_ALLOWED);
+            } else
+                fakeRequest->flags.spoofClientIp = true;
+        } else
+            fakeRequest->flags.spoofClientIp = false;
         debugs(33, 4, HERE << details << " try to generate a Dynamic SSL CTX");
-        connState->switchToHttps(fakeRequest, bumpMode);
+        connState->switchToHttps(fakeRequest.getRaw(), bumpMode);
     }
 }
 
@@ -4223,7 +4223,7 @@ clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNot
 
     debugs(1, DBG_IMPORTANT, "Accepting " <<
            (s->flags.natIntercept ? "NAT intercepted " : "") <<
-           (s->flags.tproxyIntercept ? "TPROXY spoofing " : "") <<
+           (s->flags.tproxyIntercept ? "TPROXY intercepted " : "") <<
            (s->flags.tunnelSslBumping ? "SSL bumped " : "") <<
            (s->flags.accelSurrogate ? "reverse-proxy " : "")
            << FdNote(portTypeNote) << " connections at "
@@ -670,7 +670,7 @@ ClientRequestContext::hostHeaderVerify()
     }
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
-    if (http->request->flags.intercepted || http->request->flags.spoofClientIp) {
+    if (http->request->flags.intercepted || http->request->flags.interceptTproxy) {
         // verify the Host: port (if any) matches the apparent destination
         if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
             debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
@@ -969,7 +969,7 @@ clientHierarchical(ClientHttpRequest * http)
     const wordlist *p = NULL;
 
     // intercepted requests MUST NOT (yet) be sent to peers unless verified
-    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.spoofClientIp))
+    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))
         return 0;
 
     /*
@@ -1,7 +1,7 @@
 #ifndef _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 #define _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "comm/TcpAcceptor.h"
 
 namespace Comm
@@ -19,6 +19,7 @@ Comm::Connection::Connection() :
         peerType(HIER_NONE),
         fd(-1),
         tos(0),
+        nfmark(0),
         flags(COMM_NONBLOCKING),
         peer_(NULL)
 {
@@ -41,6 +41,7 @@
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "comm/TcpAcceptor.h"
+#include "eui/Config.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
@@ -346,7 +347,11 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     // lookup the local-end details of this new connection
     details->local.InitAddrInfo(gai);
     details->local.SetEmpty();
-    getsockname(sock, gai->ai_addr, &gai->ai_addrlen);
+    if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
+        debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
+        details->local.FreeAddrInfo(gai);
+        return COMM_ERROR;
+    }
     details->local = *gai;
     details->local.FreeAddrInfo(gai);
 
@@ -377,6 +382,16 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
         return COMM_ERROR;
     }
 
+#if USE_SQUID_EUI
+    if (Eui::TheConfig.euiLookup) {
+        if (conn->remote.IsIPv4()) {
+            conn->remoteEui48.lookup(conn->remote);
+        } else if (conn->remote.IsIPv6()) {
+            conn->remoteEui64.lookup(conn->remote);
+        }
+    }
+#endif
+
     PROF_stop(comm_accept);
     return COMM_OK;
 }
@@ -1,7 +1,7 @@
 #ifndef _SQUID_COMM_FORWARD_H
 #define _SQUID_COMM_FORWARD_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 
 namespace Comm
@@ -42,7 +42,7 @@
 #include "squid.h"
 
 #if USE_DELAY_POOLS
-#include "Array.h"
+#include "base/Vector.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
 #include "CommonPool.h"
@@ -32,7 +32,7 @@
  */
 
 #include "squid.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "esi/CustomParser.h"
 #include "Debug.h"
 #include "Trie.h"
@@ -34,7 +34,7 @@
 
 #include "esi/Segment.h"
 #include "Trie.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "HttpHeader.h"
 
 class HttpReply;
@@ -32,7 +32,7 @@
 #ifndef SQUID_EVENT_H
 #define SQUID_EVENT_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "AsyncEngine.h"
 #include "MemPool.h"
 
@@ -383,7 +383,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         case LFT_LOCAL_LISTENING_IP: {
             // avoid logging a dash if we have reliable info
             const bool interceptedAtKnownPort = al->request ?
-                                                (al->request->flags.spoofClientIp ||
+                                                (al->request->flags.interceptTproxy ||
                                                  al->request->flags.intercepted) && al->cache.port :
                                                 false;
             if (interceptedAtKnownPort) {
@@ -760,7 +760,10 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_USER_NAME:
-            out = strOrNull(al->cache.authuser);
+#if USE_AUTH
+            if (al->request && al->request->auth_user_request != NULL)
+                out = strOrNull(al->request->auth_user_request->username());
+#endif
             if (!out)
                 out = strOrNull(al->cache.extuser);
 #if USE_SSL
@@ -772,7 +775,10 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_USER_LOGIN:
-            out = strOrNull(al->cache.authuser);
+#if USE_AUTH
+            if (al->request && al->request->auth_user_request != NULL)
+                out = strOrNull(al->request->auth_user_request->username());
+#endif
             break;
 
         case LFT_USER_IDENT:
@@ -151,7 +151,7 @@ void FwdState::start(Pointer aSelf)
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must force DIRECT and only to the original client destination.
-    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.spoofClientIp);
+    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || (request && !request->flags.hostVerified);
     if (isIntercepted && useOriginalDst) {
         selectPeerForIntercepted();
@@ -555,9 +555,6 @@ FwdState::checkRetry()
     if (n_tries > 10)
         return false;
 
-    if (origin_tries > 2)
-        return false;
-
     if (squid_curtime - start_t > Config.Timeout.forward)
         return false;
 
@@ -1163,9 +1160,6 @@ FwdState::connectStart()
         debugs(17, 3, HERE << "reusing pconn " << serverConnection());
         ++n_tries;
 
-        if (!serverConnection()->getPeer())
-            ++origin_tries;
-
         comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
         /* Update server side TOS and Netfilter mark on the connection. */
@@ -1364,9 +1358,6 @@ FwdState::reforward()
     if (n_tries > Config.forward_max_tries)
         return 0;
 
-    if (origin_tries > 1)
-        return 0;
-
     if (request->bodyNibbled())
         return 0;
 
@@ -1,7 +1,7 @@
 #ifndef SQUID_FORWARD_H
 #define SQUID_FORWARD_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "comm.h"
 #include "comm/Connection.h"
@@ -120,7 +120,6 @@ class FwdState : public RefCountable
     Comm::ConnectionPointer clientConn;        ///< a possibly open connection to the client.
     time_t start_t;
     int n_tries;
-    int origin_tries;
 
     // AsyncCalls which we set and may need cancelling.
     struct {
@@ -420,9 +420,14 @@ Fs::Ufs::RebuildState::undoAdd()
     added->releaseRequest();
 
     if (added->swap_filen > -1) {
-        UFSSwapDir *sde = dynamic_cast<UFSSwapDir *>(INDEXSD(added->swap_dirn));
-        assert(sde);
-        sde->undoAddDiskRestore(added);
+        SwapDir *someDir = INDEXSD(added->swap_dirn);
+        assert(someDir);
+        if (UFSSwapDir *ufsDir = dynamic_cast<UFSSwapDir*>(someDir))
+            ufsDir->undoAddDiskRestore(added);
+        // else the entry was loaded from and/or is currently in a non-UFS dir
+        // Thus, there is no use in preserving its disk file (the only purpose
+        // of undoAddDiskRestore!), even if we could. Instead, we release the
+        // the entry and [eventually] unlink its disk file or free its slot.
     }
 
     added->release();
@@ -36,6 +36,7 @@
 #include "comm/Connection.h"
 #include "comm/Write.h"
 #include "fd.h"
+#include "fde.h"
 #include "format/Quoting.h"
 #include "helper.h"
 #include "Mem.h"
@@ -771,7 +772,7 @@ helperServerFree(helper_server *srv)
     safe_free(srv->requests);
 
     cbdataReferenceDone(srv->parent);
-    cbdataFree(srv);
+    delete srv;
 }
 
 static void
@@ -840,7 +841,7 @@ helperStatefulServerFree(helper_stateful_server *srv)
 
     cbdataReferenceDone(srv->parent);
 
-    cbdataFree(srv);
+    delete srv;
 }
 
 /// Calls back with a pointer to the buffer with the helper output
@@ -957,7 +958,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
         srv->rbuf[srv->roffset] = '\0';
     }
 
-    if (Comm::IsConnOpen(srv->readPipe)) {
+    if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
         int spaceSize = srv->rbuf_sz - srv->roffset - 1;
         assert(spaceSize >= 0);
 
@@ -1078,7 +1079,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
             helperStatefulReleaseServer(srv);
     }
 
-    if (Comm::IsConnOpen(srv->readPipe)) {
+    if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
         int spaceSize = srv->rbuf_sz - srv->roffset - 1;
         assert(spaceSize >= 0);
 
@@ -6,7 +6,7 @@
 #ifndef SQUID_IPC_COORDINATOR_H
 #define SQUID_IPC_COORDINATOR_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "ipc/Messages.h"
 #include "ipc/Port.h"
 #include "ipc/SharedListen.h"
@@ -4,7 +4,7 @@
 #ifndef SQUID_IPC_KIDS_H
 #define SQUID_IPC_KIDS_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "ipc/Kid.h"
 
 /// a collection of kids
@@ -4,7 +4,7 @@
 #ifndef SQUID_IPC_QUEUE_H
 #define SQUID_IPC_QUEUE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "Debug.h"
 #include "base/InstanceId.h"
 #include "ipc/AtomicWord.h"
@@ -48,6 +48,10 @@ class CustomLog
     Logfile *logfile;
     CustomLog *next;
     Log::Format::log_type type;
+    /// how much to buffer before dropping or dying (access_log buffer-size)
+    size_t bufferSize;
+    /// whether unrecoverable errors (e.g., dropping a log record) kill worker
+    bool fatal;
 };
 
 #endif /* SQUID_CUSTOMLOG_H_ */
@@ -37,7 +37,7 @@
 #include "log/ModStdio.h"
 #include "log/ModSyslog.h"
 #include "log/ModUdp.h"
-#include "log/ModTcp.h"
+#include "log/TcpLogger.h"
 
 CBDATA_TYPE(Logfile);
 
@@ -62,7 +62,7 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
         ret = logfile_mod_daemon_open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "tcp:", 4) == 0) {
         patharg = path + 4;
-        ret = logfile_mod_tcp_open(lf, patharg, bufsz, fatal_flag);
+        ret = Log::TcpLogger::Open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "udp:", 4) == 0) {
         patharg = path + 4;
         ret = logfile_mod_udp_open(lf, patharg, bufsz, fatal_flag);
@@ -72,7 +72,7 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
         ret = logfile_mod_syslog_open(lf, patharg, bufsz, fatal_flag);
 #endif
     } else {
-        debugs(50, DBG_IMPORTANT, "WARNING: log parameters now start with a module name. Use 'stdio:" << patharg << "'");
+        debugs(50, DBG_IMPORTANT, "WARNING: log name now starts with a module name. Use 'stdio:" << patharg << "'");
         snprintf(lf->path, MAXPATHLEN, "stdio:%s", patharg);
         ret = logfile_mod_stdio_open(lf, patharg, bufsz, fatal_flag);
     }
@@ -45,13 +45,15 @@ void
 Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *user_ident = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
-
-    const char *user_auth = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
-
+    const char *user_auth = NULL;
     const char *referer = NULL;
     const char *agent = NULL;
 
     if (al->request) {
+#if USE_AUTH
+        if (al->request->auth_user_request != NULL)
+            user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
         referer = al->request->header.getStr(HDR_REFERER);
         agent = al->request->header.getStr(HDR_USER_AGENT);
     }
@@ -35,6 +35,7 @@
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "globals.h"
+#include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "SquidConfig.h"
@@ -43,7 +44,11 @@
 void
 Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
-    const char *user_auth = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
+    const char *user_auth = NULL;
+#if USE_AUTH
+    if (al->request && al->request->auth_user_request != NULL)
+        user_auth = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
     const char *user_ident = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
 
     char clientip[MAX_IPSTRLEN];
@@ -59,7 +59,10 @@ Log::Format::SquidIcap(const AccessLogEntry::Pointer &al, Logfile * logfile)
             client = al->cache.caddr.NtoA(clientbuf, MAX_IPSTRLEN);
     }
 
-    user = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
+#if USE_AUTH
+    if (al->request != NULL && al->request->auth_user_request != NULL)
+        user = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.extuser);
@@ -35,6 +35,7 @@
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "globals.h"
+#include "HttpRequest.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "SquidConfig.h"
@@ -45,7 +46,12 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     char hierHost[MAX_IPSTRLEN];
 
-    const char *user = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
+    const char *user = NULL;
+
+#if USE_AUTH
+    if (al->request && al->request->auth_user_request != NULL)
+        user = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
+#endif
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.extuser);
@@ -24,10 +24,10 @@ liblog_la_SOURCES = \
 	ModStdio.h \
 	ModSyslog.cc \
 	ModSyslog.h \
-	ModTcp.cc \
-	ModTcp.h \
 	ModUdp.cc \
 	ModUdp.h \
 	CustomLog.h \
-	CustomLog.cc
+	CustomLog.cc \
+	TcpLogger.cc \
+	TcpLogger.h
 
@@ -1,237 +0,0 @@
-/*
- * DEBUG: section 50    Log file handling
- * AUTHOR: Dhaval Varia
- * Developed based on ModUdp.* by Adrian Chadd
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-#include "comm.h"
-#include "comm/Connection.h"
-#include "disk.h"
-#include "fd.h"
-#include "log/File.h"
-#include "log/ModTcp.h"
-#include "Parsing.h"
-#include "SquidConfig.h"
-
-#if HAVE_ERRNO_H
-#include <errno.h>
-#endif
-/*
- * This logfile TCP module is mostly inspired by a patch by Tim Starling
- * from Wikimedia.
- *
- * It doesn't do any TCP buffering - it'd be quite a bit of work for
- * something which the kernel could be doing for you!
- */
-
-typedef struct {
-    int fd;
-    char *buf;
-    size_t bufsz;
-    int offset;
-} l_tcp_t;
-
-static void
-logfile_mod_tcp_write(Logfile * lf, const char *buf, size_t len)
-{
-    l_tcp_t *ll = (l_tcp_t *) lf->data;
-    ssize_t s;
-    s = write(ll->fd, (char const *) buf, len);
-
-    fd_bytes(ll->fd, s, FD_WRITE);
-#if 0
-    if (s < 0) {
-        debugs(1, DBG_IMPORTANT, "logfile (tcp): got errno (" << errno << "):" << xstrerror());
-    }
-    if (s != len) {
-        debugs(1, DBG_IMPORTANT, "logfile (tcp): len=" << len << ", wrote=" << s);
-    }
-#endif
-
-    /* We don't worry about network errors for now */
-}
-
-static void
-logfile_mod_tcp_flush(Logfile * lf)
-{
-    l_tcp_t *ll = (l_tcp_t *) lf->data;
-    if (0 == ll->offset)
-        return;
-    logfile_mod_tcp_write(lf, ll->buf, (size_t) ll->offset);
-    ll->offset = 0;
-}
-
-static void
-logfile_mod_tcp_writeline(Logfile * lf, const char *buf, size_t len)
-{
-    l_tcp_t *ll = (l_tcp_t *) lf->data;
-
-    if (0 == ll->bufsz) {
-        /* buffering disabled */
-        logfile_mod_tcp_write(lf, buf, len);
-        return;
-    }
-    if (ll->offset > 0 && (ll->offset + len + 4) > ll->bufsz)
-        logfile_mod_tcp_flush(lf);
-
-    if (len > ll->bufsz) {
-        /* too big to fit in buffer */
-        logfile_mod_tcp_write(lf, buf, len);
-        return;
-    }
-    /* buffer it */
-    memcpy(ll->buf + ll->offset, buf, len);
-
-    ll->offset += len;
-
-    assert(ll->offset >= 0);
-
-    assert((size_t) ll->offset <= ll->bufsz);
-}
-
-static void
-logfile_mod_tcp_linestart(Logfile * lf)
-{
-}
-
-static void
-logfile_mod_tcp_lineend(Logfile * lf)
-{
-    logfile_mod_tcp_flush(lf);
-}
-
-static void
-logfile_mod_tcp_rotate(Logfile * lf)
-{
-    return;
-}
-
-static void
-logfile_mod_tcp_close(Logfile * lf)
-{
-    l_tcp_t *ll = (l_tcp_t *) lf->data;
-    lf->f_flush(lf);
-
-    if (ll->fd >= 0)
-        file_close(ll->fd);
-
-    if (ll->buf)
-        xfree(ll->buf);
-
-    xfree(lf->data);
-    lf->data = NULL;
-}
-
-/*
- * This code expects the path to be //host:port
- */
-int
-logfile_mod_tcp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_flag)
-{
-    debugs(5, 3, "Tcp Open called");
-    Ip::Address addr;
-
-    char *strAddr;
-
-    lf->f_close = logfile_mod_tcp_close;
-    lf->f_linewrite = logfile_mod_tcp_writeline;
-    lf->f_linestart = logfile_mod_tcp_linestart;
-    lf->f_lineend = logfile_mod_tcp_lineend;
-    lf->f_flush = logfile_mod_tcp_flush;
-    lf->f_rotate = logfile_mod_tcp_rotate;
-
-    l_tcp_t *ll = static_cast<l_tcp_t*>(xcalloc(1, sizeof(*ll)));
-    lf->data = ll;
-
-    if (strncmp(path, "//", 2) == 0) {
-        path += 2;
-    }
-    strAddr = xstrdup(path);
-
-    if (!GetHostWithPort(strAddr, &addr)) {
-        if (lf->flags.fatal) {
-            fatalf("Invalid TCP logging address '%s'\n", lf->path);
-        } else {
-            debugs(50, DBG_IMPORTANT, "Invalid TCP logging address '" << lf->path << "'");
-            safe_free(strAddr);
-            return FALSE;
-        }
-    }
-
-    safe_free(strAddr);
-
-    Ip::Address any_addr;
-    any_addr.SetAnyAddr();
-
-    // require the sending TCP port to be of the right family for the destination address.
-    if (addr.IsIPv4())
-        any_addr.SetIPv4();
-
-    ll->fd = comm_open(SOCK_STREAM, IPPROTO_TCP, any_addr, COMM_NONBLOCKING, "TCP log socket");
-    if (ll->fd < 0) {
-        if (lf->flags.fatal) {
-            fatalf("Unable to open TCP socket for logging\n");
-        } else {
-            debugs(50, DBG_IMPORTANT, "Unable to open TCP socket for logging");
-            return FALSE;
-        }
-    } else if (!comm_connect_addr(ll->fd, &addr)) {
-        if (lf->flags.fatal) {
-            fatalf("Unable to connect to %s for TCP log: %s\n", lf->path, xstrerror());
-        } else {
-            debugs(50, DBG_IMPORTANT, "Unable to connect to " << lf->path << " for TCP log: " << xstrerror());
-            return FALSE;
-        }
-    }
-    if (ll->fd == -1) {
-        if (ENOENT == errno && fatal_flag) {
-            fatalf("Cannot open '%s' because\n"
-                   "\tthe parent directory does not exist.\n"
-                   "\tPlease create the directory.\n", path);
-        } else if (EACCES == errno && fatal_flag) {
-            fatalf("Cannot open '%s' for writing.\n"
-                   "\tThe parent directory must be writeable by the\n"
-                   "\tuser '%s', which is the cache_effective_user\n"
-                   "\tset in squid.conf.", path, Config.effectiveUser);
-        } else {
-            debugs(50, DBG_IMPORTANT, "logfileOpen (TCP): " << lf->path << ": " << xstrerror());
-            return 0;
-        }
-    }
-
-    bufsz = 65536;
-    if (bufsz > 0) {
-        ll->buf = static_cast<char*>(xmalloc(bufsz));
-        ll->bufsz = bufsz;
-    }
-
-    return 1;
-}
@@ -1,40 +0,0 @@
-/*
- * DEBUG: section 50    Log file handling
- * AUTHOR: Dhaval Varia
- * Developed based on ModUdp.* by Adrian Chadd
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-#ifndef _SQUID_SRC_LOG_MODTCP_H
-#define _SQUID_SRC_LOG_MODTCP_H
-
-class Logfile;
-
-int logfile_mod_tcp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_flag);
-
-#endif /* _SQUID_SRC_LOG_MODTCP_H */
@@ -0,0 +1,471 @@
+#include "squid.h"
+#include "comm.h"
+#include "comm/ConnOpener.h"
+#include "comm/Connection.h"
+#include "comm/Loops.h"
+#include "comm/Write.h"
+#include "fde.h"
+#include "globals.h" // for shutting_down
+#include "log/CustomLog.h"
+#include "log/File.h"
+#include "log/TcpLogger.h"
+#include "MemBlob.h"
+#include "Parsing.h"
+#include "SquidConfig.h"
+#include "SquidTime.h"
+
+// a single I/O buffer should be large enough to store any access.log record
+const size_t Log::TcpLogger::IoBufSize = 2*MAX_URL;
+
+// We need at least two buffers because when we write the first buffer,
+// we have to use the second buffer to accumulate new entries.
+const size_t Log::TcpLogger::BufferCapacityMin = 2*Log::TcpLogger::IoBufSize;
+
+#define MY_DEBUG_SECTION 50 /* Log file handling */
+
+CBDATA_NAMESPACED_CLASS_INIT(Log, TcpLogger);
+
+Log::TcpLogger::TcpLogger(size_t bufCap, bool dieOnErr, Ip::Address them):
+        AsyncJob("TcpLogger"),
+        dieOnError(dieOnErr),
+        bufferCapacity(bufCap),
+        bufferedSize(0),
+        flushDebt(0),
+        quitOnEmpty(false),
+        reconnectScheduled(false),
+        writeScheduled(false),
+        conn(NULL),
+        remote(them),
+        connectFailures(0),
+        drops(0)
+{
+    if (bufferCapacity < BufferCapacityMin) {
+        debugs(MY_DEBUG_SECTION, DBG_IMPORTANT,
+               "WARNING: tcp:" << remote << " logger configured buffer " <<
+               "size " << bufferCapacity << " is smaller than the " <<
+               BufferCapacityMin << "-byte" << " minimum. " <<
+               "Using the minimum instead.");
+        bufferCapacity = BufferCapacityMin;
+    }
+}
+
+Log::TcpLogger::~TcpLogger()
+{
+    // make sure Comm::Write does not have our buffer pointer
+    assert(!writeScheduled);
+}
+
+void
+Log::TcpLogger::start()
+{
+    connect();
+}
+
+bool
+Log::TcpLogger::doneAll() const
+{
+    debugs(MY_DEBUG_SECTION, 5, "quitOnEmpty: " << quitOnEmpty <<
+           " buffered: " << bufferedSize <<
+           " conn: " << conn << ' ' << connectFailures);
+
+    // we do not quit unless we are told that we may
+    if (!quitOnEmpty)
+        return false;
+
+    /* We were asked to quit after we are done writing buffers. Are we done? */
+
+    // If we have records but are failing to connect, quit. Otherwise, we may
+    // be trying to connect forever due to a [since fixed] misconfiguration!
+    const bool failingToConnect = !conn && connectFailures;
+    if (bufferedSize && !failingToConnect)
+        return false;
+
+    return AsyncJob::doneAll();
+}
+
+void
+Log::TcpLogger::swanSong()
+{
+    disconnect(); // optional: refcounting should close/delete conn eventually
+    AsyncJob::swanSong();
+}
+
+void
+Log::TcpLogger::endGracefully()
+{
+    // job call protection must end our job if we are done logging current bufs
+    assert(inCall != NULL);
+    quitOnEmpty = true;
+    flush();
+}
+
+void
+Log::TcpLogger::flush()
+{
+    flushDebt = bufferedSize;
+    writeIfNeeded();
+}
+
+void
+Log::TcpLogger::logRecord(const char *buf, const size_t len)
+{
+    appendRecord(buf, len);
+    writeIfNeeded();
+}
+
+/// starts writing if and only if it is time to write accumulated records
+void
+Log::TcpLogger::writeIfNeeded()
+{
+    // write if an earlier flush command forces us to write or
+    // if we have filled at least one I/O buffer
+    if (flushDebt > 0 || buffers.size() > 1)
+        writeIfPossible();
+}
+
+/// starts writing if possible
+void Log::TcpLogger::writeIfPossible()
+{
+    debugs(MY_DEBUG_SECTION, 7, "guards: " << (!writeScheduled) <<
+           (bufferedSize > 0) << (conn != NULL) <<
+           (conn != NULL && !fd_table[conn->fd].closing()) << " buffered: " <<
+           bufferedSize << '/' << buffers.size());
+
+    // XXX: Squid shutdown sequence starts closing our connection before
+    // calling LogfileClose, leading to loss of log records during shutdown.
+    if (!writeScheduled && bufferedSize > 0 && conn != NULL &&
+            !fd_table[conn->fd].closing()) {
+        debugs(MY_DEBUG_SECTION, 5, "writing first buffer");
+
+        typedef CommCbMemFunT<TcpLogger, CommIoCbParams> WriteDialer;
+        AsyncCall::Pointer callback = JobCallback(MY_DEBUG_SECTION, 5, WriteDialer, this, Log::TcpLogger::writeDone);
+        const MemBlob::Pointer &buffer = buffers.front();
+        Comm::Write(conn, buffer->mem, buffer->size, callback, NULL);
+        writeScheduled = true;
+    }
+}
+
+/// whether len more bytes can be buffered
+bool
+Log::TcpLogger::canFit(const size_t len) const
+{
+    // TODO: limit reporting frequency in addition to reporting only changes
+
+    if (bufferedSize+len <= bufferCapacity) {
+        if (drops) {
+            // We can get here if a shorter record accidentally fits after we
+            // started dropping records. When that happens, the following
+            // DBG_IMPORTANT message will mislead admin into thinking that
+            // the problem was resolved (for a brief period of time, until
+            // another record comes in and overflows the buffer). It is
+            // difficult to prevent this without also creating the opposite
+            // problem: A huge record that does not fit and is dropped blocks
+            // subsequent regular records from being buffered until we write.
+            debugs(MY_DEBUG_SECTION, DBG_IMPORTANT, "tcp:" << remote <<
+                   " logger stops dropping records after " << drops << " drops" <<
+                   "; current buffer use: " << (bufferedSize+len) <<
+                   " out of " << bufferCapacity << " bytes");
+        }
+        return true;
+    }
+
+    if (!drops || dieOnError) {
+        debugs(MY_DEBUG_SECTION,
+               dieOnError ? DBG_CRITICAL : DBG_IMPORTANT,
+               "tcp:" << remote << " logger " << bufferCapacity << "-byte " <<
+               "buffer overflowed; cannot fit " <<
+               (bufferedSize+len-bufferCapacity) << " bytes");
+    }
+
+    if (dieOnError)
+        fatal("tcp logger buffer overflowed");
+
+    if (!drops) {
+        debugs(MY_DEBUG_SECTION, DBG_IMPORTANT, "tcp:" << remote <<
+               " logger starts dropping records.");
+    }
+
+    return false;
+}
+
+/// buffer a record that might exceed IoBufSize
+void
+Log::TcpLogger::appendRecord(const char *record, const size_t len)
+{
+    // they should not happen, but to be safe, let's protect drop start/stop
+    // monitoring algorithm from empty records (which can never be dropped)
+    if (!len)
+        return;
+
+    if (!canFit(len)) {
+        ++drops;
+        return;
+    }
+
+    drops = 0;
+    // append without spliting buf, unless it exceeds IoBufSize
+    for (size_t off = 0; off < len; off += IoBufSize)
+        appendChunk(record + off, min(len - off, IoBufSize));
+}
+
+/// buffer a record chunk without splitting it across buffers
+void
+Log::TcpLogger::appendChunk(const char *chunk, const size_t len)
+{
+    Must(len <= IoBufSize);
+    // add a buffer if there is not one that can accomodate len bytes
+    bool addBuffer = buffers.empty() ||
+                     (buffers.back()->size+len > IoBufSize);
+    // also add a buffer if there is only one and that one is being written
+    addBuffer = addBuffer || (writeScheduled && buffers.size() == 1);
+
+    if (addBuffer) {
+        buffers.push_back(new MemBlob(IoBufSize));
+        debugs(MY_DEBUG_SECTION, 7, "added buffer #" << buffers.size());
+    }
+
+    Must(!buffers.empty());
+    buffers.back()->append(chunk, len);
+    bufferedSize += len;
+}
+
+/// starts [re]connecting to the remote logger
+void
+Log::TcpLogger::connect()
+{
+    if (shutting_down)
+        return;
+
+    debugs(MY_DEBUG_SECTION, 3, "connecting");
+    Must(!conn);
+
+    Comm::ConnectionPointer futureConn = new Comm::Connection;
+    futureConn->remote = remote;
+    futureConn->local.SetAnyAddr();
+    if (futureConn->remote.IsIPv4())
+        futureConn->local.SetIPv4();
+
+    typedef CommCbMemFunT<TcpLogger, CommConnectCbParams> Dialer;
+    AsyncCall::Pointer call = JobCallback(MY_DEBUG_SECTION, 5, Dialer, this, Log::TcpLogger::connectDone);
+    AsyncJob::Start(new Comm::ConnOpener(futureConn, call, 2));
+}
+
+/// Comm::ConnOpener callback
+void
+Log::TcpLogger::connectDone(const CommConnectCbParams &params)
+{
+    if (params.flag != COMM_OK) {
+        const double delay = 0.5; // seconds
+        if (connectFailures++ % 100 == 0) {
+            debugs(MY_DEBUG_SECTION, DBG_IMPORTANT, "tcp:" << remote <<
+                   " logger connection attempt #" << connectFailures <<
+                   " failed. Will keep trying every " << delay << " seconds.");
+        }
+
+        if (!reconnectScheduled) {
+            reconnectScheduled = true;
+            eventAdd("Log::TcpLogger::DelayedReconnect",
+                     Log::TcpLogger::DelayedReconnect,
+                     new Pointer(this), 0.5, 0, false);
+        }
+    } else {
+        if (connectFailures > 0) {
+            debugs(MY_DEBUG_SECTION, DBG_IMPORTANT, "tcp:" << remote <<
+                   " logger connectivity restored after " <<
+                   (connectFailures+1) << " attempts.");
+            connectFailures = 0;
+        }
+
+        Must(!conn);
+        conn = params.conn;
+
+        Must(!closer);
+        typedef CommCbMemFunT<TcpLogger, CommCloseCbParams> Closer;
+        closer = JobCallback(MY_DEBUG_SECTION, 4, Closer, this, Log::TcpLogger::handleClosure);
+        comm_add_close_handler(conn->fd, closer);
+
+        writeIfNeeded();
+    }
+}
+
+// XXX: Needed until eventAdd() starts accepting Async calls directly.
+/// Log::TcpLogger::delayedReconnect() wrapper.
+void
+Log::TcpLogger::DelayedReconnect(void *data)
+{
+    Pointer *ptr = static_cast<Pointer*>(data);
+    assert(ptr);
+    if (TcpLogger *logger = ptr->valid()) {
+        // Get back inside AsyncJob protections by scheduling another call.
+        typedef NullaryMemFunT<TcpLogger> Dialer;
+        AsyncCall::Pointer call = JobCallback(MY_DEBUG_SECTION, 5, Dialer,
+                                              logger,
+                                              Log::TcpLogger::delayedReconnect);
+        ScheduleCallHere(call);
+    }
+    delete ptr;
+}
+
+/// "sleep a little before trying to connect again" event callback
+void
+Log::TcpLogger::delayedReconnect()
+{
+    Must(reconnectScheduled);
+    Must(!conn);
+    reconnectScheduled = false;
+    connect();
+}
+
+/// Comm::Write callback
+void
+Log::TcpLogger::writeDone(const CommIoCbParams &io)
+{
+    writeScheduled = false;
+    if (io.flag == COMM_ERR_CLOSING) {
+        debugs(MY_DEBUG_SECTION, 7, "closing");
+        // do nothing here -- our comm_close_handler will be called to clean up
+    } else if (io.flag != COMM_OK) {
+        debugs(MY_DEBUG_SECTION, 2, "write failure: " << xstrerr(io.xerrno));
+        // keep the first buffer (the one we failed to write)
+        disconnect();
+        connect();
+    } else {
+        debugs(MY_DEBUG_SECTION, 5, "write successful");
+
+        Must(!buffers.empty()); // we had a buffer to write
+        const MemBlob::Pointer &written = buffers.front();
+        const size_t writtenSize = static_cast<size_t>(written->size);
+        // and we wrote the whole buffer
+        Must(io.size == writtenSize);
+        Must(bufferedSize >= writtenSize);
+        bufferedSize -= writtenSize;
+
+        buffers.pop_front();
+
+        if (flushDebt > io.size)
+            flushDebt -= io.size;
+        else
+            flushDebt = 0; // wrote everything we owed (or more)
+
+        writeIfNeeded();
+    }
+}
+
+/// This is our comm_close_handler. It is called when some external force
+/// (e.g., reconfigure or shutdown) is closing the connection (rather than us).
+void
+Log::TcpLogger::handleClosure(const CommCloseCbParams &io)
+{
+    assert(inCall != NULL);
+    closer = NULL;
+    conn = NULL;
+    // in all current use cases, we should not try to reconnect
+    mustStop("Log::TcpLogger::handleClosure");
+}
+
+/// close our connection now, without flushing
+void
+Log::TcpLogger::disconnect()
+{
+    if (conn != NULL) {
+        if (closer != NULL) {
+            comm_remove_close_handler(conn->fd, closer);
+            closer = NULL;
+        }
+        conn->close();
+        conn = NULL;
+    }
+}
+
+/// Converts Logfile into a pointer to a valid TcpLogger job or,
+/// if the logger job has quit, into a nill pointer
+Log::TcpLogger *
+Log::TcpLogger::StillLogging(Logfile *lf)
+{
+    if (Pointer *pptr = static_cast<Pointer*>(lf->data))
+        return pptr->get(); // may be nil
+    return NULL;
+}
+
+void
+Log::TcpLogger::Flush(Logfile * lf)
+{
+    if (TcpLogger *logger = StillLogging(lf))
+        logger->flush();
+}
+
+void
+Log::TcpLogger::WriteLine(Logfile * lf, const char *buf, size_t len)
+{
+    if (TcpLogger *logger = StillLogging(lf))
+        logger->logRecord(buf, len);
+}
+
+void
+Log::TcpLogger::StartLine(Logfile * lf)
+{
+}
+
+void
+Log::TcpLogger::EndLine(Logfile * lf)
+{
+    if (!Config.onoff.buffered_logs)
+        Flush(lf);
+}
+
+void
+Log::TcpLogger::Rotate(Logfile * lf)
+{
+}
+
+void
+Log::TcpLogger::Close(Logfile * lf)
+{
+    if (TcpLogger *logger = StillLogging(lf)) {
+        debugs(50, 3, "Closing " << logger);
+        typedef NullaryMemFunT<TcpLogger> Dialer;
+        Dialer dialer(logger, &Log::TcpLogger::endGracefully);
+        AsyncCall::Pointer call = asyncCall(50, 3, "Log::TcpLogger::endGracefully", dialer);
+        ScheduleCallHere(call);
+    }
+    delete static_cast<Pointer*>(lf->data);
+    lf->data = NULL;
+}
+
+/*
+ * This code expects the path to be //host:port
+ */
+int
+Log::TcpLogger::Open(Logfile * lf, const char *path, size_t bufsz, int fatalFlag)
+{
+    assert(!StillLogging(lf));
+    debugs(5, 3, "Tcp Open called");
+
+    Ip::Address addr;
+
+    if (strncmp(path, "//", 2) == 0)
+        path += 2;
+    char *strAddr = xstrdup(path);
+    if (!GetHostWithPort(strAddr, &addr)) {
+        if (lf->flags.fatal) {
+            fatalf("Invalid TCP logging address '%s'\n", lf->path);
+        } else {
+            debugs(50, DBG_IMPORTANT, "Invalid TCP logging address '" << lf->path << "'");
+            safe_free(strAddr);
+            return FALSE;
+        }
+    }
+    safe_free(strAddr);
+
+    TcpLogger *logger = new TcpLogger(bufsz, fatalFlag, addr);
+    lf->data = new Pointer(logger);
+    lf->f_close = &Close;
+    lf->f_linewrite = &WriteLine;
+    lf->f_linestart = &StartLine;
+    lf->f_lineend = &EndLine;
+    lf->f_flush = &Flush;
+    lf->f_rotate = &Rotate;
+    AsyncJob::Start(logger);
+
+    return 1;
+}
@@ -0,0 +1,106 @@
+#ifndef _SQUID_SRC_LOG_TCPLOGGER_H
+#define _SQUID_SRC_LOG_TCPLOGGER_H
+
+#include "base/AsyncJob.h"
+#include "ip/Address.h"
+
+#if HAVE_LIST
+#include <list>
+#endif
+
+class MemBlob;
+typedef RefCount<MemBlob> MemBlobPointer;
+
+namespace Log
+{
+
+/**
+ * Sends log records to a remote TCP logger at the configured IP:port address.
+ * Handles loss of connectivity, record buffering, and buffer overflows.
+ */
+class TcpLogger : public AsyncJob
+{
+public:
+    typedef CbcPointer<TcpLogger> Pointer;
+
+    /* Logfile API */
+    static int Open(Logfile *lf, const char *path, size_t bufSz, int fatalFlag);
+
+protected:
+    TcpLogger(size_t, bool, Ip::Address);
+    virtual ~TcpLogger();
+
+    /// Called when Squid is reconfiguring (or exiting) to give us a chance to
+    /// flush remaining buffers and end this job w/o loss of data. No new log
+    /// records are expected. Must be used as (or inside) an async job call and
+    /// will result in [eventual] job termination.
+    void endGracefully();
+
+    /// buffers record and possibly writes it to the remote logger
+    void logRecord(const char *buf, size_t len);
+
+    /// write all currently buffered records ASAP
+    void flush();
+
+    /* AsyncJob API */
+    virtual void start();
+    virtual bool doneAll() const;
+    virtual void swanSong();
+
+private:
+    /* Logfile API. Map c-style Logfile calls to TcpLogger method calls. */
+    static void Flush(Logfile *lf);
+    static void WriteLine(Logfile *lf, const char *buf, size_t len);
+    static void StartLine(Logfile *lf);
+    static void EndLine(Logfile *lf);
+    static void Rotate(Logfile *lf);
+    static void Close(Logfile *lf);
+
+    static TcpLogger *StillLogging(Logfile *lf);
+
+    static void DelayedReconnect(void *data);
+    void delayedReconnect();
+
+    bool canFit(const size_t len) const;
+    void appendRecord(const char *buf, size_t len);
+    void appendChunk(const char *chunk, const size_t len);
+    void writeIfNeeded();
+    void writeIfPossible();
+    void connect();
+    void disconnect();
+
+    /* comm callbacks */
+    void connectDone(const CommConnectCbParams &conn);
+    void writeDone(const CommIoCbParams &io);
+    void handleClosure(const CommCloseCbParams &io);
+
+    static const size_t IoBufSize; ///< fixed I/O buffer size
+    static const size_t BufferCapacityMin; ///< minimum bufferCapacity value
+
+    /// Whether this job must kill Squid on the first unrecoverable error.
+    /// Note that we may be able to recover from a failure to connect, but we
+    /// cannot recover from forgetting (dropping) a record while connecting.
+    bool dieOnError;
+
+    std::list<MemBlobPointer> buffers; ///< I/O buffers
+    size_t bufferCapacity; ///< bufferedSize limit
+    size_t bufferedSize; ///< number of log record bytes stored in RAM now
+    size_t flushDebt; ///< how many record bytes we still need to write ASAP
+
+    bool quitOnEmpty; ///< whether this job should quit when buffers are empty
+    bool reconnectScheduled; ///< we are sleeping before the next connection attempt
+    bool writeScheduled; ///< we are waiting for the latest write() results
+
+    Comm::ConnectionPointer conn; ///< opened connection to the remote logger
+    Ip::Address remote; ///< where the remote logger expects our records
+    AsyncCall::Pointer closer; ///< handles unexpected/external conn closures
+
+    uint64_t connectFailures; ///< number of sequential connection failures
+    uint64_t drops; ///< number of records dropped during the current outage
+
+    CBDATA_CLASS2(TcpLogger);
+};
+
+} // namespace Log
+
+#endif /* _SQUID_SRC_LOG_TCPLOGGER_H */
@@ -320,7 +320,7 @@ accessLogInit(void)
         if (log->type == Log::Format::CLF_NONE)
             continue;
 
-        log->logfile = logfileOpen(log->filename, MAX_URL << 2, 1);
+        log->logfile = logfileOpen(log->filename, log->bufferSize, log->fatal);
 
         LogfileStatus = LOG_ENABLE;
 
@@ -237,7 +237,7 @@ peerSelectDnsPaths(ps_state *psstate)
     // on intercepted traffic which failed Host verification
     const HttpRequest *req = psstate->request;
     const bool isIntercepted = !req->flags.redirected &&
-                               (req->flags.intercepted || req->flags.spoofClientIp);
+                               (req->flags.intercepted || req->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || !req->flags.hostVerified;
     const bool choseDirect = fs && fs->code == HIER_DIRECT;
     if (isIntercepted && useOriginalDst && choseDirect) {
@@ -339,7 +339,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
             if (psstate->paths->size() >= (unsigned int)Config.forward_max_tries)
                 break;
 
-            // for TPROXY we must skip unusable addresses.
+            // for TPROXY spoofing we must skip unusable addresses.
             if (psstate->request->flags.spoofClientIp && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
                 if (ia->in_addrs[n].IsIPv4() != psstate->request->client_addr.IsIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
@@ -34,6 +34,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_ipc_TypedMsgHdr.cc \
 	tests/stub_ipcache.cc \
 	tests/stub_libcomm.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
@@ -0,0 +1,25 @@
+#include "squid.h"
+
+#define STUB_API "eui/libeui.la"
+#include "STUB.h"
+
+#include "eui/Config.h"
+Eui::EuiConfig Eui::TheConfig;
+
+#include "eui/Eui48.h"
+#if USE_SQUID_EUI
+const unsigned char *Eui::Eui48::get(void) STUB_RETVAL(NULL)
+bool Eui::Eui48::decode(const char *asc) STUB_RETVAL(false)
+bool Eui::Eui48::encode(char *buf, const int len) STUB_RETVAL(false)
+bool Eui::Eui48::lookup(const Ip::Address &c) STUB_RETVAL(false)
+#endif
+
+#include "eui/Eui64.h"
+#if USE_SQUID_EUI
+const unsigned char *Eui::Eui64::get(void) STUB_RETVAL(NULL)
+bool Eui::Eui64::decode(const char *asc) STUB_RETVAL(false)
+bool Eui::Eui64::encode(char *buf, const int len) STUB_RETVAL(false)
+bool Eui::Eui64::lookup(const Ip::Address &c) STUB_RETVAL(false)
+bool Eui::Eui64::lookupNdp(const Ip::Address &c) STUB_RETVAL(false)
+bool Eui::Eui64::lookupSlaac(const Ip::Address &c) STUB_RETVAL(false)
+#endif
@@ -0,0 +1,19 @@
+#define SQUID_UNIT_TEST 1
+#include "squid.h"
+#include "base/Vector.h"
+#include "tests/testVector.h"
+
+#include <cppunit/TestAssert.h>
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testVector );
+
+void testVector::all()
+{
+    CPPUNIT_ASSERT( 1 == 1 );
+    Vector<int> aArray;
+    CPPUNIT_ASSERT(aArray.size() == 0);
+    aArray.push_back(2);
+    CPPUNIT_ASSERT(aArray.size() == 1);
+    CPPUNIT_ASSERT(aArray.back() == 2);
+    CPPUNIT_ASSERT(aArray.size() == 1);
+}
@@ -1,6 +1,5 @@
-
-#ifndef SQUID_LIB_TEST_ARRAY_H
-#define SQUID_LIB_TEST_ARRAY_H
+#ifndef SQUID_SRC_TESTS_TESTVECTOR_H
+#define SQUID_SRC_TESTS_TESTVECTOR_H
 
 #include <cppunit/extensions/HelperMacros.h>
 
@@ -10,9 +9,9 @@
  *
  */
 
-class testArray : public CPPUNIT_NS::TestFixture
+class testVector : public CPPUNIT_NS::TestFixture
 {
-    CPPUNIT_TEST_SUITE( testArray );
+    CPPUNIT_TEST_SUITE( testVector );
     CPPUNIT_TEST( all );
     CPPUNIT_TEST_SUITE_END();
 
@@ -23,4 +22,3 @@ class testArray : public CPPUNIT_NS::TestFixture
 };
 
 #endif
-
@@ -33,7 +33,7 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "CachePeer.h"
 #include "client_side_request.h"
 #include "client_side.h"
@@ -553,7 +553,7 @@ tunnelConnected(const Comm::ConnectionPointer &server, void *data)
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << server << ", tunnelState=" << tunnelState);
 
-    if (tunnelState->request && (tunnelState->request->flags.spoofClientIp || tunnelState->request->flags.intercepted))
+    if (tunnelState->request && (tunnelState->request->flags.interceptTproxy || tunnelState->request->flags.intercepted))
         tunnelStartShoveling(tunnelState); // ssl-bumped connection, be quiet
     else {
         AsyncCall::Pointer call = commCbCall(5,5, "tunnelConnectedWriteDone",