diff --git a/ChangeLog b/ChangeLog
index 9e2e394..d4d28bc 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+1999-07-28  Paul D. Smith  <psmith@gnu.org>
+
+	* make.h: Define _() and N_() macros as a passthrough to initiate
+	NLS support.
+	* <all>: Add _()/N_() around translatable strings.
+
+1999-07-27  Paul D. Smith  <psmith@gnu.org>
+
+	* read.c: Make sure make.h comes before other headers.
+
 1999-07-26  Paul D. Smith  <psmith@gnu.org>
 
 	* make.texinfo (Quick Reference): Update with the new features.
diff --git a/ar.c b/ar.c
index 9ca1e15..2e16435 100644
--- a/ar.c
+++ b/ar.c
@@ -47,7 +47,7 @@ ar_name (name)
     return 0;
 
   if (p[1] == '(' && end[-1] == ')')
-    fatal (NILF, "attempt to use unsupported feature: `%s'", name);
+    fatal (NILF, _("attempt to use unsupported feature: `%s'"), name);
 
   return 1;
 }
@@ -138,7 +138,7 @@ int
 ar_touch (name)
      char *name;
 {
-  error (NILF, "touch archive member is not available on VMS");
+  error (NILF, _("touch archive member is not available on VMS"));
   return -1;
 }
 #else
@@ -170,24 +170,24 @@ ar_touch (name)
   switch (ar_member_touch (arname, memname))
     {
     case -1:
-      error (NILF, "touch: Archive `%s' does not exist", arname);
+      error (NILF, _("touch: Archive `%s' does not exist"), arname);
       break;
     case -2:
-      error (NILF, "touch: `%s' is not a valid archive", arname);
+      error (NILF, _("touch: `%s' is not a valid archive"), arname);
       break;
     case -3:
       perror_with_name ("touch: ", arname);
       break;
     case 1:
       error (NILF,
-             "touch: Member `%s' does not exist in `%s'", memname, arname);
+             _("touch: Member `%s' does not exist in `%s'"), memname, arname);
       break;
     case 0:
       val = 0;
       break;
     default:
       error (NILF,
-             "touch: Bad return code from ar_member_touch on `%s'", name);
+             _("touch: Bad return code from ar_member_touch on `%s'"), name);
     }
 
   if (!arname_used)
diff --git a/arscan.c b/arscan.c
index 908be7f..cc9b9fd 100644
--- a/arscan.c
+++ b/arscan.c
@@ -70,7 +70,7 @@ VMS_get_member_info (module, rfa)
 			   &bufdesc.dsc$w_length, 0);
   if (! status)
     {
-      error (NILF, "lbr$set_module failed to extract module info, status = %d",
+      error (NILF, _("lbr$set_module failed to extract module info, status = %d"),
 	     status);
 
       lbr$close (&VMS_lib_idx);
@@ -152,7 +152,7 @@ ar_scan (archive, function, arg)
 
   if (! status)
     {
-      error (NILF, "lbr$ini_control failed with status = %d",status);
+      error (NILF, _("lbr$ini_control failed with status = %d"),status);
       return -2;
     }
 
@@ -163,7 +163,7 @@ ar_scan (archive, function, arg)
 
   if (! status)
     {
-      error (NILF, "unable to open library `%s' to lookup member `%s'",
+      error (NILF, _("unable to open library `%s' to lookup member `%s'"),
 	     archive, (char *)arg);
       return -1;
     }
@@ -820,11 +820,11 @@ describe_member (desc, name, truncated,
 {
   extern char *ctime ();
 
-  printf ("Member `%s'%s: %ld bytes at %ld (%ld).\n",
-	  name, truncated ? " (name might be truncated)" : "",
+  printf (_("Member `%s'%s: %ld bytes at %ld (%ld).\n"),
+	  name, truncated ? _(" (name might be truncated)") : "",
 	  size, hdrpos, datapos);
-  printf ("  Date %s", ctime (&date));
-  printf ("  uid = %d, gid = %d, mode = 0%o.\n", uid, gid, mode);
+  printf (_("  Date %s"), ctime (&date));
+  printf (_("  uid = %d, gid = %d, mode = 0%o.\n"), uid, gid, mode);
 
   return 0;
 }
diff --git a/commands.c b/commands.c
index 1864bfe..34c0cc6 100644
--- a/commands.c
+++ b/commands.c
@@ -386,7 +386,7 @@ fatal_error_signal (sig)
 #ifdef _AMIGA
   remove_intermediates (1);
   if (sig == SIGINT)
-     fputs ("*** Break.\n", stderr);
+     fputs (_("*** Break.\n"), stderr);
 
   exit (10);
 #else /* not Amiga */
@@ -478,10 +478,10 @@ delete_target (file, on_behalf_of)
       if (ar_member_date (file->name) != FILE_TIMESTAMP_S (file->last_mtime))
 	{
 	  if (on_behalf_of)
-	    error (NILF, "*** [%s] Archive member `%s' may be bogus; not deleted",
+	    error (NILF, _("*** [%s] Archive member `%s' may be bogus; not deleted"),
 		   on_behalf_of, file->name);
 	  else
-	    error (NILF, "*** Archive member `%s' may be bogus; not deleted",
+	    error (NILF, _("*** Archive member `%s' may be bogus; not deleted"),
 		   file->name);
 	}
       return;
@@ -493,9 +493,9 @@ delete_target (file, on_behalf_of)
       && FILE_TIMESTAMP_STAT_MODTIME (st) != file->last_mtime)
     {
       if (on_behalf_of)
-	error (NILF, "*** [%s] Deleting file `%s'", on_behalf_of, file->name);
+	error (NILF, _("*** [%s] Deleting file `%s'"), on_behalf_of, file->name);
       else
-	error (NILF, "*** Deleting file `%s'", file->name);
+	error (NILF, _("*** Deleting file `%s'"), file->name);
       if (unlink (file->name) < 0
 	  && errno != ENOENT)	/* It disappeared; so what.  */
 	perror_with_name ("unlink: ", file->name);
@@ -533,12 +533,12 @@ print_commands (cmds)
 {
   register char *s;
 
-  fputs ("#  commands to execute", stdout);
+  fputs (_("#  commands to execute"), stdout);
 
   if (cmds->fileinfo.filenm == 0)
-    puts (" (built-in):");
+    puts (_(" (built-in):"));
   else
-    printf (" (from `%s', line %lu):\n",
+    printf (_(" (from `%s', line %lu):\n"),
             cmds->fileinfo.filenm, cmds->fileinfo.lineno);
 
   s = cmds->commands;
diff --git a/dir.c b/dir.c
index 0d0f078..cb25c18 100644
--- a/dir.c
+++ b/dir.c
@@ -884,7 +884,7 @@ print_dir_data_base ()
   register unsigned int i, dirs, files, impossible;
   register struct directory *dir;
 
-  puts ("\n# Directories\n");
+  puts (_("\n# Directories\n"));
 
   dirs = files = impossible = 0;
   for (i = 0; i < DIRECTORY_BUCKETS; ++i)
@@ -892,19 +892,19 @@ print_dir_data_base ()
       {
 	++dirs;
 	if (dir->contents == 0)
-	  printf ("# %s: could not be stat'd.\n", dir->name);
+	  printf (_("# %s: could not be stat'd.\n"), dir->name);
 	else if (dir->contents->files == 0)
 #ifdef WINDOWS32
-          printf ("# %s (key %s, mtime %d): could not be opened.\n",
+          printf (_("# %s (key %s, mtime %d): could not be opened.\n"),
                   dir->name, dir->contents->path_key,dir->contents->mtime);
 #else  /* WINDOWS32 */
 #ifdef VMS
-	  printf ("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n",
+	  printf (_("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n"),
 		  dir->name, dir->contents->dev,
 		  dir->contents->ino[0], dir->contents->ino[1],
 		  dir->contents->ino[2]);
 #else
-	  printf ("# %s (device %ld, inode %ld): could not be opened.\n",
+	  printf (_("# %s (device %ld, inode %ld): could not be opened.\n"),
 		  dir->name, (long int) dir->contents->dev,
 		  (long int) dir->contents->ino);
 #endif
@@ -921,34 +921,34 @@ print_dir_data_base ()
 		else
 		  ++f;
 #ifdef WINDOWS32
-            printf ("# %s (key %s, mtime %d): ",
+            printf (_("# %s (key %s, mtime %d): "),
                     dir->name, dir->contents->path_key, dir->contents->mtime);
 #else  /* WINDOWS32 */
 #ifdef VMS
-	    printf ("# %s (device %d, inode [%d,%d,%d]): ",
+	    printf (_("# %s (device %d, inode [%d,%d,%d]): "),
 		    dir->name, dir->contents->dev,
 			dir->contents->ino[0], dir->contents->ino[1],
 			dir->contents->ino[2]);
 #else
-	    printf ("# %s (device %ld, inode %ld): ",
+	    printf (_("# %s (device %ld, inode %ld): "),
 		    dir->name,
                     (long)dir->contents->dev, (long)dir->contents->ino);
 #endif
 #endif /* WINDOWS32 */
 	    if (f == 0)
-	      fputs ("No", stdout);
+	      fputs (_("No"), stdout);
 	    else
 	      printf ("%u", f);
-	    fputs (" files, ", stdout);
+	    fputs (_(" files, "), stdout);
 	    if (im == 0)
-	      fputs ("no", stdout);
+	      fputs (_("no"), stdout);
 	    else
 	      printf ("%u", im);
-	    fputs (" impossibilities", stdout);
+	    fputs (_(" impossibilities"), stdout);
 	    if (dir->contents->dirstream == 0)
 	      puts (".");
 	    else
-	      puts (" so far.");
+	      puts (_(" so far."));
 	    files += f;
 	    impossible += im;
 	  }
@@ -956,15 +956,15 @@ print_dir_data_base ()
 
   fputs ("\n# ", stdout);
   if (files == 0)
-    fputs ("No", stdout);
+    fputs (_("No"), stdout);
   else
     printf ("%u", files);
-  fputs (" files, ", stdout);
+  fputs (_(" files, "), stdout);
   if (impossible == 0)
-    fputs ("no", stdout);
+    fputs (_("no"), stdout);
   else
     printf ("%u", impossible);
-  printf (" impossibilities in %u directories.\n", dirs);
+  printf (_(" impossibilities in %u directories.\n"), dirs);
 }
 
 /* Hooks for globbing.  */
diff --git a/expand.c b/expand.c
index 0b1d41d..29e3674 100644
--- a/expand.c
+++ b/expand.c
@@ -98,7 +98,8 @@ recursively_expand (v)
   if (v->expanding)
     /* Expanding V causes infinite recursion.  Lose.  */
     fatal (reading_file,
-           "Recursive variable `%s' references itself (eventually)", v->name);
+           _("Recursive variable `%s' references itself (eventually)"),
+           v->name);
 
   v->expanding = 1;
   value = allocated_variable_expand (v->value);
@@ -119,7 +120,7 @@ warn_undefined (name, length)
 {
   if (warn_undefined_variables_flag)
     error (reading_file,
-           "warning: undefined variable `%.*s'", (int)length, name);
+           _("warning: undefined variable `%.*s'"), (int)length, name);
 }
 
 /* Expand a simple reference to variable NAME, which is LENGTH chars long.  */
@@ -231,7 +232,7 @@ variable_expand_string (line, string, length)
 	    end = index (beg, closeparen);
 	    if (end == 0)
               /* Unterminated variable reference.  */
-              fatal (reading_file, "unterminated variable reference");
+              fatal (reading_file, _("unterminated variable reference"));
 	    p1 = lindex (beg, end, '$');
 	    if (p1 != 0)
 	      {
diff --git a/file.c b/file.c
index 65f3e2d..411f517 100644
--- a/file.c
+++ b/file.c
@@ -301,22 +301,22 @@ file_hash_enter (file, name, oldhash, oldname)
 		 but give a message to let the user know what's going on.  */
 	      if (oldfile->cmds->fileinfo.filenm != 0)
                 error (&file->cmds->fileinfo,
-                                "Commands were specified for \
-file `%s' at %s:%lu,",
+                                _("Commands were specified for \
+file `%s' at %s:%lu,"),
                                 oldname, oldfile->cmds->fileinfo.filenm,
                                 oldfile->cmds->fileinfo.lineno);
 	      else
 		error (&file->cmds->fileinfo,
-				"Commands for file `%s' were found by \
-implicit rule search,",
+				_("Commands for file `%s' were found by \
+implicit rule search,"),
 				oldname);
 	      error (&file->cmds->fileinfo,
-			      "but `%s' is now considered the same file \
-as `%s'.",
+			      _("but `%s' is now considered the same file \
+as `%s'."),
 			      oldname, name);
 	      error (&file->cmds->fileinfo,
-			      "Commands for `%s' will be ignored \
-in favor of those for `%s'.",
+			      _("Commands for `%s' will be ignored \
+in favor of those for `%s'."),
 			      name, oldname);
 	    }
 	}
@@ -336,12 +336,12 @@ in favor of those for `%s'.",
       merge_variable_set_lists (&oldfile->variables, file->variables);
 
       if (oldfile->double_colon && file->is_target && !file->double_colon)
-	fatal (NILF, "can't rename single-colon `%s' to double-colon `%s'",
+	fatal (NILF, _("can't rename single-colon `%s' to double-colon `%s'"),
 	       oldname, name);
       if (!oldfile->double_colon  && file->double_colon)
 	{
 	  if (oldfile->is_target)
-	    fatal (NILF, "can't rename double-colon `%s' to single-colon `%s'",
+	    fatal (NILF, _("can't rename double-colon `%s' to single-colon `%s'"),
 		   oldname, name);
 	  else
 	    oldfile->double_colon = file->double_colon;
@@ -408,7 +408,7 @@ remove_intermediates (sig)
 	  if (!f->dontcare)
 	    {
 	      if (sig)
-		error (NILF, "*** Deleting intermediate file `%s'", f->name);
+		error (NILF, _("*** Deleting intermediate file `%s'"), f->name);
 	      else if (!silent_flag)
 		{
 		  if (! doneany)
@@ -612,7 +612,7 @@ print_file (f)
 
   putchar ('\n');
   if (!f->is_target)
-    puts ("# Not a target:");
+    puts (_("# Not a target:"));
   printf ("%s:%s", f->name, f->double_colon ? ":" : "");
 
   for (d = f->deps; d != 0; d = d->next)
@@ -620,45 +620,45 @@ print_file (f)
   putchar ('\n');
 
   if (f->precious)
-    puts ("#  Precious file (dependency of .PRECIOUS).");
+    puts (_("#  Precious file (dependency of .PRECIOUS)."));
   if (f->phony)
-    puts ("#  Phony target (dependency of .PHONY).");
+    puts (_("#  Phony target (dependency of .PHONY)."));
   if (f->cmd_target)
-    puts ("#  Command-line target.");
+    puts (_("#  Command-line target."));
   if (f->dontcare)
-    puts ("#  A default or MAKEFILES makefile.");
-  printf ("#  Implicit rule search has%s been done.\n",
-	  f->tried_implicit ? "" : " not");
+    puts (_("#  A default or MAKEFILES makefile."));
+  printf (_("#  Implicit rule search has%s been done.\n"),
+	  f->tried_implicit ? "" : _(" not"));
   if (f->stem != 0)
-    printf ("#  Implicit/static pattern stem: `%s'\n", f->stem);
+    printf (_("#  Implicit/static pattern stem: `%s'\n"), f->stem);
   if (f->intermediate)
-    puts ("#  File is an intermediate dependency.");
+    puts (_("#  File is an intermediate dependency."));
   if (f->also_make != 0)
     {
-      fputs ("#  Also makes:", stdout);
+      fputs (_("#  Also makes:"), stdout);
       for (d = f->also_make; d != 0; d = d->next)
 	printf (" %s", dep_name (d));
       putchar ('\n');
     }
   if (f->last_mtime == 0)
-    puts ("#  Modification time never checked.");
+    puts (_("#  Modification time never checked."));
   else if (f->last_mtime == (FILE_TIMESTAMP) -1)
-    puts ("#  File does not exist.");
+    puts (_("#  File does not exist."));
   else
     {
       char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
       file_timestamp_sprintf (buf, f->last_mtime);
-      printf ("#  Last modified %s\n", buf);
+      printf (_("#  Last modified %s\n"), buf);
     }
-  printf ("#  File has%s been updated.\n",
-	  f->updated ? "" : " not");
+  printf (_("#  File has%s been updated.\n"),
+	  f->updated ? "" : _(" not"));
   switch (f->command_state)
     {
     case cs_running:
-      puts ("#  Commands currently running (THIS IS A BUG).");
+      puts (_("#  Commands currently running (THIS IS A BUG)."));
       break;
     case cs_deps_running:
-      puts ("#  Dependencies commands running (THIS IS A BUG).");
+      puts (_("#  Dependencies commands running (THIS IS A BUG)."));
       break;
     case cs_not_started:
     case cs_finished:
@@ -667,24 +667,24 @@ print_file (f)
 	case -1:
 	  break;
 	case 0:
-	  puts ("#  Successfully updated.");
+	  puts (_("#  Successfully updated."));
 	  break;
 	case 1:
 	  assert (question_flag);
-	  puts ("#  Needs to be updated (-q is set).");
+	  puts (_("#  Needs to be updated (-q is set)."));
 	  break;
 	case 2:
-	  puts ("#  Failed to be updated.");
+	  puts (_("#  Failed to be updated."));
 	  break;
 	default:
-	  puts ("#  Invalid value in `update_status' member!");
+	  puts (_("#  Invalid value in `update_status' member!"));
 	  fflush (stdout);
 	  fflush (stderr);
 	  abort ();
 	}
       break;
     default:
-      puts ("#  Invalid value in `command_state' member!");
+      puts (_("#  Invalid value in `command_state' member!"));
       fflush (stdout);
       fflush (stderr);
       abort ();
@@ -703,7 +703,7 @@ print_file_data_base ()
   register unsigned int i, nfiles, per_bucket;
   register struct file *file;
 
-  puts ("\n# Files");
+  puts (_("\n# Files"));
 
   per_bucket = nfiles = 0;
   for (i = 0; i < FILE_BUCKETS; ++i)
@@ -726,12 +726,12 @@ print_file_data_base ()
     }
 
   if (nfiles == 0)
-    puts ("\n# No files.");
+    puts (_("\n# No files."));
   else
     {
-      printf ("\n# %u files in %u hash buckets.\n", nfiles, FILE_BUCKETS);
+      printf (_("\n# %u files in %u hash buckets.\n"), nfiles, FILE_BUCKETS);
 #ifndef	NO_FLOAT
-      printf ("# average %.3f files per bucket, max %u files in one bucket.\n",
+      printf (_("# average %.3f files per bucket, max %u files in one bucket.\n"),
 	      ((double) nfiles) / ((double) FILE_BUCKETS), per_bucket);
 #endif
     }
diff --git a/function.c b/function.c
index 394d3c1..d5ceb78 100644
--- a/function.c
+++ b/function.c
@@ -735,11 +735,11 @@ func_word(o, argv, funcname)
   char *p=0;
 
   /* Check the first argument.  */
-  check_numeric (argv[0], "non-numeric first argument to `word' function");
+  check_numeric (argv[0], _("non-numeric first argument to `word' function"));
   i =  atoi (argv[0]);
 
   if (i == 0)
-    fatal (reading_file, "the `word' function takes a positive index argument");
+    fatal (reading_file, _("the `word' function takes a positive index argument"));
 
 
   end_p = argv[1];
@@ -764,10 +764,10 @@ func_wordlist (o, argv, funcname)
 
   /* Check the first argument.  */
   check_numeric (argv[0],
-		 "non-numeric first argument to `wordlist' function");
+		 _("non-numeric first argument to `wordlist' function"));
   i =atoi(argv[0]);
   check_numeric (argv[1],
-		 "non-numeric second argument to `wordlist' function");
+		 _("non-numeric second argument to `wordlist' function"));
 
   j = atoi(argv[1]);
 
@@ -1156,7 +1156,7 @@ windows32_openpipe (int *pipedes, int *pid_p, char **command_argv, char **envp)
 		      0,
 		      TRUE,
 		      DUPLICATE_SAME_ACCESS) == FALSE) {
-    fatal (NILF, "create_child_process: DuplicateHandle(In) failed (e=%d)\n",
+    fatal (NILF, _("create_child_process: DuplicateHandle(In) failed (e=%d)\n"),
 	   GetLastError());
 
   }
@@ -1167,19 +1167,19 @@ windows32_openpipe (int *pipedes, int *pid_p, char **command_argv, char **envp)
 		      0,
 		      TRUE,
 		      DUPLICATE_SAME_ACCESS) == FALSE) {
-    fatal (NILF, "create_child_process: DuplicateHandle(Err) failed (e=%d)\n",
+    fatal (NILF, _("create_child_process: DuplicateHandle(Err) failed (e=%d)\n"),
 	   GetLastError());
   }
 
   if (!CreatePipe(&hChildOutRd, &hChildOutWr, &saAttr, 0))
-    fatal (NILF, "CreatePipe() failed (e=%d)\n", GetLastError());
+    fatal (NILF, _("CreatePipe() failed (e=%d)\n"), GetLastError());
 
 
 
   hProcess = process_init_fd(hIn, hChildOutWr, hErr);
 
   if (!hProcess)
-    fatal (NILF, "windows32_openpipe (): process_init_fd() failed\n");
+    fatal (NILF, _("windows32_openpipe (): process_init_fd() failed\n"));
 
   else
     process_register(hProcess);
@@ -1190,7 +1190,7 @@ windows32_openpipe (int *pipedes, int *pid_p, char **command_argv, char **envp)
   if (!process_begin(hProcess, command_argv, envp, command_argv[0], NULL))
     *pid_p = (int) hProcess;
   else
-    fatal (NILF, "windows32_openpipe (): unable to launch process (e=%d)\n",
+    fatal (NILF, _("windows32_openpipe (): unable to launch process (e=%d)\n"),
 	   process_last_err(hProcess));
 
   /* set up to read data from child */
@@ -1405,7 +1405,7 @@ func_shell (o, argv, funcname)
 
       if (batch_filename) {
 	if (debug_flag)
-	  printf("Cleaning up temporary batch file %s\n", batch_filename);
+	  printf(_("Cleaning up temporary batch file %s\n"), batch_filename);
 	remove(batch_filename);
 	free(batch_filename);
       }
@@ -1676,11 +1676,11 @@ expand_builtin_function (o, argc, argv, entry_p)
 
   if (argc < min)
     fatal (reading_file,
-           "Insufficient number of arguments (%d) to function `%s'",
+           _("Insufficient number of arguments (%d) to function `%s'"),
            argc, entry_p->name);
 
   if (!entry_p->func_ptr)
-    fatal (reading_file, "Unimplemented on this platform: function `%s'",
+    fatal (reading_file, _("Unimplemented on this platform: function `%s'"),
            entry_p->name);
 
   return entry_p->func_ptr (o, argv, entry_p->name);
@@ -1736,7 +1736,7 @@ handle_function (op, stringp)
 
   if (count >= 0)
     fatal (reading_file,
-	   "unterminated call to function `%s': missing `%c'",
+	   _("unterminated call to function `%s': missing `%c'"),
 	   entry_p->name, closeparen);
 
   /* Get some memory to store the arg pointers.  */
diff --git a/implicit.c b/implicit.c
index 91b6b98..ceb2571 100644
--- a/implicit.c
+++ b/implicit.c
@@ -36,7 +36,7 @@ try_implicit_rule (file, depth)
      struct file *file;
      unsigned int depth;
 {
-  DEBUGPR ("Looking for an implicit rule for `%s'.\n");
+  DEBUGPR (_("Looking for an implicit rule for `%s'.\n"));
 
   /* The order of these searches was previously reversed.  My logic now is
      that since the non-archive search uses more information in the target
@@ -51,7 +51,7 @@ try_implicit_rule (file, depth)
      archive member name to search for implicit rules.  */
   if (ar_name (file->name))
     {
-      DEBUGPR ("Looking for archive-member implicit rule for `%s'.\n");
+      DEBUGPR (_("Looking for archive-member implicit rule for `%s'.\n"));
       if (pattern_search (file, 1, depth, 0))
 	return 1;
     }
@@ -199,7 +199,7 @@ pattern_search (file, archive, depth, recursions)
 	 don't use it here.  */
       if (rule->in_use)
 	{
-	  DEBUGP2 ("Avoiding implicit rule recursion.%s%s\n", "", "");
+	  DEBUGP2 (_("Avoiding implicit rule recursion.%s%s\n"), "", "");
 	  continue;
 	}
 
@@ -335,7 +335,7 @@ pattern_search (file, archive, depth, recursions)
 	      stemlen -= (lastslash - filename) + 1;
 	    }
 
-	  DEBUGP2 ("Trying pattern rule with stem `%.*s'.\n",
+	  DEBUGP2 (_("Trying pattern rule with stem `%.*s'.\n"),
 		   (int) stemlen, stem);
 
 	  /* Try each dependency; see if it "exists".  */
@@ -376,16 +376,16 @@ pattern_search (file, archive, depth, recursions)
 		     "impossible", then the rule fails and don't
 		     bother trying it on the second pass either
 		     since we know that will fail too.  */
-		  DEBUGP2 ("Rejecting impossible %s dependency `%s'.\n",
-			   p == depname ? "implicit" : "rule", p);
+		  DEBUGP2 (_("Rejecting impossible %s dependency `%s'.\n"),
+			   p == depname ? _("implicit") : _("rule"), p);
 		  tryrules[i] = 0;
 		  break;
 		}
 
 	      intermediate_files[deps_found] = 0;
 
-	      DEBUGP2 ("Trying %s dependency `%s'.\n",
-		       p == depname ? "implicit" : "rule", p);
+	      DEBUGP2 (_("Trying %s dependency `%s'.\n"),
+		       p == depname ? _("implicit") : _("rule"), p);
 
 	      /* The DEP->changed flag says that this dependency resides in a
 		 nonexistent directory.  So we normally can skip looking for
@@ -408,7 +408,7 @@ pattern_search (file, archive, depth, recursions)
 	      vp = p;
 	      if (vpath_search (&vp, (FILE_TIMESTAMP *) 0))
 		{
-		  DEBUGP2 ("Found dependency `%s' as VPATH `%s'\n", p, vp);
+		  DEBUGP2 (_("Found dependency `%s' as VPATH `%s'\n"), p, vp);
 		  strcpy(vp, p);
 		  found_files[deps_found++] = vp;
 		  continue;
@@ -424,8 +424,8 @@ pattern_search (file, archive, depth, recursions)
 		    intermediate_file
 		      = (struct file *) alloca (sizeof (struct file));
 
-		  DEBUGP2 ("Looking for a rule with %s file `%s'.\n",
-			   "intermediate", p);
+		  DEBUGP2 (_("Looking for a rule with %s file `%s'.\n"),
+			   _("intermediate"), p);
 
 		  bzero ((char *) intermediate_file, sizeof (struct file));
 		  intermediate_file->name = p;
diff --git a/job.c b/job.c
index 2695bea..585c35e 100644
--- a/job.c
+++ b/job.c
@@ -243,7 +243,7 @@ free_job_token (child)
   }
 
   if (debug_flag)
-    printf ("Released token `%c' for child 0x%08lx (%s).\n",
+    printf (_("Released token `%c' for child 0x%08lx (%s).\n"),
             child->job_token, (unsigned long int) child, child->file->name);
 
   child->job_token = '-';
@@ -266,16 +266,16 @@ child_error (target_name, exit_code, exit_sig, coredump, ignored)
 
 #ifdef VMS
   if (!(exit_code & 1))
-      error (NILF, "*** [%s] Error 0x%x%s", target_name, exit_code, ((ignored)? " (ignored)" : ""));
+      error (NILF, _("*** [%s] Error 0x%x%s"), target_name, exit_code, ((ignored)? _(" (ignored)") : ""));
 #else
   if (exit_sig == 0)
-    error (NILF, ignored ? "[%s] Error %d (ignored)" :
-	   "*** [%s] Error %d",
+    error (NILF, ignored ? _("[%s] Error %d (ignored)") :
+	   _("*** [%s] Error %d"),
 	   target_name, exit_code);
   else
     error (NILF, "*** [%s] %s%s",
 	   target_name, strsignal (exit_sig),
-	   coredump ? " (core dumped)" : "");
+	   coredump ? _(" (core dumped)") : "");
 #endif /* VMS */
 }
 
@@ -315,7 +315,7 @@ child_handler (sig)
   ++dead_children;
 
   if (debug_flag)
-    printf ("Got a SIGCHLD; %u unreaped children.\n", dead_children);
+    printf (_("Got a SIGCHLD; %u unreaped children.\n"), dead_children);
 }
 
 
@@ -354,7 +354,7 @@ reap_children (block, err)
 	{
 	  /* We might block for a while, so let the user know why.  */
 	  fflush (stdout);
-	  error (NILF, "*** Waiting for unfinished jobs....");
+	  error (NILF, _("*** Waiting for unfinished jobs...."));
 	}
 
       /* We have one less dead child to reap.  As noted in
@@ -384,10 +384,10 @@ reap_children (block, err)
 	  any_remote |= c->remote;
 	  any_local |= ! c->remote;
 	  if (debug_flag)
-	    printf ("Live child 0x%08lx (%s) PID %ld token %c%s\n",
+	    printf (_("Live child 0x%08lx (%s) PID %ld token %c%s\n"),
 		    (unsigned long int) c, c->file->name,
                     (long) c->pid, c->job_token,
-                    c->remote ? " (remote)" : "");
+                    c->remote ? _(" (remote)") : "");
 #ifdef VMS
 	  break;
 #endif
@@ -547,14 +547,14 @@ reap_children (block, err)
         continue;
 
       if (debug_flag)
-        printf ("Reaping %s child 0x%08lx PID %ld token %c%s\n",
-                child_failed ? "losing" : "winning",
+        printf (_("Reaping %s child 0x%08lx PID %ld token %c%s\n"),
+                child_failed ? _("losing") : _("winning"),
                 (unsigned long int) c, (long) c->pid, c->job_token,
-                c->remote ? " (remote)" : "");
+                c->remote ? _(" (remote)") : "");
 
       if (c->sh_batch_file) {
         if (debug_flag)
-          printf ("Cleaning up temp batch file %s\n", c->sh_batch_file);
+          printf (_("Cleaning up temp batch file %s\n"), c->sh_batch_file);
 
         /* just try and remove, don't care if this fails */
         remove (c->sh_batch_file);
@@ -647,9 +647,9 @@ reap_children (block, err)
         notice_finished_file (c->file);
 
       if (debug_flag)
-        printf ("Removing child 0x%08lx PID %ld token %c%s from chain.\n",
+        printf (_("Removing child 0x%08lx PID %ld token %c%s from chain.\n"),
                 (unsigned long int) c, (long) c->pid, c->job_token,
-                c->remote ? " (remote)" : "");
+                c->remote ? _(" (remote)") : "");
 
       /* Block fatal signals while frobnicating the list, so that
          children and job_slots_used are always consistent.  Otherwise
@@ -1122,11 +1122,11 @@ start_job_command (child)
         int i;
         unblock_sigs();
         fprintf(stderr,
-          "process_easy() failed failed to launch process (e=%d)\n",
+          _("process_easy() failed failed to launch process (e=%d)\n"),
           process_last_err(hPID));
                for (i = 0; argv[i]; i++)
                  fprintf(stderr, "%s ", argv[i]);
-               fprintf(stderr, "\nCounted %d args in failed launch\n", i);
+               fprintf(stderr, _("\nCounted %d args in failed launch\n"), i);
       }
   }
 #endif /* WINDOWS32 */
@@ -1208,7 +1208,7 @@ start_waiting_job (c)
                       /* We should definitely handle this more gracefully!
                          What kinds of things can happen here?  ^C closes the
                          pipe?  Something else closes it?  */
-                      pfatal_with_name ("read jobs pipe");
+                      pfatal_with_name (_("read jobs pipe"));
 #endif
                     /* We were interrupted; handle any dead children.  */
                     reap_children (1, 0);
@@ -1217,7 +1217,7 @@ start_waiting_job (c)
 
           assert(c->job_token != '-');
 	  if (debug_flag)
-	    printf ("Obtained token `%c' for child 0x%08lx (%s).\n",
+	    printf (_("Obtained token `%c' for child 0x%08lx (%s).\n"),
 		    c->job_token, (unsigned long int) c, c->file->name);
 	}
 #endif
@@ -1242,10 +1242,10 @@ start_waiting_job (c)
     case cs_running:
       c->next = children;
       if (debug_flag)
-	printf ("Putting child 0x%08lx (%s) PID %ld token %c%s on the chain.\n",
+	printf (_("Putting child 0x%08lx (%s) PID %ld token %c%s on the chain.\n"),
 		(unsigned long int) c, c->file->name,
                 (long) c->pid, c->job_token,
-                c->remote ? " (remote)" : "");
+                c->remote ? _(" (remote)") : "");
       children = c;
       /* One more job slot is in use.  */
       ++job_slots_used;
@@ -1469,9 +1469,9 @@ load_too_high ()
 	{
 	  if (errno == 0)
 	    /* An errno value of zero means getloadavg is just unsupported.  */
-	    error (NILF, "cannot enforce load limits on this operating system");
+	    error (NILF, _("cannot enforce load limits on this operating system"));
 	  else
-	    perror_with_name ("cannot enforce load limit: ", "getloadavg");
+	    perror_with_name (_("cannot enforce load limit: "), "getloadavg");
 	}
       lossage = errno;
       load = 0;
@@ -1574,7 +1574,7 @@ int vmsHandleChildTerm(struct child *child)
 	    break;
 
 	  default:
-	    error (NILF, "internal error: `%s' command_state", c->file->name);
+	    error (NILF, _("internal error: `%s' command_state"), c->file->name);
 	    abort ();
 	    break;
 	  }
@@ -1680,7 +1680,7 @@ child_execute_job (argv, child)
       sprintf (cmd, "$ @%s", comname);
 
       if (debug_flag)
-	printf ("Executing %s instead\n", cmd);
+	printf (_("Executing %s instead\n"), cmd);
     }
 
   cmddsc.dsc$w_length = strlen(cmd);
@@ -1711,7 +1711,7 @@ child_execute_job (argv, child)
 
   if (!(status & 1))
     {
-      printf("Error spawning, %d\n",status);
+      printf(_("Error spawning, %d\n"),status);
       fflush(stdout);
     }
 
@@ -1780,11 +1780,11 @@ exec_command (argv, envp)
     {
       int i;
       fprintf(stderr,
-              "process_easy() failed failed to launch process (e=%d)\n",
+              _("process_easy() failed failed to launch process (e=%d)\n"),
               process_last_err(hPID));
       for (i = 0; argv[i]; i++)
           fprintf(stderr, "%s ", argv[i]);
-      fprintf(stderr, "\nCounted %d args in failed launch\n", i);
+      fprintf(stderr, _("\nCounted %d args in failed launch\n"), i);
       exit(EXIT_FAILURE);
     }
 
@@ -1809,7 +1809,7 @@ exec_command (argv, envp)
           break;
       else
           fprintf(stderr,
-                  "make reaped child pid %d, still waiting for pid %d\n",
+                  _("make reaped child pid %d, still waiting for pid %d\n"),
                   hWaitPID, hPID);
     }
 
@@ -1828,7 +1828,7 @@ exec_command (argv, envp)
   switch (errno)
     {
     case ENOENT:
-      error (NILF, "%s: Command not found", argv[0]);
+      error (NILF, _("%s: Command not found"), argv[0]);
       break;
     case ENOEXEC:
       {
@@ -1857,7 +1857,7 @@ exec_command (argv, envp)
 
 	execvp (shell, new_argv);
 	if (errno == ENOENT)
-	  error (NILF, "%s: Shell program not found", shell);
+	  error (NILF, _("%s: Shell program not found"), shell);
 	else
 	  perror_with_name ("execvp: ", shell);
 	break;
@@ -2037,7 +2037,7 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
     {
       extern int _is_unixy_shell (const char *_path);
 
-      message (1, "$SHELL changed (was `%s', now `%s')", default_shell, shell);
+      message (1, _("$SHELL changed (was `%s', now `%s')"), default_shell, shell);
       unixy_shell = _is_unixy_shell (shell);
       default_shell = shell;
     }
@@ -2439,7 +2439,7 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
       }
 
       if (debug_flag)
-        printf("Creating temporary batch file %s\n", *batch_filename_ptr);
+        printf(_("Creating temporary batch file %s\n"), *batch_filename_ptr);
 
       /* create batch file to execute command */
       batch = fopen (*batch_filename_ptr, "w");
@@ -2480,7 +2480,7 @@ construct_command_argv_internal (line, restp, shell, ifs, batch_filename_ptr)
       }
 #else
     else
-      fatal (NILF, "%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n",
+      fatal (NILF, _("%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n"),
             __FILE__, __LINE__);
 #endif
   }
diff --git a/main.c b/main.c
index f2ec3c9..75c86a0 100644
--- a/main.c
+++ b/main.c
@@ -249,33 +249,33 @@ static const struct command_switch switches[] =
   {
     { 'b', ignore, 0, 0, 0, 0, 0, 0,
 	0, 0,
-	"Ignored for compatibility" },
+	_("Ignored for compatibility") },
     { 'C', string, (char *) &directories, 0, 0, 0, 0, 0,
 	"directory", "DIRECTORY",
-	"Change to DIRECTORY before doing anything" },
+	_("Change to DIRECTORY before doing anything") },
     { 'd', flag, (char *) &debug_flag, 1, 1, 0, 0, 0,
 	"debug", 0,
-	"Print lots of debugging information" },
+	_("Print lots of debugging information") },
 #ifdef WINDOWS32
     { 'D', flag, (char *) &suspend_flag, 1, 1, 0, 0, 0,
         "suspend-for-debug", 0,
-        "Suspend process to allow a debugger to attach" },
+        _("Suspend process to allow a debugger to attach") },
 #endif
     { 'e', flag, (char *) &env_overrides, 1, 1, 0, 0, 0,
 	"environment-overrides", 0,
-	"Environment variables override makefiles" },
+	_("Environment variables override makefiles") },
     { 'f', string, (char *) &makefiles, 0, 0, 0, 0, 0,
 	"file", "FILE",
-	"Read FILE as a makefile" },
+	_("Read FILE as a makefile") },
     { 'h', flag, (char *) &print_usage_flag, 0, 0, 0, 0, 0,
 	"help", 0,
-	"Print this message and exit" },
+	_("Print this message and exit") },
     { 'i', flag, (char *) &ignore_errors_flag, 1, 1, 0, 0, 0,
 	"ignore-errors", 0,
-	"Ignore errors from commands" },
+	_("Ignore errors from commands") },
     { 'I', string, (char *) &include_directories, 1, 1, 0, 0, 0,
 	"include-dir", "DIRECTORY",
-	"Search DIRECTORY for included makefiles" },
+	_("Search DIRECTORY for included makefiles") },
     { 'j',
 #ifndef MAKE_JOBSERVER
         positive_int, (char *) &job_slots, 1, 1, 0,
@@ -284,68 +284,68 @@ static const struct command_switch switches[] =
         int_string, (char *)&job_slots_str, 1, 1, 0, "0", "1",
 #endif
 	"jobs", "N",
-	"Allow N jobs at once; infinite jobs with no arg" },
+	_("Allow N jobs at once; infinite jobs with no arg") },
     { 'k', flag, (char *) &keep_going_flag, 1, 1, 0,
 	0, (char *) &default_keep_going_flag,
 	"keep-going", 0,
-	"Keep going when some targets can't be made" },
+	_("Keep going when some targets can't be made") },
 #ifndef NO_FLOAT
     { 'l', floating, (char *) &max_load_average, 1, 1, 0,
 	(char *) &default_load_average, (char *) &default_load_average,
 	"load-average", "N",
-	"Don't start multiple jobs unless load is below N" },
+	_("Don't start multiple jobs unless load is below N") },
 #else
     { 'l', positive_int, (char *) &max_load_average, 1, 1, 0,
 	(char *) &default_load_average, (char *) &default_load_average,
 	"load-average", "N",
-	"Don't start multiple jobs unless load is below N" },
+	_("Don't start multiple jobs unless load is below N") },
 #endif
     { 'm', ignore, 0, 0, 0, 0, 0, 0,
 	0, 0,
 	"-b" },
     { 'n', flag, (char *) &just_print_flag, 1, 1, 1, 0, 0,
 	"just-print", 0,
-	"Don't actually run any commands; just print them" },
+	_("Don't actually run any commands; just print them") },
     { 'o', string, (char *) &old_files, 0, 0, 0, 0, 0,
 	"old-file", "FILE",
-	"Consider FILE to be very old and don't remake it" },
+	_("Consider FILE to be very old and don't remake it") },
     { 'p', flag, (char *) &print_data_base_flag, 1, 1, 0, 0, 0,
 	"print-data-base", 0,
-	"Print make's internal database" },
+	_("Print make's internal database") },
     { 'q', flag, (char *) &question_flag, 1, 1, 1, 0, 0,
 	"question", 0,
-	"Run no commands; exit status says if up to date" },
+	_("Run no commands; exit status says if up to date") },
     { 'r', flag, (char *) &no_builtin_rules_flag, 1, 1, 0, 0, 0,
 	"no-builtin-rules", 0,
-	"Disable the built-in implicit rules" },
+	_("Disable the built-in implicit rules") },
     { 'R', flag, (char *) &no_builtin_variables_flag, 1, 1, 0, 0, 0,
 	"no-builtin-variables", 0,
-	"Disable the built-in variable settings" },
+	_("Disable the built-in variable settings") },
     { 's', flag, (char *) &silent_flag, 1, 1, 0, 0, 0,
 	"silent", 0,
-	"Don't echo commands" },
+	_("Don't echo commands") },
     { 'S', flag_off, (char *) &keep_going_flag, 1, 1, 0,
 	0, (char *) &default_keep_going_flag,
 	"no-keep-going", 0,
-	"Turns off -k" },
+	_("Turns off -k") },
     { 't', flag, (char *) &touch_flag, 1, 1, 1, 0, 0,
 	"touch", 0,
-	"Touch targets instead of remaking them" },
+	_("Touch targets instead of remaking them") },
     { 'v', flag, (char *) &print_version_flag, 1, 1, 0, 0, 0,
 	"version", 0,
-	"Print the version number of make and exit" },
+	_("Print the version number of make and exit") },
     { 'w', flag, (char *) &print_directory_flag, 1, 1, 0, 0, 0,
 	"print-directory", 0,
-	"Print the current directory" },
+	_("Print the current directory") },
     { 2, flag, (char *) &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
 	"no-print-directory", 0,
-	"Turn off -w, even if it was turned on implicitly" },
+	_("Turn off -w, even if it was turned on implicitly") },
     { 'W', string, (char *) &new_files, 0, 0, 0, 0, 0,
 	"what-if", "FILE",
-	"Consider FILE to be infinitely new" },
+	_("Consider FILE to be infinitely new") },
     { 3, flag, (char *) &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
 	"warn-undefined-variables", 0,
-	"Warn when an undefined variable is referenced" },
+	_("Warn when an undefined variable is referenced") },
     { '\0', }
   };
 
@@ -438,7 +438,7 @@ enter_command_line_file (name)
      char *name;
 {
   if (name[0] == '\0')
-    fatal (NILF, "empty string invalid as file name");
+    fatal (NILF, _("empty string invalid as file name"));
 
   if (name[0] == '~')
     {
@@ -504,7 +504,7 @@ handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
 
   if (!debug_flag)
     {
-      sprintf(errmsg, "%s: Interrupt/Exception caught ", prg);
+      sprintf(errmsg, _("%s: Interrupt/Exception caught "), prg);
       sprintf(&errmsg[strlen(errmsg)],
               "(code = 0x%x, addr = 0x%x)\r\n",
               exrec->ExceptionCode, exrec->ExceptionAddress);
@@ -513,7 +513,7 @@ handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
     }
 
   sprintf(errmsg,
-          "\r\nUnhandled exception filter called from program %s\r\n", prg);
+          _("\r\nUnhandled exception filter called from program %s\r\n"), prg);
   sprintf(&errmsg[strlen(errmsg)], "ExceptionCode = %x\r\n",
           exrec->ExceptionCode);
   sprintf(&errmsg[strlen(errmsg)], "ExceptionFlags = %x\r\n",
@@ -524,8 +524,8 @@ handle_runtime_exceptions( struct _EXCEPTION_POINTERS *exinfo )
   if (exrec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION
       && exrec->NumberParameters >= 2)
     sprintf(&errmsg[strlen(errmsg)],
-            "Access violation: %s operation at address %x\r\n",
-            exrec->ExceptionInformation[0] ? "write": "read",
+            _("Access violation: %s operation at address %x\r\n"),
+            exrec->ExceptionInformation[0] ? _("write"): _("read"),
             exrec->ExceptionInformation[1]);
 
   /* turn this on if we want to put stuff in the event log too */
@@ -590,7 +590,7 @@ find_and_set_default_shell(char *token)
     sprintf(sh_path, "%s", search_token);
     default_shell = xstrdup(w32ify(sh_path,0));
     if (debug_flag)
-      printf("find_and_set_shell setting default_shell = %s\n", default_shell);
+      printf(_("find_and_set_shell setting default_shell = %s\n"), default_shell);
     sh_found = 1;
   } else {
     char *p;
@@ -632,7 +632,7 @@ find_and_set_default_shell(char *token)
       }
 
       if (debug_flag && sh_found)
-        printf("find_and_set_shell path search set default_shell = %s\n", default_shell);
+        printf(_("find_and_set_shell path search set default_shell = %s\n"), default_shell);
     }
   }
 
@@ -929,9 +929,9 @@ int main (int argc, char ** argv)
 #ifdef WINDOWS32
   if (suspend_flag) {
         fprintf(stderr, "%s (pid = %d)\n", argv[0], GetCurrentProcessId());
-        fprintf(stderr, "%s is suspending for 30 seconds...", argv[0]);
+        fprintf(stderr, _("%s is suspending for 30 seconds..."), argv[0]);
         Sleep(30 * 1000);
-        fprintf(stderr, "done sleep(30). Continuing.\n");
+        fprintf(stderr, _("done sleep(30). Continuing.\n"));
   }
 #endif
 
@@ -1130,17 +1130,17 @@ int main (int argc, char ** argv)
 #endif
 
             if (stdin_nm)
-              fatal (NILF, "Makefile from standard input specified twice.");
+              fatal (NILF, _("Makefile from standard input specified twice."));
 
 	    outfile = fopen (name, "w");
 	    if (outfile == 0)
-	      pfatal_with_name ("fopen (temporary file)");
+	      pfatal_with_name (_("fopen (temporary file)"));
 	    while (!feof (stdin))
 	      {
 		char buf[2048];
 		unsigned int n = fread (buf, 1, sizeof(buf), stdin);
 		if (n > 0 && fwrite (buf, 1, n, outfile) != n)
-		  pfatal_with_name ("fwrite (temporary file)");
+		  pfatal_with_name (_("fwrite (temporary file)"));
 	      }
 	    (void) fclose (outfile);
 
@@ -1244,8 +1244,8 @@ int main (int argc, char ** argv)
     no_default_sh_exe = !find_and_set_default_shell(NULL);
 
   if (no_default_sh_exe && job_slots != 1) {
-    error (NILF, "Do not specify -j or --jobs if sh.exe is not available.");
-    error (NILF, "Resetting make for single job mode.");
+    error (NILF, _("Do not specify -j or --jobs if sh.exe is not available."));
+    error (NILF, _("Resetting make for single job mode."));
     job_slots = 1;
   }
 #endif /* WINDOWS32 */
@@ -1307,7 +1307,7 @@ int main (int argc, char ** argv)
             || fcntl (job_fds[1], F_GETFL, 0) < 0)
           {
             error (NILF,
-                   "warning: jobserver unavailable (using -j1).  Add `+' to parent make rule.");
+                   _("warning: jobserver unavailable (using -j1).  Add `+' to parent make rule."));
             job_slots = 1;
             job_fds[0] = job_fds[1] = -1;
             job_slots_str = "1";
@@ -1324,7 +1324,7 @@ int main (int argc, char ** argv)
       char c = '0';
 
       if (pipe (job_fds) < 0)
-	pfatal_with_name ("creating jobs pipe");
+	pfatal_with_name (_("creating jobs pipe"));
 
       /* Set the read FD to nonblocking; we'll use select() to wait
 	 for it in job.c.  */
@@ -1419,7 +1419,7 @@ int main (int argc, char ** argv)
       int nargc = argc;
 
       if (debug_flag)
-	puts ("Updating makefiles....");
+	puts (_("Updating makefiles...."));
 
       /* Remove any makefiles we don't want to try to update.
 	 Also record the current modtimes so we can compare them later.  */
@@ -1444,7 +1444,7 @@ int main (int argc, char ** argv)
 			 you write your makefiles.)  */
 
 		      if (debug_flag)
-			printf ("Makefile `%s' might loop; not remaking it.\n",
+			printf (_("Makefile `%s' might loop; not remaking it.\n"),
 				f->name);
 
 		      if (last == 0)
@@ -1518,7 +1518,7 @@ int main (int argc, char ** argv)
                         FILE_TIMESTAMP mtime;
                         /* The update failed and this makefile was not
                            from the MAKEFILES variable, so we care.  */
-                        error (NILF, "Failed to remake makefile `%s'.",
+                        error (NILF, _("Failed to remake makefile `%s'."),
                                d->file->name);
                         mtime = file_mtime_no_search (d->file);
                         any_remade |= (mtime != (FILE_TIMESTAMP) -1
@@ -1533,12 +1533,12 @@ int main (int argc, char ** argv)
                       if (d->changed & RM_INCLUDED)
                         /* An included makefile.  We don't need
                            to die, but we do want to complain.  */
-                        error (NILF, "Included makefile `%s' was not found.",
+                        error (NILF, _("Included makefile `%s' was not found."),
                                dep_name (d));
                       else
                         {
                           /* A normal makefile.  We must die later.  */
-                          error (NILF, "Makefile `%s' was not found",
+                          error (NILF, _("Makefile `%s' was not found"),
                                  dep_name (d));
                           any_failed = 1;
                         }
@@ -1606,7 +1606,7 @@ int main (int argc, char ** argv)
 	      else
 		bad = 1;
 	      if (bad)
-		fatal (NILF, "Couldn't change back to original directory.");
+		fatal (NILF, _("Couldn't change back to original directory."));
 	    }
 
 #ifndef _AMIGA
@@ -1640,7 +1640,7 @@ int main (int argc, char ** argv)
 	  if (debug_flag)
 	    {
 	      char **p;
-	      fputs ("Re-executing:", stdout);
+	      fputs (_("Re-executing:"), stdout);
 	      for (p = nargv; *p != 0; ++p)
 		printf (" %s", *p);
 	      puts ("");
@@ -1665,7 +1665,7 @@ int main (int argc, char ** argv)
   /* If there is a temp file from reading a makefile from stdin, get rid of
      it now.  */
   if (stdin_nm && unlink(stdin_nm) < 0 && errno != ENOENT)
-    perror_with_name("unlink (temporary file): ", stdin_nm);
+    perror_with_name(_("unlink (temporary file): "), stdin_nm);
 
   {
     int status;
@@ -1687,15 +1687,15 @@ int main (int argc, char ** argv)
     if (!goals)
       {
         if (read_makefiles == 0)
-          fatal (NILF, "No targets specified and no makefile found");
+          fatal (NILF, _("No targets specified and no makefile found"));
 
-        fatal (NILF, "No targets");
+        fatal (NILF, _("No targets"));
       }
 
     /* Update the goals.  */
 
     if (debug_flag)
-      puts ("Updating goal targets....");
+      puts (_("Updating goal targets...."));
 
     switch (update_goal_chain (goals, 0))
     {
@@ -1720,7 +1720,7 @@ int main (int argc, char ** argv)
 
     /* If we detected some clock skew, generate one last warning */
     if (clock_skew_detected)
-      error (NILF, "*** Warning:  Clock skew detected.  Your build may be incomplete.");
+      error (NILF, _("*** Warning:  Clock skew detected.  Your build may be incomplete."));
 
     /* Exit.  */
     die (status);
@@ -1879,7 +1879,7 @@ print_usage (bad)
 
   fprintf (usageto, "Usage: %s [options] [target] ...\n", program);
 
-  fputs ("Options:\n", usageto);
+  fputs (_("Options:\n"), usageto);
   for (cs = switches; cs->c != '\0'; ++cs)
     {
       char buf[1024], shortarg[50], longarg[50], *p;
@@ -2080,8 +2080,8 @@ decode_switches (argc, argv, env)
 		      if (i < 1)
 			{
 			  if (doit)
-			    error (NILF, "the `-%c' option requires a \
-positive integral argument",
+			    error (NILF, _("the `-%c' option requires a \
+positive integral argument"),
 				   cs->c);
 			  bad = 1;
 			}
@@ -2520,13 +2520,13 @@ print_version ()
   if (remote_description != 0 && *remote_description != '\0')
     printf ("-%s", remote_description);
 
-  printf (", by Richard Stallman and Roland McGrath.\n\
+  printf (_(", by Richard Stallman and Roland McGrath.\n\
 %sCopyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99\n\
 %s\tFree Software Foundation, Inc.\n\
 %sThis is free software; see the source for copying conditions.\n\
 %sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
 %sPARTICULAR PURPOSE.\n\n\
-%sReport bugs to <bug-make@gnu.org>.\n\n",
+%sReport bugs to <bug-make@gnu.org>.\n\n"),
 	  precede, precede, precede, precede, precede, precede);
 
   printed_version = 1;
@@ -2544,7 +2544,7 @@ print_data_base ()
   time_t when;
 
   when = time ((time_t *) 0);
-  printf ("\n# Make data base, printed on %s", ctime (&when));
+  printf (_("\n# Make data base, printed on %s"), ctime (&when));
 
   print_variable_data_base ();
   print_dir_data_base ();
@@ -2553,7 +2553,7 @@ print_data_base ()
   print_vpath_data_base ();
 
   when = time ((time_t *) 0);
-  printf ("\n# Finished Make data base on %s\n", ctime (&when));
+  printf (_("\n# Finished Make data base on %s\n"), ctime (&when));
 }
 
 /* Exit with STATUS, cleaning up as necessary.  */
@@ -2608,7 +2608,7 @@ log_working_directory (entering)
      int entering;
 {
   static int entered = 0;
-  char *msg = entering ? "Entering" : "Leaving";
+  char *msg = entering ? _("Entering") : _("Leaving");
 
   /* Print nothing without the flag.  Don't print the entering message
      again if we already have.  Don't print the leaving message if we
@@ -2627,7 +2627,7 @@ log_working_directory (entering)
     printf ("%s[%u]: %s ", program, makelevel, msg);
 
   if (starting_directory == 0)
-    puts ("an unknown directory");
+    puts (_("an unknown directory"));
   else
-    printf ("directory `%s'\n", starting_directory);
+    printf (_("directory `%s'\n"), starting_directory);
 }
diff --git a/make.h b/make.h
index a2f2606..0496ce7 100644
--- a/make.h
+++ b/make.h
@@ -40,6 +40,13 @@ Boston, MA 02111-1307, USA.  */
 #endif /* C++ or ANSI C.  */
 
 
+/* For now, set gettext macro to a no-op.  */
+#undef _
+#undef N_
+#define _(s)    s
+#define N_(s)   s
+
+
 #ifdef  CRAY
 /* This must happen before #include <signal.h> so
    that the declaration therein is changed.  */
diff --git a/make.texinfo b/make.texinfo
index fac7ecf..51330d0 100644
--- a/make.texinfo
+++ b/make.texinfo
@@ -9107,7 +9107,6 @@ defined.@*
 Evaluate @var{text} with @var{var} bound to each word in @var{words},
 and concatenate the results.@*
 @xref{Foreach Function, ,The @code{foreach} Function}.
-@end table
 
 @item $(call @var{var},@var{param},@dots{})
 
diff --git a/misc.c b/misc.c
index 7b7b1d3..c1d43fc 100644
--- a/misc.c
+++ b/misc.c
@@ -304,7 +304,7 @@ fatal (flocp, fmt, va_alist)
   VA_PRINTF (stderr, fmt, args);
   VA_END (args);
 
-  fputs (".  Stop.\n", stderr);
+  fputs (_(".  Stop.\n"), stderr);
 
   die (2);
 }
@@ -326,7 +326,7 @@ strerror (errnum)
   if (errno < sys_nerr)
     return sys_errlist[errnum];
 
-  sprintf (buf, "Unknown error %d", errnum);
+  sprintf (buf, _("Unknown error %d"), errnum);
   return buf;
 }
 #endif
@@ -366,7 +366,7 @@ xmalloc (size)
 {
   char *result = (char *) malloc (size);
   if (result == 0)
-    fatal (NILF, "virtual memory exhausted");
+    fatal (NILF, _("virtual memory exhausted"));
   return result;
 }
 
@@ -381,7 +381,7 @@ xrealloc (ptr, size)
   /* Some older implementations of realloc() don't conform to ANSI.  */
   result = ptr ? realloc (ptr, size) : malloc (size);
   if (result == 0)
-    fatal (NILF, "virtual memory exhausted");
+    fatal (NILF, _("virtual memory exhausted"));
   return result;
 }
 
@@ -399,7 +399,7 @@ xstrdup (ptr)
 #endif
 
   if (result == 0)
-    fatal (NILF, "virtual memory exhausted");
+    fatal (NILF, _("virtual memory exhausted"));
 
 #ifdef HAVE_STRDUP
   return result;
@@ -650,7 +650,7 @@ log_access (flavor)
      but we write this one to stderr because it might be
      run in a child fork whose stdout is piped.  */
 
-  fprintf (stderr, "%s access: user %lu (real %lu), group %lu (real %lu)\n",
+  fprintf (stderr, _("%s access: user %lu (real %lu), group %lu (real %lu)\n"),
 	   flavor, (unsigned long) geteuid (), (unsigned long) getuid (),
            (unsigned long) getegid (), (unsigned long) getgid ());
   fflush (stderr);
@@ -671,7 +671,7 @@ init_access ()
   if (user_uid == -1 || user_gid == -1 || make_uid == -1 || make_gid == -1)
     pfatal_with_name ("get{e}[gu]id");
 
-  log_access ("Initialized");
+  log_access (_("Initialized"));
 
   current_access = make;
 #endif
diff --git a/read.c b/read.c
index 740d93d..c3ce067 100644
--- a/read.c
+++ b/read.c
@@ -17,11 +17,12 @@ along with GNU Make; see the file COPYING.  If not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
+#include "make.h"
+
 #include <assert.h>
 
 #include <glob.h>
 
-#include "make.h"
 #include "dep.h"
 #include "filedef.h"
 #include "job.h"
@@ -149,7 +150,7 @@ read_all_makefiles (makefiles)
   unsigned int num_makefiles = 0;
 
   if (debug_flag)
-    puts ("Reading makefiles...");
+    puts (_("Reading makefiles..."));
 
   /* If there's a non-null variable MAKEFILES, its value is a list of
      files to read first thing.  But don't let it prevent reading the
@@ -323,15 +324,15 @@ read_makefile (filename, flags)
 
   if (debug_flag)
     {
-      printf ("Reading makefile `%s'", fileinfo.filenm);
+      printf (_("Reading makefile `%s'"), fileinfo.filenm);
       if (flags & RM_NO_DEFAULT_GOAL)
-	printf (" (no default goal)");
+	printf (_(" (no default goal)"));
       if (flags & RM_INCLUDED)
-	printf (" (search path)");
+	printf (_(" (search path)"));
       if (flags & RM_DONTCARE)
-	printf (" (don't care)");
+	printf (_(" (don't care)"));
       if (flags & RM_NO_TILDE)
-	printf (" (no ~ expansion)");
+	printf (_(" (no ~ expansion)"));
       puts ("...");
     }
 
@@ -511,7 +512,7 @@ read_makefile (filename, flags)
 	  if (i >= 0)
 	    ignoring = i;
 	  else
-	    fatal (&fileinfo, "invalid syntax in conditional");
+	    fatal (&fileinfo, _("invalid syntax in conditional"));
 	  continue;
 	}
 
@@ -520,7 +521,7 @@ read_makefile (filename, flags)
 	  if (in_ignored_define)
 	    in_ignored_define = 0;
 	  else
-	    fatal (&fileinfo, "extraneous `endef'");
+	    fatal (&fileinfo, _("extraneous `endef'"));
 	  continue;
 	}
 
@@ -532,7 +533,7 @@ read_makefile (filename, flags)
 	    {
 	      p2 = next_token (p + 6);
               if (*p2 == '\0')
-                fatal (&fileinfo, "empty variable name");
+                fatal (&fileinfo, _("empty variable name"));
 
 	      /* Let the variable name be the whole rest of the line,
 		 with trailing blanks stripped (comments have already been
@@ -550,7 +551,7 @@ read_makefile (filename, flags)
         {
 	  p2 = next_token (p + 8);
 	  if (*p2 == '\0')
-	    error (&fileinfo, "empty `override' directive");
+	    error (&fileinfo, _("empty `override' directive"));
 	  if (strneq (p2, "define", 6) && (isblank (p2[6]) || p2[6] == '\0'))
 	    {
 	      if (ignoring)
@@ -559,7 +560,7 @@ read_makefile (filename, flags)
 		{
 		  p2 = next_token (p2 + 6);
                   if (*p2 == '\0')
-                    fatal (&fileinfo, "empty variable name");
+                    fatal (&fileinfo, _("empty variable name"));
 
 		  /* Let the variable name be the whole rest of the line,
 		     with trailing blanks stripped (comments have already been
@@ -573,7 +574,7 @@ read_makefile (filename, flags)
 	    }
 	  else if (!ignoring
 		   && !try_variable_definition (&fileinfo, p2, o_override))
-	    error (&fileinfo, "invalid `override' directive");
+	    error (&fileinfo, _("invalid `override' directive"));
 
 	  continue;
 	}
@@ -657,7 +658,7 @@ read_makefile (filename, flags)
 	  if (*p == '\0')
 	    {
 	      error (&fileinfo,
-			      "no file name for `%sinclude'",
+			      _("no file name for `%sinclude'"),
 			      noerror ? "-" : "");
 	      continue;
 	    }
@@ -722,7 +723,7 @@ read_makefile (filename, flags)
 	     because there was no preceding target, and the line
 	     might have been usable as a variable definition.
 	     But now it is definitely lossage.  */
-	  fatal(&fileinfo, "commands commence before first target");
+	  fatal(&fileinfo, _("commands commence before first target"));
 	}
       else
 	{
@@ -770,7 +771,7 @@ read_makefile (filename, flags)
             {
             case w_eol:
               if (cmdleft != 0)
-                fatal(&fileinfo, "missing rule before commands");
+                fatal(&fileinfo, _("missing rule before commands"));
               /* This line contained something but turned out to be nothing
                  but whitespace (a comment?).  */
               continue;
@@ -856,9 +857,9 @@ read_makefile (filename, flags)
               if (*p2 != '\0')
                 /* There's no need to be ivory-tower about this: check for
                    one of the most common bugs found in makefiles...  */
-                fatal (&fileinfo, "missing separator%s",
+                fatal (&fileinfo, _("missing separator%s"),
                        !strneq(lb.buffer, "        ", 8) ? ""
-                       : " (did you mean TAB instead of 8 spaces?)");
+                       : _(" (did you mean TAB instead of 8 spaces?)"));
               continue;
             }
 
@@ -987,14 +988,13 @@ read_makefile (filename, flags)
 	      target = parse_file_seq (&p2, ':', sizeof (struct nameseq), 1);
 	      ++p2;
 	      if (target == 0)
-		fatal (&fileinfo, "missing target pattern");
+		fatal (&fileinfo, _("missing target pattern"));
 	      else if (target->next != 0)
-		fatal (&fileinfo, "multiple target patterns");
+		fatal (&fileinfo, _("multiple target patterns"));
 	      pattern = target->name;
 	      pattern_percent = find_percent (pattern);
 	      if (pattern_percent == 0)
-		fatal (&fileinfo,
-				"target pattern contains no `%%'");
+		fatal (&fileinfo, _("target pattern contains no `%%'"));
               free((char *)target);
 	    }
 	  else
@@ -1035,7 +1035,7 @@ read_makefile (filename, flags)
     }
 
   if (conditionals->if_cmds)
-    fatal (&fileinfo, "missing `endif'");
+    fatal (&fileinfo, _("missing `endif'"));
 
   /* At eof, record the last rule.  */
   record_waiting_files ();
@@ -1094,7 +1094,7 @@ do_define (name, namelen, origin, infile, flocp)
 	  p += 5;
 	  remove_comments (p);
 	  if (*next_token (p) != '\0')
-	    error (flocp, "Extraneous text after `endef' directive");
+	    error (flocp, _("Extraneous text after `endef' directive"));
 	  /* Define the variable.  */
 	  if (idx == 0)
 	    definition[0] = '\0';
@@ -1123,7 +1123,7 @@ do_define (name, namelen, origin, infile, flocp)
     }
 
   /* No `endef'!!  */
-  fatal (flocp, "missing `endef', unterminated `define'");
+  fatal (flocp, _("missing `endef', unterminated `define'"));
 
   /* NOTREACHED */
   return;
@@ -1177,16 +1177,15 @@ conditional_line (line, flocp)
   if (*cmdname == 'e')
     {
       if (*line != '\0')
-	error (flocp,
-                        "Extraneous text after `%s' directive", cmdname);
+	error (flocp, _("Extraneous text after `%s' directive"), cmdname);
       /* "Else" or "endif".  */
       if (conditionals->if_cmds == 0)
-	fatal (flocp, "extraneous `%s'", cmdname);
+	fatal (flocp, _("extraneous `%s'"), cmdname);
       /* NOTDEF indicates an `endif' command.  */
       if (notdef)
 	--conditionals->if_cmds;
       else if (conditionals->seen_else[conditionals->if_cmds - 1])
-	fatal (flocp, "only one `else' per conditional");
+	fatal (flocp, _("only one `else' per conditional"));
       else
 	{
 	  /* Toggle the state of ignorance.  */
@@ -1334,8 +1333,7 @@ conditional_line (line, flocp)
       *line = '\0';
       line = next_token (++line);
       if (*line != '\0')
-	error (flocp,
-                        "Extraneous text after `%s' directive", cmdname);
+	error (flocp, _("Extraneous text after `%s' directive"), cmdname);
 
       s2 = variable_expand (s2);
       conditionals->ignoring[conditionals->if_cmds - 1]
@@ -1446,7 +1444,7 @@ record_target_var (filenames, defn, two_colon, origin, flocp)
       current_variable_set_list = vlist;
       v = try_variable_definition(flocp, defn, origin);
       if (!v)
-        error (flocp, "Malformed per-target variable definition");
+        error (flocp, _("Malformed per-target variable definition"));
       v->per_target = 1;
 
       /* If it's not an override, check to see if there was a command-line
@@ -1528,10 +1526,10 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
       implicit |= implicit_percent != 0;
 
       if (implicit && pattern != 0)
-	fatal (flocp, "mixed implicit and static pattern rules");
+	fatal (flocp, _("mixed implicit and static pattern rules"));
 
       if (implicit && implicit_percent == 0)
-	fatal (flocp, "mixed implicit and normal rules");
+	fatal (flocp, _("mixed implicit and normal rules"));
 
       if (implicit)
 	{
@@ -1572,7 +1570,7 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
 	    {
 	      /* Give a warning if the rule is meaningless.  */
 	      error (flocp,
-		     "target `%s' doesn't match the target pattern", name);
+		     _("target `%s' doesn't match the target pattern"), name);
 	      this = 0;
 	    }
 	  else
@@ -1604,12 +1602,12 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
 
 	  if (f->double_colon)
 	    fatal (flocp,
-                   "target file `%s' has both : and :: entries", f->name);
+                   _("target file `%s' has both : and :: entries"), f->name);
 
 	  /* If CMDS == F->CMDS, this target was listed in this rule
 	     more than once.  Just give a warning since this is harmless.  */
 	  if (cmds != 0 && cmds == f->cmds)
-	    error (flocp, "target `%s' given more than once in the same rule.",
+	    error (flocp, _("target `%s' given more than once in the same rule."),
                    f->name);
 
 	  /* Check for two single-colon entries both with commands.
@@ -1618,9 +1616,9 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
 	  else if (cmds != 0 && f->cmds != 0 && f->is_target)
 	    {
 	      error (&cmds->fileinfo,
-                     "warning: overriding commands for target `%s'", f->name);
+                     _("warning: overriding commands for target `%s'"), f->name);
 	      error (&f->cmds->fileinfo,
-                     "warning: ignoring old commands for target `%s'",
+                     _("warning: ignoring old commands for target `%s'"),
                      f->name);
 	    }
 
@@ -1702,7 +1700,7 @@ record_files (filenames, pattern, pattern_percent, deps, cmds_started,
 	     we don't lose on default suffix rules or makefiles.  */
 	  if (f != 0 && f->is_target && !f->double_colon)
 	    fatal (flocp,
-                   "target file `%s' has both : and :: entries", f->name);
+                   _("target file `%s' has both : and :: entries"), f->name);
 	  f = enter_file (name);
 	  /* If there was an existing entry and it was a double-colon
 	     entry, enter_file will have returned a new one, making it the
@@ -2119,7 +2117,7 @@ readline (linebuffer, stream, flocp)
 	     lossage strikes again!  (xmkmf puts NULs in its makefiles.)
 	     There is nothing really to be done; we synthesize a newline so
 	     the following line doesn't appear to be part of this line.  */
-	  error (flocp, "warning: NUL character seen; rest of line ignored");
+	  error (flocp, _("warning: NUL character seen; rest of line ignored"));
 	  p[0] = '\n';
 	  len = 1;
 	}
@@ -2674,7 +2672,7 @@ multi_glob (chain, size)
 	  }
 
 	case GLOB_NOSPACE:
-	  fatal (NILF, "virtual memory exhausted");
+	  fatal (NILF, _("virtual memory exhausted"));
 	  break;
 
 	default:
diff --git a/remake.c b/remake.c
index 90de313..45633db 100644
--- a/remake.c
+++ b/remake.c
@@ -226,8 +226,8 @@ update_goal_chain (goals, makefiles)
 		  /* Never give a message under -s or -q.  */
 		  && !silent_flag && !question_flag)
 		message (1, ((file->phony || file->cmds == 0)
-			     ? "Nothing to be done for `%s'."
-			     : "`%s' is up to date."),
+			     ? _("Nothing to be done for `%s'.")
+			     : _("`%s' is up to date.")),
 			 file->name);
 
 	      /* This goal is finished.  Remove it from the chain.  */
@@ -274,9 +274,9 @@ no_rule_error(file)
   struct file *file;
 {
   static const char msg_noparent[]
-    = "%sNo rule to make target `%s'%s";
+    = _("%sNo rule to make target `%s'%s");
   static const char msg_parent[]
-    = "%sNo rule to make target `%s', needed by `%s'%s";
+    = _("%sNo rule to make target `%s', needed by `%s'%s");
 
   if (keep_going_flag || file->dontcare)
     {
@@ -326,7 +326,7 @@ update_file (file, depth)
      possible below here until then.  */
   if (file->considered == considered)
     {
-      DEBUGPR ("Pruning file `%s'.\n");
+      DEBUGPR (_("Pruning file `%s'.\n"));
       return 0;
     }
   file->considered = considered;
@@ -373,18 +373,18 @@ update_file_1 (file, depth)
   register struct dep *d, *lastd;
   int running = 0;
 
-  DEBUGPR ("Considering target file `%s'.\n");
+  DEBUGPR (_("Considering target file `%s'.\n"));
 
   if (file->updated)
     {
       if (file->update_status > 0)
 	{
-	  DEBUGPR ("Recently tried and failed to update file `%s'.\n");
+	  DEBUGPR (_("Recently tried and failed to update file `%s'.\n"));
           no_rule_error(file);
 	  return file->update_status;
 	}
 
-      DEBUGPR ("File `%s' was considered already.\n");
+      DEBUGPR (_("File `%s' was considered already.\n"));
       return 0;
     }
 
@@ -394,10 +394,10 @@ update_file_1 (file, depth)
     case cs_deps_running:
       break;
     case cs_running:
-      DEBUGPR ("Still updating file `%s'.\n");
+      DEBUGPR (_("Still updating file `%s'.\n"));
       return 0;
     case cs_finished:
-      DEBUGPR ("Finished updating file `%s'.\n");
+      DEBUGPR (_("Finished updating file `%s'.\n"));
       return file->update_status;
     default:
       abort ();
@@ -418,7 +418,7 @@ update_file_1 (file, depth)
   check_renamed (file);
   noexist = this_mtime == (FILE_TIMESTAMP) -1;
   if (noexist)
-    DEBUGPR ("File `%s' does not exist.\n");
+    DEBUGPR (_("File `%s' does not exist.\n"));
 
   must_make = noexist;
 
@@ -428,15 +428,15 @@ update_file_1 (file, depth)
   if (!file->phony && file->cmds == 0 && !file->tried_implicit)
     {
       if (try_implicit_rule (file, depth))
-	DEBUGPR ("Found an implicit rule for `%s'.\n");
+	DEBUGPR (_("Found an implicit rule for `%s'.\n"));
       else
-	DEBUGPR ("No implicit rule found for `%s'.\n");
+	DEBUGPR (_("No implicit rule found for `%s'.\n"));
       file->tried_implicit = 1;
     }
   if (file->cmds == 0 && !file->is_target
       && default_file != 0 && default_file->cmds != 0)
     {
-      DEBUGPR ("Using default commands for `%s'.\n");
+      DEBUGPR (_("Using default commands for `%s'.\n"));
       file->cmds = default_file->cmds;
     }
 
@@ -456,7 +456,7 @@ update_file_1 (file, depth)
 
       if (d->file->updating)
 	{
-	  error (NILF, "Circular %s <- %s dependency dropped.",
+	  error (NILF, _("Circular %s <- %s dependency dropped."),
 		 file->name, d->file->name);
 	  /* We cannot free D here because our the caller will still have
 	     a reference to it when we were called recursively via
@@ -534,13 +534,13 @@ update_file_1 (file, depth)
 
   file->updating = 0;
 
-  DEBUGPR ("Finished dependencies of target file `%s'.\n");
+  DEBUGPR (_("Finished dependencies of target file `%s'.\n"));
 
   if (running)
     {
       set_command_state (file, cs_deps_running);
       --depth;
-      DEBUGPR ("The dependencies of `%s' are being made.\n");
+      DEBUGPR (_("The dependencies of `%s' are being made.\n"));
       return 0;
     }
 
@@ -553,11 +553,11 @@ update_file_1 (file, depth)
 
       depth--;
 
-      DEBUGPR ("Giving up on target file `%s'.\n");
+      DEBUGPR (_("Giving up on target file `%s'.\n"));
 
       if (depth == 0 && keep_going_flag
 	  && !just_print_flag && !question_flag)
-	error (NILF, "Target `%s' not remade because of errors.", file->name);
+	error (NILF, _("Target `%s' not remade because of errors."), file->name);
 
       return dep_status;
     }
@@ -602,10 +602,10 @@ update_file_1 (file, depth)
 	{
 	  print_spaces (depth);
 	  if (d_mtime == (FILE_TIMESTAMP) -1)
-	    printf ("Dependency `%s' does not exist.\n", dep_name (d));
+	    printf (_("Dependency `%s' does not exist.\n"), dep_name (d));
 	  else
-	    printf ("Dependency `%s' is %s than dependent `%s'.\n",
-		    dep_name (d), d->changed ? "newer" : "older", file->name);
+	    printf (_("Dependency `%s' is %s than dependent `%s'.\n"),
+		    dep_name (d), d->changed ? _("newer") : _("older"), file->name);
 	  fflush (stdout);
 	}
     }
@@ -616,12 +616,12 @@ update_file_1 (file, depth)
   if (file->double_colon && file->deps == 0)
     {
       must_make = 1;
-      DEBUGPR ("Target `%s' is double-colon and has no dependencies.\n");
+      DEBUGPR (_("Target `%s' is double-colon and has no dependencies.\n"));
     }
   else if (!noexist && file->is_target && !deps_changed && file->cmds == 0)
     {
       must_make = 0;
-      DEBUGPR ("No commands for `%s' and no dependencies actually changed.\n");
+      DEBUGPR (_("No commands for `%s' and no dependencies actually changed.\n"));
     }
 
   if (!must_make)
@@ -629,9 +629,9 @@ update_file_1 (file, depth)
       if (debug_flag)
         {
           print_spaces(depth);
-          printf("No need to remake target `%s'", file->name);
+          printf(_("No need to remake target `%s'"), file->name);
           if (!streq(file->name, file->hname))
-              printf("; using VPATH name `%s'", file->hname);
+              printf(_("; using VPATH name `%s'"), file->hname);
           printf(".\n");
           fflush(stdout);
         }
@@ -651,7 +651,7 @@ update_file_1 (file, depth)
       return 0;
     }
 
-  DEBUGPR ("Must remake target `%s'.\n");
+  DEBUGPR (_("Must remake target `%s'.\n"));
 
   /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
      VPATH.  */
@@ -660,7 +660,7 @@ update_file_1 (file, depth)
       if (debug_flag)
         {
           print_spaces (depth);
-          printf("  Ignoring VPATH name `%s'.\n", file->hname);
+          printf(_("  Ignoring VPATH name `%s'.\n"), file->hname);
           fflush(stdout);
         }
       file->ignore_vpath = 1;
@@ -671,20 +671,20 @@ update_file_1 (file, depth)
 
   if (file->command_state != cs_finished)
     {
-      DEBUGPR ("Commands of `%s' are being run.\n");
+      DEBUGPR (_("Commands of `%s' are being run.\n"));
       return 0;
     }
 
   switch (file->update_status)
     {
     case 2:
-      DEBUGPR ("Failed to remake target file `%s'.\n");
+      DEBUGPR (_("Failed to remake target file `%s'.\n"));
       break;
     case 0:
-      DEBUGPR ("Successfully remade target file `%s'.\n");
+      DEBUGPR (_("Successfully remade target file `%s'.\n"));
       break;
     case 1:
-      DEBUGPR ("Target file `%s' needs remade under -q.\n");
+      DEBUGPR (_("Target file `%s' needs remade under -q.\n"));
       break;
     default:
       assert (file->update_status >= 0 && file->update_status <= 2);
@@ -823,15 +823,15 @@ check_dep (file, depth, this_mtime, must_make_ptr)
       if (!file->phony && file->cmds == 0 && !file->tried_implicit)
 	{
 	  if (try_implicit_rule (file, depth))
-	    DEBUGPR ("Found an implicit rule for `%s'.\n");
+	    DEBUGPR (_("Found an implicit rule for `%s'.\n"));
 	  else
-	    DEBUGPR ("No implicit rule found for `%s'.\n");
+	    DEBUGPR (_("No implicit rule found for `%s'.\n"));
 	  file->tried_implicit = 1;
 	}
       if (file->cmds == 0 && !file->is_target
 	  && default_file != 0 && default_file->cmds != 0)
 	{
-	  DEBUGPR ("Using default commands for `%s'.\n");
+	  DEBUGPR (_("Using default commands for `%s'.\n"));
 	  file->cmds = default_file->cmds;
 	}
 
@@ -855,7 +855,7 @@ check_dep (file, depth, this_mtime, must_make_ptr)
 	    {
 	      if (d->file->updating)
 		{
-		  error (NILF, "Circular %s <- %s dependency dropped.",
+		  error (NILF, _("Circular %s <- %s dependency dropped."),
 			 file->name, d->file->name);
 		  if (lastd == 0)
 		    {
@@ -1152,7 +1152,7 @@ f_mtime (file, search)
 
 	    file_timestamp_sprintf (mtimebuf, mtime);
 	    file_timestamp_sprintf (nowbuf, now);
-            error (NILF, "*** Warning: File `%s' has modification time in the future (%s > %s)",
+            error (NILF, _("*** Warning: File `%s' has modification time in the future (%s > %s)"),
                    file->name, mtimebuf, nowbuf);
             clock_skew_detected = 1;
           }
@@ -1266,7 +1266,7 @@ library_search (lib, mtime_ptr)
 	  {
 	    /* Give a warning if there is no pattern, then remove the
 	       pattern so it's ignored next time.  */
-	    error (NILF, ".LIBPATTERNS element `%s' is not a pattern", p);
+	    error (NILF, _(".LIBPATTERNS element `%s' is not a pattern"), p);
 	    for (; len; --len, ++p)
 	      *p = ' ';
 	    *p = c;
diff --git a/rule.c b/rule.c
index b5f690c..4983325 100644
--- a/rule.c
+++ b/rule.c
@@ -664,10 +664,10 @@ print_rule_data_base ()
     }
 
   if (rules == 0)
-    puts ("\n# No implicit rules.");
+    puts (_("\n# No implicit rules."));
   else
     {
-      printf ("\n# %u implicit rules, %u", rules, terminal);
+      printf (_("\n# %u implicit rules, %u"), rules, terminal);
 #ifndef	NO_FLOAT
       printf (" (%.1f%%)", (double) terminal / (double) rules * 100.0);
 #else
@@ -676,7 +676,7 @@ print_rule_data_base ()
 	printf (" (%d.%d%%)", f/10, f%10);
       }
 #endif
-      puts (" terminal.");
+      puts (_(" terminal."));
     }
 
   if (num_pattern_rules != rules)
@@ -684,11 +684,11 @@ print_rule_data_base ()
       /* This can happen if a fatal error was detected while reading the
          makefiles and thus count_implicit_rule_limits wasn't called yet.  */
       if (num_pattern_rules != 0)
-        fatal (NILF, "BUG: num_pattern_rules wrong!  %u != %u",
+        fatal (NILF, _("BUG: num_pattern_rules wrong!  %u != %u"),
                num_pattern_rules, rules);
     }
 
-  puts ("\n# Pattern-specific variable values");
+  puts (_("\n# Pattern-specific variable values"));
 
   {
     struct pattern_var *p;
@@ -703,10 +703,10 @@ print_rule_data_base ()
       }
 
     if (rules == 0)
-      puts ("\n# No pattern-specific variable values.");
+      puts (_("\n# No pattern-specific variable values."));
     else
       {
-        printf ("\n# %u pattern-specific variable values", rules);
+        printf (_("\n# %u pattern-specific variable values"), rules);
       }
   }
 }
diff --git a/signame.c b/signame.c
index dd73723..8ddbb36 100644
--- a/signame.c
+++ b/signame.c
@@ -17,9 +17,7 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.  */
 
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
+#include "make.h"
 
 #include <stdio.h>
 #include <sys/types.h>		/* Some systems need this for <signal.h>.  */
@@ -56,7 +54,7 @@
 /* There is too much variation in Sys V signal numbers and names, so
    we must initialize them at runtime.  */
 
-static const char undoc[] = "unknown signal";
+static const char *undoc;
 
 const char *sys_siglist[NSIG];
 
@@ -109,6 +107,10 @@ signame_init ()
 {
 #ifndef HAVE_SYS_SIGLIST
   int i;
+  char *u = _("unknown signal");
+
+  undoc = xstrdup(u);
+
   /* Initialize signal names.  */
   for (i = 0; i < NSIG; i++)
     sys_siglist[i] = undoc;
@@ -116,135 +118,135 @@ signame_init ()
 
   /* Initialize signal names.  */
 #if defined (SIGHUP)
-  init_sig (SIGHUP, "HUP", "Hangup");
+  init_sig (SIGHUP, "HUP", _("Hangup"));
 #endif
 #if defined (SIGINT)
-  init_sig (SIGINT, "INT", "Interrupt");
+  init_sig (SIGINT, "INT", _("Interrupt"));
 #endif
 #if defined (SIGQUIT)
-  init_sig (SIGQUIT, "QUIT", "Quit");
+  init_sig (SIGQUIT, "QUIT", _("Quit"));
 #endif
 #if defined (SIGILL)
-  init_sig (SIGILL, "ILL", "Illegal Instruction");
+  init_sig (SIGILL, "ILL", _("Illegal Instruction"));
 #endif
 #if defined (SIGTRAP)
-  init_sig (SIGTRAP, "TRAP", "Trace/breakpoint trap");
+  init_sig (SIGTRAP, "TRAP", _("Trace/breakpoint trap"));
 #endif
   /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because
      SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */
 #if defined (SIGABRT)
-  init_sig (SIGABRT, "ABRT", "Aborted");
+  init_sig (SIGABRT, "ABRT", _("Aborted"));
 #endif
 #if defined (SIGIOT)
-  init_sig (SIGIOT, "IOT", "IOT trap");
+  init_sig (SIGIOT, "IOT", _("IOT trap"));
 #endif
 #if defined (SIGEMT)
-  init_sig (SIGEMT, "EMT", "EMT trap");
+  init_sig (SIGEMT, "EMT", _("EMT trap"));
 #endif
 #if defined (SIGFPE)
-  init_sig (SIGFPE, "FPE", "Floating point exception");
+  init_sig (SIGFPE, "FPE", _("Floating point exception"));
 #endif
 #if defined (SIGKILL)
-  init_sig (SIGKILL, "KILL", "Killed");
+  init_sig (SIGKILL, "KILL", _("Killed"));
 #endif
 #if defined (SIGBUS)
-  init_sig (SIGBUS, "BUS", "Bus error");
+  init_sig (SIGBUS, "BUS", _("Bus error"));
 #endif
 #if defined (SIGSEGV)
-  init_sig (SIGSEGV, "SEGV", "Segmentation fault");
+  init_sig (SIGSEGV, "SEGV", _("Segmentation fault"));
 #endif
 #if defined (SIGSYS)
-  init_sig (SIGSYS, "SYS", "Bad system call");
+  init_sig (SIGSYS, "SYS", _("Bad system call"));
 #endif
 #if defined (SIGPIPE)
-  init_sig (SIGPIPE, "PIPE", "Broken pipe");
+  init_sig (SIGPIPE, "PIPE", _("Broken pipe"));
 #endif
 #if defined (SIGALRM)
-  init_sig (SIGALRM, "ALRM", "Alarm clock");
+  init_sig (SIGALRM, "ALRM", _("Alarm clock"));
 #endif
 #if defined (SIGTERM)
-  init_sig (SIGTERM, "TERM", "Terminated");
+  init_sig (SIGTERM, "TERM", _("Terminated"));
 #endif
 #if defined (SIGUSR1)
-  init_sig (SIGUSR1, "USR1", "User defined signal 1");
+  init_sig (SIGUSR1, "USR1", _("User defined signal 1"));
 #endif
 #if defined (SIGUSR2)
-  init_sig (SIGUSR2, "USR2", "User defined signal 2");
+  init_sig (SIGUSR2, "USR2", _("User defined signal 2"));
 #endif
   /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that
      is what is in POSIX.1.  */
 #if defined (SIGCHLD)
-  init_sig (SIGCHLD, "CHLD", "Child exited");
+  init_sig (SIGCHLD, "CHLD", _("Child exited"));
 #endif
 #if defined (SIGCLD)
-  init_sig (SIGCLD, "CLD", "Child exited");
+  init_sig (SIGCLD, "CLD", _("Child exited"));
 #endif
 #if defined (SIGPWR)
-  init_sig (SIGPWR, "PWR", "Power failure");
+  init_sig (SIGPWR, "PWR", _("Power failure"));
 #endif
 #if defined (SIGTSTP)
-  init_sig (SIGTSTP, "TSTP", "Stopped");
+  init_sig (SIGTSTP, "TSTP", _("Stopped"));
 #endif
 #if defined (SIGTTIN)
-  init_sig (SIGTTIN, "TTIN", "Stopped (tty input)");
+  init_sig (SIGTTIN, "TTIN", _("Stopped (tty input)"));
 #endif
 #if defined (SIGTTOU)
-  init_sig (SIGTTOU, "TTOU", "Stopped (tty output)");
+  init_sig (SIGTTOU, "TTOU", _("Stopped (tty output)"));
 #endif
 #if defined (SIGSTOP)
-  init_sig (SIGSTOP, "STOP", "Stopped (signal)");
+  init_sig (SIGSTOP, "STOP", _("Stopped (signal)"));
 #endif
 #if defined (SIGXCPU)
-  init_sig (SIGXCPU, "XCPU", "CPU time limit exceeded");
+  init_sig (SIGXCPU, "XCPU", _("CPU time limit exceeded"));
 #endif
 #if defined (SIGXFSZ)
-  init_sig (SIGXFSZ, "XFSZ", "File size limit exceeded");
+  init_sig (SIGXFSZ, "XFSZ", _("File size limit exceeded"));
 #endif
 #if defined (SIGVTALRM)
-  init_sig (SIGVTALRM, "VTALRM", "Virtual timer expired");
+  init_sig (SIGVTALRM, "VTALRM", _("Virtual timer expired"));
 #endif
 #if defined (SIGPROF)
-  init_sig (SIGPROF, "PROF", "Profiling timer expired");
+  init_sig (SIGPROF, "PROF", _("Profiling timer expired"));
 #endif
 #if defined (SIGWINCH)
   /* "Window size changed" might be more accurate, but even if that
      is all that it means now, perhaps in the future it will be
      extended to cover other kinds of window changes.  */
-  init_sig (SIGWINCH, "WINCH", "Window changed");
+  init_sig (SIGWINCH, "WINCH", _("Window changed"));
 #endif
 #if defined (SIGCONT)
-  init_sig (SIGCONT, "CONT", "Continued");
+  init_sig (SIGCONT, "CONT", _("Continued"));
 #endif
 #if defined (SIGURG)
-  init_sig (SIGURG, "URG", "Urgent I/O condition");
+  init_sig (SIGURG, "URG", _("Urgent I/O condition"));
 #endif
 #if defined (SIGIO)
   /* "I/O pending" has also been suggested.  A disadvantage is
      that signal only happens when the process has
      asked for it, not everytime I/O is pending.  Another disadvantage
      is the confusion from giving it a different name than under Unix.  */
-  init_sig (SIGIO, "IO", "I/O possible");
+  init_sig (SIGIO, "IO", _("I/O possible"));
 #endif
 #if defined (SIGWIND)
-  init_sig (SIGWIND, "WIND", "SIGWIND");
+  init_sig (SIGWIND, "WIND", _("SIGWIND"));
 #endif
 #if defined (SIGPHONE)
-  init_sig (SIGPHONE, "PHONE", "SIGPHONE");
+  init_sig (SIGPHONE, "PHONE", _("SIGPHONE"));
 #endif
 #if defined (SIGPOLL)
-  init_sig (SIGPOLL, "POLL", "I/O possible");
+  init_sig (SIGPOLL, "POLL", _("I/O possible"));
 #endif
 #if defined (SIGLOST)
-  init_sig (SIGLOST, "LOST", "Resource lost");
+  init_sig (SIGLOST, "LOST", _("Resource lost"));
 #endif
 #if defined (SIGDANGER)
-  init_sig (SIGDANGER, "DANGER", "Danger signal");
+  init_sig (SIGDANGER, "DANGER", _("Danger signal"));
 #endif
 #if defined (SIGINFO)
-  init_sig (SIGINFO, "INFO", "Information request");
+  init_sig (SIGINFO, "INFO", _("Information request"));
 #endif
 #if defined (SIGNOFP)
-  init_sig (SIGNOFP, "NOFP", "Floating point co-processor not available");
+  init_sig (SIGNOFP, "NOFP", _("Floating point co-processor not available"));
 #endif
 }
 
diff --git a/variable.c b/variable.c
index 5379cd5..d07b5e1 100644
--- a/variable.c
+++ b/variable.c
@@ -768,7 +768,7 @@ try_variable_definition (flocp, line, origin)
   expanded_name = allocated_variable_expand (name);
 
   if (expanded_name[0] == '\0')
-    fatal (flocp, "empty variable name");
+    fatal (flocp, _("empty variable name"));
 
   /* Calculate the variable's new value in VALUE.  */
 
@@ -1043,21 +1043,21 @@ print_variable_set (set, prefix)
     }
 
   if (nvariables == 0)
-    puts ("# No variables.");
+    puts (_("# No variables."));
   else
     {
-      printf ("# %u variables in %u hash buckets.\n",
+      printf (_("# %u variables in %u hash buckets.\n"),
 	      nvariables, set->buckets);
 #ifndef	NO_FLOAT
-      printf ("# average of %.1f variables per bucket, \
-max %u in one bucket.\n",
+      printf (_("# average of %.1f variables per bucket, \
+max %u in one bucket.\n"),
 	      (double) nvariables / (double) set->buckets,
 	      per_bucket);
 #else
       {
 	int f = (nvariables * 1000 + 5) / set->buckets;
-	printf ("# average of %d.%d variables per bucket, \
-max %u in one bucket.\n",
+	printf (_("# average of %d.%d variables per bucket, \
+max %u in one bucket.\n"),
 	      f/10, f%10,
 	      per_bucket);
       }
@@ -1071,7 +1071,7 @@ max %u in one bucket.\n",
 void
 print_variable_data_base ()
 {
-  puts ("\n# Variables\n");
+  puts (_("\n# Variables\n"));
 
   print_variable_set (&global_variable_set, "");
 }
diff --git a/vpath.c b/vpath.c
index 62df2a6..56a967f 100644
--- a/vpath.c
+++ b/vpath.c
@@ -549,7 +549,7 @@ print_vpath_data_base ()
   register unsigned int nvpaths;
   register struct vpath *v;
 
-  puts ("\n# VPATH Search Paths\n");
+  puts (_("\n# VPATH Search Paths\n"));
 
   nvpaths = 0;
   for (v = vpaths; v != 0; v = v->next)
@@ -566,18 +566,18 @@ print_vpath_data_base ()
     }
 
   if (vpaths == 0)
-    puts ("# No `vpath' search paths.");
+    puts (_("# No `vpath' search paths."));
   else
-    printf ("\n# %u `vpath' search paths.\n", nvpaths);
+    printf (_("\n# %u `vpath' search paths.\n"), nvpaths);
 
   if (general_vpath == 0)
-    puts ("\n# No general (`VPATH' variable) search path.");
+    puts (_("\n# No general (`VPATH' variable) search path."));
   else
     {
       register char **path = general_vpath->searchpath;
       register unsigned int i;
 
-      fputs ("\n# General (`VPATH' variable) search path:\n# ", stdout);
+      fputs (_("\n# General (`VPATH' variable) search path:\n# "), stdout);
 
       for (i = 0; path[i] != 0; ++i)
 	printf ("%s%c", path[i],
-- 
cgit v1.0-41-gc330

