@@ -19,10 +19,9 @@ basic_sspi_auth_SOURCES = \
 	valid.cc valid.h
 basic_sspi_auth_CXXFLAGS = -Wl,--enable-auto-import
 basic_sspi_auth_LDADD = \
+	$(top_builddir)/lib/libsspwin32.la \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
-	-L$(top_builddir)/lib \
-	-lsspwin32 \
-	-lmiscencoding \
 	-lnetapi32 -ladvapi32 \
 	$(XTRA_LIBS)
 
@@ -124,13 +124,6 @@ Valid_Group(char *UserName, char *Group)
     return result;
 }
 
-/* Valid_User return codes -
-   0 - User authenticated successfully.
-   1 - Server error.
-   2 - Group membership error.
-   3 - Logon error; Incorrect password or username given.
-*/
-
 int
 Valid_User(char *UserName, char *Password, char *Group)
 {
@@ -67,6 +67,16 @@ extern int debug_enabled;
 extern char Default_NTDomain[DNLEN+1];
 extern const char * errormsg;
 
+/**
+ * Valid_User return codes.
+ *
+ * \retval 0   User authenticated successfully.
+ * \retval 1   Server error.
+ * \retval 2   Group membership error.
+ * \retval 3   Logon error; Incorrect password or username given.
+ */
+int Valid_User(char *UserName, char *Password, char *Group);
+
 /* Debugging stuff */
 #if defined(__GNUC__)           /* this is really a gcc-ism */
 #include <unistd.h>
@@ -11,8 +11,8 @@ libexec_PROGRAMS = negotiate_sspi_auth
 
 negotiate_sspi_auth_SOURCES = negotiate_sspi_auth.cc
 
-LDADD	= \
-	-L$(top_builddir)/lib -lsspwin32 \
+LDADD = \
+	$(top_builddir)/lib/libsspwin32.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-ladvapi32 \
@@ -126,12 +126,26 @@ process_options(int argc, char *argv[])
         exit(1);
 }
 
+static bool
+token_decode(size_t *decodedLen, uint8_t decoded[], const char *buf)
+{
+    struct base64_decode_ctx ctx;
+    base64_decode_init(&ctx);
+    if (!base64_decode_update(&ctx, decodedLen, decoded, strlen(buf), reinterpret_cast<const uint8_t*>(buf)) ||
+            !base64_decode_final(&ctx)) {
+        SEND("BH base64 decode failed");
+        fprintf(stderr, "ERROR: base64 decoding failed for: '%s'\n", buf);
+        return false;
+    }
+    return true;
+}
+
 int
 manage_request()
 {
     char buf[HELPER_INPUT_BUFFER];
-    char decoded[HELPER_INPUT_BUFFER];
-    int decodedLen;
+    uint8_t decoded[HELPER_INPUT_BUFFER];
+    size_t decodedLen = 0;
     char helper_command[3];
     char *c;
     int status;
@@ -140,26 +154,27 @@ manage_request()
     static char cred[SSP_MAX_CRED_LEN + 1];
     BOOL Done = FALSE;
 
-try_again:
-    if (fgets(buf, HELPER_INPUT_BUFFER, stdin))
-        return 0;
+    do {
+        if (fgets(buf, HELPER_INPUT_BUFFER, stdin))
+            return 0;
 
-    c = static_cast<char*>(memchr(buf, '\n', HELPER_INPUT_BUFFER));
-    if (c) {
-        if (oversized) {
-            SEND("BH illegal request received");
-            fprintf(stderr, "ERROR: Illegal request received: '%s'\n", buf);
-            return 1;
+        c = static_cast<char*>(memchr(buf, '\n', HELPER_INPUT_BUFFER));
+        if (c) {
+            if (oversized) {
+                SEND("BH illegal request received");
+                fprintf(stderr, "ERROR: Illegal request received: '%s'\n", buf);
+                return 1;
+            }
+            *c = '\0';
+        } else {
+            fprintf(stderr, "No newline in '%s'\n", buf);
+            oversized = 1;
         }
-        *c = '\0';
-    } else {
-        fprintf(stderr, "No newline in '%s'\n", buf);
-        oversized = 1;
-        goto try_again;
-    }
+    } while (!c);
 
     if ((strlen(buf) > 3) && Negotiate_packet_debug_enabled) {
-        decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
+        if (!token_decode(&decodedLen, decoded, buf+3))
+            return 1;
         strncpy(helper_command, buf, 2);
         debug("Got '%s' from Squid with data:\n", helper_command);
         hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
@@ -168,9 +183,10 @@ manage_request()
 
     if (memcmp(buf, "YR ", 3) == 0) {   /* refresh-request */
         /* figure out what we got */
-        decodedLen = base64_decode(decoded, sizeof(decoded), buf + 3);
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
-            SEND("NA * Packet format error, couldn't base64-decode");
+        if (!decodedLen /* already decoded */ && !token_decode(&decodedLen, decoded, buf+3))
+            return 1;
+        if (decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
+            SEND("NA * Packet format error");
             return 1;
         }
         /* Obtain server blob against SSPI */
@@ -182,7 +198,8 @@ manage_request()
                 have_serverblob = 0;
                 Done = FALSE;
                 if (Negotiate_packet_debug_enabled) {
-                    decodedLen = base64_decode(decoded, sizeof(decoded), c);
+                    if (!token_decode(&decodedLen, decoded, c))
+                        return 1;
                     debug("sending 'AF' %s to squid with data:\n", cred);
                     if (c != NULL)
                         hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
@@ -193,7 +210,8 @@ manage_request()
                     SEND3("AF %s %s", c, cred);
             } else {
                 if (Negotiate_packet_debug_enabled) {
-                    decodedLen = base64_decode(decoded, sizeof(decoded), c);
+                    if (!token_decode(&decodedLen, decoded, c))
+                        return 1;
                     debug("sending 'TT' to squid with data:\n");
                     hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                     printf("TT %s\n", c);
@@ -212,9 +230,10 @@ manage_request()
             return 1;
         }
         /* figure out what we got */
-        decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
-            SEND("NA * Packet format error, couldn't base64-decode");
+        if (!decodedLen /* already decoded */ && !token_decode(&decodedLen, decoded, buf+3))
+            return 1;
+        if (decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
+            SEND("NA * Packet format error");
             return 1;
         }
         /* check against SSPI */
@@ -242,7 +261,8 @@ manage_request()
             have_serverblob = 0;
             Done = FALSE;
             if (Negotiate_packet_debug_enabled) {
-                decodedLen = base64_decode(decoded, sizeof(decoded), c);
+                if (!token_decode(&decodedLen, decoded, c))
+                    return 1;
                 debug("sending 'AF' %s to squid with data:\n", cred);
                 if (c != NULL)
                     hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
@@ -255,7 +275,8 @@ manage_request()
             return 1;
         } else {
             if (Negotiate_packet_debug_enabled) {
-                decodedLen = base64_decode(decoded, sizeof(decoded), c);
+                if (!token_decode(&decodedLen, decoded, c))
+                    return 1;
                 debug("sending 'TT' to squid with data:\n");
                 hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                 printf("TT %s\n", c);
@@ -15,7 +15,7 @@ ntlm_sspi_auth_SOURCES = ntlm_sspi_auth.cc
 
 LDADD = \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
-	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libsspwin32.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
@@ -413,13 +413,27 @@ process_options(int argc, char *argv[])
         exit(1);
 }
 
+static bool
+token_decode(size_t *decodedLen, uint8_t decoded[], const char *buf)
+{
+    struct base64_decode_ctx ctx;
+    base64_decode_init(&ctx);
+    if (!base64_decode_update(&ctx, decodedLen, decoded, strlen(buf), reinterpret_cast<const uint8_t*>(buf)) ||
+            !base64_decode_final(&ctx)) {
+        SEND_BH("message=\"base64 decode failed\"");
+        fprintf(stderr, "ERROR: base64 decoding failed for: '%s'\n", buf);
+        return false;
+    }
+    return true;
+}
+
 int
 manage_request()
 {
     ntlmhdr *fast_header;
     char buf[HELPER_INPUT_BUFFER];
-    char decoded[HELPER_INPUT_BUFFER];
-    int decodedLen;
+    uint8_t decoded[HELPER_INPUT_BUFFER];
+    size_t decodedLen = 0;
     char helper_command[3];
     int oversized = 0;
     char * ErrorMessage;
@@ -459,23 +473,25 @@ manage_request()
     } while (false);
 
     if ((strlen(buf) > 3) && NTLM_packet_debug_enabled) {
-        decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
+        if (!token_decode(&decodedLen, decoded, buf+3))
+            return 1;
         strncpy(helper_command, buf, 2);
         debug("Got '%s' from Squid with data:\n", helper_command);
         hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
     } else
         debug("Got '%s' from Squid\n", buf);
     if (memcmp(buf, "YR", 2) == 0) {    /* refresh-request */
         /* figure out what we got */
-        if (strlen(buf) > 3)
-            decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
-        else {
+        if (strlen(buf) > 3) {
+            if (!decodedLen /* already decoded*/ && !token_decode(&decodedLen, decoded, buf+3))
+                return 1;
+        } else {
             debug("Negotiate packet not supplied - self generated\n");
             memcpy(decoded, &local_nego, sizeof(local_nego));
             decodedLen = sizeof(local_nego);
         }
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
-            SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
+            SEND_ERR("message=\"Packet format error\"");
             return 1;
         }
         /* fast-track-decode request type. */
@@ -494,7 +510,8 @@ manage_request()
             if (c) {
                 SEND_TT(c);
                 if (NTLM_packet_debug_enabled) {
-                    decodedLen = base64_decode(decoded, sizeof(decoded), c);
+                    if (!token_decode(&decodedLen, decoded, c))
+                        return 1;
                     debug("send 'TT' to squid with data:\n");
                     hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                     if (NTLM_LocalCall) {
@@ -528,10 +545,11 @@ manage_request()
             return 1;
         }
         /* figure out what we got */
-        decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
+        if (!decodedLen /* already decoded*/ && !token_decode(&decodedLen, decoded, buf+3))
+            return 1;
 
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
-            SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
+            SEND_ERR("message=\"Packet format error\"");
             return 1;
         }
         /* fast-track-decode request type. */
@@ -462,7 +462,6 @@ const char * WINAPI SSP_MakeChallenge(PVOID PNegotiateBuf, int NegotiateLen)
     DWORD       cbOut      = 0;
     DWORD       cbIn       = 0;
     ntlm_challenge * challenge;
-    const char * encoded = NULL;
 
     if (NTLM_asServer.fHaveCtxtHandle)
         _DeleteSecurityContext(&NTLM_asServer.hctxt);
@@ -490,9 +489,17 @@ const char * WINAPI SSP_MakeChallenge(PVOID PNegotiateBuf, int NegotiateLen)
         challenge = (ntlm_challenge *) fResult;
         Use_Unicode = NTLM_NEGOTIATE_UNICODE & challenge->flags;
         NTLM_LocalCall = NTLM_NEGOTIATE_THIS_IS_LOCAL_CALL & challenge->flags;
-        encoded = base64_encode_bin((char *) fResult, cbOut);
+        struct base64_encode_ctx ctx;
+        base64_encode_init(&ctx);
+        static uint8_t encoded[8192];
+        size_t dstLen = base64_encode_update(&ctx, encoded, cbOut, reinterpret_cast<const uint8_t*>(fResult));
+        assert(dstLen < sizeof(encoded));
+        dstLen += base64_encode_final(&ctx, encoded+dstLen);
+        assert(dstLen < sizeof(encoded));
+        encoded[dstLen] = '\0';
+        return reinterpret_cast<char *>(encoded);
     }
-    return encoded;
+    return NULL;
 }
 
 BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID PAutenticateBuf, int AutenticateLen, char * credentials)
@@ -524,7 +531,6 @@ const char * WINAPI SSP_MakeNegotiateBlob(PVOID PNegotiateBuf, int NegotiateLen,
 {
     DWORD       cbOut      = 0;
     DWORD       cbIn       = 0;
-    const char * encoded = NULL;
 
     if (NTLM_asServer.fHaveCtxtHandle)
         _DeleteSecurityContext(&NTLM_asServer.hctxt);
@@ -548,16 +554,24 @@ const char * WINAPI SSP_MakeNegotiateBlob(PVOID PNegotiateBuf, int NegotiateLen,
         }
         *Status = SSP_OK;
     } while (0);
-    if (pServerBuf != NULL && cbOut > 0)
-        encoded = base64_encode_bin((char *) pServerBuf, cbOut);
-    return encoded;
+    if (pServerBuf != NULL && cbOut > 0) {
+        struct base64_encode_ctx ctx;
+        base64_encode_init(&ctx);
+        static uint8_t encoded[8192];
+        size_t dstLen = base64_encode_update(&ctx, encoded, cbOut, reinterpret_cast<const uint8_t*>(pServerBuf));
+        assert(dstLen < sizeof(encoded));
+        dstLen += base64_encode_final(&ctx, encoded+dstLen);
+        assert(dstLen < sizeof(encoded));
+        encoded[dstLen] = '\0';
+        return reinterpret_cast<char *>(encoded);
+    }
+    return NULL;
 }
 
 const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID PAutenticateBuf, int AutenticateLen, PBOOL fDone, int * Status, char * credentials)
 {
     DWORD       cbOut      = 0;
     DWORD       cbIn       = 0;
-    const char * encoded = NULL;
 
     memcpy(pClientBuf, PAutenticateBuf, AutenticateLen);
     ZeroMemory(pServerBuf, cbMaxToken);
@@ -575,8 +589,17 @@ const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID PAutenticateBuf, int
         }
         *Status = SSP_OK;
     } while (0);
-    if (pServerBuf != NULL && cbOut > 0)
-        encoded = base64_encode_bin((char *) pServerBuf, cbOut);
-    return encoded;
+    if (pServerBuf != NULL && cbOut > 0) {
+        struct base64_encode_ctx ctx;
+        base64_encode_init(&ctx);
+        static uint8_t encoded[8192];
+        size_t dstLen = base64_encode_update(&ctx, encoded, cbOut, reinterpret_cast<const uint8_t*>(pServerBuf));
+        assert(dstLen < sizeof(encoded));
+        dstLen += base64_encode_final(&ctx, encoded+dstLen);
+        assert(dstLen < sizeof(encoded));
+        encoded[dstLen] = '\0';
+        return reinterpret_cast<char *>(encoded);
+    }
+    return NULL;
 }
 
@@ -541,8 +541,14 @@ Ssl::PeerConnector::handleNegotiateError(const int ret)
         // In this case the connection can be saved.
         // If the checklist decision is do not splice a new error will
         // occure in the next SSL_connect call, and we will fail again.
+        // Abort on certificate validation errors to avoid splicing and
+        // thus hiding them.
+        // Abort if no certificate found probably because of malformed or
+        // unsupported server Hello message (TODO: make configurable).
 #if 1
-        if ((request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
+        if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) &&
+                SSL_get_peer_certificate(ssl) &&
+                (request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek  || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) && srvBio->holdWrite()) {
             debugs(81, 3, "Error ("  << ERR_error_string(ssl_lib_error, NULL) <<  ") but, hold write on SSL connection on FD " << fd);
             checkForPeekAndSplice();
             return;