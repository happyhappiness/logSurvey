@@ -3,7 +3,7 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.388 2005/10/23 11:55:31 hno Exp $
+dnl  $Id: configure.in,v 1.389 2005/10/30 21:48:21 serassio Exp $
 dnl
 dnl
 dnl
@@ -13,7 +13,7 @@ AC_CONFIG_SRCDIR([src/main.cc])
 AC_CONFIG_AUX_DIR(cfgaux)
 AM_INIT_AUTOMAKE(squid, 3.0-PRE3-CVS)
 AM_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.388 $)dnl
+AC_REVISION($Revision: 1.389 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AM_MAINTAINER_MODE
 
@@ -1352,6 +1352,43 @@ if test -n "$NTLM_AUTH_HELPERS"; then
 fi
 AC_SUBST(NTLM_AUTH_HELPERS)
 
+dnl Select negotiate auth helpers to build
+NEGOTIATE_AUTH_HELPERS=
+AC_ARG_ENABLE(negotiate-auth-helpers,
+[  --enable-negotiate-auth-helpers=\"list of helpers\"
+                          This option selects which proxy_auth negotiate helpers
+                          to build and install as part of the normal build 
+                          process. For a list of available helpers see
+                          the helpers/negotiate_auth directory.],
+[ case "$enableval" in
+  yes) 
+	for dir in $srcdir/helpers/negotiate_auth/*; do
+	    helper="`basename $dir`"
+	    if test -d "$dir" && test "$helper" != CVS; then
+		NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
+	    fi
+	done
+	;;
+  no)
+	;;
+  *)
+	NEGOTIATE_AUTH_HELPERS="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`"
+	;;
+  esac
+])
+if test -n "$NEGOTIATE_AUTH_HELPERS"; then
+    for helper in $NEGOTIATE_AUTH_HELPERS; do
+	if test -d $srcdir/helpers/negotiate_auth/$helper; then
+	    :
+	else
+	    echo "ERROR: Negotiate Auth helper $helper does not exists"
+	    exit 1
+	fi
+    done
+    echo "Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS"
+fi
+AC_SUBST(NEGOTIATE_AUTH_HELPERS)
+
 dnl Select digest auth scheme helpers to build
 DIGEST_AUTH_HELPERS=
 AC_ARG_ENABLE(digest-auth-helpers,
@@ -2898,6 +2935,7 @@ AC_CONFIG_FILES([\
 	helpers/basic_auth/NCSA/Makefile \
 	helpers/basic_auth/PAM/Makefile \
 	helpers/basic_auth/SMB/Makefile \
+	helpers/basic_auth/mswin_sspi/Makefile \
 	helpers/basic_auth/YP/Makefile \
 	helpers/basic_auth/getpwnam/Makefile \
 	helpers/basic_auth/multi-domain-NTLM/Makefile \
@@ -2909,6 +2947,9 @@ AC_CONFIG_FILES([\
 	helpers/ntlm_auth/no_check/Makefile \
 	helpers/ntlm_auth/SMB/Makefile \
 	helpers/ntlm_auth/SMB/smbval/Makefile \
+	helpers/ntlm_auth/mswin_sspi/Makefile \
+	helpers/negotiate_auth/Makefile \
+	helpers/negotiate_auth/mswin_sspi/Makefile \
 	helpers/external_acl/Makefile \
 	helpers/external_acl/ip_user/Makefile \
 	helpers/external_acl/ldap_group/Makefile \
@@ -1 +1 @@
-SUBDIRS = basic_auth ntlm_auth digest_auth external_acl
+SUBDIRS = basic_auth ntlm_auth digest_auth negotiate_auth external_acl
@@ -1,7 +1,7 @@
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.5 2005/07/01 22:34:50 hno Exp $
+#  $Id: Makefile.am,v 1.6 2005/10/30 21:48:21 serassio Exp $
 #
 
-DIST_SUBDIRS	= getpwnam LDAP MSNT multi-domain-NTLM NCSA PAM SMB YP SASL
+DIST_SUBDIRS	= getpwnam LDAP MSNT multi-domain-NTLM NCSA PAM SMB YP SASL mswin_sspi
 SUBDIRS		= @BASIC_AUTH_HELPERS@
@@ -0,0 +1 @@
+Makefile
@@ -0,0 +1,19 @@
+#
+#  Makefile for the Squid Object Cache server
+#
+#  $Id: Makefile.am,v 1.1 2005/10/30 21:48:21 serassio Exp $
+#
+#  Uncomment and customize the following to suit your needs:
+#
+
+
+libexec_PROGRAMS = mswin_auth
+
+mswin_auth_SOURCES = mswin_auth.c valid.c valid.h
+
+LDADD	= -L$(top_builddir)/lib -lnetapi32 -ladvapi32 -lsspwin32 \
+          -lmiscutil $(XTRA_LIBS)
+
+INCLUDES = -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/src
+
+EXTRA_DIST = README.txt
@@ -0,0 +1,188 @@
+/*
+  NT_auth -  Version 2.0
+
+  Returns OK for a successful authentication, or ERR upon error.
+
+  Guido Serassio, Torino - Italy
+
+  Uses code from -
+    Antonino Iannella 2000
+    Andrew Tridgell 1997
+    Richard Sharpe 1996
+    Bill Welliver 1999
+
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+*/
+
+#include "config.h"
+#include <stdio.h> 	 
+#include <getopt.h> 	 
+#include "util.h"
+
+/* Check if we try to compile on a Windows Platform */
+#if defined(_SQUID_CYGWIN_) || defined(_SQUID_MSWIN_)
+
+#include "valid.h"
+
+static char NTGroup[256];
+char * NTAllowedGroup;
+char * NTDisAllowedGroup;
+int UseDisallowedGroup = 0;
+int UseAllowedGroup = 0;
+int debug_enabled = 0;
+
+/*
+ * options:
+ * -A can specify a Windows Local Group name allowed to authenticate.
+ * -D can specify a Windows Local Group name not allowed to authenticate.
+ * -O can specify the default Domain against to authenticate.
+ */
+char *my_program_name = NULL;
+
+void
+usage()
+{
+    fprintf(stderr,
+	"%s usage:\n%s [-A|D UserGroup][-O DefaultDomain][-d]\n"
+	"-A can specify a Windows Local Group name allowed to authenticate\n"
+	"-D can specify a Windows Local Group name not allowed to authenticate\n"
+	"-O can specify the default Domain against to authenticate\n"
+	"-d enable debugging.\n"
+	"-h this message\n\n",
+	my_program_name, my_program_name);
+}
+
+void
+process_options(int argc, char *argv[])
+{
+    int opt, had_error = 0;
+    while (-1 != (opt = getopt(argc, argv, "dhA:D:O:"))) {
+	switch (opt) {
+	case 'A':
+	    safe_free(NTAllowedGroup);
+	    NTAllowedGroup=xstrdup(optarg);
+	    UseAllowedGroup = 1;
+	    break;
+	case 'D':
+	    safe_free(NTDisAllowedGroup);
+	    NTDisAllowedGroup=xstrdup(optarg);
+	    UseDisallowedGroup = 1;
+	    break;
+	case 'O':
+	    strncpy(Default_NTDomain, optarg, DNLEN);
+	    break;
+	case 'd':
+	    debug_enabled = 1;
+	    break;
+	case 'h':
+	    usage(argv[0]);
+	    exit(0);
+	case '?':
+	    opt = optopt;
+	    /* fall thru to default */
+	default:
+	    fprintf(stderr, "Unknown option: -%c. Exiting\n", opt);
+	    had_error = 1;
+	}
+    }
+    if (had_error) {
+	usage();
+	exit(1);
+    }
+}
+
+/* Main program for simple authentication.
+   Scans and checks for Squid input, and attempts to validate the user.
+*/
+
+int
+main(int argc, char **argv)
+
+{
+    char wstr[256];
+    char username[256];
+    char password[256];
+    char *p;
+    int err = 0;
+
+    my_program_name = argv[0];
+    process_options(argc, argv);
+
+    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+
+    if (LoadSecurityDll(SSP_BASIC, NTLM_PACKAGE_NAME) == NULL) {
+	fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
+	exit(1);
+    }
+    debug("SSPI initialized OK\n");
+
+    atexit(UnloadSecurityDll);
+
+        /* initialize FDescs */
+    setbuf(stdout, NULL);
+    setbuf(stderr, NULL);
+
+    while (1) {
+	/* Read whole line from standard input. Terminate on break. */
+	if (fgets(wstr, 255, stdin) == NULL)
+	    break;
+
+	if (NULL == strchr(wstr, '\n')) {
+	    err = 1;
+	    continue;
+	}
+	if (err) {
+	    fprintf(stderr, "Oversized message\n");
+            puts("ERR");
+	    goto error;
+	}
+	
+	if ((p = strchr(wstr, '\n')) != NULL)
+	    *p = '\0';		/* strip \n */
+	if ((p = strchr(wstr, '\r')) != NULL)
+	    *p = '\0';		/* strip \r */
+	/* Clear any current settings */
+	username[0] = '\0';
+	password[0] = '\0';
+	sscanf(wstr, "%s %s", username, password);	/* Extract parameters */
+
+        debug("Got %s from Squid\n", wstr);
+
+	/* Check for invalid or blank entries */
+	if ((username[0] == '\0') || (password[0] == '\0')) {
+	    fprintf(stderr, "Invalid Request\n");
+	    puts("ERR");
+	    fflush(stdout);
+	    continue;
+	}
+	rfc1738_unescape(username);
+	rfc1738_unescape(password);
+
+        debug("Trying to validate; %s %s\n", username, password);
+
+	if (Valid_User(username, password, NTGroup) == NTV_NO_ERROR)
+	    puts("OK");
+	else
+            printf("ERR %s\n", errormsg);
+error:
+	err = 0;
+	fflush(stdout);
+    }
+    return 0;
+}
+
+#else  /* NON Windows Platform !!! */
+
+#error NON WINDOWS PLATFORM
+
+#endif
@@ -0,0 +1,101 @@
+This is a simple authentication module for the Squid proxy server running on Windows NT
+to authenticate users on an NT domain in native WIN32 mode.
+
+Usage is simple. It accepts a username and password on standard input
+and will return OK if the username/password is valid for the domain/machine,
+or ERR if there was some problem.
+It's possible to authenticate against NT trusted domains specifyng the username 
+in the domain\\username Microsoft notation. 
+
+
+==============
+Program Syntax
+==============
+
+mswin_auth [-A UserGroup][-D UserGroup][-O DefaultDomain][-d]
+
+-A can specify a Windows Local Group name allowed to authenticate.
+-D can specify a Windows Local Group name not allowed to authenticate.
+-O can specify the default Domain against to authenticate.
+-d enable debugging.
+
+This is released under the GNU General Public License.
+
+
+==============
+Allowing Users
+==============
+
+Users that are allowed to access the web proxy must have the Windows NT
+User Rights "logon from the network" and must be included in the NT LOCAL User Groups 
+specified in the Authenticator's command line. 
+This can be accomplished creating a local user group on the NT machine, grant the privilege,
+and adding users to it.
+
+Refer to Squid documentation for the required changes to squid.conf.
+
+
+============
+Installation
+============
+
+Type 'make', then 'make install', then 'make clean'.
+
+On Cygwin the default is to install 'mswin_auth' into /usr/local/squid/libexec,
+with other Windows environments into c:/squid/libexec.
+
+Refer to Squid documentation for the required changes to squid.conf.
+You will need to set the following line to enable the authenticator:
+
+auth_param basic program /usr/local/squid/libexec/mswin_auth [options]
+
+or
+
+auth_param basic program c:/squid/libexec/mswin_auth [options]
+
+You will need to set the following lines to enable authentication for
+your access list -
+
+  acl <yourACL> proxy_auth REQUIRED
+  http_access allow <yourACL>
+
+You will need to specify the absolute path to mswin_auth in the 
+'auth_param basic program' directive, and check the 'auth_param basic children'
+and 'auth_param basic credentialsttl'.
+
+
+==================
+Compilation issues
+==================
+
+The Makefile assumes that GCC is in the current PATH.
+mswin_auth compile ONLY on Cygwin Environment, MinGW + MSYS Environment
+or MS VC++.
+
+
+=======
+Testing
+=======
+
+I strongly urge that mswin_auth is tested prior to being used in a 
+production environment. It may behave differently on different platforms.
+To test it, run it from the command line. Enter username and password
+pairs separated by a space. Press ENTER to get an OK or ERR message.
+Make sure pressing <CTRL><D> behaves the same as a carriage return.
+Make sure pressing <CTRL><C> aborts the program.
+
+Test that entering no details does not result in an OK or ERR message.
+Test that entering an invalid username and password results in an ERR message.
+Note that if NT guest user access is allowed on the PDC, an OK message
+may be returned instead of ERR.
+Test that entering an valid username and password results in an OK message.
+Test that entering a guest username and password returns the correct
+response for the site's access policy.
+
+
+===============
+Contact details
+===============
+
+To contact the maintainer of this package, e-mail on squidnt@acmeconsulting.it.
+
@@ -0,0 +1,181 @@
+/*
+  NT_auth -  Version 2.0
+
+  Modified to act as a Squid authenticator module.
+  Removed all Pike stuff.
+  Returns OK for a successful authentication, or ERR upon error.
+
+  Guido Serassio, Torino - Italy
+
+  Uses code from -
+    Antonino Iannella 2000
+    Andrew Tridgell 1997
+    Richard Sharpe 1996
+    Bill Welliver 1999
+
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+*/
+
+#include "util.h"
+
+/* Check if we try to compile on a Windows Platform */
+#if defined(_SQUID_CYGWIN_) || defined(_SQUID_MSWIN_)
+
+#if defined(_SQUID_CYGWIN_)
+#include <wchar.h>
+#endif
+#include "valid.h"
+
+char Default_NTDomain[DNLEN+1] = NTV_DEFAULT_DOMAIN;
+const char * errormsg;
+
+const char NTV_SERVER_ERROR_MSG[] = "Internal server errror";
+const char NTV_GROUP_ERROR_MSG[] = "User not allowed to use this cache";
+const char NTV_LOGON_ERROR_MSG[] = "No such user or wrong password";
+const char NTV_VALID_DOMAIN_SEPARATOR[] = "\\/";
+
+/* returns 1 on success, 0 on failure */
+int
+Valid_Group(char *UserName, char *Group)
+{
+    int result = FALSE;
+    WCHAR wszUserName[256];	// Unicode user name
+    WCHAR wszGroup[256];	// Unicode Group
+
+    LPLOCALGROUP_USERS_INFO_0 pBuf = NULL;
+    LPLOCALGROUP_USERS_INFO_0 pTmpBuf;
+    DWORD dwLevel = 0;
+    DWORD dwFlags = LG_INCLUDE_INDIRECT;
+    DWORD dwPrefMaxLen = -1;
+    DWORD dwEntriesRead = 0;
+    DWORD dwTotalEntries = 0;
+    NET_API_STATUS nStatus;
+    DWORD i;
+    DWORD dwTotalCount = 0;
+
+/* Convert ANSI User Name and Group to Unicode */
+
+    MultiByteToWideChar(CP_ACP, 0, UserName,
+	strlen(UserName) + 1, wszUserName,
+	sizeof(wszUserName) / sizeof(wszUserName[0]));
+    MultiByteToWideChar(CP_ACP, 0, Group,
+	strlen(Group) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
+
+    /*
+     * Call the NetUserGetLocalGroups function 
+	 * specifying information level 0.
+	 * 
+	 * The LG_INCLUDE_INDIRECT flag specifies that the 
+	 * function should also return the names of the local 
+	 * groups in which the user is indirectly a member.
+	 */
+	nStatus = NetUserGetLocalGroups(NULL,
+	    wszUserName,
+	    dwLevel,
+	    dwFlags,
+	    (LPBYTE *) & pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries);
+	/*
+	 * If the call succeeds,
+	 */
+    if (nStatus == NERR_Success) {
+	if ((pTmpBuf = pBuf) != NULL) {
+	    for (i = 0; i < dwEntriesRead; i++) {
+		if (pTmpBuf == NULL) {
+		    result = FALSE;
+		    break;
+		}
+		if (wcscmp(pTmpBuf->lgrui0_name, wszGroup) == 0) {
+		    result = TRUE;
+		    break;
+		}
+		pTmpBuf++;
+		dwTotalCount++;
+	    }
+	}
+    } else
+	    result = FALSE;
+/*
+ * Free the allocated memory.
+ */
+    if (pBuf != NULL)
+	NetApiBufferFree(pBuf);
+    return result;
+}
+
+/* Valid_User return codes -
+   0 - User authenticated successfully.
+   1 - Server error.
+   2 - Group membership error.
+   3 - Logon error; Incorrect password or username given.
+*/
+
+int
+Valid_User(char *UserName, char *Password, char *Group)
+{
+    int result = NTV_SERVER_ERROR;
+    size_t i;
+    char NTDomain[256];
+    char *domain_qualify;
+    char DomainUser[256];
+    char User[256];
+
+    errormsg = NTV_SERVER_ERROR_MSG;
+    strncpy(NTDomain, UserName, sizeof(NTDomain));
+
+    for (i=0; i < strlen(NTV_VALID_DOMAIN_SEPARATOR); i++) {
+        if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[i])) != NULL)
+            break;
+    }
+    if (domain_qualify == NULL) {
+	strcpy(User, NTDomain);
+	strcpy(NTDomain, Default_NTDomain);
+    } else {
+	strcpy(User, domain_qualify + 1);
+	domain_qualify[0] = '\0';
+    }
+    /* Log the client on to the local computer. */
+    if (!SSP_LogonUser(User, Password, NTDomain)) {
+	result = NTV_LOGON_ERROR;
+        errormsg = NTV_LOGON_ERROR_MSG;
+        debug("%s\n", errormsg);
+    } else {
+	result = NTV_NO_ERROR;
+	if (strcmp(NTDomain, NTV_DEFAULT_DOMAIN) == 0)
+	    strcpy(DomainUser, User);
+	else {
+	    strcpy(DomainUser, NTDomain);
+	    strcat(DomainUser, "\\");
+	    strcat(DomainUser, User);
+	}
+	if (UseAllowedGroup) {
+	    if (!Valid_Group(DomainUser, NTAllowedGroup)) {
+		result = NTV_GROUP_ERROR;
+                errormsg = NTV_GROUP_ERROR_MSG;
+                debug("%s\n", errormsg);
+	    }
+	}
+	if (UseDisallowedGroup) {
+	    if (Valid_Group(DomainUser, NTDisAllowedGroup)) {
+		result = NTV_GROUP_ERROR;
+                errormsg = NTV_GROUP_ERROR_MSG;
+                debug("%s\n", errormsg);
+	    }
+	}
+    }
+    return result;
+}
+#else  /* NON Windows Platform !!! */
+
+#error NON WINDOWS PLATFORM
+
+#endif
@@ -0,0 +1,107 @@
+/*
+  NT_auth -  Version 2.0
+
+  Modified to act as a Squid authenticator module.
+  Returns OK for a successful authentication, or ERR upon error.
+
+  Guido Serassio, Torino - Italy
+
+  Uses code from -
+    Antonino Iannella 2000
+    Andrew Tridgell 1997
+    Richard Sharpe 1996
+    Bill Welliver 1999
+
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+*/
+
+#ifndef _VALID_H_
+#define _VALID_H_
+
+#ifdef _SQUID_CYGWIN_
+#include <windows.h>
+#endif
+#include <lm.h>
+#include "sspwin32.h"
+#undef debug
+
+/************* CONFIGURATION ***************/
+/*
+ * define this if you want debugging
+ */
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+#define safe_free(x)	if (x) { free(x); x = NULL; }
+
+/* SMB User verification function */
+
+#define NTV_NO_ERROR 0
+#define NTV_SERVER_ERROR 1
+#define NTV_GROUP_ERROR 2
+#define NTV_LOGON_ERROR 3
+
+#ifndef LOGON32_LOGON_NETWORK
+#define LOGON32_LOGON_NETWORK       3
+#endif
+
+#define NTV_DEFAULT_DOMAIN "."
+
+extern char * NTAllowedGroup;
+extern char * NTDisAllowedGroup;
+extern int UseDisallowedGroup;
+extern int UseAllowedGroup;
+extern int debug_enabled;
+extern char Default_NTDomain[DNLEN+1];
+extern const char * errormsg;
+
+#include <sys/types.h>
+
+/* Debugging stuff */
+
+#ifdef __GNUC__			/* this is really a gcc-ism */
+#ifdef DEBUG
+#include <stdio.h>
+#include <unistd.h>
+static char *__foo;
+#define debug(X...) if (debug_enabled) { \
+                    fprintf(stderr,"nt_auth[%d](%s:%d): ", getpid(), \
+                    ((__foo=strrchr(__FILE__,'/'))==NULL?__FILE__:__foo+1),\
+                    __LINE__);\
+                    fprintf(stderr,X); }
+#else /* DEBUG */
+#define debug(X...)		/* */
+#endif /* DEBUG */
+#else /* __GNUC__ */
+static void
+debug(char *format,...) 
+{
+#ifdef DEBUG
+#ifdef _SQUID_MSWIN_
+    if (debug_enabled) {
+	va_list args;
+
+	va_start(args,format);
+	fprintf(stderr, "nt_auth[%d]: ",getpid());
+	vfprintf(stderr, format, args);
+	va_end(args);
+    }
+#endif /* _SQUID_MSWIN_ */
+#endif /* DEBUG */
+}
+#endif /* __GNUC__ */
+
+int Valid_User(char *,char *, char *);
+
+#endif
@@ -0,0 +1 @@
+Makefile
@@ -0,0 +1,7 @@
+#  Makefile for negotiate authentication helpers in the Squid Object Cache server
+#
+#  $Id: Makefile.am,v 1.1 2005/10/30 21:48:21 serassio Exp $
+#
+
+DIST_SUBDIRS	= mswin_sspi
+SUBDIRS		= @NEGOTIATE_AUTH_HELPERS@
@@ -0,0 +1 @@
+Makefile
@@ -0,0 +1,16 @@
+#
+#  Makefile for the Squid Object Cache server
+#
+#  $Id: Makefile.am,v 1.1 2005/10/30 21:48:21 serassio Exp $
+#
+
+libexec_PROGRAMS = mswin_negotiate_auth
+
+mswin_negotiate_auth_SOURCES = libnegotiatessp.c negotiate_auth.c negotiate.h
+
+INCLUDES      = -I. -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/src
+
+LDADD		= -L$(top_builddir)/lib -lsspwin32 -lnetapi32 \
+		  -ladvapi32 -lmiscutil $(XTRA_LIBS)
+
+EXTRA_DIST = readme.txt
@@ -0,0 +1,83 @@
+/*
+ * (C) 2002 Guido Serassio <serassio@libero.it>
+ * Based on previous work of Francesco Chemolli and Robert Collins
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+typedef unsigned char uchar;
+
+#include "util.h"
+#include "negotiate.h"
+#if HAVE_CTYPE_H
+#include <ctype.h>
+#endif
+
+void hex_dump(void *data, int size)
+{
+    /* dumps size bytes of *data to stdout. Looks like:
+     * [0000] 75 6E 6B 6E 6F 77 6E 20
+     *                  30 FF 00 00 00 00 39 00 unknown 0.....9.
+     * (in a single line of course)
+     */
+
+    if (!data)
+        return;
+
+    if (debug_enabled) {
+        unsigned char *p = data;
+        unsigned char c;
+        int n;
+        char bytestr[4] = {0};
+        char addrstr[10] = {0};
+        char hexstr[ 16*3 + 5] = {0};
+        char charstr[16*1 + 5] = {0};
+        for(n=1;n<=size;n++) {
+            if (n%16 == 1) {
+                /* store address for this line */
+                snprintf(addrstr, sizeof(addrstr), "%.4x",
+                   ((unsigned int)p-(unsigned int)data) );
+            }
+            
+            c = *p;
+            if (isalnum(c) == 0) {
+                c = '.';
+            }
+
+            /* store hex str (for left side) */
+            snprintf(bytestr, sizeof(bytestr), "%02X ", *p);
+            strncat(hexstr, bytestr, sizeof(hexstr)-strlen(hexstr)-1);
+
+            /* store char str (for right side) */
+            snprintf(bytestr, sizeof(bytestr), "%c", c);
+            strncat(charstr, bytestr, sizeof(charstr)-strlen(charstr)-1);
+
+            if(n%16 == 0) { 
+                /* line completed */
+                fprintf(stderr, "[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
+                hexstr[0] = 0;
+                charstr[0] = 0;
+            } else if(n%8 == 0) {
+                /* half line: add whitespaces */
+                strncat(hexstr, "  ", sizeof(hexstr)-strlen(hexstr)-1);
+                strncat(charstr, " ", sizeof(charstr)-strlen(charstr)-1);
+            }
+            p++; /* next byte */
+        }
+
+        if (strlen(hexstr) > 0) {
+            /* print rest of buffer if not empty */
+            fprintf(stderr, "[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
+        }
+    }
+}
+
@@ -0,0 +1,116 @@
+/*
+ * (C) 2002 Guido Serassio <serassio@libero.it>
+ * Based on previous work of Francesco Chemolli, Robert Collins and Andrew Doran
+ *
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#ifndef _NTLM_H_
+#define _NTLM_H_
+
+#include "sspwin32.h"
+#include <windows.h>
+#include <sspi.h>
+#include <security.h>
+#include "ntlmauth.h"
+#undef debug
+
+/************* CONFIGURATION ***************/
+/*
+ * define this if you want debugging
+ */
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+#define FAIL_DEBUG 0
+
+/************* END CONFIGURATION ***************/
+
+#include <sys/types.h>
+
+extern int debug_enabled;
+#if FAIL_DEBUG
+extern int fail_debug_enabled;
+#endif
+
+/* Debugging stuff */
+
+#ifdef __GNUC__			/* this is really a gcc-ism */
+#ifdef DEBUG
+#include <stdio.h>
+#include <unistd.h>
+static char *__foo;
+#define debug(X...) if (debug_enabled) { \
+                    fprintf(stderr,"ntlm-auth[%d](%s:%d): ", getpid(), \
+                    ((__foo=strrchr(__FILE__,'/'))==NULL?__FILE__:__foo+1),\
+                    __LINE__);\
+                    fprintf(stderr,X); }
+#else /* DEBUG */
+#define debug(X...)		/* */
+#endif /* DEBUG */
+#else /* __GNUC__ */
+static void
+debug(char *format,...) 
+{
+#ifdef DEBUG
+#ifdef _SQUID_MSWIN_
+#if FAIL_DEBUG
+    if (debug_enabled || fail_debug_enabled) {
+#else
+    if (debug_enabled) {
+#endif
+	va_list args;
+
+	va_start(args,format);
+	fprintf(stderr, "negotiate-auth[%d]: ",getpid());
+	vfprintf(stderr, format, args);
+	va_end(args);
+#if FAIL_DEBUG
+        fail_debug_enabled = 0;
+#endif
+    }
+#endif /* _SQUID_MSWIN_ */
+#endif /* DEBUG */
+}
+#endif /* __GNUC__ */
+
+
+/* A couple of harmless helper macros */
+#define SEND(X) debug("sending '%s' to squid\n",X); printf(X "\n");
+#ifdef __GNUC__
+#define SEND2(X,Y...) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
+#define SEND3(X,Y...) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
+#else
+/* no gcc, no debugging. varargs macros are a gcc extension */
+#define SEND2(X,Y) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
+#define SEND3(X,Y,Z) debug("sending '" X "' to squid\n",Y,Z); printf(X "\n",Y,Z);
+#endif
+
+extern int ntlm_errno;
+
+#define NTLM_NO_ERROR 0
+#define NTLM_SSPI_ERROR 1
+#define NTLM_BAD_NTGROUP 2
+#define NTLM_BAD_REQUEST 3
+
+#define NEGOTIATE_LENGTH 16
+
+extern void uc(char *);
+
+extern char *negotiate_check_auth(SSP_blobP auth, int auth_length);
+extern void hex_dump(void *, int);
+
+#define safe_free(x)	if (x) { free(x); x = NULL; }
+
+#endif /* _NTLM_H_ */
@@ -0,0 +1,316 @@
+/*
+ * win32_ntlm_auth: helper for NTLM Authentication for Squid Cache
+ *
+ * (C)2005 Guido Serassio - Acme Consulting S.r.l.
+ *
+ * Authors:
+ *  Guido Serassio <guido.serassio@acmeconsulting.it>
+ *  Acme Consulting S.r.l., Italy <http://www.acmeconsulting.it>
+ *
+ * With contributions from others mentioned in the change history section
+ * below.
+ *
+ * Based on previous work of Francesco Chemolli and Robert Collins.
+ *
+ * Dependencies: Windows NT4 SP4 and later.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ * History:
+ *
+ * Version 1.0
+ * 29-10-2005 Guido Serassio
+ *              First release.
+ *
+ *
+ */
+
+#include "util.h"
+#if HAVE_GETOPT_H
+#include <getopt.h>
+#endif
+#include "negotiate.h"
+#if HAVE_CTYPE_H
+#include <ctype.h>
+#endif
+
+#define BUFFER_SIZE 10240
+
+int debug_enabled = 0;
+int Negotiate_packet_debug_enabled = 0;
+
+static int have_serverblob;
+
+/* makes a null-terminated string upper-case. Changes CONTENTS! */
+void
+uc(char *string)
+{
+    char *p = string, c;
+    while ((c = *p)) {
+	*p = toupper(c);
+	p++;
+    }
+}
+
+/* makes a null-terminated string lower-case. Changes CONTENTS! */
+static void
+lc(char *string)
+{
+    char *p = string, c;
+    while ((c = *p)) {
+	*p = tolower(c);
+	p++;
+    }
+}
+
+void
+helperfail(const char *reason)
+{
+#if FAIL_DEBUG
+    fail_debug_enabled =1;
+#endif
+    SEND2("BH %s", reason);
+}
+
+/*
+  options:
+  -d enable debugging.
+  -v enable verbose NTLM packet debugging.
+ */
+char *my_program_name = NULL;
+
+void
+usage()
+{
+    fprintf(stderr,
+	"Usage: %s [-d] [-v] [-h]\n"
+	" -d  enable debugging.\n"
+        " -v  enable verbose NTLM packet debugging.\n"
+	" -h  this message\n\n",
+	my_program_name);
+}
+
+
+void
+process_options(int argc, char *argv[])
+{
+    int opt, had_error = 0;
+
+    opterr =0;
+    while (-1 != (opt = getopt(argc, argv, "hdv"))) {
+	switch (opt) {
+	case 'd':
+	    debug_enabled = 1;
+	    break;
+	case 'v':
+	    debug_enabled = 1;
+	    Negotiate_packet_debug_enabled = 1;
+	    break;
+	case 'h':
+	    usage();
+	    exit(0);
+	case '?':
+	    opt = optopt;
+	    /* fall thru to default */
+	default:
+	    fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
+	    usage();
+	    had_error = 1;
+	}
+    }
+    if (had_error)
+	exit(1);
+}
+
+int
+manage_request()
+{
+    char buf[BUFFER_SIZE];
+    char helper_command[3];
+    char *c, *decoded;
+    int plen, status;
+    int oversized = 0;
+    char * ErrorMessage;
+    static char cred[SSP_MAX_CRED_LEN+1];
+    BOOL Done = FALSE;
+
+try_again:
+    if (fgets(buf, BUFFER_SIZE, stdin) == NULL) 
+        return 0;
+
+    c = memchr(buf, '\n', BUFFER_SIZE);	/* safer against overrun than strchr */
+    if (c) {
+	if (oversized) {
+	    helperfail("illegal request received");
+	    fprintf(stderr, "Illegal request received: '%s'\n", buf);
+	    return 1;
+	}
+	*c = '\0';
+    } else {
+	fprintf(stderr, "No newline in '%s'\n", buf);
+	oversized = 1;
+	goto try_again;
+    }
+
+    if ((strlen(buf) > 3) && Negotiate_packet_debug_enabled) {
+        decoded = base64_decode(buf + 3);
+        strncpy(helper_command, buf, 2);
+        debug("Got '%s' from Squid with data:\n", helper_command);
+        hex_dump(decoded, ((strlen(buf) - 3) * 3) / 4);
+    } else
+        debug("Got '%s' from Squid\n", buf);
+
+    if (memcmp(buf, "YR ", 3) == 0) {	/* refresh-request */
+	/* figure out what we got */
+        decoded = base64_decode(buf + 3);
+	/*  Note: we don't need to manage memory at this point, since
+	 *  base64_decode returns a pointer to static storage.
+	 */
+	if (!decoded) {		/* decoding failure, return error */
+	    SEND("NA * Packet format error, couldn't base64-decode");
+	    return 1;
+	}
+	/* Obtain server blob against SSPI */
+        plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
+        c = (char *) SSP_MakeNegotiateBlob(decoded, plen, &Done, &status, cred);
+
+        if (status == SSP_OK) {
+            if (Done) {
+	        lc(cred);		/* let's lowercase them for our convenience */
+                have_serverblob = 0;
+                Done = FALSE;
+                if (Negotiate_packet_debug_enabled) {
+                    printf("AF %s %s\n",c,cred);
+                    decoded = base64_decode(c);
+	            debug("sending 'AF' %s to squid with data:\n", cred);
+                    hex_dump(decoded, (strlen(c) * 3) / 4);
+                } else
+                    SEND3("AF %s %s", c, cred);
+            } else {
+                if (Negotiate_packet_debug_enabled) {
+                    printf("TT %s\n",c);
+                    decoded = base64_decode(c);
+	            debug("sending 'TT' to squid with data:\n");
+                    hex_dump(decoded, (strlen(c) * 3) / 4);
+                } else {
+                    SEND2("TT %s", c);
+                }
+                have_serverblob = 1;
+            }
+        } else
+            helperfail("can't obtain server blob");
+	return 1;
+    }
+
+    if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
+        if (!have_serverblob) {
+	    helperfail("invalid server blob");
+	    return 1;
+        }
+	/* figure out what we got */
+	decoded = base64_decode(buf + 3);
+	/*  Note: we don't need to manage memory at this point, since
+	 *  base64_decode returns a pointer to static storage.
+	 */
+	if (!decoded) {		/* decoding failure, return error */
+	    SEND("NA * Packet format error, couldn't base64-decode");
+	    return 1;
+	}
+
+        /* check against SSPI */
+	plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
+        c = (char *) SSP_ValidateNegotiateCredentials(decoded, plen, &Done, &status, cred);
+        
+        if (status == SSP_ERROR) {
+#if FAIL_DEBUG
+            fail_debug_enabled = 1;
+#endif
+            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
+                          FORMAT_MESSAGE_IGNORE_INSERTS,
+                          NULL,
+                          GetLastError(),
+                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),   /* Default language */
+                          (LPTSTR) &ErrorMessage,
+                          0,
+                          NULL);
+            if (ErrorMessage[strlen(ErrorMessage) - 1] == '\n')
+                ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
+            if (ErrorMessage[strlen(ErrorMessage) - 1] == '\r')
+                ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
+	    SEND2("NA * %s", ErrorMessage);
+            LocalFree(ErrorMessage);
+	    return 1;
+	}
+
+        if (Done) {
+	    lc(cred);		/* let's lowercase them for our convenience */
+            have_serverblob = 0;
+            Done = FALSE;
+            if (Negotiate_packet_debug_enabled) {
+                printf("AF %s %s\n",c,cred);
+                decoded = base64_decode(c);
+	        debug("sending 'AF' %s to squid with data:\n", cred);
+                hex_dump(decoded, (strlen(c) * 3) / 4);
+            } else {
+                SEND3("AF %s %s", c, cred);
+            }
+	    return 1;
+        } else {
+            if (Negotiate_packet_debug_enabled) {
+                printf("TT %s\n",c);
+                decoded = base64_decode(c);
+	        debug("sending 'TT' to squid with data:\n");
+                hex_dump(decoded, (strlen(c) * 3) / 4);
+            } else
+               	SEND2("TT %s", c);
+	    return 1;
+        }
+
+    } else {	/* not an auth-request */
+	helperfail("illegal request received");
+	fprintf(stderr, "Illegal request received: '%s'\n", buf);
+	return 1;
+    }
+    helperfail("detected protocol error");
+    return 1;
+/********* END ********/
+}
+
+int
+main(int argc, char *argv[])
+{
+    my_program_name = argv[0];
+
+    process_options(argc, argv);
+
+    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+    
+    if (LoadSecurityDll(SSP_NTLM, NEGOTIATE_PACKAGE_NAME) == NULL) {
+	fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
+	exit(1);
+    }
+    debug("SSPI initialized OK\n");
+
+    atexit(UnloadSecurityDll);
+
+    /* initialize FDescs */
+    setbuf(stdout, NULL);
+    setbuf(stderr, NULL);
+
+    while (manage_request()) {
+	/* everything is done within manage_request */
+    }
+    exit(0);
+}
@@ -0,0 +1,49 @@
+mswin_negotiate_auth.exe
+
+Native Windows Negotiate authenticator for Squid.
+
+=====
+Usage
+=====
+
+mswin_negotiate_auth [-d] [-v] [-h]
+
+-d enables debugging.
+-v enables verbose Negotiate packet debugging.
+-h print program usage
+
+This is released under the GNU General Public License
+
+==============
+Allowing Users
+==============
+
+Users that are allowed to access the web proxy must have the Windows NT
+User Rights "logon from the network".
+
+Squid.conf typical minimal required changes:
+
+auth_param negotiate program c:/squid/libexec/mswin_negotiate_auth.exe
+auth_param negotiate children 5
+
+acl password proxy_auth REQUIRED
+
+http_access allow password
+http_access deny all
+
+Refer to Squid documentation for more details.
+
+Currently Internet Explorer has some problems with ftp:// URLs when handling
+internal Squid FTP icons. The following squid.conf ACL works around this:
+
+acl internal_icons urlpath_regex -i /squid-internal-static/icons/
+
+http_access allow our_networks internal_icons <== BEFORE authentication ACL !!!
+
+
+===============
+Contact details
+===============
+
+To contact the maintainer of this package, e-mail on squidnt@acmeconsulting.it.
+The latest version may be found on http://www.acmeconsulting.it/SquidNT.htm.
@@ -1,7 +1,7 @@
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.7 2005/07/01 22:34:51 hno Exp $
+#  $Id: Makefile.am,v 1.8 2005/10/30 21:48:22 serassio Exp $
 #
 
-DIST_SUBDIRS	= fakeauth no_check SMB
+DIST_SUBDIRS	= fakeauth no_check SMB mswin_sspi
 SUBDIRS		= @NTLM_AUTH_HELPERS@
@@ -0,0 +1 @@
+Makefile
@@ -0,0 +1,16 @@
+#
+#  Makefile for the Squid Object Cache server
+#
+#  $Id: Makefile.am,v 1.1 2005/10/30 21:48:22 serassio Exp $
+#
+
+libexec_PROGRAMS = mswin_ntlm_auth
+
+mswin_ntlm_auth_SOURCES = libntlmssp.c ntlm_auth.c ntlm.h
+
+INCLUDES      = -I. -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/src
+
+LDADD		= -L$(top_builddir)/lib -lntlmauth -lsspwin32 -lnetapi32 \
+		  -ladvapi32 -lmiscutil $(XTRA_LIBS)
+
+EXTRA_DIST = readme.txt
@@ -0,0 +1,382 @@
+/*
+ * (C) 2002 Guido Serassio <serassio@libero.it>
+ * Based on previous work of Francesco Chemolli and Robert Collins
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+typedef unsigned char uchar;
+
+#include "util.h"
+#include "ntlm.h"
+#if HAVE_CTYPE_H
+#include <ctype.h>
+#endif
+#include <lm.h>
+#include <ntsecapi.h>
+
+/* returns 1 on success, 0 on failure */
+int
+Valid_Group(char *UserName, char *Group)
+{
+    int result = FALSE;
+    WCHAR wszUserName[UNLEN+1];	// Unicode user name
+    WCHAR wszGroup[GNLEN+1];	// Unicode Group
+
+    LPLOCALGROUP_USERS_INFO_0 pBuf = NULL;
+    LPLOCALGROUP_USERS_INFO_0 pTmpBuf;
+    DWORD dwLevel = 0;
+    DWORD dwFlags = LG_INCLUDE_INDIRECT;
+    DWORD dwPrefMaxLen = -1;
+    DWORD dwEntriesRead = 0;
+    DWORD dwTotalEntries = 0;
+    NET_API_STATUS nStatus;
+    DWORD i;
+    DWORD dwTotalCount = 0;
+
+/* Convert ANSI User Name and Group to Unicode */
+
+    MultiByteToWideChar(CP_ACP, 0, UserName,
+	strlen(UserName) + 1, wszUserName,
+	sizeof(wszUserName) / sizeof(wszUserName[0]));
+    MultiByteToWideChar(CP_ACP, 0, Group,
+	strlen(Group) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
+
+    /*
+     * Call the NetUserGetLocalGroups function 
+	 * specifying information level 0.
+	 * 
+	 * The LG_INCLUDE_INDIRECT flag specifies that the 
+	 * function should also return the names of the local 
+	 * groups in which the user is indirectly a member.
+	 */
+	nStatus = NetUserGetLocalGroups(NULL,
+	    wszUserName,
+	    dwLevel,
+	    dwFlags,
+	    (LPBYTE *) & pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries);
+	/*
+	 * If the call succeeds,
+	 */
+    if (nStatus == NERR_Success) {
+	if ((pTmpBuf = pBuf) != NULL) {
+	    for (i = 0; i < dwEntriesRead; i++) {
+		if (pTmpBuf == NULL) {
+		    result = FALSE;
+		    break;
+		}
+		if (wcscmp(pTmpBuf->lgrui0_name, wszGroup) == 0) {
+		    result = TRUE;
+		    break;
+		}
+		pTmpBuf++;
+		dwTotalCount++;
+	    }
+	}
+    } else
+	    result = FALSE;
+/*
+ * Free the allocated memory.
+ */
+    if (pBuf != NULL)
+	NetApiBufferFree(pBuf);
+    return result;
+}
+
+
+char * AllocStrFromLSAStr(LSA_UNICODE_STRING LsaStr)
+{
+    size_t len;
+    static char * target;
+
+    len = LsaStr.Length/sizeof(WCHAR) + 1;
+
+    /* allocate buffer for str + null termination */
+    safe_free(target);
+    target = (char *)xmalloc(len);
+    if (target == NULL)
+	return NULL;
+
+    /* copy unicode buffer */
+    WideCharToMultiByte(CP_ACP, 0, LsaStr.Buffer, LsaStr.Length, target, len, NULL, NULL );
+
+    /* add null termination */
+    target[len-1] = '\0';
+    return target;
+}
+
+
+char * GetDomainName(void)
+
+{
+    LSA_HANDLE PolicyHandle;
+    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
+    NTSTATUS status;
+    PPOLICY_PRIMARY_DOMAIN_INFO ppdiDomainInfo;
+    PWKSTA_INFO_100 pwkiWorkstationInfo;
+    DWORD netret;
+    char * DomainName = NULL;
+
+    /* 
+     * Always initialize the object attributes to all zeroes.
+     */ 
+    memset(&ObjectAttributes, '\0', sizeof(ObjectAttributes));
+
+    /* 
+     * You need the local workstation name. Use NetWkstaGetInfo at level
+     * 100 to retrieve a WKSTA_INFO_100 structure.
+     * 
+     * The wki100_computername field contains a pointer to a UNICODE
+     * string containing the local computer name.
+     */ 
+    netret = NetWkstaGetInfo(NULL, 100, (LPBYTE *)&pwkiWorkstationInfo);
+    if (netret == NERR_Success) {
+	/* 
+	 * We have the workstation name in:
+	 * pwkiWorkstationInfo->wki100_computername
+	 * 
+	 * Next, open the policy object for the local system using
+	 * the LsaOpenPolicy function.
+	 */ 
+	status = LsaOpenPolicy(
+                 NULL,
+                 &ObjectAttributes,
+                 GENERIC_READ | POLICY_VIEW_LOCAL_INFORMATION,
+                 &PolicyHandle
+                );
+	
+	/* 
+	 * Error checking.
+	 */ 
+	if (status) {
+	    debug("OpenPolicy Error: %ld\n", status);
+	} else {
+
+	    /* 
+	     * You have a handle to the policy object. Now, get the
+	     * domain information using LsaQueryInformationPolicy.
+	     */ 
+	    status = LsaQueryInformationPolicy(PolicyHandle,
+		PolicyPrimaryDomainInformation,
+		(void **)&ppdiDomainInfo);
+	    if (status) {
+		debug("LsaQueryInformationPolicy Error: %ld\n", status);
+	    } else  {
+
+		/* Get name in useable format */
+		DomainName = AllocStrFromLSAStr(ppdiDomainInfo->Name);
+
+		/* 
+		 * Check the Sid pointer, if it is null, the
+		 * workstation is either a stand-alone computer
+		 * or a member of a workgroup.
+		 */ 
+		if (ppdiDomainInfo->Sid) {
+
+		    /* 
+		     * Member of a domain. Display it in debug mode.
+		     */ 
+		    debug("Member of Domain %s\n",DomainName);
+		} else {
+		    DomainName = NULL;
+                }
+	    }
+	}
+
+	/* 
+	 * Clean up all the memory buffers created by the LSA and
+	 * Net* APIs.
+	 */ 
+	NetApiBufferFree(pwkiWorkstationInfo);
+	LsaFreeMemory((LPVOID)ppdiDomainInfo);
+    } else 
+	debug("NetWkstaGetInfo Error: %ld\n", netret);
+    return DomainName;
+}
+
+
+int ntlm_errno;
+
+
+/* returns NULL on failure, or a pointer to
+ * the user's credentials (domain\\username)
+ * upon success. WARNING. It's pointing to static storage.
+ * In case of problem sets as side-effect ntlm_errno to one of the
+ * codes defined in ntlm.h
+ */
+char *
+ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
+{
+    int rv;
+    char domain[DNLEN+1];
+    char user[UNLEN+1];
+    static char credentials[DNLEN+UNLEN+2];	/* we can afford to waste */
+
+    lstring tmp;
+
+    if (!NTLM_LocalCall) {
+
+        tmp = ntlm_fetch_string((char *) auth, auth_length, &auth->domain);
+
+        if (tmp.str == NULL || tmp.l == 0) {
+	    debug("No domain supplied. Returning no-auth\n");
+	    ntlm_errno = NTLM_BAD_REQUEST;
+	    return NULL;
+        }
+        if (Use_Unicode) {
+            /* copy unicode buffer */
+            WideCharToMultiByte(CP_ACP, 0, (LPCWSTR) tmp.str, tmp.l, domain, DNLEN, NULL, NULL );
+            /* add null termination */
+            domain[tmp.l / sizeof(WCHAR)] = '\0';
+        } else {
+            if (tmp.l > DNLEN) {
+	        debug("Domain string exceeds %d bytes, rejecting\n", DNLEN);
+	        ntlm_errno = NTLM_BAD_REQUEST;
+	        return NULL;
+            }
+            memcpy(domain, tmp.str, tmp.l);
+            domain[tmp.l] = '\0';
+        }
+        tmp = ntlm_fetch_string((char *) auth, auth_length, &auth->user);
+        if (tmp.str == NULL || tmp.l == 0) {
+	    debug("No username supplied. Returning no-auth\n");
+	    ntlm_errno = NTLM_BAD_REQUEST;
+	    return NULL;
+        }
+        if (Use_Unicode) {
+            /* copy unicode buffer */
+            WideCharToMultiByte(CP_ACP, 0, (LPCWSTR) tmp.str, tmp.l, user, UNLEN, NULL, NULL );
+            /* add null termination */
+            user[tmp.l / sizeof(WCHAR)] = '\0';
+        } else {
+            if (tmp.l > UNLEN) {
+	        debug("Username string exceeds %d bytes, rejecting\n", UNLEN);
+	        ntlm_errno = NTLM_BAD_REQUEST;
+	        return NULL;
+            }
+            memcpy(user, tmp.str, tmp.l);
+            user[tmp.l] = '\0';
+        }
+        debug("checking domain: '%s', user: '%s'\n", domain, user);
+
+    } else
+        debug("checking local user\n");
+
+    rv = SSP_ValidateNTLMCredentials(auth, auth_length, credentials);
+
+    debug("Login attempt had result %d\n", rv);
+
+    if (!rv) {			/* failed */
+	ntlm_errno = NTLM_SSPI_ERROR;
+	return NULL;
+    }
+    
+    if (UseAllowedGroup) {
+	if (!Valid_Group(credentials, NTAllowedGroup)) {
+	    ntlm_errno = NTLM_BAD_NTGROUP;
+	    debug("User %s not in allowed Group %s\n", credentials, NTAllowedGroup);
+	    return NULL;
+	}
+    }
+    if (UseDisallowedGroup) {
+	if (Valid_Group(credentials, NTDisAllowedGroup)) {
+	    ntlm_errno = NTLM_BAD_NTGROUP;
+	    debug("User %s is in denied Group %s\n", credentials, NTDisAllowedGroup);
+	    return NULL;
+	}
+    }
+
+    debug("credentials: %s\n", credentials);
+    return credentials;
+}
+
+
+const char *
+ntlm_make_negotiate(void)
+{
+    ntlm_negotiate ne;
+    const char *encoded;
+    memset(&ne, 0, sizeof(ntlm_negotiate));	/* reset */
+    memcpy(ne.signature, "NTLMSSP", 8);		/* set the signature */
+    ne.type = le32toh(NTLM_NEGOTIATE);	/* this is a challenge */
+    ne.flags = le32toh(
+	NEGOTIATE_ALWAYS_SIGN |
+	NEGOTIATE_USE_NTLM |
+	NEGOTIATE_USE_LM |
+	NEGOTIATE_ASCII |
+	0
+	);
+    encoded = base64_encode_bin((char *) &ne, NEGOTIATE_LENGTH);
+    debug("Negotiate packet not supplied - self generated\n");
+    return encoded;
+}
+
+
+void hex_dump(void *data, int size)
+{
+    /* dumps size bytes of *data to stdout. Looks like:
+     * [0000] 75 6E 6B 6E 6F 77 6E 20
+     *                  30 FF 00 00 00 00 39 00 unknown 0.....9.
+     * (in a single line of course)
+     */
+
+    if (!data)
+        return;
+
+    if (debug_enabled) {
+        unsigned char *p = data;
+        unsigned char c;
+        int n;
+        char bytestr[4] = {0};
+        char addrstr[10] = {0};
+        char hexstr[ 16*3 + 5] = {0};
+        char charstr[16*1 + 5] = {0};
+        for(n=1;n<=size;n++) {
+            if (n%16 == 1) {
+                /* store address for this line */
+                snprintf(addrstr, sizeof(addrstr), "%.4x",
+                   ((unsigned int)p-(unsigned int)data) );
+            }
+            
+            c = *p;
+            if (isalnum(c) == 0) {
+                c = '.';
+            }
+
+            /* store hex str (for left side) */
+            snprintf(bytestr, sizeof(bytestr), "%02X ", *p);
+            strncat(hexstr, bytestr, sizeof(hexstr)-strlen(hexstr)-1);
+
+            /* store char str (for right side) */
+            snprintf(bytestr, sizeof(bytestr), "%c", c);
+            strncat(charstr, bytestr, sizeof(charstr)-strlen(charstr)-1);
+
+            if(n%16 == 0) { 
+                /* line completed */
+                fprintf(stderr, "[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
+                hexstr[0] = 0;
+                charstr[0] = 0;
+            } else if(n%8 == 0) {
+                /* half line: add whitespaces */
+                strncat(hexstr, "  ", sizeof(hexstr)-strlen(hexstr)-1);
+                strncat(charstr, " ", sizeof(charstr)-strlen(charstr)-1);
+            }
+            p++; /* next byte */
+        }
+
+        if (strlen(hexstr) > 0) {
+            /* print rest of buffer if not empty */
+            fprintf(stderr, "[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
+        }
+    }
+}
+
@@ -0,0 +1,119 @@
+/*
+ * (C) 2002 Guido Serassio <serassio@libero.it>
+ * Based on previous work of Francesco Chemolli, Robert Collins and Andrew Doran
+ *
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#ifndef _NTLM_H_
+#define _NTLM_H_
+
+#include "sspwin32.h"
+#include <windows.h>
+#include <sspi.h>
+#include <security.h>
+#include "ntlmauth.h"
+#undef debug
+
+/************* CONFIGURATION ***************/
+/*
+ * define this if you want debugging
+ */
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+#define FAIL_DEBUG 0
+
+/************* END CONFIGURATION ***************/
+
+#include <sys/types.h>
+
+extern int debug_enabled;
+#if FAIL_DEBUG
+extern int fail_debug_enabled;
+#endif
+
+/* Debugging stuff */
+
+#ifdef __GNUC__			/* this is really a gcc-ism */
+#ifdef DEBUG
+#include <stdio.h>
+#include <unistd.h>
+static char *__foo;
+#define debug(X...) if (debug_enabled) { \
+                    fprintf(stderr,"ntlm-auth[%d](%s:%d): ", getpid(), \
+                    ((__foo=strrchr(__FILE__,'/'))==NULL?__FILE__:__foo+1),\
+                    __LINE__);\
+                    fprintf(stderr,X); }
+#else /* DEBUG */
+#define debug(X...)		/* */
+#endif /* DEBUG */
+#else /* __GNUC__ */
+static void
+debug(char *format,...) 
+{
+#ifdef DEBUG
+#ifdef _SQUID_MSWIN_
+#if FAIL_DEBUG
+    if (debug_enabled || fail_debug_enabled) {
+#else
+    if (debug_enabled) {
+#endif
+	va_list args;
+
+	va_start(args,format);
+	fprintf(stderr, "ntlm-auth[%d]: ",getpid());
+	vfprintf(stderr, format, args);
+	va_end(args);
+#if FAIL_DEBUG
+        fail_debug_enabled = 0;
+#endif
+    }
+#endif /* _SQUID_MSWIN_ */
+#endif /* DEBUG */
+}
+#endif /* __GNUC__ */
+
+
+/* A couple of harmless helper macros */
+#define SEND(X) debug("sending '%s' to squid\n",X); printf(X "\n");
+#ifdef __GNUC__
+#define SEND2(X,Y...) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
+#else
+/* no gcc, no debugging. varargs macros are a gcc extension */
+#define SEND2(X,Y) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
+#endif
+
+extern char * NTAllowedGroup;
+extern char * NTDisAllowedGroup;
+extern int UseDisallowedGroup;
+extern int UseAllowedGroup;
+extern int ntlm_errno;
+
+#define NTLM_NO_ERROR 0
+#define NTLM_SSPI_ERROR 1
+#define NTLM_BAD_NTGROUP 2
+#define NTLM_BAD_REQUEST 3
+
+#define NEGOTIATE_LENGTH 16
+
+extern void uc(char *);
+
+extern const char * ntlm_make_negotiate(void);
+extern char *ntlm_check_auth(ntlm_authenticate * auth, int auth_length);
+extern void hex_dump(void *, int);
+
+#define safe_free(x)	if (x) { free(x); x = NULL; }
+
+#endif /* _NTLM_H_ */
@@ -0,0 +1,401 @@
+/*
+ * win32_ntlm_auth: helper for NTLM Authentication for Squid Cache
+ *
+ * (C)2002,2003 Guido Serassio - Acme Consulting S.r.l.
+ *
+ * Authors:
+ *  Guido Serassio <guido.serassio@acmeconsulting.it>
+ *  Acme Consulting S.r.l., Italy <http://www.acmeconsulting.it>
+ *
+ * With contributions from others mentioned in the change history section
+ * below.
+ *
+ * Based on previous work of Francesco Chemolli and Robert Collins.
+ *
+ * Dependencies: Windows NT4 SP4 and later.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ * History:
+ *
+ * Version 1.21
+ * 21-02-2004 Guido Serassio
+ *              Removed control of use of NTLM NEGOTIATE packet from
+ *              command line, now the support is automatic.
+ * Version 1.20
+ * 30-11-2003 Guido Serassio
+ *              Added support for NTLM local calls.
+ *              Added control of use of NTLM NEGOTIATE packet from
+ *              command line.
+ *              Updated documentation.
+ * Version 1.10
+ * 07-09-2003 Guido Serassio
+ *              Now is true NTLM authenticator.
+ *              More debug info.
+ *              Updated documentation.
+ * Version 1.0
+ * 29-06-2002 Guido Serassio
+ *              First release.
+ *
+ *
+ */
+
+#include "util.h"
+#if HAVE_GETOPT_H
+#include <getopt.h>
+#endif
+#include "ntlm.h"
+#if HAVE_CTYPE_H
+#include <ctype.h>
+#endif
+
+#define BUFFER_SIZE 10240
+
+int debug_enabled = 0;
+int NTLM_packet_debug_enabled = 0;
+
+static int have_challenge;
+
+char * NTAllowedGroup;
+char * NTDisAllowedGroup;
+int UseDisallowedGroup = 0;
+int UseAllowedGroup = 0;
+#if FAIL_DEBUG
+int fail_debug_enabled = 0;
+#endif
+
+/* makes a null-terminated string upper-case. Changes CONTENTS! */
+void
+uc(char *string)
+{
+    char *p = string, c;
+    while ((c = *p)) {
+	*p = toupper(c);
+	p++;
+    }
+}
+
+/* makes a null-terminated string lower-case. Changes CONTENTS! */
+static void
+lc(char *string)
+{
+    char *p = string, c;
+    while ((c = *p)) {
+	*p = tolower(c);
+	p++;
+    }
+}
+
+void
+helperfail(const char *reason)
+{
+#if FAIL_DEBUG
+    fail_debug_enabled =1;
+#endif
+    SEND2("BH %s", reason);
+}
+
+/*
+  options:
+  -d enable debugging.
+  -v enable verbose NTLM packet debugging.
+  -l if specified, changes behavior on failures to last-ditch.
+  -A can specify a Windows Local Group name allowed to authenticate.
+  -D can specify a Windows Local Group name not allowed to authenticate.
+ */
+char *my_program_name = NULL;
+
+void
+usage()
+{
+    fprintf(stderr,
+	"Usage: %s [-d] [-v] [-A|D LocalUserGroup] [-h]\n"
+	" -d  enable debugging.\n"
+        " -v  enable verbose NTLM packet debugging.\n"
+	" -A  specify a Windows Local Group name allowed to authenticate\n"
+	" -D  specify a Windows Local Group name not allowed to authenticate\n"
+	" -h  this message\n\n",
+	my_program_name);
+}
+
+
+void
+process_options(int argc, char *argv[])
+{
+    int opt, had_error = 0;
+
+    opterr =0;
+    while (-1 != (opt = getopt(argc, argv, "hdvA:D:"))) {
+	switch (opt) {
+	case 'A':
+	    safe_free(NTAllowedGroup);
+	    NTAllowedGroup=xstrdup(optarg);
+	    UseAllowedGroup = 1;
+	    break;
+	case 'D':
+	    safe_free(NTDisAllowedGroup);
+	    NTDisAllowedGroup=xstrdup(optarg);
+	    UseDisallowedGroup = 1;
+	    break;
+	case 'd':
+	    debug_enabled = 1;
+	    break;
+	case 'v':
+	    debug_enabled = 1;
+	    NTLM_packet_debug_enabled = 1;
+	    break;
+	case 'h':
+	    usage();
+	    exit(0);
+	case '?':
+	    opt = optopt;
+	    /* fall thru to default */
+	default:
+	    fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
+	    usage();
+	    had_error = 1;
+	}
+    }
+    if (had_error)
+	exit(1);
+}
+
+
+const char *
+obtain_challenge(ntlm_negotiate * nego, int nego_length)
+{
+    const char *ch = NULL;
+
+    debug("attempting SSPI challenge retrieval\n");
+    ch = SSP_MakeChallenge(nego, nego_length);
+    if (ch) {
+	debug("Got it\n");
+	return ch;		/* All went OK, returning */
+    }
+    return NULL;
+}
+
+
+int
+manage_request()
+{
+    ntlmhdr *fast_header;
+    char buf[BUFFER_SIZE];
+    char helper_command[3];
+    char *c, *decoded, *cred;
+    int plen;
+    int oversized = 0;
+    char * ErrorMessage;
+
+try_again:
+    if (fgets(buf, BUFFER_SIZE, stdin) == NULL) 
+        return 0;
+
+    c = memchr(buf, '\n', BUFFER_SIZE);	/* safer against overrun than strchr */
+    if (c) {
+	if (oversized) {
+	    helperfail("illegal request received");
+	    fprintf(stderr, "Illegal request received: '%s'\n", buf);
+	    return 1;
+	}
+	*c = '\0';
+    } else {
+	fprintf(stderr, "No newline in '%s'\n", buf);
+	oversized = 1;
+	goto try_again;
+    }
+    if ((strlen(buf) > 3) && NTLM_packet_debug_enabled) {
+        decoded = base64_decode(buf + 3);
+        strncpy(helper_command, buf, 2);
+        debug("Got '%s' from Squid with data:\n", helper_command);
+        hex_dump(decoded, ((strlen(buf) - 3) * 3) / 4);
+    } else
+        debug("Got '%s' from Squid\n", buf);
+    if (memcmp(buf, "YR", 2) == 0) {	/* refresh-request */
+	/* figure out what we got */
+        if (strlen(buf) > 3)
+            decoded = base64_decode(buf + 3);
+        else
+            decoded = base64_decode(ntlm_make_negotiate());
+	/* Note: we don't need to manage memory at this point, since
+	 *  base64_decode returns a pointer to static storage.
+	 */
+	if (!decoded) {		/* decoding failure, return error */
+	    SEND("NA Packet format error, couldn't base64-decode");
+	    return 1;
+	}
+	/* fast-track-decode request type. */
+	fast_header = (struct _ntlmhdr *) decoded;
+
+	/* sanity-check: it IS a NTLMSSP packet, isn't it? */
+	if (memcmp(fast_header->signature, "NTLMSSP", 8) != 0) {
+	    SEND("NA Broken authentication packet");
+	    return 1;
+	}
+	switch (fast_header->type) {
+	case NTLM_NEGOTIATE:
+	    /* Obtain challenge against SSPI */
+            if (strlen(buf) > 3)
+                plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
+            else
+                plen = NEGOTIATE_LENGTH;
+            if ((c = (char *) obtain_challenge((ntlm_negotiate *) decoded, plen)) != NULL )
+            {
+                if (NTLM_packet_debug_enabled) {
+                    printf("TT %s\n",c);
+                    decoded = base64_decode(c);
+	            debug("sending 'TT' to squid with data:\n");
+                    hex_dump(decoded, (strlen(c) * 3) / 4);
+                    if (NTLM_LocalCall)
+                        debug("NTLM Local Call detected\n");
+                } else {
+               	    SEND2("TT %s", c);
+                }
+                have_challenge = 1;
+            } else
+                helperfail("can't obtain challenge");
+	    return 1;
+	    /* notreached */
+	case NTLM_CHALLENGE:
+	    SEND
+		("NA Got a challenge. We refuse to have our authority disputed");
+	    return 1;
+	    /* notreached */
+	case NTLM_AUTHENTICATE:
+	    SEND("NA Got authentication request instead of negotiate request");
+	    return 1;
+	    /* notreached */
+	default:
+	    helperfail("unknown refresh-request packet type");
+	    return 1;
+	}
+	return 1;
+    }
+    if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
+        if (!have_challenge) {
+	    helperfail("invalid challenge");
+	    return 1;
+        }
+	/* figure out what we got */
+	decoded = base64_decode(buf + 3);
+	/* Note: we don't need to manage memory at this point, since
+	 *  base64_decode returns a pointer to static storage.
+	 */
+
+	if (!decoded) {		/* decoding failure, return error */
+	    SEND("NA Packet format error, couldn't base64-decode");
+	    return 1;
+	}
+	/* fast-track-decode request type. */
+	fast_header = (struct _ntlmhdr *) decoded;
+
+	/* sanity-check: it IS a NTLMSSP packet, isn't it? */
+	if (memcmp(fast_header->signature, "NTLMSSP", 8) != 0) {
+	    SEND("NA Broken authentication packet");
+	    return 1;
+	}
+	switch (fast_header->type) {
+	case NTLM_NEGOTIATE:
+	    SEND("NA Invalid negotiation request received");
+	    return 1;
+	    /* notreached */
+	case NTLM_CHALLENGE:
+	    SEND
+		("NA Got a challenge. We refuse to have our authority disputed");
+	    return 1;
+	    /* notreached */
+	case NTLM_AUTHENTICATE:
+	    /* check against SSPI */
+	    plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
+	    cred = ntlm_check_auth((ntlm_authenticate *) decoded, plen);
+            have_challenge = 0;
+	    if (cred == NULL) {
+#if FAIL_DEBUG
+                fail_debug_enabled =1;
+#endif
+		switch (ntlm_errno) {
+		case NTLM_BAD_NTGROUP:
+		    SEND("NA Incorrect Group Membership");
+		    return 1;
+		case NTLM_BAD_REQUEST:
+		    SEND("NA Incorrect Request Format");
+		    return 1;
+		case NTLM_SSPI_ERROR:
+                    FormatMessage( 
+                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
+                    FORMAT_MESSAGE_FROM_SYSTEM | 
+                    FORMAT_MESSAGE_IGNORE_INSERTS,
+                    NULL,
+                    GetLastError(),
+                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
+                    (LPTSTR) &ErrorMessage,
+                    0,
+                    NULL);
+                    if (ErrorMessage[strlen(ErrorMessage) - 1] == '\n')
+                        ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
+                    if (ErrorMessage[strlen(ErrorMessage) - 1] == '\r')
+                        ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
+		    SEND2("NA %s", ErrorMessage);
+                    LocalFree(ErrorMessage);
+		    return 1;
+		default:
+		    SEND("NA Unknown Error");
+		    return 1;
+		}
+	    }
+	    lc(cred);		/* let's lowercase them for our convenience */
+	    SEND2("AF %s", cred);
+	    return 1;
+	default:
+	    helperfail("unknown authentication packet type");
+	    return 1;
+	}
+	return 1;
+    } else {	/* not an auth-request */
+	helperfail("illegal request received");
+	fprintf(stderr, "Illegal request received: '%s'\n", buf);
+	return 1;
+    }
+    helperfail("detected protocol error");
+    return 1;
+/********* END ********/
+}
+
+int
+main(int argc, char *argv[])
+{
+    my_program_name = argv[0];
+
+    process_options(argc, argv);
+
+    debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
+    
+    if (LoadSecurityDll(SSP_NTLM, NTLM_PACKAGE_NAME) == NULL) {
+	fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
+	exit(1);
+    }
+    debug("SSPI initialized OK\n");
+
+    atexit(UnloadSecurityDll);
+
+    /* initialize FDescs */
+    setbuf(stdout, NULL);
+    setbuf(stderr, NULL);
+
+    while (manage_request()) {
+	/* everything is done within manage_request */
+    }
+    exit(0);
+}
@@ -0,0 +1,70 @@
+mswin_ntlm_auth.exe
+
+Native Windows NTLM/NTLMv2 authenticator for Squid with
+automatic support for NTLM NEGOTIATE packets.
+
+=====
+Usage
+=====
+
+mswin_ntlm_auth [-d] [-v] [-A|D LocalUserGroup] [-h]
+
+-d enables debugging.
+-v enables verbose NTLM packet debugging.
+-A specify a Windows Local Group name allowed to authenticate.
+-D specify a Windows Local Group name not allowed to authenticate.
+-h print program usage
+
+This is released under the GNU General Public License
+
+==============
+Allowing Users
+==============
+
+Users that are allowed to access the web proxy must have the Windows NT
+User Rights "logon from the network".
+Optionally the authenticator can verify the NT LOCAL group membership of 
+the user against the User Group specified in the Authenticator's command
+line. 
+This can be accomplished creating a local user group on the NT machine,
+grant the privilege, and adding users to it, it works only with MACHINE
+Local Groups, not Domain Local Groups.
+Better group checking is available with External Acl, see mswin_check_group
+documentation.
+
+The use of NTLM NEGOTIATE packet allow full NTLM/NTLMv2 support, but
+Squid too must be configured to use NTLM NEGOTIATE, see squid.conf.
+
+Squid.conf typical minimal required changes:
+
+auth_param ntlm program c:/squid/libexec/mswin_ntlm_auth.exe
+auth_param ntlm children 5
+auth_param ntlm max_challenge_reuses 0
+auth_param ntlm max_challenge_lifetime 2 minutes
+auth_param ntlm use_ntlm_negotiate on
+
+acl password proxy_auth REQUIRED
+
+http_access allow password
+http_access deny all
+
+When using "use_ntlm_negotiate on" 
+max_challenge_reuses and max_challenge_lifetime parameters must be specified
+but they are are ignored.
+
+Refer to Squid documentation for more details.
+
+Currently Internet Explorer has some problems with ftp:// URLs when handling
+internal Squid FTP icons. The following squid.conf ACL works around this:
+
+acl internal_icons urlpath_regex -i /squid-internal-static/icons/
+
+http_access allow our_networks internal_icons <== BEFORE authentication ACL !!!
+
+
+===============
+Contact details
+===============
+
+To contact the maintainer of this package, e-mail on squidnt@acmeconsulting.it.
+The latest version may be found on http://www.acmeconsulting.it/SquidNT.htm.
@@ -0,0 +1,59 @@
+/*
+ * (C) 2002 Guido Serassio <serassio@libero.it>
+ * Based on previous work of Francesco Chemolli, Robert Collins and Andrew Doran
+ *
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#ifndef _LIBSSPWIN32_H_
+#define _LIBSSPWIN32_H_
+#define SECURITY_WIN32
+#define NTLM_PACKAGE_NAME "NTLM"
+#define NEGOTIATE_PACKAGE_NAME "Negotiate"
+
+#ifdef _SQUID_CYGWIN_
+#include <wchar.h>
+#define _T(x) TEXT(x)
+#else
+#include <tchar.h>
+#endif
+#include <windows.h>
+#include <security.h>
+#include <sspi.h>
+
+typedef char * SSP_blobP;
+
+#define WINNT_SECURITY_DLL "security.dll"
+#define WIN2K_SECURITY_DLL "secur32.dll"
+
+#define SSP_BASIC 1
+#define SSP_NTLM 2
+
+#define SSP_MAX_CRED_LEN 848
+
+#define SSP_DEBUG 0
+
+#define SSP_OK 1
+#define SSP_ERROR 2
+
+HMODULE LoadSecurityDll(int, char *);
+void UnloadSecurityDll(void);
+BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
+BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
+const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
+const char * WINAPI SSP_MakeChallenge(PVOID, int);
+const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
+
+extern BOOL Use_Unicode;
+extern BOOL NTLM_LocalCall;
+#endif /* LIBSSPWIN32_H_ */
@@ -1,6 +1,6 @@
 ## Process this file with automake to produce Makefile.in
 #
-#  $Id: Makefile.am,v 1.17 2004/12/22 11:23:16 hno Exp $
+#  $Id: Makefile.am,v 1.18 2005/10/30 21:48:22 serassio Exp $
 #
 
 DIST_SUBDIRS = libTrie cppunit-1.10.0
@@ -29,13 +29,21 @@ else
 MD5SOURCE=
 endif
 
+if ENABLE_WIN32SPECIFIC
+LIBSSPWIN32=libsspwin32.a
+else
+LIBSSPWIN32=
+endif
+
 EXTRA_LIBRARIES = \
 	libdlmalloc.a \
-	libregex.a
+	libregex.a \
+	libsspwin32.a
 noinst_LIBRARIES = \
 	@LIBDLMALLOC@ \
 	libmiscutil.a \
 	libntlmauth.a \
+	$(LIBSSPWIN32) \
 	@LIBREGEX@
 EXTRA_libmiscutil_a_SOURCES = \
 	md5.c \
@@ -75,6 +83,8 @@ libntlmauth_a_SOURCES = \
 	ntlmauth.c
 libntlmauth_a_LIBADD = \
 	@LIBOBJS@
+libsspwin32_a_SOURCES = \
+	sspwin32.c
 
 INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include @SQUID_CPPUNIT_INC@
 ##FIXME - set these in configure.in and reuse
@@ -0,0 +1,598 @@
+/*
+ * (C) 2002 Guido Serassio <serassio@libero.it>
+ * Based on previous work of Francesco Chemolli, Robert Collins
+ *
+ * Distributed freely under the terms of the GNU General Public License,
+ * version 2. See the file COPYING for licensing details
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "util.h"
+
+#include "ntlmauth.h"
+#include "sspwin32.h"
+
+typedef struct _AUTH_SEQ {
+    BOOL fInitialized;
+    BOOL fHaveCredHandle;
+    BOOL fHaveCtxtHandle;
+    CredHandle hcred;
+    TimeStamp hcredLifeTime;
+    struct _SecHandle hctxt;
+    TimeStamp hctxtLifeTime;
+} AUTH_SEQ, *PAUTH_SEQ;
+
+BOOL GenClientContext(PAUTH_SEQ, PSEC_WINNT_AUTH_IDENTITY, PVOID, DWORD, PVOID, PDWORD, PBOOL);
+BOOL GenServerContext(PAUTH_SEQ, PVOID, DWORD, PVOID, PDWORD, PBOOL, char *);
+
+static HMODULE hModule;
+static int NTLM_mode = SSP_BASIC;
+static char * SSP_Package_InUse;
+SECURITY_STATUS SecurityStatus = SEC_E_OK;
+
+static DWORD cbMaxToken = 0;
+static PVOID pClientBuf = NULL;
+static PVOID pServerBuf = NULL;
+
+static AUTH_SEQ NTLM_asServer = {0};
+
+BOOL Use_Unicode = FALSE;
+BOOL NTLM_LocalCall = FALSE;
+
+/* Function pointers */
+ACCEPT_SECURITY_CONTEXT_FN _AcceptSecurityContext = NULL;
+ACQUIRE_CREDENTIALS_HANDLE_FN _AcquireCredentialsHandle = NULL;
+COMPLETE_AUTH_TOKEN_FN _CompleteAuthToken = NULL;
+DELETE_SECURITY_CONTEXT_FN _DeleteSecurityContext = NULL;
+FREE_CONTEXT_BUFFER_FN _FreeContextBuffer = NULL;
+FREE_CREDENTIALS_HANDLE_FN _FreeCredentialsHandle = NULL;
+INITIALIZE_SECURITY_CONTEXT_FN _InitializeSecurityContext = NULL;
+QUERY_SECURITY_PACKAGE_INFO_FN _QuerySecurityPackageInfo = NULL;
+#ifdef UNICODE
+QUERY_CONTEXT_ATTRIBUTES_FN_W _QueryContextAttributes = NULL;
+#else
+QUERY_CONTEXT_ATTRIBUTES_FN_A _QueryContextAttributes = NULL;
+#endif
+
+void UnloadSecurityDll(void)
+{
+    if (NTLM_asServer.fHaveCtxtHandle)
+	_DeleteSecurityContext(&NTLM_asServer.hctxt);
+    if (NTLM_asServer.fHaveCredHandle)
+        _FreeCredentialsHandle(&NTLM_asServer.hcred);
+
+    if (hModule)
+	FreeLibrary(hModule);
+
+    xfree(SSP_Package_InUse);
+    xfree(pClientBuf);
+    xfree(pServerBuf);
+
+    _AcceptSecurityContext      = NULL;
+    _AcquireCredentialsHandle   = NULL;
+    _CompleteAuthToken          = NULL;
+    _DeleteSecurityContext      = NULL;
+    _FreeContextBuffer          = NULL;
+    _FreeCredentialsHandle      = NULL;
+    _InitializeSecurityContext  = NULL;
+    _QuerySecurityPackageInfo   = NULL;
+    _QueryContextAttributes     = NULL;
+
+    hModule = NULL;
+}
+
+
+HMODULE LoadSecurityDll(int mode, char * SSP_Package) 
+{
+    TCHAR lpszDLL[MAX_PATH];
+    OSVERSIONINFO VerInfo;
+    PSecPkgInfo pSPI       = NULL;
+
+    /* 
+ *  Find out which security DLL to use, depending on
+ *  whether we are on NT or 2000 or XP or 2003 Server
+ *  We have to use security.dll on Windows NT 4.0.
+ *  All other operating systems, we have to use Secur32.dll
+ */ 
+    hModule = NULL;
+    if ((mode != SSP_BASIC) && (mode != SSP_NTLM))
+	return hModule;
+    NTLM_mode = mode;
+    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
+    if (!GetVersionEx (&VerInfo)) {   /* If this fails, something has gone wrong */
+	return hModule;
+    }
+    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
+	VerInfo.dwMajorVersion == 4 &&
+	VerInfo.dwMinorVersion == 0)
+    {
+	lstrcpy (lpszDLL, _T(WINNT_SECURITY_DLL));
+    } else {
+	lstrcpy (lpszDLL, _T(WIN2K_SECURITY_DLL));
+    }
+    hModule = LoadLibrary(lpszDLL);
+    if (!hModule)
+	return hModule;
+    _AcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN) 
+	GetProcAddress(hModule, "AcceptSecurityContext");
+    if (!_AcceptSecurityContext) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+#ifdef UNICODE
+    _AcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)
+	GetProcAddress(hModule, "AcquireCredentialsHandleW");
+#else
+    _AcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)
+	GetProcAddress(hModule, "AcquireCredentialsHandleA");
+#endif
+    if (!_AcquireCredentialsHandle) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+    _CompleteAuthToken = (COMPLETE_AUTH_TOKEN_FN) 
+	GetProcAddress(hModule, "CompleteAuthToken");
+    if (!_CompleteAuthToken) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+    _DeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN) 
+	GetProcAddress(hModule, "DeleteSecurityContext");
+    if (!_DeleteSecurityContext) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+    _FreeContextBuffer = (FREE_CONTEXT_BUFFER_FN) 
+	GetProcAddress(hModule, "FreeContextBuffer");
+    if (!_FreeContextBuffer) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+    _FreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN) 
+	GetProcAddress(hModule, "FreeCredentialsHandle");
+    if (!_FreeCredentialsHandle) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+#ifdef UNICODE
+    _InitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)
+	GetProcAddress(hModule, "InitializeSecurityContextW");
+#else
+    _InitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN) 
+	GetProcAddress(hModule, "InitializeSecurityContextA");
+#endif
+    if (!_InitializeSecurityContext) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    	return hModule;
+    }
+#ifdef UNICODE
+    _QuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN) 
+	GetProcAddress(hModule, "QuerySecurityPackageInfoW");
+#else
+    _QuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)
+	GetProcAddress(hModule, "QuerySecurityPackageInfoA");
+#endif
+    if (!_QuerySecurityPackageInfo) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    }
+
+#ifdef UNICODE
+    _QueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN_W) 
+	GetProcAddress(hModule, "QueryContextAttributesW");
+#else
+    _QueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN_A)
+	GetProcAddress(hModule, "QueryContextAttributesA");
+#endif
+    if (!_QueryContextAttributes) {
+	UnloadSecurityDll();
+	hModule = NULL;
+    }
+
+    /* Get max token size */
+    _QuerySecurityPackageInfo((SEC_CHAR*)_T(SSP_Package), &pSPI);
+    cbMaxToken = pSPI->cbMaxToken;
+    _FreeContextBuffer(pSPI);
+
+    /* Allocate buffers for client and server messages */
+    pClientBuf = xcalloc(cbMaxToken, sizeof(char));
+    pServerBuf = xcalloc(cbMaxToken, sizeof(char));
+    SSP_Package_InUse = xstrdup(SSP_Package);
+
+    return hModule;
+}
+
+
+BOOL GenClientContext(PAUTH_SEQ pAS, PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,
+		      PVOID pIn, DWORD cbIn, PVOID pOut, PDWORD pcbOut, PBOOL pfDone)
+{
+/*
+ *  Routine Description:
+ *
+ *  Optionally takes an input buffer coming from the server and returns
+ *  a buffer of information to send back to the server. Also returns
+ *  an indication of whether or not the context is complete.
+ *
+ *  Return Value:
+ *  Returns TRUE if successful; otherwise FALSE.
+ */ 
+    TimeStamp       tsExpiry;
+    SecBufferDesc   sbdOut;
+    SecBuffer       sbOut;
+    SecBufferDesc   sbdIn;
+    SecBuffer       sbIn;
+    ULONG           fContextAttr;
+
+    if (!pAS->fInitialized) {
+	SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse), 
+	    SECPKG_CRED_OUTBOUND, NULL, (NTLM_mode == SSP_NTLM) ? NULL : pAuthIdentity, NULL, NULL,
+	    &pAS->hcred, &tsExpiry);
+	if (SecurityStatus < 0)
+	    return FALSE;
+	pAS->fHaveCredHandle = TRUE;
+    }
+    
+    /* Prepare output buffer */
+    sbdOut.ulVersion = 0;
+    sbdOut.cBuffers = 1;
+    sbdOut.pBuffers = &sbOut;
+    sbOut.cbBuffer = *pcbOut;
+    sbOut.BufferType = SECBUFFER_TOKEN;
+    sbOut.pvBuffer = pOut;
+    
+    /* Prepare input buffer */
+    if (pAS->fInitialized)  {
+	sbdIn.ulVersion = 0;
+	sbdIn.cBuffers = 1;
+	sbdIn.pBuffers = &sbIn;
+	sbIn.cbBuffer = cbIn;
+	sbIn.BufferType = SECBUFFER_TOKEN;
+	sbIn.pvBuffer = pIn;
+    }
+    SecurityStatus = _InitializeSecurityContext(&pAS->hcred, 
+	pAS->fInitialized ? &pAS->hctxt : NULL, NULL, 0, 0, 
+	SECURITY_NATIVE_DREP, pAS->fInitialized ? &sbdIn : NULL,
+	0, &pAS->hctxt, &sbdOut, &fContextAttr, &tsExpiry);
+    if (SecurityStatus < 0) 
+	return FALSE;
+    pAS->fHaveCtxtHandle = TRUE;
+    
+    /* If necessary, complete token */
+    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {
+	SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);
+	if (SecurityStatus < 0)
+	    return FALSE;
+    }
+    *pcbOut = sbOut.cbBuffer;
+    if (!pAS->fInitialized)
+	pAS->fInitialized = TRUE;
+    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED 
+	|| SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE );
+    return TRUE;
+}
+
+
+BOOL GenServerContext(PAUTH_SEQ pAS, PVOID pIn, DWORD cbIn, PVOID pOut, 
+		      PDWORD pcbOut, PBOOL pfDone, char * credentials)
+{
+/*
+ *   Routine Description:
+ *
+ *   Takes an input buffer coming from the client and returns a buffer
+ *   to be sent to the client.  Also returns an indication of whether or
+ *   not the context is complete.
+ *
+ *   Return Value:
+ *
+ *   Returns TRUE if successful; otherwise FALSE.
+ */
+
+    SecBufferDesc   sbdOut;
+    SecBuffer       sbOut;
+    SecBufferDesc   sbdIn;
+    SecBuffer       sbIn;
+    ULONG           fContextAttr;
+    SecPkgContext_Names namebuffer;
+
+    if (!pAS->fInitialized)  {
+	SecurityStatus = _AcquireCredentialsHandle(NULL, (SEC_CHAR*) _T(SSP_Package_InUse), 
+	    SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &pAS->hcred, 
+	    &pAS->hcredLifeTime);
+#if SSP_DEBUG
+        fprintf(stderr, "AcquireCredentialsHandle returned: %x\n", SecurityStatus);
+#endif
+       if (SecurityStatus < 0) {
+#if SSP_DEBUG
+            fprintf(stderr, "AcquireCredentialsHandle failed: %x\n", SecurityStatus);
+#endif
+	    return FALSE;
+        }
+	pAS->fHaveCredHandle = TRUE;
+    }
+    
+    /* Prepare output buffer */
+    sbdOut.ulVersion = 0;
+    sbdOut.cBuffers = 1;
+    sbdOut.pBuffers = &sbOut;
+    sbOut.cbBuffer = *pcbOut;
+    sbOut.BufferType = SECBUFFER_TOKEN;
+    sbOut.pvBuffer = pOut;
+
+    /* Prepare input buffer */
+    sbdIn.ulVersion = 0;
+    sbdIn.cBuffers = 1;
+    sbdIn.pBuffers = &sbIn;
+    sbIn.cbBuffer = cbIn;
+    sbIn.BufferType = SECBUFFER_TOKEN;
+    sbIn.pvBuffer = pIn;
+    SecurityStatus = _AcceptSecurityContext(&pAS->hcred, 
+	pAS->fInitialized ? &pAS->hctxt : NULL, &sbdIn, (NTLM_mode == SSP_NTLM) ? ASC_REQ_DELEGATE : 0, 
+	SECURITY_NATIVE_DREP, &pAS->hctxt, &sbdOut, &fContextAttr, 
+	&pAS->hctxtLifeTime);
+#if SSP_DEBUG
+    fprintf(stderr, "AcceptSecurityContext returned: %x\n", SecurityStatus);
+#endif
+    if (SecurityStatus < 0) {
+#if SSP_DEBUG
+        fprintf(stderr, "AcceptSecurityContext failed: %x\n", SecurityStatus);
+#endif
+	return FALSE;
+    }
+    pAS->fHaveCtxtHandle = TRUE;
+    
+    /* If necessary, complete token */
+    if (SecurityStatus == SEC_I_COMPLETE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) {
+	SecurityStatus = _CompleteAuthToken(&pAS->hctxt, &sbdOut);
+#if SSP_DEBUG
+        fprintf(stderr, "CompleteAuthToken returned: %x\n", SecurityStatus);
+#endif
+        if (SecurityStatus < 0) {
+#if SSP_DEBUG
+            fprintf(stderr, "CompleteAuthToken failed: %x\n", SecurityStatus);
+#endif
+	    return FALSE;
+        }
+    }
+
+    if ((credentials != NULL) && 
+         !(SecurityStatus == SEC_I_CONTINUE_NEEDED || SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE)) {
+        SecurityStatus = _QueryContextAttributes(&pAS->hctxt, SECPKG_ATTR_NAMES, &namebuffer);
+#if SSP_DEBUG
+        fprintf(stderr, "QueryContextAttributes returned: %x\n", SecurityStatus);
+#endif
+        if (SecurityStatus < 0) {
+#if SSP_DEBUG
+            fprintf(stderr, "QueryContextAttributes failed: %x\n", SecurityStatus);
+#endif
+	    return FALSE;
+        }
+        strncpy(credentials, namebuffer.sUserName, SSP_MAX_CRED_LEN);
+    }
+
+    *pcbOut = sbOut.cbBuffer;
+    if (!pAS->fInitialized)
+	pAS->fInitialized = TRUE;
+    *pfDone = !(SecurityStatus == SEC_I_CONTINUE_NEEDED 
+	|| SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE);
+    return TRUE;
+}
+
+
+BOOL WINAPI SSP_LogonUser(PTSTR szUser, PTSTR szPassword, PTSTR szDomain) 
+{
+    AUTH_SEQ    asServer   = {0};
+    AUTH_SEQ    asClient   = {0};
+    BOOL        fDone      = FALSE;
+    BOOL        fResult    = FALSE;
+    DWORD       cbOut      = 0;
+    DWORD       cbIn       = 0;
+    
+    SEC_WINNT_AUTH_IDENTITY ai;
+
+    do {
+	if (!hModule)
+	    break;
+
+        /* Initialize auth identity structure */
+	ZeroMemory(&ai, sizeof(ai));
+	ai.Domain = szDomain;
+	ai.DomainLength = lstrlen(szDomain);
+	ai.User = szUser;
+	ai.UserLength = lstrlen(szUser);
+	ai.Password = szPassword;
+	ai.PasswordLength = lstrlen(szPassword);
+#if defined(UNICODE) || defined(_UNICODE)
+	ai.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
+#else      
+	ai.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
+#endif
+
+	/* Prepare client message (negotiate) */
+	cbOut = cbMaxToken;
+	if (!GenClientContext(&asClient, &ai, NULL, 0, pClientBuf, &cbOut, &fDone))
+	    break;
+
+	/* Prepare server message (challenge) */
+	cbIn = cbOut;
+	cbOut = cbMaxToken;
+	if (!GenServerContext(&asServer, pClientBuf, cbIn, pServerBuf, &cbOut, 
+	    &fDone, NULL))
+	    break;
+/* Most likely failure: AcceptServerContext fails with SEC_E_LOGON_DENIED
+ * in the case of bad szUser or szPassword.
+ * Unexpected Result: Logon will succeed if you pass in a bad szUser and 
+ * the guest account is enabled in the specified domain.
+ */
+
+	/* Prepare client message (authenticate) */
+	cbIn = cbOut;
+	cbOut = cbMaxToken;
+	if (!GenClientContext(&asClient, &ai, pServerBuf, cbIn, pClientBuf, &cbOut,
+	    &fDone))
+	    break;
+
+	/* Prepare server message (authentication) */
+	cbIn = cbOut;
+	cbOut = cbMaxToken;
+	if (!GenServerContext(&asServer, pClientBuf, cbIn, pServerBuf, &cbOut, 
+	    &fDone, NULL))
+	    break;
+	fResult = TRUE;
+    } while(0);
+
+    /* Clean up resources */
+    if (asClient.fHaveCtxtHandle)
+	_DeleteSecurityContext(&asClient.hctxt);
+    if (asClient.fHaveCredHandle)
+	_FreeCredentialsHandle(&asClient.hcred);
+    if (asServer.fHaveCtxtHandle)
+	_DeleteSecurityContext(&asServer.hctxt);
+    if (asServer.fHaveCredHandle)
+	_FreeCredentialsHandle(&asServer.hcred);
+
+    return fResult;
+}
+
+
+const char * WINAPI SSP_MakeChallenge(PVOID PNegotiateBuf, int NegotiateLen)
+{
+    BOOL        fDone      = FALSE;
+    PVOID       fResult    = NULL;
+    DWORD       cbOut      = 0;
+    DWORD       cbIn       = 0;
+    ntlm_challenge * challenge;
+    const char * encoded = NULL;    
+
+    if (NTLM_asServer.fHaveCtxtHandle)
+	_DeleteSecurityContext(&NTLM_asServer.hctxt);
+    if (NTLM_asServer.fHaveCredHandle)
+        _FreeCredentialsHandle(&NTLM_asServer.hcred);
+
+    NTLM_LocalCall = FALSE;
+    Use_Unicode = FALSE;
+    memcpy(pClientBuf, PNegotiateBuf, NegotiateLen);
+    ZeroMemory(pServerBuf, cbMaxToken);
+    ZeroMemory(&NTLM_asServer, sizeof(NTLM_asServer));
+    do {
+	if (!hModule)
+	    break;
+
+	/* Prepare server message (challenge) */
+	cbIn = NegotiateLen;
+	cbOut = cbMaxToken;
+	if (!GenServerContext(&NTLM_asServer, pClientBuf, cbIn, pServerBuf, &cbOut, 
+	    &fDone, NULL))
+	    break;
+	fResult = pServerBuf;
+    } while(0);
+    if (fResult != NULL) {
+        challenge = (ntlm_challenge *) fResult;
+        Use_Unicode = NEGOTIATE_UNICODE & challenge->flags;
+        NTLM_LocalCall = NEGOTIATE_THIS_IS_LOCAL_CALL & challenge->flags;
+        encoded = base64_encode_bin((char *) fResult, cbOut);
+    }
+    return encoded;
+}
+
+
+BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID PAutenticateBuf, int AutenticateLen, char * credentials)
+{
+    BOOL        fDone      = FALSE;
+    BOOL        fResult    = FALSE;
+    DWORD       cbOut      = 0;
+    DWORD       cbIn       = 0;
+
+    memcpy(pClientBuf, PAutenticateBuf, AutenticateLen);
+    ZeroMemory(pServerBuf, cbMaxToken);
+    do {
+	if (!hModule)
+	    break;
+
+        /* Prepare server message (authentication) */
+        cbIn = AutenticateLen;
+	cbOut = cbMaxToken;
+	if (!GenServerContext(&NTLM_asServer, pClientBuf, cbIn, pServerBuf, &cbOut, 
+	    &fDone, credentials))
+	    break;
+	fResult = TRUE;
+    } while(0);
+
+    return fResult;
+}
+
+
+const char * WINAPI SSP_MakeNegotiateBlob(PVOID PNegotiateBuf, int NegotiateLen, PBOOL fDone, int * Status, char * credentials)
+{
+    DWORD       cbOut      = 0;
+    DWORD       cbIn       = 0;
+    const char * encoded = NULL;    
+
+    if (NTLM_asServer.fHaveCtxtHandle)
+	_DeleteSecurityContext(&NTLM_asServer.hctxt);
+    if (NTLM_asServer.fHaveCredHandle)
+        _FreeCredentialsHandle(&NTLM_asServer.hcred);
+
+    memcpy(pClientBuf, PNegotiateBuf, NegotiateLen);
+    ZeroMemory(pServerBuf, cbMaxToken);
+    ZeroMemory(&NTLM_asServer, sizeof(NTLM_asServer));
+    do {
+	if (!hModule)
+	    break;
+
+	/* Prepare server message (challenge) */
+	cbIn = NegotiateLen;
+	cbOut = cbMaxToken;
+	if (!GenServerContext(&NTLM_asServer, pClientBuf, cbIn, pServerBuf, &cbOut, 
+            fDone, credentials)) {
+                *Status = SSP_ERROR;
+                break;
+        }
+	*Status = SSP_OK;
+    } while(0);
+    if (pServerBuf != NULL && cbOut > 0)
+        encoded = base64_encode_bin((char *) pServerBuf, cbOut);
+    return encoded;
+}
+
+
+const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID PAutenticateBuf, int AutenticateLen, PBOOL fDone, int * Status, char * credentials)
+{
+    DWORD       cbOut      = 0;
+    DWORD       cbIn       = 0;
+    const char * encoded = NULL;    
+
+    memcpy(pClientBuf, PAutenticateBuf, AutenticateLen);
+    ZeroMemory(pServerBuf, cbMaxToken);
+    do {
+	if (!hModule)
+	    break;
+
+        /* Prepare server message (authentication) */
+        cbIn = AutenticateLen;
+	cbOut = cbMaxToken;
+	if (!GenServerContext(&NTLM_asServer, pClientBuf, cbIn, pServerBuf, &cbOut, 
+            fDone, credentials)) {
+                *Status = SSP_ERROR;
+                break;
+        }
+	*Status = SSP_OK;
+    } while(0);
+    if (pServerBuf != NULL && cbOut > 0)
+        encoded = base64_encode_bin((char *) pServerBuf, cbOut);
+    return encoded;
+}