@@ -1,3 +1,25 @@
+Changes to squid-3.4.4.2 (23 Apr 2014):
+
+	- versino bump for packaging re-build with altered toolchain
+
+Changes to squid-3.4.4.1 (23 Apr 2014):
+
+	- Regression Bug 4019: Cache digest exchange segmentation fault
+	- Regression Bug 3982: EUI logging and helpers show blank MAC address
+	- Bug 4047: Support Android builds
+	- Bug 4043: Remove XMALLOC_TRACE and references to sbrk(2)
+	- Bug 4041: Missing files in compat/Makefile.am
+	- Bug 4014: Build failure with --disable-optimizations --disable-auth
+	- Bug 3986: (partial) assertion due to incorrect error page buffer size
+	- Bug 3955: Solaris EUI-48 lookup leaks FDs
+	- Bug 3371: CONNECT with data sent at once loses data
+	- C++11: Upgrade auto-detection to use the formal -std=c++11
+	- Crypto-NG: libnettle MD5 algorithm support
+	- SSL-Bump: Fix Basic auth caching on bumped connections
+	- Store-ID: Fix request URI when forwarding requests to peers
+	- ... and fix several other build errors
+	- ... and some documentation updates
+
 Changes to squid-3.4.4 (09 Mar 2014):
 
 	- Bug 4029: intercepted HTTPS requests bypass caching checks
@@ -56,6 +56,7 @@ libcompat_squid_la_SOURCES = \
 	xstrto.h \
 	\
 	os/aix.h \
+	os/android.h \
 	os/dragonfly.h \
 	os/freebsd.h \
 	os/hpux.h \
@@ -56,6 +56,7 @@
 /*****************************************************/
 
 #include "compat/os/aix.h"
+#include "compat/os/android.h"
 #include "compat/os/dragonfly.h"
 #include "compat/os/freebsd.h"
 #include "compat/os/hpux.h"
@@ -0,0 +1,13 @@
+#ifndef SQUID_OS_ANDROID_H
+#define SQUID_OS_ANDROID_H
+
+#if defined(__ANDROID__)
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+#define _SQUID_ANDROID_ 1
+
+#endif /* _SQUID_ANDROID_ */
+#endif /* SQUID_OS_ANDROID_H */
@@ -5,7 +5,7 @@
 #include "squid.h"
 #include "psignal.h"
 
-#if _SQUID_AIX_ || _SQUID_MINGW_
+#if _SQUID_AIX_ || _SQUID_ANDROID_ || _SQUID_MINGW_
 extern const char* const sys_siglist[];
 #define _sys_nsig 64
 #define _sys_siglist sys_siglist
@@ -206,7 +206,7 @@ AC_SUBST(CGIEXT)
 
 AM_CONDITIONAL(ENABLE_WIN32SPECIFIC,
                [test "x$squid_host_os" = "xmingw" -o "x$squid_host_os" = "xcygwin"])
-AM_CONDITIONAL(USE_IPC_WIN32,[test "x$squid_host_os" = "xmingw"])
+AM_CONDITIONAL(ENABLE_WIN32_IPC,[test "x$squid_host_os" = "xmingw"])
 
 case "$squid_host_os" in
 mingw)
@@ -536,7 +536,7 @@ AC_ARG_WITH(pthreads,AS_HELP_STRING([--without-pthreads],[Disable POSIX Threads]
 AC_ARG_WITH(aio, AS_HELP_STRING([--without-aio],[Do not use POSIX AIO. Default: auto-detect]))
 AH_TEMPLATE(USE_DISKIO_AIO, [Whether POSIX AIO support is needed. Automatic])
 AH_TEMPLATE(USE_DISKIO_DISKTHREADS, [Whether pthreads support is needed. Automatic])
-USE_AIOPS_WIN32=0
+ENABLE_WIN32_AIOPS=0
 squid_opt_use_aio=
 squid_opt_use_diskthreads=
 AIOLIB=
@@ -579,7 +579,7 @@ for module in $squid_disk_module_candidates none; do
       dnl REF: http://autoconf-archive.cryp.to/acx_pthread.html
         case "$squid_host_os" in
           mingw)
-            USE_AIOPS_WIN32=1
+            ENABLE_WIN32_AIOPS=1
             AC_MSG_NOTICE([Windows threads support automatically enabled])
             ;;
           freebsd)
@@ -691,7 +691,7 @@ for module in $squid_disk_module_candidates none; do
         DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/AIO/AIODiskIOModule.o"
         case "$squid_host_os" in
           mingw)
-            USE_AIO_WIN32=1
+            ENABLE_WIN32_AIO=1
             AC_MSG_NOTICE([Replacing AIO DiskIO module with: Windows overlapped I/O support])
             ;;
           *)
@@ -750,8 +750,8 @@ AC_SUBST(DISK_LIBS)
 AC_SUBST(DISK_PROGRAMS)
 AC_SUBST(DISK_LINKOBJS)
 AC_SUBST(DISK_OS_LIBS)
-AM_CONDITIONAL([USE_AIOPS_WIN32], [test "$USE_AIOPS_WIN32" = "1"])
-AM_CONDITIONAL([USE_AIO_WIN32], [test "$USE_AIO_WIN32" = "1"])
+AM_CONDITIONAL([ENABLE_WIN32_AIOPS], [test "$ENABLE_WIN32_AIOPS" = "1"])
+AM_CONDITIONAL([ENABLE_WIN32_AIO], [test "$ENABLE_WIN32_AIO" = "1"])
 
 
 dnl Check what Storage formats are wanted.
@@ -1204,6 +1204,64 @@ fi
 AC_MSG_NOTICE([Using Nettle cryptographic library: ${with_nettle:=yes}])
 AC_SUBST(NETTLELIB)
 
+dnl Check for libcrypt
+CRYPTLIB=
+dnl Some of our helpers use crypt(3) which may be in libc, or in
+dnl libcrypt (eg FreeBSD)
+AC_CHECK_LIB(crypt, crypt, [CRYPTLIB="-lcrypt"])
+dnl Solaris10 provides MD5 natively through libmd5
+AC_CHECK_LIB(md5, MD5Init, [CRYPTLIB="$CRYPTLIB -lmd5"])
+AC_SUBST(CRYPTLIB)
+
+SSLLIB=""
+
+dnl User may want to disable GnuTLS
+AC_ARG_WITH(gnutls,
+  AS_HELP_STRING([--without-gnutls],
+                 [Do not use GnuTLS for SSL. Default: auto-detect]), [ 
+case "$with_gnutls" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      AC_MSG_ERROR([--with-gnutls path does not point to a directory])
+    fi
+    LIBGNUTLS_PATH="-L$with_gnutls/lib"
+    CPPFLAGS="-I$with_gnutls/include $CPPFLAGS"
+  esac
+])
+AH_TEMPLATE(USE_GNUTLS,[GnuTLS support is available])
+if test "x$with_gnutls" != "xno"; then
+  AC_CHECK_HEADERS(gnutls/gnutls.h gnutls/x509.h)
+
+  # User may have provided a custom location for GnuTLS. Otherwise...
+  SQUID_STATE_SAVE(squid_gnutls_state)
+  LIBS="$LIBS $LIBGNUTLS_PATH"
+
+  # auto-detect using pkg-config
+  PKG_CHECK_MODULES([LIBGNUTLS],[gnutls >= 3.1.5],,[
+    ## find the package without pkg-config
+    ## check that the library is actually new enough.
+    ## by testing for a 3.1.5+ function which we use
+    AC_CHECK_LIB(gnutls,gnutls_certificate_verify_peers3,[LIBGNUTLS_LIBS="-lgnutls"])
+  ])
+
+  SQUID_STATE_ROLLBACK(squid_gnutls_state) #de-pollute LIBS
+
+  if test "x$with_gnutls" = "xyes" -a "x$LIBGNUTLS_LIBS" = "x"; then
+    AC_MSG_ERROR([Required GnuTLS library not found])
+  fi
+  if test "x$LIBGNUTLS_LIBS" != "x" ; then
+    CXXFLAGS="$LIBGNUTLS_CFLAGS $CXXFLAGS"
+    SSLLIB="$LIBGNUTLS_PATH $LIBGNUTLS_LIBS $SSLLIB"
+    AC_DEFINE(USE_GNUTLS,1,[GnuTLS support is available])
+  else
+    with_gnutls=no
+  fi
+fi
+AC_MSG_NOTICE([GnuTLS library support: ${with_gnutls:=auto} ${LIBGNUTLS_PATH} ${LIBGNUTLS_LIBS}])
+
 dnl User may specify OpenSSL is needed from a non-standard location
 AC_ARG_WITH(openssl,
   AS_HELP_STRING([--with-openssl=PATH],
@@ -1219,7 +1277,7 @@ case "$with_openssl" in
     if test ! -d "$withval" ; then
       AC_MSG_ERROR([--with-openssl path does not point to a directory])
     fi
-    LIBOPENSSL_LIBS="-L$with_openssl/lib"
+    LIBOPENSSL_PATH="-L$with_openssl/lib"
     CPPFLAGS="-I$with_openssl/include $CPPFLAGS"
     with_openssl=yes
   esac
@@ -1238,38 +1296,39 @@ if test "x$with_openssl" = "xyes"; then
   )
 
   # User may have provided a custom location for OpenSSL. Otherwise...
-  if test "x$LIBOPENSSL_LIBS" = "x" ; then
-    # auto-detect using pkg-config
-    PKG_CHECK_MODULES([LIBOPENSSL],[openssl],,[
-      ## For some OS pkg-config is broken or unavailable.
-      ## Detect libraries the hard way.
-
-      # Windows MinGW has some special libraries ...
-      if test "x$squid_host_os" = "xmingw" ; then
-        LIBOPENSSL_LIBS='-lssleay32 -leay32 -lgdi32 $LIBOPENSSL_LIBS'
-        AC_MSG_NOTICE([Windows OpenSSL library support: yes -lssleay32 -leay32 -lgdi32])
-      fi
-
-      AC_CHECK_LIB(crypto,[CRYPTO_new_ex_data],[LIBOPENSSL_LIBS="-lcrypto $LIBOPENSSL_LIBS"],[
-        AC_MSG_ERROR([library 'crypto' is required for OpenSSL])
-      ])
-      AC_CHECK_LIB(ssl,[SSL_library_init],[LIBOPENSSL_LIBS="-lssl $LIBOPENSSL_LIBS"],[
-        AC_MSG_ERROR([library 'ssl' is required for OpenSSL])
-      ])
+  SQUID_STATE_SAVE(squid_openssl_state)
+  LIBS="$LIBS $LIBOPENSSL_PATH"
+
+  # auto-detect using pkg-config
+  PKG_CHECK_MODULES([LIBOPENSSL],[openssl],,[
+    ## For some OS pkg-config is broken or unavailable.
+    ## Detect libraries the hard way.
+
+    # Windows MinGW has some special libraries ...
+    if test "x$squid_host_os" = "xmingw" ; then
+      LIBOPENSSL_LIBS='-lssleay32 -leay32 -lgdi32 $LIBOPENSSL_LIBS'
+      AC_MSG_NOTICE([Windows OpenSSL library support: yes -lssleay32 -leay32 -lgdi32])
+    fi
 
+    AC_CHECK_LIB(crypto,[CRYPTO_new_ex_data],[LIBOPENSSL_LIBS="-lcrypto $LIBOPENSSL_LIBS"],[
+      AC_MSG_ERROR([library 'crypto' is required for OpenSSL])
+    ])
+    AC_CHECK_LIB(ssl,[SSL_library_init],[LIBOPENSSL_LIBS="-lssl $LIBOPENSSL_LIBS"],[
+      AC_MSG_ERROR([library 'ssl' is required for OpenSSL])
     ])
+  ])
 
-    # This is a workaround for RedHat 9 brain damage..
-    if test -d /usr/kerberos/include -a -f /usr/include/openssl/kssl.h; then
-      AC_MSG_NOTICE([OpenSSL depends on Kerberos])
-      LIBOPENSSL_LIBS="-L/usr/kerberos/lib $LIBOPENSSL_LIBS"
-      CPPFLAGS="$CPPFLAGS -I/usr/kerberos/include"
-    fi
+  # This is a workaround for RedHat 9 brain damage..
+  if test -d /usr/kerberos/include -a -f /usr/include/openssl/kssl.h; then
+    AC_MSG_NOTICE([OpenSSL depends on Kerberos])
+    LIBOPENSSL_LIBS="-L/usr/kerberos/lib $LIBOPENSSL_LIBS"
+    CPPFLAGS="$CPPFLAGS -I/usr/kerberos/include"
   fi
+  SQUID_STATE_ROLLBACK(squid_openssl_state) #de-pollute LIBS
 
   if test "x$LIBOPENSSL_LIBS" != "x"; then
     CXXFLAGS="$LIBOPENSSL_CFLAGS $CXXFLAGS"
-    SSLLIB="$LIBOPENSSL_LIBS $SSLLIB"
+    SSLLIB="$LIBOPENSSL_PATH $LIBOPENSSL_LIBS $SSLLIB"
     AC_DEFINE(USE_OPENSSL,1,[OpenSSL support is available])
 
     # check for other specific broken implementations
@@ -1281,7 +1340,7 @@ if test "x$with_openssl" = "xyes"; then
     AC_MSG_ERROR([Required OpenSSL library not found])
   fi
 fi
-AC_MSG_NOTICE([OpenSSL library support: ${with_openssl:=no} ${LIBOPENSSL_LIBS}])
+AC_MSG_NOTICE([OpenSSL library support: ${with_openssl:=no} ${LIBOPENSSL_PATH} ${LIBOPENSSL_LIBS}])
 AM_CONDITIONAL(ENABLE_SSL,[ test "x$with_openssl" = "xyes" ])
 AC_SUBST(SSLLIB)
 
@@ -2196,7 +2255,6 @@ AC_CHECK_HEADERS( \
   paths.h \
   poll.h \
   pwd.h \
-  shadow.h \
   regex.h \
   sched.h \
   siginfo.h \
@@ -2561,22 +2619,6 @@ SQUID_CHECK_SS_LEN_IN_SOCKADDR_STORAGE
 SQUID_CHECK_SIN_LEN_IN_SOCKADDR_IN
 
 
-dnl Check for libcrypt
-CRYPTLIB=
-dnl Some of our helpers use crypt(3) which may be in libc, or in
-dnl libcrypt (eg FreeBSD)
-AC_CHECK_LIB(crypt, crypt, [CRYPTLIB="-lcrypt"])
-dnl Solaris10 provides MD5 natively through libmd5
-AC_CHECK_LIB(md5, MD5Init, [CRYPTLIB="$CRYPTLIB -lmd5"])
-AC_SUBST(CRYPTLIB)
-
-# check for crypt, may require -lcrypt
-SAVED_LIBS="$LIBS"
-LIBS="$LIBS $CRYPTLIB"
-AC_CHECK_FUNCS(crypt)
-LIBS="$SAVED_LIBS"
-
-
 dnl Check for libdl, used by auth_modules/PAM
 if test "x$with_dl" = "xyes"; then
     AC_CHECK_LIB(dl, dlopen)
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.4 release notes</title>
+<title>Squid 3.4.4.2 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.4 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.4.2 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -1 +1,7 @@
 BUILD_HELPER="NCSA"
+
+# check for optional crypt(3), may require -lcrypt
+SQUID_STATE_SAVE(ncsa_helper)
+LIBS="$LIBS $CRYPTLIB"
+AC_CHECK_FUNCS(crypt)
+SQUID_STATE_ROLLBACK(ncsa_helper)
@@ -1 +1,14 @@
-AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="getpwnam"])
+AC_CHECK_HEADERS([pwd.h],[
+  # check for crypt(3), may require -lcrypt
+  SQUID_STATE_SAVE(getpwnam_helper)
+  LIBS="$LIBS $CRYPTLIB"
+  AC_CHECK_FUNCS(crypt)
+  SQUID_STATE_ROLLBACK(getpwnam_helper)
+
+  # unconditionally requires crypt(3), for now
+  if test "x$ac_cv_func_crypt" != "x"; then
+    AC_CHECK_HEADERS(unistd.h crypt.h shadow.h)
+
+    BUILD_HELPER="getpwnam"
+  fi
+])
@@ -53,19 +53,24 @@ close RULES;
 URL: while (<STDIN>) {
 	chomp;
 	last if $_ eq 'quit';
-	
+
+  my $channel = "";
+  if (s/^(\d+\s+)//o) {
+    $channel = $1;
+  }
+
 	foreach my $rule (@rules) {
 		if (my @match = /$rule->[0]/) {
 			$_ = $rule->[1];
 			
 			for (my $i=1; $i<=scalar(@match); $i++) {
 				s/\$$i/$match[$i-1]/g;
 			}
-			print "OK store-id=$_\n";
+			print $channel, "OK store-id=$_\n";
 			next URL;
 		}
 	}
-	print "ERR\n";
+	print $channel, "ERR\n";
 }
 
 =pod
@@ -223,8 +223,7 @@ class AccessLogEntry: public RefCountable
 #endif
 
     // Why is this a sub-class and not a set of real "private:" fields?
-    // It looks like its duplicating HTTPRequestMethod anyway!
-    // TODO: shuffle this to the relevant protocol section OR replace with request->method
+    // TODO: shuffle this to the relevant ICP/HTCP protocol section
     class Private
     {
 
@@ -30,6 +30,7 @@
  */
 
 #include "acl/forward.h"
+#include "base/CbcPointer.h"
 #include "enums.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
@@ -43,7 +44,9 @@
 
 class CachePeerDomainList;
 class NeighborTypeDomainList;
+class PconnPool;
 class PeerDigest;
+class PeerPoolMgr;
 
 // currently a POD
 class CachePeer
@@ -186,6 +189,12 @@ class CachePeer
     time_t connect_timeout;
     int connect_fail_limit;
     int max_conn;
+    struct {
+        PconnPool *pool; ///< idle connection pool for this peer
+        CbcPointer<PeerPoolMgr> mgr; ///< pool manager
+        int limit; ///< the limit itself
+        bool waitingForClose; ///< a conn must close before we open a standby conn
+    } standby; ///< optional "cache_peer standby=limit" feature
     char *domain;       /* Forced domain */
 #if USE_OPENSSL
 
@@ -80,7 +80,7 @@ class ACLExternal : public ACL
     /* when requiresRequest is made dynamic, review this too */
     //    virtual bool requiresReply() const {return true;}
     virtual bool isProxyAuth() const;
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool valid () const;
     virtual bool empty () const;
 
@@ -65,6 +65,7 @@
 #include "neighbors.h"
 #include "pconn.h"
 #include "PeerSelectState.h"
+#include "PeerPoolMgr.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -76,6 +77,7 @@
 #include "ssl/Config.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/helper.h"
+#include "ssl/PeerConnector.h"
 #include "ssl/ServerBump.h"
 #include "ssl/support.h"
 #endif
@@ -85,37 +87,66 @@
 
 static PSC fwdPeerSelectionCompleteWrapper;
 static CLCB fwdServerClosedWrapper;
-#if USE_OPENSSL
-static PF fwdNegotiateSSLWrapper;
-#endif
 static CNCB fwdConnectDoneWrapper;
 
 static OBJH fwdStats;
 
 #define MAX_FWD_STATS_IDX 9
 static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][Http::scInvalidHeader + 1];
 
-static PconnPool *fwdPconnPool = new PconnPool("server-side");
+static PconnPool *fwdPconnPool = new PconnPool("server-side", NULL);
 CBDATA_CLASS_INIT(FwdState);
 
+#if USE_OPENSSL
+class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+{
+public:
+    typedef void (FwdState::*Method)(Ssl::PeerConnectorAnswer &);
+
+    FwdStatePeerAnswerDialer(Method method, FwdState *fwd):
+        method_(method), fwd_(fwd), answer_() {}
+
+    /* CallDialer API */
+    virtual bool canDial(AsyncCall &call) { return fwd_.valid(); }
+    void dial(AsyncCall &call) { ((&(*fwd_))->*method_)(answer_); }
+    virtual void print(std::ostream &os) const {
+        os << '(' << fwd_.get() << ", " << answer_ << ')'; }
+
+    /* Ssl::PeerConnector::CbDialer API */
+    virtual Ssl::PeerConnectorAnswer &answer() { return answer_; }
+
+private:
+    Method method_;
+    CbcPointer<FwdState> fwd_;
+    Ssl::PeerConnectorAnswer answer_;
+};
+#endif
+
+
 void
 FwdState::abort(void* d)
 {
     FwdState* fwd = (FwdState*)d;
     Pointer tmp = fwd; // Grab a temporary pointer to keep the object alive during our scope.
 
     if (Comm::IsConnOpen(fwd->serverConnection())) {
-        comm_remove_close_handler(fwd->serverConnection()->fd, fwdServerClosedWrapper, fwd);
-        debugs(17, 3, HERE << "store entry aborted; closing " <<
-               fwd->serverConnection());
-        fwd->serverConnection()->close();
+        fwd->closeServerConnection("store entry aborted");
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
     fwd->serverDestinations.clear();
     fwd->self = NULL;
 }
 
+void
+FwdState::closeServerConnection(const char *reason)
+{
+    debugs(17, 3, "because " << reason << "; " << serverConn);
+    comm_remove_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
+    fwdPconnPool->noteUses(fd_table[serverConn->fd].pconn.uses);
+    serverConn->close();
+}
+
 /**** PUBLIC INTERFACE ********************************************************/
 
 FwdState::FwdState(const Comm::ConnectionPointer &client, StoreEntry * e, HttpRequest * r, const AccessLogEntryPointer &alp):
@@ -271,11 +302,8 @@ FwdState::~FwdState()
         calls.connector = NULL;
     }
 
-    if (Comm::IsConnOpen(serverConn)) {
-        comm_remove_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
-        debugs(17, 3, HERE << "closing FD " << serverConnection()->fd);
-        serverConn->close();
-    }
+    if (Comm::IsConnOpen(serverConn))
+        closeServerConnection("~FwdState");
 
     serverDestinations.clear();
 
@@ -297,7 +325,7 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
      */
 
     if ( Config.accessList.miss && !request->client_addr.isNoAddr() &&
-            request->protocol != AnyP::PROTO_INTERNAL && request->protocol != AnyP::PROTO_CACHE_OBJECT) {
+            !request->flags.internal && request->url.getScheme() != AnyP::PROTO_CACHE_OBJECT) {
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access).
          * Intentionally replace the src_addr automatically selected by the checklist code
@@ -337,13 +365,16 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
         return;
     }
 
-    switch (request->protocol) {
-
-    case AnyP::PROTO_INTERNAL:
+    if (request->flags.internal) {
+        debugs(17, 2, "calling internalStart() due to request flag");
         internalStart(clientConn, request, entry);
         return;
+    }
+
+    switch (request->url.getScheme()) {
 
     case AnyP::PROTO_CACHE_OBJECT:
+        debugs(17, 2, "calling CacheManager due to request scheme " << request->url.getScheme());
         CacheManager::GetInstance()->Start(clientConn, request, entry);
         return;
 
@@ -508,16 +539,6 @@ fwdServerClosedWrapper(const CommCloseCbParams &params)
     fwd->serverClosed(params.fd);
 }
 
-#if USE_OPENSSL
-static void
-fwdNegotiateSSLWrapper(int fd, void *data)
-{
-    FwdState *fwd = (FwdState *) data;
-    fwd->negotiateSSL(fd);
-}
-
-#endif
-
 void
 fwdConnectDoneWrapper(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno, void *data)
 {
@@ -598,7 +619,10 @@ FwdState::checkRetriable()
 void
 FwdState::serverClosed(int fd)
 {
-    debugs(17, 2, HERE << "FD " << fd << " " << entry->url());
+    debugs(17, 2, "FD " << fd << " " << entry->url() << " after " <<
+           fd_table[fd].pconn.uses << " requests");
+    if (serverConnection()->fd == fd) // should be, but not critical to assert
+        fwdPconnPool->noteUses(fd_table[fd].pconn.uses);
     retryOrBail();
 }
 
@@ -646,363 +670,6 @@ FwdState::handleUnregisteredServerEnd()
     retryOrBail();
 }
 
-#if USE_OPENSSL
-void
-FwdState::negotiateSSL(int fd)
-{
-    unsigned long ssl_lib_error = SSL_ERROR_NONE;
-    SSL *ssl = fd_table[fd].ssl;
-    int ret;
-
-    if ((ret = SSL_connect(ssl)) <= 0) {
-        int ssl_error = SSL_get_error(ssl, ret);
-#ifdef EPROTO
-        int sysErrNo = EPROTO;
-#else
-        int sysErrNo = EACCES;
-#endif
-
-        switch (ssl_error) {
-
-        case SSL_ERROR_WANT_READ:
-            Comm::SetSelect(fd, COMM_SELECT_READ, fwdNegotiateSSLWrapper, this, 0);
-            return;
-
-        case SSL_ERROR_WANT_WRITE:
-            Comm::SetSelect(fd, COMM_SELECT_WRITE, fwdNegotiateSSLWrapper, this, 0);
-            return;
-
-        case SSL_ERROR_SSL:
-        case SSL_ERROR_SYSCALL:
-            ssl_lib_error = ERR_get_error();
-            debugs(81, DBG_IMPORTANT, "fwdNegotiateSSL: Error negotiating SSL connection on FD " << fd <<
-                   ": " << ERR_error_string(ssl_lib_error, NULL) << " (" << ssl_error <<
-                   "/" << ret << "/" << errno << ")");
-
-            // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
-            if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
-                sysErrNo = errno;
-
-            // falling through to complete error handling
-
-        default:
-            // TODO: move into a method before merge
-            Ssl::ErrorDetail *errDetails;
-            Ssl::ErrorDetail *errFromFailure = (Ssl::ErrorDetail *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail);
-            if (errFromFailure != NULL) {
-                // The errFromFailure is attached to the ssl object
-                // and will be released when ssl object destroyed.
-                // Copy errFromFailure to a new Ssl::ErrorDetail object.
-                errDetails = new Ssl::ErrorDetail(*errFromFailure);
-            } else {
-                // server_cert can be NULL here
-                X509 *server_cert = SSL_get_peer_certificate(ssl);
-                errDetails = new Ssl::ErrorDetail(SQUID_ERR_SSL_HANDSHAKE, server_cert, NULL);
-                X509_free(server_cert);
-            }
-
-            if (ssl_lib_error != SSL_ERROR_NONE)
-                errDetails->setLibError(ssl_lib_error);
-
-            if (request->clientConnectionManager.valid()) {
-                // remember the server certificate from the ErrorDetail object
-                if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
-                    serverBump->serverCert.resetAndLock(errDetails->peerCert());
-
-                    // remember validation errors, if any
-                    if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
-                        serverBump->sslErrors = cbdataReference(errs);
-                }
-
-                // For intercepted connections, set the host name to the server
-                // certificate CN. Otherwise, we just hope that CONNECT is using
-                // a user-entered address (a host name or a user-entered IP).
-                const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
-                if (request->flags.sslPeek && !isConnectRequest) {
-                    if (X509 *srvX509 = errDetails->peerCert()) {
-                        if (const char *name = Ssl::CommonHostName(srvX509)) {
-                            request->SetHost(name);
-                            debugs(83, 3, HERE << "reset request host: " << name);
-                        }
-                    }
-                }
-            }
-
-            ErrorState *const anErr = makeConnectingError(ERR_SECURE_CONNECT_FAIL);
-            anErr->xerrno = sysErrNo;
-            anErr->detail = errDetails;
-            fail(anErr);
-
-            if (serverConnection()->getPeer()) {
-                peerConnectFailed(serverConnection()->getPeer());
-            }
-
-            serverConn->close();
-            return;
-        }
-    }
-
-    if (request->clientConnectionManager.valid()) {
-        // remember the server certificate from the ErrorDetail object
-        if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
-            serverBump->serverCert.reset(SSL_get_peer_certificate(ssl));
-
-            // remember validation errors, if any
-            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
-                serverBump->sslErrors = cbdataReference(errs);
-        }
-    }
-
-    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
-        if (serverConnection()->getPeer()->sslSession)
-            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
-
-        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
-    }
-
-    if (Ssl::TheConfig.ssl_crt_validator) {
-        Ssl::CertValidationRequest validationRequest;
-        // WARNING: Currently we do not use any locking for any of the
-        // members of the Ssl::CertValidationRequest class. In this code the
-        // Ssl::CertValidationRequest object used only to pass data to
-        // Ssl::CertValidationHelper::submit method.
-        validationRequest.ssl = ssl;
-        validationRequest.domainName = request->GetHost();
-        if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
-            // validationRequest disappears on return so no need to cbdataReference
-            validationRequest.errors = errs;
-        else
-            validationRequest.errors = NULL;
-        try {
-            debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
-            Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, sslCrtvdHandleReplyWrapper, this);
-            return;
-        } catch (const std::exception &e) {
-            debugs(33, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
-                   "request for " << validationRequest.domainName <<
-                   " certificate: " << e.what() << "; will now block to " <<
-                   "validate that certificate.");
-            // fall through to do blocking in-process generation.
-            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request);
-            fail(anErr);
-            if (serverConnection()->getPeer()) {
-                peerConnectFailed(serverConnection()->getPeer());
-            }
-            serverConn->close();
-            self = NULL;
-            return;
-        }
-    }
-
-    dispatch();
-}
-
-void
-FwdState::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &validationResponse)
-{
-    FwdState * fwd = (FwdState *)(data);
-    fwd->sslCrtvdHandleReply(validationResponse);
-}
-
-void
-FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
-{
-    Ssl::CertErrors *errs = NULL;
-    Ssl::ErrorDetail *errDetails = NULL;
-    bool validatorFailed = false;
-    if (!Comm::IsConnOpen(serverConnection())) {
-        return;
-    }
-
-    debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
-
-    if (validationResponse.resultCode == HelperReply::Error)
-        errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
-    else if (validationResponse.resultCode != HelperReply::Okay)
-        validatorFailed = true;
-
-    if (!errDetails && !validatorFailed) {
-        dispatch();
-        return;
-    }
-
-    ErrorState *anErr = NULL;
-    if (validatorFailed) {
-        anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request);
-    }  else {
-
-        // Check the list error with
-        if (errDetails && request->clientConnectionManager.valid()) {
-            // remember the server certificate from the ErrorDetail object
-            if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
-                // remember validation errors, if any
-                if (errs) {
-                    if (serverBump->sslErrors)
-                        cbdataReferenceDone(serverBump->sslErrors);
-                    serverBump->sslErrors = cbdataReference(errs);
-                }
-            }
-        }
-
-        anErr = makeConnectingError(ERR_SECURE_CONNECT_FAIL);
-        anErr->detail = errDetails;
-        /*anErr->xerrno= Should preserved*/
-    }
-
-    fail(anErr);
-    if (serverConnection()->getPeer()) {
-        peerConnectFailed(serverConnection()->getPeer());
-    }
-    serverConn->close();
-    self = NULL;
-    return;
-}
-
-/// Checks errors in the cert. validator response against sslproxy_cert_error.
-/// The first honored error, if any, is returned via errDetails parameter.
-/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
-Ssl::CertErrors *
-FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
-{
-    Ssl::CertErrors *errs = NULL;
-
-    ACLFilledChecklist *check = NULL;
-    if (acl_access *acl = Config.ssl_client.cert_error)
-        check = new ACLFilledChecklist(acl, request, dash_str);
-
-    SSL *ssl = fd_table[serverConnection()->fd].ssl;
-    typedef Ssl::CertValidationResponse::RecvdErrors::const_iterator SVCRECI;
-    for (SVCRECI i = resp.errors.begin(); i != resp.errors.end(); ++i) {
-        debugs(83, 7, "Error item: " << i->error_no << " " << i->error_reason);
-
-        assert(i->error_no != SSL_ERROR_NONE);
-
-        if (!errDetails) {
-            bool allowed = false;
-            if (check) {
-                check->sslErrors = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
-                if (check->fastCheck() == ACCESS_ALLOWED)
-                    allowed = true;
-            }
-            // else the Config.ssl_client.cert_error access list is not defined
-            // and the first error will cause the error page
-
-            if (allowed) {
-                debugs(83, 3, "bypassing SSL error " << i->error_no << " in " << "buffer");
-            } else {
-                debugs(83, 5, "confirming SSL error " << i->error_no);
-                X509 *brokenCert = i->cert.get();
-                Ssl::X509_Pointer peerCert(SSL_get_peer_certificate(ssl));
-                const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
-                errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
-            }
-            if (check) {
-                delete check->sslErrors;
-                check->sslErrors = NULL;
-            }
-        }
-
-        if (!errs)
-            errs = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
-        else
-            errs->push_back_unique(Ssl::CertError(i->error_no, i->cert.get()));
-    }
-    if (check)
-        delete check;
-
-    return errs;
-}
-
-void
-FwdState::initiateSSL()
-{
-    SSL *ssl;
-    SSL_CTX *sslContext = NULL;
-    const CachePeer *peer = serverConnection()->getPeer();
-    int fd = serverConnection()->fd;
-
-    if (peer) {
-        assert(peer->use_ssl);
-        sslContext = peer->sslContext;
-    } else {
-        sslContext = Config.ssl_client.sslContext;
-    }
-
-    assert(sslContext);
-
-    if ((ssl = SSL_new(sslContext)) == NULL) {
-        debugs(83, DBG_IMPORTANT, "fwdInitiateSSL: Error allocating handle: " << ERR_error_string(ERR_get_error(), NULL)  );
-        ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request);
-        // TODO: create Ssl::ErrorDetail with OpenSSL-supplied error code
-        fail(anErr);
-        self = NULL;		// refcounted
-        return;
-    }
-
-    SSL_set_fd(ssl, fd);
-
-    if (peer) {
-        if (peer->ssldomain)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->ssldomain);
-
-#if NOT_YET
-
-        else if (peer->name)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->name);
-
-#endif
-
-        else
-            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->host);
-
-        if (peer->sslSession)
-            SSL_set_session(ssl, peer->sslSession);
-
-    } else {
-        // While we are peeking at the certificate, we may not know the server
-        // name that the client will request (after interception or CONNECT)
-        // unless it was the CONNECT request with a user-typed address.
-        const char *hostname = request->GetHost();
-        const bool hostnameIsIp = request->GetHostIsNumeric();
-        const bool isConnectRequest = request->clientConnectionManager.valid() &&
-                                      !request->clientConnectionManager->port->flags.isIntercepted();
-        if (!request->flags.sslPeek || isConnectRequest)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
-
-        // Use SNI TLS extension only when we connect directly
-        // to the origin server and we know the server host name.
-        if (!hostnameIsIp)
-            Ssl::setClientSNI(ssl, hostname);
-    }
-
-    // If CertValidation Helper used do not lookup checklist for errors,
-    // but keep a list of errors to send it to CertValidator
-    if (!Ssl::TheConfig.ssl_crt_validator) {
-        // Create the ACL check list now, while we have access to more info.
-        // The list is used in ssl_verify_cb() and is freed in ssl_free().
-        if (acl_access *acl = Config.ssl_client.cert_error) {
-            ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
-            SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
-        }
-    }
-
-    // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
-    X509 *peeked_cert;
-    if (request->clientConnectionManager.valid() &&
-            request->clientConnectionManager->serverBump() &&
-            (peeked_cert = request->clientConnectionManager->serverBump()->serverCert.get())) {
-        CRYPTO_add(&(peeked_cert->references),1,CRYPTO_LOCK_X509);
-        SSL_set_ex_data(ssl, ssl_ex_index_ssl_peeked_cert, peeked_cert);
-    }
-
-    fd_table[fd].ssl = ssl;
-    fd_table[fd].read_method = &ssl_read_method;
-    fd_table[fd].write_method = &ssl_write_method;
-    negotiateSSL(fd);
-}
-
-#endif
-
 void
 FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno)
 {
@@ -1035,9 +702,16 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
 #if USE_OPENSSL
     if (!request->flags.pinned) {
         if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
-                (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS) ||
+                (!serverConnection()->getPeer() && request->url.getScheme() == AnyP::PROTO_HTTPS) ||
                 request->flags.sslPeek) {
-            initiateSSL();
+
+            HttpRequest::Pointer requestPointer = request;
+            AsyncCall::Pointer callback = asyncCall(17,4,
+                "FwdState::ConnectedToPeer",
+                FwdStatePeerAnswerDialer(&FwdState::connectedToPeer, this));
+            Ssl::PeerConnector *connector =
+                new Ssl::PeerConnector(requestPointer, serverConnection(), callback);
+            AsyncJob::Start(connector); // will call our callback
             return;
         }
     }
@@ -1046,6 +720,21 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
     dispatch();
 }
 
+#if USE_OPENSSL
+void
+FwdState::connectedToPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    if (ErrorState *error = answer.error.get()) {
+        fail(error);
+        answer.error.clear(); // preserve error for errorSendComplete()
+        self = NULL;
+        return;
+    }
+
+    dispatch();
+}
+#endif
+
 void
 FwdState::connectTimeout(int fd)
 {
@@ -1151,7 +840,7 @@ FwdState::connectStart()
     // This does not increase the total number of connections because we just
     // closed the connection that failed the race. And re-pinning assumes this.
     if (pconnRace != raceHappened)
-        temp = fwdPconnPool->pop(serverDestinations[0], host, checkRetriable());
+        temp = pconnPop(serverDestinations[0], host);
 
     const bool openedPconn = Comm::IsConnOpen(temp);
     pconnRace = openedPconn ? racePossible : raceImpossible;
@@ -1191,18 +880,7 @@ FwdState::connectStart()
     entry->mem_obj->checkUrlChecksum();
 #endif
 
-    /* Get the server side TOS and Netfilter mark to be set on the connection. */
-    if (Ip::Qos::TheConfig.isAclTosActive()) {
-        serverDestinations[0]->tos = GetTosToServer(request);
-    }
-#if SO_MARK && USE_LIBCAP
-    serverDestinations[0]->nfmark = GetNfmarkToServer(request);
-    debugs(17, 3, "fwdConnectStart: got outgoing addr " << serverDestinations[0]->local << ", tos " << int(serverDestinations[0]->tos)
-           << ", netfilter mark " << serverDestinations[0]->nfmark);
-#else
-    serverDestinations[0]->nfmark = 0;
-    debugs(17, 3, "fwdConnectStart: got outgoing addr " << serverDestinations[0]->local << ", tos " << int(serverDestinations[0]->tos));
-#endif
+    GetMarkingsToServer(request, *serverDestinations[0]);
 
     calls.connector = commCbCall(17,3, "fwdConnectDoneWrapper", CommConnectCbPtrFun(fwdConnectDoneWrapper, this));
     Comm::ConnOpener *cs = new Comm::ConnOpener(serverDestinations[0], calls.connector, ctimeout);
@@ -1214,7 +892,7 @@ FwdState::connectStart()
 void
 FwdState::dispatch()
 {
-    debugs(17, 3, HERE << clientConn << ": Fetching '" << RequestMethodStr(request->method) << " " << entry->url() << "'");
+    debugs(17, 3, clientConn << ": Fetching " << request->method << ' ' << entry->url());
     /*
      * Assert that server_fd is set.  This is to guarantee that fwdState
      * is attached to something and will be deallocated when server_fd
@@ -1224,7 +902,7 @@ FwdState::dispatch()
 
     fd_note(serverConnection()->fd, entry->url());
 
-    fd_table[serverConnection()->fd].noteUse(fwdPconnPool);
+    fd_table[serverConnection()->fd].noteUse();
 
     /*assert(!EBIT_TEST(entry->flags, ENTRY_DISPATCHED)); */
     assert(entry->ping_status != PING_WAITING);
@@ -1278,7 +956,7 @@ FwdState::dispatch()
         request->peer_login = NULL;
         request->peer_domain = NULL;
 
-        switch (request->protocol) {
+        switch (request->url.getScheme()) {
 #if USE_OPENSSL
 
         case AnyP::PROTO_HTTPS:
@@ -1300,8 +978,6 @@ FwdState::dispatch()
 
         case AnyP::PROTO_CACHE_OBJECT:
 
-        case AnyP::PROTO_INTERNAL:
-
         case AnyP::PROTO_URN:
             fatal_dump("Should never get here");
             break;
@@ -1459,6 +1135,22 @@ FwdState::pconnPush(Comm::ConnectionPointer &conn, const char *domain)
     }
 }
 
+Comm::ConnectionPointer
+FwdState::pconnPop(const Comm::ConnectionPointer &dest, const char *domain)
+{
+    // always call shared pool first because we need to close an idle
+    // connection there if we have to use a standby connection.
+    Comm::ConnectionPointer conn = fwdPconnPool->pop(dest, domain, checkRetriable());
+    if (!Comm::IsConnOpen(conn)) {
+        // either there was no pconn to pop or this is not a retriable xaction
+        if (CachePeer *peer = dest->getPeer()) {
+            if (peer->standby.pool)
+                conn = peer->standby.pool->pop(dest, domain, true);
+        }
+    }
+    return conn; // open, closed, or nil
+}
+
 void
 FwdState::initModule()
 {
@@ -1584,3 +1276,20 @@ GetNfmarkToServer(HttpRequest * request)
     ACLFilledChecklist ch(NULL, request, NULL);
     return aclMapNfmark(Ip::Qos::TheConfig.nfmarkToServer, &ch);
 }
+
+void
+GetMarkingsToServer(HttpRequest * request, Comm::Connection &conn)
+{
+    // Get the server side TOS and Netfilter mark to be set on the connection.
+    if (Ip::Qos::TheConfig.isAclTosActive()) {
+        conn.tos = GetTosToServer(request);
+        debugs(17, 3, "from " << conn.local << " tos " << int(conn.tos));
+    }
+
+#if SO_MARK && USE_LIBCAP
+    conn.nfmark = GetNfmarkToServer(request);
+    debugs(17, 3, "from " << conn.local << " netfilter mark " << conn.nfmark);
+#else
+    conn.nfmark = 0;
+#endif
+}
@@ -16,6 +16,8 @@
 
 class AccessLogEntry;
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
+class PconnPool;
+typedef RefCount<PconnPool> PconnPoolPointer;
 class ErrorState;
 class HttpRequest;
 
@@ -24,6 +26,7 @@ namespace Ssl
 {
 class ErrorDetail;
 class CertValidationResponse;
+class PeerConnectorAnswer;
 };
 #endif
 
@@ -39,6 +42,9 @@ tos_t GetTosToServer(HttpRequest * request);
  */
 nfmark_t GetNfmarkToServer(HttpRequest * request);
 
+/// Sets initial TOS value and Netfilter for the future outgoing connection.
+void GetMarkingsToServer(HttpRequest * request, Comm::Connection &conn);
+
 class HelperReply;
 
 class FwdState : public RefCountable
@@ -69,11 +75,12 @@ class FwdState : public RefCountable
     void connectStart();
     void connectDone(const Comm::ConnectionPointer & conn, comm_err_t status, int xerrno);
     void connectTimeout(int fd);
-    void initiateSSL();
-    void negotiateSSL(int fd);
     bool checkRetry();
     bool checkRetriable();
     void dispatch();
+    /// Pops a connection from connection pool if available. If not
+    /// checks the peer stand-by connection pool for available connection.
+    Comm::ConnectionPointer pconnPop(const Comm::ConnectionPointer &dest, const char *domain);
     void pconnPush(Comm::ConnectionPointer & conn, const char *domain);
 
     bool dontRetry() { return flags.dont_retry; }
@@ -83,14 +90,6 @@ class FwdState : public RefCountable
     /** return a ConnectionPointer to the current server connection (may or may not be open) */
     Comm::ConnectionPointer const & serverConnection() const { return serverConn; };
 
-#if USE_OPENSSL
-    /// Callback function called when squid receive message from cert validator helper
-    static void sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &);
-    /// Process response from cert validator helper
-    void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
-    /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
-    Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
-#endif
 private:
     // hidden for safer management of self; use static fwdStart
     FwdState(const Comm::ConnectionPointer &client, StoreEntry *, HttpRequest *, const AccessLogEntryPointer &alp);
@@ -104,8 +103,14 @@ class FwdState : public RefCountable
     void completed();
     void retryOrBail();
     ErrorState *makeConnectingError(const err_type type) const;
+#if USE_OPENSSL
+    void connectedToPeer(Ssl::PeerConnectorAnswer &answer);
+#endif
     static void RegisterWithCacheManager(void);
 
+    /// stops monitoring server connection for closure and updates pconn stats
+    void closeServerConnection(const char *reason);
+
 public:
     StoreEntry *entry;
     HttpRequest *request;
@@ -41,7 +41,7 @@
 #include "SquidConfig.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
-        cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
+        cache_control(NULL), hdr_sz(0), content_length(0),
         pstate(psReadyToParseStartLine)
 {}
 
@@ -67,7 +67,8 @@ class HttpMsg : public RefCountable
     bool persistent() const;
 
 public:
-    /// transport protocol version for this message
+    /// HTTP-Version field in the first line of the message.
+    /// see draft-ietf-httpbis-p1-messaging-26 section 3.1
     Http::ProtocolVersion http_ver;
 
     HttpHeader header;
@@ -81,9 +82,6 @@ class HttpMsg : public RefCountable
 
     int64_t content_length;
 
-    /// URL scheme protocol (if relevant)
-    AnyP::ProtocolType protocol;
-
     HttpMsgParseState pstate;   /* the current parsing state */
 
     BodyPipe::Pointer body_pipe; // optional pipeline to receive message body
@@ -604,7 +604,6 @@ HttpReply::clone() const
     rep->pstate = pstate;
     rep->body_pipe = body_pipe;
 
-    rep->protocol = protocol;
     // keep_alive is handled in hdrCacheInit()
     return rep;
 }
@@ -83,15 +83,15 @@ void
 HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
 {
     method = aMethod;
-    protocol = aProtocol;
+    url.setScheme(aProtocol);
     urlpath = aUrlpath;
 }
 
 void
 HttpRequest::init()
 {
     method = Http::METHOD_NONE;
-    protocol = AnyP::PROTO_NONE;
+    url.clear();
     urlpath = NULL;
     login[0] = '\0';
     host[0] = '\0';
@@ -151,6 +151,7 @@ HttpRequest::clean()
 
     safe_free(vary_headers);
 
+    url.clear();
     urlpath.clean();
 
     header.clean();
@@ -198,7 +199,7 @@ HttpRequest::reset()
 HttpRequest *
 HttpRequest::clone() const
 {
-    HttpRequest *copy = new HttpRequest(method, protocol, urlpath.termedBuf());
+    HttpRequest *copy = new HttpRequest(method, url.getScheme(), urlpath.termedBuf());
     // TODO: move common cloning clone to Msg::copyTo() or copy ctor
     copy->header.append(&header);
     copy->hdrCacheInit();
@@ -390,8 +391,8 @@ HttpRequest::pack(Packer * p)
 {
     assert(p);
     /* pack request-line */
-    packerPrintf(p, "%s " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
-                 RequestMethodStr(method), SQUIDSTRINGPRINT(urlpath),
+    packerPrintf(p, SQUIDSBUFPH " " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
+                 SQUIDSBUFPRINT(method.image()), SQUIDSTRINGPRINT(urlpath),
                  http_ver.major, http_ver.minor);
     /* headers */
     header.packInto(p);
@@ -413,7 +414,7 @@ httpRequestPack(void *obj, Packer *p)
 int
 HttpRequest::prefixLen()
 {
-    return strlen(RequestMethodStr(method)) + 1 +
+    return method.image().length() + 1 +
            urlpath.size() + 1 +
            4 + 1 + 3 + 2 +
            header.len + 2;
@@ -523,8 +524,8 @@ const char *HttpRequest::packableURI(bool full_uri) const
 void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const
 {
     // form HTTP request-line
-    packerPrintf(p, "%s %s HTTP/%d.%d\r\n",
-                 RequestMethodStr(method),
+    packerPrintf(p, SQUIDSBUFPH " %s HTTP/%d.%d\r\n",
+                 SQUIDSBUFPRINT(method.image()),
                  packableURI(full_uri),
                  http_ver.major, http_ver.minor);
 }
@@ -593,7 +594,7 @@ HttpRequest::maybeCacheable()
     if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))
         return false;
 
-    switch (protocol) {
+    switch (url.getScheme()) {
     case AnyP::PROTO_HTTP:
     case AnyP::PROTO_HTTPS:
         if (!method.respMaybeCacheable())
@@ -39,6 +39,7 @@
 #include "http/RequestMethod.h"
 #include "Notes.h"
 #include "RequestFlags.h"
+#include "URL.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -136,6 +137,9 @@ class HttpRequest: public HttpMsg
 public:
     HttpRequestMethod method;
 
+    // TODO expand to include all URI parts
+    URL url; ///< the request URI (scheme only)
+
     char login[MAX_LOGIN_SZ];
 
 private:
@@ -173,7 +173,7 @@ WIN32_SOURCE =
 WINSVC_SOURCE =
 endif
 
-if USE_IPC_WIN32
+if ENABLE_WIN32_IPC
 IPC_SOURCE = SquidIpc.h ipc_win32.cc
 else
 IPC_SOURCE = SquidIpc.h ipc.cc
@@ -182,13 +182,13 @@ endif
 AIO_WIN32_ALL_SOURCES = \
 	DiskIO/AIO/aio_win32.cc \
 	DiskIO/AIO/aio_win32.h
-if USE_AIO_WIN32
+if ENABLE_WIN32_AIO
 AIO_WIN32_SOURCES = $(AIO_WIN32_ALL_SOURCES)
 else
 AIO_WIN32_SOURCES =
 endif
 
-if USE_AIOPS_WIN32
+if ENABLE_WIN32_AIOPS
 AIOPS_SOURCE = DiskIO/DiskThreads/aiops_win32.cc \
 	DiskIO/DiskThreads/CommIO.cc \
 	DiskIO/DiskThreads/CommIO.h
@@ -468,6 +468,8 @@ squid_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	PeerSelectState.h \
 	PingData.h \
 	protos.h \
@@ -1511,6 +1513,8 @@ tests_testCacheManager_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
@@ -1736,6 +1740,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_stat.cc \
@@ -1889,6 +1894,8 @@ tests_testEvent_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2134,6 +2141,8 @@ tests_testEventLoop_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2375,6 +2384,8 @@ tests_test_http_range_SOURCES = \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2712,6 +2723,8 @@ tests_testHttpRequest_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	redirect.h \
 	tests/stub_libauth_acls.cc \
 	tests/stub_redirect.cc \
@@ -3061,6 +3074,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_libeui.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
@@ -3351,6 +3365,7 @@ tests_testRock_SOURCES = \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_Port.cc \
 	tests/stub_pconn.cc \
 	tests/stub_store_client.cc \
@@ -3489,6 +3504,8 @@ tests_testURL_SOURCES = \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -3779,6 +3796,9 @@ tests_testStatHist_SOURCES = \
 	fatal.h \
 	tests/stub_fatal.cc \
 	tests/stub_MemBuf.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	StatHist.cc \
 	StatHist.h \
 	String.cc \
@@ -3797,6 +3817,7 @@ tests_testStatHist_SOURCES = \
 	repl_modules.h \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
+	time.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/testMain.cc \
@@ -95,7 +95,7 @@ MemBlob::~MemBlob()
         memFreeString(capacity,mem);
     Stats.liveBytes -= capacity;
     --Stats.live;
-    recordMemBlobSizeAtDestruct(size);
+    recordMemBlobSizeAtDestruct(capacity);
 
     debugs(MEMBLOB_DEBUGSECTION,9, HERE << "destructed, this="
            << static_cast<void*>(this) << " id=" << id
@@ -137,6 +137,7 @@ MemBuf::init(mb_size_t szInit, mb_size_t szMax)
     capacity = 0;
     stolen = 0;
     grow(szInit);
+    terminate();
 }
 
 /**
@@ -243,8 +243,7 @@ struct StoreClientStats : public unary_function<store_client, void> {
 void
 MemObject::stat(MemBuf * mb) const
 {
-    mb->Printf("\t%s %s\n",
-               RequestMethodStr(method), logUri());
+    mb->Printf("\t" SQUIDSBUFPH " %s\n", SQUIDSBUFPRINT(method.image()), logUri());
     if (vary_headers)
         mb->Printf("\tvary_headers: %s\n", vary_headers);
     mb->Printf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
@@ -158,15 +158,15 @@ NotePairs::~NotePairs()
 }
 
 const char *
-NotePairs::find(const char *noteKey) const
+NotePairs::find(const char *noteKey, const char *sep) const
 {
     static String value;
     value.clean();
     for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0) {
             if (value.size())
-                value.append(", ");
-            value.append(ConfigParser::QuoteString((*i)->value));
+                value.append(sep);
+            value.append((*i)->value);
         }
     }
     return value.size() ? value.termedBuf() : NULL;
@@ -180,7 +180,7 @@ NotePairs::toString(const char *sep) const
     for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         value.append((*i)->name);
         value.append(": ");
-        value.append(ConfigParser::QuoteString((*i)->value));
+        value.append((*i)->value);
         value.append(sep);
     }
     return value.size() ? value.termedBuf() : NULL;
@@ -145,7 +145,7 @@ class NotePairs: public RefCountable
      * Returns a comma separated list of notes with key 'noteKey'.
      * Use findFirst instead when a unique kv-pair is needed.
      */
-    const char *find(const char *noteKey) const;
+    const char *find(const char *noteKey, const char *sep = ",") const;
 
     /**
      * Returns the first note value for this key or an empty string.
@@ -0,0 +1,283 @@
+#include "squid.h"
+#include "base/AsyncJobCalls.h"
+#include "base/RunnersRegistry.h"
+#include "CachePeer.h"
+#include "comm/Connection.h"
+#include "comm/ConnOpener.h"
+#include "Debug.h"
+#include "fd.h"
+#include "FwdState.h"
+#include "globals.h"
+#include "HttpRequest.h"
+#include "neighbors.h"
+#include "pconn.h"
+#include "PeerPoolMgr.h"
+#include "SquidConfig.h"
+#if USE_OPENSSL
+#include "ssl/PeerConnector.h"
+#endif
+
+CBDATA_CLASS_INIT(PeerPoolMgr);
+
+#if USE_OPENSSL
+/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+class MyAnswerDialer: public UnaryMemFunT<PeerPoolMgr, Ssl::PeerConnectorAnswer, Ssl::PeerConnectorAnswer&>,
+        public Ssl::PeerConnector::CbDialer
+{
+public:
+    MyAnswerDialer(const JobPointer &aJob, Method aMethod):
+                   UnaryMemFunT<PeerPoolMgr, Ssl::PeerConnectorAnswer, Ssl::PeerConnectorAnswer&>(aJob, aMethod, Ssl::PeerConnectorAnswer()) {}
+
+    /* Ssl::PeerConnector::CbDialer API */
+    virtual Ssl::PeerConnectorAnswer &answer() { return arg1; }
+};
+#endif
+
+PeerPoolMgr::PeerPoolMgr(CachePeer *aPeer): AsyncJob("PeerPoolMgr"),
+        peer(cbdataReference(aPeer)),
+        request(),
+        opener(),
+        securer(),
+        closer(),
+        addrUsed(0)
+{
+}
+
+PeerPoolMgr::~PeerPoolMgr()
+{
+    cbdataReferenceDone(peer);
+}
+
+void
+PeerPoolMgr::start()
+{
+    AsyncJob::start();
+
+    // ErrorState, getOutgoingAddress(), and other APIs may require a request.
+    // We fake one. TODO: Optionally send this request to peers?
+    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, "*");
+    request->SetHost(peer->host);
+
+    checkpoint("peer initialized");
+}
+
+void
+PeerPoolMgr::swanSong()
+{
+    AsyncJob::swanSong();
+}
+
+bool
+PeerPoolMgr::validPeer() const {
+    return peer && cbdataReferenceValid(peer) && peer->standby.pool;
+}
+
+bool
+PeerPoolMgr::doneAll() const
+{
+    return !(validPeer() && peer->standby.limit) && AsyncJob::doneAll();
+}
+
+void
+PeerPoolMgr::handleOpenedConnection(const CommConnectCbParams &params)
+{
+    opener = NULL;
+
+    if (!validPeer()) {
+        debugs(48, 3, "peer gone");
+        if (params.conn != NULL)
+            params.conn->close();
+        return;
+    }
+
+    if (params.flag != COMM_OK) {
+        /* it might have been a timeout with a partially open link */
+        if (params.conn != NULL)
+            params.conn->close();
+        peerConnectFailed(peer);
+        checkpoint("conn opening failure"); // may retry
+        return;
+    }
+
+    Must(params.conn != NULL);
+
+#if USE_OPENSSL
+    // Handle SSL peers.
+    if (peer->use_ssl) {
+        typedef CommCbMemFunT<PeerPoolMgr, CommCloseCbParams> CloserDialer;
+        closer = JobCallback(48, 3, CloserDialer, this,
+                             PeerPoolMgr::handleSecureClosure);
+        comm_add_close_handler(params.conn->fd, closer);
+
+        securer = asyncCall(48, 4, "PeerPoolMgr::handleSecuredPeer",
+                            MyAnswerDialer(this, &PeerPoolMgr::handleSecuredPeer));
+        Ssl::PeerConnector *connector =
+            new Ssl::PeerConnector(request, params.conn, securer);
+        AsyncJob::Start(connector); // will call our callback
+        return;
+    }
+#endif
+
+    pushNewConnection(params.conn);
+}
+
+void
+PeerPoolMgr::pushNewConnection(const Comm::ConnectionPointer &conn)
+{
+    Must(validPeer());
+    Must(Comm::IsConnOpen(conn));
+    peer->standby.pool->push(conn, NULL /* domain */);
+    // push() will trigger a checkpoint()
+}
+
+#if USE_OPENSSL
+void
+PeerPoolMgr::handleSecuredPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    Must(securer != NULL);
+    securer = NULL;
+
+    if (closer != NULL) {
+        if (answer.conn != NULL)
+            comm_remove_close_handler(answer.conn->fd, closer);
+        else
+            closer->cancel("securing completed");
+        closer = NULL;
+    }
+
+    if (!validPeer()) {
+        debugs(48, 3, "peer gone");
+        if (answer.conn != NULL)
+            answer.conn->close();
+        return;
+    }
+
+    if (answer.error.get()) {
+        if (answer.conn != NULL)
+            answer.conn->close();
+        // PeerConnector calls peerConnectFailed() for us;
+        checkpoint("conn securing failure"); // may retry
+        return;
+    }
+
+    pushNewConnection(answer.conn);
+}
+
+void
+PeerPoolMgr::handleSecureClosure(const CommCloseCbParams &params)
+{
+    Must(closer != NULL);
+    Must(securer != NULL);
+    securer->cancel("conn closed by a 3rd party");
+    securer = NULL;
+    closer = NULL;
+    // allow the closing connection to fully close before we check again
+    Checkpoint(this, "conn closure while securing");
+}
+#endif
+
+void
+PeerPoolMgr::openNewConnection()
+{
+    // KISS: Do nothing else when we are already doing something.
+    if (opener != NULL || securer != NULL || shutting_down) {
+        debugs(48, 7, "busy: " << opener << '|' << securer << '|' << shutting_down);
+        return; // there will be another checkpoint when we are done opening/securing
+    }
+
+    // Do not talk to a peer until it is ready.
+    if (!neighborUp(peer)) // provides debugging
+        return; // there will be another checkpoint when peer is up
+
+    // Do not violate peer limits.
+    if (!peerCanOpenMore(peer)) { // provides debugging
+        peer->standby.waitingForClose = true; // may already be true
+        return; // there will be another checkpoint when a peer conn closes
+    }
+
+    // Do not violate global restrictions.
+    if (fdUsageHigh()) {
+        debugs(48, 7, "overwhelmed");
+        peer->standby.waitingForClose = true; // may already be true
+        // There will be another checkpoint when a peer conn closes OR when
+        // a future pop() fails due to an empty pool. See PconnPool::pop().
+        return;
+    }
+
+    peer->standby.waitingForClose = false;
+
+    Comm::ConnectionPointer conn = new Comm::Connection;
+    Must(peer->n_addresses); // guaranteed by neighborUp() above
+    // cycle through all available IP addresses
+    conn->remote = peer->addresses[addrUsed++ % peer->n_addresses];
+    conn->remote.port(peer->http_port);
+    conn->peerType = STANDBY_POOL; // should be reset by peerSelect()
+    conn->setPeer(peer);
+    getOutgoingAddress(request.getRaw(), conn);
+    GetMarkingsToServer(request.getRaw(), *conn);
+
+    const int ctimeout = peer->connect_timeout > 0 ?
+                         peer->connect_timeout : Config.Timeout.peer_connect;
+    typedef CommCbMemFunT<PeerPoolMgr, CommConnectCbParams> Dialer;
+    opener = JobCallback(48, 5, Dialer, this, PeerPoolMgr::handleOpenedConnection);
+    Comm::ConnOpener *cs = new Comm::ConnOpener(conn, opener, ctimeout);
+    AsyncJob::Start(cs);
+}
+
+void
+PeerPoolMgr::closeOldConnections(const int howMany)
+{
+    debugs(48, 8, howMany);
+    peer->standby.pool->closeN(howMany);
+}
+
+void
+PeerPoolMgr::checkpoint(const char *reason)
+{
+    if (!validPeer()) {
+        debugs(48, 3, reason << " and peer gone");
+        return; // nothing to do after our owner dies; the job will quit
+    }
+
+    const int count = peer->standby.pool->count();
+    const int limit = peer->standby.limit;
+    debugs(48, 7, reason << " with " << count << " ? " << limit);
+
+    if (count < limit)
+        openNewConnection();
+    else if (count > limit)
+        closeOldConnections(count - limit);
+}
+
+void
+PeerPoolMgr::Checkpoint(const Pointer &mgr, const char *reason)
+{
+    CallJobHere1(48, 5, mgr, PeerPoolMgr, checkpoint, reason);
+}
+
+/// launches PeerPoolMgrs for peers configured with standby.limit
+class PeerPoolMgrsRr: public RegisteredRunner
+{
+public:
+    /* RegisteredRunner API */
+    virtual void useConfig() { syncConfig(); }
+    virtual void syncConfig();
+};
+
+RunnerRegistrationEntry(PeerPoolMgrsRr);
+
+void
+PeerPoolMgrsRr::syncConfig()
+{
+    for (CachePeer *p = Config.peers; p; p = p->next) {
+        // On reconfigure, Squid deletes the old config (and old peers in it),
+        // so should always be dealing with a brand new configuration.
+        assert(!p->standby.mgr);
+        assert(!p->standby.pool);
+        if (p->standby.limit) {
+            p->standby.mgr = new PeerPoolMgr(p);
+            p->standby.pool = new PconnPool(p->name, p->standby.mgr);
+            AsyncJob::Start(p->standby.mgr.get());
+        }
+    }
+}
@@ -0,0 +1,68 @@
+#ifndef SQUID_PEERPOOLMGR_H
+#define SQUID_PEERPOOLMGR_H
+
+#include "base/AsyncJob.h"
+#include "comm/forward.h"
+
+class HttpRequest;
+class CachePeer;
+class CommConnectCbParams;
+
+#if USE_OPENSSL
+namespace Ssl {
+    class PeerConnectorAnswer;
+}
+#endif
+
+/// Maintains an fixed-size "standby" PconnPool for a single CachePeer.
+class PeerPoolMgr: public AsyncJob
+{
+public:
+    typedef CbcPointer<PeerPoolMgr> Pointer;
+
+    // syncs mgr state whenever connection-related peer or pool state changes
+    static void Checkpoint(const Pointer &mgr, const char *reason);
+
+    explicit PeerPoolMgr(CachePeer *aPeer);
+    virtual ~PeerPoolMgr();
+
+protected:
+    /* AsyncJob API */
+    virtual void start();
+    virtual void swanSong();
+    virtual bool doneAll() const;
+
+    /// whether the peer is still out there and in a valid state we can safely use
+    bool validPeer() const;
+
+    /// Starts new connection, or closes the excess connections
+    /// according pool configuration
+    void checkpoint(const char *reason);
+    /// starts the process of opening a new standby connection (if possible)
+    void openNewConnection();
+    /// closes 'howMany' standby connections
+    void closeOldConnections(const int howMany);
+
+    /// Comm::ConnOpener calls this when done opening a connection for us
+    void handleOpenedConnection(const CommConnectCbParams &params);
+#if USE_OPENSSL
+    /// Ssl::PeerConnector callback
+    void handleSecuredPeer(Ssl::PeerConnectorAnswer &answer);
+    /// called when the connection we are trying to secure is closed by a 3rd party
+    void handleSecureClosure(const CommCloseCbParams &params);
+#endif
+    /// the final step in connection opening (and, optionally, securing) sequence
+    void pushNewConnection(const Comm::ConnectionPointer &conn);
+
+private:
+    CachePeer *peer; ///< the owner of the pool we manage
+    RefCount<HttpRequest> request; ///< fake HTTP request for conn opening code
+    AsyncCall::Pointer opener; ///< whether we are opening a connection
+    AsyncCall::Pointer securer; ///< whether we are securing a connection
+    AsyncCall::Pointer closer; ///< monitors conn while we are securing it
+    unsigned int addrUsed; ///< counter for cycling through peer addresses
+
+    CBDATA_CLASS2(PeerPoolMgr);
+};
+
+#endif /* SQUID_PEERPOOLMGR_H */
@@ -59,7 +59,7 @@ SBufStats::SBufStats()
         : alloc(0), allocCopy(0), allocFromString(0), allocFromCString(0),
         assignFast(0), clear(0), append(0), toStream(0), setChar(0),
         getChar(0), compareSlow(0), compareFast(0), copyOut(0),
-        rawAccess(0), chop(0), trim(0), find(0), scanf(0),
+        rawAccess(0), nulTerminate(0), chop(0), trim(0), find(0), scanf(0),
         caseChange(0), cowFast(0), cowSlow(0), live(0)
 {}
 
@@ -80,6 +80,7 @@ SBufStats::operator +=(const SBufStats& ss)
     compareFast += ss.compareFast;
     copyOut += ss.copyOut;
     rawAccess += ss.rawAccess;
+    nulTerminate += ss.nulTerminate;
     chop += ss.chop;
     trim += ss.trim;
     find += ss.find;
@@ -376,12 +377,12 @@ memcasecmp(const char *b1, const char *b2, SBuf::size_type len)
 }
 
 int
-SBuf::compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n) const
+SBuf::compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n) const
 {
     if (n != npos)
         return substr(0,n).compare(S.substr(0,n),isCaseSensitive);
 
-    size_type byteCompareLen = min(S.length(), length());
+    const size_type byteCompareLen = min(S.length(), length());
     ++stats.compareSlow;
     int rv = 0;
     if (isCaseSensitive == caseSensitive) {
@@ -398,8 +399,61 @@ SBuf::compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n) con
     return -1;
 }
 
+int
+SBuf::compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n) const
+{
+    // 0-length comparison is always true regardless of buffer states
+    if (!n) {
+        ++stats.compareFast;
+        return 0;
+    }
+
+    // N-length compare MUST provide a non-NULL C-string pointer
+    assert(s);
+
+    // when this is a 0-length string, no need for any complexity.
+    if (!length()) {
+        ++stats.compareFast;
+        return '\0' - *s;
+    }
+
+    // brute-force scan in order to avoid ever needing strlen() on a c-string.
+    ++stats.compareSlow;
+    const char *left = buf();
+    const char *right = s;
+    int rv = 0;
+    // what area to scan.
+    // n may be npos, but we treat that as a huge positive value
+    size_type byteCount = min(length(), n);
+
+    // loop until we find a difference, a '\0', or reach the end of area to scan
+    if (isCaseSensitive == caseSensitive) {
+        while ((rv = *left - *right++) == 0) {
+            if (*left++ == '\0' || --byteCount == 0)
+                break;
+        }
+    } else {
+        while ((rv = tolower(*left) - tolower(*right++)) == 0) {
+            if (*left++ == '\0' || --byteCount == 0)
+                break;
+        }
+    }
+
+    // If we stopped scanning because we reached the end
+    //  of buf() before we reached the end of s,
+    // pretend we have a 0-terminator there to compare.
+    // NP: the loop already incremented "right" ready for this comparison
+    if (!byteCount && length() < n)
+        return '\0' - *right;
+
+    // If we found a difference within the scan area,
+    // or we found a '\0',
+    // or all n characters were identical (and none was \0).
+    return rv;
+}
+
 bool
-SBuf::startsWith(const SBuf &S, SBufCaseSensitive isCaseSensitive) const
+SBuf::startsWith(const SBuf &S, const SBufCaseSensitive isCaseSensitive) const
 {
     debugs(24, 8, id << " startsWith " << S.id << ", caseSensitive: " <<
            isCaseSensitive);
@@ -491,6 +545,7 @@ SBuf::c_str()
     *rawSpace(1) = '\0';
     ++store_->size;
     ++stats.setChar;
+    ++stats.nulTerminate;
     return buf();
 }
 
@@ -764,6 +819,7 @@ SBufStats::dump(std::ostream& os) const
     "\ncomparisons not requiring data-scan: " << compareFast <<
     "\ncopy-out ops: " << copyOut <<
     "\nraw access to memory: " << rawAccess <<
+    "\nNULL terminate C string: " << nulTerminate <<
     "\nchop operations: " << chop <<
     "\ntrim operations: " << trim <<
     "\nfind: " << find <<
@@ -77,6 +77,7 @@ class SBufStats
     uint64_t compareFast; ///<number of comparison operations not requiring data scan
     uint64_t copyOut; ///<number of data-copies to other forms of buffers
     uint64_t rawAccess; ///<number of accesses to raw contents
+    uint64_t nulTerminate; ///<number of c_str() terminations
     uint64_t chop;  ///<number of chop operations
     uint64_t trim;  ///<number of trim operations
     uint64_t find;  ///<number of find operations
@@ -254,15 +255,28 @@ class SBuf
      * \retval <0 argument of the call is smaller than called SBuf
      * \retval 0  argument of the call has the same contents of called SBuf
      */
-    int compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n = npos) const;
+    int compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n = npos) const;
 
-    /// shorthand version for compare
-    inline int cmp(const SBuf &S, size_type n = npos) const {
+    /// shorthand version for compare()
+    inline int cmp(const SBuf &S, const size_type n = npos) const {
         return compare(S,caseSensitive,n);
     }
 
-    /// shorthand version for case-insensitive comparison
-    inline int caseCmp(const SBuf &S, size_type n = npos) const {
+    /// shorthand version for case-insensitive compare()
+    inline int caseCmp(const SBuf &S, const size_type n = npos) const {
+        return compare(S,caseInsensitive,n);
+    }
+
+    /// Comparison with a C-string.
+    int compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n = npos) const;
+
+    /// Shorthand version for C-string compare().
+    inline int cmp(const char *S, const size_type n = npos) const {
+        return compare(S,caseSensitive,n);
+    }
+
+    /// Shorthand version for case-insensitive C-string compare().
+    inline int caseCmp(const char *S, const size_type n = npos) const {
         return compare(S,caseInsensitive,n);
     }
 
@@ -271,7 +285,7 @@ class SBuf
      *  \param isCaseSensitive one of caseSensitive or caseInsensitive
      *  \retval true argument is a prefix of the SBuf
      */
-    bool startsWith(const SBuf &S, SBufCaseSensitive isCaseSensitive = caseSensitive) const;
+    bool startsWith(const SBuf &S, const SBufCaseSensitive isCaseSensitive = caseSensitive) const;
 
     bool operator ==(const SBuf & S) const;
     bool operator !=(const SBuf & S) const;
@@ -15,8 +15,8 @@ namespace SBufDetailedStatsHistInitializer
 // run the post-instantiation initialization methods for StatHist objects
 struct Initializer {
     Initializer() {
-        sbufDestructTimeStats.logInit(300,30.0,128000.0);
-        memblobDestructTimeStats.logInit(300,30.0,128000.0);
+        sbufDestructTimeStats.logInit(100,30.0,128000.0);
+        memblobDestructTimeStats.logInit(100,30.0,128000.0);
     }
 };
 Initializer initializer;
@@ -62,6 +62,14 @@ SBufStatsAction::collect()
     mbsizesatdestruct = *collectMemBlobDestructTimeStats();
 }
 
+static void
+statHistSBufDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+{
+    if (count == 0)
+        return;
+    storeAppendPrintf(sentry, "\t%d-%d\t%d\n", static_cast<int>(val), static_cast<int>(val+size), count);
+}
+
 void
 SBufStatsAction::dump(StoreEntry* entry)
 {
@@ -73,9 +81,9 @@ SBufStatsAction::dump(StoreEntry* entry)
     mbdata.dump(ses);
     ses << "\n";
     ses << "SBuf size distribution at destruct time:\n";
-    sbsizesatdestruct.dump(entry,NULL);
-    ses << "MemBlob size distribution at destruct time:\n";
-    mbsizesatdestruct.dump(entry,NULL);
+    sbsizesatdestruct.dump(entry,statHistSBufDumper);
+    ses << "MemBlob capacity distribution at destruct time:\n";
+    mbsizesatdestruct.dump(entry,statHistSBufDumper);
 }
 
 void
@@ -517,7 +517,7 @@ ServerStateData::maybePurgeOthers()
 
     // XXX: should we use originalRequest() here?
     const char *reqUrl = urlCanonical(request);
-    debugs(88, 5, "maybe purging due to " << RequestMethodStr(request->method) << ' ' << reqUrl);
+    debugs(88, 5, "maybe purging due to " << request->method << ' ' << reqUrl);
     purgeEntriesByUrl(request, reqUrl);
     purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
     purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
@@ -398,6 +398,8 @@ class SquidConfig
         /// spoof_client_ip squid.conf acl.
         /// nil unless configured
         acl_access* spoof_client_ip;
+
+        acl_access *ftp_epsv;
     } accessList;
     AclDenyInfoList *denyInfoList;
 
@@ -45,8 +45,16 @@ class URL
     MEMPROXY_CLASS(URL);
     URL() : scheme_() {}
     URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme) {}
+
+    void clear() {
+        scheme_=AnyP::PROTO_NONE;
+    }
+
     AnyP::UriScheme const & getScheme() const {return scheme_;}
 
+    /// convert the URL scheme to that given
+    void setScheme(const AnyP::ProtocolType &p) {scheme_=p;}
+
 private:
     /**
      \par
@@ -68,7 +76,7 @@ class URL
      * In order to make taking any of these routes easy, scheme is private
      * and immutable, only settable at construction time,
      */
-    AnyP::UriScheme const scheme_;
+    AnyP::UriScheme scheme_;
 };
 
 MEMPROXY_CLASS_INLINE(URL);
@@ -38,6 +38,7 @@
 #include "defines.h"
 #include "dlink.h"
 #include "MemPool.h"
+#include "SBufList.h"
 
 #include <ostream>
 #include <string>
@@ -121,7 +122,7 @@ class ACL
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
-    virtual wordlist *dump() const = 0;
+    virtual SBufList dump() const = 0;
     virtual bool empty() const = 0;
     virtual bool valid() const;
 
@@ -9,7 +9,6 @@
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
-#include "wordlist.h"
 
 void
 ACLAdaptationServiceData::parse()
@@ -17,10 +17,10 @@ Acl::AllOf::clone() const
     return new AllOf;
 }
 
-wordlist*
+SBufList
 Acl::AllOf::dump() const
 {
-    return empty() ? NULL : nodes.front()->dump();
+    return empty() ? SBufList() : nodes.front()->dump();
 }
 
 int
@@ -18,7 +18,7 @@ class AllOf: public Acl::InnerNode
     virtual char const *typeString() const;
     virtual ACL *clone() const;
     virtual void parse();
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
 
 private:
     /* Acl::InnerNode API */
@@ -41,8 +41,8 @@
 #include "cache_cf.h"
 #include "Debug.h"
 #include "eui/Eui48.h"
+#include "globals.h"
 #include "ip/Address.h"
-#include "wordlist.h"
 
 static void aclParseArpList(SplayNode<Eui::Eui48 *> **curlist);
 static int aclMatchArp(SplayNode<Eui::Eui48 *> **dataptr, Ip::Address &c);
@@ -203,15 +203,15 @@ aclDumpArpListWalkee(Eui::Eui48 * const &node, void *state)
 {
     static char buf[48];
     node->encode(buf, 48);
-    wordlistAdd((wordlist **)state, buf);
+    static_cast<SBufList *>(state)->push_back(SBuf(buf));
 }
 
-wordlist *
+SBufList
 ACLARP::dump() const
 {
-    wordlist *w = NULL;
-    data->walk(aclDumpArpListWalkee, &w);
-    return w;
+    SBufList sl;
+    data->walk(aclDumpArpListWalkee, &sl);
+    return sl;
 }
 
 /* ==== END ARP ACL SUPPORT =============================================== */
@@ -58,7 +58,7 @@ class ACLARP : public ACL
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
@@ -50,7 +50,6 @@
 #include "Store.h"
 #include "StoreClient.h"
 #include "StoreClient.h"
-#include "wordlist.h"
 
 #define WHOIS_PORT 43
 #define	AS_REQBUF_SZ	4096
@@ -551,20 +550,21 @@ ACLASN::match(Ip::Address toMatch)
     return asnMatchIp(data, toMatch);
 }
 
-wordlist *
-ACLASN::dump()
+SBufList
+ACLASN::dump() const
 {
-    wordlist *W = NULL;
-    char buf[32];
+    SBufList sl;
+
     CbDataList<int> *ldata = data;
 
     while (ldata != NULL) {
-        snprintf(buf, sizeof(buf), "%d", ldata->element);
-        wordlistAdd(&W, buf);
+        SBuf s;
+        s.Printf("%d", ldata->element);
+        sl.push_back(s);
         ldata = ldata->next;
     }
 
-    return W;
+    return sl;
 }
 
 bool
@@ -56,7 +56,7 @@ class ACLASN : public ACLData<Ip::Address>
     virtual ~ACLASN();
 
     virtual bool match(Ip::Address);
-    virtual wordlist *dump();
+    virtual SBufList dump() const;
     virtual void parse();
     bool empty() const;
     virtual ACLData<Ip::Address> *clone() const;
@@ -2,7 +2,6 @@
 #include "acl/BoolOps.h"
 #include "acl/Checklist.h"
 #include "Debug.h"
-#include "wordlist.h"
 
 /* Acl::NotNode */
 
@@ -52,11 +51,11 @@ Acl::NotNode::clone() const
     return NULL;
 }
 
-wordlist*
+SBufList
 Acl::NotNode::dump() const
 {
-    wordlist *text = NULL;
-    wordlistAdd(&text, name);
+    SBufList text;
+    text.push_back(SBuf(name));
     return text;
 }
 
@@ -23,7 +23,7 @@ class NotNode: public InnerNode
     virtual char const *typeString() const;
     virtual ACL *clone() const;
     virtual void parse();
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
 
     /* Acl::InnerNode API */
     virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
@@ -98,23 +98,23 @@ ACLCertificateData::match(X509 *cert)
 static void
 aclDumpAttributeListWalkee(char * const & node_data, void *outlist)
 {
-    /* outlist is really a wordlist ** */
-    wordlistAdd((wordlist **)outlist, node_data);
+    /* outlist is really a SBufList * */
+    static_cast<SBufList *>(outlist)->push_back(SBuf(node_data));
 }
 
-wordlist *
-ACLCertificateData::dump()
+SBufList
+ACLCertificateData::dump() const
 {
-    wordlist *wl = NULL;
+    SBufList sl;
     if (validAttributesStr)
-        wordlistAdd(&wl, attribute);
+        sl.push_back(SBuf(attribute));
     /* damn this is VERY inefficient for long ACL lists... filling
      * a wordlist this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
     /* XXX FIXME: don't break abstraction */
-    values.values->walk(aclDumpAttributeListWalkee, &wl);
-    return wl;
+    values.values->walk(aclDumpAttributeListWalkee, &sl);
+    return sl;
 }
 
 void
@@ -53,7 +53,7 @@ class ACLCertificateData : public ACLData<X509 *>
     ACLCertificateData &operator= (ACLCertificateData const &);
     virtual ~ACLCertificateData();
     bool match(X509 *);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<X509 *> *clone() const;
@@ -32,7 +32,7 @@
 #ifndef SQUID_ACLDATA_H
 #define SQUID_ACLDATA_H
 
-class wordlist;
+#include "SBufList.h"
 
 /// \ingroup ACLAPI
 template <class M>
@@ -44,7 +44,7 @@ class ACLData
     virtual ~ACLData() {}
 
     virtual bool match(M) =0;
-    virtual wordlist *dump() =0;
+    virtual SBufList dump() const =0;
     virtual void parse() =0;
     virtual ACLData *clone() const =0;
     virtual void prepareForUse() {}
@@ -38,7 +38,6 @@
 #include "cache_cf.h"
 #include "Debug.h"
 #include "src/URL.h"
-#include "wordlist.h"
 
 template<class T>
 inline void
@@ -140,20 +139,20 @@ ACLDomainData::match(char const *host)
 static void
 aclDumpDomainListWalkee(char * const & node_data, void *outlist)
 {
-    /* outlist is really a wordlist ** */
-    wordlistAdd((wordlist **)outlist, (char const *)node_data);
+    /* outlist is really a SBufList ** */
+    static_cast<SBufList *>(outlist)->push_back(SBuf(node_data));
 }
 
-wordlist *
-ACLDomainData::dump()
+SBufList
+ACLDomainData::dump() const
 {
-    wordlist *wl = NULL;
+    SBufList sl;
     /* damn this is VERY inefficient for long ACL lists... filling
      * a wordlist this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
-    domains->walk(aclDumpDomainListWalkee, &wl);
-    return wl;
+    domains->walk(aclDumpDomainListWalkee, &sl);
+    return sl;
 }
 
 void
@@ -46,7 +46,7 @@ class ACLDomainData : public ACLData<char const *>
 
     virtual ~ACLDomainData();
     bool match(char const *);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
@@ -41,8 +41,8 @@
 #include "cache_cf.h"
 #include "Debug.h"
 #include "eui/Eui64.h"
+#include "globals.h"
 #include "ip/Address.h"
-#include "wordlist.h"
 
 static void aclParseEuiList(SplayNode<Eui::Eui64 *> **curlist);
 static int aclMatchEui(SplayNode<Eui::Eui64 *> **dataptr, Ip::Address &c);
@@ -177,13 +177,13 @@ aclDumpEuiListWalkee(Eui::Eui64 * const &node, void *state)
 {
     static char buf[48];
     node->encode(buf, 48);
-    wordlistAdd((wordlist **)state, buf);
+    static_cast<SBufList *>(state)->push_back(SBuf(buf));
 }
 
-wordlist *
+SBufList
 ACLEui64::dump() const
 {
-    wordlist *w = NULL;
+    SBufList w;
     data->walk(aclDumpEuiListWalkee, &w);
     return w;
 }
@@ -57,7 +57,7 @@ class ACLEui64 : public ACL
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
@@ -85,7 +85,7 @@ ACLExtUser::match(ACLChecklist *cl)
     }
 }
 
-wordlist *
+SBufList
 ACLExtUser::dump() const
 {
     return data->dump();
@@ -55,7 +55,7 @@ class ACLExtUser : public ACL
     virtual void parse();
 
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
     virtual ACL *clone()const;
 
@@ -3,7 +3,6 @@
 #include "acl/HierCodeData.h"
 #include "cache_cf.h"
 #include "hier_code.h"
-#include "wordlist.h"
 
 ACLHierCodeData::ACLHierCodeData()
 {
@@ -25,17 +24,17 @@ ACLHierCodeData::match(hier_code toFind)
     return values[toFind];
 }
 
-wordlist *
-ACLHierCodeData::dump()
+SBufList
+ACLHierCodeData::dump() const
 {
-    wordlist *W = NULL;
+    SBufList sl;
 
     for (hier_code iter=HIER_NONE; iter<HIER_MAX; ++iter) {
         if (!values[iter]) continue;
-        wordlistAdd(&W, hier_code_str[iter]);
+        sl.push_back(SBuf(hier_code_str[iter]));
     }
 
-    return W;
+    return sl;
 }
 
 void
@@ -18,7 +18,7 @@ class ACLHierCodeData : public ACLData<hier_code>
     ACLHierCodeData &operator= (ACLHierCodeData const &);
     virtual ~ACLHierCodeData();
     bool match(hier_code);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<hier_code> *clone() const;
@@ -42,7 +42,6 @@
 #include "Debug.h"
 #include "HttpHeaderTools.h"
 #include "SBuf.h"
-#include "wordlist.h"
 
 /* Construct an ACLHTTPHeaderData that uses an ACLRegex rule with the value of the
  * selected header from a given request.
@@ -80,15 +79,15 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
     return regex_rule->match(cvalue.c_str());
 }
 
-wordlist *
-ACLHTTPHeaderData::dump()
+SBufList
+ACLHTTPHeaderData::dump() const
 {
-    wordlist *W = NULL;
-    wordlistAdd(&W, hdrName.termedBuf());
-    wordlist * regex_dump = regex_rule->dump();
-    wordlistAddWl(&W, regex_dump);
-    wordlistDestroy(&regex_dump);
-    return W;
+    SBufList sl;
+    sl.push_back(SBuf(hdrName));
+    // temp is needed until c++11 move-constructor
+    SBufList temp = regex_rule->dump();
+    sl.splice(sl.end(), temp);
+    return sl;
 }
 
 void
@@ -54,7 +54,7 @@ class ACLHTTPHeaderData : public ACLData<HttpHeader*>
     ACLHTTPHeaderData();
     virtual ~ACLHTTPHeaderData();
     virtual bool match(HttpHeader* hdr);
-    virtual wordlist *dump();
+    virtual SBufList dump() const;
     virtual void parse();
     virtual bool empty() const;
     virtual ACLData<HttpHeader*> *clone() const;
@@ -38,7 +38,6 @@
 #include "cache_cf.h"
 #include "Debug.h"
 #include "HttpReply.h"
-#include "wordlist.h"
 
 #include <climits>
 
@@ -50,14 +49,17 @@ acl_httpstatus_data::acl_httpstatus_data(int x) : status1(x), status2(x) { ; }
 
 acl_httpstatus_data::acl_httpstatus_data(int x, int y) : status1(x), status2(y) { ; }
 
-void acl_httpstatus_data::toStr(char* buf, int len) const
+SBuf
+acl_httpstatus_data::toStr() const
 {
+    SBuf rv;
     if (status2 == INT_MAX)
-        snprintf(buf, len, "%d-", status1);
+        rv.Printf("%d-", status1);
     else if (status1 == status2)
-        snprintf(buf, len, "%d", status1);
+        rv.Printf("%d", status1);
     else
-        snprintf(buf, len, "%d-%d", status1, status2);
+        rv.Printf("%d-%d", status1, status2);
+    return rv;
 }
 
 int acl_httpstatus_data::compare(acl_httpstatus_data* const& a, acl_httpstatus_data* const& b)
@@ -69,13 +71,11 @@ int acl_httpstatus_data::compare(acl_httpstatus_data* const& a, acl_httpstatus_d
         ret = aclHTTPStatusCompare(a, b);
 
     if (ret == 0) {
-        char bufa[8];
-        char bufb[8];
-        a->toStr(bufa, sizeof(bufa));
-        b->toStr(bufb, sizeof(bufb));
-        debugs(28, DBG_CRITICAL, "WARNING: '" << bufa << "' is a subrange of '" << bufb << "'");
-        debugs(28, DBG_CRITICAL, "WARNING: because of this '" << bufa << "' is ignored to keep splay tree searching predictable");
-        debugs(28, DBG_CRITICAL, "WARNING: You should probably remove '" << bufb << "' from the ACL named '" << AclMatchedName << "'");
+        const SBuf sa = a->toStr();
+        const SBuf sb = b->toStr();
+        debugs(28, DBG_CRITICAL, "WARNING: '" << sa << "' is a subrange of '" << sb << "'");
+        debugs(28, DBG_CRITICAL, "WARNING: because of this '" << sa << "' is ignored to keep splay tree searching predictable");
+        debugs(28, DBG_CRITICAL, "WARNING: You should probably remove '" << sb << "' from the ACL named '" << AclMatchedName << "'");
     }
 
     return ret;
@@ -184,15 +184,14 @@ aclHTTPStatusCompare(acl_httpstatus_data * const &a, acl_httpstatus_data * const
 static void
 aclDumpHTTPStatusListWalkee(acl_httpstatus_data * const &node, void *state)
 {
-    static char buf[8];
-    node->toStr(buf, sizeof(buf));
-    wordlistAdd((wordlist **)state, buf);
+    // state is a SBufList*
+    static_cast<SBufList *>(state)->push_back(node->toStr());
 }
 
-wordlist *
+SBufList
 ACLHTTPStatus::dump() const
 {
-    wordlist *w = NULL;
+    SBufList w;
     data->walk(aclDumpHTTPStatusListWalkee, &w);
     return w;
 }
@@ -42,7 +42,7 @@ struct acl_httpstatus_data {
     int status1, status2;
     acl_httpstatus_data(int);
     acl_httpstatus_data(int, int);
-    void toStr(char* buf, int len) const;
+    SBuf toStr() const; // was toStr
 
     static int compare(acl_httpstatus_data* const& a, acl_httpstatus_data* const& b);
 };
@@ -63,7 +63,7 @@ class ACLHTTPStatus : public ACL
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool requiresReply() const { return true; }
 
@@ -7,7 +7,6 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "globals.h"
-#include "wordlist.h"
 #include <algorithm>
 
 void
@@ -64,13 +63,13 @@ Acl::InnerNode::lineParse()
     return;
 }
 
-wordlist*
+SBufList
 Acl::InnerNode::dump() const
 {
-    wordlist *values = NULL;
+    SBufList rv;
     for (Nodes::const_iterator i = nodes.begin(); i != nodes.end(); ++i)
-        wordlistAdd(&values, (*i)->name);
-    return values;
+        rv.push_back(SBuf((*i)->name));
+    return rv;
 }
 
 int
@@ -24,7 +24,7 @@ class InnerNode: public ACL
     /* ACL API */
     virtual void prepareForUse();
     virtual bool empty() const;
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
 
     /// parses one "acl name type acl1 acl2..." line, appending to nodes
     void lineParse();
@@ -37,7 +37,6 @@
 #include "cache_cf.h"
 #include "Debug.h"
 #include "Parsing.h"
-#include "wordlist.h"
 
 /* explicit instantiation required for some systems */
 /** \cond AUTODOCS_IGNORE */
@@ -109,27 +108,27 @@ ACLIntRange::clone() const
     return new ACLIntRange (*this);
 }
 
-ACLIntRange::~ACLIntRange ()
+ACLIntRange::~ACLIntRange()
 {}
 
-wordlist *
-ACLIntRange::dump ()
+SBufList
+ACLIntRange::dump() const
 {
-    wordlist *W = NULL;
-    char buf[32];
+    SBufList sl;
     CbDataListIterator<RangeType> iter(ranges);
 
     while (!iter.end()) {
+        SBuf sb;
         const RangeType & element = iter.next();
 
         if (element.size() == 1)
-            snprintf(buf, sizeof(buf), "%d", element.start);
+            sb.Printf("%d", element.start);
         else
-            snprintf(buf, sizeof(buf), "%d-%d", element.start, element.end-1);
+            sb.Printf("%d-%d", element.start, element.end-1);
 
-        wordlistAdd(&W, buf);
+        sl.push_back(sb);
     }
 
-    return W;
+    return sl;
 }
 
@@ -46,7 +46,7 @@ class ACLIntRange : public ACLData<int>
 
     virtual ~ACLIntRange();
     virtual bool match(int);
-    virtual wordlist *dump();
+    virtual SBufList dump() const;
     virtual void parse();
     virtual bool empty() const;
     virtual ACLData<int> *clone() const;
@@ -62,20 +62,7 @@ ACLIP::operator delete (void *address)
 void
 ACLIP::DumpIpListWalkee(acl_ip_data * const & ip, void *state)
 {
-    char tmpbuf[ ((MAX_IPSTRLEN*2)+6) ]; // space for 2 IPs and a CIDR mask(3) and seperators(3).
-    MemBuf mb;
-    wordlist **W = static_cast<wordlist **>(state);
-    tmpbuf[0] = '\0';
-
-    mb.init();
-    assert(mb.max_capacity > 0 && 1==1 );
-
-    ip->toStr(tmpbuf, sizeof(tmpbuf) );
-    assert(mb.max_capacity > 0 && 2==2 );
-    mb.append(tmpbuf, strlen(tmpbuf) );
-    assert(mb.max_capacity > 0 && 3==3);
-    wordlistAdd(W, mb.buf);
-    mb.clean();
+    static_cast<SBufList *>(state)->push_back(ip->toSBuf());
 }
 
 /**
@@ -115,6 +102,16 @@ acl_ip_data::toStr(char *buf, int len) const
         b3[0] = '\0';
 }
 
+SBuf
+acl_ip_data::toSBuf() const
+{
+    const int bufsz = MAX_IPSTRLEN*2+6;
+    static char tmpbuf[ bufsz ];
+    toStr(tmpbuf,bufsz);
+    return SBuf(tmpbuf);
+}
+
+
 /*
  * aclIpAddrNetworkCompare - The guts of the comparison for IP ACLs
  * matching checks.  The first argument (p) is a "host" address,
@@ -528,16 +525,16 @@ ACLIP::~ACLIP()
         data->destroy(IPSplay::DefaultFree);
 }
 
-wordlist *
+SBufList
 ACLIP::dump() const
 {
-    wordlist *w = NULL;
-    data->walk (DumpIpListWalkee, &w);
-    return w;
+    SBufList sl;
+    data->walk(DumpIpListWalkee, &sl);
+    return sl;
 }
 
 bool
-ACLIP::empty () const
+ACLIP::empty() const
 {
     return data->empty();
 }
@@ -561,6 +558,6 @@ ACLIP::match(Ip::Address &clientip)
     return !splayLastResult;
 }
 
-acl_ip_data::acl_ip_data () :addr1(), addr2(), mask(), next (NULL) {}
+acl_ip_data::acl_ip_data() :addr1(), addr2(), mask(), next (NULL) {}
 
-acl_ip_data::acl_ip_data (Ip::Address const &anAddress1, Ip::Address const &anAddress2, Ip::Address const &aMask, acl_ip_data *aNext) : addr1(anAddress1), addr2(anAddress2), mask(aMask), next(aNext) {}
+acl_ip_data::acl_ip_data(Ip::Address const &anAddress1, Ip::Address const &anAddress2, Ip::Address const &aMask, acl_ip_data *aNext) : addr1(anAddress1), addr2(anAddress2), mask(aMask), next(aNext) {}
@@ -50,6 +50,7 @@ class acl_ip_data
 
     acl_ip_data (Ip::Address const &, Ip::Address const &, Ip::Address const &, acl_ip_data *);
     void toStr(char *buf, int len) const;
+    SBuf toSBuf() const;
 
     Ip::Address addr1;
 
@@ -85,7 +86,7 @@ class ACLIP : public ACL
     virtual void parse();
     //    virtual bool isProxyAuth() const {return true;}
     virtual int match(ACLChecklist *checklist) = 0;
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
 
 protected:
@@ -39,7 +39,6 @@
 #include "client_db.h"
 #include "Debug.h"
 #include "SquidConfig.h"
-#include "wordlist.h"
 
 ACL *
 ACLMaxConnection::clone() const
@@ -104,21 +103,17 @@ ACLMaxConnection::match(ACLChecklist *checklist)
     return clientdbEstablished(Filled(checklist)->src_addr, 0) > limit ? 1 : 0;
 }
 
-wordlist *
+SBufList
 ACLMaxConnection::dump() const
 {
+    SBufList sl;
     if (!limit)
-        return NULL;
+        return sl;
 
-    wordlist *W = NULL;
-
-    char buf[32];
-
-    snprintf(buf, sizeof(buf), "%d", limit);
-
-    wordlistAdd(&W, buf);
-
-    return W;
+    SBuf s;
+    s.Printf("%d", limit);
+    sl.push_back(s);
+    return sl;
 }
 
 void
@@ -52,7 +52,7 @@ class ACLMaxConnection : public ACL
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool valid () const;
     virtual void prepareForUse();
@@ -36,7 +36,7 @@
 #include "acl/Checklist.h"
 #include "acl/MethodData.h"
 #include "cache_cf.h"
-#include "wordlist.h"
+#include "HttpRequestMethod.h"
 
 int ACLMethodData::ThePurgeCount = 0;
 
@@ -67,18 +67,18 @@ ACLMethodData::match(HttpRequestMethod toFind)
 template cbdata_type CbDataList<HttpRequestMethod>::CBDATA_CbDataList;
 /// \endcond
 
-wordlist *
-ACLMethodData::dump()
+SBufList
+ACLMethodData::dump() const
 {
-    wordlist *W = NULL;
+    SBufList sl;
     CbDataList<HttpRequestMethod> *data = values;
 
     while (data != NULL) {
-        wordlistAdd(&W, RequestMethodStr(data->element));
+        sl.push_back(data->element.image());
         data = data->next;
     }
 
-    return W;
+    return sl;
 }
 
 void
@@ -50,7 +50,7 @@ class ACLMethodData : public ACLData<HttpRequestMethod>
     ACLMethodData &operator= (ACLMethodData const &);
     virtual ~ACLMethodData();
     bool match(HttpRequestMethod);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<HttpRequestMethod> *clone() const;
@@ -51,15 +51,15 @@ ACLNoteData::match(HttpRequest *request)
     return false;
 }
 
-wordlist *
-ACLNoteData::dump()
+SBufList
+ACLNoteData::dump() const
 {
-    wordlist *W = NULL;
-    wordlistAdd(&W, name.termedBuf());
-    wordlist * dumpR = values->dump();
-    wordlistAddWl(&W, dumpR);
-    wordlistDestroy(&dumpR);
-    return W;
+    SBufList sl;
+    sl.push_back(SBuf(name));
+    // temp is needed until c++11 move constructor
+    SBufList temp = values->dump();
+    sl.splice(sl.end(), temp);
+    return sl;
 }
 
 void
@@ -17,7 +17,7 @@ class ACLNoteData : public ACLData<HttpRequest *>
     ACLNoteData();
     virtual ~ACLNoteData();
     virtual bool match(HttpRequest* request);
-    virtual wordlist *dump();
+    virtual SBufList dump() const;
     virtual void parse();
     virtual bool empty() const;
     virtual ACLData<HttpRequest *> *clone() const;
@@ -42,9 +42,9 @@
 template class ACLStrategised<AnyP::ProtocolType>;
 
 int
-ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLProtocolStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    return data->match (checklist->request->protocol);
+    return data->match(checklist->request->url.getScheme());
 }
 
 ACLProtocolStrategy *
@@ -65,18 +65,18 @@ ACLProtocolData::match(AnyP::ProtocolType toFind)
 template cbdata_type CbDataList<AnyP::ProtocolType>::CBDATA_CbDataList;
 /// \endcond
 
-wordlist *
-ACLProtocolData::dump()
+SBufList
+ACLProtocolData::dump() const
 {
-    wordlist *W = NULL;
+    SBufList sl;
     CbDataList<AnyP::ProtocolType> *data = values;
 
     while (data != NULL) {
-        wordlistAdd(&W, AnyP::ProtocolType_str[data->element]);
+        sl.push_back(SBuf(AnyP::ProtocolType_str[data->element]));
         data = data->next;
     }
 
-    return W;
+    return sl;
 }
 
 void
@@ -50,7 +50,7 @@ class ACLProtocolData : public ACLData<AnyP::ProtocolType>
     ACLProtocolData &operator= (ACLProtocolData const &);
     virtual ~ACLProtocolData();
     bool match(AnyP::ProtocolType);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<AnyP::ProtocolType> *clone() const;
@@ -135,10 +135,10 @@ ACLRandom::match(ACLChecklist *cl)
     return (data > random)?1:0;
 }
 
-wordlist *
+SBufList
 ACLRandom::dump() const
 {
-    wordlist *w = NULL;
-    wordlistAdd(&w, pattern);
-    return w;
+    SBufList sl;
+    sl.push_back(SBuf(pattern));
+    return sl;
 }
@@ -51,7 +51,7 @@ class ACLRandom : public ACL
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool valid() const;
 
@@ -101,28 +101,28 @@ ACLRegexData::match(char const *word)
     return 0;
 }
 
-wordlist *
-ACLRegexData::dump()
+SBufList
+ACLRegexData::dump() const
 {
-    wordlist *W = NULL;
+    SBufList sl;
     RegexList *temp = data;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     while (temp != NULL) {
         if (temp->flags != flags) {
             if ((temp->flags&REG_ICASE) != 0) {
-                wordlistAdd(&W, "-i");
+                sl.push_back(SBuf("-i"));
             } else {
-                wordlistAdd(&W, "+i");
+                sl.push_back(SBuf("+i"));
             }
             flags = temp->flags;
         }
 
-        wordlistAdd(&W, temp->pattern);
+        sl.push_back(SBuf(temp->pattern));
         temp = temp->next;
     }
 
-    return W;
+    return sl;
 }
 
 static const char *
@@ -45,7 +45,7 @@ class ACLRegexData : public ACLData<char const *>
 
     virtual ~ACLRegexData();
     virtual bool match(char const *user);
-    virtual wordlist *dump();
+    virtual SBufList dump() const;
     virtual void parse();
     virtual bool empty() const;
     virtual ACLData<char const *> *clone() const;
@@ -67,18 +67,16 @@ ACLSslErrorData::match(const Ssl::CertErrors *toFind)
 // template cbdata_type Ssl::Errors::CBDATA_CbDataList;
 /** \endcond */
 
-wordlist *
-ACLSslErrorData::dump()
+SBufList
+ACLSslErrorData::dump() const
 {
-    wordlist *W = NULL;
+    SBufList sl;
     Ssl::Errors *data = values;
-
     while (data != NULL) {
-        wordlistAdd(&W, Ssl::GetErrorName(data->element));
+        sl.push_back(SBuf(Ssl::GetErrorName(data->element)));
         data = data->next;
     }
-
-    return W;
+    return sl;
 }
 
 void
@@ -18,7 +18,7 @@ class ACLSslErrorData : public ACLData<const Ssl::CertErrors *>
     ACLSslErrorData &operator= (ACLSslErrorData const &);
     virtual ~ACLSslErrorData();
     bool match(const Ssl::CertErrors *);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual  ACLSslErrorData *clone() const;
@@ -63,7 +63,7 @@ class ACLStrategised : public ACL
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     virtual int match (M const &);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
     virtual bool valid () const;
     virtual ACL *clone()const;
@@ -161,7 +161,7 @@ ACLStrategised<MatchType>::match(MatchType const &toFind)
 }
 
 template <class MatchType>
-wordlist *
+SBufList
 ACLStrategised<MatchType>::dump() const
 {
     return data->dump();
@@ -37,7 +37,6 @@
 #include "acl/StringData.h"
 #include "cache_cf.h"
 #include "Debug.h"
-#include "wordlist.h"
 
 ACLStringData::ACLStringData() : values (NULL)
 {}
@@ -90,20 +89,20 @@ ACLStringData::match(char const *toFind)
 static void
 aclDumpStringWalkee(char * const & node_data, void *outlist)
 {
-    /* outlist is really a wordlist ** */
-    wordlistAdd((wordlist **)outlist, node_data);
+    /* outlist is really a SBufList* */
+    static_cast<SBufList*>(outlist)->push_back(SBuf(node_data));
 }
 
-wordlist *
-ACLStringData::dump()
+SBufList
+ACLStringData::dump() const
 {
-    wordlist *wl = NULL;
+    SBufList sl;
     /* damn this is VERY inefficient for long ACL lists... filling
-     * a wordlist this way costs Sum(1,N) iterations. For instance
+     * a SBufList this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
-    values->walk(aclDumpStringWalkee, &wl);
-    return wl;
+    values->walk(aclDumpStringWalkee, &sl);
+    return sl;
 }
 
 void
@@ -48,7 +48,7 @@ class ACLStringData : public ACLData<char const *>
     ACLStringData &operator= (ACLStringData const &);
     virtual ~ACLStringData();
     bool match(char const *);
-    wordlist *dump();
+    virtual SBufList dump() const;
     virtual void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
@@ -97,15 +97,15 @@ ACLTimeData::match(time_t when)
     return 0;
 }
 
-wordlist *
-ACLTimeData::dump()
+SBufList
+ACLTimeData::dump() const
 {
-    wordlist *W = NULL;
-    char buf[128];
-    ACLTimeData *t = this;
+    SBufList sl;
+    const ACLTimeData *t = this;
 
     while (t != NULL) {
-        snprintf(buf, sizeof(buf), "%c%c%c%c%c%c%c %02d:%02d-%02d:%02d",
+        SBuf s;
+        s.Printf("%c%c%c%c%c%c%c %02d:%02d-%02d:%02d",
                  t->weekbits & ACL_SUNDAY ? 'S' : '-',
                  t->weekbits & ACL_MONDAY ? 'M' : '-',
                  t->weekbits & ACL_TUESDAY ? 'T' : '-',
@@ -114,11 +114,11 @@ ACLTimeData::dump()
                  t->weekbits & ACL_FRIDAY ? 'F' : '-',
                  t->weekbits & ACL_SATURDAY ? 'A' : '-',
                  t->start / 60, t->start % 60, t->stop / 60, t->stop % 60);
-        wordlistAdd(&W, buf);
+        sl.push_back(s);
         t = t->next;
     }
 
-    return W;
+    return sl;
 }
 
 void
@@ -48,7 +48,7 @@ class ACLTimeData : public ACLData<time_t>
     ACLTimeData&operator=(ACLTimeData const &);
     virtual ~ACLTimeData();
     bool match(time_t);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<time_t> *clone() const;
@@ -48,28 +48,27 @@ Acl::Tree::add(ACL *rule)
     InnerNode::add(rule);
 }
 
-wordlist*
+SBufList
 Acl::Tree::treeDump(const char *prefix, const ActionToString &convert) const
 {
-    wordlist *text = NULL;
+    SBufList text;
     Actions::const_iterator action = actions.begin();
     typedef Nodes::const_iterator NCI;
     for (NCI node = nodes.begin(); node != nodes.end(); ++node) {
 
-        wordlistAdd(&text, prefix);
+        text.push_back(SBuf(prefix));
 
         if (action != actions.end()) {
             const char *act = convert ? convert[action->kind] :
                               (*action == ACCESS_ALLOWED ? "allow" : "deny");
-            wordlistAdd(&text, act ? act : "???");
+            text.push_back(act?SBuf(act):SBuf("???"));
             ++action;
         }
 
-        wordlist *rule = (*node)->dump();
-        wordlistAddWl(&text, rule);
-        wordlistDestroy(&rule);
-
-        wordlistAdd(&text, "\n");
+        // temp is needed until c++11 move constructor
+        SBufList temp = (*node)->dump();
+        text.splice(text.end(), temp);
+        text.push_back(SBuf("\n"));
     }
     return text;
 }
@@ -2,6 +2,7 @@
 #define SQUID_ACL_TREE_H
 
 #include "acl/BoolOps.h"
+#include "SBufList.h"
 
 namespace Acl
 {
@@ -14,7 +15,7 @@ class Tree: public OrNode
     /// dumps <name, action, rule, new line> tuples
     /// action.kind is mapped to a string using the supplied conversion table
     typedef const char **ActionToString;
-    wordlist* treeDump(const char *name, const ActionToString &convert) const;
+    SBufList treeDump(const char *name, const ActionToString &convert) const;
 
     /// Returns the corresponding action after a successful tree match.
     allow_t winningAction() const;
@@ -37,7 +37,6 @@
 #include "acl/UserData.h"
 #include "ConfigParser.h"
 #include "Debug.h"
-#include "wordlist.h"
 
 template<class T>
 inline void
@@ -97,28 +96,28 @@ ACLUserData::match(char const *user)
 static void
 aclDumpUserListWalkee(char * const & node_data, void *outlist)
 {
-    /* outlist is really a wordlist ** */
-    wordlistAdd((wordlist **)outlist, (char const *)node_data);
+    /* outlist is really a SBufList* */
+    static_cast<SBufList *>(outlist)->push_back(SBuf(node_data));
 }
 
-wordlist *
-ACLUserData::dump()
+SBufList
+ACLUserData::dump() const
 {
-    wordlist *wl = NULL;
+    SBufList sl;
 
     if (flags.case_insensitive)
-        wordlistAdd(&wl, "-i");
+        sl.push_back(SBuf("-i"));
 
     /* damn this is VERY inefficient for long ACL lists... filling
-     * a wordlist this way costs Sum(1,N) iterations. For instance
+     * a SBufList this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
     if (flags.required)
-        wordlistAdd(&wl, "REQUIRED");
+        sl.push_back(SBuf("REQUIRED"));
     else if (names)
-        names->walk(aclDumpUserListWalkee, &wl);
+        names->walk(aclDumpUserListWalkee, &sl);
 
-    return wl;
+    return sl;
 }
 
 void
@@ -45,7 +45,7 @@ class ACLUserData : public ACLData<char const *>
 
     virtual ~ACLUserData();
     bool match(char const *user);
-    wordlist *dump();
+    virtual SBufList dump() const;
     void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
@@ -45,7 +45,6 @@ Adaptation::Ecap::Host::Host()
     libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);
     libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);
     libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);
-    protocolInternal.assignHostId(AnyP::PROTO_INTERNAL);
     protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);
     protocolIcp.assignHostId(AnyP::PROTO_ICP);
 #if USE_HTCP
@@ -158,8 +158,6 @@ Adaptation::Ecap::FirstLineRep::protocol() const
 #endif
     case AnyP::PROTO_CACHE_OBJECT:
         return protocolCacheObj;
-    case AnyP::PROTO_INTERNAL:
-        return protocolInternal;
     case AnyP::PROTO_ICY:
         return protocolIcy;
     case AnyP::PROTO_COAP:
@@ -254,7 +252,7 @@ Adaptation::Ecap::RequestLineRep::method() const
     case Http::METHOD_TRACE:
         return libecap::methodTrace;
     default:
-        return Name(theMessage.method.image());
+        return Name(theMessage.method.image().toStdString());
     }
 }
 
@@ -101,7 +101,7 @@ int
 Adaptation::Ecap::Engine::checkEvents(int)
 {
     // Start with the default I/O loop timeout, convert from milliseconds.
-    static const struct timeval maxTimeout {
+    static const struct timeval maxTimeout = {
         EVENT_LOOP_TIMEOUT/1000, // seconds
         (EVENT_LOOP_TIMEOUT % 1000)*1000
     }; // microseconds
@@ -147,7 +147,7 @@ void Adaptation::Icap::ServiceRep::putConnection(const Comm::ConnectionPointer &
 void Adaptation::Icap::ServiceRep::noteConnectionUse(const Comm::ConnectionPointer &conn)
 {
     Must(Comm::IsConnOpen(conn));
-    fd_table[conn->fd].noteUse(NULL); // pconn re-use but not via PconnPool API
+    fd_table[conn->fd].noteUse(); // pconn re-use, albeit not via PconnPool API
 }
 
 void Adaptation::Icap::ServiceRep::noteConnectionFailed(const char *comment)
@@ -187,10 +187,10 @@ AnyP::PortCfg::setTransport(const char *aProtocol)
     // HTTP/1.0 not supported because we are version 1.1 which contains a superset of 1.0
     // and RFC 2616 requires us to upgrade 1.0 to 1.1
 
-    if (strcasecmp("http", aProtocol) != 0 || strcmp("HTTP/1.1", aProtocol) != 0)
+    if (strcasecmp("http", aProtocol) == 0 || strcmp("HTTP/1.1", aProtocol) == 0)
         transport = AnyP::ProtocolVersion(AnyP::PROTO_HTTP, 1,1);
 
-    else if (strcasecmp("https", aProtocol) != 0 || strcmp("HTTPS/1.1", aProtocol) != 0)
+    else if (strcasecmp("https", aProtocol) == 0 || strcmp("HTTPS/1.1", aProtocol) == 0)
         transport = AnyP::ProtocolVersion(AnyP::PROTO_HTTPS, 1,1);
 
     else
@@ -27,7 +27,6 @@ typedef enum {
 #endif
     PROTO_URN,
     PROTO_WHOIS,
-    PROTO_INTERNAL,
     PROTO_ICY,
     PROTO_UNKNOWN,
     PROTO_MAX
@@ -146,19 +146,14 @@ ACLMaxUserIP::match(ACLChecklist *cl)
     }
 }
 
-wordlist *
+SBufList
 ACLMaxUserIP::dump() const
 {
+    SBufList sl;
     if (!maximum)
-        return NULL;
-
-    wordlist *W = NULL;
-
-    char buf[128];
-
-    snprintf(buf, sizeof(buf), "%lu", (unsigned long int) maximum);
-
-    wordlistAdd(&W, buf);
-
-    return W;
+        return sl;
+    SBuf s;
+    s.Printf("%d", maximum);
+    sl.push_back(s);
+    return sl;
 }
@@ -54,7 +54,7 @@ class ACLMaxUserIP : public ACL
     virtual char const *typeString() const;
     virtual void parse();
     virtual int match(ACLChecklist *cl);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty() const;
     virtual bool valid() const;
     virtual bool requiresRequest() const {return true;}
@@ -99,7 +99,7 @@ ACLProxyAuth::match(ACLChecklist *checklist)
     }
 }
 
-wordlist *
+SBufList
 ACLProxyAuth::dump() const
 {
     return data->dump();
@@ -65,7 +65,7 @@ class ACLProxyAuth : public ACL
     virtual bool isProxyAuth() const {return true;}
 
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool valid() const;
     virtual bool empty() const;
     virtual bool requiresRequest() const {return true;}
@@ -102,9 +102,10 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
                   authenticateDigestNonceNonceb64(digest_request->nonce),
                   digest_request->cnonce,
                   digest_user->HA1, SESSIONKEY);
+    SBuf sTmp = request->method.image();
     DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
                        digest_request->nc, digest_request->cnonce, digest_request->qop,
-                       RequestMethodStr(request->method), digest_request->uri, HA2, Response);
+                       sTmp.c_str(), digest_request->uri, HA2, Response);
 
     debugs(29, 9, "\nResponse = '" << digest_request->response << "'\nsquid is = '" << Response << "'");
 
@@ -123,9 +124,10 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
              * widespread and such broken browsers no longer are commonly
              * used.
              */
+            sTmp = HttpRequestMethod(Http::METHOD_GET).image();
             DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
                                digest_request->nc, digest_request->cnonce, digest_request->qop,
-                               RequestMethodStr(Http::METHOD_GET), digest_request->uri, HA2, Response);
+                               sTmp.c_str(), digest_request->uri, HA2, Response);
 
             if (strcasecmp(digest_request->response, Response)) {
                 auth_user->credentials(Auth::Failed);
@@ -135,7 +135,7 @@ Cbc &
 CbcPointer<Cbc>::operator *() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return *c;
 }
 
@@ -144,7 +144,7 @@ Cbc *
 CbcPointer<Cbc>::operator ->() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return c;
 }
 
@@ -60,7 +60,7 @@ class RegisteredRunner
     /// Meant for cleanup and state saving that may require other modules.
     virtual void startShutdown() {}
 
-    /// Called after stopping the main loop.
+    /// Called after stopping the main loop and before releasing memory.
     /// Meant for quick/basic cleanup that does not require any other modules.
     virtual ~RegisteredRunner() {}
     /// exists to simplify caller interface; override the destructor instead
@@ -68,9 +68,12 @@
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
 #include "Parsing.h"
+#include "pconn.h"
 #include "PeerDigest.h"
+#include "PeerPoolMgr.h"
 #include "RefreshPattern.h"
 #include "rfc1738.h"
+#include "SBufList.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
 #include "ssl/ProxyCerts.h"
@@ -242,6 +245,10 @@ static void dump_sslproxy_ssl_bump(StoreEntry *entry, const char *name, acl_acce
 static void free_sslproxy_ssl_bump(acl_access **ssl_bump);
 #endif /* USE_OPENSSL */
 
+static void parse_ftp_epsv(acl_access **ftp_epsv);
+static void dump_ftp_epsv(StoreEntry *entry, const char *name, acl_access *ftp_epsv);
+static void free_ftp_epsv(acl_access **ftp_epsv);
+
 static void parse_b_size_t(size_t * var);
 static void parse_b_int64_t(int64_t * var);
 
@@ -717,6 +724,7 @@ configDoConfigure(void)
 #endif
 
     storeConfigure();
+    update_maxobjsize(); // check for late maximum_object_size directive
 
     snprintf(ThisCache, sizeof(ThisCache), "%s (%s)",
              uniqueHostname(),
@@ -1282,15 +1290,13 @@ parseBytesUnits(const char *unit)
     return 0;
 }
 
-/*****************************************************************************
- * Max
- *****************************************************************************/
-
 static void
-dump_wordlist(StoreEntry * entry, wordlist *words)
+dump_SBufList(StoreEntry * entry, const SBufList &words)
 {
-    for (wordlist *word = words; word; word = word->next)
-        storeAppendPrintf(entry, "%s ", word->key);
+    for (SBufList::const_iterator i = words.begin(); i != words.end(); ++i) {
+        entry->append(i->rawContent(), i->length());
+        entry->append(" ",1);
+    }
 }
 
 static void
@@ -1303,11 +1309,7 @@ dump_acl(StoreEntry * entry, const char *name, ACL * ae)
                           ae->name,
                           ae->typeString(),
                           ae->flags.flagsStr());
-        wordlist *w = ae->dump();
-        dump_wordlist(entry, w);
-
-        storeAppendPrintf(entry, "\n");
-        wordlistDestroy(&w);
+        dump_SBufList(entry, ae->dump());
         ae = ae->next;
     }
 }
@@ -1327,19 +1329,14 @@ free_acl(ACL ** ae)
 void
 dump_acl_list(StoreEntry * entry, ACLList * head)
 {
-    wordlist *values = head->dump();
-    dump_wordlist(entry, values);
-    wordlistDestroy(&values);
+    dump_SBufList(entry, head->dump());
 }
 
 void
 dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 {
-    if (head) {
-        wordlist *lines = head->treeDump(name, NULL);
-        dump_wordlist(entry, lines);
-        wordlistDestroy(&lines);
-    }
+    if (head)
+        dump_SBufList(entry, head->treeDump(name,NULL));
 }
 
 static void
@@ -2271,6 +2268,8 @@ parse_peer(CachePeer ** head)
             p->options.allow_miss = true;
         } else if (!strncmp(token, "max-conn=", 9)) {
             p->max_conn = xatoi(token + 9);
+        } else if (!strncmp(token, "standby=", 8)) {
+            p->standby.limit = xatoi(token + 8);
         } else if (!strcmp(token, "originserver")) {
             p->options.originserver = true;
         } else if (!strncmp(token, "name=", 5)) {
@@ -2344,6 +2343,9 @@ parse_peer(CachePeer ** head)
     if (peerFindByName(p->name))
         fatalf("ERROR: cache_peer %s specified twice\n", p->name);
 
+    if (p->max_conn > 0 && p->max_conn < p->standby.limit)
+        fatalf("ERROR: cache_peer %s max-conn=%d is lower than its standby=%d\n", p->host, p->max_conn, p->standby.limit);
+
     if (p->weight < 1)
         p->weight = 1;
 
@@ -2388,6 +2390,9 @@ free_peer(CachePeer ** P)
         cbdataReferenceDone(p->digest);
 #endif
 
+        // the mgr job will notice that its owner is gone and stop
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "peer gone");
+        delete p->standby.pool;
         cbdataFree(p);
     }
 
@@ -4722,11 +4727,8 @@ static void parse_sslproxy_ssl_bump(acl_access **ssl_bump)
 
 static void dump_sslproxy_ssl_bump(StoreEntry *entry, const char *name, acl_access *ssl_bump)
 {
-    if (ssl_bump) {
-        wordlist *lines = ssl_bump->treeDump(name, Ssl::BumpModeStr);
-        dump_wordlist(entry, lines);
-        wordlistDestroy(&lines);
-    }
+    if (ssl_bump)
+        dump_SBufList(entry, ssl_bump->treeDump(name, Ssl::BumpModeStr));
 }
 
 static void free_sslproxy_ssl_bump(acl_access **ssl_bump)
@@ -4818,6 +4820,73 @@ static void free_note(Notes *notes)
     notes->clean();
 }
 
+static bool FtpEspvDeprecated = false;
+static void parse_ftp_epsv(acl_access **ftp_epsv)
+{
+    allow_t ftpEpsvDeprecatedAction;
+    bool ftpEpsvIsDeprecatedRule = false;
+
+    char *t = ConfigParser::PeekAtToken();
+    if (!t){
+        self_destruct();
+        return;
+    }
+
+    if (!strcmp(t, "off")) {
+        (void)ConfigParser::NextToken();
+        ftpEpsvIsDeprecatedRule = true;
+        ftpEpsvDeprecatedAction = allow_t(ACCESS_DENIED);
+    } else if (!strcmp(t, "on")) {
+        (void)ConfigParser::NextToken();
+        ftpEpsvIsDeprecatedRule = true;
+        ftpEpsvDeprecatedAction = allow_t(ACCESS_ALLOWED);
+    }
+
+    // Check for mixing "ftp_epsv on|off" and "ftp_epsv allow|deny .." rules:
+    //   1) if this line is "ftp_epsv allow|deny ..." and already exist rules of "ftp_epsv on|off"
+    //   2) if this line is "ftp_epsv on|off" and already exist rules of "ftp_epsv allow|deny ..."
+    // then abort
+    if ((!ftpEpsvIsDeprecatedRule && FtpEspvDeprecated) ||
+        (ftpEpsvIsDeprecatedRule && !FtpEspvDeprecated && *ftp_epsv != NULL)) {
+        debugs(3, DBG_CRITICAL, "FATAL: do not mix \"ftp_epsv on|off\" cfg lines with \"ftp_epsv allow|deny ...\" cfg lines. Update your ftp_epsv rules.");
+        self_destruct();
+    }
+
+    if (ftpEpsvIsDeprecatedRule) {
+        // overwrite previous ftp_epsv lines
+        delete *ftp_epsv;
+        if (ftpEpsvDeprecatedAction == allow_t(ACCESS_DENIED)) {
+            Acl::AndNode *ftpEpsvRule = new Acl::AndNode;
+            ftpEpsvRule->context("(ftp_epsv rule)", config_input_line);
+            ACL *a = ACL::FindByName("all");
+            if (!a) {
+                self_destruct();
+                return;
+            }
+            ftpEpsvRule->add(a);
+            *ftp_epsv = new Acl::Tree;
+            (*ftp_epsv)->context("(ftp_epsv rules)", config_input_line);
+            (*ftp_epsv)->add(ftpEpsvRule, ftpEpsvDeprecatedAction);
+        } else
+            *ftp_epsv = NULL;
+        FtpEspvDeprecated = true;
+    } else {
+        aclParseAccessLine(cfg_directive, LegacyParser, ftp_epsv);
+    }
+}
+
+static void dump_ftp_epsv(StoreEntry *entry, const char *name, acl_access *ftp_epsv)
+{
+    if (ftp_epsv)
+        dump_SBufList(entry, ftp_epsv->treeDump(name, NULL));
+}
+
+static void free_ftp_epsv(acl_access **ftp_epsv)
+{
+    free_acl_access(ftp_epsv);
+    FtpEspvDeprecated = false;
+}
+
 static void
 parse_configuration_includes_quoted_values(bool *recognizeQuotedValues)
 {
@@ -59,18 +59,6 @@ typedef struct _CacheEntry {
     unsigned char key_arr[SQUID_MD5_DIGEST_LENGTH];
 } CacheEntry;
 
-/* copied from url.c */
-const char *RequestMethodStr[] = {
-    "NONE",
-    "GET",
-    "POST",
-    "PUT",
-    "HEAD",
-    "CONNECT",
-    "TRACE",
-    "PURGE"
-};
-
 static int cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file);
 
 static CacheEntry *
@@ -185,16 +185,14 @@ carpSelectParent(HttpRequest * request)
 
     /* select CachePeer */
     for (k = 0; k < n_carp_peers; ++k) {
-        String key;
+        SBuf key;
         tp = carp_peers[k];
         if (tp->options.carp_key.set) {
             //this code follows urlCanonical's pattern.
             //   corner cases should use the canonical URL
             if (tp->options.carp_key.scheme) {
-                // temporary, until bug 1961 URL handling is fixed.
-                const AnyP::UriScheme sch(request->protocol);
-                key.append(sch.c_str());
-                if (key.size()) //if the scheme is not empty
+                key.append(request->url.getScheme().c_str());
+                if (key.length()) //if the scheme is not empty
                     key.append("://");
             }
             if (tp->options.carp_key.host) {
@@ -208,24 +206,24 @@ carpSelectParent(HttpRequest * request)
             if (tp->options.carp_key.path) {
                 String::size_type pos;
                 if ((pos=request->urlpath.find('?'))!=String::npos)
-                    key.append(request->urlpath.substr(0,pos));
+                    key.append(SBuf(request->urlpath.substr(0,pos)));
                 else
-                    key.append(request->urlpath);
+                    key.append(SBuf(request->urlpath));
             }
             if (tp->options.carp_key.params) {
                 String::size_type pos;
                 if ((pos=request->urlpath.find('?'))!=String::npos)
-                    key.append(request->urlpath.substr(pos,request->urlpath.size()));
+                    key.append(SBuf(request->urlpath.substr(pos,request->urlpath.size())));
             }
         }
         // if the url-based key is empty, e.g. because the user is
         // asking to balance on the path but the request doesn't supply any,
         // then fall back to canonical URL
 
-        if (key.size()==0)
-            key=urlCanonical(request);
+        if (key.isEmpty())
+            key=SBuf(urlCanonical(request));
 
-        for (const char *c = key.rawBuf(), *e=key.rawBuf()+key.size(); c < e; ++c)
+        for (const char *c = key.rawContent(), *e=key.rawContent()+key.length(); c < e; ++c)
             user_hash += ROTATE_LEFT(user_hash, 19) + *c;
         combined_hash = (user_hash ^ tp->carp.hash);
         combined_hash += combined_hash * 0x62531965;
@@ -75,3 +75,4 @@ wordlist
 sslproxy_ssl_bump	acl
 sslproxy_cert_sign	acl
 sslproxy_cert_adapt	acl
+ftp_epsv                acl
@@ -64,6 +64,17 @@ COMMENT_START
   from causing Squid entering an infinite loop whilst trying to load
   configuration files.
 
+  Values with byte units
+
+	Squid accepts size units on some size related directives. All
+	such directives are documented with a default value displaying
+	a unit.
+
+	Units accepted by Squid are:
+		bytes - byte
+		KB - Kilobyte (1024 bytes)
+		MB - Megabyte
+		GB - Gigabyte
 
   Values with spaces, quotes, and other special characters
 
@@ -718,7 +729,7 @@ DOC_START
 	  %SRCPORT	Client source port
 	  %URI		Requested URI
 	  %DST		Requested host
-	  %PROTO	Requested protocol
+	  %PROTO	Requested URL scheme
 	  %PORT		Requested port
 	  %PATH		Requested URL path
 	  %METHOD	Request method
@@ -3075,7 +3086,8 @@ DOC_START
 	
 	connect-fail-limit=N
 			How many times connecting to a peer must fail before
-			it is marked as down. Default is 10.
+			it is marked as down. Standby connection failures
+			count towards this limit. Default is 10.
 	
 	allow-miss	Disable Squid's use of only-if-cached when forwarding
 			requests to siblings. This is primarily useful when
@@ -3085,8 +3097,50 @@ DOC_START
 			For example to deny peer usage on requests from peer
 			by denying cache_peer_access if the source is a peer.
 	
-	max-conn=N	Limit the amount of connections Squid may open to this
-			peer. see also 
+	max-conn=N 	Limit the number of concurrent connections the Squid
+			may open to this peer, including already opened idle
+			and standby connections. There is no peer-specific
+			connection limit by default.
+	
+			A peer exceeding the limit is not used for new
+			requests unless a standby connection is available.
+	
+			max-conn currently works poorly with idle persistent
+			connections: When a peer reaches its max-conn limit,
+			and there are idle persistent connections to the peer,
+			the peer may not be selected because the limiting code
+			does not know whether Squid can reuse those idle
+			connections.
+	
+	standby=N	Maintain a pool of N "hot standby" connections to an
+			UP peer, available for requests when no idle
+			persistent connection is available (or safe) to use.
+			By default and with zero N, no such pool is maintained.
+			N must not exceed the max-conn limit (if any).
+	
+			At start or after reconfiguration, Squid opens new TCP
+			standby connections until there are N connections
+			available and then replenishes the standby pool as
+			opened connections are used up for requests. A used
+			connection never goes back to the standby pool, but
+			may go to the regular idle persistent connection pool
+			shared by all peers and origin servers.
+	
+			Squid never opens multiple new standby connections
+			concurrently.  This one-at-a-time approach minimizes
+			flooding-like effect on peers. Furthermore, just a few
+			standby connections should be sufficient in most cases
+			to supply most new requests with a ready-to-use
+			connection.
+	
+			Standby connections obey server_idle_pconn_timeout.
+			For the feature to work as intended, the peer must be
+			configured to accept and keep them open longer than
+			the idle timeout at the connecting Squid, to minimize
+			race conditions typical to idle used persistent
+			connections. Default request_timeout and
+			server_idle_pconn_timeout values ensure such a
+			configuration.
 	
 	name=xxx	Unique name for the peer.
 			Required if you have multiple peers on the same host
@@ -3383,6 +3437,39 @@ DOC_START
 	and http://fog.hpl.external.hp.com/techreports/98/HPL-98-173.html.
 DOC_END
 
+NAME: minimum_object_size
+COMMENT: (bytes)
+TYPE: b_int64_t
+DEFAULT: 0 KB
+DEFAULT_DOC: no limit
+LOC: Config.Store.minObjectSize
+DOC_START
+	Objects smaller than this size will NOT be saved on disk.  The
+	value is specified in bytes, and the default is 0 KB, which
+	means all responses can be stored.
+DOC_END
+
+NAME: maximum_object_size
+COMMENT: (bytes)
+TYPE: b_int64_t
+DEFAULT: 4 MB
+LOC: Config.Store.maxObjectSize
+DOC_START
+	Set the default value for max-size parameter on any cache_dir.
+	The value is specified in bytes, and the default is 4 MB.
+	
+	If you wish to get a high BYTES hit ratio, you should probably
+	increase this (one 32 MB object hit counts for 3200 10KB
+	hits).
+	
+	If you wish to increase hit ratio more than you want to
+	save bandwidth you should leave this low.
+	
+	NOTE: if using the LFUDA replacement policy you should increase
+	this value to maximize the byte hit rate improvement of LFUDA!
+	See cache_replacement_policy for a discussion of this policy.
+DOC_END
+
 NAME: cache_dir
 TYPE: cachedir
 DEFAULT: none
@@ -3532,9 +3619,9 @@ DOC_START
 
 	max-size=n	the maximum object size in bytes this cache_dir
 			supports.
-			The value in maximum_object_size directive, sets
-			a default unless more specific details are available
-			about the cache_dir (ie a small store capacity).
+			The value in maximum_object_size directive sets
+			the default unless more specific details are
+			available (ie a small store capacity).
 
 	Note: To make optimal use of the max-size limits you should order
 	the cache_dir lines with the smallest max-size value first.
@@ -3607,40 +3694,6 @@ DOC_START
 	A value of 0 indicates no limit.
 DOC_END
 
-NAME: minimum_object_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 0 KB
-DEFAULT_DOC: no limit
-LOC: Config.Store.minObjectSize
-DOC_START
-	Objects smaller than this size will NOT be saved on disk.  The
-	value is specified in bytes, and the default is 0 KB, which
-	means all responses can be stored.
-DOC_END
-
-NAME: maximum_object_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 4 MB
-LOC: Config.Store.maxObjectSize
-DOC_START
-	The default limit on size of objects stored to disk.
-	This size is used for cache_dir where max-size is not set.
-	The value is specified in bytes, and the default is 4 MB.
-
-	If you wish to get a high BYTES hit ratio, you should probably
-	increase this (one 32 MB object hit counts for 3200 10KB
-	hits).
-
-	If you wish to increase hit ratio more than you want to
-	save bandwidth you should leave this low.
-
-	NOTE: if using the LFUDA replacement policy you should increase
-	this value to maximize the byte hit rate improvement of LFUDA!
-	See replacement_policy below for a discussion of this policy.
-DOC_END
-
 NAME: cache_swap_low
 COMMENT: (percent, 0-100)
 TYPE: int
@@ -3729,10 +3782,22 @@ DOC_START
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
-		note	The meta header specified by the argument. Also
+		note	The annotation specified by the argument. Also
 			logs the adaptation meta headers set by the
 			adaptation_meta configuration parameter.
-			If no argument given all meta headers logged.
+			If no argument given all annotations logged.
+			The argument may include a separator to use with
+			annotation values:
+                            name[:separator]
+			By default, multiple note values are separated with ","
+			and multiple notes are separated with "\r\n".
+			When logging named notes with %{name}note, the
+			explicitly configured separator is used between note
+			values. When logging all notes with %note, the
+			explicitly configured separator is used between
+			individual notes. There is currently no way to
+			specify both value and notes separators when logging
+			all notes with %note.
 
 	Connection related format codes:
 
@@ -4486,9 +4551,9 @@ DOC_START
 DOC_END
 
 NAME: ftp_epsv
-TYPE: onoff
-DEFAULT: on
-LOC: Config.Ftp.epsv
+TYPE: ftp_epsv
+DEFAULT: none
+LOC: Config.accessList.ftp_epsv
 DOC_START
 	FTP Protocol extensions permit the use of a special "EPSV" command.
 
@@ -4497,10 +4562,18 @@ DOC_START
 	and therefore, translation of the data portion of the segments 
 	will never be needed.
 
-	Turning this OFF will prevent EPSV being attempted.
-	WARNING: Doing so will convert Squid back to the old behavior with all
-	the related problems with external NAT devices/layers.
+	EPSV is often required to interoperate with FTP servers on IPv6
+	networks. On the other hand, it may break some IPv4 servers.
+
+	By default, EPSV may try EPSV with any FTP server. To fine tune
+	that decision, you may restrict EPSV to certain clients or servers
+	using ACLs:
+
+		ftp_epsv allow|deny al1 acl2 ...
+
+	WARNING: Disabling EPSV may cause problems with external NAT and IPv6.
 
+	Only fast ACLs are supported.
 	Requires ftp_passive to be ON (default) for any effect.
 DOC_END
 
@@ -9015,7 +9088,7 @@ DOC_END
 NAME: high_memory_warning
 TYPE: b_size_t
 LOC: Config.warnings.high_memory
-IFDEF: HAVE_MSTATS && HAVE_GNUMALLOC_H
+IFDEF: HAVE_MSTATS&&HAVE_GNUMALLOC_H
 DEFAULT: 0 KB
 DEFAULT_DOC: disabled.
 DOC_START
@@ -5,33 +5,34 @@ BEGIN {
 	print "*/"
 	print "#include \"autoconf.h\""
 	print "static struct { const char *name; const char *enable; int defined;} defines[] = {"
-	define["USE_DELAY_POOLS"]="--enable-delay-pools"
+	define["_SQUID_WINDOWS_"]="MS Windows"
 	define["FOLLOW_X_FORWARDED_FOR"]="--enable-follow-x-forwarded-for"
-	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
-	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
 	define["FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER"]="--enable-follow-x-forwarded-for and --enable-linux-netfilter"
-	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
+	define["HAVE_MSTATS&&HAVE_GNUMALLOC_H"]="GNU Malloc with mstats()"
 	define["ICAP_CLIENT"]="--enable-icap-client"
+	define["SO_MARK&&USE_LIBCAP"]="Packet MARK (Linux)"
 	define["SQUID_SNMP"]="--enable-snmp"
 	define["USE_ADAPTATION"]="--enable-ecap or --enable-icap-client"
 	define["USE_AUTH"]="--enable-auth"
 	define["USE_CACHE_DIGESTS"]="--enable-cache-digests"
+	define["USE_DELAY_POOLS"]="--enable-delay-pools"
 	define["USE_ECAP"]="--enable-ecap"
 	define["USE_ERR_LOCALES"]="--enable-auto-locale"
 	define["USE_HTCP"]="--enable-htcp"
+	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
 	define["USE_ICMP"]="--enable-icmp"
 	define["USE_IDENT"]="--enable-ident-lookups"
 	define["USE_LOADABLE_MODULES"]="--enable-loadable-modules"
+	define["USE_OPENSSL"]="--with-openssl"
+	define["USE_QOS_TOS"]="--enable-zph-qos"
 	define["USE_SQUID_ESI"]="--enable-esi"
 	define["USE_SQUID_EUI"]="--enable-eui"
 	define["USE_SSL_CRTD"]="--enable-ssl-crtd"
-	define["USE_OPENSSL"]="--with-openssl"
 	define["USE_UNLINKD"]="--enable-unlinkd"
 	define["USE_WCCP"]="--enable-wccp"
 	define["USE_WCCPv2"]="--enable-wccpv2"
-	define["USE_QOS_TOS"]="--enable-zph-qos"
-	define["_SQUID_WINDOWS_"]="MS Windows"
-	define["SO_MARK&&USE_LIBCAP"]="Packet MARK (Linux)"
 }
 /^IFDEF:/ {
 	if (define[$2] != "")
@@ -899,10 +899,8 @@ clientSetKeepaliveFlag(ClientHttpRequest * http)
 {
     HttpRequest *request = http->request;
 
-    debugs(33, 3, "clientSetKeepaliveFlag: http_ver = " <<
-           request->http_ver.major << "." << request->http_ver.minor);
-    debugs(33, 3, "clientSetKeepaliveFlag: method = " <<
-           RequestMethodStr(request->method));
+    debugs(33, 3, "http_ver = " << request->http_ver);
+    debugs(33, 3, "method = " << request->method);
 
     // TODO: move to HttpRequest::hdrCacheInit, just like HttpReply.
     request->flags.proxyKeepalive = request->persistent();
@@ -2618,20 +2616,23 @@ clientProcessRequest(ConnStateData *conn, Http1::RequestParser &hp, ClientSocket
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
-        if (internalHostnameIs(request->GetHost()) &&
-                request->port == getMyPort()) {
+        if (internalHostnameIs(request->GetHost()) && request->port == getMyPort()) {
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
+                   ':' << request->port);
             http->flags.internal = true;
         } else if (Config.onoff.global_internal_static && internalStaticCheck(request->urlpath.termedBuf())) {
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
+                   ':' << request->port << " (global_internal_static on)");
             request->SetHost(internalHostname());
             request->port = getMyPort();
             http->flags.internal = true;
-        }
+        } else
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
+                   ':' << request->port << " (not this proxy)");
     }
 
-    if (http->flags.internal) {
-        request->protocol = AnyP::PROTO_HTTP;
+    if (http->flags.internal)
         request->login[0] = '\0';
-    }
 
     request->flags.internal = http->flags.internal;
     setLogUri (http, urlCanonicalClean(request.getRaw()));
@@ -2712,6 +2713,10 @@ clientProcessRequest(ConnStateData *conn, Http1::RequestParser &hp, ClientSocket
     if (http->request->method == Http::METHOD_CONNECT) {
         context->mayUseConnection(true);
         conn->flags.readMore = false;
+
+        // consume header early so that tunnel gets just the body
+        connNoteUseOfBuffer(conn, http->req_sz);
+        notedUseOfBuffer = true;
     }
 
 #if USE_OPENSSL
@@ -583,7 +583,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
              */
             http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
             processMiss();
-        } else if (r->protocol == AnyP::PROTO_HTTP) {
+        } else if (r->url.getScheme() == AnyP::PROTO_HTTP) {
             debugs(88, 3, "validate HIT object? YES.");
             /*
              * Object needs to be revalidated
@@ -631,7 +631,7 @@ clientReplyContext::processMiss()
     char *url = http->uri;
     HttpRequest *r = http->request;
     ErrorState *err = NULL;
-    debugs(88, 4, "clientProcessMiss: '" << RequestMethodStr(r->method) << " " << url << "'");
+    debugs(88, 4, r->method << ' ' << url);
 
     /**
      * We might have a left-over StoreEntry from a failed cache hit
@@ -687,10 +687,6 @@ clientReplyContext::processMiss()
             return;
         }
 
-        /** Check for internal requests. Update Protocol info if so. */
-        if (http->flags.internal)
-            r->protocol = AnyP::PROTO_INTERNAL;
-
         assert(r->clientConnectionManager == http->getConn());
 
         /** Start forwarding to get the new object from network */
@@ -708,8 +704,7 @@ clientReplyContext::processMiss()
 void
 clientReplyContext::processOnlyIfCachedMiss()
 {
-    debugs(88, 4, "clientProcessOnlyIfCachedMiss: '" <<
-           RequestMethodStr(http->request->method) << " " << http->uri << "'");
+    debugs(88, 4, http->request->method << ' ' << http->uri);
     http->al->http.code = Http::scGatewayTimeout;
     ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, Http::scGatewayTimeout, NULL,
                                        http->getConn()->clientConnection->remote, http->request);
@@ -835,7 +830,7 @@ purgeEntriesByUrl(HttpRequest * req, const char *url)
     for (HttpRequestMethod m(Http::METHOD_NONE); m != Http::METHOD_ENUM_END; ++m) {
         if (m.respMaybeCacheable()) {
             if (StoreEntry *entry = storeGetPublic(url, m)) {
-                debugs(88, 5, "purging " << *entry << ' ' << RequestMethodStr(m) << ' ' << url);
+                debugs(88, 5, "purging " << *entry << ' ' << m << ' ' << url);
 #if USE_HTCP
                 neighborsHtcpClear(entry, url, req, m, HTCP_CLR_INVALIDATION);
                 if (m == Http::METHOD_GET || m == Http::METHOD_HEAD) {
@@ -1995,9 +1990,9 @@ clientReplyContext::ProcessReplyAccessResult(allow_t rv, void *voidMe)
 void
 clientReplyContext::processReplyAccessResult(const allow_t &accessAllowed)
 {
-    debugs(88, 2, "The reply for " << RequestMethodStr(http->request->method)
-           << " " << http->uri << " is " << accessAllowed << ", because it matched '"
-           << (AclMatchedName ? AclMatchedName : "NO ACL's") << "'" );
+    debugs(88, 2, "The reply for " << http->request->method
+           << ' ' << http->uri << " is " << accessAllowed << ", because it matched "
+           << (AclMatchedName ? AclMatchedName : "NO ACL's"));
 
     if (accessAllowed != ACCESS_ALLOWED) {
         ErrorState *err;
@@ -678,10 +678,10 @@ ClientRequestContext::hostHeaderVerify()
         // Verify forward-proxy requested URL domain matches the Host: header
         debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: port " << portStr);
         hostHeaderVerifyFailed("URL port", portStr);
-    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->protocol)) {
+    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->url.getScheme())) {
         // Verify forward-proxy requested URL domain matches the Host: header
         // Special case: we don't have a default-port to check for CONNECT. Assume URL is correct.
-        debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->protocol));
+        debugs(85, 3, "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->url.getScheme()));
         hostHeaderVerifyFailed("URL port", "default port");
     } else {
         // Okay no problem.
@@ -758,8 +758,7 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
     acl_checklist = NULL;
     err_type page_id;
     Http::StatusCode status;
-    debugs(85, 2, "The request " <<
-           RequestMethodStr(http->request->method) << " " <<
+    debugs(85, 2, "The request " << http->request->method << ' ' <<
            http->uri << " is " << answer <<
            "; last ACL checked: " << (AclMatchedName ? AclMatchedName : "[none]"));
 
@@ -984,13 +983,13 @@ clientHierarchical(ClientHttpRequest * http)
     if (request->flags.loopDetected)
         return 0;
 
-    if (request->protocol == AnyP::PROTO_HTTP)
+    if (request->url.getScheme() == AnyP::PROTO_HTTP)
         return method.respMaybeCacheable();
 
-    if (request->protocol == AnyP::PROTO_GOPHER)
+    if (request->url.getScheme() == AnyP::PROTO_GOPHER)
         return gopherCachable(request);
 
-    if (request->protocol == AnyP::PROTO_CACHE_OBJECT)
+    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)
         return 0;
 
     return 1;
@@ -1516,7 +1515,7 @@ ClientRequestContext::sslBumpAccessCheckDone(const allow_t &answer)
 void
 ClientHttpRequest::processRequest()
 {
-    debugs(85, 4, "clientProcessRequest: " << RequestMethodStr(request->method) << " '" << uri << "'");
+    debugs(85, 4, request->method << ' ' << uri);
 
     if (request->method == Http::METHOD_CONNECT && !redirect.status) {
 #if USE_OPENSSL
@@ -1180,9 +1180,6 @@ _comm_close(int fd, char const *file, int line)
 
     commCallCloseHandlers(fd);
 
-    if (F->pconn.uses && F->pconn.pool)
-        F->pconn.pool->noteUses(F->pconn.uses);
-
     comm_empty_os_read_buffers(fd);
 
     AsyncCall::Pointer completeCall=commCbCall(5,4, "comm_close_complete",
@@ -4,6 +4,7 @@
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
+#include "neighbors.h"
 #include "SquidTime.h"
 
 class CachePeer;
@@ -66,7 +67,7 @@ Comm::Connection::close()
         comm_close(fd);
         fd = -1;
         if (CachePeer *p=getPeer())
-            -- p->stats.conn_open;
+            peerConnClosed(p);
     }
 }
 
@@ -388,10 +388,10 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
 
 #if USE_SQUID_EUI
     if (Eui::TheConfig.euiLookup) {
-        if (conn->remote.isIPv4()) {
-            conn->remoteEui48.lookup(conn->remote);
-        } else if (conn->remote.isIPv6()) {
-            conn->remoteEui64.lookup(conn->remote);
+        if (details->remote.isIPv4()) {
+            details->remoteEui48.lookup(details->remote);
+        } else if (details->remote.isIPv6()) {
+            details->remoteEui64.lookup(details->remote);
         }
     }
 #endif
@@ -568,6 +568,15 @@ errorPageName(int pageId)
     return "ERR_UNKNOWN";	/* should not happen */
 }
 
+ErrorState *
+ErrorState::NewForwarding(err_type type, HttpRequest *request)
+{
+    assert(request);
+    const Http::StatusCode status = request->flags.needValidation ?
+        Http::scGatewayTimeout : Http::scServiceUnavailable;
+    return new ErrorState(type, status, request);
+}
+
 ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
         type(t),
         page_id(t),
@@ -764,8 +773,8 @@ ErrorState::Dump(MemBuf * mb)
         else
             urlpath_or_slash = "/";
 
-        str.Printf("%s " SQUIDSTRINGPH " %s/%d.%d\n",
-                   RequestMethodStr(request->method),
+        str.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
+                   SQUIDSBUFPRINT(request->method.image()),
                    SQUIDSTRINGPRINT(urlpath_or_slash),
                    AnyP::ProtocolType_str[request->http_ver.protocol],
                    request->http_ver.major, request->http_ver.minor);
@@ -940,10 +949,11 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'M':
-        if (request)
-            p = RequestMethodStr(request->method);
-        else if (!building_deny_info_url)
-            p= "[unknown method]";
+        if (request) {
+           const SBuf &m = request->method.image();
+           mb.append(m.rawContent(), m.length());
+        } else if (!building_deny_info_url)
+            p = "[unknown method]";
         break;
 
     case 'o':
@@ -962,7 +972,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'P':
         if (request) {
-            p = AnyP::ProtocolType_str[request->protocol];
+            p = request->url.getScheme().c_str();
         } else if (!building_deny_info_url) {
             p = "[unknown protocol]";
         }
@@ -983,8 +993,8 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
             else
                 urlpath_or_slash = "/";
 
-            mb.Printf("%s " SQUIDSTRINGPH " %s/%d.%d\n",
-                      RequestMethodStr(request->method),
+            mb.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
+                      SQUIDSBUFPRINT(request->method.image()),
                       SQUIDSTRINGPRINT(urlpath_or_slash),
                       AnyP::ProtocolType_str[request->http_ver.protocol],
                       request->http_ver.major, request->http_ver.minor);
@@ -101,6 +101,9 @@ class ErrorState
     ErrorState(); // not implemented.
     ~ErrorState();
 
+    /// Creates a general request forwarding error with the right http_status.
+    static ErrorState *NewForwarding(err_type type, HttpRequest *request);
+
     /**
      * Allocates and initializes an error response
      */
@@ -135,28 +135,30 @@ Eui::Eui48::decode(const char *asc)
     eui[3] = (u_char) a4;
     eui[4] = (u_char) a5;
     eui[5] = (u_char) a6;
+
+    debugs(28, 4, "id=" << (void*)this << " decoded " << asc);
     return true;
 }
 
 bool
 Eui::Eui48::encode(char *buf, const int len)
 {
-    if (len < SZ_EUI48_BUF) return false;
+    if (len < SZ_EUI48_BUF)
+        return false;
 
     snprintf(buf, len, "%02x:%02x:%02x:%02x:%02x:%02x",
              eui[0] & 0xff, eui[1] & 0xff,
              eui[2] & 0xff, eui[3] & 0xff,
              eui[4] & 0xff, eui[5] & 0xff);
+
+    debugs(28, 4, "id=" << (void*)this << " encoded " << buf);
     return true;
 }
 
 // return binary representation of the EUI
 bool
 Eui::Eui48::lookup(const Ip::Address &c)
 {
-#if !_SQUID_WINDOWS_
-#endif /* !_SQUID_WINDOWS_ */
-
     Ip::Address ipAddr = c;
     ipAddr.port(0);
 
@@ -198,6 +200,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
     ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
+    debugs(28, 4, "id=" << (void*)this << " query ARP table");
     if (ioctl(tmpSocket, SIOCGARP, &arpReq) != -1) {
         /* Skip non-ethernet interfaces */
         close(tmpSocket);
@@ -207,7 +210,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
             return false;
         }
 
-        debugs(28, 4, "Got address "<< std::setfill('0') << std::hex <<
+        debugs(28, 4, "id=" << (void*)this << " got address "<< std::setfill('0') << std::hex <<
                std::setw(2) << (arpReq.arp_ha.sa_data[0] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[1] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[2] & 0xff)  << ":" <<
@@ -240,20 +243,22 @@ Eui::Eui48::lookup(const Ip::Address &c)
 
     /* Attempt ARP lookup on each interface */
     offset = 0;
-
+    debugs(28, 4, "id=" << (void*)this << " query ARP on each interface (" << ifc.ifc_len << " found)");
     while (offset < ifc.ifc_len) {
 
         ifr = (struct ifreq *) (ifbuffer + offset);
         offset += sizeof(*ifr);
-        /* Skip loopback and aliased interfaces */
 
-        if (0 == strncmp(ifr->ifr_name, "lo", 2))
+        debugs(28, 4, "id=" << (void*)this << " found interface " << ifr->ifr_name);
+
+        /* Skip loopback and aliased interfaces */
+        if (!strncmp(ifr->ifr_name, "lo", 2))
             continue;
 
-        if (NULL != strchr(ifr->ifr_name, ':'))
+        if (strchr(ifr->ifr_name, ':'))
             continue;
 
-        debugs(28, 4, "Looking up ARP address for " << ipAddr << " on " << ifr->ifr_name);
+        debugs(28, 4, "id=" << (void*)this << " looking up ARP address for " << ipAddr << " on " << ifr->ifr_name);
 
         /* Set up structures for ARP lookup */
 
@@ -284,10 +289,12 @@ Eui::Eui48::lookup(const Ip::Address &c)
         }
 
         /* Skip non-ethernet interfaces */
-        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER)
+        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
+            debugs(28, 4, "id=" << (void*)this << "... not an Ethernet interface");
             continue;
+        }
 
-        debugs(28, 4, "Got address "<< std::setfill('0') << std::hex <<
+        debugs(28, 4, "id=" << (void*)this << " got address "<< std::setfill('0') << std::hex <<
                std::setw(2) << (arpReq.arp_ha.sa_data[0] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[1] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[2] & 0xff)  << ":" <<
@@ -354,6 +361,8 @@ Eui::Eui48::lookup(const Ip::Address &c)
 
         set(arpReq.arp_ha.sa_data, 6);
         return true;
+    } else {
+        close(tmpSocket);
     }
 
 #elif _SQUID_FREEBSD_ || _SQUID_NETBSD_ || _SQUID_OPENBSD_ || _SQUID_DRAGONFLY_ || _SQUID_KFREEBSD_
@@ -528,7 +537,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
     /*
      * Address was not found on any interface
      */
-    debugs(28, 3, HERE << ipAddr << " NOT found");
+    debugs(28, 3, "id=" << (void*)this << ' ' << ipAddr << " NOT found");
 
     clear();
     return false;
@@ -20,9 +20,9 @@ class Eui48
 {
 
 public:
-    Eui48() { clear(); };
-    Eui48(const Eui48 &t) { memcpy(this, &t, sizeof(Eui48)); };
-    ~Eui48() {};
+    Eui48() { clear(); }
+    Eui48(const Eui48 &t) { memcpy(this, &t, sizeof(Eui48)); }
+    ~Eui48() {}
 
     const unsigned char *get(void);
 
@@ -31,9 +31,9 @@ class Eui48
         if (len < SZ_EUI48_BUF) clear();
         memcpy(eui, src, len);
         return true;
-    };
+    }
 
-    void clear() { memset(eui, 0, SZ_EUI48_BUF); };
+    void clear() { memset(eui, 0, SZ_EUI48_BUF); }
 
     /**
      * Decode an ascii representation of an EUI-48 ethernet address.
@@ -18,8 +18,12 @@
 bool
 Eui::Eui64::decode(const char *asc)
 {
-    if (eui64_aton(asc, (struct eui64 *)eui) != 0) return false;
+    if (eui64_aton(asc, (struct eui64 *)eui) != 0) {
+       debugs(28, 4, "id=" << (void*)this << " decode fail on " << asc);
+       return false;
+    }
 
+    debugs(28, 4, "id=" << (void*)this << " ATON decoded " << asc);
     return true;
 }
 
@@ -31,6 +35,7 @@ Eui::Eui64::encode(char *buf, const int len)
     snprintf(buf, len, "%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
              eui[0], eui[1], eui[2], eui[3],
              eui[4], eui[5], eui[6], eui[7]);
+    debugs(28, 4, "id=" << (void*)this << " encoded " << buf);
     return true;
 }
 
@@ -39,7 +44,8 @@ bool
 Eui::Eui64::lookup(const Ip::Address &c)
 {
     /* try to short-circuit slow OS lookups by using SLAAC data */
-    if (lookupSlaac(c)) return true;
+    if (lookupSlaac(c))
+        return true;
 
     // find EUI-64 some other way. NDP table lookup?
     return lookupNdp(c);
@@ -49,15 +55,18 @@ bool
 Eui::Eui64::lookupSlaac(const Ip::Address &c)
 {
     /* RFC 4291 Link-Local unicast addresses which contain SLAAC - usually trustable. */
-    if (c.isSiteLocal6() && c.isSiteLocalAuto() ) {
+    if (c.isSiteLocal6() && c.isSiteLocalAuto()) {
 
         // strip the final 64 bits of the address...
         struct in6_addr tmp;
         c.getInAddr(tmp);
         memcpy(eui, &(tmp.s6_addr[8]), SZ_EUI64_BUF);
-
+        debugs(28, 4, "id=" << (void*)this << " SLAAC decoded " << c);
         return true;
     }
+
+    debugs(28, 4, "id=" << (void*)this << " SLAAC fail on " << c << " SL-6="
+           << (c.isSiteLocal6()?'T':'F') << " AAC-6=" << (c.isSiteLocalAuto()?'T':'F'));
     return false;
 }
 
@@ -73,7 +82,7 @@ Eui::Eui64::lookupNdp(const Ip::Address &c)
     /*
      * Address was not found on any interface
      */
-    debugs(28, 3, HERE << c << " NOT found");
+    debugs(28, 3, "id=" << (void*)this << ' ' << c << " NOT found");
 #endif /* 0 */
 
     clear();
@@ -27,9 +27,9 @@ class Eui64
 {
 
 public:
-    Eui64() { clear(); };
-    Eui64(const Eui64 &t) { memcpy(this, &t, sizeof(Eui64)); };
-    ~Eui64() {};
+    Eui64() { clear(); }
+    Eui64(const Eui64 &t) { memcpy(this, &t, sizeof(Eui64)); }
+    ~Eui64() {}
 
     const unsigned char *get(void);
 
@@ -38,9 +38,9 @@ class Eui64
         if (len < SZ_EUI64_BUF) clear();
         memcpy(eui, src, len);
         return true;
-    };
+    }
 
-    void clear() { memset(eui, 0, SZ_EUI64_BUF); };
+    void clear() { memset(eui, 0, SZ_EUI64_BUF); }
 
     /**
      * Decode an ascii representation of an EUI-64 address.
@@ -930,23 +930,20 @@ ACLExternal::match(ACLChecklist *checklist)
     }
 }
 
-wordlist *
+SBufList
 ACLExternal::dump() const
 {
     external_acl_data const *acl = data;
-    wordlist *result = NULL;
-    wordlist *arg;
-    MemBuf mb;
-    mb.init();
-    mb.Printf("%s", acl->def->name);
+    SBufList rv;
+    rv.push_back(SBuf(acl->def->name));
 
-    for (arg = acl->arguments; arg; arg = arg->next) {
-        mb.Printf(" %s", arg->key);
+    for (wordlist *arg = acl->arguments; arg; arg = arg->next) {
+        SBuf s;
+        s.Printf(" %s", arg->key);
+        rv.push_back(s);
     }
 
-    wordlistAdd(&result, mb.buf);
-    mb.clean();
-    return result;
+    return rv;
 }
 
 /******************************************************************
@@ -1048,7 +1045,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 
         case _external_acl_format::EXT_ACL_PROTO:
-            str = AnyP::ProtocolType_str[request->protocol];
+            str = request->url.getScheme().c_str();
             break;
 
         case _external_acl_format::EXT_ACL_PORT:
@@ -1061,7 +1058,11 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 
         case _external_acl_format::EXT_ACL_METHOD:
-            str = RequestMethodStr(request->method);
+            {
+                const SBuf &s = request->method.image();
+                sb.append(s.rawContent(), s.length());
+            }
+            str = sb.termedBuf();
             break;
 
         case _external_acl_format::EXT_ACL_HEADER_REQUEST:
@@ -122,8 +122,7 @@ fde::remoteAddr() const
 }
 
 void
-fde::noteUse(PconnPool *pool)
+fde::noteUse()
 {
     ++ pconn.uses;
-    pconn.pool = pool;
 }
@@ -42,7 +42,6 @@
 class ClientInfo;
 #endif
 
-class PconnPool;
 class dwrite_q;
 class _fde_disk
 {
@@ -70,7 +69,7 @@ class fde
     char const *remoteAddr() const;
     void dumpStats (StoreEntry &, int);
     bool readPending(int);
-    void noteUse(PconnPool *);
+    void noteUse();
 
 public:
 
@@ -110,7 +109,6 @@ class fde
 
     struct {
         int uses;                   /* ie # req's over persistent conn */
-        PconnPool *pool;
     } pconn;
 
 #if USE_DELAY_POOLS
@@ -167,7 +165,6 @@ class fde
         bytes_read = 0;
         bytes_written = 0;
         pconn.uses = 0;
-        pconn.pool = NULL;
 #if USE_DELAY_POOLS
         clientInfo = NULL;
 #endif
@@ -916,7 +916,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_CLIENT_REQ_METHOD:
             if (al->request) {
-                out = al->request->method.image();
+                const SBuf &s = al->request->method.image();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -952,7 +954,14 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_REQUEST_METHOD:
-            out = al->_private.method_str;
+            if (al->_private.method_str) // ICP, HTCP method code
+                out = al->_private.method_str;
+            else {
+                const SBuf &s = al->http.method.image();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
+                quote = 1;
+            }
             break;
 
         case LFT_REQUEST_URI:
@@ -967,7 +976,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_SERVER_REQ_METHOD:
             if (al->adapted_request) {
-                out = al->adapted_request->method.image();
+                const SBuf &s = al->adapted_request->method.image();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -1091,31 +1102,36 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 #endif
 
         case LFT_NOTE:
-            if (fmt->data.string) {
+            tmp[0] = fmt->data.header.separator;
+            tmp[1] = '\0';
+            if (fmt->data.header.header && *fmt->data.header.header) {
+                const char *separator = tmp;
 #if USE_ADAPTATION
                 Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL) {
-                    if (const char *meta = ah->metaHeaders->find(fmt->data.string))
+                    if (const char *meta = ah->metaHeaders->find(fmt->data.header.header, separator))
                         sb.append(meta);
                 }
 #endif
                 if (al->notes != NULL) {
-                    if (const char *note = al->notes->find(fmt->data.string)) {
+                    if (const char *note = al->notes->find(fmt->data.header.header, separator)) {
                         if (sb.size())
-                            sb.append(", ");
+                            sb.append(separator);
                         sb.append(note);
                     }
                 }
                 out = sb.termedBuf();
                 quote = 1;
             } else {
+                // if no argument given use default "\r\n" as notes separator
+                const char *separator = fmt->data.string ? tmp : "\r\n";
 #if USE_ADAPTATION
                 Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL && !ah->metaHeaders->empty())
-                    sb.append(ah->metaHeaders->toString());
+                    sb.append(ah->metaHeaders->toString(separator));
 #endif
                 if (al->notes != NULL && !al->notes->empty())
-                    sb.append(al->notes->toString());
+                    sb.append(al->notes->toString(separator));
 
                 out = sb.termedBuf();
                 quote = 1;
@@ -407,6 +407,8 @@ Format::Token::parse(const char *def, Quoting *quoting)
 
     case LFT_REPLY_HEADER:
 
+    case LFT_NOTE:
+
         if (data.string) {
             char *header = data.string;
             char *cp = strchr(header, ':');
@@ -541,6 +543,25 @@ Format::Token::parse(const char *def, Quoting *quoting)
     return (cur - def);
 }
 
+Format::Token::Token() : type(LFT_NONE),
+                         label(NULL),
+                         widthMin(-1),
+                         widthMax(-1),
+                         quote(LOG_QUOTE_NONE),
+                         left(false),
+                         space(false),
+                         zero(false),
+                         divisor(1),
+                         next(NULL)
+{
+    data.string = NULL;
+    data.header.header = NULL; 
+    data.header.element = NULL;
+    data.header.separator = ',';
+}
+
+
+
 Format::Token::~Token()
 {
     label = NULL; // drop reference to global static.
@@ -27,18 +27,7 @@ class TokenTableEntry;
 class Token
 {
 public:
-    Token() : type(LFT_NONE),
-            label(NULL),
-            widthMin(-1),
-            widthMax(-1),
-            quote(LOG_QUOTE_NONE),
-            left(false),
-            space(false),
-            zero(false),
-            divisor(1),
-            next(NULL)
-    { data.string = NULL; }
-
+    Token();
     ~Token();
 
     /// Initialize the format token registrations
@@ -52,7 +41,7 @@ class Token
 
     ByteCode_t type;
     const char *label;
-    union {
+    struct {
         char *string;
 
         struct {
@@ -31,6 +31,7 @@
  */
 
 #include "squid.h"
+#include "acl/FilledChecklist.h"
 #include "comm.h"
 #include "comm/ConnOpener.h"
 #include "comm/TcpAcceptor.h"
@@ -2560,8 +2561,13 @@ ftpSendPassive(FtpStateData * ftpState)
         ftpState->state = SENT_PASV;
         break;
 
-    default:
-        if (!Config.Ftp.epsv) {
+    default: {
+        bool doEpsv = true;
+        if (Config.accessList.ftp_epsv) {
+            ACLFilledChecklist checklist(Config.accessList.ftp_epsv, ftpState->fwd->request, NULL);
+            doEpsv = (checklist.fastCheck() == ACCESS_ALLOWED);
+        }
+        if (!doEpsv) {
             debugs(9, 5, HERE << "EPSV support manually disabled. Sending PASV for FTP Channel (" << ftpState->ctrl.conn->remote <<")");
             snprintf(cbuf, CTRL_BUFLEN, "PASV\r\n");
             ftpState->state = SENT_PASV;
@@ -2583,6 +2589,7 @@ ftpSendPassive(FtpStateData * ftpState)
                 ftpState->state = SENT_EPSV_1;
             }
         }
+    }
         break;
     }
 
@@ -3725,7 +3732,7 @@ ftpUrlWith2f(HttpRequest * request)
 {
     String newbuf = "%2f";
 
-    if (request->protocol != AnyP::PROTO_FTP)
+    if (request->url.getScheme() != AnyP::PROTO_FTP)
         return NULL;
 
     if ( request->urlpath[0]=='/' ) {
@@ -26,6 +26,7 @@ typedef enum {
     SOURCEHASH_PARENT,
     PINNED,
     ORIGINAL_DST,
+    STANDBY_POOL,
     HIER_MAX
 } hier_code;
 
@@ -168,7 +168,7 @@ class htcpSpecifier : public StoreClient
 
     void setFrom(Ip::Address &from);
     void setDataHeader(htcpDataHeader *);
-    char *method;
+    const char *method;
     char *uri;
     char *version;
     char *req_hdrs;
@@ -1577,7 +1577,8 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
     stuff.f1 = 1;
     stuff.response = 0;
     stuff.msg_id = ++msg_id_counter;
-    stuff.S.method = (char *) RequestMethodStr(req->method);
+    SBuf sb = req->method.image();
+    stuff.S.method = sb.c_str();
     stuff.S.uri = (char *) e->url();
     stuff.S.version = vbuf;
     HttpStateData::httpBuildRequestHeader(req, e, NULL, &hdr, flags);
@@ -1640,7 +1641,8 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
         stuff.reason = 0;
         break;
     }
-    stuff.S.method = (char *) RequestMethodStr(req->method);
+    SBuf sb = req->method.image();
+    stuff.S.method = sb.c_str();
     if (e == NULL || e->mem_obj == NULL) {
         if (uri == NULL) {
             return;
@@ -1046,7 +1046,7 @@ HttpStateData::statusIfComplete() const
      * connection.
      */
     if (!flags.request_sent) {
-        debugs(11, 2, "statusIfComplete: Request not yet fully sent \"" << RequestMethodStr(request->method) << " " << entry->url() << "\"" );
+        debugs(11, 2, "Request not yet fully sent " << request->method << ' ' << entry->url());
         return COMPLETE_NONPERSISTENT_MSG;
     }
 
@@ -1807,7 +1807,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     if (!hdr_out->has(HDR_HOST)) {
         if (request->peer_domain) {
             hdr_out->putStr(HDR_HOST, request->peer_domain);
-        } else if (request->port == urlDefaultPort(request->protocol)) {
+        } else if (request->port == urlDefaultPort(request->url.getScheme())) {
             /* use port# only if not default */
             hdr_out->putStr(HDR_HOST, request->GetHost());
         } else {
@@ -1865,7 +1865,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
-        if (flags.front_end_https == 1 || request->protocol == AnyP::PROTO_HTTPS)
+        if (flags.front_end_https == 1 || request->url.getScheme() == AnyP::PROTO_HTTPS)
             hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
     }
 
@@ -1958,7 +1958,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
         else {
             /* use port# only if not default */
 
-            if (request->port == urlDefaultPort(request->protocol)) {
+            if (request->port == urlDefaultPort(request->url.getScheme())) {
                 hdr_out->putStr(HDR_HOST, request->GetHost());
             } else {
                 httpHeaderPutStrf(hdr_out, HDR_HOST, "%s:%d",
@@ -2117,8 +2117,8 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
         url = urlCanonical(request);
     else
         url = request->urlpath.termedBuf();
-    mb->Printf("%s %s %s/%d.%d\r\n",
-               RequestMethodStr(request->method),
+    mb->Printf(SQUIDSBUFPH " %s %s/%d.%d\r\n",
+               SQUIDSBUFPRINT(request->method.image()),
                url && *url ? url : "/",
                AnyP::ProtocolType_str[httpver.protocol],
                httpver.major,httpver.minor);
@@ -2269,7 +2269,7 @@ HttpStateData::getMoreRequestBody(MemBuf &buf)
 void
 httpStart(FwdState *fwd)
 {
-    debugs(11, 3, "httpStart: \"" << RequestMethodStr(fwd->request->method) << " " << fwd->entry->url() << "\"" );
+    debugs(11, 3, fwd->request->method << ' ' << fwd->entry->url());
     AsyncJob::Start(new HttpStateData(fwd));
 }
 
@@ -19,7 +19,7 @@ libsquid_http_la_SOURCES = \
 	StatusLine.h
 
 MethodType.cc: MethodType.h $(top_srcdir)/src/mk-string-arrays.awk
-	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk < $(srcdir)/MethodType.h | \
+	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk sbuf=1 < $(srcdir)/MethodType.h | \
 		sed -e 's%METHOD_%%' -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
 
 CLEANFILES += MethodType.cc
@@ -1,6 +1,8 @@
 #ifndef SQUID_SRC_HTTP_METHODTYPE_H
 #define SQUID_SRC_HTTP_METHODTYPE_H
 
+#include "SBuf.h"
+
 namespace Http
 {
 
@@ -11,12 +13,6 @@ namespace Http
 typedef enum _method_t {
     METHOD_NONE = 0,
 
-#if NO_SPECIAL_HANDLING
-    // RFC 2068
-    METHOD_LINK,
-    METHOD_UNLINK,
-#endif
-
     // RFC 2616 (HTTP)
     METHOD_GET,
     METHOD_POST,
@@ -27,6 +23,12 @@ typedef enum _method_t {
     METHOD_OPTIONS,
     METHOD_DELETE,
 
+#if NO_SPECIAL_HANDLING
+    // RFC 2068
+    METHOD_LINK,
+    METHOD_UNLINK,
+#endif
+
     // RFC 3253
     METHOD_CHECKOUT,
     METHOD_CHECKIN,
@@ -83,12 +85,12 @@ typedef enum _method_t {
     METHOD_ENUM_END  // MUST be last, (yuck) this is used as an array-initialization index constant!
 } MethodType;
 
-extern const char *MethodType_str[];
+extern const SBuf MethodType_sb[];
 
-inline const char*
+inline const SBuf &
 MethodStr(const MethodType m)
 {
-    return MethodType_str[m];
+    return MethodType_sb[m];
 }
 
 }; // namespace Http
@@ -20,20 +20,11 @@ operator++ (Http::MethodType &aMethod)
  * or from a range of chars, * such as "GET" from "GETFOOBARBAZ"
  * (pass in pointer to G and pointer to F.)
  */
-HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod (Http::METHOD_NONE)
+HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod(Http::METHOD_NONE)
 {
     if (begin == NULL)
         return;
 
-    /*
-     * This check for '%' makes sure that we don't
-     * match one of the extension method placeholders,
-     * which have the form %EXT[0-9][0-9]
-     */
-
-    if (*begin == '%')
-        return;
-
     /*
      * if e is NULL, b must be NULL terminated and we
      * make e point to the first whitespace character
@@ -42,40 +33,40 @@ HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMe
     if (NULL == end)
         end = begin + strcspn(begin, w_space);
 
-    if (end == begin) {
-        theMethod = Http::METHOD_NONE;
+    if (end == begin)
         return;
-    }
 
+    // TODO: Optimize this linear search.
     for (++theMethod; theMethod < Http::METHOD_ENUM_END; ++theMethod) {
         // RFC 2616 section 5.1.1 - Method names are case-sensitive
         // NP: this is not a HTTP_VIOLATIONS case since there is no MUST/SHOULD involved.
-        if (0 == strncasecmp(begin, Http::MethodType_str[theMethod], end-begin)) {
+        if (0 == image().caseCmp(begin, end-begin)) {
 
             // relaxed parser allows mixed-case and corrects them on output
             if (Config.onoff.relaxed_header_parser)
                 return;
 
-            if (0 == strncmp(begin, Http::MethodType_str[theMethod], end-begin))
+            if (0 == image().cmp(begin, end-begin))
                 return;
         }
     }
 
     // if method not found and method string is not null then it is other method
     theMethod = Http::METHOD_OTHER;
-    theImage.limitInit(begin,end-begin);
+    theImage.assign(begin, end-begin);
 }
 
-char const*
+const SBuf &
 HttpRequestMethod::image() const
 {
+    static const SBuf methodOther("METHOD_OTHER");
     if (Http::METHOD_OTHER != theMethod) {
-        return Http::MethodType_str[theMethod];
+        return Http::MethodType_sb[theMethod];
     } else {
-        if (theImage.size()>0) {
-            return theImage.termedBuf();
+        if (!theImage.isEmpty()) {
+            return theImage;
         } else {
-            return "METHOD_OTHER";
+            return methodOther;
         }
     }
 }
@@ -3,7 +3,9 @@
 
 #include "http/forward.h"
 #include "http/MethodType.h"
-#include "SquidString.h"
+#include "SBuf.h"
+
+class SquidConfig;
 
 #include <iosfwd>
 
@@ -35,7 +37,7 @@ class HttpRequestMethod : public RefCountable
 
     HttpRequestMethod & operator = (Http::MethodType const aMethod) {
         theMethod = aMethod;
-        theImage.clean();
+        theImage.clear();
         return *this;
     }
 
@@ -67,8 +69,8 @@ class HttpRequestMethod : public RefCountable
      */
     Http::MethodType id() const { return theMethod; }
 
-    /** Get a char string representation of the method. */
-    char const * image() const;
+    /** Get a string representation of the method. */
+    const SBuf &image() const;
 
     /// Whether this method is defined as a "safe" in HTTP/1.1
     /// see RFC 2616 section 9.1.1
@@ -106,10 +108,8 @@ class HttpRequestMethod : public RefCountable
     bool purgesOthers() const;
 
 private:
-    static const char *RequestMethodStr[];
-
     Http::MethodType theMethod; ///< Method type
-    String theImage;     ///< Used for storing the Http::METHOD_OTHER only. A copy of the parsed method text.
+    SBuf theImage;     ///< Used for storing the Http::METHOD_OTHER only. A copy of the parsed method text.
 };
 
 inline std::ostream &
@@ -119,16 +119,4 @@ operator << (std::ostream &os, HttpRequestMethod const &method)
     return os;
 }
 
-inline const char*
-RequestMethodStr(const Http::MethodType m)
-{
-    return HttpRequestMethod(m).image();
-}
-
-inline const char*
-RequestMethodStr(const HttpRequestMethod& m)
-{
-    return m.image();
-}
-
 #endif /* SQUID_HTTPREQUESTMETHOD_H */
@@ -103,7 +103,7 @@ ACLIdent::match(ACLChecklist *cl)
     return -1;
 }
 
-wordlist *
+SBufList
 ACLIdent::dump() const
 {
     return data->dump();
@@ -70,7 +70,7 @@ class ACLIdent : public ACL
     virtual bool isProxyAuth() const {return true;}
 
     virtual int match(ACLChecklist *checklist);
-    virtual wordlist *dump() const;
+    virtual SBufList dump() const;
     virtual bool empty () const;
     virtual ACL *clone()const;
 
@@ -73,6 +73,7 @@ internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request,
         entry->append(msgbuf, strlen(msgbuf));
         entry->complete();
     } else if (0 == strncmp(upath, "/squid-internal-mgr/", 20)) {
+        debugs(17, 2, "calling CacheManager due to URL-path /squid-internal-mgr/");
         CacheManager::GetInstance()->Start(clientConn, request, entry);
     } else {
         debugObj(76, 1, "internalStart: unknown request:\n",
@@ -243,8 +243,8 @@ Ip::Address::isSiteLocal6() const
 bool
 Ip::Address::isSiteLocalAuto() const
 {
-    return mSocketAddr_.sin6_addr.s6_addr[10] == static_cast<uint8_t>(0xff) &&
-           mSocketAddr_.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xfe);
+    return mSocketAddr_.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xff) &&
+           mSocketAddr_.sin6_addr.s6_addr[12] == static_cast<uint8_t>(0xfe);
 }
 
 bool
@@ -67,12 +67,18 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s%s:%s%s",
+    static SBuf method;
+    if (al->_private.method_str)
+        method.assign(al->_private.method_str);
+    else
+        method = al->http.method.image();
+
+    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s%s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
                   Time::FormatHttpd(squid_curtime),
-                  al->_private.method_str,
+                  SQUIDSBUFPRINT(method),
                   al->url,
                   AnyP::ProtocolType_str[al->http.version.protocol],
                   al->http.version.major, al->http.version.minor,
@@ -54,12 +54,18 @@ Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %" PRId64 " %s%s:%s%s",
+    static SBuf method;
+    if (al->_private.method_str)
+        method.assign(al->_private.method_str);
+    else
+        method = al->http.method.image();
+
+    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " %s%s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
                   Time::FormatHttpd(squid_curtime),
-                  al->_private.method_str,
+                  SQUIDSBUFPRINT(method),
                   al->url,
                   AnyP::ProtocolType_str[al->http.version.protocol],
                   al->http.version.major, al->http.version.minor,
@@ -70,7 +70,13 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " %s %s %s %s%s/%s %s%s",
+    static SBuf method;
+    if (al->_private.method_str)
+        method.assign(al->_private.method_str);
+    else
+        method = al->http.method.image();
+
+    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " " SQUIDSBUFPH " %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   al->cache.msec,
@@ -79,7 +85,7 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   al->http.statusSfx(),
                   al->http.code,
                   al->http.clientReplySz.messageTotal(),
-                  al->_private.method_str,
+                  SQUIDSBUFPRINT(method),
                   al->url,
                   user ? user : dash_str,
                   al->hier.ping.timedout ? "TIMEOUT_" : "",
@@ -109,7 +109,7 @@ accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist * check
     else if (al->htcp.opcode)
         al->_private.method_str = al->htcp.opcode;
     else
-        al->_private.method_str = RequestMethodStr(al->http.method);
+        al->_private.method_str = NULL;
 
     if (al->hier.host[0] == '\0')
         xstrncpy(al->hier.host, dash_str, SQUIDHOSTNAMELEN);
@@ -1907,10 +1907,10 @@ SquidShutdown()
 
     comm_exit();
 
-    memClean();
-
     RunRegisteredHere(RegisteredRunner::finishShutdown);
 
+    memClean();
+
     if (IamPrimaryProcess()) {
         if (Config.pidFilename && strcmp(Config.pidFilename, "none") != 0) {
             enter_suid();
@@ -33,7 +33,7 @@ void
 Mgr::ActionParams::pack(Ipc::TypedMsgHdr &msg) const
 {
     msg.putString(httpUri);
-    String foo(httpMethod.image());
+    String foo(httpMethod.image().toString());
     msg.putString(foo);
     msg.putPod(httpFlags);
     msg.putString(httpOrigin);
@@ -21,7 +21,7 @@ BEGIN {
 }
 
 # when namespace is encountered store it
-/^namespace [a-zA-Z]+/	{
+/^namespace *[a-zA-Z]+/	{
 	nspath = tolower($2) "/"		# nested folder
 	namespace = $2				# code namespace reconstruct
 	next
@@ -33,7 +33,8 @@ codeSkip == 1		{ next }
 
 /^[ \t]*[A-Z]/ {
 	split($1, t, ",")			# remove ,
-	Element[++e] = t[1]
+	if (sbuf) Element[++e] = "SBuf(\"" t[1] "\")"
+	else Element[++e] = "\"" t[1] "\""
 	next
 }
 
@@ -49,18 +50,20 @@ codeSkip == 1		{ next }
 	type = t[1]
         codeSkip = 1
 
+	if (sbuf) print "#include \"SBuf.h\""
 	print "#include \"" nspath type ".h\""
 
 	# if namesapce is not empty ??
 	if (namespace) print "namespace " namespace
 	if (namespace) print "{"
 
-	print "\nconst char *" type "_str[] = {"
+	if (sbuf) print "\nconst SBuf " type "_sb[] = {"
+	else print "\nconst char * " type "_str[] = {"
 	for ( i = 1; i < e; ++i)
 		if (Wrapper[i]) print Wrapper[i]
-		else print "\t\"" Element[i] "\","
+		else print "\t" Element[i] ","
 
-	print "\t\"" Element[i] "\""
+	print "\t" Element[i]
 	print "};"
 	if (namespace) print "}; // namespace " namespace
 	next
@@ -54,7 +54,9 @@
 #include "multicast.h"
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
+#include "pconn.h"
 #include "PeerDigest.h"
+#include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
@@ -246,13 +248,46 @@ peerWouldBePinged(const CachePeer * p, HttpRequest * request)
     return 1;
 }
 
+bool
+peerCanOpenMore(const CachePeer *p)
+{
+    const int effectiveLimit = p->max_conn <= 0 ? Squid_MaxFD : p->max_conn;
+    const int remaining = effectiveLimit - p->stats.conn_open;
+    debugs(15, 7, remaining << '=' << effectiveLimit << '-' << p->stats.conn_open);
+    return remaining > 0;
+}
+
+bool
+peerHasConnAvailable(const CachePeer *p)
+{
+    // Standby connections can be used without opening new connections.
+    const int standbys = p->standby.pool ? p->standby.pool->count() : 0;
+
+    // XXX: Some idle pconns can be used without opening new connections.
+    // Complication: Idle pconns cannot be reused for some requests.
+    const int usableIdles = 0;
+
+    const int available = standbys + usableIdles;
+    debugs(15, 7, available << '=' << standbys << '+' << usableIdles);
+    return available > 0;
+}
+
+void
+peerConnClosed(CachePeer *p)
+{
+    --p->stats.conn_open;
+    if (p->standby.waitingForClose && peerCanOpenMore(p)) {
+        p->standby.waitingForClose = false;
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "conn closed");
+    }
+}
+
 /* Return TRUE if it is okay to send an HTTP request to this CachePeer. */
 int
 peerHTTPOkay(const CachePeer * p, HttpRequest * request)
 {
-    if (p->max_conn)
-        if (p->stats.conn_open >= p->max_conn)
-            return 0;
+    if (!peerCanOpenMore(p) && !peerHasConnAvailable(p))
+        return 0;
 
     if (!peerAllowedToUse(p, request))
         return 0;
@@ -446,6 +481,8 @@ peerAlive(CachePeer *p)
         debugs(15, DBG_IMPORTANT, "Detected REVIVED " << neighborTypeStr(p) << ": " << p->name);
         p->stats.logged_state = PEER_ALIVE;
         peerClearRR();
+        if (p->standby.mgr.valid())
+            PeerPoolMgr::Checkpoint(p->standby.mgr, "revived peer");
     }
 
     p->stats.last_reply = squid_curtime;
@@ -1190,6 +1227,9 @@ peerNoteDigestGone(CachePeer * p)
 static void
 peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 {
+    // TODO: connections to no-longer valid IP addresses should be
+    // closed when we can detect such IP addresses.
+
     CachePeer *p = (CachePeer *)data;
 
     int j;
@@ -1234,6 +1274,8 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
             eventAddIsh("netdbExchangeStart", netdbExchangeStart, p, 30.0, 1);
 #endif
 
+    if (p->standby.mgr.valid())
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "resolved peer");
 }
 
 static void
@@ -1565,6 +1607,8 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
 
     if (p->max_conn > 0)
         storeAppendPrintf(sentry, " max-conn=%d", p->max_conn);
+    if (p->standby.limit > 0)
+        storeAppendPrintf(sentry, " standby=%d", p->standby.limit);
 
     if (p->options.originserver)
         storeAppendPrintf(sentry, " originserver");
@@ -81,6 +81,13 @@ void peerConnectSucceded(CachePeer *);
 void dump_peer_options(StoreEntry *, CachePeer *);
 int peerHTTPOkay(const CachePeer *, HttpRequest *);
 
+/// Whether we can open new connections to the peer (e.g., despite max-conn)
+bool peerCanOpenMore(const CachePeer *p);
+/// Whether the peer has idle or standby connections that can be used now
+bool peerHasConnAvailable(const CachePeer *p);
+/// Notifies peer of an associated connection closure.
+void peerConnClosed(CachePeer *p);
+
 CachePeer *whichPeer(const Ip::Address &from);
 
 #endif /* SQUID_NEIGHBORS_H_ */
@@ -31,13 +31,16 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "mgr/Registration.h"
+#include "neighbors.h"
 #include "pconn.h"
+#include "PeerPoolMgr.h"
 #include "SquidConfig.h"
 #include "Store.h"
 
@@ -64,6 +67,11 @@ IdleConnList::~IdleConnList()
     if (parent_)
         parent_->unlinkList(this);
 
+    if (size_) {
+        parent_ = NULL; // prevent reentrant notifications and deletions
+        closeN(size_);
+    }
+
     delete[] theList_;
 
     xfree(hash.key);
@@ -292,6 +300,8 @@ IdleConnList::findAndClose(const Comm::ConnectionPointer &conn)
 {
     const int index = findIndexOf(conn);
     if (index >= 0) {
+        if (parent_)
+            parent_->notifyManager("idle conn closure");
         /* might delete this */
         removeAt(index);
         clearHandlers(conn);
@@ -366,15 +376,17 @@ PconnPool::dumpHash(StoreEntry *e) const
     hash_first(hid);
 
     int i = 0;
-    for (hash_link *walker = hid->next; walker; walker = hash_next(hid)) {
+    for (hash_link *walker = hash_next(hid); walker; walker = hash_next(hid)) {
         storeAppendPrintf(e, "\t item %d:\t%s\n", i, (char *)(walker->key));
         ++i;
     }
 }
 
 /* ========== PconnPool PUBLIC FUNCTIONS ============================================ */
 
-PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
+PconnPool::PconnPool(const char *aDescr, const CbcPointer<PeerPoolMgr> &aMgr):
+        table(NULL), descr(aDescr),
+        mgr(aMgr),
         theCount(0)
 {
     int i;
@@ -386,10 +398,18 @@ PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
     PconnModule::GetInstance()->add(this);
 }
 
+static void
+DeleteIdleConnList(void *hashItem)
+{
+    delete reinterpret_cast<IdleConnList*>(hashItem);
+}
+
 PconnPool::~PconnPool()
 {
-    descr = NULL;
+    PconnModule::GetInstance()->remove(this);
+    hashFreeItems(table, &DeleteIdleConnList);
     hashFreeMemory(table);
+    descr = NULL;
 }
 
 void
@@ -404,6 +424,7 @@ PconnPool::push(const Comm::ConnectionPointer &conn, const char *domain)
         debugs(48, 3, HERE << "Squid is shutting down. Refusing to do anything");
         return;
     }
+    // TODO: also close used pconns if we exceed peer max-conn limit
 
     const char *aKey = key(conn, domain);
     IdleConnList *list = (IdleConnList *) hash_lookup(table, aKey);
@@ -423,35 +444,64 @@ PconnPool::push(const Comm::ConnectionPointer &conn, const char *domain)
     snprintf(desc, FD_DESC_SZ, "Idle server: %s", aKey);
     fd_note(conn->fd, desc);
     debugs(48, 3, HERE << "pushed " << conn << " for " << aKey);
+
+    // successful push notifications resume multi-connection opening sequence
+    notifyManager("push");
 }
 
 Comm::ConnectionPointer
-PconnPool::pop(const Comm::ConnectionPointer &destLink, const char *domain, bool isRetriable)
+PconnPool::pop(const Comm::ConnectionPointer &dest, const char *domain, bool keepOpen)
 {
-    const char * aKey = key(destLink, domain);
+
+    const char * aKey = key(dest, domain);
 
     IdleConnList *list = (IdleConnList *)hash_lookup(table, aKey);
     if (list == NULL) {
         debugs(48, 3, HERE << "lookup for key {" << aKey << "} failed.");
+        // failure notifications resume standby conn creation after fdUsageHigh
+        notifyManager("pop failure");
         return Comm::ConnectionPointer();
     } else {
-        debugs(48, 3, HERE << "found " << hashKeyStr(&list->hash) << (isRetriable?"(to use)":"(to kill)") );
+        debugs(48, 3, HERE << "found " << hashKeyStr(&list->hash) <<
+               (keepOpen ? " to use" : " to kill"));
     }
 
     /* may delete list */
-    Comm::ConnectionPointer temp = list->findUseable(destLink);
-    if (!isRetriable && Comm::IsConnOpen(temp))
-        temp->close();
+    Comm::ConnectionPointer popped = list->findUseable(dest);
+    if (!keepOpen && Comm::IsConnOpen(popped))
+        popped->close();
+
+    // successful pop notifications replenish standby connections pool
+    notifyManager("pop");
+    return popped;
+}
 
-    return temp;
+void
+PconnPool::notifyManager(const char *reason)
+{
+    if (mgr.valid())
+        PeerPoolMgr::Checkpoint(mgr, reason);
 }
 
 void
-PconnPool::closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain)
+PconnPool::closeN(int n)
 {
-    // TODO: optimize: we can probably do hash_lookup just once
-    for (int i = 0; i < n; ++i)
-        pop(destLink, domain, false); // may fail!
+    hash_table *hid = table;
+    hash_first(hid);
+
+    // close N connections, one per list, to treat all lists "fairly"
+    for (int i = 0; i < n && count(); ++i) {
+
+        hash_link *current = hash_next(hid);
+        if (!current) {
+            hash_first(hid);
+            current = hash_next(hid);
+            Must(current); // must have one because the count() was positive
+        }
+
+        // may delete current
+        reinterpret_cast<IdleConnList*>(current)->closeN(1);
+    }
 }
 
 void
@@ -477,11 +527,8 @@ PconnPool::noteUses(int uses)
  * This simple class exists only for the cache manager
  */
 
-PconnModule::PconnModule() : pools(NULL), poolCount(0)
+PconnModule::PconnModule(): pools()
 {
-    pools = (PconnPool **) xcalloc(MAX_NUM_PCONN_POOLS, sizeof(*pools));
-//TODO: re-link to MemPools. WAS:    pconn_fds_pool = memPoolCreate("pconn_fds", PCONN_FDS_SZ * sizeof(int));
-    debugs(48, DBG_CRITICAL, "persistent connection module initialized");
     registerWithCacheManager();
 }
 
@@ -505,21 +552,26 @@ PconnModule::registerWithCacheManager(void)
 void
 PconnModule::add(PconnPool *aPool)
 {
-    assert(poolCount < MAX_NUM_PCONN_POOLS);
-    *(pools+poolCount) = aPool;
-    ++poolCount;
+    pools.insert(aPool);
 }
 
 void
-PconnModule::dump(StoreEntry *e)
+PconnModule::remove(PconnPool *aPool)
 {
-    int i;
+    pools.erase(aPool);
+}
 
-    for (i = 0; i < poolCount; ++i) {
+void
+PconnModule::dump(StoreEntry *e)
+{
+    typedef Pools::const_iterator PCI;
+    int i = 0; // TODO: Why number pools if they all have names?
+    for (PCI p = pools.begin(); p != pools.end(); ++p, ++i) {
+        // TODO: Let each pool dump itself the way it wants to.
         storeAppendPrintf(e, "\n Pool %d Stats\n", i);
-        (*(pools+i))->dumpHist(e);
+        (*p)->dumpHist(e);
         storeAppendPrintf(e, "\n Pool %d Hash Table\n",i);
-        (*(pools+i))->dumpHash(e);
+        (*p)->dumpHash(e);
     }
 }
 
@@ -1,6 +1,9 @@
 #ifndef SQUID_PCONN_H
 #define SQUID_PCONN_H
 
+#include "base/CbcPointer.h"
+#include <set>
+
 /**
  \defgroup PConnAPI Persistent Connection API
  \ingroup Component
@@ -9,6 +12,7 @@
  */
 
 class PconnPool;
+class PeerPoolMgr;
 
 /* for CBDATA_CLASS2() macros */
 #include "cbdata.h"
@@ -17,9 +21,6 @@ class PconnPool;
 /* for IOCB */
 #include "comm.h"
 
-/// \ingroup PConnAPI
-#define MAX_NUM_PCONN_POOLS 10
-
 /// \ingroup PConnAPI
 #define PCONN_HIST_SZ (1<<16)
 
@@ -106,38 +107,46 @@ class PconnPool
 {
 
 public:
-    PconnPool(const char *);
+    PconnPool(const char *aDescription, const CbcPointer<PeerPoolMgr> &aMgr);
     ~PconnPool();
 
     void moduleInit();
     void push(const Comm::ConnectionPointer &serverConn, const char *domain);
 
     /**
-     * Updates destLink to point at an existing open connection if available and retriable.
-     * Otherwise, return false.
+     * Returns either a pointer to a popped connection to dest or nil.
+     * Closes the connection before returning its pointer unless keepOpen.
      *
-     * We close available persistent connection if the caller transaction is not
-     * retriable to avoid having a growing number of open connections when many
-     * transactions create persistent connections but are not retriable.
+     * A caller with a non-retriable transaction should set keepOpen to false
+     * and call pop() anyway, even though the caller does not want a pconn.
+     * This forces us to close an available persistent connection, avoiding
+     * creating a growing number of open connections when many transactions 
+     * create (and push) persistent connections but are not retriable and,
+     * hence, do not need to pop a connection.
      */
-    Comm::ConnectionPointer pop(const Comm::ConnectionPointer &destLink, const char *domain, bool retriable);
+    Comm::ConnectionPointer pop(const Comm::ConnectionPointer &dest, const char *domain, bool keepOpen);
     void count(int uses);
     void dumpHist(StoreEntry *e) const;
     void dumpHash(StoreEntry *e) const;
     void unlinkList(IdleConnList *list);
     void noteUses(int uses);
-    void closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain);
+    /// closes any n connections, regardless of their destination
+    void closeN(int n);
     int count() const { return theCount; }
     void noteConnectionAdded() { ++theCount; }
     void noteConnectionRemoved() { assert(theCount > 0); --theCount; }
 
+    // sends an async message to the pool manager, if any
+    void notifyManager(const char *reason);
+
 private:
 
     static const char *key(const Comm::ConnectionPointer &destLink, const char *domain);
 
     int hist[PCONN_HIST_SZ];
     hash_table *table;
     const char *descr;
+    CbcPointer<PeerPoolMgr> mgr; ///< optional pool manager (for notifications)
     int theCount; ///< the number of pooled connections
 };
 
@@ -162,15 +171,15 @@ class PconnModule
     void registerWithCacheManager(void);
 
     void add(PconnPool *);
+    void remove(PconnPool *); ///< unregister and forget about this pool object
 
     OBJH dump;
 
 private:
-    PconnPool **pools;
+    typedef std::set<PconnPool*> Pools; ///< unordered PconnPool collection
+    Pools pools; ///< all live pools
 
     static PconnModule * instance;
-
-    int poolCount;
 };
 
 #endif /* SQUID_PCONN_H */
@@ -90,6 +90,13 @@ CBDATA_CLASS_INIT(ps_state);
 
 ps_state::~ps_state()
 {
+    while (servers) {
+        FwdServer *next = servers->next;
+        cbdataReferenceDone(servers->_peer);
+        memFree(servers, MEM_FWD_SERVER);
+        servers = next;
+    }
+
     if (entry) {
         debugs(44, 3, entry->url());
 
@@ -149,9 +156,9 @@ peerSelect(Comm::ConnectionList * paths,
     ps_state *psstate;
 
     if (entry)
-        debugs(44, 3, "peerSelect: " << entry->url()  );
+        debugs(44, 3, *entry << ' ' << entry->url());
     else
-        debugs(44, 3, "peerSelect: " << RequestMethodStr(request->method));
+        debugs(44, 3, request->method);
 
     psstate = new ps_state;
 
@@ -229,6 +236,12 @@ peerSelectDnsPaths(ps_state *psstate)
 {
     FwdServer *fs = psstate->servers;
 
+    if (!cbdataReferenceValid(psstate->callback_data)) {
+        debugs(44, 3, "Aborting peer selection. Parent Job went away.");
+        delete psstate;
+        return;
+    }
+
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must use only the original client destination when going DIRECT
@@ -244,7 +257,7 @@ peerSelectDnsPaths(ps_state *psstate)
             // construct a "result" adding the ORIGINAL_DST to the set instead of DIRECT
             Comm::ConnectionPointer p = new Comm::Connection();
             p->remote = req->clientConnectionManager->clientConnection->local;
-            p->peerType = fs->code;
+            p->peerType = ORIGINAL_DST; // fs->code is DIRECT. This fixes the display.
             p->setPeer(fs->_peer);
 
             // check for a configured outgoing address for this destination...
@@ -319,6 +332,12 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
 {
     ps_state *psstate = (ps_state *)data;
 
+    if (!cbdataReferenceValid(psstate->callback_data)) {
+        debugs(44, 3, "Aborting peer selection. Parent Job went away.");
+        delete psstate;
+        return;
+    }
+
     psstate->request->recordLookup(details);
 
     FwdServer *fs = psstate->servers;
@@ -432,9 +451,15 @@ peerCheckNetdbDirect(ps_state * psstate)
 static void
 peerSelectFoo(ps_state * ps)
 {
+    if (!cbdataReferenceValid(ps->callback_data)) {
+        debugs(44, 3, "Aborting peer selection. Parent Job went away.");
+        delete ps;
+        return;
+    }
+
     StoreEntry *entry = ps->entry;
     HttpRequest *request = ps->request;
-    debugs(44, 3, "peerSelectFoo: '" << RequestMethodStr(request->method) << " " << request->GetHost() << "'");
+    debugs(44, 3, request->method << ' ' << request->GetHost());
 
     /** If we don't know whether DIRECT is permitted ... */
     if (ps->direct == DIRECT_UNKNOWN) {
@@ -666,7 +691,7 @@ peerGetSomeDirect(ps_state * ps)
         return;
 
     /* WAIS is not implemented natively */
-    if (ps->request->protocol == AnyP::PROTO_WAIS)
+    if (ps->request->url.getScheme() == AnyP::PROTO_WAIS)
         return;
 
     peerAddFwdServer(&ps->servers, NULL, HIER_DIRECT);
@@ -678,7 +703,7 @@ peerGetSomeParent(ps_state * ps)
     CachePeer *p;
     HttpRequest *request = ps->request;
     hier_code code = HIER_NONE;
-    debugs(44, 3, "peerGetSomeParent: " << RequestMethodStr(request->method) << " " << request->GetHost());
+    debugs(44, 3, request->method << ' ' << request->GetHost());
 
     if (ps->direct == DIRECT_YES)
         return;
@@ -27,6 +27,8 @@ libsslsquid_la_SOURCES = \
 	ErrorDetail.h \
 	ErrorDetailManager.cc \
 	ErrorDetailManager.h \
+	PeerConnector.cc \
+	PeerConnector.h \
 	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \
@@ -0,0 +1,545 @@
+/*
+ * DEBUG: section 17    Request Forwarding
+ *
+ */
+
+#include "squid.h"
+#include "acl/FilledChecklist.h"
+#include "base/AsyncCbdataCalls.h"
+#include "CachePeer.h"
+#include "client_side.h"
+#include "comm/Loops.h"
+#include "errorpage.h"
+#include "fde.h"
+#include "globals.h"
+#include "HttpRequest.h"
+#include "neighbors.h"
+#include "ssl/cert_validate_message.h"
+#include "ssl/Config.h"
+#include "ssl/ErrorDetail.h"
+#include "ssl/helper.h"
+#include "ssl/PeerConnector.h"
+#include "ssl/ServerBump.h"
+#include "ssl/support.h"
+#include "SquidConfig.h"
+
+CBDATA_NAMESPACED_CLASS_INIT(Ssl, PeerConnector);
+
+Ssl::PeerConnector::PeerConnector(
+    HttpRequestPointer &aRequest,
+    const Comm::ConnectionPointer &aServerConn,
+    AsyncCall::Pointer &aCallback):
+    AsyncJob("Ssl::PeerConnector"),
+    request(aRequest),
+    serverConn(aServerConn),
+    callback(aCallback)
+{
+    // if this throws, the caller's cb dialer is not our CbDialer
+    Must(dynamic_cast<CbDialer*>(callback->getDialer()));
+}
+
+Ssl::PeerConnector::~PeerConnector()
+{
+    debugs(83, 5, "Peer connector " << this << " gone");
+}
+
+bool Ssl::PeerConnector::doneAll() const
+{
+    return (!callback || callback->canceled()) && AsyncJob::doneAll();
+}
+
+/// Preps connection and SSL state. Calls negotiate().
+void
+Ssl::PeerConnector::start()
+{
+    AsyncJob::start();
+
+    if (prepareSocket()) {
+        initializeSsl();
+        negotiateSsl();
+    }
+}
+
+void
+Ssl::PeerConnector::commCloseHandler(const CommCloseCbParams &params)
+{
+    debugs(83, 5, "FD " << params.fd << ", Ssl::PeerConnector=" << params.data);
+    connectionClosed("Ssl::PeerConnector::commCloseHandler");
+}
+
+void
+Ssl::PeerConnector::connectionClosed(const char *reason)
+{
+    mustStop(reason);
+    callback = NULL;
+}
+
+bool
+Ssl::PeerConnector::prepareSocket()
+{
+    const int fd = serverConnection()->fd;
+    if (!Comm::IsConnOpen(serverConn) || fd_table[serverConn->fd].closing()) {
+        connectionClosed("Ssl::PeerConnector::prepareSocket");
+        return false;
+    }
+
+    // watch for external connection closures
+    typedef CommCbMemFunT<Ssl::PeerConnector, CommCloseCbParams> Dialer;
+    closeHandler = JobCallback(9, 5, Dialer, this, Ssl::PeerConnector::commCloseHandler);
+    comm_add_close_handler(fd, closeHandler);
+    return true;
+}
+
+void
+Ssl::PeerConnector::initializeSsl()
+{
+    SSL *ssl;
+    SSL_CTX *sslContext = NULL;
+    const CachePeer *peer = serverConnection()->getPeer();
+    const int fd = serverConnection()->fd;
+
+    if (peer) {
+        assert(peer->use_ssl);
+        sslContext = peer->sslContext;
+    } else {
+        sslContext = ::Config.ssl_client.sslContext;
+    }
+
+    assert(sslContext);
+
+    if ((ssl = SSL_new(sslContext)) == NULL) {
+        ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request.getRaw());
+        anErr->xerrno = errno;
+        debugs(83, DBG_IMPORTANT, "Error allocating SSL handle: " << ERR_error_string(ERR_get_error(), NULL));
+        bail(anErr);
+        return;
+    }
+
+    SSL_set_fd(ssl, fd);
+
+    if (peer) {
+        if (peer->ssldomain)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->ssldomain);
+
+#if NOT_YET
+
+        else if (peer->name)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->name);
+
+#endif
+
+        else
+            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->host);
+
+        if (peer->sslSession)
+            SSL_set_session(ssl, peer->sslSession);
+
+    } else {
+        // While we are peeking at the certificate, we may not know the server
+        // name that the client will request (after interception or CONNECT)
+        // unless it was the CONNECT request with a user-typed address.
+        const char *hostname = request->GetHost();
+        const bool hostnameIsIp = request->GetHostIsNumeric();
+        const bool isConnectRequest = request->clientConnectionManager.valid() &&
+                                      !request->clientConnectionManager->port->flags.isIntercepted();
+        if (!request->flags.sslPeek || isConnectRequest)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
+
+        // Use SNI TLS extension only when we connect directly
+        // to the origin server and we know the server host name.
+        if (!hostnameIsIp)
+            Ssl::setClientSNI(ssl, hostname);
+    }
+
+    // If CertValidation Helper used do not lookup checklist for errors,
+    // but keep a list of errors to send it to CertValidator
+    if (!Ssl::TheConfig.ssl_crt_validator) {
+        // Create the ACL check list now, while we have access to more info.
+        // The list is used in ssl_verify_cb() and is freed in ssl_free().
+        if (acl_access *acl = ::Config.ssl_client.cert_error) {
+            ACLFilledChecklist *check = new ACLFilledChecklist(acl, request.getRaw(), dash_str);
+            // check->fd(fd); XXX: need client FD here
+            SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
+        }
+    }
+
+    // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
+    X509 *peeked_cert;
+    if (request->clientConnectionManager.valid() &&
+            request->clientConnectionManager->serverBump() &&
+            (peeked_cert = request->clientConnectionManager->serverBump()->serverCert.get())) {
+        CRYPTO_add(&(peeked_cert->references),1,CRYPTO_LOCK_X509);
+        SSL_set_ex_data(ssl, ssl_ex_index_ssl_peeked_cert, peeked_cert);
+    }
+
+    fd_table[fd].ssl = ssl;
+    fd_table[fd].read_method = &ssl_read_method;
+    fd_table[fd].write_method = &ssl_write_method;
+}
+
+void
+Ssl::PeerConnector::negotiateSsl()
+{
+    if (!Comm::IsConnOpen(serverConnection()) || fd_table[serverConnection()->fd].closing())
+        return;
+
+    const int fd = serverConnection()->fd;
+    SSL *ssl = fd_table[fd].ssl;
+    const int result = SSL_connect(ssl);
+    if (result <= 0) {
+        handleNegotiateError(result);
+        return; // we might be gone by now
+    }
+
+    if (request->clientConnectionManager.valid()) {
+        // remember the server certificate from the ErrorDetail object
+        if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+            serverBump->serverCert.reset(SSL_get_peer_certificate(ssl));
+
+            // remember validation errors, if any
+            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+                serverBump->sslErrors = cbdataReference(errs);
+        }
+    }
+
+    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
+        if (serverConnection()->getPeer()->sslSession)
+            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
+
+        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
+    }
+
+    if (Ssl::TheConfig.ssl_crt_validator) {
+        Ssl::CertValidationRequest validationRequest;
+        // WARNING: Currently we do not use any locking for any of the
+        // members of the Ssl::CertValidationRequest class. In this code the
+        // Ssl::CertValidationRequest object used only to pass data to
+        // Ssl::CertValidationHelper::submit method.
+        validationRequest.ssl = ssl;
+        validationRequest.domainName = request->GetHost();
+        if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+            // validationRequest disappears on return so no need to cbdataReference
+            validationRequest.errors = errs;
+        else
+            validationRequest.errors = NULL;
+        try {
+            debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
+            Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, sslCrtvdHandleReplyWrapper, this);
+            return;
+        } catch (const std::exception &e) {
+            debugs(83, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
+                   "request for " << validationRequest.domainName <<
+                   " certificate: " << e.what() << "; will now block to " <<
+                   "validate that certificate.");
+            // fall through to do blocking in-process generation.
+            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request.getRaw());
+            bail(anErr);
+            if (serverConnection()->getPeer()) {
+                peerConnectFailed(serverConnection()->getPeer());
+            }
+            serverConn->close();
+            return;
+        }
+    }
+
+    callBack();
+}
+
+void
+Ssl::PeerConnector::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &validationResponse)
+{
+    Ssl::PeerConnector *connector = (Ssl::PeerConnector *)(data);
+    connector->sslCrtvdHandleReply(validationResponse);
+}
+
+void
+Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
+{
+    Ssl::CertErrors *errs = NULL;
+    Ssl::ErrorDetail *errDetails = NULL;
+    bool validatorFailed = false;
+    if (!Comm::IsConnOpen(serverConnection())) {
+        return;
+    }
+
+    debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
+
+    if (validationResponse.resultCode == HelperReply::Error)
+        errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
+    else if (validationResponse.resultCode != HelperReply::Okay)
+        validatorFailed = true;
+
+    if (!errDetails && !validatorFailed) {
+        callBack();
+        return;
+    }
+
+    ErrorState *anErr = NULL;
+    if (validatorFailed) {
+        anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request.getRaw());
+    }  else {
+
+        // Check the list error with
+        if (errDetails && request->clientConnectionManager.valid()) {
+            // remember the server certificate from the ErrorDetail object
+            if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+                // remember validation errors, if any
+                if (errs) {
+                    if (serverBump->sslErrors)
+                        cbdataReferenceDone(serverBump->sslErrors);
+                    serverBump->sslErrors = cbdataReference(errs);
+                }
+            }
+        }
+
+        anErr =  new ErrorState(ERR_SECURE_CONNECT_FAIL, Http::scServiceUnavailable, request.getRaw());
+        anErr->detail = errDetails;
+        /*anErr->xerrno= Should preserved*/
+    }
+
+    bail(anErr);
+    if (serverConnection()->getPeer()) {
+        peerConnectFailed(serverConnection()->getPeer());
+    }
+    serverConn->close();
+    return;
+}
+
+/// Checks errors in the cert. validator response against sslproxy_cert_error.
+/// The first honored error, if any, is returned via errDetails parameter.
+/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
+Ssl::CertErrors *
+Ssl::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
+{
+    Ssl::CertErrors *errs = NULL;
+
+    ACLFilledChecklist *check = NULL;
+    if (acl_access *acl = ::Config.ssl_client.cert_error)
+        check = new ACLFilledChecklist(acl, request.getRaw(), dash_str);
+
+    SSL *ssl = fd_table[serverConnection()->fd].ssl;
+    typedef Ssl::CertValidationResponse::RecvdErrors::const_iterator SVCRECI;
+    for (SVCRECI i = resp.errors.begin(); i != resp.errors.end(); ++i) {
+        debugs(83, 7, "Error item: " << i->error_no << " " << i->error_reason);
+
+        assert(i->error_no != SSL_ERROR_NONE);
+
+        if (!errDetails) {
+            bool allowed = false;
+            if (check) {
+                check->sslErrors = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
+                if (check->fastCheck() == ACCESS_ALLOWED)
+                    allowed = true;
+            }
+            // else the Config.ssl_client.cert_error access list is not defined
+            // and the first error will cause the error page
+
+            if (allowed) {
+                debugs(83, 3, "bypassing SSL error " << i->error_no << " in " << "buffer");
+            } else {
+                debugs(83, 5, "confirming SSL error " << i->error_no);
+                X509 *brokenCert = i->cert.get();
+                Ssl::X509_Pointer peerCert(SSL_get_peer_certificate(ssl));
+                const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
+                errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
+            }
+            if (check) {
+                delete check->sslErrors;
+                check->sslErrors = NULL;
+            }
+        }
+
+        if (!errs)
+            errs = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
+        else
+            errs->push_back_unique(Ssl::CertError(i->error_no, i->cert.get()));
+    }
+    if (check)
+        delete check;
+
+    return errs;
+}
+
+/// A wrapper for Comm::SetSelect() notifications.
+void
+Ssl::PeerConnector::NegotiateSsl(int, void *data)
+{
+    PeerConnector *pc = static_cast<PeerConnector*>(data);
+    // Use job calls to add done() checks and other job logic/protections.
+    CallJobHere(83, 7, pc, Ssl::PeerConnector, negotiateSsl);
+}
+
+void
+Ssl::PeerConnector::handleNegotiateError(const int ret)
+{
+    const int fd = serverConnection()->fd;
+    unsigned long ssl_lib_error = SSL_ERROR_NONE;
+    SSL *ssl = fd_table[fd].ssl;
+    int ssl_error = SSL_get_error(ssl, ret);
+
+#ifdef EPROTO
+        int sysErrNo = EPROTO;
+#else
+        int sysErrNo = EACCES;
+#endif
+
+        switch (ssl_error) {
+
+        case SSL_ERROR_WANT_READ:
+            Comm::SetSelect(fd, COMM_SELECT_READ, &NegotiateSsl, this, 0);
+            return;
+
+        case SSL_ERROR_WANT_WRITE:
+            Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
+            return;
+
+        case SSL_ERROR_SSL:
+        case SSL_ERROR_SYSCALL:
+            ssl_lib_error = ERR_get_error();
+
+            // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
+            if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
+                sysErrNo = errno;
+
+            debugs(83, DBG_IMPORTANT, "Error negotiating SSL on FD " << fd <<
+                   ": " << ERR_error_string(ssl_lib_error, NULL) << " (" <<
+                   ssl_error << "/" << ret << "/" << errno << ")");
+
+            break; // proceed to the general error handling code
+
+        default:
+            break; // no special error handling for all other errors
+        }
+
+    ErrorState *const anErr = ErrorState::NewForwarding(ERR_SECURE_CONNECT_FAIL, request.getRaw());
+    anErr->xerrno = sysErrNo;
+
+    Ssl::ErrorDetail *errFromFailure = (Ssl::ErrorDetail *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail);
+    if (errFromFailure != NULL) {
+        // The errFromFailure is attached to the ssl object
+        // and will be released when ssl object destroyed.
+        // Copy errFromFailure to a new Ssl::ErrorDetail object
+        anErr->detail = new Ssl::ErrorDetail(*errFromFailure);
+    } else {
+        // server_cert can be NULL here
+        X509 *server_cert = SSL_get_peer_certificate(ssl);
+        anErr->detail = new Ssl::ErrorDetail(SQUID_ERR_SSL_HANDSHAKE, server_cert, NULL);
+        X509_free(server_cert);
+    }
+
+    if (ssl_lib_error != SSL_ERROR_NONE)
+        anErr->detail->setLibError(ssl_lib_error);
+
+    if (request->clientConnectionManager.valid()) {
+        // remember the server certificate from the ErrorDetail object
+        if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+            serverBump->serverCert.resetAndLock(anErr->detail->peerCert());
+
+            // remember validation errors, if any
+            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+                serverBump->sslErrors = cbdataReference(errs);
+        }
+
+        // For intercepted connections, set the host name to the server
+        // certificate CN. Otherwise, we just hope that CONNECT is using
+        // a user-entered address (a host name or a user-entered IP).
+        const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
+        if (request->flags.sslPeek && !isConnectRequest) {
+            if (X509 *srvX509 = anErr->detail->peerCert()) {
+                if (const char *name = Ssl::CommonHostName(srvX509)) {
+                    request->SetHost(name);
+                    debugs(83, 3, HERE << "reset request host: " << name);
+                }
+            }
+        }
+    }
+
+    bail(anErr);
+}
+
+void
+Ssl::PeerConnector::bail(ErrorState *error)
+{
+    Must(error); // or the recepient will not know there was a problem
+
+    // XXX: forward.cc calls peerConnectSucceeded() after an OK TCP connect but
+    // we call peerConnectFailed() if SSL failed afterwards. Is that OK?
+    // It is not clear whether we should call peerConnectSucceeded/Failed()
+    // based on TCP results, SSL results, or both. And the code is probably not
+    // consistent in this aspect across tunnelling and forwarding modules.
+    if (CachePeer *p = serverConnection()->getPeer())
+        peerConnectFailed(p);
+
+    Must(callback != NULL);
+    CbDialer *dialer = dynamic_cast<CbDialer*>(callback->getDialer());
+    Must(dialer);
+    dialer->answer().error = error;
+
+    callBack();
+    // Our job is done. The callabck recepient will probably close the failed
+    // peer connection and try another peer or go direct (if possible). We
+    // can close the connection ourselves (our error notification would reach
+    // the recepient before the fd-closure notification), but we would rather
+    // minimize the number of fd-closure notifications and let the recepient
+    // manage the TCP state of the connection.
+}
+
+void
+Ssl::PeerConnector::callBack()
+{
+    AsyncCall::Pointer cb = callback;
+    // Do this now so that if we throw below, swanSong() assert that we _tried_
+    // to call back holds.
+    callback = NULL; // this should make done() true
+
+    // remove close handler
+    comm_remove_close_handler(serverConnection()->fd, closeHandler);
+
+    CbDialer *dialer = dynamic_cast<CbDialer*>(cb->getDialer());
+    Must(dialer);
+    dialer->answer().conn = serverConnection();
+    ScheduleCallHere(cb);
+}
+
+
+void
+Ssl::PeerConnector::swanSong()
+{
+    // XXX: unregister fd-closure monitoring and CommSetSelect interest, if any
+    AsyncJob::swanSong();
+    assert(!callback); // paranoid: we have not left the caller waiting
+}
+
+const char *
+Ssl::PeerConnector::status() const
+{
+    static MemBuf buf;
+    buf.reset();
+
+    // TODO: redesign AsyncJob::status() API to avoid this
+    // id and stop reason reporting duplication.
+    buf.append(" [", 2);
+    if (stopReason != NULL) {
+        buf.Printf("Stopped, reason:");
+        buf.Printf("%s",stopReason);
+    }
+    if (serverConn != NULL)
+        buf.Printf(" FD %d", serverConn->fd);
+    buf.Printf(" %s%u]", id.Prefix, id.value);
+    buf.terminate();
+
+    return buf.content();
+}
+
+/* PeerConnectorAnswer */
+
+Ssl::PeerConnectorAnswer::~PeerConnectorAnswer()
+{
+    delete error.get();
+}
+
+std::ostream &
+operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &answer)
+{
+    return os << answer.conn << ", " << answer.error;
+}
@@ -0,0 +1,170 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#ifndef SQUID_SSL_PEER_CONNECTOR_H
+#define SQUID_SSL_PEER_CONNECTOR_H
+
+#include "base/AsyncJob.h"
+#include "base/AsyncCbdataCalls.h"
+#include "ssl/support.h"
+#include <iosfwd>
+
+class HttpRequest;
+class ErrorState;
+
+namespace Ssl {
+
+class ErrorDetail;
+class CertValidationResponse;
+
+/// PeerConnector results (supplied via a callback).
+/// The connection to peer was secured if and only if the error member is nil.
+class PeerConnectorAnswer {
+public:
+    ~PeerConnectorAnswer(); ///< deletes error if it is still set
+    Comm::ConnectionPointer conn; ///< peer connection (secured on success)
+
+    /// answer recepients must clear the error member in order to keep its info
+    /// XXX: We should refcount ErrorState instead of cbdata-protecting it.
+    CbcPointer<ErrorState> error; ///< problem details (nil on success)
+};
+
+/**
+ \par
+ * Connects Squid client-side to an SSL peer (cache_peer ... ssl).
+ * Handles peer certificate validation.
+ * Used by TunnelStateData, FwdState, and PeerPoolMgr to start talking to an
+ * SSL peer.
+ \par
+ * The caller receives a call back with PeerConnectorAnswer. If answer.error
+ * is not nil, then there was an error and the SSL connection to the SSL peer
+ * was not fully established. The error object is suitable for error response
+ * generation.
+ \par
+ * The caller must monitor the connection for closure because this
+ * job will not inform the caller about such events.
+ \par
+ * The caller must monitor the overall connection establishment timeout and
+ * close the connection on timeouts. This is probably better than having
+ * dedicated (or none at all!) timeouts for peer selection, DNS lookup,
+ * TCP handshake, SSL handshake, etc. Some steps may have their own timeout,
+ * but not all steps should be forced to have theirs. XXX: Neither tunnel.cc
+ * nor forward.cc have a "overall connection establishment" timeout. We need
+ * to change their code so that they start monitoring earlier and close on
+ * timeouts. This change may need to be discussed on squid-dev.
+ \par
+ * This job never closes the connection, even on errors. If a 3rd-party
+ * closes the connection, this job simply quits without informing the caller.
+*/ 
+class PeerConnector: virtual public AsyncJob
+{
+public:
+    /// Callback dialier API to allow PeerConnector to set the answer.
+    class CbDialer {
+    public:
+        virtual ~CbDialer() {}
+        /// gives PeerConnector access to the in-dialer answer
+        virtual PeerConnectorAnswer &answer() = 0;
+    };
+
+    typedef RefCount<HttpRequest> HttpRequestPointer;
+
+public:
+    PeerConnector(HttpRequestPointer &aRequest,
+                  const Comm::ConnectionPointer &aServerConn,
+                  AsyncCall::Pointer &aCallback);
+    virtual ~PeerConnector();
+
+protected:
+    // AsyncJob API
+    virtual void start();
+    virtual bool doneAll() const;
+    virtual void swanSong();
+    virtual const char *status() const;
+
+    /// The comm_close callback handler.
+    void commCloseHandler(const CommCloseCbParams &params);
+
+    /// Inform us that the connection is closed. Does the required clean-up.
+    void connectionClosed(const char *reason);
+
+    /// Sets up TCP socket-related notification callbacks if things go wrong.
+    /// If socket already closed return false, else install the comm_close
+    /// handler to monitor the socket.
+    bool prepareSocket();
+
+    void initializeSsl(); ///< Initializes SSL state
+
+    /// Performs a single secure connection negotiation step.
+    /// It is called multiple times untill the negotiation finish or aborted.
+    void negotiateSsl();
+
+    /// Called when the SSL negotiation step aborted because data needs to
+    /// be transferred to/from SSL server or on error. In the first case
+    /// setups the appropriate Comm::SetSelect handler. In second case
+    /// fill an error and report to the PeerConnector caller.
+    void handleNegotiateError(const int result);
+
+private:
+    PeerConnector(const PeerConnector &); // not implemented
+    PeerConnector &operator =(const PeerConnector &); // not implemented
+
+    /// mimics FwdState to minimize changes to FwdState::initiate/negotiateSsl
+    Comm::ConnectionPointer const &serverConnection() const { return serverConn; }
+
+    void bail(ErrorState *error); ///< Return an error to the PeerConnector caller 
+
+    /// Callback the caller class, and pass the ready to communicate secure
+    /// connection or an error if PeerConnector failed.
+    void callBack();
+
+    /// Process response from cert validator helper
+    void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
+
+    /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
+    Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
+
+    /// Callback function called when squid receive message from cert validator helper
+    static void sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &);
+
+    /// A wrapper function for negotiateSsl for use with Comm::SetSelect
+    static void NegotiateSsl(int fd, void *data);
+
+    HttpRequestPointer request; ///< peer connection trigger or cause
+    Comm::ConnectionPointer serverConn; ///< TCP connection to the peer
+    AsyncCall::Pointer callback; ///< we call this with the results
+    AsyncCall::Pointer closeHandler; ///< we call this when the connection closed
+
+    CBDATA_CLASS2(PeerConnector);
+};
+
+} // namespace Ssl
+
+std::ostream &operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &a);
+
+#endif /* SQUID_PEER_CONNECTOR_H */
@@ -80,7 +80,7 @@ storeLog(int tag, const StoreEntry * e)
         String ctype=(reply->content_type.size() ? reply->content_type.termedBuf() : str_unknown);
 
         logfileLineStart(storelog);
-        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %" PRId64 "/%" PRId64 " %s %s\n",
+        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %" PRId64 "/%" PRId64 " " SQUIDSBUFPH " %s\n",
                       (int) current_time.tv_sec,
                       (int) current_time.tv_usec / 1000,
                       storeLogTags[tag],
@@ -94,7 +94,7 @@ storeLog(int tag, const StoreEntry * e)
                       SQUIDSTRINGPRINT(ctype),
                       reply->content_length,
                       e->contentLen(),
-                      RequestMethodStr(mem->method),
+                      SQUIDSBUFPRINT(mem->method.image()),
                       mem->logUri());
         logfileLineEnd(storelog);
     } else {
@@ -102,18 +102,6 @@ struct _FileIterator {
 /* globals */
 static time_t cur_time = -1;	/* timestamp of the current log entry */
 
-/* copied from url.c */
-const char *RequestMethodStr[] = {
-    "NONE",
-    "GET",
-    "POST",
-    "PUT",
-    "HEAD",
-    "CONNECT",
-    "TRACE",
-    "PURGE"
-};
-
 /* copied from url.c */
 static HttpRequestMethod
 methodStrToId(const char *s)
@@ -13,7 +13,7 @@ void ACLExternal::parse() STUB
 bool ACLExternal::valid () const STUB_RETVAL(false)
 bool ACLExternal::empty () const STUB_RETVAL(false)
 int ACLExternal::match(ACLChecklist *) STUB_RETVAL(0)
-wordlist * ACLExternal::dump() const STUB_RETVAL(NULL)
+SBufList ACLExternal::dump() const STUB_RETVAL(SBufList())
 void ACLExternal::ExternalAclLookup(ACLChecklist *, ACLExternal *) STUB
 void ExternalACLLookup::Start(ACLChecklist *, external_acl_data *, bool) STUB
 void externalAclInit(void) STUB_NOP
@@ -20,7 +20,7 @@ bool ACLMaxUserIP::valid () const STUB_RETVAL(false)
 void ACLMaxUserIP::parse() STUB
 int ACLMaxUserIP::match(Auth::UserRequest::Pointer, Ip::Address const &) STUB_RETVAL(0)
 int ACLMaxUserIP::match(ACLChecklist *) STUB_RETVAL(0)
-wordlist * ACLMaxUserIP::dump() const STUB_RETVAL(NULL)
+SBufList ACLMaxUserIP::dump() const STUB_RETVAL(SBufList())
 
 #include "auth/AclProxyAuth.h"
 ACLProxyAuth::~ACLProxyAuth() STUB
@@ -30,7 +30,7 @@ ACLProxyAuth & ACLProxyAuth::operator= (ACLProxyAuth const & a) STUB_RETVAL(cons
 char const * ACLProxyAuth::typeString() const STUB_RETVAL(NULL)
 void ACLProxyAuth::parse() STUB
 int ACLProxyAuth::match(ACLChecklist *) STUB_RETVAL(0)
-wordlist * ACLProxyAuth::dump() const STUB_RETVAL(NULL)
+SBufList ACLProxyAuth::dump() const STUB_RETVAL(SBufList())
 bool ACLProxyAuth::empty () const STUB_RETVAL(false)
 bool ACLProxyAuth::valid () const STUB_RETVAL(false)
 ProxyAuthLookup * ProxyAuthLookup::Instance() STUB_RETVAL(NULL)
@@ -0,0 +1,9 @@
+#include "squid.h"
+
+#define STUB_API "neighbors.cc"
+#include "tests/STUB.h"
+
+#include "neighbors.h"
+
+void
+peerConnClosed(CachePeer *p) STUB
@@ -13,7 +13,7 @@ IdleConnList::~IdleConnList() STUB
 void IdleConnList::push(const Comm::ConnectionPointer &conn) STUB
 Comm::ConnectionPointer IdleConnList::findUseable(const Comm::ConnectionPointer &key) STUB_RETVAL(Comm::ConnectionPointer())
 void IdleConnList::clearHandlers(const Comm::ConnectionPointer &conn) STUB
-PconnPool::PconnPool(const char *) STUB
+PconnPool::PconnPool(const char *, const CbcPointer<PeerPoolMgr>&) STUB
 PconnPool::~PconnPool() STUB
 void PconnPool::moduleInit() STUB
 void PconnPool::push(const Comm::ConnectionPointer &serverConn, const char *domain) STUB
@@ -43,7 +43,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 
@@ -55,7 +55,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_PUT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo/bar"), String(url));
     xfree(url);
 
@@ -73,7 +73,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_CONNECT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String(""), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("foo:45"), String(url));
     xfree(url);
 }
@@ -93,7 +93,7 @@ testHttpRequest::testCreateFromUrl()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 }
@@ -116,7 +116,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]/foo"), String(url));
     xfree(url);
 
@@ -128,7 +128,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]:90/foo"), String(url));
     xfree(url);
 
@@ -140,7 +140,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://2000:800::45/foo"), String(url));
     xfree(url);
 }
@@ -84,15 +84,15 @@ testHttpRequestMethod::testImage()
 {
     // relaxed RFC-compliance parse HTTP methods are upgraded to correct case
     Config.onoff.relaxed_header_parser = 1;
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("POST",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("pOsT",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("post",NULL).image()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("POST",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("pOsT",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("post",NULL).image());
 
     // strict RFC-compliance parse HTTP methods are case sensitive
     Config.onoff.relaxed_header_parser = 0;
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("POST",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("pOsT"), String(HttpRequestMethod("pOsT",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("post"), String(HttpRequestMethod("post",NULL).image()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("POST",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("pOsT"), HttpRequestMethod("pOsT",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("post"), HttpRequestMethod("post",NULL).image());
 }
 
 /*
@@ -244,6 +244,63 @@ static int sign(int v)
     return 0;
 }
 
+static void
+testComparisonStdFull(const char *left, const char *right)
+{
+    if (sign(strcmp(left, right)) != sign(SBuf(left).cmp(SBuf(right))))
+        std::cerr << std::endl << " cmp(SBuf) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcmp(left, right)), sign(SBuf(left).cmp(SBuf(right))));
+
+    if (sign(strcmp(left, right)) != sign(SBuf(left).cmp(right)))
+        std::cerr << std::endl << " cmp(char*) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcmp(left, right)), sign(SBuf(left).cmp(right)));
+
+    if (sign(strcasecmp(left, right)) != sign(SBuf(left).caseCmp(SBuf(right))))
+        std::cerr << std::endl << " caseCmp(SBuf) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcasecmp(left, right)), sign(SBuf(left).caseCmp(SBuf(right))));
+
+    if (sign(strcasecmp(left, right)) != sign(SBuf(left).caseCmp(right)))
+        std::cerr << std::endl << " caseCmp(char*) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcasecmp(left, right)), sign(SBuf(left).caseCmp(right)));
+}
+
+static void
+testComparisonStdN(const char *left, const char *right, const size_t n)
+{
+    if (sign(strncmp(left, right, n)) != sign(SBuf(left).cmp(SBuf(right), n)))
+        std::cerr << std::endl << " cmp(SBuf) " << n << ' ' << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncmp(left, right, n)), sign(SBuf(left).cmp(SBuf(right), n)));
+
+    if (sign(strncmp(left, right, n)) != sign(SBuf(left).cmp(right, n)))
+        std::cerr << std::endl << " cmp(char*) " << n << ' ' << SBuf(left) << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncmp(left, right, n)), sign(SBuf(left).cmp(right, n)));
+
+    if (sign(strncasecmp(left, right, n)) != sign(SBuf(left).caseCmp(SBuf(right), n)))
+        std::cerr << std::endl << " caseCmp(SBuf) " << n << ' ' << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncasecmp(left, right, n)), sign(SBuf(left).caseCmp(SBuf(right), n)));
+
+    if (sign(strncasecmp(left, right, n)) != sign(SBuf(left).caseCmp(right, n)))
+        std::cerr << std::endl << " caseCmp(char*) " << n << ' ' << SBuf(left) << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncasecmp(left, right, n)), sign(SBuf(left).caseCmp(right, n)));
+}
+
+static void
+testComparisonStdOneWay(const char *left, const char *right)
+{
+    testComparisonStdFull(left, right);
+    const size_t maxN = 2 + min(strlen(left), strlen(right));
+    for (size_t n = 0; n <= maxN; ++n) {
+        testComparisonStdN(left, right, n);
+    }
+}
+
+static void
+testComparisonStd(const char *s1, const char *s2)
+{
+    testComparisonStdOneWay(s1, s2);
+    testComparisonStdOneWay(s2, s1);
+}
+
 void
 testSBuf::testComparisons()
 {
@@ -278,6 +335,41 @@ testSBuf::testComparisons()
     CPPUNIT_ASSERT_EQUAL(0,s1.caseCmp(s2,3));
     CPPUNIT_ASSERT_EQUAL(0,s1.caseCmp(s2,2));
     CPPUNIT_ASSERT_EQUAL(0,s1.cmp(s2,2));
+
+    testComparisonStd("foo", "fooz");
+    testComparisonStd("foo", "foo");
+    testComparisonStd("foo", "f");
+    testComparisonStd("foo", "bar");
+
+    testComparisonStd("foo", "FOOZ");
+    testComparisonStd("foo", "FOO");
+    testComparisonStd("foo", "F");
+
+    testComparisonStdOneWay("", "");
+
+    // rare case C-string input matching SBuf with N>strlen(s)
+    {
+        char *right = xstrdup("foo34567890123456789012345678");
+        SBuf left("fooZYXWVUTSRQPONMLKJIHGFEDCBA");
+        // is 3 bytes in length. NEVER more.
+        right[3] = '\0';
+        left.setAt(3, '\0');
+
+        // pick another spot to truncate at if something goes horribly wrong.
+        right[14] = '\0';
+        left.setAt(14, '\0');
+
+        const SBuf::size_type maxN = 20 + min(left.length(), static_cast<SBuf::size_type>(strlen(right)));
+        for (SBuf::size_type n = 0; n <= maxN; ++n) {
+            if (sign(strncmp(left.rawContent(), right, n)) != sign(left.cmp(right, n)) )
+                std::cerr << std::endl << " cmp(char*) " << n << ' ' << left << " ?= " << right;
+            CPPUNIT_ASSERT_EQUAL(sign(strncmp(left.rawContent(), right, n)), sign(left.cmp(right, n)));
+            if (sign(strncasecmp(left.rawContent(), right, n)) != sign(left.caseCmp(right, n)))
+                std::cerr << std::endl << " caseCmp(char*) " << n << ' ' << left << " ?= " << right;
+            CPPUNIT_ASSERT_EQUAL(sign(strncasecmp(left.rawContent(), right, n)), sign(left.caseCmp(right, n)));
+        }
+        xfree(right);
+    }
 }
 
 void
@@ -33,6 +33,7 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
+#include "base/CbcPointer.h"
 #include "CachePeer.h"
 #include "client_side.h"
 #include "client_side_request.h"
@@ -42,6 +43,7 @@
 #include "comm/Write.h"
 #include "errorpage.h"
 #include "fde.h"
+#include "FwdState.h"
 #include "http.h"
 #include "HttpRequest.h"
 #include "HttpStateFlags.h"
@@ -50,6 +52,9 @@
 #include "PeerSelectState.h"
 #include "SquidConfig.h"
 #include "StatCounters.h"
+#if USE_OPENSSL
+#include "ssl/PeerConnector.h"
+#endif
 #include "tools.h"
 #if USE_DELAY_POOLS
 #include "DelayId.h"
@@ -94,6 +99,7 @@ class TunnelStateData
 
     bool noConnections() const;
     char *url;
+    CbcPointer<ClientHttpRequest> http;
     HttpRequest::Pointer request;
     AccessLogEntryPointer al;
     Comm::ConnectionList serverDestinations;
@@ -157,7 +163,38 @@ class TunnelStateData
 
     void copyRead(Connection &from, IOCB *completion);
 
+    /// continue to set up connection to a peer, going async for SSL peers
+    void connectToPeer();
+
 private:
+#if USE_OPENSSL
+    /// Gives PeerConnector access to Answer in the TunnelStateData callback dialer.
+    class MyAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+    {
+    public:
+        typedef void (TunnelStateData::*Method)(Ssl::PeerConnectorAnswer &);
+
+        MyAnswerDialer(Method method, TunnelStateData *tunnel):
+                       method_(method), tunnel_(tunnel), answer_() {}
+
+        /* CallDialer API */
+        virtual bool canDial(AsyncCall &call) { return tunnel_.valid(); }
+        void dial(AsyncCall &call) { ((&(*tunnel_))->*method_)(answer_); }
+        virtual void print(std::ostream &os) const {
+            os << '(' << tunnel_.get() << ", " << answer_ << ')'; }
+
+        /* Ssl::PeerConnector::CbDialer API */
+        virtual Ssl::PeerConnectorAnswer &answer() { return answer_; }
+
+    private:
+        Method method_;
+        CbcPointer<TunnelStateData> tunnel_;
+        Ssl::PeerConnectorAnswer answer_;
+    };
+
+    void connectedToPeer(Ssl::PeerConnectorAnswer &answer);
+#endif
+
     CBDATA_CLASS2(TunnelStateData);
     bool keepGoingAfterRead(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to);
     void copy(size_t len, Connection &from, Connection &to, IOCB *);
@@ -220,6 +257,7 @@ tunnelClientClosed(const CommCloseCbParams &params)
 
 TunnelStateData::TunnelStateData() :
         url(NULL),
+        http(),
         request(NULL),
         status_ptr(NULL),
         connectRespBuf(NULL),
@@ -670,11 +708,27 @@ tunnelStartShoveling(TunnelStateData *tunnelState)
     assert(!tunnelState->waitingForConnectExchange());
     *tunnelState->status_ptr = Http::scOkay;
     if (cbdataReferenceValid(tunnelState)) {
+
+        // Shovel any payload already pushed into reply buffer by the server response
         if (!tunnelState->server.len)
             tunnelState->copyRead(tunnelState->server, TunnelStateData::ReadServer);
-        else
+        else {
+            debugs(26, DBG_DATA, "Tunnel server PUSH Payload: \n" << Raw("", tunnelState->server.buf, tunnelState->server.len) << "\n----------");
             tunnelState->copy(tunnelState->server.len, tunnelState->server, tunnelState->client, TunnelStateData::WriteClientDone);
-        tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
+        }
+
+        // Bug 3371: shovel any payload already pushed into ConnStateData by the client request
+        if (tunnelState->http.valid() && tunnelState->http->getConn() && !tunnelState->http->getConn()->in.buf.isEmpty()) {
+            struct ConnStateData::In *in = &tunnelState->http->getConn()->in;
+            debugs(26, DBG_DATA, "Tunnel client PUSH Payload: \n" << in->buf << "\n----------");
+
+            // We just need to ensure the bytes from ConnStateData are in client.buf already to deliver
+            memcpy(tunnelState->client.buf, in->buf.rawContent(), in->buf.length());
+            // NP: readClient() takes care of buffer length accounting.
+            tunnelState->readClient(tunnelState->client.buf, in->buf.length(), COMM_OK, 0);
+            in->buf.consume(); // ConnStateData buffer accounting after the shuffle.
+        } else
+            tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
     }
 }
 
@@ -777,15 +831,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
         tunnelState->serverDestinations.erase(tunnelState->serverDestinations.begin());
         if (status != COMM_TIMEOUT && tunnelState->serverDestinations.size() > 0) {
             /* Try another IP of this destination host */
-
-            if (Ip::Qos::TheConfig.isAclTosActive()) {
-                tunnelState->serverDestinations[0]->tos = GetTosToServer(tunnelState->request.getRaw());
-            }
-
-#if SO_MARK && USE_LIBCAP
-            tunnelState->serverDestinations[0]->nfmark = GetNfmarkToServer(tunnelState->request.getRaw());
-#endif
-
+            GetMarkingsToServer(tunnelState->request.getRaw(), *tunnelState->serverDestinations[0]);
             debugs(26, 4, HERE << "retry with : " << tunnelState->serverDestinations[0]);
             AsyncCall::Pointer call = commCbCall(26,3, "tunnelConnectDone", CommConnectCbPtrFun(tunnelConnectDone, tunnelState));
             Comm::ConnOpener *cs = new Comm::ConnOpener(tunnelState->serverDestinations[0], call, Config.Timeout.connect);
@@ -827,7 +873,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
     }
 
     if (tunnelState->request->flags.proxying)
-        tunnelRelayConnectRequest(conn, tunnelState);
+        tunnelState->connectToPeer();
     else {
         tunnelConnected(conn, tunnelState);
     }
@@ -837,9 +883,6 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
     commSetConnTimeout(conn, Config.Timeout.read, timeoutCall);
 }
 
-tos_t GetTosToServer(HttpRequest * request);
-nfmark_t GetNfmarkToServer(HttpRequest * request);
-
 void
 tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const AccessLogEntryPointer &al)
 {
@@ -873,7 +916,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
         }
     }
 
-    debugs(26, 3, HERE << "'" << RequestMethodStr(request->method) << " " << url << " " << request->http_ver << "'");
+    debugs(26, 3, request->method << ' ' << url << ' ' << request->http_ver);
     ++statCounter.server.all.requests;
     ++statCounter.server.other.requests;
 
@@ -886,6 +929,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
     tunnelState->server.size_ptr = size_ptr;
     tunnelState->status_ptr = status_ptr;
     tunnelState->client.conn = http->getConn()->clientConnection;
+    tunnelState->http = http;
     tunnelState->al = al;
 
     comm_add_close_handler(tunnelState->client.conn->fd,
@@ -902,6 +946,45 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
                tunnelState);
 }
 
+void
+TunnelStateData::connectToPeer() {
+    const Comm::ConnectionPointer &srv = server.conn;
+
+#if USE_OPENSSL
+    if (CachePeer *p = srv->getPeer()) {
+        if (p->use_ssl) {
+            AsyncCall::Pointer callback = asyncCall(5,4,
+                "TunnelStateData::ConnectedToPeer",
+                MyAnswerDialer(&TunnelStateData::connectedToPeer, this));
+            Ssl::PeerConnector *connector =
+                new Ssl::PeerConnector(request, srv, callback);
+            AsyncJob::Start(connector); // will call our callback
+            return;
+        }
+    }
+#endif
+
+    tunnelRelayConnectRequest(srv, this);
+}
+
+#if USE_OPENSSL
+/// Ssl::PeerConnector callback
+void
+TunnelStateData::connectedToPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    if (ErrorState *error = answer.error.get()) {
+        *status_ptr = error->httpStatus;
+        error->callback = tunnelErrorComplete;
+        error->callback_data = this;
+        errorSend(client.conn, error);
+        answer.error.clear(); // preserve error for errorSendComplete()
+        return;
+    }
+
+    tunnelRelayConnectRequest(server.conn, this);
+}
+#endif
+
 static void
 tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
 {
@@ -927,6 +1010,9 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     packerClean(&p);
     mb.append("\r\n", 2);
 
+    debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn << ":\n----------\n" <<
+           Raw("tunnelRelayConnectRequest", mb.content(), mb.contentSize()) << "\n----------");
+
     if (tunnelState->clientExpectsConnectResponse()) {
         // hack: blindly tunnel peer response (to our CONNECT request) to the client as ours.
         AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
@@ -974,13 +1060,7 @@ tunnelPeerSelectComplete(Comm::ConnectionList *peer_paths, ErrorState *err, void
     }
     delete err;
 
-    if (Ip::Qos::TheConfig.isAclTosActive()) {
-        tunnelState->serverDestinations[0]->tos = GetTosToServer(tunnelState->request.getRaw());
-    }
-
-#if SO_MARK && USE_LIBCAP
-    tunnelState->serverDestinations[0]->nfmark = GetNfmarkToServer(tunnelState->request.getRaw());
-#endif
+    GetMarkingsToServer(tunnelState->request.getRaw(), *tunnelState->serverDestinations[0]);
 
     debugs(26, 3, HERE << "paths=" << peer_paths->size() << ", p[0]={" << (*peer_paths)[0] << "}, serverDest[0]={" <<
            tunnelState->serverDestinations[0] << "}");
@@ -146,9 +146,6 @@ urlParseProtocol(const char *b, const char *e)
     if (strncasecmp(b, "whois", len) == 0)
         return AnyP::PROTO_WHOIS;
 
-    if (strncasecmp(b, "internal", len) == 0)
-        return AnyP::PROTO_INTERNAL;
-
     return AnyP::PROTO_NONE;
 }
 
@@ -179,8 +176,6 @@ urlDefaultPort(AnyP::ProtocolType p)
         return 210;
 
     case AnyP::PROTO_CACHE_OBJECT:
-
-    case AnyP::PROTO_INTERNAL:
         return CACHE_HTTP_PORT;
 
     case AnyP::PROTO_WHOIS:
@@ -503,25 +498,32 @@ urlCanonical(HttpRequest * request)
     if (request->canonical)
         return request->canonical;
 
-    if (request->protocol == AnyP::PROTO_URN) {
+    if (request->url.getScheme() == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
-    } else if (request->method.id() == Http::METHOD_CONNECT) {
-        snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
     } else {
-        portbuf[0] = '\0';
-
-        if (request->port != urlDefaultPort(request->protocol))
-            snprintf(portbuf, 32, ":%d", request->port);
-
-        const AnyP::UriScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
-        snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
-                 sch.c_str(),
-                 request->login,
-                 *request->login ? "@" : null_string,
-                 request->GetHost(),
-                 portbuf,
-                 SQUIDSTRINGPRINT(request->urlpath));
+        switch (request->method.id()) {
+
+        case Http::METHOD_CONNECT:
+            snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
+            break;
+
+        default:
+            {
+                portbuf[0] = '\0';
+
+                if (request->port != urlDefaultPort(request->url.getScheme()))
+                    snprintf(portbuf, 32, ":%d", request->port);
+
+                snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
+                         request->url.getScheme().c_str(),
+                         request->login,
+                         *request->login ? "@" : null_string,
+                         request->GetHost(),
+                         portbuf,
+                         SQUIDSTRINGPRINT(request->urlpath));
+            }
+        }
     }
 
     return (request->canonical = xstrdup(urlbuf));
@@ -539,42 +541,47 @@ urlCanonicalClean(const HttpRequest * request)
     LOCAL_ARRAY(char, loginbuf, MAX_LOGIN_SZ + 1);
     char *t;
 
-    if (request->protocol == AnyP::PROTO_URN) {
+    if (request->url.getScheme() == AnyP::PROTO_URN) {
         snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
-    } else if (request->method.id() == Http::METHOD_CONNECT) {
-        snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
     } else {
-        portbuf[0] = '\0';
+        switch (request->method.id()) {
 
-        if (request->port != urlDefaultPort(request->protocol))
-            snprintf(portbuf, 32, ":%d", request->port);
+        case Http::METHOD_CONNECT:
+            snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
+            break;
 
-        loginbuf[0] = '\0';
+        default:
+            {
+                portbuf[0] = '\0';
 
-        if ((int) strlen(request->login) > 0) {
-            strcpy(loginbuf, request->login);
+                if (request->port != urlDefaultPort(request->url.getScheme()))
+                    snprintf(portbuf, 32, ":%d", request->port);
 
-            if ((t = strchr(loginbuf, ':')))
-                *t = '\0';
+                loginbuf[0] = '\0';
 
-            strcat(loginbuf, "@");
-        }
+                if ((int) strlen(request->login) > 0) {
+                    strcpy(loginbuf, request->login);
 
-        const AnyP::UriScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
-        snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
-                 sch.c_str(),
-                 loginbuf,
-                 request->GetHost(),
-                 portbuf,
-                 SQUIDSTRINGPRINT(request->urlpath));
-        /*
-         * strip arguments AFTER a question-mark
-         */
+                    if ((t = strchr(loginbuf, ':')))
+                        *t = '\0';
 
-        if (Config.onoff.strip_query_terms)
-            if ((t = strchr(buf, '?')))
-                *(++t) = '\0';
+                    strcat(loginbuf, "@");
+                }
+
+                snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
+                         request->url.getScheme().c_str(),
+                         loginbuf,
+                         request->GetHost(),
+                         portbuf,
+                         SQUIDSTRINGPRINT(request->urlpath));
+
+                // strip arguments AFTER a question-mark
+                if (Config.onoff.strip_query_terms)
+                    if ((t = strchr(buf, '?')))
+                        *(++t) = '\0';
+            }
+        }
     }
 
     if (stringHasCntl(buf))
@@ -653,26 +660,25 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
-    if (req->protocol == AnyP::PROTO_URN) {
+    if (req->url.getScheme() == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(req->urlpath));
         return (urlbuf);
     }
 
     size_t urllen;
 
-    const AnyP::UriScheme sch = req->protocol; // temporary, until bug 1961 URL handling is fixed.
-    if (req->port != urlDefaultPort(req->protocol)) {
+    if (req->port != urlDefaultPort(req->url.getScheme())) {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s:%d",
-                          sch.c_str(),
+                          req->url.getScheme().c_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost(),
                           req->port
                          );
     } else {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s",
-                          sch.c_str(),
+                          req->url.getScheme().c_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost()
@@ -830,7 +836,7 @@ urlCheckRequest(const HttpRequest * r)
         return 1;
 
     /* does method match the protocol? */
-    switch (r->protocol) {
+    switch (r->url.getScheme()) {
 
     case AnyP::PROTO_URN:
 
@@ -12,6 +12,7 @@ LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
+	$(LIBGNUTLS_LIBS) \
 	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
@@ -49,4 +50,6 @@ squidclient_SOURCES = \
 	squidclient.cc \
 	stub_debug.cc \
 	test_tools.cc \
-	time.cc
+	time.cc \
+	Transport.cc \
+	Transport.h
@@ -19,6 +19,10 @@ class Parameters
     int verbosityLevel;
 };
 
+/// display debug messages at varying verbosity levels
+#define debugVerbose(LEVEL, MESSAGE) \
+    while ((LEVEL) <= scParams.verbosityLevel) {std::cerr << MESSAGE << std::endl; break;}
+
 /// global squidcleint parameters
 extern Parameters scParams;
 
@@ -0,0 +1,500 @@
+#include "squid.h"
+#include "ip/Address.h"
+#include "tools/squidclient/Ping.h"
+#include "tools/squidclient/Transport.h"
+
+#if HAVE_GETOPT_H
+#include <getopt.h>
+#endif
+#if HAVE_GNUTLS_X509_H
+#include <gnutls/x509.h>
+#endif
+#include <iostream>
+
+Transport::TheConfig Transport::Config;
+
+/// the current server connection FD
+int conn = -1;
+
+void
+Transport::TheConfig::usage()
+{
+    std::cerr << "Connection Settings" << std::endl
+              << "  -h | --host host     Send message to server on 'host'.  Default is localhost." << std::endl
+              << "  -l | --local host    Specify a local IP address to bind to.  Default is none." << std::endl
+              << "  -p | --port port     Port number on server to contact. Default is " << CACHE_HTTP_PORT << "." << std::endl
+              << "  -T timeout           Timeout in seconds for read/write operations" << std::endl
+#if USE_GNUTLS
+              << "  --https              Use TLS/SSL on the HTTP connection" << std::endl
+              << std::endl
+              << "  TLS options:" << std::endl
+              << "    --anonymous-tls    Use Anonymous TLS. Sets default parameters:" << std::endl
+              << "                         \"PERFORMANCE:+ANON-ECDH:+ANON-DH\"" << std::endl
+              << "    --params=\"...\"   Use the given parameters." << std::endl
+              << "    --cert=FILE        Path to a PEM file holding the client X.509 certificate chain." << std::endl
+              << "                       May be repeated if there are multiple certificates to use for the server." << std::endl
+              << "    --trusted-ca=PATH  Path to a PEM file holding trusted CA certificate(s)." << std::endl
+              << "                       May be repeated." << std::endl
+              << "                       Example path: \"/etc/ssl/certs/ca-certificates.crt\"" << std::endl
+#endif
+              << std::endl;
+}
+
+bool
+Transport::TheConfig::parseCommandOpts(int argc, char *argv[], int c, int &optIndex)
+{
+    bool tls = false;
+    const char *shortOpStr = "A:C:h:l:p:P:T:?";
+
+    // options for controlling squidclient transport connection
+    static struct option longOptions[] = {
+        {"anonymous-tls",no_argument, 0, '\1'},
+        {"https",        no_argument, 0, '\3'},
+        {"trusted-ca",   required_argument, 0, 'A'},
+        {"cert",         required_argument, 0, 'C'},
+        {"host",         required_argument, 0, 'h'},
+        {"local",        required_argument, 0, 'l'},
+        {"port",         required_argument, 0, 'p'},
+        {"params",       required_argument, 0, 'P'},
+        {0, 0, 0, 0}
+    };
+
+    int saved_opterr = opterr;
+    opterr = 0; // suppress errors from getopt
+    do {
+        switch (c) {
+        case '\1':
+            tls = true;
+            tlsAnonymous = true;
+            params = "PERFORMANCE:+ANON-ECDH:+ANON-DH";
+            break;
+
+        case '\3':
+            tls = true;
+            break;
+
+        case 'A':
+            tls = true;
+            caFiles.push_back(std::string(optarg));
+            break;
+
+        case 'C':
+            tls = true;
+            certFiles.push_back(std::string(optarg));
+            break;
+
+        case 'h':
+            hostname = optarg;
+            break;
+
+        case 'l':
+            localHost = optarg;
+            break;
+
+        case 'p':           /* port number */
+            sscanf(optarg, "%hd", &port);
+            if (port < 1)
+                port = CACHE_HTTP_PORT;     /* default */
+            break;
+
+        case 'P':
+            tls = true;
+            params = optarg;
+            break;
+
+        case 'T':
+            ioTimeout = atoi(optarg);
+            break;
+
+        default:
+            if (tls)
+                Transport::InitTls();
+
+            // rewind and let the caller handle unknown options
+            --optind;
+            opterr = saved_opterr;
+            return true;
+        }
+    } while ((c = getopt_long(argc, argv, shortOpStr, longOptions, &optIndex)) != -1);
+
+    if (tls)
+        Transport::InitTls();
+
+    opterr = saved_opterr;
+    return false;
+}
+
+/// Set up the source socket address from which to send.
+static int
+client_comm_bind(int sock, const Ip::Address &addr)
+{
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
+    return res;
+}
+
+static void
+resolveDestination(Ip::Address &iaddr)
+{
+    struct addrinfo *AI = NULL;
+
+    if (Transport::Config.localHost) {
+        debugVerbose(2, "Resolving " << Transport::Config.localHost << " ...");
+
+        if ( !iaddr.GetHostByName(Transport::Config.localHost) ) {
+            std::cerr << "ERROR: Cannot resolve " << Transport::Config.localHost << ": Host unknown." << std::endl;
+            exit(1);
+        }
+    } else {
+        debugVerbose(2, "Resolving " << Transport::Config.hostname << " ...");
+        /* Process the remote host name to locate the Protocol required
+           in case we are being asked to link to another version of squid */
+        if ( !iaddr.GetHostByName(Transport::Config.hostname) ) {
+            std::cerr << "ERROR: Cannot resolve " << Transport::Config.hostname << ": Host unknown." << std::endl;
+            exit(1);
+        }
+    }
+
+    iaddr.getAddrInfo(AI);
+    if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
+        std::cerr << "ERROR: could not open socket to " << iaddr << std::endl;
+        Ip::Address::FreeAddrInfo(AI);
+        exit(1);
+    }
+    Ip::Address::FreeAddrInfo(AI);
+
+    if (Transport::Config.localHost) {
+        if (client_comm_bind(conn, iaddr) < 0) {
+            std::cerr << "ERROR: could not bind socket to " << iaddr << std::endl;
+            exit(1);
+        }
+
+        iaddr.setEmpty();
+
+        debugVerbose(2, "Resolving... " << Transport::Config.hostname);
+
+        if ( !iaddr.GetHostByName(Transport::Config.hostname) ) {
+            std::cerr << "ERROR: Cannot resolve " << Transport::Config.hostname << ": Host unknown." << std::endl;
+            exit(1);
+        }
+    }
+
+    iaddr.port(Transport::Config.port);
+}
+
+/// Set up the destination socket address for message to send to.
+static int
+client_comm_connect(int sock, const Ip::Address &addr)
+{
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
+    Ping::TimerStart();
+    return res;
+}
+
+bool
+Transport::Connect()
+{
+    Ip::Address iaddr;
+    resolveDestination(iaddr);
+
+    debugVerbose(2, "Connecting... " << Config.hostname << " (" << iaddr << ")");
+
+    if (client_comm_connect(conn, iaddr) < 0) {
+        char hostnameBuf[MAX_IPSTRLEN];
+        iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
+        std::cerr << "ERROR: Cannot connect to " << hostnameBuf
+                  << (!errno ?": Host unknown." : "") << std::endl;
+        exit(1);
+    }
+    debugVerbose(2, "Connected to: " << Config.hostname << " (" << iaddr << ")");
+
+    // do any TLS setup that might be needed
+    if (!Transport::MaybeStartTls(Config.hostname))
+        return false;
+
+    return true;
+}
+
+ssize_t
+Transport::Write(void *buf, size_t len)
+{
+    if (conn < 0)
+        return -1;
+
+    if (Config.tlsEnabled) {
+#if USE_GNUTLS
+        gnutls_record_send(Config.session, buf, len);
+        return len;
+#else
+        return 0;
+#endif
+    } else {
+
+#if _SQUID_WINDOWS_
+        return send(conn, buf, len, 0);
+#else
+        alarm(Config.ioTimeout);
+        return write(conn, buf, len);
+#endif
+    }
+}
+
+ssize_t
+Transport::Read(void *buf, size_t len)
+{
+    if (conn < 0)
+        return -1;
+
+    if (Config.tlsEnabled) {
+#if USE_GNUTLS
+        return gnutls_record_recv(Config.session, buf, len);
+#else
+        return 0;
+#endif
+    } else {
+
+#if _SQUID_WINDOWS_
+        return recv(conn, buf, len, 0);
+#else
+        alarm(Config.ioTimeout);
+        return read(conn, buf, len);
+#endif
+    }
+}
+
+void
+Transport::CloseConnection()
+{
+    (void) close(conn);
+    conn = -1;
+}
+
+#if USE_GNUTLS
+/* This function will verify the peer's certificate, and check
+ * if the hostname matches, as well as the activation, expiration dates.
+ */
+static int
+verifyByCA(gnutls_session_t session)
+{
+    /* read hostname */
+    const char *hostname = static_cast<const char*>(gnutls_session_get_ptr(session));
+
+    /* This verification function uses the trusted CAs in the credentials
+     * structure. So you must have installed one or more CA certificates.
+     */
+    unsigned int status;
+    if (gnutls_certificate_verify_peers3(session, hostname, &status) < 0) {
+        std::cerr << "VERIFY peers failure";
+        return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+
+    gnutls_certificate_type_t type = gnutls_certificate_type_get(session);
+    gnutls_datum_t out;
+    if (gnutls_certificate_verification_status_print(status, type, &out, 0) < 0) {
+        std::cerr << "VERIFY status failure";
+        return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+
+    std::cerr << "VERIFY DATUM: " << out.data << std::endl;
+    gnutls_free(out.data);
+
+    if (status != 0)        /* Certificate is not trusted */
+        return GNUTLS_E_CERTIFICATE_ERROR;
+
+    /* notify gnutls to continue handshake normally */
+    return GNUTLS_E_SUCCESS;
+}
+
+static int
+verifyTlsCertificate(gnutls_session_t session)
+{
+    // XXX: 1) try to verify using DANE -> Secure Authenticated Connection
+
+    // 2) try to verify using CA
+    if (verifyByCA(session) == GNUTLS_E_SUCCESS) {
+        std::cerr << "SUCCESS: CA verified Encrypted Connection" << std::endl;
+        return GNUTLS_E_SUCCESS;
+    }
+
+    // 3) fails both is insecure, but show the results anyway.
+    std::cerr << "WARNING: Insecure Connection" << std::endl;
+    return GNUTLS_E_SUCCESS;
+}
+#endif
+
+void
+Transport::InitTls()
+{
+#if USE_GNUTLS
+    debugVerbose(3, "Initializing TLS library...");
+    // NP: gnutls init is re-entrant and lock-counted with deinit but not thread safe.
+    if (gnutls_global_init() != GNUTLS_E_SUCCESS) {
+        std::cerr << "FATAL ERROR: TLS Initialize failed: " << xstrerror() << std::endl;
+        exit(1);
+    }
+
+    Config.tlsEnabled = true;
+
+    // Initialize for anonymous TLS
+    gnutls_anon_allocate_client_credentials(&Config.anonCredentials);
+
+    // Initialize for X.509 certificate exchange
+    gnutls_certificate_allocate_credentials(&Config.certCredentials);
+    for (std::list<std::string>::const_iterator i = Config.caFiles.begin(); i != Config.caFiles.end(); ++i) {
+        int x = gnutls_certificate_set_x509_trust_file(Config.certCredentials, (*i).c_str(), GNUTLS_X509_FMT_PEM);
+        if (x < 0) {
+            debugVerbose(3, "WARNING: Failed to load Certificate Authorities from " << *i);
+        } else {
+            debugVerbose(3, "Loaded " << x << " Certificate Authorities from " << *i);
+        }
+    }
+    gnutls_certificate_set_verify_function(Config.certCredentials, verifyTlsCertificate);
+
+    for (std::list<std::string>::const_iterator i = Config.certFiles.begin(); i != Config.certFiles.end(); ++i) {
+        if (gnutls_certificate_set_x509_key_file(Transport::Config.certCredentials, (*i).c_str(), (*i).c_str(), GNUTLS_X509_FMT_PEM) != GNUTLS_E_SUCCESS) {
+            debugVerbose(3, "WARNING: Failed to load Certificate from " << *i);
+        } else {
+            debugVerbose(3, "Loaded Certificate from " << *i);
+        }
+    }
+
+#else
+    std::cerr << "ERROR: TLS support not available." << std::endl;
+#endif
+}
+
+#if USE_GNUTLS
+
+// perform the actual handshake exchange with remote server
+static bool
+doTlsHandshake(const char *type)
+{
+    // setup the connection for TLS
+    gnutls_transport_set_int(Transport::Config.session, conn);
+    gnutls_handshake_set_timeout(Transport::Config.session, GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);
+
+    debugVerbose(2, type << " TLS handshake ... ");
+
+    int ret = 0;
+    do {
+        ret = gnutls_handshake(Transport::Config.session);
+    } while (ret < 0 && gnutls_error_is_fatal(ret) == 0);
+
+    if (ret < 0) {
+        std::cerr << "ERROR: " << type << " TLS Handshake failed (" << ret << ") "
+                  << gnutls_alert_get_name(gnutls_alert_get(Transport::Config.session))
+                  << std::endl;
+        gnutls_perror(ret);
+        gnutls_deinit(Transport::Config.session);
+        return false;
+    }
+
+    char *desc = gnutls_session_get_desc(Transport::Config.session);
+    debugVerbose(3, "TLS Session info: " << std::endl << desc << std::endl);
+    gnutls_free(desc);
+    return true;
+}
+
+static bool
+loadTlsParameters()
+{
+    const char *err = NULL;
+    int x;
+    if ((x = gnutls_priority_set_direct(Transport::Config.session, Transport::Config.params, &err)) != GNUTLS_E_SUCCESS) {
+        if (x == GNUTLS_E_INVALID_REQUEST)
+            std::cerr << "ERROR: Syntax error at: " << err << std::endl;
+        gnutls_perror(x);
+        return false;
+    }
+    return true;
+}
+
+// attempt an anonymous TLS handshake
+// this encrypts the connection but does not secure it
+// so many public servers do not support this handshake type.
+static bool
+tryTlsAnonymous()
+{
+    if (!loadTlsParameters())
+        return false;
+
+    // put the anonymous credentials to the current session
+    int x;
+    if ((x = gnutls_credentials_set(Transport::Config.session, GNUTLS_CRD_ANON, Transport::Config.anonCredentials)) != GNUTLS_E_SUCCESS) {
+        std::cerr << "ERROR: Anonymous TLS credentials setup failed (" << x << ") " << std::endl;
+        gnutls_perror(x);
+        return false;
+    }
+
+    return doTlsHandshake("Anonymous");
+}
+
+// attempt a X.509 certificate exchange
+// this both encrypts and authenticates the connection
+static bool
+tryTlsCertificate(const char *hostname)
+{
+    gnutls_session_set_ptr(Transport::Config.session, (void *) hostname);
+    gnutls_server_name_set(Transport::Config.session, GNUTLS_NAME_DNS, hostname, strlen(hostname));
+
+    if (!loadTlsParameters())
+        return false;
+
+    // put the X.509 credentials to the current session
+    gnutls_credentials_set(Transport::Config.session, GNUTLS_CRD_CERTIFICATE, Transport::Config.certCredentials);
+
+    // setup the connection for TLS
+    gnutls_transport_set_int(Transport::Config.session, conn);
+    gnutls_handshake_set_timeout(Transport::Config.session, GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);
+
+    return doTlsHandshake("X.509");
+}
+#endif
+
+bool
+Transport::MaybeStartTls(const char *hostname)
+{
+#if USE_GNUTLS
+    if (Config.tlsEnabled) {
+
+        // Initialize TLS session
+        gnutls_init(&Transport::Config.session, GNUTLS_CLIENT);
+
+        if (Transport::Config.tlsAnonymous && !tryTlsAnonymous()) {
+            gnutls_deinit(Config.session);
+            return false;
+        }
+
+        if (!tryTlsCertificate(hostname)) {
+            gnutls_deinit(Config.session);
+            return false;
+        }
+    }
+#endif
+    return true;
+}
+
+void
+Transport::ShutdownTls()
+{
+#if USE_GNUTLS
+    if (!Config.tlsEnabled)
+        return;
+
+    debugVerbose(3, "Shutting down TLS library...");
+
+    // release any existing session and credentials
+    gnutls_deinit(Config.session);
+    gnutls_anon_free_client_credentials(Config.anonCredentials);
+    gnutls_certificate_free_credentials(Config.certCredentials);
+
+    // NP: gnutls init is re-entrant and lock-counted with deinit but not thread safe.
+    gnutls_global_deinit();
+    Config.tlsEnabled = false;
+#endif
+}
@@ -0,0 +1,113 @@
+#ifndef SQUID_TOOLS_SQUIDCLIENT_TRANSPORT_H
+#define SQUID_TOOLS_SQUIDCLIENT_TRANSPORT_H
+
+#include "tools/squidclient/Parameters.h"
+
+#if HAVE_GNUTLS_GNUTLS_H
+#include <gnutls/gnutls.h>
+#endif
+#include <list>
+#include <string>
+
+namespace Transport
+{
+
+/// parameters controlling outgoing connection
+class TheConfig
+{
+public:
+    TheConfig() :
+        ioTimeout(120),
+        localHost(NULL),
+        port(CACHE_HTTP_PORT),
+        tlsEnabled(false),
+        tlsAnonymous(false)
+    {
+        params = "NORMAL";
+        hostname = "localhost";
+    }
+
+// TODO: implicit transport options depending on the protocol-specific options
+//     ie --https enables TLS connection settings
+
+    /// display Transport Options command line help to stderr
+    void usage();
+
+    /**
+     * parse transport related command line options
+     * \return true if there are other options still to parse
+     */
+    bool parseCommandOpts(int argc, char *argv[], int c, int &optIndex);
+
+    /// I/O operation timeout
+    int ioTimeout;
+
+    /// the local hostname to bind as for outgoing IP
+    const char *localHost;
+
+    /// the destination server host name to contact
+    const char *hostname;
+
+    /// port on the server to contact
+    uint16_t port;
+
+    /// whether to enable TLS on the server connnection
+    bool tlsEnabled;
+
+    /// whether to do anonymous TLS (non-authenticated)
+    bool tlsAnonymous;
+
+    /// The TLS parameters (list of ciphers, versions, flags)
+    /// Default is "NORMAL" unless tlsAnonymous is used,
+    /// in which case it becomes "PERFORMANCE:+ANON-ECDH:+ANON-DH".
+    /// see http://gnutls.org/manual/html_node/Priority-Strings.html
+    const char *params;
+
+    // client certificate PEM file(s)
+    std::list<std::string> certFiles;
+
+    // client trusted x509 certificate authorities file
+    std::list<std::string> caFiles;
+
+#if USE_GNUTLS
+    /// anonymous client credentials
+    gnutls_anon_client_credentials_t anonCredentials;
+
+    // client x509 certificate credentials
+    gnutls_certificate_credentials_t certCredentials;
+
+    /// TLS session state
+    gnutls_session_t session;
+#endif
+};
+
+extern TheConfig Config;
+
+/// locate and connect to the configured server
+bool Connect();
+
+/// close the current connection
+void CloseConnection();
+
+/// Initialize TLS library environment when necessary.
+void InitTls();
+
+/// perform TLS handshake on the currently open connection if
+/// TLS library has been initialized.
+/// return false on errors, true otherwise even if TLS not performed.
+bool MaybeStartTls(const char *hostname);
+
+/// De-initialize TLS library environment when necessary.
+void ShutdownTls();
+
+/// write len bytes to the currently open connection.
+/// \return the number of bytes written, or -1 on errors
+ssize_t Write(void *buf, size_t len);
+
+/// read up to len bytes from the currently open connection.
+/// \return the number of bytes read, or -1 on errors
+ssize_t Read(void *buf, size_t len);
+
+} // namespace Transport
+
+#endif /* SQUID_TOOLS_SQUIDCLIENT_TRANSPORT_H */
@@ -7,22 +7,23 @@ A simple HTTP web client tool
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B squidclient
-.if !'po4a'hide' .B "[ \-\-ping [ping-options] ] "
-.if !'po4a'hide' .B "[ \-aknNrsv ] [ \-A"
+.if !'po4a'hide' .B "[ \-aknNrsv ] "
+.if !'po4a'hide' .B "[ \-\-ping [ping\-options] ] "
+.if !'po4a'hide' .B "[ \-\-https] [tls\-options] [ \-A"
 string
-.if !'po4a'hide' .B "] [ \-h"
+.if !'po4a'hide' .B "] [ \-h | \-\-host"
 remote host
 .if !'po4a'hide' .B "] [ \-H '"
 string
 .if !'po4a'hide' .B "' ] [ \-i"
 IMS
 .if !'po4a'hide' .B "] [ \-j '"
 Host header
-.if !'po4a'hide' .B "' ] [ \-l"
-local host
+.if !'po4a'hide' .B "' ] [ \-l | \-\-local"
+host
 .if !'po4a'hide' .B "] [ \-m"
 method
-.if !'po4a'hide' .B "] [ \-p"
+.if !'po4a'hide' .B "] [ \-p | \-\-port"
 port
 .if !'po4a'hide' .B "] [ \-P"
 file
@@ -49,6 +50,14 @@ count
 interval
 .if !'po4a'hide' .B "] "
 .
+.if !'po4a'hide' .B "TLS options: [ \-\-anonymous\-tls ] [ \-\-trusted\-ca"
+CA certificates file
+.if !'po4a'hide' .B "...] [ \-\-cert"
+client X.509 certificate file
+.if !'po4a'hide' .B "] [ \-\-params"
+TLS session parameters
+.if !'po4a'hide' .B "] "
+.
 .SH DESCRIPTION
 .B squidclient
 is a tool providing a command line interface for retrieving URLs.
@@ -70,8 +79,8 @@ Send
 as User-Agent: header. To omit the header completely set string to empty ('').
 .
 .if !'po4a'hide' .TP
-.if !'po4a'hide' .B "\-h host"
-Retrieve URL from cache on hostname.  Default is
+.if !'po4a'hide' .B "\-h | \-\-host host"
+Retrieve URL from server host.  Default is
 .B localhost
 .
 .if !'po4a'hide' .TP
@@ -93,7 +102,7 @@ Host header content
 Keep the connection active. Default is to do only one request then close.
 .
 .if !'po4a'hide' .TP
-.if !'po4a'hide' .B "\-l host"
+.if !'po4a'hide' .B "\-l | \-\-local host"
 Specify a local IP address to bind to.  Default is none.
 .
 .if !'po4a'hide' .TP
@@ -177,6 +186,31 @@ Proxy authentication password
 .if !'po4a'hide' .B "\-W password"
 WWW authentication password
 .
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-https"
+Use Transport Layer Security on the HTTP connection.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-anonymous\-tls"
+Use TLS with unauthenticated (anonymous) certificate.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-cert file"
+File containing client X.509 certificate in PEM format.
+May be repeated to load several client certificates.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-trusted-ca file"
+File containing trusted Certificate Authority (CA) certificates in PEM format.
+May be repeated to load any number of files.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-params values"
+TLS library specific parameters for the communication session.
+See the library documentation for details on valid parameters.
+.if !'po4a'hide' .I "GnuTLS: http://gnutls.org/manual/html_node/Priority\-Strings.html"
+If repeated only the last value will have effect.
+.
 .if !'po4a'hide' .TP 10
 .if !'po4a'hide' .B "\-\-ping [options]"
 Enable ping mode. Optional \-g and \-I parameters must follow immediately if used.
@@ -38,6 +38,7 @@
 #include "tools/squidclient/gssapi_support.h"
 #include "tools/squidclient/Parameters.h"
 #include "tools/squidclient/Ping.h"
+#include "tools/squidclient/Transport.h"
 
 #if _SQUID_WINDOWS_
 /** \cond AUTODOCS-IGNORE */
@@ -84,20 +85,11 @@ using namespace Squid;
 #define HEADERLEN	65536
 #endif
 
-/// display debug messages at varying verbosity levels
-#define debugVerbose(LEVEL, MESSAGE) \
-    while ((LEVEL) <= scParams.verbosityLevel) {std::cerr << MESSAGE << std::endl; break;}
-
 /* Local functions */
-static int client_comm_bind(int, const Ip::Address &);
-
-static int client_comm_connect(int, const Ip::Address &);
 static void usage(const char *progname);
 
 void pipe_handler(int sig);
 static void set_our_signal(void);
-static ssize_t myread(int fd, void *buf, size_t len);
-static ssize_t mywrite(int fd, void *buf, size_t len);
 
 Parameters scParams;
 
@@ -106,7 +98,6 @@ static char *put_file = NULL;
 
 static struct stat sb;
 int total_bytes = 0;
-int io_timeout = 120;
 
 #if _SQUID_AIX_
 /* Bug 3854: AIX 6.1 tries to link in this fde.h global symbol
@@ -129,19 +120,16 @@ usage(const char *progname)
 {
     std::cerr << "Version: " << VERSION << std::endl
               << "Usage: " << progname << " [Basic Options] [HTTP Options]" << std::endl
-              << std::endl
-              << "Basic Options:" << std::endl
-              << "    -h host         Send message to server on 'host'.  Default is localhost." << std::endl
-              << "    -l host         Specify a local IP address to bind to.  Default is none." << std::endl
-              << "    -p port         Port number on server to contact. Default is " << CACHE_HTTP_PORT << "." << std::endl
+              << std::endl;
+    std::cerr
               << "    -s | --quiet    Silent.  Do not print response message to stdout." << std::endl
-              << "    -T timeout      Timeout value (seconds) for read/write operations" << std::endl
               << "    -v | --verbose  Verbose debugging. Repeat (-vv) to increase output level." << std::endl
               << "                    Levels:" << std::endl
               << "                      1 - Print outgoing request message to stderr." << std::endl
               << "                      2 - Print action trace to stderr." << std::endl
               << "    --help          Display this help text." << std::endl
               << std::endl;
+    Transport::Config.usage();
     Ping::Config.usage();
     std::cerr
         << "HTTP Options:" << std::endl
@@ -171,16 +159,13 @@ usage(const char *progname)
 int
 main(int argc, char *argv[])
 {
-    int conn, len, bytesWritten;
-    uint16_t port;
+    int len, bytesWritten;
     bool to_stdout, reload;
     int keep_alive = 0;
     int opt_noaccept = 0;
 #if HAVE_GSSAPI
     int www_neg = 0, proxy_neg = 0;
 #endif
-    const char *hostname, *localhost;
-    Ip::Address iaddr;
     char url[BUFSIZ], msg[MESSAGELEN], buf[BUFSIZ];
     char extra_hdrs[HEADERLEN];
     const char *method = "GET";
@@ -197,10 +182,7 @@ main(int argc, char *argv[])
     const char *useragent = NULL;
 
     /* set the defaults */
-    hostname = "localhost";
-    localhost = NULL;
     extra_hdrs[0] = '\0';
-    port = CACHE_HTTP_PORT;
     to_stdout = true;
     reload = false;
 
@@ -212,15 +194,19 @@ main(int argc, char *argv[])
         url[BUFSIZ - 1] = '\0';
 
         int optIndex = 0;
-        const char *shortOpStr = "aA:h:j:V:l:P:i:kmnN:p:rsvt:p:H:T:u:U:w:W:?";
+        const char *shortOpStr = "aA:h:j:V:l:P:i:kmnN:p:rsvt:H:T:u:U:w:W:?";
 
         // options for controlling squidclient
         static struct option basicOptions[] = {
             /* These are the generic options for squidclient itself */
             {"help",    no_argument, 0, '?'},
             {"verbose", no_argument, 0, 'v'},
             {"quiet",   no_argument, 0, 's'},
+            {"host",    required_argument, 0, 'h'},
+            {"local",   required_argument, 0, 'l'},
+            {"port",    required_argument, 0, 'p'},
             {"ping",    no_argument, 0, '\1'},
+            {"https",   no_argument, 0, '\3'},
             {0, 0, 0, 0}
         };
 
@@ -231,9 +217,18 @@ main(int argc, char *argv[])
             switch (c) {
             case '\1':
                 to_stdout = 0;
-                if (Ping::Config.parseCommandOpts(argc, argv, c, optIndex))
-                    continue;
-                break;
+                Ping::Config.parseCommandOpts(argc, argv, c, optIndex);
+                continue;
+
+            case 'h':		/* remote host */
+            case 'l':		/* local host */
+            case 'p':		/* port number */
+                // rewind and let the Transport::Config parser handle
+                optind -= 2;
+
+            case '\3': // request over a TLS connection
+                Transport::Config.parseCommandOpts(argc, argv, c, optIndex);
+                continue;
 
             default: // fall through to next switch
                 break;
@@ -252,10 +247,6 @@ main(int argc, char *argv[])
                 useragent = optarg;
                 break;
 
-            case 'h':		/* remote host */
-                hostname = optarg;
-                break;
-
             case 'j':
                 host = optarg;
                 break;
@@ -264,10 +255,6 @@ main(int argc, char *argv[])
                 version = optarg;
                 break;
 
-            case 'l':		/* local host */
-                localhost = optarg;
-                break;
-
             case 's':		/* silent */
                 to_stdout = false;
                 break;
@@ -280,12 +267,6 @@ main(int argc, char *argv[])
                 reload = true;
                 break;
 
-            case 'p':		/* port number */
-                sscanf(optarg, "%hd", &port);
-                if (port < 1)
-                    port = CACHE_HTTP_PORT;	/* default */
-                break;
-
             case 'P':
                 put_file = xstrdup(optarg);
                 break;
@@ -313,7 +294,7 @@ main(int argc, char *argv[])
                 break;
 
             case 'T':
-                io_timeout = atoi(optarg);
+                Transport::Config.ioTimeout = atoi(optarg);
                 break;
 
             case 'u':
@@ -380,9 +361,9 @@ main(int argc, char *argv[])
         }
         // embed the -w proxy password into old-style cachemgr URLs
         if (at)
-            snprintf(url, BUFSIZ, "cache_object://%s/%s@%s", hostname, t, at);
+            snprintf(url, BUFSIZ, "cache_object://%s/%s@%s", Transport::Config.hostname, t, at);
         else
-            snprintf(url, BUFSIZ, "cache_object://%s/%s", hostname, t);
+            snprintf(url, BUFSIZ, "cache_object://%s/%s", Transport::Config.hostname, t);
         xfree(t);
     }
     if (put_file) {
@@ -499,8 +480,8 @@ main(int argc, char *argv[])
                 std::cerr << "ERROR: server host missing" << std::endl;
         }
         if (proxy_neg) {
-            if (hostname) {
-                snprintf(buf, BUFSIZ, "Proxy-Authorization: Negotiate %s\r\n", GSSAPI_token(hostname));
+            if (Transport::Config.hostname) {
+                snprintf(buf, BUFSIZ, "Proxy-Authorization: Negotiate %s\r\n", GSSAPI_token(Transport::Config.hostname));
                 strcat(msg, buf);
             } else
                 std::cerr << "ERROR: proxy server host missing" << std::endl;
@@ -525,61 +506,13 @@ main(int argc, char *argv[])
 
     for (uint32_t i = 0; loops == 0 || i < loops; ++i) {
         size_t fsize = 0;
-        struct addrinfo *AI = NULL;
-
-        debugVerbose(2, "Resolving... " << hostname);
-
-        /* Connect to the server */
-
-        if (localhost) {
-            if ( !iaddr.GetHostByName(localhost) ) {
-                std::cerr << "ERROR: Cannot resolve " << localhost << ": Host unknown." << std::endl;
-                exit(1);
-            }
-        } else {
-            /* Process the remote host name to locate the Protocol required
-               in case we are being asked to link to another version of squid */
-            if ( !iaddr.GetHostByName(hostname) ) {
-                std::cerr << "ERROR: Cannot resolve " << hostname << ": Host unknown." << std::endl;
-                exit(1);
-            }
-        }
-
-        iaddr.getAddrInfo(AI);
-        if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
-            std::cerr << "ERROR: could not open socket to " << iaddr << std::endl;
-            Ip::Address::FreeAddrInfo(AI);
-            exit(1);
-        }
-        Ip::Address::FreeAddrInfo(AI);
-
-        if (localhost && client_comm_bind(conn, iaddr) < 0) {
-            std::cerr << "ERROR: could not bind socket to " << iaddr << std::endl;
-            exit(1);
-        }
-
-        iaddr.setEmpty();
-        if ( !iaddr.GetHostByName(hostname) ) {
-            std::cerr << "ERROR: Cannot resolve " << hostname << ": Host unknown." << std::endl;
-            exit(1);
-        }
-
-        iaddr.port(port);
 
-        debugVerbose(2, "Connecting... " << hostname << " (" << iaddr << ")");
-
-        if (client_comm_connect(conn, iaddr) < 0) {
-            char hostnameBuf[MAX_IPSTRLEN];
-            iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
-            std::cerr << "ERROR: Cannot connect to " << hostnameBuf
-                      << (!errno ?": Host unknown." : "") << std::endl;
-            exit(1);
-        }
-        debugVerbose(2, "Connected to: " << hostname << " (" << iaddr << ")");
+        if (!Transport::Connect())
+            continue;
 
         /* Send the HTTP request */
         debugVerbose(2, "Sending HTTP request ... ");
-        bytesWritten = mywrite(conn, msg, strlen(msg));
+        bytesWritten = Transport::Write(msg, strlen(msg));
 
         if (bytesWritten < 0) {
             std::cerr << "ERROR: write" << std::endl;
@@ -596,7 +529,7 @@ main(int argc, char *argv[])
             lseek(put_fd, 0, SEEK_SET);
             while ((x = read(put_fd, buf, sizeof(buf))) > 0) {
 
-                x = mywrite(conn, buf, x);
+                x = Transport::Write(buf, x);
 
                 total_bytes += x;
 
@@ -615,18 +548,30 @@ main(int argc, char *argv[])
         setmode(1, O_BINARY);
 #endif
 
-        while ((len = myread(conn, buf, sizeof(buf))) > 0) {
+        while ((len = Transport::Read(buf, sizeof(buf))) > 0) {
             fsize += len;
 
             if (to_stdout && fwrite(buf, len, 1, stdout) != 1)
                 std::cerr << "ERROR: writing to stdout: " << xstrerror() << std::endl;
         }
 
+#if USE_GNUTLS
+        if (Transport::Config.tlsEnabled) {
+            if (len == 0) {
+                std::cerr << "- Peer has closed the TLS connection" << std::endl;
+            } else if (!gnutls_error_is_fatal(len)) {
+                std::cerr << "WARNING: " << gnutls_strerror(len) << std::endl;
+            } else {
+                std::cerr << "ERROR: " << gnutls_strerror(len) << std::endl;
+            }
+        }
+#endif
+
 #if _SQUID_WINDOWS_
         setmode(1, O_TEXT);
 #endif
 
-        (void) close(conn);	/* done with socket */
+        Transport::CloseConnection();
 
         if (Ping::LoopDone(i))
             break;
@@ -635,32 +580,10 @@ main(int argc, char *argv[])
     }
 
     Ping::DisplayStats();
+    Transport::ShutdownTls();
     return 0;
 }
 
-/// Set up the source socket address from which to send.
-static int
-client_comm_bind(int sock, const Ip::Address &addr)
-{
-    static struct addrinfo *AI = NULL;
-    addr.getAddrInfo(AI);
-    int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
-    return res;
-}
-
-/// Set up the destination socket address for message to send to.
-static int
-client_comm_connect(int sock, const Ip::Address &addr)
-{
-    static struct addrinfo *AI = NULL;
-    addr.getAddrInfo(AI);
-    int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
-    Ping::TimerStart();
-    return res;
-}
-
 void
 pipe_handler(int sig)
 {
@@ -684,25 +607,3 @@ set_our_signal(void)
     signal(SIGPIPE, pipe_handler);
 #endif
 }
-
-static ssize_t
-myread(int fd, void *buf, size_t len)
-{
-#if _SQUID_WINDOWS_
-    return recv(fd, buf, len, 0);
-#else
-    alarm(io_timeout);
-    return read(fd, buf, len);
-#endif
-}
-
-static ssize_t
-mywrite(int fd, void *buf, size_t len)
-{
-#if _SQUID_WINDOWS_
-    return send(fd, buf, len, 0);
-#else
-    alarm(io_timeout);
-    return write(fd, buf, len);
-#endif
-}