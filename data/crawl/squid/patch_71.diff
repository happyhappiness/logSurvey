----++++src/anyp/PortCfg.cc
@@ -46,7 +46,6 @@ AnyP::PortCfg::PortCfg() :
     sslContextSessionId(NULL),
     generateHostCertificates(false),
     dynamicCertMemCacheSize(std::numeric_limits&lt;size_t&gt;::max()),
-    staticSslContext(),
     signingCert(),
     signPkey(),
     certsToChain(),
@@ -143,12 +142,11 @@ AnyP::PortCfg::configureSslServerContext()
     }
 
     secure.updateTlsVersionLimits();
+    secure.staticContext.reset(sslCreateServerContext(*this));
 
-    staticSslContext.reset(sslCreateServerContext(*this));
-
-    if (!staticSslContext) {
+    if (!secure.staticContext) {
         char buf[128];
-        fatalf("%s_port %s initialization error", AnyP::ProtocolType_str[transport.protocol],  s.toUrl(buf, sizeof(buf)));
+        fatalf("%s_port %s initialization error", AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
     }
 }
 #endif
----++++src/anyp/PortCfg.h
@@ -74,11 +74,10 @@ class PortCfg : public RefCountable
 
 #if USE_OPENSSL
     char *clientca;
-    char *sslContextSessionId; ///&lt; "session id context" for staticSslContext
+    char *sslContextSessionId; ///&lt; "session id context" for secure.staticSslContext
     bool generateHostCertificates; ///&lt; dynamically make host cert for sslBump
     size_t dynamicCertMemCacheSize; ///&lt; max size of generated certificates memory cache
 
-    Security::ContextPointer staticSslContext; ///&lt; for HTTPS accelerator or static sslBump
     Security::CertPointer signingCert; ///&lt; x509 certificate for signing generated certificates
     Ssl::EVP_PKEY_Pointer signPkey; ///&lt; private key for sighing generated certificates
     Ssl::X509_STACK_Pointer certsToChain; ///&lt;  x509 certificates to send with the generated cert
----++++src/client_side.cc
@@ -3542,8 +3542,7 @@ ConnStateData::postHttpsAccept()
         acl_checklist-&gt;nonBlockingCheck(httpsSslBumpAccessCheckDone, this);
         return;
     } else {
-        Security::ContextPtr sslContext = port-&gt;staticSslContext.get();
-        httpsEstablish(this, sslContext);
+        httpsEstablish(this, port-&gt;secure.staticContext.get());
     }
 }
 
@@ -3783,13 +3782,13 @@ ConnStateData::getSslContextDone(Security::ContextPtr sslContext, bool isNew)
 
     // If generated ssl context = NULL, try to use static ssl context.
     if (!sslContext) {
-        if (!port-&gt;staticSslContext) {
-            debugs(83, DBG_IMPORTANT, "Closing SSL " &lt;&lt; clientConnection-&gt;remote &lt;&lt; " as lacking SSL context");
+        if (!port-&gt;secure.staticContext) {
+            debugs(83, DBG_IMPORTANT, "Closing " &lt;&lt; clientConnection-&gt;remote &lt;&lt; " as lacking TLS context");
             clientConnection-&gt;close();
             return;
         } else {
-            debugs(33, 5, HERE &lt;&lt; "Using static ssl context.");
-            sslContext = port-&gt;staticSslContext.get();
+            debugs(33, 5, "Using static TLS context.");
+            sslContext = port-&gt;secure.staticContext.get();
         }
     }
 
@@ -4139,7 +4138,7 @@ clientHttpConnectionsOpen(void)
                 debugs(33, DBG_IMPORTANT, &quot;WARNING: No ssl_bump configured. Disabling ssl-bump on &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s);
                 s-&gt;flags.tunnelSslBumping = false;
             }
-            if (!s-&gt;staticSslContext &amp;&amp; !s-&gt;generateHostCertificates) {
+            if (!s-&gt;secure.staticContext &amp;&amp; !s-&gt;generateHostCertificates) {
                 debugs(1, DBG_IMPORTANT, &quot;Will not bump SSL at &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to TLS initialization failure.&quot;);
                 s-&gt;flags.tunnelSslBumping = false;
                 if (s-&gt;transport.protocol == AnyP::PROTO_HTTP)
@@ -4152,7 +4151,7 @@ clientHttpConnectionsOpen(void)
             }
         }
 
-        if (s-&gt;secure.encryptTransport &amp;&amp; !s-&gt;staticSslContext) {
+        if (s-&gt;secure.encryptTransport &amp;&amp; !s-&gt;secure.staticContext) {
             debugs(1, DBG_CRITICAL, &quot;ERROR: Ignoring &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to TLS context initialization failure.&quot;);
             continue;
         }
----++++src/security/ServerOptions.h
@@ -30,13 +30,15 @@ class ServerOptions : public PeerOptions
     /// update the context with DH, EDH, EECDH settings
     void updateContextEecdh(Security::ContextPtr &amp;);
 
+public:
+    /// TLS context to use for HTTPS accelerator or static SSL-Bump
+    Security::ContextPointer staticContext;
+
 private:
     void loadDhParams();
 
-//public:
-    SBuf dh;            ///&lt; Diffi-Helman cipher config
-
 private:
+    SBuf dh;            ///&lt; Diffi-Helman cipher config
     SBuf dhParamsFile;  ///&lt; Diffi-Helman ciphers parameter file
     SBuf eecdhCurve;    ///&lt; Elliptic curve for ephemeral EC-based DH key exchanges
 
----++++src/ssl/support.cc
@@ -1531,8 +1531,8 @@ Ssl::initialize_session_cache()
     }
 
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
-        if (s-&gt;staticSslContext.get() != NULL)
-            setSessionCallbacks(s-&gt;staticSslContext.get());
+        if (s-&gt;secure.staticContext.get())
+            setSessionCallbacks(s-&gt;secure.staticContext.get());
     }
 }
 
----++++GitHub