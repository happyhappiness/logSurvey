@@ -1,31 +1,72 @@
-autom4te.cache
-config.log
-autom4te*
-libtool
-configure.lineno
-*.patch
-icons/*.gif
-tags
-tmp
-.deps
-.libs
-.dirstamp
 *.la
 *.lo
+*.loT
+*.patch
+*/*/*/Makefile
+*/Makefile
 */globals.cc
+.deps
+.dirstamp
+.libs
+Makefile
 Makefile.in
-configure
-config.h.in
-cfgaux
-stamp-h.in
 aclocal.m4
 autoconf.h.in
-testHeaders
+autom4te*
+autom4te.cache
+cfgaux
+config.h.in
+config.log
+config.status
+configure
+configure.lineno
+depcomp
+doc/*.8
 doc/Programming-Guide/html
-helpers/*/Makefile
+helpers/**/*_auth
 helpers/*/*/Makefile
+helpers/*/Makefile
+helpers/basic_auth/**/Makefile
+helpers/digest_auth/**/Makefile
+helpers/external_acl/**/Makefile
+helpers/external_acl/ip_user/ip_user_check
+helpers/external_acl/session/squid_session
+helpers/external_acl/unix_group/squid_unix_group
+helpers/negotiate_auth/Makefile
+helpers/ntlm_auth/**/Makefile
+icons/*.gif
+include/autoconf.h
+include/stamp-h1
+install-sh
+lib/**/Makefile
+lib/**/config.h
+lib/libLtdl
+libtool
+missing
+scr/**/Makefile
 scripts/Makefile
+scripts/RunAccel
+scripts/RunCache
 snmplib/Makefile
 src/*/Makefile
+src/DiskIO/DiskDaemon/diskd
+src/cf.data
+src/cf_gen
+src/cf_gen_defines.h
+src/cf_parser.h
+src/globals.cc
+src/repl_modules.cc
+src/squid
+src/squid.conf.default
+src/string_arrays.c
+src/ufsdump
+src/unlinkd
+stamp-h.in
+stamp-h1
+tags
 test-suite/Makefile
+testHeaders
+tmp
 tools/Makefile
+tools/cachemgr.cgi
+tools/squidclient
@@ -66,7 +66,7 @@ Kaspersky Lab - http://www.kaspersky.com/
 Barefruit - http://www.barefruit.com/
 
 	Barefruit has funded Squid3 development and maintenance,
-	with a focus on the ICAP client support.
+	with a focus on content adaptation (ICAP and eCAP) support.
 
 Palisade Systems - http://www.palisadesys.com/
 
@@ -52,6 +52,48 @@ bootstrap() {
   fi
 }
 
+bootstrap_libtoolize() {
+    ltver=$1
+
+    # TODO: when we have libtool2, tell libtoolize where to put its files
+    # instead of manualy moving files from ltdl to lib/libLtdl
+    if egrep -q '^[[:space:]]*AC_LIBLTDL_' configure.in
+    then
+        extras="--ltdl"
+    else
+        extras=""
+    fi
+
+    bootstrap libtoolize$ltver $extras --force --copy --automake
+
+    # customize generated libltdl, if any
+    if test -d libltdl
+    then
+        src=libltdl
+
+        # do not bundle with the huge standard license text
+        rm -fv $src/COPYING.LIB
+        makefile=$src/Makefile.in
+        sed 's/COPYING.LIB/ /g' $makefile > $makefile.new;
+        chmod u+w $makefile
+        mv $makefile.new $makefile
+        chmod u-w $makefile
+
+        dest=lib/libLtdl
+        # move $src to $dest
+	if test -d $dest # already exists
+	then
+	    echo "Updating $dest from $src."
+            chmod u+w $dest/*
+            mv $src/* $dest/
+            rmdir $src
+	else
+	    echo "Creating $dest from $src."
+	    mv $src $dest
+        fi
+    fi
+}
+
 # Adjust paths of required autool packages
 amver=`find_version automake ${amversions}`
 acver=`find_version autoconf ${acversions}`
@@ -81,7 +123,7 @@ do
 	    # Bootstrap the autotool subsystems
 	    bootstrap aclocal$amver
 	    bootstrap autoheader$acver
-	    bootstrap libtoolize$ltver --force --copy --automake
+	    bootstrap_libtoolize $ltver
 	    bootstrap automake$amver --foreign --add-missing --copy -f
 	    bootstrap autoconf$acver --force
 	fi ); then
@@ -29,9 +29,59 @@ AM_PROG_CC_C_O
 AC_LANG_C
 AC_PROG_CXX
 AC_CANONICAL_HOST
-AC_DISABLE_SHARED
+
+
+use_loadable_modules=1
+AC_MSG_CHECKING(whether to use loadable modules)
+AC_ARG_ENABLE(loadable-modules,
+    [
+        AC_HELP_STRING(
+            [--disable-loadable-modules],
+            [do not support loadable modules])
+    ],
+    [
+        case "${enableval}" in
+            yes) use_loadable_modules=yes ;;
+            no) use_loadable_modules=no ;;
+            *) AC_MSG_ERROR(bad value ${enableval} for --disable-loadable-modules) ;;
+        esac
+        AC_MSG_RESULT([$use_loadable_modules, explicitly])
+    ],
+    [
+        use_loadable_modules=yes;
+        AC_MSG_RESULT([$use_loadable_modules, implicitly])
+    ]
+)        
+
+AM_CONDITIONAL(USE_LOADABLE_MODULES, test $use_loadable_modules = yes)
+
+if test $use_loadable_modules = yes;
+then
+    AC_DEFINE(USE_LOADABLE_MODULES, 1, [Support Loadable Modules])
+    AC_ENABLE_SHARED
+else
+    AC_DISABLE_SHARED
+fi
+
+AC_LIBTOOL_DLOPEN
+if test $use_loadable_modules = yes;
+then
+    AC_LIBLTDL_CONVENIENCE(lib/libLtdl)
+fi
 AC_PROG_LIBTOOL
 AC_LTDL_DLLIB
+
+# Do we need these unconditionally for "make distcheck" to work?
+AC_SUBST(INCLTDL)
+AC_SUBST(LIBLTDL)
+
+if test $use_loadable_modules = yes;
+then
+    # Why is this needed? Should not libtool's AC_LIBTOOL_DLOPEN do that?
+    LIBADD_DL=${lt_cv_dlopen_libs}
+    AC_SUBST([LIBADD_DL])
+fi
+
 AC_PROG_RANLIB
 
 
@@ -681,6 +731,9 @@ AC_ARG_ENABLE(delay-pools,
   fi
 ])
 
+dnl disable generic/common adaptation support by default
+use_adaptation=no
+
 AM_CONDITIONAL(USE_ESI, false)
 AC_ARG_ENABLE(esi,
               AC_HELP_STRING([--enable-esi],[Enable ESI for accelerators. Requires libexpat. Enabling ESI will cause squid to follow the Edge Acceleration Specification (www.esi.org). This causes squid to IGNORE client Cache-Control headers. DO NOT use this in a squid configured as a web proxy, ONLY use it in a squid configured for webserver acceleration.]),
@@ -700,13 +753,74 @@ AC_ARG_ENABLE(icap-client,
 if test "$use_icap_client" = "yes" ; then
   AC_DEFINE(ICAP_CLIENT,1,[Enable ICAP client features in Squid])
   AM_CONDITIONAL(USE_ICAP_CLIENT, true)
-  ICAP_LIBS="ICAP/libicap.a"
+  ICAP_LIBS="ICAP/libicap.la"
+  use_adaptation=yes
 else
   AC_DEFINE(ICAP_CLIENT,0,[Enable ICAP client features in Squid])
   ICAP_LIBS=""
 fi
 AC_SUBST(ICAP_LIBS)
 
+use_ecap=1
+AC_MSG_CHECKING(whether to support eCAP)
+AC_ARG_ENABLE(ecap,
+    [
+        AC_HELP_STRING(
+            [--enable-ecap],
+            [support loadable content adaptation modules])
+    ],
+    [
+        case "${enableval}" in
+            yes) use_ecap=yes ;;
+            no) use_ecap=no ;;
+            *) AC_MSG_ERROR(bad value ${enableval} for --enable-ecap) ;;
+        esac
+        AC_MSG_RESULT([$use_ecap, explicitly])
+    ],
+    [
+        use_ecap=no;
+        AC_MSG_RESULT([$use_ecap, implicitly])
+    ]
+)
+
+dnl Perform configuration consistency checks for eCAP
+if test $use_ecap = yes;
+then
+    dnl eCAP support requires loadable modules, which are enabled by default
+    if test "$use_loadable_modules" != "yes"
+    then
+        AC_MSG_ERROR([
+            eCAP support requires loadable modules. Please do not use
+            --disable-loadable-modules with --enable-ecap.]);
+    fi
+fi
+
+AM_CONDITIONAL(USE_ECAP, test $use_ecap = yes)
+if test $use_ecap = yes;
+then
+    AC_DEFINE(USE_ECAP,1,[Enable eCAP support])
+    ECAP_LIBS="eCAP/libeCAP.la"
+    use_adaptation=yes
+else
+    AC_DEFINE(USE_ECAP,0,[Disable eCAP support])
+    ECAP_LIBS=""
+fi
+AC_SUBST(ECAP_LIBS)
+
+
+dnl enable adaptation if requested by specific adaptation mechanisms
+AM_CONDITIONAL(USE_ADAPTATION, test $use_adaptation = yes)
+if test $use_adaptation = yes
+then
+    AC_DEFINE(USE_ADAPTATION,1,[common adaptation support])
+    ADAPTATION_LIBS="adaptation/libadaptation.la"
+else
+    AC_DEFINE(USE_ADAPTATION,0,[common adaptation support])
+    ADAPTATION_LIBS=""
+fi
+AC_SUBST(ADAPTATION_LIBS)
+
+
 dnl This is a developer only option. Developers know how to set defines
 dnl
 dnl AC_ARG_ENABLE(mem-gen-trace,
@@ -3448,6 +3562,9 @@ AC_CONFIG_FILES([\
 	src/fs/Makefile \
 	src/repl/Makefile \
 	src/auth/Makefile \
+	src/adaptation/Makefile \
+	src/ICAP/Makefile \
+	src/eCAP/Makefile \
 	contrib/Makefile \
 	snmplib/Makefile \
 	icons/Makefile \
@@ -3494,4 +3611,8 @@ AC_CONFIG_FILES([\
 
 AC_CONFIG_SUBDIRS(lib/libTrie)
 
+# must configure libltdl subdir unconditionally for "make distcheck" to work
+AC_CONFIG_SUBDIRS(lib/libLtdl)
+
+
 AC_OUTPUT
@@ -3,8 +3,16 @@
 #  $Id: Makefile.am,v 1.33 2007/12/14 23:11:44 amosjeffries Exp $
 #
 
-DIST_SUBDIRS = libTrie
-SUBDIRS= libTrie
+if USE_LOADABLE_MODULES
+DIST_SUBDIRS = libLtdl
+SUBDIRS      = libLtdl
+else
+DIST_SUBDIRS =
+SUBDIRS      =
+endif
+
+DIST_SUBDIRS += libTrie
+SUBDIRS      += libTrie
 
 install: all
 install-strip: all
@@ -10,8 +10,8 @@ class ClientHttpRequest;
 /* for CBDATA_CLASS() */
 #include "cbdata.h"
 
-#if ICAP_CLIENT
-#include "ICAP/ICAPServiceRep.h"
+#if USE_ADAPTATION
+#include "adaptation/forward.h"
 #endif
 
 class ClientRequestContext : public RefCountable
@@ -31,20 +31,20 @@ class ClientRequestContext : public RefCountable
     void clientRedirectDone(char *result);
     void checkNoCache();
     void checkNoCacheDone(int answer);
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 
-    void icapAccessCheck();
-    void icapAclCheckDone(ICAPServiceRep::Pointer service);
+    void adaptationAccessCheck();
+    void adaptationAclCheckDone(Adaptation::ServicePointer service);
 #endif
 
     ClientHttpRequest *http;
     ACLChecklist *acl_checklist;        /* need ptr back so we can unreg if needed */
     int redirect_state;
 
     bool http_access_done;
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 
-    bool icap_acl_check_done;
+    bool adaptation_acl_check_done;
 #endif
 
     bool redirect_done;
@@ -47,400 +47,31 @@
 
 ICAPConfig TheICAPConfig;
 
-ICAPServiceRep::Pointer
-ICAPConfig::findService(const String& key)
+ICAPConfig::ICAPConfig(): preview_enable(0), preview_size(0),
+    connect_timeout_raw(0), io_timeout_raw(0), reuse_connections(0),
+    client_username_header(NULL), client_username_encode(0)
 {
-    Vector<ICAPServiceRep::Pointer>::iterator iter = services.begin();
-
-    while (iter != services.end()) {
-        if ((*iter)->key == key)
-            return *iter;
-
-        ++iter;
-    }
-
-    return NULL;
-}
-
-ICAPClass *
-ICAPConfig::findClass(const String& key)
-{
-    if (!key.size())
-        return NULL;
-
-    Vector<ICAPClass*>::iterator iter = classes.begin();
-
-    while (iter != classes.end()) {
-        if ((*iter)->key == key)
-            return *iter;
-
-        ++iter;
-    }
-
-    return NULL;
-}
-
-int
-ICAPClass::prepare()
-{
-    int found = 0;
-    wordlist *service_names = NULL;
-    wordlist *iter;
-
-    ConfigParser::ParseString(&key);
-    ConfigParser::ParseWordList(&service_names);
-
-    if (service_names && service_names->next) {
-        debugs(3,0, "WARNING: Multiple ICAP services per icap_class are " <<
-            "not yet supported. See Squid bug #2087.");
-    }
-
-    for (iter = service_names; iter; iter = iter->next) {
-        ICAPServiceRep::Pointer match = TheICAPConfig.findService(iter->key);
-
-        if (match != NULL) {
-            found = 1;
-            services += match;
-        }
-    }
-
-    return found;
-};
-
-// ================================================================================ //
-
-CBDATA_CLASS_INIT(ICAPAccessCheck);
-
-ICAPAccessCheck::ICAPAccessCheck(ICAP::Method aMethod,
-                                 ICAP::VectPoint aPoint,
-                                 HttpRequest *aReq,
-                                 HttpReply *aRep,
-                                 ICAPAccessCheckCallback *aCallback,
-                                 void *aCallbackData): AsyncJob("ICAPAccessCheck"), done(FALSE)
-{
-    method = aMethod;
-    point = aPoint;
-
-    req = HTTPMSGLOCK(aReq);
-    rep = aRep ? HTTPMSGLOCK(aRep) : NULL;
-
-    callback = aCallback;
-
-    callback_data = cbdataReference(aCallbackData);
-
-    candidateClasses.clean();
-
-    matchedClass.clean();
-
-    acl_checklist = NULL;
-
-    debugs(93, 5, "ICAPAccessCheck constructed for " << ICAP::methodStr(method) << " " << ICAP::vectPointStr(point));
 }
 
-ICAPAccessCheck::~ICAPAccessCheck()
-{
-    HTTPMSGUNLOCK(req);
-    HTTPMSGUNLOCK(rep);
-}
-
-/*
- * Walk the ICAPAccess list and find all classes that have at least
- * one service with matching method and vectoring point.
- */
-void
-ICAPAccessCheck::check()
-{
-    debugs(93, 3, "ICAPAccessCheck::check");
-    Vector<ICAPClass*>::iterator ci;
-
-    for (ci = TheICAPConfig.classes.begin(); ci != TheICAPConfig.classes.end(); ++ci) {
-
-        /*
-         * We only find the first matching service because we only need
-         * one matching service to justify ACL-checking a class.  We might
-         * use other services belonging to the class if the first service
-         * turns out to be unusable for some reason.
-         */
-        ICAPClass *c = *ci;
-        ICAPServiceRep::Pointer service = findBestService(c, false);
-        if (service != NULL) {
-            debugs(93, 3, "ICAPAccessCheck::check: class '" << c->key.buf() << "' has candidate service '" << service->key.buf() << "'");
-            candidateClasses += c->key;
-        }
-    }
-
-    checkCandidates();
-}
-
-void
-ICAPAccessCheck::checkCandidates()
-{
-    while (!candidateClasses.empty()) {
-        // It didn't really match yet, but we use the name anyway.
-        matchedClass = candidateClasses.shift();
-        ICAPClass *theClass = TheICAPConfig.findClass(matchedClass);
-
-        if (theClass == NULL)
-            // class apparently went away (reconfigure)
-            continue;
-
-        // XXX we don't have access to conn->rfc931 here.
-        acl_checklist = aclChecklistCreate(theClass->accessList, req, dash_str);
-
-        acl_checklist->nonBlockingCheck(ICAPAccessCheckCallbackWrapper, this);
-
-        return;
-    }
-
-    /*
-     * when there are no canidates, set matchedClass to NULL string
-     * and call the wrapper with answer = 1
-     */
-    debugs(93, 3, "ICAPAccessCheck::check: NO candidates or matches found");
-
-    matchedClass.clean();
-
-    ICAPAccessCheckCallbackWrapper(1, this);
-
-    return;
-}
-
-void
-ICAPAccessCheck::ICAPAccessCheckCallbackWrapper(int answer, void *data)
+ICAPConfig::~ICAPConfig()
 {
-    debugs(93, 5, "ICAPAccessCheckCallbackWrapper: answer=" << answer);
-    ICAPAccessCheck *ac = (ICAPAccessCheck*)data;
-
-    if (ac->matchedClass.size()) {
-        debugs(93, 5, "ICAPAccessCheckCallbackWrapper matchedClass = " << ac->matchedClass.buf());
-    }
-
-    if (!answer) {
-        ac->checkCandidates();
-        return;
-    }
-
-    /*
-     * We use an event here to break deep function call sequences
-     */
-    CallJobHere(93, 5, ac, ICAPAccessCheck::do_callback);
+    // TODO: delete client_username_header?
 }
 
-#if 0
-void
-ICAPAccessCheck::ICAPAccessCheckCallbackEvent(void *data)
+Adaptation::ServicePointer
+ICAPConfig::createService(const Adaptation::ServiceConfig &cfg)
 {
-    debugs(93, 5, "ICAPAccessCheckCallbackEvent");
-    ICAPAccessCheck *ac = (ICAPAccessCheck*)data;
-    ac->do_callback();
-    delete ac;
+    ICAPServiceRep::Pointer s = new ICAPServiceRep(cfg);
+    s->setSelf(s);
+    return s.getRaw();
 }
-#endif
-
-void
-ICAPAccessCheck::do_callback()
-{
-    debugs(93, 3, "ICAPAccessCheck::do_callback");
-
-    if (matchedClass.size()) {
-        debugs(93, 3, "ICAPAccessCheck::do_callback matchedClass = " << matchedClass.buf());
-    }
-
-    void *validated_cbdata;
-    if (!cbdataReferenceValidDone(callback_data, &validated_cbdata)) {
-        debugs(93,3,HERE << "do_callback: callback_data became invalid, skipping");
-        return;
-    }
-
-    ICAPServiceRep::Pointer service = NULL;
-    if (ICAPClass *c = TheICAPConfig.findClass(matchedClass)) {
-        service = findBestService(c, true);
-        if (service != NULL)
-            debugs(93,3,HERE << "do_callback: with service " << service->uri);
-        else
-            debugs(93,3,HERE << "do_callback: no " << matchedClass << " service");
-    } else {
-        debugs(93,3,HERE << "do_callback: no " << matchedClass << " class");
-    }
-
-    callback(service, validated_cbdata);
-    done = TRUE;
-}
-
-ICAPServiceRep::Pointer
-ICAPAccessCheck::findBestService(ICAPClass *c, bool preferUp) {
-
-    const char *what = preferUp ? "up " : "";
-    debugs(93,7,HERE << "looking for the first matching " << 
-        what << "service in class " << c->key);
-
-    ICAPServiceRep::Pointer secondBest;
-
-    Vector<ICAPServiceRep::Pointer>::iterator si;
-    for (si = c->services.begin(); si != c->services.end(); ++si) {
-        ICAPServiceRep::Pointer service = *si;
-
-        if (method != service->method)
-            continue;
-
-        if (point != service->point)
-            continue;
-
-        // sending a message to a broken service is likely to cause errors
-        if (service->bypass && service->broken())
-            continue;
-
-        if (service->up()) {
-            // sending a message to a service that does not want it is useless
-            // note that we cannot check wantsUrl for service that is not "up"
-            // note that even essential services are skipped on unwanted URLs!
-            if (!service->wantsUrl(req->urlpath))
-                continue;
-        } else {
-            if (!secondBest)
-                secondBest = service;
-            if (preferUp) {
-                // the caller asked for an "up" service and we can bypass this one
-                if (service->bypass)
-                    continue;
-                debugs(93,5,HERE << "cannot skip an essential down service");
-                what = "down-but-essential ";
-            }
-        }
-
-        debugs(93,5,HERE << "found first matching " <<
-            what << "service in class " << c->key <<
-            ": " << service->key);
-
-        return service;
-    }
-
-    if (secondBest != NULL) {
-        what = "down ";
-        debugs(93,5,HERE << "found first matching " <<
-            what << "service in class " << c->key <<
-            ": " << secondBest->key);
-        return secondBest;
-    }
-
-    debugs(93,5,HERE << "found no matching " << 
-        what << "services in class " << c->key);
-    return ICAPServiceRep::Pointer();
-}
-
-// ================================================================================ //
-
-void
-ICAPConfig::parseICAPService()
-{
-    ICAPServiceRep::Pointer S = new ICAPServiceRep();
-
-    if (S->configure(S))
-        services += S;
-    else
-        S->invalidate();
-};
-
-void
-ICAPConfig::freeICAPService()
-{
-    services.clean();
-};
-
-void
-ICAPConfig::dumpICAPService(StoreEntry *entry, const char *name) const
-{
-    typedef Vector<ICAPServiceRep::Pointer>::const_iterator VI;
-
-    for (VI i = services.begin(); i != services.end(); ++i) {
-        const ICAPServiceRep::Pointer &r = *i;
-        storeAppendPrintf(entry, "%s %s_%s %s %d %s\n", name, r->key.buf(),
-                          r->methodStr(), r->vectPointStr(), r->bypass, r->uri.buf());
-    }
-};
-
-void
-ICAPConfig::parseICAPClass()
-{
-    ICAPClass *C = new ICAPClass();
-
-    if (C->prepare()) {
-        classes.push_back(C);
-    } else {
-        delete C;
-    }
-};
-
-void
-ICAPConfig::freeICAPClass()
-{
-    classes.clean();
-};
-
-void
-ICAPConfig::dumpICAPClass(StoreEntry *entry, const char *name) const
-{
-    Vector<ICAPClass*>::const_iterator i = classes.begin();
-
-    while (i != classes.end()) {
-        storeAppendPrintf(entry, "%s %s\n", name, (*i)->key.buf());
-        ++i;
-    }
-};
-
-void
-ICAPConfig::parseICAPAccess(ConfigParser &parser)
-{
-    String aKey;
-    ConfigParser::ParseString(&aKey);
-    ICAPClass *theClass = TheICAPConfig.findClass(aKey);
-
-    if (theClass == NULL)
-        fatalf("Did not find ICAP class '%s' referenced on line %d\n",
-               aKey.buf(), config_lineno);
-
-    aclParseAccessLine(parser, &theClass->accessList);
-};
-
-void
-ICAPConfig::freeICAPAccess()
-{
-    (void) 0;
-};
-
-void
-ICAPConfig::dumpICAPAccess(StoreEntry *entry, const char *name) const
-{
-    LOCAL_ARRAY(char, nom, 64);
-
-    Vector<ICAPClass*>::const_iterator i = classes.begin();
-
-    while (i != classes.end()) {
-        snprintf(nom, 64, "%s %s", name, (*i)->key.buf());
-        dump_acl_access(entry, nom, (*i)->accessList);
-        ++i;
-    }
-};
-
-ICAPConfig::~ICAPConfig()
-{
-
-    // invalidate each service so that it can be deleted when refcount=0
-    Vector<ICAPServiceRep::Pointer>::iterator si;
-
-    for (si = services.begin(); si != services.end(); ++si)
-        (*si)->invalidate();
-
-    classes.clean();
-
-};
 
 time_t ICAPConfig::connect_timeout(bool bypassable) const
 {
     if (connect_timeout_raw > 0)
         return connect_timeout_raw; // explicitly configured
 
-    return bypassable ? Config.Timeout.peer_connect : Config.Timeout.connect;
+    return bypassable ? ::Config.Timeout.peer_connect : ::Config.Timeout.connect;
 }
 
 time_t ICAPConfig::io_timeout(bool) const
@@ -449,16 +80,5 @@ time_t ICAPConfig::io_timeout(bool) const
         return io_timeout_raw; // explicitly configured
     // TODO: provide a different default for an ICAP transaction that 
     // can still be bypassed
-    return Config.Timeout.read; 
-}
-
-ICAPConfig::ICAPConfig(const ICAPConfig &)
-{
-    assert(false); // unsupported
-}
-
-ICAPConfig &ICAPConfig::operator =(const ICAPConfig &)
-{
-    assert(false); // unsupported
-    return *this;
+    return ::Config.Timeout.read; 
 }
@@ -38,108 +38,37 @@
 
 #include "event.h"
 #include "AsyncCall.h"
+#include "adaptation/Config.h"
 #include "ICAPServiceRep.h"
 
 class acl_access;
 
 class ConfigParser;
 
-class ICAPClass
+class ICAPConfig: public Adaptation::Config
 {
 
 public:
-    String key;
-    acl_access *accessList;
-
-    Vector<ICAPServiceRep::Pointer> services;
-
-    ICAPClass() : key(NULL), accessList(NULL) {};
-
-    int prepare();
-};
-
-class ICAPAccessCheck: public virtual AsyncJob
-{
-
-public:
-    typedef void ICAPAccessCheckCallback(ICAPServiceRep::Pointer match, void *data);
-    ICAPAccessCheck(ICAP::Method, ICAP::VectPoint, HttpRequest *, HttpReply *, ICAPAccessCheckCallback *, void *);
-    ~ICAPAccessCheck();
-
-private:
-    ICAP::Method method;
-    ICAP::VectPoint point;
-    HttpRequest *req;
-    HttpReply *rep;
-    ICAPAccessCheckCallback *callback;
-    void *callback_data;
-    ACLChecklist *acl_checklist;
-    Vector<String> candidateClasses;
-    String matchedClass;
-    void do_callback();
-    ICAPServiceRep::Pointer findBestService(ICAPClass *c, bool preferUp);
-    bool done;
-
-public:
-    void check();
-    void checkCandidates();
-    static void ICAPAccessCheckCallbackWrapper(int, void*);
-#if 0
-    static EVH ICAPAccessCheckCallbackEvent;
-#endif
-//AsyncJob virtual methods
-    virtual bool doneAll() const { return AsyncJob::doneAll() && done;}
-
-private:
-    CBDATA_CLASS2(ICAPAccessCheck);
-};
-
-class ICAPConfig
-{
-
-public:
-
-    int onoff;
+    int default_options_ttl;
     int preview_enable;
     int preview_size;
     time_t connect_timeout_raw;
     time_t io_timeout_raw;
-    int default_options_ttl;
-    int send_client_ip;
-    int send_client_username;
     int reuse_connections;
-    int service_failure_limit;
-    int service_revival_delay;
     char* client_username_header;
     int client_username_encode;
 
-    Vector<ICAPServiceRep::Pointer> services;
-    Vector<ICAPClass*> classes;
-
-    ICAPConfig() {};
-
+    ICAPConfig();
     ~ICAPConfig();
 
     time_t connect_timeout(bool bypassable) const;
     time_t io_timeout(bool bypassable) const;
 
-    void parseICAPService(void);
-    void freeICAPService(void);
-    void dumpICAPService(StoreEntry *, const char *) const;
-    ICAPServiceRep::Pointer findService(const String&);
-    ICAPClass * findClass(const String& key);
-
-    void parseICAPClass(void);
-    void freeICAPClass(void);
-    void dumpICAPClass(StoreEntry *, const char *) const;
-
-    void parseICAPAccess(ConfigParser &parser);
-    void freeICAPAccess(void);
-    void dumpICAPAccess(StoreEntry *, const char *) const;
-
 private:
-    ICAPConfig(const ICAPConfig &); // unsupported
-    ICAPConfig &operator =(const ICAPConfig &); // unsupported
+    ICAPConfig(const ICAPConfig &); // not implemented
+    ICAPConfig &operator =(const ICAPConfig &); // not implemented
+
+    virtual Adaptation::ServicePointer createService(const Adaptation::ServiceConfig &cfg);
 };
 
 extern ICAPConfig TheICAPConfig;
@@ -1,52 +1,4 @@
 #include "squid.h"
 #include "ICAPElements.h"
 
-const char *ICAP::crlf = "\r\n";
-
-
-const char *
-ICAP::methodStr(ICAP::Method method)
-{
-    switch(method) {
-
-    case ICAP::methodReqmod:
-        return "REQMOD";
-        break;
-
-    case ICAP::methodRespmod:
-        return "RESPMOD";
-        break;
-
-    case ICAP::methodOptions:
-        return "OPTIONS";
-        break;
-
-    default:
-        break;
-    }
-
-    return "NONE";
-}
-
-
-const char *
-ICAP::vectPointStr(ICAP::VectPoint point)
-{
-    switch(point) {
-
-    case ICAP::pointPreCache:
-        return "PRECACHE";
-        break;
-
-    case ICAP::pointPostCache:
-        return "POSTCACHE";
-        break;
-
-    default:
-        break;
-    }
-
-    return "NONE";
-}
-
-
+// TODO: remove this file?
@@ -34,19 +34,25 @@
 #ifndef SQUID_ICAPELEMENTS_H
 #define SQUID_ICAPELEMENTS_H
 
-// ICAP-related things shared by many ICAP classes
+#include "adaptation/Elements.h"
 
-// A "fake" class to encapsulate ICAP-related declarations without
-// adding namespaces to Squid. Eventually, namespaces should be added.
+// ICAP-related things shared by many ICAP classes
 
-struct ICAP
+namespace ICAP
 {
-    typedef enum { methodNone, methodReqmod, methodRespmod, methodOptions } Method;
-    typedef enum { pointNone, pointPreCache, pointPostCache } VectPoint;
+    using Adaptation::Method;
+    using Adaptation::methodNone;
+    using Adaptation::methodRespmod;
+    using Adaptation::methodReqmod;
+
+    using Adaptation::VectPoint;
+    using Adaptation::pointNone;
+    using Adaptation::pointPreCache;
+    using Adaptation::pointPostCache;
 
-    static const char *crlf;
-    static const char *methodStr(ICAP::Method);
-    static const char *vectPointStr(ICAP::VectPoint);
-};
+    using Adaptation::crlf;
+    using Adaptation::methodStr;
+    using Adaptation::vectPointStr;
+}
 
 #endif /* SQUID_ICAPCLIENT_H */
@@ -1,122 +0,0 @@
-/*
- * DEBUG: section 93  ICAP (RFC 3507) Client
- */
-
-#include "squid.h"
-#include "HttpMsg.h"
-#include "ICAPInitiator.h"
-#include "ICAPInitiate.h"
-
-// ICAPInitiator::noteIcapAnswer Dialer locks/unlocks the message in transit
-// TODO: replace HTTPMSGLOCK with general RefCounting and delete this class
-class IcapAnswerDialer: public UnaryMemFunT<ICAPInitiator, HttpMsg*>
-{
-public:
-    typedef UnaryMemFunT<ICAPInitiator, HttpMsg*> Parent;
-
-    IcapAnswerDialer(ICAPInitiator *obj, Parent::Method meth, HttpMsg *msg):
-        Parent(obj, meth, msg) { HTTPMSGLOCK(arg1); }
-    IcapAnswerDialer(const IcapAnswerDialer &d):
-        Parent(d) { HTTPMSGLOCK(arg1); }
-    virtual ~IcapAnswerDialer() { HTTPMSGUNLOCK(arg1); }
-};
-
-
-/* ICAPInitiate */
-
-ICAPInitiate::ICAPInitiate(const char *aTypeName,
-    ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService):
-    AsyncJob(aTypeName), theInitiator(anInitiator), theService(aService)
-{
-    assert(theService != NULL);
-    assert(theInitiator);
-}
-
-ICAPInitiate::~ICAPInitiate()
-{
-    assert(!theInitiator);
-}
-
-// internal cleanup
-void ICAPInitiate::swanSong()
-{
-    debugs(93, 5, HERE << "swan sings" << status());
-
-    if (theInitiator) {
-        debugs(93, 3, HERE << "fatal failure; sending abort notification");
-        tellQueryAborted(true); // final by default
-    }
-
-    debugs(93, 5, HERE << "swan sang" << status());
-}
-
-void ICAPInitiate::clearInitiator()
-{
-    if (theInitiator)
-        theInitiator.clear();
-}
-
-void ICAPInitiate::sendAnswer(HttpMsg *msg)
-{
-    assert(msg);
-    CallJob(93, 5, __FILE__, __LINE__, "ICAPInitiator::noteIcapAnswer",
-        IcapAnswerDialer(theInitiator.ptr, &ICAPInitiator::noteIcapAnswer, msg));
-    clearInitiator();
-}
-
-
-void ICAPInitiate::tellQueryAborted(bool final)
-{
-    CallJobHere1(93, 5, theInitiator.ptr, ICAPInitiator::noteIcapQueryAbort, final);
-    clearInitiator();
-}
-
-ICAPServiceRep &ICAPInitiate::service()
-{
-    assert(theService != NULL);
-    return *theService;
-}
-
-const char *ICAPInitiate::status() const {
-    return ""; // for now
-}
-
-
-/* ICAPInitiatorHolder */
-
-ICAPInitiatorHolder::ICAPInitiatorHolder(ICAPInitiator *anInitiator):
-    ptr(0), cbdata(0)
-{
-    if (anInitiator) {
-        cbdata = cbdataReference(anInitiator->toCbdata());
-        ptr = anInitiator;
-    }
-}
-
-ICAPInitiatorHolder::ICAPInitiatorHolder(const ICAPInitiatorHolder &anInitiator):
-    ptr(0), cbdata(0)
-{
-    if (anInitiator != NULL && cbdataReferenceValid(anInitiator.cbdata)) {
-        cbdata = cbdataReference(anInitiator.cbdata);
-        ptr = anInitiator.ptr;
-    }
-}
-
-ICAPInitiatorHolder::~ICAPInitiatorHolder()
-{
-    clear();
-}
-
-void ICAPInitiatorHolder::clear() {
-    if (ptr) {
-        ptr = NULL;
-        cbdataReferenceDone(cbdata);
-    }
-}
-
-// should not be used
-ICAPInitiatorHolder &ICAPInitiatorHolder::operator =(const ICAPInitiatorHolder &anInitiator)
-{
-    assert(false);
-    return *this;
-}
@@ -1,106 +0,0 @@
-
-/*
- * $Id: ICAPInitiate.h,v 1.2 2008/02/12 23:12:45 rousskov Exp $
- *
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#ifndef SQUID_ICAPINITIATE_H
-#define SQUID_ICAPINITIATE_H
-
-#include "comm.h"
-#include "MemBuf.h"
-#include "ICAPServiceRep.h"
-#include "AsyncCall.h"
-
-class HttpMsg;
-class ICAPInitiator;
-
-/* Initiator holder associtates an initiator with its cbdata. It is used as
- * a temporary hack to make cbdata work with multiple inheritance */
-// TODO: since ICAPInitiator is now an AsyncJob, we do not need this class.
-class ICAPInitiatorHolder {
-public:
-    ICAPInitiatorHolder(ICAPInitiator *anInitiator);
-    ICAPInitiatorHolder(const ICAPInitiatorHolder &anInitiator);
-    ~ICAPInitiatorHolder();
-
-
-    void clear();
-
-    // to make comparison with NULL possible
-    operator void*() { return ptr; }
-    bool operator == (void *) const { return ptr == NULL; }
-    bool operator != (void *) const { return ptr != NULL; }
-    bool operator !() const { return !ptr; }
-
-    ICAPInitiator *ptr;
-    void *cbdata;
-
-private:
-    ICAPInitiatorHolder &operator =(const ICAPInitiatorHolder &anInitiator);
-};
-
-/*
- * The ICAP Initiate is a common base for ICAP queries or transactions
- * initiated by an ICAPInitiator. This interface exists to allow an ICAP
- * initiator to signal its "initiatees" that it is aborting and no longer
- * expecting an answer. The class is also handy for implementing common
- * initiate actions such as maintaining and notifying the initiator.
- *
- * ICAPInitiate implementations must cbdata-protect themselves.
- *
- * This class could have been named ICAPInitiatee.
- */
-class ICAPInitiate: virtual public AsyncJob
-{
-
-public:
-    ICAPInitiate(const char *aTypeName, ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService);
-    virtual ~ICAPInitiate();
-
-    // communication with the initiator
-    virtual void noteInitiatorAborted() = 0;
-
-protected:
-    ICAPServiceRep &service();
-
-    void sendAnswer(HttpMsg *msg); // send to the initiator
-    void tellQueryAborted(bool final); // tell initiator
-    void clearInitiator(); // used by noteInitiatorAborted; TODO: make private
-
-    virtual void swanSong(); // internal cleanup
-
-    virtual const char *status() const; // for debugging
-
-    ICAPInitiatorHolder theInitiator;
-    ICAPServiceRep::Pointer theService;
-};
-
-#endif /* SQUID_ICAPINITIATE_H */
@@ -1,26 +0,0 @@
-/*
- * DEBUG: section 93  ICAP (RFC 3507) Client
- */
-
-#include "squid.h"
-#include "ICAPXaction.h"
-#include "ICAPInitiator.h"
-
-ICAPInitiate *ICAPInitiator::initiateIcap(ICAPInitiate *x) {
-    if ((x = dynamic_cast<ICAPInitiate*>(ICAPInitiate::AsyncStart(x))))
-        x = cbdataReference(x);
-    return x;    
-}
-
-void ICAPInitiator::clearIcap(ICAPInitiate *&x) {
-    assert(x);
-    cbdataReferenceDone(x);
-}
-
-void ICAPInitiator::announceInitiatorAbort(ICAPInitiate *&x)
-{
-    if (x) {
-	CallJobHere(93, 5, x, ICAPInitiate::noteInitiatorAborted);
-        clearIcap(x);
-    }
-}
@@ -1,74 +0,0 @@
-
-/*
- * $Id: ICAPInitiator.h,v 1.3 2008/02/12 23:12:45 rousskov Exp $
- *
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *  
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *  
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#ifndef SQUID_ICAPINITIATOR_H
-#define SQUID_ICAPINITIATOR_H
-
-/*
- * The ICAP Initiator is an ICAP vectoring point that initates ICAP
- * transactions. This interface exists to allow ICAP transactions to
- * signal their initiators that they have the answer from the ICAP server
- * or that the ICAP query has aborted and there will be no answer. It
- * is also handy for implementing common initiator actions such as starting
- * or aborting an ICAP transaction.
- */
-
-#include "AsyncJob.h"
-
-class HttpMsg;
-class ICAPInitiate;
-
-class ICAPInitiator: virtual public AsyncJob
-{
-public:
-    ICAPInitiator():AsyncJob("ICAPInitiator"){}
-    virtual ~ICAPInitiator() {}
-
-    // called when ICAP response headers are successfully interpreted
-    virtual void noteIcapAnswer(HttpMsg *message) = 0;
-
-    // called when valid ICAP response headers are no longer expected
-    // the final parameter is set to disable bypass or retries
-    virtual void noteIcapQueryAbort(bool final) = 0;
-
-protected:
-    ICAPInitiate *initiateIcap(ICAPInitiate *x); // locks and returns x
-
-    // done with x (and not calling announceInitiatorAbort)
-    void clearIcap(ICAPInitiate *&x); // unlocks x
-
-    // inform the transaction about abnormal termination and clear it
-    void announceInitiatorAbort(ICAPInitiate *&x); // unlocks x
-};
-
-#endif /* SQUID_ICAPINITIATOR_H */
@@ -7,10 +7,13 @@
 #include "HttpMsg.h"
 #include "ICAPLauncher.h"
 #include "ICAPXaction.h"
+#include "ICAPServiceRep.h"
 
 
-ICAPLauncher::ICAPLauncher(const char *aTypeName, ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService):AsyncJob(aTypeName),
-    ICAPInitiate(aTypeName, anInitiator, aService),
+ICAPLauncher::ICAPLauncher(const char *aTypeName,
+    Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService):
+    AsyncJob(aTypeName),
+    Adaptation::Initiate(aTypeName, anInitiator, aService),
     theXaction(0), theLaunches(0)
 {
 }
@@ -22,7 +25,7 @@ ICAPLauncher::~ICAPLauncher()
 
 void ICAPLauncher::start()
 {
-    ICAPInitiate::start();
+    Adaptation::Initiate::start();
 
     Must(theInitiator);
     launchXaction(false);
@@ -36,16 +39,16 @@ void ICAPLauncher::launchXaction(bool final)
     ICAPXaction *x = createXaction();
     if (final)
         x->disableRetries();
-    theXaction = initiateIcap(x);
+    theXaction = initiateAdaptation(x);
     Must(theXaction);
 }
 
-void ICAPLauncher::noteIcapAnswer(HttpMsg *message)
+void ICAPLauncher::noteAdaptationAnswer(HttpMsg *message)
 {
     sendAnswer(message);
-    clearIcap(theXaction);
+    clearAdaptation(theXaction);
     Must(done());
-    debugs(93,3, HERE << "ICAPLauncher::noteIcapAnswer exiting "); 
+    debugs(93,3, HERE << "ICAPLauncher::noteAdaptationAnswer exiting "); 
 }
 
 void ICAPLauncher::noteInitiatorAborted()
@@ -57,9 +60,9 @@ void ICAPLauncher::noteInitiatorAborted()
 
 }
 
-void ICAPLauncher::noteIcapQueryAbort(bool final)
+void ICAPLauncher::noteAdaptationQueryAbort(bool final)
 {
-    clearIcap(theXaction);
+    clearAdaptation(theXaction);
 
     // TODO: add more checks from FwdState::checkRetry()?
     if (!final && theLaunches < 2 && !shutting_down) {
@@ -73,16 +76,16 @@ void ICAPLauncher::noteIcapQueryAbort(bool final)
 }
 
 bool ICAPLauncher::doneAll() const {
-    return (!theInitiator || !theXaction) && ICAPInitiate::doneAll();
+    return (!theInitiator || !theXaction) && Adaptation::Initiate::doneAll();
 }
 
 void ICAPLauncher::swanSong()
 {
     if (theInitiator)
-        tellQueryAborted(!service().bypass);
+        tellQueryAborted(!service().cfg().bypass);
 
     if (theXaction)
-        clearIcap(theXaction);
+        clearAdaptation(theXaction);
 
-    ICAPInitiate::swanSong();
+    Adaptation::Initiate::swanSong();
 }
@@ -34,8 +34,9 @@
 #ifndef SQUID_ICAPLAUNCHER_H
 #define SQUID_ICAPLAUNCHER_H
 
-#include "ICAP/ICAPInitiator.h"
-#include "ICAP/ICAPInitiate.h"
+#include "adaptation/Initiator.h"
+#include "adaptation/Initiate.h"
+#include "ICAP/ICAPServiceRep.h"
 
 /*
  * The ICAP Launcher starts an ICAP transaction. If the transaction fails
@@ -62,21 +63,21 @@ class ICAPXaction;
 // Note: ICAPInitiate must be the first parent for cbdata to work. We use
 // a temporary ICAPInitaitorHolder/toCbdata hacks and do not call cbdata
 // operations on the initiator directly.
-class ICAPLauncher: public ICAPInitiate, public ICAPInitiator
+class ICAPLauncher: public Adaptation::Initiate, public Adaptation::Initiator
 {
 public:
-    ICAPLauncher(const char *aTypeName, ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService);
+    ICAPLauncher(const char *aTypeName, Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService);
     virtual ~ICAPLauncher();
 
-    // ICAPInitiate: asynchronous communication with the initiator
+    // Adaptation::Initiate: asynchronous communication with the initiator
     void noteInitiatorAborted();
 
-    // ICAPInitiator: asynchronous communication with the current transaction
-    virtual void noteIcapAnswer(HttpMsg *message);
-    virtual void noteIcapQueryAbort(bool final);
+    // Adaptation::Initiator: asynchronous communication with the current transaction
+    virtual void noteAdaptationAnswer(HttpMsg *message);
+    virtual void noteAdaptationQueryAbort(bool final);
 
 protected:
-    // ICAPInitiate API implementation
+    // Adaptation::Initiate API implementation
     virtual void start();
     virtual bool doneAll() const;
     virtual void swanSong();
@@ -86,7 +87,7 @@ class ICAPLauncher: public ICAPInitiate, public ICAPInitiator
 
     void launchXaction(bool final);
 
-    ICAPInitiate *theXaction; // current ICAP transaction
+    Adaptation::Initiate *theXaction; // current ICAP transaction
     int theLaunches; // the number of transaction launches
 };
 
@@ -7,8 +7,8 @@
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
+#include "adaptation/Initiator.h"
 #include "ICAPServiceRep.h"
-#include "ICAPInitiator.h"
 #include "ICAPLauncher.h"
 #include "ICAPModXact.h"
 #include "ICAPClient.h"
@@ -37,7 +37,7 @@ ICAPModXact::State::State()
     memset(this, 0, sizeof(*this));
 }
 
-ICAPModXact::ICAPModXact(ICAPInitiator *anInitiator, HttpMsg *virginHeader,
+ICAPModXact::ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader,
     HttpRequest *virginCause, ICAPServiceRep::Pointer &aService):
     AsyncJob("ICAPModXact"),
     ICAPXaction("ICAPModXact", anInitiator, aService),
@@ -72,7 +72,7 @@ void ICAPModXact::start()
 
     estimateVirginBody(); // before virgin disappears!
 
-    canStartBypass = service().bypass;
+    canStartBypass = service().cfg().bypass;
 
     // it is an ICAP violation to send request to a service w/o known OPTIONS
 
@@ -716,14 +716,14 @@ void ICAPModXact::parseIcapHead()
 
 bool ICAPModXact::validate200Ok()
 {
-    if (ICAP::methodRespmod == service().method) {
+    if (ICAP::methodRespmod == service().cfg().method) {
         if (!gotEncapsulated("res-hdr"))
             return false;
 
         return true;
     }
 
-    if (ICAP::methodReqmod == service().method) {
+    if (ICAP::methodReqmod == service().cfg().method) {
         if (!gotEncapsulated("res-hdr") && !gotEncapsulated("req-hdr"))
             return false;
 
@@ -1047,7 +1047,7 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     /*
      * XXX These should use HttpHdr interfaces instead of Printfs
      */
-    const ICAPServiceRep &s = service();
+    const Adaptation::ServiceConfig &s = service().cfg();
     buf.Printf("%s %s ICAP/1.0\r\n", s.methodStr(), s.uri.buf());
     buf.Printf("Host: %s:%d\r\n", s.host.buf(), s.port);
     buf.Printf("Date: %s\r\n", mkrfc1123(squid_curtime));
@@ -1540,7 +1540,7 @@ bool ICAPModXact::fillVirginHttpHeader(MemBuf &mb) const
 
 /* ICAPModXactLauncher */
 
-ICAPModXactLauncher::ICAPModXactLauncher(ICAPInitiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, ICAPServiceRep::Pointer &aService):
+ICAPModXactLauncher::ICAPModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer aService):
     AsyncJob("ICAPModXactLauncher"),
     ICAPLauncher("ICAPModXactLauncher", anInitiator, aService)
 {
@@ -1550,5 +1550,8 @@ ICAPModXactLauncher::ICAPModXactLauncher(ICAPInitiator *anInitiator, HttpMsg *vi
 
 ICAPXaction *ICAPModXactLauncher::createXaction()
 {
-    return new ICAPModXact(this, virgin.header, virgin.cause, theService);
+    ICAPServiceRep::Pointer s =
+        dynamic_cast<ICAPServiceRep*>(theService.getRaw());
+    Must(s != NULL);
+    return new ICAPModXact(this, virgin.header, virgin.cause, s);
 }
@@ -127,13 +127,11 @@ class ICAPPreview
     enum State { stDisabled, stWriting, stIeof, stDone } theState;
 };
 
-class ICAPInitiator;
-
 class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
 {
 
 public:
-    ICAPModXact(ICAPInitiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, ICAPServiceRep::Pointer &s);
+    ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, ICAPServiceRep::Pointer &s);
 
     // BodyProducer methods
     virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
@@ -310,7 +308,7 @@ class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
 class ICAPModXactLauncher: public ICAPLauncher
 {
 public:
-    ICAPModXactLauncher(ICAPInitiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, ICAPServiceRep::Pointer &s);
+    ICAPModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer s);
 
 protected:
     virtual ICAPXaction *createXaction();
@@ -14,7 +14,7 @@ CBDATA_CLASS_INIT(ICAPOptXact);
 CBDATA_CLASS_INIT(ICAPOptXactLauncher);
 
 
-ICAPOptXact::ICAPOptXact(ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService):
+ICAPOptXact::ICAPOptXact(Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService):
     AsyncJob("ICAPOptXact"),
     ICAPXaction("ICAPOptXact", anInitiator, aService)
 {
@@ -42,9 +42,9 @@ void ICAPOptXact::handleCommConnected()
 
 void ICAPOptXact::makeRequest(MemBuf &buf)
 {
-    const ICAPServiceRep &s = service();
-    buf.Printf("OPTIONS %s ICAP/1.0\r\n", s.uri.buf());
-    buf.Printf("Host: %s:%d\r\n", s.host.buf(), s.port);
+    const Adaptation::Service &s = service();
+    buf.Printf("OPTIONS %s ICAP/1.0\r\n", s.cfg().uri.buf());
+    buf.Printf("Host: %s:%d\r\n", s.cfg().host.buf(), s.cfg().port);
     buf.append(ICAP::crlf, 2);
 }
 
@@ -88,13 +88,16 @@ HttpMsg *ICAPOptXact::parseResponse()
 
 /* ICAPOptXactLauncher */
 
-ICAPOptXactLauncher::ICAPOptXactLauncher(ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService):
+ICAPOptXactLauncher::ICAPOptXactLauncher(Adaptation::Initiator *anInitiator, Adaptation::ServicePointer aService):
     AsyncJob("ICAPOptXactLauncher"),
     ICAPLauncher("ICAPOptXactLauncher", anInitiator, aService)
 {
 }
 
 ICAPXaction *ICAPOptXactLauncher::createXaction()
 {
-    return new ICAPOptXact(this, theService);
+    ICAPServiceRep::Pointer s =
+        dynamic_cast<ICAPServiceRep*>(theService.getRaw());
+    Must(s != NULL);
+    return new ICAPOptXact(this, s);
 }
@@ -48,7 +48,7 @@ class ICAPOptXact: public ICAPXaction
 {
 
 public:
-    ICAPOptXact(ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService);
+    ICAPOptXact(Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService);
 
 protected:
     virtual void start();
@@ -70,7 +70,7 @@ class ICAPOptXact: public ICAPXaction
 class ICAPOptXactLauncher: public ICAPLauncher
 {
 public:
-    ICAPOptXactLauncher(ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService);
+    ICAPOptXactLauncher(Adaptation::Initiator *anInitiator, Adaptation::ServicePointer aService);
 
 protected:
     virtual ICAPXaction *createXaction();
@@ -10,12 +10,13 @@
 #include "ICAPOptXact.h"
 #include "ConfigParser.h"
 #include "ICAPConfig.h"
+#include "ICAPModXact.h"
 #include "SquidTime.h"
 
 CBDATA_CLASS_INIT(ICAPServiceRep);
 
-ICAPServiceRep::ICAPServiceRep(): AsyncJob("ICAPServiceRep"), method(ICAP::methodNone),
-        point(ICAP::pointNone), port(-1), bypass(false),
+ICAPServiceRep::ICAPServiceRep(const Adaptation::ServiceConfig &cfg):
+        AsyncJob("ICAPServiceRep"), Adaptation::Service(cfg),
         theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
         theSessionFailures(0), isSuspended(0), notifying(false),
         updateScheduled(false), self(NULL),
@@ -28,137 +29,31 @@ ICAPServiceRep::~ICAPServiceRep()
     changeOptions(0);
 }
 
-const char *
-ICAPServiceRep::methodStr() const
-{
-    return ICAP::methodStr(method);
-}
-
-ICAP::Method
-ICAPServiceRep::parseMethod(const char *str) const
-{
-    if (!strncasecmp(str, "REQMOD", 6))
-        return ICAP::methodReqmod;
-
-    if (!strncasecmp(str, "RESPMOD", 7))
-        return ICAP::methodRespmod;
-
-    return ICAP::methodNone;
-}
-
-
-const char *
-ICAPServiceRep::vectPointStr() const
-{
-    return ICAP::vectPointStr(point);
-}
-
-ICAP::VectPoint
-ICAPServiceRep::parseVectPoint(const char *service) const
-{
-    const char *t = service;
-    const char *q = strchr(t, '_');
-
-    if (q)
-        t = q + 1;
-
-    if (!strcasecmp(t, "precache"))
-        return ICAP::pointPreCache;
-
-    if (!strcasecmp(t, "postcache"))
-        return ICAP::pointPostCache;
-
-    return ICAP::pointNone;
-}
-
-bool
-ICAPServiceRep::configure(Pointer &aSelf)
+void
+ICAPServiceRep::setSelf(Pointer &aSelf)
 {
     assert(!self && aSelf != NULL);
     self = aSelf;
+}
 
-    char *service_type = NULL;
-
-    ConfigParser::ParseString(&key);
-    ConfigParser::ParseString(&service_type);
-    ConfigParser::ParseBool(&bypass);
-    ConfigParser::ParseString(&uri);
-
-    debugs(3, 5, "ICAPService::parseConfigLine (line " << config_lineno << "): " << key.buf() << " " << service_type << " " << bypass);
-
-    method = parseMethod(service_type);
-    point = parseVectPoint(service_type);
-
-    debugs(3, 5, "ICAPService::parseConfigLine (line " << config_lineno << "): service is " << methodStr() << "_" << vectPointStr());
-
-    if (uri.cmp("icap://", 7) != 0) {
-        debugs(3, 0, "ICAPService::parseConfigLine (line " << config_lineno << "): wrong uri: " << uri.buf());
-        return false;
-    }
-
-    const char *s = uri.buf() + 7;
-
-    const char *e;
-
-    bool have_port = false;
-
-    if ((e = strchr(s, ':')) != NULL) {
-        have_port = true;
-    } else if ((e = strchr(s, '/')) != NULL) {
-        have_port = false;
-    } else {
-        return false;
-    }
-
-    int len = e - s;
-    host.limitInit(s, len);
-    s = e;
-
-    if (have_port) {
-        s++;
-
-        if ((e = strchr(s, '/')) != NULL) {
-            char *t;
-            port = strtoul(s, &t, 0) % 65536;
-
-            if (t != e) {
-                return false;
-            }
-
-            s = e;
-
-            if (s[0] != '/') {
-                return false;
-            }
-        }
-    } else {
+void
+ICAPServiceRep::finalize()
+{
+	Adaptation::Service::finalize();
+    assert(self != NULL);
 
+    // use /etc/services or default port if needed
+	const bool have_port = cfg().port >= 0;
+    if (!have_port) {
         struct servent *serv = getservbyname("icap", "tcp");
 
         if (serv) {
-            port = htons(serv->s_port);
+            writeableCfg().port = htons(serv->s_port);
         } else {
-            port = 1344;
+            writeableCfg().port = 1344;
         }
     }
-
-    s++;
-    e = strchr(s, '\0');
-    len = e - s;
-
-    if (len > 1024) {
-        debugs(3, 0, "icap_service_process (line " << config_lineno << "): long resource name (>1024), probably wrong");
-    }
-
-    resource.limitInit(s, len + 1);
-
-    if ((bypass != 0) && (bypass != 1)) {
-        return false;
-    }
-
-    return true;
-
-};
+}
 
 void ICAPServiceRep::invalidate()
 {
@@ -357,7 +252,7 @@ void ICAPServiceRep::checkOptions()
 
     if (!theOptions->valid()) {
         debugs(93,1, "WARNING: Squid got an invalid ICAP OPTIONS response " <<
-            "from service " << uri << "; error: " << theOptions->error);
+            "from service " << cfg().uri << "; error: " << theOptions->error);
         return;
     }
 
@@ -373,7 +268,7 @@ void ICAPServiceRep::checkOptions()
 
         while (iter != theOptions->methods.end()) {
 
-            if (*iter == method) {
+            if (*iter == cfg().method) {
                 method_found = true;
                 break;
             }
@@ -385,8 +280,8 @@ void ICAPServiceRep::checkOptions()
 
         if (!method_found) {
             debugs(93,1, "WARNING: Squid is configured to use ICAP method " <<
-                   ICAP::methodStr(method) <<
-                   " for service " << uri.buf() <<
+                   cfg().methodStr() <<
+                   " for service " << cfg().uri.buf() <<
                    " but OPTIONS response declares the methods are " << method_list.buf());
         }
     }
@@ -400,7 +295,7 @@ void ICAPServiceRep::checkOptions()
         // TODO: If skew is negative, the option will be considered down
         // because of stale options. We should probably change this.
         debugs(93, 1, "ICAP service's clock is skewed by " << skew <<
-            " seconds: " << uri.buf());
+            " seconds: " << cfg().uri.buf());
     }
 }
 
@@ -409,20 +304,20 @@ void ICAPServiceRep::announceStatusChange(const char *downPhrase, bool important
     if (wasAnnouncedUp == up()) // no significant changes to announce
         return;
 
-    const char *what = bypass ? "optional" : "essential";
+    const char *what = cfg().bypass ? "optional" : "essential";
     const char *state = wasAnnouncedUp ? downPhrase : "up";
     const int level = important ? 1 : 2;
-    debugs(93,level, what << " ICAP service is " << state << ": " << uri <<
-        ' ' << status());
+    debugs(93,level, what << " ICAP service is " << state << ": " <<
+        cfg().uri << ' ' << status());
 
     wasAnnouncedUp = !wasAnnouncedUp;
 }
 
 // we are receiving ICAP OPTIONS response headers here or NULL on failures
-void ICAPServiceRep::noteIcapAnswer(HttpMsg *msg)
+void ICAPServiceRep::noteAdaptationAnswer(HttpMsg *msg)
 {
     Must(theOptionsFetcher);
-    clearIcap(theOptionsFetcher);
+    clearAdaptation(theOptionsFetcher);
 
     Must(msg);
 
@@ -439,9 +334,9 @@ void ICAPServiceRep::noteIcapAnswer(HttpMsg *msg)
     handleNewOptions(newOptions);
 }
 
-void ICAPServiceRep::noteIcapQueryAbort(bool) {
+void ICAPServiceRep::noteAdaptationQueryAbort(bool) {
     Must(theOptionsFetcher);
-    clearIcap(theOptionsFetcher);
+    clearAdaptation(theOptionsFetcher);
 
     debugs(93,3, "ICAPService failed to fetch options " << status());
     handleNewOptions(0);
@@ -463,7 +358,8 @@ void ICAPServiceRep::startGettingOptions()
     Must(!theOptionsFetcher);
     debugs(93,6, "ICAPService will get new options " << status());
 
-    theOptionsFetcher = initiateIcap(new ICAPOptXactLauncher(this, self));
+    // XXX: second "this" is "self"; this works but may stop if API changes
+    theOptionsFetcher = initiateAdaptation(new ICAPOptXactLauncher(this, this));
     Must(theOptionsFetcher);
     // TODO: timeout in case ICAPOptXact never calls us back?
     // Such a timeout should probably be a generic AsyncStart feature.
@@ -530,6 +426,13 @@ ICAPServiceRep::optionsFetchTime() const
     return squid_curtime + TheICAPConfig.service_revival_delay;
 }
 
+Adaptation::Initiate *
+ICAPServiceRep::makeXactLauncher(Adaptation::Initiator *initiator,
+    HttpMsg *virgin, HttpRequest *cause)
+{
+    return new ICAPModXactLauncher(initiator, virgin, cause, this);
+}
+
 // returns a temporary string depicting service status, for debugging
 const char *ICAPServiceRep::status() const
 {
@@ -35,7 +35,9 @@
 #define SQUID_ICAPSERVICEREP_H
 
 #include "cbdata.h"
-#include "ICAPInitiator.h"
+#include "adaptation/Service.h"
+#include "adaptation/forward.h"
+#include "adaptation/Initiator.h"
 #include "ICAPElements.h"
 
 class ICAPOptions;
@@ -70,26 +72,28 @@ class ICAPOptXact;
  */
 
 
-class ICAPServiceRep : public RefCountable, public ICAPInitiator
+class ICAPServiceRep : public RefCountable, public Adaptation::Service,
+    public Adaptation::Initiator
 {
 
 public:
     typedef RefCount<ICAPServiceRep> Pointer;
 
 public:
-    ICAPServiceRep();
+    ICAPServiceRep(const Adaptation::ServiceConfig &config);
     virtual ~ICAPServiceRep();
 
-    bool configure(Pointer &aSelf); // needs self pointer for ICAPOptXact
-    void invalidate(); // call when the service is no longer needed or valid
+    void setSelf(Pointer &aSelf); // needs self pointer for ICAPOptXact
+    virtual void finalize();
 
-    const char *methodStr() const;
-    const char *vectPointStr() const;
+    void invalidate(); // call when the service is no longer needed or valid
 
     bool probed() const; // see comments above
     bool broken() const; // see comments above
     bool up() const; // see comments above
 
+    virtual Adaptation::Initiate *makeXactLauncher(Adaptation::Initiator *, HttpMsg *virginHeader, HttpRequest *virginCause);
+
     void callWhenReady(AsyncCall::Pointer &cb);
 
     // the methods below can only be called on an up() service
@@ -100,29 +104,15 @@ class ICAPServiceRep : public RefCountable, public ICAPInitiator
     void noteFailure(); // called by transactions to report service failure
     
     //AsyncJob virtual methods
-    virtual bool doneAll() const { return ICAPInitiator::doneAll() && false;}
-
-public:
-    String key;
-    ICAP::Method method;
-    ICAP::VectPoint point;
-    String uri;    // service URI
-
-    // URI components
-    String host;
-    int port;
-    String resource;
-
-    // XXX: use it when selecting a service and handling ICAP errors!
-    bool bypass;
+    virtual bool doneAll() const { return Adaptation::Initiator::doneAll() && false;}
 
 public: // treat these as private, they are for callbacks only
     void noteTimeToUpdate();
     void noteTimeToNotify();
 
     // receive either an ICAP OPTIONS response header or an abort message
-    virtual void noteIcapAnswer(HttpMsg *msg);
-    virtual void noteIcapQueryAbort(bool);
+    virtual void noteAdaptationAnswer(HttpMsg *msg);
+    virtual void noteAdaptationQueryAbort(bool);
 
 private:
     // stores Prepare() callback info
@@ -137,7 +127,7 @@ class ICAPServiceRep : public RefCountable, public ICAPInitiator
     Clients theClients; // all clients waiting for a call back
 
     ICAPOptions *theOptions;
-    ICAPInitiate *theOptionsFetcher; // pending ICAP OPTIONS transaction
+    Adaptation::Initiate *theOptionsFetcher; // pending ICAP OPTIONS transaction
     time_t theLastUpdate; // time the options were last updated
 
     static const int TheSessionFailureLimit;
@@ -174,5 +164,4 @@ class ICAPServiceRep : public RefCountable, public ICAPInitiator
     CBDATA_CLASS2(ICAPServiceRep);
 };
 
-
 #endif /* SQUID_ICAPSERVICEREP_H */
@@ -17,9 +17,9 @@ static PconnPool *icapPconnPool = new PconnPool("ICAP Servers");
 
 //CBDATA_CLASS_INIT(ICAPXaction);
 
-ICAPXaction::ICAPXaction(const char *aTypeName, ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService):
+ICAPXaction::ICAPXaction(const char *aTypeName, Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService):
         AsyncJob(aTypeName),
-        ICAPInitiate(aTypeName, anInitiator, aService),
+        Adaptation::Initiate(aTypeName, anInitiator, aService.getRaw()),
         connection(-1),
         commBuf(NULL), commBufSize(0),
         commEof(false),
@@ -38,6 +38,14 @@ ICAPXaction::~ICAPXaction()
         " [icapx" << id << ']'); // we should not call virtual status() here
 }
 
+ICAPServiceRep &
+ICAPXaction::service()
+{
+    ICAPServiceRep *s = dynamic_cast<ICAPServiceRep*>(&Initiate::service());
+    Must(s);
+    return *s;
+}
+
 void ICAPXaction::disableRetries() {
     debugs(93,5, typeName << (isRetriable ? " becomes" : " remains") <<
         " final" << status());
@@ -46,7 +54,7 @@ void ICAPXaction::disableRetries() {
 
 void ICAPXaction::start()
 {
-    ICAPInitiate::start();
+    Adaptation::Initiate::start();
 
     readBuf.init(SQUID_TCP_SO_RCVBUF, SQUID_TCP_SO_RCVBUF);
     commBuf = (char*)memAllocBuf(SQUID_TCP_SO_RCVBUF, &commBufSize);
@@ -61,13 +69,13 @@ void ICAPXaction::openConnection()
 
     Must(connection < 0);
 
-    const ICAPServiceRep &s = service();
+    const Adaptation::Service &s = service();
 
     if (!TheICAPConfig.reuse_connections)
         disableRetries(); // this will also safely drain pconn pool
 
     // TODO: check whether NULL domain is appropriate here
-    connection = icapPconnPool->pop(s.host.buf(), s.port, NULL, client_addr, isRetriable);
+    connection = icapPconnPool->pop(s.cfg().host.buf(), s.cfg().port, NULL, client_addr, isRetriable);
     if (connection >= 0) {
         debugs(93,3, HERE << "reused pconn FD " << connection);
 
@@ -86,19 +94,20 @@ void ICAPXaction::openConnection()
 
     IPAddress outgoing;
     connection = comm_open(SOCK_STREAM, 0, outgoing, 
-        COMM_NONBLOCKING, s.uri.buf());
+        COMM_NONBLOCKING, s.cfg().uri.buf());
 
     if (connection < 0)
         dieOnConnectionFailure(); // throws
 
-    debugs(93,3, typeName << " opens connection to " << s.host.buf() << ":" << s.port);
+    debugs(93,3, typeName << " opens connection to " << s.cfg().host.buf() << ":" << s.cfg().port);
 
     // TODO: service bypass status may differ from that of a transaction
     typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
 			TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
 
-    commSetTimeout(connection, TheICAPConfig.connect_timeout(service().bypass), timeoutCall);
+    commSetTimeout(connection, TheICAPConfig.connect_timeout(
+        service().cfg().bypass), timeoutCall);
 
     typedef CommCbMemFunT<ICAPXaction, CommCloseCbParams> CloseDialer;
     closer =  asyncCall(93, 5, "ICAPXaction::noteCommClosed",
@@ -108,7 +117,7 @@ void ICAPXaction::openConnection()
     typedef CommCbMemFunT<ICAPXaction, CommConnectCbParams> ConnectDialer;
     connector = asyncCall(93,3, "ICAPXaction::noteCommConnected",
         ConnectDialer(this, &ICAPXaction::noteCommConnected));
-    commConnectStart(connection, s.host.buf(), s.port, connector);
+    commConnectStart(connection, s.cfg().host.buf(), s.cfg().port, connector);
 }
 
 /*
@@ -146,7 +155,8 @@ void ICAPXaction::closeConnection()
             debugs(93,3, HERE << "pushing pconn" << status());
 	    AsyncCall::Pointer call = NULL;
 	    commSetTimeout(connection, -1, call);
-            icapPconnPool->push(connection, theService->host.buf(), theService->port, NULL, client_addr);
+            icapPconnPool->push(connection, theService->cfg().host.buf(),
+                theService->cfg().port, NULL, client_addr);
             disableRetries();
         } else {
             debugs(93,3, HERE << "closing pconn" << status());
@@ -177,7 +187,7 @@ void ICAPXaction::noteCommConnected(const CommConnectCbParams &io)
 
 void ICAPXaction::dieOnConnectionFailure() {
     debugs(93, 2, HERE << typeName <<
-        " failed to connect to " << service().uri);
+        " failed to connect to " << service().cfg().uri);
     theService->noteFailure();
     throw TexcHere("cannot connect to the ICAP service");
 }
@@ -218,7 +228,8 @@ void ICAPXaction::noteCommTimedout(const CommTimeoutCbParams &io)
 void ICAPXaction::handleCommTimedout()
 {
     debugs(93, 2, HERE << typeName << " failed: timeout with " <<
-        theService->methodStr() << " " << theService->uri.buf() << status());
+        theService->cfg().methodStr() << " " <<
+        theService->cfg().uri.buf() << status());
     reuseConnection = false;
     service().noteFailure();
 
@@ -245,12 +256,12 @@ void ICAPXaction::callEnd()
         debugs(93, 5, HERE << typeName << " done with I/O" << status());
         closeConnection();
     }
-    ICAPInitiate::callEnd(); // may destroy us
+    Adaptation::Initiate::callEnd(); // may destroy us
 }
 
 bool ICAPXaction::doneAll() const
 {
-    return !connector && !reader && !writer && ICAPInitiate::doneAll();
+    return !connector && !reader && !writer && Adaptation::Initiate::doneAll();
 }
 
 void ICAPXaction::updateTimeout() {
@@ -262,7 +273,8 @@ void ICAPXaction::updateTimeout() {
 	    AsyncCall::Pointer call =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
 				    TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
 
-        commSetTimeout(connection, TheICAPConfig.io_timeout(service().bypass), call);
+        commSetTimeout(connection, 
+            TheICAPConfig.io_timeout(service().cfg().bypass), call);
     } else {
         // clear timeout when there is no I/O
         // Do we need a lifetime timeout?
@@ -396,7 +408,7 @@ void ICAPXaction::swanSong()
     if (theInitiator)
         tellQueryAborted(!isRetriable);
 
-    ICAPInitiate::swanSong();
+    Adaptation::Initiate::swanSong();
 }
 
 // returns a temporary string depicting transaction status, for debugging
@@ -38,7 +38,7 @@
 #include "CommCalls.h"
 #include "MemBuf.h"
 #include "ICAPServiceRep.h"
-#include "ICAPInitiate.h"
+#include "adaptation/Initiate.h"
 
 class HttpMsg;
 class CommConnectCbParams;
@@ -53,11 +53,11 @@ class CommConnectCbParams;
 
 // Note: ICAPXaction must be the first parent for object-unaware cbdata to work
 
-class ICAPXaction: public ICAPInitiate
+class ICAPXaction: public Adaptation::Initiate
 {
 
 public:
-    ICAPXaction(const char *aTypeName, ICAPInitiator *anInitiator, ICAPServiceRep::Pointer &aService);
+    ICAPXaction(const char *aTypeName, Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService);
     virtual ~ICAPXaction();
 
     void disableRetries();
@@ -71,7 +71,7 @@ class ICAPXaction: public ICAPInitiate
 
 protected:
     virtual void start();
-    virtual void noteInitiatorAborted(); // TODO: move to ICAPInitiate
+    virtual void noteInitiatorAborted(); // TODO: move to Adaptation::Initiate
 
     // comm hanndlers; called by comm handler wrappers
     virtual void handleCommConnected() = 0;
@@ -112,6 +112,8 @@ class ICAPXaction: public ICAPInitiate
     // custom end-of-call checks
     virtual void callEnd();
 
+    ICAPServiceRep &service();
+
 protected:
     int connection;     // FD of the ICAP server connection
 
@@ -0,0 +1,37 @@
+AM_CFLAGS = @SQUID_CFLAGS@
+AM_CXXFLAGS = @SQUID_CXXFLAGS@
+
+INCLUDES = \
+	-I$(top_builddir)/include \
+	-I$(top_srcdir)/include \
+        -I$(top_srcdir)/src
+
+noinst_LTLIBRARIES = libicap.la
+
+libicap_la_SOURCES = \
+	ICAPClient.cc \
+	ICAPClient.h \
+	ICAPInOut.h \
+	ICAPConfig.cc \
+	ICAPConfig.h \
+	ICAPElements.cc \
+	ICAPElements.h \
+	ICAPOptions.cc \
+	ICAPOptions.h \
+	ICAPServiceRep.cc \
+	ICAPServiceRep.h \
+	ICAPLauncher.cc \
+	ICAPLauncher.h \
+	ICAPOptXact.cc \
+	ICAPOptXact.h \
+	ICAPXaction.cc \
+	ICAPXaction.h \
+	ICAPModXact.cc \
+	ICAPModXact.h
+
+
+check_PROGRAMS = testHeaders
+
+## test .h correctness
+testHeaders: *.h
+	$(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "." || exit 1
@@ -0,0 +1,86 @@
+#include "squid.h"
+
+/* The original code has this constant ./configure-able.
+ * The "#else" branches use raw dlopen interface and have not been tested.
+ * We can remove that code if we are going to rely on libtool's ltdl in 
+ * all environments. */
+#define XSTD_USE_LIBLTDL 1
+
+#if XSTD_USE_LIBLTDL
+	#include "libLtdl/ltdl.h" /* generated file */
+#else
+	#include <dlfcn.h>
+#endif
+
+#include "TextException.h"
+#include "LoadableModule.h"
+
+// Note: We must use preprocessor instead of C ifs because if dlopen()
+// is seen by the static linker, the linker will complain.
+
+LoadableModule::LoadableModule(const String &aName): theName(aName), theHandle(0) {
+#	if XSTD_USE_LIBLTDL
+		// Initialise preloaded symbol lookup table.
+		LTDL_SET_PRELOADED_SYMBOLS();
+		if (lt_dlinit() != 0)
+			throw TexcHere("internal error: cannot initialize libtool module loader");
+#	endif
+}
+
+LoadableModule::~LoadableModule() {
+	if (loaded())
+		unload();
+#	if XSTD_USE_LIBLTDL
+		assert(lt_dlexit() == 0); // XXX: replace with a warning
+#	endif
+}
+
+bool LoadableModule::loaded() const {
+	return theHandle != 0;
+}
+
+void LoadableModule::load(int mode) {
+	if (loaded())
+		throw TexcHere("internal error: reusing LoadableModule object");
+
+	theHandle = openModule(mode);
+
+	if (!loaded())
+		throw TexcHere(errorMsg());
+}
+
+void LoadableModule::unload() {
+	if (!loaded())
+		throw TexcHere("internal error: unloading not loaded module");
+
+	if (!closeModule())
+		throw TexcHere(errorMsg());
+
+	theHandle = 0;
+}
+
+void *LoadableModule::openModule(int mode) {
+#	if XSTD_USE_LIBLTDL
+		return lt_dlopen(theName.buf());
+#	else
+		return dlopen(theName.c_str(),
+			mode == lmNow ? RTLD_NOW : RTLD_LAZY);
+#	endif
+}
+
+bool LoadableModule::closeModule() {
+#	if XSTD_USE_LIBLTDL
+		// we cast to avoid including ltdl.h in LoadableModule.h
+		return lt_dlclose(static_cast<lt_dlhandle>(theHandle)) == 0;
+#	else
+		return dlclose(theHandle) == 0;
+#	endif
+}
+
+const char *LoadableModule::errorMsg() {
+#	if XSTD_USE_LIBLTDL
+		return lt_dlerror();
+#	else
+		return dlerror();
+#	endif
+}
@@ -0,0 +1,33 @@
+#ifndef SQUID_LOADABLE_MODULE_H
+#define SQUID_LOADABLE_MODULE_H
+
+#include "SquidString.h"
+
+// wrapper for dlopen(3), libltdl, and friends
+class LoadableModule {
+public:
+    enum LoadMode { lmNow, lmLazy };
+
+public:
+    LoadableModule(const String &aName);
+    ~LoadableModule();           // unloads if loaded
+
+    bool loaded() const;
+    const String &name() const { return theName; }
+    const String &error() const { return theError; }
+
+    void load(int mode = lmNow); // throws Texc
+    void unload(); // throws Texc
+
+protected:
+    String theName;
+    String theError;
+    void *theHandle;
+
+private:
+    void *openModule(int mode);
+    bool closeModule();
+    const char *errorMsg();
+};
+
+#endif
@@ -0,0 +1,25 @@
+#include "squid.h"
+#include "wordlist.h"
+#include "LoadableModule.h"
+#include "LoadableModules.h"
+
+static void
+LoadModule(const char *fname)
+{
+    debugs(1, 1, "loading Squid module from '" << fname << "'");
+
+    LoadableModule *m = new LoadableModule(fname);
+    m->load();
+    debugs(1, 2, "loaded Squid module from '" << fname << "'");
+
+    //TODO: TheModules.push_back(m);
+}
+
+void
+LoadableModulesConfigure(const wordlist *names)
+{
+    int count = 0;
+    for (const wordlist *i = names; i; i = i->next, ++count)
+        LoadModule(i->key);
+    debugs(1, 1, "loaded " << count << " Squid modules");
+}
@@ -0,0 +1,10 @@
+#ifndef SQUID_LOADABLE_MODULES_H
+#define SQUID_LOADABLE_MODULES_H
+
+// TODO: add reporting for cachemgr
+// TODO: add reconfiguration support
+
+class wordlist;
+extern void LoadableModulesConfigure(const wordlist *names);
+
+#endif /* SQUID_LOADABLE_MODULES_H */
@@ -25,11 +25,31 @@ else
 SNMP_SOURCE = 
 endif
 
+LOADABLE_MODULES_SOURCES = \
+	LoadableModule.h \
+	LoadableModule.cc \
+	LoadableModules.h \
+	LoadableModules.cc
+
 TESTS=$(check_PROGRAMS)
 check_PROGRAMS=
 
 SUBDIRS		= fs repl auth
 
+if USE_ADAPTATION
+SUBDIRS += adaptation
+endif
+
+if USE_ICAP_CLIENT
+SUBDIRS += ICAP
+endif
+
+if USE_ECAP
+SUBDIRS += eCAP
+endif
+
+ADAPTATION_LIBS = @ECAP_LIBS@ @ICAP_LIBS@ @ADAPTATION_LIBS@
+
 DELAY_POOL_ALL_SOURCE = \
 	CommonPool.h \
 	CompositePoolNode.h \
@@ -202,11 +222,12 @@ endif
 AM_CFLAGS = @SQUID_CFLAGS@
 AM_CXXFLAGS = @SQUID_CXXFLAGS@
 
-EXTRA_LIBRARIES = libAIO.a libBlocking.a libDiskDaemon.a libDiskThreads.a ICAP/libicap.a
-noinst_LIBRARIES = @DISK_LIBS@ @ICAP_LIBS@
+EXTRA_LIBRARIES = libAIO.a libBlocking.a libDiskDaemon.a libDiskThreads.a
+noinst_LIBRARIES = @DISK_LIBS@
 noinst_LTLIBRARIES = libsquid.la libauth.la
 
 INCLUDES        = -I. -I$(srcdir) -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/lib/libTrie/include
+INCLUDES        += -I$(top_builddir)/lib
 INCLUDES	+= @SQUID_CPPUNIT_INC@
 
 EXTRA_PROGRAMS = \
@@ -301,6 +322,7 @@ EXTRA_squid_SOURCES = \
 	$(UNLINKDSOURCE) \
 	$(SSL_ALL_SOURCE) \
 	$(WIN32_ALL_SOURCE) \
+	$(LOADABLE_MODULES_SOURCES) \
 	DiskIO/DiskThreads/aiops.cc \
 	DiskIO/DiskThreads/aiops_win32.cc
 
@@ -413,6 +435,7 @@ libsquid_la_SOURCES = \
         TextException.cc \
         TextException.h
 
+
 # authentication framework
 libauth_la_SOURCES = \
 	AuthConfig.cc \
@@ -683,7 +706,7 @@ squid_LDADD = \
 	@CRYPTLIB@ \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@SSLLIB@ \
 	-lmiscutil \
 	@XTRA_LIBS@ \
@@ -697,32 +720,19 @@ squid_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@AUTH_LINKOBJS@ \
 	@AUTH_OBJS@ \
-	@ICAP_LIBS@
-
-ICAP_libicap_a_SOURCES = \
-	ICAP/ICAPClient.cc \
-	ICAP/ICAPClient.h \
-	ICAP/ICAPInitiator.cc \
-	ICAP/ICAPInitiator.h \
-	ICAP/ICAPInitiate.cc \
-	ICAP/ICAPInitiate.h \
-	ICAP/ICAPInOut.h \
-	ICAP/ICAPLauncher.cc \
-	ICAP/ICAPLauncher.h \
-	ICAP/ICAPConfig.cc \
-	ICAP/ICAPConfig.h \
-	ICAP/ICAPElements.cc \
-	ICAP/ICAPElements.h \
-	ICAP/ICAPModXact.cc \
-	ICAP/ICAPModXact.h \
-	ICAP/ICAPOptions.cc \
-	ICAP/ICAPOptions.h \
-	ICAP/ICAPOptXact.cc \
-	ICAP/ICAPOptXact.h \
-	ICAP/ICAPServiceRep.cc \
-	ICAP/ICAPServiceRep.h \
-	ICAP/ICAPXaction.cc \
-	ICAP/ICAPXaction.h
+	${ADAPTATION_LIBS}
+
+if USE_LOADABLE_MODULES
+squid_SOURCES += $(LOADABLE_MODULES_SOURCES)
+squid_LDADD += \
+	@LIBLTDL@
+squid_LDFLAGS = \
+	-export-dynamic -dlopen force
+# when static module linking is supported and enabled:
+# squid_LDFLAGS = \
+#         -all-static -dlopen self
+#
+endif
 
 
 unlinkd_SOURCES = unlinkd_daemon.cc SquidNew.cc
@@ -931,7 +941,7 @@ ufsdump_LDADD = \
 	@CRYPTLIB@ \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@SSLLIB@ \
 	-lmiscutil \
 	@XTRA_LIBS@ \
@@ -945,7 +955,7 @@ ufsdump_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@AUTH_LINKOBJS@ \
 	@AUTH_OBJS@ \
-	@ICAP_LIBS@
+	${ADAPTATION_LIBS}
 
 nodist_ufsdump_SOURCES = \
 	repl_modules.cc \
@@ -1179,10 +1189,9 @@ check_PROGRAMS+= testHeaders \
 
 ## Special Universal .h dependency test script
 ## aborts if error encountered
-testHeaders: *.h DiskIO/*.h ICAP/*.h
+testHeaders: *.h DiskIO/*.h
 	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "." || exit 1
 	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "DiskIO" || exit 1
-	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "ICAP" || exit 1
 ## src/repl/ has no .h files and its own makefile.
 
 
@@ -1473,7 +1482,7 @@ tests_testCacheManager_LDADD = \
 	libsquid.la \
 	libauth.la \
 	@REPL_OBJS@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
 	-L../lib -lmiscutil \
@@ -1485,7 +1494,7 @@ tests_testCacheManager_LDFLAGS = $(LIBADD_DL)
 tests_testCacheManager_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@SQUID_CPPUNIT_LA@ \
-	@ICAP_LIBS@
+	${ADAPTATION_LIBS}
 
 tests_testDiskIO_SOURCES= \
 	$(SWAP_TEST_SOURCES) \
@@ -1643,7 +1652,7 @@ tests_testEvent_LDADD = \
 	libsquid.la \
 	libauth.la \
 	@REPL_OBJS@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
 	-L../lib -lmiscutil \
@@ -1655,7 +1664,7 @@ tests_testEvent_LDFLAGS = $(LIBADD_DL)
 tests_testEvent_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@SQUID_CPPUNIT_LA@ \
-	@ICAP_LIBS@
+	${ADAPTATION_LIBS}
 
 ## Tests of the EventLoop module.
 tests_testEventLoop_SOURCES = \
@@ -1799,7 +1808,7 @@ tests_testEventLoop_LDADD = \
 	libsquid.la \
 	libauth.la \
 	@REPL_OBJS@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
 	-L../lib -lmiscutil \
@@ -1811,7 +1820,7 @@ tests_testEventLoop_LDFLAGS = $(LIBADD_DL)
 tests_testEventLoop_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@SQUID_CPPUNIT_LA@ \
-	@ICAP_LIBS@
+	${ADAPTATION_LIBS}
 
 tests_test_http_range_SOURCES = \
 	tests/test_http_range.cc \
@@ -1951,7 +1960,7 @@ tests_test_http_range_LDADD = \
 	libauth.la \
 	@REPL_OBJS@ \
 	@STORE_OBJS@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
 	-L../lib -lmiscutil \
@@ -2106,7 +2115,7 @@ tests_testHttpRequest_LDADD = \
 	libsquid.la \
 	libauth.la \
 	@REPL_OBJS@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
 	-L../lib -lmiscutil \
@@ -2118,7 +2127,7 @@ tests_testHttpRequest_LDFLAGS = $(LIBADD_DL)
 tests_testHttpRequest_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@SQUID_CPPUNIT_LA@ \
-	@ICAP_LIBS@
+	${ADAPTATION_LIBS}
 
 ## Tests of the ICMP base module.
 # Its used by pinger so SHOULD NOT require more dependancies! :-(
@@ -2465,7 +2474,7 @@ tests_testURL_LDADD = \
 	libauth.la \
 	@REGEXLIB@ \
 	@REPL_OBJS@ \
-	@ICAP_LIBS@ \
+	${ADAPTATION_LIBS} \
 	@SNMPLIB@ \
 	-L../lib -lmiscutil \
 	@SQUID_CPPUNIT_LIBS@ \
@@ -2476,4 +2485,4 @@ tests_testURL_LDFLAGS = $(LIBADD_DL)
 tests_testURL_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 	@REPL_OBJS@ \
 	@SQUID_CPPUNIT_LA@ \
-	@ICAP_LIBS@
+	${ADAPTATION_LIBS}
@@ -39,17 +39,16 @@
 #include "HttpReply.h"
 #include "errorpage.h"
 
-#if ICAP_CLIENT
-#include "ICAP/ICAPModXact.h"
-#include "ICAP/ICAPConfig.h"
-extern ICAPConfig TheICAPConfig;
+#if USE_ADAPTATION
+#include "adaptation/AccessCheck.h"
+#include "adaptation/Service.h"
 #endif
 
 ServerStateData::ServerStateData(FwdState *theFwdState): AsyncJob("ServerStateData"),requestSender(NULL)
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     , adaptedHeadSource(NULL)
-    , icapAccessCheckPending(false)
-    , startedIcap(false)
+    , adaptationAccessCheckPending(false)
+    , startedAdaptation(false)
 #endif
 {
     fwd = theFwdState;
@@ -73,8 +72,8 @@ ServerStateData::~ServerStateData()
     if (requestBodySource != NULL)
         requestBodySource->clearConsumer();
 
-#if ICAP_CLIENT
-    cleanIcap();
+#if USE_ADAPTATION
+    cleanAdaptation();
 #endif
 
     if (responseBodyBuffer != NULL) {
@@ -151,11 +150,11 @@ ServerStateData::serverComplete2()
 {
     debugs(11,5,HERE << "serverComplete2 " << this);
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     if (virginBodyDestination != NULL)
         stopProducingFor(virginBodyDestination, true);
 
-    if (!doneWithIcap())
+    if (!doneWithAdaptation())
         return;
 #endif
 
@@ -167,8 +166,8 @@ ServerStateData::serverComplete2()
 // to the ICAP service. And vice versa. Here, we quit only if we are done
 // talking to both.
 void ServerStateData::quitIfAllDone() {
-#if ICAP_CLIENT
-    if (!doneWithIcap()) {
+#if USE_ADAPTATION
+    if (!doneWithAdaptation()) {
         debugs(11,5, HERE << "transaction not done: still talking to ICAP");
         return;
     }
@@ -226,7 +225,7 @@ ServerStateData::abortOnBadEntry(const char *abortReason)
 void
 ServerStateData::noteMoreBodyDataAvailable(BodyPipe::Pointer bp)
 {
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     if (adaptedBodySource == bp) {
         handleMoreAdaptedBodyAvailable();
         return;
@@ -239,7 +238,7 @@ ServerStateData::noteMoreBodyDataAvailable(BodyPipe::Pointer bp)
 void
 ServerStateData::noteBodyProductionEnded(BodyPipe::Pointer bp)
 {
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     if (adaptedBodySource == bp) {
         handleAdaptedBodyProductionEnded();
         return;
@@ -252,7 +251,7 @@ ServerStateData::noteBodyProductionEnded(BodyPipe::Pointer bp)
 void
 ServerStateData::noteBodyProducerAborted(BodyPipe::Pointer bp)
 {
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     if (adaptedBodySource == bp) {
         handleAdaptedBodyProducerAborted();
         return;
@@ -367,7 +366,7 @@ ServerStateData::sendMoreRequestBody()
     }
 }
 
-// called by noteIcapAnswer(), HTTP server overwrites this
+// called by noteAdaptationAnswer(), HTTP server overwrites this
 void
 ServerStateData::haveParsedReplyHeaders()
 {
@@ -380,22 +379,22 @@ ServerStateData::originalRequest()
     return request;
 }
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 /*
  * Initiate an ICAP transaction.  Return true on success.
  * Caller will handle error condition by generating a Squid error message
  * or take other action.
  */
 bool
-ServerStateData::startIcap(ICAPServiceRep::Pointer service, HttpRequest *cause)
+ServerStateData::startAdaptation(Adaptation::ServicePointer service, HttpRequest *cause)
 {
-    debugs(11, 5, "ServerStateData::startIcap() called");
+    debugs(11, 5, "ServerStateData::startAdaptation() called");
     if (!service) {
-        debugs(11, 3, "ServerStateData::startIcap fails: lack of service");
+        debugs(11, 3, "ServerStateData::startAdaptation fails: lack of service");
         return false;
     }
     if (service->broken()) {
-        debugs(11, 3, "ServerStateData::startIcap fails: broken service");
+        debugs(11, 3, "ServerStateData::startAdaptation fails: broken service");
         return false;
     }
 
@@ -414,15 +413,15 @@ ServerStateData::startIcap(ICAPServiceRep::Pointer service, HttpRequest *cause)
             virginBodyDestination->setBodySize(size);
     }
 
-    adaptedHeadSource = initiateIcap(
-        new ICAPModXactLauncher(this, vrep, cause, service));
+    adaptedHeadSource = initiateAdaptation(service->makeXactLauncher(
+        this, vrep, cause));
     return adaptedHeadSource != NULL;
 }
 
 // properly cleans up ICAP-related state
 // may be called multiple times
-void ServerStateData::cleanIcap() {
-    debugs(11,5, HERE << "cleaning ICAP; ACL: " << icapAccessCheckPending);
+void ServerStateData::cleanAdaptation() {
+    debugs(11,5, HERE << "cleaning ICAP; ACL: " << adaptationAccessCheckPending);
 
     if (virginBodyDestination != NULL)
         stopProducingFor(virginBodyDestination, false);
@@ -432,21 +431,21 @@ void ServerStateData::cleanIcap() {
     if (adaptedBodySource != NULL)
         stopConsumingFrom(adaptedBodySource);
 
-    if (!icapAccessCheckPending) // we cannot cancel a pending callback
-        assert(doneWithIcap()); // make sure the two methods are in sync
+    if (!adaptationAccessCheckPending) // we cannot cancel a pending callback
+        assert(doneWithAdaptation()); // make sure the two methods are in sync
 }
 
 bool
-ServerStateData::doneWithIcap() const {
-    return !icapAccessCheckPending &&
+ServerStateData::doneWithAdaptation() const {
+    return !adaptationAccessCheckPending &&
         !virginBodyDestination && !adaptedHeadSource && !adaptedBodySource;
 }
 
 // sends virgin reply body to ICAP, buffering excesses if needed
 void
 ServerStateData::adaptVirginReplyBody(const char *data, ssize_t len)
 {
-    assert(startedIcap);
+    assert(startedAdaptation);
 
     if (!virginBodyDestination) {
         debugs(11,3, HERE << "ICAP does not want more virgin body");
@@ -504,17 +503,17 @@ ServerStateData::noteBodyConsumerAborted(BodyPipe::Pointer)
 {
     stopProducingFor(virginBodyDestination, false);
 
-    // do not force closeServer here in case we need to bypass IcapQueryAbort
+    // do not force closeServer here in case we need to bypass AdaptationQueryAbort
 
-    if (doneWithIcap()) // we may still be receiving adapted response
-        handleIcapCompleted();
+    if (doneWithAdaptation()) // we may still be receiving adapted response
+        handleAdaptationCompleted();
 }
 
 // received adapted response headers (body may follow)
 void
-ServerStateData::noteIcapAnswer(HttpMsg *msg)
+ServerStateData::noteAdaptationAnswer(HttpMsg *msg)
 {
-    clearIcap(adaptedHeadSource); // we do not expect more messages
+    clearAdaptation(adaptedHeadSource); // we do not expect more messages
 
     if (abortOnBadEntry("entry went bad while waiting for adapted headers"))
         return;
@@ -532,17 +531,17 @@ ServerStateData::noteIcapAnswer(HttpMsg *msg)
         assert(adaptedBodySource->setConsumerIfNotLate(this));
     } else {
         // no body
-        if (doneWithIcap()) // we may still be sending virgin response
-            handleIcapCompleted();
+        if (doneWithAdaptation()) // we may still be sending virgin response
+            handleAdaptationCompleted();
     }
 }
 
 // will not receive adapted response headers (and, hence, body)
 void
-ServerStateData::noteIcapQueryAbort(bool final)
+ServerStateData::noteAdaptationQueryAbort(bool final)
 {
-    clearIcap(adaptedHeadSource);
-    handleIcapAborted(!final);
+    clearAdaptation(adaptedHeadSource);
+    handleAdaptationAborted(!final);
 }
 
 // more adapted response body is available
@@ -574,22 +573,22 @@ ServerStateData::handleAdaptedBodyProductionEnded()
     if (abortOnBadEntry("entry went bad while waiting for adapted body eof"))
         return;
 
-    handleIcapCompleted();
+    handleAdaptationCompleted();
 }
 
 // premature end of the adapted response body
 void ServerStateData::handleAdaptedBodyProducerAborted()
 {
     stopConsumingFrom(adaptedBodySource);
-    handleIcapAborted();
+    handleAdaptationAborted();
 }
 
-// common part of noteIcapAnswer and handleAdaptedBodyProductionEnded
+// common part of noteAdaptationAnswer and handleAdaptedBodyProductionEnded
 void
-ServerStateData::handleIcapCompleted()
+ServerStateData::handleAdaptationCompleted()
 {
-    debugs(11,5, HERE << "handleIcapCompleted");
-    cleanIcap();
+    debugs(11,5, HERE << "handleAdaptationCompleted");
+    cleanAdaptation();
 
     // We stop reading origin response because we have no place to put it and
     // cannot use it. If some origin servers do not like that or if we want to
@@ -604,11 +603,11 @@ ServerStateData::handleIcapCompleted()
 }
 
 
-// common part of noteIcap*Aborted and noteBodyConsumerAborted methods
+// common part of noteAdaptation*Aborted and noteBodyConsumerAborted methods
 void
-ServerStateData::handleIcapAborted(bool bypassable)
+ServerStateData::handleAdaptationAborted(bool bypassable)
 {
-    debugs(11,5, HERE << "handleIcapAborted; bypassable: " << bypassable <<
+    debugs(11,5, HERE << "handleAdaptationAborted; bypassable: " << bypassable <<
         ", entry empty: " << entry->isEmpty());
 
     if (abortOnBadEntry("entry went bad while ICAP aborted"))
@@ -629,9 +628,9 @@ ServerStateData::handleIcapAborted(bool bypassable)
 }
 
 void
-ServerStateData::icapAclCheckDone(ICAPServiceRep::Pointer service)
+ServerStateData::adaptationAclCheckDone(Adaptation::ServicePointer service)
 {
-    icapAccessCheckPending = false;
+    adaptationAccessCheckPending = false;
 
     if (abortOnBadEntry("entry went bad while waiting for ICAP ACL check"))
         return;
@@ -642,19 +641,19 @@ ServerStateData::icapAclCheckDone(ICAPServiceRep::Pointer service)
         sendBodyIsTooLargeError();
         return;
     }
-    // TODO: Should we check received5CBodyTooLarge on the server-side as well?
+    // TODO: Should we check receivedBodyTooLarge on the server-side as well?
 
-    startedIcap = startIcap(service, originalRequest());
+    startedAdaptation = startAdaptation(service, originalRequest());
 
-    if (!startedIcap && (!service || service->bypass)) {
+    if (!startedAdaptation && (!service || service->cfg().bypass)) {
         // handle ICAP start failure when no service was selected
         // or where the selected service was optional
         setFinalReply(virginReply());
         processReplyBody();
         return;
     }
 
-    if (!startedIcap) {
+    if (!startedAdaptation) {
         // handle start failure for an essential ICAP service
         ErrorState *err = errorCon(ERR_ICAP_FAILURE,
             HTTP_INTERNAL_SERVER_ERROR, originalRequest());
@@ -668,10 +667,10 @@ ServerStateData::icapAclCheckDone(ICAPServiceRep::Pointer service)
 }
 
 void
-ServerStateData::icapAclCheckDoneWrapper(ICAPServiceRep::Pointer service, void *data)
+ServerStateData::adaptationAclCheckDoneWrapper(Adaptation::ServicePointer service, void *data)
 {
     ServerStateData *state = (ServerStateData *)data;
-    state->icapAclCheckDone(service);
+    state->adaptationAclCheckDone(service);
 }
 #endif
 
@@ -690,18 +689,14 @@ ServerStateData::sendBodyIsTooLargeError()
 void
 ServerStateData::adaptOrFinalizeReply()
 {
-#if ICAP_CLIENT
-
-    if (TheICAPConfig.onoff) {
-        ICAPAccessCheck *icap_access_check =
-            new ICAPAccessCheck(ICAP::methodRespmod, ICAP::pointPreCache,
-                request, virginReply(), icapAclCheckDoneWrapper, this);
-
-        icapAccessCheckPending = true;
-        icap_access_check->check(); // will eventually delete self
+#if USE_ADAPTATION
+    // TODO: merge with client side and return void to hide the on/off logic?
+    // The callback can be called with a NULL service if adaptation is off.
+    adaptationAccessCheckPending = Adaptation::AccessCheck::Start(
+        Adaptation::methodRespmod, Adaptation::pointPreCache,
+        request, virginReply(), adaptationAclCheckDoneWrapper, this);
+    if (adaptationAccessCheckPending)
         return;
-    }
-
 #endif
 
     setFinalReply(virginReply());
@@ -710,9 +705,9 @@ ServerStateData::adaptOrFinalizeReply()
 void
 ServerStateData::addVirginReplyBody(const char *data, ssize_t len)
 {
-#if ICAP_CLIENT
-    assert(!icapAccessCheckPending); // or would need to buffer while waiting
-    if (startedIcap) {
+#if USE_ADAPTATION
+    assert(!adaptationAccessCheckPending); // or would need to buffer while waiting
+    if (startedAdaptation) {
         adaptVirginReplyBody(data, len);
         return;
     }
@@ -732,7 +727,7 @@ ServerStateData::storeReplyBody(const char *data, ssize_t len)
 
 size_t ServerStateData::replyBodySpace(size_t space)
 {
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     if (responseBodyBuffer) {
 	return 0;	// Stop reading if already overflowed waiting for ICAP to catch up
     }
@@ -750,13 +745,14 @@ size_t ServerStateData::replyBodySpace(size_t space)
          * The BodyPipe will call our noteMoreBodySpaceAvailable() method
          * when it has free space again.
          */
-        size_t icap_space = virginBodyDestination->buf().potentialSpaceSize();
+        size_t adaptation_space =
+            virginBodyDestination->buf().potentialSpaceSize();
 
-        debugs(11,9, "ServerStateData may read up to min(" << icap_space <<
-               ", " << space << ") bytes");
+        debugs(11,9, "ServerStateData may read up to min(" <<
+            adaptation_space << ", " << space << ") bytes");
 
-        if (icap_space < space)
-            space = icap_space;
+        if (adaptation_space < space)
+            space = adaptation_space;
     }
 #endif
 
@@ -52,16 +52,14 @@
 #include "ICAP/AsyncJob.h"
 #include "CommCalls.h"
 
-#if ICAP_CLIENT
-#include "ICAP/ICAPServiceRep.h"
-#include "ICAP/ICAPInitiator.h"
-
-class ICAPAccessCheck;
+#if USE_ADAPTATION
+#include "adaptation/forward.h"
+#include "adaptation/Initiator.h"
 #endif
 
 class ServerStateData:
-#if ICAP_CLIENT
-    public ICAPInitiator,
+#if USE_ADAPTATION
+    public Adaptation::Initiator,
     public BodyProducer,
 #endif
     public BodyConsumer
@@ -90,13 +88,13 @@ class ServerStateData:
     // a hack to reach HttpStateData::orignal_request
     virtual  HttpRequest *originalRequest();
 
-#if ICAP_CLIENT
-    void icapAclCheckDone(ICAPServiceRep::Pointer);
-    static void icapAclCheckDoneWrapper(ICAPServiceRep::Pointer service, void *data);
+#if USE_ADAPTATION
+    void adaptationAclCheckDone(Adaptation::ServicePointer service);
+    static void adaptationAclCheckDoneWrapper(Adaptation::ServicePointer service, void *data);
 
     // ICAPInitiator: start an ICAP transaction and receive adapted headers.
-    virtual void noteIcapAnswer(HttpMsg *message);
-    virtual void noteIcapQueryAbort(bool final);
+    virtual void noteAdaptationAnswer(HttpMsg *message);
+    virtual void noteAdaptationQueryAbort(bool final);
 
     // BodyProducer: provide virgin response body to ICAP.
     virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer );
@@ -106,8 +104,8 @@ class ServerStateData:
 
 //AsyncJob virtual methods
     virtual bool doneAll() const { return
-#if ICAP_CLIENT
-                                       ICAPInitiator::doneAll() &&
+#if USE_ADAPTATION
+                       Adaptation::Initiator::doneAll() &&
 				       BodyProducer::doneAll() &&
 #endif
 				       BodyConsumer::doneAll() && false;}
@@ -142,19 +140,19 @@ class ServerStateData:
     // Entry-dependent callbacks use this check to quit if the entry went bad
     bool abortOnBadEntry(const char *abortReason);
 
-#if ICAP_CLIENT
-    bool startIcap(ICAPServiceRep::Pointer, HttpRequest *cause);
+#if USE_ADAPTATION
+    bool startAdaptation(Adaptation::ServicePointer service, HttpRequest *cause);
     void adaptVirginReplyBody(const char *buf, ssize_t len);
-    void cleanIcap();
-    virtual bool doneWithIcap() const; // did we end ICAP communication?
+    void cleanAdaptation();
+    virtual bool doneWithAdaptation() const; // did we end ICAP communication?
 
     // BodyConsumer for ICAP: consume adapted response body.
     void handleMoreAdaptedBodyAvailable();
     void handleAdaptedBodyProductionEnded();
     void handleAdaptedBodyProducerAborted();
 
-    void handleIcapCompleted();
-    void handleIcapAborted(bool bypassable = false);
+    void handleAdaptationCompleted();
+    void handleAdaptationAborted(bool bypassable = false);
 #endif
 
 protected:
@@ -184,13 +182,13 @@ class ServerStateData:
     BodyPipe::Pointer requestBodySource; // to consume request body
     AsyncCall::Pointer requestSender; // set if we are expecting comm_write to call us back
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     BodyPipe::Pointer virginBodyDestination; // to provide virgin response body
-    ICAPInitiate *adaptedHeadSource; // to get adapted response headers
+    Adaptation::Initiate *adaptedHeadSource; // to get adapted response headers
     BodyPipe::Pointer adaptedBodySource; // to consume adated response body
 
-    bool icapAccessCheckPending;
-    bool startedIcap;
+    bool adaptationAccessCheckPending;
+    bool startedAdaptation;
 #endif
 
 private:
@@ -0,0 +1,254 @@
+#include "squid.h"
+#include "structs.h"
+
+#include "ConfigParser.h"
+#include "ACL.h"
+#include "HttpRequest.h"
+#include "HttpReply.h"
+#include "ACLChecklist.h"
+#include "adaptation/Service.h"
+#include "adaptation/ServiceGroups.h"
+#include "adaptation/AccessRule.h"
+#include "adaptation/Config.h"
+#include "adaptation/AccessCheck.h"
+
+
+cbdata_type Adaptation::AccessCheck::CBDATA_AccessCheck = CBDATA_UNKNOWN;
+
+bool
+Adaptation::AccessCheck::Start(Method method, VectPoint vp,
+    HttpRequest *req, HttpReply *rep, AccessCheckCallback *cb, void *cbdata) {
+
+    if (Config::Enabled) {
+        // the new check will call the callback and delete self, eventually
+        AccessCheck *check = new AccessCheck(method, vp, req, rep, cb, cbdata);
+        check->check();
+        return true;
+	}
+
+    debugs(83, 3, HERE << "adaptation off, skipping");
+    return false;
+}
+
+Adaptation::AccessCheck::AccessCheck(Method aMethod,
+                                 VectPoint aPoint,
+                                 HttpRequest *aReq,
+                                 HttpReply *aRep,
+                                 AccessCheckCallback *aCallback,
+                                 void *aCallbackData): AsyncJob("AccessCheck"), done(FALSE)
+{
+    // TODO: assign these at creation time
+
+    method = aMethod;
+    point = aPoint;
+
+    req = HTTPMSGLOCK(aReq);
+    rep = aRep ? HTTPMSGLOCK(aRep) : NULL;
+
+    callback = aCallback;
+
+    callback_data = cbdataReference(aCallbackData);
+
+    acl_checklist = NULL;
+
+    debugs(93, 5, "AccessCheck constructed for " << methodStr(method) << " " << vectPointStr(point));
+}
+
+Adaptation::AccessCheck::~AccessCheck()
+{
+    HTTPMSGUNLOCK(req);
+    HTTPMSGUNLOCK(rep);
+    if (callback_data)
+        cbdataReferenceDone(callback_data);
+}
+
+/*
+ * Walk the access rules list and find all classes that have at least
+ * one service with matching method and vectoring point.
+ */
+void
+Adaptation::AccessCheck::check()
+{
+    debugs(93, 4, "Adaptation::AccessCheck::check");
+
+    typedef AccessRules::iterator ARI;
+    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
+
+        /*
+         * We only find the first matching service because we only need
+         * one matching service to justify ACL-checking a class.  We might
+         * use other services belonging to the class if the first service
+         * turns out to be unusable for some reason.
+         */
+        AccessRule *r = *i;
+        ServicePointer service = findBestService(*r, false);
+        if (service != NULL) {
+            debugs(93, 5, "Adaptation::AccessCheck::check: rule '" << r->id << "' has candidate service '" << service->cfg().key << "'");
+            candidates += r->id;
+        }
+    }
+
+    checkCandidates();
+}
+
+// XXX: Here and everywhere we call FindRule(topCandidate()):
+// Once we identified the candidate, we should not just ignore it
+// if reconfigure changes rules. We should either lock the rule to
+// prevent reconfigure from stealing it or restart the check with
+// new rules. Throwing an exception may also be appropriate.
+void
+Adaptation::AccessCheck::checkCandidates()
+{
+    debugs(93, 4, "Adaptation::AccessCheck has " << candidates.size() << " rules");
+
+    while (!candidates.empty()) {
+        if (AccessRule *r = FindRule(topCandidate())) {
+            // XXX: we do not have access to conn->rfc931 here.
+            acl_checklist = aclChecklistCreate(r->acl, req, dash_str);
+            acl_checklist->reply = rep ? HTTPMSGLOCK(rep) : NULL;
+            acl_checklist->nonBlockingCheck(AccessCheckCallbackWrapper, this);
+            return;
+        }
+
+        candidates.shift(); // the rule apparently went away (reconfigure)
+    }
+
+    // when there are no canidates, fake answer 1
+    debugs(93, 4, "Adaptation::AccessCheck::check: NO candidates left");
+    noteAnswer(1);
+}
+
+void
+Adaptation::AccessCheck::AccessCheckCallbackWrapper(int answer, void *data)
+{
+    debugs(93, 8, "AccessCheckCallbackWrapper: answer=" << answer);
+    AccessCheck *ac = (AccessCheck*)data;
+    ac->noteAnswer(answer);
+}
+
+void
+Adaptation::AccessCheck::noteAnswer(int answer)
+{
+    debugs(93, 5, HERE << "AccessCheck::noteAnswer " << answer);
+    if (candidates.size())
+        debugs(93, 5, HERE << "was checking rule" << topCandidate());
+
+    if (!answer) {
+        candidates.shift(); // the rule did not match
+        checkCandidates();
+        return;
+    }
+
+    /*
+     * We use an event here to break deep function call sequences
+     */
+    // XXX: use AsyncCall for callback and remove
+    CallJobHere(93, 5, this, Adaptation::AccessCheck::do_callback);
+}
+
+void
+Adaptation::AccessCheck::do_callback()
+{
+    debugs(93, 3, "Adaptation::AccessCheck::do_callback");
+
+    if (candidates.size())
+        debugs(93, 3, HERE << "was checking rule" << topCandidate());
+
+    void *validated_cbdata;
+    if (!cbdataReferenceValidDone(callback_data, &validated_cbdata)) {
+        debugs(93,3,HERE << "do_callback: callback_data became invalid, skipping");
+        return;
+    }
+
+    ServicePointer service = NULL;
+    if (candidates.size()) {
+        if (AccessRule *r = FindRule(topCandidate())) {
+            service = findBestService(*r, true);
+            if (service != NULL)
+                debugs(93,3,HERE << "do_callback: with service " << service->cfg().uri);
+            else
+                debugs(93,3,HERE << "do_callback: no service for rule" << r->id);
+        } else {
+            debugs(93,3,HERE << "do_callback: no rule" << topCandidate());
+        }
+        candidates.shift(); // done with topCandidate()
+	} else {
+        debugs(93,3,HERE << "do_callback: no candidate rules");
+	}
+
+    callback(service, validated_cbdata);
+    done = TRUE;
+}
+
+Adaptation::ServicePointer
+Adaptation::AccessCheck::findBestService(AccessRule &r, bool preferUp) {
+
+    const char *what = preferUp ? "up " : "";
+    debugs(93,7,HERE << "looking for the first matching " << 
+        what << "service in group " << r.groupId);
+
+    ServicePointer secondBest;
+
+    ServiceGroup *g = FindGroup(r.groupId);
+
+    if (!g) {
+        debugs(93,5,HERE << "lost " << r.groupId << " group in rule" << r.id);
+        return ServicePointer();
+	}
+
+    ServiceGroup::Loop loop(g->initialServices());
+    typedef ServiceGroup::iterator SGI;
+    for (SGI i = loop.begin; i != loop.end; ++i) {
+
+        ServicePointer service = FindService(*i);
+
+        if (!service)
+            continue;
+
+        if (method != service->cfg().method)
+            continue;
+
+        if (point != service->cfg().point)
+            continue;
+
+        // sending a message to a broken service is likely to cause errors
+        if (service->cfg().bypass && service->broken())
+            continue;
+
+        if (service->up()) {
+            // sending a message to a service that does not want it is useless
+            // note that we cannot check wantsUrl for service that is not "up"
+            // note that even essential services are skipped on unwanted URLs!
+            if (!service->wantsUrl(req->urlpath))
+                continue;
+        } else {
+            if (!secondBest)
+                secondBest = service;
+            if (preferUp) {
+                // the caller asked for an "up" service and we can bypass this one
+                if (service->cfg().bypass)
+                    continue;
+                debugs(93,5,HERE << "cannot skip an essential down service");
+                what = "down-but-essential ";
+            }
+        }
+
+        debugs(93,5,HERE << "found first matching " <<
+            what << "service for " << r.groupId << " group in rule" << r.id <<
+            ": " << service->cfg().key);
+
+        return service;
+    }
+
+    if (secondBest != NULL) {
+        what = "down ";
+        debugs(93,5,HERE << "found first matching " <<
+            what << "service for " << r.groupId << " group in rule" << r.id <<
+            ": " << secondBest->cfg().key);
+        return secondBest;
+    }
+
+    debugs(93,5,HERE << "found no matching " << 
+        what << "services for " << r.groupId << " group in rule" << r.id);
+    return ServicePointer();
+}
@@ -0,0 +1,66 @@
+#ifndef SQUID_ADAPTATION__ACCESS_CHECK_H
+#define SQUID_ADAPTATION__ACCESS_CHECK_H
+
+#include "ICAP/AsyncJob.h"
+#include "adaptation/Elements.h"
+#include "adaptation/forward.h"
+
+class HttpRequest;
+class HttpReply;
+
+namespace Adaptation {
+
+class AccessRule;
+
+// checks adaptation_access rules to find a matching adaptation service
+class AccessCheck: public virtual AsyncJob
+{
+public:
+    typedef void AccessCheckCallback(ServicePointer match, void *data);
+
+    // use this to start async ACL checks; returns true if started
+    static bool Start(Method method, VectPoint vp, HttpRequest *req, 
+        HttpReply *rep, AccessCheckCallback *cb, void *cbdata);
+
+protected:
+    // use Start to start adaptation checks
+    AccessCheck(Method, VectPoint, HttpRequest *, HttpReply *, AccessCheckCallback *, void *);
+    ~AccessCheck();
+
+private:
+    Method method;
+    VectPoint point;
+    HttpRequest *req;
+    HttpReply *rep;
+    AccessCheckCallback *callback;
+    void *callback_data;
+    ACLChecklist *acl_checklist;
+
+    typedef int Candidate;
+    typedef Vector<Candidate> Candidates;
+    Candidates candidates;
+    Candidate topCandidate() { return *candidates.begin(); }
+
+    void do_callback();
+    ServicePointer findBestService(AccessRule &r, bool preferUp);
+    bool done;
+
+public:
+    void check();
+    void checkCandidates();
+    static void AccessCheckCallbackWrapper(int, void*);
+#if 0
+    static EVH AccessCheckCallbackEvent;
+#endif
+    void noteAnswer(int answer);
+
+//AsyncJob virtual methods
+    virtual bool doneAll() const { return AsyncJob::doneAll() && done;}
+
+private:
+    CBDATA_CLASS2(AccessCheck);
+};
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__ACCESS_CHECK_H */
@@ -0,0 +1,73 @@
+#include "squid.h"
+#include "structs.h"
+
+#include "ConfigParser.h"
+#include "ACL.h"
+#include "adaptation/AccessRule.h"
+#include "adaptation/Service.h"
+#include "adaptation/ServiceGroups.h"
+
+
+int Adaptation::AccessRule::LastId = 0;
+
+Adaptation::AccessRule::AccessRule(): id(++LastId), acl(NULL)
+{
+}
+
+Adaptation::AccessRule::~AccessRule()
+{
+    // XXX: leaking acls here?
+}
+
+void
+Adaptation::AccessRule::parse(ConfigParser &parser)
+{
+    ConfigParser::ParseString(&groupId);
+    aclParseAccessLine(parser, &acl);
+}
+
+void
+Adaptation::AccessRule::finalize()
+{
+    if (!group()) { // no explicit group 
+        debugs(93,7, HERE << "no service group: " << groupId);
+        // try to add a one-service group
+        if (FindService(groupId) != NULL) {
+            ServiceGroup *g = new SingleService(groupId);
+            g->finalize(); // explicit groups were finalized before rules
+            AllGroups().push_back(g);
+        }
+    }
+
+    if (!group()) {
+        debugs(93,0, "ERROR: Unknown adaptation service or group name: '" <<
+            groupId << "'"); // TODO: fail on failures
+    }
+}
+
+Adaptation::ServiceGroup *
+Adaptation::AccessRule::group()
+{
+    return FindGroup(groupId);
+}
+
+
+Adaptation::AccessRules &
+Adaptation::AllRules()
+{
+    static AccessRules TheRules;
+    return TheRules;
+}
+
+// TODO: make AccessRules::find work
+Adaptation::AccessRule *
+Adaptation::FindRule(const AccessRule::Id &id)
+{
+    typedef AccessRules::iterator ARI;
+    for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
+        if ((*i)->id == id)
+            return *i;
+    }
+
+    return NULL;
+}
@@ -0,0 +1,41 @@
+#ifndef SQUID_ADAPTATION__ACCESS_RULE_H
+#define SQUID_ADAPTATION__ACCESS_RULE_H
+
+#include "SquidString.h"
+#include "adaptation/forward.h"
+
+class acl_access;
+class ConfigParser;
+
+namespace Adaptation {
+
+// manages adaptation_access configuration by associating an acl with
+// an adaptation service group
+class AccessRule {
+public:
+    AccessRule();
+    ~AccessRule();
+
+    void parse(ConfigParser &parser);
+    void finalize();
+
+    // service group consisting of one or more services
+    ServiceGroup *group();
+
+public:
+    typedef int Id;
+    const Id id;
+    String groupId;
+    acl_access *acl;
+
+private:
+    static Id LastId;
+};
+
+typedef Vector<Adaptation::AccessRule*> AccessRules;
+extern AccessRules &AllRules();
+extern AccessRule *FindRule(const AccessRule::Id &id);
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__ACCESS_RULE_H */
@@ -0,0 +1,189 @@
+
+/*
+ * $Id: ICAPConfig.cc,v 1.21 2008/02/12 23:12:45 rousskov Exp $
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "structs.h"
+
+#include "ConfigParser.h"
+#include "ACL.h"
+#include "Store.h"
+#include "Array.h"    // really Vector
+#include "adaptation/Config.h"
+#include "adaptation/Service.h"
+#include "adaptation/AccessRule.h"
+#include "adaptation/ServiceGroups.h"
+
+
+bool Adaptation::Config::Enabled = false;
+
+void
+Adaptation::Config::parseService()
+{
+    ServiceConfig *cfg = new ServiceConfig;
+    cfg->parse();
+    serviceConfigs.push_back(cfg);
+}
+
+void
+Adaptation::Config::freeService()
+{
+    while (!serviceConfigs.empty()) {
+        delete serviceConfigs.back();
+        serviceConfigs.pop_back();
+    }
+}
+
+void
+Adaptation::Config::dumpService(StoreEntry *entry, const char *name) const
+{
+    typedef Services::iterator SCI;
+    for (SCI i = AllServices().begin(); i != AllServices().end(); ++i) {
+        const ServiceConfig &cfg = (*i)->cfg();
+        storeAppendPrintf(entry, "%s %s_%s %s %d %s\n", name, cfg.key.buf(),
+            cfg.methodStr(), cfg.vectPointStr(), cfg.bypass, cfg.uri.buf());
+    }
+}
+
+void
+Adaptation::Config::finalize()
+{
+    // create service reps from service configs
+    typedef Vector<ServiceConfig*>::const_iterator VISCI;
+    const Vector<ServiceConfig*> &configs = serviceConfigs;
+    debugs(93,3, "Found " << configs.size() << " service configs.");
+    for (VISCI i = configs.begin(); i != configs.end(); ++i) {
+        ServicePointer s = createService(**i);
+        if (s != NULL)
+            AllServices().push_back(s);
+    }
+
+    debugs(93,3, "Created " << configs.size() <<
+        " message adaptation services.");
+}
+
+// poor man for_each
+template <class Collection>
+static void
+FinalizeEach(Collection &collection, const char *label)
+{
+    typedef typename Collection::iterator CI;
+    for (CI i = collection.begin(); i != collection.end(); ++i)
+        (*i)->finalize();
+
+    debugs(93,2, "Initialized " << collection.size() << ' ' << label);
+}
+
+void
+Adaptation::Config::Finalize(bool enabled)
+{
+    Enabled = enabled;
+    debugs(93,1, "Adaptation support is " << (Enabled ? "on" : "off."));
+
+    FinalizeEach(AllServices(), "message adaptation services");
+    FinalizeEach(AllGroups(), "message adaptation service groups");
+    FinalizeEach(AllRules(), "message adaptation access rules");
+}
+
+void
+Adaptation::Config::ParseServiceSet()
+{
+    ServiceSet *g = new ServiceSet();
+    g->parse();
+    AllGroups().push_back(g);
+}
+
+void
+Adaptation::Config::FreeServiceSet()
+{
+    while (!AllGroups().empty()) {
+        delete AllGroups().back();
+        AllGroups().pop_back();
+    }
+}
+
+void
+Adaptation::Config::DumpServiceSet(StoreEntry *entry, const char *name)
+{
+    typedef Groups::iterator GI;
+    for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i)
+        storeAppendPrintf(entry, "%s %s\n", name, (*i)->id.buf());
+}
+
+void
+Adaptation::Config::ParseAccess(ConfigParser &parser)
+{
+    AccessRule *r = new AccessRule;
+    r->parse(parser);
+    AllRules().push_back(r);
+}
+
+void
+Adaptation::Config::FreeAccess()
+{
+    while (!AllRules().empty()) {
+        delete AllRules().back();
+        AllRules().pop_back();
+    }
+}
+
+void
+Adaptation::Config::DumpAccess(StoreEntry *entry, const char *name)
+{
+    LOCAL_ARRAY(char, nom, 64);
+
+    typedef AccessRules::iterator CI;
+    for (CI i = AllRules().begin(); i != AllRules().end(); ++i) {
+        snprintf(nom, 64, "%s %s", name, (*i)->groupId.buf());
+        dump_acl_access(entry, nom, (*i)->acl);
+    }
+}
+
+Adaptation::Config::Config()
+{
+    // XXX: should we init members?
+}
+
+// XXX: this is called for ICAP and eCAP configs, but deals mostly 
+// with global arrays shared by those individual configs
+Adaptation::Config::~Config()
+{
+    FreeAccess();
+    FreeServiceSet();
+
+    // invalidate each service so that it can be deleted when refcount=0
+    while (!AllServices().empty()) {
+        AllServices().back()->invalidate();
+        AllServices().pop_back();
+    }
+
+    freeService();
+}
@@ -0,0 +1,71 @@
+#ifndef SQUID_ADAPTATION__CONFIG_H
+#define SQUID_ADAPTATION__CONFIG_H
+
+#include "event.h"
+#include "AsyncCall.h"
+#include "adaptation/Elements.h"
+
+class acl_access;
+class ConfigParser;
+
+template <class C>
+class RefCount;
+
+namespace Adaptation {
+
+class Service;
+class ServiceConfig;
+class Class;
+
+typedef RefCount<Service> ServicePointer;
+
+class ServiceGroup;
+class AccessRule;
+
+class Config
+{
+public:
+    static void Finalize(bool enable);
+
+    static void ParseServiceSet(void);
+    static void FreeServiceSet(void);
+    static void DumpServiceSet(StoreEntry *, const char *);
+
+    static void ParseAccess(ConfigParser &parser);
+    static void FreeAccess(void);
+    static void DumpAccess(StoreEntry *, const char *);
+
+    friend class AccessCheck;
+
+public:
+    static bool Enabled; // true if at least one adaptation mechanism is
+
+    int onoff;
+    int send_client_ip;
+    int send_client_username;
+    int service_failure_limit;
+    int service_revival_delay;
+
+    Vector<ServiceConfig*> serviceConfigs;
+
+    Config();
+    virtual ~Config();
+
+    void parseService(void);
+    void freeService(void);
+    void dumpService(StoreEntry *, const char *) const;
+    ServicePointer findService(const String&);
+    Class * findClass(const String& key);
+
+    void finalize();
+
+private:
+    Config(const Config &); // unsupported
+    Config &operator =(const Config &); // unsupported
+
+    virtual ServicePointer createService(const ServiceConfig &cfg) = 0;
+};
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__CONFIG_H */
@@ -0,0 +1,51 @@
+#include "squid.h"
+#include "adaptation/Elements.h"
+
+const char *Adaptation::crlf = "\r\n";
+
+const char *
+Adaptation::methodStr(Adaptation::Method method)
+{
+    switch(method) {
+
+    case Adaptation::methodReqmod:
+        return "REQMOD";
+        break;
+
+    case Adaptation::methodRespmod:
+        return "RESPMOD";
+        break;
+
+    case Adaptation::methodOptions:
+        return "OPTIONS";
+        break;
+
+    default:
+        break;
+    }
+
+    return "NONE";
+}
+
+
+const char *
+Adaptation::vectPointStr(Adaptation::VectPoint point)
+{
+    switch(point) {
+
+    case Adaptation::pointPreCache:
+        return "PRECACHE";
+        break;
+
+    case Adaptation::pointPostCache:
+        return "POSTCACHE";
+        break;
+
+    default:
+        break;
+    }
+
+    return "NONE";
+}
+
+
@@ -0,0 +1,18 @@
+#ifndef SQUID_ADAPTATION__ELEMENTS_H
+#define SQUID_ADAPTATION__ELEMENTS_H
+
+// widely used adaptation primitives
+
+namespace Adaptation
+{
+
+typedef enum { methodNone, methodReqmod, methodRespmod, methodOptions } Method;
+typedef enum { pointNone, pointPreCache, pointPostCache } VectPoint;
+
+extern const char *crlf;
+extern const char *methodStr(Method); // TODO: make into a stream operator?
+extern const char *vectPointStr(VectPoint); // TODO: make into a stream op?
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION_ELEMENTS_H */
@@ -0,0 +1,145 @@
+/*
+ * DEBUG: section 93  ICAP (RFC 3507) Client
+ */
+
+#include "squid.h"
+#include "HttpMsg.h"
+#include "adaptation/Service.h"
+#include "adaptation/Initiator.h"
+#include "adaptation/Initiate.h"
+
+namespace Adaptation {
+
+// AdaptInitiator::noteAdaptionAnswer Dialer locks/unlocks the message in transit
+// TODO: replace HTTPMSGLOCK with general RefCounting and delete this class
+class AnswerDialer: public UnaryMemFunT<Initiator, HttpMsg*>
+{
+public:
+    typedef UnaryMemFunT<Initiator, HttpMsg*> Parent;
+
+    AnswerDialer(Initiator *obj, Parent::Method meth, HttpMsg *msg):
+        Parent(obj, meth, msg) { HTTPMSGLOCK(arg1); }
+    AnswerDialer(const AnswerDialer &d):
+        Parent(d) { HTTPMSGLOCK(arg1); }
+    virtual ~AnswerDialer() { HTTPMSGUNLOCK(arg1); }
+};
+
+} // namespace Adaptation
+
+
+/* Initiate */
+
+Adaptation::Initiate::Initiate(const char *aTypeName,
+    Initiator *anInitiator, ServicePointer aService):
+    AsyncJob(aTypeName), theInitiator(anInitiator), theService(aService)
+{
+    assert(theService != NULL);
+    assert(theInitiator);
+}
+
+Adaptation::Initiate::~Initiate()
+{
+    assert(!theInitiator);
+}
+
+// internal cleanup
+void Adaptation::Initiate::swanSong()
+{
+    debugs(93, 5, HERE << "swan sings" << status());
+
+    if (theInitiator) {
+        debugs(93, 3, HERE << "fatal failure; sending abort notification");
+        tellQueryAborted(true); // final by default
+    }
+
+    debugs(93, 5, HERE << "swan sang" << status());
+}
+
+void Adaptation::Initiate::clearInitiator()
+{
+    if (theInitiator)
+        theInitiator.clear();
+}
+
+void Adaptation::Initiate::sendAnswer(HttpMsg *msg)
+{
+    assert(msg);
+    if (theInitiator.isThere()) {
+        CallJob(93, 5, __FILE__, __LINE__, "Initiator::noteAdaptAnswer",
+            AnswerDialer(theInitiator.ptr(), &Initiator::noteAdaptationAnswer, msg));
+	}        
+    clearInitiator();
+}
+
+
+void Adaptation::Initiate::tellQueryAborted(bool final)
+{
+    if (theInitiator.isThere()) {
+        CallJobHere1(93, 5, theInitiator.ptr(),
+            Initiator::noteAdaptationQueryAbort, final);
+	}
+    clearInitiator();
+}
+
+Adaptation::Service &
+Adaptation::Initiate::service()
+{
+    assert(theService != NULL);
+    return *theService;
+}
+
+const char *Adaptation::Initiate::status() const {
+    return ""; // for now
+}
+
+
+/* InitiatorHolder */
+
+Adaptation::InitiatorHolder::InitiatorHolder(Initiator *anInitiator):
+    prime(0), cbdata(0)
+{
+    if (anInitiator) {
+        cbdata = cbdataReference(anInitiator->toCbdata());
+        prime = anInitiator;
+    }
+}
+
+Adaptation::InitiatorHolder::InitiatorHolder(const InitiatorHolder &anInitiator):
+    prime(0), cbdata(0)
+{
+    if (anInitiator != NULL && cbdataReferenceValid(anInitiator.cbdata)) {
+        cbdata = cbdataReference(anInitiator.cbdata);
+        prime = anInitiator.prime;
+    }
+}
+
+Adaptation::InitiatorHolder::~InitiatorHolder()
+{
+    clear();
+}
+
+void Adaptation::InitiatorHolder::clear() {
+    if (prime) {
+        prime = NULL;
+        cbdataReferenceDone(cbdata);
+    }
+}
+
+Adaptation::Initiator *Adaptation::InitiatorHolder::ptr()
+{
+    assert(isThere());
+    return prime;
+}
+
+bool
+Adaptation::InitiatorHolder::isThere() {
+    return prime && cbdataReferenceValid(cbdata);
+}
+
+// should not be used
+Adaptation::InitiatorHolder &
+Adaptation::InitiatorHolder::operator =(const InitiatorHolder &anInitiator)
+{
+    assert(false);
+    return *this;
+}
@@ -0,0 +1,79 @@
+#ifndef SQUID_ADAPTATION__INITIATE_H
+#define SQUID_ADAPTATION__INITIATE_H
+
+#include "AsyncCall.h"
+#include "ICAP/AsyncJob.h"
+#include "adaptation/forward.h"
+
+class HttpMsg;
+
+namespace Adaptation {
+
+/* Initiator holder associtates an initiator with its cbdata. It is used as
+ * a temporary hack to make cbdata work with multiple inheritance. We need
+ * this hack because we cannot know whether the initiator pointer is still
+ * valid without dereferencing it to call toCbdata() 
+ * TODO: JobDialer uses the same trick. Factor out or move this code. */
+class InitiatorHolder {
+public:
+    InitiatorHolder(Initiator *anInitiator);
+    InitiatorHolder(const InitiatorHolder &anInitiator);
+    ~InitiatorHolder();
+
+    void clear();
+
+    // to make comparison with NULL possible
+    operator void*() { return prime; }
+    bool operator == (void *) const { return prime == NULL; }
+    bool operator != (void *) const { return prime != NULL; }
+    bool operator !() const { return !prime; }
+
+    bool isThere(); // we have a valid initiator pointer
+    Initiator *ptr(); // asserts isThere()
+
+private:
+    InitiatorHolder &operator =(const InitiatorHolder &anInitiator);
+
+    Initiator *prime;
+    void *cbdata;
+};
+
+/*
+ * The  Initiate is a common base for  queries or transactions
+ * initiated by an Initiator. This interface exists to allow an 
+ * initiator to signal its "initiatees" that it is aborting and no longer
+ * expecting an answer. The class is also handy for implementing common
+ * initiate actions such as maintaining and notifying the initiator.
+ *
+ * Initiate implementations must cbdata-protect themselves.
+ *
+ * This class could have been named Initiatee.
+ */
+class Initiate: virtual public AsyncJob
+{
+
+public:
+    Initiate(const char *aTypeName, Initiator *anInitiator, ServicePointer aService);
+    virtual ~Initiate();
+
+    // communication with the initiator
+    virtual void noteInitiatorAborted() = 0;
+
+protected:
+    Service &service();
+
+    void sendAnswer(HttpMsg *msg); // send to the initiator
+    void tellQueryAborted(bool final); // tell initiator
+    void clearInitiator(); // used by noteInitiatorAborted; TODO: make private
+
+    virtual void swanSong(); // internal cleanup
+
+    virtual const char *status() const; // for debugging
+
+    InitiatorHolder theInitiator;
+    ServicePointer theService;
+};
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__INITIATE_H */
@@ -0,0 +1,31 @@
+/*
+ * DEBUG: section 93  ICAP (RFC 3507) Client
+ */
+
+#include "squid.h"
+#include "adaptation/Initiate.h"
+#include "adaptation/Initiator.h"
+
+Adaptation::Initiate *
+Adaptation::Initiator::initiateAdaptation(Adaptation::Initiate *x)
+{
+    if ((x = dynamic_cast<Initiate*>(Initiate::AsyncStart(x))))
+        x = cbdataReference(x);
+    return x;
+}
+
+void
+Adaptation::Initiator::clearAdaptation(Initiate *&x)
+{
+    assert(x);
+    cbdataReferenceDone(x);
+}
+
+void
+Adaptation::Initiator::announceInitiatorAbort(Initiate *&x)
+{
+    if (x) {
+        CallJobHere(93, 5, x, Initiate::noteInitiatorAborted);
+        clearAdaptation(x);
+    }
+}
@@ -0,0 +1,45 @@
+#ifndef SQUID_ADAPTATION__INITIATOR_H
+#define SQUID_ADAPTATION__INITIATOR_H
+
+#include "ICAP/AsyncJob.h"
+#include "adaptation/forward.h"
+
+/*
+ * The ICAP Initiator is an ICAP vectoring point that initates ICAP
+ * transactions. This interface exists to allow ICAP transactions to
+ * signal their initiators that they have the answer from the ICAP server
+ * or that the ICAP query has aborted and there will be no answer. It
+ * is also handy for implementing common initiator actions such as starting
+ * or aborting an ICAP transaction.
+ */
+
+class HttpMsg;
+
+namespace Adaptation {
+
+class Initiator: virtual public AsyncJob
+{
+public:
+    Initiator(): AsyncJob("Initiator") {}
+    virtual ~Initiator() {}
+
+    // called when ICAP response headers are successfully interpreted
+    virtual void noteAdaptationAnswer(HttpMsg *message) = 0;
+
+    // called when valid ICAP response headers are no longer expected
+    // the final parameter is set to disable bypass or retries
+    virtual void noteAdaptationQueryAbort(bool final) = 0;
+
+protected:
+    Initiate *initiateAdaptation(Initiate *x); // locks and returns x
+
+    // done with x (and not calling announceInitiatorAbort)
+    void clearAdaptation(Initiate *&x); // unlocks x
+
+    // inform the transaction about abnormal termination and clear it
+    void announceInitiatorAbort(Initiate *&x); // unlocks x
+};
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__INITIATOR_H */
@@ -0,0 +1,36 @@
+AM_CFLAGS = @SQUID_CFLAGS@
+AM_CXXFLAGS = @SQUID_CXXFLAGS@
+
+INCLUDES = \
+	-I$(top_builddir)/include \
+	-I$(top_srcdir)/include \
+        -I$(top_srcdir)/src
+
+noinst_LTLIBRARIES = libadaptation.la
+
+libadaptation_la_SOURCES = \
+	AccessCheck.cc \
+	AccessCheck.h \
+	AccessRule.cc \
+	AccessRule.h \
+	Config.cc \
+	Config.h \
+	Elements.cc \
+	Elements.h \
+	forward.h \
+	Initiate.cc \
+	Initiate.h \
+	Initiator.cc \
+	Initiator.h \
+	Service.cc \
+	Service.h \
+	ServiceConfig.cc \
+	ServiceConfig.h \
+	ServiceGroups.cc \
+	ServiceGroups.h
+
+check_PROGRAMS = testHeaders
+
+## test .h correctness
+testHeaders: *.h
+	$(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "." || exit 1
@@ -0,0 +1,37 @@
+/*
+ * DEBUG: section XXX
+ */
+
+#include "squid.h"
+#include "adaptation/Service.h"
+
+Adaptation::Service::Service(const ServiceConfig &aConfig): theConfig(aConfig)
+{
+    debugs(93,3, HERE << "creating adaptation service " << theConfig.key);
+}
+
+Adaptation::Service::~Service()
+{}
+
+void
+Adaptation::Service::finalize()
+{
+}
+
+Adaptation::Services &
+Adaptation::AllServices()
+{
+    static Services TheServices;
+    return TheServices;
+}
+
+Adaptation::ServicePointer
+Adaptation::FindService(const Service::Id& key)
+{
+    typedef Services::iterator SI;
+    for (SI i = AllServices().begin(); i != AllServices().end(); ++i) {
+        if ((*i)->cfg().key == key)
+            return *i;
+	}
+    return NULL;
+}
@@ -0,0 +1,66 @@
+#ifndef SQUID_ADAPTATION__SERVICE_H
+#define SQUID_ADAPTATION__SERVICE_H
+
+#include "SquidString.h"
+#include "RefCount.h"
+#include "adaptation/forward.h"
+#include "adaptation/Elements.h"
+#include "adaptation/ServiceConfig.h"
+
+// TODO: Move src/ICAP/ICAPServiceRep.h API comments here and update them
+
+class HttpMsg;
+class HttpRequest;
+
+namespace Adaptation {
+
+// manages adaptation service configuration in squid.conf
+// specific adaptation mechanisms extend this class
+class Service: public RefCountable
+{
+public:
+    typedef RefCount<Service> Pointer;
+    typedef String Id;
+
+public:
+    Service(const ServiceConfig &aConfig);
+    virtual ~Service();
+
+    // call when the service is no longer needed or valid
+    virtual void invalidate() = 0;
+
+    virtual bool probed() const = 0; // see comments above
+    virtual bool broken() const = 0; // see comments above
+    virtual bool up() const = 0; // see comments above
+
+    virtual Initiate *makeXactLauncher(Initiator *, HttpMsg *virginHeader, HttpRequest *virginCause) = 0;
+
+    typedef void Callback(void *data, Pointer &service);
+    void callWhenReady(Callback *cb, void *data);
+
+    // the methods below can only be called on an up() service
+    virtual bool wantsUrl(const String &urlPath) const = 0;
+
+    // called by transactions to report service failure
+    virtual void noteFailure() = 0;
+
+    const ServiceConfig &cfg() const { return theConfig; }
+
+    virtual void finalize(); // called after creation
+
+protected:
+    ServiceConfig &writeableCfg() { return theConfig; }
+
+private:
+    ServiceConfig theConfig;
+};
+
+typedef Service::Pointer ServicePointer;
+
+typedef Vector<Adaptation::ServicePointer> Services;
+extern Services &AllServices();
+extern ServicePointer FindService(const Service::Id &key);
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__SERVICE_H */
@@ -0,0 +1,147 @@
+/*
+ * DEBUG: section XXX
+ */
+
+#include "squid.h"
+#include "ConfigParser.h"
+#include "adaptation/ServiceConfig.h"
+
+Adaptation::ServiceConfig::ServiceConfig(): 
+    port(-1), method(methodNone), point(pointNone), bypass(false)
+{}
+
+const char *
+Adaptation::ServiceConfig::methodStr() const
+{
+    return Adaptation::methodStr(method);
+}
+
+const char *
+Adaptation::ServiceConfig::vectPointStr() const
+{
+    return Adaptation::vectPointStr(point);
+}
+
+Adaptation::Method
+Adaptation::ServiceConfig::parseMethod(const char *str) const
+{
+    if (!strncasecmp(str, "REQMOD", 6))
+        return Adaptation::methodReqmod;
+
+    if (!strncasecmp(str, "RESPMOD", 7))
+        return Adaptation::methodRespmod;
+
+    return Adaptation::methodNone;
+}
+
+Adaptation::VectPoint
+Adaptation::ServiceConfig::parseVectPoint(const char *service_configConfig) const
+{
+    const char *t = service_configConfig;
+    const char *q = strchr(t, '_');
+
+    if (q)
+        t = q + 1;
+
+    if (!strcasecmp(t, "precache"))
+        return Adaptation::pointPreCache;
+
+    if (!strcasecmp(t, "postcache"))
+        return Adaptation::pointPostCache;
+
+    return Adaptation::pointNone;
+}
+
+bool
+Adaptation::ServiceConfig::parse()
+{
+    char *method_point = NULL;
+
+    ConfigParser::ParseString(&key);
+    ConfigParser::ParseString(&method_point);
+    ConfigParser::ParseBool(&bypass);
+    ConfigParser::ParseString(&uri);
+
+    debugs(3, 5, HERE << cfg_filename << ':' << config_lineno << ": " <<
+        key.buf() << " " << method_point << " " << bypass);
+
+    method = parseMethod(method_point);
+    point = parseVectPoint(method_point);
+
+    debugs(3, 5, HERE << cfg_filename << ':' << config_lineno << ": " <<
+        "service_configConfig is " << methodStr() << "_" << vectPointStr());
+
+    // TODO: find core code that parses URLs and extracts various parts
+
+    // extract scheme and use it as the service_configConfig protocol
+    const char *schemeSuffix = "://";
+    if (const char *schemeEnd = uri.pos(schemeSuffix))
+		protocol.limitInit(uri.buf(), schemeEnd - uri.buf());
+	debugs(3, 5, HERE << cfg_filename << ':' << config_lineno << ": " <<
+		"service protocol is " << protocol);
+	if (!protocol.size())
+		return false;
+
+    // skip scheme
+    const char *s = uri.buf() + protocol.size() + strlen(schemeSuffix);
+
+    const char *e;
+
+    bool have_port = false;
+
+    if ((e = strchr(s, ':')) != NULL) {
+        have_port = true;
+    } else if ((e = strchr(s, '/')) != NULL) {
+        have_port = false;
+    } else {
+        return false;
+    }
+
+    int len = e - s;
+    host.limitInit(s, len);
+    s = e;
+
+	port = -1;
+    if (have_port) {
+        s++;
+
+        if ((e = strchr(s, '/')) != NULL) {
+            char *t;
+			const unsigned long p = strtoul(s, &t, 0);
+
+			if (p > 65535) // port value is too high
+				return false;
+
+            port = static_cast<int>(p);
+
+            if (t != e) // extras after the port
+                return false;
+
+            s = e;
+
+            if (s[0] != '/')
+                return false;
+        }
+    }
+
+    // if no port, the caller may use service_configConfigs or supply the default if neeeded
+
+    s++;
+    e = strchr(s, '\0');
+    len = e - s;
+
+    if (len > 1024) {
+        debugs(3, 0, HERE << cfg_filename << ':' << config_lineno << ": " <<
+            "long resource name (>1024), probably wrong");
+    }
+
+    resource.limitInit(s, len + 1);
+
+    if ((bypass != 0) && (bypass != 1)) {
+        debugs(3, 0, HERE << cfg_filename << ':' << config_lineno << ": " <<
+            "wrong bypass value; 0 or 1 expected: " << bypass);
+        return false;
+    }
+
+    return true;
+}
@@ -0,0 +1,42 @@
+#ifndef SQUID_ADAPTATION__SERVICE_CONFIG_H
+#define SQUID_ADAPTATION__SERVICE_CONFIG_H
+
+#include "SquidString.h"
+#include "RefCount.h"
+#include "adaptation/Elements.h"
+
+namespace Adaptation {
+
+// manages adaptation service configuration in squid.conf
+class ServiceConfig
+{
+public:
+    ServiceConfig();
+
+    const char *methodStr() const;
+    const char *vectPointStr() const;
+
+    bool parse();
+
+public:
+    String key;    // service_configConfig name in the configuration file
+    String uri;    // service_configConfig URI
+
+    // service_configConfig URI components
+    String protocol;
+    String host;
+    String resource;
+    int port;
+
+    Method method;   // what is being adapted (REQMOD vs RESPMOD)
+    VectPoint point; // where the adaptation happens (pre- or post-cache)
+    bool bypass;
+
+protected:
+    Method parseMethod(const char *buf) const;
+    VectPoint parseVectPoint(const char *buf) const;
+};
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__SERVICE_CONFIG_H */
@@ -0,0 +1,104 @@
+#include "squid.h"
+
+#include "ConfigParser.h"
+#include "Array.h"      // really Vector
+#include "adaptation/Config.h"
+#include "adaptation/AccessRule.h"
+#include "adaptation/Service.h"
+#include "adaptation/ServiceGroups.h"
+
+
+Adaptation::ServiceGroup::ServiceGroup(const String &aKind): kind(aKind)
+{
+}
+
+Adaptation::ServiceGroup::~ServiceGroup()
+{
+}
+
+void
+Adaptation::ServiceGroup::parse()
+{
+    ConfigParser::ParseString(&id);
+
+    wordlist *names = NULL;
+    ConfigParser::ParseWordList(&names);
+    for (wordlist *i = names; i; i = i->next)
+        services.push_back(i->key);
+    wordlistDestroy(&names);
+}
+
+void
+Adaptation::ServiceGroup::finalize()
+{
+    for (iterator i = services.begin(); i != services.end(); ++i) {
+        const String &id = *i;
+        // TODO: fail on failures
+        if (!FindService(id))
+            debugs(93,0, "ERROR: Unknown adaptation name: " << id);
+	}
+    debugs(93,7, HERE << "finalized " << kind << ": " << id);
+}
+
+/* ServiceSet */
+
+Adaptation::ServiceSet::ServiceSet(): ServiceGroup("adaptation set")
+{
+}
+
+Adaptation::ServiceGroup::Loop Adaptation::ServiceSet::initialServices()
+{
+    return Loop(services.begin(), services.end());
+}
+
+#if FUTURE_OPTIMIZATION
+void
+Adaptation::ServiceSet::finalize()
+{
+    ServiceGroup::finalize();
+
+    for (wordlist *iter = service_names; iter; iter = iter->next) {
+        ServicePointer match = Config::FindService(iter->id);
+        if (match != NULL)
+            services += match;
+    }
+}
+#endif
+
+
+/* SingleService */
+
+Adaptation::SingleService::SingleService(const String &aServiceId):
+    ServiceGroup("single-service group")
+{
+    id = aServiceId;
+    services.push_back(aServiceId);
+}
+
+Adaptation::ServiceGroup::Loop
+Adaptation::SingleService::initialServices()
+{
+    return Loop(services.begin(), services.end()); // there should be only one
+}
+
+
+/* globals */
+
+Adaptation::Groups &
+Adaptation::AllGroups()
+{
+    static Groups TheGroups;
+    return TheGroups;
+}
+
+Adaptation::ServiceGroup *
+Adaptation::FindGroup(const ServiceGroup::Id &id)
+{
+    typedef Groups::iterator GI;
+    for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i) {
+        if ((*i)->id == id)
+            return *i;
+    }
+
+    return NULL;
+}
@@ -0,0 +1,72 @@
+#ifndef SQUID_ADAPTATION__SERVICE_GROUPS_H
+#define SQUID_ADAPTATION__SERVICE_GROUPS_H
+
+#include "SquidString.h"
+#include "Array.h"
+#include "adaptation/forward.h"
+
+namespace Adaptation {
+
+// Interface for grouping adaptation services together.
+// Specific groups differ in how the first and the next services are selected
+class ServiceGroup
+{
+public:
+    typedef Vector<String> Store;
+    typedef Store::iterator iterator;
+    typedef String Id;
+
+    // Information sufficient to iterate services stored in the group,
+    // grouped together to simplify initial/sequentialServices interfaces.
+    // The iterators point back to 
+    struct Loop {
+        Loop(const iterator &b, const iterator &e): begin(b), end(e) {}
+        iterator begin;
+        iterator end;
+    };
+
+public:
+    ServiceGroup(const String &aKind);
+    virtual ~ServiceGroup();
+
+    virtual void parse();
+    virtual void finalize(); // called after all are parsed
+
+    virtual Loop initialServices() = 0;
+    // TODO: virtual Loop sequentialServices() = 0;
+
+public:
+    String kind;
+    Id id;
+    Store services;
+};
+
+// a group of equivalent services; one service per set is usually used
+class ServiceSet: public ServiceGroup
+{
+public:
+    ServiceSet();
+    virtual Loop initialServices();
+};
+
+// corner case: a group consisting of one service
+class SingleService: public ServiceGroup
+{
+public:
+    SingleService(const String &aServiceKey);
+    virtual Loop initialServices();
+};
+
+// TODO: a group of services that must be used one after another
+// class ServiceChain: public ServiceGroup
+
+
+typedef Vector<Adaptation::ServiceGroup*> Groups;
+extern Groups &AllGroups();
+extern ServiceGroup *FindGroup(const ServiceGroup::Id &id);
+
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__SERVICE_GROUPS_H */
+
@@ -0,0 +1,29 @@
+#ifndef SQUID_ADAPTATION__FORWARD_H
+#define SQUID_ADAPTATION__FORWARD_H
+
+// forward-declarations for commonly used adaptation classes
+
+template <class C>
+class RefCount;
+
+// For various collections such as AllServices
+// TODO: use std::hash_map<> instead
+template <class Item>
+class Vector;
+
+namespace Adaptation {
+
+class Service;
+class ServiceConfig;
+class Class;
+class Initiate;
+class Initiator;
+class AccessCheck;
+class AccessRule;
+class ServiceGroup;
+
+typedef RefCount<Service> ServicePointer;
+
+} // namespace Adaptation
+
+#endif /* SQUID_ADAPTATION__FORWARD_H */
@@ -59,6 +59,17 @@
 #include "ESIParser.h"
 #endif
 
+#if USE_ADAPTATION
+#include "adaptation/Config.h"
+
+static void parse_adaptation_service_set_type();
+
+static void parse_adaptation_access_type();
+static void dump_adaptation_access_type(StoreEntry *, const char *);
+static void free_adaptation_access_type();
+
+#endif
+
 #if ICAP_CLIENT
 #include "ICAP/ICAPConfig.h"
 
@@ -3421,60 +3432,93 @@ free_access_log(customlog ** definitions)
     }
 }
 
+#if USE_ADAPTATION
+
+static void
+parse_adaptation_service_set_type()
+{
+    Adaptation::Config::ParseServiceSet();
+}
+
+static void
+parse_adaptation_access_type()
+{
+    Adaptation::Config::ParseAccess(LegacyParser);
+}
+
+static void
+free_adaptation_access_type()
+{
+    Adaptation::Config::FreeAccess();
+}
+
+static void
+dump_adaptation_access_type(StoreEntry * entry, const char *name)
+{
+    Adaptation::Config::DumpAccess(entry, name);
+}
+
+#endif /* USE_ADAPTATION */
+
+
 #if ICAP_CLIENT
 
 static void
 parse_icap_service_type(ICAPConfig * cfg)
 {
-    cfg->parseICAPService();
+    cfg->parseService();
 }
 
 static void
 free_icap_service_type(ICAPConfig * cfg)
 {
-    cfg->freeICAPService();
+    cfg->freeService();
 }
 
 static void
 dump_icap_service_type(StoreEntry * entry, const char *name, const ICAPConfig &cfg)
 {
-    cfg.dumpICAPService(entry, name);
+    cfg.dumpService(entry, name);
 }
 
 static void
-parse_icap_class_type(ICAPConfig * cfg)
+parse_icap_class_type(ICAPConfig *)
 {
-    cfg->parseICAPClass();
+    debugs(93, 0, "WARNING: 'icap_class' is depricated. " <<
+        "Use 'adaptation_service_set' instead");
+    Adaptation::Config::ParseServiceSet();
 }
 
 static void
-free_icap_class_type(ICAPConfig * cfg)
+free_icap_class_type(ICAPConfig *)
 {
-    cfg->freeICAPClass();
+    Adaptation::Config::FreeServiceSet();
 }
 
 static void
-dump_icap_class_type(StoreEntry * entry, const char *name, const ICAPConfig &cfg)
+dump_icap_class_type(StoreEntry * entry, const char *name, const ICAPConfig &)
 {
-    cfg.dumpICAPClass(entry, name);
+    Adaptation::Config::DumpServiceSet(entry, name);
 }
 
 static void
-parse_icap_access_type(ICAPConfig * cfg)
+parse_icap_access_type(ICAPConfig *)
 {
-    cfg->parseICAPAccess(LegacyParser);
+    debugs(93, 0, "WARNING: 'icap_access' is depricated. " <<
+        "Use 'adaptation_access' instead");
+    parse_adaptation_access_type();
 }
 
 static void
-free_icap_access_type(ICAPConfig * cfg)
+free_icap_access_type(ICAPConfig *)
 {
-    cfg->freeICAPAccess();
+    free_adaptation_access_type();
 }
 
 static void
-dump_icap_access_type(StoreEntry * entry, const char *name, const ICAPConfig &cfg)
+dump_icap_access_type(StoreEntry * entry, const char *name, const ICAPConfig &)
 {
-    cfg.dumpICAPAccess(entry, name);
+    dump_adaptation_access_type(entry, name);
 }
 
 #endif
@@ -25,6 +25,8 @@ http_header_access
 http_header_replace
 http_port_list
 https_port_list
+adaptation_access_type	adaptation_service_set acl icap_service icap_class
+adaptation_service_set_type	icap_service
 icap_access_type	icap_class acl
 icap_class_type		icap_service
 icap_service_type
@@ -5007,16 +5007,15 @@ IFDEF: ICAP_CLIENT
 LOC: TheICAPConfig
 DEFAULT: none
 DOC_START
-	Defines an ICAP service chain. Eventually, multiple services per
-	vectoring point will be supported. For now, please specify a single
-	service per class:
+	This depricated option was documented to define an ICAP service
+	chain, even though it actually defined a set of similar, redundant
+	services, and the chains were not supported. 
 
-	icap_class classname servicename
+	To define a set of redundant services, please use the
+	adaptation_service_set directive.
 
-Example:
-icap_class class_1 service_1
-icap class class_2 service_1
-icap class class_3 service_3
+	If you need adaptation service chains, patches or sponsorship
+	is welcome.
 DOC_END
 
 NAME: icap_access
@@ -5025,21 +5024,95 @@ IFDEF: ICAP_CLIENT
 LOC: TheICAPConfig
 DEFAULT: none
 DOC_START
-	Redirects a request through an ICAP service class, depending
-	on given acls
+        This option is depricated. Please use adaptation_access, which
+	has the same ICAP functionality, but comes with better
+	documentation, and eCAP support.
+DOC_END
+
+COMMENT_START
+ eCAP OPTIONS
+ -----------------------------------------------------------------------------
+COMMENT_END
+
+NAME: loadable_modules
+TYPE: wordlist
+IFDEF: USE_LOADABLE_MODULES
+LOC: Config.loadable_module_names
+DEFAULT: none
+DOC_START
+	Instructs Squid to load the specified dynamic module(s) or activate
+	preloaded module(s).
+Example:
+loadable_modules @DEFAULT_PREFIX@/lib/MinimalAdapter.so
+DOC_END
+
+COMMENT_START
+ MESSAGE ADAPTATION OPTIONS
+ -----------------------------------------------------------------------------
+COMMENT_END
+
+NAME: adaptation_service_set
+TYPE: adaptation_service_set_type
+IFDEF: USE_ADAPTATION
+LOC: none
+DEFAULT: none
+DOC_START
+
+	Defines a named adaptation service set. The set is populated in
+	the order of adaptation_service_set directives in this file.
+	When adaptation ACLs are processed, the first and only the first
+	applicable adaptation service from the set will be used. Thus,
+	the set should group similar, redundant services, rather than a
+	chain of complementary services.
+
+	If you have a single adaptation service, you do not need to
+	define a set containing it because adaptation_access accepts
+	service names.
+
+	See also: adaptation_access
+
+Example:
+adaptation_service_set svcBlocker urlFilterPrimary urlFilterBackup
+adaptation service_set svcLogger loggerLocal loggerRemote
+DOC_END
+
+NAME: adaptation_access
+TYPE: adaptation_access_type
+IFDEF: USE_ADAPTATION
+LOC: none
+DEFAULT: none
+DOC_START
+	Sends an HTTP transaction to an ICAP or eCAP adaptation	service.
+
+	adaptation_access service_name allow|deny [!]aclname...
+	adaptation_access set_name     allow|deny [!]aclname...
+
+	At each supported vectoring point, the adaptation_access
+	statements are processed in the order they appear in this
+	configuration file. Statements pointing to the following services
+	are ignored (i.e., skipped without checking their ACL):
+
+	    - services serving different vectoring points
+	    - "broken-but-bypassable" services
+	    - "up" services configured to ignore such transactions
+              (e.g., based on the ICAP Transfer-Ignore header).
+
+        When a set_name is used, all services in the set are checked
+	using the same rules, to find the first applicable one. See
+	adaptation_service_set for details.
+
+	If an access list is checked and there is a match, the
+	processing stops: For an "allow" rule, the corresponding
+	adaptation service is used for the transaction. For a "deny"
+	rule, no adaptation service is activated.
 
-	icap_access classname allow|deny [!]aclname...
+	It is currently not possible to apply more than one adaptation
+	service at the same vectoring point to the same HTTP transaction.
 
-	The icap_access statements are processed in the order they appear in
-	this configuration file. If an access list matches, the processing stops.
-	For an "allow" rule, the specified class is used for the request. A "deny"
-	rule simply stops processing without using the class. You can also use the
-	special classname "None".
+        See also: icap_service and ecap_service
 
-	For backward compatibility, it is also possible to use services
-	directly here.
 Example:
-icap_access class_1 allow all
+adaptation_access service_1 allow all
 DOC_END
 
 COMMENT_START
@@ -59,12 +59,10 @@
 #include "SquidTime.h"
 #include "wordlist.h"
 
-#if ICAP_CLIENT
-#include "ICAP/ICAPModXact.h"
-#include "ICAP/ICAPElements.h"
-#include "ICAP/ICAPConfig.h"
-static void icapAclCheckDoneWrapper(ICAPServiceRep::Pointer service, void *data);
-extern ICAPConfig TheICAPConfig;
+#if USE_ADAPTATION
+#include "adaptation/AccessCheck.h"
+#include "adaptation/Service.h"
+static void adaptationAclCheckDoneWrapper(Adaptation::ServicePointer service, void *data);
 #endif
 
 #if LINGERING_CLOSE
@@ -144,15 +142,15 @@ ClientHttpRequest::operator delete (void *address)
 }
 
 ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) : 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 AsyncJob("ClientHttpRequest"),
 #endif
 loggingEntry_(NULL)
 {
     start_time = current_time;
     setConn(aConn);
     dlinkAdd(this, &active, &ClientActiveRequests);
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     request_satisfaction_mode = false;
 #endif
 }
@@ -255,11 +253,11 @@ ClientHttpRequest::~ClientHttpRequest()
 
     freeResources();
 
-#if ICAP_CLIENT
-    announceInitiatorAbort(icapHeadSource);
+#if USE_ADAPTATION
+    announceInitiatorAbort(virginHeadSource);
 
-    if (icapBodySource != NULL)
-        stopConsumingFrom(icapBodySource);
+    if (adaptedBodySource != NULL)
+        stopConsumingFrom(adaptedBodySource);
 #endif
 
     if (calloutContext)
@@ -483,51 +481,36 @@ ClientRequestContext::clientAccessCheckDone(int answer)
     http->doCallouts();
 }
 
-#if ICAP_CLIENT
-void
-ClientRequestContext::icapAccessCheck()
-{
-    ICAPAccessCheck *icap_access_check;
-
-    icap_access_check = new ICAPAccessCheck(ICAP::methodReqmod, ICAP::pointPreCache, http->request, NULL, icapAclCheckDoneWrapper, this);
-
-    if (icap_access_check != NULL) {
-        icap_access_check->check();
-        return;
-    }
-
-    http->doCallouts();
-}
-
+#if USE_ADAPTATION
 static void
-icapAclCheckDoneWrapper(ICAPServiceRep::Pointer service, void *data)
+adaptationAclCheckDoneWrapper(Adaptation::ServicePointer service, void *data)
 {
     ClientRequestContext *calloutContext = (ClientRequestContext *)data;
 
     if (!calloutContext->httpStateIsValid())
         return;
 
-    calloutContext->icapAclCheckDone(service);
+    calloutContext->adaptationAclCheckDone(service);
 }
 
 void
-ClientRequestContext::icapAclCheckDone(ICAPServiceRep::Pointer service)
+ClientRequestContext::adaptationAclCheckDone(Adaptation::ServicePointer service)
 {
-    debugs(93,3,HERE << this << " icapAclCheckDone called");
+    debugs(93,3,HERE << this << " adaptationAclCheckDone called");
     assert(http);
 
-    if (http->startIcap(service))
+    if (http->startAdaptation(service))
         return;
 
-    if (!service || service->bypass) {
+    if (!service || service->cfg().bypass) {
         // handle ICAP start failure when no service was selected
         // or where the selected service was optional
         http->doCallouts();
         return;
     }
 
     // handle start failure for an essential ICAP service
-    http->handleIcapFailure();
+    http->handleAdaptationFailure();
 }
 
 #endif
@@ -1069,14 +1052,14 @@ ClientHttpRequest::doCallouts()
         return;
     }
 
-#if ICAP_CLIENT
-    if (TheICAPConfig.onoff && !calloutContext->icap_acl_check_done) {
-        debugs(83, 3, HERE << "Doing calloutContext->icapAccessCheck()");
-        calloutContext->icap_acl_check_done = true;
-        calloutContext->icapAccessCheck();
-        return;
+#if USE_ADAPTATION
+    if (!calloutContext->adaptation_acl_check_done) {
+        calloutContext->adaptation_acl_check_done = true;
+        if (Adaptation::AccessCheck::Start(
+            Adaptation::methodReqmod, Adaptation::pointPreCache,
+            request, NULL, adaptationAclCheckDoneWrapper, calloutContext))
+            return; // will call callback
     }
-
 #endif
 
     if (!calloutContext->redirect_done) {
@@ -1136,33 +1119,34 @@ ClientHttpRequest::doCallouts()
 #include "client_side_request.cci"
 #endif
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 /*
  * Initiate an ICAP transaction.  Return false on errors. 
  * The caller must handle errors.
  */
 bool
-ClientHttpRequest::startIcap(ICAPServiceRep::Pointer service)
+ClientHttpRequest::startAdaptation(Adaptation::ServicePointer service)
 {
-    debugs(85, 3, HERE << this << " ClientHttpRequest::startIcap() called");
+    debugs(85, 3, HERE << this << " ClientHttpRequest::startAdaptation() called");
     if (!service) {
-        debugs(85, 3, "ClientHttpRequest::startIcap fails: lack of service");
+        debugs(85, 3, "ClientHttpRequest::startAdaptation fails: lack of service");
         return false;
     }
     if (service->broken()) {
-        debugs(85, 3, "ClientHttpRequest::startIcap fails: broken service");
+        debugs(85, 3, "ClientHttpRequest::startAdaptation fails: broken service");
         return false;
     }
 
-    assert(!icapHeadSource);
-    assert(!icapBodySource);
-    icapHeadSource = initiateIcap(
-        new ICAPModXactLauncher(this, request, NULL, service));
-    return icapHeadSource != NULL;
+    assert(!virginHeadSource);
+    assert(!adaptedBodySource);
+    virginHeadSource = initiateAdaptation(service->makeXactLauncher(
+        this, request, NULL));
+
+    return virginHeadSource != NULL;
 }
 
 void
-ClientHttpRequest::noteIcapAnswer(HttpMsg *msg)
+ClientHttpRequest::noteAdaptationAnswer(HttpMsg *msg)
 {
     assert(cbdataReferenceValid(this));		// indicates bug
     assert(msg);
@@ -1185,8 +1169,8 @@ ClientHttpRequest::noteIcapAnswer(HttpMsg *msg)
 
         // subscribe to receive reply body
         if (new_rep->body_pipe != NULL) {
-            icapBodySource = new_rep->body_pipe;
-            assert(icapBodySource->setConsumerIfNotLate(this));
+            adaptedBodySource = new_rep->body_pipe;
+            assert(adaptedBodySource->setConsumerIfNotLate(this));
         }
 
         clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
@@ -1198,34 +1182,34 @@ ClientHttpRequest::noteIcapAnswer(HttpMsg *msg)
         request_satisfaction_offset = 0;
         storeEntry()->replaceHttpReply(new_rep);
 
-        if (!icapBodySource) // no body
+        if (!adaptedBodySource) // no body
             storeEntry()->complete();
         clientGetMoreData(node, this);
     }
 
     // we are done with getting headers (but may be receiving body)
-    clearIcap(icapHeadSource);
+    clearAdaptation(virginHeadSource);
 
     if (!request_satisfaction_mode)
         doCallouts();
 }
 
 void
-ClientHttpRequest::noteIcapQueryAbort(bool final)
+ClientHttpRequest::noteAdaptationQueryAbort(bool final)
 {
-    clearIcap(icapHeadSource);
-    assert(!icapBodySource);
-    handleIcapFailure(!final);
+    clearAdaptation(virginHeadSource);
+    assert(!adaptedBodySource);
+    handleAdaptationFailure(!final);
 }
 
 void
 ClientHttpRequest::noteMoreBodyDataAvailable(BodyPipe::Pointer)
 {
     assert(request_satisfaction_mode);
-    assert(icapBodySource != NULL);
+    assert(adaptedBodySource != NULL);
 
-    if (const size_t contentSize = icapBodySource->buf().contentSize()) {
-        BodyPipeCheckout bpc(*icapBodySource);
+    if (const size_t contentSize = adaptedBodySource->buf().contentSize()) {
+        BodyPipeCheckout bpc(*adaptedBodySource);
         const StoreIOBuffer ioBuf(&bpc.buf, request_satisfaction_offset);
         storeEntry()->write(ioBuf);
         // assume can write everything
@@ -1234,20 +1218,20 @@ ClientHttpRequest::noteMoreBodyDataAvailable(BodyPipe::Pointer)
         bpc.checkIn();
     }
 
-    if (icapBodySource->exhausted())
+    if (adaptedBodySource->exhausted())
         endRequestSatisfaction();
     // else wait for more body data
 }
 
 void
 ClientHttpRequest::noteBodyProductionEnded(BodyPipe::Pointer)
 {
-    assert(!icapHeadSource);
-    if (icapBodySource != NULL) { // did not end request satisfaction yet
+    assert(!virginHeadSource);
+    if (adaptedBodySource != NULL) { // did not end request satisfaction yet
         // We do not expect more because noteMoreBodyDataAvailable always 
         // consumes everything. We do not even have a mechanism to consume
         // leftovers after noteMoreBodyDataAvailable notifications seize.
-        assert(icapBodySource->exhausted());
+        assert(adaptedBodySource->exhausted());
         endRequestSatisfaction();
     }
 }
@@ -1256,7 +1240,7 @@ void
 ClientHttpRequest::endRequestSatisfaction() {
     debugs(85,4, HERE << this << " ends request satisfaction");
     assert(request_satisfaction_mode);
-    stopConsumingFrom(icapBodySource);
+    stopConsumingFrom(adaptedBodySource);
 
     // TODO: anything else needed to end store entry formation correctly?
     storeEntry()->complete();
@@ -1265,15 +1249,15 @@ ClientHttpRequest::endRequestSatisfaction() {
 void
 ClientHttpRequest::noteBodyProducerAborted(BodyPipe::Pointer)
 {
-    assert(!icapHeadSource);
-    stopConsumingFrom(icapBodySource);
-    handleIcapFailure();
+    assert(!virginHeadSource);
+    stopConsumingFrom(adaptedBodySource);
+    handleAdaptationFailure();
 }
 
 void
-ClientHttpRequest::handleIcapFailure(bool bypassable)
+ClientHttpRequest::handleAdaptationFailure(bool bypassable)
 {
-    debugs(85,3, HERE << "handleIcapFailure(" << bypassable << ")");
+    debugs(85,3, HERE << "handleAdaptationFailure(" << bypassable << ")");
 
     const bool usedStore = storeEntry() && !storeEntry()->isEmpty();
     const bool usedPipe = request->body_pipe != NULL &&
@@ -43,9 +43,9 @@
 #include "dlink.h"
 #include "ICAP/AsyncJob.h"
 
-#if ICAP_CLIENT
-#include "ICAP/ICAPServiceRep.h"
-#include "ICAP/ICAPInitiator.h"
+#if USE_ADAPTATION
+#include "adaptation/forward.h"
+#include "adaptation/Initiator.h"
 
 class HttpMsg;
 #endif
@@ -60,16 +60,16 @@ class ConnStateData;
 class ClientRequestContext;
 
 class ClientHttpRequest
-#if ICAP_CLIENT
-    : public ICAPInitiator, // to start ICAP transactions
+#if USE_ADAPTATION
+    : public Adaptation::Initiator, // to start adaptation transactions
     public BodyConsumer     // to receive reply bodies in request satisf. mode
 #endif
 {
 
 public:
     void *operator new (size_t);
     void operator delete (void *);
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     void *toCbdata() { return this; }
 #endif
     ClientHttpRequest(ConnStateData *);
@@ -136,9 +136,9 @@ class ClientHttpRequest
     ClientRequestContext *calloutContext;
     void doCallouts();
 
-#if ICAP_CLIENT
-//AsyncJob virtual methods
-    virtual bool doneAll() const { return ICAPInitiator::doneAll() && 
+#if USE_ADAPTATION
+    // AsyncJob virtual methods
+    virtual bool doneAll() const { return Initiator::doneAll() && 
 				       BodyConsumer::doneAll() && false;}
 #endif
 
@@ -156,18 +156,18 @@ class ClientHttpRequest
     void sslBumpEstablish(comm_err_t errflag);
 #endif
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 
 public:
-    bool startIcap(ICAPServiceRep::Pointer);
+    bool startAdaptation(Adaptation::ServicePointer);
 
     // private but exposed for ClientRequestContext
-    void handleIcapFailure(bool bypassable = false);
+    void handleAdaptationFailure(bool bypassable = false);
 
 private:
-    // ICAPInitiator API, called by ICAPXaction
-    virtual void noteIcapAnswer(HttpMsg *message);
-    virtual void noteIcapQueryAbort(bool final);
+    // Adaptation::Initiator API
+    virtual void noteAdaptationAnswer(HttpMsg *message);
+    virtual void noteAdaptationQueryAbort(bool final);
 
     // BodyConsumer API, called by BodyPipe
     virtual void noteMoreBodyDataAvailable(BodyPipe::Pointer);
@@ -177,8 +177,8 @@ class ClientHttpRequest
     void endRequestSatisfaction();
 
 private:
-    ICAPInitiate *icapHeadSource;
-    BodyPipe::Pointer icapBodySource;
+    Adaptation::Initiate *virginHeadSource;
+    BodyPipe::Pointer adaptedBodySource;
 
     bool request_satisfaction_mode;
     int64_t request_satisfaction_offset;
@@ -0,0 +1,26 @@
+#  Makefile for the eCAP library
+#
+#  $Id$
+#
+
+AM_CFLAGS = @SQUID_CFLAGS@
+AM_CXXFLAGS = @SQUID_CXXFLAGS@
+
+noinst_LTLIBRARIES = libeCAP.la
+
+libeCAP_la_SOURCES = \
+	Registry.h
+
+INCLUDES = -I. -I$(top_builddir)/include -I$(top_srcdir)/include \
+        -I$(top_srcdir)/src
+
+
+# Sample adapter section.
+
+EXTRA_DIST = \
+	MinimalAdapter.cc
+        
+lib_LTLIBRARIES = MinimalAdapter.la
+MinimalAdapter_la_SOURCES = MinimalAdapter.cc
+MinimalAdapter_la_LDFLAGS = -module -avoid-version
+MinimalAdapter_la_LIBADD = ./libeCAP.la
@@ -1378,10 +1378,10 @@ FtpStateData::processReplyBody()
         return;
     }
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
 
-    if (icapAccessCheckPending) {
-        debugs(9,3, HERE << "returning from FtpStateData::processReplyBody due to icapAccessCheckPending");
+    if (adaptationAccessCheckPending) {
+        debugs(9,3, HERE << "returning from FtpStateData::processReplyBody due to adaptationAccessCheckPending");
         return;
     }
 
@@ -2585,9 +2585,9 @@ FtpStateData::processHeadResponse()
         return;
     }
 
-#if ICAP_CLIENT
-    if (icapAccessCheckPending) {
-        debugs(9,3, HERE << "returning due to icapAccessCheckPending");
+#if USE_ADAPTATION
+    if (adaptationAccessCheckPending) {
+        debugs(9,3, HERE << "returning due to adaptationAccessCheckPending");
         return;
     }
 #endif
@@ -1175,8 +1175,8 @@ HttpStateData::processReplyBody()
         return;
     }
 
-#if ICAP_CLIENT
-    if (icapAccessCheckPending)
+#if USE_ADAPTATION
+    if (adaptationAccessCheckPending)
         return;
 
 #endif
@@ -70,6 +70,17 @@
 #include "MemPool.h"
 #include "ICMPSquid.h"
 
+#if USE_LOADABLE_MODULES
+#include "LoadableModules.h"
+#endif
+
+#if ICAP_CLIENT
+#include "ICAP/ICAPConfig.h"
+#endif
+#if USE_ADAPTATION
+#include "adaptation/Config.h"
+#endif
+
 #if USE_WIN32_SERVICE
 
 #include "squid_windows.h"
@@ -1078,6 +1089,26 @@ mainInitialize(void)
 
     memCheckInit();
 
+#if USE_LOADABLE_MODULES
+    LoadableModulesConfigure(Config.loadable_module_names);
+#endif
+
+#if USE_ADAPTATION
+    bool enableAdaptation = false;
+
+    // We can remove this dependency on specific adaptation mechanisms
+    // if we create a generic Registry of such mechanisms. Should we?
+#if ICAP_CLIENT
+    TheICAPConfig.finalize(); // must be after we load modules
+    enableAdaptation = TheICAPConfig.onoff;
+#endif
+    // same for eCAP
+
+    // must be the last adaptation-related finalize
+    Adaptation::Config::Finalize(enableAdaptation);
+#endif
+
+
     debugs(1, 1, "Ready to serve requests.");
 
     if (!configured_once) {
@@ -629,6 +629,10 @@ struct SquidConfig
 #endif
 
     char *accept_filter;
+
+#if USE_LOADABLE_MODULES
+    wordlist *loadable_module_names;
+#endif
 };
 
 SQUIDCEXTERN SquidConfig Config;