@@ -226,6 +226,12 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
+	<tag>access_log</tag>
+	<p>TCP accept(2) errors logged with URI <em>error:accept-client-connection</em>.
+	<p>Unused connections received in <em>http_port</em> or <em>https_port</em>
+	   or transactions terminated before reading[parsing] request headers
+	   logged with URI <em>error:transaction-end-before-headers</em>.
+
 	<tag>acl</tag>
 	<p>New <em>-m</em> flag for <em>note</em> ACL to match substrings.
 
@@ -236,14 +242,17 @@ This section gives a thorough account of those changes in three categories:
 	<tag>cache_peer</tag>
 	<p>New option <em>auth-no-keytab</em> to let GSSAPI implementation determine
 	   which Kerberos credentials to use, instead of specifying a keytab.
+	<p>Replaced option <em>ssl</em> with <em>tls</em>. Use of any
+	   <em>tls-</em> prefixed options implies <em>tls</em> is enabled.
 	<p>New option <em>tls-min-version=1.N</em> to set minimum TLS version allowed.
 	<p>New option <em>tls-default-ca</em> replaces <em>sslflags=NO_DEFAULT_CA</em>
 	<p>New option <em>tls-no-npn</em> to disable sending TLS NPN extension.
 	<p>All <em>ssloptions=</em> values for SSLv2 configuration or disabling
 	   have been removed.
 	<p>Removed <em>sslversion=</em> option. Use <em>tls-options=</em> instead.
 	<p>Manual squid.conf update may be required on upgrade.
-	<p>Replaced <em>sslcafile=</em> with <em>tls-cafile=</em> which takes multiple entries.
+	<p>Replaced option <em>sslcafile=</em> with <em>tls-cafile=</em>
+	   which takes multiple entries.
 
 	<tag>external_acl_type</tag>
 	<p>New parameter <em>queue-size=</em> to set the maximum number
@@ -35,25 +35,25 @@ static void cacheDigestHashKey(const CacheDigest * cd, const cache_key * key);
 static uint32_t hashed_keys[4];
 
 void
-CacheDigest::init(int newCapacity)
+CacheDigest::init(uint64_t newCapacity)
 {
     const auto newMaskSz = CacheDigest::CalcMaskSize(newCapacity, bits_per_entry);
     assert(newCapacity > 0 && bits_per_entry > 0);
-    assert(newMaskSz > 0);
+    assert(newMaskSz != 0);
     capacity = newCapacity;
     mask_size = newMaskSz;
     mask = static_cast<char *>(xcalloc(mask_size,1));
     debugs(70, 2, "capacity: " << capacity << " entries, bpe: " << bits_per_entry << "; size: "
            << mask_size << " bytes");
 }
 
-CacheDigest::CacheDigest(int aCapacity, int bpe) :
+CacheDigest::CacheDigest(uint64_t aCapacity, uint8_t bpe) :
+    count(0),
+    del_count(0),
+    capacity(0),
     mask(nullptr),
     mask_size(0),
-    capacity(0),
-    bits_per_entry(bpe),
-    count(0),
-    del_count(0)
+    bits_per_entry(bpe)
 {
     assert(SQUID_MD5_DIGEST_LENGTH == 16);  /* our hash functions rely on 16 byte keys */
     updateCapacity(aCapacity);
@@ -83,7 +83,7 @@ CacheDigest::clear()
 }
 
 void
-CacheDigest::updateCapacity(int newCapacity)
+CacheDigest::updateCapacity(uint64_t newCapacity)
 {
     safe_free(mask);
     init(newCapacity); // will re-init mask and mask_size
@@ -261,12 +261,12 @@ cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
     storeAppendPrintf(e, "%s digest: size: %d bytes\n",
                       label ? label : "", stats.bit_count / 8
                      );
-    storeAppendPrintf(e, "\t entries: count: %d capacity: %d util: %d%%\n",
+    storeAppendPrintf(e, "\t entries: count: %" PRIu64 " capacity: %" PRIu64 " util: %d%%\n",
                       cd->count,
                       cd->capacity,
                       xpercentInt(cd->count, cd->capacity)
                      );
-    storeAppendPrintf(e, "\t deletion attempts: %d\n",
+    storeAppendPrintf(e, "\t deletion attempts: %" PRIu64 "\n",
                       cd->del_count
                      );
     storeAppendPrintf(e, "\t bits: per entry: %d on: %d capacity: %d util: %d%%\n",
@@ -280,17 +280,18 @@ cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
                      );
 }
 
-size_t
-CacheDigest::CalcMaskSize(int cap, int bpe)
+uint32_t
+CacheDigest::CalcMaskSize(uint64_t cap, uint8_t bpe)
 {
-    // XXX: might 32-bit overflow during multiply
-    return (size_t) (cap * bpe + 7) / 8;
+    uint64_t bitCount = (cap * bpe) + 7;
+    assert(bitCount < INT_MAX); // dont 31-bit overflow later
+    return static_cast<uint32_t>(bitCount / 8);
 }
 
 static void
 cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 {
-    const unsigned int bit_count = cd->mask_size * 8;
+    const uint32_t bit_count = cd->mask_size * 8;
     unsigned int tmp_keys[4];
     /* we must memcpy to ensure alignment */
     memcpy(tmp_keys, key, sizeof(tmp_keys));
@@ -21,7 +21,7 @@ class CacheDigest
 {
     MEMPROXY_CLASS(CacheDigest);
 public:
-    CacheDigest(int capacity, int bpe);
+    CacheDigest(uint64_t capacity, uint8_t bpe);
     ~CacheDigest();
 
     // NP: only used by broken unit-test
@@ -32,7 +32,7 @@ class CacheDigest
     void clear();
 
     /// changes mask size to fit newCapacity, resets bits to 0
-    void updateCapacity(int newCapacity);
+    void updateCapacity(uint64_t newCapacity);
 
     void add(const cache_key * key);
     void remove(const cache_key * key);
@@ -45,19 +45,19 @@ class CacheDigest
 
     /// calculate the size of mask required to digest up to
     /// a specified capacity and bitsize.
-    static size_t CalcMaskSize(int cap, int bpe);
+    static uint32_t CalcMaskSize(uint64_t cap, uint8_t bpe);
 
 private:
-    void init(int newCapacity);
+    void init(uint64_t newCapacity);
 
 public:
     /* public, read-only */
-    char *mask;         /* bit mask */
-    int mask_size;      /* mask size in bytes */
-    int capacity;       /* expected maximum for .count, not a hard limit */
-    int bits_per_entry;     /* number of bits allocated for each entry from capacity */
-    int count;          /* number of digested entries */
-    int del_count;      /* number of deletions performed so far */
+    uint64_t count;          /* number of digested entries */
+    uint64_t del_count;      /* number of deletions performed so far */
+    uint64_t capacity;       /* expected maximum for .count, not a hard limit */
+    char *mask;              /* bit mask */
+    uint32_t mask_size;      /* mask size in bytes */
+    int8_t bits_per_entry;   /* number of bits allocated for each entry from capacity */
 };
 
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
@@ -42,6 +42,7 @@ CachePeer::CachePeer() :
     domain(NULL),
 #if USE_OPENSSL
     sslContext(NULL),
+    sslSession(NULL),
 #endif
     front_end_https(0),
     connection_auth(2 /* auto */)
@@ -101,6 +102,9 @@ CachePeer::~CachePeer()
 #if USE_OPENSSL
     if (sslContext)
         SSL_CTX_free(sslContext);
+
+    if (sslSession)
+        SSL_SESSION_free(sslSession);
 #endif
 }
 
@@ -184,7 +184,9 @@ class CachePeer
     /// security settings for peer connection
     Security::PeerOptions secure;
     Security::ContextPtr sslContext;
-    Security::SessionStatePointer sslSession;
+#if USE_OPENSSL
+    SSL_SESSION *sslSession;
+#endif
 
     int front_end_https;
     int connection_auth;
@@ -45,9 +45,9 @@
 #include "pconn.h"
 #include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
+#include "security/BlindPeerConnector.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
-#include "ssl/BlindPeerConnector.h"
 #include "ssl/PeekingPeerConnector.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -78,8 +78,7 @@ static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][Http::scInvalidHeader + 1];
 static PconnPool *fwdPconnPool = new PconnPool("server-peers", NULL);
 CBDATA_CLASS_INIT(FwdState);
 
-#if USE_OPENSSL
-class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+class FwdStatePeerAnswerDialer: public CallDialer, public Security::PeerConnector::CbDialer
 {
 public:
     typedef void (FwdState::*Method)(Security::EncryptorAnswer &);
@@ -94,15 +93,14 @@ class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::Cb
         os << '(' << fwd_.get() << ", " << answer_ << ')';
     }
 
-    /* Ssl::PeerConnector::CbDialer API */
+    /* Security::PeerConnector::CbDialer API */
     virtual Security::EncryptorAnswer &answer() { return answer_; }
 
 private:
     Method method_;
     CbcPointer<FwdState> fwd_;
     Security::EncryptorAnswer answer_;
 };
-#endif
 
 void
 FwdState::abort(void* d)
@@ -684,7 +682,6 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, in
 
     closeHandler = comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
-#if USE_OPENSSL
     if (!request->flags.pinned) {
         const CachePeer *p = serverConnection()->getPeer();
         const bool peerWantsTls = p && p->secure.encryptTransport;
@@ -700,16 +697,17 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, in
                                                     FwdStatePeerAnswerDialer(&FwdState::connectedToPeer, this));
             // Use positive timeout when less than one second is left.
             const time_t sslNegotiationTimeout = max(static_cast<time_t>(1), timeLeft());
-            Ssl::PeerConnector *connector = NULL;
+            Security::PeerConnector *connector = nullptr;
+#if USE_OPENSSL
             if (request->flags.sslPeek)
                 connector = new Ssl::PeekingPeerConnector(requestPointer, serverConnection(), clientConn, callback, al, sslNegotiationTimeout);
             else
-                connector = new Ssl::BlindPeerConnector(requestPointer, serverConnection(), callback, al, sslNegotiationTimeout);
+#endif
+                connector = new Security::BlindPeerConnector(requestPointer, serverConnection(), callback, al, sslNegotiationTimeout);
             AsyncJob::Start(connector); // will call our callback
             return;
         }
     }
-#endif
 
     // if not encrypting just run the post-connect actions
     Security::EncryptorAnswer nil;
@@ -997,12 +995,10 @@ FwdState::dispatch()
         request->flags.auth_no_keytab = 0;
 
         switch (request->url.getScheme()) {
-#if USE_OPENSSL
 
         case AnyP::PROTO_HTTPS:
             httpStart(this);
             break;
-#endif
 
         case AnyP::PROTO_HTTP:
             httpStart(this);
@@ -24,7 +24,6 @@
 #include "profiler/Profiler.h"
 #include "rfc1123.h"
 #include "SquidConfig.h"
-//#include "SquidString.h" // pulled by HttpHdrCc.h
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
@@ -238,6 +237,22 @@ HttpHeader::append(const HttpHeader * src)
     }
 }
 
+/// check whether the fresh header has any new/changed updatable fields
+bool
+HttpHeader::needUpdate(HttpHeader const *fresh) const
+{
+    for (const auto e: fresh->entries) {
+        if (skipUpdateHeader(e->id))
+            continue;
+        String value;
+        const char *name = e->name.termedBuf();
+        if (!getByNameIfPresent(name, strlen(name), value) ||
+                (value != fresh->getByName(name)))
+            return true;
+    }
+    return false;
+}
+
 void
 HttpHeader::updateWarnings()
 {
@@ -258,16 +273,22 @@ HttpHeader::skipUpdateHeader(const Http::HdrType id) const
     return id == Http::HdrType::WARNING;
 }
 
-void
+bool
 HttpHeader::update(HttpHeader const *fresh)
 {
-    const HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     assert(fresh);
     assert(this != fresh);
 
+    // Optimization: Finding whether a header field changed is expensive
+    // and probably not worth it except for collapsed revalidation needs.
+    if (Config.onoff.collapsed_forwarding && !needUpdate(fresh))
+        return false;
+
     updateWarnings();
 
+    const HttpHeaderEntry *e;
+    HttpHeaderPos pos = HttpHeaderInitPos;
+
     while ((e = fresh->getEntry(&pos))) {
         /* deny bad guys (ok to check for Http::HdrType::OTHER) here */
 
@@ -291,6 +312,7 @@ HttpHeader::update(HttpHeader const *fresh)
 
         addEntry(e->clone());
     }
+    return true;
 }
 
 int
@@ -81,7 +81,7 @@ class HttpHeader
     /* Interface functions */
     void clean();
     void append(const HttpHeader * src);
-    void update(HttpHeader const *fresh);
+    bool update(HttpHeader const *fresh);
     void compact();
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
@@ -145,6 +145,7 @@ class HttpHeader
 protected:
     /** \deprecated Public access replaced by removeHopByHopEntries() */
     void removeConnectionHeaderEntries();
+    bool needUpdate(const HttpHeader *fresh) const;
     bool skipUpdateHeader(const Http::HdrType id) const;
     void updateWarnings();
 
@@ -235,19 +235,23 @@ HttpReply::validatorsMatch(HttpReply const * otherRep) const
     return 1;
 }
 
-void
+bool
 HttpReply::updateOnNotModified(HttpReply const * freshRep)
 {
     assert(freshRep);
 
+    /* update raw headers */
+    if (!header.update(&freshRep->header))
+        return false;
+
     /* clean cache */
     hdrCacheClean();
-    /* update raw headers */
-    header.update(&freshRep->header);
 
     header.compact();
     /* init cache */
     hdrCacheInit();
+
+    return true;
 }
 
 /* internal routines */
@@ -72,7 +72,7 @@ class HttpReply: public HttpMsg
 
     virtual bool inheritProperties(const HttpMsg *aMsg);
 
-    void updateOnNotModified(HttpReply const *other);
+    bool updateOnNotModified(HttpReply const *other);
 
     /** set commonly used info with one call */
     void setHeaders(Http::StatusCode status,
@@ -7,50 +7,36 @@
  */
 
 #include "squid.h"
-
-/* The original code has this constant ./configure-able.
- * The "#else" branches use raw dlopen interface and have not been tested.
- * We can remove that code if we are going to rely on libtool's ltdl in
- * all environments. */
-#define XSTD_USE_LIBLTDL 1
-
-#if XSTD_USE_LIBLTDL
-#include "libltdl/ltdl.h" /* generated file */
-#else
-#include <dlfcn.h>
-#endif
-
 #include "base/TextException.h"
+#include "libltdl/ltdl.h" /* generated file */
 #include "LoadableModule.h"
 
 // Note: We must use preprocessor instead of C ifs because if dlopen()
 // is seen by the static linker, the linker will complain.
 
 LoadableModule::LoadableModule(const String &aName): theName(aName), theHandle(0)
 {
-#   if XSTD_USE_LIBLTDL
     // Initialise preloaded symbol lookup table.
     LTDL_SET_PRELOADED_SYMBOLS();
     if (lt_dlinit() != 0)
         throw TexcHere("internal error: cannot initialize libtool module loader");
-#   endif
 }
 
 LoadableModule::~LoadableModule()
 {
     if (loaded())
         unload();
-#   if XSTD_USE_LIBLTDL
     assert(lt_dlexit() == 0); // XXX: replace with a warning
-#   endif
 }
 
-bool LoadableModule::loaded() const
+bool
+LoadableModule::loaded() const
 {
     return theHandle != 0;
 }
 
-void LoadableModule::load(int mode)
+void
+LoadableModule::load(int mode)
 {
     if (loaded())
         throw TexcHere("internal error: reusing LoadableModule object");
@@ -61,7 +47,8 @@ void LoadableModule::load(int mode)
         throw TexcHere(errorMsg());
 }
 
-void LoadableModule::unload()
+void
+LoadableModule::unload()
 {
     if (!loaded())
         throw TexcHere("internal error: unloading not loaded module");
@@ -72,32 +59,22 @@ void LoadableModule::unload()
     theHandle = 0;
 }
 
-void *LoadableModule::openModule(int mode)
+void *
+LoadableModule::openModule(int mode)
 {
-#   if XSTD_USE_LIBLTDL
     return lt_dlopen(theName.termedBuf());
-#   else
-    return dlopen(theName.termedBuf(),
-                  mode == lmNow ? RTLD_NOW : RTLD_LAZY);
-#   endif
 }
 
-bool LoadableModule::closeModule()
+bool
+LoadableModule::closeModule()
 {
-#   if XSTD_USE_LIBLTDL
     // we cast to avoid including ltdl.h in LoadableModule.h
     return lt_dlclose(static_cast<lt_dlhandle>(theHandle)) == 0;
-#   else
-    return dlclose(theHandle) == 0;
-#   endif
 }
 
-const char *LoadableModule::errorMsg()
+const char *
+LoadableModule::errorMsg()
 {
-#   if XSTD_USE_LIBLTDL
     return lt_dlerror();
-#   else
-    return dlerror();
-#   endif
 }
 
@@ -1435,6 +1435,8 @@ tests_testCacheManager_LDADD = \
 tests_testCacheManager_LDFLAGS = $(LIBADD_DL)
 
 tests_testDiskIO_SOURCES = \
+	AccessLogEntry.cc \
+	AccessLogEntry.h \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	cbdata.cc \
@@ -1540,6 +1542,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
+	tests/stub_liblog.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
@@ -1583,6 +1586,7 @@ tests_testDiskIO_LDADD = \
 	fs/libfs.la \
 	ipc/libipc.la \
 	$(REPL_OBJS) \
+	$(ADAPTATION_LIBS) \
 	DiskIO/libdiskio.la \
 	acl/libapi.la \
 	anyp/libanyp.la \
@@ -2898,6 +2902,8 @@ SWAP_TEST_DS =\
 	$(REPL_OBJS)
 
 tests_testUfs_SOURCES = \
+	AccessLogEntry.cc \
+	AccessLogEntry.h \
 	tests/testUfs.cc \
 	tests/testUfs.h \
 	tests/stub_cache_manager.cc \
@@ -2909,6 +2915,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_ipcache.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libicmp.cc \
+	tests/stub_liblog.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
@@ -3055,6 +3062,7 @@ tests_testUfs_LDADD = \
 	ip/libip.la \
 	mem/libmem.la \
 	store/libstore.la \
+	$(ADAPTATION_LIBS) \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -3085,6 +3093,8 @@ testRefCount_LDADD = \
 	$(XTRA_LIBS)
 
 tests_testRock_SOURCES = \
+	AccessLogEntry.cc \
+	AccessLogEntry.h \
 	cbdata.cc \
 	CacheDigest.h \
 	CollapsedForwarding.h \
@@ -3183,6 +3193,7 @@ tests_testRock_SOURCES = \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
+	tests/stub_liblog.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_libsecurity.cc \
 	tests/stub_MemStore.cc \
@@ -3228,6 +3239,7 @@ tests_testRock_LDADD = \
 	base/libbase.la \
 	mem/libmem.la \
 	store/libstore.la \
+	$(ADAPTATION_LIBS) \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -154,7 +154,7 @@ MemBuf::reset()
  * Unfortunate hack to test if the buffer has been Init()ialized
  */
 int
-MemBuf::isNull()
+MemBuf::isNull() const
 {
     if (!buf && !max_capacity && !capacity && !size)
         return 1;       /* is null (not initialized) */
@@ -99,7 +99,7 @@ class MemBuf : public Packable
     void reset();
 
     /** unfirtunate hack to test if the buffer has been Init()ialized */
-    int isNull();
+    int isNull() const;
 
     /**
      * freezes the object! and returns function to clear it up.
@@ -63,6 +63,7 @@ class MemStore: public Store::Controlled, public Ipc::StoreMapCleaner
     virtual bool updateCollapsed(StoreEntry &e) override;
     virtual void markForUnlink(StoreEntry &) override;
     virtual void unlink(StoreEntry &e) override;
+    virtual bool smpAware() const override { return true; }
 
     static int64_t EntryLimit();
 
@@ -56,7 +56,7 @@ class DigestFetchState
     store_client *old_sc;
     HttpRequest *request;
     int offset;
-    int mask_offset;
+    uint32_t mask_offset;
     time_t start_time;
     time_t resp_time;
     time_t expires;
@@ -7,6 +7,7 @@
  */
 
 #include "squid.h"
+#include "AccessLogEntry.h"
 #include "base/AsyncJobCalls.h"
 #include "base/RunnersRegistry.h"
 #include "CachePeer.h"
@@ -20,25 +21,23 @@
 #include "neighbors.h"
 #include "pconn.h"
 #include "PeerPoolMgr.h"
+#include "security/BlindPeerConnector.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
-#include "ssl/BlindPeerConnector.h"
 
 CBDATA_CLASS_INIT(PeerPoolMgr);
 
-#if USE_OPENSSL
-/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+/// Gives Security::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
 class MyAnswerDialer: public UnaryMemFunT<PeerPoolMgr, Security::EncryptorAnswer, Security::EncryptorAnswer&>,
-    public Ssl::PeerConnector::CbDialer
+    public Security::PeerConnector::CbDialer
 {
 public:
     MyAnswerDialer(const JobPointer &aJob, Method aMethod):
         UnaryMemFunT<PeerPoolMgr, Security::EncryptorAnswer, Security::EncryptorAnswer&>(aJob, aMethod, Security::EncryptorAnswer()) {}
 
-    /* Ssl::PeerConnector::CbDialer API */
+    /* Security::PeerConnector::CbDialer API */
     virtual Security::EncryptorAnswer &answer() { return arg1; }
 };
-#endif
 
 PeerPoolMgr::PeerPoolMgr(CachePeer *aPeer): AsyncJob("PeerPoolMgr"),
     peer(cbdataReference(aPeer)),
@@ -109,8 +108,7 @@ PeerPoolMgr::handleOpenedConnection(const CommConnectCbParams &params)
 
     Must(params.conn != NULL);
 
-#if USE_OPENSSL
-    // Handle SSL peers.
+    // Handle TLS peers.
     if (peer->secure.encryptTransport) {
         typedef CommCbMemFunT<PeerPoolMgr, CommCloseCbParams> CloserDialer;
         closer = JobCallback(48, 3, CloserDialer, this,
@@ -125,12 +123,10 @@ PeerPoolMgr::handleOpenedConnection(const CommConnectCbParams &params)
         const int timeUsed = squid_curtime - params.conn->startTime();
         // Use positive timeout when less than one second is left for conn.
         const int timeLeft = max(1, (peerTimeout - timeUsed));
-        Ssl::BlindPeerConnector *connector =
-            new Ssl::BlindPeerConnector(request, params.conn, securer, NULL, timeLeft);
+        auto *connector = new Security::BlindPeerConnector(request, params.conn, securer, nullptr, timeLeft);
         AsyncJob::Start(connector); // will call our callback
         return;
     }
-#endif
 
     pushNewConnection(params.conn);
 }
@@ -51,7 +51,7 @@ class PeerPoolMgr: public AsyncJob
     /// Comm::ConnOpener calls this when done opening a connection for us
     void handleOpenedConnection(const CommConnectCbParams &params);
 
-    /// Ssl::PeerConnector callback
+    /// Security::PeerConnector callback
     void handleSecuredPeer(Security::EncryptorAnswer &answer);
 
     /// called when the connection we are trying to secure is closed by a 3rd party
@@ -36,6 +36,18 @@ Pipeline::front() const
     return requests.front();
 }
 
+Http::StreamPointer
+Pipeline::back() const
+{
+    if (requests.empty()) {
+        debugs(33, 3, "Pipeline " << (void*)this << " empty");
+        return Http::StreamPointer();
+    }
+
+    debugs(33, 3, "Pipeline " << (void*)this << " back " << requests.back());
+    return requests.back();
+}
+
 void
 Pipeline::terminateAll(int xerrno)
 {
@@ -46,6 +46,9 @@ class Pipeline
     /// get the first request context in the pipeline
     Http::StreamPointer front() const;
 
+    /// get the last request context in the pipeline
+    Http::StreamPointer back() const;
+
     /// how many requests are currently pipelined
     size_t count() const {return requests.size();}
 
@@ -82,9 +82,13 @@ class StoreEntry : public hash_link, public Packable
     void swapOutDecision(const MemObject::SwapOut::Decision &decision);
 
     void abort();
-    void makePublic();
+    void makePublic(const KeyScope keyScope = ksDefault);
     void makePrivate();
-    void setPublicKey();
+    void setPublicKey(const KeyScope keyScope = ksDefault);
+    /// Resets existing public key to a public key with default scope,
+    /// releasing the old default-scope entry (if any).
+    /// Does nothing if the existing public key already has default scope.
+    void clearPublicKeyScope();
     void setPrivateKey();
     void expireNow();
     void releaseRequest();
@@ -119,7 +123,7 @@ class StoreEntry : public hash_link, public Packable
     void registerAbort(STABH * cb, void *);
     void reset();
     void setMemStatus(mem_status_t);
-    void timestampsSet();
+    bool timestampsSet();
     void unregisterAbort();
     void destroyMemObject();
     int checkTooSmall();
@@ -217,6 +221,9 @@ class StoreEntry : public hash_link, public Packable
 
 private:
     bool checkTooBig() const;
+    void forcePublicKey(const cache_key *newkey);
+    void adjustVary();
+    const cache_key *calcPublicKey(const KeyScope keyScope);
 
     static MemAllocator *pool;
 
@@ -286,10 +293,10 @@ void storeEntryReplaceObject(StoreEntry *, HttpReply *);
 StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-StoreEntry *storeGetPublicByRequest(HttpRequest * request);
+StoreEntry *storeGetPublicByRequest(HttpRequest * request, const KeyScope keyScope = ksDefault);
 
 /// \ingroup StoreAPI
-StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method, const KeyScope keyScope = ksDefault);
 
 /// \ingroup StoreAPI
 /// Like storeCreatePureEntry(), but also locks the entry and sets entry key.
@@ -184,7 +184,8 @@ Transients::copyFromShm(const sfileno index)
     e->mem_obj->xitTable.io = MemObject::ioReading;
     e->mem_obj->xitTable.index = index;
 
-    e->setPublicKey();
+    // TODO: Support collapsed revalidation for SMP-aware caches.
+    e->setPublicKey(ksDefault);
     assert(e->key);
 
     // How do we know its SMP- and not just locally-collapsed? A worker gets
@@ -72,6 +72,7 @@ class Transients: public Store::Controlled, public Ipc::StoreMapCleaner
     virtual void markForUnlink(StoreEntry &e) override;
     virtual void unlink(StoreEntry &e) override;
     virtual void maintain() override;
+    virtual bool smpAware() const override { return true; }
 
     static int64_t EntryLimit();
 
@@ -214,7 +214,7 @@ main(int argc, char *const argv[])
             margs.rc_allow = 1;
             break;
         case 's':
-            margs.ssl = (char *) "yes";
+            margs.ssl = xstrdup("yes");
             break;
         case 'n':
             margs.nokerberos = 1;
@@ -74,9 +74,13 @@ LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 #define FILTER_AD "(samaccountname=%s)"
 #define ATTRIBUTE_AD "memberof"
 
-size_t get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
-size_t get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val , int **out_len /* OUT (caller frees) */ );
-int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth);
+size_t get_attributes(LDAP * ld, LDAPMessage * res,
+                      const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
+size_t get_bin_attributes(LDAP * ld, LDAPMessage * res,
+                          const char *attribute /* IN */ , char ***out_val,
+                          int **out_len /* OUT (caller frees) */ );
+int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp,
+                      char *ldap_group, char *group, int depth);
 
 #if HAVE_SUN_LDAP_SDK || HAVE_MOZILLA_LDAP_SDK
 #if HAVE_LDAP_REBINDPROC_CALLBACK
@@ -85,13 +89,8 @@ int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *lda
 static LDAP_REBINDPROC_CALLBACK ldap_sasl_rebind;
 
 static int LDAP_CALL LDAP_CALLBACK
-ldap_sasl_rebind(
-    LDAP * ld,
-    char **whop,
-    char **credp,
-    int *methodp,
-    int freeit,
-    void *params)
+ldap_sasl_rebind(LDAP * ld,
+                 char **whop, char **credp, int *methodp, int freeit, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     whop = whop;
@@ -105,37 +104,29 @@ ldap_sasl_rebind(
 static LDAP_REBINDPROC_CALLBACK ldap_simple_rebind;
 
 static int LDAP_CALL LDAP_CALLBACK
-ldap_simple_rebind(
-    LDAP * ld,
-    char **whop,
-    char **credp,
-    int *methodp,
-    int freeit,
-    void *params)
+ldap_simple_rebind(LDAP * ld,
+                   char **whop, char **credp, int *methodp, int freeit, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     struct berval cred;
     if (cp->pw) {
-        cred.bv_val=cp->pw;
-        cred.bv_len=strlen(cp->pw);
+        cred.bv_val = cp->pw;
+        cred.bv_len = strlen(cp->pw);
     }
     whop = whop;
     credp = credp;
     methodp = methodp;
     freeit = freeit;
-    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL, NULL);
+    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL,
+                            NULL);
 }
 #elif HAVE_LDAP_REBIND_PROC
 #if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
 static LDAP_REBIND_PROC ldap_sasl_rebind;
 
 static int
-ldap_sasl_rebind(
-    LDAP * ld,
-    LDAP_CONST char *url,
-    ber_tag_t request,
-    ber_int_t msgid,
-    void *params)
+ldap_sasl_rebind(LDAP * ld,
+                 LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     return tool_sasl_bind(ld, cp->dn, cp->pw);
@@ -145,20 +136,17 @@ ldap_sasl_rebind(
 static LDAP_REBIND_PROC ldap_simple_rebind;
 
 static int
-ldap_simple_rebind(
-    LDAP * ld,
-    LDAP_CONST char *url,
-    ber_tag_t request,
-    ber_int_t msgid,
-    void *params)
+ldap_simple_rebind(LDAP * ld,
+                   LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     struct berval cred;
     if (cp->pw) {
-        cred.bv_val=cp->pw;
-        cred.bv_len=strlen(cp->pw);
+        cred.bv_val = cp->pw;
+        cred.bv_len = strlen(cp->pw);
     }
-    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL, NULL);
+    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL,
+                            NULL);
 }
 
 #elif HAVE_LDAP_REBIND_FUNCTION
@@ -169,13 +157,8 @@ ldap_simple_rebind(
 static LDAP_REBIND_FUNCTION ldap_sasl_rebind;
 
 static int
-ldap_sasl_rebind(
-    LDAP * ld,
-    char **whop,
-    char **credp,
-    int *methodp,
-    int freeit,
-    void *params)
+ldap_sasl_rebind(LDAP * ld,
+                 char **whop, char **credp, int *methodp, int freeit, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     whop = whop;
@@ -189,25 +172,21 @@ ldap_sasl_rebind(
 static LDAP_REBIND_FUNCTION ldap_simple_rebind;
 
 static int
-ldap_simple_rebind(
-    LDAP * ld,
-    char **whop,
-    char **credp,
-    int *methodp,
-    int freeit,
-    void *params)
+ldap_simple_rebind(LDAP * ld,
+                   char **whop, char **credp, int *methodp, int freeit, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     struct berval cred;
     if (cp->pw) {
-        cred.bv_val=cp->pw;
-        cred.bv_len=strlen(cp->pw);
+        cred.bv_val = cp->pw;
+        cred.bv_len = strlen(cp->pw);
     }
     whop = whop;
     credp = credp;
     methodp = methodp;
     freeit = freeit;
-    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL, NULL);
+    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL,
+                            NULL);
 }
 #else
 #error "No rebind functione defined"
@@ -217,7 +196,8 @@ ldap_simple_rebind(
 static LDAP_REBIND_PROC ldap_sasl_rebind;
 
 static int
-ldap_sasl_rebind(LDAP *ld, LDAP_CONST char *, ber_tag_t request, ber_int_t msgid, void *params)
+ldap_sasl_rebind(LDAP * ld, LDAP_CONST char *, ber_tag_t request,
+                 ber_int_t msgid, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     return tool_sasl_bind(ld, cp->dn, cp->pw);
@@ -227,16 +207,18 @@ ldap_sasl_rebind(LDAP *ld, LDAP_CONST char *, ber_tag_t request, ber_int_t msgid
 static LDAP_REBIND_PROC ldap_simple_rebind;
 
 static int
-ldap_simple_rebind(LDAP *ld, LDAP_CONST char *, ber_tag_t request, ber_int_t msgid, void *params)
+ldap_simple_rebind(LDAP * ld, LDAP_CONST char *, ber_tag_t request,
+                   ber_int_t msgid, void *params)
 {
 
     struct ldap_creds *cp = (struct ldap_creds *) params;
     struct berval cred;
     if (cp->pw) {
-        cred.bv_val=cp->pw;
-        cred.bv_len=strlen(cp->pw);
+        cred.bv_val = cp->pw;
+        cred.bv_len = strlen(cp->pw);
     }
-    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL, NULL);
+    return ldap_sasl_bind_s(ld, cp->dn, LDAP_SASL_SIMPLE, &cred, NULL, NULL,
+                            NULL);
 }
 
 #endif
@@ -284,8 +266,7 @@ escape_filter(char *filter)
     for (ldap_filter_esc = filter; *ldap_filter_esc; ++ldap_filter_esc) {
         if ((*ldap_filter_esc == '*') ||
                 (*ldap_filter_esc == '(') ||
-                (*ldap_filter_esc == ')') ||
-                (*ldap_filter_esc == '\\'))
+                (*ldap_filter_esc == ')') || (*ldap_filter_esc == '\\'))
             i = i + 3;
     }
 
@@ -330,24 +311,34 @@ check_AD(struct main_args *margs, LDAP * ld)
     searchtime.tv_sec = SEARCH_TIMEOUT;
     searchtime.tv_usec = 0;
 
-    debug((char *) "%s| %s: DEBUG: Search ldap server with bind path \"\" and filter: %s\n", LogTime(), PROGRAM, FILTER_SCHEMA);
-    rc = ldap_search_ext_s(ld, (char *) "", LDAP_SCOPE_BASE, (char *) FILTER_SCHEMA, NULL, 0,
-                           NULL, NULL, &searchtime, 0, &res);
+    debug((char *)
+          "%s| %s: DEBUG: Search ldap server with bind path \"\" and filter: %s\n",
+          LogTime(), PROGRAM, FILTER_SCHEMA);
+    rc = ldap_search_ext_s(ld, (char *) "", LDAP_SCOPE_BASE,
+                           (char *) FILTER_SCHEMA, NULL, 0, NULL, NULL, &searchtime, 0, &res);
 
     if (rc == LDAP_SUCCESS)
         max_attr = get_attributes(ld, res, ATTRIBUTE_SCHEMA, &attr_value);
 
     if (max_attr == 1) {
         ldap_msgfree(res);
-        debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, attr_value[0], FILTER_SAM);
-        rc = ldap_search_ext_s(ld, attr_value[0], LDAP_SCOPE_SUBTREE, (char *) FILTER_SAM, NULL, 0,
-                               NULL, NULL, &searchtime, 0, &res);
-        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
+        debug((char *)
+              "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n",
+              LogTime(), PROGRAM, attr_value[0], FILTER_SAM);
+        rc = ldap_search_ext_s(ld, attr_value[0], LDAP_SCOPE_SUBTREE,
+                               (char *) FILTER_SAM, NULL, 0, NULL, NULL, &searchtime, 0, &res);
+        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(),
+              PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld,
+                      res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
         if (ldap_count_entries(ld, res) > 0)
             margs->AD = 1;
     } else
-        debug((char *) "%s| %s: DEBUG: Did not find ldap entry for subschemasubentry\n", LogTime(), PROGRAM);
-    debug((char *) "%s| %s: DEBUG: Determined ldap server %sas an Active Directory server\n", LogTime(), PROGRAM, margs->AD ? "" : "not ");
+        debug((char *)
+              "%s| %s: DEBUG: Did not find ldap entry for subschemasubentry\n",
+              LogTime(), PROGRAM);
+    debug((char *)
+          "%s| %s: DEBUG: Determined ldap server %sas an Active Directory server\n",
+          LogTime(), PROGRAM, margs->AD ? "" : "not ");
     /*
      * Cleanup
      */
@@ -361,8 +352,10 @@ check_AD(struct main_args *margs, LDAP * ld)
     ldap_msgfree(res);
     return rc;
 }
+
 int
-search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth)
+search_group_tree(struct main_args *margs, LDAP * ld, char *bindp,
+                  char *ldap_group, char *group, int depth)
 {
     LDAPMessage *res = NULL;
     char **attr_value = NULL;
@@ -395,21 +388,26 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
     xfree(ldap_filter_esc);
 
     if (depth > margs->mdepth) {
-        debug((char *) "%s| %s: DEBUG: Max search depth reached %d>%d\n", LogTime(), PROGRAM, depth, margs->mdepth);
+        debug((char *) "%s| %s: DEBUG: Max search depth reached %d>%d\n",
+              LogTime(), PROGRAM, depth, margs->mdepth);
         xfree(search_exp);
         return 0;
     }
-    debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter : %s\n", LogTime(), PROGRAM, bindp, search_exp);
-    rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
-                           search_exp, NULL, 0,
+    debug((char *)
+          "%s| %s: DEBUG: Search ldap server with bind path %s and filter : %s\n",
+          LogTime(), PROGRAM, bindp, search_exp);
+    rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE, search_exp, NULL, 0,
                            NULL, NULL, &searchtime, 0, &res);
     xfree(search_exp);
 
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         return 0;
     }
-    debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
+    debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM,
+          ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1
+          || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
     if (margs->AD)
         max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
@@ -435,21 +433,28 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
         }
         if (debug_enabled) {
             int n;
-            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                  " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
             for (n = 0; av[n] != '\0'; ++n)
                 fprintf(stderr, "%02x", (unsigned char) av[n]);
             fprintf(stderr, "\n");
         }
         if (!strcasecmp(group, av)) {
             retval = 1;
-            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                  " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM,
+                  j + 1, av, group);
             break;
         } else
-            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                  " \"%s\" does not match group name \"%s\"\n", LogTime(),
+                  PROGRAM, j + 1, av, group);
         /*
          * Do recursive group search
          */
-        debug((char *) "%s| %s: DEBUG: Perform recursive group search for group \"%s\"\n", LogTime(), PROGRAM, av);
+        debug((char *)
+              "%s| %s: DEBUG: Perform recursive group search for group \"%s\"\n",
+              LogTime(), PROGRAM, av);
         av = attr_value[j];
         if (search_group_tree(margs, ld, bindp, av, group, ldepth)) {
             retval = 1;
@@ -461,7 +466,9 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
                 }
             }
             if (debug_enabled)
-                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                      " \"%s\" is member of group named \"%s\"\n", LogTime(),
+                      PROGRAM, j + 1, av, group);
             else
                 break;
 
@@ -492,20 +499,25 @@ ldap_set_defaults(LDAP * ld)
     val = LDAP_VERSION3;
     rc = ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &val);
     if (rc != LDAP_SUCCESS) {
-        debug((char *) "%s| %s: DEBUG: Error while setting protocol version: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        debug((char *)
+              "%s| %s: DEBUG: Error while setting protocol version: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         return rc;
     }
     rc = ldap_set_option(ld, LDAP_OPT_REFERRALS, LDAP_OPT_OFF);
     if (rc != LDAP_SUCCESS) {
-        debug((char *) "%s| %s: DEBUG: Error while setting referrals off: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        debug((char *) "%s| %s: DEBUG: Error while setting referrals off: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         return rc;
     }
 #if LDAP_OPT_NETWORK_TIMEOUT
     tv.tv_sec = CONNECT_TIMEOUT;
     tv.tv_usec = 0;
     rc = ldap_set_option(ld, LDAP_OPT_NETWORK_TIMEOUT, &tv);
     if (rc != LDAP_SUCCESS) {
-        debug((char *) "%s| %s: DEBUG: Error while setting network timeout: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        debug((char *)
+              "%s| %s: DEBUG: Error while setting network timeout: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         return rc;
     }
 #endif /* LDAP_OPT_NETWORK_TIMEOUT */
@@ -527,35 +539,75 @@ ldap_set_ssl_defaults(struct main_args *margs)
 #if HAVE_OPENLDAP
     if (!margs->rc_allow) {
         char *ssl_cacertfile = NULL;
-        int free_path;
-        debug((char *) "%s| %s: DEBUG: Enable server certificate check for ldap server.\n", LogTime(), PROGRAM);
+        char *ssl_cacertdir = NULL;
+        debug((char *)
+              "%s| %s: DEBUG: Enable server certificate check for ldap server.\n",
+              LogTime(), PROGRAM);
         val = LDAP_OPT_X_TLS_DEMAND;
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &val);
         if (rc != LDAP_SUCCESS) {
-            error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_REQUIRE_CERT DEMAND for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+            error((char *)
+                  "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_REQUIRE_CERT DEMAND for ldap server: %s\n",
+                  LogTime(), PROGRAM, ldap_err2string(rc));
             return rc;
         }
-        ssl_cacertfile = getenv("TLS_CACERTFILE");
-        free_path = 0;
+        ssl_cacertfile = xstrdup(getenv("TLS_CACERTFILE"));
         if (!ssl_cacertfile) {
             ssl_cacertfile = xstrdup("/etc/ssl/certs/cert.pem");
-            free_path = 1;
         }
-        debug((char *) "%s| %s: DEBUG: Set certificate file for ldap server to %s.(Changeable through setting environment variable TLS_CACERTFILE)\n", LogTime(), PROGRAM, ssl_cacertfile);
-        rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE, ssl_cacertfile);
-        if (ssl_cacertfile && free_path) {
+        if (access(ssl_cacertfile, R_OK) == 0) {
+            debug((char *)
+                  "%s| %s: DEBUG: Set certificate file for ldap server to %s. (Changeable through setting environment variable TLS_CACERTFILE)\n",
+                  LogTime(), PROGRAM, ssl_cacertfile);
+            rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE,
+                                 ssl_cacertfile);
             xfree(ssl_cacertfile);
-        }
-        if (rc != LDAP_OPT_SUCCESS) {
-            error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_CACERTFILE for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
-            return rc;
+            if (rc != LDAP_OPT_SUCCESS) {
+                error((char *)
+                      "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_CACERTFILE for ldap server: %s\n",
+                      LogTime(), PROGRAM, ldap_err2string(rc));
+                return rc;
+            }
+        } else {
+            debug((char *)
+                  "%s| %s: DEBUG: Set certificate file for ldap server to %s failed (%s). (Changeable through setting environment variable TLS_CACERTFILE) Trying db certificate directory\n",
+                  LogTime(), PROGRAM, ssl_cacertfile, strerror(errno));
+            xfree(ssl_cacertfile);
+            ssl_cacertdir = xstrdup(getenv("TLS_CACERTDIR"));
+            if (!ssl_cacertdir) {
+                ssl_cacertdir = xstrdup("/etc/ssl/certs");
+            }
+            if (access(ssl_cacertdir, R_OK) == 0) {
+                debug((char *)
+                      "%s| %s: DEBUG: Set certificate database path for ldap server to %s. (Changeable through setting environment variable TLS_CACERTDIR)\n",
+                      LogTime(), PROGRAM, ssl_cacertdir);
+                rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTDIR,
+                                     ssl_cacertdir);
+                xfree(ssl_cacertdir);
+                if (rc != LDAP_OPT_SUCCESS) {
+                    error((char *)
+                          "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_CACERTDIR for ldap server: %s\n",
+                          LogTime(), PROGRAM, ldap_err2string(rc));
+                    return rc;
+                }
+            } else {
+                debug((char *)
+                      "%s| %s: DEBUG: Set certificate database path for ldap server to %s failed (%s). (Changeable through setting environment variable TLS_CACERTDIR)\n",
+                      LogTime(), PROGRAM, ssl_cacertdir, strerror(errno));
+                xfree(ssl_cacertdir);
+                return errno;
+            }
         }
     } else {
-        debug((char *) "%s| %s: DEBUG: Disable server certificate check for ldap server.\n", LogTime(), PROGRAM);
+        debug((char *)
+              "%s| %s: DEBUG: Disable server certificate check for ldap server.\n",
+              LogTime(), PROGRAM);
         val = LDAP_OPT_X_TLS_ALLOW;
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &val);
         if (rc != LDAP_SUCCESS) {
-            error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_REQUIRE_CERT ALLOW for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+            error((char *)
+                  "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_REQUIRE_CERT ALLOW for ldap server: %s\n",
+                  LogTime(), PROGRAM, ldap_err2string(rc));
             return rc;
         }
     }
@@ -571,26 +623,36 @@ ldap_set_ssl_defaults(struct main_args *margs)
     if (!ssl_certdbpath) {
         ssl_certdbpath = xstrdup("/etc/certs");
     }
-    debug((char *) "%s| %s: DEBUG: Set certificate database path for ldap server to %s.(Changeable through setting environment variable SSL_CERTDBPATH)\n", LogTime(), PROGRAM, ssl_certdbpath);
+    debug((char *)
+          "%s| %s: DEBUG: Set certificate database path for ldap server to %s. (Changeable through setting environment variable SSL_CERTDBPATH)\n",
+          LogTime(), PROGRAM, ssl_certdbpath);
     if (!margs->rc_allow) {
-        rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0, NULL, 2);
+        rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0,
+                                        NULL, 2);
     } else {
-        rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0, NULL, 0);
-        debug((char *) "%s| %s: DEBUG: Disable server certificate check for ldap server.\n", LogTime(), PROGRAM);
+        rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0,
+                                        NULL, 0);
+        debug((char *)
+              "%s| %s: DEBUG: Disable server certificate check for ldap server.\n",
+              LogTime(), PROGRAM);
     }
     xfree(ssl_certdbpath);
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
+        error((char *)
+              "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n",
+              LogTime(), PROGRAM, ldapssl_err2string(rc));
         return rc;
     }
 #else
-    error((char *) "%s| %s: ERROR: SSL not supported by ldap library\n", LogTime(), PROGRAM);
+    error((char *) "%s| %s: ERROR: SSL not supported by ldap library\n",
+          LogTime(), PROGRAM);
 #endif
     return LDAP_SUCCESS;
 }
 
 size_t
-get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
+get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute,
+               char ***ret_value)
 {
 
     char **attr_value = *ret_value;
@@ -599,8 +661,10 @@ get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_
     /*
      * loop over attributes
      */
-    debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n", LogTime(), PROGRAM, attribute);
-    for (LDAPMessage *msg = ldap_first_entry(ld, res); msg; msg = ldap_next_entry(ld, msg)) {
+    debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n",
+          LogTime(), PROGRAM, attribute);
+    for (LDAPMessage * msg = ldap_first_entry(ld, res); msg;
+            msg = ldap_next_entry(ld, msg)) {
 
         switch (ldap_msgtype(msg)) {
 
@@ -611,15 +675,20 @@ get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_
                 if (strcasecmp(attr, attribute) == 0) {
                     struct berval **values;
 
-                    if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
+                    if ((values =
+                                ldap_get_values_len(ld, msg, attr)) != NULL) {
                         for (int il = 0; values[il] != NULL; ++il) {
 
-                            attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
+                            attr_value =
+                                (char **) xrealloc(attr_value,
+                                                   (max_attr + 1) * sizeof(char *));
                             if (!attr_value)
                                 break;
 
-                            attr_value[max_attr] = (char *) xmalloc(values[il]->bv_len + 1);
-                            memcpy(attr_value[max_attr], values[il]->bv_val, values[il]->bv_len);
+                            attr_value[max_attr] =
+                                (char *) xmalloc(values[il]->bv_len + 1);
+                            memcpy(attr_value[max_attr], values[il]->bv_val,
+                                   values[il]->bv_len);
                             attr_value[max_attr][values[il]->bv_len] = 0;
                             max_attr++;
                         }
@@ -632,24 +701,30 @@ get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_
         }
         break;
         case LDAP_RES_SEARCH_REFERENCE:
-            debug((char *) "%s| %s: DEBUG: Received a search reference message\n", LogTime(), PROGRAM);
+            debug((char *)
+                  "%s| %s: DEBUG: Received a search reference message\n",
+                  LogTime(), PROGRAM);
             break;
         case LDAP_RES_SEARCH_RESULT:
-            debug((char *) "%s| %s: DEBUG: Received a search result message\n", LogTime(), PROGRAM);
+            debug((char *) "%s| %s: DEBUG: Received a search result message\n",
+                  LogTime(), PROGRAM);
             break;
         default:
             break;
         }
     }
 
-    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
+    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE
+          " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM,
+          max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
 
     *ret_value = attr_value;
     return max_attr;
 }
 
 size_t
-get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value, int **ret_len)
+get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute,
+                   char ***ret_value, int **ret_len)
 {
 
     char **attr_value = *ret_value;
@@ -659,8 +734,10 @@ get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***
     /*
      * loop over attributes
      */
-    debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n", LogTime(), PROGRAM, attribute);
-    for (  LDAPMessage *msg = ldap_first_entry(ld, res); msg; msg = ldap_next_entry(ld, msg)) {
+    debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n",
+          LogTime(), PROGRAM, attribute);
+    for (LDAPMessage * msg = ldap_first_entry(ld, res); msg;
+            msg = ldap_next_entry(ld, msg)) {
 
         switch (ldap_msgtype(msg)) {
 
@@ -671,21 +748,28 @@ get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***
                 if (strcasecmp(attr, attribute) == 0) {
                     struct berval **values;
 
-                    if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
+                    if ((values =
+                                ldap_get_values_len(ld, msg, attr)) != NULL) {
                         for (int il = 0; values[il] != NULL; ++il) {
 
-                            attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
+                            attr_value =
+                                (char **) xrealloc(attr_value,
+                                                   (max_attr + 1) * sizeof(char *));
                             if (!attr_value)
                                 break;
 
-                            attr_len = (int *) xrealloc(attr_len, (max_attr + 1) * sizeof(int));
+                            attr_len =
+                                (int *) xrealloc(attr_len,
+                                                 (max_attr + 1) * sizeof(int));
                             if (!attr_len)
                                 break;
 
-                            attr_value[max_attr] = (char *) xmalloc(values[il]->bv_len + 1);
-                            memcpy(attr_value[max_attr], values[il]->bv_val, values[il]->bv_len);
+                            attr_value[max_attr] =
+                                (char *) xmalloc(values[il]->bv_len + 1);
+                            memcpy(attr_value[max_attr], values[il]->bv_val,
+                                   values[il]->bv_len);
                             attr_value[max_attr][values[il]->bv_len] = 0;
-                            attr_len[max_attr]=values[il]->bv_len;
+                            attr_len[max_attr] = values[il]->bv_len;
                             max_attr++;
                         }
                     }
@@ -697,17 +781,22 @@ get_bin_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***
         }
         break;
         case LDAP_RES_SEARCH_REFERENCE:
-            debug((char *) "%s| %s: DEBUG: Received a search reference message\n", LogTime(), PROGRAM);
+            debug((char *)
+                  "%s| %s: DEBUG: Received a search reference message\n",
+                  LogTime(), PROGRAM);
             break;
         case LDAP_RES_SEARCH_RESULT:
-            debug((char *) "%s| %s: DEBUG: Received a search result message\n", LogTime(), PROGRAM);
+            debug((char *) "%s| %s: DEBUG: Received a search result message\n",
+                  LogTime(), PROGRAM);
             break;
         default:
             break;
         }
     }
 
-    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
+    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE
+          " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM,
+          max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
 
     *ret_value = attr_value;
     *ret_len = attr_len;
@@ -752,7 +841,8 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 #elif HAVE_LDAP_URL_PARSE
     rc = ldap_url_parse(ldapuri, &url);
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        error((char *) "%s| %s: ERROR: Error while parsing url: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         xfree(ldapuri);
         ldap_free_urldesc(url);
         return NULL;
@@ -764,8 +854,10 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
     rc = ldap_initialize(&ld, ldapuri);
     xfree(ldapuri);
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
-        ldap_unbind_ext(ld,NULL,NULL);
+        error((char *)
+              "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
+        ldap_unbind_ext(ld, NULL, NULL);
         ld = NULL;
         return NULL;
     }
@@ -774,7 +866,9 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 #endif
     rc = ldap_set_defaults(ld);
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        error((char *)
+              "%s| %s: ERROR: Error while setting default options for ldap server: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind_ext(ld, NULL, NULL);
         ld = NULL;
         return NULL;
@@ -786,7 +880,9 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
         debug((char *) "%s| %s: DEBUG: Set SSL defaults\n", LogTime(), PROGRAM);
         rc = ldap_set_ssl_defaults(margs);
         if (rc != LDAP_SUCCESS) {
-            error((char *) "%s| %s: ERROR: Error while setting SSL default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+            error((char *)
+                  "%s| %s: ERROR: Error while setting SSL default options for ldap server: %s\n",
+                  LogTime(), PROGRAM, ldap_err2string(rc));
             ldap_unbind_ext(ld, NULL, NULL);
             ld = NULL;
             return NULL;
@@ -797,7 +893,9 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
          */
         rc = ldap_start_tls_s(ld, NULL, NULL);
         if (rc != LDAP_SUCCESS) {
-            error((char *) "%s| %s: ERROR: Error while setting start_tls for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+            debug((char *)
+                  "%s| %s: WARNING: Error while setting start_tls for ldap server: %s\n",
+                  LogTime(), PROGRAM, ldap_err2string(rc));
             ldap_unbind_ext(ld, NULL, NULL);
             ld = NULL;
             url = (LDAPURLDesc *) xmalloc(sizeof(*url));
@@ -817,7 +915,8 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 #elif HAVE_LDAP_URL_PARSE
             rc = ldap_url_parse(ldapuri, &url);
             if (rc != LDAP_SUCCESS) {
-                error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+                error((char *) "%s| %s: ERROR: Error while parsing url: %s\n",
+                      LogTime(), PROGRAM, ldap_err2string(rc));
                 xfree(ldapuri);
                 ldap_free_urldesc(url);
                 return NULL;
@@ -829,14 +928,18 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             rc = ldap_initialize(&ld, ldapuri);
             xfree(ldapuri);
             if (rc != LDAP_SUCCESS) {
-                error((char *) "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+                error((char *)
+                      "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n",
+                      LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind_ext(ld, NULL, NULL);
                 ld = NULL;
                 return NULL;
             }
             rc = ldap_set_defaults(ld);
             if (rc != LDAP_SUCCESS) {
-                error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+                error((char *)
+                      "%s| %s: ERROR: Error while setting default options for ldap server: %s\n",
+                      LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind_ext(ld, NULL, NULL);
                 ld = NULL;
                 return NULL;
@@ -845,20 +948,25 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 #elif HAVE_LDAPSSL_CLIENT_INIT
         ld = ldapssl_init(host, port, 1);
         if (!ld) {
-            error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
+            error((char *)
+                  "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n",
+                  LogTime(), PROGRAM, ldapssl_err2string(rc));
             ldap_unbind_ext(ld, NULL, NULL);
             ld = NULL;
             return NULL;
         }
         rc = ldap_set_defaults(ld);
         if (rc != LDAP_SUCCESS) {
-            error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+            error((char *)
+                  "%s| %s: ERROR: Error while setting default options for ldap server: %s\n",
+                  LogTime(), PROGRAM, ldap_err2string(rc));
             ldap_unbind_ext(ld, NULL, NULL);
             ld = NULL;
             return NULL;
         }
 #else
-        error((char *) "%s| %s: ERROR: SSL not supported by ldap library\n", LogTime(), PROGRAM);
+        error((char *) "%s| %s: ERROR: SSL not supported by ldap library\n",
+              LogTime(), PROGRAM);
 #endif
     }
     return ld;
@@ -895,21 +1003,28 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
      * Fill Kerberos memory cache with credential from keytab for SASL/GSSAPI
      */
     if (domain) {
-        debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n", LogTime(), PROGRAM);
+        debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n",
+              LogTime(), PROGRAM);
 
 #if HAVE_KRB5
         if (margs->nokerberos) {
             kc = 1;
-            debug((char *) "%s| %s: DEBUG: Kerberos is disabled. Use username/password with ldap url instead\n", LogTime(), PROGRAM);
+            debug((char *)
+                  "%s| %s: DEBUG: Kerberos is disabled. Use username/password with ldap url instead\n",
+                  LogTime(), PROGRAM);
         } else {
             kc = krb5_create_cache(domain);
             if (kc) {
-                error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
+                error((char *)
+                      "%s| %s: ERROR: Error during setup of Kerberos credential cache\n",
+                      LogTime(), PROGRAM);
             }
         }
 #else
         kc = 1;
-        debug((char *) "%s| %s: DEBUG: Kerberos is not supported. Use username/password with ldap url instead\n", LogTime(), PROGRAM);
+        debug((char *)
+              "%s| %s: DEBUG: Kerberos is not supported. Use username/password with ldap url instead\n",
+              LogTime(), PROGRAM);
 #endif
     }
 
@@ -929,13 +1044,17 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     ldap_debug = 0;
     (void) ldap_set_option(NULL, LDAP_OPT_DEBUG_LEVEL, &ldap_debug);
 #endif
-    debug((char *) "%s| %s: DEBUG: Initialise ldap connection\n", LogTime(), PROGRAM);
+    debug((char *) "%s| %s: DEBUG: Initialise ldap connection\n", LogTime(),
+          PROGRAM);
 
     if (domain && !kc) {
         if (margs->ssl) {
-            debug((char *) "%s| %s: DEBUG: Enable SSL to ldap servers\n", LogTime(), PROGRAM);
+            debug((char *) "%s| %s: DEBUG: Enable SSL to ldap servers\n",
+                  LogTime(), PROGRAM);
         }
-        debug((char *) "%s| %s: DEBUG: Canonicalise ldap server name for domain %s\n", LogTime(), PROGRAM, domain);
+        debug((char *)
+              "%s| %s: DEBUG: Canonicalise ldap server name for domain %s\n",
+              LogTime(), PROGRAM, domain);
         /*
          * Loop over list of ldap servers of users domain
          */
@@ -944,7 +1063,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             int port = 389;
             if (hlist[i].port != -1)
                 port = hlist[i].port;
-            debug((char *) "%s| %s: DEBUG: Setting up connection to ldap server %s:%d\n", LogTime(), PROGRAM, hlist[i].host, port);
+            debug((char *)
+                  "%s| %s: DEBUG: Setting up connection to ldap server %s:%d\n",
+                  LogTime(), PROGRAM, hlist[i].host, port);
 
             ld = tool_ldap_open(margs, hlist[i].host, port, margs->ssl);
             if (!ld)
@@ -955,11 +1076,15 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
              */
 
 #if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
-            debug((char *) "%s| %s: DEBUG: Bind to ldap server with SASL/GSSAPI\n", LogTime(), PROGRAM);
+            debug((char *)
+                  "%s| %s: DEBUG: Bind to ldap server with SASL/GSSAPI\n",
+                  LogTime(), PROGRAM);
 
             rc = tool_sasl_bind(ld, bindp, margs->ssl);
             if (rc != LDAP_SUCCESS) {
-                error((char *) "%s| %s: ERROR: Error while binding to ldap server with SASL/GSSAPI: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+                error((char *)
+                      "%s| %s: ERROR: Error while binding to ldap server with SASL/GSSAPI: %s\n",
+                      LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind_ext(ld, NULL, NULL);
                 ld = NULL;
                 continue;
@@ -969,19 +1094,25 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             lcreds->pw = margs->ssl ? xstrdup(margs->ssl) : NULL;
             ldap_set_rebind_proc(ld, ldap_sasl_rebind, (char *) lcreds);
             if (ld != NULL) {
-                debug((char *) "%s| %s: DEBUG: %s initialised %sconnection to ldap server %s:%d\n", LogTime(), PROGRAM, ld ? "Successfully" : "Failed to", margs->ssl ? "SSL protected " : "", hlist[i].host, port);
+                debug((char *)
+                      "%s| %s: DEBUG: %s initialised %sconnection to ldap server %s:%d\n",
+                      LogTime(), PROGRAM, ld ? "Successfully" : "Failed to",
+                      margs->ssl ? "SSL protected " : "", hlist[i].host, port);
                 break;
             }
 #else
             ldap_unbind_ext(ld, NULL, NULL);
             ld = NULL;
-            error((char *) "%s| %s: ERROR: SASL not supported on system\n", LogTime(), PROGRAM);
+            error((char *) "%s| %s: ERROR: SASL not supported on system\n",
+                  LogTime(), PROGRAM);
             continue;
 #endif
         }
         nhosts = free_hostname_list(&hlist, nhosts);
         if (ld == NULL) {
-            debug((char *) "%s| %s: DEBUG: Error during initialisation of ldap connection: %s\n", LogTime(), PROGRAM, strerror(errno));
+            debug((char *)
+                  "%s| %s: DEBUG: Error during initialisation of ldap connection: %s\n",
+                  LogTime(), PROGRAM, strerror(errno));
         }
         bindp = convert_domain_to_bind_path(domain);
     }
@@ -997,9 +1128,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         hostname = strstr(margs->lurl, "://") + 3;
         ssl = strstr(margs->lurl, "ldaps://");
         if (ssl) {
-            debug((char *) "%s| %s: DEBUG: Enable SSL to ldap servers\n", LogTime(), PROGRAM);
+            debug((char *) "%s| %s: DEBUG: Enable SSL to ldap servers\n",
+                  LogTime(), PROGRAM);
         }
-        debug((char *) "%s| %s: DEBUG: Canonicalise ldap server name %s\n", LogTime(), PROGRAM, hostname);
+        debug((char *) "%s| %s: DEBUG: Canonicalise ldap server name %s\n",
+              LogTime(), PROGRAM, hostname);
         /*
          * Loop over list of ldap servers
          */
@@ -1015,8 +1148,8 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         for (size_t i = 0; i < nhosts; ++i) {
             struct berval cred;
             if (margs->lpass) {
-                cred.bv_val=margs->lpass;
-                cred.bv_len=strlen(margs->lpass);
+                cred.bv_val = margs->lpass;
+                cred.bv_len = strlen(margs->lpass);
             }
             ld = tool_ldap_open(margs, hlist[i].host, port, ssl);
             if (!ld)
@@ -1025,10 +1158,15 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
              * ldap bind with username/password authentication
              */
 
-            debug((char *) "%s| %s: DEBUG: Bind to ldap server with Username/Password\n", LogTime(), PROGRAM);
-            rc = ldap_sasl_bind_s(ld, margs->luser, LDAP_SASL_SIMPLE, &cred, NULL, NULL, NULL);
+            debug((char *)
+                  "%s| %s: DEBUG: Bind to ldap server with Username/Password\n",
+                  LogTime(), PROGRAM);
+            rc = ldap_sasl_bind_s(ld, margs->luser, LDAP_SASL_SIMPLE, &cred,
+                                  NULL, NULL, NULL);
             if (rc != LDAP_SUCCESS) {
-                error((char *) "%s| %s: ERROR: Error while binding to ldap server with Username/Password: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+                error((char *)
+                      "%s| %s: ERROR: Error while binding to ldap server with Username/Password: %s\n",
+                      LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind_ext(ld, NULL, NULL);
                 ld = NULL;
                 continue;
@@ -1037,7 +1175,10 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             lcreds->dn = xstrdup(margs->luser);
             lcreds->pw = xstrdup(margs->lpass);
             ldap_set_rebind_proc(ld, ldap_simple_rebind, (char *) lcreds);
-            debug((char *) "%s| %s: DEBUG: %s set up %sconnection to ldap server %s:%d\n", LogTime(), PROGRAM, ld ? "Successfully" : "Failed to", ssl ? "SSL protected " : "", hlist[i].host, port);
+            debug((char *)
+                  "%s| %s: DEBUG: %s set up %sconnection to ldap server %s:%d\n",
+                  LogTime(), PROGRAM, ld ? "Successfully" : "Failed to",
+                  ssl ? "SSL protected " : "", hlist[i].host, port);
             break;
 
         }
@@ -1050,7 +1191,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         }
     }
     if (ld == NULL) {
-        debug((char *) "%s| %s: DEBUG: Error during initialisation of ldap connection: %s\n", LogTime(), PROGRAM, strerror(errno));
+        debug((char *)
+              "%s| %s: DEBUG: Error during initialisation of ldap connection: %s\n",
+              LogTime(), PROGRAM, strerror(errno));
         retval = 0;
         goto cleanup;
     }
@@ -1063,7 +1206,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     margs->AD = 0;
     rc = check_AD(margs, ld);
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error determining ldap server type: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        error((char *)
+              "%s| %s: ERROR: Error determining ldap server type: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind_ext(ld, NULL, NULL);
         ld = NULL;
         retval = 0;
@@ -1082,20 +1227,24 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
     xfree(ldap_filter_esc);
 
-    debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter : %s\n", LogTime(), PROGRAM, bindp, search_exp);
-    rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
-                           search_exp, NULL, 0,
+    debug((char *)
+          "%s| %s: DEBUG: Search ldap server with bind path %s and filter : %s\n",
+          LogTime(), PROGRAM, bindp, search_exp);
+    rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE, search_exp, NULL, 0,
                            NULL, NULL, &searchtime, 0, &res);
     xfree(search_exp);
 
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind_ext(ld, NULL, NULL);
         ld = NULL;
         retval = 0;
         goto cleanup;
     }
-    debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
+    debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM,
+          ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1
+          || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
     if (ldap_count_entries(ld, res) != 0) {
 
@@ -1122,26 +1271,33 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 }
             }
             if (debug_enabled) {
-                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, k + 1, av);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                      " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, k + 1, av);
                 for (unsigned int n = 0; av[n] != '\0'; ++n)
                     fprintf(stderr, "%02x", (unsigned char) av[n]);
                 fprintf(stderr, "\n");
             }
             if (!strcasecmp(group, av)) {
                 retval = 1;
                 if (debug_enabled)
-                    debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
+                    debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                          " \"%s\" matches group name \"%s\"\n", LogTime(),
+                          PROGRAM, k + 1, av, group);
                 else
                     break;
             } else
-                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                      " \"%s\" does not match group name \"%s\"\n", LogTime(),
+                      PROGRAM, k + 1, av, group);
         }
         /*
          * Do recursive group search for AD only since posixgroups can not contain other groups
          */
         if (!retval && margs->AD) {
             if (debug_enabled && max_attr > 0) {
-                debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
+                debug((char *)
+                      "%s| %s: DEBUG: Perform recursive group search\n",
+                      LogTime(), PROGRAM);
             }
             for (size_t j = 0; j < max_attr; ++j) {
                 char *av = NULL;
@@ -1157,7 +1313,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                         }
                     }
                     if (debug_enabled)
-                        debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                        debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                              " group \"%s\" is (in)direct member of group \"%s\"\n",
+                              LogTime(), PROGRAM, j + 1, av, group);
                     else
                         break;
                 }
@@ -1188,7 +1346,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         /*
          * Check for primary Group membership
          */
-        debug((char *) "%s| %s: DEBUG: Search for primary group membership: \"%s\"\n", LogTime(), PROGRAM, group);
+        debug((char *)
+              "%s| %s: DEBUG: Search for primary group membership: \"%s\"\n",
+              LogTime(), PROGRAM, group);
         if (margs->AD)
             filter = (char *) FILTER_AD;
         else
@@ -1202,18 +1362,22 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
         xfree(ldap_filter_esc);
 
-        debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
-        rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
-                               search_exp, NULL, 0,
-                               NULL, NULL, &searchtime, 0, &res);
+        debug((char *)
+              "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n",
+              LogTime(), PROGRAM, bindp, search_exp);
+        rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE, search_exp, NULL,
+                               0, NULL, NULL, &searchtime, 0, &res);
         xfree(search_exp);
 
-        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
+        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(),
+              PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld,
+                      res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
         max_attr = 0;
         if (!rc) {
             if (margs->AD)
-                max_attr = get_attributes(ld, res, ATTRIBUTE_GID_AD, &attr_value);
+                max_attr =
+                    get_attributes(ld, res, ATTRIBUTE_GID_AD, &attr_value);
             else
                 max_attr = get_attributes(ld, res, ATTRIBUTE_GID, &attr_value);
         }
@@ -1226,48 +1390,61 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 char **attr_value_3 = NULL;
                 int *attr_len_3 = NULL;
                 size_t max_attr_3 = 0;
-                uint32_t gid=atoi(attr_value[0]);
+                uint32_t gid = atoi(attr_value[0]);
 
                 /* Get objectsid and search for group
                  * with objectsid = domain(objectsid) + primarygroupid  */
-                debug((char *) "%s| %s: DEBUG: Got primaryGroupID %u\n", LogTime(), PROGRAM, gid);
-                max_attr_3 = get_bin_attributes(ld, res, ATTRIBUTE_SID, &attr_value_3, &attr_len_3);
+                debug((char *) "%s| %s: DEBUG: Got primaryGroupID %u\n",
+                      LogTime(), PROGRAM, gid);
+                max_attr_3 =
+                    get_bin_attributes(ld, res, ATTRIBUTE_SID, &attr_value_3,
+                                       &attr_len_3);
                 ldap_msgfree(res);
                 if (max_attr_3 == 1) {
-                    int len=attr_len_3[0];
+                    int len = attr_len_3[0];
                     if (len < 4) {
-                        debug((char *) "%s| %s: ERROR: Length %d is too short for objectSID\n", LogTime(), PROGRAM, len);
+                        debug((char *)
+                              "%s| %s: ERROR: Length %d is too short for objectSID\n",
+                              LogTime(), PROGRAM, len);
                         rc = 1;
                     } else {
-                        char *se=NULL;
-                        attr_value_3[0][len-1]=((gid>>24) & 0xff);
-                        attr_value_3[0][len-2]=((gid>>16) & 0xff);
-                        attr_value_3[0][len-3]=((gid>>8) & 0xff);
-                        attr_value_3[0][len-4]=((gid>>0) & 0xff);
+                        char *se = NULL;
+                        attr_value_3[0][len - 1] = ((gid >> 24) & 0xff);
+                        attr_value_3[0][len - 2] = ((gid >> 16) & 0xff);
+                        attr_value_3[0][len - 3] = ((gid >> 8) & 0xff);
+                        attr_value_3[0][len - 4] = ((gid >> 0) & 0xff);
 
 #define FILTER_SID_1 "(objectSID="
 #define FILTER_SID_2 ")"
 
-                        se_len = strlen(FILTER_SID_1) + len*3 + strlen(FILTER_SID_2) + 1;
+                        se_len =
+                            strlen(FILTER_SID_1) + len * 3 +
+                            strlen(FILTER_SID_2) + 1;
                         search_exp = (char *) xmalloc(se_len);
-                        snprintf(search_exp, se_len, "%s", FILTER_SID_1 );
+                        snprintf(search_exp, se_len, "%s", FILTER_SID_1);
 
-                        for (int j=0; j<len; j++) {
-                            se=xstrdup(search_exp);
-                            snprintf(search_exp, se_len, "%s\\%02x", se, attr_value_3[0][j] & 0xFF);
+                        for (int j = 0; j < len; j++) {
+                            se = xstrdup(search_exp);
+                            snprintf(search_exp, se_len, "%s\\%02x", se,
+                                     attr_value_3[0][j] & 0xFF);
                             xfree(se);
                         }
-                        se=xstrdup(search_exp);
-                        snprintf(search_exp, se_len, "%s%s", se, FILTER_SID_2 );
+                        se = xstrdup(search_exp);
+                        snprintf(search_exp, se_len, "%s%s", se, FILTER_SID_2);
                         xfree(se);
 
-                        debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
+                        debug((char *)
+                              "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n",
+                              LogTime(), PROGRAM, bindp, search_exp);
                         rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
-                                               search_exp, NULL, 0,
-                                               NULL, NULL, &searchtime, 0, &res);
+                                               search_exp, NULL, 0, NULL, NULL, &searchtime, 0,
+                                               &res);
                         xfree(search_exp);
 
-                        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
+                        debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n",
+                              LogTime(), PROGRAM, ldap_count_entries(ld, res),
+                              ldap_count_entries(ld, res) > 1
+                              || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
                     }
                 } else {
@@ -1295,18 +1472,21 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
                 xfree(ldap_filter_esc);
 
-                debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
+                debug((char *)
+                      "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n",
+                      LogTime(), PROGRAM, bindp, search_exp);
                 rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
-                                       search_exp, NULL, 0,
-                                       NULL, NULL, &searchtime, 0, &res);
+                                       search_exp, NULL, 0, NULL, NULL, &searchtime, 0, &res);
                 xfree(search_exp);
             }
 
             if (!rc) {
                 if (margs->AD)
-                    max_attr_2 = get_attributes(ld, res, ATTRIBUTE_DN, &attr_value_2);
+                    max_attr_2 =
+                        get_attributes(ld, res, ATTRIBUTE_DN, &attr_value_2);
                 else
-                    max_attr_2 = get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
+                    max_attr_2 =
+                        get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
                 ldap_msgfree(res);
             } else {
                 ldap_msgfree(res);
@@ -1327,17 +1507,23 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 }
                 if (!strcasecmp(group, av)) {
                     retval = 1;
-                    debug((char *) "%s| %s: DEBUG: \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, av, group);
+                    debug((char *)
+                          "%s| %s: DEBUG: \"%s\" matches group name \"%s\"\n",
+                          LogTime(), PROGRAM, av, group);
                 } else
-                    debug((char *) "%s| %s: DEBUG: \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, av, group);
+                    debug((char *)
+                          "%s| %s: DEBUG: \"%s\" does not match group name \"%s\"\n",
+                          LogTime(), PROGRAM, av, group);
 
             }
             /*
              * Do recursive group search for AD only since posixgroups can not contain other groups
              */
             if (!retval && margs->AD) {
                 if (debug_enabled && max_attr_2 > 0) {
-                    debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
+                    debug((char *)
+                          "%s| %s: DEBUG: Perform recursive group search\n",
+                          LogTime(), PROGRAM);
                 }
                 for (size_t j = 0; j < max_attr_2; ++j) {
                     char *av = NULL;
@@ -1353,7 +1539,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                             }
                         }
                         if (debug_enabled) {
-                            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE
+                                  " group \"%s\" is (in)direct member of group \"%s\"\n",
+                                  LogTime(), PROGRAM, j + 1, av, group);
                         } else {
                             break;
                         }
@@ -1371,11 +1559,15 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 safe_free(attr_value_2);
             }
 
-            debug((char *) "%s| %s: DEBUG: Users primary group %s %s\n", LogTime(), PROGRAM, retval ? "matches" : "does not match", group);
+            debug((char *) "%s| %s: DEBUG: Users primary group %s %s\n",
+                  LogTime(), PROGRAM, retval ? "matches" : "does not match",
+                  group);
 
         } else {
             ldap_msgfree(res);
-            debug((char *) "%s| %s: DEBUG: Did not find ldap entry for group %s\n", LogTime(), PROGRAM, group);
+            debug((char *)
+                  "%s| %s: DEBUG: Did not find ldap entry for group %s\n",
+                  LogTime(), PROGRAM, group);
         }
         /*
          * Cleanup
@@ -1390,7 +1582,8 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     rc = ldap_unbind_ext(ld, NULL, NULL);
     ld = NULL;
     if (rc != LDAP_SUCCESS) {
-        error((char *) "%s| %s: ERROR: Error unbind ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
+        error((char *) "%s| %s: ERROR: Error unbind ldap server: %s\n",
+              LogTime(), PROGRAM, ldap_err2string(rc));
     }
     debug((char *) "%s| %s: DEBUG: Unbind ldap server\n", LogTime(), PROGRAM);
 cleanup:
@@ -34,6 +34,9 @@ CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &svcCfg):
     AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(svcCfg),
     sslContext(NULL),
+#if USE_OPENSSL
+    sslSession(NULL),
+#endif
     theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
@@ -111,7 +111,9 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     virtual void noteAdaptationAnswer(const Answer &answer);
 
     Security::ContextPtr sslContext;
-    Security::SessionStatePointer sslSession;
+#if USE_OPENSSL
+    SSL_SESSION *sslSession;
+#endif
 
 private:
     // stores Prepare() callback info
@@ -30,26 +30,26 @@
 #include "icap_log.h"
 #include "ipcache.h"
 #include "pconn.h"
+#include "security/PeerConnector.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 
-#if USE_OPENSSL
-/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+/// Gives Security::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
 class MyIcapAnswerDialer: public UnaryMemFunT<Adaptation::Icap::Xaction, Security::EncryptorAnswer, Security::EncryptorAnswer&>,
-    public Ssl::PeerConnector::CbDialer
+    public Security::PeerConnector::CbDialer
 {
 public:
     MyIcapAnswerDialer(const JobPointer &aJob, Method aMethod):
         UnaryMemFunT<Adaptation::Icap::Xaction, Security::EncryptorAnswer, Security::EncryptorAnswer&>(aJob, aMethod, Security::EncryptorAnswer()) {}
 
-    /* Ssl::PeerConnector::CbDialer API */
+    /* Security::PeerConnector::CbDialer API */
     virtual Security::EncryptorAnswer &answer() { return arg1; }
 };
 
 namespace Ssl
 {
 /// A simple PeerConnector for Secure ICAP services. No SslBump capabilities.
-class IcapPeerConnector: public PeerConnector {
+class IcapPeerConnector: public Security::PeerConnector {
     CBDATA_CLASS(IcapPeerConnector);
 public:
     IcapPeerConnector(
@@ -61,8 +61,8 @@ class IcapPeerConnector: public PeerConnector {
         AsyncJob("Ssl::IcapPeerConnector"),
         PeerConnector(aServerConn, aCallback, alp, timeout), icapService(service) {}
 
-    /* PeerConnector API */
-    virtual Security::SessionPtr initializeSsl();
+    /* Security::PeerConnector API */
+    virtual bool initializeTls(Security::SessionPointer &);
     virtual void noteNegotiationDone(ErrorState *error);
     virtual Security::ContextPtr getSslContext() {return icapService->sslContext;}
 
@@ -72,7 +72,6 @@ class IcapPeerConnector: public PeerConnector {
 } // namespace Ssl
 
 CBDATA_NAMESPACED_CLASS_INIT(Ssl, IcapPeerConnector);
-#endif
 
 Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::ServiceRep::Pointer &aService):
     AsyncJob(aTypeName),
@@ -302,7 +301,6 @@ void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
                         CloseDialer(this,&Adaptation::Icap::Xaction::noteCommClosed));
     comm_add_close_handler(io.conn->fd, closer);
 
-#if USE_OPENSSL
     // If it is a reused connection and the SSL object is build
     // we should not negotiate new SSL session
     const auto &ssl = fd_table[io.conn->fd].ssl;
@@ -311,13 +309,10 @@ void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
         securer = asyncCall(93, 4, "Adaptation::Icap::Xaction::handleSecuredPeer",
                             MyIcapAnswerDialer(me, &Adaptation::Icap::Xaction::handleSecuredPeer));
 
-        Ssl::PeerConnector::HttpRequestPointer tmpReq(NULL);
-        Ssl::IcapPeerConnector *sslConnector =
-            new Ssl::IcapPeerConnector(theService, io.conn, securer, masterLogEntry(), TheConfig.connect_timeout(service().cfg().bypass));
+        auto *sslConnector = new Ssl::IcapPeerConnector(theService, io.conn, securer, masterLogEntry(), TheConfig.connect_timeout(service().cfg().bypass));
         AsyncJob::Start(sslConnector); // will call our callback
         return;
     }
-#endif
 
 // ??    fd_table[io.conn->fd].noteUse(icapPconnPool);
     service().noteConnectionUse(connection);
@@ -709,25 +704,28 @@ bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &) const
     return false;
 }
 
-#if USE_OPENSSL
-Security::SessionPtr
-Ssl::IcapPeerConnector::initializeSsl()
+bool
+Ssl::IcapPeerConnector::initializeTls(Security::SessionPointer &serverSession)
 {
-    auto ssl = Ssl::PeerConnector::initializeSsl();
-    if (!ssl)
-        return nullptr;
+    if (!Security::PeerConnector::initializeTls(serverSession))
+        return false;
 
+#if USE_OPENSSL
     assert(!icapService->cfg().secure.sslDomain.isEmpty());
     SBuf *host = new SBuf(icapService->cfg().secure.sslDomain);
-    SSL_set_ex_data(ssl, ssl_ex_index_server, host);
+    SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
 
-    ACLFilledChecklist *check = (ACLFilledChecklist *)SSL_get_ex_data(ssl, ssl_ex_index_cert_error_check);
+    ACLFilledChecklist *check = static_cast<ACLFilledChecklist *>(SSL_get_ex_data(serverSession.get(), ssl_ex_index_cert_error_check));
     if (check)
         check->dst_peer_name = *host;
 
-    Security::GetSessionResumeData(Security::SessionPointer(ssl), icapService->sslSession);
+    if (icapService->sslSession)
+        SSL_set_session(serverSession.get(), icapService->sslSession);
 
-    return ssl;
+    return true;
+#else
+    return false;
+#endif
 }
 
 void
@@ -736,8 +734,16 @@ Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
     if (error)
         return;
 
+#if USE_OPENSSL
     const int fd = serverConnection()->fd;
-    Security::GetSessionResumeData(fd_table[fd].ssl, icapService->sslSession);
+    auto ssl = fd_table[fd].ssl.get();
+    assert(ssl);
+    if (!SSL_session_reused(ssl)) {
+        if (icapService->sslSession)
+            SSL_SESSION_free(icapService->sslSession);
+        icapService->sslSession = SSL_get1_session(ssl);
+    }
+#endif
 }
 
 void
@@ -770,5 +776,4 @@ Adaptation::Icap::Xaction::handleSecuredPeer(Security::EncryptorAnswer &answer)
 
     handleCommConnected();
 }
-#endif
 
@@ -16,9 +16,6 @@
 #include "HttpReply.h"
 #include "ipcache.h"
 #include "sbuf/SBuf.h"
-#if USE_OPENSSL
-#include "ssl/PeerConnector.h"
-#endif
 
 class MemBuf;
 
@@ -61,7 +61,11 @@ Database contains plain-text passwords
 
 =item B<--md5>
 
-Database contains unsalted md5 passwords
+Database contains unsalted MD5 passwords
+
+=item B<--sha1>
+
+Database contains unsalted SHA1 passwords
 
 =item B<--salt>
 
@@ -127,6 +131,7 @@ The Squid Configuration Manual http://www.squid-cache.org/Doc/config/
 
 use DBI;
 use Digest::MD5 qw(md5 md5_hex md5_base64);
+use Digest::SHA qw(sha1 sha1_hex sha1_base64);
 
 my $dsn = "DBI:mysql:database=squid";
 my $db_user = undef;
@@ -137,6 +142,7 @@ my $db_passwdcol = "password";
 my $db_cond = "enabled = 1";
 my $plaintext = 0;
 my $md5 = 0;
+my $sha1 = 0;
 my $persist = 0;
 my $isjoomla = 0;
 my $debug = 0;
@@ -152,6 +158,7 @@ GetOptions(
 	'cond=s' => \$db_cond,
 	'plaintext' => \$plaintext,
 	'md5' => \$md5,
+	'sha1' => \$sha1,
 	'persist' => \$persist,
 	'joomla' => \$isjoomla,
 	'debug' => \$debug,
@@ -174,7 +181,7 @@ sub open_db()
     return $_sth if defined $_sth;
     $_dbh = DBI->connect($dsn, $db_user, $db_passwd);
     if (!defined $_dbh) {
-    	warn ("Could not connect to $dsn\n");
+	warn ("Could not connect to $dsn\n");
 	my @driver_names = DBI->available_drivers();
 	my $msg = "DSN drivers apparently installed, available:\n";
 	foreach my $dn (@driver_names) {
@@ -203,6 +210,7 @@ sub check_password($$)
         return 1 if defined $hashsalt && crypt($password, $hashsalt) eq $key;
         return 1 if crypt($password, $key) eq $key;
         return 1 if $md5 && md5_hex($password) eq $key;
+        return 1 if $sha1 && sha1_hex($password) eq $key;
         return 1 if $plaintext && $password eq $key;
     }
 
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef _SQUID_SRC_BASE_HARDFUN_H
+#define _SQUID_SRC_BASE_HARDFUN_H
+
+/**
+ * A functor that calls a hard-coded unary function.
+ */
+template <class ReturnType, class ArgType, ReturnType (*fun)(ArgType)>
+struct HardFun {
+    ReturnType operator()(ArgType arg) { fun(arg); }
+};
+
+#endif /* _SQUID_SRC_BASE_HARDFUN_H */
+
@@ -25,6 +25,7 @@ libbase_la_SOURCES = \
 	CharacterSet.h \
 	CharacterSet.cc \
 	EnumIterator.h \
+	HardFun.h \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
@@ -38,5 +39,4 @@ libbase_la_SOURCES = \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	TidyPointer.h \
 	YesNoNone.h
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_BASE_TIDYPOINTER_H
-#define SQUID_BASE_TIDYPOINTER_H
-
-/**
- * A pointer that deletes the object it points to when the pointer's owner or
- * context is gone. Similar to std::unique_ptr but without confusing assignment
- * and with a customizable cleanup method. Prevents memory leaks in
- * the presence of exceptions and processing short cuts.
-*/
-template <typename T, void (*DeAllocator)(T *t)> class TidyPointer
-{
-public:
-    /// Delete callback.
-    typedef void DCB (T *t);
-    TidyPointer(T *t = NULL)
-        :   raw(t) {}
-public:
-    bool operator !() const { return !raw; }
-    explicit operator bool() const { return raw; }
-    T* operator ->() const { return get(); }
-
-    /// Returns raw and possibly NULL pointer
-    T *get() const { return raw; }
-
-    /// Reset raw pointer - delete last one and save new one.
-    void reset(T *t) {
-        deletePointer();
-        raw = t;
-    }
-
-    /// Forget the raw pointer without freeing it. Become a nil pointer.
-    T *release() {
-        T *ret = raw;
-        raw = NULL;
-        return ret;
-    }
-    /// Deallocate raw pointer.
-    ~TidyPointer() {
-        deletePointer();
-    }
-private:
-    /// Forbidden copy constructor.
-    TidyPointer(TidyPointer<T, DeAllocator> const &);
-    /// Forbidden assigment operator.
-    TidyPointer <T, DeAllocator> & operator = (TidyPointer<T, DeAllocator> const &);
-    /// Deallocate raw pointer. Become a nil pointer.
-    void deletePointer() {
-        if (raw) {
-            DeAllocator(raw);
-        }
-        raw = NULL;
-    }
-    T *raw; ///< pointer to T object or NULL
-};
-
-/// DeAllocator for pointers that need free(3) from the std C library
-template<typename T> void tidyFree(T *p)
-{
-    xfree(p);
-}
-
-#endif // SQUID_BASE_TIDYPOINTER_H
-
@@ -2204,6 +2204,8 @@ parse_peer(CachePeer ** head)
 #endif
         } else if (strncmp(token, "tls-", 4) == 0) {
             p->secure.parse(token+4);
+        } else if (strncmp(token, "tls", 3) == 0) {
+            p->secure.parse(token+3);
         } else if (strcmp(token, "front-end-https") == 0) {
             p->front_end_https = 1;
         } else if (strcmp(token, "front-end-https=on") == 0) {
@@ -3308,7 +3308,7 @@ DOC_START
 	
 	==== SSL / HTTPS / TLS OPTIONS ====
 	
-	ssl		Encrypt connections to this peer with SSL/TLS.
+	tls		Encrypt connections to this peer with TLS.
 	
 	sslcert=/path/to/ssl/certificate
 			A client SSL certificate to use when connecting to
@@ -6200,13 +6200,29 @@ DOC_START
        potentially cachable requests for the same URI before Squid knows
        whether the response is going to be cachable.
 
-       This feature is disabled by default: Enabling collapsed forwarding
-       needlessly delays forwarding requests that look cachable (when they are
-       collapsed) but then need to be forwarded individually anyway because
-       they end up being for uncachable content. However, in some cases, such
-       as accelleration of highly cachable content with periodic or groupped
-       expiration times, the gains from collapsing [large volumes of
-       simultenous refresh requests] outweigh losses from such delays.
+       When enabled, instead of forwarding each concurrent request for
+       the same URL, Squid just sends the first of them. The other, so
+       called "collapsed" requests, wait for the response to the first
+       request and, if it happens to be cachable, use that response.
+       Here, "concurrent requests" means "received after the first
+       request headers were parsed and before the corresponding response
+       headers were parsed".
+
+       This feature is disabled by default: enabling collapsed
+       forwarding needlessly delays forwarding requests that look
+       cachable (when they are collapsed) but then need to be forwarded
+       individually anyway because they end up being for uncachable
+       content. However, in some cases, such as acceleration of highly
+       cachable content with periodic or grouped expiration times, the
+       gains from collapsing [large volumes of simultaneous refresh
+       requests] outweigh losses from such delays.
+
+       Squid collapses two kinds of requests: regular client requests
+       received on one of the listening ports and internal "cache
+       revalidation" requests which are triggered by those regular
+       requests hitting a stale cached object. Revalidation collapsing
+       is currently disabled for Squid instances containing SMP-aware
+       disk or memory caches and for Vary-controlled cached objects.
 DOC_END
 
 NAME: collapsed_forwarding_shared_entries_limit
@@ -12,7 +12,6 @@
 #define SQUID_CLIENT_DB_H_
 
 #include "anyp/ProtocolType.h"
-//#include "enums.h"
 #include "ip/Address.h"
 #include "LogTags.h"
 
@@ -584,6 +584,8 @@ void
 ConnStateData::swanSong()
 {
     debugs(33, 2, HERE << clientConnection);
+    checkLogging();
+
     flags.readMore = false;
     DeregisterRunner(this);
     clientdbEstablished(clientConnection->remote, -1);  /* decrement */
@@ -2141,10 +2143,6 @@ ConnStateData::clientParseRequests()
     // On errors, bodyPipe may become nil, but readMore will be cleared
     while (!inBuf.isEmpty() && !bodyPipe && flags.readMore) {
 
-        /* Don't try to parse if the buffer is empty */
-        if (inBuf.isEmpty())
-            break;
-
         /* Limit the number of concurrent requests */
         if (concurrentRequestQueueFilled())
             break;
@@ -2577,16 +2575,16 @@ httpAccept(const CommAcceptCbParams &params)
 #if USE_OPENSSL
 
 /** Create SSL connection structure and update fd_table */
-static Security::SessionPtr
+static bool
 httpsCreate(const Comm::ConnectionPointer &conn, Security::ContextPtr sslContext)
 {
-    if (auto ssl = Ssl::CreateServer(sslContext, conn->fd, "client https start")) {
+    if (Ssl::CreateServer(sslContext, conn, "client https start")) {
         debugs(33, 5, "will negotate SSL on " << conn);
-        return ssl;
+        return true;
     }
 
     conn->close();
-    return nullptr;
+    return false;
 }
 
 /**
@@ -2657,7 +2655,7 @@ clientNegotiateSSL(int fd, void *data)
         return;
     }
 
-    if (Security::SessionIsResumed(fd_table[fd].ssl)) {
+    if (SSL_session_reused(ssl)) {
         debugs(83, 2, "clientNegotiateSSL: Session " << SSL_get_session(ssl) <<
                " reused on FD " << fd << " (" << fd_table[fd].ipaddr << ":" << (int)fd_table[fd].remote_port << ")");
     } else {
@@ -2732,11 +2730,10 @@ clientNegotiateSSL(int fd, void *data)
 static void
 httpsEstablish(ConnStateData *connState, Security::ContextPtr sslContext)
 {
-    Security::SessionPtr ssl = nullptr;
     assert(connState);
     const Comm::ConnectionPointer &details = connState->clientConnection;
 
-    if (!sslContext || !(ssl = httpsCreate(details, sslContext)))
+    if (!sslContext || !httpsCreate(details, sslContext))
         return;
 
     typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
@@ -4031,3 +4028,36 @@ ConnStateData::unpinConnection(const bool andClose)
      * connection has gone away */
 }
 
+void
+ConnStateData::checkLogging()
+{
+    // if we are parsing request body, its request is responsible for logging
+    if (bodyPipe)
+        return;
+
+    // a request currently using this connection is responsible for logging
+    if (!pipeline.empty() && pipeline.back()->mayUseConnection())
+        return;
+
+    /* Either we are waiting for the very first transaction, or
+     * we are done with the Nth transaction and are waiting for N+1st.
+     * XXX: We assume that if anything was added to inBuf, then it could
+     * only be consumed by actions already covered by the above checks.
+     */
+
+    // do not log connections that closed after a transaction (it is normal)
+    // TODO: access_log needs ACLs to match received-no-bytes connections
+    // XXX: TLS may return here even though we got no transactions yet
+    // XXX: PROXY protocol may return here even though we got no
+    // transactions yet
+    if (receivedFirstByte_ && inBuf.isEmpty())
+        return;
+
+    /* Create a temporary ClientHttpRequest object. Its destructor will log. */
+    ClientHttpRequest http(this);
+    http.req_sz = inBuf.length();
+    char const *uri = "error:transaction-end-before-headers";
+    http.uri = xstrdup(uri);
+    setLogUri(&http, uri);
+}
+
@@ -329,6 +329,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
 private:
     /* ::Server API */
     virtual bool connFinishedWithConn(int size);
+    virtual void checkLogging();
 
     void clientAfterReadingRequests();
     bool concurrentRequestQueueFilled() const;
@@ -89,7 +89,8 @@ clientReplyContext::clientReplyContext(ClientHttpRequest *clientContext) :
     reply(NULL),
     old_entry(NULL),
     old_sc(NULL),
-    deleting(false)
+    deleting(false),
+    collapsedRevalidation(crNone)
 {
     *tempbuf = 0;
 }
@@ -264,7 +265,6 @@ void
 clientReplyContext::processExpired()
 {
     const char *url = storeId();
-    StoreEntry *entry = NULL;
     debugs(88, 3, "clientReplyContext::processExpired: '" << http->uri << "'");
     assert(http->storeEntry()->lastmod >= 0);
     /*
@@ -287,9 +287,36 @@ clientReplyContext::processExpired()
 #endif
     /* Prepare to make a new temporary request */
     saveState();
-    entry = storeCreateEntry(url,
-                             http->log_uri, http->request->flags, http->request->method);
-    /* NOTE, don't call StoreEntry->lock(), storeCreateEntry() does it */
+
+    // TODO: support collapsed revalidation for Vary-controlled entries
+    const bool collapsingAllowed = Config.onoff.collapsed_forwarding &&
+                                   !Store::Root().smpAware() &&
+                                   http->request->vary_headers.isEmpty();
+
+    StoreEntry *entry = nullptr;
+    if (collapsingAllowed) {
+        if ((entry = storeGetPublicByRequest(http->request, ksRevalidation)))
+            entry->lock("clientReplyContext::processExpired#alreadyRevalidating");
+    }
+
+    if (entry) {
+        debugs(88, 5, "collapsed on existing revalidation entry: " << *entry);
+        collapsedRevalidation = crSlave;
+    } else {
+        entry = storeCreateEntry(url,
+                                 http->log_uri, http->request->flags, http->request->method);
+        /* NOTE, don't call StoreEntry->lock(), storeCreateEntry() does it */
+
+        if (collapsingAllowed) {
+            debugs(88, 5, "allow other revalidation requests to collapse on " << *entry);
+            Store::Root().allowCollapsing(entry, http->request->flags,
+                                          http->request->method);
+            collapsedRevalidation = crInitiator;
+        } else {
+            collapsedRevalidation = crNone;
+        }
+    }
+
     sc = storeClientListAdd(entry, this);
 #if USE_DELAY_POOLS
     /* delay_id is already set on original store client */
@@ -309,13 +336,14 @@ clientReplyContext::processExpired()
     assert(http->out.offset == 0);
     assert(http->request->clientConnectionManager == http->getConn());
 
-    /*
-     * A refcounted pointer so that FwdState stays around as long as
-     * this clientReplyContext does
-     */
-    Comm::ConnectionPointer conn = http->getConn() != NULL ? http->getConn()->clientConnection : NULL;
-    FwdState::Start(conn, http->storeEntry(), http->request, http->al);
-
+    if (collapsedRevalidation != crSlave) {
+        /*
+         * A refcounted pointer so that FwdState stays around as long as
+         * this clientReplyContext does
+         */
+        Comm::ConnectionPointer conn = http->getConn() != NULL ? http->getConn()->clientConnection : NULL;
+        FwdState::Start(conn, http->storeEntry(), http->request, http->al);
+    }
     /* Register with storage manager to receive updates when data comes in. */
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED))
@@ -427,6 +455,10 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
         // forward response from origin
         http->logType = LOG_TCP_REFRESH_MODIFIED;
         debugs(88, 3, "handleIMSReply: origin replied " << status << ", replacing existing entry and forwarding to client");
+
+        if (collapsedRevalidation)
+            http->storeEntry()->clearPublicKeyScope();
+
         sendClientUpstreamResponse();
     }
 
@@ -133,6 +133,14 @@ class clientReplyContext : public RefCountable, public StoreClient
     StoreEntry *old_entry;
     store_client *old_sc;   /* ... for entry to be validated */
     bool deleting;
+
+    typedef enum {
+        crNone = 0, ///< collapsed revalidation is not allowed for this context
+        crInitiator, ///< we initiated collapsed revalidation request
+        crSlave ///< we collapsed on the existing revalidation request
+    } CollapsedRevalidation;
+
+    CollapsedRevalidation collapsedRevalidation;
 };
 
 #endif /* SQUID_CLIENTSIDEREPLY_H */
@@ -177,7 +177,7 @@ ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
 #if USE_OPENSSL
         if (aConn->clientConnection != NULL && aConn->clientConnection->isOpen()) {
             if (auto ssl = fd_table[aConn->clientConnection->fd].ssl.get())
-                al->cache.sslClientCert.reset(SSL_get_peer_certificate(ssl));
+                al->cache.sslClientCert.resetWithoutLocking(SSL_get_peer_certificate(ssl));
         }
 #endif
     }
@@ -885,8 +885,7 @@ clientRedirectAccessCheckDone(allow_t answer, void *data)
     if (answer == ACCESS_ALLOWED)
         redirectStart(http, clientRedirectDoneWrapper, context);
     else {
-        Helper::Reply nilReply;
-        nilReply.result = Helper::Error;
+        Helper::Reply const nilReply(Helper::Error);
         context->clientRedirectDone(nilReply);
     }
 }
@@ -918,8 +917,7 @@ clientStoreIdAccessCheckDone(allow_t answer, void *data)
         storeIdStart(http, clientStoreIdDoneWrapper, context);
     else {
         debugs(85, 3, "access denied expected ERR reply handling: " << answer);
-        Helper::Reply nilReply;
-        nilReply.result = Helper::Error;
+        Helper::Reply const nilReply(Helper::Error);
         context->clientStoreIdDone(nilReply);
     }
 }
@@ -314,6 +314,11 @@ Ftp::Client::scheduleReadControlReply(int buffered_ok)
         /* We've already read some reply data */
         handleControlReply();
     } else {
+
+        if (!Comm::IsConnOpen(ctrl.conn)) {
+            debugs(9, 3, "cannot read without ctrl " << ctrl.conn);
+            return;
+        }
         /*
          * Cancel the timeout on the Data socket (if any) and
          * establish one on the control socket.
@@ -838,7 +838,7 @@ void
 comm_close_complete(const FdeCbParams &params)
 {
     fde *F = &fd_table[params.fd];
-    F->ssl.reset(nullptr);
+    F->ssl.resetWithoutLocking(nullptr);
 
 #if USE_OPENSSL
     if (F->dynamicSslContext) {
@@ -20,7 +20,6 @@
 #include "fde.h"
 #include "sbuf/SBuf.h"
 #include "StatCounters.h"
-//#include "tools.h"
 
 // Does comm check this fd for read readiness?
 // Note that when comm is not monitoring, there can be a pending callback
@@ -9,6 +9,7 @@
 /* DEBUG: section 05    Listener Socket Handler */
 
 #include "squid.h"
+#include "acl/FilledChecklist.h"
 #include "anyp/PortCfg.h"
 #include "base/TextException.h"
 #include "client_db.h"
@@ -24,6 +25,7 @@
 #include "globals.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
+#include "log/access_log.h"
 #include "MasterXaction.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
@@ -256,6 +258,18 @@ Comm::TcpAcceptor::okToAccept()
     return false;
 }
 
+static void
+logAcceptError(const Comm::ConnectionPointer &conn)
+{
+    AccessLogEntry::Pointer al = new AccessLogEntry;
+    al->tcpClient = conn;
+    al->url = "error:accept-client-connection";
+    ACLFilledChecklist ch(nullptr, nullptr, nullptr);
+    ch.src_addr = conn->remote;
+    ch.my_addr = conn->local;
+    accessLogLog(al, &ch);
+}
+
 void
 Comm::TcpAcceptor::acceptOne()
 {
@@ -281,6 +295,8 @@ Comm::TcpAcceptor::acceptOne()
 
         // A non-recoverable error; notify the caller */
         debugs(5, 5, HERE << "non-recoverable error:" << status() << " handler Subscription: " << theCallSub);
+        if (intendedForUserConnections())
+            logAcceptError(newConnDetails);
         notify(flag, newConnDetails);
         mustStop("Listener socket closed");
         return;
@@ -104,6 +104,8 @@ class TcpAcceptor : public AsyncJob
     Comm::Flag oldAccept(Comm::ConnectionPointer &details);
     void setListen();
     void handleClosure(const CommCloseCbParams &io);
+    /// whether we are listening on one of the squid.conf *ports
+    bool intendedForUserConnections() const { return bool(listenPort_); }
 };
 
 } // namespace Comm
@@ -167,7 +167,7 @@ class fde
         halfClosedReader = NULL;
         read_method = NULL;
         write_method = NULL;
-        ssl.reset(nullptr);
+        ssl.resetWithoutLocking(nullptr);
         dynamicSslContext = NULL;
 #if _SQUID_WINDOWS_
         win32.handle = (long)NULL;
@@ -10,8 +10,8 @@
 #define SQUID_SRC_FORMAT_CONFIG_H
 
 #include "format/Format.h"
-//#include "format/TokenTableEntry.h"
 #include "SquidString.h"
+
 #include <list>
 
 class StoreEntry;
@@ -9,7 +9,6 @@
 #ifndef _SQUID_FORMAT_TOKEN_H
 #define _SQUID_FORMAT_TOKEN_H
 
-//#include "format/TokenTableEntry.h"
 #include "format/ByteCode.h"
 
 /*
@@ -47,6 +47,7 @@ class SwapDir: public ::SwapDir, public IORequestor, public Ipc::StoreMapCleaner
     virtual void swappedOut(const StoreEntry &e);
     virtual void create();
     virtual void parse(int index, char *path);
+    virtual bool smpAware() const { return true; }
 
     // temporary path to the shared memory map of first slots of cached entries
     SBuf inodeMapPath() const;
@@ -15,7 +15,6 @@
 #include "DiskIO/WriteRequest.h"
 #include "Generic.h"
 #include "SquidConfig.h"
-#include "SquidList.h"
 #include "Store.h"
 #include "store/Disk.h"
 #include "UFSStoreState.h"
@@ -132,8 +131,9 @@ Fs::Ufs::UFSStoreState::read_(char *buf, size_t size, off_t aOffset, STRCB * aCa
     assert (aCallback);
 
     if (!theFile->canRead()) {
-        debugs(79, 3, "UFSStoreState::read_: queueing read because theFile can't read");
-        queueRead (buf, size, aOffset, aCallback, aCallbackData);
+        debugs(79, 3, "queueing read because theFile can't read");
+        assert(opening);
+        pending_reads.emplace(buf, size, aOffset, aCallback, aCallbackData);
         return;
     }
 
@@ -177,7 +177,8 @@ Fs::Ufs::UFSStoreState::write(char const *buf, size_t size, off_t aOffset, FREE
         return false;
     }
 
-    queueWrite(buf, size, aOffset, free_func);
+    debugs(79, 3, (void*)this << " queueing write of size " << size);
+    pending_writes.emplace(buf, size, aOffset, free_func);
     drainWriteQueue();
     return true;
 }
@@ -191,28 +192,20 @@ Fs::Ufs::UFSStoreState::write(char const *buf, size_t size, off_t aOffset, FREE
 void
 Fs::Ufs::UFSStoreState::doWrite()
 {
-    debugs(79, 3, HERE << this << " UFSStoreState::doWrite");
+    debugs(79, 3, (void*)this);
 
     assert(theFile->canWrite());
 
-    _queued_write *q = (_queued_write *)linklistShift(&pending_writes);
-
-    if (q == NULL) {
-        debugs(79, 3, HERE << this << " UFSStoreState::doWrite queue is empty");
+    if (pending_writes.empty()) {
+        debugs(79, 3, (void*)this << " write queue is empty");
         return;
     }
 
+    auto &q = pending_writes.front();
+
     if (theFile->error()) {
-        debugs(79, DBG_IMPORTANT,HERE << "avoid write on theFile with error");
-        debugs(79,3,HERE << "calling free_func for " << (void*) q->buf);
-        /*
-         * DPW 2006-05-24
-         * Note "free_func" is memNodeWriteComplete(), which doesn't
-         * really free the memory.  Instead it clears the node's
-         * write_pending flag.
-         */
-        q->free_func((void*)q->buf);
-        delete q;
+        debugs(79, DBG_IMPORTANT, MYNAME << " avoid write on theFile with error");
+        pending_writes.pop();
         return;
     }
 
@@ -226,10 +219,11 @@ Fs::Ufs::UFSStoreState::doWrite()
      * coming in.  For now let's just not use the writing flag at
      * all.
      */
-    debugs(79, 3, HERE << this << " calling theFile->write(" << q->size << ")");
+    debugs(79, 3, (void*)this << " calling theFile->write(" << q.size << ")");
 
-    theFile->write(new WriteRequest(q->buf, q->offset, q->size, q->free_func));
-    delete q;
+    theFile->write(new WriteRequest(q.buf, q.offset, q.size, q.free_func));
+    q.buf = nullptr; // prevent buf deletion on pop, its used by the above object
+    pending_writes.pop();
 }
 
 void
@@ -338,8 +332,6 @@ Fs::Ufs::UFSStoreState::UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB
     closing(false),
     reading(false),
     writing(false),
-    pending_reads(NULL),
-    pending_writes(NULL),
     read_buf(NULL)
 {
     // StoreIOState inherited members
@@ -354,71 +346,44 @@ Fs::Ufs::UFSStoreState::UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB
 
 Fs::Ufs::UFSStoreState::~UFSStoreState()
 {
-    assert(pending_reads == NULL);
-    assert(pending_writes == NULL);
+    assert(pending_reads.empty());
+    assert(pending_writes.empty());
 }
 
 void
 Fs::Ufs::UFSStoreState::freePending()
 {
-    _queued_read *qr;
-
-    while ((qr = (_queued_read *)linklistShift(&pending_reads))) {
-        cbdataReferenceDone(qr->callback_data);
-        delete qr;
-    }
-
-    debugs(79,3,HERE << "UFSStoreState::freePending: freed pending reads");
+    while (!pending_reads.empty())
+        pending_reads.pop();
+    debugs(79, 3, "freed pending reads");
 
-    _queued_write *qw;
-
-    while ((qw = (_queued_write *)linklistShift(&pending_writes))) {
-        if (qw->free_func)
-            qw->free_func(const_cast<char *>(qw->buf));
-        delete qw;
-    }
-
-    debugs(79,3,HERE << "UFSStoreState::freePending: freed pending writes");
+    while (!pending_writes.empty())
+        pending_writes.pop();
+    debugs(79, 3, "freed pending writes");
 }
 
 bool
 Fs::Ufs::UFSStoreState::kickReadQueue()
 {
-    _queued_read *q = (_queued_read *)linklistShift(&pending_reads);
-
-    if (NULL == q)
+    if (pending_reads.empty())
         return false;
 
-    debugs(79, 3, "UFSStoreState::kickReadQueue: reading queued request of " << q->size << " bytes");
+    auto &q = pending_reads.front();
 
-    void *cbdata;
+    debugs(79, 3, "reading queued request of " << q.size << " bytes");
 
-    if (cbdataReferenceValidDone(q->callback_data, &cbdata)) {
-        read_(q->buf, q->size, q->offset, q->callback, cbdata);
+    bool result = true;
+    void *cbdata;
+    if (cbdataReferenceValidDone(q.callback_data, &cbdata)) {
+        read_(q.buf, q.size, q.offset, q.callback, cbdata);
     } else {
-        debugs(79, 2, "UFSStoreState::kickReadQueue: this: " << this << " cbdataReferenceValidDone returned false." << " closing: " << closing << " flags.try_closing: " << flags.try_closing);
-        delete q;
-        return false;
+        debugs(79, 2, "this=" << (void*)this << " cbdataReferenceValidDone returned false." <<
+               " closing: " << closing << " flags.try_closing: " << flags.try_closing);
+        result = false;
     }
 
-    delete q;
-
-    return true;
-}
-
-void
-Fs::Ufs::UFSStoreState::queueRead(char *buf, size_t size, off_t aOffset, STRCB *callback_, void *callback_data_)
-{
-    debugs(79, 3, "UFSStoreState::queueRead: queueing read");
-    assert(opening);
-    assert (pending_reads == NULL);
-    _queued_read *q = new _queued_read;
-    q->buf = buf;
-    q->size = size;
-    q->offset = aOffset;
-    q->callback = callback_;
-    q->callback_data = cbdataReference(callback_data_);
-    linklistPush(&pending_reads, q);
+    pending_reads.pop(); // erase the front object
+    return result;
 }
 
 /*
@@ -445,9 +410,8 @@ Fs::Ufs::UFSStoreState::drainWriteQueue()
 
     flags.write_draining = true;
 
-    while (pending_writes != NULL) {
+    while (!pending_writes.empty())
         doWrite();
-    }
 
     flags.write_draining = false;
 
@@ -482,17 +446,3 @@ Fs::Ufs::UFSStoreState::tryClosing()
     theFile->close();
 }
 
-void
-Fs::Ufs::UFSStoreState::queueWrite(char const *buf, size_t size, off_t aOffset, FREE * free_func)
-{
-    debugs(79, 3, HERE << this << " UFSStoreState::queueWrite: queueing write of size " << size);
-
-    _queued_write *q;
-    q = new _queued_write;
-    q->buf = buf;
-    q->size = size;
-    q->offset = aOffset;
-    q->free_func = free_func;
-    linklistPush(&pending_writes, q);
-}
-
@@ -10,9 +10,10 @@
 #define SQUID_FS_UFS_UFSSTORESTATE_H
 
 #include "DiskIO/IORequestor.h"
-#include "SquidList.h"
 #include "StoreIOState.h"
 
+#include <queue>
+
 namespace Fs
 {
 namespace Ufs
@@ -48,37 +49,52 @@ class UFSStoreState : public StoreIOState, public IORequestor
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_read);
     public:
-        _queued_read() :
-            buf(nullptr),
-            size(0),
-            offset(0),
-            callback(nullptr),
-            callback_data(nullptr)
+        _queued_read(char *b, size_t s, off_t o, STRCB *cb, void *data) :
+            buf(b),
+            size(s),
+            offset(o),
+            callback(cb),
+            callback_data(cbdataReference(data))
         {}
+        ~_queued_read() {
+            cbdataReferenceDone(callback_data);
+        }
 
         char *buf;
         size_t size;
         off_t offset;
         STRCB *callback;
         void *callback_data;
     };
+    std::queue<Ufs::UFSStoreState::_queued_read> pending_reads;
 
     class _queued_write
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_write);
     public:
-        _queued_write() :
-            buf(nullptr),
-            size(0),
-            offset(0),
-            free_func(nullptr)
+        _queued_write(const char *b, size_t s, off_t o, FREE *f) :
+            buf(b),
+            size(s),
+            offset(o),
+            free_func(f)
         {}
+        ~_queued_write() {
+            /*
+              * DPW 2006-05-24
+              * Note "free_func" is memNodeWriteComplete(), which doesn't
+              * really free the memory.  Instead it clears the node's
+              * write_pending flag.
+              */
+            if (free_func && buf)
+                free_func(const_cast<char *>(buf));
+        }
 
         char const *buf;
         size_t size;
         off_t offset;
         FREE *free_func;
     };
+    std::queue<Ufs::UFSStoreState::_queued_write> pending_writes;
 
     /** \todo These should be in the IO strategy */
 
@@ -98,10 +114,7 @@ class UFSStoreState : public StoreIOState, public IORequestor
          */
         bool try_closing;
     } flags;
-    link_list *pending_reads;
-    link_list *pending_writes;
-    void queueRead(char *, size_t, off_t, STRCB *, void *);
-    void queueWrite(char const *, size_t, off_t, FREE *);
+
     bool kickReadQueue();
     void drainWriteQueue();
     void tryClosing();
@@ -71,6 +71,7 @@ class UFSSwapDir : public SwapDir
     virtual uint64_t currentSize() const override { return cur_size; }
     virtual uint64_t currentCount() const override { return n_disk_objects; }
     virtual ConfigOption *getOptionTree() const override;
+    virtual bool smpAware() const override { return false; }
 
     void unlinkFile(sfileno f);
     // move down when unlink is a virtual method
@@ -37,31 +37,22 @@
 /// The maximum allowed request retries.
 #define MAX_RETRIES 2
 
-/** Initial Squid input buffer size. Helper responses may exceed this, and
- * Squid will grow the input buffer as needed, up to ReadBufMaxSize.
- */
-const size_t ReadBufMinSize(4*1024);
-
-/** Maximum safe size of a helper-to-Squid response message plus one.
- * Squid will warn and close the stream if a helper sends a too-big response.
- * ssl_crtd helper is known to produce responses of at least 10KB in size.
- * Some undocumented helpers are known to produce responses exceeding 8KB.
- */
-const size_t ReadBufMaxSize(32*1024);
+/// Helpers input buffer size.
+const size_t ReadBufSize(32*1024);
 
 static IOCB helperHandleRead;
 static IOCB helperStatefulHandleRead;
 static void helperServerFree(helper_server *srv);
 static void helperStatefulServerFree(helper_stateful_server *srv);
-static void Enqueue(helper * hlp, Helper::Request *);
+static void Enqueue(helper * hlp, Helper::Xaction *);
 static helper_server *GetFirstAvailable(helper * hlp);
 static helper_stateful_server *StatefulGetFirstAvailable(statefulhelper * hlp);
-static void helperDispatch(helper_server * srv, Helper::Request * r);
-static void helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r);
+static void helperDispatch(helper_server * srv, Helper::Xaction * r);
+static void helperStatefulDispatch(helper_stateful_server * srv, Helper::Xaction * r);
 static void helperKickQueue(helper * hlp);
 static void helperStatefulKickQueue(statefulhelper * hlp);
 static void helperStatefulServerDone(helper_stateful_server * srv);
-static void StatefulEnqueue(statefulhelper * hlp, Helper::Request * r);
+static void StatefulEnqueue(statefulhelper * hlp, Helper::Xaction * r);
 
 CBDATA_CLASS_INIT(helper);
 CBDATA_CLASS_INIT(helper_server);
@@ -212,10 +203,12 @@ helperOpenServers(helper * hlp)
         srv->readPipe->fd = rfd;
         srv->writePipe = new Comm::Connection;
         srv->writePipe->fd = wfd;
-        srv->rbuf = (char *)memAllocBuf(ReadBufMinSize, &srv->rbuf_sz);
+        srv->rbuf = (char *)memAllocBuf(ReadBufSize, &srv->rbuf_sz);
         srv->wqueue = new MemBuf;
         srv->roffset = 0;
         srv->nextRequestId = 0;
+        srv->replyXaction = NULL;
+        srv->ignoreToEom = false;
         srv->parent = cbdataReference(hlp);
         dlinkAddTail(srv, &srv->link, &hlp->servers);
 
@@ -338,7 +331,7 @@ helperStatefulOpenServers(statefulhelper * hlp)
         srv->readPipe->fd = rfd;
         srv->writePipe = new Comm::Connection;
         srv->writePipe->fd = wfd;
-        srv->rbuf = (char *)memAllocBuf(ReadBufMinSize, &srv->rbuf_sz);
+        srv->rbuf = (char *)memAllocBuf(ReadBufSize, &srv->rbuf_sz);
         srv->roffset = 0;
         srv->parent = cbdataReference(hlp);
 
@@ -377,7 +370,7 @@ helperStatefulOpenServers(statefulhelper * hlp)
 }
 
 void
-helper::submitRequest(Helper::Request *r)
+helper::submitRequest(Helper::Xaction *r)
 {
     helper_server *srv;
 
@@ -399,7 +392,7 @@ helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperSubmit: hlp == NULL");
-        Helper::Reply nilReply;
+        Helper::Reply const nilReply(Helper::Unknown);
         callback(data, nilReply);
         return;
     }
@@ -443,7 +436,7 @@ helper::trySubmit(const char *buf, HLPCB * callback, void *data)
 void
 helper::submit(const char *buf, HLPCB * callback, void *data)
 {
-    Helper::Request *r = new Helper::Request(callback, data, buf);
+    Helper::Xaction *r = new Helper::Xaction(callback, data, buf);
     submitRequest(r);
     debugs(84, DBG_DATA, Raw("buf", buf, strlen(buf)));
 }
@@ -454,7 +447,7 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperStatefulSubmit: hlp == NULL");
-        Helper::Reply nilReply;
+        Helper::Reply const nilReply(Helper::Unknown);
         callback(data, nilReply);
         return;
     }
@@ -464,7 +457,7 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
 
 void statefulhelper::submit(const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver)
 {
-    Helper::Request *r = new Helper::Request(callback, data, buf);
+    Helper::Xaction *r = new Helper::Xaction(callback, data, buf);
 
     if ((buf != NULL) && lastserver) {
         debugs(84, 5, "StatefulSubmit with lastserver " << lastserver);
@@ -481,7 +474,7 @@ void statefulhelper::submit(const char *buf, HLPCB * callback, void *data, helpe
             StatefulEnqueue(this, r);
     }
 
-    debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
+    debugs(84, DBG_DATA, "placeholder: '" << r->request.placeholder <<
            "', " << Raw("buf", buf, (!buf?0:strlen(buf))));
 
     if (!queueFull()) {
@@ -548,8 +541,8 @@ helper::packStatsInto(Packable *p, const char *label) const
     for (dlink_node *link = servers.head; link; link = link->next) {
         HelperServerBase *srv = static_cast<HelperServerBase *>(link->data);
         assert(srv);
-        Helper::Request *request = srv->requests.empty() ? NULL : srv->requests.front();
-        double tt = 0.001 * (request ? tvSubMsec(request->dispatch_time, current_time) : tvSubMsec(srv->dispatch_time, srv->answer_time));
+        Helper::Xaction *xaction = srv->requests.empty() ? NULL : srv->requests.front();
+        double tt = 0.001 * (xaction ? tvSubMsec(xaction->request.dispatch_time, current_time) : tvSubMsec(srv->dispatch_time, srv->answer_time));
         p->appendf("%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
                    srv->index.value,
                    srv->readPipe->fd,
@@ -562,10 +555,10 @@ helper::packStatsInto(Packable *p, const char *label) const
                    srv->flags.closing ? 'C' : ' ',
                    srv->flags.reserved ? 'R' : ' ',
                    srv->flags.shutdown ? 'S' : ' ',
-                   request && request->placeholder ? 'P' : ' ',
+                   xaction && xaction->request.placeholder ? 'P' : ' ',
                    tt < 0.0 ? 0.0 : tt,
                    (int) srv->roffset,
-                   request ? Format::QuoteMimeBlob(request->buf) : "(none)");
+                   xaction ? Format::QuoteMimeBlob(xaction->request.buf) : "(none)");
     }
 
     p->append("\nFlags key:\n"
@@ -727,13 +720,13 @@ helperServerFree(helper_server *srv)
 
     while (!srv->requests.empty()) {
         // XXX: re-schedule these on another helper?
-        Helper::Request *r = srv->requests.front();
+        Helper::Xaction *r = srv->requests.front();
         srv->requests.pop_front();
         void *cbdata;
 
-        if (cbdataReferenceValidDone(r->data, &cbdata)) {
-            Helper::Reply nilReply;
-            r->callback(cbdata, nilReply);
+        if (cbdataReferenceValidDone(r->request.data, &cbdata)) {
+            r->reply.result = Helper::Unknown;
+            r->request.callback(cbdata, r->reply);
         }
 
         delete r;
@@ -792,13 +785,13 @@ helperStatefulServerFree(helper_stateful_server *srv)
 
     while (!srv->requests.empty()) {
         // XXX: re-schedule these on another helper?
-        Helper::Request *r = srv->requests.front();
+        Helper::Xaction *r = srv->requests.front();
         srv->requests.pop_front();
         void *cbdata;
 
-        if (cbdataReferenceValidDone(r->data, &cbdata)) {
-            Helper::Reply nilReply;
-            r->callback(cbdata, nilReply);
+        if (cbdataReferenceValidDone(r->request.data, &cbdata)) {
+            r->reply.result = Helper::Unknown;
+            r->request.callback(cbdata, r->reply);
         }
 
         delete r;
@@ -812,39 +805,57 @@ helperStatefulServerFree(helper_stateful_server *srv)
     delete srv;
 }
 
-/// Calls back with a pointer to the buffer with the helper output
-static void
-helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char * msg, char * msg_end)
+Helper::Xaction *
+helper_server::popRequest(int request_number)
 {
-    Helper::Request *r = NULL;
+    Helper::Xaction *r = nullptr;
     helper_server::RequestIndex::iterator it;
-    if (hlp->childs.concurrency) {
+    if (parent->childs.concurrency) {
         // If concurency supported retrieve request from ID
-        it = srv->requestsIndex.find(request_number);
-        if (it != srv->requestsIndex.end()) {
+        it = requestsIndex.find(request_number);
+        if (it != requestsIndex.end()) {
             r = *(it->second);
-            srv->requests.erase(it->second);
-            srv->requestsIndex.erase(it);
+            requests.erase(it->second);
+            requestsIndex.erase(it);
         }
-    } else if(!srv->requests.empty()) {
+    } else if(!requests.empty()) {
         // Else get the first request from queue, if any
-        r = srv->requests.front();
-        srv->requests.pop_front();
+        r = requests.front();
+        requests.pop_front();
     }
 
-    if (r) {
-        HLPCB *callback = r->callback;
-        r->callback = NULL;
+    return r;
+}
+
+/// Calls back with a pointer to the buffer with the helper output
+static void
+helperReturnBuffer(helper_server * srv, helper * hlp, char * msg, size_t msgSize, char * msgEnd)
+{
+    if (Helper::Xaction *r = srv->replyXaction) {
+        const bool hasSpace = r->reply.accumulate(msg, msgSize);
+        if (!hasSpace) {
+            debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
+                   "helper that overflowed " << srv->rbuf_sz << "-byte " <<
+                   "Squid input buffer: " << hlp->id_name << " #" << srv->index);
+            srv->closePipesSafely(hlp->id_name);
+            return;
+        }
+
+        if (!msgEnd)
+            return; // We are waiting for more data.
+
+        HLPCB *callback = r->request.callback;
+        r->request.callback = nullptr;
 
-        void *cbdata = NULL;
         bool retry = false;
-        if (cbdataReferenceValidDone(r->data, &cbdata)) {
-            Helper::Reply response(msg, (msg_end-msg));
-            if (response.result == Helper::BrokenHelper && r->retries < MAX_RETRIES) {
-                debugs(84, DBG_IMPORTANT, "ERROR: helper: " << response << ", attempt #" << (r->retries + 1) << " of 2");
+        void *cbdata = nullptr;
+        if (cbdataReferenceValidDone(r->request.data, &cbdata)) {
+            r->reply.finalize();
+            if (r->reply.result == Helper::BrokenHelper && r->request.retries < MAX_RETRIES) {
+                debugs(84, DBG_IMPORTANT, "ERROR: helper: " << r->reply << ", attempt #" << (r->request.retries + 1) << " of 2");
                 retry = true;
             } else
-                callback(cbdata, response);
+                callback(cbdata, r->reply);
         }
 
         -- srv->stats.pending;
@@ -854,24 +865,20 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
 
         srv->answer_time = current_time;
 
-        srv->dispatch_time = r->dispatch_time;
+        srv->dispatch_time = r->request.dispatch_time;
 
         hlp->stats.avg_svc_time =
             Math::intAverage(hlp->stats.avg_svc_time,
-                             tvSubMsec(r->dispatch_time, current_time),
+                             tvSubMsec(r->request.dispatch_time, current_time),
                              hlp->stats.replies, REDIRECT_AV_FACTOR);
 
+        // release or re-submit parsedRequestXaction object
+        srv->replyXaction = nullptr;
         if (retry) {
-            ++r->retries;
+            ++r->request.retries;
             hlp->submitRequest(r);
         } else
             delete r;
-    } else if (srv->stats.timedout) {
-        debugs(84, 3, "Timedout reply received for request-ID: " << request_number << " , ignore");
-    } else {
-        debugs(84, DBG_IMPORTANT, "helperHandleRead: unexpected reply on channel " <<
-               request_number << " from " << hlp->id_name << " #" << srv->index <<
-               " '" << srv->rbuf << "'");
     }
 
     if (hlp->timeout && hlp->childs.concurrency)
@@ -888,7 +895,6 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
 static void
 helperHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len, Comm::Flag flag, int, void *data)
 {
-    char *t = NULL;
     helper_server *srv = (helper_server *)data;
     helper *hlp = srv->parent;
     assert(cbdataReferenceValid(data));
@@ -922,57 +928,80 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len, Comm::
         srv->rbuf[0] = '\0';
     }
 
-    while ((t = strchr(srv->rbuf, hlp->eom))) {
-        /* end of reply found */
-        char *msg = srv->rbuf;
-        int i = 0;
-        int skip = 1;
-        debugs(84, 3, "helperHandleRead: end of reply found");
-
-        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n') {
-            *t = '\0';
-            // rewind to the \r octet which is the real terminal now
-            // and remember that we have to skip forward 2 places now.
-            skip = 2;
-            --t;
+    bool needsMore = false;
+    char *msg = srv->rbuf;
+    while (*msg && !needsMore) {
+        int skip = 0;
+        char *eom = strchr(msg, hlp->eom);
+        if (eom) {
+            skip = 1;
+            debugs(84, 3, "helperHandleRead: end of reply found");
+            if (eom > msg && eom[-1] == '\r' && hlp->eom == '\n') {
+                *eom = '\0';
+                // rewind to the \r octet which is the real terminal now
+                // and remember that we have to skip forward 2 places now.
+                skip = 2;
+                --eom;
+            }
+            *eom = '\0';
         }
 
-        *t = '\0';
-
-        if (hlp->childs.concurrency) {
-            i = strtol(msg, &msg, 10);
-
-            while (*msg && xisspace(*msg))
-                ++msg;
-        }
+        if (!srv->ignoreToEom && !srv->replyXaction) {
+            int i = 0;
+            if (hlp->childs.concurrency) {
+                char *e = NULL;
+                i = strtol(msg, &e, 10);
+                // Do we need to check for e == msg? Means wrong response from helper.
+                // Will be droped as "unexpected reply on channel 0"
+                needsMore = !(xisspace(*e) || (eom && e == eom));
+                if (!needsMore) {
+                    msg = e;
+                    while (*msg && xisspace(*msg))
+                        ++msg;
+                } // else not enough data to compute request number
+            }
+            if (!(srv->replyXaction = srv->popRequest(i))) {
+                if (srv->stats.timedout) {
+                    debugs(84, 3, "Timedout reply received for request-ID: " << i << " , ignore");
+                } else {
+                    debugs(84, DBG_IMPORTANT, "helperHandleRead: unexpected reply on channel " <<
+                           i << " from " << hlp->id_name << " #" << srv->index <<
+                           " '" << srv->rbuf << "'");
+                }
+                srv->ignoreToEom = true;
+            }
+        } // else we need to just append reply data to the current Xaction
+
+        if (!needsMore) {
+            size_t msgSize  = eom ? eom - msg : (srv->roffset - (msg - srv->rbuf));
+            assert(msgSize <= srv->rbuf_sz);
+            helperReturnBuffer(srv, hlp, msg, msgSize, eom);
+            msg += msgSize + skip;
+            assert(static_cast<size_t>(msg - srv->rbuf) <= srv->rbuf_sz);
+
+            // The next message should not ignored.
+            if (eom && srv->ignoreToEom)
+                srv->ignoreToEom = false;
+        } else
+            assert(skip == 0 && eom == NULL);
+    }
 
-        helperReturnBuffer(i, srv, hlp, msg, t);
-        srv->roffset -= (t - srv->rbuf) + skip;
-        memmove(srv->rbuf, t + skip, srv->roffset);
+    if (needsMore) {
+        size_t msgSize = (srv->roffset - (msg - srv->rbuf));
+        assert(msgSize <= srv->rbuf_sz);
+        memmove(srv->rbuf, msg, msgSize);
+        srv->roffset = msgSize;
         srv->rbuf[srv->roffset] = '\0';
+    } else {
+        // All of the responses parsed and msg points at the end of read data
+        assert(static_cast<size_t>(msg - srv->rbuf) == srv->roffset);
+        srv->roffset = 0;
     }
 
     if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
         int spaceSize = srv->rbuf_sz - srv->roffset - 1;
         assert(spaceSize >= 0);
 
-        // grow the input buffer if needed and possible
-        if (!spaceSize && srv->rbuf_sz + 4096 <= ReadBufMaxSize) {
-            srv->rbuf = (char *)memReallocBuf(srv->rbuf, srv->rbuf_sz + 4096, &srv->rbuf_sz);
-            debugs(84, 3, HERE << "Grew read buffer to " << srv->rbuf_sz);
-            spaceSize = srv->rbuf_sz - srv->roffset - 1;
-            assert(spaceSize >= 0);
-        }
-
-        // quit reading if there is no space left
-        if (!spaceSize) {
-            debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
-                   "helper that overflowed " << srv->rbuf_sz << "-byte " <<
-                   "Squid input buffer: " << hlp->id_name << " #" << srv->index);
-            srv->closePipesSafely(hlp->id_name);
-            return;
-        }
-
         AsyncCall::Pointer call = commCbCall(5,4, "helperHandleRead",
                                              CommIoCbPtrFun(helperHandleRead, srv));
         comm_read(srv->readPipe, srv->rbuf + srv->roffset, spaceSize, call);
@@ -1005,7 +1034,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
 
     srv->roffset += len;
     srv->rbuf[srv->roffset] = '\0';
-    Helper::Request *r = srv->requests.front();
+    Helper::Xaction *r = srv->requests.front();
     debugs(84, DBG_DATA, Raw("accumulated", srv->rbuf, srv->roffset));
 
     if (r == NULL) {
@@ -1018,40 +1047,46 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
     }
 
     if ((t = strchr(srv->rbuf, hlp->eom))) {
-        /* end of reply found */
-        srv->requests.pop_front(); // we already have it in 'r'
-        int called = 1;
-        int skip = 1;
         debugs(84, 3, "helperStatefulHandleRead: end of reply found");
 
         if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n') {
             *t = '\0';
             // rewind to the \r octet which is the real terminal now
-            // and remember that we have to skip forward 2 places now.
-            skip = 2;
             --t;
         }
 
         *t = '\0';
+    }
+
+    if (r && !r->reply.accumulate(srv->rbuf, t ? (t - srv->rbuf) : srv->roffset)) {
+        debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
+               "helper that overflowed " << srv->rbuf_sz << "-byte " <<
+               "Squid input buffer: " << hlp->id_name << " #" << srv->index);
+        srv->closePipesSafely(hlp->id_name);
+        return;
+    }
+    /**
+     * BUG: the below assumes that only one response per read() was received and discards any octets remaining.
+     *      Doing this prohibits concurrency support with multiple replies per read().
+     * TODO: check that read() setup on these buffers pays attention to roffest!=0
+     * TODO: check that replies bigger than the buffer are discarded and do not to affect future replies
+     */
+    srv->roffset = 0;
+
+    if (t) {
+        /* end of reply found */
+        srv->requests.pop_front(); // we already have it in 'r'
+        int called = 1;
 
-        if (r && cbdataReferenceValid(r->data)) {
-            Helper::Reply res(srv->rbuf, (t - srv->rbuf));
-            res.whichServer = srv;
-            r->callback(r->data, res);
+        if (r && cbdataReferenceValid(r->request.data)) {
+            r->reply.finalize();
+            r->reply.whichServer = srv;
+            r->request.callback(r->request.data, r->reply);
         } else {
             debugs(84, DBG_IMPORTANT, "StatefulHandleRead: no callback data registered");
             called = 0;
         }
-        // only skip off the \0's _after_ passing its location in Helper::Reply above
-        t += skip;
-
-        /**
-         * BUG: the below assumes that only one response per read() was received and discards any octets remaining.
-         *      Doing this prohibits concurrency support with multiple replies per read().
-         * TODO: check that read() setup on these buffers pays attention to roffest!=0
-         * TODO: check that replies bigger than the buffer are discarded and do not to affect future replies
-         */
-        srv->roffset = 0;
+
         delete r;
 
         -- srv->stats.pending;
@@ -1071,35 +1106,17 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len
     }
 
     if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
-        int spaceSize = srv->rbuf_sz - srv->roffset - 1;
-        assert(spaceSize >= 0);
-
-        // grow the input buffer if needed and possible
-        if (!spaceSize && srv->rbuf_sz + 4096 <= ReadBufMaxSize) {
-            srv->rbuf = (char *)memReallocBuf(srv->rbuf, srv->rbuf_sz + 4096, &srv->rbuf_sz);
-            debugs(84, 3, HERE << "Grew read buffer to " << srv->rbuf_sz);
-            spaceSize = srv->rbuf_sz - srv->roffset - 1;
-            assert(spaceSize >= 0);
-        }
-
-        // quit reading if there is no space left
-        if (!spaceSize) {
-            debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
-                   "helper that overflowed " << srv->rbuf_sz << "-byte " <<
-                   "Squid input buffer: " << hlp->id_name << " #" << srv->index);
-            srv->closePipesSafely(hlp->id_name);
-            return;
-        }
+        int spaceSize = srv->rbuf_sz - 1;
 
         AsyncCall::Pointer call = commCbCall(5,4, "helperStatefulHandleRead",
                                              CommIoCbPtrFun(helperStatefulHandleRead, srv));
-        comm_read(srv->readPipe, srv->rbuf + srv->roffset, spaceSize, call);
+        comm_read(srv->readPipe, srv->rbuf, spaceSize, call);
     }
 }
 
 /// Handles a request when all running helpers, if any, are busy.
 static void
-Enqueue(helper * hlp, Helper::Request * r)
+Enqueue(helper * hlp, Helper::Xaction * r)
 {
     hlp->queue.push(r);
     ++ hlp->stats.queue_size;
@@ -1128,7 +1145,7 @@ Enqueue(helper * hlp, Helper::Request * r)
 }
 
 static void
-StatefulEnqueue(statefulhelper * hlp, Helper::Request * r)
+StatefulEnqueue(statefulhelper * hlp, Helper::Xaction * r)
 {
     hlp->queue.push(r);
     ++ hlp->stats.queue_size;
@@ -1156,7 +1173,7 @@ StatefulEnqueue(statefulhelper * hlp, Helper::Request * r)
     debugs(84, DBG_CRITICAL, "WARNING: Consider increasing the number of " << hlp->id_name << " processes in your config file.");
 }
 
-Helper::Request *
+Helper::Xaction *
 helper::nextRequest()
 {
     if (queue.empty())
@@ -1272,30 +1289,30 @@ helperDispatchWriteDone(const Comm::ConnectionPointer &, char *, size_t, Comm::F
 }
 
 static void
-helperDispatch(helper_server * srv, Helper::Request * r)
+helperDispatch(helper_server * srv, Helper::Xaction * r)
 {
     helper *hlp = srv->parent;
     const uint64_t reqId = ++srv->nextRequestId;
 
-    if (!cbdataReferenceValid(r->data)) {
+    if (!cbdataReferenceValid(r->request.data)) {
         debugs(84, DBG_IMPORTANT, "helperDispatch: invalid callback data");
         delete r;
         return;
     }
 
-    r->Id = reqId;
+    r->request.Id = reqId;
     helper_server::Requests::iterator it = srv->requests.insert(srv->requests.end(), r);
-    r->dispatch_time = current_time;
+    r->request.dispatch_time = current_time;
 
     if (srv->wqueue->isNull())
         srv->wqueue->init();
 
     if (hlp->childs.concurrency) {
         srv->requestsIndex.insert(helper_server::RequestIndex::value_type(reqId, it));
         assert(srv->requestsIndex.size() == srv->requests.size());
-        srv->wqueue->appendf("%" PRIu64 " %s", reqId, r->buf);
+        srv->wqueue->appendf("%" PRIu64 " %s", reqId, r->request.buf);
     } else
-        srv->wqueue->append(r->buf, strlen(r->buf));
+        srv->wqueue->append(r->request.buf, strlen(r->request.buf));
 
     if (!srv->flags.writing) {
         assert(NULL == srv->writebuf);
@@ -1307,7 +1324,7 @@ helperDispatch(helper_server * srv, Helper::Request * r)
         Comm::Write(srv->writePipe, srv->writebuf->content(), srv->writebuf->contentSize(), call, NULL);
     }
 
-    debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index << ", " << strlen(r->buf) << " bytes");
+    debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index << ", " << strlen(r->request.buf) << " bytes");
 
     ++ srv->stats.uses;
     ++ srv->stats.pending;
@@ -1319,11 +1336,11 @@ helperStatefulDispatchWriteDone(const Comm::ConnectionPointer &, char *, size_t,
 {}
 
 static void
-helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
+helperStatefulDispatch(helper_stateful_server * srv, Helper::Xaction * r)
 {
     statefulhelper *hlp = srv->parent;
 
-    if (!cbdataReferenceValid(r->data)) {
+    if (!cbdataReferenceValid(r->request.data)) {
         debugs(84, DBG_IMPORTANT, "helperStatefulDispatch: invalid callback data");
         delete r;
         helperStatefulReleaseServer(srv);
@@ -1332,13 +1349,13 @@ helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
 
     debugs(84, 9, "helperStatefulDispatch busying helper " << hlp->id_name << " #" << srv->index);
 
-    if (r->placeholder == 1) {
+    if (r->request.placeholder == 1) {
         /* a callback is needed before this request can _use_ a helper. */
         /* we don't care about releasing this helper. The request NEVER
          * gets to the helper. So we throw away the return code */
-        Helper::Reply nilReply;
-        nilReply.whichServer = srv;
-        r->callback(r->data, nilReply);
+        r->reply.result = Helper::Unknown;
+        r->reply.whichServer = srv;
+        r->request.callback(r->request.data, r->reply);
         /* throw away the placeholder */
         delete r;
         /* and push the queue. Note that the callback may have submitted a new
@@ -1355,10 +1372,10 @@ helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
     srv->dispatch_time = current_time;
     AsyncCall::Pointer call = commCbCall(5,5, "helperStatefulDispatchWriteDone",
                                          CommIoCbPtrFun(helperStatefulDispatchWriteDone, hlp));
-    Comm::Write(srv->writePipe, r->buf, strlen(r->buf), call, NULL);
+    Comm::Write(srv->writePipe, r->request.buf, strlen(r->request.buf), call, NULL);
     debugs(84, 5, "helperStatefulDispatch: Request sent to " <<
            hlp->id_name << " #" << srv->index << ", " <<
-           (int) strlen(r->buf) << " bytes");
+           (int) strlen(r->request.buf) << " bytes");
 
     ++ srv->stats.uses;
     ++ srv->stats.pending;
@@ -1368,7 +1385,7 @@ helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
 static void
 helperKickQueue(helper * hlp)
 {
-    Helper::Request *r;
+    Helper::Xaction *r;
     helper_server *srv;
 
     while ((srv = GetFirstAvailable(hlp)) && (r = hlp->nextRequest()))
@@ -1378,7 +1395,7 @@ helperKickQueue(helper * hlp)
 static void
 helperStatefulKickQueue(statefulhelper * hlp)
 {
-    Helper::Request *r;
+    Helper::Xaction *r;
     helper_stateful_server *srv;
 
     while ((srv = StatefulGetFirstAvailable(hlp)) && (r = hlp->nextRequest()))
@@ -1400,29 +1417,32 @@ void
 helper_server::checkForTimedOutRequests(bool const retry)
 {
     assert(parent->childs.concurrency);
-    while(!requests.empty() && requests.front()->timedOut(parent->timeout)) {
-        Helper::Request *r = requests.front();
+    while(!requests.empty() && requests.front()->request.timedOut(parent->timeout)) {
+        Helper::Xaction *r = requests.front();
         RequestIndex::iterator it;
-        it = requestsIndex.find(r->Id);
+        it = requestsIndex.find(r->request.Id);
         assert(it != requestsIndex.end());
         requestsIndex.erase(it);
         requests.pop_front();
-        debugs(84, 2, "Request " << r->Id << " timed-out, remove it from queue");
+        debugs(84, 2, "Request " << r->request.Id << " timed-out, remove it from queue");
         void *cbdata;
         bool retried = false;
-        if (retry && r->retries < MAX_RETRIES && cbdataReferenceValid(r->data)) {
-            debugs(84, 2, "Retry request " << r->Id);
-            ++r->retries;
+        if (retry && r->request.retries < MAX_RETRIES && cbdataReferenceValid(r->request.data)) {
+            debugs(84, 2, "Retry request " << r->request.Id);
+            ++r->request.retries;
             parent->submitRequest(r);
             retried = true;
-        } else if (cbdataReferenceValidDone(r->data, &cbdata)) {
+        } else if (cbdataReferenceValidDone(r->request.data, &cbdata)) {
             if (!parent->onTimedOutResponse.isEmpty()) {
-                // Helper::Reply needs a non const buffer
-                char *replyMsg = xstrdup(parent->onTimedOutResponse.c_str());
-                r->callback(cbdata, Helper::Reply(replyMsg, strlen(replyMsg)));
-                xfree(replyMsg);
-            } else
-                r->callback(cbdata, Helper::Reply(Helper::TimedOut));
+                if (r->reply.accumulate(parent->onTimedOutResponse.rawContent(), parent->onTimedOutResponse.length()))
+                    r->reply.finalize();
+                else
+                    r->reply.result = Helper::TimedOut;
+                r->request.callback(cbdata, r->reply);
+            } else {
+                r->reply.result = Helper::TimedOut;
+                r->request.callback(cbdata, r->reply);
+            }
         }
         --stats.pending;
         ++stats.timedout;
@@ -1447,7 +1467,7 @@ helper_server::requestTimeout(const CommTimeoutCbParams &io)
     AsyncCall::Pointer timeoutCall = commCbCall(84, 4, "helper_server::requestTimeout",
                                      CommTimeoutCbPtrFun(helper_server::requestTimeout, srv));
 
-    const int timeSpent = srv->requests.empty() ? 0 : (squid_curtime - srv->requests.front()->dispatch_time.tv_sec);
+    const int timeSpent = srv->requests.empty() ? 0 : (squid_curtime - srv->requests.front()->request.dispatch_time.tv_sec);
     const int timeLeft = max(1, (static_cast<int>(srv->parent->timeout) - timeSpent));
 
     commSetConnTimeout(io.conn, timeLeft, timeoutCall);
@@ -18,6 +18,8 @@
 #include "dlink.h"
 #include "helper/ChildConfig.h"
 #include "helper/forward.h"
+#include "helper/Reply.h"
+#include "helper/Request.h"
 #include "ip/Address.h"
 #include "sbuf/SBuf.h"
 
@@ -28,6 +30,18 @@
 class Packable;
 class wordlist;
 
+namespace Helper
+{
+/// Holds the  required data to serve a helper request.
+class Xaction {
+    MEMPROXY_CLASS(Helper::Xaction);
+public:
+    Xaction(HLPCB *c, void *d, const char *b): request(c, d, b) {}
+    Helper::Request request;
+    Helper::Reply reply;
+};
+}
+
 /**
  * Managers a set of individual helper processes with a common queue of requests.
  *
@@ -67,22 +81,22 @@ class helper
     bool queueFull() const;
 
     /// \returns next request in the queue, or nil.
-    Helper::Request *nextRequest();
+    Helper::Xaction *nextRequest();
 
     ///< If not full, submit request. Otherwise, either kill Squid or return false.
     bool trySubmit(const char *buf, HLPCB * callback, void *data);
 
     /// Submits a request to the helper or add it to the queue if none of
     /// the servers is available.
-    void submitRequest(Helper::Request *r);
+    void submitRequest(Helper::Xaction *r);
 
     /// Dump some stats about the helper state to a Packable object
     void packStatsInto(Packable *p, const char *label = NULL) const;
 
 public:
     wordlist *cmdline;
     dlink_list servers;
-    std::queue<Helper::Request *> queue;
+    std::queue<Helper::Xaction *> queue;
     const char *id_name;
     Helper::ChildConfig childs;    ///< Configuration settings for number running.
     int ipc_type;
@@ -173,7 +187,7 @@ class HelperServerBase
         bool reserved;
     } flags;
 
-    typedef std::list<Helper::Request *> Requests;
+    typedef std::list<Helper::Xaction *> Requests;
     Requests requests; ///< requests in order of submission/expiration
 
     struct {
@@ -201,10 +215,25 @@ class helper_server : public HelperServerBase
 
     helper *parent;
 
+    /// The helper request Xaction object for the current reply .
+    /// A helper reply may be distributed to more than one of the retrieved
+    /// packets from helper. This member stores the Xaction object as long as
+    /// the end-of-message for current reply is not retrieved.
+    Helper::Xaction *replyXaction;
+
+    /// Whether to ignore current message, because it is timed-out or other reason
+    bool ignoreToEom;
+
     // STL says storing std::list iterators is safe when changing the list
     typedef std::map<uint64_t, Requests::iterator> RequestIndex;
     RequestIndex requestsIndex; ///< maps request IDs to requests
 
+    /// Search in queue for the request with requestId, return the related
+    /// Xaction object and remove it from queue.
+    /// If concurrency is disabled then the requestId is ignored and the
+    /// Xaction of the next request in queue is retrieved.
+    Helper::Xaction *popRequest(int requestId);
+
     /// Run over the active requests lists and forces a retry, or timedout reply
     /// or the configured "on timeout response" for timedout requests.
     void checkForTimedOutRequests(bool const retry);
@@ -16,29 +16,40 @@
 #include "rfc1738.h"
 #include "SquidString.h"
 
-Helper::Reply::Reply(char *buf, size_t len) :
+Helper::Reply::Reply() :
     result(Helper::Unknown),
     whichServer(NULL)
 {
-    parse(buf,len);
+}
+
+bool
+Helper::Reply::accumulate(const char *buf, size_t len)
+{
+    if (other_.isNull())
+        other_.init(4*1024, 1*1024*1024);
+
+    if (other_.potentialSpaceSize() < static_cast<mb_size_t>(len))
+        return false; // no space left
+
+    other_.append(buf, len);
+    return true;
 }
 
 void
-Helper::Reply::parse(char *buf, size_t len)
+Helper::Reply::finalize()
 {
     debugs(84, 3, "Parsing helper buffer");
     // check we have something to parse
-    if (!buf || len < 1) {
+    if (!other_.hasContent()) {
         // empty line response was the old URL-rewriter interface ERR response.
         result = Helper::Error;
         // for now ensure that legacy handlers are not presented with NULL strings.
-        debugs(84, 3, "Reply length is smaller than 1 or none at all ");
-        other_.init(1,1);
-        other_.terminate();
+        debugs(84, 3, "Zero length reply");
         return;
     }
 
-    char *p = buf;
+    char *p = other_.content();
+    size_t len = other_.contentSize();
     bool sawNA = false;
 
     // optimization: do not consider parsing result code if the response is short.
@@ -67,10 +78,8 @@ Helper::Reply::parse(char *buf, size_t len)
             // followed by an auth token
             char *w1 = strwordtok(NULL, &p);
             if (w1 != NULL) {
-                MemBuf authToken;
-                authToken.init();
-                authToken.append(w1, strlen(w1));
-                notes.add("token",authToken.content());
+                const char *authToken = w1;
+                notes.add("token",authToken);
             } else {
                 // token field is mandatory on this response code
                 result = Helper::BrokenHelper;
@@ -88,22 +97,16 @@ Helper::Reply::parse(char *buf, size_t len)
             char *w2 = strwordtok(NULL, &p);
             if (w2 != NULL) {
                 // Negotiate "token user"
-                MemBuf authToken;
-                authToken.init();
-                authToken.append(w1, strlen(w1));
-                notes.add("token",authToken.content());
+                const char *authToken = w1;
+                notes.add("token",authToken);
 
-                MemBuf user;
-                user.init();
-                user.append(w2,strlen(w2));
-                notes.add("user",user.content());
+                const char *user = w2;
+                notes.add("user",user);
 
             } else if (w1 != NULL) {
                 // NTLM "user"
-                MemBuf user;
-                user.init();
-                user.append(w1,strlen(w1));
-                notes.add("user",user.content());
+                const char *user = w1;
+                notes.add("user",user);
             }
         } else if (!strncmp(p,"NA ",3)) {
             // NTLM fail-closed ERR response
@@ -115,21 +118,17 @@ Helper::Reply::parse(char *buf, size_t len)
         for (; xisspace(*p); ++p); // skip whitespace
     }
 
-    const mb_size_t blobSize = (buf+len-p);
-    other_.init(blobSize+1, blobSize+1);
-    other_.append(p, blobSize); // remainders of the line.
-
-    // NULL-terminate so the helper callback handlers do not buffer-overrun
-    other_.terminate();
+    other_.consume(p - other_.content());
+    other_.consumeWhitespacePrefix();
 
     // Hack for backward-compatibility: Do not parse for kv-pairs on NA response
     if (!sawNA)
         parseResponseKeys();
 
     // Hack for backward-compatibility: BH and NA used to be a text message...
-    if (other().hasContent() && (sawNA || result == Helper::BrokenHelper)) {
-        notes.add("message",other().content());
-        modifiableOther().clean();
+    if (other_.hasContent() && (sawNA || result == Helper::BrokenHelper)) {
+        notes.add("message", other_.content());
+        other_.clean();
     }
 }
 
@@ -157,8 +156,9 @@ void
 Helper::Reply::parseResponseKeys()
 {
     // parse a "key=value" pair off the 'other()' buffer.
-    while (other().hasContent()) {
-        char *p = modifiableOther().content();
+    while (other_.hasContent()) {
+        char *p = other_.content();
+        const char *key = p;
         while (*p && isKeyNameChar(*p)) ++p;
         if (*p != '=')
             return; // done. Not a key.
@@ -171,8 +171,6 @@ Helper::Reply::parseResponseKeys()
         *p = '\0';
         ++p;
 
-        const char *key = other().content();
-
         // the value may be a quoted string or a token
         const bool urlDecode = (*p != '"'); // check before moving p.
         char *v = strwordtok(NULL, &p);
@@ -181,11 +179,20 @@ Helper::Reply::parseResponseKeys()
 
         notes.add(key, v ? v : ""); // value can be empty, but must not be NULL
 
-        modifiableOther().consume(p - other().content());
-        modifiableOther().consumeWhitespacePrefix();
+        other_.consume(p - other_.content());
+        other_.consumeWhitespacePrefix();
     }
 }
 
+const MemBuf &
+Helper::Reply::emptyBuf() const
+{
+    static MemBuf empty;
+    if (empty.isNull())
+        empty.init(1, 1);
+    return empty;
+}
+
 std::ostream &
 operator <<(std::ostream &os, const Helper::Reply &r)
 {
@@ -218,8 +225,9 @@ operator <<(std::ostream &os, const Helper::Reply &r)
         os << "}";
     }
 
-    if (r.other().hasContent())
-        os << ", other: \"" << r.other().content() << '\"';
+    MemBuf const &o = r.other();
+    if (o.hasContent())
+        os << ", other: \"" << o.content() << '\"';
 
     os << '}';
 
@@ -33,22 +33,12 @@ class Reply
     Reply &operator =(const Helper::Reply &r);
 
 public:
-    explicit Reply(Helper::ResultCode res = Helper::Unknown) : result(res), notes(), whichServer(NULL) {
-        other_.init(1,1);
-        other_.terminate();
-    }
+    explicit Reply(Helper::ResultCode res) : result(res), notes(), whichServer(NULL) {}
 
-    // create/parse details from the msg buffer provided
-    // XXX: buf should be const but parse() needs non-const for now
-    Reply(char *buf, size_t len);
+    /// Creates a NULL reply
+    Reply();
 
-    const MemBuf &other() const { return other_; }
-
-    /// backward compatibility:
-    /// access to modifiable blob, required by redirectHandleReply()
-    /// and by urlParse() in ClientRequestContext::clientRedirectDone()
-    /// and by token blob/arg parsing in Negotiate auth handler
-    MemBuf &modifiableOther() const { return *const_cast<MemBuf*>(&other_); }
+    const MemBuf &other() const {return other_.isNull() ? emptyBuf() : other_;};
 
     /** parse a helper response line format:
      *   line     := [ result ] *#( kv-pair )
@@ -58,7 +48,10 @@ class Reply
      * quoted-string are \-escape decoded and the quotes are stripped.
      */
     // XXX: buf should be const but we may need strwordtok() and rfc1738_unescape()
-    void parse(char *buf, size_t len);
+    //void parse(char *buf, size_t len);
+    void finalize();
+
+    bool accumulate(const char *buf, size_t len);
 
 public:
     /// The helper response 'result' field.
@@ -73,6 +66,9 @@ class Reply
 private:
     void parseResponseKeys();
 
+    /// Return an empty MemBuf.
+    const MemBuf &emptyBuf() const;
+
     /// the remainder of the line
     MemBuf other_;
 };
@@ -9,7 +9,6 @@
 #ifndef SQUID_CUSTOMLOG_H_
 #define SQUID_CUSTOMLOG_H_
 
-//#include "format/Format.h"
 #include "acl/forward.h"
 #include "log/Formats.h"
 
@@ -746,7 +746,7 @@ peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const
     if (!reason && !size) {
         if (!pd->cd)
             reason = "null digest?!";
-        else if (fetch->mask_offset != (int)pd->cd->mask_size)
+        else if (fetch->mask_offset != pd->cd->mask_size)
             reason = "premature end of digest?!";
         else if (!peerDigestUseful(pd))
             reason = "useless digest";
@@ -94,25 +94,28 @@ redirectHandleReply(void *data, const Helper::Reply &reply)
         // * trim all but the first word off the response.
         // * warn once every 50 responses that this will stop being fixed-up soon.
         //
-        if (const char * res = reply.other().content()) {
+        if (reply.other().hasContent()) {
+            const char * res = reply.other().content();
+            size_t replySize = 0;
             if (const char *t = strchr(res, ' ')) {
                 static int warn = 0;
                 debugs(61, (!(warn++%50)? DBG_CRITICAL:2), "UPGRADE WARNING: URL rewriter reponded with garbage '" << t <<
                        "'. Future Squid will treat this as part of the URL.");
-                const mb_size_t garbageLength = reply.other().contentSize() - (t-res);
-                reply.modifiableOther().truncate(garbageLength);
-            }
-            if (reply.other().hasContent() && *res == '\0')
-                reply.modifiableOther().clean(); // drop the whole buffer of garbage.
+                replySize = t - res;
+            } else
+                replySize = reply.other().contentSize();
 
             // if we still have anything in other() after all that
             // parse it into status=, url= and rewrite-url= keys
-            if (reply.other().hasContent()) {
+            if (replySize) {
                 /* 2012-06-28: This cast is due to urlParse() truncating too-long URLs itself.
                  * At this point altering the helper buffer in that way is not harmful, but annoying.
                  * When Bug 1961 is resolved and urlParse has a const API, this needs to die.
                  */
-                char * result = reply.modifiableOther().content();
+                MemBuf replyBuffer;
+                replyBuffer.init(replySize, replySize);
+                replyBuffer.append(reply.other().content(), reply.other().contentSize());
+                char * result = replyBuffer.content();
 
                 Helper::Reply newReply;
                 // BACKWARD COMPATIBILITY 2012-06-15:
@@ -12,14 +12,14 @@
 #include "fde.h"
 #include "HttpRequest.h"
 #include "neighbors.h"
+#include "security/BlindPeerConnector.h"
 #include "security/NegotiationHistory.h"
 #include "SquidConfig.h"
-#include "ssl/BlindPeerConnector.h"
 
-CBDATA_NAMESPACED_CLASS_INIT(Ssl, BlindPeerConnector);
+CBDATA_NAMESPACED_CLASS_INIT(Security, BlindPeerConnector);
 
 Security::ContextPtr
-Ssl::BlindPeerConnector::getSslContext()
+Security::BlindPeerConnector::getSslContext()
 {
     if (const CachePeer *peer = serverConnection()->getPeer()) {
         assert(peer->secure.encryptTransport);
@@ -29,34 +29,35 @@ Ssl::BlindPeerConnector::getSslContext()
     return ::Config.ssl_client.sslContext;
 }
 
-Security::SessionPtr
-Ssl::BlindPeerConnector::initializeSsl()
+bool
+Security::BlindPeerConnector::initializeTls(Security::SessionPointer &serverSession)
 {
-    auto ssl = Ssl::PeerConnector::initializeSsl();
-    if (!ssl)
-        return nullptr;
+    if (!Security::PeerConnector::initializeTls(serverSession))
+        return false;
 
     if (const CachePeer *peer = serverConnection()->getPeer()) {
         assert(peer);
 
         // NP: domain may be a raw-IP but it is now always set
         assert(!peer->secure.sslDomain.isEmpty());
 
+#if USE_OPENSSL
         // const loss is okay here, ssl_ex_index_server is only read and not assigned a destructor
         SBuf *host = new SBuf(peer->secure.sslDomain);
-        SSL_set_ex_data(ssl, ssl_ex_index_server, host);
+        SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, host);
 
-        Security::SetSessionResumeData(ssl, peer->sslSession);
+        if (peer->sslSession)
+            SSL_set_session(serverSession.get(), peer->sslSession);
     } else {
         SBuf *hostName = new SBuf(request->url.host());
-        SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
+        SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, (void*)hostName);
+#endif
     }
-
-    return ssl;
+    return true;
 }
 
 void
-Ssl::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
+Security::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
 {
     if (error) {
         // XXX: forward.cc calls peerConnectSucceeded() after an OK TCP connect but
@@ -69,9 +70,15 @@ Ssl::BlindPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
     }
 
-    if (auto *peer = serverConnection()->getPeer()) {
-        const int fd = serverConnection()->fd;
-        Security::GetSessionResumeData(fd_table[fd].ssl, peer->sslSession);
+#if USE_OPENSSL
+    const int fd = serverConnection()->fd;
+    Security::SessionPtr ssl = fd_table[fd].ssl.get();
+    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
+        if (serverConnection()->getPeer()->sslSession)
+            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
+
+        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
     }
+#endif
 }
 
@@ -9,33 +9,32 @@
 #ifndef SQUID_SRC_SSL_BLINDPEERCONNECTOR_H
 #define SQUID_SRC_SSL_BLINDPEERCONNECTOR_H
 
-#include "ssl/PeerConnector.h"
+#include "security/PeerConnector.h"
 
-#if USE_OPENSSL
-
-namespace Ssl
+namespace Security
 {
 
 /// A simple PeerConnector for SSL/TLS cache_peers. No SslBump capabilities.
-class BlindPeerConnector: public PeerConnector {
+class BlindPeerConnector: public Security::PeerConnector {
     CBDATA_CLASS(BlindPeerConnector);
 public:
     BlindPeerConnector(HttpRequestPointer &aRequest,
                        const Comm::ConnectionPointer &aServerConn,
                        AsyncCall::Pointer &aCallback,
                        const AccessLogEntryPointer &alp,
                        const time_t timeout = 0) :
-        AsyncJob("Ssl::BlindPeerConnector"),
-        PeerConnector(aServerConn, aCallback, alp, timeout)
+        AsyncJob("Security::BlindPeerConnector"),
+        Security::PeerConnector(aServerConn, aCallback, alp, timeout)
     {
         request = aRequest;
     }
 
-    /* PeerConnector API */
+    /* Security::PeerConnector API */
 
-    /// Calls parent initializeSSL, configure the created SSL object to try reuse SSL session
-    /// and sets the hostname to use for certificates validation
-    virtual Security::SessionPtr initializeSsl();
+    /// Calls parent initializeTls(), configure the created TLS session object to
+    ///  try reuse TLS session and sets the hostname to use for certificates validation
+    /// \returns true on successful initialization
+    virtual bool initializeTls(Security::SessionPointer &);
 
     /// Return the configured Security::ContextPtr object
     virtual Security::ContextPtr getSslContext();
@@ -45,8 +44,7 @@ class BlindPeerConnector: public PeerConnector {
     virtual void noteNegotiationDone(ErrorState *error);
 };
 
-} // namespace Ssl
+} // namespace Security
 
-#endif /* USE_OPENSSL */
 #endif /* SQUID_SRC_SSL_BLINDPEERCONNECTOR_H */
 
@@ -9,8 +9,6 @@
 #ifndef SQUID_SRC_SECURITY_LOCKINGPOINTER_H
 #define SQUID_SRC_SECURITY_LOCKINGPOINTER_H
 
-#include "base/TidyPointer.h"
-
 #if USE_OPENSSL
 #if HAVE_OPENSSL_CRYPTO_H
 #include <openssl/crypto.h>
@@ -24,7 +22,7 @@
             sk_object ## _pop_free(a, freefunction); \
         }
 
-#endif
+#endif /* USE_OPENSSL */
 
 // Macro to be used to define the C++ equivalent function of an extern "C"
 // function. The C++ function suffixed with the _cpp extension
@@ -37,50 +35,117 @@ namespace Security
 {
 
 /**
- * Add SSL locking (a.k.a. reference counting) and assignment to TidyPointer
+ * A shared pointer to a reference-counting Object with library-specific
+ * absorption, locking, and unlocking implementations. The API largely
+ * follows std::shared_ptr.
+ *
+ * The constructor and the resetWithoutLocking() method import a raw Object pointer.
+ * Normally, reset() would lock(), but libraries like OpenSSL
+ * pre-lock objects before they are fed to LockingPointer, necessitating
+ * this resetWithoutLocking() customization hook.
  */
-template <typename T, void (*DeAllocator)(T *t), int lock>
-class LockingPointer: public TidyPointer<T, DeAllocator>
+template <typename T, void (*UnLocker)(T *t), int lockId>
+class LockingPointer
 {
 public:
-    typedef TidyPointer<T, DeAllocator> Parent;
-    typedef LockingPointer<T, DeAllocator, lock> SelfType;
+    /// a helper label to simplify this objects API definitions below
+    typedef Security::LockingPointer<T, UnLocker, lockId> SelfType;
+
+    /**
+     * Construct directly from a raw pointer.
+     * This action requires that the producer of that pointer has already
+     * created one reference lock for the object pointed to.
+     * Our destructor will do the matching unlock.
+     */
+    explicit LockingPointer(T *t = nullptr): raw(nullptr) {
+        // de-optimized for clarity about non-locking
+        resetWithoutLocking(t);
+    }
 
-    explicit LockingPointer(T *t = nullptr): Parent(t) {}
+    /// use the custom UnLocker to unlock any value still stored.
+    ~LockingPointer() { unlock(); }
 
-    explicit LockingPointer(const SelfType &o): Parent() {
+    // copy semantics are okay only when adding a lock reference
+    explicit LockingPointer(const SelfType &o) : raw(nullptr) {
         resetAndLock(o.get());
     }
-
-    SelfType &operator =(const SelfType & o) {
+    const SelfType &operator =(const SelfType &o) {
         resetAndLock(o.get());
         return *this;
     }
 
-#if __cplusplus >= 201103L
-    explicit LockingPointer(LockingPointer<T, DeAllocator, lock> &&o): Parent(o.release()) {
+    // move semantics are definitely okay, when possible
+    explicit LockingPointer(SelfType &&) = default;
+    SelfType &operator =(SelfType &&o) {
+        if (o.get() != raw)
+            resetWithoutLocking(o.release());
+        return *this;
     }
 
-    LockingPointer<T, DeAllocator, lock> &operator =(LockingPointer<T, DeAllocator, lock> &&o) {
-        if (o.get() != this->get())
-            this->reset(o.release());
-        return *this;
+    bool operator !() const { return !raw; }
+    explicit operator bool() const { return raw; }
+
+    /// Returns raw and possibly nullptr pointer
+    T *get() const { return raw; }
+
+    /// Reset raw pointer - unlock any previous one and save new one without locking.
+    void resetWithoutLocking(T *t) {
+        unlock();
+        raw = t;
     }
-#endif
 
     void resetAndLock(T *t) {
-        if (t != this->get()) {
-            this->reset(t);
+        if (t != get()) {
+            resetWithoutLocking(t);
+            lock(t);
+        }
+    }
+
+    /// Forget the raw pointer - unlock if any value was set. Become a nil pointer.
+    void reset() { unlock(); }
+
+    /// Forget the raw pointer without unlocking it. Become a nil pointer.
+    T *release() {
+        T *ret = raw;
+        raw = nullptr;
+        return ret;
+    }
+
+private:
+    /// The lock() method increments Object's reference counter.
+    void lock(T *t) {
 #if USE_OPENSSL
-            if (t)
-                CRYPTO_add(&t->references, 1, lock);
+        if (t)
+            CRYPTO_add(&t->references, 1, lockId);
 #elif USE_GNUTLS
-            // XXX: GnuTLS does not provide locking ?
+        // XXX: GnuTLS does not provide locking ?
 #else
-            assert(false);
+        assert(false);
 #endif
+    }
+
+    /// Become a nil pointer. Decrements any pointed-to Object's reference counter
+    /// using UnLocker which ideally destroys the object when the counter reaches zero.
+    void unlock() {
+        if (raw) {
+            UnLocker(raw);
+            raw = nullptr;
         }
     }
+
+    /**
+     * Normally, no other code will have this raw pointer.
+     *
+     * However, OpenSSL does some strange and not always consistent things.
+     * OpenSSL library may keep its own internal raw pointers and manage
+     * their reference counts independently, or it may not. This varies between
+     * API functions, though it is usually documented.
+     *
+     * This means the caller code needs to be carefuly written to use the correct
+     * reset method and avoid the raw-pointer constructor unless OpenSSL function
+     * producing the pointer is clearly documented as incrementing a lock for it.
+     */
+    T *raw;
 };
 
 } // namespace Security
@@ -13,6 +13,8 @@ SUBDIRS= cert_generators cert_validators
 noinst_LTLIBRARIES = libsecurity.la
 
 libsecurity_la_SOURCES= \
+	BlindPeerConnector.cc \
+	BlindPeerConnector.h \
 	Context.h \
 	EncryptorAnswer.cc \
 	EncryptorAnswer.h \
@@ -23,6 +25,8 @@ libsecurity_la_SOURCES= \
 	LockingPointer.h \
 	NegotiationHistory.cc \
 	NegotiationHistory.h \
+	PeerConnector.cc \
+	PeerConnector.h \
 	PeerOptions.cc \
 	PeerOptions.h \
 	ServerOptions.cc \
@@ -17,17 +17,19 @@
 #include "http/Stream.h"
 #include "HttpRequest.h"
 #include "security/NegotiationHistory.h"
+#include "security/PeerConnector.h"
 #include "SquidConfig.h"
+#if USE_OPENSSL
 #include "ssl/bio.h"
 #include "ssl/cert_validate_message.h"
 #include "ssl/Config.h"
 #include "ssl/helper.h"
-#include "ssl/PeerConnector.h"
+#endif
 
-CBDATA_NAMESPACED_CLASS_INIT(Ssl, PeerConnector);
+CBDATA_NAMESPACED_CLASS_INIT(Security, PeerConnector);
 
-Ssl::PeerConnector::PeerConnector(const Comm::ConnectionPointer &aServerConn, AsyncCall::Pointer &aCallback, const AccessLogEntryPointer &alp, const time_t timeout) :
-    AsyncJob("Ssl::PeerConnector"),
+Security::PeerConnector::PeerConnector(const Comm::ConnectionPointer &aServerConn, AsyncCall::Pointer &aCallback, const AccessLogEntryPointer &alp, const time_t timeout) :
+    AsyncJob("Security::PeerConnector"),
     serverConn(aServerConn),
     al(alp),
     callback(aCallback),
@@ -36,79 +38,83 @@ Ssl::PeerConnector::PeerConnector(const Comm::ConnectionPointer &aServerConn, As
     useCertValidator_(true),
     certsDownloads(0)
 {
+    debugs(83, 5, "Security::PeerConnector constructed, this=" << (void*)this);
     // if this throws, the caller's cb dialer is not our CbDialer
     Must(dynamic_cast<CbDialer*>(callback->getDialer()));
 }
 
-Ssl::PeerConnector::~PeerConnector()
+Security::PeerConnector::~PeerConnector()
 {
-    debugs(83, 5, "Peer connector " << this << " gone");
+    debugs(83, 5, "Security::PeerConnector destructed, this=" << (void*)this);
 }
 
-bool Ssl::PeerConnector::doneAll() const
+bool Security::PeerConnector::doneAll() const
 {
     return (!callback || callback->canceled()) && AsyncJob::doneAll();
 }
 
 /// Preps connection and SSL state. Calls negotiate().
 void
-Ssl::PeerConnector::start()
+Security::PeerConnector::start()
 {
     AsyncJob::start();
 
-    if (prepareSocket() && initializeSsl())
+    Security::SessionPointer tmp;
+    if (prepareSocket() && initializeTls(tmp))
         negotiateSsl();
+    else
+        mustStop("Security::PeerConnector TLS socket initialize failed");
 }
 
 void
-Ssl::PeerConnector::commCloseHandler(const CommCloseCbParams &params)
+Security::PeerConnector::commCloseHandler(const CommCloseCbParams &params)
 {
-    debugs(83, 5, "FD " << params.fd << ", Ssl::PeerConnector=" << params.data);
-    connectionClosed("Ssl::PeerConnector::commCloseHandler");
+    debugs(83, 5, "FD " << params.fd << ", Security::PeerConnector=" << params.data);
+    connectionClosed("Security::PeerConnector::commCloseHandler");
 }
 
 void
-Ssl::PeerConnector::connectionClosed(const char *reason)
+Security::PeerConnector::connectionClosed(const char *reason)
 {
     mustStop(reason);
     callback = NULL;
 }
 
 bool
-Ssl::PeerConnector::prepareSocket()
+Security::PeerConnector::prepareSocket()
 {
     const int fd = serverConnection()->fd;
     if (!Comm::IsConnOpen(serverConn) || fd_table[serverConn->fd].closing()) {
-        connectionClosed("Ssl::PeerConnector::prepareSocket");
+        connectionClosed("Security::PeerConnector::prepareSocket");
         return false;
     }
 
     // watch for external connection closures
-    typedef CommCbMemFunT<Ssl::PeerConnector, CommCloseCbParams> Dialer;
-    closeHandler = JobCallback(9, 5, Dialer, this, Ssl::PeerConnector::commCloseHandler);
+    typedef CommCbMemFunT<Security::PeerConnector, CommCloseCbParams> Dialer;
+    closeHandler = JobCallback(9, 5, Dialer, this, Security::PeerConnector::commCloseHandler);
     comm_add_close_handler(fd, closeHandler);
     return true;
 }
 
-Security::SessionPtr
-Ssl::PeerConnector::initializeSsl()
+bool
+Security::PeerConnector::initializeTls(Security::SessionPointer &serverSession)
 {
+#if USE_OPENSSL
     Security::ContextPtr sslContext(getSslContext());
     assert(sslContext);
 
-    const int fd = serverConnection()->fd;
-
-    auto ssl = Ssl::CreateClient(sslContext, fd, "server https start");
-    if (!ssl) {
+    if (!Ssl::CreateClient(sslContext, serverConnection(), "server https start")) {
         ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request.getRaw());
         anErr->xerrno = errno;
         debugs(83, DBG_IMPORTANT, "Error allocating SSL handle: " << ERR_error_string(ERR_get_error(), NULL));
-
         noteNegotiationDone(anErr);
         bail(anErr);
-        return nullptr;
+        return false;
     }
 
+    // A TLS/SSL session has now been created for the connection and stored in fd_table
+    serverSession = fd_table[serverConnection()->fd].ssl;
+
     // If CertValidation Helper used do not lookup checklist for errors,
     // but keep a list of errors to send it to CertValidator
     if (!Ssl::TheConfig.ssl_crt_validator) {
@@ -118,14 +124,18 @@ Ssl::PeerConnector::initializeSsl()
             ACLFilledChecklist *check = new ACLFilledChecklist(acl, request.getRaw(), dash_str);
             check->al = al;
             // check->fd(fd); XXX: need client FD here
-            SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
+            SSL_set_ex_data(serverSession.get(), ssl_ex_index_cert_error_check, check);
         }
     }
-    return ssl;
+
+    return true;
+#else
+    return false;
+#endif
 }
 
 void
-Ssl::PeerConnector::setReadTimeout()
+Security::PeerConnector::setReadTimeout()
 {
     int timeToRead;
     if (negotiationTimeout) {
@@ -139,8 +149,9 @@ Ssl::PeerConnector::setReadTimeout()
 }
 
 void
-Ssl::PeerConnector::recordNegotiationDetails()
+Security::PeerConnector::recordNegotiationDetails()
 {
+#if USE_OPENSSL
     const int fd = serverConnection()->fd;
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
 
@@ -151,17 +162,22 @@ Ssl::PeerConnector::recordNegotiationDetails()
     Ssl::ServerBio *bio = static_cast<Ssl::ServerBio *>(b->ptr);
     if (const Security::TlsDetails::Pointer &details = bio->receivedHelloDetails())
         serverConnection()->tlsNegotiations()->retrieveParsedInfo(details);
+#endif
 }
 
 void
-Ssl::PeerConnector::negotiateSsl()
+Security::PeerConnector::negotiateSsl()
 {
     if (!Comm::IsConnOpen(serverConnection()) || fd_table[serverConnection()->fd].closing())
         return;
 
+#if USE_OPENSSL
     const int fd = serverConnection()->fd;
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
     const int result = SSL_connect(ssl);
+#else
+    const int result = -1;
+#endif
     if (result <= 0) {
         handleNegotiateError(result);
         return; // we might be gone by now
@@ -176,8 +192,9 @@ Ssl::PeerConnector::negotiateSsl()
 }
 
 bool
-Ssl::PeerConnector::sslFinalized()
+Security::PeerConnector::sslFinalized()
 {
+#if USE_OPENSSL
     if (Ssl::TheConfig.ssl_crt_validator && useCertValidator_) {
         const int fd = serverConnection()->fd;
         Security::SessionPtr ssl = fd_table[fd].ssl.get();
@@ -196,7 +213,7 @@ Ssl::PeerConnector::sslFinalized()
             validationRequest.errors = NULL;
         try {
             debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
-            AsyncCall::Pointer call = asyncCall(83,5, "Ssl::PeerConnector::sslCrtvdHandleReply", Ssl::CertValidationHelper::CbDialer(this, &Ssl::PeerConnector::sslCrtvdHandleReply, nullptr));
+            AsyncCall::Pointer call = asyncCall(83,5, "Security::PeerConnector::sslCrtvdHandleReply", Ssl::CertValidationHelper::CbDialer(this, &Security::PeerConnector::sslCrtvdHandleReply, nullptr));
             Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, call);
             return false;
         } catch (const std::exception &e) {
@@ -213,13 +230,15 @@ Ssl::PeerConnector::sslFinalized()
             return true;
         }
     }
+#endif
 
     noteNegotiationDone(NULL);
     return true;
 }
 
+#if USE_OPENSSL
 void
-Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse::Pointer validationResponse)
+Security::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse::Pointer validationResponse)
 {
     Must(validationResponse != NULL);
 
@@ -261,12 +280,14 @@ Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse::Pointer val
     serverConn->close();
     return;
 }
+#endif
 
+#if USE_OPENSSL
 /// Checks errors in the cert. validator response against sslproxy_cert_error.
 /// The first honored error, if any, is returned via errDetails parameter.
 /// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
 Ssl::CertErrors *
-Ssl::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
+Security::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
 {
     Ssl::CertErrors *errs = NULL;
 
@@ -318,19 +339,21 @@ Ssl::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &re
 
     return errs;
 }
+#endif
 
 /// A wrapper for Comm::SetSelect() notifications.
 void
-Ssl::PeerConnector::NegotiateSsl(int, void *data)
+Security::PeerConnector::NegotiateSsl(int, void *data)
 {
     PeerConnector *pc = static_cast<PeerConnector*>(data);
     // Use job calls to add done() checks and other job logic/protections.
-    CallJobHere(83, 7, pc, Ssl::PeerConnector, negotiateSsl);
+    CallJobHere(83, 7, pc, Security::PeerConnector, negotiateSsl);
 }
 
 void
-Ssl::PeerConnector::handleNegotiateError(const int ret)
+Security::PeerConnector::handleNegotiateError(const int ret)
 {
+#if USE_OPENSSL
     const int fd = serverConnection()->fd;
     unsigned long ssl_lib_error = SSL_ERROR_NONE;
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
@@ -358,12 +381,14 @@ Ssl::PeerConnector::handleNegotiateError(const int ret)
     // Log connection details, if any
     recordNegotiationDetails();
     noteSslNegotiationError(ret, ssl_error, ssl_lib_error);
+#endif
 }
 
 void
-Ssl::PeerConnector::noteWantRead()
+Security::PeerConnector::noteWantRead()
 {
     const int fd = serverConnection()->fd;
+#if USE_OPENSSL
     Security::SessionPtr ssl = fd_table[fd].ssl.get();
     BIO *b = SSL_get_rbio(ssl);
     Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
@@ -374,33 +399,34 @@ Ssl::PeerConnector::noteWantRead()
 
             srvBio->holdRead(false);
             // schedule a negotiateSSl to allow openSSL parse received data
-            Ssl::PeerConnector::NegotiateSsl(fd, this);
+            Security::PeerConnector::NegotiateSsl(fd, this);
             return;
         } else if (srvBio->gotHelloFailed()) {
             srvBio->holdRead(false);
             debugs(83, DBG_IMPORTANT, "Error parsing SSL Server Hello Message on FD " << fd);
             // schedule a negotiateSSl to allow openSSL parse received data
-            Ssl::PeerConnector::NegotiateSsl(fd, this);
+            Security::PeerConnector::NegotiateSsl(fd, this);
             return;
         }
     }
-
+#endif
     setReadTimeout();
     Comm::SetSelect(fd, COMM_SELECT_READ, &NegotiateSsl, this, 0);
 }
 
 void
-Ssl::PeerConnector::noteWantWrite()
+Security::PeerConnector::noteWantWrite()
 {
     const int fd = serverConnection()->fd;
     Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
     return;
 }
 
 void
-Ssl::PeerConnector::noteSslNegotiationError(const int ret, const int ssl_error, const int ssl_lib_error)
+Security::PeerConnector::noteSslNegotiationError(const int ret, const int ssl_error, const int ssl_lib_error)
 {
-#ifdef EPROTO
+#if USE_OPENSSL // not used unless OpenSSL enabled.
+#if defined(EPROTO)
     int sysErrNo = EPROTO;
 #else
     int sysErrNo = EACCES;
@@ -441,10 +467,11 @@ Ssl::PeerConnector::noteSslNegotiationError(const int ret, const int ssl_error,
 
     noteNegotiationDone(anErr);
     bail(anErr);
+#endif
 }
 
 void
-Ssl::PeerConnector::bail(ErrorState *error)
+Security::PeerConnector::bail(ErrorState *error)
 {
     Must(error); // or the recepient will not know there was a problem
     Must(callback != NULL);
@@ -462,7 +489,7 @@ Ssl::PeerConnector::bail(ErrorState *error)
 }
 
 void
-Ssl::PeerConnector::callBack()
+Security::PeerConnector::callBack()
 {
     AsyncCall::Pointer cb = callback;
     // Do this now so that if we throw below, swanSong() assert that we _tried_
@@ -479,7 +506,7 @@ Ssl::PeerConnector::callBack()
 }
 
 void
-Ssl::PeerConnector::swanSong()
+Security::PeerConnector::swanSong()
 {
     // XXX: unregister fd-closure monitoring and CommSetSelect interest, if any
     AsyncJob::swanSong();
@@ -493,7 +520,7 @@ Ssl::PeerConnector::swanSong()
 }
 
 const char *
-Ssl::PeerConnector::status() const
+Security::PeerConnector::status() const
 {
     static MemBuf buf;
     buf.reset();
@@ -513,37 +540,38 @@ Ssl::PeerConnector::status() const
     return buf.content();
 }
 
+#if USE_OPENSSL
 /// CallDialer to allow use Downloader objects within PeerConnector class.
 class PeerConnectorCertDownloaderDialer: public Downloader::CbDialer
 {
 public:
-    typedef void (Ssl::PeerConnector::*Method)(SBuf &object, int status);
+    typedef void (Security::PeerConnector::*Method)(SBuf &object, int status);
 
-    PeerConnectorCertDownloaderDialer(Method method, Ssl::PeerConnector *pc):
+    PeerConnectorCertDownloaderDialer(Method method, Security::PeerConnector *pc):
         method_(method),
         peerConnector_(pc) {}
 
     /* CallDialer API */
     virtual bool canDial(AsyncCall &call) { return peerConnector_.valid(); }
     virtual void dial(AsyncCall &call) { ((&(*peerConnector_))->*method_)(object, status); }
-    Method method_; ///< The Ssl::PeerConnector method to dial
-    CbcPointer<Ssl::PeerConnector> peerConnector_; ///< The Ssl::PeerConnector object
+    Method method_; ///< The Security::PeerConnector method to dial
+    CbcPointer<Security::PeerConnector> peerConnector_; ///< The Security::PeerConnector object
 };
 
 void
-Ssl::PeerConnector::startCertDownloading(SBuf &url)
+Security::PeerConnector::startCertDownloading(SBuf &url)
 {
     AsyncCall::Pointer certCallback = asyncCall(81, 4,
-                                            "Ssl::PeerConnector::certDownloadingDone",
-                                            PeerConnectorCertDownloaderDialer(&Ssl::PeerConnector::certDownloadingDone, this));
+                                            "Security::PeerConnector::certDownloadingDone",
+                                            PeerConnectorCertDownloaderDialer(&Security::PeerConnector::certDownloadingDone, this));
 
     const Downloader *csd = dynamic_cast<const Downloader*>(request->downloader.valid());
     Downloader *dl = new Downloader(url, certCallback, csd ? csd->nestedLevel() + 1 : 1);
     AsyncJob::Start(dl);
 }
 
 void
-Ssl::PeerConnector::certDownloadingDone(SBuf &obj, int downloadStatus)
+Security::PeerConnector::certDownloadingDone(SBuf &obj, int downloadStatus)
 {
     ++certsDownloads;
     debugs(81, 5, "Certificate downloading status: " << downloadStatus << " certificate size: " << obj.length());
@@ -581,11 +609,11 @@ Ssl::PeerConnector::certDownloadingDone(SBuf &obj, int downloadStatus)
     }
 
     srvBio->holdRead(false);
-    Ssl::PeerConnector::NegotiateSsl(serverConnection()->fd, this);
+    Security::PeerConnector::NegotiateSsl(serverConnection()->fd, this);
 }
 
 bool
-Ssl::PeerConnector::checkForMissingCertificates()
+Security::PeerConnector::checkForMissingCertificates()
 {
     // Check for nested SSL certificates downloads. For example when the
     // certificate located in an SSL site which requires to download a
@@ -613,4 +641,4 @@ Ssl::PeerConnector::checkForMissingCertificates()
 
     return false;
 }
-
+#endif //USE_OPENSSL
@@ -14,23 +14,23 @@
 #include "base/AsyncJob.h"
 #include "CommCalls.h"
 #include "security/EncryptorAnswer.h"
+#include "security/forward.h"
+#if USE_OPENSSL
 #include "ssl/support.h"
+#endif
 
 #include <iosfwd>
 #include <queue>
 
-#if USE_OPENSSL
-
 class HttpRequest;
 class ErrorState;
 class AccessLogEntry;
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 
-namespace Ssl
+namespace Security
 {
 
 /**
- \par
  * Connects Squid to SSL/TLS-capable peers or services.
  * Contains common code and interfaces of various specialized PeerConnectors,
  * including peer certificate validation code.
@@ -103,7 +103,8 @@ class PeerConnector: virtual public AsyncJob
     /// silent server
     void setReadTimeout();
 
-    virtual Security::SessionPtr initializeSsl(); ///< Initializes SSL state
+    /// \returns true on successful TLS session initialization
+    virtual bool initializeTls(Security::SessionPointer &);
 
     /// Performs a single secure connection negotiation step.
     /// It is called multiple times untill the negotiation finish or aborted.
@@ -125,6 +126,7 @@ class PeerConnector: virtual public AsyncJob
     /// Squid COMM_SELECT_READ handler.
     void noteWantRead();
 
+#if USE_OPENSSL
     /// Run the certificates list sent by the SSL server and check if there
     /// are missing certificates. Adds to the urlOfMissingCerts list the 
     /// URLS of missing certificates if this information provided by the
@@ -136,6 +138,7 @@ class PeerConnector: virtual public AsyncJob
 
     /// Called by Downloader after a certificate object downloaded.
     void certDownloadingDone(SBuf &object, int status);
+#endif
 
     /// Called when the openSSL SSL_connect function needs to write data to
     /// the remote SSL server. Sets the Squid COMM_SELECT_WRITE handler.
@@ -180,11 +183,13 @@ class PeerConnector: virtual public AsyncJob
     PeerConnector(const PeerConnector &); // not implemented
     PeerConnector &operator =(const PeerConnector &); // not implemented
 
+#if USE_OPENSSL
     /// Process response from cert validator helper
     void sslCrtvdHandleReply(Ssl::CertValidationResponsePointer);
 
     /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
     Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
+#endif
 
     /// A wrapper function for negotiateSsl for use with Comm::SetSelect
     static void NegotiateSsl(int fd, void *data);
@@ -203,8 +208,7 @@ class PeerConnector: virtual public AsyncJob
     unsigned int certsDownloads; ///< the number of downloaded missing certificates
 };
 
-} // namespace Ssl
+} // namespace Security
 
-#endif /* USE_OPENSSL */
 #endif /* SQUID_SRC_SSL_PEERCONNECTOR_H */
 
@@ -161,7 +161,7 @@ Security::ServerOptions::loadDhParams()
         }
     }
 
-    parsedDhParams.reset(dhp);
+    parsedDhParams.resetWithoutLocking(dhp);
 #endif
 }
 
@@ -16,45 +16,6 @@
 #define SSL_SESSION_ID_SIZE 32
 #define SSL_SESSION_MAX_SIZE 10*1024
 
-bool
-Security::SessionIsResumed(const Security::SessionPointer &s)
-{
-    return
-#if USE_OPENSSL
-        SSL_session_reused(s.get()) == 1;
-#elif USE_GNUTLS
-        gnutls_session_is_resumed(s.get()) != 0;
-#else
-        false;
-#endif
-}
-
-void
-Security::GetSessionResumeData(const Security::SessionPointer &s, Security::SessionStatePointer &data)
-{
-    if (!SessionIsResumed(s)) {
-#if USE_OPENSSL
-        data.reset(SSL_get1_session(s.get()));
-#elif USE_GNUTLS
-        gnutls_datum_t *tmp = nullptr;
-        (void)gnutls_session_get_data2(s.get(), tmp);
-        data.reset(tmp);
-#endif
-    }
-}
-
-void
-Security::SetSessionResumeData(const Security::SessionPtr &s, const Security::SessionStatePointer &data)
-{
-    if (s) {
-#if USE_OPENSSL
-        (void)SSL_set_session(s, data.get());
-#elif USE_GNUTLS
-        (void)gnutls_session_set_data(s, data->data, data->size);
-#endif
-    }
-}
-
 static bool
 isTlsServer()
 {
@@ -9,9 +9,10 @@
 #ifndef SQUID_SRC_SECURITY_SESSION_H
 #define SQUID_SRC_SECURITY_SESSION_H
 
-// LockingPointer.h instead of TidyPointer.h for CtoCpp1()
 #include "security/LockingPointer.h"
 
+#include <memory>
+
 #if USE_OPENSSL
 #if HAVE_OPENSSL_SSL_H
 #include <openssl/ssl.h>
@@ -31,41 +32,22 @@ typedef SSL* SessionPtr;
 CtoCpp1(SSL_free, SSL *);
 typedef LockingPointer<SSL, Security::SSL_free_cpp, CRYPTO_LOCK_SSL> SessionPointer;
 
-typedef SSL_SESSION* SessionStatePtr;
-CtoCpp1(SSL_SESSION_free, SSL_SESSION *);
-typedef LockingPointer<SSL_SESSION, Security::SSL_SESSION_free_cpp, CRYPTO_LOCK_SSL_SESSION> SessionStatePointer;
-
 #elif USE_GNUTLS
 typedef gnutls_session_t SessionPtr;
-CtoCpp1(gnutls_deinit, gnutls_session_t);
-// TODO: Convert to Locking pointer.
 // Locks can be implemented attaching locks counter to gnutls_session_t
 // objects using the gnutls_session_set_ptr()/gnutls_session_get_ptr ()
 // library functions
-typedef TidyPointer<struct gnutls_session_int, Security::gnutls_deinit_cpp> SessionPointer;
-
-typedef gnutls_datum_t *SessionStatePtr;
-CtoCpp1(gnutls_free, gnutls_datum_t *);
-typedef TidyPointer<gnutls_datum_t, Security::gnutls_free_cpp> SessionStatePointer;
+CtoCpp1(gnutls_deinit, gnutls_session_t);
+typedef LockingPointer<struct gnutls_session_int, gnutls_deinit_cpp, -1> SessionPointer;
 
 #else
 // use void* so we can check against NULL
 typedef void* SessionPtr;
-typedef TidyPointer<void, nullptr> SessionPointer;
-typedef TidyPointer<void, nullptr> SessionStatePointer;
+CtoCpp1(xfree, SessionPtr);
+typedef LockingPointer<void, xfree_cpp, -1> SessionPointer;
 
 #endif
 
-/// whether the session is a resumed one
-bool SessionIsResumed(const Security::SessionPointer &);
-
-/// Retrieve the data needed to resume this session on a later connection
-void GetSessionResumeData(const Security::SessionPointer &, Security::SessionStatePointer &);
-
-/// Set the data for resuming a previous session.
-/// Needs to be done before using the SessionPointer for a handshake.
-void SetSessionResumeData(const Security::SessionPtr &, const Security::SessionStatePointer &);
-
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_SESSION_H */
@@ -7,10 +7,12 @@
  */
 
 #include "squid.h"
+#include "base/HardFun.h"
 #include "security/cert_generators/file/certificate_db.h"
 
 #include <cerrno>
 #include <fstream>
+#include <memory>
 #include <stdexcept>
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
@@ -252,7 +254,6 @@ Ssl::CertificateDb::CertificateDb(std::string const & aDb_path, size_t aMax_db_s
        db_full(aDb_path + "/" + db_file),
        cert_full(aDb_path + "/" + cert_dir),
        size_full(aDb_path + "/" + size_file),
-       db(NULL),
        max_db_size(aMax_db_size),
        fs_block_size((aFs_block_size ? aFs_block_size : 2048)),
        dbLock(db_full),
@@ -287,12 +288,16 @@ bool Ssl::CertificateDb::addCertAndPrivateKey(Security::CertPointer & cert, Ssl:
     load();
     if (!db || !cert || !pkey)
         return false;
+
+    // Functor to wrap xfree() for std::unique_ptr
+    typedef HardFun<void, const void*, &xfree> CharDeleter;
+
     Row row;
     ASN1_INTEGER * ai = X509_get_serialNumber(cert.get());
     std::string serial_string;
     Ssl::BIGNUM_Pointer serial(ASN1_INTEGER_to_BN(ai, NULL));
     {
-        TidyPointer<char, tidyFree> hex_bn(BN_bn2hex(serial.get()));
+        std::unique_ptr<char, CharDeleter> hex_bn(BN_bn2hex(serial.get()));
         serial_string = std::string(hex_bn.get());
     }
     row.setValue(cnlSerial, serial_string.c_str());
@@ -305,13 +310,13 @@ bool Ssl::CertificateDb::addCertAndPrivateKey(Security::CertPointer & cert, Ssl:
     }
 
     {
-        TidyPointer<char, tidyFree> subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
+        std::unique_ptr<char, CharDeleter> subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), nullptr, 0));
         Security::CertPointer findCert;
         Ssl::EVP_PKEY_Pointer findPkey;
         if (pure_find(useName.empty() ? subject.get() : useName, findCert, findPkey)) {
             // Replace with database certificate
-            cert.reset(findCert.release());
-            pkey.reset(findPkey.release());
+            cert = std::move(findCert);
+            pkey = std::move(findPkey);
             return true;
         }
         // pure_find may fail because the entry is expired, or because the
@@ -348,7 +353,7 @@ bool Ssl::CertificateDb::addCertAndPrivateKey(Security::CertPointer & cert, Ssl:
     if (!useName.empty())
         row.setValue(cnlName, useName.c_str());
     else {
-        TidyPointer<char, tidyFree> subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
+        std::unique_ptr<char, CharDeleter> subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), nullptr, 0));
         row.setValue(cnlName, subject.get());
     }
 
@@ -204,8 +204,8 @@ static bool processNewRequest(Ssl::CrtdMessage & request_message, std::string co
         if (!Ssl::certificateMatchesProperties(cert.get(), certProperties)) {
             // The certificate changed (renewed or other reason).
             // Generete a new one with the updated fields.
-            cert.reset(NULL);
-            pkey.reset(NULL);
+            cert.resetWithoutLocking(nullptr);
+            pkey.resetWithoutLocking(nullptr);
             db.purgeCert(cert_subject);
         }
     }
@@ -19,6 +19,16 @@
 #endif
 #include <list>
 
+#if USE_OPENSSL
+// Macro to be used to define the C++ wrapper functor of the sk_*_pop_free
+// OpenSSL family of functions. The C++ functor is suffixed with the _free_wrapper
+// extension
+#define sk_dtor_wrapper(sk_object, argument_type, freefunction) \
+        struct sk_object ## _free_wrapper { \
+            void operator()(argument_type a) { sk_object ## _pop_free(a, freefunction); } \
+        }
+#endif /* USE_OPENSSL */
+
 /* flags a SSL connection can be configured with */
 #define SSL_FLAG_NO_DEFAULT_CA      (1<<0)
 #define SSL_FLAG_DELAYED_AUTH       (1<<1)
@@ -32,10 +42,6 @@
 namespace Security
 {
 
-class EncryptorAnswer;
-class PeerOptions;
-class ServerOptions;
-
 #if USE_OPENSSL
 CtoCpp1(X509_free, X509 *)
 typedef Security::LockingPointer<X509, X509_free_cpp, CRYPTO_LOCK_X509> CertPointer;
@@ -67,7 +73,11 @@ typedef Security::LockingPointer<DH, DH_free_cpp, CRYPTO_LOCK_DH> DhePointer;
 typedef void *DhePointer;
 #endif
 
+class EncryptorAnswer;
 class KeyData;
+class PeerConnector;
+class PeerOptions;
+class ServerOptions;
 
 } // namespace Security
 
@@ -167,6 +167,7 @@ Server::doClientRead(const CommIoCbParams &io)
     // case Comm::COMM_ERROR:
     default: // no other flags should ever occur
         debugs(33, 2, io.conn << ": got flag " << rd.flag << "; " << xstrerr(rd.xerrno));
+        checkLogging();
         pipeline.terminateAll(rd.xerrno);
         io.conn->close();
         return;
@@ -117,6 +117,9 @@ class Server : virtual public AsyncJob, public BodyProducer
     void doClientRead(const CommIoCbParams &io);
     void clientWriteDone(const CommIoCbParams &io);
 
+    /// Log the current [attempt at] transaction if nobody else will.
+    virtual void checkLogging() = 0;
+
     AsyncCall::Pointer reader; ///< set when we are reading
     AsyncCall::Pointer writer; ///< set when we are writing
 };
@@ -14,8 +14,6 @@ noinst_LTLIBRARIES = libsslsquid.la libsslutil.la
 libsslsquid_la_SOURCES = \
 	bio.cc \
 	bio.h \
-	BlindPeerConnector.cc \
-	BlindPeerConnector.h \
 	cert_validate_message.cc \
 	cert_validate_message.h \
 	context_storage.cc \
@@ -28,8 +26,6 @@ libsslsquid_la_SOURCES = \
 	ErrorDetailManager.h \
 	PeekingPeerConnector.cc \
 	PeekingPeerConnector.h \
-	PeerConnector.cc \
-	PeerConnector.h \
 	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \
@@ -97,7 +97,7 @@ Ssl::PeekingPeerConnector::checkForPeekAndSpliceMatched(const Ssl::BumpMode acti
         srvBio->holdWrite(false);
         srvBio->recordInput(false);
         debugs(83,5, "Retry the fwdNegotiateSSL on FD " << serverConn->fd);
-        Ssl::PeerConnector::noteWantWrite();
+        Security::PeerConnector::noteWantWrite();
     } else {
         splice = true;
         // Ssl Negotiation stops here. Last SSL checks for valid certificates
@@ -133,12 +133,11 @@ Ssl::PeekingPeerConnector::getSslContext()
     return ::Config.ssl_client.sslContext;
 }
 
-Security::SessionPtr
-Ssl::PeekingPeerConnector::initializeSsl()
+bool
+Ssl::PeekingPeerConnector::initializeTls(Security::SessionPointer &serverSession)
 {
-    auto ssl = Ssl::PeerConnector::initializeSsl();
-    if (!ssl)
-        return nullptr;
+    if (!Security::PeerConnector::initializeTls(serverSession))
+        return false;
 
     if (ConnStateData *csd = request->clientConnectionManager.valid()) {
 
@@ -147,8 +146,8 @@ Ssl::PeekingPeerConnector::initializeSsl()
         assert(clientConn != NULL);
         SBuf *hostName = NULL;
 
-        //Enable Status_request tls extension, required to bump some clients
-        SSL_set_tlsext_status_type(ssl, TLSEXT_STATUSTYPE_ocsp);
+        //Enable Status_request TLS extension, required to bump some clients
+        SSL_set_tlsext_status_type(serverSession.get(), TLSEXT_STATUSTYPE_ocsp);
 
         const Security::TlsDetails::Pointer details = csd->tlsParser.details;
         if (details && !details->serverName.isEmpty())
@@ -164,20 +163,20 @@ Ssl::PeekingPeerConnector::initializeSsl()
         }
 
         if (hostName)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
+            SSL_set_ex_data(serverSession.get(), ssl_ex_index_server, (void*)hostName);
 
         Must(!csd->serverBump() || csd->serverBump()->step <= Ssl::bumpStep2);
         if (csd->sslBumpMode == Ssl::bumpPeek || csd->sslBumpMode == Ssl::bumpStare) {
-            auto clientSsl = fd_table[clientConn->fd].ssl.get();
-            Must(clientSsl);
-            BIO *bc = SSL_get_rbio(clientSsl);
+            auto clientSession = fd_table[clientConn->fd].ssl.get();
+            Must(clientSession);
+            BIO *bc = SSL_get_rbio(clientSession);
             Ssl::ClientBio *cltBio = static_cast<Ssl::ClientBio *>(bc->ptr);
             Must(cltBio);
             if (details && details->tlsVersion.protocol != AnyP::PROTO_NONE) {
-                applyTlsDetailsToSSL(ssl, details, csd->sslBumpMode);
+                applyTlsDetailsToSSL(serverSession.get(), details, csd->sslBumpMode);
                 // Should we allow it for all protocols?
                 if (details->tlsVersion.protocol == AnyP::PROTO_TLS || details->tlsVersion == AnyP::ProtocolVersion(AnyP::PROTO_SSL, 3, 0)) {
-                    BIO *b = SSL_get_rbio(ssl);
+                    BIO *b = SSL_get_rbio(serverSession.get());
                     Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
                     // Inherite client features, like SSL version, SNI and other
                     srvBio->setClientFeatures(details, cltBio->rBufData());
@@ -187,7 +186,7 @@ Ssl::PeekingPeerConnector::initializeSsl()
             }
         } else {
             // Set client SSL options
-            SSL_set_options(ssl, ::Security::ProxyOutgoingConfig.parsedOptions);
+            SSL_set_options(serverSession.get(), ::Security::ProxyOutgoingConfig.parsedOptions);
 
             // Use SNI TLS extension only when we connect directly
             // to the origin server and we know the server host name.
@@ -199,20 +198,20 @@ Ssl::PeekingPeerConnector::initializeSsl()
                 sniServer = hostName->c_str();
 
             if (sniServer)
-                Ssl::setClientSNI(ssl, sniServer);
+                Ssl::setClientSNI(serverSession.get(), sniServer);
         }
 
         if (Ssl::ServerBump *serverBump = csd->serverBump()) {
-            serverBump->attachServerSSL(ssl);
+            serverBump->attachServerSSL(serverSession.get());
             // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
             if (X509 *peeked_cert = serverBump->serverCert.get()) {
                 CRYPTO_add(&(peeked_cert->references),1,CRYPTO_LOCK_X509);
-                SSL_set_ex_data(ssl, ssl_ex_index_ssl_peeked_cert, peeked_cert);
+                SSL_set_ex_data(serverSession.get(), ssl_ex_index_ssl_peeked_cert, peeked_cert);
             }
         }
     }
 
-    return ssl;
+    return true;
 }
 
 void
@@ -274,7 +273,7 @@ Ssl::PeekingPeerConnector::noteWantWrite()
         return;
     }
 
-    Ssl::PeerConnector::noteWantWrite();
+    Security::PeerConnector::noteWantWrite();
 }
 
 void
@@ -319,7 +318,7 @@ Ssl::PeekingPeerConnector::noteSslNegotiationError(const int result, const int s
     }
 
     // else call parent noteNegotiationError to produce an error page
-    Ssl::PeerConnector::noteSslNegotiationError(result, ssl_error, ssl_lib_error);
+    Security::PeerConnector::noteSslNegotiationError(result, ssl_error, ssl_lib_error);
 }
 
 void
@@ -339,7 +338,7 @@ Ssl::PeekingPeerConnector::handleServerCertificate()
 
         // remember the server certificate for later use
         if (Ssl::ServerBump *serverBump = csd->serverBump()) {
-            serverBump->serverCert.reset(serverCert.release());
+            serverBump->serverCert = std::move(serverCert);
         }
     }
 }
@@ -354,7 +353,7 @@ Ssl::PeekingPeerConnector::serverCertificateVerified()
         else {
             const int fd = serverConnection()->fd;
             Security::SessionPtr ssl = fd_table[fd].ssl.get();
-            serverCert.reset(SSL_get_peer_certificate(ssl));
+            serverCert.resetWithoutLocking(SSL_get_peer_certificate(ssl));
         }
         if (serverCert.get()) {
             csd->resetSslCommonName(Ssl::CommonHostName(serverCert.get()));
@@ -9,15 +9,15 @@
 #ifndef SQUID_SRC_SSL_PEEKINGPEERCONNECTOR_H
 #define SQUID_SRC_SSL_PEEKINGPEERCONNECTOR_H
 
-#include "ssl/PeerConnector.h"
+#include "security/PeerConnector.h"
 
 #if USE_OPENSSL
 
 namespace Ssl
 {
 
 /// A PeerConnector for HTTP origin servers. Capable of SslBumping.
-class PeekingPeerConnector: public PeerConnector {
+class PeekingPeerConnector: public Security::PeerConnector {
     CBDATA_CLASS(PeekingPeerConnector);
 public:
     PeekingPeerConnector(HttpRequestPointer &aRequest,
@@ -27,7 +27,7 @@ class PeekingPeerConnector: public PeerConnector {
                          const AccessLogEntryPointer &alp,
                          const time_t timeout = 0) :
         AsyncJob("Ssl::PeekingPeerConnector"),
-        PeerConnector(aServerConn, aCallback, alp, timeout),
+        Security::PeerConnector(aServerConn, aCallback, alp, timeout),
         clientConn(aClientConn),
         splice(false),
         resumingSession(false),
@@ -36,8 +36,8 @@ class PeekingPeerConnector: public PeerConnector {
         request = aRequest;
     }
 
-    /* PeerConnector API */
-    virtual Security::SessionPtr initializeSsl();
+    /* Security::PeerConnector API */
+    virtual bool initializeTls(Security::SessionPointer &);
     virtual Security::ContextPtr getSslContext();
     virtual void noteWantWrite();
     virtual void noteSslNegotiationError(const int result, const int ssl_error, const int ssl_lib_error);
@@ -130,12 +130,12 @@ bool Ssl::readCertAndPrivateKeyFromMemory(Security::CertPointer & cert, Ssl::EVP
     BIO_puts(bio.get(), bufferToRead);
 
     X509 * certPtr = NULL;
-    cert.reset(PEM_read_bio_X509(bio.get(), &certPtr, 0, 0));
+    cert.resetWithoutLocking(PEM_read_bio_X509(bio.get(), &certPtr, 0, 0));
     if (!cert)
         return false;
 
     EVP_PKEY * pkeyPtr = NULL;
-    pkey.reset(PEM_read_bio_PrivateKey(bio.get(), &pkeyPtr, 0, 0));
+    pkey.resetWithoutLocking(PEM_read_bio_PrivateKey(bio.get(), &pkeyPtr, 0, 0));
     if (!pkey)
         return false;
 
@@ -148,7 +148,7 @@ bool Ssl::readCertFromMemory(Security::CertPointer & cert, char const * bufferTo
     BIO_puts(bio.get(), bufferToRead);
 
     X509 * certPtr = NULL;
-    cert.reset(PEM_read_bio_X509(bio.get(), &certPtr, 0, 0));
+    cert.resetWithoutLocking(PEM_read_bio_X509(bio.get(), &certPtr, 0, 0));
     if (!cert)
         return false;
 
@@ -511,7 +511,7 @@ static bool generateFakeSslCertificate(Security::CertPointer & certToStore, Ssl:
     if (properties.signWithPkey.get())
         pkey.resetAndLock(properties.signWithPkey.get());
     else // if not exist generate one
-        pkey.reset(Ssl::createSslPrivateKey());
+        pkey.resetWithoutLocking(Ssl::createSslPrivateKey());
 
     if (!pkey)
         return false;
@@ -550,8 +550,8 @@ static bool generateFakeSslCertificate(Security::CertPointer & certToStore, Ssl:
     if (!ret)
         return false;
 
-    certToStore.reset(cert.release());
-    pkeyToStore.reset(pkey.release());
+    certToStore = std::move(cert);
+    pkeyToStore = std::move(pkey);
     return true;
 }
 
@@ -676,11 +676,11 @@ void Ssl::readCertAndPrivateKeyFromFiles(Security::CertPointer & cert, Ssl::EVP_
 {
     if (keyFilename == NULL)
         keyFilename = certFilename;
-    pkey.reset(readSslPrivateKey(keyFilename));
-    cert.reset(readSslX509Certificate(certFilename));
+    pkey.resetWithoutLocking(readSslPrivateKey(keyFilename));
+    cert.resetWithoutLocking(readSslX509Certificate(certFilename));
     if (!pkey || !cert || !X509_check_private_key(cert.get(), pkey.get())) {
-        pkey.reset(NULL);
-        cert.reset(NULL);
+        pkey.reset();
+        cert.reset();
     }
 }
 
@@ -9,6 +9,7 @@
 #ifndef SQUID_SSL_GADGETS_H
 #define SQUID_SSL_GADGETS_H
 
+#include "base/HardFun.h"
 #include "security/forward.h"
 #include "ssl/crtd_message.h"
 
@@ -39,53 +40,41 @@ typedef SSL_METHOD * ContextMethod;
 #endif
 
 /**
- \ingroup SslCrtdSslAPI
- * TidyPointer typedefs for  common SSL objects
+ * std::unique_ptr typedefs for common SSL objects
  */
-sk_free_wrapper(sk_X509, STACK_OF(X509) *, X509_free)
-typedef TidyPointer<STACK_OF(X509), sk_X509_free_wrapper> X509_STACK_Pointer;
+sk_dtor_wrapper(sk_X509, STACK_OF(X509) *, X509_free);
+typedef std::unique_ptr<STACK_OF(X509), sk_X509_free_wrapper> X509_STACK_Pointer;
 
 CtoCpp1(EVP_PKEY_free, EVP_PKEY *)
 typedef Security::LockingPointer<EVP_PKEY, EVP_PKEY_free_cpp, CRYPTO_LOCK_EVP_PKEY> EVP_PKEY_Pointer;
 
-CtoCpp1(BN_free, BIGNUM *)
-typedef TidyPointer<BIGNUM, BN_free_cpp> BIGNUM_Pointer;
+typedef std::unique_ptr<BIGNUM, HardFun<void, BIGNUM*, &BN_free>> BIGNUM_Pointer;
 
-CtoCpp1(BIO_free, BIO *)
-typedef TidyPointer<BIO, BIO_free_cpp> BIO_Pointer;
+typedef std::unique_ptr<BIO, HardFun<void, BIO*, &BIO_vfree>> BIO_Pointer;
 
-CtoCpp1(ASN1_INTEGER_free, ASN1_INTEGER *)
-typedef TidyPointer<ASN1_INTEGER, ASN1_INTEGER_free_cpp> ASN1_INT_Pointer;
+typedef std::unique_ptr<ASN1_INTEGER, HardFun<void, ASN1_INTEGER*, &ASN1_INTEGER_free>> ASN1_INT_Pointer;
 
-CtoCpp1(ASN1_OCTET_STRING_free, ASN1_OCTET_STRING *)
-typedef TidyPointer<ASN1_OCTET_STRING, ASN1_OCTET_STRING_free_cpp> ASN1_OCTET_STRING_Pointer;
+typedef std::unique_ptr<ASN1_OCTET_STRING, HardFun<void, ASN1_OCTET_STRING*, &ASN1_OCTET_STRING_free>> ASN1_OCTET_STRING_Pointer;
 
-CtoCpp1(TXT_DB_free, TXT_DB *)
-typedef TidyPointer<TXT_DB, TXT_DB_free_cpp> TXT_DB_Pointer;
+typedef std::unique_ptr<TXT_DB, HardFun<void, TXT_DB*, &TXT_DB_free>> TXT_DB_Pointer;
 
-CtoCpp1(X509_NAME_free, X509_NAME *)
-typedef TidyPointer<X509_NAME, X509_NAME_free_cpp> X509_NAME_Pointer;
+typedef std::unique_ptr<X509_NAME, HardFun<void, X509_NAME*, &X509_NAME_free>> X509_NAME_Pointer;
 
-CtoCpp1(RSA_free, RSA *)
-typedef TidyPointer<RSA, RSA_free_cpp> RSA_Pointer;
+typedef std::unique_ptr<RSA, HardFun<void, RSA*, &RSA_free>> RSA_Pointer;
 
-CtoCpp1(X509_REQ_free, X509_REQ *)
-typedef TidyPointer<X509_REQ, X509_REQ_free_cpp> X509_REQ_Pointer;
+typedef std::unique_ptr<X509_REQ, HardFun<void, X509_REQ*, &X509_REQ_free>> X509_REQ_Pointer;
 
-sk_free_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free)
-typedef TidyPointer<STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper> X509_NAME_STACK_Pointer;
+sk_dtor_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free);
+typedef std::unique_ptr<STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper> X509_NAME_STACK_Pointer;
 
-CtoCpp1(AUTHORITY_KEYID_free, AUTHORITY_KEYID *)
-typedef TidyPointer<AUTHORITY_KEYID, AUTHORITY_KEYID_free_cpp> AUTHORITY_KEYID_Pointer;
+typedef std::unique_ptr<AUTHORITY_KEYID, HardFun<void, AUTHORITY_KEYID*, &AUTHORITY_KEYID_free>> AUTHORITY_KEYID_Pointer;
 
-sk_free_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free)
-typedef TidyPointer<STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper> GENERAL_NAME_STACK_Pointer;
+sk_dtor_wrapper(sk_GENERAL_NAME, STACK_OF(GENERAL_NAME) *, GENERAL_NAME_free);
+typedef std::unique_ptr<STACK_OF(GENERAL_NAME), sk_GENERAL_NAME_free_wrapper> GENERAL_NAME_STACK_Pointer;
 
-CtoCpp1(GENERAL_NAME_free, GENERAL_NAME *)
-typedef TidyPointer<GENERAL_NAME, GENERAL_NAME_free_cpp> GENERAL_NAME_Pointer;
+typedef std::unique_ptr<GENERAL_NAME, HardFun<void, GENERAL_NAME*, &GENERAL_NAME_free>> GENERAL_NAME_Pointer;
 
-CtoCpp1(X509_EXTENSION_free, X509_EXTENSION *)
-typedef TidyPointer<X509_EXTENSION, X509_EXTENSION_free_cpp> X509_EXTENSION_Pointer;
+typedef std::unique_ptr<X509_EXTENSION, HardFun<void, X509_EXTENSION*, &X509_EXTENSION_free>> X509_EXTENSION_Pointer;
 
 /**
  \ingroup SslCrtdSslAPI
@@ -85,8 +85,7 @@ void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void
     std::string msg = message.compose();
     msg += '\n';
     if (!ssl_crtd->trySubmit(msg.c_str(), callback, data)) {
-        ::Helper::Reply failReply;
-        failReply.result = ::Helper::BrokenHelper;
+        ::Helper::Reply failReply(::Helper::BrokenHelper);
         failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
         callback(data, failReply);
         return;
@@ -198,6 +197,9 @@ sslCrtvdHandleReplyWrapper(void *data, const ::Helper::Reply &reply)
     if (reply.result == ::Helper::BrokenHelper) {
         debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper error response: " << reply.other().content());
         validationResponse->resultCode = ::Helper::BrokenHelper;
+    } else if (!reply.other().hasContent()) {
+        debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper returned NULL response");
+        validationResponse->resultCode = ::Helper::BrokenHelper;
     } else if (replyMsg.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK ||
                !replyMsg.parseResponse(*validationResponse, peerCerts, error) ) {
         debugs(83, DBG_IMPORTANT, "WARNING: Reply from ssl_crtvd for " << " is incorrect");
@@ -9,9 +9,12 @@
 #ifndef SQUID_SSL_HELPER_H
 #define SQUID_SSL_HELPER_H
 
+#if USE_OPENSSL
+
 #include "base/AsyncJobCalls.h"
 #include "base/LruMap.h"
 #include "helper/forward.h"
+#include "security/forward.h"
 #include "ssl/cert_validate_message.h"
 #include "ssl/crtd_message.h"
 
@@ -39,13 +42,12 @@ class Helper
 };
 #endif
 
-class PeerConnector;
 class CertValidationRequest;
 class CertValidationResponse;
 class CertValidationHelper
 {
 public:
-    typedef UnaryMemFunT<Ssl::PeerConnector, CertValidationResponse::Pointer> CbDialer;
+    typedef UnaryMemFunT<Security::PeerConnector, CertValidationResponse::Pointer> CbDialer;
 
     typedef void CVHCB(void *, Ssl::CertValidationResponse const &);
     static CertValidationHelper * GetInstance(); ///< Instance class.
@@ -64,5 +66,7 @@ class CertValidationHelper
 };
 
 } //namespace Ssl
+
+#endif /* USE_OPENSSL */
 #endif // SQUID_SSL_HELPER_H
 
@@ -318,7 +318,7 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
                 }
                 delete filledCheck->sslErrors;
                 filledCheck->sslErrors = NULL;
-                filledCheck->serverCert.reset(NULL);
+                filledCheck->serverCert.reset();
             }
             // If the certificate validator is used then we need to allow all errors and
             // pass them to certficate validator for more processing
@@ -1367,11 +1367,11 @@ void Ssl::readCertChainAndPrivateKeyFromFiles(Security::CertPointer & cert, EVP_
     // XXX: ssl_ask_password_cb needs SSL_CTX_set_default_passwd_cb_userdata()
     // so this may not fully work iff Config.Program.ssl_password is set.
     pem_password_cb *cb = ::Config.Program.ssl_password ? &ssl_ask_password_cb : NULL;
-    pkey.reset(readSslPrivateKey(keyFilename, cb));
-    cert.reset(readSslX509CertificatesChain(certFilename, chain.get()));
+    pkey.resetWithoutLocking(readSslPrivateKey(keyFilename, cb));
+    cert.resetWithoutLocking(readSslX509CertificatesChain(certFilename, chain.get()));
     if (!pkey || !cert || !X509_check_private_key(cert.get(), pkey.get())) {
-        pkey.reset(NULL);
-        cert.reset(NULL);
+        pkey.reset();
+        cert.reset();
     }
 }
 
@@ -1398,26 +1398,27 @@ bool Ssl::generateUntrustedCert(Security::CertPointer &untrustedCert, EVP_PKEY_P
     return Ssl::generateSslCertificate(untrustedCert, untrustedPkey, certProperties);
 }
 
-SSL *
-SslCreate(Security::ContextPtr sslContext, const int fd, Ssl::Bio::Type type, const char *squidCtx)
+static bool
+SslCreate(Security::ContextPtr sslContext, const Comm::ConnectionPointer &conn, Ssl::Bio::Type type, const char *squidCtx)
 {
-    if (fd < 0) {
+    if (!Comm::IsConnOpen(conn)) {
         debugs(83, DBG_IMPORTANT, "Gone connection");
-        return NULL;
+        return false;
     }
 
     const char *errAction = NULL;
     int errCode = 0;
     if (auto ssl = SSL_new(sslContext)) {
+        const int fd = conn->fd;
         // without BIO, we would call SSL_set_fd(ssl, fd) instead
         if (BIO *bio = Ssl::Bio::Create(fd, type)) {
             Ssl::Bio::Link(ssl, bio); // cannot fail
 
-            fd_table[fd].ssl.reset(ssl);
+            fd_table[fd].ssl.resetWithoutLocking(ssl);
             fd_table[fd].read_method = &ssl_read_method;
             fd_table[fd].write_method = &ssl_write_method;
             fd_note(fd, squidCtx);
-            return ssl;
+            return true;
         }
         errCode = ERR_get_error();
         errAction = "failed to initialize I/O";
@@ -1429,19 +1430,19 @@ SslCreate(Security::ContextPtr sslContext, const int fd, Ssl::Bio::Type type, co
 
     debugs(83, DBG_IMPORTANT, "ERROR: " << squidCtx << ' ' << errAction <<
            ": " << ERR_error_string(errCode, NULL));
-    return NULL;
+    return false;
 }
 
-SSL *
-Ssl::CreateClient(Security::ContextPtr sslContext, const int fd, const char *squidCtx)
+bool
+Ssl::CreateClient(Security::ContextPtr sslContext, const Comm::ConnectionPointer &c, const char *squidCtx)
 {
-    return SslCreate(sslContext, fd, Ssl::Bio::BIO_TO_SERVER, squidCtx);
+    return SslCreate(sslContext, c, Ssl::Bio::BIO_TO_SERVER, squidCtx);
 }
 
-SSL *
-Ssl::CreateServer(Security::ContextPtr sslContext, const int fd, const char *squidCtx)
+bool
+Ssl::CreateServer(Security::ContextPtr sslContext, const Comm::ConnectionPointer &c, const char *squidCtx)
 {
-    return SslCreate(sslContext, fd, Ssl::Bio::BIO_TO_CLIENT, squidCtx);
+    return SslCreate(sslContext, c, Ssl::Bio::BIO_TO_CLIENT, squidCtx);
 }
 
 Ssl::CertError::CertError(ssl_error_t anErr, X509 *aCert, int aDepth): code(anErr), depth(aDepth)
@@ -14,6 +14,7 @@
 #if USE_OPENSSL
 
 #include "base/CbDataList.h"
+#include "comm/forward.h"
 #include "sbuf/SBuf.h"
 #include "security/forward.h"
 #include "ssl/gadgets.h"
@@ -78,12 +79,12 @@ class CertValidationResponse;
 typedef RefCount<CertValidationResponse> CertValidationResponsePointer;
 
 /// Creates SSL Client connection structure and initializes SSL I/O (Comm and BIO).
-/// On errors, emits DBG_IMPORTANT with details and returns NULL.
-SSL *CreateClient(Security::ContextPtr sslContext, const int fd, const char *squidCtx);
+/// On errors, emits DBG_IMPORTANT with details and returns false.
+bool CreateClient(Security::ContextPtr sslContext, const Comm::ConnectionPointer &, const char *squidCtx);
 
 /// Creates SSL Server connection structure and initializes SSL I/O (Comm and BIO).
-/// On errors, emits DBG_IMPORTANT with details and returns NULL.
-SSL *CreateServer(Security::ContextPtr sslContext, const int fd, const char *squidCtx);
+/// On errors, emits DBG_IMPORTANT with details and returns false.
+bool CreateServer(Security::ContextPtr sslContext, const Comm::ConnectionPointer &, const char *squidCtx);
 
 /// An SSL certificate-related error.
 /// Pairs an error code with the certificate experiencing the error.
@@ -139,12 +139,11 @@ StoreEntry::operator delete (void *address)
 }
 
 void
-StoreEntry::makePublic()
+StoreEntry::makePublic(const KeyScope scope)
 {
     /* This object can be cached for a long time */
-
     if (!EBIT_TEST(flags, RELEASE_REQUEST))
-        setPublicKey();
+        setPublicKey(scope);
 }
 
 void
@@ -559,19 +558,19 @@ storeGetPublic(const char *uri, const HttpRequestMethod& method)
 }
 
 StoreEntry *
-storeGetPublicByRequestMethod(HttpRequest * req, const HttpRequestMethod& method)
+storeGetPublicByRequestMethod(HttpRequest * req, const HttpRequestMethod& method, const KeyScope keyScope)
 {
-    return Store::Root().get(storeKeyPublicByRequestMethod(req, method));
+    return Store::Root().get(storeKeyPublicByRequestMethod(req, method, keyScope));
 }
 
 StoreEntry *
-storeGetPublicByRequest(HttpRequest * req)
+storeGetPublicByRequest(HttpRequest * req, const KeyScope keyScope)
 {
-    StoreEntry *e = storeGetPublicByRequestMethod(req, req->method);
+    StoreEntry *e = storeGetPublicByRequestMethod(req, req->method, keyScope);
 
     if (e == NULL && req->method == Http::METHOD_HEAD)
         /* We can generate a HEAD reply from a cached GET object */
-        e = storeGetPublicByRequestMethod(req, Http::METHOD_GET);
+        e = storeGetPublicByRequestMethod(req, Http::METHOD_GET, keyScope);
 
     return e;
 }
@@ -622,10 +621,8 @@ StoreEntry::setPrivateKey()
 }
 
 void
-StoreEntry::setPublicKey()
+StoreEntry::setPublicKey(const KeyScope scope)
 {
-    const cache_key *newkey;
-
     if (key && !EBIT_TEST(flags, KEY_PRIVATE))
         return;                 /* is already public */
 
@@ -649,80 +646,35 @@ StoreEntry::setPublicKey()
 
     assert(!EBIT_TEST(flags, RELEASE_REQUEST));
 
-    if (mem_obj->request) {
-        HttpRequest *request = mem_obj->request;
-
-        if (mem_obj->vary_headers.isEmpty()) {
-            /* First handle the case where the object no longer varies */
-            request->vary_headers.clear();
-        } else {
-            if (!request->vary_headers.isEmpty() && request->vary_headers.cmp(mem_obj->vary_headers) != 0) {
-                /* Oops.. the variance has changed. Kill the base object
-                 * to record the new variance key
-                 */
-                request->vary_headers.clear();       /* free old "bad" variance key */
-                if (StoreEntry *pe = storeGetPublic(mem_obj->storeId(), mem_obj->method))
-                    pe->release();
-            }
-
-            /* Make sure the request knows the variance status */
-            if (request->vary_headers.isEmpty())
-                request->vary_headers = httpMakeVaryMark(request, mem_obj->getReply());
-        }
-
-        // TODO: storeGetPublic() calls below may create unlocked entries.
-        // We should add/use storeHas() API or lock/unlock those entries.
-        if (!mem_obj->vary_headers.isEmpty() && !storeGetPublic(mem_obj->storeId(), mem_obj->method)) {
-            /* Create "vary" base object */
-            String vary;
-            StoreEntry *pe = storeCreateEntry(mem_obj->storeId(), mem_obj->logUri(), request->flags, request->method);
-            /* We are allowed to do this typecast */
-            HttpReply *rep = new HttpReply;
-            rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
-            vary = mem_obj->getReply()->header.getList(Http::HdrType::VARY);
-
-            if (vary.size()) {
-                /* Again, we own this structure layout */
-                rep->header.putStr(Http::HdrType::VARY, vary.termedBuf());
-                vary.clean();
-            }
-
-#if X_ACCELERATOR_VARY
-            vary = mem_obj->getReply()->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
-
-            if (vary.size() > 0) {
-                /* Again, we own this structure layout */
-                rep->header.putStr(Http::HdrType::HDR_X_ACCELERATOR_VARY, vary.termedBuf());
-                vary.clean();
-            }
-
-#endif
-            pe->replaceHttpReply(rep, false); // no write until key is public
-
-            pe->timestampsSet();
-
-            pe->makePublic();
+    adjustVary();
+    forcePublicKey(calcPublicKey(scope));
+}
 
-            pe->startWriting(); // after makePublic()
+void
+StoreEntry::clearPublicKeyScope()
+{
+    if (!key || EBIT_TEST(flags, KEY_PRIVATE))
+        return; // probably the old public key was deleted or made private
 
-            pe->complete();
+    // TODO: adjustVary() when collapsed revalidation supports that
 
-            pe->unlock("StoreEntry::setPublicKey+Vary");
-        }
+    const cache_key *newKey = calcPublicKey(ksDefault);
+    if (!storeKeyHashCmp(key, newKey))
+        return; // probably another collapsed revalidation beat us to this change
 
-        newkey = storeKeyPublicByRequest(mem_obj->request);
-    } else
-        newkey = storeKeyPublic(mem_obj->storeId(), mem_obj->method);
+    forcePublicKey(newKey);
+}
 
+/// Unconditionally sets public key for this store entry.
+/// Releases the old entry with the same public key (if any).
+void
+StoreEntry::forcePublicKey(const cache_key *newkey)
+{
     if (StoreEntry *e2 = (StoreEntry *)hash_lookup(store_table, newkey)) {
+        assert(e2 != this);
         debugs(20, 3, "Making old " << *e2 << " private.");
         e2->setPrivateKey();
         e2->release();
-
-        if (mem_obj->request)
-            newkey = storeKeyPublicByRequest(mem_obj->request);
-        else
-            newkey = storeKeyPublic(mem_obj->storeId(), mem_obj->method);
     }
 
     if (key)
@@ -736,6 +688,88 @@ StoreEntry::setPublicKey()
         storeDirSwapLog(this, SWAP_LOG_ADD);
 }
 
+/// Calculates correct public key for feeding forcePublicKey().
+/// Assumes adjustVary() has been called for this entry already.
+const cache_key *
+StoreEntry::calcPublicKey(const KeyScope keyScope)
+{
+    assert(mem_obj);
+    return mem_obj->request ?  storeKeyPublicByRequest(mem_obj->request, keyScope) :
+           storeKeyPublic(mem_obj->storeId(), mem_obj->method, keyScope);
+}
+
+/// Updates mem_obj->request->vary_headers to reflect the current Vary.
+/// The vary_headers field is used to calculate the Vary marker key.
+/// Releases the old Vary marker with an outdated key (if any).
+void
+StoreEntry::adjustVary()
+{
+    assert(mem_obj);
+
+    if (!mem_obj->request)
+        return;
+
+    HttpRequest *request = mem_obj->request;
+
+    if (mem_obj->vary_headers.isEmpty()) {
+        /* First handle the case where the object no longer varies */
+        request->vary_headers.clear();
+    } else {
+        if (!request->vary_headers.isEmpty() && request->vary_headers.cmp(mem_obj->vary_headers) != 0) {
+            /* Oops.. the variance has changed. Kill the base object
+             * to record the new variance key
+             */
+            request->vary_headers.clear();       /* free old "bad" variance key */
+            if (StoreEntry *pe = storeGetPublic(mem_obj->storeId(), mem_obj->method))
+                pe->release();
+        }
+
+        /* Make sure the request knows the variance status */
+        if (request->vary_headers.isEmpty())
+            request->vary_headers = httpMakeVaryMark(request, mem_obj->getReply());
+    }
+
+    // TODO: storeGetPublic() calls below may create unlocked entries.
+    // We should add/use storeHas() API or lock/unlock those entries.
+    if (!mem_obj->vary_headers.isEmpty() && !storeGetPublic(mem_obj->storeId(), mem_obj->method)) {
+        /* Create "vary" base object */
+        String vary;
+        StoreEntry *pe = storeCreateEntry(mem_obj->storeId(), mem_obj->logUri(), request->flags, request->method);
+        /* We are allowed to do this typecast */
+        HttpReply *rep = new HttpReply;
+        rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
+        vary = mem_obj->getReply()->header.getList(Http::HdrType::VARY);
+
+        if (vary.size()) {
+            /* Again, we own this structure layout */
+            rep->header.putStr(Http::HdrType::VARY, vary.termedBuf());
+            vary.clean();
+        }
+
+#if X_ACCELERATOR_VARY
+        vary = mem_obj->getReply()->header.getList(Http::HdrType::HDR_X_ACCELERATOR_VARY);
+
+        if (vary.size() > 0) {
+            /* Again, we own this structure layout */
+            rep->header.putStr(Http::HdrType::HDR_X_ACCELERATOR_VARY, vary.termedBuf());
+            vary.clean();
+        }
+
+#endif
+        pe->replaceHttpReply(rep, false); // no write until key is public
+
+        pe->timestampsSet();
+
+        pe->makePublic();
+
+        pe->startWriting(); // after makePublic()
+
+        pe->complete();
+
+        pe->unlock("StoreEntry::forcePublicKey+Vary");
+    }
+}
+
 StoreEntry *
 storeCreatePureEntry(const char *url, const char *log_url, const RequestFlags &flags, const HttpRequestMethod& method)
 {
@@ -1486,7 +1520,7 @@ StoreEntry::validToSend() const
     return 1;
 }
 
-void
+bool
 StoreEntry::timestampsSet()
 {
     const HttpReply *reply = getReply();
@@ -1524,14 +1558,22 @@ StoreEntry::timestampsSet()
             served_date -= (squid_curtime - request_sent);
     }
 
+    time_t exp = 0;
     if (reply->expires > 0 && reply->date > -1)
-        expires = served_date + (reply->expires - reply->date);
+        exp = served_date + (reply->expires - reply->date);
     else
-        expires = reply->expires;
+        exp = reply->expires;
+
+    if (lastmod == reply->last_modified && timestamp == served_date && expires == exp)
+        return false;
+
+    expires = exp;
 
     lastmod = reply->last_modified;
 
     timestamp = served_date;
+
+    return true;
 }
 
 void
@@ -64,7 +64,8 @@ Store::Controller::init()
 
     swapDir->init();
 
-    if (UsingSmp() && IamWorkerProcess() && Config.onoff.collapsed_forwarding) {
+    if (UsingSmp() && IamWorkerProcess() && Config.onoff.collapsed_forwarding &&
+            smpAware()) {
         transients = new Transients;
         transients->init();
     }
@@ -498,8 +499,10 @@ Store::Controller::updateOnNotModified(StoreEntry *old, const StoreEntry &newer)
     Must(old);
     HttpReply *oldReply = const_cast<HttpReply*>(old->getReply());
     Must(oldReply);
-    oldReply->updateOnNotModified(newer.getReply());
-    old->timestampsSet();
+
+    const bool modified = oldReply->updateOnNotModified(newer.getReply());
+    if (!old->timestampsSet() && !modified)
+        return;
 
     /* update stored image of the old entry */
 
@@ -514,7 +517,8 @@ void
 Store::Controller::allowCollapsing(StoreEntry *e, const RequestFlags &reqFlags,
                                    const HttpRequestMethod &reqMethod)
 {
-    e->makePublic(); // this is needed for both local and SMP collapsing
+    const KeyScope keyScope = reqFlags.refresh ? ksRevalidation : ksDefault;
+    e->makePublic(keyScope); // this is needed for both local and SMP collapsing
     if (transients)
         transients->startWriting(e, reqFlags, reqMethod);
     debugs(20, 3, "may " << (transients && e->mem_obj->xitTable.index >= 0 ?
@@ -601,6 +605,12 @@ Store::Controller::anchorCollapsed(StoreEntry &collapsed, bool &inSync)
     return found;
 }
 
+bool
+Store::Controller::smpAware() const
+{
+    return memStore || (swapDir && swapDir->smpAware());
+}
+
 namespace Store {
 static RefCount<Controller> TheRoot;
 }
@@ -41,6 +41,7 @@ class Controller: public Storage
     virtual void markForUnlink(StoreEntry &) override;
     virtual void unlink(StoreEntry &) override;
     virtual int callback() override;
+    virtual bool smpAware() const override;
 
     /// Additional unknown-size entry bytes required by Store in order to
     /// reduce the risk of selecting the wrong disk cache for the growing entry.
@@ -53,6 +53,7 @@ class Disk: public Controlled
     virtual void reference(StoreEntry &e) override;
     virtual bool dereference(StoreEntry &e) override;
     virtual void maintain() override;
+    virtual bool smpAware() const override { return false; }
 
     /// the size of the smallest entry this cache_dir can store
     int64_t minObjectSize() const;
@@ -530,6 +530,19 @@ Store::Disks::updateCollapsed(StoreEntry &collapsed)
            dir(collapsed.swap_dirn).updateCollapsed(collapsed);
 }
 
+bool
+Store::Disks::smpAware() const
+{
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
+        // A mix is not supported, but we conservatively check every
+        // dir because features like collapsed revalidation should
+        // currently be disabled if any dir is SMP-aware
+        if (dir(i).smpAware())
+            return true;
+    }
+    return false;
+}
+
 /* Store::Disks globals that should be converted to use RegisteredRunner */
 
 void
@@ -48,6 +48,7 @@ class Disks: public Controlled
     /// Additional unknown-size entry bytes required by disks in order to
     /// reduce the risk of selecting the wrong disk cache for the growing entry.
     int64_t accumulateMore(const StoreEntry&) const;
+    virtual bool smpAware() const override;
 
 private:
     /* migration logic */
@@ -74,6 +74,11 @@ class Storage: public RefCountable
 
     /// prepare for shutdown
     virtual void sync() {}
+
+    /// whether this storage is capable of serving multiple workers;
+    /// a true result does not imply [lack of] non-SMP support because
+    /// [only] some SMP-aware storages also support non-SMP configss
+    virtual bool smpAware() const = 0;
 };
 
 } // namespace Store
@@ -77,36 +77,63 @@ static void storeDigestRewriteResume(void);
 static void storeDigestRewriteFinish(StoreEntry * e);
 static EVH storeDigestSwapOutStep;
 static void storeDigestCBlockSwapOut(StoreEntry * e);
-static int storeDigestCalcCap(void);
-static int storeDigestResize(void);
 static void storeDigestAdd(const StoreEntry *);
 
-#endif /* USE_CACHE_DIGESTS */
-
-static void
-storeDigestRegisterWithCacheManager(void)
+/// calculates digest capacity
+static uint64_t
+storeDigestCalcCap()
 {
-    Mgr::RegisterAction("store_digest", "Store Digest", storeDigestReport, 0, 1);
-}
+    /*
+     * To-Do: Bloom proved that the optimal filter utilization is 50% (half of
+     * the bits are off). However, we do not have a formula to calculate the
+     * number of _entries_ we want to pre-allocate for.
+     */
+    const uint64_t hi_cap = Store::Root().maxSize() / Config.Store.avgObjectSize;
+    const uint64_t lo_cap = 1 + Store::Root().currentSize() / Config.Store.avgObjectSize;
+    const uint64_t e_count = StoreEntry::inUseCount();
+    uint64_t cap = e_count ? e_count : hi_cap;
+    debugs(71, 2, "have: " << e_count << ", want " << cap <<
+           " entries; limits: [" << lo_cap << ", " << hi_cap << "]");
 
-/*
- * PUBLIC FUNCTIONS
- */
+    if (cap < lo_cap)
+        cap = lo_cap;
+
+    /* do not enforce hi_cap limit, average-based estimation may be wrong
+     *if (cap > hi_cap)
+     *  cap = hi_cap;
+     */
+
+    // Bug 4534: we still have to set an upper-limit at some reasonable value though.
+    // this matches cacheDigestCalcMaskSize doing (cap*bpe)+7 < INT_MAX
+    const uint64_t absolute_max = (INT_MAX -8) / Config.digest.bits_per_entry;
+    if (cap > absolute_max) {
+        static time_t last_loud = 0;
+        if (last_loud < squid_curtime - 86400) {
+            debugs(71, DBG_IMPORTANT, "WARNING: Cache Digest cannot store " << cap << " entries. Limiting to " << absolute_max);
+            last_loud = squid_curtime;
+        } else {
+            debugs(71, 3, "WARNING: Cache Digest cannot store " << cap << " entries. Limiting to " << absolute_max);
+        }
+        cap = absolute_max;
+    }
+
+    return cap;
+}
+#endif /* USE_CACHE_DIGESTS */
 
 void
 storeDigestInit(void)
 {
-    storeDigestRegisterWithCacheManager();
+    Mgr::RegisterAction("store_digest", "Store Digest", storeDigestReport, 0, 1);
 
 #if USE_CACHE_DIGESTS
-    const int cap = storeDigestCalcCap();
-
     if (!Config.onoff.digest_generation) {
         store_digest = NULL;
         debugs(71, 3, "Local cache digest generation disabled");
         return;
     }
 
+    const uint64_t cap = storeDigestCalcCap();
     store_digest = new CacheDigest(cap, Config.digest.bits_per_entry);
     debugs(71, DBG_IMPORTANT, "Local cache digest enabled; rebuild/rewrite every " <<
            (int) Config.digest.rebuild_period << "/" <<
@@ -291,6 +318,31 @@ storeDigestRebuildStart(void *datanotused)
     storeDigestRebuildResume();
 }
 
+/// \returns true if we actually resized the digest
+static bool
+storeDigestResize()
+{
+    const uint64_t cap = storeDigestCalcCap();
+    assert(store_digest);
+    uint64_t diff;
+    if (cap > store_digest->capacity)
+        diff = cap - store_digest->capacity;
+    else
+        diff = store_digest->capacity - cap;
+    debugs(71, 2, store_digest->capacity << " -> " << cap << "; change: " <<
+           diff << " (" << xpercentInt(diff, store_digest->capacity) << "%)" );
+    /* avoid minor adjustments */
+
+    if (diff <= store_digest->capacity / 10) {
+        debugs(71, 2, "small change, will not resize.");
+        return false;
+    } else {
+        debugs(71, 2, "big change, resizing.");
+        store_digest->updateCapacity(cap);
+    }
+    return true;
+}
+
 /* called be Rewrite to push Rebuild forward */
 static void
 storeDigestRebuildResume(void)
@@ -440,7 +492,7 @@ storeDigestSwapOutStep(void *data)
     assert(e);
     /* _add_ check that nothing bad happened while we were waiting @?@ @?@ */
 
-    if (sd_state.rewrite_offset + chunk_size > store_digest->mask_size)
+    if (static_cast<uint32_t>(sd_state.rewrite_offset + chunk_size) > store_digest->mask_size)
         chunk_size = store_digest->mask_size - sd_state.rewrite_offset;
 
     e->append(store_digest->mask + sd_state.rewrite_offset, chunk_size);
@@ -452,7 +504,7 @@ storeDigestSwapOutStep(void *data)
     sd_state.rewrite_offset += chunk_size;
 
     /* are we done ? */
-    if (sd_state.rewrite_offset >= store_digest->mask_size)
+    if (static_cast<uint32_t>(sd_state.rewrite_offset) >= store_digest->mask_size)
         storeDigestRewriteFinish(e);
     else
         eventAdd("storeDigestSwapOutStep", storeDigestSwapOutStep, data, 0.0, 1, false);
@@ -468,60 +520,10 @@ storeDigestCBlockSwapOut(StoreEntry * e)
     sd_state.cblock.count = htonl(store_digest->count);
     sd_state.cblock.del_count = htonl(store_digest->del_count);
     sd_state.cblock.mask_size = htonl(store_digest->mask_size);
-    sd_state.cblock.bits_per_entry = (unsigned char)
-                                     Config.digest.bits_per_entry;
+    sd_state.cblock.bits_per_entry = Config.digest.bits_per_entry;
     sd_state.cblock.hash_func_count = (unsigned char) CacheDigestHashFuncCount;
     e->append((char *) &sd_state.cblock, sizeof(sd_state.cblock));
 }
 
-/* calculates digest capacity */
-static int
-storeDigestCalcCap(void)
-{
-    /*
-     * To-Do: Bloom proved that the optimal filter utilization is 50% (half of
-     * the bits are off). However, we do not have a formula to calculate the
-     * number of _entries_ we want to pre-allocate for.
-     */
-    const int hi_cap = Store::Root().maxSize() / Config.Store.avgObjectSize;
-    const int lo_cap = 1 + Store::Root().currentSize() / Config.Store.avgObjectSize;
-    const int e_count = StoreEntry::inUseCount();
-    int cap = e_count ? e_count :hi_cap;
-    debugs(71, 2, "storeDigestCalcCap: have: " << e_count << ", want " << cap <<
-           " entries; limits: [" << lo_cap << ", " << hi_cap << "]");
-
-    if (cap < lo_cap)
-        cap = lo_cap;
-
-    /* do not enforce hi_cap limit, average-based estimation may be wrong
-     *if (cap > hi_cap)
-     *  cap = hi_cap;
-     */
-    return cap;
-}
-
-/* returns true if we actually resized the digest */
-static int
-storeDigestResize(void)
-{
-    const int cap = storeDigestCalcCap();
-    int diff;
-    assert(store_digest);
-    diff = abs(cap - store_digest->capacity);
-    debugs(71, 2, "storeDigestResize: " <<
-           store_digest->capacity << " -> " << cap << "; change: " <<
-           diff << " (" << xpercentInt(diff, store_digest->capacity) << "%)" );
-    /* avoid minor adjustments */
-
-    if (diff <= store_digest->capacity / 10) {
-        debugs(71, 2, "storeDigestResize: small change, will not resize.");
-        return 0;
-    } else {
-        debugs(71, 2, "storeDigestResize: big change, resizing.");
-        store_digest->updateCapacity(cap);
-        return 1;
-    }
-}
-
 #endif /* USE_CACHE_DIGESTS */
 
@@ -95,26 +95,28 @@ storeKeyPrivate()
 }
 
 const cache_key *
-storeKeyPublic(const char *url, const HttpRequestMethod& method)
+storeKeyPublic(const char *url, const HttpRequestMethod& method, const KeyScope keyScope)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     unsigned char m = (unsigned char) method.id();
     SquidMD5_CTX M;
     SquidMD5Init(&M);
     SquidMD5Update(&M, &m, sizeof(m));
     SquidMD5Update(&M, (unsigned char *) url, strlen(url));
+    if (keyScope)
+        SquidMD5Update(&M, &keyScope, sizeof(keyScope));
     SquidMD5Final(digest, &M);
     return digest;
 }
 
 const cache_key *
-storeKeyPublicByRequest(HttpRequest * request)
+storeKeyPublicByRequest(HttpRequest * request, const KeyScope keyScope)
 {
-    return storeKeyPublicByRequestMethod(request, request->method);
+    return storeKeyPublicByRequestMethod(request, request->method, keyScope);
 }
 
 const cache_key *
-storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method)
+storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method, const KeyScope keyScope)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     unsigned char m = (unsigned char) method.id();
@@ -123,6 +125,8 @@ storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& me
     SquidMD5Init(&M);
     SquidMD5Update(&M, &m, sizeof(m));
     SquidMD5Update(&M, (unsigned char *) url.rawContent(), url.length());
+    if (keyScope)
+        SquidMD5Update(&M, &keyScope, sizeof(keyScope));
 
     if (!request->vary_headers.isEmpty()) {
         SquidMD5Update(&M, request->vary_headers.rawContent(), request->vary_headers.length());
@@ -17,14 +17,19 @@
 class HttpRequestMethod;
 class HttpRequest;
 
+typedef enum {
+    ksDefault = 0,
+    ksRevalidation
+} KeyScope;
+
 cache_key *storeKeyDup(const cache_key *);
 cache_key *storeKeyCopy(cache_key *, const cache_key *);
 void storeKeyFree(const cache_key *);
 const cache_key *storeKeyScan(const char *);
 const char *storeKeyText(const cache_key *);
-const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&);
-const cache_key *storeKeyPublicByRequest(HttpRequest *);
-const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&);
+const cache_key *storeKeyPublic(const char *, const HttpRequestMethod&, const KeyScope keyScope = ksDefault);
+const cache_key *storeKeyPublicByRequest(HttpRequest *, const KeyScope keyScope = ksDefault);
+const cache_key *storeKeyPublicByRequestMethod(HttpRequest *, const HttpRequestMethod&, const KeyScope keyScope = ksDefault);
 const cache_key *storeKeyPrivate();
 int storeKeyHashBuckets(int);
 int storeKeyNull(const cache_key *);
@@ -48,6 +48,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
+	tests/stub_liblog.cc \
 	tests/stub_libmem.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_libsecurity.cc \
@@ -17,17 +17,17 @@ class CacheDigestGuessStats;
 class StoreEntry;
 
 #include "CacheDigest.h"
-CacheDigest::CacheDigest(int, int) {STUB}
+CacheDigest::CacheDigest(uint64_t, uint8_t) {STUB}
 CacheDigest::~CacheDigest() {STUB}
 CacheDigest *CacheDigest::clone() const STUB_RETVAL(nullptr)
 void CacheDigest::clear() STUB
-void CacheDigest::updateCapacity(int) STUB
+void CacheDigest::updateCapacity(uint64_t) STUB
 bool CacheDigest::contains(const cache_key *) const STUB_RETVAL(false)
 void CacheDigest::add(const cache_key *) STUB
 void CacheDigest::remove(const cache_key *) STUB
 double CacheDigest::usedMaskPercent() const STUB_RETVAL(0.0)
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats *, int, int) STUB
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats *, StoreEntry *, const char *) STUB
 void cacheDigestReport(CacheDigest *, const char *, StoreEntry *) STUB
-size_t CacheDigest::CalcMaskSize(int, int) STUB_RETVAL(1)
+uint32_t CacheDigest::CalcMaskSize(uint64_t, uint8_t) STUB_RETVAL(1)
 
@@ -28,6 +28,6 @@ HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
     void HttpReply::hdrCacheInit() STUB
     HttpReply * HttpReply::clone() const STUB_RETVAL(NULL)
     bool HttpReply::inheritProperties(const HttpMsg *aMsg) STUB_RETVAL(false)
-    void HttpReply::updateOnNotModified(HttpReply const*) STUB
+    bool HttpReply::updateOnNotModified(HttpReply const*) STUB_RETVAL(false)
     int64_t HttpReply::bodySize(const HttpRequestMethod&) const STUB_RETVAL(0)
 
@@ -22,7 +22,7 @@ void MemBuf::init(mb_size_t szInit, mb_size_t szMax) STUB
 void MemBuf::init() STUB
 void MemBuf::clean() STUB
 void MemBuf::reset() STUB
-int MemBuf::isNull() STUB_RETVAL(1)
+int MemBuf::isNull() const STUB_RETVAL(1)
 FREE *MemBuf::freeFunc() STUB_RETVAL(NULL)
 void MemBuf::append(const char *, int) STUB
 void MemBuf::vappendf(const char *fmt, va_list ap) STUB
@@ -9,7 +9,6 @@
 #include "squid.h"
 #include "comm/Connection.h"
 #include "ICP.h"
-#include "icp_opcode.h"
 
 #define STUB_API "icp_*.cc"
 #include "tests/STUB.h"
@@ -43,3 +42,7 @@ void icpConnectionClose(void) STUB
 int icpSetCacheKey(const cache_key * key) STUB_RETVAL(0)
 const cache_key *icpGetCacheKey(const char *url, int reqnum) STUB_RETVAL(NULL)
 
+#include "icp_opcode.h"
+// dynamically generated
+#include "icp_opcode.cc"
+
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "fde.h"
+
+#define STUB_API "log/liblog.la"
+#include "tests/STUB.h"
+
+// XXX: these should be moved to a log/ *.h file
+#include "AccessLogEntry.h"
+/*
+AccessLogEntry::~AccessLogEntry() {STUB}
+void AccessLogEntry::getLogClientIp(char *, size_t) const STUB
+SBuf AccessLogEntry::getLogMethod() const STUB_RETVAL(SBuf())
+#if USE_OPENSSL
+AccessLogEntry::SslDetails::SslDetails() {STUB}
+#endif
+*/
+void accessLogLogTo(CustomLog *, AccessLogEntry::Pointer &, ACLChecklist *) STUB
+void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist *) STUB
+void accessLogRotate(void) STUB
+void accessLogClose(void) STUB
+void accessLogInit(void) STUB
+const char *accessLogTime(time_t) STUB_RETVAL(nullptr)
+
+#include "log/access_log.h"
+void fvdbCountVia(const char *) STUB
+void fvdbCountForw(const char *) STUB
+#if HEADERS_LOG
+void headersLog(int, int, const HttpRequestMethod &, void *) STUB
+#endif
+
+#include "log/Config.h"
+namespace Log
+{
+void LogConfig::parseFormats() STUB
+LogConfig TheConfig;
+}
+
+//#include "log/CustomLog.h"
+#include "log/File.h"
+CBDATA_CLASS_INIT(Logfile);
+Logfile::Logfile(const char *) {STUB}
+//void Logfile::f_linestart(Logfile *) STUB
+//void Logfile::f_linewrite(Logfile *, const char *, size_t) STUB
+//void Logfile::f_lineend(Logfile *) STUB
+//void Logfile::f_flush(Logfile *) STUB
+//void Logfile::f_rotate(Logfile *, const int16_t) STUB
+//void Logfile::f_close(Logfile *) STUB
+Logfile *logfileOpen(const char *, size_t, int) STUB_RETVAL(nullptr)
+void logfileClose(Logfile *) STUB
+void logfileRotate(Logfile *, int16_t) STUB
+void logfileWrite(Logfile *, char *, size_t) STUB
+void logfileFlush(Logfile *) STUB
+void logfilePrintf(Logfile *, const char *, ...) STUB
+void logfileLineStart(Logfile *) STUB
+void logfileLineEnd(Logfile *) STUB
+
+#include "log/Formats.h"
+namespace Log
+{
+namespace Format
+{
+void SquidNative(const AccessLogEntryPointer &, Logfile *) STUB
+void SquidIcap(const AccessLogEntryPointer &, Logfile *) STUB
+void SquidUserAgent(const AccessLogEntryPointer &, Logfile *) STUB
+void SquidReferer(const AccessLogEntryPointer &, Logfile *) STUB
+void SquidCustom(const AccessLogEntryPointer &, CustomLog *) STUB
+void HttpdCommon(const AccessLogEntryPointer &, Logfile *) STUB
+void HttpdCombined(const AccessLogEntryPointer &, Logfile *) STUB
+}
+}
+
+#include "log/ModDaemon.h"
+int logfile_mod_daemon_open(Logfile *, const char *, size_t, int) STUB_RETVAL(0)
+
+#include "log/ModStdio.h"
+int logfile_mod_stdio_open(Logfile *, const char *, size_t, int) STUB_RETVAL(0)
+
+#include "log/ModSyslog.h"
+int logfile_mod_syslog_open(Logfile *, const char *, size_t, int) STUB_RETVAL(0)
+
+#include "log/ModUdp.h"
+int logfile_mod_udp_open(Logfile *, const char *, size_t, int) STUB_RETVAL(0)
+
+#include "log/TcpLogger.h"
+namespace Log
+{
+CBDATA_CLASS_INIT(TcpLogger);
+int TcpLogger::Open(Logfile *, const char *, size_t, int) STUB_RETVAL(0)
+
+/*
+protected:
+    TcpLogger(size_t, bool, Ip::Address);
+    virtual ~TcpLogger();
+    void endGracefully();
+    void logRecord(const char *buf, size_t len);
+    void flush();
+    virtual void start() STUB
+    virtual bool doneAll() const STUB_RETVAL(true)
+    virtual void swanSong() STUB
+*/
+}
+
@@ -7,15 +7,64 @@
  */
 
 #include "squid.h"
+#include "AccessLogEntry.h"
 #include "comm/Connection.h"
+#include "HttpRequest.h"
 
 #define STUB_API "security/libsecurity.la"
 #include "tests/STUB.h"
 
+#include "security/BlindPeerConnector.h"
+CBDATA_NAMESPACED_CLASS_INIT(Security, BlindPeerConnector);
+namespace Security
+{
+bool BlindPeerConnector::initializeTls(Security::SessionPointer &) STUB_RETVAL(false)
+Security::ContextPtr BlindPeerConnector::getSslContext() STUB_RETVAL(nullptr)
+void BlindPeerConnector::noteNegotiationDone(ErrorState *) STUB
+}
 #include "security/EncryptorAnswer.h"
 Security::EncryptorAnswer::~EncryptorAnswer() {}
 std::ostream &Security::operator <<(std::ostream &os, const Security::EncryptorAnswer &) STUB_RETVAL(os)
 
+#include "security/Handshake.h"
+Security::HandshakeParser::HandshakeParser() STUB
+bool Security::HandshakeParser::parseHello(const SBuf &) STUB_RETVAL(false)
+
+#include "security/NegotiationHistory.h"
+Security::NegotiationHistory::NegotiationHistory() STUB
+void Security::NegotiationHistory::retrieveNegotiatedInfo(Security::SessionPtr) STUB
+void Security::NegotiationHistory::retrieveParsedInfo(Security::TlsDetails::Pointer const &) STUB
+const char *Security::NegotiationHistory::cipherName() const STUB
+const char *Security::NegotiationHistory::printTlsVersion(AnyP::ProtocolVersion const &v) const STUB
+
+#include "security/PeerConnector.h"
+CBDATA_NAMESPACED_CLASS_INIT(Security, PeerConnector);
+namespace Security
+{
+PeerConnector::PeerConnector(const Comm::ConnectionPointer &, AsyncCall::Pointer &, const AccessLogEntryPointer &, const time_t) :
+    AsyncJob("Security::PeerConnector") {STUB}
+PeerConnector::~PeerConnector() {STUB}
+void PeerConnector::start() STUB
+bool PeerConnector::doneAll() const STUB_RETVAL(true)
+void PeerConnector::swanSong() STUB
+const char *PeerConnector::status() const STUB_RETVAL("")
+void PeerConnector::commCloseHandler(const CommCloseCbParams &) STUB
+void PeerConnector::connectionClosed(const char *) STUB
+bool PeerConnector::prepareSocket() STUB_RETVAL(false)
+void PeerConnector::setReadTimeout() STUB
+bool PeerConnector::initializeTls(Security::SessionPointer &) STUB_RETVAL(false)
+void PeerConnector::negotiateSsl() STUB
+bool PeerConnector::sslFinalized() STUB_RETVAL(false)
+void PeerConnector::handleNegotiateError(const int) STUB
+void PeerConnector::noteWantRead() STUB
+void PeerConnector::noteWantWrite() STUB
+void PeerConnector::noteSslNegotiationError(const int, const int, const int) STUB
+//    virtual Security::ContextPtr getSslContext() = 0;
+void PeerConnector::bail(ErrorState *) STUB
+void PeerConnector::callBack() STUB
+void PeerConnector::recordNegotiationDetails() STUB
+}
+
 #include "security/PeerOptions.h"
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
@@ -37,21 +86,3 @@ Security::ContextPtr Security::ServerOptions::createBlankContext() const STUB
 bool Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &) STUB_RETVAL(false)
 void Security::ServerOptions::updateContextEecdh(Security::ContextPtr &) STUB
 
-#include "security/NegotiationHistory.h"
-Security::NegotiationHistory::NegotiationHistory() STUB
-void Security::NegotiationHistory::retrieveNegotiatedInfo(Security::SessionPtr) STUB
-void Security::NegotiationHistory::retrieveParsedInfo(Security::TlsDetails::Pointer const &) STUB
-const char *Security::NegotiationHistory::cipherName() const STUB
-const char *Security::NegotiationHistory::printTlsVersion(AnyP::ProtocolVersion const &v) const STUB
-
-#include "security/Handshake.h"
-Security::HandshakeParser::HandshakeParser() STUB
-bool Security::HandshakeParser::parseHello(const SBuf &) STUB_RETVAL(false)
-
-#include "security/Session.h"
-namespace Security {
-bool SessionIsResumed(const Security::SessionPointer &) STUB_RETVAL(false)
-void GetSessionResumeData(const Security::SessionPointer &, Security::SessionStatePointer &) STUB
-void SetSessionResumeData(const Security::SessionPtr &, const Security::SessionStatePointer &) STUB
-} // namespace Security
-
@@ -37,9 +37,9 @@ void StoreEntry::replaceHttpReply(HttpReply *, bool andStartWriting) STUB
 bool StoreEntry::mayStartSwapOut() STUB_RETVAL(false)
 void StoreEntry::trimMemory(const bool preserveSwappable) STUB
 void StoreEntry::abort() STUB
-void StoreEntry::makePublic() STUB
+void StoreEntry::makePublic(const KeyScope scope) STUB
 void StoreEntry::makePrivate() STUB
-void StoreEntry::setPublicKey() STUB
+void StoreEntry::setPublicKey(const KeyScope scope) STUB
 void StoreEntry::setPrivateKey() STUB
 void StoreEntry::expireNow() STUB
 void StoreEntry::releaseRequest() STUB
@@ -62,7 +62,7 @@ void StoreEntry::hashInsert(const cache_key *) STUB
 void StoreEntry::registerAbort(STABH * cb, void *) STUB
 void StoreEntry::reset() STUB
 void StoreEntry::setMemStatus(mem_status_t) STUB
-void StoreEntry::timestampsSet() STUB
+bool StoreEntry::timestampsSet() STUB_RETVAL(false)
 void StoreEntry::unregisterAbort() STUB
 void StoreEntry::destroyMemObject() STUB
 int StoreEntry::checkTooSmall() STUB_RETVAL(0)
@@ -121,8 +121,8 @@ std::ostream &operator <<(std::ostream &os, const StoreEntry &)
 size_t storeEntryInUse() STUB_RETVAL(0)
 void storeEntryReplaceObject(StoreEntry *, HttpReply *) STUB
 StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method) STUB_RETVAL(NULL)
-StoreEntry *storeGetPublicByRequest(HttpRequest * request) STUB_RETVAL(NULL)
-StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method) STUB_RETVAL(NULL)
+StoreEntry *storeGetPublicByRequest(HttpRequest * request, const KeyScope scope) STUB_RETVAL(NULL)
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method, const KeyScope scope) STUB_RETVAL(NULL)
 StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&) STUB_RETVAL(NULL)
 StoreEntry *storeCreatePureEntry(const char *storeId, const char *logUrl, const RequestFlags &, const HttpRequestMethod&) STUB_RETVAL(NULL)
 void storeConfigure(void) STUB
@@ -34,9 +34,9 @@
 #include "MemBuf.h"
 #include "PeerSelectState.h"
 #include "sbuf/SBuf.h"
+#include "security/BlindPeerConnector.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
-#include "ssl/BlindPeerConnector.h"
 #include "StatCounters.h"
 #if USE_OPENSSL
 #include "ssl/bio.h"
@@ -174,9 +174,8 @@ class TunnelStateData
     void connectToPeer();
 
 private:
-#if USE_OPENSSL
     /// Gives PeerConnector access to Answer in the TunnelStateData callback dialer.
-    class MyAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+    class MyAnswerDialer: public CallDialer, public Security::PeerConnector::CbDialer
     {
     public:
         typedef void (TunnelStateData::*Method)(Security::EncryptorAnswer &);
@@ -191,15 +190,14 @@ class TunnelStateData
             os << '(' << tunnel_.get() << ", " << answer_ << ')';
         }
 
-        /* Ssl::PeerConnector::CbDialer API */
+        /* Security::PeerConnector::CbDialer API */
         virtual Security::EncryptorAnswer &answer() { return answer_; }
 
     private:
         Method method_;
         CbcPointer<TunnelStateData> tunnel_;
         Security::EncryptorAnswer answer_;
     };
-#endif
 
     /// callback handler after connection setup (including any encryption)
     void connectedToPeer(Security::EncryptorAnswer &answer);
@@ -1109,19 +1107,16 @@ tunnelStart(ClientHttpRequest * http)
 void
 TunnelStateData::connectToPeer()
 {
-#if USE_OPENSSL
     if (CachePeer *p = server.conn->getPeer()) {
         if (p->secure.encryptTransport) {
             AsyncCall::Pointer callback = asyncCall(5,4,
                                                     "TunnelStateData::ConnectedToPeer",
                                                     MyAnswerDialer(&TunnelStateData::connectedToPeer, this));
-            Ssl::BlindPeerConnector *connector =
-                new Ssl::BlindPeerConnector(request, server.conn, callback, al);
+            auto *connector = new Security::BlindPeerConnector(request, server.conn, callback, al);
             AsyncJob::Start(connector); // will call our callback
             return;
         }
     }
-#endif
 
     Security::EncryptorAnswer nil;
     connectedToPeer(nil);
@@ -1243,14 +1238,13 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
 {
     debugs(26,5, "Revert to tunnel FD " << clientConn->fd << " with FD " << srvConn->fd);
     /* Create state structure. */
-    TunnelStateData *tunnelState = NULL;
     const SBuf url(request->effectiveRequestUri());
 
     debugs(26, 3, request->method << " " << url << " " << request->http_ver);
     ++statCounter.server.all.requests;
     ++statCounter.server.other.requests;
 
-    tunnelState = new TunnelStateData;
+    TunnelStateData *tunnelState = new TunnelStateData;
     tunnelState->url = SBufToCstring(url);
     tunnelState->request = request;
     tunnelState->server.size_ptr = NULL; //Set later if Http::Stream is available
@@ -1260,10 +1254,9 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     tunnelState->status_ptr = &status_code;
     tunnelState->client.conn = clientConn;
 
-    ConnStateData *conn;
-    if ((conn = request->clientConnectionManager.get())) {
+    if (auto conn = request->clientConnectionManager.get()) {
         Http::StreamPointer context = conn->pipeline.front();
-        if (context != nullptr && context->http != nullptr) {
+        if (context && context->http) {
             tunnelState->logTag_ptr = &context->http->logType;
             tunnelState->server.size_ptr = &context->http->out.size;
             tunnelState->al = context->http->al;
@@ -1286,23 +1279,23 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     fd_table[clientConn->fd].read_method = &default_read_method;
     fd_table[clientConn->fd].write_method = &default_write_method;
 
-    tunnelState->request->hier.note(srvConn, tunnelState->getHost());
+    request->hier.note(srvConn, tunnelState->getHost());
 
     tunnelState->server.conn = srvConn;
-    tunnelState->request->peer_host = srvConn->getPeer() ? srvConn->getPeer()->host : NULL;
+    request->peer_host = srvConn->getPeer() ? srvConn->getPeer()->host : nullptr;
     comm_add_close_handler(srvConn->fd, tunnelServerClosed, tunnelState);
 
     debugs(26, 4, "determine post-connect handling pathway.");
     if (srvConn->getPeer()) {
-        tunnelState->request->peer_login = srvConn->getPeer()->login;
-        tunnelState->request->peer_domain = srvConn->getPeer()->domain;
-        tunnelState->request->flags.auth_no_keytab = srvConn->getPeer()->options.auth_no_keytab;
-        tunnelState->request->flags.proxying = !(srvConn->getPeer()->options.originserver);
+        request->peer_login = srvConn->getPeer()->login;
+        request->peer_domain = srvConn->getPeer()->domain;
+        request->flags.auth_no_keytab = srvConn->getPeer()->options.auth_no_keytab;
+        request->flags.proxying = !(srvConn->getPeer()->options.originserver);
     } else {
-        tunnelState->request->peer_login = NULL;
-        tunnelState->request->peer_domain = NULL;
-        tunnelState->request->flags.auth_no_keytab = false;
-        tunnelState->request->flags.proxying = false;
+        request->peer_login = nullptr;
+        request->peer_domain = nullptr;
+        request->flags.auth_no_keytab = false;
+        request->flags.proxying = false;
     }
 
     timeoutCall = commCbCall(5, 4, "tunnelTimeout",