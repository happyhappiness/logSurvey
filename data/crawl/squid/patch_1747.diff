@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.114 1998/01/07 21:16:29 wessels Exp $
+#  $Id: Makefile.in,v 1.115 1998/01/12 04:29:54 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -95,6 +95,7 @@ OBJS	 	= \
 		ident.o \
 		ipcache.o \
 		main.o \
+		mem.o \
 		mime.o \
 		multicast.o \
 		neighbors.o \
@@ -109,7 +110,6 @@ OBJS	 	= \
 		send-announce.o \
 		@SNMP_OBJS@ \
 		ssl.o \
-		stack.o \
 		stat.o \
 		stmem.o \
 		store.o \
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.129 1998/01/08 23:41:25 kostas Exp $
+ * $Id: acl.cc,v 1.130 1998/01/12 04:29:54 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -889,7 +889,7 @@ aclParseAccessLine(struct _acl_access **head)
     for (B = *head, T = head; B; T = &B->next, B = B->next);
     *T = A;
     /* We lock _acl_access structures in aclCheck() */
-    cbdataAdd(A);
+    cbdataAdd(A, MEM_NONE);
 }
 
 /**************/
@@ -1485,7 +1485,7 @@ aclChecklistCreate(const struct _acl_access *A,
 {
     int i;
     aclCheck_t *checklist = xcalloc(1, sizeof(aclCheck_t));;
-    cbdataAdd(checklist);
+    cbdataAdd(checklist, MEM_NONE);
     checklist->access_list = A;
     /*
      * aclCheck() makes sure checklist->access_list is a valid
@@ -1,5 +1,5 @@
 /*
- * $Id: asn.cc,v 1.12 1998/01/08 23:41:23 kostas Exp $
+ * $Id: asn.cc,v 1.13 1998/01/12 04:29:55 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -180,7 +180,7 @@ asnCacheStart(int as)
     const cache_key *k;
     StoreEntry *e;
     ASState *asState = xcalloc(1, sizeof(ASState));
-    cbdataAdd(asState);
+    cbdataAdd(asState, MEM_NONE);
     debug(53, 3) ("asnCacheStart: AS %d\n", as);
     snprintf(asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
     k = storeKeyPublic(asres, METHOD_GET);
@@ -195,7 +195,7 @@ asnCacheStart(int as)
 	storeClientListAdd(e, asState);
     }
     asState->entry = e;
-    storeClientCopy(e, 0, 0, 4096, get_free_4k_page(), asHandleReply, asState);
+    storeClientCopy(e, 0, 0, 4096, memAllocate(MEM_4K_BUF, 1), asHandleReply, asState);
 }
 
 static void
@@ -208,14 +208,14 @@ asHandleReply(void *data, char *buf, ssize_t size)
     char *t;
     debug(50, 3) ("asHandleReply: Called with size=%d.\n", size);
     if (e->store_status == STORE_ABORTED) {
-	put_free_4k_page(buf);
+	memFree(MEM_4K_BUF, buf);
 	return;
     }
     if (size == 0) {
-	put_free_4k_page(buf);
+	memFree(MEM_4K_BUF, buf);
 	return;
     } else if (size < 0) {
-	put_free_4k_page(buf);
+	memFree(MEM_4K_BUF, buf);
 	return;
     }
     if (e->store_status == STORE_PENDING) {
@@ -363,7 +363,7 @@ whoisStart(request_t * request, StoreEntry * entry)
     whoisState *p = xcalloc(1, sizeof(whoisState));
     p->request = request;
     p->entry = entry;
-    cbdataAdd(p);
+    cbdataAdd(p, MEM_NONE);
     storeLockObject(p->entry);
 
     fd = comm_open(SOCK_STREAM, 0, any_addr, 0, COMM_NONBLOCKING, "whois");
@@ -396,7 +396,7 @@ whoisReadReply(int fd, void *data)
 {
     whoisState *p = data;
     StoreEntry *entry = p->entry;
-    char *buf = get_free_4k_page();
+    char *buf = memAllocate(MEM_4K_BUF, 1);
     int len;
 
     len = read(fd, buf, 4096);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.241 1998/01/05 00:45:43 wessels Exp $
+ * $Id: cache_cf.cc,v 1.242 1998/01/12 04:29:56 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -645,7 +645,7 @@ parse_peer(peer ** head)
 	p->weight = 1;
     p->icp_version = ICP_VERSION_CURRENT;
     p->tcp_up = 1;
-    cbdataAdd(p);
+    cbdataAdd(p, MEM_NONE);
     while (*head != NULL)
 	head = &(*head)->next;
     *head = p;
@@ -1,7 +1,6 @@
 
-
 /*
- * $Id: cbdata.cc,v 1.12 1998/01/02 23:41:02 wessels Exp $
+ * $Id: cbdata.cc,v 1.13 1998/01/12 04:29:56 wessels Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * AUTHOR: Duane Wessels
@@ -72,6 +71,7 @@ typedef struct _cbdata {
     struct _cbdata *next;
     int valid;
     int locks;
+    mem_type mem_type;
 #if CBDATA_DEBUG
     const char *file;
     int line;
@@ -103,9 +103,9 @@ cbdataInit(void)
 
 void
 #if CBDATA_DEBUG
-cbdataAddDbg(const void *p, const char *file, int line)
+cbdataAddDbg(const void *p, mem_type, const char *file, int line)
 #else
-cbdataAdd(const void *p)
+cbdataAdd(const void *p, mem_type mem_type)
 #endif
 {
     cbdata *c;
@@ -116,6 +116,7 @@ cbdataAdd(const void *p)
     c = xcalloc(1, sizeof(cbdata));
     c->key = p;
     c->valid = 1;
+    c->mem_type = mem_type;
 #if CBDATA_DEBUG
     c->file = file;
     c->line = line;
@@ -128,6 +129,7 @@ void
 cbdataFree(void *p)
 {
     cbdata *c = (cbdata *) hash_lookup(htable, p);
+    mem_type mem_type;
     assert(p);
     debug(45, 3) ("cbdataFree: %p\n", p);
     assert(c != NULL);
@@ -139,9 +141,13 @@ cbdataFree(void *p)
     }
     hash_remove_link(htable, (hash_link *) c);
     cbdataCount--;
+    mem_type = c->mem_type;
     xfree(c);
     debug(45, 3) ("cbdataFree: freeing %p\n", p);
-    xfree(p);
+    if (mem_type == MEM_NONE)
+        xfree(p);
+    else
+	memFree(mem_type, p);
 }
 
 void
@@ -1602,7 +1602,7 @@ NAME: memory_pools
 COMMENT: on|off
 TYPE: onoff
 DEFAULT: on
-LOC: opt_mem_pools
+LOC: Config.onoff.mem_pools
 DOC_START
 	If set, Squid will keep pools of allocated (but unused) memory
 	available for future use.  If memory is a premium on your
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.197 1998/01/10 08:15:13 kostas Exp $
+ * $Id: client_side.cc,v 1.198 1998/01/12 04:29:58 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -166,14 +166,14 @@ clientCreateStoreEntry(clientHttpRequest * h, method_t m, int flags)
      * so make a fake one.
      */
     if (h->request == NULL) {
-	r = get_free_request_t();
+	r = memAllocate(MEM_REQUEST_T, 1);
 	r->method = m;
 	r->protocol = PROTO_NONE;
 	h->request = requestLink(r);
     }
     e = storeCreateEntry(h->uri, h->log_uri, flags, m);
     storeClientListAdd(e, h);
-    storeClientCopy(e, 0, 0, 4096, get_free_4k_page(), clientSendMoreData, h);
+    storeClientCopy(e, 0, 0, 4096, memAllocate(MEM_4K_BUF, 1), clientSendMoreData, h);
     return e;
 }
 
@@ -281,7 +281,7 @@ clientProcessExpired(void *data)
 	http->out.offset,
 	http->out.offset,
 	4096,
-	get_free_4k_page(),
+	memAllocate(MEM_4K_BUF, 1),
 	clientHandleIMSReply,
 	http);
 }
@@ -322,7 +322,7 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
     int unlink_request = 0;
     StoreEntry *oldentry;
     debug(33, 3) ("clientHandleIMSReply: %s\n", url);
-    put_free_4k_page(buf);
+    memFree(MEM_4K_BUF, buf);
     buf = NULL;
     /* unregister this handler */
     if (size < 0 || entry->store_status == STORE_ABORTED) {
@@ -340,7 +340,7 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	    http->out.offset + size,
 	    http->out.offset,
 	    4096,
-	    get_free_4k_page(),
+	    memAllocate(MEM_4K_BUF, 1),
 	    clientHandleIMSReply,
 	    http);
 	return;
@@ -387,7 +387,7 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	http->out.offset,
 	http->out.offset,
 	4096,
-	get_free_4k_page(),
+	memAllocate(MEM_4K_BUF, 1),
 	clientCacheHit,
 	http);
 }
@@ -784,9 +784,8 @@ clientBuildReplyHeader(clientHttpRequest * http,
 	debug(12, 3) ("clientBuildReplyHeader: DIDN'T FIND END-OF-HEADERS\n");
 	return 0;
     }
-    xbuf = get_free_4k_page();
-    ybuf = get_free_4k_page();
-
+    xbuf = memAllocate(MEM_4K_BUF, 1);
+    ybuf = memAllocate(MEM_4K_BUF, 1);
     for (t = hdr_in; t < end; t += strcspn(t, crlf), t += strspn(t, crlf)) {
 	hdr_len = t - hdr_in;
 	l = strcspn(t, crlf) + 1;
@@ -828,8 +827,8 @@ clientBuildReplyHeader(clientHttpRequest * http,
 	len = l;
     }
     debug(12, 3) ("clientBuildReplyHeader: OUTPUT:\n%s\n", hdr_out);
-    put_free_4k_page(xbuf);
-    put_free_4k_page(ybuf);
+    memFree(MEM_4K_BUF, xbuf);
+    memFree(MEM_4K_BUF, ybuf);
     return len;
 }
 
@@ -860,7 +859,7 @@ clientSendMoreData(void *data, char *buf, ssize_t size)
     size_t l = 0;
     size_t writelen;
     char *newbuf;
-    FREE *freefunc = put_free_4k_page;
+    FREE *freefunc = memFree4K;
     int hack = 0;
     char C = '\0';
     assert(size <= SM_PAGE_SIZE);
@@ -899,7 +898,7 @@ clientSendMoreData(void *data, char *buf, ssize_t size)
 	    C = *(buf + size);
 	}
 	*(buf + size) = '\0';
-	newbuf = get_free_8k_page();
+	newbuf = memAllocate(MEM_8K_BUF, 1);
 	hdrlen = 0;
 
 	l = clientBuildReplyHeader(http, buf, &hdrlen, newbuf, 8192);
@@ -919,10 +918,10 @@ clientSendMoreData(void *data, char *buf, ssize_t size)
 	    /* replace buf with newbuf */
 	    freefunc(buf);
 	    buf = newbuf;
-	    freefunc = put_free_8k_page;
+	    freefunc = memFree8K;
 	    newbuf = NULL;
 	} else {
-	    put_free_8k_page(newbuf);
+	    memFree(MEM_8K_BUF, newbuf);
 	    newbuf = NULL;
 	    if (size < SM_PAGE_SIZE && entry->store_status == STORE_PENDING) {
 		/* wait for more to arrive */
@@ -1003,7 +1002,7 @@ clientWriteComplete(int fd, char *bufnotused, size_t size, int errflag, void *da
 			http->out.offset,
 			http->out.offset,
 			SM_PAGE_SIZE,
-			get_free_4k_page(),
+			memAllocate(MEM_4K_BUF, 1),
 			clientSendMoreData,
 			http);
 	    } else {
@@ -1028,7 +1027,7 @@ clientWriteComplete(int fd, char *bufnotused, size_t size, int errflag, void *da
 	    http->out.offset,
 	    http->out.offset,
 	    SM_PAGE_SIZE,
-	    get_free_4k_page(),
+	    memAllocate(MEM_4K_BUF, 1),
 	    clientSendMoreData,
 	    http);
     }
@@ -1042,7 +1041,7 @@ clientGetHeadersForIMS(void *data, char *buf, ssize_t size)
     MemObject *mem = entry->mem_obj;
     char *reply = NULL;
     assert(size <= SM_PAGE_SIZE);
-    put_free_4k_page(buf);
+    memFree(MEM_4K_BUF, buf);
     buf = NULL;
     if (size < 0) {
 	debug(12, 1) ("clientGetHeadersForIMS: storeClientCopy failed for '%s'\n",
@@ -1060,7 +1059,7 @@ clientGetHeadersForIMS(void *data, char *buf, ssize_t size)
 	    http->out.offset + size,
 	    http->out.offset,
 	    SM_PAGE_SIZE,
-	    get_free_4k_page(),
+	    memAllocate(MEM_4K_BUF, 1),
 	    clientGetHeadersForIMS,
 	    http);
 	return;
@@ -1094,7 +1093,7 @@ clientGetHeadersForIMS(void *data, char *buf, ssize_t size)
 	    http->out.offset,
 	    http->out.offset,
 	    SM_PAGE_SIZE,
-	    get_free_4k_page(),
+	    memAllocate(MEM_4K_BUF, 1),
 	    clientSendMoreData,
 	    http);
 	return;
@@ -1247,7 +1246,7 @@ clientProcessRequest(clientHttpRequest * http)
 	    http->out.offset,
 	    http->out.offset,
 	    SM_PAGE_SIZE,
-	    get_free_4k_page(),
+	    memAllocate(MEM_4K_BUF, 1),
 	    clientCacheHit,
 	    http);
 	break;
@@ -1256,7 +1255,7 @@ clientProcessRequest(clientHttpRequest * http)
 	    http->out.offset,
 	    http->out.offset,
 	    SM_PAGE_SIZE,
-	    get_free_4k_page(),
+	    memAllocate(MEM_4K_BUF, 1),
 	    clientGetHeadersForIMS,
 	    http);
 	break;
@@ -1358,7 +1357,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     if ((mstr = strtok(inbuf, "\t ")) == NULL) {
 	debug(12, 1) ("parseHttpRequest: Can't get request method\n");
 	http = xcalloc(1, sizeof(clientHttpRequest));
-	cbdataAdd(http);
+	cbdataAdd(http, MEM_NONE);
 	http->conn = conn;
 	http->start = current_time;
 	http->req_sz = conn->in.offset;
@@ -1374,7 +1373,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     if (method == METHOD_NONE) {
 	debug(12, 1) ("parseHttpRequest: Unsupported method '%s'\n", mstr);
 	http = xcalloc(1, sizeof(clientHttpRequest));
-	cbdataAdd(http);
+	cbdataAdd(http, MEM_NONE);
 	http->conn = conn;
 	http->start = current_time;
 	http->req_sz = conn->in.offset;
@@ -1393,7 +1392,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     if ((url = strtok(NULL, "\r\n\t ")) == NULL) {
 	debug(12, 1) ("parseHttpRequest: Missing URL\n");
 	http = xcalloc(1, sizeof(clientHttpRequest));
-	cbdataAdd(http);
+	cbdataAdd(http, MEM_NONE);
 	http->conn = conn;
 	http->start = current_time;
 	http->req_sz = conn->in.offset;
@@ -1411,7 +1410,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     if (t == NULL || *t == '\0' || t == token || strncmp(token, "HTTP/", 5)) {
 	debug(12, 3) ("parseHttpRequest: Missing HTTP identifier\n");
 	http = xcalloc(1, sizeof(clientHttpRequest));
-	cbdataAdd(http);
+	cbdataAdd(http, MEM_NONE);
 	http->conn = conn;
 	http->start = current_time;
 	http->req_sz = conn->in.offset;
@@ -1442,7 +1441,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 	/* Invalid request */
 	debug(12, 3) ("parseHttpRequest: No request headers?\n");
 	http = xcalloc(1, sizeof(clientHttpRequest));
-	cbdataAdd(http);
+	cbdataAdd(http, MEM_NONE);
 	http->conn = conn;
 	http->start = current_time;
 	http->req_sz = conn->in.offset;
@@ -1458,7 +1457,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 
     /* Ok, all headers are received */
     http = xcalloc(1, sizeof(clientHttpRequest));
-    cbdataAdd(http);
+    cbdataAdd(http, MEM_NONE);
     http->http_ver = http_ver;
     http->conn = conn;
     http->start = current_time;
@@ -1775,7 +1774,7 @@ httpAccept(int sock, void *notused)
     connState->ident.fd = -1;
     connState->in.size = REQUEST_BUF_SIZE;
     connState->in.buf = xcalloc(connState->in.size, 1);
-    cbdataAdd(connState);
+    cbdataAdd(connState, MEM_NONE);
     meta_data.misc += connState->in.size;
     comm_add_close_handler(fd, connStateFree, connState);
     if (Config.onoff.log_fqdn)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.221 1998/01/06 02:47:14 wessels Exp $
+ * $Id: comm.cc,v 1.222 1998/01/12 04:29:58 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -308,7 +308,7 @@ void
 commConnectStart(int fd, const char *host, u_short port, CNCB * callback, void *data)
 {
     ConnectStateData *cs = xcalloc(1, sizeof(ConnectStateData));
-    cbdataAdd(cs);
+    cbdataAdd(cs, MEM_NONE);
     cs->fd = fd;
     cs->host = xstrdup(host);
     cs->port = port;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dns.cc,v 1.49 1998/01/06 05:15:40 wessels Exp $
+ * $Id: dns.cc,v 1.50 1998/01/12 04:29:59 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -259,7 +259,7 @@ dnsOpenServers(void)
     NDnsServersAlloc = 0;
     for (k = 0; k < N; k++) {
 	dns_child_table[k] = xcalloc(1, sizeof(dnsserver_t));
-	cbdataAdd(dns_child_table[k]);
+	cbdataAdd(dns_child_table[k], MEM_NONE);
 	if ((dnssocket = dnsOpenServer(prg)) < 0) {
 	    debug(34, 1) ("dnsOpenServers: WARNING: Failed to start 'dnsserver' #%d.\n", k + 1);
 	    EBIT_CLR(dns_child_table[k]->flags, HELPER_ALIVE);
@@ -152,6 +152,7 @@ typedef enum {
     MGR_CBDATA,
     MGR_PCONN,
     MGR_5MIN,
+    MGR_MEM,
     MGR_MAX
 } objcache_op;
 
@@ -369,11 +370,87 @@ typedef enum {
     ACCESS_REQ_PROXY_AUTH
 } allow_t;
 
+#if SQUID_SNMP
 enum {
     SNMP_C_VIEW,
     SNMP_C_USER,
     SNMP_C_COMMUNITY
 };
+#endif
+
+typedef enum {
+	MEM_NONE,
+	MEM_DISK_BUF,
+	MEM_STMEM_BUF,
+	MEM_4K_BUF,
+	MEM_8K_BUF,
+	MEM_ACL_IP_DATA,
+	MEM_ACL_TIME_DATA,
+	MEM_ACL_NAME_LIST,
+	MEM_ACL_DENY_INFO_LIST,
+	MEM_ACL,
+#if SQUID_SNMP
+	MEM_SNMPCONF,
+#endif
+	MEM_ACL_LIST,
+	MEM_ACL_ACCESS,
+	MEM_ACLCHECK_T,
+	MEM_AIO_RESULT_T,
+	MEM_WORDLIST,
+	MEM_INTLIST,
+	MEM_USHORTLIST,
+	MEM_RELIST,
+	MEM_SQUIDCONFIG,
+	MEM_SQUIDCONFIG2,
+	MEM_CLOSE_HANDLER,
+	MEM_DREAD_CTRL,
+	MEM_DNSSERVER_T,
+	MEM_DNSSTATDATA,
+	MEM_DWRITE_Q,
+	MEM_FILEMAP,
+	MEM_FQDNCACHE_ENTRY,
+	MEM_HASH_LINK,
+	MEM_HASH_TABLE,
+	MEM_HTTP_REPLY,
+	MEM_HTTPSTATEDATA,
+	MEM_ICPUDPDATA,
+	MEM_CLIENTHTTPREQUEST,
+	MEM_CONNSTATEDATA,
+	MEM_IPCACHE_ADDRS,
+	MEM_IPCACHE_ENTRY,
+	MEM_DOMAIN_PING,
+	MEM_DOMAIN_TYPE,
+	MEM_PEER,
+	MEM_NET_DB_NAME,
+	MEM_NET_DB_PEER,
+	MEM_NETDBENTRY,
+	MEM_ICP_PING_DATA,
+	MEM_PS_STATE,
+	MEM_HIERARCHYLOGENTRY,
+	MEM_PINGERECHODATA,
+	MEM_PINGERREPLYDATA,
+	MEM_ICP_COMMON_T,
+	MEM_PROTO_STAT,
+	MEM_META_DATA,
+	MEM_CACHEINFO,
+	MEM_IOSTATS,
+	MEM_MEM_NODE,
+	MEM_MEM_HDR,
+	MEM_STORE_CLIENT,
+	MEM_MEMOBJECT,
+	MEM_STOREENTRY,
+	MEM_SWAPDIR,
+	MEM_REQUEST_T,
+	MEM_ACCESSLOGENTRY,
+	MEM_CACHEMGR_PASSWD,
+	MEM_REFRESH_T,
+	MEM_COMMWRITESTATEDATA,
+	MEM_ERRORSTATE,
+	MEM_DLINK_NODE,
+	MEM_DLINK_LIST,
+	MEM_STATCOUNTERS,
+	MEM_MAX
+} mem_type;
 
 enum {
     SWAP_META_VOID,		/* should not come up */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.114 1998/01/06 05:12:08 wessels Exp $
+ * $Id: errorpage.cc,v 1.115 1998/01/12 04:30:00 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -167,7 +167,7 @@ errorSend(int fd, ErrorState * err)
 	err->request->err_type = err->type;
     buf = errorBuildBuf(err, &len);
     EBIT_SET(err->flags, ERR_FLAG_CBDATA);
-    cbdataAdd(err);
+    cbdataAdd(err, MEM_NONE);
     comm_write(fd, xstrdup(buf), len, errorSendComplete, err, xfree);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.185 1998/01/07 21:16:30 wessels Exp $
+ * $Id: ftp.cc,v 1.186 1998/01/12 04:30:01 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -207,7 +207,7 @@ ftpStateFree(int fdnotused, void *data)
     storeUnregisterAbort(ftpState->entry);
     storeUnlockObject(ftpState->entry);
     if (ftpState->reply_hdr) {
-	put_free_8k_page(ftpState->reply_hdr);
+	memFree(MEM_8K_BUF, ftpState->reply_hdr);
 	ftpState->reply_hdr = NULL;
     }
     requestUnlink(ftpState->request);
@@ -639,7 +639,7 @@ ftpParseListing(FtpStateData * ftpState, int len)
 	debug(9, 3) ("ftpParseListing: didn't find end for %s\n", storeUrl(e));
 	return;
     }
-    line = get_free_4k_page();
+    line = memAllocate(MEM_4K_BUF, 1);
     end++;
     /* XXX there is an ABR bug here.   We need to make sure buf is
      * NULL terminated */
@@ -667,7 +667,7 @@ ftpParseListing(FtpStateData * ftpState, int len)
 	xstrncpy(ftpState->data.buf, line, ftpState->data.size);
 	ftpState->data.offset = strlen(ftpState->data.buf);
     }
-    put_free_4k_page(line);
+    memFree(MEM_4K_BUF, line);
 }
 
 static void
@@ -863,7 +863,7 @@ ftpStart(request_t * request, StoreEntry * entry)
     char *response;
     int fd;
     ErrorState *err;
-    cbdataAdd(ftpState);
+    cbdataAdd(ftpState, MEM_NONE);
     debug(9, 3) ("FtpStart: '%s'\n", url);
     storeLockObject(entry);
     ftpState->entry = entry;
@@ -941,8 +941,8 @@ ftpConnectDone(int fd, int status, void *data)
 	comm_close(ftpState->ctrl.fd);
     } else {
 	ftpState->state = BEGIN;
-	ftpState->ctrl.buf = get_free_4k_page();
-	ftpState->ctrl.freefunc = put_free_4k_page;
+	ftpState->ctrl.buf = memAllocate(MEM_4K_BUF, 1);
+	ftpState->ctrl.freefunc = memFree4K;
 	ftpState->ctrl.size = 4096;
 	ftpState->ctrl.offset = 0;
 	ftpState->data.buf = xmalloc(SQUID_TCP_SO_RCVBUF);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.25 1998/01/10 07:50:35 kostas Exp $
+ * $Id: globals.h,v 1.26 1998/01/12 04:30:01 wessels Exp $
  */
 
 extern FILE *debug_log;		/* NULL */
@@ -61,7 +61,6 @@ extern int opt_debug_stderr;	/* 0 */
 extern int opt_dns_tests;	/* 1 */
 extern int opt_foreground_rebuild;	/* 0 */
 extern int opt_forwarded_for;	/* 1 */
-extern int opt_mem_pools;	/* 1 */
 extern int opt_reload_hit_only;	/* 0 */
 extern int opt_syslog_enable;	/* 0 */
 extern int opt_udp_hit_obj;	/* 0 */
@@ -77,10 +76,6 @@ extern char *snmp_agentinfo;
 extern int vhost_mode;		/* 0 */
 extern int vizSock;		/* -1 */
 extern iostats IOStats;
-extern stmem_stats disk_stats;
-extern stmem_stats mem_obj_pool;
-extern stmem_stats request_pool;
-extern stmem_stats sm_stats;
 extern struct _acl_deny_info_list *DenyInfoList;	/* NULL */
 extern struct in_addr any_addr;
 extern struct in_addr local_addr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: gopher.cc,v 1.117 1998/01/05 21:44:42 wessels Exp $
+ * $Id: gopher.cc,v 1.118 1998/01/12 04:30:02 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -190,7 +190,7 @@ gopherStateFree(int fdnotused, void *data)
 	storeUnregisterAbort(gopherState->entry);
 	storeUnlockObject(gopherState->entry);
     }
-    put_free_4k_page(gopherState->buf);
+    memFree(MEM_4K_BUF, gopherState->buf);
     gopherState->buf = NULL;
     cbdataFree(gopherState);
 }
@@ -680,7 +680,7 @@ gopherReadReply(int fd, void *data)
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->inmem_hi;
-    buf = get_free_4k_page();
+    buf = memAllocate(MEM_4K_BUF, 1);
     errno = 0;
     /* leave one space for \0 in gopherToHTML */
     len = read(fd, buf, TEMP_BUF_SIZE - 1);
@@ -735,7 +735,7 @@ gopherReadReply(int fd, void *data)
 	    gopherReadReply,
 	    data, 0);
     }
-    put_free_4k_page(buf);
+    memFree(MEM_4K_BUF, buf);
     return;
 }
 
@@ -758,7 +758,7 @@ gopherSendComplete(int fd, char *buf, size_t size, int errflag, void *data)
 	errorAppendEntry(entry, err);
 	comm_close(fd);
 	if (buf)
-	    put_free_4k_page(buf);	/* Allocated by gopherSendRequest. */
+	    memFree(MEM_4K_BUF, buf);	/* Allocated by gopherSendRequest. */
 	return;
     }
     /* 
@@ -793,7 +793,7 @@ gopherSendComplete(int fd, char *buf, size_t size, int errflag, void *data)
     commSetSelect(fd, COMM_SELECT_READ, gopherReadReply, gopherState, 0);
     commSetDefer(fd, protoCheckDeferRead, entry);
     if (buf)
-	put_free_4k_page(buf);	/* Allocated by gopherSendRequest. */
+	memFree(MEM_4K_BUF, buf);	/* Allocated by gopherSendRequest. */
 }
 
 /* This will be called when connect completes. Write request. */
@@ -802,7 +802,7 @@ gopherSendRequest(int fd, void *data)
 {
     GopherStateData *gopherState = data;
     LOCAL_ARRAY(char, query, MAX_URL);
-    char *buf = get_free_4k_page();
+    char *buf = memAllocate(MEM_4K_BUF, 1);
     char *t;
     if (gopherState->type_id == GOPHER_CSO) {
 	sscanf(gopherState->request, "?%s", query);
@@ -820,7 +820,7 @@ gopherSendRequest(int fd, void *data)
 	strlen(buf),
 	gopherSendComplete,
 	data,
-	put_free_4k_page);
+	memFree4K);
     if (EBIT_TEST(gopherState->entry->flag, ENTRY_CACHABLE))
 	storeSetPublicKey(gopherState->entry);	/* Make it public */
 }
@@ -923,8 +923,8 @@ static GopherStateData *
 CreateGopherStateData(void)
 {
     GopherStateData *gd = xcalloc(1, sizeof(GopherStateData));
-    cbdataAdd(gd);
-    gd->buf = get_free_4k_page();
+    cbdataAdd(gd, MEM_NONE);
+    gd->buf = memAllocate(MEM_4K_BUF, 1);
     return (gd);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.232 1998/01/10 08:15:14 kostas Exp $
+ * $Id: http.cc,v 1.233 1998/01/12 04:30:03 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -225,7 +225,7 @@ httpStateFree(int fdnotused, void *data)
     assert(httpState->entry->store_status != STORE_PENDING);
     storeUnlockObject(httpState->entry);
     if (httpState->reply_hdr) {
-	put_free_8k_page(httpState->reply_hdr);
+	memFree(MEM_8K_BUF, httpState->reply_hdr);
 	httpState->reply_hdr = NULL;
     }
     requestUnlink(httpState->request);
@@ -294,7 +294,7 @@ httpCacheNegatively(StoreEntry * entry)
 void
 httpParseReplyHeaders(const char *buf, struct _http_reply *reply)
 {
-    char *headers = get_free_4k_page();
+    char *headers = memAllocate(MEM_4K_BUF, 1);
     char *line;
     char *end;
     char *s = NULL;
@@ -314,11 +314,11 @@ httpParseReplyHeaders(const char *buf, struct _http_reply *reply)
 	    if ((t = strchr(t, ' ')))
 		reply->code = atoi(++t);
 	}
-	put_free_4k_page(headers);
+	memFree(MEM_4K_BUF, headers);
 	return;
     }
     reply->hdr_sz = end - headers;
-    line = get_free_4k_page();
+    line = memAllocate(MEM_4K_BUF, 1);
     for (s = headers; s < end; s += strcspn(s, crlf), s += strspn(s, crlf)) {
 	l = strcspn(s, crlf) + 1;
 	if (l > 4096)
@@ -417,8 +417,8 @@ httpParseReplyHeaders(const char *buf, struct _http_reply *reply)
 		EBIT_SET(reply->misc_headers, HDR_PROXY_KEEPALIVE);
 	}
     }
-    put_free_4k_page(headers);
-    put_free_4k_page(line);
+    memFree(MEM_4K_BUF, headers);
+    memFree(MEM_4K_BUF, line);
 }
 
 static int
@@ -510,7 +510,7 @@ httpProcessReplyHeader(HttpStateData * httpState, const char *buf, int size)
     debug(11, 3) ("httpProcessReplyHeader: key '%s'\n",
 	storeKeyText(entry->key));
     if (httpState->reply_hdr == NULL)
-	httpState->reply_hdr = get_free_8k_page();
+	httpState->reply_hdr = memAllocate(MEM_8K_BUF, 1);
     if (httpState->reply_hdr_state == 0) {
 	hdr_len = strlen(httpState->reply_hdr);
 	room = 8191 - hdr_len;
@@ -771,9 +771,9 @@ httpBuildRequestHeader(request_t * request,
 {
     LOCAL_ARRAY(char, ybuf, YBUF_SZ);
     LOCAL_ARRAY(char, no_forward, 1024);
-    char *xbuf = get_free_4k_page();
-    char *viabuf = get_free_4k_page();
-    char *fwdbuf = get_free_4k_page();
+    char *xbuf = memAllocate(MEM_4K_BUF, 1);
+    char *viabuf = memAllocate(MEM_4K_BUF, 1);
+    char *fwdbuf = memAllocate(MEM_4K_BUF, 1);
     char *t = NULL;
     char *s = NULL;
     char *end = NULL;
@@ -883,9 +883,9 @@ httpBuildRequestHeader(request_t * request,
 	httpAppendRequestHeader(hdr_out, ybuf, &len, out_sz, 1);
     }
     httpAppendRequestHeader(hdr_out, null_string, &len, out_sz, 1);
-    put_free_4k_page(xbuf);
-    put_free_4k_page(viabuf);
-    put_free_4k_page(fwdbuf);
+    memFree(MEM_4K_BUF, xbuf);
+    memFree(MEM_4K_BUF, viabuf);
+    memFree(MEM_4K_BUF, fwdbuf);
     if (in_len)
 	*in_len = hdr_len;
     if ((l = strlen(hdr_out)) != len) {
@@ -921,7 +921,7 @@ httpSendRequest(int fd, void *data)
 	return;
     }
     if (buflen < DISK_PAGE_SIZE) {
-	buf = get_free_8k_page();
+	buf = memAllocate(MEM_8K_BUF, 1);
 	buftype = BUF_TYPE_8K;
 	buflen = DISK_PAGE_SIZE;
     } else {
@@ -958,7 +958,7 @@ httpSendRequest(int fd, void *data)
 	len,
 	httpSendComplete,
 	httpState,
-	buftype == BUF_TYPE_8K ? put_free_8k_page : xfree);
+	buftype == BUF_TYPE_8K ? memFree8K : xfree);
 #ifdef BREAKS_PCONN_RESTART
     requestUnlink(httpState->orig_request);
     httpState->orig_request = NULL;
@@ -992,11 +992,11 @@ httpBuildState(int fd, StoreEntry * entry, request_t * orig_request, peer * e)
     HttpStateData *httpState = xcalloc(1, sizeof(HttpStateData));
     request_t *request;
     storeLockObject(entry);
-    cbdataAdd(httpState);
+    cbdataAdd(httpState, MEM_NONE);
     httpState->entry = entry;
     httpState->fd = fd;
     if (e) {
-	request = get_free_request_t();
+	request = memAllocate(MEM_REQUEST_T, 1);
 	request->method = orig_request->method;
 	xstrncpy(request->host, e->host, SQUIDHOSTNAMELEN);
 	request->port = e->http_port;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icmp.cc,v 1.52 1998/01/06 22:58:08 wessels Exp $
+ * $Id: icmp.cc,v 1.53 1998/01/12 04:30:03 wessels Exp $
  *
  * DEBUG: section 37    ICMP Routines
  * AUTHOR: Duane Wessels
@@ -203,13 +203,13 @@ icmpSourcePing(struct in_addr to, const icp_common_t * header, const char *url)
     debug(37, 3) ("icmpSourcePing: '%s'\n", url);
     if ((ulen = strlen(url)) > MAX_URL)
 	return;
-    payload = get_free_8k_page();
+    payload = memAllocate(MEM_8K_BUF, 1);
     len = sizeof(icp_common_t);
     xmemcpy(payload, header, len);
     strcpy(payload + len, url);
     len += ulen + 1;
     icmpSendEcho(to, S_ICMP_ICP, payload, len);
-    put_free_8k_page(payload);
+    memFree(MEM_8K_BUF, payload);
 #endif
 }
 
@@ -261,7 +261,7 @@ icpHandleIcpV2(int fd, struct sockaddr_in from, char *buf, int len)
 	break;
     }
     if (icp_request)
-	put_free_request_t(icp_request);
+	memFree(MEM_REQUEST_T, icp_request);
 }
 
 #ifdef ICP_PKT_DUMP
@@ -121,5 +121,5 @@ icpHandleIcpV3(int fd, struct sockaddr_in from, char *buf, int len)
 	break;
     }
     if (icp_request)
-	put_free_request_t(icp_request);
+	memFree(MEM_REQUEST_T, icp_request);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.206 1998/01/10 07:50:36 kostas Exp $
+ * $Id: main.cc,v 1.207 1998/01/12 04:30:05 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -429,7 +429,7 @@ mainInitialize(void)
     debug(1, 1) ("With %d file descriptors available\n", Squid_MaxFD);
 
     if (!configured_once) {
-	stmemInit();		/* stmem must go before at least redirect */
+	memInit();		/* memInit must go before at least redirect */
 	disk_init();		/* disk_init must go before ipcache_init() */
     }
     ipcache_init();
@@ -1,5 +1,5 @@
 /*
- * $Id: mime.cc,v 1.44 1997/11/14 05:13:29 wessels Exp $
+ * $Id: mime.cc,v 1.45 1998/01/12 04:30:05 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -421,7 +421,7 @@ mimeLoadIconFile(const char *icon)
 	METHOD_GET);
     assert(e != NULL);
     e->mem_obj->request = requestLink(urlParse(METHOD_GET, url));
-    buf = get_free_4k_page();
+    buf = memAllocate(MEM_4K_BUF, 1);
     l = 0;
     l += snprintf(buf + l, SM_PAGE_SIZE - l, "HTTP/1.0 200 OK\r\n");
     l += snprintf(buf + l, SM_PAGE_SIZE - l, "Date: %s\r\n", mkrfc1123(squid_curtime));
@@ -442,5 +442,5 @@ mimeLoadIconFile(const char *icon)
     EBIT_SET(e->flag, ENTRY_SPECIAL);
     debug(25, 3) ("Loaded icon %s\n", url);
     storeUnlockObject(e);
-    put_free_4k_page(buf);
+    memFree(MEM_4K_BUF, buf);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.59 1998/01/09 08:06:32 wessels Exp $
+ * $Id: net_db.cc,v 1.60 1998/01/12 04:30:06 wessels Exp $
  *
  * DEBUG: section 37    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -374,7 +374,7 @@ static void
 netdbReloadState(void)
 {
     LOCAL_ARRAY(char, path, SQUID_MAXPATHLEN);
-    char *buf = get_free_4k_page();
+    char *buf = memAllocate(MEM_4K_BUF, 1);
     char *t;
     FILE *fp;
     netdbEntry *n;
@@ -422,7 +422,7 @@ netdbReloadState(void)
 	    netdbHashLink(n, t);
 	count++;
     }
-    put_free_4k_page(buf);
+    memFree(MEM_4K_BUF, buf);
     fclose(fp);
     debug(37, 0) ("NETDB state reloaded; %d entries, %d msec\n",
 	count, tvSubMsec(start, current_time));
@@ -472,7 +472,7 @@ netdbPingSite(const char *hostname)
 	if (n->next_ping_time > squid_curtime)
 	    return;
     h = xstrdup(hostname);
-    cbdataAdd(h);
+    cbdataAdd(h, MEM_NONE);
     cbdataLock(h);
     ipcache_nbgethostbyname(hostname, netdbSendPing, h);
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.34 1997/12/21 11:00:19 kostas Exp $
+ * $Id: peer_select.cc,v 1.35 1998/01/12 04:30:08 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -146,7 +146,7 @@ peerSelect(request_t * request,
 	debug(44, 3) ("peerSelect: %s\n", storeUrl(entry));
     else
 	debug(44, 3) ("peerSelect: %s\n", RequestMethodStr[request->method]);
-    cbdataAdd(psstate);
+    cbdataAdd(psstate, MEM_NONE);
     psstate->request = requestLink(request);
     psstate->entry = entry;
     psstate->callback = callback;
@@ -55,9 +55,9 @@ extern void configFreeMemory(void);
 
 extern void cbdataInit(void);
 #if CBDATA_DEBUG
-extern void cbdataAddDbg(const void *p, const char *, int);
+extern void cbdataAddDbg(const void *p, mem_type, const char *, int);
 #else
-extern void cbdataAdd(const void *p);
+extern void cbdataAdd(const void *p, mem_type);
 #endif
 extern void cbdataFree(void *p);
 extern void cbdataLock(const void *p);
@@ -376,42 +376,26 @@ extern void storeDirClean(void *unused);
 extern void passStart(int, const char *, request_t *, size_t *);
 extern void identStart(int, ConnStateData *, IDCB * callback);
 
-extern void *pop(Stack *);
-extern int empty_stack(const Stack *);
-extern int full_stack(const Stack *);
-extern void push(Stack *, void *);
-extern void init_stack(Stack *, int);
-extern void stackFreeMemory(Stack *);
-
 extern void stat_init(cacheinfo **, const char *);
 extern void pconnHistCount(int, int);
 extern void statAvgInit(void);
 extern int statMemoryAccounted(void);
 
-/* To reduce memory fragmentation, we now store the memory version of an
- * object in fixed size blocks of size PAGE_SIZE and instead of calling 
- * malloc and free, we manage our own fixed block free list.   
- */
-
-extern char *get_free_4k_page(void);
-extern char *get_free_8k_page(void);
-extern void *get_free_request_t(void);
-extern void *get_free_mem_obj(void);
-extern mem_hdr *memInit(void);
-extern void put_free_4k_page(void *);
-extern void put_free_8k_page(void *);
-extern void put_free_request_t(void *);
-extern void put_free_mem_obj(void *);
-extern void stmemInit(void);
-extern void stmemFreeMemory(void);
-
-extern int memFreeDataUpto(mem_hdr *, int);
-extern void memAppend(mem_hdr *, const char *, int);
-extern ssize_t memCopy(const mem_hdr *, off_t, char *, size_t);
-extern void memFree(mem_hdr *);
-extern void memFreeData(mem_hdr *);
-
-
+extern void memInit(void);
+extern void memFreeMemory(void);
+extern void *memAllocate(mem_type, int);
+extern void memFree(mem_type, void *);
+extern void memFree4K(void *);
+extern void memFree8K(void *);
+extern void memFreeDISK(void *);
+extern int memInUse(mem_type);
+extern OBJH memStats;
+
+extern int stmemFreeDataUpto(mem_hdr *, int);
+extern void stmemAppend(mem_hdr *, const char *, int);
+extern ssize_t stmemCopy(const mem_hdr *, off_t, char *, size_t);
+extern void stmemFree(mem_hdr *);
+extern void stmemFreeData(mem_hdr *);
 
 /* ----------------------------------------------------------------- */
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.51 1997/12/06 05:16:59 wessels Exp $
+ * $Id: redirect.cc,v 1.52 1998/01/12 04:30:10 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -181,7 +181,7 @@ redirectHandleRead(int fd, void *data)
 	    ("FD %d: Connection from Redirector #%d is closed, disabling\n",
 	    fd, redirector->index + 1);
 	redirector->flags = 0;
-	put_free_8k_page(redirector->inbuf);
+	memFree(MEM_8K_BUF, redirector->inbuf);
 	redirector->inbuf = NULL;
 	comm_close(fd);
 	if (--NRedirectorsOpen == 0 && !shutdown_pending && !reconfigure_pending)
@@ -301,7 +301,7 @@ redirectDispatch(redirector_t * redirect, redirectStateData * r)
     redirect->dispatch_time = current_time;
     if ((fqdn = fqdncache_gethostbyaddr(r->client_addr, 0)) == NULL)
 	fqdn = dash_str;
-    buf = get_free_8k_page();
+    buf = memAllocate(MEM_8K_BUF, 1);
     snprintf(buf, 8192, "%s %s/%s %s %s\n",
 	r->orig_url,
 	inet_ntoa(r->client_addr),
@@ -314,7 +314,7 @@ redirectDispatch(redirector_t * redirect, redirectStateData * r)
 	len,
 	NULL,			/* Handler */
 	NULL,			/* Handler-data */
-	put_free_8k_page);
+	memFree8K);
     debug(29, 5) ("redirectDispatch: Request sent to Redirector #%d, %d bytes\n",
 	redirect->index + 1, len);
     RedirectStats.use_hist[redirect->index]++;
@@ -365,7 +365,7 @@ redirectFreeMemory(void)
     if (redirect_child_table) {
 	for (k = 0; k < NRedirectors; k++) {
 	    if (redirect_child_table[k]->inbuf)
-		put_free_8k_page(redirect_child_table[k]->inbuf);
+		memFree(MEM_8K_BUF, redirect_child_table[k]->inbuf);
 	    safe_free(redirect_child_table[k]);
 	}
 	safe_free(redirect_child_table);
@@ -398,7 +398,7 @@ redirectOpenServers(void)
 	    EBIT_SET(redirect_child_table[k]->flags, HELPER_ALIVE);
 	    redirect_child_table[k]->index = k;
 	    redirect_child_table[k]->fd = redirectsocket;
-	    redirect_child_table[k]->inbuf = get_free_8k_page();
+	    redirect_child_table[k]->inbuf = memAllocate(MEM_8K_BUF, 1);
 	    redirect_child_table[k]->size = 8192;
 	    redirect_child_table[k]->offset = 0;
 	    if ((s = strrchr(prg, '/')))
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.72 1997/11/14 17:21:23 wessels Exp $
+ * $Id: ssl.cc,v 1.73 1998/01/12 04:30:11 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -368,7 +368,7 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr)
 	return;
     }
     sslState = xcalloc(1, sizeof(SslStateData));
-    cbdataAdd(sslState);
+    cbdataAdd(sslState, MEM_NONE);
     sslState->url = xstrdup(url);
     sslState->request = requestLink(request);
     sslState->size_ptr = size_ptr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.184 1998/01/08 03:39:22 wessels Exp $
+ * $Id: stat.cc,v 1.185 1998/01/12 04:30:11 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -502,15 +502,10 @@ int
 statMemoryAccounted(void)
 {
     return (int)
-	meta_data.store_entries * sizeof(StoreEntry) +
 	meta_data.store_keys +
 	meta_data.ipcache_count * sizeof(ipcache_entry) +
 	meta_data.fqdncache_count * sizeof(fqdncache_entry) +
 	hash_links_allocated * sizeof(hash_link) +
-	sm_stats.total_pages_allocated * sm_stats.page_size +
-	disk_stats.total_pages_allocated * disk_stats.page_size +
-	request_pool.total_pages_allocated * request_pool.page_size +
-	mem_obj_pool.total_pages_allocated * mem_obj_pool.page_size +
 	meta_data.netdb_addrs * sizeof(netdbEntry) +
 	meta_data.netdb_hosts * sizeof(struct _net_db_name) +
                  meta_data.netdb_peers * sizeof(struct _net_db_peer) +
@@ -642,21 +637,14 @@ info_get(StoreEntry * sentry)
 
     storeAppendPrintf(sentry, "{Internal Data Structures:}\n");
     storeAppendPrintf(sentry, "{\t%6d StoreEntries}\n",
-	meta_data.store_entries);
+	memInUse(MEM_STOREENTRY));
     storeAppendPrintf(sentry, "{\t%6d StoreEntries with MemObjects}\n",
-	meta_data.mem_obj_count);
+	memInUse(MEM_MEMOBJECT));
     storeAppendPrintf(sentry, "{\t%6d StoreEntries with MemObject Data}\n",
-	meta_data.mem_data_count);
+	memInUse(MEM_MEM_HDR));
     storeAppendPrintf(sentry, "{\t%6d Hot Object Cache Items}\n",
 	meta_data.hot_vm);
 
-    storeAppendPrintf(sentry, "{Accounted Memory Usage:}\n");
-    storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB}\n",
-	"StoreEntry",
-	meta_data.store_entries,
-	(int) sizeof(StoreEntry),
-	(int) (meta_data.store_entries * sizeof(StoreEntry) >> 10));
-
     storeAppendPrintf(sentry, "{\t%-25.25s                      = %6d KB}\n",
 	"StoreEntry Keys",
 	meta_data.store_keys >> 10);
@@ -679,34 +667,6 @@ info_get(StoreEntry * sentry)
 	(int) sizeof(hash_link),
 	(int) (hash_links_allocated * sizeof(hash_link) >> 10));
 
-    storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB (%6d free)}\n",
-	"Pool MemObject structures",
-	mem_obj_pool.total_pages_allocated,
-	mem_obj_pool.page_size,
-	mem_obj_pool.total_pages_allocated * mem_obj_pool.page_size >> 10,
-	(mem_obj_pool.total_pages_allocated - mem_obj_pool.n_pages_in_use) * mem_obj_pool.page_size >> 10);
-
-    storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB (%6d free)}\n",
-	"Pool for Request structures",
-	request_pool.total_pages_allocated,
-	request_pool.page_size,
-	request_pool.total_pages_allocated * request_pool.page_size >> 10,
-	(request_pool.total_pages_allocated - request_pool.n_pages_in_use) * request_pool.page_size >> 10);
-
-    storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB (%6d free)}\n",
-	"Pool for in-memory object data",
-	sm_stats.total_pages_allocated,
-	sm_stats.page_size,
-	sm_stats.total_pages_allocated * sm_stats.page_size >> 10,
-	(sm_stats.total_pages_allocated - sm_stats.n_pages_in_use) * sm_stats.page_size >> 10);
-
-    storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB (%6d free)}\n",
-	"Pool for disk I/O",
-	disk_stats.total_pages_allocated,
-	disk_stats.page_size,
-	disk_stats.total_pages_allocated * disk_stats.page_size >> 10,
-	(disk_stats.total_pages_allocated - disk_stats.n_pages_in_use) * disk_stats.page_size >> 10);
-
     storeAppendPrintf(sentry, "{\t%-25.25s %7d x %4d bytes = %6d KB}\n",
 	"NetDB Address Entries",
 	meta_data.netdb_addrs,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stmem.cc,v 1.54 1998/01/05 21:18:15 wessels Exp $
+ * $Id: stmem.cc,v 1.55 1998/01/12 04:30:12 wessels Exp $
  *
  * DEBUG: section 19    Memory Primitives
  * AUTHOR: Harvest Derived
@@ -106,16 +106,8 @@
 
 #include "squid.h"
 
-#ifndef USE_MEMALIGN
-#define USE_MEMALIGN 0
-#endif
-
-static void *get_free_thing(stmem_stats *);
-static void put_free_thing(stmem_stats *, void *);
-static void stmemFreeThingMemory(stmem_stats *);
-
 void
-memFree(mem_hdr * mem)
+stmemFree(mem_hdr * mem)
 {
     mem_node *lastp;
     mem_node *p = mem->head;
@@ -125,24 +117,23 @@ memFree(mem_hdr * mem)
 	    lastp = p;
 	    p = p->next;
 	    if (lastp) {
-		put_free_4k_page(lastp->data);
+		memFree(MEM_STMEM_BUF, lastp->data);
 		store_mem_size -= SM_PAGE_SIZE;
 		safe_free(lastp);
 	    }
 	}
 
 	if (p) {
-	    put_free_4k_page(p->data);
+	    memFree(MEM_STMEM_BUF, p->data);
 	    store_mem_size -= SM_PAGE_SIZE;
 	    safe_free(p);
 	}
     }
-    memset(mem, '\0', sizeof(mem_hdr *));	/* nuke in case ref'ed again */
-    safe_free(mem);
+    memFree(MEM_MEM_HDR, mem);
 }
 
 int
-memFreeDataUpto(mem_hdr * mem, int target_offset)
+stmemFreeDataUpto(mem_hdr * mem, int target_offset)
 {
     int current_offset = mem->origin_offset;
     mem_node *lastp;
@@ -157,7 +148,7 @@ memFreeDataUpto(mem_hdr * mem, int target_offset)
 	    lastp = p;
 	    p = p->next;
 	    current_offset += lastp->len;
-	    put_free_4k_page(lastp->data);
+	    memFree(MEM_STMEM_BUF, lastp->data);
 	    store_mem_size -= SM_PAGE_SIZE;
 	    safe_free(lastp);
 	}
@@ -174,7 +165,7 @@ memFreeDataUpto(mem_hdr * mem, int target_offset)
 
 /* Append incoming data. */
 void
-memAppend(mem_hdr * mem, const char *data, int len)
+stmemAppend(mem_hdr * mem, const char *data, int len)
 {
     mem_node *p;
     int avail_len;
@@ -197,7 +188,7 @@ memAppend(mem_hdr * mem, const char *data, int len)
 	p = xcalloc(1, sizeof(mem_node));
 	p->next = NULL;
 	p->len = len_to_copy;
-	p->data = get_free_4k_page();
+	p->data = memAllocate(MEM_STMEM_BUF, 1);
 	store_mem_size += SM_PAGE_SIZE;
 	xmemcpy(p->data, data, len_to_copy);
 	if (!mem->head) {
@@ -214,7 +205,7 @@ memAppend(mem_hdr * mem, const char *data, int len)
 }
 
 ssize_t
-memCopy(const mem_hdr * mem, off_t offset, char *buf, size_t size)
+stmemCopy(const mem_hdr * mem, off_t offset, char *buf, size_t size)
 {
     mem_node *p = mem->head;
     off_t t_off = mem->origin_offset;
@@ -253,155 +244,3 @@ memCopy(const mem_hdr * mem, off_t offset, char *buf, size_t size)
     }
     return size - bytes_to_go;
 }
-
-
-/* Do whatever is necessary to begin storage of new object */
-mem_hdr *
-memInit(void)
-{
-    mem_hdr *new = xcalloc(1, sizeof(mem_hdr));
-    new->tail = new->head = NULL;
-    return new;
-}
-
-static void *
-get_free_thing(stmem_stats * thing)
-{
-    void *p = NULL;
-    if (!empty_stack(&thing->free_page_stack)) {
-	p = pop(&thing->free_page_stack);
-	assert(p != NULL);
-    } else {
-	p = xmalloc(thing->page_size);
-	thing->total_pages_allocated++;
-    }
-    thing->n_pages_in_use++;
-    memset(p, '\0', thing->page_size);
-    return p;
-}
-
-void *
-get_free_request_t(void)
-{
-    return get_free_thing(&request_pool);
-}
-
-void *
-get_free_mem_obj(void)
-{
-    return get_free_thing(&mem_obj_pool);
-}
-
-char *
-get_free_4k_page(void)
-{
-    return (char *) get_free_thing(&sm_stats);
-}
-
-char *
-get_free_8k_page(void)
-{
-    return (char *) get_free_thing(&disk_stats);
-}
-
-static void
-put_free_thing(stmem_stats * thing, void *p)
-{
-    assert(p != NULL);
-    thing->n_pages_in_use--;
-    if (thing->total_pages_allocated > thing->max_pages) {
-	xfree(p);
-	thing->total_pages_allocated--;
-    } else if (full_stack(&thing->free_page_stack)) {
-	xfree(p);
-	thing->total_pages_allocated--;
-    } else {
-	push(&thing->free_page_stack, p);
-    }
-}
-
-void
-put_free_request_t(void *req)
-{
-    put_free_thing(&request_pool, req);
-}
-
-void
-put_free_mem_obj(void *mem)
-{
-    put_free_thing(&mem_obj_pool, mem);
-}
-
-void
-put_free_4k_page(void *page)
-{
-    put_free_thing(&sm_stats, page);
-}
-
-void
-put_free_8k_page(void *page)
-{
-    put_free_thing(&disk_stats, page);
-}
-
-void
-stmemInit(void)
-{
-    sm_stats.page_size = SM_PAGE_SIZE;
-    sm_stats.total_pages_allocated = 0;
-    sm_stats.n_pages_in_use = 0;
-    sm_stats.max_pages = Config.Mem.maxSize / SM_PAGE_SIZE;
-
-    disk_stats.page_size = DISK_PAGE_SIZE;
-    disk_stats.total_pages_allocated = 0;
-    disk_stats.n_pages_in_use = 0;
-    disk_stats.max_pages = 200;
-
-    request_pool.page_size = sizeof(request_t);
-    request_pool.total_pages_allocated = 0;
-    request_pool.n_pages_in_use = 0;
-    request_pool.max_pages = Squid_MaxFD >> 3;
-
-    mem_obj_pool.page_size = sizeof(MemObject);
-    mem_obj_pool.total_pages_allocated = 0;
-    mem_obj_pool.n_pages_in_use = 0;
-    mem_obj_pool.max_pages = Squid_MaxFD >> 3;
-
-#if PURIFY
-    debug(19, 0) ("Disabling stacks under purify\n");
-    sm_stats.max_pages = 0;
-    disk_stats.max_pages = 0;
-    request_pool.max_pages = 0;
-    mem_obj_pool.max_pages = 0;
-#endif
-    if (!opt_mem_pools) {
-	sm_stats.max_pages = 0;
-	disk_stats.max_pages = 0;
-	request_pool.max_pages = 0;
-	mem_obj_pool.max_pages = 0;
-    }
-    init_stack(&sm_stats.free_page_stack, sm_stats.max_pages);
-    init_stack(&disk_stats.free_page_stack, disk_stats.max_pages);
-    init_stack(&request_pool.free_page_stack, request_pool.max_pages);
-    init_stack(&mem_obj_pool.free_page_stack, mem_obj_pool.max_pages);
-}
-
-static void
-stmemFreeThingMemory(stmem_stats * thing)
-{
-    void *p;
-    while (!empty_stack(&thing->free_page_stack)) {
-	p = pop(&thing->free_page_stack);
-	safe_free(p);
-    }
-    stackFreeMemory(&thing->free_page_stack);
-}
-
-void
-stmemFreeMemory(void)
-{
-    stmemFreeThingMemory(&sm_stats);
-    stmemFreeThingMemory(&disk_stats);
-    stmemFreeThingMemory(&request_pool);
-    stmemFreeThingMemory(&mem_obj_pool);
-}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.365 1998/01/10 07:50:38 kostas Exp $
+ * $Id: store.cc,v 1.366 1998/01/12 04:30:13 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -241,7 +241,6 @@ static int storeEntryValidLength(const StoreEntry *);
 static void storeGetMemSpace(int);
 static void storeHashDelete(StoreEntry *);
 static VCB storeSwapInValidateComplete;
-static mem_hdr *new_MemObjectData(void);
 static MemObject *new_MemObject(const char *, const char *);
 static StoreEntry *new_StoreEntry(int, const char *, const char *);
 static StoreEntry *storeAddDiskRestore(const cache_key *,
@@ -323,17 +322,15 @@ static int store_maintain_buckets;
 static MemObject *
 new_MemObject(const char *url, const char *log_url)
 {
-    MemObject *mem = get_free_mem_obj();
-    mem->reply = xcalloc(1, sizeof(struct _http_reply));
+    MemObject *mem = memAllocate(MEM_MEMOBJECT, 1);
+    mem->reply = memAllocate(MEM_HTTP_REPLY, 1);
     mem->reply->date = -2;
     mem->reply->expires = -2;
     mem->reply->last_modified = -2;
     mem->reply->content_length = -1;
     mem->url = xstrdup(url);
     mem->log_url = xstrdup(log_url);
     mem->swapout.fd = -1;
-    meta_data.mem_obj_count++;
-    meta_data.misc += sizeof(struct _http_reply);
     meta_data.misc += strlen(log_url);
     debug(20, 3) ("new_MemObject: returning %p\n", mem);
     return mem;
@@ -343,8 +340,7 @@ static StoreEntry *
 new_StoreEntry(int mem_obj_flag, const char *url, const char *log_url)
 {
     StoreEntry *e = NULL;
-    e = xcalloc(1, sizeof(StoreEntry));
-    meta_data.store_entries++;
+    e = memAllocate(MEM_STOREENTRY, 1);
     if (mem_obj_flag)
 	e->mem_obj = new_MemObject(url, log_url);
     debug(20, 3) ("new_StoreEntry: returning %p\n", e);
@@ -360,14 +356,12 @@ destroy_MemObject(MemObject * mem)
     meta_data.misc -= strlen(mem->log_url);
     assert(mem->clients == NULL);
     safe_free(mem->swapout.meta_buf);
-    safe_free(mem->reply);
+    memFree(MEM_HTTP_REPLY, mem->reply);
     safe_free(mem->url);
     safe_free(mem->log_url);
     requestUnlink(mem->request);
     mem->request = NULL;
-    put_free_mem_obj(mem);
-    meta_data.mem_obj_count--;
-    meta_data.misc -= sizeof(struct _http_reply);
+    memFree(MEM_MEMOBJECT, mem);
 }
 
 static void
@@ -380,15 +374,6 @@ destroy_StoreEntry(StoreEntry * e)
     storeHashDelete(e);
     assert(e->key == NULL);
     xfree(e);
-    meta_data.store_entries--;
-}
-
-static mem_hdr *
-new_MemObjectData(void)
-{
-    debug(20, 3) ("new_MemObjectData: calling memInit()\n");
-    meta_data.mem_data_count++;
-    return memInit();
 }
 
 static void
@@ -397,9 +382,8 @@ destroy_MemObjectData(MemObject * mem)
     debug(20, 3) ("destroy_MemObjectData: destroying %p, %d bytes\n",
 	mem->data, mem->inmem_hi);
     if (mem->data) {
-	memFree(mem->data);
+	stmemFree(mem->data);
 	mem->data = NULL;
-	meta_data.mem_data_count--;
     }
     mem->inmem_hi = 0;
 }
@@ -621,7 +605,7 @@ storeCreateEntry(const char *url, const char *log_url, int flags, method_t metho
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->swap_status = SWAPOUT_NONE;
     e->swap_file_number = -1;
-    mem->data = new_MemObjectData();
+    mem->data = memAllocate(MEM_MEM_HDR, 1);
     e->refcount = 0;
     e->lastref = squid_curtime;
     e->timestamp = 0;		/* set in storeTimestampsSet() */
@@ -901,13 +885,13 @@ storeCheckSwapOut(StoreEntry * e)
     new_mem_lo = lowest_offset;
     if (!EBIT_TEST(e->flag, ENTRY_CACHABLE)) {
 	assert(EBIT_TEST(e->flag, KEY_PRIVATE));
-	memFreeDataUpto(mem->data, new_mem_lo);
+	stmemFreeDataUpto(mem->data, new_mem_lo);
 	mem->inmem_lo = new_mem_lo;
 	return;
     }
     if (mem->swapout.queue_offset < new_mem_lo)
 	new_mem_lo = mem->swapout.queue_offset;
-    memFreeDataUpto(mem->data, new_mem_lo);
+    stmemFreeDataUpto(mem->data, new_mem_lo);
     mem->inmem_lo = new_mem_lo;
 
     swapout_size = (size_t) (mem->inmem_hi - mem->swapout.queue_offset);
@@ -929,27 +913,26 @@ storeCheckSwapOut(StoreEntry * e)
     if (e->swap_status == SWAPOUT_OPENING)
 	return;
     assert(mem->swapout.fd > -1);
-
-    swap_buf = get_free_8k_page();
+    swap_buf = memAllocate(MEM_DISK_BUF, 1);
     if (mem->swapout.queue_offset==0) 
 	hdr_len= storeBuildMetaData(e, swap_buf);
 
     if (swapout_size > SWAP_BUF - hdr_len)
 	swapout_size = SWAP_BUF - hdr_len;
     
-    swap_buf_len = memCopy(mem->data,
+    swap_buf_len = stmemCopy(mem->data,
 	mem->swapout.queue_offset,
 	swap_buf+hdr_len,
 	swapout_size) + hdr_len;
 
     if (swap_buf_len < 0) {
-	debug(20, 1) ("memCopy returned %d for '%s'\n", swap_buf_len, storeKeyText(e->key));
+	debug(20, 1) ("stmemCopy returned %d for '%s'\n", swap_buf_len, storeKeyText(e->key));
 	/* XXX This is probably wrong--we should storeRelease()? */
 	storeDirMapBitReset(e->swap_file_number);
 	safeunlink(storeSwapFullPath(e->swap_file_number, NULL), 1);
 	e->swap_file_number = -1;
 	e->swap_status = SWAPOUT_NONE;
-	put_free_8k_page(swap_buf);
+	memFree(MEM_DISK_BUF, swap_buf);
 	storeSwapOutFileClose(e);
 	return;
     }
@@ -963,7 +946,7 @@ storeCheckSwapOut(StoreEntry * e)
 	swap_buf_len,
 	storeSwapOutHandle,
 	e,
-	put_free_8k_page);
+	memFreeDISK);
     assert(x == DISK_OK);
 }
 
@@ -979,7 +962,7 @@ storeAppend(StoreEntry * e, const char *buf, int len)
 	    len,
 	    storeKeyText(e->key));
 	storeGetMemSpace(len);
-	memAppend(mem->data, buf, len);
+	stmemAppend(mem->data, buf, len);
 	mem->inmem_hi += len;
     }
     if (EBIT_TEST(e->flag, DELAY_SENDING))
@@ -1313,7 +1296,7 @@ storeCleanup(void *datanotused)
 	storeValidate(e, storeCleanupComplete, e);
 	if ((++validnum & 0xFFF) == 0)
 	    debug(20, 1) ("  %7d Entries Validated so far.\n", validnum);
-	assert(validnum <= meta_data.store_entries);
+	assert(validnum <= memInUse(MEM_STOREENTRY));
     }
     storeKeyFree(curr->key);
     xfree(curr);
@@ -1412,7 +1395,7 @@ storeRebuiltFromDisk(struct storeRebuildState *data)
 	debug(20, 1) ("  store_swap_size = %dk\n", store_swap_size);
 	store_rebuilding = 0;
     }
-    safe_free(data->line_in);
+    memFree(MEM_4K_BUF, data->line_in);
     safe_free(data);
 }
 
@@ -1555,7 +1538,7 @@ storeGetMemSpace(int size)
 	return;
     last_check = squid_curtime;
     pages_needed = (size / SM_PAGE_SIZE) + 1;
-    if (sm_stats.n_pages_in_use + pages_needed < store_pages_high)
+    if (memInUse(MEM_STMEM_BUF) + pages_needed < store_pages_high)
 	return;
     if (store_rebuilding)
 	return;
@@ -1567,7 +1550,7 @@ storeGetMemSpace(int size)
 	    continue;
 	released++;
 	storeRelease(e);
-	if (sm_stats.n_pages_in_use + pages_needed < store_pages_low)
+	if (memInUse(MEM_STMEM_BUF) + pages_needed < store_pages_low)
 	    break;
     }
     debug(20, 3) ("storeGetMemSpace stats:\n");
@@ -1625,7 +1608,7 @@ storeMaintainSwapSpace(void *datanotused)
 	    break;
     }
     debug(20, 3) ("storeMaintainSwapSpace stats:\n");
-    debug(20, 3) ("  %6d objects\n", meta_data.store_entries);
+    debug(20, 3) ("  %6d objects\n", memInUse(MEM_STOREENTRY));
     debug(20, 3) ("  %6d were scanned\n", scanned);
     debug(20, 3) ("  %6d were locked\n", locked);
     debug(20, 3) ("  %6d were expired\n", expired);
@@ -1725,8 +1708,8 @@ storeClientListAdd(StoreEntry * e, void *data)
     if (storeClientListSearch(mem, data) != NULL)
 	return;
     mem->nclients++;
-    sc = xcalloc(1, sizeof(store_client));
-    cbdataAdd(sc);		/* sc is callback_data for file_read */
+    sc = memAllocate(MEM_STORE_CLIENT, 1);
+    cbdataAdd(sc, MEM_STORE_CLIENT);	/* sc is callback_data for file_read */
     sc->callback_data = data;
     sc->seen_offset = 0;
     sc->copy_offset = 0;
@@ -1797,7 +1780,7 @@ storeClientCopy2(StoreEntry * e, store_client * sc)
     } else if (sc->copy_offset >= mem->inmem_lo && mem->inmem_lo < mem->inmem_hi) {
 	/* What the client wants is in memory */
 	debug(20, 3) ("storeClientCopy2: Copying from memory\n");
-	sz = memCopy(mem->data, sc->copy_offset, sc->copy_buf, sc->copy_size);
+	sz = stmemCopy(mem->data, sc->copy_offset, sc->copy_buf, sc->copy_size);
 	sc->callback = NULL;
 	callback(sc->callback_data, sc->copy_buf, sz);
     } else if (sc->swapin_fd < 0) {
@@ -2299,9 +2282,9 @@ storeFreeMemory(void)
     StoreEntry **list;
     int i = 0;
     int j;
-    list = xcalloc(meta_data.store_entries, sizeof(StoreEntry *));
+    list = xcalloc(memInUse(MEM_STOREENTRY), sizeof(StoreEntry *));
     e = (StoreEntry *) hash_first(store_table);
-    while (e && i < meta_data.store_entries) {
+    while (e && i < memInUse(MEM_STOREENTRY)) {
 	*(list + i) = e;
 	i++;
 	e = (StoreEntry *) hash_next(store_table);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir.cc,v 1.39 1998/01/06 07:11:56 wessels Exp $
+ * $Id: store_dir.cc,v 1.40 1998/01/12 04:30:14 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -421,9 +421,12 @@ storeDirStats(StoreEntry * sentry)
     int i;
     SwapDir *SD;
     storeAppendPrintf(sentry, "Store Directory Statistics:\n");
-    storeAppendPrintf(sentry, "Store Entries          : %d\n", meta_data.store_entries);
-    storeAppendPrintf(sentry, "Maximum Swap Size      : %8d KB\n", Config.Swap.maxSize);
-    storeAppendPrintf(sentry, "Current Store Swap Size: %8d KB\n", store_swap_size);
+    storeAppendPrintf(sentry, "Store Entries          : %d\n",
+	memInUse(MEM_STOREENTRY));
+    storeAppendPrintf(sentry, "Maximum Swap Size      : %8d KB\n",
+	Config.Swap.maxSize);
+    storeAppendPrintf(sentry, "Current Store Swap Size: %8d KB\n",
+	store_swap_size);
     storeAppendPrintf(sentry, "Current Capacity       : %d%% used, %d%% free\n",
 	percent((int) store_swap_size, (int) Config.Swap.maxSize),
 	percent((int) (Config.Swap.maxSize - store_swap_size), (int) Config.Swap.maxSize));
@@ -287,6 +287,7 @@ struct _SquidConfig {
 	int log_fqdn;
 	int announce;
 	int accel_with_proxy;
+	int mem_pools;
     } onoff;
     struct _acl *aclList;
     struct {
@@ -761,9 +762,6 @@ struct _proto_stat {
 
 struct _Meta_data {
     int hot_vm;
-    int store_entries;
-    int mem_obj_count;
-    int mem_data_count;
     int ipcache_count;
     int fqdncache_count;
     int netdb_addrs;
@@ -806,15 +804,6 @@ struct _mem_hdr {
     int origin_offset;
 };
 
-/* Memory allocator routines for fixed size blocks */
-struct _stmem_stats {
-    int max_pages;
-    int total_pages_allocated;
-    size_t page_size;
-    int n_pages_in_use;
-    Stack free_page_stack;
-};
-
 /* keep track each client receiving data from that particular StoreEntry */
 struct _store_client {
     int type;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.72 1997/11/14 17:21:23 wessels Exp $
+ * $Id: tunnel.cc,v 1.73 1998/01/12 04:30:11 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -368,7 +368,7 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr)
 	return;
     }
     sslState = xcalloc(1, sizeof(SslStateData));
-    cbdataAdd(sslState);
+    cbdataAdd(sslState, MEM_NONE);
     sslState->url = xstrdup(url);
     sslState->request = requestLink(request);
     sslState->size_ptr = size_ptr;
@@ -54,14 +54,12 @@ typedef struct _HierarchyLogEntry HierarchyLogEntry;
 typedef struct _pingerEchoData pingerEchoData;
 typedef struct _pingerReplyData pingerReplyData;
 typedef struct _icp_common_t icp_common_t;
-typedef struct _Stack Stack;
 typedef struct _proto_stat proto_stat;
 typedef struct _Meta_data Meta_data;
 typedef struct _cacheinfo cacheinfo;
 typedef struct _iostats iostats;
 typedef struct _mem_node mem_node;
 typedef struct _mem_hdr mem_hdr;
-typedef struct _stmem_stats stmem_stats;
 typedef struct _store_client store_client;
 typedef struct _MemObject MemObject;
 typedef struct _StoreEntry StoreEntry;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.73 1998/01/01 19:35:13 wessels Exp $
+ * $Id: url.cc,v 1.74 1998/01/12 04:30:16 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -272,7 +272,7 @@ urlParse(method_t method, char *url)
 	    *t = '\0';
     }
 #endif
-    request = get_free_request_t();
+    request = memAllocate(MEM_REQUEST_T, 1);
     request->method = method;
     request->protocol = protocol;
     xstrncpy(request->host, host, SQUIDHOSTNAMELEN);
@@ -289,7 +289,7 @@ urnParse(method_t method, char *urn)
 {
     request_t *request = NULL;
     debug(50, 5) ("urnParse: %s\n", urn);
-    request = get_free_request_t();
+    request = memAllocate(MEM_REQUEST_T, 1);
     request->method = method;
     request->protocol = PROTO_URN;
     xstrncpy(request->urlpath, &urn[4], MAX_URL);
@@ -374,7 +374,7 @@ urlClean(char *dirty)
     if (r == NULL)
 	return dirty;
     clean = urlCanonicalClean(r);
-    put_free_request_t(r);
+    memFree(MEM_REQUEST_T, r);
     return clean;
 }
 
@@ -396,7 +396,7 @@ requestUnlink(request_t * request)
 	return;
     safe_free(request->headers);
     safe_free(request->body);
-    put_free_request_t(request);
+    memFree(MEM_REQUEST_T, request);
 }
 
 int
@@ -63,7 +63,7 @@ urnFindMinRtt(wordlist * urls, method_t m, int *rtt_ret)
 	if (rtt == 0) {
 	    debug(50, 3) ("Pinging %s\n", r->host);
 	    netdbPingSite(r->host);
-	    put_free_request_t(r);
+	    memFree(MEM_REQUEST_T, r);
 	    continue;
 	}
 	debug(50, 3) ("%s rtt=%d\n", r->host, rtt);
@@ -73,7 +73,7 @@ urnFindMinRtt(wordlist * urls, method_t m, int *rtt_ret)
 	    continue;
 	min_rtt = rtt;
 	min_w = w;
-	put_free_request_t(r);
+	memFree(MEM_REQUEST_T, r);
     }
     if (rtt_ret)
 	*rtt_ret = min_rtt;
@@ -97,7 +97,7 @@ urnStart(request_t * r, StoreEntry * e)
     urnState = xcalloc(1, sizeof(UrnState));
     urnState->entry = e;
     urnState->request = requestLink(r);
-    cbdataAdd(urnState);
+    cbdataAdd(urnState, MEM_NONE);
     storeLockObject(urnState->entry);
     if (strncasecmp(r->urlpath, "menu.", 5) == 0) {
 	EBIT_SET(urnState->flags, URN_FORCE_MENU);
@@ -131,7 +131,7 @@ urnStart(request_t * r, StoreEntry * e)
 	0,
 	0,
 	4096,
-	get_free_4k_page(),
+	memAllocate(MEM_4K_BUF, 1),
 	urnHandleReply,
 	urnState);
 }
@@ -156,14 +156,14 @@ urnHandleReply(void *data, char *buf, ssize_t size)
 
     debug(50, 3) ("urnHandleReply: Called with size=%d.\n", size);
     if (urlres_e->store_status == STORE_ABORTED) {
-	put_free_4k_page(buf);
+	memFree(MEM_4K_BUF, buf);
 	return;
     }
     if (size == 0) {
-	put_free_4k_page(buf);
+	memFree(MEM_4K_BUF, buf);
 	return;
     } else if (size < 0) {
-	put_free_4k_page(buf);
+	memFree(MEM_4K_BUF, buf);
 	return;
     }
     if (urlres_e->store_status == STORE_PENDING) {
@@ -250,7 +250,7 @@ urnHandleReply(void *data, char *buf, ssize_t size)
     storeAppend(e, "\r\n", 2);
     storeAppend(e, S->buf, stringLength(S));
     storeComplete(e);
-    put_free_4k_page(buf);
+    memFree(MEM_4K_BUF, buf);
     wordlistDestroy(&urls);
     stringFree(S);
     storeUnregister(urlres_e, urnState);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.99 1997/12/03 09:00:20 wessels Exp $
+ * $Id: wais.cc,v 1.100 1998/01/12 04:30:17 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -306,7 +306,7 @@ waisStart(request_t * request, StoreEntry * entry)
 	return;
     }
     waisState = xcalloc(1, sizeof(WaisStateData));
-    cbdataAdd(waisState);
+    cbdataAdd(waisState, MEM_NONE);
     waisState->method = method;
     waisState->relayhost = Config.Wais.relayHost;
     waisState->relayport = Config.Wais.relayPort;