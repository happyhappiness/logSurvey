@@ -1,3 +1,15 @@
+Changes to squid-4.0.18 (06 Feb 2017):
+
+	- Bug 4661: compile error 'warning: _XPG4_2 redefined' with GCC on Solaris 10
+	- Bug 4636: assertion 'byteCount > 0 && byteCount <= inBuf.length()'
+	- Bug 4610 partial: compile errors on Solaris 11.3 with Oracle Studio 12.5
+	- Bug 4599: support OpenSSL 1.1
+	- squidclient: link GnuTLS library debugs to -v level display
+	- Fix GCC6: unused local variable 'weInitiatedThisClosure'
+	- ... and some code polishing
+	- ... and some copyright updates
+	- ... and all fixes from 3.5.24
+
 Changes to squid-4.0.17 (16 Dec 2016):
 
 	- Bug 4630: user credentials cache cleanup not re-scheduled
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 4.0.17 release notes</title>
+<title>Squid 4.0.18 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -12,7 +12,7 @@ for Applied Network Research and members of the Web Caching community.
 <toc>
 
 <sect>Notice
-<p>The Squid Team are pleased to announce the release of Squid-4.0.17 for testing.
+<p>The Squid Team are pleased to announce the release of Squid-4.0.18 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v4/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+
+#if USE_DELAY_POOLS
+
+#include "BandwidthBucket.h"
+#include "ClientInfo.h"
+#include "comm/Connection.h"
+#include "Debug.h"
+#include "fde.h"
+
+BandwidthBucket::BandwidthBucket(const int speed, const int initialLevelPercent, const double sizeLimit) :
+    bucketLevel( sizeLimit * (initialLevelPercent / 100.0)),
+    selectWaiting(false),
+    writeSpeedLimit(speed),
+    bucketSizeLimit(sizeLimit)
+{
+    getCurrentTime();
+    /* put current time to have something sensible here */
+    prevTime = current_dtime;
+}
+
+void
+BandwidthBucket::refillBucket()
+{
+    if (noLimit())
+        return;
+    // all these times are in seconds, with double precision
+    const double currTime = current_dtime;
+    const double timePassed = currTime - prevTime;
+
+    // Calculate allowance for the time passed. Use double to avoid
+    // accumulating rounding errors for small intervals. For example, always
+    // adding 1 byte instead of 1.4 results in 29% bandwidth allocation error.
+    const double gain = timePassed * writeSpeedLimit;
+
+    // to further combat error accumulation during micro updates,
+    // quit before updating time if we cannot add at least one byte
+    if (gain < 1.0)
+        return;
+
+    prevTime = currTime;
+
+    // for "first" connections, drain initial fat before refilling but keep
+    // updating prevTime to avoid bursts after the fat is gone
+    if (bucketLevel > bucketSizeLimit) {
+        debugs(77, 4, "not refilling while draining initial fat");
+        return;
+    }
+
+    bucketLevel += gain;
+
+    // obey quota limits
+    if (bucketLevel > bucketSizeLimit)
+        bucketLevel = bucketSizeLimit;
+}
+
+bool
+BandwidthBucket::applyQuota(int &nleft, Comm::IoCallback *state)
+{
+    const int q = quota();
+    if (!q)
+        return false;
+    else if (q < 0)
+        return true;
+    const int nleft_corrected = min(nleft, q);
+    if (nleft != nleft_corrected) {
+        debugs(77, 5, state->conn << " writes only " <<
+               nleft_corrected << " out of " << nleft);
+        nleft = nleft_corrected;
+    }
+    return true;
+}
+
+void
+BandwidthBucket::reduceBucket(const int len)
+{
+    if (len <= 0 || noLimit())
+        return;
+    bucketLevel -= len;
+    if (bucketLevel < 0.0) {
+        debugs(77, DBG_IMPORTANT, "drained too much"); // should not happen
+        bucketLevel = 0;
+    }
+}
+
+BandwidthBucket *
+BandwidthBucket::SelectBucket(fde *f)
+{
+    BandwidthBucket *bucket = f->writeQuotaHandler.getRaw();
+    if (!bucket) {
+        ClientInfo *clientInfo = f->clientInfo;
+        if (clientInfo && clientInfo->writeLimitingActive)
+            bucket = clientInfo;
+    }
+    return bucket;
+}
+
+#endif /* USE_DELAY_POOLS */
+
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef BANDWIDTHBUCKET_H
+#define BANDWIDTHBUCKET_H
+
+#if USE_DELAY_POOLS
+
+#include "comm/IoCallback.h"
+
+class fde;
+
+/// Base class for Squid-to-client bandwidth limiting
+class BandwidthBucket
+{
+public:
+    BandwidthBucket(const int speed, const int initialLevelPercent, const double sizeLimit);
+    virtual ~BandwidthBucket() {}
+
+    static BandwidthBucket *SelectBucket(fde *f);
+
+    /// \returns the number of bytes this bucket allows to write,
+    /// also considering aggregates, if any. Negative quota means
+    /// no limitations by this bucket.
+    virtual int quota() = 0;
+    /// Adjusts nleft to not exceed the current bucket quota value,
+    /// if needed.
+    virtual bool applyQuota(int &nleft, Comm::IoCallback *state);
+    /// Will plan another write call.
+    virtual void scheduleWrite(Comm::IoCallback *state) = 0;
+    /// Performs cleanup when the related file descriptor becomes closed.
+    virtual void onFdClosed() { selectWaiting = false; }
+    /// Decreases the bucket level.
+    virtual void reduceBucket(const int len);
+    /// Whether this bucket will not do bandwidth limiting.
+    bool noLimit() const { return writeSpeedLimit < 0; }
+
+protected:
+    /// Increases the bucket level with the writeSpeedLimit speed.
+    void refillBucket();
+
+public:
+    double bucketLevel; ///< how much can be written now
+    bool selectWaiting; ///< is between commSetSelect and commHandleWrite
+
+protected:
+    double prevTime; ///< previous time when we checked
+    double writeSpeedLimit; ///< Write speed limit in bytes per second.
+    double bucketSizeLimit; ///< maximum bucket size
+};
+
+#endif /* USE_DELAY_POOLS */
+
+#endif
+
@@ -14,6 +14,12 @@
 #include "Parsing.h"
 #include "Store.h"
 
+ClientDelayPool::~ClientDelayPool()
+{
+    if (access)
+        aclDestroyAccessList(&access);
+}
+
 void ClientDelayPool::dump(StoreEntry * entry, unsigned int poolNumberMinusOne) const
 {
     LOCAL_ARRAY(char, nom, 32);
@@ -23,81 +29,85 @@ void ClientDelayPool::dump(StoreEntry * entry, unsigned int poolNumberMinusOne)
     storeAppendPrintf(entry, "\n");
 }
 
+ClientDelayPools *
+ClientDelayPools::Instance()
+{
+    static ClientDelayPools pools;
+    return &pools;
+}
+
+ClientDelayPools::~ClientDelayPools()
+{
+    pools.clear();
+}
+
 void
 ClientDelayConfig::finalize()
 {
-    for (unsigned int i = 0; i < pools.size(); ++i) {
+    for (unsigned int i = 0; i < pools().size(); ++i) {
         /* pools require explicit 'allow' to assign a client into them */
-        if (!pools[i].access) {
-            debugs(77, DBG_IMPORTANT, "client_delay_pool #" << (i+1) <<
+        if (!pool(i).access) {
+            debugs(77, DBG_IMPORTANT, "WARNING: client_delay_pool #" << (i+1) <<
                    " has no client_delay_access configured. " <<
                    "No client will ever use it.");
         }
     }
 }
 
-void ClientDelayConfig::freePoolCount()
+void ClientDelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
 {
-    pools.clear();
+    const auto &pools_ = ClientDelayPools::Instance()->pools;
+    if (pools_.size()) {
+        storeAppendPrintf(entry, "%s %d\n", name, static_cast<int>(pools_.size()));
+        for (unsigned int i = 0; i < pools_.size(); ++i)
+            pools_[i]->dump(entry, i);
+    }
 }
 
-void ClientDelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
+void
+ClientDelayConfig::freePools()
 {
-    if (pools.size()) {
-        storeAppendPrintf(entry, "%s %d\n", name, (int)pools.size());
-        for (unsigned int i = 0; i < pools.size(); ++i)
-            pools[i].dump(entry, i);
-    }
+    pools().clear();
 }
 
 void ClientDelayConfig::parsePoolCount()
 {
-    if (pools.size()) {
-        debugs(3, DBG_CRITICAL, "parse_client_delay_pool_count: multiple client_delay_pools lines, aborting all previous client_delay_pools config");
-        clean();
+    if (pools().size()) {
+        debugs(3, DBG_CRITICAL, "parse_client_delay_pool_count: multiple client_delay_pools lines, " <<
+               "aborting all previous client_delay_pools config");
+        freePools();
     }
     unsigned short pools_;
     ConfigParser::ParseUShort(&pools_);
-    for (int i = 0; i < pools_; ++i) {
-        pools.push_back(ClientDelayPool());
-    }
+    for (int i = 0; i < pools_; ++i)
+        pools().push_back(new ClientDelayPool());
 }
 
 void ClientDelayConfig::parsePoolRates()
 {
-    unsigned short pool;
-    ConfigParser::ParseUShort(&pool);
-
-    if (pool < 1 || pool > pools.size()) {
-        debugs(3, DBG_CRITICAL, "parse_client_delay_pool_rates: Ignoring pool " << pool << " not in 1 .. " << pools.size());
-        return;
+    if (unsigned short poolId = parsePoolId()) {
+        --poolId;
+        pool(poolId).rate = GetInteger();
+        pool(poolId).highwatermark = GetInteger64();
     }
-
-    --pool;
-
-    pools[pool].rate = GetInteger();
-    pools[pool].highwatermark = GetInteger64();
 }
 
 void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
 {
-    unsigned short pool;
-
-    ConfigParser::ParseUShort(&pool);
-
-    if (pool < 1 || pool > pools.size()) {
-        debugs(3, DBG_CRITICAL, "parse_client_delay_pool_rates: Ignoring pool " << pool << " not in 1 .. " << pools.size());
-        return;
-    }
-
-    --pool;
-    aclParseAccessLine("client_delay_access", parser, &pools[pool].access);
+    if (const unsigned short poolId = parsePoolId())
+        aclParseAccessLine("client_delay_access", parser, &(pool(poolId-1).access));
 }
 
-void ClientDelayConfig::clean()
+unsigned short
+ClientDelayConfig::parsePoolId()
 {
-    for (unsigned int i = 0; i < pools.size(); ++i) {
-        aclDestroyAccessList(&pools[i].access);
+    unsigned short poolId = 0;
+    ConfigParser::ParseUShort(&poolId);
+    if (poolId < 1 || poolId > pools().size()) {
+        debugs(3, DBG_CRITICAL, "parse_client_delay_pool_rates: Ignoring pool " <<
+               poolId << " not in 1 .. " << pools().size());
+        return 0;
     }
+    return poolId;
 }
 
@@ -10,6 +10,7 @@
 #define SQUID_CLIENTDELAYCONFIG_H
 
 #include "acl/forward.h"
+#include "base/RefCount.h"
 
 #include <vector>
 
@@ -19,26 +20,46 @@ class ConfigParser;
 /// \ingroup DelayPoolsAPI
 
 /* represents one client write limiting delay 'pool' */
-class ClientDelayPool
+class ClientDelayPool : public RefCountable
 {
 public:
+    typedef RefCount<ClientDelayPool> Pointer;
+
     ClientDelayPool()
-        :   access(NULL), rate(0), highwatermark(0) {}
+        :   access(nullptr), rate(0), highwatermark(0) {}
+    ~ClientDelayPool();
+    ClientDelayPool(const ClientDelayPool &) = delete;
+    ClientDelayPool &operator=(const ClientDelayPool &) = delete;
+
     void dump (StoreEntry * entry, unsigned int poolNumberMinusOne) const;
     acl_access *access;
     int rate;
     int64_t highwatermark;
 };
 
-typedef std::vector<ClientDelayPool> ClientDelayPools;
+class ClientDelayPools
+{
+public:
+    ClientDelayPools(const ClientDelayPools &) = delete;
+    ClientDelayPools &operator=(const ClientDelayPools &) = delete;
+    static ClientDelayPools *Instance();
+
+    std::vector<ClientDelayPool::Pointer> pools;
+private:
+    ClientDelayPools() {}
+    ~ClientDelayPools();
+};
 
 /* represents configuration of client write limiting delay pools */
 class ClientDelayConfig
 {
 public:
     ClientDelayConfig()
         :   initial(50) {}
-    void freePoolCount();
+    ClientDelayConfig(const ClientDelayConfig &) = delete;
+    ClientDelayConfig &operator=(const ClientDelayConfig &) = delete;
+
+    void freePools();
     void dumpPoolCount(StoreEntry * entry, const char *name) const;
     /* parsing of client_delay_pools - number of pools */
     void parsePoolCount();
@@ -51,9 +72,11 @@ class ClientDelayConfig
 
     /* initial bucket level, how fill bucket at startup */
     unsigned short initial;
-    ClientDelayPools pools;
+
 private:
-    void clean();
+    unsigned short parsePoolId();
+    std::vector<ClientDelayPool::Pointer> &pools() { return ClientDelayPools::Instance()->pools; }
+    ClientDelayPool &pool(const int i) { return *(ClientDelayPools::Instance()->pools.at(i)); }
 };
 
 #endif // SQUID_CLIENTDELAYCONFIG_H
@@ -9,6 +9,9 @@
 #ifndef SQUID__SRC_CLIENTINFO_H
 #define SQUID__SRC_CLIENTINFO_H
 
+#if USE_DELAY_POOLS
+#include "BandwidthBucket.h"
+#endif
 #include "base/ByteCounter.h"
 #include "cbdata.h"
 #include "enums.h"
@@ -24,16 +27,17 @@
 class CommQuotaQueue;
 #endif
 
-class ClientInfo
+class ClientInfo : public hash_link
+#if USE_DELAY_POOLS
+    , public BandwidthBucket
+#endif
 {
     MEMPROXY_CLASS(ClientInfo);
 
 public:
     explicit ClientInfo(const Ip::Address &);
     ~ClientInfo();
 
-    hash_link hash;             /* must be first */
-
     Ip::Address addr;
 
     struct Protocol {
@@ -58,17 +62,12 @@ class ClientInfo
     int n_established;          /* number of current established connections */
     time_t last_seen;
 #if USE_DELAY_POOLS
-    double writeSpeedLimit;///< Write speed limit in bytes per second, can be less than 1, if too close to zero this could result in timeouts from client
-    double prevTime; ///< previous time when we checked
-    double bucketSize; ///< how much can be written now
-    double bucketSizeLimit;  ///< maximum bucket size
     bool writeLimitingActive; ///< Is write limiter active
     bool firstTimeConnection;///< is this first time connection for this client
 
     CommQuotaQueue *quotaQueue; ///< clients waiting for more write quota
     int rationedQuota; ///< precomputed quota preserving fairness among clients
     int rationedCount; ///< number of clients that will receive rationedQuota
-    bool selectWaiting; ///< is between commSetSelect and commHandleWrite
     bool eventWaiting; ///< waiting for commHandleWriteHelper event to fire
 
     // all those functions access Comm fd_table and are defined in comm.cc
@@ -79,8 +78,13 @@ class ClientInfo
     unsigned int quotaPeekReserv() const; ///< returns the next reserv. to pop
     void quotaDequeue(); ///< pops queue head from queue
     void kickQuotaQueue(); ///< schedule commHandleWriteHelper call
-    int quotaForDequed(); ///< allocate quota for a just dequeued client
-    void refillBucket(); ///< adds bytes to bucket based on rate and time
+
+    /* BandwidthBucket API */
+    virtual int quota() override; ///< allocate quota for a just dequeued client
+    virtual bool applyQuota(int &nleft, Comm::IoCallback *state) override;
+    virtual void scheduleWrite(Comm::IoCallback *state) override;
+    virtual void onFdClosed() override;
+    virtual void reduceBucket(int len) override;
 
     void quotaDumpQueue(); ///< dumps quota queue for debugging
 
@@ -248,7 +248,7 @@ HttpHeader::needUpdate(HttpHeader const *fresh) const
             continue;
         String value;
         const char *name = e->name.termedBuf();
-        if (!getByNameIfPresent(name, strlen(name), value) ||
+        if (!hasNamed(name, strlen(name), &value) ||
                 (value != fresh->getByName(name)))
             return true;
     }
@@ -870,7 +870,7 @@ HttpHeader::getByName(const char *name) const
 {
     String result;
     // ignore presence: return undefined string if an empty header is present
-    (void)getByNameIfPresent(name, strlen(name), result);
+    (void)hasNamed(name, strlen(name), &result);
     return result;
 }
 
@@ -879,37 +879,38 @@ HttpHeader::getByName(const SBuf &name) const
 {
     String result;
     // ignore presence: return undefined string if an empty header is present
-    (void)getByNameIfPresent(name, result);
+    (void)hasNamed(name, &result);
     return result;
 }
 
 String
 HttpHeader::getById(Http::HdrType id) const
 {
     String result;
-    (void)getByIdIfPresent(id,result);
+    (void)getByIdIfPresent(id, &result);
     return result;
 }
 
 bool
-HttpHeader::getByNameIfPresent(const SBuf &s, String &result) const
+HttpHeader::hasNamed(const SBuf &s, String *result) const
 {
-    return getByNameIfPresent(s.rawContent(), s.length(), result);
+    return hasNamed(s.rawContent(), s.length(), result);
 }
 
 bool
-HttpHeader::getByIdIfPresent(Http::HdrType id, String &result) const
+HttpHeader::getByIdIfPresent(Http::HdrType id, String *result) const
 {
     if (id == Http::HdrType::BAD_HDR)
         return false;
     if (!has(id))
         return false;
-    result = getStrOrList(id);
+    if (result)
+        *result = getStrOrList(id);
     return true;
 }
 
 bool
-HttpHeader::getByNameIfPresent(const char *name, int namelen, String &result) const
+HttpHeader::hasNamed(const char *name, int namelen, String *result) const
 {
     Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -930,7 +931,9 @@ HttpHeader::getByNameIfPresent(const char *name, int namelen, String &result) co
     while ((e = getEntry(&pos))) {
         if (e->id == Http::HdrType::OTHER && e->name.size() == static_cast<String::size_type>(namelen) && e->name.caseCmp(name, namelen) == 0) {
             found = true;
-            strListAdd(&result, e->value.termedBuf(), ',');
+            if (!result)
+                break;
+            strListAdd(result, e->value.termedBuf(), ',');
         }
     }
 
@@ -105,11 +105,13 @@ class HttpHeader
     String getByName(const SBuf &name) const;
     String getByName(const char *name) const;
     String getById(Http::HdrType id) const;
-    /// sets value and returns true iff a [possibly empty] field identified by id is there
-    bool getByIdIfPresent(Http::HdrType id, String &result) const;
-    /// sets value and returns true iff a [possibly empty] named field is there
-    bool getByNameIfPresent(const SBuf &s, String &value) const;
-    bool getByNameIfPresent(const char *name, int namelen, String &value) const;
+    /// returns true iff a [possibly empty] field identified by id is there
+    /// when returning true, also sets the `result` parameter (if it is not nil)
+    bool getByIdIfPresent(Http::HdrType id, String *result) const;
+    /// returns true iff a [possibly empty] named field is there
+    /// when returning true, also sets the `value` parameter (if it is not nil)
+    bool hasNamed(const SBuf &s, String *value = 0) const;
+    bool hasNamed(const char *name, int namelen, String *value = 0) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(Http::HdrType id, const char *member, const char separator) const;
     int has(Http::HdrType id) const;
@@ -25,7 +25,7 @@
 #include "Store.h"
 #include "StrList.h"
 
-HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
+HttpReply::HttpReply() : Http::Message(hoReply), date (0), last_modified (0),
     expires (0), surrogate_control (NULL), content_range (NULL), keep_alive (0),
     protoPrefix("HTTP/"), bodySizeMax(-2)
 {
@@ -43,7 +43,7 @@ HttpReply::init()
 {
     hdrCacheInit();
     sline.init();
-    pstate = psReadyToParseStartLine;
+    pstate = Http::Message::psReadyToParseStartLine;
     do_clean = true;
 }
 
@@ -308,7 +308,7 @@ HttpReply::hdrExpirationTime()
 void
 HttpReply::hdrCacheInit()
 {
-    HttpMsg::hdrCacheInit();
+    Http::Message::hdrCacheInit();
 
     http_ver = sline.version;
     content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
@@ -443,7 +443,7 @@ HttpReply::parseFirstLine(const char *blk_start, const char *blk_end)
 int
 HttpReply::httpMsgParseError()
 {
-    int result(HttpMsg::httpMsgParseError());
+    int result(Http::Message::httpMsgParseError());
     /* indicate an error in the status line */
     sline.set(Http::ProtocolVersion(), Http::scInvalidHeader);
     return result;
@@ -553,7 +553,8 @@ HttpReply::clone() const
     return rep;
 }
 
-bool HttpReply::inheritProperties(const HttpMsg *aMsg)
+bool
+HttpReply::inheritProperties(const Http::Message *aMsg)
 {
     const HttpReply *aRep = dynamic_cast<const HttpReply*>(aMsg);
     if (!aRep)
@@ -11,7 +11,6 @@
 
 #include "http/StatusLine.h"
 #include "HttpBody.h"
-#include "HttpMsg.h"
 #include "HttpRequest.h"
 
 void httpReplyInitModule(void);
@@ -22,7 +21,7 @@ class HttpHdrContRange;
 
 class HttpHdrSc;
 
-class HttpReply: public HttpMsg
+class HttpReply: public Http::Message
 {
     MEMPROXY_CLASS(HttpReply);
 
@@ -70,7 +69,7 @@ class HttpReply: public HttpMsg
 
     virtual bool expectingBody(const HttpRequestMethod&, int64_t&) const;
 
-    virtual bool inheritProperties(const HttpMsg *aMsg);
+    virtual bool inheritProperties(const Http::Message *);
 
     bool updateOnNotModified(HttpReply const *other);
 
@@ -39,13 +39,13 @@
 #endif
 
 HttpRequest::HttpRequest() :
-    HttpMsg(hoRequest)
+    Http::Message(hoRequest)
 {
     init();
 }
 
 HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aSchemeImg, const char *aUrlpath) :
-    HttpMsg(hoRequest)
+    Http::Message(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
@@ -99,7 +99,7 @@ HttpRequest::init()
 #endif
     extacl_log = null_string;
     extacl_message = null_string;
-    pstate = psReadyToParseStartLine;
+    pstate = Http::Message::psReadyToParseStartLine;
 #if FOLLOW_X_FORWARDED_FOR
     indirect_client_addr.setEmpty();
 #endif /* FOLLOW_X_FORWARDED_FOR */
@@ -207,7 +207,7 @@ HttpRequest::clone() const
 }
 
 bool
-HttpRequest::inheritProperties(const HttpMsg *aMsg)
+HttpRequest::inheritProperties(const Http::Message *aMsg)
 {
     const HttpRequest* aReq = dynamic_cast<const HttpRequest*>(aMsg);
     if (!aReq)
@@ -386,7 +386,7 @@ HttpRequest::prefixLen() const
 void
 HttpRequest::hdrCacheInit()
 {
-    HttpMsg::hdrCacheInit();
+    Http::Message::hdrCacheInit();
 
     assert(!range);
     range = header.getRange();
@@ -13,8 +13,8 @@
 #include "dns/forward.h"
 #include "err_type.h"
 #include "HierarchyLogEntry.h"
+#include "http/Message.h"
 #include "http/RequestMethod.h"
-#include "HttpMsg.h"
 #include "Notes.h"
 #include "RequestFlags.h"
 #include "URL.h"
@@ -41,7 +41,7 @@ void httpRequestPack(void *obj, Packable *p);
 
 class HttpHdrRange;
 
-class HttpRequest: public HttpMsg
+class HttpRequest: public Http::Message
 {
     MEMPROXY_CLASS(HttpRequest);
 
@@ -236,7 +236,7 @@ class HttpRequest: public HttpMsg
 
     virtual void hdrCacheInit();
 
-    virtual bool inheritProperties(const HttpMsg *aMsg);
+    virtual bool inheritProperties(const Http::Message *);
 };
 
 class ConnStateData;
@@ -88,6 +88,8 @@ endif
 DIST_SUBDIRS += esi
 
 DELAY_POOL_ALL_SOURCE = \
+	BandwidthBucket.cc \
+	BandwidthBucket.h \
 	CommonPool.h \
 	CompositePoolNode.h \
 	delay_pools.cc \
@@ -109,6 +111,10 @@ DELAY_POOL_ALL_SOURCE = \
 	DelayUser.h \
 	DelayVector.cc \
 	DelayVector.h \
+	MessageBucket.cc \
+	MessageBucket.h \
+	MessageDelayPools.h \
+	MessageDelayPools.cc \
 	NullDelayId.h \
 	ClientDelayConfig.cc \
 	ClientDelayConfig.h
@@ -335,8 +341,6 @@ squid_SOURCES = \
 	HttpBody.cc \
 	HttpControlMsg.cc \
 	HttpControlMsg.h \
-	HttpMsg.cc \
-	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
 	RequestFlags.h \
@@ -943,8 +947,6 @@ tests_testHttpReply_SOURCES=\
 	HttpHeaderTools.cc \
 	HttpControlMsg.cc \
 	HttpControlMsg.h \
-	HttpMsg.cc \
-	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
 	MasterXaction.cc \
@@ -1044,7 +1046,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	HttpHdrCc.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
-	HttpMsg.cc \
 	int.h \
 	int.cc \
 	MasterXaction.cc \
@@ -1272,7 +1273,6 @@ tests_testCacheManager_SOURCES = \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	icp_v2.cc \
 	icp_v3.cc \
@@ -1461,7 +1461,6 @@ tests_testDiskIO_SOURCES = \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	int.h \
 	int.cc \
@@ -1691,7 +1690,6 @@ tests_testEvent_SOURCES = \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
@@ -1927,7 +1925,6 @@ tests_testEventLoop_SOURCES = \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
@@ -2158,7 +2155,6 @@ tests_test_http_range_SOURCES = \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
@@ -2473,7 +2469,6 @@ tests_testHttpRequest_SOURCES = \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	icp_v2.cc \
 	icp_v3.cc \
@@ -2707,7 +2702,6 @@ tests_testStore_SOURCES= \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
-	HttpMsg.cc \
 	RequestFlags.cc \
 	RequestFlags.h \
 	int.h \
@@ -2959,7 +2953,6 @@ tests_testUfs_SOURCES = \
 	tests/stub_CacheDigest.cc \
 	ConfigParser.cc \
 	EventLoop.cc \
-	HttpMsg.cc \
 	RemovalPolicy.cc \
 	repl_modules.h \
 	store.cc \
@@ -3116,7 +3109,6 @@ tests_testRock_SOURCES = \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	int.h \
 	int.cc \
@@ -3315,7 +3307,6 @@ tests_testURL_SOURCES = \
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
-	HttpMsg.cc \
 	HttpReply.cc \
 	PeerPoolMgr.h \
 	PeerPoolMgr.cc \
@@ -285,7 +285,7 @@ MemObject::expectedReplySize() const
     if (_reply) {
         const int64_t clen = _reply->bodySize(method);
         debugs(20, 7, HERE << "clen: " << clen);
-        if (clen >= 0 && _reply->hdr_sz > 0) // yuck: HttpMsg sets hdr_sz to 0
+        if (clen >= 0 && _reply->hdr_sz > 0) // yuck: Http::Message sets hdr_sz to 0
             return clen + _reply->hdr_sz;
     }
 
@@ -568,15 +568,15 @@ MemStore::copyFromShmSlice(StoreEntry &e, const StoreIOBuffer &buf, bool eof)
     // from store_client::readBody()
     // parse headers if needed; they might span multiple slices!
     HttpReply *rep = (HttpReply *)e.getReply();
-    if (rep->pstate < psParsed) {
+    if (rep->pstate < Http::Message::psParsed) {
         // XXX: have to copy because httpMsgParseStep() requires 0-termination
         MemBuf mb;
         mb.init(buf.length+1, buf.length+1);
         mb.append(buf.data, buf.length);
         mb.terminate();
         const int result = rep->httpMsgParseStep(mb.buf, buf.length, eof);
         if (result > 0) {
-            assert(rep->pstate == psParsed);
+            assert(rep->pstate == Http::Message::psParsed);
             EBIT_CLR(e.flags, ENTRY_FWD_HDR_WAIT);
         } else if (result < 0) {
             debugs(20, DBG_IMPORTANT, "Corrupted mem-cached headers: " << e);
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+
+#if USE_DELAY_POOLS
+#include "comm/Connection.h"
+#include "DelayPools.h"
+#include "fde.h"
+#include "MessageBucket.h"
+
+MessageBucket::MessageBucket(const int speed, const int initialLevelPercent,
+                             const double sizeLimit, MessageDelayPool::Pointer pool) :
+    BandwidthBucket(speed, initialLevelPercent, sizeLimit),
+    theAggregate(pool) {}
+
+int
+MessageBucket::quota()
+{
+    refillBucket();
+    theAggregate->refillBucket();
+    if (theAggregate->noLimit())
+        return bucketLevel;
+    else if (noLimit())
+        return theAggregate->level();
+    else
+        return min(bucketLevel, static_cast<double>(theAggregate->level()));
+}
+
+void
+MessageBucket::reduceBucket(int len)
+{
+    BandwidthBucket::reduceBucket(len);
+    theAggregate->bytesIn(len);
+}
+
+void
+MessageBucket::scheduleWrite(Comm::IoCallback *state)
+{
+    fde *F = &fd_table[state->conn->fd];
+    if (!F->writeQuotaHandler->selectWaiting) {
+        F->writeQuotaHandler->selectWaiting = true;
+        // message delay pools limit this write; see checkTimeouts()
+        SetSelect(state->conn->fd, COMM_SELECT_WRITE, Comm::HandleWrite, state, 0);
+    }
+}
+
+#endif /* USE_DELAY_POOLS */
+
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef MESSAGEBUCKET_H
+#define MESSAGEBUCKET_H
+
+#if USE_DELAY_POOLS
+
+#include "BandwidthBucket.h"
+#include "base/RefCount.h"
+#include "comm/forward.h"
+#include "MessageDelayPools.h"
+
+/// Limits Squid-to-client bandwidth for each matching response
+class MessageBucket : public RefCountable, public BandwidthBucket
+{
+    MEMPROXY_CLASS(MessageBucket);
+
+public:
+    typedef RefCount<MessageBucket> Pointer;
+
+    MessageBucket(const int speed, const int initialLevelPercent, const double sizeLimit, MessageDelayPool::Pointer pool);
+
+    /* BandwidthBucket API */
+    virtual int quota() override;
+    virtual void scheduleWrite(Comm::IoCallback *state) override;
+    virtual void reduceBucket(int len);
+
+private:
+    MessageDelayPool::Pointer theAggregate;
+};
+
+#endif /* USE_DELAY_POOLS */
+
+#endif
+
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+
+#if USE_DELAY_POOLS
+#include "acl/Gadgets.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "DelaySpec.h"
+#include "event.h"
+#include "MessageBucket.h"
+#include "MessageDelayPools.h"
+#include "Parsing.h"
+#include "SquidTime.h"
+#include "Store.h"
+
+#include <algorithm>
+#include <map>
+
+MessageDelayPools::~MessageDelayPools()
+{
+    freePools();
+}
+
+MessageDelayPools *
+MessageDelayPools::Instance()
+{
+    static MessageDelayPools pools;
+    return &pools;
+}
+
+MessageDelayPool::Pointer
+MessageDelayPools::pool(const SBuf &name)
+{
+    auto it = std::find_if(pools.begin(), pools.end(),
+    [&name](const MessageDelayPool::Pointer p) { return p->poolName == name; });
+    return it == pools.end() ? 0 : *it;
+}
+
+void
+MessageDelayPools::add(MessageDelayPool *p)
+{
+    const auto it = std::find_if(pools.begin(), pools.end(),
+    [&p](const MessageDelayPool::Pointer mp) { return mp->poolName == p->poolName; });
+    if (it != pools.end()) {
+        debugs(3, DBG_CRITICAL, "WARNING: Ignoring duplicate " << p->poolName << " response delay pool");
+        return;
+    }
+    pools.push_back(p);
+}
+
+void
+MessageDelayPools::freePools()
+{
+    pools.clear();
+}
+
+MessageDelayPool::MessageDelayPool(const SBuf &name, int64_t bucketSpeed, int64_t bucketSize,
+                                   int64_t aggregateSpeed, int64_t aggregateSize, uint16_t initialBucketPercent):
+    access(0),
+    poolName(name),
+    individualRestore(bucketSpeed),
+    individualMaximum(bucketSize),
+    aggregateRestore(aggregateSpeed),
+    aggregateMaximum(aggregateSize),
+    initialBucketLevel(initialBucketPercent),
+    lastUpdate(squid_curtime)
+{
+    theBucket.level() = aggregateMaximum;
+}
+
+MessageDelayPool::~MessageDelayPool()
+{
+    if (access)
+        aclDestroyAccessList(&access);
+}
+
+void
+MessageDelayPool::refillBucket()
+{
+    if (noLimit())
+        return;
+    const int incr = squid_curtime - lastUpdate;
+    if (incr >= 1) {
+        lastUpdate = squid_curtime;
+        DelaySpec spec;
+        spec.restore_bps = aggregateRestore;
+        spec.max_bytes = aggregateMaximum;
+        theBucket.update(spec, incr);
+    }
+}
+
+void
+MessageDelayPool::dump(StoreEntry *entry) const
+{
+    SBuf name("response_delay_pool_access ");
+    name.append(poolName);
+    dump_acl_access(entry, name.c_str(), access);
+    storeAppendPrintf(entry, "response_delay_pool parameters %" PRId64 " %" PRId64 " %" PRId64 " %" PRId64 " %d\n",
+                      individualRestore, individualMaximum, aggregateRestore, aggregateMaximum, initialBucketLevel);
+    storeAppendPrintf(entry, "\n");
+}
+
+MessageBucket::Pointer
+MessageDelayPool::createBucket()
+{
+    return new MessageBucket(individualRestore, initialBucketLevel, individualMaximum, this);
+}
+
+void
+MessageDelayConfig::parseResponseDelayPool()
+{
+    static const SBuf bucketSpeedLimit("individual-restore");
+    static const SBuf maxBucketSize("individual-maximum");
+    static const SBuf aggregateSpeedLimit("aggregate-restore");
+    static const SBuf maxAggregateSize("aggregate-maximum");
+    static const SBuf initialBucketPercent("initial-bucket-level");
+
+    static std::map<SBuf, int64_t> params;
+    params[bucketSpeedLimit] = -1;
+    params[maxBucketSize] = -1;
+    params[aggregateSpeedLimit] = -1;
+    params[maxAggregateSize] = -1;
+    params[initialBucketPercent] = 50;
+
+    const SBuf name(ConfigParser::NextToken());
+    if (name.isEmpty()) {
+        debugs(3, DBG_CRITICAL, "FATAL: response_delay_pool missing required \"name\" parameter.");
+        self_destruct();
+    }
+
+    char *key = nullptr;
+    char *value = nullptr;
+    while (ConfigParser::NextKvPair(key, value)) {
+        if (!value) {
+            debugs(3, DBG_CRITICAL, "FATAL: '" << key << "' option missing value");
+            self_destruct();
+        }
+        auto it = params.find(SBuf(key));
+        if (it == params.end()) {
+            debugs(3, DBG_CRITICAL, "FATAL: response_delay_pool unknown option '" << key << "'");
+            self_destruct();
+        }
+        it->second = (it->first == initialBucketPercent) ? xatos(value) : xatoll(value, 10);
+    }
+
+    const char *fatalMsg = nullptr;
+    if ((params[bucketSpeedLimit] < 0) != (params[maxBucketSize] < 0))
+        fatalMsg = "'individual-restore' and 'individual-maximum'";
+    else if ((params[aggregateSpeedLimit] < 0) != (params[maxAggregateSize] < 0))
+        fatalMsg = "'aggregate-restore' and 'aggregate-maximum'";
+
+    if (fatalMsg) {
+        debugs(3, DBG_CRITICAL, "FATAL: must use " << fatalMsg << " options in conjunction");
+        self_destruct();
+    }
+
+    MessageDelayPool *pool = new MessageDelayPool(name,
+            params[bucketSpeedLimit],
+            params[maxBucketSize],
+            params[aggregateSpeedLimit],
+            params[maxAggregateSize],
+            static_cast<uint16_t>(params[initialBucketPercent])
+                                                 );
+    MessageDelayPools::Instance()->add(pool);
+}
+
+void
+MessageDelayConfig::parseResponseDelayPoolAccess() {
+    const char *token = ConfigParser::NextToken();
+    if (!token) {
+        debugs(3, DBG_CRITICAL, "ERROR: required pool_name option missing");
+        return;
+    }
+    MessageDelayPool::Pointer pool = MessageDelayPools::Instance()->pool(SBuf(token));
+    static ConfigParser parser;
+    if (pool)
+        aclParseAccessLine("response_delay_pool_access", parser, &pool->access);
+}
+
+void
+MessageDelayConfig::freePools()
+{
+    MessageDelayPools::Instance()->freePools();
+}
+
+void
+MessageDelayConfig::dumpResponseDelayPoolParameters(StoreEntry *entry, const char *name)
+{
+    auto &pools = MessageDelayPools::Instance()->pools;
+    for (auto pool: pools)
+        pool->dump(entry);
+}
+
+#endif
+
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 1996-2017 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef MESSAGEDELAYPOOLS_H
+#define MESSAGEDELAYPOOLS_H
+
+#if USE_DELAY_POOLS
+
+#include "acl/Acl.h"
+#include "base/RefCount.h"
+#include "DelayBucket.h"
+#include "DelayPools.h"
+
+class MessageBucket;
+typedef RefCount<MessageBucket> MessageBucketPointer;
+
+/// \ingroup DelayPoolsAPI
+/// Represents one 'response' delay pool, creates individual response
+/// buckets and performes aggregate limiting for them
+class MessageDelayPool : public RefCountable
+{
+public:
+    typedef RefCount<MessageDelayPool> Pointer;
+
+    MessageDelayPool(const SBuf &name, int64_t bucketSpeed, int64_t bucketSize,
+                     int64_t aggregateSpeed, int64_t aggregateSize, uint16_t initialBucketPercent);
+    ~MessageDelayPool();
+    MessageDelayPool(const MessageDelayPool &) = delete;
+    MessageDelayPool &operator=(const MessageDelayPool &) = delete;
+
+    /// Increases the aggregate bucket level with the aggregateRestore speed.
+    void refillBucket();
+    /// decreases the aggregate level
+    void bytesIn(int qty) { if (!noLimit()) theBucket.bytesIn(qty); }
+    /// current aggregate level
+    int level() { return theBucket.level(); }
+    /// creates an individual response bucket
+    MessageBucketPointer createBucket();
+    /// whether the aggregate bucket has no limit
+    bool noLimit () const { return aggregateRestore < 0; }
+
+    void dump (StoreEntry * entry) const;
+
+    acl_access *access;
+    /// the response delay pool name
+    SBuf poolName;
+    /// the speed limit of an individual bucket (bytes/s)
+    int64_t individualRestore;
+    /// the maximum size of an individual bucket
+    int64_t individualMaximum;
+    /// the speed limit of the aggregate bucket (bytes/s)
+    int64_t aggregateRestore;
+    /// the maximum size of the aggregate bucket
+    int64_t aggregateMaximum;
+    /// the initial bucket size as a percentage of individualMaximum
+    uint16_t initialBucketLevel;
+    /// the aggregate bucket
+    DelayBucket theBucket;
+
+private:
+    /// Time the aggregate bucket level was last refilled.
+    time_t lastUpdate;
+};
+
+/// \ingroup DelayPoolsAPI
+/// represents all configured 'response' delay pools
+class MessageDelayPools
+{
+public:
+    MessageDelayPools(const MessageDelayPools &) = delete;
+    MessageDelayPools &operator=(const MessageDelayPools &) = delete;
+
+    static MessageDelayPools *Instance();
+
+    /// returns a MessageDelayPool with a given name or null otherwise
+    MessageDelayPool::Pointer pool(const SBuf &name);
+    /// appends a single MessageDelayPool, created during configuration
+    void add(MessageDelayPool *pool);
+    /// memory cleanup, performing during reconfiguration
+    void freePools();
+
+    std::vector<MessageDelayPool::Pointer> pools;
+
+private:
+    MessageDelayPools() {}
+    ~MessageDelayPools();
+    void Stats() { } // TODO
+};
+
+/// represents configuration for response delay pools
+class MessageDelayConfig
+{
+public:
+    void parseResponseDelayPool();
+    void dumpResponseDelayPoolParameters(StoreEntry *e, const char *name);
+    void parseResponseDelayPoolAccess();
+    void freePools();
+};
+
+#define free_response_delay_pool_access(X)
+#define dump_response_delay_pool_access(X, Y, Z)
+
+inline void
+free_response_delay_pool_parameters(MessageDelayConfig * cfg)
+{
+    cfg->freePools();
+}
+
+inline void
+dump_response_delay_pool_parameters(StoreEntry *entry, const char *name, MessageDelayConfig &cfg)
+{
+    cfg.dumpResponseDelayPoolParameters(entry, name);
+}
+
+inline void
+parse_response_delay_pool_parameters(MessageDelayConfig * cfg)
+{
+    cfg->parseResponseDelayPool();
+}
+
+inline void
+parse_response_delay_pool_access(MessageDelayConfig * cfg)
+{
+    cfg->parseResponseDelayPoolAccess();
+}
+
+#endif
+#endif
+
@@ -16,14 +16,12 @@
 class MessageSizes
 {
 public:
-    MessageSizes() : header(0), payloadData(0) {}
-
     /// size of message header block (if any)
     /// including message Request-Line or Start-Line.
-    uint64_t header;
+    uint64_t header = 0;
 
     /// total size of payload block(s) excluding transfer encoding overheads
-    uint64_t payloadData;
+    uint64_t payloadData = 0;
 
     /// total message size
     uint64_t messageTotal() const {return header + payloadData;}
@@ -28,14 +28,20 @@
 Note::Value::~Value()
 {
     aclDestroyAclList(&aclList);
+    delete valueFormat;
 }
 
 Note::Value::Value(const char *aVal, const bool quoted, const char *descr, const Method m)
     : aclList(nullptr), valueFormat(nullptr), theValue(aVal), theMethod(m)
 {
     if (quoted) {
         valueFormat = new Format::Format(descr ? descr : "Notes");
-        valueFormat->parse(theValue.c_str());
+        if (!valueFormat->parse(theValue.c_str())) {
+            delete valueFormat;
+            SBuf exceptionMsg;
+            exceptionMsg.Printf("failed to parse annotation value %s", theValue.c_str());
+            throw TexcHere(exceptionMsg.c_str());
+        }
     }
 }
 
@@ -12,11 +12,16 @@
 #include "acl/forward.h"
 #include "base/RefCount.h"
 #include "base/YesNoNone.h"
+#if USE_DELAY_POOLS
 #include "ClientDelayConfig.h"
 #include "DelayConfig.h"
+#endif
 #include "helper/ChildConfig.h"
 #include "HttpHeaderTools.h"
 #include "ip/Address.h"
+#if USE_DELAY_POOLS
+#include "MessageDelayPools.h"
+#endif
 #include "Notes.h"
 #include "security/forward.h"
 #include "SquidTime.h"
@@ -234,7 +239,6 @@ class SquidConfig
     size_t tcpRcvBufsz;
     size_t udpMaxHitObjsz;
     wordlist *mcast_group_list;
-    wordlist *dns_nameservers;
     CachePeer *peers;
     int npeers;
 
@@ -434,6 +438,7 @@ class SquidConfig
 
     DelayConfig Delay;
     ClientDelayConfig ClientDelay;
+    MessageDelayConfig MessageDelay;
 #endif
 
     struct {
@@ -531,6 +536,7 @@ class SquidConfig
     char *storeId_extras;
 
     struct {
+        SBufList nameservers;
         int v4_first;       ///< Place IPv4 first in the order of DNS results.
         ssize_t packet_max; ///< maximum size EDNS advertised for DNS replies.
     } dns;
@@ -63,9 +63,9 @@ Acl::ConnectionsEncrypted::match(ACLChecklist *checklist)
     ACLFilledChecklist *filled = Filled((ACLChecklist*)checklist);
 
     const bool safeRequest =
-        !(filled->request->sources & HttpMsg::srcUnsafe);
+        !(filled->request->sources & Http::Message::srcUnsafe);
     const bool safeReply = !filled->reply ||
-                           !(filled->reply->sources & HttpMsg::srcUnsafe);
+                           !(filled->reply->sources & Http::Message::srcUnsafe);
 
     return (safeRequest && safeReply) ? 1 : 0;
 }
@@ -48,7 +48,7 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
             return false;
         value = hdr->getStrOrList(hdrId);
     } else {
-        if (!hdr->getByNameIfPresent(hdrName, value))
+        if (!hdr->hasNamed(hdrName, &value))
             return false;
     }
 
@@ -1039,8 +1039,8 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     /*
      * Initialise ldap
      */
-    ldap_debug = 127 /* LDAP_DEBUG_TRACE */ ;
-    ldap_debug = -1 /* LDAP_DEBUG_ANY */ ;
+//    ldap_debug = 127 /* LDAP_DEBUG_TRACE */ ;
+//    ldap_debug = -1 /* LDAP_DEBUG_ANY */ ;
     ldap_debug = 0;
     (void) ldap_set_option(NULL, LDAP_OPT_DEBUG_LEVEL, &ldap_debug);
 #endif
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "adaptation/Answer.h"
 #include "base/AsyncJobCalls.h"
+#include "http/Message.h"
 
 Adaptation::Answer
 Adaptation::Answer::Error(bool final)
@@ -22,7 +23,7 @@ Adaptation::Answer::Error(bool final)
 }
 
 Adaptation::Answer
-Adaptation::Answer::Forward(HttpMsg *aMsg)
+Adaptation::Answer::Forward(Http::Message *aMsg)
 {
     Answer answer(akForward);
     answer.message = aMsg;
@@ -10,7 +10,8 @@
 #define SQUID_ADAPTATION__ANSWER_H
 
 #include "adaptation/forward.h"
-#include "HttpMsg.h"
+#include "http/forward.h"
+#include "SquidString.h"
 
 #include <iosfwd>
 
@@ -29,13 +30,13 @@ class Answer
     } Kind;
 
     static Answer Error(bool final); ///< create an akError answer
-    static Answer Forward(HttpMsg *aMsg); ///< create an akForward answer
+    static Answer Forward(Http::Message *aMsg); ///< create an akForward answer
     static Answer Block(const String &aRule); ///< create an akBlock answer
 
     std::ostream &print(std::ostream &os) const;
 
 public:
-    HttpMsg::Pointer message; ///< HTTP request or response to forward
+    Http::MessagePointer message; ///< HTTP request or response to forward
     String ruleId; ///< ACL (or similar rule) name that blocked forwarding
     bool final; ///< whether the error, if any, cannot be bypassed
     Kind kind; ///< the type of the answer
@@ -13,7 +13,7 @@
 #include "adaptation/Initiate.h"
 #include "adaptation/Initiator.h"
 #include "base/AsyncJobCalls.h"
-#include "HttpMsg.h"
+#include "http/Message.h"
 
 namespace Adaptation
 {
@@ -16,13 +16,11 @@
 #include "adaptation/ServiceFilter.h"
 #include "adaptation/ServiceGroups.h"
 #include "base/TextException.h"
-#include "HttpMsg.h"
 #include "HttpReply.h"
-#include "HttpRequest.h"
 #include "sbuf/StringConvert.h"
 
 Adaptation::Iterator::Iterator(
-    HttpMsg *aMsg, HttpRequest *aCause,
+    Http::Message *aMsg, HttpRequest *aCause,
     AccessLogEntry::Pointer &alp,
     const ServiceGroupPointer &aGroup):
     AsyncJob("Iterator"),
@@ -118,7 +116,7 @@ Adaptation::Iterator::noteAdaptationAnswer(const Answer &answer)
 {
     switch (answer.kind) {
     case Answer::akForward:
-        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
+        handleAdaptedHeader(const_cast<Http::Message*>(answer.message.getRaw()));
         break;
 
     case Answer::akBlock:
@@ -132,7 +130,7 @@ Adaptation::Iterator::noteAdaptationAnswer(const Answer &answer)
 }
 
 void
-Adaptation::Iterator::handleAdaptedHeader(HttpMsg *aMsg)
+Adaptation::Iterator::handleAdaptedHeader(Http::Message *aMsg)
 {
     // set theCause if we switched to request satisfaction mode
     if (!theCause) { // probably sent a request message
@@ -13,9 +13,7 @@
 #include "adaptation/Initiate.h"
 #include "adaptation/Initiator.h"
 #include "adaptation/ServiceGroups.h"
-
-class HttpMsg;
-class HttpRequest;
+#include "http/forward.h"
 
 namespace Adaptation
 {
@@ -35,7 +33,7 @@ class Iterator: public Initiate, public Initiator
     CBDATA_CLASS(Iterator);
 
 public:
-    Iterator(HttpMsg *virginHeader, HttpRequest *virginCause,
+    Iterator(Http::Message *virginHeader, HttpRequest *virginCause,
              AccessLogEntry::Pointer &alp,
              const Adaptation::ServiceGroupPointer &aGroup);
     virtual ~Iterator();
@@ -61,13 +59,13 @@ class Iterator: public Initiate, public Initiator
     /// creates service filter for the current step
     ServiceFilter filter() const;
 
-    void handleAdaptedHeader(HttpMsg *msg);
+    void handleAdaptedHeader(Http::Message *msg);
     void handleAdaptationBlock(const Answer &answer);
     void handleAdaptationError(bool final);
 
     ServiceGroupPointer theGroup; ///< the service group we are iterating
     ServicePlan thePlan; ///< which services to use and in what order
-    HttpMsg *theMsg; ///< the message being adapted (virgin for each step)
+    Http::Message *theMsg; ///< the message being adapted (virgin for each step)
     HttpRequest *theCause; ///< the cause of the original virgin message
     AccessLogEntry::Pointer al; ///< info for the future access.log entry
     CbcPointer<Adaptation::Initiate> theLauncher; ///< current transaction launcher
@@ -11,7 +11,8 @@
 #include "squid.h"
 #include "adaptation/Message.h"
 #include "base/TextException.h"
-#include "HttpMsg.h"
+#include "BodyPipe.h"
+#include "http/Message.h"
 
 Adaptation::Message::Message(): header(NULL)
 {
@@ -10,8 +10,8 @@
 #define SQUID__ADAPTATION__MESSAGE_H
 
 #include "base/RefCount.h"
+#include "http/forward.h"
 
-class HttpMsg;
 class BodyPipe;
 typedef RefCount<BodyPipe> BodyPipePointer;
 
@@ -21,12 +21,12 @@ namespace Adaptation
 // Manages the header and the body of an HTTP message being worked on.
 // Adaptation transactions use this class for virgin and adapted HTTP messages.
 // TODO: remove this class after adding refcounted message pointers and
-// after making sure nobody abruptly clears the HttpMsg::body_pipe pointer.
+// after making sure nobody abruptly clears the Http::Message::body_pipe pointer.
 class Message
 {
 
 public:
-    typedef HttpMsg Header;
+    typedef Http::Message Header;
 
     Message();
     Message(Header *aHeader);
@@ -14,13 +14,11 @@
 #include "adaptation/forward.h"
 #include "adaptation/ServiceConfig.h"
 #include "base/RefCount.h"
+#include "http/forward.h"
 #include "SquidString.h"
 
 // TODO: Move src/ICAP/ICAPServiceRep.h API comments here and update them
 
-class HttpMsg;
-class HttpRequest;
-
 namespace Adaptation
 {
 
@@ -40,7 +38,7 @@ class Service: public RefCountable
     virtual bool broken() const;
     virtual bool up() const = 0; // see comments above
 
-    virtual Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp) = 0;
+    virtual Initiate *makeXactLauncher(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp) = 0;
 
     bool wants(const ServiceFilter &filter) const;
 
@@ -139,7 +139,7 @@ Adaptation::ServiceConfig::parse()
             grokked = grokOnOverload(onOverload, value);
             onOverloadSet = true;
         } else if (strcmp(name, "connection-encryption") == 0) {
-            bool encrypt;
+            bool encrypt = false;
             grokked = grokBool(encrypt, name, value);
             connectionEncryption.configure(encrypt);
         } else if (strncmp(name, "ssl", 3) == 0 || strncmp(name, "tls-", 4) == 0) {
@@ -24,7 +24,7 @@
 
 /* HeaderRep */
 
-Adaptation::Ecap::HeaderRep::HeaderRep(HttpMsg &aMessage): theHeader(aMessage.header),
+Adaptation::Ecap::HeaderRep::HeaderRep(Http::Message &aMessage): theHeader(aMessage.header),
     theMessage(aMessage)
 {
 }
@@ -33,10 +33,9 @@ bool
 Adaptation::Ecap::HeaderRep::hasAny(const Name &name) const
 {
     const Http::HdrType squidId = TranslateHeaderId(name);
-    // XXX: optimize to remove getByName: we do not need the value here
     return squidId == Http::HdrType::OTHER ?
-           theHeader.getByName(name.image().c_str()).size() > 0:
-           (bool)theHeader.has(squidId);
+           theHeader.hasNamed(name.image().c_str(), name.image().size()) :
+           static_cast<bool>(theHeader.has(squidId));
 }
 
 Adaptation::Ecap::HeaderRep::Value
@@ -113,7 +112,7 @@ Adaptation::Ecap::HeaderRep::TranslateHeaderId(const Name &name)
 
 /* FirstLineRep */
 
-Adaptation::Ecap::FirstLineRep::FirstLineRep(HttpMsg &aMessage): theMessage(aMessage)
+Adaptation::Ecap::FirstLineRep::FirstLineRep(Http::Message &aMessage): theMessage(aMessage)
 {
 }
 
@@ -360,7 +359,7 @@ Adaptation::Ecap::BodyRep::bodySize() const
 
 /* MessageRep */
 
-Adaptation::Ecap::MessageRep::MessageRep(HttpMsg *rawHeader):
+Adaptation::Ecap::MessageRep::MessageRep(Http::Message *rawHeader):
     theMessage(rawHeader), theFirstLineRep(NULL),
     theHeaderRep(NULL), theBodyRep(NULL)
 {
@@ -389,7 +388,7 @@ Adaptation::Ecap::MessageRep::~MessageRep()
 libecap::shared_ptr<libecap::Message>
 Adaptation::Ecap::MessageRep::clone() const
 {
-    HttpMsg *hdr = theMessage.header->clone();
+    Http::Message *hdr = theMessage.header->clone();
     hdr->body_pipe = NULL; // if any; TODO: remove pipe cloning from ::clone?
     libecap::shared_ptr<libecap::Message> res(new MessageRep(hdr));
 
@@ -15,31 +15,29 @@
 #include "adaptation/Message.h"
 #include "anyp/ProtocolType.h"
 #include "BodyPipe.h"
+#include "http/forward.h"
 #include "HttpHeader.h"
+
 #include <libecap/common/message.h>
 #include <libecap/common/header.h>
 #include <libecap/common/body.h>
 
-class HttpMsg;
-class HttpRequest;
-class HttpReply;
-
 namespace Adaptation
 {
 namespace Ecap
 {
 
 class XactionRep;
 
-// Translates Squid HttpMsg into libecap::Header.
+// Translates Squid Http::Message into libecap::Header.
 class HeaderRep: public libecap::Header
 {
 public:
     typedef libecap::Name Name;
     typedef libecap::Area Area;
 
 public:
-    HeaderRep(HttpMsg &aMessage);
+    HeaderRep(Http::Message &aMessage);
 
     /* libecap::Header API */
     virtual bool hasAny(const Name &name) const;
@@ -55,17 +53,17 @@ class HeaderRep: public libecap::Header
 
 private:
     HttpHeader &theHeader; // the header being translated to libecap
-    HttpMsg &theMessage;   // the message being translated to libecap
+    Http::Message &theMessage;   // the message being translated to libecap
 };
 
-// Helps translate Squid HttpMsg into libecap::FirstLine (see children).
+// Helps translate Squid Http::Message into libecap::FirstLine (see children).
 class FirstLineRep
 {
 public:
     typedef libecap::Name Name;
 
 public:
-    FirstLineRep(HttpMsg &aMessage);
+    FirstLineRep(Http::Message &aMessage);
 
     libecap::Version version() const;
     void version(const libecap::Version &aVersion);
@@ -76,7 +74,7 @@ class FirstLineRep
     static AnyP::ProtocolType TranslateProtocolId(const Name &name);
 
 private:
-    HttpMsg &theMessage; // the message which first line is being translated
+    Http::Message &theMessage; // the message which first line is being translated
 };
 
 // Translates Squid HttpRequest into libecap::RequestLine.
@@ -149,7 +147,7 @@ class BodyRep: public libecap::Body
 class MessageRep: public libecap::Message
 {
 public:
-    explicit MessageRep(HttpMsg *rawHeader);
+    explicit MessageRep(Http::Message *rawHeader);
     virtual ~MessageRep();
 
     /* libecap::Message API */
@@ -248,7 +248,7 @@ bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &urlPath) const
 }
 
 Adaptation::Initiate *
-Adaptation::Ecap::ServiceRep::makeXactLauncher(HttpMsg *virgin,
+Adaptation::Ecap::ServiceRep::makeXactLauncher(Http::Message *virgin,
         HttpRequest *cause, AccessLogEntry::Pointer &alp)
 {
     Must(up());
@@ -37,7 +37,7 @@ class ServiceRep : public Adaptation::Service
     virtual void finalize();
     virtual bool probed() const;
     virtual bool up() const;
-    virtual Adaptation::Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp);
+    virtual Adaptation::Initiate *makeXactLauncher(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp);
     virtual bool wantsUrl(const SBuf &urlPath) const;
     virtual void noteFailure();
     virtual const char *status() const;
@@ -45,7 +45,7 @@ class OptionsExtractor: public libecap::NamedValueVisitor
 };
 
 Adaptation::Ecap::XactionRep::XactionRep(
-    HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp,
+    Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp,
     const Adaptation::ServicePointer &aService):
     AsyncJob("Adaptation::Ecap::XactionRep"),
     Adaptation::Initiate("Adaptation::Ecap::XactionRep"),
@@ -401,7 +401,7 @@ Adaptation::Ecap::XactionRep::useVirgin()
 
     preserveVb("useVirgin");
 
-    HttpMsg *clone = theVirginRep.raw().header->clone();
+    Http::Message *clone = theVirginRep.raw().header->clone();
     // check that clone() copies the pipe so that we do not have to
     Must(!theVirginRep.raw().header->body_pipe == !clone->body_pipe);
 
@@ -418,7 +418,7 @@ Adaptation::Ecap::XactionRep::useAdapted(const libecap::shared_ptr<libecap::Mess
     theAnswerRep = m;
     Must(proxyingAb == opUndecided);
 
-    HttpMsg *msg = answer().header;
+    Http::Message *msg = answer().header;
     updateSources(msg);
     if (!theAnswerRep->body()) { // final, bodyless answer
         proxyingAb = opNever;
@@ -457,7 +457,7 @@ Adaptation::Ecap::XactionRep::blockVirgin()
 /// Called just before sendAnswer() to record adapter meta-information
 /// which may affect answer processing and may be needed for logging.
 void
-Adaptation::Ecap::XactionRep::updateHistory(HttpMsg *adapted)
+Adaptation::Ecap::XactionRep::updateHistory(Http::Message *adapted)
 {
     if (!theMaster) // all updates rely on being able to query the adapter
         return;
@@ -734,8 +734,8 @@ Adaptation::Ecap::XactionRep::status() const
 }
 
 void
-Adaptation::Ecap::XactionRep::updateSources(HttpMsg *adapted)
+Adaptation::Ecap::XactionRep::updateSources(Http::Message *adapted)
 {
-    adapted->sources |= service().cfg().connectionEncryption ? HttpMsg::srcEcaps : HttpMsg::srcEcap;
+    adapted->sources |= service().cfg().connectionEncryption ? Http::Message::srcEcaps : Http::Message::srcEcap;
 }
 
@@ -35,7 +35,7 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
     CBDATA_CLASS(XactionRep);
 
 public:
-    XactionRep(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, const Adaptation::ServicePointer &service);
+    XactionRep(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, const Adaptation::ServicePointer &service);
     virtual ~XactionRep();
 
     typedef libecap::shared_ptr<libecap::adapter::Xaction> AdapterXaction;
@@ -91,10 +91,10 @@ class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
 
     void moveAbContent();
 
-    void updateHistory(HttpMsg *adapted);
+    void updateHistory(Http::Message *adapted);
     void terminateMaster();
     void scheduleStop(const char *reason);
-    void updateSources(HttpMsg *adapted);
+    void updateSources(Http::Message *adapted);
 
     const libecap::Area clientIpValue() const;
     const libecap::Area usernameValue() const;
@@ -9,9 +9,7 @@
 #ifndef SQUID_ICAPINOUT_H
 #define SQUID_ICAPINOUT_H
 
-#include "HttpMsg.h"
 #include "HttpReply.h"
-#include "HttpRequest.h"
 
 // IcapInOut manages a pointer to the HTTP message being worked on.
 // For HTTP responses, request header information is also available
@@ -27,7 +25,8 @@ class InOut
 {
 
 public:
-    typedef HttpMsg Header;
+    // TODO: s/Header/Message/i ?
+    typedef Http::Message Header;
 
     InOut(): header(0), cause(0) {}
 
@@ -64,8 +63,6 @@ class InOut
     BodyPipe::Pointer body_pipe;
 };
 
-// TODO: s/Header/Message/i ?
-
 } // namespace Icap
 } // namespace Adaptation
 
@@ -17,9 +17,7 @@
 #include "adaptation/icap/Xaction.h"
 #include "base/TextException.h"
 #include "globals.h"
-#include "HttpMsg.h"
 #include "HttpReply.h"
-#include "HttpRequest.h"
 
 Adaptation::Icap::Launcher::Launcher(const char *aTypeName,
                                      Adaptation::ServicePointer &aService):
@@ -27,9 +27,7 @@
 #include "err_detail_type.h"
 #include "http/one/TeChunkedParser.h"
 #include "HttpHeaderTools.h"
-#include "HttpMsg.h"
 #include "HttpReply.h"
-#include "HttpRequest.h"
 #include "SquidTime.h"
 #include "URL.h"
 
@@ -49,7 +47,7 @@ Adaptation::Icap::ModXact::State::State()
     memset(this, 0, sizeof(*this));
 }
 
-Adaptation::Icap::ModXact::ModXact(HttpMsg *virginHeader,
+Adaptation::Icap::ModXact::ModXact(Http::Message *virginHeader,
                                    HttpRequest *virginCause, AccessLogEntry::Pointer &alp, Adaptation::Icap::ServiceRep::Pointer &aService):
     AsyncJob("Adaptation::Icap::ModXact"),
     Adaptation::Icap::Xaction("Adaptation::Icap::ModXact", aService),
@@ -777,9 +775,9 @@ void Adaptation::Icap::ModXact::startSending()
         echoMore();
     else {
         // If we are not using the virgin HTTP object update the
-        // HttpMsg::sources flag.
+        // Http::Message::sources flag.
         // The state.sending may set to State::sendingVirgin in the case
-        // of 206 responses too, where we do not want to update HttpMsg::sources
+        // of 206 responses too, where we do not want to update Http::Message::sources
         // flag. However even for 206 responses the state.sending is
         // not set yet to sendingVirgin. This is done in later step
         // after the parseBody method called.
@@ -953,12 +951,12 @@ void Adaptation::Icap::ModXact::prepEchoing()
     setOutcome(xoEcho);
 
     // We want to clone the HTTP message, but we do not want
-    // to copy some non-HTTP state parts that HttpMsg kids carry in them.
+    // to copy some non-HTTP state parts that Http::Message kids carry in them.
     // Thus, we cannot use a smart pointer, copy constructor, or equivalent.
     // Instead, we simply write the HTTP message and "clone" it by parsing.
-    // TODO: use HttpMsg::clone()!
+    // TODO: use Http::Message::clone()!
 
-    HttpMsg *oldHead = virgin.header;
+    Http::Message *oldHead = virgin.header;
     debugs(93, 7, HERE << "cloning virgin message " << oldHead);
 
     MemBuf httpBuf;
@@ -970,7 +968,7 @@ void Adaptation::Icap::ModXact::prepEchoing()
     // allocate the adapted message and copy metainfo
     Must(!adapted.header);
     {
-        HttpMsg::Pointer newHead;
+        Http::MessagePointer newHead;
         if (dynamic_cast<const HttpRequest*>(oldHead)) {
             newHead = new HttpRequest;
         } else if (dynamic_cast<const HttpReply*>(oldHead)) {
@@ -986,7 +984,7 @@ void Adaptation::Icap::ModXact::prepEchoing()
     // parse the buffer back
     Http::StatusCode error = Http::scNone;
 
-    httpBuf.terminate(); // HttpMsg::parse requires nil-terminated buffer
+    httpBuf.terminate(); // Http::Message::parse requires nil-terminated buffer
     Must(adapted.header->parse(httpBuf.content(), httpBuf.contentSize(), true, &error));
     Must(adapted.header->hdr_sz == httpBuf.contentSize()); // no leftovers
 
@@ -1094,7 +1092,7 @@ bool Adaptation::Icap::ModXact::parsePart(Part *part, const char *description)
     debugs(93, 5, "have " << readBuf.length() << ' ' << description << " bytes to parse; state: " << state.parsing);
     Http::StatusCode error = Http::scNone;
     // XXX: performance regression. c_str() data copies
-    // XXX: HttpMsg::parse requires a terminated string buffer
+    // XXX: Http::Message::parse requires a terminated string buffer
     const char *tmpBuf = readBuf.c_str();
     const bool parsed = part->parse(tmpBuf, readBuf.length(), commEof, &error);
     debugs(93, (!parsed && error) ? 2 : 5, description << " parsing result: " << parsed << " detail: " << error);
@@ -1105,7 +1103,8 @@ bool Adaptation::Icap::ModXact::parsePart(Part *part, const char *description)
 }
 
 // parses both HTTP and ICAP headers
-bool Adaptation::Icap::ModXact::parseHead(HttpMsg *head)
+bool
+Adaptation::Icap::ModXact::parseHead(Http::Message *head)
 {
     if (!parsePart(head, "head")) {
         head->reset();
@@ -1127,7 +1126,7 @@ bool Adaptation::Icap::ModXact::expectHttpBody() const
 bool Adaptation::Icap::ModXact::expectIcapTrailers() const
 {
     String trailers;
-    const bool promisesToSendTrailer = icapReply->header.getByIdIfPresent(Http::HdrType::TRAILER, trailers);
+    const bool promisesToSendTrailer = icapReply->header.getByIdIfPresent(Http::HdrType::TRAILER, &trailers);
     const bool supportsTrailers = icapReply->header.hasListMember(Http::HdrType::ALLOW, "trailers", ',');
     // ICAP Trailer specs require us to reject transactions having either Trailer
     // header or Allow:trailers
@@ -1348,7 +1347,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
 #endif
     al.cache.code = h->logType;
 
-    const HttpMsg *virgin_msg = dynamic_cast<HttpReply*>(virgin.header);
+    const Http::Message *virgin_msg = dynamic_cast<HttpReply*>(virgin.header);
     if (!virgin_msg)
         virgin_msg = virgin_request_;
     assert(virgin_msg != virgin.cause);
@@ -1450,7 +1449,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     }
 
     if (ICAP::methodRespmod == m)
-        if (const HttpMsg *prime = virgin.header)
+        if (const Http::Message *prime = virgin.header)
             encapsulateHead(buf, "res-hdr", httpBuf, prime);
 
     if (!virginBody.expected())
@@ -1584,17 +1583,18 @@ void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, M
 #endif
 }
 
-void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head)
+void
+Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const Http::Message *head)
 {
     // update ICAP header
     icapBuf.appendf("%s=%d, ", section, (int) httpBuf.contentSize());
 
     // begin cloning
-    HttpMsg::Pointer headClone;
+    Http::MessagePointer headClone;
 
     if (const HttpRequest* old_request = dynamic_cast<const HttpRequest*>(head)) {
         HttpRequest::Pointer new_request(new HttpRequest);
-        // copy the requst-line details
+        // copy the request-line details
         new_request->method = old_request->method;
         new_request->url = old_request->url;
         new_request->http_ver = old_request->http_ver;
@@ -1624,7 +1624,8 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
     // headClone unlocks and, hence, deletes the message we packed
 }
 
-void Adaptation::Icap::ModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
+void
+Adaptation::Icap::ModXact::packHead(MemBuf &httpBuf, const Http::Message *head)
 {
     head->packInto(&httpBuf, true);
 }
@@ -1819,7 +1820,7 @@ void Adaptation::Icap::ModXact::estimateVirginBody()
 {
     // note: lack of size info may disable previews and 204s
 
-    HttpMsg *msg = virgin.header;
+    Http::Message *msg = virgin.header;
     Must(msg);
 
     HttpRequestMethod method;
@@ -2014,12 +2015,12 @@ void Adaptation::Icap::ModXact::clearError()
 void Adaptation::Icap::ModXact::updateSources()
 {
     Must(adapted.header);
-    adapted.header->sources |= (service().cfg().connectionEncryption ? HttpMsg::srcIcaps : HttpMsg::srcIcap);
+    adapted.header->sources |= (service().cfg().connectionEncryption ? Http::Message::srcIcaps : Http::Message::srcIcap);
 }
 
 /* Adaptation::Icap::ModXactLauncher */
 
-Adaptation::Icap::ModXactLauncher::ModXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, Adaptation::ServicePointer aService):
+Adaptation::Icap::ModXactLauncher::ModXactLauncher(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, Adaptation::ServicePointer aService):
     AsyncJob("Adaptation::Icap::ModXactLauncher"),
     Adaptation::Icap::Launcher("Adaptation::Icap::ModXactLauncher", aService),
     al(alp)
@@ -125,7 +125,7 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
     CBDATA_CLASS(ModXact);
 
 public:
-    ModXact(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, ServiceRep::Pointer &s);
+    ModXact(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, ServiceRep::Pointer &s);
     virtual ~ModXact();
 
     // BodyProducer methods
@@ -217,7 +217,7 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
     void parseHeaders();
     void parseIcapHead();
     void parseHttpHead();
-    bool parseHead(HttpMsg *head);
+    bool parseHead(Http::Message *head);
 
     void decideOnParsingBody();
     void parseBody();
@@ -239,7 +239,7 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
     void prepEchoing();
     void prepPartialBodyEchoing(uint64_t pos);
     void echoMore();
-    void updateSources(); ///< Update the HttpMsg sources
+    void updateSources(); ///< Update the Http::Message sources
 
     virtual bool doneAll() const;
     virtual void swanSong();
@@ -262,8 +262,8 @@ class ModXact: public Xaction, public BodyProducer, public BodyConsumer
     template<class Part>
     bool parsePart(Part *part, const char *description);
 
-    void packHead(MemBuf &httpBuf, const HttpMsg *head);
-    void encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head);
+    void packHead(MemBuf &httpBuf, const Http::Message *head);
+    void encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const Http::Message *head);
     bool gotEncapsulated(const char *section) const;
     /// whether ICAP response header indicates HTTP header presence
     bool expectHttpHeader() const;
@@ -359,7 +359,7 @@ class ModXactLauncher: public Launcher
     CBDATA_CLASS(ModXactLauncher);
 
 public:
-    ModXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, Adaptation::ServicePointer s);
+    ModXactLauncher(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp, Adaptation::ServicePointer s);
 
 protected:
     virtual Xaction *createXaction();
@@ -69,7 +69,7 @@ void Adaptation::Icap::OptXact::makeRequest(MemBuf &buf)
 
     // XXX: HttpRequest cannot fully parse ICAP Request-Line
     Http::StatusCode reqStatus;
-    buf.terminate(); // HttpMsg::parse requires terminated buffer
+    buf.terminate(); // Http::Message::parse requires terminated buffer
     Must(icapRequest->parse(buf.content(), buf.contentSize(), true, &reqStatus) > 0);
 }
 
@@ -555,7 +555,7 @@ void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(const Answer &answer)
     }
 
     Must(answer.kind == Answer::akForward); // no akBlock for OPTIONS requests
-    const HttpMsg *msg = answer.message.getRaw();
+    const Http::Message *msg = answer.message.getRaw();
     Must(msg);
 
     debugs(93,5, HERE << "is interpreting new options " << status());
@@ -677,7 +677,7 @@ Adaptation::Icap::ServiceRep::optionsFetchTime() const
 }
 
 Adaptation::Initiate *
-Adaptation::Icap::ServiceRep::makeXactLauncher(HttpMsg *virgin,
+Adaptation::Icap::ServiceRep::makeXactLauncher(Http::Message *virgin,
         HttpRequest *cause, AccessLogEntry::Pointer &alp)
 {
     return new Adaptation::Icap::ModXactLauncher(virgin, cause, alp, this);
@@ -75,7 +75,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     bool availableForNew() const; ///< a new transaction may start communicating with the service
     bool availableForOld() const; ///< a transaction notified about connection slot availability may start communicating with the service
 
-    virtual Initiate *makeXactLauncher(HttpMsg *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp);
+    virtual Initiate *makeXactLauncher(Http::Message *virginHeader, HttpRequest *virginCause, AccessLogEntry::Pointer &alp);
 
     void callWhenAvailable(AsyncCall::Pointer &cb, bool priority = false);
     void callWhenReady(AsyncCall::Pointer &cb);
@@ -24,9 +24,7 @@
 #include "fde.h"
 #include "FwdState.h"
 #include "globals.h"
-#include "HttpMsg.h"
 #include "HttpReply.h"
-#include "HttpRequest.h"
 #include "icap_log.h"
 #include "ipcache.h"
 #include "pconn.h"
@@ -522,7 +520,8 @@ void Adaptation::Icap::Xaction::cancelRead()
     }
 }
 
-bool Adaptation::Icap::Xaction::parseHttpMsg(HttpMsg *msg)
+bool
+Adaptation::Icap::Xaction::parseHttpMsg(Http::Message *msg)
 {
     debugs(93, 5, "have " << readBuf.length() << " head bytes to parse");
 
@@ -86,7 +86,7 @@ class Xaction: public Adaptation::Initiate
 
     void cancelRead();
 
-    bool parseHttpMsg(HttpMsg *msg); // true=success; false=needMore; throw=err
+    bool parseHttpMsg(Http::Message *msg); // true=success; false=needMore; throw=err
     bool mayReadMore() const;
 
     virtual bool doneReading() const;
@@ -17,7 +17,6 @@
 #include "format/Format.h"
 #include "helper.h"
 #include "helper/Reply.h"
-#include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
@@ -63,6 +63,7 @@ static const char *usersearchfilter = NULL;
 static const char *binddn = NULL;
 static const char *bindpasswd = NULL;
 static const char *delimiter = ":";
+static const char *frealm = "";
 static int encrpass = 0;
 static int searchscope = LDAP_SCOPE_SUBTREE;
 static int persistent = 0;
@@ -267,7 +268,7 @@ getpassword(char *login, char *realm)
             }
             value = values;
             while (*value) {
-                if (encrpass) {
+                if (encrpass && *delimiter ) {
                     const char *t = strtok(*value, delimiter);
                     if (t && strcmp(t, realm) == 0) {
                         password = strtok(NULL, delimiter);
@@ -451,6 +452,9 @@ LDAPArguments(int argc, char **argv)
         case 'l':
             delimiter = value;
             break;
+        case 'r':
+            frealm = value;
+            break;
         case 'b':
             userbasedn = value;
             break;
@@ -574,10 +578,11 @@ LDAPArguments(int argc, char **argv)
     if (!ldapServer)
         ldapServer = (char *) "localhost";
 
-    if (!userbasedn || !passattr) {
-        fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
+    if (!userbasedn || !passattr || (!*delimiter && !*frealm)) {
+        fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -F filter [options] ldap_server_name\n\n");
         fprintf(stderr, "\t-A password attribute(REQUIRED)\t\tUser attribute that contains the password\n");
-        fprintf(stderr, "\t-l password realm delimiter(REQUIRED)\tCharater(s) that devides the password attribute\n\t\t\t\t\t\tin realm and password tokens, default ':' realm:password\n");
+        fprintf(stderr, "\t-l password realm delimiter(REQUIRED)\tCharacter(s) that divides the password attribute\n\t\t\t\t\t\tin realm and password tokens, default ':' realm:password, could be\n\t\t\t\t\t\tempty string if the password is alone in the password attribute\n");
+        fprintf(stderr, "\t-r filtered realm\t\t\tonly honor Squid requests for this realm. Mandatory if the password is alone in\n\t\t\t\t\t\tthe password attribute, acting as the implicit realm\n");
         fprintf(stderr, "\t-b basedn (REQUIRED)\t\t\tbase dn under where to search for users\n");
         fprintf(stderr, "\t-e Encrypted passwords(REQUIRED)\tPassword are stored encrypted using HHA1\n");
         fprintf(stderr, "\t-F filter\t\t\t\tuser search filter pattern. %%s = login\n");
@@ -644,9 +649,17 @@ readSecret(const char *filename)
 void
 LDAPHHA1(RequestData * requestData)
 {
-    char *password;
+    char *password = NULL;
     ldapconnect();
-    password = getpassword(requestData->user, requestData->realm);
+
+    // use the -l delimiter to find realm, or
+    // only honor the -r specified realm
+    const bool lookup = (!*frealm && *delimiter) ||
+                        (*frealm && strcmp(requestData->realm, frealm) != 0);
+
+    if (lookup)
+        password = getpassword(requestData->user, requestData->realm);
+
     if (password != NULL) {
         if (encrpass)
             xstrncpy(requestData->HHA1, password, sizeof(requestData->HHA1));
@@ -21,7 +21,6 @@
 #include "helper.h"
 #include "helper/Reply.h"
 #include "http/Stream.h"
-#include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
@@ -42,6 +42,7 @@
 #include "log/Config.h"
 #include "log/CustomLog.h"
 #include "MemBuf.h"
+#include "MessageDelayPools.h"
 #include "mgr/ActionPasswordList.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
@@ -1300,16 +1301,42 @@ parseBytesUnits(const char *unit)
     return 0;
 }
 
+static void
+parse_SBufList(SBufList * list)
+{
+    while (char *token = ConfigParser::NextQuotedToken())
+        list->push_back(SBuf(token));
+}
+
+// just dump a list, no directive name
 static void
 dump_SBufList(StoreEntry * entry, const SBufList &words)
 {
-    for (SBufList::const_iterator i = words.begin(); i != words.end(); ++i) {
-        entry->append(i->rawContent(), i->length());
+    for (const auto &i : words) {
+        entry->append(i.rawContent(), i.length());
         entry->append(" ",1);
     }
     entry->append("\n",1);
 }
 
+// dump a SBufList type directive with name
+static void
+dump_SBufList(StoreEntry * entry, const char *name, SBufList &list)
+{
+    if (!list.empty()) {
+        entry->append(name, strlen(name));
+        entry->append(" ", 1);
+        dump_SBufList(entry, list);
+    }
+}
+
+static void
+free_SBufList(SBufList *list)
+{
+    if (list)
+        list->clear();
+}
+
 static void
 dump_acl(StoreEntry * entry, const char *name, ACL * ae)
 {
@@ -1654,7 +1681,7 @@ parse_delay_pool_access(DelayConfig * cfg)
 static void
 free_client_delay_pool_count(ClientDelayConfig * cfg)
 {
-    cfg->freePoolCount();
+    cfg->freePools();
 }
 
 static void
@@ -33,6 +33,8 @@ delay_pool_rates	delay_class
 client_delay_pool_access	acl
 client_delay_pool_count
 client_delay_pool_rates
+response_delay_pool_access	acl
+response_delay_pool_parameters
 denyinfo		acl
 eol
 externalAclHelper	auth_param
@@ -86,6 +88,7 @@ wccp2_amethod
 wccp2_service
 wccp2_service_info
 wordlist
+SBufList
 sslproxy_ssl_bump	acl
 sslproxy_ssl_bump_peeked acl
 sslproxy_cert_sign	acl
@@ -7202,6 +7202,64 @@ DOC_START
 	See also client_delay_parameters and client_delay_pools.
 DOC_END
 
+NAME: response_delay_pool
+TYPE: response_delay_pool_parameters
+DEFAULT: none
+IFDEF: USE_DELAY_POOLS
+LOC: Config.MessageDelay
+DOC_START
+	This option configures client response bandwidth limits using the
+	following format:
+
+	response_delay_pool name [option=value] ...
+
+	name	the response delay pool name
+
+	available options:
+
+		individual-restore	The speed limit of an individual
+					bucket(bytes/s). To be used in conjunction
+					with 'individual-maximum'.
+
+		individual-maximum	The maximum number of bytes which can
+					be placed into the individual bucket. To be used
+					in conjunction with 'individual-restore'.
+
+		aggregate-restore	The speed limit for the aggregate
+					bucket(bytes/s). To be used in conjunction with
+					'aggregate-maximum'.
+
+		aggregate-maximum	The maximum number of bytes which can
+	   				be placed into the aggregate bucket. To be used
+					in conjunction with 'aggregate-restore'.
+
+		initial-bucket-level	The initial bucket size as a percentage
+					of individual-maximum.
+
+	Individual and(or) aggregate bucket options may not be specified,
+   	meaning no individual and(or) aggregate speed limitation.
+	See also response_delay_pool_access and delay_parameters for
+	terminology details.
+DOC_END
+
+NAME: response_delay_pool_access
+TYPE: response_delay_pool_access
+DEFAULT: none
+DEFAULT_DOC: Deny use of the pool, unless allow rules exist in squid.conf for the pool.
+IFDEF: USE_DELAY_POOLS
+LOC: Config.MessageDelay
+DOC_START
+	Determines whether a specific named response delay pool is used
+	for the transaction. The syntax for this directive is:
+
+	response_delay_pool_access pool_name allow|deny acl_name
+
+	All response_delay_pool_access options are checked in the order
+	they appear in this configuration file. The first rule with a
+	matching ACL wins. If (and only if) an "allow" rule won, Squid
+	assigns the response to the corresponding named delay pool.
+DOC_END
+
 COMMENT_START
  WCCPv1 AND WCCPv2 CONFIGURATION OPTIONS
  -----------------------------------------------------------------------------
@@ -9328,10 +9386,10 @@ DOC_START
 DOC_END
 
 NAME: dns_nameservers
-TYPE: wordlist
+TYPE: SBufList
 DEFAULT: none
 DEFAULT_DOC: Use operating system definitions
-LOC: Config.dns_nameservers
+LOC: Config.dns.nameservers
 DOC_START
 	Use this if you want to specify a list of DNS name servers
 	(IP addresses) to use instead of those given in your
@@ -53,40 +53,31 @@ static int cleanup_removed;
 #endif
 
 ClientInfo::ClientInfo(const Ip::Address &ip) :
+#if USE_DELAY_POOLS
+    BandwidthBucket(0, 0, 0),
+#endif
     addr(ip),
     n_established(0),
     last_seen(0)
 #if USE_DELAY_POOLS
-    , writeSpeedLimit(0),
-    prevTime(0),
-    bucketSize(0),
-    bucketSizeLimit(0),
-    writeLimitingActive(false),
+    , writeLimitingActive(false),
     firstTimeConnection(true),
     quotaQueue(nullptr),
     rationedQuota(0),
     rationedCount(0),
-    selectWaiting(false),
     eventWaiting(false)
 #endif
 {
     debugs(77, 9, "ClientInfo constructed, this=" << static_cast<void*>(this));
-
-#if USE_DELAY_POOLS
-    getCurrentTime();
-    /* put current time to have something sensible here */
-    prevTime = current_dtime;
-#endif
-
     char *buf = static_cast<char*>(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
-    hash.key = addr.toStr(buf,MAX_IPSTRLEN);
+    key = addr.toStr(buf,MAX_IPSTRLEN);
 }
 
 static ClientInfo *
 clientdbAdd(const Ip::Address &addr)
 {
     ClientInfo *c = new ClientInfo(addr);
-    hash_join(client_table, &c->hash);
+    hash_join(client_table, static_cast<hash_link*>(c));
     ++statCounter.client_http.clients;
 
     if ((statCounter.client_http.clients > max_clients) && !cleanup_running && cleanup_scheduled < 2) {
@@ -277,16 +268,16 @@ void
 clientdbDump(StoreEntry * sentry)
 {
     const char *name;
-    ClientInfo *c;
     int icp_total = 0;
     int icp_hits = 0;
     int http_total = 0;
     int http_hits = 0;
     storeAppendPrintf(sentry, "Cache Clients:\n");
     hash_first(client_table);
 
-    while ((c = (ClientInfo *) hash_next(client_table))) {
-        storeAppendPrintf(sentry, "Address: %s\n", hashKeyStr(&c->hash));
+    while (hash_link *hash = hash_next(client_table)) {
+        const ClientInfo *c = reinterpret_cast<const ClientInfo *>(hash);
+        storeAppendPrintf(sentry, "Address: %s\n", hashKeyStr(hash));
         if ( (name = fqdncache_gethostbyaddr(c->addr, 0)) ) {
             storeAppendPrintf(sentry, "Name:    %s\n", name);
         }
@@ -344,7 +335,7 @@ clientdbFreeItem(void *data)
 
 ClientInfo::~ClientInfo()
 {
-    safe_free(hash.key);
+    safe_free(key);
 
 #if USE_DELAY_POOLS
     if (CommQuotaQueue *q = quotaQueue) {
@@ -399,7 +390,7 @@ clientdbGC(void *)
         if (age < 60)
             continue;
 
-        hash_remove_link(client_table, &c->hash);
+        hash_remove_link(client_table, static_cast<hash_link*>(c));
 
         clientdbFreeItem(c);
 
@@ -438,30 +429,22 @@ clientdbStartGC(void)
 Ip::Address *
 client_entry(Ip::Address *current)
 {
-    ClientInfo *c = NULL;
     char key[MAX_IPSTRLEN];
+    hash_first(client_table);
 
     if (current) {
         current->toStr(key,MAX_IPSTRLEN);
-        hash_first(client_table);
-        while ((c = (ClientInfo *) hash_next(client_table))) {
-            if (!strcmp(key, hashKeyStr(&c->hash)))
+        while (hash_link *hash = hash_next(client_table)) {
+            if (!strcmp(key, hashKeyStr(hash)))
                 break;
         }
-
-        c = (ClientInfo *) hash_next(client_table);
-    } else {
-        hash_first(client_table);
-        c = (ClientInfo *) hash_next(client_table);
     }
 
-    hash_last(client_table);
+    ClientInfo *c = reinterpret_cast<ClientInfo *>(hash_next(client_table));
 
-    if (c)
-        return (&c->addr);
-    else
-        return (NULL);
+    hash_last(client_table);
 
+    return c ? &c->addr : nullptr;
 }
 
 variable_list *
@@ -120,6 +120,7 @@
 #endif
 #if USE_DELAY_POOLS
 #include "ClientInfo.h"
+#include "MessageDelayPools.h"
 #endif
 #if USE_OPENSSL
 #include "ssl/bio.h"
@@ -1641,8 +1642,8 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
     // TODO: decouple http->flags.accel from request->flags.sslBumped
     request->flags.noDirect = (request->flags.accelerated && !request->flags.sslBumped) ?
                               !conn->port->allow_direct : 0;
-    request->sources |= isFtp ? HttpMsg::srcFtp :
-                        ((request->flags.sslBumped || conn->port->transport.protocol == AnyP::PROTO_HTTPS) ? HttpMsg::srcHttps : HttpMsg::srcHttp);
+    request->sources |= isFtp ? Http::Message::srcFtp :
+                        ((request->flags.sslBumped || conn->port->transport.protocol == AnyP::PROTO_HTTPS) ? Http::Message::srcHttps : Http::Message::srcHttp);
 #if USE_AUTH
     if (request->flags.sslBumped) {
         if (conn->getAuth() != NULL)
@@ -1695,7 +1696,7 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
     request->myportname = conn->port->name;
 
     if (!isFtp) {
-        // XXX: for non-HTTP messages instantiate a different HttpMsg child type
+        // XXX: for non-HTTP messages instantiate a different Http::Message child type
         // for now Squid only supports HTTP requests
         const AnyP::ProtocolVersion &http_ver = hp->messageProtocol();
         assert(request->http_ver.protocol == http_ver.protocol);
@@ -2488,7 +2489,7 @@ ConnStateData::start()
     if (Config.onoff.client_db) {
         /* it was said several times that client write limiter does not work if client_db is disabled */
 
-        ClientDelayPools& pools(Config.ClientDelay.pools);
+        auto &pools = ClientDelayPools::Instance()->pools;
         ACLFilledChecklist ch(NULL, NULL, NULL);
 
         // TODO: we check early to limit error response bandwith but we
@@ -2500,8 +2501,8 @@ ConnStateData::start()
         for (unsigned int pool = 0; pool < pools.size(); ++pool) {
 
             /* pools require explicit 'allow' to assign a client into them */
-            if (pools[pool].access) {
-                ch.changeAcl(pools[pool].access);
+            if (pools[pool]->access) {
+                ch.changeAcl(pools[pool]->access);
                 allow_t answer = ch.fastCheck();
                 if (answer == ACCESS_ALLOWED) {
 
@@ -2515,8 +2516,8 @@ ConnStateData::start()
 
                     /* setup write limiter for this request */
                     const double burst = floor(0.5 +
-                                               (pools[pool].highwatermark * Config.ClientDelay.initial)/100.0);
-                    cli->setWriteLimiter(pools[pool].rate, burst, pools[pool].highwatermark);
+                                               (pools[pool]->highwatermark * Config.ClientDelay.initial)/100.0);
+                    cli->setWriteLimiter(pools[pool]->rate, burst, pools[pool]->highwatermark);
                     break;
                 } else {
                     debugs(83, 4, HERE << "Delay pool " << pool << " skipped because ACL " << answer);
@@ -3428,7 +3429,7 @@ ConnStateData::buildFakeRequest(Http::MethodType const method, SBuf &useHost, un
         request->header.putStr(Http::HOST, useHost.c_str());
     request->flags.intercepted = ((clientConnection->flags & COMM_INTERCEPTION) != 0);
     request->flags.interceptTproxy = ((clientConnection->flags & COMM_TRANSPARENT) != 0 );
-    request->sources |= ((switchedToHttps() || port->transport.protocol == AnyP::PROTO_HTTPS) ? HttpMsg::srcHttps : HttpMsg::srcHttp);
+    request->sources |= ((switchedToHttps() || port->transport.protocol == AnyP::PROTO_HTTPS) ? Http::Message::srcHttps : Http::Message::srcHttp);
 #if USE_AUTH
     if (getAuth())
         request->auth_user_request = getAuth();
@@ -27,6 +27,9 @@
 #include "security/Handshake.h"
 #include "ssl/support.h"
 #endif
+#if USE_DELAY_POOLS
+#include "MessageBucket.h"
+#endif
 
 class ClientHttpRequest;
 class HttpHdrRangeSpec;
@@ -1452,6 +1452,13 @@ ClientRequestContext::sslBumpAccessCheck()
         return false;
     }
 
+    if (error) {
+        debugs(85, 5, "SslBump applies. Force bump action on error " << errorTypeName(error->type));
+        http->sslBumpNeed(Ssl::bumpBump);
+        http->al->ssl.bumpMode = Ssl::bumpBump;
+        return false;
+    }
+
     debugs(85, 5, HERE << "SslBump possible, checking ACL");
 
     ACLFilledChecklist *aclChecklist = clientAclChecklistCreate(Config.accessList.ssl_bump, http);
@@ -1788,8 +1795,9 @@ ClientHttpRequest::doCallouts()
     }
 
 #if USE_OPENSSL
-    // We need to check for SslBump even if the calloutContext->error is set
-    // because bumping may require delaying the error until after CONNECT.
+    // Even with calloutContext->error, we call sslBumpAccessCheck() to decide
+    // whether SslBump applies to this transaction. If it applies, we will
+    // attempt to bump the client to serve the error.
     if (!calloutContext->sslBumpCheckDone) {
         calloutContext->sslBumpCheckDone = true;
         if (calloutContext->sslBumpAccessCheck())
@@ -1875,7 +1883,7 @@ ClientHttpRequest::noteAdaptationAnswer(const Adaptation::Answer &answer)
 
     switch (answer.kind) {
     case Adaptation::Answer::akForward:
-        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
+        handleAdaptedHeader(const_cast<Http::Message*>(answer.message.getRaw()));
         break;
 
     case Adaptation::Answer::akBlock:
@@ -1889,7 +1897,7 @@ ClientHttpRequest::noteAdaptationAnswer(const Adaptation::Answer &answer)
 }
 
 void
-ClientHttpRequest::handleAdaptedHeader(HttpMsg *msg)
+ClientHttpRequest::handleAdaptedHeader(Http::Message *msg)
 {
     assert(msg);
 
@@ -13,14 +13,14 @@
 #include "acl/forward.h"
 #include "client_side.h"
 #include "clientStream.h"
+#include "http/forward.h"
 #include "HttpHeaderRange.h"
 #include "LogTags.h"
 #include "Store.h"
 
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
-class HttpMsg;
 #endif
 
 class ClientRequestContext;
@@ -168,7 +168,7 @@ class ClientHttpRequest
 
     // Adaptation::Initiator API
     virtual void noteAdaptationAnswer(const Adaptation::Answer &answer);
-    void handleAdaptedHeader(HttpMsg *msg);
+    void handleAdaptedHeader(Http::Message *msg);
     void handleAdaptationBlock(const Adaptation::Answer &answer);
     virtual void noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer group);
 
@@ -464,7 +464,7 @@ sameUrlHosts(const char *url1, const char *url2)
 
 // purges entries that match the value of a given HTTP [response] header
 static void
-purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, Http::HdrType hdr)
+purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, Http::Message *rep, Http::HdrType hdr)
 {
     const char *hdrUrl, *absUrl;
 
@@ -681,7 +681,7 @@ Client::noteAdaptationAnswer(const Adaptation::Answer &answer)
 
     switch (answer.kind) {
     case Adaptation::Answer::akForward:
-        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
+        handleAdaptedHeader(const_cast<Http::Message*>(answer.message.getRaw()));
         break;
 
     case Adaptation::Answer::akBlock:
@@ -695,7 +695,7 @@ Client::noteAdaptationAnswer(const Adaptation::Answer &answer)
 }
 
 void
-Client::handleAdaptedHeader(HttpMsg *msg)
+Client::handleAdaptedHeader(Http::Message *msg)
 {
     if (abortOnBadEntry("entry went bad while waiting for adapted headers")) {
         // If the adapted response has a body, the ICAP side needs to know
@@ -13,15 +13,13 @@
 #include "BodyPipe.h"
 #include "CommCalls.h"
 #include "FwdState.h"
+#include "http/forward.h"
 #include "StoreIOBuffer.h"
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
 #endif
 
-class HttpMsg;
-class HttpReply;
-
 /**
  * Client is a common base for classes such as HttpStateData and FtpStateData.
  * All such classes must be able to consume request bodies from a BodyPipe
@@ -127,7 +125,7 @@ class Client:
     void handleAdaptedBodyProductionEnded();
     void handleAdaptedBodyProducerAborted();
 
-    void handleAdaptedHeader(HttpMsg *msg);
+    void handleAdaptedHeader(Http::Message *msg);
     void handleAdaptationCompleted();
     void handleAdaptationBlocked(const Adaptation::Answer &answer);
     void handleAdaptationAborted(bool bypassable = false);
@@ -27,7 +27,6 @@
 #include "HttpHeader.h"
 #include "HttpHeaderRange.h"
 #include "HttpReply.h"
-#include "HttpRequest.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
 #include "mime.h"
@@ -189,7 +188,7 @@ typedef struct {
     char *link;
 } ftpListParts;
 
-#define CTRL_BUFLEN 1024
+#define CTRL_BUFLEN 16*1024
 static char cbuf[CTRL_BUFLEN];
 
 /*
@@ -1744,7 +1743,7 @@ Ftp::Gateway::dataChannelConnected(const CommConnectCbParams &io)
 
         // ABORT on timeouts. server may be waiting on a broken TCP link.
         if (io.xerrno == Comm::TIMEOUT)
-            writeCommand("ABOR");
+            writeCommand("ABOR\r\n");
 
         // try another connection attempt with some other method
         ftpSendPassive(this);
@@ -2616,7 +2615,7 @@ Ftp::Gateway::appendSuccessHeader()
     if (mime_enc)
         reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);
 
-    reply->sources |= HttpMsg::srcFtp;
+    reply->sources |= Http::Message::srcFtp;
     setVirginReply(reply);
     adaptOrFinalizeReply();
 }
@@ -377,7 +377,7 @@ Ftp::Relay::forwardReply()
     EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
 
     HttpReply *const reply = createHttpReply(Http::scNoContent);
-    reply->sources |= HttpMsg::srcFtp;
+    reply->sources |= Http::Message::srcFtp;
 
     setVirginReply(reply);
     adaptOrFinalizeReply();
@@ -450,7 +450,7 @@ Ftp::Relay::startDataDownload()
            " (" << data.conn->local << ")");
 
     HttpReply *const reply = createHttpReply(Http::scOkay, -1);
-    reply->sources |= HttpMsg::srcFtp;
+    reply->sources |= Http::Message::srcFtp;
 
     EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
     setVirginReply(reply);
@@ -901,12 +901,9 @@ _comm_close(int fd, char const *file, int line)
     }
 
 #if USE_DELAY_POOLS
-    if (ClientInfo *clientInfo = F->clientInfo) {
-        if (clientInfo->selectWaiting) {
-            clientInfo->selectWaiting = false;
-            // kick queue or it will get stuck as commWriteHandle is not called
-            clientInfo->kickQuotaQueue();
-        }
+    if (BandwidthBucket *bucket = BandwidthBucket::SelectBucket(F)) {
+        if (bucket->selectWaiting)
+            bucket->onFdClosed();
     }
 #endif
 
@@ -1334,7 +1331,7 @@ ClientInfo::kickQuotaQueue()
 {
     if (!eventWaiting && !selectWaiting && hasQueue()) {
         // wait at least a second if the bucket is empty
-        const double delay = (bucketSize < 1.0) ? 1.0 : 0.0;
+        const double delay = (bucketLevel < 1.0) ? 1.0 : 0.0;
         eventAdd("commHandleWriteHelper", &commHandleWriteHelper,
                  quotaQueue, delay, 0, true);
         eventWaiting = true;
@@ -1343,7 +1340,7 @@ ClientInfo::kickQuotaQueue()
 
 /// calculates how much to write for a single dequeued client
 int
-ClientInfo::quotaForDequed()
+ClientInfo::quota()
 {
     /* If we have multiple clients and give full bucketSize to each client then
      * clt1 may often get a lot more because clt1->clt2 time distance in the
@@ -1359,7 +1356,7 @@ ClientInfo::quotaForDequed()
 
         // Rounding errors do not accumulate here, but we round down to avoid
         // negative bucket sizes after write with rationedCount=1.
-        rationedQuota = static_cast<int>(floor(bucketSize/rationedCount));
+        rationedQuota = static_cast<int>(floor(bucketLevel/rationedCount));
         debugs(77,5, HERE << "new rationedQuota: " << rationedQuota <<
                '*' << rationedCount);
     }
@@ -1373,48 +1370,50 @@ ClientInfo::quotaForDequed()
     return rationedQuota;
 }
 
-///< adds bytes to the quota bucket based on the rate and passed time
+bool
+ClientInfo::applyQuota(int &nleft, Comm::IoCallback *state)
+{
+    assert(hasQueue());
+    assert(quotaPeekFd() == state->conn->fd);
+    quotaDequeue(); // we will write or requeue below
+    if (nleft > 0 && !BandwidthBucket::applyQuota(nleft, state)) {
+        state->quotaQueueReserv = quotaEnqueue(state->conn->fd);
+        kickQuotaQueue();
+        return false;
+    }
+    return true;
+}
+
 void
-ClientInfo::refillBucket()
+ClientInfo::scheduleWrite(Comm::IoCallback *state)
 {
-    // all these times are in seconds, with double precision
-    const double currTime = current_dtime;
-    const double timePassed = currTime - prevTime;
-
-    // Calculate allowance for the time passed. Use double to avoid
-    // accumulating rounding errors for small intervals. For example, always
-    // adding 1 byte instead of 1.4 results in 29% bandwidth allocation error.
-    const double gain = timePassed * writeSpeedLimit;
-
-    debugs(77,5, HERE << currTime << " clt" << (const char*)hash.key << ": " <<
-           bucketSize << " + (" << timePassed << " * " << writeSpeedLimit <<
-           " = " << gain << ')');
-
-    // to further combat error accumulation during micro updates,
-    // quit before updating time if we cannot add at least one byte
-    if (gain < 1.0)
-        return;
-
-    prevTime = currTime;
-
-    // for "first" connections, drain initial fat before refilling but keep
-    // updating prevTime to avoid bursts after the fat is gone
-    if (bucketSize > bucketSizeLimit) {
-        debugs(77,4, HERE << "not refilling while draining initial fat");
-        return;
+    if (writeLimitingActive) {
+        state->quotaQueueReserv = quotaEnqueue(state->conn->fd);
+        kickQuotaQueue();
     }
+}
 
-    bucketSize += gain;
+void
+ClientInfo::onFdClosed()
+{
+    BandwidthBucket::onFdClosed();
+    // kick queue or it will get stuck as commWriteHandle is not called
+    kickQuotaQueue();
+}
 
-    // obey quota limits
-    if (bucketSize > bucketSizeLimit)
-        bucketSize = bucketSizeLimit;
+void
+ClientInfo::reduceBucket(const int len)
+{
+    if (len > 0)
+        BandwidthBucket::reduceBucket(len);
+    // even if we wrote nothing, we were served; give others a chance
+    kickQuotaQueue();
 }
 
 void
 ClientInfo::setWriteLimiter(const int aWriteSpeedLimit, const double anInitialBurst, const double aHighWatermark)
 {
-    debugs(77,5, HERE << "Write limits for " << (const char*)hash.key <<
+    debugs(77,5, "Write limits for " << (const char*)key <<
            " speed=" << aWriteSpeedLimit << " burst=" << anInitialBurst <<
            " highwatermark=" << aHighWatermark);
 
@@ -1431,7 +1430,7 @@ ClientInfo::setWriteLimiter(const int aWriteSpeedLimit, const double anInitialBu
         assert(!quotaQueue);
         quotaQueue = new CommQuotaQueue(this);
 
-        bucketSize = anInitialBurst;
+        bucketLevel = anInitialBurst;
         prevTime = current_dtime;
     }
 }
@@ -1451,7 +1450,7 @@ CommQuotaQueue::~CommQuotaQueue()
 unsigned int
 CommQuotaQueue::enqueue(int fd)
 {
-    debugs(77,5, HERE << "clt" << (const char*)clientInfo->hash.key <<
+    debugs(77,5, "clt" << (const char*)clientInfo->key <<
            ": FD " << fd << " with qqid" << (ins+1) << ' ' << fds.size());
     fds.push_back(fd);
     return ++ins;
@@ -1462,13 +1461,13 @@ void
 CommQuotaQueue::dequeue()
 {
     assert(!fds.empty());
-    debugs(77,5, HERE << "clt" << (const char*)clientInfo->hash.key <<
+    debugs(77,5, "clt" << (const char*)clientInfo->key <<
            ": FD " << fds.front() << " with qqid" << (outs+1) << ' ' <<
            fds.size());
     fds.pop_front();
     ++outs;
 }
-#endif
+#endif /* USE_DELAY_POOLS */
 
 /*
  * hm, this might be too general-purpose for all the places we'd
@@ -1576,7 +1575,16 @@ checkTimeouts(void)
             debugs(5, 5, "checkTimeouts: FD " << fd << " auto write timeout");
             Comm::SetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
             COMMIO_FD_WRITECB(fd)->finish(Comm::COMM_ERROR, ETIMEDOUT);
-        } else if (AlreadyTimedOut(F))
+#if USE_DELAY_POOLS
+        } else if (F->writeQuotaHandler != nullptr && COMMIO_FD_WRITECB(fd)->conn != nullptr) {
+            if (!F->writeQuotaHandler->selectWaiting && F->writeQuotaHandler->quota() && !F->closing()) {
+                F->writeQuotaHandler->selectWaiting = true;
+                Comm::SetSelect(fd, COMM_SELECT_WRITE, Comm::HandleWrite, COMMIO_FD_WRITECB(fd), 0);
+            }
+            continue;
+#endif
+        }
+        else if (AlreadyTimedOut(F))
             continue;
 
         debugs(5, 5, "checkTimeouts: FD " << fd << " Expired");
@@ -69,13 +69,9 @@ void
 Comm::IoCallback::selectOrQueueWrite()
 {
 #if USE_DELAY_POOLS
-    // stand in line if there is one
-    if (ClientInfo *clientInfo = fd_table[conn->fd].clientInfo) {
-        if (clientInfo->writeLimitingActive) {
-            quotaQueueReserv = clientInfo->quotaEnqueue(conn->fd);
-            clientInfo->kickQuotaQueue();
-            return;
-        }
+    if (BandwidthBucket *bucket = BandwidthBucket::SelectBucket(&fd_table[conn->fd])) {
+        bucket->scheduleWrite(this);
+        return;
     }
 #endif
 
@@ -24,9 +24,6 @@ namespace Comm
 /// Initialize the module on Squid startup
 void SelectLoopInit(void);
 
-/// Mark an FD to be watched for its IO status.
-void SetSelect(int, unsigned int, PF *, void *, time_t);
-
 /// reset/undo/unregister the watch for an FD which was set by Comm::SetSelect()
 void ResetSelect(int);
 
@@ -7,8 +7,10 @@
  */
 
 #include "squid.h"
+#include "cbdata.h"
 #include "comm/Connection.h"
 #include "comm/IoCallback.h"
+#include "comm/Loops.h"
 #include "comm/Write.h"
 #include "fd.h"
 #include "fde.h"
@@ -59,7 +61,8 @@ Comm::HandleWrite(int fd, void *data)
     int len = 0;
     int nleft;
 
-    assert(state->conn != NULL && state->conn->fd == fd);
+    assert(state->conn != NULL);
+    assert(state->conn->fd == fd);
 
     PROF_start(commHandleWrite);
     debugs(5, 5, HERE << state->conn << ": off " <<
@@ -68,35 +71,13 @@ Comm::HandleWrite(int fd, void *data)
     nleft = state->size - state->offset;
 
 #if USE_DELAY_POOLS
-    ClientInfo * clientInfo=fd_table[fd].clientInfo;
-
-    if (clientInfo && !clientInfo->writeLimitingActive)
-        clientInfo = NULL; // we only care about quota limits here
-
-    if (clientInfo) {
-        assert(clientInfo->selectWaiting);
-        clientInfo->selectWaiting = false;
-
-        assert(clientInfo->hasQueue());
-        assert(clientInfo->quotaPeekFd() == fd);
-        clientInfo->quotaDequeue(); // we will write or requeue below
-
-        if (nleft > 0) {
-            const int quota = clientInfo->quotaForDequed();
-            if (!quota) {  // if no write quota left, queue this fd
-                state->quotaQueueReserv = clientInfo->quotaEnqueue(fd);
-                clientInfo->kickQuotaQueue();
-                PROF_stop(commHandleWrite);
-                return;
-            }
-
-            const int nleft_corrected = min(nleft, quota);
-            if (nleft != nleft_corrected) {
-                debugs(5, 5, HERE << state->conn << " writes only " <<
-                       nleft_corrected << " out of " << nleft);
-                nleft = nleft_corrected;
-            }
-
+    BandwidthBucket *bucket = BandwidthBucket::SelectBucket(&fd_table[fd]);
+    if (bucket) {
+        assert(bucket->selectWaiting);
+        bucket->selectWaiting = false;
+        if (nleft > 0 && !bucket->applyQuota(nleft, state)) {
+            PROF_stop(commHandleWrite);
+            return;
         }
     }
 #endif /* USE_DELAY_POOLS */
@@ -108,18 +89,9 @@ Comm::HandleWrite(int fd, void *data)
     debugs(5, 5, HERE << "write() returns " << len);
 
 #if USE_DELAY_POOLS
-    if (clientInfo) {
-        if (len > 0) {
-            /* we wrote data - drain them from bucket */
-            clientInfo->bucketSize -= len;
-            if (clientInfo->bucketSize < 0.0) {
-                debugs(5, DBG_IMPORTANT, HERE << "drained too much"); // should not happen
-                clientInfo->bucketSize = 0;
-            }
-        }
-
-        // even if we wrote nothing, we were served; give others a chance
-        clientInfo->kickQuotaQueue();
+    if (bucket) {
+        /* we wrote data - drain them from bucket */
+        bucket->reduceBucket(len);
     }
 #endif /* USE_DELAY_POOLS */
 
@@ -34,9 +34,6 @@ void Write(const Comm::ConnectionPointer &conn, MemBuf *mb, AsyncCall::Pointer &
 /// Cancel the write pending on FD. No action if none pending.
 void WriteCancel(const Comm::ConnectionPointer &conn, const char *reason);
 
-// callback handler to process an FD which is available for writing.
-extern PF HandleWrite;
-
 } // namespace Comm
 
 #endif /* _SQUID_COMM_IOWRITE_H */
@@ -13,6 +13,10 @@
 
 #include <vector>
 
+/// legacy CBDATA callback functions ABI definition for read or write I/O events
+/// \deprecated use CommCalls API instead where possible
+typedef void PF(int, void *);
+
 /// Abstraction layer for TCP, UDP, TLS, UDS and filedescriptor sockets.
 namespace Comm
 {
@@ -26,11 +30,13 @@ typedef std::vector<Comm::ConnectionPointer> ConnectionList;
 
 bool IsConnOpen(const Comm::ConnectionPointer &conn);
 
-}; // namespace Comm
+// callback handler to process an FD which is available for writing.
+PF HandleWrite;
 
-/// legacy CBDATA callback functions ABI definition for read or write I/O events
-/// \deprecated use CommCalls API instead where possible
-typedef void PF(int, void *);
+/// Mark an FD to be watched for its IO status.
+void SetSelect(int, unsigned int, PF *, void *, time_t);
+
+}; // namespace Comm
 
 #endif /* _SQUID_COMM_FORWARD_H */
 
@@ -105,27 +105,8 @@ class idns_query
     CBDATA_CLASS(idns_query);
 
 public:
-    idns_query() :
-        sz(0),
-        query_id(0),
-        nsends(0),
-        need_vc(0),
-        permit_mdns(false),
-        pending(0),
-        callback(NULL),
-        callback_data(NULL),
-        attempt(0),
-        rcode(0),
-        queue(NULL),
-        slave(NULL),
-        master(NULL),
-        domain(0),
-        do_searchpath(0),
-        message(NULL),
-        ancount(0),
-        error(NULL)
-    {
-        memset(&hash, 0, sizeof(hash));
+    idns_query() {
+        callback = nullptr;
         memset(&query, 0, sizeof(query));
         *buf = 0;
         *name = 0;
@@ -149,31 +130,31 @@ class idns_query
     char buf[RESOLV_BUFSZ];
     char name[NS_MAXDNAME + 1];
     char orig[NS_MAXDNAME + 1];
-    ssize_t sz;
-    unsigned short query_id; /// random query ID sent to server; changes with every query sent
-    InstanceId<idns_query> xact_id; /// identifies our "transaction", stays constant when query is retried
+    ssize_t sz = 0;
+    unsigned short query_id = 0; ///< random query ID sent to server; changes with every query sent
+    InstanceId<idns_query> xact_id; ///< identifies our "transaction", stays constant when query is retried
 
-    int nsends;
-    int need_vc;
-    bool permit_mdns;
-    int pending;
+    int nsends = 0;
+    int need_vc = 0;
+    bool permit_mdns = false;
+    int pending = 0;
 
     struct timeval start_t;
     struct timeval sent_t;
     struct timeval queue_t;
     dlink_node lru;
     IDNSCB *callback;
-    void *callback_data;
-    int attempt;
-    int rcode;
-    idns_query *queue;
-    idns_query *slave;  // single linked list
-    idns_query *master; // single pointer to a shared master
-    unsigned short domain;
-    unsigned short do_searchpath;
-    rfc1035_message *message;
-    int ancount;
-    const char *error;
+    void *callback_data = nullptr;
+    int attempt = 0;
+    int rcode = 0;
+    idns_query *queue = nullptr;
+    idns_query *slave = nullptr;  // single linked list
+    idns_query *master = nullptr; // single pointer to a shared master
+    unsigned short domain = 0;
+    unsigned short do_searchpath = 0;
+    rfc1035_message *message = nullptr;
+    int ancount = 0;
+    const char *error = nullptr;
 };
 
 InstanceIdDefinitions(idns_query,  "dns");
@@ -185,16 +166,16 @@ class nsvc
     CBDATA_CLASS(nsvc);
 
 public:
-    explicit nsvc(int nsv) : ns(nsv), msglen(0), read_msglen(0), msg(new MemBuf()), queue(new MemBuf()), busy(true) {}
+    explicit nsvc(int nsv) : ns(nsv), msg(new MemBuf()), queue(new MemBuf()) {}
     ~nsvc();
 
-    int ns;
+    int ns = 0;
     Comm::ConnectionPointer conn;
-    unsigned short msglen;
-    int read_msglen;
-    MemBuf *msg;
-    MemBuf *queue;
-    bool busy;
+    unsigned short msglen = 0;
+    int read_msglen = 0;
+    MemBuf *msg = nullptr;
+    MemBuf *queue = nullptr;
+    bool busy = true;
 };
 
 CBDATA_CLASS_INIT(nsvc);
@@ -435,9 +416,9 @@ static bool
 idnsParseNameservers(void)
 {
     bool result = false;
-    for (wordlist *w = Config.dns_nameservers; w; w = w->next) {
-        debugs(78, DBG_IMPORTANT, "Adding nameserver " << w->key << " from squid.conf");
-        idnsAddNameserver(w->key);
+    for (auto &i : Config.dns.nameservers) {
+        debugs(78, DBG_IMPORTANT, "Adding nameserver " << i << " from squid.conf");
+        idnsAddNameserver(i.c_str());
         result = true;
     }
     return result;
@@ -123,14 +123,6 @@ enum {
     STORE_LOG_SWAPOUTFAIL
 };
 
-/* parse state of HttpReply or HttpRequest */
-typedef enum {
-    psReadyToParseStartLine = 0,
-    psReadyToParseHeaders,
-    psParsed,
-    psError
-} HttpMsgParseState;
-
 enum {
     PCTILE_HTTP,
     PCTILE_ICP_QUERY,
@@ -420,7 +420,7 @@ TemplateFile::loadFor(const HttpRequest *request)
     if (loaded()) // already loaded?
         return true;
 
-    if (!request || !request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr) )
+    if (!request || !request->header.getList(Http::HdrType::ACCEPT_LANGUAGE, &hdr))
         return false;
 
     char lang[256];
@@ -550,47 +550,24 @@ errorPageName(int pageId)
 }
 
 ErrorState *
-ErrorState::NewForwarding(err_type type, HttpRequest *request)
+ErrorState::NewForwarding(err_type type, HttpRequestPointer &request)
 {
-    assert(request);
-    const Http::StatusCode status = request->flags.needValidation ?
+    const Http::StatusCode status = (request && request->flags.needValidation) ?
                                     Http::scGatewayTimeout : Http::scServiceUnavailable;
-    return new ErrorState(type, status, request);
+    return new ErrorState(type, status, request.getRaw());
 }
 
 ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
     type(t),
     page_id(t),
-    err_language(NULL),
     httpStatus(status),
-#if USE_AUTH
-    auth_user_request (NULL),
-#endif
-    request(NULL),
-    url(NULL),
-    xerrno(0),
-    port(0),
-    dnsError(),
-    ttl(0),
-    src_addr(),
-    redirect_url(NULL),
-    callback(NULL),
-    callback_data(NULL),
-    request_hdrs(NULL),
-    err_msg(NULL),
-#if USE_OPENSSL
-    detail(NULL),
-#endif
-    detailCode(ERR_DETAIL_NONE)
+    callback(nullptr)
 {
-    memset(&ftp, 0, sizeof(ftp));
-
     if (page_id >= ERR_MAX && ErrorDynamicPages[page_id - ERR_MAX]->page_redirect != Http::scNone)
         httpStatus = ErrorDynamicPages[page_id - ERR_MAX]->page_redirect;
 
-    if (req != NULL) {
+    if (req) {
         request = req;
-        HTTPMSGLOCK(request);
         src_addr = req->client_addr;
     }
 }
@@ -631,19 +608,16 @@ errorAppendEntry(StoreEntry * entry, ErrorState * err)
 void
 errorSend(const Comm::ConnectionPointer &conn, ErrorState * err)
 {
-    HttpReply *rep;
-    debugs(4, 3, HERE << conn << ", err=" << err);
+    debugs(4, 3, conn << ", err=" << err);
     assert(Comm::IsConnOpen(conn));
 
-    rep = err->BuildHttpReply();
+    HttpReplyPointer rep(err->BuildHttpReply());
 
     MemBuf *mb = rep->pack();
     AsyncCall::Pointer call = commCbCall(78, 5, "errorSendComplete",
                                          CommIoCbPtrFun(&errorSendComplete, err));
     Comm::Write(conn, mb, call);
     delete mb;
-
-    delete rep;
 }
 
 /**
@@ -676,16 +650,12 @@ errorSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm
 
 ErrorState::~ErrorState()
 {
-    HTTPMSGUNLOCK(request);
     safe_free(redirect_url);
     safe_free(url);
     safe_free(request_hdrs);
     wordlistDestroy(&ftp.server_msg);
     safe_free(ftp.request);
     safe_free(ftp.reply);
-#if USE_AUTH
-    auth_user_request = NULL;
-#endif
     safe_free(err_msg);
 #if USE_ERR_LOCALES
     if (err_language != Config.errorDefaultLanguage)
@@ -781,7 +751,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'a':
 #if USE_AUTH
-        if (request && request->auth_user_request != NULL)
+        if (request && request->auth_user_request)
             p = request->auth_user_request->username();
         if (!p)
 #endif
@@ -795,7 +765,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'B':
         if (building_deny_info_url) break;
         if (request) {
-            const SBuf &tmp = Ftp::UrlWith2f(request);
+            const SBuf &tmp = Ftp::UrlWith2f(request.getRaw());
             mb.append(tmp.rawContent(), tmp.length());
         } else
             p = "[no URL]";
@@ -812,7 +782,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 #if USE_OPENSSL
         // currently only SSL error details implemented
         else if (detail) {
-            detail->useRequest(request);
+            detail->useRequest(request.getRaw());
             const String &errDetail = detail->toString();
             if (errDetail.size() > 0) {
                 MemBuf *detail_mb  = ConvertText(errDetail.termedBuf(), false);
@@ -885,7 +855,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'I':
-        if (request && request->hier.tcpServer != NULL)
+        if (request && request->hier.tcpServer)
             p = request->hier.tcpServer->remote.toStr(ntoabuf,MAX_IPSTRLEN);
         else if (!building_deny_info_url)
             p = "[unknown]";
@@ -962,7 +932,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
                 p = "[no request]";
             break;
         }
-        if (request != NULL) {
+        if (request) {
             mb.appendf(SQUIDSBUFPH " " SQUIDSBUFPH " %s/%d.%d\n",
                        SQUIDSBUFPRINT(request->method.image()),
                        SQUIDSBUFPRINT(request->url.path()),
@@ -1022,7 +992,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         /* Using the fake-https version of absolute-URI so error pages see https:// */
         /* even when the url-path cannot be shown as more than '*' */
         if (request)
-            p = urlCanonicalFakeHttps(request);
+            p = urlCanonicalFakeHttps(request.getRaw());
         else if (url)
             p = url;
         else if (!building_deny_info_url)
@@ -1145,7 +1115,7 @@ ErrorState::BuildHttpReply()
             status = httpStatus;
         else {
             // Use 307 for HTTP/1.1 non-GET/HEAD requests.
-            if (request != NULL && request->method != Http::METHOD_GET && request->method != Http::METHOD_HEAD && request->http_ver >= Http::ProtocolVersion(1,1))
+            if (request && request->method != Http::METHOD_GET && request->method != Http::METHOD_HEAD && request->http_ver >= Http::ProtocolVersion(1,1))
                 status = Http::scTemporaryRedirect;
         }
 
@@ -1154,7 +1124,7 @@ ErrorState::BuildHttpReply()
         if (request) {
             MemBuf redirect_location;
             redirect_location.init();
-            DenyInfoLocation(name, request, redirect_location);
+            DenyInfoLocation(name, request.getRaw(), redirect_location);
             httpHeaderPutStrf(&rep->header, Http::HdrType::LOCATION, "%s", redirect_location.content() );
         }
 
@@ -1239,7 +1209,7 @@ ErrorState::BuildContent()
             safe_free(err_language);
 
         localeTmpl = new ErrorPageFile(err_type_str[page_id], static_cast<err_type>(page_id));
-        if (localeTmpl->loadFor(request)) {
+        if (localeTmpl->loadFor(request.getRaw())) {
             m = localeTmpl->text();
             assert(localeTmpl->language());
             err_language = xstrdup(localeTmpl->language());
@@ -15,6 +15,7 @@
 #include "comm/forward.h"
 #include "err_detail_type.h"
 #include "err_type.h"
+#include "http/forward.h"
 #include "http/StatusCode.h"
 #include "ip/Address.h"
 #include "SquidString.h"
@@ -69,8 +70,6 @@ typedef void ERCB(int fd, void *, size_t);
  \endverbatim
  */
 
-class HttpReply;
-class HttpRequest;
 class MemBuf;
 class StoreEntry;
 class wordlist;
@@ -82,11 +81,11 @@ class ErrorState
 
 public:
     ErrorState(err_type type, Http::StatusCode, HttpRequest * request);
-    ErrorState(); // not implemented.
+    ErrorState() = delete; // not implemented.
     ~ErrorState();
 
     /// Creates a general request forwarding error with the right http_status.
-    static ErrorState *NewForwarding(err_type type, HttpRequest *request);
+    static ErrorState *NewForwarding(err_type, HttpRequestPointer &);
 
     /**
      * Allocates and initializes an error response
@@ -137,42 +136,42 @@ class ErrorState
     int Dump(MemBuf * mb);
 
 public:
-    err_type type;
-    int page_id;
-    char *err_language;
+    err_type type = ERR_NONE;
+    int page_id = ERR_NONE;
+    char *err_language = nullptr;
     Http::StatusCode httpStatus;
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
-    HttpRequest *request;
-    char *url;
-    int xerrno;
-    unsigned short port;
+    HttpRequestPointer request;
+    char *url = nullptr;
+    int xerrno = 0;
+    unsigned short port = 0;
     String dnsError; ///< DNS lookup error message
-    time_t ttl;
+    time_t ttl = 0;
 
     Ip::Address src_addr;
-    char *redirect_url;
+    char *redirect_url = nullptr;
     ERCB *callback;
-    void *callback_data;
+    void *callback_data = nullptr;
 
     struct {
-        wordlist *server_msg;
-        char *request;
-        char *reply;
-        char *cwd_msg;
-        MemBuf *listing;
+        wordlist *server_msg = nullptr;
+        char *request = nullptr;
+        char *reply = nullptr;
+        char *cwd_msg = nullptr;
+        MemBuf *listing = nullptr;
     } ftp;
 
-    char *request_hdrs;
-    char *err_msg; /* Preformatted error message from the cache */
+    char *request_hdrs = nullptr;
+    char *err_msg = nullptr; /* Preformatted error message from the cache */
 
 #if USE_OPENSSL
-    Ssl::ErrorDetail *detail;
+    Ssl::ErrorDetail *detail = nullptr;
 #endif
     /// type-specific detail about the transaction error;
     /// overwrites xerrno; overwritten by detail, if any.
-    int detailCode;
+    int detailCode = ERR_DETAIL_NONE;
 };
 
 /**
@@ -17,6 +17,7 @@
 #include "typedefs.h" //DRCB, DWCB
 
 #if USE_DELAY_POOLS
+#include "MessageBucket.h"
 class ClientInfo;
 #endif
 class dwrite_q;
@@ -117,6 +118,7 @@ class fde
 #if USE_DELAY_POOLS
     /// pointer to client info used in client write limiter or nullptr if not present
     ClientInfo * clientInfo = nullptr;
+    MessageBucket::Pointer writeQuotaHandler; ///< response write limiter, if configured
 #endif
     unsigned epoll_state = 0;
 
@@ -335,10 +335,10 @@ sslErrorName(Security::ErrorCode err, char *buf, size_t size)
 /// \retval HttpReply sent to the HTTP client (access.log and default context).
 /// \retval HttpReply received (encapsulated) from the ICAP server (icap.log context).
 /// \retval HttpRequest received (encapsulated) from the ICAP server (icap.log context).
-static const HttpMsg *
+static const Http::Message *
 actualReplyHeader(const AccessLogEntry::Pointer &al)
 {
-    const HttpMsg *msg = al->reply;
+    const Http::Message *msg = al->reply;
 #if ICAP_CLIENT
     // al->icap.reqMethod is methodNone in access.log context
     if (!msg && al->icap.reqMethod == Adaptation::methodReqmod)
@@ -349,7 +349,7 @@ actualReplyHeader(const AccessLogEntry::Pointer &al)
 
 /// XXX: Misnamed. See actualReplyHeader().
 /// \return HttpRequest or HttpReply for %http::>h.
-static const HttpMsg *
+static const Http::Message *
 actualRequestHeader(const AccessLogEntry::Pointer &al)
 {
 #if ICAP_CLIENT
@@ -628,7 +628,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_REQUEST_HEADER:
-            if (const HttpMsg *msg = actualRequestHeader(al))
+            if (const Http::Message *msg = actualRequestHeader(al))
                 sb = msg->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
@@ -649,7 +649,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_REPLY_HEADER: {
-            if (const HttpMsg *msg = actualReplyHeader(al))
+            if (const Http::Message *msg = actualReplyHeader(al))
                 sb = msg->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
@@ -838,7 +838,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 #endif
         case LFT_REQUEST_HEADER_ELEM:
-            if (const HttpMsg *msg = actualRequestHeader(al))
+            if (const Http::Message *msg = actualRequestHeader(al))
                 sb = msg->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
@@ -858,7 +858,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_REPLY_HEADER_ELEM: {
-            if (const HttpMsg *msg = actualReplyHeader(al))
+            if (const Http::Message *msg = actualReplyHeader(al))
                 sb = msg->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
             out = sb.termedBuf();
@@ -15,7 +15,7 @@
 #include "sbuf/SBuf.h"
 
 // FTP does not have a notion of a "protocol version" but we need something for
-// compatibility with the current HttpMsg wrapping layer. We use version 1.1:
+// compatibility with the current Http::Message wrapping layer. We use version 1.1:
 // * some ICAP services probably expect /1.0 or /1.1 when parsing HTTP headers;
 // * FTP commands are sent on a "persistent by default" connection, just like
 //   HTTP/1.1. Using 1.1 leads to fewer exceptions in current code shared by
@@ -9,11 +9,10 @@
 #ifndef SQUID_FTP_ELEMENTS_H
 #define SQUID_FTP_ELEMENTS_H
 
+#include "http/forward.h"
 #include "http/StatusCode.h"
 #include "sbuf/forward.h"
 
-class HttpReply;
-
 namespace AnyP
 {
 class ProtocolVersion;
@@ -22,7 +21,7 @@ class ProtocolVersion;
 namespace Ftp
 {
 
-/// Protocol version to use in HttpMsg structures wrapping FTP messages.
+/// Protocol version to use in Http::Message structures wrapping FTP messages.
 AnyP::ProtocolVersion ProtocolVersion();
 
 /// Create an internal HttpReply structure to house FTP control response info.
@@ -777,7 +777,7 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm
         if (req->hier.bodyBytesRead < 0) {
             req->hier.bodyBytesRead = 0;
             // first bytes read, update Reply flags:
-            gopherState->reply_->sources |= HttpMsg::srcGopher;
+            gopherState->reply_->sources |= Http::Message::srcGopher;
         }
 
         req->hier.bodyBytesRead += len;
@@ -771,7 +771,7 @@ HttpStateData::processReplyHeader()
     // done with Parser, now process using the HttpReply
     hp = NULL;
 
-    newrep->sources |= request->url.getScheme() == AnyP::PROTO_HTTPS ? HttpMsg::srcHttps : HttpMsg::srcHttp;
+    newrep->sources |= request->url.getScheme() == AnyP::PROTO_HTTPS ? Http::Message::srcHttps : Http::Message::srcHttp;
 
     newrep->removeStaleWarnings();
 
@@ -17,6 +17,8 @@ libhttp_la_SOURCES = \
 	ContentLengthInterpreter.cc \
 	ContentLengthInterpreter.h \
 	forward.h \
+	Message.cc \
+	Message.h \
 	MethodType.cc \
 	MethodType.h \
 	ProtocolVersion.h \
@@ -10,32 +10,27 @@
 
 #include "squid.h"
 #include "Debug.h"
+#include "http/Message.h"
 #include "http/one/Parser.h"
 #include "HttpHdrCc.h"
 #include "HttpHeaderTools.h"
-#include "HttpMsg.h"
 #include "MemBuf.h"
 #include "mime_header.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
-HttpMsg::HttpMsg(http_hdr_owner_type owner):
+Http::Message::Message(http_hdr_owner_type owner):
     http_ver(Http::ProtocolVersion()),
-    header(owner),
-    cache_control(NULL),
-    hdr_sz(0),
-    content_length(0),
-    pstate(psReadyToParseStartLine),
-    sources(0)
+    header(owner)
 {}
 
-HttpMsg::~HttpMsg()
+Http::Message::~Message()
 {
     assert(!body_pipe);
 }
 
 void
-HttpMsg::putCc(const HttpHdrCc *otherCc)
+Http::Message::putCc(const HttpHdrCc *otherCc)
 {
     // get rid of the old CC, if any
     if (cache_control) {
@@ -53,13 +48,6 @@ HttpMsg::putCc(const HttpHdrCc *otherCc)
     }
 }
 
-HttpMsgParseState &operator++ (HttpMsgParseState &aState)
-{
-    int tmp = (int)aState;
-    aState = (HttpMsgParseState)(++tmp);
-    return aState;
-}
-
 /* find first CRLF */
 static int
 httpMsgIsolateStart(const char **parse_start, const char **blk_start, const char **blk_end)
@@ -88,7 +76,7 @@ httpMsgIsolateStart(const char **parse_start, const char **blk_start, const char
 // zero return means need more data
 // positive return is the size of parsed headers
 bool
-HttpMsg::parse(const char *buf, const size_t sz, bool eof, Http::StatusCode *error)
+Http::Message::parse(const char *buf, const size_t sz, bool eof, Http::StatusCode *error)
 {
     assert(error);
     *error = Http::scNone;
@@ -107,13 +95,13 @@ HttpMsg::parse(const char *buf, const size_t sz, bool eof, Http::StatusCode *err
     }
 
     if (hdr_len > Config.maxReplyHeaderSize || (hdr_len <= 0 && sz > Config.maxReplyHeaderSize)) {
-        debugs(58, DBG_IMPORTANT, "HttpMsg::parse: Too large reply header (" << hdr_len << " > " << Config.maxReplyHeaderSize);
+        debugs(58, DBG_IMPORTANT, "Too large reply header (" << hdr_len << " > " << Config.maxReplyHeaderSize);
         *error = Http::scHeaderTooLarge;
         return false;
     }
 
     if (hdr_len <= 0) {
-        debugs(58, 3, "HttpMsg::parse: failed to find end of headers (eof: " << eof << ") in '" << buf << "'");
+        debugs(58, 3, "failed to find end of headers (eof: " << eof << ") in '" << buf << "'");
 
         if (eof) // iff we have seen the end, this is an error
             *error = Http::scInvalidHeader;
@@ -124,39 +112,39 @@ HttpMsg::parse(const char *buf, const size_t sz, bool eof, Http::StatusCode *err
     const int res = httpMsgParseStep(buf, sz, eof);
 
     if (res < 0) { // error
-        debugs(58, 3, "HttpMsg::parse: cannot parse isolated headers in '" << buf << "'");
+        debugs(58, 3, "cannot parse isolated headers in '" << buf << "'");
         *error = Http::scInvalidHeader;
         return false;
     }
 
     if (res == 0) {
-        debugs(58, 2, "HttpMsg::parse: strange, need more data near '" << buf << "'");
+        debugs(58, 2, "strange, need more data near '" << buf << "'");
         *error = Http::scInvalidHeader;
         return false; // but this should not happen due to headersEnd() above
     }
 
     assert(res > 0);
-    debugs(58, 9, "HttpMsg::parse success (" << hdr_len << " bytes) near '" << buf << "'");
+    debugs(58, 9, "success (" << hdr_len << " bytes) near '" << buf << "'");
 
     if (hdr_sz != (int)hdr_len) {
-        debugs(58, DBG_IMPORTANT, "internal HttpMsg::parse vs. headersEnd error: " <<
+        debugs(58, DBG_IMPORTANT, "internal Http::Message::parse vs. headersEnd error: " <<
                hdr_sz << " != " << hdr_len);
         hdr_sz = (int)hdr_len; // because old http.cc code used hdr_len
     }
 
     return true;
 }
 
-/*
+/**
  * parseCharBuf() takes character buffer of HTTP headers (buf),
- * which may not be NULL-terminated, and fills in an HttpMsg
+ * which may not be NULL-terminated, and fills in an Http::Message
  * structure.  The parameter 'end' specifies the offset to
  * the end of the reply headers.  The caller may know where the
  * end is, but is unable to NULL-terminate the buffer.  This function
  * returns true on success.
  */
 bool
-HttpMsg::parseCharBuf(const char *buf, ssize_t end)
+Http::Message::parseCharBuf(const char *buf, ssize_t end)
 {
     MemBuf mb;
     int success;
@@ -170,28 +158,28 @@ HttpMsg::parseCharBuf(const char *buf, ssize_t end)
     return success == 1;
 }
 
-/*
- * parses a 0-terminating buffer into HttpMsg.
- * Returns:
- *      1 -- success
- *       0 -- need more data (partial parse)
- *      -1 -- parse error
+/**
+ * parses a 0-terminated buffer into Http::Message.
+ *
+ * \retval  1 success
+ * \retval  0 need more data (partial parse)
+ * \retval -1 parse error
  */
 int
-HttpMsg::httpMsgParseStep(const char *buf, int len, int atEnd)
+Http::Message::httpMsgParseStep(const char *buf, int len, int atEnd)
 {
     const char *parse_start = buf;
     int parse_len = len;
     const char *blk_start, *blk_end;
     const char **parse_end_ptr = &blk_end;
     assert(parse_start);
-    assert(pstate < psParsed);
+    assert(pstate < Http::Message::psParsed);
 
     *parse_end_ptr = parse_start;
 
     PROF_start(HttpMsg_httpMsgParseStep);
 
-    if (pstate == psReadyToParseStartLine) {
+    if (pstate == Http::Message::psReadyToParseStartLine) {
         if (!httpMsgIsolateStart(&parse_start, &blk_start, &blk_end)) {
             PROF_stop(HttpMsg_httpMsgParseStep);
             return 0;
@@ -207,15 +195,15 @@ HttpMsg::httpMsgParseStep(const char *buf, int len, int atEnd)
         hdr_sz = *parse_end_ptr - buf;
         parse_len = parse_len - hdr_sz;
 
-        ++pstate;
+        pstate = Http::Message::psReadyToParseHeaders;
     }
 
     /*
      * XXX This code uses parse_start; but if we're incrementally parsing then
      * this code might not actually be given parse_start at the right spot (just
      * after headers.) Grr.
      */
-    if (pstate == psReadyToParseHeaders) {
+    if (pstate == Http::Message::psReadyToParseHeaders) {
         size_t hsize = 0;
         const int parsed = header.parse(parse_start, parse_len, atEnd, hsize);
         if (parsed <= 0) {
@@ -224,49 +212,49 @@ HttpMsg::httpMsgParseStep(const char *buf, int len, int atEnd)
         }
         hdr_sz += hsize;
         hdrCacheInit();
-        ++pstate;
+        pstate = Http::Message::psParsed;
     }
 
     PROF_stop(HttpMsg_httpMsgParseStep);
     return 1;
 }
 
 bool
-HttpMsg::parseHeader(Http1::Parser &hp)
+Http::Message::parseHeader(Http1::Parser &hp)
 {
     // HTTP/1 message contains "zero or more header fields"
     // zero does not need parsing
     // XXX: c_str() reallocates. performance regression.
     if (hp.headerBlockSize() && !header.parse(hp.mimeHeader().c_str(), hp.headerBlockSize())) {
-        pstate = psError;
+        pstate = Http::Message::psError;
         return false;
     }
 
     // XXX: we are just parsing HTTP headers, not the whole message prefix here
     hdr_sz = hp.messageHeaderSize();
-    pstate = psParsed;
+    pstate = Http::Message::psParsed;
     hdrCacheInit();
     return true;
 }
 
 /* handy: resets and returns -1 */
 int
-HttpMsg::httpMsgParseError()
+Http::Message::httpMsgParseError()
 {
     reset();
     return -1;
 }
 
 void
-HttpMsg::setContentLength(int64_t clen)
+Http::Message::setContentLength(int64_t clen)
 {
     header.delById(Http::HdrType::CONTENT_LENGTH); // if any
     header.putInt64(Http::HdrType::CONTENT_LENGTH, clen);
     content_length = clen;
 }
 
 bool
-HttpMsg::persistent() const
+Http::Message::persistent() const
 {
     if (http_ver > Http::ProtocolVersion(1,0)) {
         /*
@@ -280,24 +268,25 @@ HttpMsg::persistent() const
     }
 }
 
-void HttpMsg::packInto(Packable *p, bool full_uri) const
+void
+Http::Message::packInto(Packable *p, bool full_uri) const
 {
     packFirstLineInto(p, full_uri);
     header.packInto(p);
     p->append("\r\n", 2);
 }
 
-void HttpMsg::hdrCacheInit()
+void
+Http::Message::hdrCacheInit()
 {
     content_length = header.getInt64(Http::HdrType::CONTENT_LENGTH);
     assert(NULL == cache_control);
     cache_control = header.getCc();
 }
 
-/*
- * useful for debugging
- */
-void HttpMsg::firstLineBuf(MemBuf& mb)
+/// useful for debugging
+void
+Http::Message::firstLineBuf(MemBuf &mb)
 {
     packFirstLineInto(&mb, true);
 }
@@ -6,8 +6,8 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_HTTPMSG_H
-#define SQUID_HTTPMSG_H
+#ifndef SQUID_HTTP_MESSAGE_H
+#define SQUID_HTTP_MESSAGE_H
 
 #include "base/Lock.h"
 #include "BodyPipe.h"
@@ -17,12 +17,13 @@
 #include "http/StatusCode.h"
 #include "HttpHeader.h"
 
-/// common parts of HttpRequest and HttpReply
-class HttpMsg : public RefCountable
+namespace Http
 {
 
+/// common parts of HttpRequest and HttpReply
+class Message : public RefCountable
+{
 public:
-    typedef RefCount<HttpMsg> Pointer;
     /// Who may have created or modified this message?
     enum Sources {
         srcUnknown = 0,
@@ -44,18 +45,18 @@ class HttpMsg : public RefCountable
         srcSafe = 0x0000FFFF ///< Safe sources mask
     };
 
-    HttpMsg(http_hdr_owner_type owner);
-    virtual ~HttpMsg();
+    Message(http_hdr_owner_type);
+    virtual ~Message();
 
     virtual void reset() = 0; // will have body when http*Clean()s are gone
 
-    void packInto(Packable * p, bool full_uri) const;
+    void packInto(Packable *, bool full_uri) const;
 
     ///< produce a message copy, except for a few connection-specific settings
-    virtual HttpMsg *clone() const = 0; ///< \todo rename: not a true copy?
+    virtual Http::Message *clone() const = 0; // TODO rename: not a true copy?
 
     /// [re]sets Content-Length header and cached value
-    void setContentLength(int64_t clen);
+    void setContentLength(int64_t);
 
     /**
      * \retval true  the message sender asks to keep the connection open.
@@ -72,20 +73,30 @@ class HttpMsg : public RefCountable
 
     HttpHeader header;
 
-    HttpHdrCc *cache_control;
+    HttpHdrCc *cache_control = nullptr;
 
     /* Unsupported, writable, may disappear/change in the future
      * For replies, sums _stored_ status-line, headers, and <CRLF>.
      * Also used to report parsed header size if parse() is successful */
-    int hdr_sz;
+    int hdr_sz = 0;
 
-    int64_t content_length;
+    int64_t content_length = 0;
 
-    HttpMsgParseState pstate;   /* the current parsing state */
+    /// parse state of HttpReply or HttpRequest
+    enum ParseState {
+        psReadyToParseStartLine = 0,
+        psReadyToParseHeaders,
+        psParsed,
+        psError
+    };
+
+    /// the current parsing state
+    ParseState pstate = Http::Message::psReadyToParseStartLine;
 
-    BodyPipe::Pointer body_pipe; // optional pipeline to receive message body
+    /// optional pipeline to receive message body
+    BodyPipe::Pointer body_pipe;
 
-    uint32_t sources; ///< The message sources
+    uint32_t sources = 0; ///< The message sources
 
     /// copies Cache-Control header to this message
     void putCc(const HttpHdrCc *otherCc);
@@ -108,7 +119,7 @@ class HttpMsg : public RefCountable
 
     void firstLineBuf(MemBuf&);
 
-    virtual bool inheritProperties(const HttpMsg *aMsg) = 0;
+    virtual bool inheritProperties(const Http::Message *) = 0;
 
 protected:
     /**
@@ -127,6 +138,8 @@ class HttpMsg : public RefCountable
     virtual void hdrCacheInit();
 };
 
+} // namespace Http
+
 #define HTTPMSGUNLOCK(a) if (a) { if ((a)->unlock() == 0) delete (a); (a)=NULL; }
 #define HTTPMSGLOCK(a) (a)->lock()
 
@@ -76,7 +76,7 @@ Http::StatusLine::parse(const String &protoPrefix, const char *start, const char
 {
     status_ = Http::scInvalidHeader;    /* Squid header parsing error */
 
-    // XXX: HttpMsg::parse() has a similar check but is using
+    // XXX: Http::Message::parse() has a similar check but is using
     // casesensitive comparison (which is required by HTTP errata?)
 
     if (protoPrefix.cmp("ICY", 3) == 0) {
@@ -13,6 +13,12 @@
 #include "HttpHeaderTools.h"
 #include "Store.h"
 #include "TimeOrTag.h"
+#if USE_DELAY_POOLS
+#include "acl/FilledChecklist.h"
+#include "ClientInfo.h"
+#include "fde.h"
+#include "MessageDelayPools.h"
+#endif
 
 Http::Stream::Stream(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
     clientConnection(aConn),
@@ -283,6 +289,24 @@ Http::Stream::sendStartOfMessage(HttpReply *rep, StoreIOBuffer bodyData)
             mb->append(bodyData.data, length);
         }
     }
+#if USE_DELAY_POOLS
+    for (const auto &pool: MessageDelayPools::Instance()->pools) {
+        if (pool->access) {
+            std::unique_ptr<ACLFilledChecklist> chl(clientAclChecklistCreate(pool->access, http));
+            chl->reply = rep;
+            HTTPMSGLOCK(chl->reply);
+            const allow_t answer = chl->fastCheck();
+            if (answer == ACCESS_ALLOWED) {
+                writeQuotaHandler = pool->createBucket();
+                fd_table[clientConnection->fd].writeQuotaHandler = writeQuotaHandler;
+                break;
+            } else {
+                debugs(83, 4, "Response delay pool " << pool->poolName <<
+                       " skipped because ACL " << answer);
+            }
+        }
+    }
+#endif
 
     getConn()->write(mb);
     delete mb;
@@ -12,6 +12,9 @@
 #include "http/forward.h"
 #include "mem/forward.h"
 #include "StoreIOBuffer.h"
+#if USE_DELAY_POOLS
+#include "MessageBucket.h"
+#endif
 
 class clientStreamNode;
 class ClientHttpRequest;
@@ -161,6 +164,9 @@ class Stream : public RefCountable
 
     bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
     bool connRegistered_;
+#if USE_DELAY_POOLS
+    MessageBucket::Pointer writeQuotaHandler; ///< response write limiter, if configured
+#endif
 };
 
 } // namespace Http
@@ -14,6 +14,9 @@
 namespace Http
 {
 
+class Message;
+typedef RefCount<Http::Message> MessagePointer;
+
 class Stream;
 typedef RefCount<Http::Stream> StreamPointer;
 
@@ -47,6 +47,7 @@ COPIED_SOURCE= \
 	SquidNew.cc \
 	stub_HelperChildConfig.cc \
 	stub_libmem.cc \
+	stub_SBuf.cc \
 	STUB.h \
 	time.cc
 
@@ -108,5 +109,8 @@ stub_HelperChildConfig.cc: $(top_srcdir)/src/tests/stub_HelperChildConfig.cc
 stub_libmem.cc: $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
 	cp $(top_srcdir)/src/tests/stub_libmem.cc $@
 
+stub_SBuf.cc: $(top_srcdir)/src/tests/stub_SBuf.cc STUB.h
+	cp $(top_srcdir)/src/tests/stub_SBuf.cc $@
+
 STUB.h: $(top_srcdir)/src/tests/STUB.h
 	cp $(top_srcdir)/src/tests/STUB.h $@
@@ -522,11 +522,11 @@ mainParseOptions(int argc, char *argv[])
             /** \par k
              * Run the administrative action given following the option */
 
-            /** \li When its an unknown option display the usage help. */
-            if ((int) strlen(optarg) < 1)
+            /** \li When it is missing or an unknown option display the usage help. */
+            if (!optarg || strlen(optarg) < 1)
                 usage();
 
-            if (!strncmp(optarg, "reconfigure", strlen(optarg)))
+            else if (!strncmp(optarg, "reconfigure", strlen(optarg)))
                 /** \li On reconfigure send SIGHUP. */
                 opt_send_signal = SIGHUP;
             else if (!strncmp(optarg, "rotate", strlen(optarg)))
@@ -545,6 +545,10 @@ Security::HandshakeParser::ParseCertificate(const SBuf &raw, Security::CertPoint
     pCert.resetWithoutLocking(x509);
     Must(x509); // successfully parsed
     Must(x509Pos == x509Start + raw.length()); // no leftovers
+#else
+    // workaround GCC -O3 error with unused variables. see bug 4663.
+    (void)pCert;
+    debugs(83, 2, "TLS parsing is not supported without OpenSSL. " << raw);
 #endif
 }
 
@@ -505,11 +505,7 @@ Security::PeerConnector::noteNegotiationError(const int ret, const int ssl_error
            ": " << Security::ErrorString(ssl_lib_error) << " (" <<
            ssl_error << "/" << ret << "/" << xerr << ")");
 
-    ErrorState *anErr = NULL;
-    if (request != NULL)
-        anErr = ErrorState::NewForwarding(ERR_SECURE_CONNECT_FAIL, request.getRaw());
-    else
-        anErr = new ErrorState(ERR_SECURE_CONNECT_FAIL, Http::scServiceUnavailable, NULL);
+    ErrorState *anErr = ErrorState::NewForwarding(ERR_SECURE_CONNECT_FAIL, request);
     anErr->xerrno = sysErrNo;
 
 #if USE_OPENSSL
@@ -1453,9 +1453,33 @@ Ftp::Server::createDataConnection(Ip::Address cltAddr)
     Comm::ConnectionPointer conn = new Comm::Connection();
     conn->flags |= COMM_DOBIND;
 
-    // Use local IP address of the control connection as the source address
-    // of the active data connection, or some clients will refuse to accept.
-    conn->setAddrs(clientConnection->local, cltAddr);
+    if (clientConnection->flags & COMM_INTERCEPTION) {
+        // In the case of NAT interception conn->local value is not set
+        // because the TCP stack will automatically pick correct source
+        // address for the data connection. We must only ensure that IP
+        // version matches client's address.
+        conn->local.setAnyAddr();
+
+        if (cltAddr.isIPv4())
+            conn->local.setIPv4();
+
+        conn->remote = cltAddr;
+    } else {
+        // In the case of explicit-proxy the local IP of the control connection
+        // is the Squid IP the client is knowingly talking to.
+        //
+        // In the case of TPROXY the IP address of the control connection is
+        // server IP the client is connecting to, it can be spoofed by Squid.
+        //
+        // In both cases some clients may refuse to accept data connections if
+        // these control connectin local-IP's are not used.
+        conn->setAddrs(clientConnection->local, cltAddr);
+
+        // Using non-local addresses in TPROXY mode requires appropriate socket option.
+        if (clientConnection->flags & COMM_TRANSPARENT)
+            conn->flags |= COMM_TRANSPARENT;
+    }
+
     // RFC 959 requires active FTP connections to originate from port 20
     // but that would preclude us from supporting concurrent transfers! (XXX?)
     conn->local.port(0);
@@ -12,22 +12,22 @@
 #define STUB_API "HttpReply.cc"
 #include "tests/STUB.h"
 
-HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
+HttpReply::HttpReply() : Http::Message(hoReply), date (0), last_modified (0),
     expires (0), surrogate_control (NULL), content_range (NULL), keep_alive (0),
     protoPrefix("HTTP/"), do_clean(false), bodySizeMax(-2)
-    STUB_NOP
-    HttpReply::~HttpReply() STUB
-    void HttpReply::setHeaders(Http::StatusCode status, const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires_) STUB
-    void HttpReply::packHeadersInto(Packable *) const STUB
-    void HttpReply::reset() STUB
-    void httpBodyPackInto(const HttpBody *, Packable *) STUB
-    bool HttpReply::sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
-    int HttpReply::httpMsgParseError() STUB_RETVAL(0)
-    bool HttpReply::expectingBody(const HttpRequestMethod&, int64_t&) const STUB_RETVAL(false)
-    bool HttpReply::parseFirstLine(const char *start, const char *end) STUB_RETVAL(false)
-    void HttpReply::hdrCacheInit() STUB
-    HttpReply * HttpReply::clone() const STUB_RETVAL(NULL)
-    bool HttpReply::inheritProperties(const HttpMsg *aMsg) STUB_RETVAL(false)
-    bool HttpReply::updateOnNotModified(HttpReply const*) STUB_RETVAL(false)
-    int64_t HttpReply::bodySize(const HttpRequestMethod&) const STUB_RETVAL(0)
+{STUB_NOP}
+HttpReply::~HttpReply() STUB
+void HttpReply::setHeaders(Http::StatusCode status, const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires_) STUB
+void HttpReply::packHeadersInto(Packable *) const STUB
+void HttpReply::reset() STUB
+void httpBodyPackInto(const HttpBody *, Packable *) STUB
+bool HttpReply::sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
+int HttpReply::httpMsgParseError() STUB_RETVAL(0)
+bool HttpReply::expectingBody(const HttpRequestMethod&, int64_t&) const STUB_RETVAL(false)
+bool HttpReply::parseFirstLine(const char *start, const char *end) STUB_RETVAL(false)
+void HttpReply::hdrCacheInit() STUB
+HttpReply * HttpReply::clone() const STUB_RETVAL(NULL)
+bool HttpReply::inheritProperties(const Http::Message *aMsg) STUB_RETVAL(false)
+bool HttpReply::updateOnNotModified(HttpReply const*) STUB_RETVAL(false)
+int64_t HttpReply::bodySize(const HttpRequestMethod&) const STUB_RETVAL(0)
 
@@ -15,8 +15,8 @@
 
 // void httpRequestPack(void *obj, Packable *p);
 
-HttpRequest::HttpRequest() : HttpMsg(hoRequest) {STUB}
-HttpRequest::HttpRequest(const HttpRequestMethod &, AnyP::ProtocolType, const char *, const char *) : HttpMsg(hoRequest) {STUB}
+HttpRequest::HttpRequest() : Http::Message(hoRequest) {STUB}
+HttpRequest::HttpRequest(const HttpRequestMethod &, AnyP::ProtocolType, const char *, const char *) : Http::Message(hoRequest) {STUB}
 HttpRequest::~HttpRequest() STUB
 void HttpRequest::reset() STUB
 void HttpRequest::initHTTP(const HttpRequestMethod &, AnyP::ProtocolType, const char *, const char *) STUB
@@ -55,6 +55,6 @@ int64_t HttpRequest::getRangeOffsetLimit() STUB_RETVAL(0)
 void HttpRequest::packFirstLineInto(Packable *, bool) const STUB
 bool HttpRequest::sanityCheckStartLine(const char *, const size_t, Http::StatusCode *) STUB_RETVAL(false)
 void HttpRequest::hdrCacheInit() STUB
-bool HttpRequest::inheritProperties(const HttpMsg *) STUB_RETVAL(false)
+bool HttpRequest::inheritProperties(const Http::Message *) STUB_RETVAL(false)
 NotePairs::Pointer HttpRequest::notes() STUB_RETVAL(NotePairs::Pointer())
 
@@ -487,7 +487,7 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
     HttpReply rep;
     Http::StatusCode parseErr = Http::scNone;
     const bool eof = !chunkSize;
-    connectRespBuf->terminate(); // HttpMsg::parse requires terminated string
+    connectRespBuf->terminate(); // Http::Message::parse requires terminated string
     const bool parsed = rep.parse(connectRespBuf->content(), connectRespBuf->contentSize(), eof, &parseErr);
     if (!parsed) {
         if (parseErr > 0) { // unrecoverable parsing error
@@ -1170,7 +1170,7 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     tunnelState->connectRespBuf = new MemBuf;
     // SQUID_TCP_SO_RCVBUF: we should not accumulate more than regular I/O buffer
     // can hold since any CONNECT response leftovers have to fit into server.buf.
-    // 2*SQUID_TCP_SO_RCVBUF: HttpMsg::parse() zero-terminates, which uses space.
+    // 2*SQUID_TCP_SO_RCVBUF: Http::Message::parse() zero-terminates, which uses space.
     tunnelState->connectRespBuf->init(SQUID_TCP_SO_RCVBUF, 2*SQUID_TCP_SO_RCVBUF);
     tunnelState->readConnectResponse();
 
@@ -105,7 +105,7 @@ WhoisState::setReplyToOK(StoreEntry *sentry)
     HttpReply *reply = new HttpReply;
     sentry->buffer();
     reply->setHeaders(Http::scOkay, "Gatewaying", "text/plain", -1, -1, -2);
-    reply->sources |= HttpMsg::srcWhois;
+    reply->sources |= Http::Message::srcWhois;
     sentry->replaceHttpReply(reply);
 }
 