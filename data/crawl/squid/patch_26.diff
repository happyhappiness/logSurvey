----++++src/acl/Tree.cc
@@ -57,35 +57,6 @@ Acl::Tree::add(ACL *rule)
     InnerNode::add(rule);
 }
 
-SBufList
-Acl::Tree::treeDump(const char *prefix, const ActionToString &amp;convert) const
-{
-    SBufList text;
-    Actions::const_iterator action = actions.begin();
-    typedef Nodes::const_iterator NCI;
-    for (NCI node = nodes.begin(); node != nodes.end(); ++node) {
-
-        text.push_back(SBuf(prefix));
-
-        if (action != actions.end()) {
-            const char *act = convert ? convert[action-&gt;kind] :
-                              (*action == ACCESS_ALLOWED ? &quot;allow&quot; : &quot;deny&quot;);
-            text.push_back(act?SBuf(act):SBuf(&quot;???&quot;));
-            ++action;
-        }
-
-#if __cplusplus &gt;= 201103L
-        text.splice(text.end(), (*node)-&gt;dump());
-#else
-        // temp is needed until c++11 move constructor
-        SBufList temp = (*node)-&gt;dump();
-        text.splice(text.end(), temp);
-#endif
-        text.push_back(SBuf(&quot;\n&quot;));
-    }
-    return text;
-}
-
 bool
 Acl::Tree::bannedAction(ACLChecklist *checklist, Nodes::const_iterator node) const
 {
----++++src/acl/Tree.h
@@ -25,9 +25,9 @@ class Tree: public OrNode
 
 public:
     /// dumps &lt;name, action, rule, new line&gt; tuples
-    /// action.kind is mapped to a string using the supplied conversion table
-    typedef const char **ActionToString;
-    SBufList treeDump(const char *name, const ActionToString &amp;convert) const;
+    /// the supplied converter maps action.kind to a string
+    template &lt;class ActionToStringConverter&gt;
+    SBufList treeDump(const char *name, ActionToStringConverter converter) const;
 
     /// Returns the corresponding action after a successful tree match.
     allow_t winningAction() const;
@@ -49,6 +49,42 @@ class Tree: public OrNode
     Actions actions;
 };
 
+inline const char *
+AllowOrDeny(const allow_t &amp;action)
+{
+    return action == ACCESS_ALLOWED ? &quot;allow&quot; : &quot;deny&quot;;
+}
+
+template &lt;class ActionToStringConverter&gt;
+inline SBufList
+Tree::treeDump(const char *prefix, ActionToStringConverter converter) const
+{
+    SBufList text;
+    Actions::const_iterator action = actions.begin();
+    typedef Nodes::const_iterator NCI;
+    for (NCI node = nodes.begin(); node != nodes.end(); ++node) {
+
+        text.push_back(SBuf(prefix));
+
+        if (action != actions.end()) {
+            static const SBuf DefaultActString(&quot;???&quot;);
+            const char *act = converter(*action);
+            text.push_back(act ? SBuf(act) : DefaultActString);
+            ++action;
+        }
+
+#if __cplusplus &gt;= 201103L
+        text.splice(text.end(), (*node)-&gt;dump());
+#else
+        // temp is needed until c++11 move constructor
+        SBufList temp = (*node)-&gt;dump();
+        text.splice(text.end(), temp);
+#endif
+        text.push_back(SBuf(&quot;\n&quot;));
+    }
+    return text;
+}
+
 } // namespace Acl
 
 #endif /* SQUID_ACL_TREE_H */
----++++src/cache_cf.cc
@@ -1340,7 +1340,7 @@ void
 dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 {
     if (head)
-        dump_SBufList(entry, head-&gt;treeDump(name,NULL));
+        dump_SBufList(entry, head-&gt;treeDump(name, &amp;Acl::AllowOrDeny));
 }
 
 static void
@@ -1826,6 +1826,23 @@ dump_authparam(StoreEntry * entry, const char *name, Auth::ConfigVector cfg)
 }
 #endif /* USE_AUTH */
 
+static void
+ParseAclWithAction(acl_access **access, const allow_t &amp;action, const char *desc, ACL *acl = nullptr)
+{
+    assert(access);
+    SBuf name;
+    if (!*access) {
+        *access = new Acl::Tree;
+        name.Printf(&quot;(%s rules)&quot;, desc);
+        (*access)-&gt;context(name.c_str(), config_input_line);
+    }
+    Acl::AndNode *rule = new Acl::AndNode;
+    name.Printf(&quot;(%s rule)&quot;, desc);
+    rule-&gt;context(name.c_str(), config_input_line);
+    acl ? rule-&gt;add(acl) : rule-&gt;lineParse();
+    (*access)-&gt;add(rule, action);
+}
+
 /* TODO: just return the object, the # is irrelevant */
 static int
 find_fstype(char *type)
@@ -4626,24 +4643,16 @@ static void parse_sslproxy_ssl_bump(acl_access **ssl_bump)
 
     bumpCfgStyleLast = bumpCfgStyleNow;
 
-    Acl::AndNode *rule = new Acl::AndNode;
-    rule-&gt;context(&quot;(ssl_bump rule)&quot;, config_input_line);
-    rule-&gt;lineParse();
     // empty rule OK
-
-    assert(ssl_bump);
-    if (!*ssl_bump) {
-        *ssl_bump = new Acl::Tree;
-        (*ssl_bump)-&gt;context(&quot;(ssl_bump rules)&quot;, config_input_line);
-    }
-
-    (*ssl_bump)-&gt;add(rule, action);
+    ParseAclWithAction(ssl_bump, action, &quot;ssl_bump&quot;);
 }
 
 static void dump_sslproxy_ssl_bump(StoreEntry *entry, const char *name, acl_access *ssl_bump)
 {
     if (ssl_bump)
-        dump_SBufList(entry, ssl_bump-&gt;treeDump(name, Ssl::BumpModeStr));
+        dump_SBufList(entry, ssl_bump-&gt;treeDump(name, [](const allow_t &amp;action) {
+                    return Ssl::BumpModeStr.at(action.kind);
+        }));
 }
 
 static void free_sslproxy_ssl_bump(acl_access **ssl_bump)
@@ -4770,21 +4779,16 @@ static void parse_ftp_epsv(acl_access **ftp_epsv)
     if (ftpEpsvIsDeprecatedRule) {
         // overwrite previous ftp_epsv lines
         delete *ftp_epsv;
+        *ftp_epsv = nullptr;
+
         if (ftpEpsvDeprecatedAction == allow_t(ACCESS_DENIED)) {
-            Acl::AndNode *ftpEpsvRule = new Acl::AndNode;
-            ftpEpsvRule-&gt;context(&quot;(ftp_epsv rule)&quot;, config_input_line);
-            ACL *a = ACL::FindByName(&quot;all&quot;);
-            if (!a) {
-                delete ftpEpsvRule;
+            if (ACL *a = ACL::FindByName(&quot;all&quot;))
+                ParseAclWithAction(ftp_epsv, ftpEpsvDeprecatedAction, &quot;ftp_epsv&quot;, a);
+            else {
                 self_destruct();
                 return;
             }
-            ftpEpsvRule-&gt;add(a);
-            *ftp_epsv = new Acl::Tree;
-            (*ftp_epsv)-&gt;context(&quot;(ftp_epsv rules)&quot;, config_input_line);
-            (*ftp_epsv)-&gt;add(ftpEpsvRule, ftpEpsvDeprecatedAction);
-        } else
-            *ftp_epsv = NULL;
+        }
         FtpEspvDeprecated = true;
     } else {
         aclParseAccessLine(cfg_directive, LegacyParser, ftp_epsv);
@@ -4794,7 +4798,7 @@ static void parse_ftp_epsv(acl_access **ftp_epsv)
 static void dump_ftp_epsv(StoreEntry *entry, const char *name, acl_access *ftp_epsv)
 {
     if (ftp_epsv)
-        dump_SBufList(entry, ftp_epsv-&gt;treeDump(name, NULL));
+        dump_SBufList(entry, ftp_epsv-&gt;treeDump(name, Acl::AllowOrDeny));
 }
 
 static void free_ftp_epsv(acl_access **ftp_epsv)
@@ -4919,31 +4923,22 @@ parse_on_unsupported_protocol(acl_access **access)
         return;
     }
 
-    Acl::AndNode *rule = new Acl::AndNode;
-    rule-&gt;context(&quot;(on_unsupported_protocol rule)&quot;, config_input_line);
-    rule-&gt;lineParse();
     // empty rule OK
-
-    assert(access);
-    if (!*access) {
-        *access = new Acl::Tree;
-        (*access)-&gt;context(&quot;(on_unsupported_protocol rules)&quot;, config_input_line);
-    }
-
-    (*access)-&gt;add(rule, action);
+    ParseAclWithAction(access, action, &quot;on_unsupported_protocol&quot;);
 }
 
 static void
 dump_on_unsupported_protocol(StoreEntry *entry, const char *name, acl_access *access)
 {
-    const char *on_error_tunnel_mode_str[] = {
+    static const std::vector&lt;const char *&gt; onErrorTunnelMode = {
         &quot;none&quot;,
         &quot;tunnel&quot;,
-        &quot;respond&quot;,
-        NULL
+        &quot;respond&quot;
     };
     if (access) {
-        SBufList lines = access-&gt;treeDump(name, on_error_tunnel_mode_str);
+        SBufList lines = access-&gt;treeDump(name, [](const allow_t &amp;action) {
+                return onErrorTunnelMode.at(action.kind);
+        });
         dump_SBufList(entry, lines);
     }
 }
----++++src/ssl/support.cc
@@ -44,17 +44,16 @@ static Ssl::CertsIndexedList SquidUntrustedCerts;
 
 const EVP_MD *Ssl::DefaultSignHash = NULL;
 
-const char *Ssl::BumpModeStr[] = {
+std::vector&lt;const char *&gt; Ssl::BumpModeStr = {
     &quot;none&quot;,
     &quot;client-first&quot;,
     &quot;server-first&quot;,
     &quot;peek&quot;,
     &quot;stare&quot;,
     &quot;bump&quot;,
     &quot;splice&quot;,
-    &quot;terminate&quot;,
-    /*&quot;err&quot;,*/
-    NULL
+    &quot;terminate&quot;
+    /*,&quot;err&quot;*/
 };
 
 /**
----++++src/ssl/support.h
@@ -151,15 +151,15 @@ enum BumpStep {bumpStep1, bumpStep2, bumpStep3};
  \ingroup  ServerProtocolSSLAPI
  * Short names for ssl-bump modes
  */
-extern const char *BumpModeStr[];
+extern std::vector&lt;const char *&gt;BumpModeStr;
 
 /**
  \ingroup ServerProtocolSSLAPI
  * Return the short name of the ssl-bump mode &quot;bm&quot;
  */
 inline const char *bumpMode(int bm)
 {
-    return (0 &lt;= bm &amp;&amp; bm &lt; Ssl::bumpEnd) ? Ssl::BumpModeStr[bm] : NULL;
+    return (0 &lt;= bm &amp;&amp; bm &lt; Ssl::bumpEnd) ? Ssl::BumpModeStr.at(bm) : NULL;
 }
 
 /// certificates indexed by issuer name
----++++src/tests/stub_libsslsquid.cc
@@ -66,7 +66,7 @@ namespace Ssl
 //GETX509ATTRIBUTE GetX509UserAttribute;
 //GETX509ATTRIBUTE GetX509CAAttribute;
 //GETX509ATTRIBUTE GetX509Fingerprint;
-const char *BumpModeStr[] = {""};
+std::vector&lt;const char *&gt; BumpModeStr = {""};
 bool generateUntrustedCert(Security::CertPointer &amp; untrustedCert, EVP_PKEY_Pointer &amp; untrustedPkey, Security::CertPointer const &amp; cert, EVP_PKEY_Pointer const &amp; pkey) STUB_RETVAL(false)
 Security::ContextPointer generateSslContext(CertificateProperties const &amp;, AnyP::PortCfg &amp;) STUB_RETVAL(Security::ContextPointer())
 bool verifySslCertificate(Security::ContextPointer &amp;, CertificateProperties const &amp;) STUB_RETVAL(false)
----++++GitHub