@@ -64,6 +64,7 @@ The 3.5 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Helper support for concurrency channels
 	<item>Native FTP Relay
 	<item>Receive PROXY protocol, Versions 1 & 2
+	<item>Basic authentication MSNT helper changes
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -271,6 +272,23 @@ Most user-facing changes are reflected in squid.conf (see below).
    Use of <em>require-proxy-header</em> on <em>https_port</em> and <em>ftp_port</em> is not supported.
 
 
+<sect1>Basic authentication MSNT helper changes
+
+<p>The authentication helper previously known as <em>basic_msnt_auth</em> has
+   been deprecated and renamed to <em>basic_smb_lm_auth</em> to reflect that
+   it only performs SMB LanMan protocol(s) instead of modern MS authentication
+   protocols.
+
+<p>The <em>basic_smb_lm_auth</em> helper has been remodelled and no longer uses
+   configuration files. The Doman Controller servers are now configured via
+   command line parameters and user credentials are looked up in each DC in the
+   order configured until one matches or all have confirmed a non-match.
+
+<p>The <em>MSNT-multi-domain</em> helper provides the same functionality and
+   is also deprecated. It will be removed in the Squid-3.6 series.
+
+
+
 <sect>Changes to squid.conf since Squid-3.4
 <p>
 There have been changes to Squid's configuration file since Squid-3.4.
@@ -41,7 +41,7 @@ The 3.6 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Helper concurrency channels changes
 	<item>Configurable helper queue size
 	<item>SSLv2 support removal
-	<item>MSNT Helper changes
+	<item>MSNT-multi-domain helper removal
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -75,14 +75,7 @@ its use since it is now forced to disable by default. Also settings enabling
 various client/server workarounds specific to SSLv2 are removed.
 
 
-<sect1>MSNT Helper changes
-
-<p>The authentication helper previously known as <em>basic_msnt_auth</em> has
-   been renamed to <em>basic_smb_lm_auth</em> to reflect that it only performs
-   SMB LanMan protocol(s) instead of modern ActiveDirectory protocols.
-
-<p>The <em>basic_smb_lm_auth</em> helper is also deprecated and will be removed
-   in a later Squid version.
+<sect1>MSNT-multi-domain helper removal
 
 <p>The <em>basic_msnt_multi_domain_auth</em> helper has been removed. The
    <em>basic_smb_lm_auth</em> helper performs the same actions without extra
@@ -187,6 +180,8 @@ This section gives an account of those changes in three categories:
 <sect1>Changes to existing options<label id="modifiedoptions">
 <p>
 <descrip>
+	<tag>--enable-auth-basic</tag>
+	<p>The <em>MSNT-multi-domain</em> helper has been removed.
 
 </descrip>
 </p>
@@ -162,7 +162,7 @@ md5_calc(uint8_t out[16], void *in, size_t len)
  *    Receive and verify the result.
  */
 static int
-result_recv(uint32_t host, unsigned short udp_port, char *buffer, int length)
+result_recv(char *buffer, int length)
 {
     AUTH_HDR *auth;
     int totallen;
@@ -449,7 +449,7 @@ authenticate(int socket_fd, const char *username, const char *passwd)
             if (len < 0)
                 continue;
 
-            rc = result_recv(saremote.sin_addr.s_addr, saremote.sin_port, recv_buffer, len);
+            rc = result_recv(recv_buffer, len);
             if (rc == 0) {
                 SEND_OK("");
                 return;
@@ -49,7 +49,7 @@
 #define APP_NAME_SASL   "basic_sasl_auth"
 
 int
-main(int argc, char *argv[])
+main(int, char *argv[])
 {
     char line[HELPER_INPUT_BUFFER];
     char *username, *password;
@@ -21,7 +21,7 @@
 
 // BACKUP is unused
 int
-Valid_User(char *USERNAME, char *PASSWORD, const char *SERVER, char *BACKUP, const char *DOMAIN)
+Valid_User(char *USERNAME, char *PASSWORD, const char *SERVER, char *, const char *DOMAIN)
 {
     const char *supportedDialects[] = {"PC NETWORK PROGRAM 1.0",
                                        "MICROSOFT NETWORKS 1.03",
@@ -86,7 +86,7 @@ shadow_auth(char *user, char *passwd)
 #endif
 
 int
-main(int argc, char **argv)
+main(int, char **)
 {
     int auth = 0;
     char buf[HELPER_INPUT_BUFFER];
@@ -202,12 +202,7 @@ ldap_simple_rebind(
 static LDAP_REBIND_PROC ldap_sasl_rebind;
 
 static int
-ldap_sasl_rebind(
-    LDAP * ld,
-    LDAP_CONST char *url,
-    ber_tag_t request,
-    ber_int_t msgid,
-    void *params)
+ldap_sasl_rebind(LDAP *ld, LDAP_CONST char *, ber_tag_t, ber_int_t, void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
     return tool_sasl_bind(ld, cp->dn, cp->pw);
@@ -217,12 +212,7 @@ ldap_sasl_rebind(
 static LDAP_REBIND_PROC ldap_simple_rebind;
 
 static int
-ldap_simple_rebind(
-    LDAP * ld,
-    LDAP_CONST char *url,
-    ber_tag_t request,
-    ber_int_t msgid,
-    void *params)
+ldap_simple_rebind(LDAP * ld, LDAP_CONST char *, ber_tag_t, ber_int_t, void *params)
 {
 
     struct ldap_creds *cp = (struct ldap_creds *) params;
@@ -136,7 +136,7 @@ lutil_sasl_defaults(
 
 static int
 interaction(
-    unsigned flags,
+    unsigned,
     sasl_interact_t * interact,
     lutilSASLdefaults * defaults)
 {
@@ -323,7 +323,7 @@ static char got_timeout = 0;
 /** signal handler to be invoked when the authentication operation
  * times out */
 void
-timeout_during_auth(int signum)
+timeout_during_auth(int)
 {
     dc_disconnect();
 }
@@ -201,7 +201,7 @@ ntlm_make_nonce(char *nonce)
  */
 void
 ntlm_make_challenge(ntlm_challenge *ch,
-                    const char *domain, const char *domain_controller_UNUSED,
+                    const char *domain, const char *,
                     const char *challenge_nonce, const int challenge_nonce_len,
                     const uint32_t flags)
 {
@@ -27,10 +27,10 @@ class BodySink: public BodyConsumer
         size_t contentSize = bp->buf().contentSize();
         bp->consume(contentSize);
     }
-    virtual void noteBodyProductionEnded(BodyPipe::Pointer bp) {
+    virtual void noteBodyProductionEnded(BodyPipe::Pointer) {
         stopConsumingFrom(body_pipe);
     }
-    virtual void noteBodyProducerAborted(BodyPipe::Pointer bp) {
+    virtual void noteBodyProducerAborted(BodyPipe::Pointer) {
         stopConsumingFrom(body_pipe);
     }
     bool doneAll() const {return !body_pipe && AsyncJob::doneAll();}
@@ -51,7 +51,7 @@ AIODiskFile::error(bool const &aBool)
 }
 
 void
-AIODiskFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
+AIODiskFile::open(int flags, mode_t, RefCount<IORequestor> callback)
 {
     /* Simulate async calls */
 #if _SQUID_WINDOWS_
@@ -184,7 +184,7 @@ AIODiskIOStrategy::init()
 }
 
 void
-AIODiskIOStrategy::statfs(StoreEntry & sentry)const
+AIODiskIOStrategy::statfs(StoreEntry &) const
 {}
 
 ConfigOption *
@@ -36,7 +36,7 @@ BlockingFile::~BlockingFile()
 }
 
 void
-BlockingFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
+BlockingFile::open(int flags, mode_t, RefCount<IORequestor> callback)
 {
     /* Simulate async calls */
     fd = file_open(path_ , flags);
@@ -50,7 +50,7 @@ DiskdFile::~DiskdFile()
 }
 
 void
-DiskdFile::open(int flags, mode_t aMode, RefCount< IORequestor > callback)
+DiskdFile::open(int flags, mode_t, RefCount<IORequestor> callback)
 {
     debugs(79, 3, "DiskdFile::open: " << this << " opening for " << callback.getRaw());
     assert(ioRequestor.getRaw() == NULL);
@@ -81,7 +81,7 @@ DiskdFile::open(int flags, mode_t aMode, RefCount< IORequestor > callback)
 }
 
 void
-DiskdFile::create(int flags, mode_t aMode, RefCount< IORequestor > callback)
+DiskdFile::create(int flags, mode_t, RefCount<IORequestor> callback)
 {
     debugs(79, 3, "DiskdFile::create: " << this << " creating for " << callback.getRaw());
     assert (ioRequestor.getRaw() == NULL);
@@ -51,7 +51,7 @@ static char *shmbuf;
 static int DebugLevel = 0;
 
 static int
-do_open(diomsg * r, int len, const char *buf)
+do_open(diomsg * r, int, const char *buf)
 {
     int fd;
     file_state *fs;
@@ -85,7 +85,7 @@ do_open(diomsg * r, int len, const char *buf)
 }
 
 static int
-do_close(diomsg * r, int len)
+do_close(diomsg * r, int)
 {
     int fd;
     file_state *fs;
@@ -115,7 +115,7 @@ do_close(diomsg * r, int len)
 }
 
 static int
-do_read(diomsg * r, int len, char *buf)
+do_read(diomsg * r, int, char *buf)
 {
     int x;
     int readlen = r->size;
@@ -165,7 +165,7 @@ do_read(diomsg * r, int len, char *buf)
 }
 
 static int
-do_write(diomsg * r, int len, const char *buf)
+do_write(diomsg * r, int, const char *buf)
 {
     int wrtlen = r->size;
     int x;
@@ -211,7 +211,7 @@ do_write(diomsg * r, int len, const char *buf)
 }
 
 static int
-do_unlink(diomsg * r, int len, const char *buf)
+do_unlink(diomsg * r, int, const char *buf)
 {
     if (unlink(buf) < 0) {
         DEBUG(1) {
@@ -295,11 +295,8 @@ fsHash(const void *key, unsigned int n)
     return (*k & (--n));
 }
 
-SQUIDCEXTERN {
-    static void
-    alarm_handler(int sig) {
-        (void) 0;
-    }
+extern "C" {
+    static void alarm_handler(int) {}
 };
 
 int
@@ -39,7 +39,7 @@ class DiskFile : public RefCountable
     typedef RefCount<DiskFile> Pointer;
 
     /// notes supported configuration options; kids must call this first
-    virtual void configure(const Config &cfg) {}
+    virtual void configure(const Config &) {}
 
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback) = 0;
     virtual void create(int flags, mode_t mode, RefCount<IORequestor> callback) = 0;
@@ -47,10 +47,10 @@ class DiskIOStrategy
     virtual void init() {}
 
     /** cachemgr output on the IO instance stats */
-    virtual void statfs(StoreEntry & sentry)const {}
+    virtual void statfs(StoreEntry &) const {}
 
     /** module specific options */
-    virtual ConfigOption *getOptionTree() const { return NULL;}
+    virtual ConfigOption *getOptionTree() const {return NULL;}
 };
 
 /* Because we need the DiskFile definition for newFile. */
@@ -72,13 +72,13 @@ class SingletonIOStrategy : public DiskIOStrategy
 
     virtual bool unlinkdUseful() const { return io->unlinkdUseful(); }
 
-    virtual void unlinkFile (char const *path) { io->unlinkFile(path); }
+    virtual void unlinkFile(char const *path) { io->unlinkFile(path); }
 
     virtual int callback() { return io->callback(); }
 
     virtual void init() { io->init(); }
 
-    virtual void statfs(StoreEntry & sentry)const { io->statfs(sentry); }
+    virtual void statfs(StoreEntry & sentry) const { io->statfs(sentry); }
 
     virtual ConfigOption *getOptionTree() const { return io->getOptionTree(); }
 
@@ -59,7 +59,7 @@ CommIO::FlushPipe()
 }
 
 void
-CommIO::NULLFDHandler(int fd, void *data)
+CommIO::NULLFDHandler(int fd, void *)
 {
     FlushPipe();
     Comm::SetSelect(fd, COMM_SELECT_READ, NULLFDHandler, NULL, 0);
@@ -135,7 +135,7 @@ DiskThreadsDiskFile::OpenDone(int fd, void *cbdata, const char *buf, int aio_ret
 }
 
 void
-DiskThreadsDiskFile::openDone(int unused, const char *unused2, int anFD, int errflag)
+DiskThreadsDiskFile::openDone(int, const char *, int anFD, int errflag)
 {
     debugs(79, 3, "DiskThreadsDiskFile::openDone: FD " << anFD << ", errflag " << errflag);
     --Opening_FD;
@@ -890,7 +890,7 @@ IpcIoFile::DiskerHandleRequest(const int workerId, IpcIoMsg &ipcIo)
 }
 
 static bool
-DiskerOpen(const SBuf &path, int flags, mode_t mode)
+DiskerOpen(const SBuf &path, int flags, mode_t)
 {
     assert(TheFile < 0);
 
@@ -69,7 +69,7 @@ MmappedFile::~MmappedFile()
 
 // XXX: almost a copy of BlockingFile::open
 void
-MmappedFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
+MmappedFile::open(int flags, mode_t, RefCount<IORequestor> callback)
 {
     assert(fd < 0);
 
@@ -503,7 +503,7 @@ FwdState::complete()
 /**** CALLBACK WRAPPERS ************************************************************/
 
 static void
-fwdPeerSelectionCompleteWrapper(Comm::ConnectionList * unused, ErrorState *err, void *data)
+fwdPeerSelectionCompleteWrapper(Comm::ConnectionList *, ErrorState *err, void *data)
 {
     FwdState *fwd = (FwdState *) data;
     if (err)
@@ -23,11 +23,22 @@
 #include <map>
 
 /* a row in the table used for parsing cache control header and statistics */
-typedef struct {
+class HttpHeaderCcFields
+{
+public:
+    HttpHeaderCcFields() : name(NULL), id(CC_BADHDR), stat() {}
+    HttpHeaderCcFields(const char *aName, http_hdr_cc_type aTypeId) : name(aName), id(aTypeId) {}
+    // nothing to do as name is a pointer to global static string
+    ~HttpHeaderCcFields() {}
+
     const char *name;
     http_hdr_cc_type id;
     HttpHeaderFieldStat stat;
-} HttpHeaderCcFields;
+
+private:
+    HttpHeaderCcFields(const HttpHeaderCcFields &); // not implemented
+    HttpHeaderCcFields &operator =(const HttpHeaderCcFields &); // not implemented
+};
 
 /* order must match that of enum http_hdr_cc_type. The constraint is verified at initialization time */
 static HttpHeaderCcFields CcAttrs[CC_ENUM_END] = {
@@ -299,7 +310,7 @@ httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist)
 }
 
 void
-httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHdrCcStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     extern const HttpHeaderStat *dump_stat; /* argh! */
     const int id = (int) val;
@@ -303,7 +303,7 @@ HttpHdrSc::updateStats(StatHist * hist) const
 }
 
 void
-httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHdrScTargetStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     extern const HttpHeaderStat *dump_stat;     /* argh! */
     const int id = (int) val;
@@ -316,7 +316,7 @@ httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size,
 }
 
 void
-httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHdrScStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     extern const HttpHeaderStat *dump_stat; /* argh! */
     const int id = (int) val;
@@ -322,13 +322,18 @@ static http_hdr_type HopByHopHeadersArr[] = {
 };
 
 /* header accounting */
+// NP: keep in sync with enum http_hdr_owner_type
 static HttpHeaderStat HttpHeaderStats[] = {
-    {"all"},
+    {/*hoNone*/ "all", NULL},
 #if USE_HTCP
-    {"HTCP reply"},
+    {/*hoHtcpReply*/ "HTCP reply", &ReplyHeadersMask},
 #endif
-    {"request"},
-    {"reply"}
+    {/*hoRequest*/ "request", &RequestHeadersMask},
+    {/*hoReply*/ "reply", &ReplyHeadersMask}
+#if USE_OPENSSL
+    /* hoErrorDetail */
+#endif
+    /* hoEnd */
 };
 static int HttpHeaderStatCount = countof(HttpHeaderStats);
 
@@ -343,7 +348,6 @@ class StoreEntry;
 
 static void httpHeaderNoteParsedEntry(http_hdr_type id, String const &value, int error);
 
-static void httpHeaderStatInit(HttpHeaderStat * hs, const char *label);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
 
 /** store report about current header usage and other stats */
@@ -364,7 +368,6 @@ httpHeaderRegisterWithCacheManager(void)
 void
 httpHeaderInitModule(void)
 {
-    int i;
     /* check that we have enough space for masks */
     assert(8 * sizeof(HttpHeaderMask) >= HDR_ENUM_END);
     /* all headers must be described */
@@ -390,18 +393,8 @@ httpHeaderInitModule(void)
     httpHeaderMaskInit(&HopByHopHeadersMask, 0);
     httpHeaderCalcMask(&HopByHopHeadersMask, HopByHopHeadersArr, countof(HopByHopHeadersArr));
 
-    /* init header stats */
+    /* header stats initialized by class constructor */
     assert(HttpHeaderStatCount == hoReply + 1);
-    for (i = 0; i < HttpHeaderStatCount; ++i)
-        httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
-
-    HttpHeaderStats[hoRequest].owner_mask = &RequestHeadersMask;
-
-    HttpHeaderStats[hoReply].owner_mask = &ReplyHeadersMask;
-
-#if USE_HTCP
-    HttpHeaderStats[hoHtcpReply].owner_mask = &ReplyHeadersMask;
-#endif
 
     /* init dependent modules */
     httpHdrCcInitModule();
@@ -419,19 +412,6 @@ httpHeaderCleanModule(void)
     httpHdrScCleanModule();
 }
 
-static void
-httpHeaderStatInit(HttpHeaderStat * hs, const char *label)
-{
-    assert(hs);
-    assert(label);
-    memset(hs, 0, sizeof(HttpHeaderStat));
-    hs->label = label;
-    hs->hdrUCountDistr.enumInit(32);    /* not a real enum */
-    hs->fieldTypeDistr.enumInit(HDR_ENUM_END);
-    hs->ccTypeDistr.enumInit(CC_ENUM_END);
-    hs->scTypeDistr.enumInit(SC_ENUM_END);
-}
-
 /*
  * HttpHeader Implementation
  */
@@ -1763,7 +1743,7 @@ extern const HttpHeaderStat *dump_stat;     /* argh! */
 const HttpHeaderStat *dump_stat = NULL;
 
 void
-httpHeaderFieldStatDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHeaderFieldStatDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     const int id = (int) val;
     const int valid_id = id >= 0 && id < HDR_ENUM_END;
@@ -1780,7 +1760,7 @@ httpHeaderFieldStatDumper(StoreEntry * sentry, int idx, double val, double size,
 }
 
 static void
-httpHeaderFldsPerHdrDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+httpHeaderFldsPerHdrDumper(StoreEntry * sentry, int idx, double val, double, int count)
 {
     if (count)
         storeAppendPrintf(sentry, "%2d\t %5d\t %5d\t %6.2f\n",
@@ -55,10 +55,18 @@ typedef enum {
     hoEnd
 } http_hdr_owner_type;
 
-// currently a POD
 class HttpHeaderFieldAttrs
 {
 public:
+    HttpHeaderFieldAttrs() : name(NULL), id(HDR_BAD_HDR), type(ftInvalid) {}
+    HttpHeaderFieldAttrs(const char *aName, http_hdr_type anId, field_type aType = ftInvalid) : name(aName), id(anId), type(aType) {}
+#if __cplusplus >= 201103L
+    HttpHeaderFieldAttrs(const HttpHeaderFieldAttrs &) = default;
+    HttpHeaderFieldAttrs(HttpHeaderFieldAttrs &&) = default;
+#endif
+    // nothing to do as name is a pointer to global const string
+    ~HttpHeaderFieldAttrs() {}
+
     const char *name;
     http_hdr_type id;
     field_type type;
@@ -11,10 +11,45 @@
 
 #include "StatHist.h"
 
-/// per header statistics
+/// HTTP per header statistics
 class HttpHeaderStat
 {
 public:
+    HttpHeaderStat() :
+        label(NULL),
+        owner_mask(NULL),
+        parsedCount(0),
+        ccParsedCount(0),
+        scParsedCount(0),
+        destroyedCount(0),
+        busyDestroyedCount(0)
+    {
+        hdrUCountDistr.enumInit(32);    /* not a real enum */
+        fieldTypeDistr.enumInit(HDR_ENUM_END);
+        ccTypeDistr.enumInit(CC_ENUM_END);
+        scTypeDistr.enumInit(SC_ENUM_END);
+    }
+
+    HttpHeaderStat(const char *aLabel, HttpHeaderMask *aMask) :
+        label(aLabel),
+        owner_mask(aMask),
+        parsedCount(0),
+        ccParsedCount(0),
+        scParsedCount(0),
+        destroyedCount(0),
+        busyDestroyedCount(0)
+    {
+        assert(label);
+        hdrUCountDistr.enumInit(32);    /* not a real enum */
+        fieldTypeDistr.enumInit(HDR_ENUM_END);
+        ccTypeDistr.enumInit(CC_ENUM_END);
+        scTypeDistr.enumInit(SC_ENUM_END);
+    }
+
+    // nothing to destruct as label is a pointer to global const string
+    // and owner_mask is a pointer to global static array
+    ~HttpHeaderStat() {}
+
     const char *label;
     HttpHeaderMask *owner_mask;
 
@@ -522,7 +522,7 @@ void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const
  * along with this request
  */
 bool
-HttpRequest::expectingBody(const HttpRequestMethod& unused, int64_t& theSize) const
+HttpRequest::expectingBody(const HttpRequestMethod &, int64_t &theSize) const
 {
     bool expectBody = false;
 
@@ -120,9 +120,9 @@ class MemBuf
      * private copy constructor and assignment operator generates
      * compiler errors if someone tries to copy/assign a MemBuf
      */
-    MemBuf(const MemBuf& m) {assert(false);};
+    MemBuf(const MemBuf &) {assert(false);}
 
-    MemBuf& operator= (const MemBuf& m) {assert(false); return *this;};
+    MemBuf& operator= (const MemBuf &) {assert(false); return *this;}
 
     void grow(mb_size_t min_cap);
 
@@ -221,7 +221,7 @@ MemStore::get(const cache_key *key)
 }
 
 void
-MemStore::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+MemStore::get(String const, STOREGETCLIENT, void *)
 {
     // XXX: not needed but Store parent forces us to implement this
     fatal("MemStore::get(key,callback,data) should not be called");
@@ -43,7 +43,7 @@ SBufStatsAction::collect()
 }
 
 static void
-statHistSBufDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+statHistSBufDumper(StoreEntry * sentry, int, double val, double size, int count)
 {
     if (count == 0)
         return;
@@ -529,7 +529,7 @@ class SquidConfig
 
     char *redirector_extras;
 
-    struct {
+    struct UrlHelperTimeout {
         int action;
         char *response;
     } onUrlRewriteTimeout;
@@ -236,15 +236,15 @@ StatHist::enumInit(unsigned int last_enum)
 }
 
 void
-statHistEnumDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+statHistEnumDumper(StoreEntry * sentry, int idx, double val, double, int count)
 {
     if (count)
         storeAppendPrintf(sentry, "%2d\t %5d\t %5d\n",
                           idx, (int) val, count);
 }
 
 void
-statHistIntDumper(StoreEntry * sentry, int idx, double val, double size, int count)
+statHistIntDumper(StoreEntry * sentry, int, double val, double, int count)
 {
     if (count)
         storeAppendPrintf(sentry, "%9d\t%9d\n", (int) val, count);
@@ -259,7 +259,7 @@ class NullStoreEntry:public StoreEntry
 
     bool isEmpty () const {return true;}
 
-    virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const { return aRange.end; }
+    virtual size_t bytesWanted(Range<size_t> const aRange, bool) const { return aRange.end; }
 
     void operator delete(void *address);
     void complete() {}
@@ -270,7 +270,7 @@ class NullStoreEntry:public StoreEntry
     char const *getSerialisedMetaData();
     virtual bool mayStartSwapOut() { return false; }
 
-    void trimMemory(const bool preserveSwappable) {}
+    void trimMemory(const bool) {}
 
     static NullStoreEntry _instance;
 };
@@ -363,71 +363,71 @@ class Store : public RefCountable
     virtual void reference(StoreEntry &) = 0;   /* Reference this object */
 
     /// Undo reference(), returning false iff idle e should be destroyed
-    virtual bool dereference(StoreEntry &e, bool wantsLocalMemory) = 0;
+    virtual bool dereference(StoreEntry &, bool wantsLocalMemory) = 0;
 
     virtual void maintain() = 0; /* perform regular maintenance should be private and self registered ... */
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// informs stores that this entry will be eventually unlinked
-    virtual void markForUnlink(StoreEntry &e) {}
+    virtual void markForUnlink(StoreEntry &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // because test cases use non-StoreController derivatives as Root
     /// called when the entry is no longer needed by any transaction
-    virtual void handleIdleEntry(StoreEntry &e) {}
+    virtual void handleIdleEntry(StoreEntry &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // because test cases use non-StoreController derivatives as Root
     /// called to get rid of no longer needed entry data in RAM, if any
-    virtual void memoryOut(StoreEntry &e, const bool preserveSwappable) {}
+    virtual void memoryOut(StoreEntry &, const bool /*preserveSwappable*/) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// makes the entry available for collapsing future requests
-    virtual void allowCollapsing(StoreEntry *e, const RequestFlags &reqFlags, const HttpRequestMethod &reqMethod) {}
+    virtual void allowCollapsing(StoreEntry *, const RequestFlags &, const HttpRequestMethod &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// marks the entry completed for collapsed requests
-    virtual void transientsCompleteWriting(StoreEntry &e) {}
+    virtual void transientsCompleteWriting(StoreEntry &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// Update local intransit entry after changes made by appending worker.
-    virtual void syncCollapsed(const sfileno xitIndex) {}
+    virtual void syncCollapsed(const sfileno) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// calls Root().transients->abandon() if transients are tracked
-    virtual void transientsAbandon(StoreEntry &e) {}
+    virtual void transientsAbandon(StoreEntry &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// number of the transient entry readers some time ago
-    virtual int transientReaders(const StoreEntry &e) const { return 0; }
+    virtual int transientReaders(const StoreEntry &) const { return 0; }
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// disassociates the entry from the intransit table
-    virtual void transientsDisconnect(MemObject &mem_obj) {}
+    virtual void transientsDisconnect(MemObject &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// removes the entry from the memory cache
-    virtual void memoryUnlink(StoreEntry &e) {}
+    virtual void memoryUnlink(StoreEntry &) {}
 
     // XXX: This method belongs to Store::Root/StoreController, but it is here
     // to avoid casting Root() to StoreController until Root() API is fixed.
     /// disassociates the entry from the memory cache, preserving cached data
-    virtual void memoryDisconnect(StoreEntry &e) {}
+    virtual void memoryDisconnect(StoreEntry &) {}
 
     /// If the entry is not found, return false. Otherwise, return true after
     /// tying the entry to this cache and setting inSync to updateCollapsed().
-    virtual bool anchorCollapsed(StoreEntry &collapsed, bool &inSync) { return false; }
+    virtual bool anchorCollapsed(StoreEntry &, bool &/*inSync*/) { return false; }
 
     /// update a local collapsed entry with fresh info from this cache (if any)
-    virtual bool updateCollapsed(StoreEntry &collapsed) { return false; }
+    virtual bool updateCollapsed(StoreEntry &) { return false; }
 
 private:
     static RefCount<Store> CurrentRoot;
@@ -14,14 +14,17 @@
 #include "StoreIOState.h"
 
 void *
-StoreIOState::operator new (size_t amount)
+StoreIOState::operator new (size_t)
 {
     assert(0);
     return (void *)1;
 }
 
 void
-StoreIOState::operator delete (void *address) {assert (0);}
+StoreIOState::operator delete (void *)
+{
+    assert(0);
+}
 
 StoreIOState::StoreIOState() :
     swap_dirn(-1), swap_filen(-1), e(NULL), mode(O_BINARY),
@@ -157,7 +157,7 @@ StoreMeta::Add(StoreMeta **tail, StoreMeta *aNode)
 }
 
 bool
-StoreMeta::checkConsistency(StoreEntry *e) const
+StoreMeta::checkConsistency(StoreEntry *) const
 {
     switch (getType()) {
 
@@ -208,7 +208,7 @@ void
 SwapDir::writeCleanDone() {}
 
 void
-SwapDir::logEntry(const StoreEntry & e, int op) const {}
+SwapDir::logEntry(const StoreEntry &, int) const {}
 
 char const *
 SwapDir::type() const
@@ -297,7 +297,7 @@ SwapDir::dumpOptions(StoreEntry * entry) const
 }
 
 bool
-SwapDir::optionReadOnlyParse(char const *option, const char *value, int isaReconfig)
+SwapDir::optionReadOnlyParse(char const *option, const char *value, int)
 {
     if (strcmp(option, "no-store") != 0 && strcmp(option, "read-only") != 0)
         return false;
@@ -370,13 +370,13 @@ SwapDir::optionObjectSizeDump(StoreEntry * e) const
 
 // some SwapDirs may maintain their indexes and be able to lookup an entry key
 StoreEntry *
-SwapDir::get(const cache_key *key)
+SwapDir::get(const cache_key *)
 {
     return NULL;
 }
 
 void
-SwapDir::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+SwapDir::get(String const, STOREGETCLIENT, void *)
 {
     fatal("not implemented");
 }
@@ -213,7 +213,7 @@ Transients::copyFromShm(const sfileno index)
 }
 
 void
-Transients::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+Transients::get(String const, STOREGETCLIENT, void *)
 {
     // XXX: not needed but Store parent forces us to implement this
     fatal("Transients::get(key,callback,data) should not be called");
@@ -297,7 +297,7 @@ Transients::copyToShm(const StoreEntry &e, const sfileno index,
 }
 
 void
-Transients::noteFreeMapSlice(const Ipc::StoreMapSliceId sliceId)
+Transients::noteFreeMapSlice(const Ipc::StoreMapSliceId)
 {
     // TODO: we should probably find the entry being deleted and abort it
 }
@@ -17,8 +17,8 @@ void WIN32_SetServiceCommandLine(void);
 void WIN32_InstallService(void);
 void WIN32_RemoveService(void);
 #else /* _SQUID_WINDOWS_ */
-inline int WIN32_Subsystem_Init(int *foo, char ***bar) {return 0; } /* NOP */
-inline void WIN32_sendSignal(int foo) { return; } /* NOP */
+inline int WIN32_Subsystem_Init(int *, char ***) {return 0;} /* NOP */
+inline void WIN32_sendSignal(int) {return;} /* NOP */
 inline void WIN32_SetServiceCommandLine(void) {} /* NOP */
 inline void WIN32_InstallService(void) {} /* NOP */
 inline  void WIN32_RemoveService(void) {} /* NOP */
@@ -79,14 +79,14 @@ ACLFlags::flagsStr() const
 }
 
 void *
-ACL::operator new (size_t byteCount)
+ACL::operator new (size_t)
 {
     fatal ("unusable ACL::new");
     return (void *)1;
 }
 
 void
-ACL::operator delete (void *address)
+ACL::operator delete (void *)
 {
     fatal ("unusable ACL::delete");
 }
@@ -297,7 +297,7 @@ ACL::isProxyAuth() const
 /* ACL result caching routines */
 
 int
-ACL::matchForCache(ACLChecklist *checklist)
+ACL::matchForCache(ACLChecklist *)
 {
     /* This is a fatal to ensure that cacheMatchAcl calls are _only_
      * made for supported acl types */
@@ -33,7 +33,7 @@ DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 }
 
 void
-DestinationDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
+DestinationDomainLookup::LookupDone(const char *, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markDestinationDomainChecked();
@@ -18,14 +18,14 @@
 #include "wordlist.h"
 
 void *
-ACLIP::operator new (size_t byteCount)
+ACLIP::operator new (size_t)
 {
     fatal ("ACLIP::operator new: unused");
     return (void *)1;
 }
 
 void
-ACLIP::operator delete (void *address)
+ACLIP::operator delete (void *)
 {
     fatal ("ACLIP::operator delete: unused");
 }
@@ -102,7 +102,7 @@ ACLRandom::parse()
 }
 
 int
-ACLRandom::match(ACLChecklist *cl)
+ACLRandom::match(ACLChecklist *)
 {
     // make up the random value
     double random = ((double)rand() / (double)RAND_MAX);
@@ -31,7 +31,7 @@ SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 }
 
 void
-SourceDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
+SourceDomainLookup::LookupDone(const char *, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markSourceDomainChecked();
@@ -14,9 +14,9 @@
 #include "SquidTime.h"
 
 int
-ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLTimeStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *, ACLFlags &)
 {
-    return data->match (squid_curtime);
+    return data->match(squid_curtime);
 }
 
 ACLTimeStrategy *
@@ -14,7 +14,7 @@
 #include "base/AsyncJobCalls.h"
 
 void
-Adaptation::Initiator::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer group)
+Adaptation::Initiator::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer)
 {
     Must(false);
 }
@@ -81,7 +81,7 @@ class ServiceSet: public ServiceGroup
 
 protected:
     virtual bool replace(Pos &pos) const { return has(++pos); }
-    virtual bool advance(Pos &pos) const { return false; }
+    virtual bool advance(Pos &) const { return false; }
 };
 
 // corner case: a group consisting of one service
@@ -91,8 +91,8 @@ class SingleService: public ServiceGroup
     SingleService(const String &aServiceKey);
 
 protected:
-    virtual bool replace(Pos &pos) const { return false; }
-    virtual bool advance(Pos &pos) const { return false; }
+    virtual bool replace(Pos &) const { return false; }
+    virtual bool advance(Pos &) const { return false; }
 };
 
 /// a group of services that must be used one after another
@@ -102,7 +102,7 @@ class ServiceChain: public ServiceGroup
     ServiceChain();
 
 protected:
-    virtual bool replace(Pos &pos) const { return false; }
+    virtual bool replace(Pos &) const { return false; }
     virtual bool advance(Pos &pos) const { return has(++pos); }
 };
 
@@ -1680,7 +1680,7 @@ void Adaptation::Icap::ModXact::decideOnRetries()
 // structures were initialized. This is not the case when there is no body
 // or the body is known to be empty, because the virgin message will lack a
 // body_pipe. So we handle preview of null-body and zero-size bodies here.
-void Adaptation::Icap::ModXact::finishNullOrEmptyBodyPreview(MemBuf &buf)
+void Adaptation::Icap::ModXact::finishNullOrEmptyBodyPreview(MemBuf &)
 {
     Must(!virginBodyWriting.active()); // one reason we handle it here
     Must(!virgin.body_pipe);          // another reason we handle it here
@@ -305,7 +305,7 @@ void Adaptation::Icap::Xaction::noteCommWrote(const CommIoCbParams &io)
 }
 
 // communication timeout with the ICAP service
-void Adaptation::Icap::Xaction::noteCommTimedout(const CommTimeoutCbParams &io)
+void Adaptation::Icap::Xaction::noteCommTimedout(const CommTimeoutCbParams &)
 {
     handleCommTimedout();
 }
@@ -328,7 +328,7 @@ void Adaptation::Icap::Xaction::handleCommTimedout()
 }
 
 // unexpected connection close while talking to the ICAP service
-void Adaptation::Icap::Xaction::noteCommClosed(const CommCloseCbParams &io)
+void Adaptation::Icap::Xaction::noteCommClosed(const CommCloseCbParams &)
 {
     closer = NULL;
     handleCommClosed();
@@ -629,7 +629,7 @@ void Adaptation::Icap::Xaction::fillDoneStatus(MemBuf &buf) const
         buf.Printf("Stopped");
 }
 
-bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &buf) const
+bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &) const
 {
     return false;
 }
@@ -71,7 +71,7 @@ class Xaction: public Adaptation::Initiate
     virtual void handleCommClosed();
 
     /// record error detail if possible
-    virtual void detailError(int errDetail) {}
+    virtual void detailError(int) {}
 
     void openConnection();
     void closeConnection();
@@ -71,7 +71,7 @@ Auth::Config::registerWithCacheManager(void)
 {}
 
 void
-Auth::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
+Auth::Config::parse(Auth::Config * scheme, int, char *param_str)
 {
     if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
@@ -172,7 +172,7 @@ Auth::User::CachedACLsReset()
 }
 
 void
-Auth::User::cacheCleanup(void *datanotused)
+Auth::User::cacheCleanup(void *)
 {
     /*
      * We walk the hash by username as that is the unique key we use.
@@ -76,14 +76,14 @@ Auth::UserRequest::valid() const
 }
 
 void *
-Auth::UserRequest::operator new (size_t byteCount)
+Auth::UserRequest::operator new (size_t)
 {
     fatal("Auth::UserRequest not directly allocatable\n");
     return (void *)1;
 }
 
 void
-Auth::UserRequest::operator delete (void *address)
+Auth::UserRequest::operator delete (void *)
 {
     fatal("Auth::UserRequest child failed to override operator delete\n");
 }
@@ -193,11 +193,11 @@ Auth::UserRequest::direction()
 }
 
 void
-Auth::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accelerated)
+Auth::UserRequest::addAuthenticationInfoHeader(HttpReply *, int)
 {}
 
 void
-Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int accelerated)
+Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply *, int)
 {}
 
 void
@@ -534,7 +534,7 @@ authenticateFixHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_requ
 /* call the active auth module and allow it to add a trailer to the request */
 // TODO remove wrapper
 void
-authenticateAddTrailer(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated)
+authenticateAddTrailer(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest *, int accelerated)
 {
     if (auth_user_request != NULL)
         auth_user_request->addAuthenticationInfoTrailer(rep, accelerated);
@@ -72,7 +72,7 @@ Auth::Basic::Config::type() const
 }
 
 void
-Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest * request)
+Auth::Basic::Config::fixHeader(Auth::UserRequest::Pointer, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
 {
     if (authenticateProgram) {
         debugs(29, 9, "Sending type:" << hdrType << " header: 'Basic realm=\"" << realm << "\"'");
@@ -277,7 +277,7 @@ Auth::Basic::Config::decode(char const *proxy_auth, const char *aRequestRealm)
 /** Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
 void
-Auth::Basic::Config::init(Auth::Config * schemeCfg)
+Auth::Basic::Config::init(Auth::Config *)
 {
     if (authenticateProgram) {
         authbasic_initialised = 1;
@@ -50,7 +50,7 @@ Auth::Basic::UserRequest::credentialsStr()
 /* log a basic user in
  */
 void
-Auth::Basic::UserRequest::authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type)
+Auth::Basic::UserRequest::authenticate(HttpRequest *, ConnStateData *, http_hdr_type)
 {
     assert(user() != NULL);
 
@@ -70,8 +70,6 @@ Auth::Basic::UserRequest::authenticate(HttpRequest * request, ConnStateData * co
     /* Decode now takes care of finding the AuthUser struct in the cache */
     /* after external auth occurs anyway */
     user()->expiretime = current_time.tv_sec;
-
-    return;
 }
 
 Auth::Direction
@@ -244,7 +244,7 @@ authenticateDigestNonceShutdown(void)
 }
 
 static void
-authenticateDigestNonceCacheCleanup(void *data)
+authenticateDigestNonceCacheCleanup(void *)
 {
     /*
      * We walk the hash by nonceb64 as that is the unique key we
@@ -506,7 +506,7 @@ Auth::Digest::Config::configured() const
 
 /* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */
 void
-Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest * request)
+Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest *)
 {
     if (!authenticateProgram)
         return;
@@ -542,7 +542,7 @@ Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Ht
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
 void
-Auth::Digest::Config::init(Auth::Config * scheme)
+Auth::Digest::Config::init(Auth::Config *)
 {
     if (authenticateProgram) {
         DigestFieldsInfo = httpHeaderBuildFieldsInfo(DigestAttrs, DIGEST_ENUM_END);
@@ -78,7 +78,7 @@ Auth::Digest::UserRequest::credentialsStr()
 /** log a digest user in
  */
 void
-Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type)
+Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *, http_hdr_type)
 {
     HASHHEX SESSIONKEY;
     HASHHEX HA2 = "";
@@ -121,7 +121,7 @@ Auth::Negotiate::Config::type() const
  * Called AFTER parsing the config file
  */
 void
-Auth::Negotiate::Config::init(Auth::Config * scheme)
+Auth::Negotiate::Config::init(Auth::Config *)
 {
     if (authenticateProgram) {
 
@@ -252,7 +252,7 @@ authenticateNegotiateStats(StoreEntry * sentry)
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
-Auth::Negotiate::Config::decode(char const *proxy_auth, const char *aRequestRealm)
+Auth::Negotiate::Config::decode(char const *, const char *aRequestRealm)
 {
     Auth::Negotiate::User *newUser = new Auth::Negotiate::User(Auth::Config::Find("negotiate"), aRequestRealm);
     Auth::UserRequest *auth_user_request = new Auth::Negotiate::UserRequest();
@@ -107,7 +107,7 @@ Auth::Negotiate::UserRequest::module_direction()
 }
 
 void
-Auth::Negotiate::UserRequest::startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Negotiate::UserRequest::startHelperLookup(HttpRequest *, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -111,7 +111,7 @@ Auth::Ntlm::Config::type() const
 /* Initialize helpers and the like for this auth scheme. Called AFTER parsing the
  * config file */
 void
-Auth::Ntlm::Config::init(Auth::Config * scheme)
+Auth::Ntlm::Config::init(Auth::Config *)
 {
     if (authenticateProgram) {
 
@@ -232,7 +232,7 @@ authenticateNTLMStats(StoreEntry * sentry)
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
-Auth::Ntlm::Config::decode(char const *proxy_auth, const char *aRequestRealm)
+Auth::Ntlm::Config::decode(char const *, const char *aRequestRealm)
 {
     Auth::Ntlm::User *newUser = new Auth::Ntlm::User(Auth::Config::Find("ntlm"), aRequestRealm);
     Auth::UserRequest::Pointer auth_user_request = new Auth::Ntlm::UserRequest();
@@ -106,7 +106,7 @@ Auth::Ntlm::UserRequest::module_direction()
 }
 
 void
-Auth::Ntlm::UserRequest::startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Ntlm::UserRequest::startHelperLookup(HttpRequest *, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -22,10 +22,11 @@ class UnaryCbdataDialer : public CallDialer
 
     UnaryCbdataDialer(Handler *aHandler, Argument1 *aArg) :
         arg1(aArg),
-        handler(aHandler) {}
+        handler(aHandler)
+    {}
 
-    virtual bool canDial(AsyncCall &call) { return arg1.valid(); }
-    void dial(AsyncCall &call) { handler(arg1.get()); }
+    virtual bool canDial(AsyncCall &) { return arg1.valid(); }
+    void dial(AsyncCall &) { handler(arg1.get()); }
     virtual void print(std::ostream &os) const {  os << '(' << arg1 << ')'; }
 
 public:
@@ -123,7 +123,8 @@ void AsyncJob::callStart(AsyncCall &call)
            typeName << " status in:" << status());
 }
 
-void AsyncJob::callException(const std::exception &e)
+void
+AsyncJob::callException(const std::exception &)
 {
     // we must be called asynchronously and hence, the caller must lock us
     Must(cbdataReferenceValid(toCbdata()));
@@ -237,9 +237,9 @@ static void parse_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap);
 static void dump_CpuAffinityMap(StoreEntry *const entry, const char *const name, const CpuAffinityMap *const cpuAffinityMap);
 static void free_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap);
 
-static void parse_url_rewrite_timeout(SquidConfig *);
-static void dump_url_rewrite_timeout(StoreEntry *, const char *, SquidConfig &);
-static void free_url_rewrite_timeout(SquidConfig *);
+static void parse_UrlHelperTimeout(SquidConfig::UrlHelperTimeout *);
+static void dump_UrlHelperTimeout(StoreEntry *, const char *, SquidConfig::UrlHelperTimeout &);
+static void free_UrlHelperTimeout(SquidConfig::UrlHelperTimeout *);
 
 static int parseOneConfigFile(const char *file_name, unsigned int depth);
 
@@ -3334,9 +3334,7 @@ dump_removalpolicy(StoreEntry * entry, const char *name, RemovalPolicySettings *
 
 inline void
 free_YesNoNone(YesNoNone *)
-{
-    // do nothing: no explicit cleanup is required
-}
+{}
 
 static void
 parse_YesNoNone(YesNoNone *option)
@@ -3354,13 +3352,11 @@ dump_YesNoNone(StoreEntry * entry, const char *name, YesNoNone &option)
 }
 
 static void
-free_memcachemode(SquidConfig * config)
-{
-    return;
-}
+free_memcachemode(SquidConfig *)
+{}
 
 static void
-parse_memcachemode(SquidConfig * config)
+parse_memcachemode(SquidConfig *)
 {
     char *token = ConfigParser::NextToken();
     if (!token)
@@ -3385,7 +3381,7 @@ parse_memcachemode(SquidConfig * config)
 }
 
 static void
-dump_memcachemode(StoreEntry * entry, const char *name, SquidConfig &config)
+dump_memcachemode(StoreEntry * entry, const char *name, SquidConfig &)
 {
     storeAppendPrintf(entry, "%s ", name);
     if (Config.onoff.memory_cache_first && Config.onoff.memory_cache_disk)
@@ -4770,8 +4766,7 @@ static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderW
         return;
 
     for (HeaderWithAclList::iterator hwa = headers->begin(); hwa != headers->end(); ++hwa) {
-        storeAppendPrintf(entry, "%s ", hwa->fieldName.c_str());
-        storeAppendPrintf(entry, "%s ", hwa->fieldValue.c_str());
+        storeAppendPrintf(entry, "%s %s %s", name, hwa->fieldName.c_str(), hwa->fieldValue.c_str());
         if (hwa->aclList)
             dump_acl_list(entry, hwa->aclList);
         storeAppendPrintf(entry, "\n");
@@ -4914,7 +4909,7 @@ static void free_ftp_epsv(acl_access **ftp_epsv)
 }
 
 static void
-parse_url_rewrite_timeout(SquidConfig *config)
+parse_UrlHelperTimeout(SquidConfig::UrlHelperTimeout *config)
 {
     time_msec_t tval;
     parseTimeLine(&tval, T_SECOND_STR, false, true);
@@ -4924,62 +4919,61 @@ parse_url_rewrite_timeout(SquidConfig *config)
     while(ConfigParser::NextKvPair(key, value)) {
         if (strcasecmp(key, "on_timeout") == 0) {
             if (strcasecmp(value, "bypass") == 0)
-                Config.onUrlRewriteTimeout.action = toutActBypass;
+                config->action = toutActBypass;
             else if (strcasecmp(value, "fail") == 0)
-                Config.onUrlRewriteTimeout.action = toutActFail;
+                config->action = toutActFail;
             else if (strcasecmp(value, "retry") == 0)
-                Config.onUrlRewriteTimeout.action = toutActRetry;
+                config->action = toutActRetry;
             else if (strcasecmp(value, "use_configured_response") == 0) {
-                Config.onUrlRewriteTimeout.action = toutActUseConfiguredResponse;
+                config->action = toutActUseConfiguredResponse;
             } else {
                 debugs(3, DBG_CRITICAL, "FATAL: unsuported \"on_timeout\"  action:" << value);
                 self_destruct();
             }
         } else if (strcasecmp(key, "response") == 0) {
-            Config.onUrlRewriteTimeout.response = xstrdup(value);
+            config->response = xstrdup(value);
         } else {
             debugs(3, DBG_CRITICAL, "FATAL: unsuported option " << key);
             self_destruct();
         }
     }
 
-    if (Config.onUrlRewriteTimeout.action == toutActUseConfiguredResponse && !Config.onUrlRewriteTimeout.response) {
+    if (config->action == toutActUseConfiguredResponse && !config->response) {
         debugs(3, DBG_CRITICAL, "FATAL: Expected 'response=' option after 'on_timeout=use_configured_response' option");
         self_destruct();
     }
 
-    if (Config.onUrlRewriteTimeout.action != toutActUseConfiguredResponse && Config.onUrlRewriteTimeout.response) {
+    if (config->action != toutActUseConfiguredResponse && config->response) {
         debugs(3, DBG_CRITICAL, "FATAL: 'response=' option is valid only when used with the  'on_timeout=use_configured_response' option");
         self_destruct();
     }
 }
 
 static void
-dump_url_rewrite_timeout(StoreEntry *entry, const char *name, SquidConfig &config)
+dump_UrlHelperTimeout(StoreEntry *entry, const char *name, SquidConfig::UrlHelperTimeout &config)
 {
     const char  *onTimedOutActions[] = {"bypass", "fail", "retry", "use_configured_response"};
-    assert(Config.onUrlRewriteTimeout.action >= 0 && Config.onUrlRewriteTimeout.action <= toutActUseConfiguredResponse);
+    assert(config.action >= 0 && config.action <= toutActUseConfiguredResponse);
 
     dump_time_t(entry, name, Config.Timeout.urlRewrite);
-    storeAppendPrintf(entry, " on_timeout=%s", onTimedOutActions[Config.onUrlRewriteTimeout.action]);
+    storeAppendPrintf(entry, " on_timeout=%s", onTimedOutActions[config.action]);
 
-    if (Config.onUrlRewriteTimeout.response)
-        storeAppendPrintf(entry, " response=\"%s\"", Config.onUrlRewriteTimeout.response);
+    if (config.response)
+        storeAppendPrintf(entry, " response=\"%s\"", config.response);
 
     storeAppendPrintf(entry, "\n");
 }
 
 static void
-free_url_rewrite_timeout(SquidConfig *config)
+free_UrlHelperTimeout(SquidConfig::UrlHelperTimeout *config)
 {
     Config.Timeout.urlRewrite = 0;
-    Config.onUrlRewriteTimeout.action = 0;
-    xfree(Config.onUrlRewriteTimeout.response);
-    Config.onUrlRewriteTimeout.response = NULL;
+    config->action = 0;
+    safe_free(config->response);
 }
 
 static void
-parse_configuration_includes_quoted_values(bool *recognizeQuotedValues)
+parse_configuration_includes_quoted_values(bool *)
 {
     int val = 0;
     parse_onoff(&val);
@@ -4995,14 +4989,14 @@ parse_configuration_includes_quoted_values(bool *recognizeQuotedValues)
 }
 
 static void
-dump_configuration_includes_quoted_values(StoreEntry *const entry, const char *const name, bool recognizeQuotedValues)
+dump_configuration_includes_quoted_values(StoreEntry *const entry, const char *const name, bool)
 {
     int val = ConfigParser::RecognizeQuotedValues ? 1 : 0;
     dump_onoff(entry, name, val);
 }
 
 static void
-free_configuration_includes_quoted_values(bool *recognizeQuotedValues)
+free_configuration_includes_quoted_values(bool *)
 {
     ConfigParser::RecognizeQuotedValues = false;
     ConfigParser::StrictMode = false;
@@ -66,8 +66,12 @@ class cbdata
 {
 #if !HASHED_CBDATA
 public:
-    void *operator new(size_t size, void *where);
-    void operator delete(void *where, void *where2);
+    void *operator new(size_t, void *where) {return where;}
+    /**
+     * Only ever invoked when placement new throws
+     * an exception. Used to prevent an incorrect free.
+     */
+    void operator delete(void *, void *) {}
 #else
     MEMPROXY_CLASS(cbdata);
 #endif
@@ -105,7 +109,7 @@ class cbdata
 
     /* cookie used while debugging */
     long cookie;
-    void check(int aLine) const {assert(cookie == ((long)this ^ Cookie));}
+    void check(int) const {assert(cookie == ((long)this ^ Cookie));}
     static const long Cookie;
 
 #if !HASHED_CBDATA
@@ -122,24 +126,6 @@ const long cbdata::Cookie((long)0xDEADBEEF);
 #if !HASHED_CBDATA
 const long cbdata::Offset(MakeOffset());
 
-void *
-cbdata::operator new(size_t size, void *where)
-{
-    // assert (size == sizeof(cbdata));
-    return where;
-}
-
-/**
- * Only ever invoked when placement new throws
- * an exception. Used to prevent an incorrect
- * free.
- */
-void
-cbdata::operator delete(void *where, void *where2)
-{
-    ; // empty.
-}
-
 long
 cbdata::MakeOffset()
 {
@@ -74,7 +74,7 @@ time_msec
 time_t
 tristate
 uri_whitespace
-url_rewrite_timeout
+UrlHelperTimeout	acl
 u_short
 wccp2_method
 wccp2_amethod
@@ -4955,26 +4955,26 @@ DOC_START
 DOC_END
 
 NAME: url_rewrite_timeout
-TYPE: url_rewrite_timeout
-LOC: Config
+TYPE: UrlHelperTimeout
+LOC: Config.onUrlRewriteTimeout
 DEFAULT: none
 DEFAULT_DOC: Squid waits for the helper response forever
 DOC_START
 	Squid times active requests to redirector. The timeout value and Squid
 	reaction to a timed out request are configurable using the following
 	format:
 
-	url_rewrite_timeout timeout time-units  on_timeout=<action> [response=<quoted-response>]
+	url_rewrite_timeout timeout time-units on_timeout=<action> [response=<quoted-response>]
 
 	supported timeout actions:
-			fail  Squid return a ERR_GATEWAY_FAILURE error page
+		fail	Squid return a ERR_GATEWAY_FAILURE error page
 
-			bypass  Do not re-write the URL
+		bypass	Do not re-write the URL
 
-			retry  Send the lookup to the helper again
+		retry	Send the lookup to the helper again
 
-			use_configured_response  Use the <quoted-response> as
-			helper response
+		use_configured_response
+			Use the <quoted-response> as helper response
 DOC_END
 
 COMMENT_START
@@ -353,14 +353,14 @@ clientdbFreeMemory(void)
 }
 
 static void
-clientdbScheduledGC(void *unused)
+clientdbScheduledGC(void *)
 {
     cleanup_scheduled = 0;
     clientdbStartGC();
 }
 
 static void
-clientdbGC(void *unused)
+clientdbGC(void *)
 {
     static int bucket = 0;
     hash_link *link_next;
@@ -725,7 +725,7 @@ ConnStateData::notifyAllContexts(int xerrno)
 }
 
 /* This is a handler normally called by comm_close() */
-void ConnStateData::connStateClosed(const CommCloseCbParams &io)
+void ConnStateData::connStateClosed(const CommCloseCbParams &)
 {
     deleteThis("ConnStateData::connStateClosed");
 }
@@ -1489,9 +1489,9 @@ clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
 }
 
 static void
-clientWriteBodyComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size, Comm::Flag errflag, int xerrno, void *data)
+clientWriteBodyComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)
 {
-    debugs(33,7, HERE << "clientWriteBodyComplete schedules clientWriteComplete");
+    debugs(33,7, "schedule clientWriteComplete");
     clientWriteComplete(conn, NULL, size, errflag, xerrno, data);
 }
 
@@ -1783,7 +1783,7 @@ ClientSocketContext::socketState()
  * no more data to send.
  */
 void
-clientWriteComplete(const Comm::ConnectionPointer &conn, char *bufnotused, size_t size, Comm::Flag errflag, int xerrno, void *data)
+clientWriteComplete(const Comm::ConnectionPointer &conn, char *bufnotused, size_t size, Comm::Flag errflag, int, void *data)
 {
     ClientSocketContext *context = (ClientSocketContext *)data;
     context->writeComplete(conn, bufnotused, size, errflag);
@@ -1839,7 +1839,7 @@ ConnStateData::stopSending(const char *error)
 }
 
 void
-ClientSocketContext::writeComplete(const Comm::ConnectionPointer &conn, char *bufnotused, size_t size, Comm::Flag errflag)
+ClientSocketContext::writeComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag)
 {
     const StoreEntry *entry = http->storeEntry();
     http->out.size += size;
@@ -755,7 +755,7 @@ Ftp::Client::dataCloser()
 
 /// handler called by Comm when FTP data channel is closed unexpectedly
 void
-Ftp::Client::dataClosed(const CommCloseCbParams &io)
+Ftp::Client::dataClosed(const CommCloseCbParams &)
 {
     debugs(9, 4, status());
     if (data.listenConn != NULL) {
@@ -823,7 +823,7 @@ Ftp::Client::writeCommandCallback(const CommIoCbParams &io)
 
 /// handler called by Comm when FTP control channel is closed unexpectedly
 void
-Ftp::Client::ctrlClosed(const CommCloseCbParams &io)
+Ftp::Client::ctrlClosed(const CommCloseCbParams &)
 {
     debugs(9, 4, status());
     ctrl.clear();
@@ -448,7 +448,7 @@ Comm::ConnOpener::timeout(const CommTimeoutCbParams &)
  * XXX: As soon as Comm::SetSelect() accepts Async calls we can use a ConnOpener::doConnect call
  */
 void
-Comm::ConnOpener::InProgressConnectRetry(int fd, void *data)
+Comm::ConnOpener::InProgressConnectRetry(int, void *data)
 {
     Pointer *ptr = static_cast<Pointer*>(data);
     assert(ptr);
@@ -38,7 +38,7 @@
 
 CBDATA_NAMESPACED_CLASS_INIT(Comm, TcpAcceptor);
 
-Comm::TcpAcceptor::TcpAcceptor(const Comm::ConnectionPointer &newConn, const char *note, const Subscription::Pointer &aSub) :
+Comm::TcpAcceptor::TcpAcceptor(const Comm::ConnectionPointer &newConn, const char *, const Subscription::Pointer &aSub) :
     AsyncJob("Comm::TcpAcceptor"),
     errcode(0),
     isLimited(0),
@@ -47,7 +47,7 @@ Comm::TcpAcceptor::TcpAcceptor(const Comm::ConnectionPointer &newConn, const cha
     listenPort_()
 {}
 
-Comm::TcpAcceptor::TcpAcceptor(const AnyP::PortCfgPointer &p, const char *note, const Subscription::Pointer &aSub) :
+Comm::TcpAcceptor::TcpAcceptor(const AnyP::PortCfgPointer &p, const char *, const Subscription::Pointer &aSub) :
     AsyncJob("Comm::TcpAcceptor"),
     errcode(0),
     isLimited(0),
@@ -199,7 +199,7 @@ Comm::TcpAcceptor::setListen()
 /// called when listening descriptor is closed by an external force
 /// such as clientHttpConnectionsClose()
 void
-Comm::TcpAcceptor::handleClosure(const CommCloseCbParams &io)
+Comm::TcpAcceptor::handleClosure(const CommCloseCbParams &)
 {
     closer_ = NULL;
     conn = NULL;
@@ -190,7 +190,7 @@ diskCombineWrites(_fde_disk *fdd)
 
 /* write handler */
 static void
-diskHandleWrite(int fd, void *notused)
+diskHandleWrite(int fd, void *)
 {
     int len = 0;
     fde *F = &fd_table[fd];
@@ -769,7 +769,7 @@ idnsTickleQueue(void)
 }
 
 static void
-idnsSentQueryVC(const Comm::ConnectionPointer &conn, char *buf, size_t size, Comm::Flag flag, int xerrno, void *data)
+idnsSentQueryVC(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag flag, int, void *data)
 {
     nsvc * vc = (nsvc *)data;
 
@@ -823,7 +823,7 @@ idnsDoSendQueryVC(nsvc *vc)
 }
 
 static void
-idnsInitVCConnected(const Comm::ConnectionPointer &conn, Comm::Flag status, int xerrno, void *data)
+idnsInitVCConnected(const Comm::ConnectionPointer &conn, Comm::Flag status, int, void *data)
 {
     nsvc * vc = (nsvc *)data;
 
@@ -1117,7 +1117,7 @@ idnsCallback(idns_query *q, const char *error)
 }
 
 static void
-idnsGrokReply(const char *buf, size_t sz, int from_ns)
+idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
 {
     int n;
     rfc1035_message *message = NULL;
@@ -1269,7 +1269,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
 }
 
 static void
-idnsRead(int fd, void *data)
+idnsRead(int fd, void *)
 {
     int *N = &incoming_sockets_accepted;
     int len;
@@ -1354,7 +1354,7 @@ idnsRead(int fd, void *data)
 }
 
 static void
-idnsCheckQueue(void *unused)
+idnsCheckQueue(void *)
 {
     dlink_node *n;
     dlink_node *p = NULL;
@@ -1408,7 +1408,7 @@ idnsCheckQueue(void *unused)
 }
 
 static void
-idnsReadVC(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+idnsReadVC(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int, void *data)
 {
     nsvc * vc = (nsvc *)data;
 
@@ -1441,7 +1441,7 @@ idnsReadVC(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Fla
 }
 
 static void
-idnsReadVCHeader(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+idnsReadVCHeader(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int, void *data)
 {
     nsvc * vc = (nsvc *)data;
 
@@ -124,14 +124,14 @@ static IOCB errorSendComplete;
 class ErrorPageFile: public TemplateFile
 {
 public:
-    ErrorPageFile(const char *name, const err_type code): TemplateFile(name,code) { textBuf.init();}
+    ErrorPageFile(const char *name, const err_type code) : TemplateFile(name,code) {textBuf.init();}
 
     /// The template text data read from disk
     const char *text() { return textBuf.content(); }
 
 private:
     /// stores the data read from disk to a local buffer
-    virtual bool parse(const char *buf, int len, bool eof) {
+    virtual bool parse(const char *buf, int len, bool) {
         if (len)
             textBuf.append(buf, len);
         return true;
@@ -654,7 +654,7 @@ errorSend(const Comm::ConnectionPointer &conn, ErrorState * err)
  *     closing the FD, otherwise we do it ourselves.
  */
 static void
-errorSendComplete(const Comm::ConnectionPointer &conn, char *bufnotused, size_t size, Comm::Flag errflag, int xerrno, void *data)
+errorSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int, void *data)
 {
     ErrorState *err = static_cast<ErrorState *>(data);
     debugs(4, 3, HERE << conn << ", size=" << size);
@@ -1107,7 +1107,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 }
 
 void
-ErrorState::DenyInfoLocation(const char *name, HttpRequest *aRequest, MemBuf &result)
+ErrorState::DenyInfoLocation(const char *name, HttpRequest *, MemBuf &result)
 {
     char const *m = name;
     char const *p = m;
@@ -75,7 +75,7 @@ Eui::Eui64::lookupSlaac(const Ip::Address &c)
 
 // return binary representation of the EUI
 bool
-Eui::Eui64::lookupNdp(const Ip::Address &c)
+Eui::Eui64::lookupNdp(const Ip::Address &/*c*/)
 {
 #if 0 /* no actual lookup coded yet */
 
@@ -219,7 +219,7 @@ EventScheduler::timeRemaining() const
 }
 
 int
-EventScheduler::checkEvents(int timeout)
+EventScheduler::checkEvents(int)
 {
     int result = timeRemaining();
     if (result != 0)
@@ -164,7 +164,7 @@ default_write_method(int fd, const char *buf, int len)
 }
 
 int
-msghdr_read_method(int fd, char *buf, int len)
+msghdr_read_method(int fd, char *buf, int)
 {
     PROF_start(read);
     const int i = recvmsg(fd, reinterpret_cast<msghdr*>(buf), MSG_DONTWAIT);
@@ -30,6 +30,11 @@ namespace Format
 class TokenTableEntry
 {
 public:
+    TokenTableEntry() : configTag(NULL), tokenType(LFT_NONE), options(0) {}
+    TokenTableEntry(const char *aTag, const ByteCode_t &aType) : configTag(aTag), tokenType(aType), options(0) {}
+    // nothing to destruct configTag is pointer to global const string
+    ~TokenTableEntry() {}
+
     /// the config file ASCII representation for this token
     /// just the base tag bytes, excluding any option syntax bytes
     const char *configTag;
@@ -39,6 +44,10 @@ class TokenTableEntry
 
     /// 32-bit mask? of options affecting the output display of this token
     uint32_t options;
+
+private:
+    TokenTableEntry(const TokenTableEntry&); // not implemented
+    TokenTableEntry &operator =(const TokenTableEntry&); // not implemented
 };
 
 } // namespace Format
@@ -203,7 +203,7 @@ fqdncacheExpiredEntry(const fqdncache_entry * f)
 
 /// \ingroup FQDNCacheAPI
 void
-fqdncache_purgelru(void *notused)
+fqdncache_purgelru(void *)
 {
     dlink_node *m;
     dlink_node *prev = NULL;
@@ -374,13 +374,13 @@ class StoreIOStateCb: public CallDialer
         cbdataReferenceDone(callback_data); // may be nil already
     }
 
-    void dial(AsyncCall &call) {
+    void dial(AsyncCall &) {
         void *cbd;
         if (cbdataReferenceValidDone(callback_data, &cbd) && callback)
             callback(cbd, errflag, sio.getRaw());
     }
 
-    bool canDial(AsyncCall &call) const {
+    bool canDial(AsyncCall &) const {
         return cbdataReferenceValid(callback_data) && callback;
     }
 
@@ -389,7 +389,7 @@ class StoreIOStateCb: public CallDialer
     }
 
 private:
-    StoreIOStateCb &operator =(const StoreIOStateCb &cb); // not defined
+    StoreIOStateCb &operator =(const StoreIOStateCb &); // not defined
 
     StoreIOState::STIOCB *callback;
     void *callback_data;
@@ -51,7 +51,7 @@ Rock::StoreFileSystem::setup()
 }
 
 void
-Rock::StoreFileSystem::Stats(StoreEntry *sentry)
+Rock::StoreFileSystem::Stats(StoreEntry *)
 {
     assert(false); // XXX: implement
 }
@@ -52,7 +52,7 @@ Rock::SwapDir::~SwapDir()
 }
 
 StoreSearch *
-Rock::SwapDir::search(String const url, HttpRequest *)
+Rock::SwapDir::search(String const, HttpRequest *)
 {
     assert(false);
     return NULL; // XXX: implement
@@ -810,7 +810,7 @@ Rock::SwapDir::closeCompleted()
 }
 
 void
-Rock::SwapDir::readCompleted(const char *buf, int rlen, int errflag, RefCount< ::ReadRequest> r)
+Rock::SwapDir::readCompleted(const char *, int rlen, int errflag, RefCount< ::ReadRequest> r)
 {
     ReadRequest *request = dynamic_cast<Rock::ReadRequest*>(r.getRaw());
     assert(request);
@@ -823,7 +823,7 @@ Rock::SwapDir::readCompleted(const char *buf, int rlen, int errflag, RefCount< :
 }
 
 void
-Rock::SwapDir::writeCompleted(int errflag, size_t rlen, RefCount< ::WriteRequest> r)
+Rock::SwapDir::writeCompleted(int errflag, size_t, RefCount< ::WriteRequest> r)
 {
     Rock::WriteRequest *request = dynamic_cast<Rock::WriteRequest*>(r.getRaw());
     assert(request);
@@ -417,7 +417,7 @@ Fs::Ufs::RebuildState::undoAdd()
 }
 
 int
-Fs::Ufs::RebuildState::getNextFile(sfileno * filn_p, int *size)
+Fs::Ufs::RebuildState::getNextFile(sfileno * filn_p, int *)
 {
     int fd = -1;
     int dirs_opened = 0;
@@ -223,7 +223,7 @@ Fs::Ufs::UFSStoreState::doWrite()
 }
 
 void
-Fs::Ufs::UFSStoreState::readCompleted(const char *buf, int len, int errflag, RefCount<ReadRequest> result)
+Fs::Ufs::UFSStoreState::readCompleted(const char *buf, int len, int, RefCount<ReadRequest> result)
 {
     assert (result.getRaw());
     reading = false;
@@ -266,7 +266,7 @@ Fs::Ufs::UFSStoreState::readCompleted(const char *buf, int len, int errflag, Ref
 }
 
 void
-Fs::Ufs::UFSStoreState::writeCompleted(int errflag, size_t len, RefCount<WriteRequest> writeRequest)
+Fs::Ufs::UFSStoreState::writeCompleted(int, size_t len, RefCount<WriteRequest>)
 {
     debugs(79, 3, HERE << "dirno " << swap_dirn << ", fileno " <<
            std::setfill('0') << std::hex << std::uppercase << std::setw(8) << swap_filen <<
@@ -54,7 +54,7 @@ Fs::Ufs::UFSStrategy::unlinkFile(char const *path)
 }
 
 StoreIOState::Pointer
-Fs::Ufs::UFSStrategy::open(SwapDir * SD, StoreEntry * e, StoreIOState::STFNCB * file_callback,
+Fs::Ufs::UFSStrategy::open(SwapDir * SD, StoreEntry * e, StoreIOState::STFNCB *,
                            StoreIOState::STIOCB * aCallback, void *callback_data)
 {
     assert (((UFSSwapDir *)SD)->IO == this);
@@ -90,7 +90,7 @@ Fs::Ufs::UFSStrategy::open(SwapDir * SD, StoreEntry * e, StoreIOState::STFNCB *
 }
 
 StoreIOState::Pointer
-Fs::Ufs::UFSStrategy::create(SwapDir * SD, StoreEntry * e, StoreIOState::STFNCB * file_callback,
+Fs::Ufs::UFSStrategy::create(SwapDir * SD, StoreEntry * e, StoreIOState::STFNCB *,
                              StoreIOState::STIOCB * aCallback, void *callback_data)
 {
     assert (((UFSSwapDir *)SD)->IO == this);
@@ -729,7 +729,7 @@ Fs::Ufs::UFSSwapDir::addDiskRestore(const cache_key * key,
                                     time_t lastmod,
                                     uint32_t refcount,
                                     uint16_t newFlags,
-                                    int clean)
+                                    int)
 {
     StoreEntry *e = NULL;
     debugs(47, 5, HERE << storeKeyText(key)  <<
@@ -999,7 +999,7 @@ Fs::Ufs::UFSSwapDir::writeCleanDone()
 }
 
 void
-Fs::Ufs::UFSSwapDir::CleanEvent(void *unused)
+Fs::Ufs::UFSSwapDir::CleanEvent(void *)
 {
     static int swap_index = 0;
     int i;
@@ -1217,7 +1217,7 @@ Fs::Ufs::UFSSwapDir::swappedOut(const StoreEntry &e)
 }
 
 StoreSearch *
-Fs::Ufs::UFSSwapDir::search(String const url, HttpRequest *request)
+Fs::Ufs::UFSSwapDir::search(String const url, HttpRequest *)
 {
     if (url.size())
         fatal ("Cannot search by url yet\n");
@@ -153,7 +153,7 @@ gopherStateFree(const CommCloseCbParams &params)
 }
 
 void
-GopherStateData::deleteThis(const char *reason)
+GopherStateData::deleteThis(const char *)
 {
     swanSong();
     delete this;
@@ -888,7 +888,7 @@ gopherSendComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size,
  * This will be called when connect completes. Write request.
  */
 static void
-gopherSendRequest(int fd, void *data)
+gopherSendRequest(int, void *data)
 {
     GopherStateData *gopherState = (GopherStateData *)data;
     char *buf = (char *)memAllocate(MEM_4K_BUF);
@@ -953,7 +953,7 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
 }
 
 static void
-helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+helperHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len, Comm::Flag flag, int, void *data)
 {
     char *t = NULL;
     helper_server *srv = (helper_server *)data;
@@ -1047,7 +1047,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, Com
 }
 
 static void
-helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *, size_t len, Comm::Flag flag, int, void *data)
 {
     char *t = NULL;
     helper_stateful_server *srv = (helper_stateful_server *)data;
@@ -1339,7 +1339,7 @@ StatefulGetFirstAvailable(statefulhelper * hlp)
 }
 
 static void
-helperDispatchWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+helperDispatchWriteDone(const Comm::ConnectionPointer &, char *, size_t, Comm::Flag flag, int, void *data)
 {
     helper_server *srv = (helper_server *)data;
 
@@ -1408,11 +1408,8 @@ helperDispatch(helper_server * srv, Helper::Request * r)
 }
 
 static void
-helperStatefulDispatchWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag,
-                                int xerrno, void *data)
-{
-    /* nothing! */
-}
+helperStatefulDispatchWriteDone(const Comm::ConnectionPointer &, char *, size_t, Comm::Flag, int, void *)
+{}
 
 static void
 helperStatefulDispatch(helper_stateful_server * srv, Helper::Request * r)
@@ -276,12 +276,6 @@ static void htcpFreeDetail(htcpDetail * s);
 static void htcpHandleMsg(char *buf, int sz, Ip::Address &from);
 
 static void htcpLogHtcp(Ip::Address &, int, LogTags, const char *);
-static void htcpHandleMon(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
-
-static void htcpHandleNop(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
-
-static void htcpHandleSet(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
-
 static void htcpHandleTst(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
 static void htcpRecv(int fd, void *data);
@@ -298,24 +292,21 @@ static void
 htcpHexdump(const char *tag, const char *s, int sz)
 {
 #if USE_HEXDUMP
-    int i;
-    int k;
     char hex[80];
     debugs(31, 3, "htcpHexdump " << tag);
-    memset(hex, '\0', 80);
+    memset(hex, '\0', sizeof(hex));
 
-    for (i = 0; i < sz; ++i) {
-        k = i % 16;
+    for (int i = 0; i < sz; ++i) {
+        int k = i % 16;
         snprintf(&hex[k * 3], 4, " %02x", (int) *(s + i));
 
         if (k < 15 && i < (sz - 1))
             continue;
 
         debugs(31, 3, "\t" << hex);
 
-        memset(hex, '\0', 80);
+        memset(hex, '\0', sizeof(hex));
     }
-
 #endif
 }
 
@@ -972,13 +963,6 @@ htcpClrReply(htcpDataHeader * dhdr, int purgeSucceeded, Ip::Address &from)
     htcpSend(pkt, (int) pktlen, from);
 }
 
-static void
-
-htcpHandleNop(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
-{
-    debugs(31, 3, "htcpHandleNop: Unimplemented");
-}
-
 void
 htcpSpecifier::checkHit()
 {
@@ -1212,20 +1196,6 @@ htcpSpecifier::checkedHit(StoreEntry *e)
     htcpFreeSpecifier(this);
 }
 
-static void
-
-htcpHandleMon(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
-{
-    debugs(31, 3, "htcpHandleMon: Unimplemented");
-}
-
-static void
-
-htcpHandleSet(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
-{
-    debugs(31, 3, "htcpHandleSet: Unimplemented");
-}
-
 static void
 htcpHandleClr(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
@@ -1417,16 +1387,16 @@ htcpHandleMsg(char *buf, int sz, Ip::Address &from)
 
     switch (hdr.opcode) {
     case HTCP_NOP:
-        htcpHandleNop(&hdr, hbuf, hsz, from);
+        debugs(31, 3, "HTCP NOP not implemented");
         break;
     case HTCP_TST:
         htcpHandleTst(&hdr, hbuf, hsz, from);
         break;
     case HTCP_MON:
-        htcpHandleMon(&hdr, hbuf, hsz, from);
+        debugs(31, 3, "HTCP MON not implemented");
         break;
     case HTCP_SET:
-        htcpHandleSet(&hdr, hbuf, hsz, from);
+        debugs(31, 3, "HTCP SET not implemented");
         break;
     case HTCP_CLR:
         htcpHandleClr(&hdr, hbuf, hsz, from);
@@ -1438,7 +1408,7 @@ htcpHandleMsg(char *buf, int sz, Ip::Address &from)
 }
 
 static void
-htcpRecv(int fd, void *data)
+htcpRecv(int fd, void *)
 {
     static char buf[8192];
     int len;
@@ -1595,7 +1565,7 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
  * Send an HTCP CLR message for a specified item to a given CachePeer.
  */
 void
-htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &method, CachePeer * p, htcp_clr_reason reason)
+htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestMethod &, CachePeer * p, htcp_clr_reason reason)
 {
     static char pkt[8192];
     ssize_t pktlen;
@@ -157,9 +157,9 @@ HttpStateData::httpStateConnClosed(const CommCloseCbParams &params)
 }
 
 void
-HttpStateData::httpTimeout(const CommTimeoutCbParams &params)
+HttpStateData::httpTimeout(const CommTimeoutCbParams &)
 {
-    debugs(11, 4, HERE << serverConnection << ": '" << entry->url() << "'" );
+    debugs(11, 4, serverConnection << ": '" << entry->url() << "'");
 
     if (entry->store_status == STORE_PENDING) {
         fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, fwd->request));
@@ -72,7 +72,7 @@ Http::StatusLine::packInto(Packer * p) const
  * XXX: Note 'end' currently unused, so NULL-termination assumed.
  */
 bool
-Http::StatusLine::parse(const String &protoPrefix, const char *start, const char *end)
+Http::StatusLine::parse(const String &protoPrefix, const char *start, const char * /*end*/)
 {
     status_ = Http::scInvalidHeader;    /* Squid header parsing error */
 
@@ -213,7 +213,7 @@ icpLogIcp(const Ip::Address &caddr, LogTags logcode, int len, const char *url, i
 
 /// \ingroup ServerProtocolICPInternal2
 void
-icpUdpSendQueue(int fd, void *unused)
+icpUdpSendQueue(int fd, void *)
 {
     icpUdpData *q;
 
@@ -578,7 +578,7 @@ icpPktDump(icp_common_t * pkt)
 #endif
 
 void
-icpHandleUdp(int sock, void *data)
+icpHandleUdp(int sock, void *)
 {
     int *N = &incoming_sockets_accepted;
 
@@ -707,7 +707,7 @@ icpOpenPorts(void)
 }
 
 static void
-icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo)
+icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int)
 {
     if (!Comm::IsConnOpen(conn))
         fatal("Cannot open ICP Port");
@@ -73,7 +73,7 @@ static void ClientAdd(IdentStateData * state, IDCB * callback, void *callback_da
 Ident::IdentConfig Ident::TheConfig;
 
 void
-Ident::IdentStateData::deleteThis(const char *aReason)
+Ident::IdentStateData::deleteThis(const char *)
 {
     swanSong();
     delete this;
@@ -124,7 +124,7 @@ Ident::Timeout(const CommTimeoutCbParams &io)
 }
 
 void
-Ident::ConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int xerrno, void *data)
+Ident::ConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
 
@@ -164,7 +164,7 @@ Ident::ConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int x
 }
 
 void
-Ident::WriteFeedback(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+Ident::WriteFeedback(const Comm::ConnectionPointer &conn, char *, size_t len, Comm::Flag flag, int xerrno, void *data)
 {
     debugs(30, 5, HERE << conn << ": Wrote IDENT request " << len << " bytes.");
 
@@ -177,7 +177,7 @@ Ident::WriteFeedback(const Comm::ConnectionPointer &conn, char *buf, size_t len,
 }
 
 void
-Ident::ReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+Ident::ReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
     char *ident = NULL;
@@ -140,7 +140,7 @@ Ip::Intercept::NetfilterInterception(const Comm::ConnectionPointer &newConn, int
 }
 
 bool
-Ip::Intercept::TproxyTransparent(const Comm::ConnectionPointer &newConn, int silent)
+Ip::Intercept::TproxyTransparent(const Comm::ConnectionPointer &newConn, int)
 {
 #if (LINUX_NETFILTER && defined(IP_TRANSPARENT)) || \
     (PF_TRANSPARENT && defined(SO_BINDANY)) || \
@@ -158,7 +158,7 @@ Ip::Intercept::TproxyTransparent(const Comm::ConnectionPointer &newConn, int sil
 }
 
 bool
-Ip::Intercept::IpfwInterception(const Comm::ConnectionPointer &newConn, int silent)
+Ip::Intercept::IpfwInterception(const Comm::ConnectionPointer &newConn, int)
 {
 #if IPFW_TRANSPARENT
     /* The getsockname() call performed already provided the TCP packet details.
@@ -117,7 +117,7 @@ void Ip::Qos::getNfmarkFromServer(const Comm::ConnectionPointer &server, const f
 
 #if USE_LIBNETFILTERCONNTRACK
 int
-Ip::Qos::getNfMarkCallback(enum nf_conntrack_msg_type type,
+Ip::Qos::getNfMarkCallback(enum nf_conntrack_msg_type,
                            struct nf_conntrack *ct,
                            void *data)
 {
@@ -137,7 +137,7 @@ Ipc::BaseMultiQueue::BaseMultiQueue(const int aLocalProcessId):
 }
 
 void
-Ipc::BaseMultiQueue::clearReaderSignal(const int remoteProcessId)
+Ipc::BaseMultiQueue::clearReaderSignal(const int /*remoteProcessId*/)
 {
     QueueReader &reader = localReader();
     debugs(54, 7, "reader: " << reader.id);
@@ -210,7 +210,7 @@ ipcacheExpiredEntry(ipcache_entry * i)
 
 /// \ingroup IPCacheAPI
 void
-ipcache_purgelru(void *voidnotused)
+ipcache_purgelru(void *)
 {
     dlink_node *m;
     dlink_node *prev = NULL;
@@ -88,7 +88,7 @@ logfileFreeBuffer(Logfile * lf, logfile_buffer_t * b)
 }
 
 static void
-logfileHandleWrite(int fd, void *data)
+logfileHandleWrite(int, void *data)
 {
     Logfile *lf = static_cast<Logfile *>(data);
     l_daemon_t *ll = static_cast<l_daemon_t *>(lf->data);
@@ -207,7 +207,7 @@ logfileFlushEvent(void *data)
 /* External code */
 
 int
-logfile_mod_daemon_open(Logfile * lf, const char *path, size_t bufsz, int fatal_flag)
+logfile_mod_daemon_open(Logfile * lf, const char *path, size_t, int)
 {
     const char *args[5];
     char *tmpbuf;
@@ -77,7 +77,7 @@ logfile_mod_stdio_writeline(Logfile * lf, const char *buf, size_t len)
 }
 
 static void
-logfile_mod_stdio_linestart(Logfile * lf)
+logfile_mod_stdio_linestart(Logfile *)
 {
 }
 
@@ -98,34 +98,34 @@ typedef struct {
 #define PRIORITY_MASK (LOG_ERR | LOG_WARNING | LOG_NOTICE | LOG_INFO | LOG_DEBUG)
 
 static void
-logfile_mod_syslog_writeline(Logfile * lf, const char *buf, size_t len)
+logfile_mod_syslog_writeline(Logfile * lf, const char *buf, size_t)
 {
     l_syslog_t *ll = (l_syslog_t *) lf->data;
     syslog(ll->syslog_priority, "%s", (char *) buf);
 }
 
 static void
-logfile_mod_syslog_linestart(Logfile * lf)
+logfile_mod_syslog_linestart(Logfile *)
 {
 }
 
 static void
-logfile_mod_syslog_lineend(Logfile * lf)
+logfile_mod_syslog_lineend(Logfile *)
 {
 }
 
 static void
-logfile_mod_syslog_flush(Logfile * lf)
+logfile_mod_syslog_flush(Logfile *)
 {
 }
 
 static void
-logfile_mod_syslog_rotate(Logfile * lf)
+logfile_mod_syslog_rotate(Logfile *)
 {
 }
 
 static void
-logfile_mod_syslog_close(Logfile * lf)
+logfile_mod_syslog_close(Logfile *lf)
 {
     xfree(lf->data);
     lf->data = NULL;
@@ -135,7 +135,7 @@ logfile_mod_syslog_close(Logfile * lf)
  * This code expects the path to be syslog:<priority>
  */
 int
-logfile_mod_syslog_open(Logfile * lf, const char *path, size_t bufsz, int fatal_flag)
+logfile_mod_syslog_open(Logfile * lf, const char *path, size_t, int)
 {
     lf->f_close = logfile_mod_syslog_close;
     lf->f_linewrite = logfile_mod_syslog_writeline;
@@ -94,19 +94,18 @@ logfile_mod_udp_writeline(Logfile * lf, const char *buf, size_t len)
 }
 
 static void
-logfile_mod_udp_linestart(Logfile * lf)
+logfile_mod_udp_linestart(Logfile *)
 {
 }
 
 static void
-logfile_mod_udp_lineend(Logfile * lf)
+logfile_mod_udp_lineend(Logfile *)
 {
 }
 
 static void
-logfile_mod_udp_rotate(Logfile * lf)
+logfile_mod_udp_rotate(Logfile *)
 {
-    return;
 }
 
 static void
@@ -363,7 +363,7 @@ Log::TcpLogger::writeDone(const CommIoCbParams &io)
 /// This is our comm_close_handler. It is called when some external force
 /// (e.g., reconfigure or shutdown) is closing the connection (rather than us).
 void
-Log::TcpLogger::handleClosure(const CommCloseCbParams &io)
+Log::TcpLogger::handleClosure(const CommCloseCbParams &)
 {
     assert(inCall != NULL);
     closer = NULL;
@@ -411,7 +411,7 @@ Log::TcpLogger::WriteLine(Logfile * lf, const char *buf, size_t len)
 }
 
 void
-Log::TcpLogger::StartLine(Logfile * lf)
+Log::TcpLogger::StartLine(Logfile *)
 {
 }
 
@@ -423,7 +423,7 @@ Log::TcpLogger::EndLine(Logfile * lf)
 }
 
 void
-Log::TcpLogger::Rotate(Logfile * lf)
+Log::TcpLogger::Rotate(Logfile *)
 {
 }
 
@@ -185,7 +185,7 @@ class StoreRootEngine : public AsyncEngine
 {
 
 public:
-    int checkEvents(int timeout) {
+    int checkEvents(int) {
         Store::Root().callback();
         return EVENT_IDLE;
     };
@@ -207,7 +207,7 @@ class SignalEngine: public AsyncEngine
 };
 
 int
-SignalEngine::checkEvents(int timeout)
+SignalEngine::checkEvents(int)
 {
     PROF_start(SignalEngine_checkEvents);
 
@@ -217,7 +217,7 @@ class MemAllocator
      \note  As a general guideline, increase chunk size only for pools that keep
      *      very many items for relatively long time.
      */
-    virtual void setChunkSize(size_t chunksize) {}
+    virtual void setChunkSize(size_t) {}
 
     /**
      \param minSize Minimum size needed to be allocated.
@@ -321,7 +321,7 @@ MemPoolChunked::allocate()
 }
 
 void
-MemPoolChunked::deallocate(void *obj, bool aggressive)
+MemPoolChunked::deallocate(void *obj, bool)
 {
     push(obj);
     assert(meter.inuse.level > 0);
@@ -106,7 +106,7 @@ MemPoolMalloc::idleTrigger(int shift) const
 }
 
 void
-MemPoolMalloc::clean(time_t maxage)
+MemPoolMalloc::clean(time_t)
 {
     while (!freelist.empty()) {
         void *obj = freelist.top();
@@ -177,7 +177,7 @@ Mem::Stats(StoreEntry * sentry)
  * Relies on Mem::Init() having been called beforehand.
  */
 void
-memDataInit(mem_type type, const char *name, size_t size, int max_pages_notused, bool doZero)
+memDataInit(mem_type type, const char *name, size_t size, int, bool doZero)
 {
     assert(name && size);
 
@@ -360,7 +360,7 @@ memFreeBuf(size_t size, void *buf)
 static double clean_interval = 15.0;    /* time to live of idle chunk before release */
 
 void
-Mem::CleanIdlePools(void *unused)
+Mem::CleanIdlePools(void *)
 {
     MemPools::GetInstance().clean(static_cast<time_t>(clean_interval));
     eventAdd("memPoolCleanIdlePools", CleanIdlePools, NULL, clean_interval, 1);
@@ -60,12 +60,12 @@ Mgr::Action::createStoreEntry() const
 }
 
 void
-Mgr::Action::add(const Action& action)
+Mgr::Action::add(const Action &)
 {
 }
 
 void
-Mgr::Action::respond(const Request& request)
+Mgr::Action::respond(const Request &request)
 {
     debugs(16, 5, HERE);
 
@@ -49,9 +49,10 @@ class Action: public RefCountable
     virtual void respond(const Request &request);
 
     /// pack collected action info into a message to be sent to Coordinator
-    virtual void pack(Ipc::TypedMsgHdr &msg) const {}
+    virtual void pack(Ipc::TypedMsgHdr &) const {}
+
     /// unpack action info from the message received by Coordinator
-    virtual void unpack(const Ipc::TypedMsgHdr &msg) {}
+    virtual void unpack(const Ipc::TypedMsgHdr &) {}
 
     /// notify Coordinator that this action is done with local processing
     void sendResponse(unsigned int requestId);
@@ -79,7 +80,7 @@ class Action: public RefCountable
      * may collect info during dump, especially if collect() did nothing
      * non-atomic() actions may continue writing asynchronously after returning
      */
-    virtual void dump(StoreEntry *entry) {}
+    virtual void dump(StoreEntry *) {}
 
 private:
     const CommandPointer cmd; ///< the command that caused this action
@@ -31,7 +31,7 @@ Mgr::IndexAction::IndexAction(const Command::Pointer &aCmd): Action(aCmd)
 }
 
 void
-Mgr::IndexAction::dump(StoreEntry* entry)
+Mgr::IndexAction::dump(StoreEntry *)
 {
     debugs(16, 5, HERE);
 }
@@ -75,7 +75,7 @@ Mgr::ShutdownAction::ShutdownAction(const Command::Pointer &aCmd): Action(aCmd)
 }
 
 void
-Mgr::ShutdownAction::dump(StoreEntry* entry)
+Mgr::ShutdownAction::dump(StoreEntry *)
 {
     debugs(16, DBG_CRITICAL, "Shutdown by Cache Manager command.");
     shut_down(SIGTERM);
@@ -86,7 +86,7 @@ Mgr::Forwarder::handleTimeout()
 }
 
 void
-Mgr::Forwarder::handleException(const std::exception& e)
+Mgr::Forwarder::handleException(const std::exception &e)
 {
     if (entry != NULL && httpRequest != NULL && Comm::IsConnOpen(conn))
         sendError(new ErrorState(ERR_INVALID_RESP, Http::scInternalServerError, httpRequest));
@@ -95,7 +95,7 @@ Mgr::Forwarder::handleException(const std::exception& e)
 
 /// called when the client socket gets closed by some external force
 void
-Mgr::Forwarder::noteCommClosed(const CommCloseCbParams& params)
+Mgr::Forwarder::noteCommClosed(const CommCloseCbParams &)
 {
     debugs(16, 5, HERE);
     conn = NULL; // needed?
@@ -126,7 +126,7 @@ Mgr::StoreToCommWriter::noteCommWrote(const CommIoCbParams& params)
 }
 
 void
-Mgr::StoreToCommWriter::noteCommClosed(const CommCloseCbParams& params)
+Mgr::StoreToCommWriter::noteCommClosed(const CommCloseCbParams &)
 {
     debugs(16, 6, HERE);
     Must(!Comm::IsConnOpen(clientConnection));
@@ -437,7 +437,7 @@ MimeEntry::MimeEntry(const char *aPattern, const regex_t &compiledPattern,
     content_type(xstrdup(aContentType)),
     content_encoding(xstrdup(aContentEncoding)),
     view_option(optionViewEnable),
-    download_option(optionViewEnable),
+    download_option(optionDownloadEnable),
     theIcon(anIconName), next(NULL)
 {
     if (!strcasecmp(aTransferMode, "ascii"))
@@ -31,7 +31,7 @@ mcastSetTtl(int fd, int mcast_ttl)
 }
 
 void
-mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *datanotused)
+mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *)
 {
 #ifdef IP_MULTICAST_TTL
     struct ip_mreq mr;
@@ -869,7 +869,7 @@ peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup)
 }
 
 static void
-neighborAlive(CachePeer * p, const MemObject * mem, const icp_common_t * header)
+neighborAlive(CachePeer * p, const MemObject *, const icp_common_t * header)
 {
     peerAlive(p);
     ++ p->stats.pings_acked;
@@ -906,7 +906,7 @@ neighborUpdateRtt(CachePeer * p, MemObject * mem)
 
 #if USE_HTCP
 static void
-neighborAliveHtcp(CachePeer * p, const MemObject * mem, const HtcpReplyData * htcp)
+neighborAliveHtcp(CachePeer * p, const MemObject *, const HtcpReplyData * htcp)
 {
     peerAlive(p);
     ++ p->stats.pings_acked;
@@ -1353,7 +1353,7 @@ peerProbeConnect(CachePeer * p)
 }
 
 static void
-peerProbeConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int xerrno, void *data)
+peerProbeConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int, void *data)
 {
     CachePeer *p = (CachePeer*)data;
 
@@ -1452,19 +1452,17 @@ peerCountMcastPeersDone(void *data)
 }
 
 static void
-peerCountHandleIcpReply(CachePeer * p, peer_t type, AnyP::ProtocolType proto, void *hdrnotused, void *data)
+peerCountHandleIcpReply(CachePeer * p, peer_t, AnyP::ProtocolType proto, void *, void *data)
 {
-    int rtt_av_factor;
-
     ps_state *psstate = (ps_state *)data;
     StoreEntry *fake = psstate->entry;
+    assert(fake);
     MemObject *mem = fake->mem_obj;
+    assert(mem);
     int rtt = tvSubMsec(mem->start_ping, current_time);
     assert(proto == AnyP::PROTO_ICP);
-    assert(fake);
-    assert(mem);
     ++ psstate->ping.n_recv;
-    rtt_av_factor = RTT_AV_FACTOR;
+    int rtt_av_factor = RTT_AV_FACTOR;
 
     if (p->options.weighted_roundrobin)
         rtt_av_factor = RTT_BACKGROUND_AV_FACTOR;
@@ -289,7 +289,7 @@ IdleConnList::findAndClose(const Comm::ConnectionPointer &conn)
 }
 
 void
-IdleConnList::Read(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm::Flag flag, int xerrno, void *data)
+IdleConnList::Read(const Comm::ConnectionPointer &conn, char *, size_t len, Comm::Flag flag, int, void *data)
 {
     debugs(48, 3, HERE << len << " bytes from " << conn);
 
@@ -25,7 +25,7 @@
 static IPH send_announce;
 
 void
-start_announce(void *datanotused)
+start_announce(void *)
 {
     if (0 == Config.onoff.announce)
         return;
@@ -39,7 +39,7 @@ start_announce(void *datanotused)
 }
 
 static void
-send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *junk)
+send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *)
 {
     LOCAL_ARRAY(char, tbuf, 256);
     LOCAL_ARRAY(char, sndbuf, BUFSIZ);
@@ -149,7 +149,7 @@ Ftp::Server::doProcessRequest()
 }
 
 void
-Ftp::Server::processParsedRequest(ClientSocketContext *context)
+Ftp::Server::processParsedRequest(ClientSocketContext *)
 {
     Must(getConcurrentRequestCount() == 1);
 
@@ -1128,7 +1128,7 @@ Ftp::Server::writeForwardedForeign(const HttpReply *reply)
 }
 
 void
-Ftp::Server::writeControlMsgAndCall(ClientSocketContext *context, HttpReply *reply, AsyncCall::Pointer &call)
+Ftp::Server::writeControlMsgAndCall(ClientSocketContext *, HttpReply *reply, AsyncCall::Pointer &call)
 {
     // the caller guarantees that we are dealing with the current context only
     // the caller should also make sure reply->header.has(HDR_FTP_STATUS)
@@ -1188,7 +1188,7 @@ Ftp::Server::writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Point
 }
 
 static void
-Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const prefix)
+Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const)
 {
     const HttpHeader &header = reply->header;
 
@@ -1335,7 +1335,7 @@ Ftp::Server::handleRequest(HttpRequest *request)
 /// Called to parse USER command, which is required to create an HTTP request
 /// wrapper. W/o request, the errors are handled by returning earlyError().
 ClientSocketContext *
-Ftp::Server::handleUserRequest(const SBuf &cmd, SBuf &params)
+Ftp::Server::handleUserRequest(const SBuf &, SBuf &params)
 {
     if (params.isEmpty())
         return earlyError(eekMissingUsername);
@@ -1383,14 +1383,14 @@ Ftp::Server::handleUserRequest(const SBuf &cmd, SBuf &params)
 }
 
 bool
-Ftp::Server::handleFeatRequest(String &cmd, String &params)
+Ftp::Server::handleFeatRequest(String &, String &)
 {
     changeState(fssHandleFeat, "handleFeatRequest");
     return true;
 }
 
 bool
-Ftp::Server::handlePasvRequest(String &cmd, String &params)
+Ftp::Server::handlePasvRequest(String &, String &params)
 {
     if (gotEpsvAll) {
         setReply(500, "Bad PASV command");
@@ -1444,7 +1444,7 @@ Ftp::Server::createDataConnection(Ip::Address cltAddr)
 }
 
 bool
-Ftp::Server::handlePortRequest(String &cmd, String &params)
+Ftp::Server::handlePortRequest(String &, String &params)
 {
     // TODO: Should PORT errors trigger closeDataConnection() cleanup?
 
@@ -1473,7 +1473,7 @@ Ftp::Server::handlePortRequest(String &cmd, String &params)
 }
 
 bool
-Ftp::Server::handleDataRequest(String &cmd, String &params)
+Ftp::Server::handleDataRequest(String &, String &)
 {
     if (!checkDataConnPre())
         return false;
@@ -1484,7 +1484,7 @@ Ftp::Server::handleDataRequest(String &cmd, String &params)
 }
 
 bool
-Ftp::Server::handleUploadRequest(String &cmd, String &params)
+Ftp::Server::handleUploadRequest(String &, String &)
 {
     if (!checkDataConnPre())
         return false;
@@ -1515,7 +1515,7 @@ Ftp::Server::handleUploadRequest(String &cmd, String &params)
 }
 
 bool
-Ftp::Server::handleEprtRequest(String &cmd, String &params)
+Ftp::Server::handleEprtRequest(String &, String &params)
 {
     debugs(9, 3, "Process an EPRT " << params);
 
@@ -1544,7 +1544,7 @@ Ftp::Server::handleEprtRequest(String &cmd, String &params)
 }
 
 bool
-Ftp::Server::handleEpsvRequest(String &cmd, String &params)
+Ftp::Server::handleEpsvRequest(String &, String &params)
 {
     debugs(9, 3, "Process an EPSV command with params: " << params);
     if (params.size() <= 0) {
@@ -1569,21 +1569,21 @@ Ftp::Server::handleEpsvRequest(String &cmd, String &params)
 }
 
 bool
-Ftp::Server::handleCwdRequest(String &cmd, String &params)
+Ftp::Server::handleCwdRequest(String &, String &)
 {
     changeState(fssHandleCwd, "handleCwdRequest");
     return true;
 }
 
 bool
-Ftp::Server::handlePassRequest(String &cmd, String &params)
+Ftp::Server::handlePassRequest(String &, String &)
 {
     changeState(fssHandlePass, "handlePassRequest");
     return true;
 }
 
 bool
-Ftp::Server::handleCdupRequest(String &cmd, String &params)
+Ftp::Server::handleCdupRequest(String &, String &)
 {
     changeState(fssHandleCdup, "handleCdupRequest");
     return true;
@@ -300,7 +300,7 @@ snmpOpenPorts(void)
 }
 
 static void
-snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo)
+snmpPortOpened(const Comm::ConnectionPointer &conn, int)
 {
     if (!Comm::IsConnOpen(conn))
         fatalf("Cannot open SNMP %s Port",(conn->fd == snmpIncomingConn->fd?"receiving":"sending"));
@@ -340,7 +340,7 @@ snmpClosePorts(void)
  * Accept the UDP packet
  */
 void
-snmpHandleUdp(int sock, void *not_used)
+snmpHandleUdp(int sock, void *)
 {
     static char buf[SNMP_REQUEST_SIZE];
     Ip::Address from;
@@ -806,7 +806,6 @@ void
 DumpMallocStatistics(StoreEntry* sentry)
 {
 #if XMALLOC_STATISTICS
-
     xm_deltat = current_dtime - xm_time;
     xm_time = current_dtime;
     storeAppendPrintf(sentry, "\nMemory allocation statistics\n");
@@ -1255,7 +1254,7 @@ statInit(void)
 }
 
 static void
-statAvgTick(void *notused)
+statAvgTick(void *)
 {
     StatCounters *t = &CountHist[0];
     StatCounters *p = &CountHist[1];
@@ -127,7 +127,7 @@ Store::Root(StorePointer aRoot)
 void
 Store::Stats(StoreEntry * output)
 {
-    assert (output);
+    assert(output);
     Root().stat(*output);
 }
 
@@ -144,15 +144,15 @@ Store::sync()
 {}
 
 void
-Store::unlink (StoreEntry &anEntry)
+Store::unlink(StoreEntry &)
 {
     fatal("Store::unlink on invalid Store\n");
 }
 
 void *
 StoreEntry::operator new (size_t bytecount)
 {
-    assert (bytecount == sizeof (StoreEntry));
+    assert(bytecount == sizeof (StoreEntry));
 
     if (!pool) {
         pool = memPoolCreate ("StoreEntry", bytecount);
@@ -279,13 +279,13 @@ StoreEntry::bytesWanted (Range<size_t> const aRange, bool ignoreDelayPools) cons
 }
 
 bool
-StoreEntry::checkDeferRead(int fd) const
+StoreEntry::checkDeferRead(int) const
 {
     return (bytesWanted(Range<size_t>(0,INT_MAX)) == 0);
 }
 
 void
-StoreEntry::setNoDelay (bool const newValue)
+StoreEntry::setNoDelay(bool const newValue)
 {
     if (mem_obj)
         mem_obj->setNoDelay(newValue);
@@ -1195,7 +1195,7 @@ storeGetMemSpace(int size)
  * it becomes active will self register
  */
 void
-Store::Maintain(void *notused)
+Store::Maintain(void *)
 {
     Store::Root().maintain();
 
@@ -1287,7 +1287,7 @@ StoreEntry::release()
 }
 
 static void
-storeLateRelease(void *unused)
+storeLateRelease(void *)
 {
     StoreEntry *e;
     static int n = 0;
@@ -1934,7 +1934,7 @@ StoreEntry::transientsAbandonmentCheck()
 }
 
 void
-StoreEntry::memOutDecision(const bool willCacheInRam)
+StoreEntry::memOutDecision(const bool)
 {
     transientsAbandonmentCheck();
 }
@@ -459,7 +459,7 @@ store_client::fileRead()
 }
 
 void
-store_client::readBody(const char *buf, ssize_t len)
+store_client::readBody(const char *, ssize_t len)
 {
     int parsed_header = 0;
 
@@ -513,14 +513,14 @@ store_client::fail()
 }
 
 static void
-storeClientReadHeader(void *data, const char *buf, ssize_t len, StoreIOState::Pointer self)
+storeClientReadHeader(void *data, const char *buf, ssize_t len, StoreIOState::Pointer)
 {
     store_client *sc = (store_client *)data;
     sc->readHeader(buf, len);
 }
 
 static void
-storeClientReadBody(void *data, const char *buf, ssize_t len, StoreIOState::Pointer self)
+storeClientReadBody(void *data, const char *buf, ssize_t len, StoreIOState::Pointer)
 {
     store_client *sc = (store_client *)data;
     sc->readBody(buf, len);
@@ -748,7 +748,7 @@ StoreController::find(const cache_key *key)
 }
 
 void
-StoreController::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+StoreController::get(String const, STOREGETCLIENT, void *)
 {
     fatal("not implemented");
 }
@@ -1079,7 +1079,7 @@ StoreHashIndex::get(const cache_key *key)
 }
 
 void
-StoreHashIndex::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+StoreHashIndex::get(String const, STOREGETCLIENT, void *)
 {
     fatal("not implemented");
 }
@@ -48,7 +48,7 @@ storeCleanupDoubleCheck(StoreEntry * e)
 }
 
 static void
-storeCleanup(void *datanotused)
+storeCleanup(void *)
 {
     static int store_errors = 0;
     static StoreSearchPointer currentSearch;
@@ -51,7 +51,7 @@ storeSwapInStart(store_client * sc)
 }
 
 static void
-storeSwapInFileClosed(void *data, int errflag, StoreIOState::Pointer self)
+storeSwapInFileClosed(void *data, int errflag, StoreIOState::Pointer)
 {
     store_client *sc = (store_client *)data;
     debugs(20, 3, "storeSwapInFileClosed: sio=" << sc->swapin_sio.getRaw() << ", errflag=" << errflag);
@@ -66,7 +66,7 @@ storeSwapInFileClosed(void *data, int errflag, StoreIOState::Pointer self)
 }
 
 static void
-storeSwapInFileNotify(void *data, int errflag, StoreIOState::Pointer self)
+storeSwapInFileNotify(void *data, int, StoreIOState::Pointer)
 {
     store_client *sc = (store_client *)data;
     StoreEntry *e = sc->entry;
@@ -30,22 +30,21 @@ int Debug::log_stderr = 1;
 bool Debug::log_syslog = false;
 
 Ctx
-ctx_enter(const char *descr)
+ctx_enter(const char *)
 {
     return -1;
 }
 
 void
-ctx_exit(Ctx ctx)
-{
-}
+ctx_exit(Ctx)
+{}
 
 void
-_db_init(const char *logfile, const char *options)
+_db_init(const char *, const char *)
 {}
 
 void
-_db_set_syslog(const char *facility)
+_db_set_syslog(const char *)
 {}
 
 void
@@ -109,9 +108,7 @@ Debug::getDebugOut()
 
 void
 Debug::parseOptions(char const *)
-{
-    return;
-}
+{}
 
 void
 Debug::finishDebug()
@@ -132,7 +129,6 @@ Debug::finishDebug()
 void
 Debug::xassert(const char *msg, const char *file, int line)
 {
-
     if (CurrentDebug) {
         *CurrentDebug << "assertion failed: " << file << ":" << line <<
                       ": \"" << msg << "\"";
@@ -435,7 +435,7 @@ sig_child(int sig)
 }
 
 void
-sig_shutdown(int sig)
+sig_shutdown(int)
 {
     shutting_down = 1;
 }
@@ -325,7 +325,7 @@ TunnelStateData::ReadServer(const Comm::ConnectionPointer &c, char *buf, size_t
 }
 
 void
-TunnelStateData::readServer(char *buf, size_t len, Comm::Flag errcode, int xerrno)
+TunnelStateData::readServer(char *, size_t len, Comm::Flag errcode, int xerrno)
 {
     debugs(26, 3, HERE << server.conn << ", read " << len << " bytes, err=" << errcode);
 
@@ -349,7 +349,7 @@ TunnelStateData::readServer(char *buf, size_t len, Comm::Flag errcode, int xerrn
 
 /// Called when we read [a part of] CONNECT response from the peer
 void
-TunnelStateData::readConnectResponseDone(char *buf, size_t len, Comm::Flag errcode, int xerrno)
+TunnelStateData::readConnectResponseDone(char *, size_t len, Comm::Flag errcode, int xerrno)
 {
     debugs(26, 3, server.conn << ", read " << len << " bytes, err=" << errcode);
     assert(waitingForConnectResponse());
@@ -470,7 +470,7 @@ TunnelStateData::ReadClient(const Comm::ConnectionPointer &, char *buf, size_t l
 }
 
 void
-TunnelStateData::readClient(char *buf, size_t len, Comm::Flag errcode, int xerrno)
+TunnelStateData::readClient(char *, size_t len, Comm::Flag errcode, int xerrno)
 {
     debugs(26, 3, HERE << client.conn << ", read " << len << " bytes, err=" << errcode);
 
@@ -556,7 +556,7 @@ TunnelStateData::WriteServerDone(const Comm::ConnectionPointer &, char *buf, siz
 }
 
 void
-TunnelStateData::writeServerDone(char *buf, size_t len, Comm::Flag flag, int xerrno)
+TunnelStateData::writeServerDone(char *, size_t len, Comm::Flag flag, int xerrno)
 {
     debugs(26, 3, HERE  << server.conn << ", " << len << " bytes written, flag=" << flag);
 
@@ -617,7 +617,7 @@ TunnelStateData::Connection::dataSent(size_t amount)
 }
 
 void
-TunnelStateData::writeClientDone(char *buf, size_t len, Comm::Flag flag, int xerrno)
+TunnelStateData::writeClientDone(char *, size_t len, Comm::Flag flag, int xerrno)
 {
     debugs(26, 3, HERE << client.conn << ", " << len << " bytes written, flag=" << flag);
 
@@ -735,7 +735,7 @@ tunnelStartShoveling(TunnelStateData *tunnelState)
  * Call the tunnelStartShoveling to start the blind pump.
  */
 static void
-tunnelConnectedWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t size, Comm::Flag flag, int xerrno, void *data)
+tunnelConnectedWriteDone(const Comm::ConnectionPointer &conn, char *, size_t, Comm::Flag flag, int, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << conn << ", flag=" << flag);
@@ -751,7 +751,7 @@ tunnelConnectedWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t
 
 /// Called when we are done writing CONNECT request to a peer.
 static void
-tunnelConnectReqWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t size, Comm::Flag flag, int xerrno, void *data)
+tunnelConnectReqWriteDone(const Comm::ConnectionPointer &conn, char *, size_t, Comm::Flag flag, int, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, conn << ", flag=" << flag);
@@ -47,7 +47,7 @@
  \retval OK  The file has been removed.
  */
 int
-main(int argc, char *argv[])
+main(int, char *[])
 {
     char buf[UNLINK_BUF_LEN];
     char *t;
@@ -82,7 +82,7 @@ UrnState::~UrnState()
 }
 
 static url_entry *
-urnFindMinRtt(url_entry * urls, const HttpRequestMethod& m, int *rtt_ret)
+urnFindMinRtt(url_entry * urls, const HttpRequestMethod &, int *rtt_ret)
 {
     int min_rtt = 0;
     url_entry *u = NULL;
@@ -174,7 +174,7 @@ wccpConnectionClose(void)
  * Accept the UDP packet
  */
 static void
-wccpHandleUdp(int sock, void *not_used)
+wccpHandleUdp(int sock, void *)
 {
     Ip::Address from;
     int len;
@@ -271,7 +271,7 @@ wccpLowestIP(void)
 }
 
 static void
-wccpHereIam(void *voidnotused)
+wccpHereIam(void *)
 {
     debugs(80, 6, "wccpHereIam: Called");
 
@@ -1107,9 +1107,8 @@ wccp2ConnectionClose(void)
  * Accept the UDP packet
  */
 static void
-wccp2HandleUdp(int sock, void *not_used)
+wccp2HandleUdp(int sock, void *)
 {
-
     struct wccp2_service_list_t *service_list_ptr;
 
     struct wccp2_router_list_t *router_list_ptr;
@@ -1514,9 +1513,8 @@ wccp2HandleUdp(int sock, void *not_used)
 }
 
 static void
-wccp2HereIam(void *voidnotused)
+wccp2HereIam(void *)
 {
-
     struct wccp2_service_list_t *service_list_ptr;
 
     struct wccp2_router_list_t *router_list_ptr;
@@ -1599,9 +1597,8 @@ wccp2HereIam(void *voidnotused)
 }
 
 static void
-wccp2AssignBuckets(void *voidnotused)
+wccp2AssignBuckets(void *)
 {
-
     struct wccp2_service_list_t *service_list_ptr;
 
     struct wccp2_router_list_t *router_list_ptr;
@@ -2031,7 +2028,7 @@ dump_wccp2_method(StoreEntry * e, const char *label, int v)
 }
 
 void
-free_wccp2_method(int *v)
+free_wccp2_method(int *)
 { }
 
 /**
@@ -2078,16 +2075,16 @@ dump_wccp2_amethod(StoreEntry * e, const char *label, int v)
 }
 
 void
-free_wccp2_amethod(int *v)
-{ }
+free_wccp2_amethod(int *)
+{}
 
 /*
  * Format:
  *
  * wccp2_service {standard|dynamic} {id} (password=password)
  */
 void
-parse_wccp2_service(void *v)
+parse_wccp2_service(void *)
 {
     char *t;
     int service = 0;
@@ -2138,9 +2135,8 @@ parse_wccp2_service(void *v)
 }
 
 void
-dump_wccp2_service(StoreEntry * e, const char *label, void *v)
+dump_wccp2_service(StoreEntry * e, const char *label, void *)
 {
-
     struct wccp2_service_list_t *srv;
     srv = wccp2_service_list_head;
 
@@ -2161,11 +2157,11 @@ dump_wccp2_service(StoreEntry * e, const char *label, void *v)
 }
 
 void
-free_wccp2_service(void *v)
+free_wccp2_service(void *)
 {}
 
 int
-check_null_wccp2_service(void *v)
+check_null_wccp2_service(void *)
 {
     return !wccp2_service_list_head;
 }
@@ -2258,7 +2254,7 @@ parse_wccp2_service_ports(char *options, int portlist[])
 }
 
 void
-parse_wccp2_service_info(void *v)
+parse_wccp2_service_info(void *)
 {
     char *t, *end;
     int service_id = 0;
@@ -2337,7 +2333,7 @@ parse_wccp2_service_info(void *v)
 }
 
 void
-dump_wccp2_service_info(StoreEntry * e, const char *label, void *v)
+dump_wccp2_service_info(StoreEntry * e, const char *label, void *)
 {
     char comma;
 
@@ -2509,7 +2505,7 @@ wccp2SortCacheList(struct wccp2_cache_list_t *head)
 }
 
 void
-free_wccp2_service_info(void *v)
+free_wccp2_service_info(void *)
 {}
 
 #endif /* USE_WCCPv2 */
@@ -48,7 +48,7 @@ static IOCB whoisReadReply;
 /* PUBLIC */
 
 static void
-whoisWriteComplete(const Comm::ConnectionPointer &, char *buf, size_t size, Comm::Flag flag, int xerrno, void *data)
+whoisWriteComplete(const Comm::ConnectionPointer &, char *buf, size_t, Comm::Flag, int, void *)
 {
     xfree(buf);
 }
@@ -480,7 +480,7 @@ munge_menu_line(const char *buf, cachemgr_request * req)
 }
 
 static const char *
-munge_other_line(const char *buf, cachemgr_request * req)
+munge_other_line(const char *buf, cachemgr_request *)
 {
     static const char *ttags[] = {"td", "th"};
 
@@ -104,7 +104,7 @@ getSocketNoDelay( int sockfd )
 }
 
 int
-setSocketNoDelay( int sockfd, bool nodelay )
+setSocketNoDelay( int sockfd, bool)
 // purpose: get state of the TCP_NODELAY of the socket
 // paramtr: sockfd (IN): socket descriptor
 //          nodelay (IN): true, if TCP_NODELAY is to be set, false otherwise.
@@ -574,7 +574,7 @@ main(int argc, char *argv[])
 }
 
 void
-pipe_handler(int sig)
+pipe_handler(int)
 {
     std::cerr << "SIGPIPE received." << std::endl;
 }