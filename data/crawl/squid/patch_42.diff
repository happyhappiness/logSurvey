----++++src/cache_cf.cc
@@ -946,6 +946,10 @@ configDoConfigure(void)
         }
     }
 #endif
+
+    if (Config.readAheadGap &lt;= 0) {
+        fatalf(&quot;read_ahead_gap must be greater than 0 bytes&quot;);
+    }
 }
 
 /** Parse a line containing an obsolete directive.
----++++src/cf.data.pre
@@ -5650,6 +5650,17 @@ DEFAULT: 16 KB
 DOC_START
 	The amount of data the cache will buffer ahead of what has been
 	sent to the client when retrieving an object from another server.
+	
+	This also influences the maximum network read(2)/write(2) sizes in some
+	circumstances. Reducing the size of this buffer will decrease
+	per-connection memory usage at the cost of more read(2)/write(2) calls.
+	Conversely, increasing the size of this buffer will decrease the number of
+	read(2)/write(2) calls at the cost of memory usage, potentially improving
+	performance.
+
+	Squid does not slow does the response delivery to the client in order to
+	fill the buffer.
+
 DOC_END
 
 NAME: negative_ttl
----++++src/client_side.cc
@@ -1012,12 +1012,9 @@ ConnStateData::abortRequestParsing(const char *const uri)
     http-&gt;uri = xstrdup(uri);
     setLogUri (http, uri);
     auto *context = new Http::Stream(clientConnection, http);
-    StoreIOBuffer tempBuffer;
-    tempBuffer.data = context-&gt;reqbuf;
-    tempBuffer.length = HTTP_REQBUF_SZ;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, new clientReplyContext(http), clientSocketRecipient,
-                     clientSocketDetach, context, tempBuffer);
+                     clientSocketDetach, context, context-&gt;getClientStreamBuffer());
     return context;
 }
 
@@ -1359,15 +1356,11 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &amp;hp)
     http-&gt;req_sz = hp-&gt;messageHeaderSize();
     Http::Stream *result = new Http::Stream(csd-&gt;clientConnection, http);
 
-    StoreIOBuffer tempBuffer;
-    tempBuffer.data = result-&gt;reqbuf;
-    tempBuffer.length = HTTP_REQBUF_SZ;
-
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
-                     clientSocketDetach, newClient, tempBuffer);
+                     clientSocketDetach, newClient, result-&gt;getClientStreamBuffer());
 
     /* set url */
     debugs(33,5, &quot;Prepare absolute URL from &quot; &lt;&lt;
----++++src/http/Stream.cc
@@ -11,6 +11,7 @@
 #include &quot;http/Stream.h&quot;
 #include &quot;HttpHdrContRange.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
+#include &quot;SquidConfig.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;TimeOrTag.h&quot;
 
@@ -20,10 +21,10 @@ Http::Stream::Stream(const Comm::ConnectionPointer &amp;aConn, ClientHttpRequest *aR
     reply(nullptr),
     writtenToSocket(0),
     mayUseConnection_(false),
-    connRegistered_(false)
+    connRegistered_(false),
+    requestBuffer(nullptr)
 {
     assert(http != nullptr);
-    memset(reqbuf, &#39;\0&#39;, sizeof (reqbuf));
     flags.deferred = 0;
     flags.parsed_ok = 0;
     deferredparams.node = nullptr;
@@ -109,12 +110,10 @@ Http::Stream::pullData()
     debugs(33, 5, reply &lt;&lt; &quot; written &quot; &lt;&lt; http-&gt;out.size &lt;&lt; &quot; into &quot; &lt;&lt; clientConnection);
 
     /* More data will be coming from the stream. */
-    StoreIOBuffer readBuffer;
+    StoreIOBuffer readBuffer = getClientStreamBuffer();
     /* XXX: Next requested byte in the range sequence */
     /* XXX: length = getmaximumrangelenfgth */
     readBuffer.offset = getNextRangeOffset();
-    readBuffer.length = HTTP_REQBUF_SZ;
-    readBuffer.data = reqbuf;
     /* we may note we have reached the end of the wanted ranges */
     clientStreamRead(getTail(), http, readBuffer);
 }
@@ -568,6 +567,18 @@ Http::Stream::deferRecipientForLater(clientStreamNode *node, HttpReply *rep, Sto
     deferredparams.queuedBuffer = receivedData;
 }
 
+StoreIOBuffer
+Http::Stream::getClientStreamBuffer()
+{
+    if (!requestBuffer) {
+        requestBuffer = new MemBlob(Config.readAheadGap);
+    }
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = requestBuffer-&gt;mem;
+    tempBuffer.length = requestBuffer-&gt;spaceSize();
+    return tempBuffer;
+}
+
 void
 Http::Stream::prepareReply(HttpReply *rep)
 {
----++++src/http/Stream.h
@@ -120,12 +120,13 @@ class Stream : public RefCountable
 
     void deferRecipientForLater(clientStreamNode *, HttpReply *, StoreIOBuffer receivedData);
 
+    StoreIOBuffer getClientStreamBuffer();
+
 public: // HTTP/1.x state data
 
     Comm::ConnectionPointer clientConnection; ///&lt; details about the client connection socket
     ClientHttpRequest *http;    /* we pretend to own that Job */
     HttpReply *reply;
-    char reqbuf[HTTP_REQBUF_SZ];
     struct {
         unsigned deferred:1; ///&lt; This is a pipelined request waiting for the current object to complete
         unsigned parsed_ok:1; ///&lt; Was this parsed correctly?
@@ -158,6 +159,8 @@ class Stream : public RefCountable
 
     bool mayUseConnection_; /* This request may use the connection. Don&#39;t read anymore requests for now */
     bool connRegistered_;
+
+    MemBlob::Pointer requestBuffer;
 };
 
 } // namespace Http
----++++src/servers/FtpServer.cc
@@ -759,15 +759,11 @@ Ftp::Server::parseOneRequest()
     Http::Stream *const result =
         new Http::Stream(clientConnection, http);
 
-    StoreIOBuffer tempBuffer;
-    tempBuffer.data = result-&gt;reqbuf;
-    tempBuffer.length = HTTP_REQBUF_SZ;
-
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
-                     clientSocketDetach, newClient, tempBuffer);
+                     clientSocketDetach, newClient, result-&gt;getClientStreamBuffer());
 
     result-&gt;flags.parsed_ok = 1;
     return result;
----++++GitHub