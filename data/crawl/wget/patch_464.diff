diff --git a/src/ChangeLog b/src/ChangeLog
index a3b726c..54e591d 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,5 +1,10 @@
 2005-06-20  Hrvoje Niksic  <hniksic@xemacs.org>
 
+	* main.c, ptimer.c, sysdep.h, utils.c: Use #elif to simplify reading of
+	chained if-else-else-else-... statements.
+
+2005-06-20  Hrvoje Niksic  <hniksic@xemacs.org>
+
 	* all: Return type of signal handlers is `void'.  Include signal.h
 	unconditionally.
 
diff --git a/src/main.c b/src/main.c
index 43496dc..414c1ca 100644
--- a/src/main.c
+++ b/src/main.c
@@ -36,11 +36,9 @@ so, delete this exception statement from your version.  */
 #endif /* HAVE_UNISTD_H */
 #include <string.h>
 #include <signal.h>
-#ifdef HAVE_NLS
-#ifdef HAVE_LOCALE_H
+#if defined(HAVE_NLS) && defined(HAVE_LOCALE_H)
 # include <locale.h>
-#endif /* HAVE_LOCALE_H */
-#endif /* HAVE_NLS */
+#endif
 #include <assert.h>
 #include <errno.h>
 
diff --git a/src/ptimer.c b/src/ptimer.c
index 695019e..f6ad555 100644
--- a/src/ptimer.c
+++ b/src/ptimer.c
@@ -83,16 +83,12 @@ so, delete this exception statement from your version.  */
 
 #if defined(WINDOWS) || defined(__CYGWIN__)
 # define PTIMER_WINDOWS		/* use Windows timers */
+#elif _POSIX_TIMERS - 0 > 0
+# define PTIMER_POSIX		/* use POSIX timers (clock_gettime) */
+#elif defined(HAVE_GETTIMEOFDAY)
+# define PTIMER_GETTIMEOFDAY	/* use gettimeofday */
 #else
-# if _POSIX_TIMERS - 0 > 0
-#  define PTIMER_POSIX		/* use POSIX timers (clock_gettime) */
-# else
-#  ifdef HAVE_GETTIMEOFDAY
-#   define PTIMER_GETTIMEOFDAY	/* use gettimeofday */
-#  else
-#   define PTIMER_TIME
-#  endif
-# endif
+# define PTIMER_TIME
 #endif
 
 #ifdef PTIMER_POSIX
diff --git a/src/sysdep.h b/src/sysdep.h
index 17d3f67..8cadccb 100644
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -104,22 +104,18 @@ so, delete this exception statement from your version.  */
 /* Long is large enough: use it.  */
 typedef long LARGE_INT;
 # define LARGE_INT_FMT "%ld"
-#else
-# if SIZEOF_LONG_LONG >= 8
+#elif SIZEOF_LONG_LONG >= 8
 /* Long long is large enough: use it.  */
 typedef long long LARGE_INT;
-#  define LARGE_INT_FMT "%lld"
-# else
-#  if _MSC_VER
+# define LARGE_INT_FMT "%lld"
+#elif _MSC_VER
 /* Use __int64 under Windows. */
 typedef __int64 LARGE_INT;
-#   define LARGE_INT_FMT "%I64"
-#  else
-/* Large integer type unavailable; use `double' instead.  */
+# define LARGE_INT_FMT "%I64"
+#else
+/* Large integer type unavailable; fake it with `double'.  */
 typedef double LARGE_INT;
-#   define LARGE_INT_FMT "%.0f"
-#  endif
-# endif
+# define LARGE_INT_FMT "%.0f"
 #endif
 
 /* Under Windows we #define struct_stat to struct _stati64. */
diff --git a/src/utils.c b/src/utils.c
index caf8341..fc6aea0 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -1354,17 +1354,13 @@ numdigit (wgint number)
    would just use "%j" and intmax_t, but many systems don't support
    it, so it's used only if nothing else works.  */
 #if SIZEOF_LONG >= SIZEOF_WGINT
-#  define SPRINTF_WGINT(buf, n) sprintf (buf, "%ld", (long) (n))
+# define SPRINTF_WGINT(buf, n) sprintf (buf, "%ld", (long) (n))
+#elif SIZEOF_LONG_LONG >= SIZEOF_WGINT
+# define SPRINTF_WGINT(buf, n) sprintf (buf, "%lld", (long long) (n))
+#elif defined(WINDOWS)
+# define SPRINTF_WGINT(buf, n) sprintf (buf, "%I64", (__int64) (n))
 #else
-# if SIZEOF_LONG_LONG >= SIZEOF_WGINT
-#   define SPRINTF_WGINT(buf, n) sprintf (buf, "%lld", (long long) (n))
-# else
-#  ifdef WINDOWS
-#   define SPRINTF_WGINT(buf, n) sprintf (buf, "%I64", (__int64) (n))
-#  else
-#   define SPRINTF_WGINT(buf, n) sprintf (buf, "%j", (intmax_t) (n))
-#  endif
-# endif
+# define SPRINTF_WGINT(buf, n) sprintf (buf, "%j", (intmax_t) (n))
 #endif
 
 /* Shorthand for casting to wgint. */
@@ -1541,16 +1537,14 @@ determine_screen_width (void)
     return 0;			/* most likely ENOTTY */
 
   return wsz.ws_col;
-#else  /* not TIOCGWINSZ */
-# ifdef WINDOWS
+#elif defined(WINDOWS)
   CONSOLE_SCREEN_BUFFER_INFO csbi;
   if (!GetConsoleScreenBufferInfo (GetStdHandle (STD_ERROR_HANDLE), &csbi))
     return 0;
   return csbi.dwSize.X;
-# else /* neither WINDOWS nor TIOCGWINSZ */
+#else  /* neither TIOCGWINSZ nor WINDOWS */
   return 0;
-#endif /* neither WINDOWS nor TIOCGWINSZ */
-#endif /* not TIOCGWINSZ */
+#endif /* neither TIOCGWINSZ nor WINDOWS */
 }
 
 /* Return a random number between 0 and MAX-1, inclusive.
@@ -1795,8 +1789,7 @@ xsleep (double seconds)
     /* If nanosleep has been interrupted by a signal, adjust the
        sleeping period and return to sleep.  */
     sleep = remaining;
-#else  /* not HAVE_NANOSLEEP */
-#ifdef HAVE_USLEEP
+#elif defined(HAVE_USLEEP)
   /* If usleep is available, use it in preference to select.  */
   if (seconds >= 1)
     {
@@ -1807,8 +1800,7 @@ xsleep (double seconds)
       seconds -= (long) seconds;
     }
   usleep (seconds * 1000000);
-#else  /* not HAVE_USLEEP */
-#ifdef HAVE_SELECT
+#elif defined(HAVE_SELECT)
   /* Note that, although Windows supports select, this sleeping
      strategy doesn't work there because Winsock's select doesn't
      implement timeout when it is passed NULL pointers for all fd
@@ -1822,11 +1814,9 @@ xsleep (double seconds)
      interrupted by a signal.  But without knowing how long we've
      actually slept, we can't return to sleep.  Using gettimeofday to
      track sleeps is slow and unreliable due to clock skew.  */
-#else  /* not HAVE_SELECT */
+#else  /* none of the above */
   sleep (seconds);
-#endif /* not HAVE_SELECT */
-#endif /* not HAVE_USLEEP */
-#endif /* not HAVE_NANOSLEEP */
+#endif
 }
 
 #endif /* not WINDOWS */
-- 
cgit v1.0-41-gc330

