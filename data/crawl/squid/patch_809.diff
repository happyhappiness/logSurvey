@@ -79,7 +79,7 @@ int
 ACLExtUser::match(ACLChecklist *checklist)
 {
     if (checklist->request->extacl_user.size()) {
-        return data->match(checklist->request->extacl_user.unsafeBuf());
+        return data->match(checklist->request->extacl_user.termedBuf());
     } else {
         return -1;
     }
@@ -59,7 +59,7 @@ class CommonPool
     void *operator new(size_t);
     void operator delete (void *);
     static CommonPool *Factory (unsigned char _class, CompositePoolNode::Pointer&);
-    char const* theClassTypeLabel() const {return typeLabel.unsafeBuf();}
+    char const* theClassTypeLabel() const {return typeLabel.termedBuf();}
 
 protected:
     CommonPool();
@@ -77,7 +77,7 @@ int
 DelayTaggedCmp(DelayTaggedBucket::Pointer const &left, DelayTaggedBucket::Pointer const &right)
 {
     /* for rate limiting, case insensitive */
-    return left->tag.caseCmp(right->tag.unsafeBuf());
+    return left->tag.caseCmp(right->tag);
 }
 
 void
@@ -195,7 +195,7 @@ DelayTaggedBucket::~DelayTaggedBucket()
 void
 DelayTaggedBucket::stats (StoreEntry *entry) const
 {
-    storeAppendPrintf(entry, " %s:", tag.unsafeBuf());
+    storeAppendPrintf(entry, " :" SQUIDSTRINGPH , SQUIDSTRINGPRINT(tag));
     theBucket.stats (entry);
 }
 
@@ -87,10 +87,9 @@ AIODiskFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
 {
     /* Simulate async calls */
 #ifdef _SQUID_WIN32_
-    fd = aio_open(path.unsafeBuf(), flags);
+    fd = aio_open(path.termedBuf(), flags);
 #else
-
-    fd = file_open(path.unsafeBuf() , flags);
+    fd = file_open(path.termedBuf() , flags);
 #endif
 
     ioRequestor = callback;
@@ -130,7 +129,7 @@ AIODiskFile::read(ReadRequest *request)
         fatal("Aiee! out of aiocb slots! - FIXME and wrap file_read\n");
         debugs(79, 1, "WARNING: out of aiocb slots!");
         /* fall back to blocking method */
-        //        file_read(fd, request->unsafeBuf, request->len, request->offset, callback, data);
+        //        file_read(fd, request->buf, request->len, request->offset, callback, data);
         return;
     }
 
@@ -167,7 +166,7 @@ AIODiskFile::read(ReadRequest *request)
         fatalf("Aiee! aio_read() returned error (%d)  FIXME and wrap file_read !\n", errno);
         debugs(79, 1, "WARNING: aio_read() returned error: " << xstrerror());
         /* fall back to blocking method */
-        //        file_read(fd, request->unsafeBuf, request->len, request->offset, callback, data);
+        //        file_read(fd, request->buf, request->len, request->offset, callback, data);
     }
 
 }
@@ -188,7 +187,7 @@ AIODiskFile::write(WriteRequest *request)
         fatal("Aiee! out of aiocb slots FIXME and wrap file_write !\n");
         debugs(79, 1, "WARNING: out of aiocb slots!");
         /* fall back to blocking method */
-        //        file_write(fd, offset, unsafeBuf, len, callback, data, freefunc);
+        //        file_write(fd, offset, buf, len, callback, data, freefunc);
         return;
     }
 
@@ -225,7 +224,7 @@ AIODiskFile::write(WriteRequest *request)
         fatalf("Aiee! aio_write() returned error (%d) FIXME and wrap file_write !\n", errno);
         debugs(79, 1, "WARNING: aio_write() returned error: " << xstrerror());
         /* fall back to blocking method */
-        //       file_write(fd, offset, unsafeBuf, len, callback, data, freefunc);
+        //       file_write(fd, offset, buf, len, callback, data, freefunc);
     }
 }
 
@@ -2430,7 +2430,7 @@ esiEnableProcessing (HttpReply *rep)
              */
             return 0;
 
-        if (strstr (sctusable->content.unsafeBuf(), "ESI/1.0"))
+        if (sctusable->content.pos("ESI/1.0") != NULL)
             rv = 1;
 
         httpHdrScTargetDestroy (sctusable);
@@ -89,7 +89,7 @@ ESIAssign::evaluateVariable()
     variable = NULL;
 
     if (unevaluatedVariable.size()) {
-        varState->feedData(unevaluatedVariable.unsafeBuf(), unevaluatedVariable.size());
+        varState->feedData(unevaluatedVariable.rawBuf(), unevaluatedVariable.size());
         char const *result = varState->extractChar ();
 
         /* Consider activating this, when we want to evaluate variables to a
@@ -123,7 +123,7 @@ ESIAssign::process (int dovars)
     if (!value)
         return ESI_PROCESS_COMPLETE;
 
-    varState->addVariable (name.unsafeBuf(), name.size(), value);
+    varState->addVariable (name.rawBuf(), name.size(), value);
 
     value = NULL;
 
@@ -194,7 +194,7 @@ void
 ESIVariableExpression::eval (ESIVarState &state, char const *subref, char const *defaultOnEmpty) const
 {
     /* XXX: Implement evaluation of the expression */
-    ESISegment::ListAppend (state.getOutput(), expression.unsafeBuf(), expression.size());
+    ESISegment::ListAppend (state.getOutput(), expression.rawBuf(), expression.size());
 }
 
 #endif /* USE_SQUID_ESI == 1 */
@@ -109,7 +109,8 @@ ESICustomParser::parse(char const *dataToParse, size_t const lengthOfData, bool
     }
 
     size_t openESITags (0);
-    char const *currentPos = content.unsafeBuf();
+    //erring on the safe side. Probably rawBuf would be ok too
+    char const *currentPos = content.termedBuf();
     size_t remainingCount = content.size();
     char const *tag = NULL;
 
@@ -302,7 +303,7 @@ char const *
 ESICustomParser::errorString() const
 {
     if (error.size())
-        return error.unsafeBuf();
+        return error.termedBuf();
     else
         return "Parsing error strings not implemented";
 }
@@ -236,5 +236,5 @@ ESISegment::dumpOne() const
 {
     String temp;
     temp.limitInit(buf, len);
-    debugs(86, 9, "ESISegment::dumpOne: \"" << temp.unsafeBuf() << "\"");
+    debugs(86, 9, "ESISegment::dumpOne: \"" << temp << "\"");
 }
@@ -235,9 +235,8 @@ httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p)
         if (EBIT_TEST(cc->mask, flag) && flag != CC_OTHER) {
 
             /* print option name */
-            packerPrintf(p, (pcount ? ", %.*s" : "%.*s"),
-                CcFieldsInfo[flag].name.size(),
-                CcFieldsInfo[flag].name.rawBuf());
+            packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
+                SQUIDSTRINGPRINT(CcFieldsInfo[flag].name));
 
             /* handle options with values */
 
@@ -254,9 +253,9 @@ httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p)
         }
     }
 
-    if (cc->other.size())
-        packerPrintf(p, (pcount ? ", %.*s" : "%.*s"),
-            cc->other.size(), cc->other.rawBuf());
+    if (cc->other.size() != 0)
+        packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
+            SQUIDSTRINGPRINT(cc->other));
 }
 
 /* negative max_age will clean old max_Age setting */
@@ -257,24 +257,23 @@ httpHdrScTargetPackInto(const HttpHdrScTarget * sc, Packer * p)
         if (EBIT_TEST(sc->mask, flag) && flag != SC_OTHER) {
 
             /* print option name */
-            packerPrintf(p, (pcount ? ", %.*s" : "%.*s"),
-                ScFieldsInfo[flag].name.size(),
-                ScFieldsInfo[flag].name.rawBuf());
+            packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
+                SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
 
             /* handle options with values */
 
             if (flag == SC_MAX_AGE)
                 packerPrintf(p, "=%d", (int) sc->max_age);
 
             if (flag == SC_CONTENT)
-                packerPrintf(p, "=\"%.*s\"", sc->content.size(), sc->content.rawBuf());
+                packerPrintf(p, "=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(sc->content));
 
             pcount++;
         }
     }
 
     if (sc->target.size())
-        packerPrintf (p, ";%.*s", sc->target.size(), sc->target.rawBuf());
+        packerPrintf (p, ";" SQUIDSTRINGPH, SQUIDSTRINGPRINT(sc->target));
 }
 
 void
@@ -1683,7 +1683,7 @@ httpHeaderStoreReport(StoreEntry * e)
 }
 
 http_hdr_type
-httpHeaderIdByName(const char *name, int name_len, const HttpHeaderFieldInfo * info, int end)
+httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * info, int end)
 {
     int i;
 
@@ -33,12 +33,21 @@
 #ifndef SQUID_HTTPHEADER_H
 #define SQUID_HTTPHEADER_H
 
-
 /* because we pass a spec by value */
 #include "HttpHeaderRange.h"
 /* HttpHeader holds a HttpHeaderMask */
 #include "HttpHeaderMask.h"
 
+
+/* class forward declarations */
+class HttpVersion;
+class HttpHdrContRange;
+class HttpHdrCc;
+class HttpHdrSc;
+class HttpHdrRange;
+class String;
+
+
 /* constant attributes of http header fields */
 
 /** recognized or "known" header fields; @?@ add more! */
@@ -149,13 +158,6 @@ struct _HttpHeaderFieldAttrs {
     field_type type;
 };
 
-class HttpVersion;
-
-class HttpHdrContRange;
-
-class HttpHdrCc;
-
-class HttpHdrSc;
 
 /** Iteration for headers; use HttpHeaderPos as opaque type, do not interpret */
 typedef ssize_t HttpHeaderPos;
@@ -439,7 +439,8 @@ HttpReply::bodySize(const HttpRequestMethod& method) const
 
 bool HttpReply::sanityCheckStartLine(MemBuf *buf, http_status *error)
 {
-    if (buf->contentSize() >= protoPrefix.size() && protoPrefix.cmp(buf->content(), protoPrefix.size()) != 0) {
+    //hack warning: using psize instead of size here due to type mismatches with MemBuf.
+    if (buf->contentSize() >= protoPrefix.psize() && protoPrefix.cmp(buf->content(), protoPrefix.size()) != 0) {
         debugs(58, 3, "HttpReply::sanityCheckStartLine: missing protocol prefix (" << protoPrefix << ") in '" << buf->content() << "'");
         *error = HTTP_INVALID_HEADER;
         return false;
@@ -298,8 +298,8 @@ HttpRequest::pack(Packer * p)
 {
     assert(p);
     /* pack request-line */
-    packerPrintf(p, "%s %.*s HTTP/1.0\r\n",
-                 RequestMethodStr(method), urlpath.size(), urlpath.rawBuf());
+    packerPrintf(p, "%s " SQUIDSTRINGPH " HTTP/1.0\r\n",
+                 RequestMethodStr(method), SQUIDSTRINGPRINT(urlpath));
     /* headers */
     header.packInto(p);
     /* trailer */
@@ -1029,8 +1029,8 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
      * XXX These should use HttpHdr interfaces instead of Printfs
      */
     const Adaptation::ServiceConfig &s = service().cfg();
-    buf.Printf("%s %.*s ICAP/1.0\r\n", s.methodStr(), s.uri.size(), s.uri.rawBuf());
-    buf.Printf("Host: %.*s:%d\r\n", s.host.size(), s.host.rawBuf(), s.port);
+    buf.Printf("%s " SQUIDSTRINGPH " ICAP/1.0\r\n", s.methodStr(), SQUIDSTRINGPRINT(s.uri));
+    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
     buf.Printf("Date: %s\r\n", mkrfc1123(squid_curtime));
 
     if (!TheICAPConfig.reuse_connections)
@@ -1040,14 +1040,12 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     // as ICAP headers.
     if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getByName("Proxy-Authenticate");
-        buf.Printf("Proxy-Authenticate: %.*s\r\n",
-                   vh.size(), vh.rawBuf());
+        buf.Printf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
     if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
-        buf.Printf("Proxy-Authorization: %.*s\r\n",
-                   vh.size(), vh.rawBuf());
+        buf.Printf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     }
 
     buf.Printf("Encapsulated: ");
@@ -1111,7 +1109,7 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     if (TheICAPConfig.send_client_username && request)
         makeUsernameHeader(request, buf);
 
-    // fprintf(stderr, "%s\n", unsafeBuf.content());
+    // fprintf(stderr, "%s\n", buf.content());
 
     buf.append(ICAP::crlf, 2); // terminate ICAP header
 
@@ -1272,7 +1270,7 @@ void ICAPModXact::finishNullOrEmptyBodyPreview(MemBuf &buf)
     Must(!preview.ad());
 
     // do not add last-chunk because our Encapsulated header says null-body
-    // addLastRequestChunk(unsafeBuf);
+    // addLastRequestChunk(buf);
     preview.wrote(0, true);
 
     Must(preview.done());
@@ -44,9 +44,9 @@ void ICAPOptXact::makeRequest(MemBuf &buf)
 {
     const Adaptation::Service &s = service();
     const String uri = s.cfg().uri;
-    buf.Printf("OPTIONS %.*s ICAP/1.0\r\n", uri.size(), uri.rawBuf());
+    buf.Printf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
     const String host = s.cfg().host;
-    buf.Printf("Host: %.*s:%d\r\n", host.size(), host.rawBuf(), s.cfg().port);
+    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
     buf.append(ICAP::crlf, 2);
 }
 
@@ -279,7 +279,7 @@ void ICAPServiceRep::checkOptions()
         if (!method_found) {
             debugs(93,1, "WARNING: Squid is configured to use ICAP method " <<
                    cfg().methodStr() <<
-                   " for service " << cfg().uri.unsafeBuf() <<
+                   " for service " << cfg().uri <<
                    " but OPTIONS response declares the methods are " << method_list);
         }
     }
@@ -293,7 +293,7 @@ void ICAPServiceRep::checkOptions()
         // TODO: If skew is negative, the option will be considered down
         // because of stale options. We should probably change this.
         debugs(93, 1, "ICAP service's clock is skewed by " << skew <<
-               " seconds: " << cfg().uri.unsafeBuf());
+               " seconds: " << cfg().uri);
     }
 }
 
@@ -76,7 +76,7 @@ void ICAPXaction::openConnection()
         disableRetries(); // this will also safely drain pconn pool
 
     // TODO: check whether NULL domain is appropriate here
-    connection = icapPconnPool->pop(s.cfg().host.unsafeBuf(), s.cfg().port, NULL, client_addr, isRetriable);
+    connection = icapPconnPool->pop(s.cfg().host.termedBuf(), s.cfg().port, NULL, client_addr, isRetriable);
     if (connection >= 0) {
         debugs(93,3, HERE << "reused pconn FD " << connection);
 
@@ -96,12 +96,12 @@ void ICAPXaction::openConnection()
 
     IpAddress outgoing;
     connection = comm_open(SOCK_STREAM, 0, outgoing,
-                           COMM_NONBLOCKING, s.cfg().uri.unsafeBuf());
+                           COMM_NONBLOCKING, s.cfg().uri.termedBuf());
 
     if (connection < 0)
         dieOnConnectionFailure(); // throws
 
-    debugs(93,3, typeName << " opens connection to " << s.cfg().host.unsafeBuf() << ":" << s.cfg().port);
+    debugs(93,3, typeName << " opens connection to " << s.cfg().host << ":" << s.cfg().port);
 
     // TODO: service bypass status may differ from that of a transaction
     typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
@@ -119,7 +119,7 @@ void ICAPXaction::openConnection()
     typedef CommCbMemFunT<ICAPXaction, CommConnectCbParams> ConnectDialer;
     connector = asyncCall(93,3, "ICAPXaction::noteCommConnected",
                           ConnectDialer(this, &ICAPXaction::noteCommConnected));
-    commConnectStart(connection, s.cfg().host.unsafeBuf(), s.cfg().port, connector);
+    commConnectStart(connection, s.cfg().host.termedBuf(), s.cfg().port, connector);
 }
 
 /*
@@ -148,19 +148,22 @@ void ICAPXaction::closeConnection()
         cancelRead(); // may not work
 
         if (reuseConnection && !doneWithIo()) {
+            //status() adds leading spaces.
             debugs(93,5, HERE << "not reusing pconn due to pending I/O" << status());
             reuseConnection = false;
         }
 
         if (reuseConnection) {
             IpAddress client_addr;
+            //status() adds leading spaces.
             debugs(93,3, HERE << "pushing pconn" << status());
             AsyncCall::Pointer call = NULL;
             commSetTimeout(connection, -1, call);
-            icapPconnPool->push(connection, theService->cfg().host.unsafeBuf(),
+            icapPconnPool->push(connection, theService->cfg().host.termedBuf(),
                                 theService->cfg().port, NULL, client_addr);
             disableRetries();
         } else {
+            //status() adds leading spaces.
             debugs(93,3, HERE << "closing pconn" << status());
             // comm_close will clear timeout
             comm_close(connection);
@@ -232,7 +235,7 @@ void ICAPXaction::handleCommTimedout()
 {
     debugs(93, 2, HERE << typeName << " failed: timeout with " <<
            theService->cfg().methodStr() << " " <<
-           theService->cfg().uri.unsafeBuf() << status());
+           theService->cfg().uri << status());
     reuseConnection = false;
     service().noteFailure();
 
@@ -295,7 +298,7 @@ void ICAPXaction::scheduleRead()
 
     /*
      * See comments in ICAPXaction.h about why we use commBuf
-     * here instead of reading directly into readBuf.unsafeBuf.
+     * here instead of reading directly into readBuf.buf.
      */
     typedef CommCbMemFunT<ICAPXaction, CommIoCbParams> Dialer;
     reader = asyncCall(93,3, "ICAPXaction::noteCommRead",
@@ -320,7 +323,7 @@ void ICAPXaction::noteCommRead(const CommIoCbParams &io)
 
     /*
      * See comments in ICAPXaction.h about why we use commBuf
-     * here instead of reading directly into readBuf.unsafeBuf.
+     * here instead of reading directly into readBuf.buf.
      */
 
     if (io.size > 0) {
@@ -1518,6 +1518,7 @@ nodist_tests_testDiskIO_SOURCES= \
 	$(SWAP_TEST_GEN_SOURCES)
 tests_testDiskIO_LDADD = \
 	ip/libip.la \
+	libsquid.la \
 	@DISK_LIBS@ \
 	$(SWAP_TEST_LDADD) \
 	SquidConfig.o
@@ -40,6 +40,12 @@
 /** todo checks to wrap this include properly */
 #include <ostream>
 
+/* squid string placeholder (for printf) */
+#ifndef SQUIDSTRINGPH
+#define SQUIDSTRINGPH "%.*s"
+#define SQUIDSTRINGPRINT(s) s.psize(),s.rawBuf()
+#endif /* SQUIDSTRINGPH */
+
 
 #define DEBUGSTRINGS 0
 #if DEBUGSTRINGS
@@ -86,6 +92,9 @@ class String
     String (String const &);
     ~String();
 
+    typedef size_t size_type; //storage size intentionally unspecified
+    const static size_type npos = std::string::npos;
+
     String &operator =(char const *);
     String &operator =(String const &);
     bool operator ==(String const &) const;
@@ -97,8 +106,10 @@ class String
      */
     _SQUID_INLINE_ char operator [](unsigned int pos) const;
 
-    _SQUID_INLINE_ int size() const;
-    _SQUID_INLINE_ char const * unsafeBuf() const;
+    _SQUID_INLINE_ size_type size() const;
+    /// variant of size() suited to be used for printf-alikes.
+    /// throws when size() > MAXINT
+    int psize() const;
 
     /**
      * \retval true the String has some contents
@@ -126,33 +137,28 @@ class String
     void append(char const);
     void append (String const &);
     void absorb(String &old);
-    _SQUID_INLINE_ const char * pos(char const *) const;
-    _SQUID_INLINE_ const char * pos(char const ch) const;
+    const char * pos(char const *aString) const;
+    const char * pos(char const ch) const;
     ///offset from string start of the first occurrence of ch
-    /// returns std::string::npos if ch is not found
-    _SQUID_INLINE_ size_t find(char const ch) const;
-    _SQUID_INLINE_ const char * rpos(char const ch) const;
+    /// returns String::npos if ch is not found
+    size_type find(char const ch) const;
+    size_type find(char const *aString) const;
+    const char * rpos(char const ch) const;
+    size_type rfind(char const ch) const;
     _SQUID_INLINE_ int cmp (char const *) const;
-    _SQUID_INLINE_ int cmp (char const *, size_t count) const;
+    _SQUID_INLINE_ int cmp (char const *, size_type count) const;
     _SQUID_INLINE_ int cmp (String const &) const;
     _SQUID_INLINE_ int caseCmp (char const *) const;
-    _SQUID_INLINE_ int caseCmp (char const *, size_t count) const;
+    _SQUID_INLINE_ int caseCmp (char const *, size_type count) const;
     _SQUID_INLINE_ int caseCmp (String const &) const;
 
-    /** \deprecated Use assignment to [] position instead.
-     *              ie   str[0] = 'h';
-     */
-    _SQUID_INLINE_ void set(char const *loc, char const ch);
+    String substr(size_type from, size_type to) const;
 
     /** \deprecated Use assignment to [] position instead.
      *              ie   str[newLength] = '\0';
      */
-    _SQUID_INLINE_ void cut(size_t newLength);
+    _SQUID_INLINE_ void cut(size_type newLength);
 
-    /** \deprecated Use assignment to [] position instead.
-     *              ie   str[newLength] = '\0';
-     */
-    _SQUID_INLINE_ void cutPointer(char const *loc);
 
 #if DEBUGSTRINGS
 
@@ -164,15 +170,19 @@ class String
 
 private:
     void allocAndFill(const char *str, int len);
-    void allocBuffer(size_t sz);
-    void setBuffer(char *buf, size_t sz);
+    void allocBuffer(size_type sz);
+    void setBuffer(char *buf, size_type sz);
 
     /* never reference these directly! */
-    unsigned short int size_; /* buffer size; 64K limit */
+    size_type size_; /* buffer size; 64K limit */
 
-    unsigned short int len_;  /* current length  */
+    size_type len_;  /* current length  */
 
     char *buf_;
+
+    _SQUID_INLINE_ void set(char const *loc, char const ch);
+    _SQUID_INLINE_ void cutPointer(char const *loc);
+
 };
 
 _SQUID_INLINE_ std::ostream & operator<<(std::ostream& os, String const &aString);
@@ -35,11 +35,20 @@
 
 #include "squid.h"
 #include "Store.h"
+#include "TextException.h"
+
+int
+String::psize() const
+{
+    Must(size() < INT_MAX);
+    return size();
+}
+
 
 // low-level buffer allocation,
 // does not free old buffer and does not adjust or look at len_
 void
-String::allocBuffer(size_t sz)
+String::allocBuffer(String::size_type sz)
 {
     PROF_start(StringInitBuf);
     assert (undefined());
@@ -51,7 +60,7 @@ String::allocBuffer(size_t sz)
 // low-level buffer assignment
 // does not free old buffer and does not adjust or look at len_
 void
-String::setBuffer(char *aBuf, size_t aSize)
+String::setBuffer(char *aBuf, String::size_type aSize)
 {
     assert(undefined());
     assert(aSize < 65536);
@@ -233,6 +242,19 @@ String::absorb(String &old)
     old.len_ = 0;
 }
 
+String
+String::substr(String::size_type from, String::size_type to) const
+{
+    Must(from >= 0 && from < size());
+    Must(to > 0 && to <= size());
+    Must(to > from);
+
+    String rv;
+    rv.limitInit(rawBuf()+from,to-from);
+    return rv;
+}
+
+
 #if DEBUGSTRINGS
 void
 String::stat(StoreEntry *entry) const
@@ -279,7 +301,7 @@ StringRegistry::remove
 
 StringRegistry StringRegistry::Instance_;
 
-extern size_t memStringCount();
+extern String::size_type memStringCount();
 
 void
 StringRegistry::Stat(StoreEntry *entry)
@@ -412,6 +434,56 @@ checkNullString(const char *p)
     return p ? p : "(NULL)";
 }
 
+const char *
+String::pos(char const *aString) const
+{
+    return strstr(termedBuf(), aString);
+}
+
+const char *
+String::pos(char const ch) const
+{
+    return strchr(termedBuf(), ch);
+}
+
+const char *
+String::rpos(char const ch) const
+{
+    return strrchr(termedBuf(), (ch));
+}
+
+String::size_type
+String::find(char const ch) const
+{
+    const char *c;
+    c=pos(ch);
+    if (c==NULL)
+        return npos;
+    return c-rawBuf();
+}
+
+String::size_type
+String::find(char const *aString) const
+{
+    const char *c;
+    c=pos(aString);
+    if (c==NULL)
+        return npos;
+    return c-rawBuf();
+}
+
+String::size_type
+String::rfind(char const ch) const
+{
+    const char *c;
+    c=rpos(ch);
+    if (c==NULL)
+        return npos;
+    return c-rawBuf();
+}
+
+
+
 #ifndef _USE_INLINE_
 #include "String.cci"
 #endif
@@ -35,25 +35,28 @@
 #include "config.h"
 #include <cstring>
 
+#ifdef HAVE_STDINT_H
+#include <stdint.h> //for INT_MAX
+#else /* HAVE_STDINT_H */
+#ifndef INT_MAX
+#define INT_MAX 1<<31 //hack but a safe bet
+#endif /* INT_MAX */
+#endif /* HAVE_STDINT_H */
+
+
 String::String() : size_(0), len_(0), buf_ (NULL)
 {
 #if DEBUGSTRINGS
     StringRegistry::Instance().add(this);
 #endif
 }
 
-int
+String::size_type
 String::size() const
 {
     return len_;
 }
 
-char const *
-String::unsafeBuf() const
-{
-    return buf_;
-}
-
 bool String::defined() const
 {
     return buf_!=NULL;
@@ -84,33 +87,6 @@ String::operator [](unsigned int pos) const
     return buf_[pos];
 }
 
-const char *
-String::pos(char const *aString) const
-{
-    return strstr(termedBuf(), aString);
-}
-
-const char *
-String::pos(char const ch) const
-{
-    return strchr(termedBuf(), ch);
-}
-
-size_t
-String::find(char const ch) const
-{
-    const char *c;
-    c=pos(ch);
-    if (c==NULL)
-        return std::string::npos;
-    return c-rawBuf();
-}
-
-const char *
-String::rpos(char const ch) const
-{
-    return strrchr(termedBuf(), (ch));
-}
 
 int
 String::cmp (char const *aString) const
@@ -130,7 +106,7 @@ String::cmp (char const *aString) const
 }
 
 int
-String::cmp (char const *aString, size_t count) const
+String::cmp (char const *aString, String::size_type count) const
 {
     /* always the same at length 0 */
 
@@ -173,7 +149,7 @@ String::caseCmp(char const *aString) const
 }
 
 int
-String::caseCmp(char const *aString, size_t count) const
+String::caseCmp(char const *aString, String::size_type count) const
 {
     return strncasecmp(termedBuf(), aString, count);
 }
@@ -194,7 +170,7 @@ String::set(char const *loc, char const ch)
 }
 
 void
-String::cut(size_t newLength)
+String::cut(String::size_type newLength)
 {
     if (newLength < 0 || newLength > len_) return;
 
@@ -625,7 +625,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             if (al->request)
                 sb = al->request->header.getByName(fmt->data.header.header);
 
-            out = sb.unsafeBuf();
+            out = sb.termedBuf();
 
             quote = 1;
 
@@ -635,7 +635,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             if (al->reply)
                 sb = al->reply->header.getByName(fmt->data.header.header);
 
-            out = sb.unsafeBuf();
+            out = sb.termedBuf();
 
             quote = 1;
 
@@ -645,7 +645,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             if (al->request)
                 sb = al->request->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
-            out = sb.unsafeBuf();
+            out = sb.termedBuf();
 
             quote = 1;
 
@@ -655,7 +655,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             if (al->reply)
                 sb = al->reply->header.getByNameListMember(fmt->data.header.header, fmt->data.header.element, fmt->data.header.separator);
 
-            out = sb.unsafeBuf();
+            out = sb.termedBuf();
 
             quote = 1;
 
@@ -764,7 +764,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_REQUEST_URLPATH:
             if (al->request) {
-                out = al->request->urlpath.unsafeBuf();
+                out = al->request->urlpath.termedBuf();
                 quote = 1;
             }
             break;
@@ -810,7 +810,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_TAG:
             if (al->request)
-                out = al->request->tag.unsafeBuf();
+                out = al->request->tag.termedBuf();
 
             quote = 1;
 
@@ -823,7 +823,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_EXT_LOG:
             if (al->request)
-                out = al->request->extacl_log.unsafeBuf();
+                out = al->request->extacl_log.termedBuf();
 
             quote = 1;
 
@@ -68,8 +68,11 @@ Adaptation::Config::dumpService(StoreEntry *entry, const char *name) const
     typedef Services::iterator SCI;
     for (SCI i = AllServices().begin(); i != AllServices().end(); ++i) {
         const ServiceConfig &cfg = (*i)->cfg();
-        storeAppendPrintf(entry, "%s %.*s_%s %s %d %.*s\n", name, cfg.key.size(), cfg.key.rawBuf(),
-                          cfg.methodStr(), cfg.vectPointStr(), cfg.bypass, cfg.uri.size(), cfg.uri.rawBuf());
+        storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "_%s %s %d " SQUIDSTRINGPH "\n",
+            name,
+            SQUIDSTRINGPRINT(cfg.key),
+            cfg.methodStr(), cfg.vectPointStr(), cfg.bypass,
+            SQUIDSTRINGPRINT(cfg.uri));
     }
 }
 
@@ -141,7 +144,7 @@ Adaptation::Config::DumpServiceSet(StoreEntry *entry, const char *name)
 {
     typedef Groups::iterator GI;
     for (GI i = AllGroups().begin(); i != AllGroups().end(); ++i)
-        storeAppendPrintf(entry, "%s %s\n", name, (*i)->id.unsafeBuf());
+        storeAppendPrintf(entry, "%s " SQUIDSTRINGPH "\n", name, SQUIDSTRINGPRINT((*i)->id));
 }
 
 void
@@ -173,7 +176,7 @@ Adaptation::Config::DumpAccess(StoreEntry *entry, const char *name)
 
     typedef AccessRules::iterator CI;
     for (CI i = AllRules().begin(); i != AllRules().end(); ++i) {
-        snprintf(nom, 64, "%s %s", name, (*i)->groupId.unsafeBuf());
+        snprintf(nom, 64, "%s " SQUIDSTRINGPH, name, SQUIDSTRINGPRINT((*i)->groupId));
         dump_acl_access(entry, nom, (*i)->acl);
     }
 }
@@ -75,11 +75,13 @@ Adaptation::ServiceConfig::parse()
 
     // extract scheme and use it as the service_configConfig protocol
     const char *schemeSuffix = "://";
-    if (const char *schemeEnd = uri.pos(schemeSuffix))
-        protocol.limitInit(uri.rawBuf(), schemeEnd - uri.rawBuf()); //substring
+    if (const String::size_type schemeEnd=uri.find(schemeSuffix))
+        protocol=uri.substr(0,schemeEnd-1);
+
     debugs(3, 5, HERE << cfg_filename << ':' << config_lineno << ": " <<
            "service protocol is " << protocol);
-    if (!protocol.size())
+
+    if (protocol.size() == 0)
         return false;
 
     // skip scheme
@@ -489,7 +489,7 @@ ClientHttpRequest::logRequest()
             al.http.content_type = al.reply->content_type.termedBuf();
         } else if (loggingEntry() && loggingEntry()->mem_obj) {
             al.http.code = loggingEntry()->mem_obj->getReply()->sline.status;
-            al.http.content_type = loggingEntry()->mem_obj->getReply()->content_type.unsafeBuf();
+            al.http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
         }
 
         debugs(33, 9, "clientLogRequest: http.code='" << al.http.code << "'");
@@ -852,7 +852,7 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
 static void
 clientPackTermBound(String boundary, MemBuf * mb)
 {
-    mb->Printf("\r\n--%.*s--\r\n", boundary.size(), boundary.rawBuf());
+    mb->Printf("\r\n--" SQUIDSTRINGPH "--\r\n", SQUIDSTRINGPRINT(boundary));
     debugs(33, 6, "clientPackTermBound: buf offset: " << mb->size);
 }
 
@@ -868,7 +868,7 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
     /* put boundary */
     debugs(33, 5, "clientPackRangeHdr: appending boundary: " << boundary);
     /* rfc2046 requires to _prepend_ boundary with <crlf>! */
-    mb->Printf("\r\n--%.*s\r\n", boundary.size(), boundary.rawBuf());
+    mb->Printf("\r\n--" SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(boundary));
 
     /* stuff the header with required entries and pack it */
 
@@ -890,7 +890,7 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
 }
 
 /**
- * extracts a "range" from *unsafeBuf and appends them to mb, updating
+ * extracts a "range" from *buf and appends them to mb, updating
  * all offsets and such.
  */
 void
@@ -1168,8 +1168,8 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
             /* delete old Content-Type, add ours */
             hdr->delById(HDR_CONTENT_TYPE);
             httpHeaderPutStrf(hdr, HDR_CONTENT_TYPE,
-                              "multipart/byteranges; boundary=\"%s\"",
-                              http->range_iter.boundary.unsafeBuf());
+                              "multipart/byteranges; boundary=\"" SQUIDSTRINGPH "\"",
+                              SQUIDSTRINGPRINT(http->range_iter.boundary));
             /* Content-Length is not required in multipart responses
              * but it is always nice to have one */
             actual_clen = http->mRangeCLen();
@@ -1923,7 +1923,7 @@ parseHttpRequest(ConnStateData *conn, HttpParser *hp, HttpRequestMethod * method
         req_sz = HttpParserReqSz(hp);
     }
 
-    /* We know the whole request is in hp->unsafeBuf now */
+    /* We know the whole request is in hp->buf now */
 
     assert(req_sz <= (size_t) hp->bufsiz);
 
@@ -2639,7 +2639,7 @@ ConnStateData::handleReadData(char *buf, size_t size)
 }
 
 /**
- * called when new request body data has been buffered in in.unsafeBuf
+ * called when new request body data has been buffered in in.buf
  * may close the connection if we were closing and piped everything out
  */
 void
@@ -1671,7 +1671,7 @@ clientReplyDetach(clientStreamNode * node, ClientHttpRequest * http)
 }
 
 /*
- * accepts chunk of a http message in unsafeBuf, parses prefix, filters headers and
+ * accepts chunk of a http message in buf, parses prefix, filters headers and
  * such, writes processed message to the message recipient
  */
 void
@@ -426,7 +426,7 @@ clientFollowXForwardedForCheck(int answer, void *data)
         const char *asciiaddr;
         int l;
         struct in_addr addr;
-        p = request->x_forwarded_for_iterator.unsafeBuf();
+        p = request->x_forwarded_for_iterator.termedBuf();
         l = request->x_forwarded_for_iterator.size();
 
         /*
@@ -897,7 +897,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         }
 
 #if FORW_VIA_DB
-        fvdbCountVia(s.unsafeBuf());
+        fvdbCountVia(s.termedBuf());
 
 #endif
 
@@ -923,7 +923,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 
     if (req_hdr->has(HDR_X_FORWARDED_FOR)) {
         String s = req_hdr->getList(HDR_X_FORWARDED_FOR);
-        fvdbCountForw(s.unsafeBuf());
+        fvdbCountForw(s.termedBuf());
         s.clean();
     }
 
@@ -192,7 +192,7 @@ Ecap::RequestLineRep::uri(const Area &aUri)
 Ecap::RequestLineRep::Area
 Ecap::RequestLineRep::uri() const
 {
-    return Area::FromTempBuffer(theMessage.urlpath.unsafeBuf(),
+    return Area::FromTempBuffer(theMessage.urlpath.rawBuf(),
                                 theMessage.urlpath.size());
 }
 
@@ -556,9 +556,16 @@ ErrorState::Dump(MemBuf * mb)
 
     if (NULL != request) {
         Packer p;
-        str.Printf("%s %s HTTP/%d.%d\n",
+        String urlpath_or_slash;
+
+        if (request->urlpath.size() != 0)
+            urlpath_or_slash = request->urlpath;
+        else
+            urlpath_or_slash = "/";
+
+        str.Printf("%s " SQUIDSTRINGPH " HTTP/%d.%d\n",
                    RequestMethodStr(request->method),
-                   request->urlpath.size() ? request->urlpath.unsafeBuf() : "/",
+                   SQUIDSTRINGPRINT(urlpath_or_slash),
                    request->http_ver.major, request->http_ver.minor);
         packerToMemInit(&p, &str);
         request->header.packInto(&p);
@@ -734,9 +741,16 @@ ErrorState::Convert(char token)
 
         if (NULL != request) {
             Packer p;
-            mb.Printf("%s %s HTTP/%d.%d\n",
+            String urlpath_or_slash;
+
+            if (request->urlpath.size() != 0)
+                urlpath_or_slash = request->urlpath;
+            else
+                urlpath_or_slash = "/";
+
+            mb.Printf("%s " SQUIDSTRINGPH " HTTP/%d.%d\n",
                       RequestMethodStr(request->method),
-                      request->urlpath.size() ? request->urlpath.unsafeBuf() : "/",
+                      SQUIDSTRINGPRINT(urlpath_or_slash),
                       request->http_ver.major, request->http_ver.minor);
             packerToMemInit(&p, &mb);
             request->header.packInto(&p);
@@ -928,8 +942,7 @@ ErrorState::BuildContent()
      */
     if (!Config.errorDirectory && request && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr) ) {
 
-        const char *unsafeBuf = hdr.unsafeBuf(); // raw header string for parsing
-        int pos = 0; // current parsing position in header string
+        size_t pos = 0; // current parsing position in header string
         char *reset = NULL; // where to reset the p pointer for each new tag file
         char *dt = NULL;
 
@@ -950,12 +963,12 @@ ErrorState::BuildContent()
              *  - IFF a tag contains only two characters we can wildcard ANY translations matching: <it> '-'? .*
              *    with preference given to an exact match.
              */
-            while (pos < hdr.size() && unsafeBuf[pos] != ';' && unsafeBuf[pos] != ',' && !xisspace(unsafeBuf[pos]) && dt < (dir+256) ) {
-                *dt++ = xtolower(unsafeBuf[pos++]);
+            while (pos < hdr.size() && hdr[pos] != ';' && hdr[pos] != ',' && !xisspace(hdr[pos]) && dt < (dir+256) ) {
+                *dt++ = xtolower(hdr[pos++]);
             }
             *dt++ = '\0'; // nul-terminated the filename content string before system use.
 
-            debugs(4, 9, HERE << "STATE: dt='" << dt << "', reset='" << reset << "', reset[1]='" << reset[1] << "', pos=" << pos << ", buf='" << &unsafeBuf[pos] << "'");
+            debugs(4, 9, HERE << "STATE: dt='" << dt << "', reset='" << reset << "', reset[1]='" << reset[1] << "', pos=" << pos << ", buf='" << hdr.substr(pos,hdr.size()) << "'");
 
             /* if we found anything we might use, try it. */
             if (*reset != '\0') {
@@ -983,8 +996,8 @@ ErrorState::BuildContent()
             dt = reset; // reset for next tag testing. we replace the failed name instead of cloning.
 
             // IFF we terminated the tag on ';' we need to skip the 'q=' bit to the next ',' or end.
-            while (pos < hdr.size() && unsafeBuf[pos] != ',') pos++;
-            if (unsafeBuf[pos] == ',') pos++;
+            while (pos < hdr.size() && hdr[pos] != ',') pos++;
+            if (hdr[pos] == ',') pos++;
         }
     }
 #endif /* USE_ERR_LOCALES */
@@ -753,7 +753,7 @@ aclMatchExternal(external_acl_data *acl, ACLChecklist * ch)
 
     external_acl_cache_touch(acl->def, entry);
     result = entry->result;
-    external_acl_message = entry->message.unsafeBuf();
+    external_acl_message = entry->message.termedBuf();
 
     debugs(82, 2, "aclMatchExternal: " << acl->def->name << " = " << result);
 
@@ -1445,16 +1445,20 @@ FtpStateData::checkAuth(const HttpHeader * req_hdr)
     return 0;			/* different username */
 }
 
+static String str_type_eq;
 void
 FtpStateData::checkUrlpath()
 {
     int l;
-    const char *t;
+    size_t t;
+
+    if (str_type_eq.undefined()) //hack. String doesn't support global-static
+        str_type_eq="type=";
 
-    if ((t = request->urlpath.rpos(';')) != NULL) {
-        if (strncasecmp(t + 1, "type=", 5) == 0) {
-            typecode = (char) xtoupper(*(t + 6));
-            request->urlpath.cutPointer(t);
+    if ((t = request->urlpath.rfind(';')) != String::npos) {
+        if (request->urlpath.substr(t+1,t+1+str_type_eq.size())==str_type_eq) {
+            typecode = (char)xtoupper(request->urlpath[t+str_type_eq.size()+1]);
+            request->urlpath.cut(t);
         }
     }
 
@@ -3742,7 +3746,7 @@ ftpUrlWith2f(HttpRequest * request)
         request->urlpath.absorb(newbuf);
         safe_free(request->canonical);
     } else if ( !strncmp(request->urlpath.termedBuf(), "%2f", 3) ) {
-        newbuf.append(request->urlpath.rawBuf() +1, request->urlpath.size()-1);
+        newbuf.append(request->urlpath.substr(1,request->urlpath.size()));
         request->urlpath.absorb(newbuf);
         safe_free(request->canonical);
     }
@@ -853,7 +853,7 @@ gopherReadReply(int fd, char *buf, size_t len, comm_err_t flag, int xerrno, void
         do_next_read = 0;
     } else if (len == 0) {
         /* Connection closed; retrieval done. */
-        /* flush the rest of data in temp unsafeBuf if there is one. */
+        /* flush the rest of data in temp buf if there is one. */
 
         if (gopherState->conversion != gopher_ds::NORMAL)
             gopherEndHTML(gopherState);
@@ -1542,11 +1542,9 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
         } else if (strcmp(orig_request->peer_login, "PASS") == 0) {
             if (orig_request->extacl_user.size() && orig_request->extacl_passwd.size()) {
                 char loginbuf[256];
-                snprintf(loginbuf, sizeof(loginbuf), "%.*s:%.*s",
-                    orig_request->extacl_user.size(),
-                    orig_request->extacl_user.rawBuf(),
-                    orig_request->extacl_passwd.size(),
-                    orig_request->extacl_passwd.rawBuf());
+                snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
+                    SQUIDSTRINGPRINT(orig_request->extacl_user),
+                    SQUIDSTRINGPRINT(orig_request->extacl_passwd));
                 httpHeaderPutStrf(hdr_out, HDR_PROXY_AUTHORIZATION, "Basic %s",
                                   base64_encode(loginbuf));
             }
@@ -1573,11 +1571,9 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
                 hdr_out->putStr(HDR_AUTHORIZATION, auth);
             } else if (orig_request->extacl_user.size() && orig_request->extacl_passwd.size()) {
                 char loginbuf[256];
-                snprintf(loginbuf, sizeof(loginbuf), "%.*s:%.*s",
-                    orig_request->extacl_user.size(),
-                    orig_request->extacl_user.rawBuf(),
-                    orig_request->extacl_passwd.size(),
-                    orig_request->extacl_passwd.rawBuf());
+                snprintf(loginbuf, sizeof(loginbuf), SQUIDSTRINGPH ":" SQUIDSTRINGPH,
+                    SQUIDSTRINGPRINT(orig_request->extacl_user),
+                    SQUIDSTRINGPRINT(orig_request->extacl_passwd));
                 httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
                                   base64_encode(loginbuf));
             }
@@ -1808,7 +1804,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
          * pass on all other header fields
          * which are NOT listed by the special Connection: header. */
 
-        if (strConnection.size()>0 && strListIsMember(&strConnection, e->name.unsafeBuf(), ',')) {
+        if (strConnection.size()>0 && strListIsMember(&strConnection, e->name.termedBuf(), ',')) {
             debugs(11, 2, "'" << e->name << "' header cropped by Connection: definition");
             return;
         }
@@ -231,7 +231,7 @@ peerDigestSetCheck(PeerDigest * pd, time_t delay)
 {
     eventAdd("peerDigestCheck", peerDigestCheck, pd, (double) delay, 1);
     pd->times.next_check = squid_curtime + delay;
-    debugs(72, 3, "peerDigestSetCheck: will check peer " << pd->host.unsafeBuf() << " in " << delay << " secs");
+    debugs(72, 3, "peerDigestSetCheck: will check peer " << pd->host << " in " << delay << " secs");
 }
 
 /*
@@ -241,10 +241,10 @@ void
 peerDigestNotePeerGone(PeerDigest * pd)
 {
     if (pd->flags.requested) {
-        debugs(72, 2, "peerDigest: peer " << pd->host.unsafeBuf() << " gone, will destroy after fetch.");
+        debugs(72, 2, "peerDigest: peer " << pd->host << " gone, will destroy after fetch.");
         /* do nothing now, the fetching chain will notice and take action */
     } else {
-        debugs(72, 2, "peerDigest: peer " << pd->host.unsafeBuf() << " is gone, destroying now.");
+        debugs(72, 2, "peerDigest: peer " << pd->host << " is gone, destroying now.");
         peerDigestDestroy(pd);
     }
 }
@@ -279,7 +279,7 @@ peerDigestCheck(void *data)
     /* per-peer limit */
 
     if (req_time - pd->times.received < PeerDigestReqMinGap) {
-        debugs(72, 2, "peerDigestCheck: " << pd->host.unsafeBuf() <<
+        debugs(72, 2, "peerDigestCheck: " << pd->host <<
                ", avoiding close peer requests (" <<
                (int) (req_time - pd->times.received) << " < " <<
                (int) PeerDigestReqMinGap << " secs).");
@@ -289,7 +289,7 @@ peerDigestCheck(void *data)
 
     /* global limit */
     if (req_time - pd_last_req_time < GlobDigestReqMinGap) {
-        debugs(72, 2, "peerDigestCheck: " << pd->host.unsafeBuf() <<
+        debugs(72, 2, "peerDigestCheck: " << pd->host <<
                ", avoiding close requests (" <<
                (int) (req_time - pd_last_req_time) << " < " <<
                (int) GlobDigestReqMinGap << " secs).");
@@ -544,7 +544,7 @@ peerDigestFetchReply(void *data, char *buf, ssize_t size)
         assert(reply);
         assert (reply->sline.status != 0);
         status = reply->sline.status;
-        debugs(72, 3, "peerDigestFetchReply: " << pd->host.unsafeBuf() << " status: " << status <<
+        debugs(72, 3, "peerDigestFetchReply: " << pd->host << " status: " << status <<
                ", expires: " << (long int) reply->expires << " (" << std::showpos <<
                (int) (reply->expires - squid_curtime) << ")");
 
@@ -634,7 +634,7 @@ peerDigestSwapInHeaders(void *data, char *buf, ssize_t size)
         assert (fetch->entry->getReply()->sline.status != 0);
 
         if (fetch->entry->getReply()->sline.status != HTTP_OK) {
-            debugs(72, 1, "peerDigestSwapInHeaders: " << fetch->pd->host.unsafeBuf() <<
+            debugs(72, 1, "peerDigestSwapInHeaders: " << fetch->pd->host <<
                    " status " << fetch->entry->getReply()->sline.status <<
                    " got cached!");
 
@@ -762,7 +762,7 @@ peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const
 #endif
 
         else
-            host = pd->host.unsafeBuf();
+            host = pd->host.termedBuf();
     }
 
     debugs(72, 6, step_name << ": peer " << host << ", offset: " <<
@@ -813,7 +813,7 @@ static void
 peerDigestFetchStop(DigestFetchState * fetch, char *buf, const char *reason)
 {
     assert(reason);
-    debugs(72, 2, "peerDigestFetchStop: peer " << fetch->pd->host.unsafeBuf() << ", reason: " << reason);
+    debugs(72, 2, "peerDigestFetchStop: peer " << fetch->pd->host << ", reason: " << reason);
     peerDigestReqFinish(fetch, buf, 1, 1, 1, reason, 0);
 }
 
@@ -822,7 +822,7 @@ static void
 peerDigestFetchAbort(DigestFetchState * fetch, char *buf, const char *reason)
 {
     assert(reason);
-    debugs(72, 2, "peerDigestFetchAbort: peer " << fetch->pd->host.unsafeBuf() << ", reason: " << reason);
+    debugs(72, 2, "peerDigestFetchAbort: peer " << fetch->pd->host << ", reason: " << reason);
     peerDigestReqFinish(fetch, buf, 1, 1, 1, reason, 1);
 }
 
@@ -872,7 +872,7 @@ static void
 peerDigestPDFinish(DigestFetchState * fetch, int pcb_valid, int err)
 {
     PeerDigest *pd = fetch->pd;
-    const char *host = pd->host.unsafeBuf();
+    const char *host = pd->host.termedBuf();
 
     pd->times.received = squid_curtime;
     pd->times.req_delay = fetch->resp_time;
@@ -986,7 +986,7 @@ peerDigestSetCBlock(PeerDigest * pd, const char *buf)
 {
     StoreDigestCBlock cblock;
     int freed_size = 0;
-    const char *host = pd->host.unsafeBuf();
+    const char *host = pd->host.termedBuf();
 
     xmemcpy(&cblock, buf, sizeof(cblock));
     /* network -> host conversions */
@@ -1080,7 +1080,7 @@ peerDigestUseful(const PeerDigest * pd)
     const int bit_util = cacheDigestBitUtil(pd->cd);
 
     if (bit_util > 65) {
-        debugs(72, 0, "Warning: " << pd->host.unsafeBuf() <<
+        debugs(72, 0, "Warning: " << pd->host <<
                " peer digest has too many bits on (" << bit_util << "%%).");
 
         return 0;
@@ -1106,7 +1106,7 @@ peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e)
 
     assert(pd);
 
-    const char *host = pd->host.unsafeBuf();
+    const char *host = pd->host.termedBuf();
     storeAppendPrintf(e, "\npeer digest from %s\n", host);
 
     cacheDigestGuessStatsReport(&pd->stats.guess, e, host);
@@ -179,6 +179,7 @@ class FwdState;
 SQUIDCEXTERN void ftpStart(FwdState *);
 
 class HttpRequest;
+class HttpReply;
 
 /// \ingroup ServerProtocolFTPAPI
 SQUIDCEXTERN const char *ftpUrlWith2f(HttpRequest *);
@@ -255,7 +256,7 @@ SQUIDCEXTERN void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val,
 class HttpHeaderFieldInfo;
 SQUIDCEXTERN HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
 SQUIDCEXTERN void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
-SQUIDCEXTERN http_hdr_type httpHeaderIdByName(const char *name, int name_len, const HttpHeaderFieldInfo * attrs, int end);
+SQUIDCEXTERN http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
 SQUIDCEXTERN http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
 SQUIDCEXTERN const char *httpHeaderNameById(int id);
 SQUIDCEXTERN int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
@@ -696,9 +696,9 @@ StoreEntry::setPublicKey()
 #if X_ACCELERATOR_VARY
             vary = mem_obj->getReply()->header.getList(HDR_X_ACCELERATOR_VARY);
 
-            if (vary.unsafeBuf()) {
+            if (vary.defined()) {
                 /* Again, we own this structure layout */
-                rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.unsafeBuf());
+                rep->header.putStr(HDR_X_ACCELERATOR_VARY, vary.termedBuf());
                 vary.clean();
             }
 
@@ -52,12 +52,17 @@ static OBJH storeLogTagsHist;
 
 static Logfile *storelog = NULL;
 
+static String str_unknown;
+
 void
 storeLog(int tag, const StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
     HttpReply const *reply;
 
+    if (str_unknown.undefined())
+        str_unknown="unknown"; //hack. Delay initialization as string doesn't support global variables..
+
     if (NULL == storelog)
         return;
 
@@ -75,7 +80,10 @@ storeLog(int tag, const StoreEntry * e)
          * Because if we print it before the swap file number, it'll break
          * the existing log format.
          */
-        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d %s %"PRId64"/%"PRId64" %s %s\n",
+
+        String ctype=(reply->content_type.size() ? reply->content_type.termedBuf() : str_unknown);
+
+        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %"PRId64"/%"PRId64" %s %s\n",
                       (int) current_time.tv_sec,
                       (int) current_time.tv_usec / 1000,
                       storeLogTags[tag],
@@ -86,7 +94,7 @@ storeLog(int tag, const StoreEntry * e)
                       (int) reply->date,
                       (int) reply->last_modified,
                       (int) reply->expires,
-                      reply->content_type.size() ? reply->content_type.unsafeBuf() : "unknown",
+                      SQUIDSTRINGPRINT(ctype),
                       reply->content_length,
                       e->contentLen(),
                       RequestMethodStr(mem->method),
@@ -97,7 +97,7 @@ testEvent::testDump()
     /* loop over the strings, showing exactly where they differ (if at all) */
     printf("Actual Text:\n");
     /* TODO: these should really be just [] lookups, but String doesn't have those here yet. */
-    for ( int i = 0; i < anEntry->_appended_text.size(); i++) {
+    for ( unsigned int i = 0; i < anEntry->_appended_text.size(); i++) {
         CPPUNIT_ASSERT( expect[i] );
         CPPUNIT_ASSERT( anEntry->_appended_text[i] );
 
@@ -59,3 +59,11 @@ testString::testCmpNotEmptyDefault()
     CPPUNIT_ASSERT(right.cmp("foo") < 0);
     CPPUNIT_ASSERT(right.cmp("foo", 1) < 0);
 }
+
+void testString::testSubstr()
+{
+    String s("0123456789");
+    String check=s.substr(3,5);
+    String ref("34");
+    CPPUNIT_ASSERT(check == ref);
+}
@@ -14,6 +14,8 @@ class testString : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testCmpDefault );
     CPPUNIT_TEST( testCmpEmptyString );
     CPPUNIT_TEST( testCmpNotEmptyDefault );
+    CPPUNIT_TEST( testSubstr );
+
     CPPUNIT_TEST_SUITE_END();
 
 public:
@@ -23,6 +25,7 @@ class testString : public CPPUNIT_NS::TestFixture
     void testCmpDefault();
     void testCmpEmptyString();
     void testCmpNotEmptyDefault();
+    void testSubstr();
 };
 
 #endif
@@ -439,9 +439,8 @@ urlCanonical(HttpRequest * request)
         return request->canonical;
 
     if (request->protocol == PROTO_URN) {
-        snprintf(urlbuf, MAX_URL, "urn:%.*s",
-            request->urlpath.size(),
-            request->urlpath.rawBuf());
+        snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
+            SQUIDSTRINGPRINT(request->urlpath));
     } else {
 /// \todo AYJ: this could use "if..else and method == METHOD_CONNECT" easier.
         switch (request->method.id()) {
@@ -456,14 +455,13 @@ urlCanonical(HttpRequest * request)
             if (request->port != urlDefaultPort(request->protocol))
                 snprintf(portbuf, 32, ":%d", request->port);
 
-            snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s%.*s",
+            snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
                      ProtocolStr[request->protocol],
                      request->login,
                      *request->login ? "@" : null_string,
                      request->GetHost(),
                      portbuf,
-                     request->urlpath.size(),
-                     request->urlpath.rawBuf());
+                     SQUIDSTRINGPRINT(request->urlpath));
 
             break;
         }
@@ -485,8 +483,8 @@ urlCanonicalClean(const HttpRequest * request)
     char *t;
 
     if (request->protocol == PROTO_URN) {
-        snprintf(buf, MAX_URL, "urn:%.*s",
-            request->urlpath.size(), request->urlpath.rawBuf());
+        snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
+            SQUIDSTRINGPRINT(request->urlpath));
     } else {
 /// \todo AYJ: this could use "if..else and method == METHOD_CONNECT" easier.
         switch (request->method.id()) {
@@ -514,13 +512,12 @@ urlCanonicalClean(const HttpRequest * request)
                 strcat(loginbuf, "@");
             }
 
-            snprintf(buf, MAX_URL, "%s://%s%s%s%.*s",
+            snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
                      ProtocolStr[request->protocol],
                      loginbuf,
                      request->GetHost(),
                      portbuf,
-                     request->urlpath.size(),
-                     request->urlpath.rawBuf());
+                     SQUIDSTRINGPRINT(request->urlpath));
             /*
              * strip arguments AFTER a question-mark
              */
@@ -589,9 +586,8 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
     if (req->protocol == PROTO_URN) {
-        snprintf(urlbuf, MAX_URL, "urn:%.*s",
-            req->urlpath.size(),
-            req->urlpath.rawBuf());
+        snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
+            SQUIDSTRINGPRINT(req->urlpath));
         return (urlbuf);
     }
 
@@ -57,7 +57,7 @@ class UrnState : public StoreClient
     char *getHost (String &urlpath);
     void setUriResFromRequest(HttpRequest *);
     bool RequestNeedsMenu(HttpRequest *r);
-    void updateRequestURL(HttpRequest *r, char const *newPath);
+    void updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len);
     void createUriResRequest (String &uri);
 
     virtual ~UrnState();
@@ -171,7 +171,7 @@ UrnState::getHost (String &urlpath)
 
     /** FIXME: this appears to be parsing the URL. *very* badly. */
     /*   a proper encapsulated URI/URL type needs to clear this up. */
-    if ((p=urlpath.find(':')) != std::string::npos) {
+    if ((p=urlpath.find(':')) != String::npos) {
         result=xstrndup(urlpath.rawBuf(),p-1);
     } else {
         result = xstrndup(urlpath.rawBuf(),urlpath.size());
@@ -182,13 +182,16 @@ UrnState::getHost (String &urlpath)
 bool
 UrnState::RequestNeedsMenu(HttpRequest *r)
 {
-    return strncasecmp(r->urlpath.unsafeBuf(), "menu.", 5) == 0;
+    if (r->urlpath.size() < 5)
+        return false;
+    //now we're sure it's long enough
+    return strncasecmp(r->urlpath.rawBuf(), "menu.", 5) == 0;
 }
 
 void
-UrnState::updateRequestURL(HttpRequest *r, char const *newPath)
+UrnState::updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len)
 {
-    char *new_path = xstrdup (newPath);
+    char *new_path = xstrndup (newPath, newPath_len);
     r->urlpath = new_path;
     xfree(new_path);
 }
@@ -198,7 +201,8 @@ UrnState::createUriResRequest (String &uri)
 {
     LOCAL_ARRAY(char, local_urlres, 4096);
     char *host = getHost (uri);
-    snprintf(local_urlres, 4096, "http://%s/uri-res/N2L?urn:%s", host, uri.unsafeBuf());
+    snprintf(local_urlres, 4096, "http://%s/uri-res/N2L?urn:" SQUIDSTRINGPH,
+        host, SQUIDSTRINGPRINT(uri));
     safe_free (host);
     safe_free (urlres);
     urlres = xstrdup (local_urlres);
@@ -209,7 +213,7 @@ void
 UrnState::setUriResFromRequest(HttpRequest *r)
 {
     if (RequestNeedsMenu(r)) {
-        updateRequestURL(r, r->urlpath.unsafeBuf() + 5);
+        updateRequestURL(r, r->urlpath.rawBuf() + 5, r->urlpath.size() - 5 );
         flags.force_menu = 1;
     }
 
@@ -98,7 +98,8 @@ whoisStart(FwdState * fwd)
 
     buf = (char *)xmalloc(l);
 
-    snprintf(buf, l, "%s\r\n", p->request->urlpath.unsafeBuf() + 1);
+    String str_print=p->request->urlpath.substr(1,p->request->urlpath.size());
+    snprintf(buf, l, SQUIDSTRINGPH"\r\n", SQUIDSTRINGPRINT(str_print));
 
     comm_write(fd, buf, strlen(buf), whoisWriteComplete, p, NULL);
     comm_read(fd, p->buf, BUFSIZ, whoisReadReply, p);