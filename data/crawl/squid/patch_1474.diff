@@ -1,4 +1,4 @@
-$Id: CREDITS,v 1.4 1998/12/11 20:09:33 wessels Exp $
+$Id: CREDITS,v 1.5 1999/04/15 06:14:50 wessels Exp $
 
 ==============================================================================
 
@@ -254,3 +254,42 @@ mcast_encode() in src/access_log.c is derived from Mark Atkinson's
 http://www.io.com/~paulhart/game/algorithms/tea.html
 
 ==============================================================================
+
+lib/inet_ntoa.c:
+
+/*
+ * Copyright (c) 1983 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *     This product includes software developed by the University of
+ *     California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+static char sccsid[] = "@(#)inet_ntoa.c        5.6 (Berkeley) 2/24/91";
+
+==============================================================================
@@ -106,6 +106,45 @@ Changes to Squid-2.2 ():
 	  the number of open disk FD's is above the 'max_open_disk_fds'
 	  limit.  Otherwise, a very loaded cache will end up with
 	  all disk files open for reading, and none for writing.
+	- Added lib/inet_ntoa.c from BSD Unix for systems that have
+	  broken inet_ntoa().  (Erik Hofman).
+	- Added more specific FTP error messages for "permission
+	  denied, "file not found," and "service unavailable."
+	  (Tony Finch)
+	- Added xisspace(), xisdigit(), etc, macros to cast function
+	  args and eliminate compiler warnings.
+	- Fixed case-sensitive comparisons of domain names (Henrik
+	  Nordstrom).
+	- Added proxy-authentication to cachemgr.cgi's requests
+	  (Henrik Nordstrom).
+	- Changed Squid to *truncate* rather than *unlink* purged
+	  swap files.  Can be reversed by undefining 
+	  USE_TRUNCATE_NOT_UNLINK in src/defines.h.
+	- Changed internal icon headers to use Cache-control
+	  Max-age instead of Expires.
+	- Changed storeMaintainSwapSpace behavior to be adjusted
+	  smoothly, instead of discretely, between store_swap_low
+	  and store_swap_high.  This includes the number of
+	  objects to scan, number to remove, and time until the
+	  next storeMaintainSwapSpace event.
+	- Fixed a quick_abort bug that incorrectly calculated
+	  content lengths.
+	- Added getpwnam() auth module from Erik Hofman.
+	- Added 'coredump_dir' option.
+	- Fixed a peerDestroy() assertion that required peer->digest
+	  to be NULL at the end of peerDestroy().
+	- configure script now automatically enables dlmalloc for
+	  Solaris/x86.
+	- configure enables poll() on linux 2.2 and later (Henrik).
+	- Icon files are now distributed in binary format, install
+	  will not need to run 'sh' and 'uudecode'.
+	- Fixed some bugs with large responses (>READ_AHEAD_GAP) and
+	  re-forwarding requests and ENTRY_FWD_HDR_WAIT.
+	  fwdCheckDeferRead() will NOT defer reading if the
+	  ENTRY_FWD_HDR_WAIT bit is set.
+	- Fixed a "F->flags.open" assertion for aborted FTP PUT's.
+	- Fixed a (double) cast problem that caused statAvgTick()
+	  events to be added as fast as possible.
 
 Changes to Squid-2.1 (November 16, 1998):
 
@@ -647,6 +686,12 @@ Changes to squid-1.2.beta20 (April 24, 1998):
 	- Fixed "huge 304 reply" loop bug.
 	- Fixed --enable-splaytree compile bugs.
 	- Removed ASN lookup code in peer_select.c.
+	- Added warnings if ACL code detects subdomains in SPLAY
+	  trees.
+	- Rewrote some bits of httpRequestFree() to eliminate
+	  possible bugs that could cause an "e->lock_count" asseertion.
+	- Added value/bounds checking to _db_init() when setting
+	  the debugLevels[] array.
 
 Changes to squid-1.2.beta19 (Apr 8, 1998):
 
@@ -591,7 +591,7 @@ fi
 
 
 
-# From configure.in Revision: 1.167 
+# From configure.in Revision: 1.168 
 ac_aux_dir=
 for ac_dir in cfgaux $srcdir/cfgaux; do
   if test -f $ac_dir/install-sh; then
@@ -887,6 +887,7 @@ if test -z "$PRESET_CFLAGS"; then
 	    ;;
 	alpha-dec-osf4.*)
 	    # Mogul says DEC compilers take both -g and -O2
+	    CFLAGS=`echo $CFLAGS | sed -e 's/-g/-g3/'`
 	    CFLAGS="$CFLAGS -O2"
 	    ;;
 	*)
@@ -912,6 +913,15 @@ if test -z "$PRESET_LDFLAGS"; then
     fi
 fi
 
+if test "x$ac_cv_enabled_dlmalloc" = "x"; then
+    case "$host" in
+	i386-*-solaris2.*)
+		echo "Enabling dlmalloc for $host"
+		ac_cv_enabled_dlmalloc="yes"
+		;;
+    esac
+fi
+
 # Check whether --enable-dlmalloc or --disable-dlmalloc was given.
 if test "${enable_dlmalloc+set}" = set; then
   enableval="$enable_dlmalloc"
@@ -1442,7 +1452,7 @@ case "$host" in
 esac
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1446: checking how to run the C preprocessor" >&5
+echo "configure:1456: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -1457,13 +1467,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1461 "configure"
+#line 1471 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1467: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1477: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1474,13 +1484,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1478 "configure"
+#line 1488 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1484: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1494: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1513,7 +1523,7 @@ echo "$ac_t""$CPP" 1>&6
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:1517: checking for a BSD compatible install" >&5
+echo "configure:1527: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1565,7 +1575,7 @@ test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1569: checking for $ac_word" >&5
+echo "configure:1579: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1592,7 +1602,7 @@ else
 fi
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:1596: checking whether ln -s works" >&5
+echo "configure:1606: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1615,7 +1625,7 @@ fi
 # Extract the first word of "sh", so it can be a program name with args.
 set dummy sh; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1619: checking for $ac_word" >&5
+echo "configure:1629: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SH'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1647,7 +1657,7 @@ fi
 # Extract the first word of "false", so it can be a program name with args.
 set dummy false; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1651: checking for $ac_word" >&5
+echo "configure:1661: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_FALSE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1679,7 +1689,7 @@ fi
 # Extract the first word of "true", so it can be a program name with args.
 set dummy true; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1683: checking for $ac_word" >&5
+echo "configure:1693: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_TRUE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1711,7 +1721,7 @@ fi
 # Extract the first word of "rm", so it can be a program name with args.
 set dummy rm; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1715: checking for $ac_word" >&5
+echo "configure:1725: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_RM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1743,7 +1753,7 @@ fi
 # Extract the first word of "mv", so it can be a program name with args.
 set dummy mv; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1747: checking for $ac_word" >&5
+echo "configure:1757: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MV'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1775,7 +1785,7 @@ fi
 # Extract the first word of "mkdir", so it can be a program name with args.
 set dummy mkdir; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1779: checking for $ac_word" >&5
+echo "configure:1789: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MKDIR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1807,7 +1817,7 @@ fi
 # Extract the first word of "ln", so it can be a program name with args.
 set dummy ln; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1811: checking for $ac_word" >&5
+echo "configure:1821: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LN'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1839,7 +1849,7 @@ fi
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1843: checking for $ac_word" >&5
+echo "configure:1853: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1871,7 +1881,7 @@ fi
 # Extract the first word of "makedepend", so it can be a program name with args.
 set dummy makedepend; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1875: checking for $ac_word" >&5
+echo "configure:1885: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPEND'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1903,7 +1913,7 @@ fi
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1907: checking for $ac_word" >&5
+echo "configure:1917: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1953,20 +1963,20 @@ for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:1957: checking for $ac_hdr that defines DIR" >&5
+echo "configure:1967: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1962 "configure"
+#line 1972 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
 int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:1970: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1980: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -1991,15 +2001,15 @@ done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:1995: checking for opendir in -ldir" >&5
+echo "configure:2005: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2003 "configure"
+#line 2013 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2010,7 +2020,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:2014: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2024: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2032,15 +2042,15 @@ fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:2036: checking for opendir in -lx" >&5
+echo "configure:2046: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2044 "configure"
+#line 2054 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2051,7 +2061,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:2055: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2065: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2074,20 +2084,20 @@ fi
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:2078: checking for ANSI C header files" >&5
+echo "configure:2088: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2083 "configure"
+#line 2093 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2091: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2101: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2104,7 +2114,7 @@ rm -f conftest*
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2108 "configure"
+#line 2118 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -2122,7 +2132,7 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2126 "configure"
+#line 2136 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -2143,7 +2153,7 @@ if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 2147 "configure"
+#line 2157 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -2154,7 +2164,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:2158: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -2238,17 +2248,17 @@ for ac_hdr in \
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2242: checking for $ac_hdr" >&5
+echo "configure:2252: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2247 "configure"
+#line 2257 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2252: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2262: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2276,12 +2286,12 @@ done
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:2280: checking for working const" >&5
+echo "configure:2290: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2285 "configure"
+#line 2295 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -2330,7 +2340,7 @@ ccp = (char const *const *) p;
 
 ; return 0; }
 EOF
-if { (eval echo configure:2334: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2344: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -2351,14 +2361,14 @@ EOF
 fi
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:2355: checking whether byte ordering is bigendian" >&5
+echo "configure:2365: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 2362 "configure"
+#line 2372 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2369,11 +2379,11 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2373: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2383: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 2377 "configure"
+#line 2387 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2384,7 +2394,7 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2388: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2398: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
@@ -2404,7 +2414,7 @@ if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2408 "configure"
+#line 2418 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
@@ -2417,7 +2427,7 @@ main () {
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:2421: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2431: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
@@ -2442,20 +2452,20 @@ fi
 
 
 echo $ac_n "checking if ANSI prototypes work""... $ac_c" 1>&6
-echo "configure:2446: checking if ANSI prototypes work" >&5
+echo "configure:2456: checking if ANSI prototypes work" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ansi_prototypes'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2452 "configure"
+#line 2462 "configure"
 #include "confdefs.h"
 int foo(char *); int foo (char *bar) {return 1;}
 int main() {
 foo("bar")
 ; return 0; }
 EOF
-if { (eval echo configure:2459: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2469: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ansi_prototypes="yes"
 else
@@ -2477,13 +2487,13 @@ EOF
 fi
 
 echo $ac_n "checking for tm->tm_gmtoff""... $ac_c" 1>&6
-echo "configure:2481: checking for tm->tm_gmtoff" >&5
+echo "configure:2491: checking for tm->tm_gmtoff" >&5
 if eval "test \"`echo '$''{'ac_cv_have_tm_gmoff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2487 "configure"
+#line 2497 "configure"
 #include "confdefs.h"
 #include <time.h>
 #include <sys/time.h>
@@ -2492,7 +2502,7 @@ struct tm foo;
       foo.tm_gmtoff = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2496: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2506: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_tm_gmoff="yes"
 else
@@ -2514,13 +2524,13 @@ EOF
 fi
 
 echo $ac_n "checking for extended mallinfo""... $ac_c" 1>&6
-echo "configure:2518: checking for extended mallinfo" >&5
+echo "configure:2528: checking for extended mallinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ext_mallinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2524 "configure"
+#line 2534 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <malloc.h>
@@ -2529,7 +2539,7 @@ struct mallinfo foo;
       foo.mxfast = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2533: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2543: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ext_mallinfo="yes"
 else
@@ -2551,13 +2561,13 @@ EOF
 fi
 
 echo $ac_n "checking for struct rusage""... $ac_c" 1>&6
-echo "configure:2555: checking for struct rusage" >&5
+echo "configure:2565: checking for struct rusage" >&5
 if eval "test \"`echo '$''{'ac_cv_have_struct_rusage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2561 "configure"
+#line 2571 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TIME_H
@@ -2570,7 +2580,7 @@ int main() {
 struct rusage R;
 ; return 0; }
 EOF
-if { (eval echo configure:2574: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2584: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_struct_rusage="yes"
 else
@@ -2592,13 +2602,13 @@ EOF
 fi
 
 echo $ac_n "checking for ip->ip_hl""... $ac_c" 1>&6
-echo "configure:2596: checking for ip->ip_hl" >&5
+echo "configure:2606: checking for ip->ip_hl" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ip_hl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2602 "configure"
+#line 2612 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -2615,7 +2625,7 @@ struct iphdr ip;
       ip.ip_hl= 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2619: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2629: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ip_hl="yes"
 else
@@ -2637,15 +2647,15 @@ EOF
 fi
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:2641: checking size of int" >&5
+echo "configure:2651: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2649 "configure"
+#line 2659 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2656,7 +2666,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2660: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -2676,15 +2686,15 @@ EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:2680: checking size of long" >&5
+echo "configure:2690: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2688 "configure"
+#line 2698 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2695,7 +2705,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2699: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2709: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -2714,23 +2724,62 @@ cat >> confdefs.h <<EOF
 EOF
 
 
+echo $ac_n "checking size of void *""... $ac_c" 1>&6
+echo "configure:2729: checking size of void *" >&5
+if eval "test \"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2737 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main()
+{
+  FILE *f=fopen("conftestval", "w");
+  if (!f) exit(1);
+  fprintf(f, "%d\n", sizeof(void *));
+  exit(0);
+}
+EOF
+if { (eval echo configure:2748: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_sizeof_void_p=`cat conftestval`
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_sizeof_void_p=0
+fi
+rm -fr conftest*
+fi
+
+fi
+echo "$ac_t""$ac_cv_sizeof_void_p" 1>&6
+cat >> confdefs.h <<EOF
+#define SIZEOF_VOID_P $ac_cv_sizeof_void_p
+EOF
+
+
 
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:2722: checking for working alloca.h" >&5
+echo "configure:2771: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2727 "configure"
+#line 2776 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:2734: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2783: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -2751,12 +2800,12 @@ EOF
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:2755: checking for alloca" >&5
+echo "configure:2804: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2760 "configure"
+#line 2809 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -2779,7 +2828,7 @@ int main() {
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:2783: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2832: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -2811,12 +2860,12 @@ EOF
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:2815: checking whether alloca needs Cray hooks" >&5
+echo "configure:2864: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2820 "configure"
+#line 2869 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -2841,12 +2890,12 @@ echo "$ac_t""$ac_cv_os_cray" 1>&6
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2845: checking for $ac_func" >&5
+echo "configure:2894: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2850 "configure"
+#line 2899 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -2869,7 +2918,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2873: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2922: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -2896,15 +2945,15 @@ done
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:2900: checking stack direction for C alloca" >&5
+echo "configure:2949: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 2908 "configure"
+#line 2957 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -2923,7 +2972,7 @@ main ()
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:2927: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2976: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -2946,12 +2995,12 @@ fi
 
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:2950: checking for pid_t" >&5
+echo "configure:2999: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2955 "configure"
+#line 3004 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2979,12 +3028,12 @@ EOF
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:2983: checking for size_t" >&5
+echo "configure:3032: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2988 "configure"
+#line 3037 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3012,12 +3061,12 @@ EOF
 fi
 
 echo $ac_n "checking for ssize_t""... $ac_c" 1>&6
-echo "configure:3016: checking for ssize_t" >&5
+echo "configure:3065: checking for ssize_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ssize_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3021 "configure"
+#line 3070 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3045,12 +3094,12 @@ EOF
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:3049: checking for off_t" >&5
+echo "configure:3098: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3054 "configure"
+#line 3103 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3078,12 +3127,12 @@ EOF
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:3082: checking for mode_t" >&5
+echo "configure:3131: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3087 "configure"
+#line 3136 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3111,12 +3160,12 @@ EOF
 fi
 
 echo $ac_n "checking for fd_mask""... $ac_c" 1>&6
-echo "configure:3115: checking for fd_mask" >&5
+echo "configure:3164: checking for fd_mask" >&5
 if eval "test \"`echo '$''{'ac_cv_type_fd_mask'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3120 "configure"
+#line 3169 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3145,13 +3194,13 @@ fi
 
 
 echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
-echo "configure:3149: checking for socklen_t" >&5
+echo "configure:3198: checking for socklen_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_socklen_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 3155 "configure"
+#line 3204 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -3182,22 +3231,22 @@ EOF
 fi
 
 echo $ac_n "checking for main in -lnsl""... $ac_c" 1>&6
-echo "configure:3186: checking for main in -lnsl" >&5
+echo "configure:3235: checking for main in -lnsl" >&5
 ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3194 "configure"
+#line 3243 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3201: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3250: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3225,22 +3274,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lsocket""... $ac_c" 1>&6
-echo "configure:3229: checking for main in -lsocket" >&5
+echo "configure:3278: checking for main in -lsocket" >&5
 ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3237 "configure"
+#line 3286 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3244: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3293: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3272,22 +3321,22 @@ if test "x$ac_cv_enabled_dlmalloc" = "xyes" ; then
   echo "skipping libmalloc check (--enable-dlmalloc specified)"
 else
   echo $ac_n "checking for main in -lgnumalloc""... $ac_c" 1>&6
-echo "configure:3276: checking for main in -lgnumalloc" >&5
+echo "configure:3325: checking for main in -lgnumalloc" >&5
 ac_lib_var=`echo gnumalloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lgnumalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3284 "configure"
+#line 3333 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3291: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3340: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3330,22 +3379,22 @@ fi
 			*)
   
 				echo $ac_n "checking for main in -lmalloc""... $ac_c" 1>&6
-echo "configure:3334: checking for main in -lmalloc" >&5
+echo "configure:3383: checking for main in -lmalloc" >&5
 ac_lib_var=`echo malloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3342 "configure"
+#line 3391 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3349: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3398: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3378,22 +3427,22 @@ fi
 fi
 
 echo $ac_n "checking for main in -lbsd""... $ac_c" 1>&6
-echo "configure:3382: checking for main in -lbsd" >&5
+echo "configure:3431: checking for main in -lbsd" >&5
 ac_lib_var=`echo bsd'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3390 "configure"
+#line 3439 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3397: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3446: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3421,22 +3470,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lregex""... $ac_c" 1>&6
-echo "configure:3425: checking for main in -lregex" >&5
+echo "configure:3474: checking for main in -lregex" >&5
 ac_lib_var=`echo regex'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lregex  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3433 "configure"
+#line 3482 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3440: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3489: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3457,15 +3506,15 @@ else
 fi
 
 echo $ac_n "checking for gethostbyname in -lbind""... $ac_c" 1>&6
-echo "configure:3461: checking for gethostbyname in -lbind" >&5
+echo "configure:3510: checking for gethostbyname in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3469 "configure"
+#line 3518 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3476,7 +3525,7 @@ int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:3480: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3529: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3510,15 +3559,15 @@ if test $ac_cv_lib_bind_gethostbyname = "no" ; then
 		;;
 	*)
 		echo $ac_n "checking for inet_aton in -lresolv""... $ac_c" 1>&6
-echo "configure:3514: checking for inet_aton in -lresolv" >&5
+echo "configure:3563: checking for inet_aton in -lresolv" >&5
 ac_lib_var=`echo resolv'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3522 "configure"
+#line 3571 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3529,7 +3578,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3533: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3582: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3545,15 +3594,15 @@ fi
 if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for inet_aton in -l44bsd""... $ac_c" 1>&6
-echo "configure:3549: checking for inet_aton in -l44bsd" >&5
+echo "configure:3598: checking for inet_aton in -l44bsd" >&5
 ac_lib_var=`echo 44bsd'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-l44bsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3557 "configure"
+#line 3606 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3564,7 +3613,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3568: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3617: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3596,22 +3645,22 @@ else
 fi
 
 		echo $ac_n "checking for main in -lresolv""... $ac_c" 1>&6
-echo "configure:3600: checking for main in -lresolv" >&5
+echo "configure:3649: checking for main in -lresolv" >&5
 ac_lib_var=`echo resolv'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3608 "configure"
+#line 3657 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3615: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3642,22 +3691,22 @@ fi
     esac
 fi
 echo $ac_n "checking for main in -lm""... $ac_c" 1>&6
-echo "configure:3646: checking for main in -lm" >&5
+echo "configure:3695: checking for main in -lm" >&5
 ac_lib_var=`echo m'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3654 "configure"
+#line 3703 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3661: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3710: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3686,15 +3735,15 @@ fi
 
 
 echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
-echo "configure:3690: checking for crypt in -lcrypt" >&5
+echo "configure:3739: checking for crypt in -lcrypt" >&5
 ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3698 "configure"
+#line 3747 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3705,7 +3754,7 @@ int main() {
 crypt()
 ; return 0; }
 EOF
-if { (eval echo configure:3709: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3758: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3738,22 +3787,22 @@ fi
 
 
 echo $ac_n "checking for main in -lpthread""... $ac_c" 1>&6
-echo "configure:3742: checking for main in -lpthread" >&5
+echo "configure:3791: checking for main in -lpthread" >&5
 ac_lib_var=`echo pthread'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lpthread  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3750 "configure"
+#line 3799 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3757: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3806: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3788,15 +3837,15 @@ fi
 case "$host" in
 	*-pc-sco3.2*)
 		echo $ac_n "checking for strftime in -lintl""... $ac_c" 1>&6
-echo "configure:3792: checking for strftime in -lintl" >&5
+echo "configure:3841: checking for strftime in -lintl" >&5
 ac_lib_var=`echo intl'_'strftime | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3800 "configure"
+#line 3849 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3807,7 +3856,7 @@ int main() {
 strftime()
 ; return 0; }
 EOF
-if { (eval echo configure:3811: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3908,8 +3957,11 @@ if test -z "$ac_cv_func_poll"; then
 			# Henrik Nordstrom (hno@hem.passagen.se) 19980817
 			# poll is problematic on Linux.  We disable it
 			# by default until Linux gets it right.
-			echo "disabling poll for $host..."
-			ac_cv_func_poll='no'
+			rev=`uname -r | awk -F. '{printf "%03d%03d",$1,$2}'`
+			if test $rev -lt 002002; then
+			    echo "disabling poll for $host < 2.2..."
+			    ac_cv_func_poll='no'
+			fi
 			;;
 		powerpc-ibm-aix4.1.*)
 			# Mike Laster (mlaster@metavillage.com) 19981021
@@ -3954,12 +4006,12 @@ for ac_func in \
 	seteuid \
 	setpgrp \
 	setrlimit \
+	getrlimit \
 	setsid \
 	sigaction \
 	snprintf \
 	srand48 \
 	srandom \
-	statvfs \
 	sysconf \
 	syslog \
 	tempnam \
@@ -3968,12 +4020,12 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3972: checking for $ac_func" >&5
+echo "configure:4024: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3977 "configure"
+#line 4029 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3996,7 +4048,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4000: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4052: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4029,12 +4081,12 @@ if test "$async_io" = "yes" ; then
 	
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4033: checking for $ac_func" >&5
+echo "configure:4085: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4038 "configure"
+#line 4090 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4057,7 +4109,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4061: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4113: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4084,15 +4136,15 @@ done
 fi
 
 echo $ac_n "checking if setresuid is implemented""... $ac_c" 1>&6
-echo "configure:4088: checking if setresuid is implemented" >&5
+echo "configure:4140: checking if setresuid is implemented" >&5
 if eval "test \"`echo '$''{'ac_cv_func_setresuid'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 4096 "configure"
+#line 4148 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4105,7 +4157,7 @@ else
   }
   
 EOF
-if { (eval echo configure:4109: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4161: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_setresuid="yes"
 else
@@ -4130,7 +4182,7 @@ fi
 
 if test "$IPF_TRANSPARENT" ; then
     echo $ac_n "checking if IP-Filter header files are installed""... $ac_c" 1>&6
-echo "configure:4134: checking if IP-Filter header files are installed" >&5
+echo "configure:4186: checking if IP-Filter header files are installed" >&5
     if test "$ac_cv_header_ip_compat_h" = "no" ||
        test "$ac_cv_header_ip_fil_h" = "no" ||
        test "$ac_cv_header_ip_nat_h" = "no" ; then
@@ -4165,21 +4217,21 @@ if test -z "$USE_GNUREGEX" ; then
     esac
 fi
 echo $ac_n "checking if GNUregex needs to be compiled""... $ac_c" 1>&6
-echo "configure:4169: checking if GNUregex needs to be compiled" >&5
+echo "configure:4221: checking if GNUregex needs to be compiled" >&5
 if test -z "$USE_GNUREGEX"; then
 if test "$ac_cv_func_regcomp" = "no" || test "$USE_GNUREGEX" = "yes" ; then
 	USE_GNUREGEX="yes"
 else
 	cat > conftest.$ac_ext <<EOF
-#line 4175 "configure"
+#line 4227 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <regex.h>
 int main() {
 regex_t t; regcomp(&t,"",0);
 ; return 0; }
 EOF
-if { (eval echo configure:4183: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4235: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   USE_GNUREGEX="no"
 else
@@ -4210,12 +4262,12 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4214: checking for $ac_func" >&5
+echo "configure:4266: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4219 "configure"
+#line 4271 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4238,7 +4290,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4242: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4294: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4266,12 +4318,12 @@ done
 
 
 echo $ac_n "checking Default FD_SETSIZE value""... $ac_c" 1>&6
-echo "configure:4270: checking Default FD_SETSIZE value" >&5
+echo "configure:4322: checking Default FD_SETSIZE value" >&5
 if test "$cross_compiling" = yes; then
   DEFAULT_FD_SETSIZE=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4275 "configure"
+#line 4327 "configure"
 #include "confdefs.h"
 
 #if HAVE_STDIO_H
@@ -4296,7 +4348,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4300: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   DEFAULT_FD_SETSIZE=`cat conftestval`
 else
@@ -4315,12 +4367,12 @@ EOF
 
 
 echo $ac_n "checking Maximum number of filedescriptors we can open""... $ac_c" 1>&6
-echo "configure:4319: checking Maximum number of filedescriptors we can open" >&5
+echo "configure:4371: checking Maximum number of filedescriptors we can open" >&5
 if test "$cross_compiling" = yes; then
   SQUID_MAXFD=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4324 "configure"
+#line 4376 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -4359,7 +4411,12 @@ main() {
     }
 #endif /* RLIMIT_NOFILE */
 #endif /* HAVE_SETRLIMIT */
-#if HAVE_SYSCONF && defined(_SC_OPEN_MAX)
+#if HAVE_GETRLIMIT && defined(RLIMIT_NOFILE)
+	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
+		perror("getrlimit: RLIMIT_NOFILE");
+	}
+	i = rl.rlim_cur;
+#elif HAVE_SYSCONF && defined(_SC_OPEN_MAX)
         i = sysconf(_SC_OPEN_MAX);
 #elif HAVE_GETDTABLESIZE && !defined(__linux__)
         i = getdtablesize();
@@ -4381,7 +4438,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4442: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_MAXFD=`cat conftestval`
 else
@@ -4407,12 +4464,12 @@ if test "$SQUID_MAXFD" -lt 512 ; then
 fi
 
 echo $ac_n "checking Default UDP send buffer size""... $ac_c" 1>&6
-echo "configure:4411: checking Default UDP send buffer size" >&5
+echo "configure:4468: checking Default UDP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4416 "configure"
+#line 4473 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4433,7 +4490,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4437: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4494: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_SNDBUF=`cat conftestval`
 else
@@ -4452,12 +4509,12 @@ EOF
 
 
 echo $ac_n "checking Default UDP receive buffer size""... $ac_c" 1>&6
-echo "configure:4456: checking Default UDP receive buffer size" >&5
+echo "configure:4513: checking Default UDP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4461 "configure"
+#line 4518 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4478,7 +4535,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4482: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4539: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_RCVBUF=`cat conftestval`
 else
@@ -4497,12 +4554,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP send buffer size""... $ac_c" 1>&6
-echo "configure:4501: checking Default TCP send buffer size" >&5
+echo "configure:4558: checking Default TCP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4506 "configure"
+#line 4563 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4514,7 +4571,6 @@ main ()
 {
 	FILE *fp;
         int fd,val=0,len=sizeof(int);
-	FILE *fp;
 	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) exit(1);
         if (getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &len) < 0) exit(1);
 	if (val <= 0) exit(1);
@@ -4524,7 +4580,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4528: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4584: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_SNDBUF=`cat conftestval`
 else
@@ -4543,12 +4599,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP receive buffer size""... $ac_c" 1>&6
-echo "configure:4547: checking Default TCP receive buffer size" >&5
+echo "configure:4603: checking Default TCP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4552 "configure"
+#line 4608 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4560,7 +4616,6 @@ main ()
 {
 	FILE *fp;
         int fd,val=0,len=sizeof(int);
-	FILE *fp;
 	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) exit(1);
         if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &val, &len) < 0) exit(1);
 	if (val <= 0) exit(1);
@@ -4570,7 +4625,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4574: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4629: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_RCVBUF=`cat conftestval`
 else
@@ -4589,19 +4644,19 @@ EOF
 
 
 echo $ac_n "checking if sys_errlist is already defined""... $ac_c" 1>&6
-echo "configure:4593: checking if sys_errlist is already defined" >&5
+echo "configure:4648: checking if sys_errlist is already defined" >&5
 if eval "test \"`echo '$''{'ac_cv_needs_sys_errlist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4598 "configure"
+#line 4653 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 int main() {
 char *s = sys_errlist0;
 ; return 0; }
 EOF
-if { (eval echo configure:4605: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4660: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_needs_sys_errlist="no"
 else
@@ -4623,16 +4678,16 @@ EOF
 fi
 
 echo $ac_n "checking for libresolv _dns_ttl_ hack""... $ac_c" 1>&6
-echo "configure:4627: checking for libresolv _dns_ttl_ hack" >&5
+echo "configure:4682: checking for libresolv _dns_ttl_ hack" >&5
 cat > conftest.$ac_ext <<EOF
-#line 4629 "configure"
+#line 4684 "configure"
 #include "confdefs.h"
 extern int _dns_ttl_;
 int main() {
 return _dns_ttl_;
 ; return 0; }
 EOF
-if { (eval echo configure:4636: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4691: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 cat >> confdefs.h <<\EOF
@@ -4648,12 +4703,12 @@ fi
 rm -f conftest*
 
 echo $ac_n "checking if inet_ntoa() actually works""... $ac_c" 1>&6
-echo "configure:4652: checking if inet_ntoa() actually works" >&5
+echo "configure:4707: checking if inet_ntoa() actually works" >&5
 if test "$cross_compiling" = yes; then
   INET_NTOA_RESULT="broken"
 else
   cat > conftest.$ac_ext <<EOF
-#line 4657 "configure"
+#line 4712 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4672,7 +4727,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4676: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4731: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   INET_NTOA_RESULT=`cat conftestval`
 else
@@ -4688,17 +4743,19 @@ if test "$INET_NTOA_RESULT" = "1.2.3.4" ; then
 	echo "$ac_t"""yes"" 1>&6
 else
 	echo "$ac_t"""no"" 1>&6
-	echo "WARNING: This looks bad, and probably prevents Squid from working."
-	echo "         If you're on IRIX and using GCC 2.8, you probably need"
-	echo "         to use the IRIX C compiler instead."
-	sleep 10
+	echo "Will use our own inet_ntoa()."
+	LIBOBJS="$LIBOBJS inet_ntoa.o"
+#	echo "WARNING: This looks bad, and probably prevents Squid from working."
+#	echo "         If you're on IRIX and using GCC 2.8, you probably need"
+#	echo "         to use the IRIX C compiler instead."
+#	sleep 10
 fi
 
-if test "$ac_cv_func_statvfs" = "yes" ; then
+if test "$ac_cv_header_sys_statvfs_h" = "yes" ; then
 echo $ac_n "checking for working statvfs() interface""... $ac_c" 1>&6
-echo "configure:4700: checking for working statvfs() interface" >&5
+echo "configure:4757: checking for working statvfs() interface" >&5
 cat > conftest.$ac_ext <<EOF
-#line 4702 "configure"
+#line 4759 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4715,7 +4772,7 @@ statvfs("/tmp", &sfs);
 
 ; return 0; }
 EOF
-if { (eval echo configure:4719: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4776: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_func_statvfs=yes
 else
@@ -4726,15 +4783,21 @@ else
 fi
 rm -f conftest*
 echo "$ac_t""$ac_cv_func_statvfs" 1>&6
+fi
+if test $ac_cv_func_statvfs = "yes" ; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_STATVFS 1
+EOF
+
 fi
 
 echo $ac_n "checking for _res.nsaddr_list""... $ac_c" 1>&6
-echo "configure:4733: checking for _res.nsaddr_list" >&5
+echo "configure:4796: checking for _res.nsaddr_list" >&5
 if eval "test \"`echo '$''{'ac_cv_have_res_nsaddr_list'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4738 "configure"
+#line 4801 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H
@@ -4757,7 +4820,7 @@ int main() {
 _res.nsaddr_list[0];
 ; return 0; }
 EOF
-if { (eval echo configure:4761: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4824: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_res_nsaddr_list="yes"
 else
@@ -4779,12 +4842,12 @@ fi
 
 if test $ac_cv_have_res_nsaddr_list = "no" ; then
 echo $ac_n "checking for _res.ns_list""... $ac_c" 1>&6
-echo "configure:4783: checking for _res.ns_list" >&5
+echo "configure:4846: checking for _res.ns_list" >&5
 if eval "test \"`echo '$''{'ac_cv_have_res_ns_list'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4788 "configure"
+#line 4851 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H
@@ -4807,7 +4870,7 @@ int main() {
 _res.ns_list[0].addr;
 ; return 0; }
 EOF
-if { (eval echo configure:4811: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4874: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_res_ns_list="yes"
 else
@@ -4968,6 +5031,7 @@ trap 'rm -fr `echo "\
 	./auth_modules/NCSA/Makefile \
 	./auth_modules/PAM/Makefile \
 	./auth_modules/SMB/Makefile
+	./auth_modules/getpwnam/Makefile \
  include/autoconf.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
@@ -5100,6 +5164,7 @@ CONFIG_FILES=\${CONFIG_FILES-"\
 	./auth_modules/NCSA/Makefile \
 	./auth_modules/PAM/Makefile \
 	./auth_modules/SMB/Makefile
+	./auth_modules/getpwnam/Makefile \
 "}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
@@ -3,13 +3,13 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.168 1999/04/07 19:48:53 wessels Exp $
+dnl  $Id: configure.in,v 1.169 1999/04/15 06:14:54 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.168 $)dnl
+AC_REVISION($Revision: 1.169 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(cfgaux)
 
@@ -97,6 +97,7 @@ if test -z "$PRESET_CFLAGS"; then
 	    ;;
 	alpha-dec-osf4.*)
 	    # Mogul says DEC compilers take both -g and -O2
+	    CFLAGS=`echo $CFLAGS | sed -e 's/-g/-g3/'`
 	    CFLAGS="$CFLAGS -O2"
 	    ;;
 	*)
@@ -123,6 +124,15 @@ if test -z "$PRESET_LDFLAGS"; then
     fi
 fi
 
+if test "x$ac_cv_enabled_dlmalloc" = "x"; then
+    case "$host" in
+	i386-*-solaris2.*)
+		echo "Enabling dlmalloc for $host"
+		ac_cv_enabled_dlmalloc="yes"
+		;;
+    esac
+fi
+
 dnl Enable optional modules
 AC_ARG_ENABLE(dlmalloc,
 [  --enable-dlmalloc[=LIB] Compile & use the malloc package by Doug Lea],
@@ -696,6 +706,7 @@ fi
 dnl Check for typedefs
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
+AC_CHECK_SIZEOF(void *)
 
 dnl Check for special functions
 AC_FUNC_ALLOCA
@@ -864,8 +875,11 @@ if test -z "$ac_cv_func_poll"; then
 			# Henrik Nordstrom (hno@hem.passagen.se) 19980817
 			# poll is problematic on Linux.  We disable it
 			# by default until Linux gets it right.
-			echo "disabling poll for $host..."
-			ac_cv_func_poll='no'
+			rev=`uname -r | awk -F. '{printf "%03d%03d",$1,$2}'`
+			if test $rev -lt 002002; then
+			    echo "disabling poll for $host < 2.2..."
+			    ac_cv_func_poll='no'
+			fi
 			;;
 		[powerpc-ibm-aix4.1.*])
 			# Mike Laster (mlaster@metavillage.com) 19981021
@@ -911,12 +925,12 @@ AC_CHECK_FUNCS(\
 	seteuid \
 	setpgrp \
 	setrlimit \
+	getrlimit \
 	setsid \
 	sigaction \
 	snprintf \
 	srand48 \
 	srandom \
-	statvfs \
 	sysconf \
 	syslog \
 	tempnam \
@@ -1078,7 +1092,12 @@ main() {
     }
 #endif /* RLIMIT_NOFILE */
 #endif /* HAVE_SETRLIMIT */
-#if HAVE_SYSCONF && defined(_SC_OPEN_MAX)
+#if HAVE_GETRLIMIT && defined(RLIMIT_NOFILE)
+	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
+		perror("getrlimit: RLIMIT_NOFILE");
+	}
+	i = rl.rlim_cur;
+#elif HAVE_SYSCONF && defined(_SC_OPEN_MAX)
         i = sysconf(_SC_OPEN_MAX);
 #elif HAVE_GETDTABLESIZE && !defined(__linux__)
         i = getdtablesize();
@@ -1176,7 +1195,6 @@ main ()
 {
 	FILE *fp;
         int fd,val=0,len=sizeof(int);
-	FILE *fp;
 	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) exit(1);
         if (getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &len) < 0) exit(1);
 	if (val <= 0) exit(1);
@@ -1203,7 +1221,6 @@ main ()
 {
 	FILE *fp;
         int fd,val=0,len=sizeof(int);
-	FILE *fp;
 	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) exit(1);
         if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &val, &len) < 0) exit(1);
 	if (val <= 0) exit(1);
@@ -1258,13 +1275,15 @@ if test "$INET_NTOA_RESULT" = "1.2.3.4" ; then
 	AC_MSG_RESULT("yes")
 else
 	AC_MSG_RESULT("no")
-	echo "WARNING: This looks bad, and probably prevents Squid from working."
-	echo "         If you're on IRIX and using GCC 2.8, you probably need"
-	echo "         to use the IRIX C compiler instead."
-	sleep 10
+	echo "Will use our own inet_ntoa()."
+	LIBOBJS="$LIBOBJS inet_ntoa.o"
+#	echo "WARNING: This looks bad, and probably prevents Squid from working."
+#	echo "         If you're on IRIX and using GCC 2.8, you probably need"
+#	echo "         to use the IRIX C compiler instead."
+#	sleep 10
 fi
 
-if test "$ac_cv_func_statvfs" = "yes" ; then
+if test "$ac_cv_header_sys_statvfs_h" = "yes" ; then
 AC_MSG_CHECKING(for working statvfs() interface)
 AC_TRY_COMPILE([
 #include <stdlib.h>
@@ -1282,6 +1301,9 @@ statvfs("/tmp", &sfs);
   ac_cv_func_statvfs=no)
 AC_MSG_RESULT($ac_cv_func_statvfs)
 fi
+if test $ac_cv_func_statvfs = "yes" ; then
+  AC_DEFINE(HAVE_STATVFS)
+fi
 
 AC_CACHE_CHECK(for _res.nsaddr_list, ac_cv_have_res_nsaddr_list,
 AC_TRY_COMPILE([
@@ -1379,4 +1401,5 @@ AC_OUTPUT(\
 	./auth_modules/NCSA/Makefile \
 	./auth_modules/PAM/Makefile \
 	./auth_modules/SMB/Makefile
+	./auth_modules/getpwnam/Makefile \
 )
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -14,9 +14,5 @@ Squid sent the following FTP command:
 and then received this reply
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
-<P>
-This might be caused by an FTP URL with an absolute path (which does
-not comply with RFC 1738).  If this is the cause, then the file
-can be found at <A HREF="%B">%B</A>.
 </P>
 
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,16 @@
+<HTML><HEAD>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
+</HEAD><BODY>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
+<HR>
+<P>
+URLi <A HREF="%U">%U</A> lugemisel tekkis t&otilde;rge FTP autentimisel.
+<P>
+Squid saatis j&auml;rgneva FTP k&auml;su:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+ja sai sellise vastuse
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,20 @@
+<HTML><HEAD>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
+</HEAD><BODY>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
+<HR>
+<P>
+URLi <A HREF="%U">%U</A> ei &otilde;nnestu lugeda:
+<P>
+Squid saatis j&auml;rgneva ftp k&auml;su:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+ja sai sellise vastuse
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+See olukord v&otilde;ib olla tekkinud, kui FTP URL on antud absoluutse
+teega (mis on vastuolus RFC 1738-ga). Kui see on nii, siis saab faili 
+aadressilt <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
+</HEAD><BODY>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
+<HR>
+<P>
+FTP server oli j&auml;rgneva URLi lugemise ajal liiga koormatud:
+<A HREF="%U">%U</A>
+<P>
+Squid saatis j&auml;rgneva FTP k&auml;su:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+ja sai sellise vastuse
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -1,17 +1,17 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
 </HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-While trying to retrieve the URL:
+Lugedes j&auml;rgnevat URLi:
 <A HREF="%U">%U</A>
 <P>
-The following error was encountered:
+Tekkis j&auml;rgnev viga:
 <UL>
 <P>
-This cache is in the process of shutting down and can not
-service your request at this time.  Please retry your
-request again soon.
+Meie server on saanud k&auml;su t&ouml;&ouml; l&otilde;petada ja 
+ei saa teie p&auml;ringut hetkel teenindada. Palun korrake oma
+p&auml;ringut motilde;ne aja p&auml;rast.
 </P>
@@ -1,21 +1,21 @@
-<HTML><HEAD>
-<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
-</HEAD><BODY>
-<H1>VIGA</H1>
-<H2>P&auml;ring URLile ei saa vastust</H2>
-<HR>
-<P>
-Sooritades p&auml;ringut URLile
-<A HREF="%U">%U</A>
-<P>
-tekkis j&auml;rgnev viga:
-<UL>
-<LI>
-<STRONG>
-Vastus on t&uuml;hi
-</STRONG>
-</UL>
-
-<P>
-Squid ei saanud selle p&auml;ringu vastuseks midagi...
-</P>
+<HTML><HEAD>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
+</HEAD><BODY>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
+<HR>
+<P>
+Sooritades p&auml;ringut URLile
+<A HREF="%U">%U</A>
+<P>
+tekkis j&auml;rgnev viga:
+<UL>
+<LI>
+<STRONG>
+Vastus on t&uuml;hi
+</STRONG>
+</UL>
+
+<P>
+Squid ei saanud selle p&auml;ringu vastuseks midagi...
+</P>
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -22,6 +22,6 @@ A hiba oka val
 <UL>
 <LI>A cache adminisztrtor nem engedlyezi a forrs szerverekhez val kzvetlen
     kapcsolat felptst s
-<LI>minden ltalunk hasznlt szl cache szerver nem rhet el jelenleg.
+<LI>egyik ltalunk hasznlt szl cache szerver sem rhet el jelenleg.
 </UL>
 </P>
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -21,6 +21,6 @@ direkt
 
 Olyan krst kldtt el, amelyben <code>only-if-cached</code> cache vezrl direktva  
 tallhat. A dokumentum nincs a cache-ben <em>vagy</em> a dokumentum
-rvnyessg-ellenrzst ignyelt volna, ezt azonban a <code>only-if-cached</code>
+rvnyessg-ellenrzst ignyelt volna, ezt azonban az <code>only-if-cached</code>
 direktva megtiltotta.
 </P>
@@ -1,17 +1,17 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
-</HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<TITLE>HIBA: A krt URL nem tlthet le</TITLE>
+<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2"></HEAD>
+<BODY>
+<H1>HIBA</H1>
+<H2>A krt URL nem tlthet le</H2>
 <HR>
 <P>
-While trying to retrieve the URL:
+Az albbi URL letltsekor:
 <A HREF="%U">%U</A>
 <P>
-The following error was encountered:
+a kvetkez hiba lpett fel:
 <UL>
-<P>
-This cache is in the process of shutting down and can not
-service your request at this time.  Please retry your
-request again soon.
+<LI>
+A cache lellsra kszl s ezrt nem tudja kiszolglni a krst.
+Krjk, rvid id mlva ismtelje meg krst!</UL>
 </P>
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERRO: A URL solicitada n&atilde;o pode ser recuperada</TITLE>
+</HEAD><BODY>
+<H1>ERRO</H1>
+<H2>A URL solicitada n&atilde;o pode ser recuperada</H2>
+<HR>
+<P>
+Ocorreu uma falha na autentica&ccedil;&atilde;o no FTP,
+na tentativa de recuperar a seguinte URL:
+<A HREF="%U">%U</A>
+<P>
+Squid emitiu o seguinte comando FTP:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+e recebeu esta resposta:
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERRO: A URL solicitada n&atilde;o pode ser recuperada</TITLE>
+</HEAD><BODY>
+<H1>ERRO</H1>
+<H2>A URL solicitada n&atilde;o pode ser recuperada</H2>
+<HR>
+<P>
+A seguite URL n&atilde;o pode ser recuperada (n&atilde;o foi encontrada):
+<A HREF="%U">%U</A>
+<P>
+Squid emitiu o seguinte comando FTP:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+e recebeu esta resposta:
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+Isto pode ter como causa uma URL de FTP com caminho absoluto (quen&atilde;o
+est&aacute; de acordo com a RFC 1738). Se a causa for essa, ent&atilde;o
+o arquivo pode ser encontrado em <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERRO: A URL solicitada n&atilde;o pode ser recuperada</TITLE>
+</HEAD><BODY>
+<H1>ERRO</H1>
+<H2>A URL solicitada n&atilde;o pode ser recuperada</H2>
+<HR>
+<P>
+O servidor de FTP estava muito ocupado, enquanto tentava recuperar a seguite URL:
+<A HREF="%U">%U</A>
+<P>
+Squid emitiu o seguinte comando FTP:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+e recebeu esta resposta:
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -1,17 +1,20 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+<TITLE>ERRO: A URL solicitada n&atilde;o pode ser recuperada</TITLE>
 </HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<H1>ERRO</H1>
+<H2>A URL solicitada n&atilde;o pode ser recuperada</H2>
 <HR>
 <P>
-While trying to retrieve the URL:
-<A HREF="%U">%U</A>
+Enquanto tentava recuperar a URL:
+<A HREF="%U">%U</A>,
 <P>
-The following error was encountered:
+o seguite erro foi encontrado:
 <UL>
 <P>
-This cache is in the process of shutting down and can not
-service your request at this time.  Please retry your
-request again soon.
+Este servidor de cache est&aacute; em procedimento de 
+<STRONG>shutting down</STRONG> e n&atilde;o pode servir
+sua requisi&ccedil;&atilde;o neste momento. Por favor,
+tente mais tarde. Voc&ecirc; pode tentar usar outro servidor
+de cache, ou desligar o <STRONG>proxy</STRONG>, alterando a 
+configura&ccedil;&atilde;o de seu <STRONG>browser</STRONG>.
 </P>
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,18 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+An FTP authentication failure occurred
+while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -0,0 +1,21 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The following URL could not be retrieved:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+<P>
+This might be caused by an FTP URL with an absolute path (which does
+not comply with RFC 1738).  If this is the cause, then the file
+can be found at <A HREF="%B">%B</A>.
+</P>
+
@@ -0,0 +1,17 @@
+<HTML><HEAD>
+<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+</HEAD><BODY>
+<H1>ERROR</H1>
+<H2>The requested URL could not be retrieved</H2>
+<HR>
+<P>
+The FTP server was too busy while trying to retrieve the URL:
+<A HREF="%U">%U</A>
+<P>
+Squid sent the following FTP command:
+<blockquote><strong><pre>%f</pre></strong></blockquote>
+and then received this reply
+<blockquote><strong><pre>%F</pre></strong></blockquote>
+<blockquote><strong><pre>%g</pre></strong></blockquote>
+</P>
+
@@ -241,12 +241,20 @@
  */
 #define USE_IDENT 1
 
+/*
+ * If your system has statvfs(), and if it actually works!
+ */
+#undef HAVE_STATVFS
+
 /* The number of bytes in a int.  */
 #undef SIZEOF_INT
 
 /* The number of bytes in a long.  */
 #undef SIZEOF_LONG
 
+/* The number of bytes in a void *.  */
+#undef SIZEOF_VOID_P
+
 /* Define if you have the bcopy function.  */
 #undef HAVE_BCOPY
 
@@ -265,6 +273,9 @@
 /* Define if you have the getpagesize function.  */
 #undef HAVE_GETPAGESIZE
 
+/* Define if you have the getrlimit function.  */
+#undef HAVE_GETRLIMIT
+
 /* Define if you have the getrusage function.  */
 #undef HAVE_GETRUSAGE
 
@@ -355,9 +366,6 @@
 /* Define if you have the srandom function.  */
 #undef HAVE_SRANDOM
 
-/* Define if you have the statvfs function.  */
-#undef HAVE_STATVFS
-
 /* Define if you have the strerror function.  */
 #undef HAVE_STRERROR
 
@@ -1,5 +1,5 @@
 /*
- * $Id: cache_snmp.h,v 1.22 1999/01/26 06:16:30 glenn Exp $
+ * $Id: cache_snmp.h,v 1.23 1999/04/15 06:15:35 wessels Exp $
  */
 
 #ifdef SQUID_SNMP
@@ -35,6 +35,9 @@
 
 #define SQUIDMIB 1, 3, 6, 1, 4, 1, 3495, 1
 #define LEN_SQUIDMIB 8
+#define INSTANCE 0
+#define TIME_INDEX 1, 5, 60
+#define TIME_INDEX_LEN 3
 
 /* basic groups under .squid */
 
@@ -61,6 +64,9 @@ enum {
     SYS_END
 };
 
+#define LEN_SYS LEN_SQ_SYS + 1
+#define LEN_SYS_INST LEN_SQ_SYS + 2
+
 /* 
 	cacheConfig group 
 */
@@ -75,6 +81,9 @@ enum {
     CONF_END
 };
 
+#define LEN_CONF LEN_SQ_CONF + 1
+#define LEN_CONF_INST LEN_SQ_CONF + 2
+
 enum {
     CONF_ST_START,
     CONF_ST_MMAXSZ,
@@ -84,6 +93,9 @@ enum {
     CONF_ST_END
 };
 
+#define LEN_CONF_ST LEN_CONF + 1
+#define LEN_CONF_ST_INST LEN_CONF + 2
+
 /* 
 	cacheMesh group 
 */
@@ -131,6 +143,14 @@ enum {				/* cacheClientTable */
 	cacheNetwork group 
 */
 
+enum {
+    NET_START,
+    NET_IP_CACHE,
+    NET_FQDN_CACHE,
+    NET_DNS_CACHE,
+    NET_END
+};
+
 enum {
     IP_START,
     IP_ENT,
@@ -172,7 +192,6 @@ enum {
     PERF_START,
     PERF_SYS,
     PERF_PROTO,
-    PERF_PEER,
     PERF_END
 };
 
@@ -1,10 +1,10 @@
 /*
- * $Id: version.h,v 1.124 1999/02/02 23:57:40 wessels Exp $
+ * $Id: version.h,v 1.125 1999/04/15 06:15:36 wessels Exp $
  *
  *  SQUID_VERSION - String for version id of this distribution
  */
 #ifndef SQUID_VERSION
-#define SQUID_VERSION	"2.2.PRE3"
+#define SQUID_VERSION	"2.2.DEVEL4"
 #endif
 
 #ifndef SQUID_RELEASE_TIME
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 1983 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *     This product includes software developed by the University of
+ *     California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)inet_ntoa.c        5.6 (Berkeley) 2/24/91";
+#endif /* LIBC_SCCS and not lint */
+
+/*
+ * Convert network-format internet address
+ * to base 256 d.d.d.d representation.
+ */
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdio.h>
+
+char *
+inet_ntoa(struct in_addr in)
+{
+    static char b[18];
+    register char *p;
+
+    p = (char *) &in;
+#define        UC(b)   (((int)b)&0xff)
+    (void) snprintf(b, sizeof(b),
+	"%d.%d.%d.%d", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));
+    return (b);
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: rfc1123.c,v 1.22 1999/04/08 07:09:00 wessels Exp $
+ * $Id: rfc1123.c,v 1.23 1999/04/15 06:15:38 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -93,9 +93,9 @@ make_month(const char *s)
     int i;
     char month[3];
 
-    month[0] = toupper(*s);
-    month[1] = tolower(*(s + 1));
-    month[2] = tolower(*(s + 2));
+    month[0] = xtoupper(*s);
+    month[1] = xtolower(*(s + 1));
+    month[2] = xtolower(*(s + 2));
 
     for (i = 0; i < 12; i++)
 	if (!strncmp(month_names[i], month, 3))
@@ -119,7 +119,7 @@ parse_rfc1123(const char *str)
 	s++;			/* or: Thu, 10 Jan 1993 01:29:59 GMT */
 	while (*s == ' ')
 	    s++;
-	if (isdigit(*s) && !isdigit(*(s + 1)))	/* backoff if only one digit */
+	if (xisdigit(*s) && !xisdigit(*(s + 1)))	/* backoff if only one digit */
 	    s--;
 	if (strchr(s, '-')) {	/* First format */
 	    if ((int) strlen(s) < 18)
@@ -1,5 +1,5 @@
 /*
- * $Id: snprintf.c,v 1.16 1998/09/29 16:47:53 wessels Exp $
+ * $Id: snprintf.c,v 1.17 1999/04/15 06:15:38 wessels Exp $
  */
 
 /* ====================================================================
@@ -302,7 +302,7 @@ typedef struct buf_area buffy;
 
 #define STR_TO_DEC( str, num )		\
     num = NUM( *str++ ) ;		\
-    while ( isdigit( *str ) )		\
+    while ( xisdigit( *str ) )		\
     {					\
 	num *= 10 ;			\
 	num += NUM( *str++ ) ;		\
@@ -422,7 +422,7 @@ conv_fp(register char format, register double num,
     /*
      * Check for Infinity and NaN
      */
-    if (isalpha(*p)) {
+    if (xisalpha(*p)) {
 	*len = strlen(strcpy(buf, p));
 	*is_negative = FALSE;
 	return (buf);
@@ -577,7 +577,7 @@ format_converter(register buffy * odp, const char *fmt,
 	    /*
 	     * Try to avoid checking for flags, width or precision
 	     */
-	    if (isascii(*fmt) && !islower(*fmt)) {
+	    if (xisascii(*fmt) && !xislower(*fmt)) {
 		/*
 		 * Recognize flags: -, #, BLANK, +
 		 */
@@ -599,7 +599,7 @@ format_converter(register buffy * odp, const char *fmt,
 		/*
 		 * Check if a width was specified
 		 */
-		if (isdigit(*fmt)) {
+		if (xisdigit(*fmt)) {
 		    STR_TO_DEC(fmt, min_width);
 		    adjust_width = YES;
 		} else if (*fmt == '*') {
@@ -623,7 +623,7 @@ format_converter(register buffy * odp, const char *fmt,
 		if (*fmt == '.') {
 		    adjust_precision = YES;
 		    fmt++;
-		    if (isdigit(*fmt)) {
+		    if (xisdigit(*fmt)) {
 			STR_TO_DEC(fmt, precision);
 		    } else if (*fmt == '*') {
 			precision = va_arg(ap, int);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: util.c,v 1.65 1998/11/12 06:30:16 wessels Exp $
+ * $Id: util.c,v 1.66 1999/04/15 06:15:39 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -678,7 +678,7 @@ xcountws(const char *str)
 {
     size_t count = 0;
     if (str) {
-	while (isspace(*str)) {
+	while (xisspace(*str)) {
 	    str++;
 	    count++;
 	}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrExtField.cc,v 1.6 1998/07/22 20:36:44 wessels Exp $
+ * $Id: HttpHdrExtField.cc,v 1.7 1999/04/15 06:15:40 wessels Exp $
  *
  * DEBUG: section 69    HTTP Header: Extension Field
  * AUTHOR: Alex Rousskov
@@ -73,7 +73,7 @@ httpHdrExtFieldParseCreate(const char *field_start, const char *field_end)
 
     value_start = name_end + 1;	/* skip ':' */
     /* skip white space */
-    while (value_start < field_end && isspace(*value_start))
+    while (value_start < field_end && xisspace(*value_start))
 	value_start++;
 
     return httpHdrExtFieldDoCreate(
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.61 1999/01/24 02:26:19 wessels Exp $
+ * $Id: HttpHeader.cc,v 1.62 1999/04/15 06:15:40 wessels Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -819,7 +819,7 @@ httpHeaderGetAuth(const HttpHeader * hdr, http_hdr_type id, const char *authSche
     if (!l || strncasecmp(field, authScheme, l))	/* wrong scheme */
 	return NULL;
     field += l;
-    if (!isspace(*field))	/* wrong scheme */
+    if (!xisspace(*field))	/* wrong scheme */
 	return NULL;
     /* skip white space */
     field += xcountws(field);
@@ -933,7 +933,7 @@ httpHeaderEntryParseCreate(const char *field_start, const char *field_end)
     else
 	e->name = Headers[id].name;
     /* trim field value */
-    while (value_start < field_end && isspace(*value_start))
+    while (value_start < field_end && xisspace(*value_start))
 	value_start++;
     /* set field value */
     stringLimitInit(&e->value, value_start, field_end - value_start);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeaderTools.cc,v 1.24 1999/01/24 02:26:20 wessels Exp $
+ * $Id: HttpHeaderTools.cc,v 1.25 1999/04/15 06:15:41 wessels Exp $
  *
  * DEBUG: section 66    HTTP Header Tools
  * AUTHOR: Alex Rousskov
@@ -241,7 +241,7 @@ strListGetItem(const String * str, char del, const char **item, int *ilen, const
 	*pos = *item + strlen(*item);
     len = *pos - *item;		/* *pos points to del or '\0' */
     /* rtrim */
-    while (len > 0 && isspace((*item)[len - 1]))
+    while (len > 0 && xisspace((*item)[len - 1]))
 	len--;
     if (ilen)
 	*ilen = len;
@@ -268,7 +268,7 @@ httpHeaderParseInt(const char *start, int *value)
 {
     assert(value);
     *value = atoi(start);
-    if (!*value && !isdigit(*start)) {
+    if (!*value && !xisdigit(*start)) {
 	debug(66, 2) ("failed to parse an int header field near '%s'\n", start);
 	return 0;
     }
@@ -308,7 +308,7 @@ httpHeaderTestParser(const char *hstr)
 	    hstr = p + 1;
     }
     /* skip invalid first line if any */
-    if (isspace(*hstr)) {
+    if (xisspace(*hstr)) {
 	const char *p = strchr(hstr, '\n');
 	if (p)
 	    hstr = p + 1;
@@ -353,8 +353,8 @@ httpHeaderStrCmp(const char *h1, const char *h2, int len)
     if (!strncasecmp(h1, h2, len))
 	return 0;
     while (1) {
-	const char c1 = toupper(h1[len1 += xcountws(h1 + len1)]);
-	const char c2 = toupper(h2[len2 += xcountws(h2 + len2)]);
+	const char c1 = xtoupper(h1[len1 += xcountws(h1 + len1)]);
+	const char c2 = xtoupper(h2[len2 += xcountws(h2 + len2)]);
 	if (c1 < c2)
 	    return -len1;
 	if (c1 > c2)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpStatusLine.cc,v 1.17 1998/08/14 19:25:12 wessels Exp $
+ * $Id: HttpStatusLine.cc,v 1.18 1999/04/15 06:15:42 wessels Exp $
  *
  * DEBUG: section 57    HTTP Status-line
  * AUTHOR: Alex Rousskov
@@ -83,7 +83,7 @@ httpStatusLineParse(HttpStatusLine * sline, const char *start, const char *end)
     if (strncasecmp(start, "HTTP/", 5))
 	return 0;
     start += 5;
-    if (!isdigit(*start))
+    if (!xisdigit(*start))
 	return 0;
     sline->version = atof(start);
     if (!(start = strchr(start, ' ')))
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.199 1999/04/07 20:03:48 wessels Exp $
+ * $Id: acl.cc,v 1.200 1999/04/15 06:15:43 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -673,6 +673,11 @@ aclParseAclLine(acl ** head)
 	debug(28, 3) ("aclParseAclLine: Appending to '%s'\n", aclname);
 	new_acl = 0;
     }
+    /*
+     * Here we set AclMatchedName in case we need to use it in a
+     * warning message in aclDomainCompare().
+     */
+    AclMatchedName = aclname;	/* ugly */
     switch (A->type) {
     case ACL_SRC_IP:
     case ACL_DST_IP:
@@ -737,6 +742,10 @@ aclParseAclLine(acl ** head)
 	fatal("Bad ACL type");
 	break;
     }
+    /*
+     * Clear AclMatchedName from our temporary hack
+    */
+    AclMatchedName = NULL;	/* ugly */
     if (!new_acl)
 	return;
     if (A->data == NULL) {
@@ -997,7 +1006,7 @@ aclDecodeProxyAuth(const char *proxy_auth, char **user, char **password, char *b
     /* Trim trailing \n before decoding */
     strtok(sent_auth, "\n");
     /* Trim leading whitespace before decoding */
-    while (isspace(*proxy_auth))
+    while (xisspace(*proxy_auth))
 	proxy_auth++;
     cleartext = uudecode(sent_auth);
     xfree(sent_auth);
@@ -1886,10 +1895,18 @@ aclDomainCompare(const void *data, splayNode * n)
     while (d1[l1] == d2[l2]) {
 	if ((l1 == 0) && (l2 == 0))
 	    return 0;		/* d1 == d2 */
-	if (l1-- == 0)
+	if (l1-- == 0) {
+	    debug(28, 0) ("WARNING: %s is a subdomain of %s\n", d1, d2);
+	    debug(28, 0) ("WARNING: This may break Splay tree searching\n");
+	    debug(28, 0) ("WARNING: You should remove '%s' from the ACL named '%s'\n", d2, AclMatchedName);
 	    return -1;		/* d1 < d2 */
-	if (l2-- == 0)
+	}
+	if (l2-- == 0) {
+	    debug(28, 0) ("WARNING: %s is a subdomain of %s\n", d2, d1);
+	    debug(28, 0) ("WARNING: This may break Splay tree searching\n");
+	    debug(28, 0) ("WARNING: You should remove '%s' from the ACL named '%s'\n", d1, AclMatchedName);
 	    return 1;		/* d1 > d2 */
+	}
     }
     return (d1[l1] - d2[l2]);
 }
@@ -1908,7 +1925,7 @@ aclHostDomainCompare(const void *data, splayNode * n)
     l1 = strlen(h);
     l2 = strlen(d);
     /* h != d */
-    while (h[l1] == d[l2]) {
+    while (xtolower(h[l1]) == xtolower(d[l2])) {
 	if (l1 == 0)
 	    break;
 	if (l2 == 0)
@@ -1921,7 +1938,7 @@ aclHostDomainCompare(const void *data, splayNode * n)
 	return -1;		/* domain(h) < d */
     if ((d[l2] == '.') || (l2 == 0))
 	return 1;		/* domain(h) > d */
-    return (h[l1] - d[l2]);
+    return (xtolower(h[l1]) - xtolower(d[l2]));
 }
 
 /* compare two network specs
@@ -1,5 +1,5 @@
 /*
- * $Id: asn.cc,v 1.56 1999/01/29 21:28:07 wessels Exp $
+ * $Id: asn.cc,v 1.57 1999/04/15 06:15:44 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -238,10 +238,10 @@ asHandleReply(void *data, char *buf, ssize_t size)
     }
     s = buf;
     while (s - buf < size && *s != '\0') {
-	while (*s && isspace(*s))
+	while (*s && xisspace(*s))
 	    s++;
 	for (t = s; *t; t++) {
-	    if (isspace(*t))
+	    if (xisspace(*t))
 		break;
 	}
 	if (*t == '\0') {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.325 1999/04/07 21:39:04 wessels Exp $
+ * $Id: cache_cf.cc,v 1.326 1999/04/15 06:15:45 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -327,7 +327,7 @@ configDoConfigure(void)
 	    cbdataFree(Config.Wais.peer);
 	Config.Wais.peer = memAllocate(MEM_PEER);
 	cbdataAdd(Config.Wais.peer, peerDestroy, MEM_PEER);
-	Config.Wais.peer->host = Config.Wais.relayHost;
+	Config.Wais.peer->host = xstrdup(Config.Wais.relayHost);
 	Config.Wais.peer->http_port = Config.Wais.relayPort;
     }
 }
@@ -771,7 +771,7 @@ parse_cachedir(cacheSwap * swap)
     int size;
     int l1;
     int l2;
-    int read_only = 0;
+    unsigned int read_only = 0;
     SwapDir *tmp = NULL;
     if ((path = strtok(NULL, w_space)) == NULL)
 	self_destruct();
@@ -801,10 +801,10 @@ parse_cachedir(cacheSwap * swap)
 		debug(3, 1) ("Cache dir '%s' size changed to %d KB\n",
 		    path, size);
 	    tmp->max_size = size;
-	    if (tmp->read_only != read_only)
+	    if (tmp->flags.read_only != read_only)
 		debug(3, 1) ("Cache dir '%s' now %s\n",
 		    path, read_only ? "Read-Only" : "Read-Write");
-	    tmp->read_only = read_only;
+	    tmp->flags.read_only = read_only;
 	    return;
 	}
     }
@@ -824,7 +824,7 @@ parse_cachedir(cacheSwap * swap)
     tmp->max_size = size;
     tmp->l1 = l1;
     tmp->l2 = l2;
-    tmp->read_only = read_only;
+    tmp->flags.read_only = read_only;
     tmp->swaplog_fd = -1;
     swap->n_configured++;
 }
@@ -886,7 +886,7 @@ dump_peer(StoreEntry * entry, const char *name, peer * p)
 	    p->http_port,
 	    p->icp.port);
 	dump_peer_options(entry, p);
-	for (d = p->pinglist; d; d = d->next) {
+	for (d = p->peer_domain; d; d = d->next) {
 	    storeAppendPrintf(entry, "cache_peer_domain %s %s%s\n",
 		p->host,
 		d->do_ping ? null_string : "!",
@@ -997,7 +997,8 @@ parse_peer(peer ** head)
 	    p->carp.hash += (p->carp.hash << 19) + *token;
     }
 #endif
-    cbdataAdd(p, peerDestroy, MEM_PEER);	/* must preceed peerDigestCreate */
+    /* This must preceed peerDigestCreate */
+    cbdataAdd(p, peerDestroy, MEM_PEER);
 #if USE_CACHE_DIGESTS
     if (!p->options.no_digest) {
 	p->digest = peerDigestCreate(p);
@@ -1146,7 +1147,7 @@ parse_hostdomain(void)
 	    domain++;
 	}
 	l->domain = xstrdup(domain);
-	for (L = &(p->pinglist); *L; L = &((*L)->next));
+	for (L = &(p->peer_domain); *L; L = &((*L)->next));
 	*L = l;
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cachemgr.cc,v 1.84 1999/01/19 02:24:22 wessels Exp $
+ * $Id: cachemgr.cc,v 1.85 1999/04/15 06:15:46 wessels Exp $
  *
  * DEBUG: section 0     CGI Cache Manager
  * AUTHOR: Duane Wessels
@@ -206,9 +206,9 @@ xstrtok(char **str, char del)
 	    *str = NULL;
 	/* trim */
 	len = strlen(tok);
-	while (len && isspace(tok[len - 1]))
+	while (len && xisspace(tok[len - 1]))
 	    tok[--len] = '\0';
-	while (isspace(*tok))
+	while (xisspace(*tok))
 	    tok++;
 	return tok;
     } else
@@ -273,8 +273,8 @@ parse_status_line(const char *sline, const char **statusStr)
 	*statusStr = NULL;
     if (strncasecmp(sline, "HTTP/", 5) || !sp)
 	return -1;
-    while (isspace(*++sp));
-    if (!isdigit(*sp))
+    while (xisspace(*++sp));
+    if (!xisdigit(*sp))
 	return -1;
     if (statusStr)
 	*statusStr = sp;
@@ -725,6 +725,7 @@ static const char *
 make_auth_header(const cachemgr_request * req)
 {
     static char buf[1024];
+    off_t l = 0;
     const char *str64;
     if (!req->passwd)
 	return "";
@@ -734,6 +735,8 @@ make_auth_header(const cachemgr_request * req)
 	req->passwd);
 
     str64 = base64_encode(buf);
-    snprintf(buf, sizeof(buf), "Authorization: Basic %s\r\n", str64);
+    l += snprintf(buf, sizeof(buf), "Authorization: Basic %s\r\n", str64);
+    l += snprintf(&buf[l], sizeof(buf) - l,
+	"Proxy-Authorization: Basic %s\r\n", str64);
     return buf;
 }
@@ -1,6 +1,6 @@
 
 #
-# $Id: cf.data.pre,v 1.146 1999/04/07 21:39:05 wessels Exp $
+# $Id: cf.data.pre,v 1.147 1999/04/15 06:15:47 wessels Exp $
 #
 #
 # SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -2089,7 +2089,7 @@ DOC_START
 	Lowering this value increases the total number of buckets and
 	also the storage maintenance rate.  The default is 20.
 
-store_objects_per_bucket 20
+store_objects_per_bucket 50
 DOC_END
 
 NAME: client_db
@@ -2348,7 +2348,7 @@ DEFAULT: @DEFAULT_ERROR_DIR@
 DOC_START
 	If you wish to create your own versions of the default
 	(English) error files, either to customise them to suit your
-	language or company copy the template english files to anther
+	language or company copy the template english files to another
 	directory and point this tag at them.
 DOC_END
 
@@ -2658,7 +2658,7 @@ TYPE: int
 DEFAULT: 8
 LOC: Config.comm_incoming.http_min_poll
 DOC_START
-	Heavy voodoo here.  I can't even beleve you are reading this.
+	Heavy voodoo here.  I can't even believe you are reading this.
 	Are you crazy?  Don't even think about adjusting these unless
 	you understand the algorithms in comm_select.c first!
 
@@ -2734,21 +2734,33 @@ IFDEF: MULTICAST_MISS_STREAM
 TYPE: address
 LOC: Config.mcast_miss.addr
 DEFAULT: 255.255.255.255
-DOC_NONE
+DOC_START
+	If you enable this option, every "cache miss" URL will
+	be sent out on the specified multicast address.
+
+	Do not enable this option unless you are are absolutely
+	certain you understand what you are doing.
+DOC_END
 
 NAME: mcast_miss_port
 IFDEF: MULTICAST_MISS_STREAM
 TYPE: ushort
 LOC: Config.mcast_miss.port
 DEFAULT: 3135
-DOC_NONE
+DOC_START
+	This is the port number to be used in conjuction with
+	'mcast_miss_addr'.
+DOC_END
 
 NAME: mcast_miss_encode_key
 IFDEF: MULTICAST_MISS_STREAM
 TYPE: string
 LOC: Config.mcast_miss.encode_key
 DEFAULT: XXXXXXXXXXXXXXXX
-DOC_NONE
+DOC_START
+	The URLs that are sent in the multicast miss stream are
+	encrypted.  This is the encryption key.
+DOC_END
 
 NAME: prefer_direct
 TYPE: onoff
@@ -2775,4 +2787,15 @@ DOC_START
 strip_query_terms on
 DOC_END
 
+NAME: coredump_dir
+TYPE: string
+LOC: Config.coredump_dir
+DEFAULT: none
+DOC_START
+	By default Squid leaves core files in the first cache_dir
+	directory.  If you set 'coredump_dir' to a directory
+	that exists, Squid will chdir() to that directory at startup
+	and coredump files will be left there.
+DOC_END
+
 EOF
@@ -1,5 +1,5 @@
 /*
- * $Id: cf_gen.cc,v 1.31 1999/01/24 04:29:43 wessels Exp $
+ * $Id: cf_gen.cc,v 1.32 1999/04/15 06:15:47 wessels Exp $
  *
  * DEBUG: none
  * AUTHOR: Max Okumoto
@@ -177,17 +177,17 @@ main(int argc, char *argv[])
 		(void) 0;
 	    } else if (!strncmp(buff, "COMMENT:", 8)) {
 		ptr = buff + 8;
-		while (isspace(*ptr))
+		while (xisspace(*ptr))
 		    ptr++;
 		curr->comment = xstrdup(ptr);
 	    } else if (!strncmp(buff, "DEFAULT:", 8)) {
 		ptr = buff + 8;
-		while (isspace(*ptr))
+		while (xisspace(*ptr))
 		    ptr++;
 		curr->default_value = xstrdup(ptr);
 	    } else if (!strncmp(buff, "DEFAULT_IF_NONE:", 16)) {
 		ptr = buff + 16;
-		while (isspace(*ptr))
+		while (xisspace(*ptr))
 		    ptr++;
 		curr->default_if_none = xstrdup(ptr);
 	    } else if (!strncmp(buff, "LOC:", 4)) {
@@ -1,8 +1,6 @@
 
-
-
 /*
- * $Id: client.cc,v 1.82 1999/04/07 22:06:45 wessels Exp $
+ * $Id: client.cc,v 1.83 1999/04/15 06:15:48 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_db.cc,v 1.43 1998/12/05 00:54:18 wessels Exp $
+ * $Id: client_db.cc,v 1.44 1999/04/15 06:15:49 wessels Exp $
  *
  * DEBUG: section 0     Client Database
  * AUTHOR: Duane Wessels
@@ -201,28 +201,31 @@ clientdbFreeMemory(void)
 }
 
 #if SQUID_SNMP
-int
-meshCtblGetRowFn(oid * New, oid * Oid)
+struct in_addr *
+client_entry(struct in_addr *current)
 {
     ClientInfo *c = NULL;
+    char *key;
 
-    if (!Oid[0] && !Oid[1] && !Oid[2] && !Oid[3]) {
+    if (current) {
+	key = inet_ntoa(*current);
 	hash_first(client_table);
+	while ((c = (ClientInfo *) hash_next(client_table))) {
+	    if (!strcmp(key, c->key))
+		break;
+	}
 	c = (ClientInfo *) hash_next(client_table);
-	hash_last(client_table);
     } else {
-	char key[15];
-	snprintf(key, sizeof(key), "%d.%d.%d.%d", Oid[0], Oid[1], Oid[2], Oid[3]);
-	c = (ClientInfo *) hash_lookup(client_table, key);
-	if (NULL != c)
-	    c = c->next;
+	hash_first(client_table);
+	c = (ClientInfo *) hash_next(client_table);
     }
-    if (!c)
-	return 0;
-    addr2oid(c->addr, New);
-    return 1;
-}
+    hash_last(client_table);
+    if (c)
+	return (&c->addr);
+    else
+	return (NULL);
 
+}
 
 variable_list *
 snmp_meshCtblFn(variable_list * Var, snint * ErrP)
@@ -236,6 +239,9 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
     Answer = snmp_var_new(Var->name, Var->name_length);
     *ErrP = SNMP_ERR_NOERROR;
 
+    debug(49, 6) ("snmp_meshCtblFn: Current : \n");
+    snmpDebugOid(6, Var->name, Var->name_length);
+
     snprintf(key, sizeof(key), "%d.%d.%d.%d", Var->name[LEN_SQ_NET + 3], Var->name[LEN_SQ_NET + 4],
 	Var->name[LEN_SQ_NET + 5], Var->name[LEN_SQ_NET + 6]);
     debug(49, 5) ("snmp_meshCtblFn: [%s] requested!\n", key);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.442 1999/03/24 04:16:08 rousskov Exp $
+ * $Id: client_side.cc,v 1.443 1999/04/15 06:15:50 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -201,10 +201,16 @@ clientAccessCheckDone(int answer, void *data)
 	debug(33, 5) ("Access Denied: %s\n", http->uri);
 	debug(33, 5) ("AclMatchedName = %s\n",
 	    AclMatchedName ? AclMatchedName : "<null>");
+	/*
+	 * NOTE: get page_id here, based on AclMatchedName because
+	 * if USE_DELAY_POOLS is enabled, then AclMatchedName gets
+	 * clobbered in the clientCreateStoreEntry() call
+	 * just below.  Pedro Ribeiro <pribeiro@isel.pt>
+	 */
+	page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName);
 	http->log_type = LOG_TCP_DENIED;
 	http->entry = clientCreateStoreEntry(http, http->request->method,
 	    null_request_flags);
-	page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName);
 	if (answer == ACCESS_REQ_PROXY_AUTH || aclIsProxyAuth(AclMatchedName)) {
 	    if (!http->flags.accel) {
 		/* Proxy authorisation needed */
@@ -291,13 +297,18 @@ clientProcessExpired(void *data)
     }
     http->request->flags.refresh = 1;
     http->old_entry = http->entry;
+    /*
+     * Assert that 'http' is already a client of old_entry.  If 
+     * it is not, then the beginning of the object data might get
+     * freed from memory before we need to access it.
+     */
+    assert(storeClientListSearch(http->old_entry->mem_obj, http));
     entry = storeCreateEntry(url,
 	http->log_uri,
 	http->request->flags,
 	http->request->method);
     /* NOTE, don't call storeLockObject(), storeCreateEntry() does it */
     storeClientListAdd(entry, http);
-    storeClientListAdd(http->old_entry, http);
 #if DELAY_POOLS
     /* delay_id is already set on original store client */
     delaySetStoreClient(entry, http, delayClient(http->request));
@@ -364,17 +375,23 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 {
     clientHttpRequest *http = data;
     StoreEntry *entry = http->entry;
-    MemObject *mem = entry->mem_obj;
+    MemObject *mem;
     const char *url = storeUrl(entry);
     int unlink_request = 0;
     StoreEntry *oldentry;
     int recopy = 1;
-    const http_status status = mem->reply->sline.status;
+    http_status status;
     debug(33, 3) ("clientHandleIMSReply: %s, %d bytes\n", url, (int) size);
+    if (entry == NULL) {
+	memFree(buf, MEM_CLIENT_SOCK_BUF);
+	return;
+    }
     if (size < 0 && !EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
 	memFree(buf, MEM_CLIENT_SOCK_BUF);
 	return;
     }
+    mem = entry->mem_obj;
+    status = mem->reply->sline.status;
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
 	debug(33, 3) ("clientHandleIMSReply: ABORTED '%s'\n", url);
 	/* We have an existing entry, but failed to validate it */
@@ -605,20 +622,22 @@ httpRequestFree(void *data)
     clientHttpRequest *http = data;
     clientHttpRequest **H;
     ConnStateData *conn = http->conn;
-    StoreEntry *entry = http->entry;
+    StoreEntry *e;
     request_t *request = http->request;
     MemObject *mem = NULL;
-    debug(33, 3) ("httpRequestFree: %s\n", storeUrl(entry));
+    debug(33, 3) ("httpRequestFree: %s\n", storeUrl(http->entry));
     if (!clientCheckTransferDone(http)) {
-	if (entry)
-	    storeUnregister(entry, http);
-	entry = http->entry;	/* reset, IMS might have changed it */
-	if (entry && entry->ping_status == PING_WAITING)
-	    storeReleaseRequest(entry);
+	if ((e = http->entry)) {
+	    http->entry = NULL;
+	    storeUnregister(e, http);
+	    storeUnlockObject(e);
+	}
+	if (http->entry && http->entry->ping_status == PING_WAITING)
+	    storeReleaseRequest(http->entry);
     }
     assert(http->log_type < LOG_TYPE_MAX);
-    if (entry)
-	mem = entry->mem_obj;
+    if (http->entry)
+	mem = http->entry->mem_obj;
     if (http->out.size || http->log_type) {
 	http->al.icp.opcode = ICP_INVALID;
 	http->al.url = http->log_uri;
@@ -662,17 +681,17 @@ httpRequestFree(void *data)
     safe_free(http->al.headers.reply);
     safe_free(http->redirect.location);
     stringClean(&http->range_iter.boundary);
-    if (entry) {
+    if ((e = http->entry)) {
 	http->entry = NULL;
-	storeUnregister(entry, http);
-	storeUnlockObject(entry);
+	storeUnregister(e, http);
+	storeUnlockObject(e);
     }
     /* old_entry might still be set if we didn't yet get the reply
      * code in clientHandleIMSReply() */
-    if (http->old_entry) {
-	storeUnregister(http->old_entry, http);
-	storeUnlockObject(http->old_entry);
+    if ((e = http->old_entry)) {
 	http->old_entry = NULL;
+	storeUnregister(e, http);
+	storeUnlockObject(e);
     }
     requestUnlink(http->request);
     assert(http != http->next);
@@ -2020,19 +2039,19 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 	debug(33, 1) ("parseHttpRequest: Missing URL\n");
 	return parseHttpRequestAbort(conn, "error:missing-url");
     }
-    while (isspace(*url))
+    while (xisspace(*url))
 	url++;
     t = url + strlen(url);
     assert(*t == '\0');
     token = NULL;
     while (t > url) {
 	t--;
-	if (isspace(*t) && !strncmp(t + 1, "HTTP/", 5)) {
+	if (xisspace(*t) && !strncmp(t + 1, "HTTP/", 5)) {
 	    token = t + 1;
 	    break;
 	}
     }
-    while (t > url && isspace(*t))
+    while (t > url && xisspace(*t))
 	*(t--) = '\0';
     debug(33, 5) ("parseHttpRequest: URI is '%s'\n", url);
     if (token == NULL) {
@@ -2247,7 +2266,7 @@ clientReadRequest(int fd, void *data)
     while (conn->in.offset > 0) {
 	int nrequests;
 	size_t req_line_sz;
-	while (conn->in.offset > 0 && isspace(conn->in.buf[0])) {
+	while (conn->in.offset > 0 && xisspace(conn->in.buf[0])) {
 	    xmemmove(conn->in.buf, conn->in.buf + 1, conn->in.offset - 1);
 	    conn->in.offset--;
 	}
@@ -2316,9 +2335,9 @@ clientReadRequest(int fd, void *data)
 	    request->flags.accelerated = http->flags.accel;
 	    if (!http->flags.internal) {
 		if (internalCheck(strBuf(request->urlpath))) {
-		    if (0 == strcasecmp(request->host, internalHostname())) {
-			if (request->port == Config.Port.http->i)
-			    http->flags.internal = 1;
+		    if (0 == strcasecmp(request->host, internalHostname()) &&
+			request->port == Config.Port.http->i) {
+			http->flags.internal = 1;
 		    } else if (internalStaticCheck(strBuf(request->urlpath))) {
 			xstrncpy(request->host, internalHostname(), SQUIDHOSTNAMELEN);
 			request->port = Config.Port.http->i;
@@ -2512,6 +2531,7 @@ httpAccept(int sock, void *data)
 	commSetTimeout(fd, Config.Timeout.request, requestTimeout, connState);
 #if USE_IDENT
 	identChecklist.src_addr = peer.sin_addr;
+	identChecklist.my_addr = me.sin_addr;
 	if (aclCheckFast(Config.accessList.identLookup, &identChecklist))
 	    identStart(&me, &peer, clientIdentDone, connState);
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: debug.cc,v 1.74 1999/01/11 21:55:38 wessels Exp $
+ * $Id: debug.cc,v 1.75 1999/04/15 06:15:51 wessels Exp $
  *
  * DEBUG: section 0     Debug Routines
  * AUTHOR: Harvest Derived
@@ -115,7 +115,6 @@ debugArg(const char *arg)
     int s = 0;
     int l = 0;
     int i;
-
     if (!strncasecmp(arg, "ALL", 3)) {
 	s = -1;
 	arg += 4;
@@ -124,7 +123,12 @@ debugArg(const char *arg)
 	while (*arg && *arg++ != ',');
     }
     l = atoi(arg);
-
+    assert(s >= -1);
+    assert(s < MAX_DEBUG_SECTIONS);
+    if (l < 0)
+	l = 0;
+    if (l > 10)
+	l = 10;
     if (s >= 0) {
 	debugLevels[s] = l;
 	return;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: defines.h,v 1.71 1999/02/02 23:57:22 wessels Exp $
+ * $Id: defines.h,v 1.72 1999/04/15 06:15:52 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -201,7 +201,7 @@
 #define SwapMetaType(x) (char)x[0]
 #define SwapMetaSize(x) &x[sizeof(char)]
 #define SwapMetaData(x) &x[STORE_META_TLD_START]
-#define STORE_HDR_METASIZE (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(int))
+#define STORE_HDR_METASIZE (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(size_t))
 
 #define STORE_ENTRY_WITH_MEMOBJ		1
 #define STORE_ENTRY_WITHOUT_MEMOBJ	0
@@ -1,6 +1,6 @@
 
 /*
- * $Id: delay_pools.cc,v 1.7 1999/01/29 23:39:17 wessels Exp $
+ * $Id: delay_pools.cc,v 1.8 1999/04/15 06:15:52 wessels Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: David Luyer <luyer@ucs.uwa.edu.au>
@@ -83,9 +83,40 @@ typedef union _delayPool delayPool;
 static delayPool *delay_data = NULL;
 static fd_set delay_no_delay;
 static time_t delay_pools_last_update = 0;
+static hash_table *delay_id_ptr_hash = NULL;
 
 static OBJH delayPoolStats;
 
+static unsigned int
+delayIdPtrHash(const void *key, unsigned int n)
+{
+    /* Hashes actual POINTER VALUE.
+     * Assumes <= 256 hash buckets & even hash size.
+     * Assumes the most variation in pointers to inside
+     * medium size objects occurs in the 2nd and 3rd
+     * least significant bytes.
+     */
+    const char *ptr = (char *) &key;
+#if SIZEOF_VOID_P == 4
+    return (ptr[1] ^ ptr[2]) & (n - 1);
+#elif SIZEOF_VOID_P == 8
+#if WORDS_BIGENDIAN
+    return (ptr[5] ^ ptr[6]) & (n - 1);
+#else
+    return (ptr[1] ^ ptr[2]) & (n - 1);
+#endif
+#else
+#error What kind of a sick architecture are you on anyway?
+#endif
+}
+
+static int
+delayIdPtrHashCmp(const void *a, const void *b)
+{
+    /* Sort by POINTER VALUE. */
+    return b - a;
+}
+
 void
 delayPoolsInit(void)
 {
@@ -97,16 +128,61 @@ delayPoolsInit(void)
 void
 delayInitDelayData(unsigned short pools)
 {
-    if (pools) {
-	delay_data = xcalloc(pools, sizeof(delayPool));
-	eventAdd("delayPoolsUpdate", delayPoolsUpdate, NULL, 1.0, 1);
-    }
+    if (!pools)
+	return;
+    delay_data = xcalloc(pools, sizeof(delayPool));
+    eventAdd("delayPoolsUpdate", delayPoolsUpdate, NULL, 1.0, 1);
+    delay_id_ptr_hash = hash_create(delayIdPtrHashCmp, 256, delayIdPtrHash);
+}
+
+static void
+delayIdZero(void *hlink)
+{
+    hash_link *h = hlink;
+    delay_id *id = (delay_id *) h->key;
+    *id = 0;
+    xfree(h);
 }
 
 void
 delayFreeDelayData()
 {
     safe_free(delay_data);
+    if (!delay_id_ptr_hash)
+	return;
+    hashFreeItems(delay_id_ptr_hash, delayIdZero);
+    hashFreeMemory(delay_id_ptr_hash);
+    delay_id_ptr_hash = NULL;
+}
+
+void
+delayRegisterDelayIdPtr(delay_id * loc)
+{
+    hash_link *lnk;
+    if (!delay_id_ptr_hash)
+	return;
+    lnk = xmalloc(sizeof(hash_link));
+    lnk->key = (char *) loc;
+    hash_join(delay_id_ptr_hash, lnk);
+}
+
+void
+delayUnregisterDelayIdPtr(delay_id * loc)
+{
+    hash_link *lnk;
+    if (!delay_id_ptr_hash)
+	return;
+    /*
+     * If we went through a reconfigure, then all the delay_id's
+     * got set to zero, and they were removed from our hash
+     * table.
+     */
+    if (*loc == 0)
+	return;
+    lnk = hash_lookup(delay_id_ptr_hash, loc);
+    assert(lnk);
+    hash_remove_link(delay_id_ptr_hash, lnk);
+    xxfree(lnk);
 }
 
 void
@@ -189,7 +265,7 @@ delayId(unsigned short pool, unsigned short position)
 }
 
 delay_id
-delayClient(request_t *r)
+delayClient(request_t * r)
 {
     aclCheck_t ch;
     int i;
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: disk.cc,v 1.141 1999/01/29 17:33:05 wessels Exp $
+ * $Id: disk.cc,v 1.142 1999/04/15 06:15:53 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -75,6 +75,7 @@ file_open(const char *path, int mode, FOCB * callback, void *callback_data, void
     mode |= SQUID_NONBLOCK;
 
     /* Open file */
+    Opening_FD++;
 #if USE_ASYNC_IO
     if (callback != NULL) {
 	aioOpen(path, mode, 0644, fileOpenComplete, ctrlp, tag);
@@ -97,6 +98,7 @@ fileOpenComplete(int unused, void *data, int fd, int errcode)
     debug(6, 5) ("fileOpenComplete: FD %d, data %p, errcode %d\n",
 	fd, data, errcode);
     Counter.syscalls.disk.opens++;
+    Opening_FD--;
     if (fd == -2 && errcode == -2) {	/* Cancelled - clean up */
 	if (ctrlp->callback)
 	    (ctrlp->callback) (ctrlp->callback_data, fd, errcode);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.147 1999/04/14 05:16:15 wessels Exp $
+ * $Id: enums.h,v 1.148 1999/04/15 06:15:54 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -81,6 +81,9 @@ typedef enum {
     ERR_FTP_PUT_CREATED,	/* !error,a note that the file was created */
     ERR_FTP_PUT_MODIFIED,	/* modified, !created */
     ERR_FTP_PUT_ERROR,
+    ERR_FTP_NOT_FOUND,
+    ERR_FTP_FORBIDDEN,
+    ERR_FTP_UNAVAILABLE,
     ERR_ONLY_IF_CACHED_MISS,	/* failure to satisfy only-if-cached request */
     ERR_MAX
 } err_type;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fd.cc,v 1.35 1999/01/21 21:13:01 wessels Exp $
+ * $Id: fd.cc,v 1.36 1999/04/15 06:15:54 wessels Exp $
  *
  * DEBUG: section 51    Filedescriptor Functions
  * AUTHOR: Duane Wessels
@@ -173,7 +173,7 @@ fdDumpOpen(void)
 int
 fdNFree(void)
 {
-    return Squid_MaxFD - Number_FD;
+    return Squid_MaxFD - Number_FD - Opening_FD;
 }
 
 /* Called when we runs out of file descriptors */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.55 1999/04/07 21:17:50 wessels Exp $
+ * $Id: forward.cc,v 1.56 1999/04/15 06:15:55 wessels Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -367,18 +367,7 @@ fwdReforward(FwdState * fwdState)
     }
     s = e->mem_obj->reply->sline.status;
     debug(17, 3) ("fwdReforward: status %d\n", (int) s);
-    switch (s) {
-    case HTTP_FORBIDDEN:
-    case HTTP_INTERNAL_SERVER_ERROR:
-    case HTTP_NOT_IMPLEMENTED:
-    case HTTP_BAD_GATEWAY:
-    case HTTP_SERVICE_UNAVAILABLE:
-    case HTTP_GATEWAY_TIMEOUT:
-	return 1;
-    default:
-	return 0;
-    }
-    /* NOTREACHED */
+    return fwdReforwardableStatus(s);
 }
 
 /* PUBLIC FUNCTIONS */
@@ -465,6 +454,8 @@ fwdCheckDeferRead(int fd, void *data)
 	    if (delayMostBytesWanted(mem, 1) == 0)
 		return 1;
 #endif
+    if (EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT))
+	return 0;
     if (mem->inmem_hi - storeLowestMemReaderOffset(e) < READ_AHEAD_GAP)
 	return 0;
     return 1;
@@ -583,3 +574,20 @@ fwdStats(StoreEntry * s)
 	storeAppendPrintf(s, "\n");
     }
 }
+
+int
+fwdReforwardableStatus(http_status s)
+{
+    switch (s) {
+    case HTTP_FORBIDDEN:
+    case HTTP_INTERNAL_SERVER_ERROR:
+    case HTTP_NOT_IMPLEMENTED:
+    case HTTP_BAD_GATEWAY:
+    case HTTP_SERVICE_UNAVAILABLE:
+    case HTTP_GATEWAY_TIMEOUT:
+	return 1;
+    default:
+	return 0;
+    }
+    /* NOTREACHED */
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.280 1999/02/06 08:44:13 wessels Exp $
+ * $Id: ftp.cc,v 1.281 1999/04/15 06:15:56 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -147,6 +147,7 @@ typedef void (FTPSM) (FtpStateData *);
 static CNCB ftpPasvCallback;
 static PF ftpDataRead;
 static PF ftpStateFree;
+static PF ftpPumpClosedData;
 static PF ftpTimeout;
 static PF ftpReadControlReply;
 static CWCB ftpWriteCommandCallback;
@@ -481,7 +482,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
 	tokens[n_tokens++] = xstrdup(t);
     xfree(xbuf);
     /* locate the Month field */
-    for (i = 3; i < n_tokens - 3; i++) {
+    for (i = 3; i < n_tokens - 2; i++) {
 	if (!is_month(tokens[i]))	/* Month */
 	    continue;
 	if (!sscanf(tokens[i - 1], SCAN_FTP1, sbuf))	/* Size */
@@ -535,7 +536,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
 	    /* Directory.. name begins with first printable after <dir> */
 	    ct = strstr(buf, tokens[2]);
 	    ct += strlen(tokens[2]);
-	    while (isspace(*ct))
+	    while (xisspace(*ct))
 		ct++;
 	    if (!*ct)
 		ct = NULL;
@@ -666,8 +667,8 @@ ftpHtmlifyListEntry(char *line, FtpStateData * ftpState)
     if ((parts = ftpListParseParts(line, ftpState->flags)) == NULL) {
 	char *p;
 	snprintf(html, 8192, "%s\n", line);
-	for (p = line; *p && isspace(*p); p++);
-	if (*p && !isspace(*p))
+	for (p = line; *p && xisspace(*p); p++);
+	if (*p && !xisspace(*p))
 	    ftpState->flags.listformat_unknown = 1;
 	return html;
     }
@@ -2227,7 +2228,26 @@ ftpFail(FtpStateData * ftpState)
 	    break;
 	}
     }
-    err = errorCon(ERR_FTP_FAILURE, HTTP_INTERNAL_SERVER_ERROR);
+    /* Translate FTP errors into HTTP errors */
+    err = NULL;
+    switch (ftpState->state) {
+    case SENT_USER:
+    case SENT_PASS:
+	if (ftpState->ctrl.replycode > 500)
+	    err = errorCon(ERR_FTP_FORBIDDEN, HTTP_FORBIDDEN);
+	else if (ftpState->ctrl.replycode == 421)
+	    err = errorCon(ERR_FTP_UNAVAILABLE, HTTP_SERVICE_UNAVAILABLE);
+	break;
+    case SENT_CWD:
+    case SENT_RETR:
+	if (ftpState->ctrl.replycode == 550)
+	    err = errorCon(ERR_FTP_NOT_FOUND, HTTP_NOT_FOUND);
+	break;
+    default:
+	break;
+    }
+    if (err == NULL)
+	err = errorCon(ERR_FTP_FAILURE, HTTP_BAD_GATEWAY);
     err->request = requestLink(ftpState->request);
     err->ftp_server_msg = ftpState->ctrl.message;
     if (ftpState->old_request)
@@ -2246,10 +2266,33 @@ ftpFail(FtpStateData * ftpState)
     comm_close(ftpState->ctrl.fd);
 }
 
+void
+ftpPumpClosedData(int data_fd, void *data)
+{
+    FtpStateData *ftpState = data;
+    assert(data_fd == ftpState->data.fd);
+    /*
+     * Ugly pump module closed our server-side.  Deal with it.
+     * The data FD is already closed, so just set it to -1.
+     */
+    ftpState->data.fd = -1;
+    /*
+     * Currently, thats all we have to do.  Because the upload failed,
+     * storeAbort() will be called on the reply entry.  That will
+     * call fwdAbort, which closes ftpState->ctrl.fd and then
+     * ftpStateFree gets called.
+     */
+}
+
 static void
 ftpPutStart(FtpStateData * ftpState)
 {
     debug(9, 3) ("ftpPutStart\n");
+    /*
+     * sigh, we need this gross hack to detect when ugly pump module
+     * aborts and wants to close the server-side.
+     */
+    comm_add_close_handler(ftpState->data.fd, ftpPumpClosedData, ftpState);
     pumpStart(ftpState->data.fd, ftpState->fwd, ftpPutTransferDone, ftpState);
 }
 
@@ -2258,6 +2301,7 @@ ftpPutTransferDone(int fd, char *bufnotused, size_t size, int errflag, void *dat
 {
     FtpStateData *ftpState = data;
     if (ftpState->data.fd >= 0) {
+	comm_remove_close_handler(fd, ftpPumpClosedData, ftpState);
 	comm_close(ftpState->data.fd);
 	ftpState->data.fd = -1;
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.76 1999/01/21 21:10:33 wessels Exp $
+ * $Id: globals.h,v 1.77 1999/04/15 06:15:57 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -66,6 +66,7 @@ extern dnsStatData DnsStats;
 extern fde *fd_table;		/* NULL */
 extern int Biggest_FD;		/* -1 */
 extern int Number_FD;		/* 0 */
+extern int Opening_FD;		/* 0 */
 extern int HttpSockets[MAXHTTPPORTS];
 extern int NDnsServersAlloc;	/* 0 */
 extern int NHttpSockets;	/* 0 */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.346 1999/01/29 23:39:19 wessels Exp $
+ * $Id: http.cc,v 1.347 1999/04/15 06:15:58 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -42,13 +42,12 @@
 
 static const char *const crlf = "\r\n";
 
-static CNCB httpConnectDone;
 static CWCB httpSendComplete;
 static CWCB httpSendRequestEntry;
 static CWCB httpSendRequestEntryDone;
 
 static PF httpReadReply;
-static PF httpSendRequest;
+static void httpSendRequest(HttpStateData *);
 static PF httpStateFree;
 static PF httpTimeout;
 static void httpCacheNegatively(StoreEntry *);
@@ -385,6 +384,15 @@ httpPconnTransferDone(HttpStateData * httpState)
     /*
      * What does the reply have to say about keep-alive?
      */
+    /*
+     * XXX BUG?
+     * If the origin server (HTTP/1.0) does not send a keep-alive
+     * header, but keeps the connection open anyway, what happens?
+     * We'll return here and http.c waits for an EOF before changing
+     * store_status to STORE_OK.   Combine this with ENTRY_FWD_HDR_WAIT
+     * and an error status code, and we might have to wait until
+     * the server times out the socket.
+     */
     if (!reply->keep_alive)
 	return 0;
     debug(11, 5) ("httpPconnTransferDone: content_length=%d\n",
@@ -476,7 +484,7 @@ httpReadReply(int fd, void *data)
     }
     if (!httpState->reply_hdr && len > 0) {
 	/* Skip whitespace */
-	while (len > 0 && isspace(*buf))
+	while (len > 0 && xisspace(*buf))
 	    xmemmove(buf, buf + 1, len--);
 	if (len == 0) {
 	    /* Continue to read... */
@@ -523,10 +531,11 @@ httpReadReply(int fd, void *data)
 	    httpProcessReplyHeader(httpState, buf, len);
 	    if (httpState->reply_hdr_state == 2) {
 		http_status s = entry->mem_obj->reply->sline.status;
-		/* If its "successful" reply, allow the client
-		 * to get it
+		/*
+		 * If its not a reply that we will re-forward, then
+		 * allow the client to get it.
 		 */
-		if (s >= 200 && s < 300)
+		if (!fwdReforwardableStatus(s))
 		    EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
 	    }
 	}
@@ -582,10 +591,16 @@ httpSendComplete(int fd, char *bufnotused, size_t size, int errflag, void *data)
 	return;
     } else {
 	/* Schedule read reply. */
-	commSetSelect(fd,
-	    COMM_SELECT_READ,
-	    httpReadReply,
-	    httpState, 0);
+	commSetSelect(fd, COMM_SELECT_READ, httpReadReply, httpState, 0);
+	/*
+	 * Set the read timeout here because it hasn't been set yet.
+	 * We only set the read timeout after the request has been
+	 * fully written to the server-side.  If we start the timeout
+	 * after connection establishment, then we are likely to hit
+	 * the timeout for POST/PUT requests that have very large
+	 * request bodies.
+	 */
+	commSetTimeout(fd, Config.Timeout.read, httpTimeout, httpState);
 	commSetDefer(fd, fwdCheckDeferRead, entry);
     }
 }
@@ -789,17 +804,16 @@ httpBuildRequestPrefix(request_t * request,
 }
 /* This will be called when connect completes. Write request. */
 static void
-httpSendRequest(int fd, void *data)
+httpSendRequest(HttpStateData * httpState)
 {
-    HttpStateData *httpState = data;
     MemBuf mb;
     request_t *req = httpState->request;
     StoreEntry *entry = httpState->entry;
     int cfd;
     peer *p = httpState->peer;
     CWCB *sendHeaderDone;
 
-    debug(11, 5) ("httpSendRequest: FD %d: httpState %p.\n", fd, httpState);
+    debug(11, 5) ("httpSendRequest: FD %d: httpState %p.\n", httpState->fd, httpState);
 
     if (pumpMethod(req->method))
 	sendHeaderDone = httpSendRequestEntry;
@@ -834,9 +848,10 @@ httpSendRequest(int fd, void *data)
 	&mb,
 	cfd,
 	httpState->flags);
-    debug(11, 6) ("httpSendRequest: FD %d:\n%s\n", fd, mb.buf);
-    comm_write_mbuf(fd, mb, sendHeaderDone, httpState);
+    debug(11, 6) ("httpSendRequest: FD %d:\n%s\n", httpState->fd, mb.buf);
+    comm_write_mbuf(httpState->fd, mb, sendHeaderDone, httpState);
 }
+
 void
 httpStart(FwdState * fwd)
 {
@@ -886,37 +901,12 @@ httpStart(FwdState * fwd)
     comm_add_close_handler(fd, httpStateFree, httpState);
     Counter.server.all.requests++;
     Counter.server.http.requests++;
-    httpConnectDone(fd, COMM_OK, httpState);
-}
-
-static void
-httpConnectDone(int fd, int status, void *data)
-{
-    HttpStateData *httpState = data;
-    request_t *request = httpState->request;
-    StoreEntry *entry = httpState->entry;
-    ErrorState *err;
-    if (status == COMM_ERR_DNS) {
-	debug(11, 4) ("httpConnectDone: Unknown host: %s\n", request->host);
-	err = errorCon(ERR_DNS_FAIL, HTTP_SERVICE_UNAVAILABLE);
-	err->dnsserver_msg = xstrdup(dns_error_message);
-	err->request = requestLink(httpState->orig_request);
-	errorAppendEntry(entry, err);
-	comm_close(fd);
-    } else if (status != COMM_OK) {
-	err = errorCon(ERR_CONNECT_FAIL, HTTP_SERVICE_UNAVAILABLE);
-	err->xerrno = errno;
-	err->host = xstrdup(request->host);
-	err->port = request->port;
-	err->request = requestLink(httpState->orig_request);
-	errorAppendEntry(entry, err);
-	if (httpState->peer)
-	    peerCheckConnectStart(httpState->peer);
-	comm_close(fd);
-    } else {
-	commSetSelect(fd, COMM_SELECT_WRITE, httpSendRequest, httpState, 0);
-	commSetTimeout(fd, Config.Timeout.read, httpTimeout, httpState);
-    }
+    httpSendRequest(httpState);
+    /*
+     * We used to set the read timeout here, but not any more.
+     * Now its set in httpSendComplete() after the full request,
+     * including request body, has been written to the server.
+     */
 }
 
 static void
@@ -942,6 +932,10 @@ httpSendRequestEntry(int fd, char *bufnotused, size_t size, int errflag, void *d
 	comm_close(fd);
 	return;
     }
+    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
+	comm_close(fd);
+	return;
+    }
     pumpStart(fd, httpState->fwd, httpSendRequestEntryDone, httpState);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ident.cc,v 1.49 1999/01/24 05:24:22 wessels Exp $
+ * $Id: ident.cc,v 1.50 1999/04/15 06:15:59 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -159,7 +159,7 @@ identReadReply(int fd, void *data)
     debug(30, 5) ("identReadReply: FD %d: Read '%s'\n", fd, buf);
     if (strstr(buf, "USERID")) {
 	if ((ident = strrchr(buf, ':'))) {
-	    while (isspace(*++ident));
+	    while (xisspace(*++ident));
 	    identCallback(state, ident);
 	}
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.291 1999/04/14 05:16:17 wessels Exp $
+ * $Id: main.cc,v 1.292 1999/04/15 06:16:00 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -70,6 +70,7 @@ extern void log_trace_done();
 extern void log_trace_init(char *);
 #endif
 static EVH SquidShutdown;
+static void mainSetCwd(void);
 
 static void
 usage(void)
@@ -375,6 +376,34 @@ setEffectiveUser(void)
     }
 }
 
+static void
+mainSetCwd(void)
+{
+    if (Config.coredump_dir) {
+	if (!chdir(Config.coredump_dir)) {
+	    debug(0, 1) ("Set Current Directory to %s\n", Config.coredump_dir);
+	    return;
+	} else {
+	    debug(50, 0) ("chdir: %s: %s\n", Config.coredump_dir, xstrerror());
+	}
+    }
+    if (!Config.effectiveUser) {
+	char *p = getcwd(NULL, 0);
+	debug(0, 1) ("Current Directory is %s\n", p);
+	xfree(p);
+	return;
+    }
+    /* we were probably started as root, so cd to a swap
+     * directory in case we dump core */
+    if (!chdir(storeSwapDir(0))) {
+	debug(0, 1) ("Set Current Directory to %s\n", storeSwapDir(0));
+	return;
+    } else {
+	debug(50, 0) ("%s: %s\n", storeSwapDir(0), xstrerror());
+	fatal_dump("Cannot cd to swap directory?");
+    }
+}
+
 static void
 mainInitialize(void)
 {
@@ -433,14 +462,7 @@ mainInitialize(void)
 	cachemgrInit();
 	statInit();
 	storeInit();
-	if (Config.effectiveUser) {
-	    /* we were probably started as root, so cd to a swap
-	     * directory in case we dump core */
-	    if (chdir(storeSwapDir(0)) < 0) {
-		debug(50, 0) ("%s: %s\n", storeSwapDir(0), xstrerror());
-		fatal_dump("Cannot cd to swap directory?");
-	    }
-	}
+	mainSetCwd();
 	/* after this point we want to see the mallinfo() output */
 	do_mallinfo = 1;
 	mimeInit(Config.mimeTablePathname);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.84 1998/12/05 00:54:32 wessels Exp $
+ * $Id: mime.cc,v 1.85 1999/04/15 06:16:01 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -84,11 +84,11 @@ mime_get_header_field(const char *mime, const char *name, const char *prefix)
     for (p = mime; *p; p += strcspn(p, "\n\r")) {
 	if (strcmp(p, "\r\n\r\n") == 0 || strcmp(p, "\n\n") == 0)
 	    return NULL;
-	while (isspace(*p))
+	while (xisspace(*p))
 	    p++;
 	if (strncasecmp(p, name, namelen))
 	    continue;
-	if (!isspace(p[namelen]) && p[namelen] != ':')
+	if (!xisspace(p[namelen]) && p[namelen] != ':')
 	    continue;
 	l = strcspn(p, "\n\r") + 1;
 	if (l > GET_HDR_SZ)
@@ -99,12 +99,12 @@ mime_get_header_field(const char *mime, const char *name, const char *prefix)
 	q += namelen;
 	if (*q == ':')
 	    q++, got = 1;
-	while (isspace(*q))
+	while (xisspace(*q))
 	    q++, got = 1;
 	if (got && prefix) {
 	    /* we could process list entries here if we had strcasestr(). */
 	    /* make sure we did not match a part of another field-value */
-	    got = !strncasecmp(q, prefix, preflen) && !isalpha(q[preflen]);
+	    got = !strncasecmp(q, prefix, preflen) && !xisalpha(q[preflen]);
 	}
 	if (got) {
 	    debug(25, 5) ("mime_get_header: returning '%s'\n", q);
@@ -393,6 +393,7 @@ mimeLoadIconFile(const char *icon)
     LOCAL_ARRAY(char, url, MAX_URL);
     char *buf;
     const char *type = mimeGetContentType(icon);
+    HttpReply *reply;
     if (type == NULL)
 	fatal("Unknown icon format while reading mime.conf\n");
     buf = internalLocalUri("/squid-internal-static/icons/", icon);
@@ -418,10 +419,13 @@ mimeLoadIconFile(const char *icon)
     assert(e != NULL);
     storeSetPublicKey(e);
     e->mem_obj->request = requestLink(urlParse(METHOD_GET, url));
-    httpReplyReset(e->mem_obj->reply);
-    httpReplySetHeaders(e->mem_obj->reply, 1.0, HTTP_OK, NULL,
-	type, (int) sb.st_size, sb.st_mtime, squid_curtime + 86400);
-    httpReplySwapOut(e->mem_obj->reply, e);
+    httpReplyReset(reply = e->mem_obj->reply);
+    httpReplySetHeaders(reply, 1.0, HTTP_OK, NULL,
+	type, (int) sb.st_size, sb.st_mtime, -1);
+    reply->cache_control = httpHdrCcCreate();
+    httpHdrCcSetMaxAge(reply->cache_control, 86400);
+    httpHeaderPutCc(&reply->header, reply->cache_control);
+    httpReplySwapOut(reply, e);
     /* read the file into the buffer and append it to store */
     buf = memAllocate(MEM_4K_BUF);
     while ((n = read(fd, buf, 4096)) > 0)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.270 1999/01/29 23:01:06 wessels Exp $
+ * $Id: neighbors.cc,v 1.271 1999/04/15 06:16:03 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -132,17 +132,17 @@ peerAllowedToUse(const peer * p, request_t * request)
 	if (request->flags.need_validation)
 	    return 0;
     }
-    if (p->pinglist == NULL && p->access == NULL)
+    if (p->peer_domain == NULL && p->access == NULL)
 	return do_ping;
     do_ping = 0;
-    for (d = p->pinglist; d; d = d->next) {
+    for (d = p->peer_domain; d; d = d->next) {
 	if (matchDomainName(d->domain, request->host)) {
 	    do_ping = d->do_ping;
 	    break;
 	}
 	do_ping = !d->do_ping;
     }
-    if (p->pinglist && 0 == do_ping)
+    if (p->peer_domain && 0 == do_ping)
 	return do_ping;
     if (p->access == NULL)
 	return do_ping;
@@ -318,7 +318,7 @@ neighborRemove(peer * target)
     }
     if (p) {
 	*P = p->next;
-	cbdataUnlock(p);
+	cbdataFree(p);
 	Config.npeers--;
     }
     first_ping = Config.peers;
@@ -888,15 +888,18 @@ peerDestroy(void *data, int unused)
     struct _domain_ping *nl = NULL;
     if (p == NULL)
 	return;
-    for (l = p->pinglist; l; l = nl) {
+    for (l = p->peer_domain; l; l = nl) {
 	nl = l->next;
 	safe_free(l->domain);
 	safe_free(l);
     }
     safe_free(p->host);
 #if USE_CACHE_DIGESTS
-    /* it should be set NULL in free_peer() */
-    assert(p->digest == NULL);
+    if (p->digest) {
+	PeerDigest *pd = p->digest;
+	p->digest = NULL;
+	cbdataUnlock(pd);
+    }
 #endif
     xfree(p);
 }
@@ -1230,9 +1233,9 @@ dump_peers(StoreEntry * sentry, peer * peers)
 	    storeAppendPrintf(sentry, "Last failed connect() at: %s\n",
 		mkhttpdlogtime(&(e->last_fail_time)));
 	}
-	if (e->pinglist != NULL) {
+	if (e->peer_domain != NULL) {
 	    storeAppendPrintf(sentry, "DOMAIN LIST: ");
-	    for (d = e->pinglist; d; d = d->next) {
+	    for (d = e->peer_domain; d; d = d->next) {
 		storeAppendPrintf(sentry, "%s%s ",
 		    d->do_ping ? null_string : "!", d->domain);
 	    }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.136 1999/01/29 21:28:16 wessels Exp $
+ * $Id: net_db.cc,v 1.137 1999/04/15 06:16:04 wessels Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -668,6 +668,8 @@ netdbHandlePingReply(const struct sockaddr_in *from, int hops, int rtt)
     N = ++n->pings_recv;
     if (N > 5)
 	N = 5;
+    if (rtt < 1.0)
+	rtt = 1.0;
     n->hops = ((n->hops * (N - 1)) + hops) / N;
     n->rtt = ((n->rtt * (N - 1)) + rtt) / N;
     debug(38, 3) ("netdbHandlePingReply: %s; rtt=%5.1f  hops=%4.1f\n",
@@ -1,6 +1,6 @@
 
 /*
- * $Id: pinger.cc,v 1.39 1998/11/21 16:54:28 wessels Exp $
+ * $Id: pinger.cc,v 1.40 1999/04/15 06:16:05 wessels Exp $
  *
  * DEBUG: section 42    ICMP Pinger program
  * AUTHOR: Duane Wessels
@@ -152,6 +152,14 @@ pingerSendEcho(struct in_addr to, int opcode, char *payload, int len)
     struct sockaddr_in S;
     memset(pkt, '\0', MAX_PKT_SZ);
     icmp = (struct icmphdr *) (void *) pkt;
+
+    /*
+     * cevans - beware signed/unsigned issues in untrusted data from
+     * the network!!
+     */
+    if (len < 0) {
+	len = 0;
+    }
     icmp->icmp_type = ICMP_ECHO;
     icmp->icmp_code = 0;
     icmp->icmp_cksum = 0;
@@ -169,6 +177,9 @@ pingerSendEcho(struct in_addr to, int opcode, char *payload, int len)
     }
     icmp->icmp_cksum = in_cksum((u_short *) icmp, icmp_pktsize);
     S.sin_family = AF_INET;
+    /*
+     * cevans: alert: trusting to-host, was supplied in network packet
+     */
     S.sin_addr = to;
     S.sin_port = 0;
     assert(icmp_pktsize <= MAX_PKT_SZ);
@@ -294,9 +305,12 @@ pingerReadRequest(void)
     if (n < 0)
 	return n;
     guess_size = n - (sizeof(pingerEchoData) - PINGER_PAYLOAD_SZ);
-    if (guess_size != pecho.psize)
+    if (guess_size != pecho.psize) {
 	fprintf(stderr, "size mismatch, guess=%d psize=%d\n",
 	    guess_size, pecho.psize);
+	errno = 0;
+	return -1;
+    }
     pingerSendEcho(pecho.to,
 	pecho.opcode,
 	pecho.payload,
@@ -336,12 +350,19 @@ main(int argc, char *argv[])
     char *t;
     time_t last_check_time = 0;
 
+/*
+ * cevans - do this first. It grabs a raw socket. After this we can
+ * drop privs
+ */
+    pingerOpen();
+    setgid(getgid());
+    setuid(getuid());
+
     if ((t = getenv("SQUID_DEBUG")))
 	debug_args = xstrdup(t);
     getCurrentTime();
     _db_init(NULL, debug_args);
 
-    pingerOpen();
     for (;;) {
 	tv.tv_sec = 10;
 	tv.tv_usec = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.316 1999/04/14 05:16:18 wessels Exp $
+ * $Id: protos.h,v 1.317 1999/04/15 06:16:06 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -503,17 +503,18 @@ extern void snmpConnectionClose(void);
 extern void snmpDebugOid(int lvl, oid * Name, snint Len);
 extern void addr2oid(struct in_addr addr, oid * Dest);
 extern struct in_addr *oid2addr(oid * id);
-variable_list *snmp_basicFn(variable_list *, snint *);
-variable_list *snmp_confFn(variable_list *, snint *);
-variable_list *snmp_sysFn(variable_list *, snint *);
-variable_list *snmp_prfSysFn(variable_list *, snint *);
-variable_list *snmp_prfProtoFn(variable_list *, snint *);
-variable_list *snmp_prfPeerFn(variable_list *, snint *);
-variable_list *snmp_netIpFn(variable_list *, snint *);
-variable_list *snmp_netFqdnFn(variable_list *, snint *);
-variable_list *snmp_netDnsFn(variable_list *, snint *);
-variable_list *snmp_meshPtblFn(variable_list *, snint *);
-variable_list *snmp_meshCtblFn(variable_list *, snint *);
+extern struct in_addr *client_entry(struct in_addr *current);
+extern variable_list *snmp_basicFn(variable_list *, snint *);
+extern variable_list *snmp_confFn(variable_list *, snint *);
+extern variable_list *snmp_sysFn(variable_list *, snint *);
+extern variable_list *snmp_prfSysFn(variable_list *, snint *);
+extern variable_list *snmp_prfProtoFn(variable_list *, snint *);
+extern variable_list *snmp_prfPeerFn(variable_list *, snint *);
+extern variable_list *snmp_netIpFn(variable_list *, snint *);
+extern variable_list *snmp_netFqdnFn(variable_list *, snint *);
+extern variable_list *snmp_netDnsFn(variable_list *, snint *);
+extern variable_list *snmp_meshPtblFn(variable_list *, snint *);
+extern variable_list *snmp_meshCtblFn(variable_list *, snint *);
 #endif /* SQUID_SNMP */
 
 extern void icpHandleIcpV3(int, struct sockaddr_in, char *, int);
@@ -665,6 +666,7 @@ extern void fwdFail(FwdState *, ErrorState *);
 extern void fwdUnregister(int fd, FwdState *);
 extern void fwdComplete(FwdState * fwdState);
 extern void fwdInit(void);
+extern int fwdReforwardableStatus(http_status s);
 
 extern void urnStart(request_t *, StoreEntry *);
 
@@ -1127,6 +1129,8 @@ extern void delayBytesIn(delay_id, int qty);
 extern int delayMostBytesWanted(const MemObject * mem, int max);
 extern delay_id delayMostBytesAllowed(const MemObject * mem);
 extern void delaySetStoreClient(StoreEntry * e, void *data, delay_id delay_id);
+void delayRegisterDelayIdPtr(delay_id * loc);
+void delayUnregisterDelayIdPtr(delay_id * loc);
 #endif
 
 /* helper.c */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: snmp_agent.cc,v 1.65 1999/01/26 06:16:33 glenn Exp $
+ * $Id: snmp_agent.cc,v 1.66 1999/04/15 06:16:07 wessels Exp $
  *
  * DEBUG: section 49     SNMP Interface
  * AUTHOR: Kostas Anagnostakis
@@ -177,13 +177,6 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
 	if (p->in_addr.sin_addr.s_addr == laddr->s_addr)
 	    break;
 
-#if SNMP_OLD_INDEX
-    p = Config.peers;
-    cnt = Var->name[LEN_SQ_MESH + 3];
-    debug(49, 5) ("snmp_meshPtblFn: we want .x.%d\n", Var->name[10]);
-    while (--cnt)
-	if (!(p = p->next));
-#endif
     if (p == NULL) {
 	*ErrP = SNMP_ERR_NOSUCHNAME;
 	snmp_var_free(Answer);
@@ -478,26 +471,3 @@ snmp_prfProtoFn(variable_list * Var, snint * ErrP)
     snmp_var_free(Answer);
     return (NULL);
 }
-
-void
-addr2oid(struct in_addr addr, oid * Dest)
-{
-    u_char *cp;
-    cp = (u_char *) & (addr.s_addr);
-    Dest[0] = *cp++;
-    Dest[1] = *cp++;
-    Dest[2] = *cp++;
-    Dest[3] = *cp++;
-}
-
-struct in_addr *
-oid2addr(oid * id)
-{
-    static struct in_addr laddr;
-    u_char *cp = (u_char *) & (laddr.s_addr);
-    cp[0] = id[0];
-    cp[1] = id[1];
-    cp[2] = id[2];
-    cp[3] = id[3];
-    return &laddr;
-}
@@ -1,5 +1,6 @@
+
 /*
- * $Id: snmp_core.cc,v 1.34 1999/01/30 01:05:09 wessels Exp $
+ * $Id: snmp_core.cc,v 1.35 1999/04/15 06:16:08 wessels Exp $
  *
  * DEBUG: section 49    SNMP support
  * AUTHOR: Glenn Chisholm
@@ -37,27 +38,34 @@
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
 
+typedef struct _mib_tree_entry mib_tree_entry;
+typedef oid *(instance_Fn) (oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
+
 struct _mib_tree_entry {
     oid *name;
     int len;
     oid_ParseFn *parsefunction;
+    instance_Fn *instancefunction;
     int children;
     struct _mib_tree_entry **leaves;
     struct _mib_tree_entry *parent;
 };
 
-typedef struct _mib_tree_entry mib_tree_entry;
-
 mib_tree_entry *mib_tree_head;
+mib_tree_entry *mib_tree_last;
 
 #if STDC_HEADERS
-static mib_tree_entry *snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, int children,...);
+static mib_tree_entry *snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, instance_Fn * instancefunction, int children,...);
 static oid *snmpCreateOid(int length,...);
 #else
 static mib_tree_entry *snmpAddNode();
 static oid *snmpCreateOid();
 #endif
 extern void (*snmplib_debug_hook) (int, char *);
+static oid *static_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
+static oid *time_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
+static oid *peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
+static oid *client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static void snmpDecodePacket(snmp_request_t * rq);
 static void snmpConstructReponse(snmp_request_t * rq);
 static struct snmp_pdu *snmpAgentResponse(struct snmp_pdu *PDU);
@@ -90,401 +98,231 @@ snmpInit(void)
     snmplib_debug_hook = snmpSnmplibDebug;
 
     mib_tree_head = snmpAddNode(snmpCreateOid(1, 1),
-	1, NULL, 1,
+	1, NULL, NULL, 1,
 	snmpAddNode(snmpCreateOid(2, 1, 3),
-	    2, NULL, 1,
+	    2, NULL, NULL, 1,
 	    snmpAddNode(snmpCreateOid(3, 1, 3, 6),
-		3, NULL, 1,
+		3, NULL, NULL, 1,
 		snmpAddNode(snmpCreateOid(4, 1, 3, 6, 1),
-		    4, NULL, 1,
+		    4, NULL, NULL, 1,
 		    snmpAddNode(snmpCreateOid(5, 1, 3, 6, 1, 4),
-			5, NULL, 1,
+			5, NULL, NULL, 1,
 			snmpAddNode(snmpCreateOid(6, 1, 3, 6, 1, 4, 1),
-			    6, NULL, 1,
+			    6, NULL, NULL, 1,
 			    snmpAddNode(snmpCreateOid(7, 1, 3, 6, 1, 4, 1, 3495),
-				7, NULL, 1,
+				7, NULL, NULL, 1,
 				snmpAddNode(snmpCreateOid(LEN_SQUIDMIB, SQUIDMIB),
-				    8, NULL, 5,
+				    8, NULL, NULL, 5,
 				    snmpAddNode(snmpCreateOid(LEN_SQ_SYS, SQ_SYS),
-					LEN_SQ_SYS, NULL, 3,
-					snmpAddNode(snmpCreateOid(LEN_SQ_SYS + 1, SQ_SYS, 1),
-					    LEN_SQ_SYS + 1, snmp_sysFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_SYS + 2, SQ_SYS, 1, 0),
-						LEN_SQ_SYS + 2, snmp_sysFn, 0)),
-					snmpAddNode(snmpCreateOid(LEN_SQ_SYS + 1, SQ_SYS, 2),
-					    LEN_SQ_SYS + 1, snmp_sysFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_SYS + 2, SQ_SYS, 2, 0),
-						LEN_SQ_SYS + 2, snmp_sysFn, 0)),
-					snmpAddNode(snmpCreateOid(LEN_SQ_SYS + 1, SQ_SYS, 3),
-					    LEN_SQ_SYS + 1, snmp_sysFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_SYS + 2, SQ_SYS, 3, 0),
-						LEN_SQ_SYS + 2, snmp_sysFn, 0))),
+					LEN_SQ_SYS, NULL, NULL, 3,
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_SYS, SYSVMSIZ),
+					    LEN_SYS, snmp_sysFn, static_Inst, 0),
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_SYS, SYSSTOR),
+					    LEN_SYS, snmp_sysFn, static_Inst, 0),
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_SYS, SYS_UPTIME),
+					    LEN_SYS, snmp_sysFn, static_Inst, 0)),
 				    snmpAddNode(snmpCreateOid(LEN_SQ_CONF, SQ_CONF),
-					LEN_SQ_CONF, NULL, 5,
-					snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 1, SQ_CONF, 1),
-					    LEN_SQ_CONF + 1, snmp_confFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 1, 0),
-						LEN_SQ_CONF + 2, snmp_confFn, 0)),
-					snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 1, SQ_CONF, 2),
-					    LEN_SQ_CONF + 1, snmp_confFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 2, 0),
-						LEN_SQ_CONF + 2, snmp_confFn, 0)),
-					snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 1, SQ_CONF, 3),
-					    LEN_SQ_CONF + 1, snmp_confFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 3, 0),
-						LEN_SQ_CONF + 2, snmp_confFn, 0)),
-					snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 1, SQ_CONF, 4),
-					    LEN_SQ_CONF + 1, snmp_confFn, 1,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 4, 0),
-						LEN_SQ_CONF + 2, snmp_confFn, 0)),
-					snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 1, SQ_CONF, 5),
-					    LEN_SQ_CONF + 1, NULL, 4,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 5, 1),
-						LEN_SQ_CONF + 2, snmp_confFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 3, SQ_CONF, 5, 1, 0),
-						    LEN_SQ_CONF + 3, snmp_confFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 5, 2),
-						LEN_SQ_CONF + 2, snmp_confFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 3, SQ_CONF, 5, 2, 0),
-						    LEN_SQ_CONF + 3, snmp_confFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 5, 3),
-						LEN_SQ_CONF + 2, snmp_confFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 3, SQ_CONF, 5, 3, 0),
-						    LEN_SQ_CONF + 3, snmp_confFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 2, SQ_CONF, 5, 4),
-						LEN_SQ_CONF + 2, snmp_confFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_CONF + 3, SQ_CONF, 5, 4, 0),
-						    LEN_SQ_CONF + 3, snmp_confFn, 0)))),
+					LEN_SQ_CONF, NULL, NULL, 5,
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_CONF, CONF_ADMIN),
+					    LEN_SYS, snmp_confFn, static_Inst, 0),
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_CONF, CONF_VERSION),
+					    LEN_SYS, snmp_confFn, static_Inst, 0),
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_CONF, CONF_VERSION_ID),
+					    LEN_SYS, snmp_confFn, static_Inst, 0),
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_CONF, CONF_LOG_FAC),
+					    LEN_SYS, snmp_confFn, static_Inst, 0),
+					snmpAddNode(snmpCreateOid(LEN_SYS, SQ_CONF, CONF_STORAGE),
+					    LEN_SYS, NULL, NULL, 4,
+					    snmpAddNode(snmpCreateOid(LEN_CONF_ST, SQ_CONF, CONF_STORAGE, CONF_ST_MMAXSZ),
+						LEN_CONF_ST, snmp_confFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_CONF_ST, SQ_CONF, CONF_STORAGE, CONF_ST_SWMAXSZ),
+						LEN_CONF_ST, snmp_confFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_CONF_ST, SQ_CONF, CONF_STORAGE, CONF_ST_SWHIWM),
+						LEN_CONF_ST, snmp_confFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_CONF_ST, SQ_CONF, CONF_STORAGE, CONF_ST_SWLOWM),
+						LEN_CONF_ST, snmp_confFn, static_Inst, 0))),
 				    snmpAddNode(snmpCreateOid(LEN_SQ_PRF, SQ_PRF),
-					LEN_SQ_PRF, NULL, 2,
-					snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 1, SQ_PRF, 1),
-					    LEN_SQ_PRF + 1, NULL, 11,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 1),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 1, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 2),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 2, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 3),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 3, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 4),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 4, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 5),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 5, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 6),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 6, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 7),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 7, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 8),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 8, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 9),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 9, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 10),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 10, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 1, 11),
-						LEN_SQ_PRF + 2, snmp_prfSysFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 1, 11, 0),
-						    LEN_SQ_PRF + 3, snmp_prfSysFn, 0))),
-					snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 1, SQ_PRF, 2),
-					    LEN_SQ_PRF + 1, NULL, 2,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 2, 1),
-						LEN_SQ_PRF + 2, NULL, 15,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 1),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 1, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 2),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 2, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 3),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 3, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 4),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 4, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 5),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 5, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 6),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 6, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 7),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 7, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 8),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 8, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 9),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 9, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 10),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 10, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 11),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 11, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 12),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 12, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 13),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 13, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 14),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 14, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0)),
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 1, 15),
-						    LEN_SQ_PRF + 3, snmp_prfProtoFn, 1,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 1, 15, 0),
-							LEN_SQ_PRF + 4, snmp_prfProtoFn, 0))),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, 2, 2),
-						LEN_SQ_PRF + 2, NULL, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, 2, 2, 1),
-						    LEN_SQ_PRF + 3, NULL, 10,
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 1),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 1, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 1, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 1, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 2),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 2, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 2, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 2, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 3),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 3, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 3, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 3, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 4),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 4, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 4, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 4, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 5),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 5, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 5, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 5, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 6),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 6, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 6, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 6, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 7),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 7, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 7, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 7, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 8),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 8, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 8, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 8, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 9),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 9, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 9, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 9, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)),
-						    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, 2, 2, 1, 10),
-							LEN_SQ_PRF + 4, NULL, 3,
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 10, 1),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 10, 5),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0),
-							snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 5, SQ_PRF, 2, 2, 1, 10, 60),
-							    LEN_SQ_PRF + 5, snmp_prfProtoFn, 0)))))),
+					LEN_SQ_PRF, NULL, NULL, 2,
+					snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 1, SQ_PRF, PERF_SYS),
+					    LEN_SQ_PRF + 1, NULL, NULL, 11,
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 1),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 2),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 3),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 4),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 5),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 6),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 7),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 8),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 9),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 10),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_SYS, 11),
+						LEN_SQ_PRF + 2, snmp_prfSysFn, static_Inst, 0)),
+					snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 1, SQ_PRF, PERF_PROTO),
+					    LEN_SQ_PRF + 1, NULL, NULL, 2,
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_PROTO, 1),
+						LEN_SQ_PRF + 2, NULL, NULL, 15,
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 1),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 2),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 3),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 4),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 5),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 6),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 7),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 8),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 9),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 10),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 11),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 12),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 13),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 14),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 1, 15),
+						    LEN_SQ_PRF + 3, snmp_prfProtoFn, static_Inst, 0))),
+					snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 2, SQ_PRF, PERF_PROTO, 2),
+					    LEN_SQ_PRF + 2, NULL, NULL, 1,
+					    snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 3, SQ_PRF, PERF_PROTO, 2, 1),
+						LEN_SQ_PRF + 3, NULL, NULL, 10,
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 1),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 2),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 3),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 4),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 5),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 6),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 7),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 8),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 9),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0),
+						snmpAddNode(snmpCreateOid(LEN_SQ_PRF + 4, SQ_PRF, PERF_PROTO, 2, 1, 10),
+						    LEN_SQ_PRF + 4, snmp_prfProtoFn, time_Inst, 0)))),
 				    snmpAddNode(snmpCreateOid(LEN_SQ_NET, SQ_NET),
-					LEN_SQ_NET, NULL, 3,
-					snmpAddNode(snmpCreateOid(LEN_SQ_NET + 1, SQ_NET, 1),
-					    LEN_SQ_NET + 1, NULL, 8,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 1),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 1, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 2),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 2, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 3),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 3, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 4),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 4, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 5),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 5, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 6),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 6, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 7),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 7, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 1, 8),
-						LEN_SQ_NET + 2, snmp_netIpFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 1, 8, 0),
-						    LEN_SQ_NET + 3, snmp_netIpFn, 0))),
-					snmpAddNode(snmpCreateOid(LEN_SQ_NET + 1, SQ_NET, 2),
-					    LEN_SQ_NET + 1, NULL, 7,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 1),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 1, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 2),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 2, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 3),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 3, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 4),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 4, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 5),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 5, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 6),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 6, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 2, 7),
-						LEN_SQ_NET + 2, snmp_netFqdnFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 2, 7, 0),
-						    LEN_SQ_NET + 3, snmp_netFqdnFn, 0))),
-					snmpAddNode(snmpCreateOid(LEN_SQ_NET + 1, SQ_NET, 3),
-					    LEN_SQ_NET + 1, NULL, 3,
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 3, 1),
-						LEN_SQ_NET + 2, snmp_netDnsFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 3, 1, 0),
-						    LEN_SQ_NET + 3, snmp_netDnsFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 3, 2),
-						LEN_SQ_NET + 2, snmp_netDnsFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 3, 2, 0),
-						    LEN_SQ_NET + 3, snmp_netDnsFn, 0)),
-					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, 3, 3),
-						LEN_SQ_NET + 2, snmp_netDnsFn, 1,
-						snmpAddNode(snmpCreateOid(LEN_SQ_NET + 3, SQ_NET, 3, 3, 0),
-						    LEN_SQ_NET + 3, snmp_netDnsFn, 0)))),
+					LEN_SQ_NET, NULL, NULL, 3,
+					snmpAddNode(snmpCreateOid(LEN_SQ_NET + 1, SQ_NET, NET_IP_CACHE),
+					    LEN_SQ_NET + 1, NULL, NULL, 8,
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_ENT),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_REQ),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_HITS),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_PENDHIT),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_NEGHIT),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_MISS),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_GHBN),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_IP_CACHE, IP_LOC),
+						LEN_SQ_NET + 2, snmp_netIpFn, static_Inst, 0)),
+					snmpAddNode(snmpCreateOid(LEN_SQ_NET + 1, SQ_NET, NET_FQDN_CACHE),
+					    LEN_SQ_NET + 1, NULL, NULL, 7,
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_ENT),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_REQ),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_HITS),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_PENDHIT),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_NEGHIT),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_MISS),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_FQDN_CACHE, FQDN_GHBN),
+						LEN_SQ_NET + 2, snmp_netFqdnFn, static_Inst, 0)),
+					snmpAddNode(snmpCreateOid(LEN_SQ_NET + 1, SQ_NET, NET_DNS_CACHE),
+					    LEN_SQ_NET + 1, NULL, NULL, 3,
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_DNS_CACHE, DNS_REQ),
+						LEN_SQ_NET + 2, snmp_netDnsFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_DNS_CACHE, DNS_REP),
+						LEN_SQ_NET + 2, snmp_netDnsFn, static_Inst, 0),
+					    snmpAddNode(snmpCreateOid(LEN_SQ_NET + 2, SQ_NET, NET_DNS_CACHE, DNS_SERVERS),
+						LEN_SQ_NET + 2, snmp_netDnsFn, static_Inst, 0))),
 				    snmpAddNode(snmpCreateOid(LEN_SQ_MESH, SQ_MESH),
-					LEN_SQ_MESH, NULL, 2,
+					LEN_SQ_MESH, NULL, NULL, 2,
 					snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 1, SQ_MESH, 1),
-					    LEN_SQ_MESH + 1, NULL, 1,
+					    LEN_SQ_MESH + 1, NULL, NULL, 1,
 					    snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 2, SQ_MESH, 1, 1),
-						LEN_SQ_MESH + 2, NULL, 13,
+						LEN_SQ_MESH + 2, NULL, NULL, 13,
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 1),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 2),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 3),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 4),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 5),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 6),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 7),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 8),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 9),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 10),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 11),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 12),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 1, 1, 13),
-						    LEN_SQ_MESH + 3, snmp_meshPtblFn, 0))),
+						    LEN_SQ_MESH + 3, snmp_meshPtblFn, peer_Inst, 0))),
 					snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 1, SQ_MESH, 2),
-					    LEN_SQ_MESH + 1, NULL, 1,
+					    LEN_SQ_MESH + 1, NULL, NULL, 1,
 					    snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 2, SQ_MESH, 2, 1),
-						LEN_SQ_MESH + 2, NULL, 9,
+						LEN_SQ_MESH + 2, NULL, NULL, 9,
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 1),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 2),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 3),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 4),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 5),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 6),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 7),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
 						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 8),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0),
-						snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 9),
-						    LEN_SQ_MESH + 3, snmp_meshCtblFn, 0))))
+						    LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0),
+						(mib_tree_last = snmpAddNode(snmpCreateOid(LEN_SQ_MESH + 3, SQ_MESH, 2, 1, 9),
+							LEN_SQ_MESH + 3, snmp_meshCtblFn, client_Inst, 0)))))
 				)
 			    )
 			)
@@ -671,7 +509,7 @@ snmpDecodePacket(snmp_request_t * rq)
 	debug(49, 5) ("snmpAgentParse: reqid=[%d]\n", PDU->reqid);
 	snmpConstructReponse(rq);
     } else {
-	debug(49, 0) ("Failed SNMP agent query from : %s.\n",
+	debug(49, 1) ("Failed SNMP agent query from : %s.\n",
 	    inet_ntoa(rq->from.sin_addr));
 	snmp_free_pdu(PDU);
     }
@@ -797,7 +635,7 @@ oid_ParseFn *
 snmpTreeGet(oid * Current, snint CurrentLen)
 {
     oid_ParseFn *Fn = NULL;
-    mib_tree_entry *mibTreeEntry = NULL;
+    mib_tree_entry *mibTreeEntry = NULL, *lastEntry = NULL;
     int count = 0;
 
     debug(49, 5) ("snmpTreeGet: Called\n");
@@ -808,14 +646,14 @@ snmpTreeGet(oid * Current, snint CurrentLen)
     mibTreeEntry = mib_tree_head;
     if (Current[count] == mibTreeEntry->name[count]) {
 	count++;
-	while ((mibTreeEntry) && (count < CurrentLen)) {
+	while ((mibTreeEntry) && (count < CurrentLen) && (!mibTreeEntry->parsefunction)) {
+	    lastEntry = mibTreeEntry;
 	    mibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
 	    count++;
 	}
     }
-    if (mibTreeEntry) {
+    if (mibTreeEntry)
 	Fn = mibTreeEntry->parsefunction;
-    }
     debug(49, 5) ("snmpTreeGet: return\n");
     return (Fn);
 }
@@ -835,49 +673,206 @@ snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
     mibTreeEntry = mib_tree_head;
     if (Current[count] == mibTreeEntry->name[count]) {
 	count++;
-	while ((mibTreeEntry) && (count < CurrentLen)) {
+	while ((mibTreeEntry) && (count < CurrentLen) && (!mibTreeEntry->parsefunction)) {
 	    mibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
 	    count++;
 	}
 	debug(49, 5) ("snmpTreeNext: Recursed down to requested object\n");
-
-	if ((mibTreeEntry) && (mibTreeEntry->parsefunction)) {
-	    count--;
-	    nextoid = snmpTreeSiblingEntry(Current[count], count, mibTreeEntry->parent);
-	    if (nextoid) {
-		mibTreeEntry = nextoid;
-		count++;
-	    } else {
-		debug(49, 5) ("snmpTreeNext: Attempting to recurse up for next object\n");
-		while (!nextoid) {
-		    count--;
+    } else {
+	return NULL;
+    }
+    if (mibTreeEntry == mib_tree_last)
+	return (Fn);
+    if ((mibTreeEntry) && (mibTreeEntry->parsefunction)) {
+	*NextLen = CurrentLen;
+	*Next = (*mibTreeEntry->instancefunction) (Current, NextLen, mibTreeEntry, &Fn);
+	if (*Next)
+	    return (Fn);
+    }
+    if ((mibTreeEntry) && (mibTreeEntry->parsefunction)) {
+	count--;
+	nextoid = snmpTreeSiblingEntry(Current[count], count, mibTreeEntry->parent);
+	if (nextoid) {
+	    debug(49, 5) ("snmpTreeNext: Next OID found for sibling\n");
+	    mibTreeEntry = nextoid;
+	    count++;
+	} else {
+	    debug(49, 5) ("snmpTreeNext: Attempting to recurse up for next object\n");
+	    while (!nextoid) {
+		count--;
+		if (mibTreeEntry->parent->parent) {
 		    nextoid = mibTreeEntry->parent;
 		    mibTreeEntry = snmpTreeEntry(Current[count] + 1, count, nextoid->parent);
 		    if (!mibTreeEntry) {
 			mibTreeEntry = nextoid;
 			nextoid = NULL;
 		    }
+		} else {
+		    nextoid = mibTreeEntry;
+		    mibTreeEntry = NULL;
 		}
 	    }
 	}
-	debug(49, 5) ("snmpTreeNext: Past Second\n");
-
-	while ((mibTreeEntry) && (!mibTreeEntry->parsefunction)) {
-	    mibTreeEntry = mibTreeEntry->leaves[0];
-	}
-
-	if ((mibTreeEntry) && (mibTreeEntry->children == 1))
-	    mibTreeEntry = mibTreeEntry->leaves[0];
+    }
+    while ((mibTreeEntry) && (!mibTreeEntry->parsefunction)) {
+	mibTreeEntry = mibTreeEntry->leaves[0];
     }
     if (mibTreeEntry) {
-	*Next = snmpOidDup(mibTreeEntry->name, mibTreeEntry->len);
 	*NextLen = mibTreeEntry->len;
-	Fn = mibTreeEntry->parsefunction;
+	*Next = (*mibTreeEntry->instancefunction) (mibTreeEntry->name, NextLen, mibTreeEntry, &Fn);
     }
-    debug(49, 5) ("snmpTreeNext: return\n");
     return (Fn);
 }
 
+oid *
+static_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
+{
+    oid *instance = NULL;
+
+    if (*len <= current->len) {
+	instance = xmalloc(sizeof(name) * (*len + 1));
+	xmemcpy(instance, name, (sizeof(name) * *len));
+	instance[*len] = 0;
+	*len += 1;
+    }
+    *Fn = current->parsefunction;
+    return (instance);
+}
+
+oid *
+time_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
+{
+    oid *instance = NULL;
+    int identifier = 0, loop = 0;
+    int index[TIME_INDEX_LEN] =
+    {TIME_INDEX};
+
+    if (*len <= current->len) {
+	instance = xmalloc(sizeof(name) * (*len + 1));
+	xmemcpy(instance, name, (sizeof(name) * *len));
+	instance[*len] = *index;
+	*len += 1;
+    } else {
+	identifier = name[*len - 1];
+	while ((identifier != index[loop]) && (loop < TIME_INDEX_LEN))
+	    loop++;
+	if (loop < TIME_INDEX_LEN - 1) {
+	    instance = xmalloc(sizeof(name) * (*len));
+	    xmemcpy(instance, name, (sizeof(name) * *len));
+	    instance[*len - 1] = index[++loop];
+	}
+    }
+    *Fn = current->parsefunction;
+    return (instance);
+}
+
+oid *
+peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
+{
+    oid *instance = NULL;
+    u_char *cp = NULL;
+    peer *peers = Config.peers;
+    struct in_addr *laddr = NULL;
+    char *host_addr = NULL, *current_addr = NULL, *last_addr = NULL;
+
+    if (peers == NULL) {
+	current = current->parent->parent->parent->leaves[1];
+	while ((current) && (!current->parsefunction))
+	    current = current->leaves[0];
+	instance = client_Inst(current->name, len, current, Fn);
+    } else if (*len <= current->len) {
+	instance = xmalloc(sizeof(name) * (*len + 4));
+	xmemcpy(instance, name, (sizeof(name) * *len));
+	cp = (u_char *) & (peers->in_addr.sin_addr.s_addr);
+	instance[*len] = *cp++;
+	instance[*len + 1] = *cp++;
+	instance[*len + 2] = *cp++;
+	instance[*len + 3] = *cp++;
+	*len += 4;
+    } else {
+	laddr = oid2addr(&name[*len - 4]);
+	host_addr = inet_ntoa(*laddr);
+	last_addr = xmalloc(strlen(host_addr));
+	strncpy(last_addr, host_addr, strlen(host_addr));
+	current_addr = inet_ntoa(peers->in_addr.sin_addr);
+	while ((peers) && (strncmp(last_addr, current_addr, strlen(current_addr)))) {
+	    if (peers->next) {
+		peers = peers->next;
+		current_addr = inet_ntoa(peers->in_addr.sin_addr);
+	    } else {
+		peers = NULL;
+	    }
+	}
+	xfree(last_addr);
+	if (peers) {
+	    if (peers->next) {
+		peers = peers->next;
+		instance = xmalloc(sizeof(name) * (*len));
+		xmemcpy(instance, name, (sizeof(name) * *len));
+		cp = (u_char *) & (peers->in_addr.sin_addr.s_addr);
+		instance[*len - 4] = *cp++;
+		instance[*len - 3] = *cp++;
+		instance[*len - 2] = *cp++;
+		instance[*len - 1] = *cp++;
+	    } else {
+		return (instance);
+	    }
+	} else {
+	    return (instance);
+	}
+    }
+    *Fn = current->parsefunction;
+    return (instance);
+}
+
+oid *
+client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
+{
+    oid *instance = NULL;
+    u_char *cp = NULL;
+    struct in_addr *laddr = NULL;
+
+    if (*len <= current->len) {
+	instance = xmalloc(sizeof(name) * (*len + 4));
+	xmemcpy(instance, name, (sizeof(name) * *len));
+	laddr = client_entry(NULL);
+	if (laddr) {
+	    cp = (u_char *) & (laddr->s_addr);
+	    instance[*len] = *cp++;
+	    instance[*len + 1] = *cp++;
+	    instance[*len + 2] = *cp++;
+	    instance[*len + 3] = *cp++;
+	    *len += 4;
+	}
+    } else {
+	laddr = oid2addr(&name[*len - 4]);
+	laddr = client_entry(laddr);
+	if (laddr) {
+	    instance = xmalloc(sizeof(name) * (*len));
+	    xmemcpy(instance, name, (sizeof(name) * *len));
+	    cp = (u_char *) & (laddr->s_addr);
+	    instance[*len - 4] = *cp++;
+	    instance[*len - 3] = *cp++;
+	    instance[*len - 2] = *cp++;
+	    instance[*len - 1] = *cp++;
+	}
+    }
+    *Fn = current->parsefunction;
+    return (instance);
+}
+
+
+/*
+ * Utility functions
+ */
+
+/*
+ * Tree utility functions. 
+ */
+
+/* 
+ * Returns a the sibling object in the tree
+ */
 mib_tree_entry *
 snmpTreeSiblingEntry(oid entry, snint len, mib_tree_entry * current)
 {
@@ -898,6 +893,9 @@ snmpTreeSiblingEntry(oid entry, snint len, mib_tree_entry * current)
     return (next);
 }
 
+/* 
+ * Returns the requested child object or NULL if it does not exist
+ */
 mib_tree_entry *
 snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
 {
@@ -913,20 +911,12 @@ snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
     return (next);
 }
 
-/*
- * Utility functions
- */
-
-/*
- * Tree utility functions. 
- */
-
 /*
  * Adds a node to the MIB tree structure and adds the appropriate children
  */
 mib_tree_entry *
 #if STDC_HEADERS
-snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, int children,...)
+snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, instance_Fn * instancefunction, int children,...)
 #else
 snmpAddNode(va_alist)
      va_dcl
@@ -936,31 +926,34 @@ snmpAddNode(va_alist)
     va_list args;
     int loop;
     mib_tree_entry *entry = NULL;
-                   va_start(args, children);
+    va_start(args, children);
 #else
     va_list args;
     oid *name = NULL;
     int len = 0, children = 0, loop;
     oid_ParseFn *parsefunction = NULL;
+    instance_Fn *instancefunction = NULL;
     mib_tree_entry *entry = NULL;
-                   va_start(args);
-                   name = va_arg(args, oid *);
-                   len = va_arg(args, int);
-        parsefunction = va_arg(args, oid_ParseFn *);
-        children = va_arg(args, int);
+    va_start(args);
+    name = va_arg(args, oid *);
+    len = va_arg(args, int);
+    parsefunction = va_arg(args, oid_ParseFn *);
+    instancefunction = va_arg(args, instance_Fn *);
+    children = va_arg(args, int);
 #endif
 
-        debug(49, 6) ("snmpAddNode: Children : %d, Oid : \n", children);
-        snmpDebugOid(6, name, len);
+    debug(49, 6) ("snmpAddNode: Children : %d, Oid : \n", children);
+    snmpDebugOid(6, name, len);
 
-        va_start(args, children);
-        entry = xmalloc(sizeof(mib_tree_entry));
-        entry->name = snmpOidDup(name, len);
-        entry->len = len;
-        entry->parsefunction = parsefunction;
-        entry->children = children;
+    va_start(args, children);
+    entry = xmalloc(sizeof(mib_tree_entry));
+    entry->name = snmpOidDup(name, len);
+    entry->len = len;
+    entry->parsefunction = parsefunction;
+    entry->instancefunction = instancefunction;
+    entry->children = children;
 
-    if  (children > 0) {
+    if (children > 0) {
 	entry->leaves = xmalloc(sizeof(mib_tree_entry *) * children);
 	for (loop = 0; loop < children; loop++) {
 	    entry->leaves[loop] = va_arg(args, mib_tree_entry *);
@@ -1039,3 +1032,27 @@ snmpSnmplibDebug(int lvl, char *buf)
 {
     debug(49, lvl) ("%s", buf);
 }
+
+void
+addr2oid(struct in_addr addr, oid * Dest)
+{
+    u_char *cp;
+    cp = (u_char *) & (addr.s_addr);
+    Dest[0] = *cp++;
+    Dest[1] = *cp++;
+    Dest[2] = *cp++;
+    Dest[3] = *cp++;
+}
+
+struct in_addr
+       *
+oid2addr(oid * id)
+{
+    static struct in_addr laddr;
+    u_char *cp = (u_char *) & (laddr.s_addr);
+    cp[0] = id[0];
+    cp[1] = id[1];
+    cp[2] = id[2];
+    cp[3] = id[3];
+    return &laddr;
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.186 1999/04/14 05:16:19 wessels Exp $
+ * $Id: squid.h,v 1.187 1999/04/15 06:16:09 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -370,11 +370,21 @@ struct rusage {
 /*
  * Squid source files should not call these functions directly
  */
+#ifndef malloc
 #define malloc +
+#endif
+#ifndef free
 #define free +
+#endif
+#ifndef calloc
 #define calloc +
+#endif
+#ifndef sprintf
 #define sprintf +
+#endif
+#ifndef strdup
 #define strdup +
+#endif
 
 #if SQUID_SNMP
 extern struct snmp_mib_tree *Mib;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.92 1999/01/29 23:39:23 wessels Exp $
+ * $Id: ssl.cc,v 1.93 1999/04/15 06:16:09 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -107,6 +107,9 @@ sslStateFree(SslStateData * sslState)
     sslState->host = NULL;
     requestUnlink(sslState->request);
     sslState->request = NULL;
+#if DELAY_POOLS
+    delayUnregisterDelayIdPtr(&sslState->delay_id);
+#endif
     cbdataFree(sslState);
 }
 
@@ -429,6 +432,7 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr)
     cbdataAdd(sslState, cbdataXfree, 0);
 #if DELAY_POOLS
     sslState->delay_id = delayClient(request);
+    delayRegisterDelayIdPtr(&sslState->delay_id);
 #endif
     sslState->url = xstrdup(url);
     sslState->request = requestLink(request);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.311 1999/01/21 21:10:34 wessels Exp $
+ * $Id: stat.cc,v 1.312 1999/04/15 06:16:10 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -407,25 +407,27 @@ statFiledescriptors(StoreEntry * sentry)
     int i;
     fde *f;
     storeAppendPrintf(sentry, "Active file descriptors:\n");
-    storeAppendPrintf(sentry, "%-4s %-6s %-4s %-7s %-7s %-21s %s\n",
+    storeAppendPrintf(sentry, "%-4s %-6s %-4s %-7s* %-7s* %-21s %s\n",
 	"File",
 	"Type",
 	"Tout",
 	"Nread",
 	"Nwrite",
 	"Remote Address",
 	"Description");
-    storeAppendPrintf(sentry, "---- ------ ---- ------- ------- --------------------- ------------------------------\n");
+    storeAppendPrintf(sentry, "---- ------ ---- -------- -------- --------------------- ------------------------------\n");
     for (i = 0; i < Squid_MaxFD; i++) {
 	f = &fd_table[i];
 	if (!f->flags.open)
 	    continue;
-	storeAppendPrintf(sentry, "%4d %-6.6s %4d %7d %7d %-21s %s\n",
+	storeAppendPrintf(sentry, "%4d %-6.6s %4d %7d%c %7d%c %-21s %s\n",
 	    i,
 	    fdTypeStr[f->type],
 	    f->timeout_handler ? (int) (f->timeout - squid_curtime) / 60 : 0,
 	    f->bytes_read,
+	    f->read_handler ? '*' : ' ',
 	    f->bytes_written,
+	    f->write_handler ? '*' : ' ',
 	    fdRemoteAddr(f),
 	    f->desc);
     }
@@ -587,6 +589,8 @@ info_get(StoreEntry * sentry)
 	Biggest_FD);
     storeAppendPrintf(sentry, "\tNumber of file desc currently in use: %4d\n",
 	Number_FD);
+    storeAppendPrintf(sentry, "\tFiles queued for open:                %4d\n",
+	Opening_FD);
     storeAppendPrintf(sentry, "\tAvailable number of file descriptors: %4d\n",
 	fdNFree());
     storeAppendPrintf(sentry, "\tReserved number of file descriptors:  %4d\n",
@@ -874,7 +878,7 @@ statAvgTick(void *notused)
     StatCounters *p = &CountHist[1];
     StatCounters *c = &Counter;
     struct rusage rusage;
-    eventAdd("statAvgTick", statAvgTick, NULL, COUNT_INTERVAL, 1);
+    eventAdd("statAvgTick", statAvgTick, NULL, (double) COUNT_INTERVAL, 1);
     squid_getrusage(&rusage);
     c->page_faults = rusage_pagefaults(&rusage);
     c->cputime = rusage_cputime(&rusage);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_client.cc,v 1.61 1999/04/14 06:36:09 wessels Exp $
+ * $Id: store_client.cc,v 1.62 1999/04/15 06:16:11 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Client-Side Interface
  * AUTHOR: Duane Wessels
@@ -132,6 +132,9 @@ storeClientListAdd(StoreEntry * e, void *data)
 	assert(e->swap_file_number > -1 || storeSwapOutAble(e));
     for (T = &mem->clients; *T; T = &(*T)->next);
     *T = sc;
+#if DELAY_POOLS
+    delayRegisterDelayIdPtr(&sc->delay_id);
+#endif
 }
 
 static void
@@ -466,6 +469,9 @@ storeUnregister(StoreEntry * e, void *data)
 	sc->callback = NULL;
 	callback(sc->callback_data, sc->copy_buf, -1);
     }
+#if DELAY_POOLS
+    delayUnregisterDelayIdPtr(&sc->delay_id);
+#endif
     cbdataFree(sc);
     assert(e->lock_count > 0);
     if (mem->nclients == 0)
@@ -541,7 +547,7 @@ CheckQuickAbort2(StoreEntry * entry)
 	debug(20, 3) ("CheckQuickAbort2: YES KEY_PRIVATE\n");
 	return 1;
     }
-    expectlen = mem->reply->content_length;
+    expectlen = mem->reply->content_length + mem->reply->hdr_sz;
     curlen = (int) mem->inmem_hi;
     minlen = (int) Config.quickAbort.min << 10;
     if (minlen < 0) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir.cc,v 1.84 1999/01/13 23:24:15 wessels Exp $
+ * $Id: store_dir.cc,v 1.85 1999/04/15 06:16:12 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -283,7 +283,7 @@ storeDirSelectSwapDir(void)
 	diru[i] = 1.1;
 	SD = &Config.cacheSwap.swapDirs[i];
 	SD->flags.selected = 0;
-	if (SD->read_only)
+	if (SD->flags.read_only)
 	    continue;
 	u = (double) SD->cur_size / SD->max_size;
 	if (u > high)
@@ -627,6 +627,8 @@ storeDirStats(StoreEntry * sentry)
 	storeAppendPrintf(sentry, "Flags:");
 	if (SD->flags.selected)
 	    storeAppendPrintf(sentry, " SELECTED");
+	if (SD->flags.read_only)
+	    storeAppendPrintf(sentry, " READ-ONLY");
 	storeAppendPrintf(sentry, "\n");
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.279 1999/04/15 06:03:50 wessels Exp $
+ * $Id: structs.h,v 1.280 1999/04/15 06:16:13 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -439,6 +439,7 @@ struct _SquidConfig {
     } mcast_miss;
 #endif
     HttpHeaderMask anonymize_headers;
+    char *coredump_dir;
 };
 
 struct _SquidConfig2 {
@@ -1010,7 +1011,7 @@ struct _peer {
     } htcp;
 #endif
     u_short http_port;
-    domain_ping *pinglist;
+    domain_ping *peer_domain;
     domain_type *typelist;
     acl_access *access;
     struct {
@@ -1254,12 +1255,12 @@ struct _SwapDir {
     int l2;
     int cur_size;
     int max_size;
-    int read_only;
     int suggest;
     fileMap *map;
     int swaplog_fd;
     struct {
 	unsigned int selected:1;
+	unsigned int read_only:1;
     } flags;
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.92 1999/01/29 23:39:23 wessels Exp $
+ * $Id: tunnel.cc,v 1.93 1999/04/15 06:16:09 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -107,6 +107,9 @@ sslStateFree(SslStateData * sslState)
     sslState->host = NULL;
     requestUnlink(sslState->request);
     sslState->request = NULL;
+#if DELAY_POOLS
+    delayUnregisterDelayIdPtr(&sslState->delay_id);
+#endif
     cbdataFree(sslState);
 }
 
@@ -429,6 +432,7 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr)
     cbdataAdd(sslState, cbdataXfree, 0);
 #if DELAY_POOLS
     sslState->delay_id = delayClient(request);
+    delayRegisterDelayIdPtr(&sslState->delay_id);
 #endif
     sslState->url = xstrdup(url);
     sslState->request = requestLink(request);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.113 1999/01/19 02:24:35 wessels Exp $
+ * $Id: url.cc,v 1.114 1999/04/15 06:16:13 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -233,7 +233,7 @@ urlParse(method_t method, char *url)
 	}
     }
     for (t = host; *t; t++)
-	*t = tolower(*t);
+	*t = xtolower(*t);
     if (strspn(host, valid_hostname_chars) != strlen(host)) {
 	debug(23, 1) ("urlParse: Illegal character in hostname '%s'\n", host);
 	return NULL;
@@ -1,7 +1,7 @@
 
 /*
  *
- * $Id: urn.cc,v 1.52 1999/01/29 23:39:25 wessels Exp $
+ * $Id: urn.cc,v 1.53 1999/04/15 06:16:14 wessels Exp $
  *
  * DEBUG: section 52    URN Parsing
  * AUTHOR: Kostas Anagnostakis
@@ -143,9 +143,6 @@ urnStart(request_t * r, StoreEntry * e)
 	storeLockObject(urlres_e);
 	storeClientListAdd(urlres_e, urnState);
     }
-#if DELAY_POOLS
-    delaySetStoreClient(urlres_e, urnState, 0);
-#endif
     urnState->urlres_e = urlres_e;
     urnState->urlres_r = requestLink(urlres_r);
     storeClientCopy(urlres_e,
@@ -231,7 +228,7 @@ urnHandleReply(void *data, char *buf, ssize_t size)
 	errorAppendEntry(e, err);
 	return;
     }
-    while (isspace(*s))
+    while (xisspace(*s))
 	s++;
     urls = urnParseReply(s, urnState->request->method);
     for (i = 0; NULL != urls[i].url; i++)
@@ -1,5 +1,7 @@
 #include "config.h"
 
+/* $Id: tcp-banger2.c,v 1.23 1999/04/15 06:16:15 wessels Exp $ */
+
 /*
  * On some systems, FD_SETSIZE is set to something lower than the
  * actual number of files which can be opened.  IRIX is one case,
@@ -82,6 +84,9 @@
 #if HAVE_ASSERT_H
 #include <assert.h>
 #endif
+#if HAVE_CTYPE_H
+#include <ctype.h>
+#endif
 
 #define PROXY_PORT 3128
 #define PROXY_ADDR "127.0.0.1"
@@ -102,7 +107,6 @@ static struct timeval now;
 static long total_bytes_written = 0;
 static long total_bytes_read = 0;
 static int opt_checksum = 0;
-static int accepted_status = 200;
 FILE *trace_file = NULL;
 
 typedef void (CB) (int, void *);
@@ -124,7 +128,6 @@ struct _request {
     int bodysize;
     int content_length;
     int status;
-    int validstatus;
     long validsum;
     long sum;
 };
@@ -220,11 +223,11 @@ read_reply(int fd, void *data)
 		if (!header)
 		    break;
 		/* Decode header */
-		if (strncasecmp(header, "HTTP/1", 6) == 0)
-		    r->status = atoi(header + 9);
-		if (strncasecmp(header, "Content-Length:", 15) == 0)
+		if (strncmp(header, "HTTP", 4) == 0)
+		    r->status = atoi(header + 8);
+		else if (strncasecmp(header, "Content-Length:", 15) == 0)
 		    r->content_length = atoi(header + 15);
-		if (strncasecmp(header, "X-Request-URI:", 14) == 0) {
+		else if (strncasecmp(header, "X-Request-URI:", 14) == 0) {
 		    /* Check URI */
 		    if (strncmp(r->url, header + 15, strcspn(header + 15, "\r\n"))) {
 			char url[8192];
@@ -275,11 +278,13 @@ reply_done(int fd, void *data)
 	    fprintf(stderr, "WARNING: %s invalid checksum wanted 0x%lx got 0x%lx\n",
 		r->url, r->validsum, r->sum);
     }
-    if (r->status != r->validstatus && r->validstatus)
-	fprintf(stderr, "WARNING: %s status %d\n", r->url, r->status);
     if (trace_file) {
-	fprintf(trace_file, "%s %s %s %d 0x%lx %d\n",
-	    r->method, r->url, r->requestbodyfile, r->bodysize, r->sum, r->status);
+	if (opt_checksum)
+	    fprintf(trace_file, "%s %s %d %s %d 0x%lx\n",
+		r->method, r->url, r->status, r->requestbodyfile, r->bodysize, r->sum);
+	else
+	    fprintf(trace_file, "%s %s %d %s %d\n",
+		r->method, r->url, r->status, r->requestbodyfile, r->bodysize);
     }
     free_request(r);
 }
@@ -290,7 +295,7 @@ request(char *urlin)
     int s = -1, f = -1;
     char buf[4096];
     char msg[8192];
-    char *method, *url, *file, *size, *checksum, *status;
+    char *method, *url, *file, *size, *checksum;
     char *host;
     char urlbuf[8192];
     int len, len2;
@@ -319,7 +324,6 @@ request(char *urlin)
     file = strtok(NULL, " ");
     size = strtok(NULL, " ");
     checksum = strtok(NULL, " ");
-    status = strtok(NULL, " ");
     if (!url) {
 	url = method;
 	method = "GET";
@@ -344,10 +348,6 @@ request(char *urlin)
     if (checksum && strcmp(checksum, "-") != 0)
 	r->validsum = strtoul(checksum, NULL, 0);
     r->content_length = -1;	/* Unknown */
-    if (status && strcmp(status, "-") != 0)
-	r->validstatus = strtoul(status, NULL, 0);
-    else
-	r->validstatus = accepted_status;
     if (opt_accel) {
 	host = strchr(url, '/') + 2;
 	url = strchr(host, '/');
@@ -465,7 +465,6 @@ usage(void)
     fprintf(stderr, " -c              Check checksum agains trace\n");
     fprintf(stderr, " -i              Send random If-Modified-Since times\n");
     fprintf(stderr, " -l <seconds>    Connection lifetime timeout (default 60)\n");
-    fprintf(stderr, " -s <status>     HTTP status expected (default 200, 0 == ignore)\n");
     fprintf(stderr, " -a              Accelerator mode\n");
 }
 
@@ -514,9 +513,9 @@ main(argc, argv)
 	    opt_checksum = 1;
 	    break;
 	case 't':
-	    opt_checksum = 1;	/* Tracing requires checksums */
-	    trace_file = fopen(optarg, "w");
+	    trace_file = fopen(optarg, "a");
 	    assert(trace_file);
+	    setbuf(trace_file, NULL);
 	    break;
 	case 'r':
 	    opt_range = 1;
@@ -579,9 +578,12 @@ main(argc, argv)
 		(int) total_bytes_read / 1024 / 1024,
 		(int) total_bytes_read / 1024 / dt);
 	    reqpersec = 0;
-	    if (dt > process_lifetime)
-		exit(0);
+	    /*
+	     * if (dt > process_lifetime)
+	     *     exit(0);
+	     */
 	}
     }
+    printf("Exiting normally\n");
     return 0;
 }
@@ -136,8 +136,10 @@ get_url(const char *url)
 	*t = '\0';
 	port = (unsigned short) atoi(t + 1);
     }
+#if 0
     if ((int) port != 80)
 	return 0;
+#endif
     t = strchr(url + 7, '/');
     strncpy(path, (t ? t : "/"), URL_BUF_SZ);
     memset(&S, '\0', sizeof(S));