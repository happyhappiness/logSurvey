@@ -195,3 +195,4 @@ and ideas to make this software available.
     benno@jeamland.net
     fancyrabbit <fancyrabbit@gmail.com>
     vollkommen <vollkommen@gmx.net>
+    Benjamin Kerensa <bkerensa@ubuntu.com>
@@ -1,3 +1,35 @@
+Changes to squid-3.3.3 (12 Mar 2013):
+
+	- Bug 3720: Add missing include in /dev/poll I/O module (pt2)
+	- ... and all changes from squid 3.2.9
+
+Changes to squid-3.3.2 (02 Mar 2013):
+
+	- Bug 3781: Proxy Authentication not sent to cache_peer
+	- Bug 3794: MacOS: workaround compiler errors
+	- Bug 3720: Compile error in Solaris /OpenIndiana
+	- ... and all changes from squid 3.2.8
+
+Changes to squid-3.3.1 (09 Feb 2013):
+
+	- Bug 3726: build errors with --disable-ssl
+	- Propigate pinned connection persistency and closures to the client.
+	- Mimic SSL certificate Key Usage and Basic Constraints
+	- Fix segmentation fault on missing squid.conf values
+	- ext_sql_session_acl: Fix hex decoding on UID
+	- ... and some code polish
+	- ... and a lot of documentation polish
+	- ... and all changes from squid 3.2.7
+
+Changes to squid-3.3.0.3 (09 Jan 2013):
+
+	- Bug 3729: 32-bit overflow in parsing 64-bit configuration values
+	- Bug 3728: Improve debug for cache_dir
+	- Additional fixes for CVE-2012-5643 / SQUID:2012-1
+	- kerberos_ldap_group: support multiple groups in squid.conf ACL definition
+	- kqueue: update status from experimental to fully available net I/O method
+	- ... and many memory leaks and potential bugs detected by Coverity Scan
+
 Changes to squid-3.3.0.2 (03 Dec 2012):
 
 	- Support matching empty header field values using req_header and rep_header
@@ -23,6 +55,58 @@ Changes to squid-3.3.0.1 (21 Oct 2012):
 	- ... and many compile error fixes
 	- ... and a very large amount of code polish for faster compilation
 
+Changes to squid-3.2.9 (12 Mar 2013):
+
+	- Regression fix: Accept-Language header parse
+	- Bug 3673: Silence 'Failed to select source' messages
+	- Fix authentication headers sent on peer digest requests
+	- Fix build error on Solaris, OpenIndiana, Omnios
+
+Changes to squid-3.2.8 (02 Mar 2013):
+
+	- Bug 3767: tcp_outgoing_tos/mark ACLs do not obey acl_uses_indirect_client
+	- Bug 3763: diskd Error: no filename in shm buffer
+	- Bug 3752: objects that cannot be cached in memory are not cached on disk
+	- Bug 3753: Removes the domain from the cache_peer server pconn key
+	- Bug 3749: IDENT lookup using wrong ports to identify the user
+	- Bug 3723: tcp_outgoing_tos/mark broken for CONNECT requests
+	- Bug 3686: cache_dir max-size default fails
+	- Bug 3515: crash in FtpStateData::ftpTimeout
+	- Bug 3329: Quieten orphan Comm::Connection messages
+	- Make squid -z for cache_dir rock preserve the rock DB
+	- Fixed several server connect problems
+	- ... and some build issues on Solaris, OpenIndiana, MacOS X
+	- ... and some documentation and debugs polishing
+
+Changes to squid-3.2.7 (01 Feb 2013):
+
+	- Bug 3736: Floating point exception due to divide by zero
+	- Bug 3735: raw-IPv6 domain URLs crash if IPv6-disabled
+	- Bug 3732: Fix ConnOpener IPv6 awareness
+	- Bug 3729: 32-bit overflow in parsing 64-bit configuration values
+	- Bug 3728: Improve debug for cache_dir
+	- Bug 3687: unhandled exception: c when using interception and peers
+	- Bug 3678: external acl grace period causes acl lookup failures
+	- Bug 3567: Memory leak handling malformed requests
+	- Bug 3111: Mid-term fix for the forward.cc "err" assertion
+	- Support OpenSSL NO_Compression optio
+	- Fix IPv6 enabled pinger on split-stack or IPv6-disabled systems
+	- Fix "address.GetPort() != 0" assertion for helpers
+	- ... and several minor memory leaks
+	- ... and some cache.log message polishing
+
+Changes to squid-3.2.6 (09 Jan 2013):
+
+	- Regression Bug 3731: TOS setsockopt() requires int value
+	- Regression Bug 3712: Rotating logs overwrites the previous log
+	- Bug 3727: LLVM compile errors in kerberos_ldap_group
+	- Bug 3650: Negotiate auth missing challenge token
+	- Additional fixes for CVE-2012-5643 / SQUID:2012-1
+
+Changes to squid-3.2.5 (10 Dec 2012):
+
+	- Bug 3698: Add missing include of errno.h
+
 Changes to squid-3.2.4 (03 Dec 2012):
 
 	- Ported: urllogin ACL from squid 2.7
@@ -472,6 +556,10 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.23 (09 Jan 2013):
+
+	- Additional fixes for CVE-2012-5643 / SQUID:2012-1
+
 Changes to squid-3.1.22 (03 Dec 2012):
 
 	- Bug 3685: Squid hangs in Delay Pools ClassCBucket::update
@@ -85,8 +85,14 @@ xstrtoui(const char *s, char **end, unsigned int *value,
     bool ret;
 
     ret = xstrtoul(s, end, &v, min, max);
-    if (value != NULL)
+    if (value != NULL) {
         *value = v;
+
+        if (v != static_cast<unsigned long>(*value)) {
+            return false;
+        }
+    }
+
     return ret;
 }
 
@@ -1,6 +1,9 @@
 #ifndef _SQUID_XSTRTO_H
 #define _SQUID_XSTRTO_H
 
+// these functions are not used by the remaining Squid C code.
+#if defined(__cplusplus)
+
 #if HAVE_STDBOOL_H
 #include <stdbool.h>
 #endif
@@ -27,4 +30,5 @@ bool xstrtoul(const char *s, char **end, unsigned long *value,
 bool xstrtoui(const char *s, char **end, unsigned int *value,
               unsigned int min, unsigned int max);
 
+#endif /* __cplusplus */
 #endif /* _SQUID_XSTRTO_H */
@@ -1,4 +1,4 @@
-AC_INIT([Squid Web Proxy],[3.HEAD-BZR],[http://www.squid-cache.org/bugs/],[squid])
+AC_INIT([Squid Web Proxy],[3.HEAD-BZR],[http://bugs.squid-cache.org/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
 AC_CONFIG_AUX_DIR(cfgaux)
@@ -317,7 +317,7 @@ dnl Guido Serassio (serassio@squid-cache.org) 20070811
 dnl Using the latest MinGW (gcc 3.4.5 + mingw-runtime 3.13) cannot build with
 dnl -Werror -Wmissing-prototypes -Wmissing-declarations
 dnl TODO: check if the problem will be present in any other newer MinGW release.
-    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments"
+    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
     ;;
   freebsd)
     # FreeBSD places local libraries and packages in /usr/local
@@ -326,10 +326,10 @@ dnl TODO: check if the problem will be present in any other newer MinGW release.
     LDFLAGS="$LDFLAGS -L/usr/local/lib -Wl,-R/usr/local/lib"
     ;;
   *)
-    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments"
+    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow"
     ;;
   esac
-  SQUID_CXXFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments"
+  SQUID_CXXFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
 else
   SQUID_CFLAGS=
   SQUID_CXXFLAGS=
@@ -1318,18 +1318,29 @@ test "x$enableval" = "xyes" && squid_opt_io_loop_engine="poll"
 ])
 AC_MSG_NOTICE([enabling poll syscall for net I/O: ${enable_poll:=auto}])
 
-# kqueue support is still experiemntal and unstable. Not enabled by default.
 AC_ARG_ENABLE(kqueue,
-  AS_HELP_STRING([--enable-kqueue],
-                 [Enable kqueue(2) support (experimental).]), [
+  AS_HELP_STRING([--disable-kqueue],
+                 [Disable kqueue(2) support.]), [
 SQUID_YESNO($enableval,[--enable-kqueue takes no extra argument])
 ])
-if test "x${enable_kqueue:=no}" = "xyes" ; then
-  AC_CHECK_HEADERS([sys/event.h],[],
-    [ AC_MSG_ERROR([kqueue support requires sys/event.h header file.]) ])
-  squid_opt_io_loop_engine="kqueue"
+if test "x${enable_kqueue:=auto}" != "xno" ; then
+  AC_CHECK_HEADERS([sys/event.h],[],[
+    if test "x${enable_kqueue}" = "xyes" ; then
+      AC_MSG_ERROR([kqueue support requires sys/event.h header file.])
+    fi
+  ])
+  AC_CHECK_FUNCS(kqueue,[],[
+    if test "x${enable_kqueue}" = "xyes" ; then
+      AC_MSG_ERROR([kqueue support missing in libc library.])
+    fi
+  ])
+  if test "x$ac_cv_func_kqueue" = "xyes" -a "x$ac_cv_header_sys_event_h" = "xyes" ; then
+    squid_opt_io_loop_engine="kqueue"
+  else
+    enable_kqueue="no"
+  fi
 fi
-AC_MSG_NOTICE([enabling kqueue for net I/O: $enable_kqueue])
+AC_MSG_NOTICE([enabling kqueue for net I/O: ${enable_kqueue:=auto}])
 
 dnl Enable epoll()
 AC_ARG_ENABLE(epoll,
@@ -3173,7 +3184,6 @@ AC_CHECK_FUNCS(\
 	glob \
 	htobe16 \
 	htole16 \
-	kqueue\
 	lrand48 \
 	mallinfo \
 	mallocblksize \
@@ -3241,7 +3251,7 @@ if test "x$squid_opt_io_loop_engine" != "x"; then
 	AC_MSG_NOTICE([choosing user-specified net I/O API $squid_opt_io_loop_engine])
 elif test "x$enable_epoll" != "xno" -a "x$squid_cv_epoll_works" = "xyes" ; then
   squid_opt_io_loop_engine="epoll"
-elif test "x$enable_kqueue" != "xno" -a "x$ac_cv_func_kqueue" = "xyes" ; then
+elif test "x$enable_kqueue" != "xno" ; then
   squid_opt_io_loop_engine="kqueue"
 elif test "x$enable_devpoll" != "xno" ; then
   squid_opt_io_loop_engine="devpoll"
@@ -1,6 +1,6 @@
-all: release-3.3.html
+all: release-3.4.html
 
-DOC= release-3.3
+DOC= release-3.4
 
 $(DOC).ps: $(DOC).sgml
 	linuxdoc -B latex -o ps $(DOC)
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.22 release notes</title>
+<title>Squid 3.1.23 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.22
+The Squid Team are pleased to announce the release of Squid-3.1.23
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.4 release notes</title>
+<title>Squid 3.2.9 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,18 +13,21 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.4 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.9.
 
-This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the
+ <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
-While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
+<p>A large number of the show-stopper bugs have been fixed along with general improvements to the IPv6 support.
+While this release is not fully bug-free we believe it is ready for use in production on many systems.
 
-We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting"> for how to submit a 
+<p>We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting"> for how to submit a 
 report with a stack trace.
 
 <sect1>Known issues
 <p>
-Although this release is deemed good enough for use in many setups, please note the existence of <url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.2&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" name="open bugs against Squid-3.2">.
+Although this release is deemed good enough for use in many setups, please note the existence of 
+<url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.2" name="open bugs against Squid-3.2">.
 
 <p>Some issues to note as currently known in this release which are not able to be fixed in the 3.2 series are:
 
@@ -89,7 +92,7 @@ Most user-facing changes are reflected in squid.conf (see below).
   DNS lookups to locate alternative DIRECT destinations will not be done.
 
 <p>Known Issue: When non-strict validation fails Squid will relay the request, but can only do
-  so safely to the orginal destination IP the client was contacting. The client original
+  so safely to the original destination IP the client was contacting. The client original
   destination IP is lost when relaying to peers in a hierarchy. This means the upstream peers
   are still at risk of causing same-origin bypass CVE-2009-0801 vulnerability.
   Developer time is required to implement safe transit of these requests.
@@ -174,7 +177,7 @@ Most user-facing changes are reflected in squid.conf (see below).
    path and parameters as its own command parameters. The <em>concurrency</em> setting already
    existing in Squid is used to configure how many child helpers it may run.
 
-<p>For example, a traditional configration is
+<p>For example, a traditional configuration is
    <verb>
 	url_rewrite_program /your/redirector.sh
 	url_rewrite_children 5
@@ -203,10 +206,10 @@ Most user-facing changes are reflected in squid.conf (see below).
 <p>The on-demand helpers feature allows greater flexibility and resolves this problem by allowing
   maximum, initial and idle thresholds to be configured. Squid will start the initial set during
   start and reconfigure phases. However over the operational use new helpers up to the maxium will
-  be started as load demands. The idle threshold determins how many more helpers to start if the
+  be started as load demands. The idle threshold determines how many more helpers to start if the
   currently running set is not enough to handle current request loads.
 
-<p>For example, a traditional configration is
+<p>For example, a traditional configuration is
    <verb>
 	auth_param ntlm /usr/libexec/squid/ntlm_auth
 	auth_param ntlm children 200
@@ -257,7 +260,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 <sect2>External ACL helpers
 <p><itemize>
 	<item>mswin_check_ad_group - ext_ad_group_acl - Check logged in users Group membership using Active Directory.
-	<item>ip_user_check - ext_file_userip_acl - Restrict users to cetain IP addresses, using a text file backend.
+	<item>ip_user_check - ext_file_userip_acl - Restrict users to certain IP addresses, using a text file backend.
 	<item>squid_kerb_ldap - ext_kerberos_ldap_group_acl - Check logged in Kerberos or NTLM users Group membership using LDAP.
 	<item>squid_ldap_group - ext_ldap_group_acl - Check logged in users Group membership using LDAP.
 	<item>mswin_check_lm_group - ext_lm_group_acl - Check logged in users Group membership using LanManager.
@@ -302,8 +305,8 @@ Most user-facing changes are reflected in squid.conf (see below).
 <sect1>Solaris 10 pthreads Support (Experimental)
 <p>Automatic detection and use of the pthreads library available from Solaris 10
 
-<p>The result of this addition means that faster more efficient AUFS cache storage mechanisims
-  are now available in Solaris 10.
+<p>The result of this addition means that faster more efficient AUFS cache storage mechanism
+  is now available in Solaris 10.
 
 <p>Support is experimental at this stage due to lack of feedback on the results of enabling it.
   We recommend giving AUFS a try for faster disk storage and encourage feedback.
@@ -315,14 +318,14 @@ Most user-facing changes are reflected in squid.conf (see below).
   feature support in Squid. This release opens Surrogate support to all reverse proxies.
 
 <p>Reverse proxy requests sent on to the web server include the HTTP header <em>Surrogate-Capabilities:</em>
-  specifying the capabilities of the reverse proxy along with an ID which can be used to target reponses with
+  specifying the capabilities of the reverse proxy along with an ID which can be used to target responses with
   a <em>Surrogate-Control:</em> HTTP header used instead of the <em>Cache-Control:</em> header.
 
 <p>The default surrogate ID is generated automatically from the Squid site-unique hostname as found by the
   automatic detection or manual configuration of <em>visible_hostname</em> although can be configured
   separately with the <em>httpd_accel_surrogate_id</em> option.
 
-<p><em>Security Considerations:</em> Websites sould be careful of accepting any surrogate ID.
+<p><em>Security Considerations:</em> Websites should be careful of accepting any surrogate ID.
   Older releases of Squid leak the Surrogate-Control headers to external servers.
   This 3.2 series of Squid will now prevent this leakage of its own ID destined responses, however it is possible
   and for some uses desirable to receive external reverse-proxies <em>Surrogate-Capabilities:</em> headers.
@@ -428,7 +431,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 <itemize>
    <item>should contain a complete HTML page, with optional client-side scripting.
    <item>must not contain server-side scripting. 
-   <item>will have macro substitution performed on it using the same macros as used by the error page tempates.
+   <item>will have macro substitution performed on it using the same macros as used by the error page templates.
 </itemize>
 
 <p>Version 3.2 of the CGI cache manager tool now presents XHR scripted probes to detect
@@ -457,32 +460,32 @@ This section gives a thorough account of those changes in three categories:
 	   headers or eCAP options to Squid ICAP requests or eCAP transactions.
 
 	<tag>adaptation_send_client_ip</tag>
-	<p>Same as depricated icap_send_client_ip
+	<p>Same as deprecated icap_send_client_ip
 	   but applies to both ICAP and eCAP.</p>
 
 	<tag>adaptation_send_username</tag>
-	<p>Same as depricated icap_send_client_username
+	<p>Same as deprecated icap_send_client_username
 	   but applies to both ICAP and eCAP.</p>
 
 	<tag>adaptation_uses_indirect_client</tag>
-	<p>Same as depricated icap_uses_indirect_client
+	<p>Same as deprecated icap_uses_indirect_client
 	   but applies to both ICAP and eCAP.</p>
 
 	<tag>client_delay_pools</tag>
-	<p>New setting for client bandwith limits to specifies the number 
+	<p>New setting for client bandwidth limits to specifies the number 
 	  of client delay pools used.
 
 	<tag>client_delay_initial_bucket_level</tag>
-	<p>New setting for client bandwith limits to determine the initial 
+	<p>New setting for client bandwidth limits to determine the initial 
 	  bucket size as a percentage of  max_bucket_size from 
 	  client_delay_parameters.
             
 	<tag>client_delay_parameters</tag>
-	<p>New setting for client bandwith limits to configures client-side 
+	<p>New setting for client bandwidth limits to configures client-side 
 	   bandwidth limits.
 
 	<tag>client_delay_access</tag>
-	<p>New setting for client bandwith limits to determines the 
+	<p>New setting for client bandwidth limits to determines the 
 	  client-side delay pool for the request.
 
 	<tag>client_dst_passthru</tag>
@@ -589,17 +592,12 @@ This section gives a thorough account of those changes in three categories:
 	New installs, or installs with no logs configured explicitly will use this module by default.
 	<p>New <em>tcp</em> module to send each log line as text data to a TCP receiver.
 	<p>New <em>udp</em> module to send each log line as text data to a UDP receiver.
-	<p>New format <em>referrer</em> to log with the format prevously used by referer_log directive.
-	<p>New format <em>useragent</em> to log with the format prevously used by useragent_log directive.
+	<p>New format <em>referrer</em> to log with the format previously used by referer_log directive.
+	<p>New format <em>useragent</em> to log with the format previously used by useragent_log directive.
 
-	<tag>acl : random, localip, localport</tag>
+	<tag>acl : random, urllogin</tag>
 	<p>New type <em>random</em>. Pseudo-randomly match requests based on a configured probability.
-	<p>Renamed <em>myip</em> to <em>localip</em>. It matches the IP which the client connected to.
-	<p>Renamed <em>myport</em> to <em>localport</em>. It matches the port which the client connected to.
 	<p>Ported <em>urllogin</em> option from Squid 2.7, to match a regex pattern on the URL login field (if any).
-	<p>The <em>localip</em>/<em>localport</em> differ from earlier releases where they matched a mix of
-	   of an invalid IP and port 0, the client destination IP/port or the Squid listening IP/port.
-	   This definition is now consistent across all modes of traffic received by Squid.
 	<p>The <em>manager</em> ACL requires adjustment to cover new cache manager access. So it has now been
 	  built-in as a predefined ACL name matching URLs equivalent to the following regular expression:
         <verb>
@@ -609,7 +607,7 @@ This section gives a thorough account of those changes in three categories:
 
 	<tag>auth_param</tag>
 	<p>New options for Basic, Digest, NTLM, Negotiate <em>children</em> settings.
-	   <em>startup=N</em> determins minimum number of helper processes used.
+	   <em>startup=N</em> determines minimum number of helper processes used.
 	   <em>idle=N</em> determines how many helper to retain as buffer against sudden traffic loads.
 	   <em>concurrency=N</em> previously called <em>auth_param ... concurrency</em> as a separate option.
 	<p>Removed Basic, Digest, NTLM, Negotiate <em>auth_param ... concurrency</em> setting option.
@@ -643,8 +641,8 @@ This section gives a thorough account of those changes in three categories:
 	<p><em>%SRCEUI64</em> EUI-64 of clients with SLAAC address.
 	<p><em>%EXT_LOG</em> log= message returned by previous external ACL calls. An updated version may be returned.
 	<p><em>%EXT_TAG</em> tag= value returned by previous external ACL calls. Tag may not be altered once set.
-	<p><em>children-max=N</em> determins maximum number of helper processes used.
-	<p><em>children-startup=N</em> determins minimum number of helper processes used.
+	<p><em>children-max=N</em> determines maximum number of helper processes used.
+	<p><em>children-startup=N</em> determines minimum number of helper processes used.
 	<p><em>children-idle=N</em> determines how many helper to retain as buffer against sudden traffic loads.
 	<p>Deprecated <em>children=N</em> in favor of <em>children-max=N</em>.
 
@@ -870,16 +868,16 @@ This section gives an account of those changes in three categories:
 	<p>Replaced by --enable-eui
 
 	<tag>--enable-auth-basic-helpers</tag>
-	<p>replaced by <em>--enable-auth-basic</em>.
+	<p>Replaced by <em>--enable-auth-basic</em>.
 
 	<tag>--enable-auth-digest-helpers</tag>
-	<p>replaced by <em>--enable-auth-digest</em>.
+	<p>Replaced by <em>--enable-auth-digest</em>.
 
 	<tag>--enable-auth-negotiate-helpers</tag>
-	<p>replaced by <em>--enable-auth-negotiate</em>.
+	<p>Replaced by <em>--enable-auth-negotiate</em>.
 
 	<tag>--enable-auth-ntlm-helpers</tag>
-	<p>replaced by <em>--enable-auth-ntlm</em>.
+	<p>Replaced by <em>--enable-auth-ntlm</em>.
 
 	<tag>--enable-referer-log</tag>
 	<p>Obsolete.
@@ -909,7 +907,7 @@ This section gives an account of those changes in three categories:
 	  An external_acl_type helper may be used to bypass authentication if that is suitable.
 
 	<tag>cache_peer</tag>
-	<p><em>http11</em> Obsolete.
+	<p>Option <em>http11</em> obsolete.
 
 	<tag>external_acl_type</tag>
 	<p>Format tag <em>%{Header}</em> replaced by <em>%>{Header}</em>
@@ -919,9 +917,9 @@ This section gives an account of those changes in three categories:
 	<p>Replaced by <em>request_header_access</em> and <em>reply_header_access</em>
 
 	<tag>http_port</tag>
-	<p><em>no-connection-auth</em> replaced by <em>connection-auth=[on|off]</em>. Default is ON.
-	<p><em>transparent</em> option replaced by <em>intercept</em>
-	<p><em>http11</em> obsolete.
+	<p>Option <em>no-connection-auth</em> replaced by <em>connection-auth=[on|off]</em>. Default is ON.
+	<p>Option <em>transparent</em> option replaced by <em>intercept</em>
+	<p>Option <em>http11</em> obsolete.
 
 	<tag>http_access2</tag>
 	<p>Replaced by <em>adapted_http_access</em>
@@ -938,6 +936,12 @@ This section gives an account of those changes in three categories:
 	<tag>server_http11</tag>
 	<p>Obsolete.
 
+        <tag>update_headers</tag>
+	<p>Obsolete. The experimental actions enabled in 2.7 by this option have been integrated as default
+	   actions for the <em>rock</em> storage type and memory caches.
+	   The configuration option is no longer necessary and has been dropped.
+	   NOTE: It is not yet supported by <em>ufs</em>, <em>aufs</em>, or <em>diskd</em> storage.
+
 	<tag>upgrade_http0.9</tag>
 	<p>Obsolete.
 
@@ -1109,8 +1113,5 @@ This section gives an account of those changes in three categories:
 	<tag>storeurl_rewrite_program</tag>
 	<p>Not yet ported from 2.7
 	
-	<tag>update_headers</tag>
-	<p>Not yet fully ported from 2.7. Memory and rock storage caches support this natively. UFS caches do not support it.
-
 </descrip>
 </article>
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.0.2 release notes</title>
+<title>Squid 3.3.3 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,17 +13,22 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.0.2 for testing.
+The Squid Team are pleased to announce the release of Squid-3.3.3.
 
-This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
+<url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
-While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
+<p>A large number of the design flaws in SSL-Bump feature have been fixed along with general improvements all around.
+While this release is not fully bug-free we believe it is ready for use in production on many systems.
 
-We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d"> for how to submit a report with a stack trace.
+<p>We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
+ for how to submit a report with a stack trace.
 
 <sect1>Known issues
 <p>
-Although this release is deemed good enough for use in many setups, please note the existence of <url url="http://www.squid-cache.org/bugs/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.3&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" name="open bugs against Squid-3.3">.
+Although this release is deemed good enough for use in many setups, please note the existence of 
+<url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.3" name="open bugs against Squid-3.3">.
+
 
 <sect1>Changes since earlier releases of Squid-3.3
 <p>
@@ -184,16 +189,15 @@ This section gives a thorough account of those changes in three categories:
 	<tag>sslproxy_cert_adapt</tag>
 	<p>New option to adapt certain properties of outgoing SSL certificates generated for use when bumping SSL to an upstream server.
 
-
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
 	<tag>acl</tag>
-	<p><em>myport</em> and <em>myip</em>ACL types replaced with <em>localport</em> and <em>localip</em> respecitively.
+	<p><em>myport</em> and <em>myip</em>ACL types replaced with <em>localport</em> and <em>localip</em> respectively.
 	   To reflect that it matches the TCP connection details and not the squid.conf port.
-	   This matters when dealing with interecepted traffic, where the Squid receiving port differs from the TCP connection IP:port.
+	   This matters when dealing with intercepted traffic, where the Squid receiving port differs from the TCP connection IP:port.
 	   Always use <em>myportname</em> type to match the squid.conf port details.
 	<p>New default built-in ACLs for testing SSL certificate properties.
 	<p><em>ssl::certHasExpired</em>,
@@ -205,8 +209,8 @@ This section gives a thorough account of those changes in three categories:
 	<tag>logformat</tag>
 	<p>New token <em>%ssl::bump_mode</em> to log the SSL-bump mode type performed on a request.
 	  Logs values of: <em>-</em>, <em>none</em>, <em>client-first</em>, or <em>server-first</em>.
-	<p>New token of <em>%ssl::&gt;cert_subject</em> to log the Subject field of a SSL certficate received from the client.
-	<p>New token of <em>%ssl::&gt;cert_issuer</em> to log the Issuer field of a SSL certficate received from the client.
+	<p>New token of <em>%ssl::&gt;cert_subject</em> to log the Subject field of a SSL certificate received from the client.
+	<p>New token of <em>%ssl::&gt;cert_issuer</em> to log the Issuer field of a SSL certificate received from the client.
 
 	<tag>ssl_bump</tag>
 	<p>New action types <em>none</em>, <em>client-first</em>, <em>server-first</em>. The default is <em>none</em>.
@@ -220,7 +224,8 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
-	<p><em>There are no removed squid.conf tags in Squid-3.3.</em>
+
+	<p><em>There are no removed squid.conf options in Squid-3.3.</em>
 
 </descrip>
 
@@ -248,7 +253,14 @@ This section gives an account of those changes in three categories:
 <sect1>Changes to existing options<label id="modifiedoptions">
 <p>
 <descrip>
-	<p><em>There are no changed ./configure options in Squid-3.3.</em>
+	<tag>--enable-kqueue</tag>
+	<p>kqueue network I/O module is now built by default when it is available.
+	   This option is no longer required to enable kqueue support,
+	   but if used will abort build when kqueue dependencies are missing or broken.
+
+	<tag>--disable-kqueue</tag>
+	<p>kqueue network I/O module is now built by default when it is available.
+	   This configure option is now needed to disable it. Previously it did nothing.
 
 </descrip>
 </p>
@@ -342,9 +354,6 @@ This section gives an account of those changes in three categories:
 	<tag>storeurl_rewrite_program</tag>
 	<p>Not yet ported from 2.7
 	
-	<tag>update_headers</tag>
-	<p>Not yet ported from 2.7
-
 </descrip>
 
 </article>
@@ -2,14 +2,14 @@
 <HTML>
 <HEAD>
  <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
- <TITLE>Squid 3.3.0.0 release notes</TITLE>
+ <TITLE>Squid 3.4.0.0 release notes</TITLE>
 </HEAD>
 <BODY>
-<H1>Squid 3.3.0.0 release notes</H1>
+<H1>Squid 3.4.0.0 release notes</H1>
 
 <H2>Squid Developers</H2>
 <HR>
-<EM>This document contains the release notes for version 3.3 of Squid.
+<EM>This document contains the release notes for version 3.4 of Squid.
 Squid is a WWW Cache application developed by the National Laboratory
 for Applied Network Research and members of the Web Caching community.</EM>
 <HR>
@@ -18,52 +18,44 @@ <H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
 
 <UL>
 <LI><A NAME="toc1.1">1.1</A> <A HREF="#ss1.1">Known issues</A>
-<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-3.3</A>
+<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-3.4</A>
 </UL>
 <P>
-<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.2</A></H2>
+<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></H2>
 
 <UL>
-<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1"></A>
+<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
+<LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
 </UL>
 <P>
-<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.2</A></H2>
+<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <UL>
 <LI><A NAME="toc3.1">3.1</A> <A HREF="#ss3.1">New tags</A>
 <LI><A NAME="toc3.2">3.2</A> <A HREF="#ss3.2">Changes to existing tags</A>
 <LI><A NAME="toc3.3">3.3</A> <A HREF="#ss3.3">Removed tags</A>
 </UL>
 <P>
-<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.2</A></H2>
+<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.3</A></H2>
 
 <UL>
 <LI><A NAME="toc4.1">4.1</A> <A HREF="#ss4.1">New options</A>
 <LI><A NAME="toc4.2">4.2</A> <A HREF="#ss4.2">Changes to existing options</A>
 <LI><A NAME="toc4.3">4.3</A> <A HREF="#ss4.3">Removed options</A>
 </UL>
 <P>
-<H2><A NAME="toc5">5.</A> <A HREF="#s5">Options Removed since Squid-2</A></H2>
+<H2><A NAME="toc5">5.</A> <A HREF="#s5">Regressions since Squid-2.7</A></H2>
 
 <UL>
-<LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Removed squid.conf options since Squid-2.7</A>
-<LI><A NAME="toc5.2">5.2</A> <A HREF="#ss5.2">Removed squid.conf options since Squid-2.6</A>
-<LI><A NAME="toc5.3">5.3</A> <A HREF="#ss5.3">Removed ./configure options since Squid-2.7</A>
-</UL>
-<P>
-<H2><A NAME="toc6">6.</A> <A HREF="#s6">Regressions since Squid-2.7</A></H2>
-
-<UL>
-<LI><A NAME="toc6.1">6.1</A> <A HREF="#ss6.1">Missing squid.conf options available in Squid-2.7</A>
-<LI><A NAME="toc6.2">6.2</A> <A HREF="#ss6.2">Missing ./configure options available in Squid-2.7</A>
+<LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Missing squid.conf options available in Squid-2.7</A>
 </UL>
 
 <HR>
 <H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
 
-<P>The Squid Team are pleased to announce the release of Squid-3.3.0.0 for testing.</P>
+<P>The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.</P>
 <P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.3/">http://www.squid-cache.org/Versions/v3/3.3/</A> or the 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the 
 <A HREF="http://www.squid-cache.org/Mirrors/http-mirrors.html">mirrors</A>.</P>
 <P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
 <P>We welcome feedback and bug reports. If you find a bug, please see 
@@ -73,34 +65,86 @@ <H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
 </H2>
 
 <P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://www.squid-cache.org/bugs/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.3&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">open bugs against Squid-3.3</A>.</P>
+<A HREF="http://www.squid-cache.org/bugs/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.4&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">open bugs against Squid-3.4</A>.</P>
 
-<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.3</A>
+<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.4</A>
 </H2>
 
-<P>The 3.3 change history can be 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.3/changesets/">viewed here</A>.</P>
+<P>The 3.4 change history can be 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/changesets/">viewed here</A>.</P>
 
-<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.2</A></H2>
+<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></H2>
 
-<P>Squid 3.3 represents a new feature release above 3.2.</P>
+<P>Squid 3.4 represents a new feature release above 3.3.</P>
 
 <P>The most important of these new features are:
 <UL>
-<LI></LI>
+<LI>Helper protocol extensions</LI>
+<LI>SSL Server Certificate Validator</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
 
-<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1"></A>
+
+<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Helper protocol extensions</A>
 </H2>
 
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<P>The Squid helper protocol used to communicate with authenticators,
+URL-rewriters, Redirectors, and External ACL helpers has been updated
+and extended.</P>
 
+<P><EM>BH</EM> status code is now accepted from all helpers to report
+internal error events separate from <EM>ERR</EM> rejection code.
+Permitting Squid to perform recovery operations specific to
+helper failure instead of a blanket client rejection.</P>
 
+<P>Arbitrary key-value pairs can be returned from any helper.
+Allowing future helpers to be forward- and backward- compatible
+with this and future version of Squid.</P>
 
-<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.2</A></H2>
 
-<P>There have been changes to Squid's configuration file since Squid-3.2.</P>
+<H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/SslServerCertValidator">http://wiki.squid-cache.org/Features/SslServerCertValidator</A>.</P>
+
+<P>The helper consulted after the internal OpenSSL validation, regardless of the
+validation results. The helper will receive:</P>
+<P>
+<UL>
+<LI>the origin server certificate (chain),</LI>
+<LI>the intended domain name, and</LI>
+<LI>a list of OpenSSL validation errors (if any).</LI>
+</UL>
+</P>
+
+<P>If the helper decides to honor an OpenSSL error or report another validation 
+error(s), the helper will return:</P>
+<P>
+<UL>
+<LI>A list of certificates.</LI>
+<LI>A list of items consists the the validation error name (see <EM>%err_name</EM>
+error page macro and <EM>%err_details</EM> code for <EM>logformat</EM>), error reason
+(<EM>%ssl_lib_error macro</EM>), and the offending certificate.</LI>
+</UL>
+</P>
+
+<P>The returned information mimics what the internal OpenSSL-based validation code
+collects now. Returned errors, if any, are fed to <EM>sslproxy_cert_error</EM>,
+triggering the existing SSL error processing code.</P>
+
+<P>The helper invocation controlled by the <EM>sslcrtvalidator_program</EM> and
+<EM>sslcrtvalidator_children</EM> configurations options which are similar to the
+<EM>ssl_crtd</EM> related options. </P>
+
+
+<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
+
+<P>There have been changes to Squid's configuration file since Squid-3.3.</P>
 <P>This section gives a thorough account of those changes in three categories:</P>
 <P>
 <UL>
@@ -119,6 +163,16 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 
 <P>
 <DL>
+<DT><B>note</B><DD>
+<P>Use ACLs to annotate a transaction with customized annotations
+which can be logged in access.log</P>
+
+<DT><B>sslcrtvalidator_children</B><DD>
+<P>Specifies the settings for how many SSL server certificate
+validator helpers are run and when they are started.</P>
+
+<DT><B>sslcrtvalidator_program</B><DD>
+<P>Specifies the location of a SSL server certificate validator helper.</P>
 
 </DL>
 </P>
@@ -128,24 +182,62 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 
 <P>
 <DL>
+<DT><B>acl</B><DD>
+<P>New test type <EM>server_cert_fingerprint</EM> to match against 
+server SSL certificate fingerprint.</P>
+
+<DT><B>auth_param</B><DD>
+<P>New result code <EM>BH</EM> to signal helper internal errors
+available in all authentication schemes.</P>
+<P>New key <EM>message=</EM> for error message details in all authentication schemes.</P>
+<P>New result code <EM>OK</EM> and key <EM>ha1=</EM> in Digest authentication.</P>
+<P>New result codes <EM>OK</EM>, <EM>ERR</EM> replace result codes <EM>AF</EM>,
+and <EM>NA</EM> in NTLM and Negotiate authentication.</P>
+<P>New key <EM>token=</EM> for NTLM and Negotiate authentication <EM>OK</EM> responses.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<DT><B>external_acl_type</B><DD>
+<P>Deprecated <EM>protocol=3.0</EM> option. No longer necessary.</P>
+<P>New result code <EM>BH</EM> to signal helper internal errors</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<DT><B>logformat</B><DD>
+<P>New format code <EM>%note</EM> to log a transaction annotation linked to the
+transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
+
+<DT><B>unlinkd_program</B><DD>
+<P>New helper response format utilizing result codes <EM>OK</EM> and <EM>BH</EM>,
+to signal helper lookup results. Also, key-value response values to return
+multiple values to Squid.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<DT><B>url_rewrite_program</B><DD>
+<P>New helper response format utilizing result codes <EM>OK</EM>, <EM>ERR</EM>,
+and <EM>BH</EM> to signal helper lookup results. Also, key-value response
+values to return multiple values to Squid.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
 </DL>
 </P>
 
-
 <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed tags</A>
 </H2>
 
 <P>
 <DL>
+<P><EM>There are no removed squid.conf tags in Squid-3.4.</EM></P>
 
 </DL>
 </P>
 
 
-<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.2</A></H2>
+<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.3</A></H2>
 
-<P>There have been some changes to Squid's build configuration since Squid-3.2.</P>
+<P>There have been some changes to Squid's build configuration since Squid-3.3.</P>
 <P>This section gives an account of those changes in three categories:</P>
 <P>
 <UL>
@@ -164,6 +256,7 @@ <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New opti
 
 <P>
 <DL>
+<P><EM>There are no new ./configure options in Squid-3.4.</EM></P>
 
 </DL>
 </P>
@@ -173,6 +266,7 @@ <H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Cha
 
 <P>
 <DL>
+<P><EM>There are no changed ./configure options in Squid-3.4.</EM></P>
 
 </DL>
 </P>
@@ -181,163 +275,23 @@ <H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Remo
 
 <P>
 <DL>
+<P><EM>There are no removed ./configure options in Squid-3.4.</EM></P>
 
 </DL>
 </P>
 
 
-<H2><A NAME="s5">5.</A> <A HREF="#toc5">Options Removed since Squid-2</A></H2>
-
-<P>Some squid.conf and ./configure options which were available in Squid-2.6 and Squid-2.7 are made obsolete in Squid-3.3.</P>
-
-<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Removed squid.conf options since Squid-2.7</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>auth_param</B><DD>
-<P><EM>blankpassword</EM> option for basic scheme removed.</P>
-
-<DT><B>cache_peer</B><DD>
-<P><EM>http11</EM> Obsolete.</P>
-
-<DT><B>external_acl_type</B><DD>
-<P>Format tag <EM>%{Header}</EM> replaced by <EM>%>{Header}</EM></P>
-<P>Format tag <EM>%{Header:member}</EM> replaced by <EM>%>{Header:member}</EM></P>
-
-<DT><B>header_access</B><DD>
-<P>Replaced by <EM>request_header_access</EM> and <EM>reply_header_access</EM></P>
-
-<DT><B>http_port</B><DD>
-<P><EM>no-connection-auth</EM> replaced by <EM>connection-auth=[on|off]</EM>. Default is ON.</P>
-<P><EM>transparent</EM> option replaced by <EM>intercept</EM></P>
-<P><EM>http11</EM> obsolete.</P>
-
-<DT><B>http_access2</B><DD>
-<P>Replaced by <EM>adapted_http_access</EM></P>
-
-<DT><B>httpd_accel_no_pmtu_disc</B><DD>
-<P>Replaced by <EM>http_port disable-pmtu-discovery=</EM> option</P>
-
-<DT><B>incoming_rate</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>redirector_bypass</B><DD>
-<P>Replaced by <EM>url_rewrite_bypass</EM></P>
-
-<DT><B>server_http11</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>upgrade_http0.9</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>zph_local</B><DD>
-<P>Replaced by <EM>qos_flows local-hit=</EM></P>
-
-<DT><B>zph_mode</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>zph_option</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>zph_parent</B><DD>
-<P>Replaced by <EM>qos_flows parent-hit=</EM></P>
-
-<DT><B>zph_sibling</B><DD>
-<P>Replaced by <EM>qos_flows sibling-hit=</EM></P>
-
-</DL>
-</P>
-
-<H2><A NAME="ss5.2">5.2</A> <A HREF="#toc5.2">Removed squid.conf options since Squid-2.6</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>cache_dir</B><DD>
-<P><EM>read-only</EM> option replaced by <EM>no-store</EM>.</P>
-
-</DL>
-</P>
-
-<H2><A NAME="ss5.3">5.3</A> <A HREF="#toc5.3">Removed ./configure options since Squid-2.7</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>--enable-coss-aio-ops</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-devpoll</B><DD>
-<P>Replaced by automatic detection.</P>
-
-<DT><B>--enable-dlmalloc=LIB</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-epoll</B><DD>
-<P>Replaced by automatic detection.</P>
-
-<DT><B>--enable-forward-log</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-heap-replacement</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-htcp</B><DD>
-<P>Obsolete. Enabled by default.</P>
-
-<DT><B>--enable-large-cache-files</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-mempool-debug</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-multicast-miss</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--enable-poll</B><DD>
-<P>Replaced by automatic detection.</P>
-
-<DT><B>--enable-select</B><DD>
-<P>Replaced by automatic detection.</P>
-
-<DT><B>--enable-select-simple</B><DD>
-<P>Replaced by automatic detection.</P>
-
-<DT><B>--enable-snmp</B><DD>
-<P>Obsolete. Enabled by default.</P>
-
-<DT><B>--enable-truncate</B><DD>
-<P>Obsolete.</P>
-
-<DT><B>--disable-kqueue</B><DD>
-<P>Obsolete. Disabled by default.</P>
-
-</DL>
-</P>
-
-
-<H2><A NAME="s6">6.</A> <A HREF="#toc6">Regressions since Squid-2.7</A></H2>
+<H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
 
 <P>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3</P>
 
 <P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
 
-<H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Missing squid.conf options available in Squid-2.7</A>
+<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options available in Squid-2.7</A>
 </H2>
 
 <P>
 <DL>
-<DT><B>acl</B><DD>
-<P><EM>urllogin</EM> option not yet ported from 2.6</P>
-<P><EM>urlgroup</EM> option not yet ported from 2.6</P>
-
-<DT><B>authenticate_ip_shortcircuit_access</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>authenticate_ip_shortcircuit_ttl</B><DD>
-<P>Not yet ported from 2.7</P>
-
 <DT><B>broken_vary_encoding</B><DD>
 <P>Not yet ported from 2.6</P>
 
@@ -373,7 +327,6 @@ <H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Missing squid.conf options availab
 
 <DT><B>http_port</B><DD>
 <P><EM>act-as-origin</EM> not yet ported from 2.7</P>
-<P><EM>urlgroup=</EM> not yet ported from 2.6</P>
 
 <DT><B>ignore_ims_on_miss</B><DD>
 <P>Not yet ported from 2.7</P>
@@ -390,9 +343,6 @@ <H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Missing squid.conf options availab
 <DT><B>location_rewrite_program</B><DD>
 <P>Not yet ported from 2.6</P>
 
-<DT><B>logformat</B><DD>
-<P><EM>%oa</EM> tag not yet ported from 2.7</P>
-
 <DT><B>refresh_pattern</B><DD>
 <P><EM>stale-while-revalidate=</EM> not yet ported from 2.7</P>
 <P><EM>ignore-stale-while-revalidate=</EM> not yet ported from 2.7</P>
@@ -416,19 +366,6 @@ <H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Missing squid.conf options availab
 <DT><B>update_headers</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>zero_buffers</B><DD>
-<P>Not yet ported from 2.7</P>
-
-</DL>
-</P>
-
-<H2><A NAME="ss6.2">6.2</A> <A HREF="#toc6.2">Missing ./configure options available in Squid-2.7</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>--without-system-md5</B><DD>
-
 </DL>
 </P>
 
@@ -0,0 +1,294 @@
+<!doctype linuxdoc system>
+<article>
+<title>Squid 3.4.0.0 release notes</title>
+<author>Squid Developers</author>
+
+<abstract>
+This document contains the release notes for version 3.4 of Squid.
+Squid is a WWW Cache application developed by the National Laboratory
+for Applied Network Research and members of the Web Caching community.
+</abstract>
+
+<toc>
+
+<sect>Notice
+<p>
+The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.
+
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.HEAD/"> or the
+ <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+
+While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
+
+We welcome feedback and bug reports. If you find a bug, please see <url url="http://wiki.squid-cache.org/SquidFaq/BugReporting">
+ for how to submit a report with a stack trace.
+
+<sect1>Known issues
+<p>
+Although this release is deemed good enough for use in many setups, please note the existence of 
+<url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4" name="open bugs against Squid-3.4">.
+
+
+<sect1>Changes since earlier releases of Squid-3.4
+<p>
+The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.HEAD/changesets/" name="viewed here">.
+
+<sect>Major new features since Squid-3.3
+<p>Squid 3.4 represents a new feature release above 3.3.
+
+<p>The most important of these new features are:
+<itemize>
+	<item>Helper protocol extensions
+	<item>SSL Server Certificate Validator
+</itemize>
+
+Most user-facing changes are reflected in squid.conf (see below).
+
+
+<sect1>Helper protocol extensions
+<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
+
+<p>The Squid helper protocol used to communicate with authenticators,
+   URL-rewriters, Redirectors, and External ACL helpers has been updated
+   and extended.
+
+<p><em>BH</em> status code is now accepted from all helpers to report
+   internal error events separate from <em>ERR</em> rejection code.
+   Permitting Squid to perform recovery operations specific to
+   helper failure instead of a blanket client rejection.
+
+<p>Arbitrary key-value pairs can be returned from any helper.
+   Allowing future helpers to be forward- and backward- compatible
+   with this and future version of Squid.
+
+
+<sect1>SSL Server Certificate Validator
+<p>Details at <url url="http://wiki.squid-cache.org/Features/SslServerCertValidator">.
+
+<p>The helper consulted after the internal OpenSSL validation, regardless of the
+   validation results. The helper will receive:
+
+<itemize>
+	<item>the origin server certificate (chain),
+	<item>the intended domain name, and
+	<item>a list of OpenSSL validation errors (if any).
+</itemize>
+
+<p>If the helper decides to honor an OpenSSL error or report another validation 
+   error(s), the helper will return:
+
+<itemize>
+	<item>A list of certificates.
+	<item>A list of items consists the the validation error name (see <em>%err_name</em>
+        error page macro and <em>%err_details</em> code for <em>logformat</em>), error reason
+        (<em>%ssl_lib_error macro</em>), and the offending certificate.
+</itemize>
+
+<p>The returned information mimics what the internal OpenSSL-based validation code
+   collects now. Returned errors, if any, are fed to <em>sslproxy_cert_error</em>,
+   triggering the existing SSL error processing code.
+
+<p>The helper invocation controlled by the <em>sslcrtvalidator_program</em> and
+   <em>sslcrtvalidator_children</em> configurations options which are similar to the
+   <em>ssl_crtd</em> related options. 
+
+
+<sect>Changes to squid.conf since Squid-3.3
+<p>
+There have been changes to Squid's configuration file since Squid-3.3.
+
+This section gives a thorough account of those changes in three categories:
+
+<itemize>
+	<item><ref id="newtags" name="New tags">
+	<item><ref id="modifiedtags" name="Changes to existing tags">
+	<item><ref id="removedtags" name="Removed tags">
+</itemize>
+<p>
+
+<sect1>New tags<label id="newtags">
+<p>
+<descrip>
+	<tag>note</tag>
+	<p>Use ACLs to annotate a transaction with customized annotations
+	   which can be logged in access.log
+
+	<tag>sslcrtvalidator_children</tag>
+	<p>Specifies the settings for how many SSL server certificate
+	   validator helpers are run and when they are started.
+
+	<tag>sslcrtvalidator_program</tag>
+	<p>Specifies the location of a SSL server certificate validator helper.
+
+</descrip>
+
+<sect1>Changes to existing tags<label id="modifiedtags">
+<p>
+<descrip>
+	<tag>acl</tag>
+	<p>New test type <em>server_cert_fingerprint</em> to match against 
+	   server SSL certificate fingerprint.
+
+	<tag>auth_param</tag>
+	<p>New result code <em>BH</em> to signal helper internal errors
+	   available in all authentication schemes.
+	<p>New key <em>message=</em> for error message details in all authentication schemes.
+	<p>New result code <em>OK</em> and key <em>ha1=</em> in Digest authentication.
+	<p>New result codes <em>OK</em>, <em>ERR</em> replace result codes <em>AF</em>,
+	   and <em>NA</em> in NTLM and Negotiate authentication.
+	<p>New key <em>token=</em> for NTLM and Negotiate authentication <em>OK</em> responses.
+	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
+
+	<tag>external_acl_type</tag>
+	<p>Deprecated <em>protocol=3.0</em> option. No longer necessary.
+	<p>New result code <em>BH</em> to signal helper internal errors
+	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
+
+	<tag>logformat</tag>
+	<p>New format code <em>%note</em> to log a transaction annotation linked to the
+	   transaction by ICAP, eCAP, a helper, or the <em>note</em> squid.conf directive.
+
+	<tag>unlinkd_program</tag>
+	<p>New helper response format utilizing result codes <em>OK</em> and <em>BH</em>,
+	   to signal helper lookup results. Also, key-value response values to return
+	   multiple values to Squid.
+	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
+
+	<tag>url_rewrite_program</tag>
+	<p>New helper response format utilizing result codes <em>OK</em>, <em>ERR</em>,
+	   and <em>BH</em> to signal helper lookup results. Also, key-value response
+	   values to return multiple values to Squid.
+	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
+
+</descrip>
+
+<sect1>Removed tags<label id="removedtags">
+<p>
+<descrip>
+	<p><em>There are no removed squid.conf tags in Squid-3.4.</em>
+
+</descrip>
+
+
+<sect>Changes to ./configure options since Squid-3.3
+<p>
+There have been some changes to Squid's build configuration since Squid-3.3.
+
+This section gives an account of those changes in three categories:
+
+<itemize>
+	<item><ref id="newoptions" name="New options">
+	<item><ref id="modifiedoptions" name="Changes to existing options">
+	<item><ref id="removedoptions" name="Removed options">
+</itemize>
+
+
+<sect1>New options<label id="newoptions">
+<p>
+<descrip>
+	<p><em>There are no new ./configure options in Squid-3.4.</em>
+
+</descrip>
+
+<sect1>Changes to existing options<label id="modifiedoptions">
+<p>
+<descrip>
+	<p><em>There are no changed ./configure options in Squid-3.4.</em>
+
+</descrip>
+</p>
+
+<sect1>Removed options<label id="removedoptions">
+<p>
+<descrip>
+	<p><em>There are no removed ./configure options in Squid-3.4.</em>
+
+</descrip>
+
+
+<sect>Regressions since Squid-2.7
+
+<p>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3
+
+<p>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.
+
+<sect1>Missing squid.conf options available in Squid-2.7
+<p>
+<descrip>
+	<tag>broken_vary_encoding</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>cache_dir</tag>
+	<p><em>COSS</em> storage type is lacking stability fixes from 2.6
+	<p>COSS <em>overwrite-percent=</em> option not yet ported from 2.6
+	<p>COSS <em>max-stripe-waste=</em> option not yet ported from 2.6
+	<p>COSS <em>membufs=</em> option not yet ported from 2.6
+	<p>COSS <em>maxfullbufs=</em> option not yet ported from 2.6
+
+	<tag>cache_peer</tag>
+	<p><em>idle=</em> not yet ported from 2.7
+	<p><em>monitorinterval=</em> not yet ported from 2.6
+	<p><em>monitorsize=</em> not yet ported from 2.6
+	<p><em>monitortimeout=</em> not yet ported from 2.6
+	<p><em>monitorurl=</em> not yet ported from 2.6
+
+	<tag>cache_vary</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>collapsed_forwarding</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>error_map</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>external_acl_type</tag>
+	<p><em>%ACL</em> format tag not yet ported from 2.6
+	<p><em>%DATA</em> format tag not yet ported from 2.6
+
+	<tag>external_refresh_check</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>http_port</tag>
+	<p><em>act-as-origin</em> not yet ported from 2.7
+
+	<tag>ignore_ims_on_miss</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>location_rewrite_access</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>location_rewrite_children</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>location_rewrite_concurrency</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>location_rewrite_program</tag>
+	<p>Not yet ported from 2.6
+
+	<tag>refresh_pattern</tag>
+	<p><em>stale-while-revalidate=</em> not yet ported from 2.7
+	<p><em>ignore-stale-while-revalidate=</em> not yet ported from 2.7
+	<p><em>negative-ttl=</em> not yet ported from 2.7
+
+	<tag>refresh_stale_hit</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>storeurl_access</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>storeurl_rewrite_children</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>storeurl_rewrite_concurrency</tag>
+	<p>Not yet ported from 2.7
+
+	<tag>storeurl_rewrite_program</tag>
+	<p>Not yet ported from 2.7
+	
+	<tag>update_headers</tag>
+	<p>Not yet ported from 2.7
+
+</descrip>
+
+</article>
@@ -122,7 +122,7 @@ ProcessLine(char *Linebuf)
         return;
 
     /* Check for server line. Check for 3 parameters. */
-    if (strcasecmp(Directive, "server") == 0) {
+    if (strcmp(Directive, "server") == 0) {
         Param1 = strtok(NULL, " \t\n");
         if (NULL == Param1) {
             syslog(LOG_ERR, "ProcessLine: 'server' missing PDC parameter.");
@@ -142,7 +142,7 @@ ProcessLine(char *Linebuf)
         return;
     }
     /* Check for denyusers line */
-    if (strcasecmp(Directive, "denyusers") == 0) {
+    if (strcmp(Directive, "denyusers") == 0) {
         Param1 = strtok(NULL, " \t\n");
 
         if (NULL == Param1) {
@@ -154,7 +154,7 @@ ProcessLine(char *Linebuf)
         return;
     }
     /* Check for allowusers line */
-    if (strcasecmp(Directive, "allowusers") == 0) {
+    if (strcmp(Directive, "allowusers") == 0) {
         Param1 = strtok(NULL, " \t\n");
 
         if (NULL == Param1) {
@@ -158,6 +158,7 @@ static void usage(char *program)
     fprintf(stderr, "           to authenticate all users\n");
     fprintf(stderr, " -o        Do not perform account mgmt (account expiration etc)\n");
     fprintf(stderr, " -1        Only one user authentication per PAM connection\n");
+    fprintf(stderr, " -r        Detect and remove Negotiate/NTLM realm from username\n");
 }
 
 int
@@ -172,12 +173,13 @@ main(int argc, char *argv[])
     int ttl = DEFAULT_SQUID_PAM_TTL;
     const char *service = DEFAULT_SQUID_PAM_SERVICE;
     int no_acct_mgmt = 0;
+    int no_realm = 0;
 
     /* make standard output line buffered */
     setvbuf(stdout, NULL, _IOLBF, 0);
 
     while (1) {
-        int ch = getopt(argc, argv, "1n:t:o");
+        int ch = getopt(argc, argv, "1n:t:or");
         switch (ch) {
         case -1:
             goto start;
@@ -193,6 +195,9 @@ main(int argc, char *argv[])
         case 'o':
             no_acct_mgmt = 1;
             break;
+        case 'r':
+            no_realm = 1;
+            break;
         default:
             fprintf(stderr, "FATAL: Unknown getopt value '%c'\n", ch);
             usage(argv[0]);
@@ -225,6 +230,18 @@ main(int argc, char *argv[])
         rfc1738_unescape(password_buf);
         conv.appdata_ptr = (char *) password_buf;	/* from buf above. not allocated */
 
+        if (no_realm) {
+            /* Remove DOMAIN\.. and ...@domain from the user name in case the user
+             * thought this was an NTLM or Negotiate authentication popup box
+             */
+            char * user_ptr = strchr(user, '@');
+            if (user_ptr) *user_ptr = 0;
+            else {
+                user_ptr = strchr(user, '\\');
+                if (user_ptr) user = user_ptr + 1;
+            }
+        }
+
 #if _SQUID_SOLARIS_
         /* Workaround for Solaris 2.6 where the PAM library is broken
          * and does not pass appdata_ptr to the conversation routine
@@ -147,7 +147,7 @@ while (<>) {
 
     $status = "ERR";
     $cid =~ s/%(..)/pack("H*", $1)/ge;
-    $uid =~ s/%(..)/pack("H*", $2)/ge;
+    $uid =~ s/%(..)/pack("H*", $1)/ge;
 
     print(stderr "Received: Channel=".$cid.", UID='".$uid."'\n") if ($debug);
 
@@ -977,7 +977,7 @@ ConvertIP(edui_ldap_t *l, char *ip)
                     if (bufb[i] == ':')
                         ++j;
                 }
-                --j;								/* Preceeding "::" doesn't count */
+                --j;								/* Preceding "::" doesn't count */
                 t = 8 - (strlen(l->search_ip) / 4) - j;			/* Remainder */
                 if (t > 0) {
                     for (i = 0; i < t; ++i)
@@ -388,6 +388,11 @@ create_gd(struct main_args *margs)
                 cleanup();
                 return (1);
             }
+            if (dp) {  /* end of domain name - twice */
+                debug((char *) "%s| %s: @ is not allowed in group name %s@%s\n",LogTime(), PROGRAM,gp,dp);
+                cleanup();
+                return(1);
+            }
             *p = '\0';
             ++p;
             gdsp = init_gd();
@@ -109,9 +109,6 @@ ldap_sasl_rebind(
     void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
-    url = url;
-    request = request;
-    msgid = msgid;
     return tool_sasl_bind(ld, cp->dn, cp->pw);
 }
 #endif
@@ -127,9 +124,6 @@ ldap_simple_rebind(
     void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
-    url = url;
-    request = request;
-    msgid = msgid;
     return ldap_bind_s(ld, cp->dn, cp->pw, LDAP_AUTH_SIMPLE);
 }
 
@@ -192,9 +186,6 @@ ldap_sasl_rebind(
     void *params)
 {
     struct ldap_creds *cp = (struct ldap_creds *) params;
-    url = url;
-    request = request;
-    msgid = msgid;
     return tool_sasl_bind(ld, cp->dn, cp->pw);
 }
 #endif
@@ -211,9 +202,6 @@ ldap_simple_rebind(
 {
 
     struct ldap_creds *cp = (struct ldap_creds *) params;
-    url = url;
-    request = request;
-    msgid = msgid;
     return ldap_bind_s(ld, cp->dn, cp->pw, LDAP_AUTH_SIMPLE);
 }
 
@@ -1165,8 +1153,10 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
             debug((char *) "%s| %s: DEBUG: Users primary group %s %s\n", LogTime(), PROGRAM, retval ? "matches" : "does not match", group);
 
-        } else
+        } else {
+            ldap_msgfree(res);
             debug((char *) "%s| %s: DEBUG: Did not find ldap entry for group %s\n", LogTime(), PROGRAM, group);
+        }
         /*
          * Cleanup
          */
@@ -88,6 +88,11 @@ create_ls(struct main_args *margs)
                 free_ls(lssp);
                 return (1);
             }
+            if (dp) {  /* end of domain name - twice */
+                debug((char *) "%s| %s: @ is not allowed in server name %s@%s\n",LogTime(), PROGRAM,np,dp);
+                free_ls(lssp);
+                return(1);
+            }
             *p = '\0';
             ++p;
             lssp = init_ls();
@@ -89,6 +89,11 @@ create_nd(struct main_args *margs)
                 free_nd(ndsp);
                 return (1);
             }
+            if (dp) {  /* end of domain name - twice */
+                debug((char *) "%s| %s: @ is not allowed in netbios name %s@%s\n",LogTime(), PROGRAM,np,dp);
+                free_nd(ndsp);
+                return(1);
+            }
             *p = '\0';
             ++p;
             ndsp = init_nd();
@@ -297,10 +297,10 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
             if ((len = res_search(service, ns_c_in, ns_t_srv, (u_char *) buffer, PACKETSZ_MULT * NS_PACKETSZ)) < 0) {
                 error((char *) "%s| %s: ERROR: Error while resolving service record %s with res_search\n", LogTime(), PROGRAM, service);
                 nsError(h_errno, service);
-                goto cleanup;
+                goto finalise;
             }
         } else {
-            goto cleanup;
+            goto finalise;
         }
     }
     if (len > PACKETSZ_MULT * NS_PACKETSZ) {
@@ -309,70 +309,70 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         if ((len = res_search(service, ns_c_in, ns_t_srv, (u_char *) buffer, len)) < 0) {
             error((char *) "%s| %s: ERROR: Error while resolving service record %s with res_search\n", LogTime(), PROGRAM, service);
             nsError(h_errno, service);
-            goto cleanup;
+            goto finalise;
         }
         if (len > olen) {
             error((char *) "%s| %s: ERROR: Reply to big: buffer: %d reply length: %d\n", LogTime(), PROGRAM, olen, len);
-            goto cleanup;
+            goto finalise;
         }
     }
     p = buffer;
     p += 6 * NS_INT16SZ;	/* Header(6*16bit) = id + flags + 4*section count */
     if (p > buffer + len) {
         error((char *) "%s| %s: ERROR: Message to small: %d < header size\n", LogTime(), PROGRAM, len);
-        goto cleanup;
+        goto finalise;
     }
     if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
         error((char *) "%s| %s: ERROR: Error while expanding query name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
-        goto cleanup;
+        goto finalise;
     }
     p += size;			/* Query name */
     p += 2 * NS_INT16SZ;	/* Query type + class (2*16bit) */
     if (p > buffer + len) {
         error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class \n", LogTime(), PROGRAM, len);
-        goto cleanup;
+        goto finalise;
     }
     while (p < buffer + len) {
         if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
             error((char *) "%s| %s: ERROR: Error while expanding answer name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
-            goto cleanup;
+            goto finalise;
         }
         p += size;		/* Resource Record name */
         if (p > buffer + len) {
             error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name\n", LogTime(), PROGRAM, len);
-            goto cleanup;
+            goto finalise;
         }
         NS_GET16(type, p);	/* RR type (16bit) */
         p += NS_INT16SZ + NS_INT32SZ;	/* RR class + ttl (16bit+32bit) */
         if (p > buffer + len) {
             error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl\n", LogTime(), PROGRAM, len);
-            goto cleanup;
+            goto finalise;
         }
         NS_GET16(rdlength, p);	/* RR data length (16bit) */
 
         if (type == ns_t_srv) {	/* SRV record */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl + RR data length\n", LogTime(), PROGRAM, len);
-                goto cleanup;
+                goto finalise;
             }
             NS_GET16(priority, p);	/* Priority (16bit) */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority\n", LogTime(), PROGRAM, len);
-                goto cleanup;
+                goto finalise;
             }
             NS_GET16(weight, p);	/* Weight (16bit) */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority + weight\n", LogTime(), PROGRAM, len);
-                goto cleanup;
+                goto finalise;
             }
             NS_GET16(port, p);	/* Port (16bit) */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority + weight + port\n", LogTime(), PROGRAM, len);
-                goto cleanup;
+                goto finalise;
             }
             if ((size = dn_expand(buffer, buffer + len, p, host, NS_MAXDNAME)) < 0) {
                 error((char *) "%s| %s: ERROR: Error while expanding SRV RR name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
-                goto cleanup;
+                goto finalise;
             }
             debug((char *) "%s| %s: DEBUG: Resolved SRV %s record to %s\n", LogTime(), PROGRAM, service, host);
             hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nh + 1));
@@ -387,7 +387,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         }
         if (p > buffer + len) {
             error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority + weight + port + name\n", LogTime(), PROGRAM, len);
-            goto cleanup;
+            goto finalise;
         }
     }
     if (p != buffer + len) {
@@ -396,10 +396,10 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
 #else
         error((char *) "%s| %s: ERROR: Inconsistence message length: %d!=0\n", LogTime(), PROGRAM, buffer + len - p);
 #endif
-        goto cleanup;
+        goto finalise;
     }
 
-cleanup:
+finalise:
     nhosts = get_hostname_list(margs, &hp, nh, domain);
 
     debug("%s| %s: DEBUG: Adding %s to list\n", LogTime(), PROGRAM, domain);
@@ -411,6 +411,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     hp[nhosts].weight = -2;
     ++nhosts;
 
+cleanup:
     /* Remove duplicates */
     for (i = 0; i < nhosts; ++i) {
         for (j = i + 1; j < nhosts; ++j) {
@@ -134,7 +134,6 @@ interaction(
 {
     const char *dflt = interact->defresult;
 
-    flags = flags;
     switch (interact->id) {
     case SASL_CB_GETREALM:
         if (defaults)
@@ -231,11 +230,7 @@ tool_sasl_bind(LDAP * ld, char *binddn, char *ssl)
     char *sasl_realm = NULL;
     char *sasl_authc_id = NULL;
     char *sasl_authz_id = NULL;
-#ifdef HAVE_SUN_LDAP_SDK
     char *sasl_mech = (char *) "GSSAPI";
-#else
-    char *sasl_mech = NULL;
-#endif
     /*
      * Force encryption
      */
@@ -175,6 +175,7 @@ main(int argc, char *argv[])
             } else {
                 fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
             }
+            // fall through to display help texts.
 
         default:
             usage(argv[0]);
@@ -206,7 +207,7 @@ main(int argc, char *argv[])
         } else {
             user = p;
             rfc1738_unescape(user);
-            if (user && strip_dm) {
+            if (strip_dm) {
                 suser = strchr(user, '\\');
                 if (!suser) suser = strchr(user, '/');
                 if (suser && suser[1]) user = suser + 1;
@@ -61,8 +61,8 @@ rotate(const char *path, int rotate_count)
             fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerror());
         }
 #endif
-        if (rename(path, to) < 0 && errno != ENOENT) {
-            fprintf(stderr, "WARNING: rename '%s' to '%s' failure: %s\n", path, to, xstrerror());
+        if (rename(from, to) < 0 && errno != ENOENT) {
+            fprintf(stderr, "WARNING: rename '%s' to '%s' failure: %s\n", from, to, xstrerror());
         }
     }
     if (rotate_count > 0) {
@@ -114,7 +114,6 @@ main(int argc, char *const argv[])
     int nend = 0, kend = 0;
     char *token;
     char **nargs, **kargs;
-    int i,j;
     int fpid;
     FILE *FDKIN,*FDKOUT;
     FILE *FDNIN,*FDNOUT;
@@ -131,13 +130,13 @@ main(int argc, char *const argv[])
         return 0;
     }
 
-    j = 1;
+    int j = 1;
     if (!strncasecmp(argv[1],"-d",2)) {
         debug = 1;
         j = 2;
     }
 
-    for (i=j; i<argc; ++i) {
+    for (int i=j; i<argc; ++i) {
         if (!strncasecmp(argv[i],"--ntlm",6))
             nstart = i;
         if (!strncasecmp(argv[i],"--kerberos",10))
@@ -167,7 +166,7 @@ main(int argc, char *const argv[])
     nargs[nend-nstart]=NULL;
     if (debug) {
         fprintf(stderr, "%s| %s: NTLM command: ", LogTime(), PROGRAM);
-        for (i=0; i<nend-nstart; ++i)
+        for (int i=0; i<nend-nstart; ++i)
             fprintf(stderr, "%s ", nargs[i]);
         fprintf(stderr, "\n");
     }
@@ -179,7 +178,7 @@ main(int argc, char *const argv[])
     kargs[kend-kstart]=NULL;
     if (debug) {
         fprintf(stderr, "%s| %s: Kerberos command: ", LogTime(), PROGRAM);
-        for (i=0; i<kend-kstart; ++i)
+        for (int i=0; i<kend-kstart; ++i)
             fprintf(stderr, "%s ", kargs[i]);
         fprintf(stderr, "\n");
     }
@@ -204,7 +204,7 @@ class MemAllocator
     virtual char const *objectType() const;
     virtual size_t objectSize() const = 0;
     virtual int getInUseCount() = 0;
-    void zeroOnPush(bool doIt);
+    void zeroBlocks(bool doIt) {doZero = doIt;}
     int inUseCount();
 
     /**
@@ -226,7 +226,13 @@ class MemAllocator
     static size_t RoundedSize(size_t minSize);
 
 protected:
-    bool doZeroOnPush;
+    /** Whether to zero memory on initial allocation and on return to the pool.
+     *
+     * We do this on some pools because many object constructors are/were incomplete
+     * and we are afraid some code may use the object after free.
+     * These probems are becoming less common, so when possible set this to false.
+     */
+    bool doZero;
 
 private:
     const char *label;
@@ -57,7 +57,7 @@ struct session_list {
 
 struct snmp_internal_session {
     int sd;			/* socket descriptor for this connection */
-    ipaddr addr;		/* address of connected peer */
+    struct sockaddr_in addr;		/* address of connected peer */
     struct request_list *requests;	/* Info about outstanding requests */
 };
 
@@ -65,7 +65,4 @@ struct trapVar {
     struct trapVar *next;
 };
 
-/* from snmp.c */
-extern u_char sid[];		/* size SID_MAX_LEN */
-
 #endif /* SQUID_SNMP_IMPL_H */
@@ -39,12 +39,10 @@
 extern "C" {
 #endif
 
-    typedef struct sockaddr_in ipaddr;
-
     /* An SNMP PDU */
     struct snmp_pdu {
         int command;		/* Type of this PDU */
-        ipaddr address;		/* Address of peer */
+        struct sockaddr_in address;		/* Address of peer */
 
         int reqid;			/* Integer32: Request id */
         int errstat;		/* INTEGER:   Error status */
@@ -59,7 +57,7 @@ extern "C" {
         /* Trap information */
         oid *enterprise;		/* System OID */
         int enterprise_length;
-        ipaddr agent_addr;		/* address of object generating trap */
+        struct sockaddr_in agent_addr;		/* address of object generating trap */
         int trap_type;		/* generic trap type */
         int specific_type;		/* specific type */
         u_int time;			/* Uptime */
@@ -324,7 +324,7 @@ memPoolGetGlobalStats(MemPoolGlobalStats * stats)
     return pools_inuse;
 }
 
-MemAllocator::MemAllocator(char const *aLabel) : doZeroOnPush(true), label(aLabel)
+MemAllocator::MemAllocator(char const *aLabel) : doZero(true), label(aLabel)
 {
 }
 
@@ -445,12 +445,6 @@ MemImplementingAllocator::~MemImplementingAllocator()
     --MemPools::GetInstance().poolCount;
 }
 
-void
-MemAllocator::zeroOnPush(bool doIt)
-{
-    doZeroOnPush = doIt;
-}
-
 MemPoolMeter const &
 MemImplementingAllocator::getMeter() const
 {
@@ -141,7 +141,11 @@ MemChunk::MemChunk(MemPoolChunked *aPool)
     next = NULL;
     pool = aPool;
 
-    objCache = xcalloc(1, pool->chunk_size);
+    if (pool->doZero)
+        objCache = xcalloc(1, pool->chunk_size);
+    else
+        objCache = xmalloc(pool->chunk_size);
+
     freeList = objCache;
     void **Free = (void **)freeList;
 
@@ -196,7 +200,7 @@ MemPoolChunked::push(void *obj)
      * not really need to be cleared.. There was a condition based on
      * the object size here, but such condition is not safe.
      */
-    if (doZeroOnPush)
+    if (doZero)
         memset(obj, 0, obj_size);
     Free = (void **)obj;
     *Free = freeCache;
@@ -56,7 +56,10 @@ MemPoolMalloc::allocate()
         memMeterDec(meter.idle);
         ++saved_calls;
     } else {
-        obj = xcalloc(1, obj_size);
+        if (doZero)
+            obj = xcalloc(1, obj_size);
+        else
+            obj = xmalloc(obj_size);
         memMeterInc(meter.alloc);
     }
     memMeterInc(meter.inuse);
@@ -71,7 +74,7 @@ MemPoolMalloc::deallocate(void *obj, bool aggressive)
         xfree(obj);
         memMeterDec(meter.alloc);
     } else {
-        if (doZeroOnPush)
+        if (doZero)
             memset(obj, 0, obj_size);
         memMeterInc(meter.idle);
         freelist.push_back(obj);
@@ -362,10 +362,10 @@ RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP)
 
 /* Disconnect the TCP connection to the server */
 int
-RFCNB_Close(int socket)
+RFCNB_Close(int fd)
 {
 
-    close(socket);
+    close(fd);
 
     /* If we want to do error recovery, here is where we put it */
 
@@ -35,7 +35,7 @@ void RFCNB_Print_Pkt(FILE * fd, char *dirn, struct RFCNB_Pkt *pkt, int len);
 
 int RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP);
 
-int RFCNB_Close(int socket);
+int RFCNB_Close(int fd);
 
 int RFCNB_IP_Connect(struct in_addr Dest_IP, int port);
 
@@ -79,6 +79,7 @@ RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address, int port
     con->errn = 0;              /* no error yet */
     con->timeout = 0;           /* no timeout   */
     con->redirects = 0;
+    con->redirect_list = con->last_addr = NULL;
 
     /* Resolve that name into an IP address */
 
@@ -208,6 +209,7 @@ RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)
 
         /* No need to change RFCNB_errno as it was done by put_pkt ...     */
 
+        RFCNB_Free_Pkt(pkt);
         return (RFCNBE_Bad);    /* Should be able to write that lot ... */
 
     }
@@ -256,7 +258,7 @@ RFCNB_Recv(void *con_Handle, struct RFCNB_Pkt *Data, int Length)
 #ifdef RFCNB_DEBUG
         fprintf(stderr, "Bad packet return in RFCNB_Recv... \n");
 #endif
-
+        RFCNB_Free_Pkt(pkt);
         return (RFCNBE_Bad);
 
     }
@@ -767,7 +767,7 @@ int SMB_Get_Last_SMB_Err()
 
 static const char *SMBlib_Error_Messages[] = {
 
-    "Request completed sucessfully.",
+    "Request completed successfully.",
     "Server returned a non-zero SMB Error Class and Code.",
     "A lower layer protocol error occurred.",
     "Function not yet implemented.",
@@ -120,8 +120,10 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
     strcpy(con -> password, "");
     strcpy(con -> sock_options, "");
     strcpy(con -> address, "");
-    strcpy(con -> desthost, server);
-    strcpy(con -> PDomain, NTdomain);
+    strncpy(con -> desthost, server, sizeof(con->desthost));
+    con->desthost[sizeof(con->desthost) - 1] = '\0';
+    strncpy(con -> PDomain, NTdomain, sizeof(con->PDomain));
+    con->PDomain[sizeof(con->PDomain) - 1] = '\0';
     strcpy(con -> OSName, SMBLIB_DEFAULT_OSNAME);
     strcpy(con -> LMType, SMBLIB_DEFAULT_LMTYPE);
     con -> first_tree = con -> last_tree = NULL;
@@ -213,9 +215,12 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
 
     /* Init some things ... */
 
-    strcpy(con -> service, service);
-    strcpy(con -> username, username);
-    strcpy(con -> password, password);
+    strncpy(con -> service, service, sizeof(con -> service));
+    con -> service[sizeof(con -> service) - 1] = '\0';
+    strncpy(con -> username, username, sizeof(con -> username));
+    con -> username[sizeof(con -> username) - 1] = '\0';
+    strncpy(con -> password, password, sizeof(con -> password));
+    con -> password[sizeof(con -> password) - 1] = '\0';
     strcpy(con -> sock_options, "");
     strcpy(con -> address, "");
     strcpy(con -> PDomain, SMBLIB_DEFAULT_DOMAIN);
@@ -236,9 +241,19 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
 
     /* Now figure out the host portion of the service */
 
-    strcpy(temp, service);
+    strncpy(temp, service, sizeof(temp));
+    temp[sizeof(temp) - 1] = '\0';
     host = strtok(temp, "/\\");     /* Separate host name portion */
-    strcpy(con -> desthost, host);
+    if (!host) {
+        if (Con_Handle == NULL) {
+            free(con);
+            Con_Handle = NULL;
+        }
+        SMBlib_errno = -SMBlibE_CallFailed;
+        return NULL;
+    }
+    strncpy(con->desthost, host, sizeof(con->desthost));
+    con->desthost[sizeof(con->desthost)-1]='\0';
 
     /* Now connect to the remote end, but first upper case the name of the
        service we are going to call, sine some servers want it in uppercase */
@@ -280,9 +295,10 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
 
     if (SMB_Negotiate(con, SMB_Prots_Restrict) < 0) {
 
-        /* Hmmm what should we do here ... We have a connection, but could not
-           negotiate ...                                                      */
-
+        if (Con_Handle == NULL) {
+            free(con);
+        }
+        SMBlib_errno = -SMBlibE_NegNoProt;
         return NULL;
 
     }
@@ -291,6 +307,10 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
 
     if ((*tree = SMB_TreeConnect(con, NULL, service, password, "A:")) == NULL) {
 
+        if (Con_Handle == NULL) {
+            free(con);
+        }
+        SMBlib_errno = -SMBlibE_BAD;
         return NULL;
 
     }
@@ -325,7 +345,8 @@ int SMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,
         pass_len = 24;
         memcpy(pword, PassWord, 24);
     } else {
-        strcpy(pword, PassWord);
+        strncpy(pword, PassWord, sizeof(pword));
+        pword[sizeof(pword) - 1] = '\0';
 #ifdef PAM_SMB_ENC_PASS
         if (Con_Handle->encrypt_passwords) {
             pass_len = 24;
@@ -391,7 +412,7 @@ int SMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,
 
         p = p + 1;
 
-        if (NtDomain != NULL) {
+        if (NtDomain == NULL) {
             strcpy(p, Con_Handle -> PDomain);
             p = p + strlen(Con_Handle -> PDomain);
         } else {
@@ -61,12 +61,11 @@ make_snapshot()
   set +e
     # cleanup old snapshots
     ls ${dst}/*-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-r*[0-9]${type} | \
-		sed -e 's/.*-\([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-r[0-9]+'${type}'\)/\1/' | \
+#		sed -e 's/.*-\([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-r[0-9]+'${type}'\)/\1/' | \
 		sort -r | tail +${save} | \
     while read f; do
-	rm -f ${dst}/*-${f} ${dst}/*-${f}.md5
+	rm -f ${f} ${f}.md5
     done
-
   set -e
 
     # update dynamic index pages Last-Modified info
@@ -49,7 +49,7 @@
 	],
 	cbdata => [
 		'cbdataAlloc: (\S+)',
-		'cbdataFree: Freeing (\S+)',
+		'(?:cbdataFree|cbdataUnlock): Freeing (\S+)',
 	],
 	FD => [
 		'fd_open.*\sFD (\d+)',
@@ -405,7 +405,7 @@ do_subtree(struct snmp_mib_tree *root, struct node **nodes)
         np->enums = NULL;	/* so we don't free them later */
         if (root->child_list == NULL) {
             root->child_list = tp;
-        } else {
+        } else if (peer) {
             peer->next_peer = tp;
         }
         peer = tp;
@@ -625,6 +625,16 @@ free_node(struct node *np)
     xfree((char *) np);
 }
 
+static void
+free_node_list(struct node *nl)
+{
+    while (nl) {
+        struct node *t = nl->next;
+        free_node(nl);
+        nl = t;
+    }
+}
+
 /*
  * Parse an entry of the form:
  * label OBJECT IDENTIFIER ::= { parent 2 }
@@ -657,9 +667,9 @@ parse_objectid(FILE *fp, char *name) {
                 op++, nop++) {
             /* every node must have parent's name and child's name or number */
             if (op->label && (nop->label || (nop->subid != -1))) {
-                strcpy(np->parent, op->label);
+                strncpy(np->parent, op->label, sizeof(np->parent) - 1);
                 if (nop->label)
-                    strcpy(np->label, nop->label);
+                    strncpy(np->label, nop->label, sizeof(np->label) - 1);
                 if (nop->subid != -1)
                     np->subid = nop->subid;
                 np->type = 0;
@@ -680,8 +690,8 @@ parse_objectid(FILE *fp, char *name) {
          */
         if (count == (length - 2)) {
             if (op->label) {
-                strcpy(np->parent, op->label);
-                strcpy(np->label, name);
+                strncpy(np->parent, op->label, sizeof(np->parent));
+                strncpy(np->label, name, sizeof(np->label));
                 if (nop->subid != -1)
                     np->subid = nop->subid;
                 else
@@ -690,12 +700,14 @@ parse_objectid(FILE *fp, char *name) {
                 free_node(np);
                 if (oldnp)
                     oldnp->next = NULL;
-                else
+                else {
+                    free_node_list(root); // we need to clear the newly allocated list
                     return NULL;
+                }
             }
         } else {
             print_error("Missing end of oid", (char *) NULL, type);
-            free_node(np);	/* the last node allocated wasn't used */
+            free_node_list(root); // we need to clear the newly allocated list
             if (oldnp)
                 oldnp->next = NULL;
             return NULL;
@@ -945,9 +957,12 @@ parse_objecttype(register FILE *fp, char *name) {
     length = getoid(fp, SubOid, 32);
     if (length > 1 && length <= 32) {
         /* just take the last pair in the oid list */
-        if (SubOid[length - 2].label)
+        if (SubOid[length - 2].label) {
             strncpy(np->parent, SubOid[length - 2].label, 64);
-        strcpy(np->label, name);
+            np->parent[63] = '\0';
+        }
+        strncpy(np->label, name, sizeof(np->label));
+        np->label[sizeof(np->label) - 1] = '\0';
         if (SubOid[length - 1].subid != -1)
             np->subid = SubOid[length - 1].subid;
         else
@@ -989,9 +1004,11 @@ parse(FILE *fp) {
                 return root;
             }
             print_error(token, "is a reserved word", type);
+            free_node_list(root);
             return NULL;
         }
         strncpy(name, token, 64);
+        name[63] = '\0';
         type = get_token(fp, token);
         if (type == OBJTYPE) {
             if (root == NULL) {
@@ -1005,6 +1022,7 @@ parse(FILE *fp) {
                 np->next = parse_objecttype(fp, name);
                 if (np->next == NULL) {
                     print_error("Bad parse of objecttype", (char *) NULL, type);
+                    free_node_list(root);
                     return NULL;
                 }
             }
@@ -1023,6 +1041,7 @@ parse(FILE *fp) {
                 np->next = parse_objectid(fp, name);
                 if (np->next == NULL) {
                     print_error("Bad parse of object type", (char *) NULL, type);
+                    free_node_list(root);
                     return NULL;
                 }
             }
@@ -1035,6 +1054,7 @@ parse(FILE *fp) {
             break;
         } else {
             print_error("Bad operator", (char *) NULL, type);
+            free_node_list(root);
             return NULL;
         }
     }
@@ -1075,18 +1095,20 @@ read_mib(char *filename) {
             strlen("DUMMY")));
     if (!p) {
         snmplib_debug(0, "Bad MIB version or tag missing, install original!\n");
+        fclose(fp);
         return NULL;
     }
     if (!strcmp(mbuf, "DUMMY")) {
         snmplib_debug(0, "You need to update your MIB!\n");
+        fclose(fp);
         return NULL;
     }
     nodes = parse(fp);
+    fclose(fp);
     if (!nodes) {
         snmplib_debug(0, "Mib table is bad.  Exiting\n");
         return NULL;
     }
     tree = build_tree(nodes);
-    fclose(fp);
     return (tree);
 }
@@ -252,23 +252,23 @@ snmp_msg_Decode(u_char * Packet, int *PacketLenP,
 
     bufp = asn_parse_header(Packet, PacketLenP, &type);
     if (bufp == NULL) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Header)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     if (type != (ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Header)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     bufp = asn_parse_int(bufp, PacketLenP,
                          &type,
                          (int *) Version, sizeof(*Version));
     if (bufp == NULL) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Version)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Version)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     bufp = asn_parse_string(bufp, PacketLenP, &type, Community, CommLenP);
     if (bufp == NULL) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Community)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Community)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     Community[*CommLenP] = '\0';
@@ -373,6 +373,7 @@ snmp_var_DecodeVarBind(u_char * Buffer, int *BufLen,
     u_char *DataPtr;
     int DataLen;
     oid TmpBuf[MAX_NAME_LEN];
+    memset(TmpBuf, 0, MAX_NAME_LEN * sizeof(*TmpBuf));
 
     int AllVarLen = *BufLen;
     int ThisVarLen = 0;
@@ -3,9 +3,10 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
-#include "ssl/support.h"
 
 #if USE_SSL
+#include "ssl/support.h"
+
 AccessLogEntry::SslDetails::SslDetails(): user(NULL), bumpMode(::Ssl::bumpEnd)
 {
 }
@@ -31,7 +32,7 @@ AccessLogEntry::~AccessLogEntry()
 {
     safe_free(headers.request);
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     safe_free(adapt.last_meta);
 #endif
 
@@ -34,16 +34,16 @@
 #include "base/RefCount.h"
 #include "comm/Connection.h"
 #include "HttpHeader.h"
-#include "HttpVersion.h"
+#include "http/ProtocolVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
-#include "HttpRequestMethod.h"
+#include "LogTags.h"
+#include "Notes.h"
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
-#include "Notes.h"
 #if USE_SSL
 #include "ssl/gadgets.h"
 #endif
@@ -89,7 +89,7 @@ class AccessLogEntry: public RefCountable
         HttpRequestMethod method;
         int code;
         const char *content_type;
-        HttpVersion version;
+        Http::ProtocolVersion version;
         bool timedout; ///< terminated due to a lifetime or I/O timeout
         bool aborted; ///< other abnormal termination (e.g., I/O error)
 
@@ -169,7 +169,7 @@ class AccessLogEntry: public RefCountable
         int replyHeadersSize; ///< sent, including status line
         int64_t highOffset;
         int64_t objectSize;
-        log_type code;
+        LogTags code;
         int msec;
         const char *rfc931;
         const char *authuser;
@@ -243,7 +243,10 @@ class AccessLogEntry: public RefCountable
     class IcapLogEntry
     {
     public:
-        IcapLogEntry():bodyBytesRead(-1),request(NULL),reply(NULL),outcome(Adaptation::Icap::xoUnknown),trTime(0),ioTime(0),resStatus(HTTP_STATUS_NONE) {}
+        IcapLogEntry() : reqMethod(Adaptation::methodNone), bytesSent(0), bytesRead(0),
+                bodyBytesRead(-1), request(NULL), reply(NULL),
+                outcome(Adaptation::Icap::xoUnknown), trTime(0),
+                ioTime(0), resStatus(Http::scNone), processingTime(0) {}
 
         Ip::Address hostAddr; ///< ICAP server IP address
         String serviceName;        ///< ICAP service name
@@ -271,7 +274,7 @@ class AccessLogEntry: public RefCountable
          * ICAP response is received.
          */
         int ioTime;
-        http_status resStatus;   ///< ICAP response status code
+        Http::StatusCode resStatus;   ///< ICAP response status code
         int processingTime;      ///< total ICAP processing time in milliseconds
     }
     icap;
@@ -59,6 +59,9 @@
 #include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "acl/StringData.h"
+#if USE_SSL
+#include "acl/ServerCertificate.h"
+#endif
 #include "acl/Tag.h"
 #include "acl/TimeData.h"
 #include "acl/Time.h"
@@ -77,10 +80,12 @@
 
 ACL::Prototype ACLBrowser::RegistryProtoype(&ACLBrowser::RegistryEntry_, "browser");
 ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_USER_AGENT>::Instance(), "browser");
+ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
 ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&ACLDestinationDomain::LiteralRegistryEntry_, "dstdomain");
-ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain");
+ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain", DestinationDomainFlags);
 ACL::Prototype ACLDestinationDomain::RegexRegistryProtoype(&ACLDestinationDomain::RegexRegistryEntry_, "dstdom_regex");
-ACLStrategised<char const *> ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,"dstdom_regex");
+ACLFlag  DestinationDomainRegexFlags[] = {ACL_F_NO_LOOKUP, ACL_F_REGEX_CASE, ACL_F_END};
+ACLStrategised<char const *> ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,"dstdom_regex", DestinationDomainRegexFlags);
 ACL::Prototype ACLDestinationIP::RegistryProtoype(&ACLDestinationIP::RegistryEntry_, "dst");
 ACLDestinationIP ACLDestinationIP::RegistryEntry_;
 #if USE_AUTH
@@ -143,9 +148,11 @@ ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrate
 ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
 ACLStrategised<const Ssl::Errors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
 ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
-ACLStrategised<SSL *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (sslGetUserAttribute), ACLCertificateStrategy::Instance(), "user_cert");
+ACLStrategised<X509 *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (Ssl::GetX509UserAttribute, "*"), ACLCertificateStrategy::Instance(), "user_cert");
 ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
-ACLStrategised<SSL *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (sslGetCAAttribute), ACLCertificateStrategy::Instance(), "ca_cert");
+ACLStrategised<X509 *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (Ssl::GetX509CAAttribute, "*"), ACLCertificateStrategy::Instance(), "ca_cert");
+ACL::Prototype ACLServerCertificate::X509FingerprintRegistryProtoype(&ACLServerCertificate::X509FingerprintRegistryEntry_, "server_cert_fingerprint");
+ACLStrategised<X509 *> ACLServerCertificate::X509FingerprintRegistryEntry_(new ACLCertificateData(Ssl::GetX509Fingerprint, "-sha1", true), ACLServerCertificateStrategy::Instance(), "server_cert_fingerprint");
 #endif
 
 #if USE_SQUID_EUI
@@ -93,45 +93,45 @@ class CachePeer
     acl_access *access;
 
     struct {
-        unsigned int proxy_only:1;
-        unsigned int no_query:1;
-        unsigned int background_ping:1;
-        unsigned int no_digest:1;
-        unsigned int default_parent:1;
-        unsigned int roundrobin:1;
-        unsigned int weighted_roundrobin:1;
-        unsigned int mcast_responder:1;
-        unsigned int closest_only:1;
+        bool proxy_only;
+        bool no_query;
+        bool background_ping;
+        bool no_digest;
+        bool default_parent;
+        bool roundrobin;
+        bool weighted_roundrobin;
+        bool mcast_responder;
+        bool closest_only;
 #if USE_HTCP
-        unsigned int htcp:1;
-        unsigned int htcp_oldsquid:1;
-        unsigned int htcp_no_clr:1;
-        unsigned int htcp_no_purge_clr:1;
-        unsigned int htcp_only_clr:1;
-        unsigned int htcp_forward_clr:1;
+        bool htcp;
+        bool htcp_oldsquid;
+        bool htcp_no_clr;
+        bool htcp_no_purge_clr;
+        bool htcp_only_clr;
+        bool htcp_forward_clr;
 #endif
-        unsigned int no_netdb_exchange:1;
+        bool no_netdb_exchange;
 #if USE_DELAY_POOLS
-        unsigned int no_delay:1;
+        bool no_delay;
 #endif
-        unsigned int allow_miss:1;
-        unsigned int carp:1;
+        bool allow_miss;
+        bool carp;
         struct {
-            unsigned int set:1; //If false, whole url is to be used. Overrides others
-            unsigned int scheme:1;
-            unsigned int host:1;
-            unsigned int port:1;
-            unsigned int path:1;
-            unsigned int params:1;
+            bool set; //If false, whole url is to be used. Overrides others
+            bool scheme;
+            bool host;
+            bool port;
+            bool path;
+            bool params;
         } carp_key;
 #if USE_AUTH
-        unsigned int userhash:1;
+        bool userhash;
 #endif
-        unsigned int sourcehash:1;
-        unsigned int originserver:1;
-        unsigned int no_tproxy:1;
+        bool sourcehash;
+        bool originserver;
+        bool no_tproxy;
 #if PEER_MULTICAST_SIBLINGS
-        unsigned int mcast_siblings:1;
+        bool mcast_siblings;
 #endif
     } options;
 
@@ -146,8 +146,8 @@ class CachePeer
         int id;
 
         struct {
-            unsigned int count_event_pending:1;
-            unsigned int counting:1;
+            bool count_event_pending;
+            bool counting;
         } flags;
     } mcast;
 #if USE_CACHE_DIGESTS
@@ -3,6 +3,7 @@
 
 #include "ip/Address.h"
 #include "hash.h"
+#include "LogTags.h"
 #include "enums.h"
 #include "typedefs.h"
 #include "cbdata.h"
@@ -35,6 +35,8 @@ class ClientRequestContext : public RefCountable
     void clientAccessCheckDone(const allow_t &answer);
     void clientRedirectStart();
     void clientRedirectDone(const HelperReply &reply);
+    void clientStoreIdStart();
+    void clientStoreIdDone(const HelperReply &reply);
     void checkNoCache();
     void checkNoCacheDone(const allow_t &answer);
 #if USE_ADAPTATION
@@ -55,6 +57,7 @@ class ClientRequestContext : public RefCountable
     ClientHttpRequest *http;
     ACLChecklist *acl_checklist;        /* need ptr back so we can unreg if needed */
     int redirect_state;
+    int store_id_state;
 
     /**
      * URL-rewrite/redirect helper may return BH for internal errors.
@@ -63,6 +66,7 @@ class ClientRequestContext : public RefCountable
      * This tracks the number of previous failures for the current context.
      */
     uint8_t redirect_fail_count;
+    uint8_t store_id_fail_count;
 
     bool host_header_verify_done;
     bool http_access_done;
@@ -71,6 +75,7 @@ class ClientRequestContext : public RefCountable
     bool adaptation_acl_check_done;
 #endif
     bool redirect_done;
+    bool store_id_done;
     bool no_cache_done;
     bool interpreted_req_hdrs;
     bool tosToClientDone;
@@ -169,9 +169,9 @@ class CommCbMemFunT: public JobDialer<C>, public CommDialerParamsT<Params_>
     typedef Params_ Params;
     typedef void (C::*Method)(const Params &io);
 
-    CommCbMemFunT(const CbcPointer<C> &job, Method meth): JobDialer<C>(job),
-            CommDialerParamsT<Params_>(job.get()),
-            method(meth) {}
+    CommCbMemFunT(const CbcPointer<C> &aJob, Method aMeth): JobDialer<C>(aJob),
+            CommDialerParamsT<Params_>(aJob.get()),
+            method(aMeth) {}
 
     virtual bool canDial(AsyncCall &c) {
         return JobDialer<C>::canDial(c) &&
@@ -38,6 +38,9 @@
 #include "fatal.h"
 #include "globals.h"
 
+char *ConfigParser::lastToken = NULL;
+std::queue<std::string> ConfigParser::undo;
+
 void
 ConfigParser::destruct()
 {
@@ -46,15 +49,38 @@ ConfigParser::destruct()
            cfg_filename, config_lineno, config_input_line);
 }
 
+void
+ConfigParser::strtokFileUndo()
+{
+    assert(lastToken);
+    undo.push(lastToken);
+}
+
+void
+ConfigParser::strtokFilePutBack(const char *tok)
+{
+    assert(tok);
+    undo.push(tok);
+}
+
 char *
 ConfigParser::strtokFile(void)
 {
     static int fromFile = 0;
     static FILE *wordFile = NULL;
+    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
 
     char *t, *fn;
     LOCAL_ARRAY(char, buf, CONFIG_LINE_LIMIT);
 
+    if (!undo.empty()) {
+        strncpy(undoToken, undo.front().c_str(), sizeof(undoToken));
+        undoToken[sizeof(undoToken) - 1] = '\0';
+        undo.pop();
+        return undoToken;
+    }
+
+    lastToken = NULL;
     do {
 
         if (!fromFile) {
@@ -82,7 +108,7 @@ ConfigParser::strtokFile(void)
 
                 fromFile = 1;
             } else {
-                return t;
+                return lastToken = t;
             }
         }
 
@@ -113,7 +139,7 @@ ConfigParser::strtokFile(void)
         /* skip blank lines */
     } while ( *t == '#' || !*t );
 
-    return t;
+    return lastToken = t;
 }
 
 void
@@ -35,6 +35,10 @@
 #define SQUID_CONFIGPARSER_H
 
 #include "SquidString.h"
+#include <queue>
+#if HAVE_STRING
+#include <string>
+#endif
 
 class wordlist;
 /**
@@ -76,6 +80,11 @@ class ConfigParser
     static const char *QuoteString(String &var);
     static void ParseWordList(wordlist **list);
     static char * strtokFile();
+    static void strtokFileUndo();
+    static void strtokFilePutBack(const char *);
+private:
+    static char *lastToken;
+    static std::queue<std::string> undo;
 };
 
 int parseConfigFile(const char *file_name);
@@ -81,7 +81,8 @@ class Debug
     static char *cache_log;
     static int rotateNumber;
     static int Levels[MAX_DEBUG_SECTIONS];
-    static int level;
+    static int level; ///< minimum debugging level required by debugs() call
+    static int sectionLevel; ///< maximum debugging level allowed now
     static int override_X;
     static int log_stderr;
     static bool log_syslog;
@@ -107,6 +108,7 @@ const char * SkipBuildPrefix(const char* path);
 #define debugs(SECTION, LEVEL, CONTENT) \
    do { \
         if ((Debug::level = (LEVEL)) <= Debug::Levels[SECTION]) { \
+            Debug::sectionLevel = Debug::Levels[SECTION]; \
             std::ostream &_dbo=Debug::getDebugOut(); \
             if (Debug::level > DBG_IMPORTANT) \
                 _dbo << SkipBuildPrefix(__FILE__)<<"("<<__LINE__<<") "<<__FUNCTION__<<": "; \
@@ -157,4 +159,42 @@ void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
 void _db_set_syslog(const char *facility);
 void _db_rotate_log(void);
 
+/// Prints raw and/or non-terminated data safely, efficiently, and beautifully.
+/// Allows raw data debugging in debugs() statements with low debugging levels
+/// by printing only if higher section debugging levels are configured:
+///   debugs(11, DBG_IMPORTANT, "always printed" << Raw(may be printed...));
+class Raw
+{
+public:
+    Raw(const char *label, const char *data, const size_t size):
+            level(-1), label_(label), data_(data), size_(size) {}
+
+    /// limit data printing to at least the given debugging level
+    Raw &minLevel(const int aLevel) { level = aLevel; return *this; }
+
+    /// If debugging is prohibited by the current debugs() or section level,
+    /// prints nothing. Otherwise, dumps data using one of these formats:
+    ///   " label[size]=data" if label was set and data size is positive
+    ///   " label[0]" if label was set and data size is zero
+    ///   " data" if label was not set and data size is positive
+    ///   "" (i.e., prints nothing) if label was not set and data size is zero
+    std::ostream &print(std::ostream &os) const;
+
+    /// Minimum section debugging level necessary for printing. By default,
+    /// small strings are always printed while large strings are only printed
+    /// if DBG_DATA debugging level is enabled.
+    int level;
+
+private:
+    const char *label_; ///< optional data name or ID; triggers size printing
+    const char *data_; ///< raw data to be printed
+    size_t size_; ///< data length
+};
+
+inline
+std::ostream &operator <<(std::ostream &os, const Raw &raw)
+{
+    return raw.print(os);
+}
+
 #endif /* SQUID_DEBUG_H */
@@ -42,6 +42,8 @@ class DelayBucket
 {
 
 public:
+    DelayBucket() : level_(0) {}
+
     int const& level() const {return level_;}
 
     int & level() {return level_;}
@@ -47,9 +47,12 @@
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
 
-AIODiskIOStrategy::AIODiskIOStrategy()
+AIODiskIOStrategy::AIODiskIOStrategy() :
+        fd(-1)
 {
+    aq.aq_state = AQ_STATE_NONE;
     aq.aq_numpending = 0;
+    memset(&aq.aq_queue, 0, sizeof(aq.aq_queue));
 }
 
 AIODiskIOStrategy::~AIODiskIOStrategy()
@@ -72,8 +72,11 @@ DiskdFile::operator delete(void *address)
     cbdataFree(t);
 }
 
-DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) : errorOccured (false), IO(anIO),
-        inProgressIOs (0)
+DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) :
+        errorOccured(false),
+        IO(anIO),
+        mode(0),
+        inProgressIOs(0)
 {
     assert (aPath);
     debugs(79, 3, "DiskdFile::DiskdFile: " << aPath);
@@ -385,8 +388,10 @@ DiskdFile::readDone(diomsg * M)
     debugs(79, 3, "DiskdFile::readDone: status " << M->status);
     assert (M->requestor);
     ReadRequest::Pointer readRequest = dynamic_cast<ReadRequest *>(M->requestor);
+
     /* remove the free protection */
-    readRequest->unlock();
+    if (readRequest != NULL)
+        readRequest->unlock();
 
     if (M->status < 0) {
         ++diskd_stats.read.fail;
@@ -410,7 +415,8 @@ DiskdFile::writeDone(diomsg *M)
     assert (M->requestor);
     WriteRequest::Pointer writeRequest = dynamic_cast<WriteRequest *>(M->requestor);
     /* remove the free protection */
-    writeRequest->unlock();
+    if (writeRequest != NULL)
+        writeRequest->unlock();
 
     if (M->status < 0) {
         errorOccured = true;
@@ -270,6 +270,10 @@ msg_handle(diomsg * r, int rl, diomsg * s)
 
     if (s->shm_offset > -1)
         buf = shmbuf + s->shm_offset;
+    else if (r->mtype != _MQD_CLOSE) {
+        fprintf(stderr, "%d UNLNK id(%u) Error: no filename in shm buffer\n", (int) mypid, s->id);
+        return;
+    }
 
     switch (r->mtype) {
 
@@ -374,7 +378,10 @@ main(int argc, char *argv[])
 
     hash = hash_create(fsCmp, 1 << 4, fsHash);
     assert(hash);
-    fcntl(0, F_SETFL, SQUID_NONBLOCK);
+    if (fcntl(0, F_SETFL, SQUID_NONBLOCK) < 0) {
+        perror(xstrerror());
+        return 1;
+    }
     memset(&sa, '\0', sizeof(sa));
     sa.sa_handler = alarm_handler;
     sa.sa_flags = SA_RESTART;
@@ -187,7 +187,10 @@ DiskThreadsIOStrategy::sync()
     debugs(32, 2, "aioSync: done");
 }
 
-DiskThreadsIOStrategy::DiskThreadsIOStrategy() :  initialised (false) {}
+DiskThreadsIOStrategy::DiskThreadsIOStrategy() :
+        initialised(false),
+        squidaio_ctrl_pool(NULL)
+{}
 
 void
 DiskThreadsIOStrategy::aioStats(StoreEntry * sentry)
@@ -722,8 +722,10 @@ squidaio_read(int fd, char *bufp, size_t bufs, off_t offset, int whence, squidai
 static void
 squidaio_do_read(squidaio_request_t * requestp)
 {
-    lseek(requestp->fd, requestp->offset, requestp->whence);
-    requestp->ret = read(requestp->fd, requestp->bufferp, requestp->buflen);
+    if (lseek(requestp->fd, requestp->offset, requestp->whence) >= 0)
+        requestp->ret = read(requestp->fd, requestp->bufferp, requestp->buflen);
+    else
+        requestp->ret = -1;
     requestp->err = errno;
 }
 
@@ -594,9 +594,14 @@ IpcIoFile::getFD() const
 /* IpcIoMsg */
 
 IpcIoMsg::IpcIoMsg():
-        requestId(0), offset(0), len(0), command(IpcIo::cmdNone), xerrno(0)
+        requestId(0),
+        offset(0),
+        len(0),
+        command(IpcIo::cmdNone),
+        xerrno(0)
 {
     start.tv_sec = 0;
+    start.tv_usec = 0;
 }
 
 /* IpcIoPendingRequest */
@@ -38,7 +38,10 @@
 #include "SquidTime.h"
 
 EventLoop::EventLoop() : errcount(0), last_loop(false), timeService(NULL),
-        primaryEngine(NULL)
+        primaryEngine(NULL),
+        loop_delay(EVENT_LOOP_TIMEOUT),
+        error(false),
+        runOnceResult(false)
 {}
 
 void
@@ -3,6 +3,7 @@
 #include "Debug.h"
 #include "HelperChildConfig.h"
 #include "globals.h"
+#include "Parsing.h"
 
 #include <string.h>
 
@@ -49,24 +50,27 @@ HelperChildConfig::parseConfig()
         self_destruct();
 
     /* starts with a bare number for the max... back-compatible */
-    n_max = atoi(token);
+    n_max = xatoui(token);
 
-    if (n_max < 1)
+    if (n_max < 1) {
+        debugs(0, DBG_CRITICAL, "ERROR: The maximum number of processes cannot be less than 1.");
         self_destruct();
+    }
 
     /* Parse extension options */
     for (; (token = strtok(NULL, w_space)) ;) {
         if (strncmp(token, "startup=", 8) == 0) {
-            n_startup = atoi(token + 8);
+            n_startup = xatoui(token + 8);
         } else if (strncmp(token, "idle=", 5) == 0) {
-            n_idle = atoi(token + 5);
+            n_idle = xatoui(token + 5);
             if (n_idle < 1) {
                 debugs(0, DBG_CRITICAL, "WARNING OVERIDE: Using idle=0 for helpers causes request failures. Overiding to use idle=1 instead.");
                 n_idle = 1;
             }
         } else if (strncmp(token, "concurrency=", 12) == 0) {
-            concurrency = atoi(token + 12);
+            concurrency = xatoui(token + 12);
         } else {
+            debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Undefined option: " << token << ".");
             self_destruct();
         }
     }
@@ -8,6 +8,7 @@
 #include "helper.h"
 #include "rfc1738.h"
 #include "SquidString.h"
+#include "Debug.h"
 
 HelperReply::HelperReply(char *buf, size_t len) :
         result(HelperReply::Unknown),
@@ -19,29 +20,38 @@ HelperReply::HelperReply(char *buf, size_t len) :
 void
 HelperReply::parse(char *buf, size_t len)
 {
+    debugs(84, 3, "Parsing helper buffer");
     // check we have something to parse
     if (!buf || len < 1) {
+        // empty line response was the old URL-rewriter interface ERR response.
+        result = HelperReply::Error;
         // for now ensure that legacy handlers are not presented with NULL strings.
+        debugs(84, 3, "Reply length is smaller than 1 or none at all ");
         other_.init(1,1);
         other_.terminate();
         return;
     }
 
     char *p = buf;
+    bool sawNA = false;
 
     // optimization: do not consider parsing result code if the response is short.
     // URL-rewriter may return relative URLs or empty response for a large portion
     // of its replies.
     if (len >= 2) {
+        debugs(84, 3, "Buff length is larger than 2");
         // some helper formats (digest auth, URL-rewriter) just send a data string
         // we must also check for the ' ' character after the response token (if anything)
         if (!strncmp(p,"OK",2) && (len == 2 || p[2] == ' ')) {
+            debugs(84, 3, "helper Result = OK");
             result = HelperReply::Okay;
             p+=2;
         } else if (!strncmp(p,"ERR",3) && (len == 3 || p[3] == ' ')) {
+            debugs(84, 3, "helper Result = ERR");
             result = HelperReply::Error;
             p+=3;
         } else if (!strncmp(p,"BH",2) && (len == 2 || p[2] == ' ')) {
+            debugs(84, 3, "helper Result = BH");
             result = HelperReply::BrokenHelper;
             p+=2;
         } else if (!strncmp(p,"TT ",3)) {
@@ -93,6 +103,7 @@ HelperReply::parse(char *buf, size_t len)
             // NTLM fail-closed ERR response
             result = HelperReply::Error;
             p+=3;
+            sawNA=true;
         }
 
         for (; xisspace(*p); ++p); // skip whitespace
@@ -105,10 +116,12 @@ HelperReply::parse(char *buf, size_t len)
     // NULL-terminate so the helper callback handlers do not buffer-overrun
     other_.terminate();
 
-    parseResponseKeys();
+    // Hack for backward-compatibility: Do not parse for kv-pairs on NA response
+    if (!sawNA)
+        parseResponseKeys();
 
-    // Hack for backward-compatibility: BH used to be a text message...
-    if (other().hasContent() && result == HelperReply::BrokenHelper) {
+    // Hack for backward-compatibility: BH and NA used to be a text message...
+    if (other().hasContent() && (sawNA || result == HelperReply::BrokenHelper)) {
         notes.add("message",other().content());
         modifiableOther().clean();
     }
@@ -33,15 +33,13 @@
 #define SQUID_HTTPHIERARCHYLOGENTRY_H
 
 #include "comm/Connection.h"
+#include "enums.h"
 #include "hier_code.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 #include "lookup_t.h"
 #include "rfc2181.h"
 #include "PingData.h"
 
-/* for http_status */
-#include "enums.h"
-
 class HierarchyLogEntry
 {
 
@@ -66,7 +64,7 @@ class HierarchyLogEntry
 
     struct timeval store_complete_stop;
 
-    http_status peer_reply_status; ///< last HTTP status code received
+    Http::StatusCode peer_reply_status; ///< last HTTP status code received
     timeval peer_http_request_sent; ///< last peer finished writing req
     int64_t peer_response_time; ///< last peer response delay
     timeval first_conn_start; ///< first connection use among all peers
@@ -29,14 +29,13 @@ class HttpControlMsgSink: public virtual AsyncJob
 class HttpControlMsg
 {
 public:
-    typedef HttpMsgPointerT<HttpReply> MsgPtr;
     typedef AsyncCall::Pointer Callback;
 
-    HttpControlMsg(const MsgPtr &aReply, const Callback &aCallback):
+    HttpControlMsg(const HttpReply::Pointer &aReply, const Callback &aCallback):
             reply(aReply), cbSuccess(aCallback) {}
 
 public:
-    MsgPtr reply; ///< the 1xx message being forwarded
+    HttpReply::Pointer reply; ///< the 1xx message being forwarded
     Callback cbSuccess; ///< called after successfully writing the 1xx message
 
     // We could add an API to notify of send failures as well, but the
@@ -96,7 +96,7 @@ HttpHdrRangeSpec::parseInit(const char *field, int flen)
             return false;
     } else
         /* must have a '-' somewhere in _this_ field */
-        if (!((p = strchr(field, '-')) || (p - field >= flen))) {
+        if (!((p = strchr(field, '-')) && (p - field < flen))) {
             debugs(64, 2, "invalid (missing '-') range-spec near: '" << field << "'");
             return false;
         } else {
@@ -224,7 +224,7 @@ HttpHdrRangeSpec::mergeWith(const HttpHdrRangeSpec * donor)
  * Range
  */
 
-HttpHdrRange::HttpHdrRange () : clen (HttpHdrRangeSpec::UnknownPosition)
+HttpHdrRange::HttpHdrRange() : clen(HttpHdrRangeSpec::UnknownPosition)
 {}
 
 HttpHdrRange *
@@ -285,7 +285,9 @@ HttpHdrRange::~HttpHdrRange()
         delete specs.pop_back();
 }
 
-HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) : specs()
+HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) :
+        specs(),
+        clen(HttpHdrRangeSpec::UnknownPosition)
 {
     specs.reserve(old.specs.size());
 
@@ -197,22 +197,23 @@ HttpHdrSc::parse(const String * str)
             int ma;
             if (p && httpHeaderParseInt(p, &ma)) {
                 sct->maxAge(ma);
+
+                if ((p = strchr (p, '+'))) {
+                    int ms;
+                    ++p; //skip the + char
+                    if (httpHeaderParseInt(p, &ms)) {
+                        sct->maxStale(ms);
+                    } else {
+                        debugs(90, 2, "sc: invalid max-stale specs near '" << item << "'");
+                        sct->clearMaxStale();
+                        /* leave the max-age alone */
+                    }
+                }
             } else {
                 debugs(90, 2, "sc: invalid max-age specs near '" << item << "'");
                 sct->clearMaxAge();
             }
 
-            if ((p = strchr (p, '+'))) {
-                int ms;
-                ++p; //skip the + char
-                if (httpHeaderParseInt(p, &ms)) {
-                    sct->maxStale(ms);
-                } else {
-                    debugs(90, 2, "sc: invalid max-stale specs near '" << item << "'");
-                    sct->clearMaxStale();
-                    /* leave the max-age alone */
-                }
-            }
             break;
         }
 
@@ -77,7 +77,7 @@ class HeaderManglers
 class HeaderWithAcl
 {
 public:
-    HeaderWithAcl() :  aclList(NULL), fieldId (HDR_BAD_HDR), quoted(false) {}
+    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(HDR_BAD_HDR), quoted(false) {}
 
     /// HTTP header field name
     std::string fieldName;
@@ -42,12 +42,11 @@
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
         cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
-        pstate(psReadyToParseStartLine), lock_count(0)
+        pstate(psReadyToParseStartLine)
 {}
 
 HttpMsg::~HttpMsg()
 {
-    assert(lock_count == 0);
     assert(!body_pipe);
 }
 
@@ -141,13 +140,14 @@ httpMsgIsolateStart(const char **parse_start, const char **blk_start, const char
     return 1;
 }
 
-// negative return is the negated HTTP_ error code
+// negative return is the negated Http::StatusCode error code
 // zero return means need more data
 // positive return is the size of parsed headers
-bool HttpMsg::parse(MemBuf *buf, bool eof, http_status *error)
+bool
+HttpMsg::parse(MemBuf *buf, bool eof, Http::StatusCode *error)
 {
     assert(error);
-    *error = HTTP_STATUS_NONE;
+    *error = Http::scNone;
 
     // httpMsgParseStep() and debugging require 0-termination, unfortunately
     buf->terminate(); // does not affect content size
@@ -159,24 +159,24 @@ bool HttpMsg::parse(MemBuf *buf, bool eof, http_status *error)
     if (!sanityCheckStartLine(buf, hdr_len, error)) {
         // NP: sanityCheck sets *error and sends debug warnings on syntax errors.
         // if we have seen the connection close, this is an error too
-        if (eof && *error==HTTP_STATUS_NONE)
-            *error = HTTP_INVALID_HEADER;
+        if (eof && *error == Http::scNone)
+            *error = Http::scInvalidHeader;
 
         return false;
     }
 
     // TODO: move to httpReplyParseStep()
     if (hdr_len > Config.maxReplyHeaderSize || (hdr_len <= 0 && (size_t)buf->contentSize() > Config.maxReplyHeaderSize)) {
         debugs(58, DBG_IMPORTANT, "HttpMsg::parse: Too large reply header (" << hdr_len << " > " << Config.maxReplyHeaderSize);
-        *error = HTTP_HEADER_TOO_LARGE;
+        *error = Http::scHeaderTooLarge;
         return false;
     }
 
     if (hdr_len <= 0) {
         debugs(58, 3, "HttpMsg::parse: failed to find end of headers (eof: " << eof << ") in '" << buf->content() << "'");
 
         if (eof) // iff we have seen the end, this is an error
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
 
         return false;
     }
@@ -185,13 +185,13 @@ bool HttpMsg::parse(MemBuf *buf, bool eof, http_status *error)
 
     if (res < 0) { // error
         debugs(58, 3, "HttpMsg::parse: cannot parse isolated headers in '" << buf->content() << "'");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false;
     }
 
     if (res == 0) {
         debugs(58, 2, "HttpMsg::parse: strange, need more data near '" << buf->content() << "'");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false; // but this should not happen due to headersEnd() above
     }
 
@@ -322,7 +322,7 @@ HttpMsg::setContentLength(int64_t clen)
 bool
 HttpMsg::persistent() const
 {
-    if (http_ver > HttpVersion(1, 0)) {
+    if (http_ver > Http::ProtocolVersion(1, 0)) {
         /*
          * for modern versions of HTTP: persistent unless there is
          * a "Connection: close" header.
@@ -358,22 +358,3 @@ void HttpMsg::firstLineBuf(MemBuf& mb)
     packFirstLineInto(&p, true);
     packerClean(&p);
 }
-
-// use HTTPMSGLOCK() instead of calling this directly
-HttpMsg *
-HttpMsg::_lock()
-{
-    ++lock_count;
-    return this;
-}
-
-// use HTTPMSGUNLOCK() instead of calling this directly
-void
-HttpMsg::_unlock()
-{
-    assert(lock_count > 0);
-    --lock_count;
-
-    if (0 == lock_count)
-        delete this;
-}
@@ -31,23 +31,20 @@
 #ifndef SQUID_HTTPMSG_H
 #define SQUID_HTTPMSG_H
 
-#include "typedefs.h"
+#include "base/Lock.h"
+#include "BodyPipe.h"
 #include "HttpHeader.h"
 #include "HttpRequestMethod.h"
-#include "HttpStatusCode.h"
-#include "HttpVersion.h"
-#include "BodyPipe.h"
-
-// common parts of HttpRequest and HttpReply
-
-template <class Msg>
-class HttpMsgPointerT;
+#include "http/StatusCode.h"
+#include "http/ProtocolVersion.h"
+#include "typedefs.h"
 
-class HttpMsg
+/// common parts of HttpRequest and HttpReply
+class HttpMsg : public RefCountable
 {
 
 public:
-    typedef HttpMsgPointerT<HttpMsg> Pointer;
+    typedef RefCount<HttpMsg> Pointer;
 
     HttpMsg(http_hdr_owner_type owner);
     virtual ~HttpMsg();
@@ -56,9 +53,6 @@ class HttpMsg
 
     void packInto(Packer * p, bool full_uri) const;
 
-    virtual HttpMsg *_lock();	// please use HTTPMSGLOCK()
-    virtual void _unlock();	// please use HTTPMSGUNLOCK()
-
     ///< produce a message copy, except for a few connection-specific settings
     virtual HttpMsg *clone() const = 0; ///< \todo rename: not a true copy?
 
@@ -74,7 +68,7 @@ class HttpMsg
     bool persistent() const;
 
 public:
-    HttpVersion http_ver;
+    Http::ProtocolVersion http_ver;
 
     HttpHeader header;
 
@@ -95,8 +89,8 @@ class HttpMsg
 
     // returns true and sets hdr_sz on success
     // returns false and sets *error to zero when needs more data
-    // returns false and sets *error to a positive http_status code on error
-    bool parse(MemBuf *buf, bool eol, http_status *error);
+    // returns false and sets *error to a positive Http::StatusCode on error
+    bool parse(MemBuf *buf, bool eol, Http::StatusCode *error);
 
     bool parseCharBuf(const char *buf, ssize_t end);
 
@@ -118,72 +112,18 @@ class HttpMsg
      * \retval true   Status line has no serious problems.
      * \retval false  Status line has a serious problem. Correct response is indicated by error.
      */
-    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error) = 0;
+    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error) = 0;
 
     virtual void packFirstLineInto(Packer * p, bool full_uri) const = 0;
 
     virtual bool parseFirstLine(const char *blk_start, const char *blk_end) = 0;
 
     virtual void hdrCacheInit();
-
-    int lock_count;
-
 };
 
 int httpMsgIsolateHeaders(const char **parse_start, int len, const char **blk_start, const char **blk_end);
 
-#define HTTPMSGUNLOCK(a) if(a){(a)->_unlock();(a)=NULL;}
-#define HTTPMSGLOCK(a) (a)->_lock()
-
-// TODO: replace HTTPMSGLOCK with general RefCounting and delete this class
-/// safe HttpMsg pointer wrapper that locks and unlocks the message
-template <class Msg>
-class HttpMsgPointerT
-{
-public:
-    HttpMsgPointerT(): msg(NULL) {}
-    explicit HttpMsgPointerT(Msg *m): msg(m) { lock(); }
-    virtual ~HttpMsgPointerT() { unlock(); }
-
-    HttpMsgPointerT(const HttpMsgPointerT &p): msg(p.msg) { lock(); }
-    HttpMsgPointerT &operator =(const HttpMsgPointerT &p)
-    { if (msg != p.msg) { unlock(); msg = p.msg; lock(); } return *this; }
-    HttpMsgPointerT &operator =(Msg *newM)
-    { if (msg != newM) { unlock(); msg = newM; lock(); } return *this; }
-
-    /// support converting a child msg pointer into a parent msg pointer
-    template <typename Other>
-    HttpMsgPointerT(const HttpMsgPointerT<Other> &o): msg(o.raw()) { lock(); }
-
-    /// support assigning a child msg pointer to a parent msg pointer
-    template <typename Other>
-    HttpMsgPointerT &operator =(const HttpMsgPointerT<Other> &o)
-    { if (msg != o.raw()) { unlock(); msg = o.raw(); lock(); } return *this; }
-
-    Msg &operator *() { return *msg; }
-    const Msg &operator *() const { return *msg; }
-    Msg *operator ->() { return msg; }
-    const Msg *operator ->() const { return msg; }
-    operator Msg *() const { return msg; }
-    // add more as needed
-
-    /// public access for HttpMsgPointerT copying and assignment; avoid
-    Msg *raw() const { return msg; }
-
-protected:
-    void lock() { if (msg) HTTPMSGLOCK(msg); } ///< prevent msg destruction
-    void unlock() { HTTPMSGUNLOCK(msg); } ///< allows/causes msg destruction
-
-private:
-    Msg *msg;
-};
-
-/// convenience wrapper to create HttpMsgPointerT<> object based on msg type
-template <class Msg>
-inline
-HttpMsgPointerT<Msg> HttpMsgPointer(Msg *msg)
-{
-    return HttpMsgPointerT<Msg>(msg);
-}
+#define HTTPMSGUNLOCK(a) if (a) { if ((a)->unlock() == 0) delete (a); (a)=NULL; }
+#define HTTPMSGLOCK(a) (a)->lock()
 
 #endif /* SQUID_HTTPMSG_H */
@@ -8,7 +8,7 @@ void
 HttpParser::clear()
 {
     state = HTTP_PARSE_NONE;
-    request_parse_status = HTTP_STATUS_NONE;
+    request_parse_status = Http::scNone;
     buf = NULL;
     bufsiz = 0;
     req.start = req.end = -1;
@@ -96,7 +96,7 @@ HttpParser::parseRequestFirstLine()
 
             // RFC 2616 section 5.1
             // "No CR or LF is allowed except in the final CRLF sequence"
-            request_parse_status = HTTP_BAD_REQUEST;
+            request_parse_status = Http::scBadRequest;
             return -1;
         }
     }
@@ -116,25 +116,25 @@ HttpParser::parseRequestFirstLine()
 
     // First non-whitespace = beginning of method
     if (req.start > line_end) {
-        request_parse_status = HTTP_BAD_REQUEST;
+        request_parse_status = Http::scBadRequest;
         return -1;
     }
     req.m_start = req.start;
 
     // First whitespace = end of method
     if (first_whitespace > line_end || first_whitespace < req.start) {
-        request_parse_status = HTTP_BAD_REQUEST; // no method
+        request_parse_status = Http::scBadRequest; // no method
         return -1;
     }
     req.m_end = first_whitespace - 1;
     if (req.m_end < req.m_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI?
+        request_parse_status = Http::scBadRequest; // missing URI?
         return -1;
     }
 
     // First non-whitespace after first SP = beginning of URL+Version
     if (second_word > line_end || second_word < req.start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI
+        request_parse_status = Http::scBadRequest; // missing URI
         return -1;
     }
     req.u_start = second_word;
@@ -145,7 +145,7 @@ HttpParser::parseRequestFirstLine()
         req.v_maj = 0;
         req.v_min = 9;
         req.u_end = line_end;
-        request_parse_status = HTTP_OK; // HTTP/0.9
+        request_parse_status = Http::scOkay; // HTTP/0.9
         return 1;
     } else {
         // otherwise last whitespace is somewhere after end of URI.
@@ -154,13 +154,13 @@ HttpParser::parseRequestFirstLine()
         for (; req.u_end >= req.u_start && xisspace(buf[req.u_end]); --req.u_end);
     }
     if (req.u_end < req.u_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI
+        request_parse_status = Http::scBadRequest; // missing URI
         return -1;
     }
 
     // Last whitespace SP = before start of protocol/version
     if (last_whitespace >= line_end) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing version
+        request_parse_status = Http::scBadRequest; // missing version
         return -1;
     }
     req.v_start = last_whitespace + 1;
@@ -175,10 +175,11 @@ HttpParser::parseRequestFirstLine()
         req.v_maj = 0;
         req.v_min = 9;
         req.u_end = line_end;
-        request_parse_status = HTTP_OK; // treat as HTTP/0.9
+        request_parse_status = Http::scOkay; // treat as HTTP/0.9
         return 1;
 #else
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED; // protocol not supported / implemented.
+        // protocol not supported / implemented.
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
 #endif
     }
@@ -187,7 +188,7 @@ HttpParser::parseRequestFirstLine()
 
     /* next should be 1 or more digits */
     if (!isdigit(buf[i])) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     int maj = 0;
@@ -197,24 +198,24 @@ HttpParser::parseRequestFirstLine()
     }
     // catch too-big values or missing remainders
     if (maj >= 65536 || i > line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     req.v_maj = maj;
 
     /* next should be .; we -have- to have this as we have a whole line.. */
     if (buf[i] != '.') {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     // catch missing minor part
     if (++i > line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     /* next should be one or more digits */
     if (!isdigit(buf[i])) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     int min = 0;
@@ -224,15 +225,15 @@ HttpParser::parseRequestFirstLine()
     }
     // catch too-big values or trailing garbage
     if (min >= 65536 || i < line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     req.v_min = min;
 
     /*
      * Rightio - we have all the schtuff. Return true; we've got enough.
      */
-    request_parse_status = HTTP_OK;
+    request_parse_status = Http::scOkay;
     return 1;
 }
 
@@ -1,7 +1,7 @@
 #ifndef _SQUID_SRC_HTTPPARSER_H
 #define _SQUID_SRC_HTTPPARSER_H
 
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 
 // Parser states
 #define HTTP_PARSE_NONE   0 // nothing. completely unset state.
@@ -72,9 +72,9 @@ class HttpParser
     // TODO: Offsets for pieces of the (HTTP reply) Status-Line as per RFC 2616
 
     /** HTTP status code to be used on the invalid-request error page
-     * HTTP_STATUS_NONE indicates incomplete parse, HTTP_OK indicates no error.
+     * Http::scNone indicates incomplete parse, Http::scOkay indicates no error.
      */
-    http_status request_parse_status;
+    Http::StatusCode request_parse_status;
 };
 
 // Legacy functions
@@ -76,7 +76,7 @@ static http_hdr_type Denied304HeadersArr[] = {
 void
 httpReplyInitModule(void)
 {
-    assert(HTTP_STATUS_NONE == 0); // HttpReply::parse() interface assumes that
+    assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
     httpHeaderMaskInit(&Denied304HeadersMask, 0);
     httpHeaderCalcMask(&Denied304HeadersMask, Denied304HeadersArr, countof(Denied304HeadersArr));
 }
@@ -98,7 +98,7 @@ void
 HttpReply::init()
 {
     hdrCacheInit();
-    httpStatusLineInit(&sline);
+    sline.init();
     pstate = psReadyToParseStartLine;
     do_clean = true;
 }
@@ -126,14 +126,14 @@ HttpReply::clean()
     body.clear();
     hdrCacheClean();
     header.clean();
-    httpStatusLineClean(&sline);
+    sline.clean();
     bodySizeMax = -2; // hack: make calculatedBodySizeMax() false
 }
 
 void
 HttpReply::packHeadersInto(Packer * p) const
 {
-    httpStatusLinePackInto(&sline, p);
+    sline.packInto(p);
     header.packInto(p);
     packerAppend(p, "\r\n", 2);
 }
@@ -159,18 +159,6 @@ HttpReply::pack()
     return mb;
 }
 
-#if DEAD_CODE
-MemBuf *
-httpPackedReply(http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires)
-{
-    HttpReply *rep = new HttpReply;
-    rep->setHeaders(status, ctype, NULL, clen, lmt, expires);
-    MemBuf *mb = rep->pack();
-    delete rep;
-    return mb;
-}
-#endif
-
 HttpReply *
 HttpReply::make304() const
 {
@@ -188,8 +176,7 @@ HttpReply::make304() const
     /* rv->cache_control */
     /* rv->content_range */
     /* rv->keep_alive */
-    HttpVersion ver(1,1);
-    httpStatusLineSet(&rv->sline, ver, HTTP_NOT_MODIFIED, NULL);
+    rv->sline.set(Http::ProtocolVersion(1,1), Http::scNotModified, NULL);
 
     for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
         if ((e = header.findEntry(ImsEntries[t])))
@@ -212,12 +199,11 @@ HttpReply::packed304Reply()
 }
 
 void
-HttpReply::setHeaders(http_status status, const char *reason,
+HttpReply::setHeaders(Http::StatusCode status, const char *reason,
                       const char *ctype, int64_t clen, time_t lmt, time_t expiresTime)
 {
     HttpHeader *hdr;
-    HttpVersion ver(1,1);
-    httpStatusLineSet(&sline, ver, status, reason);
+    sline.set(Http::ProtocolVersion(1,1), status, reason);
     hdr = &header;
     hdr->putStr(HDR_SERVER, visible_appname_string);
     hdr->putStr(HDR_MIME_VERSION, "1.0");
@@ -248,11 +234,10 @@ HttpReply::setHeaders(http_status status, const char *reason,
 }
 
 void
-HttpReply::redirect(http_status status, const char *loc)
+HttpReply::redirect(Http::StatusCode status, const char *loc)
 {
     HttpHeader *hdr;
-    HttpVersion ver(1,1);
-    httpStatusLineSet(&sline, ver, status, httpStatusString(status));
+    sline.set(Http::ProtocolVersion(1,1), status, NULL);
     hdr = &header;
     hdr->putStr(HDR_SERVER, APP_FULLNAME);
     hdr->putTime(HDR_DATE, squid_curtime);
@@ -430,13 +415,13 @@ HttpReply::bodySize(const HttpRequestMethod& method) const
         return -1;
     else if (method.id() == Http::METHOD_HEAD)
         return 0;
-    else if (sline.status == HTTP_OK)
+    else if (sline.status() == Http::scOkay)
         (void) 0;		/* common case, continue */
-    else if (sline.status == HTTP_NO_CONTENT)
+    else if (sline.status() == Http::scNoContent)
         return 0;
-    else if (sline.status == HTTP_NOT_MODIFIED)
+    else if (sline.status() == Http::scNotModified)
         return 0;
-    else if (sline.status < HTTP_OK)
+    else if (sline.status() < Http::scOkay)
         return 0;
 
     return content_length;
@@ -449,7 +434,7 @@ HttpReply::bodySize(const HttpRequestMethod& method) const
  * NP: not all error cases are detected yet. Some are left for detection later in parse.
  */
 bool
-HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error)
+HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error)
 {
     // hack warning: using psize instead of size here due to type mismatches with MemBuf.
 
@@ -458,7 +443,7 @@ HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *
     if ( buf->contentSize() < (protoPrefix.psize() + 4) ) {
         if (hdr_len > 0) {
             debugs(58, 3, HERE << "Too small reply header (" << hdr_len << " bytes)");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
         }
         return false;
     }
@@ -473,7 +458,7 @@ HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *
 
         if (protoPrefix.cmp(buf->content(), protoPrefix.size()) != 0) {
             debugs(58, 3, "HttpReply::sanityCheckStartLine: missing protocol prefix (" << protoPrefix << ") in '" << buf->content() << "'");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
             return false;
         }
 
@@ -486,7 +471,7 @@ HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *
         // catch missing version info
         if (pos == protoPrefix.psize()) {
             debugs(58, 3, "HttpReply::sanityCheckStartLine: missing protocol version numbers (ie. " << protoPrefix << "/1.0) in '" << buf->content() << "'");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
             return false;
         }
     }
@@ -496,21 +481,17 @@ HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *
 
     if (pos < buf->contentSize() && !xisdigit(*(buf->content()+pos))) {
         debugs(58, 3, "HttpReply::sanityCheckStartLine: missing or invalid status number in '" << buf->content() << "'");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false;
     }
 
     return true;
 }
 
-void HttpReply::packFirstLineInto(Packer *p, bool unused) const
-{
-    httpStatusLinePackInto(&sline, p);
-}
-
-bool HttpReply::parseFirstLine(const char *blk_start, const char *blk_end)
+bool
+HttpReply::parseFirstLine(const char *blk_start, const char *blk_end)
 {
-    return httpStatusLineParse(&sline, protoPrefix, blk_start, blk_end);
+    return sline.parse(protoPrefix, blk_start, blk_end);
 }
 
 /* handy: resets and returns -1 */
@@ -519,7 +500,7 @@ HttpReply::httpMsgParseError()
 {
     int result(HttpMsg::httpMsgParseError());
     /* indicate an error in the status line */
-    sline.status = HTTP_INVALID_HEADER;
+    sline.set(Http::ProtocolVersion(1,1), Http::scInvalidHeader);
     return result;
 }
 
@@ -534,11 +515,11 @@ HttpReply::expectingBody(const HttpRequestMethod& req_method, int64_t& theSize)
 
     if (req_method == Http::METHOD_HEAD)
         expectBody = false;
-    else if (sline.status == HTTP_NO_CONTENT)
+    else if (sline.status() == Http::scNoContent)
         expectBody = false;
-    else if (sline.status == HTTP_NOT_MODIFIED)
+    else if (sline.status() == Http::scNotModified)
         expectBody = false;
-    else if (sline.status < HTTP_OK)
+    else if (sline.status() < Http::scOkay)
         expectBody = false;
     else
         expectBody = true;
@@ -585,7 +566,7 @@ HttpReply::expectedBodyTooLarge(HttpRequest& request)
 }
 
 void
-HttpReply::calcMaxBodySize(HttpRequest& request)
+HttpReply::calcMaxBodySize(HttpRequest& request) const
 {
     // hack: -2 is used as "we have not calculated max body size yet" state
     if (bodySizeMax != -2) // already tried
@@ -597,7 +578,9 @@ HttpReply::calcMaxBodySize(HttpRequest& request)
         return;
 
     ACLFilledChecklist ch(NULL, &request, NULL);
-    ch.reply = HTTPMSGLOCK(this); // XXX: this lock makes method non-const
+    // XXX: cont-cast becomes irrelevant when checklist is HttpReply::Pointer
+    ch.reply = const_cast<HttpReply *>(this);
+    HTTPMSGLOCK(ch.reply);
     for (AclSizeLimit *l = Config.ReplyBodySize; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this size value */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
@@ -33,15 +33,10 @@
 #include "HttpBody.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
-#include "HttpStatusLine.h"
+#include "http/StatusLine.h"
 
 void httpReplyInitModule(void);
 
-#if DEAD_CODE
-/** do everything in one call: init, set, pack, clean, return MemBuf */
-MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
-#endif
-
 /* Sync changes here with HttpReply.cc */
 
 class HttpHdrContRange;
@@ -52,27 +47,20 @@ class HttpReply: public HttpMsg
 {
 
 public:
-    typedef HttpMsgPointerT<HttpReply> Pointer;
+    typedef RefCount<HttpReply> Pointer;
 
     MEMPROXY_CLASS(HttpReply);
     HttpReply();
     ~HttpReply();
 
     virtual void reset();
 
-    /// \par use HTTPMSGLOCK() instead of calling this directly
-    virtual HttpReply *_lock() {
-        return static_cast<HttpReply*>(HttpMsg::_lock());
-    };
-
-    //virtual void unlock();  // only needed for debugging
-
     /**
      \retval true on success
      \retval false and sets *error to zero when needs more data
-     \retval false and sets *error to a positive http_status code on error
+     \retval false and sets *error to a positive Http::StatusCode on error
      */
-    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error);
+    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error);
 
     /** \par public, readable; never update these or their .hdr equivalents directly */
     time_t date;
@@ -90,7 +78,7 @@ class HttpReply: public HttpMsg
     short int keep_alive;
 
     /** \par public, writable, but use httpReply* interfaces when possible */
-    HttpStatusLine sline;
+    Http::StatusLine sline;
 
     HttpBody body;		/**< for small constant memory-resident text bodies only */
 
@@ -108,7 +96,7 @@ class HttpReply: public HttpMsg
     void updateOnNotModified(HttpReply const *other);
 
     /** set commonly used info with one call */
-    void setHeaders(http_status status,
+    void setHeaders(Http::StatusCode status,
                     const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires);
 
     /** \return a ready to use mem buffer with a packed reply */
@@ -117,7 +105,7 @@ class HttpReply: public HttpMsg
     /** construct a 304 reply and return it */
     HttpReply *make304() const;
 
-    void redirect(http_status, const char *);
+    void redirect(Http::StatusCode, const char *);
 
     int64_t bodySize(const HttpRequestMethod&) const;
 
@@ -163,14 +151,14 @@ class HttpReply: public HttpMsg
     /** Calculates and stores maximum body size if needed.
      * Used by receivedBodyTooLarge() and expectedBodyTooLarge().
      */
-    void calcMaxBodySize(HttpRequest& request);
+    void calcMaxBodySize(HttpRequest& request) const;
 
     String removeStaleWarningValues(const String &value);
 
     mutable int64_t bodySizeMax; /**< cached result of calcMaxBodySize */
 
 protected:
-    virtual void packFirstLineInto(Packer * p, bool) const;
+    virtual void packFirstLineInto(Packer * p, bool) const { sline.packInto(p); }
 
     virtual bool parseFirstLine(const char *start, const char *end);
 
@@ -116,6 +116,7 @@ HttpRequest::init()
     errDetail = ERR_DETAIL_NONE;
     peer_login = NULL;		// not allocated/deallocated by this class
     peer_domain = NULL;		// not allocated/deallocated by this class
+    peer_host = NULL;
     vary_headers = NULL;
     myportname = null_string;
     tag = null_string;
@@ -292,23 +293,23 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
  * NP: Other errors are left for detection later in the parse.
  */
 bool
-HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error)
+HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error)
 {
     // content is long enough to possibly hold a reply
     // 2 being magic size of a 1-byte request method plus space delimiter
     if ( buf->contentSize() < 2 ) {
         // this is ony a real error if the headers apparently complete.
         if (hdr_len > 0) {
             debugs(58, 3, HERE << "Too large request header (" << hdr_len << " bytes)");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
         }
         return false;
     }
 
     /* See if the request buffer starts with a known HTTP request method. */
     if (HttpRequestMethod(buf->content(),NULL) == Http::METHOD_NONE) {
         debugs(73, 3, "HttpRequest::sanityCheckStartLine: did not find HTTP request method");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false;
     }
 
@@ -674,7 +675,7 @@ HttpRequest::canHandle1xx() const
 {
     // old clients do not support 1xx unless they sent Expect: 100-continue
     // (we reject all other HDR_EXPECT values so just check for HDR_EXPECT)
-    if (http_ver <= HttpVersion(1,0) && !header.has(HDR_EXPECT))
+    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(HDR_EXPECT))
         return false;
 
     // others must support 1xx control messages
@@ -688,3 +689,16 @@ HttpRequest::pinnedConnection()
         return clientConnectionManager.get();
     return NULL;
 }
+
+const char *
+HttpRequest::storeId()
+{
+    if (store_id.size() != 0) {
+        debugs(73, 3, "sent back store_id:" << store_id);
+
+        return store_id.termedBuf();
+    }
+    debugs(73, 3, "sent back canonicalUrl:" << urlCanonical(this) );
+
+    return urlCanonical(this);
+}
@@ -66,19 +66,14 @@ class HttpRequest: public HttpMsg
 {
 
 public:
-    typedef HttpMsgPointerT<HttpRequest> Pointer;
+    typedef RefCount<HttpRequest> Pointer;
 
     MEMPROXY_CLASS(HttpRequest);
     HttpRequest();
     HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
     ~HttpRequest();
     virtual void reset();
 
-    // use HTTPMSGLOCK() instead of calling this directly
-    virtual HttpRequest *_lock() {
-        return static_cast<HttpRequest*>(HttpMsg::_lock());
-    };
-
     void initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
 
     virtual HttpRequest *clone() const;
@@ -165,6 +160,14 @@ class HttpRequest: public HttpMsg
 
     char *canonical;
 
+    /**
+     * If defined, store_id_program mapped the request URL to this ID.
+     * Store uses this ID (and not the URL) to find and store entries,
+     * avoiding caching duplicate entries when different URLs point to
+     * "essentially the same" cachable resource.
+     */
+    String store_id;
+
     RequestFlags flags;
 
     HttpHdrRange *range;
@@ -241,6 +244,14 @@ class HttpRequest: public HttpMsg
 
     ConnStateData *pinnedConnection();
 
+    /**
+     * Returns the current StoreID for the request as a nul-terminated char*.
+     * Always returns the current id for the request
+     * (either the request canonical url or modified ID by the helper).
+     * Does not return NULL.
+     */
+    const char *storeId();
+
     /**
      * The client connection manager, if known;
      * Used for any response actions needed directly to the client.
@@ -258,7 +269,7 @@ class HttpRequest: public HttpMsg
 protected:
     virtual void packFirstLineInto(Packer * p, bool full_uri) const;
 
-    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error);
+    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error);
 
     virtual void hdrCacheInit();
 
@@ -1,68 +0,0 @@
-#ifndef _SQUID_SRC_HTTP_STATUSCODE_H
-#define _SQUID_SRC_HTTP_STATUSCODE_H
-
-/**
- * These basic HTTP reply status codes are defined by RFC 2616 unless otherwise stated.
- */
-typedef enum {
-    HTTP_STATUS_NONE = 0,
-    HTTP_CONTINUE = 100,
-    HTTP_SWITCHING_PROTOCOLS = 101,
-    HTTP_PROCESSING = 102,      /**< RFC2518 section 10.1 */
-    HTTP_OK = 200,
-    HTTP_CREATED = 201,
-    HTTP_ACCEPTED = 202,
-    HTTP_NON_AUTHORITATIVE_INFORMATION = 203,
-    HTTP_NO_CONTENT = 204,
-    HTTP_RESET_CONTENT = 205,
-    HTTP_PARTIAL_CONTENT = 206,
-    HTTP_MULTI_STATUS = 207,    /**< RFC2518 section 10.2 */
-    HTTP_MULTIPLE_CHOICES = 300,
-    HTTP_MOVED_PERMANENTLY = 301,
-    HTTP_MOVED_TEMPORARILY = 302,
-    HTTP_SEE_OTHER = 303,
-    HTTP_NOT_MODIFIED = 304,
-    HTTP_USE_PROXY = 305,
-    HTTP_TEMPORARY_REDIRECT = 307,
-    HTTP_PERMANENT_REDIRECT = 308,
-    HTTP_BAD_REQUEST = 400,
-    HTTP_UNAUTHORIZED = 401,
-    HTTP_PAYMENT_REQUIRED = 402,
-    HTTP_FORBIDDEN = 403,
-    HTTP_NOT_FOUND = 404,
-    HTTP_METHOD_NOT_ALLOWED = 405,
-    HTTP_NOT_ACCEPTABLE = 406,
-    HTTP_PROXY_AUTHENTICATION_REQUIRED = 407,
-    HTTP_REQUEST_TIMEOUT = 408,
-    HTTP_CONFLICT = 409,
-    HTTP_GONE = 410,
-    HTTP_LENGTH_REQUIRED = 411,
-    HTTP_PRECONDITION_FAILED = 412,
-    HTTP_REQUEST_ENTITY_TOO_LARGE = 413,
-    HTTP_REQUEST_URI_TOO_LARGE = 414,
-    HTTP_UNSUPPORTED_MEDIA_TYPE = 415,
-    HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416,
-    HTTP_EXPECTATION_FAILED = 417,
-    HTTP_UNPROCESSABLE_ENTITY = 422,    /**< RFC2518 section 10.3 */
-    HTTP_LOCKED = 423,                  /**< RFC2518 section 10.4 */
-    HTTP_FAILED_DEPENDENCY = 424,       /**< RFC2518 section 10.5 */
-    HTTP_PRECONDITION_REQUIRED = 428,   /**< RFC6585 */
-    HTTP_TOO_MANY_REQUESTS = 429,       /**< RFC6585 */
-    HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431, /**< RFC6585 */
-    HTTP_INTERNAL_SERVER_ERROR = 500,
-    HTTP_NOT_IMPLEMENTED = 501,
-    HTTP_BAD_GATEWAY = 502,
-    HTTP_SERVICE_UNAVAILABLE = 503,
-    HTTP_GATEWAY_TIMEOUT = 504,
-    HTTP_HTTP_VERSION_NOT_SUPPORTED = 505,
-    HTTP_INSUFFICIENT_STORAGE = 507,    /**< RFC2518 section 10.6 */
-    HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511, /**< RFC6585 */
-
-    // The 6xx codes below are for internal use only: Bad requests result
-    // in HTTP_BAD_REQUEST; bad responses in HTTP_GATEWAY_TIMEOUT.
-
-    HTTP_INVALID_HEADER = 600,          /**< Squid header parsing error */
-    HTTP_HEADER_TOO_LARGE = 601         /* Header too large to process */
-} http_status;
-
-#endif /* _SQUID_SRC_HTTP_STATUSCODE_H */
@@ -1,347 +0,0 @@
-
-/*
- * DEBUG: section 57    HTTP Status-line
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-#include "Debug.h"
-#include "HttpStatusLine.h"
-#include "Packer.h"
-
-/* local constants */
-/* AYJ: see bug 2469 - RFC2616 confirms stating 'SP characters' plural! */
-const char *HttpStatusLineFormat = "HTTP/%d.%d %3d %s\r\n";
-const char *IcyStatusLineFormat = "ICY %3d %s\r\n";
-
-void
-httpStatusLineInit(HttpStatusLine * sline)
-{
-    HttpVersion version;
-    httpStatusLineSet(sline, version, HTTP_STATUS_NONE, NULL);
-}
-
-void
-httpStatusLineClean(HttpStatusLine * sline)
-{
-    HttpVersion version;
-    httpStatusLineSet(sline, version, HTTP_INTERNAL_SERVER_ERROR, NULL);
-}
-
-/* set values */
-void
-httpStatusLineSet(HttpStatusLine * sline, HttpVersion version, http_status status, const char *reason)
-{
-    assert(sline);
-    sline->protocol = AnyP::PROTO_HTTP;
-    sline->version = version;
-    sline->status = status;
-    /* Note: no xstrdup for 'reason', assumes constant 'reasons' */
-    sline->reason = reason;
-}
-
-/**
- * Write HTTP version and status structures into a Packer buffer for output as HTTP status line.
- * Special exemption made for ICY response status lines.
- */
-void
-httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p)
-{
-    assert(sline && p);
-
-    /* handle ICY protocol status line specially. Pass on the bad format. */
-    if (sline->protocol == AnyP::PROTO_ICY) {
-        debugs(57, 9, "packing sline " << sline << " using " << p << ":");
-        debugs(57, 9, "FORMAT=" << IcyStatusLineFormat );
-        debugs(57, 9, "ICY " << sline->status << " " << (sline->reason ? sline->reason : httpStatusString(sline->status)) );
-        packerPrintf(p, IcyStatusLineFormat, sline->status, httpStatusLineReason(sline));
-        return;
-    }
-
-    debugs(57, 9, "packing sline " << sline << " using " << p << ":");
-    debugs(57, 9, "FORMAT=" << HttpStatusLineFormat );
-    debugs(57, 9, "HTTP/" << sline->version.major << "." << sline->version.minor <<
-           " " << sline->status << " " << (sline->reason ? sline->reason : httpStatusString(sline->status)) );
-    packerPrintf(p, HttpStatusLineFormat, sline->version.major,
-                 sline->version.minor, sline->status, httpStatusLineReason(sline));
-}
-
-/*
- * Parse character string into 'sline'.  Note 'end' currently unused,
- * so NULL-termination assumed.
- */
-int
-httpStatusLineParse(HttpStatusLine * sline, const String &protoPrefix, const char *start, const char *end)
-{
-    assert(sline);
-    sline->status = HTTP_INVALID_HEADER;	/* Squid header parsing error */
-
-    // XXX: HttpMsg::parse() has a similar check but is using
-    // casesensitive comparison (which is required by HTTP errata?)
-
-    if (protoPrefix.cmp("ICY", 3) == 0) {
-        debugs(57, 3, "httpStatusLineParse: Invalid HTTP identifier. Detected ICY protocol istead.");
-        sline->protocol = AnyP::PROTO_ICY;
-        start += protoPrefix.size();
-    } else if (protoPrefix.caseCmp(start, protoPrefix.size()) == 0) {
-
-        start += protoPrefix.size();
-
-        if (!xisdigit(*start))
-            return 0;
-
-        if (sscanf(start, "%d.%d", &sline->version.major, &sline->version.minor) != 2) {
-            debugs(57, 7, "httpStatusLineParse: Invalid HTTP identifier.");
-        }
-    } else
-        return 0;
-
-    if (!(start = strchr(start, ' ')))
-        return 0;
-
-    sline->status = (http_status) atoi(++start);
-
-    /* we ignore 'reason-phrase' */
-    /* Should assert start < end ? */
-    return 1;			/* success */
-}
-
-const char *
-httpStatusLineReason(const HttpStatusLine * sline)
-{
-    assert(sline);
-    return sline->reason ? sline->reason : httpStatusString(sline->status);
-}
-
-const char *
-httpStatusString(http_status status)
-{
-    /* why not to return matching string instead of using "p" ? @?@ */
-    const char *p = NULL;
-
-    switch (status) {
-
-    case 0:
-        p = "Init";		/* we init .status with code 0 */
-        break;
-
-    case HTTP_CONTINUE:
-        p = "Continue";
-        break;
-
-    case HTTP_SWITCHING_PROTOCOLS:
-        p = "Switching Protocols";
-        break;
-
-    case HTTP_OK:
-        p = "OK";
-        break;
-
-    case HTTP_CREATED:
-        p = "Created";
-        break;
-
-    case HTTP_ACCEPTED:
-        p = "Accepted";
-        break;
-
-    case HTTP_NON_AUTHORITATIVE_INFORMATION:
-        p = "Non-Authoritative Information";
-        break;
-
-    case HTTP_NO_CONTENT:
-        p = "No Content";
-        break;
-
-    case HTTP_RESET_CONTENT:
-        p = "Reset Content";
-        break;
-
-    case HTTP_PARTIAL_CONTENT:
-        p = "Partial Content";
-        break;
-
-    case HTTP_MULTI_STATUS:
-        p = "Multi-Status";
-        break;
-
-    case HTTP_MULTIPLE_CHOICES:
-        p = "Multiple Choices";
-        break;
-
-    case HTTP_MOVED_PERMANENTLY:
-        p = "Moved Permanently";
-        break;
-
-    case HTTP_MOVED_TEMPORARILY:
-        p = "Moved Temporarily";
-        break;
-
-    case HTTP_SEE_OTHER:
-        p = "See Other";
-        break;
-
-    case HTTP_NOT_MODIFIED:
-        p = "Not Modified";
-        break;
-
-    case HTTP_USE_PROXY:
-        p = "Use Proxy";
-        break;
-
-    case HTTP_TEMPORARY_REDIRECT:
-        p = "Temporary Redirect";
-        break;
-
-    case HTTP_PERMANENT_REDIRECT:
-        p = "Permanent Redirect";
-        break;
-
-    case HTTP_BAD_REQUEST:
-        p = "Bad Request";
-        break;
-
-    case HTTP_UNAUTHORIZED:
-        p = "Unauthorized";
-        break;
-
-    case HTTP_PAYMENT_REQUIRED:
-        p = "Payment Required";
-        break;
-
-    case HTTP_FORBIDDEN:
-        p = "Forbidden";
-        break;
-
-    case HTTP_NOT_FOUND:
-        p = "Not Found";
-        break;
-
-    case HTTP_METHOD_NOT_ALLOWED:
-        p = "Method Not Allowed";
-        break;
-
-    case HTTP_NOT_ACCEPTABLE:
-        p = "Not Acceptable";
-        break;
-
-    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
-        p = "Proxy Authentication Required";
-        break;
-
-    case HTTP_REQUEST_TIMEOUT:
-        p = "Request Time-out";
-        break;
-
-    case HTTP_CONFLICT:
-        p = "Conflict";
-        break;
-
-    case HTTP_GONE:
-        p = "Gone";
-        break;
-
-    case HTTP_LENGTH_REQUIRED:
-        p = "Length Required";
-        break;
-
-    case HTTP_PRECONDITION_FAILED:
-        p = "Precondition Failed";
-        break;
-
-    case HTTP_REQUEST_ENTITY_TOO_LARGE:
-        p = "Request Entity Too Large";
-        break;
-
-    case HTTP_REQUEST_URI_TOO_LARGE:
-        p = "Request-URI Too Large";
-        break;
-
-    case HTTP_UNSUPPORTED_MEDIA_TYPE:
-        p = "Unsupported Media Type";
-        break;
-
-    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:
-        p = "Requested Range Not Satisfiable";
-        break;
-
-    case HTTP_EXPECTATION_FAILED:
-        p = "Expectation Failed";
-        break;
-
-    case HTTP_INTERNAL_SERVER_ERROR:
-        p = "Internal Server Error";
-        break;
-
-    case HTTP_NOT_IMPLEMENTED:
-        p = "Not Implemented";
-        break;
-
-    case HTTP_BAD_GATEWAY:
-        p = "Bad Gateway";
-        break;
-
-    case HTTP_SERVICE_UNAVAILABLE:
-        p = "Service Unavailable";
-        break;
-
-    case HTTP_GATEWAY_TIMEOUT:
-        p = "Gateway Time-out";
-        break;
-
-    case HTTP_HTTP_VERSION_NOT_SUPPORTED:
-        p = "HTTP Version not supported";
-        break;
-
-        // RFC 6585
-    case HTTP_PRECONDITION_REQUIRED: // 428
-        p = "Precondition Required";
-        break;
-
-    case HTTP_TOO_MANY_REQUESTS: // 429
-        p = "Too Many Requests";
-        break;
-
-    case HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE: // 431
-        p = "Request Header Fields Too Large";
-        break;
-
-    case HTTP_NETWORK_AUTHENTICATION_REQUIRED: // 511
-        p = "Network Authentication Required";
-        break;
-
-    default:
-        p = "Unknown";
-        debugs(57, 3, "Unknown HTTP status code: " << status);
-        break;
-    }
-
-    return p;
-}
@@ -1,46 +0,0 @@
-
-/*
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
- */
-
-#ifndef SQUID_HTTPVERSION_H
-#define SQUID_HTTPVERSION_H
-
-#include "anyp/ProtocolVersion.h"
-
-class HttpVersion : public AnyP::ProtocolVersion
-{
-public:
-    HttpVersion() : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,0) {}
-
-    HttpVersion(unsigned int aMajor, unsigned int aMinor) : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,aMajor,aMinor) {}
-};
-
-#endif /* SQUID_HTTPVERSION_H */
@@ -40,6 +40,7 @@
 #include "icp_opcode.h"
 #include "ip/Address.h"
 #include "StoreClient.h"
+#include "LogTags.h"
 
 class HttpRequest;
 
@@ -122,7 +123,7 @@ struct icpUdpData {
     struct timeval start;
 #endif
 
-    log_type logcode;
+    LogTags logcode;
 
     struct timeval queue_time;
 };
@@ -144,10 +145,10 @@ void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pa
 icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, LogTags, int);
 
 /// \ingroup ServerProtocolICPAPI
-log_type icpLogFromICPCode(icp_opcode opcode);
+LogTags icpLogFromICPCode(icp_opcode opcode);
 
 /// \ingroup ServerProtocolICPAPI
 void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd);
@@ -45,15 +45,20 @@
 /* ========================================================================= */
 
 LeakFinderPtr::LeakFinderPtr(void *p , const char *f, const int l) :
-        file(f), line(l), when(squid_curtime)
+        file(f),
+        line(l),
+        when(squid_curtime)
 {
+    // XXX: these bits should be done by hash_link()
     key = p;
     next = NULL;
 }
 
 /* ========================================================================= */
 
-LeakFinder::LeakFinder()
+LeakFinder::LeakFinder() :
+        count(0),
+        last_dump(0)
 {
     debugs(45, 3, "LeakFinder constructed");
     table = hash_create(cmp, 1 << 8, hash);
@@ -0,0 +1,62 @@
+#ifndef SQUID_SRC_LOGTAGS_H
+#define SQUID_SRC_LOGTAGS_H
+
+/** Squid transaction result code/tag set.
+ *
+ * These codes indicate how the request was received
+ * and some details about its processing pathway.
+ *
+ * see also http://wiki.squid-cache.org/SquidFaq/SquidLogs#Squid_result_codes
+ * for details on particular components.
+ */
+typedef enum {
+    LOG_TAG_NONE = 0,
+    LOG_TCP_HIT,
+    LOG_TCP_MISS,
+    LOG_TCP_REFRESH_UNMODIFIED, // refresh from origin revalidated existing entry
+    LOG_TCP_REFRESH_FAIL_OLD,   // refresh from origin failed, stale reply sent
+    LOG_TCP_REFRESH_FAIL_ERR,   // refresh from origin failed, error forwarded
+    LOG_TCP_REFRESH_MODIFIED,   // refresh from origin replaced existing entry
+    LOG_TCP_CLIENT_REFRESH_MISS,
+    LOG_TCP_IMS_HIT,
+    LOG_TCP_SWAPFAIL_MISS,
+    LOG_TCP_NEGATIVE_HIT,
+    LOG_TCP_MEM_HIT,
+    LOG_TCP_DENIED,
+    LOG_TCP_DENIED_REPLY,
+    LOG_TCP_OFFLINE_HIT,
+    LOG_TCP_REDIRECT,
+    LOG_UDP_HIT,
+    LOG_UDP_MISS,
+    LOG_UDP_DENIED,
+    LOG_UDP_INVALID,
+    LOG_UDP_MISS_NOFETCH,
+    LOG_ICP_QUERY,
+    LOG_TYPE_MAX
+} LogTags;
+
+/// list of string representations for LogTags
+extern const char *LogTags_str[];
+
+/// determine if the log tag code indicates a cache HIT
+inline bool logTypeIsATcpHit(LogTags code)
+{
+    return
+        (code == LOG_TCP_HIT) ||
+        (code == LOG_TCP_IMS_HIT) ||
+        (code == LOG_TCP_REFRESH_FAIL_OLD) ||
+        (code == LOG_TCP_REFRESH_UNMODIFIED) ||
+        (code == LOG_TCP_NEGATIVE_HIT) ||
+        (code == LOG_TCP_MEM_HIT) ||
+        (code == LOG_TCP_OFFLINE_HIT);
+}
+
+/// iterator for LogTags enumeration
+inline LogTags &operator++ (LogTags &aLogType)
+{
+    int tmp = (int)aLogType;
+    aLogType = (LogTags)(++tmp);
+    return aLogType;
+}
+
+#endif
@@ -371,9 +371,6 @@ squid_SOURCES = \
 	HttpStateFlags.h \
 	http.cc \
 	http.h \
-	HttpStatusCode.h \
-	HttpStatusLine.cc \
-	HttpStatusLine.h \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
@@ -408,7 +405,6 @@ squid_SOURCES = \
 	HttpRequest.h \
 	HttpRequestMethod.cc \
 	HttpRequestMethod.h \
-	HttpVersion.h \
 	ICP.h \
 	icp_opcode.h \
 	icp_v2.cc \
@@ -423,6 +419,7 @@ squid_SOURCES = \
 	$(LEAKFINDERSOURCE) \
 	SquidList.h \
 	SquidList.cc \
+	LogTags.h \
 	lookup_t.h \
 	main.cc \
 	Mem.h \
@@ -603,6 +600,7 @@ BUILT_SOURCES = \
 	globals.cc \
 	hier_code.cc \
 	icp_opcode.cc \
+	LogTags.cc \
 	lookup_t.cc \
 	repl_modules.cc \
 	swap_log_op.cc
@@ -956,6 +954,9 @@ err_type.cc: err_type.h mk-string-arrays.awk
 err_detail_type.cc: err_detail_type.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/err_detail_type.h | sed 's/ERR_DETAIL_//' > $@ || ($(RM) -f $@ && exit 1)
 
+LogTags.cc: LogTags.h mk-string-arrays.awk
+	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/LogTags.h | sed 's/LOG_//' > $@ || ($(RM) -f $@ && exit 1)
+
 lookup_t.cc: lookup_t.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/lookup_t.h > $@ || ($(RM) -f $@ && exit 1)
 
@@ -1149,9 +1150,6 @@ tests_testHttpReply_SOURCES=\
 	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
-	HttpStatusCode.h \
-	HttpStatusLine.cc \
-	HttpStatusLine.h \
 	Mem.h \
 	mem.cc \
 	RegexList.h \
@@ -1199,6 +1197,7 @@ nodist_tests_testHttpReply_SOURCES=\
 	$(TESTSOURCES)
 tests_testHttpReply_LDFLAGS = $(LIBADD_DL)
 tests_testHttpReply_LDADD=\
+	http/libsquid-http.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
@@ -1475,7 +1474,6 @@ tests_testCacheManager_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
@@ -1639,6 +1637,8 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
+	fde.h \
+	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
@@ -1659,7 +1659,6 @@ tests_testDiskIO_SOURCES = \
 	HttpMsg.cc \
 	HttpReply.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
@@ -1889,7 +1888,6 @@ tests_testEvent_SOURCES = \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
@@ -2136,7 +2134,6 @@ tests_testEventLoop_SOURCES = \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
@@ -2380,7 +2377,6 @@ tests_test_http_range_SOURCES = \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	int.h \
@@ -2669,7 +2665,6 @@ tests_testHttpRequest_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
@@ -2902,6 +2897,7 @@ tests_testStore_SOURCES= \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
 	fd.h \
+	fde.h \
 	tests/stub_fd.cc \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
@@ -3061,6 +3057,8 @@ tests_testUfs_SOURCES = \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
+	fde.h \
+	fde.cc \
 	client_db.h \
 	disk.h \
 	disk.cc \
@@ -3069,7 +3067,6 @@ tests_testUfs_SOURCES = \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	RequestFlags.h \
@@ -3239,6 +3236,8 @@ tests_testRock_SOURCES = \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
+	fde.h \
+	fde.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpHeaderFieldStat.h \
@@ -3257,7 +3256,6 @@ tests_testRock_SOURCES = \
 	HttpMsg.cc \
 	HttpReply.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
@@ -3401,14 +3399,15 @@ tests_testCoss_SOURCES = \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
+	fde.h \
+	fde.cc \
 	disk.h \
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
@@ -3635,7 +3634,6 @@ tests_testURL_SOURCES = \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
@@ -75,7 +75,7 @@ void memFreeString(size_t size, void *);
 void memFreeBuf(size_t size, void *);
 FREE *memFreeBufFunc(size_t size);
 int memInUse(mem_type);
-void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
+void memDataInit(mem_type, const char *, size_t, int, bool doZero = true);
 void memCheckInit(void);
 void memConfigure(void);
 
@@ -86,9 +86,9 @@ MemObject::resetUrls(char const *aUrl, char const *aLog_url)
 MemObject::MemObject(char const *aUrl, char const *aLog_url)
 {
     debugs(20, 3, HERE << "new MemObject " << this);
-    HttpReply *rep = new HttpReply;
+    _reply = new HttpReply;
+    HTTPMSGLOCK(_reply);
 
-    _reply  = HTTPMSGLOCK(rep);
     url = xstrdup(aUrl);
 
 #if URL_CHECKSUM_DEBUG
@@ -182,7 +182,7 @@ MemObject::dump() const
     debugs(20, DBG_IMPORTANT, "MemObject->nclients: " << nclients);
     debugs(20, DBG_IMPORTANT, "MemObject->reply: " << _reply);
     debugs(20, DBG_IMPORTANT, "MemObject->request: " << request);
-    debugs(20, DBG_IMPORTANT, "MemObject->log_url: " << log_url << " " << checkNullString(log_url));
+    debugs(20, DBG_IMPORTANT, "MemObject->log_url: " << checkNullString(log_url));
 }
 
 HttpReply const *
@@ -195,7 +195,8 @@ void
 MemObject::replaceHttpReply(HttpReply *newrep)
 {
     HTTPMSGUNLOCK(_reply);
-    _reply = HTTPMSGLOCK(newrep);
+    _reply = newrep;
+    HTTPMSGLOCK(_reply);
 }
 
 struct LowestMemReader : public unary_function<store_client, void> {
@@ -59,8 +59,9 @@ Note::match(HttpRequest *request, HttpReply *reply)
 
     typedef Values::iterator VLI;
     ACLFilledChecklist ch(NULL, request, NULL);
+    ch.reply = reply;
     if (reply)
-        ch.reply = HTTPMSGLOCK(reply);
+        HTTPMSGLOCK(ch.reply);
 
     for (VLI i = values.begin(); i != values.end(); ++i ) {
         const int ret= ch.fastCheck((*i)->aclList);
@@ -34,6 +34,8 @@
 #include "cache_cf.h"
 #include "compat/strtoll.h"
 #include "Parsing.h"
+#include "globals.h"
+#include "Debug.h"
 
 /*
  * These functions is the same as atoi/l/f, except that they check for errors
@@ -42,29 +44,83 @@
 double
 xatof(const char *token)
 {
-    char *end;
+    char *end = NULL;
     double ret = strtod(token, &end);
 
-    if (ret == 0 && end == token)
+    if (ret == 0 && end == token) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: No digits were found in the input value '" << token << "'.");
         self_destruct();
+    }
+
+    if (*end) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid value: '" << token << "' is supposed to be a number.");
+        self_destruct();
+    }
 
     return ret;
 }
 
 int
 xatoi(const char *token)
 {
-    return xatol(token);
+    int64_t input = xatoll(token, 10);
+    int ret = (int) input;
+
+    if (input != static_cast<int64_t>(ret)) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is larger than the type 'int'.");
+        self_destruct();
+    }
+
+    return ret;
+}
+
+unsigned int
+xatoui(const char *token)
+{
+    int64_t input = xatoll(token, 10);
+    if (input < 0) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The input value '" << token << "' cannot be less than 0.");
+        self_destruct();
+    }
+
+    unsigned int ret = (unsigned int) input;
+    if (input != static_cast<int64_t>(ret)) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is larger than the type 'unsigned int'.");
+        self_destruct();
+    }
+
+    return ret;
 }
 
 long
 xatol(const char *token)
 {
-    char *end;
-    long ret = strtol(token, &end, 10);
+    int64_t input = xatoll(token, 10);
+    long ret = (long) input;
+
+    if (input != static_cast<int64_t>(ret)) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is larger than the type 'long'.");
+        self_destruct();
+    }
+
+    return ret;
+}
+
+int64_t
+xatoll(const char *token, int base)
+{
+    char *end = NULL;
+    int64_t ret = strtoll(token, &end, base);
+
+    if (end == token) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: No digits were found in the input value '" << token << "'.");
+        self_destruct();
+    }
 
-    if (end == token || *end)
+    if (*end) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid value: '" << token << "' is supposed to be a number.");
         self_destruct();
+    }
 
     return ret;
 }
@@ -74,8 +130,15 @@ xatos(const char *token)
 {
     long port = xatol(token);
 
-    if (port & ~0xFFFF)
+    if (port < 0) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' cannot be less than 0.");
+        self_destruct();
+    }
+
+    if (port & ~0xFFFF) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is larger than the type 'short'.");
         self_destruct();
+    }
 
     return port;
 }
@@ -84,16 +147,17 @@ int64_t
 GetInteger64(void)
 {
     char *token = strtok(NULL, w_space);
-    int i;
 
     if (token == NULL)
         self_destruct();
 
-    i = strtoll(token, NULL, 10);
-
-    return i;
+    return xatoll(token, 10);
 }
 
+/*
+ * This function is different from others (e.g., GetInteger64, GetShort)
+ * because it supports octal and hexadecimal numbers
+ */
 int
 GetInteger(void)
 {
@@ -103,13 +167,51 @@ GetInteger(void)
     if (token == NULL)
         self_destruct();
 
-    // %i honors 0 and 0x prefixes, which are important for things like umask
-    if (sscanf(token, "%i", &i) != 1)
+    // The conversion must honor 0 and 0x prefixes, which are important for things like umask
+    int64_t ret = xatoll(token, 0);
+
+    i = (int) ret;
+    if (ret != static_cast<int64_t>(i)) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is larger than the type 'int'.");
         self_destruct();
+    }
 
     return i;
 }
 
+/*
+ * This function is similar as GetInteger() but the token might contain
+ * the percentage symbol (%) and we check whether the value is in the range
+ * of [0, 100]
+ * So, we accept two types of input: 1. XX% or 2. XX , 0<=XX<=100
+ */
+int
+GetPercentage(void)
+{
+    int p;
+    char *token = strtok(NULL, w_space);
+
+    if (!token) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: A percentage value is missing.");
+        self_destruct();
+    }
+
+    //if there is a % in the end of the digits, we remove it and go on.
+    char* end = &token[strlen(token)-1];
+    if (*end == '%') {
+        *end = '\0';
+    }
+
+    p = xatoi(token);
+
+    if (p < 0 || p > 100) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is out of range. A percentage should be within [0, 100].");
+        self_destruct();
+    }
+
+    return p;
+}
+
 unsigned short
 GetShort(void)
 {
@@ -191,8 +293,8 @@ GetHostWithPort(char *token, Ip::Address *ipa)
 
         if (0 == port)
             return false;
-    } else if ((port = strtol(token, &tmp, 10)), !*tmp) {
-        /* port */
+    } else if (strtol(token, &tmp, 10) && !*tmp) {
+        port = xatos(token);
     } else {
         host = token;
         port = 0;
@@ -38,7 +38,9 @@
 
 double xatof(const char *token);
 int xatoi(const char *token);
+unsigned int xatoui(const char *token);
 long xatol(const char *token);
+int64_t xatoll(const char *token, int base);
 unsigned short xatos(const char *token);
 
 /**
@@ -49,9 +51,19 @@ int64_t GetInteger64(void);
 /**
  * Parses an integer value.
  * Uses a method that obeys hexadecimal 0xN syntax needed for certain bitmasks.
+ * self_destruct() will be called to abort when invalid tokens are encountered.
  */
 int GetInteger(void);
 
+/**
+ * Parse a percentage value, e.g., 20%.
+ * The behavior of this function is similar as GetInteger().
+ * The difference is that the token might contain '%' as percentage symbol (%),
+ * and we further check whether the value is in the range of [0, 100]
+ * For example, 20% and 20 are both valid tokens, while 101%, 101, -1 are invalid.
+ */
+int GetPercentage(void);
+
 unsigned short GetShort(void);
 
 // on success, returns true and sets *p (if any) to the end of the integer
@@ -104,9 +104,9 @@ class PeerDigest
     const char *req_result;     /**< text status of the last request */
 
     struct {
-        unsigned int needed:1;          /**< there were requests for this digest */
-        unsigned int usable:1;          /**< can be used for lookups */
-        unsigned int requested:1;       /**< in process of receiving [fresh] digest */
+        bool needed;          /**< there were requests for this digest */
+        bool usable;          /**< can be used for lookups */
+        bool requested;       /**< in process of receiving [fresh] digest */
     } flags;
 
     struct {
@@ -73,6 +73,11 @@ class ps_state
 public:
     void *operator new(size_t);
     ps_state();
+
+    // Produce a URL for display identifying the transaction we are
+    // trying to locate a peer for.
+    const char * url() const;
+
     HttpRequest *request;
     StoreEntry *entry;
     allow_t always_direct;
@@ -41,18 +41,18 @@ class RefreshPattern
     RefreshPattern *next;
 
     struct {
-        unsigned int icase:1;
-        unsigned int refresh_ims:1;
-        unsigned int store_stale:1;
+        bool icase;
+        bool refresh_ims;
+        bool store_stale;
 #if USE_HTTP_VIOLATIONS
-        unsigned int override_expire:1;
-        unsigned int override_lastmod:1;
-        unsigned int reload_into_ims:1;
-        unsigned int ignore_reload:1;
-        unsigned int ignore_no_store:1;
-        unsigned int ignore_must_revalidate:1;
-        unsigned int ignore_private:1;
-        unsigned int ignore_auth:1;
+        bool override_expire;
+        bool override_lastmod;
+        bool reload_into_ims;
+        bool ignore_reload;
+        bool ignore_no_store;
+        bool ignore_must_revalidate;
+        bool ignore_private;
+        bool ignore_auth;
 #endif
     } flags;
     int max_stale;
@@ -105,8 +105,6 @@ class RequestFlags
     bool connectionProxyAuth :1;
     /** set if the request was sent on a pinned connection */
     bool pinned :1;
-    /** OK to reopen a failed pinned connection */
-    bool canRePin :1;
     /** Authentication was already sent upstream (e.g. due tcp-level auth) */
     bool authSent :1;
     /** Deny direct forwarding unless overriden by always_direct
@@ -75,7 +75,8 @@ ServerStateData::ServerStateData(FwdState *theFwdState): AsyncJob("ServerStateDa
 
     entry->lock();
 
-    request = HTTPMSGLOCK(fwd->request);
+    request = fwd->request;
+    HTTPMSGLOCK(request);
 }
 
 ServerStateData::~ServerStateData()
@@ -147,7 +148,8 @@ ServerStateData::setVirginReply(HttpReply *rep)
     debugs(11,5, HERE << this << " setting virgin reply to " << rep);
     assert(!theVirginReply);
     assert(rep);
-    theVirginReply = HTTPMSGLOCK(rep);
+    theVirginReply = rep;
+    HTTPMSGLOCK(theVirginReply);
     return theVirginReply;
 }
 
@@ -165,7 +167,8 @@ ServerStateData::setFinalReply(HttpReply *rep)
 
     assert(!theFinalReply);
     assert(rep);
-    theFinalReply = HTTPMSGLOCK(rep);
+    theFinalReply = rep;
+    HTTPMSGLOCK(theFinalReply);
 
     // give entry the reply because haveParsedReplyHeaders() expects it there
     entry->replaceHttpReply(theFinalReply, false); // but do not write yet
@@ -380,7 +383,7 @@ ServerStateData::sentRequestBody(const CommIoCbParams &io)
     if (io.flag) {
         debugs(11, DBG_IMPORTANT, "sentRequestBody error: FD " << io.fd << ": " << xstrerr(io.xerrno));
         ErrorState *err;
-        err = new ErrorState(ERR_WRITE_ERROR, HTTP_BAD_GATEWAY, fwd->request);
+        err = new ErrorState(ERR_WRITE_ERROR, Http::scBadGateway, fwd->request);
         err->xerrno = io.xerrno;
         fwd->fail(err);
         abortTransaction("I/O error while sending request body");
@@ -505,7 +508,7 @@ ServerStateData::maybePurgeOthers()
         return;
 
     // and probably only if the response was successful
-    if (theFinalReply->sline.status >= 400)
+    if (theFinalReply->sline.status() >= 400)
         return;
 
     // XXX: should we use originalRequest() here?
@@ -658,7 +661,7 @@ ServerStateData::noteAdaptationAnswer(const Adaptation::Answer &answer)
 
     switch (answer.kind) {
     case Adaptation::Answer::akForward:
-        handleAdaptedHeader(answer.message);
+        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
         break;
 
     case Adaptation::Answer::akBlock:
@@ -825,7 +828,7 @@ ServerStateData::handleAdaptationAborted(bool bypassable)
 
     if (entry->isEmpty()) {
         debugs(11,9, HERE << "creating ICAP error entry after ICAP failure");
-        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, Http::scInternalServerError, request);
         err->detailError(ERR_DETAIL_ICAP_RESPMOD_EARLY);
         fwd->fail(err);
         fwd->dontRetry(true);
@@ -859,7 +862,7 @@ ServerStateData::handleAdaptationBlocked(const Adaptation::Answer &answer)
     if (page_id == ERR_NONE)
         page_id = ERR_ACCESS_DENIED;
 
-    ErrorState *err = new ErrorState(page_id, HTTP_FORBIDDEN, request);
+    ErrorState *err = new ErrorState(page_id, Http::scForbidden, request);
     err->detailError(ERR_DETAIL_RESPMOD_BLOCK_EARLY);
     fwd->fail(err);
     fwd->dontRetry(true);
@@ -898,7 +901,7 @@ ServerStateData::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer grou
 void
 ServerStateData::sendBodyIsTooLargeError()
 {
-    ErrorState *err = new ErrorState(ERR_TOO_BIG, HTTP_FORBIDDEN, request);
+    ErrorState *err = new ErrorState(ERR_TOO_BIG, Http::scForbidden, request);
     fwd->fail(err);
     fwd->dontRetry(true);
     abortTransaction("Virgin body too large.");
@@ -203,6 +203,7 @@ class SquidConfig
 #endif
 
         wordlist *redirect;
+        wordlist *store_id;
 #if USE_UNLINKD
 
         char *unlinkd;
@@ -220,6 +221,7 @@ class SquidConfig
 #endif
 
     HelperChildConfig redirectChildren;
+    HelperChildConfig storeIdChildren;
     time_t authenticateGCInterval;
     time_t authenticateTTL;
     time_t authenticateIpTTL;
@@ -318,6 +320,7 @@ class SquidConfig
         int nonhierarchical_direct;
         int strip_query_terms;
         int redirector_bypass;
+        int store_id_bypass;
         int ignore_unknown_nameservers;
         int client_pconns;
         int server_pconns;
@@ -381,6 +384,7 @@ class SquidConfig
         acl_access *brokenPosts;
 #endif
         acl_access *redirector;
+        acl_access *store_id;
         acl_access *reply;
         AclAddress *outgoing_address;
 #if USE_HTCP
@@ -73,11 +73,11 @@ StatHist::StatHist(const StatHist &src) :
 }
 
 void
-StatHist::count(double val)
+StatHist::count(double v)
 {
     if (bins==NULL) //do not count before initialization or after destruction
         return;
-    const unsigned int bin = findBin(val);
+    const unsigned int bin = findBin(v);
     ++bins[bin];
 }
 
@@ -83,9 +83,9 @@ class store_client
     StoreIOState::Pointer swapin_sio;
 
     struct {
-        unsigned int disk_io_pending:1;
-        unsigned int store_copying:1;
-        unsigned int copy_event_pending:1;
+        bool disk_io_pending;
+        bool store_copying;
+        bool copy_event_pending;
     } flags;
 
 #if USE_DELAY_POOLS
@@ -46,9 +46,13 @@ StoreIOState::operator new (size_t amount)
 void
 StoreIOState::operator delete (void *address) {assert (0);}
 
-StoreIOState::StoreIOState()
+StoreIOState::StoreIOState() :
+        swap_dirn(-1), swap_filen(-1), e(NULL), mode(O_BINARY),
+        offset_(0), file_callback(NULL), callback(NULL), callback_data(NULL)
 {
-    mode = O_BINARY;
+    read.callback = NULL;
+    read.callback_data = NULL;
+    flags.closing = false;
 }
 
 off_t
@@ -109,7 +109,7 @@ class StoreIOState : public RefCountable
     } read;
 
     struct {
-        unsigned int closing:1;	/* debugging aid */
+        bool closing;	/* debugging aid */
     } flags;
 };
 
@@ -42,8 +42,8 @@
 #include "tools.h"
 
 SwapDir::SwapDir(char const *aType): theType(aType),
-        max_size(0),
-        path(NULL), index(-1), disker(-1), min_objsize(0), max_objsize (-1),
+        max_size(0), min_objsize(0), max_objsize (-1),
+        path(NULL), index(-1), disker(-1),
         repl(NULL), removals(0), scanned(0),
         cleanLog(NULL)
 {
@@ -114,6 +114,39 @@ SwapDir::minSize() const
     return ((maxSize() * Config.Swap.lowWaterMark) / 100);
 }
 
+int64_t
+SwapDir::maxObjectSize() const
+{
+    // per-store max-size=N value is authoritative
+    if (max_objsize > -1)
+        return max_objsize;
+
+    // store with no individual max limit is limited by configured maximum_object_size
+    // or the total store size, whichever is smaller
+    return min(static_cast<int64_t>(maxSize()), Config.Store.maxObjectSize);
+}
+
+void
+SwapDir::maxObjectSize(int64_t newMax)
+{
+    // negative values mean no limit (-1)
+    if (newMax < 0) {
+        max_objsize = -1; // set explicitly in case it had a non-default value previously
+        return;
+    }
+
+    // prohibit values greater than total storage area size
+    // but set max_objsize to the maximum allowed to override maximum_object_size global config
+    if (static_cast<uint64_t>(newMax) > maxSize()) {
+        debugs(47, DBG_PARSE_NOTE(2), "WARNING: Ignoring 'max-size' option for " << path <<
+               " which is larger than total cache_dir size of " << maxSize() << " bytes.");
+        max_objsize = maxSize();
+        return;
+    }
+
+    max_objsize = newMax;
+}
+
 void
 SwapDir::reference(StoreEntry &) {}
 
@@ -238,7 +271,7 @@ SwapDir::getOptionTree() const
 void
 SwapDir::parseOptions(int isaReconfig)
 {
-    unsigned int old_read_only = flags.read_only;
+    const bool old_read_only = flags.read_only;
     char *name, *value;
 
     ConfigOption *newOption = getOptionTree();
@@ -290,12 +323,16 @@ SwapDir::optionReadOnlyParse(char const *option, const char *value, int isaRecon
     if (strcmp(option, "no-store") != 0 && strcmp(option, "read-only") != 0)
         return false;
 
-    int read_only = 0;
+    if (strcmp(option, "read-only") == 0) {
+        debugs(3, DBG_PARSE_NOTE(3), "UPGRADE WARNING: Replace cache_dir option 'read-only' with 'no-store'.");
+    }
+
+    bool read_only = 0;
 
     if (value)
-        read_only = xatoi(value);
+        read_only = (xatoi(value) != 0);
     else
-        read_only = 1;
+        read_only = true;
 
     flags.read_only = read_only;
 
@@ -148,7 +148,13 @@ class SwapDir : public Store
 
     virtual uint64_t minSize() const;
 
-    virtual int64_t maxObjectSize() const { return max_objsize; }
+    /// The maximum size of object which may be stored here.
+    /// Larger objects will not be added and may be purged.
+    virtual int64_t maxObjectSize() const;
+
+    /// configure the maximum object size for this storage area.
+    /// May be any size up to the total storage area.
+    void maxObjectSize(int64_t newMax);
 
     virtual void getStats(StoreInfoStats &stats) const;
     virtual void stat (StoreEntry &anEntry) const;
@@ -180,21 +186,21 @@ class SwapDir : public Store
 
 protected:
     uint64_t max_size;        ///< maximum allocatable size of the storage area
+    int64_t min_objsize;      ///< minimum size of any object stored here (-1 for no limit)
+    int64_t max_objsize;      ///< maximum size of any object stored here (-1 for no limit)
 
 public:
     char *path;
     int index;			/* This entry's index into the swapDirs array */
     int disker; ///< disker kid id dedicated to this SwapDir or -1
-    int64_t min_objsize;
-    int64_t max_objsize;
     RemovalPolicy *repl;
     int removals;
     int scanned;
 
     struct Flags {
-        Flags() : selected(0), read_only(0) {}
-        unsigned int selected:1;
-        unsigned int read_only:1;
+        Flags() : selected(false), read_only(false) {}
+        bool selected;
+        bool read_only;
     } flags;
     virtual void init() = 0;	/* Initialise the fs */
     virtual void create();	/* Create a new fs */
@@ -33,14 +33,69 @@
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
 #include "anyp/PortCfg.h"
+#include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
 #include "SquidConfig.h"
 
+const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
+
 const char *AclMatchedName = NULL;
 
+bool ACLFlags::supported(const ACLFlag f) const
+{
+    if (f == ACL_F_REGEX_CASE)
+        return true;
+    return (supported_.find(f) != std::string::npos);
+}
+
+void
+ACLFlags::parseFlags(char * &nextToken)
+{
+    while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
+
+        //if token is the "--" break flag
+        if (strcmp(nextToken, "--") == 0)
+            break;
+
+        for (const char *flg = nextToken+1; *flg!='\0'; flg++ ) {
+            if (supported(*flg)) {
+                makeSet(*flg);
+            } else {
+                debugs(28, 0, HERE << "Flag '" << *flg << "' not supported");
+                self_destruct();
+            }
+        }
+    }
+
+    /*Regex code needs to parse -i file*/
+    if ( isSet(ACL_F_REGEX_CASE))
+        ConfigParser::strtokFilePutBack("-i");
+
+    if (nextToken != NULL && strcmp(nextToken, "--") != 0 )
+        ConfigParser::strtokFileUndo();
+}
+
+const char *
+ACLFlags::flagsStr() const
+{
+    static char buf[64];
+    if (flags_ == 0)
+        return "";
+
+    char *s = buf;
+    *s++ = '-';
+    for (ACLFlag f = 'A'; f <= 'z'; f++) {
+        // ACL_F_REGEX_CASE (-i) flag handled by ACLRegexData class, ignore
+        if (isSet(f) && f != ACL_F_REGEX_CASE)
+            *s++ = f;
+    }
+    *s = '\0';
+    return buf;
+}
+
 void *
 ACL::operator new (size_t byteCount)
 {
@@ -131,7 +186,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
         AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
-            if (p->intercepted)
+            if (p->flags.natIntercept)
                 debugs(28, DBG_CRITICAL, "WARNING: 'myip' ACL is not reliable for interception proxies. Please use 'myportname' instead.");
             p = p->next;
         }
@@ -142,7 +197,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
             // Bug 3239: myport - not reliable (yet) when there is interception traffic coming
-            if (p->intercepted)
+            if (p->flags.natIntercept)
                 debugs(28, DBG_CRITICAL, "WARNING: 'myport' ACL is not reliable for interception proxies. Please use 'myportname' instead.");
             p = p->next;
         }
@@ -180,6 +235,9 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
      */
     AclMatchedName = A->name;	/* ugly */
 
+    char *aTok;
+    A->flags.parseFlags(aTok);
+
     /*split the function here */
     A->parse();
 
@@ -425,8 +483,11 @@ ACL::Prototype::Factory (char const *typeToClone)
     debugs(28, 4, "ACL::Prototype::Factory: cloning an object for type '" << typeToClone << "'");
 
     for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-        if (!strcmp (typeToClone, (*i)->typeString))
-            return (*i)->prototype->clone();
+        if (!strcmp (typeToClone, (*i)->typeString)) {
+            ACL *A = (*i)->prototype->clone();
+            A->flags = (*i)->prototype->flags;
+            return A;
+        }
 
     debugs(28, 4, "ACL::Prototype::Factory: cloning failed, no type '" << typeToClone << "' available");
 
@@ -42,11 +42,54 @@
 #if HAVE_OSTREAM
 #include <ostream>
 #endif
+#if HAVE_STRING
+#include <string>
+#endif
 
 class ConfigParser;
 class ACLChecklist;
 class ACLList;
 
+typedef char ACLFlag;
+// ACLData Flags
+#define ACL_F_REGEX_CASE 'i'
+#define ACL_F_NO_LOOKUP 'n'
+#define ACL_F_END '\0'
+
+/**
+ * \ingroup ACLAPI
+ * Used to hold a list of one-letter flags which can be passed as parameters
+ * to acls  (eg '-i', '-n' etc)
+ */
+class ACLFlags
+{
+public:
+    explicit ACLFlags(const ACLFlag flags[]) : supported_(flags), flags_(0) {}
+    ACLFlags() : flags_(0) {}
+    bool supported(const ACLFlag f) const; ///< True if the given flag supported
+    void makeSet(const ACLFlag f) { flags_ |= flagToInt(f); } ///< Set the given flag
+    /// Return true if the given flag is set
+    bool isSet(const ACLFlag f) const { return flags_ & flagToInt(f);}
+    /// Parse a flags given in the form -[A..Z|a..z]
+    void parseFlags(char * &nextToken);
+    const char *flagsStr() const; ///< Convert the flags to a string representation
+
+private:
+    /// Convert a flag to a 64bit unsigned integer.
+    /// The characters from 'A' to 'z' represented by the values from 65 to 122.
+    /// They are 57 different characters which can be fit to the bits of an 64bit
+    /// integer.
+    uint64_t flagToInt(const ACLFlag f) const {
+        assert('A' <= f && f <= 'z');
+        return ((uint64_t)1 << (f - 'A'));
+    }
+
+    std::string supported_; ///< The supported character flags
+    uint64_t flags_; ///< The flags which is set
+public:
+    static const ACLFlag NoFlags[1]; ///< An empty flags list
+};
+
 /// \ingroup ACLAPI
 class ACL
 {
@@ -61,6 +104,7 @@ class ACL
     static ACL* FindByName(const char *name);
 
     ACL();
+    explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs) { memset(name, '\0', sizeof(name)); }
     virtual ~ACL();
     virtual ACL *clone()const = 0;
     virtual void parse() = 0;
@@ -82,6 +126,7 @@ class ACL
     char name[ACL_NAME_SZ];
     char *cfgline;
     ACL *next;
+    ACLFlags flags; ///< The list of given ACL flags
 
 public:
 
@@ -237,16 +237,15 @@ asnCacheStart(int as)
 {
     LOCAL_ARRAY(char, asres, 4096);
     StoreEntry *e;
-    HttpRequest *req;
     ASState *asState;
     asState = cbdataAlloc(ASState);
     asState->dataRead = 0;
     debugs(53, 3, "asnCacheStart: AS " << as);
     snprintf(asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
     asState->as_number = as;
-    req = HttpRequest::CreateFromUrl(asres);
-    assert(NULL != req);
-    asState->request = HTTPMSGLOCK(req);
+    asState->request = HttpRequest::CreateFromUrl(asres);
+    assert(NULL != asState->request);
+    HTTPMSGLOCK(asState->request);
 
     if ((e = storeGetPublic(asres, Http::METHOD_GET)) == NULL) {
         e = storeCreateEntry(asres, asres, RequestFlags(), Http::METHOD_GET);
@@ -297,7 +296,7 @@ asHandleReply(void *data, StoreIOBuffer result)
         debugs(53, DBG_IMPORTANT, "asHandleReply: Called with Error set and size=" << (unsigned int) result.length);
         asStateFree(asState);
         return;
-    } else if (HTTP_OK != e->getReply()->sline.status) {
+    } else if (e->getReply()->sline.status() != Http::scOkay) {
         debugs(53, DBG_IMPORTANT, "WARNING: AS " << asState->as_number << " whois request failed");
         asStateFree(asState);
         return;
@@ -395,8 +394,6 @@ asStateFree(void *data)
 static int
 asnAddNet(char *as_string, int as_number)
 {
-    rtentry_t *e;
-
     struct squid_radix_node *rn;
     CbDataList<int> **Tail = NULL;
     CbDataList<int> *q = NULL;
@@ -430,9 +427,7 @@ asnAddNet(char *as_string, int as_number)
 
     debugs(53, 3, "asnAddNet: called for " << addr << "/" << mask );
 
-    e = (rtentry_t *)xmalloc(sizeof(rtentry_t));
-
-    memset(e, '\0', sizeof(rtentry_t));
+    rtentry_t *e = (rtentry_t *)xcalloc(1, sizeof(rtentry_t));
 
     e->e_addr.addr = addr;
 
@@ -459,7 +454,7 @@ asnAddNet(char *as_string, int as_number)
         q = new CbDataList<int> (as_number);
         asinfo = (as_info *)xmalloc(sizeof(as_info));
         asinfo->as_number = q;
-        rn = squid_rn_addroute(&e->e_addr, &e->e_mask, AS_tree_head, e->e_nodes);
+        squid_rn_addroute(&e->e_addr, &e->e_mask, AS_tree_head, e->e_nodes);
         rn = squid_rn_match(&e->e_addr, AS_tree_head);
         assert(rn != NULL);
         e->e_info = asinfo;
@@ -613,7 +608,7 @@ ACL::Prototype ACLASN::DestinationRegistryProtoype(&ACLASN::DestinationRegistryE
 ACLStrategised<Ip::Address> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
 
 int
-ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist)
+ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match(checklist->src_addr);
 }
@@ -627,7 +622,7 @@ ACLSourceASNStrategy::Instance()
 ACLSourceASNStrategy ACLSourceASNStrategy::Instance_;
 
 int
-ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
@@ -48,12 +48,15 @@
 #include "globals.h"
 
 int
-ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     const int fd = checklist->fd();
     const bool goodDescriptor = 0 <= fd && fd <= Biggest_FD;
     SSL *ssl = goodDescriptor ? fd_table[fd].ssl : 0;
-    return data->match (ssl);
+    X509 *cert = SSL_get_peer_certificate(ssl);
+    const bool res = data->match (cert);
+    X509_free(cert);
+    return res;
 }
 
 ACLCertificateStrategy *
@@ -40,11 +40,11 @@
 #include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
-class ACLCertificateStrategy : public ACLStrategy<SSL *>
+class ACLCertificateStrategy : public ACLStrategy<X509 *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLCertificateStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -64,9 +64,9 @@ class ACLCertificate
 
 private:
     static ACL::Prototype UserRegistryProtoype;
-    static ACLStrategised<SSL*> UserRegistryEntry_;
+    static ACLStrategised<X509*> UserRegistryEntry_;
     static ACL::Prototype CARegistryProtoype;
-    static ACLStrategised<SSL *> CARegistryEntry_;
+    static ACLStrategised<X509 *> CARegistryEntry_;
 };
 
 #endif /* SQUID_ACLCERTIFICATE_H */
@@ -35,14 +35,29 @@
 #include "squid.h"
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
+#include "Debug.h"
 #include "cache_cf.h"
 #include "wordlist.h"
 
-ACLCertificateData::ACLCertificateData(SSLGETATTRIBUTE *sslStrategy) : attribute (NULL), values (), sslAttributeCall (sslStrategy)
-{}
+ACLCertificateData::ACLCertificateData(Ssl::GETX509ATTRIBUTE *sslStrategy, const char *attrs, bool optionalAttr) : validAttributesStr(attrs), attributeIsOptional(optionalAttr), attribute (NULL), values (), sslAttributeCall (sslStrategy)
+{
+    if (attrs) {
+        size_t current = 0;
+        size_t next = std::string::npos;
+        std::string valid(attrs);
+        do {
+            next = valid.find_first_of( "|", current);
+            validAttributes.push_back(valid.substr( current, (next == std::string::npos ? std::string::npos : next - current)));
+            current = next + 1;
+        } while (next != std::string::npos);
+    }
+}
 
 ACLCertificateData::ACLCertificateData(ACLCertificateData const &old) : attribute (NULL), values (old.values), sslAttributeCall (old.sslAttributeCall)
 {
+    validAttributesStr = old.validAttributesStr;
+    validAttributes.assign (old.validAttributes.begin(), old.validAttributes.end());
+    attributeIsOptional = old.attributeIsOptional;
     if (old.attribute)
         attribute = xstrdup (old.attribute);
 }
@@ -67,13 +82,13 @@ splaystrcmp (T&l, T&r)
 }
 
 bool
-ACLCertificateData::match(SSL *ssl)
+ACLCertificateData::match(X509 *cert)
 {
-    if (!ssl)
+    if (!cert)
         return 0;
 
-    char const *value = sslAttributeCall(ssl, attribute);
-
+    char const *value = sslAttributeCall(cert, attribute);
+    debugs(28, 6, (attribute ? attribute : "value") << "=" << value);
     if (value == NULL)
         return 0;
 
@@ -91,7 +106,8 @@ wordlist *
 ACLCertificateData::dump()
 {
     wordlist *wl = NULL;
-    wordlistAdd(&wl, attribute);
+    if (validAttributesStr)
+        wordlistAdd(&wl, attribute);
     /* damn this is VERY inefficient for long ACL lists... filling
      * a wordlist this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
@@ -104,17 +120,45 @@ ACLCertificateData::dump()
 void
 ACLCertificateData::parse()
 {
-    char *newAttribute = strtokFile();
+    if (validAttributesStr) {
+        char *newAttribute = strtokFile();
 
-    if (!newAttribute)
-        self_destruct();
+        if (!newAttribute) {
+            if (attributeIsOptional)
+                return;
 
-    /* an acl must use consistent attributes in all config lines */
-    if (attribute) {
-        if (strcasecmp(newAttribute, attribute) != 0)
+            debugs(28, DBG_CRITICAL, "FATAL: required attribute argument missing");
             self_destruct();
-    } else
-        attribute = xstrdup(newAttribute);
+        }
+
+        // Handle the cases where we have optional -x type attributes
+        if (attributeIsOptional && newAttribute[0] != '-')
+            // The read token is not an attribute/option, so add it to values list
+            values.insert(newAttribute);
+        else {
+            bool valid = false;
+            for (std::list<std::string>::const_iterator it = validAttributes.begin(); it != validAttributes.end(); ++it) {
+                if (*it == "*" || *it == newAttribute) {
+                    valid = true;
+                    break;
+                }
+            }
+
+            if (!valid) {
+                debugs(28, DBG_CRITICAL, "FATAL: Unknown option. Supported option(s) are: " << validAttributesStr);
+                self_destruct();
+            }
+
+            /* an acl must use consistent attributes in all config lines */
+            if (attribute) {
+                if (strcasecmp(newAttribute, attribute) != 0) {
+                    debugs(28, DBG_CRITICAL, "FATAL: An acl must use consistent attributes in all config lines (" << newAttribute << "!=" << attribute << ").");
+                    self_destruct();
+                }
+            } else
+                attribute = xstrdup(newAttribute);
+        }
+    }
 
     values.parse();
 }
@@ -125,7 +169,7 @@ ACLCertificateData::empty() const
     return values.empty();
 }
 
-ACLData<SSL *> *
+ACLData<X509 *> *
 ACLCertificateData::clone() const
 {
     /* Splay trees don't clone yet. */
@@ -38,29 +38,41 @@
 #include "acl/Data.h"
 #include "ssl/support.h"
 #include "acl/StringData.h"
+#include <string>
+#include <list>
 
 /// \ingroup ACLAPI
-class ACLCertificateData : public ACLData<SSL *>
+class ACLCertificateData : public ACLData<X509 *>
 {
 
 public:
     MEMPROXY_CLASS(ACLCertificateData);
 
-    ACLCertificateData(SSLGETATTRIBUTE *);
+    ACLCertificateData(Ssl::GETX509ATTRIBUTE *, const char *attributes, bool optionalAttr = false);
     ACLCertificateData(ACLCertificateData const &);
     ACLCertificateData &operator= (ACLCertificateData const &);
     virtual ~ACLCertificateData();
-    bool match(SSL *);
+    bool match(X509 *);
     wordlist *dump();
     void parse();
     bool empty() const;
-    virtual ACLData<SSL *> *clone() const;
+    virtual ACLData<X509 *> *clone() const;
 
+    /// A '|'-delimited list of valid ACL attributes.
+    /// A "*" item means that any attribute is acceptable.
+    /// Assumed to be a const-string and is never duped/freed.
+    /// Nil unless ACL form is: acl Name type attribute value1 ...
+    const char *validAttributesStr;
+    /// Parsed list of valid attribute names
+    std::list<std::string> validAttributes;
+    /// True if the attribute is optional (-xxx options)
+    bool attributeIsOptional;
     char *attribute;
     ACLStringData values;
 
 private:
-    SSLGETATTRIBUTE *sslAttributeCall;
+    /// The callback used to retrieve the data from X509 cert
+    Ssl::GETX509ATTRIBUTE *sslAttributeCall;
 };
 
 MEMPROXY_CLASS_INLINE(ACLCertificateData);
@@ -41,7 +41,7 @@ class ACLDestinationASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLDestinationASNStrategy *Instance();
@@ -71,14 +71,19 @@ DestinationDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &de
 }
 
 int
-ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
 {
     assert(checklist != NULL && checklist->request != NULL);
 
     if (data->match(checklist->request->GetHost())) {
         return 1;
     }
 
+    if (flags.isSet(ACL_F_NO_LOOKUP)) {
+        debugs(28, 3, "aclMatchAcl:  No-lookup DNS ACL '" << AclMatchedName << "' for '" << checklist->request->GetHost() << "'");
+        return 0;
+    }
+
     /* numeric IPA? no, trust the above result. */
     if (checklist->request->GetHostIsNumeric() == 0) {
         return 0;
@@ -43,7 +43,7 @@ class ACLDestinationDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLDestinationDomainStrategy *Instance();
     virtual bool requiresRequest() const {return true;}
 
@@ -39,6 +39,8 @@
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
+ACLFlag ACLDestinationIP::SupportedFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
+
 char const *
 ACLDestinationIP::typeString() const
 {
@@ -59,6 +61,17 @@ ACLDestinationIP::match(ACLChecklist *cl)
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
 
+    if (flags.isSet(ACL_F_NO_LOOKUP)) {
+        if (!checklist->request->GetHostIsNumeric()) {
+            debugs(28, 3, "aclMatchAcl:  No-lookup DNS ACL '" << AclMatchedName << "' for '" << checklist->request->GetHost() << "'");
+            return 0;
+        }
+
+        if (ACLIP::match(checklist->request->host_addr))
+            return 1;
+        return 0;
+    }
+
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
@@ -101,7 +114,7 @@ DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &d
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     assert (checklist->asyncState() == DestinationIPLookup::Instance());
-    checklist->request->flags.destinationIpLookedUp=true;
+    checklist->request->flags.destinationIpLookedUp = true;
     checklist->request->recordLookup(details);
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
@@ -55,12 +55,14 @@ class ACLDestinationIP : public ACLIP
 public:
     MEMPROXY_CLASS(ACLDestinationIP);
 
+    ACLDestinationIP(): ACLIP(ACLDestinationIP::SupportedFlags) {}
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
     virtual bool requiresRequest() const {return true;}
 
     virtual ACL *clone()const;
 
+    static ACLFlag SupportedFlags[];
 private:
     static Prototype RegistryProtoype;
     static ACLDestinationIP RegistryEntry_;
@@ -38,7 +38,7 @@
 #include "cache_cf.h"
 #include "Debug.h"
 #include "wordlist.h"
-#include "URL.h"
+#include "src/URL.h"
 
 template<class T>
 inline void
@@ -175,7 +175,8 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
         accessList = cbdataReference(A);
 
     if (http_request != NULL) {
-        request = HTTPMSGLOCK(http_request);
+        request = http_request;
+        HTTPMSGLOCK(request);
 #if FOLLOW_X_FORWARDED_FOR
         if (Config.onoff.acl_uses_indirect_client)
             src_addr = request->indirect_client_addr;
@@ -73,6 +73,8 @@ class ACLFilledChecklist: public ACLChecklist
 #if USE_SSL
     /// SSL [certificate validation] errors, in undefined order
     Ssl::Errors *sslErrors;
+    /// The peer certificate
+    Ssl::X509_Pointer serverCert;
 #endif
 
     ExternalACLEntry *extacl_entry;
@@ -3,12 +3,12 @@
 
 #include "err_type.h"
 
-struct dlink_list;
 class acl_access;
 class ACL;
 class AclDenyInfoList;
 class ACLList;
 class ConfigParser;
+class dlink_list;
 class StoreEntry;
 class wordlist;
 
@@ -9,7 +9,7 @@
 template class ACLStrategised<hier_code>;
 
 int
-ACLHierCodeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLHierCodeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->hier.code);
 }
@@ -10,7 +10,7 @@ class ACLHierCodeStrategy : public ACLStrategy<hier_code>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLHierCodeStrategy *Instance();
@@ -38,7 +38,7 @@
 #include "HttpReply.h"
 
 int
-ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (&checklist->reply->header);
 }
@@ -42,7 +42,7 @@ class ACLHTTPRepHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresReply() const { return true; }
 
     static ACLHTTPRepHeaderStrategy *Instance();
@@ -38,7 +38,7 @@
 #include "HttpRequest.h"
 
 int
-ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (&checklist->request->header);
 }
@@ -42,7 +42,7 @@ class ACLHTTPReqHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const { return true; }
 
     static ACLHTTPReqHeaderStrategy *Instance();
@@ -46,7 +46,7 @@
 
 static void aclParseHTTPStatusList(SplayNode<acl_httpstatus_data *> **curlist);
 static int aclHTTPStatusCompare(acl_httpstatus_data * const &a, acl_httpstatus_data * const &b);
-static int aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, http_status status);
+static int aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, Http::StatusCode status);
 
 acl_httpstatus_data::acl_httpstatus_data(int x) : status1(x), status2(x) { ; }
 
@@ -156,11 +156,11 @@ aclParseHTTPStatusList(SplayNode<acl_httpstatus_data *> **curlist)
 int
 ACLHTTPStatus::match(ACLChecklist *checklist)
 {
-    return aclMatchHTTPStatus(&data, Filled(checklist)->reply->sline.status);
+    return aclMatchHTTPStatus(&data, Filled(checklist)->reply->sline.status());
 }
 
 int
-aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, http_status status)
+aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, const Http::StatusCode status)
 {
 
     acl_httpstatus_data X(status);
@@ -260,7 +260,7 @@ acl_ip_data::FactoryParse(const char *t)
     debugs(28, 5, "aclIpParseIpData: " << t);
 
     /* Special ACL RHS "all" matches entire Internet */
-    if (strcasecmp(t, "all") == 0) {
+    if (strcmp(t, "all") == 0) {
         debugs(28, 9, "aclIpParseIpData: magic 'all' found.");
         q->addr1.SetAnyAddr();
         q->addr2.SetEmpty();
@@ -270,8 +270,8 @@ acl_ip_data::FactoryParse(const char *t)
 
     /* Detect some old broken strings equivalent to 'all'.
      * treat them nicely. But be loud until its fixed.  */
-    if (strcasecmp(t, "0/0") == 0 || strcasecmp(t, "0.0.0.0/0") == 0 || strcasecmp(t, "0.0.0.0/0.0.0.0") == 0 ||
-            strcasecmp(t, "0.0.0.0-255.255.255.255") == 0 || strcasecmp(t, "0.0.0.0-0.0.0.0/0") == 0) {
+    if (strcmp(t, "0/0") == 0 || strcmp(t, "0.0.0.0/0") == 0 || strcmp(t, "0.0.0.0/0.0.0.0") == 0 ||
+            strcmp(t, "0.0.0.0-255.255.255.255") == 0 || strcmp(t, "0.0.0.0-0.0.0.0/0") == 0) {
 
         debugs(28,DBG_CRITICAL, "ERROR: '" << t << "' needs to be replaced by the term 'all'.");
         debugs(28,DBG_CRITICAL, "SECURITY NOTICE: Overriding config setting. Using 'all' instead.");
@@ -284,14 +284,14 @@ acl_ip_data::FactoryParse(const char *t)
     /* Special ACL RHS "ipv4" matches IPv4 Internet
      * A nod to IANA; we include the entire class space in case
      * they manage to find a way to recover and use it */
-    if (strcasecmp(t, "ipv4") == 0) {
+    if (strcmp(t, "ipv4") == 0) {
         q->mask.SetNoAddr();
         q->mask.ApplyMask(0, AF_INET);
         return q;
     }
 
     /* Special ACL RHS "ipv6" matches IPv6-Unicast Internet */
-    if (strcasecmp(t, "ipv6") == 0) {
+    if (strcmp(t, "ipv6") == 0) {
         debugs(28, 9, "aclIpParseIpData: magic 'ipv6' found.");
         r = q; // save head of the list for result.
 
@@ -509,7 +509,12 @@ ACLIP::parse()
 {
     char *t = NULL;
 
-    while ((t = strtokFile())) {
+    flags.parseFlags(t);
+
+    if (!t)
+        return;
+
+    do {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
@@ -519,7 +524,7 @@ ACLIP::parse()
             data = data->insert(q, acl_ip_data::NetworkCompare);
             q = next_node;
         }
-    }
+    } while ((t = strtokFile()));
 }
 
 ACLIP::~ACLIP()
@@ -33,6 +33,7 @@
 #define SQUID_ACLIP_H
 
 #include "acl/Acl.h"
+#include "acl/Data.h"
 #include "splay.h"
 #include "ip/Address.h"
 
@@ -74,6 +75,7 @@ class ACLIP : public ACL
     void operator delete(void *);
 
     ACLIP() : data(NULL) {}
+    explicit ACLIP(const ACLFlag flgs[]) : ACL(flgs), data(NULL) {}
 
     ~ACLIP();
 
@@ -37,7 +37,7 @@
 #include "acl/Checklist.h"
 
 int
-ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->my_addr.GetPort());
 }
@@ -41,7 +41,7 @@ class ACLLocalPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLLocalPortStrategy *Instance();
     /**
      * Not implemented to prevent copies of the instance.
@@ -122,6 +122,8 @@ SSL_ACLS = \
         CertificateData.h  \
         Certificate.cc \
         Certificate.h  \
+	ServerCertificate.cc \
+	ServerCertificate.h \
         SslError.cc \
         SslError.h \
         SslErrorData.cc \
@@ -42,7 +42,7 @@
 template class ACLStrategised<HttpRequestMethod>;
 
 int
-ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->method);
 }
@@ -42,7 +42,7 @@ class ACLMethodStrategy : public ACLStrategy<HttpRequestMethod>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLMethodStrategy *Instance();
@@ -32,19 +32,19 @@
  */
 
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
-#include "acl/Checklist.h"
 #include "anyp/PortCfg.h"
 #include "HttpRequest.h"
 
 /* for ConnStateData */
 #include "client_side.h"
 
 int
-ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    if (checklist->conn() != NULL)
+    if (checklist->conn() != NULL && checklist->conn()->port != NULL)
         return data->match(checklist->conn()->port->name);
     if (checklist->request != NULL)
         return data->match(checklist->request->myportname.termedBuf());
@@ -40,7 +40,7 @@ class ACLMyPortNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLMyPortNameStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -6,7 +6,7 @@
 #include "CachePeer.h"
 
 int
-ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     if (checklist->dst_peer != NULL && checklist->dst_peer->name != NULL)
         return data->match(checklist->dst_peer->name);
@@ -8,7 +8,7 @@ class ACLPeerNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLPeerNameStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -42,7 +42,7 @@
 template class ACLStrategised<AnyP::ProtocolType>;
 
 int
-ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->protocol);
 }
@@ -42,7 +42,7 @@ class ACLProtocolStrategy : public ACLStrategy<AnyP::ProtocolType>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLProtocolStrategy *Instance();
@@ -88,8 +88,10 @@ ACLRandom::parse()
     char bufa[256], bufb[256];
 
     t = strtokFile();
-    if (!t)
+    if (!t) {
+        debugs(28, DBG_PARSE_NOTE(DBG_IMPORTANT), "ACL random missing pattern");
         return;
+    }
 
     debugs(28, 5, "aclParseRandomData: " << t);
 
@@ -99,15 +101,15 @@ ACLRandom::parse()
     if (sscanf(t, "%[0-9]:%[0-9]", bufa, bufb) == 2) {
         int a = xatoi(bufa);
         int b = xatoi(bufb);
-        if (a == 0 || b == 0) {
+        if (a <= 0 || b <= 0) {
             debugs(28, DBG_CRITICAL, "ERROR: ACL random with bad pattern: '" << t << "'");
             return;
         } else
             data = a / (double)(a+b);
     } else if (sscanf(t, "%[0-9]/%[0-9]", bufa, bufb) == 2) {
         int a = xatoi(bufa);
         int b = xatoi(bufb);
-        if (a == 0 || b == 0) {
+        if (a <= 0 || b <= 0) {
             debugs(28, DBG_CRITICAL, "ERROR: ACL random with bad pattern: '" << t << "'");
             return;
         } else
@@ -45,7 +45,7 @@ class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresReply() const {return true;}
 
     static ACLReplyHeaderStrategy *Instance();
@@ -63,7 +63,7 @@ class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 
 template <http_hdr_type header>
 int
-ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->reply->header.getStr(header);
 
@@ -51,7 +51,7 @@ class ACLReplyMIMEType
 
 template <>
 inline int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
 
@@ -45,7 +45,7 @@ class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLRequestHeaderStrategy *Instance();
@@ -63,7 +63,7 @@ class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 
 template <http_hdr_type header>
 int
-ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->request->header.getStr(header);
 
@@ -51,7 +51,7 @@ class ACLRequestMIMEType
 
 template <>
 inline int
-ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
 
@@ -0,0 +1,38 @@
+/*
+ */
+
+#include "squid.h"
+
+#if USE_SSL
+
+#include "acl/ServerCertificate.h"
+#include "acl/Checklist.h"
+#include "acl/CertificateData.h"
+#include "client_side.h"
+#include "fde.h"
+#include "ssl/ServerBump.h"
+
+int
+ACLServerCertificateStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+{
+    X509 *cert = NULL;
+    if (checklist->serverCert.get())
+        cert = checklist->serverCert.get();
+    else if (checklist->conn() != NULL && checklist->conn()->serverBump())
+        cert = checklist->conn()->serverBump()->serverCert.get();
+
+    if (!cert)
+        return 0;
+
+    return data->match(cert);
+}
+
+ACLServerCertificateStrategy *
+ACLServerCertificateStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLServerCertificateStrategy ACLServerCertificateStrategy::Instance_;
+
+#endif /* USE_SSL */
@@ -0,0 +1,39 @@
+/*
+ */
+
+#ifndef SQUID_ACLSERVERCERTIFICATE_H
+#define SQUID_ACLSERVERCERTIFICATE_H
+
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Checklist.h"
+#include "ssl/support.h"
+#include "acl/Strategised.h"
+
+/// \ingroup ACLAPI
+class ACLServerCertificateStrategy : public ACLStrategy<X509 *>
+{
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    static ACLServerCertificateStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLServerCertificateStrategy(ACLServerCertificateStrategy const &);
+
+private:
+    static ACLServerCertificateStrategy Instance_;
+    ACLServerCertificateStrategy() {}
+
+    ACLServerCertificateStrategy&operator=(ACLServerCertificateStrategy const &);
+};
+
+/// \ingroup ACLAPI
+class ACLServerCertificate
+{
+private:
+    static ACL::Prototype X509FingerprintRegistryProtoype;
+    static ACLStrategised<X509*> X509FingerprintRegistryEntry_;
+};
+
+#endif /* SQUID_ACLSERVERCERTIFICATE_H */
@@ -28,23 +28,19 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-#ifndef SQUID_ACLSOURCEASN_H
-#define SQUID_ACLSOURCEASN_H
-
-#if 0
-#include "acl/Asn.h"
-#endif
-
-class ACLChecklist;
+#ifndef SQUID_ACL_SOURCEASN_H
+#define SQUID_ACL_SOURCEASN_H
 
 #include "acl/Strategy.h"
 #include "ip/Address.h"
 
+class ACLChecklist;
+
 class ACLSourceASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSourceASNStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -58,4 +54,4 @@ class ACLSourceASNStrategy : public ACLStrategy<Ip::Address>
     ACLSourceASNStrategy&operator=(ACLSourceASNStrategy const &);
 };
 
-#endif /* SQUID_ACLSOURCEASN_H */
+#endif /* SQUID_ACL_SOURCEASN_H */
@@ -69,7 +69,7 @@ SourceDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details
 }
 
 int
-ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     const char *fqdn = NULL;
     fqdn = fqdncache_gethostbyaddr(checklist->src_addr, FQDN_LOOKUP_IF_MISS);
@@ -42,7 +42,7 @@ class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSourceDomainStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -4,7 +4,7 @@
 #include "acl/Checklist.h"
 
 int
-ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->sslErrors);
 }
@@ -8,7 +8,7 @@ class ACLSslErrorStrategy : public ACLStrategy<const Ssl::Errors *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSslErrorStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -49,7 +49,7 @@ class ACLStrategised : public ACL
     void operator delete(void *);
 
     ~ACLStrategised();
-    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *);
+    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *, const ACLFlag flags[] = ACLFlags::NoFlags);
     ACLStrategised (ACLStrategised const &);
     ACLStrategised &operator= (ACLStrategised const &);
 
@@ -107,7 +107,7 @@ ACLStrategised<MatchType>::~ACLStrategised()
 }
 
 template <class MatchType>
-ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType) : data (newData), type_(theType), matcher(theStrategy) {}
+ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType, const ACLFlag flgs[]) : ACL(flgs), data (newData), type_(theType), matcher(theStrategy) {}
 
 template <class MatchType>
 ACLStrategised<MatchType>::ACLStrategised (ACLStrategised const &old) : data (old.data->clone()), type_(old.type_), matcher (old.matcher)
@@ -150,7 +150,7 @@ ACLStrategised<MatchType>::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = dynamic_cast<ACLFilledChecklist*>(cl);
     assert(checklist);
-    return matcher->match(data, checklist);
+    return matcher->match(data, checklist, flags);
 }
 
 template <class MatchType>
@@ -34,6 +34,7 @@
 #ifndef SQUID_ACLSTRATEGY_H
 #define SQUID_ACLSTRATEGY_H
 
+#include "acl/Acl.h"
 #include "acl/Data.h"
 
 class ACLFilledChecklist;
@@ -45,7 +46,7 @@ class ACLStrategy
 
 public:
     typedef M MatchType;
-    virtual int match (ACLData<M> * &, ACLFilledChecklist *) = 0;
+    virtual int match (ACLData<M> * &, ACLFilledChecklist *, ACLFlags &) = 0;
     virtual bool requiresRequest() const {return false;}
 
     virtual bool requiresReply() const {return false;}
@@ -66,6 +66,12 @@ splaystrcmp (char * const &l, char * const &r)
     return strcmp (l,r);
 }
 
+void
+ACLStringData::insert(const char *value)
+{
+    values = values->insert(xstrdup(value), splaystrcmp);
+}
+
 bool
 ACLStringData::match(char const *toFind)
 {
@@ -52,6 +52,8 @@ class ACLStringData : public ACLData<char const *>
     void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
+    /// Insert a string data value
+    void insert(const char *);
 
     SplayNode<char *> *values;
 };
@@ -41,7 +41,7 @@
 #include "HttpRequest.h"
 
 int
-ACLTagStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLTagStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     if (checklist->request != NULL)
         return data->match (checklist->request->tag.termedBuf());
@@ -41,7 +41,7 @@ class ACLTagStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLTagStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -38,7 +38,7 @@
 #include "SquidTime.h"
 
 int
-ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (squid_curtime);
 }
@@ -43,7 +43,7 @@ class ACLTimeStrategy : public ACLStrategy<time_t>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLTimeStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -37,10 +37,10 @@
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
 #include "rfc1738.h"
-#include "URL.h"
+#include "src/URL.h"
 
 int
-ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char *esc_buf = xstrdup(urlCanonical(checklist->request));
     rfc1738_unescape(esc_buf);
@@ -41,7 +41,7 @@ class ACLUrlStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlStrategy *Instance();
@@ -38,7 +38,7 @@
 #include "rfc1738.h"
 
 int
-ACLUrlLoginStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLUrlLoginStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char *esc_buf = xstrdup(checklist->request->login);
     rfc1738_unescape(esc_buf);
@@ -45,7 +45,7 @@ class ACLUrlLoginStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlLoginStrategy *Instance();
@@ -40,7 +40,7 @@
 #include "rfc1738.h"
 
 int
-ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char *esc_buf = xstrdup(checklist->request->urlpath.termedBuf());
     rfc1738_unescape(esc_buf);
@@ -42,7 +42,7 @@ class ACLUrlPathStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlPathStrategy *Instance();
@@ -38,7 +38,7 @@
 #include "HttpRequest.h"
 
 int
-ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->port);
 }
@@ -40,7 +40,7 @@ class ACLUrlPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlPortStrategy *Instance();
@@ -132,10 +132,10 @@ ACLUserData::parse()
 
         if (strcmp("-i", t) == 0) {
             debugs(28, 5, "aclParseUserList: Going case-insensitive");
-            flags.case_insensitive = 1;
+            flags.case_insensitive = true;
         } else if (strcmp("REQUIRED", t) == 0) {
             debugs(28, 5, "aclParseUserList: REQUIRED-type enabled");
-            flags.required = 1;
+            flags.required = true;
         } else {
             if (flags.case_insensitive)
                 Tolower(t);
@@ -53,8 +53,8 @@ class ACLUserData : public ACLData<char const *>
     SplayNode<char *> *names;
 
     struct {
-        unsigned int case_insensitive:1;
-        unsigned int required:1;
+        bool case_insensitive;
+        bool required;
     } flags;
 };
 
@@ -122,7 +122,8 @@ Adaptation::AccessCheck::checkCandidates()
             /* BUG 2526: what to do when r->acl is empty?? */
             // XXX: we do not have access to conn->rfc931 here.
             acl_checklist = new ACLFilledChecklist(r->acl, filter.request, dash_str);
-            acl_checklist->reply = filter.reply ? HTTPMSGLOCK(filter.reply) : NULL;
+            if ((acl_checklist->reply = filter.reply))
+                HTTPMSGLOCK(acl_checklist->reply);
             acl_checklist->nonBlockingCheck(AccessCheckCallbackWrapper, this);
             return;
         }
@@ -27,7 +27,7 @@ class Answer
     std::ostream &print(std::ostream &os) const;
 
 public:
-    HttpMsgPointerT<HttpMsg> message; ///< HTTP request or response to forward
+    HttpMsg::Pointer message; ///< HTTP request or response to forward
     String ruleId; ///< ACL (or similar rule) name that blocked forwarding
     bool final; ///< whether the error, if any, cannot be bypassed
     Kind kind; ///< the type of the answer
@@ -295,10 +295,10 @@ Adaptation::Config::DumpAccess(StoreEntry *entry, const char *name)
     }
 }
 
-Adaptation::Config::Config()
-{
-    // XXX: should we init members?
-}
+Adaptation::Config::Config() :
+        onoff(0), service_failure_limit(0), oldest_service_failure(0),
+        service_revival_delay(0)
+{}
 
 // XXX: this is called for ICAP and eCAP configs, but deals mostly
 // with global arrays shared by those individual configs
@@ -20,12 +20,17 @@ Adaptation::Iterator::Iterator(
         AsyncJob("Iterator"),
         Adaptation::Initiate("Iterator"),
         theGroup(aGroup),
-        theMsg(HTTPMSGLOCK(aMsg)),
-        theCause(aCause ? HTTPMSGLOCK(aCause) : NULL),
+        theMsg(aMsg),
+        theCause(aCause),
         theLauncher(0),
         iterations(0),
         adapted(false)
 {
+    if (theCause != NULL)
+        HTTPMSGLOCK(theCause);
+
+    if (theMsg != NULL)
+        HTTPMSGLOCK(theMsg);
 }
 
 Adaptation::Iterator::~Iterator()
@@ -85,7 +90,7 @@ Adaptation::Iterator::noteAdaptationAnswer(const Answer &answer)
 {
     switch (answer.kind) {
     case Answer::akForward:
-        handleAdaptedHeader(answer.message);
+        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
         break;
 
     case Answer::akBlock:
@@ -115,7 +120,8 @@ Adaptation::Iterator::handleAdaptedHeader(HttpMsg *aMsg)
 
     Must(aMsg);
     HTTPMSGUNLOCK(theMsg);
-    theMsg = HTTPMSGLOCK(aMsg);
+    theMsg = aMsg;
+    HTTPMSGLOCK(theMsg);
     adapted = true;
 
     clearAdaptation(theLauncher);
@@ -215,18 +221,18 @@ bool Adaptation::Iterator::updatePlan(bool adopt)
 
     debugs(85,3, HERE << "retiring old plan: " << thePlan);
 
-    Adaptation::ServiceFilter filter = this->filter();
+    Adaptation::ServiceFilter f = this->filter();
     DynamicGroupCfg current, future;
-    DynamicServiceChain::Split(filter, services, current, future);
+    DynamicServiceChain::Split(f, services, current, future);
 
     if (!future.empty()) {
         ah->setFutureServices(future);
         debugs(85,3, HERE << "noted future service-proposed plan: " << future);
     }
 
     // use the current config even if it is empty; we must replace the old plan
-    theGroup = new DynamicServiceChain(current, filter); // refcounted
-    thePlan = ServicePlan(theGroup, filter);
+    theGroup = new DynamicServiceChain(current, f); // refcounted
+    thePlan = ServicePlan(theGroup, f);
     debugs(85,3, HERE << "adopted service-proposed plan: " << thePlan);
     return true;
 }
@@ -33,7 +33,8 @@ Adaptation::Message::set(Header *aHeader)
 {
     clear();
     if (aHeader) {
-        header = HTTPMSGLOCK(aHeader);
+        header = aHeader;
+        HTTPMSGLOCK(header);
         body_pipe = header->body_pipe;
     }
 }
@@ -49,10 +49,10 @@ Adaptation::ServiceConfig::parseVectPoint(const char *service_configConfig) cons
     if (q)
         t = q + 1;
 
-    if (!strcasecmp(t, "precache"))
+    if (!strcmp(t, "precache"))
         return Adaptation::pointPreCache;
 
-    if (!strcasecmp(t, "postcache"))
+    if (!strcmp(t, "postcache"))
         return Adaptation::pointPostCache;
 
     return Adaptation::pointNone;
@@ -3,20 +3,31 @@
 #include "HttpReply.h"
 #include "adaptation/ServiceFilter.h"
 
-Adaptation::ServiceFilter::ServiceFilter(Method aMethod, VectPoint aPoint,
-        HttpRequest *aReq, HttpReply *aRep): method(aMethod), point(aPoint),
-        request(HTTPMSGLOCK(aReq)),
-        reply(aRep ? HTTPMSGLOCK(aRep) : NULL)
+Adaptation::ServiceFilter::ServiceFilter(Method aMethod, VectPoint aPoint, HttpRequest *aReq, HttpReply *aRep):
+        method(aMethod),
+        point(aPoint),
+        request(aReq),
+        reply(aRep)
 {
+    if (reply)
+        HTTPMSGLOCK(reply);
+
     // a lot of code assumes that there is always a virgin request or cause
     assert(request);
+    HTTPMSGLOCK(request);
 }
 
 Adaptation::ServiceFilter::ServiceFilter(const ServiceFilter &f):
-        method(f.method), point(f.point),
-        request(HTTPMSGLOCK(f.request)),
-        reply(f.reply ? HTTPMSGLOCK(f.reply) : NULL)
+        method(f.method),
+        point(f.point),
+        request(f.request),
+        reply(f.reply)
 {
+    if (request)
+        HTTPMSGLOCK(request);
+
+    if (reply)
+        HTTPMSGLOCK(reply);
 }
 
 Adaptation::ServiceFilter::~ServiceFilter()
@@ -32,8 +43,11 @@ Adaptation::ServiceFilter &Adaptation::ServiceFilter::operator =(const ServiceFi
         point = f.point;
         HTTPMSGUNLOCK(request);
         HTTPMSGUNLOCK(reply);
-        request = HTTPMSGLOCK(f.request);
-        reply = f.reply ? HTTPMSGLOCK(f.reply) : NULL;
+        request = f.request;
+        HTTPMSGLOCK(request);
+        reply = f.reply;
+        if (reply)
+            HTTPMSGLOCK(reply);
     }
     return *this;
 }
@@ -99,7 +99,7 @@ Adaptation::Ecap::HeaderRep::parse(const Area &buf)
     MemBuf mb;
     mb.init();
     mb.append(buf.start, buf.size);
-    http_status error;
+    Http::StatusCode error;
     Must(theMessage.parse(&mb, true, &error));
 }
 
@@ -292,29 +292,26 @@ Adaptation::Ecap::StatusLineRep::StatusLineRep(HttpReply &aMessage):
 void
 Adaptation::Ecap::StatusLineRep::statusCode(int code)
 {
-    // TODO: why is .status a enum? Do we not support unknown statuses?
-    theMessage.sline.status = static_cast<http_status>(code);
+    theMessage.sline.set(theMessage.sline.version, static_cast<Http::StatusCode>(code), theMessage.sline.reason());
 }
 
 int
 Adaptation::Ecap::StatusLineRep::statusCode() const
 {
-    // TODO: see statusCode(code) TODO above
-    return static_cast<int>(theMessage.sline.status);
+    // TODO: remove cast when possible
+    return static_cast<int>(theMessage.sline.status());
 }
 
 void
-Adaptation::Ecap::StatusLineRep::reasonPhrase(const Area &)
+Adaptation::Ecap::StatusLineRep::reasonPhrase(const Area &str)
 {
-    // Squid does not support custom reason phrases
-    theMessage.sline.reason = NULL;
+    theMessage.sline.set(theMessage.sline.version, theMessage.sline.status(), str.c_str());
 }
 
 Adaptation::Ecap::StatusLineRep::Area
 Adaptation::Ecap::StatusLineRep::reasonPhrase() const
 {
-    return theMessage.sline.reason ?
-           Area::FromTempString(std::string(theMessage.sline.reason)) : Area();
+    return Area::FromTempString(std::string(theMessage.sline.reason()));
 }
 
 libecap::Version
@@ -43,16 +43,17 @@
 
 Adaptation::Icap::Config Adaptation::Icap::TheConfig;
 
-Adaptation::Icap::Config::Config(): preview_enable(0), preview_size(0),
-        allow206_enable(0),
+Adaptation::Icap::Config::Config() :
+        preview_enable(0), preview_size(0), allow206_enable(0),
         connect_timeout_raw(0), io_timeout_raw(0), reuse_connections(0),
-        client_username_header(NULL), client_username_encode(0), repeat(NULL)
+        client_username_header(NULL), client_username_encode(0), repeat(NULL),
+        repeat_limit(0)
 {
 }
 
 Adaptation::Icap::Config::~Config()
 {
-    // TODO: delete client_username_header?
+    // no need to free client_username_header, it's done in cf_parser.cci:free_all
 }
 
 Adaptation::ServicePointer
@@ -3,6 +3,7 @@
 
 #include "base/RefCount.h"
 #include "enums.h"
+#include "LogTags.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -30,7 +31,7 @@ class History: public RefCountable
 #if USE_SSL
     String ssluser; ///< the username from SSL
 #endif
-    log_type logType; ///< the squid request status (TCP_MISS etc)
+    LogTags logType; ///< the squid request status (TCP_MISS etc)
 
     String log_uri; ///< the request uri
     size_t req_sz; ///< the request size
@@ -62,15 +62,17 @@ class InOut
     void setCause(HttpRequest *r) {
         if (r) {
             HTTPMSGUNLOCK(cause);
-            cause = HTTPMSGLOCK(r);
+            cause = r;
+            HTTPMSGLOCK(cause);
         } else {
             assert(!cause);
         }
     }
 
     void setHeader(Header *h) {
         HTTPMSGUNLOCK(header);
-        header = HTTPMSGLOCK(h);
+        header = h;
+        HTTPMSGLOCK(header);
         body_pipe = header->body_pipe;
     }
 
@@ -130,13 +130,16 @@ bool Adaptation::Icap::Launcher::canRepeat(Adaptation::Icap::XactAbortInfo &info
     if (!info.icapReply) // did not get to read an ICAP reply; a timeout?
         return true;
 
-    debugs(93,9, HERE << info.icapReply->sline.status);
-    if (!info.icapReply->sline.status) // failed to parse the reply; I/O err
+    debugs(93,9, info.icapReply->sline.status());
+    // XXX: Http::scNone is not the only sign of parse error
+    // XXX: if there is a specific HTTP error code describing the problem, that may be set
+    if (info.icapReply->sline.status() == Http::scNone) // failed to parse the reply; I/O err
         return true;
 
     ACLFilledChecklist *cl =
         new ACLFilledChecklist(TheConfig.repeat, info.icapRequest, dash_str);
-    cl->reply = HTTPMSGLOCK(info.icapReply);
+    cl->reply = info.icapReply;
+    HTTPMSGLOCK(cl->reply);
 
     bool result = cl->fastCheck() == ACCESS_ALLOWED;
     delete cl;
@@ -147,17 +150,27 @@ bool Adaptation::Icap::Launcher::canRepeat(Adaptation::Icap::XactAbortInfo &info
 
 Adaptation::Icap::XactAbortInfo::XactAbortInfo(HttpRequest *anIcapRequest,
         HttpReply *anIcapReply, bool beRetriable, bool beRepeatable):
-        icapRequest(anIcapRequest ? HTTPMSGLOCK(anIcapRequest) : NULL),
-        icapReply(anIcapReply ? HTTPMSGLOCK(anIcapReply) : NULL),
-        isRetriable(beRetriable), isRepeatable(beRepeatable)
+        icapRequest(anIcapRequest),
+        icapReply(anIcapReply),
+        isRetriable(beRetriable),
+        isRepeatable(beRepeatable)
 {
+    if (icapRequest)
+        HTTPMSGLOCK(icapRequest);
+    if (icapReply)
+        HTTPMSGLOCK(icapReply);
 }
 
 Adaptation::Icap::XactAbortInfo::XactAbortInfo(const Adaptation::Icap::XactAbortInfo &i):
-        icapRequest(i.icapRequest ? HTTPMSGLOCK(i.icapRequest) : NULL),
-        icapReply(i.icapReply ? HTTPMSGLOCK(i.icapReply) : NULL),
-        isRetriable(i.isRetriable), isRepeatable(i.isRepeatable)
+        icapRequest(i.icapRequest),
+        icapReply(i.icapReply),
+        isRetriable(i.isRetriable),
+        isRepeatable(i.isRepeatable)
 {
+    if (icapRequest)
+        HTTPMSGLOCK(icapRequest);
+    if (icapReply)
+        HTTPMSGLOCK(icapReply);
 }
 
 Adaptation::Icap::XactAbortInfo::~XactAbortInfo()
@@ -771,22 +771,22 @@ void Adaptation::Icap::ModXact::parseIcapHead()
 {
     Must(state.sending == State::sendingUndecided);
 
-    if (!parseHead(icapReply))
+    if (!parseHead(icapReply.getRaw()))
         return;
 
     if (httpHeaderHasConnDir(&icapReply->header, "close")) {
         debugs(93, 5, HERE << "found connection close");
         reuseConnection = false;
     }
 
-    switch (icapReply->sline.status) {
+    switch (icapReply->sline.status()) {
 
-    case 100:
+    case Http::scContinue:
         handle100Continue();
         break;
 
-    case 200:
-    case 201: // Symantec Scan Engine 5.0 and later when modifying HTTP msg
+    case Http::scOkay:
+    case Http::scCreated: // Symantec Scan Engine 5.0 and later when modifying HTTP msg
 
         if (!validate200Ok()) {
             throw TexcHere("Invalid ICAP Response");
@@ -796,16 +796,16 @@ void Adaptation::Icap::ModXact::parseIcapHead()
 
         break;
 
-    case 204:
+    case Http::scNoContent:
         handle204NoContent();
         break;
 
-    case 206:
+    case Http::scPartialContent:
         handle206PartialContent();
         break;
 
     default:
-        debugs(93, 5, HERE << "ICAP status " << icapReply->sline.status);
+        debugs(93, 5, "ICAP status " << icapReply->sline.status());
         handleUnknownScode();
         break;
     }
@@ -946,20 +946,19 @@ void Adaptation::Icap::ModXact::prepEchoing()
     {
         HttpMsg::Pointer newHead;
         if (dynamic_cast<const HttpRequest*>(oldHead)) {
-            HttpRequest::Pointer newR(new HttpRequest);
-            newHead = newR;
+            newHead = new HttpRequest;
         } else if (dynamic_cast<const HttpReply*>(oldHead)) {
             newHead = new HttpReply;
         }
         Must(newHead != NULL);
 
         newHead->inheritProperties(oldHead);
 
-        adapted.setHeader(newHead);
+        adapted.setHeader(newHead.getRaw());
     }
 
     // parse the buffer back
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
 
     Must(adapted.header->parse(&httpBuf, true, &error));
 
@@ -1072,7 +1071,7 @@ bool Adaptation::Icap::ModXact::parseHead(HttpMsg *head)
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " head bytes to parse" <<
            "; state: " << state.parsing);
 
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
     const bool parsed = head->parse(&readBuf, commEof, &error);
     Must(parsed || !error); // success or need more data
 
@@ -1269,10 +1268,12 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
 
     al.cache.caddr = request_->client_addr;
 
-    al.request = HTTPMSGLOCK(request_);
-    if (reply_)
-        al.reply = HTTPMSGLOCK(reply_);
-    else
+    al.request = request_;
+    HTTPMSGLOCK(al.request);
+    if (reply_) {
+        al.reply = reply_;
+        HTTPMSGLOCK(al.reply);
+    } else
         al.reply = NULL;
 
     if (h->rfc931.size())
@@ -1293,7 +1294,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
     }
 
     if (reply_) {
-        al.http.code = reply_->sline.status;
+        al.http.code = reply_->sline.status();
         al.http.content_type = reply_->content_type.termedBuf();
         if (replyHttpBodySize >= 0) {
             al.cache.replySize = replyHttpBodySize + reply_->hdr_sz;
@@ -1514,13 +1515,13 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
     if (const HttpRequest* old_request = dynamic_cast<const HttpRequest*>(head)) {
         HttpRequest::Pointer new_request(new HttpRequest);
         Must(old_request->canonical);
-        urlParse(old_request->method, old_request->canonical, new_request);
+        urlParse(old_request->method, old_request->canonical, new_request.getRaw());
         new_request->http_ver = old_request->http_ver;
-        headClone = new_request;
+        headClone = new_request.getRaw();
     } else if (const HttpReply *old_reply = dynamic_cast<const HttpReply*>(head)) {
         HttpReply::Pointer new_reply(new HttpReply);
         new_reply->sline = old_reply->sline;
-        headClone = new_reply;
+        headClone = new_reply.getRaw();
     }
     Must(headClone != NULL);
     headClone->inheritProperties(head);
@@ -1537,7 +1538,7 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
     headClone->header.removeHopByHopEntries();
 
     // pack polished HTTP header
-    packHead(httpBuf, headClone);
+    packHead(httpBuf, headClone.getRaw());
 
     // headClone unlocks and, hence, deletes the message we packed
 }
@@ -56,7 +56,7 @@ void Adaptation::Icap::OptXact::makeRequest(MemBuf &buf)
     buf.append(ICAP::crlf, 2);
 
     // XXX: HttpRequest cannot fully parse ICAP Request-Line
-    http_status reqStatus;
+    Http::StatusCode reqStatus;
     Must(icapRequest->parse(&buf, true, &reqStatus) > 0);
 }
 
@@ -79,7 +79,7 @@ void Adaptation::Icap::OptXact::handleCommRead(size_t)
         debugs(93, 7, HERE << "readAll=" << readAll);
         icap_tio_finish = current_time;
         setOutcome(xoOpt);
-        sendAnswer(Answer::Forward(icapReply));
+        sendAnswer(Answer::Forward(icapReply.getRaw()));
         Must(done()); // there should be nothing else to do
         return;
     }
@@ -96,7 +96,7 @@ bool Adaptation::Icap::OptXact::parseResponse()
     HttpReply::Pointer r(new HttpReply);
     r->protoPrefix = "ICAP/"; // TODO: make an IcapReply class?
 
-    if (!parseHttpMsg(r)) // throws on errors
+    if (!parseHttpMsg(r.getRaw())) // throws on errors
         return false;
 
     if (httpHeaderHasConnDir(&r->header, "close"))
@@ -116,7 +116,7 @@ void Adaptation::Icap::OptXact::finalizeLogInfo()
     //    al.cache.caddr = 0;
     al.icap.reqMethod = Adaptation::methodOptions;
 
-    if (icapReply && al.icap.bytesRead > icapReply->hdr_sz)
+    if (icapReply != NULL && al.icap.bytesRead > icapReply->hdr_sz)
         al.icap.bodyBytesRead = al.icap.bytesRead - icapReply->hdr_sz;
 
     Adaptation::Icap::Xaction::finalizeLogInfo();
@@ -75,7 +75,7 @@ void Adaptation::Icap::Options::configure(const HttpReply *reply)
 
     const HttpHeader *h = &reply->header;
 
-    if (reply->sline.status != 200)
+    if (reply->sline.status() != Http::scOkay)
         error = "unsupported status code of OPTIONS response";
 
     // Methods
@@ -530,13 +530,13 @@ void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(const Answer &answer)
     }
 
     Must(answer.kind == Answer::akForward); // no akBlock for OPTIONS requests
-    HttpMsg *msg = answer.message;
+    const HttpMsg *msg = answer.message.getRaw();
     Must(msg);
 
     debugs(93,5, HERE << "is interpreting new options " << status());
 
     Adaptation::Icap::Options *newOptions = NULL;
-    if (HttpReply *r = dynamic_cast<HttpReply*>(msg)) {
+    if (const HttpReply *r = dynamic_cast<const HttpReply*>(msg)) {
         newOptions = new Adaptation::Icap::Options;
         newOptions->configure(r);
     } else {
@@ -50,7 +50,8 @@ Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::Serv
 {
     debugs(93,3, typeName << " constructed, this=" << this <<
            " [icapx" << id << ']'); // we should not call virtual status() here
-    icapRequest = HTTPMSGLOCK(new HttpRequest);
+    icapRequest = new HttpRequest;
+    HTTPMSGLOCK(icapRequest);
     icap_tr_start = current_time;
 }
 
@@ -438,7 +439,7 @@ bool Adaptation::Icap::Xaction::parseHttpMsg(HttpMsg *msg)
 {
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " head bytes to parse");
 
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
     const bool parsed = msg->parse(&readBuf, commEof, &error);
     Must(parsed || !error); // success or need more data
 
@@ -536,7 +537,7 @@ void Adaptation::Icap::Xaction::swanSong()
 void Adaptation::Icap::Xaction::tellQueryAborted()
 {
     if (theInitiator.set()) {
-        Adaptation::Icap::XactAbortInfo abortInfo(icapRequest, icapReply,
+        Adaptation::Icap::XactAbortInfo abortInfo(icapRequest, icapReply.getRaw(),
                 retriable(), repeatable());
         Launcher *launcher = dynamic_cast<Launcher*>(theInitiator.get());
         // launcher may be nil if initiator is invalid
@@ -571,10 +572,12 @@ void Adaptation::Icap::Xaction::finalizeLogInfo()
     al.icap.ioTime = tvSubMsec(icap_tio_start, icap_tio_finish);
     al.icap.trTime = tvSubMsec(icap_tr_start, current_time);
 
-    al.icap.request = HTTPMSGLOCK(icapRequest);
-    if (icapReply) {
-        al.icap.reply = HTTPMSGLOCK(icapReply);
-        al.icap.resStatus = icapReply->sline.status;
+    al.icap.request = icapRequest;
+    HTTPMSGLOCK(al.icap.request);
+    if (icapReply != NULL) {
+        al.icap.reply = icapReply.getRaw();
+        HTTPMSGLOCK(al.icap.reply);
+        al.icap.resStatus = icapReply->sline.status();
     }
 }
 
@@ -8,7 +8,8 @@ libanyp_la_SOURCES = \
 	PortCfg.h \
 	ProtocolType.cc \
 	ProtocolType.h \
-	ProtocolVersion.h
+	ProtocolVersion.h \
+	TrafficMode.h
 
 ProtocolType.cc: ProtocolType.h $(top_srcdir)/src/mk-string-arrays.awk
 	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk <$(srcdir)/ProtocolType.h | sed -e 's%PROTO_%%' >$@) || ($(RM) -f $@ && exit 1)
@@ -13,14 +13,15 @@ CBDATA_NAMESPACED_CLASS_INIT(AnyP, PortCfg);
 int NHttpSockets = 0;
 int HttpSockets[MAXTCPLISTENPORTS];
 
-AnyP::PortCfg::PortCfg(const char *aProtocol)
+AnyP::PortCfg::PortCfg(const char *aProtocol) :
+        next(NULL),
+        protocol(xstrdup(aProtocol)),
+        name(NULL),
+        defaultsite(NULL)
 #if USE_SSL
-        :
-        dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
+        ,dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
 #endif
-{
-    protocol = xstrdup(aProtocol);
-}
+{}
 
 AnyP::PortCfg::~PortCfg()
 {
@@ -57,20 +58,16 @@ AnyP::PortCfg::clone() const
     if (defaultsite)
         b->defaultsite = xstrdup(defaultsite);
 
-    b->intercepted = intercepted;
-    b->spoof_client_ip = spoof_client_ip;
-    b->accel = accel;
+    b->flags = flags;
     b->allow_direct = allow_direct;
     b->vhost = vhost;
-    b->sslBump = sslBump;
     b->vport = vport;
     b->connection_auth_disabled = connection_auth_disabled;
     b->disable_pmtu_discovery = disable_pmtu_discovery;
-
-    memcpy( &(b->tcp_keepalive), &(tcp_keepalive), sizeof(tcp_keepalive));
+    b->tcp_keepalive = tcp_keepalive;
 
 #if 0
-    // AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
+    // TODO: AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
 
 #if USE_SSL
     char *cert;
@@ -94,7 +91,8 @@ AnyP::PortCfg::clone() const
 }
 
 #if USE_SSL
-void AnyP::PortCfg::configureSslServerContext()
+void
+AnyP::PortCfg::configureSslServerContext()
 {
     if (cert)
         Ssl::readCertChainAndPrivateKeyFromFiles(signingCert, signPkey, certsToChain, cert, key);
@@ -1,6 +1,7 @@
 #ifndef SQUID_ANYP_PORTCFG_H
 #define SQUID_ANYP_PORTCFG_H
 
+#include "anyp/TrafficMode.h"
 #include "cbdata.h"
 #include "comm/Connection.h"
 
@@ -29,24 +30,23 @@ class PortCfg
     char *name;                /* visible name */
     char *defaultsite;         /* default web site */
 
-    unsigned int intercepted:1;        /**< intercepting proxy port */
-    unsigned int spoof_client_ip:1;    /**< spoof client ip if possible */
-    unsigned int accel:1;              /**< HTTP accelerator */
-    unsigned int allow_direct:1;       /**< Allow direct forwarding in accelerator mode */
-    unsigned int vhost:1;              /**< uses host header */
-    unsigned int sslBump:1;            /**< intercepts CONNECT requests */
-    unsigned int actAsOrigin:1;        ///< update replies to conform with RFC 2616
-    unsigned int ignore_cc:1;          /**< Ignore request Cache-Control directives */
-
-    int vport;                 /* virtual port support, -1 for dynamic, >0 static*/
-    bool connection_auth_disabled;     /* Don't support connection oriented auth */
+    TrafficMode flags;  ///< flags indicating what type of traffic to expect via this port.
+
+    bool allow_direct;       ///< Allow direct forwarding in accelerator mode
+    bool vhost;              ///< uses host header
+    bool actAsOrigin;        ///< update replies to conform with RFC 2616
+    bool ignore_cc;          ///< Ignore request Cache-Control directives
+
+    bool connection_auth_disabled; ///< Don't support connection oriented auth
+
+    int vport;               ///< virtual port support. -1 if dynamic, >0 static
     int disable_pmtu_discovery;
 
     struct {
-        unsigned int enabled;
         unsigned int idle;
         unsigned int interval;
         unsigned int timeout;
+        bool enabled;
     } tcp_keepalive;
 
     /**
@@ -10,6 +10,10 @@
 namespace AnyP
 {
 
+/**
+ * Stores a protocol version label.
+ * For example HTTP/1.1 or ICY/1.0 or FTP/2.0
+ */
 class ProtocolVersion
 {
 
@@ -26,9 +30,9 @@ class ProtocolVersion
         minor = aMinor;
     }
 
-    ProtocolType protocol;
-    unsigned int major;
-    unsigned int minor;
+    ProtocolType protocol; ///< which protocol this version is for
+    unsigned int major;    ///< major version number
+    unsigned int minor;    ///< minor version number
 
     bool operator==(const ProtocolVersion& that) const {
         if (this->protocol != that.protocol)
@@ -0,0 +1,70 @@
+#ifndef SQUID_ANYP_TRAFFIC_MODE_H
+#define SQUID_ANYP_TRAFFIC_MODE_H
+
+namespace AnyP
+{
+
+/**
+ * Set of 'mode' flags defining types of trafic which can be received.
+ *
+ * Use to determine the processing steps which need to be applied
+ * to this traffic under any special circumstances which may apply.
+ */
+class TrafficMode
+{
+public:
+    TrafficMode() : accelSurrogate(false), natIntercept(false), tproxyIntercept(false), tunnelSslBumping(false) {}
+    TrafficMode(const TrafficMode &rhs) { operator =(rhs); }
+    TrafficMode &operator =(const TrafficMode &rhs) { memcpy(this, &rhs, sizeof(TrafficMode)); return *this; }
+
+    /** marks HTTP accelerator (reverse/surrogate proxy) traffic
+     *
+     * Indicating the following are required:
+     *  - URL translation from relative to absolute form
+     *  - restriction to origin peer relay recommended
+     */
+    bool accelSurrogate;
+
+    /** marks NAT intercepted traffic
+     *
+     * Indicating the following are required:
+     *  - NAT lookups
+     *  - URL translation from relative to absolute form
+     *  - Same-Origin verification is mandatory
+     *  - destination pinning is recommended
+     *  - authentication prohibited
+     */
+    bool natIntercept;
+
+    /** marks TPROXY intercepted traffic
+     *
+     * Indicating the following are required:
+     *  - src/dst IP inversion must be performed
+     *  - client IP should be spoofed if possible
+     *  - URL translation from relative to absolute form
+     *  - Same-Origin verification is mandatory
+     *  - destination pinning is recommended
+     *  - authentication prohibited
+     */
+    bool tproxyIntercept;
+
+    /** marks intercept and decryption of CONNECT (tunnel) SSL traffic
+     *
+     * Indicating the following are required:
+     *  - decryption of CONNECT request
+     *  - URL translation from relative to absolute form
+     *  - authentication prohibited on unwrapped requests (only on the CONNECT tunnel)
+     *  - encrypted outbound server connections
+     *  - peer relay prohibited. TODO: re-encrypt and re-wrap with CONNECT
+     */
+    bool tunnelSslBumping;
+
+    /** true if the traffic is in any way intercepted
+     *
+     */
+    bool isIntercepted() { return natIntercept||tproxyIntercept ;}
+};
+
+} // namespace AnyP
+
+#endif
@@ -63,7 +63,7 @@ ACLMaxUserIP::parse()
 
     if (strcmp("-s", t) == 0) {
         debugs(28, 5, "aclParseUserMaxIP: Going strict");
-        flags.strict = 1;
+        flags.strict = true;
         t = ConfigParser::strtokFile();
     }
 
@@ -73,9 +73,9 @@ class ACLMaxUserIP : public ACL
     int maximum;
 
     struct Flags {
-        Flags() : strict(0) {}
+        Flags() : strict(false) {}
 
-        unsigned int strict:1;
+        bool strict;
     } flags;
 };
 
@@ -18,6 +18,7 @@ libauth_la_SOURCES = \
 	CredentialState.h \
 	Gadgets.cc \
 	Gadgets.h \
+	QueueNode.h \
 	Scheme.cc \
 	Scheme.h \
 	State.h \
@@ -0,0 +1,49 @@
+#ifndef SQUID_SRC_AUTH_QUEUENODE_H
+#define SQUID_SRC_AUTH_QUEUENODE_H
+
+namespace Auth
+{
+
+/**
+ * A queue of auth requests waiting for verification to occur.
+ *
+ * Certain authentication schemes such a Basic and Bearer auth
+ * permit credentials tokens to be repeated from multiple sources
+ * simultaneously. This queue node allows multiple validation
+ * queries to be collapsed into one backend helper lookup.
+ * CBDATA and handlers stored in these queue nodes can be notified
+ * all at once with a result when the lookup completes.
+ */
+class QueueNode
+{
+
+private:
+    // we store CBDATA here, copy is not safe
+    QueueNode(const QueueNode &);
+    QueueNode &operator =(const QueueNode &);
+
+public:
+    QueueNode(Auth::UserRequest *aRequest, AUTHCB *aHandler, void *aData) : auth_user_request(aRequest), handler(aHandler), data(cbdataReference(aData)) {}
+    ~QueueNode() {
+        cbdataReferenceDone(data);
+        while (next) {
+            QueueNode *tmp = next->next;
+            next->next = NULL;
+            delete next;
+            next = tmp;
+        };
+    }
+
+    Auth::QueueNode *next;
+    Auth::UserRequest::Pointer auth_user_request;
+    AUTHCB *handler;
+    void *data;
+
+    MEMPROXY_CLASS(Auth::QueueNode);
+};
+
+MEMPROXY_CLASS_INLINE(Auth::QueueNode);
+
+} // namespace Auth
+
+#endif /* SQUID_SRC_AUTH_QUEUENODE_H */
@@ -105,7 +105,7 @@ Auth::User::absorb(Auth::User::Pointer from)
         new_ipdata = static_cast<AuthUserIP *>(from->ip_list.head->data);
 
         /* If this IP has expired - ignore the expensive merge actions. */
-        if (new_ipdata->ip_expiretime + ::Config.authenticateIpTTL < squid_curtime) {
+        if (new_ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the source list */
             dlinkDelete(&new_ipdata->node, &(from->ip_list));
             cbdataFree(new_ipdata);
@@ -124,7 +124,7 @@ Auth::User::absorb(Auth::User::Pointer from)
                     /* update IP ttl and stop searching. */
                     ipdata->ip_expiretime = max(ipdata->ip_expiretime, new_ipdata->ip_expiretime);
                     break;
-                } else if (ipdata->ip_expiretime + ::Config.authenticateIpTTL < squid_curtime) {
+                } else if (ipdata->ip_expiretime <= squid_curtime) {
                     /* This IP has expired - cleanup the destination list */
                     dlinkDelete(&ipdata->node, &ip_list);
                     cbdataFree(ipdata);
@@ -309,7 +309,7 @@ Auth::User::addIp(Ip::Address ipaddr)
             found = 1;
             /* update IP ttl */
             ipdata->ip_expiretime = squid_curtime;
-        } else if (ipdata->ip_expiretime + ::Config.authenticateIpTTL < squid_curtime) {
+        } else if (ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&ipdata->node, &ip_list);
             cbdataFree(ipdata);
@@ -327,7 +327,7 @@ Auth::User::addIp(Ip::Address ipaddr)
     /* This ip is not in the seen list */
     ipdata = cbdataAlloc(AuthUserIP);
 
-    ipdata->ip_expiretime = squid_curtime;
+    ipdata->ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
 
     ipdata->ipaddr = ipaddr;
 
@@ -479,14 +479,14 @@ Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointe
 {
     http_hdr_type type;
 
-    switch (rep->sline.status) {
+    switch (rep->sline.status()) {
 
-    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
+    case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
         type = HDR_PROXY_AUTHENTICATE;
         break;
 
-    case HTTP_UNAUTHORIZED:
+    case Http::scUnauthorized:
         /* WWW Authorisation needed */
         type = HDR_WWW_AUTHENTICATE;
         break;
@@ -500,8 +500,8 @@ Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointe
 
     debugs(29, 9, HERE << "headertype:" << type << " authuser:" << auth_user_request);
 
-    if (((rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (rep->sline.status == HTTP_UNAUTHORIZED)) && internal)
+    if (((rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (rep->sline.status() == Http::scUnauthorized)) && internal)
         /* this is a authenticate-needed response */
     {
 
@@ -50,14 +50,24 @@ class HttpRequest;
 // AYJ: must match re-definition in helpers/negotiate_auth/kerberos/negotiate_kerb_auth.cc
 #define MAX_AUTHTOKEN_LEN   32768
 
-/// \ingroup AuthAPI
+/**
+ * Node used to link an IP address to some user credentials
+ * for the max_user_ip ACL feature.
+ *
+ * \ingroup AuthAPI
+ */
 class AuthUserIP
 {
 public:
     dlink_node node;
-    /* IP addr this user authenticated from */
 
+    /// IP address this user authenticated from
     Ip::Address ipaddr;
+
+    /** When this IP should be forgotten.
+     * Set to the time of last request made from this
+     * (user,IP) pair plus authenticate_ip_ttl seconds
+     */
     time_t ip_expiretime;
 };
 
@@ -8,7 +8,7 @@
 Auth::Basic::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
         passwd(NULL),
-        auth_queue(NULL),
+        queue(NULL),
         currentRequest(NULL)
 {}
 
@@ -4,12 +4,11 @@
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 
-class BasicAuthQueueNode;
-
 namespace Auth
 {
 
 class Config;
+class QueueNode;
 
 namespace Basic
 {
@@ -31,7 +30,7 @@ class User : public Auth::User
 
     char *passwd;
 
-    BasicAuthQueueNode *auth_queue;
+    QueueNode *queue;
 
 private:
     Auth::UserRequest::Pointer currentRequest;
@@ -2,6 +2,7 @@
 #include "auth/basic/auth_basic.h"
 #include "auth/basic/User.h"
 #include "auth/basic/UserRequest.h"
+#include "auth/QueueNode.h"
 #include "auth/State.h"
 #include "charset.h"
 #include "Debug.h"
@@ -96,34 +97,30 @@ Auth::Basic::UserRequest::module_start(AUTHCB * handler, void *data)
     if (user()->credentials() == Auth::Pending) {
         /* there is a request with the same credentials already being verified */
 
-        BasicAuthQueueNode *node = static_cast<BasicAuthQueueNode *>(xcalloc(1, sizeof(BasicAuthQueueNode)));
-        assert(node);
-        node->auth_user_request = this;
-        node->handler = handler;
-        node->data = cbdataReference(data);
+        Auth::QueueNode *node = new Auth::QueueNode(this, handler, data);
 
         /* queue this validation request to be infored of the pending lookup results */
-        node->next = basic_auth->auth_queue;
-        basic_auth->auth_queue = node;
+        node->next = basic_auth->queue;
+        basic_auth->queue = node;
         return;
     }
     // otherwise submit this request to the auth helper(s) for validation
 
     /* mark this user as having verification in progress */
     user()->credentials(Auth::Pending);
     char buf[HELPER_INPUT_BUFFER];
-    static char username[HELPER_INPUT_BUFFER];
+    static char usern[HELPER_INPUT_BUFFER];
     static char pass[HELPER_INPUT_BUFFER];
     if (static_cast<Auth::Basic::Config*>(user()->config)->utf8) {
-        latin1_to_utf8(username, sizeof(username), user()->username());
+        latin1_to_utf8(usern, sizeof(usern), user()->username());
         latin1_to_utf8(pass, sizeof(pass), basic_auth->passwd);
-        xstrncpy(username, rfc1738_escape(username), sizeof(username));
+        xstrncpy(usern, rfc1738_escape(usern), sizeof(usern));
         xstrncpy(pass, rfc1738_escape(pass), sizeof(pass));
     } else {
-        xstrncpy(username, rfc1738_escape(user()->username()), sizeof(username));
+        xstrncpy(usern, rfc1738_escape(user()->username()), sizeof(usern));
         xstrncpy(pass, rfc1738_escape(basic_auth->passwd), sizeof(pass));
     }
-    int sz = snprintf(buf, sizeof(buf), "%s %s\n", username, pass);
+    int sz = snprintf(buf, sizeof(buf), "%s %s\n", usern, pass);
     if (sz<=0) {
         debugs(9, DBG_CRITICAL, "ERROR: Basic Authentication Failure. Can not build helper validation request.");
         handler(data);
@@ -139,7 +136,6 @@ void
 Auth::Basic::UserRequest::HandleReply(void *data, const HelperReply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
-    BasicAuthQueueNode *tmpnode;
     void *cbdata;
     debugs(29, 5, HERE << "reply=" << reply);
 
@@ -168,15 +164,15 @@ Auth::Basic::UserRequest::HandleReply(void *data, const HelperReply &reply)
 
     cbdataReferenceDone(r->data);
 
-    while (basic_auth->auth_queue) {
-        tmpnode = basic_auth->auth_queue->next;
+    while (basic_auth->queue) {
+        if (cbdataReferenceValidDone(basic_auth->queue->data, &cbdata))
+            basic_auth->queue->handler(cbdata);
 
-        if (cbdataReferenceValidDone(basic_auth->auth_queue->data, &cbdata))
-            basic_auth->auth_queue->handler(cbdata);
+        Auth::QueueNode *tmpnode = basic_auth->queue->next;
+        basic_auth->queue->next = NULL;
+        delete basic_auth->queue;
 
-        xfree(basic_auth->auth_queue);
-
-        basic_auth->auth_queue = tmpnode;
+        basic_auth->queue = tmpnode;
     }
 
     delete r;
@@ -167,22 +167,22 @@ Auth::Basic::Config::~Config()
 void
 Auth::Basic::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param basic program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "realm") == 0) {
+    } else if (strcmp(param_str, "realm") == 0) {
         parse_eol(&basicAuthRealm);
-    } else if (strcasecmp(param_str, "credentialsttl") == 0) {
+    } else if (strcmp(param_str, "credentialsttl") == 0) {
         parse_time_t(&credentialsTTL);
-    } else if (strcasecmp(param_str, "casesensitive") == 0) {
+    } else if (strcmp(param_str, "casesensitive") == 0) {
         parse_onoff(&casesensitive);
-    } else if (strcasecmp(param_str, "utf8") == 0) {
+    } else if (strcmp(param_str, "utf8") == 0) {
         parse_onoff(&utf8);
     } else {
         debugs(29, DBG_CRITICAL, HERE << "unrecognised basic auth scheme parameter '" << param_str << "'");
@@ -13,17 +13,6 @@
 
 #define DefaultAuthenticateChildrenMax  32	/* 32 processes */
 
-/** queue of auth requests waiting for verification to occur */
-class BasicAuthQueueNode
-{
-
-public:
-    BasicAuthQueueNode *next;
-    Auth::UserRequest::Pointer auth_user_request;
-    AUTHCB *handler;
-    void *data;
-};
-
 namespace Auth
 {
 namespace Basic
@@ -9,7 +9,9 @@
 Auth::Digest::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
         HA1created(0)
-{}
+{
+    memset(HA1, 0, sizeof(HA1));
+}
 
 Auth::Digest::User::~User()
 {
@@ -20,7 +20,10 @@ Auth::Digest::UserRequest::UserRequest() :
         uri(NULL),
         response(NULL),
         nonce(NULL)
-{}
+{
+    memset(nc, 0, sizeof(nc));
+    memset(&flags, 0, sizeof(flags));
+}
 
 /**
  * Delete the digest request structure.
@@ -99,7 +102,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
     if (strcasecmp(digest_request->response, Response) != 0) {
         if (!digest_request->flags.helper_queried) {
             /* Query the helper in case the password has changed */
-            digest_request->flags.helper_queried = 1;
+            digest_request->flags.helper_queried = true;
             auth_user->credentials(Auth::Pending);
             return;
         }
@@ -117,7 +120,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
 
             if (strcasecmp(digest_request->response, Response)) {
                 auth_user->credentials(Auth::Failed);
-                digest_request->flags.invalid_password = 1;
+                digest_request->flags.invalid_password = true;
                 digest_request->setDenyMessage("Incorrect password");
                 return;
             } else {
@@ -142,7 +145,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
             }
         } else {
             auth_user->credentials(Auth::Failed);
-            digest_request->flags.invalid_password = 1;
+            digest_request->flags.invalid_password = true;
             digest_request->setDenyMessage("Incorrect password");
             return;
         }
@@ -197,9 +200,8 @@ Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int acce
     http_hdr_type type;
 
     /* don't add to authentication error pages */
-
-    if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
@@ -211,7 +213,7 @@ Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int acce
 #endif
 
     if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->authenticateProgram) && authDigestNonceLastRequest(nonce)) {
-        flags.authinfo_sent = 1;
+        flags.authinfo_sent = true;
         debugs(29, 9, HERE << "Sending type:" << type << " header: 'nextnonce=\"" << authenticateDigestNonceNonceb64(nonce) << "\"");
         httpHeaderPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(nonce));
     }
@@ -231,8 +233,8 @@ Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int acc
         return;
 
     /* don't add to authentication error pages */
-    if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
@@ -328,7 +330,7 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
         assert(digest_request);
 
         digest_request->user()->credentials(Auth::Failed);
-        digest_request->flags.invalid_password = 1;
+        digest_request->flags.invalid_password = true;
 
         Note::Pointer msgNote = reply.notes.find("message");
         if (msgNote != NULL) {
@@ -48,9 +48,9 @@ class UserRequest : public Auth::UserRequest
     char *response;
 
     struct {
-        unsigned int authinfo_sent:1;
-        unsigned int invalid_password:1;
-        unsigned int helper_queried:1;
+        bool authinfo_sent;
+        bool invalid_password;
+        bool helper_queried;
     } flags;
     digest_nonce_h *nonce;
 
@@ -129,7 +129,6 @@ static digest_nonce_h *
 authenticateDigestNonceNew(void)
 {
     digest_nonce_h *newnonce = static_cast < digest_nonce_h * >(digest_nonce_pool->alloc());
-    digest_nonce_h *temp;
 
     /* NONCE CREATION - NOTES AND REASONING. RBC 20010108
      * === EXCERPT FROM RFC 2617 ===
@@ -172,7 +171,7 @@ authenticateDigestNonceNew(void)
 
     /* create a new nonce */
     newnonce->nc = 0;
-    newnonce->flags.valid = 1;
+    newnonce->flags.valid = true;
     newnonce->noncedata.self = newnonce;
     newnonce->noncedata.creationtime = current_time.tv_sec;
     newnonce->noncedata.randomdata = squid_random();
@@ -183,7 +182,7 @@ authenticateDigestNonceNew(void)
      * have a random factor
      */
 
-    while ((temp = authenticateDigestNonceFindNonce((char const *) (newnonce->key)))) {
+    while (authenticateDigestNonceFindNonce((char const *) (newnonce->key))) {
         /* create a new nonce */
         newnonce->noncedata.randomdata = squid_random();
         /* Bug 3526 high performance fix: add 1 second to creationtime to avoid duplication */
@@ -194,7 +193,7 @@ authenticateDigestNonceNew(void)
     hash_join(digest_nonce_cache, newnonce);
     /* the cache's link */
     authDigestNonceLink(newnonce);
-    newnonce->flags.incache = 1;
+    newnonce->flags.incache = true;
     debugs(29, 5, "authenticateDigestNonceNew: created nonce " << newnonce << " at " << newnonce->noncedata.creationtime);
     return newnonce;
 }
@@ -211,7 +210,7 @@ authenticateDigestNonceDelete(digest_nonce_h * nonce)
 
 #endif
 
-        assert(nonce->flags.incache == 0);
+        assert(!nonce->flags.incache);
 
         safe_free(nonce->key);
 
@@ -282,7 +281,7 @@ authenticateDigestNonceCacheCleanup(void *data)
             debugs(29, 4, "authenticateDigestNonceCacheCleanup: Removing nonce " << (char *) nonce->key << " from cache due to timeout.");
             assert(nonce->flags.incache);
             /* invalidate nonce so future requests fail */
-            nonce->flags.valid = 0;
+            nonce->flags.valid = false;
             /* if it is tied to a auth_user, remove the tie */
             authDigestNonceUserUnlink(nonce);
             authDigestNoncePurge(nonce);
@@ -387,7 +386,7 @@ authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
     if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->NonceStrictness && intnc != nonce->nc + 1) ||
             intnc < nonce->nc + 1) {
         debugs(29, 4, "authDigestNonceIsValid: Nonce count doesn't match");
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return 0;
     }
 
@@ -415,19 +414,19 @@ authDigestNonceIsStale(digest_nonce_h * nonce)
                static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxduration << " " <<
                current_time.tv_sec);
 
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return -1;
     }
 
     if (nonce->nc > 99999998) {
         debugs(29, 4, "authDigestNonceIsStale: Nonce count overflow");
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return -1;
     }
 
     if (nonce->nc > static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxuses) {
         debugs(29, 4, "authDigestNoncelastRequest: Nonce count over user limit");
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return -1;
     }
 
@@ -470,7 +469,7 @@ authDigestNoncePurge(digest_nonce_h * nonce)
 
     hash_remove_link(digest_nonce_cache, nonce);
 
-    nonce->flags.incache = 0;
+    nonce->flags.incache = false;
 
     /* the cache's link */
     authDigestNonceUnlink(nonce);
@@ -642,30 +641,30 @@ Auth::Digest::Config::Config() :
 void
 Auth::Digest::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param digest program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "realm") == 0) {
+    } else if (strcmp(param_str, "realm") == 0) {
         parse_eol(&digestAuthRealm);
-    } else if (strcasecmp(param_str, "nonce_garbage_interval") == 0) {
+    } else if (strcmp(param_str, "nonce_garbage_interval") == 0) {
         parse_time_t(&nonceGCInterval);
-    } else if (strcasecmp(param_str, "nonce_max_duration") == 0) {
+    } else if (strcmp(param_str, "nonce_max_duration") == 0) {
         parse_time_t(&noncemaxduration);
-    } else if (strcasecmp(param_str, "nonce_max_count") == 0) {
+    } else if (strcmp(param_str, "nonce_max_count") == 0) {
         parse_int((int *) &noncemaxuses);
-    } else if (strcasecmp(param_str, "nonce_strictness") == 0) {
+    } else if (strcmp(param_str, "nonce_strictness") == 0) {
         parse_onoff(&NonceStrictness);
-    } else if (strcasecmp(param_str, "check_nonce_count") == 0) {
+    } else if (strcmp(param_str, "check_nonce_count") == 0) {
         parse_onoff(&CheckNonceCount);
-    } else if (strcasecmp(param_str, "post_workaround") == 0) {
+    } else if (strcmp(param_str, "post_workaround") == 0) {
         parse_onoff(&PostWorkaround);
-    } else if (strcasecmp(param_str, "utf8") == 0) {
+    } else if (strcmp(param_str, "utf8") == 0) {
         parse_onoff(&utf8);
     } else {
         debugs(29, DBG_CRITICAL, "unrecognised digest auth scheme parameter '" << param_str << "'");
@@ -764,7 +763,7 @@ authDigestLogUsername(char *username, Auth::UserRequest::Pointer auth_user_reque
     assert(auth_user_request != NULL);
 
     /* log the username */
-    debugs(29, 9, "authDigestLogUsername: Creating new user for logging '" << username << "'");
+    debugs(29, 9, "Creating new user for logging '" << (username?username:"[no username]") << "'");
     Auth::User::Pointer digest_user = new Auth::Digest::User(static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest")));
     /* save the credentials */
     digest_user->username(username);
@@ -852,9 +851,9 @@ Auth::Digest::Config::decode(char const *proxy_auth)
         }
 
         /* find type */
-        http_digest_attr_type type = (http_digest_attr_type)httpHeaderIdByName(item, nlen, DigestFieldsInfo, DIGEST_ENUM_END);
+        http_digest_attr_type t = (http_digest_attr_type)httpHeaderIdByName(item, nlen, DigestFieldsInfo, DIGEST_ENUM_END);
 
-        switch (type) {
+        switch (t) {
         case DIGEST_USERNAME:
             safe_free(username);
             username = xstrndup(value.rawBuf(), value.size() + 1);
@@ -932,53 +931,69 @@ Auth::Digest::Config::decode(char const *proxy_auth)
 
     /* 2069 requirements */
 
+    // return value.
+    Auth::UserRequest::Pointer rv;
     /* do we have a username ? */
     if (!username || username[0] == '\0') {
-        debugs(29, 2, HERE << "Empty or not present username");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Empty or not present username");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* Sanity check of the username.
      * " can not be allowed in usernames until * the digest helper protocol
      * have been redone
      */
     if (strchr(username, '"')) {
-        debugs(29, 2, HERE << "Unacceptable username '" << username << "'");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Unacceptable username '" << username << "'");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* do we have a realm ? */
     if (!digest_request->realm || digest_request->realm[0] == '\0') {
-        debugs(29, 2, HERE << "Empty or not present realm");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Empty or not present realm");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* and a nonce? */
     if (!digest_request->nonceb64 || digest_request->nonceb64[0] == '\0') {
-        debugs(29, 2, HERE << "Empty or not present nonce");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Empty or not present nonce");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* we can't check the URI just yet. We'll check it in the
      * authenticate phase, but needs to be given */
     if (!digest_request->uri || digest_request->uri[0] == '\0') {
-        debugs(29, 2, HERE << "Missing URI field");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Missing URI field");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* is the response the correct length? */
     if (!digest_request->response || strlen(digest_request->response) != 32) {
-        debugs(29, 2, HERE << "Response length invalid");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Response length invalid");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* check the algorithm is present and supported */
     if (!digest_request->algorithm)
         digest_request->algorithm = xstrndup("MD5", 4);
     else if (strcmp(digest_request->algorithm, "MD5")
              && strcmp(digest_request->algorithm, "MD5-sess")) {
-        debugs(29, 2, HERE << "invalid algorithm specified!");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "invalid algorithm specified!");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* 2617 requirements, indicated by qop */
@@ -987,26 +1002,34 @@ Auth::Digest::Config::decode(char const *proxy_auth)
         /* check the qop is what we expected. */
         if (strcmp(digest_request->qop, QOP_AUTH) != 0) {
             /* we received a qop option we didn't send */
-            debugs(29, 2, HERE << "Invalid qop option received");
-            return authDigestLogUsername(username, digest_request);
+            debugs(29, 2, "Invalid qop option received");
+            rv = authDigestLogUsername(username, digest_request);
+            safe_free(username);
+            return rv;
         }
 
         /* check cnonce */
         if (!digest_request->cnonce || digest_request->cnonce[0] == '\0') {
-            debugs(29, 2, HERE << "Missing cnonce field");
-            return authDigestLogUsername(username, digest_request);
+            debugs(29, 2, "Missing cnonce field");
+            rv = authDigestLogUsername(username, digest_request);
+            safe_free(username);
+            return rv;
         }
 
         /* check nc */
         if (strlen(digest_request->nc) != 8 || strspn(digest_request->nc, "0123456789abcdefABCDEF") != 8) {
-            debugs(29, 2, HERE << "invalid nonce count");
-            return authDigestLogUsername(username, digest_request);
+            debugs(29, 2, "invalid nonce count");
+            rv = authDigestLogUsername(username, digest_request);
+            safe_free(username);
+            return rv;
         }
     } else {
         /* cnonce and nc both require qop */
-        if (digest_request->cnonce || digest_request->nc) {
-            debugs(29, 2, HERE << "missing qop!");
-            return authDigestLogUsername(username, digest_request);
+        if (digest_request->cnonce || digest_request->nc[0] != '\0') {
+            debugs(29, 2, "missing qop!");
+            rv = authDigestLogUsername(username, digest_request);
+            safe_free(username);
+            return rv;
         }
     }
 
@@ -1016,19 +1039,23 @@ Auth::Digest::Config::decode(char const *proxy_auth)
     nonce = authenticateDigestNonceFindNonce(digest_request->nonceb64);
     if (!nonce) {
         /* we couldn't find a matching nonce! */
-        debugs(29, 2, HERE << "Unexpected or invalid nonce received");
+        debugs(29, 2, "Unexpected or invalid nonce received");
         if (digest_request->user() != NULL)
             digest_request->user()->credentials(Auth::Failed);
-        return authDigestLogUsername(username, digest_request);
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     digest_request->nonce = nonce;
     authDigestNonceLink(nonce);
 
     /* check that we're not being hacked / the username hasn't changed */
     if (nonce->user && strcmp(username, nonce->user->username())) {
-        debugs(29, 2, HERE << "Username for the nonce does not equal the username for the request");
-        return authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Username for the nonce does not equal the username for the request");
+        rv = authDigestLogUsername(username, digest_request);
+        safe_free(username);
+        return rv;
     }
 
     /* the method we'll check at the authenticate step as well */
@@ -45,8 +45,8 @@ struct _digest_nonce_h : public hash_link {
     /* has this nonce been invalidated ? */
 
     struct {
-        unsigned int valid:1;
-        unsigned int incache:1;
+        bool valid;
+        bool incache;
     } flags;
 };
 
@@ -266,7 +266,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.mustKeepalive = 1;
+        lm_request->request->flags.mustKeepalive = true;
         if (lm_request->request->flags.proxyKeepalive) {
             Note::Pointer tokenNote = reply.notes.find("token");
             lm_request->server_blob = xstrdup(tokenNote->firstValue());
@@ -329,17 +329,16 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     case HelperReply::Error: {
         Note::Pointer messageNote = reply.notes.find("message");
         Note::Pointer tokenNote = reply.notes.find("token");
-        if (tokenNote == NULL) {
-            /* protocol error */
-            fatalf("authenticateNegotiateHandleReply: *** Unsupported helper response ***, '%s'\n", reply.other().content());
-            break;
-        }
 
         /* authentication failure (wrong password, etc.) */
-        auth_user_request->denyMessage(messageNote->firstValue());
+        if (messageNote != NULL)
+            auth_user_request->denyMessage(messageNote->firstValue());
+        else
+            auth_user_request->denyMessage("Negotiate Authentication denied with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
-        lm_request->server_blob = xstrdup(tokenNote->firstValue());
+        if (tokenNote != NULL)
+            lm_request->server_blob = xstrdup(tokenNote->firstValue());
         lm_request->releaseAuthServer();
         debugs(29, 4, HERE << "Failed validating user via Negotiate. Error returned '" << reply << "'");
     }
@@ -386,8 +385,8 @@ Auth::Negotiate::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int a
         return;
 
     /* don't add to authentication error pages */
-    if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
@@ -65,9 +65,6 @@ statefulhelper *negotiateauthenticators = NULL;
 /// \ingroup AuthNegotiateInternal
 static int authnegotiate_initialised = 0;
 
-/// \ingroup AuthNegotiateInternal
-Auth::Negotiate::Config negotiateConfig;
-
 /// \ingroup AuthNegotiateInternal
 static hash_table *proxy_auth_cache = NULL;
 
@@ -132,16 +129,16 @@ Auth::Negotiate::Config::Config() : keep_alive(1)
 void
 Auth::Negotiate::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param negotiate program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "keep_alive") == 0) {
+    } else if (strcmp(param_str, "keep_alive") == 0) {
         parse_onoff(&keep_alive);
     } else {
         debugs(29, DBG_CRITICAL, "ERROR: unrecognised Negotiate auth scheme parameter '" << param_str << "'");
@@ -229,7 +226,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         if (!keep_alive) {
             /* drop the connection */
             rep->header.delByName("keep-alive");
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
         }
     } else {
         Auth::Negotiate::UserRequest *negotiate_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
@@ -241,7 +238,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
             rep->header.delByName("keep-alive");
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
             /* fall through */
 
         case Auth::Ok:
@@ -292,7 +289,7 @@ authenticateNegotiateStats(StoreEntry * sentry)
 Auth::UserRequest::Pointer
 Auth::Negotiate::Config::decode(char const *proxy_auth)
 {
-    Auth::Negotiate::User *newUser = new Auth::Negotiate::User(&negotiateConfig);
+    Auth::Negotiate::User *newUser = new Auth::Negotiate::User(Auth::Config::Find("negotiate"));
     Auth::UserRequest *auth_user_request = new Auth::Negotiate::UserRequest();
     assert(auth_user_request->user() == NULL);
 
@@ -259,7 +259,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
     case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.mustKeepalive = 1;
+        lm_request->request->flags.mustKeepalive = true;
         if (lm_request->request->flags.proxyKeepalive) {
             Note::Pointer serverBlob = reply.notes.find("token");
             lm_request->server_blob = xstrdup(serverBlob->firstValue());
@@ -121,16 +121,16 @@ Auth::Ntlm::Config::Config() : keep_alive(1)
 void
 Auth::Ntlm::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param ntlm program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "keep_alive") == 0) {
+    } else if (strcmp(param_str, "keep_alive") == 0) {
         parse_onoff(&keep_alive);
     } else {
         debugs(29, DBG_CRITICAL, "ERROR unrecognised NTLM auth scheme parameter '" << param_str << "'");
@@ -215,7 +215,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
 
         if (!keep_alive) {
             /* drop the connection */
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
         }
     } else {
         Auth::Ntlm::UserRequest *ntlm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
@@ -226,7 +226,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         case Auth::Failed:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
             /* fall through */
 
         case Auth::Ok:
@@ -21,7 +21,8 @@ AsyncJob::Pointer AsyncJob::Start(AsyncJob *j)
     return job;
 }
 
-AsyncJob::AsyncJob(const char *aTypeName): typeName(aTypeName), inCall(NULL)
+AsyncJob::AsyncJob(const char *aTypeName) :
+        stopReason(NULL), typeName(aTypeName), inCall(NULL)
 {
     debugs(93,5, "AsyncJob constructed, this=" << this <<
            " type=" << typeName << " [" << id << ']');
@@ -0,0 +1,210 @@
+
+/*
+ */
+
+#ifndef SQUID_LRUMAP_H
+#define SQUID_LRUMAP_H
+
+#include "SquidTime.h"
+#if HAVE_LIST
+#include <list>
+#endif
+#if HAVE_MAP
+#include <map>
+#endif
+
+template <class EntryValue, size_t EntryCost = sizeof(EntryValue)> class LruMap
+{
+public:
+    class Entry
+    {
+    public:
+        Entry(const char *aKey, EntryValue *t): key(aKey), value(t), date(squid_curtime) {}
+        ~Entry() {delete value;}
+    private:
+        Entry(Entry &);
+        Entry & operator = (Entry &);
+    public:
+        std::string key; ///< the key of entry
+        EntryValue *value; ///< A pointer to the stored value
+        time_t date; ///< The date the entry created
+    };
+    typedef std::list<Entry *> Queue;
+    typedef typename std::list<Entry *>::iterator QueueIterator;
+
+    /// key:queue_item mapping for fast lookups by key
+    typedef std::map<std::string, QueueIterator> Map;
+    typedef typename Map::iterator MapIterator;
+    typedef std::pair<std::string, QueueIterator> MapPair;
+
+    LruMap(int ttl, size_t size);
+    ~LruMap();
+    /// Search for an entry, and return a pointer
+    EntryValue *get(const char *key);
+    /// Add an entry to the map
+    bool add(const char *key, EntryValue *t);
+    /// Delete an entry from the map
+    bool del(const char *key);
+    /// (Re-)set the maximum size for this map
+    void setMemLimit(size_t aSize);
+    /// The available size for the map
+    size_t memLimit() const {return memLimit_;}
+    /// The free space of the map
+    size_t freeMem() const { return (memLimit() - size());}
+    /// The current size of the map
+    size_t size() const {return (entries_ * EntryCost);}
+    /// The number of stored entries
+    int entries() const {return entries_;}
+private:
+    LruMap(LruMap const &);
+    LruMap & operator = (LruMap const &);
+
+    bool expired(Entry &e);
+    void trim();
+    void touch(const MapIterator &i);
+    bool del(const MapIterator &i);
+    void findEntry(const char *key, LruMap::MapIterator &i);
+
+    Map storage; ///< The Key/value * pairs
+    Queue index; ///< LRU cache index
+    int ttl;///< >0 ttl for caching, == 0 cache is disabled, < 0 store for ever
+    size_t memLimit_; ///< The maximum memory to use
+    int entries_; ///< The stored entries
+};
+
+template <class EntryValue, size_t EntryCost>
+LruMap<EntryValue, EntryCost>::LruMap(int aTtl, size_t aSize): entries_(0)
+{
+    ttl = aTtl;
+
+    setMemLimit(aSize);
+}
+
+template <class EntryValue, size_t EntryCost>
+LruMap<EntryValue, EntryCost>::~LruMap()
+{
+    for (QueueIterator i = index.begin(); i != index.end(); ++i) {
+        delete *i;
+    }
+}
+
+template <class EntryValue, size_t EntryCost>
+void
+LruMap<EntryValue, EntryCost>::setMemLimit(size_t aSize)
+{
+    if (aSize > 0)
+        memLimit_ = aSize;
+    else
+        memLimit_ = 0;
+}
+
+template <class EntryValue, size_t EntryCost>
+void
+LruMap<EntryValue, EntryCost>::findEntry(const char *key, LruMap::MapIterator &i)
+{
+    i = storage.find(key);
+    if (i == storage.end()) {
+        return;
+    }
+    index.push_front(*(i->second));
+    index.erase(i->second);
+    i->second = index.begin();
+
+    Entry *e = *i->second;
+
+    if (e && expired(*e)) {
+        del(i);
+        e = NULL;
+    }
+}
+
+template <class EntryValue, size_t EntryCost>
+EntryValue *
+LruMap<EntryValue, EntryCost>::get(const char *key)
+{
+    MapIterator i;
+    findEntry(key, i);
+    Entry *e = *i->second;
+    if (i != storage.end()) {
+        touch(i);
+        return e->value;
+    }
+    return NULL;
+}
+
+template <class EntryValue, size_t EntryCost>
+bool
+LruMap<EntryValue, EntryCost>::add(const char *key, EntryValue *t)
+{
+    if (ttl == 0)
+        return false;
+
+    del(key);
+    trim();
+    index.push_front(new Entry(key, t));
+    storage.insert(MapPair(key, index.begin()));
+
+    ++entries_;
+    return true;
+}
+
+template <class EntryValue, size_t EntryCost>
+bool
+LruMap<EntryValue, EntryCost>::expired(LruMap::Entry &entry)
+{
+    if (ttl < 0)
+        return false;
+
+    return (entry.date + ttl < squid_curtime);
+}
+
+template <class EntryValue, size_t EntryCost>
+bool
+LruMap<EntryValue, EntryCost>::del(LruMap::MapIterator const &i)
+{
+    if (i != storage.end()) {
+        delete *(i->second);
+        index.erase(i->second);
+        storage.erase(i);
+        --entries_;
+        return true;
+    }
+    return false;
+}
+
+template <class EntryValue, size_t EntryCost>
+bool
+LruMap<EntryValue, EntryCost>::del(const char *key)
+{
+    MapIterator i;
+    findEntry(key, i);
+    return del(i);
+}
+
+template <class EntryValue, size_t EntryCost>
+void
+LruMap<EntryValue, EntryCost>::trim()
+{
+    while (memLimit() > 0 && size() >= memLimit()) {
+        QueueIterator i = index.end();
+        --i;
+        if (i != index.end()) {
+            del((*i)->key.c_str());
+        }
+    }
+}
+
+template <class EntryValue, size_t EntryCost>
+void
+LruMap<EntryValue, EntryCost>::touch(LruMap::MapIterator const &i)
+{
+    // this must not be done when nothing is being cached.
+    if (ttl == 0)
+        return;
+
+    index.push_front(*(i->second));
+    index.erase(i->second);
+    i->second = index.begin();
+}
+
+#endif
@@ -16,6 +16,7 @@ libbase_la_SOURCES = \
 	CbcPointer.h \
 	InstanceId.h \
 	Lock.h \
+	LruMap.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
@@ -43,7 +43,7 @@
 /**
  * Template for Reference Counting pointers.
  *
- * Objects of type 'C' must inherit from 'Lockable' in base/Lock.h
+ * Objects of type 'C' must inherit from 'RefCountable' in base/Lock.h
  * which provides the locking interface used by reference counting.
  */
 template <class C>
@@ -277,16 +277,23 @@ self_destruct(void)
 static void
 update_maxobjsize(void)
 {
-    int i;
     int64_t ms = -1;
 
-    for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
+    // determine the maximum size object that can be stored to disk
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         assert (Config.cacheSwap.swapDirs[i].getRaw());
 
-        if (dynamic_cast<SwapDir *>(Config.cacheSwap.swapDirs[i].getRaw())->
-                max_objsize > ms)
-            ms = dynamic_cast<SwapDir *>(Config.cacheSwap.swapDirs[i].getRaw())->max_objsize;
+        const int64_t storeMax = dynamic_cast<SwapDir *>(Config.cacheSwap.swapDirs[i].getRaw())->maxObjectSize();
+        if (ms < storeMax)
+            ms = storeMax;
     }
+
+    // Ensure that we do not discard objects which could be stored only in memory.
+    // It is governed by maximum_object_size_in_memory (for now)
+    // TODO: update this to check each in-memory location (SMP and local memory limits differ)
+    if (ms < static_cast<int64_t>(Config.Store.maxInMemObjSize))
+        ms = Config.Store.maxInMemObjSize;
+
     store_maxobjsize = ms;
 }
 
@@ -679,7 +686,7 @@ configDoConfigure(void)
 
     if (Config.Announce.period > 0) {
         Config.onoff.announce = 1;
-    } else if (Config.Announce.period < 1) {
+    } else {
         Config.Announce.period = 86400 * 365;	/* one year */
         Config.onoff.announce = 0;
     }
@@ -701,6 +708,13 @@ configDoConfigure(void)
         }
     }
 
+    if (Config.Program.store_id) {
+        if (Config.storeIdChildren.n_max < 1) {
+            Config.storeIdChildren.n_max = 0;
+            wordlistDestroy(&Config.Program.store_id);
+        }
+    }
+
     if (Config.appendDomain)
         if (*Config.appendDomain != '.')
             fatal("append_domain must begin with a '.'");
@@ -763,6 +777,9 @@ configDoConfigure(void)
     if (Config.Program.redirect)
         requirePathnameExists("redirect_program", Config.Program.redirect->key);
 
+    if (Config.Program.store_id)
+        requirePathnameExists("store_id_program", Config.Program.store_id->key);
+
     requirePathnameExists("Icon Directory", Config.icons.directory);
 
     if (Config.errorDirectory)
@@ -928,7 +945,7 @@ configDoConfigure(void)
     }
 
     for (AnyP::PortCfg *s = Config.Sockaddr.http; s != NULL; s = s->next) {
-        if (!s->sslBump)
+        if (!s->flags.tunnelSslBumping)
             continue;
 
         debugs(3, DBG_IMPORTANT, "Initializing http_port " << s->s << " SSL context");
@@ -1017,6 +1034,12 @@ parseTimeLine(time_msec_t * tptr, const char *units,  bool allowMsec)
         self_destruct();
 
     *tptr = static_cast<time_msec_t>(m * d);
+
+    if (static_cast<double>(*tptr) * 2 != m * d * 2) {
+        debugs(3, DBG_CRITICAL, "ERROR: Invalid value '" <<
+               d << " " << token << ": integer overflow (time_msec_t).");
+        self_destruct();
+    }
 }
 
 static uint64_t
@@ -1097,8 +1120,11 @@ parseBytesLine64(int64_t * bptr, const char *units)
 
     *bptr = static_cast<int64_t>(m * d / u);
 
-    if (static_cast<double>(*bptr) * 2 != m * d / u * 2)
+    if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2) {
+        debugs(3, DBG_CRITICAL, "ERROR: Invalid value '" <<
+               d << " " << token << ": integer overflow (int64_t).");
         self_destruct();
+    }
 }
 
 static void
@@ -1141,8 +1167,11 @@ parseBytesLine(size_t * bptr, const char *units)
 
     *bptr = static_cast<size_t>(m * d / u);
 
-    if (static_cast<double>(*bptr) * 2 != m * d / u * 2)
+    if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2) {
+        debugs(3, DBG_CRITICAL, "ERROR: Invalid value '" <<
+               d << " " << token << ": integer overflow (size_t).");
         self_destruct();
+    }
 }
 
 #if !USE_DNSHELPER
@@ -1184,10 +1213,13 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
         return;
     }
 
-    *bptr = static_cast<size_t>(m * d / u);
+    *bptr = static_cast<ssize_t>(m * d / u);
 
-    if (static_cast<double>(*bptr) * 2 != m * d / u * 2)
+    if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2) {
+        debugs(3, DBG_CRITICAL, "ERROR: Invalid value '" <<
+               d << " " << token << ": integer overflow (ssize_t).");
         self_destruct();
+    }
 }
 #endif
 
@@ -1224,7 +1256,7 @@ static void parseBytesOptionValue(size_t * bptr, const char *units, char const *
     }
 
     *bptr = static_cast<size_t>(m * d / u);
-    if (static_cast<double>(*bptr) * 2 != m * d / u * 2)
+    if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2)
         self_destruct();
 }
 #endif
@@ -1261,10 +1293,11 @@ dump_acl(StoreEntry * entry, const char *name, ACL * ae)
 
     while (ae != NULL) {
         debugs(3, 3, "dump_acl: " << name << " " << ae->name);
-        storeAppendPrintf(entry, "%s %s %s ",
+        storeAppendPrintf(entry, "%s %s %s %s ",
                           name,
                           ae->name,
-                          ae->typeString());
+                          ae->typeString(),
+                          ae->flags.flagsStr());
         v = w = ae->dump();
 
         while (v != NULL) {
@@ -2092,8 +2125,8 @@ parse_peer(CachePeer ** head)
     p->type = parseNeighborType(token);
 
     if (p->type == PEER_MULTICAST) {
-        p->options.no_digest = 1;
-        p->options.no_netdb_exchange = 1;
+        p->options.no_digest = true;
+        p->options.no_netdb_exchange = true;
     }
 
     p->http_port = GetTcpService();
@@ -2105,48 +2138,48 @@ parse_peer(CachePeer ** head)
     p->connection_auth = 2;    /* auto */
 
     while ((token = strtok(NULL, w_space))) {
-        if (!strcasecmp(token, "proxy-only")) {
-            p->options.proxy_only = 1;
-        } else if (!strcasecmp(token, "no-query")) {
-            p->options.no_query = 1;
-        } else if (!strcasecmp(token, "background-ping")) {
-            p->options.background_ping = 1;
-        } else if (!strcasecmp(token, "no-digest")) {
-            p->options.no_digest = 1;
-        } else if (!strcasecmp(token, "no-tproxy")) {
-            p->options.no_tproxy = 1;
-        } else if (!strcasecmp(token, "multicast-responder")) {
-            p->options.mcast_responder = 1;
+        if (!strcmp(token, "proxy-only")) {
+            p->options.proxy_only = true;
+        } else if (!strcmp(token, "no-query")) {
+            p->options.no_query = true;
+        } else if (!strcmp(token, "background-ping")) {
+            p->options.background_ping = true;
+        } else if (!strcmp(token, "no-digest")) {
+            p->options.no_digest = true;
+        } else if (!strcmp(token, "no-tproxy")) {
+            p->options.no_tproxy = true;
+        } else if (!strcmp(token, "multicast-responder")) {
+            p->options.mcast_responder = true;
 #if PEER_MULTICAST_SIBLINGS
-        } else if (!strcasecmp(token, "multicast-siblings")) {
-            p->options.mcast_siblings = 1;
+        } else if (!strcmp(token, "multicast-siblings")) {
+            p->options.mcast_siblings = true;
 #endif
-        } else if (!strncasecmp(token, "weight=", 7)) {
+        } else if (!strncmp(token, "weight=", 7)) {
             p->weight = xatoi(token + 7);
-        } else if (!strncasecmp(token, "basetime=", 9)) {
+        } else if (!strncmp(token, "basetime=", 9)) {
             p->basetime = xatoi(token + 9);
-        } else if (!strcasecmp(token, "closest-only")) {
-            p->options.closest_only = 1;
-        } else if (!strncasecmp(token, "ttl=", 4)) {
+        } else if (!strcmp(token, "closest-only")) {
+            p->options.closest_only = true;
+        } else if (!strncmp(token, "ttl=", 4)) {
             p->mcast.ttl = xatoi(token + 4);
 
             if (p->mcast.ttl < 0)
                 p->mcast.ttl = 0;
 
             if (p->mcast.ttl > 128)
                 p->mcast.ttl = 128;
-        } else if (!strcasecmp(token, "default")) {
-            p->options.default_parent = 1;
-        } else if (!strcasecmp(token, "round-robin")) {
-            p->options.roundrobin = 1;
-        } else if (!strcasecmp(token, "weighted-round-robin")) {
-            p->options.weighted_roundrobin = 1;
+        } else if (!strcmp(token, "default")) {
+            p->options.default_parent = true;
+        } else if (!strcmp(token, "round-robin")) {
+            p->options.roundrobin = true;
+        } else if (!strcmp(token, "weighted-round-robin")) {
+            p->options.weighted_roundrobin = true;
 #if USE_HTCP
-        } else if (!strcasecmp(token, "htcp")) {
-            p->options.htcp = 1;
-        } else if (!strncasecmp(token, "htcp=", 5) || !strncasecmp(token, "htcp-", 5)) {
+        } else if (!strcmp(token, "htcp")) {
+            p->options.htcp = true;
+        } else if (!strncmp(token, "htcp=", 5) || !strncmp(token, "htcp-", 5)) {
             /* Note: The htcp- form is deprecated, replaced by htcp= */
-            p->options.htcp = 1;
+            p->options.htcp = true;
             char *tmp = xstrdup(token+5);
             char *mode, *nextmode;
             for (mode = nextmode = tmp; mode; mode = nextmode) {
@@ -2155,101 +2188,101 @@ parse_peer(CachePeer ** head)
                     *nextmode = '\0';
                     ++nextmode;
                 }
-                if (!strcasecmp(mode, "no-clr")) {
+                if (!strcmp(mode, "no-clr")) {
                     if (p->options.htcp_only_clr)
                         fatalf("parse_peer: can't set htcp-no-clr and htcp-only-clr simultaneously");
-                    p->options.htcp_no_clr = 1;
-                } else if (!strcasecmp(mode, "no-purge-clr")) {
-                    p->options.htcp_no_purge_clr = 1;
-                } else if (!strcasecmp(mode, "only-clr")) {
+                    p->options.htcp_no_clr = true;
+                } else if (!strcmp(mode, "no-purge-clr")) {
+                    p->options.htcp_no_purge_clr = true;
+                } else if (!strcmp(mode, "only-clr")) {
                     if (p->options.htcp_no_clr)
                         fatalf("parse_peer: can't set htcp no-clr and only-clr simultaneously");
-                    p->options.htcp_only_clr = 1;
-                } else if (!strcasecmp(mode, "forward-clr")) {
-                    p->options.htcp_forward_clr = 1;
-                } else if (!strcasecmp(mode, "oldsquid")) {
-                    p->options.htcp_oldsquid = 1;
+                    p->options.htcp_only_clr = true;
+                } else if (!strcmp(mode, "forward-clr")) {
+                    p->options.htcp_forward_clr = true;
+                } else if (!strcmp(mode, "oldsquid")) {
+                    p->options.htcp_oldsquid = true;
                 } else {
                     fatalf("invalid HTCP mode '%s'", mode);
                 }
             }
             safe_free(tmp);
 #endif
-        } else if (!strcasecmp(token, "no-netdb-exchange")) {
-            p->options.no_netdb_exchange = 1;
+        } else if (!strcmp(token, "no-netdb-exchange")) {
+            p->options.no_netdb_exchange = true;
 
-        } else if (!strcasecmp(token, "carp")) {
+        } else if (!strcmp(token, "carp")) {
             if (p->type != PEER_PARENT)
                 fatalf("parse_peer: non-parent carp peer %s/%d\n", p->host, p->http_port);
 
-            p->options.carp = 1;
-        } else if (!strncasecmp(token, "carp-key=", 9)) {
-            if (p->options.carp != 1)
+            p->options.carp = true;
+        } else if (!strncmp(token, "carp-key=", 9)) {
+            if (p->options.carp != true)
                 fatalf("parse_peer: carp-key specified on non-carp peer %s/%d\n", p->host, p->http_port);
-            p->options.carp_key.set=1;
+            p->options.carp_key.set = true;
             char *nextkey=token+strlen("carp-key="), *key=nextkey;
             for (; key; key = nextkey) {
                 nextkey=strchr(key,',');
                 if (nextkey) ++nextkey; // skip the comma, any
-                if (0==strncasecmp(key,"scheme",6)) {
-                    p->options.carp_key.scheme=1;
-                } else if (0==strncasecmp(key,"host",4)) {
-                    p->options.carp_key.host=1;
-                } else if (0==strncasecmp(key,"port",4)) {
-                    p->options.carp_key.port=1;
-                } else if (0==strncasecmp(key,"path",4)) {
-                    p->options.carp_key.path=1;
-                } else if (0==strncasecmp(key,"params",6)) {
-                    p->options.carp_key.params=1;
+                if (0==strncmp(key,"scheme",6)) {
+                    p->options.carp_key.scheme = true;
+                } else if (0==strncmp(key,"host",4)) {
+                    p->options.carp_key.host = true;
+                } else if (0==strncmp(key,"port",4)) {
+                    p->options.carp_key.port = true;
+                } else if (0==strncmp(key,"path",4)) {
+                    p->options.carp_key.path = true;
+                } else if (0==strncmp(key,"params",6)) {
+                    p->options.carp_key.params = true;
                 } else {
                     fatalf("invalid carp-key '%s'",key);
                 }
             }
-        } else if (!strcasecmp(token, "userhash")) {
+        } else if (!strcmp(token, "userhash")) {
 #if USE_AUTH
             if (p->type != PEER_PARENT)
                 fatalf("parse_peer: non-parent userhash peer %s/%d\n", p->host, p->http_port);
 
-            p->options.userhash = 1;
+            p->options.userhash = true;
 #else
             fatalf("parse_peer: userhash requires authentication. peer %s/%d\n", p->host, p->http_port);
 #endif
-        } else if (!strcasecmp(token, "sourcehash")) {
+        } else if (!strcmp(token, "sourcehash")) {
             if (p->type != PEER_PARENT)
                 fatalf("parse_peer: non-parent sourcehash peer %s/%d\n", p->host, p->http_port);
 
-            p->options.sourcehash = 1;
+            p->options.sourcehash = true;
 
-        } else if (!strcasecmp(token, "no-delay")) {
+        } else if (!strcmp(token, "no-delay")) {
 #if USE_DELAY_POOLS
-            p->options.no_delay = 1;
+            p->options.no_delay = true;
 #else
             debugs(0, DBG_CRITICAL, "WARNING: cache_peer option 'no-delay' requires --enable-delay-pools");
 #endif
-        } else if (!strncasecmp(token, "login=", 6)) {
+        } else if (!strncmp(token, "login=", 6)) {
             p->login = xstrdup(token + 6);
             rfc1738_unescape(p->login);
-        } else if (!strncasecmp(token, "connect-timeout=", 16)) {
+        } else if (!strncmp(token, "connect-timeout=", 16)) {
             p->connect_timeout = xatoi(token + 16);
-        } else if (!strncasecmp(token, "connect-fail-limit=", 19)) {
+        } else if (!strncmp(token, "connect-fail-limit=", 19)) {
             p->connect_fail_limit = xatoi(token + 19);
 #if USE_CACHE_DIGESTS
-        } else if (!strncasecmp(token, "digest-url=", 11)) {
+        } else if (!strncmp(token, "digest-url=", 11)) {
             p->digest_url = xstrdup(token + 11);
 #endif
 
-        } else if (!strcasecmp(token, "allow-miss")) {
-            p->options.allow_miss = 1;
-        } else if (!strncasecmp(token, "max-conn=", 9)) {
+        } else if (!strcmp(token, "allow-miss")) {
+            p->options.allow_miss = true;
+        } else if (!strncmp(token, "max-conn=", 9)) {
             p->max_conn = xatoi(token + 9);
-        } else if (!strcasecmp(token, "originserver")) {
-            p->options.originserver = 1;
-        } else if (!strncasecmp(token, "name=", 5)) {
+        } else if (!strcmp(token, "originserver")) {
+            p->options.originserver = true;
+        } else if (!strncmp(token, "name=", 5)) {
             safe_free(p->name);
 
             if (token[5])
                 p->name = xstrdup(token + 5);
-        } else if (!strncasecmp(token, "forceddomain=", 13)) {
+        } else if (!strncmp(token, "forceddomain=", 13)) {
             safe_free(p->domain);
 
             if (token[13])
@@ -2266,7 +2299,7 @@ parse_peer(CachePeer ** head)
             safe_free(p->sslkey);
             p->sslkey = xstrdup(token + 7);
         } else if (strncmp(token, "sslversion=", 11) == 0) {
-            p->sslversion = atoi(token + 11);
+            p->sslversion = xatoi(token + 11);
         } else if (strncmp(token, "ssloptions=", 11) == 0) {
             safe_free(p->ssloptions);
             p->ssloptions = xstrdup(token + 11);
@@ -2281,7 +2314,7 @@ parse_peer(CachePeer ** head)
             p->sslcapath = xstrdup(token + 10);
         } else if (strncmp(token, "sslcrlfile=", 11) == 0) {
             safe_free(p->sslcrlfile);
-            p->sslcapath = xstrdup(token + 10);
+            p->sslcrlfile = xstrdup(token + 11);
         } else if (strncmp(token, "sslflags=", 9) == 0) {
             safe_free(p->sslflags);
             p->sslflags = xstrdup(token + 9);
@@ -2597,10 +2630,20 @@ parse_onoff(int *var)
     if (token == NULL)
         self_destruct();
 
-    if (!strcasecmp(token, "on") || !strcasecmp(token, "enable"))
+    if (!strcmp(token, "on")) {
         *var = 1;
-    else
+    } else if (!strcmp(token, "enable")) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'enable' is deprecated. Please update to use 'on'.");
+        *var = 1;
+    } else if (!strcmp(token, "off")) {
         *var = 0;
+    } else if (!strcmp(token, "disable")) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'disable' is deprecated. Please update to use 'off'.");
+        *var = 0;
+    } else {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid option: Boolean options can only be 'on' or 'off'.");
+        self_destruct();
+    }
 }
 
 #define free_onoff free_int
@@ -2628,12 +2671,22 @@ parse_tristate(int *var)
     if (token == NULL)
         self_destruct();
 
-    if (!strcasecmp(token, "on") || !strcasecmp(token, "enable"))
+    if (!strcmp(token, "on")) {
+        *var = 1;
+    } else if (!strcmp(token, "enable")) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'enable' is deprecated. Please update to use value 'on'.");
         *var = 1;
-    else if (!strcasecmp(token, "warn"))
+    } else if (!strcmp(token, "warn")) {
         *var = -1;
-    else
+    } else if (!strcmp(token, "off")) {
+        *var = 0;
+    } else if (!strcmp(token, "disable")) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'disable' is deprecated. Please update to use value 'off'.");
         *var = 0;
+    } else {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid option: Tristate options can only be 'on', 'off', or 'warn'.");
+        self_destruct();
+    }
 }
 
 #define free_tristate free_int
@@ -2757,7 +2810,7 @@ parse_refreshpattern(RefreshPattern ** head)
 
     min = (time_t) (i * 60);	/* convert minutes to seconds */
 
-    i = GetInteger();		/* token: pct */
+    i = GetPercentage();	/* token: pct */
 
     pct = (double) i / 100.0;
 
@@ -2782,7 +2835,7 @@ parse_refreshpattern(RefreshPattern ** head)
         } else if (!strcmp(token, "store-stale")) {
             store_stale = 1;
         } else if (!strncmp(token, "max-stale=", 10)) {
-            max_stale = atoi(token + 10);
+            max_stale = xatoi(token + 10);
 #if USE_HTTP_VIOLATIONS
 
         } else if (!strcmp(token, "override-expire"))
@@ -2831,41 +2884,41 @@ parse_refreshpattern(RefreshPattern ** head)
     t->max = max;
 
     if (flags & REG_ICASE)
-        t->flags.icase = 1;
+        t->flags.icase = true;
 
     if (refresh_ims)
-        t->flags.refresh_ims = 1;
+        t->flags.refresh_ims = true;
 
     if (store_stale)
-        t->flags.store_stale = 1;
+        t->flags.store_stale = true;
 
     t->max_stale = max_stale;
 
 #if USE_HTTP_VIOLATIONS
 
     if (override_expire)
-        t->flags.override_expire = 1;
+        t->flags.override_expire = true;
 
     if (override_lastmod)
-        t->flags.override_lastmod = 1;
+        t->flags.override_lastmod = true;
 
     if (reload_into_ims)
-        t->flags.reload_into_ims = 1;
+        t->flags.reload_into_ims = true;
 
     if (ignore_reload)
-        t->flags.ignore_reload = 1;
+        t->flags.ignore_reload = true;
 
     if (ignore_no_store)
-        t->flags.ignore_no_store = 1;
+        t->flags.ignore_no_store = true;
 
     if (ignore_must_revalidate)
-        t->flags.ignore_must_revalidate = 1;
+        t->flags.ignore_must_revalidate = true;
 
     if (ignore_private)
-        t->flags.ignore_private = 1;
+        t->flags.ignore_private = true;
 
     if (ignore_auth)
-        t->flags.ignore_auth = 1;
+        t->flags.ignore_auth = true;
 
 #endif
 
@@ -3213,18 +3266,20 @@ parse_uri_whitespace(int *var)
     if (token == NULL)
         self_destruct();
 
-    if (!strcasecmp(token, "strip"))
+    if (!strcmp(token, "strip"))
         *var = URI_WHITESPACE_STRIP;
-    else if (!strcasecmp(token, "deny"))
+    else if (!strcmp(token, "deny"))
         *var = URI_WHITESPACE_DENY;
-    else if (!strcasecmp(token, "allow"))
+    else if (!strcmp(token, "allow"))
         *var = URI_WHITESPACE_ALLOW;
-    else if (!strcasecmp(token, "encode"))
+    else if (!strcmp(token, "encode"))
         *var = URI_WHITESPACE_ENCODE;
-    else if (!strcasecmp(token, "chop"))
+    else if (!strcmp(token, "chop"))
         *var = URI_WHITESPACE_CHOP;
-    else
+    else {
+        debugs(0, DBG_PARSE_NOTE(2), "ERROR: Invalid option '" << token << "': 'uri_whitespace' accepts 'strip', 'deny', 'allow', 'encode', and 'chop'.");
         self_destruct();
+    }
 }
 
 static void
@@ -3335,8 +3390,10 @@ parse_memcachemode(SquidConfig * config)
     } else if (strcmp(token, "never") == 0) {
         Config.onoff.memory_cache_first = 0;
         Config.onoff.memory_cache_disk = 0;
-    } else
+    } else {
+        debugs(0, DBG_PARSE_NOTE(2), "ERROR: Invalid option '" << token << "': 'memory_cache_mode' accepts 'always', 'disk', 'network', and 'never'.");
         self_destruct();
+    }
 }
 
 static void
@@ -3359,19 +3416,19 @@ dump_memcachemode(StoreEntry * entry, const char *name, SquidConfig &config)
 peer_t
 parseNeighborType(const char *s)
 {
-    if (!strcasecmp(s, "parent"))
+    if (!strcmp(s, "parent"))
         return PEER_PARENT;
 
-    if (!strcasecmp(s, "neighbor"))
+    if (!strcmp(s, "neighbor"))
         return PEER_SIBLING;
 
-    if (!strcasecmp(s, "neighbour"))
+    if (!strcmp(s, "neighbour"))
         return PEER_SIBLING;
 
-    if (!strcasecmp(s, "sibling"))
+    if (!strcmp(s, "sibling"))
         return PEER_SIBLING;
 
-    if (!strcasecmp(s, "multicast"))
+    if (!strcmp(s, "multicast"))
         return PEER_MULTICAST;
 
     debugs(15, DBG_CRITICAL, "WARNING: Unknown neighbor type: " << s);
@@ -3473,8 +3530,8 @@ parsePortSpecification(AnyP::PortCfg * s, char *token)
         *t = '\0';
         port = xatos(t + 1);
 
-    } else if ((port = strtol(token, &junk, 10)), !*junk) {
-        /* port */
+    } else if (strtol(token, &junk, 10) && !*junk) {
+        port = xatos(token);
         debugs(3, 3, s->protocol << "_port: found Listen on Port: " << port);
     } else {
         debugs(3, DBG_CRITICAL, s->protocol << "_port: missing Port: " << token);
@@ -3516,17 +3573,18 @@ parse_port_option(AnyP::PortCfg * s, char *token)
     /* modes first */
 
     if (strcmp(token, "accel") == 0) {
-        if (s->intercepted || s->spoof_client_ip) {
+        if (s->flags.isIntercepted()) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: Accelerator mode requires its own port. It cannot be shared with other modes.");
             self_destruct();
         }
-        s->accel = s->vhost = 1;
+        s->flags.accelSurrogate = true;
+        s->vhost = true;
     } else if (strcmp(token, "transparent") == 0 || strcmp(token, "intercept") == 0) {
-        if (s->accel || s->spoof_client_ip) {
+        if (s->flags.accelSurrogate || s->flags.tproxyIntercept) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: Intercept mode requires its own interception port. It cannot be shared with other modes.");
             self_destruct();
         }
-        s->intercepted = 1;
+        s->flags.natIntercept = true;
         Ip::Interceptor.StartInterception();
         /* Log information regarding the port modes under interception. */
         debugs(3, DBG_IMPORTANT, "Starting Authentication on port " << s->s);
@@ -3540,11 +3598,11 @@ parse_port_option(AnyP::PortCfg * s, char *token)
             self_destruct();
         }
     } else if (strcmp(token, "tproxy") == 0) {
-        if (s->intercepted || s->accel) {
+        if (s->flags.natIntercept || s->flags.accelSurrogate) {
             debugs(3,DBG_CRITICAL, "FATAL: http(s)_port: TPROXY option requires its own interception port. It cannot be shared with other modes.");
             self_destruct();
         }
-        s->spoof_client_ip = 1;
+        s->flags.tproxyIntercept = true;
         Ip::Interceptor.StartTransparency();
         /* Log information regarding the port modes under transparency. */
         debugs(3, DBG_IMPORTANT, "Starting IP Spoofing on port " << s->s);
@@ -3556,59 +3614,60 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         }
 
     } else if (strncmp(token, "defaultsite=", 12) == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: defaultsite option requires Acceleration mode flag.");
             self_destruct();
         }
         safe_free(s->defaultsite);
         s->defaultsite = xstrdup(token + 12);
     } else if (strcmp(token, "vhost") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "WARNING: http(s)_port: vhost option is deprecated. Use 'accel' mode flag instead.");
         }
-        s->accel = s->vhost = 1;
+        s->flags.accelSurrogate = true;
+        s->vhost = true;
     } else if (strcmp(token, "no-vhost") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_IMPORTANT, "ERROR: http(s)_port: no-vhost option requires Acceleration mode flag.");
         }
-        s->vhost = 0;
+        s->vhost = false;
     } else if (strcmp(token, "vport") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: vport option requires Acceleration mode flag.");
             self_destruct();
         }
         s->vport = -1;
     } else if (strncmp(token, "vport=", 6) == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: vport option requires Acceleration mode flag.");
             self_destruct();
         }
         s->vport = xatos(token + 6);
     } else if (strncmp(token, "protocol=", 9) == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: protocol option requires Acceleration mode flag.");
             self_destruct();
         }
         s->protocol = xstrdup(token + 9);
     } else if (strcmp(token, "allow-direct") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: allow-direct option requires Acceleration mode flag.");
             self_destruct();
         }
-        s->allow_direct = 1;
+        s->allow_direct = true;
     } else if (strcmp(token, "act-as-origin") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_IMPORTANT, "ERROR: http(s)_port: act-as-origin option requires Acceleration mode flag.");
         } else
-            s->actAsOrigin = 1;
+            s->actAsOrigin = true;
     } else if (strcmp(token, "ignore-cc") == 0) {
 #if !USE_HTTP_VIOLATIONS
-        if (!s->accel) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: ignore-cc option requires Scceleration mode flag.");
+        if (!s->flags.accelSurrogate) {
+            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: ignore-cc option requires Acceleration mode flag.");
             self_destruct();
         }
 #endif
-        s->ignore_cc = 1;
+        s->ignore_cc = true;
     } else if (strncmp(token, "name=", 5) == 0) {
         safe_free(s->name);
         s->name = xstrdup(token + 5);
@@ -3621,11 +3680,11 @@ parse_port_option(AnyP::PortCfg * s, char *token)
     } else if (strcmp(token, "connection-auth=on") == 0) {
         s->connection_auth_disabled = false;
     } else if (strncmp(token, "disable-pmtu-discovery=", 23) == 0) {
-        if (!strcasecmp(token + 23, "off"))
+        if (!strcmp(token + 23, "off"))
             s->disable_pmtu_discovery = DISABLE_PMTU_OFF;
-        else if (!strcasecmp(token + 23, "transparent"))
+        else if (!strcmp(token + 23, "transparent"))
             s->disable_pmtu_discovery = DISABLE_PMTU_TRANSPARENT;
-        else if (!strcasecmp(token + 23, "always"))
+        else if (!strcmp(token + 23, "always"))
             s->disable_pmtu_discovery = DISABLE_PMTU_ALWAYS;
         else
             self_destruct();
@@ -3635,29 +3694,29 @@ parse_port_option(AnyP::PortCfg * s, char *token)
             self_destruct();
         }
     } else if (strcmp(token, "tcpkeepalive") == 0) {
-        s->tcp_keepalive.enabled = 1;
+        s->tcp_keepalive.enabled = true;
     } else if (strncmp(token, "tcpkeepalive=", 13) == 0) {
         char *t = token + 13;
-        s->tcp_keepalive.enabled = 1;
-        s->tcp_keepalive.idle = atoi(t);
+        s->tcp_keepalive.enabled = true;
+        s->tcp_keepalive.idle = xatoui(t);
         t = strchr(t, ',');
         if (t) {
             ++t;
-            s->tcp_keepalive.interval = atoi(t);
+            s->tcp_keepalive.interval = xatoui(t);
             t = strchr(t, ',');
         }
         if (t) {
             ++t;
-            s->tcp_keepalive.timeout = atoi(t);
+            s->tcp_keepalive.timeout = xatoui(t);
             // t = strchr(t, ','); // not really needed, left in as documentation
         }
 #if USE_SSL
-    } else if (strcasecmp(token, "sslBump") == 0) {
+    } else if (strcmp(token, "sslBump") == 0) {
         debugs(3, DBG_CRITICAL, "WARNING: '" << token << "' is deprecated " <<
                "in http_port. Use 'ssl-bump' instead.");
-        s->sslBump = 1; // accelerated when bumped, otherwise not
+        s->flags.tunnelSslBumping = true;
     } else if (strcmp(token, "ssl-bump") == 0) {
-        s->sslBump = 1; // accelerated when bumped, otherwise not
+        s->flags.tunnelSslBumping = true;
     } else if (strncmp(token, "cert=", 5) == 0) {
         safe_free(s->cert);
         s->cert = xstrdup(token + 5);
@@ -3705,6 +3764,7 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         parseBytesOptionValue(&s->dynamicCertMemCacheSize, B_BYTES_STR, token + 28);
 #endif
     } else {
+        debugs(3, DBG_CRITICAL, "FATAL: Unknown http(s)_port option '" << token << "'.");
         self_destruct();
     }
 }
@@ -3751,14 +3811,14 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
     }
 
 #if USE_SSL
-    if (strcasecmp(protocol, "https") == 0) {
+    if (strcmp(protocol, "https") == 0) {
         /* ssl-bump on https_port configuration requires either tproxy or intercept, and vice versa */
-        const bool hijacked = s->spoof_client_ip || s->intercepted;
-        if (s->sslBump && !hijacked) {
+        const bool hijacked = s->flags.isIntercepted();
+        if (s->flags.tunnelSslBumping && !hijacked) {
             debugs(3, DBG_CRITICAL, "FATAL: ssl-bump on https_port requires tproxy/intercept which is missing.");
             self_destruct();
         }
-        if (hijacked && !s->sslBump) {
+        if (hijacked && !s->flags.tunnelSslBumping) {
             debugs(3, DBG_CRITICAL, "FATAL: tproxy/intercept on https_port requires ssl-bump which is missing.");
             self_destruct();
         }
@@ -3788,13 +3848,13 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
                       s->s.ToURL(buf,MAX_IPSTRLEN));
 
     // MODES and specific sub-options.
-    if (s->intercepted)
+    if (s->flags.natIntercept)
         storeAppendPrintf(e, " intercept");
 
-    else if (s->spoof_client_ip)
+    else if (s->flags.tproxyIntercept)
         storeAppendPrintf(e, " tproxy");
 
-    else if (s->accel) {
+    else if (s->flags.accelSurrogate) {
         storeAppendPrintf(e, " accel");
 
         if (s->vhost)
@@ -3825,7 +3885,7 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
         storeAppendPrintf(e, " name=%s", s->name);
 
 #if USE_HTTP_VIOLATIONS
-    if (!s->accel && s->ignore_cc)
+    if (!s->flags.accelSurrogate && s->ignore_cc)
         storeAppendPrintf(e, " ignore-cc");
 #endif
 
@@ -3857,7 +3917,7 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
     }
 
 #if USE_SSL
-    if (s->sslBump)
+    if (s->flags.tunnelSslBumping)
         storeAppendPrintf(e, " ssl-bump");
 
     if (s->cert)
@@ -4178,7 +4238,7 @@ dump_CpuAffinityMap(StoreEntry *const entry, const char *const name, const CpuAf
                               cpuAffinityMap->processes()[i]);
         }
         storeAppendPrintf(entry, " cores=");
-        for (size_t i = 0; i < cpuAffinityMap->processes().size(); ++i) {
+        for (size_t i = 0; i < cpuAffinityMap->cores().size(); ++i) {
             storeAppendPrintf(entry, "%s%i", (i ? "," : ""),
                               cpuAffinityMap->cores()[i]);
         }
@@ -330,7 +330,7 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
 
     Mgr::Command::Pointer cmd = ParseUrl(entry->url());
     if (!cmd) {
-        ErrorState *err = new ErrorState(ERR_INVALID_URL, HTTP_NOT_FOUND, request);
+        ErrorState *err = new ErrorState(ERR_INVALID_URL, Http::scNotFound, request);
         err->url = xstrdup(entry->url());
         errorAppendEntry(entry, err);
         entry->expires = squid_curtime;
@@ -353,7 +353,7 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
 
     if (CheckPassword(*cmd) != 0) {
         /* build error message */
-        ErrorState errState(ERR_CACHE_MGR_ACCESS_DENIED, HTTP_UNAUTHORIZED, request);
+        ErrorState errState(ERR_CACHE_MGR_ACCESS_DENIED, Http::scUnauthorized, request);
         /* warn if user specified incorrect password */
 
         if (cmd->params.password.size()) {
@@ -407,11 +407,11 @@ CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request
 
     // special case: /squid-internal-mgr/ index page
     if (!strcmp(cmd->profile->name, "index")) {
-        ErrorState err(MGR_INDEX, HTTP_OK, request);
+        ErrorState err(MGR_INDEX, Http::scOkay, request);
         err.url = xstrdup(entry->url());
         HttpReply *rep = err.BuildHttpReply();
         if (strncmp(rep->body.content(),"Internal Error:", 15) == 0)
-            rep->sline.status = HTTP_NOT_FOUND;
+            rep->sline.set(Http::ProtocolVersion(1,1), Http::scNotFound);
         // Allow cachemgr and other XHR scripts access to our version string
         if (request->header.has(HDR_ORIGIN)) {
             rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
@@ -104,6 +104,57 @@ COMMENT_START
 	across all Squid processes.
 COMMENT_END
 
+# options still not yet ported from 2.7 to 3.x
+NAME: broken_vary_encoding
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+NAME: cache_vary
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+NAME: collapsed_forwarding
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3. see http://bugs.squid-cache.org/show_bug.cgi?id=3495
+DOC_END
+
+NAME: error_map
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+NAME: external_refresh_check
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+NAME: ignore_ims_on_miss
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+NAME: location_rewrite_program location_rewrite_access location_rewrite_children location_rewrite_concurrency
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+NAME: refresh_stale_hit
+TYPE: obsolete
+DOC_START
+	This option is not yet supported by Squid-3.
+DOC_END
+
+# no Options Removed in 3.3
+
 # Options Removed in 3.2
 NAME: ignore_expect_100
 TYPE: obsolete
@@ -114,7 +165,7 @@ DOC_END
 NAME: dns_v4_fallback
 TYPE: obsolete
 DOC_START
-	Remove this line.
+	Remove this line. Squid performs a 'Happy Eyeballs' algorithm, the 'fallback' algorithm is no longer relevant.
 DOC_END
 
 NAME: ftp_list_width
@@ -129,6 +180,12 @@ DOC_START
 	Replaced by connect_retries. The behaviour has changed, please read the documentation before altering.
 DOC_END
 
+NAME: update_headers
+TYPE: obsolete
+DOC_START
+	Remove this line. The feature is supported by default in storage types where update is implemented.
+DOC_END
+
 NAME: url_rewrite_concurrency
 TYPE: obsolete
 DOC_START
@@ -190,6 +247,18 @@ DOC_START
 	Since squid-3.0 use the 'disable-pmtu-discovery' flag on http_port instead.
 DOC_END
 
+NAME: wais_relay_host
+TYPE: obsolete
+DOC_START
+	Replace this line with 'cache_peer' configuration.
+DOC_END
+
+NAME: wais_relay_port
+TYPE: obsolete
+DOC_START
+	Replace this line with 'cache_peer' configuration.
+DOC_END
+
 COMMENT_START
  OPTIONS FOR AUTHENTICATION
  -----------------------------------------------------------------------------
@@ -252,7 +321,7 @@ DOC_START
 		the user does not exist.
 
 	  BH
-		An internal error occured in the helper, preventing
+		An internal error occurred in the helper, preventing
 		a result being identified.
 
 	"ERR" and "BH" results may optionally be followed by message="..."
@@ -270,7 +339,7 @@ DOC_START
 	auth_param basic program @DEFAULT_PREFIX@/libexec/ncsa_auth @DEFAULT_PREFIX@/etc/passwd
 
 	"utf8" on|off
-	HTTP uses iso-latin-1 as characterset, while some authentication
+	HTTP uses iso-latin-1 as character set, while some authentication
 	backends such as LDAP expects UTF-8. If this is set to on Squid will
 	translate the HTTP iso-latin-1 charset to UTF-8 before sending the
 	username & password to the helper.
@@ -293,7 +362,7 @@ DOC_START
 	supports one request at a time. Setting this to a number greater than
 	0 changes the protocol used to include a channel number first on the
 	request/response line, allowing multiple requests to be sent to the
-	same helper in parallell without wating for the response.
+	same helper in parallel without waiting for the response.
 	Must not be set unless it's known the helper supports this.
 
 	auth_param basic children 20 startup=0 idle=1
@@ -339,7 +408,7 @@ DOC_START
 		the user does not exist.
 
 	  BH
-		An internal error occured in the helper, preventing
+		An internal error occurred in the helper, preventing
 		a result being identified.
 
 	"ERR" and "BH" results may optionally be followed by message="..."
@@ -354,7 +423,7 @@ DOC_START
 	auth_param digest program @DEFAULT_PREFIX@/bin/digest_pw_auth @DEFAULT_PREFIX@/etc/digpass
 
 	"utf8" on|off
-	HTTP uses iso-latin-1 as characterset, while some authentication
+	HTTP uses iso-latin-1 as character set, while some authentication
 	backends such as LDAP expects UTF-8. If this is set to on Squid will
 	translate the HTTP iso-latin-1 charset to UTF-8 before sending the
 	username & password to the helper.
@@ -377,7 +446,7 @@ DOC_START
 	supports one request at a time. Setting this to a number greater than
 	0 changes the protocol used to include a channel number first on the
 	request/response line, allowing multiple requests to be sent to the
-	same helper in parallell without wating for the response.
+	same helper in parallel without waiting for the response.
 	Must not be set unless it's known the helper supports this.
 
 	auth_param digest children 20 startup=0 idle=1
@@ -404,7 +473,7 @@ DOC_START
 	"nonce_strictness" on|off
 	Determines if squid requires strict increment-by-1 behavior
 	for nonce counts, or just incrementing (off - for use when
-	useragents generate nonce counts that occasionally miss 1
+	user agents generate nonce counts that occasionally miss 1
 	(ie, 1,2,4,6)). Default off.
 
 	"check_nonce_count" on|off
@@ -475,7 +544,7 @@ DOC_START
 	The maximum number of authenticator processes to spawn (default 5).
 	If you start too few Squid will have to wait for them to
 	process a backlog of credential verifications, slowing it
-	down. When crendential verifications are done via a (slow)
+	down. When credential verifications are done via a (slow)
 	network you are likely to need lots of authenticator
 	processes.
 
@@ -527,7 +596,7 @@ DEFAULT: 1 hour
 LOC: Config.authenticateGCInterval
 DOC_START
 	The time period between garbage collection across the username cache.
-	This is a tradeoff between memory utilization (long intervals - say
+	This is a trade-off between memory utilization (long intervals - say
 	2 days) and CPU (short intervals - say 1 minute). Only change if you
 	have good reason to.
 DOC_END
@@ -546,13 +615,13 @@ DOC_END
 NAME: authenticate_ip_ttl
 TYPE: time_t
 LOC: Config.authenticateIpTTL
-DEFAULT: 0 seconds
+DEFAULT: 1 second
 DOC_START
 	If you use proxy authentication and the 'max_user_ip' ACL,
 	this directive controls how long Squid remembers the IP
 	addresses associated with each user.  Use a small value
 	(e.g., 60 seconds) if your users might change addresses
-	quickly, as is the case with dialups.   You might be safe
+	quickly, as is the case with dialup.   You might be safe
 	using a larger value (e.g., 2 hours) in a corporate LAN
 	environment with relatively static address assignments.
 DOC_END
@@ -689,7 +758,7 @@ DOC_START
 		the ACL test does not produce a match.
 
 	  BH
-		An internal error occured in the helper, preventing
+		An internal error occurred in the helper, preventing
 		a result being identified.
 
 	The meaning of 'a match' is determined by your squid.conf
@@ -753,9 +822,23 @@ DOC_START
 
 	When using "file", the file should contain one item per line.
 
-	By default, regular expressions are CASE-SENSITIVE.
-	To make them case-insensitive, use the -i option. To return case-sensitive
-	use the +i option between patterns, or make a new ACL line without -i.
+	Some acl types supports options which changes their default behaviour.
+	The available options are:
+
+	-i,+i	By default, regular expressions are CASE-SENSITIVE. To make them
+		case-insensitive, use the -i option. To return case-sensitive
+		use the +i option between patterns, or make a new ACL line
+		without -i.	
+
+	-n	Disable lookups and address type conversions.  If lookup or
+		conversion is required because the parameter type (IP or
+		domain name) does not match the message address type (domain
+		name or IP), then the ACL would immediately declare a mismatch
+		without any warnings or lookups.
+
+	--	Used to stop processing all options, in the case the first acl
+		value has '-' character as first character (for example the '-'
+		is a valid domain name)
 
 	Some acl types require suspending the current request in order
 	to access some external data source.
@@ -768,7 +851,7 @@ DOC_START
 
 	acl aclname src ip-address/mask ...	# clients IP address [fast]
 	acl aclname src addr1-addr2/mask ...	# range of addresses [fast]
-	acl aclname dst ip-address/mask ...	# URL host's IP address [slow]
+	acl aclname dst [-n] ip-address/mask ...	# URL host's IP address [slow]
 	acl aclname localip ip-address/mask ... # IP address the client connected to [fast]
 
 	acl aclname arp      mac-address ... (xx:xx:xx:xx:xx:xx notation)
@@ -784,11 +867,11 @@ DOC_START
 
 	acl aclname srcdomain   .foo.com ...
 	  # reverse lookup, from client IP [slow]
-	acl aclname dstdomain   .foo.com ...
+	acl aclname dstdomain [-n] .foo.com ...
 	  # Destination server from URL [fast]
 	acl aclname srcdom_regex [-i] \.foo\.com ...
 	  # regex matching client name [slow]
-	acl aclname dstdom_regex [-i] \.foo\.com ...
+	acl aclname dstdom_regex [-n] [-i] \.foo\.com ...
 	  # regex matching server [fast]
 	  #
 	  # For dstdomain and dstdom_regex a reverse lookup is tried if a IP
@@ -983,6 +1066,15 @@ IF USE_SSL
 	  #
 	  # NOTE: The ssl_error ACL is only supported with sslproxy_cert_error,
 	  # sslproxy_cert_sign, and sslproxy_cert_adapt options.
+
+	acl aclname server_cert_fingerprint [-sha1] fingerprint
+	  # match against server SSL certificate fingerprint [fast]
+	  #
+	  # The fingerprint is the digest of the DER encoded version 
+	  # of the whole certificate. The user should use the form: XX:XX:...
+	  # Optional argument specifies the digest algorithm to use.
+	  # The SHA1 digest algorithm is the default and is currently
+	  # the only algorithm supported (-sha1).
 ENDIF
 
 	Examples:
@@ -2431,7 +2523,12 @@ DEFAULT: none
 LOC: Ssl::TheConfig.ssl_crt_validator
 DOC_START
 	Specify the location and options of the executable for ssl_crt_validator
-	process.
+	process. Usage:
+		sslcrtvalidator_program [ttl=n] [cache=n] path ...
+
+	Options:
+	  ttl=n         TTL in seconds for cached results.The default is 60 secs
+	  cache=n       limit the result cache size. The default value is 2048
 DOC_END
 
 NAME: sslcrtvalidator_children
@@ -3112,7 +3209,7 @@ DOC_START
 	replacement policies.
 
 	NOTE: if using the LFUDA replacement policy you should increase
-	the value of maximum_object_size above its default of 4096 KB to
+	the value of maximum_object_size above its default of 4 MB to
 	to maximize the potential byte hit rate improvement of LFUDA.
 
 	For more information about the GDSF and LFUDA cache replacement
@@ -3208,6 +3305,12 @@ DOC_START
 	entries are stored in a "database" file, using fixed-size slots.
 	A single entry occupies one or more slots.
 
+	If possible, Squid using Rock Store creates a dedicated kid
+	process called "disker" to avoid blocking Squid worker(s) on disk
+	I/O. One disker kid is created for each rock cache_dir.  Diskers
+	are created only when Squid, running in daemon mode, has support
+	for the IpcIo disk I/O module.
+
 	swap-timeout=msec: Squid will not start writing a miss to or
 	reading a hit from disk if it estimates that the swap operation
 	will take more than the specified number of milliseconds. By
@@ -3319,14 +3422,18 @@ DOC_END
 NAME: maximum_object_size
 COMMENT: (bytes)
 TYPE: b_int64_t
-DEFAULT: 4096 KB
+DEFAULT: 4 MB
 LOC: Config.Store.maxObjectSize
 DOC_START
-	Objects larger than this size will NOT be saved on disk.  The
-	value is specified in kilobytes, and the default is 4MB.  If
-	you wish to get a high BYTES hit ratio, you should probably
+	The default limit on size of objects stored to disk.
+	This size is used for cache_dir where max-size is not set.
+	The value is specified in bytes, and the default is 4 MB.
+
+	If you wish to get a high BYTES hit ratio, you should probably
 	increase this (one 32 MB object hit counts for 3200 10KB
-	hits).  If you wish to increase speed more than your want to
+	hits).
+
+	If you wish to increase hit ratio more than you want to
 	save bandwidth you should leave this low.
 
 	NOTE: if using the LFUDA replacement policy you should increase
@@ -4221,7 +4328,7 @@ DOC_START
 		Do not change the URL.
 
 	  BH
-		An internal error occured in the helper, preventing
+		An internal error occurred in the helper, preventing
 		a result being identified.
 
 
@@ -4285,9 +4392,8 @@ DOC_START
 
 	When this directive is set to a value >= 1 then the protocol
 	used to communicate with the helper is modified to include
-	a request ID in front of the request/response. The request
-	ID from the request must be echoed back with the response
-	to that request.
+	an ID in front of the request/response. The ID from the request
+	must be echoed back with the response to that request.
 DOC_END
 
 NAME: url_rewrite_host_header redirect_rewrites_host_header
@@ -4340,6 +4446,128 @@ DOC_START
 	be allowed to request.
 DOC_END
 
+COMMENT_START
+ OPTIONS FOR STORE ID
+ -----------------------------------------------------------------------------
+COMMENT_END
+
+NAME: store_id_program storeurl_rewrite_program
+TYPE: wordlist
+LOC: Config.Program.store_id
+DEFAULT: none
+DOC_START
+	Specify the location of the executable StoreID helper to use.
+	Since they can perform almost any function there isn't one included.
+
+	For each requested URL, the helper will receive one line with the format
+
+	  [channel-ID <SP>] URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kv-pairs]<NL>
+
+
+	After processing the request the helper must reply using the following format:
+
+	  [channel-ID <SP>] result [<SP> kv-pairs]
+
+	The result code can be:
+
+	  OK store-id="..."
+		Use the StoreID supplied in 'store-id='.
+
+	  ERR
+		The default is to use HTTP request URL as the store ID.
+
+	  BH
+		An internal error occured in the helper, preventing
+		a result being identified.
+
+
+	Helper programs should be prepared to receive and possibly ignore additional
+	kv-pairs with keys they do not support.
+
+	When using the concurrency= option the protocol is changed by
+	introducing a query channel tag in front of the request/response.
+	The query channel tag is a number between 0 and concurrency-1.
+	This value must be echoed back unchanged to Squid as the first part
+	of the response relating to its request.
+
+	NOTE: when using StoreID refresh_pattern will apply to the StoreID
+	      returned from the helper and not the URL.
+
+	WARNING: Wrong StoreID value returned by a careless helper may result
+	         in the wrong cached response returned to the user.
+
+	By default, a StoreID helper is not used.
+DOC_END
+
+NAME: store_id_children storeurl_rewrite_children
+TYPE: HelperChildConfig
+DEFAULT: 20 startup=0 idle=1 concurrency=0
+LOC: Config.storeIdChildren
+DOC_START
+	The maximum number of StoreID helper processes to spawn. If you limit
+	it too few Squid will have to wait for them to process a backlog of
+	requests, slowing it down. If you allow too many they will use RAM
+	and other system resources noticably.
+	
+	The startup= and idle= options allow some measure of skew in your
+	tuning.
+	
+		startup=
+	
+	Sets a minimum of how many processes are to be spawned when Squid
+	starts or reconfigures. When set to zero the first request will
+	cause spawning of the first child process to handle it.
+	
+	Starting too few will cause an initial slowdown in traffic as Squid
+	attempts to simultaneously spawn enough processes to cope.
+	
+		idle=
+	
+	Sets a minimum of how many processes Squid is to try and keep available
+	at all times. When traffic begins to rise above what the existing
+	processes can handle this many more will be spawned up to the maximum
+	configured. A minimum setting of 1 is required.
+
+		concurrency=
+
+	The number of requests each storeID helper can handle in
+	parallel. Defaults to 0 which indicates the helper
+	is a old-style single threaded program.
+
+	When this directive is set to a value >= 1 then the protocol
+	used to communicate with the helper is modified to include
+	an ID in front of the request/response. The ID from the request
+	must be echoed back with the response to that request.
+DOC_END
+
+NAME: store_id_access storeurl_rewrite_access
+TYPE: acl_access
+DEFAULT: none
+LOC: Config.accessList.store_id
+DOC_START
+	If defined, this access list specifies which requests are
+	sent to the StoreID processes.  By default all requests
+	are sent.
+
+	This clause supports both fast and slow acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+DOC_END
+
+NAME: store_id_bypass storeurl_rewrite_bypass
+TYPE: onoff
+LOC: Config.onoff.store_id_bypass
+DEFAULT: on
+DOC_START
+	When this is 'on', a request will not go through the
+	helper if all helpers are busy.  If this is 'off'
+	and the helper queue grows too large, Squid will exit
+	with a FATAL error and ask you to increase the number of
+	helpers.  You should only enable this if the helperss
+	are not critical to your caching system.  If you use
+	helpers for critical caching components, and you enable this 
+	option,	users may not get objects from cache.
+DOC_END
+
 COMMENT_START
  OPTIONS FOR TUNING THE CACHE
  -----------------------------------------------------------------------------
@@ -151,7 +151,7 @@ ClientInfo * clientdbGetInfo(const Ip::Address &addr)
 }
 #endif
 void
-clientdbUpdate(const Ip::Address &addr, log_type ltype, AnyP::ProtocolType p, size_t size)
+clientdbUpdate(const Ip::Address &addr, LogTags ltype, AnyP::ProtocolType p, size_t size)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
@@ -279,19 +279,11 @@ clientdbCutoffDenied(const Ip::Address &addr)
     return 1;
 }
 
-log_type &operator++ (log_type &aLogType)
-{
-    int tmp = (int)aLogType;
-    aLogType = (log_type)(++tmp);
-    return aLogType;
-}
-
 void
 clientdbDump(StoreEntry * sentry)
 {
     const char *name;
     ClientInfo *c;
-    log_type l;
     int icp_total = 0;
     int icp_hits = 0;
     int http_total = 0;
@@ -309,7 +301,7 @@ clientdbDump(StoreEntry * sentry)
         storeAppendPrintf(sentry, "    ICP  Requests %d\n",
                           c->Icp.n_requests);
 
-        for (l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (c->Icp.result_hist[l] == 0)
                 continue;
 
@@ -318,12 +310,12 @@ clientdbDump(StoreEntry * sentry)
             if (LOG_UDP_HIT == l)
                 icp_hits += c->Icp.result_hist[l];
 
-            storeAppendPrintf(sentry, "        %-20.20s %7d %3d%%\n",Format::log_tags[l], c->Icp.result_hist[l], Math::intPercent(c->Icp.result_hist[l], c->Icp.n_requests));
+            storeAppendPrintf(sentry, "        %-20.20s %7d %3d%%\n",LogTags_str[l], c->Icp.result_hist[l], Math::intPercent(c->Icp.result_hist[l], c->Icp.n_requests));
         }
 
         storeAppendPrintf(sentry, "    HTTP Requests %d\n", c->Http.n_requests);
 
-        for (l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (c->Http.result_hist[l] == 0)
                 continue;
 
@@ -334,7 +326,7 @@ clientdbDump(StoreEntry * sentry)
 
             storeAppendPrintf(sentry,
                               "        %-20.20s %7d %3d%%\n",
-                              Format::log_tags[l],
+                              LogTags_str[l],
                               c->Http.result_hist[l],
                               Math::intPercent(c->Http.result_hist[l], c->Http.n_requests));
         }
@@ -504,7 +496,6 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
 
     variable_list *Answer = NULL;
     int aggr = 0;
-    log_type l;
 
     switch (Var->name[LEN_SQ_NET + 2]) {
 
@@ -543,7 +534,7 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
     case MESH_CTBL_HTHITS:
         aggr = 0;
 
-        for (l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (logTypeIsATcpHit(l))
                 aggr += c->Http.result_hist[l];
         }
@@ -34,8 +34,10 @@
 #define SQUID_CLIENT_DB_H_
 
 #include "anyp/ProtocolType.h"
-#include "enums.h"
+//#include "enums.h"
 #include "ip/Address.h"
+#include "LogTags.h"
+
 namespace Ip
 {
 class Address;
@@ -45,7 +47,7 @@ class StoreEntry;
 class ClientInfo;
 
 void clientdbInit(void);
-void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
+void clientdbUpdate(const Ip::Address &, LogTags, AnyP::ProtocolType, size_t);
 int clientdbCutoffDenied(const Ip::Address &);
 void clientdbDump(StoreEntry *);
 void clientdbFreeMemory(void);
@@ -221,7 +221,7 @@ static IOACB httpsAccept;
 #endif
 static CTCB clientLifetimeTimeout;
 static ClientSocketContext *parseHttpRequestAbort(ConnStateData * conn, const char *uri);
-static ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, HttpVersion *);
+static ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, Http::ProtocolVersion *);
 #if USE_IDENT
 static IDCB clientIdentDone;
 #endif
@@ -231,8 +231,8 @@ static void clientSetKeepaliveFlag(ClientHttpRequest *);
 static int clientIsContentLengthValid(HttpRequest * r);
 static int clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength);
 
-static void clientUpdateStatHistCounters(log_type logType, int svc_time);
-static void clientUpdateStatCounters(log_type logType);
+static void clientUpdateStatHistCounters(LogTags logType, int svc_time);
+static void clientUpdateStatCounters(LogTags logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
@@ -241,7 +241,7 @@ static bool connIsUsable(ConnStateData * conn);
 #endif
 static int responseFinishedOrFailed(HttpReply * rep, StoreIOBuffer const &receivedData);
 static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
-static void clientUpdateSocketStats(log_type logType, size_t size);
+static void clientUpdateSocketStats(LogTags logType, size_t size);
 
 char *skipLeadingSpace(char *aString);
 static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
@@ -381,8 +381,8 @@ ClientSocketContextNew(const Comm::ConnectionPointer &client, ClientHttpRequest
 void
 ClientSocketContext::writeControlMsg(HttpControlMsg &msg)
 {
-    HttpReply *rep = msg.reply;
-    Must(rep);
+    const HttpReply::Pointer rep(msg.reply);
+    Must(rep != NULL);
 
     // apply selected clientReplyContext::buildReplyHeader() mods
     // it is not clear what headers are required for control messages
@@ -444,7 +444,7 @@ clientIdentDone(const char *ident, void *data)
 #endif
 
 void
-clientUpdateStatCounters(log_type logType)
+clientUpdateStatCounters(LogTags logType)
 {
     ++statCounter.client_http.requests;
 
@@ -458,7 +458,7 @@ clientUpdateStatCounters(log_type logType)
 }
 
 void
-clientUpdateStatHistCounters(log_type logType, int svc_time)
+clientUpdateStatHistCounters(LogTags logType, int svc_time)
 {
     statCounter.client_http.allSvcTime.count(svc_time);
     /**
@@ -649,10 +649,10 @@ ClientHttpRequest::logRequest()
     debugs(33, 9, "clientLogRequest: al.url='" << al->url << "'");
 
     if (al->reply) {
-        al->http.code = al->reply->sline.status;
+        al->http.code = al->reply->sline.status();
         al->http.content_type = al->reply->content_type.termedBuf();
     } else if (loggingEntry() && loggingEntry()->mem_obj) {
-        al->http.code = loggingEntry()->mem_obj->getReply()->sline.status;
+        al->http.code = loggingEntry()->mem_obj->getReply()->sline.status();
         al->http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
     }
 
@@ -707,14 +707,19 @@ ClientHttpRequest::logRequest()
 
     ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.log, this);
 
-    if (al->reply)
-        checklist->reply = HTTPMSGLOCK(al->reply);
+    if (al->reply) {
+        checklist->reply = al->reply;
+        HTTPMSGLOCK(checklist->reply);
+    }
 
     if (!Config.accessList.log || checklist->fastCheck() == ACCESS_ALLOWED) {
-        if (request)
-            al->adapted_request = HTTPMSGLOCK(request);
+        if (request) {
+            al->adapted_request = request;
+            HTTPMSGLOCK(al->adapted_request);
+        }
         accessLogLog(al, checklist);
-        updateCounters();
+        if (request)
+            updateCounters();
 
         if (getConn() != NULL && getConn()->clientConnection != NULL)
             clientdbUpdate(getConn()->clientConnection->remote, logType, AnyP::PROTO_HTTP, out.size);
@@ -862,7 +867,7 @@ clientSetKeepaliveFlag(ClientHttpRequest * http)
            RequestMethodStr(request->method));
 
     // TODO: move to HttpRequest::hdrCacheInit, just like HttpReply.
-    request->flags.proxyKeepalive = request->persistent() ? 1 : 0;
+    request->flags.proxyKeepalive = request->persistent();
 }
 
 static int
@@ -1273,7 +1278,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
 
     if (!rep)
         range_err = "no [parse-able] reply";
-    else if ((rep->sline.status != HTTP_OK) && (rep->sline.status != HTTP_PARTIAL_CONTENT))
+    else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
         range_err = "wrong status code";
     else if (hdr->has(HDR_CONTENT_RANGE))
         range_err = "origin server does ranges";
@@ -1305,9 +1310,8 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         delete http->request->range;
         http->request->range = NULL;
     } else {
-        /* XXX: TODO: Review, this unconditional set may be wrong. - TODO: review. */
-        httpStatusLineSet(&rep->sline, rep->sline.version,
-                          HTTP_PARTIAL_CONTENT, NULL);
+        /* XXX: TODO: Review, this unconditional set may be wrong. */
+        rep->sline.set(rep->sline.version, Http::scPartialContent);
         // web server responded with a valid, but unexpected range.
         // will (try-to) forward as-is.
         //TODO: we should cope with multirange request/responses
@@ -1474,7 +1478,8 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
         context->sendBody(rep, receivedData);
     else {
         assert(rep);
-        http->al->reply = HTTPMSGLOCK(rep);
+        http->al->reply = rep;
+        HTTPMSGLOCK(http->al->reply);
         context->sendStartOfMessage(rep, receivedData);
     }
 
@@ -1639,7 +1644,7 @@ ClientSocketContext::keepaliveNextRequest()
 }
 
 void
-clientUpdateSocketStats(log_type logType, size_t size)
+clientUpdateSocketStats(LogTags logType, size_t size)
 {
     if (size == 0)
         return;
@@ -2029,7 +2034,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
     char *host;
     char ipbuf[MAX_IPSTRLEN];
 
-    http->flags.accel = 1;
+    http->flags.accel = true;
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
 
@@ -2046,7 +2051,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
 #if SHOULD_REJECT_UNKNOWN_URLS
 
         if (!url) {
-            hp->request_parse_status = HTTP_BAD_REQUEST;
+            hp->request_parse_status = Http::scBadRequest;
             return parseHttpRequestAbort(conn, "error:invalid-request");
         }
 #endif
@@ -2140,17 +2145,21 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
     }
 }
 
-/**
- *  parseHttpRequest()
+/** Parse an HTTP request
  *
- *  Returns
- *  NULL on incomplete requests
- *  a ClientSocketContext structure on success or failure.
- *  Sets result->flags.parsed_ok to 0 if failed to parse the request.
- *  Sets result->flags.parsed_ok to 1 if we have a good request.
+ *  \note Sets result->flags.parsed_ok to 0 if failed to parse the request,
+ *          to 1 if the request was correctly parsed.
+ *  \param[in] csd a ConnStateData. The caller must make sure it is not null
+ *  \param[in] hp an HttpParser
+ *  \param[out] mehtod_p will be set as a side-effect of the parsing.
+ *          Pointed-to value will be set to Http::METHOD_NONE in case of
+ *          parsing failure
+ *  \param[out] http_ver will be set as a side-effect of the parsing
+ *  \return NULL on incomplete requests,
+ *          a ClientSocketContext structure on success or failure.
  */
 static ClientSocketContext *
-parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_p, HttpVersion *http_ver)
+parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_p, Http::ProtocolVersion *http_ver)
 {
     char *req_hdr = NULL;
     char *end;
@@ -2170,7 +2179,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
         return NULL;
     } else if ( (size_t)hp->bufsiz >= Config.maxRequestHeaderSize && headersEnd(hp->buf, Config.maxRequestHeaderSize) == 0) {
         debugs(33, 5, "parseHttpRequest: Too large request");
-        hp->request_parse_status = HTTP_HEADER_TOO_LARGE;
+        hp->request_parse_status = Http::scHeaderTooLarge;
         return parseHttpRequestAbort(csd, "error:request-too-large");
     }
 
@@ -2187,7 +2196,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     }
 
     /* Request line is valid here .. */
-    *http_ver = HttpVersion(hp->req.v_maj, hp->req.v_min);
+    *http_ver = Http::ProtocolVersion(hp->req.v_maj, hp->req.v_min);
 
     /* This call scans the entire request, not just the headers */
     if (hp->req.v_maj > 0) {
@@ -2215,26 +2224,26 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     /* Enforce max_request_size */
     if (req_sz >= Config.maxRequestHeaderSize) {
         debugs(33, 5, "parseHttpRequest: Too large request");
-        hp->request_parse_status = HTTP_HEADER_TOO_LARGE;
+        hp->request_parse_status = Http::scHeaderTooLarge;
         return parseHttpRequestAbort(csd, "error:request-too-large");
     }
 
     /* Set method_p */
     *method_p = HttpRequestMethod(&hp->buf[hp->req.m_start], &hp->buf[hp->req.m_end]+1);
 
     /* deny CONNECT via accelerated ports */
-    if (*method_p == Http::METHOD_CONNECT && csd && csd->port && csd->port->accel) {
+    if (*method_p == Http::METHOD_CONNECT && csd->port && csd->port->flags.accelSurrogate) {
         debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->protocol << " Accelerator port " << csd->port->s.GetPort() );
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "WARNING: for request: " << hp->buf);
-        hp->request_parse_status = HTTP_METHOD_NOT_ALLOWED;
+        hp->request_parse_status = Http::scMethodNotAllowed;
         return parseHttpRequestAbort(csd, "error:method-not-allowed");
     }
 
     if (*method_p == Http::METHOD_NONE) {
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "clientParseRequestMethod: Unsupported method in request '" << hp->buf << "'");
-        hp->request_parse_status = HTTP_METHOD_NOT_ALLOWED;
+        hp->request_parse_status = Http::scMethodNotAllowed;
         return parseHttpRequestAbort(csd, "error:unsupported-request-method");
     }
 
@@ -2289,7 +2298,8 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
 
 #endif
 
-    debugs(33,5, HERE << "repare absolute URL from " << (csd->transparent()?"intercept":(csd->port->accel ? "accel":"")));
+    debugs(33,5, HERE << "repare absolute URL from " <<
+           (csd->transparent()?"intercept":(csd->port->flags.accelSurrogate ? "accel":"")));
     /* Rewrite the URL in transparent or accelerator mode */
     /* NP: there are several cases to traverse here:
      *  - standard mode (forward proxy)
@@ -2311,9 +2321,9 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
         http->uri = xstrdup(internalLocalUri(NULL, url));
         // We just re-wrote the URL. Must replace the Host: header.
         //  But have not parsed there yet!! flag for local-only handling.
-        http->flags.internal = 1;
+        http->flags.internal = true;
 
-    } else if (csd->port->accel || csd->switchedToHttps()) {
+    } else if (csd->port->flags.accelSurrogate || csd->switchedToHttps()) {
         /* accelerator mode */
         prepareAcceleratedURL(csd, http, url, req_hdr);
     }
@@ -2457,7 +2467,7 @@ ConnStateData::checkHeaderLimits()
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
     assert (repContext);
     repContext->setReplyToError(ERR_TOO_BIG,
-                                HTTP_BAD_REQUEST, Http::METHOD_NONE, NULL,
+                                Http::scBadRequest, Http::METHOD_NONE, NULL,
                                 clientConnection->remote, NULL, NULL, NULL);
     context->registerWithConn();
     context->pullData();
@@ -2484,7 +2494,7 @@ ConnStateData::quitAfterError(HttpRequest *request)
     // at the client-side, but many such errors do require closure and the
     // client-side code is bad at handling errors so we play it safe.
     if (request)
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     flags.readMore = false;
     debugs(33,4, HERE << "Will close after error: " << clientConnection);
 }
@@ -2511,8 +2521,10 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
         repContext->setReplyToStoreEntry(sslServerBump->entry);
 
         // save the original request for logging purposes
-        if (!context->http->al->request)
-            context->http->al->request = HTTPMSGLOCK(http->request);
+        if (!context->http->al->request) {
+            context->http->al->request = http->request;
+            HTTPMSGLOCK(context->http->al->request);
+        }
 
         // Get error details from the fake certificate-peeking request.
         http->request->detailError(sslServerBump->request->errType, sslServerBump->request->errDetail);
@@ -2548,15 +2560,17 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
                 request->hier.note(peekerRequest->hier.tcpServer, request->GetHost());
 
                 // Create an error object and fill it
-                ErrorState *err = new ErrorState(ERR_SECURE_CONNECT_FAIL, HTTP_SERVICE_UNAVAILABLE, request);
+                ErrorState *err = new ErrorState(ERR_SECURE_CONNECT_FAIL, Http::scServiceUnavailable, request);
                 err->src_addr = clientConnection->remote;
                 Ssl::ErrorDetail *errDetail = new Ssl::ErrorDetail(
                     SQUID_X509_V_ERR_DOMAIN_MISMATCH,
                     sslServerBump->serverCert.get(), NULL);
                 err->detail = errDetail;
                 // Save the original request for logging purposes.
-                if (!context->http->al->request)
-                    context->http->al->request = HTTPMSGLOCK(request);
+                if (!context->http->al->request) {
+                    context->http->al->request = request;
+                    HTTPMSGLOCK(context->http->al->request);
+                }
                 repContext->setReplyToError(request->method, err);
                 assert(context->http->out.offset == 0);
                 context->pullData();
@@ -2570,10 +2584,10 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
 #endif // USE_SSL
 
 static void
-clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod& method, HttpVersion http_ver)
+clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod& method, Http::ProtocolVersion http_ver)
 {
     ClientHttpRequest *http = context->http;
-    HttpRequest *request = NULL;
+    HttpRequest::Pointer request;
     bool notedUseOfBuffer = false;
     bool chunked = false;
     bool mustReplyToOptions = false;
@@ -2593,11 +2607,11 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         switch (hp->request_parse_status) {
-        case HTTP_HEADER_TOO_LARGE:
-            repContext->setReplyToError(ERR_TOO_BIG, HTTP_BAD_REQUEST, method, http->uri, conn->clientConnection->remote, NULL, conn->in.buf, NULL);
+        case Http::scHeaderTooLarge:
+            repContext->setReplyToError(ERR_TOO_BIG, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, conn->in.buf, NULL);
             break;
-        case HTTP_METHOD_NOT_ALLOWED:
-            repContext->setReplyToError(ERR_UNSUP_REQ, HTTP_METHOD_NOT_ALLOWED, method, http->uri,
+        case Http::scMethodNotAllowed:
+            repContext->setReplyToError(ERR_UNSUP_REQ, Http::scMethodNotAllowed, method, http->uri,
                                         conn->clientConnection->remote, NULL, conn->in.buf, NULL);
             break;
         default:
@@ -2612,12 +2626,12 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, method)) == NULL) {
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Invalid URL: " << http->uri);
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_INVALID_URL, HTTP_BAD_REQUEST, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
+        repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
@@ -2631,12 +2645,12 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
 
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Unsupported HTTP version discovered. :\n" << HttpParserHdrBuf(hp));
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, HTTP_HTTP_VERSION_NOT_SUPPORTED, method, http->uri,
+        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, method, http->uri,
                                     conn->clientConnection->remote, NULL, HttpParserHdrBuf(hp), NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
@@ -2649,12 +2663,12 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     if (http_ver.major >= 1 && !request->parseHeader(HttpParserHdrBuf(hp), HttpParserHdrSz(hp))) {
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Failed to parse request headers:\n" << HttpParserHdrBuf(hp));
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_INVALID_REQ, HTTP_BAD_REQUEST, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
+        repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
@@ -2664,7 +2678,6 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
 
     request->flags.accelerated = http->flags.accel;
     request->flags.sslBumped=conn->switchedToHttps();
-    request->flags.canRePin = request->flags.sslBumped && conn->pinning.pinned;
     request->flags.ignoreCc = conn->port->ignore_cc;
     // TODO: decouple http->flags.accel from request->flags.sslBumped
     request->flags.noDirect = (request->flags.accelerated && !request->flags.sslBumped) ?
@@ -2688,11 +2701,11 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     if (internalCheck(request->urlpath.termedBuf())) {
         if (internalHostnameIs(request->GetHost()) &&
                 request->port == getMyPort()) {
-            http->flags.internal = 1;
+            http->flags.internal = true;
         } else if (Config.onoff.global_internal_static && internalStaticCheck(request->urlpath.termedBuf())) {
             request->SetHost(internalHostname());
             request->port = getMyPort();
-            http->flags.internal = 1;
+            http->flags.internal = true;
         }
     }
 
@@ -2702,7 +2715,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     }
 
     request->flags.internal = http->flags.internal;
-    setLogUri (http, urlCanonicalClean(request));
+    setLogUri (http, urlCanonicalClean(request.getRaw()));
     request->client_addr = conn->clientConnection->remote; // XXX: remove reuest->client_addr member.
 #if FOLLOW_X_FORWARDED_FOR
     // indirect client gets stored here because it is an HTTP header result (from X-Forwarded-For:)
@@ -2727,26 +2740,26 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
 
     mustReplyToOptions = (method == Http::METHOD_OPTIONS) &&
                          (request->header.getInt64(HDR_MAX_FORWARDS) == 0);
-    if (!urlCheckRequest(request) || mustReplyToOptions || unsupportedTe) {
+    if (!urlCheckRequest(request.getRaw()) || mustReplyToOptions || unsupportedTe) {
         clientStreamNode *node = context->getClientReplyContext();
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_UNSUP_REQ, HTTP_NOT_IMPLEMENTED, request->method, NULL,
-                                    conn->clientConnection->remote, request, NULL, NULL);
+        repContext->setReplyToError(ERR_UNSUP_REQ, Http::scNotImplemented, request->method, NULL,
+                                    conn->clientConnection->remote, request.getRaw(), NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
     }
 
-    if (!chunked && !clientIsContentLengthValid(request)) {
+    if (!chunked && !clientIsContentLengthValid(request.getRaw())) {
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         repContext->setReplyToError(ERR_INVALID_REQ,
-                                    HTTP_LENGTH_REQUIRED, request->method, NULL,
-                                    conn->clientConnection->remote, request, NULL, NULL);
+                                    Http::scLengthRequired, request->method, NULL,
+                                    conn->clientConnection->remote, request.getRaw(), NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
@@ -2759,16 +2772,17 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
             clientStreamNode *node = context->getClientReplyContext();
             clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
             assert (repContext);
-            conn->quitAfterError(request);
-            repContext->setReplyToError(ERR_INVALID_REQ, HTTP_EXPECTATION_FAILED, request->method, http->uri,
-                                        conn->clientConnection->remote, request, NULL, NULL);
+            conn->quitAfterError(request.getRaw());
+            repContext->setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request->method, http->uri,
+                                        conn->clientConnection->remote, request.getRaw(), NULL, NULL);
             assert(context->http->out.offset == 0);
             context->pullData();
             goto finish;
         }
     }
 
-    http->request = HTTPMSGLOCK(request);
+    http->request = request.getRaw();
+    HTTPMSGLOCK(http->request);
     clientSetKeepaliveFlag(http);
 
     // Let tunneling code be fully responsible for CONNECT requests
@@ -2798,9 +2812,9 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
             clientStreamNode *node = context->getClientReplyContext();
             clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
             assert (repContext);
-            conn->quitAfterError(request);
+            conn->quitAfterError(request.getRaw());
             repContext->setReplyToError(ERR_TOO_BIG,
-                                        HTTP_REQUEST_ENTITY_TOO_LARGE, Http::METHOD_NONE, NULL,
+                                        Http::scRequestEntityTooLarge, Http::METHOD_NONE, NULL,
                                         conn->clientConnection->remote, http->request, NULL, NULL);
             assert(context->http->out.offset == 0);
             context->pullData();
@@ -2834,7 +2848,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      * be freed and the above connNoteUseOfBuffer() would hit an
      * assertion, not to mention that we were accessing freed memory.
      */
-    if (request && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
+    if (request != NULL && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
         debugs(33, 3, HERE << "Sending TCP RST on " << conn->clientConnection);
         conn->flags.readMore = false;
         comm_reset_close(conn->clientConnection);
@@ -2873,7 +2887,6 @@ ConnStateData::clientParseRequests()
 {
     HttpRequestMethod method;
     bool parsed_req = false;
-    HttpVersion http_ver;
 
     debugs(33, 5, HERE << clientConnection << ": attempting to parse");
 
@@ -2900,6 +2913,7 @@ ConnStateData::clientParseRequests()
         HttpParserInit(&parser_, in.buf, in.notYetUsed);
 
         /* Process request */
+        Http::ProtocolVersion http_ver;
         ClientSocketContext *context = parseHttpRequest(this, &parser_, &method, &http_ver);
         PROF_stop(parseHttpRequest);
 
@@ -2980,7 +2994,7 @@ ConnStateData::clientReadRequest(const CommIoCbParams &io)
             }
 
             /* It might be half-closed, we can't tell */
-            fd_table[io.conn->fd].flags.socket_eof = 1;
+            fd_table[io.conn->fd].flags.socket_eof = true;
 
             commMarkHalfClosed(io.conn->fd);
 
@@ -3154,8 +3168,8 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext*>(node->data.getRaw());
         assert(repContext);
-        const http_status scode = (error == ERR_TOO_BIG) ?
-                                  HTTP_REQUEST_ENTITY_TOO_LARGE : HTTP_BAD_REQUEST;
+        const Http::StatusCode scode = (error == ERR_TOO_BIG) ?
+                                       Http::scRequestEntityTooLarge : HTTP_BAD_REQUEST;
         repContext->setReplyToError(error, scode,
                                     repContext->http->request->method,
                                     repContext->http->uri,
@@ -3228,7 +3242,7 @@ ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         repContext->setReplyToError(ERR_LIFETIME_EXP,
-                                    HTTP_REQUEST_TIMEOUT, Http::METHOD_NONE, "N/A", &CachePeer.sin_addr,
+                                    Http::scRequestTimeout, Http::METHOD_NONE, "N/A", &CachePeer.sin_addr,
                                     NULL, NULL, NULL);
         /* No requests can be outstanded */
         assert(chr == NULL);
@@ -3294,13 +3308,14 @@ connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
             (result->transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
         int i = IP_PMTUDISC_DONT;
-        setsockopt(client->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof i);
+        if (setsockopt(client->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0)
+            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << client << " : " << xstrerror());
 #else
-        static int reported = 0;
+        static bool reported = false;
 
         if (!reported) {
-            debugs(33, DBG_IMPORTANT, "Notice: httpd_accel_no_pmtu_disc not supported on your platform");
-            reported = 1;
+            debugs(33, DBG_IMPORTANT, "NOTICE: Path MTU discovery disabling is not supported on your platform.");
+            reported = true;
         }
 #endif
     }
@@ -3625,8 +3640,8 @@ httpsSslBumpAccessCheckDone(allow_t answer, void *data)
         // fake a CONNECT request to force connState to tunnel
         static char ip[MAX_IPSTRLEN];
         static char reqStr[MAX_IPSTRLEN + 80];
-        connState->clientConnection->local.NtoA(ip, sizeof(ip));
-        snprintf(reqStr, sizeof(reqStr), "CONNECT %s:%d HTTP/1.1\r\nHost: %s\r\n\r\n", ip, connState->clientConnection->local.GetPort(), ip);
+        connState->clientConnection->local.ToURL(ip, sizeof(ip));
+        snprintf(reqStr, sizeof(reqStr), "CONNECT %s HTTP/1.1\r\nHost: %s\r\n\r\n", ip, ip);
         bool ret = connState->handleReadData(reqStr, strlen(reqStr));
         if (ret)
             ret = connState->clientParseRequests();
@@ -3662,7 +3677,7 @@ httpsAccept(const CommAcceptCbParams &params)
     // Socket is ready, setup the connection manager to start using it
     ConnStateData *connState = connStateCreate(params.conn, s);
 
-    if (s->sslBump) {
+    if (s->flags.tunnelSslBumping) {
         debugs(33, 5, "httpsAccept: accept transparent connection: " << params.conn);
 
         if (!Config.accessList.ssl_bump) {
@@ -3745,7 +3760,7 @@ void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &cer
         if (X509 *mimicCert = sslServerBump->serverCert.get())
             certProperties.mimicCert.resetAndLock(mimicCert);
 
-        ACLFilledChecklist checklist(NULL, sslServerBump->request,
+        ACLFilledChecklist checklist(NULL, sslServerBump->request.getRaw(),
                                      clientConnection != NULL ? clientConnection->rfc931 : dash_str);
         checklist.sslErrors = cbdataReference(sslServerBump->sslErrors);
 
@@ -3823,16 +3838,17 @@ ConnStateData::getSslContextStart()
 
         debugs(33, 5, HERE << "Finding SSL certificate for " << sslBumpCertKey << " in cache");
         Ssl::LocalContextStorage & ssl_ctx_cache(Ssl::TheGlobalContextStorage.getLocalStorage(port->s));
-        SSL_CTX * dynCtx = ssl_ctx_cache.find(sslBumpCertKey.termedBuf());
-        if (dynCtx) {
+        SSL_CTX * dynCtx = NULL;
+        Ssl::SSL_CTX_Pointer *cachedCtx = ssl_ctx_cache.get(sslBumpCertKey.termedBuf());
+        if (cachedCtx && (dynCtx = cachedCtx->get())) {
             debugs(33, 5, HERE << "SSL certificate for " << sslBumpCertKey << " have found in cache");
             if (Ssl::verifySslCertificate(dynCtx, certProperties)) {
                 debugs(33, 5, HERE << "Cached SSL certificate for " << sslBumpCertKey << " is valid");
                 getSslContextDone(dynCtx);
                 return;
             } else {
                 debugs(33, 5, HERE << "Cached SSL certificate for " << sslBumpCertKey << " is out of date. Delete this certificate from cache");
-                ssl_ctx_cache.remove(sslBumpCertKey.termedBuf());
+                ssl_ctx_cache.del(sslBumpCertKey.termedBuf());
             }
         } else {
             debugs(33, 5, HERE << "SSL certificate for " << sslBumpCertKey << " haven't found in cache");
@@ -3877,7 +3893,7 @@ ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew)
         Ssl::LocalContextStorage & ssl_ctx_cache(Ssl::TheGlobalContextStorage.getLocalStorage(port->s));
         assert(sslBumpCertKey.defined() && sslBumpCertKey[0] != '\0');
         if (sslContext) {
-            if (!ssl_ctx_cache.add(sslBumpCertKey.termedBuf(), sslContext)) {
+            if (!ssl_ctx_cache.add(sslBumpCertKey.termedBuf(), new Ssl::SSL_CTX_Pointer(sslContext))) {
                 // If it is not in storage delete after using. Else storage deleted it.
                 fd_table[clientConnection->fd].dynamicSslContext = sslContext;
             }
@@ -3898,8 +3914,7 @@ ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew)
         }
     }
 
-    SSL *ssl = NULL;
-    if (!(ssl = httpsCreate(clientConnection, sslContext)))
+    if (!httpsCreate(clientConnection, sslContext))
         return;
 
     // commSetConnTimeout() was called for this request before we switched.
@@ -3926,11 +3941,11 @@ ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode)
     // and now want to switch to SSL to send the error to the client
     // without even peeking at the origin server certificate.
     if (bumpServerMode == Ssl::bumpServerFirst && !sslServerBump) {
-        request->flags.sslPeek = 1;
+        request->flags.sslPeek = true;
         sslServerBump = new Ssl::ServerBump(request);
 
         // will call httpsPeeked() with certificate and connection, eventually
-        FwdState::fwdStart(clientConnection, sslServerBump->entry, sslServerBump->request);
+        FwdState::fwdStart(clientConnection, sslServerBump->entry, sslServerBump->request.getRaw());
         return;
     }
 
@@ -3959,7 +3974,7 @@ ConnStateData::httpsPeeked(Comm::ConnectionPointer serverConnection)
         debugs(33, 5, HERE << "Error while bumping: " << sslConnectHostOrIp);
         Ip::Address intendedDest;
         intendedDest = sslConnectHostOrIp.termedBuf();
-        const bool isConnectRequest = !port->spoof_client_ip && !port->intercepted;
+        const bool isConnectRequest = !port->flags.isIntercepted();
 
         // Squid serves its own error page and closes, so we want
         // a CN that causes no additional browser errors. Possible
@@ -4021,16 +4036,18 @@ clientHttpConnectionsOpen(void)
         }
 
 #if USE_SSL
-        if (s->sslBump && !Config.accessList.ssl_bump) {
+        if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
             debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << s->protocol << "_port " << s->s);
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
 
-        if (s->sslBump && !s->staticSslContext && !s->generateHostCertificates) {
+        if (s->flags.tunnelSslBumping &&
+                !s->staticSslContext &&
+                !s->generateHostCertificates) {
             debugs(1, DBG_IMPORTANT, "Will not bump SSL at http_port " << s->s << " due to SSL initialization failure.");
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
-        if (s->sslBump) {
+        if (s->flags.tunnelSslBumping) {
             // Create ssl_ctx cache for this port.
             Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
         }
@@ -4040,7 +4057,7 @@ clientHttpConnectionsOpen(void)
         //  then pass back when active so we can start a TcpAcceptor subscription.
         s->listenConn = new Comm::Connection;
         s->listenConn->local = s->s;
-        s->listenConn->flags = COMM_NONBLOCKING | (s->spoof_client_ip ? COMM_TRANSPARENT : 0) | (s->intercepted ? COMM_INTERCEPTION : 0);
+        s->listenConn->flags = COMM_NONBLOCKING | (s->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) | (s->flags.natIntercept ? COMM_INTERCEPTION : 0);
 
         // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
@@ -4076,26 +4093,26 @@ clientHttpsConnectionsOpen(void)
         }
 
         // TODO: merge with similar code in clientHttpConnectionsOpen()
-        if (s->sslBump && !Config.accessList.ssl_bump) {
+        if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
             debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << s->protocol << "_port " << s->s);
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
 
-        if (s->sslBump && !s->staticSslContext && !s->generateHostCertificates) {
+        if (s->flags.tunnelSslBumping && !s->staticSslContext && !s->generateHostCertificates) {
             debugs(1, DBG_IMPORTANT, "Will not bump SSL at http_port " << s->s << " due to SSL initialization failure.");
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
 
-        if (s->sslBump) {
+        if (s->flags.tunnelSslBumping) {
             // Create ssl_ctx cache for this port.
             Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
         }
 
         // Fill out a Comm::Connection which IPC will open as a listener for us
         s->listenConn = new Comm::Connection;
         s->listenConn->local = s->s;
-        s->listenConn->flags = COMM_NONBLOCKING | (s->spoof_client_ip ? COMM_TRANSPARENT : 0) |
-                               (s->intercepted ? COMM_INTERCEPTION : 0);
+        s->listenConn->flags = COMM_NONBLOCKING | (s->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
+                               (s->flags.natIntercept ? COMM_INTERCEPTION : 0);
 
         // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
@@ -4126,10 +4143,10 @@ clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNot
     AsyncJob::Start(new Comm::TcpAcceptor(s->listenConn, FdNote(portTypeNote), sub));
 
     debugs(1, DBG_IMPORTANT, "Accepting " <<
-           (s->intercepted ? "NAT intercepted " : "") <<
-           (s->spoof_client_ip ? "TPROXY spoofing " : "") <<
-           (s->sslBump ? "SSL bumped " : "") <<
-           (s->accel ? "reverse-proxy " : "")
+           (s->flags.natIntercept ? "NAT intercepted " : "") <<
+           (s->flags.tproxyIntercept ? "TPROXY spoofing " : "") <<
+           (s->flags.tunnelSslBumping ? "SSL bumped " : "") <<
+           (s->flags.accelSurrogate ? "reverse-proxy " : "")
            << FdNote(portTypeNote) << " connections at "
            << s->listenConn);
 
@@ -4267,8 +4284,12 @@ ConnStateData::ConnStateData() :
         stoppedSending_(NULL),
         stoppedReceiving_(NULL)
 {
+    pinning.host = NULL;
+    pinning.port = -1;
     pinning.pinned = false;
     pinning.auth = false;
+    pinning.zeroReply = false;
+    pinning.peer = NULL;
 }
 
 bool
@@ -4424,9 +4445,13 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
 {
     // FwdState might repin a failed connection sooner than this close
     // callback is called for the failed connection.
-    if (pinning.serverConnection == io.conn) {
-        pinning.closeHandler = NULL; // Comm unregisters handlers before calling
-        unpinConnection();
+    assert(pinning.serverConnection == io.conn);
+    pinning.closeHandler = NULL; // Comm unregisters handlers before calling
+    const bool sawZeroReply = pinning.zeroReply; // reset when unpinning
+    unpinConnection();
+    if (sawZeroReply) {
+        debugs(33, 3, "Closing client connection on pinned zero reply.");
+        clientConnection->close();
     }
 }
 
@@ -4525,6 +4550,8 @@ ConnStateData::unpinConnection()
 
     safe_free(pinning.host);
 
+    pinning.zeroReply = false;
+
     /* NOTE: pinning.pinned should be kept. This combined with fd == -1 at the end of a request indicates that the host
      * connection has gone away */
 }
@@ -264,6 +264,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         int port;               /* port of pinned connection */
         bool pinned;             /* this connection was pinned */
         bool auth;               /* pinned for www authentication */
+        bool zeroReply; ///< server closed w/o response (ERR_ZERO_SIZE_OBJECT)
         CachePeer *peer;             /* CachePeer the connection goes via */
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
@@ -76,7 +76,7 @@ CBDATA_CLASS_INIT(clientReplyContext);
 
 /* Local functions */
 extern "C" CSS clientReplyStatus;
-ErrorState *clientBuildError(err_type, http_status, char const *, Ip::Address &, HttpRequest *);
+ErrorState *clientBuildError(err_type, Http::StatusCode, char const *, Ip::Address &, HttpRequest *);
 
 /* privates */
 
@@ -105,7 +105,7 @@ clientReplyContext::clientReplyContext(ClientHttpRequest *clientContext) : http
  */
 void
 clientReplyContext::setReplyToError(
-    err_type err, http_status status, const HttpRequestMethod& method, char const *uri,
+    err_type err, Http::StatusCode status, const HttpRequestMethod& method, char const *uri,
     Ip::Address &addr, HttpRequest * failedrequest, const char *unparsedrequest,
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request
@@ -127,9 +127,9 @@ clientReplyContext::setReplyToError(
 
 void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorState *errstate)
 {
-    if (errstate->httpStatus == HTTP_NOT_IMPLEMENTED && http->request)
+    if (errstate->httpStatus == Http::scNotImplemented && http->request)
         /* prevent confusion over whether we default to persistent or not */
-        http->request->flags.proxyKeepalive = 0;
+        http->request->flags.proxyKeepalive = false;
 
     http->al->http.code = errstate->httpStatus;
 
@@ -258,7 +258,7 @@ clientReplyContext::triggerInitialStoreRead()
 void
 clientReplyContext::processExpired()
 {
-    char *url = http->uri;
+    const char *url = storeId();
     StoreEntry *entry = NULL;
     debugs(88, 3, "clientReplyContext::processExpired: '" << http->uri << "'");
     assert(http->storeEntry()->lastmod >= 0);
@@ -273,7 +273,7 @@ clientReplyContext::processExpired()
         return;
     }
 
-    http->request->flags.refresh = 1;
+    http->request->flags.refresh = true;
 #if STORE_CLIENT_LIST_DEBUG
     /* Prevent a race with the store client memory free routines
      */
@@ -376,7 +376,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
     /* update size of the request */
     reqsize = result.length + reqofs;
 
-    const http_status status = http->storeEntry()->getReply()->sline.status;
+    const Http::StatusCode status = http->storeEntry()->getReply()->sline.status();
 
     // request to origin was aborted
     if (EBIT_TEST(http->storeEntry()->flags, ENTRY_ABORTED)) {
@@ -388,9 +388,9 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
     HttpReply *old_rep = (HttpReply *) old_entry->getReply();
 
     // origin replied 304
-    if (status == HTTP_NOT_MODIFIED) {
+    if (status == Http::scNotModified) {
         http->logType = LOG_TCP_REFRESH_UNMODIFIED;
-        http->request->flags.staleIfHit = 0; // old_entry is no longer stale
+        http->request->flags.staleIfHit = false; // old_entry is no longer stale
 
         // update headers on existing entry
         old_rep->updateOnNotModified(http->storeEntry()->getReply());
@@ -405,13 +405,13 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
         } else {
             // send existing entry, it's still valid
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and sending " <<
-                   old_rep->sline.status << " to client");
+                   old_rep->sline.status() << " to client");
             sendClientOldEntry();
         }
     }
 
     // origin replied with a non-error code
-    else if (status > HTTP_STATUS_NONE && status < HTTP_INTERNAL_SERVER_ERROR) {
+    else if (status > Http::scNone && status < Http::scInternalServerError) {
         // forward response from origin
         http->logType = LOG_TCP_REFRESH_MODIFIED;
         debugs(88, 3, "handleIMSReply: origin replied " << status << ", replacing existing entry and forwarding to client");
@@ -428,7 +428,7 @@ clientReplyContext::handleIMSReply(StoreIOBuffer result)
         // ignore and let client have old entry
         http->logType = LOG_TCP_REFRESH_FAIL_OLD;
         debugs(88, 3, "handleIMSReply: origin replied with error " <<
-               status << ", sending old entry (" << old_rep->sline.status << ") to client");
+               status << ", sending old entry (" << old_rep->sline.status() << ") to client");
         sendClientOldEntry();
     }
 }
@@ -497,8 +497,8 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
      */
     assert(http->logType == LOG_TCP_HIT);
 
-    if (strcmp(e->mem_obj->url, urlCanonical(r)) != 0) {
-        debugs(33, DBG_IMPORTANT, "clientProcessHit: URL mismatch, '" << e->mem_obj->url << "' != '" << urlCanonical(r) << "'");
+    if (strcmp(e->mem_obj->url, http->request->storeId()) != 0) {
+        debugs(33, DBG_IMPORTANT, "clientProcessHit: URL mismatch, '" << e->mem_obj->url << "' != '" << http->request->storeId() << "'");
         processMiss();
         return;
     }
@@ -558,29 +558,33 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
          * request.  Otherwise two siblings could generate a loop if
          * both have a stale version of the object.
          */
-        r->flags.needValidation = 1;
+        r->flags.needValidation = true;
 
         if (e->lastmod < 0) {
+            debugs(88, 3, "validate HIT object? NO. Missing Last-Modified header. Do MISS.");
             /*
              * Previous reply didn't have a Last-Modified header,
              * we cannot revalidate it.
              */
             http->logType = LOG_TCP_MISS;
             processMiss();
         } else if (r->flags.noCache) {
+            debugs(88, 3, "validate HIT object? NO. Client sent CC:no-cache. Do CLIENT_REFRESH_MISS");
             /*
              * This did not match a refresh pattern that overrides no-cache
              * we should honour the client no-cache header.
              */
             http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
             processMiss();
         } else if (r->protocol == AnyP::PROTO_HTTP) {
+            debugs(88, 3, "validate HIT object? YES.");
             /*
              * Object needs to be revalidated
              * XXX This could apply to FTP as well, if Last-Modified is known.
              */
             processExpired();
         } else {
+            debugs(88, 3, "validate HIT object? NO. Client protocol non-HTTP. Do MISS.");
             /*
              * We don't know how to re-validate other protocols. Handle
              * them as if the object has expired.
@@ -627,7 +631,7 @@ clientReplyContext::processMiss()
     if (http->storeEntry()) {
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             debugs(88, DBG_CRITICAL, "clientProcessMiss: miss on a special object (" << url << ").");
-            debugs(88, DBG_CRITICAL, "\tlog_type = " << Format::log_tags[http->logType]);
+            debugs(88, DBG_CRITICAL, "\tlog_type = " << LogTags_str[http->logType]);
             http->storeEntry()->dump(1);
         }
 
@@ -653,8 +657,8 @@ clientReplyContext::processMiss()
 
     /// Deny loops
     if (r->flags.loopDetected) {
-        http->al->http.code = HTTP_FORBIDDEN;
-        err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
+        http->al->http.code = Http::scForbidden;
+        err = clientBuildError(ERR_ACCESS_DENIED, Http::scForbidden, NULL, http->getConn()->clientConnection->remote, http->request);
         createStoreEntry(r->method, RequestFlags());
         errorAppendEntry(http->storeEntry(), err);
         triggerInitialStoreRead();
@@ -697,8 +701,8 @@ clientReplyContext::processOnlyIfCachedMiss()
 {
     debugs(88, 4, "clientProcessOnlyIfCachedMiss: '" <<
            RequestMethodStr(http->request->method) << " " << http->uri << "'");
-    http->al->http.code = HTTP_GATEWAY_TIMEOUT;
-    ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, HTTP_GATEWAY_TIMEOUT, NULL,
+    http->al->http.code = Http::scGateway_Timeout;
+    ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, Http::scGateway_Timeout, NULL,
                                        http->getConn()->clientConnection->remote, http->request);
     removeClientStoreReference(&sc, http);
     startError(err);
@@ -710,9 +714,9 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
 {
     StoreEntry *const e = http->storeEntry();
 
-    if (e->getReply()->sline.status != HTTP_OK) {
+    if (e->getReply()->sline.status() != Http::scOkay) {
         debugs(88, 4, "clientReplyContext::processConditional: Reply code " <<
-               e->getReply()->sline.status << " != 200");
+               e->getReply()->sline.status() << " != 200");
         http->logType = LOG_TCP_MISS;
         processMiss();
         return;
@@ -730,7 +734,7 @@ clientReplyContext::processConditional(StoreIOBuffer &result)
     if (r.header.has(HDR_IF_NONE_MATCH)) {
         if (!e->hasIfNoneMatchEtag(r)) {
             // RFC 2616: ignore IMS if If-None-Match did not match
-            r.flags.ims = 0;
+            r.flags.ims = false;
             r.ims = -1;
             r.imslen = 0;
             r.header.delById(HDR_IF_MODIFIED_SINCE);
@@ -774,7 +778,7 @@ void
 clientReplyContext::purgeRequestFindObjectToPurge()
 {
     /* Try to find a base entry */
-    http->flags.purging = 1;
+    http->flags.purging = true;
     lookingforstore = 1;
 
     // TODO: can we use purgeAllCached() here instead of doing the
@@ -865,7 +869,7 @@ clientReplyContext::purgeFoundObject(StoreEntry *entry)
 
     if (EBIT_TEST(entry->flags, ENTRY_SPECIAL)) {
         http->logType = LOG_TCP_DENIED;
-        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL,
+        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, Http::scForbidden, NULL,
                                            http->getConn()->clientConnection->remote, http->request);
         startError(err);
         return;
@@ -876,7 +880,7 @@ clientReplyContext::purgeFoundObject(StoreEntry *entry)
     http->storeEntry(entry);
 
     http->storeEntry()->lock();
-    http->storeEntry()->createMemObject(http->uri, http->log_uri);
+    http->storeEntry()->createMemObject(storeId(), http->log_uri);
 
     http->storeEntry()->mem_obj->method = http->request->method;
 
@@ -904,7 +908,7 @@ clientReplyContext::purgeRequest()
 
     if (!Config2.onoff.enable_purge) {
         http->logType = LOG_TCP_DENIED;
-        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
+        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, Http::scForbidden, NULL, http->getConn()->clientConnection->remote, http->request);
         startError(err);
         return;
     }
@@ -931,7 +935,7 @@ clientReplyContext::purgeDoPurgeGet(StoreEntry *newEntry)
 {
     assert (newEntry);
     /* Move to new() when that is created */
-    purgeStatus = HTTP_NOT_FOUND;
+    purgeStatus = Http::scNotFound;
 
     if (!newEntry->isNull()) {
         /* Release the cached URI */
@@ -940,7 +944,7 @@ clientReplyContext::purgeDoPurgeGet(StoreEntry *newEntry)
         neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(Http::METHOD_GET), HTCP_CLR_PURGE);
 #endif
         newEntry->release();
-        purgeStatus = HTTP_OK;
+        purgeStatus = Http::scOkay;
     }
 
     lookingforstore = 4;
@@ -956,7 +960,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
         neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_PURGE);
 #endif
         newEntry->release();
-        purgeStatus = HTTP_OK;
+        purgeStatus = Http::scOkay;
     }
 
     /* And for Vary, release the base URI if none of the headers was included in the request */
@@ -971,7 +975,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
             neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(Http::METHOD_GET), HTCP_CLR_PURGE);
 #endif
             entry->release();
-            purgeStatus = HTTP_OK;
+            purgeStatus = Http::scOkay;
         }
 
         entry = storeGetPublic(urlCanonical(http->request), Http::METHOD_HEAD);
@@ -982,7 +986,7 @@ clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
             neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_PURGE);
 #endif
             entry->release();
-            purgeStatus = HTTP_OK;
+            purgeStatus = Http::scOkay;
         }
     }
 
@@ -1017,7 +1021,7 @@ clientReplyContext::traceReply(clientStreamNode * node)
     http->storeEntry()->releaseRequest();
     http->storeEntry()->buffer();
     HttpReply *rep = new HttpReply;
-    rep->setHeaders(HTTP_OK, NULL, "text/plain", http->request->prefixLen(), 0, squid_curtime);
+    rep->setHeaders(Http::scOkay, NULL, "text/plain", http->request->prefixLen(), 0, squid_curtime);
     http->storeEntry()->replaceHttpReply(rep);
     http->request->swapOut(http->storeEntry());
     http->storeEntry()->complete();
@@ -1228,21 +1232,21 @@ clientReplyContext::replyStatus()
  * mysterious breakages.
  */
 bool
-clientReplyContext::alwaysAllowResponse(http_status sline) const
+clientReplyContext::alwaysAllowResponse(Http::StatusCode sline) const
 {
     bool result;
 
     switch (sline) {
 
-    case HTTP_CONTINUE:
+    case Http::scContinue:
 
-    case HTTP_SWITCHING_PROTOCOLS:
+    case Http::scSwitchingProtocols:
 
-    case HTTP_PROCESSING:
+    case Http::scProcessing:
 
-    case HTTP_NO_CONTENT:
+    case Http::scNoContent:
 
-    case HTTP_NOT_MODIFIED:
+    case Http::scNotModified:
         result = true;
         break;
 
@@ -1301,15 +1305,6 @@ clientReplyContext::buildReplyHeader()
          * age calculation is performed by adjusting the timestamp in
          * StoreEntry::timestampsSet(), not here.
          */
-#if DEAD_CODE
-        // XXX: realy useless? or is there a bug now that this is detatched from the below if-sequence ?
-        // looks like this pre-if was supposed to be the browser workaround...
-        if (NULL == http->storeEntry())
-            (void) 0;
-        else if (http->storeEntry()->timestamp < 0)
-            (void) 0;
-#endif
-
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             hdr->delById(HDR_DATE);
             hdr->insertTime(HDR_DATE, squid_curtime);
@@ -1403,7 +1398,7 @@ clientReplyContext::buildReplyHeader()
                         hdr->delAt(pos, connection_auth_blocked);
                         continue;
                     }
-                    request->flags.mustKeepalive = 1;
+                    request->flags.mustKeepalive = true;
                     if (!request->flags.accelerated && !request->flags.intercepted) {
                         httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
@@ -1426,8 +1421,8 @@ clientReplyContext::buildReplyHeader()
 #if USE_AUTH
     /* Handle authentication headers */
     if (http->logType == LOG_TCP_DENIED &&
-            ( reply->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED ||
-              reply->sline.status == HTTP_UNAUTHORIZED)
+            ( reply->sline.status() == Http::scProxyAuthenticationRequired ||
+              reply->sline.status() == Http::scUnauthorized)
        ) {
         /* Add authentication header */
         /*! \todo alter errorstate to be accel on|off aware. The 0 on the next line
@@ -1454,39 +1449,43 @@ clientReplyContext::buildReplyHeader()
 
     const bool maySendChunkedReply = !request->multipartRangeRequest() &&
                                      reply->sline.protocol == AnyP::PROTO_HTTP && // response is HTTP
-                                     (request->http_ver >= HttpVersion(1, 1));
+                                     (request->http_ver >= Http::ProtocolVersion(1, 1));
 
     /* Check whether we should send keep-alive */
-    if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.mustKeepalive) {
+    if (!Config.onoff.error_pconns && reply->sline.status() >= 400 && !request->flags.mustKeepalive) {
         debugs(33, 3, "clientBuildReplyHeader: Error, don't keep-alive");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (!Config.onoff.client_pconns && !request->flags.mustKeepalive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection Keep-Alive not requested by admin or client");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->flags.proxyKeepalive && shutting_down) {
         debugs(88, 3, "clientBuildReplyHeader: Shutting down, don't keep-alive.");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->flags.connectionAuth && !reply->keep_alive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection oriented auth but server side non-persistent");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (reply->bodySize(request->method) < 0 && !maySendChunkedReply) {
         debugs(88, 3, "clientBuildReplyHeader: can't keep-alive, unknown body size" );
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (fdUsageHigh()&& !request->flags.mustKeepalive) {
         debugs(88, 3, "clientBuildReplyHeader: Not many unused FDs, can't keep-alive");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->flags.sslBumped && !reply->persistent()) {
         // We do not really have to close, but we pretend we are a tunnel.
         debugs(88, 3, "clientBuildReplyHeader: bumped reply forces close");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
+    } else if (request->pinnedConnection() && !reply->persistent()) {
+        // The peer wants to close the pinned connection
+        debugs(88, 3, "pinned reply forces close");
+        request->flags.proxyKeepalive = false;
     }
 
     // Decide if we send chunked reply
     if (maySendChunkedReply &&
             request->flags.proxyKeepalive &&
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
-        request->flags.chunkedReply = 1;
+        request->flags.chunkedReply = true;
         hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
     }
 
@@ -1534,13 +1533,12 @@ clientReplyContext::cloneReply()
 {
     assert(reply == NULL);
 
-    HttpReply *rep = http->storeEntry()->getReply()->clone();
-
-    reply = HTTPMSGLOCK(rep);
+    reply = http->storeEntry()->getReply()->clone();
+    HTTPMSGLOCK(reply);
 
     if (reply->sline.protocol == AnyP::PROTO_HTTP) {
         /* RFC 2616 requires us to advertise our 1.1 version (but only on real HTTP traffic) */
-        reply->sline.version = HttpVersion(1,1);
+        reply->sline.version = Http::ProtocolVersion(1,1);
     }
 
     /* do header conversions */
@@ -1753,8 +1751,13 @@ clientReplyContext::doGetMoreData()
              * is a cache hit for a GET response, we want to keep
              * the method as GET.
              */
-            http->storeEntry()->createMemObject(http->uri, http->log_uri);
+            http->storeEntry()->createMemObject(storeId(), http->log_uri);
             http->storeEntry()->mem_obj->method = http->request->method;
+            /**
+             * Here we can see if the object was
+             * created using URL or alternative StoreID from helper.
+             */
+            debugs(88, 3, "mem_obj->url: " << http->storeEntry()->mem_obj->url);
         }
 
         sc = storeClientListAdd(http->storeEntry(), this);
@@ -1833,7 +1836,7 @@ clientReplyContext::sendStreamError(StoreIOBuffer const &result)
     debugs(88, 5, "clientReplyContext::sendStreamError: A stream error has occured, marking as complete and sending no data.");
     StoreIOBuffer localTempBuffer;
     flags.complete = 1;
-    http->request->flags.streamError = 1;
+    http->request->flags.streamError = true;
     localTempBuffer.flags.error = result.flags.error;
     clientStreamCallback((clientStreamNode*)http->client_stream.head->data, http, NULL,
                          localTempBuffer);
@@ -1873,7 +1876,7 @@ clientReplyContext::sendBodyTooLargeError()
     Ip::Address tmp_noaddr;
     tmp_noaddr.SetNoAddr(); // TODO: make a global const
     http->logType = LOG_TCP_DENIED_REPLY;
-    ErrorState *err = clientBuildError(ERR_TOO_BIG, HTTP_FORBIDDEN, NULL,
+    ErrorState *err = clientBuildError(ERR_TOO_BIG, Http::scForbidden, NULL,
                                        http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmp_noaddr,
                                        http->request);
     removeClientStoreReference(&(sc), http);
@@ -1888,7 +1891,7 @@ clientReplyContext::sendPreconditionFailedError()
 {
     http->logType = LOG_TCP_HIT;
     ErrorState *const err =
-        clientBuildError(ERR_PRECONDITION_FAILED, HTTP_PRECONDITION_FAILED,
+        clientBuildError(ERR_PRECONDITION_FAILED, Http::scPreconditionFailed,
                          NULL, http->getConn()->clientConnection->remote, http->request);
     removeClientStoreReference(&sc, http);
     HTTPMSGUNLOCK(reply);
@@ -1941,7 +1944,7 @@ clientReplyContext::processReplyAccess ()
     /** Don't block our own responses or HTTP status messages */
     if (http->logType == LOG_TCP_DENIED ||
             http->logType == LOG_TCP_DENIED_REPLY ||
-            alwaysAllowResponse(reply->sline.status)) {
+            alwaysAllowResponse(reply->sline.status())) {
         headers_sz = reply->hdr_sz;
         processReplyAccessResult(ACCESS_ALLOWED);
         return;
@@ -1964,7 +1967,8 @@ clientReplyContext::processReplyAccess ()
     /** Process http_reply_access lists */
     ACLFilledChecklist *replyChecklist =
         clientAclChecklistCreate(Config.accessList.reply, http);
-    replyChecklist->reply = HTTPMSGLOCK(reply);
+    replyChecklist->reply = reply;
+    HTTPMSGLOCK(replyChecklist->reply);
     replyChecklist->nonBlockingCheck(ProcessReplyAccessResult, this);
 }
 
@@ -1994,7 +1998,7 @@ clientReplyContext::processReplyAccessResult(const allow_t &accessAllowed)
 
         Ip::Address tmp_noaddr;
         tmp_noaddr.SetNoAddr();
-        err = clientBuildError(page_id, HTTP_FORBIDDEN, NULL,
+        err = clientBuildError(page_id, Http::scForbidden, NULL,
                                http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmp_noaddr,
                                http->request);
 
@@ -2022,8 +2026,8 @@ clientReplyContext::processReplyAccessResult(const allow_t &accessAllowed)
 
 #if USE_SQUID_ESI
 
-    if (http->flags.accel && reply->sline.status != HTTP_FORBIDDEN &&
-            !alwaysAllowResponse(reply->sline.status) &&
+    if (http->flags.accel && reply->sline.status() != Http::scForbidden &&
+            !alwaysAllowResponse(reply->sline.status()) &&
             esiEnableProcessing(reply)) {
         debugs(88, 2, "Enabling ESI processing for " << http->uri);
         clientStreamInsertHead(&http->client_stream, esiStreamRead,
@@ -2035,7 +2039,7 @@ clientReplyContext::processReplyAccessResult(const allow_t &accessAllowed)
     if (http->request->method == Http::METHOD_HEAD) {
         /* do not forward body for HEAD replies */
         body_size = 0;
-        http->flags.done_copying = 1;
+        http->flags.done_copying = true;
         flags.complete = 1;
     }
 
@@ -2084,10 +2088,18 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
 
     ConnStateData * conn = http->getConn();
 
-    if (conn == NULL || !conn->isOpen()) {
-        // too late, our conn is closing
-        // TODO: should we also quit?
-        debugs(33,3, HERE << "not sending more data to a closing " << conn->clientConnection);
+    // too late, our conn is closing
+    // TODO: should we also quit?
+    if (conn == NULL) {
+        debugs(33,3, "not sending more data to a closed connection" );
+        return;
+    }
+    if (!conn->isOpen()) {
+        debugs(33,3, "not sending more data to closing connection " << conn->clientConnection);
+        return;
+    }
+    if (conn->pinning.zeroReply) {
+        debugs(33,3, "not sending more data after a pinned zero reply " << conn->clientConnection);
         return;
     }
 
@@ -2174,10 +2186,12 @@ clientReplyContext::createStoreEntry(const HttpRequestMethod& m, RequestFlags re
      * so make a fake one.
      */
 
-    if (http->request == NULL)
-        http->request = HTTPMSGLOCK(new HttpRequest(m, AnyP::PROTO_NONE, null_string));
+    if (http->request == NULL) {
+        http->request = new HttpRequest(m, AnyP::PROTO_NONE, null_string);
+        HTTPMSGLOCK(http->request);
+    }
 
-    StoreEntry *e = storeCreateEntry(http->uri, http->log_uri, reqFlags, m);
+    StoreEntry *e = storeCreateEntry(storeId(), http->log_uri, reqFlags, m);
 
     sc = storeClientListAdd(e, this);
 
@@ -2208,7 +2222,7 @@ clientReplyContext::createStoreEntry(const HttpRequestMethod& m, RequestFlags re
 }
 
 ErrorState *
-clientBuildError(err_type page_id, http_status status, char const *url,
+clientBuildError(err_type page_id, Http::StatusCode status, char const *url,
                  Ip::Address &src_addr, HttpRequest * request)
 {
     ErrorState *err = new ErrorState(page_id, status, request);
@@ -75,7 +75,7 @@ class clientReplyContext : public RefCountable, public StoreClient
     /// replaces current response store entry with the given one
     void setReplyToStoreEntry(StoreEntry *e);
     /// builds error using clientBuildError() and calls setReplyToError() below
-    void setReplyToError(err_type, http_status, const HttpRequestMethod&, char const *, Ip::Address &, HttpRequest *, const char *,
+    void setReplyToError(err_type, Http::StatusCode, const HttpRequestMethod&, char const *, Ip::Address &, HttpRequest *, const char *,
 #if USE_AUTH
                          Auth::UserRequest::Pointer);
 #else
@@ -91,8 +91,9 @@ class clientReplyContext : public RefCountable, public StoreClient
     clientStream_status_t replyStatus();
     void processMiss();
     void traceReply(clientStreamNode * node);
+    const char *storeId() const { return (http->store_id.size() > 0 ? http->store_id.termedBuf() : http->uri); }
 
-    http_status purgeStatus;
+    Http::StatusCode purgeStatus;
 
     /* state variable - replace with class to handle storeentries at some point */
     int lookingforstore;
@@ -134,7 +135,7 @@ class clientReplyContext : public RefCountable, public StoreClient
     void processReplyAccessResult(const allow_t &accessAllowed);
     void cloneReply();
     void buildReplyHeader ();
-    bool alwaysAllowResponse(http_status sline) const;
+    bool alwaysAllowResponse(Http::StatusCode sline) const;
     int checkTransferDone();
     void processOnlyIfCachedMiss();
     void processConditional(StoreIOBuffer &result);
@@ -103,7 +103,7 @@ static const char *const crlf = "\r\n";
 static void clientFollowXForwardedForCheck(allow_t answer, void *data);
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-ErrorState *clientBuildError(err_type, http_status, char const *url, Ip::Address &, HttpRequest *);
+ErrorState *clientBuildError(err_type, Http::StatusCode, char const *url, Ip::Address &, HttpRequest *);
 
 CBDATA_CLASS_INIT(ClientRequestContext);
 
@@ -132,6 +132,7 @@ static void sslBumpAccessCheckDoneWrapper(allow_t, void *);
 static int clientHierarchical(ClientHttpRequest * http);
 static void clientInterpretRequestHeaders(ClientHttpRequest * http);
 static HLPCB clientRedirectDoneWrapper;
+static HLPCB clientStoreIdDoneWrapper;
 static void checkNoCacheDoneWrapper(allow_t, void *);
 SQUIDCEXTERN CSR clientGetMoreData;
 SQUIDCEXTERN CSS clientReplyStatus;
@@ -152,11 +153,13 @@ ClientRequestContext::~ClientRequestContext()
     debugs(85,3, HERE << this << " ClientRequestContext destructed");
 }
 
-ClientRequestContext::ClientRequestContext(ClientHttpRequest *anHttp) : http(cbdataReference(anHttp)), acl_checklist (NULL), redirect_state (REDIRECT_NONE), error(NULL), readNextRequest(false)
+ClientRequestContext::ClientRequestContext(ClientHttpRequest *anHttp) : http(cbdataReference(anHttp)), acl_checklist (NULL), redirect_state (REDIRECT_NONE), store_id_state(REDIRECT_NONE),error(NULL), readNextRequest(false)
 {
     http_access_done = false;
     redirect_done = false;
     redirect_fail_count = 0;
+    store_id_done = false;
+    store_id_fail_count = 0;
     no_cache_done = false;
     interpreted_req_hdrs = false;
 #if USE_SSL
@@ -364,7 +367,7 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
     /* Set flags */
     /* internal requests only makes sense in an
      * accelerator today. TODO: accept flags ? */
-    http->flags.accel = 1;
+    http->flags.accel = true;
     /* allow size for url rewriting */
     url_sz = strlen(url) + Config.appendDomainLen + 5;
     http->uri = (char *)xcalloc(url_sz, 1);
@@ -392,7 +395,7 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
      */
     request->flags.accelerated = http->flags.accel;
 
-    request->flags.internalClient = 1;
+    request->flags.internalClient = true;
 
     /* this is an internally created
      * request, not subject to acceleration
@@ -416,10 +419,10 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
     request->my_addr.SetPort(0);
 
     /* Our version is HTTP/1.1 */
-    HttpVersion http_ver(1,1);
-    request->http_ver = http_ver;
+    request->http_ver = Http::ProtocolVersion(1,1);
 
-    http->request = HTTPMSGLOCK(request);
+    http->request = request;
+    HTTPMSGLOCK(http->request);
 
     /* optional - skip the access check ? */
     http->calloutContext = new ClientRequestContext(http);
@@ -537,7 +540,7 @@ clientFollowXForwardedForCheck(allow_t answer, void *data)
         conn->log_addr = request->indirect_client_addr;
     }
     request->x_forwarded_for_iterator.clean();
-    request->flags.done_follow_x_forwarded_for=true;
+    request->flags.done_follow_x_forwarded_for = true;
 
     if (answer != ACCESS_ALLOWED && answer != ACCESS_DENIED) {
         debugs(28, DBG_CRITICAL, "ERROR: Processing X-Forwarded-For. Stopping at IP address: " << request->indirect_client_addr );
@@ -568,7 +571,7 @@ ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLooku
         for (int i = 0; i < ia->count; ++i) {
             if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                 debugs(85, 3, HERE << "validate IP " << clientConn->local << " possible from Host:");
-                http->request->flags.hostVerified = 1;
+                http->request->flags.hostVerified = true;
                 http->doCallouts();
                 return;
             }
@@ -590,9 +593,9 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
 
         // NP: it is tempting to use 'flags.noCache' but that is all about READing cache data.
         // The problems here are about WRITE for new cache content, which means flags.cachable
-        http->request->flags.cachable = 0; // MUST NOT cache (for now)
+        http->request->flags.cachable = false; // MUST NOT cache (for now)
         // XXX: when we have updated the cache key to base on raw-IP + URI this cacheable limit can go.
-        http->request->flags.hierarchical = 0; // MUST NOT pass to peers (for now)
+        http->request->flags.hierarchical = false; // MUST NOT pass to peers (for now)
         // XXX: when we have sorted out the best way to relay requests properly to peers this hierarchical limit can go.
         http->doCallouts();
         return;
@@ -607,7 +610,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
     clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
     assert (repContext);
-    repContext->setReplyToError(ERR_CONFLICT_HOST, HTTP_CONFLICT,
+    repContext->setReplyToError(ERR_CONFLICT_HOST, Http::scConflict,
                                 http->request->method, NULL,
                                 http->getConn()->clientConnection->remote,
                                 http->request,
@@ -702,7 +705,7 @@ ClientRequestContext::hostHeaderVerify()
     } else {
         // Okay no problem.
         debugs(85, 3, HERE << "validate passed.");
-        http->request->flags.hostVerified = 1;
+        http->request->flags.hostVerified = true;
         http->doCallouts();
     }
     safe_free(hostB);
@@ -773,7 +776,7 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 {
     acl_checklist = NULL;
     err_type page_id;
-    http_status status;
+    Http::StatusCode status;
     debugs(85, 2, "The request " <<
            RequestMethodStr(http->request->method) << " " <<
            http->uri << " is " << answer <<
@@ -815,22 +818,22 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 #if USE_AUTH
             if (http->request->flags.sslBumped) {
                 /*SSL Bumped request, authentication is not possible*/
-                status = HTTP_FORBIDDEN;
+                status = Http::scForbidden;
             } else if (!http->flags.accel) {
                 /* Proxy authorisation needed */
-                status = HTTP_PROXY_AUTHENTICATION_REQUIRED;
+                status = Http::scProxyAuthenticationRequired;
             } else {
                 /* WWW authorisation needed */
-                status = HTTP_UNAUTHORIZED;
+                status = Http::scUnauthorized;
             }
 #else
             // need auth, but not possible to do.
-            status = HTTP_FORBIDDEN;
+            status = Http::scForbidden;
 #endif
             if (page_id == ERR_NONE)
                 page_id = ERR_CACHE_ACCESS_DENIED;
         } else {
-            status = HTTP_FORBIDDEN;
+            status = Http::scForbidden;
 
             if (page_id == ERR_NONE)
                 page_id = ERR_ACCESS_DENIED;
@@ -920,6 +923,44 @@ ClientRequestContext::clientRedirectStart()
         redirectStart(http, clientRedirectDoneWrapper, this);
 }
 
+/**
+ * This methods handles Access checks result of StoreId access list.
+ * Will handle as "ERR" (no change) in a case Access is not allowed.
+ */
+static void
+clientStoreIdAccessCheckDone(allow_t answer, void *data)
+{
+    ClientRequestContext *context = static_cast<ClientRequestContext *>(data);
+    ClientHttpRequest *http = context->http;
+    context->acl_checklist = NULL;
+
+    if (answer == ACCESS_ALLOWED)
+        storeIdStart(http, clientStoreIdDoneWrapper, context);
+    else {
+        debugs(85, 3, "access denied expected ERR reply handling: " << answer);
+        HelperReply nilReply;
+        nilReply.result = HelperReply::Error;
+        context->clientStoreIdDone(nilReply);
+    }
+}
+
+/**
+ * Start locating an alternative storeage ID string (if any) from admin
+ * configured helper program. This is an asynchronous operation terminating in
+ * ClientRequestContext::clientStoreIdDone() when completed.
+ */
+void
+ClientRequestContext::clientStoreIdStart()
+{
+    debugs(33, 5,"'" << http->uri << "'");
+
+    if (Config.accessList.store_id) {
+        acl_checklist = clientAclChecklistCreate(Config.accessList.store_id, http);
+        acl_checklist->nonBlockingCheck(clientStoreIdAccessCheckDone, this);
+    } else
+        storeIdStart(http, clientStoreIdDoneWrapper, this);
+}
+
 static int
 clientHierarchical(ClientHttpRequest * http)
 {
@@ -990,10 +1031,10 @@ clientCheckPinning(ClientHttpRequest * http)
     if (!request->flags.connectionAuthDisabled) {
         if (Comm::IsConnOpen(http_conn->pinning.serverConnection)) {
             if (http_conn->pinning.auth) {
-                request->flags.connectionAuth = 1;
-                request->flags.auth = 1;
+                request->flags.connectionAuth = true;
+                request->flags.auth = true;
             } else {
-                request->flags.connectionProxyAuth = 1;
+                request->flags.connectionProxyAuth = true;
             }
             // These should already be linked correctly.
             assert(request->clientConnectionManager == http_conn);
@@ -1019,10 +1060,10 @@ clientCheckPinning(ClientHttpRequest * http)
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
                         if (e->id == HDR_AUTHORIZATION) {
-                            request->flags.connectionAuth = 1;
+                            request->flags.connectionAuth = true;
                             may_pin = 1;
                         } else {
-                            request->flags.connectionProxyAuth = 1;
+                            request->flags.connectionProxyAuth = true;
                             may_pin = 1;
                         }
                     }
@@ -1048,7 +1089,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
-        request->flags.ims = 1;
+        request->flags.ims = true;
 
     if (!request->flags.ignoreCc) {
         if (request->cache_control) {
@@ -1090,13 +1131,13 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 #if USE_HTTP_VIOLATIONS
 
         if (Config.onoff.reload_into_ims)
-            request->flags.nocacheHack = 1;
+            request->flags.nocacheHack = true;
         else if (refresh_nocache_hack)
-            request->flags.nocacheHack = 1;
+            request->flags.nocacheHack = true;
         else
 #endif
 
-            request->flags.noCache = 1;
+            request->flags.noCache = true;
     }
 
     /* ignore range header in non-GETs or non-HEADs */
@@ -1106,7 +1147,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
             request->range = req_hdr->getRange();
 
         if (request->range) {
-            request->flags.isRanged=true;
+            request->flags.isRanged = true;
             clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->data;
             /* XXX: This is suboptimal. We should give the stream the range set,
              * and thereby let the top of the stream set the offset when the
@@ -1132,12 +1173,12 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     }
 
     if (req_hdr->has(HDR_AUTHORIZATION))
-        request->flags.auth = 1;
+        request->flags.auth = true;
 
     clientCheckPinning(http);
 
     if (request->login[0] != '\0')
-        request->flags.auth = 1;
+        request->flags.auth = true;
 
     if (req_hdr->has(HDR_VIA)) {
         String s = req_hdr->getList(HDR_VIA);
@@ -1150,7 +1191,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
         if (strListIsSubstr(&s, ThisCache2, ',')) {
             debugObj(33, 1, "WARNING: Forwarding loop detected for:\n",
                      request, (ObjPackMethod) & httpRequestPack);
-            request->flags.loopDetected = 1;
+            request->flags.loopDetected = true;
         }
 
 #if USE_FORW_VIA_DB
@@ -1174,7 +1215,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
     request->flags.cachable = http->request->maybeCacheable();
 
     if (clientHierarchical(http))
-        request->flags.hierarchical = 1;
+        request->flags.hierarchical = true;
 
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_NOCACHE = " <<
            (request->flags.noCache ? "SET" : "NOT SET"));
@@ -1196,6 +1237,17 @@ clientRedirectDoneWrapper(void *data, const HelperReply &result)
     calloutContext->clientRedirectDone(result);
 }
 
+void
+clientStoreIdDoneWrapper(void *data, const HelperReply &result)
+{
+    ClientRequestContext *calloutContext = (ClientRequestContext *)data;
+
+    if (!calloutContext->httpStateIsValid())
+        return;
+
+    calloutContext->clientStoreIdDone(result);
+}
+
 void
 ClientRequestContext::clientRedirectDone(const HelperReply &reply)
 {
@@ -1245,20 +1297,20 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
 
             // TODO: change default redirect status for appropriate requests
             // Squid defaults to 302 status for now for better compatibility with old clients.
-            // HTTP/1.0 client should get 302 (HTTP_MOVED_TEMPORARILY)
-            // HTTP/1.1 client contacting reverse-proxy should get 307 (HTTP_TEMPORARY_REDIRECT)
-            // HTTP/1.1 client being diverted by forward-proxy should get 303 (HTTP_SEE_OTHER)
-            http_status status = HTTP_MOVED_TEMPORARILY;
+            // HTTP/1.0 client should get 302 (Http::scMovedTemporarily)
+            // HTTP/1.1 client contacting reverse-proxy should get 307 (Http::scTemporaryRedirect)
+            // HTTP/1.1 client being diverted by forward-proxy should get 303 (Http::scSeeOther)
+            Http::StatusCode status = Http::scMovedTemporarily;
             if (statusNote != NULL) {
                 const char * result = statusNote->firstValue();
-                status = (http_status) atoi(result);
+                status = static_cast<Http::StatusCode>(atoi(result));
             }
 
-            if (status == HTTP_MOVED_PERMANENTLY
-                    || status == HTTP_MOVED_TEMPORARILY
-                    || status == HTTP_SEE_OTHER
-                    || status == HTTP_PERMANENT_REDIRECT
-                    || status == HTTP_TEMPORARY_REDIRECT) {
+            if (status == Http::scMovedPermanently
+                    || status == Http::scMovedTemporarily
+                    || status == Http::scSeeOther
+                    || status == Http::scPermanentRedirect
+                    || status == Http::scTemporaryRedirect) {
                 http->redirect.status = status;
                 http->redirect.location = xstrdup(urlNote->firstValue());
                 // TODO: validate the URL produced here is RFC 2616 compliant absolute URI
@@ -1278,7 +1330,7 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
                     debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
 
                     // update the new request to flag the re-writing was done on it
-                    new_request->flags.redirected = 1;
+                    new_request->flags.redirected = true;
 
                     // unlink bodypipe from the old request. Not needed there any longer.
                     if (old_request->body_pipe != NULL) {
@@ -1291,7 +1343,8 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
                     safe_free(http->uri);
                     http->uri = xstrdup(urlCanonical(new_request));
                     HTTPMSGUNLOCK(old_request);
-                    http->request = HTTPMSGLOCK(new_request);
+                    http->request = new_request;
+                    HTTPMSGLOCK(http->request);
                 } else {
                     debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
                            old_request->method << " " << urlNote->firstValue() << " " << old_request->http_ver);
@@ -1313,6 +1366,62 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
     http->doCallouts();
 }
 
+/**
+ * This method handles the different replies from StoreID helper.
+ */
+void
+ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
+{
+    HttpRequest *old_request = http->request;
+    debugs(85, 5, "'" << http->uri << "' result=" << reply);
+    assert(store_id_state == REDIRECT_PENDING);
+    store_id_state = REDIRECT_DONE;
+
+    // copy the helper response Notes to the HTTP request for logging
+    // do it early to ensure that no matter what the outcome the notes are present.
+    // TODO put them straight into the transaction state record (ALE?) eventually
+    if (!old_request->helperNotes)
+        old_request->helperNotes = new Notes;
+    old_request->helperNotes->add(reply.notes);
+
+    switch (reply.result) {
+    case HelperReply::Unknown:
+    case HelperReply::TT:
+        // Handler in redirect.cc should have already mapped Unknown
+        // IF it contained valid entry for the old helper protocol
+        debugs(85, DBG_IMPORTANT, "ERROR: storeID helper returned invalid result code. Wrong helper? " << reply);
+        break;
+
+    case HelperReply::BrokenHelper:
+        debugs(85, DBG_IMPORTANT, "ERROR: storeID helper: " << reply << ", attempt #" << (store_id_fail_count+1) << " of 2");
+        if (store_id_fail_count < 2) { // XXX: make this configurable ?
+            ++store_id_fail_count;
+            // reset state flag to try StoreID again from scratch.
+            store_id_done = false;
+        }
+        break;
+
+    case HelperReply::Error:
+        // no change to be done.
+        break;
+
+    case HelperReply::Okay: {
+        Note::Pointer urlNote = reply.notes.find("store-id");
+
+        // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
+        if (urlNote != NULL && strcmp(urlNote->firstValue(), http->uri) ) {
+            // Debug section required for some very specific cases.
+            debugs(85, 9, "Setting storeID with: " << urlNote->firstValue() );
+            http->request->store_id = urlNote->firstValue();
+            http->store_id = urlNote->firstValue();
+        }
+    }
+    break;
+    }
+
+    http->doCallouts();
+}
+
 /** Test cache allow/deny configuration
  *  Sets flags.cachable=1 if caching is not denied.
  */
@@ -1366,24 +1475,25 @@ ClientRequestContext::sslBumpAccessCheck()
     // (bumping of intercepted SSL conns is decided before we get 1st request).
     // We also do not bump redirected CONNECT requests.
     if (http->request->method != Http::METHOD_CONNECT || http->redirect.status ||
-            !Config.accessList.ssl_bump || !http->getConn()->port->sslBump) {
+            !Config.accessList.ssl_bump ||
+            !http->getConn()->port->flags.tunnelSslBumping) {
         http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
         debugs(85, 5, HERE << "cannot SslBump this request");
         return false;
     }
 
     // Do not bump during authentication: clients would not proxy-authenticate
     // if we delay a 407 response and respond with 200 OK to CONNECT.
-    if (error && error->httpStatus == HTTP_PROXY_AUTHENTICATION_REQUIRED) {
+    if (error && error->httpStatus == Http::scProxyAuthenticationRequired) {
         http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
         debugs(85, 5, HERE << "no SslBump during proxy authentication");
         return false;
     }
 
     debugs(85, 5, HERE << "SslBump possible, checking ACL");
 
-    ACLFilledChecklist *acl_checklist = clientAclChecklistCreate(Config.accessList.ssl_bump, http);
-    acl_checklist->nonBlockingCheck(sslBumpAccessCheckDoneWrapper, this);
+    ACLFilledChecklist *aclChecklist = clientAclChecklistCreate(Config.accessList.ssl_bump, http);
+    aclChecklist->nonBlockingCheck(sslBumpAccessCheckDoneWrapper, this);
     return true;
 }
 
@@ -1447,7 +1557,7 @@ ClientHttpRequest::httpStart()
 {
     PROF_start(httpStart);
     logType = LOG_TAG_NONE;
-    debugs(85, 4, "ClientHttpRequest::httpStart: " << Format::log_tags[logType] << " for '" << uri << "'");
+    debugs(85, 4, LogTags_str[logType] << " for '" << uri << "'");
 
     /* no one should have touched this */
     assert(out.offset == 0);
@@ -1594,8 +1704,10 @@ ClientHttpRequest::doCallouts()
     assert(calloutContext);
 
     /*Save the original request for logging purposes*/
-    if (!calloutContext->http->al->request)
-        calloutContext->http->al->request = HTTPMSGLOCK(request);
+    if (!calloutContext->http->al->request) {
+        calloutContext->http->al->request = request;
+        HTTPMSGLOCK(calloutContext->http->al->request);
+    }
 
     if (!calloutContext->error) {
         // CVE-2009-0801: verify the Host: header is consistent with other known details.
@@ -1642,6 +1754,18 @@ ClientHttpRequest::doCallouts()
             return;
         }
 
+        if (!calloutContext->store_id_done) {
+            calloutContext->store_id_done = true;
+            assert(calloutContext->store_id_state == REDIRECT_NONE);
+
+            if (Config.Program.store_id) {
+                debugs(83, 3,"Doing calloutContext->clientStoreIdStart()");
+                calloutContext->store_id_state = REDIRECT_PENDING;
+                calloutContext->clientStoreIdStart();
+                return;
+            }
+        }
+
         if (!calloutContext->interpreted_req_hdrs) {
             debugs(83, 3, HERE << "Doing clientInterpretRequestHeaders()");
             calloutContext->interpreted_req_hdrs = 1;
@@ -1695,8 +1819,8 @@ ClientHttpRequest::doCallouts()
 #endif
 
     if (calloutContext->error) {
-        const char *uri = urlCanonical(request);
-        StoreEntry *e= storeCreateEntry(uri, uri, request->flags, request->method);
+        const char *storeUri = request->storeId();
+        StoreEntry *e= storeCreateEntry(storeUri, storeUri, request->flags, request->method);
 #if USE_SSL
         if (sslBumpNeeded()) {
             // set final error but delay sending until we bump
@@ -1771,7 +1895,7 @@ ClientHttpRequest::noteAdaptationAnswer(const Adaptation::Answer &answer)
 
     switch (answer.kind) {
     case Adaptation::Answer::akForward:
-        handleAdaptedHeader(answer.message);
+        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
         break;
 
     case Adaptation::Answer::akBlock:
@@ -1794,7 +1918,8 @@ ClientHttpRequest::handleAdaptedHeader(HttpMsg *msg)
          * Replace the old request with the new request.
          */
         HTTPMSGUNLOCK(request);
-        request = HTTPMSGLOCK(new_req);
+        request = new_req;
+        HTTPMSGLOCK(request);
         /*
          * Store the new URI for logging
          */
@@ -1814,6 +1939,7 @@ ClientHttpRequest::handleAdaptedHeader(HttpMsg *msg)
 
         clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert(repContext);
         repContext->createStoreEntry(request->method, request->flags);
 
         EBIT_CLR(storeEntry()->flags, ENTRY_FWD_HDR_WAIT);
@@ -1956,7 +2082,7 @@ ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
         Ip::Address noAddr;
         noAddr.SetNoAddr();
         ConnStateData * c = getConn();
-        calloutContext->error = clientBuildError(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR,
+        calloutContext->error = clientBuildError(ERR_ICAP_FAILURE, Http::scInternalServerError,
                                 NULL,
                                 c != NULL ? c->clientConnection->remote : noAddr,
                                 request
@@ -1967,7 +2093,8 @@ ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
 #endif
         calloutContext->error->detailError(errDetail);
         calloutContext->readNextRequest = true;
-        c->expectNoForwarding();
+        if (c != NULL)
+            c->expectNoForwarding();
         doCallouts();
     }
     //else if(calloutContext == NULL) is it possible?
@@ -37,6 +37,7 @@
 #include "dlink.h"
 #include "base/AsyncJob.h"
 #include "HttpHeaderRange.h"
+#include "LogTags.h"
 
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
@@ -98,6 +99,7 @@ class ClientHttpRequest
     HttpRequest *request;		/* Parsed URL ... */
     char *uri;
     char *log_uri;
+    String store_id; /* StoreID for transactions where the request member is nil */
 
     struct {
         int64_t offset;
@@ -107,22 +109,25 @@ class ClientHttpRequest
 
     HttpHdrRangeIter range_iter;	/* data for iterating thru range specs */
     size_t req_sz;		/* raw request size on input, not current request size */
-    log_type logType;
+
+    /// the processing tags associated with this request transaction.
+    // NP: still an enum so each stage altering it must take care when replacing it.
+    LogTags logType;
 
     struct timeval start_time;
     AccessLogEntry::Pointer al; ///< access.log entry
 
     struct {
-        unsigned int accel:1;
-        unsigned int intercepted:1;
-        unsigned int spoof_client_ip:1;
-        unsigned int internal:1;
-        unsigned int done_copying:1;
-        unsigned int purging:1;
+        bool accel;
+        //bool intercepted; //XXX: it's apparently never used.
+        //bool spoof_client_ip; //XXX: it's apparently never used.
+        bool internal;
+        bool done_copying;
+        bool purging;
     } flags;
 
     struct {
-        http_status status;
+        Http::StatusCode status;
         char *location;
     } redirect;
 
@@ -206,7 +206,7 @@ comm_empty_os_read_buffers(int fd)
     /* prevent those nasty RST packets */
     char buf[SQUID_TCP_SO_RCVBUF];
 
-    if (fd_table[fd].flags.nonblocking == 1) {
+    if (fd_table[fd].flags.nonblocking) {
         while (FD_READ_METHOD(fd, buf, SQUID_TCP_SO_RCVBUF) > 0) {};
     }
 #endif
@@ -504,7 +504,7 @@ comm_set_transparent(int fd)
         debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(IP_TRANSPARENT) on FD " << fd << ": " << xstrerror());
     } else {
         /* mark the socket as having transparent options */
-        fd_table[fd].flags.transparent = 1;
+        fd_table[fd].flags.transparent = true;
     }
 #else
     debugs(50, DBG_CRITICAL, "WARNING: comm_open: setsockopt(IP_TRANSPARENT) not supported on this platform");
@@ -711,24 +711,24 @@ comm_import_opened(const Comm::ConnectionPointer &conn,
     comm_init_opened(conn, 0, 0, note, AI);
 
     if (!(conn->flags & COMM_NOCLOEXEC))
-        fd_table[conn->fd].flags.close_on_exec = 1;
+        fd_table[conn->fd].flags.close_on_exec = true;
 
     if (conn->local.GetPort() > (unsigned short) 0) {
 #if _SQUID_WINDOWS_
         if (AI->ai_socktype != SOCK_DGRAM)
 #endif
-            fd_table[conn->fd].flags.nolinger = 1;
+            fd_table[conn->fd].flags.nolinger = true;
     }
 
     if ((conn->flags & COMM_TRANSPARENT))
-        fd_table[conn->fd].flags.transparent = 1;
+        fd_table[conn->fd].flags.transparent = true;
 
     if (conn->flags & COMM_NONBLOCKING)
-        fd_table[conn->fd].flags.nonblocking = 1;
+        fd_table[conn->fd].flags.nonblocking = true;
 
 #ifdef TCP_NODELAY
     if (AI->ai_socktype == SOCK_STREAM)
-        fd_table[conn->fd].flags.nodelay = 1;
+        fd_table[conn->fd].flags.nodelay = true;
 #endif
 
     /* no fd_table[fd].flags. updates needed for these conditions:
@@ -829,7 +829,7 @@ comm_connect_addr(int sock, const Ip::Address &address)
     errno = 0;
 
     if (!F->flags.called_connect) {
-        F->flags.called_connect = 1;
+        F->flags.called_connect = true;
         ++ statCounter.syscalls.sock.connects;
 
         x = connect(sock, AI->ai_addr, AI->ai_addrlen);
@@ -890,23 +890,6 @@ comm_connect_addr(int sock, const Ip::Address &address)
 
     }
 
-    /* Squid seems to be working fine without this code. With this code,
-     * we leak memory on many connect requests because of EINPROGRESS.
-     * If you find that this code is needed, please file a bug report. */
-#if 0
-#if _SQUID_LINUX_
-    /* 2007-11-27:
-     * Linux Debian replaces our allocated AI pointer with garbage when
-     * connect() fails. This leads to segmentation faults deallocating
-     * the system-allocated memory when we go to clean up our pointer.
-     * HACK: is to leak the memory returned since we can't deallocate.
-     */
-    if (errno != 0) {
-        AI = NULL;
-    }
-#endif
-#endif
-
     address.FreeAddrInfo(AI);
 
     PROF_stop(comm_connect_addr);
@@ -1110,7 +1093,7 @@ _comm_close(int fd, char const *file, int line)
 
     PROF_start(comm_close);
 
-    F->flags.close_request = 1;
+    F->flags.close_request = true;
 
 #if USE_SSL
     if (F->ssl) {
@@ -1287,7 +1270,7 @@ commSetNoLinger(int fd)
     if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0)
         debugs(50, 0, "commSetNoLinger: FD " << fd << ": " << xstrerror());
 
-    fd_table[fd].flags.nolinger = 1;
+    fd_table[fd].flags.nolinger = true;
 }
 
 static void
@@ -1351,7 +1334,7 @@ commSetNonBlocking(int fd)
 #if _SQUID_CYGWIN_
     }
 #endif
-    fd_table[fd].flags.nonblocking = 1;
+    fd_table[fd].flags.nonblocking = true;
 
     return 0;
 }
@@ -1378,7 +1361,7 @@ commUnsetNonBlocking(int fd)
         return COMM_ERROR;
     }
 
-    fd_table[fd].flags.nonblocking = 0;
+    fd_table[fd].flags.nonblocking = false;
     return 0;
 }
 
@@ -1397,7 +1380,7 @@ commSetCloseOnExec(int fd)
     if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)
         debugs(50, 0, "FD " << fd << ": set close-on-exec failed: " << xstrerror());
 
-    fd_table[fd].flags.close_on_exec = 1;
+    fd_table[fd].flags.close_on_exec = true;
 
 #endif
 }
@@ -1411,7 +1394,7 @@ commSetTcpNoDelay(int fd)
     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0)
         debugs(50, DBG_IMPORTANT, "commSetTcpNoDelay: FD " << fd << ": " << xstrerror());
 
-    fd_table[fd].flags.nodelay = 1;
+    fd_table[fd].flags.nodelay = true;
 }
 
 #endif
@@ -13,6 +13,7 @@
 #include "globals.h"
 #include "icmp/net_db.h"
 #include "ipcache.h"
+#include "ip/tools.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 
@@ -32,8 +33,7 @@ Comm::ConnOpener::ConnOpener(Comm::ConnectionPointer &c, AsyncCall::Pointer &han
         callback_(handler),
         totalTries_(0),
         failRetries_(0),
-        connectTimeout_(ctimeout),
-        connectStart_(0)
+        deadline_(squid_curtime + static_cast<time_t>(ctimeout))
 {}
 
 Comm::ConnOpener::~ConnOpener()
@@ -54,36 +54,26 @@ Comm::ConnOpener::doneAll() const
         return AsyncJob::doneAll();
     }
 
+    // otherwise, we must be waiting for something
+    Must(temporaryFd_ >= 0 || calls_.sleep_);
     return false;
 }
 
 void
 Comm::ConnOpener::swanSong()
 {
-    // cancel any event watchers
-    // done here to get the "swanSong" mention in cancel debugging.
-    if (calls_.earlyAbort_ != NULL) {
-        calls_.earlyAbort_->cancel("Comm::ConnOpener::swanSong");
-        calls_.earlyAbort_ = NULL;
-    }
-    if (calls_.timeout_ != NULL) {
-        calls_.timeout_->cancel("Comm::ConnOpener::swanSong");
-        calls_.timeout_ = NULL;
-    }
-
     if (callback_ != NULL) {
-        if (callback_->canceled())
-            callback_ = NULL;
-        else
-            // inform the still-waiting caller we are dying
-            doneConnecting(COMM_ERR_CONNECT, 0);
+        // inform the still-waiting caller we are dying
+        sendAnswer(COMM_ERR_CONNECT, 0, "Comm::ConnOpener::swanSong");
     }
 
-    // rollback what we can from the job state
-    if (temporaryFd_ >= 0) {
-        // doneConnecting() handles partial FD connection cleanup
-        doneConnecting(COMM_ERR_CONNECT, 0);
-    }
+    // did we abort with a temporary FD assigned?
+    if (temporaryFd_ >= 0)
+        closeFd();
+
+    // did we abort while waiting between retries?
+    if (calls_.sleep_)
+        cancelSleep();
 
     AsyncJob::swanSong();
 }
@@ -109,14 +99,13 @@ Comm::ConnOpener::getHost() const
 /**
  * Connection attempt are completed. One way or the other.
  * Pass the results back to the external handler.
- * NP: on errors the earlyAbort call should be cancelled first with a reason.
  */
 void
-Comm::ConnOpener::doneConnecting(comm_err_t status, int xerrno)
+Comm::ConnOpener::sendAnswer(comm_err_t errFlag, int xerrno, const char *why)
 {
     // only mark the address good/bad AFTER connect is finished.
     if (host_ != NULL) {
-        if (xerrno == 0)
+        if (xerrno == 0) // XXX: should not we use errFlag instead?
             ipcacheMarkGoodAddr(host_, conn_->remote);
         else {
             ipcacheMarkBadAddr(host_, conn_->remote);
@@ -128,54 +117,148 @@ Comm::ConnOpener::doneConnecting(comm_err_t status, int xerrno)
     }
 
     if (callback_ != NULL) {
-        typedef CommConnectCbParams Params;
-        Params &params = GetCommParams<Params>(callback_);
-        params.conn = conn_;
-        params.flag = status;
-        params.xerrno = xerrno;
-        ScheduleCallHere(callback_);
+        // avoid scheduling cancelled callbacks, assuming they are common
+        // enough to make this extra check an optimization
+        if (callback_->canceled()) {
+            debugs(5, 4, conn_ << " not calling canceled " << *callback_ <<
+                   " [" << callback_->id << ']' );
+            // TODO save the pconn to the pconnPool ?
+        } else {
+            typedef CommConnectCbParams Params;
+            Params &params = GetCommParams<Params>(callback_);
+            params.conn = conn_;
+            params.flag = errFlag;
+            params.xerrno = xerrno;
+            ScheduleCallHere(callback_);
+        }
         callback_ = NULL;
     }
 
-    if (temporaryFd_ >= 0) {
-        debugs(5, 4, HERE << conn_ << " closing temp FD " << temporaryFd_);
-        // it never reached fully open, so cleanup the FD handlers
-        // Note that comm_close() sequence does not happen for partially open FD
-        Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, NULL, NULL, 0);
+    // The job will stop without this call because nil callback_ makes
+    // doneAll() true, but this explicit call creates nicer debugging.
+    mustStop(why);
+}
+
+/// cleans up this job I/O state without closing temporaryFd
+/// required before closing temporaryFd or keeping it in conn_
+/// leaves FD bare so must only be called via closeFd() or keepFd()
+void
+Comm::ConnOpener::cleanFd()
+{
+    debugs(5, 4, HERE << conn_ << " closing temp FD " << temporaryFd_);
+
+    Must(temporaryFd_ >= 0);
+    fde &f = fd_table[temporaryFd_];
+
+    // Our write_handler was set without using Comm::Write API, so we cannot
+    // use a cancellable Pointer-free job callback and simply cancel it here.
+    if (f.write_handler) {
+
+        /* XXX: We are about to remove write_handler, which was responsible
+         * for deleting write_data, so we have to delete write_data
+         * ourselves. Comm currently calls SetSelect handlers synchronously
+         * so if write_handler is set, we know it has not been called yet.
+         * ConnOpener converts that sync call into an async one, but only
+         * after deleting ptr, so that is not a problem.
+         */
+
+        delete static_cast<Pointer*>(f.write_data);
+        f.write_data = NULL;
+        f.write_handler = NULL;
+    }
+    // Comm::DoSelect does not do this when calling and resetting write_handler
+    // (because it expects more writes to come?). We could mimic that
+    // optimization by resetting Comm "Select" state only when the FD is
+    // actually closed.
+    Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, NULL, NULL, 0);
+
+    if (calls_.timeout_ != NULL) {
+        calls_.timeout_->cancel("Comm::ConnOpener::cleanFd");
+        calls_.timeout_ = NULL;
+    }
+    // Comm checkTimeouts() and commCloseAllSockets() do not clear .timeout
+    // when calling timeoutHandler (XXX fix them), so we clear unconditionally.
+    f.timeoutHandler = NULL;
+    f.timeout = 0;
+
+    if (calls_.earlyAbort_ != NULL) {
+        comm_remove_close_handler(temporaryFd_, calls_.earlyAbort_);
         calls_.earlyAbort_ = NULL;
-        if (calls_.timeout_ != NULL) {
-            calls_.timeout_->cancel("Comm::ConnOpener::doneConnecting");
-            calls_.timeout_ = NULL;
-        }
-        fd_table[temporaryFd_].timeoutHandler = NULL;
-        fd_table[temporaryFd_].timeout = 0;
-        close(temporaryFd_);
-        fd_close(temporaryFd_);
-        temporaryFd_ = -1;
     }
+}
+
+/// cleans I/O state and ends I/O for temporaryFd_
+void
+Comm::ConnOpener::closeFd()
+{
+    if (temporaryFd_ < 0)
+        return;
+
+    cleanFd();
+
+    // comm_close() below uses COMMIO_FD_WRITECB(fd)->active() to clear Comm
+    // "Select" state. It will not clear ours. XXX: It should always clear
+    // because a callback may have been active but was called before comm_close
+    // Update: we now do this in cleanFd()
+    // Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, NULL, NULL, 0);
+
+    comm_close(temporaryFd_);
+    temporaryFd_ = -1;
+}
+
+/// cleans I/O state and moves temporaryFd_ to the conn_ for long-term use
+void
+Comm::ConnOpener::keepFd()
+{
+    Must(conn_ != NULL);
+    Must(temporaryFd_ >= 0);
+
+    cleanFd();
 
-    /* ensure cleared local state, we are done. */
-    conn_ = NULL;
+    conn_->fd = temporaryFd_;
+    temporaryFd_ = -1;
 }
 
 void
 Comm::ConnOpener::start()
 {
     Must(conn_ != NULL);
 
-    /* get a socket open ready for connecting with */
+    /* outbound sockets have no need to be protocol agnostic. */
+    if (!(Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING) && conn_->remote.IsIPv4()) {
+        conn_->local.SetIPv4();
+    }
+
+    if (createFd())
+        connect();
+}
+
+/// called at the end of Comm::ConnOpener::DelayedConnectRetry event
+void
+Comm::ConnOpener::restart()
+{
+    debugs(5, 5, conn_ << " restarting after sleep");
+    calls_.sleep_ = false;
+
+    if (createFd())
+        connect();
+}
+
+/// Create a socket for the future connection or return false.
+/// If false is returned, done() is guaranteed to return true and end the job.
+bool
+Comm::ConnOpener::createFd()
+{
+    Must(temporaryFd_ < 0);
+
+    // our initators signal abort by cancelling their callbacks
+    if (callback_ == NULL || callback_->canceled())
+        return false;
+
+    temporaryFd_ = comm_openex(SOCK_STREAM, IPPROTO_TCP, conn_->local, conn_->flags, conn_->tos, conn_->nfmark, host_);
     if (temporaryFd_ < 0) {
-#if USE_IPV6
-        /* outbound sockets have no need to be protocol agnostic. */
-        if (conn_->remote.IsIPv4()) {
-            conn_->local.SetIPv4();
-        }
-#endif
-        temporaryFd_ = comm_openex(SOCK_STREAM, IPPROTO_TCP, conn_->local, conn_->flags, conn_->tos, conn_->nfmark, host_);
-        if (temporaryFd_ < 0) {
-            doneConnecting(COMM_ERR_CONNECT, 0);
-            return;
-        }
+        sendAnswer(COMM_ERR_CONNECT, 0, "Comm::ConnOpener::createFd");
+        return false;
     }
 
     typedef CommCbMemFunT<Comm::ConnOpener, CommCloseCbParams> abortDialer;
@@ -184,26 +267,25 @@ Comm::ConnOpener::start()
 
     typedef CommCbMemFunT<Comm::ConnOpener, CommTimeoutCbParams> timeoutDialer;
     calls_.timeout_ = JobCallback(5, 4, timeoutDialer, this, Comm::ConnOpener::timeout);
-    debugs(5, 3, HERE << conn_ << " timeout " << connectTimeout_);
+    debugs(5, 3, conn_ << " will timeout in " << (deadline_ - squid_curtime));
 
-    // Update the fd_table directly because conn_ is not yet storing the FD
+    // Update the fd_table directly because commSetConnTimeout() needs open conn_
     assert(temporaryFd_ < Squid_MaxFD);
     assert(fd_table[temporaryFd_].flags.open);
     typedef CommTimeoutCbParams Params;
     Params &params = GetCommParams<Params>(calls_.timeout_);
     params.conn = conn_;
     fd_table[temporaryFd_].timeoutHandler = calls_.timeout_;
-    fd_table[temporaryFd_].timeout = squid_curtime + (time_t) connectTimeout_;
+    fd_table[temporaryFd_].timeout = deadline_;
 
-    connectStart_ = squid_curtime;
-    connect();
+    return true;
 }
 
 void
 Comm::ConnOpener::connected()
 {
-    conn_->fd = temporaryFd_;
-    temporaryFd_ = -1;
+    Must(temporaryFd_ >= 0);
+    keepFd();
 
     /*
      * stats.conn_open is used to account for the number of
@@ -221,64 +303,81 @@ Comm::ConnOpener::connected()
      *       Also, legacy code still depends on comm_local_port() with no access to Comm::Connection
      *       when those are done comm_local_port can become one of our member functions to do the below.
      */
-    fd_table[conn_->fd].flags.open = 1;
+    Must(fd_table[conn_->fd].flags.open);
     fd_table[conn_->fd].local_addr = conn_->local;
+
+    sendAnswer(COMM_OK, 0, "Comm::ConnOpener::connected");
 }
 
-/** Make an FD connection attempt.
- * Handles the case(s) when a partially setup connection gets closed early.
- */
+/// Make an FD connection attempt.
 void
 Comm::ConnOpener::connect()
 {
     Must(conn_ != NULL);
-
-    // our parent Jobs signal abort by cancelling their callbacks.
-    if (callback_ == NULL || callback_->canceled())
-        return;
+    Must(temporaryFd_ >= 0);
 
     ++ totalTries_;
 
     switch (comm_connect_addr(temporaryFd_, conn_->remote) ) {
 
     case COMM_INPROGRESS:
-        // check for timeout FIRST.
-        if (squid_curtime - connectStart_ > connectTimeout_) {
-            debugs(5, 5, HERE << conn_ << ": * - ERR took too long already.");
-            calls_.earlyAbort_->cancel("Comm::ConnOpener::connect timed out");
-            doneConnecting(COMM_TIMEOUT, errno);
-            return;
-        } else {
-            debugs(5, 5, HERE << conn_ << ": COMM_INPROGRESS");
-            Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, Comm::ConnOpener::InProgressConnectRetry, new Pointer(this), 0);
-        }
+        debugs(5, 5, HERE << conn_ << ": COMM_INPROGRESS");
+        Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, Comm::ConnOpener::InProgressConnectRetry, new Pointer(this), 0);
         break;
 
     case COMM_OK:
         debugs(5, 5, HERE << conn_ << ": COMM_OK - connected");
         connected();
-        doneConnecting(COMM_OK, 0);
         break;
 
-    default:
+    default: {
+        const int xerrno = errno;
+
         ++failRetries_;
+        debugs(5, 7, conn_ << ": failure #" << failRetries_ << " <= " <<
+               Config.connect_retries << ": " << xstrerr(xerrno));
 
-        // check for timeout FIRST.
-        if (squid_curtime - connectStart_ > connectTimeout_) {
-            debugs(5, 5, HERE << conn_ << ": * - ERR took too long to receive response.");
-            calls_.earlyAbort_->cancel("Comm::ConnOpener::connect timed out");
-            doneConnecting(COMM_TIMEOUT, errno);
-        } else if (failRetries_ < Config.connect_retries) {
+        if (failRetries_ < Config.connect_retries) {
             debugs(5, 5, HERE << conn_ << ": * - try again");
-            eventAdd("Comm::ConnOpener::DelayedConnectRetry", Comm::ConnOpener::DelayedConnectRetry, new Pointer(this), 0.05, 0, false);
+            sleep();
             return;
         } else {
             // send ERROR back to the upper layer.
             debugs(5, 5, HERE << conn_ << ": * - ERR tried too many times already.");
-            calls_.earlyAbort_->cancel("Comm::ConnOpener::connect failed");
-            doneConnecting(COMM_ERR_CONNECT, errno);
+            sendAnswer(COMM_ERR_CONNECT, xerrno, "Comm::ConnOpener::connect");
         }
     }
+    }
+}
+
+/// Close and wait a little before trying to open and connect again.
+void
+Comm::ConnOpener::sleep()
+{
+    Must(!calls_.sleep_);
+    closeFd();
+    calls_.sleep_ = true;
+    eventAdd("Comm::ConnOpener::DelayedConnectRetry",
+             Comm::ConnOpener::DelayedConnectRetry,
+             new Pointer(this), 0.05, 0, false);
+}
+
+/// cleans up this job sleep state
+void
+Comm::ConnOpener::cancelSleep()
+{
+    if (calls_.sleep_) {
+        // It would be nice to delete the sleep event, but it might be out of
+        // the event queue and in the async queue already, so (a) we do not know
+        // whether we can safely delete the call ptr here and (b) eventDelete()
+        // will assert if the event went async. Thus, we let the event run so
+        // that it deletes the call ptr [after this job is gone]. Note that we
+        // are called only when the job ends so this "hanging event" will do
+        // nothing but deleting the call ptr.  TODO: Revise eventDelete() API.
+        // eventDelete(Comm::ConnOpener::DelayedConnectRetry, calls_.sleep);
+        calls_.sleep_ = false;
+        debugs(5, 9, conn_ << " stops sleeping");
+    }
 }
 
 /**
@@ -309,7 +408,9 @@ void
 Comm::ConnOpener::earlyAbort(const CommCloseCbParams &io)
 {
     debugs(5, 3, HERE << io.conn);
-    doneConnecting(COMM_ERR_CLOSING, io.xerrno); // NP: is closing or shutdown better?
+    calls_.earlyAbort_ = NULL;
+    // NP: is closing or shutdown better?
+    sendAnswer(COMM_ERR_CLOSING, io.xerrno, "Comm::ConnOpener::earlyAbort");
 }
 
 /**
@@ -319,7 +420,9 @@ Comm::ConnOpener::earlyAbort(const CommCloseCbParams &io)
 void
 Comm::ConnOpener::timeout(const CommTimeoutCbParams &)
 {
-    connect();
+    debugs(5, 5, HERE << conn_ << ": * - ERR took too long to receive response.");
+    calls_.timeout_ = NULL;
+    sendAnswer(COMM_TIMEOUT, ETIMEDOUT, "Comm::ConnOpener::timeout");
 }
 
 /* Legacy Wrapper for the retry event after COMM_INPROGRESS
@@ -341,7 +444,7 @@ Comm::ConnOpener::InProgressConnectRetry(int fd, void *data)
 }
 
 /* Legacy Wrapper for the retry event with small delay after errors.
- * XXX: As soon as eventAdd() accepts Async calls we can use a ConnOpener::connect call
+ * XXX: As soon as eventAdd() accepts Async calls we can use a ConnOpener::restart call
  */
 void
 Comm::ConnOpener::DelayedConnectRetry(void *data)
@@ -352,7 +455,7 @@ Comm::ConnOpener::DelayedConnectRetry(void *data)
         // Ew. we are now outside the all AsyncJob protections.
         // get back inside by scheduling another call...
         typedef NullaryMemFunT<Comm::ConnOpener> Dialer;
-        AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::connect);
+        AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::restart);
         ScheduleCallHere(call);
     }
     delete ptr;
@@ -40,13 +40,23 @@ class ConnOpener : public AsyncJob
 
     void earlyAbort(const CommCloseCbParams &);
     void timeout(const CommTimeoutCbParams &);
-    void doneConnecting(comm_err_t status, int xerrno);
+    void sendAnswer(comm_err_t errFlag, int xerrno, const char *why);
     static void InProgressConnectRetry(int fd, void *data);
     static void DelayedConnectRetry(void *data);
     void connect();
     void connected();
     void lookupLocalAddress();
 
+    void sleep();
+    void restart();
+
+    bool createFd();
+    void closeFd();
+    void keepFd();
+    void cleanFd();
+
+    void cancelSleep();
+
 private:
     char *host_;                         ///< domain name we are trying to connect to.
     int temporaryFd_;                    ///< the FD being opened. Do NOT set conn_->fd until it is fully open.
@@ -56,19 +66,16 @@ class ConnOpener : public AsyncJob
     int totalTries_;   ///< total number of connection attempts over all destinations so far.
     int failRetries_;  ///< number of retries current destination has been tried.
 
-    /**
-     * time at which to abandon the connection.
-     * the connection-done callback will be passed COMM_TIMEOUT
-     */
-    time_t connectTimeout_;
-
-    /// time at which this series of connection attempts was started.
-    time_t connectStart_;
+    /// if we are not done by then, we will call back with COMM_TIMEOUT
+    time_t deadline_;
 
     /// handles to calls which we may need to cancel.
     struct Calls {
         AsyncCall::Pointer earlyAbort_;
         AsyncCall::Pointer timeout_;
+        /// Whether we are idling before retrying to connect; not yet a call
+        /// [that we can cancel], but it will probably become one eventually.
+        bool sleep_;
     } calls_;
 
     CBDATA_CLASS2(ConnOpener);
@@ -29,8 +29,8 @@ static int64_t lost_conn = 0;
 Comm::Connection::~Connection()
 {
     if (fd >= 0) {
-        debugs(5, DBG_CRITICAL, "BUG #3329: Orphan Comm::Connection: " << *this);
-        debugs(5, DBG_CRITICAL, "NOTE: " << ++lost_conn << " Orphans since last started.");
+        debugs(5, 4, "BUG #3329: Orphan Comm::Connection: " << *this);
+        debugs(5, 4, "NOTE: " << ++lost_conn << " Orphans since last started.");
         close();
     }
 
@@ -53,6 +53,7 @@
 #if USE_DEVPOLL
 
 #include "comm/Loops.h"
+#include "fd.h"
 #include "fde.h"
 #include "mgr/Registration.h"
 #include "profiler/Profiler.h"
@@ -68,10 +69,13 @@
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
+#if HAVE_LIMITS_H
+#include <limits.h>
+#endif
 
 #define DEBUG_DEVPOLL 0
 
-/* OPEN_MAX is defined in <limits.h>, presumably included by sys/devpoll.h */
+// OPEN_MAX is defined in <limits.h>
 #define	DEVPOLL_UPDATESIZE	OPEN_MAX
 #define	DEVPOLL_QUERYSIZE	OPEN_MAX
 
@@ -55,6 +55,7 @@
 #if USE_KQUEUE
 #include "comm/Loops.h"
 #include "fde.h"
+#include "globals.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -502,7 +502,7 @@ Comm::DoSelect(int msec)
                 if ((hdl = F->read_handler)) {
                     PROF_start(comm_read_handler);
                     F->read_handler = NULL;
-                    F->flags.read_pending = 0;
+                    F->flags.read_pending = false;
                     hdl(fd, F->read_data);
                     PROF_stop(comm_read_handler);
                     ++ statCounter.select_fds;
@@ -45,6 +45,7 @@ int Debug::log_stderr = -1;
 bool Debug::log_syslog = false;
 int Debug::Levels[MAX_DEBUG_SECTIONS];
 int Debug::level;
+int Debug::sectionLevel;
 char *Debug::cache_log = NULL;
 int Debug::rotateNumber = -1;
 FILE *debug_log = NULL;
@@ -801,3 +802,26 @@ SkipBuildPrefix(const char* path)
 
     return path+BuildPrefixLength;
 }
+
+std::ostream &
+Raw::print(std::ostream &os) const
+{
+    if (label_)
+        os << ' ' << label_ << '[' << size_ << ']';
+
+    if (!size_)
+        return os;
+
+    // finalize debugging level if no level was set explicitly via minLevel()
+    const int finalLevel = (level >= 0) ? level :
+                           (size_ > 40 ? DBG_DATA : Debug::sectionLevel);
+    if (finalLevel <= Debug::sectionLevel) {
+        os << (label_ ? '=' : ' ');
+        if (data_)
+            os.write(data_, size_);
+        else
+            os << "[null]";
+    }
+
+    return os;
+}
@@ -173,6 +173,11 @@
 #define IPC_UNIX_STREAM 4
 #define IPC_UNIX_DGRAM 5
 
+/* required for AF_UNIX below to be defined [on FreeBSD] */
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
 #if HAVE_SOCKETPAIR && defined (AF_UNIX)
 #define IPC_STREAM IPC_UNIX_STREAM
 #define IPC_DGRAM IPC_UNIX_DGRAM
@@ -125,7 +125,7 @@ file_close(int fd)
         while (!diskWriteIsComplete(fd))
             diskHandleWrite(fd, NULL);
 #else
-        F->flags.close_request = 1;
+        F->flags.close_request = true;
         debugs(6, 2, "file_close: FD " << fd << ", delaying close");
         PROF_stop(file_close);
         return;
@@ -223,7 +223,7 @@ diskHandleWrite(int fd, void *notused)
     _fde_disk *fdd = &F->disk;
     dwrite_q *q = fdd->write_q;
     int status = DISK_OK;
-    int do_close;
+    bool do_close;
 
     if (NULL == q)
         return;
@@ -232,7 +232,7 @@ diskHandleWrite(int fd, void *notused)
 
     debugs(6, 3, "diskHandleWrite: FD " << fd);
 
-    F->flags.write_daemon = 0;
+    F->flags.write_daemon = false;
 
     assert(fdd->write_q != NULL);
 
@@ -332,7 +332,7 @@ diskHandleWrite(int fd, void *notused)
         /* another block is queued */
         diskCombineWrites(fdd);
         Comm::SetSelect(fd, COMM_SELECT_WRITE, diskHandleWrite, NULL, 0);
-        F->flags.write_daemon = 1;
+        F->flags.write_daemon = true;
     }
 
     do_close = F->flags.close_request;
@@ -41,7 +41,11 @@ class dlink_node
     dlink_node *next;
 };
 
-struct dlink_list {
+class dlink_list
+{
+public:
+    dlink_list() : head(NULL), tail(NULL) {}
+
     dlink_node *head;
     dlink_node *tail;
 };
@@ -388,7 +388,7 @@ idnsParseResolvConf(void)
 
         if (NULL == t) {
             continue;
-        } else if (strcasecmp(t, "nameserver") == 0) {
+        } else if (strcmp(t, "nameserver") == 0) {
             t = strtok(NULL, w_space);
 
             if (NULL == t)
@@ -397,7 +397,7 @@ idnsParseResolvConf(void)
             debugs(78, DBG_IMPORTANT, "Adding nameserver " << t << " from " << _PATH_RESCONF);
 
             idnsAddNameserver(t);
-        } else if (strcasecmp(t, "domain") == 0) {
+        } else if (strcmp(t, "domain") == 0) {
             idnsFreeSearchpath();
             t = strtok(NULL, w_space);
 
@@ -407,7 +407,7 @@ idnsParseResolvConf(void)
             debugs(78, DBG_IMPORTANT, "Adding domain " << t << " from " << _PATH_RESCONF);
 
             idnsAddPathComponent(t);
-        } else if (strcasecmp(t, "search") == 0) {
+        } else if (strcmp(t, "search") == 0) {
             idnsFreeSearchpath();
             while (NULL != t) {
                 t = strtok(NULL, w_space);
@@ -419,7 +419,7 @@ idnsParseResolvConf(void)
 
                 idnsAddPathComponent(t);
             }
-        } else if (strcasecmp(t, "options") == 0) {
+        } else if (strcmp(t, "options") == 0) {
             while (NULL != t) {
                 t = strtok(NULL, w_space);
 
@@ -836,13 +836,13 @@ idnsVCClosed(const CommCloseCbParams &params)
 }
 
 static void
-idnsInitVC(int ns)
+idnsInitVC(int nsv)
 {
     nsvc *vc = cbdataAlloc(nsvc);
-    assert(ns < nns);
+    assert(nsv < nns);
     assert(vc->conn == NULL); // MUST be NULL from the construction process!
-    nameservers[ns].vc = vc;
-    vc->ns = ns;
+    nameservers[nsv].vc = vc;
+    vc->ns = nsv;
     vc->queue = new MemBuf;
     vc->msg = new MemBuf;
     vc->busy = 1;
@@ -854,7 +854,7 @@ idnsInitVC(int ns)
     else
         conn->local = Config.Addrs.udp_incoming;
 
-    conn->remote = nameservers[ns].S;
+    conn->remote = nameservers[nsv].S;
 
     if (conn->remote.IsIPv4()) {
         conn->local.SetIPv4();
@@ -868,17 +868,17 @@ idnsInitVC(int ns)
 }
 
 static void
-idnsSendQueryVC(idns_query * q, int ns)
+idnsSendQueryVC(idns_query * q, int nsn)
 {
-    assert(ns < nns);
-    if (nameservers[ns].vc == NULL)
-        idnsInitVC(ns);
+    assert(nsn < nns);
+    if (nameservers[nsn].vc == NULL)
+        idnsInitVC(nsn);
 
-    nsvc *vc = nameservers[ns].vc;
+    nsvc *vc = nameservers[nsn].vc;
 
     if (!vc) {
         char buf[MAX_IPSTRLEN];
-        debugs(78, DBG_IMPORTANT, "idnsSendQuery: Failed to initiate TCP connection to nameserver " << nameservers[ns].S.NtoA(buf,MAX_IPSTRLEN) << "!");
+        debugs(78, DBG_IMPORTANT, "idnsSendQuery: Failed to initiate TCP connection to nameserver " << nameservers[nsn].S.NtoA(buf,MAX_IPSTRLEN) << "!");
 
         return;
     }
@@ -912,28 +912,28 @@ idnsSendQuery(idns_query * q)
     assert(q->lru.prev == NULL);
 
     int x = -1, y = -1;
-    int ns;
+    int nsn;
 
     do {
-        ns = q->nsends % nns;
+        nsn = q->nsends % nns;
 
         if (q->need_vc) {
-            idnsSendQueryVC(q, ns);
+            idnsSendQueryVC(q, nsn);
             x = y = 0;
         } else {
-            if (DnsSocketB >= 0 && nameservers[ns].S.IsIPv6())
-                y = comm_udp_sendto(DnsSocketB, nameservers[ns].S, q->buf, q->sz);
+            if (DnsSocketB >= 0 && nameservers[nsn].S.IsIPv6())
+                y = comm_udp_sendto(DnsSocketB, nameservers[nsn].S, q->buf, q->sz);
             else if (DnsSocketA >= 0)
-                x = comm_udp_sendto(DnsSocketA, nameservers[ns].S, q->buf, q->sz);
+                x = comm_udp_sendto(DnsSocketA, nameservers[nsn].S, q->buf, q->sz);
         }
 
         ++ q->nsends;
 
         q->sent_t = current_time;
 
-        if (y < 0 && nameservers[ns].S.IsIPv6())
+        if (y < 0 && nameservers[nsn].S.IsIPv6())
             debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketB << ": sendto: " << xstrerror());
-        if (x < 0 && nameservers[ns].S.IsIPv4())
+        if (x < 0 && nameservers[nsn].S.IsIPv4())
             debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketA << ": sendto: " << xstrerror());
 
     } while ( (x<0 && y<0) && q->nsends % nns != 0);
@@ -945,7 +945,7 @@ idnsSendQuery(idns_query * q)
         fd_bytes(DnsSocketA, x, FD_WRITE);
     }
 
-    ++ nameservers[ns].nqueries;
+    ++ nameservers[nsn].nqueries;
     q->queue_t = current_time;
     dlinkAdd(q, &q->lru, &lru_list);
     q->pending = 1;
@@ -1016,9 +1016,8 @@ idnsCallback(idns_query *q, const char *error)
     if (q->master)
         q = q->master;
 
-    idns_query *q2;
     // If any of our subqueries are still pending then wait for them to complete before continuing
-    for ( q2 = q; q2; q2 = q2->slave) {
+    for (idns_query *q2 = q; q2; q2 = q2->slave) {
         if (q2->pending) {
             return;
         }
@@ -1030,7 +1029,7 @@ idnsCallback(idns_query *q, const char *error)
     int n = q->ancount;
     error = q->error;
 
-    while ( (q2 = q->slave) ) {
+    while ( idns_query *q2 = q->slave ) {
         debugs(78, 6, HERE << "Merging DNS results " << q->name << " A has " << n << " RR, AAAA has " << q2->ancount << " RR");
         q->slave = q2->slave;
         if ( !q2->error ) {
@@ -1252,7 +1251,6 @@ idnsRead(int fd, void *data)
     int len;
     int max = INCOMING_DNS_MAX;
     static char rbuf[SQUID_UDP_SO_RCVBUF];
-    int ns;
     Ip::Address from;
 
     debugs(78, 3, "idnsRead: starting with FD " << fd);
@@ -1304,18 +1302,18 @@ idnsRead(int fd, void *data)
         debugs(78, 3, "idnsRead: FD " << fd << ": received " << len << " bytes from " << from);
 
         /* BUG: see above. Its here that it becomes apparent that the content of bugbypass is gone. */
-        ns = idnsFromKnownNameserver(from);
+        int nsn = idnsFromKnownNameserver(from);
 
-        if (ns >= 0) {
-            ++ nameservers[ns].nreplies;
+        if (nsn >= 0) {
+            ++ nameservers[nsn].nreplies;
         }
 
         // Before unknown_nameservers check to avoid flooding cache.log on attacks,
         // but after the ++ above to keep statistics right.
         if (!lru_list.head)
             continue; // Don't process replies if there is no pending query.
 
-        if (ns < 0 && Config.onoff.ignore_unknown_nameservers) {
+        if (nsn < 0 && Config.onoff.ignore_unknown_nameservers) {
             static time_t last_warning = 0;
 
             if (squid_curtime - last_warning > 60) {
@@ -1327,7 +1325,7 @@ idnsRead(int fd, void *data)
             continue;
         }
 
-        idnsGrokReply(rbuf, len, ns);
+        idnsGrokReply(rbuf, len, nsn);
     }
 }
 
@@ -32,32 +32,6 @@
 #ifndef SQUID_ENUMS_H
 #define SQUID_ENUMS_H
 
-typedef enum {
-    LOG_TAG_NONE,
-    LOG_TCP_HIT,
-    LOG_TCP_MISS,
-    LOG_TCP_REFRESH_UNMODIFIED, // refresh from origin revalidated existing entry
-    LOG_TCP_REFRESH_FAIL_OLD,   // refresh from origin failed, stale reply sent
-    LOG_TCP_REFRESH_FAIL_ERR,   // refresh from origin failed, error forwarded
-    LOG_TCP_REFRESH_MODIFIED,   // refresh from origin replaced existing entry
-    LOG_TCP_CLIENT_REFRESH_MISS,
-    LOG_TCP_IMS_HIT,
-    LOG_TCP_SWAPFAIL_MISS,
-    LOG_TCP_NEGATIVE_HIT,
-    LOG_TCP_MEM_HIT,
-    LOG_TCP_DENIED,
-    LOG_TCP_DENIED_REPLY,
-    LOG_TCP_OFFLINE_HIT,
-    LOG_TCP_REDIRECT,
-    LOG_UDP_HIT,
-    LOG_UDP_MISS,
-    LOG_UDP_DENIED,
-    LOG_UDP_INVALID,
-    LOG_UDP_MISS_NOFETCH,
-    LOG_ICP_QUERY,
-    LOG_TYPE_MAX
-} log_type;
-
 enum fd_type {
     FD_NONE,
     FD_LOG,
@@ -87,7 +87,7 @@ CBDATA_CLASS_INIT(ErrorState);
 typedef struct {
     int id;
     char *page_name;
-    http_status page_redirect;
+    Http::StatusCode page_redirect;
 } ErrorDynamicPageInfo;
 
 /* local constant and vars */
@@ -210,7 +210,7 @@ errorInitialize(void)
             assert(info && info->id == i && info->page_name);
 
             const char *pg = info->page_name;
-            if (info->page_redirect != HTTP_STATUS_NONE)
+            if (info->page_redirect != Http::scNone)
                 pg = info->page_name +4;
 
             if (strchr(pg, ':') == NULL) {
@@ -381,17 +381,9 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
     while (pos < hdr.size()) {
         char *dt = lang;
 
-        if (!pos) {
-            /* skip any initial whitespace. */
-            while (pos < hdr.size() && xisspace(hdr[pos]))
-                ++pos;
-        } else {
-            // IFF we terminated the tag on whitespace or ';' we need to skip to the next ',' or end of header.
-            while (pos < hdr.size() && hdr[pos] != ',')
-                ++pos;
-            if (hdr[pos] == ',')
-                ++pos;
-        }
+        /* skip any initial whitespace. */
+        while (pos < hdr.size() && xisspace(hdr[pos]))
+            ++pos;
 
         /*
          * Header value format:
@@ -422,6 +414,13 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
         *dt = '\0'; // nul-terminated the filename content string before system use.
         ++dt;
 
+        // if we terminated the tag on garbage or ';' we need to skip to the next ',' or end of header.
+        while (pos < hdr.size() && hdr[pos] != ',')
+            ++pos;
+
+        if (pos < hdr.size() && hdr[pos] == ',')
+            ++pos;
+
         debugs(4, 9, HERE << "STATE: dt='" << dt << "', lang='" << lang << "', pos=" << pos << ", buf='" << ((pos < hdr.size()) ? hdr.substr(pos,hdr.size()) : "") << "'");
 
         /* if we found anything we might use, try it. */
@@ -432,7 +431,7 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
 }
 
 bool
-TemplateFile::loadFor(HttpRequest *request)
+TemplateFile::loadFor(const HttpRequest *request)
 {
     String hdr;
 
@@ -478,7 +477,7 @@ errorDynamicPageInfoCreate(int id, const char *page_name)
     ErrorDynamicPageInfo *info = new ErrorDynamicPageInfo;
     info->id = id;
     info->page_name = xstrdup(page_name);
-    info->page_redirect = static_cast<http_status>(atoi(page_name));
+    info->page_redirect = static_cast<Http::StatusCode>(atoi(page_name));
 
     /* WARNING on redirection status:
      * 2xx are permitted, but not documented officially.
@@ -491,7 +490,7 @@ errorDynamicPageInfoCreate(int id, const char *page_name)
      * - current result is Squid crashing or XSS problems as dynamic deny_info load random disk files.
      * - a future redesign of the file loading may result in loading remote objects sent inline as local body.
      */
-    if (info->page_redirect == HTTP_STATUS_NONE)
+    if (info->page_redirect == Http::scNone)
         ; // special case okay.
     else if (info->page_redirect < 200 || info->page_redirect > 599) {
         // out of range
@@ -569,7 +568,7 @@ errorPageName(int pageId)
     return "ERR_UNKNOWN";	/* should not happen */
 }
 
-ErrorState::ErrorState(err_type t, http_status status, HttpRequest * req) :
+ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
         type(t),
         page_id(t),
         err_language(NULL),
@@ -594,14 +593,14 @@ ErrorState::ErrorState(err_type t, http_status status, HttpRequest * req) :
 #endif
         detailCode(ERR_DETAIL_NONE)
 {
-    memset(&flags, 0, sizeof(flags));
     memset(&ftp, 0, sizeof(ftp));
 
-    if (page_id >= ERR_MAX && ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect != HTTP_STATUS_NONE)
+    if (page_id >= ERR_MAX && ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect != Http::scNone)
         httpStatus = ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect;
 
     if (req != NULL) {
-        request = HTTPMSGLOCK(req);
+        request = req;
+        HTTPMSGLOCK(request);
         src_addr = req->client_addr;
     }
 }
@@ -631,7 +630,7 @@ errorAppendEntry(StoreEntry * entry, ErrorState * err)
     if (err->page_id == TCP_RESET) {
         if (err->request) {
             debugs(4, 2, "RSTing this reply");
-            err->request->flags.resetTcp=true;
+            err->request->flags.resetTcp = true;
         }
     }
 
@@ -654,9 +653,6 @@ errorSend(const Comm::ConnectionPointer &conn, ErrorState * err)
     debugs(4, 3, HERE << conn << ", err=" << err);
     assert(Comm::IsConnOpen(conn));
 
-    /* moved in front of errorBuildBuf @?@ */
-    err->flags.flag_cbdata = 1;
-
     rep = err->BuildHttpReply();
 
     MemBuf *mb = rep->pack();
@@ -1161,14 +1157,14 @@ ErrorState::BuildHttpReply()
 
     if (name[0] == '3' || (name[0] != '2' && name[0] != '4' && name[0] != '5' && strchr(name, ':'))) {
         /* Redirection */
-        http_status status = HTTP_MOVED_TEMPORARILY;
+        Http::StatusCode status = Http::scMovedTemporarily;
         // Use configured 3xx reply status if set.
         if (name[0] == '3')
             status = httpStatus;
         else {
             // Use 307 for HTTP/1.1 non-GET/HEAD requests.
-            if (request->method != Http::METHOD_GET && request->method != Http::METHOD_HEAD && request->http_ver >= HttpVersion(1,1))
-                status = HTTP_TEMPORARY_REDIRECT;
+            if (request->method != Http::METHOD_GET && request->method != Http::METHOD_HEAD && request->http_ver >= Http::ProtocolVersion(1,1))
+                status = Http::scTemporaryRedirect;
         }
 
         rep->setHeaders(status, NULL, "text/html", 0, 0, -1);
@@ -38,7 +38,7 @@
 #include "comm/forward.h"
 #include "err_detail_type.h"
 #include "err_type.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 #include "ip/Address.h"
 #include "SquidString.h"
 /* auth/UserRequest.h is empty unless USE_AUTH is defined */
@@ -97,7 +97,7 @@ class MemBuf;
 class ErrorState
 {
 public:
-    ErrorState(err_type type, http_status, HttpRequest * request);
+    ErrorState(err_type type, Http::StatusCode, HttpRequest * request);
     ErrorState(); // not implemented.
     ~ErrorState();
 
@@ -153,7 +153,7 @@ class ErrorState
     err_type type;
     int page_id;
     char *err_language;
-    http_status httpStatus;
+    Http::StatusCode httpStatus;
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
@@ -169,10 +169,6 @@ class ErrorState
     ERCB *callback;
     void *callback_data;
 
-    struct {
-        unsigned int flag_cbdata:1;
-    } flags;
-
     struct {
         wordlist *server_msg;
         char *request;
@@ -282,7 +278,7 @@ class TemplateFile
      * template selected (eg because of a "Accept-Language: *"), or not available
      * template found this function return false.
      */
-    bool loadFor(HttpRequest *request);
+    bool loadFor(const HttpRequest *request);
 
     /**
      * Load the file given by "path". It uses the "parse()" method.
@@ -315,11 +311,16 @@ class TemplateFile
 /**
  * Parses the Accept-Language header value and return one language item on
  * each call.
+ * Will ignore any whitespace, q-values, and detectably invalid language
+ * codes in the header.
+ *
  * \param hdr is the Accept-Language header value
- * \param lang a buffer given by the user to store parsed language
+ * \param lang a buffer to store parsed language code in
  * \param langlen the length of the lang buffer
- * \param pos it is used to store the state of parsing. Must be "0" on first call
- * \return true on success, false otherwise
+ * \param pos is used to store the offset state of parsing. Must be "0" on first call.
+ *            Will be altered to point at the start of next field-value.
+ * \return true if something looking like a language token has been placed in lang, false otherwise
  */
 bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &pos);
+
 #endif /* SQUID_ERRORPAGE_H */
@@ -36,7 +36,7 @@
 #include "esi/Element.h"
 #include "clientStream.h"
 #include "err_type.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 
 class ESIVarState;
 class ClientHttpRequest;
@@ -54,7 +54,7 @@ class ESIContext : public esiTreeParent, public ESIParserClient
             thisNode(NULL),
             http(NULL),
             errorpage(ERR_NONE),
-            errorstatus(HTTP_STATUS_NONE),
+            errorstatus(Http::scNone),
             errormessage(NULL),
             rep(NULL),
             outbound_offset(0),
@@ -114,7 +114,7 @@ class ESIContext : public esiTreeParent, public ESIParserClient
     } flags;
 
     err_type errorpage; /* if we error what page to use */
-    http_status errorstatus; /* if we error, what code to return */
+    Http::StatusCode errorstatus; /* if we error, what code to return */
     char *errormessage; /* error to pass to error page */
     HttpReply *rep; /* buffered until we pass data downstream */
     ESISegment::Pointer buffered; /* unprocessed data - for whatever reason */
@@ -296,7 +296,7 @@ void
 ESIContext::setError()
 {
     errorpage = ERR_ESI;
-    errorstatus = HTTP_INTERNAL_SERVER_ERROR;
+    errorstatus = Http::scInternalServerError;
     flags.error = 1;
 }
 
@@ -541,21 +541,21 @@ esiStreamStatus (clientStreamNode *thisNode, ClientHttpRequest *http)
 }
 
 static int
-esiAlwaysPassthrough(http_status sline)
+esiAlwaysPassthrough(Http::StatusCode sline)
 {
     int result;
 
     switch (sline) {
 
-    case HTTP_CONTINUE: /* Should never reach us... but squid needs to alter to accomodate this */
+    case Http::scContinue: /* Should never reach us... but squid needs to alter to accomodate this */
 
-    case HTTP_SWITCHING_PROTOCOLS: /* Ditto */
+    case Http::scSwitchingProtocols: /* Ditto */
 
-    case HTTP_PROCESSING: /* Unknown - some extension */
+    case Http::scProcessing: /* Unknown - some extension */
 
-    case HTTP_NO_CONTENT: /* no body, no esi */
+    case Http::scNoContent: /* no body, no esi */
 
-    case HTTP_NOT_MODIFIED: /* ESI does not affect assembled page headers, so 304s are valid */
+    case Http::scNotModified: /* ESI does not affect assembled page headers, so 304s are valid */
         result = 1;
         /* unreached */
         break;
@@ -888,7 +888,7 @@ ESIContextNew (HttpReply *rep, clientStreamNode *thisNode, ClientHttpRequest *ht
     rv->rep = rep;
     rv->cbdataLocker = rv;
 
-    if (esiAlwaysPassthrough(rep->sline.status)) {
+    if (esiAlwaysPassthrough(rep->sline.status())) {
         rv->flags.passthrough = 1;
     } else {
         /* remove specific headers for ESI to prevent
@@ -1323,7 +1323,7 @@ ESIContext::process ()
     /* parsing:
      * read through buffered, skipping plain text, and skipping any
      * <...> entry that is not an <esi: entry.
-     * when it's found, hand an esiLiteral of the preceeding data to our current
+     * when it's found, hand an esiLiteral of the preceding data to our current
      * context
      */
 
@@ -1451,7 +1451,7 @@ ESIContext::freeResources ()
     /* don't touch incoming, it's a pointer into buffered anyway */
 }
 
-ErrorState *clientBuildError (err_type, http_status, char const *, Ip::Address &, HttpRequest *);
+ErrorState *clientBuildError (err_type, Http::StatusCode, char const *, Ip::Address &, HttpRequest *);
 
 /* This can ONLY be used before we have sent *any* data to the client */
 void
@@ -2077,12 +2077,13 @@ esiChoose::addElement(ESIElement::Pointer element)
 
         debugs (86,3, "esiChooseAdd: Added a new element, elements = " << elements.size());
 
-        if (chosenelement == -1)
-            if ((dynamic_cast<esiWhen *>(element.getRaw()))->
-                    testsTrue()) {
+        if (chosenelement == -1) {
+            const esiWhen * topElement=dynamic_cast<esiWhen *>(element.getRaw());
+            if (topElement && topElement->testsTrue()) {
                 chosenelement = elements.size() - 1;
                 debugs (86,3, "esiChooseAdd: Chose element " << elements.size());
             }
+        }
     }
 
     return true;
@@ -114,7 +114,7 @@ esiBufferRecipient (clientStreamNode *node, ClientHttpRequest *http, HttpReply *
         assert(rep == NULL);
     } else {
         if (rep) {
-            if (rep->sline.status != HTTP_OK) {
+            if (rep->sline.status() != Http::scOkay) {
                 rep = NULL;
                 esiStream->include->includeFail (esiStream);
                 esiStream->finished = 1;
@@ -705,7 +705,7 @@ ACLExternal::parse()
 
     data = cbdataAlloc(external_acl_data);
 
-    token = strtok(NULL, w_space);
+    token = strtokFile();
 
     if (!token)
         self_destruct();
@@ -106,7 +106,7 @@ fd_close(int fd)
     fde *F = &fd_table[fd];
 
     assert(fd >= 0);
-    assert(F->flags.open == 1);
+    assert(F->flags.open);
 
     if (F->type == FD_FILE) {
         assert(F->read_handler == NULL);
@@ -116,7 +116,7 @@ fd_close(int fd)
     debugs(51, 3, "fd_close FD " << fd << " " << F->desc);
     Comm::SetSelect(fd, COMM_SELECT_READ, NULL, NULL, 0);
     Comm::SetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
-    F->flags.open = 0;
+    F->flags.open = false;
     fdUpdateBiggest(fd, 0);
     --Number_FD;
     *F = fde();
@@ -220,7 +220,7 @@ fd_open(int fd, unsigned int type, const char *desc)
     assert(!F->flags.open);
     debugs(51, 3, "fd_open() FD " << fd << " " << desc);
     F->type = type;
-    F->flags.open = 1;
+    F->flags.open = true;
     F->epoll_state = 0;
 #if _SQUID_WINDOWS_
 
@@ -38,6 +38,8 @@
 #include "SquidTime.h"
 #include "Store.h"
 
+fde *fde::Table = NULL;
+
 bool
 fde::readPending(int fdNumber)
 {
@@ -73,6 +73,10 @@ class fde
     void noteUse(PconnPool *);
 
 public:
+
+    /// global table of FD and their state.
+    static fde* Table;
+
     unsigned int type;
     unsigned short remote_port;
 
@@ -86,19 +90,19 @@ class fde
     char desc[FD_DESC_SZ];
 
     struct _fde_flags {
-        unsigned int open:1;
-        unsigned int close_request:1; // file_ or comm_close has been called
-        unsigned int write_daemon:1;
-        unsigned int socket_eof:1;
-        unsigned int nolinger:1;
-        unsigned int nonblocking:1;
-        unsigned int ipc:1;
-        unsigned int called_connect:1;
-        unsigned int nodelay:1;
-        unsigned int close_on_exec:1;
-        unsigned int read_pending:1;
-        unsigned int write_pending:1;
-        unsigned int transparent:1;
+        bool open;
+        bool close_request; ///< true if file_ or comm_close has been called
+        bool write_daemon;
+        bool socket_eof;
+        bool nolinger;
+        bool nonblocking;
+        bool ipc;
+        bool called_connect;
+        bool nodelay;
+        bool close_on_exec;
+        bool read_pending;
+        //bool write_pending; //XXX seems not to be used
+        bool transparent;
     } flags;
 
     int64_t bytes_read;
@@ -193,6 +197,8 @@ class fde
     }
 };
 
+#define fd_table fde::Table
+
 int fdNFree(void);
 
 #define FD_READ_METHOD(fd, buf, len) (*fd_table[fd].read_method)(fd, buf, len)
@@ -209,8 +209,6 @@ enum Quoting {
     LOG_QUOTE_RAW
 };
 
-extern const char *log_tags[];
-
 } // namespace Format
 
 #endif /* _SQUID_FMT_BYTECODE_H */
@@ -79,16 +79,16 @@ Format::Format::parse(const char *def)
 }
 
 void
-Format::Format::dump(StoreEntry * entry, const char *name)
+Format::Format::dump(StoreEntry * entry, const char *directiveName)
 {
     debugs(46, 4, HERE);
 
     // loop rather than recursing to conserve stack space.
-    for (Format *format = this; format; format = format->next) {
-        debugs(46, 3, HERE << "Dumping format definition for " << format->name);
-        storeAppendPrintf(entry, "format %s ", format->name);
+    for (Format *fmt = this; fmt; fmt = fmt->next) {
+        debugs(46, 3, HERE << "Dumping format definition for " << fmt->name);
+        storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
 
-        for (Token *t = format->format; t; t = t->next) {
+        for (Token *t = fmt->format; t; t = t->next) {
             if (t->type == LFT_STRING)
                 storeAppendPrintf(entry, "%s", t->data.string);
             else {
@@ -797,7 +797,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_HTTP_RECEIVED_STATUS_CODE:
-            if (al->hier.peer_reply_status == HTTP_STATUS_NONE) {
+            if (al->hier.peer_reply_status == Http::scNone) {
                 out = "-";
             } else {
                 outint = al->hier.peer_reply_status;
@@ -821,11 +821,11 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_SQUID_STATUS:
             if (al->http.timedout || al->http.aborted) {
-                snprintf(tmp, sizeof(tmp), "%s%s", log_tags[al->cache.code],
+                snprintf(tmp, sizeof(tmp), "%s%s", LogTags_str[al->cache.code],
                          al->http.statusSfx());
                 out = tmp;
             } else {
-                out = log_tags[al->cache.code];
+                out = LogTags_str[al->cache.code];
             }
 
             break;
@@ -41,7 +41,7 @@ class Format
     void assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const;
 
     /// dump this whole list of formats into the provided StoreEntry
-    void dump(StoreEntry * entry, const char *name);
+    void dump(StoreEntry * entry, const char *directiveName);
 
     char *name;
     Token *format;
@@ -6,32 +6,6 @@
 #include "SquidConfig.h"
 #include "Store.h"
 
-const char *Format::log_tags[] = {
-    "NONE",
-    "TCP_HIT",
-    "TCP_MISS",
-    "TCP_REFRESH_UNMODIFIED",
-    "TCP_REFRESH_FAIL", // same tag logged for LOG_TCP_REFRESH_FAIL_OLD and
-    "TCP_REFRESH_FAIL", // LOG_TCP_REFRESH_FAIL_ERR for backward-compatibility
-    "TCP_REFRESH_MODIFIED",
-    "TCP_CLIENT_REFRESH_MISS",
-    "TCP_IMS_HIT",
-    "TCP_SWAPFAIL_MISS",
-    "TCP_NEGATIVE_HIT",
-    "TCP_MEM_HIT",
-    "TCP_DENIED",
-    "TCP_DENIED_REPLY",
-    "TCP_OFFLINE_HIT",
-    "TCP_REDIRECT",
-    "UDP_HIT",
-    "UDP_MISS",
-    "UDP_DENIED",
-    "UDP_INVALID",
-    "UDP_MISS_NOFETCH",
-    "ICP_QUERY",
-    "LOG_TYPE_MAX"
-};
-
 // Due to token overlaps between 1 and 2 letter tokens (Bug 3310)
 // We split the token table into sets determined by the token length
 namespace Format
@@ -322,12 +296,12 @@ Format::Token::parse(const char *def, Quoting *quoting)
     }
 
     if (*cur == '-') {
-        left = 1;
+        left = true;
         ++cur;
     }
 
     if (*cur == '0') {
-        zero = 1;
+        zero = false;
         ++cur;
     }
 
@@ -403,7 +377,7 @@ Format::Token::parse(const char *def, Quoting *quoting)
     }
 
     if (*cur == ' ') {
-        space = 1;
+        space = true;
         ++cur;
     }
 
@@ -32,9 +32,9 @@ class Token
             widthMin(-1),
             widthMax(-1),
             quote(LOG_QUOTE_NONE),
-            left(0),
-            space(0),
-            zero(0),
+            left(false),
+            space(false),
+            zero(false),
             divisor(0),
             next(NULL)
     { data.string = NULL; }
@@ -65,18 +65,16 @@ class Token
     int widthMin; ///< minimum field width
     int widthMax; ///< maximum field width
     enum Quoting quote;
-    unsigned int left:1;
-    unsigned int space:1;
-    unsigned int zero:1;
+    bool left;
+    bool space;
+    bool zero;
     int divisor;
     Token *next;	/* todo: move from linked list to array */
 
 private:
     const char *scanForToken(TokenTableEntry const table[], const char *cur);
 };
 
-extern const char *log_tags[];
-
 } // namespace Format
 
 #endif /* _SQUID_FORMAT_TOKEN_H */
@@ -72,11 +72,9 @@
 #include "urn.h"
 #include "whois.h"
 #if USE_SSL
-#if 1 // USE_SSL_CERT_VALIDATOR
 #include "ssl/cert_validate_message.h"
 #include "ssl/Config.h"
 #include "ssl/helper.h"
-#endif
 #include "ssl/support.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/ServerBump.h"
@@ -95,7 +93,7 @@ static CNCB fwdConnectDoneWrapper;
 static OBJH fwdStats;
 
 #define MAX_FWD_STATS_IDX 9
-static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][HTTP_INVALID_HEADER + 1];
+static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][Http::scInvalidHeader + 1];
 
 static PconnPool *fwdPconnPool = new PconnPool("server-side");
 CBDATA_CLASS_INIT(FwdState);
@@ -126,7 +124,8 @@ FwdState::FwdState(const Comm::ConnectionPointer &client, StoreEntry * e, HttpRe
     debugs(17, 2, HERE << "Forwarding client request " << client << ", url=" << e->url() );
     entry = e;
     clientConn = client;
-    request = HTTPMSGLOCK(r);
+    request = r;
+    HTTPMSGLOCK(request);
     pconnRace = raceImpossible;
     start_t = squid_curtime;
     serverDestinations.reserve(Config.forward_max_tries);
@@ -174,16 +173,22 @@ FwdState::selectPeerForIntercepted()
 {
     // use pinned connection if available
     Comm::ConnectionPointer p;
-    if (ConnStateData *client = request->pinnedConnection())
+    if (ConnStateData *client = request->pinnedConnection()) {
         p = client->validatePinnedConnection(request, NULL);
+        if (Comm::IsConnOpen(p)) {
+            /* duplicate peerSelectPinned() effects */
+            p->peerType = PINNED;
+            entry->ping_status = PING_DONE;     /* Skip ICP */
 
-    if (Comm::IsConnOpen(p)) {
-        /* duplicate peerSelectPinned() effects */
-        p->peerType = PINNED;
-        entry->ping_status = PING_DONE;     /* Skip ICP */
-
-        debugs(17, 3, HERE << "reusing a pinned conn: " << *p);
-        serverDestinations.push_back(p);
+            debugs(17, 3, "reusing a pinned conn: " << *p);
+            serverDestinations.push_back(p);
+        } else {
+            debugs(17,2, "Pinned connection is not valid: " << p);
+            ErrorState *anErr = new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, request);
+            fail(anErr);
+        }
+        // Either use the valid pinned connection or fail if it is invalid.
+        return;
     }
 
     // use client original destination as second preferred choice
@@ -200,12 +205,12 @@ FwdState::selectPeerForIntercepted()
 void
 FwdState::completed()
 {
-    if (flags.forward_completed == 1) {
+    if (flags.forward_completed) {
         debugs(17, DBG_IMPORTANT, HERE << "FwdState::completed called on a completed request! Bad!");
         return;
     }
 
-    flags.forward_completed = 1;
+    flags.forward_completed = true;
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
         debugs(17, 3, HERE << "entry aborted");
@@ -219,6 +224,8 @@ FwdState::completed()
 
     if (entry->store_status == STORE_PENDING) {
         if (entry->isEmpty()) {
+            if (!err) // we quit (e.g., fd closed) before an error or content
+                fail(new ErrorState(ERR_READ_ERROR, Http::scBadGateway, request));
             assert(err);
             errorAppendEntry(entry, err);
             err = NULL;
@@ -292,19 +299,20 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
     if ( Config.accessList.miss && !request->client_addr.IsNoAddr() &&
             request->protocol != AnyP::PROTO_INTERNAL && request->protocol != AnyP::PROTO_CACHE_OBJECT) {
         /**
-         * Check if this host is allowed to fetch MISSES from us (miss_access)
+         * Check if this host is allowed to fetch MISSES from us (miss_access).
+         * Intentionally replace the src_addr automatically selected by the checklist code
+         * we do NOT want the indirect client address to be tested here.
          */
         ACLFilledChecklist ch(Config.accessList.miss, request, NULL);
         ch.src_addr = request->client_addr;
-        ch.my_addr = request->my_addr;
         if (ch.fastCheck() == ACCESS_DENIED) {
             err_type page_id;
             page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName, 1);
 
             if (page_id == ERR_NONE)
                 page_id = ERR_FORWARDING_DENIED;
 
-            ErrorState *anErr = new ErrorState(page_id, HTTP_FORBIDDEN, request);
+            ErrorState *anErr = new ErrorState(page_id, Http::scForbidden, request);
             errorAppendEntry(entry, anErr);	// frees anErr
             return;
         }
@@ -315,15 +323,16 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
      * This seems like an odd place to bind mem_obj and request.
      * Might want to assert that request is NULL at this point
      */
-    entry->mem_obj->request = HTTPMSGLOCK(request);
+    entry->mem_obj->request = request;
+    HTTPMSGLOCK(entry->mem_obj->request);
 #if URL_CHECKSUM_DEBUG
 
     entry->mem_obj->checkUrlChecksum();
 #endif
 
     if (shutting_down) {
         /* more yuck */
-        ErrorState *anErr = new ErrorState(ERR_SHUTTING_DOWN, HTTP_SERVICE_UNAVAILABLE, request);
+        ErrorState *anErr = new ErrorState(ERR_SHUTTING_DOWN, Http::scServiceUnavailable, request);
         errorAppendEntry(entry, anErr);	// frees anErr
         return;
     }
@@ -380,7 +389,7 @@ FwdState::startConnectionOrFail()
     } else {
         debugs(17, 3, HERE << "Connection failed: " << entry->url());
         if (!err) {
-            ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, HTTP_INTERNAL_SERVER_ERROR, request);
+            ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scInternalServerError, request);
             fail(anErr);
         } // else use actual error from last connection attempt
         self = NULL;       // refcounted
@@ -390,18 +399,29 @@ FwdState::startConnectionOrFail()
 void
 FwdState::fail(ErrorState * errorState)
 {
-    debugs(17, 3, HERE << err_type_str[errorState->type] << " \"" << httpStatusString(errorState->httpStatus) << "\"\n\t" << entry->url()  );
+    debugs(17, 3, err_type_str[errorState->type] << " \"" << Http::StatusCodeString(errorState->httpStatus) << "\"\n\t" << entry->url());
 
     delete err;
     err = errorState;
 
-    if (!errorState->request)
-        errorState->request = HTTPMSGLOCK(request);
+    if (!errorState->request) {
+        errorState->request = request;
+        HTTPMSGLOCK(errorState->request);
+    }
+
+    if (err->type != ERR_ZERO_SIZE_OBJECT)
+        return;
 
-    if (pconnRace == racePossible && err->type == ERR_ZERO_SIZE_OBJECT) {
+    if (pconnRace == racePossible) {
         debugs(17, 5, HERE << "pconn race happened");
         pconnRace = raceHappened;
     }
+
+    if (ConnStateData *pinned_connection = request->pinnedConnection()) {
+        pinned_connection->pinning.zeroReply = true;
+        flags.dont_retry = true; // we want to propagate failure to the client
+        debugs(17, 4, "zero reply on pinned connection");
+    }
 }
 
 /**
@@ -435,16 +455,16 @@ FwdState::unregister(int fd)
 void
 FwdState::complete()
 {
-    debugs(17, 3, HERE << entry->url() << "\n\tstatus " << entry->getReply()->sline.status  );
+    debugs(17, 3, HERE << entry->url() << "\n\tstatus " << entry->getReply()->sline.status());
 #if URL_CHECKSUM_DEBUG
 
     entry->mem_obj->checkUrlChecksum();
 #endif
 
-    logReplyStatus(n_tries, entry->getReply()->sline.status);
+    logReplyStatus(n_tries, entry->getReply()->sline.status());
 
     if (reforward()) {
-        debugs(17, 3, HERE << "re-forwarding " << entry->getReply()->sline.status << " " << entry->url());
+        debugs(17, 3, HERE << "re-forwarding " << entry->getReply()->sline.status() << " " << entry->url());
 
         if (Comm::IsConnOpen(serverConn))
             unregister(serverConn);
@@ -457,9 +477,9 @@ FwdState::complete()
 
     } else {
         if (Comm::IsConnOpen(serverConn))
-            debugs(17, 3, HERE << "server FD " << serverConnection()->fd << " not re-forwarding status " << entry->getReply()->sline.status);
+            debugs(17, 3, HERE << "server FD " << serverConnection()->fd << " not re-forwarding status " << entry->getReply()->sline.status());
         else
-            debugs(17, 3, HERE << "server (FD closed) not re-forwarding status " << entry->getReply()->sline.status);
+            debugs(17, 3, HERE << "server (FD closed) not re-forwarding status " << entry->getReply()->sline.status());
         EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
         entry->complete();
 
@@ -603,7 +623,7 @@ FwdState::retryOrBail()
     doneWithRetries();
 
     if (self != NULL && !err && shutting_down) {
-        ErrorState *anErr = new ErrorState(ERR_SHUTTING_DOWN, HTTP_SERVICE_UNAVAILABLE, request);
+        ErrorState *anErr = new ErrorState(ERR_SHUTTING_DOWN, Http::scServiceUnavailable, request);
         errorAppendEntry(entry, anErr);
     }
 
@@ -701,8 +721,7 @@ FwdState::negotiateSSL(int fd)
             // For intercepted connections, set the host name to the server
             // certificate CN. Otherwise, we just hope that CONNECT is using
             // a user-entered address (a host name or a user-entered IP).
-            const bool isConnectRequest = !request->clientConnectionManager->port->spoof_client_ip &&
-                                          !request->clientConnectionManager->port->intercepted;
+            const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
             if (request->flags.sslPeek && !isConnectRequest) {
                 if (X509 *srvX509 = errDetails->peerCert()) {
                     if (const char *name = Ssl::CommonHostName(srvX509)) {
@@ -744,18 +763,13 @@ FwdState::negotiateSSL(int fd)
         serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
     }
 
-#if 1 // USE_SSL_CERT_VALIDATOR
     if (Ssl::TheConfig.ssl_crt_validator) {
         Ssl::CertValidationRequest validationRequest;
-        // WARNING: The STACK_OF(*) OpenSSL objects does not support locking.
-        // If we need to support locking we need to sk_X509_dup the STACK_OF(X509)
-        // list and lock all of the X509 members of the list.
-        // Currently we do not use any locking for any of the members of the
-        // Ssl::CertValidationRequest class. If the ssl object gone, the value returned
-        // from SSL_get_peer_cert_chain may not exist any more. In this code the
+        // WARNING: Currently we do not use any locking for any of the
+        // members of the Ssl::CertValidationRequest class. In this code the
         // Ssl::CertValidationRequest object used only to pass data to
         // Ssl::CertValidationHelper::submit method.
-        validationRequest.peerCerts = SSL_get_peer_cert_chain(ssl);
+        validationRequest.ssl = ssl;
         validationRequest.domainName = request->GetHost();
         if (Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
             // validationRequest disappears on return so no need to cbdataReference
@@ -764,19 +778,15 @@ FwdState::negotiateSSL(int fd)
             validationRequest.errors = NULL;
         try {
             debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
-            Ssl::CertValidationMsg requestMsg(Ssl::CrtdMessage::REQUEST);
-            requestMsg.setCode(Ssl::CertValidationMsg::code_cert_validate);
-            requestMsg.composeRequest(validationRequest);
-            debugs(83, 5, "SSL crtvd request: " << requestMsg.compose().c_str());
-            Ssl::CertValidationHelper::GetInstance()->sslSubmit(requestMsg, sslCrtvdHandleReplyWrapper, this);
+            Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, sslCrtvdHandleReplyWrapper, this);
             return;
         } catch (const std::exception &e) {
             debugs(33, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
                    "request for " << validationRequest.domainName <<
                    " certificate: " << e.what() << "; will now block to " <<
                    "validate that certificate.");
             // fall through to do blocking in-process generation.
-            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request);
             fail(anErr);
             if (serverConnection()->getPeer()) {
                 peerConnectFailed(serverConnection()->getPeer());
@@ -786,66 +796,42 @@ FwdState::negotiateSSL(int fd)
             return;
         }
     }
-#endif // USE_SSL_CERT_VALIDATOR
 
     dispatch();
 }
 
-#if 1 // USE_SSL_CERT_VALIDATOR
 void
-FwdState::sslCrtvdHandleReplyWrapper(void *data, const HelperReply &reply)
+FwdState::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &validationResponse)
 {
     FwdState * fwd = (FwdState *)(data);
-    fwd->sslCrtvdHandleReply(reply);
+    fwd->sslCrtvdHandleReply(validationResponse);
 }
 
 void
-FwdState::sslCrtvdHandleReply(const HelperReply &reply)
+FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
 {
     Ssl::Errors *errs = NULL;
     Ssl::ErrorDetail *errDetails = NULL;
     bool validatorFailed = false;
     if (!Comm::IsConnOpen(serverConnection())) {
         return;
     }
-    SSL *ssl = fd_table[serverConnection()->fd].ssl;
 
-    if (!reply.other().hasContent()) {
-        debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper return <NULL> reply");
-        validatorFailed = true;
-    } else if (reply.result == HelperReply::BrokenHelper) {
-        debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper error response: " << reply.other().content());
+    debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
+
+    if (validationResponse.resultCode == HelperReply::Error)
+        errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
+    else if (validationResponse.resultCode != HelperReply::Okay)
         validatorFailed = true;
-    } else  {
-        Ssl::CertValidationMsg replyMsg(Ssl::CrtdMessage::REPLY);
-        Ssl::CertValidationResponse validationResponse;
-        std::string error;
-        STACK_OF(X509) *peerCerts = SSL_get_peer_cert_chain(ssl);
-        if (replyMsg.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK ||
-                   !replyMsg.parseResponse(validationResponse, peerCerts, error) ) {
-            debugs(83, 5, "Reply from ssl_crtvd for " << request->GetHost() << " is incorrect");
-            validatorFailed = true;
-        } else {
-            if (reply.result == HelperReply::Okay) {
-                debugs(83, 5, "Certificate for " << request->GetHost() << " was successfully validated from ssl_crtvd");
-            } else if (reply.result == HelperReply::Error) {
-                debugs(83, 5, "Certificate for " << request->GetHost() << " found buggy by ssl_crtvd");
-                errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
-            } else {
-                debugs(83, 5, "Certificate for " << request->GetHost() << " cannot be validated. ssl_crtvd response: " << replyMsg.getBody());
-                validatorFailed = true;
-            }
 
-            if (!errDetails && !validatorFailed) {
-                dispatch();
-                return;
-            }
-        }
+    if (!errDetails && !validatorFailed) {
+        dispatch();
+        return;
     }
 
     ErrorState *anErr = NULL;
     if (validatorFailed) {
-        anErr = new ErrorState(ERR_GATEWAY_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+        anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request);
     }  else {
 
         // Check the list error with
@@ -879,7 +865,7 @@ FwdState::sslCrtvdHandleReply(const HelperReply &reply)
 /// The first honored error, if any, is returned via errDetails parameter.
 /// The method returns all seen errors except SSL_ERROR_NONE as Ssl::Errors.
 Ssl::Errors *
-FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse &resp, Ssl::ErrorDetail *& errDetails)
+FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
 {
     Ssl::Errors *errs = NULL;
 
@@ -913,8 +899,10 @@ FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse &resp, Ssl::ErrorDe
                 const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
                 errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
             }
-            delete check->sslErrors;
-            check->sslErrors = NULL;
+            if (check) {
+                delete check->sslErrors;
+                check->sslErrors = NULL;
+            }
         }
 
         if (!errs)
@@ -928,8 +916,6 @@ FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse &resp, Ssl::ErrorDe
     return errs;
 }
 
-#endif // USE_SSL_CERT_VALIDATOR
-
 void
 FwdState::initiateSSL()
 {
@@ -949,7 +935,7 @@ FwdState::initiateSSL()
 
     if ((ssl = SSL_new(sslContext)) == NULL) {
         debugs(83, DBG_IMPORTANT, "fwdInitiateSSL: Error allocating handle: " << ERR_error_string(ERR_get_error(), NULL)  );
-        ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+        ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request);
         // TODO: create Ssl::ErrorDetail with OpenSSL-supplied error code
         fail(anErr);
         self = NULL;		// refcounted
@@ -981,8 +967,7 @@ FwdState::initiateSSL()
         // unless it was the CONNECT request with a user-typed address.
         const char *hostname = request->GetHost();
         const bool hostnameIsIp = request->GetHostIsNumeric();
-        const bool isConnectRequest = !request->clientConnectionManager->port->spoof_client_ip &&
-                                      !request->clientConnectionManager->port->intercepted;
+        const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
         if (!request->flags.sslPeek || isConnectRequest)
             SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
 
@@ -992,20 +977,16 @@ FwdState::initiateSSL()
             Ssl::setClientSNI(ssl, hostname);
     }
 
-#if 1 // USE_SSL_CERT_VALIDATOR
     // If CertValidation Helper used do not lookup checklist for errors,
     // but keep a list of errors to send it to CertValidator
     if (!Ssl::TheConfig.ssl_crt_validator) {
-#endif
         // Create the ACL check list now, while we have access to more info.
         // The list is used in ssl_verify_cb() and is freed in ssl_free().
         if (acl_access *acl = Config.ssl_client.cert_error) {
             ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
             SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
         }
-#if 1 // USE_SSL_CERT_VALIDATOR
     }
-#endif
 
     // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
     X509 *peeked_cert;
@@ -1053,18 +1034,8 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
     if (serverConnection()->getPeer())
         peerConnectSucceded(serverConnection()->getPeer());
 
-    // some requests benefit from pinning but do not require it and can "repin"
-    const bool rePin = request->flags.canRePin &&
-                       request->clientConnectionManager.valid();
-    if (rePin) {
-        debugs(17, 3, HERE << "repinning " << serverConn);
-        request->clientConnectionManager->pinConnection(serverConn,
-                request, serverConn->getPeer(), request->flags.auth);
-        request->flags.pinned = 1;
-    }
-
 #if USE_SSL
-    if (!request->flags.pinned || rePin) {
+    if (!request->flags.pinned) {
         if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
                 (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS) ||
                 request->flags.sslPeek) {
@@ -1085,7 +1056,7 @@ FwdState::connectTimeout(int fd)
     assert(fd == serverDestinations[0]->fd);
 
     if (entry->isEmpty()) {
-        ErrorState *anErr = new ErrorState(ERR_CONNECT_FAIL, HTTP_GATEWAY_TIMEOUT, request);
+        ErrorState *anErr = new ErrorState(ERR_CONNECT_FAIL, Http::scGateway_Timeout, request);
         anErr->xerrno = ETIMEDOUT;
         fail(anErr);
 
@@ -1133,57 +1104,47 @@ FwdState::connectStart()
 
     if (serverDestinations[0]->getPeer() && request->flags.sslBumped) {
         debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parrent proxy are not allowed");
-        ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, HTTP_SERVICE_UNAVAILABLE, request);
+        ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request);
         fail(anErr);
         self = NULL; // refcounted
         return;
     }
 
-    request->flags.pinned = 0; // XXX: what if the ConnStateData set this to flag existing credentials?
+    request->flags.pinned = false; // XXX: what if the ConnStateData set this to flag existing credentials?
     // XXX: answer: the peer selection *should* catch it and give us only the pinned peer. so we reverse the =0 step below.
     // XXX: also, logs will now lie if pinning is broken and leads to an error message.
     if (serverDestinations[0]->peerType == PINNED) {
         ConnStateData *pinned_connection = request->pinnedConnection();
+        debugs(17,7, "pinned peer connection: " << pinned_connection);
         // pinned_connection may become nil after a pconn race
         if (pinned_connection)
             serverConn = pinned_connection->validatePinnedConnection(request, serverDestinations[0]->getPeer());
         else
             serverConn = NULL;
         if (Comm::IsConnOpen(serverConn)) {
             flags.connected_okay = true;
-#if 0
-            if (!serverConn->getPeer())
-                serverConn->peerType = HIER_DIRECT;
-#endif
             ++n_tries;
-            request->flags.pinned = 1;
+            request->flags.pinned = true;
             if (pinned_connection->pinnedAuth())
-                request->flags.auth = 1;
+                request->flags.auth = true;
             comm_add_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
             // the server may close the pinned connection before this request
             pconnRace = racePossible;
             dispatch();
             return;
         }
-        /* Failure. Fall back on next path unless we can re-pin */
+        // Pinned connection failure.
         debugs(17,2,HERE << "Pinned connection failed: " << pinned_connection);
-        if (pconnRace != raceHappened || !request->flags.canRePin) {
-            serverDestinations.shift();
-            pconnRace = raceImpossible;
-            startConnectionOrFail();
-            return;
-        }
-        debugs(17,3, HERE << "There was a pconn race. Will try to repin.");
-        // and fall through to regular handling
+        ErrorState *anErr = new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, request);
+        fail(anErr);
+        self = NULL; // refcounted
+        return;
     }
 
     // Use pconn to avoid opening a new connection.
-    const char *host;
-    if (serverDestinations[0]->getPeer()) {
-        host = serverDestinations[0]->getPeer()->host;
-    } else {
+    const char *host = NULL;
+    if (!serverDestinations[0]->getPeer())
         host = request->GetHost();
-    }
 
     Comm::ConnectionPointer temp;
     // Avoid pconns after races so that the same client does not suffer twice.
@@ -1248,7 +1209,8 @@ FwdState::connectStart()
 
     calls.connector = commCbCall(17,3, "fwdConnectDoneWrapper", CommConnectCbPtrFun(fwdConnectDoneWrapper, this));
     Comm::ConnOpener *cs = new Comm::ConnOpener(serverDestinations[0], calls.connector, ctimeout);
-    cs->setHost(host);
+    if (host)
+        cs->setHost(host);
     AsyncJob::Start(cs);
 }
 
@@ -1355,10 +1317,10 @@ FwdState::dispatch()
 
         default:
             debugs(17, DBG_IMPORTANT, "WARNING: Cannot retrieve '" << entry->url() << "'.");
-            ErrorState *anErr = new ErrorState(ERR_UNSUP_REQ, HTTP_BAD_REQUEST, request);
+            ErrorState *anErr = new ErrorState(ERR_UNSUP_REQ, Http::scBadRequest, request);
             fail(anErr);
             // Set the dont_retry flag because this is not a transient (network) error.
-            flags.dont_retry = 1;
+            flags.dont_retry = true;
             if (Comm::IsConnOpen(serverConn)) {
                 serverConn->close();
             }
@@ -1379,7 +1341,6 @@ int
 FwdState::reforward()
 {
     StoreEntry *e = entry;
-    http_status s;
 
     if (EBIT_TEST(e->flags, ENTRY_ABORTED)) {
         debugs(17, 3, HERE << "entry aborted");
@@ -1415,7 +1376,7 @@ FwdState::reforward()
         return 0;
     }
 
-    s = e->getReply()->sline.status;
+    const Http::StatusCode s = e->getReply()->sline.status();
     debugs(17, 3, HERE << "status " << s);
     return reforwardableStatus(s);
 }
@@ -1430,7 +1391,7 @@ ErrorState *
 FwdState::makeConnectingError(const err_type type) const
 {
     return new ErrorState(type, request->flags.needValidation ?
-                          HTTP_GATEWAY_TIMEOUT : HTTP_SERVICE_UNAVAILABLE, request);
+                          Http::scGateway_Timeout : Http::scServiceUnavailable, request);
 }
 
 static void
@@ -1446,7 +1407,7 @@ fwdStats(StoreEntry * s)
 
     storeAppendPrintf(s, "\n");
 
-    for (i = 0; i <= (int) HTTP_INVALID_HEADER; ++i) {
+    for (i = 0; i <= (int) Http::scInvalidHeader; ++i) {
         if (FwdReplyCodes[0][i] == 0)
             continue;
 
@@ -1463,22 +1424,22 @@ fwdStats(StoreEntry * s)
 /**** STATIC MEMBER FUNCTIONS *************************************************/
 
 bool
-FwdState::reforwardableStatus(http_status s)
+FwdState::reforwardableStatus(const Http::StatusCode s) const
 {
     switch (s) {
 
-    case HTTP_BAD_GATEWAY:
+    case Http::scBadGateway:
 
-    case HTTP_GATEWAY_TIMEOUT:
+    case Http::scGateway_Timeout:
         return true;
 
-    case HTTP_FORBIDDEN:
+    case Http::scForbidden:
 
-    case HTTP_INTERNAL_SERVER_ERROR:
+    case Http::scInternalServerError:
 
-    case HTTP_NOT_IMPLEMENTED:
+    case Http::scNotImplemented:
 
-    case HTTP_SERVICE_UNAVAILABLE:
+    case Http::scServiceUnavailable:
         return Config.retry.onerror;
 
     default:
@@ -1498,7 +1459,7 @@ void
 FwdState::pconnPush(Comm::ConnectionPointer &conn, const char *domain)
 {
     if (conn->getPeer()) {
-        fwdPconnPool->push(conn, conn->getPeer()->name);
+        fwdPconnPool->push(conn, NULL);
     } else {
         fwdPconnPool->push(conn, domain);
     }
@@ -1517,9 +1478,9 @@ FwdState::RegisterWithCacheManager(void)
 }
 
 void
-FwdState::logReplyStatus(int tries, http_status status)
+FwdState::logReplyStatus(int tries, const Http::StatusCode status)
 {
-    if (status > HTTP_INVALID_HEADER)
+    if (status > Http::scInvalidHeader)
         return;
 
     assert(tries >= 0);
@@ -1620,24 +1581,12 @@ tos_t
 GetTosToServer(HttpRequest * request)
 {
     ACLFilledChecklist ch(NULL, request, NULL);
-
-    if (request) {
-        ch.src_addr = request->client_addr;
-        ch.my_addr = request->my_addr;
-    }
-
     return aclMapTOS(Ip::Qos::TheConfig.tosToServer, &ch);
 }
 
 nfmark_t
 GetNfmarkToServer(HttpRequest * request)
 {
     ACLFilledChecklist ch(NULL, request, NULL);
-
-    if (request) {
-        ch.src_addr = request->client_addr;
-        ch.my_addr = request->my_addr;
-    }
-
     return aclMapNfmark(Ip::Qos::TheConfig.nfmarkToServer, &ch);
 }
@@ -7,9 +7,9 @@
 #include "comm/Connection.h"
 #include "err_type.h"
 #include "fde.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 #include "ip/Address.h"
-#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+#if USE_SSL
 #include "ssl/support.h"
 #endif
 
@@ -20,7 +20,7 @@ typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class ErrorState;
 class HttpRequest;
 
-#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+#if USE_SSL
 namespace Ssl
 {
 class ErrorDetail;
@@ -65,7 +65,7 @@ class FwdState : public RefCountable
     void complete();
     void handleUnregisteredServerEnd();
     int reforward();
-    bool reforwardableStatus(http_status s);
+    bool reforwardableStatus(const Http::StatusCode s) const;
     void serverClosed(int fd);
     void connectStart();
     void connectDone(const Comm::ConnectionPointer & conn, comm_err_t status, int xerrno);
@@ -84,13 +84,13 @@ class FwdState : public RefCountable
     /** return a ConnectionPointer to the current server connection (may or may not be open) */
     Comm::ConnectionPointer const & serverConnection() const { return serverConn; };
 
-#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+#if USE_SSL
     /// Callback function called when squid receive message from cert validator helper
-    static void sslCrtvdHandleReplyWrapper(void *data, const HelperReply &reply);
+    static void sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &);
     /// Process response from cert validator helper
-    void sslCrtvdHandleReply(const HelperReply &reply);
+    void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
     /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
-    Ssl::Errors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse &, Ssl::ErrorDetail *&);
+    Ssl::Errors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
 #endif
 private:
     // hidden for safer management of self; use static fwdStart
@@ -100,7 +100,7 @@ class FwdState : public RefCountable
 #if STRICT_ORIGINAL_DST
     void selectPeerForIntercepted();
 #endif
-    static void logReplyStatus(int tries, http_status status);
+    static void logReplyStatus(int tries, const Http::StatusCode status);
     void doneWithRetries();
     void completed();
     void retryOrBail();
@@ -128,9 +128,9 @@ class FwdState : public RefCountable
     } calls;
 
     struct {
-        unsigned int connected_okay:1; ///< TCP link ever opened properly. This affects retry of POST,PUT,CONNECT,etc
-        unsigned int dont_retry:1;
-        unsigned int forward_completed:1;
+        bool connected_okay; ///< TCP link ever opened properly. This affects retry of POST,PUT,CONNECT,etc
+        bool dont_retry;
+        bool forward_completed;
     } flags;
 
     /** connections to open, in order, until successful */
@@ -116,8 +116,8 @@ class fqdncache_entry
     unsigned short locks;
 
     struct {
-        unsigned int negcached:1;
-        unsigned int fromhosts:1;
+        bool negcached;
+        bool fromhosts;
     } flags;
 
     int age() const; ///< time passed since request_time or -1 if unknown
@@ -428,7 +428,7 @@ fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const cha
     int ttl = 0;
     const char *name = (const char *)f->hash.key;
     f->expires = squid_curtime + Config.negativeDnsTtl;
-    f->flags.negcached = 1;
+    f->flags.negcached = true;
 
     if (nr < 0) {
         debugs(35, 3, "fqdncacheParse: Lookup of '" << name << "' failed (" << error_message << ")");
@@ -485,7 +485,7 @@ fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const cha
 
     f->expires = squid_curtime + ttl;
 
-    f->flags.negcached = 0;
+    f->flags.negcached = false;
 
     return f->name_count;
 }
@@ -702,25 +702,6 @@ fqdnStats(StoreEntry * sentry)
     }
 }
 
-/// \ingroup FQDNCacheAPI
-#if 0
-const char *
-fqdnFromAddr(const Ip::Address &addr)
-{
-    const char *n;
-    static char buf[MAX_IPSTRLEN];
-
-    if (Config.onoff.log_fqdn && (n = fqdncache_gethostbyaddr(addr, 0)))
-        return n;
-
-/// \todo Perhapse this should use toHostname() instead of straight NtoA.
-///       that would wrap the IPv6 properly when raw.
-    addr.NtoA(buf, MAX_IPSTRLEN);
-
-    return buf;
-}
-#endif
-
 /// \ingroup FQDNCacheInternal
 static void
 fqdncacheLockEntry(fqdncache_entry * f)
@@ -827,7 +808,7 @@ fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames)
 
     fce->name_count = j;
     fce->names[j] = NULL;	/* it's safe */
-    fce->flags.fromhosts = 1;
+    fce->flags.fromhosts = true;
     fqdncacheAddEntry(fce);
     fqdncacheLockEntry(fce);
 }
@@ -36,8 +36,9 @@ class CossMemBuf
     char buffer[COSS_MEMBUF_SZ];
 
     struct _cossmembuf_flags {
-        unsigned int full:1;
-        unsigned int writing:1;
+        _cossmembuf_flags() : full(false), writing(false) {}
+        bool full;
+        bool writing;
     } flags;
 };
 
@@ -68,9 +69,9 @@ class CossState : public StoreIOState
     size_t requestoffset;	/* in blocks */
     int64_t reqdiskoffset;	/* in blocks */
 
-    struct {
-        unsigned int reading:1;
-        unsigned int writing:1;
+    struct CossFlags {
+        bool reading;
+        bool writing;
     } flags;
 
     CossMemBuf *locked_membuf;
@@ -176,7 +176,7 @@ CossSwapDir::readCompleted(const char *buf, int len, int errflag, RefCount<ReadR
     ssize_t rlen;
 
     debugs(79, 3, "storeCossReadDone: fileno " << sio->swap_filen << ", len " << len);
-    cstate->flags.reading = 0;
+    cstate->flags.reading = false;
 
     if (errflag) {
         ++ StoreFScoss::GetInstance().stats.read.fail;
@@ -87,7 +87,7 @@ CossSwapDir::allocate(const StoreEntry * e, int which)
          * back to the beginning
          */
         ++ StoreFScoss::GetInstance().stats.disk_overflows;
-        current_membuf->flags.full = 1;
+        current_membuf->flags.full = true;
         current_membuf->diskend = current_offset;
         current_membuf->maybeWrite(this);
         current_offset = 0;	/* wrap back to beginning */
@@ -102,7 +102,7 @@ CossSwapDir::allocate(const StoreEntry * e, int which)
          * Skip the blank space at the end of the stripe. start over.
          */
         ++ StoreFScoss::GetInstance().stats.stripe_overflows;
-        current_membuf->flags.full = 1;
+        current_membuf->flags.full = true;
         current_offset = current_membuf->diskend;
         current_membuf->maybeWrite(this);
         debugs(79, 2, "CossSwapDir::allocate: New offset - " << current_offset);
@@ -183,8 +183,8 @@ CossSwapDir::createStoreIO(StoreEntry &e, StoreIOState::STFNCB * file_callback,
     sio->callback_data = cbdataReference(callback_data);
     sio->e = &e;
 
-    cstate->flags.writing = 0;
-    cstate->flags.reading = 0;
+    cstate->flags.writing = false;
+    cstate->flags.reading = false;
     cstate->readbuffer = NULL;
     cstate->reqdiskoffset = -1;
 
@@ -220,8 +220,8 @@ CossSwapDir::openStoreIO(StoreEntry & e, StoreIOState::STFNCB * file_callback,
     cstate->st_size = e.swap_file_sz;
     sio->e = &e;
 
-    cstate->flags.writing = 0;
-    cstate->flags.reading = 0;
+    cstate->flags.writing = false;
+    cstate->flags.reading = false;
     cstate->readbuffer = NULL;
     cstate->reqdiskoffset = -1;
     p = storeCossMemPointerFromDiskOffset(storeCossFilenoToDiskOffset(f), NULL);
@@ -308,7 +308,7 @@ CossState::read_(char *buf, size_t size, off_t offset, STRCB * callback, void *c
     read.callback_data = cbdataReference(callback_data);
     debugs(79, 3, "storeCossRead: offset " << offset);
     offset_ = offset;
-    flags.reading = 1;
+    flags.reading = true;
 
     if ((offset + (off_t)size) > st_size)
         size = st_size - offset;
@@ -543,7 +543,7 @@ CossMemBuf::write(CossSwapDir * SD)
 {
     ++ StoreFScoss::GetInstance().stats.stripe_write.ops;
     debugs(79, 3, "CossMemBuf::write: offset " << diskstart << ", len " << (diskend - diskstart));
-    flags.writing = 1;
+    flags.writing = true;
     /* XXX Remember that diskstart/diskend are block offsets! */
     SD->theFile->write(new CossWrite(WriteRequest((char const *)&buffer, diskstart, diskend - diskstart, NULL), this));
 }
@@ -563,8 +563,6 @@ CossSwapDir::createMemBuf(off_t start, sfileno curfn, int *collision)
     debugs(79, 3, "CossSwapDir::createMemBuf: creating new membuf at " << newmb->diskstart);
     debugs(79, 3, "CossSwapDir::createMemBuf: at " << newmb);
     newmb->diskend = newmb->diskstart + COSS_MEMBUF_SZ;
-    newmb->flags.full = 0;
-    newmb->flags.writing = 0;
     newmb->lockcount = 0;
     newmb->SD = this;
     /* XXX This should be reversed, with the new buffer last in the chain */
@@ -126,8 +126,8 @@ Rock::IoState::write(char const *buf, size_t size, off_t coreOff, FREE *dtor)
     try {
         tryWrite(buf, size, coreOff);
         success = true;
-    } catch (const std::exception &e) { // TODO: should we catch ... as well?
-        debugs(79, 2, "db write error: " << e.what());
+    } catch (const std::exception &ex) { // TODO: should we catch ... as well?
+        debugs(79, 2, "db write error: " << ex.what());
         dir->writeError(swap_filen);
         finishedWriting(DISK_ERROR);
         // 'this' might be gone beyond this point; fall through to free buf
@@ -165,14 +165,26 @@ Rock::SwapDir::create()
 
     debugs (47,3, HERE << "creating in " << path);
 
-    struct stat swap_sb;
-    if (::stat(path, &swap_sb) < 0) {
+    struct stat dir_sb;
+    if (::stat(path, &dir_sb) == 0) {
+        struct stat file_sb;
+        if (::stat(filePath, &file_sb) == 0) {
+            debugs (47, DBG_IMPORTANT, "Skipping existing Rock db: " << filePath);
+            return;
+        }
+        // else the db file is not there or is not accessible, and we will try
+        // to create it later below, generating a detailed error on failures.
+    } else { // path does not exist or is inaccessible
+        // If path exists but is not accessible, mkdir() below will fail, and
+        // the admin should see the error and act accordingly, so there is
+        // no need to distinguish ENOENT from other possible stat() errors.
         debugs (47, DBG_IMPORTANT, "Creating Rock db directory: " << path);
         const int res = mkdir(path, 0700);
         if (res != 0)
             createError("mkdir");
     }
 
+    debugs (47, DBG_IMPORTANT, "Creating Rock db: " << filePath);
     const int swap = open(filePath, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0600);
     if (swap < 0)
         createError("create");
@@ -285,14 +297,14 @@ Rock::SwapDir::reconfigure()
 
 /// parse maximum db disk size
 void
-Rock::SwapDir::parseSize(const bool reconfiguring)
+Rock::SwapDir::parseSize(const bool reconfig)
 {
     const int i = GetInteger();
     if (i < 0)
         fatal("negative Rock cache_dir size value");
     const uint64_t new_max_size =
         static_cast<uint64_t>(i) << 20; // MBytes to Bytes
-    if (!reconfiguring)
+    if (!reconfig)
         max_size = new_max_size;
     else if (new_max_size != max_size) {
         debugs(3, DBG_IMPORTANT, "WARNING: cache_dir '" << path << "' size "
@@ -321,7 +333,7 @@ Rock::SwapDir::allowOptionReconfigure(const char *const option) const
 
 /// parses time-specific options; mimics ::SwapDir::optionObjectSizeParse()
 bool
-Rock::SwapDir::parseTimeOption(char const *option, const char *value, int reconfiguring)
+Rock::SwapDir::parseTimeOption(char const *option, const char *value, int reconfig)
 {
     // TODO: ::SwapDir or, better, Config should provide time-parsing routines,
     // including time unit handling. Same for size and rate.
@@ -344,7 +356,7 @@ Rock::SwapDir::parseTimeOption(char const *option, const char *value, int reconf
 
     const time_msec_t newTime = static_cast<time_msec_t>(parsedValue);
 
-    if (!reconfiguring)
+    if (!reconfig)
         *storedTime = newTime;
     else if (*storedTime != newTime) {
         debugs(3, DBG_IMPORTANT, "WARNING: cache_dir " << path << ' ' << option
@@ -412,7 +424,7 @@ Rock::SwapDir::dumpRateOption(StoreEntry * e) const
 
 /// parses size-specific options; mimics ::SwapDir::optionObjectSizeParse()
 bool
-Rock::SwapDir::parseSizeOption(char const *option, const char *value, int reconfiguring)
+Rock::SwapDir::parseSizeOption(char const *option, const char *value, int reconfig)
 {
     uint64_t *storedSize;
     if (strcmp(option, "slot-size") == 0)
@@ -435,7 +447,7 @@ Rock::SwapDir::parseSizeOption(char const *option, const char *value, int reconf
         self_destruct();
     }
 
-    if (!reconfiguring)
+    if (!reconfig)
         *storedSize = newSize;
     else if (*storedSize != newSize) {
         debugs(3, DBG_IMPORTANT, "WARNING: cache_dir " << path << ' ' << option
@@ -713,12 +725,12 @@ Rock::SwapDir::readCompleted(const char *buf, int rlen, int errflag, RefCount< :
     if (errflag == DISK_OK && rlen > 0)
         sio->offset_ += rlen;
 
-    StoreIOState::STRCB *callback = sio->read.callback;
-    assert(callback);
+    StoreIOState::STRCB *callb = sio->read.callback;
+    assert(callb);
     sio->read.callback = NULL;
     void *cbdata;
     if (cbdataReferenceValidDone(sio->read.callback_data, &cbdata))
-        callback(cbdata, r->buf, rlen, sio.getRaw());
+        callb(cbdata, r->buf, rlen, sio.getRaw());
 }
 
 void
@@ -63,7 +63,7 @@ Fs::Ufs::RebuildState::RebuildState(RefCount<UFSSwapDir> aSwapDir) :
      * use commonUfsDirRebuildFromDirectory() to open up each file
      * and suck in the meta data.
      */
-    int clean = 0;
+    int clean = 0; //TODO: change to bool
     int zeroLengthLog = 0;
     FILE *fp = sd->openTmpSwapLog(&clean, &zeroLengthLog);
 
@@ -78,11 +78,11 @@ Fs::Ufs::RebuildState::RebuildState(RefCount<UFSSwapDir> aSwapDir) :
 
     } else {
         fromLog = true;
-        flags.clean = (unsigned int) clean;
+        flags.clean = (clean != 0);
     }
 
     if (!clean)
-        flags.need_to_validate = 1;
+        flags.need_to_validate = true;
 
     debugs(47, DBG_IMPORTANT, "Rebuilding storage in " << sd->path << " (" <<
            (clean ? "clean log" : (LogParser ? "dirty log" : "no log")) << ")");
@@ -454,12 +454,12 @@ Fs::Ufs::RebuildState::getNextFile(sfileno * filn_p, int *size)
     while (fd < 0 && done == 0) {
         fd = -1;
 
-        if (0 == flags.init) {  /* initialize, open first file */
+        if (!flags.init) {  /* initialize, open first file */
             done = 0;
             curlvl1 = 0;
             curlvl2 = 0;
             in_dir = 0;
-            flags.init = 1;
+            flags.init = true;
             assert(Config.cacheSwap.n_configured > 0);
         }
 
@@ -62,10 +62,11 @@ class RebuildState : public RefCountable
     int curlvl1;
     int curlvl2;
 
-    struct {
-        unsigned int need_to_validate:1;
-        unsigned int clean:1;
-        unsigned int init:1;
+    struct Flags {
+        Flags() : need_to_validate(false), clean(false), init(false) {}
+        bool need_to_validate;
+        bool clean;
+        bool init;
     } flags;
     int in_dir;
     int done;
@@ -34,16 +34,8 @@
 /*TODO: remove this file as unused*/
 
 #include "squid.h"
-#if 0
-#include "StoreFileSystem.h"
-#endif
-
 #include "fs/ufs/StoreFSufs.h"
 #include "fs/ufs/UFSSwapDir.h"
 
-#if 0
-#include "DiskIO/DiskIOModule.h"
-#endif
-
 /* Unused variable: */
 Fs::Ufs::StoreFSufs<Fs::Ufs::UFSSwapDir> *UfsInstance_foo = NULL;
@@ -236,7 +236,7 @@ Fs::Ufs::UFSSwapDir::changeIO(DiskIOModule *module)
     /* TODO: factor out these 4 lines */
     ConfigOption *ioOptions = IO->io->getOptionTree();
 
-    if (ioOptions)
+    if (currentIOOptions && ioOptions)
         currentIOOptions->options.push_back(ioOptions);
 }
 
@@ -341,15 +341,10 @@ Fs::Ufs::UFSSwapDir::~UFSSwapDir()
         file_close(swaplog_fd);
         swaplog_fd = -1;
     }
-
-    delete map;
-
-    if (IO)
-        delete IO;
-
-    IO = NULL;
-
     safe_free(ioType);
+    delete map;
+    delete IO;
+    delete currentIOOptions;
 }
 
 void
@@ -681,32 +681,23 @@ FtpStateData::ftpTimeout(const CommTimeoutCbParams &io)
     if (abortOnBadEntry("entry went bad while waiting for a timeout"))
         return;
 
-    if (SENT_PASV == state && io.conn->fd == data.conn->fd) {
-        /* stupid ftp.netscape.com */
+    if (SENT_PASV == state) {
+        /* stupid ftp.netscape.com, of FTP server behind stupid firewall rules */
         flags.pasv_supported = false;
         debugs(9, DBG_IMPORTANT, "ftpTimeout: timeout in SENT_PASV state" );
+
+        // cancel the data connection setup.
+        if (data.opener != NULL) {
+            data.opener->cancel("timeout");
+            data.opener = NULL;
+        }
+        data.close();
     }
 
     failed(ERR_READ_TIMEOUT, 0);
     /* failed() closes ctrl.conn and frees ftpState */
 }
 
-#if DEAD_CODE // obsoleted by ERR_DIR_LISTING
-void
-FtpStateData::listingFinish()
-{
-    // TODO: figure out what this means and how to show it ...
-
-    if (flags.listformat_unknown && !flags.tried_nlst) {
-        printfReplyBody("<a href=\"%s/;type=d\">[As plain directory]</a>\n",
-                        flags.dir_slash ? rfc1738_escape_part(old_filepath) : ".");
-    } else if (typecode == 'D') {
-        const char *path = flags.dir_slash ? filepath : ".";
-        printfReplyBody("<a href=\"%s/\">[As extended directory]</a>\n", rfc1738_escape_part(path));
-    }
-}
-#endif /* DEAD_CODE */
-
 /// \ingroup ServerProtocolFTPInternal
 static const char *Month[] = {
     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
@@ -1912,16 +1903,16 @@ FtpStateData::loginFailed()
     if ((state == SENT_USER || state == SENT_PASS) && ctrl.replycode >= 400) {
         if (ctrl.replycode == 421 || ctrl.replycode == 426) {
             // 421/426 - Service Overload - retry permitted.
-            err = new ErrorState(ERR_FTP_UNAVAILABLE, HTTP_SERVICE_UNAVAILABLE, fwd->request);
+            err = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd->request);
         } else if (ctrl.replycode >= 430 && ctrl.replycode <= 439) {
             // 43x - Invalid or Credential Error - retry challenge required.
-            err = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_UNAUTHORIZED, fwd->request);
+            err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
         } else if (ctrl.replycode >= 530 && ctrl.replycode <= 539) {
             // 53x - Credentials Missing - retry challenge required
             if (password_url) // but they were in the URI! major fail.
-                err = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_FORBIDDEN, fwd->request);
+                err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd->request);
             else
-                err = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_UNAUTHORIZED, fwd->request);
+                err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
         }
     }
 
@@ -3287,7 +3278,7 @@ FtpStateData::completedListing()
 {
     assert(entry);
     entry->lock();
-    ErrorState ferr(ERR_DIR_LISTING, HTTP_OK, request);
+    ErrorState ferr(ERR_DIR_LISTING, Http::scOkay, request);
     ferr.ftp.listing = &listing;
     ferr.ftp.cwd_msg = xstrdup(cwd_message.size()? cwd_message.termedBuf() : "");
     ferr.ftp.server_msg = ctrl.message;
@@ -3509,20 +3500,20 @@ FtpStateData::failedErrorMessage(err_type error, int xerrno)
 
             if (ctrl.replycode > 500)
                 if (password_url)
-                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_FORBIDDEN, fwd->request);
+                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd->request);
                 else
-                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_UNAUTHORIZED, fwd->request);
+                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
 
             else if (ctrl.replycode == 421)
-                ftperr = new ErrorState(ERR_FTP_UNAVAILABLE, HTTP_SERVICE_UNAVAILABLE, fwd->request);
+                ftperr = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd->request);
 
             break;
 
         case SENT_CWD:
 
         case SENT_RETR:
             if (ctrl.replycode == 550)
-                ftperr = new ErrorState(ERR_FTP_NOT_FOUND, HTTP_NOT_FOUND, fwd->request);
+                ftperr = new ErrorState(ERR_FTP_NOT_FOUND, Http::scNotFound, fwd->request);
 
             break;
 
@@ -3533,16 +3524,16 @@ FtpStateData::failedErrorMessage(err_type error, int xerrno)
         break;
 
     case ERR_READ_TIMEOUT:
-        ftperr = new ErrorState(error, HTTP_GATEWAY_TIMEOUT, fwd->request);
+        ftperr = new ErrorState(error, Http::scGateway_Timeout, fwd->request);
         break;
 
     default:
-        ftperr = new ErrorState(error, HTTP_BAD_GATEWAY, fwd->request);
+        ftperr = new ErrorState(error, Http::scBadGateway, fwd->request);
         break;
     }
 
     if (ftperr == NULL)
-        ftperr = new ErrorState(ERR_FTP_FAILURE, HTTP_BAD_GATEWAY, fwd->request);
+        ftperr = new ErrorState(ERR_FTP_FAILURE, Http::scBadGateway, fwd->request);
 
     ftperr->xerrno = xerrno;
 
@@ -3577,7 +3568,7 @@ static void
 ftpSendReply(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    http_status http_code;
+    Http::StatusCode http_code;
     err_type err_code = ERR_NONE;
 
     debugs(9, 3, HERE << ftpState->entry->url() << ", code " << code);
@@ -3587,13 +3578,13 @@ ftpSendReply(FtpStateData * ftpState)
 
     if (code == 226 || code == 250) {
         err_code = (ftpState->mdtm > 0) ? ERR_FTP_PUT_MODIFIED : ERR_FTP_PUT_CREATED;
-        http_code = (ftpState->mdtm > 0) ? HTTP_ACCEPTED : HTTP_CREATED;
+        http_code = (ftpState->mdtm > 0) ? Http::scAccepted : Http::scCreated;
     } else if (code == 227) {
         err_code = ERR_FTP_PUT_CREATED;
-        http_code = HTTP_CREATED;
+        http_code = Http::scCreated;
     } else {
         err_code = ERR_FTP_PUT_ERROR;
-        http_code = HTTP_INTERNAL_SERVER_ERROR;
+        http_code = Http::scInternalServerError;
     }
 
     ErrorState err(err_code, http_code, ftpState->request);
@@ -3669,7 +3660,7 @@ FtpStateData::appendSuccessHeader()
 
     if (0 == getCurrentOffset()) {
         /* Full reply */
-        reply->setHeaders(HTTP_OK, "Gatewaying", mime_type, theSize, mdtm, -2);
+        reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, theSize, mdtm, -2);
     } else if (theSize < getCurrentOffset()) {
         /*
          * DPW 2007-05-04
@@ -3681,13 +3672,13 @@ FtpStateData::appendSuccessHeader()
                " current offset=" << getCurrentOffset() <<
                ", but theSize=" << theSize <<
                ".  assuming full content response");
-        reply->setHeaders(HTTP_OK, "Gatewaying", mime_type, theSize, mdtm, -2);
+        reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, theSize, mdtm, -2);
     } else {
         /* Partial reply */
         HttpHdrRangeSpec range_spec;
         range_spec.offset = getCurrentOffset();
         range_spec.length = theSize - getCurrentOffset();
-        reply->setHeaders(HTTP_PARTIAL_CONTENT, "Gatewaying", mime_type, theSize - getCurrentOffset(), mdtm, -2);
+        reply->setHeaders(Http::scPartialContent, "Gatewaying", mime_type, theSize - getCurrentOffset(), mdtm, -2);
         httpHeaderAddContRange(&reply->header, range_spec, theSize);
     }
 
@@ -3723,7 +3714,7 @@ FtpStateData::haveParsedReplyHeaders()
 HttpReply *
 FtpStateData::ftpAuthRequired(HttpRequest * request, const char *realm)
 {
-    ErrorState err(ERR_CACHE_ACCESS_DENIED, HTTP_UNAUTHORIZED, request);
+    ErrorState err(ERR_CACHE_ACCESS_DENIED, Http::scUnauthorized, request);
     HttpReply *newrep = err.BuildHttpReply();
 #if HAVE_AUTH_MODULE_BASIC
     /* add Authenticate header */
@@ -60,8 +60,6 @@ extern const char *memStatusStr[];
 extern const char *pingStatusStr[];
 extern const char *storeStatusStr[];
 extern const char *swapStatusStr[];
-class fde;
-extern fde *fd_table;		/* NULL */
 extern int Biggest_FD;		/* -1 */
 extern int Number_FD;		/* 0 */
 extern int Opening_FD;		/* 0 */
@@ -257,7 +257,7 @@ gopherMimeCreate(GopherStateData * gopherState)
 
     HttpReply *reply = new HttpReply;
     entry->buffer();
-    reply->setHeaders(HTTP_OK, "Gatewaying", mime_type, -1, -1, -2);
+    reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, -1, -1, -2);
     if (mime_enc)
         reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
 
@@ -726,7 +726,7 @@ gopherTimeout(const CommTimeoutCbParams &io)
     GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);
     debugs(10, 4, HERE << io.conn << ": '" << gopherState->entry->url() << "'" );
 
-    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT, gopherState->fwd->request));
+    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGateway_Timeout, gopherState->fwd->request));
 
     if (Comm::IsConnOpen(io.conn))
         io.conn->close();
@@ -804,13 +804,13 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, comm
                                                  CommIoCbPtrFun(gopherReadReply, gopherState));
             comm_read(conn, buf, read_sz, call);
         } else {
-            ErrorState *err = new ErrorState(ERR_READ_ERROR, HTTP_INTERNAL_SERVER_ERROR, gopherState->fwd->request);
+            ErrorState *err = new ErrorState(ERR_READ_ERROR, Http::scInternalServerError, gopherState->fwd->request);
             err->xerrno = xerrno;
             gopherState->fwd->fail(err);
             gopherState->serverConn->close();
         }
     } else if (len == 0 && entry->isEmpty()) {
-        gopherState->fwd->fail(new ErrorState(ERR_ZERO_SIZE_OBJECT, HTTP_SERVICE_UNAVAILABLE, gopherState->fwd->request));
+        gopherState->fwd->fail(new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, gopherState->fwd->request));
         gopherState->serverConn->close();
     } else if (len == 0) {
         /* Connection closed; retrieval done. */
@@ -854,7 +854,7 @@ gopherSendComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size,
 
     if (errflag) {
         ErrorState *err;
-        err = new ErrorState(ERR_WRITE_ERROR, HTTP_SERVICE_UNAVAILABLE, gopherState->fwd->request);
+        err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request);
         err->xerrno = xerrno;
         err->port = gopherState->fwd->request->port;
         err->url = xstrdup(entry->url());
@@ -102,7 +102,7 @@ HelperServerBase::closePipesSafely()
     shutdown(writePipe->fd, SD_BOTH);
 #endif
 
-    flags.closing = 1;
+    flags.closing = true;
     if (readPipe->fd == writePipe->fd)
         readPipe->fd = -1;
     else
@@ -131,7 +131,7 @@ HelperServerBase::closeWritePipeSafely()
     shutdown(writePipe->fd, (readPipe->fd == writePipe->fd ? SD_BOTH : SD_SEND));
 #endif
 
-    flags.closing = 1;
+    flags.closing = true;
     if (readPipe->fd == writePipe->fd)
         readPipe->fd = -1;
     writePipe->close();
@@ -347,7 +347,7 @@ helperStatefulOpenServers(statefulhelper * hlp)
         helper_stateful_server *srv = cbdataAlloc(helper_stateful_server);
         srv->hIpc = hIpc;
         srv->pid = pid;
-        srv->flags.reserved = 0;
+        srv->flags.reserved = false;
         srv->initStats();
         srv->index = k;
         srv->addr = hlp->addr;
@@ -415,7 +415,7 @@ helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
     else
         Enqueue(hlp, r);
 
-    debugs(84, 9, "helperSubmit: " << buf);
+    debugs(84, DBG_DATA, Raw("buf", buf, strlen(buf)));
 }
 
 /// lastserver = "server last used as part of a reserved request sequence"
@@ -457,7 +457,8 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
             StatefulEnqueue(hlp, r);
     }
 
-    debugs(84, 9, "helperStatefulSubmit: placeholder: '" << r->placeholder << "', buf '" << buf << "'.");
+    debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
+           "', " << Raw("buf", buf, strlen(buf)));
 }
 
 /**
@@ -475,7 +476,7 @@ helperStatefulReleaseServer(helper_stateful_server * srv)
 
     ++ srv->stats.releases;
 
-    srv->flags.reserved = 0;
+    srv->flags.reserved = false;
     if (srv->parent->OnEmptyQueue != NULL && srv->data)
         srv->parent->OnEmptyQueue(srv->data);
 
@@ -621,7 +622,7 @@ helperShutdown(helper * hlp)
 
         assert(hlp->childs.n_active > 0);
         -- hlp->childs.n_active;
-        srv->flags.shutdown = 1;	/* request it to shut itself down */
+        srv->flags.shutdown = true;	/* request it to shut itself down */
 
         if (srv->flags.closing) {
             debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is CLOSING.");
@@ -658,7 +659,7 @@ helperStatefulShutdown(statefulhelper * hlp)
 
         assert(hlp->childs.n_active > 0);
         -- hlp->childs.n_active;
-        srv->flags.shutdown = 1;	/* request it to shut itself down */
+        srv->flags.shutdown = true;	/* request it to shut itself down */
 
         if (srv->flags.busy) {
             debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is BUSY.");
@@ -848,9 +849,6 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
 {
     helper_request *r = srv->requests[request_number];
     if (r) {
-// TODO: parse the reply into new helper reply object
-// pass that to the callback instead of msg
-
         HLPCB *callback = r->callback;
 
         srv->requests[request_number] = NULL;
@@ -883,15 +881,12 @@ helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char *
                request_number << " from " << hlp->id_name << " #" << srv->index + 1 <<
                " '" << srv->rbuf << "'");
     }
-    srv->roffset -= (msg_end - srv->rbuf);
-    memmove(srv->rbuf, msg_end, srv->roffset + 1);
 
     if (!srv->flags.shutdown) {
         helperKickQueue(hlp);
     } else if (!srv->flags.closing && !srv->stats.pending) {
-        srv->flags.closing=1;
+        srv->flags.closing=true;
         srv->writePipe->close();
-        return;
     }
 }
 
@@ -920,7 +915,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
 
     srv->roffset += len;
     srv->rbuf[srv->roffset] = '\0';
-    debugs(84, 9, "helperHandleRead: '" << srv->rbuf << "'");
+    debugs(84, DBG_DATA, Raw("accumulated", srv->rbuf, srv->roffset));
 
     if (!srv->stats.pending) {
         /* someone spoke without being spoken to */
@@ -936,10 +931,16 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
         /* end of reply found */
         char *msg = srv->rbuf;
         int i = 0;
+        int skip = 1;
         debugs(84, 3, "helperHandleRead: end of reply found");
 
-        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n')
-            t[-1] = '\0';
+        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n') {
+            *t = '\0';
+            // rewind to the \r octet which is the real terminal now
+            // and remember that we have to skip forward 2 places now.
+            skip = 2;
+            --t;
+        }
 
         *t = '\0';
 
@@ -951,8 +952,9 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
         }
 
         helperReturnBuffer(i, srv, hlp, msg, t);
-        // only skip off the \0 _after_ passing its location to helperReturnBuffer
-        ++t;
+        srv->roffset -= (t - srv->rbuf) + skip;
+        memmove(srv->rbuf, t + skip, srv->roffset);
+        srv->rbuf[srv->roffset] = '\0';
     }
 
     if (Comm::IsConnOpen(srv->readPipe)) {
@@ -1011,6 +1013,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
     srv->roffset += len;
     srv->rbuf[srv->roffset] = '\0';
     r = srv->request;
+    debugs(84, DBG_DATA, Raw("accumulated", srv->rbuf, srv->roffset));
 
     if (r == NULL) {
         /* someone spoke without being spoken to */
@@ -1048,7 +1051,13 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
         // only skip off the \0's _after_ passing its location in HelperReply above
         t += skip;
 
-        srv->flags.busy = 0;
+        srv->flags.busy = false;
+        /**
+         * BUG: the below assumes that only one response per read() was received and discards any octets remaining.
+         *      Doing this prohibits concurrency support with multiple replies per read().
+         * TODO: check that read() setup on these buffers pays attention to roffest!=0
+         * TODO: check that replies bigger than the buffer are discarded and do not to affect future replies
+         */
         srv->roffset = 0;
         helperStatefulRequestFree(r);
         srv->request = NULL;
@@ -1283,7 +1292,7 @@ helperDispatchWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t l
     srv->writebuf->clean();
     delete srv->writebuf;
     srv->writebuf = NULL;
-    srv->flags.writing = 0;
+    srv->flags.writing = false;
 
     if (flag != COMM_OK) {
         /* Helper server has crashed */
@@ -1294,7 +1303,7 @@ helperDispatchWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t l
     if (!srv->wqueue->isNull()) {
         srv->writebuf = srv->wqueue;
         srv->wqueue = new MemBuf;
-        srv->flags.writing = 1;
+        srv->flags.writing = true;
         AsyncCall::Pointer call = commCbCall(5,5, "helperDispatchWriteDone",
                                              CommIoCbPtrFun(helperDispatchWriteDone, srv));
         Comm::Write(srv->writePipe, srv->writebuf->content(), srv->writebuf->contentSize(), call, NULL);
@@ -1337,7 +1346,7 @@ helperDispatch(helper_server * srv, helper_request * r)
         assert(NULL == srv->writebuf);
         srv->writebuf = srv->wqueue;
         srv->wqueue = new MemBuf;
-        srv->flags.writing = 1;
+        srv->flags.writing = true;
         AsyncCall::Pointer call = commCbCall(5,5, "helperDispatchWriteDone",
                                              CommIoCbPtrFun(helperDispatchWriteDone, srv));
         Comm::Write(srv->writePipe, srv->writebuf->content(), srv->writebuf->contentSize(), call, NULL);
@@ -1389,8 +1398,8 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
         return;
     }
 
-    srv->flags.busy = 1;
-    srv->flags.reserved = 1;
+    srv->flags.busy = true;
+    srv->flags.reserved = true;
     srv->request = r;
     srv->dispatch_time = current_time;
     AsyncCall::Pointer call = commCbCall(5,5, "helperStatefulDispatchWriteDone",
@@ -48,7 +48,15 @@ typedef void HLPCB(void *, const HelperReply &reply);
 class helper
 {
 public:
-    inline helper(const char *name) : cmdline(NULL), id_name(name), eom('\n') {}
+    inline helper(const char *name) :
+            cmdline(NULL),
+            id_name(name),
+            ipc_type(0),
+            last_queue_warn(0),
+            last_restart(0),
+            eom('\n') {
+        memset(&stats, 0, sizeof(stats));
+    }
     ~helper();
 
 public:
@@ -77,7 +85,7 @@ class helper
 class statefulhelper : public helper
 {
 public:
-    inline statefulhelper(const char *name) : helper(name) {};
+    inline statefulhelper(const char *name) : helper(name), datapool(NULL), IsAvailable(NULL), OnEmptyQueue(NULL) {};
     inline ~statefulhelper() {};
 
 public:
@@ -124,11 +132,11 @@ class HelperServerBase
     dlink_node link;
 
     struct _helper_flags {
-        unsigned int busy:1;
-        unsigned int writing:1;
-        unsigned int closing:1;
-        unsigned int shutdown:1;
-        unsigned int reserved:1;
+        bool busy;
+        bool writing;
+        bool closing;
+        bool shutdown;
+        bool reserved;
     } flags;
 
     struct {
@@ -267,7 +267,7 @@ static void htcpFreeDetail(htcpDetail * s);
 
 static void htcpHandleMsg(char *buf, int sz, Ip::Address &from);
 
-static void htcpLogHtcp(Ip::Address &, int, log_type, const char *);
+static void htcpLogHtcp(Ip::Address &, int, LogTags, const char *);
 static void htcpHandleMon(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
 static void htcpHandleNop(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
@@ -1088,14 +1088,15 @@ htcpHandleTst(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
         htcpHandleTstResponse(hdr, buf, sz, from);
 }
 
-HtcpReplyData::HtcpReplyData() : hdr(hoHtcpReply)
+HtcpReplyData::HtcpReplyData() :
+        hit(0), hdr(hoHtcpReply), msg_id(0), version(0.0)
 {}
 
 static void
 
 htcpHandleTstResponse(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from)
 {
-    htcpReplyData htcpReply;
+    HtcpReplyData htcpReply;
     cache_key *key = NULL;
 
     Ip::Address *peer;
@@ -1180,14 +1181,13 @@ htcpHandleTstRequest(htcpDataHeader * dhdr, char *buf, int sz, Ip::Address &from
     /* s is a new object */
     s = htcpUnpackSpecifier(buf, sz);
 
-    s->setFrom(from);
-
-    s->setDataHeader(dhdr);
-
-    if (NULL == s) {
+    if (s == NULL) {
         debugs(31, 3, "htcpHandleTstRequest: htcpUnpackSpecifier failed");
         htcpLogHtcp(from, dhdr->opcode, LOG_UDP_INVALID, dash_str);
         return;
+    } else {
+        s->setFrom(from);
+        s->setDataHeader(dhdr);
     }
 
     if (!s->request) {
@@ -1721,7 +1721,7 @@ htcpClosePorts(void)
 }
 
 static void
-htcpLogHtcp(Ip::Address &caddr, int opcode, log_type logcode, const char *url)
+htcpLogHtcp(Ip::Address &caddr, int opcode, LogTags logcode, const char *url)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry;
     if (LOG_TAG_NONE == logcode)
@@ -57,11 +57,8 @@ class HtcpReplyData
     } cto;
 };
 
-/// \bug redundant typedef
-typedef class HtcpReplyData htcpReplyData;
-
 /// \ingroup ServerProtocolHTCP
-void neighborsHtcpReply(const cache_key *, htcpReplyData *, const Ip::Address &);
+void neighborsHtcpReply(const cache_key *, HtcpReplyData *, const Ip::Address &);
 
 /// \ingroup ServerProtocolHTCP
 void htcpOpenPorts(void);
@@ -97,7 +97,7 @@ CBDATA_CLASS_INIT(HttpStateData);
 
 static const char *const crlf = "\r\n";
 
-static void httpMaybeRemovePublic(StoreEntry *, http_status);
+static void httpMaybeRemovePublic(StoreEntry *, Http::StatusCode);
 static void copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, const String strConnection, const HttpRequest * request,
         HttpHeader * hdr_out, const int we_do_ranges, const HttpStateFlags &);
 //Declared in HttpHeaderTools.cc
@@ -122,7 +122,7 @@ HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"),
         _peer = cbdataReference(fwd->serverConnection()->getPeer());         /* might be NULL */
 
     if (_peer) {
-        request->flags.proxying = 1;
+        request->flags.proxying = true;
         /*
          * This NEIGHBOR_PROXY_ONLY check probably shouldn't be here.
          * We might end up getting the object from somewhere else if,
@@ -182,14 +182,14 @@ HttpStateData::httpTimeout(const CommTimeoutCbParams &params)
     debugs(11, 4, HERE << serverConnection << ": '" << entry->url() << "'" );
 
     if (entry->store_status == STORE_PENDING) {
-        fwd->fail(new ErrorState(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT, fwd->request));
+        fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGateway_Timeout, fwd->request));
     }
 
     serverConnection->close();
 }
 
 static void
-httpMaybeRemovePublic(StoreEntry * e, http_status status)
+httpMaybeRemovePublic(StoreEntry * e, Http::StatusCode status)
 {
     int remove = 0;
     int forbidden = 0;
@@ -200,33 +200,33 @@ httpMaybeRemovePublic(StoreEntry * e, http_status status)
 
     switch (status) {
 
-    case HTTP_OK:
+    case Http::scOkay:
 
-    case HTTP_NON_AUTHORITATIVE_INFORMATION:
+    case Http::scNonAuthoritativeInformation:
 
-    case HTTP_MULTIPLE_CHOICES:
+    case Http::scMultipleChoices:
 
-    case HTTP_MOVED_PERMANENTLY:
+    case Http::scMovedPermanently:
 
-    case HTTP_MOVED_TEMPORARILY:
+    case Http::scMovedTemporarily:
 
-    case HTTP_GONE:
+    case Http::scGone:
 
-    case HTTP_NOT_FOUND:
+    case Http::scNotFound:
         remove = 1;
 
         break;
 
-    case HTTP_FORBIDDEN:
+    case Http::scForbidden:
 
-    case HTTP_METHOD_NOT_ALLOWED:
+    case Http::scMethodNotAllowed:
         forbidden = 1;
 
         break;
 
 #if WORK_IN_PROGRESS
 
-    case HTTP_UNAUTHORIZED:
+    case Http::scUnauthorized:
         forbidden = 1;
 
         break;
@@ -419,7 +419,7 @@ HttpStateData::cacheableReply()
 
             // HTTPbis pt6 section 3.2: a response CC:s-maxage is present
         } else if (rep->cache_control->sMaxAge()) {
-            debugs(22, 3, HERE << " Authenticated but server reply Cache-Control:s-maxage");
+            debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:s-maxage");
             mayStore = true;
         }
 
@@ -442,19 +442,19 @@ HttpStateData::cacheableReply()
             return 0;
         }
 
-    switch (rep->sline.status) {
+    switch (rep->sline.status()) {
         /* Responses that are cacheable */
 
-    case HTTP_OK:
+    case Http::scOkay:
 
-    case HTTP_NON_AUTHORITATIVE_INFORMATION:
+    case Http::scNonAuthoritativeInformation:
 
-    case HTTP_MULTIPLE_CHOICES:
+    case Http::scMultipleChoices:
 
-    case HTTP_MOVED_PERMANENTLY:
-    case HTTP_PERMANENT_REDIRECT:
+    case Http::scMovedPermanently:
+    case Http::scPermanentRedirect:
 
-    case HTTP_GONE:
+    case Http::scGone:
         /*
          * Don't cache objects that need to be refreshed on next request,
          * unless we know how to refresh it.
@@ -464,98 +464,98 @@ HttpStateData::cacheableReply()
             debugs(22, 3, "NO because refreshIsCachable() returned non-cacheable..");
             return 0;
         } else {
-            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status);
+            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status());
             return 1;
         }
         /* NOTREACHED */
         break;
 
         /* Responses that only are cacheable if the server says so */
 
-    case HTTP_MOVED_TEMPORARILY:
-    case HTTP_TEMPORARY_REDIRECT:
+    case Http::scMovedTemporarily:
+    case Http::scTemporaryRedirect:
         if (rep->date <= 0) {
-            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status << " and Date missing/invalid");
+            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status() << " and Date missing/invalid");
             return 0;
         }
         if (rep->expires > rep->date) {
-            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status << " and Expires > Date");
+            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status() << " and Expires > Date");
             return 1;
         } else {
-            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status << " and Expires <= Date");
+            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status() << " and Expires <= Date");
             return 0;
         }
         /* NOTREACHED */
         break;
 
         /* Errors can be negatively cached */
 
-    case HTTP_NO_CONTENT:
+    case Http::scNoContent:
 
-    case HTTP_USE_PROXY:
+    case Http::scUseProxy:
 
-    case HTTP_BAD_REQUEST:
+    case Http::scBadRequest:
 
-    case HTTP_FORBIDDEN:
+    case Http::scForbidden:
 
-    case HTTP_NOT_FOUND:
+    case Http::scNotFound:
 
-    case HTTP_METHOD_NOT_ALLOWED:
+    case Http::scMethodNotAllowed:
 
-    case HTTP_REQUEST_URI_TOO_LARGE:
+    case Http::scRequestUriTooLarge:
 
-    case HTTP_INTERNAL_SERVER_ERROR:
+    case Http::scInternalServerError:
 
-    case HTTP_NOT_IMPLEMENTED:
+    case Http::scNotImplemented:
 
-    case HTTP_BAD_GATEWAY:
+    case Http::scBadGateway:
 
-    case HTTP_SERVICE_UNAVAILABLE:
+    case Http::scServiceUnavailable:
 
-    case HTTP_GATEWAY_TIMEOUT:
-        debugs(22, 3, HERE << "MAYBE because HTTP status " << rep->sline.status);
+    case Http::scGateway_Timeout:
+        debugs(22, 3, HERE << "MAYBE because HTTP status " << rep->sline.status());
         return -1;
 
         /* NOTREACHED */
         break;
 
         /* Some responses can never be cached */
 
-    case HTTP_PARTIAL_CONTENT:	/* Not yet supported */
+    case Http::scPartialContent:	/* Not yet supported */
 
-    case HTTP_SEE_OTHER:
+    case Http::scSeeOther:
 
-    case HTTP_NOT_MODIFIED:
+    case Http::scNotModified:
 
-    case HTTP_UNAUTHORIZED:
+    case Http::scUnauthorized:
 
-    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
+    case Http::scProxyAuthenticationRequired:
 
-    case HTTP_INVALID_HEADER:	/* Squid header parsing error */
+    case Http::scInvalidHeader:	/* Squid header parsing error */
 
-    case HTTP_HEADER_TOO_LARGE:
+    case Http::scHeaderTooLarge:
 
-    case HTTP_PAYMENT_REQUIRED:
-    case HTTP_NOT_ACCEPTABLE:
-    case HTTP_REQUEST_TIMEOUT:
-    case HTTP_CONFLICT:
-    case HTTP_LENGTH_REQUIRED:
-    case HTTP_PRECONDITION_FAILED:
-    case HTTP_REQUEST_ENTITY_TOO_LARGE:
-    case HTTP_UNSUPPORTED_MEDIA_TYPE:
-    case HTTP_UNPROCESSABLE_ENTITY:
-    case HTTP_LOCKED:
-    case HTTP_FAILED_DEPENDENCY:
-    case HTTP_INSUFFICIENT_STORAGE:
-    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:
-    case HTTP_EXPECTATION_FAILED:
+    case Http::scPaymentRequired:
+    case Http::scNotAcceptable:
+    case Http::scRequestTimeout:
+    case Http::scConflict:
+    case Http::scLengthRequired:
+    case Http::scPreconditionFailed:
+    case Http::scRequestEntityTooLarge:
+    case Http::scUnsupportedMediaType:
+    case Http::scUnprocessableEntity:
+    case Http::scLocked:
+    case Http::scFailedDependency:
+    case Http::scInsufficientStorage:
+    case Http::scRequestedRangeNotSatisfied:
+    case Http::scExpectationFailed:
 
-        debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status);
+        debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status());
         return 0;
 
     default:
         /* RFC 2616 section 6.1.1: an unrecognized response MUST NOT be cached. */
-        debugs (11, 3, HERE << "NO because unknown HTTP status code " << rep->sline.status);
+        debugs (11, 3, HERE << "NO because unknown HTTP status code " << rep->sline.status());
         return 0;
 
         /* NOTREACHED */
@@ -696,15 +696,15 @@ HttpStateData::processReplyHeader()
         return;
     }
 
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
 
     HttpReply *newrep = new HttpReply;
     const bool parsed = newrep->parse(readBuf, eof, &error);
 
     if (!parsed && readBuf->contentSize() > 5 && strncmp(readBuf->content(), "HTTP/", 5) != 0 && strncmp(readBuf->content(), "ICY", 3) != 0) {
         MemBuf *mb;
         HttpReply *tmprep = new HttpReply;
-        tmprep->setHeaders(HTTP_OK, "Gatewaying", NULL, -1, -1, -1);
+        tmprep->setHeaders(Http::scOkay, "Gatewaying", NULL, -1, -1, -1);
         tmprep->header.putExt("X-Transformed-From", "HTTP/0.9");
         mb = tmprep->pack();
         newrep->parse(mb, eof, &error);
@@ -714,8 +714,9 @@ HttpStateData::processReplyHeader()
         if (!parsed && error > 0) { // unrecoverable parsing error
             debugs(11, 3, "processReplyHeader: Non-HTTP-compliant header: '" <<  readBuf->content() << "'");
             flags.headers_parsed = true;
-            newrep->sline.version = HttpVersion(1,1);
-            newrep->sline.status = error;
+            // XXX: when sanityCheck is gone and Http::StatusLine is used to parse,
+            //   the sline should be already set the appropriate values during that parser stage
+            newrep->sline.set(Http::ProtocolVersion(1,1), error);
             HttpReply *vrep = setVirginReply(newrep);
             entry->replaceHttpReply(vrep);
             ctx_exit(ctx);
@@ -739,7 +740,7 @@ HttpStateData::processReplyHeader()
 
     newrep->removeStaleWarnings();
 
-    if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->sline.status >= 100 && newrep->sline.status < 200) {
+    if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->sline.status() >= 100 && newrep->sline.status() < 200) {
         handle1xx(newrep);
         ctx_exit(ctx);
         return;
@@ -752,7 +753,7 @@ HttpStateData::processReplyHeader()
     }
 
     if (!peerSupportsConnectionPinning())
-        request->flags.connectionAuthDisabled = 1;
+        request->flags.connectionAuthDisabled = true;
 
     HttpReply *vrep = setVirginReply(newrep);
     flags.headers_parsed = true;
@@ -763,7 +764,7 @@ HttpStateData::processReplyHeader()
 
     processSurrogateControl (vrep);
 
-    request->hier.peer_reply_status = newrep->sline.status;
+    request->hier.peer_reply_status = newrep->sline.status();
 
     ctx_exit(ctx);
 }
@@ -772,7 +773,7 @@ HttpStateData::processReplyHeader()
 void
 HttpStateData::handle1xx(HttpReply *reply)
 {
-    HttpMsgPointerT<HttpReply> msg(reply); // will destroy reply if unused
+    HttpReply::Pointer msg(reply); // will destroy reply if unused
 
     // one 1xx at a time: we must not be called while waiting for previous 1xx
     Must(!flags.handling1xx);
@@ -788,7 +789,8 @@ HttpStateData::handle1xx(HttpReply *reply)
     // check whether the 1xx response forwarding is allowed by squid.conf
     if (Config.accessList.reply) {
         ACLFilledChecklist ch(Config.accessList.reply, originalRequest(), NULL);
-        ch.reply = HTTPMSGLOCK(reply);
+        ch.reply = reply;
+        HTTPMSGLOCK(ch.reply);
         if (ch.fastCheck() != ACCESS_ALLOWED) { // TODO: support slow lookups?
             debugs(11, 3, HERE << "ignoring denied 1xx");
             proceedAfter1xx();
@@ -847,10 +849,10 @@ bool HttpStateData::peerSupportsConnectionPinning() const
     /*The peer supports connection pinning and the http reply status
       is not unauthorized, so the related connection can be pinned
      */
-    if (rep->sline.status != HTTP_UNAUTHORIZED)
+    if (rep->sline.status() != Http::scUnauthorized)
         return true;
 
-    /*The server respond with HTTP_UNAUTHORIZED and the peer configured
+    /*The server respond with Http::scUnauthorized and the peer configured
       with "connection-auth=on" we know that the peer supports pinned
       connections
     */
@@ -896,17 +898,16 @@ HttpStateData::haveParsedReplyHeaders()
     Ctx ctx = ctx_enter(entry->mem_obj->url);
     HttpReply *rep = finalReply();
 
-    if (rep->sline.status == HTTP_PARTIAL_CONTENT &&
-            rep->content_range)
+    if (rep->sline.status() == Http::scPartialContent && rep->content_range)
         currentOffset = rep->content_range->spec.offset;
 
     entry->timestampsSet();
 
     /* Check if object is cacheable or not based on reply code */
-    debugs(11, 3, "haveParsedReplyHeaders: HTTP CODE: " << rep->sline.status);
+    debugs(11, 3, "HTTP CODE: " << rep->sline.status());
 
     if (neighbors_do_private_keys)
-        httpMaybeRemovePublic(entry, rep->sline.status);
+        httpMaybeRemovePublic(entry, rep->sline.status());
 
     if (rep->header.has(HDR_VARY)
 #if X_ACCELERATOR_VARY
@@ -917,7 +918,7 @@ HttpStateData::haveParsedReplyHeaders()
 
         if (!vary) {
             entry->makePrivate();
-            if (!fwd->reforwardableStatus(rep->sline.status))
+            if (!fwd->reforwardableStatus(rep->sline.status()))
                 EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
             goto no_cache;
         }
@@ -929,7 +930,7 @@ HttpStateData::haveParsedReplyHeaders()
      * If its not a reply that we will re-forward, then
      * allow the client to get it.
      */
-    if (!fwd->reforwardableStatus(rep->sline.status))
+    if (!fwd->reforwardableStatus(rep->sline.status()))
         EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
 
     switch (cacheableReply()) {
@@ -1134,7 +1135,7 @@ HttpStateData::readReply(const CommIoCbParams &io)
         if (ignoreErrno(io.xerrno)) {
             flags.do_next_read = true;
         } else {
-            ErrorState *err = new ErrorState(ERR_READ_ERROR, HTTP_BAD_GATEWAY, fwd->request);
+            ErrorState *err = new ErrorState(ERR_READ_ERROR, Http::scBadGateway, fwd->request);
             err->xerrno = io.xerrno;
             fwd->fail(err);
             flags.do_next_read = false;
@@ -1259,12 +1260,12 @@ HttpStateData::continueAfterParsingHeader()
     if (flags.headers_parsed) { // parsed headers, possibly with errors
         // check for header parsing errors
         if (HttpReply *vrep = virginReply()) {
-            const http_status s = vrep->sline.status;
-            const HttpVersion &v = vrep->sline.version;
-            if (s == HTTP_INVALID_HEADER && v != HttpVersion(0,9)) {
+            const Http::StatusCode s = vrep->sline.status();
+            const Http::ProtocolVersion &v = vrep->sline.version;
+            if (s == Http::scInvalidHeader && v != Http::ProtocolVersion(0,9)) {
                 debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Bad header encountered from " << entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
                 error = ERR_INVALID_RESP;
-            } else if (s == HTTP_HEADER_TOO_LARGE) {
+            } else if (s == Http::scHeaderTooLarge) {
                 fwd->dontRetry(true);
                 error = ERR_TOO_BIG;
             } else {
@@ -1289,7 +1290,7 @@ HttpStateData::continueAfterParsingHeader()
 
     assert(error != ERR_NONE);
     entry->reset();
-    fwd->fail(new ErrorState(error, HTTP_BAD_GATEWAY, fwd->request));
+    fwd->fail(new ErrorState(error, Http::scBadGateway, fwd->request));
     flags.do_next_read = false;
     serverConnection->close();
     return false; // quit on error
@@ -1442,9 +1443,9 @@ HttpStateData::processReplyBody()
 
             if (ispinned && request->clientConnectionManager.valid()) {
                 request->clientConnectionManager->pinConnection(serverConnection, request, _peer,
-                        (request->flags.connectionAuth != 0));
+                        (request->flags.connectionAuth));
             } else {
-                fwd->pconnPush(serverConnection, request->peer_host ? request->peer_host : request->GetHost());
+                fwd->pconnPush(serverConnection, request->GetHost());
             }
 
             serverConnection = NULL;
@@ -1513,7 +1514,7 @@ HttpStateData::wroteLast(const CommIoCbParams &io)
         return;
 
     if (io.flag) {
-        ErrorState *err = new ErrorState(ERR_WRITE_ERROR, HTTP_BAD_GATEWAY, fwd->request);
+        ErrorState *err = new ErrorState(ERR_WRITE_ERROR, Http::scBadGateway, fwd->request);
         err->xerrno = io.xerrno;
         fwd->fail(err);
         serverConnection->close();
@@ -1691,11 +1692,11 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
      */
     if (!we_do_ranges && request->multipartRangeRequest()) {
         /* don't cache the result */
-        request->flags.cachable = 0;
+        request->flags.cachable = false;
         /* pretend it's not a range request */
         delete request->range;
         request->range = NULL;
-        request->flags.isRanged=false;
+        request->flags.isRanged = false;
     }
 
     /* append Via */
@@ -1779,7 +1780,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Authorization if known in URL, not in header and going direct */
     if (!hdr_out->has(HDR_AUTHORIZATION)) {
-        if (!request->flags.proxying && request->login && *request->login) {
+        if (!request->flags.proxying && request->login[0] != '\0') {
             httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
                               old_base64_encode(request->login));
         }
@@ -2047,7 +2048,13 @@ mb_size_t
 HttpStateData::buildRequestPrefix(MemBuf * mb)
 {
     const int offset = mb->size;
-    HttpVersion httpver(1,1);
+    /* Uses a local httpver variable to print the HTTP/1.1 label
+     * since the HttpRequest may have an older version label.
+     * XXX: This could create protocol bugs as the headers sent and
+     * flow control should all be based on the HttpRequest version
+     * not the one we are sending. Needs checking.
+     */
+    Http::ProtocolVersion httpver(1,1);
     const char * url;
     if (_peer && !_peer->options.originserver)
         url = entry->url();
@@ -2065,9 +2072,9 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
         httpBuildRequestHeader(request, entry, fwd->al, &hdr, flags);
 
         if (request->flags.pinned && request->flags.connectionAuth)
-            request->flags.authSent = 1;
+            request->flags.authSent = true;
         else if (hdr.has(HDR_AUTHORIZATION))
-            request->flags.authSent = 1;
+            request->flags.authSent = true;
 
         packerToMemInit(&p, mb);
         hdr.packInto(&p);
@@ -2118,24 +2125,16 @@ HttpStateData::sendRequest()
                                     Dialer, this,  HttpStateData::wroteLast);
     }
 
-    if (_peer != NULL) {
-        if (_peer->options.originserver) {
-            flags.proxying = false;
-            flags.originpeer = true;
-        } else {
-            flags.proxying = false;
-            flags.originpeer = false;
-        }
-    } else {
-        flags.proxying = false;
-        flags.originpeer = false;
-    }
+    flags.originpeer = (_peer != NULL && _peer->options.originserver);
+    flags.proxying = (_peer != NULL && !flags.originpeer);
 
     /*
      * Is keep-alive okay for all request methods?
      */
     if (request->flags.mustKeepalive)
         flags.keepalive = true;
+    else if (request->flags.pinned)
+        flags.keepalive = request->persistent();
     else if (!Config.onoff.server_pconns)
         flags.keepalive = false;
     else if (_peer == NULL)
@@ -2323,7 +2322,7 @@ HttpStateData::handleMoreRequestBodyAvailable()
             flags.abuse_detected = true;
             debugs(11, DBG_IMPORTANT, "http handleMoreRequestBodyAvailable: Likely proxy abuse detected '" << request->client_addr << "' -> '" << entry->url() << "'" );
 
-            if (virginReply()->sline.status == HTTP_INVALID_HEADER) {
+            if (virginReply()->sline.status() == Http::scInvalidHeader) {
                 serverConnection->close();
                 return;
             }
@@ -2344,7 +2343,7 @@ HttpStateData::handleRequestBodyProducerAborted()
         // We might also get here if client-side aborts, but then our response
         // should not matter because either client-side will provide its own or
         // there will be no response at all (e.g., if the the client has left).
-        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR, fwd->request);
+        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, Http::scInternalServerError, fwd->request);
         err->detailError(ERR_DETAIL_SRV_REQMOD_REQ_BODY);
         fwd->fail(err);
     }
@@ -5,10 +5,15 @@ noinst_LTLIBRARIES = libsquid-http.la
 
 libsquid_http_la_SOURCES = \
 	MethodType.cc \
-	MethodType.h
+	MethodType.h \
+	ProtocolVersion.h \
+	StatusCode.cc \
+	StatusCode.h \
+	StatusLine.cc \
+	StatusLine.h
 
 MethodType.cc: MethodType.h $(top_srcdir)/src/mk-string-arrays.awk
-	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk < $(srcdir)/MethodType.h | sed -e 's%METHOD_%%' | \
-		sed -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
+	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk < $(srcdir)/MethodType.h | \
+		sed -e 's%METHOD_%%' -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
 
 CLEANFILES += MethodType.cc
@@ -0,0 +1,23 @@
+#ifndef SQUID_HTTP_PROTOCOLVERSION_H
+#define SQUID_HTTP_PROTOCOLVERSION_H
+
+#include "anyp/ProtocolVersion.h"
+
+namespace Http
+{
+
+/**
+ * Stores HTTP version label information.
+ * For example HTTP/1.0
+ */
+class ProtocolVersion : public AnyP::ProtocolVersion
+{
+public:
+    ProtocolVersion() : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,0) {}
+
+    ProtocolVersion(unsigned int aMajor, unsigned int aMinor) : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,aMajor,aMinor) {}
+};
+
+}; // namespace Http
+
+#endif /* SQUID_HTTP_PROTOCOLVERSION_H */
@@ -0,0 +1,203 @@
+#include "squid.h"
+#include "Debug.h"
+#include "http/StatusCode.h"
+
+const char *
+Http::StatusCodeString(const Http::StatusCode status)
+{
+    switch (status) {
+
+    case Http::scNone:
+        return "Init";		/* we init .status with code 0 */
+        break;
+
+    case Http::scContinue:
+        return "Continue";
+        break;
+
+    case Http::scSwitchingProtocols:
+        return "Switching Protocols";
+        break;
+
+    case Http::scOkay:
+        return "OK";
+        break;
+
+    case Http::scCreated:
+        return "Created";
+        break;
+
+    case Http::scAccepted:
+        return "Accepted";
+        break;
+
+    case Http::scNonAuthoritativeInformation:
+        return "Non-Authoritative Information";
+        break;
+
+    case Http::scNoContent:
+        return "No Content";
+        break;
+
+    case Http::scResetContent:
+        return "Reset Content";
+        break;
+
+    case Http::scPartialContent:
+        return "Partial Content";
+        break;
+
+    case Http::scMultiStatus:
+        return "Multi-Status";
+        break;
+
+    case Http::scMultipleChoices:
+        return "Multiple Choices";
+        break;
+
+    case Http::scMovedPermanently:
+        return "Moved Permanently";
+        break;
+
+    case Http::scMovedTemporarily:
+        return "Moved Temporarily";
+        break;
+
+    case Http::scSeeOther:
+        return "See Other";
+        break;
+
+    case Http::scNotModified:
+        return "Not Modified";
+        break;
+
+    case Http::scUseProxy:
+        return "Use Proxy";
+        break;
+
+    case Http::scTemporaryRedirect:
+        return "Temporary Redirect";
+        break;
+
+    case Http::scPermanentRedirect:
+        return "Permanent Redirect";
+        break;
+
+    case Http::scBadRequest:
+        return "Bad Request";
+        break;
+
+    case Http::scUnauthorized:
+        return "Unauthorized";
+        break;
+
+    case Http::scPaymentRequired:
+        return "Payment Required";
+        break;
+
+    case Http::scForbidden:
+        return "Forbidden";
+        break;
+
+    case Http::scNotFound:
+        return "Not Found";
+        break;
+
+    case Http::scMethodNotAllowed:
+        return "Method Not Allowed";
+        break;
+
+    case Http::scNotAcceptable:
+        return "Not Acceptable";
+        break;
+
+    case Http::scProxyAuthenticationRequired:
+        return "Proxy Authentication Required";
+        break;
+
+    case Http::scRequestTimeout:
+        return "Request Time-out";
+        break;
+
+    case Http::scConflict:
+        return "Conflict";
+        break;
+
+    case Http::scGone:
+        return "Gone";
+        break;
+
+    case Http::scLengthRequired:
+        return "Length Required";
+        break;
+
+    case Http::scPreconditionFailed:
+        return "Precondition Failed";
+        break;
+
+    case Http::scRequestEntityTooLarge:
+        return "Request Entity Too Large";
+        break;
+
+    case Http::scRequestUriTooLarge:
+        return "Request-URI Too Large";
+        break;
+
+    case Http::scUnsupportedMediaType:
+        return "Unsupported Media Type";
+        break;
+
+    case Http::scRequestedRangeNotSatisfied:
+        return "Requested Range Not Satisfiable";
+        break;
+
+    case Http::scExpectationFailed:
+        return "Expectation Failed";
+        break;
+
+    case Http::scInternalServerError:
+        return "Internal Server Error";
+        break;
+
+    case Http::scNotImplemented:
+        return "Not Implemented";
+        break;
+
+    case Http::scBadGateway:
+        return "Bad Gateway";
+        break;
+
+    case Http::scServiceUnavailable:
+        return "Service Unavailable";
+        break;
+
+    case Http::scGateway_Timeout:
+        return "Gateway Time-out";
+        break;
+
+    case Http::scHttpVersionNotSupported:
+        return "HTTP Version not supported";
+        break;
+
+        // RFC 6585
+    case Http::scPreconditionRequired: // 428
+        return "Precondition Required";
+        break;
+
+    case Http::scTooManyFields: // 429
+        return "Too Many Requests";
+        break;
+
+    case Http::scRequestHeaderFieldsTooLarge: // 431
+        return "Request Header Fields Too Large";
+        break;
+
+    case Http::scNetworkAuthenticationRequired: // 511
+        return "Network Authentication Required";
+        break;
+
+    default:
+        debugs(57, 3, "Unknown HTTP status code: " << status);
+        return "Unknown";
+    }
+}
@@ -0,0 +1,75 @@
+#ifndef _SQUID_SRC_HTTP_STATUSCODE_H
+#define _SQUID_SRC_HTTP_STATUSCODE_H
+
+namespace Http
+{
+
+/**
+ * These basic HTTP reply status codes are defined by RFC 2616 unless otherwise stated.
+ */
+typedef enum {
+    scNone = 0,
+    scContinue = 100,
+    scSwitchingProtocols = 101,
+    scProcessing = 102,      /**< RFC2518 section 10.1 */
+    scOkay = 200,
+    scCreated = 201,
+    scAccepted = 202,
+    scNonAuthoritativeInformation = 203,
+    scNoContent = 204,
+    scResetContent = 205,
+    scPartialContent = 206,
+    scMultiStatus = 207,    /**< RFC2518 section 10.2 */
+    scMultipleChoices = 300,
+    scMovedPermanently = 301,
+    scMovedTemporarily = 302,
+    scSeeOther = 303,
+    scNotModified = 304,
+    scUseProxy = 305,
+    scTemporaryRedirect = 307,
+    scPermanentRedirect = 308,
+    scBadRequest = 400,
+    scUnauthorized = 401,
+    scPaymentRequired = 402,
+    scForbidden = 403,
+    scNotFound = 404,
+    scMethodNotAllowed = 405,
+    scNotAcceptable = 406,
+    scProxyAuthenticationRequired = 407,
+    scRequestTimeout = 408,
+    scConflict = 409,
+    scGone = 410,
+    scLengthRequired = 411,
+    scPreconditionFailed = 412,
+    scRequestEntityTooLarge = 413,
+    scRequestUriTooLarge = 414,
+    scUnsupportedMediaType = 415,
+    scRequestedRangeNotSatisfied = 416,
+    scExpectationFailed = 417,
+    scUnprocessableEntity = 422,    /**< RFC2518 section 10.3 */
+    scLocked = 423,                  /**< RFC2518 section 10.4 */
+    scFailedDependency = 424,       /**< RFC2518 section 10.5 */
+    scPreconditionRequired = 428,   /**< RFC6585 */
+    scTooManyFields = 429,       /**< RFC6585 */
+    scRequestHeaderFieldsTooLarge = 431, /**< RFC6585 */
+    scInternalServerError = 500,
+    scNotImplemented = 501,
+    scBadGateway = 502,
+    scServiceUnavailable = 503,
+    scGateway_Timeout = 504,
+    scHttpVersionNotSupported = 505,
+    scInsufficientStorage = 507,    /**< RFC2518 section 10.6 */
+    scNetworkAuthenticationRequired = 511, /**< RFC6585 */
+
+    // The 6xx codes below are for internal use only: Bad requests result
+    // in scBadRequest; bad responses in scGateway_Timeout.
+
+    scInvalidHeader = 600,          /**< Squid header parsing error */
+    scHeaderTooLarge = 601         /* Header too large to process */
+} StatusCode;
+
+const char *StatusCodeString(const Http::StatusCode status);
+
+} // namespace Http
+
+#endif /* _SQUID_SRC_HTTP_STATUSCODE_H */
@@ -0,0 +1,136 @@
+/*
+ * DEBUG: section 57    HTTP Status-line
+ * AUTHOR: Alex Rousskov
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "Debug.h"
+#include "http/StatusLine.h"
+#include "Packer.h"
+
+void
+Http::StatusLine::init()
+{
+    set(Http::ProtocolVersion(), Http::scNone, NULL);
+}
+
+void
+Http::StatusLine::clean()
+{
+    set(Http::ProtocolVersion(), Http::scInternalServerError, NULL);
+}
+
+/* set values */
+void
+Http::StatusLine::set(const Http::ProtocolVersion &newVersion, const Http::StatusCode newStatus, const char *newReason)
+{
+    protocol = AnyP::PROTO_HTTP;
+    version = newVersion;
+    status_ = newStatus;
+    /* Note: no xstrdup for 'reason', assumes constant 'reasons' */
+    reason_ = newReason;
+}
+
+const char *
+Http::StatusLine::reason() const
+{
+    return reason_ ? reason_ : Http::StatusCodeString(status());
+}
+
+void
+Http::StatusLine::packInto(Packer * p) const
+{
+    assert(p);
+
+    /* local constants */
+    /* AYJ: see bug 2469 - RFC2616 confirms stating 'SP characters' plural! */
+    static const char *Http1StatusLineFormat = "HTTP/%d.%d %3d %s\r\n";
+    static const char *IcyStatusLineFormat = "ICY %3d %s\r\n";
+
+    /* handle ICY protocol status line specially. Pass on the bad format. */
+    if (protocol == AnyP::PROTO_ICY) {
+        debugs(57, 9, "packing sline " << this << " using " << p << ":");
+        debugs(57, 9, "FORMAT=" << IcyStatusLineFormat );
+        debugs(57, 9, "ICY " << status() << " " << reason());
+        packerPrintf(p, IcyStatusLineFormat, status(), reason());
+        return;
+    }
+
+    debugs(57, 9, "packing sline " << this << " using " << p << ":");
+    debugs(57, 9, "FORMAT=" << Http1StatusLineFormat );
+    debugs(57, 9, "HTTP/" << version.major << "." << version.minor << " " << status() << " " << reason());
+    packerPrintf(p, Http1StatusLineFormat, version.major, version.minor, status(), reason());
+}
+
+/*
+ * Parse character string.
+ * XXX: Note 'end' currently unused, so NULL-termination assumed.
+ */
+bool
+Http::StatusLine::parse(const String &protoPrefix, const char *start, const char *end)
+{
+    status_ = Http::scInvalidHeader;	/* Squid header parsing error */
+
+    // XXX: HttpMsg::parse() has a similar check but is using
+    // casesensitive comparison (which is required by HTTP errata?)
+
+    if (protoPrefix.cmp("ICY", 3) == 0) {
+        debugs(57, 3, "Invalid HTTP identifier. Detected ICY protocol istead.");
+        protocol = AnyP::PROTO_ICY;
+        start += protoPrefix.size();
+    } else if (protoPrefix.caseCmp(start, protoPrefix.size()) == 0) {
+
+        start += protoPrefix.size();
+
+        if (!xisdigit(*start))
+            return false;
+
+        // XXX: HTTPbis have defined this to be single-digit version numbers. no need to sscanf()
+        // XXX: furthermore, only HTTP/1 will be using ASCII format digits
+
+        if (sscanf(start, "%d.%d", &version.major, &version.minor) != 2) {
+            debugs(57, 7, "Invalid HTTP identifier.");
+            return false;
+        }
+    } else
+        return false;
+
+    if (!(start = strchr(start, ' ')))
+        return false;
+
+    // XXX: should we be using xstrtoui() or xatoui() ?
+    status_ = static_cast<Http::StatusCode>(atoi(++start));
+
+    // XXX check if the given 'reason' is the default status string, if not save to reason_
+
+    /* we ignore 'reason-phrase' */
+    /* Should assert start < end ? */
+    return true;			/* success */
+}
@@ -28,24 +28,52 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-#ifndef SQUID_HTTPSTATUSLINE_H
-#define SQUID_HTTPSTATUSLINE_H
+#ifndef SQUID_HTTP_STATUSLINE_H
+#define SQUID_HTTP_STATUSLINE_H
+
+#include "http/ProtocolVersion.h"
+#include "http/StatusCode.h"
+#include "SquidString.h"
 
 class Packer;
 class String;
 
-#include "HttpStatusCode.h"
-#include "HttpVersion.h"
-#include "anyp/ProtocolType.h"
-#include "SquidString.h"
+namespace Http
+{
 
 /**
  * Holds the values parsed from an HTTP reply status line.
  *
- * For example: HTTP/1.1 200 Okay
+ * For example: HTTP/1.1 200 OK
  */
-class HttpStatusLine
+class StatusLine
 {
+public:
+    /// reset this status-line back to empty state
+    void init();
+
+    /// reset this status-line back to Internal Server Error state
+    void clean();
+
+    /// set this status-line to the given values
+    /// when reason is NULL the default message text for this StatusCode will be used
+    void set(const Http::ProtocolVersion &newVersion, Http::StatusCode newStatus, const char *newReason = NULL);
+
+    /// retrieve the status code for this status line
+    const Http::StatusCode status() const { return status_; }
+
+    /// retrieve the reason string for this status line
+    const char *reason() const;
+
+    /// pack fields using Packer
+    void packInto(Packer * p) const;
+
+    /**
+     * Parse a buffer and fill internal structures;
+     * \return true on success, false otherwise
+     */
+    bool parse(const String &protoPrefix, const char *start, const char *end);
+
 public:
     /* public, read only */
 
@@ -54,27 +82,19 @@ class HttpStatusLine
      * However there are protocols which violate HTTP by sending their own custom formats
      * back with other protocol names (ICY streaming format being the current major problem).
      */
+    // XXX: protocol is part of Http::ProtocolVersion. We should be able to use version.protocol instead now.
     AnyP::ProtocolType protocol;
 
-    HttpVersion version;     ///< breakdown of protocol version labels: 0.9 1.0 1.1
-    http_status status;      ///< status code. ie 200 404
-    const char *reason;	     ///< points to a _constant_ string (default or supplied), never free()d */
+    Http::ProtocolVersion version;     ///< breakdown of protocol version label: (HTTP/ICY) and (0.9/1.0/1.1)
+
+private:
+    /// status code. ie 100 ... 200 ... 404 ... 599
+    Http::StatusCode status_;
+
+    /// points to a _constant_ string (default or supplied), never free()d
+    const char *reason_;
 };
 
-/* init/clean */
-void httpStatusLineInit(HttpStatusLine * sline);
-void httpStatusLineClean(HttpStatusLine * sline);
-/* set/get values */
-void httpStatusLineSet(HttpStatusLine * sline, HttpVersion version,
-                       http_status status, const char *reason);
-const char *httpStatusLineReason(const HttpStatusLine * sline);
-/* parse/pack */
-/* parse a 0-terminating buffer and fill internal structires; returns true on success */
-int httpStatusLineParse(HttpStatusLine * sline, const String &protoPrefix,
-                        const char *start, const char *end);
-/* pack fields using Packer */
-void httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p);
-
-const char *httpStatusString(http_status status);
-
-#endif /* SQUID_HTTPSTATUSLINE_H */
+} // namespace Http
+
+#endif /* SQUID_HTTP_STATUSLINE_H */
@@ -155,6 +155,7 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     }
 
     Log(to, ' ', NULL, 0, 0);
+    to.FreeAddrInfo(S);
 }
 
 void
@@ -220,11 +221,15 @@ Icmp4::Recv(void)
 
     icmp = (struct icmphdr *) (void *) (pkt + iphdrlen);
 
-    if (icmp->icmp_type != ICMP_ECHOREPLY)
+    if (icmp->icmp_type != ICMP_ECHOREPLY) {
+        preply.from.FreeAddrInfo(from);
         return;
+    }
 
-    if (icmp->icmp_id != icmp_ident)
+    if (icmp->icmp_id != icmp_ident) {
+        preply.from.FreeAddrInfo(from);
         return;
+    }
 
     echo = (icmpEchoData *) (void *) (icmp + 1);
 
@@ -241,6 +246,7 @@ Icmp4::Recv(void)
     control.SendResult(preply, (sizeof(pingerReplyData) - MAX_PKT4_SZ + preply.psize) );
 
     Log(preply.from, icmp->icmp_type, icmpPktStr[icmp->icmp_type], preply.rtt, preply.hops);
+    preply.from.FreeAddrInfo(from);
 }
 
 #endif /* USE_ICMP */
@@ -200,6 +200,7 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     debugs(42,9, HERE << "x=" << x);
 
     Log(to, 0, NULL, 0, 0);
+    to.FreeAddrInfo(S);
 }
 
 /**
@@ -293,11 +294,13 @@ Icmp6::Recv(void)
                    ( icmp6header->icmp6_type&0x80 ? icmp6HighPktStr[(int)(icmp6header->icmp6_type&0x7f)] : icmp6LowPktStr[(int)(icmp6header->icmp6_type&0x7f)] )
                   );
         }
+        preply.from.FreeAddrInfo(from);
         return;
     }
 
     if (icmp6header->icmp6_id != icmp_ident) {
         debugs(42, 8, HERE << "dropping Icmp6 read. IDENT check failed. ident=='" << icmp_ident << "'=='" << icmp6header->icmp6_id << "'");
+        preply.from.FreeAddrInfo(from);
         return;
     }
 
@@ -334,6 +337,7 @@ Icmp6::Recv(void)
 
     /* send results of the lookup back to squid.*/
     control.SendResult(preply, (sizeof(pingerReplyData) - PINGER_PAYLOAD_SZ + preply.psize) );
+    preply.from.FreeAddrInfo(from);
 }
 
 #endif /* USE_ICMP */
@@ -51,9 +51,6 @@ IcmpSquid icmpEngine;
 #if USE_ICMP
 
 #define S_ICMP_ECHO     1
-#if DEAD_CODE
-#define S_ICMP_ICP      2
-#endif
 #define S_ICMP_DOM      3
 
 static void * hIpc;
@@ -742,10 +742,10 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
         if ((hdr_sz = headersEnd(p, ex->buf_ofs))) {
             debugs(38, 5, "netdbExchangeHandleReply: hdr_sz = " << hdr_sz);
             rep = ex->e->getReply();
-            assert (0 != rep->sline.status);
-            debugs(38, 3, "netdbExchangeHandleReply: reply status " << rep->sline.status);
+            assert(rep->sline.status() != Http::scNone);
+            debugs(38, 3, "netdbExchangeHandleReply: reply status " << rep->sline.status());
 
-            if (HTTP_OK != rep->sline.status) {
+            if (rep->sline.status() != Http::scOkay) {
                 netdbExchangeDone(ex);
                 return;
             }
@@ -989,23 +989,6 @@ netdbFreeMemory(void)
 #endif
 }
 
-#if 0 // AYJ: Looks to be unused code.
-int
-netdbHops(Ip::Address &addr)
-{
-#if USE_ICMP
-    netdbEntry *n = netdbLookupAddr(addr);
-
-    if (n && n->pings_recv) {
-        n->last_use_time = squid_curtime;
-        return (int) (n->hops + 0.5);
-    }
-
-#endif
-    return 256;
-}
-#endif
-
 void
 netdbDump(StoreEntry * sentry)
 {
@@ -1232,7 +1215,7 @@ netdbBinaryExchange(StoreEntry * s)
 
     struct in_addr line_addr;
     s->buffer();
-    reply->setHeaders(HTTP_OK, "OK", NULL, -1, squid_curtime, -2);
+    reply->setHeaders(Http::scOkay, "OK", NULL, -1, squid_curtime, -2);
     s->replaceHttpReply(reply);
     rec_sz = 0;
     rec_sz += 1 + sizeof(struct in_addr);
@@ -1298,7 +1281,7 @@ netdbBinaryExchange(StoreEntry * s)
     memFree(buf, MEM_4K_BUF);
 #else
 
-    reply->setHeaders(HTTP_BAD_REQUEST, "Bad Request", NULL, -1, squid_curtime, -2);
+    reply->setHeaders(Http::scBadRequest, "Bad Request", NULL, -1, squid_curtime, -2);
     s->replaceHttpReply(reply);
     storeAppendPrintf(s, "NETDB support not compiled into this Squid cache.\n");
 #endif
@@ -1333,7 +1316,7 @@ netdbExchangeStart(void *data)
 
     HTTPMSGLOCK(ex->r);
     assert(NULL != ex->r);
-    ex->r->http_ver = HttpVersion(1,1);
+    ex->r->http_ver = Http::ProtocolVersion(1,1);
     ex->connstate = STATE_HEADER;
     ex->e = storeCreateEntry(uri, uri, RequestFlags(), Http::METHOD_GET);
     ex->buf_sz = NETDB_REQBUF_SZ;
@@ -1344,7 +1327,7 @@ netdbExchangeStart(void *data)
     tempBuffer.data = ex->buf;
     storeClientCopy(ex->sc, ex->e, tempBuffer,
                     netdbExchangeHandleReply, ex);
-    ex->r->flags.loopDetected = 1;	/* cheat! -- force direct */
+    ex->r->flags.loopDetected = true;	/* cheat! -- force direct */
 
     if (p->login)
         xstrncpy(ex->r->login, p->login, MAX_LOGIN_SZ);
@@ -70,6 +70,7 @@
 #include "Icmp4.h"
 #include "Icmp6.h"
 #include "IcmpPinger.h"
+#include "ip/tools.h"
 
 #if _SQUID_WINDOWS_
 
@@ -147,6 +148,9 @@ main(int argc, char *argv[])
 
     getCurrentTime();
 
+    // determine IPv4 or IPv6 capabilities before using sockets.
+    Ip::ProbeTransport();
+
     _db_init(NULL, debug_args);
 
     debugs(42, DBG_CRITICAL, "pinger: Initialising ICMP pinger ...");
@@ -72,7 +72,7 @@
 static void icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo);
 
 /// \ingroup ServerProtocolICPInternal2
-static void icpLogIcp(const Ip::Address &, log_type, int, const char *, int);
+static void icpLogIcp(const Ip::Address &, LogTags, int, const char *, int);
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpHandleIcpV2(int, Ip::Address &, char *, int);
@@ -95,10 +95,13 @@ Comm::ConnectionPointer icpIncomingConn = NULL;
 Comm::ConnectionPointer icpOutgoingConn = NULL;
 
 /* icp_common_t */
-_icp_common_t::_icp_common_t() : opcode(ICP_INVALID), version(0), length(0), reqnum(0), flags(0), pad(0), shostid(0)
+_icp_common_t::_icp_common_t() :
+        opcode(ICP_INVALID), version(0), length(0), reqnum(0),
+        flags(0), pad(0), shostid(0)
 {}
 
-_icp_common_t::_icp_common_t(char *buf, unsigned int len)
+_icp_common_t::_icp_common_t(char *buf, unsigned int len) :
+        opcode(ICP_INVALID), version(0), reqnum(0), flags(0), pad(0), shostid(0)
 {
     if (len < sizeof(_icp_common_t)) {
         /* mark as invalid */
@@ -129,10 +132,12 @@ _icp_common_t::getOpCode() const
 
 ICPState::ICPState(icp_common_t &aHeader, HttpRequest *aRequest):
         header(aHeader),
-        request(HTTPMSGLOCK(aRequest)),
+        request(aRequest),
         fd(-1),
         url(NULL)
-{}
+{
+    HTTPMSGLOCK(request);
+}
 
 ICPState::~ICPState()
 {
@@ -196,7 +201,7 @@ ICP2State::created(StoreEntry *newEntry)
 
 /// \ingroup ServerProtocolICPInternal2
 static void
-icpLogIcp(const Ip::Address &caddr, log_type logcode, int len, const char *url, int delay)
+icpLogIcp(const Ip::Address &caddr, LogTags logcode, int len, const char *url, int delay)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry();
 
@@ -293,7 +298,7 @@ int
 icpUdpSend(int fd,
            const Ip::Address &to,
            icp_common_t * msg,
-           log_type logcode,
+           LogTags logcode,
            int delay)
 {
     icpUdpData *queue;
@@ -377,7 +382,7 @@ icpGetCommonOpcode()
     return ICP_ERR;
 }
 
-log_type
+LogTags
 icpLogFromICPCode(icp_opcode opcode)
 {
     if (opcode == ICP_ERR)
@@ -59,6 +59,7 @@ typedef struct _IdentClient {
 typedef struct _IdentStateData {
     hash_link hash;		/* must be first */
     Comm::ConnectionPointer conn;
+    MemBuf queryMsg;  ///< the lookup message sent to IDENT server
     IdentClient *clients;
     char buf[IDENT_BUFSIZE];
 } IdentStateData;
@@ -147,14 +148,9 @@ Ident::ConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int x
 
     comm_add_close_handler(conn->fd, Ident::Close, state);
 
-    MemBuf mb;
-    mb.init();
-    mb.Printf("%d, %d\r\n",
-              conn->remote.GetPort(),
-              conn->local.GetPort());
     AsyncCall::Pointer writeCall = commCbCall(5,4, "Ident::WriteFeedback",
                                    CommIoCbPtrFun(Ident::WriteFeedback, state));
-    Comm::Write(conn, &mb, writeCall);
+    Comm::Write(conn, &state->queryMsg, writeCall);
     AsyncCall::Pointer readCall = commCbCall(5,4, "Ident::ReadReply",
                                   CommIoCbPtrFun(Ident::ReadReply, state));
     comm_read(conn, state->buf, IDENT_BUFSIZE, readCall);
@@ -264,6 +260,10 @@ Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
     state->conn->local.SetPort(0);
     state->conn->remote.SetPort(IDENT_PORT);
 
+    // build our query from the original connection details
+    state->queryMsg.init();
+    state->queryMsg.Printf("%d, %d\r\n", conn->remote.GetPort(), conn->local.GetPort());
+
     ClientAdd(state, callback, data);
     hash_join(ident_hash, &state->hash);
 
@@ -48,7 +48,7 @@
 
 /* called when we "miss" on an internal object;
  * generate known dynamic objects,
- * return HTTP_NOT_FOUND for others
+ * return Http::scNotFound for others
  */
 void
 internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request, StoreEntry * entry)
@@ -68,7 +68,7 @@ internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request,
 #endif
 
         HttpReply *reply = new HttpReply;
-        reply->setHeaders(HTTP_NOT_FOUND, "Not Found", "text/plain", strlen(msgbuf), squid_curtime, -2);
+        reply->setHeaders(Http::scNotFound, "Not Found", "text/plain", strlen(msgbuf), squid_curtime, -2);
         entry->replaceHttpReply(reply);
         entry->append(msgbuf, strlen(msgbuf));
         entry->complete();
@@ -77,7 +77,7 @@ internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request,
     } else {
         debugObj(76, 1, "internalStart: unknown request:\n",
                  request, (ObjPackMethod) & httpRequestPack);
-        err = new ErrorState(ERR_INVALID_REQ, HTTP_NOT_FOUND, request);
+        err = new ErrorState(ERR_INVALID_REQ, Http::scNotFound, request);
         errorAppendEntry(entry, err);
     }
 }
@@ -400,10 +400,6 @@ Ip::Address::LookupHostIP(const char *s, bool nodns)
     if (nodns) {
         want.ai_flags = AI_NUMERICHOST; // prevent actual DNS lookups!
     }
-#if 0
-    else if (!Ip::EnableIpv6)
-        want.ai_family = AF_INET;  // maybe prevent IPv6 DNS lookups.
-#endif
 
     if ( (err = getaddrinfo(s, NULL, &want, &res)) != 0) {
         debugs(14,3, HERE << "Given Non-IP '" << s << "': " << gai_strerror(err) );
@@ -5,8 +5,13 @@
 int
 Ip::Qos::setSockTos(const Comm::ConnectionPointer &conn, tos_t tos)
 {
-#ifdef IP_TOS
-    int x = setsockopt(conn->fd, IPPROTO_IP, IP_TOS, &tos, sizeof(tos_t));
+#if defined(IP_TOS)
+    // Bug 3731: FreeBSD produces 'invalid option'
+    // unless we pass it a 32-bit variable storing 8-bits of data.
+    // NP: it is documented as 'int' for all systems, even those like Linux which accept 8-bit char
+    //     so we convert to a int before setting.
+    int bTos = tos;
+    int x = setsockopt(conn->fd, IPPROTO_IP, IP_TOS, &bTos, sizeof(bTos));
     if (x < 0)
         debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IP_TOS) on " << conn << ": " << xstrerror());
     return x;
@@ -184,22 +184,14 @@ Ip::Qos::doNfmarkLocalHit(const Comm::ConnectionPointer &conn)
 
 Ip::Qos::Config Ip::Qos::TheConfig;
 
-Ip::Qos::Config::Config()
+Ip::Qos::Config::Config() : tosLocalHit(0), tosSiblingHit(0), tosParentHit(0),
+        tosMiss(0), tosMissMask(0), preserveMissTos(false),
+        preserveMissTosMask(0xFF), markLocalHit(0), markSiblingHit(0),
+        markParentHit(0), markMiss(0), markMissMask(0),
+        preserveMissMark(false), preserveMissMarkMask(0xFFFFFFFF),
+        tosToServer(NULL), tosToClient(NULL), nfmarkToServer(NULL),
+        nfmarkToClient(NULL)
 {
-    tosLocalHit = 0;
-    tosSiblingHit = 0;
-    tosParentHit = 0;
-    tosMiss = 0;
-    tosMissMask = 0;
-    preserveMissTos = false;
-    preserveMissTosMask = 0xFF;
-    markLocalHit = 0;
-    markSiblingHit = 0;
-    markParentHit = 0;
-    markMiss = 0;
-    markMissMask = 0;
-    preserveMissMark = false;
-    preserveMissMarkMask = 0xFFFFFFFF;
 }
 
 void
@@ -711,6 +711,7 @@ testIpAddress::testAddrInfo()
     CPPUNIT_ASSERT( memcmp( expect->ai_addr, ipval->ai_addr, expect->ai_addrlen ) == 0 );
 
     freeaddrinfo(expect);
+    anIP.FreeAddrInfo(ipval);
 }
 
 void
@@ -255,23 +255,23 @@ Ipc::Coordinator::openListenSocket(const SharedListenRequest& request,
     debugs(54, 6, HERE << "opening listen FD at " << p.addr << " for kid" <<
            request.requestorId);
 
-    Comm::ConnectionPointer conn = new Comm::Connection;
-    conn->local = p.addr; // comm_open_listener may modify it
-    conn->flags = p.flags;
+    Comm::ConnectionPointer newConn = new Comm::Connection;
+    newConn->local = p.addr; // comm_open_listener may modify it
+    newConn->flags = p.flags;
 
     enter_suid();
-    comm_open_listener(p.sock_type, p.proto, conn, FdNote(p.fdNote));
-    errNo = Comm::IsConnOpen(conn) ? 0 : errno;
+    comm_open_listener(p.sock_type, p.proto, newConn, FdNote(p.fdNote));
+    errNo = Comm::IsConnOpen(newConn) ? 0 : errno;
     leave_suid();
 
-    debugs(54, 6, HERE << "tried listening on " << conn << " for kid" <<
+    debugs(54, 6, HERE << "tried listening on " << newConn << " for kid" <<
            request.requestorId);
 
     // cache positive results
-    if (Comm::IsConnOpen(conn))
-        listeners[request.params] = conn;
+    if (Comm::IsConnOpen(newConn))
+        listeners[request.params] = newConn;
 
-    return conn;
+    return newConn;
 }
 
 void Ipc::Coordinator::broadcastSignal(int sig) const
@@ -17,7 +17,8 @@ Kid::Kid():
         badFailures(0),
         pid(-1),
         startTime(0),
-        isRunning(false)
+        isRunning(false),
+        status(0)
 {
 }
 
@@ -26,7 +27,8 @@ Kid::Kid(const String& kid_name):
         badFailures(0),
         pid(-1),
         startTime(0),
-        isRunning(false)
+        isRunning(false),
+        status(0)
 {
 }
 
@@ -42,7 +44,7 @@ void Kid::start(pid_t cpid)
 }
 
 /// called when kid terminates, sets exiting status
-void Kid::stop(status_type exitStatus)
+void Kid::stop(status_type theExitStatus)
 {
     assert(running());
     assert(startTime != 0);
@@ -56,7 +58,7 @@ void Kid::stop(status_type exitStatus)
     else
         badFailures = 0; // the failures are not "frequent" [any more]
 
-    status = exitStatus;
+    status = theExitStatus;
 }
 
 /// returns true if tracking of kid is stopped
@@ -231,8 +231,8 @@ StoreMapWithExtras<ExtrasT>::Init(const char *const path, const int limit)
 }
 
 template <class ExtrasT>
-StoreMapWithExtras<ExtrasT>::StoreMapWithExtras(const char *const path):
-        StoreMap(path)
+StoreMapWithExtras<ExtrasT>::StoreMapWithExtras(const char *const aPath):
+        StoreMap(aPath)
 {
     const size_t sharedSizeWithoutExtras =
         Shared::SharedMemorySize(entryLimit(), 0);
@@ -132,38 +132,38 @@ Ipc::TypedMsgHdr::putString(const String &s)
 }
 
 void
-Ipc::TypedMsgHdr::getFixed(void *raw, size_t size) const
+Ipc::TypedMsgHdr::getFixed(void *rawBuf, size_t rawSize) const
 {
     // no need to load size because it is constant
-    getRaw(raw, size);
+    getRaw(rawBuf, rawSize);
 }
 
 void
-Ipc::TypedMsgHdr::putFixed(const void *raw, size_t size)
+Ipc::TypedMsgHdr::putFixed(const void *rawBuf, size_t rawSize)
 {
     // no need to store size because it is constant
-    putRaw(raw, size);
+    putRaw(rawBuf, rawSize);
 }
 
 /// low-level loading of exactly size bytes of raw data
 void
-Ipc::TypedMsgHdr::getRaw(void *raw, size_t size) const
+Ipc::TypedMsgHdr::getRaw(void *rawBuf, size_t rawSize) const
 {
-    if (size > 0) {
-        Must(size <= data.size - offset);
-        memcpy(raw, data.raw + offset, size);
-        offset += size;
+    if (rawSize > 0) {
+        Must(rawSize <= data.size - offset);
+        memcpy(rawBuf, data.raw + offset, rawSize);
+        offset += rawSize;
     }
 }
 
 /// low-level storage of exactly size bytes of raw data
 void
-Ipc::TypedMsgHdr::putRaw(const void *raw, size_t size)
+Ipc::TypedMsgHdr::putRaw(const void *rawBuf, size_t rawSize)
 {
-    if (size > 0) {
-        Must(size <= sizeof(data.raw) - data.size);
-        memcpy(data.raw + data.size, raw, size);
-        data.size += size;
+    if (rawSize > 0) {
+        Must(rawSize <= sizeof(data.raw) - data.size);
+        memcpy(data.raw + data.size, rawBuf, rawSize);
+        data.size += rawSize;
     }
 }
 
@@ -321,13 +321,10 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     if (wfd)
         *wfd = pwfd;
 
-    fd_table[prfd].flags.ipc = 1;
-
-    fd_table[pwfd].flags.ipc = 1;
-
-    fd_table[crfd].flags.ipc = 1;
-
-    fd_table[cwfd].flags.ipc = 1;
+    fd_table[prfd].flags.ipc = true;
+    fd_table[pwfd].flags.ipc = true;
+    fd_table[crfd].flags.ipc = true;
+    fd_table[cwfd].flags.ipc = true;
 
     if (Config.sleep_after_fork) {
         /* XXX emulation of usleep() */
@@ -113,8 +113,8 @@ class ipcache_entry
     dlink_node lru;
     unsigned short locks;
     struct {
-        unsigned int negcached:1;
-        unsigned int fromhosts:1;
+        bool negcached;
+        bool fromhosts;
     } flags;
 
     int age() const; ///< time passed since request_time or -1 if unknown
@@ -473,7 +473,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
     int cname_found = 0;
 
     i->expires = squid_curtime + Config.negativeDnsTtl;
-    i->flags.negcached = 1;
+    i->flags.negcached = true;
     safe_free(i->addrs.in_addrs);
     assert(i->addrs.in_addrs == NULL);
     safe_free(i->addrs.bad_mask);
@@ -585,7 +585,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
 
     i->expires = squid_curtime + ttl;
 
-    i->flags.negcached = 0;
+    i->flags.negcached = false;
 
     return i->addrs.count;
 }
@@ -1218,7 +1218,7 @@ ipcacheAddEntryFromHosts(const char *name, const char *ipaddr)
     i->addrs.bad_mask = (unsigned char *)xcalloc(1, sizeof(unsigned char));
     i->addrs.in_addrs[0] = ip;
     i->addrs.bad_mask[0] = FALSE;
-    i->flags.fromhosts = 1;
+    i->flags.fromhosts = true;
     ipcacheAddEntry(i);
     ipcacheLockEntry(i);
     return 0;
@@ -78,7 +78,7 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   al->cache.replySize,
                   referer,
                   agent,
-                  ::Format::log_tags[al->cache.code],
+                  LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   hier_code_str[al->hier.code],
                   (Config.onoff.log_mime_hdrs?"":"\n"));
@@ -60,7 +60,7 @@ Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   al->http.version.major, al->http.version.minor,
                   al->http.code,
                   al->cache.replySize,
-                  ::Format::log_tags[al->cache.code],
+                  LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   hier_code_str[al->hier.code],
                   (Config.onoff.log_mime_hdrs?"":"\n"));
@@ -69,7 +69,7 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   (int) current_time.tv_usec / 1000,
                   al->cache.msec,
                   clientip,
-                  ::Format::log_tags[al->cache.code],
+                  LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   al->http.code,
                   al->cache.replySize,
@@ -113,26 +113,29 @@ logfileFreeBuffer(Logfile * lf, logfile_buffer_t * b)
 static void
 logfileHandleWrite(int fd, void *data)
 {
-    Logfile *lf = (Logfile *) data;
-    l_daemon_t *ll = (l_daemon_t *) lf->data;
-    int ret;
-    logfile_buffer_t *b;
+    Logfile *lf = static_cast<Logfile *>(data);
+    l_daemon_t *ll = static_cast<l_daemon_t *>(lf->data);
 
     /*
      * We'll try writing the first entry until its done - if we
      * get a partial write then we'll re-schedule until its completed.
      * Its naive but it'll do for now.
      */
-    b = static_cast<logfile_buffer_t*>(ll->bufs.head->data);
+    if (!ll->bufs.head) // abort if there is nothing pending right now.
+        return;
+
+    logfile_buffer_t *b = static_cast<logfile_buffer_t*>(ll->bufs.head->data);
     assert(b != NULL);
     ll->flush_pending = 0;
 
-    ret = FD_WRITE_METHOD(ll->wfd, b->buf + b->written_len, b->len - b->written_len);
-    debugs(50, 3, "logfileHandleWrite: " << lf->path << ": write returned " << ret);
+    int ret = FD_WRITE_METHOD(ll->wfd, b->buf + b->written_len, b->len - b->written_len);
+    debugs(50, 3, lf->path << ": write returned " << ret);
     if (ret < 0) {
         if (ignoreErrno(errno)) {
             /* something temporary */
-            goto reschedule;
+            Comm::SetSelect(ll->wfd, COMM_SELECT_WRITE, logfileHandleWrite, lf, 0);
+            ll->flush_pending = 1;
+            return;
         }
         debugs(50, DBG_IMPORTANT,"logfileHandleWrite: " << lf->path << ": error writing (" << xstrerror() << ")");
         /* XXX should handle this better */
@@ -153,15 +156,12 @@ logfileHandleWrite(int fd, void *data)
         b = NULL;
     }
     /* Is there more to write? */
-    if (ll->bufs.head == NULL) {
-        goto finish;
-    }
+    if (!ll->bufs.head)
+        return;
     /* there is, so schedule more */
 
-reschedule:
     Comm::SetSelect(ll->wfd, COMM_SELECT_WRITE, logfileHandleWrite, lf, 0);
     ll->flush_pending = 1;
-finish:
     return;
 }
 
@@ -253,7 +253,7 @@ HierarchyLogEntry::HierarchyLogEntry() :
         cd_lookup(LOOKUP_NONE),
         n_choices(0),
         n_ichoices(0),
-        peer_reply_status(HTTP_STATUS_NONE),
+        peer_reply_status(Http::scNone),
         peer_response_time(-1),
         total_response_time(-1),
         tcpServer(NULL),
@@ -531,7 +531,6 @@ headersLog(int cs, int pq, const HttpRequestMethod& method, void *data)
     HttpRequest *req;
     unsigned short magic = 0;
     unsigned char M = (unsigned char) m;
-    unsigned short S;
     char *hmask;
     int ccmask = 0;
 
@@ -566,10 +565,9 @@ headersLog(int cs, int pq, const HttpRequestMethod& method, void *data)
     magic = htons(magic);
     ccmask = htonl(ccmask);
 
+    unsigned short S = 0;
     if (0 == pq)
-        S = (unsigned short) rep->sline.status;
-    else
-        S = (unsigned short) HTTP_STATUS_NONE;
+        S = static_cast<unsigned short>(rep->sline.status());
 
     logfileWrite(headerslog, &magic, sizeof(magic));
     logfileWrite(headerslog, &M, sizeof(M));
@@ -579,32 +577,3 @@ headersLog(int cs, int pq, const HttpRequestMethod& method, void *data)
 }
 
 #endif
-
-int
-logTypeIsATcpHit(log_type code)
-{
-    /* this should be a bitmap for better optimization */
-
-    if (code == LOG_TCP_HIT)
-        return 1;
-
-    if (code == LOG_TCP_IMS_HIT)
-        return 1;
-
-    if (code == LOG_TCP_REFRESH_FAIL_OLD)
-        return 1;
-
-    if (code == LOG_TCP_REFRESH_UNMODIFIED)
-        return 1;
-
-    if (code == LOG_TCP_NEGATIVE_HIT)
-        return 1;
-
-    if (code == LOG_TCP_MEM_HIT)
-        return 1;
-
-    if (code == LOG_TCP_OFFLINE_HIT)
-        return 1;
-
-    return 0;
-}
@@ -33,7 +33,8 @@
 #ifndef SQUID_LOG_ACCESS_LOG_H_
 #define SQUID_LOG_ACCESS_LOG_H_
 
-int logTypeIsATcpHit(log_type);
+#include "LogTags.h"
+
 void fvdbCountVia(const char *key);
 void fvdbCountForw(const char *key);
 