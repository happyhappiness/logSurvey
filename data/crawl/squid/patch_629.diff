@@ -122,7 +122,7 @@ KRB5INT_BEGIN_DECLS
 #endif
 #endif
 #include <krb5.h>
-main()
+int main(int argc, char *argv[])
 {
     krb5_context context;
     krb5_ccache cc;
@@ -119,7 +119,7 @@ xmalloc(size_t sz)
     if (p == NULL) {
         if (failure_notify) {
             static char msg[128];
-            snprintf(msg, 128, "xmalloc: Unable to allocate %Zu bytes!\n", sz);
+            snprintf(msg, 128, "xmalloc: Unable to allocate %lu bytes!\n", (unsigned long)sz);
             failure_notify(msg);
         } else {
             perror("malloc");
@@ -167,7 +167,7 @@ xrealloc(void *s, size_t sz)
     if (p == NULL) {
         if (failure_notify) {
             static char msg[128];
-            snprintf(msg, 128, "xrealloc: Unable to reallocate %Zu bytes!\n", sz);
+            snprintf(msg, 128, "xrealloc: Unable to reallocate %lu bytes!\n", (unsigned long)sz);
             failure_notify(msg);
         } else {
             perror("realloc");
@@ -40,6 +40,12 @@ AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
+# might be cross-compiling
+if test "x$HOSTCXX" = "x"; then
+  HOSTCXX="$CXX"
+fi
+AC_SUBST(HOSTCXX)
+
 AC_MSG_CHECKING([simplified host os])
 simple_host_os=`echo $host_os|sed 's/[0-9].*//g;s/-.*//g'`
 squid_host_os_version=`echo $host_os|tr -d "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-"`
@@ -1 +0,0 @@
-</div>
@@ -1010,6 +1010,7 @@ NOCOMMENT_START
 	<tag>auth_param ntlm, basic, digest</tag>
 	<p>BASIC, DIGEST:  New parameter option <em>utf8 on|off</em> to permit helpers to selectively process UTF-8 characters even though
 	   HTTP accepts only ISO-8859-1.</p>
+	<p>NCSA authenticator updated to reject passwords with more than 8 characters when using DES encryption method.
 	<p>NTLM: The helper binary bundled with Squid under the name <em>ntlm_auth</em> has been renamed to accurately reflect
 	   its real behavior and to prevent confusion with the more useful Samba helper using the same name.
 	<p>Despite being used for NTLM, the helper does not in fact provide true NTLM function. What it does provide is
@@ -546,14 +546,17 @@ This section gives a thorough account of those changes in three categories:
 	which applies to both ICAP and eCAP.</p>
 
 	<tag>logformat</tag>
+	<p><em>%&lt;a</em> Server or Peer IP address from the last server connection (next hop).
         <p><em>%&gt;bs</em> Number of HTTP-equivalent message body bytes received from the next hop.
         <p><em>icap::%&gt;bs</em> Number of message body bytes received from the ICAP server.
 	<p><em>%sn</em> Unique sequence number per log line. Ported from 2.7
-	<p><em>%&gt;eui</em> EUI logging (EUI-48 / MAC address for IPv4, EUI-64 for IPv6)
+	<p><em>%&gt;eui</em> EUI logging (EUI-48 / MAC address for IPv4, EUI-64 for IPv6).
 	   Both EUI forms are logged in the same field. Type can be identified by length or byte delimiter.
-        <p><em>%err_code</em> The ID of an error response served by Squid or
-          a similar internal error identifier
+        <p><em>%err_code</em> The ID of an error response served by Squid or a similar internal error identifier
         <p><em>%err_detail</em> Additional err_code-dependent error information.
+	<p><em>%&gt;la</em> Rename of %la to indicate being a client connection detail.
+	<p><em>%&gt;lp</em> Rename of %lp to indicate being a client connection detail.
+	<p><em>%&lt;p</em> Server or Peer port number from the last server connection (next hop).
 
 	<tag>memory_pools_limit</tag>
 	<p>Memory limits have been revised and corrected from 3.1.4 onwards.
@@ -622,6 +625,9 @@ This section gives a thorough account of those changes in three categories:
 	<tag>log_fqdn</tag>
 	<p>Obsolete. Replaced by automatic detection of the %>A logformat tag.
 
+	<tag>log_ip_on_direct</tag>
+	<p>Obsolete. Use a custom log with <em>%&lt;A</em> format tag to receive server FQDN or peer name.
+
 	<tag>maximum_single_addr_tries</tag>
 	<p>The behaviour controlled by this directive is no longer possible.
 	   It has been replaced by <em>connect_retries</em> option which operates a little differently.
@@ -17,6 +17,13 @@ httpd\-style password file when using basic HTTP authentication.
 This password file can be manipulated using
 .B htpasswd.
 .
+.PP
+.This authenticator accepts:
+.BR
+* MD5 - with optional salt and magic strings
+.BR
+* DES - for passwords 8 characters or less in length
+.
 .SH OPTIONS
 The only parameter is the password file.
 It must have permissions to be read by the user that Squid is running as.
@@ -29,6 +36,12 @@ It must have permissions to be read by the user that Squid is running as.
 .B basic_ncsa_auth
 must have access to the password file to be executed.
 .
+.SH KNOWN ISSUES
+.PP
+DES functionality (used by htpasswd by default) silently truncates passwords to 8 characters.
+Allowing login with password values shorter than the one desired.
+This authenticator will reject login with long passwords when using DES.
+.
 .SH AUTHOR
 This manual was written by
 .if !'po4a'hide' .I Amos Jeffries <amosjeffries@squid-cache.org>
@@ -13,6 +13,7 @@
  * - extra fields in the password file are ignored; this makes it
  *   possible to use a Unix password file but I do not recommend that.
  *
+ *  MD5 without salt and magic strings - Added by Ramon de Carvalho and Rodrigo Rubira Branco
  */
 
 #include "config.h"
@@ -139,12 +140,13 @@ main(int argc, char **argv)
         if (u == NULL) {
             SEND_ERR("No such user");
 #if HAVE_CRYPT
-        } else if (strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
+        } else if (strlen(passwd) <= 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
+            // Bug 3107: crypt() DES functionality silently truncates long passwords.
             SEND_OK("");
 #endif
         } else if (strcmp(u->passwd, (char *) crypt_md5(passwd, u->passwd)) == 0) {
             SEND_OK("");
-        } else if (strcmp(u->passwd, (char *) md5sum(passwd)) == 0) {	/* md5 without salt and magic strings - Added by Ramon de Carvalho and Rodrigo Rubira Branco */
+        } else if (strcmp(u->passwd, (char *) md5sum(passwd)) == 0) {
             SEND_OK("");
         } else {
             SEND_ERR("Wrong password");
@@ -8,6 +8,12 @@
 #include <syslog.h>
 #include <sys/types.h>
 #include <rpc/rpc.h>
+
+#if _SQUID_FREEBSD_  && !defined(BOOL_DEFINED)
+// BUG: FreeBSD rpcsvc/yp_* headers try to redefine bool unless we match their non-standard hack.
+#define BOOL_DEFINED
+#endif
+
 #include <rpcsvc/ypclnt.h>
 #include <rpcsvc/yp_prot.h>
 
@@ -108,7 +108,6 @@ main(int argc, char *const argv[])
     char tbuff[MAX_AUTHTOKEN_LEN];
     char buff[MAX_AUTHTOKEN_LEN+2];
     char *c;
-    static int err = 0;
     int debug = 0;
     int length;
     int nstart = 0, kstart = 0;
@@ -299,20 +298,16 @@ main(int argc, char *const argv[])
         if (c) {
             *c = '\0';
             length = c - buf;
+            if (debug)
+                fprintf(stderr, "%s| %s: Got '%s' from squid (length: %d).\n",
+                        LogTime(), PROGRAM, buf, length);
         } else {
-            err = 1;
-        }
-        if (err) {
             if (debug)
                 fprintf(stderr, "%s| %s: Oversized message\n", LogTime(),
                         PROGRAM);
             fprintf(stdout, "BH Oversized message\n");
-            err = 0;
             continue;
         }
-        if (debug)
-            fprintf(stderr, "%s| %s: Got '%s' from squid (length: %d).\n",
-                    LogTime(), PROGRAM, buf, length);
 
         if (buf[0] == '\0') {
             if (debug)
@@ -60,12 +60,12 @@
 #include "ntlmauth/support_bits.cci"
 //#include "util.h"
 
-#if HAVE_CTYPE_H
-#include <ctype.h>
-#endif
 #if HAVE_STRING_H
 #include <string.h>
 #endif
+#if HAVE_CTYPE_H
+#include <ctype.h>
+#endif
 #if HAVE_CRYPT_H
 #include <crypt.h>
 #endif
@@ -75,6 +75,15 @@
 #if HAVE_GETOPT_H
 #include <getopt.h>
 #endif
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
 
 /* A couple of harmless helper macros */
 #define SEND(X) debug("sending '%s' to squid\n",X); printf(X "\n");
@@ -190,7 +199,7 @@ main(int argc, char *argv[])
         } else
             debug("Got '%s' from Squid\n", buf);
 
-        if (strncasecmp(buf, "YR", 2) == 0) {
+        if (strncmp(buf, "YR", 2) == 0) {
             char nonce[NTLM_NONCE_LEN];
             ntlm_challenge chal;
             ntlm_make_nonce(nonce);
@@ -211,7 +220,7 @@ main(int argc, char *argv[])
                 hex_dump((unsigned char *)&chal, len);
             } else
                 SEND2("TT %s", data);
-        } else if (strncasecmp(buf, "KK ", 3) == 0) {
+        } else if (strncmp(buf, "KK ", 3) == 0) {
             if (!packet) {
                 SEND("BH received KK with no data! user=");
             } else if (ntlm_validate_packet(packet, NTLM_AUTHENTICATE) == NTLM_ERR_NONE) {
@@ -1,4 +1,4 @@
-#!/bin/sh -ex
+#!/bin/sh -e
 echo "RUN: $0"
 # Nightly cron job to generate snapshot releases
 top=${PWD}
@@ -118,11 +118,11 @@ make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_1 v3 3.1 3
 #../commit/bootstrap squid-3.0
 #make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_0 v3 3.0 3
 
-../commit/bootstrap squid-2
-make_snapshot ../commit/squid-2/mksnapshot.sh HEAD v2 HEAD 3
+#../commit/bootstrap squid-2
+#make_snapshot ../commit/squid-2/mksnapshot.sh HEAD v2 HEAD 3
 
-../commit/bootstrap squid-2.7
-make_snapshot ../commit/squid-2.7/mksnapshot.sh SQUID_2_7 v2 2.7 3
+#../commit/bootstrap squid-2.7
+#make_snapshot ../commit/squid-2.7/mksnapshot.sh SQUID_2_7 v2 2.7 3
 
 #../commit/bootstrap squid-2.6
 #make_snapshot ../commit/squid-2.6/mksnapshot.sh SQUID_2_6 v2 2.6 3
@@ -1,4 +1,4 @@
-#!/bin/sh -ex
+#!/bin/sh -e
 
 if [ $# -lt 1 ]; then
 	echo "Usage: $0 [branch]"
@@ -790,7 +790,7 @@ HTML_HEADER            = ./doc/Programming-Guide/doxygen.header.dyn
 # each generated HTML page. If it is left blank doxygen will generate a 
 # standard footer.
 
-HTML_FOOTER            = ./doc/Programming-Guide/doxygen.footer.dyn
+#HTML_FOOTER            = ./doc/Programming-Guide/doxygen.footer.dyn
 
 # The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
 # style sheet that is used by each HTML page. It can be used to 
@@ -30,6 +30,7 @@
 #ifndef SQUID_HTTPACCESSLOGENTRY_H
 #define SQUID_HTTPACCESSLOGENTRY_H
 
+#include "comm/Connection.h"
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
@@ -47,11 +48,16 @@ class AccessLogEntry
 {
 
 public:
-    AccessLogEntry() : url(NULL) , reply(NULL), request(NULL),
+    AccessLogEntry() : url(NULL), tcpClient(), reply(NULL), request(NULL),
             adapted_request(NULL) {}
 
     const char *url;
 
+    /// TCP/IP level details about the client connection
+    Comm::ConnectionPointer tcpClient;
+    // TCP/IP level details about the server or peer connection
+    // are stored in hier.tcpServer
+
     /** \brief This subclass holds log info for HTTP protocol
      * \todo Inner class declarations should be moved outside
      * \todo details of HTTP held in the parent class need moving into here.
@@ -159,9 +159,11 @@ void ChunkedCodingParser::parseTrailerHeader()
     size_t crlfEnd = 0;
 
     if (findCrlf(crlfBeg, crlfEnd)) {
-        if (crlfBeg > 0)
 
-            ; //theTrailer.append(theIn->content(), crlfEnd);
+#if TRAILERS_ARE_SUPPORTED
+        if (crlfBeg > 0)
+            theTrailer.append(theIn->content(), crlfEnd);
+#endif
 
         theIn->consume(crlfEnd);
 
@@ -27,7 +27,7 @@ class ClientRequestContext : public RefCountable
     bool httpStateIsValid();
     void hostHeaderVerify();
     void hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLookupDetails &dns);
-    void hostHeaderVerifyFailed();
+    void hostHeaderVerifyFailed(const char *A, const char *B);
     void clientAccessCheck();
     void clientAccessCheck2();
     void clientAccessCheckDone(const allow_t &answer);
@@ -69,7 +69,7 @@ ExternalACLEntry::operator delete (void *address)
 ExternalACLEntry::ExternalACLEntry()
 {
     lru.next = lru.prev = NULL;
-    result = 0;
+    result = ACCESS_DENIED;
     date = 0;
     def = NULL;
 }
@@ -44,7 +44,7 @@
 #ifndef SQUID_EXTERNALACLENTRY_H
 #define SQUID_EXTERNALACLENTRY_H
 
-
+#include "acl/Acl.h"
 #include "cbdata.h"
 
 /******************************************************************
@@ -58,9 +58,9 @@ class ExternalACLEntryData
 {
 
 public:
-    ExternalACLEntryData() : result (-1) {}
+    ExternalACLEntryData() : result(ACCESS_DUNNO) {}
 
-    int result;
+    allow_t result;
 #if USE_AUTH
     // TODO use an AuthUser to hold this info
     String user;
@@ -89,7 +89,7 @@ class ExternalACLEntry: public hash_link
 
     void update(ExternalACLEntryData const &);
     dlink_node lru;
-    int result;
+    allow_t result;
     time_t date;
 #if USE_AUTH
     String user;
@@ -34,8 +34,8 @@
 #ifndef SQUID_HTTPHIERARCHYLOGENTRY_H
 #define SQUID_HTTPHIERARCHYLOGENTRY_H
 
+#include "comm/Connection.h"
 #include "hier_code.h"
-#include "ip/Address.h"
 #include "lookup_t.h"
 #include "rfc2181.h"
 #include "PingData.h"
@@ -48,6 +48,13 @@ class HierarchyLogEntry
 
 public:
     HierarchyLogEntry();
+    ~HierarchyLogEntry() { tcpServer = NULL; };
+
+    /// Record details from a new server connection.
+    /// call this whenever the destination server changes.
+    void note(const Comm::ConnectionPointer &server, const char *requestedHost);
+
+public:
     hier_code code;
     char host[SQUIDHOSTNAMELEN];
     ping_data ping;
@@ -65,10 +72,8 @@ class HierarchyLogEntry
     int64_t peer_response_time; ///< last peer response delay
     timeval first_conn_start; ///< first connection use among all peers
     int64_t total_response_time; ///< cumulative for all peers
-    Ip::Address peer_local_addr; ///< local IP:port of the last server-side connection
+    Comm::ConnectionPointer tcpServer; ///< TCP/IP level details of the last server-side connection
     int64_t bodyBytesRead;  ///< number of body bytes received from the next hop or -1
 };
 
-extern void hierarchyNote(HierarchyLogEntry *, hier_code, const char *);
-
 #endif /* SQUID_HTTPHIERARCHYLOGENTRY_H */
@@ -209,11 +209,8 @@ libexec_PROGRAMS = \
 
 cf_gen_SOURCES = cf_gen.cc
 nodist_cf_gen_HEADER = cf_gen_defines.cci
-cf_gen_LDADD= \
-	$(COMPAT_LIB) \
-	$(EPOLL_LIBS) \
-	$(MINGW_LIBS) \
-	$(XTRA_LIBS)
+## cf_gen must be stand-alone executable. It is a purely build-time executable.
+cf_gen_LDADD=
 cf_gen.$(OBJEXT): cf_gen_defines.cci
 
 ## cf_gen.cc needs src/cf_gen_defines.cci
@@ -893,6 +890,10 @@ test_cache_digest: test_cache_digest.o CacheDigest.o debug.o globals.o store_key
 ## If autodependency works well this is not needed anymore
 cache_cf.o: cf_parser.cci
 
+# cf_gen builds the configuration files.
+cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES)
+	$(HOSTCXX) -o $@ $(srcdir)/cf_gen.cc -I$(srcdir) -I$(top_builddir)/include/ -I$(top_builddir)/src
+
 # squid.conf.default is built by cf_gen when making cf_parser.cci
 squid.conf.default squid.conf.documented: cf_parser.cci
 	true
@@ -105,10 +105,15 @@ class ACL
 
 /// \ingroup ACLAPI
 typedef enum {
+    // Authorization ACL result states
     ACCESS_DENIED,
     ACCESS_ALLOWED,
     ACCESS_DUNNO,
-    ACCESS_REQ_PROXY_AUTH
+
+    // Authentication ACL result states
+    ACCESS_AUTH_REQUIRED,    // Missing Credentials
+    ACCESS_AUTH_EXPIRED_OK,  // Expired now. Were Okay.
+    ACCESS_AUTH_EXPIRED_BAD  // Expired now. Were Failed.
 } allow_t;
 
 /// \ingroup ACLAPI
@@ -3,6 +3,7 @@
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
+ * AUTHOR: Marcus Kool
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -32,6 +33,7 @@
  *
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ * Copyright (c) 2011, Marcus Kool
  */
 
 #include "squid.h"
@@ -41,8 +43,7 @@
 #include "wordlist.h"
 #include "ConfigParser.h"
 
-static void aclDestroyRegexList(relist * data);
-void
+static void
 aclDestroyRegexList(relist * data)
 {
     relist *next = NULL;
@@ -123,49 +124,214 @@ ACLRegexData::dump()
     return W;
 }
 
-static void aclParseRegexList(relist **curlist);
-void
-aclParseRegexList(relist **curlist)
+static const char *
+removeUnnecessaryWildcards(char * t)
+{
+    char * orig = t;
+
+    if (strncmp(t, "^.*", 3) == 0)
+        t += 3;
+
+    /* NOTE: an initial '.' might seem unnessary but is not;
+     * it can be a valid requirement that cannot be optimised
+     */
+    while (*t == '.'  &&  *(t+1) == '*') {
+        t += 2;
+    }
+
+    if (*t == '\0') {
+        debugs(28, DBG_IMPORTANT, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_IMPORTANT, "WARNING: regular expression '" << orig << "' has only wildcards and matches all strings. Using '.*' instead.");
+        return ".*";
+    }
+    if (t != orig) {
+        debugs(28, DBG_IMPORTANT, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_IMPORTANT, "WARNING: regular expression '" << orig << "' has unnecessary wildcard(s). Using '" << t << "' instead.");
+    }
+
+    return t;
+}
+
+static relist **
+compileRE(relist **Tail, char * RE, int flags)
 {
-    relist **Tail;
-    relist *q = NULL;
-    char *t = NULL;
-    regex_t comp;
     int errcode;
+    relist *q;
+    regex_t comp;
+
+    if (RE == NULL  ||  *RE == '\0')
+        return Tail;
+
+    if ((errcode = regcomp(&comp, RE, flags)) != 0) {
+        char errbuf[256];
+        regerror(errcode, &comp, errbuf, sizeof errbuf);
+        debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': " << errbuf);
+        return NULL;
+    }
+    debugs(28, 2, "compileRE: compiled '" << RE << "' with flags " << flags );
+
+    q = (relist *) memAllocate(MEM_RELIST);
+    q->pattern = xstrdup(RE);
+    q->regex = comp;
+    q->flags = flags;
+    *(Tail) = q;
+    Tail = &q->next;
+
+    return Tail;
+}
+
+/** Compose and compile one large RE from a set of (small) REs.
+ * The ultimate goal is to have only one RE per ACL so that regexec() is
+ * called only once per ACL.
+ */
+static int
+compileOptimisedREs(relist **curlist, wordlist * wl)
+{
+    relist **Tail;
+    relist *newlist;
+    relist **newlistp;
+    int numREs = 0;
     int flags = REG_EXTENDED | REG_NOSUB;
+    int largeREindex = 0;
+    char largeRE[BUFSIZ];
 
-    debugs(28,5, HERE << "Regex new line.");
+    newlist = NULL;
+    newlistp = &newlist;
 
-    for (Tail = (relist **)curlist; *Tail; Tail = &((*Tail)->next));
-    while ((t = ConfigParser::strtokFile())) {
+    largeRE[0] = '\0';
 
-        debugs(28,5, HERE << "Regex token: " << t);
+    while (wl != NULL) {
+        int RElen;
+        RElen = strlen( wl->key );
 
-        if (strcmp(t, "-i") == 0) {
-            flags |= REG_ICASE;
-            continue;
+        if (strcmp(wl->key, "-i") == 0) {
+            if (flags & REG_ICASE) {
+                /* optimisation of  -i ... -i */
+                debugs(28, 2, "compileOptimisedREs: optimisation of -i ... -i" );
+            } else {
+                debugs(28, 2, "compileOptimisedREs: -i" );
+                newlistp = compileRE( newlistp, largeRE, flags );
+                if (newlistp == NULL) {
+                    aclDestroyRegexList( newlist );
+                    return 0;
+                }
+                flags |= REG_ICASE;
+                largeRE[largeREindex=0] = '\0';
+            }
+        } else if (strcmp(wl->key, "+i") == 0) {
+            if ((flags & REG_ICASE) == 0) {
+                /* optimisation of  +i ... +i */
+                debugs(28, 2, "compileOptimisedREs: optimisation of +i ... +i");
+            } else {
+                debugs(28, 2, "compileOptimisedREs: +i");
+                newlistp = compileRE( newlistp, largeRE, flags );
+                if (newlistp == NULL) {
+                    aclDestroyRegexList( newlist );
+                    return 0;
+                }
+                flags &= ~REG_ICASE;
+                largeRE[largeREindex=0] = '\0';
+            }
+        } else if (RElen + largeREindex + 3 < BUFSIZ-1) {
+            debugs(28, 2, "compileOptimisedREs: adding RE '" << wl->key << "'");
+            if (largeREindex > 0)
+                largeRE[largeREindex++] = '|';
+            largeRE[largeREindex++] = '(';
+            for (char * t = wl->key; *t != '\0'; t++)
+                largeRE[largeREindex++] = *t;
+            largeRE[largeREindex++] = ')';
+            largeRE[largeREindex] = '\0';
+            numREs++;
+        } else {
+            debugs(28, 2, "compileOptimisedREs: buffer full, generating new optimised RE..." );
+            newlistp = compileRE( newlistp, largeRE, flags );
+            if (newlistp == NULL) {
+                aclDestroyRegexList( newlist );
+                return 0;
+            }
+            largeRE[largeREindex=0] = '\0';
+            continue;    /* do the loop again to add the RE to largeRE */
         }
+        wl = wl->next;
+    }
+
+    newlistp = compileRE( newlistp, largeRE, flags );
+    if (newlistp == NULL) {
+        aclDestroyRegexList( newlist );
+        return 0;
+    }
+
+    /* all was successful, so put the new list at the tail */
+    if (*curlist == NULL) {
+        *curlist = newlist;
+    } else {
+        for (Tail = curlist; *Tail != NULL; Tail = &((*Tail)->next))
+            ;
+        (*Tail) = newlist;
+    }
+
+    debugs(28, 2, "compileOptimisedREs: " << numREs << " REs are optimised into one RE.");
+    if (numREs > 100) {
+        debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, (opt_parse_cfg_only?DBG_IMPORTANT:2), "WARNING: there are more than 100 regular expressions. " <<
+               "Consider using less REs or use rules without expressions like 'dstdomain'.");
+    }
+
+    return 1;
+}
 
-        if (strcmp(t, "+i") == 0) {
+static void
+compileUnoptimisedREs(relist **curlist, wordlist * wl)
+{
+    relist **Tail;
+    relist **newTail;
+    int flags = REG_EXTENDED | REG_NOSUB;
+
+    for (Tail = curlist; *Tail != NULL; Tail = &((*Tail)->next))
+        ;
+
+    while (wl != NULL) {
+        if (strcmp(wl->key, "-i") == 0) {
+            flags |= REG_ICASE;
+        } else if (strcmp(wl->key, "+i") == 0) {
             flags &= ~REG_ICASE;
-            continue;
+        } else {
+            newTail = compileRE( Tail, wl->key , flags );
+            if (newTail == NULL)
+                debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Compile failed: '" << wl->key << "'");
+            else
+                Tail = newTail;
         }
+        wl = wl->next;
+    }
+}
+
+static void
+aclParseRegexList(relist **curlist)
+{
+    char *t;
+    wordlist *wl = NULL;
 
-        if ((errcode = regcomp(&comp, t, flags)) != 0) {
-            char errbuf[256];
-            regerror(errcode, &comp, errbuf, sizeof errbuf);
-            debugs(28, 0, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
-            debugs(28, 0, "aclParseRegexList: Invalid regular expression '" << t << "': " << errbuf);
-            continue;
+    debugs(28, 2, HERE << "aclParseRegexList: new Regex line or file");
+
+    while ((t = ConfigParser::strtokFile()) != NULL) {
+        const char *clean = removeUnnecessaryWildcards(t);
+        if (strlen(clean) > BUFSIZ-1) {
+            debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+            debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. Larger than " << BUFSIZ-1 << " characters: '" << clean << "'");
+        } else {
+            debugs(28, 3, "aclParseRegexList: buffering RE '" << clean << "'");
+            wordlistAdd(&wl, clean);
         }
+    }
 
-        q = (relist *)memAllocate(MEM_RELIST);
-        q->flags = flags;
-        q->pattern = xstrdup(t);
-        q->regex = comp;
-        *(Tail) = q;
-        Tail = &q->next;
+    if (!compileOptimisedREs(curlist, wl)) {
+        debugs(28, DBG_IMPORTANT, "WARNING: optimisation of regular expressions failed; using fallback method without optimisation");
+        compileUnoptimisedREs(curlist, wl);
     }
+
+    wordlistDestroy(&wl);
 }
 
 void
@@ -144,7 +144,7 @@ Adaptation::AccessCheck::AccessCheckCallbackWrapper(allow_t answer, void *data)
     debugs(93, 8, HERE << "callback answer=" << answer);
     AccessCheck *ac = (AccessCheck*)data;
 
-    /** \todo AYJ 2008-06-12: If answer == ACCESS_REQ_PROXY_AUTH
+    /** \todo AYJ 2008-06-12: If answer == ACCESS_AUTH_REQUIRED
      * we should be kicking off an authentication before continuing
      * with this request. see bug 2400 for details.
      */
@@ -6,10 +6,14 @@
 #include "auth/AclProxyAuth.h"
 #include "HttpRequest.h"
 
-/** retval -1 user not authenticated (authentication error?)
-    retval  0 user not authorized OR user authentication is in pgrogress
-    retval +1 user authenticated and authorized */
-int
+/**
+ * \retval ACCESS_AUTH_REQUIRED credentials missing. challenge required.
+ * \retval ACCESS_DENIED        user not authenticated (authentication error?)
+ * \retval ACCESS_DUNNO         user authentication is in progress
+ * \retval ACCESS_DENIED        user not authorized
+ * \retval ACCESS_ALLOWED       user authenticated and authorized
+ */
+allow_t
 AuthenticateAcl(ACLChecklist *ch)
 {
     ACLFilledChecklist *checklist = Filled(ch);
@@ -18,13 +22,13 @@ AuthenticateAcl(ACLChecklist *ch)
 
     if (NULL == request) {
         fatal ("requiresRequest SHOULD have been true for this ACL!!");
-        return 0;
+        return ACCESS_DENIED;
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
     } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
-        debugs(28, DBG_IMPORTANT, HERE << " authentication not applicable on intercepted requests.");
-        return -1;
+        debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
+        return ACCESS_DENIED;
     } else {
         /* Proxy authorization on proxy requests */
         headertype = HDR_PROXY_AUTHORIZATION;
@@ -38,25 +42,25 @@ AuthenticateAcl(ACLChecklist *ch)
     switch (result) {
 
     case AUTH_ACL_CANNOT_AUTHENTICATE:
-        debugs(28, 4, HERE << "returning  0 user authenticated but not authorised.");
-        return 0;
+        debugs(28, 4, HERE << "returning " << ACCESS_DENIED << " user authenticated but not authorised.");
+        return ACCESS_DENIED;
 
     case AUTH_AUTHENTICATED:
-        return 1;
+        return ACCESS_ALLOWED;
         break;
 
     case AUTH_ACL_HELPER:
-        debugs(28, 4, HERE << "returning 0 sending credentials to helper.");
+        debugs(28, 4, HERE << "returning " << ACCESS_DENIED << " sending credentials to helper.");
         checklist->changeState(ProxyAuthLookup::Instance());
-        return 0;
+        return ACCESS_DUNNO; // XXX: break this down into DUNNO, EXPIRED_OK, EXPIRED_BAD states
 
     case AUTH_ACL_CHALLENGE:
-        debugs(28, 4, HERE << "returning 0 sending authentication challenge.");
-        checklist->changeState (ProxyAuthNeeded::Instance());
-        return 0;
+        debugs(28, 4, HERE << "returning " << ACCESS_DENIED << " sending authentication challenge.");
+        checklist->changeState(ProxyAuthNeeded::Instance());
+        return ACCESS_AUTH_REQUIRED;
 
     default:
         fatal("unexpected authenticateAuthenticate reply\n");
-        return 0;
+        return ACCESS_DENIED;
     }
 }
@@ -3,13 +3,15 @@
 
 #if USE_AUTH
 
+#include "acl/Acl.h"
+
 // ACL-related code used by authentication-related code. This code is not in
 // auth/Gadgets to avoid making auth/libauth dependent on acl/libstate because
 // acl/libstate already depends on auth/libauth.
 
 class ACLChecklist;
 /// \ingroup AuthAPI
-extern int AuthenticateAcl(ACLChecklist *ch);
+extern allow_t AuthenticateAcl(ACLChecklist *ch);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_ACL_H */
@@ -150,16 +150,28 @@ int
 ACLMaxUserIP::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
+    allow_t answer = AuthenticateAcl(checklist);
+    checklist->currentAnswer(answer);
     int ti;
 
-    if ((ti = AuthenticateAcl(checklist)) != 1)
+    // convert to tri-state ACL match 1,0,-1
+    switch (answer) {
+    case ACCESS_ALLOWED:
+    case ACCESS_AUTH_EXPIRED_OK:
+        // check for a match
+        ti = match(checklist->auth_user_request, checklist->src_addr);
+        checklist->auth_user_request = NULL;
         return ti;
 
-    ti = match(checklist->auth_user_request, checklist->src_addr);
+    case ACCESS_DENIED:
+    case ACCESS_AUTH_EXPIRED_BAD:
+        return 0; // non-match
 
-    checklist->auth_user_request = NULL;
-
-    return ti;
+    case ACCESS_DUNNO:
+    case ACCESS_AUTH_REQUIRED:
+    default:
+        return -1; // other
+    }
 }
 
 wordlist *
@@ -79,14 +79,25 @@ ACLProxyAuth::parse()
 int
 ACLProxyAuth::match(ACLChecklist *checklist)
 {
-    int ti;
-
-    if ((ti = AuthenticateAcl(checklist)) != 1)
-        return ti;
-
-    ti = matchProxyAuth(checklist);
-
-    return ti;
+    allow_t answer = AuthenticateAcl(checklist);
+    checklist->currentAnswer(answer);
+
+    // convert to tri-state ACL match 1,0,-1
+    switch (answer) {
+    case ACCESS_ALLOWED:
+    case ACCESS_AUTH_EXPIRED_OK:
+        // check for a match
+        return matchProxyAuth(checklist);
+
+    case ACCESS_DENIED:
+    case ACCESS_AUTH_EXPIRED_BAD:
+        return 0; // non-match
+
+    case ACCESS_DUNNO:
+    case ACCESS_AUTH_REQUIRED:
+    default:
+        return -1; // other
+    }
 }
 
 wordlist *
@@ -181,7 +192,7 @@ ProxyAuthNeeded::checkForAsync(ACLChecklist *checklist) const
      * The request is denied.
      */
     debugs(28, 6, "ACLChecklist::checkForAsync: requiring Proxy Auth header.");
-    checklist->currentAnswer(ACCESS_REQ_PROXY_AUTH);
+    checklist->currentAnswer(ACCESS_AUTH_REQUIRED);
     checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markFinished();
 }
@@ -193,21 +193,15 @@ CacheManager::ParseUrl(const char *url)
     int len = strlen(url);
     Must(len > 0);
     t = sscanf(url, "cache_object://%[^/]/%[^@?]%n@%[^?]?%s", host, request, &pos, password, params);
+    if (t < 3) {
+        t = sscanf(url, "cache_object://%[^/]/%[^?]%n?%s", host, request, &pos, params);
+    }
     if (t < 1) {
         t = sscanf(url, "http://%[^/]/squid-internal-mgr/%[^?]%n?%s", host, request, &pos, params);
     }
     if (t < 1) {
         t = sscanf(url, "https://%[^/]/squid-internal-mgr/%[^?]%n?%s", host, request, &pos, params);
     }
-    debugs(16, 3, HERE << "HTTPS: t=" << t << ", host='" << host << "', request='" << request << "', pos=" << pos <<
-           ", password='" << password << "', params='" << params << "'");
-
-    if (pos >0 && url[pos] == '?') {
-        ++pos;
-        if (pos < len)
-            xstrncpy(params, url + pos, sizeof(params));
-    }
-
     if (t < 2)
         xstrncpy(request, "menu", MAX_URL);
 
@@ -221,6 +215,9 @@ CacheManager::ParseUrl(const char *url)
     }
 #endif
 
+    debugs(16, 3, HERE << "MGR request: t=" << t << ", host='" << host << "', request='" << request << "', pos=" << pos <<
+           ", password='" << password << "', params='" << params << "'");
+
     Mgr::ActionProfile::Pointer profile = findAction(request);
     if (!profile) {
         debugs(16, DBG_IMPORTANT, "CacheManager::ParseUrl: action '" << request << "' not found");
@@ -632,6 +632,10 @@ NAME: acl
 TYPE: acl
 LOC: Config.aclList
 DEFAULT: all src all
+DEFAULT: manager url_regex -i ^cache_object:// +i ^https?://[^/]+/squid-internal-mgr/
+DEFAULT: localhost src 127.0.0.1/32 ::1
+DEFAULT: to_localhost dst 127.0.0.0/8 0.0.0.0/32 ::1
+DEFAULT_DOC: ACLs all, manager, localhost, and to_localhost are predefined.
 DOC_START
 	Defining an Access List
 
@@ -862,9 +866,6 @@ NOCOMMENT_START
 #
 # Recommended minimum configuration:
 #
-acl manager url_regex -i ^cache_object:// +i ^https?://[^/]+/squid-internal-mgr/
-acl localhost src 127.0.0.1/32 ::1
-acl to_localhost dst 127.0.0.0/8 0.0.0.0/32 ::1
 
 # Example rule allowing access from your local networks.
 # Adapt to list your (internal) IP networks from where browsing
@@ -1163,7 +1164,7 @@ DOC_END
 NAME: miss_access
 TYPE: acl_access
 LOC: Config.accessList.miss
-DEFAULT: allow all
+DEFAULT: none
 DOC_START
 	Use to force your neighbors to use you as a sibling instead of
 	a parent.  For example:
@@ -2912,10 +2913,13 @@ DOC_START
 		>a	Client source IP address
 		>A	Client FQDN
 		>p	Client source port
-		>eui	Client EUI (MAC address, EUI-48 or EUI-64 identifier)
-		<A	Server IP address or peer name
-		la	Local IP address (http_port)
-		lp	Local port number (http_port)
+		>eui	Client source EUI (MAC address, EUI-48 or EUI-64 identifier)
+		>la	Local IP address the client connected to
+		>lp	Local port number the client connected to
+
+		<a	Server IP address of the last server or peer connection
+		<A	Server FQDN or peer name
+		<p	Server port number of the last server or peer connection
 		<la	Local IP address of the last server or peer connection
 		<lp     Local port number of the last server or peer connection
 
@@ -2930,28 +2934,31 @@ DOC_START
 		tr	Response time (milliseconds)
 		dt	Total time spent making DNS lookups (milliseconds)
 
-	HTTP cache related format codes:
+	Access Control related format codes:
+
+		et	Tag returned by external acl
+		ea	Log string returned by external acl
+		un	User name (any available)
+		ul	User name from authentication
+		ue	User name from external acl helper
+		ui	User name from ident
+		us	User name from SSL
+
+	HTTP related format codes:
 
 		[http::]>h	Original request header. Optional header name argument
 				on the format header[:[separator]element]
 		[http::]>ha	The HTTP request headers after adaptation and redirection. 
 				Optional header name argument as for >h
 		[http::]<h	Reply header. Optional header name argument
 				as for >h
-		[http::]un	User name
-		[http::]ul	User name from authentication
-		[http::]ui	User name from ident
-		[http::]us	User name from SSL
-		[http::]ue	User name from external acl helper
 		[http::]>Hs	HTTP status code sent to the client
 		[http::]<Hs	HTTP status code received from the next hop
 		[http::]<bs	Number of HTTP-equivalent message body bytes 
 				received from the next hop, excluding chunked
 				transfer encoding and control messages.
 				Generated FTP/Gopher listings are treated as
 				received bodies.
-		[http::]Ss	Squid request status (TCP_MISS etc)
-		[http::]Sh	Squid hierarchy status (DEFAULT_PARENT etc)
 		[http::]mt	MIME content type
 		[http::]rm	Request method (GET/POST etc)
 		[http::]>rm	Request method from client
@@ -2965,8 +2972,6 @@ DOC_START
 		[http::]rv	Request protocol version
 		[http::]>rv	Request protocol version from client
 		[http::]<rv	Request protocol version sent to server or peer
-		[http::]et	Tag returned by external acl
-		[http::]ea	Log string returned by external acl
 		[http::]<st	Sent reply size including HTTP headers
 		[http::]>st	Received request size including HTTP headers. In the
 				case of chunked requests the chunked encoding metadata
@@ -2984,6 +2989,11 @@ DOC_START
 				sent to the first selected peer. The timer stops
 				with the last I/O with the last peer.
 
+	Squid handling related format codes:
+
+		Ss	Squid request status (TCP_MISS etc)
+		Sh	Squid hierarchy status (DEFAULT_PARENT etc)
+
 	If ICAP is enabled, the following code becomes available (as
 	well as ICAP log codes documented with the icap_log option):
 
@@ -3024,18 +3034,19 @@ DOC_START
 
 	The default formats available (which do not need re-defining) are:
 
-logformat squid      %ts.%03tu %6tr %>a %Ss/%03>Hs %<st %rm %ru %un %Sh/%<A %mt
+logformat squid      %ts.%03tu %6tr %>a %Ss/%03>Hs %<st %rm %ru %un %Sh/%<a %mt
 logformat common     %>a %ui %un [%tl] "%rm %ru HTTP/%rv" %>Hs %<st %Ss:%Sh
 logformat combined   %>a %ui %un [%tl] "%rm %ru HTTP/%rv" %>Hs %<st "%{Referer}>h" "%{User-Agent}>h" %Ss:%Sh
 logformat referrer   %ts.%03tu %>a %{Referer}>h %ru
 logformat useragent  %>a [%tl] "%{User-Agent}>h"
 
-	When the log_mime_hdrs directive is set to ON. The squid, common and combined
-	formats have a safely encoded copy of the mime headers appended to each line
-	within a pair of brackets.
+	NOTE: When the log_mime_hdrs directive is set to ON.
+		The squid, common and combined formats have a safely encoded copy
+		of the mime headers appended to each line within a pair of brackets.
+
+	NOTE: The common and combined formats are not quite true to the Apache definition.
+		The logs from Squid contain an extra status and hierarchy code appended.
 
-	The common and combined formats are not quite true to the Apache definition.
-	The logs from Squid contain an extra status and hierarchy code appended.
 DOC_END
 
 NAME: access_log cache_access_log
@@ -3302,14 +3313,9 @@ DOC_START
 DOC_END
 
 NAME: log_ip_on_direct
-COMMENT: on|off
-TYPE: onoff
-DEFAULT: on
-LOC: Config.onoff.log_ip_on_direct
+TYPE: obsolete
 DOC_START
-	Log the destination IP address in the hierarchy log tag when going
-	direct. Earlier Squid versions logged the hostname here. If you
-	prefer the old way set this to off.
+	Remove this option from your config. To log server or peer names use %<A in the log format.
 DOC_END
 
 NAME: mime_table
@@ -1,6 +1,8 @@
 /*
  * DEBUG: none          Generate squid.conf.default and cf_parser.cci
  * AUTHOR: Max Okumoto
+ * AUTHOR: Francesco Chemolli
+ * AUTHOR: Amos Jeffries
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -45,22 +47,25 @@
  *			 administrator.
  *****************************************************************************/
 
-#include "config.h"
-#include "util.h"
-
-#if HAVE_STRING_H
-#include <string.h>
-#endif
-#if HAVE_STRING_H
-#include <ctype.h>
+/*
+ * hack around a bug in intel's c++ compiler's libraries which do not
+ * correctly support 64-bit iostreams
+ */
+#if defined(__INTEL_COMPILER) && defined(_FILE_OFFSET_BITS) && \
+_FILE_OFFSET_BITS==64
+#undef _FILE_OFFSET_BITS
 #endif
 
-#include "cf_gen_defines.cci"
+#include <cassert>
+#include <cctype>
+#include <cerrno>
+#include <cstdlib>
+#include <cstring>
+#include <fstream>
+#include <iostream>
+#include <list>
 
-/* libmisc pulls in dependency on time.cc via new() / mem
- * but for cross-compilers we cannot link to the available time.o
- */
-#include "time.cc"
+#include "cf_gen_defines.cci"
 
 #define MAX_LINE	1024	/* longest configuration line */
 #define _PATH_PARSER		"cf_parser.cci"
@@ -76,125 +81,123 @@ enum State {
     sEXIT
 };
 
-typedef struct Line {
-    char *data;
-
-    struct Line *next;
-} Line;
-
-typedef struct EntryAlias {
-
-    struct EntryAlias *next;
-    char *name;
-} EntryAlias;
-
-typedef struct Entry {
-    char *name;
-    EntryAlias *alias;
-    char *type;
-    char *loc;
-    char *default_value;
-    Line *default_if_none;
-    char *comment;
-    char *ifdef;
-    Line *doc;
-    Line *nocomment;
-    int array_flag;
+typedef std::list<std::string> LineList;
+typedef std::list<std::string> TypeDepList;
+typedef std::list<std::string> EntryAliasList;
 
-    struct Entry *next;
-} Entry;
+class DefaultValues
+{
+public:
+    DefaultValues() : preset(), if_none(), docs() {}
+    ~DefaultValues() {}
 
-typedef struct TypeDep {
-    char *name;
+    /// Default config lines to be defined before parsing the config files.
+    LineList preset;
 
-    TypeDep *next;
-} TypeDep;
+    /// Default config lines to parse if the directive has no prior settings.
+    /// This is mutually exclusive with preset values.
+    /// An error will be printed during build if they clash.
+    LineList if_none;
 
-typedef struct Type {
-    char *name;
-    TypeDep *depend;
+    /// Text description to use in documentation for the default.
+    /// If unset the preset or if-none values will be displayed.
+    LineList docs;
+};
 
-    struct Type *next;
-} Type;
+class Entry
+{
+public:
+    Entry(const char *str) :
+            name(str), alias(),type(), loc(),
+            defaults(), comment(), ifdef(), doc(), nocomment(),
+            array_flag(0) {}
+    ~Entry() {}
+
+    std::string name;
+    EntryAliasList alias;
+    std::string type;
+    std::string loc;
+    DefaultValues defaults;
+    std::string comment;
+    std::string ifdef;
+    LineList doc;
+    LineList nocomment;
+    int array_flag;
 
-static const char WS[] = " \t\n";
-static int gen_default(Entry *, FILE *);
-static void gen_parse(Entry *, FILE *);
-static void gen_parse_entry(Entry *entry, FILE *fp);
-static void gen_parse_alias(char *, EntryAlias *, Entry *, FILE *);
-static void gen_dump(Entry *, FILE *);
-static void gen_free(Entry *, FILE *);
-static void gen_conf(Entry *, FILE *, bool verbose_output);
-static void gen_default_if_none(Entry *, FILE *);
+    void genParse(std::ostream &fout) const;
 
+private:
+    void genParseAlias(const std::string &, std::ostream &) const;
+};
 
-static void
-lineAdd(Line ** L, const char *str)
+typedef std::list<class Entry> EntryList;
+
+class Type
 {
-    while (*L)
-        L = &(*L)->next;
+public:
+    Type(const char *str) : name(str) {}
+    ~Type() {}
 
-    *L = (Line *)xcalloc(1, sizeof(Line));
+    std::string name;
+    TypeDepList depend;
+};
 
-    (*L)->data = xstrdup(str);
-}
+typedef std::list<class Type> TypeList;
+
+static const char WS[] = " \t\n";
+static int gen_default(const EntryList &, std::ostream &);
+static void gen_parse(const EntryList &, std::ostream &);
+static void gen_dump(const EntryList &, std::ostream&);
+static void gen_free(const EntryList &, std::ostream&);
+static void gen_conf(const EntryList &, std::ostream&, bool verbose_output);
+static void gen_default_if_none(const EntryList &, std::ostream&);
 
 static void
-checkDepend(const char *directive, const char *name, const Type *types, const Entry *entries)
+checkDepend(const std::string &directive, const char *name, const TypeList &types, const EntryList &entries)
 {
-    const Type *type;
-    for (type = types; type; type = type->next) {
-        const TypeDep *dep;
-        if (strcmp(type->name, name) != 0)
+    for (TypeList::const_iterator t = types.begin(); t != types.end(); ++t) {
+        if (t->name.compare(name) != 0)
             continue;
-        for (dep = type->depend; dep; dep = dep->next) {
-            const Entry *entry;
-            for (entry = entries; entry; entry = entry->next) {
-                if (strcmp(entry->name, dep->name) == 0)
+        for (TypeDepList::const_iterator dep = t->depend.begin(); dep != t->depend.end(); ++dep) {
+            EntryList::const_iterator entry = entries.begin();
+            for (; entry != entries.end(); ++entry) {
+                if (entry->name.compare(*dep) == 0)
                     break;
             }
-            if (!entry) {
-                fprintf(stderr, "ERROR: '%s' (%s) depends on '%s'\n", directive, name, dep->name);
+            if (entry == entries.end()) {
+                std::cerr << "ERROR: '" << directive << "' (" << name << ") depends on '" << *dep << "'\n";
                 exit(1);
             }
         }
         return;
     }
-    fprintf(stderr, "ERROR: Dependencies for cf.data type '%s' used in '%s' not defined\n", name, directive);
+    std::cerr << "ERROR: Dependencies for cf.data type '" << name << "' used in ' " << directive << "' not defined\n" ;
     exit(1);
 }
 
 static void
 usage(const char *program_name)
 {
-    fprintf(stderr, "Usage: %s cf.data cf.data.depend\n", program_name);
+    std::cerr << "Usage: " << program_name << " cf.data cf.data.depend\n";
     exit(1);
 }
 
 int
 main(int argc, char *argv[])
 {
-    FILE *fp;
     char *input_filename;
     const char *output_filename = _PATH_PARSER;
     const char *conf_filename = _PATH_SQUID_CONF;
     const char *conf_filename_short = _PATH_SQUID_CONF_SHORT;
     const char *type_depend;
     int linenum = 0;
-    Entry *entries = NULL;
-    Entry *curr = NULL;
-    Type *types = NULL;
+    EntryList entries;
+    TypeList types;
     enum State state;
     int rc = 0;
     char *ptr = NULL;
-#if _SQUID_OS2_
-
-    const char *rmode = "rt";
-#else
-
-    const char *rmode = "r";
-#endif
     char buff[MAX_LINE];
+    std::ifstream fp;
 
     if (argc != 3)
         usage(argv[0]);
@@ -205,53 +208,45 @@ main(int argc, char *argv[])
     /*-------------------------------------------------------------------*
      * Parse type dependencies
      *-------------------------------------------------------------------*/
-    if ((fp = fopen(type_depend, rmode)) == NULL) {
-        perror(input_filename);
+    fp.open(type_depend, std::ifstream::in);
+    if (fp.fail()) {
+        std::cerr << "error while opening type dependencies file '" <<
+                  type_depend << "': " << strerror(errno) << std::endl;
         exit(1);
     }
 
-    while ((NULL != fgets(buff, MAX_LINE, fp))) {
+    while (fp.good()) {
+        fp.getline(buff,MAX_LINE);
         const char *type = strtok(buff, WS);
         const char *dep;
         if (!type || type[0] == '#')
             continue;
-        Type *t = (Type *)xcalloc(1, sizeof(*t));
-        t->name = xstrdup(type);
+        Type t(type);
         while ((dep = strtok(NULL, WS)) != NULL) {
-            TypeDep *d = (TypeDep *)xcalloc(1, sizeof(*d));
-            d->name = xstrdup(dep);
-            d->next = t->depend;
-            t->depend = d;
+            t.depend.push_front(dep);
         }
-        t->next = types;
-        types = t;
+        types.push_front(t);
     }
-    fclose(fp);
+    fp.close();
+    fp.clear(); // BSD does not reset flags in close().
 
     /*-------------------------------------------------------------------*
      * Parse input file
      *-------------------------------------------------------------------*/
 
     /* Open input file */
-
-    if ((fp = fopen(input_filename, rmode)) == NULL) {
-        perror(input_filename);
+    fp.open(input_filename, std::ifstream::in);
+    if (fp.fail()) {
+        std::cerr << "error while opening input file '" <<
+                  input_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
 
-#if _SQUID_WINDOWS_
-    setmode(fileno(fp), O_TEXT);
-
-#endif
-
     state = sSTART;
 
-    while (feof(fp) == 0 && state != sEXIT) {
+    while (fp.getline(buff,MAX_LINE), fp.good() && state != sEXIT) {
         char *t;
 
-        if (NULL == fgets(buff, MAX_LINE, fp))
-            break;
-
         linenum++;
 
         if ((t = strchr(buff, '\n')))
@@ -268,187 +263,136 @@ main(int argc, char *argv[])
                 char *name, *aliasname;
 
                 if ((name = strtok(buff + 5, WS)) == NULL) {
-                    printf("Error in input file\n");
+                    std::cerr << "Error in input file\n";
                     exit(1);
                 }
 
-                curr = (Entry *)xcalloc(1, sizeof(Entry));
-                curr->name = xstrdup(name);
+                entries.push_back(name);
 
-                while ((aliasname = strtok(NULL, WS)) != NULL) {
-                    EntryAlias *alias = (EntryAlias *)xcalloc(1, sizeof(EntryAlias));
-                    alias->next = curr->alias;
-                    alias->name = xstrdup(aliasname);
-                    curr->alias = alias;
-                }
+                while ((aliasname = strtok(NULL, WS)) != NULL)
+                    entries.back().alias.push_front(aliasname);
 
                 state = s1;
             } else if (!strcmp(buff, "EOF")) {
                 state = sEXIT;
             } else if (!strcmp(buff, "COMMENT_START")) {
-                curr = (Entry *)xcalloc(1, sizeof(Entry));
-                curr->name = xstrdup("comment");
-                curr->loc = xstrdup("none");
+                entries.push_back("comment");
+                entries.back().loc = "none";
                 state = sDOC;
             } else {
-                printf("Error on line %d\n", linenum);
-                printf("--> %s\n", buff);
+                std::cerr << "Error on line " << linenum << std::endl <<
+                          "--> " << buff << std::endl;
                 exit(1);
             }
 
             break;
 
-        case s1:
+        case s1: {
+            Entry &curr = entries.back();
 
             if ((strlen(buff) == 0) || (!strncmp(buff, "#", 1))) {
                 /* ignore empty and comment lines */
                 (void) 0;
             } else if (!strncmp(buff, "COMMENT:", 8)) {
                 ptr = buff + 8;
 
-                while (xisspace(*ptr))
+                while (isspace((unsigned char)*ptr))
                     ptr++;
 
-                curr->comment = xstrdup(ptr);
+                curr.comment = ptr;
             } else if (!strncmp(buff, "DEFAULT:", 8)) {
                 ptr = buff + 8;
 
-                while (xisspace(*ptr))
+                while (isspace((unsigned char)*ptr))
                     ptr++;
 
-                curr->default_value = xstrdup(ptr);
+                curr.defaults.preset.push_back(ptr);
             } else if (!strncmp(buff, "DEFAULT_IF_NONE:", 16)) {
                 ptr = buff + 16;
 
-                while (xisspace(*ptr))
+                while (isspace((unsigned char)*ptr))
+                    ptr++;
+
+                curr.defaults.if_none.push_back(ptr);
+            } else if (!strncmp(buff, "DEFAULT_DOC:", 12)) {
+                ptr = buff + 12;
+
+                while (isspace((unsigned char)*ptr))
                     ptr++;
 
-                lineAdd(&curr->default_if_none, ptr);
+                curr.defaults.docs.push_back(ptr);
             } else if (!strncmp(buff, "LOC:", 4)) {
                 if ((ptr = strtok(buff + 4, WS)) == NULL) {
-                    printf("Error on line %d\n", linenum);
+                    std::cerr << "Error on line " << linenum << std::endl;
                     exit(1);
                 }
 
-                curr->loc = xstrdup(ptr);
+                curr.loc = ptr;
             } else if (!strncmp(buff, "TYPE:", 5)) {
                 if ((ptr = strtok(buff + 5, WS)) == NULL) {
-                    printf("Error on line %d\n", linenum);
+                    std::cerr << "Error on line " << linenum << std::endl;
                     exit(1);
                 }
 
                 /* hack to support arrays, rather than pointers */
                 if (0 == strcmp(ptr + strlen(ptr) - 2, "[]")) {
-                    curr->array_flag = 1;
+                    curr.array_flag = 1;
                     *(ptr + strlen(ptr) - 2) = '\0';
                 }
 
-                checkDepend(curr->name, ptr, types, entries);
-                curr->type = xstrdup(ptr);
+                checkDepend(curr.name, ptr, types, entries);
+                curr.type = ptr;
             } else if (!strncmp(buff, "IFDEF:", 6)) {
                 if ((ptr = strtok(buff + 6, WS)) == NULL) {
-                    printf("Error on line %d\n", linenum);
+                    std::cerr << "Error on line " << linenum << std::endl;
                     exit(1);
                 }
 
-                curr->ifdef = xstrdup(ptr);
+                curr.ifdef = ptr;
             } else if (!strcmp(buff, "DOC_START")) {
                 state = sDOC;
             } else if (!strcmp(buff, "DOC_NONE")) {
-                /* add to list of entries */
-                curr->next = entries;
-                entries = curr;
                 state = sSTART;
             } else {
-                printf("Error on line %d\n", linenum);
+                std::cerr << "Error on line " << linenum << std::endl;
                 exit(1);
             }
-
-            break;
+        }
+        break;
 
         case sDOC:
-
             if (!strcmp(buff, "DOC_END") || !strcmp(buff, "COMMENT_END")) {
-                Line *head = NULL;
-                Line *line = curr->doc;
-                /* reverse order of doc lines */
-
-                while (line != NULL) {
-                    Line *tmp;
-                    tmp = line->next;
-                    line->next = head;
-                    head = line;
-                    line = tmp;
-                }
-
-                curr->doc = head;
-                /* add to list of entries */
-                curr->next = entries;
-                entries = curr;
                 state = sSTART;
             } else if (!strcmp(buff, "NOCOMMENT_START")) {
                 state = sNOCOMMENT;
-            } else {
-                Line *line = (Line *)xcalloc(1, sizeof(Line));
-                line->data = xstrdup(buff);
-                line->next = curr->doc;
-                curr->doc = line;
+            } else { // if (buff != NULL) {
+                assert(buff != NULL);
+                entries.back().doc.push_back(buff);
             }
-
             break;
 
         case sNOCOMMENT:
-
             if (!strcmp(buff, "NOCOMMENT_END")) {
-                Line *head = NULL;
-                Line *line = curr->nocomment;
-                /* reverse order of lines */
-
-                while (line != NULL) {
-                    Line *tmp;
-                    tmp = line->next;
-                    line->next = head;
-                    head = line;
-                    line = tmp;
-                }
-
-                curr->nocomment = head;
                 state = sDOC;
-            } else {
-                Line *line = (Line *)xcalloc(1, sizeof(Line));
-                line->data = xstrdup(buff);
-                line->next = curr->nocomment;
-                curr->nocomment = line;
+            } else { // if (buff != NULL) {
+                assert(buff != NULL);
+                entries.back().nocomment.push_back(buff);
             }
-
             break;
 
         case sEXIT:
             assert(0);		/* should never get here */
             break;
         }
+
     }
 
     if (state != sEXIT) {
-        printf("Error unexpected EOF\n");
+        std::cerr << "Error: unexpected EOF\n";
         exit(1);
-    } else {
-        /* reverse order of entries */
-        Entry *head = NULL;
-
-        while (entries != NULL) {
-            Entry *tmp;
-
-            tmp = entries->next;
-            entries->next = head;
-            head = entries;
-            entries = tmp;
-        }
-
-        entries = head;
     }
 
-    fclose(fp);
+    fp.close();
 
     /*-------------------------------------------------------------------*
      * Generate default_all()
@@ -460,433 +404,385 @@ main(int argc, char *argv[])
 
     /* Open output x.c file */
 
-    if ((fp = fopen(output_filename, "w")) == NULL) {
-        perror(output_filename);
+    std::ofstream fout(output_filename,std::ostream::out);
+    if (!fout.good()) {
+        std::cerr << "error while opening output .c file '" <<
+                  output_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
 
-#if _SQUID_WINDOWS_
-    setmode(fileno(fp), O_TEXT);
-#endif
-
-    fprintf(fp,
-            "/*\n"
-            " * Generated automatically from %s by %s\n"
-            " *\n"
-            " * Abstract: This file contains routines used to configure the\n"
-            " *           variables in the squid server.\n"
-            " */\n"
-            "\n"
-            "#include \"config.h\"\n"
-            "\n",
-            input_filename, argv[0]
-           );
+    fout <<  "/*\n" <<
+    " * Generated automatically from " << input_filename << " by " <<
+    argv[0] << "\n"
+    " *\n"
+    " * Abstract: This file contains routines used to configure the\n"
+    " *           variables in the squid server.\n"
+    " */\n"
+    "\n";
 
-    rc = gen_default(entries, fp);
+    rc = gen_default(entries, fout);
 
-    gen_default_if_none(entries, fp);
+    gen_default_if_none(entries, fout);
 
-    gen_parse(entries, fp);
+    gen_parse(entries, fout);
 
-    gen_dump(entries, fp);
+    gen_dump(entries, fout);
 
-    gen_free(entries, fp);
+    gen_free(entries, fout);
 
-    fclose(fp);
+    fout.close();
 
     /* Open output x.conf file */
-    if ((fp = fopen(conf_filename, "w")) == NULL) {
-        perror(conf_filename);
+    fout.open(conf_filename,std::ostream::out);
+    if (!fout.good()) {
+        std::cerr << "error while opening output conf file '" <<
+                  output_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
 
-#if _SQUID_WINDOWS_
-    setmode(fileno(fp), O_TEXT);
-#endif
+    gen_conf(entries, fout, 1);
 
-    gen_conf(entries, fp, 1);
+    fout.close();
 
-    fclose(fp);
-
-    if ((fp = fopen(conf_filename_short, "w")) == NULL) {
-        perror(conf_filename_short);
+    fout.open(conf_filename_short,std::ostream::out);
+    if (!fout.good()) {
+        std::cerr << "error while opening output short conf file '" <<
+                  output_filename << "': " << strerror(errno) << std::endl;
         exit(1);
     }
-#if _SQUID_WINDOWS_
-    setmode(fileno(fp), O_TEXT);
-#endif
-    gen_conf(entries, fp, 0);
-    fclose(fp);
+    gen_conf(entries, fout, 0);
+    fout.close();
 
     return (rc);
 }
 
 static int
-gen_default(Entry * head, FILE * fp)
+gen_default(const EntryList &head, std::ostream &fout)
 {
-    Entry *entry;
     int rc = 0;
-    fprintf(fp,
-            "static void\n"
-            "default_line(const char *s)\n"
-            "{\n"
-            "\tLOCAL_ARRAY(char, tmp_line, BUFSIZ);\n"
-            "\txstrncpy(tmp_line, s, BUFSIZ);\n"
-            "\txstrncpy(config_input_line, s, BUFSIZ);\n"
-            "\tconfig_lineno++;\n"
-            "\tparse_line(tmp_line);\n"
-            "}\n"
-           );
-    fprintf(fp,
-            "static void\n"
-            "default_all(void)\n"
-            "{\n"
-            "\tcfg_filename = \"Default Configuration\";\n"
-            "\tconfig_lineno = 0;\n"
-           );
-
-    for (entry = head; entry != NULL; entry = entry->next) {
-        assert(entry->name);
-        assert(entry != entry->next);
-
-        if (!strcmp(entry->name, "comment"))
+    fout << "static void" << std::endl <<
+    "default_line(const char *s)" << std::endl <<
+    "{" << std::endl <<
+    "    LOCAL_ARRAY(char, tmp_line, BUFSIZ);" << std::endl <<
+    "    xstrncpy(tmp_line, s, BUFSIZ);" << std::endl <<
+    "    xstrncpy(config_input_line, s, BUFSIZ);" << std::endl <<
+    "    config_lineno++;" << std::endl <<
+    "    parse_line(tmp_line);" << std::endl <<
+    "}" << std::endl << std::endl;
+    fout << "static void" << std::endl <<
+    "default_all(void)" << std::endl <<
+    "{" << std::endl <<
+    "    cfg_filename = \"Default Configuration\";" << std::endl <<
+    "    config_lineno = 0;" << std::endl;
+
+    for (EntryList::const_iterator entry = head.begin(); entry != head.end(); ++entry) {
+        assert(entry->name.size());
+
+        if (!entry->name.compare("comment"))
             continue;
 
-        if (!strcmp(entry->type, "obsolete"))
+        if (!entry->type.compare("obsolete"))
             continue;
 
-        if (entry->loc == NULL) {
-            fprintf(stderr, "NO LOCATION FOR %s\n", entry->name);
+        if (!entry->loc.size()) {
+            std::cerr << "NO LOCATION FOR " << entry->name << std::endl;
             rc |= 1;
             continue;
         }
 
-        if (entry->default_value == NULL && entry->default_if_none == NULL) {
-            fprintf(stderr, "NO DEFAULT FOR %s\n", entry->name);
+        if (!entry->defaults.preset.size() && entry->defaults.if_none.empty()) {
+            std::cerr << "NO DEFAULT FOR " << entry->name << std::endl;
             rc |= 1;
             continue;
         }
 
-        if (entry->default_value == NULL || strcmp(entry->default_value, "none") == 0) {
-            fprintf(fp, "\t/* No default for %s */\n", entry->name);
+        if (!entry->defaults.preset.size() || entry->defaults.preset.front().compare("none") == 0) {
+            fout << "    // No default for " << entry->name << std::endl;
         } else {
-            if (entry->ifdef)
-                fprintf(fp, "#if %s\n", entry->ifdef);
+            if (entry->ifdef.size())
+                fout << "#if " << entry->ifdef << std::endl;
 
-            fprintf(fp, "\tdefault_line(\"%s %s\");\n",
-                    entry->name,
-                    entry->default_value);
+            for (LineList::const_iterator l = entry->defaults.preset.begin(); l != entry->defaults.preset.end(); ++l) {
+                fout << "    default_line(\"" << entry->name << " " << *l << "\");" << std::endl;
+            }
 
-            if (entry->ifdef)
-                fprintf(fp, "#endif\n");
+            if (entry->ifdef.size())
+                fout << "#endif" << std::endl;
         }
     }
 
-    fprintf(fp, "\tcfg_filename = NULL;\n");
-    fprintf(fp, "}\n\n");
+    fout << "    cfg_filename = NULL;" << std::endl <<
+    "}" << std::endl << std::endl;
     return rc;
 }
 
 static void
-gen_default_if_none(Entry * head, FILE * fp)
+gen_default_if_none(const EntryList &head, std::ostream &fout)
 {
-    Entry *entry;
-    Line *line;
-    fprintf(fp,
-            "static void\n"
-            "defaults_if_none(void)\n"
-            "{\n"
-           );
-
-    for (entry = head; entry != NULL; entry = entry->next) {
-        assert(entry->name);
-
-        if (!entry->loc)
+    fout << "static void" << std::endl <<
+    "defaults_if_none(void)" << std::endl <<
+    "{" << std::endl;
+
+    for (EntryList::const_iterator entry = head.begin(); entry != head.end(); ++entry) {
+        assert(entry->name.size());
+
+        if (!entry->loc.size())
             continue;
 
-        if (entry->default_if_none == NULL)
+        if (entry->defaults.if_none.empty())
             continue;
 
-        if (entry->ifdef)
-            fprintf(fp, "#if %s\n", entry->ifdef);
+        if (!entry->defaults.preset.empty()) {
+            std::cerr << "ERROR: " << entry->name << " has preset defaults. DEFAULT_IF_NONE cannot be true." << std::endl;
+            exit(1);
+        }
 
-        if (entry->default_if_none) {
-            fprintf(fp,
-                    "\tif (check_null_%s(%s)) {\n",
-                    entry->type,
-                    entry->loc);
+        if (entry->ifdef.size())
+            fout << "#if " << entry->ifdef << std::endl;
 
-            for (line = entry->default_if_none; line; line = line->next)
-                fprintf(fp,
-                        "\t\tdefault_line(\"%s %s\");\n",
-                        entry->name,
-                        line->data);
+        fout << "    if (check_null_" << entry->type << "(" << entry->loc << ")) {" << std::endl;
+        for (LineList::const_iterator l = entry->defaults.if_none.begin(); l != entry->defaults.if_none.end(); ++l)
+            fout << "        default_line(\"" << entry->name << " " << *l <<"\");" << std::endl;
+        fout << "    }" << std::endl;
 
-            fprintf(fp, "\t}\n");
-        }
-
-        if (entry->ifdef)
-            fprintf(fp, "#endif\n");
+        if (entry->ifdef.size())
+            fout << "#endif" << std::endl;
     }
 
-    fprintf(fp, "}\n\n");
+    fout << "}" << std::endl << std::endl;
 }
 
 void
-gen_parse_alias(char *name, EntryAlias *alias, Entry *entry, FILE *fp)
+Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
 {
-    fprintf(fp, "\tif (!strcmp(token, \"%s\")) {\n", name);
-
-    if (strcmp(entry->type,"obsolete") == 0) {
-        fprintf(fp, "\t\tdebugs(0, DBG_CRITICAL, \"ERROR: Directive '%s' is obsolete.\");\n", name);
-        for (Line *line = entry->doc; line != NULL; line = line->next) {
+    fout << "    if (!strcmp(token, \"" << aName << "\")) {" << std::endl;
+    fout << "        ";
+    if (type.compare("obsolete") == 0) {
+        fout << "debugs(0, DBG_CRITICAL, \"ERROR: Directive '" << aName << "' is obsolete.\");\n";
+        for (LineList::const_iterator l = doc.begin(); l != doc.end(); ++l) {
             // offset line to strip initial whitespace tab byte
-            fprintf(fp, "\t\tdebugs(0, opt_parse_cfg_only?0:1, \"%s : %s\");\n", name, &line->data[1]);
+            fout << "        debugs(0, opt_parse_cfg_only?0:1, \"" << aName << " : " << &(*l)[1] << "\");" << std::endl;
         }
-        fprintf(fp, "\t\tparse_obsolete(token);\n");
-    } else if (!entry->loc || strcmp(entry->loc, "none") == 0) {
-        fprintf(fp,
-                "\t\tparse_%s();\n",
-                entry->type
-               );
+        fout << "        parse_obsolete(token);";
+    } else if (!loc.size() || loc.compare("none") == 0) {
+        fout << "parse_" << type << "();";
     } else {
-        fprintf(fp,
-                "\t\tparse_%s(&%s%s);\n",
-                entry->type, entry->loc,
-                entry->array_flag ? "[0]" : ""
-               );
+        fout << "parse_" << type << "(&" << loc << (array_flag ? "[0]" : "") << ");";
     }
-
-    fprintf(fp,"\t\treturn 1;\n");
-    fprintf(fp,"\t};\n");
+    fout << std::endl;
+    fout << "        return 1;" << std::endl;
+    fout << "    };" << std::endl;
 }
 
 void
-gen_parse_entry(Entry *entry, FILE *fp)
+Entry::genParse(std::ostream &fout) const
 {
-    if (strcmp(entry->name, "comment") == 0)
+    if (name.compare("comment") == 0)
         return;
 
-    if (entry->ifdef)
-        fprintf(fp, "#if %s\n", entry->ifdef);
-
-    char *name = entry->name;
-
-    EntryAlias *alias = entry->alias;
+    if (ifdef.size())
+        fout << "#if " << ifdef << std::endl;
 
-    bool more;
+    // Once for the current directive name
+    genParseAlias(name, fout);
 
-    do {
-        gen_parse_alias (name, alias,entry, fp);
-        more = false;
-
-        if (alias) {
-            name = alias->name;
-            alias = alias->next;
-            more = true;
-        }
-    } while (more);
+    // All accepted aliases
+    for (EntryAliasList::const_iterator a = alias.begin(); a != alias.end(); ++a) {
+        genParseAlias(*a, fout);
+    }
 
-    if (entry->ifdef)
-        fprintf(fp, "#endif\n");
+    if (ifdef.size())
+        fout << "#endif\n";
 }
 
 static void
-gen_parse(Entry * head, FILE * fp)
+gen_parse(const EntryList &head, std::ostream &fout)
 {
-    fprintf(fp,
-            "static int\n"
-            "parse_line(char *buff)\n"
-            "{\n"
-            "\tchar\t*token;\n"
-            "\tif ((token = strtok(buff, w_space)) == NULL) \n"
-            "\t\treturn 1;\t/* ignore empty lines */\n"
-           );
-
-    for (Entry *entry = head; entry != NULL; entry = entry->next)
-        gen_parse_entry (entry, fp);
-
-    fprintf(fp,
-            "\treturn 0; /* failure */\n"
-            "}\n\n"
-           );
+    fout <<
+    "static int\n"
+    "parse_line(char *buff)\n"
+    "{\n"
+    "\tchar\t*token;\n"
+    "\tif ((token = strtok(buff, w_space)) == NULL) \n"
+    "\t\treturn 1;\t/* ignore empty lines */\n";
+
+    for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e)
+        e->genParse(fout);
+
+    fout << "\treturn 0; /* failure */\n"
+    "}\n\n";
+
 }
 
 static void
-gen_dump(Entry * head, FILE * fp)
+gen_dump(const EntryList &head, std::ostream &fout)
 {
-    Entry *entry;
-    fprintf(fp,
-            "static void\n"
-            "dump_config(StoreEntry *entry)\n"
-            "{\n"
-            "    debugs(5, 4, HERE);\n"
-           );
+    fout <<
+    "static void" << std::endl <<
+    "dump_config(StoreEntry *entry)" << std::endl <<
+    "{" << std::endl <<
+    "    debugs(5, 4, HERE);" << std::endl;
 
-    for (entry = head; entry != NULL; entry = entry->next) {
+    for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e) {
 
-        if (!entry->loc || strcmp(entry->loc, "none") == 0)
+        if (!e->loc.size() || e->loc.compare("none") == 0)
             continue;
 
-        if (strcmp(entry->name, "comment") == 0)
+        if (e->name.compare("comment") == 0)
             continue;
 
-        if (entry->ifdef)
-            fprintf(fp, "#if %s\n", entry->ifdef);
+        if (e->ifdef.size())
+            fout << "#if " << e->ifdef << std::endl;
 
-        fprintf(fp, "\tdump_%s(entry, \"%s\", %s);\n",
-                entry->type,
-                entry->name,
-                entry->loc);
+        fout << "    dump_" << e->type << "(entry, \"" << e->name << "\", " << e->loc << ");" << std::endl;
 
-        if (entry->ifdef)
-            fprintf(fp, "#endif\n");
+        if (e->ifdef.size())
+            fout << "#endif" << std::endl;
     }
 
-    fprintf(fp, "}\n\n");
+    fout << "}" << std::endl << std::endl;
 }
 
 static void
-gen_free(Entry * head, FILE * fp)
+gen_free(const EntryList &head, std::ostream &fout)
 {
-    Entry *entry;
-    fprintf(fp,
-            "static void\n"
-            "free_all(void)\n"
-            "{\n"
-            "    debugs(5, 4, HERE);\n"
-           );
-
-    for (entry = head; entry != NULL; entry = entry->next) {
-        if (!entry->loc || strcmp(entry->loc, "none") == 0)
+    fout <<
+    "static void" << std::endl <<
+    "free_all(void)" << std::endl <<
+    "{" << std::endl <<
+    "    debugs(5, 4, HERE);" << std::endl;
+
+    for (EntryList::const_iterator e = head.begin(); e != head.end(); ++e) {
+        if (!e->loc.size() || e->loc.compare("none") == 0)
             continue;
 
-        if (strcmp(entry->name, "comment") == 0)
+        if (e->name.compare("comment") == 0)
             continue;
 
-        if (entry->ifdef)
-            fprintf(fp, "#if %s\n", entry->ifdef);
+        if (e->ifdef.size())
+            fout << "#if " << e->ifdef << std::endl;
 
-        fprintf(fp, "\tfree_%s(&%s%s);\n",
-                entry->type, entry->loc,
-                entry->array_flag ? "[0]" : "");
+        fout << "    free_" << e->type << "(&" << e->loc << (e->array_flag ? "[0]" : "") << ");" << std::endl;
 
-        if (entry->ifdef)
-            fprintf(fp, "#endif\n");
+        if (e->ifdef.size())
+            fout << "#endif" << std::endl;
     }
 
-    fprintf(fp, "}\n\n");
+    fout << "}" << std::endl << std::endl;
 }
 
-static int
-defined(char *name)
+static bool
+isDefined(const std::string &name)
 {
-    int i = 0;
-
-    if (!name)
-        return 1;
+    if (!name.size())
+        return true;
 
-    for (i = 0; strcmp(defines[i].name, name) != 0; i++) {
-        assert(defines[i].name);
+    for (int i = 0; defines[i].name; i++) {
+        if (name.compare(defines[i].name) == 0)
+            return defines[i].defined;
     }
 
-    return defines[i].defined;
+    return false;
 }
 
 static const char *
-available_if(char *name)
+available_if(const std::string &name)
 {
-    int i = 0;
-    assert(name);
+    assert(name.size());
 
-    for (i = 0; strcmp(defines[i].name, name) != 0; i++) {
-        assert(defines[i].name);
+    for (int i = 0; defines[i].name; i++) {
+        if (name.compare(defines[i].name) == 0)
+            return defines[i].enable;
     }
 
-    return defines[i].enable;
+    return name.c_str();
 }
 
 static void
-gen_conf(Entry * head, FILE * fp, bool verbose_output)
+gen_conf(const EntryList &head, std::ostream &fout, bool verbose_output)
 {
-    Entry *entry;
-    char buf[8192];
-    Line *def = NULL;
-
-    for (entry = head; entry != NULL; entry = entry->next) {
-        Line *line;
+    for (EntryList::const_iterator entry = head.begin(); entry != head.end(); ++entry) {
+        char buf[8192];
+        LineList def;
         int enabled = 1;
 
-        if (!strcmp(entry->name, "comment"))
+        // Display TAG: line
+        if (!entry->name.compare("comment"))
             (void) 0;
-        else if (!strcmp(entry->name, "obsolete"))
+        else if (!entry->name.compare("obsolete"))
             (void) 0;
         else if (verbose_output) {
-            fprintf(fp, "#  TAG: %s", entry->name);
+            fout << "#  TAG: " << entry->name;
 
-            if (entry->comment)
-                fprintf(fp, "\t%s", entry->comment);
+            if (entry->comment.size())
+                fout << "\t" << entry->comment;
 
-            fprintf(fp, "\n");
+            fout << std::endl;
         }
 
-        if (!defined(entry->ifdef)) {
+        // Display --enable/--disable disclaimer
+        if (!isDefined(entry->ifdef)) {
             if (verbose_output) {
-                fprintf(fp, "# Note: This option is only available if Squid is rebuilt with the\n");
-                fprintf(fp, "#       %s\n#\n", available_if(entry->ifdef));
+                fout << "# Note: This option is only available if Squid is rebuilt with the" << std::endl <<
+                "#       " << available_if(entry->ifdef) << std::endl <<
+                "#" << std::endl;
             }
             enabled = 0;
         }
 
-        if (verbose_output) {
-            for (line = entry->doc; line != NULL; line = line->next) {
-                fprintf(fp, "#%s\n", line->data);
+        // Display DOC_START section
+        if (verbose_output && entry->doc.size()) {
+            for (LineList::const_iterator line = entry->doc.begin(); line != entry->doc.end(); ++line) {
+                fout << "#" << *line << std::endl;
             }
         }
 
-        if (entry->default_value && strcmp(entry->default_value, "none") != 0) {
-            snprintf(buf, sizeof(buf), "%s %s", entry->name, entry->default_value);
-            lineAdd(&def, buf);
-        }
-
-        if (entry->default_if_none) {
-            for (line = entry->default_if_none; line; line = line->next) {
-                snprintf(buf, sizeof(buf), "%s %s", entry->name, line->data);
-                lineAdd(&def, buf);
+        if (entry->defaults.docs.size()) {
+            // Display the DEFAULT_DOC line(s)
+            def = entry->defaults.docs;
+        } else {
+            if (entry->defaults.preset.size() && entry->defaults.preset.front().compare("none") != 0) {
+                // Display DEFAULT: line(s)
+                for (LineList::const_iterator l = entry->defaults.preset.begin(); l != entry->defaults.preset.end(); ++l) {
+                    snprintf(buf, sizeof(buf), "%s %s", entry->name.c_str(), l->c_str());
+                    def.push_back(buf);
+                }
+            } else if (entry->defaults.if_none.size()) {
+                // Display DEFAULT_IF_NONE: line(s)
+                for (LineList::const_iterator l = entry->defaults.if_none.begin(); l != entry->defaults.if_none.end(); ++l) {
+                    snprintf(buf, sizeof(buf), "%s %s", entry->name.c_str(), l->c_str());
+                    def.push_back(buf);
+                }
             }
         }
 
-        if (!def && entry->doc && !entry->nocomment &&
-                strcmp(entry->name, "comment") != 0)
-            lineAdd(&def, "none");
-
-        if (verbose_output && def && (entry->doc || entry->nocomment)) {
-            fprintf(fp, "#Default:\n");
-            while (def != NULL) {
-                line = def;
-                def = line->next;
-                fprintf(fp, "# %s\n", line->data);
-                xfree(line->data);
-                xfree(line);
+        // Display "none" if no default is set or comments to display
+        if (def.empty() && entry->nocomment.empty() && entry->name.compare("comment") != 0)
+            def.push_back("none");
+
+        if (verbose_output && def.size()) {
+            fout << "#Default:\n";
+            while (def.size()) {
+                fout << "# " << def.front() << std::endl;
+                def.pop_front();
             }
+            if (entry->doc.empty() && entry->nocomment.empty())
+                fout << std::endl;
         }
 
-        if (verbose_output && entry->nocomment)
-            fprintf(fp, "#\n");
+        if (verbose_output && entry->nocomment.size())
+            fout << "#" << std::endl;
 
         if (enabled || verbose_output) {
-            for (line = entry->nocomment; line != NULL; line = line->next) {
-                if (!line->data)
-                    continue;
-                if (!enabled && line->data[0] != '#')
-                    fprintf(fp, "#%s\n", line->data);
-                else
-                    fprintf(fp, "%s\n", line->data);
+            for (LineList::const_iterator line = entry->nocomment.begin(); line != entry->nocomment.end(); ++line) {
+                if (!enabled && line->at(0) != '#')
+                    fout << "#";
+                fout << *line << std::endl;
             }
         }
 
-        if (verbose_output && entry->doc != NULL) {
-            fprintf(fp, "\n");
+        if (verbose_output && entry->doc.size()) {
+            fout << std::endl;
         }
     }
 }
@@ -3,7 +3,7 @@ BEGIN {
 	print "/* Generated automatically from cf.data.pre"
 	print " * DO NOT EDIT"
 	print "*/"
-	print "#include \"config.h\""
+	print "#include \"autoconf.h\""
 	print "static struct { const char *name; const char *enable; int defined;} defines[] = {"
 	define["USE_DELAY_POOLS"]="--enable-delay-pools"
 	define["FOLLOW_X_FORWARDED_FOR"]="--enable-follow-x-forwarded-for"
@@ -3607,9 +3607,6 @@ static void
 clientHttpConnectionsOpen(void)
 {
     http_port_list *s = NULL;
-#if USE_SSL
-    int bumpCount = 0; // counts http_ports with sslBump option
-#endif
 
     for (s = Config.Sockaddr.http; s; s = s->next) {
         if (MAXHTTPPORTS == NHttpSockets) {
@@ -3619,21 +3616,20 @@ clientHttpConnectionsOpen(void)
         }
 
 #if USE_SSL
-        if (s->sslBump &&
-                !s->staticSslContext && !s->generateHostCertificates) {
-            debugs(1, 1, "Will not bump SSL at http_port " <<
-                   s->http.s << " due to SSL initialization failure.");
+        if (s->sslBump && !Config.accessList.ssl_bump) {
+            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << s->protocol << "_port " << s->http.s);
+            s->sslBump = 0;
+        }
+
+        if (s->sslBump && !s->staticSslContext && !s->generateHostCertificates) {
+            debugs(1, DBG_IMPORTANT, "Will not bump SSL at http_port " << s->http.s << " due to SSL initialization failure.");
             s->sslBump = 0;
         }
         if (s->sslBump) {
-            ++bumpCount;
             // Create ssl_ctx cache for this port.
             Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
         }
 #endif
-#if USE_SSL_CRTD
-        Ssl::Helper::GetInstance();
-#endif //USE_SSL_CRTD
 
         // Fill out a Comm::Connection which IPC will open as a listener for us
         //  then pass back when active so we can start a TcpAcceptor subscription.
@@ -3652,13 +3648,6 @@ clientHttpConnectionsOpen(void)
 
         HttpSockets[NHttpSockets++] = -1; // set in clientListenerConnectionOpened
     }
-
-#if USE_SSL
-    if (bumpCount && !Config.accessList.ssl_bump)
-        debugs(33, 1, "WARNING: http_port(s) with SslBump found, but no " <<
-               std::endl << "\tssl_bump ACL configured. No requests will be " <<
-               "bumped.");
-#endif
 }
 
 #if USE_SSL
@@ -175,7 +175,7 @@ ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
 {
     start_time = current_time;
     setConn(aConn);
-    clientConnection = aConn->clientConnection;
+    al.tcpClient = clientConnection = aConn->clientConnection;
     dlinkAdd(this, &active, &ClientActiveRequests);
 #if USE_ADAPTATION
     request_satisfaction_mode = false;
@@ -546,13 +546,14 @@ ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLooku
         }
     }
     debugs(85, 3, HERE << "FAIL: validate IP " << clientConn->local << " possible from Host:");
-    hostHeaderVerifyFailed();
+    hostHeaderVerifyFailed("local IP", "any domain IP");
 }
 
 void
-ClientRequestContext::hostHeaderVerifyFailed()
+ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
 {
-    debugs(85, 1, "SECURITY ALERT: Host: header forgery detected from " << http->getConn()->clientConnection);
+    debugs(85, 1, "SECURITY ALERT: Host: header forgery detected from " << http->getConn()->clientConnection <<
+           " (" << A << " does not match " << B << ")");
 
     // IP address validation for Host: failed. reject the connection.
     clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
@@ -618,32 +619,36 @@ ClientRequestContext::hostHeaderVerify()
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
     if (http->request->flags.intercepted || http->request->flags.spoof_client_ip) {
-        // verify the port (if any) matches the apparent destination
+        // verify the Host: port (if any) matches the apparent destination
         if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
-            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() << " matches Host: port " << port << "((" << portStr);
-            hostHeaderVerifyFailed();
-            safe_free(hostB);
-            return;
-        }
-        // XXX: match the scheme default port against the apparent destination
-
-        // verify the destination DNS is one of the Host: headers IPs
-        ipcache_nbgethostbyname(host, hostHeaderIpVerifyWrapper, this);
-        safe_free(hostB);
-        return;
-    }
-    safe_free(hostB);
+            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
+                   " matches Host: port " << port << " (" << portStr << ")");
+            hostHeaderVerifyFailed("intercepted port", portStr);
+        } else {
+            // XXX: match the scheme default port against the apparent destination
 
-    // Verify forward-proxy requested URL domain matches the Host: header
-    host = http->request->header.getStr(HDR_HOST);
-    if (strcmp(host, http->request->GetHost()) != 0) {
+            // verify the destination DNS is one of the Host: headers IPs
+            ipcache_nbgethostbyname(host, hostHeaderIpVerifyWrapper, this);
+        }
+    } else if (strcmp(host, http->request->GetHost()) != 0) {
+        // Verify forward-proxy requested URL domain matches the Host: header
         debugs(85, 3, HERE << "FAIL on validate URL domain " << http->request->GetHost() << " matches Host: " << host);
-        hostHeaderVerifyFailed();
-        return;
+        hostHeaderVerifyFailed(host, http->request->GetHost());
+    } else if (portStr && port != http->request->port) {
+        // Verify forward-proxy requested URL domain matches the Host: header
+        debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: port " << portStr);
+        hostHeaderVerifyFailed("URL port", portStr);
+    } else if (!portStr && http->request->method != METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->protocol)) {
+        // Verify forward-proxy requested URL domain matches the Host: header
+        // Special case: we don't have a default-port to check for CONNECT. Assume URL is correct.
+        debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->protocol));
+        hostHeaderVerifyFailed("URL port", "default port");
+    } else {
+        // Okay no problem.
+        debugs(85, 3, HERE << "validate passed.");
+        http->doCallouts();
     }
-
-    debugs(85, 3, HERE << "validate passed.");
-    http->doCallouts();
+    safe_free(hostB);
 }
 
 /* This is the entry point for external users of the client_side routines */
@@ -726,13 +731,16 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
         proxy_auth_msg = http->request->auth_user_request->denyMessage("<null>");
 #endif
 
-    if (answer != ACCESS_ALLOWED) {
-        /* Send an error */
-        int require_auth = (answer == ACCESS_REQ_PROXY_AUTH || aclIsProxyAuth(AclMatchedName));
+    if (answer != ACCESS_ALLOWED && answer != ACCESS_AUTH_EXPIRED_OK) {
+        // auth has a grace period where credentials can be expired but okay not to challenge.
+
+        /* Send an auth challenge or error */
+        // XXX: do we still need aclIsProxyAuth() ?
+        bool auth_challenge = (answer == ACCESS_AUTH_REQUIRED || answer == ACCESS_AUTH_EXPIRED_BAD || aclIsProxyAuth(AclMatchedName));
         debugs(85, 5, "Access Denied: " << http->uri);
         debugs(85, 5, "AclMatchedName = " << (AclMatchedName ? AclMatchedName : "<null>"));
 #if USE_AUTH
-        if (require_auth)
+        if (auth_challenge)
             debugs(33, 5, "Proxy Auth Message = " << (proxy_auth_msg ? proxy_auth_msg : "<null>"));
 #endif
 
@@ -742,11 +750,11 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
          * the clientCreateStoreEntry() call just below.  Pedro Ribeiro
          * <pribeiro@isel.pt>
          */
-        page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName, answer != ACCESS_REQ_PROXY_AUTH);
+        page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName, answer != ACCESS_AUTH_REQUIRED);
 
         http->logType = LOG_TCP_DENIED;
 
-        if (require_auth) {
+        if (auth_challenge) {
 #if USE_AUTH
             if (!http->flags.accel) {
                 /* Proxy authorisation needed */
@@ -784,12 +792,13 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 #else
                                     NULL);
 #endif
+        http->getConn()->flags.readMore = true; // resume any pipeline reads.
         node = (clientStreamNode *)http->client_stream.tail->data;
         clientStreamRead(node, http, node->readBuffer);
         return;
     }
 
-    /* ACCESS_ALLOWED continues here ... */
+    /* ACCESS_ALLOWED (or auth in grace period ACCESS_AUTH_EXPIRED_OK) continues here ... */
     safe_free(http->uri);
 
     http->uri = xstrdup(urlCanonical(http->request));
@@ -1773,7 +1782,7 @@ ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
 #endif
 
     request->detailError(ERR_ICAP_FAILURE, errDetail);
-
+    c->flags.readMore = true;
     node = (clientStreamNode *)client_stream.tail->data;
     clientStreamRead(node, this, node->readBuffer);
 }
@@ -676,7 +676,7 @@ idnsStats(StoreEntry * sentry)
     }
 
     if (Config.dns.packet_max > 0)
-        storeAppendPrintf(sentry, "DNS jumbo-grams: %Zd Bytes\n", Config.dns.packet_max);
+        storeAppendPrintf(sentry, "DNS jumbo-grams: %zd Bytes\n", Config.dns.packet_max);
     else
         storeAppendPrintf(sentry, "DNS jumbo-grams: not working\n");
 
@@ -744,14 +744,12 @@ ACLExternal::~ACLExternal()
     safe_free (class_);
 }
 
-static int
+static allow_t
 aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 {
-    int result;
-    external_acl_entry *entry;
     const char *key = "";
     debugs(82, 9, HERE << "acl=\"" << acl->def->name << "\"");
-    entry = ch->extacl_entry;
+    external_acl_entry *entry = ch->extacl_entry;
 
     if (entry) {
         if (cbdataReferenceValid(entry) && entry->def == acl->def) {
@@ -775,43 +773,43 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
         debugs(82, 9, HERE << "No helper entry available");
 #if USE_AUTH
         if (acl->def->require_auth) {
-            int ti;
+            int ti = AuthenticateAcl(ch);
             /* Make sure the user is authenticated */
-            debugs(82, 3, "aclMatchExternal: " << acl->def->name << " check user authenticated.");
-            if ((ti = AuthenticateAcl(ch)) != 1) {
-                debugs(82, 2, "aclMatchExternal: " << acl->def->name << " user not authenticated (" << ti << ")");
-                return ti;
+            debugs(82, 3, HERE << acl->def->name << " check user authenticated.");
+            if (ti != 1) {
+                debugs(82, 2, HERE << acl->def->name << " user not authenticated (" << ti << ")");
+                return ACCESS_AUTH_REQUIRED;
             }
-            debugs(82, 3, "aclMatchExternal: " << acl->def->name << " user is authenticated.");
+            debugs(82, 3, HERE << acl->def->name << " user is authenticated.");
         }
 #endif
         key = makeExternalAclKey(ch, acl);
 
         if (!key) {
             /* Not sufficient data to process */
-            return -1;
+            return ACCESS_DUNNO;
         }
 
         entry = static_cast<external_acl_entry *>(hash_lookup(acl->def->cache, key));
 
         if (!entry || external_acl_grace_expired(acl->def, entry)) {
-            debugs(82, 2, "aclMatchExternal: " << acl->def->name << "(\"" << key << "\") = lookup needed");
-            debugs(82, 2, "aclMatchExternal: \"" << key << "\": entry=@" <<
+            debugs(82, 2, HERE << acl->def->name << "(\"" << key << "\") = lookup needed");
+            debugs(82, 2, HERE << "\"" << key << "\": entry=@" <<
                    entry << ", age=" << (entry ? (long int) squid_curtime - entry->date : 0));
 
             if (acl->def->theHelper->stats.queue_size <= (int)acl->def->theHelper->childs.n_active) {
-                debugs(82, 2, "aclMatchExternal: \"" << key << "\": queueing a call.");
+                debugs(82, 2, HERE << "\"" << key << "\": queueing a call.");
                 ch->changeState(ExternalACLLookup::Instance());
-                debugs(82, 2, "aclMatchExternal: \"" << key << "\": return -1.");
-                return -1; // to get here we have to have an expired cache entry. MUST not use.
+                debugs(82, 2, HERE << "\"" << key << "\": return -1.");
+                return ACCESS_DUNNO; // to get here we have to have an expired cache entry. MUST not use.
             } else {
                 if (!entry) {
-                    debugs(82, 1, "aclMatchExternal: '" << acl->def->name <<
+                    debugs(82, DBG_IMPORTANT, "WARNING: external ACL '" << acl->def->name <<
                            "' queue overload. Request rejected '" << key << "'.");
                     external_acl_message = "SYSTEM TOO BUSY, TRY AGAIN LATER";
-                    return -1;
+                    return ACCESS_DUNNO;
                 } else {
-                    debugs(82, 1, "aclMatchExternal: '" << acl->def->name <<
+                    debugs(82, DBG_IMPORTANT, "WARNING: external ACL '" << acl->def->name <<
                            "' queue overload. Using stale result. '" << key << "'.");
                     /* Fall thru to processing below */
                 }
@@ -820,10 +818,9 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
     }
 
     external_acl_cache_touch(acl->def, entry);
-    result = entry->result;
     external_acl_message = entry->message.termedBuf();
 
-    debugs(82, 2, "aclMatchExternal: " << acl->def->name << " = " << result);
+    debugs(82, 2, HERE << acl->def->name << " = " << entry->result);
 
     if (ch->request) {
 #if USE_AUTH
@@ -843,13 +840,30 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
             ch->request->extacl_message = entry->message;
     }
 
-    return result;
+    return entry->result;
 }
 
 int
 ACLExternal::match(ACLChecklist *checklist)
 {
-    return aclMatchExternal (data, Filled(checklist));
+    allow_t answer = aclMatchExternal(data, Filled(checklist));
+    checklist->currentAnswer(answer);
+
+    // convert to tri-state ACL match 1,0,-1
+    switch (answer) {
+    case ACCESS_ALLOWED:
+    case ACCESS_AUTH_EXPIRED_OK:
+        return 1; // match
+
+    case ACCESS_DENIED:
+    case ACCESS_AUTH_EXPIRED_BAD:
+        return 0; // non-match
+
+    case ACCESS_DUNNO:
+    case ACCESS_AUTH_REQUIRED:
+    default:
+        return -1; // other
+    }
 }
 
 wordlist *
@@ -1260,7 +1274,7 @@ externalAclHandleReply(void *data, char *reply)
     char *value;
     char *t = NULL;
     ExternalACLEntryData entryData;
-    entryData.result = 0;
+    entryData.result = ACCESS_DENIED;
     external_acl_entry *entry = NULL;
 
     debugs(82, 2, "externalAclHandleReply: reply=\"" << reply << "\"");
@@ -1269,7 +1283,7 @@ externalAclHandleReply(void *data, char *reply)
         status = strwordtok(reply, &t);
 
         if (status && strcmp(status, "OK") == 0)
-            entryData.result = 1;
+            entryData.result = ACCESS_ALLOWED;
 
         while ((token = strwordtok(NULL, &t))) {
             value = strchr(token, '=');
@@ -1346,15 +1360,15 @@ ACLExternal::ExternalAclLookup(ACLChecklist *checklist, ACLExternal * me, EAH *
     if (acl->def->require_auth) {
         int ti;
         /* Make sure the user is authenticated */
-        debugs(82, 3, "aclMatchExternal: " << acl->def->name << " check user authenticated.");
+        debugs(82, 3, HERE << acl->def->name << " check user authenticated.");
 
         if ((ti = AuthenticateAcl(ch)) != 1) {
-            debugs(82, 1, "externalAclLookup: " << acl->def->name <<
+            debugs(82, DBG_IMPORTANT, "WARNING: " << acl->def->name <<
                    " user authentication failure (" << ti << ", ch=" << ch << ")");
             callback(callback_data, NULL);
             return;
         }
-        debugs(82, 3, "aclMatchExternal: " << acl->def->name << " user is authenticated.");
+        debugs(82, 3, HERE << acl->def->name << " user is authenticated.");
     }
 #endif
 
@@ -338,8 +338,8 @@ Format::Format::assemble(MemBuf &mb, AccessLogEntry *al, int logSequenceNumber)
             }
             break;
 
-#if USE_SQUID_EUI
         case LFT_CLIENT_EUI:
+#if USE_SQUID_EUI
             // TODO make the ACL checklist have a direct link to any TCP details.
             if (al->request && al->request->clientConnectionManager.valid() && al->request->clientConnectionManager->clientConnection != NULL) {
                 if (al->request->clientConnectionManager->clientConnection->remote.IsIPv4())
@@ -348,44 +348,53 @@ Format::Format::assemble(MemBuf &mb, AccessLogEntry *al, int logSequenceNumber)
                     al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
                 out = tmp;
             }
-            break;
+#else
+            out = "-";
 #endif
+            break;
 
-            /* case LFT_SERVER_IP_ADDRESS: */
+        case LFT_SERVER_IP_ADDRESS:
+            if (al->hier.tcpServer != NULL) {
+                out = al->hier.tcpServer->remote.NtoA(tmp,sizeof(tmp));
+            }
+            break;
 
-        case LFT_SERVER_IP_OR_PEER_NAME:
+        case LFT_SERVER_FQDN_OR_PEER_NAME:
             out = al->hier.host;
-
             break;
 
-            /* case LFT_SERVER_PORT: */
-
-        case LFT_LOCAL_IP:
-            if (al->request) {
-                out = al->request->my_addr.NtoA(tmp,sizeof(tmp));
+        case LFT_SERVER_PORT:
+            if (al->hier.tcpServer != NULL) {
+                outint = al->hier.tcpServer->remote.GetPort();
+                doint = 1;
             }
+            break;
 
+        case LFT_CLIENT_LOCAL_IP_OLD_31:
+        case LFT_CLIENT_LOCAL_IP:
+            if (al->tcpClient != NULL) {
+                out = al->tcpClient->local.NtoA(tmp,sizeof(tmp));
+            }
             break;
 
-        case LFT_LOCAL_PORT:
-            if (al->request) {
-                outint = al->request->my_addr.GetPort();
+        case LFT_CLIENT_LOCAL_PORT_OLD_31:
+        case LFT_CLIENT_LOCAL_PORT:
+            if (al->tcpClient != NULL) {
+                outint = al->tcpClient->local.GetPort();
                 doint = 1;
             }
-
             break;
 
-            // the fmt->type can not be LFT_PEER_LOCAL_IP_OLD_27
-            // but compiler complains if ommited
-        case LFT_PEER_LOCAL_IP_OLD_27:
-        case LFT_PEER_LOCAL_IP:
-            if (!al->hier.peer_local_addr.IsAnyAddr()) {
-                out = al->hier.peer_local_addr.NtoA(tmp,sizeof(tmp));
+        case LFT_SERVER_LOCAL_IP_OLD_27:
+        case LFT_SERVER_LOCAL_IP:
+            if (al->hier.tcpServer != NULL) {
+                out = al->hier.tcpServer->local.NtoA(tmp,sizeof(tmp));
             }
             break;
 
-        case LFT_PEER_LOCAL_PORT:
-            if ((outint = al->hier.peer_local_addr.GetPort())) {
+        case LFT_SERVER_LOCAL_PORT:
+            if (al->hier.tcpServer != NULL) {
+                outint = al->hier.tcpServer->local.GetPort();
                 doint = 1;
             }
 
@@ -35,21 +35,21 @@ struct Format::TokenTableEntry Format::TokenTable[] = {
     {">a", LFT_CLIENT_IP_ADDRESS},
     {">p", LFT_CLIENT_PORT},
     {">A", LFT_CLIENT_FQDN},
-#if USE_SQUID_EUI
     {">eui", LFT_CLIENT_EUI},
-#endif
 
-    /*{ "<a", LFT_SERVER_IP_ADDRESS }, */
-    /*{ "<p", LFT_SERVER_PORT }, */
-    {"<A", LFT_SERVER_IP_OR_PEER_NAME},
+    {"<a", LFT_SERVER_IP_ADDRESS},
+    {"<p", LFT_SERVER_PORT},
+    {"<A", LFT_SERVER_FQDN_OR_PEER_NAME},
 
-    {"la", LFT_LOCAL_IP},
-    {"lp", LFT_LOCAL_PORT},
+    {">la", LFT_CLIENT_LOCAL_IP},
+    {"la", LFT_CLIENT_LOCAL_IP_OLD_31},
+    {">lp", LFT_CLIENT_LOCAL_PORT},
+    {"lp", LFT_CLIENT_LOCAL_PORT_OLD_31},
     /*{ "lA", LFT_LOCAL_NAME }, */
 
-    {"<la", LFT_PEER_LOCAL_IP},
-    {"oa", LFT_PEER_LOCAL_IP_OLD_27},
-    {"<lp", LFT_PEER_LOCAL_PORT},
+    {"<la", LFT_SERVER_LOCAL_IP},
+    {"oa", LFT_SERVER_LOCAL_IP_OLD_27},
+    {"<lp", LFT_SERVER_LOCAL_PORT},
     /* {"ot", LFT_PEER_OUTGOING_TOS}, */
 
     {"ts", LFT_TIME_SECONDS_SINCE_EPOCH},
@@ -420,17 +420,26 @@ Format::Token::parse(char *def, Quoting *quoting)
             if (!divisor)
                 divisor = 0;
         }
-
         break;
 
     case LFT_HTTP_SENT_STATUS_CODE_OLD_30:
         debugs(46, 0, "WARNING: The \"Hs\" formatting code is deprecated. Use the \">Hs\" instead.");
         type = LFT_HTTP_SENT_STATUS_CODE;
         break;
 
-    case LFT_PEER_LOCAL_IP_OLD_27:
+    case LFT_CLIENT_LOCAL_IP_OLD_31:
+        debugs(46, 0, "WARNING: The \"la\" formatting code is deprecated. Use the \">la\" instead.");
+        type = LFT_CLIENT_LOCAL_IP;
+        break;
+
+    case LFT_CLIENT_LOCAL_PORT_OLD_31:
+        debugs(46, 0, "WARNING: The \"lp\" formatting code is deprecated. Use the \">lp\" instead.");
+        type = LFT_CLIENT_LOCAL_PORT;
+        break;
+
+    case LFT_SERVER_LOCAL_IP_OLD_27:
         debugs(46, 0, "WARNING: The \"oa\" formatting code is deprecated. Use the \"<la\" instead.");
-        type = LFT_PEER_LOCAL_IP;
+        type = LFT_SERVER_LOCAL_IP;
         break;
 
     case LFT_REQUEST_URLPATH_OLD_31:
@@ -443,6 +452,12 @@ Format::Token::parse(char *def, Quoting *quoting)
         type = LFT_REQUEST_VERSION;
         break;
 
+#if !USE_SQUID_EUI
+    case LFT_CLIENT_EUI:
+        debugs(46, 0, "WARNING: The \">eui\" formatting code requires EUI features which are disabled in this Squid.");
+        break;
+#endif
+
     default:
         break;
     }
@@ -28,20 +28,21 @@ typedef enum {
     LFT_CLIENT_IP_ADDRESS,
     LFT_CLIENT_FQDN,
     LFT_CLIENT_PORT,
-#if USE_SQUID_EUI
     LFT_CLIENT_EUI,
-#endif
 
-    /*LFT_SERVER_IP_ADDRESS, */
-    LFT_SERVER_IP_OR_PEER_NAME,
-    /*LFT_SERVER_PORT, */
+    LFT_SERVER_IP_ADDRESS,
+    LFT_SERVER_FQDN_OR_PEER_NAME,
+    LFT_SERVER_PORT,
 
-    LFT_LOCAL_IP,
-    LFT_LOCAL_PORT,
+    LFT_CLIENT_LOCAL_IP,
+    LFT_CLIENT_LOCAL_IP_OLD_31,
+    LFT_CLIENT_LOCAL_PORT,
+    LFT_CLIENT_LOCAL_PORT_OLD_31,
     /*LFT_LOCAL_NAME, */
-    LFT_PEER_LOCAL_IP,
-    LFT_PEER_LOCAL_IP_OLD_27,
-    LFT_PEER_LOCAL_PORT,
+
+    LFT_SERVER_LOCAL_IP,
+    LFT_SERVER_LOCAL_IP_OLD_27,
+    LFT_SERVER_LOCAL_PORT,
 
     LFT_TIME_SECONDS_SINCE_EPOCH,
     LFT_TIME_SUBSECOND,
@@ -177,7 +178,16 @@ enum Quoting {
 class Token
 {
 public:
-    Token() {};
+    Token() : type(LFT_NONE),
+            width(0),
+            precision(0),
+            quote(LOG_QUOTE_NONE),
+            left(0),
+            space(0),
+            zero(0),
+            divisor(0),
+            next(NULL)
+    { data.string = NULL; };
     ~Token();
 
     /** parses a single token. Returns the token length in characters,
@@ -285,14 +285,30 @@ FwdState::fwdStart(const Comm::ConnectionPointer &clientConn, StoreEntry *entry,
 void
 FwdState::startConnectionOrFail()
 {
-    debugs(17, 3, HERE << entry->url() );
+    debugs(17, 3, HERE << entry->url());
 
     if (serverDestinations.size() > 0) {
+        // Ditch error page if it was created before.
+        // A new one will be created if there's another problem
+        if (err) {
+            errorStateFree(err);
+            err = NULL;
+        }
+
+        // Update the logging information about this new server connection.
+        // Done here before anything else so the errors get logged for
+        // this server link regardless of what happens when connecting to it.
+        // IF sucessfuly connected this top destination will become the serverConnection().
+        request->hier.note(serverDestinations[0], request->GetHost());
+
         connectStart();
     } else {
-        debugs(17, 3, HERE << entry->url()  );
-        ErrorState *anErr = errorCon(ERR_CANNOT_FORWARD, HTTP_SERVICE_UNAVAILABLE, request);
-        anErr->xerrno = errno;
+        debugs(17, 3, HERE << entry->url());
+        ErrorState *anErr = NULL;
+        if (err) {
+            anErr = errorCon(ERR_CANNOT_FORWARD, HTTP_INTERNAL_SERVER_ERROR, request);
+            anErr->xerrno = errno;
+        } // else use actual error from last connection attempt
         fail(anErr);
         self = NULL;       // refcounted
     }
@@ -355,18 +371,17 @@ FwdState::complete()
     logReplyStatus(n_tries, entry->getReply()->sline.status);
 
     if (reforward()) {
-        assert(serverDestinations.size() > 0);
         debugs(17, 3, HERE << "re-forwarding " << entry->getReply()->sline.status << " " << entry->url());
 
         if (Comm::IsConnOpen(serverConn))
             unregister(serverConn);
 
         entry->reset();
 
-        /* the call to reforward() has already dropped the last path off the
-         * selection list. all we have now are the next path(s) to be tried.
-         */
-        connectStart();
+        // drop the last path off the selection list. try the next one.
+        serverDestinations.shift();
+        startConnectionOrFail();
+
     } else {
         if (Comm::IsConnOpen(serverConn))
             debugs(17, 3, HERE << "server FD " << serverConnection()->fd << " not re-forwarding status " << entry->getReply()->sline.status);
@@ -523,27 +538,9 @@ FwdState::retryOrBail()
 {
     if (checkRetry()) {
         debugs(17, 3, HERE << "re-forwarding (" << n_tries << " tries, " << (squid_curtime - start_t) << " secs)");
-
         serverDestinations.shift(); // last one failed. try another.
-
-        if (serverDestinations.size() > 0) {
-            /* Ditch error page if it was created before.
-             * A new one will be created if there's another problem */
-            if (err) {
-                errorStateFree(err);
-                err = NULL;
-            }
-
-            connectStart();
-            return;
-        }
-        // else bail. no more serverDestinations possible to try.
-
-        // produce cannot-forward error, but only if no more specific one exists
-        if (!err) {
-            ErrorState *anErr = errorCon(ERR_CANNOT_FORWARD, HTTP_INTERNAL_SERVER_ERROR, request);
-            errorAppendEntry(entry, anErr);
-        }
+        startConnectionOrFail();
+        return;
     }
 
     // TODO: should we call completed() here and move doneWithRetries there?
@@ -728,20 +725,13 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
 
     serverConn = conn;
 
-#if REDUNDANT_NOW
-    if (Config.onoff.log_ip_on_direct && serverConnection()->peerType == HIER_DIRECT)
-        updateHierarchyInfo();
-#endif
-
     debugs(17, 3, HERE << serverConnection() << ": '" << entry->url() << "'" );
 
     comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
     if (serverConnection()->getPeer())
         peerConnectSucceded(serverConnection()->getPeer());
 
-    updateHierarchyInfo();
-
 #if USE_SSL
     if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
             (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS)) {
@@ -761,9 +751,6 @@ FwdState::connectTimeout(int fd)
     assert(serverDestinations[0] != NULL);
     assert(fd == serverDestinations[0]->fd);
 
-    if (Config.onoff.log_ip_on_direct && serverDestinations[0]->peerType == HIER_DIRECT)
-        updateHierarchyInfo();
-
     if (entry->isEmpty()) {
         ErrorState *anErr = errorCon(ERR_CONNECT_FAIL, HTTP_GATEWAY_TIMEOUT, request);
         anErr->xerrno = ETIMEDOUT;
@@ -835,7 +822,6 @@ FwdState::connectStart()
             request->flags.pinned = 1;
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = 1;
-            updateHierarchyInfo();
             dispatch();
             return;
         }
@@ -864,7 +850,6 @@ FwdState::connectStart()
         if (!serverConnection()->getPeer())
             origin_tries++;
 
-        updateHierarchyInfo();
         comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
         /* Update server side TOS and Netfilter mark on the connection. */
@@ -1055,9 +1040,8 @@ FwdState::reforward()
     if (request->bodyNibbled())
         return 0;
 
-    serverDestinations.shift();
-
-    if (serverDestinations.size() == 0) {
+    if (serverDestinations.size() <= 1) {
+        // NP: <= 1 since total count includes the recently failed one.
         debugs(17, 3, HERE << "No alternative forwarding paths left");
         return 0;
     }
@@ -1178,44 +1162,6 @@ FwdState::logReplyStatus(int tries, http_status status)
     FwdReplyCodes[tries][status]++;
 }
 
-/** From Comment #5 by Henrik Nordstrom made at
-http://www.squid-cache.org/bugs/show_bug.cgi?id=2391 on 2008-09-19
-
-updateHierarchyInfo should be called each time a new path has been
-selected or when more information about the path is available (i.e. the
-server IP), and when it's called it needs to be given reasonable
-arguments describing the now selected path..
-
-It does not matter from a functional perspective if it gets called a few
-times more than what is really needed, but calling it too often may
-obviously hurt performance.
-*/
-// updates HierarchyLogEntry, guessing nextHop and its format
-void
-FwdState::updateHierarchyInfo()
-{
-    assert(request);
-
-    assert(serverDestinations.size() > 0);
-
-    char nextHop[256];
-
-    if (serverConnection()->getPeer()) {
-        // went to peer, log peer host name
-        snprintf(nextHop,256,"%s", serverConnection()->getPeer()->name);
-    } else {
-        // went DIRECT, must honor log_ip_on_direct
-        if (!Config.onoff.log_ip_on_direct)
-            snprintf(nextHop,256,"%s",request->GetHost()); // domain name
-        else
-            serverConnection()->remote.NtoA(nextHop, 256);
-    }
-
-    assert(nextHop[0]);
-    hierarchyNote(&request->hier, serverConnection()->peerType, nextHop);
-}
-
-
 /**** PRIVATE NON-MEMBER FUNCTIONS ********************************************/
 
 /*
@@ -33,7 +33,12 @@ class FwdState : public RefCountable
     static void initModule();
 
     static void fwdStart(const Comm::ConnectionPointer &client, StoreEntry *, HttpRequest *);
+
+    /// This is the real beginning of server connection. Call it whenever
+    /// the forwarding server destination has changed and a new one needs to be opened.
+    /// Produces the cannot-forward error on fail if no better error exists.
     void startConnectionOrFail();
+
     void fail(ErrorState *err);
     void unregister(Comm::ConnectionPointer &conn);
     void unregister(int fd);
@@ -65,7 +70,6 @@ class FwdState : public RefCountable
     void start(Pointer aSelf);
 
     static void logReplyStatus(int tries, http_status status);
-    void updateHierarchyInfo();
     void doneWithRetries();
     void completed();
     void retryOrBail();
@@ -1215,7 +1215,8 @@ FtpStateData::dataComplete()
 void
 FtpStateData::maybeReadVirginBody()
 {
-    if (!Comm::IsConnOpen(data.conn))
+    // too late to read
+    if (!Comm::IsConnOpen(data.conn) || fd_table[data.conn->fd].closing())
         return;
 
     if (data.read_pending)
@@ -54,6 +54,7 @@
 #endif
 #include "err_detail_type.h"
 #include "errorpage.h"
+#include "fde.h"
 #include "http.h"
 #include "HttpControlMsg.h"
 #include "HttpHdrContRange.h"
@@ -1430,6 +1431,10 @@ HttpStateData::processReplyBody()
 void
 HttpStateData::maybeReadVirginBody()
 {
+    // too late to read
+    if (!Comm::IsConnOpen(serverConnection) || fd_table[serverConnection->fd].closing())
+        return;
+
     // we may need to grow the buffer if headers do not fit
     const int minRead = flags.headers_parsed ? 0 :1024;
     const int read_size = replyBodySpace(*readBuf, minRead);
@@ -15,7 +15,9 @@ void
 testIcmp::testChecksum()
 {
     stubIcmp icmp;
-    short unsigned int buf[10] = {htons(1),htons(2),htons(3),htons(4),htons(5),htons(6),htons(7),htons(8),htons(9), htons(10)};
+    uint16_t buf[10], tmpval;
+    for (tmpval=0; tmpval < 10; ++tmpval)
+        buf[tmpval]=htons(1+tmpval);
 
     // NULL data
     CPPUNIT_ASSERT_EQUAL((int)htons(0xffff), icmp.testChecksum(NULL,0));
@@ -43,10 +43,9 @@
 void
 Log::Format::SquidNative(AccessLogEntry * al, Logfile * logfile)
 {
-    const char *user = NULL;
-    char clientip[MAX_IPSTRLEN];
+    char hierHost[MAX_IPSTRLEN];
 
-    user = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
+    const char *user = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
 
     if (!user)
         user = ::Format::QuoteUrlEncodeUsername(al->cache.extuser);
@@ -62,11 +61,17 @@ Log::Format::SquidNative(AccessLogEntry * al, Logfile * logfile)
     if (user && !*user)
         safe_free(user);
 
+    char clientip[MAX_IPSTRLEN];
+    if (al->tcpClient != NULL)
+        al->tcpClient->remote.NtoA(clientip, sizeof(clientip));
+    else
+        al->cache.caddr.NtoA(clientip, sizeof(clientip));
+
     logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %"PRId64" %s %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   al->cache.msec,
-                  al->cache.caddr.NtoA(clientip, MAX_IPSTRLEN),
+                  clientip,
                   ::Format::log_tags[al->cache.code],
                   al->http.statusSfx(),
                   al->http.code,
@@ -76,7 +81,7 @@ Log::Format::SquidNative(AccessLogEntry * al, Logfile * logfile)
                   user ? user : dash_str,
                   al->hier.ping.timedout ? "TIMEOUT_" : "",
                   hier_code_str[al->hier.code],
-                  al->hier.host,
+                  al->hier.tcpServer != NULL ? al->hier.tcpServer->remote.NtoA(hierHost, sizeof(hierHost)) : "-",
                   al->http.content_type,
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
@@ -252,7 +252,7 @@ HierarchyLogEntry::HierarchyLogEntry() :
         peer_reply_status(HTTP_STATUS_NONE),
         peer_response_time(-1),
         total_response_time(-1),
-        peer_local_addr(),
+        tcpServer(NULL),
         bodyBytesRead(-1)
 {
     memset(host, '\0', SQUIDHOSTNAMELEN);
@@ -272,13 +272,22 @@ HierarchyLogEntry::HierarchyLogEntry() :
 }
 
 void
-hierarchyNote(HierarchyLogEntry * hl,
-              hier_code code,
-              const char *cache_peer)
+HierarchyLogEntry::note(const Comm::ConnectionPointer &server, const char *requestedHost)
 {
-    assert(hl != NULL);
-    hl->code = code;
-    xstrncpy(hl->host, cache_peer, SQUIDHOSTNAMELEN);
+    tcpServer = server;
+    if (tcpServer == NULL) {
+        code = HIER_NONE;
+        xstrncpy(host, requestedHost, sizeof(host));
+    } else {
+        code = tcpServer->peerType;
+
+        if (tcpServer->getPeer()) {
+            // went to peer, log peer host name
+            xstrncpy(host, tcpServer->getPeer()->name, sizeof(host));
+        } else {
+            xstrncpy(host, requestedHost, sizeof(host));
+        }
+    }
 }
 
 static void
@@ -1046,6 +1046,10 @@ mainInitialize(void)
 
 #endif
 
+#if USE_SSL_CRTD
+    Ssl::Helper::GetInstance()->Init();
+#endif
+
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
@@ -3,6 +3,7 @@
  */
 
 #include "config.h"
+#include "ProtoPort.h"
 #include "ssl/Config.h"
 #include "ssl/helper.h"
 #include "SquidTime.h"
@@ -16,7 +17,6 @@ Ssl::Helper * Ssl::Helper::GetInstance()
 
 Ssl::Helper::Helper()
 {
-    Init();
 }
 
 Ssl::Helper::~Helper()
@@ -26,8 +26,20 @@ Ssl::Helper::~Helper()
 
 void Ssl::Helper::Init()
 {
-    if (ssl_crtd == NULL)
-        ssl_crtd = new helper("ssl_crtd");
+    assert(ssl_crtd == NULL);
+
+    bool useSslBump = false;
+    for (http_port_list *s = ::Config.Sockaddr.http; s; s = s->next) {
+        if (s->sslBump) {
+            useSslBump = true;
+            break;
+        }
+    }
+
+    if (!useSslBump)
+        return;
+
+    ssl_crtd = new helper("ssl_crtd");
     ssl_crtd->childs = Ssl::TheConfig.ssl_crtdChildren;
     ssl_crtd->ipc_type = IPC_STREAM;
     // The crtd messages may contain the eol ('\n') character. We are
@@ -69,15 +81,14 @@ void Ssl::Helper::Shutdown()
         return;
     helperShutdown(ssl_crtd);
     wordlistDestroy(&ssl_crtd->cmdline);
-    if (!shutting_down)
-        return;
     delete ssl_crtd;
     ssl_crtd = NULL;
 }
 
 void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void * data)
 {
     static time_t first_warn = 0;
+    assert(ssl_crtd);
 
     if (ssl_crtd->stats.queue_size >= (int)(ssl_crtd->childs.n_running * 2)) {
         if (first_warn == 0)
@@ -1542,6 +1542,14 @@ StoreEntry::timestampsSet()
     if (served_date < 0 || served_date > squid_curtime)
         served_date = squid_curtime;
 
+    /* Bug 1791:
+     * If the returned Date: is more than 24 hours older than
+     * the squid_curtime, then one of us needs to use NTP to set our
+     * clock.  We'll pretend that our clock is right.
+     */
+    else if (served_date < (squid_curtime - 24 * 60 * 60) )
+        served_date = squid_curtime;
+
     /*
      * Compensate with Age header if origin server clock is ahead
      * of us and there is a cache in between us and the origin
@@ -432,7 +432,6 @@ struct SquidConfig {
         int digest_generation;
 #endif
 
-        int log_ip_on_direct;
         int ie_refresh;
         int vary_ignore_expire;
         int pipeline_prefetch;
@@ -78,11 +78,10 @@ class TunnelStateData
     {
 
     public:
-        Connection() : len (0), buf ((char *)xmalloc(SQUID_TCP_SO_RCVBUF)), size_ptr(NULL) {}
+        Connection() : len (0), buf(), size_ptr(NULL) { buf.init(SQUID_TCP_SO_RCVBUF,SQUID_TCP_SO_RCVBUF); }
+        ~Connection() {};
 
-        ~Connection();
-
-        int bytesWanted(int lower=0, int upper = INT_MAX) const;
+        int bytesWanted() const;
         void bytesIn(int const &);
 #if USE_DELAY_POOLS
 
@@ -92,9 +91,9 @@ class TunnelStateData
         void error(int const xerrno);
         int debugLevelForError(int const xerrno) const;
         void closeIfOpen();
-        void dataSent (size_t amount);
+        void dataSent(size_t amount);
         int len;
-        char *buf;
+        MemBuf buf;
         int64_t *size_ptr;		/* pointer to size in an ConnStateData for logging */
 
         Comm::ConnectionPointer conn;    ///< The currently connected connection.
@@ -113,7 +112,7 @@ class TunnelStateData
 
 private:
     CBDATA_CLASS(TunnelStateData);
-    void copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *);
+    void copy(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, AsyncCall::Pointer &);
     void readServer(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void readClient(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void writeClientDone(char *buf, size_t len, comm_err_t flag, int xerrno);
@@ -180,19 +179,13 @@ tunnelStateFree(TunnelStateData * tunnelState)
     delete tunnelState;
 }
 
-TunnelStateData::Connection::~Connection()
-{
-    safe_free(buf);
-}
-
 int
-TunnelStateData::Connection::bytesWanted(int lowerbound, int upperbound) const
+TunnelStateData::Connection::bytesWanted() const
 {
 #if USE_DELAY_POOLS
-    return delayId.bytesWanted(lowerbound, upperbound);
+    return delayId.bytesWanted(1, buf.spaceSize());
 #else
-
-    return upperbound;
+    return buf.spaceSize();
 #endif
 }
 
@@ -253,7 +246,10 @@ TunnelStateData::readServer(char *buf, size_t len, comm_err_t errcode, int xerrn
         kb_incr(&statCounter.server.other.kbytes_in, len);
     }
 
-    copy (len, errcode, xerrno, server, client, WriteClientDone);
+    AsyncCall::Pointer call = commCbCall(5,5, "TunnelStateData::WriteClientDone",
+                                         CommIoCbPtrFun(WriteClientDone, this));
+
+    copy (len, errcode, xerrno, server, client, call);
 }
 
 void
@@ -296,11 +292,14 @@ TunnelStateData::readClient(char *buf, size_t len, comm_err_t errcode, int xerrn
         kb_incr(&statCounter.client_http.kbytes_in, len);
     }
 
-    copy (len, errcode, xerrno, client, server, WriteServerDone);
+    AsyncCall::Pointer call = commCbCall(5,5, "TunnelStateData::WriteServerDone",
+                                         CommIoCbPtrFun(WriteServerDone, this));
+
+    copy (len, errcode, xerrno, client, server, call);
 }
 
 void
-TunnelStateData::copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *completion)
+TunnelStateData::copy(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, AsyncCall::Pointer &call)
 {
     debugs(26, 3, HERE << "from={" << from.conn << "}, to={" << to.conn << "}");
 
@@ -329,9 +328,7 @@ TunnelStateData::copy (size_t len, comm_err_t errcode, int xerrno, Connection &f
         }
     } else if (cbdataReferenceValid(this)) {
         debugs(26, 3, HERE << "Schedule Write");
-        AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
-                                             CommIoCbPtrFun(completion, this));
-        Comm::Write(to.conn, from.buf, len, call, NULL);
+        Comm::Write(to.conn, &from.buf, call);
     }
 
     cbdataInternalUnlock(this);	/* ??? */
@@ -476,7 +473,7 @@ TunnelStateData::copyRead(Connection &from, IOCB *completion)
     assert(from.len == 0);
     AsyncCall::Pointer call = commCbCall(5,4, "TunnelBlindCopyReadHandler",
                                          CommIoCbPtrFun(completion, this));
-    comm_read(from.conn, from.buf, from.bytesWanted(1, SQUID_TCP_SO_RCVBUF), call);
+    comm_read(from.conn, from.buf.space(), from.bytesWanted(), call);
 }
 
 /**
@@ -574,14 +571,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
         tunnelState->server.setDelayId(DelayId());
 #endif
 
-    if (conn != NULL && conn->getPeer())
-        hierarchyNote(&tunnelState->request->hier, conn->peerType, conn->getPeer()->name);
-    else if (Config.onoff.log_ip_on_direct) {
-        conn->remote.NtoA(fd_table[conn->fd].ipaddr,sizeof(fd_table[conn->fd].ipaddr));
-        hierarchyNote(&tunnelState->request->hier, conn->peerType, fd_table[conn->fd].ipaddr);
-    } else
-        hierarchyNote(&tunnelState->request->hier, conn->peerType, tunnelState->getHost());
-
+    tunnelState->request->hier.note(conn, tunnelState->getHost());
 
     tunnelState->server.conn = conn;
     tunnelState->request->peer_host = conn->getPeer() ? conn->getPeer()->host : NULL;
@@ -626,7 +616,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
      * be allowed.  yuck, I know.
      */
 
-    if (!request->client_addr.IsNoAddr() && Config.accessList.miss) {
+    if (Config.accessList.miss && !request->client_addr.IsNoAddr()) {
         /*
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          * default is to allow.
@@ -37,7 +37,7 @@
 // Initial revision
 //
 //
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 
@@ -43,7 +43,7 @@
 // Initial revision
 //
 //
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 
@@ -38,7 +38,7 @@
 // Initial revision
 //
 //
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 
@@ -93,7 +93,7 @@
 // Initial revision
 //
 //
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 
@@ -292,7 +292,9 @@ log_extended( const char* fn, int code, long size, const SquidMetaList* meta )
                   (unsigned long)temp.timestamp, (unsigned long)temp.lastref,
                   (unsigned long)temp.expires, (unsigned long)temp.lastmod, temp.flags, temp.refcount );
     } else {
-        snprintf( timeb, sizeof(timeb), "%08lx %08lx %08lx %08lx %04x %5hu ", (unsigned long)-1, (unsigned long)-1, (unsigned long)-1, (unsigned long)-1, 0, 0 );
+        unsigned long ul = ULONG_MAX;  // Match type of StoreMetaTLV fields
+        unsigned short hu = 0;  // Match type of StoreMetaTLV refcount fields
+        snprintf( timeb, sizeof(timeb), "%08lx %08lx %08lx %08lx %04x %5d ", ul, ul, ul, ul, 0, hu);
     }
 
     // make sure that there is just one printf()
@@ -45,7 +45,7 @@
 //
 //
 
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 
@@ -46,7 +46,7 @@
 // Initial revision
 //
 //
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 
@@ -35,7 +35,7 @@
 // Initial revision
 //
 //
-#if defined(__GNUC__) || defined(__GNUG__)
+#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
 #pragma implementation
 #endif
 