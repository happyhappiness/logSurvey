@@ -208,7 +208,7 @@ RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
 /* Get a packet of size n */
 
 struct RFCNB_Pkt *
-            RFCNB_Alloc_Pkt(int n) {
+RFCNB_Alloc_Pkt(int n) {
     RFCNB_Pkt *pkt;
 
     if ((pkt = malloc(sizeof(struct RFCNB_Pkt))) == NULL) {
@@ -188,7 +188,7 @@ char *md5sum(const char *s)
     SquidMD5Update(&ctx,(const unsigned char *)s,strlen(s));
     SquidMD5Final(digest,&ctx);
 
-    for (idx=0;idx<16;idx++)
+    for (idx=0; idx<16; idx++)
         sprintf(&sum[idx*2],"%02x",digest[idx]);
 
     sum[32]='\0';
@@ -121,7 +121,7 @@ static u_int32_t ipstr2long(char *ip_str)
     int	cur_byte;
 
     ipaddr = (u_int32_t)0;
-    for (i = 0;i < 4;i++) {
+    for (i = 0; i < 4; i++) {
         ptr = buf;
         count = 0;
         *ptr = '\0';
@@ -42,7 +42,7 @@
  * It returns a pointer to the first entry of the linked list
  */
 struct ip_user_dict *
-            load_dict (FILE * FH) {
+load_dict (FILE * FH) {
     struct ip_user_dict *current_entry;	/* the structure used to
 					   store data */
     struct ip_user_dict *first_entry = NULL;	/* the head of the
@@ -42,7 +42,7 @@ void ska_base64_decode(char* result, const char *data, int result_size)
         ska_base64_init();
     val = c = 0;
 
-    for (j = 0; *data ;data++) {
+    for (j = 0; *data ; data++) {
         unsigned int k = ((unsigned char) *data) % BASE64_VALUE_SZ;
         if (base64_value[k] < 0)
             continue;
@@ -144,7 +144,7 @@ int ska_base64_decode_len(const char *data)
     int i,j;
 
     j=0;
-    for (i=strlen(data)-1;i>=0;i--) {
+    for (i=strlen(data)-1; i>=0; i--) {
         if (data[i] == '=') j++;
         if (data[i] != '=') break;
     }
@@ -26,8 +26,7 @@
 
 // C++ Specific
 #if defined(__cplusplus)
-extern "C"
-{
+extern "C" {
 #endif
 
     /* Identifier Types */
@@ -27,8 +27,7 @@
 
 // C++ Specific
 #if defined(__cplusplus)
-extern "C"
-{
+extern "C" {
 #endif
 
 // Type Definitions
@@ -11,8 +11,7 @@
 #define SPNEGOHELP_H
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 #include <stddef.h>
@@ -29,9 +28,9 @@ extern "C"
      */
 
     int makeNegTokenTarg (const unsigned char *  kerberosToken,
-                          size_t                 kerberosTokenLength,
-                          const unsigned char ** negTokenTarg,
-                          size_t *               negTokenTargLength);
+    size_t                 kerberosTokenLength,
+    const unsigned char ** negTokenTarg,
+    size_t *               negTokenTargLength);
 
     /* -----------------------------------------------------------------------------
      * parseNegTokenInit parses an RFC 2478 SPNEGO NegTokenInit (token) to extract
@@ -26,8 +26,7 @@
 
 // C++ Specific
 #if defined(__cplusplus)
-extern "C"
-{
+extern "C" {
 #endif
 
 // Indicates if we copy data when creating a SPNEGO_TOKEN structure or not
@@ -511,10 +511,10 @@ int main(int argc, char * const argv[])
                 goto cleanup;
             user=xmalloc(output_token.length+1);
             if (user == NULL) {
-               if (debug)
-                  fprintf(stderr, "%s| %s: Not enough memory\n", LogTime(), PROGRAM);
-               fprintf(stdout, "BH Not enough memory\n");
-               goto cleanup;
+                if (debug)
+                    fprintf(stderr, "%s| %s: Not enough memory\n", LogTime(), PROGRAM);
+                fprintf(stdout, "BH Not enough memory\n");
+                goto cleanup;
             }
             memcpy(user,output_token.value,output_token.length);
             user[output_token.length]='\0';
@@ -544,10 +544,10 @@ int main(int argc, char * const argv[])
              */
             user=xmalloc(output_token.length+1);
             if (user == NULL) {
-               if (debug)
-                  fprintf(stderr, "%s| %s: Not enough memory\n", LogTime(), PROGRAM);
-               fprintf(stdout, "BH Not enough memory\n");
-               goto cleanup;
+                if (debug)
+                    fprintf(stderr, "%s| %s: Not enough memory\n", LogTime(), PROGRAM);
+                fprintf(stdout, "BH Not enough memory\n");
+                goto cleanup;
             }
             memcpy(user,output_token.value,output_token.length);
             user[output_token.length]='\0';
@@ -131,21 +131,21 @@ debug(char *format,...)
 #if FAIL_DEBUG
     if (debug_enabled || fail_debug_enabled) {
 #else
-        if (debug_enabled) {
+if (debug_enabled) {
 #endif
-            va_list args;
+        va_list args;
 
-            va_start(args, format);
-            fprintf(stderr, "ntlm-auth[%ld]: ", (long)getpid());
-            vfprintf(stderr, format, args);
-            va_end(args);
+        va_start(args, format);
+        fprintf(stderr, "ntlm-auth[%ld]: ", (long)getpid());
+        vfprintf(stderr, format, args);
+        va_end(args);
 #if FAIL_DEBUG
-            fail_debug_enabled = 0;
+        fail_debug_enabled = 0;
 #endif
-        }
+    }
 #endif /* _SQUID_MSWIN_ */
 #endif /* DEBUG */
-    }
+}
 #endif /* __GNUC__ */
 
 
@@ -340,7 +340,7 @@ void hex_dump(void *data, int size)
         char addrstr[10] = {0};
         char hexstr[ 16*3 + 5] = {0};
         char charstr[16*1 + 5] = {0};
-        for (n=1;n<=size;n++) {
+        for (n=1; n<=size; n++) {
             if (n%16 == 1) {
                 /* store address for this line */
                 snprintf(addrstr, sizeof(addrstr), "%.4x",
@@ -68,21 +68,21 @@ debug(char *format,...)
 #if FAIL_DEBUG
     if (debug_enabled || fail_debug_enabled) {
 #else
-        if (debug_enabled) {
+if (debug_enabled) {
 #endif
-            va_list args;
+        va_list args;
 
-            va_start(args,format);
-            fprintf(stderr, "ntlm-auth[%d]: ",getpid());
-            vfprintf(stderr, format, args);
-            va_end(args);
+        va_start(args,format);
+        fprintf(stderr, "ntlm-auth[%d]: ",getpid());
+        vfprintf(stderr, format, args);
+        va_end(args);
 #if FAIL_DEBUG
-            fail_debug_enabled = 0;
+        fail_debug_enabled = 0;
 #endif
-        }
+    }
 #endif /* _SQUID_MSWIN_ */
 #endif /* DEBUG */
-    }
+}
 #endif /* __GNUC__ */
 
 
@@ -186,7 +186,7 @@ RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
 /* Get a packet of size n */
 
 struct RFCNB_Pkt *
-            RFCNB_Alloc_Pkt(int n) {
+RFCNB_Alloc_Pkt(int n) {
     RFCNB_Pkt *pkt;
 
     if ((pkt = (struct RFCNB_Pkt *) malloc(sizeof(struct RFCNB_Pkt))) == NULL) {
@@ -638,15 +638,15 @@ extern int SMBlib_SMB_Error;	/* last Error             */
 #endif
 
 extern SMB_Tree_Handle SMB_TreeConnect(SMB_Handle_Type con, SMB_Tree_Handle tree,
-                                           char *path, char *password, char const *dev);
+                                       char *path, char *password, char const *dev);
 
 extern int SMB_Init(void);
 extern void SMB_Get_My_Name(char *name, int len);
 extern int SMB_Negotiate(SMB_Handle_Type Con_Handle, char const *Prots[]);
 extern int SMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle);
 
 extern int SMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,
-                                char *PassWord, char *UserDomain, int precrypted);
+                            char *PassWord, char *UserDomain, int precrypted);
 
 extern int SMB_Get_Error_Msg(int msg, char *msgbuf, int len);
 
@@ -69,8 +69,7 @@ typedef u_char oid;
 #define IS_EXTENSION_ID(byte)	(((byte) & ASN_EXTENSION_ID) == ASN_EXTENSION_ID)
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     u_char *asn_build_header(u_char *, int *, u_char, int);
@@ -67,8 +67,7 @@ struct snmp_mib_tree {
 #define TYPE_NULL	    10
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     void init_mib(char *);
@@ -113,34 +113,31 @@ struct squid_radix_node_head {
     int rnh_pktsize;		/* permit, but not require fixed keys */
 
     struct squid_radix_node *(*rnh_addaddr)	/* add based on sockaddr */
-                (void *v, void *mask,
-
-                 struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
+    (void *v, void *mask, struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
 
     struct squid_radix_node *(*rnh_addpkt)	/* add based on packet hdr */
-                (void *v, void *mask,
-
-                 struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
+    (void *v, void *mask, struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
 
     struct squid_radix_node *(*rnh_deladdr)	/* remove based on sockaddr */
 
-                (void *v, void *mask, struct squid_radix_node_head * head);
+    (void *v, void *mask, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_delpkt)	/* remove based on packet hdr */
 
-                (void *v, void *mask, struct squid_radix_node_head * head);
+    (void *v, void *mask, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_matchaddr)		/* locate based on sockaddr */
 
-                (void *v, struct squid_radix_node_head * head);
+    (void *v, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_lookup)	/* locate based on sockaddr */
 
-                (void *v, void *mask, struct squid_radix_node_head * head);
+    (void *v, void *mask, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_matchpkt)	/* locate based on packet hdr */
 
-                (void *v, struct squid_radix_node_head * head);
+    (void *v, struct squid_radix_node_head * head);
+
     int (*rnh_walktree)		/* traverse tree */
 
     (struct squid_radix_node_head * head, int (*f) (struct squid_radix_node *, void *), void *w);
@@ -52,22 +52,19 @@ SOFTWARE.
 #define SNMP_DEFAULT_MACREPEATERS   0
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     /* Parse the buffer pointed to by arg3, of length arg4, into pdu arg2.
      *
      * Returns the community of the incoming PDU, or NULL
      */
-    u_char *snmp_parse(struct snmp_session *, struct snmp_pdu *,
-                       u_char *, int);
+    u_char *snmp_parse(struct snmp_session *, struct snmp_pdu *, u_char *, int);
 
     /* Encode pdu arg2 into buffer arg3.  arg4 contains the size of
      * the buffer.
      */
-    int snmp_build(struct snmp_session *, struct snmp_pdu *,
-                   u_char *, int *);
+    int snmp_build(struct snmp_session *, struct snmp_pdu *, u_char *, int *);
 
     /*
      * struct snmp_session *snmp_open(session)
@@ -52,8 +52,7 @@
 #define SNMPERR_LAST            -16	/* Last error message */
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     /* extern int snmp_errno */
@@ -85,8 +85,7 @@ struct snmp_internal_session {
 #endif /* HAVE_SRAND */
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     int snmp_get_socket_session(struct snmp_session *session_);
@@ -41,8 +41,7 @@ struct synch_state {
 };
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     extern struct synch_state snmp_synch_state;
@@ -31,8 +31,7 @@
  **********************************************************************/
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     int snmp_coexist_V2toV1(struct snmp_pdu *);
@@ -57,8 +57,7 @@
 
 #ifdef __cplusplus
 
-extern "C"
-{
+extern "C" {
 #endif
 
     const char *snmp_errstring(int);
@@ -36,8 +36,7 @@
 #define SNMP_VERSION_2	    1	/* RFC 1901 */
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     u_char *snmp_msg_Encode(u_char *, int *, u_char *, int, int, struct snmp_pdu *);
@@ -39,8 +39,7 @@
  **********************************************************************/
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     typedef struct sockaddr_in ipaddr;
@@ -7,8 +7,7 @@
 #include "config.h"
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     /* call a function at regular intervals (in seconds): */
@@ -32,8 +32,7 @@
 #include "asn1.h"
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
     struct variable_list {
@@ -155,7 +155,7 @@ opendir(const CHAR * szPath)
  * next entry in the directory.
  */
 struct dirent *
-            readdir(DIR * dirp) {
+readdir(DIR * dirp) {
     errno = 0;
 
     /* Check for valid DIR struct. */
@@ -83,7 +83,7 @@
 #include "inet_pton.h"
 
 static struct addrinfo *
-            dup_addrinfo (struct addrinfo *info, void *addr, size_t addrlen) {
+dup_addrinfo (struct addrinfo *info, void *addr, size_t addrlen) {
     struct addrinfo *ret;
 
     ret = malloc (sizeof (struct addrinfo));
@@ -178,7 +178,7 @@ static char *rn_zeros, *rn_ones;
  */
 
 struct squid_radix_node *
-            squid_rn_search(void *v_arg, struct squid_radix_node *head) {
+squid_rn_search(void *v_arg, struct squid_radix_node *head) {
     register struct squid_radix_node *x;
     register caddr_t v;
 
@@ -192,7 +192,7 @@ struct squid_radix_node *
 }
 
 struct squid_radix_node *
-            squid_rn_search_m(void *v_arg, struct squid_radix_node *head, void *m_arg) {
+squid_rn_search_m(void *v_arg, struct squid_radix_node *head, void *m_arg) {
     register struct squid_radix_node *x;
     register caddr_t v = v_arg, m = m_arg;
 
@@ -233,7 +233,7 @@ squid_rn_refines(void *m_arg, void *n_arg)
 }
 
 struct squid_radix_node *
-            squid_rn_lookup(void *v_arg, void *m_arg, struct squid_radix_node_head *head) {
+squid_rn_lookup(void *v_arg, void *m_arg, struct squid_radix_node_head *head) {
     register struct squid_radix_node *x;
     caddr_t netmask = 0;
 
@@ -271,7 +271,7 @@ rn_satsifies_leaf(char *trial, register struct squid_radix_node *leaf, int skip)
 }
 
 struct squid_radix_node *
-            squid_rn_match(void *v_arg, struct squid_radix_node_head *head) {
+squid_rn_match(void *v_arg, struct squid_radix_node_head *head) {
     caddr_t v = v_arg;
     register struct squid_radix_node *t = head->rnh_treetop, *x;
     register caddr_t cp = v, cp2;
@@ -377,7 +377,7 @@ int rn_debug = 1;
 #endif
 
 struct squid_radix_node *
-            squid_rn_newpair(void *v, int b, struct squid_radix_node nodes[2]) {
+squid_rn_newpair(void *v, int b, struct squid_radix_node nodes[2]) {
     register struct squid_radix_node *tt = nodes, *t = tt + 1;
     t->rn_b = b;
     t->rn_bmask = 0x80 >> (b & 7);
@@ -398,7 +398,7 @@ struct squid_radix_node *
 }
 
 struct squid_radix_node *
-            squid_rn_insert(void *v_arg, struct squid_radix_node_head *head, int *dupentry, struct squid_radix_node nodes[2]) {
+squid_rn_insert(void *v_arg, struct squid_radix_node_head *head, int *dupentry, struct squid_radix_node nodes[2]) {
     caddr_t v = v_arg;
     struct squid_radix_node *top = head->rnh_treetop;
     int head_off = top->rn_off, vlen = (int) *((u_char *) v);
@@ -463,7 +463,7 @@ struct squid_radix_node *
 }
 
 struct squid_radix_node *
-            squid_rn_addmask(void *n_arg, int search, int skip) {
+squid_rn_addmask(void *n_arg, int search, int skip) {
     caddr_t netmask = (caddr_t) n_arg;
     register struct squid_radix_node *x;
     register caddr_t cp, cplim;
@@ -548,7 +548,7 @@ rn_lexobetter(void *m_arg, void *n_arg)
 }
 
 static struct squid_radix_mask *
-            rn_new_radix_mask(struct squid_radix_node *tt, struct squid_radix_mask *next) {
+rn_new_radix_mask(struct squid_radix_node *tt, struct squid_radix_mask *next) {
     register struct squid_radix_mask *m;
 
     squid_MKGet(m);
@@ -569,7 +569,7 @@ static struct squid_radix_mask *
 }
 
 struct squid_radix_node *
-            squid_rn_addroute(void *v_arg, void *n_arg, struct squid_radix_node_head *head, struct squid_radix_node treenodes[2]) {
+squid_rn_addroute(void *v_arg, void *n_arg, struct squid_radix_node_head *head, struct squid_radix_node treenodes[2]) {
     caddr_t v = (caddr_t) v_arg, netmask = (caddr_t) n_arg;
     register struct squid_radix_node *t, *x = NULL, *tt;
     struct squid_radix_node *saved_tt, *top = head->rnh_treetop;
@@ -720,7 +720,7 @@ struct squid_radix_node *
 }
 
 struct squid_radix_node *
-            squid_rn_delete(void *v_arg, void *netmask_arg, struct squid_radix_node_head *head) {
+squid_rn_delete(void *v_arg, void *netmask_arg, struct squid_radix_node_head *head) {
     register struct squid_radix_node *t, *p, *x, *tt;
     struct squid_radix_mask *m, *saved_m, **mp;
     struct squid_radix_node *dupedkey, *saved_tt, *top;
@@ -118,8 +118,8 @@ tmSaneValues(struct tm *tm)
 }
 
 static struct tm *
-            parse_date_elements(const char *day, const char *month, const char *year,
-                                const char *time, const char *zone) {
+parse_date_elements(const char *day, const char *month, const char *year,
+                    const char *time, const char *zone) {
     static struct tm tm;
     char *t;
     memset(&tm, 0, sizeof(tm));
@@ -150,7 +150,7 @@ static struct tm *
 }
 
 static struct tm *
-            parse_date(const char *str) {
+parse_date(const char *str) {
     struct tm *tm;
     static char tmp[64];
     char *t;
@@ -224,7 +224,7 @@ parse_rfc1123(const char *str)
 #elif defined(_SQUID_MSWIN_)
 #elif defined(_SQUID_SGI_)
 #else
-        extern long timezone;
+    extern long timezone;
 #endif
         /*
          * The following assumes a fixed DST offset of 1 hour,
@@ -235,7 +235,7 @@ parse_rfc1123(const char *str)
 #if defined ( _timezone) || defined(_SQUID_WIN32_)
         t -= (_timezone + dst);
 #else
-        t -= (timezone + dst);
+    t -= (timezone + dst);
 #endif
     }
 #endif
@@ -490,13 +490,13 @@ wsastrerror(int err)
 }
 
 struct passwd *
-            getpwnam(char *unused) {
+getpwnam(char *unused) {
     static struct passwd pwd = {NULL, NULL, 100, 100, NULL, NULL, NULL};
     return &pwd;
 }
 
 struct group *
-            getgrnam(char *unused) {
+getgrnam(char *unused) {
     static struct group grp = {NULL, NULL, 100, NULL};
     return &grp;
 }
@@ -100,7 +100,7 @@ init_mib(char *file)
 
 
 static struct snmp_mib_tree *
-            find_rfc1066_mib(struct snmp_mib_tree *root) {
+find_rfc1066_mib(struct snmp_mib_tree *root) {
     oid *op = RFC1066_MIB;
     struct snmp_mib_tree *tp;
     int len;
@@ -283,8 +283,8 @@ int objidlen;		/* number of subidentifiers */
 }
 
 static struct snmp_mib_tree *
-            get_symbol(objid, objidlen, subtree, buf)
-            oid *objid;
+get_symbol(objid, objidlen, subtree, buf)
+oid *objid;
 int objidlen;
 struct snmp_mib_tree *subtree;
 char *buf;
@@ -428,7 +428,7 @@ do_subtree(struct snmp_mib_tree *root, struct node **nodes)
 static
 #endif
 struct snmp_mib_tree *
-            build_tree(struct node *nodes) {
+build_tree(struct node *nodes) {
     struct node *np;
     struct snmp_mib_tree *tp;
     int bucket, nodes_left = 0;
@@ -635,7 +635,7 @@ free_node(struct node *np)
  * Returns 0 on error.
  */
 static struct node *
-            parse_objectid(FILE *fp, char *name) {
+parse_objectid(FILE *fp, char *name) {
     int type;
     char token[64];
     register int count;
@@ -744,7 +744,7 @@ parse_asntype(FILE *fp)
  * Returns 0 on error.
  */
 static struct node *
-            parse_objecttype(register FILE *fp, char *name) {
+parse_objecttype(register FILE *fp, char *name) {
     register int type;
     char token[64];
     int count, length;
@@ -978,7 +978,7 @@ static struct node *
 static
 #endif
 struct node *
-            parse(FILE *fp) {
+parse(FILE *fp) {
     char token[64];
     char name[64];
     int type = 1;
@@ -1062,7 +1062,7 @@ struct node *
 }
 
 struct snmp_mib_tree *
-            read_mib(char *filename) {
+read_mib(char *filename) {
     FILE *fp;
     struct node *nodes;
     struct snmp_mib_tree *tree;
@@ -104,7 +104,7 @@
  */
 
 struct snmp_pdu *
-            snmp_pdu_create(int command) {
+snmp_pdu_create(int command) {
     struct snmp_pdu *pdu;
 
 #ifdef DEBUG_PDU
@@ -138,7 +138,7 @@ struct snmp_pdu *
 /* Clone an existing PDU.
  */
 struct snmp_pdu *
-            snmp_pdu_clone(struct snmp_pdu *Src) {
+snmp_pdu_clone(struct snmp_pdu *Src) {
     struct snmp_pdu *Dest;
 
 #ifdef DEBUG_PDU
@@ -172,12 +172,12 @@ struct snmp_pdu *
  * be returned.
  */
 struct snmp_pdu *
-            snmp_pdu_fix(struct snmp_pdu *pdu, int command) {
+snmp_pdu_fix(struct snmp_pdu *pdu, int command) {
     return (snmp_fix_pdu(pdu, command));
 }
 
 struct snmp_pdu *
-            snmp_fix_pdu(struct snmp_pdu *pdu, int command) {
+snmp_fix_pdu(struct snmp_pdu *pdu, int command) {
     struct variable_list *var, *newvar;
     struct snmp_pdu *newpdu;
     int i;
@@ -105,7 +105,7 @@
  */
 
 struct variable_list *
-            snmp_var_new(oid * Name, int Len) {
+snmp_var_new(oid * Name, int Len) {
     struct variable_list *New;
 
 #ifdef DEBUG_VARS
@@ -147,7 +147,7 @@ struct variable_list *
 }
 
 struct variable_list *
-            snmp_var_new_integer(oid * Name, int Len, int ival, unsigned char type) {
+snmp_var_new_integer(oid * Name, int Len, int ival, unsigned char type) {
     variable_list *v = snmp_var_new(Name, Len);
     v->val_len = sizeof(int);
     v->val.integer = xmalloc(sizeof(int));
@@ -162,7 +162,7 @@ struct variable_list *
  */
 
 struct variable_list *
-            snmp_var_clone(struct variable_list *Src) {
+snmp_var_clone(struct variable_list *Src) {
     struct variable_list *Dest;
 
 #ifdef DEBUG_VARS
@@ -12,7 +12,7 @@
 void (*snmplib_debug_hook) (int, char *,...) = NULL;
 
 extern void
-    snmplib_debug(int lvl, const char *fmt,...)
+snmplib_debug(int lvl, const char *fmt,...)
 {
     char buf[BUFSIZ];
     va_list args;
@@ -127,9 +127,9 @@ class AccessLogEntry
     public:
         Headers() : request(NULL),
 #if ICAP_CLIENT
-                    icap(NULL),
+                icap(NULL),
 #endif
-                    reply(NULL) {}
+                reply(NULL) {}
 
         char *request;
 
@@ -157,9 +157,10 @@ class AccessLogEntry
     /** \brief This subclass holds log info for ICAP part of request
      *  \todo Inner class declarations should be moved outside
      */
-    class IcapLogEntry {
+    class IcapLogEntry
+    {
     public:
-    IcapLogEntry():request(NULL),reply(NULL),outcome(Adaptation::Icap::xoUnknown),trTime(0),ioTime(0),resStatus(HTTP_STATUS_NONE){}
+        IcapLogEntry():request(NULL),reply(NULL),outcome(Adaptation::Icap::xoUnknown),trTime(0),ioTime(0),resStatus(HTTP_STATUS_NONE) {}
 
         IpAddress hostAddr; ///< ICAP server IP address
         String serviceName;        ///< ICAP service name
@@ -178,7 +179,7 @@ class AccessLogEntry
         int trTime;
         /** \brief Transaction I/O time.
          * The timer starts when the first ICAP request
-         * byte is scheduled for sending and stops when the lastbyte of the 
+         * byte is scheduled for sending and stops when the lastbyte of the
          * ICAP response is received.
          */
         int ioTime;
@@ -189,9 +189,8 @@ BodyPipe::clearProducer(bool atEof)
         if (atEof) {
             if (!bodySizeKnown())
                 theBodySize = thePutSize;
-            else
-                if (bodySize() != thePutSize)
-                    debugs(91,3, HERE << "aborting on premature eof" << status());
+            else if (bodySize() != thePutSize)
+                debugs(91,3, HERE << "aborting on premature eof" << status());
         } else {
             // asserta that we can detect the abort if the consumer joins later
             assert(!bodySizeKnown() || bodySize() != thePutSize);
@@ -321,9 +320,8 @@ BodyPipe::checkIn(Checkout &checkout)
     const size_t currentSize = theBuf.contentSize();
     if (checkout.checkedOutSize > currentSize)
         postConsume(checkout.checkedOutSize - currentSize);
-    else
-        if (checkout.checkedOutSize < currentSize)
-            postAppend(currentSize - checkout.checkedOutSize);
+    else if (checkout.checkedOutSize < currentSize)
+        postAppend(currentSize - checkout.checkedOutSize);
 }
 
 void
@@ -192,17 +192,15 @@ bool ChunkedCodingParser::findCrlf(size_t &crlfBeg, size_t &crlfEnd)
         if (quoted) {
             if (c == '\\')
                 slashed = true;
-            else
-                if (c == '"')
-                    quoted = false;
+            else if (c == '"')
+                quoted = false;
 
             continue;
-        } else
-            if (c == '"') {
-                quoted = true;
-                crOff = -1;
-                continue;
-            }
+        } else if (c == '"') {
+            quoted = true;
+            crOff = -1;
+            continue;
+        }
 
         if (crOff < 0) { // looking for the first CR or LF
 
@@ -172,7 +172,7 @@ class CommCbMemFunT: public JobDialer, public CommDialerParamsT<Params_>
 
 // accept (IOACB) dialer
 class CommAcceptCbPtrFun: public CallDialer,
-            public CommDialerParamsT<CommAcceptCbParams>
+        public CommDialerParamsT<CommAcceptCbParams>
 {
 public:
     typedef CommAcceptCbParams Params;
@@ -188,7 +188,7 @@ class CommAcceptCbPtrFun: public CallDialer,
 
 // connect (CNCB) dialer
 class CommConnectCbPtrFun: public CallDialer,
-            public CommDialerParamsT<CommConnectCbParams>
+        public CommDialerParamsT<CommConnectCbParams>
 {
 public:
     typedef CommConnectCbParams Params;
@@ -205,7 +205,7 @@ class CommConnectCbPtrFun: public CallDialer,
 
 // read/write (IOCB) dialer
 class CommIoCbPtrFun: public CallDialer,
-            public CommDialerParamsT<CommIoCbParams>
+        public CommDialerParamsT<CommIoCbParams>
 {
 public:
     typedef CommIoCbParams Params;
@@ -222,7 +222,7 @@ class CommIoCbPtrFun: public CallDialer,
 
 // close (PF) dialer
 class CommCloseCbPtrFun: public CallDialer,
-            public CommDialerParamsT<CommCloseCbParams>
+        public CommDialerParamsT<CommCloseCbParams>
 {
 public:
     typedef CommCloseCbParams Params;
@@ -237,7 +237,7 @@ class CommCloseCbPtrFun: public CallDialer,
 };
 
 class CommTimeoutCbPtrFun:public CallDialer,
-            public CommDialerParamsT<CommTimeoutCbParams>
+        public CommDialerParamsT<CommTimeoutCbParams>
 {
 public:
     typedef CommTimeoutCbParams Params;
@@ -10,7 +10,7 @@ DnsLookupDetails::DnsLookupDetails(): wait(-1)
 }
 
 DnsLookupDetails::DnsLookupDetails(const String &e, int w):
-    error(e), wait(w)
+        error(e), wait(w)
 {
 }
 
@@ -58,7 +58,7 @@ class HierarchyLogEntry
     struct timeval peer_select_start;
 
     struct timeval store_complete_stop;
-    
+
     http_status peer_reply_status; ///< last HTTP status code received
     timeval peer_http_request_sent; ///< last peer finished writing req
     int64_t peer_response_time; ///< last peer response delay
@@ -321,7 +321,7 @@ httpHeaderInitModule(void)
     httpHeaderCalcMask(&RequestHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
 
     httpHeaderMaskInit(&HopByHopHeadersMask, 0);
-    
+
     httpHeaderCalcMask(&HopByHopHeadersMask, HopByHopHeadersArr, countof(HopByHopHeadersArr));
 
     /* init header stats */
@@ -233,8 +233,7 @@ strListGetItem(const String * str, char del, const char **item, int *ilen, const
      * processing merged header values properly, even if Cookie normally
      * uses ';' as delimiter.
      */
-    static char delim[3][8] =
-    {
+    static char delim[3][8] = {
         "\"?,",
         "\"\\",
         " ?,\t\r\n"
@@ -263,12 +262,12 @@ strListGetItem(const String * str, char del, const char **item, int *ilen, const
         if (**pos == '"') {
             quoted = !quoted;
             *pos += 1;
-	} else if (quoted && **pos == '\\') {
+        } else if (quoted && **pos == '\\') {
             *pos += 1;
             if (**pos)
                 *pos += 1;
-	} else {
-	    break;		/* Delimiter found, marking the end of this value */
+        } else {
+            break;		/* Delimiter found, marking the end of this value */
         }
     } while (**pos);
 
@@ -99,13 +99,13 @@ class HttpMsg
     virtual bool inheritProperties(const HttpMsg *aMsg) = 0;
 
 protected:
-     /**
-      * Validate the message start line is syntactically correct.
-      * Set HTTP error status according to problems found.
-      *
-      * \retval true   Status line has no serious problems.
-      * \retval false  Status line has a serious problem. Correct response is indicated by error.
-      */
+    /**
+     * Validate the message start line is syntactically correct.
+     * Set HTTP error status according to problems found.
+     *
+     * \retval true   Status line has no serious problems.
+     * \retval false  Status line has a serious problem. Correct response is indicated by error.
+     */
     virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error) = 0;
 
     virtual void packFirstLineInto(Packer * p, bool full_uri) const = 0;
@@ -119,7 +119,8 @@ class HttpMsg
 };
 
 /* Temporary parsing state; might turn into the replacement parser later on */
-class HttpParser {
+class HttpParser
+{
 public:
     char state;
     const char *buf;
@@ -377,12 +377,12 @@ request_flags::clearResetTCP()
 }
 
 #if ICAP_CLIENT
-Adaptation::Icap::History::Pointer 
+Adaptation::Icap::History::Pointer
 HttpRequest::icapHistory() const
 {
     if (!icapHistory_) {
         if ((LogfileStatus == LOG_ENABLE && alLogformatHasIcapToken) ||
-            IcapLogfileStatus == LOG_ENABLE) {
+                IcapLogfileStatus == LOG_ENABLE) {
             icapHistory_ = new Adaptation::Icap::History();
             debugs(93,4, HERE << "made " << icapHistory_ << " for " << this);
         }
@@ -393,7 +393,7 @@ HttpRequest::icapHistory() const
 #endif
 
 #if USE_ADAPTATION
-Adaptation::History::Pointer 
+Adaptation::History::Pointer
 HttpRequest::adaptHistory(bool createIfNone) const
 {
     if (!adaptHistory_ && createIfNone) {
@@ -404,11 +404,11 @@ HttpRequest::adaptHistory(bool createIfNone) const
     return adaptHistory_;
 }
 
-Adaptation::History::Pointer 
+Adaptation::History::Pointer
 HttpRequest::adaptLogHistory() const
 {
     const bool loggingNeedsHistory = (LogfileStatus == LOG_ENABLE) &&
-        alLogformatHasAdaptToken; // TODO: make global to remove this method?
+                                     alLogformatHasAdaptToken; // TODO: make global to remove this method?
     return HttpRequest::adaptHistory(loggingNeedsHistory);
 }
 
@@ -176,8 +176,8 @@ ServerStateData::serverComplete()
 
     HttpRequest *r = originalRequest();
     r->hier.total_response_time = r->hier.first_conn_start.tv_sec ?
-        tvSubMsec(r->hier.first_conn_start, current_time) : -1;
-    
+                                  tvSubMsec(r->hier.first_conn_start, current_time) : -1;
+
     if (requestBodySource != NULL)
         stopConsumingFrom(requestBodySource);
 
@@ -529,7 +529,7 @@ ServerStateData::startAdaptation(const Adaptation::ServiceGroupPointer &group, H
     }
 
     adaptedHeadSource = initiateAdaptation(
-        new Adaptation::Iterator(this, vrep, cause, group));
+                            new Adaptation::Iterator(this, vrep, cause, group));
     startedAdaptation = adaptedHeadSource != NULL;
     Must(startedAdaptation);
 }
@@ -56,10 +56,10 @@
  */
 class ServerStateData:
 #if USE_ADAPTATION
-            public Adaptation::Initiator,
-            public BodyProducer,
+        public Adaptation::Initiator,
+        public BodyProducer,
 #endif
-            public BodyConsumer
+        public BodyConsumer
 {
 
 public:
@@ -207,7 +207,7 @@ class NullStoreEntry:public StoreEntry
 
     bool isEmpty () const {return true;}
 
-    virtual size_t bytesWanted(Range<size_t> const aRange) const { assert (aRange.size());return aRange.end - 1;}
+    virtual size_t bytesWanted(Range<size_t> const aRange) const { assert (aRange.size()); return aRange.end - 1;}
 
     void operator delete(void *address);
     void complete() {}
@@ -3,13 +3,13 @@
 
 TextException::TextException()
 {
-	message=NULL;
-	theFileName=NULL;
-	theLineNo=0;
+    message=NULL;
+    theFileName=NULL;
+    theLineNo=0;
 }
 
 TextException::TextException(const TextException& right) :
-	message((right.message?xstrdup(right.message):NULL)), theFileName(right.theFileName), theLineNo(right.theLineNo)
+        message((right.message?xstrdup(right.message):NULL)), theFileName(right.theFileName), theLineNo(right.theLineNo)
 {
 }
 
@@ -19,18 +19,18 @@ TextException::TextException(const char *aMsg, const char *aFileName, int aLineN
 
 TextException::~TextException() throw()
 {
-    if(message) xfree(message);
+    if (message) xfree(message);
 }
 
 TextException& TextException::operator=(const TextException &right)
 {
-	if(this==&right) return *this;
-	if(message) xfree(message);
+    if (this==&right) return *this;
+    if (message) xfree(message);
     message=(right.message?xstrdup(right.message):NULL);
     theFileName=right.theFileName;
     theLineNo=right.theLineNo;
 
-	return *this;	
+    return *this;
 }
 
 const char *TextException::what() const throw()
@@ -20,7 +20,7 @@ class TextException: public std::exception
 
     virtual const char *what() const throw();
 
-	TextException& operator=(const TextException &right);
+    TextException& operator=(const TextException &right);
 
 public:
     char *message; // read-only
@@ -402,7 +402,7 @@ typedef enum {
     LTF_ADAPTATION_ALL_XACT_TIMES,
 #endif
 
-#if ICAP_CLIENT    
+#if ICAP_CLIENT
 
     LFT_ICAP_TOTAL_TIME,
     LFT_ICAP_LAST_MATCHED_HEADER,
@@ -415,15 +415,15 @@ typedef enum {
     LFT_ICAP_REQUEST_METHOD,
     LFT_ICAP_BYTES_SENT,
     LFT_ICAP_BYTES_READ,
-    
+
     LFT_ICAP_REQ_HEADER,
     LFT_ICAP_REQ_HEADER_ELEM,
     LFT_ICAP_REQ_ALL_HEADERS,
-    
+
     LFT_ICAP_REP_HEADER,
     LFT_ICAP_REP_HEADER_ELEM,
     LFT_ICAP_REP_ALL_HEADERS,
-    
+
     LFT_ICAP_TR_RESPONSE_TIME,
     LFT_ICAP_IO_TIME,
     LFT_ICAP_OUTCOME,
@@ -623,7 +623,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             if (al->cache.caddr.IsAnyAddr()) // e.g., ICAP OPTIONS lack client
                 out = "-";
             else
-            out = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
+                out = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
             if (!out) {
                 out = al->cache.caddr.NtoA(tmp,1024);
             }
@@ -704,7 +704,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             doint = 1;
             break;
 
-    case LFT_PEER_RESPONSE_TIME:
+        case LFT_PEER_RESPONSE_TIME:
             if (al->hier.peer_response_time < 0) {
                 out = "-";
             } else {
@@ -770,7 +770,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             break;
 #endif
 
-#if ICAP_CLIENT            
+#if ICAP_CLIENT
         case LFT_ICAP_LAST_MATCHED_HEADER:
             if (al->request) {
                 Adaptation::Icap::History::Pointer ih = al->request->icapHistory();
@@ -806,7 +806,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
         case LFT_ICAP_ADDR:
             if (!out)
-        out = al->icap.hostAddr.NtoA(tmp,1024);
+                out = al->icap.hostAddr.NtoA(tmp,1024);
             break;
 
         case LFT_ICAP_SERV_NAME:
@@ -881,7 +881,7 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
 
             break;
 
-        case LFT_ICAP_REP_ALL_HEADERS: 
+        case LFT_ICAP_REP_ALL_HEADERS:
             if (al->icap.reply) {
                 HttpHeaderPos pos = HttpHeaderInitPos;
                 while (const HttpHeaderEntry *e = al->icap.reply->header.getEntry(&pos)) {
@@ -997,8 +997,8 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             /* case LFT_USER_REALM: */
             /* case LFT_USER_SCHEME: */
 
-        // the fmt->type can not be LFT_HTTP_SENT_STATUS_CODE_OLD_30
-        // but compiler complains if ommited
+            // the fmt->type can not be LFT_HTTP_SENT_STATUS_CODE_OLD_30
+            // but compiler complains if ommited
         case LFT_HTTP_SENT_STATUS_CODE_OLD_30:
         case LFT_HTTP_SENT_STATUS_CODE:
             outint = al->http.code;
@@ -1008,10 +1008,9 @@ accessLogCustom(AccessLogEntry * al, customlog * log)
             break;
 
         case LFT_HTTP_RECEIVED_STATUS_CODE:
-            if(al->hier.peer_reply_status == HTTP_STATUS_NONE) {
+            if (al->hier.peer_reply_status == HTTP_STATUS_NONE) {
                 out = "-";
-            }
-            else {
+            } else {
                 outint = al->hier.peer_reply_status;
                 doint = 1;
             }
@@ -1317,12 +1316,12 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
             cur++;
     }
 
-    // For upward compatibility, assume "http::" prefix as default prefix 
+    // For upward compatibility, assume "http::" prefix as default prefix
     // for all log access formating codes, except those starting
     // from "icap::", "adapt::" and "%"
     if (strncmp(cur,"http::", 6) == 0 &&
-        strncmp(cur+6, "icap::", 6) != 0  &&
-        strncmp(cur+6, "adapt::", 12) != 0 && *(cur+6) != '%' ) {
+            strncmp(cur+6, "icap::", 6) != 0  &&
+            strncmp(cur+6, "adapt::", 12) != 0 && *(cur+6) != '%' ) {
         cur += 6;
     }
 
@@ -1350,7 +1349,7 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
 
     switch (lt->type) {
 
-#if ICAP_CLIENT    
+#if ICAP_CLIENT
     case LFT_ICAP_LAST_MATCHED_HEADER:
 
     case LFT_ICAP_REQ_HEADER:
@@ -1376,29 +1375,51 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
 
                 lt->data.header.element = cp;
 
-                switch(lt->type) {
-                case LFT_REQUEST_HEADER: lt->type = LFT_REQUEST_HEADER_ELEM; break;
-                case LFT_REPLY_HEADER: lt->type = LFT_REPLY_HEADER_ELEM; break;
+                switch (lt->type) {
+                case LFT_REQUEST_HEADER:
+                    lt->type = LFT_REQUEST_HEADER_ELEM;
+                    break;
+                case LFT_REPLY_HEADER:
+                    lt->type = LFT_REPLY_HEADER_ELEM;
+                    break;
 #if ICAP_CLIENT
-                case LFT_ICAP_LAST_MATCHED_HEADER: lt->type = LFT_ICAP_LAST_MATCHED_HEADER_ELEM; break;
-                case LFT_ICAP_REQ_HEADER: lt->type = LFT_ICAP_REQ_HEADER_ELEM; break; 
-                case LFT_ICAP_REP_HEADER: lt->type = LFT_ICAP_REP_HEADER_ELEM; break;
+                case LFT_ICAP_LAST_MATCHED_HEADER:
+                    lt->type = LFT_ICAP_LAST_MATCHED_HEADER_ELEM;
+                    break;
+                case LFT_ICAP_REQ_HEADER:
+                    lt->type = LFT_ICAP_REQ_HEADER_ELEM;
+                    break;
+                case LFT_ICAP_REP_HEADER:
+                    lt->type = LFT_ICAP_REP_HEADER_ELEM;
+                    break;
 #endif
-                default:break;
+                default:
+                    break;
                 }
             }
 
             lt->data.header.header = header;
         } else {
-            switch(lt->type) {
-            case LFT_REQUEST_HEADER: lt->type = LFT_REQUEST_ALL_HEADERS; break;
-            case LFT_REPLY_HEADER: lt->type = LFT_REPLY_ALL_HEADERS; break;
+            switch (lt->type) {
+            case LFT_REQUEST_HEADER:
+                lt->type = LFT_REQUEST_ALL_HEADERS;
+                break;
+            case LFT_REPLY_HEADER:
+                lt->type = LFT_REPLY_ALL_HEADERS;
+                break;
 #if ICAP_CLIENT
-            case LFT_ICAP_LAST_MATCHED_HEADER: lt->type = LFT_ICAP_LAST_MATCHED_ALL_HEADERS; break;
-            case LFT_ICAP_REQ_HEADER: lt->type = LFT_ICAP_REQ_ALL_HEADERS; break; 
-            case LFT_ICAP_REP_HEADER: lt->type = LFT_ICAP_REP_ALL_HEADERS; break;
+            case LFT_ICAP_LAST_MATCHED_HEADER:
+                lt->type = LFT_ICAP_LAST_MATCHED_ALL_HEADERS;
+                break;
+            case LFT_ICAP_REQ_HEADER:
+                lt->type = LFT_ICAP_REQ_ALL_HEADERS;
+                break;
+            case LFT_ICAP_REP_HEADER:
+                lt->type = LFT_ICAP_REP_ALL_HEADERS;
+                break;
 #endif
-            default:break;
+            default:
+                break;
             }
             Config.onoff.log_mime_hdrs = 1;
         }
@@ -1427,7 +1448,7 @@ accessLogGetNewLogFormatToken(logformat_token * lt, char *def, enum log_quote *q
 
     case LFT_HTTP_SENT_STATUS_CODE_OLD_30:
         debugs(46, 0, "WARNING: the \"Hs\" formating code is deprecated use the \">Hs\" instead");
-	lt->type = LFT_HTTP_SENT_STATUS_CODE;
+        lt->type = LFT_HTTP_SENT_STATUS_CODE;
         break;
     default:
         break;
@@ -1506,15 +1527,26 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
 
                     arg = argbuf;
 
-                    switch(type) {
-                    case LFT_REQUEST_HEADER_ELEM: type = LFT_REQUEST_HEADER_ELEM; break;
-                    case LFT_REPLY_HEADER_ELEM: type = LFT_REPLY_HEADER_ELEM; break;
+                    switch (type) {
+                    case LFT_REQUEST_HEADER_ELEM:
+                        type = LFT_REQUEST_HEADER_ELEM;
+                        break;
+                    case LFT_REPLY_HEADER_ELEM:
+                        type = LFT_REPLY_HEADER_ELEM;
+                        break;
 #if ICAP_CLIENT
-                    case LFT_ICAP_LAST_MATCHED_HEADER_ELEM: type = LFT_ICAP_LAST_MATCHED_HEADER; break;
-                    case LFT_ICAP_REQ_HEADER_ELEM: type = LFT_ICAP_REQ_HEADER; break; 
-                    case LFT_ICAP_REP_HEADER_ELEM: type = LFT_ICAP_REP_HEADER; break;
+                    case LFT_ICAP_LAST_MATCHED_HEADER_ELEM:
+                        type = LFT_ICAP_LAST_MATCHED_HEADER;
+                        break;
+                    case LFT_ICAP_REQ_HEADER_ELEM:
+                        type = LFT_ICAP_REQ_HEADER;
+                        break;
+                    case LFT_ICAP_REP_HEADER_ELEM:
+                        type = LFT_ICAP_REP_HEADER;
+                        break;
 #endif
-                    default:break;
+                    default:
+                        break;
                     }
 
                     break;
@@ -1529,15 +1561,26 @@ accessLogDumpLogFormat(StoreEntry * entry, const char *name, logformat * definit
                 case LFT_ICAP_REP_ALL_HEADERS:
 #endif
 
-                    switch(type) {
-                    case LFT_REQUEST_ALL_HEADERS: type = LFT_REQUEST_HEADER; break;
-                    case LFT_REPLY_ALL_HEADERS: type = LFT_REPLY_HEADER; break;
+                    switch (type) {
+                    case LFT_REQUEST_ALL_HEADERS:
+                        type = LFT_REQUEST_HEADER;
+                        break;
+                    case LFT_REPLY_ALL_HEADERS:
+                        type = LFT_REPLY_HEADER;
+                        break;
 #if ICAP_CLIENT
-                    case LFT_ICAP_LAST_MATCHED_ALL_HEADERS: type = LFT_ICAP_LAST_MATCHED_HEADER; break;
-                    case LFT_ICAP_REQ_ALL_HEADERS: type = LFT_ICAP_REQ_HEADER; break; 
-                    case LFT_ICAP_REP_ALL_HEADERS: type = LFT_ICAP_REP_HEADER; break;
+                    case LFT_ICAP_LAST_MATCHED_ALL_HEADERS:
+                        type = LFT_ICAP_LAST_MATCHED_HEADER;
+                        break;
+                    case LFT_ICAP_REQ_ALL_HEADERS:
+                        type = LFT_ICAP_REQ_HEADER;
+                        break;
+                    case LFT_ICAP_REP_ALL_HEADERS:
+                        type = LFT_ICAP_REP_HEADER;
+                        break;
 #endif
-                    default:break;
+                    default:
+                        break;
                     }
 
                     break;
@@ -1776,24 +1819,24 @@ accessLogICAPSquid(AccessLogEntry * al, Logfile * logfile)
     if (user && !*user)
         safe_free(user);
 
-        logfilePrintf(logfile, "%9ld.%03d %6d %s -/%03d %"PRId64" %s %s %s -/%s -\n",
-                      (long int) current_time.tv_sec,
-                      (int) current_time.tv_usec / 1000,
+    logfilePrintf(logfile, "%9ld.%03d %6d %s -/%03d %"PRId64" %s %s %s -/%s -\n",
+                  (long int) current_time.tv_sec,
+                  (int) current_time.tv_usec / 1000,
 
-                      al->icap.trTime,
-                      client,
+                  al->icap.trTime,
+                  client,
 
-                      al->icap.resStatus,
-                      al->icap.bytesRead,
-                      Adaptation::Icap::ICAP::methodStr(al->icap.reqMethod),
-                      al->icap.reqUri.termedBuf(),
-                      user ? user : dash_str,
-                      al->icap.hostAddr.NtoA(tmp, MAX_IPSTRLEN));
+                  al->icap.resStatus,
+                  al->icap.bytesRead,
+                  Adaptation::Icap::ICAP::methodStr(al->icap.reqMethod),
+                  al->icap.reqUri.termedBuf(),
+                  user ? user : dash_str,
+                  al->icap.hostAddr.NtoA(tmp, MAX_IPSTRLEN));
     safe_free(user);
 }
 #endif
 
-void 
+void
 accessLogLogTo(customlog* log, AccessLogEntry * al, ACLChecklist * checklist)
 {
 
@@ -1874,7 +1917,7 @@ accessLogLog(AccessLogEntry * al, ACLChecklist * checklist)
 {
     if (LogfileStatus != LOG_ENABLE)
         return;
-    
+
     accessLogLogTo(Config.Log.accesslogs, al, checklist);
 #if MULTICAST_MISS_STREAM
 
@@ -2010,19 +2053,17 @@ accessLogInit(void)
 #if USE_ADAPTATION || ICAP_CLIENT
         alLogformatHasAdaptToken = false;
         alLogformatHasIcapToken = false;
-        for (logformat_token * curr_token = (log->logFormat?log->logFormat->format:NULL); curr_token; curr_token = curr_token->next)
-        {
+        for (logformat_token * curr_token = (log->logFormat?log->logFormat->format:NULL); curr_token; curr_token = curr_token->next) {
 #if USE_ADAPTATION
             if (curr_token->type == LTF_ADAPTATION_SUM_XACT_TIMES ||
-                curr_token->type == LTF_ADAPTATION_ALL_XACT_TIMES) {
+                    curr_token->type == LTF_ADAPTATION_ALL_XACT_TIMES) {
                 alLogformatHasAdaptToken = true;
             }
-#endif    
+#endif
 #if ICAP_CLIENT
             if (curr_token->type == LFT_ICAP_LAST_MATCHED_HEADER ||
-                curr_token->type == LFT_ICAP_LAST_MATCHED_HEADER_ELEM ||
-                curr_token->type == LFT_ICAP_LAST_MATCHED_ALL_HEADERS)
-            {
+                    curr_token->type == LFT_ICAP_LAST_MATCHED_HEADER_ELEM ||
+                    curr_token->type == LFT_ICAP_LAST_MATCHED_ALL_HEADERS) {
                 alLogformatHasIcapToken = true;
             }
 #endif
@@ -91,7 +91,7 @@ ACLMethodData::parse()
 
     for (Tail = &values; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-        if(strcmp(t, "PURGE") == 0)
+        if (strcmp(t, "PURGE") == 0)
             ++ThePurgeCount; // configuration code wants to know
         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));
         *(Tail) = q;
@@ -24,7 +24,7 @@ Adaptation::AccessCheck::Start(Method method, VectPoint vp,
     if (Config::Enabled) {
         // the new check will call the callback and delete self, eventually
         return AsyncStart(new AccessCheck(
-            ServiceFilter(method, vp, req, rep), cb, cbdata));
+                              ServiceFilter(method, vp, req, rep), cb, cbdata));
     }
 
     debugs(83, 3, HERE << "adaptation off, skipping");
@@ -34,10 +34,10 @@ Adaptation::AccessCheck::Start(Method method, VectPoint vp,
 Adaptation::AccessCheck::AccessCheck(const ServiceFilter &aFilter,
                                      AccessCheckCallback *aCallback,
                                      void *aCallbackData):
-    AsyncJob("AccessCheck"), filter(aFilter),
-    callback(aCallback),
-    callback_data(cbdataReference(aCallbackData)),
-    acl_checklist(NULL)
+        AsyncJob("AccessCheck"), filter(aFilter),
+        callback(aCallback),
+        callback_data(cbdataReference(aCallbackData)),
+        acl_checklist(NULL)
 {
 #if ICAP_CLIENT
     Adaptation::Icap::History::Pointer h = filter.request->icapHistory();
@@ -46,7 +46,7 @@ Adaptation::AccessCheck::AccessCheck(const ServiceFilter &aFilter,
 #endif
 
     debugs(93, 5, HERE << "AccessCheck constructed for " <<
-        methodStr(filter.method) << " " << vectPointStr(filter.point));
+           methodStr(filter.method) << " " << vectPointStr(filter.point));
 }
 
 Adaptation::AccessCheck::~AccessCheck()
@@ -61,9 +61,10 @@ Adaptation::AccessCheck::~AccessCheck()
 }
 
 void
-Adaptation::AccessCheck::start() {
-	AsyncJob::start();
-	check();
+Adaptation::AccessCheck::start()
+{
+    AsyncJob::start();
+    check();
 }
 
 /// Walk the access rules list to find rules with applicable service groups
@@ -184,7 +185,7 @@ bool
 Adaptation::AccessCheck::isCandidate(AccessRule &r)
 {
     debugs(93,7,HERE << "checking candidacy of " << r.id << ", group " <<
-        r.groupId);
+           r.groupId);
 
     ServiceGroupPointer g = FindGroup(r.groupId);
 
@@ -54,7 +54,7 @@ Adaptation::Config::parseService()
     ServiceConfig *cfg = new ServiceConfig;
     if (!cfg->parse()) {
         fatalf("%s:%d: malformed adaptation service configuration",
-            cfg_filename, config_lineno);
+               cfg_filename, config_lineno);
     }
     serviceConfigs.push_back(cfg);
 }
@@ -10,12 +10,12 @@
 const static char *TheNullServices = ",null,";
 
 Adaptation::History::Entry::Entry(const String &sid, const timeval &when):
-    service(sid), start(when), theRptm(-1), retried(false)
+        service(sid), start(when), theRptm(-1), retried(false)
 {
 }
 
 Adaptation::History::Entry::Entry():
-    start(current_time), theRptm(-1), retried(false)
+        start(current_time), theRptm(-1), retried(false)
 {
 }
 
@@ -33,7 +33,8 @@ int Adaptation::History::Entry::rptm()
 }
 
 
-Adaptation::History::History(): theNextServices(TheNullServices) {
+Adaptation::History::History(): theNextServices(TheNullServices)
+{
 }
 
 int Adaptation::History::recordXactStart(const String &sid, const timeval &when, bool retrying)
@@ -82,8 +83,7 @@ void Adaptation::History::sumLogString(const char *serviceId, String &s)
     for (ECI i = theEntries.begin(); i != theEntries.end(); ++i) {
         if (i->retried) { // do not log retried xact but accumulate their time
             retriedRptm += i->rptm();
-        } else
-        if (!serviceId || i->service == serviceId) {
+        } else if (!serviceId || i->service == serviceId) {
             if (s.size() > 0) // not the first logged time, must delimit
                 s.append(",");
 
@@ -99,7 +99,7 @@ void Adaptation::History::sumLogString(const char *serviceId, String &s)
     }
 
     // the last transaction is never retried or it would not be the last
-    Must(!retriedRptm); 
+    Must(!retriedRptm);
 }
 
 void Adaptation::History::updateXxRecord(const char *name, const String &value)
@@ -111,7 +111,7 @@ void Adaptation::History::updateXxRecord(const char *name, const String &value)
 bool Adaptation::History::getXxRecord(String &name, String &value) const
 {
     if (theXxName.size() <= 0)
-       return false;
+        return false;
 
     name = theXxName;
     value = theXxValue;
@@ -121,7 +121,7 @@ bool Adaptation::History::getXxRecord(String &name, String &value) const
 void Adaptation::History::updateNextServices(const String &services)
 {
     if (theNextServices != TheNullServices)
-       debugs(93,3, HERE << "old services: " << theNextServices);
+        debugs(93,3, HERE << "old services: " << theNextServices);
     debugs(93,3, HERE << "new services: " << services);
     Must(services != TheNullServices);
     theNextServices = services;
@@ -130,7 +130,7 @@ void Adaptation::History::updateNextServices(const String &services)
 bool Adaptation::History::extractNextServices(String &value)
 {
     if (theNextServices == TheNullServices)
-       return false;
+        return false;
 
     value = theNextServices;
     theNextServices = TheNullServices; // prevents resetting the plan twice
@@ -5,11 +5,13 @@
 #include "Array.h"
 #include "SquidString.h"
 
-namespace Adaptation {
+namespace Adaptation
+{
 
 
 /// collects information about adaptations related to a master transaction
-class History: public RefCountable {
+class History: public RefCountable
+{
 public:
     typedef RefCount<Adaptation::History> Pointer;
 
@@ -41,7 +43,8 @@ class History: public RefCountable {
 
 private:
     /// single Xaction stats (i.e., a historical record entry)
-    class Entry {
+    class Entry
+    {
     public:
         Entry(const String &serviceId, const timeval &when);
         Entry(); // required by Vector<>
@@ -58,8 +61,8 @@ class History: public RefCountable {
     public:
         bool retried; ///< whether the xaction was replaced by another
     };
-    
-    typedef Vector<Entry> Entries;  
+
+    typedef Vector<Entry> Entries;
     Entries theEntries; ///< historical record, in the order of xact starts
 
     // theXx* will become a map<string,string>, but we only support one record
@@ -30,7 +30,7 @@ class AnswerDialer: public UnaryMemFunT<Initiator, HttpMsg*>
 /* Initiate */
 
 Adaptation::Initiate::Initiate(const char *aTypeName, Initiator *anInitiator):
-    AsyncJob(aTypeName), theInitiator(anInitiator)
+        AsyncJob(aTypeName), theInitiator(anInitiator)
 {
     assert(theInitiator);
 }
@@ -15,16 +15,16 @@
 
 
 Adaptation::Iterator::Iterator(Adaptation::Initiator *anInitiator,
-    HttpMsg *aMsg, HttpRequest *aCause,
-    const ServiceGroupPointer &aGroup):
-    AsyncJob("Iterator"),
-    Adaptation::Initiate("Iterator", anInitiator),
-    theGroup(aGroup),
-    theMsg(HTTPMSGLOCK(aMsg)),
-    theCause(aCause ? HTTPMSGLOCK(aCause) : NULL),
-    theLauncher(0),
-    iterations(0),
-    adapted(false)
+                               HttpMsg *aMsg, HttpRequest *aCause,
+                               const ServiceGroupPointer &aGroup):
+        AsyncJob("Iterator"),
+        Adaptation::Initiate("Iterator", anInitiator),
+        theGroup(aGroup),
+        theMsg(HTTPMSGLOCK(aMsg)),
+        theCause(aCause ? HTTPMSGLOCK(aCause) : NULL),
+        theLauncher(0),
+        iterations(0),
+        adapted(false)
 {
 }
 
@@ -58,9 +58,9 @@ void Adaptation::Iterator::step()
 
     if (iterations > Adaptation::Config::service_iteration_limit) {
         debugs(93,DBG_CRITICAL, "Adaptation iterations limit (" <<
-            Adaptation::Config::service_iteration_limit << ") exceeded:\n" <<
-            "\tPossible service loop with " <<
-            theGroup->kind << " " << theGroup->id << ", plan=" << thePlan);
+               Adaptation::Config::service_iteration_limit << ") exceeded:\n" <<
+               "\tPossible service loop with " <<
+               theGroup->kind << " " << theGroup->id << ", plan=" << thePlan);
         throw TexcHere("too many adaptations");
     }
 
@@ -69,7 +69,7 @@ void Adaptation::Iterator::step()
     debugs(93,5, HERE << "using adaptation service: " << service->cfg().key);
 
     theLauncher = initiateAdaptation(
-        service->makeXactLauncher(this, theMsg, theCause));
+                      service->makeXactLauncher(this, theMsg, theCause));
     Must(theLauncher);
     Must(!done());
 }
@@ -113,8 +113,8 @@ void Adaptation::Iterator::noteAdaptationQueryAbort(bool final)
     updatePlan(false);
 
     // can we replace the failed service (group-level bypass)?
-    const bool srcIntact = !theMsg->body_pipe || 
-        !theMsg->body_pipe->consumedSize();
+    const bool srcIntact = !theMsg->body_pipe ||
+                           !theMsg->body_pipe->consumedSize();
     // can we ignore the failure (compute while thePlan is not exhausted)?
     Must(!thePlan.exhausted());
     const bool canIgnore = thePlan.current()->cfg().bypass;
@@ -176,7 +176,7 @@ bool Adaptation::Iterator::updatePlan(bool adopt)
         debugs(85,3, HERE << "rejecting service-proposed plan");
         return false;
     }
-  
+
     debugs(85,3, HERE << "retiring old plan: " << thePlan);
     theGroup = new DynamicServiceChain(services, theGroup); // refcounted
     thePlan = ServicePlan(theGroup, filter());
@@ -196,8 +196,7 @@ Adaptation::ServiceFilter Adaptation::Iterator::filter() const
         method = methodReqmod;
         req = r;
         rep = NULL;
-    } else
-    if (HttpReply *r = dynamic_cast<HttpReply*>(theMsg)) {
+    } else if (HttpReply *r = dynamic_cast<HttpReply*>(theMsg)) {
         method = methodRespmod;
         req = theCause;
         rep = r;
@@ -14,16 +14,16 @@ namespace Adaptation
 
    Note: Initiate must be the first parent for cbdata to work. We use
    a temporary InitiatorHolder/toCbdata hacks and do not call cbdata
-   operations on the initiator directly. 
+   operations on the initiator directly.
 */
 
 /// iterates services in ServiceGroup, starting adaptation launchers
 class Iterator: public Initiate, public Initiator
 {
 public:
-    Iterator(Adaptation::Initiator *anInitiator, 
-        HttpMsg *virginHeader, HttpRequest *virginCause,
-        const Adaptation::ServiceGroupPointer &aGroup);
+    Iterator(Adaptation::Initiator *anInitiator,
+             HttpMsg *virginHeader, HttpRequest *virginCause,
+             const Adaptation::ServiceGroupPointer &aGroup);
     virtual ~Iterator();
 
     // Adaptation::Initiate: asynchronous communication with the initiator
@@ -7,8 +7,8 @@
 #include "adaptation/ServiceConfig.h"
 
 Adaptation::ServiceConfig::ServiceConfig():
-    port(-1), method(methodNone), point(pointNone),
-    bypass(false), routing(false)
+        port(-1), method(methodNone), point(pointNone),
+        bypass(false), routing(false)
 {}
 
 const char *
@@ -91,12 +91,11 @@ Adaptation::ServiceConfig::parse()
         bool grokked = false;
         if (strcmp(name, "bypass") == 0)
             grokked = grokBool(bypass, name, value);
-        else
-        if (strcmp(name, "routing") == 0)
+        else if (strcmp(name, "routing") == 0)
             grokked = grokBool(routing, name, value);
         else {
             debugs(3, 0, cfg_filename << ':' << config_lineno << ": " <<
-                "unknown adaptation service option: " << name << '=' << value);
+                   "unknown adaptation service option: " << name << '=' << value);
         }
         if (!grokked)
             return false;
@@ -109,15 +108,15 @@ Adaptation::ServiceConfig::parse()
     // there should be nothing else left
     if (const char *tail = strtok(NULL, w_space)) {
         debugs(3, 0, cfg_filename << ':' << config_lineno << ": " <<
-            "garbage after adaptation service URI: " << tail);
+               "garbage after adaptation service URI: " << tail);
         return false;
     }
 
     debugs(3,5, cfg_filename << ':' << config_lineno << ": " <<
-        "adaptation_service " << key << ' ' <<
-            methodStr() << "_" << vectPointStr() << ' ' <<
-            bypass << routing << ' ' <<
-            uri);
+           "adaptation_service " << key << ' ' <<
+           methodStr() << "_" << vectPointStr() << ' ' <<
+           bypass << routing << ' ' <<
+           uri);
 
     return true;
 }
@@ -210,8 +209,7 @@ Adaptation::ServiceConfig::grokBool(bool &var, const char *name, const char *val
 {
     if (!strcmp(value, "0") || !strcmp(value, "off"))
         var = false;
-    else
-    if (!strcmp(value, "1") || !strcmp(value, "on"))
+    else if (!strcmp(value, "1") || !strcmp(value, "on"))
         var = true;
     else {
         debugs(3, 0, HERE << cfg_filename << ':' << config_lineno << ": " <<
@@ -37,7 +37,7 @@ class ServiceConfig
 protected:
     Method parseMethod(const char *buf) const;
     VectPoint parseVectPoint(const char *buf) const;
- 
+
     /// interpret parsed values
     bool grokBool(bool &var, const char *name, const char *value);
     bool grokUri(const char *value);
@@ -5,18 +5,18 @@
 
 
 Adaptation::ServiceFilter::ServiceFilter(Method aMethod, VectPoint aPoint,
-HttpRequest *aReq, HttpReply *aRep): method(aMethod), point(aPoint),
-    request(HTTPMSGLOCK(aReq)),
-    reply(aRep ? HTTPMSGLOCK(aRep) : NULL)
+        HttpRequest *aReq, HttpReply *aRep): method(aMethod), point(aPoint),
+        request(HTTPMSGLOCK(aReq)),
+        reply(aRep ? HTTPMSGLOCK(aRep) : NULL)
 {
     // a lot of code assumes that there is always a virgin request or cause
     assert(request);
 }
 
 Adaptation::ServiceFilter::ServiceFilter(const ServiceFilter &f):
-    method(f.method), point(f.point),
-    request(HTTPMSGLOCK(f.request)),
-    reply(f.reply ? HTTPMSGLOCK(f.reply) : NULL)
+        method(f.method), point(f.point),
+        request(HTTPMSGLOCK(f.request)),
+        reply(f.reply ? HTTPMSGLOCK(f.reply) : NULL)
 {
 }
 
@@ -11,8 +11,8 @@
 #define ServiceGroup ServiceGroup
 
 Adaptation::ServiceGroup::ServiceGroup(const String &aKind, bool allSame):
-    kind(aKind), method(methodNone), point(pointNone),
-    allServicesSame(allSame)
+        kind(aKind), method(methodNone), point(pointNone),
+        allServicesSame(allSame)
 {
 }
 
@@ -48,7 +48,7 @@ Adaptation::ServiceGroup::finalize()
         const String &sid = services[pos];
         ServicePointer service = at(pos);
         if (service != NULL) {
-            if (method == methodNone) { 
+            if (method == methodNone) {
                 // optimization: cache values that should be the same
                 method = service->cfg().method;
                 point = service->cfg().point;
@@ -61,18 +61,17 @@ Adaptation::ServiceGroup::finalize()
 
             checkUniqueness(pos);
 
-            if (allServicesSame) { 
+            if (allServicesSame) {
                 if (!baselineKey.size()) {
                     baselineKey = service->cfg().key;
                     baselineBypass = service->cfg().bypass;
-                } else
-                if (baselineBypass != service->cfg().bypass) {
+                } else if (baselineBypass != service->cfg().bypass) {
                     debugs(93,0, "WARNING: Inconsistent bypass in " << kind <<
-                        ' ' << id << " may produce surprising results: " <<
-                        baselineKey << " vs. " << sid);
+                           ' ' << id << " may produce surprising results: " <<
+                           baselineKey << " vs. " << sid);
                 }
             }
-        } else { 
+        } else {
             finalizeMsg("ERROR: Unknown adaptation name", sid, true);
         }
     }
@@ -91,24 +90,24 @@ Adaptation::ServiceGroup::checkUniqueness(const Pos checkedPos) const
         ServicePointer s = at(p);
         if (s != NULL && s->cfg().key == checkedService->cfg().key)
             finalizeMsg("duplicate service name", s->cfg().key, false);
-        else
-        if (s != NULL && s->cfg().uri == checkedService->cfg().uri)
+        else if (s != NULL && s->cfg().uri == checkedService->cfg().uri)
             finalizeMsg("duplicate service URI", s->cfg().uri, false);
     }
 }
 
 /// emits a formatted warning or error message at the appropriate dbg level
 void
 Adaptation::ServiceGroup::finalizeMsg(const char *msg, const String &culprit,
-    bool error) const
+                                      bool error) const
 {
-    const int level = error ? DBG_CRITICAL : DBG_IMPORTANT;
+    const int level = error ? DBG_CRITICAL :DBG_IMPORTANT;
     const char *pfx = error ? "ERROR: " : "WARNING: ";
     debugs(93,level, pfx << msg << ' ' << culprit << " in " << kind << " '" <<
-        id << "'");
+           id << "'");
 }
 
-Adaptation::ServicePointer Adaptation::ServiceGroup::at(const Pos pos) const {
+Adaptation::ServicePointer Adaptation::ServiceGroup::at(const Pos pos) const
+{
     return FindService(services[pos]);
 }
 
@@ -213,7 +212,7 @@ Adaptation::ServiceChain::ServiceChain(): ServiceGroup("adaptation chain", false
 /* ServiceChain */
 
 Adaptation::DynamicServiceChain::DynamicServiceChain(const String &ids,
-    const ServiceGroupPointer prev)
+        const ServiceGroupPointer prev)
 {
     kind = "dynamic adaptation chain"; // TODO: optimize by using String const
     id = ids; // use services ids as the dynamic group ID
@@ -241,8 +240,8 @@ Adaptation::ServicePlan::ServicePlan(): pos(0), atEof(true)
 }
 
 Adaptation::ServicePlan::ServicePlan(const ServiceGroupPointer &g,
-    const ServiceFilter &filter):
-    group(g), pos(0), atEof(!g || !g->has(pos))
+                                     const ServiceFilter &filter):
+        group(g), pos(0), atEof(!g || !g->has(pos))
 {
     // this will find the first service because starting pos is zero
     if (!atEof && !group->findService(filter, pos))
@@ -257,14 +256,16 @@ Adaptation::ServicePlan::current() const
 }
 
 Adaptation::ServicePointer
-Adaptation::ServicePlan::replacement(const ServiceFilter &filter) {
+Adaptation::ServicePlan::replacement(const ServiceFilter &filter)
+{
     if (!atEof && !group->findReplacement(filter, ++pos))
         atEof = true;
     return current();
 }
 
 Adaptation::ServicePointer
-Adaptation::ServicePlan::next(const ServiceFilter &filter) {
+Adaptation::ServicePlan::next(const ServiceFilter &filter)
+{
     if (!atEof && !group->findLink(filter, ++pos))
         atEof = true;
     return current();
@@ -277,7 +278,7 @@ Adaptation::ServicePlan::print(std::ostream &os) const
         return os << "[nil]";
 
     return os << group->id << '[' << pos << ".." << group->services.size() <<
-        (atEof ? ".]" : "]");
+           (atEof ? ".]" : "]");
 }
 
 
@@ -81,7 +81,7 @@ class SingleService: public ServiceGroup
     SingleService(const String &aServiceKey);
 
 protected:
-    virtual bool replace(Pos &pos) const { return false; } 
+    virtual bool replace(Pos &pos) const { return false; }
     virtual bool advance(Pos &pos) const { return false; }
 };
 
@@ -92,7 +92,7 @@ class ServiceChain: public ServiceGroup
     ServiceChain();
 
 protected:
-    virtual bool replace(Pos &pos) const { return false; } 
+    virtual bool replace(Pos &pos) const { return false; }
     virtual bool advance(Pos &pos) const { return has(++pos); }
 };
 
@@ -106,7 +106,8 @@ class DynamicServiceChain: public ServiceChain
 
 /** iterates services stored in a group; iteration is not linear because we
     need to both replace failed services and advance to the next chain link */
-class ServicePlan {
+class ServicePlan
+{
 public:
     typedef unsigned int Pos; // Vector<>::poistion_type
 
@@ -11,7 +11,8 @@
 
 namespace Adaptation
 {
-namespace Ecap {
+namespace Ecap
+{
 
 class Config: public Adaptation::Config
 {
@@ -10,7 +10,8 @@
 
 namespace Adaptation
 {
-namespace Ecap {
+namespace Ecap
+{
 
 // Squid wrapper, providing host application functionality to eCAP services.
 class Host : public libecap::host::Host
@@ -348,11 +348,10 @@ Adaptation::Ecap::MessageRep::MessageRep(HttpMsg *rawHeader):
 
     if (HttpRequest *req = dynamic_cast<HttpRequest*>(theMessage.header))
         theFirstLineRep = new RequestLineRep(*req);
+    else if (HttpReply *rep = dynamic_cast<HttpReply*>(theMessage.header))
+        theFirstLineRep = new StatusLineRep(*rep);
     else
-        if (HttpReply *rep = dynamic_cast<HttpReply*>(theMessage.header))
-            theFirstLineRep = new StatusLineRep(*rep);
-        else
-            Must(false); // unknown message header type
+        Must(false); // unknown message header type
 
     theHeaderRep = new HeaderRep(*theMessage.header);
 
@@ -21,7 +21,8 @@ class HttpReply;
 
 namespace Adaptation
 {
-namespace Ecap {
+namespace Ecap
+{
 
 class XactionRep;
 
@@ -13,7 +13,8 @@
 
 namespace Adaptation
 {
-namespace Ecap {
+namespace Ecap
+{
 
 /* The eCAP service representative maintains information about a single eCAP
    service that Squid communicates with. One eCAP module may register many
@@ -20,7 +20,7 @@ Adaptation::Ecap::XactionRep::XactionRep(Adaptation::Initiator *anInitiator,
         theVirginRep(virginHeader), theCauseRep(NULL),
         proxyingVb(opUndecided), proxyingAb(opUndecided),
         adaptHistoryId(-1),
-		canAccessVb(false),
+        canAccessVb(false),
         abProductionFinished(false), abProductionAtEnd(false)
 {
     if (virginCause)
@@ -60,10 +60,10 @@ Adaptation::Ecap::XactionRep::start()
         proxyingVb = opNever;
 
     const HttpRequest *request = dynamic_cast<const HttpRequest*> (theCauseRep ?
-        theCauseRep->raw().header : theVirginRep.raw().header);
+                                 theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     Adaptation::History::Pointer ah = request->adaptLogHistory();
-    if (ah != NULL) { 
+    if (ah != NULL) {
         // retrying=false because ecap never retries transactions
         adaptHistoryId = ah->recordXactStart(service().cfg().key, current_time, false);
     }
@@ -96,7 +96,7 @@ Adaptation::Ecap::XactionRep::swanSong()
     terminateMaster();
 
     const HttpRequest *request = dynamic_cast<const HttpRequest*>(theCauseRep ?
-        theCauseRep->raw().header : theVirginRep.raw().header);
+                                 theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     Adaptation::History::Pointer ah = request->adaptLogHistory();
     if (ah != NULL && adaptHistoryId >= 0)
@@ -188,11 +188,10 @@ Adaptation::Ecap::XactionRep::useVirgin()
         stopConsumingFrom(vbody_pipe);
         canAccessVb = false;
         proxyingVb = opComplete;
-    } else
-        if (proxyingVb == opUndecided) {
-            vbody_pipe = NULL; // it is not our pipe anymore
-            proxyingVb = opNever;
-        }
+    } else if (proxyingVb == opUndecided) {
+        vbody_pipe = NULL; // it is not our pipe anymore
+        proxyingVb = opNever;
+    }
 
     sendAnswer(clone);
     Must(done());
@@ -410,8 +409,7 @@ Adaptation::Ecap::XactionRep::moveAbContent()
         stopProducingFor(answer().body_pipe, abProductionAtEnd);
         proxyingAb = opComplete;
         debugs(93,5, HERE << "last adapted body data retrieved");
-    } else
-    if (c.size > 0) {
+    } else if (c.size > 0) {
         if (const size_t used = answer().body_pipe->putMoreData(c.start, c.size))
             theMaster->abContentShift(used);
     }
@@ -18,13 +18,14 @@
 
 namespace Adaptation
 {
-namespace Ecap {
+namespace Ecap
+{
 
 /* The eCAP xaction representative maintains information about a single eCAP
    xaction that Squid communicates with. One eCAP module may register many
    eCAP xactions. */
 class XactionRep : public Adaptation::Initiate, public libecap::host::Xaction,
-            public BodyConsumer, public BodyProducer
+        public BodyConsumer, public BodyProducer
 {
 public:
     XactionRep(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, const Adaptation::ServicePointer &service);
@@ -39,7 +39,8 @@
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 extern void InitModule();
 extern void CleanModule();
@@ -45,7 +45,8 @@ class acl_access;
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 class ConfigParser;
 
@@ -2,8 +2,10 @@
 #include "adaptation/icap/Elements.h"
 
 // TODO: remove this file?
-namespace Adaptation {
-namespace Icap {
+namespace Adaptation
+{
+namespace Icap
+{
 
 const XactOutcome xoUnknown = "ICAP_ERR_UNKNOWN";
 const XactOutcome xoError = "ICAP_ERR_OTHER";
@@ -41,10 +41,12 @@
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 //TODO: remove the ICAP namespace
-namespace ICAP {
+namespace ICAP
+{
 using Adaptation::Method;
 using Adaptation::methodNone;
 using Adaptation::methodRespmod;
@@ -4,8 +4,8 @@
 #include "SquidTime.h"
 
 Adaptation::Icap::History::History(): mergeOfIcapHeaders(hoRequest),
-    lastIcapHeader(hoRequest), logType(LOG_TAG_NONE), req_sz(0),
-    pastTime(0), concurrencyLevel(0)
+        lastIcapHeader(hoRequest), logType(LOG_TAG_NONE), req_sz(0),
+        pastTime(0), concurrencyLevel(0)
 {
 }
 
@@ -21,7 +21,7 @@ Adaptation::Icap::History::~History()
     rfc931.clean();
 #if USE_SSL
     ssluser.clean();
-#endif 
+#endif
     log_uri.clean();
 }
 
@@ -65,16 +65,16 @@ void Adaptation::Icap::History::mergeIcapHeaders(const HttpHeader * lih)
     mergeOfIcapHeaders.compact();
 }
 
-void Adaptation::Icap::History::start(const char *context) 
+void Adaptation::Icap::History::start(const char *context)
 {
     if (!concurrencyLevel++)
         currentStart = current_time;
 
     debugs(93,4, HERE << "start " << context << " level=" << concurrencyLevel
-        << " time=" << pastTime << ' ' << this);
+           << " time=" << pastTime << ' ' << this);
 }
 
-void Adaptation::Icap::History::stop(const char *context) 
+void Adaptation::Icap::History::stop(const char *context)
 {
     if (!concurrencyLevel) {
         debugs(93,1, HERE << "Internal error: poor history accounting " << this);
@@ -83,8 +83,8 @@ void Adaptation::Icap::History::stop(const char *context)
 
     const int current = currentTime();
     debugs(93,4, HERE << "stop " << context << " level=" << concurrencyLevel <<
-        " time=" << pastTime << '+' << current << ' ' << this);
-    
+           " time=" << pastTime << '+' << current << ' ' << this);
+
     if (!--concurrencyLevel)
         pastTime += current;
 }
@@ -99,5 +99,5 @@ int Adaptation::Icap::History::processingTime() const
 int Adaptation::Icap::History::currentTime() const
 {
     return concurrencyLevel > 0 ?
-        max(0, tvSubMsec(currentStart, current_time)) : 0;
+           max(0, tvSubMsec(currentStart, current_time)) : 0;
 }
@@ -5,11 +5,14 @@
 #include "HttpHeader.h"
 #include "enums.h"
 
-namespace Adaptation {
-namespace Icap {
+namespace Adaptation
+{
+namespace Icap
+{
 
 /// collects information about ICAP processing related to an HTTP transaction
-class History: public RefCountable {
+class History: public RefCountable
+{
 public:
     typedef RefCount<History> Pointer;
 
@@ -46,7 +46,8 @@
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 class InOut
 {
@@ -72,28 +72,27 @@ void Adaptation::Icap::Launcher::noteAdaptationQueryAbort(bool final)
 {
     debugs(93,5, HERE << "launches: " << theLaunches << "; final: " << final);
     clearAdaptation(theXaction);
-       
+
     Must(done()); // swanSong will notify the initiator
 }
 
 void Adaptation::Icap::Launcher::noteXactAbort(XactAbortInfo &info)
 {
     debugs(93,5, HERE << "theXaction:" << theXaction << " launches: " << theLaunches);
 
-     // TODO: add more checks from FwdState::checkRetry()?
+    // TODO: add more checks from FwdState::checkRetry()?
     if (canRetry(info)) {
         clearAdaptation(theXaction);
         launchXaction("retry");
-    } 
-    else if (canRepeat(info)) {
+    } else if (canRepeat(info)) {
         clearAdaptation(theXaction);
         launchXaction("repeat");
     } else {
         debugs(93,3, HERE << "cannot retry or repeat a failed transaction");
         clearAdaptation(theXaction);
         tellQueryAborted(false); // caller decides based on bypass, consumption
         Must(done());
-    }   
+    }
 }
 
 bool Adaptation::Icap::Launcher::doneAll() const
@@ -132,15 +131,15 @@ bool Adaptation::Icap::Launcher::canRepeat(Adaptation::Icap::XactAbortInfo &info
     debugs(93,9, HERE << info.icapReply);
     if (!info.icapReply) // did not get to read an ICAP reply; a timeout?
         return true;
-       
+
     debugs(93,9, HERE << info.icapReply->sline.status);
     if (!info.icapReply->sline.status) // failed to parse the reply; I/O err
         return true;
-    
+
     ACLFilledChecklist *cl =
         new ACLFilledChecklist(TheConfig.repeat, info.icapRequest, dash_str);
     cl->reply = HTTPMSGLOCK(info.icapReply);
-    
+
     const bool result = cl->fastCheck();
     delete cl;
     return result;
@@ -149,17 +148,17 @@ bool Adaptation::Icap::Launcher::canRepeat(Adaptation::Icap::XactAbortInfo &info
 /* ICAPXactAbortInfo */
 
 Adaptation::Icap::XactAbortInfo::XactAbortInfo(HttpRequest *anIcapRequest,
-    HttpReply *anIcapReply, bool beRetriable, bool beRepeatable):
-    icapRequest(anIcapRequest ? HTTPMSGLOCK(anIcapRequest) : NULL),
-    icapReply(anIcapReply ? HTTPMSGLOCK(anIcapReply) : NULL),
-    isRetriable(beRetriable), isRepeatable(beRepeatable)
+        HttpReply *anIcapReply, bool beRetriable, bool beRepeatable):
+        icapRequest(anIcapRequest ? HTTPMSGLOCK(anIcapRequest) : NULL),
+        icapReply(anIcapReply ? HTTPMSGLOCK(anIcapReply) : NULL),
+        isRetriable(beRetriable), isRepeatable(beRepeatable)
 {
 }
 
 Adaptation::Icap::XactAbortInfo::XactAbortInfo(const Adaptation::Icap::XactAbortInfo &i):
-    icapRequest(i.icapRequest ? HTTPMSGLOCK(i.icapRequest) : NULL),
-    icapReply(i.icapReply ? HTTPMSGLOCK(i.icapReply) : NULL),
-    isRetriable(i.isRetriable), isRepeatable(i.isRepeatable)
+        icapRequest(i.icapRequest ? HTTPMSGLOCK(i.icapRequest) : NULL),
+        icapReply(i.icapReply ? HTTPMSGLOCK(i.icapReply) : NULL),
+        isRetriable(i.isRetriable), isRepeatable(i.isRepeatable)
 {
 }
 
@@ -61,7 +61,8 @@
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 class Xaction;
 class XactAbortInfo;
@@ -84,7 +85,7 @@ class Launcher: public Adaptation::Initiate, public Adaptation::Initiator
 
 private:
     bool canRetry(XactAbortInfo &info) const; //< true if can retry in the case of persistent connection failures
-    bool canRepeat(XactAbortInfo &info) const; //< true if can repeat in the case of no or unsatisfactory response 
+    bool canRepeat(XactAbortInfo &info) const; //< true if can repeat in the case of no or unsatisfactory response
     virtual void noteAdaptationQueryAbort(bool final);
 
 protected:
@@ -103,9 +104,10 @@ class Launcher: public Adaptation::Initiate, public Adaptation::Initiator
     int theLaunches; // the number of transaction launches
 };
 
-/// helper class to pass information about aborted ICAP requests to 
+/// helper class to pass information about aborted ICAP requests to
 /// the Adaptation::Icap::Launcher class
-class XactAbortInfo {
+class XactAbortInfo
+{
 public:
     XactAbortInfo(HttpRequest *anIcapRequest, HttpReply *anIcapReply,
                   bool beRetriable, bool beRepeatable);
@@ -116,7 +118,7 @@ class XactAbortInfo {
     HttpReply *icapReply;
     bool isRetriable;
     bool isRepeatable;
-    
+
 private:
     XactAbortInfo &operator =(const XactAbortInfo &); // undefined
 };
@@ -129,19 +131,19 @@ inline std::ostream &operator << (std::ostream &os, Adaptation::Icap::XactAbortI
 }
 
 /// A Dialer class used to schedule the Adaptation::Icap::Launcher::noteXactAbort call
-class XactAbortCall: public UnaryMemFunT<Adaptation::Icap::Launcher, Adaptation::Icap::XactAbortInfo> {
+class XactAbortCall: public UnaryMemFunT<Adaptation::Icap::Launcher, Adaptation::Icap::XactAbortInfo>
+{
 public:
     typedef void (Adaptation::Icap::Launcher::*DialMethod)(Adaptation::Icap::XactAbortInfo &);
-    XactAbortCall(Adaptation::Icap::Launcher *launcer, DialMethod aMethod, 
+    XactAbortCall(Adaptation::Icap::Launcher *launcer, DialMethod aMethod,
                   const Adaptation::Icap::XactAbortInfo &info):
-    UnaryMemFunT<Adaptation::Icap::Launcher, Adaptation::Icap::XactAbortInfo>(launcer, NULL, info),
-       dialMethod(aMethod)
-    {}
+            UnaryMemFunT<Adaptation::Icap::Launcher, Adaptation::Icap::XactAbortInfo>(launcer, NULL, info),
+            dialMethod(aMethod) {}
     virtual void print(std::ostream &os) const {  os << '(' << "retriable:" << arg1.isRetriable << ", repeatable:" << arg1.isRepeatable << ')'; }
 
 public:
     DialMethod dialMethod;
-    
+
 protected:
     virtual void doDial() { (object->*dialMethod)(arg1); }
 };
@@ -163,13 +163,12 @@ void Adaptation::Icap::ModXact::handleCommWroteHeaders()
     // determine next step
     if (preview.enabled())
         state.writing = preview.done() ? State::writingPaused : State::writingPreview;
-    else
-        if (virginBody.expected())
-            state.writing = State::writingPrime;
-        else {
-            stopWriting(true);
-            return;
-        }
+    else if (virginBody.expected())
+        state.writing = State::writingPrime;
+    else {
+        stopWriting(true);
+        return;
+    }
 
     writeMore();
 }
@@ -319,7 +318,7 @@ void Adaptation::Icap::ModXact::closeChunk(MemBuf &buf)
 const HttpRequest &Adaptation::Icap::ModXact::virginRequest() const
 {
     const HttpRequest *request = virgin.cause ?
-        virgin.cause : dynamic_cast<const HttpRequest*>(virgin.header);
+                                 virgin.cause : dynamic_cast<const HttpRequest*>(virgin.header);
     Must(request);
     return *request;
 }
@@ -656,7 +655,7 @@ void Adaptation::Icap::ModXact::maybeAllocateHttpMsg()
     if (gotEncapsulated("res-hdr")) {
         adapted.setHeader(new HttpReply);
         setOutcome(service().cfg().method == ICAP::methodReqmod ?
-            xoSatisfied : xoModified);
+                   xoSatisfied : xoModified);
     } else if (gotEncapsulated("req-hdr")) {
         adapted.setHeader(new HttpRequest);
         setOutcome(xoModified);
@@ -763,7 +762,7 @@ void Adaptation::Icap::ModXact::parseIcapHead()
     // We need to store received ICAP headers for <icapLastHeader logformat option.
     // If we already have stored headers from previous ICAP transaction related to this
     // request, old headers will be replaced with the new one.
-    
+
     Adaptation::Icap::History::Pointer h = request->icapHistory();
     if (h != NULL) {
         h->mergeIcapHeaders(&icapReply->header);
@@ -857,7 +856,7 @@ void Adaptation::Icap::ModXact::prepEchoing()
     if (const HttpRequest *oldR = dynamic_cast<const HttpRequest*>(oldHead)) {
         HttpRequest *newR = new HttpRequest;
         newR->canonical = oldR->canonical ?
-            xstrdup(oldR->canonical) : NULL; // parse() does not set it
+                          xstrdup(oldR->canonical) : NULL; // parse() does not set it
         newHead = newR;
     } else if (dynamic_cast<const HttpReply*>(oldHead)) {
         HttpReply *newRep = new HttpReply;
@@ -1110,57 +1109,56 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
 {
     HttpRequest * request_ = NULL;
     HttpReply * reply_ = NULL;
-    if(!(request_ = dynamic_cast<HttpRequest*>(adapted.header)))
-    {
+    if (!(request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
         request_ = (virgin.cause? virgin.cause: dynamic_cast<HttpRequest*>(virgin.header));
         reply_ = dynamic_cast<HttpReply*>(adapted.header);
     }
 
     Adaptation::Icap::History::Pointer h = request_->icapHistory();
-     Must(h != NULL); // ICAPXaction::maybeLog calls only if there is a log
-     al.icp.opcode = ICP_INVALID;
-     al.url = h->log_uri.termedBuf();
-     const Adaptation::Icap::ServiceRep  &s = service();
-     al.icap.reqMethod = s.cfg().method;
+    Must(h != NULL); // ICAPXaction::maybeLog calls only if there is a log
+    al.icp.opcode = ICP_INVALID;
+    al.url = h->log_uri.termedBuf();
+    const Adaptation::Icap::ServiceRep  &s = service();
+    al.icap.reqMethod = s.cfg().method;
 
-     al.cache.caddr = request_->client_addr;
+    al.cache.caddr = request_->client_addr;
 
-     al.request = HTTPMSGLOCK(request_);
-     if(reply_)
-         al.reply = HTTPMSGLOCK(reply_);
-     else
-         al.reply = NULL;
+    al.request = HTTPMSGLOCK(request_);
+    if (reply_)
+        al.reply = HTTPMSGLOCK(reply_);
+    else
+        al.reply = NULL;
 
-     if (h->rfc931.size())
-         al.cache.rfc931 = h->rfc931.termedBuf();
+    if (h->rfc931.size())
+        al.cache.rfc931 = h->rfc931.termedBuf();
 
 #if USE_SSL
-     if (h->ssluser.size())
-         al.cache.ssluser = h->ssluser.termedBuf();
+    if (h->ssluser.size())
+        al.cache.ssluser = h->ssluser.termedBuf();
 #endif
-     al.cache.code = h->logType;
-     al.cache.requestSize = h->req_sz;
-     if (reply_) {
-         al.http.code = reply_->sline.status;
-         al.http.content_type = reply_->content_type.termedBuf();
-         al.cache.replySize = replyBodySize + reply_->hdr_sz;
-         al.cache.highOffset = replyBodySize;
-         //don't set al.cache.objectSize because it hasn't exist yet
-
-         Packer p;
-         MemBuf mb;
-
-         mb.init();
-         packerToMemInit(&p, &mb);
-
-         reply_->header.packInto(&p);
-         al.headers.reply = xstrdup(mb.buf);
-
-         packerClean(&p);
-         mb.clean();
-     }
-     prepareLogWithRequestDetails(request_, &al);
-     Xaction::finalizeLogInfo();
+    al.cache.code = h->logType;
+    al.cache.requestSize = h->req_sz;
+    if (reply_) {
+        al.http.code = reply_->sline.status;
+        al.http.content_type = reply_->content_type.termedBuf();
+        al.cache.replySize = replyBodySize + reply_->hdr_sz;
+        al.cache.highOffset = replyBodySize;
+        //don't set al.cache.objectSize because it hasn't exist yet
+
+        Packer p;
+        MemBuf mb;
+
+        mb.init();
+        packerToMemInit(&p, &mb);
+
+        reply_->header.packInto(&p);
+        al.headers.reply = xstrdup(mb.buf);
+
+        packerClean(&p);
+        mb.clean();
+    }
+    prepareLogWithRequestDetails(request_, &al);
+    Xaction::finalizeLogInfo();
 }
 
 
@@ -1198,12 +1196,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         if (ah != NULL) {
             String name, value;
             if (ah->getXxRecord(name, value)) {
-                buf.Printf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n",  
-                    SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
+                buf.Printf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n",
+                           SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
             }
         }
     }
-    
+
 
     buf.Printf("Encapsulated: ");
 
@@ -1221,9 +1219,8 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         urlPath = request->urlpath;
         if (ICAP::methodRespmod == m)
             encapsulateHead(buf, "req-hdr", httpBuf, request);
-        else
-            if (ICAP::methodReqmod == m)
-                encapsulateHead(buf, "req-hdr", httpBuf, virgin.header);
+        else if (ICAP::methodReqmod == m)
+            encapsulateHead(buf, "req-hdr", httpBuf, virgin.header);
     }
 
     if (ICAP::methodRespmod == m)
@@ -1359,9 +1356,8 @@ void Adaptation::Icap::ModXact::decideOnPreview()
 
     if (!virginBody.expected())
         ad = 0;
-    else
-        if (virginBody.knownSize())
-            ad = min(static_cast<uint64_t>(ad), virginBody.size()); // not more than we have
+    else if (virginBody.knownSize())
+        ad = min(static_cast<uint64_t>(ad), virginBody.size()); // not more than we have
 
     debugs(93, 5, HERE << "should offer " << ad << "-byte preview " <<
            "(service wanted " << wantedSize << ")");
@@ -1513,11 +1509,10 @@ void Adaptation::Icap::ModXact::estimateVirginBody()
 
     if (virgin.cause)
         method = virgin.cause->method;
+    else if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
+        method = req->method;
     else
-        if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
-            method = req->method;
-        else
-            method = METHOD_NONE;
+        method = METHOD_NONE;
 
     int64_t size;
     // expectingBody returns true for zero-sized bodies, but we will not
@@ -1664,9 +1659,8 @@ void Adaptation::Icap::Preview::wrote(size_t size, bool wroteEof)
 
     if (wroteEof)
         theState = stIeof; // written size is irrelevant
-    else
-        if (theWritten >= theAd)
-            theState = stDone;
+    else if (theWritten >= theAd)
+        theState = stDone;
 }
 
 bool Adaptation::Icap::ModXact::fillVirginHttpHeader(MemBuf &mb) const
@@ -1699,24 +1693,26 @@ Adaptation::Icap::Xaction *Adaptation::Icap::ModXactLauncher::createXaction()
     return new Adaptation::Icap::ModXact(this, virgin.header, virgin.cause, s);
 }
 
-void Adaptation::Icap::ModXactLauncher::swanSong() {
+void Adaptation::Icap::ModXactLauncher::swanSong()
+{
     debugs(93, 5, HERE << "swan sings");
     updateHistory(false);
     Adaptation::Icap::Launcher::swanSong();
 }
 
-void Adaptation::Icap::ModXactLauncher::updateHistory(bool start) {
-     HttpRequest *r = virgin.cause ?
-         virgin.cause : dynamic_cast<HttpRequest*>(virgin.header);
-
-     // r should never be NULL but we play safe; TODO: add Should()
-     if (r) {
-         Adaptation::Icap::History::Pointer h = r->icapHistory();
-         if (h != NULL) {
-             if (start)
-                 h->start("ICAPModXactLauncher");
-             else
-                 h->stop("ICAPModXactLauncher");
-         }
-     }
+void Adaptation::Icap::ModXactLauncher::updateHistory(bool start)
+{
+    HttpRequest *r = virgin.cause ?
+                     virgin.cause : dynamic_cast<HttpRequest*>(virgin.header);
+
+    // r should never be NULL but we play safe; TODO: add Should()
+    if (r) {
+        Adaptation::Icap::History::Pointer h = r->icapHistory();
+        if (h != NULL) {
+            if (start)
+                h->start("ICAPModXactLauncher");
+            else
+                h->stop("ICAPModXactLauncher");
+        }
+    }
 }
@@ -54,7 +54,8 @@ class ChunkedCodingParser;
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 // estimated future presence and size of something (e.g., HTTP body)
 
@@ -39,7 +39,8 @@
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 /* OptXact sends an ICAP OPTIONS request to the ICAP service,
  * parses the ICAP response, and sends it to the initiator. A NULL response
@@ -41,7 +41,8 @@ class wordlist;
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 /* Maintains options supported by a given ICAP service.
  * See RFC 3507, Section "4.10.2 OPTIONS Response". */
@@ -451,12 +451,10 @@ const char *Adaptation::Icap::ServiceRep::status() const
 
         if (!theOptions)
             buf.append(",!opt", 5);
-        else
-            if (!theOptions->valid())
-                buf.append(",!valid", 7);
-            else
-                if (!theOptions->fresh())
-                    buf.append(",stale", 6);
+        else if (!theOptions->valid())
+            buf.append(",!valid", 7);
+        else if (!theOptions->fresh())
+            buf.append(",stale", 6);
     }
 
     if (theOptionsFetcher)
@@ -43,7 +43,8 @@
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 class Options;
 class OptXact;
@@ -78,7 +79,7 @@ class OptXact;
 
 
 class ServiceRep : public RefCountable, public Adaptation::Service,
-            public Adaptation::Initiator
+        public Adaptation::Initiator
 {
 
 public:
@@ -432,7 +432,7 @@ void Adaptation::Icap::Xaction::setOutcome(const Adaptation::Icap::XactOutcome &
 {
     if (al.icap.outcome != xoUnknown) {
         debugs(93, 3, HERE << "Warning: reseting outcome: from " <<
-            al.icap.outcome << " to " << xo);
+               al.icap.outcome << " to " << xo);
     } else {
         debugs(93, 4, HERE << xo);
     }
@@ -462,19 +462,20 @@ void Adaptation::Icap::Xaction::swanSong()
     Adaptation::Initiate::swanSong();
 }
 
-void Adaptation::Icap::Xaction::tellQueryAborted() {
+void Adaptation::Icap::Xaction::tellQueryAborted()
+{
     Adaptation::Icap::Launcher *l = dynamic_cast<Adaptation::Icap::Launcher*>(theInitiator.ptr());
     Adaptation::Icap::XactAbortInfo abortInfo(icapRequest, icapReply, retriable(), repeatable());
-    CallJob(91, 5, __FILE__, __LINE__, 
+    CallJob(91, 5, __FILE__, __LINE__,
             "Adaptation::Icap::Launcher::noteXactAbort",
             XactAbortCall(l, &Adaptation::Icap::Launcher::noteXactAbort, abortInfo) );
     clearInitiator();
 }
 
 
-void Adaptation::Icap::Xaction::maybeLog() {
-    if(IcapLogfileStatus == LOG_ENABLE)
-    {
+void Adaptation::Icap::Xaction::maybeLog()
+{
+    if (IcapLogfileStatus == LOG_ENABLE) {
         ACLChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
         if (!::Config.accessList.icap || checklist->fastCheck()) {
             finalizeLogInfo();
@@ -489,12 +490,12 @@ void Adaptation::Icap::Xaction::finalizeLogInfo()
 {
     //prepare log data
     al.icp.opcode = ICP_INVALID;
-    
+
     const Adaptation::Icap::ServiceRep &s = service();
     al.icap.hostAddr = s.cfg().host.termedBuf();
     al.icap.serviceName = s.cfg().key;
     al.icap.reqUri = s.cfg().uri;
-    
+
     al.icap.ioTime = tvSubMsec(icap_tio_start, icap_tio_finish);
     al.icap.trTime = tvSubMsec(icap_tr_start, current_time);
 
@@ -46,7 +46,8 @@ class CommConnectCbParams;
 
 namespace Adaptation
 {
-namespace Icap {
+namespace Icap
+{
 
 /*
  * The ICAP Xaction implements common tasks for ICAP OPTIONS, REQMOD, and
@@ -22,7 +22,7 @@ icapLogOpen()
     }
 }
 
-void 
+void
 icapLogClose()
 {
     customlog *log;
@@ -602,8 +602,7 @@ AuthNegotiateUserRequest::releaseAuthServer()
         debugs(29, 6, HERE << "releasing Negotiate auth server '" << authserver << "'");
         helperStatefulReleaseServer(authserver);
         authserver = NULL;
-    }
-    else
+    } else
         debugs(29, 6, HERE << "No Negotiate auth server to release.");
 }
 
@@ -516,10 +516,9 @@ AuthNTLMUserRequest::releaseAuthServer()
 {
     if (authserver) {
         debugs(29, 6, HERE << "releasing NTLM auth server '" << authserver << "'");
-	helperStatefulReleaseServer(authserver);
-	authserver = NULL;
-    }
-    else
+        helperStatefulReleaseServer(authserver);
+        authserver = NULL;
+    } else
         debugs(29, 6, HERE << "No NTLM auth server to release.");
 }
 
@@ -1648,7 +1648,7 @@ GetService(const char *proto)
         return 0; /* NEVER REACHED */
     }
     /** Returns either the service port number from /etc/services */
-    if( !isUnsignedNumeric(token, strlen(token)) )
+    if ( !isUnsignedNumeric(token, strlen(token)) )
         port = getservbyname(token, proto);
     if (port != NULL) {
         return ntohs((u_short)port->s_port);
@@ -2782,36 +2782,36 @@ parse_memcachemode(SquidConfig * config)
 {
     char *token = strtok(NULL, w_space);
     if (!token)
-	self_destruct();
+        self_destruct();
 
     if (strcmp(token, "always") == 0) {
-	Config.onoff.memory_cache_first = 1;
-	Config.onoff.memory_cache_disk = 1;
+        Config.onoff.memory_cache_first = 1;
+        Config.onoff.memory_cache_disk = 1;
     } else if (strcmp(token, "disk") == 0) {
-	Config.onoff.memory_cache_first = 0;
-	Config.onoff.memory_cache_disk = 1;
+        Config.onoff.memory_cache_first = 0;
+        Config.onoff.memory_cache_disk = 1;
     } else if (strncmp(token, "net", 3) == 0) {
-	Config.onoff.memory_cache_first = 1;
-	Config.onoff.memory_cache_disk = 0;
+        Config.onoff.memory_cache_first = 1;
+        Config.onoff.memory_cache_disk = 0;
     } else if (strcmp(token, "never") == 0) {
-	Config.onoff.memory_cache_first = 0;
-	Config.onoff.memory_cache_disk = 0;
+        Config.onoff.memory_cache_first = 0;
+        Config.onoff.memory_cache_disk = 0;
     } else
-	self_destruct();
+        self_destruct();
 }
 
 static void
 dump_memcachemode(StoreEntry * entry, const char *name, SquidConfig &config)
 {
     storeAppendPrintf(entry, "%s ", name);
     if (Config.onoff.memory_cache_first && Config.onoff.memory_cache_disk)
-	storeAppendPrintf(entry, "always");
+        storeAppendPrintf(entry, "always");
     else if (!Config.onoff.memory_cache_first && Config.onoff.memory_cache_disk)
-	storeAppendPrintf(entry, "disk");
+        storeAppendPrintf(entry, "disk");
     else if (Config.onoff.memory_cache_first && !Config.onoff.memory_cache_disk)
-	storeAppendPrintf(entry, "network");
+        storeAppendPrintf(entry, "network");
     else if (!Config.onoff.memory_cache_first && !Config.onoff.memory_cache_disk)
-	storeAppendPrintf(entry, "none");
+        storeAppendPrintf(entry, "none");
     storeAppendPrintf(entry, "\n");
 }
 
@@ -450,7 +450,7 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogEntry)
     assert(request);
     assert(aLogEntry);
 
-#if ICAP_CLIENT   
+#if ICAP_CLIENT
     Adaptation::Icap::History::Pointer ih = request->icapHistory();
 #endif
     if (Config.onoff.log_mime_hdrs) {
@@ -1898,13 +1898,14 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
 
 // Temporary hack helper: determine whether the request is chunked, expensive
 static bool
-isChunkedRequest(const HttpParser *hp) {
+isChunkedRequest(const HttpParser *hp)
+{
     HttpRequest request;
     if (!request.parseHeader(HttpParserHdrBuf(hp), HttpParserHdrSz(hp)))
-	return false;
+        return false;
 
     return request.header.has(HDR_TRANSFER_ENCODING) &&
-	request.header.hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
+           request.header.hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
 }
 
 
@@ -1936,8 +1937,7 @@ parseHttpRequest(ConnStateData *conn, HttpParser *hp, HttpRequestMethod * method
     if ( hp->bufsiz <= 0) {
         debugs(33, 5, "Incomplete request, waiting for end of request line");
         return NULL;
-    }
-    else if ( (size_t)hp->bufsiz >= Config.maxRequestHeaderSize && headersEnd(hp->buf, Config.maxRequestHeaderSize) == 0) {
+    } else if ( (size_t)hp->bufsiz >= Config.maxRequestHeaderSize && headersEnd(hp->buf, Config.maxRequestHeaderSize) == 0) {
         debugs(33, 5, "parseHttpRequest: Too large request");
         return parseHttpRequestAbort(conn, "error:request-too-large");
     }
@@ -2033,8 +2033,8 @@ parseHttpRequest(ConnStateData *conn, HttpParser *hp, HttpRequestMethod * method
     // logic to determine when it is valid to do so.
     // FUTURE_CODE_TO_SUPPORT_CHUNKED_REQUESTS below will replace this hack.
     if (hp->v_min == 1 && hp->v_maj == 1 && // broken client, may send chunks
-        Config.maxChunkedRequestBodySize > 0 && // configured to dechunk
-        (*method_p == METHOD_PUT || *method_p == METHOD_POST)) {
+            Config.maxChunkedRequestBodySize > 0 && // configured to dechunk
+            (*method_p == METHOD_PUT || *method_p == METHOD_POST)) {
 
         // check only once per request because isChunkedRequest is expensive
         if (conn->in.dechunkingState == ConnStateData::chunkUnknown) {
@@ -2743,15 +2743,15 @@ ConnStateData::handleRequestBodyData()
 {
     assert(bodyPipe != NULL);
 
-    size_t putSize = 0;    
+    size_t putSize = 0;
 
 #if FUTURE_CODE_TO_SUPPORT_CHUNKED_REQUESTS
-   // The code below works, in principle, but we cannot do dechunking 
-   // on-the-fly because that would mean sending chunked requests to
-   // the next hop. Squid lacks logic to determine which servers can
-   // receive chunk requests. Squid v3.0 code cannot even handle chunked
-   // responses which we may encourage by sending chunked requests.
-   // The error generation code probably needs more work.
+    // The code below works, in principle, but we cannot do dechunking
+    // on-the-fly because that would mean sending chunked requests to
+    // the next hop. Squid lacks logic to determine which servers can
+    // receive chunk requests. Squid v3.0 code cannot even handle chunked
+    // responses which we may encourage by sending chunked requests.
+    // The error generation code probably needs more work.
     if (in.bodyParser) { // chunked body
         debugs(33,5, HERE << "handling chunked request body for FD " << fd);
         bool malformedChunks = false;
@@ -2771,7 +2771,7 @@ ConnStateData::handleRequestBodyData()
             } else {
                 // parser needy state must imply body pipe needy state
                 if (in.bodyParser->needsMoreData() &&
-                    !bodyPipe->mayNeedMoreData())
+                        !bodyPipe->mayNeedMoreData())
                     malformedChunks = true;
                 // XXX: if bodyParser->needsMoreSpace, how can we guarantee it?
             }
@@ -2789,14 +2789,14 @@ ConnStateData::handleRequestBodyData()
                 clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
                 assert (repContext);
                 repContext->setReplyToError(ERR_INVALID_REQ, HTTP_BAD_REQUEST,
-                    METHOD_NONE, NULL, &peer.sin_addr,
-                    NULL, NULL, NULL);
+                                            METHOD_NONE, NULL, &peer.sin_addr,
+                                            NULL, NULL, NULL);
                 context->pullData();
             }
             flags.readMoreRequests = false;
             return; // XXX: is that sufficient to generate an error?
         }
-    } else // identity encoding 
+    } else // identity encoding
 #endif
     {
         debugs(33,5, HERE << "handling plain request body for FD " << fd);
@@ -3612,15 +3612,15 @@ ConnStateData::finishDechunkingRequest(HttpParser *hp)
     debugs(33, 5, HERE << "finish dechunking; content: " << in.dechunked.contentSize());
 
     assert(in.dechunkingState == chunkReady);
-    assert(in.bodyParser); 
+    assert(in.bodyParser);
     delete in.bodyParser;
     in.bodyParser = NULL;
 
     const mb_size_t headerSize = HttpParserRequestLen(hp);
 
     // dechunking cannot make data bigger
     assert(headerSize + in.dechunked.contentSize() + in.chunked.contentSize()
-        <= static_cast<mb_size_t>(in.notYetUsed));
+           <= static_cast<mb_size_t>(in.notYetUsed));
     assert(in.notYetUsed <= in.allocatedSize);
 
     // copy dechunked content
@@ -3647,7 +3647,7 @@ bool
 ConnStateData::parseRequestChunks(HttpParser *)
 {
     debugs(33,5, HERE << "parsing chunked request body at " <<
-        in.chunkedSeen << " < " << in.notYetUsed);
+           in.chunkedSeen << " < " << in.notYetUsed);
     assert(in.bodyParser);
     assert(in.dechunkingState == chunkParsing);
 
@@ -3657,20 +3657,20 @@ ConnStateData::parseRequestChunks(HttpParser *)
     // be safe: count some chunked coding metadata towards the total body size
     if (fresh + in.dechunked.contentSize() > Config.maxChunkedRequestBodySize) {
         debugs(33,3, HERE << "chunked body (" << fresh << " + " <<
-            in.dechunked.contentSize() << " may exceed " <<
-            "chunked_request_body_max_size=" <<
-            Config.maxChunkedRequestBodySize);
+               in.dechunked.contentSize() << " may exceed " <<
+               "chunked_request_body_max_size=" <<
+               Config.maxChunkedRequestBodySize);
         in.dechunkingState = chunkError;
         return false;
     }
-        
+
     if (fresh > in.chunked.potentialSpaceSize()) {
         // should not happen if Config.maxChunkedRequestBodySize is reasonable
         debugs(33,1, HERE << "request_body_max_size exceeds chunked buffer " <<
-            "size: " << fresh << " + " << in.chunked.contentSize() << " > " <<
-            in.chunked.potentialSpaceSize() << " with " <<
-            "chunked_request_body_max_size=" <<
-            Config.maxChunkedRequestBodySize);
+               "size: " << fresh << " + " << in.chunked.contentSize() << " > " <<
+               in.chunked.potentialSpaceSize() << " with " <<
+               "chunked_request_body_max_size=" <<
+               Config.maxChunkedRequestBodySize);
         in.dechunkingState = chunkError;
         return false;
     }
@@ -3696,8 +3696,8 @@ ConnStateData::In::addressToReadInto() const
 }
 
 ConnStateData::In::In() : bodyParser(NULL),
-    buf (NULL), notYetUsed (0), allocatedSize (0),
-    dechunkingState(ConnStateData::chunkUnknown)
+        buf (NULL), notYetUsed (0), allocatedSize (0),
+        dechunkingState(ConnStateData::chunkUnknown)
 {}
 
 ConnStateData::In::~In()
@@ -155,14 +155,14 @@ class ConnStateData : public BodyProducer/*, public RefCountable*/
         ~In();
         char *addressToReadInto() const;
 
-	ChunkedCodingParser *bodyParser; ///< parses chunked request body
-	MemBuf chunked; ///< contains unparsed raw (chunked) body data
-	MemBuf dechunked; ///< accumulates parsed (dechunked) content
+        ChunkedCodingParser *bodyParser; ///< parses chunked request body
+        MemBuf chunked; ///< contains unparsed raw (chunked) body data
+        MemBuf dechunked; ///< accumulates parsed (dechunked) content
         char *buf;
         size_t notYetUsed;
         size_t allocatedSize;
-	size_t chunkedSeen; ///< size of processed or ignored raw read data
-	DechunkingState dechunkingState; ///< request dechunking state
+        size_t chunkedSeen; ///< size of processed or ignored raw read data
+        DechunkingState dechunkingState; ///< request dechunking state
     } in;
 
     int64_t bodySizeLeft();
@@ -652,7 +652,7 @@ clientReplyContext::processMiss()
 
     /// Deny loops for accelerator and interceptor. TODO: deny in all modes?
     if (r->flags.loopdetect &&
-        (http->flags.accel || http->flags.intercepted)) {
+            (http->flags.accel || http->flags.intercepted)) {
         http->al.http.code = HTTP_FORBIDDEN;
         err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->peer, http->request);
         createStoreEntry(r->method, request_flags());
@@ -636,16 +636,14 @@ ClientRequestContext::adaptationAclCheckDone(Adaptation::ServiceGroupPointer g)
     debugs(93,3,HERE << this << " adaptationAclCheckDone called");
     assert(http);
 
-#if ICAP_CLIENT                                                                
+#if ICAP_CLIENT
     Adaptation::Icap::History::Pointer ih = http->request->icapHistory();
-    if(ih != NULL)
-    {                                                                          
-        if (http->getConn() != NULL)
-        {
+    if (ih != NULL) {
+        if (http->getConn() != NULL) {
             ih->rfc931 = http->getConn()->rfc931;
-#if USE_SSL                              
+#if USE_SSL
             ih->ssluser = sslGetUserEmail(fd_table[http->getConn()->fd].ssl);
-#endif  
+#endif
         }
         ih->log_uri = http->log_uri;
         ih->req_sz = http->req_sz;
@@ -1340,9 +1338,9 @@ ClientHttpRequest::startAdaptation(const Adaptation::ServiceGroupPointer &g)
     assert(!virginHeadSource);
     assert(!adaptedBodySource);
     virginHeadSource = initiateAdaptation(
-        new Adaptation::Iterator(this, request, NULL, g));
+                           new Adaptation::Iterator(this, request, NULL, g));
 
-    // we could try to guess whether we can bypass this adaptation 
+    // we could try to guess whether we can bypass this adaptation
     // initiation failure, but it should not really happen
     assert(virginHeadSource != NULL); // Must, really
 }
@@ -61,8 +61,8 @@ class ClientRequestContext;
 
 class ClientHttpRequest
 #if USE_ADAPTATION
-            : public Adaptation::Initiator, // to start adaptation transactions
-            public BodyConsumer     // to receive reply bodies in request satisf. mode
+        : public Adaptation::Initiator, // to start adaptation transactions
+        public BodyConsumer     // to receive reply bodies in request satisf. mode
 #endif
 {
 
@@ -1858,7 +1858,8 @@ commUnsetNonBlocking(int fd)
 }
 
 void
-commSetCloseOnExec(int fd) {
+commSetCloseOnExec(int fd)
+{
 #ifdef FD_CLOEXEC
     int flags;
     int dummy = 0;
@@ -1878,7 +1879,8 @@ commSetCloseOnExec(int fd) {
 
 #ifdef TCP_NODELAY
 static void
-commSetTcpNoDelay(int fd) {
+commSetTcpNoDelay(int fd)
+{
     int on = 1;
 
     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0)
@@ -1890,7 +1892,8 @@ commSetTcpNoDelay(int fd) {
 #endif
 
 void
-commSetTcpKeepalive(int fd, int idle, int interval, int timeout) {
+commSetTcpKeepalive(int fd, int idle, int interval, int timeout)
+{
     int on = 1;
 #ifdef TCP_KEEPCNT
     if (timeout && interval) {
@@ -1916,7 +1919,8 @@ commSetTcpKeepalive(int fd, int idle, int interval, int timeout) {
 }
 
 void
-comm_init(void) {
+comm_init(void)
+{
     fd_table =(fde *) xcalloc(Squid_MaxFD, sizeof(fde));
     fdd_table = (fd_debug_t *)xcalloc(Squid_MaxFD, sizeof(fd_debug_t));
 
@@ -1946,7 +1950,8 @@ comm_init(void) {
 }
 
 void
-comm_exit(void) {
+comm_exit(void)
+{
     delete TheHalfClosed;
     TheHalfClosed = NULL;
 
@@ -1961,7 +1966,8 @@ comm_exit(void) {
 
 /* Write to FD. */
 static void
-commHandleWrite(int fd, void *data) {
+commHandleWrite(int fd, void *data)
+{
     comm_io_callback_t *state = (comm_io_callback_t *)data;
     int len = 0;
     int nleft;
@@ -2029,15 +2035,17 @@ commHandleWrite(int fd, void *data) {
  * free_func is used to free the passed buffer when the write has completed.
  */
 void
-comm_write(int fd, const char *buf, int size, IOCB * handler, void *handler_data, FREE * free_func) {
+comm_write(int fd, const char *buf, int size, IOCB * handler, void *handler_data, FREE * free_func)
+{
     AsyncCall::Pointer call = commCbCall(5,5, "SomeCommWriteHander",
                                          CommIoCbPtrFun(handler, handler_data));
 
     comm_write(fd, buf, size, call, free_func);
 }
 
 void
-comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE * free_func) {
+comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE * free_func)
+{
     debugs(5, 5, "comm_write: FD " << fd << ": sz " << size << ": asynCall " << callback);
 
     /* Make sure we are open, not closing, and not writing */
@@ -2055,12 +2063,14 @@ comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE
 
 /* a wrapper around comm_write to allow for MemBuf to be comm_written in a snap */
 void
-comm_write_mbuf(int fd, MemBuf *mb, IOCB * handler, void *handler_data) {
+comm_write_mbuf(int fd, MemBuf *mb, IOCB * handler, void *handler_data)
+{
     comm_write(fd, mb->buf, mb->size, handler, handler_data, mb->freeFunc());
 }
 
 void
-comm_write_mbuf(int fd, MemBuf *mb, AsyncCall::Pointer &callback) {
+comm_write_mbuf(int fd, MemBuf *mb, AsyncCall::Pointer &callback)
+{
     comm_write(fd, mb->buf, mb->size, callback, mb->freeFunc());
 }
 
@@ -2070,7 +2080,8 @@ comm_write_mbuf(int fd, MemBuf *mb, AsyncCall::Pointer &callback) {
  * like to use it.
  */
 int
-ignoreErrno(int ierrno) {
+ignoreErrno(int ierrno)
+{
     switch (ierrno) {
 
     case EINPROGRESS:
@@ -2099,7 +2110,8 @@ ignoreErrno(int ierrno) {
 }
 
 void
-commCloseAllSockets(void) {
+commCloseAllSockets(void)
+{
     int fd;
     fde *F = NULL;
 
@@ -2128,7 +2140,8 @@ commCloseAllSockets(void) {
 }
 
 static bool
-AlreadyTimedOut(fde *F) {
+AlreadyTimedOut(fde *F)
+{
     if (!F->flags.open)
         return true;
 
@@ -2142,7 +2155,8 @@ AlreadyTimedOut(fde *F) {
 }
 
 void
-checkTimeouts(void) {
+checkTimeouts(void)
+{
     int fd;
     fde *F = NULL;
     AsyncCall::Pointer callback;
@@ -2175,7 +2189,8 @@ checkTimeouts(void) {
  * accept()ed.
  */
 int
-comm_listen(int sock) {
+comm_listen(int sock)
+{
     int x;
 
     if ((x = listen(sock, Squid_MaxFD >> 2)) < 0) {
@@ -2208,7 +2223,8 @@ comm_listen(int sock) {
 }
 
 void
-comm_accept(int fd, IOACB *handler, void *handler_data) {
+comm_accept(int fd, IOACB *handler, void *handler_data)
+{
     debugs(5, 5, "comm_accept: FD " << fd << " handler: " << (void*)handler);
     assert(isOpen(fd));
 
@@ -2218,7 +2234,8 @@ comm_accept(int fd, IOACB *handler, void *handler_data) {
 }
 
 void
-comm_accept(int fd, AsyncCall::Pointer &call) {
+comm_accept(int fd, AsyncCall::Pointer &call)
+{
     debugs(5, 5, "comm_accept: FD " << fd << " AsyncCall: " << call);
     assert(isOpen(fd));
 
@@ -2228,7 +2245,8 @@ comm_accept(int fd, AsyncCall::Pointer &call) {
 // Called when somebody wants to be notified when our socket accepts new
 // connection. We do not probe the FD until there is such interest.
 void
-AcceptFD::subscribe(AsyncCall::Pointer &call) {
+AcceptFD::subscribe(AsyncCall::Pointer &call)
+{
     /* make sure we're not pending! */
     assert(!theCallback);
     theCallback = call;
@@ -2244,7 +2262,8 @@ AcceptFD::subscribe(AsyncCall::Pointer &call) {
 }
 
 bool
-AcceptFD::acceptOne() {
+AcceptFD::acceptOne()
+{
     // If there is no callback and we accept, we will leak the accepted FD.
     // When we are running out of FDs, there is often no callback.
     if (!theCallback) {
@@ -2293,12 +2312,14 @@ AcceptFD::acceptOne() {
 }
 
 void
-AcceptFD::acceptNext() {
+AcceptFD::acceptNext()
+{
     mayAcceptMore = acceptOne();
 }
 
 void
-AcceptFD::notify(int newfd, comm_err_t errcode, int xerrno, const ConnectionDetail &connDetails) {
+AcceptFD::notify(int newfd, comm_err_t errcode, int xerrno, const ConnectionDetail &connDetails)
+{
     if (theCallback != NULL) {
         typedef CommAcceptCbParams Params;
         Params &params = GetCommParams<Params>(theCallback);
@@ -2317,12 +2338,14 @@ AcceptFD::notify(int newfd, comm_err_t errcode, int xerrno, const ConnectionDeta
  * to dupe itself and fob off an accept()ed connection
  */
 static void
-comm_accept_try(int fd, void *) {
+comm_accept_try(int fd, void *)
+{
     assert(isOpen(fd));
     fdc_table[fd].acceptNext();
 }
 
-void CommIO::Initialise() {
+void CommIO::Initialise()
+{
     /* Initialize done pipe signal */
     int DonePipe[2];
     if (pipe(DonePipe)) {}
@@ -2336,7 +2359,8 @@ void CommIO::Initialise() {
     Initialised = true;
 }
 
-void CommIO::NotifyIOClose() {
+void CommIO::NotifyIOClose()
+{
     /* Close done pipe signal */
     FlushPipe();
     close(DoneFD);
@@ -2352,19 +2376,22 @@ int CommIO::DoneFD = -1;
 int CommIO::DoneReadFD = -1;
 
 void
-CommIO::FlushPipe() {
+CommIO::FlushPipe()
+{
     char buf[256];
     FD_READ_METHOD(DoneReadFD, buf, sizeof(buf));
 }
 
 void
-CommIO::NULLFDHandler(int fd, void *data) {
+CommIO::NULLFDHandler(int fd, void *data)
+{
     FlushPipe();
     commSetSelect(fd, COMM_SELECT_READ, NULLFDHandler, NULL, 0);
 }
 
 void
-CommIO::ResetNotifications() {
+CommIO::ResetNotifications()
+{
     if (DoneSignalled) {
         FlushPipe();
         DoneSignalled = false;
@@ -2373,17 +2400,20 @@ CommIO::ResetNotifications() {
 
 AcceptLimiter AcceptLimiter::Instance_;
 
-AcceptLimiter &AcceptLimiter::Instance() {
+AcceptLimiter &AcceptLimiter::Instance()
+{
     return Instance_;
 }
 
 bool
-AcceptLimiter::deferring() const {
+AcceptLimiter::deferring() const
+{
     return deferred.size() > 0;
 }
 
 void
-AcceptLimiter::defer (int fd, Acceptor::AcceptorFunction *aFunc, void *data) {
+AcceptLimiter::defer (int fd, Acceptor::AcceptorFunction *aFunc, void *data)
+{
     debugs(5, 5, "AcceptLimiter::defer: FD " << fd << " handler: " << (void*)aFunc);
     Acceptor temp;
     temp.theFunction = aFunc;
@@ -2393,7 +2423,8 @@ AcceptLimiter::defer (int fd, Acceptor::AcceptorFunction *aFunc, void *data) {
 }
 
 void
-AcceptLimiter::kick() {
+AcceptLimiter::kick()
+{
     if (!deferring())
         return;
 
@@ -2409,7 +2440,8 @@ AcceptLimiter::kick() {
 // by scheduling a read callback to a monitoring handler that
 // will close the connection on read errors.
 void
-commStartHalfClosedMonitor(int fd) {
+commStartHalfClosedMonitor(int fd)
+{
     debugs(5, 5, HERE << "adding FD " << fd << " to " << *TheHalfClosed);
     assert(isOpen(fd));
     assert(!commHasHalfClosedMonitor(fd));
@@ -2419,7 +2451,8 @@ commStartHalfClosedMonitor(int fd) {
 
 static
 void
-commPlanHalfClosedCheck() {
+commPlanHalfClosedCheck()
+{
     if (!WillCheckHalfClosed && !TheHalfClosed->empty()) {
         eventAdd("commHalfClosedCheck", &commHalfClosedCheck, NULL, 1.0, 1);
         WillCheckHalfClosed = true;
@@ -2430,7 +2463,8 @@ commPlanHalfClosedCheck() {
 /// calls comm_read for those that do; re-schedules the check if needed
 static
 void
-commHalfClosedCheck(void *) {
+commHalfClosedCheck(void *)
+{
     debugs(5, 5, HERE << "checking " << *TheHalfClosed);
 
     typedef DescriptorSet::const_iterator DSCI;
@@ -2452,13 +2486,15 @@ commHalfClosedCheck(void *) {
 /// checks whether we are waiting for possibly half-closed connection to close
 // We are monitoring if the read handler for the fd is the monitoring handler.
 bool
-commHasHalfClosedMonitor(int fd) {
+commHasHalfClosedMonitor(int fd)
+{
     return TheHalfClosed->has(fd);
 }
 
 /// stop waiting for possibly half-closed connection to close
 static void
-commStopHalfClosedMonitor(int const fd) {
+commStopHalfClosedMonitor(int const fd)
+{
     debugs(5, 5, HERE << "removing FD " << fd << " from " << *TheHalfClosed);
 
     // cancel the read if one was scheduled
@@ -2472,7 +2508,8 @@ commStopHalfClosedMonitor(int const fd) {
 
 /// I/O handler for the possibly half-closed connection monitoring code
 static void
-commHalfClosedReader(int fd, char *, size_t size, comm_err_t flag, int, void *) {
+commHalfClosedReader(int fd, char *, size_t size, comm_err_t flag, int, void *)
+{
     // there cannot be more data coming in on half-closed connections
     assert(size == 0);
     assert(commHasHalfClosedMonitor(fd)); // or we would have canceled the read
@@ -2504,7 +2541,8 @@ DeferredRead::DeferredRead () : theReader(NULL), theContext(NULL), theRead(), ca
 
 DeferredRead::DeferredRead (DeferrableRead *aReader, void *data, CommRead const &aRead) : theReader(aReader), theContext (data), theRead(aRead), cancelled(false) {}
 
-DeferredReadManager::~DeferredReadManager() {
+DeferredReadManager::~DeferredReadManager()
+{
     flushReads();
     assert (deferredReads.empty());
 }
@@ -2516,7 +2554,8 @@ template cbdata_type CbDataList<DeferredRead>::CBDATA_CbDataList;
 /// \endcond
 
 void
-DeferredReadManager::delayRead(DeferredRead const &aRead) {
+DeferredReadManager::delayRead(DeferredRead const &aRead)
+{
     debugs(5, 3, "Adding deferred read on FD " << aRead.theRead.fd);
     CbDataList<DeferredRead> *temp = deferredReads.push_back(aRead);
 
@@ -2531,7 +2570,8 @@ DeferredReadManager::delayRead(DeferredRead const &aRead) {
 }
 
 void
-DeferredReadManager::CloseHandler(int fd, void *thecbdata) {
+DeferredReadManager::CloseHandler(int fd, void *thecbdata)
+{
     if (!cbdataReferenceValid (thecbdata))
         return;
 
@@ -2542,7 +2582,8 @@ DeferredReadManager::CloseHandler(int fd, void *thecbdata) {
 }
 
 DeferredRead
-DeferredReadManager::popHead(CbDataListContainer<DeferredRead> &deferredReads) {
+DeferredReadManager::popHead(CbDataListContainer<DeferredRead> &deferredReads)
+{
     assert (!deferredReads.empty());
 
     DeferredRead &read = deferredReads.head->element;
@@ -2557,7 +2598,8 @@ DeferredReadManager::popHead(CbDataListContainer<DeferredRead> &deferredReads) {
 }
 
 void
-DeferredReadManager::kickReads(int const count) {
+DeferredReadManager::kickReads(int const count)
+{
     /* if we had CbDataList::size() we could consolidate this and flushReads */
 
     if (count < 1) {
@@ -2577,7 +2619,8 @@ DeferredReadManager::kickReads(int const count) {
 }
 
 void
-DeferredReadManager::flushReads() {
+DeferredReadManager::flushReads()
+{
     CbDataListContainer<DeferredRead> reads;
     reads = deferredReads;
     deferredReads = CbDataListContainer<DeferredRead>();
@@ -2590,7 +2633,8 @@ DeferredReadManager::flushReads() {
 }
 
 void
-DeferredReadManager::kickARead(DeferredRead const &aRead) {
+DeferredReadManager::kickARead(DeferredRead const &aRead)
+{
     if (aRead.cancelled)
         return;
 
@@ -2603,15 +2647,18 @@ DeferredReadManager::kickARead(DeferredRead const &aRead) {
 }
 
 void
-DeferredRead::markCancelled() {
+DeferredRead::markCancelled()
+{
     cancelled = true;
 }
 
-ConnectionDetail::ConnectionDetail() : me(), peer() {
+ConnectionDetail::ConnectionDetail() : me(), peer()
+{
 }
 
 int
-CommSelectEngine::checkEvents(int timeout) {
+CommSelectEngine::checkEvents(int timeout)
+{
     static time_t last_timeout = 0;
 
     /* No, this shouldn't be here. But it shouldn't be in each comm handler. -adrian */
@@ -4,15 +4,15 @@
 typedef enum {
     ERR_NONE,
 
-/* Access Permission Errors.  Prefix new with ERR_ACCESS_ */
+    /* Access Permission Errors.  Prefix new with ERR_ACCESS_ */
     ERR_ACCESS_DENIED,
     ERR_CACHE_ACCESS_DENIED,
     ERR_CACHE_MGR_ACCESS_DENIED,
     ERR_FORWARDING_DENIED,
     ERR_NO_RELAY,
     ERR_CANNOT_FORWARD,
 
-/* TCP Errors. */
+    /* TCP Errors. */
     ERR_READ_TIMEOUT,
     ERR_LIFETIME_EXP,
     ERR_READ_ERROR,
@@ -21,11 +21,11 @@ typedef enum {
     ERR_SECURE_CONNECT_FAIL,
     ERR_SOCKET_FAILURE,
 
-/* DNS Errors */
+    /* DNS Errors */
     ERR_DNS_FAIL,
     ERR_URN_RESOLVE,
 
-/* HTTP Errors */
+    /* HTTP Errors */
     ERR_ONLY_IF_CACHED_MISS,    /* failure to satisfy only-if-cached request */
     ERR_TOO_BIG,
     ERR_INVALID_RESP,
@@ -35,7 +35,7 @@ typedef enum {
     ERR_INVALID_URL,
     ERR_ZERO_SIZE_OBJECT,
 
-/* FTP Errors */
+    /* FTP Errors */
     ERR_FTP_DISABLED,
     ERR_FTP_UNAVAILABLE,
     ERR_FTP_FAILURE,
@@ -45,13 +45,13 @@ typedef enum {
     ERR_FTP_PUT_CREATED,        /* !error,a note that the file was created */
     ERR_FTP_PUT_MODIFIED,       /* modified, !created */
 
-/* ESI Errors */
+    /* ESI Errors */
     ERR_ESI,                    /* Failure to perform ESI processing */
 
-/* ICAP Errors */
+    /* ICAP Errors */
     ERR_ICAP_FAILURE,
 
-/* Special Cases */
+    /* Special Cases */
     ERR_SQUID_SIGNATURE,        /* not really an error */
     ERR_SHUTTING_DOWN,
     TCP_RESET,
@@ -975,7 +975,7 @@ ErrorState::BuildContent()
                         *dt = '-';
                     else
 #endif
-                    *dt = xtolower(hdr[pos]);
+                        *dt = xtolower(hdr[pos]);
                     // valid codes only contain A-Z, hyphen (-) and *
                     if (*dt != '-' && *dt != '*' && (*dt < 'a' || *dt > 'z') )
                         invalid_byte = true;
@@ -112,9 +112,9 @@ ESIVariableQuery::queryString() const
 }
 
 struct _query_elem const *
-            ESIVariableQuery::queryVector() const {
-        return query;
-    }
+ESIVariableQuery::queryVector() const {
+    return query;
+}
 
 size_t const &
 ESIVariableQuery::queryElements() const
@@ -90,7 +90,8 @@
  * where structures of type fqdncache_entry whose most
  * interesting members are:
  */
-class fqdncache_entry {
+class fqdncache_entry
+{
 public:
     hash_link hash;		/* must be first */
     time_t lastref;
@@ -1436,12 +1436,11 @@ FtpStateData::processReplyBody()
 
     if (flags.isdir) {
         parseListing();
-    } else
-        if (const int csize = data.readBuf->contentSize()) {
-            writeReplyBody(data.readBuf->content(), csize);
-            debugs(9, 5, HERE << "consuming " << csize << " bytes of readBuf");
-            data.readBuf->consume(csize);
-        }
+    } else if (const int csize = data.readBuf->contentSize()) {
+        writeReplyBody(data.readBuf->content(), csize);
+        debugs(9, 5, HERE << "consuming " << csize << " bytes of readBuf");
+        data.readBuf->consume(csize);
+    }
 
     entry->flush();
 
@@ -1497,8 +1496,7 @@ FtpStateData::checkAuth(const HttpHeader * req_hdr)
             xstrncpy(password, Config.Ftp.anon_user, MAX_URL);
             flags.tried_auth_anonymous=1;
             return 1;
-        }
-        else if (!flags.tried_auth_nopass) {
+        } else if (!flags.tried_auth_nopass) {
             xstrncpy(password, null_string, MAX_URL);
             flags.tried_auth_nopass=1;
             return 1;
@@ -2465,7 +2463,7 @@ ftpReadEPSV(FtpStateData* ftpState)
         /* server response with list of supported methods   */
         /*   522 Network protocol not supported, use (1)    */
         /*   522 Network protocol not supported, use (1,2)  */
-        /* TODO: handle the (1,2) case. We might get it back after EPSV ALL 
+        /* TODO: handle the (1,2) case. We might get it back after EPSV ALL
          * which means close data + control without self-destructing and re-open from scratch. */
         debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
         buf = ftpState->ctrl.last_reply;
@@ -2494,8 +2492,7 @@ ftpReadEPSV(FtpStateData* ftpState)
             ftpState->state = SENT_EPSV_1;
             ftpSendPassive(ftpState);
 #endif
-        }
-        else {
+        } else {
             /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
             debugs(9, DBG_IMPORTANT, "WARNING: Server at " << fd_table[ftpState->ctrl.fd].ipaddr << " sent unknown protocol negotiation hint: " << buf);
             ftpSendPassive(ftpState);
@@ -2642,8 +2639,7 @@ ftpSendPassive(FtpStateData * ftpState)
             snprintf(cbuf, 1024, "EPSV 1\r\n");
             ftpState->state = SENT_EPSV_1;
             break;
-        }
-        else if (ftpState->flags.epsv_all_sent) {
+        } else if (ftpState->flags.epsv_all_sent) {
             debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
             ftpFail(ftpState);
             return;
@@ -46,8 +46,7 @@
 
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 //MOVED:Debug.h    extern FILE *debug_log;		/* NULL */
@@ -489,9 +489,9 @@ helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label
                           srv->flags.reserved ? 'R' : ' ',
                           srv->flags.shutdown ? 'S' : ' ',
                           srv->request ? (srv->request->placeholder ? 'P' : ' ') : ' ',
-                          tt < 0.0 ? 0.0 : tt,
-                          (int) srv->roffset,
-                          srv->request ? log_quote(srv->request->buf) : "(none)");
+                                  tt < 0.0 ? 0.0 : tt,
+                                  (int) srv->roffset,
+                                  srv->request ? log_quote(srv->request->buf) : "(none)");
     }
 
     storeAppendPrintf(sentry, "\nFlags key:\n\n");
@@ -608,8 +608,7 @@ helperStatefulShutdown(statefulhelper * hlp)
         if (srv->flags.reserved) {
             if (shutting_down) {
                 debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is RESERVED. Closing anyway.");
-            }
-            else {
+            } else {
                 debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is RESERVED. Not Shutting Down Yet.");
                 continue;
             }
@@ -999,7 +998,7 @@ helperStatefulHandleRead(int fd, char *buf, size_t len, comm_err_t flag, int xer
 
     if ((t = strchr(srv->rbuf, '\n'))) {
         /* end of reply found */
-	int called = 1;
+        int called = 1;
         debugs(84, 3, "helperStatefulHandleRead: end of reply found");
 
         if (t > srv->rbuf && t[-1] == '\r')
@@ -1011,7 +1010,7 @@ helperStatefulHandleRead(int fd, char *buf, size_t len, comm_err_t flag, int xer
             r->callback(r->data, srv, srv->rbuf);
         } else {
             debugs(84, 1, "StatefulHandleRead: no callback data registered");
-	    called = 0;
+            called = 0;
         }
 
         srv->flags.busy = 0;
@@ -1025,15 +1024,15 @@ helperStatefulHandleRead(int fd, char *buf, size_t len, comm_err_t flag, int xer
                        tvSubMsec(srv->dispatch_time, current_time),
                        hlp->stats.replies, REDIRECT_AV_FACTOR);
 
-	if (called)
-	    helperStatefulServerDone(srv);
-	else
-	    helperStatefulReleaseServer(srv);
+        if (called)
+            helperStatefulServerDone(srv);
+        else
+            helperStatefulReleaseServer(srv);
     }
 
     if (srv->rfd != -1)
         comm_read(srv->rfd, srv->rbuf + srv->roffset, srv->rbuf_sz - srv->roffset - 1,
-              helperStatefulHandleRead, srv);
+                  helperStatefulHandleRead, srv);
 }
 
 static void
@@ -1295,7 +1294,7 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
     if (!cbdataReferenceValid(r->data)) {
         debugs(84, 1, "helperStatefulDispatch: invalid callback data");
         helperStatefulRequestFree(r);
-	helperStatefulReleaseServer(srv);
+        helperStatefulReleaseServer(srv);
         return;
     }
 
@@ -76,8 +76,8 @@ static void copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeader
         HttpHeader * hdr_out, const int we_do_ranges, const http_state_flags);
 
 HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"), ServerStateData(theFwdState),
-    lastChunk(0), header_bytes_read(0), reply_bytes_read(0),
-    body_bytes_truncated(0), httpChunkDecoder(NULL)
+        lastChunk(0), header_bytes_read(0), reply_bytes_read(0),
+        body_bytes_truncated(0), httpChunkDecoder(NULL)
 {
     debugs(11,5,HERE << "HttpStateData " << this << " created");
     ignoreCacheControl = false;
@@ -1150,13 +1150,12 @@ HttpStateData::continueAfterParsingHeader()
             const HttpVersion &v = vrep->sline.version;
             if (s == HTTP_INVALID_HEADER && v != HttpVersion(0,9)) {
                 error = ERR_INVALID_RESP;
-            } else
-                if (s == HTTP_HEADER_TOO_LARGE) {
-                    fwd->dontRetry(true);
-                    error = ERR_TOO_BIG;
-                } else {
-                    return true; // done parsing, got reply, and no error
-                }
+            } else if (s == HTTP_HEADER_TOO_LARGE) {
+                fwd->dontRetry(true);
+                error = ERR_TOO_BIG;
+            } else {
+                return true; // done parsing, got reply, and no error
+            }
         } else {
             // parsed headers but got no reply
             error = ERR_INVALID_RESP;
@@ -1188,14 +1187,14 @@ HttpStateData::truncateVirginBody()
         return; // no body or a body of unknown size, including chunked
 
     const int64_t body_bytes_read = reply_bytes_read - header_bytes_read;
-    if (body_bytes_read - body_bytes_truncated <= clen) 
+    if (body_bytes_read - body_bytes_truncated <= clen)
         return; // we did not read too much or already took care of the extras
 
     if (const int64_t extras = body_bytes_read - body_bytes_truncated - clen) {
         // server sent more that the advertised content length
-        debugs(11,5, HERE << "body_bytes_read=" << body_bytes_read << 
-            " clen=" << clen << '/' << vrep->content_length <<
-            " body_bytes_truncated=" << body_bytes_truncated << '+' << extras);
+        debugs(11,5, HERE << "body_bytes_read=" << body_bytes_read <<
+               " clen=" << clen << '/' << vrep->content_length <<
+               " body_bytes_truncated=" << body_bytes_truncated << '+' << extras);
 
         readBuf->truncate(extras);
         body_bytes_truncated += extras;
@@ -1422,7 +1421,7 @@ HttpStateData::sendComplete(const CommIoCbParams &io)
     commSetTimeout(fd, Config.Timeout.read, timeoutCall);
 
     flags.request_sent = 1;
-    
+
     orig_request->hier.peer_http_request_sent = current_time;
 }
 
@@ -140,7 +140,7 @@ IpAddress::GetCIDR() const
 
 #endif
 
-    for (;shift<sizeof(m_SocketAddr.sin6_addr) ;shift++) {
+    for (; shift<sizeof(m_SocketAddr.sin6_addr) ; shift++) {
         byte= *(ptr+shift);
 
         if (byte == 0xFF) {
@@ -1020,7 +1020,8 @@ char* IpAddress::NtoA(char* buf, const unsigned int blen, int force) const
     return buf;
 }
 
-unsigned int IpAddress::ToHostname(char *buf, const unsigned int blen) const {
+unsigned int IpAddress::ToHostname(char *buf, const unsigned int blen) const
+{
     char *p = buf;
 
     if (IsIPv6() && blen > 0) {
@@ -1050,7 +1051,8 @@ unsigned int IpAddress::ToHostname(char *buf, const unsigned int blen) const {
     return (p - buf);
 }
 
-char* IpAddress::ToURL(char* buf, unsigned int blen) const {
+char* IpAddress::ToURL(char* buf, unsigned int blen) const
+{
     char *p = buf;
 
     // Ensure we have a buffer.
@@ -1072,7 +1074,8 @@ char* IpAddress::ToURL(char* buf, unsigned int blen) const {
     return buf;
 }
 
-void IpAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) const {
+void IpAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) const
+{
     struct sockaddr_in *sin = NULL;
 
     if ( family == AF_INET && !IsIPv4()) {
@@ -1097,7 +1100,8 @@ void IpAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) con
 #endif /* USE_IPV6 */
 }
 
-void IpAddress::GetSockAddr(struct sockaddr_in &buf) const {
+void IpAddress::GetSockAddr(struct sockaddr_in &buf) const
+{
 #if USE_IPV6
 
     if ( IsIPv4() ) {
@@ -1130,7 +1134,8 @@ void IpAddress::GetSockAddr(struct sockaddr_in &buf) const {
 
 #if USE_IPV6
 
-void IpAddress::GetSockAddr(struct sockaddr_in6 &buf) const {
+void IpAddress::GetSockAddr(struct sockaddr_in6 &buf) const
+{
     memcpy(&buf, &m_SocketAddr, sizeof(struct sockaddr_in6));
     /* maintain address family. It may have changed inside us. */
     buf.sin6_family = AF_INET6;
@@ -1145,7 +1150,8 @@ void IpAddress::GetSockAddr(struct sockaddr_in6 &buf) const {
 
 #if USE_IPV6
 
-void IpAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const {
+void IpAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const
+{
     /* check for special cases */
 
     if ( in.s_addr == 0x00000000) {
@@ -1169,7 +1175,8 @@ void IpAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const {
     }
 }
 
-void IpAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const {
+void IpAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const
+{
     /* ANYADDR */
     /* NOADDR */
     /* general */
@@ -1181,13 +1188,15 @@ void IpAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const {
 #endif
 
 #if USE_IPV6
-void IpAddress::GetInAddr(in6_addr &buf) const {
+void IpAddress::GetInAddr(in6_addr &buf) const
+{
     memcpy(&buf, &m_SocketAddr.sin6_addr, sizeof(struct in6_addr));
 }
 
 #endif
 
-bool IpAddress::GetInAddr(struct in_addr &buf) const {
+bool IpAddress::GetInAddr(struct in_addr &buf) const
+{
 
 #if USE_IPV6
     if ( IsIPv4() ) {
@@ -85,7 +85,8 @@
  * where structures of type ipcache_entry whose most
  * interesting members are:
  */
-class ipcache_entry {
+class ipcache_entry
+{
 public:
     hash_link hash;		/* must be first */
     time_t lastref;
@@ -656,7 +657,7 @@ ipcacheHandleReply(void *data, rfc1035_rr * answers, int na, const char *error_m
     IpcacheStats.replies++;
     const int age = i->age();
     statHistCount(&statCounter.dns.svc_time, age);
-                  
+
 #if USE_DNSSERVERS
 
     done = ipcacheParse(i, reply);
@@ -717,7 +717,7 @@ mainReconfigureFinish(void *)
     enter_suid();		/* root to read config file */
 
     // we may have disabled the need for PURGE
-    if(Config2.onoff.enable_purge)
+    if (Config2.onoff.enable_purge)
         Config2.onoff.enable_purge = 2;
 
     parseConfigFile(ConfigFile);
@@ -959,7 +959,7 @@ mainInitialize(void)
 
     accessLogInit();
 
-#if ICAP_CLIENT    
+#if ICAP_CLIENT
     icapLogOpen();
 #endif
 
@@ -1118,7 +1118,7 @@ static int SquidMainSafe(int argc, char **argv);
 #if USE_WIN32_SERVICE
 /* When USE_WIN32_SERVICE is defined, the main function is placed in win32.cc */
 extern "C" void WINAPI
-    SquidWinSvcMain(int argc, char **argv)
+SquidWinSvcMain(int argc, char **argv)
 #else
 int
 main(int argc, char **argv)
@@ -748,23 +748,23 @@ SQUIDCEXTERN int SquidMain(int, char **);
 SQUIDCEXTERN int WIN32_pipe(int[2]);
 
 SQUIDCEXTERN int WIN32_getrusage(int, struct rusage *);
-            SQUIDCEXTERN void WIN32_ExceptionHandlerInit(void);
+SQUIDCEXTERN void WIN32_ExceptionHandlerInit(void);
 
-            SQUIDCEXTERN int Win32__WSAFDIsSet(int fd, fd_set* set);
-            SQUIDCEXTERN DWORD WIN32_IpAddrChangeMonitorInit();
+SQUIDCEXTERN int Win32__WSAFDIsSet(int fd, fd_set* set);
+SQUIDCEXTERN DWORD WIN32_IpAddrChangeMonitorInit();
 
 #endif
 
-            /* external_acl.c */
-            class external_acl;
-            SQUIDCEXTERN void parse_externalAclHelper(external_acl **);
+/* external_acl.c */
+class external_acl;
+        SQUIDCEXTERN void parse_externalAclHelper(external_acl **);
 
-            SQUIDCEXTERN void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
+        SQUIDCEXTERN void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 
-            SQUIDCEXTERN void free_externalAclHelper(external_acl **);
+        SQUIDCEXTERN void free_externalAclHelper(external_acl **);
 
-            typedef void EAH(void *data, void *result);
-            class ACLChecklist;
+        typedef void EAH(void *data, void *result);
+        class ACLChecklist;
             SQUIDCEXTERN void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
 
             SQUIDCEXTERN void externalAclInit(void);
@@ -577,7 +577,7 @@ snmpConstructReponse(snmp_request_t * rq)
 
 static struct snmp_pdu *
 
-            snmpAgentResponse(struct snmp_pdu *PDU) {
+snmpAgentResponse(struct snmp_pdu *PDU) {
 
     struct snmp_pdu *Answer = NULL;
 
@@ -1536,7 +1536,7 @@ statCPUUsage(int minutes)
 }
 
 extern double
-    statRequestHitRatio(int minutes)
+statRequestHitRatio(int minutes)
 {
     assert(minutes < N_COUNT_HIST);
     return dpercent(CountHist[0].client_http.hits -
@@ -1546,7 +1546,7 @@ extern double
 }
 
 extern double
-    statRequestHitMemoryRatio(int minutes)
+statRequestHitMemoryRatio(int minutes)
 {
     assert(minutes < N_COUNT_HIST);
     return dpercent(CountHist[0].client_http.mem_hits -
@@ -1556,7 +1556,7 @@ extern double
 }
 
 extern double
-    statRequestHitDiskRatio(int minutes)
+statRequestHitDiskRatio(int minutes)
 {
     assert(minutes < N_COUNT_HIST);
     return dpercent(CountHist[0].client_http.disk_hits -
@@ -1566,7 +1566,7 @@ extern double
 }
 
 extern double
-    statByteHitRatio(int minutes)
+statByteHitRatio(int minutes)
 {
     size_t s;
     size_t c;
@@ -319,13 +319,13 @@ StoreEntry::storeClientType() const
 
         if (mem_obj->inmem_lo == 0 && !isEmpty()) {
             if (swap_status == SWAPOUT_DONE) {
-        	if (mem_obj->endOffset() == mem_obj->object_sz) {
-        	    /* hot object fully swapped in */
-        	    return STORE_MEM_CLIENT;
-        	}
+                if (mem_obj->endOffset() == mem_obj->object_sz) {
+                    /* hot object fully swapped in */
+                    return STORE_MEM_CLIENT;
+                }
             } else {
-        	/* Memory-only, or currently being swapped out */
-        	return STORE_MEM_CLIENT;
+                /* Memory-only, or currently being swapped out */
+                return STORE_MEM_CLIENT;
             }
         }
         return STORE_DISK_CLIENT;
@@ -1419,10 +1419,10 @@ StoreEntry::keepInMemory() const
         return 0;
 
     if (mem_obj->inmem_lo != 0)
-	return 0;
+        return 0;
 
     if (!Config.onoff.memory_cache_first && swap_status == SWAPOUT_DONE && refcount == 1)
-	return 0;
+        return 0;
 
     return 1;
 }
@@ -1844,10 +1844,10 @@ StoreEntry::trimMemory()
         return;
 
     if (!swapOutAble()) {
-	if (mem_obj->policyLowestOffsetToKeep(0) == 0) {
-	    /* Nothing to do */
-	    return;
-	}
+        if (mem_obj->policyLowestOffsetToKeep(0) == 0) {
+            /* Nothing to do */
+            return;
+        }
         /*
          * Its not swap-able, and we're about to delete a chunk,
          * so we must make it PRIVATE.  This is tricky/ugly because
@@ -474,7 +474,7 @@ store_client::fileRead()
 static void
 storeClientMemWriteComplete(void *data, StoreIOBuffer wroteBuffer)
 {
-        // Nothin to do here but callback is needed
+    // Nothin to do here but callback is needed
 }
 
 void
@@ -268,7 +268,7 @@ struct SquidConfig {
 
         customlog *accesslogs;
 
-#if ICAP_CLIENT        
+#if ICAP_CLIENT
         customlog *icaplogs;
 #endif
 
@@ -38,13 +38,13 @@
 StorePointer Store::CurrentRoot = NULL;
 
 extern "C" void
-    storeAppendPrintf(StoreEntry * e, const char *fmt,...)
+storeAppendPrintf(StoreEntry * e, const char *fmt,...)
 {
     fatal("storeAppendPrintf: Not implemented");
 }
 
 extern "C" void
-    storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
+storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
 {
     fatal("storeAppendVPrintf: Not implemented");
 }
@@ -551,7 +551,7 @@ wccp2_add_service_list(int service, int service_id, int service_priority,
 }
 
 static struct wccp2_service_list_t *
-            wccp2_get_service_by_id(int service, int service_id) {
+wccp2_get_service_by_id(int service, int service_id) {
 
     struct wccp2_service_list_t *p;
 
@@ -1,6 +1,5 @@
 #define  DEFAULT_HASH_SIZE 7951
-extern "C"
-{
+extern "C" {
     typedef unsigned int HASHHASH(const void *, unsigned int);
     struct _hash_link {
         char *key;
@@ -298,7 +298,7 @@ reply_done(int fd, void *data)
 }
 
 struct _request *
-            request(char *urlin) {
+request(char *urlin) {
     int s = -1, f = -1;
     char buf[4096];
     char msg[8192];
@@ -123,8 +123,7 @@
 #include <sys/select.h>
 #endif
 #if HAVE_FNMATCH_H
-extern "C"
-{
+extern "C" {
 #include <fnmatch.h>
 }
 #endif
@@ -880,7 +879,8 @@ process_request(cachemgr_request * req)
 }
 
 int
-main(int argc, char *argv[]) {
+main(int argc, char *argv[])
+{
     char *s;
     cachemgr_request *req;
 
@@ -912,7 +912,8 @@ main(int argc, char *argv[]) {
 }
 
 static char *
-read_post_request(void) {
+read_post_request(void)
+{
     char *s;
     char *buf;
     int len;
@@ -940,7 +941,8 @@ read_post_request(void) {
 }
 
 static char *
-read_get_request(void) {
+read_get_request(void)
+{
     char *s;
 
     if ((s = getenv("QUERY_STRING")) == NULL)
@@ -950,7 +952,8 @@ read_get_request(void) {
 }
 
 static cachemgr_request *
-read_request(void) {
+read_request(void)
+{
     char *buf;
 
     cachemgr_request *req;
@@ -1029,7 +1032,8 @@ read_request(void) {
  * Currently no powerful encryption is used.
  */
 static void
-make_pub_auth(cachemgr_request * req) {
+make_pub_auth(cachemgr_request * req)
+{
     static char buf[1024];
     safe_free(req->pub_auth);
     debug(3) fprintf(stderr, "cmgr: encoding for pub...\n");
@@ -1052,7 +1056,8 @@ make_pub_auth(cachemgr_request * req) {
 }
 
 static void
-decode_pub_auth(cachemgr_request * req) {
+decode_pub_auth(cachemgr_request * req)
+{
     char *buf;
     const char *host_name;
     const char *time_str;
@@ -1110,13 +1115,15 @@ decode_pub_auth(cachemgr_request * req) {
 }
 
 static void
-reset_auth(cachemgr_request * req) {
+reset_auth(cachemgr_request * req)
+{
     safe_free(req->passwd);
     safe_free(req->pub_auth);
 }
 
 static const char *
-make_auth_header(const cachemgr_request * req) {
+make_auth_header(const cachemgr_request * req)
+{
     static char buf[1024];
     size_t stringLength = 0;
     const char *str64;
@@ -1141,7 +1148,8 @@ make_auth_header(const cachemgr_request * req) {
 }
 
 static int
-check_target_acl(const char *hostname, int port) {
+check_target_acl(const char *hostname, int port)
+{
     char config_line[BUFSIZ];
     FILE *fp = NULL;
     int ret = 0;
@@ -636,7 +636,8 @@ main(int argc, char *argv[])
 }
 
 static int
-client_comm_bind(int sock, const IpAddress &addr) {
+client_comm_bind(int sock, const IpAddress &addr)
+{
 
     int res;
 
@@ -654,7 +655,8 @@ client_comm_bind(int sock, const IpAddress &addr) {
 }
 
 static int
-client_comm_connect(int sock, const IpAddress &addr, struct timeval *tvp) {
+client_comm_connect(int sock, const IpAddress &addr, struct timeval *tvp)
+{
     int res;
     static struct addrinfo *AI = NULL;
 
@@ -673,7 +675,8 @@ client_comm_connect(int sock, const IpAddress &addr, struct timeval *tvp) {
 }
 
 static int
-Now(struct timeval *tp) {
+Now(struct timeval *tp)
+{
 #if GETTIMEOFDAY_NO_TZP
     return gettimeofday(tp);
 #else
@@ -683,18 +686,21 @@ Now(struct timeval *tp) {
 }				/* ARGSUSED */
 
 static void
-catchSignal(int sig) {
+catchSignal(int sig)
+{
     interrupted = 1;
     fprintf(stderr, "Interrupted.\n");
 }
 
 static void
-pipe_handler(int sig) {
+pipe_handler(int sig)
+{
     fprintf(stderr, "SIGPIPE received.\n");
 }
 
 static void
-set_our_signal(void) {
+set_our_signal(void)
+{
 #if HAVE_SIGACTION
 
     struct sigaction sa;
@@ -714,7 +720,8 @@ set_our_signal(void) {
 }
 
 static ssize_t
-myread(int fd, void *buf, size_t len) {
+myread(int fd, void *buf, size_t len)
+{
 #ifndef _SQUID_MSWIN_
     alarm(io_timeout);
     return read(fd, buf, len);
@@ -725,7 +732,8 @@ myread(int fd, void *buf, size_t len) {
 }
 
 static ssize_t
-mywrite(int fd, void *buf, size_t len) {
+mywrite(int fd, void *buf, size_t len)
+{
 #ifndef _SQUID_MSWIN_
     alarm(io_timeout);
     return write(fd, buf, len);