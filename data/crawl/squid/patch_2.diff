----++++src/anyp/PortCfg.cc
@@ -40,17 +40,6 @@ AnyP::PortCfg::PortCfg() :
     vport(0),
     disable_pmtu_discovery(0),
     listenConn()
-#if USE_OPENSSL
-    ,
-    sslContextSessionId(NULL),
-    generateHostCertificates(true),
-    dynamicCertMemCacheSize(4*1024*1024), // 4 MB
-    signingCert(),
-    signPkey(),
-    certsToChain(),
-    untrustedSigningCert(),
-    untrustedSignPkey()
-#endif
 {
     memset(&amp;tcp_keepalive, 0, sizeof(tcp_keepalive));
 }
@@ -64,10 +53,6 @@ AnyP::PortCfg::~PortCfg()
 
     safe_free(name);
     safe_free(defaultsite);
-
-#if USE_OPENSSL
-    safe_free(sslContextSessionId);
-#endif
 }
 
 AnyP::PortCfgPointer
@@ -91,50 +76,6 @@ AnyP::PortCfg::clone() const
     b-&gt;tcp_keepalive = tcp_keepalive;
     b-&gt;secure = secure;
 
-#if USE_OPENSSL
-    if (sslContextSessionId)
-        b-&gt;sslContextSessionId = xstrdup(sslContextSessionId);
-
-#if 0
-    // TODO: AYJ: 2015-01-15: for now SSL does not clone the context object.
-    // cloning should only be done before the PortCfg is post-configure initialized and opened
-    Security::ContextPointer sslContext;
-#endif
-
-#endif /*0*/
-
     return b;
 }
 
-#if USE_OPENSSL
-void
-AnyP::PortCfg::configureSslServerContext()
-{
-    if (!secure.certs.empty()) {
-        Security::KeyData &amp;keys = secure.certs.front();
-        Ssl::readCertChainAndPrivateKeyFromFiles(signingCert, signPkey, certsToChain, keys.certFile.c_str(), keys.privateKeyFile.c_str());
-    }
-
-    if (!signingCert) {
-        char buf[128];
-        fatalf(&quot;No valid signing SSL certificate configured for %s_port %s&quot;, AnyP::ProtocolType_str[transport.protocol],  s.toUrl(buf, sizeof(buf)));
-    }
-
-    if (!signPkey)
-        debugs(3, DBG_IMPORTANT, &quot;No SSL private key configured for  &quot; &lt;&lt; AnyP::ProtocolType_str[transport.protocol] &lt;&lt; &quot;_port &quot; &lt;&lt; s);
-
-    Ssl::generateUntrustedCert(untrustedSigningCert, untrustedSignPkey,
-                               signingCert, signPkey);
-
-    if (!untrustedSigningCert) {
-        char buf[128];
-        fatalf(&quot;Unable to generate signing SSL certificate for untrusted sites for %s_port %s&quot;, AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
-    }
-
-    if (!secure.createStaticServerContext(*this)) {
-        char buf[128];
-        fatalf(&quot;%s_port %s initialization error&quot;, AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
-    }
-}
-#endif
-
----++++src/anyp/PortCfg.h
@@ -16,10 +16,6 @@
 #include &quot;sbuf/SBuf.h&quot;
 #include &quot;security/ServerOptions.h&quot;
 
-#if USE_OPENSSL
-#include &quot;ssl/gadgets.h&quot;
-#endif
-
 namespace AnyP
 {
 
@@ -29,10 +25,6 @@ class PortCfg : public RefCountable
     PortCfg();
     ~PortCfg();
     AnyP::PortCfgPointer clone() const;
-#if USE_OPENSSL
-    /// creates, configures, and validates SSL context and related port options
-    void configureSslServerContext();
-#endif
 
     PortCfgPointer next;
 
@@ -71,18 +63,6 @@ class PortCfg : public RefCountable
 
     /// TLS configuration options for this listening port
     Security::ServerOptions secure;
-
-#if USE_OPENSSL
-    char *sslContextSessionId; ///&lt; &quot;session id context&quot; for secure.staticSslContext
-    bool generateHostCertificates; ///&lt; dynamically make host cert for sslBump
-    size_t dynamicCertMemCacheSize; ///&lt; max size of generated certificates memory cache
-
-    Security::CertPointer signingCert; ///&lt; x509 certificate for signing generated certificates
-    Ssl::EVP_PKEY_Pointer signPkey; ///&lt; private key for sighing generated certificates
-    Ssl::X509_STACK_Pointer certsToChain; ///&lt;  x509 certificates to send with the generated cert
-    Security::CertPointer untrustedSigningCert; ///&lt; x509 certificate for signing untrusted generated certificates
-    Ssl::EVP_PKEY_Pointer untrustedSignPkey; ///&lt; private key for signing untrusted generated certificates
-#endif
 };
 
 } // namespace AnyP
----++++src/cache_cf.cc
@@ -168,9 +168,6 @@ static void defaults_postscriptum(void);
 static int parse_line(char *);
 static void parse_obsolete(const char *);
 static void parseBytesLine(size_t * bptr, const char *units);
-#if USE_OPENSSL
-static void parseBytesOptionValue(size_t * bptr, const char *units, char const * value);
-#endif
 static void parseBytesLineSigned(ssize_t * bptr, const char *units);
 static size_t parseBytesUnits(const char *unit);
 static void free_all(void);
@@ -915,14 +912,12 @@ configDoConfigure(void)
         }
     }
 
-#if USE_OPENSSL
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
         if (!s-&gt;secure.encryptTransport)
             continue;
         debugs(3, DBG_IMPORTANT, &quot;Initializing &quot; &lt;&lt; AnyP::UriScheme(s-&gt;transport.protocol) &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; TLS context&quot;);
-        s-&gt;configureSslServerContext();
+        s-&gt;secure.createSigningContexts(*s);
     }
-#endif
 
     // prevent infinite fetch loops in the request parser
     // due to buffer full but not enough data recived to finish parse
@@ -1265,7 +1260,8 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
  * Similar to the parseBytesLine function but parses the string value instead of
  * the current token value.
  */
-static void parseBytesOptionValue(size_t * bptr, const char *units, char const * value)
+void
+parseBytesOptionValue(size_t * bptr, const char *units, char const * value)
 {
     int u;
     if ((u = parseBytesUnits(units)) == 0) {
@@ -3735,17 +3731,13 @@ parse_port_option(AnyP::PortCfgPointer &amp;s, char *token)
         // NP: deprecation warnings output by secure.parse() when relevant
         s-&gt;secure.parse(token+3);
     } else if (strncmp(token, &quot;sslcontext=&quot;, 11) == 0) {
-        safe_free(s-&gt;sslContextSessionId);
-        s-&gt;sslContextSessionId = xstrdup(token + 11);
-    } else if (strcmp(token, &quot;generate-host-certificates&quot;) == 0) {
-        s-&gt;generateHostCertificates = true;
-    } else if (strcmp(token, &quot;generate-host-certificates=on&quot;) == 0) {
-        s-&gt;generateHostCertificates = true;
-    } else if (strcmp(token, &quot;generate-host-certificates=off&quot;) == 0) {
-        s-&gt;generateHostCertificates = false;
-    } else if (strncmp(token, &quot;dynamic_cert_mem_cache_size=&quot;, 28) == 0) {
-        parseBytesOptionValue(&amp;s-&gt;dynamicCertMemCacheSize, B_BYTES_STR, token + 28);
+        // NP: deprecation warnings output by secure.parse() when relevant
+        s-&gt;secure.parse(token+3);
+    } else if (strncmp(token, &quot;generate-host-certificates&quot;, 26) == 0) {
+        s-&gt;secure.parse(token);
 #endif
+    } else if (strncmp(token, &quot;dynamic_cert_mem_cache_size=&quot;, 28) == 0) {
+        s-&gt;secure.parse(token);
     } else if (strncmp(token, &quot;tls-&quot;, 4) == 0) {
         s-&gt;secure.parse(token+4);
     } else if (strcmp(token, &quot;ftp-track-dirs&quot;) == 0) {
@@ -3939,17 +3931,6 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfgPointer &amp;s)
 #endif
 
     s-&gt;secure.dumpCfg(e, &quot;tls-&quot;);
-
-#if USE_OPENSSL
-    if (s-&gt;sslContextSessionId)
-        storeAppendPrintf(e, &quot; sslcontext=%s&quot;, s-&gt;sslContextSessionId);
-
-    if (!s-&gt;generateHostCertificates)
-        storeAppendPrintf(e, &quot; generate-host-certificates=off&quot;);
-
-    if (s-&gt;dynamicCertMemCacheSize != 4*1024*1024) // 4MB default
-        storeAppendPrintf(e, &quot;dynamic_cert_mem_cache_size=%&quot; PRIuSIZE &quot;%s\n&quot;, s-&gt;dynamicCertMemCacheSize, B_BYTES_STR);
-#endif
 }
 
 static void
----++++src/cache_cf.h
@@ -24,6 +24,8 @@ void parse_eol(char *volatile *var);
 void parse_wordlist(wordlist ** list);
 void requirePathnameExists(const char *name, const char *path);
 void parse_time_t(time_t * var);
+/// Parse bytes number from a string
+void parseBytesOptionValue(size_t * bptr, const char *units, char const * value);
 
 #endif /* SQUID_CACHE_CF_H_ */
 
----++++src/client_side.cc
@@ -2838,7 +2838,7 @@ ConnStateData::sslCrtdHandleReply(const Helper::Reply &amp;reply)
                     Security::ContextPointer ctx(Security::GetFrom(fd_table[clientConnection-&gt;fd].ssl));
                     Ssl::configureUnconfiguredSslContext(ctx, signAlgorithm, *port);
                 } else {
-                    Security::ContextPointer ctx(Ssl::GenerateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str(), *port, (signAlgorithm == Ssl::algSignTrusted)));
+                    Security::ContextPointer ctx(Ssl::GenerateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str(), port-&gt;secure, (signAlgorithm == Ssl::algSignTrusted)));
                     if (ctx &amp;&amp; !sslBumpCertKey.isEmpty())
                         storeTlsContextToCache(sslBumpCertKey, ctx);
                     getSslContextDone(ctx);
@@ -2912,15 +2912,15 @@ void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &amp;cer
     assert(certProperties.signAlgorithm != Ssl::algSignEnd);
 
     if (certProperties.signAlgorithm == Ssl::algSignUntrusted) {
-        assert(port-&gt;untrustedSigningCert.get());
-        certProperties.signWithX509.resetAndLock(port-&gt;untrustedSigningCert.get());
-        certProperties.signWithPkey.resetAndLock(port-&gt;untrustedSignPkey.get());
+        assert(port-&gt;secure.untrustedSigningCert);
+        certProperties.signWithX509.resetAndLock(port-&gt;secure.untrustedSigningCert.get());
+        certProperties.signWithPkey.resetAndLock(port-&gt;secure.untrustedSignPkey.get());
     } else {
-        assert(port-&gt;signingCert.get());
-        certProperties.signWithX509.resetAndLock(port-&gt;signingCert.get());
+        assert(port-&gt;secure.signingCert.get());
+        certProperties.signWithX509.resetAndLock(port-&gt;secure.signingCert.get());
 
-        if (port-&gt;signPkey.get())
-            certProperties.signWithPkey.resetAndLock(port-&gt;signPkey.get());
+        if (port-&gt;secure.signPkey)
+            certProperties.signWithPkey.resetAndLock(port-&gt;secure.signPkey.get());
     }
     signAlgorithm = certProperties.signAlgorithm;
 
@@ -2967,7 +2967,7 @@ ConnStateData::getSslContextStart()
     }
     /* careful: finished() above frees request, host, etc. */
 
-    if (port-&gt;generateHostCertificates) {
+    if (port-&gt;secure.generateHostCertificates) {
         Ssl::CertificateProperties certProperties;
         buildSslCertGenerationParams(certProperties);
 
@@ -3012,7 +3012,7 @@ ConnStateData::getSslContextStart()
             Security::ContextPointer ctx(Security::GetFrom(fd_table[clientConnection-&gt;fd].ssl));
             Ssl::configureUnconfiguredSslContext(ctx, certProperties.signAlgorithm, *port);
         } else {
-            Security::ContextPointer dynCtx(Ssl::GenerateSslContext(certProperties, *port, (signAlgorithm == Ssl::algSignTrusted)));
+            Security::ContextPointer dynCtx(Ssl::GenerateSslContext(certProperties, port-&gt;secure, (signAlgorithm == Ssl::algSignTrusted)));
             if (dynCtx &amp;&amp; !sslBumpCertKey.isEmpty())
                 storeTlsContextToCache(sslBumpCertKey, dynCtx);
             getSslContextDone(dynCtx);
@@ -3027,7 +3027,7 @@ ConnStateData::getSslContextStart()
 void
 ConnStateData::getSslContextDone(Security::ContextPointer &amp;ctx)
 {
-    if (port-&gt;generateHostCertificates &amp;&amp; !ctx) {
+    if (port-&gt;secure.generateHostCertificates &amp;&amp; !ctx) {
         debugs(33, 2, &quot;Failed to generate TLS cotnext for &quot; &lt;&lt; sslConnectHostOrIp);
     }
 
@@ -3259,7 +3259,7 @@ ConnStateData::startPeekAndSplice()
     }
 
     // will call httpsPeeked() with certificate and connection, eventually
-    Security::ContextPointer unConfiguredCTX(Ssl::createSSLContext(port-&gt;signingCert, port-&gt;signPkey, *port));
+    Security::ContextPointer unConfiguredCTX(Ssl::createSSLContext(port-&gt;secure.signingCert, port-&gt;secure.signPkey, port-&gt;secure));
     fd_table[clientConnection-&gt;fd].dynamicTlsContext = unConfiguredCTX;
 
     if (!httpsCreate(clientConnection, unConfiguredCTX))
@@ -3491,16 +3491,15 @@ clientHttpConnectionsOpen(void)
                 debugs(33, DBG_IMPORTANT, &quot;WARNING: No ssl_bump configured. Disabling ssl-bump on &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s);
                 s-&gt;flags.tunnelSslBumping = false;
             }
-            if (!s-&gt;secure.staticContext &amp;&amp; !s-&gt;generateHostCertificates) {
+            if (!s-&gt;secure.staticContext &amp;&amp; !s-&gt;secure.generateHostCertificates) {
                 debugs(1, DBG_IMPORTANT, &quot;Will not bump SSL at &quot; &lt;&lt; scheme &lt;&lt; &quot;_port &quot; &lt;&lt; s-&gt;s &lt;&lt; &quot; due to TLS initialization failure.&quot;);
                 s-&gt;flags.tunnelSslBumping = false;
                 if (s-&gt;transport.protocol == AnyP::PROTO_HTTP)
                     s-&gt;secure.encryptTransport = false;
             }
             if (s-&gt;flags.tunnelSslBumping) {
                 // Create ssl_ctx cache for this port.
-                auto sz = s-&gt;dynamicCertMemCacheSize == std::numeric_limits&lt;size_t&gt;::max() ? 4194304 : s-&gt;dynamicCertMemCacheSize;
-                Ssl::TheGlobalContextStorage.addLocalStorage(s-&gt;s, sz);
+                Ssl::TheGlobalContextStorage.addLocalStorage(s-&gt;s, s-&gt;secure.dynamicCertMemCacheSize);
             }
         }
 
----++++src/security/PeerOptions.cc
@@ -282,10 +282,9 @@ Security::PeerOptions::createClientContext(bool setOptions)
 
     Security::ContextPointer t(createBlankContext());
     if (t) {
+        if (setOptions)
+            updateContextOptions(t);
 #if USE_OPENSSL
-        // NP: GnuTLS uses &#39;priorities&#39; which are set per-session instead.
-        SSL_CTX_set_options(t.get(), (setOptions ? parsedOptions : 0));
-
         // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
         Ssl::InitClientContext(t, *this, parsedFlags);
 #endif
@@ -594,6 +593,16 @@ Security::PeerOptions::loadCrlFile()
 #endif
 }
 
+void
+Security::PeerOptions::updateContextOptions(Security::ContextPointer &amp;ctx) const
+{
+#if USE_OPENSSL
+    SSL_CTX_set_options(ctx.get(), parsedOptions);
+#elif USE_GNUTLS
+    // NP: GnuTLS uses &#39;priorities&#39; which are set per-session instead.
+#endif
+}
+
 #if USE_OPENSSL &amp;&amp; defined(TLSEXT_TYPE_next_proto_neg)
 // Dummy next_proto_neg callback
 static int
----++++src/security/PeerOptions.h
@@ -44,6 +44,9 @@ class PeerOptions
     /// sync the context options with tls-min-version=N configuration
     void updateTlsVersionLimits();
 
+    /// Setup the library specific &#39;options=&#39; parameters for the given context.
+    void updateContextOptions(Security::ContextPointer &amp;) const;
+
     /// setup the NPN extension details for the given context
     void updateContextNpn(Security::ContextPointer &amp;);
 
----++++GitHub