diff --git a/ChangeLog b/ChangeLog
index 7e1e7f6..1c3b949 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,8 @@
 2012-03-03  Paul Smith  <psmith@gnu.org>
 
+	Convert uses of `foo' for quoting to 'foo' to reflect changes in
+	the GNU Coding Standards.  Fixes Savannah bug #34530.
+
 	* job.c (construct_command_argv_internal): In oneshell we need to
 	break the SHELLFLAGS up for argv.  Fixes Savannah bug #35397.
 
diff --git a/Makefile.am b/Makefile.am
index 133a579..45137a1 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -107,8 +107,8 @@ localedir =	$(datadir)/locale
 #
 
 # Whether or not make needs to be installed setgid.
-# The value should be either `true' or `false'.
-# On many systems, the getloadavg function (used to implement the `-l'
+# The value should be either 'true' or 'false'.
+# On many systems, the getloadavg function (used to implement the '-l'
 # switch) will not work unless make is installed setgid kmem.
 #
 inst_setgid = @NEED_SETGID@
@@ -124,7 +124,7 @@ install-exec-local:
 	     echo "chgrp $(inst_group) $$app && chmod g+s $$app"; \
 	   else \
 	     echo "$$app needs to be owned by group $(inst_group) and setgid;"; \
-	     echo "otherwise the \`-l' option will probably not work."; \
+	     echo "otherwise the '-l' option will probably not work."; \
 	     echo "You may need special privileges to complete the installation"; \
 	     echo "of $$app."; \
 	   fi; \
diff --git a/Makefile.ami b/Makefile.ami
index e0d47f3..e612182 100644
--- a/Makefile.ami
+++ b/Makefile.ami
@@ -1,7 +1,7 @@
 # -*-Makefile-*- for GNU make on Amiga
 #
-# NOTE: If you have no `make' program at all to process this makefile, run
-# `build.sh' instead.
+# NOTE: If you have no 'make' program at all to process this makefile, run
+# 'build.sh' instead.
 #
 # Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 # 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
@@ -32,18 +32,18 @@ CPPFLAGS =
 LDFLAGS =
 
 # Define these for your system as follows:
-#	-DNO_ARCHIVES		To disable `ar' archive support.
+#	-DNO_ARCHIVES		To disable 'ar' archive support.
 #	-DNO_FLOAT		To avoid using floating-point numbers.
 #	-DENUM_BITFIELDS	If the compiler isn't GCC but groks enum foo:2.
 #				Some compilers apparently accept this
 #				without complaint but produce losing code,
 #				so beware.
 # NeXT 1.0a uses an old version of GCC, which required -D__inline=inline.
-# See also `config.h'.
+# See also 'config.h'.
 defines =
 
 # Which flavor of remote job execution support to use.
-# The code is found in `remote-$(REMOTE).c'.
+# The code is found in 'remote-$(REMOTE).c'.
 REMOTE = stub
 
 # If you are using the GNU C library, or have the GNU getopt functions in
@@ -77,9 +77,9 @@ prefix =
 # Common prefix for machine-dependent installed files.
 exec_prefix =
 
-# Directory to install `make' in.
+# Directory to install 'make' in.
 bindir = sc:c
-# Directory to find libraries in for `-lXXX'.
+# Directory to find libraries in for '-lXXX'.
 libdir = lib:
 # Directory to search by default for included makefiles.
 includedir = include:
@@ -89,20 +89,20 @@ infodir = doc:
 mandir = t:
 # Number to put on the man page filename.
 manext = 1
-# Prefix to put on installed `make' binary file name.
+# Prefix to put on installed 'make' binary file name.
 binprefix =
-# Prefix to put on installed `make' man page file name.
+# Prefix to put on installed 'make' man page file name.
 manprefix = $(binprefix)
 
 # Whether or not make needs to be installed setgid.
-# The value should be either `true' or `false'.
-# On many systems, the getloadavg function (used to implement the `-l'
+# The value should be either 'true' or 'false'.
+# On many systems, the getloadavg function (used to implement the '-l'
 # switch) will not work unless make is installed setgid kmem.
 install_setgid = false
 # Install make setgid to this group so it can read /dev/kmem.
 group = sys
 
-# Program to install `make'.
+# Program to install 'make'.
 INSTALL_PROGRAM = copy
 # Program to install the man page.
 INSTALL_DATA = copy
@@ -145,7 +145,7 @@ srcs = $(srcdir)commands.c $(srcdir)job.c $(srcdir)dir.c             \
 all: make
 info: make.info
 dvi: make.dvi
-# Some makes apparently use .PHONY as the default goal if it is before `all'.
+# Some makes apparently use .PHONY as the default goal if it is before 'all'.
 .PHONY: all check info dvi
 
 make.info: make.texinfo
@@ -197,7 +197,7 @@ $(bindir)$(binprefix)make: make
 	     echo "chgrp $(group) $@.new && chmod g+s $@.new"; \
 	   else \
 	     echo "$@ needs to be owned by group $(group) and setgid;"; \
-	     echo "otherwise the \`-l' option will probably not work."; \
+	     echo "otherwise the '-l' option will probably not work."; \
 	     echo "You may need special privileges to install $@."; \
 	   fi; \
 	 else true; fi
@@ -214,9 +214,9 @@ $(infodir)make.info: make.info
 	    `echo $@ | sed "s,make.info\$$,$$name,"`; \
 	done
 # Run install-info only if it exists.
-# Use `if' instead of just prepending `-' to the
+# Use 'if' instead of just prepending '-' to the
 # line so we notice real errors from install-info.
-# We use `$(SHELL) -c' because some shells do not
+# We use '$(SHELL) -c' because some shells do not
 # fail gracefully when there is an unknown command.
 	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
 	  if [ -r ./make.info ]; then dir=.; else dir=$(srcdir); fi; \
@@ -267,8 +267,8 @@ glob-clean glob-realclean:
 .NOEXPORT:
 
 # The automatically generated dependencies below may omit config.h
-# because it is included with ``#include <config.h>'' rather than
-# ``#include "config.h"''.  So we add the explicit dependency to make sure.
+# because it is included with '#include <config.h>' rather than
+# '#include "config.h"'.  So we add the explicit dependency to make sure.
 $(objs): config.h
 
 # Automatically generated dependencies will be put at the end of the file.
diff --git a/README.DOS.template b/README.DOS.template
index c857b22..b7f9dee 100644
--- a/README.DOS.template
+++ b/README.DOS.template
@@ -8,12 +8,12 @@ New (since 3.74) DOS-specific features:
    1. Supports long filenames when run from DOS box on Windows 9x.
 
    2. Supports both stock DOS COMMAND.COM and Unix-style shells
-      (details in ``Notes'' below).
+      (details in 'Notes' below).
 
    3. Supports DOS drive letters in dependencies and pattern rules.
 
    4. Better support for DOS-style backslashes in pathnames (but see
-      ``Notes'' below).
+      'Notes' below).
 
    5. The $(shell) built-in can run arbitrary complex commands,
       including pipes and redirection, even when COMMAND.COM is your
@@ -55,7 +55,7 @@ To build from sources:
       either DJTAR (which is part of the DJGPP development
       environment), or the DJGPP port of GNU Tar.
 
-   2. Invoke the `configure.bat' batch file.
+   2. Invoke the 'configure.bat' batch file.
 
       If you are building Make in-place, i.e. in the same directory
       where its sources are kept, just type "configure.bat" and press
@@ -68,7 +68,7 @@ To build from sources:
       use them here.
 
    3. If configure.bat doesn't find a working Make, it will suggest to
-      use the `dosbuild.bat' batch file to build Make.  Either do as it
+      use the 'dosbuild.bat' batch file to build Make.  Either do as it
       suggests or install another Make program (a pre-compiled binary
       should be available from the usual DJGPP sites) and rerun
       configure.bat.
@@ -91,7 +91,7 @@ To build from sources:
       else Make might fail.
 
    6. After Make finishes, if you have a Unix-style shell installed,
-      you can use the `install' target to install the package.  You
+      you can use the 'install' target to install the package.  You
       will also need GNU Fileutils and GNU Sed for this (they should
       be available from the DJGPP sites).
 
@@ -107,12 +107,12 @@ To build from sources:
       Without a Unix-style shell, you will have to install programs
       and the docs manually.  Copy make.exe to a directory on your
       PATH, make.i* info files to your Info directory, and update the
-      file `dir' in your Info directory by adding the following item
+      file 'dir' in your Info directory by adding the following item
       to the main menu:
 
 	* Make: (make.info).           The GNU make utility.
 
-      If you have the `install-info' program (from the GNU Texinfo
+      If you have the 'install-info' program (from the GNU Texinfo
       package), it will do that for you if you invoke it like this:
 
 	install-info --info-dir=c:/djgpp/info c:/djgpp/info/make.info
@@ -120,8 +120,8 @@ To build from sources:
       (If your Info directory is other than C:\DJGPP\INFO, change this
       command accordingly.)
 
-   7. The `clean' targets also require Unix-style shell, and GNU Sed
-      and `rm' programs (the latter from Fileutils).
+   7. The 'clean' targets also require Unix-style shell, and GNU Sed
+      and 'rm' programs (the latter from Fileutils).
 
    8. To run the test suite, type "make check".  This requires a Unix
       shell (I used the DJGPP port of Bash 2.03), Perl, Sed, Fileutils
@@ -144,7 +144,7 @@ Notes:
 
       This port supports both DOS shells (the stock COMMAND.COM and its
       4DOS/NDOS replacements), and Unix-style shells (tested with the
-      venerable Stewartson's `ms_sh' 2.3 and the DJGPP port of `bash' by
+      venerable Stewartson's 'ms_sh' 2.3 and the DJGPP port of 'bash' by
       Daisuke Aoyama <jack@st.rim.or.jp>).
 
       When the $SHELL variable points to a Unix-style shell, Make
@@ -166,17 +166,17 @@ Notes:
       redirection and pipes, and shall only call the shell when a
       batch file or a command internal to the shell is invoked.  (Even
       when a command is an internal shell command, Make will first
-      search the $PATH for it, so that if a Makefile calls `mkdir',
-      you can install, say, a port of GNU `mkdir' and have it called
+      search the $PATH for it, so that if a Makefile calls 'mkdir',
+      you can install, say, a port of GNU 'mkdir' and have it called
       in that case.)
 
-      The key to all this is the extended functionality of `spawn' and
-      `system' functions from the DJGPP library; this port just calls
-      `system' where it would invoke the shell on Unix.  The most
+      The key to all this is the extended functionality of 'spawn' and
+      'system' functions from the DJGPP library; this port just calls
+      'system' where it would invoke the shell on Unix.  The most
       important aspect of these functions is that they use a special
       mechanism to pass long (up to 16KB) command lines to DJGPP
-      programs.  In addition, `system' emulates some internal
-      commands, like `cd' (so that you can now use forward slashes
+      programs.  In addition, 'system' emulates some internal
+      commands, like 'cd' (so that you can now use forward slashes
       with it, and can also change the drive if the directory is on
       another drive).  Another aspect worth mentioning is that you can
       call Unix shell scripts directly, provided that the shell whose
@@ -186,7 +186,7 @@ Notes:
       reference for more details.
 
       The $(shell) built-in is implemented in this port by calling
-      `popen'.  Since `popen' calls `system', the above considerations
+      'popen'.  Since 'popen' calls 'system', the above considerations
       are valid for $(shell) as well.  In particular, you can put
       arbitrary complex commands, including pipes and redirection,
       inside $(shell), which is in many cases a valid substitute for
@@ -197,12 +197,12 @@ Notes:
 
       Many Unix Makefiles include a line which sets the SHELL, for
       those versions of Make which don't have this as the default.
-      Since many DOS systems don't have `sh' installed (in fact, most
-      of them don't even have a `/bin' directory), this port takes
+      Since many DOS systems don't have 'sh' installed (in fact, most
+      of them don't even have a '/bin' directory), this port takes
       such directives with a grain of salt.  It will only honor such a
-      directive if the basename of the shell name (like `sh' in the
+      directive if the basename of the shell name (like 'sh' in the
       above example) can indeed be found in the directory that is
-      mentioned in the SHELL= line (`/bin' in the above example), or
+      mentioned in the SHELL= line ('/bin' in the above example), or
       in the current working directory, or anywhere on the $PATH (in
       that order).  If the basename doesn't include a filename
       extension, Make will look for any known extension that indicates
@@ -237,8 +237,8 @@ Notes:
       require such a shell).  More important, you can convert Unix
       Makefiles to MSDOS and leave the line which sets the shell
       intact, so that people who do have Unixy shell could use it for
-      targets which aren't converted to DOS (like `install' and
-      `uninstall', for example).
+      targets which aren't converted to DOS (like 'install' and
+      'uninstall', for example).
 
 
    3. Default directories.
@@ -258,14 +258,14 @@ Notes:
       If you run Make on Windows 9x, you should be aware of the
       letter-case issue.  Make is internally case-sensitive, but all
       file operations are case-insensitive on Windows 9x, so
-      e.g. files `FAQ', `faq' and `Faq' all refer to the same file, as
+      e.g. files 'FAQ', 'faq' and 'Faq' all refer to the same file, as
       far as Windows is concerned.  The underlying DJGPP C library
       functions honor the letter-case of the filenames they get from
       the OS, except that by default, they down-case 8+3 DOS filenames
       which are stored in upper case in the directory and would break
       many Makefiles otherwise.  (The details of which filenames are
       converted to lower case are explained in the DJGPP libc docs,
-      under the `_preserve_fncase' and `_lfn_gen_short_fname'
+      under the '_preserve_fncase' and '_lfn_gen_short_fname'
       functions, but as a thumb rule, any filename that is stored in
       upper case in the directory, is a valid DOS 8+3 filename and
       doesn't include characters invalid on MSDOS FAT filesystems,
@@ -282,8 +282,8 @@ Notes:
 
       There are a lot of places throughout the program sources which
       make implicit assumptions about the pathname syntax.  In
-      particular, the directories are assumed to be separated by `/',
-      and any pathname which doesn't begin with a `/' is assumed to be
+      particular, the directories are assumed to be separated by '/',
+      and any pathname which doesn't begin with a '/' is assumed to be
       relative to the current directory.  This port attempts to
       support DOS-style pathnames which might include the drive letter
       and use backslashes instead of forward slashes.  However, this
@@ -296,7 +296,7 @@ Notes:
       is the standard programs which come with MSDOS.  Otherwise, you
       are advised to stay away from backslashes whenever possible.  In
       particular, filename globbing won't work on pathnames with
-      backslashes, because the GNU `glob' library doesn't support them
+      backslashes, because the GNU 'glob' library doesn't support them
       (backslash is special in filename wildcards, and I didn't want
       to break that).
 
@@ -315,7 +315,7 @@ Bug reports:
    <djgpp@delorie.com>, which is an email gateway into the above news
    group).  For other bugs, please follow the procedure explained in
    the "Bugs" chapter of the Info docs.  If you don't have an Info
-   reader, look up that chapter in the `make.i1' file with any text
+   reader, look up that chapter in the 'make.i1' file with any text
    browser/editor.
 
 
diff --git a/README.OS2.template b/README.OS2.template
index 85d90b3..800f909 100644
--- a/README.OS2.template
+++ b/README.OS2.template
@@ -140,7 +140,7 @@ to do this but the testsuite ignores the environment. -DNO_CHDIR2 causes
 make not to use drive letters for directory names (i.e. _chdir2() and
 _getcwd2() are NOT used).  The testsuite interpretes the whole output of
 make, especially statements like make[1]: Entering directory
-`C:/somewhere/make-3.79.1/tests' where the testsuite does not expect the
+'C:/somewhere/make-3.79.1/tests' where the testsuite does not expect the
 drive letter. This would be interpreted as an error even if there is
 none.
 
diff --git a/README.customs b/README.customs
index eacdbc1..4b2e7b0 100644
--- a/README.customs
+++ b/README.customs
@@ -35,19 +35,19 @@ you'll need to re-apply them by hand.
 Install the Customs library and header files according to the
 documentation.  You should also install the man pages (contrary to
 comments in the documentation, they weren't installed automatically for
-me; I had to cd to the ``pmake-2.1.33/doc'' directory and run ``pmake
-install'' there directly).
+me; I had to cd to the 'pmake-2.1.33/doc' directory and run 'pmake
+install' there directly).
 
 
 BUILDING GNU MAKE
 -----------------
 
 Once you've installed Customs, you can build GNU make to use it.  When
-configuring GNU make, merely use the ``--with-customs=DIR'' option.
-Provide the directory containing the ``lib'' and ``include/customs''
+configuring GNU make, merely use the '--with-customs=DIR' option.
+Provide the directory containing the 'lib' and 'include/customs'
 subdirectories as DIR.  For example, if you installed the customs
 library in /usr/local/lib and the headers in /usr/local/include/customs,
-then you'd pass ``--with-customs=/usr/local'' as an option to configure.
+then you'd pass '--with-customs=/usr/local' as an option to configure.
 
 Run make (or use build.sh) normally to build GNU make as described in
 the INSTALL file.
diff --git a/README.template b/README.template
index 2e1d986..0e1999d 100644
--- a/README.template
+++ b/README.template
@@ -8,16 +8,16 @@ your operating system.
 
 For general building and installation instructions, see the file INSTALL.
 
-If you need to build GNU Make and have no other `make' program to use,
-you can use the shell script `build.sh' instead.  To do this, first run
-`configure' as described in INSTALL.  Then, instead of typing `make' to
-build the program, type `sh build.sh'.  This should compile the program
+If you need to build GNU Make and have no other 'make' program to use,
+you can use the shell script 'build.sh' instead.  To do this, first run
+'configure' as described in INSTALL.  Then, instead of typing 'make' to
+build the program, type 'sh build.sh'.  This should compile the program
 in the current directory.  Then you will have a Make program that you can
-use for `./make install', or whatever else.
+use for './make install', or whatever else.
 
 Some systems' Make programs are broken and cannot process the Makefile for
 GNU Make.  If you get errors from your system's Make when building GNU
-Make, try using `build.sh' instead.
+Make, try using 'build.sh' instead.
 
 
 GNU Make is free software.  See the file COPYING for copying conditions.
@@ -64,7 +64,7 @@ Bug Reporting
 -------------
 
 You can send GNU make bug reports to <bug-make@gnu.org>.  Please see the
-section of the GNU make manual entitled `Problems and Bugs' for
+section of the GNU make manual entitled 'Problems and Bugs' for
 information on submitting useful and complete bug reports.
 
 You can also use the online bug tracking system in the Savannah GNU Make
@@ -112,8 +112,8 @@ System-specific Notes
 ---------------------
 
 It has been reported that the XLC 1.2 compiler on AIX 3.2 is buggy such
-that if you compile make with `cc -O' on AIX 3.2, it will not work
-correctly.  It is said that using `cc' without `-O' does work.
+that if you compile make with 'cc -O' on AIX 3.2, it will not work
+correctly.  It is said that using 'cc' without '-O' does work.
 
 The standard /bin/sh on SunOS 4.1.3_U1 and 4.1.4 is broken and cannot be
 used to configure GNU make.  Please install a different shell such as
@@ -123,15 +123,15 @@ information:
 
 One area that is often a problem in configuration and porting is the code
 to check the system's current load average.  To make it easier to test and
-debug this code, you can do `make check-loadavg' to see if it works
-properly on your system.  (You must run `configure' beforehand, but you
+debug this code, you can do 'make check-loadavg' to see if it works
+properly on your system.  (You must run 'configure' beforehand, but you
 need not build Make itself to run this test.)
 
 Another potential source of porting problems is the support for large
 files (LFS) in configure for those operating systems that provide it.
 Please report any bugs that you find in this area.  If you run into
 difficulties, then as a workaround you should be able to disable LFS by
-adding the `--disable-largefile' option to the `configure' script.
+adding the '--disable-largefile' option to the 'configure' script.
 
 On systems that support micro- and nano-second timestamp values and
 where stat(2) provides this information, GNU make will use it when
diff --git a/SMakefile.template b/SMakefile.template
index cf4fa44..edb46be 100644
--- a/SMakefile.template
+++ b/SMakefile.template
@@ -26,7 +26,7 @@
 
 # Ultrix 2.2 make doesn't expand the value of VPATH.
 VPATH = /make-%VERSION%/
-# This must repeat the value, because configure will remove `VPATH = .'.
+# This must repeat the value, because configure will remove 'VPATH = .'.
 srcdir = /make-%VERSION%/
 
 CC = sc
@@ -38,18 +38,18 @@ CPPFLAGS =
 LDFLAGS =
 
 # Define these for your system as follows:
-#	-DNO_ARCHIVES		To disable `ar' archive support.
+#	-DNO_ARCHIVES		To disable 'ar' archive support.
 #	-DNO_FLOAT		To avoid using floating-point numbers.
 #	-DENUM_BITFIELDS	If the compiler isn't GCC but groks enum foo:2.
 #				Some compilers apparently accept this
 #				without complaint but produce losing code,
 #				so beware.
 # NeXT 1.0a uses an old version of GCC, which required -D__inline=inline.
-# See also `config.h'.
+# See also 'config.h'.
 defines =
 
 # Which flavor of remote job execution support to use.
-# The code is found in `remote-$(REMOTE).c'.
+# The code is found in 'remote-$(REMOTE).c'.
 REMOTE = stub
 
 # If you are using the GNU C library, or have the GNU getopt functions in
@@ -83,9 +83,9 @@ prefix =
 # Common prefix for machine-dependent installed files.
 exec_prefix =
 
-# Directory to install `make' in.
+# Directory to install 'make' in.
 bindir = sc:c
-# Directory to find libraries in for `-lXXX'.
+# Directory to find libraries in for '-lXXX'.
 libdir = lib:
 # Directory to search by default for included makefiles.
 includedir = include:
@@ -95,20 +95,20 @@ infodir = doc:
 mandir = t:
 # Number to put on the man page filename.
 manext = 1
-# Prefix to put on installed `make' binary file name.
+# Prefix to put on installed 'make' binary file name.
 binprefix =
-# Prefix to put on installed `make' man page file name.
+# Prefix to put on installed 'make' man page file name.
 manprefix = $(binprefix)
 
 # Whether or not make needs to be installed setgid.
-# The value should be either `true' or `false'.
-# On many systems, the getloadavg function (used to implement the `-l'
+# The value should be either 'true' or 'false'.
+# On many systems, the getloadavg function (used to implement the '-l'
 # switch) will not work unless make is installed setgid kmem.
 install_setgid = false
 # Install make setgid to this group so it can read /dev/kmem.
 group = sys
 
-# Program to install `make'.
+# Program to install 'make'.
 INSTALL_PROGRAM = copy
 # Program to install the man page.
 INSTALL_DATA = copy
@@ -151,7 +151,7 @@ srcs = $(srcdir)commands.c $(srcdir)job.c $(srcdir)dir.c             \
 all: make
 info: make.info
 dvi: make.dvi
-# Some makes apparently use .PHONY as the default goal if it is before `all'.
+# Some makes apparently use .PHONY as the default goal if it is before 'all'.
 .PHONY: all check info dvi
 
 make.info: make.texinfo
diff --git a/alloca.c b/alloca.c
index 6e009b4..02ac921 100644
--- a/alloca.c
+++ b/alloca.c
@@ -116,7 +116,7 @@ static int stack_dir;		/* 1 or -1 once known.  */
 static void
 find_stack_direction (void)
 {
-  static char *addr = NULL;	/* Address of first `dummy', once known.  */
+  static char *addr = NULL;	/* Address of first 'dummy', once known.  */
   auto char dummy;		/* To get stack address.  */
 
   if (addr == NULL)
diff --git a/ar.c b/ar.c
index 5eda266..69993d0 100644
--- a/ar.c
+++ b/ar.c
@@ -1,4 +1,4 @@
-/* Interface to `ar' archives for GNU Make.
+/* Interface to 'ar' archives for GNU Make.
 Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
 2012 Free Software Foundation, Inc.
@@ -26,9 +26,9 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #include <fnmatch.h>
 
 /* Return nonzero if NAME is an archive-member reference, zero if not.  An
-   archive-member reference is a name like `lib(member)' where member is a
+   archive-member reference is a name like 'lib(member)' where member is a
    non-empty string.
-   If a name like `lib((entry))' is used, a fatal error is signaled at
+   If a name like 'lib((entry))' is used, a fatal error is signaled at
    the attempt to use this unsupported feature.  */
 
 int
@@ -45,7 +45,7 @@ ar_name (const char *name)
     return 0;
 
   if (p[1] == '(' && end[-1] == ')')
-    fatal (NILF, _("attempt to use unsupported feature: `%s'"), name);
+    fatal (NILF, _("attempt to use unsupported feature: '%s'"), name);
 
   return 1;
 }
@@ -68,7 +68,7 @@ ar_parse_name (const char *name, char **arname_p, char **memname_p)
 }
 
 
-/* This function is called by `ar_scan' to find which member to look at.  */
+/* This function is called by 'ar_scan' to find which member to look at.  */
 
 /* ARGSUSED */
 static long int
@@ -146,24 +146,24 @@ ar_touch (const char *name)
   switch (ar_member_touch (arname, memname))
     {
     case -1:
-      error (NILF, _("touch: Archive `%s' does not exist"), arname);
+      error (NILF, _("touch: Archive '%s' does not exist"), arname);
       break;
     case -2:
-      error (NILF, _("touch: `%s' is not a valid archive"), arname);
+      error (NILF, _("touch: '%s' is not a valid archive"), arname);
       break;
     case -3:
       perror_with_name ("touch: ", arname);
       break;
     case 1:
       error (NILF,
-             _("touch: Member `%s' does not exist in `%s'"), memname, arname);
+             _("touch: Member '%s' does not exist in '%s'"), memname, arname);
       break;
     case 0:
       val = 0;
       break;
     default:
       error (NILF,
-             _("touch: Bad return code from ar_member_touch on `%s'"), name);
+             _("touch: Bad return code from ar_member_touch on '%s'"), name);
     }
 
   free (arname);
@@ -172,7 +172,7 @@ ar_touch (const char *name)
 }
 #endif /* !VMS */
 
-/* State of an `ar_glob' run, passed to `ar_glob_match'.  */
+/* State of an 'ar_glob' run, passed to 'ar_glob_match'.  */
 
 struct ar_glob_state
   {
@@ -183,7 +183,7 @@ struct ar_glob_state
     unsigned int n;
   };
 
-/* This function is called by `ar_scan' to match one archive
+/* This function is called by 'ar_scan' to match one archive
    element against the pattern in STATE.  */
 
 static long int
diff --git a/arscan.c b/arscan.c
index c50b043..b9206bb 100644
--- a/arscan.c
+++ b/arscan.c
@@ -184,7 +184,7 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
 
   if (! (status & 1))
     {
-      error (NILF, _("unable to open library `%s' to lookup member `%s'"),
+      error (NILF, _("unable to open library '%s' to lookup member '%s'"),
 	     archive, (char *)arg);
       return -1;
     }
@@ -847,7 +847,7 @@ describe_member (int desc, const char *name, int truncated,
 {
   extern char *ctime ();
 
-  printf (_("Member `%s'%s: %ld bytes at %ld (%ld).\n"),
+  printf (_("Member '%s'%s: %ld bytes at %ld (%ld).\n"),
 	  name, truncated ? _(" (name might be truncated)") : "",
 	  size, hdrpos, datapos);
   printf (_("  Date %s"), ctime (&date));
diff --git a/build.template b/build.template
index 07ee486..7c31050 100644
--- a/build.template
+++ b/build.template
@@ -1,5 +1,5 @@
 #!/bin/sh
-# Shell script to build GNU Make in the absence of any `make' program.
+# Shell script to build GNU Make in the absence of any 'make' program.
 # @configure_input@
 
 # Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -40,7 +40,7 @@ EXEEXT='@EXEEXT@'
 prefix='@prefix@'
 # Common prefix for machine-dependent installed files.
 exec_prefix=`eval echo @exec_prefix@`
-# Directory to find libraries in for `-lXXX'.
+# Directory to find libraries in for '-lXXX'.
 libdir=${exec_prefix}/lib
 # Directory to search by default for included makefiles.
 includedir=${prefix}/include
diff --git a/commands.c b/commands.c
index 87f2369..147fabc 100644
--- a/commands.c
+++ b/commands.c
@@ -71,8 +71,8 @@ set_file_variables (struct file *file)
   const char *at, *percent, *star, *less;
 
 #ifndef	NO_ARCHIVES
-  /* If the target is an archive member `lib(member)',
-     then $@ is `lib' and $% is `member'.  */
+  /* If the target is an archive member 'lib(member)',
+     then $@ is 'lib' and $% is 'member'.  */
 
   if (ar_name (file->name))
     {
@@ -103,7 +103,7 @@ set_file_variables (struct file *file)
     {
       /* In Unix make, $* is set to the target name with
 	 any suffix in the .SUFFIXES list stripped off for
-	 explicit rules.  We store this in the `stem' member.  */
+	 explicit rules.  We store this in the 'stem' member.  */
       const char *name;
       unsigned int len;
 
@@ -325,7 +325,7 @@ set_file_variables (struct file *file)
 }
 
 /* Chop CMDS up into individual command lines if necessary.
-   Also set the `lines_flags' and `any_recurse' members.  */
+   Also set the 'lines_flags' and 'any_recurse' members.  */
 
 void
 chop_commands (struct commands *cmds)
@@ -622,10 +622,10 @@ delete_target (struct file *file, const char *on_behalf_of)
       if (ar_member_date (file->name) != file_date)
 	{
 	  if (on_behalf_of)
-	    error (NILF, _("*** [%s] Archive member `%s' may be bogus; not deleted"),
+	    error (NILF, _("*** [%s] Archive member '%s' may be bogus; not deleted"),
 		   on_behalf_of, file->name);
 	  else
-	    error (NILF, _("*** Archive member `%s' may be bogus; not deleted"),
+	    error (NILF, _("*** Archive member '%s' may be bogus; not deleted"),
 		   file->name);
 	}
       return;
@@ -638,9 +638,9 @@ delete_target (struct file *file, const char *on_behalf_of)
       && FILE_TIMESTAMP_STAT_MODTIME (file->name, st) != file->last_mtime)
     {
       if (on_behalf_of)
-	error (NILF, _("*** [%s] Deleting file `%s'"), on_behalf_of, file->name);
+	error (NILF, _("*** [%s] Deleting file '%s'"), on_behalf_of, file->name);
       else
-	error (NILF, _("*** Deleting file `%s'"), file->name);
+	error (NILF, _("*** Deleting file '%s'"), file->name);
       if (unlink (file->name) < 0
 	  && errno != ENOENT)	/* It disappeared; so what.  */
 	perror_with_name ("unlink: ", file->name);
@@ -662,7 +662,7 @@ delete_child_targets (struct child *child)
   /* Delete the target file if it changed.  */
   delete_target (child->file, NULL);
 
-  /* Also remove any non-precious targets listed in the `also_make' member.  */
+  /* Also remove any non-precious targets listed in the 'also_make' member.  */
   for (d = child->file->also_make; d != 0; d = d->next)
     delete_target (d->file, child->file->name);
 
@@ -681,7 +681,7 @@ print_commands (const struct commands *cmds)
   if (cmds->fileinfo.filenm == 0)
     puts (_(" (built-in):"));
   else
-    printf (_(" (from `%s', line %lu):\n"),
+    printf (_(" (from '%s', line %lu):\n"),
             cmds->fileinfo.filenm, cmds->fileinfo.lineno);
 
   s = cmds->commands;
diff --git a/commands.h b/commands.h
index 8f08aab..61dfef6 100644
--- a/commands.h
+++ b/commands.h
@@ -27,11 +27,11 @@ struct commands
     char *lines_flags;		/* One set of flag bits for each line.  */
     unsigned short ncommand_lines;/* Number of command lines.  */
     char recipe_prefix;         /* Recipe prefix for this command set.  */
-    unsigned int any_recurse:1; /* Nonzero if any `lines_flags' elt has */
+    unsigned int any_recurse:1; /* Nonzero if any 'lines_flags' elt has */
 				/* the COMMANDS_RECURSE bit set.  */
   };
 
-/* Bits in `lines_flags'.  */
+/* Bits in 'lines_flags'.  */
 #define	COMMANDS_RECURSE	1 /* Recurses: + or $(MAKE).  */
 #define	COMMANDS_SILENT		2 /* Silent: @.  */
 #define	COMMANDS_NOERROR	4 /* No errors: -.  */
diff --git a/config.ami.template b/config.ami.template
index 947d5a1..2376c23 100644
--- a/config.ami.template
+++ b/config.ami.template
@@ -38,14 +38,14 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define for DGUX with <sys/dg_sys_info.h>.  */
 /* #undef DGUX */
 
-/* Define if the `getloadavg' function needs to be run setuid or setgid.  */
+/* Define if the 'getloadavg' function needs to be run setuid or setgid.  */
 /* #undef GETLOADAVG_PRIVILEGED */
 
-/* Define to `unsigned long' or `unsigned long long'
+/* Define to 'unsigned long' or 'unsigned long long'
    if <inttypes.h> doesn't define.  */
 #define uintmax_t unsigned long
 
-/* Define to `int' if <sys/types.h> doesn't define.  */
+/* Define to 'int' if <sys/types.h> doesn't define.  */
 #define gid_t int
 
 /* Define if you have alloca, as a function or macro.  */
@@ -60,7 +60,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define if your system has a working fnmatch function.  */
 /* #undef HAVE_FNMATCH */
 
-/* Define if your system has its own `getloadavg' function.  */
+/* Define if your system has its own 'getloadavg' function.  */
 /* #undef HAVE_GETLOADAVG */
 
 /* Define if you have the getmntent function.  */
@@ -69,13 +69,13 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Embed GNU Guile support */
 /* #undef HAVE_GUILE */
 
-/* Define if the `long double' type works.  */
+/* Define if the 'long double' type works.  */
 /* #undef HAVE_LONG_DOUBLE */
 
 /* Define if you support file names longer than 14 characters.	*/
 #define HAVE_LONG_FILE_NAMES 1
 
-/* Define if you have a working `mmap' system call.  */
+/* Define if you have a working 'mmap' system call.  */
 /* #undef HAVE_MMAP */
 
 /* Define if system calls automatically restart after interruption
@@ -134,7 +134,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define if your C compiler doesn't accept -c and -o together.  */
 /* #undef NO_MINUS_C_MINUS_O */
 
-/* Define to `int' if <sys/types.h> doesn't define.  */
+/* Define to 'int' if <sys/types.h> doesn't define.  */
 #define pid_t int
 
 /* Define if the system does not provide POSIX.1 features except
@@ -161,7 +161,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
  */
 #define STACK_DIRECTION -1
 
-/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
+/* Define if the 'S_IS*' macros in <sys/stat.h> do not work properly.  */
 /* #undef STAT_MACROS_BROKEN */
 
 /* Define if your compiler conforms to the ANSI C standard. */
@@ -173,10 +173,10 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define on System V Release 4.  */
 /* #undef SVR4 */
 
-/* Define if `sys_siglist' is declared by <signal.h>.  */
+/* Define if 'sys_siglist' is declared by <signal.h>.  */
 /* #undef SYS_SIGLIST_DECLARED */
 
-/* Define to `int' if <sys/types.h> doesn't define.  */
+/* Define to 'int' if <sys/types.h> doesn't define.  */
 #define uid_t int
 
 /* Define for Encore UMAX.  */
@@ -195,10 +195,10 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Version of this package (needed by automake) */
 #define VERSION "%VERSION%"
 
-/* Define to the name of the SCCS `get' command.  */
+/* Define to the name of the SCCS 'get' command.  */
 #define SCCS_GET "get"
 
-/* Define this if the SCCS `get' command understands the `-G<file>' option.  */
+/* Define this if the SCCS 'get' command understands the '-G<file>' option.  */
 /* #undef SCCS_GET_MINUS_G */
 
 /* Define this to enable job server support in GNU make.  */
@@ -208,13 +208,13 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
    if it exists.  */
 /* #undef ST_MTIM_NSEC */
 
-/* Define this if the C library defines the variable `sys_siglist'.  */
+/* Define this if the C library defines the variable 'sys_siglist'.  */
 /* #undef HAVE_SYS_SIGLIST */
 
-/* Define this if the C library defines the variable `_sys_siglist'.  */
+/* Define this if the C library defines the variable '_sys_siglist'.  */
 /* #undef HAVE__SYS_SIGLIST */
 
-/* Define this if you have the `union wait' type in <sys/wait.h>.  */
+/* Define this if you have the 'union wait' type in <sys/wait.h>.  */
 /* #undef HAVE_UNION_WAIT */
 
 /* Define if you have the dup2 function.  */
diff --git a/config.h-vms.template b/config.h-vms.template
index b59c951..440fc62 100644
--- a/config.h-vms.template
+++ b/config.h-vms.template
@@ -60,14 +60,14 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define for DGUX with <sys/dg_sys_info.h>.  */
 /* #undef DGUX */
 
-/* Define to 1 if the `getloadavg' function needs to be run setuid or setgid.  */
+/* Define to 1 if the 'getloadavg' function needs to be run setuid or setgid.  */
 /* #undef GETLOADAVG_PRIVILEGED */
 
-/* Define to `unsigned long' or `unsigned long long'
+/* Define to 'unsigned long' or 'unsigned long long'
    if <inttypes.h> doesn't define.  */
 #define uintmax_t unsigned long
 
-/* Define to `int' if <sys/types.h> doesn't define.  */
+/* Define to 'int' if <sys/types.h> doesn't define.  */
 /* #undef gid_t */
 
 /* Define to 1 if you have alloca, as a function or macro.  */
@@ -85,19 +85,19 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if your system has a working fnmatch function.  */
 /* #undef HAVE_FNMATCH */
 
-/* Define to 1 if your system has its own `getloadavg' function.  */
+/* Define to 1 if your system has its own 'getloadavg' function.  */
 /* #undef HAVE_GETLOADAVG */
 
 /* Define to 1 if you have the getmntent function.  */
 /* #undef HAVE_GETMNTENT */
 
-/* Define to 1 if the `long double' type works.  */
+/* Define to 1 if the 'long double' type works.  */
 /* #undef HAVE_LONG_DOUBLE */
 
 /* Define to 1 if you support file names longer than 14 characters.  */
 #define HAVE_LONG_FILE_NAMES 1
 
-/* Define to 1 if you have a working `mmap' system call.  */
+/* Define to 1 if you have a working 'mmap' system call.  */
 /* #undef HAVE_MMAP */
 
 /* Define to 1 if system calls automatically restart after interruption
@@ -163,7 +163,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if your C compiler doesn't accept -c and -o together.  */
 /* #undef NO_MINUS_C_MINUS_O */
 
-/* Define to `int' if <sys/types.h> doesn't define.  */
+/* Define to 'int' if <sys/types.h> doesn't define.  */
 /* I assume types.h is available for all 5.0 cc/cxx compilers */
 #if __DECC_VER < 50090000
 #define pid_t int
@@ -193,7 +193,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
  */
 /* #undef STACK_DIRECTION */
 
-/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
+/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly.  */
 /* #undef STAT_MACROS_BROKEN */
 
 /* Define to 1 if you have the ANSI C header files.  */
@@ -202,10 +202,10 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define on System V Release 4.  */
 /* #undef SVR4 */
 
-/* Define to 1 if `sys_siglist' is declared by <signal.h>.  */
+/* Define to 1 if 'sys_siglist' is declared by <signal.h>.  */
 /* #undef SYS_SIGLIST_DECLARED */
 
-/* Define to `int' if <sys/types.h> doesn't define.  */
+/* Define to 'int' if <sys/types.h> doesn't define.  */
 #if __DECC_VER < 50090000
 #define uid_t int
 #endif
@@ -226,10 +226,10 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Version of this package (needed by automake) */
 #define VERSION "%VERSION%"
 
-/* Define to the name of the SCCS `get' command.  */
+/* Define to the name of the SCCS 'get' command.  */
 /* #undef SCCS_GET */
 
-/* Define this if the SCCS `get' command understands the `-G<file>' option.  */
+/* Define this if the SCCS 'get' command understands the '-G<file>' option.  */
 /* #undef SCCS_GET_MINUS_G */
 
 /* Define this to enable job server support in GNU make.  */
@@ -239,13 +239,13 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
    if it exists.  */
 /* #undef ST_MTIM_NSEC */
 
-/* Define to 1 if the C library defines the variable `sys_siglist'.  */
+/* Define to 1 if the C library defines the variable 'sys_siglist'.  */
 /* #undefine HAVE_SYS_SIGLIST */
 
-/* Define to 1 if the C library defines the variable `_sys_siglist'.  */
+/* Define to 1 if the C library defines the variable '_sys_siglist'.  */
 /* #undef HAVE__SYS_SIGLIST */
 
-/* Define to 1 if you have the `union wait' type in <sys/wait.h>.  */
+/* Define to 1 if you have the 'union wait' type in <sys/wait.h>.  */
 /* #undef HAVE_UNION_WAIT */
 
 /* Define to 1 if you have the dup2 function.  */
diff --git a/config.h.W32.template b/config.h.W32.template
index 2c5c02d..95c0244 100644
--- a/config.h.W32.template
+++ b/config.h.W32.template
@@ -28,18 +28,18 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 # define _CRT_NONSTDC_NO_WARNINGS /* functions w/o a leading underscore */
 #endif
 
-/* Define to 1 if the `closedir' function returns void instead of `int'. */
+/* Define to 1 if the 'closedir' function returns void instead of 'int'. */
 /* #undef CLOSEDIR_VOID */
 
-/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
-   systems. This function is required for `alloca.c' support on those systems.
+/* Define to one of '_getb67', 'GETB67', 'getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for 'alloca.c' support on those systems.
    */
 /* #undef CRAY_STACKSEG_END */
 
-/* Define to 1 if using `alloca.c'. */
+/* Define to 1 if using 'alloca.c'. */
 /* #undef C_ALLOCA */
 
-/* Define to 1 if using `getloadavg.c'. */
+/* Define to 1 if using 'getloadavg.c'. */
 #define C_GETLOADAVG 1
 
 /* Define to 1 for DGUX with <sys/dg_sys_info.h>. */
@@ -52,11 +52,11 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Use high resolution file timestamps if nonzero. */
 #define FILE_TIMESTAMP_HI_RES 0
 
-/* Define to 1 if the `getloadavg' function needs to be run setuid or setgid.
+/* Define to 1 if the 'getloadavg' function needs to be run setuid or setgid.
    */
 /* #undef GETLOADAVG_PRIVILEGED */
 
-/* Define to 1 if you have `alloca', as a function or macro. */
+/* Define to 1 if you have 'alloca', as a function or macro. */
 #define HAVE_ALLOCA 1
 
 /* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
@@ -66,7 +66,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if your compiler conforms to the ANSI C standard. */
 #define HAVE_ANSI_COMPILER 1
 
-/* Define to 1 if you have the `atexit' function. */
+/* Define to 1 if you have the 'atexit' function. */
 #define HAVE_ATEXIT 1
 
 /* Use case insensitive file names */
@@ -83,23 +83,23 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
    */
 /* #undef HAVE_DCGETTEXT */
 
-/* Define to 1 if you have the declaration of `bsd_signal', and to 0 if you
+/* Define to 1 if you have the declaration of 'bsd_signal', and to 0 if you
    don't. */
 #define HAVE_DECL_BSD_SIGNAL 0
 
-/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you
+/* Define to 1 if you have the declaration of 'sys_siglist', and to 0 if you
    don't. */
 #define HAVE_DECL_SYS_SIGLIST 0
 
-/* Define to 1 if you have the declaration of `_sys_siglist', and to 0 if you
+/* Define to 1 if you have the declaration of '_sys_siglist', and to 0 if you
    don't. */
 #define HAVE_DECL__SYS_SIGLIST 0
 
-/* Define to 1 if you have the declaration of `__sys_siglist', and to 0 if you
+/* Define to 1 if you have the declaration of '__sys_siglist', and to 0 if you
    don't. */
 #define HAVE_DECL___SYS_SIGLIST 0
 
-/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.
    */
 #define HAVE_DIRENT_H 1
 
@@ -110,45 +110,45 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 # define HAVE_DIRECT_H 1
 #endif
 
-/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+/* Define to 1 if you don't have 'vprintf' but do have '_doprnt.' */
 /* #undef HAVE_DOPRNT */
 
 /* Use platform specific coding */
 #define HAVE_DOS_PATHS 1
 
-/* Define to 1 if you have the `dup2' function. */
+/* Define to 1 if you have the 'dup2' function. */
 #define HAVE_DUP2 1
 
 /* Define to 1 if you have the <fcntl.h> header file. */
 #define HAVE_FCNTL_H 1
 
-/* Define to 1 if you have the `fdopen' function. */
+/* Define to 1 if you have the 'fdopen' function. */
 #ifdef __MINGW32__
 #define HAVE_FDOPEN 1
 #endif
 
-/* Define to 1 if you have the `fileno' function. */
+/* Define to 1 if you have the 'fileno' function. */
 #define HAVE_FILENO 1
 
-/* Define to 1 if you have the `fork' function. */
+/* Define to 1 if you have the 'fork' function. */
 /* #undef HAVE_FORK */
 
-/* Define to 1 if you have the `getcwd' function.  */
+/* Define to 1 if you have the 'getcwd' function.  */
 #define HAVE_GETCWD 1
 
-/* Define to 1 if you have the `getgroups' function. */
+/* Define to 1 if you have the 'getgroups' function. */
 /* #undef HAVE_GETGROUPS */
 
-/* Define to 1 if you have the `gethostbyname' function. */
+/* Define to 1 if you have the 'gethostbyname' function. */
 /* #undef HAVE_GETHOSTBYNAME */
 
-/* Define to 1 if you have the `gethostname' function. */
+/* Define to 1 if you have the 'gethostname' function. */
 /* #undef HAVE_GETHOSTNAME */
 
-/* Define to 1 if you have the `getloadavg' function. */
+/* Define to 1 if you have the 'getloadavg' function. */
 /* #undef HAVE_GETLOADAVG */
 
-/* Define to 1 if you have the `getrlimit' function. */
+/* Define to 1 if you have the 'getrlimit' function. */
 /* #undef HAVE_GETRLIMIT */
 
 /* Define if the GNU gettext() function is already present or preinstalled. */
@@ -167,10 +167,10 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define HAVE_INTTYPES_H 1
 #endif
 
-/* Define to 1 if you have the `dgc' library (-ldgc). */
+/* Define to 1 if you have the 'dgc' library (-ldgc). */
 /* #undef HAVE_LIBDGC */
 
-/* Define to 1 if you have the `kstat' library (-lkstat). */
+/* Define to 1 if you have the 'kstat' library (-lkstat). */
 /* #undef HAVE_LIBKSTAT */
 
 /* Define to 1 if you have the <limits.h> header file. */
@@ -179,7 +179,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the <locale.h> header file. */
 /*#define HAVE_LOCALE_H 1*/
 
-/* Define to 1 if you have the `lstat' function. */
+/* Define to 1 if you have the 'lstat' function. */
 /* #undef HAVE_LSTAT */
 
 /* Define to 1 if you have the <mach/mach.h> header file. */
@@ -188,64 +188,64 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the <memory.h> header file. */
 #define HAVE_MEMORY_H 1
 
-/* Define to 1 if you have the `mkstemp' function. */
+/* Define to 1 if you have the 'mkstemp' function. */
 /* #undef HAVE_MKSTEMP */
 
-/* Define to 1 if you have the `mktemp' function. */
+/* Define to 1 if you have the 'mktemp' function. */
 #define HAVE_MKTEMP 1
 
-/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */
 /* #undef HAVE_NDIR_H */
 
 /* Define to 1 if you have the <nlist.h> header file. */
 /* #undef HAVE_NLIST_H */
 
-/* Define to 1 if you have the `pipe' function. */
+/* Define to 1 if you have the 'pipe' function. */
 /* #undef HAVE_PIPE */
 
-/* Define to 1 if you have the `pstat_getdynamic' function. */
+/* Define to 1 if you have the 'pstat_getdynamic' function. */
 /* #undef HAVE_PSTAT_GETDYNAMIC */
 
-/* Define to 1 if you have the `readlink' function. */
+/* Define to 1 if you have the 'readlink' function. */
 /* #undef HAVE_READLINK */
 
-/* Define to 1 if you have the `realpath' function. */
+/* Define to 1 if you have the 'realpath' function. */
 /* #undef HAVE_REALPATH */
 
 /* Define to 1 if <signal.h> defines the SA_RESTART constant. */
 /* #undef HAVE_SA_RESTART */
 
-/* Define to 1 if you have the `setegid' function. */
+/* Define to 1 if you have the 'setegid' function. */
 /* #undef HAVE_SETEGID */
 
-/* Define to 1 if you have the `seteuid' function. */
+/* Define to 1 if you have the 'seteuid' function. */
 /* #undef HAVE_SETEUID */
 
-/* Define to 1 if you have the `setlinebuf' function. */
+/* Define to 1 if you have the 'setlinebuf' function. */
 /* #undef HAVE_SETLINEBUF */
 
-/* Define to 1 if you have the `setlocale' function. */
+/* Define to 1 if you have the 'setlocale' function. */
 /*#define HAVE_SETLOCALE 1*/
 
-/* Define to 1 if you have the `setregid' function. */
+/* Define to 1 if you have the 'setregid' function. */
 /* #undef HAVE_SETREGID */
 
-/* Define to 1 if you have the `setreuid' function. */
+/* Define to 1 if you have the 'setreuid' function. */
 /* #undef HAVE_SETREUID */
 
-/* Define to 1 if you have the `setrlimit' function. */
+/* Define to 1 if you have the 'setrlimit' function. */
 /* #undef HAVE_SETRLIMIT */
 
-/* Define to 1 if you have the `setvbuf' function. */
+/* Define to 1 if you have the 'setvbuf' function. */
 #define HAVE_SETVBUF 1
 
-/* Define to 1 if you have the `sigaction' function. */
+/* Define to 1 if you have the 'sigaction' function. */
 /* #undef HAVE_SIGACTION */
 
-/* Define to 1 if you have the `sigsetmask' function. */
+/* Define to 1 if you have the 'sigsetmask' function. */
 /* #undef HAVE_SIGSETMASK */
 
-/* Define to 1 if you have the `socket' function. */
+/* Define to 1 if you have the 'socket' function. */
 /* #undef HAVE_SOCKET */
 
 /* Define to 1 if you have the <stdarg.h> header file. */
@@ -259,25 +259,25 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strcasecmp' function. */
+/* Define to 1 if you have the 'strcasecmp' function. */
 #ifdef __MINGW32__
 #define HAVE_STRCASECMP 1
 #endif
 
-/* Define to 1 if you have the `strcmpi' function. */
+/* Define to 1 if you have the 'strcmpi' function. */
 #define HAVE_STRCMPI 1
 
-/* Define to 1 if you have the `strcoll' function and it is properly defined.
+/* Define to 1 if you have the 'strcoll' function and it is properly defined.
    */
 #define HAVE_STRCOLL 1
 
-/* Define to 1 if you have the `strdup' function. */
+/* Define to 1 if you have the 'strdup' function. */
 #define HAVE_STRDUP 1
 
-/* Define to 1 if you have the `strerror' function. */
+/* Define to 1 if you have the 'strerror' function. */
 #define HAVE_STRERROR 1
 
-/* Define to 1 if you have the `stricmp' function. */
+/* Define to 1 if you have the 'stricmp' function. */
 #define HAVE_STRICMP 1
 
 /* Define to 1 if you have the <strings.h> header file. */
@@ -286,33 +286,33 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the <string.h> header file. */
 #define HAVE_STRING_H 1
 
-/* Define to 1 if you have the `strncasecmp' function. */
+/* Define to 1 if you have the 'strncasecmp' function. */
 #ifdef __MINGW32__
 #define HAVE_STRNCASECMP 1
 #endif
 
-/* Define to 1 if you have the `strncmpi' function. */
+/* Define to 1 if you have the 'strncmpi' function. */
 /* #undef HAVE_STRNCMPI */
 
-/* Define to 1 if you have the `strndup' function. */
+/* Define to 1 if you have the 'strndup' function. */
 /* #undef HAVE_STRNDUP */
 
-/* Define to 1 if you have the `strnicmp' function. */
+/* Define to 1 if you have the 'strnicmp' function. */
 #ifdef __MINGW32__
 #define HAVE_STRNICMP 1
 #endif
 
-/* Define to 1 if you have the `strsignal' function. */
+/* Define to 1 if you have the 'strsignal' function. */
 /* #undef HAVE_STRSIGNAL */
 
-/* Define to 1 if `n_un.n_name' is a member of `struct nlist'. */
+/* Define to 1 if 'n_un.n_name' is a member of 'struct nlist'. */
 /* #undef HAVE_STRUCT_NLIST_N_UN_N_NAME */
 
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.
    */
 /* #undef HAVE_SYS_DIR_H */
 
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.
    */
 /* #undef HAVE_SYS_NDIR_H */
 
@@ -341,7 +341,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the <sys/wait.h> header file. */
 /* #undef HAVE_SYS_WAIT_H */
 
-/* Define to 1 if you have the \`union wait' type in <sys/wait.h>. */
+/* Define to 1 if you have the \'union wait' type in <sys/wait.h>. */
 /* #undef HAVE_UNION_WAIT */
 
 /* Define to 1 if you have the <unistd.h> header file. */
@@ -352,26 +352,26 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the <varargs.h> header file. */
 /* #undef HAVE_VARARGS_H */
 
-/* Define to 1 if you have the `vfork' function. */
+/* Define to 1 if you have the 'vfork' function. */
 /* #undef HAVE_VFORK */
 
 /* Define to 1 if you have the <vfork.h> header file. */
 /* #undef HAVE_VFORK_H */
 
-/* Define to 1 if you have the `vprintf' function. */
+/* Define to 1 if you have the 'vprintf' function. */
 #define HAVE_VPRINTF 1
 
 
-/* Define to 1 if you have the `wait3' function. */
+/* Define to 1 if you have the 'wait3' function. */
 /* #undef HAVE_WAIT3 */
 
-/* Define to 1 if you have the `waitpid' function. */
+/* Define to 1 if you have the 'waitpid' function. */
 /* #undef HAVE_WAITPID */
 
-/* Define to 1 if `fork' works. */
+/* Define to 1 if 'fork' works. */
 /* #undef HAVE_WORKING_FORK */
 
-/* Define to 1 if `vfork' works. */
+/* Define to 1 if 'vfork' works. */
 /* #undef HAVE_WORKING_VFORK */
 
 /* Build host information. */
@@ -383,8 +383,8 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 to enable symbolic link timestamp checking. */
 /* #undef MAKE_SYMLINKS */
 
-/* Define to 1 if your `struct nlist' has an `n_un' member. Obsolete, depend
-   on `HAVE_STRUCT_NLIST_N_UN_N_NAME */
+/* Define to 1 if your 'struct nlist' has an 'n_un' member. Obsolete, depend
+   on 'HAVE_STRUCT_NLIST_N_UN_N_NAME */
 /* #undef NLIST_NAME_UNION */
 
 /* Define to 1 if struct nlist.n_name is a pointer rather than an array. */
@@ -411,7 +411,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to the character that separates directories in PATH. */
 #define PATH_SEPARATOR_CHAR ';'
 
-/* Define as the return type of signal handlers (`int' or `void'). */
+/* Define as the return type of signal handlers ('int' or 'void'). */
 #define RETSIGTYPE void
 
 /* Define to the name of the SCCS 'get' command. */
@@ -420,7 +420,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define this if the SCCS 'get' command understands the '-G<file>' option. */
 /* #undef SCCS_GET_MINUS_G */
 
-/* Define to 1 if the `setvbuf' function takes the buffering type as its
+/* Define to 1 if the 'setvbuf' function takes the buffering type as its
    second argument and the buffer pointer as the third, as on System V before
    release 3. */
 /* #undef SETVBUF_REVERSED */
@@ -433,7 +433,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 	STACK_DIRECTION = 0 => direction of growth unknown */
 /* #undef STACK_DIRECTION */
 
-/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
+/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly. */
 /* #undef STAT_MACROS_BROKEN */
 
 /* Define to 1 if you have the ANSI C header files. */
@@ -483,18 +483,18 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
    this defined. */
 /* #undef _POSIX_1_SOURCE */
 
-/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* Define to 1 if you need to in order for 'stat' and other things to work. */
 /* #undef _POSIX_SOURCE */
 
-/* Define to empty if `const' does not conform to ANSI C. */
+/* Define to empty if 'const' does not conform to ANSI C. */
 /* #undef const */
 
 #include <sys/types.h>
 
-/* Define to `int' if <sys/types.h> doesn't define. */
+/* Define to 'int' if <sys/types.h> doesn't define. */
 #define gid_t int
 
-/* Define to `int' if <sys/types.h> does not define. */
+/* Define to 'int' if <sys/types.h> does not define. */
 /* GCC 4.x reportedly defines pid_t.  */
 #ifndef _PID_T_
 #ifdef _WIN64
@@ -504,7 +504,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #endif
 #endif
 
-/* Define to `int' if <sys/types.h> doesn't define. */
+/* Define to 'int' if <sys/types.h> doesn't define. */
 #define uid_t int
 
 /* Define uintmax_t if not defined in <stdint.h> or <inttypes.h>. */
@@ -512,7 +512,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define uintmax_t unsigned long
 #endif
 
-/* Define as `fork' if `vfork' does not work. */
+/* Define as 'fork' if 'vfork' does not work. */
 /*#define vfork fork*/
 
 /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
diff --git a/configh.dos.template b/configh.dos.template
index dd3d5e4..5624bd0 100644
--- a/configh.dos.template
+++ b/configh.dos.template
@@ -25,10 +25,10 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 #if __DJGPP__ > 2 || __DJGPP_MINOR__ > 1
 
-/* Define to 1 if `sys_siglist' is declared by <signal.h> or <unistd.h>. */
+/* Define to 1 if 'sys_siglist' is declared by <signal.h> or <unistd.h>. */
 # define SYS_SIGLIST_DECLARED 1
 
-/* Define to 1 if the C library defines the variable `_sys_siglist'.  */
+/* Define to 1 if the C library defines the variable '_sys_siglist'.  */
 # define HAVE_DECL_SYS_SIGLIST 1
 
 #else
@@ -41,13 +41,13 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Use high resolution file timestamps if nonzero. */
 #define FILE_TIMESTAMP_HI_RES 0
 
-/* Define to 1 if you have `alloca', as a function or macro. */
+/* Define to 1 if you have 'alloca', as a function or macro. */
 #define HAVE_ALLOCA 1
 
 /* Define to 1 if you have the fdopen function.  */
 #define HAVE_FDOPEN 1
 
-/* Define to 1 if you have the `getgroups' function. */
+/* Define to 1 if you have the 'getgroups' function. */
 #define HAVE_GETGROUPS 1
 
 /* Define to 1 if you have the <memory.h> header file.  */
@@ -56,18 +56,18 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the mkstemp function.  */
 #define HAVE_MKSTEMP 1
 
-/* Define to 1 if you have the `mktemp' function. */
+/* Define to 1 if you have the 'mktemp' function. */
 #define HAVE_MKTEMP 1
 
-/* Define to 1 if you have the `setlinebuf' function. */
+/* Define to 1 if you have the 'setlinebuf' function. */
 #define HAVE_SETLINEBUF 1
 
-/* Define to 1 if you have the `setvbuf' function. */
+/* Define to 1 if you have the 'setvbuf' function. */
 #define HAVE_SETVBUF 1
 
 #define SCCS_GET "get"
 
-/* Define to `unsigned long' or `unsigned long long'
+/* Define to 'unsigned long' or 'unsigned long long'
    if <inttypes.h> doesn't define.  */
 #define uintmax_t unsigned long long
 
@@ -90,7 +90,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 /* Define to 1 if you have the stricmp function.  */
 #define HAVE_STRICMP 1
 
-/* Define to 1 if you have the `strncasecmp' function. */
+/* Define to 1 if you have the 'strncasecmp' function. */
 #define HAVE_STRNCASECMP 1
 
 /* Name of the package */
diff --git a/configure.in b/configure.in
index 90b55ea..774dc7a 100644
--- a/configure.in
+++ b/configure.in
@@ -243,7 +243,7 @@ AC_CACHE_CHECK([for union wait], [make_cv_union_wait],
 ])
 AS_IF([test "$make_cv_union_wait" = yes],
 [ AC_DEFINE([HAVE_UNION_WAIT], [1],
-            [Define to 1 if you have the \`union wait' type in <sys/wait.h>.])
+            [Define to 1 if you have the 'union wait' type in <sys/wait.h>.])
 ])
 
 
diff --git a/default.c b/default.c
index afaed9a..7a2fc55 100644
--- a/default.c
+++ b/default.c
@@ -32,8 +32,8 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 
 /* This is the default list of suffixes for suffix rules.
-   `.s' must come last, so that a `.o' file will be made from
-   a `.c' or `.p' or ... file rather than from a .s file.  */
+   '.s' must come last, so that a '.o' file will be made from
+   a '.c' or '.p' or ... file rather than from a .s file.  */
 
 static char default_suffixes[]
 #ifdef VMS
@@ -56,8 +56,8 @@ static struct pspec default_pattern_rules[] =
         "$(AR) $(ARFLAGS) $@ $<" },
 
     /* The X.out rules are only in BSD's default set because
-       BSD Make has no null-suffix rules, so `foo.out' and
-       `foo' are the same thing.  */
+       BSD Make has no null-suffix rules, so 'foo.out' and
+       'foo' are the same thing.  */
 #ifdef VMS
     { "%.exe", "%",
         "copy $< $@" },
@@ -293,13 +293,13 @@ static char *default_suffix_rules[] =
     "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
 
     ".w.c",
-    "$(CTANGLE) $< - $@",       /* The `-' says there is no `.ch' file.  */
+    "$(CTANGLE) $< - $@",       /* The '-' says there is no '.ch' file.  */
 
     ".web.p",
     "$(TANGLE) $<",
 
     ".w.tex",
-    "$(CWEAVE) $< - $@",        /* The `-' says there is no `.ch' file.  */
+    "$(CWEAVE) $< - $@",        /* The '-' says there is no '.ch' file.  */
 
     ".web.tex",
     "$(WEAVE) $<",
diff --git a/dep.h b/dep.h
index 2ba52a3..b790cc1 100644
--- a/dep.h
+++ b/dep.h
@@ -16,9 +16,9 @@ A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 You should have received a copy of the GNU General Public License along with
 this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Flag bits for the second argument to `read_makefile'.
-   These flags are saved in the `changed' field of each
-   `struct dep' in the chain returned by `read_all_makefiles'.  */
+/* Flag bits for the second argument to 'read_makefile'.
+   These flags are saved in the 'changed' field of each
+   'struct dep' in the chain returned by 'read_all_makefiles'.  */
 
 #define RM_NO_DEFAULT_GOAL	(1 << 0) /* Do not set default goal.  */
 #define RM_INCLUDED		(1 << 1) /* Search makefile search path.  */
@@ -27,8 +27,8 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define RM_NOFLAG		0
 
 /* Structure representing one dependency of a file.
-   Each struct file's `deps' points to a chain of these,
-   chained through the `next'. `stem' is the stem for this
+   Each struct file's 'deps' points to a chain of these,
+   chained through the 'next'. 'stem' is the stem for this
    dep line of static pattern rule or NULL.
 
    Note that the first two words of this match a struct nameseq.  */
diff --git a/dir.c b/dir.c
index 61705e5..a016e8f 100644
--- a/dir.c
+++ b/dir.c
@@ -337,7 +337,7 @@ struct directory
 
     /* The directory's contents.  This data may be shared by several
        entries in the hash table, which refer to the same directory
-       (identified uniquely by `dev' and `ino') under different names.  */
+       (identified uniquely by 'dev' and 'ino') under different names.  */
     struct directory_contents *contents;
   };
 
@@ -410,7 +410,7 @@ static int dir_contents_file_exists_p (struct directory_contents *dir,
                                        const char *filename);
 static struct directory *find_directory (const char *name);
 
-/* Find the directory named NAME and return its `struct directory'.  */
+/* Find the directory named NAME and return its 'struct directory'.  */
 
 static struct directory *
 find_directory (const char *name)
@@ -482,7 +482,7 @@ find_directory (const char *name)
       if (r < 0)
         {
 	/* Couldn't stat the directory.  Mark this by
-	   setting the `contents' member to a nil pointer.  */
+	   setting the 'contents' member to a nil pointer.  */
 	  dir->contents = 0;
 	}
       else
@@ -553,7 +553,7 @@ find_directory (const char *name)
 	      ENULLLOOP (dc->dirstream, opendir (name));
 	      if (dc->dirstream == 0)
                 /* Couldn't open the directory.  Mark this by setting the
-                   `files' member to a nil pointer.  */
+                   'files' member to a nil pointer.  */
                 dc->dirfiles.ht_vec = 0;
 	      else
 		{
@@ -805,7 +805,7 @@ file_exists_p (const char *name)
   return dir_file_exists_p (dirname, slash + 1);
 }
 
-/* Mark FILENAME as `impossible' for `file_impossible_p'.
+/* Mark FILENAME as 'impossible' for 'file_impossible_p'.
    This means an attempt has been made to search for FILENAME
    as an intermediate file, and it has failed.  */
 
@@ -1146,7 +1146,7 @@ read_dirstream (__ptr_t stream)
       struct dirfile *df = *ds->dirfile_slot++;
       if (! HASH_VACANT (df) && !df->impossible)
 	{
-	  /* The glob interface wants a `struct dirent', so mock one up.  */
+	  /* The glob interface wants a 'struct dirent', so mock one up.  */
 	  struct dirent *d;
 	  unsigned int len = df->length + 1;
           unsigned int sz = sizeof (*d) - sizeof (d->d_name) + len;
diff --git a/expand.c b/expand.c
index 43ce4df..e9c376c 100644
--- a/expand.c
+++ b/expand.c
@@ -124,7 +124,7 @@ recursively_expand_for_file (struct variable *v, struct file *file)
       if (!v->exp_count)
         /* Expanding V causes infinite recursion.  Lose.  */
         fatal (*expanding_var,
-               _("Recursive variable `%s' references itself (eventually)"),
+               _("Recursive variable '%s' references itself (eventually)"),
                v->name);
       --v->exp_count;
     }
@@ -187,7 +187,7 @@ reference_variable (char *o, const char *name, unsigned int length)
    LENGTH bytes of STRING are actually scanned.  If LENGTH is -1, scan until
    a null byte is found.
 
-   Write the results to LINE, which must point into `variable_buffer'.  If
+   Write the results to LINE, which must point into 'variable_buffer'.  If
    LINE is NULL, start at the beginning of the buffer.
    Return a pointer to LINE, or to the beginning of the buffer if LINE is
    NULL.
@@ -284,7 +284,7 @@ variable_expand_string (char *line, const char *string, long length)
 		  }
 		/* If COUNT is >= 0, there were unmatched opening parens
 		   or braces, so we go to the simple case of a variable name
-		   such as `$($(a)'.  */
+		   such as '$($(a)'.  */
 		if (count < 0)
 		  {
 		    abeg = expand_argument (beg, p); /* Expand the name.  */
@@ -413,7 +413,7 @@ variable_expand_string (char *line, const char *string, long length)
 }
 
 /* Scan LINE for variable references and expansion-function calls.
-   Build in `variable_buffer' the result of expanding the references and calls.
+   Build in 'variable_buffer' the result of expanding the references and calls.
    Return the address of the resulting string, which is null-terminated
    and is valid only until the next time this function is called.  */
 
@@ -426,7 +426,7 @@ variable_expand (const char *line)
 /* Expand an argument for an expansion function.
    The text starting at STR and ending at END is variable-expanded
    into a null-terminated string that is returned as the value.
-   This is done without clobbering `variable_buffer' or the current
+   This is done without clobbering 'variable_buffer' or the current
    variable-expansion that is in progress.  */
 
 char *
diff --git a/file.c b/file.c
index 78ef933..3f261b2 100644
--- a/file.c
+++ b/file.c
@@ -202,7 +202,7 @@ enter_file (const char *name)
 }
 
 /* Rehash FILE to NAME.  This is not as simple as resetting
-   the `hname' member, since it must be put in a new hash bucket,
+   the 'hname' member, since it must be put in a new hash bucket,
    and possibly merged with an existing file called NAME.  */
 
 void
@@ -264,18 +264,18 @@ rehash_file (struct file *from_file, const char *to_hname)
              but give a message to let the user know what's going on.  */
           if (to_file->cmds->fileinfo.filenm != 0)
             error (&from_file->cmds->fileinfo,
-                   _("Recipe was specified for file `%s' at %s:%lu,"),
+                   _("Recipe was specified for file '%s' at %s:%lu,"),
                    from_file->name, to_file->cmds->fileinfo.filenm,
                    to_file->cmds->fileinfo.lineno);
           else
             error (&from_file->cmds->fileinfo,
-                   _("Recipe for file `%s' was found by implicit rule search,"),
+                   _("Recipe for file '%s' was found by implicit rule search,"),
                    from_file->name);
           error (&from_file->cmds->fileinfo,
-                 _("but `%s' is now considered the same file as `%s'."),
+                 _("but '%s' is now considered the same file as '%s'."),
                  from_file->name, to_hname);
           error (&from_file->cmds->fileinfo,
-                 _("Recipe for `%s' will be ignored in favor of the one for `%s'."),
+                 _("Recipe for '%s' will be ignored in favor of the one for '%s'."),
                  to_hname, from_file->name);
         }
     }
@@ -295,12 +295,12 @@ rehash_file (struct file *from_file, const char *to_hname)
   merge_variable_set_lists (&to_file->variables, from_file->variables);
 
   if (to_file->double_colon && from_file->is_target && !from_file->double_colon)
-    fatal (NILF, _("can't rename single-colon `%s' to double-colon `%s'"),
+    fatal (NILF, _("can't rename single-colon '%s' to double-colon '%s'"),
            from_file->name, to_hname);
   if (!to_file->double_colon  && from_file->double_colon)
     {
       if (to_file->is_target)
-        fatal (NILF, _("can't rename double-colon `%s' to single-colon `%s'"),
+        fatal (NILF, _("can't rename double-colon '%s' to single-colon '%s'"),
                from_file->name, to_hname);
       else
         to_file->double_colon = from_file->double_colon;
@@ -327,7 +327,7 @@ rehash_file (struct file *from_file, const char *to_hname)
 }
 
 /* Rename FILE to NAME.  This is not as simple as resetting
-   the `name' member, since it must be put in a new hash bucket,
+   the 'name' member, since it must be put in a new hash bucket,
    and possibly merged with an existing file called NAME.  */
 
 void
@@ -389,7 +389,7 @@ remove_intermediates (int sig)
 	    if (!f->dontcare)
 	      {
 		if (sig)
-		  error (NILF, _("*** Deleting intermediate file `%s'"), f->name);
+		  error (NILF, _("*** Deleting intermediate file '%s'"), f->name);
 		else
 		  {
 		    if (! doneany)
@@ -637,8 +637,8 @@ reset_updating (const void *item)
   f->updating = 0;
 }
 
-/* For each dependency of each file, make the `struct dep' point
-   at the appropriate `struct file' (which may have to be created).
+/* For each dependency of each file, make the 'struct dep' point
+   at the appropriate 'struct file' (which may have to be created).
 
    Also mark the files depended on by .PRECIOUS, .PHONY, .SILENT,
    and various other special targets.  */
@@ -772,7 +772,7 @@ snap_deps (void)
 #endif
 }
 
-/* Set the `command_state' member of FILE and all its `also_make's.  */
+/* Set the 'command_state' member of FILE and all its 'also_make's.  */
 
 void
 set_command_state (struct file *file, enum cmd_state state)
@@ -951,7 +951,7 @@ print_file (const void *item)
         ? _("#  Implicit rule search has been done.")
         : _("#  Implicit rule search has not been done."));
   if (f->stem != 0)
-    printf (_("#  Implicit/static pattern stem: `%s'\n"), f->stem);
+    printf (_("#  Implicit/static pattern stem: '%s'\n"), f->stem);
   if (f->intermediate)
     puts (_("#  File is an intermediate prerequisite."));
   if (f->also_make != 0)
@@ -1001,14 +1001,14 @@ print_file (const void *item)
 	  puts (_("#  Failed to be updated."));
 	  break;
 	default:
-	  puts (_("#  Invalid value in `update_status' member!"));
+	  puts (_("#  Invalid value in 'update_status' member!"));
 	  fflush (stdout);
 	  fflush (stderr);
 	  abort ();
 	}
       break;
     default:
-      puts (_("#  Invalid value in `command_state' member!"));
+      puts (_("#  Invalid value in 'command_state' member!"));
       fflush (stdout);
       fflush (stderr);
       abort ();
diff --git a/filedef.h b/filedef.h
index f22a01a..9f170d9 100644
--- a/filedef.h
+++ b/filedef.h
@@ -19,7 +19,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* Structure that represents the info on one file
    that the makefile says how to make.
-   All of these are chained together through `next'.  */
+   All of these are chained together through 'next'.  */
 
 #include "hash.h"
 
@@ -43,7 +43,7 @@ struct file
     struct file *last;          /* Last entry for the same file name.  */
 
     /* File that this file was renamed to.  After any time that a
-       file could be renamed, call `check_renamed' (below).  */
+       file could be renamed, call 'check_renamed' (below).  */
     struct file *renamed;
 
     /* List of variable sets used for this file.  */
@@ -189,10 +189,10 @@ FILE_TIMESTAMP f_mtime (struct file *file, int search);
 			     << FILE_TIMESTAMP_LO_BITS) \
 			    + ORDINARY_MTIME_MIN + FILE_TIMESTAMPS_PER_S - 1)
 
-/* Modtime value to use for `infinitely new'.  We used to get the current time
-   from the system and use that whenever we wanted `new'.  But that causes
+/* Modtime value to use for 'infinitely new'.  We used to get the current time
+   from the system and use that whenever we wanted 'new'.  But that causes
    trouble when the machine running make and the machine holding a file have
-   different ideas about what time it is; and can also lose for `force'
+   different ideas about what time it is; and can also lose for 'force'
    targets, which need to be considered newer than anything that depends on
    them, even if said dependents' modtimes are in the future.  */
 #define NEW_MTIME INTEGER_TYPE_MAXIMUM (FILE_TIMESTAMP)
diff --git a/function.c b/function.c
index d68bc4d..bba9d61 100644
--- a/function.c
+++ b/function.c
@@ -356,7 +356,7 @@ string_glob (char *line)
   unsigned int idx;
 
   chain = PARSE_FILE_SEQ (&line, struct nameseq, '\0', NULL,
-                          /* We do not want parse_file_seq to strip `./'s.
+                          /* We do not want parse_file_seq to strip './'s.
                              That would break examples like:
                              $(patsubst ./%.c,obj/%.o,$(wildcard ./?*.c)).  */
                           PARSEFS_NOSTRIP|PARSEFS_NOCACHE|PARSEFS_EXISTS);
@@ -755,12 +755,12 @@ func_word (char *o, char **argv, const char *funcname UNUSED)
   int i;
 
   /* Check the first argument.  */
-  check_numeric (argv[0], _("non-numeric first argument to `word' function"));
+  check_numeric (argv[0], _("non-numeric first argument to 'word' function"));
   i = atoi (argv[0]);
 
   if (i == 0)
     fatal (*expanding_var,
-           _("first argument to `word' function must be greater than 0"));
+           _("first argument to 'word' function must be greater than 0"));
 
   end_p = argv[1];
   while ((p = find_next_token (&end_p, 0)) != 0)
@@ -780,14 +780,14 @@ func_wordlist (char *o, char **argv, const char *funcname UNUSED)
 
   /* Check the arguments.  */
   check_numeric (argv[0],
-		 _("non-numeric first argument to `wordlist' function"));
+		 _("non-numeric first argument to 'wordlist' function"));
   check_numeric (argv[1],
-		 _("non-numeric second argument to `wordlist' function"));
+		 _("non-numeric second argument to 'wordlist' function"));
 
   start = atoi (argv[0]);
   if (start < 1)
     fatal (*expanding_var,
-           "invalid first argument to `wordlist' function: `%d'", start);
+           "invalid first argument to 'wordlist' function: '%d'", start);
 
   count = atoi (argv[1]) - start + 1;
 
@@ -1509,7 +1509,7 @@ windows32_openpipe (int *pipedes, pid_t *pid_p, char **command_argv, char **envp
 
   /* make sure that CreateProcess() has Path it needs */
   sync_Path_environment();
-  /* `sync_Path_environment' may realloc `environ', so take note of
+  /* 'sync_Path_environment' may realloc 'environ', so take note of
      the new value.  */
   envp = environ;
 
@@ -1552,7 +1552,7 @@ FILE *
 msdos_openpipe (int* pipedes, int *pidp, char *text)
 {
   FILE *fpipe=0;
-  /* MSDOS can't fork, but it has `popen'.  */
+  /* MSDOS can't fork, but it has 'popen'.  */
   struct variable *sh = lookup_variable ("SHELL", 5);
   int e;
   extern int dos_command_running, dos_status;
@@ -1656,7 +1656,7 @@ func_shell_base (char *o, char **argv, int trim_newlines)
     }
 #endif
 
-  /* Using a target environment for `shell' loses in cases like:
+  /* Using a target environment for 'shell' loses in cases like:
      export var = $(shell echo foobie)
      because target_environment hits a loop trying to expand $(var)
      to put it in the environment.  This is even more confusing when
@@ -1740,7 +1740,7 @@ func_shell_base (char *o, char **argv, int trim_newlines)
 
       /* Close the write side of the pipe.  We test for -1, since
 	 pipedes[1] is -1 on MS-Windows, and some versions of MS
-	 libraries barf when `close' is called with -1.  */
+	 libraries barf when 'close' is called with -1.  */
       if (pipedes[1] >= 0)
 	close (pipedes[1]);
 #endif
@@ -1946,8 +1946,8 @@ func_not (char *o, char **argv, char *funcname)
 #define ROOT_LEN 1
 #endif
 
-/* Return the absolute name of file NAME which does not contain any `.',
-   `..' components nor any repeated path separators ('/').   */
+/* Return the absolute name of file NAME which does not contain any '.',
+   '..' components nor any repeated path separators ('/').   */
 
 static char *
 abspath (const char *name, char *apath)
@@ -2247,7 +2247,7 @@ expand_builtin_function (char *o, int argc, char **argv,
 {
   if (argc < (int)entry_p->minimum_args)
     fatal (*expanding_var,
-           _("insufficient number of arguments (%d) to function `%s'"),
+           _("insufficient number of arguments (%d) to function '%s'"),
            argc, entry_p->name);
 
   /* I suppose technically some function could do something with no
@@ -2259,7 +2259,7 @@ expand_builtin_function (char *o, int argc, char **argv,
 
   if (!entry_p->func_ptr)
     fatal (*expanding_var,
-           _("unimplemented on this platform: function `%s'"), entry_p->name);
+           _("unimplemented on this platform: function '%s'"), entry_p->name);
 
   return entry_p->func_ptr (o, argv, entry_p->name);
 }
@@ -2309,7 +2309,7 @@ handle_function (char **op, const char **stringp)
 
   if (count >= 0)
     fatal (*expanding_var,
-	   _("unterminated call to function `%s': missing `%c'"),
+	   _("unterminated call to function '%s': missing '%c'"),
 	   entry_p->name, closeparen);
 
   *stringp = end;
diff --git a/getloadavg.c b/getloadavg.c
index b8ca5f5..9ccc02d 100644
--- a/getloadavg.c
+++ b/getloadavg.c
@@ -86,9 +86,9 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 
 /* Exclude all the code except the test program at the end
-   if the system has its own `getloadavg' function.
+   if the system has its own 'getloadavg' function.
 
-   The declaration of `errno' is needed by the test program
+   The declaration of 'errno' is needed by the test program
    as well as the function itself, so it comes first.  */
 
 #include <errno.h>
@@ -745,7 +745,7 @@ getloadavg (double loadavg[], int nelem)
 #  define LDAV_DONE
   /* This call can return -1 for an error, but with good args
      it's not supposed to fail.  The first argument is for no
-     apparent reason of type `long int *'.  */
+     apparent reason of type 'long int *'.  */
   dg_sys_info ((long int *) &load_info,
 	       DG_SYS_INFO_LOAD_INFO_TYPE,
 	       DG_SYS_INFO_LOAD_VERSION_0);
diff --git a/getopt.c b/getopt.c
index 0345039..1eb49b8 100644
--- a/getopt.c
+++ b/getopt.c
@@ -83,7 +83,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #define _(msgid)    gettext (msgid)
 
 
-/* This version of `getopt' appears to the caller like standard Unix `getopt'
+/* This version of `getopt' appears to the caller like standard Unix 'getopt'
    but it behaves differently for the user, since it allows the user
    to intersperse the options with the other arguments.
 
@@ -658,7 +658,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
       if (ambig && !exact)
 	{
 	  if (opterr)
-	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
+	    fprintf (stderr, _("%s: option '%s' is ambiguous\n"),
 		     argv[0], argv[optind]);
 	  nextchar += strlen (nextchar);
 	  optind++;
@@ -682,12 +682,12 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 		   if (argv[optind - 1][1] == '-')
 		    /* --option */
 		    fprintf (stderr,
-		     _("%s: option `--%s' doesn't allow an argument\n"),
+		     _("%s: option '--%s' doesn't allow an argument\n"),
 		     argv[0], pfound->name);
 		   else
 		    /* +option or -option */
 		    fprintf (stderr,
-		     _("%s: option `%c%s' doesn't allow an argument\n"),
+		     _("%s: option '%c%s' doesn't allow an argument\n"),
 		     argv[0], argv[optind - 1][0], pfound->name);
 
 		  nextchar += strlen (nextchar);
@@ -704,7 +704,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 		{
 		  if (opterr)
 		    fprintf (stderr,
-			   _("%s: option `%s' requires an argument\n"),
+			   _("%s: option '%s' requires an argument\n"),
 			   argv[0], argv[optind - 1]);
 		  nextchar += strlen (nextchar);
 		  optopt = pfound->val;
@@ -733,11 +733,11 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 	    {
 	      if (argv[optind][1] == '-')
 		/* --option */
-		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
+		fprintf (stderr, _("%s: unrecognized option '--%s'\n"),
 			 argv[0], nextchar);
 	      else
 		/* +option or -option */
-		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
+		fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),
 			 argv[0], argv[optind][0], nextchar);
 	    }
 	  nextchar = (char *) "";
@@ -843,7 +843,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 	if (ambig && !exact)
 	  {
 	    if (opterr)
-	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
+	      fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),
 		       argv[0], argv[optind]);
 	    nextchar += strlen (nextchar);
 	    optind++;
@@ -862,7 +862,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 		  {
 		    if (opterr)
 		      fprintf (stderr, _("\
-%s: option `-W %s' doesn't allow an argument\n"),
+%s: option '-W %s' doesn't allow an argument\n"),
 			       argv[0], pfound->name);
 
 		    nextchar += strlen (nextchar);
@@ -877,7 +877,7 @@ _getopt_internal (int argc, char *const *argv, const char *optstring,
 		  {
 		    if (opterr)
 		      fprintf (stderr,
-			       _("%s: option `%s' requires an argument\n"),
+			       _("%s: option '%s' requires an argument\n"),
 			       argv[0], argv[optind - 1]);
 		    nextchar += strlen (nextchar);
 		    return optstring[0] == ':' ? ':' : '?';
@@ -1003,7 +1003,7 @@ main (int argc, char **argv)
 	  break;
 
 	case 'c':
-	  printf ("option c with value `%s'\n", optarg);
+	  printf ("option c with value '%s'\n", optarg);
 	  break;
 
 	case '?':
diff --git a/getopt1.c b/getopt1.c
index 7e90abc..a0639a2 100644
--- a/getopt1.c
+++ b/getopt1.c
@@ -149,11 +149,11 @@ main (int argc, char **argv)
 	  break;
 
 	case 'c':
-	  printf ("option c with value `%s'\n", optarg);
+	  printf ("option c with value '%s'\n", optarg);
 	  break;
 
 	case 'd':
-	  printf ("option d with value `%s'\n", optarg);
+	  printf ("option d with value '%s'\n", optarg);
 	  break;
 
 	case '?':
diff --git a/hash.c b/hash.c
index b91447c..e04b1bb 100644
--- a/hash.c
+++ b/hash.c
@@ -26,7 +26,7 @@ static void hash_rehash __P((struct hash_table* ht));
 static unsigned long round_up_2 __P((unsigned long rough));
 
 /* Implement double hashing with open addressing.  The table size is
-   always a power of two.  The secondary (`increment') hash function
+   always a power of two.  The secondary ('increment') hash function
    is forced to return an odd-value, in order to be relatively prime
    to the table size.  This guarantees that the increment can
    potentially hit every slot in the table during collision
@@ -61,7 +61,7 @@ hash_init (struct hash_table *ht, unsigned long size,
   ht->ht_compare = hash_cmp;
 }
 
-/* Load an array of items into `ht'.  */
+/* Load an array of items into 'ht'.  */
 
 void
 hash_load (struct hash_table *ht, void *item_table,
@@ -75,9 +75,9 @@ hash_load (struct hash_table *ht, void *item_table,
     }
 }
 
-/* Returns the address of the table slot matching `key'.  If `key' is
+/* Returns the address of the table slot matching 'key'.  If 'key' is
    not found, return the address of an empty slot suitable for
-   inserting `key'.  The caller is responsible for incrementing
+   inserting 'key'.  The caller is responsible for incrementing
    ht_fill on insertion.  */
 
 void **
diff --git a/hash.h b/hash.h
index 2c78e63..6624fe6 100644
--- a/hash.h
+++ b/hash.h
@@ -28,9 +28,9 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 #else /* Not C++ or ANSI C.  */
 # undef	__P
 # define __P(protos)	()
-/* We can get away without defining `const' here only because in this file
-   it is used only inside the prototype for `fnmatch', which is elided in
-   non-ANSI C where `const' is problematical.  */
+/* We can get away without defining 'const' here only because in this file
+   it is used only inside the prototype for 'fnmatch', which is elided in
+   non-ANSI C where 'const' is problematical.  */
 #endif /* C++ or ANSI C.  */
 
 typedef unsigned long (*hash_func_t) __P((void const *key));
diff --git a/implicit.c b/implicit.c
index c5f7481..ffe490e 100644
--- a/implicit.c
+++ b/implicit.c
@@ -37,7 +37,7 @@ static int pattern_search (struct file *file, int archive,
 int
 try_implicit_rule (struct file *file, unsigned int depth)
 {
-  DBF (DB_IMPLICIT, _("Looking for an implicit rule for `%s'.\n"));
+  DBF (DB_IMPLICIT, _("Looking for an implicit rule for '%s'.\n"));
 
   /* The order of these searches was previously reversed.  My logic now is
      that since the non-archive search uses more information in the target
@@ -53,7 +53,7 @@ try_implicit_rule (struct file *file, unsigned int depth)
   if (ar_name (file->name))
     {
       DBF (DB_IMPLICIT,
-           _("Looking for archive-member implicit rule for `%s'.\n"));
+           _("Looking for archive-member implicit rule for '%s'.\n"));
       if (pattern_search (file, 1, depth, 0))
         return 1;
     }
@@ -251,7 +251,7 @@ pattern_search (struct file *file, int archive,
   int file_vars_initialized = 0;
 
   /* Nonzero if we have matched a pattern-rule target
-     that is not just `%'.  */
+     that is not just '%'.  */
   int specific_rule_matched = 0;
 
   struct dep dep_simple;
@@ -490,12 +490,12 @@ pattern_search (struct file *file, int archive,
 
           if (stemlen > GET_PATH_MAX)
             {
-              DBS (DB_IMPLICIT, (_("Stem too long: `%.*s'.\n"),
+              DBS (DB_IMPLICIT, (_("Stem too long: '%.*s'.\n"),
                                  (int) stemlen, stem));
               continue;
             }
 
-          DBS (DB_IMPLICIT, (_("Trying pattern rule with stem `%.*s'.\n"),
+          DBS (DB_IMPLICIT, (_("Trying pattern rule with stem '%.*s'.\n"),
                              (int) stemlen, stem));
 
           strncpy (stem_str, stem, stemlen);
@@ -678,8 +678,8 @@ pattern_search (struct file *file, int archive,
                          second pass either since we know that will fail.  */
                       DBS (DB_IMPLICIT,
                            (is_rule
-                            ? _("Rejecting impossible rule prerequisite `%s'.\n")
-                            : _("Rejecting impossible implicit prerequisite `%s'.\n"),
+                            ? _("Rejecting impossible rule prerequisite '%s'.\n")
+                            : _("Rejecting impossible implicit prerequisite '%s'.\n"),
                             d->name));
                       tryrules[ri].rule = 0;
 
@@ -692,8 +692,8 @@ pattern_search (struct file *file, int archive,
 
                   DBS (DB_IMPLICIT,
                        (is_rule
-                        ? _("Trying rule prerequisite `%s'.\n")
-                        : _("Trying implicit prerequisite `%s'.\n"), d->name));
+                        ? _("Trying rule prerequisite '%s'.\n")
+                        : _("Trying implicit prerequisite '%s'.\n"), d->name));
 
                   /* If this prereq is also explicitly mentioned for FILE,
                      skip all tests below since it must be built no matter
@@ -732,7 +732,7 @@ pattern_search (struct file *file, int archive,
                     if (vname)
                       {
                         DBS (DB_IMPLICIT,
-                             (_("Found prerequisite `%s' as VPATH `%s'\n"),
+                             (_("Found prerequisite '%s' as VPATH '%s'\n"),
                               d->name, vname));
                         (pat++)->name = d->name;
                         continue;
@@ -746,7 +746,7 @@ pattern_search (struct file *file, int archive,
                   if (intermed_ok)
                     {
                       DBS (DB_IMPLICIT,
-                           (_("Looking for a rule with intermediate file `%s'.\n"),
+                           (_("Looking for a rule with intermediate file '%s'.\n"),
                             d->name));
 
                       if (int_file == 0)
@@ -795,7 +795,7 @@ pattern_search (struct file *file, int archive,
 
           file->stem = 0;
 
-          /* This rule is no longer `in use' for recursive searches.  */
+          /* This rule is no longer 'in use' for recursive searches.  */
           rule->in_use = 0;
 
           if (! failed)
@@ -897,8 +897,8 @@ pattern_search (struct file *file, int archive,
           /* If the file actually existed (was not an intermediate file), and
              the rule that found it was a terminal one, then we want to mark
              the found file so that it will not have implicit rule search done
-             for it.  If we are not entering a `struct file' for it now, we
-             indicate this with the `changed' flag.  */
+             for it.  If we are not entering a 'struct file' for it now, we
+             indicate this with the 'changed' flag.  */
           if (dep->file == 0)
             dep->changed = 1;
           else
@@ -942,7 +942,7 @@ pattern_search (struct file *file, int archive,
   }
 
   /* If this rule builds other targets, too, put the others into FILE's
-     `also_make' member.  */
+     'also_make' member.  */
 
   if (rule->num > 1)
     for (ri = 0; ri < rule->num; ++ri)
diff --git a/job.c b/job.c
index 82612c0..47fac06 100644
--- a/job.c
+++ b/job.c
@@ -154,7 +154,7 @@ int wait ();
 #  define WIFEXITED(x) (WTERMSIG (x) == 0)
 # endif
 
-#else	/* Have `union wait'.  */
+#else	/* Have 'union wait'.  */
 
 # define WAIT_T union wait
 # ifndef WTERMSIG
@@ -173,7 +173,7 @@ int wait ();
 #  define WIFEXITED(x) (WTERMSIG(x) == 0)
 # endif
 
-#endif	/* Don't have `union wait'.  */
+#endif	/* Don't have 'union wait'.  */
 
 #if !defined(HAVE_UNISTD_H) && !defined(WINDOWS32)
 int dup2 ();
@@ -225,7 +225,7 @@ struct child *children = 0;
 
 unsigned int job_slots_used = 0;
 
-/* Nonzero if the `good' standard input is in use.  */
+/* Nonzero if the 'good' standard input is in use.  */
 
 static int good_stdin_used = 0;
 
@@ -467,7 +467,7 @@ child_error (const struct file *file,
       sprintf (a, "%s:%lu", flocp->filenm, flocp->lineno);
       nm = a;
     }
-  message (0, _("%s: recipe for target `%s' failed"), nm, file->name);
+  message (0, _("%s: recipe for target '%s' failed"), nm, file->name);
 
 #ifdef VMS
   if (!(exit_code & 1))
@@ -518,7 +518,7 @@ child_handler (int sig UNUSED)
 extern int shell_function_pid, shell_function_completed;
 
 /* Reap all dead children, storing the returned status and the new command
-   state (`cs_finished') in the `file' member of the `struct child' for the
+   state ('cs_finished') in the 'file' member of the 'struct child' for the
    dead child, and removing the child from the chain.  In addition, if BLOCK
    nonzero, we block in this function until we've reaped at least one
    complete child, waiting for it to die if necessary.  If ERR is nonzero,
@@ -763,10 +763,10 @@ reap_children (int block, int err)
 #endif /* WINDOWS32 */
 	}
 
-      /* Check if this is the child of the `shell' function.  */
+      /* Check if this is the child of the 'shell' function.  */
       if (!remote && pid == shell_function_pid)
 	{
-	  /* It is.  Leave an indicator for the `shell' function.  */
+	  /* It is.  Leave an indicator for the 'shell' function.  */
 	  if (exit_sig == 0 && exit_code == 127)
 	    shell_function_completed = -1;
 	  else
@@ -1064,7 +1064,7 @@ set_child_handler_action_flags (int set_handler, int set_alarm)
    CHILD is updated to reflect the commands and ID of the child process.
 
    NOTE: On return fatal signals are blocked!  The caller is responsible
-   for calling `unblock_sigs', once the new child is safely on the chain so
+   for calling 'unblock_sigs', once the new child is safely on the chain so
    it can be cleaned up in the event of a fatal signal.  */
 
 static void
@@ -1151,9 +1151,9 @@ start_job_command (struct child *child)
       }
   }
 
-  /* If -q was given, say that updating `failed' if there was any text on the
-     command line, or `succeeded' otherwise.  The exit status of 1 tells the
-     user that -q is saying `something to do'; the exit status for a random
+  /* If -q was given, say that updating 'failed' if there was any text on the
+     command line, or 'succeeded' otherwise.  The exit status of 1 tells the
+     user that -q is saying 'something to do'; the exit status for a random
      error is 2.  */
   if (argv != 0 && question_flag && !(flags & COMMANDS_RECURSE))
     {
@@ -1200,7 +1200,7 @@ start_job_command (struct child *child)
       return;
     }
 
-  /* Print out the command.  If silent, we call `message' with null so it
+  /* Print out the command.  If silent, we call 'message' with null so it
      can log the working directory before the command's own error messages
      appear.  */
 
@@ -1286,8 +1286,8 @@ start_job_command (struct child *child)
 
 #endif /* !WINDOWS32 && !_AMIGA && !__MSDOS__ */
 
-  /* Decide whether to give this child the `good' standard input
-     (one that points to the terminal or whatever), or the `bad' one
+  /* Decide whether to give this child the 'good' standard input
+     (one that points to the terminal or whatever), or the 'bad' one
      that points to the read side of a broken pipe.  */
 
   child->good_stdin = !good_stdin_used;
@@ -1429,25 +1429,25 @@ start_job_command (struct child *child)
     block_sigs ();
     dos_status = 0;
 
-    /* We call `system' to do the job of the SHELL, since stock DOS
-       shell is too dumb.  Our `system' knows how to handle long
+    /* We call 'system' to do the job of the SHELL, since stock DOS
+       shell is too dumb.  Our 'system' knows how to handle long
        command lines even if pipes/redirection is needed; it will only
        call COMMAND.COM when its internal commands are used.  */
     if (execute_by_shell)
       {
 	char *cmdline = argv[0];
-	/* We don't have a way to pass environment to `system',
+	/* We don't have a way to pass environment to 'system',
 	   so we need to save and restore ours, sigh...  */
 	char **parent_environ = environ;
 
 	environ = child->environment;
 
-	/* If we have a *real* shell, tell `system' to call
+	/* If we have a *real* shell, tell 'system' to call
 	   it to do everything for us.  */
 	if (unixy_shell)
 	  {
 	    /* A *real* shell on MSDOS may not support long
-	       command lines the DJGPP way, so we must use `system'.  */
+	       command lines the DJGPP way, so we must use 'system'.  */
 	    cmdline = argv[2];	/* get past "shell -c" */
 	  }
 
@@ -1547,7 +1547,7 @@ start_job_command (struct child *child)
 
 /* Try to start a child running.
    Returns nonzero if the child was started (and maybe finished), or zero if
-   the load was too high and the child was put on the `waiting_jobs' chain.  */
+   the load was too high and the child was put on the 'waiting_jobs' chain.  */
 
 static int
 start_waiting_job (struct child *c)
@@ -1611,7 +1611,7 @@ start_waiting_job (struct child *c)
   return 1;
 }
 
-/* Create a `struct child' for FILE and start its commands running.  */
+/* Create a 'struct child' for FILE and start its commands running.  */
 
 void
 new_job (struct file *file)
@@ -1734,7 +1734,7 @@ new_job (struct file *file)
     }
 
   /* Start the command sequence, record it in a new
-     `struct child', and add that to the chain.  */
+     'struct child', and add that to the chain.  */
 
   c = xcalloc (sizeof (struct child));
   c->file = file;
@@ -1893,9 +1893,9 @@ new_job (struct file *file)
         }
 
       if (newer[0] == '\0')
-        message (0, _("%s: target `%s' does not exist"), nm, c->file->name);
+        message (0, _("%s: target '%s' does not exist"), nm, c->file->name);
       else
-        message (0, _("%s: update target `%s' due to: %s"), nm,
+        message (0, _("%s: update target '%s' due to: %s"), nm,
                  c->file->name, newer);
 
       free (newer);
@@ -1908,7 +1908,7 @@ new_job (struct file *file)
 
   if (job_slots == 1 || not_parallel)
     /* Since there is only one job slot, make things run linearly.
-       Wait for the child to die, setting the state to `cs_finished'.  */
+       Wait for the child to die, setting the state to 'cs_finished'.  */
     while (file->command_state == cs_running)
       reap_children (1, 0);
 
@@ -2368,7 +2368,7 @@ void clean_tmp (void)
 #ifndef VMS
 /* Figure out the argument list necessary to run LINE as a command.  Try to
    avoid using a shell.  This routine handles only ' quoting, and " quoting
-   when no backslash, $ or ` characters are seen in the quotes.  Starting
+   when no backslash, $ or ' characters are seen in the quotes.  Starting
    quotes may be escaped with a backslash.  If any of the characters in
    sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
    is the first word of a line, the shell is used.
@@ -2391,22 +2391,22 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 {
 #ifdef __MSDOS__
   /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
-     We call `system' for anything that requires ``slow'' processing,
+     We call 'system' for anything that requires ''slow'' processing,
      because DOS shells are too dumb.  When $SHELL points to a real
-     (unix-style) shell, `system' just calls it to do everything.  When
-     $SHELL points to a DOS shell, `system' does most of the work
+     (unix-style) shell, 'system' just calls it to do everything.  When
+     $SHELL points to a DOS shell, 'system' does most of the work
      internally, calling the shell only for its internal commands.
      However, it looks on the $PATH first, so you can e.g. have an
-     external command named `mkdir'.
+     external command named 'mkdir'.
 
-     Since we call `system', certain characters and commands below are
+     Since we call 'system', certain characters and commands below are
      actually not specific to COMMAND.COM, but to the DJGPP implementation
-     of `system'.  In particular:
+     of 'system'.  In particular:
 
        The shell wildcard characters are in DOS_CHARS because they will
-       not be expanded if we call the child via `spawnXX'.
+       not be expanded if we call the child via 'spawnXX'.
 
-       The `;' is in DOS_CHARS, because our `system' knows how to run
+       The ';' is in DOS_CHARS, because our 'system' knows how to run
        multiple commands on a single line.
 
        DOS_CHARS also include characters special to 4DOS/NDOS, so we
@@ -2562,7 +2562,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     {
       extern int _is_unixy_shell (const char *_path);
 
-      DB (DB_BASIC, (_("$SHELL changed (was `%s', now `%s')\n"),
+      DB (DB_BASIC, (_("$SHELL changed (was '%s', now '%s')\n"),
                      default_shell, shell));
       unixy_shell = _is_unixy_shell (shell);
       /* we must allocate a copy of shell: construct_command_argv() will free
@@ -2671,7 +2671,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 	goto slow;
 #ifdef  __MSDOS__
       else if (*p == '.' && p[1] == '.' && p[2] == '.' && p[3] != '.')
-	/* `...' is a wildcard in DJGPP.  */
+	/* '...' is a wildcard in DJGPP.  */
 	goto slow;
 #endif
       else
@@ -2760,10 +2760,10 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 	    last_argument_was_empty = 0;
 
 	    /* Update SEEN_NONEQUALS, which tells us if every word
-	       heretofore has contained an `='.  */
+	       heretofore has contained an '='.  */
 	    seen_nonequals |= ! word_has_equals;
 	    if (word_has_equals && ! seen_nonequals)
-	      /* An `=' in a word before the first
+	      /* An '=' in a word before the first
 		 word without one is magical.  */
 	      goto slow;
 	    word_has_equals = 0; /* Prepare for the next word.  */
@@ -2838,7 +2838,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
     }
 
 #ifdef __MSDOS__
-  execute_by_shell = 1;	/* actually, call `system' if shell isn't unixy */
+  execute_by_shell = 1;	/* actually, call 'system' if shell isn't unixy */
 #endif
 
 #ifdef _AMIGA
@@ -3045,7 +3045,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 #ifdef __MSDOS__
         else if (unixy_shell && strneq (p, "...", 3))
           {
-            /* The case of `...' wildcard again.  */
+            /* The case of '...' wildcard again.  */
             strcpy (ap, "\\.\\.\\");
             ap += 5;
             p  += 2;
@@ -3205,7 +3205,7 @@ construct_command_argv_internal (char *line, char **restp, char *shell,
 
 /* Figure out the argument list necessary to run LINE as a command.  Try to
    avoid using a shell.  This routine handles only ' quoting, and " quoting
-   when no backslash, $ or ` characters are seen in the quotes.  Starting
+   when no backslash, $ or ' characters are seen in the quotes.  Starting
    quotes may be escaped with a backslash.  If any of the characters in
    sh_chars[] is seen, or any of the builtin commands listed in sh_cmds[]
    is the first word of a line, the shell is used.
diff --git a/job.h b/job.h
index 0863345..844871e 100644
--- a/job.h
+++ b/job.h
@@ -59,7 +59,7 @@ struct child
     char *sh_batch_file;        /* Script file for shell commands */
     unsigned int remote:1;	/* Nonzero if executing remotely.  */
 
-    unsigned int noerror:1;	/* Nonzero if commands contained a `-'.  */
+    unsigned int noerror:1;	/* Nonzero if commands contained a '-'.  */
 
     unsigned int good_stdin:1;	/* Nonzero if this child has a good stdin.  */
     unsigned int deleted:1;	/* Nonzero if targets have been deleted.  */
diff --git a/main.c b/main.c
index 5a3bc22..ce10ff0 100644
--- a/main.c
+++ b/main.c
@@ -489,7 +489,7 @@ struct variable * default_goal_var;
 
 struct file *default_file;
 
-/* Nonzero if we have seen the magic `.POSIX' target.
+/* Nonzero if we have seen the magic '.POSIX' target.
    This turns on pedantic compliance with POSIX.2.  */
 
 int posix_pedantic;
@@ -505,7 +505,7 @@ int second_expansion;
 
 int one_shell;
 
-/* Nonzero if we have seen the `.NOTPARALLEL' target.
+/* Nonzero if we have seen the '.NOTPARALLEL' target.
    This turns off parallel builds for this invocation of make.  */
 
 int not_parallel;
@@ -650,7 +650,7 @@ decode_debug_flags (void)
               db_level |= DB_BASIC | DB_VERBOSE;
               break;
             default:
-              fatal (NILF, _("unknown debug level specification `%s'"), p);
+              fatal (NILF, _("unknown debug level specification '%s'"), p);
             }
 
           while (*(++p) != '\0')
@@ -962,7 +962,7 @@ main (int argc, char **argv, char **envp)
   reading_file = 0;
 
 #if defined (__MSDOS__) && !defined (_POSIX_SOURCE)
-  /* Request the most powerful version of `system', to
+  /* Request the most powerful version of 'system', to
      make up for the dumb default shell.  */
   __system_flags = (__system_redirect
 		    | __system_use_shell
@@ -1198,7 +1198,7 @@ main (int argc, char **argv, char **envp)
                environment.  We used to rely on target_environment's
                v_default code to do this.  But that does not work for the
                case where an environment variable is redefined in a makefile
-               with `override'; it should then still be exported, because it
+               with 'override'; it should then still be exported, because it
                was originally in the environment.  */
             v->export = v_export;
 
@@ -1294,7 +1294,7 @@ main (int argc, char **argv, char **envp)
     {
       print_version ();
 
-      /* `make --version' is supposed to just print the version and exit.  */
+      /* 'make --version' is supposed to just print the version and exit.  */
       if (print_version_flag)
         die (0);
     }
@@ -1575,7 +1575,7 @@ main (int argc, char **argv, char **envp)
 #ifndef __EMX__ /* Don't use a SIGCHLD handler for OS/2 */
 #if defined(MAKE_JOBSERVER) || !defined(HAVE_WAIT_NOHANG)
   /* Set up to handle children dying.  This must be done before
-     reading in the makefiles so that `shell' function calls will work.
+     reading in the makefiles so that 'shell' function calls will work.
 
      If we don't have a hanging wait we have to fall back to old, broken
      functionality here and rely on the signal handler and counting
@@ -1734,14 +1734,14 @@ main (int argc, char **argv, char **envp)
       if (! open_jobserver_semaphore(cp))
         {
           DWORD err = GetLastError();
-          fatal (NILF, _("internal error: unable to open jobserver semaphore `%s': (Error %ld: %s)"), 
+          fatal (NILF, _("internal error: unable to open jobserver semaphore '%s': (Error %ld: %s)"), 
                  cp, err, map_windows32_error_to_string(err));
         }
       DB (DB_JOBS, (_("Jobserver client (semaphore %s)\n"), cp));
 #else
       if (sscanf (cp, "%d,%d", &job_fds[0], &job_fds[1]) != 2)
         fatal (NILF,
-               _("internal error: invalid --jobserver-fds string `%s'"), cp);
+               _("internal error: invalid --jobserver-fds string '%s'"), cp);
 
       DB (DB_JOBS,
           (_("Jobserver client (fds %d,%d)\n"), job_fds[0], job_fds[1]));
@@ -1768,7 +1768,7 @@ main (int argc, char **argv, char **envp)
             pfatal_with_name (_("dup jobserver"));
 
           error (NILF,
-                 _("warning: jobserver unavailable: using -j1.  Add `+' to parent make rule."));
+                 _("warning: jobserver unavailable: using -j1.  Add '+' to parent make rule."));
           job_slots = 1;
         }
 #endif
@@ -1871,7 +1871,7 @@ main (int argc, char **argv, char **envp)
 
   define_makeflags (1, 0);
 
-  /* Make each `struct dep' point at the `struct file' for the file
+  /* Make each 'struct dep' point at the 'struct file' for the file
      depended on.  Also do magic for special targets.  */
 
   snap_deps ();
@@ -1967,7 +1967,7 @@ main (int argc, char **argv, char **envp)
 			 you write your makefiles.)  */
 
 		      DB (DB_VERBOSE,
-                          (_("Makefile `%s' might loop; not remaking it.\n"),
+                          (_("Makefile '%s' might loop; not remaking it.\n"),
                            f->name));
 
 		      if (last == 0)
@@ -1995,7 +1995,7 @@ main (int argc, char **argv, char **envp)
 	  }
       }
 
-      /* Set up `MAKEFLAGS' specially while remaking makefiles.  */
+      /* Set up 'MAKEFLAGS' specially while remaking makefiles.  */
       define_makeflags (1, 1);
 
       rebuilding_makefiles = 1;
@@ -2046,7 +2046,7 @@ main (int argc, char **argv, char **envp)
                         FILE_TIMESTAMP mtime;
                         /* The update failed and this makefile was not
                            from the MAKEFILES variable, so we care.  */
-                        error (NILF, _("Failed to remake makefile `%s'."),
+                        error (NILF, _("Failed to remake makefile '%s'."),
                                d->file->name);
                         mtime = file_mtime_no_search (d->file);
                         any_remade |= (mtime != NONEXISTENT_MTIME
@@ -2063,12 +2063,12 @@ main (int argc, char **argv, char **envp)
                         /* An included makefile.  We don't need
                            to die, but we do want to complain.  */
                         error (NILF,
-                               _("Included makefile `%s' was not found."),
+                               _("Included makefile '%s' was not found."),
                                dep_name (d));
                       else
                         {
                           /* A normal makefile.  We must die later.  */
-                          error (NILF, _("Makefile `%s' was not found"),
+                          error (NILF, _("Makefile '%s' was not found"),
                                  dep_name (d));
                           any_failed = 1;
                         }
@@ -2250,7 +2250,7 @@ main (int argc, char **argv, char **envp)
         free (makefile_mtimes);
     }
 
-  /* Set up `MAKEFLAGS' again for the normal targets.  */
+  /* Set up 'MAKEFLAGS' again for the normal targets.  */
   define_makeflags (1, 0);
 
   /* Set always_make_flag if -B was given.  */
@@ -2443,7 +2443,7 @@ handle_non_switch_argument (char *arg, int env)
   /* Non-option argument.  It might be a variable definition.  */
   struct variable *v;
   if (arg[0] == '-' && arg[1] == '\0')
-    /* Ignore plain `-' for compatibility.  */
+    /* Ignore plain '-' for compatibility.  */
     return;
   v = try_variable_definition (0, arg, o_command, 0);
   if (v != 0)
@@ -2617,7 +2617,7 @@ decode_switches (int argc, char **argv, int env)
                       else
                         op = cs->long_name;
 
-                      error (NILF, _("the `%s%s' option requires a non-empty string argument"),
+                      error (NILF, _("the '%s%s' option requires a non-empty string argument"),
                              short_option (cs->c) ? "-" : "--", op);
                       bad = 1;
                     }
@@ -2672,7 +2672,7 @@ decode_switches (int argc, char **argv, int env)
 
 		      if (i < 1 || cp[0] != '\0')
 			{
-                          error (NILF, _("the `-%c' option requires a positive integral argument"),
+                          error (NILF, _("the '-%c' option requires a positive integral argument"),
                                  cs->c);
 			  bad = 1;
 			}
@@ -2812,7 +2812,7 @@ quote_for_env (char *out, const char *in)
 
 /* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
    command switches.  Include options with args if ALL is nonzero.
-   Don't include options with the `no_makefile' flag set if MAKEFILE.  */
+   Don't include options with the 'no_makefile' flag set if MAKEFILE.  */
 
 static const char *
 define_makeflags (int all, int makefile)
@@ -2826,7 +2826,7 @@ define_makeflags (int all, int makefile)
   unsigned int words;
   struct variable *v;
 
-  /* We will construct a linked list of `struct flag's describing
+  /* We will construct a linked list of 'struct flag's describing
      all the flags which need to go in MAKEFLAGS.  Then, once we
      know how many there are and their lengths, we can put them all
      together in a string.  */
@@ -3084,7 +3084,7 @@ define_makeflags (int all, int makefile)
   if (! all)
     /* The first time we are called, set MAKEFLAGS to always be exported.
        We should not do this again on the second call, because that is
-       after reading makefiles which might have done `unexport MAKEFLAGS'. */
+       after reading makefiles which might have done 'unexport MAKEFLAGS'. */
     v->export = v_export;
 
   return v->value;
@@ -3313,10 +3313,10 @@ log_working_directory (int entering)
         printf (_("%s: Leaving an unknown directory\n"), program);
     else
       if (entering)
-        printf (_("%s: Entering directory `%s'\n"),
+        printf (_("%s: Entering directory '%s'\n"),
                 program, starting_directory);
       else
-        printf (_("%s: Leaving directory `%s'\n"),
+        printf (_("%s: Leaving directory '%s'\n"),
                 program, starting_directory);
   else
     if (starting_directory == 0)
@@ -3328,10 +3328,10 @@ log_working_directory (int entering)
                 program, makelevel);
     else
       if (entering)
-        printf (_("%s[%u]: Entering directory `%s'\n"),
+        printf (_("%s[%u]: Entering directory '%s'\n"),
                 program, makelevel, starting_directory);
       else
-        printf (_("%s[%u]: Leaving directory `%s'\n"),
+        printf (_("%s[%u]: Leaving directory '%s'\n"),
                 program, makelevel, starting_directory);
 
   /* Flush stdout to be sure this comes before any stderr output.  */
diff --git a/maintMakefile b/maintMakefile
index 14daa98..f817e82 100644
--- a/maintMakefile
+++ b/maintMakefile
@@ -201,7 +201,7 @@ update: po-update scm-update
 ## Sanity checks.  ##
 ## --------------- ##
 
-# Checks that don't require cvs.  Run `changelog-check' last as
+# Checks that don't require cvs.  Run 'changelog-check' last as
 # previous test may reveal problems requiring new ChangeLog entries.
 local-check: po-check changelog-check
 
diff --git a/make.1 b/make.1
index 5dade8f..e25ee8c 100644
--- a/make.1
+++ b/make.1
@@ -1,4 +1,4 @@
-.TH MAKE 1 "27 December 2010" "GNU" "User Commands"
+.TH MAKE 1 "03 March 2012" "GNU" "User Commands"
 .SH NAME
 make \- GNU make utility to maintain groups of programs
 .SH SYNOPSIS
@@ -82,7 +82,7 @@ and will not be understood by other versions of
 .BR make .
 If
 .I makefile
-is `\-', the standard input is read.
+is '\-', the standard input is read.
 .LP
 .B make
 updates a target if it depends on prerequisite files
@@ -332,14 +332,14 @@ programs are properly installed at your site, the command
 .PP
 should give you access to the complete manual.
 .SH BUGS
-See the chapter `Problems and Bugs' in
+See the chapter ``Problems and Bugs'' in
 .IR "The GNU Make Manual" .
 .SH AUTHOR
 This manual page contributed by Dennis Morse of Stanford University.
 Further updates contributed by Mike Frysinger.  It has been reworked by Roland
 McGrath.  Maintained by Paul Smith.
 .SH "COPYRIGHT"
-Copyright \(co 1992, 1993, 1996, 1999, 2007, 2010 Free Software Foundation, Inc.
+Copyright \(co 1992-1993, 1996-2012 Free Software Foundation, Inc.
 This file is part of
 .IR "GNU make" .
 .LP
diff --git a/make.h b/make.h
index 2fe492b..f890363 100644
--- a/make.h
+++ b/make.h
@@ -68,7 +68,7 @@ char *alloca ();
 #include <ctype.h>
 
 #ifdef HAVE_SYS_TIMEB_H
-/* SCO 3.2 "devsys 4.2" has a prototype for `ftime' in <time.h> that bombs
+/* SCO 3.2 "devsys 4.2" has a prototype for 'ftime' in <time.h> that bombs
    unless <sys/timeb.h> has been included first.  */
 # include <sys/timeb.h>
 #endif
@@ -96,7 +96,7 @@ extern int errno;
 #ifdef  HAVE_UNISTD_H
 # include <unistd.h>
 /* Ultrix's unistd.h always defines _POSIX_VERSION, but you only get
-   POSIX.1 behavior with `cc -YPOSIX', which predefines POSIX itself!  */
+   POSIX.1 behavior with 'cc -YPOSIX', which predefines POSIX itself!  */
 # if defined (_POSIX_VERSION) && !defined (ultrix) && !defined (VMS)
 #  define POSIX 1
 # endif
@@ -201,7 +201,7 @@ unsigned int get_path_max (void);
 # if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
 #  define __attribute__(x)
 # endif
-/* The __-protected variants of `format' and `printf' attributes
+/* The __-protected variants of 'format' and 'printf' attributes
    are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
 # if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
 #  define __format__ format
@@ -275,7 +275,7 @@ char *strsignal (int signum);
    - It's typically faster.
    POSIX 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
    only '0' through '9' are digits.  Prefer ISDIGIT to isdigit() unless
-   it's important to use the locale's definition of `digit' even when the
+   it's important to use the locale's definition of 'digit' even when the
    host does not conform to POSIX.  */
 #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
 
diff --git a/makefile.vms b/makefile.vms
index 0b88061..253a74b 100644
--- a/makefile.vms
+++ b/makefile.vms
@@ -82,7 +82,7 @@ extras = ,signame.obj,remote-stub.obj,vmsfunctions.obj,vmsify.obj
 # as an alternative:
 glob = ,[.glob]glob.obj,[.glob]fnmatch.obj
 getopt = ,getopt.obj,getopt1.obj
-# Directory to install `make' in.
+# Directory to install 'make' in.
 bindir = []
 # Directory to install the man page in.
 mandir = []
diff --git a/misc.c b/misc.c
index 0ea56bb..4e87b35 100644
--- a/misc.c
+++ b/misc.c
@@ -535,7 +535,7 @@ find_next_token (const char **ptr, unsigned int *lengthptr)
 }
 
 
-/* Copy a chain of `struct dep'.  For 2nd expansion deps, dup the name.  */
+/* Copy a chain of 'struct dep'.  For 2nd expansion deps, dup the name.  */
 
 struct dep *
 copy_dep_chain (const struct dep *d)
@@ -941,7 +941,7 @@ get_path_max (void)
    the failure.  That's what the ferror test is checking below.
 
    It's important to detect such failures and exit nonzero because many
-   tools (most notably `make' and other build-management systems) depend
+   tools (most notably 'make' and other build-management systems) depend
    on being able to detect failure in other tools via their exit status.  */
 
 void
diff --git a/read.c b/read.c
index 4378d1b..5145dff 100644
--- a/read.c
+++ b/read.c
@@ -76,12 +76,12 @@ enum make_word_type
   };
 
 
-/* A `struct conditionals' contains the information describing
+/* A 'struct conditionals' contains the information describing
    all the active conditionals in a makefile.
 
-   The global variable `conditionals' contains the conditionals
+   The global variable 'conditionals' contains the conditionals
    information for the current makefile.  It is initialized from
-   the static structure `toplevel_conditionals' and is later changed
+   the static structure 'toplevel_conditionals' and is later changed
    to new structures for included makefiles.  */
 
 struct conditionals
@@ -91,7 +91,7 @@ struct conditionals
     char *ignoring;		/* Are we ignoring or interpreting?
                                    0=interpreting, 1=not yet interpreted,
                                    2=already interpreted */
-    char *seen_else;		/* Have we already seen an `else'?  */
+    char *seen_else;		/* Have we already seen an 'else'?  */
   };
 
 static struct conditionals toplevel_conditionals;
@@ -260,7 +260,7 @@ read_all_makefiles (const char **makefiles)
       else
 	{
 	  /* No default makefile was found.  Add the default makefiles to the
-	     `read_makefiles' chain so they will be updated if possible.  */
+	     'read_makefiles' chain so they will be updated if possible.  */
 	  struct dep *tail = read_makefiles;
 	  /* Add them to the tail, after any MAKEFILES variable makefiles.  */
 	  while (tail != 0 && tail->next != 0)
@@ -329,7 +329,7 @@ eval_makefile (const char *filename, int flags)
 
   if (ISDB (DB_VERBOSE))
     {
-      printf (_("Reading makefile `%s'"), filename);
+      printf (_("Reading makefile '%s'"), filename);
       if (flags & RM_NO_DEFAULT_GOAL)
 	printf (_(" (no default goal)"));
       if (flags & RM_INCLUDED)
@@ -343,7 +343,7 @@ eval_makefile (const char *filename, int flags)
 
   /* First, get a stream to read.  */
 
-  /* Expand ~ in FILENAME unless it came from `include',
+  /* Expand ~ in FILENAME unless it came from 'include',
      in which case it was already done.  */
   if (!(flags & RM_NO_TILDE) && filename[0] == '~')
     {
@@ -357,7 +357,7 @@ eval_makefile (const char *filename, int flags)
   makefile_errno = errno;
 
   /* If the makefile wasn't found and it's either a makefile from
-     the `MAKEFILES' variable or an included makefile,
+     the 'MAKEFILES' variable or an included makefile,
      search the included makefile search path for this makefile.  */
   if (ebuf.fp == 0 && (flags & RM_INCLUDED) && *filename != '/')
     {
@@ -819,7 +819,7 @@ eval (struct ebuffer *ebuf, int set_default)
       /* Handle include and variants.  */
       if (word1eq ("include") || word1eq ("-include") || word1eq ("sinclude"))
 	{
-	  /* We have found an `include' line specifying a nested
+	  /* We have found an 'include' line specifying a nested
 	     makefile to be read at this point.  */
 	  struct conditionals *save;
           struct conditionals new_conditionals;
@@ -884,11 +884,11 @@ eval (struct ebuffer *ebuf, int set_default)
       /* This line describes some target files.  This is complicated by
          the existence of target-specific variables, because we can't
          expand the entire line until we know if we have one or not.  So
-         we expand the line word by word until we find the first `:',
+         we expand the line word by word until we find the first ':',
          then check to see if it's a target-specific variable.
 
-         In this algorithm, `lb_next' will point to the beginning of the
-         unexpanded parts of the input buffer, while `p2' points to the
+         In this algorithm, 'lb_next' will point to the beginning of the
+         unexpanded parts of the input buffer, while 'p2' points to the
          parts of the expanded buffer we haven't searched yet. */
 
       {
@@ -1103,7 +1103,7 @@ eval (struct ebuffer *ebuf, int set_default)
               }
           }
 
-        /* Is this a static pattern rule: `target: %targ: %dep; ...'?  */
+        /* Is this a static pattern rule: 'target: %targ: %dep; ...'?  */
         p = strchr (p2, ':');
         while (p != 0 && p[-1] == '\\')
           {
@@ -1161,7 +1161,7 @@ eval (struct ebuffer *ebuf, int set_default)
             pattern_percent = find_percent_cached (&target->name);
             pattern = target->name;
             if (pattern_percent == 0)
-              fatal (fstart, _("target pattern contains no `%%'"));
+              fatal (fstart, _("target pattern contains no '%%'"));
             free_ns (target);
           }
         else
@@ -1227,7 +1227,7 @@ eval (struct ebuffer *ebuf, int set_default)
                 if (strchr (name, '%') != 0)
                   break;
 
-                /* See if this target's name does not start with a `.',
+                /* See if this target's name does not start with a '.',
                    unless it contains a slash.  */
                 if (*name == '.' && strchr (name, '/') == 0
 #ifdef HAVE_DOS_PATHS
@@ -1285,7 +1285,7 @@ eval (struct ebuffer *ebuf, int set_default)
 #undef	word1eq
 
   if (conditionals->if_cmds)
-    fatal (fstart, _("missing `endif'"));
+    fatal (fstart, _("missing 'endif'"));
 
   /* At eof, record the last rule.  */
   record_waiting_files ();
@@ -1311,7 +1311,7 @@ remove_comments (char *line)
     *comment = '\0';
 }
 
-/* Execute a `undefine' directive.
+/* Execute a 'undefine' directive.
    The undefine line has already been read, and NAME is the name of
    the variable to be undefined. */
 
@@ -1334,7 +1334,7 @@ do_undefine (char *name, enum variable_origin origin, struct ebuffer *ebuf)
   free (var);
 }
 
-/* Execute a `define' directive.
+/* Execute a 'define' directive.
    The first line has already been read, and NAME is the name of
    the variable to be defined.  The following lines remain to be read.  */
 
@@ -1359,7 +1359,7 @@ do_define (char *name, enum variable_origin origin, struct ebuffer *ebuf)
   else
     {
       if (var.value[0] != '\0')
-        error (&defstart, _("extraneous text after `define' directive"));
+        error (&defstart, _("extraneous text after 'define' directive"));
 
       /* Chop the string before the assignment token to get the name.  */
       var.name[var.length] = '\0';
@@ -1384,7 +1384,7 @@ do_define (char *name, enum variable_origin origin, struct ebuffer *ebuf)
 
       /* If there is nothing left to be eval'd, there's no 'endef'!!  */
       if (nlines < 0)
-        fatal (&defstart, _("missing `endef', unterminated `define'"));
+        fatal (&defstart, _("missing 'endef', unterminated 'define'"));
 
       ebuf->floc.lineno += nlines;
       line = ebuf->buffer;
@@ -1412,7 +1412,7 @@ do_define (char *name, enum variable_origin origin, struct ebuffer *ebuf)
               remove_comments (p);
               if (*(next_token (p)) != '\0')
                 error (&ebuf->floc,
-                       _("extraneous text after `endef' directive"));
+                       _("extraneous text after 'endef' directive"));
 
               if (--nlevels == 0)
                 break;
@@ -1483,7 +1483,7 @@ conditional_line (char *line, int len, const struct floc *flocp)
   /* Found one: skip past it and any whitespace after it.  */
   line = next_token (line + len);
 
-#define EXTRANEOUS() error (flocp, _("Extraneous text after `%s' directive"), cmdname)
+#define EXTRANEOUS() error (flocp, _("Extraneous text after '%s' directive"), cmdname)
 
   /* An 'endif' cannot contain extra text, and reduces the if-depth by 1  */
   if (cmdtype == c_endif)
@@ -1492,7 +1492,7 @@ conditional_line (char *line, int len, const struct floc *flocp)
 	EXTRANEOUS ();
 
       if (!conditionals->if_cmds)
-	fatal (flocp, _("extraneous `%s'"), cmdname);
+	fatal (flocp, _("extraneous '%s'"), cmdname);
 
       --conditionals->if_cmds;
 
@@ -1506,12 +1506,12 @@ conditional_line (char *line, int len, const struct floc *flocp)
       const char *p;
 
       if (!conditionals->if_cmds)
-	fatal (flocp, _("extraneous `%s'"), cmdname);
+	fatal (flocp, _("extraneous '%s'"), cmdname);
 
       o = conditionals->if_cmds - 1;
 
       if (conditionals->seen_else[o])
-        fatal (flocp, _("only one `else' per conditional"));
+        fatal (flocp, _("only one 'else' per conditional"));
 
       /* Change the state of ignorance.  */
       switch (conditionals->ignoring[o])
@@ -1574,7 +1574,7 @@ conditional_line (char *line, int len, const struct floc *flocp)
                                           conditionals->allocated);
     }
 
-  /* Record that we have seen an `if...' but no `else' so far.  */
+  /* Record that we have seen an 'if...' but no 'else' so far.  */
   conditionals->seen_else[o] = 0;
 
   /* Search through the stack to see if we're already ignoring.  */
@@ -1825,9 +1825,9 @@ record_target_var (struct nameseq *filenames, char *defn,
    with dependencies DEPS, commands to execute described
    by COMMANDS and COMMANDS_IDX, coming from FILENAME:COMMANDS_STARTED.
    TWO_COLON is nonzero if a double colon was used.
-   If not nil, PATTERN is the `%' pattern to make this
+   If not nil, PATTERN is the '%' pattern to make this
    a static pattern rule, and PATTERN_PERCENT is a pointer
-   to the `%' within it.
+   to the '%' within it.
 
    The links of FILENAMES are freed, and so are any names in it
    that are not incorporated into other data structures.  */
@@ -1968,10 +1968,10 @@ record_files (struct nameseq *filenames, const char *pattern,
 #endif
 
       /* If this is a static pattern rule:
-         `targets: target%pattern: prereq%pattern; recipe',
+         'targets: target%pattern: prereq%pattern; recipe',
          make sure the pattern matches this target name.  */
       if (pattern && !pattern_matches (pattern, pattern_percent, name))
-        error (flocp, _("target `%s' doesn't match the target pattern"), name);
+        error (flocp, _("target '%s' doesn't match the target pattern"), name);
       else if (deps)
         /* If there are multiple targets, copy the chain DEPS for all but the
            last one.  It is not safe for the same deps to go in more than one
@@ -1986,13 +1986,13 @@ record_files (struct nameseq *filenames, const char *pattern,
 	  f = enter_file (strcache_add (name));
 	  if (f->double_colon)
 	    fatal (flocp,
-                   _("target file `%s' has both : and :: entries"), f->name);
+                   _("target file '%s' has both : and :: entries"), f->name);
 
 	  /* If CMDS == F->CMDS, this target was listed in this rule
 	     more than once.  Just give a warning since this is harmless.  */
 	  if (cmds != 0 && cmds == f->cmds)
 	    error (flocp,
-                   _("target `%s' given more than once in the same rule."),
+                   _("target '%s' given more than once in the same rule."),
                    f->name);
 
 	  /* Check for two single-colon entries both with commands.
@@ -2001,10 +2001,10 @@ record_files (struct nameseq *filenames, const char *pattern,
 	  else if (cmds != 0 && f->cmds != 0 && f->is_target)
 	    {
 	      error (&cmds->fileinfo,
-                     _("warning: overriding recipe for target `%s'"),
+                     _("warning: overriding recipe for target '%s'"),
                      f->name);
 	      error (&f->cmds->fileinfo,
-                     _("warning: ignoring old recipe for target `%s'"),
+                     _("warning: ignoring old recipe for target '%s'"),
                      f->name);
 	    }
 
@@ -2031,7 +2031,7 @@ record_files (struct nameseq *filenames, const char *pattern,
 	     on default suffix rules or makefiles.  */
 	  if (f != 0 && f->is_target && !f->double_colon)
 	    fatal (flocp,
-                   _("target file `%s' has both : and :: entries"), f->name);
+                   _("target file '%s' has both : and :: entries"), f->name);
 
 	  f = enter_file (strcache_add (name));
 	  /* If there was an existing entry and it was a double-colon entry,
@@ -2049,7 +2049,7 @@ record_files (struct nameseq *filenames, const char *pattern,
       f->is_target = 1;
 
       /* If this is a static pattern rule, set the stem to the part of its
-         name that matched the `%' in the pattern, so you can use $* in the
+         name that matched the '%' in the pattern, so you can use $* in the
          commands.  If we didn't do it before, enter the prereqs now.  */
       if (pattern)
         {
@@ -2954,10 +2954,10 @@ parse_file_seq (char **stringp, unsigned int size, int stopchar,
       /* Strip leading "this directory" references.  */
       if (! (flags & PARSEFS_NOSTRIP))
 #ifdef VMS
-	/* Skip leading `[]'s.  */
+	/* Skip leading '[]'s.  */
 	while (p - s > 2 && s[0] == '[' && s[1] == ']')
 #else
-	/* Skip leading `./'s.  */
+	/* Skip leading './'s.  */
 	while (p - s > 2 && s[0] == '.' && s[1] == '/')
 #endif
 	  {
@@ -3018,7 +3018,7 @@ parse_file_seq (char **stringp, unsigned int size, int stopchar,
          "libf.a(x.o) libf.a(y.o) libf.a(z.o)"
 
          TP == TMP means we're not already in an archive group.  Ignore
-         something starting with `(', as that cannot actually be an
+         something starting with '(', as that cannot actually be an
          archive-member reference (and treating it as such results in an empty
          file name, which causes much lossage).  Also if it ends in ")" then
          it's a complete reference so we don't need to treat it specially.
diff --git a/readme.vms b/readme.vms
index 48ac163..4f507cd 100644
--- a/readme.vms
+++ b/readme.vms
@@ -212,7 +212,7 @@ returns a modification time 1 hour ahead. This results in GNU make
 warning messages. For a just created source you will see:
 
  $ gmake x.exe
- gmake.exe;1: *** Warning: File `x.c' has modification time in the future (940582863 > 940579269)
+ gmake.exe;1: *** Warning: File 'x.c' has modification time in the future (940582863 > 940579269)
  cc    /obj=x.obj x.c
  link  x.obj    /exe=x.exe
  gmake.exe;1: *** Warning:  Clock skew detected.  Your build may be incomplete.
diff --git a/remake.c b/remake.c
index c58d3a5..224d6bf 100644
--- a/remake.c
+++ b/remake.c
@@ -43,7 +43,7 @@ extern int try_implicit_rule (struct file *file, unsigned int depth);
 
 
 /* The test for circular dependencies is based on the 'updating' bit in
-   `struct file'.  However, double colon targets have seperate `struct
+   'struct file'.  However, double colon targets have seperate 'struct
    file's; make sure we always use the base of the double colon chain. */
 
 #define start_updating(_f)  (((_f)->double_colon ? (_f)->double_colon : (_f))\
@@ -70,13 +70,13 @@ static FILE_TIMESTAMP name_mtime (const char *name);
 static const char *library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr);
 
 
-/* Remake all the goals in the `struct dep' chain GOALS.  Return -1 if nothing
+/* Remake all the goals in the 'struct dep' chain GOALS.  Return -1 if nothing
    was done, 0 if all goals were updated successfully, or 1 if a goal failed.
 
    If rebuilding_makefiles is nonzero, these goals are makefiles, so -t, -q,
    and -n should be disabled for them unless they were also command-line
    targets, and we should only make one goal at a time and return as soon as
-   one goal whose `changed' member is nonzero is successfully made.  */
+   one goal whose 'changed' member is nonzero is successfully made.  */
 
 int
 update_goal_chain (struct dep *goals)
@@ -92,7 +92,7 @@ update_goal_chain (struct dep *goals)
   goals = copy_dep_chain (goals);
 
   {
-    /* Clear the `changed' flag of each goal in the chain.
+    /* Clear the 'changed' flag of each goal in the chain.
        We will use the flag below to notice when any commands
        have actually been run for a target.  When no commands
        have been run, we give an "up to date" diagnostic.  */
@@ -149,7 +149,7 @@ update_goal_chain (struct dep *goals)
 		    touch_flag = question_flag = just_print_flag = 0;
 		}
 
-	      /* Save the old value of `commands_started' so we can compare
+	      /* Save the old value of 'commands_started' so we can compare
 		 later.  It will be incremented when any commands are
 		 actually run.  */
 	      ocommands_started = commands_started;
@@ -157,7 +157,7 @@ update_goal_chain (struct dep *goals)
 	      x = update_file (file, rebuilding_makefiles ? 1 : 0);
 	      check_renamed (file);
 
-	      /* Set the goal's `changed' flag if any commands were started
+	      /* Set the goal's 'changed' flag if any commands were started
 		 by calling update_file above.  We check this flag below to
 		 decide when to give an "up to date" diagnostic.  */
               if (commands_started > ocommands_started)
@@ -231,8 +231,8 @@ update_goal_chain (struct dep *goals)
 		  /* Never give a message under -s or -q.  */
 		  && !silent_flag && !question_flag)
 		message (1, ((file->phony || file->cmds == 0)
-			     ? _("Nothing to be done for `%s'.")
-			     : _("`%s' is up to date.")),
+			     ? _("Nothing to be done for '%s'.")
+			     : _("'%s' is up to date.")),
 			 file->name);
 
 	      /* This goal is finished.  Remove it from the chain.  */
@@ -274,7 +274,7 @@ update_goal_chain (struct dep *goals)
 
 /* If FILE is not up to date, execute the commands for it.
    Return 0 if successful, 1 if unsuccessful;
-   but with some flag settings, just call `exit' if unsuccessful.
+   but with some flag settings, just call 'exit' if unsuccessful.
 
    DEPTH is the depth in recursions of this function.
    We increment it during the consideration of our dependencies,
@@ -303,7 +303,7 @@ update_file (struct file *file, unsigned int depth)
          then we will have to continue. */
       if (!(f->updated && f->update_status > 0 && !f->dontcare && f->no_diag))
         {
-          DBF (DB_VERBOSE, _("Pruning file `%s'.\n"));
+          DBF (DB_VERBOSE, _("Pruning file '%s'.\n"));
           return f->command_state == cs_finished ? f->update_status : 0;
         }
     }
@@ -375,9 +375,9 @@ complain (struct file *file)
   if (d == 0)
     {
       const char *msg_noparent
-        = _("%sNo rule to make target `%s'%s");
+        = _("%sNo rule to make target '%s'%s");
       const char *msg_parent
-        = _("%sNo rule to make target `%s', needed by `%s'%s");
+        = _("%sNo rule to make target '%s', needed by '%s'%s");
 
       /* Didn't find any dependencies to complain about. */
       if (!keep_going_flag)
@@ -397,7 +397,7 @@ complain (struct file *file)
     }
 }
 
-/* Consider a single `struct file' and update it as appropriate.  */
+/* Consider a single 'struct file' and update it as appropriate.  */
 
 static int
 update_file_1 (struct file *file, unsigned int depth)
@@ -410,14 +410,14 @@ update_file_1 (struct file *file, unsigned int depth)
   struct dep amake;
   int running = 0;
 
-  DBF (DB_VERBOSE, _("Considering target file `%s'.\n"));
+  DBF (DB_VERBOSE, _("Considering target file '%s'.\n"));
 
   if (file->updated)
     {
       if (file->update_status > 0)
 	{
 	  DBF (DB_VERBOSE,
-               _("Recently tried and failed to update file `%s'.\n"));
+               _("Recently tried and failed to update file '%s'.\n"));
 
           /* If the file we tried to make is marked no_diag then no message
              was printed about it when it failed during the makefile rebuild.
@@ -429,7 +429,7 @@ update_file_1 (struct file *file, unsigned int depth)
 	  return file->update_status;
 	}
 
-      DBF (DB_VERBOSE, _("File `%s' was considered already.\n"));
+      DBF (DB_VERBOSE, _("File '%s' was considered already.\n"));
       return 0;
     }
 
@@ -439,10 +439,10 @@ update_file_1 (struct file *file, unsigned int depth)
     case cs_deps_running:
       break;
     case cs_running:
-      DBF (DB_VERBOSE, _("Still updating file `%s'.\n"));
+      DBF (DB_VERBOSE, _("Still updating file '%s'.\n"));
       return 0;
     case cs_finished:
-      DBF (DB_VERBOSE, _("Finished updating file `%s'.\n"));
+      DBF (DB_VERBOSE, _("Finished updating file '%s'.\n"));
       return file->update_status;
     default:
       abort ();
@@ -471,14 +471,14 @@ update_file_1 (struct file *file, unsigned int depth)
   check_renamed (file);
   noexist = this_mtime == NONEXISTENT_MTIME;
   if (noexist)
-    DBF (DB_BASIC, _("File `%s' does not exist.\n"));
+    DBF (DB_BASIC, _("File '%s' does not exist.\n"));
   else if (ORDINARY_MTIME_MIN <= this_mtime && this_mtime <= ORDINARY_MTIME_MAX
 	   && file->low_resolution_time)
     {
       /* Avoid spurious rebuilds due to low resolution time stamps.  */
       int ns = FILE_TIMESTAMP_NS (this_mtime);
       if (ns != 0)
-	error (NILF, _("*** Warning: .LOW_RESOLUTION_TIME file `%s' has a high resolution time stamp"),
+	error (NILF, _("*** Warning: .LOW_RESOLUTION_TIME file '%s' has a high resolution time stamp"),
 	       file->name);
       this_mtime += FILE_TIMESTAMPS_PER_S - 1 - ns;
     }
@@ -491,15 +491,15 @@ update_file_1 (struct file *file, unsigned int depth)
   if (!file->phony && file->cmds == 0 && !file->tried_implicit)
     {
       if (try_implicit_rule (file, depth))
-	DBF (DB_IMPLICIT, _("Found an implicit rule for `%s'.\n"));
+	DBF (DB_IMPLICIT, _("Found an implicit rule for '%s'.\n"));
       else
-	DBF (DB_IMPLICIT, _("No implicit rule found for `%s'.\n"));
+	DBF (DB_IMPLICIT, _("No implicit rule found for '%s'.\n"));
       file->tried_implicit = 1;
     }
   if (file->cmds == 0 && !file->is_target
       && default_file != 0 && default_file->cmds != 0)
     {
-      DBF (DB_IMPLICIT, _("Using default recipe for `%s'.\n"));
+      DBF (DB_IMPLICIT, _("Using default recipe for '%s'.\n"));
       file->cmds = default_file->cmds;
     }
 
@@ -648,13 +648,13 @@ update_file_1 (struct file *file, unsigned int depth)
   finish_updating (file);
   finish_updating (ofile);
 
-  DBF (DB_VERBOSE, _("Finished prerequisites of target file `%s'.\n"));
+  DBF (DB_VERBOSE, _("Finished prerequisites of target file '%s'.\n"));
 
   if (running)
     {
       set_command_state (file, cs_deps_running);
       --depth;
-      DBF (DB_VERBOSE, _("The prerequisites of `%s' are being made.\n"));
+      DBF (DB_VERBOSE, _("The prerequisites of '%s' are being made.\n"));
       return 0;
     }
 
@@ -667,12 +667,12 @@ update_file_1 (struct file *file, unsigned int depth)
 
       --depth;
 
-      DBF (DB_VERBOSE, _("Giving up on target file `%s'.\n"));
+      DBF (DB_VERBOSE, _("Giving up on target file '%s'.\n"));
 
       if (depth == 0 && keep_going_flag
 	  && !just_print_flag && !question_flag)
 	error (NILF,
-               _("Target `%s' not remade because of errors."), file->name);
+               _("Target '%s' not remade because of errors."), file->name);
 
       return dep_status;
     }
@@ -724,20 +724,20 @@ update_file_1 (struct file *file, unsigned int depth)
           if (d->ignore_mtime)
             {
               if (ISDB (DB_VERBOSE))
-                fmt = _("Prerequisite `%s' is order-only for target `%s'.\n");
+                fmt = _("Prerequisite '%s' is order-only for target '%s'.\n");
             }
           else if (d_mtime == NONEXISTENT_MTIME)
             {
               if (ISDB (DB_BASIC))
-                fmt = _("Prerequisite `%s' of target `%s' does not exist.\n");
+                fmt = _("Prerequisite '%s' of target '%s' does not exist.\n");
             }
 	  else if (d->changed)
             {
               if (ISDB (DB_BASIC))
-                fmt = _("Prerequisite `%s' is newer than target `%s'.\n");
+                fmt = _("Prerequisite '%s' is newer than target '%s'.\n");
             }
           else if (ISDB (DB_VERBOSE))
-            fmt = _("Prerequisite `%s' is older than target `%s'.\n");
+            fmt = _("Prerequisite '%s' is older than target '%s'.\n");
 
           if (fmt)
             {
@@ -755,19 +755,19 @@ update_file_1 (struct file *file, unsigned int depth)
     {
       must_make = 1;
       DBF (DB_BASIC,
-           _("Target `%s' is double-colon and has no prerequisites.\n"));
+           _("Target '%s' is double-colon and has no prerequisites.\n"));
     }
   else if (!noexist && file->is_target && !deps_changed && file->cmds == 0
            && !always_make_flag)
     {
       must_make = 0;
       DBF (DB_VERBOSE,
-           _("No recipe for `%s' and no prerequisites actually changed.\n"));
+           _("No recipe for '%s' and no prerequisites actually changed.\n"));
     }
   else if (!must_make && file->cmds != 0 && always_make_flag)
     {
       must_make = 1;
-      DBF (DB_VERBOSE, _("Making `%s' due to always-make flag.\n"));
+      DBF (DB_VERBOSE, _("Making '%s' due to always-make flag.\n"));
     }
 
   if (!must_make)
@@ -775,9 +775,9 @@ update_file_1 (struct file *file, unsigned int depth)
       if (ISDB (DB_VERBOSE))
         {
           print_spaces (depth);
-          printf (_("No need to remake target `%s'"), file->name);
+          printf (_("No need to remake target '%s'"), file->name);
           if (!streq (file->name, file->hname))
-              printf (_("; using VPATH name `%s'"), file->hname);
+              printf (_("; using VPATH name '%s'"), file->hname);
           puts (".");
           fflush (stdout);
         }
@@ -797,13 +797,13 @@ update_file_1 (struct file *file, unsigned int depth)
       return 0;
     }
 
-  DBF (DB_BASIC, _("Must remake target `%s'.\n"));
+  DBF (DB_BASIC, _("Must remake target '%s'.\n"));
 
   /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
      VPATH.  */
   if (!streq(file->name, file->hname))
     {
-      DB (DB_BASIC, (_("  Ignoring VPATH name `%s'.\n"), file->hname));
+      DB (DB_BASIC, (_("  Ignoring VPATH name '%s'.\n"), file->hname));
       file->ignore_vpath = 1;
     }
 
@@ -812,20 +812,20 @@ update_file_1 (struct file *file, unsigned int depth)
 
   if (file->command_state != cs_finished)
     {
-      DBF (DB_VERBOSE, _("Recipe of `%s' is being run.\n"));
+      DBF (DB_VERBOSE, _("Recipe of '%s' is being run.\n"));
       return 0;
     }
 
   switch (file->update_status)
     {
     case 2:
-      DBF (DB_BASIC, _("Failed to remake target file `%s'.\n"));
+      DBF (DB_BASIC, _("Failed to remake target file '%s'.\n"));
       break;
     case 0:
-      DBF (DB_BASIC, _("Successfully remade target file `%s'.\n"));
+      DBF (DB_BASIC, _("Successfully remade target file '%s'.\n"));
       break;
     case 1:
-      DBF (DB_BASIC, _("Target file `%s' needs remade under -q.\n"));
+      DBF (DB_BASIC, _("Target file '%s' needs remade under -q.\n"));
       break;
     default:
       assert (file->update_status >= 0 && file->update_status <= 2);
@@ -836,8 +836,8 @@ update_file_1 (struct file *file, unsigned int depth)
   return file->update_status;
 }
 
-/* Set FILE's `updated' flag and re-check its mtime and the mtime's of all
-   files listed in its `also_make' member.  Under -t, this function also
+/* Set FILE's 'updated' flag and re-check its mtime and the mtime's of all
+   files listed in its 'also_make' member.  Under -t, this function also
    touches FILE.
 
    On return, FILE->update_status will no longer be -1 if it was.  */
@@ -882,7 +882,7 @@ notice_finished_file (struct file *file)
               file->update_status = touch_file (file);
 
               /* Pretend we ran a real touch command, to suppress the
-                 "`foo' is up to date" message.  */
+                 "'foo' is up to date" message.  */
               commands_started++;
 
               /* Request for the timestamp to be updated (and distributed
@@ -1013,15 +1013,15 @@ check_dep (struct file *file, unsigned int depth,
       if (!file->phony && file->cmds == 0 && !file->tried_implicit)
 	{
 	  if (try_implicit_rule (file, depth))
-	    DBF (DB_IMPLICIT, _("Found an implicit rule for `%s'.\n"));
+	    DBF (DB_IMPLICIT, _("Found an implicit rule for '%s'.\n"));
 	  else
-	    DBF (DB_IMPLICIT, _("No implicit rule found for `%s'.\n"));
+	    DBF (DB_IMPLICIT, _("No implicit rule found for '%s'.\n"));
 	  file->tried_implicit = 1;
 	}
       if (file->cmds == 0 && !file->is_target
 	  && default_file != 0 && default_file->cmds != 0)
 	{
-	  DBF (DB_IMPLICIT, _("Using default commands for `%s'.\n"));
+	  DBF (DB_IMPLICIT, _("Using default commands for '%s'.\n"));
 	  file->cmds = default_file->cmds;
 	}
 
@@ -1202,7 +1202,7 @@ remake_file (struct file *file)
   notice_finished_file (file);
 }
 
-/* Return the mtime of a file, given a `struct file'.
+/* Return the mtime of a file, given a 'struct file'.
    Caches the time in the struct file to avoid excess stat calls.
 
    If the file is not found, and SEARCH is nonzero, VPATH searching and
@@ -1358,7 +1358,7 @@ f_mtime (struct file *file, int search)
           if (adjusted_now < adjusted_mtime)
             {
 #ifdef NO_FLOAT
-              error (NILF, _("Warning: File `%s' has modification time in the future"),
+              error (NILF, _("Warning: File '%s' has modification time in the future"),
                      file->name);
 #else
               double from_now =
@@ -1371,7 +1371,7 @@ f_mtime (struct file *file, int search)
                 sprintf (from_now_string, "%lu", (unsigned long) from_now);
               else
                 sprintf (from_now_string, "%.2g", from_now);
-              error (NILF, _("Warning: File `%s' has modification time %s s in the future"),
+              error (NILF, _("Warning: File '%s' has modification time %s s in the future"),
                      file->name, from_now_string);
 #endif
               clock_skew_detected = 1;
@@ -1570,7 +1570,7 @@ library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr)
 	if (!p3)
 	  {
 	    /* Give a warning if there is no pattern.  */
-	    error (NILF, _(".LIBPATTERNS element `%s' is not a pattern"), p);
+	    error (NILF, _(".LIBPATTERNS element '%s' is not a pattern"), p);
             p[len] = c;
 	    continue;
 	  }
@@ -1580,7 +1580,7 @@ library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr)
 	p[len] = c;
       }
 
-      /* Look first for `libNAME.a' in the current directory.  */
+      /* Look first for 'libNAME.a' in the current directory.  */
       mtime = name_mtime (libbuf);
       if (mtime != NONEXISTENT_MTIME)
 	{
diff --git a/remote-cstms.c b/remote-cstms.c
index bbdf1c3..92d1ed4 100644
--- a/remote-cstms.c
+++ b/remote-cstms.c
@@ -34,7 +34,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 char *remote_description = "Customs";
 
-/* File name of the Customs `export' client command.
+/* File name of the Customs 'export' client command.
    A full path name can be used to avoid some path-searching overhead.  */
 #define	EXPORT_COMMAND	"/usr/local/bin/export"
 
@@ -175,7 +175,7 @@ start_remote_job (char **argv, char **envp, int stdin_fd,
   len = Customs_MakeWayBill (&permit, normalized_cwd, argv[0], argv,
 			     envp, retport, waybill);
 
-  /* Modify the waybill as if the remote child had done `child_access ()'.  */
+  /* Modify the waybill as if the remote child had done 'child_access ()'.  */
   {
     WayBill *wb = (WayBill *) waybill;
     wb->ruid = wb->euid;
@@ -232,7 +232,7 @@ start_remote_job (char **argv, char **envp, int stdin_fd,
     }
   else if (pid == 0)
     {
-      /* Child side.  Run `export' to handle the connection.  */
+      /* Child side.  Run 'export' to handle the connection.  */
       static char sock_buf[20], retsock_buf[20], id_buf[20];
       static char *new_argv[6] =
 	{ EXPORT_COMMAND, "-id", sock_buf, retsock_buf, id_buf, 0 };
@@ -253,7 +253,7 @@ start_remote_job (char **argv, char **envp, int stdin_fd,
       exec_command (new_argv, envp);
     }
 
-  /* Parent side.  Return the `export' process's ID.  */
+  /* Parent side.  Return the 'export' process's ID.  */
   (void) close (retsock);
   (void) close (sock);
   *is_remote = 0;
diff --git a/rule.c b/rule.c
index bc83e44..bf52d0e 100644
--- a/rule.c
+++ b/rule.c
@@ -126,7 +126,7 @@ count_implicit_rule_limits (void)
 	      memcpy (name, dname, p - dname);
 	      name[p - dname] = '\0';
 
-	      /* In the deps of an implicit rule the `changed' flag
+	      /* In the deps of an implicit rule the 'changed' flag
 		 actually indicates that the dependency is in a
 		 nonexistent subdirectory.  */
 
@@ -151,7 +151,7 @@ count_implicit_rule_limits (void)
 /* Create a pattern rule from a suffix rule.
    TARGET is the target suffix; SOURCE is the source suffix.
    CMDS are the commands.
-   If TARGET is nil, it means the target pattern should be `(%.o)'.
+   If TARGET is nil, it means the target pattern should be '(%.o)'.
    If SOURCE is nil, it means there should be no deps.  */
 
 static void
@@ -166,8 +166,8 @@ convert_suffix_rule (const char *target, const char *source,
 
   if (target == 0)
     {
-      /* Special case: TARGET being nil means we are defining a `.X.a' suffix
-         rule; the target pattern is always `(%.o)'.  */
+      /* Special case: TARGET being nil means we are defining a '.X.a' suffix
+         rule; the target pattern is always '(%.o)'.  */
 #ifdef VMS
       *names = strcache_add_len ("(%.obj)", 7);
 #else
@@ -261,14 +261,14 @@ convert_to_pattern (void)
 	    continue;
 
 	  if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
-	    /* A suffix rule `.X.a:' generates the pattern rule `(%.o): %.X'.
-	       It also generates a normal `%.a: %.X' rule below.  */
-	    convert_suffix_rule (NULL, /* Indicates `(%.o)'.  */
+	    /* A suffix rule '.X.a:' generates the pattern rule '(%.o): %.X'.
+	       It also generates a normal '%.a: %.X' rule below.  */
+	    convert_suffix_rule (NULL, /* Indicates '(%.o)'.  */
 				 dep_name (d),
 				 f->cmds);
 
-	  /* The suffix rule `.X.Y:' is converted
-	     to the pattern rule `%.Y: %.X'.  */
+	  /* The suffix rule '.X.Y:' is converted
+	     to the pattern rule '%.Y: %.X'.  */
 	  convert_suffix_rule (dep_name (d2), dep_name (d), f->cmds);
 	}
     }
@@ -355,7 +355,7 @@ new_pattern_rule (struct rule *rule, int override)
 /* Install an implicit pattern rule based on the three text strings
    in the structure P points to.  These strings come from one of
    the arrays of default implicit pattern rules.
-   TERMINAL specifies what the `terminal' field of the rule should be.  */
+   TERMINAL specifies what the 'terminal' field of the rule should be.  */
 
 void
 install_pattern_rule (struct pspec *p, int terminal)
@@ -413,13 +413,13 @@ freerule (struct rule *rule, struct rule *lastrule)
   /* We can't free the storage for the commands because there
      are ways that they could be in more than one place:
        * If the commands came from a suffix rule, they could also be in
-       the `struct file's for other suffix rules or plain targets given
+       the 'struct file's for other suffix rules or plain targets given
        on the same makefile line.
        * If two suffixes that together make a two-suffix rule were each
        given twice in the .SUFFIXES list, and in the proper order, two
        identical pattern rules would be created and the second one would
-       be discarded here, but both would contain the same `struct commands'
-       pointer from the `struct file' for the suffix rule.  */
+       be discarded here, but both would contain the same 'struct commands'
+       pointer from the 'struct file' for the suffix rule.  */
 
   free (rule);
 
diff --git a/rule.h b/rule.h
index e72da61..118302e 100644
--- a/rule.h
+++ b/rule.h
@@ -24,7 +24,7 @@ struct rule
     struct rule *next;
     const char **targets;	/* Targets of the rule.  */
     unsigned int *lens;		/* Lengths of each target.  */
-    const char **suffixes;	/* Suffixes (after `%') of each target.  */
+    const char **suffixes;	/* Suffixes (after '%') of each target.  */
     struct dep *deps;		/* Dependencies of the rule.  */
     struct commands *cmds;	/* Commands to execute.  */
     unsigned short num;         /* Number of targets.  */
diff --git a/tests/mkshadow b/tests/mkshadow
index dfd054c..1413630 100755
--- a/tests/mkshadow
+++ b/tests/mkshadow
@@ -28,7 +28,7 @@ esac
 dest="$1"
 
 if [ ! -d "$dest" ]; then
-  echo "Destination directory \`$dest' must exist!"
+  echo "Destination directory '$dest' must exist!"
   exit 1
 fi
 
@@ -55,5 +55,5 @@ done
 
 rm -rf work
 
-echo "Shadow test suite created in \`$dest/$name'."
+echo "Shadow test suite created in '$dest/$name'."
 exit 0
diff --git a/tests/run_make_tests.pl b/tests/run_make_tests.pl
index 88f62a9..294b289 100755
--- a/tests/run_make_tests.pl
+++ b/tests/run_make_tests.pl
@@ -318,7 +318,7 @@ sub set_more_defaults
    $mk or die "FATAL ERROR: Cannot determine the value of \$(MAKE):\n
 'echo \"all:;\@echo \\\$(MAKE)\" | $make_path -f-' failed!\n";
    $make_path = $mk;
-   print "Make\t= `$make_path'\n" if $debug;
+   print "Make\t= '$make_path'\n" if $debug;
 
    $string = `$make_path -v -f /dev/null 2> /dev/null`;
 
diff --git a/tests/scripts/features/archives b/tests/scripts/features/archives
index 3fe46a0..af4fa39 100644
--- a/tests/scripts/features/archives
+++ b/tests/scripts/features/archives
@@ -25,7 +25,7 @@ run_make_test(undef, '', "ar rv libxx.a a1.o\nr - a1.o\n");
 
 # Use wildcards
 run_make_test('all: libxx.a(*.o)',
-              '', "#MAKE#: Nothing to be done for `all'.\n");
+              '', "#MAKE#: Nothing to be done for 'all'.\n");
 
 # Touch one of the .o's so it's rebuilt
 utouch(-30, 'a1.o');
diff --git a/tests/scripts/features/errors b/tests/scripts/features/errors
index 1e4be46..c0339cb 100644
--- a/tests/scripts/features/errors
+++ b/tests/scripts/features/errors
@@ -50,7 +50,7 @@ $delete_error_code = $? >> 8;
 
 $answer = "$rm_command cleanit
 $cleanit_error
-$makefile:2: recipe for target `clean' failed
+$makefile:2: recipe for target 'clean' failed
 $make_name: [clean] Error $delete_error_code (ignored)
 $rm_command foo\n";
 
@@ -78,7 +78,7 @@ if (!$vos)
 
 $answer = "$rm_command cleanit
 $cleanit_error
-$makefile:5: recipe for target `clean2' failed
+$makefile:5: recipe for target 'clean2' failed
 $make_name: [clean2] Error $delete_error_code (ignored)
 $rm_command foo\n";
 
diff --git a/tests/scripts/features/escape b/tests/scripts/features/escape
index 97a2994..36bab18 100644
--- a/tests/scripts/features/escape
+++ b/tests/scripts/features/escape
@@ -2,7 +2,7 @@
 $description = "Test various types of escaping in makefiles.";
 
 $details = "\
-Make sure that escaping of `:' works in target names.
+Make sure that escaping of ':' works in target names.
 Make sure escaping of whitespace works in target names.
 Make sure that escaping of '#' works.";
 
@@ -26,7 +26,7 @@ foo\#bar.ext: ; @echo "foo#bar.ext = ($@)"',
 
 run_make_test(undef,
 	      'path=pre:',
-	      "#MAKEFILE#:2: *** target pattern contains no `%'.  Stop.",
+	      "#MAKEFILE#:2: *** target pattern contains no '%'.  Stop.",
 	      512);
 
 # TEST 3: This one should work, since we escape the ":".
@@ -39,7 +39,7 @@ run_make_test(undef,
 
 run_make_test(undef,
 	      "'path=pre\\\\:'",
-	      "#MAKEFILE#:2: *** target pattern contains no `%'.  Stop.",
+	      "#MAKEFILE#:2: *** target pattern contains no '%'.  Stop.",
 	      512);
 
 # TEST 5: This one should work
diff --git a/tests/scripts/features/include b/tests/scripts/features/include
index ba8908c..ee014bd 100644
--- a/tests/scripts/features/include
+++ b/tests/scripts/features/include
@@ -1,6 +1,6 @@
 #                                     -*-mode: perl; rm-trailing-spaces: nil-*-
 
-$description = "Test various forms of the GNU make `include' command.";
+$description = "Test various forms of the GNU make 'include' command.";
 
 $details = "\
 Test include, -include, sinclude and various regressions involving them.
@@ -60,7 +60,7 @@ run_make_test
 error: foo.mk ; @echo $@
 ',
    '',
-   "#MAKE#: *** No rule to make target `foo.mk', needed by `error'.  Stop.\n",
+   "#MAKE#: *** No rule to make target 'foo.mk', needed by 'error'.  Stop.\n",
    512
   );
 
@@ -128,7 +128,7 @@ foo: baz
 bar: baz
 ',
 '',
-"#MAKE#: *** No rule to make target `baz', needed by `bar'.  Stop.\n",
+"#MAKE#: *** No rule to make target 'baz', needed by 'bar'.  Stop.\n",
 512);
 
 # Test that the diagnostics is issued even if the target has been
@@ -144,7 +144,7 @@ bar: baz
 baz: end
 ',
 '',
-"#MAKE#: *** No rule to make target `end', needed by `baz'.  Stop.\n",
+"#MAKE#: *** No rule to make target 'end', needed by 'baz'.  Stop.\n",
 512);
 
 # Test that the diagnostics is issued even if the target has been
@@ -162,7 +162,7 @@ baz: end
 ',
 '',
 "#MAKEFILE#:2: bar: No such file or directory
-#MAKE#: *** No rule to make target `end', needed by `baz'.  Stop.\n",
+#MAKE#: *** No rule to make target 'end', needed by 'baz'.  Stop.\n",
 512);
 
 if ($all_tests) {
@@ -172,7 +172,7 @@ if ($all_tests) {
 include foo
 foo: ; @echo foo = bar > $@
 !,
-                  '', "#MAKE#: `foo' is up to date.\n");
+                  '', "#MAKE#: 'foo' is up to date.\n");
     rmfiles('foo');
 }
 
diff --git a/tests/scripts/features/mult_rules b/tests/scripts/features/mult_rules
index 6f120f1..e706e17 100644
--- a/tests/scripts/features/mult_rules
+++ b/tests/scripts/features/mult_rules
@@ -47,7 +47,7 @@ else
                        $error_code);
 
 # Create the answer to what should be produced by this Makefile
-$answer = "$make_name: *** No rule to make target `extra.h', needed by `foo.o'.  Stop.\n";
+$answer = "$make_name: *** No rule to make target 'extra.h', needed by 'foo.o'.  Stop.\n";
 
 &compare_output($answer,&get_logfile(1));
 
diff --git a/tests/scripts/features/parallelism b/tests/scripts/features/parallelism
index 909c979..d4250f0 100644
--- a/tests/scripts/features/parallelism
+++ b/tests/scripts/features/parallelism
@@ -99,14 +99,14 @@ ok:
 	\@sleep 4
 	\@echo Ok done",
               '-rR -j5', "Fail
-#MAKEFILE#:6: recipe for target `fail.1' failed
+#MAKEFILE#:6: recipe for target 'fail.1' failed
 #MAKE#: *** [fail.1] Error 1
 #MAKE#: *** Waiting for unfinished jobs....
 Fail
-#MAKEFILE#:6: recipe for target `fail.2' failed
+#MAKEFILE#:6: recipe for target 'fail.2' failed
 #MAKE#: *** [fail.2] Error 1
 Fail
-#MAKEFILE#:6: recipe for target `fail.3' failed
+#MAKEFILE#:6: recipe for target 'fail.3' failed
 #MAKE#: *** [fail.3] Error 1
 Ok done",
              512);
diff --git a/tests/scripts/features/patternrules b/tests/scripts/features/patternrules
index 5cc6b94..0ff49a7 100644
--- a/tests/scripts/features/patternrules
+++ b/tests/scripts/features/patternrules
@@ -110,7 +110,7 @@ $(dir)/foo.bar:
 
 ',
 "dir=$dir",
-"#MAKEFILE#:6: recipe for target `$dir/foo.bar' failed
+"#MAKEFILE#:6: recipe for target '$dir/foo.bar' failed
 #MAKE#: *** [$dir/foo.bar] Error 1",
 512);
 
@@ -204,7 +204,7 @@ CWEAVE := :
 %.tex : %.w %.ch
 !,
               'foo.tex',
-              "#MAKE#: *** No rule to make target `foo.tex'.  Stop.", 512);
+              "#MAKE#: *** No rule to make target 'foo.tex'.  Stop.", 512);
 
 unlink(@f);
 
diff --git a/tests/scripts/features/recursion b/tests/scripts/features/recursion
index a6b8f90..fd5e351 100644
--- a/tests/scripts/features/recursion
+++ b/tests/scripts/features/recursion
@@ -18,7 +18,7 @@ last:
 ',
               ('CFLAGS=-O -w' . ($parallel_jobs ? ' -j 2' : '')),
               ($vos
-               ? "#MAKE#: Entering directory `#PWD#'
+               ? "#MAKE#: Entering directory '#PWD#'
 make 'CFLAGS=-O' -f #MAKEFILE# foo
 make CFLAGS=-O
 MAKELEVEL = 0
@@ -26,20 +26,20 @@ make 'CFLAGS=-O' -f #MAKEFILE# last
 make CFLAGS=-O
 MAKELEVEL = 0
 THE END
-#MAKE#: Leaving directory `#PWD#'"
-               : "#MAKE#: Entering directory `#PWD#'
+#MAKE#: Leaving directory '#PWD#'"
+               : "#MAKE#: Entering directory '#PWD#'
 #MAKEPATH# -f #MAKEFILE# foo
-#MAKE#[1]: Entering directory `#PWD#'
+#MAKE#[1]: Entering directory '#PWD#'
 #MAKEPATH#
 MAKELEVEL = 1
 #MAKEPATH# -f #MAKEFILE# last
-#MAKE#[2]: Entering directory `#PWD#'
+#MAKE#[2]: Entering directory '#PWD#'
 #MAKEPATH#
 MAKELEVEL = 2
 THE END
-#MAKE#[2]: Leaving directory `#PWD#'
-#MAKE#[1]: Leaving directory `#PWD#'
-#MAKE#: Leaving directory `#PWD#'"));
+#MAKE#[2]: Leaving directory '#PWD#'
+#MAKE#[1]: Leaving directory '#PWD#'
+#MAKE#: Leaving directory '#PWD#'"));
 
 
 # Test command line overrides.
diff --git a/tests/scripts/features/se_explicit b/tests/scripts/features/se_explicit
index 79e0a36..f942a1c 100644
--- a/tests/scripts/features/se_explicit
+++ b/tests/scripts/features/se_explicit
@@ -115,7 +115,7 @@ run_make_test(q!
 .SECONDEXPANSION:
 all : $$(eval $$(info test))
 !,
-            '', "test\n#MAKE#: Nothing to be done for `all'.\n");
+            '', "test\n#MAKE#: Nothing to be done for 'all'.\n");
 
 # TEST #5: (NEGATIVE) catch eval in a prereq list trying to create new
 # target/prereq relationships.
diff --git a/tests/scripts/features/vpath b/tests/scripts/features/vpath
index a3aebd9..ec24165 100644
--- a/tests/scripts/features/vpath
+++ b/tests/scripts/features/vpath
@@ -74,7 +74,7 @@ vpath-d/a: fail.te
 vpath-d/b : fail.te
 vpath-d/fail.te:
 !,
-              '', "#MAKE#: Nothing to be done for `default'.\n");
+              '', "#MAKE#: Nothing to be done for 'default'.\n");
 
 rmdir('vpath-d');
 
diff --git a/tests/scripts/features/vpathgpath b/tests/scripts/features/vpathgpath
index f7683f5..5e6217b 100644
--- a/tests/scripts/features/vpathgpath
+++ b/tests/scripts/features/vpathgpath
@@ -57,7 +57,7 @@ sub touchfiles {
 
 push(@touchedfiles, "bar.c");
 
-$answer = "$make_name: Nothing to be done for `general'.\n";
+$answer = "$make_name: Nothing to be done for 'general'.\n";
 
 &compare_output($answer,&get_logfile(1));
 
diff --git a/tests/scripts/features/vpathplus b/tests/scripts/features/vpathplus
index c95c8ab..361788c 100644
--- a/tests/scripts/features/vpathplus
+++ b/tests/scripts/features/vpathplus
@@ -86,7 +86,7 @@ cat ${VP}foo.c bar.c > foo.b 2>/dev/null || exit 1
 
 $answer = "not creating notarget.c from notarget.d
 cat notarget.c > notarget.b 2>/dev/null || exit 1
-$makefile:16: recipe for target `notarget.b' failed
+$makefile:16: recipe for target 'notarget.b' failed
 $make_name: *** [notarget.b] Error 1
 ";
 
diff --git a/tests/scripts/functions/call b/tests/scripts/functions/call
index 98f1d92..9db9da7 100644
--- a/tests/scripts/functions/call
+++ b/tests/scripts/functions/call
@@ -13,7 +13,7 @@ print MAKEFILE <<'EOMAKE';
 #
 reverse = $2 $1
 
-# A complex `map' function, using recursive `call'.
+# A complex 'map' function, using recursive 'call'.
 #
 map = $(foreach a,$2,$(call $1,$a))
 
diff --git a/tests/scripts/functions/foreach b/tests/scripts/functions/foreach
index 9d1c464..4d1a11d 100644
--- a/tests/scripts/functions/foreach
+++ b/tests/scripts/functions/foreach
@@ -62,7 +62,7 @@ y = $x
 
 all: ; @echo $y',
               '',
-              "#MAKEFILE#:2: *** insufficient number of arguments (1) to function `foreach'.  Stop.",
+              "#MAKEFILE#:2: *** insufficient number of arguments (1) to function 'foreach'.  Stop.",
               512);
 
 run_make_test('
@@ -71,7 +71,7 @@ y := $x
 
 all: ; @echo $y',
               '',
-              "#MAKEFILE#:2: *** insufficient number of arguments (1) to function `foreach'.  Stop.",
+              "#MAKEFILE#:2: *** insufficient number of arguments (1) to function 'foreach'.  Stop.",
               512);
 
 1;
diff --git a/tests/scripts/functions/word b/tests/scripts/functions/word
index 34527ea..4dcc940 100644
--- a/tests/scripts/functions/word
+++ b/tests/scripts/functions/word
@@ -56,32 +56,32 @@ wordlist-e1: ; @echo $(wordlist ,,$(FOO))
 wordlist-e2: ; @echo $(wordlist abc ,,$(FOO))
 wordlist-e3: ; @echo $(wordlist 1, 12a ,$(FOO))',
               'word-e1',
-              "#MAKEFILE#:3: *** non-numeric first argument to `word' function: ''.  Stop.",
+              "#MAKEFILE#:3: *** non-numeric first argument to 'word' function: ''.  Stop.",
               512);
 
 run_make_test(undef,
               'word-e2',
-              "#MAKEFILE#:4: *** non-numeric first argument to `word' function: 'abc '.  Stop.",
+              "#MAKEFILE#:4: *** non-numeric first argument to 'word' function: 'abc '.  Stop.",
               512);
 
 run_make_test(undef,
               'word-e3',
-              "#MAKEFILE#:5: *** non-numeric first argument to `word' function: '1a'.  Stop.",
+              "#MAKEFILE#:5: *** non-numeric first argument to 'word' function: '1a'.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e1',
-              "#MAKEFILE#:7: *** non-numeric first argument to `wordlist' function: ''.  Stop.",
+              "#MAKEFILE#:7: *** non-numeric first argument to 'wordlist' function: ''.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e2',
-              "#MAKEFILE#:8: *** non-numeric first argument to `wordlist' function: 'abc '.  Stop.",
+              "#MAKEFILE#:8: *** non-numeric first argument to 'wordlist' function: 'abc '.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e3',
-              "#MAKEFILE#:9: *** non-numeric second argument to `wordlist' function: ' 12a '.  Stop.",
+              "#MAKEFILE#:9: *** non-numeric second argument to 'wordlist' function: ' 12a '.  Stop.",
               512);
 
 # Test error conditions again, but this time in a variable reference
@@ -94,37 +94,37 @@ WL = $(wordlist $s,$e,$(FOO))
 word-e: ; @echo $(W)
 wordlist-e: ; @echo $(WL)',
               'word-e x=',
-              "#MAKEFILE#:3: *** non-numeric first argument to `word' function: ''.  Stop.",
+              "#MAKEFILE#:3: *** non-numeric first argument to 'word' function: ''.  Stop.",
               512);
 
 run_make_test(undef,
               'word-e x=abc',
-              "#MAKEFILE#:3: *** non-numeric first argument to `word' function: 'abc'.  Stop.",
+              "#MAKEFILE#:3: *** non-numeric first argument to 'word' function: 'abc'.  Stop.",
               512);
 
 run_make_test(undef,
               'word-e x=0',
-              "#MAKEFILE#:3: *** first argument to `word' function must be greater than 0.  Stop.",
+              "#MAKEFILE#:3: *** first argument to 'word' function must be greater than 0.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e s= e=',
-              "#MAKEFILE#:4: *** non-numeric first argument to `wordlist' function: ''.  Stop.",
+              "#MAKEFILE#:4: *** non-numeric first argument to 'wordlist' function: ''.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e s=abc e=',
-              "#MAKEFILE#:4: *** non-numeric first argument to `wordlist' function: 'abc'.  Stop.",
+              "#MAKEFILE#:4: *** non-numeric first argument to 'wordlist' function: 'abc'.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e s=4 e=12a',
-              "#MAKEFILE#:4: *** non-numeric second argument to `wordlist' function: '12a'.  Stop.",
+              "#MAKEFILE#:4: *** non-numeric second argument to 'wordlist' function: '12a'.  Stop.",
               512);
 
 run_make_test(undef,
               'wordlist-e s=0 e=12',
-              "#MAKEFILE#:4: *** invalid first argument to `wordlist' function: `0'.  Stop.",
+              "#MAKEFILE#:4: *** invalid first argument to 'wordlist' function: '0'.  Stop.",
               512);
 
 
diff --git a/tests/scripts/misc/general3 b/tests/scripts/misc/general3
index b3142c2..8ad0f8e 100644
--- a/tests/scripts/misc/general3
+++ b/tests/scripts/misc/general3
@@ -26,7 +26,7 @@ TAB =   \t  \# A TAB and some spaces
 \$(STR)
 
 \$(STR) \$(TAB)",
-              '', "#MAKE#: Nothing to be done for `all'.");
+              '', "#MAKE#: Nothing to be done for 'all'.");
 
 # TEST 2
 
diff --git a/tests/scripts/options/dash-B b/tests/scripts/options/dash-B
index e36842e..9c708b7 100644
--- a/tests/scripts/options/dash-B
+++ b/tests/scripts/options/dash-B
@@ -22,13 +22,13 @@ foo: bar.x
 ',
               '', 'cp bar.x foo');
 
-run_make_test(undef, '', "#MAKE#: Nothing to be done for `all'.");
+run_make_test(undef, '', "#MAKE#: Nothing to be done for 'all'.");
 run_make_test(undef, '-B', 'cp bar.x foo');
 
 # Put the timestamp for foo into the future; it should still be remade.
 
 utouch(1000, 'foo');
-run_make_test(undef, '', "#MAKE#: Nothing to be done for `all'.");
+run_make_test(undef, '', "#MAKE#: Nothing to be done for 'all'.");
 run_make_test(undef, '-B', 'cp bar.x foo');
 
 # Clean up
diff --git a/tests/scripts/options/dash-C b/tests/scripts/options/dash-C
index 5864ffd..42d0a8b 100644
--- a/tests/scripts/options/dash-C
+++ b/tests/scripts/options/dash-C
@@ -34,9 +34,9 @@ if (-f $example) {
 }
 
 # Create the answer to what should be produced by this Makefile
-$answer = "$make_name: Entering directory `$wpath'\n"
+$answer = "$make_name: Entering directory '$wpath'\n"
         . "$delete_command EXAMPLE\n"
-        . "$make_name: Leaving directory `$wpath'\n";
+        . "$make_name: Leaving directory '$wpath'\n";
 
 &compare_output($answer,&get_logfile(1));
 
@@ -62,9 +62,9 @@ if (-f $example) {
 }
 
 # Create the answer to what should be produced by this Makefile
-$answer = "$make_name: Entering directory `$wpath'\n"
+$answer = "$make_name: Entering directory '$wpath'\n"
         . "$delete_command EXAMPLEslash\n"
-        . "$make_name: Leaving directory `$wpath'\n";
+        . "$make_name: Leaving directory '$wpath'\n";
 
 &compare_output($answer,&get_logfile(1));
 
diff --git a/tests/scripts/options/dash-I b/tests/scripts/options/dash-I
index 8dc5d9b..d47a8d8 100644
--- a/tests/scripts/options/dash-I
+++ b/tests/scripts/options/dash-I
@@ -51,9 +51,9 @@ $answer = "This is another included makefile\n";
 
 
 $answer = "$mkpath ANOTHER -f $makefile
-${make_name}[1]: Entering directory `$pwd'
+${make_name}[1]: Entering directory '$pwd'
 This is another included makefile
-${make_name}[1]: Leaving directory `$pwd'\n";
+${make_name}[1]: Leaving directory '$pwd'\n";
 
 &run_make_with_options($makefile,"-I $workdir recurse",&get_logfile);
 &compare_output($answer,&get_logfile(1));
diff --git a/tests/scripts/options/dash-W b/tests/scripts/options/dash-W
index d3fde87..20b9f74 100644
--- a/tests/scripts/options/dash-W
+++ b/tests/scripts/options/dash-W
@@ -12,7 +12,7 @@ a.x b.x: ; echo >> $@
 
 # Run it again: nothing should happen
 
-run_make_test(undef, '', "#MAKE#: `a.x' is up to date.");
+run_make_test(undef, '', "#MAKE#: 'a.x' is up to date.");
 
 # Now run it with -W b.x: should rebuild a.x
 
@@ -21,7 +21,7 @@ run_make_test(undef, '-W b.x', 'echo >> a.x');
 # Put the timestamp for a.x into the future; it should still be remade.
 
 utouch(1000, 'a.x');
-run_make_test(undef, '', "#MAKE#: `a.x' is up to date.");
+run_make_test(undef, '', "#MAKE#: 'a.x' is up to date.");
 run_make_test(undef, '-W b.x', 'echo >> a.x');
 
 # Clean up
diff --git a/tests/scripts/options/dash-k b/tests/scripts/options/dash-k
index 40d9b97..e784e0d 100644
--- a/tests/scripts/options/dash-k
+++ b/tests/scripts/options/dash-k
@@ -57,10 +57,10 @@ else {
 
 # Create the answer to what should be produced by this Makefile
 $answer = "cc -c main.c
-$make_name: *** No rule to make target `kbd.c', needed by `kbd.o'.
+$make_name: *** No rule to make target 'kbd.c', needed by 'kbd.o'.
 cc -c commands.c
 cc -c display.c
-$make_name: Target `edit' not remade because of errors.\n";
+$make_name: Target 'edit' not remade because of errors.\n";
 
 # COMPARE RESULTS
 
@@ -92,9 +92,9 @@ close(MAKEFILE);
 &run_make_with_options($makefile2, "-k", &get_logfile, $error_code);
 
 $answer = "exit 1
-$makefile2:9: recipe for target `foo.o' failed
+$makefile2:9: recipe for target 'foo.o' failed
 $make_name: *** [foo.o] Error 1
-$make_name: Target `all' not remade because of errors.\n";
+$make_name: Target 'all' not remade because of errors.\n";
 
 &compare_output($answer, &get_logfile(1));
 
@@ -107,8 +107,8 @@ ifile: no-such-file; @false
 ',
               '-k',
               "#MAKEFILE#:2: ifile: No such file or directory
-#MAKE#: *** No rule to make target `no-such-file', needed by `ifile'.
-#MAKE#: Failed to remake makefile `ifile'.
+#MAKE#: *** No rule to make target 'no-such-file', needed by 'ifile'.
+#MAKE#: Failed to remake makefile 'ifile'.
 hi\n",
               512);
 
diff --git a/tests/scripts/options/dash-n b/tests/scripts/options/dash-n
index 248e0c8..1953909 100644
--- a/tests/scripts/options/dash-n
+++ b/tests/scripts/options/dash-n
@@ -56,13 +56,13 @@ close(MAKEFILE);
 # TEST 2
 
 &run_make_with_options($makefile2, "", &get_logfile);
-$answer = "$make_name: `a' is up to date.\n";
+$answer = "$make_name: 'a' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 # TEST 3
 
 &run_make_with_options($makefile2, "-n", &get_logfile);
-$answer = "$make_name: `a' is up to date.\n";
+$answer = "$make_name: 'a' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 # TEST 4
diff --git a/tests/scripts/options/symlinks b/tests/scripts/options/symlinks
index 40d2564..a1bfce0 100644
--- a/tests/scripts/options/symlinks
+++ b/tests/scripts/options/symlinks
@@ -26,7 +26,7 @@ if ($port_type eq 'W32' || !( eval { symlink("",""); 1 })) {
   # Without -L, nothing should happen
   # With -L, it should update targ
   run_make_test('targ: sym ; @echo make $@ from $<', '',
-                "#MAKE#: `targ' is up to date.");
+                "#MAKE#: 'targ' is up to date.");
   run_make_test(undef, '-L', "make targ from sym");
 
   # Now update dep; in all cases targ should be out of date.
@@ -36,8 +36,8 @@ if ($port_type eq 'W32' || !( eval { symlink("",""); 1 })) {
 
   # Now update targ; in all cases targ should be up to date.
   &touch('targ');
-  run_make_test(undef, '', "#MAKE#: `targ' is up to date.");
-  run_make_test(undef, '-L', "#MAKE#: `targ' is up to date.");
+  run_make_test(undef, '', "#MAKE#: 'targ' is up to date.");
+  run_make_test(undef, '-L', "#MAKE#: 'targ' is up to date.");
 
   # Add in a new link between sym and dep.  Be sure it's newer than targ.
   sleep(1);
@@ -46,7 +46,7 @@ if ($port_type eq 'W32' || !( eval { symlink("",""); 1 })) {
 
   # Without -L, nothing should happen
   # With -L, it should update targ
-  run_make_test(undef, '', "#MAKE#: `targ' is up to date.");
+  run_make_test(undef, '', "#MAKE#: 'targ' is up to date.");
   run_make_test(undef, '-L', "make targ from sym");
 
   rmfiles('targ', 'dep', 'sym', 'dep1');
@@ -56,7 +56,7 @@ if ($port_type eq 'W32' || !( eval { symlink("",""); 1 })) {
 
   symlink("../$dirname/dep", 'sym');
   run_make_test('targ: sym ; @echo make $@ from $<', '',
-                "#MAKE#: *** No rule to make target `sym', needed by `targ'.  Stop.", 512);
+                "#MAKE#: *** No rule to make target 'sym', needed by 'targ'.  Stop.", 512);
 
   run_make_test('targ: sym ; @echo make $@ from $<', '-L',
                 'make targ from sym');
diff --git a/tests/scripts/options/warn-undefined-variables b/tests/scripts/options/warn-undefined-variables
index 34bfaea..ce15507 100644
--- a/tests/scripts/options/warn-undefined-variables
+++ b/tests/scripts/options/warn-undefined-variables
@@ -18,8 +18,8 @@ all: ; @echo ref $(EREF) $(UREF)',
 
 # With --warn-undefined-variables, it should warn me
 run_make_test(undef, '--warn-undefined-variables',
-              "#MAKEFILE#:7: warning: undefined variable `UNDEFINED'
-#MAKEFILE#:9: warning: undefined variable `UNDEFINED'
+              "#MAKEFILE#:7: warning: undefined variable 'UNDEFINED'
+#MAKEFILE#:9: warning: undefined variable 'UNDEFINED'
 ref");
 
 1;
diff --git a/tests/scripts/targets/DEFAULT b/tests/scripts/targets/DEFAULT
index 0cabde9..f3d5148 100644
--- a/tests/scripts/targets/DEFAULT
+++ b/tests/scripts/targets/DEFAULT
@@ -35,9 +35,9 @@ close(MAKEFILE);
 &run_make_with_options($makefile,'bar',&get_logfile);
 
 # Create the answer to what should be produced by this Makefile
-$answer = "${make_name}[1]: Entering directory `$pwd'\n"
+$answer = "${make_name}[1]: Entering directory '$pwd'\n"
         . "Executing rule BAR\n"
-        . "${make_name}[1]: Leaving directory `$pwd'\n";
+        . "${make_name}[1]: Leaving directory '$pwd'\n";
 
 # COMPARE RESULTS
 
diff --git a/tests/scripts/targets/INTERMEDIATE b/tests/scripts/targets/INTERMEDIATE
index 4fdd7a2..2b3021b 100644
--- a/tests/scripts/targets/INTERMEDIATE
+++ b/tests/scripts/targets/INTERMEDIATE
@@ -42,7 +42,7 @@ $answer = "cp foo.f foo.e\ncp foo.e foo.d\nrm foo.e\n";
 # TEST #1
 
 &run_make_with_options($makefile,'foo.d',&get_logfile);
-$answer = "$make_name: `foo.d' is up to date.\n";
+$answer = "$make_name: 'foo.d' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 # TEST #2
@@ -63,7 +63,7 @@ $answer = "cp foo.f foo.e\ncp bar.f bar.e\ncat foo.e bar.e > foo.c\nrm bar.e foo
 # TEST #4
 
 &run_make_with_options($makefile,'foo.c',&get_logfile);
-$answer = "$make_name: `foo.c' is up to date.\n";
+$answer = "$make_name: 'foo.c' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 # TEST #5
diff --git a/tests/scripts/targets/POSIX b/tests/scripts/targets/POSIX
index 5f854be..35c59b1 100644
--- a/tests/scripts/targets/POSIX
+++ b/tests/scripts/targets/POSIX
@@ -17,7 +17,7 @@ run_make_test(qq!
 .POSIX:
 all: ; \@$script
 !,
-              '', "#MAKEFILE#:3: recipe for target `all' failed
+              '', "#MAKEFILE#:3: recipe for target 'all' failed
 #MAKE#: *** [all] Error $err\n", 512);
 
 # User settings must override .POSIX
diff --git a/tests/scripts/targets/SECONDARY b/tests/scripts/targets/SECONDARY
index 26515d8..447c275 100644
--- a/tests/scripts/targets/SECONDARY
+++ b/tests/scripts/targets/SECONDARY
@@ -44,7 +44,7 @@ $answer = "cp foo.f foo.e\ncp foo.e foo.d\n";
 unlink('foo.e');
 
 &run_make_with_options($makefile,'foo.d',&get_logfile);
-$answer = "$make_name: `foo.d' is up to date.\n";
+$answer = "$make_name: 'foo.d' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 # TEST #3
@@ -67,7 +67,7 @@ $answer = "cp foo.e foo.c\n";
 unlink('foo.e');
 
 &run_make_with_options($makefile,'foo.c',&get_logfile);
-$answer = "$make_name: `foo.c' is up to date.\n";
+$answer = "$make_name: 'foo.c' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 # TEST #6
@@ -103,7 +103,7 @@ close(MAKEFILE);
 touch('final');
 
 &run_make_with_options($makefile2, '', &get_logfile);
-$answer = "$make_name: `final' is up to date.\n";
+$answer = "$make_name: 'final' is up to date.\n";
 &compare_output($answer, &get_logfile(1));
 
 unlink('source', 'final', 'intermediate');
diff --git a/tests/scripts/variables/DEFAULT_GOAL b/tests/scripts/variables/DEFAULT_GOAL
index 1c06506..8188ce7 100644
--- a/tests/scripts/variables/DEFAULT_GOAL
+++ b/tests/scripts/variables/DEFAULT_GOAL
@@ -42,7 +42,7 @@ run_make_test('
 .DEFAULT_GOAL = foo
 ',
 '',
-'#MAKE#: *** No rule to make target `foo\'.  Stop.',
+"#MAKE#: *** No rule to make target 'foo'.  Stop.",
 512);
 
 
diff --git a/tests/scripts/variables/LIBPATTERNS b/tests/scripts/variables/LIBPATTERNS
index 826f2fa..9182954 100644
--- a/tests/scripts/variables/LIBPATTERNS
+++ b/tests/scripts/variables/LIBPATTERNS
@@ -20,7 +20,7 @@ run_make_test('
 .LIBPATTERNS = mtest_foo.a mtest_%.a
 all: -lfoo ; @echo "build $@ from $<"
 ',
-              '', "#MAKE#: .LIBPATTERNS element `mtest_foo.a' is not a pattern
+              '', "#MAKE#: .LIBPATTERNS element 'mtest_foo.a' is not a pattern
 build all from mtest_foo.a\n");
 
 # TEST 2: target-specific override
diff --git a/tests/scripts/variables/MAKE b/tests/scripts/variables/MAKE
index d1081da..dc62160 100644
--- a/tests/scripts/variables/MAKE
+++ b/tests/scripts/variables/MAKE
@@ -16,8 +16,8 @@ foo:
 !,
               '',
               "#MAKEPATH#\n#MAKEPATH# -f #MAKEFILE# foo\n"
-              . "#MAKE#[1]: Entering directory `#PWD#'\n"
-              . "#MAKEPATH#\n#MAKE#[1]: Leaving directory `#PWD#'\n");
+              . "#MAKE#[1]: Entering directory '#PWD#'\n"
+              . "#MAKEPATH#\n#MAKE#[1]: Leaving directory '#PWD#'\n");
 
 rmfiles("foo");
 
diff --git a/tests/scripts/variables/MAKE_RESTARTS b/tests/scripts/variables/MAKE_RESTARTS
index 53ab738..711c627 100644
--- a/tests/scripts/variables/MAKE_RESTARTS
+++ b/tests/scripts/variables/MAKE_RESTARTS
@@ -53,9 +53,9 @@ foo.x:1: bar.x: No such file or directory
 MAKE_RESTARTS=2
 recurse MAKE_RESTARTS=
 MAKE_RESTARTS=
-#MAKE#[1]: Entering directory `#PWD#'
+#MAKE#[1]: Entering directory '#PWD#'
 all MAKE_RESTARTS=
-#MAKE#[1]: Leaving directory `#PWD#'");
+#MAKE#[1]: Leaving directory '#PWD#'");
 
 rmfiles('foo.x', 'bar.x');
 
diff --git a/tests/scripts/variables/SHELL b/tests/scripts/variables/SHELL
index 3d49349..4c73890 100644
--- a/tests/scripts/variables/SHELL
+++ b/tests/scripts/variables/SHELL
@@ -89,7 +89,7 @@ run_make_test(qq!
 .SHELLFLAGS = $flags
 all: ; \@$script
 !,
-              '', "$out#MAKEFILE#:3: recipe for target `all' failed
+              '', "$out#MAKEFILE#:3: recipe for target 'all' failed
 #MAKE#: *** [all] Error $err\n", 512);
 
 1;
diff --git a/tests/scripts/variables/define b/tests/scripts/variables/define
index 68d493b..7324cbc 100644
--- a/tests/scripts/variables/define
+++ b/tests/scripts/variables/define
@@ -160,7 +160,7 @@ ouch
 endef
 all: ; @echo ok
 ',
-              '', "#MAKEFILE#:3: extraneous text after `define' directive\nok\n");
+              '', "#MAKEFILE#:3: extraneous text after 'define' directive\nok\n");
 
 # TEST 7: NEGATIVE: extra text after endef
 
@@ -171,7 +171,7 @@ ouch
 endef $(NAME)
 all: ; @echo ok
 ',
-              '', "#MAKEFILE#:5: extraneous text after `endef' directive\nok\n");
+              '', "#MAKEFILE#:5: extraneous text after 'endef' directive\nok\n");
 
 # TEST 8: NEGATIVE: missing endef
 
@@ -182,7 +182,7 @@ define NAME =
 ouch
 endef$(NAME)
 ',
-              '', "#MAKEFILE#:4: *** missing `endef', unterminated `define'.  Stop.\n", 512);
+              '', "#MAKEFILE#:4: *** missing 'endef', unterminated 'define'.  Stop.\n", 512);
 
 # -------------------------
 # Make sure that prefix characters apply properly to define/endef values.
diff --git a/tests/test_driver.pl b/tests/test_driver.pl
index 4ec3a11..30d2ab7 100644
--- a/tests/test_driver.pl
+++ b/tests/test_driver.pl
@@ -132,7 +132,7 @@ sub toplevel
 
   &parse_command_line (@ARGV);
 
-  print "OS name = `$osname'\n" if $debug;
+  print "OS name = '$osname'\n" if $debug;
 
   $workpath = "$cwdslash$workdir";
   $scriptpath = "$cwdslash$scriptdir";
diff --git a/variable.c b/variable.c
index 839aa5a..5a9d4d2 100644
--- a/variable.c
+++ b/variable.c
@@ -412,7 +412,7 @@ lookup_special_var (struct variable *var)
 
 /* Lookup a variable whose name is a string starting at NAME
    and with LENGTH chars.  NAME need not be null-terminated.
-   Returns address of the `struct variable' containing all info
+   Returns address of the 'struct variable' containing all info
    on the variable, or nil if no such variable is defined.  */
 
 struct variable *
@@ -499,7 +499,7 @@ lookup_variable (const char *name, unsigned int length)
 
 /* Lookup a variable whose name is a string starting at NAME
    and with LENGTH chars in set SET.  NAME need not be null-terminated.
-   Returns address of the `struct variable' containing all info
+   Returns address of the 'struct variable' containing all info
    on the variable, or nil if no such variable is defined.  */
 
 struct variable *
@@ -954,7 +954,7 @@ define_automatic_variables (void)
 int export_all_variables;
 
 /* Create a new environment for FILE's commands.
-   If FILE is nil, this is for the `shell' function.
+   If FILE is nil, this is for the 'shell' function.
    The child's MAKELEVEL variable is incremented.  */
 
 char **
@@ -1250,7 +1250,7 @@ do_variable_definition (const struct floc *flocp, const char *varname,
 #ifdef __MSDOS__
   /* Many Unix Makefiles include a line saying "SHELL=/bin/sh", but
      non-Unix systems don't conform to this default configuration (in
-     fact, most of them don't even have `/bin').  On the other hand,
+     fact, most of them don't even have '/bin').  On the other hand,
      $SHELL in the environment, if set, points to the real pathname of
      the shell.
      Therefore, we generally won't let lines like "SHELL=/bin/sh" from
@@ -1536,7 +1536,7 @@ parse_variable_definition (const char *p, struct variable *var)
 
 /* Try to interpret LINE (a null-terminated string) as a variable definition.
 
-   If LINE was recognized as a variable definition, a pointer to its `struct
+   If LINE was recognized as a variable definition, a pointer to its 'struct
    variable' is returned.  If LINE is not a variable definition, NULL is
    returned.  */
 
@@ -1569,7 +1569,7 @@ assign_variable_definition (struct variable *v, char *line)
 
    See the comments for assign_variable_definition().
 
-   If LINE was recognized as a variable definition, a pointer to its `struct
+   If LINE was recognized as a variable definition, a pointer to its 'struct
    variable' is returned.  If LINE is not a variable definition, NULL is
    returned.  */
 
@@ -1626,7 +1626,7 @@ print_variable (const void *item, void *arg)
       origin = _("command line");
       break;
     case o_override:
-      origin = _("`override' directive");
+      origin = _("'override' directive");
       break;
     case o_invalid:
     default:
@@ -1637,12 +1637,12 @@ print_variable (const void *item, void *arg)
   if (v->private_var)
     fputs (" private", stdout);
   if (v->fileinfo.filenm)
-    printf (_(" (from `%s', line %lu)"),
+    printf (_(" (from '%s', line %lu)"),
             v->fileinfo.filenm, v->fileinfo.lineno);
   putchar ('\n');
   fputs (prefix, stdout);
 
-  /* Is this a `define'?  */
+  /* Is this a 'define'?  */
   if (v->recursive && strchr (v->value, '\n') != 0)
     printf ("define %s\n%s\nendef\n", v->name, v->value);
   else
diff --git a/variable.h b/variable.h
index 1fe3d1e..410c355 100644
--- a/variable.h
+++ b/variable.h
@@ -27,7 +27,7 @@ enum variable_origin
     o_file,		/* Variable given in a makefile.  */
     o_env_override,	/* Variable from environment, if -e.  */
     o_command,		/* Variable given by user.  */
-    o_override, 	/* Variable from an `override' directive.  */
+    o_override, 	/* Variable from an 'override' directive.  */
     o_automatic,	/* Automatic variable -- cannot be set.  */
     o_invalid		/* Core dump time.  */
   };
@@ -44,7 +44,7 @@ enum variable_flavor
 
 /* Structure that represents one variable definition.
    Each bucket of the hash table is a chain of these,
-   chained through `next'.  */
+   chained through 'next'.  */
 
 #define EXP_COUNT_BITS  15      /* This gets all the bitfields into 32 bits */
 #define EXP_COUNT_MAX   ((1<<EXP_COUNT_BITS)-1)
@@ -223,7 +223,7 @@ void undefine_variable_in_set (const char *name, unsigned int length,
 #define warn_undefined(n,l) do{\
                               if (warn_undefined_variables_flag) \
                                 error (reading_file, \
-                                       _("warning: undefined variable `%.*s'"), \
+                                       _("warning: undefined variable '%.*s'"), \
                                 (int)(l), (n)); \
                               }while(0)
 
diff --git a/vmsjobs.c b/vmsjobs.c
index 4b2ba08..729311e 100644
--- a/vmsjobs.c
+++ b/vmsjobs.c
@@ -181,7 +181,7 @@ vmsHandleChildTerm(struct child *child)
 	    break;
 
 	  default:
-	    error (NILF, _("internal error: `%s' command_state"),
+	    error (NILF, _("internal error: '%s' command_state"),
                    c->file->name);
 	    abort ();
 	    break;
diff --git a/vpath.c b/vpath.c
index 4e515b7..f541d6a 100644
--- a/vpath.c
+++ b/vpath.c
@@ -30,7 +30,7 @@ struct vpath
   {
     struct vpath *next;	/* Pointer to next struct in the linked list.  */
     const char *pattern;/* The pattern to match.  */
-    const char *percent;/* Pointer into `pattern' where the `%' is.  */
+    const char *percent;/* Pointer into 'pattern' where the '%' is.  */
     unsigned int patlen;/* Length of the pattern.  */
     const char **searchpath; /* Null-terminated list of directories.  */
     unsigned int maxlen;/* Maximum length of any entry in the list.  */
@@ -90,7 +90,7 @@ build_vpath_lists ()
       struct vpath *save_vpaths = vpaths;
       char gp[] = "%";
 
-      /* Empty `vpaths' so the new one will have no next, and `vpaths'
+      /* Empty 'vpaths' so the new one will have no next, and 'vpaths'
 	 will still be nil if P contains no existing directories.  */
       vpaths = 0;
 
@@ -123,7 +123,7 @@ build_vpath_lists ()
       struct vpath *save_vpaths = vpaths;
       char gp[] = "%";
 
-      /* Empty `vpaths' so the new one will have no next, and `vpaths'
+      /* Empty 'vpaths' so the new one will have no next, and 'vpaths'
 	 will still be nil if P contains no existing directories.  */
       vpaths = 0;
 
@@ -600,18 +600,18 @@ print_vpath_data_base (void)
     }
 
   if (vpaths == 0)
-    puts (_("# No `vpath' search paths."));
+    puts (_("# No 'vpath' search paths."));
   else
-    printf (_("\n# %u `vpath' search paths.\n"), nvpaths);
+    printf (_("\n# %u 'vpath' search paths.\n"), nvpaths);
 
   if (general_vpath == 0)
-    puts (_("\n# No general (`VPATH' variable) search path."));
+    puts (_("\n# No general ('VPATH' variable) search path."));
   else
     {
       const char **path = general_vpath->searchpath;
       unsigned int i;
 
-      fputs (_("\n# General (`VPATH' variable) search path:\n# "), stdout);
+      fputs (_("\n# General ('VPATH' variable) search path:\n# "), stdout);
 
       for (i = 0; path[i] != 0; ++i)
 	printf ("%s%c", path[i],
diff --git a/w32/subproc/NMakefile b/w32/subproc/NMakefile
index 50e8fe1..0f0338f 100644
--- a/w32/subproc/NMakefile
+++ b/w32/subproc/NMakefile
@@ -1,5 +1,5 @@
-# NOTE: If you have no `make' program at all to process this makefile, run
-# `build.bat' instead.
+# NOTE: If you have no 'make' program at all to process this makefile, run
+# 'build.bat' instead.
 #
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 # 2006, 2007, 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
diff --git a/w32/subproc/w32err.c b/w32/subproc/w32err.c
index 7f68f59..3063aca 100644
--- a/w32/subproc/w32err.c
+++ b/w32/subproc/w32err.c
@@ -31,7 +31,7 @@ this program.  If not, see <http://www.gnu.org/licenses/>.  */
 const char *
 map_windows32_error_to_string (DWORD ercode) {
 /*
- * We used to have an MSVC-specific `__declspec (thread)' qualifier
+ * We used to have an MSVC-specific '__declspec (thread)' qualifier
  * here, with the following comment:
  *
  * __declspec (thread) necessary if you will use multiple threads on MSVC
@@ -43,7 +43,7 @@ map_windows32_error_to_string (DWORD ercode) {
  * never used, and are now #ifdef'ed away.  Until we need more than
  * one thread, we have no problems with the following buffer being
  * static.  (If and when we do need it to be in thread-local storage,
- * the corresponding GCC qualifier is `__thread'.)
+ * the corresponding GCC qualifier is '__thread'.)
  */
     static char szMessageBuffer[128];
 	/* Fill message buffer with a default message in
-- 
cgit v1.0-41-gc330

