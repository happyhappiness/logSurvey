@@ -1576,15 +1576,10 @@ fi
 dnl Authentication libraries to build
 dnl This list will not be needed when each auth library has its own Makefile
 AUTH_LIBS_TO_BUILD=
-dnl Authentication libraries to link authenticating executables with.
-dnl These are the same as AUTH_LIBS_TO_BUILD, but with a path
-AUTH_LIBS_TO_ADD=
 for module in $AUTH_MODULES; do
-    AUTH_LIBS_TO_BUILD="$AUTH_LIBS_TO_BUILD lib${module}.a"
-    AUTH_LIBS_TO_ADD="$AUTH_LIBS_TO_ADD auth/lib${module}.a"
+    AUTH_LIBS_TO_BUILD="$AUTH_LIBS_TO_BUILD lib${module}.la"
 done
 AC_SUBST(AUTH_MODULES)
-AC_SUBST(AUTH_LIBS_TO_ADD)
 AC_SUBST(AUTH_LIBS_TO_BUILD)
 
 dnl bundled auth modules, in order to have handy defines for the cppunit testsuite
@@ -3806,6 +3801,7 @@ AC_CONFIG_FILES([\
 	scripts/RunAccel \
 	src/Makefile \
 	src/base/Makefile \
+	src/acl/Makefile \
 	src/fs/Makefile \
 	src/repl/Makefile \
 	src/auth/Makefile \
@@ -1,41 +0,0 @@
-/*
- * $Id$
- *
- * DEBUG: section 28    Access Control
- * AUTHOR: Henrik Nordstrom
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-bool
-ACLChecklist::matchAclListFast(const ACLList * list)
-{
-    matchAclList(list, true);
-    return finished();
-}
-
@@ -49,8 +49,8 @@
 #include "StoreClient.h"
 #include "MemObject.h"
 #include "client_side_request.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/Checklist.h"
+#include "acl/Acl.h"
 #include "ConfigParser.h"
 #include "DelayId.h"
 #include "Array.h"
@@ -46,7 +46,8 @@
 #include "DelayPools.h"
 #include "DelayPool.h"
 #include "Store.h"
-#include "ACL.h"
+#include "acl/Acl.h"
+#include "acl/Gadgets.h"
 
 void
 DelayConfig::parsePoolCount()
@@ -47,7 +47,7 @@
 #include "squid.h"
 #include "DelayId.h"
 #include "client_side_request.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "DelayPools.h"
 #include "DelayPool.h"
 #include "HttpRequest.h"
@@ -114,7 +114,7 @@ DelayId::DelayClient(ClientHttpRequest * http)
             continue;
         }
 
-        ACLChecklist ch;
+        ACLFilledChecklist ch(DelayPools::delay_data[pool].access, r, NULL);
 #if FOLLOW_X_FORWARDED_FOR
         if (Config.onoff.delay_pool_uses_indirect_client)
             ch.src_addr = r->indirect_client_addr;
@@ -126,12 +126,6 @@ DelayId::DelayClient(ClientHttpRequest * http)
         if (http->getConn() != NULL)
             ch.conn(http->getConn());
 
-        ch.request = HTTPMSGLOCK(r);
-
-        ch.accessList = cbdataReference(DelayPools::delay_data[pool].access);
-
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
-
         if (DelayPools::delay_data[pool].theComposite().getRaw() && ch.fastCheck()) {
 
             DelayId result (pool + 1);
@@ -41,7 +41,8 @@
 #if DELAY_POOLS
 #include "DelayPool.h"
 #include "CommonPool.h"
-#include "ACL.h"
+#include "acl/Acl.h"
+#include "acl/Gadgets.h"
 #include "Store.h"
 
 DelayPool::DelayPool() : pool (NULL), access (NULL)
@@ -40,7 +40,6 @@
 #if DELAY_POOLS
 #include "squid.h"
 #include "DelayTagged.h"
-#include "authenticate.h"
 #include "NullDelayId.h"
 #include "Store.h"
 
@@ -41,7 +41,7 @@
 #if DELAY_POOLS
 
 #include "squid.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "CompositePoolNode.h"
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
@@ -41,7 +41,7 @@
 #if DELAY_POOLS
 
 #include "squid.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "CompositePoolNode.h"
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
@@ -34,7 +34,7 @@
 #ifndef SQUID_EXTERNALACL_H
 #define SQUID_EXTERNALACL_H
 
-#include "ACLChecklist.h"
+#include "acl/Checklist.h"
 
 class external_acl;
 
@@ -53,7 +53,7 @@ class ExternalACLLookup : public ACLChecklist::AsyncState
 /** \todo CLEANUP: kill this typedef. */
 typedef struct _external_acl_data external_acl_data;
 
-#include "ACL.h"
+#include "acl/Acl.h"
 
 class ACLExternal : public ACL
 {
@@ -36,7 +36,7 @@
 #include "squid.h"
 #include "HttpHeader.h"
 #include "HttpHdrContRange.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "MemBuf.h"
 
 static void httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs);
@@ -372,7 +372,6 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
 
     /* check with anonymizer tables */
     header_mangler *hm;
-    ACLChecklist *checklist;
     assert(e);
 
     if (ROR_REQUEST == req_or_rep) {
@@ -389,9 +388,9 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
         return 1;
     }
 
-    checklist = aclChecklistCreate(hm->access_list, request, NULL);
+    ACLFilledChecklist checklist(hm->access_list, request, NULL);
 
-    if (checklist->fastCheck()) {
+    if (checklist.fastCheck()) {
         /* aclCheckFast returns true for allow. */
         retval = 1;
     } else if (NULL == hm->replacement) {
@@ -406,7 +405,6 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
         retval = 1;
     }
 
-    delete checklist;
     return retval;
 }
 
@@ -39,7 +39,7 @@
 #include "HttpReply.h"
 #include "HttpHdrContRange.h"
 #include "HttpHdrSc.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 
@@ -538,11 +538,10 @@ HttpReply::calcMaxBodySize(HttpRequest& request)
         return;
     bodySizeMax = -1;
 
-    ACLChecklist ch;
+    ACLFilledChecklist ch(NULL, &request, NULL);
     ch.src_addr = request.client_addr;
     ch.my_addr = request.my_addr;
     ch.reply = HTTPMSGLOCK(this); // XXX: this lock makes method non-const
-    ch.request = HTTPMSGLOCK(&request);
     for (acl_size_t *l = Config.ReplyBodySize; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this size value */
         if (!l->aclList || ch.matchAclListFast(l->aclList)) {
@@ -32,7 +32,7 @@ LOADABLE_MODULES_SOURCES = \
 TESTS=$(check_PROGRAMS)
 check_PROGRAMS=
 
-SUBDIRS	= base fs repl auth ip icmp
+SUBDIRS	= base acl fs repl auth ip icmp
 
 if USE_ADAPTATION
 SUBDIRS += adaptation
@@ -132,14 +132,6 @@ UNLINKD =
 endif
 
 SSL_ALL_SOURCE = \
-	ACLCertificateData.cc \
-	ACLCertificateData.h  \
-	ACLCertificate.cc \
-	ACLCertificate.h  \
-	ACLSslError.cc \
-	ACLSslError.h \
-	ACLSslErrorData.cc \
-	ACLSslErrorData.h \
 	ssl_support.cc \
 	ssl_support.h
 
@@ -181,20 +173,13 @@ else
 AIOPS_SOURCE = DiskIO/DiskThreads/aiops.cc
 endif
 
-IDENT_ALL_SOURCE = ACLIdent.cc ACLIdent.h ident.cc ident.h
+IDENT_ALL_SOURCE = ident.cc ident.h
 if ENABLE_IDENT
 IDENT_SOURCE = $(IDENT_ALL_SOURCE)
 else
 IDENT_SOURCE =
 endif
 
-ARP_ACL_ALL_SOURCE = ACLARP.cc ACLARP.h
-if ENABLE_ARP_ACL
-ARP_ACL_SOURCE = $(ARP_ACL_ALL_SOURCE)
-else
-ARP_ACL_SOURCE =
-endif
-
 AM_CFLAGS = @SQUID_CFLAGS@
 AM_CXXFLAGS = @SQUID_CXXFLAGS@
 
@@ -205,7 +190,11 @@ noinst_LTLIBRARIES = libsquid.la
 # libraries used by many targets
 COMMON_LIBS = \
 	libsquid.la \
-	auth/libauth.a \
+	auth/libacls.la \
+	acl/libacls.la \
+	acl/libstate.la \
+	auth/libauth.la \
+	acl/libapi.la \
 	base/libbase.la \
 	ip/libip.la
 
@@ -278,7 +267,6 @@ DiskIO/DiskIOModules_gen.cc: Makefile
 EXTRA_squid_SOURCES = \
 	$(AIO_WIN32_ALL_SOURCES) \
 	$(all_AUTHMODULES) \
-	$(ARP_ACL_ALL_SOURCE) \
 	ConfigOption.h \
 	$(DELAY_POOL_ALL_SOURCE) \
 	dns.cc \
@@ -301,89 +289,6 @@ EXTRA_squid_SOURCES = \
 	DiskIO/DiskThreads/aiops.cc \
 	DiskIO/DiskThreads/aiops_win32.cc
 
-squid_ACLSOURCES = \
-	$(ARP_ACL_SOURCE) \
-	ACLASN.cc \
-	ACLASN.h \
-	ACLDestinationASN.h \
-	ACLSourceASN.h \
-	ACLBrowser.cc \
-	ACLBrowser.h \
-	ACLData.h \
-	ACLDestinationDomain.cc \
-	ACLDestinationDomain.h \
-	ACLDestinationIP.cc \
-	ACLDestinationIP.h \
-	ACLDomainData.h \
-	ACLDomainData.cc \
-	ACLExtUser.h \
-	ACLExtUser.cc \
-	ACLHTTPHeaderData.h \
-	ACLHTTPHeaderData.cc \
-	ACLHTTPStatus.h \
-	ACLHTTPStatus.cc \
-	ACLIntRange.cc \
-	ACLIntRange.h \
-	ACLIP.cc \
-	ACLIP.h \
-	ACLMaxConnection.cc \
-	ACLMaxConnection.h \
-	ACLMaxUserIP.cc \
-	ACLMaxUserIP.h \
-	ACLMethod.cc \
-	ACLMethod.h \
-	ACLMethodData.cc \
-	ACLMethodData.h \
-	ACLMyIP.cc \
-	ACLMyIP.h \
-	ACLMyPort.cc \
-	ACLMyPort.h \
-	ACLMyPortName.cc \
-	ACLMyPortName.h \
-	ACLPeerName.cc \
-	ACLPeerName.h \
-	ACLProtocol.cc \
-	ACLProtocol.h \
-	ACLProtocolData.cc \
-	ACLProtocolData.h \
-	ACLProxyAuth.cc \
-	ACLProxyAuth.h \
-	ACLReferer.cc \
-	ACLReferer.h \
-	ACLRegexData.cc \
-	ACLRegexData.h \
-	ACLReplyHeaderStrategy.h \
-	ACLReplyMIMEType.cc \
-	ACLReplyMIMEType.h \
-	ACLHTTPRepHeader.cc \
-	ACLHTTPRepHeader.h \
-	ACLHTTPReqHeader.cc \
-	ACLHTTPReqHeader.h \
-	ACLRequestHeaderStrategy.h \
-	ACLRequestMIMEType.cc \
-	ACLRequestMIMEType.h \
-	ACLSourceDomain.cc \
-	ACLSourceDomain.h \
-	ACLSourceIP.cc \
-	ACLSourceIP.h \
-	ACLStrategised.cc \
-	ACLStrategised.h \
-	ACLStrategy.h \
-	ACLStringData.cc \
-	ACLStringData.h \
-	ACLTime.cc \
-	ACLTime.h \
-	ACLTimeData.cc \
-	ACLTimeData.h \
-	ACLUrl.cc \
-	ACLUrl.h \
-	ACLUrlPath.cc \
-	ACLUrlPath.h \
-	ACLUrlPort.cc \
-	ACLUrlPort.h \
-	ACLUserData.cc \
-	ACLUserData.h 
-
 squid_COMMSOURCES = \
 	comm_select.cc \
 	comm_select.h \
@@ -413,12 +318,6 @@ libsquid_la_SOURCES = \
 squid_SOURCES = \
 	access_log.cc \
 	AccessLogEntry.h \
-	acl.cc \
-	acl_noncore.cc \
-	ACL.h \
-	ACLChecklist.cc \
-	ACLChecklist.h \
-	$(squid_ACLSOURCES) \
 	asn.cc \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
@@ -427,8 +326,6 @@ squid_SOURCES = \
 	AsyncJobCalls.h \
 	AsyncEngine.cc \
 	AsyncEngine.h \
-	authenticate.cc \
-	authenticate.h \
 	cache_cf.cc \
 	ProtoPort.cc \
 	ProtoPort.h \
@@ -472,6 +369,7 @@ squid_SOURCES = \
 	$(DNSSOURCE) \
 	enums.h \
 	errorpage.cc \
+	errorpage.h \
 	$(ESI_SOURCE) \
 	ETag.cc \
 	event.cc \
@@ -637,7 +535,7 @@ squid_SOURCES = \
 	$(WIN32_SOURCE) \
 	$(WINSVC_SOURCE)
 
-noinst_HEADERS = ACLChecklist.cci \
+noinst_HEADERS = \
 	client_side_request.cci \
 	MemBuf.cci \
 	MemBuf.h \
@@ -663,7 +561,6 @@ squid_LDADD = \
 	@REPL_OBJS@ \
 	@STORE_LIBS_TO_ADD@ \
 	@DISK_LIBS@ \
-	@AUTH_LIBS_TO_ADD@ \
 	@CRYPTLIB@ \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
@@ -677,8 +574,7 @@ squid_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
 	@STORE_LIBS_TO_ADD@ \
 	@DISK_LIBS@ \
 	@DISK_LINKOBJS@ \
-	@REPL_OBJS@ \
-	@AUTH_LIBS_TO_ADD@
+	@REPL_OBJS@
 
 if USE_LOADABLE_MODULES
 squid_SOURCES += $(LOADABLE_MODULES_SOURCES)
@@ -729,162 +625,20 @@ ufsdump_SOURCES = \
 	String.cc \
 	time.cc \
 	ufsdump.cc \
-	url.cc \
-	AsyncCallQueue.cc \
-	AsyncCallQueue.h \
-	AsyncCall.cc \
-	AsyncCall.h \
-	BodyPipe.cc \
-	BodyPipe.h \
-	ConfigParser.cc \
-	store.cc \
-	StoreFileSystem.cc \
-	StoreSwapLogData.cc \
-	StoreSwapLogData.h \
-	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLUserData.cc \
-	ACLRegexData.cc \
-	ACLStringData.cc \
-	authenticate.cc \
-	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
-	cache_manager.cc \
-	CacheDigest.cc \
-	carp.cc \
-	cbdata.cc \
-	ChunkedCodingParser.cc \
-	ChunkedCodingParser.h \
-	client_db.cc \
-	client_side.cc \
-	client_side_reply.cc \
-	client_side_request.cc \
-	client_side_request.h \
-	clientStream.cc \
-	clientStream.h \
-	CommIO.h \
-	$(squid_COMMSOURCES) \
-	ConfigOption.cc \
-	defines.h \
-	$(DELAY_POOL_SOURCE) \
-	disk.cc \
 	dlink.h \
 	dlink.cc \
-	$(DNSSOURCE) \
-	enums.h \
-	errorpage.cc \
-	errorpage.h \
-	$(ESI_SOURCE) \
-	ETag.cc \
-	event.cc \
-	external_acl.cc \
-	ExternalACLEntry.cc \
-	fd.cc \
-	fde.cc \
-	fde.h \
-	filemap.cc \
-	forward.cc \
-	forward.h \
-	fqdncache.cc \
-	ftp.cc \
-	gopher.cc \
-	helper.cc \
-	$(HTCPSOURCE) \
-	http.cc \
-	HttpStatusLine.cc \
-	HttpHdrCc.cc \
-	HttpHdrRange.cc \
-	HttpHdrSc.cc \
-	HttpHdrScTarget.cc \
-	HttpHdrContRange.cc \
-	HttpHeader.cc \
-	HttpHeaderTools.cc \
-	HttpBody.cc \
-	HttpMsg.cc \
-	HttpReply.cc \
-	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	icp_v2.cc \
-	icp_v3.cc \
-	$(IDENT_SOURCE) \
-	internal.cc \
-	$(IPC_SOURCE) \
-	ipcache.cc \
-	$(LEAKFINDERSOURCE) \
-        list.cc \
-	logfile.cc \
-	mem_node.cc \
-	mem_node.h \
-	Mem.h \
-	MemBuf.cc \
-	MemObject.cc \
-	MemObject.h \
-	mime.cc \
-	multicast.cc \
-	neighbors.cc \
-	Packer.cc \
-	Parsing.cc \
-	$(XPROF_STATS_SOURCE) \
-	pconn.cc \
-	peer_digest.cc \
-	peer_select.cc \
-	peer_sourcehash.cc \
-	peer_userhash.cc \
-	protos.h \
-	redirect.cc \
-	referer.cc \
-	refresh.cc \
 	RemovalPolicy.cc \
-	send-announce.cc \
-	$(SNMP_SOURCE) \
 	squid.h \
-	$(SSL_SOURCE) \
-	tunnel.cc \
-	Server.cc \
-	SquidNew.cc \
-	stat.cc \
-	StatHist.cc \
-	stmem.cc \
-	store_io.cc \
-	StoreIOBuffer.h \
-	StoreIOState.cc \
-	store_client.cc \
-	StoreClient.h \
-	store_digest.cc \
-	store_dir.cc \
-	store_log.cc \
-	store_rebuild.cc \
-	store_swapin.cc \
-	store_swapmeta.cc \
-	store_swapout.cc \
-	structs.h \
-	SwapDir.cc \
-	tools.cc \
-	typedefs.h \
-	$(UNLINKDSOURCE) \
-	URLScheme.cc \
-	urn.cc \
-	useragent.cc \
-	wccp.cc \
-	wccp2.cc \
-	whois.cc \
-	wordlist.cc \
 	$(WIN32_SOURCE)
 ufsdump_LDADD = \
 	$(COMMON_LIBS) \
-	icmp/libicmp.la icmp/libicmp-core.la \
 	@XTRA_OBJS@ \
 	@REPL_OBJS@ \
 	@STORE_LIBS_TO_ADD@ \
-	@AUTH_LIBS_TO_ADD@ \
 	@CRYPTLIB@ \
 	@REGEXLIB@ \
 	@SNMPLIB@ \
-	${ADAPTATION_LIBS} \
 	@SSLLIB@ \
 	-L$(top_builddir)/lib -lmiscutil \
 	@XTRA_LIBS@ \
@@ -894,14 +648,10 @@ ufsdump_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
 	@STORE_LIBS_TO_ADD@ \
 	@DISK_LIBS@ \
 	@DISK_LINKOBJS@ \
-	@REPL_OBJS@ \
-	@AUTH_LIBS_TO_ADD@
+	@REPL_OBJS@
 
 nodist_ufsdump_SOURCES = \
-	repl_modules.cc \
-	cf_parser.h \
-	globals.cc \
-	string_arrays.c
+	globals.cc
 
 BUILT_SOURCES = \
 	cf_gen_defines.h \
@@ -1163,13 +913,12 @@ CLEANFILES += testHeaders.c
 
 tests_testAuth_SOURCES = \
 	tests/testAuth.cc tests/testMain.cc  tests/testAuth.h \
-	authenticate.cc \
 	ConfigParser.cc \
 	tests/stub_acl.cc tests/stub_cache_cf.cc \
 	tests/stub_helper.cc cbdata.cc String.cc \
-	tests/stub_store.cc HttpHeaderTools.cc HttpHeader.cc acl.cc mem.cc \
-	MemBuf.cc HttpHdrContRange.cc Packer.cc ACLChecklist.cc HttpHdrCc.cc HttpHdrSc.cc \
-	HttpHdrScTarget.cc url.cc ACLProxyAuth.cc ACLRegexData.cc ACLUserData.cc \
+	tests/stub_store.cc HttpHeaderTools.cc HttpHeader.cc mem.cc \
+	MemBuf.cc HttpHdrContRange.cc Packer.cc HttpHdrCc.cc HttpHdrSc.cc \
+	HttpHdrScTarget.cc url.cc \
 	StatHist.cc HttpHdrRange.cc ETag.cc tests/stub_errorpage.cc \
 	tests/stub_HttpRequest.cc tests/stub_DelayId.cc \
 	tests/stub_MemObject.cc mem_node.cc \
@@ -1194,22 +943,19 @@ nodist_tests_testAuth_SOURCES = \
 
 tests_testAuth_LDADD= \
 	$(COMMON_LIBS) \
-	@AUTH_LIBS_TO_ADD@ \
 	-L../lib -lmiscutil \
 	@REGEXLIB@ \
 	@SQUID_CPPUNIT_LIBS@ \
 	@SSLLIB@
 tests_testAuth_LDFLAGS = $(LIBADD_DL)
 tests_testAuth_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
-	@AUTH_LIBS_TO_ADD@ \
 	@SQUID_CPPUNIT_LA@
 
 ## Tests for the ACLMaxUserIP class
 ## acl needs wordlist. wordlist needs MemBug
 ## MemBuf needs mem, MemBuf needs event,
 ## event needs cbdata.
-## ACLMaxUserUP needs authenticate.cc
-## authenticate.cc needs libauth.la
+## ACLMaxUserUP needs libauth.la
 ## ACLMaxUserIP needs ACLChecklist
 ## AuthUser request needs HttpHeader, which brings in 
 ##	ETag.cc \
@@ -1224,13 +970,6 @@ tests_testAuth_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
 ##	StatHist.cc \
 ##	String.cc \
 tests_testACLMaxUserIP_SOURCES= \
-	acl.cc \
-	ACLChecklist.cc \
-	ACLMaxUserIP.cc \
-	ACLProxyAuth.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	cbdata.cc \
 	ConfigParser.cc \
 	ETag.cc \
@@ -1302,14 +1041,6 @@ tests_testCacheManager_SOURCES = \
 	tests/testMain.cc \
 	time.cc \
 	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLStringData.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
@@ -1452,10 +1183,11 @@ tests_testDiskIO_SOURCES = \
 nodist_tests_testDiskIO_SOURCES= \
 	$(SWAP_TEST_GEN_SOURCES)
 tests_testDiskIO_LDADD = \
-	$(COMMON_LIBS) \
-	@DISK_LIBS@ \
 	$(SWAP_TEST_LDADD) \
+	@DISK_LIBS@ \
+	$(COMMON_LIBS) \
 	SquidConfig.o
+
 tests_testDiskIO_LDFLAGS = $(LIBADD_DL)
 tests_testDiskIO_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
 	@DISK_LIBS@ \
@@ -1478,14 +1210,6 @@ tests_testEvent_SOURCES = \
 	tests/testMain.cc \
 	time.cc \
 	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLStringData.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
@@ -1633,14 +1357,6 @@ tests_testEventLoop_SOURCES = \
 	tests/testMain.cc \
 	time.cc \
 	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLStringData.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
@@ -1776,14 +1492,6 @@ tests_testEventLoop_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 tests_test_http_range_SOURCES = \
 	tests/test_http_range.cc \
 	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLStringData.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	BodyPipe.cc \
 	cache_cf.cc \
 	ProtoPort.cc \
@@ -1938,14 +1646,6 @@ tests_testHttpRequest_SOURCES = \
 	tests/testMain.cc \
 	time.cc \
 	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLStringData.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
@@ -2097,7 +1797,6 @@ STORE_TEST_SOURCES=\
 	Parsing.cc \
 	ConfigOption.cc \
 	SwapDir.cc \
-	authenticate.cc \
 	tests/stub_acl.cc tests/stub_cache_cf.cc \
 	tests/stub_helper.cc cbdata.cc String.cc \
 	tests/stub_comm.cc \
@@ -2106,10 +1805,9 @@ STORE_TEST_SOURCES=\
 	mem_node.cc \
 	stmem.cc \
 	tests/stub_mime.cc \
-	HttpHeaderTools.cc HttpHeader.cc acl.cc mem.cc \
-	acl_noncore.cc \
-	MemBuf.cc HttpHdrContRange.cc Packer.cc ACLChecklist.cc HttpHdrCc.cc HttpHdrSc.cc \
-	HttpHdrScTarget.cc url.cc ACLProxyAuth.cc ACLRegexData.cc ACLUserData.cc \
+	HttpHeaderTools.cc HttpHeader.cc mem.cc \
+	MemBuf.cc HttpHdrContRange.cc Packer.cc HttpHdrCc.cc HttpHdrSc.cc \
+	HttpHdrScTarget.cc url.cc \
 	StatHist.cc HttpHdrRange.cc ETag.cc tests/stub_errorpage.cc \
 	tests/stub_HttpRequest.cc tests/stub_access_log.cc \
 	refresh.cc \
@@ -2223,6 +1921,7 @@ SWAP_TEST_LDADD = \
 	@REPL_OBJS@ \
 	@DISK_LIBS@ \
 	-L../lib -lmiscutil \
+	acl/libapi.la \
 	@SQUID_CPPUNIT_LIBS@
 SWAP_TEST_DS =\
 	$(top_builddir)/lib/libmiscutil.a \
@@ -2241,8 +1940,8 @@ tests_testUfs_SOURCES = \
 nodist_tests_testUfs_SOURCES = \
 	$(SWAP_TEST_GEN_SOURCES)
 tests_testUfs_LDADD = \
-	$(COMMON_LIBS) \
 	$(SWAP_TEST_LDADD) \
+	$(COMMON_LIBS) \
 	@SSLLIB@
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
 tests_testUfs_DEPENDENCIES = \
@@ -2296,14 +1995,6 @@ tests_testURL_SOURCES = \
 	tests/testMain.cc \
 	time.cc \
 	access_log.cc \
-	acl.cc \
-	acl_noncore.cc \
-	ACLChecklist.cc \
-	ACLProxyAuth.cc \
-	ACLStringData.cc \
-	ACLRegexData.cc \
-	ACLUserData.cc \
-	authenticate.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
@@ -39,7 +39,7 @@
 // Store.h Required by configuration directives parsing/dumping only
 #include "Store.h"
 
-#include "ACLChecklist.h"
+#include "acl/Checklist.h"
 
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -33,12 +33,10 @@
  */
 #include "config.h"
 
-#include "ACL.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
 #include "ConfigParser.h"
 #include "dlink.h"
-/* for special-case PURGE test */
-#include "HttpRequestMethod.h"
 
 const char *AclMatchedName = NULL;
 
@@ -278,12 +276,12 @@ ACL::checklistMatches(ACLChecklist *checklist)
 {
     int rv;
 
-    if (NULL == checklist->request && requiresRequest()) {
+    if (!checklist->hasRequest() && requiresRequest()) {
         debugs(28, 1, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP request -- not matching.");
         return 0;
     }
 
-    if (NULL == checklist->reply && requiresReply()) {
+    if (!checklist->hasReply() && requiresReply()) {
         debugs(28, 1, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP reply -- not matching.");
         return 0;
     }
@@ -321,35 +319,6 @@ ACL::~ACL()
     safe_free(cfgline);
 }
 
-#include "ACLStrategised.h"
-bool
-acl_access::containsPURGE() const
-{
-    acl_access const *a = this;
-    ACLList *b;
-
-    debugs(28, 6, "acl_access::containsPURGE: invoked for '" << cfgline << "'");
-
-    for (; a; a = a->next) {
-        for (b = a->aclList; b; b = b->next) {
-            ACLStrategised<HttpRequestMethod> *tempAcl = dynamic_cast<ACLStrategised<HttpRequestMethod> *>(b->_acl);
-
-            if (!tempAcl) {
-                debugs(28, 7, "acl_access::containsPURGE: can't create tempAcl");
-                continue;
-            }
-
-            if (tempAcl->match(METHOD_PURGE)) {
-                debugs(28, 6, "acl_access::containsPURGE:   returning true");
-                return true;
-            }
-        }
-    }
-
-    debugs(28, 6, "acl_access::containsPURGE:   returning false");
-    return false;
-}
-
 /* to be split into separate files in the future */
 
 CBDATA_CLASS_INIT(acl_access);
@@ -38,46 +38,9 @@
 #include "Array.h"
 #include "cbdata.h"
 #include "dlink.h"
-/**
- \todo FIXME: finish splitting out the dependencies here
- *	- typedefs should not be needed to parse this.
- */
-#include "typedefs.h"
 
 class ConfigParser;
-
-/* acl.c */
-
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclDestroyAccessList(acl_access **list);
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclDestroyAcls(ACL **);
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclDestroyAclList(ACLList **);
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclParseAccessLine(ConfigParser &parser, acl_access **);
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclParseAclList(ConfigParser &parser, ACLList **);
-/// \ingroup ACLAPI
-SQUIDCEXTERN int aclIsProxyAuth(const char *name);
-/// \ingroup ACLAPI
-SQUIDCEXTERN err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed);
-
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclParseDenyInfoLine(struct acl_deny_info_list **);
-
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclDestroyDenyInfoList(struct acl_deny_info_list **);
-/// \ingroup ACLAPI
-SQUIDCEXTERN wordlist *aclDumpGeneric(const ACL *);
-/// \ingroup ACLAPI
-SQUIDCEXTERN void aclCacheMatchFlush(dlink_list * cache);
-/// \ingroup ACLAPI
-extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
-/// \ingroup ACLAPI
-int aclPurgeMethodInUse(acl_access * a);
-/// \ingroup ACLAPI
-extern const char *AclMatchedName;	/* NULL */
+class ACLChecklist;
 
 /// \ingroup ACLAPI
 class ACL
@@ -154,7 +117,6 @@ class acl_access
 public:
     void *operator new(size_t);
     void operator delete(void *);
-    bool containsPURGE() const;
     allow_t allow;
     ACLList *aclList;
     char *cfgline;
@@ -194,4 +156,8 @@ class acl_proxy_auth_match_cache
 
 MEMPROXY_CLASS_INLINE(acl_proxy_auth_match_cache);
 
+
+/// \ingroup ACLAPI
+extern const char *AclMatchedName;	/* NULL */
+
 #endif /* SQUID_ACL_H */
@@ -73,7 +73,8 @@ struct arpreq {
 #endif
 #endif
 
-#include "ACLARP.h"
+#include "acl/Arp.h"
+#include "acl/FilledChecklist.h"
 #include "wordlist.h"
 
 #if !USE_ARP_ACL
@@ -224,8 +225,10 @@ aclParseArpList(SplayNode<acl_arp_data *> **curlist)
 }
 
 int
-ACLARP::match(ACLChecklist *checklist)
+ACLARP::match(ACLChecklist *cl)
 {
+	ACLFilledChecklist *checklist = Filled(cl);
+
     /* IPv6 does not do ARP */
     if (!checklist->src_addr.IsIPv4()) {
         debugs(14, 3, "ACLARP::match: IPv4 Required for ARP Lookups. Skipping " << checklist->src_addr );
@@ -35,8 +35,8 @@
 #ifndef SQUID_ACLARP_H
 #define SQUID_ACLARP_H
 
-#include "ACL.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
 #include "splay.h"
 
 /// \ingroup ACLAPI
@@ -34,6 +34,6 @@
  */
 
 #include "squid.h"
-#include "ACLASN.h"
-#include "ACLChecklist.h"
+#include "acl/Asn.h"
+#include "acl/Checklist.h"
 
@@ -32,10 +32,10 @@
 #ifndef SQUID_ACLASN_H
 #define SQUID_ACLASN_H
 
-#include "ACLData.h"
+#include "acl/Data.h"
 #include "CbDataList.h"
-#include "ACLStrategised.h"
-#include "ACLChecklist.h"
+#include "acl/Strategised.h"
+#include "acl/Checklist.h"
 #include "ip/IpAddress.h"
 
 SQUIDCEXTERN int asnMatchIp(CbDataList<int> *, IpAddress &);
@@ -35,9 +35,9 @@
  */
 
 #include "squid.h"
-#include "ACLChecklist.h"
-#include "ACLBrowser.h"
-#include "ACLRegexData.h"
+#include "acl/Checklist.h"
+#include "acl/Browser.h"
+#include "acl/RegexData.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -35,10 +35,10 @@
 #ifndef SQUID_ACLBROWSER_H
 #define SQUID_ACLBROWSER_H
 
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLRequestHeaderStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/RequestHeaderStrategy.h"
+#include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
 class ACLBrowser
@@ -41,9 +41,9 @@
  */
 #if USE_SSL
 
-#include "ACLCertificate.h"
-#include "ACLChecklist.h"
-#include "ACLCertificateData.h"
+#include "acl/Certificate.h"
+#include "acl/Checklist.h"
+#include "acl/CertificateData.h"
 #include "fde.h"
 #include "client_side.h"
 
@@ -53,7 +53,7 @@ ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEnt
 ACLStrategised<SSL *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (sslGetCAAttribute), ACLCertificateStrategy::Instance(), "ca_cert");
 
 int
-ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     const int fd = checklist->fd();
     const bool goodDescriptor = 0 <= fd && fd <= Biggest_FD;
@@ -35,18 +35,18 @@
 #ifndef SQUID_ACLCERTIFICATE_H
 #define SQUID_ACLCERTIFICATE_H
 
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Checklist.h"
 #include "ssl_support.h"
-#include "ACLStrategised.h"
+#include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
 class ACLCertificateStrategy : public ACLStrategy<SSL *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLCertificateStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -35,9 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLCertificateData.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
+#include "acl/CertificateData.h"
+#include "acl/Checklist.h"
 #include "wordlist.h"
 
 ACLCertificateData::ACLCertificateData(SSLGETATTRIBUTE *sslStrategy) : attribute (NULL), values (), sslAttributeCall (sslStrategy)
@@ -36,10 +36,10 @@
 #define SQUID_ACLCERTIFICATEDATA_H
 
 #include "splay.h"
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 #include "ssl_support.h"
-#include "ACLStringData.h"
+#include "acl/StringData.h"
 
 /// \ingroup ACLAPI
 class ACLCertificateData : public ACLData<SSL *>
@@ -34,78 +34,7 @@
  */
 
 #include "squid.h"
-#include "ACLChecklist.h"
-#include "HttpRequest.h"
-#include "HttpReply.h"
-#include "authenticate.h"
-#include "ACLProxyAuth.h"
-#include "client_side.h"
-#include "auth/UserRequest.h"
-
-int
-ACLChecklist::authenticated()
-{
-    http_hdr_type headertype;
-
-    if (NULL == request) {
-        fatal ("requiresRequest SHOULD have been true for this ACL!!");
-        return 0;
-    } else if (request->flags.accelerated) {
-        /* WWW authorization on accelerated requests */
-        headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
-        debugs(28, DBG_IMPORTANT, HERE << " authentication not applicable on intercepted requests.");
-        return -1;
-    } else {
-        /* Proxy authorization on proxy requests */
-        headertype = HDR_PROXY_AUTHORIZATION;
-    }
-
-    /* get authed here */
-    /* Note: this fills in auth_user_request when applicable */
-    /*
-     * DPW 2007-05-08
-     * tryToAuthenticateAndSetAuthUser used to try to lock and
-     * unlock auth_user_request on our behalf, but it was too
-     * ugly and hard to follow.  Now we do our own locking here.
-     *
-     * I'm not sure what tryToAuthenticateAndSetAuthUser does when
-     * auth_user_request is set before calling.  I'm tempted to
-     * unlock and set it to NULL, but it seems safer to save the
-     * pointer before calling and unlock it afterwards.  If the
-     * pointer doesn't change then its a no-op.
-     */
-    AuthUserRequest *old_auth_user_request = auth_user_request;
-    auth_acl_t result = AuthUserRequest::tryToAuthenticateAndSetAuthUser (&auth_user_request, headertype, request, conn(), src_addr);
-    if (auth_user_request)
-        AUTHUSERREQUESTLOCK(auth_user_request, "ACLChecklist");
-    AUTHUSERREQUESTUNLOCK(old_auth_user_request, "old ACLChecklist");
-    switch (result) {
-
-    case AUTH_ACL_CANNOT_AUTHENTICATE:
-        debugs(28, 4, "aclMatchAcl: returning  0 user authenticated but not authorised.");
-        return 0;
-
-    case AUTH_AUTHENTICATED:
-
-        return 1;
-        break;
-
-    case AUTH_ACL_HELPER:
-        debugs(28, 4, "aclMatchAcl: returning 0 sending credentials to helper.");
-        changeState (ProxyAuthLookup::Instance());
-        return 0;
-
-    case AUTH_ACL_CHALLENGE:
-        debugs(28, 4, "aclMatchAcl: returning 0 sending authentication challenge.");
-        changeState (ProxyAuthNeeded::Instance());
-        return 0;
-
-    default:
-        fatal("unexpected authenticateAuthenticate reply\n");
-        return 0;
-    }
-}
+#include "acl/Checklist.h"
 
 allow_t const &
 ACLChecklist::currentAnswer() const
@@ -249,30 +178,15 @@ ACLChecklist::checkForAsync()
     asyncState()->checkForAsync(this);
 }
 
+// ACLFilledChecklist overwrites this to unclock something before we
+// "delete this"
 void
 ACLChecklist::checkCallback(allow_t answer)
 {
     PF *callback_;
     void *cbdata_;
     debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
 
-    /* During reconfigure, we can end up not finishing call
-     * sequences into the auth code */
-
-    if (auth_user_request) {
-        /* the checklist lock */
-        AUTHUSERREQUESTUNLOCK(auth_user_request, "ACLChecklist");
-        /* it might have been connection based */
-        assert(conn() != NULL);
-        /*
-         * DPW 2007-05-08
-         * yuck, this make me uncomfortable.  why do this here?
-         * ConnStateData will do its own unlocking.
-         */
-        AUTHUSERREQUESTUNLOCK(conn()->auth_user_request, "conn via ACLChecklist");
-        conn()->auth_type = AUTH_BROKEN;
-    }
-
     callback_ = callback;
     callback = NULL;
 
@@ -346,104 +260,28 @@ ACLChecklist::matchAclList(const ACLList * head, bool const fast)
     PROF_stop(aclMatchAclList);
 }
 
-CBDATA_CLASS_INIT(ACLChecklist);
-
-void *
-ACLChecklist::operator new (size_t size)
-{
-    assert (size == sizeof(ACLChecklist));
-    CBDATA_INIT_TYPE(ACLChecklist);
-    ACLChecklist *result = cbdataAlloc(ACLChecklist);
-    return result;
-}
-
-void
-ACLChecklist::operator delete (void *address)
-{
-    ACLChecklist *t = static_cast<ACLChecklist *>(address);
-    cbdataFree(t);
-}
-
 ACLChecklist::ACLChecklist() :
         accessList (NULL),
-        dst_peer(NULL),
-        request (NULL),
-        reply (NULL),
-        auth_user_request (NULL),
-#if SQUID_SNMP
-        snmp_community(NULL),
-#endif
-#if USE_SSL
-        ssl_error(0),
-#endif
         callback (NULL),
         callback_data (NULL),
-        extacl_entry (NULL),
-        conn_(NULL),
-        fd_(-1),
         async_(false),
         finished_(false),
         allow_(ACCESS_DENIED),
         state_(NullState::Instance()),
-        destinationDomainChecked_(false),
-        sourceDomainChecked_(false),
         lastACLResult_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
-    rfc931[0] = '\0';
 }
 
 ACLChecklist::~ACLChecklist()
 {
     assert (!asyncInProgress());
 
-    if (extacl_entry)
-        cbdataReferenceDone(extacl_entry);
-
-    HTTPMSGUNLOCK(request);
-
-    HTTPMSGUNLOCK(reply);
-
-    // no auth_user_request in builds without any Authentication configured
-    if (auth_user_request)
-        AUTHUSERREQUESTUNLOCK(auth_user_request, "ACLChecklist destructor");
-
-    cbdataReferenceDone(conn_);
-
     cbdataReferenceDone(accessList);
 
     debugs(28, 4, "ACLChecklist::~ACLChecklist: destroyed " << this);
 }
 
 
-ConnStateData *
-ACLChecklist::conn() const
-{
-    return  conn_;
-}
-
-void
-ACLChecklist::conn(ConnStateData *aConn)
-{
-    assert (conn() == NULL);
-    conn_ = cbdataReference(aConn);
-}
-
-int
-ACLChecklist::fd() const
-{
-    return conn_ != NULL ? conn_->fd : fd_;
-}
-
-void
-ACLChecklist::fd(int aDescriptor)
-{
-    assert(!conn() || conn()->fd == aDescriptor);
-    fd_ = aDescriptor;
-}
-
 void
 ACLChecklist::AsyncState::changeState (ACLChecklist *checklist, AsyncState *newState) const
 {
@@ -532,32 +370,6 @@ ACLChecklist::fastCheck()
 }
 
 
-bool
-ACLChecklist::destinationDomainChecked() const
-{
-    return destinationDomainChecked_;
-}
-
-void
-ACLChecklist::markDestinationDomainChecked()
-{
-    assert (!finished() && !destinationDomainChecked());
-    destinationDomainChecked_ = true;
-}
-
-bool
-ACLChecklist::sourceDomainChecked() const
-{
-    return sourceDomainChecked_;
-}
-
-void
-ACLChecklist::markSourceDomainChecked()
-{
-    assert (!finished() && !sourceDomainChecked());
-    sourceDomainChecked_ = true;
-}
-
 bool
 ACLChecklist::checking() const
 {
@@ -570,58 +382,17 @@ ACLChecklist::checking (bool const newValue)
     checking_ = newValue;
 }
 
-/*
- * Any ACLChecklist created by aclChecklistCreate() must eventually be
- * freed by ACLChecklist::operator delete().  There are two common cases:
- *
- * A) Using aclCheckFast():  The caller creates the ACLChecklist using
- *    aclChecklistCreate(), checks it using aclCheckFast(), and frees it
- *    using aclChecklistFree().
- *
- * B) Using aclNBCheck() and callbacks: The caller creates the
- *    ACLChecklist using aclChecklistCreate(), and passes it to
- *    aclNBCheck().  Control eventually passes to ACLChecklist::checkCallback(),
- *    which will invoke the callback function as requested by the
- *    original caller of aclNBCheck().  This callback function must
- *    *not* invoke aclChecklistFree().  After the callback function
- *    returns, ACLChecklist::checkCallback() will free the ACLChecklist using
- *    aclChecklistFree().
- */
-ACLChecklist *
-aclChecklistCreate(const acl_access * A, HttpRequest * request, const char *ident)
+bool
+ACLChecklist::callerGone()
 {
-    // TODO: make this a constructor? On-stack creation uses the same code.
-    ACLChecklist *checklist = new ACLChecklist;
-
-    if (A)
-        checklist->accessList = cbdataReference(A);
-
-    if (request != NULL) {
-        checklist->request = HTTPMSGLOCK(request);
-#if FOLLOW_X_FORWARDED_FOR
-        if (Config.onoff.acl_uses_indirect_client)
-            checklist->src_addr = request->indirect_client_addr;
-        else
-#endif /* FOLLOW_X_FORWARDED_FOR */
-            checklist->src_addr = request->client_addr;
-        checklist->my_addr = request->my_addr;
-    }
-
-#if USE_IDENT
-    if (ident)
-        xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
-
-#endif
-
-    return checklist;
+    return !cbdataReferenceValid(callback_data);
 }
 
 bool
-ACLChecklist::callerGone()
+ACLChecklist::matchAclListFast(const ACLList * list)
 {
-    return !cbdataReferenceValid(callback_data);
+    matchAclList(list, true);
+    return finished();
 }
 
-#ifndef _USE_INLINE_
-#include "ACLChecklist.cci"
-#endif
+
@@ -33,17 +33,13 @@
 #ifndef SQUID_ACLCHECKLIST_H
 #define SQUID_ACLCHECKLIST_H
 
-//#include "typedefs.h"
-//#include "client_side.h"
-//#include "structs.h"
+#include "acl/Acl.h"
 
-#include "ACL.h"
-
-class AuthUserRequest;
-class ExternalACLEntry;
-class ConnStateData;
-
-/// \ingroup ACLAPI
+/** \ingroup ACLAPI
+    Base class for maintaining Squid and transaction state for access checks.
+	Provides basic ACL checking methods. Its only child, ACLFilledChecklist,
+	keeps the actual state data. The split is necessary to avoid exposing
+    all ACL-related code to virtually Squid data types. */
 class ACLChecklist
 {
 
@@ -88,18 +84,9 @@ class ACLChecklist
     };
 
 
-public: /* operators */
-    void *operator new(size_t);
-    void operator delete(void *);
-
+public:
     ACLChecklist();
-    ~ACLChecklist();
-    /** NP: To cause link failures if assignment attempted */
-    ACLChecklist (ACLChecklist const &);
-    /** NP: To cause link failures if assignment attempted */
-    ACLChecklist &operator=(ACLChecklist const &);
-
-public: /* API methods */
+    virtual ~ACLChecklist();
 
     /**
      * Trigger off a non-blocking access check for a set of *_access options..
@@ -135,7 +122,7 @@ class ACLChecklist
      * \retval  1/true    Access Allowed
      * \retval 0/false    Access Denied
      */
-    _SQUID_INLINE_ bool matchAclListFast(const ACLList * list);
+    bool matchAclListFast(const ACLList * list);
 
     /**
      * Attempt to check the current checklist against current data.
@@ -149,20 +136,6 @@ class ACLChecklist
      */
     void check();
 
-    ConnStateData * conn() const;
-
-    /// uses conn() if available
-    int fd() const;
-
-    /// set either conn
-    void conn(ConnStateData *);
-    /// set FD
-    void fd(int aDescriptor);
-
-/* Accessors used by internal ACL stuff */
-
-    int authenticated();
-
     bool asyncInProgress() const;
     void asyncInProgress(bool const);
 
@@ -175,62 +148,33 @@ class ACLChecklist
     void changeState(AsyncState *);
     AsyncState *asyncState() const;
 
-private: /* NP: only used internally */
+	// XXX: ACLs that need request or reply have to use ACLFilledChecklist and
+	// should do their own checks so that we do not have to povide these two
+    // for ACL::checklistMatches to use
+	virtual bool hasRequest() const = 0;
+	virtual bool hasReply() const = 0;
 
-    void checkCallback(allow_t answer);
+private:
+    virtual void checkCallback(allow_t answer);
     void checkAccessList();
     void checkForAsync();
 
-public: /* checklist available data */
-
+public:
     const acl_access *accessList;
 
-    IpAddress src_addr;
-
-    IpAddress dst_addr;
-
-    IpAddress my_addr;
-
-    struct peer *dst_peer;
-
-    HttpRequest *request;
-
-    /* for acls that look at reply data */
-    HttpReply *reply;
-    char rfc931[USER_IDENT_SZ];
-    AuthUserRequest *auth_user_request;
-#if SQUID_SNMP
-
-    char *snmp_community;
-#endif
-
-#if USE_SSL
-    int ssl_error;
-#endif
-
     PF *callback;
     void *callback_data;
-    ExternalACLEntry *extacl_entry;
-
-    bool destinationDomainChecked() const;
-    void markDestinationDomainChecked();
-    bool sourceDomainChecked() const;
-    void markSourceDomainChecked();
 
 private: /* internal methods */
     void preCheck();
     void matchAclList(const ACLList * list, bool const fast);
     void matchAclListSlow(const ACLList * list);
-    CBDATA_CLASS(ACLChecklist);
 
-    ConnStateData * conn_;          /**< hack for ident and NTLM */
-    int fd_;                        /**< may be available when conn_ is not */
     bool async_;
     bool finished_;
     allow_t allow_;
     AsyncState *state_;
-    bool destinationDomainChecked_;
-    bool sourceDomainChecked_;
+
     bool checking_;
     bool checking() const;
     void checking (bool const);
@@ -244,13 +188,4 @@ class ACLChecklist
     bool lastACLResult() const { return lastACLResult_; }
 };
 
-/// \ingroup ACLAPI
-SQUIDCEXTERN ACLChecklist *aclChecklistCreate(const acl_access *,
-        HttpRequest *,
-        const char *ident);
-
-#ifdef _USE_INLINE_
-#include "ACLChecklist.cci"
-#endif
-
 #endif /* SQUID_ACLCHECKLIST_H */
@@ -32,16 +32,16 @@
 #ifndef SQUID_ACLDESTINATIONASN_H
 #define SQUID_ACLDESTINATIONASN_H
 
-#include "ACLASN.h"
-#include "ACLStrategy.h"
+#include "acl/Asn.h"
+#include "acl/Strategy.h"
 #include "ip/IpAddress.h"
 
 /// \ingroup ACLAPI
 class ACLDestinationASNStrategy : public ACLStrategy<IpAddress>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLDestinationASNStrategy *Instance();
@@ -35,10 +35,10 @@
  */
 
 #include "squid.h"
-#include "ACLDestinationDomain.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
-#include "ACLDomainData.h"
+#include "acl/DestinationDomain.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
+#include "acl/DomainData.h"
 #include "HttpRequest.h"
 
 DestinationDomainLookup DestinationDomainLookup::instance_;
@@ -50,8 +50,9 @@ DestinationDomainLookup::Instance()
 }
 
 void
-DestinationDomainLookup::checkForAsync(ACLChecklist *checklist) const
+DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 {
+	ACLFilledChecklist *checklist = Filled(cl);
     checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(checklist->dst_addr, LookupDone, checklist);
 }
@@ -64,7 +65,7 @@ DestinationDomainLookup::LookupDone(const char *fqdn, void *data)
 
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->markDestinationDomainChecked();
+    Filled(checklist)->markDestinationDomainChecked();
     checklist->check();
 }
 
@@ -74,7 +75,7 @@ ACL::Prototype ACLDestinationDomain::RegexRegistryProtoype(&ACLDestinationDomain
 ACLStrategised<char const *> ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,"dstdom_regex");
 
 int
-ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     assert(checklist != NULL && checklist->request != NULL);
 
@@ -35,17 +35,17 @@
 #ifndef SQUID_ACLSOURCEDOMAIN_H
 #define SQUID_ACLSOURCEDOMAIN_H
 
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLChecklist.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Checklist.h"
+#include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
 class ACLDestinationDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLDestinationDomainStrategy *Instance();
 
     /**
@@ -34,8 +34,8 @@
  */
 
 #include "squid.h"
-#include "ACLDestinationIP.h"
-#include "ACLChecklist.h"
+#include "acl/DestinationIp.h"
+#include "acl/FilledChecklist.h"
 #include "HttpRequest.h"
 
 char const *
@@ -45,8 +45,9 @@ ACLDestinationIP::typeString() const
 }
 
 int
-ACLDestinationIP::match(ACLChecklist *checklist)
+ACLDestinationIP::match(ACLChecklist *cl)
 {
+	ACLFilledChecklist *checklist = Filled(cl);
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
@@ -77,8 +78,9 @@ DestinationIPLookup::Instance()
 }
 
 void
-DestinationIPLookup::checkForAsync(ACLChecklist *checklist)const
+DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 {
+	ACLFilledChecklist *checklist = Filled(cl);
     checklist->asyncInProgress(true);
     ipcache_nbgethostbyname(checklist->request->GetHost(), LookupDone, checklist);
 }
@@ -88,7 +90,7 @@ DestinationIPLookup::LookupDone(const ipcache_addrs * ia, void *data)
 {
     ACLChecklist *checklist = (ACLChecklist *)data;
     assert (checklist->asyncState() == DestinationIPLookup::Instance());
-    checklist->request->flags.destinationIPLookupCompleted();
+    Filled(checklist)->request->flags.destinationIPLookupCompleted();
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->check();
@@ -35,8 +35,8 @@
 
 #ifndef SQUID_ACLDESTINATIONIP_H
 #define SQUID_ACLDESTINATIONIP_H
-#include "ACLChecklist.h"
-#include "ACLIP.h"
+#include "acl/Checklist.h"
+#include "acl/Ip.h"
 
 class DestinationIPLookup : public ACLChecklist::AsyncState
 {
@@ -35,9 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLDomainData.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
+#include "acl/DomainData.h"
+#include "acl/Checklist.h"
 #include "wordlist.h"
 
 template<class T>
@@ -36,8 +36,8 @@
 #define SQUID_ACLDOMAINDATA_H
 
 #include "splay.h"
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 
 /// \ingroup ACLAPI
 class ACLDomainData : public ACLData<char const *>
@@ -35,11 +35,10 @@
  */
 
 #include "squid.h"
-#include "ACLExtUser.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
-#include "ACLUserData.h"
+#include "acl/ExtUser.h"
+#include "acl/FilledChecklist.h"
+#include "acl/RegexData.h"
+#include "acl/UserData.h"
 #include "client_side.h"
 #include "HttpRequest.h"
 
@@ -76,8 +75,9 @@ ACLExtUser::parse()
 }
 
 int
-ACLExtUser::match(ACLChecklist *checklist)
+ACLExtUser::match(ACLChecklist *cl)
 {
+	ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->request->extacl_user.size()) {
         return data->match(checklist->request->extacl_user.termedBuf());
     } else {
@@ -35,9 +35,9 @@
 #ifndef SQUID_ACLIDENT_H
 #define SQUID_ACLIDENT_H
 
-#include "ACL.h"
-#include "ACLChecklist.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/Data.h"
 
 /// \ingroup ACLAPI
 class ACLExtUser : public ACL
@@ -0,0 +1,274 @@
+#include "squid.h"
+#include "HttpRequest.h"
+#include "HttpReply.h"
+#include "client_side.h"
+#include "auth/UserRequest.h"
+#include "auth/AclProxyAuth.h"
+#include "acl/FilledChecklist.h"
+
+CBDATA_CLASS_INIT(ACLFilledChecklist);
+
+#if MOVED
+int
+ACLFilledChecklist::authenticated()
+{
+    http_hdr_type headertype;
+
+    if (NULL == request) {
+        fatal ("requiresRequest SHOULD have been true for this ACL!!");
+        return 0;
+    } else if (request->flags.accelerated) {
+        /* WWW authorization on accelerated requests */
+        headertype = HDR_AUTHORIZATION;
+    } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
+        debugs(28, DBG_IMPORTANT, HERE << " authentication not applicable on intercepted requests.");
+        return -1;
+    } else {
+        /* Proxy authorization on proxy requests */
+        headertype = HDR_PROXY_AUTHORIZATION;
+    }
+
+    /* get authed here */
+    /* Note: this fills in auth_user_request when applicable */
+    /*
+     * DPW 2007-05-08
+     * tryToAuthenticateAndSetAuthUser used to try to lock and
+     * unlock auth_user_request on our behalf, but it was too
+     * ugly and hard to follow.  Now we do our own locking here.
+     *
+     * I'm not sure what tryToAuthenticateAndSetAuthUser does when
+     * auth_user_request is set before calling.  I'm tempted to
+     * unlock and set it to NULL, but it seems safer to save the
+     * pointer before calling and unlock it afterwards.  If the
+     * pointer doesn't change then its a no-op.
+     */
+    AuthUserRequest *old_auth_user_request = auth_user_request;
+    auth_acl_t result = AuthUserRequest::tryToAuthenticateAndSetAuthUser (&auth_user_request, headertype, request, conn(), src_addr);
+    if (auth_user_request)
+        AUTHUSERREQUESTLOCK(auth_user_request, "ACLFilledChecklist");
+    AUTHUSERREQUESTUNLOCK(old_auth_user_request, "old ACLFilledChecklist");
+    switch (result) {
+
+    case AUTH_ACL_CANNOT_AUTHENTICATE:
+        debugs(28, 4, "aclMatchAcl: returning  0 user authenticated but not authorised.");
+        return 0;
+
+    case AUTH_AUTHENTICATED:
+
+        return 1;
+        break;
+
+    case AUTH_ACL_HELPER:
+        debugs(28, 4, "aclMatchAcl: returning 0 sending credentials to helper.");
+        changeState (ProxyAuthLookup::Instance());
+        return 0;
+
+    case AUTH_ACL_CHALLENGE:
+        debugs(28, 4, "aclMatchAcl: returning 0 sending authentication challenge.");
+        changeState (ProxyAuthNeeded::Instance());
+        return 0;
+
+    default:
+        fatal("unexpected authenticateAuthenticate reply\n");
+        return 0;
+    }
+}
+#endif
+
+void
+ACLFilledChecklist::checkCallback(allow_t answer)
+{
+    debugs(28, 5, "ACLFilledChecklist::checkCallback: " << this << " answer=" << answer);
+
+    /* During reconfigure, we can end up not finishing call
+     * sequences into the auth code */
+
+    if (auth_user_request) {
+        /* the filled_checklist lock */
+        AUTHUSERREQUESTUNLOCK(auth_user_request, "ACLFilledChecklist");
+        /* it might have been connection based */
+        assert(conn() != NULL);
+        /*
+         * DPW 2007-05-08
+         * yuck, this make me uncomfortable.  why do this here?
+         * ConnStateData will do its own unlocking.
+         */
+        AUTHUSERREQUESTUNLOCK(conn()->auth_user_request, "conn via ACLFilledChecklist");
+        conn()->auth_type = AUTH_BROKEN;
+    }
+
+	ACLFilledChecklist::checkCallback(answer); // may delete us
+}
+
+
+void *
+ACLFilledChecklist::operator new (size_t size)
+{
+    assert (size == sizeof(ACLFilledChecklist));
+    CBDATA_INIT_TYPE(ACLFilledChecklist);
+    ACLFilledChecklist *result = cbdataAlloc(ACLFilledChecklist);
+    return result;
+}
+
+void
+ACLFilledChecklist::operator delete (void *address)
+{
+    ACLFilledChecklist *t = static_cast<ACLFilledChecklist *>(address);
+    cbdataFree(t);
+}
+
+
+ACLFilledChecklist::ACLFilledChecklist() :
+        dst_peer(NULL),
+        request (NULL),
+        reply (NULL),
+        auth_user_request (NULL),
+#if SQUID_SNMP
+        snmp_community(NULL),
+#endif
+#if USE_SSL
+        ssl_error(0),
+#endif
+        extacl_entry (NULL),
+        conn_(NULL),
+        fd_(-1),
+        destinationDomainChecked_(false),
+        sourceDomainChecked_(false)
+{
+    my_addr.SetEmpty();
+    src_addr.SetEmpty();
+    dst_addr.SetEmpty();
+    rfc931[0] = '\0';
+}
+
+
+ACLFilledChecklist::~ACLFilledChecklist()
+{
+    assert (!asyncInProgress());
+
+    if (extacl_entry)
+        cbdataReferenceDone(extacl_entry);
+
+    HTTPMSGUNLOCK(request);
+
+    HTTPMSGUNLOCK(reply);
+
+    // no auth_user_request in builds without any Authentication configured
+    if (auth_user_request)
+        AUTHUSERREQUESTUNLOCK(auth_user_request, "ACLFilledChecklist destructor");
+
+    cbdataReferenceDone(conn_);
+
+    debugs(28, 4, HERE << "ACLFilledChecklist destroyed " << this);
+}
+
+
+ConnStateData *
+ACLFilledChecklist::conn() const
+{
+    return  conn_;
+}
+
+void
+ACLFilledChecklist::conn(ConnStateData *aConn)
+{
+    assert (conn() == NULL);
+    conn_ = cbdataReference(aConn);
+}
+
+int
+ACLFilledChecklist::fd() const
+{
+    return conn_ != NULL ? conn_->fd : fd_;
+}
+
+void
+ACLFilledChecklist::fd(int aDescriptor)
+{
+    assert(!conn() || conn()->fd == aDescriptor);
+    fd_ = aDescriptor;
+}
+
+bool
+ACLFilledChecklist::destinationDomainChecked() const
+{
+    return destinationDomainChecked_;
+}
+
+void
+ACLFilledChecklist::markDestinationDomainChecked()
+{
+    assert (!finished() && !destinationDomainChecked());
+    destinationDomainChecked_ = true;
+}
+
+bool
+ACLFilledChecklist::sourceDomainChecked() const
+{
+    return sourceDomainChecked_;
+}
+
+void
+ACLFilledChecklist::markSourceDomainChecked()
+{
+    assert (!finished() && !sourceDomainChecked());
+    sourceDomainChecked_ = true;
+}
+
+/*
+ * There are two common ACLFilledChecklist lifecycles paths:
+ *
+ * A) Using aclCheckFast(): The caller creates an ACLFilledChecklist object
+ *    on stack and calls aclCheckFast().
+ *
+ * B) Using aclNBCheck() and callbacks: The caller allocates an
+ *    ACLFilledChecklist object (via operator new) and passes it to
+ *    aclNBCheck(). Control eventually passes to ACLChecklist::checkCallback(),
+ *    which will invoke the callback function as requested by the
+ *    original caller of aclNBCheck().  This callback function must
+ *    *not* delete the list.  After the callback function returns,
+ *    checkCallback() will delete the list (i.e., self).
+ */
+ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *request, const char *ident):
+    dst_peer(NULL),
+    request(NULL),
+    reply(NULL),
+    auth_user_request(NULL),
+#if SQUID_SNMP
+    snmp_community(NULL),
+#endif
+#if USE_SSL
+    ssl_error(0),
+#endif
+    extacl_entry (NULL),
+    conn_(NULL),
+    fd_(-1),
+    destinationDomainChecked_(false),
+    sourceDomainChecked_(false)
+{
+    my_addr.SetEmpty();
+    src_addr.SetEmpty();
+    dst_addr.SetEmpty();
+    rfc931[0] = '\0';
+    
+    // cbdataReferenceDone() is in either fastCheck() or the destructor
+    if (A)
+        accessList = cbdataReference(A);
+
+    if (request != NULL) {
+        request = HTTPMSGLOCK(request);
+#if FOLLOW_X_FORWARDED_FOR
+        if (Config.onoff.acl_uses_indirect_client)
+            src_addr = request->indirect_client_addr;
+        else
+#endif /* FOLLOW_X_FORWARDED_FOR */
+            src_addr = request->client_addr;
+        my_addr = request->my_addr;
+    }
+
+#if USE_IDENT
+    if (ident)
+        xstrncpy(rfc931, ident, USER_IDENT_SZ);
+#endif
+}
+
@@ -0,0 +1,94 @@
+#ifndef SQUID_ACLFILLED_CHECKLIST_H
+#define SQUID_ACLFILLED_CHECKLIST_H
+
+#include "acl/Checklist.h"
+
+class AuthUserRequest;
+class ExternalACLEntry;
+class ConnStateData;
+
+/** \ingroup ACLAPI
+    ACLChecklist filled with specific data, representing Squid and transaction
+    state for access checks along with some data-specific checking methods */
+class ACLFilledChecklist: public ACLChecklist
+{
+public:
+    void *operator new(size_t);
+    void operator delete(void *);
+
+    ACLFilledChecklist();
+	ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
+    ~ACLFilledChecklist();
+
+public:
+    ConnStateData * conn() const;
+
+    /// uses conn() if available
+    int fd() const;
+
+    /// set either conn
+    void conn(ConnStateData *);
+    /// set FD
+    void fd(int aDescriptor);
+
+    //int authenticated();
+
+    bool destinationDomainChecked() const;
+    void markDestinationDomainChecked();
+    bool sourceDomainChecked() const;
+    void markSourceDomainChecked();
+
+    // ACLChecklist API
+    virtual bool hasRequest() const { return request != NULL; }
+    virtual bool hasReply() const { return reply != NULL; }
+
+public:
+    IpAddress src_addr;
+    IpAddress dst_addr;
+    IpAddress my_addr;
+    struct peer *dst_peer;
+
+    HttpRequest *request;
+    HttpReply *reply;
+
+    char rfc931[USER_IDENT_SZ];
+    AuthUserRequest *auth_user_request;
+
+#if SQUID_SNMP
+    char *snmp_community;
+#endif
+
+#if USE_SSL
+    int ssl_error;
+#endif
+
+    ExternalACLEntry *extacl_entry;
+
+private:
+    virtual void checkCallback(allow_t answer);
+
+private:
+    CBDATA_CLASS(ACLFilledChecklist);
+
+    ConnStateData * conn_;          /**< hack for ident and NTLM */
+    int fd_;                        /**< may be available when conn_ is not */
+    bool destinationDomainChecked_;
+    bool sourceDomainChecked_;
+
+private:
+    /// not implemented; will cause link failures if used
+    ACLFilledChecklist(const ACLFilledChecklist &);
+    /// not implemented; will cause link failures if used
+    ACLFilledChecklist &operator=(const ACLFilledChecklist &);
+};
+
+/// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
+inline
+ACLFilledChecklist *Filled(ACLChecklist *checklist)
+{
+    // this should always be safe because ACLChecklist is an abstract class
+    // and ACLFilledChecklist is its only [concrete] child
+    return dynamic_cast<ACLFilledChecklist*>(checklist);
+}
+
+#endif /* SQUID_ACLFILLED_CHECKLIST_H */
@@ -39,8 +39,10 @@
  */
 
 #include "squid.h"
-#include "ACL.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/Strategised.h"
+#include "acl/Gadgets.h"
 #include "ConfigParser.h"
 #include "errorpage.h"
 #include "HttpRequest.h"
@@ -318,5 +320,26 @@ aclDestroyDenyInfoList(acl_deny_info_list ** list)
 int
 aclPurgeMethodInUse(acl_access * a)
 {
-    return a->containsPURGE();
+    ACLList *b;
+
+    debugs(28, 6, "aclPurgeMethodInUse: invoked for '" << a->cfgline << "'");
+
+    for (; a; a = a->next) {
+        for (b = a->aclList; b; b = b->next) {
+            ACLStrategised<HttpRequestMethod> *tempAcl = dynamic_cast<ACLStrategised<HttpRequestMethod> *>(b->_acl);
+
+            if (!tempAcl) {
+                debugs(28, 7, "aclPurgeMethodInUse: can't create tempAcl");
+                continue;
+            }
+
+            if (tempAcl->match(METHOD_PURGE)) {
+                debugs(28, 6, "aclPurgeMethodInUse: returning true");
+                return true;
+            }
+        }
+    }
+
+    debugs(28, 6, "aclPurgeMethodInUse: returning false");
+    return false;
 }
@@ -0,0 +1,43 @@
+#ifndef SQUID_ACL_GADGETS_H
+#define SQUID_ACL_GADGETS_H
+
+#include "config.h"
+#include "enums.h" /* for err_type */
+
+struct dlink_list;
+class StoreEntry;
+class ConfigParser;
+class acl_access;
+class ACL;
+class ACLList;
+struct acl_deny_info_list;
+class wordlist;
+
+/// \ingroup ACLAPI
+extern void aclDestroyAccessList(acl_access **list);
+/// \ingroup ACLAPI
+extern void aclDestroyAcls(ACL **);
+/// \ingroup ACLAPI
+extern void aclDestroyAclList(ACLList **);
+/// \ingroup ACLAPI
+extern void aclParseAccessLine(ConfigParser &parser, acl_access **);
+/// \ingroup ACLAPI
+extern void aclParseAclList(ConfigParser &parser, ACLList **);
+/// \ingroup ACLAPI
+extern int aclIsProxyAuth(const char *name);
+/// \ingroup ACLAPI
+extern err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed);
+/// \ingroup ACLAPI
+extern void aclParseDenyInfoLine(acl_deny_info_list **);
+/// \ingroup ACLAPI
+extern void aclDestroyDenyInfoList(acl_deny_info_list **);
+/// \ingroup ACLAPI
+extern wordlist *aclDumpGeneric(const ACL *);
+/// \ingroup ACLAPI
+extern void aclCacheMatchFlush(dlink_list * cache);
+/// \ingroup ACLAPI
+extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
+/// \ingroup ACLAPI
+int aclPurgeMethodInUse(acl_access * a);
+
+#endif /* SQUID_ACL_GADGETS_H */
@@ -35,11 +35,10 @@
  */
 
 #include "squid.h"
-#include "ACLHTTPHeaderData.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
-#include "ACLRegexData.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Checklist.h"
+#include "acl/Acl.h"
+#include "acl/RegexData.h"
 #include "wordlist.h"
 #include "ConfigParser.h"
 
@@ -38,7 +38,7 @@ class HttpHeader;
 class wordlist;
 
 /* becaue we inherit from it */
-#include "ACLData.h"
+#include "acl/Data.h"
 /* for String field */
 #include "SquidString.h"
 /* for http_hdr_type field */
@@ -34,17 +34,17 @@
  */
 
 #include "squid.h"
-#include "ACLHTTPRepHeader.h"
-#include "ACLHTTPHeaderData.h"
-#include "ACLChecklist.h"
+#include "acl/HttpRepHeader.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Checklist.h"
 #include "HttpReply.h"
 
 ACL::Prototype ACLHTTPRepHeader::RegistryProtoype(&ACLHTTPRepHeader::RegistryEntry_, "rep_header");
 
 ACLStrategised<HttpHeader*> ACLHTTPRepHeader::RegistryEntry_(new ACLHTTPHeaderData, ACLHTTPRepHeaderStrategy::Instance(), "rep_header");
 
 int
-ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (&checklist->reply->header);
 }
@@ -35,16 +35,16 @@
 #ifndef SQUID_ACLHTTPREPHEADER_H
 #define SQUID_ACLHTTPREPHEADER_H
 
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 #include "HttpHeader.h"
 
 /// \ingroup ACLAPI
 class ACLHTTPRepHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresReply() const { return true; }
 
     static ACLHTTPRepHeaderStrategy *Instance();
@@ -34,17 +34,17 @@
  */
 
 #include "squid.h"
-#include "ACLHTTPReqHeader.h"
-#include "ACLHTTPHeaderData.h"
-#include "ACLChecklist.h"
+#include "acl/HttpReqHeader.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 ACL::Prototype ACLHTTPReqHeader::RegistryProtoype(&ACLHTTPReqHeader::RegistryEntry_, "req_header");
 
 ACLStrategised<HttpHeader*> ACLHTTPReqHeader::RegistryEntry_(new ACLHTTPHeaderData, ACLHTTPReqHeaderStrategy::Instance(), "req_header");
 
 int
-ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (&checklist->request->header);
 }
@@ -35,16 +35,16 @@
 #ifndef SQUID_ACLHTTPREQHEADER_H
 #define SQUID_ACLHTTPREQHEADER_H
 
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 #include "HttpHeader.h"
 
 /// \ingroup ACLAPI
 class ACLHTTPReqHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const { return true; }
 
     static ACLHTTPReqHeaderStrategy *Instance();
@@ -40,7 +40,8 @@
 #endif
 #include "squid.h"
 
-#include "ACLHTTPStatus.h"
+#include "acl/HttpStatus.h"
+#include "acl/FilledChecklist.h"
 #include "HttpReply.h"
 #include "wordlist.h"
 
@@ -161,7 +162,7 @@ aclParseHTTPStatusList(SplayNode<acl_httpstatus_data *> **curlist)
 int
 ACLHTTPStatus::match(ACLChecklist *checklist)
 {
-    return aclMatchHTTPStatus(&data, checklist->reply->sline.status);
+    return aclMatchHTTPStatus(&data, Filled(checklist)->reply->sline.status);
 }
 
 int
@@ -35,8 +35,8 @@
 #ifndef SQUID_ACLHTTPSTATUS_H
 #define SQUID_ACLHTTPSTATUS_H
 
-#include "ACL.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
 #include "splay.h"
 
 /// \ingroup ACLAPI
@@ -35,11 +35,10 @@
  */
 
 #include "squid.h"
-#include "ACLIdent.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
-#include "ACLUserData.h"
+#include "acl/Ident.h"
+#include "acl/FilledChecklist.h"
+#include "acl/RegexData.h"
+#include "acl/UserData.h"
 #include "client_side.h"
 #include "ident.h"
 
@@ -79,8 +78,9 @@ ACLIdent::parse()
 }
 
 int
-ACLIdent::match(ACLChecklist *checklist)
+ACLIdent::match(ACLChecklist *cl)
 {
+    ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->rfc931[0]) {
         return data->match(checklist->rfc931);
     } else if (checklist->conn() != NULL && checklist->conn()->rfc931[0]) {
@@ -124,8 +124,9 @@ IdentLookup::Instance()
 }
 
 void
-IdentLookup::checkForAsync(ACLChecklist *checklist)const
+IdentLookup::checkForAsync(ACLChecklist *cl)const
 {
+    ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->conn() != NULL) {
         debugs(28, 3, "IdentLookup::checkForAsync: Doing ident lookup" );
         checklist->asyncInProgress(true);
@@ -141,7 +142,7 @@ IdentLookup::checkForAsync(ACLChecklist *checklist)const
 void
 IdentLookup::LookupDone(const char *ident, void *data)
 {
-    ACLChecklist *checklist = (ACLChecklist *)data;
+    ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
     assert (checklist->asyncState() == IdentLookup::Instance());
 
     if (ident) {
@@ -35,7 +35,7 @@
 #ifndef SQUID_ACLIDENT_H
 #define SQUID_ACLIDENT_H
 
-#include "ACLChecklist.h"
+#include "acl/Checklist.h"
 
 /// \ingroup ACLAPI
 class IdentLookup : public ACLChecklist::AsyncState
@@ -51,8 +51,8 @@ class IdentLookup : public ACLChecklist::AsyncState
 };
 
 
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 
 /// \ingroup ACLAPI
 class ACLIdent : public ACL
@@ -35,7 +35,7 @@
  */
 
 #include "squid.h"
-#include "ACLIntRange.h"
+#include "acl/IntRange.h"
 #include "wordlist.h"
 #include "Parsing.h"
 
@@ -35,7 +35,7 @@
 #ifndef SQUID_ACLINTRANGE_H
 #define SQUID_ACLINTRANGE_H
 
-#include "ACLData.h"
+#include "acl/Data.h"
 #include "CbDataList.h"
 #include "Range.h"
 
@@ -34,8 +34,8 @@
  */
 
 #include "squid.h"
-#include "ACLIP.h"
-#include "ACLChecklist.h"
+#include "acl/Ip.h"
+#include "acl/Checklist.h"
 #include "MemBuf.h"
 #include "wordlist.h"
 
@@ -32,7 +32,7 @@
 #ifndef SQUID_ACLIP_H
 #define SQUID_ACLIP_H
 
-#include "ACL.h"
+#include "acl/Acl.h"
 #include "splay.h"
 #include "ip/IpAddress.h"
 
@@ -0,0 +1,142 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libapi.la libstate.la libacls.la
+
+## General data-independent ACL API
+libapi_la_SOURCES = \
+	Acl.cc \
+	Acl.h \
+	Checklist.cc \
+	Checklist.h
+
+## Data-dependent Squid/transaction state used by specific ACLs.
+## Does not refer to specific ACLs to avoid circular dependencies.
+libstate_la_SOURCES = \
+	Data.h \
+	Strategy.h \
+	Strategised.cc \
+	Strategised.h \
+	\
+	FilledChecklist.cc \
+	FilledChecklist.h
+
+## data-specific ACLs
+libacls_la_SOURCES = \
+	IntRange.cc \
+	IntRange.h \
+	RegexData.cc \
+	RegexData.h \
+	StringData.cc \
+	StringData.h \
+	Time.cc \
+	Time.h \
+	TimeData.cc \
+	TimeData.h \
+	\
+	Asn.cc \
+	Asn.h \
+	Browser.cc \
+	Browser.h \
+	DestinationAsn.h \
+	DestinationDomain.cc \
+	DestinationDomain.h \
+	DestinationIp.cc \
+	DestinationIp.h \
+	DomainData.cc \
+	DomainData.h \
+	ExtUser.cc \
+	ExtUser.h \
+	HttpHeaderData.cc \
+	HttpHeaderData.h \
+	HttpRepHeader.cc \
+	HttpRepHeader.h \
+	HttpReqHeader.cc \
+	HttpReqHeader.h \
+	HttpStatus.cc \
+	HttpStatus.h \
+	Ip.cc \
+	Ip.h \
+	MaxConnection.cc \
+	MaxConnection.h \
+	Method.cc \
+	MethodData.cc \
+	MethodData.h \
+	Method.h \
+	MyIp.cc \
+	MyIp.h \
+	MyPort.cc \
+	MyPort.h \
+	MyPortName.cc \
+	MyPortName.h \
+	PeerName.cc \
+	PeerName.h \
+	Protocol.cc \
+	ProtocolData.cc \
+	ProtocolData.h \
+	Protocol.h \
+	Referer.cc \
+	Referer.h \
+	ReplyHeaderStrategy.h \
+	ReplyMimeType.cc \
+	ReplyMimeType.h \
+	RequestHeaderStrategy.h \
+	RequestMimeType.cc \
+	RequestMimeType.h \
+	SourceAsn.h \
+	SourceDomain.cc \
+	SourceDomain.h \
+	SourceIp.cc \
+	SourceIp.h \
+	Url.cc \
+	Url.h \
+	UrlPath.cc \
+	UrlPath.h \
+	UrlPort.cc \
+	UrlPort.h \
+	UserData.cc \
+	UserData.h \
+	\
+	Gadgets.cc \
+	Gadgets.h
+
+## Add conditional sources
+## TODO: move these to their respectful dirs when those dirs are created
+
+EXTRA_libacls_la_SOURCES =
+
+SSL_ACLS = \
+        CertificateData.cc \
+        CertificateData.h  \
+        Certificate.cc \
+        Certificate.h  \
+        SslError.cc \
+        SslError.h \
+        SslErrorData.cc \
+        SslErrorData.h
+
+if ENABLE_SSL
+libacls_la_SOURCES += $(SSL_ACLS)
+endif
+
+EXTRA_libacls_la_SOURCES += $(SSL_ACLS)
+
+
+ARP_ACLS = Arp.cc Arp.h
+
+if ENABLE_ARP_ACL
+libacls_la_SOURCES += $(ARP_ACLS)
+endif
+
+EXTRA_libacls_la_SOURCES += $(ARP_ACLS)
+
+
+IDENT_ACLS = Ident.cc Ident.h
+
+if ENABLE_IDENT
+libacls_la_SOURCES += $(IDENT_ACLS)
+endif
+
+EXTRA_libacls_la_SOURCES += $(IDENT_ACLS)
+
+
@@ -35,7 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLMaxConnection.h"
+#include "acl/FilledChecklist.h"
+#include "acl/MaxConnection.h"
 #include "wordlist.h"
 
 ACL::Prototype ACLMaxConnection::RegistryProtoype(&ACLMaxConnection::RegistryEntry_, "maxconn");
@@ -95,7 +96,7 @@ ACLMaxConnection::parse()
 int
 ACLMaxConnection::match(ACLChecklist *checklist)
 {
-    return (clientdbEstablished(checklist->src_addr, 0) > limit ? 1 : 0);
+    return clientdbEstablished(Filled(checklist)->src_addr, 0) > limit ? 1 : 0;
 }
 
 wordlist *
@@ -35,8 +35,8 @@
 #ifndef SQUID_ACLMAXCONNECTION_H
 #define SQUID_ACLMAXCONNECTION_H
 
-#include "ACL.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
 
 /// \ingroup ACLAPI
 class ACLMaxConnection : public ACL
@@ -34,9 +34,9 @@
  */
 
 #include "squid.h"
-#include "ACLMethod.h"
-#include "ACLMethodData.h"
-#include "ACLChecklist.h"
+#include "acl/Method.h"
+#include "acl/MethodData.h"
+#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
@@ -48,7 +48,7 @@ ACL::Prototype ACLMethod::RegistryProtoype(&ACLMethod::RegistryEntry_, "method")
 ACLStrategised<HttpRequestMethod> ACLMethod::RegistryEntry_(new ACLMethodData, ACLMethodStrategy::Instance(), "method");
 
 int
-ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->request->method);
 }
@@ -35,15 +35,15 @@
 #ifndef SQUID_ACLMETHOD_H
 #define SQUID_ACLMETHOD_H
 
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
 class ACLMethodStrategy : public ACLStrategy<HttpRequestMethod>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLMethodStrategy *Instance();
@@ -35,8 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLMethodData.h"
-#include "ACLChecklist.h"
+#include "acl/MethodData.h"
+#include "acl/Checklist.h"
 #include "HttpRequestMethod.h"
 #include "wordlist.h"
 
@@ -35,8 +35,8 @@
 #ifndef SQUID_ACLMETHODDATA_H
 #define SQUID_ACLMETHODDATA_H
 
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 #include "CbDataList.h"
 
 /// \ingroup ACLAPI
@@ -34,8 +34,8 @@
  */
 
 #include "squid.h"
-#include "ACLMyIP.h"
-#include "ACLChecklist.h"
+#include "acl/MyIp.h"
+#include "acl/FilledChecklist.h"
 
 char const *
 ACLMyIP::typeString() const
@@ -46,7 +46,7 @@ ACLMyIP::typeString() const
 int
 ACLMyIP::match(ACLChecklist *checklist)
 {
-    return ACLIP::match (checklist->my_addr);
+    return ACLIP::match (Filled(checklist)->my_addr);
 }
 
 ACL::Prototype ACLMyIP::RegistryProtoype(&ACLMyIP::RegistryEntry(), "myip");
@@ -35,7 +35,7 @@
 #ifndef SQUID_ACLMYIP_H
 #define SQUID_ACLMYIP_H
 
-#include "ACLIP.h"
+#include "acl/Ip.h"
 
 /// \ingroup ACLAPI
 class ACLMyIP : public ACLIP
@@ -34,9 +34,9 @@
  */
 
 #include "squid.h"
-#include "ACLMyPort.h"
-#include "ACLIntRange.h"
-#include "ACLChecklist.h"
+#include "acl/MyPort.h"
+#include "acl/IntRange.h"
+#include "acl/Checklist.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -47,7 +47,7 @@ ACL::Prototype ACLMyPort::RegistryProtoype(&ACLMyPort::RegistryEntry_, "myport")
 ACLStrategised<int> ACLMyPort::RegistryEntry_(new ACLIntRange, ACLMyPortStrategy::Instance(), "myport");
 
 int
-ACLMyPortStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLMyPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->my_addr.GetPort());
 }
@@ -35,15 +35,15 @@
 #ifndef SQUID_ACLMYPORT_H
 #define SQUID_ACLMYPORT_H
 
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
 class ACLMyPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLMyPortStrategy *Instance();
     /**
      * Not implemented to prevent copies of the instance.
@@ -35,9 +35,9 @@
 
 #include "squid.h"
 #include "ProtoPort.h"
-#include "ACLMyPortName.h"
-#include "ACLStringData.h"
-#include "ACLChecklist.h"
+#include "acl/MyPortName.h"
+#include "acl/StringData.h"
+#include "acl/Checklist.h"
 
 /* for ConnStateData */
 #include "client_side.h"
@@ -48,7 +48,7 @@ ACL::Prototype ACLMyPortName::RegistryProtoype(&ACLMyPortName::RegistryEntry_, "
 ACLStrategised<const char *> ACLMyPortName::RegistryEntry_(new ACLStringData, ACLMyPortNameStrategy::Instance(), "myportname");
 
 int
-ACLMyPortNameStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLMyPortNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->conn() != NULL)
         return data->match (checklist->conn()->port->name);
@@ -35,14 +35,14 @@
 
 #ifndef SQUID_ACLMYPORTNAME_H
 #define SQUID_ACLMYPORTNAME_H
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 class ACLMyPortNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLMyPortNameStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -1,14 +1,14 @@
 #include "squid.h"
-#include "ACLPeerName.h"
-#include "ACLStringData.h"
-#include "ACLChecklist.h"
+#include "acl/PeerName.h"
+#include "acl/StringData.h"
+#include "acl/Checklist.h"
 
 ACL::Prototype ACLPeerName::RegistryProtoype(&ACLPeerName::RegistryEntry_, "peername");
 
 ACLStrategised<const char *> ACLPeerName::RegistryEntry_(new ACLStringData, ACLPeerNameStrategy::Instance(), "peername");
 
 int
-ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     if (checklist->dst_peer != NULL && checklist->dst_peer->name != NULL)
         return data->match(checklist->dst_peer->name);
@@ -1,14 +1,14 @@
 #ifndef SQUID_ACLPEERNAME_H
 #define SQUID_ACLPEERNAME_H
 
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 class ACLPeerNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLPeerNameStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -34,9 +34,9 @@
  */
 
 #include "squid.h"
-#include "ACLProtocol.h"
-#include "ACLProtocolData.h"
-#include "ACLChecklist.h"
+#include "acl/Protocol.h"
+#include "acl/ProtocolData.h"
+#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 /* explicit template instantiation required for some systems */
@@ -48,7 +48,7 @@ ACL::Prototype ACLProtocol::RegistryProtoype(&ACLProtocol::RegistryEntry_, "prot
 ACLStrategised<protocol_t> ACLProtocol::RegistryEntry_(new ACLProtocolData, ACLProtocolStrategy::Instance(), "proto");
 
 int
-ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->request->protocol);
 }
@@ -35,14 +35,14 @@
 
 #ifndef SQUID_ACLPROTOCOL_H
 #define SQUID_ACLPROTOCOL_H
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 class ACLProtocolStrategy : public ACLStrategy<protocol_t>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLProtocolStrategy *Instance();
@@ -35,8 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLProtocolData.h"
-#include "ACLChecklist.h"
+#include "acl/ProtocolData.h"
+#include "acl/Checklist.h"
 #include "URLScheme.h"
 #include "wordlist.h"
 
@@ -35,8 +35,8 @@
 
 #ifndef SQUID_ACLPROTOCOLDATA_H
 #define SQUID_ACLPROTOCOLDATA_H
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 #include "CbDataList.h"
 
 class ACLProtocolData : public ACLData<protocol_t>
@@ -35,9 +35,9 @@
  */
 
 #include "squid.h"
-#include "ACLReferer.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
+#include "acl/Referer.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -35,10 +35,10 @@
 
 #ifndef SQUID_ACLREFERER_H
 #define SQUID_ACLREFERER_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLRequestHeaderStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/RequestHeaderStrategy.h"
+#include "acl/Strategised.h"
 
 class ACLReferer
 {
@@ -35,10 +35,9 @@
  */
 
 #include "squid.h"
-#include "ACLRegexData.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/RegexData.h"
+#include "acl/Checklist.h"
+#include "acl/Acl.h"
 #include "wordlist.h"
 #include "ConfigParser.h"
 
@@ -34,7 +34,7 @@
 #ifndef SQUID_ACLREGEXDATA_H
 #define SQUID_ACLREGEXDATA_H
 
-#include "ACLData.h"
+#include "acl/Data.h"
 #include "MemPool.h"
 
 /** \todo CLEANUP: break out relist, we don't need the rest. */
@@ -36,18 +36,18 @@
 
 class ACLChecklist;
 
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLStrategy.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategy.h"
+#include "acl/FilledChecklist.h"
 #include "HttpReply.h"
 
 template <http_hdr_type header>
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresReply() const {return true;}
 
     static ACLReplyHeaderStrategy *Instance();
@@ -65,7 +65,7 @@ class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 
 template <http_hdr_type header>
 int
-ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->reply->header.getStr(header);
 
@@ -35,9 +35,9 @@
  */
 
 #include "squid.h"
-#include "ACLReplyMIMEType.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
+#include "acl/ReplyMimeType.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -34,8 +34,8 @@
 #ifndef SQUID_ACLREPLYMIMETYPE_H
 #define SQUID_ACLREPLYMIMETYPE_H
 
-#include "ACL.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Strategised.h"
 
 class ACLReplyMIMEType
 {
@@ -47,13 +47,13 @@ class ACLReplyMIMEType
 
 /* partial specialisation */
 
-#include "ACLData.h"
-#include "ACLReplyHeaderStrategy.h"
-#include "ACLChecklist.h"
+#include "acl/Data.h"
+#include "acl/ReplyHeaderStrategy.h"
+#include "acl/Checklist.h"
 
 template <>
 inline int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLChecklist *checklist)
+ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
 
@@ -35,19 +35,19 @@
 
 #ifndef SQUID_ACLREQUESTHEADERSTRATEGY_H
 #define SQUID_ACLREQUESTHEADERSTRATEGY_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLStrategy.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategy.h"
 #include "HttpRequest.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 
 template <http_hdr_type header>
 
 class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLRequestHeaderStrategy *Instance();
@@ -65,7 +65,7 @@ class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 
 template <http_hdr_type header>
 int
-ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->request->header.getStr(header);
 
@@ -35,9 +35,9 @@
  */
 
 #include "squid.h"
-#include "ACLRequestMIMEType.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
+#include "acl/RequestMimeType.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -34,8 +34,8 @@
 #ifndef SQUID_ACLREQUESTMIMETYPE_H
 #define SQUID_ACLREQUESTMIMETYPE_H
 
-#include "ACL.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Strategised.h"
 
 class ACLRequestMIMEType
 {
@@ -47,13 +47,13 @@ class ACLRequestMIMEType
 
 /* partial specialisation */
 
-#include "ACLData.h"
-#include "ACLRequestHeaderStrategy.h"
-#include "ACLChecklist.h"
+#include "acl/Data.h"
+#include "acl/RequestHeaderStrategy.h"
+#include "acl/Checklist.h"
 
 template <>
 inline int
-ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
 
@@ -32,19 +32,19 @@
 #define SQUID_ACLSOURCEASN_H
 
 #if 0
-#include "ACLASN.h"
+#include "acl/Asn.h"
 #endif
 
 class ACLChecklist;
 
-#include "ACLStrategy.h"
+#include "acl/Strategy.h"
 #include "ip/IpAddress.h"
 
 class ACLSourceASNStrategy : public ACLStrategy<IpAddress>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLSourceASNStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -35,10 +35,10 @@
  */
 
 #include "squid.h"
-#include "ACLSourceDomain.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
-#include "ACLDomainData.h"
+#include "acl/SourceDomain.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
+#include "acl/DomainData.h"
 
 SourceDomainLookup SourceDomainLookup::instance_;
 
@@ -52,7 +52,7 @@ void
 SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 {
     checklist->asyncInProgress(true);
-    fqdncache_nbgethostbyaddr(checklist->src_addr, LookupDone, checklist);
+    fqdncache_nbgethostbyaddr(Filled(checklist)->src_addr, LookupDone, checklist);
 }
 
 void
@@ -63,7 +63,7 @@ SourceDomainLookup::LookupDone(const char *fqdn, void *data)
 
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->markSourceDomainChecked();
+    Filled(checklist)->markSourceDomainChecked();
     checklist->check();
 }
 
@@ -73,7 +73,7 @@ ACL::Prototype ACLSourceDomain::RegexRegistryProtoype(&ACLSourceDomain::RegexReg
 ACLStrategised<char const *> ACLSourceDomain::RegexRegistryEntry_(new ACLRegexData,ACLSourceDomainStrategy::Instance() ,"srcdom_regex");
 
 int
-ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     const char *fqdn = NULL;
     fqdn = fqdncache_gethostbyaddr(checklist->src_addr, FQDN_LOOKUP_IF_MISS);
@@ -35,16 +35,16 @@
 
 #ifndef SQUID_ACLSOURCEDOMAIN_H
 #define SQUID_ACLSOURCEDOMAIN_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLChecklist.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Checklist.h"
+#include "acl/Strategised.h"
 
 class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLSourceDomainStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -34,8 +34,8 @@
  */
 
 #include "squid.h"
-#include "ACLSourceIP.h"
-#include "ACLChecklist.h"
+#include "acl/SourceIp.h"
+#include "acl/FilledChecklist.h"
 
 char const *
 ACLSourceIP::typeString() const
@@ -46,7 +46,7 @@ ACLSourceIP::typeString() const
 int
 ACLSourceIP::match(ACLChecklist *checklist)
 {
-    return ACLIP::match(checklist->src_addr);
+    return ACLIP::match(Filled(checklist)->src_addr);
 }
 
 ACL::Prototype ACLSourceIP::RegistryProtoype(&ACLSourceIP::RegistryEntry_, "src");
@@ -34,7 +34,7 @@
 
 #ifndef SQUID_ACLSOURCEIP_H
 #define SQUID_ACLSOURCEIP_H
-#include "ACLIP.h"
+#include "acl/Ip.h"
 
 class ACLSourceIP : public ACLIP
 {
@@ -4,9 +4,9 @@
  */
 
 #include "squid.h"
-#include "ACLSslError.h"
-#include "ACLSslErrorData.h"
-#include "ACLChecklist.h"
+#include "acl/SslError.h"
+#include "acl/SslErrorData.h"
+#include "acl/Checklist.h"
 
 /* explicit template instantiation required for some systems */
 
@@ -17,7 +17,7 @@ ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_
 ACLStrategised<int> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
 
 int
-ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->ssl_error);
 }
@@ -5,14 +5,14 @@
 
 #ifndef SQUID_ACLSSL_ERROR_H
 #define SQUID_ACLSSL_ERROR_H
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 class ACLSslErrorStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLSslErrorStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -3,8 +3,8 @@
  */
 
 #include "squid.h"
-#include "ACLSslErrorData.h"
-#include "ACLChecklist.h"
+#include "acl/SslErrorData.h"
+#include "acl/Checklist.h"
 #include "wordlist.h"
 
 ACLSslErrorData::ACLSslErrorData() : values (NULL)
@@ -5,8 +5,8 @@
 
 #ifndef SQUID_ACLSSL_ERRORDATA_H
 #define SQUID_ACLSSL_ERRORDATA_H
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 #include "CbDataList.h"
 #include "ssl_support.h"
 
@@ -35,11 +35,7 @@
  */
 
 #include "squid.h"
-#include "ACLStrategised.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
-#include "ACLDomainData.h"
+#include "acl/Strategised.h"
 
 /*
  *  moved template instantiation into ACLStrategized.cc
@@ -49,7 +45,7 @@
 
 /* explicit template instantiation required for some systems */
 
-/* ACLHTTPRepHeader + ACLHTTPReqHeader */
+/* XXX: move to ACLHTTPRepHeader or ACLHTTPReqHeader */
 template class ACLStrategised<HttpHeader*>;
 
 /* ACLMyPortName + ACLMyPeerName + ACLBrowser */
@@ -35,9 +35,10 @@
 
 #ifndef SQUID_ACLSTRATEGISED_H
 #define SQUID_ACLSTRATEGISED_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLStrategy.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategy.h"
+#include "acl/FilledChecklist.h"
 
 template <class M>
 
@@ -147,8 +148,10 @@ ACLStrategised<MatchType>::empty() const
 
 template <class MatchType>
 int
-ACLStrategised<MatchType>::match(ACLChecklist *checklist)
+ACLStrategised<MatchType>::match(ACLChecklist *cl)
 {
+	ACLFilledChecklist *checklist = dynamic_cast<ACLFilledChecklist*>(cl);
+	assert(checklist);
     return matcher->match(data, checklist);
 }
 
@@ -35,10 +35,10 @@
 
 #ifndef SQUID_ACLSTRATEGY_H
 #define SQUID_ACLSTRATEGY_H
-#include "ACL.h"
-#include "ACLData.h"
 
-/* Perhaps this should live in ACL? */
+#include "acl/Data.h"
+
+class ACLFilledChecklist;
 
 template<class M>
 
@@ -47,7 +47,7 @@ class ACLStrategy
 
 public:
     typedef M MatchType;
-    virtual int match (ACLData<M> * &, ACLChecklist *) = 0;
+    virtual int match (ACLData<M> * &, ACLFilledChecklist *) = 0;
     virtual bool requiresRequest() const {return false;}
 
     virtual bool requiresReply() const {return false;}
@@ -35,8 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLStringData.h"
-#include "ACLChecklist.h"
+#include "acl/StringData.h"
+#include "acl/Checklist.h"
 #include "wordlist.h"
 
 
@@ -36,8 +36,8 @@
 #ifndef SQUID_ACLSTRINGDATA_H
 #define SQUID_ACLSTRINGDATA_H
 #include "splay.h"
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 
 
 class ACLStringData : public ACLData<char const *>
@@ -35,15 +35,15 @@
  */
 
 #include "squid.h"
-#include "ACLTime.h"
-#include "ACLTimeData.h"
+#include "acl/Time.h"
+#include "acl/TimeData.h"
 #include "SquidTime.h"
 
 ACL::Prototype ACLTime::RegistryProtoype(&ACLTime::RegistryEntry_, "time");
 ACLStrategised<time_t> ACLTime::RegistryEntry_(new ACLTimeData, ACLTimeStrategy::Instance(), "time");
 
 int
-ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (squid_curtime);
 }
@@ -35,16 +35,17 @@
 
 #ifndef SQUID_ACLTIME_H
 #define SQUID_ACLTIME_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLChecklist.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategised.h"
+
+class ACLChecklist; // XXX: we do not need it
 
 class ACLTimeStrategy : public ACLStrategy<time_t>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLTimeStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -35,9 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLTimeData.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
+#include "acl/TimeData.h"
+#include "acl/Checklist.h"
 #include "wordlist.h"
 
 ACLTimeData::ACLTimeData () : weekbits (0), start (0), stop (0), next (NULL) {}
@@ -36,8 +36,8 @@
 #ifndef SQUID_ACLTIMEDATA_H
 #define SQUID_ACLTIMEDATA_H
 #include "splay.h"
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 
 class ACLTimeData : public ACLData<time_t>
 {
@@ -35,15 +35,15 @@
  */
 
 #include "squid.h"
-#include "ACLUrl.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
+#include "acl/Url.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
 
 ACL::Prototype ACLUrl::RegistryProtoype(&ACLUrl::RegistryEntry_, "url_regex");
 ACLStrategised<char const *> ACLUrl::RegistryEntry_(new ACLRegexData, ACLUrlStrategy::Instance(), "url_regex");
 
 int
-ACLUrlStrategy::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char *esc_buf = xstrdup(urlCanonical(checklist->request));
     rfc1738_unescape(esc_buf);
@@ -35,15 +35,15 @@
 
 #ifndef SQUID_ACLURL_H
 #define SQUID_ACLURL_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategised.h"
 
 class ACLUrlStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlStrategy *Instance();
@@ -35,17 +35,17 @@
  */
 
 #include "squid.h"
-#include "ACLUrlPath.h"
-#include "ACLChecklist.h"
-#include "ACLRegexData.h"
+#include "acl/UrlPath.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
 #include "HttpRequest.h"
 
 ACL::Prototype ACLUrlPath::LegacyRegistryProtoype(&ACLUrlPath::RegistryEntry_, "pattern");
 ACL::Prototype ACLUrlPath::RegistryProtoype(&ACLUrlPath::RegistryEntry_, "urlpath_regex");
 ACLStrategised<char const *> ACLUrlPath::RegistryEntry_(new ACLRegexData, ACLUrlPathStrategy::Instance(), "urlpath_regex");
 
 int
-ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
 {
     char *esc_buf = xstrdup(checklist->request->urlpath.termedBuf());
     rfc1738_unescape(esc_buf);
@@ -35,16 +35,16 @@
 
 #ifndef SQUID_ACLURLPATH_H
 #define SQUID_ACLURLPATH_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 class ACLUrlPathStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlPathStrategy *Instance();
@@ -34,16 +34,16 @@
  */
 
 #include "squid.h"
-#include "ACLUrlPort.h"
-#include "ACLIntRange.h"
-#include "ACLChecklist.h"
+#include "acl/UrlPort.h"
+#include "acl/IntRange.h"
+#include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 ACL::Prototype ACLUrlPort::RegistryProtoype(&ACLUrlPort::RegistryEntry_, "port");
 ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrategy::Instance(), "port");
 
 int
-ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->request->port);
 }
@@ -35,14 +35,14 @@
 
 #ifndef SQUID_ACLURLPORT_H
 #define SQUID_ACLURLPORT_H
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
 
 class ACLUrlPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlPortStrategy *Instance();
@@ -35,9 +35,8 @@
  */
 
 #include "squid.h"
-#include "ACLUserData.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
+#include "acl/UserData.h"
+#include "acl/Checklist.h"
 #include "wordlist.h"
 #include "ConfigParser.h"
 
@@ -36,8 +36,8 @@
 #ifndef SQUID_ACLUSERDATA_H
 #define SQUID_ACLUSERDATA_H
 #include "splay.h"
-#include "ACL.h"
-#include "ACLData.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
 
 class ACLUserData : public ACLData<char const *>
 {
@@ -2,10 +2,9 @@
 #include "structs.h"
 
 #include "ConfigParser.h"
-#include "ACL.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
 #include "adaptation/AccessRule.h"
@@ -106,7 +105,7 @@ Adaptation::AccessCheck::checkCandidates()
         if (AccessRule *r = FindRule(topCandidate())) {
             /* BUG 2526: what to do when r->acl is empty?? */
             // XXX: we do not have access to conn->rfc931 here.
-            acl_checklist = aclChecklistCreate(r->acl, req, dash_str);
+            acl_checklist = new ACLFilledChecklist(r->acl, req, dash_str);
             acl_checklist->reply = rep ? HTTPMSGLOCK(rep) : NULL;
             acl_checklist->nonBlockingCheck(AccessCheckCallbackWrapper, this);
             return;
@@ -7,6 +7,7 @@
 
 class HttpRequest;
 class HttpReply;
+class ACLFilledChecklist;
 
 namespace Adaptation
 {
@@ -35,7 +36,7 @@ class AccessCheck: public virtual AsyncJob
     HttpReply *rep;
     AccessCheckCallback *callback;
     void *callback_data;
-    ACLChecklist *acl_checklist;
+    ACLFilledChecklist *acl_checklist;
 
     typedef int Candidate;
     typedef Vector<Candidate> Candidates;
@@ -2,7 +2,7 @@
 #include "structs.h"
 
 #include "ConfigParser.h"
-#include "ACL.h"
+#include "acl/Gadgets.h"
 #include "adaptation/AccessRule.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
@@ -34,7 +34,7 @@
 #include "structs.h"
 
 #include "ConfigParser.h"
-#include "ACL.h"
+#include "acl/Gadgets.h"
 #include "Store.h"
 #include "Array.h"    // really Vector
 #include "adaptation/Config.h"
@@ -35,14 +35,12 @@
 #include "squid.h"
 
 #include "ConfigParser.h"
-#include "ACL.h"
 #include "Store.h"
 #include "Array.h"	// really Vector
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
-#include "ACLChecklist.h"
 #include "wordlist.h"
 
 Adaptation::Icap::Config Adaptation::Icap::TheConfig;
@@ -39,11 +39,11 @@
 #include "HttpRequest.h"
 #include "StoreClient.h"
 #include "Store.h"
-#include "ACL.h"
-#include "ACLASN.h"
-#include "ACLSourceASN.h"
-#include "ACLDestinationASN.h"
-#include "ACLDestinationIP.h"
+#include "acl/Acl.h"
+#include "acl/Asn.h"
+#include "acl/SourceAsn.h"
+#include "acl/DestinationAsn.h"
+#include "acl/DestinationIp.h"
 #include "HttpReply.h"
 #include "forward.h"
 #include "wordlist.h"
@@ -605,7 +605,7 @@ ACL::Prototype ACLASN::DestinationRegistryProtoype(&ACLASN::DestinationRegistryE
 ACLStrategised<IpAddress> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
 
 int
-ACLSourceASNStrategy::match (ACLData<IpAddress> * &data, ACLChecklist *checklist)
+ACLSourceASNStrategy::match (ACLData<IpAddress> * &data, ACLFilledChecklist *checklist)
 {
     return data->match(checklist->src_addr);
 }
@@ -620,7 +620,7 @@ ACLSourceASNStrategy ACLSourceASNStrategy::Instance_;
 
 
 int
-ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
@@ -0,0 +1,78 @@
+#include "squid.h"
+#include "acl/Acl.h"
+#include "acl/FilledChecklist.h"
+#include "auth/UserRequest.h"
+#include "auth/Acl.h"
+#include "auth/AclProxyAuth.h"
+#include "HttpRequest.h"
+
+/** retval -1 user not authenticated (authentication error?)
+    retval  0 user not authorized OR user authentication is in pgrogress
+    retval +1 user authenticated and authorized */
+int
+AuthenticateAcl(ACLChecklist *ch)
+{
+	ACLFilledChecklist *checklist = Filled(ch);
+	HttpRequest *request = checklist->request;
+    http_hdr_type headertype;
+
+    if (NULL == request) {
+        fatal ("requiresRequest SHOULD have been true for this ACL!!");
+        return 0;
+    } else if (request->flags.accelerated) {
+        /* WWW authorization on accelerated requests */
+        headertype = HDR_AUTHORIZATION;
+    } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
+        debugs(28, DBG_IMPORTANT, HERE << " authentication not applicable on intercepted requests.");
+        return -1;
+    } else {
+        /* Proxy authorization on proxy requests */
+        headertype = HDR_PROXY_AUTHORIZATION;
+    }
+
+    /* get authed here */
+    /* Note: this fills in auth_user_request when applicable */
+    /*
+     * DPW 2007-05-08
+     * tryToAuthenticateAndSetAuthUser used to try to lock and
+     * unlock auth_user_request on our behalf, but it was too
+     * ugly and hard to follow.  Now we do our own locking here.
+     *
+     * I'm not sure what tryToAuthenticateAndSetAuthUser does when
+     * auth_user_request is set before calling.  I'm tempted to
+     * unlock and set it to NULL, but it seems safer to save the
+     * pointer before calling and unlock it afterwards.  If the
+     * pointer doesn't change then its a no-op.
+     */
+    AuthUserRequest *old_auth_user_request = checklist->auth_user_request;
+    const auth_acl_t result = AuthUserRequest::tryToAuthenticateAndSetAuthUser(
+        &checklist->auth_user_request, headertype, request, 
+        checklist->conn(), checklist->src_addr);
+    if (checklist->auth_user_request)
+        AUTHUSERREQUESTLOCK(checklist->auth_user_request, "ACLAuth::authenticated");
+    AUTHUSERREQUESTUNLOCK(old_auth_user_request, "old ACLAuth");
+    switch (result) {
+
+    case AUTH_ACL_CANNOT_AUTHENTICATE:
+        debugs(28, 4, HERE << "returning  0 user authenticated but not authorised.");
+        return 0;
+
+    case AUTH_AUTHENTICATED:
+        return 1;
+        break;
+
+    case AUTH_ACL_HELPER:
+        debugs(28, 4, HERE << "returning 0 sending credentials to helper.");
+        checklist->changeState(ProxyAuthLookup::Instance());
+        return 0;
+
+    case AUTH_ACL_CHALLENGE:
+        debugs(28, 4, HERE << "returning 0 sending authentication challenge.");
+        checklist->changeState (ProxyAuthNeeded::Instance());
+        return 0;
+
+    default:
+        fatal("unexpected authenticateAuthenticate reply\n");
+        return 0;
+    }
+}
@@ -0,0 +1,12 @@
+#ifndef SQUID_AUTH_ACL_H
+#define SQUID_AUTH_ACL_H
+
+// ACL-related code used by authentication-related code. This code is not in
+// auth/Gadgets to avoid making auth/libauth dependent on acl/libstate because
+// acl/libstate already depends on auth/libauth.
+
+class ACLChecklist;
+/// \ingroup AuthAPI
+extern int AuthenticateAcl(ACLChecklist *ch);
+
+#endif /* SQUID_AUTH_ACL_H */
@@ -35,9 +35,10 @@
  */
 
 #include "squid.h"
-#include "ACLMaxUserIP.h"
+#include "acl/FilledChecklist.h"
+#include "auth/Acl.h"
+#include "auth/AclMaxUserIp.h"
 #include "auth/UserRequest.h"
-#include "authenticate.h"
 #include "wordlist.h"
 #include "ConfigParser.h"
 
@@ -152,11 +153,12 @@ ACLMaxUserIP::match(AuthUserRequest * auth_user_request,
 }
 
 int
-ACLMaxUserIP::match(ACLChecklist *checklist)
+ACLMaxUserIP::match(ACLChecklist *cl)
 {
+    ACLFilledChecklist *checklist = Filled(cl);
     int ti;
 
-    if ((ti = checklist->authenticated()) != 1)
+    if ((ti = AuthenticateAcl(checklist)) != 1)
         return ti;
 
     ti = match(checklist->auth_user_request, checklist->src_addr);
@@ -35,8 +35,10 @@
 #ifndef SQUID_ACLMAXUSERIP_H
 #define SQUID_ACLMAXUSERIP_H
 
-#include "ACL.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
+
+class AuthUserRequest;
 
 /// \ingroup ACLAPI
 class ACLMaxUserIP : public ACL
@@ -35,13 +35,14 @@
  */
 
 #include "squid.h"
-#include "ACLProxyAuth.h"
-#include "authenticate.h"
-#include "ACLChecklist.h"
-#include "ACLUserData.h"
-#include "ACLRegexData.h"
+#include "auth/AclProxyAuth.h"
+#include "auth/Gadgets.h"
+#include "acl/FilledChecklist.h"
+#include "acl/UserData.h"
+#include "acl/RegexData.h"
 #include "client_side.h"
 #include "HttpRequest.h"
+#include "auth/Acl.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 
@@ -80,7 +81,7 @@ ACLProxyAuth::match(ACLChecklist *checklist)
 {
     int ti;
 
-    if ((ti = checklist->authenticated()) != 1)
+    if ((ti = AuthenticateAcl(checklist)) != 1)
         return ti;
 
     ti = matchProxyAuth(checklist);
@@ -133,8 +134,10 @@ ProxyAuthLookup::Instance()
 }
 
 void
-ProxyAuthLookup::checkForAsync(ACLChecklist *checklist)const
+ProxyAuthLookup::checkForAsync(ACLChecklist *cl)const
 {
+    ACLFilledChecklist *checklist = Filled(cl);
+
     checklist->asyncInProgress(true);
     debugs(28, 3, "ACLChecklist::checkForAsync: checking password via authenticator");
 
@@ -150,7 +153,8 @@ ProxyAuthLookup::checkForAsync(ACLChecklist *checklist)const
 void
 ProxyAuthLookup::LookupDone(void *data, char *result)
 {
-    ACLChecklist *checklist = (ACLChecklist *)data;
+    ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
+
     assert (checklist->asyncState() == ProxyAuthLookup::Instance());
 
     if (result != NULL)
@@ -198,8 +202,9 @@ ACLProxyAuth::clone() const
 }
 
 int
-ACLProxyAuth::matchForCache(ACLChecklist *checklist)
+ACLProxyAuth::matchForCache(ACLChecklist *cl)
 {
+    ACLFilledChecklist *checklist = Filled(cl);
     assert (checklist->auth_user_request);
     return data->match(checklist->auth_user_request->username());
 }
@@ -209,8 +214,9 @@ ACLProxyAuth::matchForCache(ACLChecklist *checklist)
  * 1 : Authorisation OK. (Matched)
  */
 int
-ACLProxyAuth::matchProxyAuth(ACLChecklist *checklist)
+ACLProxyAuth::matchProxyAuth(ACLChecklist *cl)
 {
+    ACLFilledChecklist *checklist = Filled(cl);
     checkAuthForCaching(checklist);
     /* check to see if we have matched the user-acl before */
     int result = cacheMatchAcl(&checklist->auth_user_request->user()->
@@ -224,7 +230,7 @@ ACLProxyAuth::checkAuthForCaching(ACLChecklist *checklist)const
 {
     /* for completeness */
     /* consistent parameters ? */
-    assert(authenticateUserAuthenticated(checklist->auth_user_request));
+    assert(authenticateUserAuthenticated(Filled(checklist)->auth_user_request));
     /* this check completed */
 }
 
@@ -34,9 +34,9 @@
 
 #ifndef SQUID_ACLPROXYAUTH_H
 #define SQUID_ACLPROXYAUTH_H
-#include "ACL.h"
-#include "ACLData.h"
-#include "ACLChecklist.h"
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Checklist.h"
 
 class ProxyAuthLookup : public ACLChecklist::AsyncState
 {
@@ -38,12 +38,15 @@
  * See acl.c for access control and client_side.c for auditing */
 
 #include "squid.h"
-#include "authenticate.h"
-#include "ACL.h"
+#include "acl/Acl.h"
+#include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "auth/Config.h"
 #include "auth/Scheme.h"
+#include "auth/Gadgets.h"
 #include "auth/User.h"
+#include "auth/UserRequest.h"
+#include "auth/AclProxyAuth.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -30,10 +30,12 @@
  *
  */
 
-#ifndef SQUID_AUTHENTICATE_H
-#define SQUID_AUTHENTICATE_H
+#ifndef SQUID_AUTH_GADGETS_H
+#define SQUID_AUTH_GADGETS_H
 
-#include "client_side.h"
+#include "hash.h"
+#include "MemPool.h"
+#include "typedefs.h" /* for authConfig */
 
 class AuthUser;
 
@@ -65,6 +67,7 @@ MEMPROXY_CLASS_INLINE(AuthUserHashPointer);
 
 class ConnStateData;
 class AuthScheme;
+class StoreEntry;
 
 /**
  \ingroup AuthAPI
@@ -98,4 +101,4 @@ extern void authenticateUserCacheRestart(void);
 /// \ingroup AuthAPI
 extern void authenticateOnCloseConnection(ConnStateData * conn);
 
-#endif /* SQUID_AUTHENTICATE_H */
+#endif /* SQUID_AUTH_GADGETS_H */
@@ -1,11 +1,10 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_LIBRARIES	= libbasic.a libdigest.a libntlm.a libnegotiate.a
-noinst_LIBRARIES = libauth.a @AUTH_LIBS_TO_BUILD@
+noinst_LTLIBRARIES = libauth.la libacls.la @AUTH_LIBS_TO_BUILD@
+EXTRA_LTLIBRARIES = libbasic.la libdigest.la libntlm.la libnegotiate.la
 
 ## authentication framework; this library is always built
-## TODO: use libtool and add @AUTH_LIBS_TO_BUILD@ to libauth.la
-libauth_a_SOURCES = \
+libauth_la_SOURCES = \
 	Config.cc \
 	Config.h \
 	Scheme.cc \
@@ -14,27 +13,43 @@ libauth_a_SOURCES = \
 	User.cci \
 	User.cc \
 	UserRequest.h \
-	UserRequest.cc
+	UserRequest.cc \
+	Gadgets.cc \
+	Gadgets.h
 
-libbasic_a_SOURCES = \
+libauth_la_LIBADD = @AUTH_LIBS_TO_BUILD@
+libauth_la_DEPENDENCIES = @AUTH_LIBS_TO_BUILD@
+
+## authentication-dependent ACLs and authentication code they share
+libacls_la_SOURCES = \
+	Acl.cc \
+	Acl.h \
+	\
+	AclMaxUserIp.cc \
+	AclMaxUserIp.h \
+	AclProxyAuth.cc \
+	AclProxyAuth.h	
+
+
+libbasic_la_SOURCES = \
 	basic/basicScheme.cc \
 	basic/basicScheme.h \
 	basic/auth_basic.cc \
 	basic/auth_basic.h
 
-libdigest_a_SOURCES = \
+libdigest_la_SOURCES = \
 	digest/digestScheme.cc \
 	digest/digestScheme.h \
 	digest/auth_digest.cc \
 	digest/auth_digest.h
 
-libntlm_a_SOURCES = \
+libntlm_la_SOURCES = \
 	ntlm/ntlmScheme.cc \
 	ntlm/ntlmScheme.h \
 	ntlm/auth_ntlm.cc \
 	ntlm/auth_ntlm.h
 
-libnegotiate_a_SOURCES = \
+libnegotiate_la_SOURCES = \
 	negotiate/negotiateScheme.cc \
 	negotiate/negotiateScheme.h \
 	negotiate/auth_negotiate.cc \
@@ -36,7 +36,7 @@
 
 #include "squid.h"
 #include "auth/Scheme.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "auth/Config.h"
 
 Vector<AuthScheme*> *AuthScheme::_Schemes = NULL;
@@ -37,8 +37,9 @@
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "auth/Config.h"
-#include "authenticate.h"
-#include "ACL.h"
+#include "auth/Gadgets.h"
+#include "acl/Acl.h"
+#include "acl/Gadgets.h"
 #include "event.h"
 #include "SquidTime.h"
 
@@ -43,8 +43,8 @@
 #include "squid.h"
 #include "auth/UserRequest.h"
 #include "auth/User.h"
-/*#include "authenticate.h"
-#include "ACL.h"
+/*#include "auth/Gadgets.h"
+#include "acl/Acl.h"
 #include "client_side.h"
 */
 #include "auth/Config.h"
@@ -39,7 +39,7 @@
 
 #include "squid.h"
 #include "auth_basic.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "CacheManager.h"
 #include "Store.h"
 #include "HttpReply.h"
@@ -5,7 +5,7 @@
 
 #ifndef __AUTH_BASIC_H__
 #define __AUTH_BASIC_H__
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "auth/Config.h"
@@ -40,7 +40,7 @@
 #include "squid.h"
 #include "rfc2617.h"
 #include "auth_digest.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "event.h"
 #include "CacheManager.h"
 #include "Store.h"
@@ -6,7 +6,7 @@
 #ifndef __AUTH_DIGEST_H__
 #define __AUTH_DIGEST_H__
 #include "rfc2617.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "auth/Config.h"
@@ -39,7 +39,7 @@
 
 #include "squid.h"
 #include "auth_negotiate.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "CacheManager.h"
 #include "Store.h"
 #include "client_side.h"
@@ -5,7 +5,7 @@
 
 #ifndef __AUTH_NEGOTIATE_H__
 #define __AUTH_NEGOTIATE_H__
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "auth/Config.h"
@@ -39,7 +39,7 @@
 
 #include "squid.h"
 #include "auth_ntlm.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "CacheManager.h"
 #include "Store.h"
 #include "client_side.h"
@@ -5,7 +5,7 @@
 
 #ifndef __AUTH_NTLM_H__
 #define __AUTH_NTLM_H__
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "auth/Config.h"
@@ -33,7 +33,6 @@
  */
 
 #include "squid.h"
-#include "authenticate.h"
 #include "ProtoPort.h"
 #include "HttpRequestMethod.h"
 #include "auth/Config.h"
@@ -42,7 +41,8 @@
 #include "Store.h"
 #include "SwapDir.h"
 #include "ConfigParser.h"
-#include "ACL.h"
+#include "acl/Acl.h"
+#include "acl/Gadgets.h"
 #include "StoreFileSystem.h"
 #include "Parsing.h"
 #include "MemBuf.h"
@@ -96,7 +96,7 @@
 #include "MemObject.h"
 #include "fde.h"
 #include "client_side_request.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "ConnectionDetail.h"
 #include "client_side_reply.h"
 #include "ClientRequestContext.h"
@@ -527,7 +527,7 @@ ClientHttpRequest::logRequest()
 
 #endif
 
-        ACLChecklist *checklist = clientAclChecklistCreate(Config.accessList.log, this);
+        ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.log, this);
 
         if (al.reply)
             checklist->reply = HTTPMSGLOCK(al.reply);
@@ -2874,12 +2874,9 @@ httpAccept(int sock, int newfd, ConnectionDetail *details,
 #if USE_IDENT
 
     if (Config.accessList.identLookup) {
-        ACLChecklist identChecklist;
+        ACLFilledChecklist identChecklist(Config.accessList.identLookup, NULL, NULL);
         identChecklist.src_addr = details->peer;
         identChecklist.my_addr = details->me;
-        identChecklist.accessList = cbdataReference(Config.accessList.identLookup);
-
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
         if (identChecklist.fastCheck())
             identStart(details->me, details->peer, clientIdentDone, connState);
     }
@@ -3089,12 +3086,9 @@ httpsAccept(int sock, int newfd, ConnectionDetail *details,
 #if USE_IDENT
 
     if (Config.accessList.identLookup) {
-        ACLChecklist identChecklist;
+        ACLFilledChecklist identChecklist(Config.accessList.identLookup, NULL, NULL);
         identChecklist.src_addr = details->peer;
         identChecklist.my_addr = details->me;
-        identChecklist.accessList = cbdataReference(Config.accessList.identLookup);
-
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
         if (identChecklist.fastCheck())
             identStart(details->me, details->peer, clientIdentDone, connState);
     }
@@ -3345,12 +3339,12 @@ varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
     }
 }
 
-ACLChecklist *
+ACLFilledChecklist *
 clientAclChecklistCreate(const acl_access * acl, ClientHttpRequest * http)
 {
-    ACLChecklist *ch;
     ConnStateData * conn = http->getConn();
-    ch = aclChecklistCreate(acl, http->request, cbdataReferenceValid(conn) && conn != NULL ? conn->rfc931 : dash_str);
+    ACLFilledChecklist *ch = new ACLFilledChecklist(acl, http->request,
+        cbdataReferenceValid(conn) && conn != NULL ? conn->rfc931 : dash_str);
 
     /*
      * hack for ident ACL. It needs to get full addresses, and a place to store
@@ -3365,7 +3359,7 @@ clientAclChecklistCreate(const acl_access * acl, ClientHttpRequest * http)
      */
 
     if (conn != NULL)
-        ch->conn(conn);	/* unreferenced in acl.cc */
+        ch->conn(conn);	/* unreferenced in FilledCheckList.cc */
 
     return ch;
 }
@@ -52,8 +52,8 @@
 #endif
 #include "MemObject.h"
 #include "fde.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Gadgets.h"
 #if DELAY_POOLS
 #include "DelayPools.h"
 #endif
@@ -1785,8 +1785,8 @@ clientReplyContext::processReplyAccess ()
     }
 
     /** Process http_reply_access lists */
-    ACLChecklist *replyChecklist;
-    replyChecklist = clientAclChecklistCreate(Config.accessList.reply, http);
+    ACLFilledChecklist *replyChecklist =
+        clientAclChecklistCreate(Config.accessList.reply, http);
     replyChecklist->reply = HTTPMSGLOCK(reply);
     replyChecklist->nonBlockingCheck(ProcessReplyAccessResult, this);
 }
@@ -48,8 +48,8 @@
 #include "auth/UserRequest.h"
 #include "HttpRequest.h"
 #include "ProtoPort.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Gadgets.h"
 #include "client_side.h"
 #include "client_side_reply.h"
 #include "Store.h"
@@ -1113,12 +1113,9 @@ ClientHttpRequest::sslBumpNeeded() const
 
     debugs(85, 5, HERE << "SslBump possible, checking ACL");
 
-    ACLChecklist check;
+    ACLFilledChecklist check(Config.accessList.ssl_bump, request, NULL);
     check.src_addr = request->client_addr;
     check.my_addr = request->my_addr;
-    check.request = HTTPMSGLOCK(request);
-    check.accessList = cbdataReference(Config.accessList.ssl_bump);
-    /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
     return check.fastCheck() == 1;
 }
 
@@ -1285,10 +1282,9 @@ ClientHttpRequest::doCallouts()
     if (!calloutContext->clientside_tos_done) {
         calloutContext->clientside_tos_done = true;
         if (getConn() != NULL) {
-            ACLChecklist ch;
+            ACLFilledChecklist ch(NULL, request, NULL);
             ch.src_addr = request->client_addr;
             ch.my_addr = request->my_addr;
-            ch.request = HTTPMSGLOCK(request);
             int tos = aclMapTOS(Config.accessList.clientside_tos, &ch);
             if (tos)
                 comm_set_tos(getConn()->fd, tos);
@@ -187,7 +187,9 @@ class ClientHttpRequest
 
 /* client http based routines */
 SQUIDCEXTERN char *clientConstructTraceEcho(ClientHttpRequest *);
-SQUIDCEXTERN ACLChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
+
+class ACLFilledChecklist;
+SQUIDCEXTERN ACLFilledChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
 SQUIDCEXTERN int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
 SQUIDCEXTERN void clientAccessCheck(ClientHttpRequest *);
 
@@ -48,15 +48,16 @@
 #include "SquidTime.h"
 #include "Store.h"
 #include "fde.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Acl.h"
 #if USE_IDENT
-#include "ACLIdent.h"
+#include "acl/Ident.h"
 #endif
 #include "client_side.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
-#include "authenticate.h"
+#include "auth/Acl.h"
+#include "auth/Gadgets.h"
 #include "helper.h"
 #include "MemBuf.h"
 #include "URLScheme.h"
@@ -71,7 +72,7 @@
 
 typedef struct _external_acl_format external_acl_format;
 
-static char *makeExternalAclKey(ACLChecklist * ch, external_acl_data * acl_data);
+static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
 static void external_acl_cache_delete(external_acl * def, external_acl_entry * entry);
 static int external_acl_entry_expired(external_acl * def, external_acl_entry * entry);
 static int external_acl_grace_expired(external_acl * def, external_acl_entry * entry);
@@ -677,9 +678,7 @@ ACLExternal::~ACLExternal()
 }
 
 static int
-aclMatchExternal(external_acl_data *acl, ACLChecklist * ch);
-static int
-aclMatchExternal(external_acl_data *acl, ACLChecklist * ch)
+aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 {
     int result;
     external_acl_entry *entry;
@@ -705,7 +704,7 @@ aclMatchExternal(external_acl_data *acl, ACLChecklist * ch)
             int ti;
             /* Make sure the user is authenticated */
 
-            if ((ti = ch->authenticated()) != 1) {
+            if ((ti = AuthenticateAcl(ch)) != 1) {
                 debugs(82, 2, "aclMatchExternal: " << acl->def->name << " user not authenticated (" << ti << ")");
                 return ti;
             }
@@ -777,7 +776,7 @@ aclMatchExternal(external_acl_data *acl, ACLChecklist * ch)
 int
 ACLExternal::match(ACLChecklist *checklist)
 {
-    return aclMatchExternal (data, checklist);
+    return aclMatchExternal (data, Filled(checklist));
 }
 
 wordlist *
@@ -811,7 +810,7 @@ external_acl_cache_touch(external_acl * def, external_acl_entry * entry)
 }
 
 static char *
-makeExternalAclKey(ACLChecklist * ch, external_acl_data * acl_data)
+makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 {
     static MemBuf mb;
     char buf[256];
@@ -1216,7 +1215,7 @@ externalAclHandleReply(void *data, char *reply)
 }
 
 void
-ACLExternal::ExternalAclLookup(ACLChecklist * ch, ACLExternal * me, EAH * callback, void *callback_data)
+ACLExternal::ExternalAclLookup(ACLChecklist *checklist, ACLExternal * me, EAH * callback, void *callback_data)
 {
     MemBuf buf;
     external_acl_data *acl = me->data;
@@ -1226,11 +1225,12 @@ ACLExternal::ExternalAclLookup(ACLChecklist * ch, ACLExternal * me, EAH * callba
     externalAclState *oldstate = NULL;
     bool graceful = 0;
 
+    ACLFilledChecklist *ch = Filled(checklist);
     if (acl->def->require_auth) {
         int ti;
         /* Make sure the user is authenticated */
 
-        if ((ti = ch->authenticated()) != 1) {
+        if ((ti = AuthenticateAcl(ch)) != 1) {
             debugs(82, 1, "externalAclLookup: " << acl->def->name <<
                    " user authentication failure (" << ti << ", ch=" << ch << ")");
             callback(callback_data, NULL);
@@ -1434,7 +1434,7 @@ ExternalACLLookup::checkForAsync(ACLChecklist *checklist)const
 void
 ExternalACLLookup::LookupDone(void *data, void *result)
 {
-    ACLChecklist *checklist = (ACLChecklist *)data;
+    ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
     checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
@@ -33,8 +33,8 @@
 
 #include "squid.h"
 #include "forward.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Gadgets.h"
 #include "CacheManager.h"
 #include "event.h"
 #include "errorpage.h"
@@ -205,12 +205,9 @@ FwdState::fwdStart(int client_fd, StoreEntry *entry, HttpRequest *request)
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          */
-        ACLChecklist ch;
+        ACLFilledChecklist ch(Config.accessList.miss, request, NULL);
         ch.src_addr = request->client_addr;
         ch.my_addr = request->my_addr;
-        ch.request = HTTPMSGLOCK(request);
-        ch.accessList = cbdataReference(Config.accessList.miss);
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
         int answer = ch.fastCheck();
 
         if (answer == 0) {
@@ -664,7 +661,7 @@ FwdState::initiateSSL()
     // Create the ACL check list now, while we have access to more info.
     // The list is used in ssl_verify_cb() and is freed in ssl_free().
     if (acl_access *acl = Config.ssl_client.cert_error) {
-        ACLChecklist *check = aclChecklistCreate(acl, request, dash_str);
+        ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
         check->fd(fd);
         SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
     }
@@ -1341,21 +1338,19 @@ aclMapTOS(acl_tos * head, ACLChecklist * ch)
 IpAddress
 getOutgoingAddr(HttpRequest * request, struct peer *dst_peer)
 {
-    ACLChecklist ch;
-
     if (request && request->flags.spoof_client_ip)
         return request->client_addr;
 
     if (!Config.accessList.outgoing_address) {
         return IpAddress(); // anything will do.
     }
 
+    ACLFilledChecklist ch(NULL, request, NULL);
     ch.dst_peer = dst_peer;
 
     if (request) {
         ch.src_addr = request->client_addr;
         ch.my_addr = request->my_addr;
-        ch.request = HTTPMSGLOCK(request);
     }
 
     return aclMapAddr(Config.accessList.outgoing_address, &ch);
@@ -1364,12 +1359,11 @@ getOutgoingAddr(HttpRequest * request, struct peer *dst_peer)
 unsigned long
 getOutgoingTOS(HttpRequest * request)
 {
-    ACLChecklist ch;
+    ACLFilledChecklist ch(NULL, request, NULL);
 
     if (request) {
         ch.src_addr = request->client_addr;
         ch.my_addr = request->my_addr;
-        ch.request = HTTPMSGLOCK(request);
     }
 
     return aclMapTOS(Config.accessList.outgoing_tos, &ch);
@@ -35,8 +35,8 @@
 
 #include "squid.h"
 #include "htcp.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Acl.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -850,12 +850,9 @@ htcpAccessCheck(acl_access * acl, htcpSpecifier * s, IpAddress &from)
     if (!acl)
         return 0;
 
-    ACLChecklist checklist;
+    ACLFilledChecklist checklist(acl, s->request, NULL);
     checklist.src_addr = from;
     checklist.my_addr.SetNoAddr();
-    checklist.request = HTTPMSGLOCK(s->request);
-    checklist.accessList = cbdataReference(acl);
-    /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
     int result = checklist.fastCheck();
     return result;
 }
@@ -50,7 +50,7 @@
 #include "HttpHdrContRange.h"
 #include "HttpHdrSc.h"
 #include "HttpHdrScTarget.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "fde.h"
 #if DELAY_POOLS
 #include "DelayPools.h"
@@ -1974,13 +1974,8 @@ HttpStateData::doneSendingRequestBody()
     debugs(11,5, HERE << "doneSendingRequestBody: FD " << fd);
 
 #if HTTP_VIOLATIONS
-    ACLChecklist ch;
-    ch.request = HTTPMSGLOCK(request);
-
     if (Config.accessList.brokenPosts) {
-        ch.accessList = cbdataReference(Config.accessList.brokenPosts);
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
-
+		ACLFilledChecklist ch(Config.accessList.brokenPosts, request, NULL);
         if (!ch.fastCheck()) {
             debugs(11, 5, "doneSendingRequestBody: didn't match brokenPosts");
             CommIoCbParams io(NULL);
@@ -40,8 +40,8 @@
 #include "comm.h"
 #include "ICP.h"
 #include "HttpRequest.h"
-#include "ACLChecklist.h"
-#include "ACL.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Acl.h"
 #include "AccessLogEntry.h"
 #include "wordlist.h"
 #include "SquidTime.h"
@@ -409,12 +409,9 @@ icpAccessAllowed(IpAddress &from, HttpRequest * icp_request)
     if (!Config.accessList.icp)
         return 0;
 
-    ACLChecklist checklist;
+    ACLFilledChecklist checklist(Config.accessList.icp, icp_request, NULL);
     checklist.src_addr = from;
     checklist.my_addr.SetNoAddr();
-    checklist.request = HTTPMSGLOCK(icp_request);
-    checklist.accessList = cbdataReference(Config.accessList.icp);
-    /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
     int result = checklist.fastCheck();
     return result;
 }
@@ -33,7 +33,6 @@
  */
 
 #include "squid.h"
-#include "authenticate.h"
 #include "fde.h"
 
 static void logfileWriteWrapper(Logfile * lf, const void *buf, size_t len);
@@ -34,7 +34,7 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "ConfigParser.h"
 #include "errorpage.h"
 #include "event.h"
@@ -46,8 +46,8 @@
 #include "HttpReply.h"
 #include "pconn.h"
 #include "Mem.h"
-#include "ACLASN.h"
-#include "ACL.h"
+#include "acl/Asn.h"
+#include "acl/Acl.h"
 #include "htcp.h"
 #include "StoreFileSystem.h"
 #include "DiskIO/DiskIOModule.h"
@@ -32,7 +32,7 @@
 
 #include "squid.h"
 #include "ProtoPort.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "event.h"
 #include "CacheManager.h"
 #include "htcp.h"
@@ -175,18 +175,10 @@ peerAllowedToUse(const peer * p, HttpRequest * request)
     if (p->access == NULL)
         return do_ping;
 
-    ACLChecklist checklist;
-
+    ACLFilledChecklist checklist(p->access, request, NULL);
     checklist.src_addr = request->client_addr;
-
     checklist.my_addr = request->my_addr;
 
-    checklist.request = HTTPMSGLOCK(request);
-
-    checklist.accessList = cbdataReference(p->access);
-
-    /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
-
 #if 0 && USE_IDENT
     /*
      * this is currently broken because 'request->user_ident' has been
@@ -38,7 +38,7 @@
 #include "Store.h"
 #include "ICP.h"
 #include "HttpRequest.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "htcp.h"
 #include "forward.h"
 #include "SquidTime.h"
@@ -294,7 +294,7 @@ peerSelectFoo(ps_state * ps)
     if (ps->direct == DIRECT_UNKNOWN) {
         if (ps->always_direct == 0 && Config.accessList.AlwaysDirect) {
             /** check always_direct; */
-            ps->acl_checklist = aclChecklistCreate(
+            ps->acl_checklist = new ACLFilledChecklist(
                                     Config.accessList.AlwaysDirect,
                                     request,
                                     NULL);		/* ident */
@@ -305,7 +305,7 @@ peerSelectFoo(ps_state * ps)
             ps->direct = DIRECT_YES;
         } else if (ps->never_direct == 0 && Config.accessList.NeverDirect) {
             /** check never_direct; */
-            ps->acl_checklist = aclChecklistCreate(
+            ps->acl_checklist = new ACLFilledChecklist(
                                     Config.accessList.NeverDirect,
                                     request,
                                     NULL);		/* ident */
@@ -39,7 +39,7 @@
 #include "Store.h"
 #include "fde.h"
 #include "client_side_request.h"
-#include "ACLChecklist.h"
+#include "acl/Checklist.h"
 #include "HttpRequest.h"
 #include "client_side.h"
 #include "helper.h"
@@ -32,7 +32,7 @@
 #include "squid.h"
 #include "comm.h"
 #include "cache_snmp.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #include "ip/IpAddress.h"
 
 #define SNMP_REQUEST_SIZE 4096
@@ -530,11 +530,9 @@ snmpDecodePacket(snmp_request_t * rq)
     /* Check if we have explicit permission to access SNMP data.
      * default (set above) is to deny all */
     if (Community && Config.accessList.snmp) {
-        ACLChecklist checklist;
-        checklist.accessList = cbdataReference(Config.accessList.snmp);
+        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);
         checklist.src_addr = rq->from;
         checklist.snmp_community = (char *) Community;
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
         allow = checklist.fastCheck();
     }
 
@@ -1136,15 +1134,15 @@ oid2addr(oid * id, IpAddress &addr, u_int size)
 }
 
 /* SNMP checklists */
-#include "ACLStrategy.h"
-#include "ACLStrategised.h"
-#include "ACLStringData.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
+#include "acl/StringData.h"
 
 class ACLSNMPCommunityStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLSNMPCommunityStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
@@ -1170,7 +1168,7 @@ ACL::Prototype ACLSNMPCommunity::RegistryProtoype(&ACLSNMPCommunity::RegistryEnt
 ACLStrategised<char const *> ACLSNMPCommunity::RegistryEntry_(new ACLStringData, ACLSNMPCommunityStrategy::Instance(), "snmp_community");
 
 int
-ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
+ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
 {
     return data->match (checklist->snmp_community);
 }
@@ -41,7 +41,7 @@
 #if USE_SSL
 
 #include "fde.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 
 /**
  \defgroup ServerProtocolSSLInternal Server-Side SSL Internals
@@ -182,7 +182,7 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
                 debugs(83, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " << buffer << " does not match domainname " << server);
                 ok = 0;
                 if (check)
-                    check->ssl_error = SQUID_X509_V_ERR_DOMAIN_MISMATCH;
+                    Filled(check)->ssl_error = SQUID_X509_V_ERR_DOMAIN_MISMATCH;
             }
         }
     } else {
@@ -216,7 +216,7 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
         }
 
         if (check)
-            check->ssl_error = ctx->error;
+            Filled(check)->ssl_error = ctx->error;
     }
 
     if (!ok && check) {
@@ -4,7 +4,7 @@
 #include <stdexcept>
 
 #include "testACLMaxUserIP.h"
-#include "ACLMaxUserIP.h"
+#include "auth/AclMaxUserIp.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testACLMaxUserIP );
 
@@ -2,7 +2,7 @@
 
 #include "squid.h"
 #include "testAuth.h"
-#include "authenticate.h"
+#include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
 #include "auth/Scheme.h"
 #include "auth/Config.h"
@@ -45,7 +45,7 @@
 #include "Mem.h"
 
 #if 0
-#include "ACLChecklist.h"
+#include "acl/Checklist.h"
 #endif
 
 /* Stub routines */
@@ -39,7 +39,7 @@
 #include "fde.h"
 #include "comm.h"
 #include "client_side_request.h"
-#include "ACLChecklist.h"
+#include "acl/FilledChecklist.h"
 #if DELAY_POOLS
 #include "DelayId.h"
 #endif
@@ -618,12 +618,9 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          * default is to allow.
          */
-        ACLChecklist ch;
+        ACLFilledChecklist ch(Config.accessList.miss, request, NULL);
         ch.src_addr = request->client_addr;
         ch.my_addr = request->my_addr;
-        ch.request = HTTPMSGLOCK(request);
-        ch.accessList = cbdataReference(Config.accessList.miss);
-        /* cbdataReferenceDone() happens in either fastCheck() or ~ACLCheckList */
         answer = ch.fastCheck();
 
         if (answer == 0) {
@@ -45,19 +45,37 @@
 #include <cassert>
 
 /* stub functions for parts of squid not factored to be dynamic yet */
-void shut_down(int)
+void
+eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata)
 {}
 
+// required by storeKeyPublicByRequest*
+// XXX: what pulls in storeKeyPublicByRequest?
+const char *urlCanonical(HttpRequest *) { assert(false); return NULL; }
+
 void
-reconfigure(int)
-{}
+storeAppendPrintf(StoreEntry * e, const char *fmt,...)
+{
+    va_list args;
+    va_start(args, fmt);
+
+	assert(false);
+
+    va_end(args);
+}
+
+#include "CacheManager.h"
+CacheManager*
+CacheManager::GetInstance()
+{
+	assert(false);
+    return NULL;
+}
 
-#if WHENITMINIMAL
 void
-eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata)
-{}
+CacheManager::registerAction(char const * action, char const * desc, OBJH * handler, int pw_req_flag, int atomic) {}
+
 
-#endif
 /* end stub functions */
 
 struct MetaStd {