@@ -383,6 +383,46 @@ compat/getnameinfo.c:
 
 ==============================================================================
 
+compat/GnuRegex.h:
+
+ * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+
+==============================================================================
+
+compat/GnuRegex.c:
+
+ * Copyright (C) 1993 Free Software Foundation, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+
+==============================================================================
+
 compat/inet_ntop.c:
 
 /*
@@ -32,6 +32,26 @@ AC_DEFUN([SQUID_CHECK_DBOPEN_NEEDS_LIBDB],[
 ])
 
 
+dnl check whether regex works by actually compiling one
+dnl sets squid_cv_regex_works to either yes or no
+
+AC_DEFUN([SQUID_CHECK_REGEX_WORKS],[
+  AC_CACHE_CHECK([if the system-supplied regex lib actually works],squid_cv_regex_works,[
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_REGEX_H
+#include <regex.h> 
+#endif
+]], [[
+regex_t t; regcomp(&t,"",0);]])],
+    [ squid_cv_regex_works=yes ],
+    [ squid_cv_regex_works=no ])
+  ])
+])
+
+
 AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
   AC_CACHE_CHECK([for libIpHlpApi],squid_cv_have_libiphlpapi,[
     SQUID_STATE_SAVE(iphlpapi)
@@ -0,0 +1,413 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_REGEXP_LIBRARY_H
+#define SQUID_REGEXP_LIBRARY_H
+
+#if !USE_GNUREGEX /* try the system one by default */
+
+/* POSIX says that <sys/types.h> must be included (by the caller) before
+ * <regex.h>.  */
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_REGEX_H
+#include <regex.h>
+#endif
+
+#else  /* USE_GNUREGEX */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Definitions for data structures and routines for the regular
+ * expression library, version 0.12.
+ *
+ * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
+
+/* POSIX says that <sys/types.h> must be included (by the caller) before
+ * <regex.h>.  */
+
+/* The following bits are used to determine the regexp syntax we
+ * recognize.  The set/not-set meanings are chosen so that Emacs syntax
+ * remains the value 0.  The bits are given in alphabetical order, and
+ * the definitions shifted by one from the previous bit; thus, when we
+ * add or remove a bit, only one other definition need change.  */
+typedef unsigned reg_syntax_t;
+
+/* If this bit is not set, then \ inside a bracket expression is literal.
+ * If set, then such a \ quotes the following character.  */
+#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
+
+/* If this bit is not set, then + and ? are operators, and \+ and \? are
+ * literals.
+ * If set, then \+ and \? are operators and + and ? are literals.  */
+#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
+
+/* If this bit is set, then character classes are supported.  They are:
+ * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+ * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+ * If not set, then character classes are not supported.  */
+#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
+
+/* If this bit is set, then ^ and $ are always anchors (outside bracket
+ * expressions, of course).
+ * If this bit is not set, then it depends:
+ * ^  is an anchor if it is at the beginning of a regular
+ * expression or after an open-group or an alternation operator;
+ * $  is an anchor if it is at the end of a regular expression, or
+ * before a close-group or an alternation operator.
+ *
+ * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+ * POSIX draft 11.2 says that * etc. in leading positions is undefined.
+ * We already implemented a previous draft which made those constructs
+ * invalid, though, so we haven't changed the code back.  */
+#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
+
+/* If this bit is set, then special characters are always special
+ * regardless of where they are in the pattern.
+ * If this bit is not set, then special characters are special only in
+ * some contexts; otherwise they are ordinary.  Specifically,
+ * * + ? and intervals are only special when not after the beginning,
+ * open-group, or alternation operator.  */
+#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
+
+/* If this bit is set, then *, +, ?, and { cannot be first in an re or
+ * immediately after an alternation or begin-group operator.  */
+#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
+
+/* If this bit is set, then . matches newline.
+ * If not set, then it doesn't.  */
+#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
+
+/* If this bit is set, then . doesn't match NUL.
+ * If not set, then it does.  */
+#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
+
+/* If this bit is set, nonmatching lists [^...] do not match newline.
+ * If not set, they do.  */
+#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
+
+/* If this bit is set, either \{...\} or {...} defines an
+ * interval, depending on RE_NO_BK_BRACES.
+ * If not set, \{, \}, {, and } are literals.  */
+#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
+
+/* If this bit is set, +, ? and | aren't recognized as operators.
+ * If not set, they are.  */
+#define RE_LIMITED_OPS (RE_INTERVALS << 1)
+
+/* If this bit is set, newline is an alternation operator.
+ * If not set, newline is literal.  */
+#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
+
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
+ * are literals.
+ * If not set, then `\{...\}' defines an interval.  */
+#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
+
+/* If this bit is set, (...) defines a group, and \( and \) are literals.
+ * If not set, \(...\) defines a group, and ( and ) are literals.  */
+#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
+
+/* If this bit is set, then \<digit> matches <digit>.
+ * If not set, then \<digit> is a back-reference.  */
+#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
+
+/* If this bit is set, then | is an alternation operator, and \| is literal.
+ * If not set, then \| is an alternation operator, and | is literal.  */
+#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
+
+/* If this bit is set, then an ending range point collating higher
+ * than the starting range point, as in [z-a], is invalid.
+ * If not set, then when ending range point collates higher than the
+ * starting range point, the range is ignored.  */
+#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
+
+/* If this bit is set, then an unmatched ) is ordinary.
+ * If not set, then an unmatched ) is invalid.  */
+#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
+
+/* Define combinations of the above bits for the standard possibilities.
+ * (The [[[ comments delimit what gets put into the Texinfo file, so
+ * don't delete them!)  */
+/* [[[begin syntaxes]]] */
+#define RE_SYNTAX_EMACS 0
+
+#define RE_SYNTAX_AWK                           \
+  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL           \
+   | RE_NO_BK_PARENS            | RE_NO_BK_REFS             \
+   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES           \
+   | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+#define RE_SYNTAX_POSIX_AWK                         \
+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
+
+#define RE_SYNTAX_GREP                          \
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES             \
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS                \
+   | RE_NEWLINE_ALT)
+
+#define RE_SYNTAX_EGREP                         \
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS            \
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE            \
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS             \
+   | RE_NO_BK_VBAR)
+
+#define RE_SYNTAX_POSIX_EGREP                       \
+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
+
+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
+
+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
+
+/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+#define _RE_SYNTAX_POSIX_COMMON                     \
+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL      \
+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
+
+#define RE_SYNTAX_POSIX_BASIC                       \
+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
+
+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+ * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+ * isn't minimal, since other operators, such as \`, aren't disabled.  */
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC                   \
+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
+
+#define RE_SYNTAX_POSIX_EXTENDED                    \
+  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS           \
+   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES                \
+   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR              \
+   | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
+ * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED                \
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS          \
+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES               \
+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS             \
+   | RE_NO_BK_VBAR      | RE_UNMATCHED_RIGHT_PAREN_ORD)
+/* [[[end syntaxes]]] */
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+ * (erroneously) define this in other header files, but we want our
+ * value, so remove any previous define.  */
+#ifdef RE_DUP_MAX
+#undef RE_DUP_MAX
+#endif
+#define RE_DUP_MAX ((1 << 15) - 1)
+
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
+
+/* If this bit is set, then use extended regular expression syntax.
+ * If not set, then use basic regular expression syntax.  */
+#define REG_EXTENDED 1
+
+/* If this bit is set, then ignore case when matching.
+ * If not set, then case is significant.  */
+#define REG_ICASE (REG_EXTENDED << 1)
+
+/* If this bit is set, then anchors do not match at newline
+ * characters in the string.
+ * If not set, then anchors do match at newlines.  */
+#define REG_NEWLINE (REG_ICASE << 1)
+
+/* If this bit is set, then report only success or fail in regexec.
+ * If not set, then returns differ between not matching and errors.  */
+#define REG_NOSUB (REG_NEWLINE << 1)
+
+/* POSIX `eflags' bits (i.e., information for regexec).  */
+
+/* If this bit is set, then the beginning-of-line operator doesn't match
+ * the beginning of the string (presumably because it's not the
+ * beginning of a line).
+ * If not set, then the beginning-of-line operator does match the
+ * beginning of the string.  */
+#define REG_NOTBOL 1
+
+/* Like REG_NOTBOL, except for the end-of-line.  */
+#define REG_NOTEOL (1 << 1)
+
+/* If any error codes are removed, changed, or added, update the
+ * `re_error_msg' table in regex.c.  */
+typedef enum {
+    REG_NOERROR = 0,        /* Success.  */
+    REG_NOMATCH,        /* Didn't find a match (for regexec).  */
+
+    /* POSIX regcomp return error codes.  (In the order listed in the
+     * standard.)  */
+    REG_BADPAT,         /* Invalid pattern.  */
+    REG_ECOLLATE,       /* Not implemented.  */
+    REG_ECTYPE,         /* Invalid character class name.  */
+    REG_EESCAPE,        /* Trailing backslash.  */
+    REG_ESUBREG,        /* Invalid back reference.  */
+    REG_EBRACK,         /* Unmatched left bracket.  */
+    REG_EPAREN,         /* Parenthesis imbalance.  */
+    REG_EBRACE,         /* Unmatched \{.  */
+    REG_BADBR,          /* Invalid contents of \{\}.  */
+    REG_ERANGE,         /* Invalid range end.  */
+    REG_ESPACE,         /* Ran out of memory.  */
+    REG_BADRPT,         /* No preceding re for repetition op.  */
+
+    /* Error codes we've added.  */
+    REG_EEND,           /* Premature end.  */
+    REG_ESIZE,          /* Compiled pattern bigger than 2^16 bytes.  */
+    REG_ERPAREN         /* Unmatched ) or \); not returned from regcomp.  */
+} reg_errcode_t;
+
+/* This data structure represents a compiled pattern.  Before calling
+ * the pattern compiler, the fields `buffer', `allocated', `fastmap',
+ * `translate', and `no_sub' can be set.  After the pattern has been
+ * compiled, the `re_nsub' field is available.  All other fields are
+ * private to the regex routines.  */
+
+struct re_pattern_buffer {
+    /* [[[begin pattern_buffer]]] */
+    /* Space that holds the compiled pattern.  It is declared as
+     * `unsigned char *' because its elements are
+     * sometimes used as array indexes.  */
+    unsigned char *buffer;
+
+    /* Number of bytes to which `buffer' points.  */
+    unsigned long allocated;
+
+    /* Number of bytes actually used in `buffer'.  */
+    unsigned long used;
+
+    /* Syntax setting with which the pattern was compiled.  */
+    reg_syntax_t syntax;
+
+    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
+     * the fastmap, if there is one, to skip over impossible
+     * starting points for matches.  */
+    char *fastmap;
+
+    /* Either a translate table to apply to all characters before
+     * comparing them, or zero for no translation.  The translation
+     * is applied to a pattern when it is compiled and to a string
+     * when it is matched.  */
+    char *translate;
+
+    /* Number of subexpressions found by the compiler.  */
+    size_t re_nsub;
+
+    /* Zero if this pattern cannot match the empty string, one else.
+     * Well, in truth it's used only in `re_search_2', to see
+     * whether or not we should use the fastmap, so we don't set
+     * this absolutely perfectly; see `re_compile_fastmap' (the
+     * `duplicate' case).  */
+    unsigned can_be_null:1;
+
+    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+     * for `max (RE_NREGS, re_nsub + 1)' groups.
+     * If REGS_REALLOCATE, reallocate space if necessary.
+     * If REGS_FIXED, use what's there.  */
+#define REGS_UNALLOCATED 0
+#define REGS_REALLOCATE 1
+#define REGS_FIXED 2
+    unsigned regs_allocated:2;
+
+    /* Set to zero when `regex_compile' compiles a pattern; set to one
+     * by `re_compile_fastmap' if it updates the fastmap.  */
+    unsigned fastmap_accurate:1;
+
+    /* If set, `re_match_2' does not return information about
+     * subexpressions.  */
+    unsigned no_sub:1;
+
+    /* If set, a beginning-of-line anchor doesn't match at the
+     * beginning of the string.  */
+    unsigned not_bol:1;
+
+    /* Similarly for an end-of-line anchor.  */
+    unsigned not_eol:1;
+
+    /* If true, an anchor at a newline matches.  */
+    unsigned newline_anchor:1;
+
+    /* [[[end pattern_buffer]]] */
+};
+
+typedef struct re_pattern_buffer regex_t;
+
+/* search.c (search_buffer) in Emacs needs this one opcode value.  It is
+ * defined both in `regex.c' and here.  */
+#define RE_EXACTN_VALUE 1
+
+/* Type for byte offsets within the string.  POSIX mandates this.  */
+typedef int regoff_t;
+
+/* This is the structure we store register match data in.  See
+ * regex.texinfo for a full description of what registers match.  */
+struct re_registers {
+    unsigned num_regs;
+    regoff_t *start;
+    regoff_t *end;
+};
+
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+ * `re_match_2' returns information about at least this many registers
+ * the first time a `regs' structure is passed.  */
+#ifndef RE_NREGS
+#define RE_NREGS 30
+#endif
+
+/* POSIX specification for registers.  Aside from the different names than
+ * `re_registers', POSIX uses an array of structures, instead of a
+ * structure of arrays.  */
+typedef struct {
+    regoff_t rm_so;     /* Byte offset from string's start to substring's start.  */
+    regoff_t rm_eo;     /* Byte offset from string's start to substring's end.  */
+} regmatch_t;
+
+/* Declarations for routines.  */
+
+/* To avoid duplicating every routine declaration -- once with a
+ * prototype (if we are ANSI), and once without (if we aren't) -- we
+ * use the following macro to declare argument types.  This
+ * unfortunately clutters up the declarations a bit, but I think it's
+ * worth it.  */
+
+/* POSIX compatibility.  */
+extern int regcomp(regex_t * preg, const char *pattern, int cflags);
+extern int regexec(const regex_t * preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
+extern size_t regerror(int errcode, const regex_t * preg, char *errbuf, size_t errbuf_size);
+extern void regfree(regex_t * preg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* USE_GNUREGEX */
+#endif /* SQUID_REGEXP_LIBRARY_H */
+
+/*
+ * Local variables:
+ * make-backup-files: t
+ * version-control: t
+ * trim-versions-without-asking: nil
+ * End:
+ */
+
@@ -33,6 +33,8 @@ libcompatsquid_la_SOURCES = \
 	getaddrinfo.h \
 	getnameinfo.cc \
 	getnameinfo.h \
+	GnuRegex.c \
+	GnuRegex.h \
 	inet_ntop.cc \
 	inet_ntop.h \
 	inet_pton.cc \
@@ -107,6 +107,13 @@
 /* Valgrind API macros changed between two versions squid supports */
 #include "compat/valgrind.h"
 
+/**
+ * A Regular Expression library is bundled with Squid.
+ * Default is to use a system provided one, but the bundle
+ * may be used instead with explicit configuration.
+ */
+#include "compat/GnuRegex.h"
+
 /* cppunit is not quite C++0x compatible yet */
 #include "compat/cppunit.h"
 
@@ -2807,6 +2807,7 @@ AC_CHECK_HEADERS( \
   paths.h \
   poll.h \
   pwd.h \
+  regex.h \
   sched.h \
   siginfo.h \
   signal.h \
@@ -3341,6 +3342,9 @@ AC_CHECK_FUNCS(\
 	pthread_setschedparam \
 	pthread_sigmask \
 	putenv \
+	regcomp \
+	regexec \
+	regfree \
 	res_init \
 	__res_init \
 	rint \
@@ -3626,6 +3630,51 @@ if test x"$enable_zph_qos" = "xyes" ; then
                       [Enable support for QOS netfilter mark preservation])
 fi
 
+
+AC_CHECK_LIB(regex, regexec, [REGEXLIB="-lregex"],[REGEXLIB=''])
+AC_ARG_ENABLE(gnuregex,
+  AS_HELP_STRING([--enable-gnuregex],
+                 [Compile GNUregex.  Unless you have reason to use 
+                 this option, you should not enable it.
+                 This library file is usually only required on Windows and 
+                 very old Unix boxes which do not have their own regex 
+                 library built in.]), [
+SQUID_YESNO([$enableval],[unrecognized argument to --enable-gnuregex: $enableval])
+])
+# force-enable on old solaris and nextstep
+if test "x${enable_gnuregex:=auto}" = "xauto" ; then
+    case "$host" in
+    *-sun-solaris2.[[0-4]])
+	  enable_gnuregex="yes"
+	  ;;
+    *-next-nextstep*)
+	  enable_gnuregex="yes"
+	  ;;
+    esac
+fi
+
+# try detecting if it is needed
+if test "x$enable_gnuregex" = "xauto" ; then
+  SQUID_CHECK_REGEX_WORKS
+  if test "x$squid_cv_regex_works" = "xyes" ; then
+    enable_gnuregex=no
+  else
+    enable_gnuregex=yes
+  fi
+fi
+AC_MSG_CHECKING(if GNUregex needs to be compiled)
+AC_MSG_RESULT($enable_gnuregex)
+if test "x$enable_gnuregex" = "xyes"; then
+  # for some reason (force-enable, test..) gnuregex was found as needed. Override any system lib
+  REGEXLIB=""
+fi
+#if no reason was found to enable gnuregex, disable it
+if test "x$enable_gnuregex" = "xauto" ; then
+  enable_gnuregex=no
+fi
+SQUID_DEFINE_BOOL(USE_GNUREGEX,$enable_gnuregex,[Define if we should use GNU regex])
+AC_SUBST(REGEXLIB)
+
 SQUID_DETECT_UDP_SND_BUFSIZE
 SQUID_DETECT_UDP_RECV_BUFSIZE
 SQUID_DETECT_TCP_SND_BUFSIZE
@@ -82,16 +82,7 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Changes to existing directives<label id="modifieddirectives">
 <p>
 <descrip>
-	<tag>acl</tag>
-	<p>Due to differences between GNU Regex and libc regular expressions
-	   patterns escaping the double quote (") character escaped by a slash (\)
-	   will now be rejected. Use without the escaping is still accepted.
-	   This affects all *_regex and regular expression based ACL types.
-
-	<tag>refresh_pattern</tag>
-	<p>Due to differences between GNU Regex and libc regular expressions
-	   patterns escaping the double quote (") character with a slash (\)
-	   will now be rejected. Use without the escaping is still accepted.
+	<p>No changes to existing directives in this version.
 
 </descrip>
 
@@ -134,19 +125,7 @@ This section gives an account of those changes in three categories:
 <sect1>Removed options<label id="removedoptions">
 <p>
 <descrip>
-	<tag>--enable-gnuregex</tag>
-	<p>Squid now uses C++11 std::regex instead of GNU Regex. Removed.
-
-	<tag>LDFLAGS</tag>
-	<p>Squid now uses C++11 std::regex API instead of the C regex.h API.
-	   This means that linker overrides for -lregex and regex.h no longer exist.
-	<p>Custom regex libraries need to provide bindings for the std::regex
-	   API to link with Squid. This may require additional -I path to be
-	   provided in CXXFLAGS to the library headers. Refer to the chosen
-	   library documentation for more details.
-	<p>Note that popular modern high performance regex libraries should
-	   already be used by the STL internal implementation and no longer
-	   need manually linking.
+	<p>No removed options in this version.
 
 </descrip>
 
@@ -1275,6 +1275,7 @@ PREDEFINED             = __cplusplus \
                          USE_DELAY_POOLS \
                          USE_DLMALLOC \
                          USE_EPOLL \
+                         USE_GNUREGEX \
                          USE_HEXDUMP \
                          USE_HTCP \
                          USE_ICMP \
@@ -559,6 +559,7 @@ squid_LDADD = \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
+	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SNMP_LIBS) \
@@ -657,6 +658,7 @@ ufsdump_LDADD = \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(EPOLL_LIBS) \
@@ -1144,6 +1146,7 @@ tests_testACLMaxUserIP_LDADD= \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -1416,6 +1419,7 @@ tests_testCacheManager_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -1589,6 +1593,7 @@ tests_testDiskIO_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -1843,6 +1848,7 @@ tests_testEvent_LDADD = \
 	sbuf/libsbuf.la \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2078,6 +2084,7 @@ tests_testEventLoop_LDADD = \
 	store/libstore.la \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2309,6 +2316,7 @@ tests_test_http_range_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2612,6 +2620,7 @@ tests_testHttpRequest_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2832,6 +2841,7 @@ tests_testStore_LDADD= \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	CommCalls.o \
 	$(LIBCPPUNIT_LIBS) \
@@ -2869,6 +2879,7 @@ tests_testString_LDADD = \
 	ip/libip.la \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -3055,6 +3066,7 @@ tests_testUfs_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -3229,6 +3241,7 @@ tests_testRock_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -3460,6 +3473,7 @@ tests_testURL_LDADD = \
 	format/libformat.la \
 	store/libstore.la \
 	sbuf/libsbuf.la \
+	$(REGEXLIB) \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
@@ -3539,6 +3553,7 @@ tests_testConfigParser_LDADD = \
 	sbuf/libsbuf.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -21,6 +21,7 @@
 #include "base/RegexPattern.h"
 #include "ConfigParser.h"
 #include "Debug.h"
+#include "sbuf/Algorithms.h"
 #include "sbuf/List.h"
 
 ACLRegexData::~ACLRegexData()
@@ -52,13 +53,13 @@ SBufList
 ACLRegexData::dump() const
 {
     SBufList sl;
-    auto flags = std::regex::extended | std::regex::nosubs;
+    int flags = REG_EXTENDED | REG_NOSUB;
 
     // walk and dump the list
     // keeping the flags values consistent
     for (auto &i : data) {
         if (i.flags != flags) {
-            if ((i.flags & std::regex::icase)) {
+            if ((i.flags&REG_ICASE) != 0) {
                 sl.emplace_back("-i");
             } else {
                 sl.emplace_back("+i");
@@ -101,30 +102,39 @@ removeUnnecessaryWildcards(char * t)
 }
 
 static bool
-compileRE(std::list<RegexPattern> &curlist, const char * RE, const decltype(RegexPattern::flags) &flags)
+compileRE(std::list<RegexPattern> &curlist, const char * RE, int flags)
 {
     if (RE == NULL || *RE == '\0')
         return curlist.empty(); // XXX: old code did this. It looks wrong.
 
-    // std::regex constructor does the actual compile and throws on invalid patterns
-    try {
-        curlist.emplace_back(flags, RE);
-
-    } catch(std::regex_error &e) {
+    regex_t comp;
+    if (int errcode = regcomp(&comp, RE, flags)) {
+        char errbuf[256];
+        regerror(errcode, &comp, errbuf, sizeof errbuf);
         debugs(28, DBG_CRITICAL, cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': " << e.code());
-        return false;
-
-    } catch(...) {
-        debugs(28, DBG_CRITICAL, cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': (unknown error)");
+        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': " << errbuf);
         return false;
     }
-
     debugs(28, 2, "compiled '" << RE << "' with flags " << flags);
+
+    curlist.emplace_back(flags, RE);
+    curlist.back().regex = comp;
+
     return true;
 }
 
+static bool
+compileRE(std::list<RegexPattern> &curlist, const SBufList &RE, int flags)
+{
+    if (RE.empty())
+        return curlist.empty(); // XXX: old code did this. It looks wrong.
+    SBuf regexp;
+    static const SBuf openparen("("), closeparen(")"), separator(")|(");
+    JoinContainerIntoSBuf(regexp, RE.begin(), RE.end(), separator, openparen,
+                          closeparen);
+    return compileRE(curlist, regexp.c_str(), flags);
+}
+
 /** Compose and compile one large RE from a set of (small) REs.
  * The ultimate goal is to have only one RE per ACL so that match() is
  * called only once per ACL.
@@ -133,66 +143,62 @@ static int
 compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
     std::list<RegexPattern> newlist;
-    int numREs = 0;
-    auto flags = std::regex::extended | std::regex::nosubs;
-    int largeREindex = 0;
-    char largeRE[BUFSIZ];
-    *largeRE = 0;
+    SBufList accumulatedRE;
+    int numREs = 0, reSize = 0;
+    int flags = REG_EXTENDED | REG_NOSUB;
 
     for (const SBuf & configurationLineWord : sl) {
-        int RElen;
-        RElen = configurationLineWord.length();
-
         static const SBuf minus_i("-i");
         static const SBuf plus_i("+i");
         if (configurationLineWord == minus_i) {
-            if ((flags & std::regex::icase)) {
+            if (flags & REG_ICASE) {
                 /* optimisation of  -i ... -i */
                 debugs(28, 2, "optimisation of -i ... -i" );
             } else {
                 debugs(28, 2, "-i" );
-                if (!compileRE(newlist, largeRE, flags))
+                if (!compileRE(newlist, accumulatedRE, flags))
                     return 0;
-                flags |= std::regex::icase;
-                largeRE[largeREindex=0] = '\0';
+                flags |= REG_ICASE;
+                accumulatedRE.clear();
+                reSize = 0;
             }
+            continue;
         } else if (configurationLineWord == plus_i) {
-            if (!(flags & std::regex::icase)) {
+            if ((flags & REG_ICASE) == 0) {
                 /* optimisation of  +i ... +i */
                 debugs(28, 2, "optimisation of +i ... +i");
             } else {
                 debugs(28, 2, "+i");
-                if (!compileRE(newlist, largeRE, flags))
+                if (!compileRE(newlist, accumulatedRE, flags))
                     return 0;
-                flags &= ~std::regex::icase;
-                largeRE[largeREindex=0] = '\0';
+                flags &= ~REG_ICASE;
+                accumulatedRE.clear();
+                reSize = 0;
             }
-        } else if (RElen + largeREindex + 3 < BUFSIZ-1) {
-            debugs(28, 2, "adding RE '" << configurationLineWord << "'");
-            if (largeREindex > 0) {
-                largeRE[largeREindex] = '|';
-                ++largeREindex;
-            }
-            largeRE[largeREindex] = '(';
-            ++largeREindex;
-            configurationLineWord.copy(largeRE+largeREindex, BUFSIZ-largeREindex);
-            largeREindex += configurationLineWord.length();
-            largeRE[largeREindex] = ')';
-            ++largeREindex;
-            largeRE[largeREindex] = '\0';
-            ++numREs;
-        } else {
+            continue;
+        }
+
+        debugs(28, 2, "adding RE '" << configurationLineWord << "'");
+        accumulatedRE.push_back(configurationLineWord);
+        ++numREs;
+        reSize += configurationLineWord.length();
+
+        if (reSize > 1024) { // must be < BUFSIZ everything included
             debugs(28, 2, "buffer full, generating new optimised RE..." );
-            if (!compileRE(newlist, largeRE, flags))
+            if (!compileRE(newlist, accumulatedRE, flags))
                 return 0;
-            largeRE[largeREindex=0] = '\0';
+            accumulatedRE.clear();
+            reSize = 0;
             continue;    /* do the loop again to add the RE to largeRE */
         }
     }
 
-    if (!compileRE(newlist, largeRE, flags))
+    if (!compileRE(newlist, accumulatedRE, flags))
         return 0;
 
+    accumulatedRE.clear();
+    reSize = 0;
+
     /* all was successful, so put the new list at the tail */
     curlist.splice(curlist.end(), newlist);
 
@@ -209,14 +215,14 @@ compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 static void
 compileUnoptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
-    auto flags = std::regex::extended | std::regex::nosubs;
+    int flags = REG_EXTENDED | REG_NOSUB;
 
     static const SBuf minus_i("-i"), plus_i("+i");
     for (auto configurationLineWord : sl) {
         if (configurationLineWord == minus_i) {
-            flags |= std::regex::icase;
+            flags |= REG_ICASE;
         } else if (configurationLineWord == plus_i) {
-            flags &= ~std::regex::icase;
+            flags &= ~REG_ICASE;
         } else {
             if (!compileRE(curlist, configurationLineWord.c_str() , flags))
                 debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. "
@@ -1064,6 +1064,10 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
          * the user agent won't change user name without warning.
          */
         authDigestUserLinkNonce(digest_user, nonce);
+
+        /* auth_user is now linked, we reset these values
+         * after external auth occurs anyway */
+        auth_user->expiretime = current_time.tv_sec;
     } else {
         debugs(29, 9, "Found user '" << username << "' in the user cache as '" << auth_user << "'");
         digest_user = static_cast<Auth::Digest::User *>(auth_user.getRaw());
@@ -187,12 +187,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *,
     auth_user->credentials(Auth::Ok);
 
     /* password was checked and did match */
-    debugs(29, 4, HERE << "user '" << auth_user->username() << "' validated OK");
-
-    /* auth_user is now linked, we reset these values
-     * after external auth occurs anyway */
-    auth_user->expiretime = current_time.tv_sec;
-    return;
+    debugs(29, 4, "user '" << auth_user->username() << "' validated OK");
 }
 
 Auth::Direction
@@ -10,18 +10,35 @@
 #include "base/RegexPattern.h"
 #include <utility>
 
-RegexPattern::RegexPattern(const std::regex_constants::syntax_option_type &aFlags, const char *aPattern) :
+RegexPattern::RegexPattern(int aFlags, const char *aPattern) :
     flags(aFlags),
-    pattern(xstrdup(aPattern)),
-    regex(pattern, flags)
-{}
+    pattern(xstrdup(aPattern))
+{
+    memset(&regex, 0, sizeof(regex));
+}
+
+RegexPattern::RegexPattern(RegexPattern &&o) :
+    flags(std::move(o.flags)),
+    regex(std::move(o.regex)),
+    pattern(std::move(o.pattern))
+{
+    memset(&o.regex, 0, sizeof(o.regex));
+    o.pattern = nullptr;
+}
+
+RegexPattern::~RegexPattern()
+{
+    xfree(pattern);
+    regfree(&regex);
+}
 
 RegexPattern &
 RegexPattern::operator =(RegexPattern &&o)
 {
     flags = std::move(o.flags);
     regex = std::move(o.regex);
-    pattern = o.pattern;
+    memset(&o.regex, 0, sizeof(o.regex));
+    pattern = std::move(o.pattern);
     o.pattern = nullptr;
     return *this;
 }
@@ -9,10 +9,9 @@
 #ifndef SQUID_SRC_BASE_REGEXPATTERN_H
 #define SQUID_SRC_BASE_REGEXPATTERN_H
 
+#include "compat/GnuRegex.h"
 #include "mem/forward.h"
 
-#include <regex>
-
 /**
  * A regular expression,
  * plain text and compiled representations
@@ -23,22 +22,25 @@ class RegexPattern
 
 public:
     RegexPattern() = delete;
-    RegexPattern(const std::regex_constants::syntax_option_type &aFlags, const char *aPattern); // throws std::regex_error
+    RegexPattern(int aFlags, const char *aPattern);
+    ~RegexPattern();
+
+    // regex type varies by library, usually not safe to copy
     RegexPattern(const RegexPattern &) = delete;
     RegexPattern &operator =(const RegexPattern &) = delete;
-    RegexPattern(RegexPattern &&) = default; // throws std::regex_error
+
+    RegexPattern(RegexPattern &&);
     RegexPattern &operator =(RegexPattern &&);
-    ~RegexPattern() { xfree(pattern); }
 
-    const char * c_str() const { return pattern; }
-    bool match(const char *str) const { return std::regex_search(str, regex); }
+    const char * c_str() const {return pattern;}
+    bool match(const char *str) const {return regexec(&regex,str,0,NULL,0)==0;}
 
 public:
-    std::regex_constants::syntax_option_type flags;
+    int flags;
+    regex_t regex;
 
 private:
     char *pattern;
-    std::regex regex;
 };
 
 #endif /* SQUID_SRC_BASE_REGEXPATTERN_H */
@@ -2577,7 +2577,7 @@ dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
     while (head != NULL) {
         storeAppendPrintf(entry, "%s%s %s %d %d%% %d",
                           name,
-                          head->pattern.flags & std::regex::icase ? " -i" : null_string,
+                          head->pattern.flags&REG_ICASE ? " -i" : null_string,
                           head->pattern.c_str(),
                           (int) head->min / 60,
                           (int) (100.0 * head->pct + 0.5),
@@ -2623,6 +2623,7 @@ static void
 parse_refreshpattern(RefreshPattern ** head)
 {
     char *token;
+    char *pattern;
     time_t min = 0;
     double pct = 0.0;
     time_t max = 0;
@@ -2640,25 +2641,33 @@ parse_refreshpattern(RefreshPattern ** head)
     int ignore_private = 0;
 #endif
 
-    auto flags = std::regex::extended | std::regex::nosubs;
+    int i;
+    RefreshPattern *t;
+    regex_t comp;
+    int errcode;
+    int flags = REG_EXTENDED | REG_NOSUB;
+
+    if ((token = ConfigParser::RegexPattern()) != NULL) {
 
-    if ((token = ConfigParser::RegexPattern())) {
         if (strcmp(token, "-i") == 0) {
-            flags |= std::regex::icase;
+            flags |= REG_ICASE;
             token = ConfigParser::RegexPattern();
         } else if (strcmp(token, "+i") == 0) {
-            flags &= ~std::regex::icase;
+            flags &= ~REG_ICASE;
             token = ConfigParser::RegexPattern();
         }
-    } else {
+
+    }
+
+    if (token == NULL) {
         debugs(3, DBG_CRITICAL, "FATAL: refresh_pattern missing the regex pattern parameter");
         self_destruct();
         return;
     }
 
-    char *pattern = xstrdup(token);
+    pattern = xstrdup(token);
 
-    int i = GetInteger();       /* token: min */
+    i = GetInteger();       /* token: min */
 
     /* catch negative and insanely huge values close to 32-bit wrap */
     if (i < 0) {
@@ -2689,7 +2698,7 @@ parse_refreshpattern(RefreshPattern ** head)
     max = (time_t) (i * 60);    /* convert minutes to seconds */
 
     /* Options */
-    while ((token = ConfigParser::NextToken())) {
+    while ((token = ConfigParser::NextToken()) != NULL) {
         if (!strcmp(token, "refresh-ims")) {
             refresh_ims = 1;
         } else if (!strcmp(token, "store-stale")) {
@@ -2726,19 +2735,19 @@ parse_refreshpattern(RefreshPattern ** head)
             debugs(22, DBG_CRITICAL, "refreshAddToList: Unknown option '" << pattern << "': " << token);
     }
 
-    RefreshPattern *t = nullptr;
-    try { // RegexPattern constructor throws on pattern errors
-        t = new RefreshPattern(pattern, flags);
-
-    } catch (std::regex_error &e) {
+    if ((errcode = regcomp(&comp, pattern, flags)) != 0) {
+        char errbuf[256];
+        regerror(errcode, &comp, errbuf, sizeof errbuf);
         debugs(22, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(22, DBG_CRITICAL, "ERROR: Invalid regular expression '" << pattern << "': " << e.code());
+        debugs(22, DBG_CRITICAL, "refreshAddToList: Invalid regular expression '" << pattern << "': " << errbuf);
         xfree(pattern);
         return;
     }
 
     pct = pct < 0.0 ? 0.0 : pct;
     max = max < 0 ? 0 : max;
+    t = new RefreshPattern(pattern, flags);
+    t->pattern.regex = comp;
     t->min = min;
     t->pct = pct;
     t->max = max;
@@ -48,7 +48,6 @@
 #endif
 
 #include <cerrno>
-#include <regex>
 
 namespace Ftp
 {
@@ -531,11 +530,6 @@ ftpListPartsFree(ftpListParts ** parts)
 static ftpListParts *
 ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
 {
-    static const std::regex scan_ftp_integer("^[0-9]+$", std::regex::extended | std::regex::nosubs);
-    static const std::regex scan_ftp_time("^[0-9:]+$", std::regex::extended | std::regex::nosubs);
-    static const std::regex scan_ftp_dostime("^[0-9]+-[0-9]+-[0-9]+$", std::regex::extended | std::regex::nosubs);
-    static const std::regex scan_ftp_dosdate("^[0-9]+:[0-9]+[AP]M$", std::regex::extended | std::regex::nosubs | std::regex::icase);
-
     ftpListParts *p = NULL;
     char *t = NULL;
     const char *ct = NULL;
@@ -544,6 +538,19 @@ ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
     int n_tokens;
     static char tbuf[128];
     char *xbuf = NULL;
+    static int scan_ftp_initialized = 0;
+    static regex_t scan_ftp_integer;
+    static regex_t scan_ftp_time;
+    static regex_t scan_ftp_dostime;
+    static regex_t scan_ftp_dosdate;
+
+    if (!scan_ftp_initialized) {
+        scan_ftp_initialized = 1;
+        regcomp(&scan_ftp_integer, "^[0123456789]+$", REG_EXTENDED | REG_NOSUB);
+        regcomp(&scan_ftp_time, "^[0123456789:]+$", REG_EXTENDED | REG_NOSUB);
+        regcomp(&scan_ftp_dosdate, "^[0123456789]+-[0123456789]+-[0123456789]+$", REG_EXTENDED | REG_NOSUB);
+        regcomp(&scan_ftp_dostime, "^[0123456789]+:[0123456789]+[AP]M$", REG_EXTENDED | REG_NOSUB | REG_ICASE);
+    }
 
     if (buf == NULL)
         return NULL;
@@ -580,17 +587,16 @@ ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
         char *day = tokens[i + 1];
         char *year = tokens[i + 2];
 
-        // checking that the other bits are all of the right pattern...
         if (!is_month(month))
             continue;
 
-        if (!std::regex_match(size, scan_ftp_integer))
+        if (regexec(&scan_ftp_integer, size, 0, NULL, 0) != 0)
             continue;
 
-        if (!std::regex_match(day, scan_ftp_integer))
+        if (regexec(&scan_ftp_integer, day, 0, NULL, 0) != 0)
             continue;
 
-        if (!std::regex_match(year, scan_ftp_time)) /* Yr | hh:mm */
+        if (regexec(&scan_ftp_time, year, 0, NULL, 0) != 0) /* Yr | hh:mm */
             continue;
 
         snprintf(tbuf, 128, "%s %2s %5s",
@@ -634,8 +640,8 @@ ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
 
     /* try it as a DOS listing, 04-05-70 09:33PM ... */
     if (n_tokens > 3 &&
-            std::regex_match(tokens[0], scan_ftp_dosdate) &&
-            std::regex_match(tokens[1], scan_ftp_dostime)) {
+            regexec(&scan_ftp_dosdate, tokens[0], 0, NULL, 0) == 0 &&
+            regexec(&scan_ftp_dostime, tokens[1], 0, NULL, 0) == 0) {
         if (!strcasecmp(tokens[2], "<dir>")) {
             p->type = 'd';
         } else {
@@ -343,13 +343,20 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
     }
 
     memset(&nl, 0, sizeof(struct pfioc_natlook));
-    newConn->remote.getInAddr(nl.saddr.v4);
-    nl.sport = htons(newConn->remote.port());
 
-    newConn->local.getInAddr(nl.daddr.v4);
+    if (newConn->remote.isIPv6()) {
+        newConn->remote.getInAddr(nl.saddr.v6);
+        newConn->local.getInAddr(nl.daddr.v6);
+        nl.af = AF_INET6;
+    } else {
+        newConn->remote.getInAddr(nl.saddr.v4);
+        newConn->local.getInAddr(nl.daddr.v4);
+        nl.af = AF_INET;
+    }
+
+    nl.sport = htons(newConn->remote.port());
     nl.dport = htons(newConn->local.port());
 
-    nl.af = AF_INET;
     nl.proto = IPPROTO_TCP;
     nl.direction = PF_OUT;
 
@@ -366,7 +373,10 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
         debugs(89, 9, HERE << "address: " << newConn);
         return false;
     } else {
-        newConn->local = nl.rdaddr.v4;
+        if (newConn->remote.isIPv6())
+            newConn->local = nl.rdaddr.v6;
+        else
+            newConn->local = nl.rdaddr.v4;
         newConn->local.port(ntohs(nl.rdport));
         debugs(89, 5, HERE << "address NAT: " << newConn);
         return true;
@@ -129,7 +129,6 @@ static void stat_ipcache_get(StoreEntry *);
 static FREE ipcacheFreeEntry;
 static IDNSCB ipcacheHandleReply;
 static int ipcacheExpiredEntry(ipcache_entry *);
-static int ipcacheParse(ipcache_entry *, const rfc1035_rr *, int, const char *error);
 static ipcache_entry *ipcache_get(const char *);
 static void ipcacheLockEntry(ipcache_entry *);
 static void ipcacheStatPrint(ipcache_entry *, StoreEntry *);
@@ -333,8 +332,7 @@ ipcacheCallback(ipcache_entry *i, int wait)
     ipcacheUnlockEntry(i);
 }
 
-/// \ingroup IPCacheAPI
-static int
+static void
 ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *error_message)
 {
     int k;
@@ -355,25 +353,25 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
     i->addrs.count = 0;
 
     if (nr < 0) {
-        debugs(14, 3, "ipcacheParse: Lookup failed '" << error_message << "' for '" << (const char *)i->hash.key << "'");
+        debugs(14, 3, "Lookup failed '" << error_message << "' for '" << (const char *)i->hash.key << "'");
         i->error_message = xstrdup(error_message);
-        return -1;
+        return;
     }
 
     if (nr == 0) {
-        debugs(14, 3, "ipcacheParse: No DNS records in response to '" << name << "'");
+        debugs(14, 3, "No DNS records in response to '" << name << "'");
         i->error_message = xstrdup("No DNS records");
-        return -1;
+        return;
     }
 
-    debugs(14, 3, "ipcacheParse: " << nr << " answers for '" << name << "'");
+    debugs(14, 3, nr << " answers for '" << name << "'");
     assert(answers);
 
     for (k = 0; k < nr; ++k) {
 
         if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr)) {
-                debugs(14, DBG_IMPORTANT, "ipcacheParse: Invalid IPv6 address in response to '" << name << "'");
+                debugs(14, DBG_IMPORTANT, MYNAME << "Invalid IPv6 address in response to '" << name << "'");
                 continue;
             }
             ++na;
@@ -383,7 +381,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
 
         if (answers[k].type == RFC1035_TYPE_A) {
             if (answers[k].rdlength != sizeof(struct in_addr)) {
-                debugs(14, DBG_IMPORTANT, "ipcacheParse: Invalid IPv4 address in response to '" << name << "'");
+                debugs(14, DBG_IMPORTANT, MYNAME << "Invalid IPv4 address in response to '" << name << "'");
                 continue;
             }
             ++na;
@@ -399,14 +397,14 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
         }
 
         // otherwise its an unknown RR. debug at level 9 since we usually want to ignore these and they are common.
-        debugs(14, 9, HERE << "Unknown RR type received: type=" << answers[k].type << " starting at " << &(answers[k]) );
+        debugs(14, 9, "Unknown RR type received: type=" << answers[k].type << " starting at " << &(answers[k]) );
     }
     if (na == 0) {
-        debugs(14, DBG_IMPORTANT, "ipcacheParse: No Address records in response to '" << name << "'");
+        debugs(14, DBG_IMPORTANT, MYNAME << "No Address records in response to '" << name << "'");
         i->error_message = xstrdup("No Address records");
         if (cname_found)
             ++IpcacheStats.cname_only;
-        return 0;
+        return;
     }
 
     i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(na, sizeof(Ip::Address)));
@@ -424,7 +422,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
             memcpy(&temp, answers[k].rdata, sizeof(struct in_addr));
             i->addrs.in_addrs[j] = temp;
 
-            debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j]);
+            debugs(14, 3, name << " #" << j << " " << i->addrs.in_addrs[j]);
             ++j;
 
         } else if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
@@ -435,7 +433,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
             memcpy(&temp, answers[k].rdata, sizeof(struct in6_addr));
             i->addrs.in_addrs[j] = temp;
 
-            debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j] );
+            debugs(14, 3, name << " #" << j << " " << i->addrs.in_addrs[j] );
             ++j;
         }
         if (ttl == 0 || (int) answers[k].ttl < ttl)
@@ -458,8 +456,6 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
     i->expires = squid_curtime + ttl;
 
     i->flags.negcached = false;
-
-    return i->addrs.count;
 }
 
 /// \ingroup IPCacheInternal
@@ -472,13 +468,9 @@ ipcacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *e
     const int age = i->age();
     statCounter.dns.svcTime.count(age);
 
-    int done = ipcacheParse(i, answers, na, error_message);
-
-    /* If we have not produced either IPs or Error immediately, wait for recursion to finish. */
-    if (done != 0 || error_message != NULL) {
-        ipcacheAddEntry(i);
-        ipcacheCallback(i, age);
-    }
+    ipcacheParse(i, answers, na, error_message);
+    ipcacheAddEntry(i);
+    ipcacheCallback(i, age);
 }
 
 /**
@@ -15,8 +15,6 @@
 #include "mgr/QueryParams.h"
 #include "mgr/StringParam.h"
 
-#include <regex>
-
 Mgr::QueryParam::Pointer
 Mgr::QueryParams::get(const String& name) const
 {
@@ -70,40 +68,34 @@ Mgr::QueryParams::find(const String& name) const
 bool
 Mgr::QueryParams::ParseParam(const String& paramStr, Param& param)
 {
-    std::regex intExpr("^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$", std::regex::extended | std::regex::icase);
-    std::regex stringExpr("^([a-z][a-z0-9_]*)=([^&= ]+)$", std::regex::extended | std::regex::icase);
-    std::smatch pmatch;
-
-    std::string temp(paramStr.termedBuf());
-    if (std::regex_match(temp, pmatch, intExpr)) {
-
-        auto itr = pmatch.begin();
-        ++itr; // move to [1] - first actual sub-match
-
-        // match [1] is the key name
-        param.first = itr->str().c_str();
-        ++itr;
-
-        // match [2] and later are a series of N,N,N,N,N values
+    bool parsed = false;
+    regmatch_t pmatch[3];
+    regex_t intExpr;
+    regcomp(&intExpr, "^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$", REG_EXTENDED | REG_ICASE);
+    regex_t stringExpr;
+    regcomp(&stringExpr, "^([a-z][a-z0-9_]*)=([^&= ]+)$", REG_EXTENDED | REG_ICASE);
+    if (regexec(&intExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
+        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
         std::vector<int> array;
-        while (itr != pmatch.end()) {
-            if (itr->str().c_str()[0] == ',')
-                array.push_back(atoi(itr->str().c_str()+1));
-            else
-                array.push_back(atoi(itr->str().c_str()));
-            ++itr;
+        int n = pmatch[2].rm_so;
+        for (int i = n; i < pmatch[2].rm_eo; ++i) {
+            if (paramStr[i] == ',') {
+                array.push_back(atoi(paramStr.substr(n, i).termedBuf()));
+                n = i + 1;
+            }
         }
+        if (n < pmatch[2].rm_eo)
+            array.push_back(atoi(paramStr.substr(n, pmatch[2].rm_eo).termedBuf()));
         param.second = new IntParam(array);
-        return true;
+        parsed = true;
+    } else if (regexec(&stringExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
+        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
+        param.second = new StringParam(paramStr.substr(pmatch[2].rm_so, pmatch[2].rm_eo));
+        parsed = true;
     }
-
-    if (std::regex_match(temp, pmatch, stringExpr)) {
-        param.first = pmatch[1].str().c_str();
-        param.second = new StringParam(pmatch[2].str().c_str());
-        return true;
-    }
-
-    return false;
+    regfree(&stringExpr);
+    regfree(&intExpr);
+    return parsed;
 }
 
 bool
@@ -9,7 +9,6 @@
 /* DEBUG: section 25    MIME Parsing and Internal Icons */
 
 #include "squid.h"
-#include "base/RegexPattern.h"
 #include "fde.h"
 #include "fs_io.h"
 #include "globals.h"
@@ -59,16 +58,15 @@ class MimeEntry
     MEMPROXY_CLASS(MimeEntry);
 
 public:
-    MimeEntry(const char *aPattern, const decltype(RegexPattern::flags) &reFlags,
-              const char *aContentType,
-              const char *aContentEncoding, const char *aTransferMode,
-              bool optionViewEnable, bool optionDownloadEnable,
-              const char *anIconName);
-    MimeEntry(const MimeEntry &) = delete;
-    MimeEntry(const MimeEntry &&) = delete;
+    explicit MimeEntry(const char *aPattern, const regex_t &compiledPattern,
+                       const char *aContentType,
+                       const char *aContentEncoding, const char *aTransferMode,
+                       bool optionViewEnable, bool optionDownloadEnable,
+                       const char *anIconName);
     ~MimeEntry();
 
-    RegexPattern pattern;
+    const char *pattern;
+    regex_t compiled_pattern;
     const char *content_type;
     const char *content_encoding;
     char transfer_mode;
@@ -92,7 +90,7 @@ mimeGetEntry(const char *fn, int skip_encodings)
         t = NULL;
 
         for (m = MimeTable; m; m = m->next) {
-            if (m->pattern.match(name))
+            if (regexec(&m->compiled_pattern, name, 0, 0, 0) == 0)
                 break;
         }
 
@@ -235,14 +233,17 @@ mimeInit(char *filename)
     char buf[BUFSIZ];
     char chopbuf[BUFSIZ];
     char *t;
+    char *pattern;
     char *icon;
     char *type;
     char *encoding;
     char *mode;
     char *option;
     int view_option;
     int download_option;
+    regex_t re;
     MimeEntry *m;
+    int re_flags = REG_EXTENDED | REG_NOSUB | REG_ICASE;
 
     if (filename == NULL)
         return;
@@ -259,8 +260,6 @@ mimeInit(char *filename)
 
     mimeFreeMemory();
 
-    const auto re_flags = std::regex::extended | std::regex::nosubs | std::regex::icase;
-
     while (fgets(buf, BUFSIZ, fp)) {
         if ((t = strchr(buf, '#')))
             *t = '\0';
@@ -276,7 +275,6 @@ mimeInit(char *filename)
 
         xstrncpy(chopbuf, buf, BUFSIZ);
 
-        char *pattern;
         if ((pattern = strtok(chopbuf, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, "mimeInit: parse error: '" << buf << "'");
             continue;
@@ -314,14 +312,14 @@ mimeInit(char *filename)
                 debugs(25, DBG_IMPORTANT, "mimeInit: unknown option: '" << buf << "' (" << option << ")");
         }
 
-        try {
-            m = new MimeEntry(pattern, re_flags, type, encoding, mode, view_option, download_option, icon);
-
-        } catch (std::regex_error &e) {
-            debugs(25, DBG_IMPORTANT, "mimeInit: invalid regular expression: '" << buf << "'");
+        if (regcomp(&re, pattern, re_flags) != 0) {
+            debugs(25, DBG_IMPORTANT, "mimeInit: regcomp error: '" << buf << "'");
             continue;
         }
 
+        m = new MimeEntry(pattern,re,type,encoding,mode,view_option,
+                          download_option,icon);
+
         *MimeTableTail = m;
 
         MimeTableTail = &m->next;
@@ -442,21 +440,23 @@ MimeIcon::created(StoreEntry *newEntry)
 
 MimeEntry::~MimeEntry()
 {
+    xfree(pattern);
     xfree(content_type);
     xfree(content_encoding);
+    regfree(&compiled_pattern);
 }
 
-MimeEntry::MimeEntry(const char *aPattern, const decltype(RegexPattern::flags) &reFlags,
+MimeEntry::MimeEntry(const char *aPattern, const regex_t &compiledPattern,
                      const char *aContentType, const char *aContentEncoding,
                      const char *aTransferMode, bool optionViewEnable,
                      bool optionDownloadEnable, const char *anIconName) :
-    pattern(reFlags, aPattern),
+    pattern(xstrdup(aPattern)),
+    compiled_pattern(compiledPattern),
     content_type(xstrdup(aContentType)),
     content_encoding(xstrdup(aContentEncoding)),
     view_option(optionViewEnable),
     download_option(optionDownloadEnable),
-    theIcon(anIconName),
-    next(nullptr)
+    theIcon(anIconName), next(NULL)
 {
     if (!strcasecmp(aTransferMode, "ascii"))
         transfer_mode = 'A';
@@ -8,6 +8,10 @@
 
 /* DEBUG: section 22    Refresh Calculation */
 
+#ifndef USE_POSIX_REGEX
+#define USE_POSIX_REGEX     /* put before includes; always use POSIX */
+#endif
+
 #include "squid.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
@@ -79,7 +83,7 @@ static const RefreshPattern *refreshUncompiledPattern(const char *);
 static OBJH refreshStats;
 static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf);
 
-static RefreshPattern DefaultRefresh(".",std::regex_constants::syntax_option_type());
+static RefreshPattern DefaultRefresh("<none>", 0);
 
 /** Locate the first refresh_pattern rule that matches the given URL by regex.
  *
@@ -693,7 +697,7 @@ refreshStats(StoreEntry * sentry)
                           R->stats.matchCount,
                           R->stats.matchTests,
                           xpercent(R->stats.matchCount, R->stats.matchTests),
-                          (R->pattern.flags & std::regex::icase ? "-i " : ""),
+                          (R->pattern.flags&REG_ICASE ? "-i " : ""),
                           R->pattern.c_str());
     }
 
@@ -37,6 +37,7 @@ MAKETEST="distcheck"
 DISTCHECK_CONFIGURE_FLAGS=" \
 	--disable-build-info \
 	--disable-loadable-modules \
+	--disable-gnuregex \
 	--disable-optimizations \
 	--disable-inline \
 	--disable-debug-cbdata \
@@ -52,6 +52,7 @@ MAKETEST="distcheck"
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=" \
 	--enable-loadable-modules \
+	--enable-gnuregex \
 	--enable-optimizations \
 	--enable-inline \
 	--enable-debug-cbdata \
@@ -52,6 +52,7 @@ MAKETEST="distcheck"
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=" \
 	--enable-loadable-modules \
+	--enable-gnuregex \
 	--enable-optimizations \
 	--enable-inline \
 	--enable-debug-cbdata \
@@ -19,13 +19,6 @@ acl G dstdom_regex \.g...le\.com$
 acl B browser ^Mozilla
 acl B browser ^Java/[0-9]+(\.[0-9]+)?
 
-# double-quotes 'regression' from GNU regex library
-refresh_pattern "foo 0 80% 20160
-refresh_pattern ["] 0 80% 20160
-refresh_pattern "foo\" 0 80% 20160
-refresh_pattern "foo["] 0 80% 20160
-refresh_pattern foo\" 0 80% 20160
-
 # invalid pattern - this should ERROR
 acl foo browser *
 
@@ -47,7 +47,6 @@
 #include <cstdlib>
 #include <cstring>
 #include <fstream>
-#include <regex>
 #include <sys/types.h>
 #include <memory.h>
 
@@ -58,6 +57,9 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
 //          fn (IN): file name of squid.conf to use
 // returns: number of entries, or negative to warn of errors
 {
+    static const char* expression =
+        "^[ \t]*cache_dir([ \t]+([[:alpha:]]+))?[ \t]+([[:graph:]]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)";
+
     // try to open file
     if ( debug ) fprintf( debug, "# trying to open %s\n", fn ? fn : "(null)" );
     std::ifstream cfgin(fn);
@@ -67,15 +69,20 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
     }
 
     // prepare regular expression for matching
-    static const char * expression = "^[ \t]*cache_dir([ \t]+([[:alpha:]]+))?[ \t]+([[:graph:]]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)";
     if ( debug ) fprintf( debug, "# trying to compile \"%s\"\n", expression );
-
-    static const std::regex rexp(expression, std::regex::extended);
+    regex_t rexp;
+    int result = regcomp( &rexp, expression, REG_EXTENDED );
+    if ( result != 0 ) {
+        char buffer[256];
+        regerror( result, &rexp, buffer, sizeof(buffer) );
+        fprintf( stderr, "regular expression \"%s\": %s\n", expression, buffer );
+        return -1;
+    }
 
     // read line by line
     if ( debug ) fputs( "# trying to read lines\n", debug );
 
-    std::smatch subs; // set of std::string so we can use ==
+    regmatch_t subs[8];
     char *s, line[1024];
     CacheDir cd;
     while ( cfgin.getline( line, sizeof(line)) ) {
@@ -88,62 +95,93 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
         if ( *line == '\0' || *line == '\n' ) continue;
 
         // test line
-        std::string tmpLine(line);
-        if (!std::regex_search(tmpLine, subs, rexp))
-            continue;
-
-        // match, please record
-        memset( &cd, 0, sizeof(cd) );
-        if ( debug ) fprintf( debug, "# match '%s' on line %s", subs[0].str().c_str(), line);
-
-        // extract information. If 6th parenthesis is filled, this is
-        // a new squid with disk types, otherwise it is an older version
-        int offset = 2;
-        if (subs[6].str().empty()) {
-            // old version, disk type at position 2 is always UFS
-            cd.type = CacheDir::CDT_UFS;
+        if ( (result=regexec( &rexp, line, 7, subs, 0 )) != 0 ) {
+            // error or no match
+            if ( result != REG_NOMATCH ) {
+                char buffer[256];
+                regerror( result, &rexp, buffer, sizeof(buffer) );
+                fprintf( stderr, "while matching \"%s\" against %s%s\n",
+                         expression, line, buffer );
+                regfree(&rexp);
+                cfgin.close();
+                return -1;
+            }
         } else {
-            // new version, disk type at position 2
-            if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
-            static const std::string ufsDir("ufs",3);
-            static const std::string aufsDir("aufs",4);
-            static const std::string asyncUfsDir("asyncufs",8);
-            static const std::string diskdDir("diskd",5);
-            if (subs[offset] == ufsDir)
+            // match, please record
+            memset( &cd, 0, sizeof(cd) );
+            if ( debug ) fprintf( debug, "# match from %d-%d on line %s",
+                                      (int)subs[0].rm_so, (int)subs[0].rm_eo,
+                                      line );
+
+            // terminate line after matched expression
+            line[ subs[0].rm_eo ] = '\0';
+
+            // extract information. If 6th parenthesis is filled, this is
+            // a new squid with disk types, otherwise it is an older version
+            int offset = 2;
+            if ( subs[6].rm_so == -1 ) {
+                // old version, disk type at position 2 is always UFS
                 cd.type = CacheDir::CDT_UFS;
-            else if (subs[offset] == aufsDir || subs[offset] == asyncUfsDir)
-                cd.type = CacheDir::CDT_AUFS;
-            else if (subs[offset] == diskdDir)
-                cd.type = CacheDir::CDT_DISKD;
-            else
-                cd.type = CacheDir::CDT_OTHER;
+            } else {
+                // new version, disk type at position 2
+                line[ subs[offset].rm_eo ] = '\0';
+                if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
+                                          (int)subs[offset].rm_so,
+                                          (int)subs[offset].rm_eo,
+                                          line+subs[offset].rm_so );
+                if ( strcmp( line + subs[offset].rm_so, "ufs" ) == 0 )
+                    cd.type = CacheDir::CDT_UFS;
+                else if ( strcmp( line + subs[offset].rm_so, "asyncufs" ) == 0 )
+                    cd.type = CacheDir::CDT_AUFS;
+                else if ( strcmp( line + subs[offset].rm_so, "diskd" ) == 0 )
+                    cd.type = CacheDir::CDT_DISKD;
+                else
+                    cd.type = CacheDir::CDT_OTHER;
+                ++offset;
+            }
+
+            // extract base directory
+            line[ subs[offset].rm_eo ] = '\0';
+            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
+                                      (int)subs[offset].rm_so,
+                                      (int)subs[offset].rm_eo,
+                                      line+subs[offset].rm_so );
+            cd.base = xstrdup( line+subs[offset].rm_so );
             ++offset;
-        }
 
-        // extract base directory
-        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
-        cd.base = xstrdup(subs[offset].str().c_str());
-        ++offset;
-
-        // extract size information
-        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
-        cd.size = strtoul(subs[offset].str().c_str(), 0, 10);
-        ++offset;
+            // extract size information
+            line[ subs[offset].rm_eo ] = '\0';
+            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
+                                      (int)subs[offset].rm_so,
+                                      (int)subs[offset].rm_eo,
+                                      line+subs[offset].rm_so );
+            cd.size = strtoul( line+subs[offset].rm_so, 0, 10 );
+            ++offset;
 
-        // extract 1st level directories
-        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
-        cd.level[0] = strtoul(subs[offset].str().c_str(), 0, 10);
-        ++offset;
+            // extract 1st level directories
+            line[ subs[offset].rm_eo ] = '\0';
+            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
+                                      (int)subs[offset].rm_so,
+                                      (int)subs[offset].rm_eo,
+                                      line+subs[offset].rm_so );
+            cd.level[0] = strtoul( line+subs[offset].rm_so, 0, 10 );
+            ++offset;
 
-        // extract 2nd level directories
-        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
-        cd.level[1] = strtoul(subs[offset].str().c_str(), 0, 10);
-        ++offset;
+            // extract 2nd level directories
+            line[ subs[offset].rm_eo ] = '\0';
+            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
+                                      (int)subs[offset].rm_so,
+                                      (int)subs[offset].rm_eo,
+                                      line+subs[offset].rm_so );
+            cd.level[1] = strtoul( line+subs[offset].rm_so, 0, 10 );
+            ++offset;
 
-        cachedir.push_back( cd );
+            cachedir.push_back( cd );
+        }
     }
 
     cfgin.close();
+    regfree(&rexp);
     return cachedir.size();
 }
 
@@ -108,7 +108,6 @@
 #include <cstdlib>
 #include <cstring>
 #include <dirent.h>
-#include <regex>
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <fcntl.h>
@@ -153,29 +152,50 @@ static const char* programname = 0;
 
 // ----------------------------------------------------------------------
 
-class REList
-{
-public:
-    REList( const char* what, bool doCase ) :
-        next(nullptr),
-        data(xstrdup(what)),
-        rexp(data, std::regex::extended | std::regex::nosubs |
-             (doCase ? std::regex_constants::syntax_option_type() : std::regex::icase) )
-    {}
-
-    ~REList() {
-        if (next) delete next;
-        xfree(data);
-    }
-
-    bool match(const char *check) const {return std::regex_match(check, rexp);}
+struct REList {
+    REList( const char* what, bool doCase );
+    ~REList();
+    bool match( const char* check ) const;
 
     REList*     next;
     const char* data;
-private:
-    std::regex  rexp;
+    regex_t     rexp;
 };
 
+REList::REList( const char* what, bool doCase )
+    :next(0),data(xstrdup(what))
+{
+    int result = regcomp( &rexp, what,
+                          REG_EXTENDED | REG_NOSUB | (doCase ? 0 : REG_ICASE) );
+    if ( result != 0 ) {
+        char buffer[256];
+        regerror( result, &rexp, buffer, 256 );
+        fprintf( stderr, "unable to compile re \"%s\": %s\n", what, buffer );
+        exit(1);
+    }
+}
+
+REList::~REList()
+{
+    if ( next ) delete next;
+    if ( data ) xfree((void*) data);
+    regfree(&rexp);
+}
+
+bool
+REList::match( const char* check ) const
+{
+    int result = regexec( &rexp, check, 0, 0, 0 );
+    if ( result != 0 && result != REG_NOMATCH ) {
+        char buffer[256];
+        regerror( result, &rexp, buffer, 256 );
+        fprintf( stderr, "unable to execute re \"%s\"\n+ on line \"%s\": %s\n",
+                 data, check, buffer );
+        exit(1);
+    }
+    return ( result == 0 );
+}
+
 // ----------------------------------------------------------------------
 
 char*
@@ -430,12 +450,12 @@ match( const char* fn, const REList* list )
                 if ( list == 0 )
                     flag = action( fd, datastart, fn, (char*) urlmeta->data, meta );
                 else {
-                    const REList * head = list;
-                    while (head) {
+                    REList* head = (REList*) list; // YUCK!
+                    while ( head != 0 ) {
                         if ( head->match( (char*) urlmeta->data ) ) break;
                         head = head->next;
                     }
-                    if (head)
+                    if ( head != 0 )
                         flag = action( fd, datastart, fn, (char*) urlmeta->data, meta );
                     else flag = true;
                 }
@@ -620,7 +640,7 @@ parseCommandline( int argc, char* argv[], REList*& head,
     ::programname = ptr;
 
     // extract commandline parameters
-    REList* tail = head = nullptr;
+    REList* tail = head = 0;
     opterr = 0;
     while ( (option = getopt( argc, argv, "ac:C:d:E:e:F:f:Hnp:P:sv" )) != -1 ) {
         switch ( option ) {
@@ -658,16 +678,11 @@ parseCommandline( int argc, char* argv[], REList*& head,
                 fprintf( stderr, "%c requires a regex pattern argument!\n", option );
                 exit(1);
             }
-            try { // std::regex constructor throws on pattern errors
-                if (!head)
-                    tail = head = new REList( optarg, option=='E' );
-                else {
-                    tail->next = new REList( optarg, option=='E' );
-                    tail = tail->next;
-                }
-            } catch (std::regex_error &e) {
-                fprintf(stderr, "%c contains invalid regular expression: %s\n", option, optarg);
-                exit(1);
+            if ( head == 0 )
+                tail = head = new REList( optarg, option=='E' );
+            else {
+                tail->next = new REList( optarg, option=='E' );
+                tail = tail->next;
             }
             break;
 
@@ -695,17 +710,11 @@ parseCommandline( int argc, char* argv[], REList*& head,
                         --len;
                     }
 
-                    try { // std::regex constructor throws on pattern errors
-                        // insert into list of expressions
-                        if (!head)
-                            tail = head = new REList(line,option=='F');
-                        else {
-                            tail->next = new REList(line,option=='F');
-                            tail = tail->next;
-                        }
-                    } catch (std::regex_error &e) {
-                        fprintf(stderr, "%s:%lu: invalid regular expression\n", optarg, lineno);
-                        exit(1);
+                    // insert into list of expressions
+                    if ( head == 0 ) tail = head = new REList(line,option=='F');
+                    else {
+                        tail->next = new REList(line,option=='F');
+                        tail = tail->next;
                     }
                 }
                 fclose(rfile);
@@ -880,7 +889,7 @@ int
 main( int argc, char* argv[] )
 {
     // setup variables
-    REList* list = nullptr;
+    REList* list = 0;
     char* conffile = xstrdup( DEFAULT_SQUID_CONF );
     serverPort = htons(DEFAULTPORT);
     if ( convertHostname(DEFAULTHOST,serverHost) == -1 ) {