@@ -18,20 +18,20 @@
  *   is optional
  */
 
-#if ! HAVE_CONFIG_H
+#if !HAVE_CONFIG_H
 
 #include <stdlib.h>
 
 #include <string.h>
 
 #ifndef __USE_ISOC99 /* required for NAN */
-# define DISABLE_ISOC99 1
-# define __USE_ISOC99 1
+#define DISABLE_ISOC99 1
+#define __USE_ISOC99 1
 #endif /* !defined(__USE_ISOC99) */
 #include <math.h>
 #if DISABLE_ISOC99
-# undef DISABLE_ISOC99
-# undef __USE_ISOC99
+#undef DISABLE_ISOC99
+#undef __USE_ISOC99
 #endif /* DISABLE_ISOC99 */
 
 #include <time.h>
@@ -50,10 +50,7 @@
  * - minimum allowed value
  * - maximum allowed value
  */
-static data_source_t dsrc[1] =
-{
-	{ "my_ds", DS_TYPE_GAUGE, 0, NAN }
-};
+static data_source_t dsrc[1] = {{"my_ds", DS_TYPE_GAUGE, 0, NAN}};
 
 /*
  * data set definition:
@@ -67,174 +64,163 @@ static data_source_t dsrc[1] =
  * It is strongly recommended to use one of the types and data-sets
  * pre-defined in the types.db file.
  */
-static data_set_t ds =
-{
-	"myplugin", STATIC_ARRAY_SIZE (dsrc), dsrc
-};
+static data_set_t ds = {"myplugin", STATIC_ARRAY_SIZE(dsrc), dsrc};
 
 /*
  * This function is called once upon startup to initialize the plugin.
  */
-static int my_init (void)
-{
-	/* open sockets, initialize data structures, ... */
+static int my_init(void) {
+  /* open sockets, initialize data structures, ... */
 
-	/* A return value != 0 indicates an error and causes the plugin to be
-	   disabled. */
-    return 0;
+  /* A return value != 0 indicates an error and causes the plugin to be
+     disabled. */
+  return 0;
 } /* static int my_init (void) */
 
 /*
  * This is a utility function used by the read callback to populate a
  * value_list_t and pass it to plugin_dispatch_values.
  */
-static int my_submit (gauge_t value)
-{
-	value_list_t vl = VALUE_LIST_INIT;
-
-	/* Convert the gauge_t to a value_t and add it to the value_list_t. */
-	vl.values = &(value_t) { .gauge = value };
-	vl.values_len = 1;
-
-	/* Only set vl.time yourself if you update multiple metrics (i.e. you
-	 * have multiple calls to plugin_dispatch_values()) and they need to all
-	 * have the same timestamp. */
-	/* vl.time = cdtime(); */
-
-	sstrncpy (vl.plugin, "myplugin", sizeof (vl.plugin));
-
-	/* it is strongly recommended to use a type defined in the types.db file
-	 * instead of a custom type */
-	sstrncpy (vl.type, "myplugin", sizeof (vl.type));
-	/* optionally set vl.plugin_instance and vl.type_instance to reasonable
-	 * values (default: "") */
-
-	/* dispatch the values to collectd which passes them on to all registered
-	 * write functions */
-	return plugin_dispatch_values (&vl);
+static int my_submit(gauge_t value) {
+  value_list_t vl = VALUE_LIST_INIT;
+
+  /* Convert the gauge_t to a value_t and add it to the value_list_t. */
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
+
+  /* Only set vl.time yourself if you update multiple metrics (i.e. you
+   * have multiple calls to plugin_dispatch_values()) and they need to all
+   * have the same timestamp. */
+  /* vl.time = cdtime(); */
+
+  sstrncpy(vl.plugin, "myplugin", sizeof(vl.plugin));
+
+  /* it is strongly recommended to use a type defined in the types.db file
+   * instead of a custom type */
+  sstrncpy(vl.type, "myplugin", sizeof(vl.type));
+  /* optionally set vl.plugin_instance and vl.type_instance to reasonable
+   * values (default: "") */
+
+  /* dispatch the values to collectd which passes them on to all registered
+   * write functions */
+  return plugin_dispatch_values(&vl);
 }
 
 /*
  * This function is called in regular intervalls to collect the data.
  */
-static int my_read (void)
-{
-	/* do the magic to read the data */
-	gauge_t value = random ();
+static int my_read(void) {
+  /* do the magic to read the data */
+  gauge_t value = random();
 
-	if (my_submit (value) != 0)
-		WARNING ("myplugin plugin: Dispatching a random value failed.");
+  if (my_submit(value) != 0)
+    WARNING("myplugin plugin: Dispatching a random value failed.");
 
-	/* A return value != 0 indicates an error and the plugin will be skipped
-	 * for an increasing amount of time. */
-	return 0;
+  /* A return value != 0 indicates an error and the plugin will be skipped
+   * for an increasing amount of time. */
+  return 0;
 } /* static int my_read (void) */
 
 /*
  * This function is called after values have been dispatched to collectd.
  */
-static int my_write (const data_set_t *ds, const value_list_t *vl,
-		user_data_t *ud)
-{
-	char name[1024] = "";
-	int i = 0;
-
-	if (ds->ds_num != vl->values_len) {
-		plugin_log (LOG_WARNING, "DS number does not match values length");
-		return -1;
-	}
-
-	/* get the default base filename for the output file - depending on the
-	 * provided values this will be something like
-	 * <host>/<plugin>[-<plugin_type>]/<instance>[-<instance_type>] */
-	if (0 != format_name (name, 1024, vl->host, vl->plugin,
-			vl->plugin_instance, ds->type, vl->type_instance))
-		return -1;
-
-	for (i = 0; i < ds->ds_num; ++i) {
-		/* do the magic to output the data */
-		printf ("%s (%s) at %i: ", name,
-				(ds->ds->type == DS_TYPE_GAUGE) ? "GAUGE" : "COUNTER",
-				(int)vl->time);
-
-		if (ds->ds->type == DS_TYPE_GAUGE)
-			printf ("%f\n", vl->values[i].gauge);
-		else
-			printf ("%lld\n", vl->values[i].counter);
-	}
-	return 0;
+static int my_write(const data_set_t *ds, const value_list_t *vl,
+                    user_data_t *ud) {
+  char name[1024] = "";
+  int i = 0;
+
+  if (ds->ds_num != vl->values_len) {
+    plugin_log(LOG_WARNING, "DS number does not match values length");
+    return -1;
+  }
+
+  /* get the default base filename for the output file - depending on the
+   * provided values this will be something like
+   * <host>/<plugin>[-<plugin_type>]/<instance>[-<instance_type>] */
+  if (0 != format_name(name, 1024, vl->host, vl->plugin, vl->plugin_instance,
+                       ds->type, vl->type_instance))
+    return -1;
+
+  for (i = 0; i < ds->ds_num; ++i) {
+    /* do the magic to output the data */
+    printf("%s (%s) at %i: ", name,
+           (ds->ds->type == DS_TYPE_GAUGE) ? "GAUGE" : "COUNTER",
+           (int)vl->time);
+
+    if (ds->ds->type == DS_TYPE_GAUGE)
+      printf("%f\n", vl->values[i].gauge);
+    else
+      printf("%lld\n", vl->values[i].counter);
+  }
+  return 0;
 } /* static int my_write (data_set_t *, value_list_t *) */
 
 /*
  * This function is called when plugin_log () has been used.
  */
-static void my_log (int severity, const char *msg, user_data_t *ud)
-{
-	printf ("LOG: %i - %s\n", severity, msg);
-	return;
+static void my_log(int severity, const char *msg, user_data_t *ud) {
+  printf("LOG: %i - %s\n", severity, msg);
+  return;
 } /* static void my_log (int, const char *) */
 
 /*
  * This function is called when plugin_dispatch_notification () has been used.
  */
-static int my_notify (const notification_t *notif, user_data_t *ud)
-{
-	char time_str[32] = "";
-	struct tm *tm = NULL;
+static int my_notify(const notification_t *notif, user_data_t *ud) {
+  char time_str[32] = "";
+  struct tm *tm = NULL;
 
-	int n = 0;
+  int n = 0;
 
-	if (NULL == (tm = localtime (&notif->time)))
-		time_str[0] = '\0';
+  if (NULL == (tm = localtime(&notif->time)))
+    time_str[0] = '\0';
 
-	n = strftime (time_str, 32, "%F %T", tm);
-	if (n >= 32) n = 31;
-	time_str[n] = '\0';
+  n = strftime(time_str, 32, "%F %T", tm);
+  if (n >= 32)
+    n = 31;
+  time_str[n] = '\0';
 
-	printf ("NOTIF (%s): %i - ", time_str, notif->severity);
+  printf("NOTIF (%s): %i - ", time_str, notif->severity);
 
-	if ('\0' != *notif->host)
-		printf ("%s: ", notif->host);
+  if ('\0' != *notif->host)
+    printf("%s: ", notif->host);
 
-	if ('\0' != *notif->plugin)
-		printf ("%s: ", notif->plugin);
+  if ('\0' != *notif->plugin)
+    printf("%s: ", notif->plugin);
 
-	if ('\0' != *notif->plugin_instance)
-		printf ("%s: ", notif->plugin_instance);
+  if ('\0' != *notif->plugin_instance)
+    printf("%s: ", notif->plugin_instance);
 
-	if ('\0' != *notif->type)
-		printf ("%s: ", notif->type);
+  if ('\0' != *notif->type)
+    printf("%s: ", notif->type);
 
-	if ('\0' != *notif->type_instance)
-		printf ("%s: ", notif->type_instance);
+  if ('\0' != *notif->type_instance)
+    printf("%s: ", notif->type_instance);
 
-	printf ("%s\n", notif->message);
-	return 0;
+  printf("%s\n", notif->message);
+  return 0;
 } /* static int my_notify (notification_t *) */
 
 /*
  * This function is called before shutting down collectd.
  */
-static int my_shutdown (void)
-{
-	/* close sockets, free data structures, ... */
-	return 0;
+static int my_shutdown(void) {
+  /* close sockets, free data structures, ... */
+  return 0;
 } /* static int my_shutdown (void) */
 
 /*
  * This function is called after loading the plugin to register it with
  * collectd.
  */
-void module_register (void)
-{
-	plugin_register_log ("myplugin", my_log, /* user data */ NULL);
-	plugin_register_notification ("myplugin", my_notify,
-			/* user data */ NULL);
-	plugin_register_data_set (&ds);
-	plugin_register_read ("myplugin", my_read);
-	plugin_register_init ("myplugin", my_init);
-	plugin_register_write ("myplugin", my_write, /* user data */ NULL);
-	plugin_register_shutdown ("myplugin", my_shutdown);
-    return;
+void module_register(void) {
+  plugin_register_log("myplugin", my_log, /* user data */ NULL);
+  plugin_register_notification("myplugin", my_notify,
+                               /* user data */ NULL);
+  plugin_register_data_set(&ds);
+  plugin_register_read("myplugin", my_read);
+  plugin_register_init("myplugin", my_init);
+  plugin_register_write("myplugin", my_write, /* user data */ NULL);
+  plugin_register_shutdown("myplugin", my_shutdown);
+  return;
 } /* void module_register (void) */
-
@@ -33,12 +33,11 @@ service Collectd {
   // PutValues reads the value lists from the PutValuesRequest stream.
   // The gRPC server embedded into collectd will inject them into the system
   // just like the network plugin.
-  rpc PutValues(stream PutValuesRequest)
-      returns (PutValuesResponse);
+  rpc PutValues(stream PutValuesRequest) returns(PutValuesResponse);
 
   // QueryValues returns a stream of matching value lists from collectd's
   // internal cache.
-  rpc QueryValues(QueryValuesRequest) returns (stream QueryValuesResponse);
+  rpc QueryValues(QueryValuesRequest) returns(stream QueryValuesResponse);
 }
 
 // The arguments to PutValues.
@@ -17,45 +17,36 @@ package io.prometheus.client;
 option java_package = "io.prometheus.client";
 
 message LabelPair {
-  optional string name  = 1;
+  optional string name = 1;
   optional string value = 2;
 }
 
 enum MetricType {
-  COUNTER    = 0;
-  GAUGE      = 1;
-  SUMMARY    = 2;
-  UNTYPED    = 3;
-  HISTOGRAM  = 4;
+  COUNTER = 0; GAUGE = 1; SUMMARY = 2; UNTYPED = 3; HISTOGRAM = 4;
 }
 
-message Gauge {
-  optional double value = 1;
-}
+message Gauge { optional double value = 1; }
 
-message Counter {
-  optional double value = 1;
-}
+message Counter { optional double value = 1; }
 
 message Quantile {
   optional double quantile = 1;
-  optional double value    = 2;
+  optional double value = 2;
 }
 
 message Summary {
-  optional uint64   sample_count = 1;
-  optional double   sample_sum   = 2;
-  repeated Quantile quantile     = 3;
+  optional uint64 sample_count = 1;
+  optional double sample_sum = 2;
+  repeated Quantile quantile = 3;
 }
 
-message Untyped {
-  optional double value = 1;
-}
+message Untyped { optional double value = 1; }
 
 message Histogram {
   optional uint64 sample_count = 1;
-  optional double sample_sum   = 2;
-  repeated Bucket bucket       = 3; // Ordered in increasing order of upper_bound, +Inf bucket is optional.
+  optional double sample_sum = 2;
+  repeated Bucket bucket =
+      3; // Ordered in increasing order of upper_bound, +Inf bucket is optional.
 }
 
 message Bucket {
@@ -64,18 +55,18 @@ message Bucket {
 }
 
 message Metric {
-  repeated LabelPair label        = 1;
-  optional Gauge     gauge        = 2;
-  optional Counter   counter      = 3;
-  optional Summary   summary      = 4;
-  optional Untyped   untyped      = 5;
-  optional Histogram histogram    = 7;
-  optional int64     timestamp_ms = 6;
+  repeated LabelPair label = 1;
+  optional Gauge gauge = 2;
+  optional Counter counter = 3;
+  optional Summary summary = 4;
+  optional Untyped untyped = 5;
+  optional Histogram histogram = 7;
+  optional int64 timestamp_ms = 6;
 }
 
 message MetricFamily {
-  optional string     name   = 1;
-  optional string     help   = 2;
-  optional MetricType type   = 3;
-  repeated Metric     metric = 4;
+  optional string name = 1;
+  optional string help = 2;
+  optional MetricType type = 3;
+  repeated Metric metric = 4;
 }
@@ -26,14 +26,14 @@
 
 #include "collectd.h"
 
-#include "plugin.h"
 #include "common.h"
 #include "meta_data.h"
+#include "plugin.h"
 #include "utils_cache.h" /* for uc_get_rate() */
 #include "utils_subst.h"
 #include "utils_vl_lookup.h"
 
-#define AGG_MATCHES_ALL(str) (strcmp ("/.*/", str) == 0)
+#define AGG_MATCHES_ALL(str) (strcmp("/.*/", str) == 0)
 #define AGG_FUNC_PLACEHOLDER "%{aggregation}"
 
 struct aggregation_s /* {{{ */
@@ -88,14 +88,14 @@ static lookup_t *lookup = NULL;
 static pthread_mutex_t agg_instance_list_lock = PTHREAD_MUTEX_INITIALIZER;
 static agg_instance_t *agg_instance_list_head = NULL;
 
-static _Bool agg_is_regex (char const *str) /* {{{ */
+static _Bool agg_is_regex(char const *str) /* {{{ */
 {
   size_t len;
 
   if (str == NULL)
     return (0);
 
-  len = strlen (str);
+  len = strlen(str);
   if (len < 3)
     return (0);
 
@@ -105,179 +105,175 @@ static _Bool agg_is_regex (char const *str) /* {{{ */
     return (0);
 } /* }}} _Bool agg_is_regex */
 
-static void agg_destroy (aggregation_t *agg) /* {{{ */
+static void agg_destroy(aggregation_t *agg) /* {{{ */
 {
-  sfree (agg);
+  sfree(agg);
 } /* }}} void agg_destroy */
 
 /* Frees all dynamically allocated memory within the instance. */
-static void agg_instance_destroy (agg_instance_t *inst) /* {{{ */
+static void agg_instance_destroy(agg_instance_t *inst) /* {{{ */
 {
   if (inst == NULL)
     return;
 
   /* Remove this instance from the global list of instances. */
-  pthread_mutex_lock (&agg_instance_list_lock);
+  pthread_mutex_lock(&agg_instance_list_lock);
   if (agg_instance_list_head == inst)
     agg_instance_list_head = inst->next;
-  else if (agg_instance_list_head != NULL)
-  {
+  else if (agg_instance_list_head != NULL) {
     agg_instance_t *prev = agg_instance_list_head;
     while ((prev != NULL) && (prev->next != inst))
       prev = prev->next;
     if (prev != NULL)
       prev->next = inst->next;
   }
-  pthread_mutex_unlock (&agg_instance_list_lock);
+  pthread_mutex_unlock(&agg_instance_list_lock);
 
-  sfree (inst->state_num);
-  sfree (inst->state_sum);
-  sfree (inst->state_average);
-  sfree (inst->state_min);
-  sfree (inst->state_max);
-  sfree (inst->state_stddev);
+  sfree(inst->state_num);
+  sfree(inst->state_sum);
+  sfree(inst->state_average);
+  sfree(inst->state_min);
+  sfree(inst->state_max);
+  sfree(inst->state_stddev);
 
-  memset (inst, 0, sizeof (*inst));
+  memset(inst, 0, sizeof(*inst));
   inst->ds_type = -1;
   inst->min = NAN;
   inst->max = NAN;
 } /* }}} void agg_instance_destroy */
 
-static int agg_instance_create_name (agg_instance_t *inst, /* {{{ */
-    value_list_t const *vl, aggregation_t const *agg)
-{
-#define COPY_FIELD(buffer, buffer_size, field, group_mask, all_value) do { \
-  if (agg->set_ ## field != NULL) \
-    sstrncpy (buffer, agg->set_ ## field, buffer_size); \
-  else if ((agg->regex_fields & group_mask) \
-      && (agg->group_by & group_mask)) \
-    sstrncpy (buffer, vl->field, buffer_size); \
-  else if ((agg->regex_fields & group_mask) \
-      && (AGG_MATCHES_ALL (agg->ident.field))) \
-    sstrncpy (buffer, all_value, buffer_size); \
-  else \
-    sstrncpy (buffer, agg->ident.field, buffer_size); \
-} while (0)
+static int agg_instance_create_name(agg_instance_t *inst, /* {{{ */
+                                    value_list_t const *vl,
+                                    aggregation_t const *agg) {
+#define COPY_FIELD(buffer, buffer_size, field, group_mask, all_value)          \
+  do {                                                                         \
+    if (agg->set_##field != NULL)                                              \
+      sstrncpy(buffer, agg->set_##field, buffer_size);                         \
+    else if ((agg->regex_fields & group_mask) && (agg->group_by & group_mask)) \
+      sstrncpy(buffer, vl->field, buffer_size);                                \
+    else if ((agg->regex_fields & group_mask) &&                               \
+             (AGG_MATCHES_ALL(agg->ident.field)))                              \
+      sstrncpy(buffer, all_value, buffer_size);                                \
+    else                                                                       \
+      sstrncpy(buffer, agg->ident.field, buffer_size);                         \
+  } while (0)
 
   /* Host */
-  COPY_FIELD (inst->ident.host, sizeof (inst->ident.host),
-      host, LU_GROUP_BY_HOST, "global");
+  COPY_FIELD(inst->ident.host, sizeof(inst->ident.host), host, LU_GROUP_BY_HOST,
+             "global");
 
   /* Plugin */
   if (agg->set_plugin != NULL)
-    sstrncpy (inst->ident.plugin, agg->set_plugin,
-        sizeof (inst->ident.plugin));
+    sstrncpy(inst->ident.plugin, agg->set_plugin, sizeof(inst->ident.plugin));
   else
-    sstrncpy (inst->ident.plugin, "aggregation", sizeof (inst->ident.plugin));
+    sstrncpy(inst->ident.plugin, "aggregation", sizeof(inst->ident.plugin));
 
   /* Plugin instance */
   if (agg->set_plugin_instance != NULL)
-    sstrncpy (inst->ident.plugin_instance, agg->set_plugin_instance,
-        sizeof (inst->ident.plugin_instance));
-  else
-  {
+    sstrncpy(inst->ident.plugin_instance, agg->set_plugin_instance,
+             sizeof(inst->ident.plugin_instance));
+  else {
     char tmp_plugin[DATA_MAX_NAME_LEN];
     char tmp_plugin_instance[DATA_MAX_NAME_LEN] = "";
 
-    if ((agg->regex_fields & LU_GROUP_BY_PLUGIN)
-        && (agg->group_by & LU_GROUP_BY_PLUGIN))
-      sstrncpy (tmp_plugin, vl->plugin, sizeof (tmp_plugin));
-    else if ((agg->regex_fields & LU_GROUP_BY_PLUGIN)
-        && (AGG_MATCHES_ALL (agg->ident.plugin)))
-      sstrncpy (tmp_plugin, "", sizeof (tmp_plugin));
+    if ((agg->regex_fields & LU_GROUP_BY_PLUGIN) &&
+        (agg->group_by & LU_GROUP_BY_PLUGIN))
+      sstrncpy(tmp_plugin, vl->plugin, sizeof(tmp_plugin));
+    else if ((agg->regex_fields & LU_GROUP_BY_PLUGIN) &&
+             (AGG_MATCHES_ALL(agg->ident.plugin)))
+      sstrncpy(tmp_plugin, "", sizeof(tmp_plugin));
     else
-      sstrncpy (tmp_plugin, agg->ident.plugin, sizeof (tmp_plugin));
-
-    if ((agg->regex_fields & LU_GROUP_BY_PLUGIN_INSTANCE)
-        && (agg->group_by & LU_GROUP_BY_PLUGIN_INSTANCE))
-      sstrncpy (tmp_plugin_instance, vl->plugin_instance,
-          sizeof (tmp_plugin_instance));
-    else if ((agg->regex_fields & LU_GROUP_BY_PLUGIN_INSTANCE)
-        && (AGG_MATCHES_ALL (agg->ident.plugin_instance)))
-      sstrncpy (tmp_plugin_instance, "", sizeof (tmp_plugin_instance));
+      sstrncpy(tmp_plugin, agg->ident.plugin, sizeof(tmp_plugin));
+
+    if ((agg->regex_fields & LU_GROUP_BY_PLUGIN_INSTANCE) &&
+        (agg->group_by & LU_GROUP_BY_PLUGIN_INSTANCE))
+      sstrncpy(tmp_plugin_instance, vl->plugin_instance,
+               sizeof(tmp_plugin_instance));
+    else if ((agg->regex_fields & LU_GROUP_BY_PLUGIN_INSTANCE) &&
+             (AGG_MATCHES_ALL(agg->ident.plugin_instance)))
+      sstrncpy(tmp_plugin_instance, "", sizeof(tmp_plugin_instance));
     else
-      sstrncpy (tmp_plugin_instance, agg->ident.plugin_instance,
-          sizeof (tmp_plugin_instance));
-
-    if ((strcmp ("", tmp_plugin) == 0)
-        && (strcmp ("", tmp_plugin_instance) == 0))
-      sstrncpy (inst->ident.plugin_instance, AGG_FUNC_PLACEHOLDER,
-          sizeof (inst->ident.plugin_instance));
-    else if (strcmp ("", tmp_plugin) != 0)
-      ssnprintf (inst->ident.plugin_instance,
-          sizeof (inst->ident.plugin_instance),
-          "%s-%s", tmp_plugin, AGG_FUNC_PLACEHOLDER);
-    else if (strcmp ("", tmp_plugin_instance) != 0)
-      ssnprintf (inst->ident.plugin_instance,
-          sizeof (inst->ident.plugin_instance),
-          "%s-%s", tmp_plugin_instance, AGG_FUNC_PLACEHOLDER);
+      sstrncpy(tmp_plugin_instance, agg->ident.plugin_instance,
+               sizeof(tmp_plugin_instance));
+
+    if ((strcmp("", tmp_plugin) == 0) && (strcmp("", tmp_plugin_instance) == 0))
+      sstrncpy(inst->ident.plugin_instance, AGG_FUNC_PLACEHOLDER,
+               sizeof(inst->ident.plugin_instance));
+    else if (strcmp("", tmp_plugin) != 0)
+      ssnprintf(inst->ident.plugin_instance,
+                sizeof(inst->ident.plugin_instance), "%s-%s", tmp_plugin,
+                AGG_FUNC_PLACEHOLDER);
+    else if (strcmp("", tmp_plugin_instance) != 0)
+      ssnprintf(inst->ident.plugin_instance,
+                sizeof(inst->ident.plugin_instance), "%s-%s",
+                tmp_plugin_instance, AGG_FUNC_PLACEHOLDER);
     else
-      ssnprintf (inst->ident.plugin_instance,
-          sizeof (inst->ident.plugin_instance),
-          "%s-%s-%s", tmp_plugin, tmp_plugin_instance, AGG_FUNC_PLACEHOLDER);
+      ssnprintf(inst->ident.plugin_instance,
+                sizeof(inst->ident.plugin_instance), "%s-%s-%s", tmp_plugin,
+                tmp_plugin_instance, AGG_FUNC_PLACEHOLDER);
   }
 
   /* Type */
-  sstrncpy (inst->ident.type, agg->ident.type, sizeof (inst->ident.type));
+  sstrncpy(inst->ident.type, agg->ident.type, sizeof(inst->ident.type));
 
   /* Type instance */
-  COPY_FIELD (inst->ident.type_instance, sizeof (inst->ident.type_instance),
-      type_instance, LU_GROUP_BY_TYPE_INSTANCE, "");
+  COPY_FIELD(inst->ident.type_instance, sizeof(inst->ident.type_instance),
+             type_instance, LU_GROUP_BY_TYPE_INSTANCE, "");
 
 #undef COPY_FIELD
 
   return (0);
 } /* }}} int agg_instance_create_name */
 
 /* Create a new aggregation instance. */
-static agg_instance_t *agg_instance_create (data_set_t const *ds, /* {{{ */
-    value_list_t const *vl, aggregation_t *agg)
-{
+static agg_instance_t *agg_instance_create(data_set_t const *ds, /* {{{ */
+                                           value_list_t const *vl,
+                                           aggregation_t *agg) {
   agg_instance_t *inst;
 
-  DEBUG ("aggregation plugin: Creating new instance.");
+  DEBUG("aggregation plugin: Creating new instance.");
 
-  inst = calloc (1, sizeof (*inst));
-  if (inst == NULL)
-  {
-    ERROR ("aggregation plugin: calloc() failed.");
+  inst = calloc(1, sizeof(*inst));
+  if (inst == NULL) {
+    ERROR("aggregation plugin: calloc() failed.");
     return (NULL);
   }
-  pthread_mutex_init (&inst->lock, /* attr = */ NULL);
+  pthread_mutex_init(&inst->lock, /* attr = */ NULL);
 
   inst->ds_type = ds->ds[0].type;
 
-  agg_instance_create_name (inst, vl, agg);
+  agg_instance_create_name(inst, vl, agg);
 
   inst->min = NAN;
   inst->max = NAN;
 
-#define INIT_STATE(field) do { \
-  inst->state_ ## field = NULL; \
-  if (agg->calc_ ## field) { \
-    inst->state_ ## field = calloc (1, sizeof (*inst->state_ ## field)); \
-    if (inst->state_ ## field == NULL) { \
-      agg_instance_destroy (inst); \
-      free (inst); \
-      ERROR ("aggregation plugin: calloc() failed."); \
-      return (NULL); \
-    } \
-  } \
-} while (0)
-
-  INIT_STATE (num);
-  INIT_STATE (sum);
-  INIT_STATE (average);
-  INIT_STATE (min);
-  INIT_STATE (max);
-  INIT_STATE (stddev);
+#define INIT_STATE(field)                                                      \
+  do {                                                                         \
+    inst->state_##field = NULL;                                                \
+    if (agg->calc_##field) {                                                   \
+      inst->state_##field = calloc(1, sizeof(*inst->state_##field));           \
+      if (inst->state_##field == NULL) {                                       \
+        agg_instance_destroy(inst);                                            \
+        free(inst);                                                            \
+        ERROR("aggregation plugin: calloc() failed.");                         \
+        return (NULL);                                                         \
+      }                                                                        \
+    }                                                                          \
+  } while (0)
+
+  INIT_STATE(num);
+  INIT_STATE(sum);
+  INIT_STATE(average);
+  INIT_STATE(min);
+  INIT_STATE(max);
+  INIT_STATE(stddev);
 
 #undef INIT_STATE
 
-  pthread_mutex_lock (&agg_instance_list_lock);
+  pthread_mutex_lock(&agg_instance_list_lock);
   inst->next = agg_instance_list_head;
   agg_instance_list_head = inst;
-  pthread_mutex_unlock (&agg_instance_list_lock);
+  pthread_mutex_unlock(&agg_instance_list_lock);
 
   return (inst);
 } /* }}} agg_instance_t *agg_instance_create */
@@ -286,91 +282,87 @@ static agg_instance_t *agg_instance_create (data_set_t const *ds, /* {{{ */
  * the rate of the value list is available. Value lists with more than one data
  * source are not supported and will return an error. Returns zero on success
  * and non-zero otherwise. */
-static int agg_instance_update (agg_instance_t *inst, /* {{{ */
-    data_set_t const *ds, value_list_t const *vl)
-{
+static int agg_instance_update(agg_instance_t *inst, /* {{{ */
+                               data_set_t const *ds, value_list_t const *vl) {
   gauge_t *rate;
 
-  if (ds->ds_num != 1)
-  {
-    ERROR ("aggregation plugin: The \"%s\" type (data set) has more than one "
-        "data source. This is currently not supported by this plugin. "
-        "Sorry.", ds->type);
+  if (ds->ds_num != 1) {
+    ERROR("aggregation plugin: The \"%s\" type (data set) has more than one "
+          "data source. This is currently not supported by this plugin. "
+          "Sorry.",
+          ds->type);
     return (EINVAL);
   }
 
-  rate = uc_get_rate (ds, vl);
-  if (rate == NULL)
-  {
+  rate = uc_get_rate(ds, vl);
+  if (rate == NULL) {
     char ident[6 * DATA_MAX_NAME_LEN];
-    FORMAT_VL (ident, sizeof (ident), vl);
-    ERROR ("aggregation plugin: Unable to read the current rate of \"%s\".",
-        ident);
+    FORMAT_VL(ident, sizeof(ident), vl);
+    ERROR("aggregation plugin: Unable to read the current rate of \"%s\".",
+          ident);
     return (ENOENT);
   }
 
-  if (isnan (rate[0]))
-  {
-    sfree (rate);
+  if (isnan(rate[0])) {
+    sfree(rate);
     return (0);
   }
 
-  pthread_mutex_lock (&inst->lock);
+  pthread_mutex_lock(&inst->lock);
 
   inst->num++;
   inst->sum += rate[0];
   inst->squares_sum += (rate[0] * rate[0]);
 
-  if (isnan (inst->min) || (inst->min > rate[0]))
+  if (isnan(inst->min) || (inst->min > rate[0]))
     inst->min = rate[0];
-  if (isnan (inst->max) || (inst->max < rate[0]))
+  if (isnan(inst->max) || (inst->max < rate[0]))
     inst->max = rate[0];
 
-  pthread_mutex_unlock (&inst->lock);
+  pthread_mutex_unlock(&inst->lock);
 
-  sfree (rate);
+  sfree(rate);
   return (0);
 } /* }}} int agg_instance_update */
 
-static int agg_instance_read_func (agg_instance_t *inst, /* {{{ */
-  char const *func, gauge_t rate, rate_to_value_state_t *state,
-  value_list_t *vl, char const *pi_prefix, cdtime_t t)
-{
+static int agg_instance_read_func(agg_instance_t *inst, /* {{{ */
+                                  char const *func, gauge_t rate,
+                                  rate_to_value_state_t *state,
+                                  value_list_t *vl, char const *pi_prefix,
+                                  cdtime_t t) {
   value_t v;
   int status;
 
   if (pi_prefix[0] != 0)
-    subst_string (vl->plugin_instance, sizeof (vl->plugin_instance),
-        pi_prefix, AGG_FUNC_PLACEHOLDER, func);
+    subst_string(vl->plugin_instance, sizeof(vl->plugin_instance), pi_prefix,
+                 AGG_FUNC_PLACEHOLDER, func);
   else
-    sstrncpy (vl->plugin_instance, func, sizeof (vl->plugin_instance));
+    sstrncpy(vl->plugin_instance, func, sizeof(vl->plugin_instance));
 
-  status = rate_to_value (&v, rate, state, inst->ds_type, t);
-  if (status != 0)
-  {
+  status = rate_to_value(&v, rate, state, inst->ds_type, t);
+  if (status != 0) {
     /* If this is the first iteration and rate_to_value() was asked to return a
      * COUNTER or a DERIVE, it will return EAGAIN. Catch this and handle
      * gracefully. */
     if (status == EAGAIN)
       return (0);
 
-    WARNING ("aggregation plugin: rate_to_value failed with status %i.",
-        status);
+    WARNING("aggregation plugin: rate_to_value failed with status %i.", status);
     return (-1);
   }
 
   vl->values = &v;
   vl->values_len = 1;
 
-  plugin_dispatch_values (vl);
+  plugin_dispatch_values(vl);
 
   vl->values = NULL;
   vl->values_len = 0;
 
   return (0);
 } /* }}} int agg_instance_read_func */
 
-static int agg_instance_read (agg_instance_t *inst, cdtime_t t) /* {{{ */
+static int agg_instance_read(agg_instance_t *inst, cdtime_t t) /* {{{ */
 {
   value_list_t vl = VALUE_LIST_INIT;
 
@@ -381,41 +373,41 @@ static int agg_instance_read (agg_instance_t *inst, cdtime_t t) /* {{{ */
   vl.time = t;
   vl.interval = 0;
 
-  vl.meta = meta_data_create ();
-  if (vl.meta == NULL)
-  {
-    ERROR ("aggregation plugin: meta_data_create failed.");
+  vl.meta = meta_data_create();
+  if (vl.meta == NULL) {
+    ERROR("aggregation plugin: meta_data_create failed.");
     return (-1);
   }
-  meta_data_add_boolean (vl.meta, "aggregation:created", 1);
+  meta_data_add_boolean(vl.meta, "aggregation:created", 1);
 
-  sstrncpy (vl.host, inst->ident.host, sizeof (vl.host));
-  sstrncpy (vl.plugin, inst->ident.plugin, sizeof (vl.plugin));
-  sstrncpy (vl.type, inst->ident.type, sizeof (vl.type));
-  sstrncpy (vl.type_instance, inst->ident.type_instance,
-      sizeof (vl.type_instance));
+  sstrncpy(vl.host, inst->ident.host, sizeof(vl.host));
+  sstrncpy(vl.plugin, inst->ident.plugin, sizeof(vl.plugin));
+  sstrncpy(vl.type, inst->ident.type, sizeof(vl.type));
+  sstrncpy(vl.type_instance, inst->ident.type_instance,
+           sizeof(vl.type_instance));
 
-#define READ_FUNC(func, rate) do { \
-  if (inst->state_ ## func != NULL) { \
-    agg_instance_read_func (inst, #func, rate, \
-        inst->state_ ## func, &vl, inst->ident.plugin_instance, t); \
-  } \
-} while (0)
+#define READ_FUNC(func, rate)                                                  \
+  do {                                                                         \
+    if (inst->state_##func != NULL) {                                          \
+      agg_instance_read_func(inst, #func, rate, inst->state_##func, &vl,       \
+                             inst->ident.plugin_instance, t);                  \
+    }                                                                          \
+  } while (0)
 
-  pthread_mutex_lock (&inst->lock);
+  pthread_mutex_lock(&inst->lock);
 
-  READ_FUNC (num, (gauge_t) inst->num);
+  READ_FUNC(num, (gauge_t)inst->num);
 
   /* All other aggregations are only defined when there have been any values
    * at all. */
-  if (inst->num > 0)
-  {
-    READ_FUNC (sum, inst->sum);
-    READ_FUNC (average, (inst->sum / ((gauge_t) inst->num)));
-    READ_FUNC (min, inst->min);
-    READ_FUNC (max, inst->max);
-    READ_FUNC (stddev, sqrt((((gauge_t) inst->num) * inst->squares_sum)
-          - (inst->sum * inst->sum)) / ((gauge_t) inst->num));
+  if (inst->num > 0) {
+    READ_FUNC(sum, inst->sum);
+    READ_FUNC(average, (inst->sum / ((gauge_t)inst->num)));
+    READ_FUNC(min, inst->min);
+    READ_FUNC(max, inst->max);
+    READ_FUNC(stddev, sqrt((((gauge_t)inst->num) * inst->squares_sum) -
+                           (inst->sum * inst->sum)) /
+                          ((gauge_t)inst->num));
   }
 
   /* Reset internal state. */
@@ -425,40 +417,40 @@ static int agg_instance_read (agg_instance_t *inst, cdtime_t t) /* {{{ */
   inst->min = NAN;
   inst->max = NAN;
 
-  pthread_mutex_unlock (&inst->lock);
+  pthread_mutex_unlock(&inst->lock);
 
-  meta_data_destroy (vl.meta);
+  meta_data_destroy(vl.meta);
   vl.meta = NULL;
 
   return (0);
 } /* }}} int agg_instance_read */
 
 /* lookup_class_callback_t for utils_vl_lookup */
-static void *agg_lookup_class_callback ( /* {{{ */
-    data_set_t const *ds, value_list_t const *vl, void *user_class)
-{
-  return (agg_instance_create (ds, vl, (aggregation_t *) user_class));
+static void *agg_lookup_class_callback(/* {{{ */
+                                       data_set_t const *ds,
+                                       value_list_t const *vl,
+                                       void *user_class) {
+  return (agg_instance_create(ds, vl, (aggregation_t *)user_class));
 } /* }}} void *agg_class_callback */
 
 /* lookup_obj_callback_t for utils_vl_lookup */
-static int agg_lookup_obj_callback (data_set_t const *ds, /* {{{ */
-    value_list_t const *vl,
-    __attribute__((unused)) void *user_class,
-    void *user_obj)
-{
-  return (agg_instance_update ((agg_instance_t *) user_obj, ds, vl));
+static int agg_lookup_obj_callback(data_set_t const *ds, /* {{{ */
+                                   value_list_t const *vl,
+                                   __attribute__((unused)) void *user_class,
+                                   void *user_obj) {
+  return (agg_instance_update((agg_instance_t *)user_obj, ds, vl));
 } /* }}} int agg_lookup_obj_callback */
 
 /* lookup_free_class_callback_t for utils_vl_lookup */
-static void agg_lookup_free_class_callback (void *user_class) /* {{{ */
+static void agg_lookup_free_class_callback(void *user_class) /* {{{ */
 {
-  agg_destroy ((aggregation_t *) user_class);
+  agg_destroy((aggregation_t *)user_class);
 } /* }}} void agg_lookup_free_class_callback */
 
 /* lookup_free_obj_callback_t for utils_vl_lookup */
-static void agg_lookup_free_obj_callback (void *user_obj) /* {{{ */
+static void agg_lookup_free_obj_callback(void *user_obj) /* {{{ */
 {
-  agg_instance_destroy ((agg_instance_t *) user_obj);
+  agg_instance_destroy((agg_instance_t *)user_obj);
 } /* }}} void agg_lookup_free_obj_callback */
 
 /*
@@ -479,300 +471,286 @@ static void agg_lookup_free_obj_callback (void *user_obj) /* {{{ */
  *   </Aggregation>
  * </Plugin>
  */
-static int agg_config_handle_group_by (oconfig_item_t const *ci, /* {{{ */
-    aggregation_t *agg)
-{
-  for (int i = 0; i < ci->values_num; i++)
-  {
+static int agg_config_handle_group_by(oconfig_item_t const *ci, /* {{{ */
+                                      aggregation_t *agg) {
+  for (int i = 0; i < ci->values_num; i++) {
     char const *value;
 
-    if (ci->values[i].type != OCONFIG_TYPE_STRING)
-    {
-      ERROR ("aggregation plugin: Argument %i of the \"GroupBy\" option "
-          "is not a string.", i + 1);
+    if (ci->values[i].type != OCONFIG_TYPE_STRING) {
+      ERROR("aggregation plugin: Argument %i of the \"GroupBy\" option "
+            "is not a string.",
+            i + 1);
       continue;
     }
 
     value = ci->values[i].value.string;
 
-    if (strcasecmp ("Host", value) == 0)
+    if (strcasecmp("Host", value) == 0)
       agg->group_by |= LU_GROUP_BY_HOST;
-    else if (strcasecmp ("Plugin", value) == 0)
+    else if (strcasecmp("Plugin", value) == 0)
       agg->group_by |= LU_GROUP_BY_PLUGIN;
-    else if (strcasecmp ("PluginInstance", value) == 0)
+    else if (strcasecmp("PluginInstance", value) == 0)
       agg->group_by |= LU_GROUP_BY_PLUGIN_INSTANCE;
-    else if (strcasecmp ("TypeInstance", value) == 0)
+    else if (strcasecmp("TypeInstance", value) == 0)
       agg->group_by |= LU_GROUP_BY_TYPE_INSTANCE;
-    else if (strcasecmp ("Type", value) == 0)
-      ERROR ("aggregation plugin: Grouping by type is not supported.");
+    else if (strcasecmp("Type", value) == 0)
+      ERROR("aggregation plugin: Grouping by type is not supported.");
     else
-      WARNING ("aggregation plugin: The \"%s\" argument to the \"GroupBy\" "
-          "option is invalid and will be ignored.", value);
+      WARNING("aggregation plugin: The \"%s\" argument to the \"GroupBy\" "
+              "option is invalid and will be ignored.",
+              value);
   } /* for (ci->values) */
 
   return (0);
 } /* }}} int agg_config_handle_group_by */
 
-static int agg_config_aggregation (oconfig_item_t *ci) /* {{{ */
+static int agg_config_aggregation(oconfig_item_t *ci) /* {{{ */
 {
   aggregation_t *agg;
   _Bool is_valid;
   int status;
 
-  agg = calloc (1, sizeof (*agg));
-  if (agg == NULL)
-  {
-    ERROR ("aggregation plugin: calloc failed.");
+  agg = calloc(1, sizeof(*agg));
+  if (agg == NULL) {
+    ERROR("aggregation plugin: calloc failed.");
     return (-1);
   }
 
-  sstrncpy (agg->ident.host, "/.*/", sizeof (agg->ident.host));
-  sstrncpy (agg->ident.plugin, "/.*/", sizeof (agg->ident.plugin));
-  sstrncpy (agg->ident.plugin_instance, "/.*/",
-      sizeof (agg->ident.plugin_instance));
-  sstrncpy (agg->ident.type, "/.*/", sizeof (agg->ident.type));
-  sstrncpy (agg->ident.type_instance, "/.*/",
-      sizeof (agg->ident.type_instance));
+  sstrncpy(agg->ident.host, "/.*/", sizeof(agg->ident.host));
+  sstrncpy(agg->ident.plugin, "/.*/", sizeof(agg->ident.plugin));
+  sstrncpy(agg->ident.plugin_instance, "/.*/",
+           sizeof(agg->ident.plugin_instance));
+  sstrncpy(agg->ident.type, "/.*/", sizeof(agg->ident.type));
+  sstrncpy(agg->ident.type_instance, "/.*/", sizeof(agg->ident.type_instance));
 
-  for (int i = 0; i < ci->children_num; i++)
-  {
+  for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
-    if (strcasecmp ("Host", child->key) == 0)
-      cf_util_get_string_buffer (child, agg->ident.host,
-          sizeof (agg->ident.host));
-    else if (strcasecmp ("Plugin", child->key) == 0)
-      cf_util_get_string_buffer (child, agg->ident.plugin,
-          sizeof (agg->ident.plugin));
-    else if (strcasecmp ("PluginInstance", child->key) == 0)
-      cf_util_get_string_buffer (child, agg->ident.plugin_instance,
-          sizeof (agg->ident.plugin_instance));
-    else if (strcasecmp ("Type", child->key) == 0)
-      cf_util_get_string_buffer (child, agg->ident.type,
-          sizeof (agg->ident.type));
-    else if (strcasecmp ("TypeInstance", child->key) == 0)
-      cf_util_get_string_buffer (child, agg->ident.type_instance,
-          sizeof (agg->ident.type_instance));
-    else if (strcasecmp ("SetHost", child->key) == 0)
-      cf_util_get_string (child, &agg->set_host);
-    else if (strcasecmp ("SetPlugin", child->key) == 0)
-      cf_util_get_string (child, &agg->set_plugin);
-    else if (strcasecmp ("SetPluginInstance", child->key) == 0)
-      cf_util_get_string (child, &agg->set_plugin_instance);
-    else if (strcasecmp ("SetTypeInstance", child->key) == 0)
-      cf_util_get_string (child, &agg->set_type_instance);
-    else if (strcasecmp ("GroupBy", child->key) == 0)
-      agg_config_handle_group_by (child, agg);
-    else if (strcasecmp ("CalculateNum", child->key) == 0)
-      cf_util_get_boolean (child, &agg->calc_num);
-    else if (strcasecmp ("CalculateSum", child->key) == 0)
-      cf_util_get_boolean (child, &agg->calc_sum);
-    else if (strcasecmp ("CalculateAverage", child->key) == 0)
-      cf_util_get_boolean (child, &agg->calc_average);
-    else if (strcasecmp ("CalculateMinimum", child->key) == 0)
-      cf_util_get_boolean (child, &agg->calc_min);
-    else if (strcasecmp ("CalculateMaximum", child->key) == 0)
-      cf_util_get_boolean (child, &agg->calc_max);
-    else if (strcasecmp ("CalculateStddev", child->key) == 0)
-      cf_util_get_boolean (child, &agg->calc_stddev);
+    if (strcasecmp("Host", child->key) == 0)
+      cf_util_get_string_buffer(child, agg->ident.host,
+                                sizeof(agg->ident.host));
+    else if (strcasecmp("Plugin", child->key) == 0)
+      cf_util_get_string_buffer(child, agg->ident.plugin,
+                                sizeof(agg->ident.plugin));
+    else if (strcasecmp("PluginInstance", child->key) == 0)
+      cf_util_get_string_buffer(child, agg->ident.plugin_instance,
+                                sizeof(agg->ident.plugin_instance));
+    else if (strcasecmp("Type", child->key) == 0)
+      cf_util_get_string_buffer(child, agg->ident.type,
+                                sizeof(agg->ident.type));
+    else if (strcasecmp("TypeInstance", child->key) == 0)
+      cf_util_get_string_buffer(child, agg->ident.type_instance,
+                                sizeof(agg->ident.type_instance));
+    else if (strcasecmp("SetHost", child->key) == 0)
+      cf_util_get_string(child, &agg->set_host);
+    else if (strcasecmp("SetPlugin", child->key) == 0)
+      cf_util_get_string(child, &agg->set_plugin);
+    else if (strcasecmp("SetPluginInstance", child->key) == 0)
+      cf_util_get_string(child, &agg->set_plugin_instance);
+    else if (strcasecmp("SetTypeInstance", child->key) == 0)
+      cf_util_get_string(child, &agg->set_type_instance);
+    else if (strcasecmp("GroupBy", child->key) == 0)
+      agg_config_handle_group_by(child, agg);
+    else if (strcasecmp("CalculateNum", child->key) == 0)
+      cf_util_get_boolean(child, &agg->calc_num);
+    else if (strcasecmp("CalculateSum", child->key) == 0)
+      cf_util_get_boolean(child, &agg->calc_sum);
+    else if (strcasecmp("CalculateAverage", child->key) == 0)
+      cf_util_get_boolean(child, &agg->calc_average);
+    else if (strcasecmp("CalculateMinimum", child->key) == 0)
+      cf_util_get_boolean(child, &agg->calc_min);
+    else if (strcasecmp("CalculateMaximum", child->key) == 0)
+      cf_util_get_boolean(child, &agg->calc_max);
+    else if (strcasecmp("CalculateStddev", child->key) == 0)
+      cf_util_get_boolean(child, &agg->calc_stddev);
     else
-      WARNING ("aggregation plugin: The \"%s\" key is not allowed inside "
-          "<Aggregation /> blocks and will be ignored.", child->key);
+      WARNING("aggregation plugin: The \"%s\" key is not allowed inside "
+              "<Aggregation /> blocks and will be ignored.",
+              child->key);
   }
 
-  if (agg_is_regex (agg->ident.host))
+  if (agg_is_regex(agg->ident.host))
     agg->regex_fields |= LU_GROUP_BY_HOST;
-  if (agg_is_regex (agg->ident.plugin))
+  if (agg_is_regex(agg->ident.plugin))
     agg->regex_fields |= LU_GROUP_BY_PLUGIN;
-  if (agg_is_regex (agg->ident.plugin_instance))
+  if (agg_is_regex(agg->ident.plugin_instance))
     agg->regex_fields |= LU_GROUP_BY_PLUGIN_INSTANCE;
-  if (agg_is_regex (agg->ident.type_instance))
+  if (agg_is_regex(agg->ident.type_instance))
     agg->regex_fields |= LU_GROUP_BY_TYPE_INSTANCE;
 
   /* Sanity checking */
   is_valid = 1;
-  if (strcmp ("/.*/", agg->ident.type) == 0) /* {{{ */
+  if (strcmp("/.*/", agg->ident.type) == 0) /* {{{ */
   {
-    ERROR ("aggregation plugin: It appears you did not specify the required "
-        "\"Type\" option in this aggregation. "
-        "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
-        "Type \"%s\", TypeInstance \"%s\")",
-        agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
-        agg->ident.type, agg->ident.type_instance);
+    ERROR("aggregation plugin: It appears you did not specify the required "
+          "\"Type\" option in this aggregation. "
+          "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
+          "Type \"%s\", TypeInstance \"%s\")",
+          agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
+          agg->ident.type, agg->ident.type_instance);
     is_valid = 0;
-  }
-  else if (strchr (agg->ident.type, '/') != NULL)
-  {
-    ERROR ("aggregation plugin: The \"Type\" may not contain the '/' "
-        "character. Especially, it may not be a regex. The current "
-        "value is \"%s\".", agg->ident.type);
+  } else if (strchr(agg->ident.type, '/') != NULL) {
+    ERROR("aggregation plugin: The \"Type\" may not contain the '/' "
+          "character. Especially, it may not be a regex. The current "
+          "value is \"%s\".",
+          agg->ident.type);
     is_valid = 0;
   } /* }}} */
 
   /* Check that there is at least one regex field without a grouping. {{{ */
-  if ((agg->regex_fields & ~agg->group_by) == 0)
-  {
-    ERROR ("aggregation plugin: An aggregation must contain at least one "
-        "wildcard. This is achieved by leaving at least one of the \"Host\", "
-        "\"Plugin\", \"PluginInstance\" and \"TypeInstance\" options blank "
-        "or using a regular expression and not grouping by that field. "
-        "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
-        "Type \"%s\", TypeInstance \"%s\")",
-        agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
-        agg->ident.type, agg->ident.type_instance);
+  if ((agg->regex_fields & ~agg->group_by) == 0) {
+    ERROR("aggregation plugin: An aggregation must contain at least one "
+          "wildcard. This is achieved by leaving at least one of the \"Host\", "
+          "\"Plugin\", \"PluginInstance\" and \"TypeInstance\" options blank "
+          "or using a regular expression and not grouping by that field. "
+          "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
+          "Type \"%s\", TypeInstance \"%s\")",
+          agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
+          agg->ident.type, agg->ident.type_instance);
     is_valid = 0;
   } /* }}} */
 
   /* Check that all grouping fields are regular expressions. {{{ */
-  if (agg->group_by & ~agg->regex_fields)
-  {
-    ERROR ("aggregation plugin: Only wildcard fields (fields for which a "
-        "regular expression is configured or which are left blank) can be "
-        "specified in the \"GroupBy\" option. "
-        "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
-        "Type \"%s\", TypeInstance \"%s\")",
-        agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
-        agg->ident.type, agg->ident.type_instance);
+  if (agg->group_by & ~agg->regex_fields) {
+    ERROR("aggregation plugin: Only wildcard fields (fields for which a "
+          "regular expression is configured or which are left blank) can be "
+          "specified in the \"GroupBy\" option. "
+          "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
+          "Type \"%s\", TypeInstance \"%s\")",
+          agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
+          agg->ident.type, agg->ident.type_instance);
     is_valid = 0;
   } /* }}} */
 
   if (!agg->calc_num && !agg->calc_sum && !agg->calc_average /* {{{ */
-      && !agg->calc_min && !agg->calc_max && !agg->calc_stddev)
-  {
-    ERROR ("aggregation plugin: No aggregation function has been specified. "
-        "Without this, I don't know what I should be calculating. "
-        "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
-        "Type \"%s\", TypeInstance \"%s\")",
-        agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
-        agg->ident.type, agg->ident.type_instance);
+      && !agg->calc_min && !agg->calc_max && !agg->calc_stddev) {
+    ERROR("aggregation plugin: No aggregation function has been specified. "
+          "Without this, I don't know what I should be calculating. "
+          "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
+          "Type \"%s\", TypeInstance \"%s\")",
+          agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
+          agg->ident.type, agg->ident.type_instance);
     is_valid = 0;
   } /* }}} */
 
   if (!is_valid) /* {{{ */
   {
-    sfree (agg);
+    sfree(agg);
     return (-1);
   } /* }}} */
 
-  status = lookup_add (lookup, &agg->ident, agg->group_by, agg);
-  if (status != 0)
-  {
-    ERROR ("aggregation plugin: lookup_add failed with status %i.", status);
-    sfree (agg);
+  status = lookup_add(lookup, &agg->ident, agg->group_by, agg);
+  if (status != 0) {
+    ERROR("aggregation plugin: lookup_add failed with status %i.", status);
+    sfree(agg);
     return (-1);
   }
 
-  DEBUG ("aggregation plugin: Successfully added aggregation: "
-      "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
-      "Type \"%s\", TypeInstance \"%s\")",
-      agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
-      agg->ident.type, agg->ident.type_instance);
+  DEBUG("aggregation plugin: Successfully added aggregation: "
+        "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
+        "Type \"%s\", TypeInstance \"%s\")",
+        agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
+        agg->ident.type, agg->ident.type_instance);
   return (0);
 } /* }}} int agg_config_aggregation */
 
-static int agg_config (oconfig_item_t *ci) /* {{{ */
+static int agg_config(oconfig_item_t *ci) /* {{{ */
 {
-  pthread_mutex_lock (&agg_instance_list_lock);
-
-  if (lookup == NULL)
-  {
-    lookup = lookup_create (agg_lookup_class_callback,
-        agg_lookup_obj_callback,
-        agg_lookup_free_class_callback,
-        agg_lookup_free_obj_callback);
-    if (lookup == NULL)
-    {
-      pthread_mutex_unlock (&agg_instance_list_lock);
-      ERROR ("aggregation plugin: lookup_create failed.");
+  pthread_mutex_lock(&agg_instance_list_lock);
+
+  if (lookup == NULL) {
+    lookup = lookup_create(agg_lookup_class_callback, agg_lookup_obj_callback,
+                           agg_lookup_free_class_callback,
+                           agg_lookup_free_obj_callback);
+    if (lookup == NULL) {
+      pthread_mutex_unlock(&agg_instance_list_lock);
+      ERROR("aggregation plugin: lookup_create failed.");
       return (-1);
     }
   }
 
-  for (int i = 0; i < ci->children_num; i++)
-  {
+  for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
-    if (strcasecmp ("Aggregation", child->key) == 0)
-      agg_config_aggregation (child);
+    if (strcasecmp("Aggregation", child->key) == 0)
+      agg_config_aggregation(child);
     else
-      WARNING ("aggregation plugin: The \"%s\" key is not allowed inside "
-          "<Plugin aggregation /> blocks and will be ignored.", child->key);
+      WARNING("aggregation plugin: The \"%s\" key is not allowed inside "
+              "<Plugin aggregation /> blocks and will be ignored.",
+              child->key);
   }
 
-  pthread_mutex_unlock (&agg_instance_list_lock);
+  pthread_mutex_unlock(&agg_instance_list_lock);
 
   return (0);
 } /* }}} int agg_config */
 
-static int agg_read (void) /* {{{ */
+static int agg_read(void) /* {{{ */
 {
   cdtime_t t;
   int success;
 
-  t = cdtime ();
+  t = cdtime();
   success = 0;
 
-  pthread_mutex_lock (&agg_instance_list_lock);
+  pthread_mutex_lock(&agg_instance_list_lock);
 
   /* agg_instance_list_head only holds data, after the "write" callback has
    * been called with a matching value list at least once. So on startup,
    * there's a race between the aggregations read() and write() callback. If
    * the read() callback is called first, agg_instance_list_head is NULL and
    * "success" may be zero. This is expected and should not result in an error.
    * Therefore we need to handle this case separately. */
-  if (agg_instance_list_head == NULL)
-  {
-    pthread_mutex_unlock (&agg_instance_list_lock);
+  if (agg_instance_list_head == NULL) {
+    pthread_mutex_unlock(&agg_instance_list_lock);
     return (0);
   }
 
-  for (agg_instance_t *this = agg_instance_list_head; this != NULL; this = this->next)
-  {
+  for (agg_instance_t *this = agg_instance_list_head; this != NULL;
+       this = this->next) {
     int status;
 
-    status = agg_instance_read (this, t);
+    status = agg_instance_read(this, t);
     if (status != 0)
-      WARNING ("aggregation plugin: Reading an aggregation instance "
-          "failed with status %i.", status);
+      WARNING("aggregation plugin: Reading an aggregation instance "
+              "failed with status %i.",
+              status);
     else
       success++;
   }
 
-  pthread_mutex_unlock (&agg_instance_list_lock);
+  pthread_mutex_unlock(&agg_instance_list_lock);
 
   return ((success > 0) ? 0 : -1);
 } /* }}} int agg_read */
 
-static int agg_write (data_set_t const *ds, value_list_t const *vl, /* {{{ */
-    __attribute__((unused)) user_data_t *user_data)
-{
+static int agg_write(data_set_t const *ds, value_list_t const *vl, /* {{{ */
+                     __attribute__((unused)) user_data_t *user_data) {
   _Bool created_by_aggregation = 0;
   int status;
 
   /* Ignore values that were created by the aggregation plugin to avoid weird
    * effects. */
-  (void) meta_data_get_boolean (vl->meta, "aggregation:created",
-      &created_by_aggregation);
+  (void)meta_data_get_boolean(vl->meta, "aggregation:created",
+                              &created_by_aggregation);
   if (created_by_aggregation)
     return (0);
 
   if (lookup == NULL)
     status = ENOENT;
-  else
-  {
-    status = lookup_search (lookup, ds, vl);
+  else {
+    status = lookup_search(lookup, ds, vl);
     if (status > 0)
       status = 0;
   }
 
   return (status);
 } /* }}} int agg_write */
 
-void module_register (void)
-{
-  plugin_register_complex_config ("aggregation", agg_config);
-  plugin_register_read ("aggregation", agg_read);
-  plugin_register_write ("aggregation", agg_write, /* user_data = */ NULL);
+void module_register(void) {
+  plugin_register_complex_config("aggregation", agg_config);
+  plugin_register_read("aggregation", agg_read);
+  plugin_register_write("aggregation", agg_write, /* user_data = */ NULL);
 }
 
 /* vim: set sw=2 sts=2 tw=78 et fdm=marker : */
@@ -31,17 +31,17 @@
 #include "common.h"
 #include "plugin.h"
 #include "utils_cmd_putval.h"
-#include "utils_format_json.h"
 #include "utils_format_graphite.h"
+#include "utils_format_json.h"
 
 #include <amqp.h>
 #include <amqp_framing.h>
 
 #ifdef HAVE_AMQP_TCP_SOCKET_H
-# include <amqp_tcp_socket.h>
+#include <amqp_tcp_socket.h>
 #endif
 #ifdef HAVE_AMQP_SOCKET_H
-# include <amqp_socket.h>
+#include <amqp_socket.h>
 #endif
 #ifdef HAVE_AMQP_TCP_SOCKET
 #if defined HAVE_DECL_AMQP_SOCKET_CLOSE && !HAVE_DECL_AMQP_SOCKET_CLOSE
@@ -53,1070 +53,974 @@ int amqp_socket_close(amqp_socket_t *);
 
 /* Defines for the delivery mode. I have no idea why they're not defined by the
  * library.. */
-#define CAMQP_DM_VOLATILE   1
+#define CAMQP_DM_VOLATILE 1
 #define CAMQP_DM_PERSISTENT 2
 
-#define CAMQP_FORMAT_COMMAND    1
-#define CAMQP_FORMAT_JSON       2
-#define CAMQP_FORMAT_GRAPHITE   3
+#define CAMQP_FORMAT_COMMAND 1
+#define CAMQP_FORMAT_JSON 2
+#define CAMQP_FORMAT_GRAPHITE 3
 
 #define CAMQP_CHANNEL 1
 
 /*
  * Data types
  */
-struct camqp_config_s
-{
-    _Bool   publish;
-    char   *name;
-
-    char   *host;
-    int     port;
-    char   *vhost;
-    char   *user;
-    char   *password;
-
-    char   *exchange;
-    char   *routing_key;
-
-    /* Number of seconds to wait before connection is retried */
-    int     connection_retry_delay;
-
-    /* publish only */
-    uint8_t delivery_mode;
-    _Bool   store_rates;
-    int     format;
-    /* publish & graphite format only */
-    char    *prefix;
-    char    *postfix;
-    char    escape_char;
-    unsigned int graphite_flags;
-
-    /* subscribe only */
-    char   *exchange_type;
-    char   *queue;
-    _Bool   queue_durable;
-    _Bool   queue_auto_delete;
-
-    amqp_connection_state_t connection;
-    pthread_mutex_t lock;
+struct camqp_config_s {
+  _Bool publish;
+  char *name;
+
+  char *host;
+  int port;
+  char *vhost;
+  char *user;
+  char *password;
+
+  char *exchange;
+  char *routing_key;
+
+  /* Number of seconds to wait before connection is retried */
+  int connection_retry_delay;
+
+  /* publish only */
+  uint8_t delivery_mode;
+  _Bool store_rates;
+  int format;
+  /* publish & graphite format only */
+  char *prefix;
+  char *postfix;
+  char escape_char;
+  unsigned int graphite_flags;
+
+  /* subscribe only */
+  char *exchange_type;
+  char *queue;
+  _Bool queue_durable;
+  _Bool queue_auto_delete;
+
+  amqp_connection_state_t connection;
+  pthread_mutex_t lock;
 };
 typedef struct camqp_config_s camqp_config_t;
 
 /*
  * Global variables
  */
-static const char *def_host       = "localhost";
-static const char *def_vhost      = "/";
-static const char *def_user       = "guest";
-static const char *def_password   = "guest";
-static const char *def_exchange   = "amq.fanout";
+static const char *def_host = "localhost";
+static const char *def_vhost = "/";
+static const char *def_user = "guest";
+static const char *def_password = "guest";
+static const char *def_exchange = "amq.fanout";
 
-static pthread_t *subscriber_threads     = NULL;
-static size_t     subscriber_threads_num = 0;
-static _Bool      subscriber_threads_running = 1;
+static pthread_t *subscriber_threads = NULL;
+static size_t subscriber_threads_num = 0;
+static _Bool subscriber_threads_running = 1;
 
-#define CONF(c,f) (((c)->f != NULL) ? (c)->f : def_##f)
+#define CONF(c, f) (((c)->f != NULL) ? (c)->f : def_##f)
 
 /*
  * Functions
  */
-static void camqp_close_connection (camqp_config_t *conf) /* {{{ */
+static void camqp_close_connection(camqp_config_t *conf) /* {{{ */
 {
-    int sockfd;
+  int sockfd;
 
-    if ((conf == NULL) || (conf->connection == NULL))
-        return;
+  if ((conf == NULL) || (conf->connection == NULL))
+    return;
 
-    sockfd = amqp_get_sockfd (conf->connection);
-    amqp_channel_close (conf->connection, CAMQP_CHANNEL, AMQP_REPLY_SUCCESS);
-    amqp_connection_close (conf->connection, AMQP_REPLY_SUCCESS);
-    amqp_destroy_connection (conf->connection);
-    close (sockfd);
-    conf->connection = NULL;
+  sockfd = amqp_get_sockfd(conf->connection);
+  amqp_channel_close(conf->connection, CAMQP_CHANNEL, AMQP_REPLY_SUCCESS);
+  amqp_connection_close(conf->connection, AMQP_REPLY_SUCCESS);
+  amqp_destroy_connection(conf->connection);
+  close(sockfd);
+  conf->connection = NULL;
 } /* }}} void camqp_close_connection */
 
-static void camqp_config_free (void *ptr) /* {{{ */
+static void camqp_config_free(void *ptr) /* {{{ */
 {
-    camqp_config_t *conf = ptr;
-
-    if (conf == NULL)
-        return;
-
-    camqp_close_connection (conf);
-
-    sfree (conf->name);
-    sfree (conf->host);
-    sfree (conf->vhost);
-    sfree (conf->user);
-    sfree (conf->password);
-    sfree (conf->exchange);
-    sfree (conf->exchange_type);
-    sfree (conf->queue);
-    sfree (conf->routing_key);
-    sfree (conf->prefix);
-    sfree (conf->postfix);
-
-
-    sfree (conf);
+  camqp_config_t *conf = ptr;
+
+  if (conf == NULL)
+    return;
+
+  camqp_close_connection(conf);
+
+  sfree(conf->name);
+  sfree(conf->host);
+  sfree(conf->vhost);
+  sfree(conf->user);
+  sfree(conf->password);
+  sfree(conf->exchange);
+  sfree(conf->exchange_type);
+  sfree(conf->queue);
+  sfree(conf->routing_key);
+  sfree(conf->prefix);
+  sfree(conf->postfix);
+
+  sfree(conf);
 } /* }}} void camqp_config_free */
 
-static char *camqp_bytes_cstring (amqp_bytes_t *in) /* {{{ */
+static char *camqp_bytes_cstring(amqp_bytes_t *in) /* {{{ */
 {
-    char *ret;
+  char *ret;
 
-    if ((in == NULL) || (in->bytes == NULL))
-        return (NULL);
+  if ((in == NULL) || (in->bytes == NULL))
+    return (NULL);
 
-    ret = malloc (in->len + 1);
-    if (ret == NULL)
-        return (NULL);
+  ret = malloc(in->len + 1);
+  if (ret == NULL)
+    return (NULL);
 
-    memcpy (ret, in->bytes, in->len);
-    ret[in->len] = 0;
+  memcpy(ret, in->bytes, in->len);
+  ret[in->len] = 0;
 
-    return (ret);
+  return (ret);
 } /* }}} char *camqp_bytes_cstring */
 
-static _Bool camqp_is_error (camqp_config_t *conf) /* {{{ */
+static _Bool camqp_is_error(camqp_config_t *conf) /* {{{ */
 {
-    amqp_rpc_reply_t r;
+  amqp_rpc_reply_t r;
 
-    r = amqp_get_rpc_reply (conf->connection);
-    if (r.reply_type == AMQP_RESPONSE_NORMAL)
-        return (0);
+  r = amqp_get_rpc_reply(conf->connection);
+  if (r.reply_type == AMQP_RESPONSE_NORMAL)
+    return (0);
 
-    return (1);
+  return (1);
 } /* }}} _Bool camqp_is_error */
 
-static char *camqp_strerror (camqp_config_t *conf, /* {{{ */
-        char *buffer, size_t buffer_size)
-{
-    amqp_rpc_reply_t r;
+static char *camqp_strerror(camqp_config_t *conf, /* {{{ */
+                            char *buffer, size_t buffer_size) {
+  amqp_rpc_reply_t r;
 
-    r = amqp_get_rpc_reply (conf->connection);
-    switch (r.reply_type)
-    {
-        case AMQP_RESPONSE_NORMAL:
-            sstrncpy (buffer, "Success", buffer_size);
-            break;
+  r = amqp_get_rpc_reply(conf->connection);
+  switch (r.reply_type) {
+  case AMQP_RESPONSE_NORMAL:
+    sstrncpy(buffer, "Success", buffer_size);
+    break;
 
-        case AMQP_RESPONSE_NONE:
-            sstrncpy (buffer, "Missing RPC reply type", buffer_size);
-            break;
+  case AMQP_RESPONSE_NONE:
+    sstrncpy(buffer, "Missing RPC reply type", buffer_size);
+    break;
 
-        case AMQP_RESPONSE_LIBRARY_EXCEPTION:
+  case AMQP_RESPONSE_LIBRARY_EXCEPTION:
 #if HAVE_AMQP_RPC_REPLY_T_LIBRARY_ERRNO
-            if (r.library_errno)
-                return (sstrerror (r.library_errno, buffer, buffer_size));
+    if (r.library_errno)
+      return (sstrerror(r.library_errno, buffer, buffer_size));
 #else
-            if (r.library_error)
-                return (sstrerror (r.library_error, buffer, buffer_size));
+    if (r.library_error)
+      return (sstrerror(r.library_error, buffer, buffer_size));
 #endif
-            else
-                sstrncpy (buffer, "End of stream", buffer_size);
-            break;
-
-        case AMQP_RESPONSE_SERVER_EXCEPTION:
-            if (r.reply.id == AMQP_CONNECTION_CLOSE_METHOD)
-            {
-                amqp_connection_close_t *m = r.reply.decoded;
-                char *tmp = camqp_bytes_cstring (&m->reply_text);
-                ssnprintf (buffer, buffer_size, "Server connection error %d: %s",
-                        m->reply_code, tmp);
-                sfree (tmp);
-            }
-            else if (r.reply.id == AMQP_CHANNEL_CLOSE_METHOD)
-            {
-                amqp_channel_close_t *m = r.reply.decoded;
-                char *tmp = camqp_bytes_cstring (&m->reply_text);
-                ssnprintf (buffer, buffer_size, "Server channel error %d: %s",
-                        m->reply_code, tmp);
-                sfree (tmp);
-            }
-            else
-            {
-                ssnprintf (buffer, buffer_size, "Server error method %#"PRIx32,
-                        r.reply.id);
-            }
-            break;
-
-        default:
-            ssnprintf (buffer, buffer_size, "Unknown reply type %i",
-                    (int) r.reply_type);
+    else
+      sstrncpy(buffer, "End of stream", buffer_size);
+    break;
+
+  case AMQP_RESPONSE_SERVER_EXCEPTION:
+    if (r.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {
+      amqp_connection_close_t *m = r.reply.decoded;
+      char *tmp = camqp_bytes_cstring(&m->reply_text);
+      ssnprintf(buffer, buffer_size, "Server connection error %d: %s",
+                m->reply_code, tmp);
+      sfree(tmp);
+    } else if (r.reply.id == AMQP_CHANNEL_CLOSE_METHOD) {
+      amqp_channel_close_t *m = r.reply.decoded;
+      char *tmp = camqp_bytes_cstring(&m->reply_text);
+      ssnprintf(buffer, buffer_size, "Server channel error %d: %s",
+                m->reply_code, tmp);
+      sfree(tmp);
+    } else {
+      ssnprintf(buffer, buffer_size, "Server error method %#" PRIx32,
+                r.reply.id);
     }
+    break;
 
-    return (buffer);
+  default:
+    ssnprintf(buffer, buffer_size, "Unknown reply type %i", (int)r.reply_type);
+  }
+
+  return (buffer);
 } /* }}} char *camqp_strerror */
 
 #if HAVE_AMQP_RPC_REPLY_T_LIBRARY_ERRNO
-static int camqp_create_exchange (camqp_config_t *conf) /* {{{ */
+static int camqp_create_exchange(camqp_config_t *conf) /* {{{ */
 {
-    amqp_exchange_declare_ok_t *ed_ret;
-
-    if (conf->exchange_type == NULL)
-        return (0);
-
-    ed_ret = amqp_exchange_declare (conf->connection,
-            /* channel     = */ CAMQP_CHANNEL,
-            /* exchange    = */ amqp_cstring_bytes (conf->exchange),
-            /* type        = */ amqp_cstring_bytes (conf->exchange_type),
-            /* passive     = */ 0,
-            /* durable     = */ 0,
-            /* auto_delete = */ 1,
-            /* arguments   = */ AMQP_EMPTY_TABLE);
-    if ((ed_ret == NULL) && camqp_is_error (conf))
-    {
-        char errbuf[1024];
-        ERROR ("amqp plugin: amqp_exchange_declare failed: %s",
-                camqp_strerror (conf, errbuf, sizeof (errbuf)));
-        camqp_close_connection (conf);
-        return (-1);
-    }
-
-    INFO ("amqp plugin: Successfully created exchange \"%s\" "
-            "with type \"%s\".",
-            conf->exchange, conf->exchange_type);
+  amqp_exchange_declare_ok_t *ed_ret;
 
+  if (conf->exchange_type == NULL)
     return (0);
+
+  ed_ret = amqp_exchange_declare(
+      conf->connection,
+      /* channel     = */ CAMQP_CHANNEL,
+      /* exchange    = */ amqp_cstring_bytes(conf->exchange),
+      /* type        = */ amqp_cstring_bytes(conf->exchange_type),
+      /* passive     = */ 0,
+      /* durable     = */ 0,
+      /* auto_delete = */ 1,
+      /* arguments   = */ AMQP_EMPTY_TABLE);
+  if ((ed_ret == NULL) && camqp_is_error(conf)) {
+    char errbuf[1024];
+    ERROR("amqp plugin: amqp_exchange_declare failed: %s",
+          camqp_strerror(conf, errbuf, sizeof(errbuf)));
+    camqp_close_connection(conf);
+    return (-1);
+  }
+
+  INFO("amqp plugin: Successfully created exchange \"%s\" "
+       "with type \"%s\".",
+       conf->exchange, conf->exchange_type);
+
+  return (0);
 } /* }}} int camqp_create_exchange */
 #else
-static int camqp_create_exchange (camqp_config_t *conf) /* {{{ */
+static int camqp_create_exchange(camqp_config_t *conf) /* {{{ */
 {
-    amqp_exchange_declare_ok_t *ed_ret;
-    amqp_table_t argument_table;
-    struct amqp_table_entry_t_ argument_table_entries[1];
-
-    if (conf->exchange_type == NULL)
-        return (0);
-
-    /* Valid arguments: "auto_delete", "internal" */
-    argument_table.num_entries = STATIC_ARRAY_SIZE (argument_table_entries);
-    argument_table.entries = argument_table_entries;
-    argument_table_entries[0].key = amqp_cstring_bytes ("auto_delete");
-    argument_table_entries[0].value.kind = AMQP_FIELD_KIND_BOOLEAN;
-    argument_table_entries[0].value.value.boolean = 1;
-
-    ed_ret = amqp_exchange_declare (conf->connection,
-            /* channel     = */ CAMQP_CHANNEL,
-            /* exchange    = */ amqp_cstring_bytes (conf->exchange),
-            /* type        = */ amqp_cstring_bytes (conf->exchange_type),
-            /* passive     = */ 0,
-            /* durable     = */ 0,
-#if defined(AMQP_VERSION) && AMQP_VERSION >= 0x00060000
-            /* auto delete = */ 0,
-            /* internal    = */ 0,
-#endif
-            /* arguments   = */ argument_table);
-    if ((ed_ret == NULL) && camqp_is_error (conf))
-    {
-        char errbuf[1024];
-        ERROR ("amqp plugin: amqp_exchange_declare failed: %s",
-                camqp_strerror (conf, errbuf, sizeof (errbuf)));
-        camqp_close_connection (conf);
-        return (-1);
-    }
-
-    INFO ("amqp plugin: Successfully created exchange \"%s\" "
-            "with type \"%s\".",
-            conf->exchange, conf->exchange_type);
+  amqp_exchange_declare_ok_t *ed_ret;
+  amqp_table_t argument_table;
+  struct amqp_table_entry_t_ argument_table_entries[1];
 
+  if (conf->exchange_type == NULL)
     return (0);
+
+  /* Valid arguments: "auto_delete", "internal" */
+  argument_table.num_entries = STATIC_ARRAY_SIZE(argument_table_entries);
+  argument_table.entries = argument_table_entries;
+  argument_table_entries[0].key = amqp_cstring_bytes("auto_delete");
+  argument_table_entries[0].value.kind = AMQP_FIELD_KIND_BOOLEAN;
+  argument_table_entries[0].value.value.boolean = 1;
+
+  ed_ret = amqp_exchange_declare(
+      conf->connection,
+      /* channel     = */ CAMQP_CHANNEL,
+      /* exchange    = */ amqp_cstring_bytes(conf->exchange),
+      /* type        = */ amqp_cstring_bytes(conf->exchange_type),
+      /* passive     = */ 0,
+      /* durable     = */ 0,
+#if defined(AMQP_VERSION) && AMQP_VERSION >= 0x00060000
+      /* auto delete = */ 0,
+      /* internal    = */ 0,
+#endif
+      /* arguments   = */ argument_table);
+  if ((ed_ret == NULL) && camqp_is_error(conf)) {
+    char errbuf[1024];
+    ERROR("amqp plugin: amqp_exchange_declare failed: %s",
+          camqp_strerror(conf, errbuf, sizeof(errbuf)));
+    camqp_close_connection(conf);
+    return (-1);
+  }
+
+  INFO("amqp plugin: Successfully created exchange \"%s\" "
+       "with type \"%s\".",
+       conf->exchange, conf->exchange_type);
+
+  return (0);
 } /* }}} int camqp_create_exchange */
 #endif
 
-static int camqp_setup_queue (camqp_config_t *conf) /* {{{ */
+static int camqp_setup_queue(camqp_config_t *conf) /* {{{ */
 {
-    amqp_queue_declare_ok_t *qd_ret;
-    amqp_basic_consume_ok_t *cm_ret;
-
-    qd_ret = amqp_queue_declare (conf->connection,
-            /* channel     = */ CAMQP_CHANNEL,
-            /* queue       = */ (conf->queue != NULL)
-            ? amqp_cstring_bytes (conf->queue)
-            : AMQP_EMPTY_BYTES,
-            /* passive     = */ 0,
-            /* durable     = */ conf->queue_durable,
-            /* exclusive   = */ 0,
-            /* auto_delete = */ conf->queue_auto_delete,
-            /* arguments   = */ AMQP_EMPTY_TABLE);
-    if (qd_ret == NULL)
-    {
-        ERROR ("amqp plugin: amqp_queue_declare failed.");
-        camqp_close_connection (conf);
-        return (-1);
+  amqp_queue_declare_ok_t *qd_ret;
+  amqp_basic_consume_ok_t *cm_ret;
+
+  qd_ret = amqp_queue_declare(conf->connection,
+                              /* channel     = */ CAMQP_CHANNEL,
+                              /* queue       = */ (conf->queue != NULL)
+                                  ? amqp_cstring_bytes(conf->queue)
+                                  : AMQP_EMPTY_BYTES,
+                              /* passive     = */ 0,
+                              /* durable     = */ conf->queue_durable,
+                              /* exclusive   = */ 0,
+                              /* auto_delete = */ conf->queue_auto_delete,
+                              /* arguments   = */ AMQP_EMPTY_TABLE);
+  if (qd_ret == NULL) {
+    ERROR("amqp plugin: amqp_queue_declare failed.");
+    camqp_close_connection(conf);
+    return (-1);
+  }
+
+  if (conf->queue == NULL) {
+    conf->queue = camqp_bytes_cstring(&qd_ret->queue);
+    if (conf->queue == NULL) {
+      ERROR("amqp plugin: camqp_bytes_cstring failed.");
+      camqp_close_connection(conf);
+      return (-1);
     }
 
-    if (conf->queue == NULL)
-    {
-        conf->queue = camqp_bytes_cstring (&qd_ret->queue);
-        if (conf->queue == NULL)
-        {
-            ERROR ("amqp plugin: camqp_bytes_cstring failed.");
-            camqp_close_connection (conf);
-            return (-1);
-        }
-
-        INFO ("amqp plugin: Created queue \"%s\".", conf->queue);
-    }
-    DEBUG ("amqp plugin: Successfully created queue \"%s\".", conf->queue);
-
-    /* bind to an exchange */
-    if (conf->exchange != NULL)
-    {
-        amqp_queue_bind_ok_t *qb_ret;
-
-        assert (conf->queue != NULL);
-        qb_ret = amqp_queue_bind (conf->connection,
-                /* channel     = */ CAMQP_CHANNEL,
-                /* queue       = */ amqp_cstring_bytes (conf->queue),
-                /* exchange    = */ amqp_cstring_bytes (conf->exchange),
-                /* routing_key = */ (conf->routing_key != NULL)
-                ? amqp_cstring_bytes (conf->routing_key)
-                : AMQP_EMPTY_BYTES,
-                /* arguments   = */ AMQP_EMPTY_TABLE);
-        if ((qb_ret == NULL) && camqp_is_error (conf))
-        {
-            char errbuf[1024];
-            ERROR ("amqp plugin: amqp_queue_bind failed: %s",
-                    camqp_strerror (conf, errbuf, sizeof (errbuf)));
-            camqp_close_connection (conf);
-            return (-1);
-        }
-
-        DEBUG ("amqp plugin: Successfully bound queue \"%s\" to exchange \"%s\".",
-                conf->queue, conf->exchange);
-    } /* if (conf->exchange != NULL) */
-
-    cm_ret = amqp_basic_consume (conf->connection,
-            /* channel      = */ CAMQP_CHANNEL,
-            /* queue        = */ amqp_cstring_bytes (conf->queue),
-            /* consumer_tag = */ AMQP_EMPTY_BYTES,
-            /* no_local     = */ 0,
-            /* no_ack       = */ 1,
-            /* exclusive    = */ 0,
-            /* arguments    = */ AMQP_EMPTY_TABLE
-        );
-    if ((cm_ret == NULL) && camqp_is_error (conf))
-    {
-        char errbuf[1024];
-        ERROR ("amqp plugin: amqp_basic_consume failed: %s",
-                    camqp_strerror (conf, errbuf, sizeof (errbuf)));
-        camqp_close_connection (conf);
-        return (-1);
+    INFO("amqp plugin: Created queue \"%s\".", conf->queue);
+  }
+  DEBUG("amqp plugin: Successfully created queue \"%s\".", conf->queue);
+
+  /* bind to an exchange */
+  if (conf->exchange != NULL) {
+    amqp_queue_bind_ok_t *qb_ret;
+
+    assert(conf->queue != NULL);
+    qb_ret =
+        amqp_queue_bind(conf->connection,
+                        /* channel     = */ CAMQP_CHANNEL,
+                        /* queue       = */ amqp_cstring_bytes(conf->queue),
+                        /* exchange    = */ amqp_cstring_bytes(conf->exchange),
+                        /* routing_key = */ (conf->routing_key != NULL)
+                            ? amqp_cstring_bytes(conf->routing_key)
+                            : AMQP_EMPTY_BYTES,
+                        /* arguments   = */ AMQP_EMPTY_TABLE);
+    if ((qb_ret == NULL) && camqp_is_error(conf)) {
+      char errbuf[1024];
+      ERROR("amqp plugin: amqp_queue_bind failed: %s",
+            camqp_strerror(conf, errbuf, sizeof(errbuf)));
+      camqp_close_connection(conf);
+      return (-1);
     }
 
-    return (0);
+    DEBUG("amqp plugin: Successfully bound queue \"%s\" to exchange \"%s\".",
+          conf->queue, conf->exchange);
+  } /* if (conf->exchange != NULL) */
+
+  cm_ret =
+      amqp_basic_consume(conf->connection,
+                         /* channel      = */ CAMQP_CHANNEL,
+                         /* queue        = */ amqp_cstring_bytes(conf->queue),
+                         /* consumer_tag = */ AMQP_EMPTY_BYTES,
+                         /* no_local     = */ 0,
+                         /* no_ack       = */ 1,
+                         /* exclusive    = */ 0,
+                         /* arguments    = */ AMQP_EMPTY_TABLE);
+  if ((cm_ret == NULL) && camqp_is_error(conf)) {
+    char errbuf[1024];
+    ERROR("amqp plugin: amqp_basic_consume failed: %s",
+          camqp_strerror(conf, errbuf, sizeof(errbuf)));
+    camqp_close_connection(conf);
+    return (-1);
+  }
+
+  return (0);
 } /* }}} int camqp_setup_queue */
 
-static int camqp_connect (camqp_config_t *conf) /* {{{ */
+static int camqp_connect(camqp_config_t *conf) /* {{{ */
 {
-    static time_t last_connect_time = 0;
+  static time_t last_connect_time = 0;
 
-    amqp_rpc_reply_t reply;
-    int status;
+  amqp_rpc_reply_t reply;
+  int status;
 #ifdef HAVE_AMQP_TCP_SOCKET
-    amqp_socket_t *socket;
+  amqp_socket_t *socket;
 #else
-    int sockfd;
+  int sockfd;
 #endif
 
-    if (conf->connection != NULL)
-        return (0);
+  if (conf->connection != NULL)
+    return (0);
 
-    time_t now = time(NULL);
-    if (now < (last_connect_time + conf->connection_retry_delay))
-    {
-        DEBUG("amqp plugin: skipping connection retry, "
-            "ConnectionRetryDelay: %d", conf->connection_retry_delay);
-        return(1);
-    }
-    else
-    {
-        DEBUG ("amqp plugin: retrying connection");
-        last_connect_time = now;
-    }
+  time_t now = time(NULL);
+  if (now < (last_connect_time + conf->connection_retry_delay)) {
+    DEBUG("amqp plugin: skipping connection retry, "
+          "ConnectionRetryDelay: %d",
+          conf->connection_retry_delay);
+    return (1);
+  } else {
+    DEBUG("amqp plugin: retrying connection");
+    last_connect_time = now;
+  }
 
-    conf->connection = amqp_new_connection ();
-    if (conf->connection == NULL)
-    {
-        ERROR ("amqp plugin: amqp_new_connection failed.");
-        return (ENOMEM);
-    }
+  conf->connection = amqp_new_connection();
+  if (conf->connection == NULL) {
+    ERROR("amqp plugin: amqp_new_connection failed.");
+    return (ENOMEM);
+  }
 
 #ifdef HAVE_AMQP_TCP_SOCKET
-# define CLOSE_SOCKET() /* amqp_destroy_connection() closes the socket for us */
-    /* TODO: add support for SSL using amqp_ssl_socket_new
-     *       and related functions */
-    socket = amqp_tcp_socket_new (conf->connection);
-    if (! socket)
-    {
-        ERROR ("amqp plugin: amqp_tcp_socket_new failed.");
-        amqp_destroy_connection (conf->connection);
-        conf->connection = NULL;
-        return (ENOMEM);
-    }
-
-    status = amqp_socket_open (socket, CONF(conf, host), conf->port);
-    if (status < 0)
-    {
-        char errbuf[1024];
-        status *= -1;
-        ERROR ("amqp plugin: amqp_socket_open failed: %s",
-                sstrerror (status, errbuf, sizeof (errbuf)));
-        amqp_destroy_connection (conf->connection);
-        conf->connection = NULL;
-        return (status);
-    }
+#define CLOSE_SOCKET() /* amqp_destroy_connection() closes the socket for us   \
+                          */
+  /* TODO: add support for SSL using amqp_ssl_socket_new
+   *       and related functions */
+  socket = amqp_tcp_socket_new(conf->connection);
+  if (!socket) {
+    ERROR("amqp plugin: amqp_tcp_socket_new failed.");
+    amqp_destroy_connection(conf->connection);
+    conf->connection = NULL;
+    return (ENOMEM);
+  }
+
+  status = amqp_socket_open(socket, CONF(conf, host), conf->port);
+  if (status < 0) {
+    char errbuf[1024];
+    status *= -1;
+    ERROR("amqp plugin: amqp_socket_open failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    amqp_destroy_connection(conf->connection);
+    conf->connection = NULL;
+    return (status);
+  }
 #else /* HAVE_AMQP_TCP_SOCKET */
-# define CLOSE_SOCKET() close(sockfd)
-    /* this interface is deprecated as of rabbitmq-c 0.4 */
-    sockfd = amqp_open_socket (CONF(conf, host), conf->port);
-    if (sockfd < 0)
-    {
-        char errbuf[1024];
-        status = (-1) * sockfd;
-        ERROR ("amqp plugin: amqp_open_socket failed: %s",
-                sstrerror (status, errbuf, sizeof (errbuf)));
-        amqp_destroy_connection (conf->connection);
-        conf->connection = NULL;
-        return (status);
-    }
-    amqp_set_sockfd (conf->connection, sockfd);
+#define CLOSE_SOCKET() close(sockfd)
+  /* this interface is deprecated as of rabbitmq-c 0.4 */
+  sockfd = amqp_open_socket(CONF(conf, host), conf->port);
+  if (sockfd < 0) {
+    char errbuf[1024];
+    status = (-1) * sockfd;
+    ERROR("amqp plugin: amqp_open_socket failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    amqp_destroy_connection(conf->connection);
+    conf->connection = NULL;
+    return (status);
+  }
+  amqp_set_sockfd(conf->connection, sockfd);
 #endif
 
-    reply = amqp_login (conf->connection, CONF(conf, vhost),
-            /* channel max = */      0,
-            /* frame max   = */ 131072,
-            /* heartbeat   = */      0,
-            /* authentication = */ AMQP_SASL_METHOD_PLAIN,
-            CONF(conf, user), CONF(conf, password));
-    if (reply.reply_type != AMQP_RESPONSE_NORMAL)
-    {
-        ERROR ("amqp plugin: amqp_login (vhost = %s, user = %s) failed.",
-                CONF(conf, vhost), CONF(conf, user));
-        amqp_destroy_connection (conf->connection);
-        CLOSE_SOCKET ();
-        conf->connection = NULL;
-        return (1);
-    }
-
-    amqp_channel_open (conf->connection, /* channel = */ 1);
-    /* FIXME: Is checking "reply.reply_type" really correct here? How does
-     * it get set? --octo */
-    if (reply.reply_type != AMQP_RESPONSE_NORMAL)
-    {
-        ERROR ("amqp plugin: amqp_channel_open failed.");
-        amqp_connection_close (conf->connection, AMQP_REPLY_SUCCESS);
-        amqp_destroy_connection (conf->connection);
-        CLOSE_SOCKET ();
-        conf->connection = NULL;
-        return (1);
-    }
+  reply = amqp_login(conf->connection, CONF(conf, vhost),
+                     /* channel max = */ 0,
+                     /* frame max   = */ 131072,
+                     /* heartbeat   = */ 0,
+                     /* authentication = */ AMQP_SASL_METHOD_PLAIN,
+                     CONF(conf, user), CONF(conf, password));
+  if (reply.reply_type != AMQP_RESPONSE_NORMAL) {
+    ERROR("amqp plugin: amqp_login (vhost = %s, user = %s) failed.",
+          CONF(conf, vhost), CONF(conf, user));
+    amqp_destroy_connection(conf->connection);
+    CLOSE_SOCKET();
+    conf->connection = NULL;
+    return (1);
+  }
+
+  amqp_channel_open(conf->connection, /* channel = */ 1);
+  /* FIXME: Is checking "reply.reply_type" really correct here? How does
+   * it get set? --octo */
+  if (reply.reply_type != AMQP_RESPONSE_NORMAL) {
+    ERROR("amqp plugin: amqp_channel_open failed.");
+    amqp_connection_close(conf->connection, AMQP_REPLY_SUCCESS);
+    amqp_destroy_connection(conf->connection);
+    CLOSE_SOCKET();
+    conf->connection = NULL;
+    return (1);
+  }
 
-    INFO ("amqp plugin: Successfully opened connection to vhost \"%s\" "
-            "on %s:%i.", CONF(conf, vhost), CONF(conf, host), conf->port);
+  INFO("amqp plugin: Successfully opened connection to vhost \"%s\" "
+       "on %s:%i.",
+       CONF(conf, vhost), CONF(conf, host), conf->port);
 
-    status = camqp_create_exchange (conf);
-    if (status != 0)
-        return (status);
+  status = camqp_create_exchange(conf);
+  if (status != 0)
+    return (status);
 
-    if (!conf->publish)
-        return (camqp_setup_queue (conf));
-    return (0);
+  if (!conf->publish)
+    return (camqp_setup_queue(conf));
+  return (0);
 } /* }}} int camqp_connect */
 
-static int camqp_shutdown (void) /* {{{ */
+static int camqp_shutdown(void) /* {{{ */
 {
-    DEBUG ("amqp plugin: Shutting down %zu subscriber threads.",
-            subscriber_threads_num);
-
-    subscriber_threads_running = 0;
-    for (size_t i = 0; i < subscriber_threads_num; i++)
-    {
-        /* FIXME: Sending a signal is not very elegant here. Maybe find out how
-         * to use a timeout in the thread and check for the variable in regular
-         * intervals. */
-        pthread_kill (subscriber_threads[i], SIGTERM);
-        pthread_join (subscriber_threads[i], /* retval = */ NULL);
-    }
+  DEBUG("amqp plugin: Shutting down %zu subscriber threads.",
+        subscriber_threads_num);
 
-    subscriber_threads_num = 0;
-    sfree (subscriber_threads);
+  subscriber_threads_running = 0;
+  for (size_t i = 0; i < subscriber_threads_num; i++) {
+    /* FIXME: Sending a signal is not very elegant here. Maybe find out how
+     * to use a timeout in the thread and check for the variable in regular
+     * intervals. */
+    pthread_kill(subscriber_threads[i], SIGTERM);
+    pthread_join(subscriber_threads[i], /* retval = */ NULL);
+  }
 
-    DEBUG ("amqp plugin: All subscriber threads exited.");
+  subscriber_threads_num = 0;
+  sfree(subscriber_threads);
 
-    return (0);
+  DEBUG("amqp plugin: All subscriber threads exited.");
+
+  return (0);
 } /* }}} int camqp_shutdown */
 
 /*
  * Subscribing code
  */
-static int camqp_read_body (camqp_config_t *conf, /* {{{ */
-        size_t body_size, const char *content_type)
-{
-    char body[body_size + 1];
-    char *body_ptr;
-    size_t received;
-    amqp_frame_t frame;
-    int status;
-
-    memset (body, 0, sizeof (body));
-    body_ptr = &body[0];
-    received = 0;
-
-    while (received < body_size)
-    {
-        status = amqp_simple_wait_frame (conf->connection, &frame);
-        if (status < 0)
-        {
-            char errbuf[1024];
-            status = (-1) * status;
-            ERROR ("amqp plugin: amqp_simple_wait_frame failed: %s",
-                    sstrerror (status, errbuf, sizeof (errbuf)));
-            camqp_close_connection (conf);
-            return (status);
-        }
-
-        if (frame.frame_type != AMQP_FRAME_BODY)
-        {
-            NOTICE ("amqp plugin: Unexpected frame type: %#"PRIx8,
-                    frame.frame_type);
-            return (-1);
-        }
-
-        if ((body_size - received) < frame.payload.body_fragment.len)
-        {
-            WARNING ("amqp plugin: Body is larger than indicated by header.");
-            return (-1);
-        }
-
-        memcpy (body_ptr, frame.payload.body_fragment.bytes,
-                frame.payload.body_fragment.len);
-        body_ptr += frame.payload.body_fragment.len;
-        received += frame.payload.body_fragment.len;
-    } /* while (received < body_size) */
-
-    if (strcasecmp ("text/collectd", content_type) == 0)
-    {
-        status = cmd_handle_putval (stderr, body);
-        if (status != 0)
-            ERROR ("amqp plugin: cmd_handle_putval failed with status %i.",
-                    status);
-        return (status);
+static int camqp_read_body(camqp_config_t *conf, /* {{{ */
+                           size_t body_size, const char *content_type) {
+  char body[body_size + 1];
+  char *body_ptr;
+  size_t received;
+  amqp_frame_t frame;
+  int status;
+
+  memset(body, 0, sizeof(body));
+  body_ptr = &body[0];
+  received = 0;
+
+  while (received < body_size) {
+    status = amqp_simple_wait_frame(conf->connection, &frame);
+    if (status < 0) {
+      char errbuf[1024];
+      status = (-1) * status;
+      ERROR("amqp plugin: amqp_simple_wait_frame failed: %s",
+            sstrerror(status, errbuf, sizeof(errbuf)));
+      camqp_close_connection(conf);
+      return (status);
     }
-    else if (strcasecmp ("application/json", content_type) == 0)
-    {
-        ERROR ("amqp plugin: camqp_read_body: Parsing JSON data has not "
-                "been implemented yet. FIXME!");
-        return (0);
+
+    if (frame.frame_type != AMQP_FRAME_BODY) {
+      NOTICE("amqp plugin: Unexpected frame type: %#" PRIx8, frame.frame_type);
+      return (-1);
     }
-    else
-    {
-        ERROR ("amqp plugin: camqp_read_body: Unknown content type \"%s\".",
-                content_type);
-        return (EINVAL);
+
+    if ((body_size - received) < frame.payload.body_fragment.len) {
+      WARNING("amqp plugin: Body is larger than indicated by header.");
+      return (-1);
     }
 
-    /* not reached */
+    memcpy(body_ptr, frame.payload.body_fragment.bytes,
+           frame.payload.body_fragment.len);
+    body_ptr += frame.payload.body_fragment.len;
+    received += frame.payload.body_fragment.len;
+  } /* while (received < body_size) */
+
+  if (strcasecmp("text/collectd", content_type) == 0) {
+    status = cmd_handle_putval(stderr, body);
+    if (status != 0)
+      ERROR("amqp plugin: cmd_handle_putval failed with status %i.", status);
+    return (status);
+  } else if (strcasecmp("application/json", content_type) == 0) {
+    ERROR("amqp plugin: camqp_read_body: Parsing JSON data has not "
+          "been implemented yet. FIXME!");
     return (0);
+  } else {
+    ERROR("amqp plugin: camqp_read_body: Unknown content type \"%s\".",
+          content_type);
+    return (EINVAL);
+  }
+
+  /* not reached */
+  return (0);
 } /* }}} int camqp_read_body */
 
-static int camqp_read_header (camqp_config_t *conf) /* {{{ */
+static int camqp_read_header(camqp_config_t *conf) /* {{{ */
 {
-    int status;
+  int status;
+  amqp_frame_t frame;
+  amqp_basic_properties_t *properties;
+  char *content_type;
+
+  status = amqp_simple_wait_frame(conf->connection, &frame);
+  if (status < 0) {
+    char errbuf[1024];
+    status = (-1) * status;
+    ERROR("amqp plugin: amqp_simple_wait_frame failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    camqp_close_connection(conf);
+    return (status);
+  }
+
+  if (frame.frame_type != AMQP_FRAME_HEADER) {
+    NOTICE("amqp plugin: Unexpected frame type: %#" PRIx8, frame.frame_type);
+    return (-1);
+  }
+
+  properties = frame.payload.properties.decoded;
+  content_type = camqp_bytes_cstring(&properties->content_type);
+  if (content_type == NULL) {
+    ERROR("amqp plugin: Unable to determine content type.");
+    return (-1);
+  }
+
+  status = camqp_read_body(conf, (size_t)frame.payload.properties.body_size,
+                           content_type);
+
+  sfree(content_type);
+  return (status);
+} /* }}} int camqp_read_header */
+
+static void *camqp_subscribe_thread(void *user_data) /* {{{ */
+{
+  camqp_config_t *conf = user_data;
+  int status;
+
+  cdtime_t interval = plugin_get_interval();
+
+  while (subscriber_threads_running) {
     amqp_frame_t frame;
-    amqp_basic_properties_t *properties;
-    char *content_type;
-
-    status = amqp_simple_wait_frame (conf->connection, &frame);
-    if (status < 0)
-    {
-        char errbuf[1024];
-        status = (-1) * status;
-        ERROR ("amqp plugin: amqp_simple_wait_frame failed: %s",
-                    sstrerror (status, errbuf, sizeof (errbuf)));
-        camqp_close_connection (conf);
-        return (status);
+
+    status = camqp_connect(conf);
+    if (status != 0) {
+      ERROR("amqp plugin: camqp_connect failed. "
+            "Will sleep for %.3f seconds.",
+            CDTIME_T_TO_DOUBLE(interval));
+      nanosleep(&CDTIME_T_TO_TIMESPEC(interval), /* remaining = */ NULL);
+      continue;
     }
 
-    if (frame.frame_type != AMQP_FRAME_HEADER)
-    {
-        NOTICE ("amqp plugin: Unexpected frame type: %#"PRIx8,
-                frame.frame_type);
-        return (-1);
+    status = amqp_simple_wait_frame(conf->connection, &frame);
+    if (status < 0) {
+      ERROR("amqp plugin: amqp_simple_wait_frame failed. "
+            "Will sleep for %.3f seconds.",
+            CDTIME_T_TO_DOUBLE(interval));
+      camqp_close_connection(conf);
+      nanosleep(&CDTIME_T_TO_TIMESPEC(interval), /* remaining = */ NULL);
+      continue;
     }
 
-    properties = frame.payload.properties.decoded;
-    content_type = camqp_bytes_cstring (&properties->content_type);
-    if (content_type == NULL)
-    {
-        ERROR ("amqp plugin: Unable to determine content type.");
-        return (-1);
+    if (frame.frame_type != AMQP_FRAME_METHOD) {
+      DEBUG("amqp plugin: Unexpected frame type: %#" PRIx8, frame.frame_type);
+      continue;
     }
 
-    status = camqp_read_body (conf,
-            (size_t) frame.payload.properties.body_size,
-            content_type);
+    if (frame.payload.method.id != AMQP_BASIC_DELIVER_METHOD) {
+      DEBUG("amqp plugin: Unexpected method id: %#" PRIx32,
+            frame.payload.method.id);
+      continue;
+    }
 
-    sfree (content_type);
-    return (status);
-} /* }}} int camqp_read_header */
+    camqp_read_header(conf);
 
-static void *camqp_subscribe_thread (void *user_data) /* {{{ */
-{
-    camqp_config_t *conf = user_data;
-    int status;
-
-    cdtime_t interval = plugin_get_interval ();
-
-    while (subscriber_threads_running)
-    {
-        amqp_frame_t frame;
-
-        status = camqp_connect (conf);
-        if (status != 0)
-        {
-            ERROR ("amqp plugin: camqp_connect failed. "
-                    "Will sleep for %.3f seconds.",
-                    CDTIME_T_TO_DOUBLE (interval));
-            nanosleep (&CDTIME_T_TO_TIMESPEC (interval), /* remaining = */ NULL);
-            continue;
-        }
-
-        status = amqp_simple_wait_frame (conf->connection, &frame);
-        if (status < 0)
-        {
-            ERROR ("amqp plugin: amqp_simple_wait_frame failed. "
-                    "Will sleep for %.3f seconds.",
-                    CDTIME_T_TO_DOUBLE (interval));
-            camqp_close_connection (conf);
-            nanosleep (&CDTIME_T_TO_TIMESPEC (interval), /* remaining = */ NULL);
-            continue;
-        }
-
-        if (frame.frame_type != AMQP_FRAME_METHOD)
-        {
-            DEBUG ("amqp plugin: Unexpected frame type: %#"PRIx8,
-                    frame.frame_type);
-            continue;
-        }
-
-        if (frame.payload.method.id != AMQP_BASIC_DELIVER_METHOD)
-        {
-            DEBUG ("amqp plugin: Unexpected method id: %#"PRIx32,
-                    frame.payload.method.id);
-            continue;
-        }
-
-        camqp_read_header (conf);
-
-        amqp_maybe_release_buffers (conf->connection);
-    } /* while (subscriber_threads_running) */
-
-    camqp_config_free (conf);
-    pthread_exit (NULL);
-    return (NULL);
+    amqp_maybe_release_buffers(conf->connection);
+  } /* while (subscriber_threads_running) */
+
+  camqp_config_free(conf);
+  pthread_exit(NULL);
+  return (NULL);
 } /* }}} void *camqp_subscribe_thread */
 
-static int camqp_subscribe_init (camqp_config_t *conf) /* {{{ */
+static int camqp_subscribe_init(camqp_config_t *conf) /* {{{ */
 {
-    int status;
-    pthread_t *tmp;
-
-    tmp = realloc (subscriber_threads,
-            sizeof (*subscriber_threads) * (subscriber_threads_num + 1));
-    if (tmp == NULL)
-    {
-        ERROR ("amqp plugin: realloc failed.");
-        sfree (subscriber_threads);
-        return (ENOMEM);
-    }
-    subscriber_threads = tmp;
-    tmp = subscriber_threads + subscriber_threads_num;
-    memset (tmp, 0, sizeof (*tmp));
-
-    status = plugin_thread_create (tmp, /* attr = */ NULL,
-            camqp_subscribe_thread, conf, "amqp subscribe");
-    if (status != 0)
-    {
-        char errbuf[1024];
-        ERROR ("amqp plugin: pthread_create failed: %s",
-                sstrerror (status, errbuf, sizeof (errbuf)));
-        return (status);
-    }
+  int status;
+  pthread_t *tmp;
+
+  tmp = realloc(subscriber_threads,
+                sizeof(*subscriber_threads) * (subscriber_threads_num + 1));
+  if (tmp == NULL) {
+    ERROR("amqp plugin: realloc failed.");
+    sfree(subscriber_threads);
+    return (ENOMEM);
+  }
+  subscriber_threads = tmp;
+  tmp = subscriber_threads + subscriber_threads_num;
+  memset(tmp, 0, sizeof(*tmp));
+
+  status = plugin_thread_create(tmp, /* attr = */ NULL, camqp_subscribe_thread,
+                                conf, "amqp subscribe");
+  if (status != 0) {
+    char errbuf[1024];
+    ERROR("amqp plugin: pthread_create failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    return (status);
+  }
 
-    subscriber_threads_num++;
+  subscriber_threads_num++;
 
-    return (0);
+  return (0);
 } /* }}} int camqp_subscribe_init */
 
 /*
  * Publishing code
  */
 /* XXX: You must hold "conf->lock" when calling this function! */
-static int camqp_write_locked (camqp_config_t *conf, /* {{{ */
-        const char *buffer, const char *routing_key)
-{
-    int status;
-
-    status = camqp_connect (conf);
-    if (status != 0)
-        return (status);
-
-    amqp_basic_properties_t props = {
-        ._flags = AMQP_BASIC_CONTENT_TYPE_FLAG
-            | AMQP_BASIC_DELIVERY_MODE_FLAG
-            | AMQP_BASIC_APP_ID_FLAG,
-        .delivery_mode = conf->delivery_mode,
-        .app_id = amqp_cstring_bytes("collectd")
-    };
-
-    if (conf->format == CAMQP_FORMAT_COMMAND)
-        props.content_type = amqp_cstring_bytes("text/collectd");
-    else if (conf->format == CAMQP_FORMAT_JSON)
-        props.content_type = amqp_cstring_bytes("application/json");
-    else if (conf->format == CAMQP_FORMAT_GRAPHITE)
-        props.content_type = amqp_cstring_bytes("text/graphite");
-    else
-        assert (23 == 42);
-
-    status = amqp_basic_publish(conf->connection,
-                /* channel = */ 1,
-                amqp_cstring_bytes(CONF(conf, exchange)),
-                amqp_cstring_bytes (routing_key),
-                /* mandatory = */ 0,
-                /* immediate = */ 0,
-                &props,
-                amqp_cstring_bytes(buffer));
-    if (status != 0)
-    {
-        ERROR ("amqp plugin: amqp_basic_publish failed with status %i.",
-                status);
-        camqp_close_connection (conf);
-    }
+static int camqp_write_locked(camqp_config_t *conf, /* {{{ */
+                              const char *buffer, const char *routing_key) {
+  int status;
 
+  status = camqp_connect(conf);
+  if (status != 0)
     return (status);
-} /* }}} int camqp_write_locked */
-
-static int camqp_write (const data_set_t *ds, const value_list_t *vl, /* {{{ */
-        user_data_t *user_data)
-{
-    camqp_config_t *conf = user_data->data;
-    char routing_key[6 * DATA_MAX_NAME_LEN];
-    char buffer[8192];
-    int status;
 
-    if ((ds == NULL) || (vl == NULL) || (conf == NULL))
-        return (EINVAL);
+  amqp_basic_properties_t props = {._flags = AMQP_BASIC_CONTENT_TYPE_FLAG |
+                                             AMQP_BASIC_DELIVERY_MODE_FLAG |
+                                             AMQP_BASIC_APP_ID_FLAG,
+                                   .delivery_mode = conf->delivery_mode,
+                                   .app_id = amqp_cstring_bytes("collectd")};
+
+  if (conf->format == CAMQP_FORMAT_COMMAND)
+    props.content_type = amqp_cstring_bytes("text/collectd");
+  else if (conf->format == CAMQP_FORMAT_JSON)
+    props.content_type = amqp_cstring_bytes("application/json");
+  else if (conf->format == CAMQP_FORMAT_GRAPHITE)
+    props.content_type = amqp_cstring_bytes("text/graphite");
+  else
+    assert(23 == 42);
+
+  status = amqp_basic_publish(
+      conf->connection,
+      /* channel = */ 1, amqp_cstring_bytes(CONF(conf, exchange)),
+      amqp_cstring_bytes(routing_key),
+      /* mandatory = */ 0,
+      /* immediate = */ 0, &props, amqp_cstring_bytes(buffer));
+  if (status != 0) {
+    ERROR("amqp plugin: amqp_basic_publish failed with status %i.", status);
+    camqp_close_connection(conf);
+  }
+
+  return (status);
+} /* }}} int camqp_write_locked */
 
-    if (conf->routing_key != NULL)
-    {
-        sstrncpy (routing_key, conf->routing_key, sizeof (routing_key));
-    }
-    else
-    {
-        ssnprintf (routing_key, sizeof (routing_key), "collectd/%s/%s/%s/%s/%s",
-                vl->host,
-                vl->plugin, vl->plugin_instance,
-                vl->type, vl->type_instance);
-
-        /* Switch slashes (the only character forbidden by collectd) and dots
-         * (the separation character used by AMQP). */
-        for (size_t i = 0; routing_key[i] != 0; i++)
-        {
-            if (routing_key[i] == '.')
-                routing_key[i] = '/';
-            else if (routing_key[i] == '/')
-                routing_key[i] = '.';
-        }
+static int camqp_write(const data_set_t *ds, const value_list_t *vl, /* {{{ */
+                       user_data_t *user_data) {
+  camqp_config_t *conf = user_data->data;
+  char routing_key[6 * DATA_MAX_NAME_LEN];
+  char buffer[8192];
+  int status;
+
+  if ((ds == NULL) || (vl == NULL) || (conf == NULL))
+    return (EINVAL);
+
+  if (conf->routing_key != NULL) {
+    sstrncpy(routing_key, conf->routing_key, sizeof(routing_key));
+  } else {
+    ssnprintf(routing_key, sizeof(routing_key), "collectd/%s/%s/%s/%s/%s",
+              vl->host, vl->plugin, vl->plugin_instance, vl->type,
+              vl->type_instance);
+
+    /* Switch slashes (the only character forbidden by collectd) and dots
+     * (the separation character used by AMQP). */
+    for (size_t i = 0; routing_key[i] != 0; i++) {
+      if (routing_key[i] == '.')
+        routing_key[i] = '/';
+      else if (routing_key[i] == '/')
+        routing_key[i] = '.';
     }
+  }
 
-    if (conf->format == CAMQP_FORMAT_COMMAND)
-    {
-        status = cmd_create_putval (buffer, sizeof (buffer), ds, vl);
-        if (status != 0)
-        {
-            ERROR ("amqp plugin: cmd_create_putval failed with status %i.",
-                    status);
-            return (status);
-        }
+  if (conf->format == CAMQP_FORMAT_COMMAND) {
+    status = cmd_create_putval(buffer, sizeof(buffer), ds, vl);
+    if (status != 0) {
+      ERROR("amqp plugin: cmd_create_putval failed with status %i.", status);
+      return (status);
     }
-    else if (conf->format == CAMQP_FORMAT_JSON)
-    {
-        size_t bfree = sizeof (buffer);
-        size_t bfill = 0;
-
-        format_json_initialize (buffer, &bfill, &bfree);
-        format_json_value_list (buffer, &bfill, &bfree, ds, vl, conf->store_rates);
-        format_json_finalize (buffer, &bfill, &bfree);
-    }
-    else if (conf->format == CAMQP_FORMAT_GRAPHITE)
-    {
-        status = format_graphite (buffer, sizeof (buffer), ds, vl,
-                    conf->prefix, conf->postfix, conf->escape_char,
-                    conf->graphite_flags);
-        if (status != 0)
-        {
-            ERROR ("amqp plugin: format_graphite failed with status %i.",
-                    status);
-            return (status);
-        }
-    }
-    else
-    {
-        ERROR ("amqp plugin: Invalid format (%i).", conf->format);
-        return (-1);
+  } else if (conf->format == CAMQP_FORMAT_JSON) {
+    size_t bfree = sizeof(buffer);
+    size_t bfill = 0;
+
+    format_json_initialize(buffer, &bfill, &bfree);
+    format_json_value_list(buffer, &bfill, &bfree, ds, vl, conf->store_rates);
+    format_json_finalize(buffer, &bfill, &bfree);
+  } else if (conf->format == CAMQP_FORMAT_GRAPHITE) {
+    status =
+        format_graphite(buffer, sizeof(buffer), ds, vl, conf->prefix,
+                        conf->postfix, conf->escape_char, conf->graphite_flags);
+    if (status != 0) {
+      ERROR("amqp plugin: format_graphite failed with status %i.", status);
+      return (status);
     }
+  } else {
+    ERROR("amqp plugin: Invalid format (%i).", conf->format);
+    return (-1);
+  }
 
-    pthread_mutex_lock (&conf->lock);
-    status = camqp_write_locked (conf, buffer, routing_key);
-    pthread_mutex_unlock (&conf->lock);
+  pthread_mutex_lock(&conf->lock);
+  status = camqp_write_locked(conf, buffer, routing_key);
+  pthread_mutex_unlock(&conf->lock);
 
-    return (status);
+  return (status);
 } /* }}} int camqp_write */
 
 /*
  * Config handling
  */
-static int camqp_config_set_format (oconfig_item_t *ci, /* {{{ */
-        camqp_config_t *conf)
-{
-    char *string;
-    int status;
+static int camqp_config_set_format(oconfig_item_t *ci, /* {{{ */
+                                   camqp_config_t *conf) {
+  char *string;
+  int status;
+
+  string = NULL;
+  status = cf_util_get_string(ci, &string);
+  if (status != 0)
+    return (status);
 
-    string = NULL;
-    status = cf_util_get_string (ci, &string);
-    if (status != 0)
-        return (status);
-
-    assert (string != NULL);
-    if (strcasecmp ("Command", string) == 0)
-        conf->format = CAMQP_FORMAT_COMMAND;
-    else if (strcasecmp ("JSON", string) == 0)
-        conf->format = CAMQP_FORMAT_JSON;
-    else if (strcasecmp ("Graphite", string) == 0)
-        conf->format = CAMQP_FORMAT_GRAPHITE;
-    else
-    {
-        WARNING ("amqp plugin: Invalid format string: %s",
-                string);
-    }
+  assert(string != NULL);
+  if (strcasecmp("Command", string) == 0)
+    conf->format = CAMQP_FORMAT_COMMAND;
+  else if (strcasecmp("JSON", string) == 0)
+    conf->format = CAMQP_FORMAT_JSON;
+  else if (strcasecmp("Graphite", string) == 0)
+    conf->format = CAMQP_FORMAT_GRAPHITE;
+  else {
+    WARNING("amqp plugin: Invalid format string: %s", string);
+  }
 
-    free (string);
+  free(string);
 
-    return (0);
+  return (0);
 } /* }}} int config_set_string */
 
-static int camqp_config_connection (oconfig_item_t *ci, /* {{{ */
-        _Bool publish)
-{
-    camqp_config_t *conf;
-    int status;
-
-    conf = calloc (1, sizeof (*conf));
-    if (conf == NULL)
-    {
-        ERROR ("amqp plugin: calloc failed.");
-        return (ENOMEM);
-    }
-
-    /* Initialize "conf" {{{ */
-    conf->publish = publish;
-    conf->name = NULL;
-    conf->format = CAMQP_FORMAT_COMMAND;
-    conf->host = NULL;
-    conf->port = 5672;
-    conf->vhost = NULL;
-    conf->user = NULL;
-    conf->password = NULL;
-    conf->exchange = NULL;
-    conf->routing_key = NULL;
-    conf->connection_retry_delay = 0;
-
-    /* publish only */
-    conf->delivery_mode = CAMQP_DM_VOLATILE;
-    conf->store_rates = 0;
-    conf->graphite_flags = 0;
-    /* publish & graphite only */
-    conf->prefix = NULL;
-    conf->postfix = NULL;
-    conf->escape_char = '_';
-    /* subscribe only */
-    conf->exchange_type = NULL;
-    conf->queue = NULL;
-    conf->queue_durable = 0;
-    conf->queue_auto_delete = 1;
-    /* general */
-    conf->connection = NULL;
-    pthread_mutex_init (&conf->lock, /* attr = */ NULL);
-    /* }}} */
+static int camqp_config_connection(oconfig_item_t *ci, /* {{{ */
+                                   _Bool publish) {
+  camqp_config_t *conf;
+  int status;
+
+  conf = calloc(1, sizeof(*conf));
+  if (conf == NULL) {
+    ERROR("amqp plugin: calloc failed.");
+    return (ENOMEM);
+  }
+
+  /* Initialize "conf" {{{ */
+  conf->publish = publish;
+  conf->name = NULL;
+  conf->format = CAMQP_FORMAT_COMMAND;
+  conf->host = NULL;
+  conf->port = 5672;
+  conf->vhost = NULL;
+  conf->user = NULL;
+  conf->password = NULL;
+  conf->exchange = NULL;
+  conf->routing_key = NULL;
+  conf->connection_retry_delay = 0;
+
+  /* publish only */
+  conf->delivery_mode = CAMQP_DM_VOLATILE;
+  conf->store_rates = 0;
+  conf->graphite_flags = 0;
+  /* publish & graphite only */
+  conf->prefix = NULL;
+  conf->postfix = NULL;
+  conf->escape_char = '_';
+  /* subscribe only */
+  conf->exchange_type = NULL;
+  conf->queue = NULL;
+  conf->queue_durable = 0;
+  conf->queue_auto_delete = 1;
+  /* general */
+  conf->connection = NULL;
+  pthread_mutex_init(&conf->lock, /* attr = */ NULL);
+  /* }}} */
+
+  status = cf_util_get_string(ci, &conf->name);
+  if (status != 0) {
+    sfree(conf);
+    return (status);
+  }
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("Host", child->key) == 0)
+      status = cf_util_get_string(child, &conf->host);
+    else if (strcasecmp("Port", child->key) == 0) {
+      status = cf_util_get_port_number(child);
+      if (status > 0) {
+        conf->port = status;
+        status = 0;
+      }
+    } else if (strcasecmp("VHost", child->key) == 0)
+      status = cf_util_get_string(child, &conf->vhost);
+    else if (strcasecmp("User", child->key) == 0)
+      status = cf_util_get_string(child, &conf->user);
+    else if (strcasecmp("Password", child->key) == 0)
+      status = cf_util_get_string(child, &conf->password);
+    else if (strcasecmp("Exchange", child->key) == 0)
+      status = cf_util_get_string(child, &conf->exchange);
+    else if ((strcasecmp("ExchangeType", child->key) == 0) && !publish)
+      status = cf_util_get_string(child, &conf->exchange_type);
+    else if ((strcasecmp("Queue", child->key) == 0) && !publish)
+      status = cf_util_get_string(child, &conf->queue);
+    else if ((strcasecmp("QueueDurable", child->key) == 0) && !publish)
+      status = cf_util_get_boolean(child, &conf->queue_durable);
+    else if ((strcasecmp("QueueAutoDelete", child->key) == 0) && !publish)
+      status = cf_util_get_boolean(child, &conf->queue_auto_delete);
+    else if (strcasecmp("RoutingKey", child->key) == 0)
+      status = cf_util_get_string(child, &conf->routing_key);
+    else if ((strcasecmp("Persistent", child->key) == 0) && publish) {
+      _Bool tmp = 0;
+      status = cf_util_get_boolean(child, &tmp);
+      if (tmp)
+        conf->delivery_mode = CAMQP_DM_PERSISTENT;
+      else
+        conf->delivery_mode = CAMQP_DM_VOLATILE;
+    } else if ((strcasecmp("StoreRates", child->key) == 0) && publish) {
+      status = cf_util_get_boolean(child, &conf->store_rates);
+      (void)cf_util_get_flag(child, &conf->graphite_flags,
+                             GRAPHITE_STORE_RATES);
+    } else if ((strcasecmp("Format", child->key) == 0) && publish)
+      status = camqp_config_set_format(child, conf);
+    else if ((strcasecmp("GraphiteSeparateInstances", child->key) == 0) &&
+             publish)
+      status = cf_util_get_flag(child, &conf->graphite_flags,
+                                GRAPHITE_SEPARATE_INSTANCES);
+    else if ((strcasecmp("GraphiteAlwaysAppendDS", child->key) == 0) && publish)
+      status = cf_util_get_flag(child, &conf->graphite_flags,
+                                GRAPHITE_ALWAYS_APPEND_DS);
+    else if ((strcasecmp("GraphitePreserveSeparator", child->key) == 0) &&
+             publish)
+      status = cf_util_get_flag(child, &conf->graphite_flags,
+                                GRAPHITE_PRESERVE_SEPARATOR);
+    else if ((strcasecmp("GraphitePrefix", child->key) == 0) && publish)
+      status = cf_util_get_string(child, &conf->prefix);
+    else if ((strcasecmp("GraphitePostfix", child->key) == 0) && publish)
+      status = cf_util_get_string(child, &conf->postfix);
+    else if ((strcasecmp("GraphiteEscapeChar", child->key) == 0) && publish) {
+      char *tmp_buff = NULL;
+      status = cf_util_get_string(child, &tmp_buff);
+      if (strlen(tmp_buff) > 1)
+        WARNING("amqp plugin: The option \"GraphiteEscapeChar\" handles "
+                "only one character. Others will be ignored.");
+      conf->escape_char = tmp_buff[0];
+      sfree(tmp_buff);
+    } else if (strcasecmp("ConnectionRetryDelay", child->key) == 0)
+      status = cf_util_get_int(child, &conf->connection_retry_delay);
+    else
+      WARNING("amqp plugin: Ignoring unknown "
+              "configuration option \"%s\".",
+              child->key);
 
-    status = cf_util_get_string (ci, &conf->name);
     if (status != 0)
-    {
-        sfree (conf);
-        return (status);
-    }
-
-    for (int i = 0; i < ci->children_num; i++)
-    {
-        oconfig_item_t *child = ci->children + i;
-
-        if (strcasecmp ("Host", child->key) == 0)
-            status = cf_util_get_string (child, &conf->host);
-        else if (strcasecmp ("Port", child->key) == 0)
-        {
-            status = cf_util_get_port_number (child);
-            if (status > 0)
-            {
-                conf->port = status;
-                status = 0;
-            }
-        }
-        else if (strcasecmp ("VHost", child->key) == 0)
-            status = cf_util_get_string (child, &conf->vhost);
-        else if (strcasecmp ("User", child->key) == 0)
-            status = cf_util_get_string (child, &conf->user);
-        else if (strcasecmp ("Password", child->key) == 0)
-            status = cf_util_get_string (child, &conf->password);
-        else if (strcasecmp ("Exchange", child->key) == 0)
-            status = cf_util_get_string (child, &conf->exchange);
-        else if ((strcasecmp ("ExchangeType", child->key) == 0) && !publish)
-            status = cf_util_get_string (child, &conf->exchange_type);
-        else if ((strcasecmp ("Queue", child->key) == 0) && !publish)
-            status = cf_util_get_string (child, &conf->queue);
-        else if ((strcasecmp ("QueueDurable", child->key) == 0) && !publish)
-            status = cf_util_get_boolean (child, &conf->queue_durable);
-        else if ((strcasecmp ("QueueAutoDelete", child->key) == 0) && !publish)
-            status = cf_util_get_boolean (child, &conf->queue_auto_delete);
-        else if (strcasecmp ("RoutingKey", child->key) == 0)
-            status = cf_util_get_string (child, &conf->routing_key);
-        else if ((strcasecmp ("Persistent", child->key) == 0) && publish)
-        {
-            _Bool tmp = 0;
-            status = cf_util_get_boolean (child, &tmp);
-            if (tmp)
-                conf->delivery_mode = CAMQP_DM_PERSISTENT;
-            else
-                conf->delivery_mode = CAMQP_DM_VOLATILE;
-        }
-        else if ((strcasecmp ("StoreRates", child->key) == 0) && publish)
-        {
-            status = cf_util_get_boolean (child, &conf->store_rates);
-            (void) cf_util_get_flag (child, &conf->graphite_flags,
-                    GRAPHITE_STORE_RATES);
-        }
-        else if ((strcasecmp ("Format", child->key) == 0) && publish)
-            status = camqp_config_set_format (child, conf);
-        else if ((strcasecmp ("GraphiteSeparateInstances", child->key) == 0) && publish)
-            status = cf_util_get_flag (child, &conf->graphite_flags,
-                    GRAPHITE_SEPARATE_INSTANCES);
-        else if ((strcasecmp ("GraphiteAlwaysAppendDS", child->key) == 0) && publish)
-            status = cf_util_get_flag (child, &conf->graphite_flags,
-                    GRAPHITE_ALWAYS_APPEND_DS);
-        else if ((strcasecmp ("GraphitePreserveSeparator", child->key) == 0) && publish)
-            status = cf_util_get_flag (child, &conf->graphite_flags,
-                    GRAPHITE_PRESERVE_SEPARATOR);
-        else if ((strcasecmp ("GraphitePrefix", child->key) == 0) && publish)
-            status = cf_util_get_string (child, &conf->prefix);
-        else if ((strcasecmp ("GraphitePostfix", child->key) == 0) && publish)
-            status = cf_util_get_string (child, &conf->postfix);
-        else if ((strcasecmp ("GraphiteEscapeChar", child->key) == 0) && publish)
-        {
-            char *tmp_buff = NULL;
-            status = cf_util_get_string (child, &tmp_buff);
-            if (strlen (tmp_buff) > 1)
-                WARNING ("amqp plugin: The option \"GraphiteEscapeChar\" handles "
-                        "only one character. Others will be ignored.");
-            conf->escape_char = tmp_buff[0];
-            sfree (tmp_buff);
-        }
-        else if (strcasecmp ("ConnectionRetryDelay", child->key) == 0)
-            status = cf_util_get_int (child, &conf->connection_retry_delay);
-        else
-            WARNING ("amqp plugin: Ignoring unknown "
-                    "configuration option \"%s\".", child->key);
-
-        if (status != 0)
-            break;
-    } /* for (i = 0; i < ci->children_num; i++) */
-
-    if ((status == 0) && (conf->exchange == NULL))
-    {
-        if (conf->exchange_type != NULL)
-            WARNING ("amqp plugin: The option \"ExchangeType\" was given "
-                    "without the \"Exchange\" option. It will be ignored.");
-
-        if (!publish && (conf->routing_key != NULL))
-            WARNING ("amqp plugin: The option \"RoutingKey\" was given "
-                    "without the \"Exchange\" option. It will be ignored.");
+      break;
+  } /* for (i = 0; i < ci->children_num; i++) */
 
-    }
-
-    if (status != 0)
-    {
-        camqp_config_free (conf);
-        return (status);
-    }
+  if ((status == 0) && (conf->exchange == NULL)) {
+    if (conf->exchange_type != NULL)
+      WARNING("amqp plugin: The option \"ExchangeType\" was given "
+              "without the \"Exchange\" option. It will be ignored.");
 
-    if (conf->exchange != NULL)
-    {
-        DEBUG ("amqp plugin: camqp_config_connection: exchange = %s;",
-                conf->exchange);
-    }
+    if (!publish && (conf->routing_key != NULL))
+      WARNING("amqp plugin: The option \"RoutingKey\" was given "
+              "without the \"Exchange\" option. It will be ignored.");
+  }
 
-    if (publish)
-    {
-        char cbname[128];
-        ssnprintf (cbname, sizeof (cbname), "amqp/%s", conf->name);
-
-        status = plugin_register_write (cbname, camqp_write,
-                &(user_data_t) {
-                    .data = conf,
-                    .free_func = camqp_config_free,
-                });
-        if (status != 0)
-        {
-            camqp_config_free (conf);
-            return (status);
-        }
+  if (status != 0) {
+    camqp_config_free(conf);
+    return (status);
+  }
+
+  if (conf->exchange != NULL) {
+    DEBUG("amqp plugin: camqp_config_connection: exchange = %s;",
+          conf->exchange);
+  }
+
+  if (publish) {
+    char cbname[128];
+    ssnprintf(cbname, sizeof(cbname), "amqp/%s", conf->name);
+
+    status = plugin_register_write(
+        cbname, camqp_write, &(user_data_t){
+                                 .data = conf, .free_func = camqp_config_free,
+                             });
+    if (status != 0) {
+      camqp_config_free(conf);
+      return (status);
     }
-    else
-    {
-        status = camqp_subscribe_init (conf);
-        if (status != 0)
-        {
-            camqp_config_free (conf);
-            return (status);
-        }
+  } else {
+    status = camqp_subscribe_init(conf);
+    if (status != 0) {
+      camqp_config_free(conf);
+      return (status);
     }
+  }
 
-    return (0);
+  return (0);
 } /* }}} int camqp_config_connection */
 
-static int camqp_config (oconfig_item_t *ci) /* {{{ */
+static int camqp_config(oconfig_item_t *ci) /* {{{ */
 {
-    for (int i = 0; i < ci->children_num; i++)
-    {
-        oconfig_item_t *child = ci->children + i;
-
-        if (strcasecmp ("Publish", child->key) == 0)
-            camqp_config_connection (child, /* publish = */ 1);
-        else if (strcasecmp ("Subscribe", child->key) == 0)
-            camqp_config_connection (child, /* publish = */ 0);
-        else
-            WARNING ("amqp plugin: Ignoring unknown config option \"%s\".",
-                    child->key);
-    } /* for (ci->children_num) */
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
 
-    return (0);
+    if (strcasecmp("Publish", child->key) == 0)
+      camqp_config_connection(child, /* publish = */ 1);
+    else if (strcasecmp("Subscribe", child->key) == 0)
+      camqp_config_connection(child, /* publish = */ 0);
+    else
+      WARNING("amqp plugin: Ignoring unknown config option \"%s\".",
+              child->key);
+  } /* for (ci->children_num) */
+
+  return (0);
 } /* }}} int camqp_config */
 
-void module_register (void)
-{
-    plugin_register_complex_config ("amqp", camqp_config);
-    plugin_register_shutdown ("amqp", camqp_shutdown);
+void module_register(void) {
+  plugin_register_complex_config("amqp", camqp_config);
+  plugin_register_shutdown("amqp", camqp_shutdown);
 } /* void module_register */
 
 /* vim: set sw=4 sts=4 et fdm=marker : */
@@ -31,136 +31,122 @@
 
 #include <curl/curl.h>
 
-enum server_enum
-{
-	APACHE = 0,
-	LIGHTTPD
-};
-
-struct apache_s
-{
-	int server_type;
-	char *name;
-	char *host;
-	char *url;
-	char *user;
-	char *pass;
-	_Bool verify_peer;
-	_Bool verify_host;
-	char *cacert;
-	char *ssl_ciphers;
-	char *server; /* user specific server type */
-	char *apache_buffer;
-	char apache_curl_error[CURL_ERROR_SIZE];
-	size_t apache_buffer_size;
-	size_t apache_buffer_fill;
-	int timeout;
-	CURL *curl;
+enum server_enum { APACHE = 0, LIGHTTPD };
+
+struct apache_s {
+  int server_type;
+  char *name;
+  char *host;
+  char *url;
+  char *user;
+  char *pass;
+  _Bool verify_peer;
+  _Bool verify_host;
+  char *cacert;
+  char *ssl_ciphers;
+  char *server; /* user specific server type */
+  char *apache_buffer;
+  char apache_curl_error[CURL_ERROR_SIZE];
+  size_t apache_buffer_size;
+  size_t apache_buffer_fill;
+  int timeout;
+  CURL *curl;
 }; /* apache_s */
 
 typedef struct apache_s apache_t;
 
 /* TODO: Remove this prototype */
-static int apache_read_host (user_data_t *user_data);
-
-static void apache_free (void *arg)
-{
-	apache_t *st = arg;
-
-	if (st == NULL)
-		return;
-
-	sfree (st->name);
-	sfree (st->host);
-	sfree (st->url);
-	sfree (st->user);
-	sfree (st->pass);
-	sfree (st->cacert);
-	sfree (st->ssl_ciphers);
-	sfree (st->server);
-	sfree (st->apache_buffer);
-	if (st->curl) {
-		curl_easy_cleanup(st->curl);
-		st->curl = NULL;
-	}
-	sfree (st);
+static int apache_read_host(user_data_t *user_data);
+
+static void apache_free(void *arg) {
+  apache_t *st = arg;
+
+  if (st == NULL)
+    return;
+
+  sfree(st->name);
+  sfree(st->host);
+  sfree(st->url);
+  sfree(st->user);
+  sfree(st->pass);
+  sfree(st->cacert);
+  sfree(st->ssl_ciphers);
+  sfree(st->server);
+  sfree(st->apache_buffer);
+  if (st->curl) {
+    curl_easy_cleanup(st->curl);
+    st->curl = NULL;
+  }
+  sfree(st);
 } /* apache_free */
 
-static size_t apache_curl_callback (void *buf, size_t size, size_t nmemb,
-		void *user_data)
-{
-	size_t len = size * nmemb;
-	apache_t *st;
-
-	st = user_data;
-	if (st == NULL)
-	{
-		ERROR ("apache plugin: apache_curl_callback: "
-				"user_data pointer is NULL.");
-		return (0);
-	}
-
-	if (len == 0)
-		return (len);
-
-	if ((st->apache_buffer_fill + len) >= st->apache_buffer_size)
-	{
-		char *temp;
-
-		temp = realloc (st->apache_buffer,
-				st->apache_buffer_fill + len + 1);
-		if (temp == NULL)
-		{
-			ERROR ("apache plugin: realloc failed.");
-			return (0);
-		}
-		st->apache_buffer = temp;
-		st->apache_buffer_size = st->apache_buffer_fill + len + 1;
-	}
-
-	memcpy (st->apache_buffer + st->apache_buffer_fill, (char *) buf, len);
-	st->apache_buffer_fill += len;
-	st->apache_buffer[st->apache_buffer_fill] = 0;
-
-	return (len);
+static size_t apache_curl_callback(void *buf, size_t size, size_t nmemb,
+                                   void *user_data) {
+  size_t len = size * nmemb;
+  apache_t *st;
+
+  st = user_data;
+  if (st == NULL) {
+    ERROR("apache plugin: apache_curl_callback: "
+          "user_data pointer is NULL.");
+    return (0);
+  }
+
+  if (len == 0)
+    return (len);
+
+  if ((st->apache_buffer_fill + len) >= st->apache_buffer_size) {
+    char *temp;
+
+    temp = realloc(st->apache_buffer, st->apache_buffer_fill + len + 1);
+    if (temp == NULL) {
+      ERROR("apache plugin: realloc failed.");
+      return (0);
+    }
+    st->apache_buffer = temp;
+    st->apache_buffer_size = st->apache_buffer_fill + len + 1;
+  }
+
+  memcpy(st->apache_buffer + st->apache_buffer_fill, (char *)buf, len);
+  st->apache_buffer_fill += len;
+  st->apache_buffer[st->apache_buffer_fill] = 0;
+
+  return (len);
 } /* int apache_curl_callback */
 
-static size_t apache_header_callback (void *buf, size_t size, size_t nmemb,
-		void *user_data)
-{
-	size_t len = size * nmemb;
-	apache_t *st;
-
-	st = user_data;
-	if (st == NULL)
-	{
-		ERROR ("apache plugin: apache_header_callback: "
-				"user_data pointer is NULL.");
-		return (0);
-	}
-
-	if (len == 0)
-		return (len);
-
-	/* look for the Server header */
-	if (strncasecmp (buf, "Server: ", strlen ("Server: ")) != 0)
-		return (len);
-
-	if (strstr (buf, "Apache") != NULL)
-		st->server_type = APACHE;
-	else if (strstr (buf, "lighttpd") != NULL)
-		st->server_type = LIGHTTPD;
-	else if (strstr (buf, "IBM_HTTP_Server") != NULL)
-		st->server_type = APACHE;
-	else
-	{
-		const char *hdr = buf;
-
-		hdr += strlen ("Server: ");
-		NOTICE ("apache plugin: Unknown server software: %s", hdr);
-	}
-
-	return (len);
+static size_t apache_header_callback(void *buf, size_t size, size_t nmemb,
+                                     void *user_data) {
+  size_t len = size * nmemb;
+  apache_t *st;
+
+  st = user_data;
+  if (st == NULL) {
+    ERROR("apache plugin: apache_header_callback: "
+          "user_data pointer is NULL.");
+    return (0);
+  }
+
+  if (len == 0)
+    return (len);
+
+  /* look for the Server header */
+  if (strncasecmp(buf, "Server: ", strlen("Server: ")) != 0)
+    return (len);
+
+  if (strstr(buf, "Apache") != NULL)
+    st->server_type = APACHE;
+  else if (strstr(buf, "lighttpd") != NULL)
+    st->server_type = LIGHTTPD;
+  else if (strstr(buf, "IBM_HTTP_Server") != NULL)
+    st->server_type = APACHE;
+  else {
+    const char *hdr = buf;
+
+    hdr += strlen("Server: ");
+    NOTICE("apache plugin: Unknown server software: %s", hdr);
+  }
+
+  return (len);
 } /* apache_header_callback */
 
 /* Configuration handling functiions
@@ -171,443 +157,421 @@ static size_t apache_header_callback (void *buf, size_t size, size_t nmemb,
  *   URL ...
  * </Plugin>
  */
-static int config_add (oconfig_item_t *ci)
-{
-	apache_t *st;
-	int status;
-
-	st = calloc (1, sizeof (*st));
-	if (st == NULL)
-	{
-		ERROR ("apache plugin: calloc failed.");
-		return (-1);
-	}
-
-	st->timeout = -1;
-
-	status = cf_util_get_string (ci, &st->name);
-	if (status != 0)
-	{
-		sfree (st);
-		return (status);
-	}
-	assert (st->name != NULL);
-
-	for (int i = 0; i < ci->children_num; i++)
-	{
-		oconfig_item_t *child = ci->children + i;
-
-		if (strcasecmp ("URL", child->key) == 0)
-			status = cf_util_get_string (child, &st->url);
-		else if (strcasecmp ("Host", child->key) == 0)
-			status = cf_util_get_string (child, &st->host);
-		else if (strcasecmp ("User", child->key) == 0)
-			status = cf_util_get_string (child, &st->user);
-		else if (strcasecmp ("Password", child->key) == 0)
-			status = cf_util_get_string (child, &st->pass);
-		else if (strcasecmp ("VerifyPeer", child->key) == 0)
-			status = cf_util_get_boolean (child, &st->verify_peer);
-		else if (strcasecmp ("VerifyHost", child->key) == 0)
-			status = cf_util_get_boolean (child, &st->verify_host);
-		else if (strcasecmp ("CACert", child->key) == 0)
-			status = cf_util_get_string (child, &st->cacert);
-		else if (strcasecmp ("SSLCiphers", child->key) == 0)
-			status = cf_util_get_string (child, &st->ssl_ciphers);
-		else if (strcasecmp ("Server", child->key) == 0)
-			status = cf_util_get_string (child, &st->server);
-		else if (strcasecmp ("Timeout", child->key) == 0)
-			status = cf_util_get_int (child, &st->timeout);
-		else
-		{
-			WARNING ("apache plugin: Option `%s' not allowed here.",
-					child->key);
-			status = -1;
-		}
-
-		if (status != 0)
-			break;
-	}
-
-	/* Check if struct is complete.. */
-	if ((status == 0) && (st->url == NULL))
-	{
-		ERROR ("apache plugin: Instance `%s': "
-				"No URL has been configured.",
-				st->name);
-		status = -1;
-	}
-
-	if (status == 0)
-	{
-		char callback_name[3*DATA_MAX_NAME_LEN];
-
-		ssnprintf (callback_name, sizeof (callback_name),
-				"apache/%s/%s",
-				(st->host != NULL) ? st->host : hostname_g,
-				(st->name != NULL) ? st->name : "default");
-
-		status = plugin_register_complex_read (/* group = */ NULL,
-				/* name      = */ callback_name,
-				/* callback  = */ apache_read_host,
-				/* interval  = */ 0,
-				&(user_data_t) {
-					.data = st,
-					.free_func = apache_free,
-				});
-
-	}
-
-	if (status != 0)
-	{
-		apache_free (st);
-		return (-1);
-	}
-
-	return (0);
+static int config_add(oconfig_item_t *ci) {
+  apache_t *st;
+  int status;
+
+  st = calloc(1, sizeof(*st));
+  if (st == NULL) {
+    ERROR("apache plugin: calloc failed.");
+    return (-1);
+  }
+
+  st->timeout = -1;
+
+  status = cf_util_get_string(ci, &st->name);
+  if (status != 0) {
+    sfree(st);
+    return (status);
+  }
+  assert(st->name != NULL);
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("URL", child->key) == 0)
+      status = cf_util_get_string(child, &st->url);
+    else if (strcasecmp("Host", child->key) == 0)
+      status = cf_util_get_string(child, &st->host);
+    else if (strcasecmp("User", child->key) == 0)
+      status = cf_util_get_string(child, &st->user);
+    else if (strcasecmp("Password", child->key) == 0)
+      status = cf_util_get_string(child, &st->pass);
+    else if (strcasecmp("VerifyPeer", child->key) == 0)
+      status = cf_util_get_boolean(child, &st->verify_peer);
+    else if (strcasecmp("VerifyHost", child->key) == 0)
+      status = cf_util_get_boolean(child, &st->verify_host);
+    else if (strcasecmp("CACert", child->key) == 0)
+      status = cf_util_get_string(child, &st->cacert);
+    else if (strcasecmp("SSLCiphers", child->key) == 0)
+      status = cf_util_get_string(child, &st->ssl_ciphers);
+    else if (strcasecmp("Server", child->key) == 0)
+      status = cf_util_get_string(child, &st->server);
+    else if (strcasecmp("Timeout", child->key) == 0)
+      status = cf_util_get_int(child, &st->timeout);
+    else {
+      WARNING("apache plugin: Option `%s' not allowed here.", child->key);
+      status = -1;
+    }
+
+    if (status != 0)
+      break;
+  }
+
+  /* Check if struct is complete.. */
+  if ((status == 0) && (st->url == NULL)) {
+    ERROR("apache plugin: Instance `%s': "
+          "No URL has been configured.",
+          st->name);
+    status = -1;
+  }
+
+  if (status == 0) {
+    char callback_name[3 * DATA_MAX_NAME_LEN];
+
+    ssnprintf(callback_name, sizeof(callback_name), "apache/%s/%s",
+              (st->host != NULL) ? st->host : hostname_g,
+              (st->name != NULL) ? st->name : "default");
+
+    status = plugin_register_complex_read(
+        /* group = */ NULL,
+        /* name      = */ callback_name,
+        /* callback  = */ apache_read_host,
+        /* interval  = */ 0, &(user_data_t){
+                                 .data = st, .free_func = apache_free,
+                             });
+  }
+
+  if (status != 0) {
+    apache_free(st);
+    return (-1);
+  }
+
+  return (0);
 } /* int config_add */
 
-static int config (oconfig_item_t *ci)
-{
-	int status = 0;
-
-	for (int i = 0; i < ci->children_num; i++)
-	{
-		oconfig_item_t *child = ci->children + i;
-
-		if (strcasecmp ("Instance", child->key) == 0)
-			config_add (child);
-		else
-			WARNING ("apache plugin: The configuration option "
-					"\"%s\" is not allowed here. Did you "
-					"forget to add an <Instance /> block "
-					"around the configuration?",
-					child->key);
-	} /* for (ci->children) */
-
-	return (status);
+static int config(oconfig_item_t *ci) {
+  int status = 0;
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("Instance", child->key) == 0)
+      config_add(child);
+    else
+      WARNING("apache plugin: The configuration option "
+              "\"%s\" is not allowed here. Did you "
+              "forget to add an <Instance /> block "
+              "around the configuration?",
+              child->key);
+  } /* for (ci->children) */
+
+  return (status);
 } /* int config */
 
 /* initialize curl for each host */
-static int init_host (apache_t *st) /* {{{ */
+static int init_host(apache_t *st) /* {{{ */
 {
-	assert (st->url != NULL);
-	/* (Assured by `config_add') */
-
-	if (st->curl != NULL)
-	{
-		curl_easy_cleanup (st->curl);
-		st->curl = NULL;
-	}
-
-	if ((st->curl = curl_easy_init ()) == NULL)
-	{
-		ERROR ("apache plugin: init_host: `curl_easy_init' failed.");
-		return (-1);
-	}
-
-	curl_easy_setopt (st->curl, CURLOPT_NOSIGNAL, 1L);
-	curl_easy_setopt (st->curl, CURLOPT_WRITEFUNCTION, apache_curl_callback);
-	curl_easy_setopt (st->curl, CURLOPT_WRITEDATA, st);
-
-	/* not set as yet if the user specified string doesn't match apache or
-	 * lighttpd, then ignore it. Headers will be parsed to find out the
-	 * server type */
-	st->server_type = -1;
-
-	if (st->server != NULL)
-	{
-		if (strcasecmp(st->server, "apache") == 0)
-			st->server_type = APACHE;
-		else if (strcasecmp(st->server, "lighttpd") == 0)
-			st->server_type = LIGHTTPD;
-		else if (strcasecmp(st->server, "ibm_http_server") == 0)
-			st->server_type = APACHE;
-		else
-			WARNING ("apache plugin: Unknown `Server' setting: %s",
-					st->server);
-	}
-
-	/* if not found register a header callback to determine the server_type */
-	if (st->server_type == -1)
-	{
-		curl_easy_setopt (st->curl, CURLOPT_HEADERFUNCTION, apache_header_callback);
-		curl_easy_setopt (st->curl, CURLOPT_WRITEHEADER, st);
-	}
-
-	curl_easy_setopt (st->curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
-	curl_easy_setopt (st->curl, CURLOPT_ERRORBUFFER, st->apache_curl_error);
-
-	if (st->user != NULL)
-	{
+  assert(st->url != NULL);
+  /* (Assured by `config_add') */
+
+  if (st->curl != NULL) {
+    curl_easy_cleanup(st->curl);
+    st->curl = NULL;
+  }
+
+  if ((st->curl = curl_easy_init()) == NULL) {
+    ERROR("apache plugin: init_host: `curl_easy_init' failed.");
+    return (-1);
+  }
+
+  curl_easy_setopt(st->curl, CURLOPT_NOSIGNAL, 1L);
+  curl_easy_setopt(st->curl, CURLOPT_WRITEFUNCTION, apache_curl_callback);
+  curl_easy_setopt(st->curl, CURLOPT_WRITEDATA, st);
+
+  /* not set as yet if the user specified string doesn't match apache or
+   * lighttpd, then ignore it. Headers will be parsed to find out the
+   * server type */
+  st->server_type = -1;
+
+  if (st->server != NULL) {
+    if (strcasecmp(st->server, "apache") == 0)
+      st->server_type = APACHE;
+    else if (strcasecmp(st->server, "lighttpd") == 0)
+      st->server_type = LIGHTTPD;
+    else if (strcasecmp(st->server, "ibm_http_server") == 0)
+      st->server_type = APACHE;
+    else
+      WARNING("apache plugin: Unknown `Server' setting: %s", st->server);
+  }
+
+  /* if not found register a header callback to determine the server_type */
+  if (st->server_type == -1) {
+    curl_easy_setopt(st->curl, CURLOPT_HEADERFUNCTION, apache_header_callback);
+    curl_easy_setopt(st->curl, CURLOPT_WRITEHEADER, st);
+  }
+
+  curl_easy_setopt(st->curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
+  curl_easy_setopt(st->curl, CURLOPT_ERRORBUFFER, st->apache_curl_error);
+
+  if (st->user != NULL) {
 #ifdef HAVE_CURLOPT_USERNAME
-		curl_easy_setopt (st->curl, CURLOPT_USERNAME, st->user);
-		curl_easy_setopt (st->curl, CURLOPT_PASSWORD,
-				(st->pass == NULL) ? "" : st->pass);
+    curl_easy_setopt(st->curl, CURLOPT_USERNAME, st->user);
+    curl_easy_setopt(st->curl, CURLOPT_PASSWORD,
+                     (st->pass == NULL) ? "" : st->pass);
 #else
-		static char credentials[1024];
-		int status;
-
-		status = ssnprintf (credentials, sizeof (credentials), "%s:%s",
-				st->user, (st->pass == NULL) ? "" : st->pass);
-		if ((status < 0) || ((size_t) status >= sizeof (credentials)))
-		{
-			ERROR ("apache plugin: init_host: Returning an error "
-					"because the credentials have been "
-					"truncated.");
-			curl_easy_cleanup (st->curl);
-			st->curl = NULL;
-			return (-1);
-		}
-
-		curl_easy_setopt (st->curl, CURLOPT_USERPWD, credentials);
+    static char credentials[1024];
+    int status;
+
+    status = ssnprintf(credentials, sizeof(credentials), "%s:%s", st->user,
+                       (st->pass == NULL) ? "" : st->pass);
+    if ((status < 0) || ((size_t)status >= sizeof(credentials))) {
+      ERROR("apache plugin: init_host: Returning an error "
+            "because the credentials have been "
+            "truncated.");
+      curl_easy_cleanup(st->curl);
+      st->curl = NULL;
+      return (-1);
+    }
+
+    curl_easy_setopt(st->curl, CURLOPT_USERPWD, credentials);
 #endif
-	}
+  }
 
-	curl_easy_setopt (st->curl, CURLOPT_URL, st->url);
-	curl_easy_setopt (st->curl, CURLOPT_FOLLOWLOCATION, 1L);
-	curl_easy_setopt (st->curl, CURLOPT_MAXREDIRS, 50L);
+  curl_easy_setopt(st->curl, CURLOPT_URL, st->url);
+  curl_easy_setopt(st->curl, CURLOPT_FOLLOWLOCATION, 1L);
+  curl_easy_setopt(st->curl, CURLOPT_MAXREDIRS, 50L);
 
-	curl_easy_setopt (st->curl, CURLOPT_SSL_VERIFYPEER,
-			(long) st->verify_peer);
-	curl_easy_setopt (st->curl, CURLOPT_SSL_VERIFYHOST,
-			st->verify_host ? 2L : 0L);
-	if (st->cacert != NULL)
-		curl_easy_setopt (st->curl, CURLOPT_CAINFO, st->cacert);
-	if (st->ssl_ciphers != NULL)
-		curl_easy_setopt (st->curl, CURLOPT_SSL_CIPHER_LIST,st->ssl_ciphers);
+  curl_easy_setopt(st->curl, CURLOPT_SSL_VERIFYPEER, (long)st->verify_peer);
+  curl_easy_setopt(st->curl, CURLOPT_SSL_VERIFYHOST, st->verify_host ? 2L : 0L);
+  if (st->cacert != NULL)
+    curl_easy_setopt(st->curl, CURLOPT_CAINFO, st->cacert);
+  if (st->ssl_ciphers != NULL)
+    curl_easy_setopt(st->curl, CURLOPT_SSL_CIPHER_LIST, st->ssl_ciphers);
 
 #ifdef HAVE_CURLOPT_TIMEOUT_MS
-	if (st->timeout >= 0)
-		curl_easy_setopt (st->curl, CURLOPT_TIMEOUT_MS, (long) st->timeout);
-	else
-		curl_easy_setopt (st->curl, CURLOPT_TIMEOUT_MS, (long) CDTIME_T_TO_MS(plugin_get_interval()));
+  if (st->timeout >= 0)
+    curl_easy_setopt(st->curl, CURLOPT_TIMEOUT_MS, (long)st->timeout);
+  else
+    curl_easy_setopt(st->curl, CURLOPT_TIMEOUT_MS,
+                     (long)CDTIME_T_TO_MS(plugin_get_interval()));
 #endif
 
-	return (0);
+  return (0);
 } /* }}} int init_host */
 
-static void submit_value (const char *type, const char *type_instance,
-		value_t value, apache_t *st)
-{
-	value_list_t vl = VALUE_LIST_INIT;
+static void submit_value(const char *type, const char *type_instance,
+                         value_t value, apache_t *st) {
+  value_list_t vl = VALUE_LIST_INIT;
 
-	vl.values = &value;
-	vl.values_len = 1;
+  vl.values = &value;
+  vl.values_len = 1;
 
-	if (st->host != NULL)
-		sstrncpy (vl.host, st->host, sizeof (vl.host));
+  if (st->host != NULL)
+    sstrncpy(vl.host, st->host, sizeof(vl.host));
 
-	sstrncpy (vl.plugin, "apache", sizeof (vl.plugin));
-	if (st->name != NULL)
-		sstrncpy (vl.plugin_instance, st->name,
-				sizeof (vl.plugin_instance));
+  sstrncpy(vl.plugin, "apache", sizeof(vl.plugin));
+  if (st->name != NULL)
+    sstrncpy(vl.plugin_instance, st->name, sizeof(vl.plugin_instance));
 
-	sstrncpy (vl.type, type, sizeof (vl.type));
-	if (type_instance != NULL)
-		sstrncpy (vl.type_instance, type_instance,
-				sizeof (vl.type_instance));
+  sstrncpy(vl.type, type, sizeof(vl.type));
+  if (type_instance != NULL)
+    sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
-	plugin_dispatch_values (&vl);
+  plugin_dispatch_values(&vl);
 } /* void submit_value */
 
-static void submit_derive (const char *type, const char *type_instance,
-		derive_t d, apache_t *st)
-{
-	submit_value (type, type_instance, (value_t) { .derive = d }, st);
+static void submit_derive(const char *type, const char *type_instance,
+                          derive_t d, apache_t *st) {
+  submit_value(type, type_instance, (value_t){.derive = d}, st);
 } /* void submit_derive */
 
-static void submit_gauge (const char *type, const char *type_instance,
-		gauge_t g, apache_t *st)
-{
-	submit_value (type, type_instance, (value_t) { .gauge = g }, st);
+static void submit_gauge(const char *type, const char *type_instance, gauge_t g,
+                         apache_t *st) {
+  submit_value(type, type_instance, (value_t){.gauge = g}, st);
 } /* void submit_gauge */
 
-static void submit_scoreboard (char *buf, apache_t *st)
-{
-	/*
-	 * Scoreboard Key:
-	 * "_" Waiting for Connection, "S" Starting up,
-	 * "R" Reading Request for apache and read-POST for lighttpd,
-	 * "W" Sending Reply, "K" Keepalive (read), "D" DNS Lookup,
-	 * "C" Closing connection, "L" Logging, "G" Gracefully finishing,
-	 * "I" Idle cleanup of worker, "." Open slot with no current process
-	 * Lighttpd specific legends -
-	 * "E" hard error, "." connect, "h" handle-request,
-	 * "q" request-start, "Q" request-end, "s" response-start
-	 * "S" response-end, "r" read
-	 */
-	long long open      = 0LL;
-	long long waiting   = 0LL;
-	long long starting  = 0LL;
-	long long reading   = 0LL;
-	long long sending   = 0LL;
-	long long keepalive = 0LL;
-	long long dnslookup = 0LL;
-	long long closing   = 0LL;
-	long long logging   = 0LL;
-	long long finishing = 0LL;
-	long long idle_cleanup = 0LL;
-
-	/* lighttpd specific */
-	long long hard_error     = 0LL;
-	long long lighttpd_read  = 0LL;
-	long long handle_request = 0LL;
-	long long request_start  = 0LL;
-	long long request_end    = 0LL;
-	long long response_start = 0LL;
-	long long response_end   = 0LL;
-
-	for (int i = 0; buf[i] != '\0'; i++)
-	{
-		if (buf[i] == '.') open++;
-		else if (buf[i] == '_') waiting++;
-		else if (buf[i] == 'S') starting++;
-		else if (buf[i] == 'R') reading++;
-		else if (buf[i] == 'W') sending++;
-		else if (buf[i] == 'K') keepalive++;
-		else if (buf[i] == 'D') dnslookup++;
-		else if (buf[i] == 'C') closing++;
-		else if (buf[i] == 'L') logging++;
-		else if (buf[i] == 'G') finishing++;
-		else if (buf[i] == 'I') idle_cleanup++;
-		else if (buf[i] == 'r') lighttpd_read++;
-		else if (buf[i] == 'h') handle_request++;
-		else if (buf[i] == 'E') hard_error++;
-		else if (buf[i] == 'q') request_start++;
-		else if (buf[i] == 'Q') request_end++;
-		else if (buf[i] == 's') response_start++;
-		else if (buf[i] == 'S') response_end++;
-	}
-
-	if (st->server_type == APACHE)
-	{
-		submit_gauge ("apache_scoreboard", "open"     , open, st);
-		submit_gauge ("apache_scoreboard", "waiting"  , waiting, st);
-		submit_gauge ("apache_scoreboard", "starting" , starting, st);
-		submit_gauge ("apache_scoreboard", "reading"  , reading, st);
-		submit_gauge ("apache_scoreboard", "sending"  , sending, st);
-		submit_gauge ("apache_scoreboard", "keepalive", keepalive, st);
-		submit_gauge ("apache_scoreboard", "dnslookup", dnslookup, st);
-		submit_gauge ("apache_scoreboard", "closing"  , closing, st);
-		submit_gauge ("apache_scoreboard", "logging"  , logging, st);
-		submit_gauge ("apache_scoreboard", "finishing", finishing, st);
-		submit_gauge ("apache_scoreboard", "idle_cleanup", idle_cleanup, st);
-	}
-	else
-	{
-		submit_gauge ("apache_scoreboard", "connect"       , open, st);
-		submit_gauge ("apache_scoreboard", "close"         , closing, st);
-		submit_gauge ("apache_scoreboard", "hard_error"    , hard_error, st);
-		submit_gauge ("apache_scoreboard", "read"          , lighttpd_read, st);
-		submit_gauge ("apache_scoreboard", "read_post"     , reading, st);
-		submit_gauge ("apache_scoreboard", "write"         , sending, st);
-		submit_gauge ("apache_scoreboard", "handle_request", handle_request, st);
-		submit_gauge ("apache_scoreboard", "request_start" , request_start, st);
-		submit_gauge ("apache_scoreboard", "request_end"   , request_end, st);
-		submit_gauge ("apache_scoreboard", "response_start", response_start, st);
-		submit_gauge ("apache_scoreboard", "response_end"  , response_end, st);
-	}
+static void submit_scoreboard(char *buf, apache_t *st) {
+  /*
+   * Scoreboard Key:
+   * "_" Waiting for Connection, "S" Starting up,
+   * "R" Reading Request for apache and read-POST for lighttpd,
+   * "W" Sending Reply, "K" Keepalive (read), "D" DNS Lookup,
+   * "C" Closing connection, "L" Logging, "G" Gracefully finishing,
+   * "I" Idle cleanup of worker, "." Open slot with no current process
+   * Lighttpd specific legends -
+   * "E" hard error, "." connect, "h" handle-request,
+   * "q" request-start, "Q" request-end, "s" response-start
+   * "S" response-end, "r" read
+   */
+  long long open = 0LL;
+  long long waiting = 0LL;
+  long long starting = 0LL;
+  long long reading = 0LL;
+  long long sending = 0LL;
+  long long keepalive = 0LL;
+  long long dnslookup = 0LL;
+  long long closing = 0LL;
+  long long logging = 0LL;
+  long long finishing = 0LL;
+  long long idle_cleanup = 0LL;
+
+  /* lighttpd specific */
+  long long hard_error = 0LL;
+  long long lighttpd_read = 0LL;
+  long long handle_request = 0LL;
+  long long request_start = 0LL;
+  long long request_end = 0LL;
+  long long response_start = 0LL;
+  long long response_end = 0LL;
+
+  for (int i = 0; buf[i] != '\0'; i++) {
+    if (buf[i] == '.')
+      open++;
+    else if (buf[i] == '_')
+      waiting++;
+    else if (buf[i] == 'S')
+      starting++;
+    else if (buf[i] == 'R')
+      reading++;
+    else if (buf[i] == 'W')
+      sending++;
+    else if (buf[i] == 'K')
+      keepalive++;
+    else if (buf[i] == 'D')
+      dnslookup++;
+    else if (buf[i] == 'C')
+      closing++;
+    else if (buf[i] == 'L')
+      logging++;
+    else if (buf[i] == 'G')
+      finishing++;
+    else if (buf[i] == 'I')
+      idle_cleanup++;
+    else if (buf[i] == 'r')
+      lighttpd_read++;
+    else if (buf[i] == 'h')
+      handle_request++;
+    else if (buf[i] == 'E')
+      hard_error++;
+    else if (buf[i] == 'q')
+      request_start++;
+    else if (buf[i] == 'Q')
+      request_end++;
+    else if (buf[i] == 's')
+      response_start++;
+    else if (buf[i] == 'S')
+      response_end++;
+  }
+
+  if (st->server_type == APACHE) {
+    submit_gauge("apache_scoreboard", "open", open, st);
+    submit_gauge("apache_scoreboard", "waiting", waiting, st);
+    submit_gauge("apache_scoreboard", "starting", starting, st);
+    submit_gauge("apache_scoreboard", "reading", reading, st);
+    submit_gauge("apache_scoreboard", "sending", sending, st);
+    submit_gauge("apache_scoreboard", "keepalive", keepalive, st);
+    submit_gauge("apache_scoreboard", "dnslookup", dnslookup, st);
+    submit_gauge("apache_scoreboard", "closing", closing, st);
+    submit_gauge("apache_scoreboard", "logging", logging, st);
+    submit_gauge("apache_scoreboard", "finishing", finishing, st);
+    submit_gauge("apache_scoreboard", "idle_cleanup", idle_cleanup, st);
+  } else {
+    submit_gauge("apache_scoreboard", "connect", open, st);
+    submit_gauge("apache_scoreboard", "close", closing, st);
+    submit_gauge("apache_scoreboard", "hard_error", hard_error, st);
+    submit_gauge("apache_scoreboard", "read", lighttpd_read, st);
+    submit_gauge("apache_scoreboard", "read_post", reading, st);
+    submit_gauge("apache_scoreboard", "write", sending, st);
+    submit_gauge("apache_scoreboard", "handle_request", handle_request, st);
+    submit_gauge("apache_scoreboard", "request_start", request_start, st);
+    submit_gauge("apache_scoreboard", "request_end", request_end, st);
+    submit_gauge("apache_scoreboard", "response_start", response_start, st);
+    submit_gauge("apache_scoreboard", "response_end", response_end, st);
+  }
 }
 
-static int apache_read_host (user_data_t *user_data) /* {{{ */
+static int apache_read_host(user_data_t *user_data) /* {{{ */
 {
-	char *ptr;
-	char *saveptr;
-	char *line;
-
-	char *fields[4];
-	int   fields_num;
-
-	apache_t *st;
-
-	st = user_data->data;
-
-	int status;
-
-	char *content_type;
-	static const char *text_plain = "text/plain";
-
-	assert (st->url != NULL);
-	/* (Assured by `config_add') */
-
-	if (st->curl == NULL)
-	{
-		status = init_host (st);
-		if (status != 0)
-			return (-1);
-	}
-	assert (st->curl != NULL);
-
-	st->apache_buffer_fill = 0;
-	if (curl_easy_perform (st->curl) != CURLE_OK)
-	{
-		ERROR ("apache: curl_easy_perform failed: %s",
-				st->apache_curl_error);
-		return (-1);
-	}
-
-	/* fallback - server_type to apache if not set at this time */
-	if (st->server_type == -1)
-	{
-		WARNING ("apache plugin: Unable to determine server software "
-				"automatically. Will assume Apache.");
-		st->server_type = APACHE;
-	}
-
-	status = curl_easy_getinfo (st->curl, CURLINFO_CONTENT_TYPE, &content_type);
-	if ((status == CURLE_OK) && (content_type != NULL) &&
-	    (strncasecmp (content_type, text_plain, strlen (text_plain)) != 0))
-	{
-		WARNING ("apache plugin: `Content-Type' response header is not `%s' "
-			"(received: `%s'). Expecting unparseable data. Please check `URL' "
-			"parameter (missing `?auto' suffix ?)",
-			text_plain, content_type);
-	}
-
-	ptr = st->apache_buffer;
-	saveptr = NULL;
-	while ((line = strtok_r (ptr, "\n\r", &saveptr)) != NULL)
-	{
-		ptr = NULL;
-		fields_num = strsplit (line, fields, STATIC_ARRAY_SIZE (fields));
-
-		if (fields_num == 3)
-		{
-			if ((strcmp (fields[0], "Total") == 0) && (strcmp (fields[1], "Accesses:") == 0))
-				submit_derive ("apache_requests", "", atoll (fields[2]), st);
-			else if ((strcmp (fields[0], "Total") == 0) && (strcmp (fields[1], "kBytes:") == 0))
-				submit_derive ("apache_bytes", "", 1024LL * atoll (fields[2]), st);
-		}
-		else if (fields_num == 2)
-		{
-			if (strcmp (fields[0], "Scoreboard:") == 0)
-				submit_scoreboard (fields[1], st);
-			else if ((strcmp (fields[0], "BusyServers:") == 0) /* Apache 1.* */
-					|| (strcmp (fields[0], "BusyWorkers:") == 0) /* Apache 2.* */)
-				submit_gauge ("apache_connections", NULL, atol (fields[1]), st);
-			else if ((strcmp (fields[0], "IdleServers:") == 0) /* Apache 1.x */
-					|| (strcmp (fields[0], "IdleWorkers:") == 0) /* Apache 2.x */)
-				submit_gauge ("apache_idle_workers", NULL, atol (fields[1]), st);
-		}
-	}
-
-	st->apache_buffer_fill = 0;
-
-	return (0);
+  char *ptr;
+  char *saveptr;
+  char *line;
+
+  char *fields[4];
+  int fields_num;
+
+  apache_t *st;
+
+  st = user_data->data;
+
+  int status;
+
+  char *content_type;
+  static const char *text_plain = "text/plain";
+
+  assert(st->url != NULL);
+  /* (Assured by `config_add') */
+
+  if (st->curl == NULL) {
+    status = init_host(st);
+    if (status != 0)
+      return (-1);
+  }
+  assert(st->curl != NULL);
+
+  st->apache_buffer_fill = 0;
+  if (curl_easy_perform(st->curl) != CURLE_OK) {
+    ERROR("apache: curl_easy_perform failed: %s", st->apache_curl_error);
+    return (-1);
+  }
+
+  /* fallback - server_type to apache if not set at this time */
+  if (st->server_type == -1) {
+    WARNING("apache plugin: Unable to determine server software "
+            "automatically. Will assume Apache.");
+    st->server_type = APACHE;
+  }
+
+  status = curl_easy_getinfo(st->curl, CURLINFO_CONTENT_TYPE, &content_type);
+  if ((status == CURLE_OK) && (content_type != NULL) &&
+      (strncasecmp(content_type, text_plain, strlen(text_plain)) != 0)) {
+    WARNING("apache plugin: `Content-Type' response header is not `%s' "
+            "(received: `%s'). Expecting unparseable data. Please check `URL' "
+            "parameter (missing `?auto' suffix ?)",
+            text_plain, content_type);
+  }
+
+  ptr = st->apache_buffer;
+  saveptr = NULL;
+  while ((line = strtok_r(ptr, "\n\r", &saveptr)) != NULL) {
+    ptr = NULL;
+    fields_num = strsplit(line, fields, STATIC_ARRAY_SIZE(fields));
+
+    if (fields_num == 3) {
+      if ((strcmp(fields[0], "Total") == 0) &&
+          (strcmp(fields[1], "Accesses:") == 0))
+        submit_derive("apache_requests", "", atoll(fields[2]), st);
+      else if ((strcmp(fields[0], "Total") == 0) &&
+               (strcmp(fields[1], "kBytes:") == 0))
+        submit_derive("apache_bytes", "", 1024LL * atoll(fields[2]), st);
+    } else if (fields_num == 2) {
+      if (strcmp(fields[0], "Scoreboard:") == 0)
+        submit_scoreboard(fields[1], st);
+      else if ((strcmp(fields[0], "BusyServers:") == 0) /* Apache 1.* */
+               || (strcmp(fields[0], "BusyWorkers:") == 0) /* Apache 2.* */)
+        submit_gauge("apache_connections", NULL, atol(fields[1]), st);
+      else if ((strcmp(fields[0], "IdleServers:") == 0) /* Apache 1.x */
+               || (strcmp(fields[0], "IdleWorkers:") == 0) /* Apache 2.x */)
+        submit_gauge("apache_idle_workers", NULL, atol(fields[1]), st);
+    }
+  }
+
+  st->apache_buffer_fill = 0;
+
+  return (0);
 } /* }}} int apache_read_host */
 
-static int apache_init (void) /* {{{ */
+static int apache_init(void) /* {{{ */
 {
-	/* Call this while collectd is still single-threaded to avoid
-	 * initialization issues in libgcrypt. */
-	curl_global_init (CURL_GLOBAL_SSL);
-	return (0);
+  /* Call this while collectd is still single-threaded to avoid
+   * initialization issues in libgcrypt. */
+  curl_global_init(CURL_GLOBAL_SSL);
+  return (0);
 } /* }}} int apache_init */
 
-void module_register (void)
-{
-	plugin_register_complex_config ("apache", config);
-	plugin_register_init ("apache", apache_init);
+void module_register(void) {
+  plugin_register_complex_config("apache", config);
+  plugin_register_init("apache", apache_init);
 } /* void module_register */
 
 /* vim: set sw=8 noet fdm=marker : */
@@ -26,45 +26,44 @@
 
 #include "collectd.h"
 
-#include "common.h"      /* rrd_update_file */
-#include "plugin.h"      /* plugin_register, plugin_submit */
+#include "common.h" /* rrd_update_file */
+#include "plugin.h" /* plugin_register, plugin_submit */
 
 #if HAVE_SYS_TYPES_H
-# include <sys/types.h>
+#include <sys/types.h>
 #endif
 #if HAVE_NETDB_H
-# include <netdb.h>
+#include <netdb.h>
 #endif
 
 #if HAVE_NETINET_IN_H
-# include <netinet/in.h>
+#include <netinet/in.h>
 #endif
 
 #ifndef APCUPS_SERVER_TIMEOUT
-# define APCUPS_SERVER_TIMEOUT 15.0
+#define APCUPS_SERVER_TIMEOUT 15.0
 #endif
 
 #ifndef APCUPS_DEFAULT_NODE
-# define APCUPS_DEFAULT_NODE "localhost"
+#define APCUPS_DEFAULT_NODE "localhost"
 #endif
 
 #ifndef APCUPS_DEFAULT_SERVICE
-# define APCUPS_DEFAULT_SERVICE "3551"
+#define APCUPS_DEFAULT_SERVICE "3551"
 #endif
 
 /*
  * Private data types
  */
-typedef struct
-{
-	gauge_t linev;
-	gauge_t loadpct;
-	gauge_t bcharge;
-	gauge_t timeleft;
-	gauge_t outputv;
-	gauge_t itemp;
-	gauge_t battv;
-	gauge_t linefreq;
+typedef struct {
+  gauge_t linev;
+  gauge_t loadpct;
+  gauge_t bcharge;
+  gauge_t timeleft;
+  gauge_t outputv;
+  gauge_t itemp;
+  gauge_t battv;
+  gauge_t linefreq;
 } apc_detail_t;
 
 /*
@@ -82,92 +81,82 @@ static int global_sockfd = -1;
 static int count_retries = 0;
 static int count_iterations = 0;
 
-static int net_shutdown (int *fd)
-{
-	uint16_t packet_size = 0;
+static int net_shutdown(int *fd) {
+  uint16_t packet_size = 0;
 
-	if ((fd == NULL) || (*fd < 0))
-		return (EINVAL);
+  if ((fd == NULL) || (*fd < 0))
+    return (EINVAL);
 
-	(void)swrite (*fd, (void *) &packet_size, sizeof (packet_size));
-	close (*fd);
-	*fd = -1;
+  (void)swrite(*fd, (void *)&packet_size, sizeof(packet_size));
+  close(*fd);
+  *fd = -1;
 
-	return (0);
+  return (0);
 } /* int net_shutdown */
 
 /* Close the network connection */
-static int apcups_shutdown (void)
-{
-	if (global_sockfd < 0)
-		return (0);
+static int apcups_shutdown(void) {
+  if (global_sockfd < 0)
+    return (0);
 
-	net_shutdown (&global_sockfd);
-	return (0);
+  net_shutdown(&global_sockfd);
+  return (0);
 } /* int apcups_shutdown */
 
 /*
  * Open a TCP connection to the UPS network server
  * Returns -1 on error
  * Returns socket file descriptor otherwise
  */
-static int net_open (char const *node, char const *service)
-{
-	int              sd;
-	int              status;
-	struct addrinfo *ai_return;
-	struct addrinfo *ai_list;
-
-	/* TODO: Change this to `AF_UNSPEC' if apcupsd can handle IPv6 */
-	struct addrinfo ai_hints = {
-		.ai_family = AF_INET,
-		.ai_socktype = SOCK_STREAM
-	};
-
-	status = getaddrinfo (node, service, &ai_hints, &ai_return);
-	if (status != 0)
-	{
-		char errbuf[1024];
-		INFO ("apcups plugin: getaddrinfo failed: %s",
-				(status == EAI_SYSTEM)
-				? sstrerror (errno, errbuf, sizeof (errbuf))
-				: gai_strerror (status));
-		return (-1);
-	}
-
-	/* Create socket */
-	sd = -1;
-	for (ai_list = ai_return; ai_list != NULL; ai_list = ai_list->ai_next)
-	{
-		sd = socket (ai_list->ai_family, ai_list->ai_socktype, ai_list->ai_protocol);
-		if (sd >= 0)
-			break;
-	}
-	/* `ai_list' still holds the current description of the socket.. */
-
-	if (sd < 0)
-	{
-		DEBUG ("apcups plugin: Unable to open a socket");
-		freeaddrinfo (ai_return);
-		return (-1);
-	}
-
-	status = connect (sd, ai_list->ai_addr, ai_list->ai_addrlen);
-
-	freeaddrinfo (ai_return);
-
-	if (status != 0) /* `connect(2)' failed */
-	{
-		char errbuf[1024];
-		INFO ("apcups plugin: connect failed: %s",
-				sstrerror (errno, errbuf, sizeof (errbuf)));
-		close (sd);
-		return (-1);
-	}
-
-	DEBUG ("apcups plugin: Done opening a socket %i", sd);
-
-	return (sd);
+static int net_open(char const *node, char const *service) {
+  int sd;
+  int status;
+  struct addrinfo *ai_return;
+  struct addrinfo *ai_list;
+
+  /* TODO: Change this to `AF_UNSPEC' if apcupsd can handle IPv6 */
+  struct addrinfo ai_hints = {.ai_family = AF_INET, .ai_socktype = SOCK_STREAM};
+
+  status = getaddrinfo(node, service, &ai_hints, &ai_return);
+  if (status != 0) {
+    char errbuf[1024];
+    INFO("apcups plugin: getaddrinfo failed: %s",
+         (status == EAI_SYSTEM) ? sstrerror(errno, errbuf, sizeof(errbuf))
+                                : gai_strerror(status));
+    return (-1);
+  }
+
+  /* Create socket */
+  sd = -1;
+  for (ai_list = ai_return; ai_list != NULL; ai_list = ai_list->ai_next) {
+    sd = socket(ai_list->ai_family, ai_list->ai_socktype, ai_list->ai_protocol);
+    if (sd >= 0)
+      break;
+  }
+  /* `ai_list' still holds the current description of the socket.. */
+
+  if (sd < 0) {
+    DEBUG("apcups plugin: Unable to open a socket");
+    freeaddrinfo(ai_return);
+    return (-1);
+  }
+
+  status = connect(sd, ai_list->ai_addr, ai_list->ai_addrlen);
+
+  freeaddrinfo(ai_return);
+
+  if (status != 0) /* `connect(2)' failed */
+  {
+    char errbuf[1024];
+    INFO("apcups plugin: connect failed: %s",
+         sstrerror(errno, errbuf, sizeof(errbuf)));
+    close(sd);
+    return (-1);
+  }
+
+  DEBUG("apcups plugin: Done opening a socket %i", sd);
+
+  return (sd);
 } /* int net_open */
 
 /*
@@ -179,41 +168,37 @@ static int net_open (char const *node, char const *service)
  * Returns -1 on hard end of file (i.e. network connection close)
  * Returns -2 on error
  */
-static int net_recv (int *sockfd, char *buf, int buflen)
-{
-	uint16_t packet_size;
-
-	/* get data size -- in short */
-	if (sread (*sockfd, (void *) &packet_size, sizeof (packet_size)) != 0)
-	{
-		close (*sockfd);
-		*sockfd = -1;
-		return (-1);
-	}
-
-	packet_size = ntohs (packet_size);
-	if (packet_size > buflen)
-	{
-		ERROR ("apcups plugin: Received %"PRIu16" bytes of payload "
-				"but have only %i bytes of buffer available.",
-				packet_size, buflen);
-		close (*sockfd);
-		*sockfd = -1;
-		return (-2);
-	}
-
-	if (packet_size == 0)
-		return (0);
-
-	/* now read the actual data */
-	if (sread (*sockfd, (void *) buf, packet_size) != 0)
-	{
-		close (*sockfd);
-		*sockfd = -1;
-		return (-1);
-	}
-
-	return ((int) packet_size);
+static int net_recv(int *sockfd, char *buf, int buflen) {
+  uint16_t packet_size;
+
+  /* get data size -- in short */
+  if (sread(*sockfd, (void *)&packet_size, sizeof(packet_size)) != 0) {
+    close(*sockfd);
+    *sockfd = -1;
+    return (-1);
+  }
+
+  packet_size = ntohs(packet_size);
+  if (packet_size > buflen) {
+    ERROR("apcups plugin: Received %" PRIu16 " bytes of payload "
+          "but have only %i bytes of buffer available.",
+          packet_size, buflen);
+    close(*sockfd);
+    *sockfd = -1;
+    return (-2);
+  }
+
+  if (packet_size == 0)
+    return (0);
+
+  /* now read the actual data */
+  if (sread(*sockfd, (void *)buf, packet_size) != 0) {
+    close(*sockfd);
+    *sockfd = -1;
+    return (-1);
+  }
+
+  return ((int)packet_size);
 } /* static int net_recv (int *sockfd, char *buf, int buflen) */
 
 /*
@@ -223,258 +208,236 @@ static int net_recv (int *sockfd, char *buf, int buflen)
  * Returns zero on success
  * Returns non-zero on error
  */
-static int net_send (int *sockfd, const char *buff, int len)
-{
-	uint16_t packet_size;
-
-	assert (len > 0);
-	assert (*sockfd >= 0);
-
-	/* send short containing size of data packet */
-	packet_size = htons ((uint16_t) len);
-
-	if (swrite (*sockfd, (void *) &packet_size, sizeof (packet_size)) != 0)
-	{
-		close (*sockfd);
-		*sockfd = -1;
-		return (-1);
-	}
-
-	/* send data packet */
-	if (swrite (*sockfd, (void *) buff, len) != 0)
-	{
-		close (*sockfd);
-		*sockfd = -1;
-		return (-2);
-	}
-
-	return (0);
+static int net_send(int *sockfd, const char *buff, int len) {
+  uint16_t packet_size;
+
+  assert(len > 0);
+  assert(*sockfd >= 0);
+
+  /* send short containing size of data packet */
+  packet_size = htons((uint16_t)len);
+
+  if (swrite(*sockfd, (void *)&packet_size, sizeof(packet_size)) != 0) {
+    close(*sockfd);
+    *sockfd = -1;
+    return (-1);
+  }
+
+  /* send data packet */
+  if (swrite(*sockfd, (void *)buff, len) != 0) {
+    close(*sockfd);
+    *sockfd = -1;
+    return (-2);
+  }
+
+  return (0);
 }
 
 /* Get and print status from apcupsd NIS server */
-static int apc_query_server (char const *node, char const *service,
-		apc_detail_t *apcups_detail)
-{
-	int     n;
-	char    recvline[1024];
-	char   *tokptr;
-	char   *toksaveptr;
-	_Bool retry = 1;
-	int status;
+static int apc_query_server(char const *node, char const *service,
+                            apc_detail_t *apcups_detail) {
+  int n;
+  char recvline[1024];
+  char *tokptr;
+  char *toksaveptr;
+  _Bool retry = 1;
+  int status;
 
 #if APCMAIN
-# define PRINT_VALUE(name, val) printf("  Found property: name = %s; value = %f;\n", name, val)
+#define PRINT_VALUE(name, val)                                                 \
+  printf("  Found property: name = %s; value = %f;\n", name, val)
 #else
-# define PRINT_VALUE(name, val) /**/
+#define PRINT_VALUE(name, val) /**/
 #endif
 
-	while (retry)
-	{
-		if (global_sockfd < 0)
-		{
-			global_sockfd = net_open (node, service);
-			if (global_sockfd < 0)
-			{
-				ERROR ("apcups plugin: Connecting to the "
-						"apcupsd failed.");
-				return (-1);
-			}
-		}
-
-
-		status = net_send (&global_sockfd, "status", strlen ("status"));
-		if (status != 0)
-		{
-			/* net_send is closing the socket on error. */
-			assert (global_sockfd < 0);
-			if (retry)
-			{
-				retry = 0;
-				count_retries++;
-				continue;
-			}
-
-			ERROR ("apcups plugin: Writing to the socket failed.");
-			return (-1);
-		}
-
-		break;
-	} /* while (retry) */
-
-        /* When collectd's collection interval is larger than apcupsd's
-         * timeout, we would have to retry / re-connect each iteration. Try to
-         * detect this situation and shut down the socket gracefully in that
-         * case. Otherwise, keep the socket open to avoid overhead. */
-	count_iterations++;
-	if ((count_iterations == 10) && (count_retries > 2))
-	{
-		NOTICE ("apcups plugin: There have been %i retries in the "
-				"first %i iterations. Will close the socket "
-				"in future iterations.",
-				count_retries, count_iterations);
-		conf_persistent_conn = 0;
-	}
-
-	while ((n = net_recv (&global_sockfd, recvline, sizeof (recvline) - 1)) > 0)
-	{
-		assert ((size_t)n < sizeof (recvline));
-		recvline[n] = 0;
+  while (retry) {
+    if (global_sockfd < 0) {
+      global_sockfd = net_open(node, service);
+      if (global_sockfd < 0) {
+        ERROR("apcups plugin: Connecting to the "
+              "apcupsd failed.");
+        return (-1);
+      }
+    }
+
+    status = net_send(&global_sockfd, "status", strlen("status"));
+    if (status != 0) {
+      /* net_send is closing the socket on error. */
+      assert(global_sockfd < 0);
+      if (retry) {
+        retry = 0;
+        count_retries++;
+        continue;
+      }
+
+      ERROR("apcups plugin: Writing to the socket failed.");
+      return (-1);
+    }
+
+    break;
+  } /* while (retry) */
+
+  /* When collectd's collection interval is larger than apcupsd's
+   * timeout, we would have to retry / re-connect each iteration. Try to
+   * detect this situation and shut down the socket gracefully in that
+   * case. Otherwise, keep the socket open to avoid overhead. */
+  count_iterations++;
+  if ((count_iterations == 10) && (count_retries > 2)) {
+    NOTICE("apcups plugin: There have been %i retries in the "
+           "first %i iterations. Will close the socket "
+           "in future iterations.",
+           count_retries, count_iterations);
+    conf_persistent_conn = 0;
+  }
+
+  while ((n = net_recv(&global_sockfd, recvline, sizeof(recvline) - 1)) > 0) {
+    assert((size_t)n < sizeof(recvline));
+    recvline[n] = 0;
 #if APCMAIN
-		printf ("net_recv = `%s';\n", recvline);
+    printf("net_recv = `%s';\n", recvline);
 #endif /* if APCMAIN */
 
-		toksaveptr = NULL;
-		tokptr = strtok_r (recvline, " :\t", &toksaveptr);
-		while (tokptr != NULL)
-		{
-			char *key = tokptr;
-			if ((tokptr = strtok_r (NULL, " :\t", &toksaveptr)) == NULL)
-				continue;
-
-			gauge_t value;
-			if (strtogauge (tokptr, &value) != 0)
-				continue;
-
-			PRINT_VALUE (key, value);
-
-			if (strcmp ("LINEV", key) == 0)
-				apcups_detail->linev = value;
-			else if (strcmp ("BATTV", key) == 0)
-				apcups_detail->battv = value;
-			else if (strcmp ("ITEMP", key) == 0)
-				apcups_detail->itemp = value;
-			else if (strcmp ("LOADPCT", key) == 0)
-				apcups_detail->loadpct = value;
-			else if (strcmp ("BCHARGE", key) == 0)
-				apcups_detail->bcharge = value;
-			else if (strcmp ("OUTPUTV", key) == 0)
-				apcups_detail->outputv = value;
-			else if (strcmp ("LINEFREQ", key) == 0)
-				apcups_detail->linefreq = value;
-			else if (strcmp ("TIMELEFT", key) == 0)
-			{
-				/* Convert minutes to seconds if requested by
-				 * the user. */
-				if (conf_report_seconds)
-					value *= 60.0;
-				apcups_detail->timeleft = value;
-			}
-
-			tokptr = strtok_r (NULL, ":", &toksaveptr);
-		} /* while (tokptr != NULL) */
-	}
-	status = errno; /* save errno, net_shutdown() may re-set it. */
-
-	if (!conf_persistent_conn)
-		net_shutdown (&global_sockfd);
-
-	if (n < 0)
-	{
-		char errbuf[1024];
-		ERROR ("apcups plugin: Reading from socket failed: %s",
-				sstrerror (status, errbuf, sizeof (errbuf)));
-		return (-1);
-	}
-
-	return (0);
+    toksaveptr = NULL;
+    tokptr = strtok_r(recvline, " :\t", &toksaveptr);
+    while (tokptr != NULL) {
+      char *key = tokptr;
+      if ((tokptr = strtok_r(NULL, " :\t", &toksaveptr)) == NULL)
+        continue;
+
+      gauge_t value;
+      if (strtogauge(tokptr, &value) != 0)
+        continue;
+
+      PRINT_VALUE(key, value);
+
+      if (strcmp("LINEV", key) == 0)
+        apcups_detail->linev = value;
+      else if (strcmp("BATTV", key) == 0)
+        apcups_detail->battv = value;
+      else if (strcmp("ITEMP", key) == 0)
+        apcups_detail->itemp = value;
+      else if (strcmp("LOADPCT", key) == 0)
+        apcups_detail->loadpct = value;
+      else if (strcmp("BCHARGE", key) == 0)
+        apcups_detail->bcharge = value;
+      else if (strcmp("OUTPUTV", key) == 0)
+        apcups_detail->outputv = value;
+      else if (strcmp("LINEFREQ", key) == 0)
+        apcups_detail->linefreq = value;
+      else if (strcmp("TIMELEFT", key) == 0) {
+        /* Convert minutes to seconds if requested by
+         * the user. */
+        if (conf_report_seconds)
+          value *= 60.0;
+        apcups_detail->timeleft = value;
+      }
+
+      tokptr = strtok_r(NULL, ":", &toksaveptr);
+    } /* while (tokptr != NULL) */
+  }
+  status = errno; /* save errno, net_shutdown() may re-set it. */
+
+  if (!conf_persistent_conn)
+    net_shutdown(&global_sockfd);
+
+  if (n < 0) {
+    char errbuf[1024];
+    ERROR("apcups plugin: Reading from socket failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    return (-1);
+  }
+
+  return (0);
 }
 
-static int apcups_config (oconfig_item_t *ci)
-{
-	_Bool persistent_conn_set = 0;
-
-	for (int i = 0; i < ci->children_num; i++)
-	{
-		oconfig_item_t *child = ci->children + i;
-
-		if (strcasecmp (child->key, "Host") == 0)
-			cf_util_get_string (child, &conf_node);
-		else if (strcasecmp (child->key, "Port") == 0)
-			cf_util_get_service (child, &conf_service);
-		else if (strcasecmp (child->key, "ReportSeconds") == 0)
-			cf_util_get_boolean (child, &conf_report_seconds);
-		else if (strcasecmp (child->key, "PersistentConnection") == 0) {
-			cf_util_get_boolean (child, &conf_persistent_conn);
-			persistent_conn_set = 1;
-		}
-		else
-			ERROR ("apcups plugin: Unknown config option \"%s\".", child->key);
-	}
-
-	if (!persistent_conn_set) {
-		double interval = CDTIME_T_TO_DOUBLE(plugin_get_interval());
-		if (interval > APCUPS_SERVER_TIMEOUT) {
-			NOTICE ("apcups plugin: Plugin poll interval set to %.3f seconds. "
-				"Apcupsd NIS socket timeout is %.3f seconds, "
-				"PersistentConnection disabled by default.",
-				interval, APCUPS_SERVER_TIMEOUT);
-			conf_persistent_conn = 0;
-		}
-	}
-
-	return (0);
+static int apcups_config(oconfig_item_t *ci) {
+  _Bool persistent_conn_set = 0;
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp(child->key, "Host") == 0)
+      cf_util_get_string(child, &conf_node);
+    else if (strcasecmp(child->key, "Port") == 0)
+      cf_util_get_service(child, &conf_service);
+    else if (strcasecmp(child->key, "ReportSeconds") == 0)
+      cf_util_get_boolean(child, &conf_report_seconds);
+    else if (strcasecmp(child->key, "PersistentConnection") == 0) {
+      cf_util_get_boolean(child, &conf_persistent_conn);
+      persistent_conn_set = 1;
+    } else
+      ERROR("apcups plugin: Unknown config option \"%s\".", child->key);
+  }
+
+  if (!persistent_conn_set) {
+    double interval = CDTIME_T_TO_DOUBLE(plugin_get_interval());
+    if (interval > APCUPS_SERVER_TIMEOUT) {
+      NOTICE("apcups plugin: Plugin poll interval set to %.3f seconds. "
+             "Apcupsd NIS socket timeout is %.3f seconds, "
+             "PersistentConnection disabled by default.",
+             interval, APCUPS_SERVER_TIMEOUT);
+      conf_persistent_conn = 0;
+    }
+  }
+
+  return (0);
 } /* int apcups_config */
 
-static void apc_submit_generic (const char *type, const char *type_inst, gauge_t value)
-{
-	if (isnan (value))
-		return;
+static void apc_submit_generic(const char *type, const char *type_inst,
+                               gauge_t value) {
+  if (isnan(value))
+    return;
 
-	value_list_t vl = VALUE_LIST_INIT;
-	vl.values = &(value_t) { .gauge = value };
-	vl.values_len = 1;
-	sstrncpy (vl.plugin, "apcups", sizeof (vl.plugin));
-	sstrncpy (vl.type, type, sizeof (vl.type));
-	sstrncpy (vl.type_instance, type_inst, sizeof (vl.type_instance));
+  value_list_t vl = VALUE_LIST_INIT;
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
+  sstrncpy(vl.plugin, "apcups", sizeof(vl.plugin));
+  sstrncpy(vl.type, type, sizeof(vl.type));
+  sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
-	plugin_dispatch_values (&vl);
+  plugin_dispatch_values(&vl);
 }
 
-static void apc_submit (apc_detail_t const *apcups_detail)
-{
-	apc_submit_generic ("voltage",    "input",   apcups_detail->linev);
-	apc_submit_generic ("voltage",    "output",  apcups_detail->outputv);
-	apc_submit_generic ("voltage",    "battery", apcups_detail->battv);
-	apc_submit_generic ("charge",     "",        apcups_detail->bcharge);
-	apc_submit_generic ("percent",    "load",    apcups_detail->loadpct);
-	apc_submit_generic ("timeleft",   "",        apcups_detail->timeleft);
-	apc_submit_generic ("temperature", "",       apcups_detail->itemp);
-	apc_submit_generic ("frequency",  "input",   apcups_detail->linefreq);
+static void apc_submit(apc_detail_t const *apcups_detail) {
+  apc_submit_generic("voltage", "input", apcups_detail->linev);
+  apc_submit_generic("voltage", "output", apcups_detail->outputv);
+  apc_submit_generic("voltage", "battery", apcups_detail->battv);
+  apc_submit_generic("charge", "", apcups_detail->bcharge);
+  apc_submit_generic("percent", "load", apcups_detail->loadpct);
+  apc_submit_generic("timeleft", "", apcups_detail->timeleft);
+  apc_submit_generic("temperature", "", apcups_detail->itemp);
+  apc_submit_generic("frequency", "input", apcups_detail->linefreq);
 }
 
-static int apcups_read (void)
-{
-	apc_detail_t apcups_detail = {
-		.linev    = NAN,
-		.outputv  = NAN,
-		.battv    = NAN,
-		.loadpct  = NAN,
-		.bcharge  = NAN,
-		.timeleft = NAN,
-		.itemp    = NAN,
-		.linefreq = NAN,
-	};
-
-	int status = apc_query_server (conf_node == NULL
-			? APCUPS_DEFAULT_NODE
-			: conf_node,
-			conf_service, &apcups_detail);
-	if (status != 0)
-	{
-		DEBUG ("apcups plugin: apc_query_server (\"%s\", \"%s\") = %d",
-				conf_node == NULL ? APCUPS_DEFAULT_NODE : conf_node,
-				conf_service, status);
-		return (status);
-	}
-
-	apc_submit (&apcups_detail);
-
-	return (0);
+static int apcups_read(void) {
+  apc_detail_t apcups_detail = {
+      .linev = NAN,
+      .outputv = NAN,
+      .battv = NAN,
+      .loadpct = NAN,
+      .bcharge = NAN,
+      .timeleft = NAN,
+      .itemp = NAN,
+      .linefreq = NAN,
+  };
+
+  int status =
+      apc_query_server(conf_node == NULL ? APCUPS_DEFAULT_NODE : conf_node,
+                       conf_service, &apcups_detail);
+  if (status != 0) {
+    DEBUG("apcups plugin: apc_query_server (\"%s\", \"%s\") = %d",
+          conf_node == NULL ? APCUPS_DEFAULT_NODE : conf_node, conf_service,
+          status);
+    return (status);
+  }
+
+  apc_submit(&apcups_detail);
+
+  return (0);
 } /* apcups_read */
 
-void module_register (void)
-{
-	plugin_register_complex_config ("apcups", apcups_config);
-	plugin_register_read ("apcups", apcups_read);
-	plugin_register_shutdown ("apcups", apcups_shutdown);
+void module_register(void) {
+  plugin_register_complex_config("apcups", apcups_config);
+  plugin_register_read("apcups", apcups_read);
+  plugin_register_shutdown("apcups", apcups_shutdown);
 } /* void module_register */
@@ -30,206 +30,168 @@
 #include "plugin.h"
 
 #if HAVE_CTYPE_H
-#  include <ctype.h>
+#include <ctype.h>
 #endif
 
 #if HAVE_MACH_MACH_TYPES_H
-#  include <mach/mach_types.h>
+#include <mach/mach_types.h>
 #endif
 #if HAVE_MACH_MACH_INIT_H
-#  include <mach/mach_init.h>
+#include <mach/mach_init.h>
 #endif
 #if HAVE_MACH_MACH_ERROR_H
-#  include <mach/mach_error.h>
+#include <mach/mach_error.h>
 #endif
 #if HAVE_MACH_MACH_PORT_H
-#  include <mach/mach_port.h>
+#include <mach/mach_port.h>
 #endif
 #if HAVE_COREFOUNDATION_COREFOUNDATION_H
-#  include <CoreFoundation/CoreFoundation.h>
+#include <CoreFoundation/CoreFoundation.h>
 #endif
 #if HAVE_IOKIT_IOKITLIB_H
-#  include <IOKit/IOKitLib.h>
+#include <IOKit/IOKitLib.h>
 #endif
 #if HAVE_IOKIT_IOTYPES_H
-#  include <IOKit/IOTypes.h>
+#include <IOKit/IOTypes.h>
 #endif
 
 static mach_port_t io_master_port = MACH_PORT_NULL;
 
-static int as_init (void)
-{
-	kern_return_t status;
-
-	if (io_master_port != MACH_PORT_NULL)
-	{
-		mach_port_deallocate (mach_task_self (),
-				io_master_port);
-		io_master_port = MACH_PORT_NULL;
-	}
-
-	status = IOMasterPort (MACH_PORT_NULL, &io_master_port);
-	if (status != kIOReturnSuccess)
-	{
-		ERROR ("IOMasterPort failed: %s",
-				mach_error_string (status));
-		io_master_port = MACH_PORT_NULL;
-		return (-1);
-	}
-
-	return (0);
+static int as_init(void) {
+  kern_return_t status;
+
+  if (io_master_port != MACH_PORT_NULL) {
+    mach_port_deallocate(mach_task_self(), io_master_port);
+    io_master_port = MACH_PORT_NULL;
+  }
+
+  status = IOMasterPort(MACH_PORT_NULL, &io_master_port);
+  if (status != kIOReturnSuccess) {
+    ERROR("IOMasterPort failed: %s", mach_error_string(status));
+    io_master_port = MACH_PORT_NULL;
+    return (-1);
+  }
+
+  return (0);
 }
 
-static void as_submit (const char *type, const char *type_instance,
-		double val)
-{
-	value_list_t vl = VALUE_LIST_INIT;
+static void as_submit(const char *type, const char *type_instance, double val) {
+  value_list_t vl = VALUE_LIST_INIT;
 
-	vl.values = &(value_t) { .gauge = val };
-	vl.values_len = 1;
-	sstrncpy (vl.plugin, "apple_sensors", sizeof (vl.plugin));
-	sstrncpy (vl.type, type, sizeof (vl.type));
-	sstrncpy (vl.type_instance, type_instance, sizeof (vl.type_instance));
+  vl.values = &(value_t){.gauge = val};
+  vl.values_len = 1;
+  sstrncpy(vl.plugin, "apple_sensors", sizeof(vl.plugin));
+  sstrncpy(vl.type, type, sizeof(vl.type));
+  sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
-	plugin_dispatch_values (&vl);
+  plugin_dispatch_values(&vl);
 }
 
-static int as_read (void)
-{
-	kern_return_t   status;
-	io_iterator_t   iterator;
-	io_object_t     io_obj;
-	CFMutableDictionaryRef prop_dict;
-	CFTypeRef       property;
-
-	char   type[128];
-	char   inst[128];
-	int    value_int;
-	double value_double;
-	if (!io_master_port || (io_master_port == MACH_PORT_NULL))
-		return (-1);
-
-	status = IOServiceGetMatchingServices (io_master_port,
-		       	IOServiceNameMatching("IOHWSensor"),
-		       	&iterator);
-	if (status != kIOReturnSuccess)
-       	{
-		ERROR ("IOServiceGetMatchingServices failed: %s",
-				mach_error_string (status));
-		return (-1);
-	}
-
-	while ((io_obj = IOIteratorNext (iterator)))
-	{
-		prop_dict = NULL;
-		status = IORegistryEntryCreateCFProperties (io_obj,
-				&prop_dict,
-				kCFAllocatorDefault,
-				kNilOptions);
-		if (status != kIOReturnSuccess)
-		{
-			DEBUG ("IORegistryEntryCreateCFProperties failed: %s",
-					mach_error_string (status));
-			continue;
-		}
-
-		/* Copy the sensor type. */
-		property = NULL;
-		if (!CFDictionaryGetValueIfPresent (prop_dict,
-					CFSTR ("type"),
-					&property))
-			continue;
-		if (CFGetTypeID (property) != CFStringGetTypeID ())
-			continue;
-		if (!CFStringGetCString (property,
-					type, sizeof (type),
-					kCFStringEncodingASCII))
-			continue;
-		type[sizeof (type) - 1] = '\0';
-
-		/* Copy the sensor location. This will be used as `instance'. */
-		property = NULL;
-		if (!CFDictionaryGetValueIfPresent (prop_dict,
-					CFSTR ("location"),
-					&property))
-			continue;
-		if (CFGetTypeID (property) != CFStringGetTypeID ())
-			continue;
-		if (!CFStringGetCString (property,
-					inst, sizeof (inst),
-					kCFStringEncodingASCII))
-			continue;
-		inst[sizeof (inst) - 1] = '\0';
-		for (int i = 0; i < 128; i++)
-		{
-			if (inst[i] == '\0')
-				break;
-			else if (isalnum (inst[i]))
-				inst[i] = (char) tolower (inst[i]);
-			else
-				inst[i] = '_';
-		}
-
-		/* Get the actual value. Some computation, based on the `type'
-		 * is neccessary. */
-		property = NULL;
-		if (!CFDictionaryGetValueIfPresent (prop_dict,
-					CFSTR ("current-value"),
-					&property))
-			continue;
-		if (CFGetTypeID (property) != CFNumberGetTypeID ())
-			continue;
-		if (!CFNumberGetValue (property,
-				       	kCFNumberIntType,
-				       	&value_int))
-			continue;
-
-		/* Found e.g. in the 1.5GHz PowerBooks */
-		if (strcmp (type, "temperature") == 0)
-		{
-			value_double = ((double) value_int) / 65536.0;
-			sstrncpy (type, "temperature", sizeof (type));
-		}
-		else if (strcmp (type, "temp") == 0)
-		{
-			value_double = ((double) value_int) / 10.0;
-			sstrncpy (type, "temperature", sizeof (type));
-		}
-		else if (strcmp (type, "fanspeed") == 0)
-		{
-			value_double = ((double) value_int) / 65536.0;
-			sstrncpy (type, "fanspeed", sizeof (type));
-		}
-		else if (strcmp (type, "voltage") == 0)
-		{
-			/* Leave this to the battery plugin. */
-			continue;
-		}
-		else if (strcmp (type, "adc") == 0)
-		{
-			value_double = ((double) value_int) / 10.0;
-			sstrncpy (type, "fanspeed", sizeof (type));
-		}
-		else
-		{
-			DEBUG ("apple_sensors: Read unknown sensor type: %s",
-					type);
-			value_double = (double) value_int;
-		}
-
-		as_submit (type, inst, value_double);
-
-		CFRelease (prop_dict);
-		IOObjectRelease (io_obj);
-	} /* while (iterator) */
-
-	IOObjectRelease (iterator);
-
-	return (0);
+static int as_read(void) {
+  kern_return_t status;
+  io_iterator_t iterator;
+  io_object_t io_obj;
+  CFMutableDictionaryRef prop_dict;
+  CFTypeRef property;
+
+  char type[128];
+  char inst[128];
+  int value_int;
+  double value_double;
+  if (!io_master_port || (io_master_port == MACH_PORT_NULL))
+    return (-1);
+
+  status = IOServiceGetMatchingServices(
+      io_master_port, IOServiceNameMatching("IOHWSensor"), &iterator);
+  if (status != kIOReturnSuccess) {
+    ERROR("IOServiceGetMatchingServices failed: %s", mach_error_string(status));
+    return (-1);
+  }
+
+  while ((io_obj = IOIteratorNext(iterator))) {
+    prop_dict = NULL;
+    status = IORegistryEntryCreateCFProperties(
+        io_obj, &prop_dict, kCFAllocatorDefault, kNilOptions);
+    if (status != kIOReturnSuccess) {
+      DEBUG("IORegistryEntryCreateCFProperties failed: %s",
+            mach_error_string(status));
+      continue;
+    }
+
+    /* Copy the sensor type. */
+    property = NULL;
+    if (!CFDictionaryGetValueIfPresent(prop_dict, CFSTR("type"), &property))
+      continue;
+    if (CFGetTypeID(property) != CFStringGetTypeID())
+      continue;
+    if (!CFStringGetCString(property, type, sizeof(type),
+                            kCFStringEncodingASCII))
+      continue;
+    type[sizeof(type) - 1] = '\0';
+
+    /* Copy the sensor location. This will be used as `instance'. */
+    property = NULL;
+    if (!CFDictionaryGetValueIfPresent(prop_dict, CFSTR("location"), &property))
+      continue;
+    if (CFGetTypeID(property) != CFStringGetTypeID())
+      continue;
+    if (!CFStringGetCString(property, inst, sizeof(inst),
+                            kCFStringEncodingASCII))
+      continue;
+    inst[sizeof(inst) - 1] = '\0';
+    for (int i = 0; i < 128; i++) {
+      if (inst[i] == '\0')
+        break;
+      else if (isalnum(inst[i]))
+        inst[i] = (char)tolower(inst[i]);
+      else
+        inst[i] = '_';
+    }
+
+    /* Get the actual value. Some computation, based on the `type'
+     * is neccessary. */
+    property = NULL;
+    if (!CFDictionaryGetValueIfPresent(prop_dict, CFSTR("current-value"),
+                                       &property))
+      continue;
+    if (CFGetTypeID(property) != CFNumberGetTypeID())
+      continue;
+    if (!CFNumberGetValue(property, kCFNumberIntType, &value_int))
+      continue;
+
+    /* Found e.g. in the 1.5GHz PowerBooks */
+    if (strcmp(type, "temperature") == 0) {
+      value_double = ((double)value_int) / 65536.0;
+      sstrncpy(type, "temperature", sizeof(type));
+    } else if (strcmp(type, "temp") == 0) {
+      value_double = ((double)value_int) / 10.0;
+      sstrncpy(type, "temperature", sizeof(type));
+    } else if (strcmp(type, "fanspeed") == 0) {
+      value_double = ((double)value_int) / 65536.0;
+      sstrncpy(type, "fanspeed", sizeof(type));
+    } else if (strcmp(type, "voltage") == 0) {
+      /* Leave this to the battery plugin. */
+      continue;
+    } else if (strcmp(type, "adc") == 0) {
+      value_double = ((double)value_int) / 10.0;
+      sstrncpy(type, "fanspeed", sizeof(type));
+    } else {
+      DEBUG("apple_sensors: Read unknown sensor type: %s", type);
+      value_double = (double)value_int;
+    }
+
+    as_submit(type, inst, value_double);
+
+    CFRelease(prop_dict);
+    IOObjectRelease(io_obj);
+  } /* while (iterator) */
+
+  IOObjectRelease(iterator);
+
+  return (0);
 } /* int as_read */
 
-void module_register (void)
-{
-	plugin_register_init ("apple_sensors", as_init);
-	plugin_register_read ("apple_sensors", as_read);
+void module_register(void) {
+  plugin_register_init("apple_sensors", as_init);
+  plugin_register_read("apple_sensors", as_read);
 } /* void module_register */
@@ -32,155 +32,134 @@
 /* Default values for contacting daemon */
 static char *conf_device = NULL;
 
-static int aquaero_config (oconfig_item_t *ci)
-{
-	for (int i = 0; i < ci->children_num; i++)
-	{
-		oconfig_item_t *child = ci->children + i;
-
-		if (strcasecmp ("Device", child->key))
-			cf_util_get_string (child, &conf_device);
-		else
-		{
-			ERROR ("aquaero plugin: Unknown config option \"%s\".",
-					child->key);
-		}
-	}
-
-	return (0);
+static int aquaero_config(oconfig_item_t *ci) {
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("Device", child->key))
+      cf_util_get_string(child, &conf_device);
+    else {
+      ERROR("aquaero plugin: Unknown config option \"%s\".", child->key);
+    }
+  }
+
+  return (0);
 }
 
-static int aquaero_shutdown (void)
-{
-	libaquaero5_exit();
-	return (0);
+static int aquaero_shutdown(void) {
+  libaquaero5_exit();
+  return (0);
 } /* int aquaero_shutdown */
 
-static void aquaero_submit (const char *type, const char *type_instance,
-		double value)
-{
-	const char *instance = conf_device?conf_device:"default";
-	value_list_t vl = VALUE_LIST_INIT;
+static void aquaero_submit(const char *type, const char *type_instance,
+                           double value) {
+  const char *instance = conf_device ? conf_device : "default";
+  value_list_t vl = VALUE_LIST_INIT;
 
-	/* Don't report undefined values. */
-	if (value == AQ5_FLOAT_UNDEF)
-		return;
+  /* Don't report undefined values. */
+  if (value == AQ5_FLOAT_UNDEF)
+    return;
 
-	vl.values = &(value_t) { .gauge = value };
-	vl.values_len = 1;
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
 
-	sstrncpy (vl.plugin, "aquaero", sizeof (vl.plugin));
-	sstrncpy (vl.plugin_instance, instance, sizeof (vl.plugin_instance));
-	sstrncpy (vl.type, type, sizeof (vl.type));
-	sstrncpy (vl.type_instance, type_instance, sizeof (vl.type_instance));
+  sstrncpy(vl.plugin, "aquaero", sizeof(vl.plugin));
+  sstrncpy(vl.plugin_instance, instance, sizeof(vl.plugin_instance));
+  sstrncpy(vl.type, type, sizeof(vl.type));
+  sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
-	plugin_dispatch_values (&vl);
+  plugin_dispatch_values(&vl);
 } /* int aquaero_submit */
 
 /* aquaero_submit_array submits every value of a given array of values */
-static void aquaero_submit_array (const char *type,
-		const char *type_instance_prefix, double *value_array, int len)
-{
-	char type_instance[DATA_MAX_NAME_LEN];
-
-	for (int i = 0; i < len; i++)
-	{
-		if (value_array[i] == AQ5_FLOAT_UNDEF)
-			continue;
-
-		snprintf (type_instance, sizeof (type_instance), "%s%d",
-				type_instance_prefix, i + 1);
-		aquaero_submit (type, type_instance, value_array[i]);
-	}
+static void aquaero_submit_array(const char *type,
+                                 const char *type_instance_prefix,
+                                 double *value_array, int len) {
+  char type_instance[DATA_MAX_NAME_LEN];
+
+  for (int i = 0; i < len; i++) {
+    if (value_array[i] == AQ5_FLOAT_UNDEF)
+      continue;
+
+    snprintf(type_instance, sizeof(type_instance), "%s%d", type_instance_prefix,
+             i + 1);
+    aquaero_submit(type, type_instance, value_array[i]);
+  }
 }
 
-static int aquaero_read (void)
-{
-	aq5_data_t aq_data;
-	aq5_settings_t aq_sett;
-	char *err_msg = NULL;
-	char type_instance[DATA_MAX_NAME_LEN];
-
-	if (libaquaero5_poll(conf_device, &aq_data, &err_msg) < 0)
-	{
-		char errbuf[1024];
-		ERROR ("aquaero plugin: Failed to poll device \"%s\": %s (%s)",
-				conf_device ? conf_device : "default", err_msg,
-				sstrerror (errno, errbuf, sizeof (errbuf)));
-		return (-1);
-	}
-
-	if (libaquaero5_getsettings(conf_device, &aq_sett, &err_msg) < 0)
-	{
-		char errbuf[1024];
-		ERROR ("aquaero plugin: Failed to get settings "
-				"for device \"%s\": %s (%s)",
-				conf_device ? conf_device : "default", err_msg,
-				sstrerror (errno, errbuf, sizeof (errbuf)));
-		return (-1);
-	}
-
-	/* CPU Temperature sensor */
-	aquaero_submit("temperature", "cpu", aq_data.cpu_temp[0]);
-
-	/* Temperature sensors */
-	aquaero_submit_array("temperature", "sensor", aq_data.temp,
-			AQ5_NUM_TEMP);
-
-	/* Virtual temperature sensors */
-	aquaero_submit_array("temperature", "virtual", aq_data.vtemp,
-			AQ5_NUM_VIRT_SENSORS);
-
-	/* Software temperature sensors */
-	aquaero_submit_array("temperature", "software", aq_data.stemp,
-			AQ5_NUM_SOFT_SENSORS);
-
-	/* Other temperature sensors */
-	aquaero_submit_array("temperature", "other", aq_data.otemp,
-			AQ5_NUM_OTHER_SENSORS);
-
-	/* Fans */
-	for (int i = 0; i < AQ5_NUM_FAN; i++)
-	{
-		if ((aq_sett.fan_data_source[i] == NONE)
-				|| (aq_data.fan_vrm_temp[i] != AQ5_FLOAT_UNDEF))
-			continue;
-
-		snprintf (type_instance, sizeof (type_instance),
-				"fan%d", i + 1);
-
-		aquaero_submit ("fanspeed", type_instance,
-				aq_data.fan_rpm[i]);
-		aquaero_submit ("percent", type_instance,
-				aq_data.fan_duty[i]);
-		aquaero_submit ("voltage", type_instance,
-				aq_data.fan_voltage[i]);
-		aquaero_submit ("current", type_instance,
-				aq_data.fan_current[i]);
-
-		/* Report the voltage reglator module (VRM) temperature with a
-		 * different type instance. */
-		snprintf (type_instance, sizeof (type_instance),
-				"fan%d-vrm", i + 1);
-		aquaero_submit ("temperature", type_instance,
-				aq_data.fan_vrm_temp[i]);
-	}
-
-	/* Flow sensors */
-	aquaero_submit_array("flow", "sensor", aq_data.flow, AQ5_NUM_FLOW);
-
-	/* Liquid level */
-	aquaero_submit_array("percent", "waterlevel",
-			aq_data.level, AQ5_NUM_LEVEL);
-
-	return (0);
+static int aquaero_read(void) {
+  aq5_data_t aq_data;
+  aq5_settings_t aq_sett;
+  char *err_msg = NULL;
+  char type_instance[DATA_MAX_NAME_LEN];
+
+  if (libaquaero5_poll(conf_device, &aq_data, &err_msg) < 0) {
+    char errbuf[1024];
+    ERROR("aquaero plugin: Failed to poll device \"%s\": %s (%s)",
+          conf_device ? conf_device : "default", err_msg,
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return (-1);
+  }
+
+  if (libaquaero5_getsettings(conf_device, &aq_sett, &err_msg) < 0) {
+    char errbuf[1024];
+    ERROR("aquaero plugin: Failed to get settings "
+          "for device \"%s\": %s (%s)",
+          conf_device ? conf_device : "default", err_msg,
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return (-1);
+  }
+
+  /* CPU Temperature sensor */
+  aquaero_submit("temperature", "cpu", aq_data.cpu_temp[0]);
+
+  /* Temperature sensors */
+  aquaero_submit_array("temperature", "sensor", aq_data.temp, AQ5_NUM_TEMP);
+
+  /* Virtual temperature sensors */
+  aquaero_submit_array("temperature", "virtual", aq_data.vtemp,
+                       AQ5_NUM_VIRT_SENSORS);
+
+  /* Software temperature sensors */
+  aquaero_submit_array("temperature", "software", aq_data.stemp,
+                       AQ5_NUM_SOFT_SENSORS);
+
+  /* Other temperature sensors */
+  aquaero_submit_array("temperature", "other", aq_data.otemp,
+                       AQ5_NUM_OTHER_SENSORS);
+
+  /* Fans */
+  for (int i = 0; i < AQ5_NUM_FAN; i++) {
+    if ((aq_sett.fan_data_source[i] == NONE) ||
+        (aq_data.fan_vrm_temp[i] != AQ5_FLOAT_UNDEF))
+      continue;
+
+    snprintf(type_instance, sizeof(type_instance), "fan%d", i + 1);
+
+    aquaero_submit("fanspeed", type_instance, aq_data.fan_rpm[i]);
+    aquaero_submit("percent", type_instance, aq_data.fan_duty[i]);
+    aquaero_submit("voltage", type_instance, aq_data.fan_voltage[i]);
+    aquaero_submit("current", type_instance, aq_data.fan_current[i]);
+
+    /* Report the voltage reglator module (VRM) temperature with a
+     * different type instance. */
+    snprintf(type_instance, sizeof(type_instance), "fan%d-vrm", i + 1);
+    aquaero_submit("temperature", type_instance, aq_data.fan_vrm_temp[i]);
+  }
+
+  /* Flow sensors */
+  aquaero_submit_array("flow", "sensor", aq_data.flow, AQ5_NUM_FLOW);
+
+  /* Liquid level */
+  aquaero_submit_array("percent", "waterlevel", aq_data.level, AQ5_NUM_LEVEL);
+
+  return (0);
 }
 
-void module_register (void)
-{
-	plugin_register_complex_config ("aquaero", aquaero_config);
-	plugin_register_read ("aquaero", aquaero_read);
-	plugin_register_shutdown ("aquaero", aquaero_shutdown);
+void module_register(void) {
+  plugin_register_complex_config("aquaero", aquaero_config);
+  plugin_register_read("aquaero", aquaero_read);
+  plugin_register_shutdown("aquaero", aquaero_shutdown);
 } /* void module_register */
 
 /* vim: set sw=8 sts=8 noet : */
@@ -33,48 +33,39 @@
 #include <libxml/parser.h>
 
 static const char *races_list[] = /* {{{ */
-{
-  NULL,
-  "Human",    /*  1 */
-  "Orc",      /*  2 */
-  "Dwarf",    /*  3 */
-  "Nightelf", /*  4 */
-  "Undead",   /*  5 */
-  "Tauren",   /*  6 */
-  "Gnome",    /*  7 */
-  "Troll",    /*  8 */
-  NULL,
-  "Bloodelf", /* 10 */
-  "Draenei"   /* 11 */
-}; /* }}} */
-#define RACES_LIST_LENGTH STATIC_ARRAY_SIZE (races_list)
+    {
+        NULL,       "Human",    /*  1 */
+        "Orc",                  /*  2 */
+        "Dwarf",                /*  3 */
+        "Nightelf",             /*  4 */
+        "Undead",               /*  5 */
+        "Tauren",               /*  6 */
+        "Gnome",                /*  7 */
+        "Troll",                /*  8 */
+        NULL,       "Bloodelf", /* 10 */
+        "Draenei"               /* 11 */
+};                              /* }}} */
+#define RACES_LIST_LENGTH STATIC_ARRAY_SIZE(races_list)
 
 static const char *classes_list[] = /* {{{ */
-{
-  NULL,
-  "Warrior", /*  1 */
-  "Paladin", /*  2 */
-  "Hunter",  /*  3 */
-  "Rogue",   /*  4 */
-  "Priest",  /*  5 */
-  NULL,
-  "Shaman",  /*  7 */
-  "Mage",    /*  8 */
-  "Warlock", /*  9 */
-  NULL,
-  "Druid"    /* 11 */
-}; /* }}} */
-#define CLASSES_LIST_LENGTH STATIC_ARRAY_SIZE (classes_list)
+    {
+        NULL,      "Warrior", /*  1 */
+        "Paladin",            /*  2 */
+        "Hunter",             /*  3 */
+        "Rogue",              /*  4 */
+        "Priest",             /*  5 */
+        NULL,      "Shaman",  /*  7 */
+        "Mage",               /*  8 */
+        "Warlock",            /*  9 */
+        NULL,      "Druid"    /* 11 */
+};                            /* }}} */
+#define CLASSES_LIST_LENGTH STATIC_ARRAY_SIZE(classes_list)
 
 static const char *genders_list[] = /* {{{ */
-{
-  "Male",
-  "Female"
-}; /* }}} */
-#define GENDERS_LIST_LENGTH STATIC_ARRAY_SIZE (genders_list)
+    {"Male", "Female"};             /* }}} */
+#define GENDERS_LIST_LENGTH STATIC_ARRAY_SIZE(genders_list)
 
-struct player_stats_s
-{
+struct player_stats_s {
   int races[RACES_LIST_LENGTH];
   int classes[CLASSES_LIST_LENGTH];
   int genders[GENDERS_LIST_LENGTH];
@@ -85,232 +76,208 @@ struct player_stats_s
 };
 typedef struct player_stats_s player_stats_t;
 
-struct player_info_s
-{
+struct player_info_s {
   int race;
   int class;
   int gender;
   int level;
   int latency;
 };
 typedef struct player_info_s player_info_t;
-#define PLAYER_INFO_STATIC_INIT { -1, -1, -1, -1, -1 }
+#define PLAYER_INFO_STATIC_INIT                                                \
+  { -1, -1, -1, -1, -1 }
 
-static char *url         = NULL;
-static char *user        = NULL;
-static char *pass        = NULL;
+static char *url = NULL;
+static char *user = NULL;
+static char *pass = NULL;
 static char *verify_peer = NULL;
 static char *verify_host = NULL;
-static char *cacert      = NULL;
-static char *timeout     = NULL;
+static char *cacert = NULL;
+static char *timeout = NULL;
 
 static CURL *curl = NULL;
 
-static char  *ascent_buffer = NULL;
+static char *ascent_buffer = NULL;
 static size_t ascent_buffer_size = 0;
 static size_t ascent_buffer_fill = 0;
-static char   ascent_curl_error[CURL_ERROR_SIZE];
+static char ascent_curl_error[CURL_ERROR_SIZE];
 
-static const char *config_keys[] =
-{
-  "URL",
-  "User",
-  "Password",
-  "VerifyPeer",
-  "VerifyHost",
-  "CACert",
-  "Timeout",
+static const char *config_keys[] = {
+    "URL", "User", "Password", "VerifyPeer", "VerifyHost", "CACert", "Timeout",
 };
-static int config_keys_num = STATIC_ARRAY_SIZE (config_keys);
+static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
-static int ascent_submit_gauge (const char *plugin_instance, /* {{{ */
-    const char *type, const char *type_instance, gauge_t value)
-{
+static int ascent_submit_gauge(const char *plugin_instance, /* {{{ */
+                               const char *type, const char *type_instance,
+                               gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  vl.values = &(value_t) { .gauge = value };
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy (vl.plugin, "ascent", sizeof (vl.plugin));
+  sstrncpy(vl.plugin, "ascent", sizeof(vl.plugin));
 
   if (plugin_instance != NULL)
-    sstrncpy (vl.plugin_instance, plugin_instance,
-        sizeof (vl.plugin_instance));
+    sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
 
-  sstrncpy (vl.type, type, sizeof (vl.type));
+  sstrncpy(vl.type, type, sizeof(vl.type));
 
   if (type_instance != NULL)
-    sstrncpy (vl.type_instance, type_instance, sizeof (vl.type_instance));
+    sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
-  plugin_dispatch_values (&vl);
+  plugin_dispatch_values(&vl);
   return (0);
 } /* }}} int ascent_submit_gauge */
 
-static size_t ascent_curl_callback (void *buf, size_t size, size_t nmemb, /* {{{ */
-    void __attribute__((unused)) *stream)
-{
+static size_t ascent_curl_callback(void *buf, size_t size,
+                                   size_t nmemb, /* {{{ */
+                                   void __attribute__((unused)) * stream) {
   size_t len = size * nmemb;
 
   if (len == 0)
     return (len);
 
-  if ((ascent_buffer_fill + len) >= ascent_buffer_size)
-  {
+  if ((ascent_buffer_fill + len) >= ascent_buffer_size) {
     char *temp;
 
-    temp = realloc (ascent_buffer,
-        ascent_buffer_fill + len + 1);
-    if (temp == NULL)
-    {
-      ERROR ("ascent plugin: realloc failed.");
+    temp = realloc(ascent_buffer, ascent_buffer_fill + len + 1);
+    if (temp == NULL) {
+      ERROR("ascent plugin: realloc failed.");
       return (0);
     }
     ascent_buffer = temp;
     ascent_buffer_size = ascent_buffer_fill + len + 1;
   }
 
-  memcpy (ascent_buffer + ascent_buffer_fill, (char *) buf, len);
+  memcpy(ascent_buffer + ascent_buffer_fill, (char *)buf, len);
   ascent_buffer_fill += len;
   ascent_buffer[ascent_buffer_fill] = 0;
 
   return (len);
 } /* }}} size_t ascent_curl_callback */
 
-static int ascent_submit_players (player_stats_t *ps) /* {{{ */
+static int ascent_submit_players(player_stats_t *ps) /* {{{ */
 {
   gauge_t value;
 
   for (size_t i = 0; i < RACES_LIST_LENGTH; i++)
     if (races_list[i] != NULL)
-      ascent_submit_gauge ("by-race", "players", races_list[i],
-          (gauge_t) ps->races[i]);
+      ascent_submit_gauge("by-race", "players", races_list[i],
+                          (gauge_t)ps->races[i]);
 
   for (size_t i = 0; i < CLASSES_LIST_LENGTH; i++)
     if (classes_list[i] != NULL)
-      ascent_submit_gauge ("by-class", "players", classes_list[i],
-          (gauge_t) ps->classes[i]);
+      ascent_submit_gauge("by-class", "players", classes_list[i],
+                          (gauge_t)ps->classes[i]);
 
   for (size_t i = 0; i < GENDERS_LIST_LENGTH; i++)
     if (genders_list[i] != NULL)
-      ascent_submit_gauge ("by-gender", "players", genders_list[i],
-          (gauge_t) ps->genders[i]);
+      ascent_submit_gauge("by-gender", "players", genders_list[i],
+                          (gauge_t)ps->genders[i]);
 
   if (ps->level_num <= 0)
     value = NAN;
   else
-    value = ((double) ps->level_sum) / ((double) ps->level_num);
-  ascent_submit_gauge (NULL, "gauge", "avg-level", value);
+    value = ((double)ps->level_sum) / ((double)ps->level_num);
+  ascent_submit_gauge(NULL, "gauge", "avg-level", value);
 
   /* Latency is in ms, but we store seconds. */
   if (ps->latency_num <= 0)
     value = NAN;
   else
-    value = ((double) ps->latency_sum) / (1000.0 * ((double) ps->latency_num));
-  ascent_submit_gauge (NULL, "latency", "average", value);
+    value = ((double)ps->latency_sum) / (1000.0 * ((double)ps->latency_num));
+  ascent_submit_gauge(NULL, "latency", "average", value);
 
   return (0);
 } /* }}} int ascent_submit_players */
 
-static int ascent_account_player (player_stats_t *ps, /* {{{ */
-    player_info_t *pi)
-{
-  if (pi->race >= 0)
-  {
-    if (((size_t) pi->race >= RACES_LIST_LENGTH)
-        || (races_list[pi->race] == NULL))
-      ERROR ("ascent plugin: Ignoring invalid numeric race %i.", pi->race);
+static int ascent_account_player(player_stats_t *ps, /* {{{ */
+                                 player_info_t *pi) {
+  if (pi->race >= 0) {
+    if (((size_t)pi->race >= RACES_LIST_LENGTH) ||
+        (races_list[pi->race] == NULL))
+      ERROR("ascent plugin: Ignoring invalid numeric race %i.", pi->race);
     else
       ps->races[pi->race]++;
   }
 
-  if (pi->class >= 0)
-  {
-    if (((size_t) pi->class >= CLASSES_LIST_LENGTH)
-        || (classes_list[pi->class] == NULL))
-      ERROR ("ascent plugin: Ignoring invalid numeric class %i.", pi->class);
+  if (pi->class >= 0) {
+    if (((size_t)pi->class >= CLASSES_LIST_LENGTH) ||
+        (classes_list[pi->class] == NULL))
+      ERROR("ascent plugin: Ignoring invalid numeric class %i.", pi->class);
     else
       ps->classes[pi->class]++;
   }
 
-  if (pi->gender >= 0)
-  {
-    if (((size_t) pi->gender >= GENDERS_LIST_LENGTH)
-        || (genders_list[pi->gender] == NULL))
-      ERROR ("ascent plugin: Ignoring invalid numeric gender %i.",
-          pi->gender);
+  if (pi->gender >= 0) {
+    if (((size_t)pi->gender >= GENDERS_LIST_LENGTH) ||
+        (genders_list[pi->gender] == NULL))
+      ERROR("ascent plugin: Ignoring invalid numeric gender %i.", pi->gender);
     else
       ps->genders[pi->gender]++;
   }
 
-
-  if (pi->level > 0)
-  {
+  if (pi->level > 0) {
     ps->level_sum += pi->level;
     ps->level_num++;
   }
 
-  if (pi->latency >= 0)
-  {
+  if (pi->latency >= 0) {
     ps->latency_sum += pi->latency;
     ps->latency_num++;
   }
 
   return (0);
 } /* }}} int ascent_account_player */
 
-static int ascent_xml_submit_gauge (xmlDoc *doc, xmlNode *node, /* {{{ */
-    const char *plugin_instance, const char *type, const char *type_instance)
-{
+static int ascent_xml_submit_gauge(xmlDoc *doc, xmlNode *node, /* {{{ */
+                                   const char *plugin_instance,
+                                   const char *type,
+                                   const char *type_instance) {
   char *str_ptr;
   gauge_t value;
 
-  str_ptr = (char *) xmlNodeListGetString (doc, node->xmlChildrenNode, 1);
-  if (str_ptr == NULL)
-  {
-    ERROR ("ascent plugin: ascent_xml_submit_gauge: xmlNodeListGetString failed.");
+  str_ptr = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
+  if (str_ptr == NULL) {
+    ERROR(
+        "ascent plugin: ascent_xml_submit_gauge: xmlNodeListGetString failed.");
     return (-1);
   }
 
-  if (strcasecmp ("N/A", str_ptr) == 0)
+  if (strcasecmp("N/A", str_ptr) == 0)
     value = NAN;
-  else
-  {
+  else {
     char *end_ptr = NULL;
-    value = strtod (str_ptr, &end_ptr);
-    if (str_ptr == end_ptr)
-    {
+    value = strtod(str_ptr, &end_ptr);
+    if (str_ptr == end_ptr) {
       xmlFree(str_ptr);
-      ERROR ("ascent plugin: ascent_xml_submit_gauge: strtod failed.");
+      ERROR("ascent plugin: ascent_xml_submit_gauge: strtod failed.");
       return (-1);
     }
   }
   xmlFree(str_ptr);
 
-  return (ascent_submit_gauge (plugin_instance, type, type_instance, value));
+  return (ascent_submit_gauge(plugin_instance, type, type_instance, value));
 } /* }}} int ascent_xml_submit_gauge */
 
-static int ascent_xml_read_int (xmlDoc *doc, xmlNode *node, /* {{{ */
-    int *ret_value)
-{
+static int ascent_xml_read_int(xmlDoc *doc, xmlNode *node, /* {{{ */
+                               int *ret_value) {
   char *str_ptr;
   int value;
 
-  str_ptr = (char *) xmlNodeListGetString (doc, node->xmlChildrenNode, 1);
-  if (str_ptr == NULL)
-  {
-    ERROR ("ascent plugin: ascent_xml_read_int: xmlNodeListGetString failed.");
+  str_ptr = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
+  if (str_ptr == NULL) {
+    ERROR("ascent plugin: ascent_xml_read_int: xmlNodeListGetString failed.");
     return (-1);
   }
 
-  if (strcasecmp ("N/A", str_ptr) == 0)
+  if (strcasecmp("N/A", str_ptr) == 0)
     value = -1;
-  else
-  {
+  else {
     char *end_ptr = NULL;
-    value = strtol (str_ptr, &end_ptr, 0);
-    if (str_ptr == end_ptr)
-    {
+    value = strtol(str_ptr, &end_ptr, 0);
+    if (str_ptr == end_ptr) {
       xmlFree(str_ptr);
-      ERROR ("ascent plugin: ascent_xml_read_int: strtol failed.");
+      ERROR("ascent plugin: ascent_xml_read_int: strtol failed.");
       return (-1);
     }
   }
@@ -320,111 +287,103 @@ static int ascent_xml_read_int (xmlDoc *doc, xmlNode *node, /* {{{ */
   return (0);
 } /* }}} int ascent_xml_read_int */
 
-static int ascent_xml_sessions_plr (xmlDoc *doc, xmlNode *node, /* {{{ */
-    player_info_t *pi)
-{
-  for (xmlNode *child = node->xmlChildrenNode; child != NULL; child = child->next)
-  {
-    if ((xmlStrcmp ((const xmlChar *) "comment", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "text", child->name) == 0))
+static int ascent_xml_sessions_plr(xmlDoc *doc, xmlNode *node, /* {{{ */
+                                   player_info_t *pi) {
+  for (xmlNode *child = node->xmlChildrenNode; child != NULL;
+       child = child->next) {
+    if ((xmlStrcmp((const xmlChar *)"comment", child->name) == 0) ||
+        (xmlStrcmp((const xmlChar *)"text", child->name) == 0))
       /* ignore */;
-    else if (xmlStrcmp ((const xmlChar *) "race", child->name) == 0)
-      ascent_xml_read_int (doc, child, &pi->race);
-    else if (xmlStrcmp ((const xmlChar *) "class", child->name) == 0)
-      ascent_xml_read_int (doc, child, &pi->class);
-    else if (xmlStrcmp ((const xmlChar *) "gender", child->name) == 0)
-      ascent_xml_read_int (doc, child, &pi->gender);
-    else if (xmlStrcmp ((const xmlChar *) "level", child->name) == 0)
-      ascent_xml_read_int (doc, child, &pi->level);
-    else if (xmlStrcmp ((const xmlChar *) "latency", child->name) == 0)
-      ascent_xml_read_int (doc, child, &pi->latency);
-    else if ((xmlStrcmp ((const xmlChar *) "name", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "pvprank", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "map", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "areaid", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "xpos", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "ypos", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "onime", child->name) == 0))
+    else if (xmlStrcmp((const xmlChar *)"race", child->name) == 0)
+      ascent_xml_read_int(doc, child, &pi->race);
+    else if (xmlStrcmp((const xmlChar *)"class", child->name) == 0)
+      ascent_xml_read_int(doc, child, &pi->class);
+    else if (xmlStrcmp((const xmlChar *)"gender", child->name) == 0)
+      ascent_xml_read_int(doc, child, &pi->gender);
+    else if (xmlStrcmp((const xmlChar *)"level", child->name) == 0)
+      ascent_xml_read_int(doc, child, &pi->level);
+    else if (xmlStrcmp((const xmlChar *)"latency", child->name) == 0)
+      ascent_xml_read_int(doc, child, &pi->latency);
+    else if ((xmlStrcmp((const xmlChar *)"name", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"pvprank", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"map", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"areaid", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"xpos", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"ypos", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"onime", child->name) == 0))
       /* ignore */;
-    else
-    {
-      WARNING ("ascent plugin: ascent_xml_status: Unknown tag: %s", child->name);
+    else {
+      WARNING("ascent plugin: ascent_xml_status: Unknown tag: %s", child->name);
     }
   } /* for (child) */
 
   return (0);
 } /* }}} int ascent_xml_sessions_plr */
 
-static int ascent_xml_sessions (xmlDoc *doc, xmlNode *node) /* {{{ */
+static int ascent_xml_sessions(xmlDoc *doc, xmlNode *node) /* {{{ */
 {
-  player_stats_t ps = {
-    .level_sum = 0
-  };
-
-  for (xmlNode *child = node->xmlChildrenNode; child != NULL; child = child->next)
-  {
-    if ((xmlStrcmp ((const xmlChar *) "comment", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "text", child->name) == 0))
+  player_stats_t ps = {.level_sum = 0};
+
+  for (xmlNode *child = node->xmlChildrenNode; child != NULL;
+       child = child->next) {
+    if ((xmlStrcmp((const xmlChar *)"comment", child->name) == 0) ||
+        (xmlStrcmp((const xmlChar *)"text", child->name) == 0))
       /* ignore */;
-    else if (xmlStrcmp ((const xmlChar *) "plr", child->name) == 0)
-    {
+    else if (xmlStrcmp((const xmlChar *)"plr", child->name) == 0) {
       int status;
       player_info_t pi = PLAYER_INFO_STATIC_INIT;
 
-      status = ascent_xml_sessions_plr (doc, child, &pi);
+      status = ascent_xml_sessions_plr(doc, child, &pi);
       if (status == 0)
-        ascent_account_player (&ps, &pi);
-    }
-    else
-    {
-      WARNING ("ascent plugin: ascent_xml_status: Unknown tag: %s", child->name);
+        ascent_account_player(&ps, &pi);
+    } else {
+      WARNING("ascent plugin: ascent_xml_status: Unknown tag: %s", child->name);
     }
   } /* for (child) */
 
-  ascent_submit_players (&ps);
+  ascent_submit_players(&ps);
 
   return (0);
 } /* }}} int ascent_xml_sessions */
 
-static int ascent_xml_status (xmlDoc *doc, xmlNode *node) /* {{{ */
+static int ascent_xml_status(xmlDoc *doc, xmlNode *node) /* {{{ */
 {
-  for (xmlNode *child = node->xmlChildrenNode; child != NULL; child = child->next)
-  {
-    if ((xmlStrcmp ((const xmlChar *) "comment", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "text", child->name) == 0))
+  for (xmlNode *child = node->xmlChildrenNode; child != NULL;
+       child = child->next) {
+    if ((xmlStrcmp((const xmlChar *)"comment", child->name) == 0) ||
+        (xmlStrcmp((const xmlChar *)"text", child->name) == 0))
       /* ignore */;
-    else if (xmlStrcmp ((const xmlChar *) "alliance", child->name) == 0)
-      ascent_xml_submit_gauge (doc, child, NULL, "players", "alliance");
-    else if (xmlStrcmp ((const xmlChar *) "horde", child->name) == 0)
-      ascent_xml_submit_gauge (doc, child, NULL, "players", "horde");
-    else if (xmlStrcmp ((const xmlChar *) "qplayers", child->name) == 0)
-      ascent_xml_submit_gauge (doc, child, NULL, "players", "queued");
-    else if ((xmlStrcmp ((const xmlChar *) "acceptedconns", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "avglat", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "cdbquerysize", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "cpu", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "fthreads", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "gmcount", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "lastupdate", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "ontime", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "oplayers", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "peakcount", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "platform", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "ram", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "threads", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "uptime", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "wdbquerysize", child->name) == 0))
+    else if (xmlStrcmp((const xmlChar *)"alliance", child->name) == 0)
+      ascent_xml_submit_gauge(doc, child, NULL, "players", "alliance");
+    else if (xmlStrcmp((const xmlChar *)"horde", child->name) == 0)
+      ascent_xml_submit_gauge(doc, child, NULL, "players", "horde");
+    else if (xmlStrcmp((const xmlChar *)"qplayers", child->name) == 0)
+      ascent_xml_submit_gauge(doc, child, NULL, "players", "queued");
+    else if ((xmlStrcmp((const xmlChar *)"acceptedconns", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"avglat", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"cdbquerysize", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"cpu", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"fthreads", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"gmcount", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"lastupdate", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"ontime", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"oplayers", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"peakcount", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"platform", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"ram", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"threads", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"uptime", child->name) == 0) ||
+             (xmlStrcmp((const xmlChar *)"wdbquerysize", child->name) == 0))
       /* ignore */;
-    else
-    {
-      WARNING ("ascent plugin: ascent_xml_status: Unknown tag: %s", child->name);
+    else {
+      WARNING("ascent plugin: ascent_xml_status: Unknown tag: %s", child->name);
     }
   } /* for (child) */
 
   return (0);
 } /* }}} int ascent_xml_status */
 
-static int ascent_xml (const char *data) /* {{{ */
+static int ascent_xml(const char *data) /* {{{ */
 {
   xmlDoc *doc;
   xmlNode *cur;
@@ -435,196 +394,182 @@ static int ascent_xml (const char *data) /* {{{ */
       /* encoding = */ NULL,
       /* options = */ 0);
 #else
-  doc = xmlParseMemory (data, strlen (data));
+  doc = xmlParseMemory(data, strlen(data));
 #endif
-  if (doc == NULL)
-  {
-    ERROR ("ascent plugin: xmlParseMemory failed.");
+  if (doc == NULL) {
+    ERROR("ascent plugin: xmlParseMemory failed.");
     return (-1);
   }
 
-  cur = xmlDocGetRootElement (doc);
-  if (cur == NULL)
-  {
-    ERROR ("ascent plugin: XML document is empty.");
-    xmlFreeDoc (doc);
+  cur = xmlDocGetRootElement(doc);
+  if (cur == NULL) {
+    ERROR("ascent plugin: XML document is empty.");
+    xmlFreeDoc(doc);
     return (-1);
   }
 
-  if (xmlStrcmp ((const xmlChar *) "serverpage", cur->name) != 0)
-  {
-    ERROR ("ascent plugin: XML root element is not \"serverpage\".");
-    xmlFreeDoc (doc);
+  if (xmlStrcmp((const xmlChar *)"serverpage", cur->name) != 0) {
+    ERROR("ascent plugin: XML root element is not \"serverpage\".");
+    xmlFreeDoc(doc);
     return (-1);
   }
 
-  for (xmlNode *child = cur->xmlChildrenNode; child != NULL; child = child->next)
-  {
-    if ((xmlStrcmp ((const xmlChar *) "comment", child->name) == 0)
-        || (xmlStrcmp ((const xmlChar *) "text", child->name) == 0))
+  for (xmlNode *child = cur->xmlChildrenNode; child != NULL;
+       child = child->next) {
+    if ((xmlStrcmp((const xmlChar *)"comment", child->name) == 0) ||
+        (xmlStrcmp((const xmlChar *)"text", child->name) == 0))
       /* ignore */;
-    else if (xmlStrcmp ((const xmlChar *) "status", child->name) == 0)
-      ascent_xml_status (doc, child);
-    else if (xmlStrcmp ((const xmlChar *) "instances", child->name) == 0)
+    else if (xmlStrcmp((const xmlChar *)"status", child->name) == 0)
+      ascent_xml_status(doc, child);
+    else if (xmlStrcmp((const xmlChar *)"instances", child->name) == 0)
       /* ignore for now */;
-    else if (xmlStrcmp ((const xmlChar *) "gms", child->name) == 0)
+    else if (xmlStrcmp((const xmlChar *)"gms", child->name) == 0)
       /* ignore for now */;
-    else if (xmlStrcmp ((const xmlChar *) "sessions", child->name) == 0)
-      ascent_xml_sessions (doc, child);
-    else
-    {
-      WARNING ("ascent plugin: ascent_xml: Unknown tag: %s", child->name);
+    else if (xmlStrcmp((const xmlChar *)"sessions", child->name) == 0)
+      ascent_xml_sessions(doc, child);
+    else {
+      WARNING("ascent plugin: ascent_xml: Unknown tag: %s", child->name);
     }
   } /* for (child) */
 
-  xmlFreeDoc (doc);
+  xmlFreeDoc(doc);
   return (0);
 } /* }}} int ascent_xml */
 
-static int config_set (char **var, const char *value) /* {{{ */
+static int config_set(char **var, const char *value) /* {{{ */
 {
-  if (*var != NULL)
-  {
-    free (*var);
+  if (*var != NULL) {
+    free(*var);
     *var = NULL;
   }
 
-  if ((*var = strdup (value)) == NULL)
+  if ((*var = strdup(value)) == NULL)
     return (1);
   else
     return (0);
 } /* }}} int config_set */
 
-static int ascent_config (const char *key, const char *value) /* {{{ */
+static int ascent_config(const char *key, const char *value) /* {{{ */
 {
-  if (strcasecmp (key, "URL") == 0)
-    return (config_set (&url, value));
-  else if (strcasecmp (key, "User") == 0)
-    return (config_set (&user, value));
-  else if (strcasecmp (key, "Password") == 0)
-    return (config_set (&pass, value));
-  else if (strcasecmp (key, "VerifyPeer") == 0)
-    return (config_set (&verify_peer, value));
-  else if (strcasecmp (key, "VerifyHost") == 0)
-    return (config_set (&verify_host, value));
-  else if (strcasecmp (key, "CACert") == 0)
-    return (config_set (&cacert, value));
-  else if (strcasecmp (key, "Timeout") == 0)
-    return (config_set (&timeout, value));
+  if (strcasecmp(key, "URL") == 0)
+    return (config_set(&url, value));
+  else if (strcasecmp(key, "User") == 0)
+    return (config_set(&user, value));
+  else if (strcasecmp(key, "Password") == 0)
+    return (config_set(&pass, value));
+  else if (strcasecmp(key, "VerifyPeer") == 0)
+    return (config_set(&verify_peer, value));
+  else if (strcasecmp(key, "VerifyHost") == 0)
+    return (config_set(&verify_host, value));
+  else if (strcasecmp(key, "CACert") == 0)
+    return (config_set(&cacert, value));
+  else if (strcasecmp(key, "Timeout") == 0)
+    return (config_set(&timeout, value));
   else
     return (-1);
 } /* }}} int ascent_config */
 
-static int ascent_init (void) /* {{{ */
+static int ascent_init(void) /* {{{ */
 {
-  if (url == NULL)
-  {
-    WARNING ("ascent plugin: ascent_init: No URL configured, "
-        "returning an error.");
+  if (url == NULL) {
+    WARNING("ascent plugin: ascent_init: No URL configured, "
+            "returning an error.");
     return (-1);
   }
 
-  if (curl != NULL)
-  {
-    curl_easy_cleanup (curl);
+  if (curl != NULL) {
+    curl_easy_cleanup(curl);
   }
 
-  if ((curl = curl_easy_init ()) == NULL)
-  {
-    ERROR ("ascent plugin: ascent_init: curl_easy_init failed.");
+  if ((curl = curl_easy_init()) == NULL) {
+    ERROR("ascent plugin: ascent_init: curl_easy_init failed.");
     return (-1);
   }
 
-  curl_easy_setopt (curl, CURLOPT_NOSIGNAL, 1L);
-  curl_easy_setopt (curl, CURLOPT_WRITEFUNCTION, ascent_curl_callback);
-  curl_easy_setopt (curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
-  curl_easy_setopt (curl, CURLOPT_ERRORBUFFER, ascent_curl_error);
+  curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
+  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ascent_curl_callback);
+  curl_easy_setopt(curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
+  curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, ascent_curl_error);
 
-  if (user != NULL)
-  {
+  if (user != NULL) {
 #ifdef HAVE_CURLOPT_USERNAME
-    curl_easy_setopt (curl, CURLOPT_USERNAME, user);
-    curl_easy_setopt (curl, CURLOPT_PASSWORD, (pass == NULL) ? "" : pass);
+    curl_easy_setopt(curl, CURLOPT_USERNAME, user);
+    curl_easy_setopt(curl, CURLOPT_PASSWORD, (pass == NULL) ? "" : pass);
 #else
     static char credentials[1024];
     int status;
 
-    status = ssnprintf (credentials, sizeof (credentials), "%s:%s",
-        user, (pass == NULL) ? "" : pass);
-    if ((status < 0) || ((size_t) status >= sizeof (credentials)))
-    {
-      ERROR ("ascent plugin: ascent_init: Returning an error because the "
-          "credentials have been truncated.");
+    status = ssnprintf(credentials, sizeof(credentials), "%s:%s", user,
+                       (pass == NULL) ? "" : pass);
+    if ((status < 0) || ((size_t)status >= sizeof(credentials))) {
+      ERROR("ascent plugin: ascent_init: Returning an error because the "
+            "credentials have been truncated.");
       return (-1);
     }
 
-    curl_easy_setopt (curl, CURLOPT_USERPWD, credentials);
+    curl_easy_setopt(curl, CURLOPT_USERPWD, credentials);
 #endif
   }
 
-  curl_easy_setopt (curl, CURLOPT_URL, url);
-  curl_easy_setopt (curl, CURLOPT_FOLLOWLOCATION, 1L);
-  curl_easy_setopt (curl, CURLOPT_MAXREDIRS, 50L);
+  curl_easy_setopt(curl, CURLOPT_URL, url);
+  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
+  curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
 
-  if ((verify_peer == NULL) || IS_TRUE (verify_peer))
-    curl_easy_setopt (curl, CURLOPT_SSL_VERIFYPEER, 1L);
+  if ((verify_peer == NULL) || IS_TRUE(verify_peer))
+    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
   else
-    curl_easy_setopt (curl, CURLOPT_SSL_VERIFYPEER, 0L);
+    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
 
-  if ((verify_host == NULL) || IS_TRUE (verify_host))
-    curl_easy_setopt (curl, CURLOPT_SSL_VERIFYHOST, 2L);
+  if ((verify_host == NULL) || IS_TRUE(verify_host))
+    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
   else
-    curl_easy_setopt (curl, CURLOPT_SSL_VERIFYHOST, 0L);
+    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
 
   if (cacert != NULL)
-    curl_easy_setopt (curl, CURLOPT_CAINFO, cacert);
+    curl_easy_setopt(curl, CURLOPT_CAINFO, cacert);
 
 #ifdef HAVE_CURLOPT_TIMEOUT_MS
   if (timeout != NULL)
-    curl_easy_setopt (curl, CURLOPT_TIMEOUT_MS, atol(timeout));
+    curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, atol(timeout));
   else
-    curl_easy_setopt (curl, CURLOPT_TIMEOUT_MS, (long) CDTIME_T_TO_MS(plugin_get_interval()));
+    curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS,
+                     (long)CDTIME_T_TO_MS(plugin_get_interval()));
 #endif
 
   return (0);
 } /* }}} int ascent_init */
 
-static int ascent_read (void) /* {{{ */
+static int ascent_read(void) /* {{{ */
 {
   int status;
 
-  if (curl == NULL)
-  {
-    ERROR ("ascent plugin: I don't have a CURL object.");
+  if (curl == NULL) {
+    ERROR("ascent plugin: I don't have a CURL object.");
     return (-1);
   }
 
-  if (url == NULL)
-  {
-    ERROR ("ascent plugin: No URL has been configured.");
+  if (url == NULL) {
+    ERROR("ascent plugin: No URL has been configured.");
     return (-1);
   }
 
   ascent_buffer_fill = 0;
-  if (curl_easy_perform (curl) != CURLE_OK)
-  {
-    ERROR ("ascent plugin: curl_easy_perform failed: %s",
-        ascent_curl_error);
+  if (curl_easy_perform(curl) != CURLE_OK) {
+    ERROR("ascent plugin: curl_easy_perform failed: %s", ascent_curl_error);
     return (-1);
   }
 
-  status = ascent_xml (ascent_buffer);
+  status = ascent_xml(ascent_buffer);
   if (status != 0)
     return (-1);
   else
     return (0);
 } /* }}} int ascent_read */
 
-void module_register (void)
-{
-  plugin_register_config ("ascent", ascent_config, config_keys, config_keys_num);
-  plugin_register_init ("ascent", ascent_init);
-  plugin_register_read ("ascent", ascent_read);
+void module_register(void) {
+  plugin_register_config("ascent", ascent_config, config_keys, config_keys_num);
+  plugin_register_init("ascent", ascent_init);
+  plugin_register_read("ascent", ascent_read);
 } /* void module_register */
 
 /* vim: set sw=2 sts=2 ts=8 et fdm=marker : */
@@ -22,187 +22,184 @@
 #include "collectd.h"
 
 #include "common.h"
-#include "utils_cache.h"
 #include "plugin.h"
+#include "utils_cache.h"
 
-#include <stdint.h>
 #include <fcntl.h>
-#include <unistd.h>
 #include <linux/i2c-dev.h>
 #include <math.h>
+#include <stdint.h>
 #include <sys/ioctl.h>
+#include <unistd.h>
 
 /* ------------ MPL115 defines ------------ */
 /* I2C address of the MPL115 sensor */
-#define MPL115_I2C_ADDRESS          0x60
+#define MPL115_I2C_ADDRESS 0x60
 
 /* register addresses */
-#define MPL115_ADDR_CONV            0x00
-#define MPL115_ADDR_COEFFS          0x04
+#define MPL115_ADDR_CONV 0x00
+#define MPL115_ADDR_COEFFS 0x04
 
 /* register sizes */
-#define MPL115_NUM_CONV             4
-#define MPL115_NUM_COEFFS           12
+#define MPL115_NUM_CONV 4
+#define MPL115_NUM_COEFFS 12
 
 /* commands / addresses */
-#define MPL115_CMD_CONVERT_PRESS    0x10
-#define MPL115_CMD_CONVERT_TEMP     0x11
-#define MPL115_CMD_CONVERT_BOTH     0x12
-
-#define MPL115_CONVERSION_RETRIES   5
+#define MPL115_CMD_CONVERT_PRESS 0x10
+#define MPL115_CMD_CONVERT_TEMP 0x11
+#define MPL115_CMD_CONVERT_BOTH 0x12
 
+#define MPL115_CONVERSION_RETRIES 5
 
 /* ------------ MPL3115 defines ------------ */
 /* MPL3115 I2C address */
-#define MPL3115_I2C_ADDRESS         0x60
+#define MPL3115_I2C_ADDRESS 0x60
 
 /* register addresses (only the interesting ones) */
-#define MPL3115_REG_STATUS          0x00
-#define MPL3115_REG_OUT_P_MSB       0x01
-#define MPL3115_REG_OUT_P_CSB       0x02
-#define MPL3115_REG_OUT_P_LSB       0x03
-#define MPL3115_REG_OUT_T_MSB       0x04
-#define MPL3115_REG_OUT_T_LSB       0x05
-#define MPL3115_REG_DR_STATUS       0x06
-#define MPL3115_REG_WHO_AM_I        0x0C
-#define MPL3115_REG_SYSMOD          0x11
-#define MPL3115_REG_PT_DATA_CFG     0x13
-#define MPL3115_REG_BAR_IN_MSB      0x14
-#define MPL3115_REG_BAR_IN_LSB      0x15
-#define MPL3115_REG_CTRL_REG1       0x26
-#define MPL3115_REG_CTRL_REG2       0x27
-#define MPL3115_REG_CTRL_REG3       0x28
-#define MPL3115_REG_CTRL_REG4       0x29
-#define MPL3115_REG_CTRL_REG5       0x2A
-#define MPL3115_REG_OFF_P           0x2B
-#define MPL3115_REG_OFF_T           0x2C
-#define MPL3115_REG_OFF_H           0x2D
+#define MPL3115_REG_STATUS 0x00
+#define MPL3115_REG_OUT_P_MSB 0x01
+#define MPL3115_REG_OUT_P_CSB 0x02
+#define MPL3115_REG_OUT_P_LSB 0x03
+#define MPL3115_REG_OUT_T_MSB 0x04
+#define MPL3115_REG_OUT_T_LSB 0x05
+#define MPL3115_REG_DR_STATUS 0x06
+#define MPL3115_REG_WHO_AM_I 0x0C
+#define MPL3115_REG_SYSMOD 0x11
+#define MPL3115_REG_PT_DATA_CFG 0x13
+#define MPL3115_REG_BAR_IN_MSB 0x14
+#define MPL3115_REG_BAR_IN_LSB 0x15
+#define MPL3115_REG_CTRL_REG1 0x26
+#define MPL3115_REG_CTRL_REG2 0x27
+#define MPL3115_REG_CTRL_REG3 0x28
+#define MPL3115_REG_CTRL_REG4 0x29
+#define MPL3115_REG_CTRL_REG5 0x2A
+#define MPL3115_REG_OFF_P 0x2B
+#define MPL3115_REG_OFF_T 0x2C
+#define MPL3115_REG_OFF_H 0x2D
 
 /* Register values, masks */
-#define MPL3115_WHO_AM_I_RESP       0xC4
-
-#define MPL3115_PT_DATA_DREM        0x04
-#define MPL3115_PT_DATA_PDEF        0x02
-#define MPL3115_PT_DATA_TDEF        0x01
-
-#define MPL3115_DR_STATUS_TDR       0x02
-#define MPL3115_DR_STATUS_PDR       0x04
-#define MPL3115_DR_STATUS_PTDR      0x08
-#define MPL3115_DR_STATUS_DR        (MPL3115_DR_STATUS_TDR | MPL3115_DR_STATUS_PDR | MPL3115_DR_STATUS_PTDR)
-
-#define MPL3115_DR_STATUS_TOW       0x20
-#define MPL3115_DR_STATUS_POW       0x40
-#define MPL3115_DR_STATUS_PTOW      0x80
-
-#define MPL3115_CTRL_REG1_ALT       0x80
-#define MPL3115_CTRL_REG1_RAW       0x40
-#define MPL3115_CTRL_REG1_OST_MASK  0x38
-#define MPL3115_CTRL_REG1_OST_1     0x00
-#define MPL3115_CTRL_REG1_OST_2     0x08
-#define MPL3115_CTRL_REG1_OST_4     0x10
-#define MPL3115_CTRL_REG1_OST_8     0x18
-#define MPL3115_CTRL_REG1_OST_16    0x20
-#define MPL3115_CTRL_REG1_OST_32    0x28
-#define MPL3115_CTRL_REG1_OST_64    0x30
-#define MPL3115_CTRL_REG1_OST_128   0x38
-#define MPL3115_CTRL_REG1_RST       0x04
-#define MPL3115_CTRL_REG1_OST       0x02
-#define MPL3115_CTRL_REG1_SBYB      0x01
+#define MPL3115_WHO_AM_I_RESP 0xC4
+
+#define MPL3115_PT_DATA_DREM 0x04
+#define MPL3115_PT_DATA_PDEF 0x02
+#define MPL3115_PT_DATA_TDEF 0x01
+
+#define MPL3115_DR_STATUS_TDR 0x02
+#define MPL3115_DR_STATUS_PDR 0x04
+#define MPL3115_DR_STATUS_PTDR 0x08
+#define MPL3115_DR_STATUS_DR                                                   \
+  (MPL3115_DR_STATUS_TDR | MPL3115_DR_STATUS_PDR | MPL3115_DR_STATUS_PTDR)
+
+#define MPL3115_DR_STATUS_TOW 0x20
+#define MPL3115_DR_STATUS_POW 0x40
+#define MPL3115_DR_STATUS_PTOW 0x80
+
+#define MPL3115_CTRL_REG1_ALT 0x80
+#define MPL3115_CTRL_REG1_RAW 0x40
+#define MPL3115_CTRL_REG1_OST_MASK 0x38
+#define MPL3115_CTRL_REG1_OST_1 0x00
+#define MPL3115_CTRL_REG1_OST_2 0x08
+#define MPL3115_CTRL_REG1_OST_4 0x10
+#define MPL3115_CTRL_REG1_OST_8 0x18
+#define MPL3115_CTRL_REG1_OST_16 0x20
+#define MPL3115_CTRL_REG1_OST_32 0x28
+#define MPL3115_CTRL_REG1_OST_64 0x30
+#define MPL3115_CTRL_REG1_OST_128 0x38
+#define MPL3115_CTRL_REG1_RST 0x04
+#define MPL3115_CTRL_REG1_OST 0x02
+#define MPL3115_CTRL_REG1_SBYB 0x01
 #define MPL3115_CTRL_REG1_SBYB_MASK 0xFE
 
-#define MPL3115_NUM_CONV_VALS       5
-
+#define MPL3115_NUM_CONV_VALS 5
 
 /* ------------ BMP085 defines ------------ */
 /* I2C address of the BMP085 sensor */
-#define BMP085_I2C_ADDRESS          0x77
+#define BMP085_I2C_ADDRESS 0x77
 
 /* register addresses */
-#define BMP085_ADDR_ID_REG          0xD0
-#define BMP085_ADDR_VERSION         0xD1
+#define BMP085_ADDR_ID_REG 0xD0
+#define BMP085_ADDR_VERSION 0xD1
 
-#define BMP085_ADDR_CONV            0xF6
+#define BMP085_ADDR_CONV 0xF6
 
-#define BMP085_ADDR_CTRL_REG        0xF4
-#define BMP085_ADDR_COEFFS          0xAA
+#define BMP085_ADDR_CTRL_REG 0xF4
+#define BMP085_ADDR_COEFFS 0xAA
 
 /* register sizes */
-#define BMP085_NUM_COEFFS           22
+#define BMP085_NUM_COEFFS 22
 
 /* commands, values */
-#define BMP085_CHIP_ID              0x55
+#define BMP085_CHIP_ID 0x55
 
-#define BMP085_CMD_CONVERT_TEMP     0x2E
+#define BMP085_CMD_CONVERT_TEMP 0x2E
 
-#define BMP085_CMD_CONVERT_PRESS_0  0x34
-#define BMP085_CMD_CONVERT_PRESS_1  0x74
-#define BMP085_CMD_CONVERT_PRESS_2  0xB4
-#define BMP085_CMD_CONVERT_PRESS_3  0xF4
+#define BMP085_CMD_CONVERT_PRESS_0 0x34
+#define BMP085_CMD_CONVERT_PRESS_1 0x74
+#define BMP085_CMD_CONVERT_PRESS_2 0xB4
+#define BMP085_CMD_CONVERT_PRESS_3 0xF4
 
 /* in us */
-#define BMP085_TIME_CNV_TEMP        4500
-
-#define BMP085_TIME_CNV_PRESS_0     4500
-#define BMP085_TIME_CNV_PRESS_1     7500
-#define BMP085_TIME_CNV_PRESS_2    13500
-#define BMP085_TIME_CNV_PRESS_3    25500
+#define BMP085_TIME_CNV_TEMP 4500
 
+#define BMP085_TIME_CNV_PRESS_0 4500
+#define BMP085_TIME_CNV_PRESS_1 7500
+#define BMP085_TIME_CNV_PRESS_2 13500
+#define BMP085_TIME_CNV_PRESS_3 25500
 
 /* ------------ Normalization ------------ */
 /* Mean sea level pressure normalization methods */
-#define MSLP_NONE          0
+#define MSLP_NONE 0
 #define MSLP_INTERNATIONAL 1
-#define MSLP_DEU_WETT      2
-
-/** Temperature reference history depth for averaging. See #get_reference_temperature */
-#define REF_TEMP_AVG_NUM   5
+#define MSLP_DEU_WETT 2
 
+/** Temperature reference history depth for averaging. See
+ * #get_reference_temperature */
+#define REF_TEMP_AVG_NUM 5
 
 /* ------------------------------------------ */
 
 /** Supported sensor types */
 enum Sensor_type {
-    Sensor_none = 0,
-    Sensor_MPL115,
-    Sensor_MPL3115,
-    Sensor_BMP085
+  Sensor_none = 0,
+  Sensor_MPL115,
+  Sensor_MPL3115,
+  Sensor_BMP085
 };
 
-static const char *config_keys[] =
-{
+static const char *config_keys[] = {
     "Device",
     "Oversampling",
     "PressureOffset",    /**< only for MPL3115 */
     "TemperatureOffset", /**< only for MPL3115 */
     "Altitude",
     "Normalization",
-    "TemperatureSensor"
-};
+    "TemperatureSensor"};
 
-static int    config_keys_num     = STATIC_ARRAY_SIZE(config_keys);
+static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
-static char * config_device       = NULL;  /**< I2C bus device */
-static int    config_oversample   = 1;     /**< averaging window */
+static char *config_device = NULL; /**< I2C bus device */
+static int config_oversample = 1;  /**< averaging window */
 
-static double config_press_offset = 0.0;   /**< pressure offset */
-static double config_temp_offset  = 0.0;   /**< temperature offset */
+static double config_press_offset = 0.0; /**< pressure offset */
+static double config_temp_offset = 0.0;  /**< temperature offset */
 
-static double config_altitude     = NAN;   /**< altitude */
-static int    config_normalize    = 0;     /**< normalization method */
+static double config_altitude = NAN; /**< altitude */
+static int config_normalize = 0;     /**< normalization method */
 
-static _Bool  configured          = 0;     /**< the whole plugin config status */
+static _Bool configured = 0; /**< the whole plugin config status */
 
-static int    i2c_bus_fd          = -1;    /**< I2C bus device FD */
+static int i2c_bus_fd = -1; /**< I2C bus device FD */
 
-static enum Sensor_type sensor_type = Sensor_none; /**< detected/used sensor type */
+static enum Sensor_type sensor_type =
+    Sensor_none; /**< detected/used sensor type */
 
-static __s32  mpl3115_oversample  = 0;    /**< MPL3115 CTRL1 oversample setting */
+static __s32 mpl3115_oversample = 0; /**< MPL3115 CTRL1 oversample setting */
 
 // BMP085 configuration
-static unsigned      bmp085_oversampling; /**< BMP085 oversampling (0-3) */
-static unsigned long bmp085_timeCnvPress; /**< BMP085 conversion time for pressure in us */
-static __u8          bmp085_cmdCnvPress;  /**< BMP085 pressure conversion command */
-
+static unsigned bmp085_oversampling; /**< BMP085 oversampling (0-3) */
+static unsigned long
+    bmp085_timeCnvPress; /**< BMP085 conversion time for pressure in us */
+static __u8 bmp085_cmdCnvPress; /**< BMP085 pressure conversion command */
 
 /* MPL115 conversion coefficients */
 static double mpl115_coeffA0;
@@ -225,25 +222,21 @@ static short bmp085_MB;
 static short bmp085_MC;
 static short bmp085_MD;
 
-
-
 /* ------------------------ averaging ring buffer ------------------------ */
 /*  Used only for MPL115. MPL3115 supports real oversampling in the device so */
 /*  no need for any postprocessing. */
 
-static _Bool avg_initialized = 0;    /**< already initialized by real values */
+static _Bool avg_initialized = 0; /**< already initialized by real values */
 
 typedef struct averaging_s {
-    long int * ring_buffer;
-    int        ring_buffer_size;
-    long int   ring_buffer_sum;
-    int        ring_buffer_head;
+  long int *ring_buffer;
+  int ring_buffer_size;
+  long int ring_buffer_sum;
+  int ring_buffer_head;
 } averaging_t;
 
-
-static averaging_t pressure_averaging    = { NULL, 0, 0L, 0 };
-static averaging_t temperature_averaging = { NULL, 0, 0L, 0 };
-
+static averaging_t pressure_averaging = {NULL, 0, 0L, 0};
+static averaging_t temperature_averaging = {NULL, 0, 0L, 0};
 
 /**
  * Create / allocate averaging buffer
@@ -255,42 +248,37 @@ static averaging_t temperature_averaging = { NULL, 0, 0L, 0 };
  *
  * @return Zero when successful
  */
-static int averaging_create(averaging_t *avg, int size)
-{
-    avg->ring_buffer = calloc ((size_t) size, sizeof (*avg->ring_buffer));
-    if (avg->ring_buffer == NULL)
-    {
-        ERROR ("barometer: averaging_create - ring buffer allocation of size %d failed",
-               size);
-        return -1;
-    }
-
-    avg->ring_buffer_size = size;
-    avg->ring_buffer_sum  = 0L;
-    avg->ring_buffer_head = 0;
-
-    return 0;
+static int averaging_create(averaging_t *avg, int size) {
+  avg->ring_buffer = calloc((size_t)size, sizeof(*avg->ring_buffer));
+  if (avg->ring_buffer == NULL) {
+    ERROR("barometer: averaging_create - ring buffer allocation of size %d "
+          "failed",
+          size);
+    return -1;
+  }
+
+  avg->ring_buffer_size = size;
+  avg->ring_buffer_sum = 0L;
+  avg->ring_buffer_head = 0;
+
+  return 0;
 }
 
-
 /**
  * Delete / free existing averaging buffer
  *
  * @param avg  pointer to the ring buffer to be deleted
  */
-static void averaging_delete(averaging_t * avg)
-{
-    if (avg->ring_buffer != NULL)
-    {
-        free(avg->ring_buffer);
-        avg->ring_buffer = NULL;
-    }
-    avg->ring_buffer_size = 0;
-    avg->ring_buffer_sum  = 0L;
-    avg->ring_buffer_head = 0;
+static void averaging_delete(averaging_t *avg) {
+  if (avg->ring_buffer != NULL) {
+    free(avg->ring_buffer);
+    avg->ring_buffer = NULL;
+  }
+  avg->ring_buffer_size = 0;
+  avg->ring_buffer_sum = 0L;
+  avg->ring_buffer_head = 0;
 }
 
-
 /*
  * Add new sample to the averaging buffer
  *
@@ -303,37 +291,33 @@ static void averaging_delete(averaging_t * avg)
  *
  * @return Averaged sample value
  */
-static double averaging_add_sample(averaging_t * avg, long int sample)
-{
-    double result;
+static double averaging_add_sample(averaging_t *avg, long int sample) {
+  double result;
 
-    avg->ring_buffer_sum += sample - avg->ring_buffer[avg->ring_buffer_head];
-    avg->ring_buffer[avg->ring_buffer_head] = sample;
-    avg->ring_buffer_head = (avg->ring_buffer_head+1) % avg->ring_buffer_size;
-    result = (double)(avg->ring_buffer_sum) / (double)(avg->ring_buffer_size);
+  avg->ring_buffer_sum += sample - avg->ring_buffer[avg->ring_buffer_head];
+  avg->ring_buffer[avg->ring_buffer_head] = sample;
+  avg->ring_buffer_head = (avg->ring_buffer_head + 1) % avg->ring_buffer_size;
+  result = (double)(avg->ring_buffer_sum) / (double)(avg->ring_buffer_size);
 
-    DEBUG ("barometer: averaging_add_sample - added %ld, result = %lf",
-           sample,
-           result);
+  DEBUG("barometer: averaging_add_sample - added %ld, result = %lf", sample,
+        result);
 
-    return result;
+  return result;
 }
 
-
 /* ------------------------ temperature refference ------------------------ */
 
 /**
  * Linked list type of temperature sensor references
  */
 typedef struct temperature_list_s {
-    char                      * sensor_name; /**< sensor name/reference */
-    size_t                      num_values;  /**< number of values (usually one) */
-    _Bool                       initialized; /**< sensor already provides data */
-    struct temperature_list_s * next;        /**< next in the list */
+  char *sensor_name;               /**< sensor name/reference */
+  size_t num_values;               /**< number of values (usually one) */
+  _Bool initialized;               /**< sensor already provides data */
+  struct temperature_list_s *next; /**< next in the list */
 } temperature_list_t;
 
-static temperature_list_t * temp_list = NULL;
-
+static temperature_list_t *temp_list = NULL;
 
 /*
  * Add new sensor to the temperature reference list
@@ -343,240 +327,215 @@ static temperature_list_t * temp_list = NULL;
  *
  * @return Zero when successful
  */
-static int temp_list_add(temperature_list_t * list, const char * sensor)
-{
-    temperature_list_t *new_temp;
-
-    new_temp = malloc(sizeof (*new_temp));
-    if(new_temp == NULL)
-        return -1;
-
-    new_temp->sensor_name = strdup(sensor);
-    new_temp->initialized = 0;
-    new_temp->num_values = 0;
-    if(new_temp->sensor_name == NULL)
-    {
-        free(new_temp);
-        return -1;
-    }
-
-    new_temp->next = temp_list;
-    temp_list = new_temp;
-    return 0;
+static int temp_list_add(temperature_list_t *list, const char *sensor) {
+  temperature_list_t *new_temp;
+
+  new_temp = malloc(sizeof(*new_temp));
+  if (new_temp == NULL)
+    return -1;
+
+  new_temp->sensor_name = strdup(sensor);
+  new_temp->initialized = 0;
+  new_temp->num_values = 0;
+  if (new_temp->sensor_name == NULL) {
+    free(new_temp);
+    return -1;
+  }
+
+  new_temp->next = temp_list;
+  temp_list = new_temp;
+  return 0;
 }
 
-
 /*
  * Delete the whole temperature reference list
  *
  * @param list the list to be deleted
  */
-static void temp_list_delete(temperature_list_t ** list)
-{
-    temperature_list_t * tmp;
-
-    while (*list != NULL)
-    {
-        tmp = (*list);
-        (*list) = (*list)->next;
-        free(tmp->sensor_name);
-        free(tmp);
-        tmp = NULL;
-    }
+static void temp_list_delete(temperature_list_t **list) {
+  temperature_list_t *tmp;
+
+  while (*list != NULL) {
+    tmp = (*list);
+    (*list) = (*list)->next;
+    free(tmp->sensor_name);
+    free(tmp);
+    tmp = NULL;
+  }
 }
 
-
 /*
  * Get reference temperature value
  *
- * First initially uc_get_rate_by_name is tried. At the startup due to nondeterministic
- * order the temperature may not be read yet (then it fails and first measurment gives
- * only absolute air pressure reading which is acceptable). Once it succedes (should be
+ * First initially uc_get_rate_by_name is tried. At the startup due to
+ * nondeterministic
+ * order the temperature may not be read yet (then it fails and first measurment
+ * gives
+ * only absolute air pressure reading which is acceptable). Once it succedes
+ * (should be
  * second measurement at the latest) we use average of few last readings from
- * uc_get_history_by_name. It may take few readings to start filling so again we use
+ * uc_get_history_by_name. It may take few readings to start filling so again we
+ * use
  * uc_get_rate_by_name as a fallback.
- * The idea is to use basic "noise" filtering (history averaging) across all the values
+ * The idea is to use basic "noise" filtering (history averaging) across all the
+ * values
  * which given sensor provides (up to given depth). Then we get minimum among
  * the sensors.
  *
  * @param result where the result is stored. When not available NAN is stored.
  *
  * @return Zero when successful
  */
-static int get_reference_temperature(double * result)
-{
-    temperature_list_t * list = temp_list;
+static int get_reference_temperature(double *result) {
+  temperature_list_t *list = temp_list;
 
-    gauge_t * values = NULL;   /**< rate values */
-    size_t    values_num = 0;  /**< number of rate values */
+  gauge_t *values = NULL; /**< rate values */
+  size_t values_num = 0;  /**< number of rate values */
 
-    gauge_t values_history[REF_TEMP_AVG_NUM];
+  gauge_t values_history[REF_TEMP_AVG_NUM];
 
-    double avg_sum;  /**< Value sum for computing average */
-    int    avg_num;  /**< Number of values for computing average */
-    double average;  /**< Resulting value average */
+  double avg_sum; /**< Value sum for computing average */
+  int avg_num;    /**< Number of values for computing average */
+  double average; /**< Resulting value average */
 
-    *result = NAN;
+  *result = NAN;
 
-    while(list != NULL)
-    {
-        avg_sum = 0.0;
-        avg_num = 0;
-
-        /* First time need to read current rate to learn how many values are
-           there (typically for temperature it would be just one).
-           We do not expect dynamic changing of number of temperarure values
-           in runtime yet (are there any such cases?). */
-        if(!list->initialized)
-        {
-            if(uc_get_rate_by_name(list->sensor_name,
-                                   &values,
-                                   &values_num))
-            {
-                DEBUG ("barometer: get_reference_temperature - rate \"%s\" not found yet",
-                       list->sensor_name);
-                list = list->next;
-                continue;
-            }
-
-            DEBUG ("barometer: get_reference_temperature - initialize \"%s\", %zu vals",
-                   list->sensor_name,
-                   values_num);
-
-            list->initialized = 1;
-            list->num_values = values_num;
-
-            for(size_t i=0; i<values_num; ++i)
-            {
-                DEBUG ("barometer: get_reference_temperature - rate %zu: %lf **",
-                       i, values[i]);
-                if(!isnan(values[i]))
-                {
-                    avg_sum += values[i];
-                    ++avg_num;
-                }
-            }
-            free(values);
-            values = NULL;
-        }
-
-        /* It is OK to get here the first time as well, in the worst case
-           the history will full of NANs. */
-        if(uc_get_history_by_name(list->sensor_name,
-                                  values_history,
-                                  REF_TEMP_AVG_NUM,
-                                  list->num_values))
-        {
-            ERROR ("barometer: get_reference_temperature - history \"%s\" lost",
-                   list->sensor_name);
-            list->initialized = 0;
-            list->num_values = 0;
-            list = list->next;
-            continue;
-        }
-
-        for(size_t i=0; i<REF_TEMP_AVG_NUM*list->num_values; ++i)
-        {
-            DEBUG ("barometer: get_reference_temperature - history %zu: %lf",
-                   i, values_history[i]);
-            if(!isnan(values_history[i]))
-            {
-                avg_sum += values_history[i];
-                ++avg_num;
-            }
-        }
+  while (list != NULL) {
+    avg_sum = 0.0;
+    avg_num = 0;
 
-        if(avg_num == 0)   /* still no history? fallback to current */
-        {
-            if(uc_get_rate_by_name(list->sensor_name,
-                                   &values,
-                                   &values_num))
-            {
-                ERROR ("barometer: get_reference_temperature - rate \"%s\" lost",
-                       list->sensor_name);
-                list->initialized = 0;
-                list->num_values = 0;
-                list = list->next;
-                continue;
-            }
-
-            for(size_t i=0; i<values_num; ++i)
-            {
-                DEBUG ("barometer: get_reference_temperature - rate last %zu: %lf **",
-                       i, values[i]);
-                if(!isnan(values[i]))
-                {
-                    avg_sum += values[i];
-                    ++avg_num;
-                }
-            }
-            free(values);
-            values = NULL;
-        }
-
-        if(avg_num == 0)
-        {
-            ERROR ("barometer: get_reference_temperature - could not read \"%s\"",
-                   list->sensor_name);
-            list->initialized = 0;
-            list->num_values = 0;
-        }
-        else
-        {
-            average = avg_sum / (double) avg_num;
-            if(isnan(*result))
-                *result=average;
-            else if(*result>average)
-                *result=average;
+    /* First time need to read current rate to learn how many values are
+       there (typically for temperature it would be just one).
+       We do not expect dynamic changing of number of temperarure values
+       in runtime yet (are there any such cases?). */
+    if (!list->initialized) {
+      if (uc_get_rate_by_name(list->sensor_name, &values, &values_num)) {
+        DEBUG(
+            "barometer: get_reference_temperature - rate \"%s\" not found yet",
+            list->sensor_name);
+        list = list->next;
+        continue;
+      }
+
+      DEBUG(
+          "barometer: get_reference_temperature - initialize \"%s\", %zu vals",
+          list->sensor_name, values_num);
+
+      list->initialized = 1;
+      list->num_values = values_num;
+
+      for (size_t i = 0; i < values_num; ++i) {
+        DEBUG("barometer: get_reference_temperature - rate %zu: %lf **", i,
+              values[i]);
+        if (!isnan(values[i])) {
+          avg_sum += values[i];
+          ++avg_num;
         }
+      }
+      free(values);
+      values = NULL;
+    }
+
+    /* It is OK to get here the first time as well, in the worst case
+       the history will full of NANs. */
+    if (uc_get_history_by_name(list->sensor_name, values_history,
+                               REF_TEMP_AVG_NUM, list->num_values)) {
+      ERROR("barometer: get_reference_temperature - history \"%s\" lost",
+            list->sensor_name);
+      list->initialized = 0;
+      list->num_values = 0;
+      list = list->next;
+      continue;
+    }
+
+    for (size_t i = 0; i < REF_TEMP_AVG_NUM * list->num_values; ++i) {
+      DEBUG("barometer: get_reference_temperature - history %zu: %lf", i,
+            values_history[i]);
+      if (!isnan(values_history[i])) {
+        avg_sum += values_history[i];
+        ++avg_num;
+      }
+    }
+
+    if (avg_num == 0) /* still no history? fallback to current */
+    {
+      if (uc_get_rate_by_name(list->sensor_name, &values, &values_num)) {
+        ERROR("barometer: get_reference_temperature - rate \"%s\" lost",
+              list->sensor_name);
+        list->initialized = 0;
+        list->num_values = 0;
         list = list->next;
-    }  /* while sensor list */
-
-    if(*result == NAN)
-    {
-        ERROR("barometer: get_reference_temperature - no sensor available (yet?)");
-        return -1;
-    }
-    DEBUG ("barometer: get_reference_temperature - temp is %lf", *result);
-    return 0;
+        continue;
+      }
+
+      for (size_t i = 0; i < values_num; ++i) {
+        DEBUG("barometer: get_reference_temperature - rate last %zu: %lf **", i,
+              values[i]);
+        if (!isnan(values[i])) {
+          avg_sum += values[i];
+          ++avg_num;
+        }
+      }
+      free(values);
+      values = NULL;
+    }
+
+    if (avg_num == 0) {
+      ERROR("barometer: get_reference_temperature - could not read \"%s\"",
+            list->sensor_name);
+      list->initialized = 0;
+      list->num_values = 0;
+    } else {
+      average = avg_sum / (double)avg_num;
+      if (isnan(*result))
+        *result = average;
+      else if (*result > average)
+        *result = average;
+    }
+    list = list->next;
+  } /* while sensor list */
+
+  if (*result == NAN) {
+    ERROR("barometer: get_reference_temperature - no sensor available (yet?)");
+    return -1;
+  }
+  DEBUG("barometer: get_reference_temperature - temp is %lf", *result);
+  return 0;
 }
 
-
 /* ------------------------ MPL115 access ------------------------ */
 
 /**
  * Detect presence of a MPL115 pressure sensor.
  *
  * Unfortunately there seems to be no ID register so we just try to read first
  * conversion coefficient from device at MPL115 address and hope it is really
- * MPL115. We should use this check as the last resort (which would be the typical
+ * MPL115. We should use this check as the last resort (which would be the
+ * typical
  * case anyway since MPL115 is the least accurate sensor).
  * As a sideeffect will leave set I2C slave address.
  *
  * @return 1 if MPL115, 0 otherwise
  */
-static int MPL115_detect(void)
-{
-    __s32 res;
-    char errbuf[1024];
-
-    if (ioctl(i2c_bus_fd, I2C_SLAVE_FORCE, MPL115_I2C_ADDRESS) < 0)
-    {
-        ERROR("barometer: MPL115_detect problem setting i2c slave address to 0x%02X: %s",
-              MPL115_I2C_ADDRESS,
-              sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 0 ;
-    }
+static int MPL115_detect(void) {
+  __s32 res;
+  char errbuf[1024];
+
+  if (ioctl(i2c_bus_fd, I2C_SLAVE_FORCE, MPL115_I2C_ADDRESS) < 0) {
+    ERROR("barometer: MPL115_detect problem setting i2c slave address to "
+          "0x%02X: %s",
+          MPL115_I2C_ADDRESS, sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 0;
+  }
 
-    res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL115_ADDR_COEFFS);
-    if(res >= 0)
-    {
-        DEBUG ("barometer: MPL115_detect - positive detection");
-        return 1;
-    }
+  res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL115_ADDR_COEFFS);
+  if (res >= 0) {
+    DEBUG("barometer: MPL115_detect - positive detection");
+    return 1;
+  }
 
-    DEBUG ("barometer: MPL115_detect - negative detection");
-    return 0;
+  DEBUG("barometer: MPL115_detect - negative detection");
+  return 0;
 }
 
 /**
@@ -586,91 +545,84 @@ static int MPL115_detect(void)
  *
  * @return Zero when successful
  */
-static int MPL115_read_coeffs(void)
-{
-    uint8_t mpl115_coeffs[MPL115_NUM_COEFFS] = { 0 };
-    int32_t res;
-
-    int8_t  sia0MSB, sia0LSB, sib1MSB, sib1LSB, sib2MSB, sib2LSB;
-    int8_t  sic12MSB, sic12LSB, sic11MSB, sic11LSB, sic22MSB, sic22LSB;
-    int16_t sia0, sib1, sib2, sic12, sic11, sic22;
-
-    char errbuf[1024];
-
-    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
-                                        MPL115_ADDR_COEFFS,
-                                        STATIC_ARRAY_SIZE (mpl115_coeffs),
-                                        mpl115_coeffs);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL115_read_coeffs - problem reading data: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
-
-    /* Using perhaps less elegant/efficient code, but more readable. */
-    /* a0: 16total 1sign 12int 4fract 0pad */
-    sia0MSB = mpl115_coeffs[0];
-    sia0LSB = mpl115_coeffs[1];
-    sia0 = (int16_t) sia0MSB <<8;          /* s16 type, Shift to MSB */
-    sia0 += (int16_t) sia0LSB & 0x00FF;    /* Add LSB to 16bit number */
-    mpl115_coeffA0 = (double) (sia0);
-    mpl115_coeffA0 /= 8.0;                 /* 3 fract bits */
-
-    /* b1: 16total 1sign 2int 13fract 0pad */
-    sib1MSB= mpl115_coeffs[2];
-    sib1LSB= mpl115_coeffs[3];
-    sib1 = sib1MSB <<8;                    /* Shift to MSB */
-    sib1 += sib1LSB & 0x00FF;              /* Add LSB to 16bit number */
-    mpl115_coeffB1 = (double) (sib1);
-    mpl115_coeffB1 /= 8192.0;              /* 13 fract */
-
-    /* b2: 16total 1sign 1int 14fract 0pad */
-    sib2MSB= mpl115_coeffs[4];
-    sib2LSB= mpl115_coeffs[5];
-    sib2 = sib2MSB <<8;                     /* Shift to MSB */
-    sib2 += sib2LSB & 0x00FF;               /* Add LSB to 16bit number */
-    mpl115_coeffB2 = (double) (sib2);
-    mpl115_coeffB2 /= 16384.0;              /* 14 fract */
-
-    /* c12: 14total 1sign 0int 13fract 9pad */
-    sic12MSB= mpl115_coeffs[6];
-    sic12LSB= mpl115_coeffs[7];
-    sic12 = sic12MSB <<8;                   /* Shift to MSB only by 8 for MSB */
-    sic12 += sic12LSB & 0x00FF;
-    mpl115_coeffC12 = (double) (sic12);
-    mpl115_coeffC12 /= 4.0;                 /* 16-14=2 */
-    mpl115_coeffC12 /= 4194304.0;           /* 13+9=22 fract */
-
-    /* c11: 11total 1sign 0int 11fract 11pad */
-    sic11MSB= mpl115_coeffs[8];
-    sic11LSB= mpl115_coeffs[9];
-    sic11 = sic11MSB <<8;                   /* Shift to MSB only by 8 for MSB */
-    sic11 += sic11LSB & 0x00FF;
-    mpl115_coeffC11 = (double) (sic11);
-    mpl115_coeffC11 /= 32.0;               /* 16-11=5 */
-    mpl115_coeffC11 /= 4194304.0;          /* 11+11=22 fract */
-
-    /* c12: 11total 1sign 0int 10fract 15pad */
-    sic22MSB= mpl115_coeffs[10];
-    sic22LSB= mpl115_coeffs[11];
-    sic22 = sic22MSB <<8;                   /* Shift to MSB only by 8 for MSB */
-    sic22 += sic22LSB & 0x00FF;
-    mpl115_coeffC22 = (double) (sic22);
-    mpl115_coeffC22 /= 32.0; //16-11=5
-    mpl115_coeffC22 /= 33554432.0;          /* 10+15=25 fract */
-
-    DEBUG("barometer: MPL115_read_coeffs: a0=%lf, b1=%lf, b2=%lf, c12=%lf, c11=%lf, c22=%lf",
-          mpl115_coeffA0,
-          mpl115_coeffB1,
-          mpl115_coeffB2,
-          mpl115_coeffC12,
-          mpl115_coeffC11,
-          mpl115_coeffC22);
-    return 0;
+static int MPL115_read_coeffs(void) {
+  uint8_t mpl115_coeffs[MPL115_NUM_COEFFS] = {0};
+  int32_t res;
+
+  int8_t sia0MSB, sia0LSB, sib1MSB, sib1LSB, sib2MSB, sib2LSB;
+  int8_t sic12MSB, sic12LSB, sic11MSB, sic11LSB, sic22MSB, sic22LSB;
+  int16_t sia0, sib1, sib2, sic12, sic11, sic22;
+
+  char errbuf[1024];
+
+  res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, MPL115_ADDR_COEFFS,
+                                      STATIC_ARRAY_SIZE(mpl115_coeffs),
+                                      mpl115_coeffs);
+  if (res < 0) {
+    ERROR("barometer: MPL115_read_coeffs - problem reading data: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
+
+  /* Using perhaps less elegant/efficient code, but more readable. */
+  /* a0: 16total 1sign 12int 4fract 0pad */
+  sia0MSB = mpl115_coeffs[0];
+  sia0LSB = mpl115_coeffs[1];
+  sia0 = (int16_t)sia0MSB << 8;      /* s16 type, Shift to MSB */
+  sia0 += (int16_t)sia0LSB & 0x00FF; /* Add LSB to 16bit number */
+  mpl115_coeffA0 = (double)(sia0);
+  mpl115_coeffA0 /= 8.0; /* 3 fract bits */
+
+  /* b1: 16total 1sign 2int 13fract 0pad */
+  sib1MSB = mpl115_coeffs[2];
+  sib1LSB = mpl115_coeffs[3];
+  sib1 = sib1MSB << 8;      /* Shift to MSB */
+  sib1 += sib1LSB & 0x00FF; /* Add LSB to 16bit number */
+  mpl115_coeffB1 = (double)(sib1);
+  mpl115_coeffB1 /= 8192.0; /* 13 fract */
+
+  /* b2: 16total 1sign 1int 14fract 0pad */
+  sib2MSB = mpl115_coeffs[4];
+  sib2LSB = mpl115_coeffs[5];
+  sib2 = sib2MSB << 8;      /* Shift to MSB */
+  sib2 += sib2LSB & 0x00FF; /* Add LSB to 16bit number */
+  mpl115_coeffB2 = (double)(sib2);
+  mpl115_coeffB2 /= 16384.0; /* 14 fract */
+
+  /* c12: 14total 1sign 0int 13fract 9pad */
+  sic12MSB = mpl115_coeffs[6];
+  sic12LSB = mpl115_coeffs[7];
+  sic12 = sic12MSB << 8; /* Shift to MSB only by 8 for MSB */
+  sic12 += sic12LSB & 0x00FF;
+  mpl115_coeffC12 = (double)(sic12);
+  mpl115_coeffC12 /= 4.0;       /* 16-14=2 */
+  mpl115_coeffC12 /= 4194304.0; /* 13+9=22 fract */
+
+  /* c11: 11total 1sign 0int 11fract 11pad */
+  sic11MSB = mpl115_coeffs[8];
+  sic11LSB = mpl115_coeffs[9];
+  sic11 = sic11MSB << 8; /* Shift to MSB only by 8 for MSB */
+  sic11 += sic11LSB & 0x00FF;
+  mpl115_coeffC11 = (double)(sic11);
+  mpl115_coeffC11 /= 32.0;      /* 16-11=5 */
+  mpl115_coeffC11 /= 4194304.0; /* 11+11=22 fract */
+
+  /* c12: 11total 1sign 0int 10fract 15pad */
+  sic22MSB = mpl115_coeffs[10];
+  sic22LSB = mpl115_coeffs[11];
+  sic22 = sic22MSB << 8; /* Shift to MSB only by 8 for MSB */
+  sic22 += sic22LSB & 0x00FF;
+  mpl115_coeffC22 = (double)(sic22);
+  mpl115_coeffC22 /= 32.0;       // 16-11=5
+  mpl115_coeffC22 /= 33554432.0; /* 10+15=25 fract */
+
+  DEBUG("barometer: MPL115_read_coeffs: a0=%lf, b1=%lf, b2=%lf, c12=%lf, "
+        "c11=%lf, c22=%lf",
+        mpl115_coeffA0, mpl115_coeffB1, mpl115_coeffB2, mpl115_coeffC12,
+        mpl115_coeffC11, mpl115_coeffC22);
+  return 0;
 }
 
-
 /**
  * Convert raw adc values to real data using the sensor coefficients.
  *
@@ -679,24 +631,21 @@ static int MPL115_read_coeffs(void)
  * @param pressure     computed real pressure
  * @param temperature  computed real temperature
  */
-static void MPL115_convert_adc_to_real(double   adc_pressure,
-                                       double   adc_temp,
-                                       double * pressure,
-                                       double * temperature)
-{
-    double Pcomp;
-    Pcomp = mpl115_coeffA0 +                                            \
-        (mpl115_coeffB1 + mpl115_coeffC11*adc_pressure + mpl115_coeffC12*adc_temp) * adc_pressure + \
-        (mpl115_coeffB2 + mpl115_coeffC22*adc_temp) * adc_temp;
-
-    *pressure = ((1150.0-500.0) * Pcomp / 1023.0) + 500.0;
-    *temperature = (472.0 - adc_temp) / 5.35 + 25.0;
-    DEBUG ("barometer: MPL115_convert_adc_to_real - got %lf hPa, %lf C",
-           *pressure,
-           *temperature);
+static void MPL115_convert_adc_to_real(double adc_pressure, double adc_temp,
+                                       double *pressure, double *temperature) {
+  double Pcomp;
+  Pcomp = mpl115_coeffA0 +
+          (mpl115_coeffB1 + mpl115_coeffC11 * adc_pressure +
+           mpl115_coeffC12 * adc_temp) *
+              adc_pressure +
+          (mpl115_coeffB2 + mpl115_coeffC22 * adc_temp) * adc_temp;
+
+  *pressure = ((1150.0 - 500.0) * Pcomp / 1023.0) + 500.0;
+  *temperature = (472.0 - adc_temp) / 5.35 + 25.0;
+  DEBUG("barometer: MPL115_convert_adc_to_real - got %lf hPa, %lf C", *pressure,
+        *temperature);
 }
 
-
 /**
  * Read sensor averegaed measurements
  *
@@ -705,97 +654,82 @@ static void MPL115_convert_adc_to_real(double   adc_pressure,
  *
  * @return Zero when successful
  */
-static int MPL115_read_averaged(double * pressure, double * temperature)
-{
-    uint8_t mpl115_conv[MPL115_NUM_CONV] = { 0 };
-    int8_t  res;
-    int     retries;
-    int     conv_pressure;
-    int     conv_temperature;
-    double  adc_pressure;
-    double  adc_temperature;
-    char    errbuf[1024];
-
-    *pressure    = 0.0;
-    *temperature = 0.0;
-
-    /* start conversion of both temp and presure */
-    retries = MPL115_CONVERSION_RETRIES;
-    while (retries>0)
-    {
-        /* write 1 to start conversion */
-        res = i2c_smbus_write_byte_data (i2c_bus_fd,
-                                         MPL115_CMD_CONVERT_BOTH,
-                                         0x01);
-        if (res >= 0)
-            break;
-
-        --retries;
-        if(retries>0)
-        {
-            ERROR ("barometer: MPL115_read_averaged - requesting conversion: %s, " \
-                   "will retry at most %d more times",
-                   sstrerror (errno, errbuf, sizeof (errbuf)),
-                   retries);
-        }
-        else
-        {
-            ERROR ("barometer: MPL115_read_averaged - requesting conversion: %s, "\
-                   "too many failed retries",
-                   sstrerror (errno, errbuf, sizeof (errbuf)));
-            return -1;
-        }
-    }
-
-    usleep (10000); /* wait 10ms for the conversion */
-
-    retries=MPL115_CONVERSION_RETRIES;
-    while (retries>0)
-    {
-        res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
-                                            MPL115_ADDR_CONV,
-                                            STATIC_ARRAY_SIZE (mpl115_conv),
-                                            mpl115_conv);
-        if (res >= 0)
-            break;
-
-        --retries;
-        if (retries>0)
-        {
-            ERROR ("barometer: MPL115_read_averaged - reading conversion: %s, " \
-                   "will retry at most %d more times",
-                   sstrerror (errno, errbuf, sizeof (errbuf)),
-                   retries);
-        }
-        else
-        {
-            ERROR ("barometer: MPL115_read_averaged - reading conversion: %s, " \
-                   "too many failed retries",
-                   sstrerror (errno, errbuf, sizeof (errbuf)));
-            return -1;
-        }
-    }
-
-    conv_pressure    = ((mpl115_conv[0] << 8) | mpl115_conv[1]) >> 6;
-    conv_temperature = ((mpl115_conv[2] << 8) | mpl115_conv[3]) >> 6;
-    DEBUG ("barometer: MPL115_read_averaged, raw pressure ADC value = %d, " \
-           "raw temperature ADC value = %d",
-           conv_pressure,
-           conv_temperature);
-
-    adc_pressure    = averaging_add_sample (&pressure_averaging, conv_pressure);
-    adc_temperature = averaging_add_sample (&temperature_averaging, conv_temperature);
-
-    MPL115_convert_adc_to_real(adc_pressure, adc_temperature, pressure, temperature);
-
-    DEBUG ("barometer: MPL115_read_averaged - averaged ADC pressure = %lf / temperature = %lf, " \
-           "real pressure = %lf hPa / temperature = %lf C",
-           adc_pressure,
-           adc_temperature,
-           *pressure,
-           *temperature);
-
-    return 0;
+static int MPL115_read_averaged(double *pressure, double *temperature) {
+  uint8_t mpl115_conv[MPL115_NUM_CONV] = {0};
+  int8_t res;
+  int retries;
+  int conv_pressure;
+  int conv_temperature;
+  double adc_pressure;
+  double adc_temperature;
+  char errbuf[1024];
+
+  *pressure = 0.0;
+  *temperature = 0.0;
+
+  /* start conversion of both temp and presure */
+  retries = MPL115_CONVERSION_RETRIES;
+  while (retries > 0) {
+    /* write 1 to start conversion */
+    res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL115_CMD_CONVERT_BOTH, 0x01);
+    if (res >= 0)
+      break;
+
+    --retries;
+    if (retries > 0) {
+      ERROR("barometer: MPL115_read_averaged - requesting conversion: %s, "
+            "will retry at most %d more times",
+            sstrerror(errno, errbuf, sizeof(errbuf)), retries);
+    } else {
+      ERROR("barometer: MPL115_read_averaged - requesting conversion: %s, "
+            "too many failed retries",
+            sstrerror(errno, errbuf, sizeof(errbuf)));
+      return -1;
+    }
+  }
+
+  usleep(10000); /* wait 10ms for the conversion */
+
+  retries = MPL115_CONVERSION_RETRIES;
+  while (retries > 0) {
+    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, MPL115_ADDR_CONV,
+                                        STATIC_ARRAY_SIZE(mpl115_conv),
+                                        mpl115_conv);
+    if (res >= 0)
+      break;
+
+    --retries;
+    if (retries > 0) {
+      ERROR("barometer: MPL115_read_averaged - reading conversion: %s, "
+            "will retry at most %d more times",
+            sstrerror(errno, errbuf, sizeof(errbuf)), retries);
+    } else {
+      ERROR("barometer: MPL115_read_averaged - reading conversion: %s, "
+            "too many failed retries",
+            sstrerror(errno, errbuf, sizeof(errbuf)));
+      return -1;
+    }
+  }
+
+  conv_pressure = ((mpl115_conv[0] << 8) | mpl115_conv[1]) >> 6;
+  conv_temperature = ((mpl115_conv[2] << 8) | mpl115_conv[3]) >> 6;
+  DEBUG("barometer: MPL115_read_averaged, raw pressure ADC value = %d, "
+        "raw temperature ADC value = %d",
+        conv_pressure, conv_temperature);
+
+  adc_pressure = averaging_add_sample(&pressure_averaging, conv_pressure);
+  adc_temperature =
+      averaging_add_sample(&temperature_averaging, conv_temperature);
+
+  MPL115_convert_adc_to_real(adc_pressure, adc_temperature, pressure,
+                             temperature);
+
+  DEBUG("barometer: MPL115_read_averaged - averaged ADC pressure = %lf / "
+        "temperature = %lf, "
+        "real pressure = %lf hPa / temperature = %lf C",
+        adc_pressure, adc_temperature, *pressure, *temperature);
+
+  return 0;
 }
 
 /* ------------------------ MPL3115 access ------------------------ */
@@ -807,84 +741,65 @@ static int MPL115_read_averaged(double * pressure, double * temperature)
  *
  * @return 1 if MPL3115, 0 otherwise
  */
-static int MPL3115_detect(void)
-{
-    __s32 res;
-    char errbuf[1024];
+static int MPL3115_detect(void) {
+  __s32 res;
+  char errbuf[1024];
+
+  if (ioctl(i2c_bus_fd, I2C_SLAVE_FORCE, MPL3115_I2C_ADDRESS) < 0) {
+    ERROR("barometer: MPL3115_detect problem setting i2c slave address to "
+          "0x%02X: %s",
+          MPL3115_I2C_ADDRESS, sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 0;
+  }
 
-    if (ioctl(i2c_bus_fd, I2C_SLAVE_FORCE, MPL3115_I2C_ADDRESS) < 0)
-    {
-        ERROR("barometer: MPL3115_detect problem setting i2c slave address to 0x%02X: %s",
-              MPL3115_I2C_ADDRESS,
-              sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 0 ;
-    }
+  res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_WHO_AM_I);
+  if (res == MPL3115_WHO_AM_I_RESP) {
+    DEBUG("barometer: MPL3115_detect - positive detection");
+    return 1;
+  }
 
-    res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_WHO_AM_I);
-    if(res == MPL3115_WHO_AM_I_RESP)
-    {
-        DEBUG ("barometer: MPL3115_detect - positive detection");
-        return 1;
-    }
-
-    DEBUG ("barometer: MPL3115_detect - negative detection");
-    return 0;
+  DEBUG("barometer: MPL3115_detect - negative detection");
+  return 0;
 }
 
 /**
  * Adjusts oversampling to values supported by MPL3115
  *
  * MPL3115 supports only power of 2 in the range 1 to 128.
  */
-static void MPL3115_adjust_oversampling(void)
-{
-    int new_val = 0;
-
-    if(config_oversample > 100)
-    {
-        new_val = 128;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_128;
-    }
-    else if(config_oversample > 48)
-    {
-        new_val = 64;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_64;
-    }
-    else if(config_oversample > 24)
-    {
-        new_val = 32;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_32;
-    }
-    else if(config_oversample > 12)
-    {
-        new_val = 16;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_16;
-    }
-    else if(config_oversample > 6)
-    {
-        new_val = 8;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_8;
-    }
-    else if(config_oversample > 3)
-    {
-        new_val = 4;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_4;
-    }
-    else if(config_oversample > 1)
-    {
-        new_val = 2;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_2;
-    }
-    else
-    {
-        new_val = 1;
-        mpl3115_oversample = MPL3115_CTRL_REG1_OST_1;
-    }
-
-    DEBUG("barometer: MPL3115_adjust_oversampling - correcting oversampling from %d to %d",
-          config_oversample,
-          new_val);
-    config_oversample = new_val;
+static void MPL3115_adjust_oversampling(void) {
+  int new_val = 0;
+
+  if (config_oversample > 100) {
+    new_val = 128;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_128;
+  } else if (config_oversample > 48) {
+    new_val = 64;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_64;
+  } else if (config_oversample > 24) {
+    new_val = 32;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_32;
+  } else if (config_oversample > 12) {
+    new_val = 16;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_16;
+  } else if (config_oversample > 6) {
+    new_val = 8;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_8;
+  } else if (config_oversample > 3) {
+    new_val = 4;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_4;
+  } else if (config_oversample > 1) {
+    new_val = 2;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_2;
+  } else {
+    new_val = 1;
+    mpl3115_oversample = MPL3115_CTRL_REG1_OST_1;
+  }
+
+  DEBUG("barometer: MPL3115_adjust_oversampling - correcting oversampling from "
+        "%d to %d",
+        config_oversample, new_val);
+  config_oversample = new_val;
 }
 
 /**
@@ -895,162 +810,142 @@ static void MPL3115_adjust_oversampling(void)
  *
  * @return Zero when successful
  */
-static int MPL3115_read(double * pressure, double * temperature)
-{
-    __s32 res;
-    __s32 ctrl ;
-    __u8 data[MPL3115_NUM_CONV_VALS];
-    long int tmp_value = 0;
-    char errbuf[1024];
-
-    /* Set Active - activate the device from standby */
-    res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_CTRL_REG1);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_read - cannot read CTRL_REG1: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-    ctrl = res;
-    res = i2c_smbus_write_byte_data(i2c_bus_fd,
-                                    MPL3115_REG_CTRL_REG1,
-                                    ctrl | MPL3115_CTRL_REG1_SBYB);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_read - problem activating: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    /* base sleep is 5ms x OST */
-    usleep(5000 * config_oversample);
-
-    /* check the flags/status if ready */
+static int MPL3115_read(double *pressure, double *temperature) {
+  __s32 res;
+  __s32 ctrl;
+  __u8 data[MPL3115_NUM_CONV_VALS];
+  long int tmp_value = 0;
+  char errbuf[1024];
+
+  /* Set Active - activate the device from standby */
+  res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_CTRL_REG1);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_read - cannot read CTRL_REG1: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+  ctrl = res;
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_CTRL_REG1,
+                                  ctrl | MPL3115_CTRL_REG1_SBYB);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_read - problem activating: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  /* base sleep is 5ms x OST */
+  usleep(5000 * config_oversample);
+
+  /* check the flags/status if ready */
+  res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_STATUS);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_read - cannot read status register: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  while ((res & MPL3115_DR_STATUS_DR) != MPL3115_DR_STATUS_DR) {
+    /* try some extra sleep... */
+    usleep(10000);
+
+    /* ... and repeat the check. The conversion has to finish sooner or later.
+     */
     res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_STATUS);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_read - cannot read status register: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    while ((res & MPL3115_DR_STATUS_DR) != MPL3115_DR_STATUS_DR)
-    {
-        /* try some extra sleep... */
-        usleep(10000);
-
-        /* ... and repeat the check. The conversion has to finish sooner or later. */
-        res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_STATUS);
-        if (res < 0)
-        {
-            ERROR ("barometer: MPL3115_read - cannot read status register: %s",
-                   sstrerror (errno, errbuf, sizeof (errbuf)));
-            return 1;
-        }
-    }
-
-    /* Now read all the data in one block. There is address autoincrement. */
-    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
-                                        MPL3115_REG_OUT_P_MSB,
-                                        MPL3115_NUM_CONV_VALS,
-                                        data);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_read - cannot read data registers: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    tmp_value = (data[0] << 16) | (data[1] << 8) | data[2];
-    *pressure = ((double) tmp_value) / 4.0 / 16.0 / 100.0;
-    DEBUG ("barometer: MPL3115_read - absolute pressure = %lf hPa", *pressure);
-
-    if(data[3] > 0x7F)
-    {
-        data[3] = ~data[3] + 1;
-        *temperature = data[3];
-        *temperature = - *temperature;
-    }
-    else
-    {
-        *temperature = data[3];
-    }
-
-    *temperature += (double)(data[4]) / 256.0;
-    DEBUG ("barometer: MPL3115_read - temperature = %lf C", *temperature);
-
-    return 0;
+    if (res < 0) {
+      ERROR("barometer: MPL3115_read - cannot read status register: %s",
+            sstrerror(errno, errbuf, sizeof(errbuf)));
+      return 1;
+    }
+  }
+
+  /* Now read all the data in one block. There is address autoincrement. */
+  res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, MPL3115_REG_OUT_P_MSB,
+                                      MPL3115_NUM_CONV_VALS, data);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_read - cannot read data registers: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  tmp_value = (data[0] << 16) | (data[1] << 8) | data[2];
+  *pressure = ((double)tmp_value) / 4.0 / 16.0 / 100.0;
+  DEBUG("barometer: MPL3115_read - absolute pressure = %lf hPa", *pressure);
+
+  if (data[3] > 0x7F) {
+    data[3] = ~data[3] + 1;
+    *temperature = data[3];
+    *temperature = -*temperature;
+  } else {
+    *temperature = data[3];
+  }
+
+  *temperature += (double)(data[4]) / 256.0;
+  DEBUG("barometer: MPL3115_read - temperature = %lf C", *temperature);
+
+  return 0;
 }
 
 /**
  * Initialize MPL3115 for barometeric measurements
  *
  * @return 0 if successful
  */
-static int MPL3115_init_sensor(void)
-{
-    __s32 res;
-    __s8 offset;
-    char errbuf[1024];
-
-    /* Reset the sensor. It will reset immediately without ACKing */
-    /* the transaction, so no error handling here. */
-    i2c_smbus_write_byte_data(i2c_bus_fd,
-                              MPL3115_REG_CTRL_REG1,
-                              MPL3115_CTRL_REG1_RST);
-
-    /* wait some time for the reset to finish */
-    usleep(100000);
-
-    /* now it should be in standby already so we can go and configure it */
-
-    /*  Set temperature offset. */
-    /*  result = ADCtemp + offset [C] */
-    offset = (__s8) (config_temp_offset * 16.0);
-    res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_OFF_T, offset);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_init_sensor - problem setting temp offset: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
-
-    /*  Set pressure offset. */
-    /*  result = ADCpress + offset [hPa] */
-    offset = (__s8) (config_press_offset * 100.0 / 4.0);
-    res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_OFF_P, offset);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_init_sensor - problem setting pressure offset: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
-
-    /* Enable Data Flags in PT_DATA_CFG - flags on both pressure and temp */
-    res = i2c_smbus_write_byte_data(i2c_bus_fd,
-                                    MPL3115_REG_PT_DATA_CFG,
-                                    MPL3115_PT_DATA_DREM        \
-                                    | MPL3115_PT_DATA_PDEF      \
-                                    | MPL3115_PT_DATA_TDEF);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_init_sensor - problem setting PT_DATA_CFG: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
-
-    /* Set to barometer with an OSR */
-    res = i2c_smbus_write_byte_data(i2c_bus_fd,
-                                    MPL3115_REG_CTRL_REG1,
-                                    mpl3115_oversample);
-    if (res < 0)
-    {
-        ERROR ("barometer: MPL3115_init_sensor - problem configuring CTRL_REG1: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
-
-    return 0;
+static int MPL3115_init_sensor(void) {
+  __s32 res;
+  __s8 offset;
+  char errbuf[1024];
+
+  /* Reset the sensor. It will reset immediately without ACKing */
+  /* the transaction, so no error handling here. */
+  i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_CTRL_REG1,
+                            MPL3115_CTRL_REG1_RST);
+
+  /* wait some time for the reset to finish */
+  usleep(100000);
+
+  /* now it should be in standby already so we can go and configure it */
+
+  /*  Set temperature offset. */
+  /*  result = ADCtemp + offset [C] */
+  offset = (__s8)(config_temp_offset * 16.0);
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_OFF_T, offset);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_init_sensor - problem setting temp offset: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
+
+  /*  Set pressure offset. */
+  /*  result = ADCpress + offset [hPa] */
+  offset = (__s8)(config_press_offset * 100.0 / 4.0);
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_OFF_P, offset);
+  if (res < 0) {
+    ERROR(
+        "barometer: MPL3115_init_sensor - problem setting pressure offset: %s",
+        sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
+
+  /* Enable Data Flags in PT_DATA_CFG - flags on both pressure and temp */
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_PT_DATA_CFG,
+                                  MPL3115_PT_DATA_DREM | MPL3115_PT_DATA_PDEF |
+                                      MPL3115_PT_DATA_TDEF);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_init_sensor - problem setting PT_DATA_CFG: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
+
+  /* Set to barometer with an OSR */
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_CTRL_REG1,
+                                  mpl3115_oversample);
+  if (res < 0) {
+    ERROR("barometer: MPL3115_init_sensor - problem configuring CTRL_REG1: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
+
+  return 0;
 }
 
 /* ------------------------ BMP085 access ------------------------ */
@@ -1062,142 +957,117 @@ static int MPL3115_init_sensor(void)
  *
  * @return 1 if BMP085, 0 otherwise
  */
-static int BMP085_detect(void)
-{
-    __s32 res;
-    char errbuf[1024];
-
-    if (ioctl(i2c_bus_fd, I2C_SLAVE_FORCE, BMP085_I2C_ADDRESS) < 0)
-    {
-        ERROR("barometer: BMP085_detect - problem setting i2c slave address to 0x%02X: %s",
-              BMP085_I2C_ADDRESS,
-              sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 0 ;
-    }
-
-    res = i2c_smbus_read_byte_data(i2c_bus_fd, BMP085_ADDR_ID_REG);
-    if(res == BMP085_CHIP_ID)
-    {
-        DEBUG ("barometer: BMP085_detect - positive detection");
-
-        /* get version */
-        res = i2c_smbus_read_byte_data(i2c_bus_fd, BMP085_ADDR_VERSION );
-        if (res < 0)
-        {
-            ERROR("barometer: BMP085_detect - problem checking chip version: %s",
-                  sstrerror (errno, errbuf, sizeof (errbuf)));
-            return 0 ;
-        }
-        DEBUG ("barometer: BMP085_detect - chip version ML:0x%02X AL:0x%02X",
-               res & 0x0f,
-               (res & 0xf0) >> 4);
-        return 1;
-    }
-
-    DEBUG ("barometer: BMP085_detect - negative detection");
+static int BMP085_detect(void) {
+  __s32 res;
+  char errbuf[1024];
+
+  if (ioctl(i2c_bus_fd, I2C_SLAVE_FORCE, BMP085_I2C_ADDRESS) < 0) {
+    ERROR("barometer: BMP085_detect - problem setting i2c slave address to "
+          "0x%02X: %s",
+          BMP085_I2C_ADDRESS, sstrerror(errno, errbuf, sizeof(errbuf)));
     return 0;
+  }
+
+  res = i2c_smbus_read_byte_data(i2c_bus_fd, BMP085_ADDR_ID_REG);
+  if (res == BMP085_CHIP_ID) {
+    DEBUG("barometer: BMP085_detect - positive detection");
+
+    /* get version */
+    res = i2c_smbus_read_byte_data(i2c_bus_fd, BMP085_ADDR_VERSION);
+    if (res < 0) {
+      ERROR("barometer: BMP085_detect - problem checking chip version: %s",
+            sstrerror(errno, errbuf, sizeof(errbuf)));
+      return 0;
+    }
+    DEBUG("barometer: BMP085_detect - chip version ML:0x%02X AL:0x%02X",
+          res & 0x0f, (res & 0xf0) >> 4);
+    return 1;
+  }
+
+  DEBUG("barometer: BMP085_detect - negative detection");
+  return 0;
 }
 
-
 /**
  * Adjusts oversampling settings to values supported by BMP085
  *
  * BMP085 supports only 1,2,4 or 8 samples.
  */
-static void BMP085_adjust_oversampling(void)
-{
-    int new_val = 0;
-
-    if( config_oversample > 6 ) /* 8 */
-    {
-        new_val = 8;
-        bmp085_oversampling = 3;
-        bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_3;
-        bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_3;
-    }
-    else if( config_oversample > 3 ) /* 4 */
-    {
-        new_val = 4;
-        bmp085_oversampling = 2;
-        bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_2;
-        bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_2;
-    }
-    else if( config_oversample > 1 ) /* 2 */
-    {
-        new_val = 2;
-        bmp085_oversampling = 1;
-        bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_1;
-        bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_1;
-    }
-    else /* 1 */
-    {
-        new_val = 1;
-        bmp085_oversampling = 0;
-        bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_0;
-        bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_0;
-    }
-
-    DEBUG("barometer: BMP085_adjust_oversampling - correcting oversampling from %d to %d",
-          config_oversample,
-          new_val);
-    config_oversample = new_val;
+static void BMP085_adjust_oversampling(void) {
+  int new_val = 0;
+
+  if (config_oversample > 6) /* 8 */
+  {
+    new_val = 8;
+    bmp085_oversampling = 3;
+    bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_3;
+    bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_3;
+  } else if (config_oversample > 3) /* 4 */
+  {
+    new_val = 4;
+    bmp085_oversampling = 2;
+    bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_2;
+    bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_2;
+  } else if (config_oversample > 1) /* 2 */
+  {
+    new_val = 2;
+    bmp085_oversampling = 1;
+    bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_1;
+    bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_1;
+  } else /* 1 */
+  {
+    new_val = 1;
+    bmp085_oversampling = 0;
+    bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_0;
+    bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_0;
+  }
+
+  DEBUG("barometer: BMP085_adjust_oversampling - correcting oversampling from "
+        "%d to %d",
+        config_oversample, new_val);
+  config_oversample = new_val;
 }
 
-
 /**
  * Read the BMP085 sensor conversion coefficients.
  *
  * These are (device specific) constants so we can read them just once.
  *
  * @return Zero when successful
  */
-static int BMP085_read_coeffs(void)
-{
-    __s32 res;
-    __u8 coeffs[BMP085_NUM_COEFFS];
-    char errbuf[1024];
-
-    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
-                                        BMP085_ADDR_COEFFS,
-                                        BMP085_NUM_COEFFS,
-                                        coeffs);
-    if (res < 0)
-    {
-        ERROR ("barometer: BMP085_read_coeffs - problem reading data: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
-
-    bmp085_AC1 = ((int16_t)  coeffs[0]  <<8) | (int16_t)  coeffs[1];
-    bmp085_AC2 = ((int16_t)  coeffs[2]  <<8) | (int16_t)  coeffs[3];
-    bmp085_AC3 = ((int16_t)  coeffs[4]  <<8) | (int16_t)  coeffs[5];
-    bmp085_AC4 = ((uint16_t) coeffs[6]  <<8) | (uint16_t) coeffs[7];
-    bmp085_AC5 = ((uint16_t) coeffs[8]  <<8) | (uint16_t) coeffs[9];
-    bmp085_AC6 = ((uint16_t) coeffs[10] <<8) | (uint16_t) coeffs[11];
-    bmp085_B1 =  ((int16_t)  coeffs[12] <<8) | (int16_t)  coeffs[13];
-    bmp085_B2 =  ((int16_t)  coeffs[14] <<8) | (int16_t)  coeffs[15];
-    bmp085_MB =  ((int16_t)  coeffs[16] <<8) | (int16_t)  coeffs[17];
-    bmp085_MC =  ((int16_t)  coeffs[18] <<8) | (int16_t)  coeffs[19];
-    bmp085_MD =  ((int16_t)  coeffs[20] <<8) | (int16_t)  coeffs[21];
-
-    DEBUG("barometer: BMP085_read_coeffs - AC1=%d, AC2=%d, AC3=%d, AC4=%u,"\
-          " AC5=%u, AC6=%u, B1=%d, B2=%d, MB=%d, MC=%d, MD=%d",
-          bmp085_AC1,
-          bmp085_AC2,
-          bmp085_AC3,
-          bmp085_AC4,
-          bmp085_AC5,
-          bmp085_AC6,
-          bmp085_B1,
-          bmp085_B2,
-          bmp085_MB,
-          bmp085_MC,
-          bmp085_MD);
-
-    return 0;
+static int BMP085_read_coeffs(void) {
+  __s32 res;
+  __u8 coeffs[BMP085_NUM_COEFFS];
+  char errbuf[1024];
+
+  res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, BMP085_ADDR_COEFFS,
+                                      BMP085_NUM_COEFFS, coeffs);
+  if (res < 0) {
+    ERROR("barometer: BMP085_read_coeffs - problem reading data: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
+
+  bmp085_AC1 = ((int16_t)coeffs[0] << 8) | (int16_t)coeffs[1];
+  bmp085_AC2 = ((int16_t)coeffs[2] << 8) | (int16_t)coeffs[3];
+  bmp085_AC3 = ((int16_t)coeffs[4] << 8) | (int16_t)coeffs[5];
+  bmp085_AC4 = ((uint16_t)coeffs[6] << 8) | (uint16_t)coeffs[7];
+  bmp085_AC5 = ((uint16_t)coeffs[8] << 8) | (uint16_t)coeffs[9];
+  bmp085_AC6 = ((uint16_t)coeffs[10] << 8) | (uint16_t)coeffs[11];
+  bmp085_B1 = ((int16_t)coeffs[12] << 8) | (int16_t)coeffs[13];
+  bmp085_B2 = ((int16_t)coeffs[14] << 8) | (int16_t)coeffs[15];
+  bmp085_MB = ((int16_t)coeffs[16] << 8) | (int16_t)coeffs[17];
+  bmp085_MC = ((int16_t)coeffs[18] << 8) | (int16_t)coeffs[19];
+  bmp085_MD = ((int16_t)coeffs[20] << 8) | (int16_t)coeffs[21];
+
+  DEBUG("barometer: BMP085_read_coeffs - AC1=%d, AC2=%d, AC3=%d, AC4=%u,"
+        " AC5=%u, AC6=%u, B1=%d, B2=%d, MB=%d, MC=%d, MD=%d",
+        bmp085_AC1, bmp085_AC2, bmp085_AC3, bmp085_AC4, bmp085_AC5, bmp085_AC6,
+        bmp085_B1, bmp085_B2, bmp085_MB, bmp085_MC, bmp085_MD);
+
+  return 0;
 }
 
-
 /**
  * Convert raw BMP085 adc values to real data using the sensor coefficients.
  *
@@ -1206,67 +1076,60 @@ static int BMP085_read_coeffs(void)
  * @param pressure     computed real pressure
  * @param temperature  computed real temperature
  */
-static void BMP085_convert_adc_to_real(long adc_pressure,
-                                       long adc_temperature,
-                                       double * pressure,
-                                       double * temperature)
+static void BMP085_convert_adc_to_real(long adc_pressure, long adc_temperature,
+                                       double *pressure, double *temperature)
 
 {
-    long X1, X2, X3;
-    long B3, B5, B6;
-    unsigned long B4, B7;
-
-    long T;
-    long P;
-
-
-    /* calculate real temperature */
-    X1 = ( (adc_temperature - bmp085_AC6) * bmp085_AC5) >> 15;
-    X2 = (bmp085_MC << 11) / (X1 + bmp085_MD);
-
-    /* B5, T */
-    B5 = X1 + X2;
-    T = (B5 + 8) >> 4;
-    *temperature = (double)T * 0.1;
-
-    /* calculate real pressure */
-    /* in general X1, X2, X3 are recycled while values of B3, B4, B5, B6 are kept */
-
-    /* B6, B3 */
-    B6 = B5 - 4000;
-    X1 = ((bmp085_B2 * ((B6 * B6)>>12)) >> 11 );
-    X2 = (((long)bmp085_AC2 * B6) >> 11);
-    X3 = X1 + X2;
-    B3 = (((((long)bmp085_AC1 * 4) + X3) << bmp085_oversampling) + 2) >> 2;
-
-    /* B4 */
-    X1 = (((long)bmp085_AC3*B6) >> 13);
-    X2 = (bmp085_B1*((B6*B6) >> 12) ) >> 16;
-    X3 = ((X1 + X2) + 2 ) >> 2;
-    B4 = ((long)bmp085_AC4* (unsigned long)(X3 + 32768)) >> 15;
-
-    /* B7, P */
-    B7 =  (unsigned long)(adc_pressure - B3)*(50000>>bmp085_oversampling);
-    if( B7 < 0x80000000 )
-    {
-        P = (B7 << 1) / B4;
-    }
-    else
-    {
-        P = (B7/B4) << 1;
-    }
-    X1 = (P >> 8) * (P >> 8);
-    X1 = (X1 * 3038) >> 16;
-    X2 = ((-7357) * P) >> 16;
-    P = P + ( ( X1 + X2 + 3791 ) >> 4);
-
-    *pressure = P / 100.0; // in [hPa]
-    DEBUG ("barometer: BMP085_convert_adc_to_real - got %lf hPa, %lf C",
-           *pressure,
-           *temperature);
+  long X1, X2, X3;
+  long B3, B5, B6;
+  unsigned long B4, B7;
+
+  long T;
+  long P;
+
+  /* calculate real temperature */
+  X1 = ((adc_temperature - bmp085_AC6) * bmp085_AC5) >> 15;
+  X2 = (bmp085_MC << 11) / (X1 + bmp085_MD);
+
+  /* B5, T */
+  B5 = X1 + X2;
+  T = (B5 + 8) >> 4;
+  *temperature = (double)T * 0.1;
+
+  /* calculate real pressure */
+  /* in general X1, X2, X3 are recycled while values of B3, B4, B5, B6 are kept
+   */
+
+  /* B6, B3 */
+  B6 = B5 - 4000;
+  X1 = ((bmp085_B2 * ((B6 * B6) >> 12)) >> 11);
+  X2 = (((long)bmp085_AC2 * B6) >> 11);
+  X3 = X1 + X2;
+  B3 = (((((long)bmp085_AC1 * 4) + X3) << bmp085_oversampling) + 2) >> 2;
+
+  /* B4 */
+  X1 = (((long)bmp085_AC3 * B6) >> 13);
+  X2 = (bmp085_B1 * ((B6 * B6) >> 12)) >> 16;
+  X3 = ((X1 + X2) + 2) >> 2;
+  B4 = ((long)bmp085_AC4 * (unsigned long)(X3 + 32768)) >> 15;
+
+  /* B7, P */
+  B7 = (unsigned long)(adc_pressure - B3) * (50000 >> bmp085_oversampling);
+  if (B7 < 0x80000000) {
+    P = (B7 << 1) / B4;
+  } else {
+    P = (B7 / B4) << 1;
+  }
+  X1 = (P >> 8) * (P >> 8);
+  X1 = (X1 * 3038) >> 16;
+  X2 = ((-7357) * P) >> 16;
+  P = P + ((X1 + X2 + 3791) >> 4);
+
+  *pressure = P / 100.0; // in [hPa]
+  DEBUG("barometer: BMP085_convert_adc_to_real - got %lf hPa, %lf C", *pressure,
+        *temperature);
 }
 
-
 /**
  * Read compensated sensor measurements
  *
@@ -1275,82 +1138,70 @@ static void BMP085_convert_adc_to_real(long adc_pressure,
  *
  * @return Zero when successful
  */
-static int BMP085_read(double * pressure, double * temperature)
-{
-    __s32 res;
-    __u8 measBuff[3];
-
-    long adc_pressure;
-    long adc_temperature;
-
-    char errbuf[1024];
-
-    /* start conversion of temperature */
-    res = i2c_smbus_write_byte_data( i2c_bus_fd,
-                                     BMP085_ADDR_CTRL_REG,
-                                     BMP085_CMD_CONVERT_TEMP );
-    if (res < 0)
-    {
-        ERROR ("barometer: BMP085_read - problem requesting temperature conversion: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    usleep(BMP085_TIME_CNV_TEMP); /* wait for the conversion */
-
-    res = i2c_smbus_read_i2c_block_data( i2c_bus_fd,
-                                         BMP085_ADDR_CONV,
-                                         2,
-                                         measBuff);
-    if (res < 0)
-    {
-        ERROR ("barometer: BMP085_read - problem reading temperature data: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    adc_temperature = ( (unsigned short)measBuff[0] << 8 ) + measBuff[1];
-
-
-    /* get presure */
-    res = i2c_smbus_write_byte_data( i2c_bus_fd,
-                                     BMP085_ADDR_CTRL_REG,
-                                     bmp085_cmdCnvPress );
-    if (res < 0)
-    {
-        ERROR ("barometer: BMP085_read - problem requesting pressure conversion: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    usleep(bmp085_timeCnvPress); /* wait for the conversion */
-
-    res = i2c_smbus_read_i2c_block_data( i2c_bus_fd,
-                                         BMP085_ADDR_CONV,
-                                         3,
-                                         measBuff );
-    if (res < 0)
-    {
-        ERROR ("barometer: BMP085_read - problem reading pressure data: %s",
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return 1;
-    }
-
-    adc_pressure = (long)((((ulong)measBuff[0]<<16) | ((ulong)measBuff[1]<<8) | (ulong)measBuff[2] ) >> (8 - bmp085_oversampling));
-
-
-    DEBUG ("barometer: BMP085_read - raw pressure ADC value = %ld, " \
-           "raw temperature ADC value = %ld",
-           adc_pressure,
-           adc_temperature);
-
-    BMP085_convert_adc_to_real(adc_pressure, adc_temperature, pressure, temperature);
-
-    return 0;
+static int BMP085_read(double *pressure, double *temperature) {
+  __s32 res;
+  __u8 measBuff[3];
+
+  long adc_pressure;
+  long adc_temperature;
+
+  char errbuf[1024];
+
+  /* start conversion of temperature */
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, BMP085_ADDR_CTRL_REG,
+                                  BMP085_CMD_CONVERT_TEMP);
+  if (res < 0) {
+    ERROR("barometer: BMP085_read - problem requesting temperature conversion: "
+          "%s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  usleep(BMP085_TIME_CNV_TEMP); /* wait for the conversion */
+
+  res =
+      i2c_smbus_read_i2c_block_data(i2c_bus_fd, BMP085_ADDR_CONV, 2, measBuff);
+  if (res < 0) {
+    ERROR("barometer: BMP085_read - problem reading temperature data: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  adc_temperature = ((unsigned short)measBuff[0] << 8) + measBuff[1];
+
+  /* get presure */
+  res = i2c_smbus_write_byte_data(i2c_bus_fd, BMP085_ADDR_CTRL_REG,
+                                  bmp085_cmdCnvPress);
+  if (res < 0) {
+    ERROR("barometer: BMP085_read - problem requesting pressure conversion: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  usleep(bmp085_timeCnvPress); /* wait for the conversion */
+
+  res =
+      i2c_smbus_read_i2c_block_data(i2c_bus_fd, BMP085_ADDR_CONV, 3, measBuff);
+  if (res < 0) {
+    ERROR("barometer: BMP085_read - problem reading pressure data: %s",
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return 1;
+  }
+
+  adc_pressure = (long)((((ulong)measBuff[0] << 16) |
+                         ((ulong)measBuff[1] << 8) | (ulong)measBuff[2]) >>
+                        (8 - bmp085_oversampling));
+
+  DEBUG("barometer: BMP085_read - raw pressure ADC value = %ld, "
+        "raw temperature ADC value = %ld",
+        adc_pressure, adc_temperature);
+
+  BMP085_convert_adc_to_real(adc_pressure, adc_temperature, pressure,
+                             temperature);
+
+  return 0;
 }
 
-
-
 /* ------------------------ Sensor detection ------------------------ */
 /**
  * Detect presence of a supported sensor.
@@ -1361,18 +1212,17 @@ static int BMP085_read(double * pressure, double * temperature)
  *
  * @return detected sensor type
  */
-static enum Sensor_type detect_sensor_type(void)
-{
-    if(BMP085_detect())
-        return Sensor_BMP085;
+static enum Sensor_type detect_sensor_type(void) {
+  if (BMP085_detect())
+    return Sensor_BMP085;
 
-    else if(MPL3115_detect())
-        return Sensor_MPL3115;
+  else if (MPL3115_detect())
+    return Sensor_MPL3115;
 
-    else if(MPL115_detect())
-        return Sensor_MPL115;
+  else if (MPL115_detect())
+    return Sensor_MPL115;
 
-    return Sensor_none;
+  return Sensor_none;
 }
 
 /* ------------------------ Common functionality ------------------------ */
@@ -1383,7 +1233,8 @@ static enum Sensor_type detect_sensor_type(void)
  * Implemented methods are:
  * - MSLP_NONE - no converions, returns absolute pressure
  *
- * - MSLP_INTERNATIONAL - see http://en.wikipedia.org/wiki/Atmospheric_pressure#Altitude_atmospheric_pressure_variation
+ * - MSLP_INTERNATIONAL - see
+ * http://en.wikipedia.org/wiki/Atmospheric_pressure#Altitude_atmospheric_pressure_variation
  *           Requires #config_altitude
  *
  * - MSLP_DEU_WETT - formula as recommended by the Deutsche Wetterdienst. See
@@ -1394,58 +1245,54 @@ static enum Sensor_type detect_sensor_type(void)
  *
  * @return mean sea level pressure if successful, NAN otherwise
  */
-static double abs_to_mean_sea_level_pressure(double abs_pressure)
-{
-    double mean = -1.0;
-    double temp = 0.0;
-    int result = 0;
+static double abs_to_mean_sea_level_pressure(double abs_pressure) {
+  double mean = -1.0;
+  double temp = 0.0;
+  int result = 0;
 
-    if (config_normalize >= MSLP_DEU_WETT)
-    {
-        result = get_reference_temperature(&temp);
-        if(result)
-        {
-            return NAN;
-        }
+  if (config_normalize >= MSLP_DEU_WETT) {
+    result = get_reference_temperature(&temp);
+    if (result) {
+      return NAN;
     }
+  }
 
-    switch(config_normalize)
-    {
-    case MSLP_NONE:
-        mean = abs_pressure;
-        break;
-
-    case MSLP_INTERNATIONAL:
-        mean = abs_pressure / \
-            pow(1.0 - 0.0065*config_altitude/288.15, 9.80665*0.0289644/(8.31447*0.0065));
-        break;
+  switch (config_normalize) {
+  case MSLP_NONE:
+    mean = abs_pressure;
+    break;
 
-    case MSLP_DEU_WETT:
-    {
-        double E; /* humidity */
-        double x;
-        if(temp<9.1)
-            E = 5.6402 * (-0.0916 + exp(0.06*temp) );
-        else
-            E = 18.2194 * (1.0463 - exp(-0.0666*temp) );
-        x = 9.80665 / (287.05 * (temp+273.15 + 0.12*E + 0.0065*config_altitude/2)) * config_altitude;
-        mean = abs_pressure * exp(x);
-    }
+  case MSLP_INTERNATIONAL:
+    mean = abs_pressure / pow(1.0 - 0.0065 * config_altitude / 288.15,
+                              9.80665 * 0.0289644 / (8.31447 * 0.0065));
     break;
 
-    default:
-        ERROR ("barometer: abs_to_mean_sea_level_pressure: wrong conversion method %d",
-               config_normalize);
-        mean = abs_pressure;
-        break;
-    }
+  case MSLP_DEU_WETT: {
+    double E; /* humidity */
+    double x;
+    if (temp < 9.1)
+      E = 5.6402 * (-0.0916 + exp(0.06 * temp));
+    else
+      E = 18.2194 * (1.0463 - exp(-0.0666 * temp));
+    x = 9.80665 /
+        (287.05 * (temp + 273.15 + 0.12 * E + 0.0065 * config_altitude / 2)) *
+        config_altitude;
+    mean = abs_pressure * exp(x);
+  } break;
+
+  default:
+    ERROR(
+        "barometer: abs_to_mean_sea_level_pressure: wrong conversion method %d",
+        config_normalize);
+    mean = abs_pressure;
+    break;
+  }
 
-    DEBUG ("barometer: abs_to_mean_sea_level_pressure: absPressure = %lf hPa, method = %d, meanPressure = %lf hPa",
-           abs_pressure,
-           config_normalize,
-           mean);
+  DEBUG("barometer: abs_to_mean_sea_level_pressure: absPressure = %lf hPa, "
+        "method = %d, meanPressure = %lf hPa",
+        abs_pressure, config_normalize, mean);
 
-    return mean;
+  return mean;
 }
 
 /* ------------------------ main plugin callbacks ------------------------ */
@@ -1458,96 +1305,73 @@ static double abs_to_mean_sea_level_pressure(double abs_pressure)
  *
  * @return Zero when successful.
  */
-static int collectd_barometer_config (const char *key, const char *value)
-{
-    DEBUG("barometer: collectd_barometer_config");
-
-    if (strcasecmp (key, "Device") == 0)
-    {
-        sfree (config_device);
-        config_device = strdup (value);
-    }
-    else if (strcasecmp (key, "Oversampling") == 0)
-    {
-        int oversampling_tmp = atoi (value);
-        if (oversampling_tmp < 1 || oversampling_tmp > 1024)
-        {
-            WARNING ("barometer: collectd_barometer_config: invalid oversampling: %d." \
-                     " Allowed values are 1 to 1024 (for MPL115) or 1 to 128 (for MPL3115) or 1 to 8 (for BMP085).",
-                     oversampling_tmp);
-            return 1;
-        }
-        config_oversample = oversampling_tmp;
-    }
-    else if (strcasecmp (key, "Altitude") == 0)
-    {
-        config_altitude = atof (value);
-    }
-    else if (strcasecmp (key, "Normalization") == 0)
-    {
-        int normalize_tmp = atoi (value);
-        if (normalize_tmp < 0 || normalize_tmp > 2)
-        {
-            WARNING ("barometer: collectd_barometer_config: invalid normalization: %d",
-                     normalize_tmp);
-            return 1;
-        }
-        config_normalize = normalize_tmp;
-    }
-    else if (strcasecmp (key, "TemperatureSensor") == 0)
-    {
-        if(temp_list_add(temp_list, value))
-        {
-            return -1;
-        }
-    }
-    else if (strcasecmp (key, "PressureOffset") == 0)
-    {
-        config_press_offset = atof(value);
-    }
-    else if (strcasecmp (key, "TemperatureOffset") == 0)
-    {
-        config_temp_offset = atof(value);
-    }
-    else
-    {
-        return -1;
-    }
-
-    return 0;
+static int collectd_barometer_config(const char *key, const char *value) {
+  DEBUG("barometer: collectd_barometer_config");
+
+  if (strcasecmp(key, "Device") == 0) {
+    sfree(config_device);
+    config_device = strdup(value);
+  } else if (strcasecmp(key, "Oversampling") == 0) {
+    int oversampling_tmp = atoi(value);
+    if (oversampling_tmp < 1 || oversampling_tmp > 1024) {
+      WARNING("barometer: collectd_barometer_config: invalid oversampling: %d."
+              " Allowed values are 1 to 1024 (for MPL115) or 1 to 128 (for "
+              "MPL3115) or 1 to 8 (for BMP085).",
+              oversampling_tmp);
+      return 1;
+    }
+    config_oversample = oversampling_tmp;
+  } else if (strcasecmp(key, "Altitude") == 0) {
+    config_altitude = atof(value);
+  } else if (strcasecmp(key, "Normalization") == 0) {
+    int normalize_tmp = atoi(value);
+    if (normalize_tmp < 0 || normalize_tmp > 2) {
+      WARNING("barometer: collectd_barometer_config: invalid normalization: %d",
+              normalize_tmp);
+      return 1;
+    }
+    config_normalize = normalize_tmp;
+  } else if (strcasecmp(key, "TemperatureSensor") == 0) {
+    if (temp_list_add(temp_list, value)) {
+      return -1;
+    }
+  } else if (strcasecmp(key, "PressureOffset") == 0) {
+    config_press_offset = atof(value);
+  } else if (strcasecmp(key, "TemperatureOffset") == 0) {
+    config_temp_offset = atof(value);
+  } else {
+    return -1;
+  }
+
+  return 0;
 }
 
-
 /**
  * Shutdown callback.
  *
  * Close I2C and delete all the buffers.
  *
  * @return Zero when successful (at the moment the only possible outcome)
  */
-static int collectd_barometer_shutdown(void)
-{
-    DEBUG ("barometer: collectd_barometer_shutdown");
+static int collectd_barometer_shutdown(void) {
+  DEBUG("barometer: collectd_barometer_shutdown");
 
-    if(sensor_type == Sensor_MPL115)
-    {
-        averaging_delete (&pressure_averaging);
-        averaging_delete (&temperature_averaging);
+  if (sensor_type == Sensor_MPL115) {
+    averaging_delete(&pressure_averaging);
+    averaging_delete(&temperature_averaging);
 
-        temp_list_delete(&temp_list);
-    }
+    temp_list_delete(&temp_list);
+  }
 
-    if (i2c_bus_fd > 0)
-    {
-        close (i2c_bus_fd);
-        i2c_bus_fd = -1;
-        sfree (config_device);
-    }
+  if (i2c_bus_fd > 0) {
+    close(i2c_bus_fd);
+    i2c_bus_fd = -1;
+    sfree(config_device);
+  }
 
-    return 0;
+  return 0;
 }
 
-
 /**
  * Plugin read callback for MPL115.
  *
@@ -1558,76 +1382,72 @@ static int collectd_barometer_shutdown(void)
  *
  * @return Zero when successful.
  */
-static int MPL115_collectd_barometer_read (void)
-{
-    int result = 0;
-
-    double pressure        = 0.0;
-    double temperature     = 0.0;
-    double norm_pressure   = 0.0;
-
-    value_list_t vl = VALUE_LIST_INIT;
-    value_t      values[1];
-
-    DEBUG("barometer: MPL115_collectd_barometer_read");
-
-    if (!configured)
-    {
-        return -1;
-    }
-
-    /* Rather than delaying init, we will intitialize during first read. This
-       way at least we have a better chance to have the reference temperature
-       already available. */
-    if(!avg_initialized)
-    {
-        for(int i=0; i<config_oversample-1; ++i)
-        {
-            result = MPL115_read_averaged(&pressure, &temperature);
-            if(result)
-            {
-                ERROR ("barometer: MPL115_collectd_barometer_read - mpl115 read, ignored during init");
-            }
-            DEBUG("barometer: MPL115_collectd_barometer_read - init %d / %d", i+1, config_oversample-1);
-            usleep(20000);
-        }
-        avg_initialized = 1;
-    }
-
-    result = MPL115_read_averaged(&pressure, &temperature);
-    if(result)
-        return result;
+static int MPL115_collectd_barometer_read(void) {
+  int result = 0;
+
+  double pressure = 0.0;
+  double temperature = 0.0;
+  double norm_pressure = 0.0;
+
+  value_list_t vl = VALUE_LIST_INIT;
+  value_t values[1];
+
+  DEBUG("barometer: MPL115_collectd_barometer_read");
+
+  if (!configured) {
+    return -1;
+  }
+
+  /* Rather than delaying init, we will intitialize during first read. This
+     way at least we have a better chance to have the reference temperature
+     already available. */
+  if (!avg_initialized) {
+    for (int i = 0; i < config_oversample - 1; ++i) {
+      result = MPL115_read_averaged(&pressure, &temperature);
+      if (result) {
+        ERROR("barometer: MPL115_collectd_barometer_read - mpl115 read, "
+              "ignored during init");
+      }
+      DEBUG("barometer: MPL115_collectd_barometer_read - init %d / %d", i + 1,
+            config_oversample - 1);
+      usleep(20000);
+    }
+    avg_initialized = 1;
+  }
+
+  result = MPL115_read_averaged(&pressure, &temperature);
+  if (result)
+    return result;
 
-    norm_pressure = abs_to_mean_sea_level_pressure(pressure);
+  norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
-    sstrncpy (vl.plugin, "barometer", sizeof (vl.plugin));
-    sstrncpy (vl.plugin_instance, "mpl115", sizeof (vl.plugin_instance));
+  sstrncpy(vl.plugin, "barometer", sizeof(vl.plugin));
+  sstrncpy(vl.plugin_instance, "mpl115", sizeof(vl.plugin_instance));
 
-    vl.values_len = 1;
-    vl.values = values;
+  vl.values_len = 1;
+  vl.values = values;
 
-    /* dispatch normalized air pressure */
-    sstrncpy (vl.type, "pressure", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "normalized", sizeof (vl.type_instance));
-    values[0].gauge = norm_pressure;
-    plugin_dispatch_values (&vl);
+  /* dispatch normalized air pressure */
+  sstrncpy(vl.type, "pressure", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "normalized", sizeof(vl.type_instance));
+  values[0].gauge = norm_pressure;
+  plugin_dispatch_values(&vl);
 
-    /* dispatch absolute air pressure */
-    sstrncpy (vl.type, "pressure", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "absolute", sizeof (vl.type_instance));
-    values[0].gauge = pressure;
-    plugin_dispatch_values (&vl);
+  /* dispatch absolute air pressure */
+  sstrncpy(vl.type, "pressure", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "absolute", sizeof(vl.type_instance));
+  values[0].gauge = pressure;
+  plugin_dispatch_values(&vl);
 
-    /* dispatch sensor temperature */
-    sstrncpy (vl.type, "temperature", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "", sizeof (vl.type_instance));
-    values[0].gauge = temperature;
-    plugin_dispatch_values (&vl);
+  /* dispatch sensor temperature */
+  sstrncpy(vl.type, "temperature", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "", sizeof(vl.type_instance));
+  values[0].gauge = temperature;
+  plugin_dispatch_values(&vl);
 
-    return 0;
+  return 0;
 }
 
-
 /**
  * Plugin read callback for MPL3115.
  *
@@ -1638,58 +1458,55 @@ static int MPL115_collectd_barometer_read (void)
  *
  * @return Zero when successful.
  */
-static int MPL3115_collectd_barometer_read (void)
-{
-    int result = 0;
+static int MPL3115_collectd_barometer_read(void) {
+  int result = 0;
 
-    double pressure        = 0.0;
-    double temperature     = 0.0;
-    double norm_pressure   = 0.0;
+  double pressure = 0.0;
+  double temperature = 0.0;
+  double norm_pressure = 0.0;
 
-    value_list_t vl = VALUE_LIST_INIT;
-    value_t      values[1];
+  value_list_t vl = VALUE_LIST_INIT;
+  value_t values[1];
 
-    DEBUG("barometer: MPL3115_collectd_barometer_read");
+  DEBUG("barometer: MPL3115_collectd_barometer_read");
 
-    if (!configured)
-    {
-        return -1;
-    }
+  if (!configured) {
+    return -1;
+  }
 
-    result = MPL3115_read(&pressure, &temperature);
-    if(result)
-        return result;
+  result = MPL3115_read(&pressure, &temperature);
+  if (result)
+    return result;
 
-    norm_pressure = abs_to_mean_sea_level_pressure(pressure);
+  norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
-    sstrncpy (vl.plugin, "barometer", sizeof (vl.plugin));
-    sstrncpy (vl.plugin_instance, "mpl3115", sizeof (vl.plugin_instance));
+  sstrncpy(vl.plugin, "barometer", sizeof(vl.plugin));
+  sstrncpy(vl.plugin_instance, "mpl3115", sizeof(vl.plugin_instance));
 
-    vl.values_len = 1;
-    vl.values = values;
+  vl.values_len = 1;
+  vl.values = values;
 
-    /* dispatch normalized air pressure */
-    sstrncpy (vl.type, "pressure", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "normalized", sizeof (vl.type_instance));
-    values[0].gauge = norm_pressure;
-    plugin_dispatch_values (&vl);
+  /* dispatch normalized air pressure */
+  sstrncpy(vl.type, "pressure", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "normalized", sizeof(vl.type_instance));
+  values[0].gauge = norm_pressure;
+  plugin_dispatch_values(&vl);
 
-    /* dispatch absolute air pressure */
-    sstrncpy (vl.type, "pressure", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "absolute", sizeof (vl.type_instance));
-    values[0].gauge = pressure;
-    plugin_dispatch_values (&vl);
+  /* dispatch absolute air pressure */
+  sstrncpy(vl.type, "pressure", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "absolute", sizeof(vl.type_instance));
+  values[0].gauge = pressure;
+  plugin_dispatch_values(&vl);
 
-    /* dispatch sensor temperature */
-    sstrncpy (vl.type, "temperature", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "", sizeof (vl.type_instance));
-    values[0].gauge = temperature;
-    plugin_dispatch_values (&vl);
+  /* dispatch sensor temperature */
+  sstrncpy(vl.type, "temperature", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "", sizeof(vl.type_instance));
+  values[0].gauge = temperature;
+  plugin_dispatch_values(&vl);
 
-    return 0;
+  return 0;
 }
 
-
 /**
  * Plugin read callback for BMP085.
  *
@@ -1700,179 +1517,159 @@ static int MPL3115_collectd_barometer_read (void)
  *
  * @return Zero when successful.
  */
-static int BMP085_collectd_barometer_read (void)
-{
-    int result = 0;
+static int BMP085_collectd_barometer_read(void) {
+  int result = 0;
 
-    double pressure        = 0.0;
-    double temperature     = 0.0;
-    double norm_pressure   = 0.0;
+  double pressure = 0.0;
+  double temperature = 0.0;
+  double norm_pressure = 0.0;
 
-    value_list_t vl = VALUE_LIST_INIT;
-    value_t      values[1];
+  value_list_t vl = VALUE_LIST_INIT;
+  value_t values[1];
 
-    DEBUG("barometer: BMP085_collectd_barometer_read");
+  DEBUG("barometer: BMP085_collectd_barometer_read");
 
-    if (!configured)
-    {
-        return -1;
-    }
+  if (!configured) {
+    return -1;
+  }
 
-    result = BMP085_read(&pressure, &temperature);
-    if(result)
-        return result;
+  result = BMP085_read(&pressure, &temperature);
+  if (result)
+    return result;
 
-    norm_pressure = abs_to_mean_sea_level_pressure(pressure);
+  norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
-    sstrncpy (vl.plugin, "barometer", sizeof (vl.plugin));
-    sstrncpy (vl.plugin_instance, "bmp085", sizeof (vl.plugin_instance));
+  sstrncpy(vl.plugin, "barometer", sizeof(vl.plugin));
+  sstrncpy(vl.plugin_instance, "bmp085", sizeof(vl.plugin_instance));
 
-    vl.values_len = 1;
-    vl.values = values;
+  vl.values_len = 1;
+  vl.values = values;
 
-    /* dispatch normalized air pressure */
-    sstrncpy (vl.type, "pressure", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "normalized", sizeof (vl.type_instance));
-    values[0].gauge = norm_pressure;
-    plugin_dispatch_values (&vl);
+  /* dispatch normalized air pressure */
+  sstrncpy(vl.type, "pressure", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "normalized", sizeof(vl.type_instance));
+  values[0].gauge = norm_pressure;
+  plugin_dispatch_values(&vl);
 
-    /* dispatch absolute air pressure */
-    sstrncpy (vl.type, "pressure", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "absolute", sizeof (vl.type_instance));
-    values[0].gauge = pressure;
-    plugin_dispatch_values (&vl);
+  /* dispatch absolute air pressure */
+  sstrncpy(vl.type, "pressure", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "absolute", sizeof(vl.type_instance));
+  values[0].gauge = pressure;
+  plugin_dispatch_values(&vl);
 
-    /* dispatch sensor temperature */
-    sstrncpy (vl.type, "temperature", sizeof (vl.type));
-    sstrncpy (vl.type_instance, "", sizeof (vl.type_instance));
-    values[0].gauge = temperature;
-    plugin_dispatch_values (&vl);
+  /* dispatch sensor temperature */
+  sstrncpy(vl.type, "temperature", sizeof(vl.type));
+  sstrncpy(vl.type_instance, "", sizeof(vl.type_instance));
+  values[0].gauge = temperature;
+  plugin_dispatch_values(&vl);
 
-    return 0;
+  return 0;
 }
 
-
 /**
  * Initialization callback
  *
- * Check config, initialize I2C bus access, conversion coefficients and averaging
+ * Check config, initialize I2C bus access, conversion coefficients and
+ * averaging
  * ring buffers
  *
  * @return Zero when successful.
  */
-static int collectd_barometer_init (void)
-{
-    char errbuf[1024];
+static int collectd_barometer_init(void) {
+  char errbuf[1024];
 
-    DEBUG ("barometer: collectd_barometer_init");
+  DEBUG("barometer: collectd_barometer_init");
 
-    if (config_device == NULL)
-    {
-        ERROR("barometer: collectd_barometer_init I2C bus device not configured");
-        return -1;
-    }
+  if (config_device == NULL) {
+    ERROR("barometer: collectd_barometer_init I2C bus device not configured");
+    return -1;
+  }
 
-    if (config_normalize >= MSLP_INTERNATIONAL && isnan(config_altitude))
-    {
-        ERROR("barometer: collectd_barometer_init no altitude configured " \
-              "for mean sea level pressure normalization.");
-        return -1;
-    }
+  if (config_normalize >= MSLP_INTERNATIONAL && isnan(config_altitude)) {
+    ERROR("barometer: collectd_barometer_init no altitude configured "
+          "for mean sea level pressure normalization.");
+    return -1;
+  }
 
-    if (config_normalize == MSLP_DEU_WETT
-        &&
-        temp_list == NULL)
-    {
-        ERROR("barometer: collectd_barometer_init no temperature reference "\
-              "configured for mean sea level pressure normalization.");
-        return -1;
-    }
+  if (config_normalize == MSLP_DEU_WETT && temp_list == NULL) {
+    ERROR("barometer: collectd_barometer_init no temperature reference "
+          "configured for mean sea level pressure normalization.");
+    return -1;
+  }
 
+  i2c_bus_fd = open(config_device, O_RDWR);
+  if (i2c_bus_fd < 0) {
+    ERROR("barometer: collectd_barometer_init problem opening I2C bus device "
+          "\"%s\": %s (is loaded mod i2c-dev?)",
+          config_device, sstrerror(errno, errbuf, sizeof(errbuf)));
+    return -1;
+  }
 
-    i2c_bus_fd = open(config_device, O_RDWR);
-    if (i2c_bus_fd < 0)
-    {
-        ERROR ("barometer: collectd_barometer_init problem opening I2C bus device \"%s\": %s (is loaded mod i2c-dev?)",
-               config_device,
-               sstrerror (errno, errbuf, sizeof (errbuf)));
-        return -1;
-    }
+  /* detect sensor type - this will also set slave address */
+  sensor_type = detect_sensor_type();
 
-    /* detect sensor type - this will also set slave address */
-    sensor_type = detect_sensor_type();
+  /* init correct sensor type */
+  switch (sensor_type) {
+  /* MPL3115 */
+  case Sensor_MPL3115: {
+    MPL3115_adjust_oversampling();
 
-    /* init correct sensor type */
-    switch(sensor_type)
-    {
-/* MPL3115 */
-    case Sensor_MPL3115:
-    {
-        MPL3115_adjust_oversampling();
+    if (MPL3115_init_sensor())
+      return -1;
 
-        if(MPL3115_init_sensor())
-            return -1;
+    plugin_register_read("barometer", MPL3115_collectd_barometer_read);
+  } break;
 
-        plugin_register_read ("barometer", MPL3115_collectd_barometer_read);
+  /* MPL115 */
+  case Sensor_MPL115: {
+    if (averaging_create(&pressure_averaging, config_oversample)) {
+      ERROR(
+          "barometer: collectd_barometer_init pressure averaging init failed");
+      return -1;
     }
-    break;
-
-/* MPL115 */
-    case Sensor_MPL115:
-    {
-        if (averaging_create (&pressure_averaging, config_oversample))
-        {
-            ERROR("barometer: collectd_barometer_init pressure averaging init failed");
-            return -1;
-        }
-
-        if (averaging_create (&temperature_averaging, config_oversample))
-        {
-            ERROR("barometer: collectd_barometer_init temperature averaging init failed");
-            return -1;
-        }
-
-        if (MPL115_read_coeffs() < 0)
-            return -1;
 
-        plugin_register_read ("barometer", MPL115_collectd_barometer_read);
+    if (averaging_create(&temperature_averaging, config_oversample)) {
+      ERROR("barometer: collectd_barometer_init temperature averaging init "
+            "failed");
+      return -1;
     }
-    break;
 
-/* BMP085 */
-    case Sensor_BMP085:
-    {
-        BMP085_adjust_oversampling();
+    if (MPL115_read_coeffs() < 0)
+      return -1;
 
-        if (BMP085_read_coeffs() < 0)
-            return -1;
+    plugin_register_read("barometer", MPL115_collectd_barometer_read);
+  } break;
 
-        plugin_register_read ("barometer", BMP085_collectd_barometer_read);
-    }
-    break;
+  /* BMP085 */
+  case Sensor_BMP085: {
+    BMP085_adjust_oversampling();
 
-/* anything else -> error */
-    default:
-        ERROR("barometer: collectd_barometer_init - no supported sensor found");
-        return -1;
-    }
+    if (BMP085_read_coeffs() < 0)
+      return -1;
 
+    plugin_register_read("barometer", BMP085_collectd_barometer_read);
+  } break;
 
-    configured = 1;
-    return 0;
+  /* anything else -> error */
+  default:
+    ERROR("barometer: collectd_barometer_init - no supported sensor found");
+    return -1;
+  }
+
+  configured = 1;
+  return 0;
 }
 
-/* ------------------------ plugin register / entry point ------------------------ */
+/* ------------------------ plugin register / entry point
+ * ------------------------ */
 
 /**
  * Plugin "entry" - register all callback.
  *
  */
-void module_register (void)
-{
-    plugin_register_config ("barometer",
-                            collectd_barometer_config,
-                            config_keys,
-                            config_keys_num);
-    plugin_register_init ("barometer", collectd_barometer_init);
-    plugin_register_shutdown ("barometer", collectd_barometer_shutdown);
+void module_register(void) {
+  plugin_register_config("barometer", collectd_barometer_config, config_keys,
+                         config_keys_num);
+  plugin_register_init("barometer", collectd_barometer_init);
+  plugin_register_shutdown("barometer", collectd_barometer_shutdown);
 }
@@ -29,773 +29,708 @@
 #include "plugin.h"
 
 #if HAVE_MACH_MACH_TYPES_H
-#  include <mach/mach_types.h>
+#include <mach/mach_types.h>
 #endif
 #if HAVE_MACH_MACH_INIT_H
-#  include <mach/mach_init.h>
+#include <mach/mach_init.h>
 #endif
 #if HAVE_MACH_MACH_ERROR_H
-#  include <mach/mach_error.h>
+#include <mach/mach_error.h>
 #endif
 #if HAVE_COREFOUNDATION_COREFOUNDATION_H
-#  include <CoreFoundation/CoreFoundation.h>
+#include <CoreFoundation/CoreFoundation.h>
 #endif
 #if HAVE_IOKIT_IOKITLIB_H
-#  include <IOKit/IOKitLib.h>
+#include <IOKit/IOKitLib.h>
 #endif
 #if HAVE_IOKIT_IOTYPES_H
-#  include <IOKit/IOTypes.h>
+#include <IOKit/IOTypes.h>
 #endif
 #if HAVE_IOKIT_PS_IOPOWERSOURCES_H
-#  include <IOKit/ps/IOPowerSources.h>
+#include <IOKit/ps/IOPowerSources.h>
 #endif
 #if HAVE_IOKIT_PS_IOPSKEYS_H
-#  include <IOKit/ps/IOPSKeys.h>
+#include <IOKit/ps/IOPSKeys.h>
 #endif
 
 #if !HAVE_IOKIT_IOKITLIB_H && !HAVE_IOKIT_PS_IOPOWERSOURCES_H && !KERNEL_LINUX
-# error "No applicable input method."
+#error "No applicable input method."
 #endif
 
 #if HAVE_IOKIT_IOKITLIB_H || HAVE_IOKIT_PS_IOPOWERSOURCES_H
-	/* No global variables */
+/* No global variables */
 /* #endif HAVE_IOKIT_IOKITLIB_H || HAVE_IOKIT_PS_IOPOWERSOURCES_H */
 
 #elif KERNEL_LINUX
-# define PROC_PMU_PATH_FORMAT "/proc/pmu/battery_%i"
-# define PROC_ACPI_PATH "/proc/acpi/battery"
-# define PROC_ACPI_FACTOR 0.001
-# define SYSFS_PATH "/sys/class/power_supply"
-# define SYSFS_FACTOR 0.000001
+#define PROC_PMU_PATH_FORMAT "/proc/pmu/battery_%i"
+#define PROC_ACPI_PATH "/proc/acpi/battery"
+#define PROC_ACPI_FACTOR 0.001
+#define SYSFS_PATH "/sys/class/power_supply"
+#define SYSFS_FACTOR 0.000001
 #endif /* KERNEL_LINUX */
 
-int battery_read_statefs (void); /* defined in battery_statefs; used by StateFS backend */
+int battery_read_statefs(
+    void); /* defined in battery_statefs; used by StateFS backend */
 
 static _Bool report_percent = 0;
 static _Bool report_degraded = 0;
 static _Bool query_statefs = 0;
 
-static void battery_submit2 (char const *plugin_instance, /* {{{ */
-		char const *type, char const *type_instance, gauge_t value)
-{
-	value_list_t vl = VALUE_LIST_INIT;
+static void battery_submit2(char const *plugin_instance, /* {{{ */
+                            char const *type, char const *type_instance,
+                            gauge_t value) {
+  value_list_t vl = VALUE_LIST_INIT;
 
-	vl.values = &(value_t) { .gauge = value };
-	vl.values_len = 1;
-	sstrncpy (vl.plugin, "battery", sizeof (vl.plugin));
-	sstrncpy (vl.plugin_instance, plugin_instance, sizeof (vl.plugin_instance));
-	sstrncpy (vl.type, type, sizeof (vl.type));
-	if (type_instance != NULL)
-		sstrncpy (vl.type_instance, type_instance, sizeof (vl.type_instance));
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
+  sstrncpy(vl.plugin, "battery", sizeof(vl.plugin));
+  sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
+  sstrncpy(vl.type, type, sizeof(vl.type));
+  if (type_instance != NULL)
+    sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
-	plugin_dispatch_values (&vl);
+  plugin_dispatch_values(&vl);
 } /* }}} void battery_submit2 */
 
-static void battery_submit (char const *plugin_instance, /* {{{ */
-		char const *type, gauge_t value)
-{
-	battery_submit2 (plugin_instance, type, NULL, value);
+static void battery_submit(char const *plugin_instance, /* {{{ */
+                           char const *type, gauge_t value) {
+  battery_submit2(plugin_instance, type, NULL, value);
 } /* }}} void battery_submit */
 
-static void submit_capacity (char const *plugin_instance, /* {{{ */
-		gauge_t capacity_charged,
-		gauge_t capacity_full,
-		gauge_t capacity_design)
-{
-	if (report_percent && (capacity_charged > capacity_full))
-		return;
-	if (report_degraded && (capacity_full > capacity_design))
-		return;
-
-	if (report_percent)
-	{
-		gauge_t capacity_max;
-
-		if (report_degraded)
-			capacity_max = capacity_design;
-		else
-			capacity_max = capacity_full;
-
-		battery_submit2 (plugin_instance, "percent", "charged",
-				100.0 * capacity_charged / capacity_max);
-		battery_submit2 (plugin_instance, "percent", "discharged",
-				100.0 * (capacity_full - capacity_charged) / capacity_max);
-
-		if (report_degraded)
-			battery_submit2 (plugin_instance, "percent", "degraded",
-					100.0 * (capacity_design - capacity_full) / capacity_max);
-	}
-	else if (report_degraded) /* && !report_percent */
-	{
-		battery_submit2 (plugin_instance, "capacity", "charged",
-				capacity_charged);
-		battery_submit2 (plugin_instance, "capacity", "discharged",
-				(capacity_full - capacity_charged));
-		battery_submit2 (plugin_instance, "capacity", "degraded",
-				(capacity_design - capacity_full));
-	}
-	else /* !report_percent && !report_degraded */
-	{
-		battery_submit (plugin_instance, "capacity", capacity_charged);
-	}
+static void submit_capacity(char const *plugin_instance, /* {{{ */
+                            gauge_t capacity_charged, gauge_t capacity_full,
+                            gauge_t capacity_design) {
+  if (report_percent && (capacity_charged > capacity_full))
+    return;
+  if (report_degraded && (capacity_full > capacity_design))
+    return;
+
+  if (report_percent) {
+    gauge_t capacity_max;
+
+    if (report_degraded)
+      capacity_max = capacity_design;
+    else
+      capacity_max = capacity_full;
+
+    battery_submit2(plugin_instance, "percent", "charged",
+                    100.0 * capacity_charged / capacity_max);
+    battery_submit2(plugin_instance, "percent", "discharged",
+                    100.0 * (capacity_full - capacity_charged) / capacity_max);
+
+    if (report_degraded)
+      battery_submit2(plugin_instance, "percent", "degraded",
+                      100.0 * (capacity_design - capacity_full) / capacity_max);
+  } else if (report_degraded) /* && !report_percent */
+  {
+    battery_submit2(plugin_instance, "capacity", "charged", capacity_charged);
+    battery_submit2(plugin_instance, "capacity", "discharged",
+                    (capacity_full - capacity_charged));
+    battery_submit2(plugin_instance, "capacity", "degraded",
+                    (capacity_design - capacity_full));
+  } else /* !report_percent && !report_degraded */
+  {
+    battery_submit(plugin_instance, "capacity", capacity_charged);
+  }
 } /* }}} void submit_capacity */
 
 #if HAVE_IOKIT_PS_IOPOWERSOURCES_H || HAVE_IOKIT_IOKITLIB_H
-static double dict_get_double (CFDictionaryRef dict, const char *key_string) /* {{{ */
+static double dict_get_double(CFDictionaryRef dict,
+                              const char *key_string) /* {{{ */
 {
-	double      val_double;
-	long long   val_int;
-	CFNumberRef val_obj;
-	CFStringRef key_obj;
-
-	key_obj = CFStringCreateWithCString (kCFAllocatorDefault, key_string,
-			kCFStringEncodingASCII);
-	if (key_obj == NULL)
-	{
-		DEBUG ("CFStringCreateWithCString (%s) failed.\n", key_string);
-		return (NAN);
-	}
-
-	if ((val_obj = CFDictionaryGetValue (dict, key_obj)) == NULL)
-	{
-		DEBUG ("CFDictionaryGetValue (%s) failed.", key_string);
-		CFRelease (key_obj);
-		return (NAN);
-	}
-	CFRelease (key_obj);
-
-	if (CFGetTypeID (val_obj) == CFNumberGetTypeID ())
-	{
-		if (CFNumberIsFloatType (val_obj))
-		{
-			CFNumberGetValue (val_obj,
-					kCFNumberDoubleType,
-					&val_double);
-		}
-		else
-		{
-			CFNumberGetValue (val_obj,
-					kCFNumberLongLongType,
-					&val_int);
-			val_double = val_int;
-		}
-	}
-	else
-	{
-		DEBUG ("CFGetTypeID (val_obj) = %i", (int) CFGetTypeID (val_obj));
-		return (NAN);
-	}
-
-	return (val_double);
+  double val_double;
+  long long val_int;
+  CFNumberRef val_obj;
+  CFStringRef key_obj;
+
+  key_obj = CFStringCreateWithCString(kCFAllocatorDefault, key_string,
+                                      kCFStringEncodingASCII);
+  if (key_obj == NULL) {
+    DEBUG("CFStringCreateWithCString (%s) failed.\n", key_string);
+    return (NAN);
+  }
+
+  if ((val_obj = CFDictionaryGetValue(dict, key_obj)) == NULL) {
+    DEBUG("CFDictionaryGetValue (%s) failed.", key_string);
+    CFRelease(key_obj);
+    return (NAN);
+  }
+  CFRelease(key_obj);
+
+  if (CFGetTypeID(val_obj) == CFNumberGetTypeID()) {
+    if (CFNumberIsFloatType(val_obj)) {
+      CFNumberGetValue(val_obj, kCFNumberDoubleType, &val_double);
+    } else {
+      CFNumberGetValue(val_obj, kCFNumberLongLongType, &val_int);
+      val_double = val_int;
+    }
+  } else {
+    DEBUG("CFGetTypeID (val_obj) = %i", (int)CFGetTypeID(val_obj));
+    return (NAN);
+  }
+
+  return (val_double);
 } /* }}} double dict_get_double */
 
-# if HAVE_IOKIT_PS_IOPOWERSOURCES_H
-static void get_via_io_power_sources (double *ret_charge, /* {{{ */
-		double *ret_current,
-		double *ret_voltage)
-{
-	CFTypeRef       ps_raw;
-	CFArrayRef      ps_array;
-	int             ps_array_len;
-	CFDictionaryRef ps_dict;
-	CFTypeRef       ps_obj;
-
-	double temp_double;
-
-	ps_raw       = IOPSCopyPowerSourcesInfo ();
-	ps_array     = IOPSCopyPowerSourcesList (ps_raw);
-	ps_array_len = CFArrayGetCount (ps_array);
-
-	DEBUG ("ps_array_len == %i", ps_array_len);
-
-	for (int i = 0; i < ps_array_len; i++)
-	{
-		ps_obj  = CFArrayGetValueAtIndex (ps_array, i);
-		ps_dict = IOPSGetPowerSourceDescription (ps_raw, ps_obj);
-
-		if (ps_dict == NULL)
-		{
-			DEBUG ("IOPSGetPowerSourceDescription failed.");
-			continue;
-		}
-
-		if (CFGetTypeID (ps_dict) != CFDictionaryGetTypeID ())
-		{
-			DEBUG ("IOPSGetPowerSourceDescription did not return a CFDictionaryRef");
-			continue;
-		}
-
-		/* FIXME: Check if this is really an internal battery */
-
-		if (isnan (*ret_charge))
-		{
-			/* This is the charge in percent. */
-			temp_double = dict_get_double (ps_dict,
-					kIOPSCurrentCapacityKey);
-			if (!isnan ((temp_double))
-					&& (temp_double >= 0.0)
-					&& (temp_double <= 100.0))
-				*ret_charge = temp_double;
-		}
-
-		if (isnan (*ret_current))
-		{
-			temp_double = dict_get_double (ps_dict,
-					kIOPSCurrentKey);
-			if (!isnan (temp_double))
-				*ret_current = temp_double / 1000.0;
-		}
-
-		if (isnan (*ret_voltage))
-		{
-			temp_double = dict_get_double (ps_dict,
-					kIOPSVoltageKey);
-			if (!isnan (temp_double))
-				*ret_voltage = temp_double / 1000.0;
-		}
-	}
-
-	CFRelease(ps_array);
-	CFRelease(ps_raw);
+#if HAVE_IOKIT_PS_IOPOWERSOURCES_H
+static void get_via_io_power_sources(double *ret_charge, /* {{{ */
+                                     double *ret_current, double *ret_voltage) {
+  CFTypeRef ps_raw;
+  CFArrayRef ps_array;
+  int ps_array_len;
+  CFDictionaryRef ps_dict;
+  CFTypeRef ps_obj;
+
+  double temp_double;
+
+  ps_raw = IOPSCopyPowerSourcesInfo();
+  ps_array = IOPSCopyPowerSourcesList(ps_raw);
+  ps_array_len = CFArrayGetCount(ps_array);
+
+  DEBUG("ps_array_len == %i", ps_array_len);
+
+  for (int i = 0; i < ps_array_len; i++) {
+    ps_obj = CFArrayGetValueAtIndex(ps_array, i);
+    ps_dict = IOPSGetPowerSourceDescription(ps_raw, ps_obj);
+
+    if (ps_dict == NULL) {
+      DEBUG("IOPSGetPowerSourceDescription failed.");
+      continue;
+    }
+
+    if (CFGetTypeID(ps_dict) != CFDictionaryGetTypeID()) {
+      DEBUG("IOPSGetPowerSourceDescription did not return a CFDictionaryRef");
+      continue;
+    }
+
+    /* FIXME: Check if this is really an internal battery */
+
+    if (isnan(*ret_charge)) {
+      /* This is the charge in percent. */
+      temp_double = dict_get_double(ps_dict, kIOPSCurrentCapacityKey);
+      if (!isnan((temp_double)) && (temp_double >= 0.0) &&
+          (temp_double <= 100.0))
+        *ret_charge = temp_double;
+    }
+
+    if (isnan(*ret_current)) {
+      temp_double = dict_get_double(ps_dict, kIOPSCurrentKey);
+      if (!isnan(temp_double))
+        *ret_current = temp_double / 1000.0;
+    }
+
+    if (isnan(*ret_voltage)) {
+      temp_double = dict_get_double(ps_dict, kIOPSVoltageKey);
+      if (!isnan(temp_double))
+        *ret_voltage = temp_double / 1000.0;
+    }
+  }
+
+  CFRelease(ps_array);
+  CFRelease(ps_raw);
 } /* }}} void get_via_io_power_sources */
-# endif /* HAVE_IOKIT_PS_IOPOWERSOURCES_H */
+#endif /* HAVE_IOKIT_PS_IOPOWERSOURCES_H */
 
-# if HAVE_IOKIT_IOKITLIB_H
-static void get_via_generic_iokit (double *ret_capacity_full, /* {{{ */
-		double *ret_capacity_design,
-		double *ret_current,
-		double *ret_voltage)
-{
-	kern_return_t   status;
-	io_iterator_t   iterator;
-	io_object_t     io_obj;
-
-	CFDictionaryRef bat_root_dict;
-	CFArrayRef      bat_info_arry;
-	CFIndex         bat_info_arry_len;
-	CFDictionaryRef bat_info_dict;
-
-	double temp_double;
-
-	status = IOServiceGetMatchingServices (kIOMasterPortDefault,
-			IOServiceNameMatching ("battery"),
-			&iterator);
-	if (status != kIOReturnSuccess)
-	{
-		DEBUG ("IOServiceGetMatchingServices failed.");
-		return;
-	}
-
-	while ((io_obj = IOIteratorNext (iterator)))
-	{
-		status = IORegistryEntryCreateCFProperties (io_obj,
-				(CFMutableDictionaryRef *) &bat_root_dict,
-				kCFAllocatorDefault,
-				kNilOptions);
-		if (status != kIOReturnSuccess)
-		{
-			DEBUG ("IORegistryEntryCreateCFProperties failed.");
-			continue;
-		}
-
-		bat_info_arry = (CFArrayRef) CFDictionaryGetValue (bat_root_dict,
-				CFSTR ("IOBatteryInfo"));
-		if (bat_info_arry == NULL)
-		{
-			CFRelease (bat_root_dict);
-			continue;
-		}
-		bat_info_arry_len = CFArrayGetCount (bat_info_arry);
-
-		for (CFIndex bat_info_arry_pos = 0;
-				bat_info_arry_pos < bat_info_arry_len;
-				bat_info_arry_pos++)
-		{
-			bat_info_dict = (CFDictionaryRef) CFArrayGetValueAtIndex (bat_info_arry, bat_info_arry_pos);
-
-			if (isnan (*ret_capacity_full))
-			{
-				temp_double = dict_get_double (bat_info_dict, "Capacity");
-				*ret_capacity_full = temp_double / 1000.0;
-			}
-
-			if (isnan (*ret_capacity_design))
-			{
-				temp_double = dict_get_double (bat_info_dict, "AbsoluteMaxCapacity");
-				*ret_capacity_design = temp_double / 1000.0;
-			}
-
-			if (isnan (*ret_current))
-			{
-				temp_double = dict_get_double (bat_info_dict, "Current");
-				*ret_current = temp_double / 1000.0;
-			}
-
-			if (isnan (*ret_voltage))
-			{
-				temp_double = dict_get_double (bat_info_dict, "Voltage");
-				*ret_voltage = temp_double / 1000.0;
-			}
-		}
-
-		CFRelease (bat_root_dict);
-	}
-
-	IOObjectRelease (iterator);
+#if HAVE_IOKIT_IOKITLIB_H
+static void get_via_generic_iokit(double *ret_capacity_full, /* {{{ */
+                                  double *ret_capacity_design,
+                                  double *ret_current, double *ret_voltage) {
+  kern_return_t status;
+  io_iterator_t iterator;
+  io_object_t io_obj;
+
+  CFDictionaryRef bat_root_dict;
+  CFArrayRef bat_info_arry;
+  CFIndex bat_info_arry_len;
+  CFDictionaryRef bat_info_dict;
+
+  double temp_double;
+
+  status = IOServiceGetMatchingServices(
+      kIOMasterPortDefault, IOServiceNameMatching("battery"), &iterator);
+  if (status != kIOReturnSuccess) {
+    DEBUG("IOServiceGetMatchingServices failed.");
+    return;
+  }
+
+  while ((io_obj = IOIteratorNext(iterator))) {
+    status = IORegistryEntryCreateCFProperties(
+        io_obj, (CFMutableDictionaryRef *)&bat_root_dict, kCFAllocatorDefault,
+        kNilOptions);
+    if (status != kIOReturnSuccess) {
+      DEBUG("IORegistryEntryCreateCFProperties failed.");
+      continue;
+    }
+
+    bat_info_arry =
+        (CFArrayRef)CFDictionaryGetValue(bat_root_dict, CFSTR("IOBatteryInfo"));
+    if (bat_info_arry == NULL) {
+      CFRelease(bat_root_dict);
+      continue;
+    }
+    bat_info_arry_len = CFArrayGetCount(bat_info_arry);
+
+    for (CFIndex bat_info_arry_pos = 0; bat_info_arry_pos < bat_info_arry_len;
+         bat_info_arry_pos++) {
+      bat_info_dict = (CFDictionaryRef)CFArrayGetValueAtIndex(
+          bat_info_arry, bat_info_arry_pos);
+
+      if (isnan(*ret_capacity_full)) {
+        temp_double = dict_get_double(bat_info_dict, "Capacity");
+        *ret_capacity_full = temp_double / 1000.0;
+      }
+
+      if (isnan(*ret_capacity_design)) {
+        temp_double = dict_get_double(bat_info_dict, "AbsoluteMaxCapacity");
+        *ret_capacity_design = temp_double / 1000.0;
+      }
+
+      if (isnan(*ret_current)) {
+        temp_double = dict_get_double(bat_info_dict, "Current");
+        *ret_current = temp_double / 1000.0;
+      }
+
+      if (isnan(*ret_voltage)) {
+        temp_double = dict_get_double(bat_info_dict, "Voltage");
+        *ret_voltage = temp_double / 1000.0;
+      }
+    }
+
+    CFRelease(bat_root_dict);
+  }
+
+  IOObjectRelease(iterator);
 } /* }}} void get_via_generic_iokit */
-# endif /* HAVE_IOKIT_IOKITLIB_H */
+#endif /* HAVE_IOKIT_IOKITLIB_H */
 
-static int battery_read (void) /* {{{ */
+static int battery_read(void) /* {{{ */
 {
-	gauge_t current = NAN; /* Current in A */
-	gauge_t voltage = NAN; /* Voltage in V */
+  gauge_t current = NAN; /* Current in A */
+  gauge_t voltage = NAN; /* Voltage in V */
 
-	/* We only get the charged capacity as a percentage from
-	 * IOPowerSources. IOKit, on the other hand, only reports the full
-	 * capacity. We use the two to calculate the current charged capacity. */
-	gauge_t charge_rel = NAN; /* Current charge in percent */
-	gauge_t capacity_charged; /* Charged capacity */
-	gauge_t capacity_full = NAN; /* Total capacity */
-	gauge_t capacity_design = NAN; /* Full design capacity */
+  /* We only get the charged capacity as a percentage from
+   * IOPowerSources. IOKit, on the other hand, only reports the full
+   * capacity. We use the two to calculate the current charged capacity. */
+  gauge_t charge_rel = NAN;      /* Current charge in percent */
+  gauge_t capacity_charged;      /* Charged capacity */
+  gauge_t capacity_full = NAN;   /* Total capacity */
+  gauge_t capacity_design = NAN; /* Full design capacity */
 
-	if (query_statefs)
-		return battery_read_statefs ();
+  if (query_statefs)
+    return battery_read_statefs();
 
 #if HAVE_IOKIT_PS_IOPOWERSOURCES_H
-	get_via_io_power_sources (&charge_rel, &current, &voltage);
+  get_via_io_power_sources(&charge_rel, &current, &voltage);
 #endif
 #if HAVE_IOKIT_IOKITLIB_H
-	get_via_generic_iokit (&capacity_full, &capacity_design, &current, &voltage);
+  get_via_generic_iokit(&capacity_full, &capacity_design, &current, &voltage);
 #endif
 
-	capacity_charged = charge_rel * capacity_full / 100.0;
-	submit_capacity ("0", capacity_charged, capacity_full, capacity_design);
+  capacity_charged = charge_rel * capacity_full / 100.0;
+  submit_capacity("0", capacity_charged, capacity_full, capacity_design);
 
-	if (!isnan (current))
-		battery_submit ("0", "current", current);
-	if (!isnan (voltage))
-		battery_submit ("0", "voltage", voltage);
+  if (!isnan(current))
+    battery_submit("0", "current", current);
+  if (!isnan(voltage))
+    battery_submit("0", "voltage", voltage);
 
-	return (0);
+  return (0);
 } /* }}} int battery_read */
 /* #endif HAVE_IOKIT_IOKITLIB_H || HAVE_IOKIT_PS_IOPOWERSOURCES_H */
 
 #elif KERNEL_LINUX
 /* Reads a file which contains only a number (and optionally a trailing
  * newline) and parses that number. */
 static int sysfs_file_to_buffer(char const *dir, /* {{{ */
-		char const *power_supply,
-		char const *basename,
-		char *buffer, size_t buffer_size)
-{
-	char filename[PATH_MAX];
-	int status;
+                                char const *power_supply, char const *basename,
+                                char *buffer, size_t buffer_size) {
+  char filename[PATH_MAX];
+  int status;
 
-	ssnprintf (filename, sizeof (filename), "%s/%s/%s",
-			dir, power_supply, basename);
+  ssnprintf(filename, sizeof(filename), "%s/%s/%s", dir, power_supply,
+            basename);
 
-	status = (int) read_file_contents (filename, buffer, buffer_size);
-	if (status < 0)
-		return status;
+  status = (int)read_file_contents(filename, buffer, buffer_size);
+  if (status < 0)
+    return status;
 
-	strstripnewline (buffer);
-	return 0;
+  strstripnewline(buffer);
+  return 0;
 } /* }}} int sysfs_file_to_buffer */
 
 /* Reads a file which contains only a number (and optionally a trailing
  * newline) and parses that number. */
 static int sysfs_file_to_gauge(char const *dir, /* {{{ */
-		char const *power_supply,
-		char const *basename, gauge_t *ret_value)
-{
-	int status;
-	char buffer[32] = "";
+                               char const *power_supply, char const *basename,
+                               gauge_t *ret_value) {
+  int status;
+  char buffer[32] = "";
 
-	status = sysfs_file_to_buffer (dir, power_supply, basename, buffer, sizeof (buffer));
-	if (status != 0)
-		return (status);
+  status =
+      sysfs_file_to_buffer(dir, power_supply, basename, buffer, sizeof(buffer));
+  if (status != 0)
+    return (status);
 
-	return (strtogauge (buffer, ret_value));
+  return (strtogauge(buffer, ret_value));
 } /* }}} sysfs_file_to_gauge */
 
-static int read_sysfs_capacity (char const *dir, /* {{{ */
-		char const *power_supply,
-		char const *plugin_instance)
-{
-	gauge_t capacity_charged = NAN;
-	gauge_t capacity_full = NAN;
-	gauge_t capacity_design = NAN;
-	int status;
-
-	status = sysfs_file_to_gauge (dir, power_supply, "energy_now", &capacity_charged);
-	if (status != 0)
-		return (status);
-
-	status = sysfs_file_to_gauge (dir, power_supply, "energy_full", &capacity_full);
-	if (status != 0)
-		return (status);
-
-	status = sysfs_file_to_gauge (dir, power_supply, "energy_full_design", &capacity_design);
-	if (status != 0)
-		return (status);
-
-	submit_capacity (plugin_instance,
-			capacity_charged * SYSFS_FACTOR,
-			capacity_full * SYSFS_FACTOR,
-			capacity_design * SYSFS_FACTOR);
-	return (0);
+static int read_sysfs_capacity(char const *dir, /* {{{ */
+                               char const *power_supply,
+                               char const *plugin_instance) {
+  gauge_t capacity_charged = NAN;
+  gauge_t capacity_full = NAN;
+  gauge_t capacity_design = NAN;
+  int status;
+
+  status =
+      sysfs_file_to_gauge(dir, power_supply, "energy_now", &capacity_charged);
+  if (status != 0)
+    return (status);
+
+  status =
+      sysfs_file_to_gauge(dir, power_supply, "energy_full", &capacity_full);
+  if (status != 0)
+    return (status);
+
+  status = sysfs_file_to_gauge(dir, power_supply, "energy_full_design",
+                               &capacity_design);
+  if (status != 0)
+    return (status);
+
+  submit_capacity(plugin_instance, capacity_charged * SYSFS_FACTOR,
+                  capacity_full * SYSFS_FACTOR, capacity_design * SYSFS_FACTOR);
+  return (0);
 } /* }}} int read_sysfs_capacity */
 
-static int read_sysfs_callback (char const *dir, /* {{{ */
-		char const *power_supply,
-		void *user_data)
-{
-	int *battery_index = user_data;
-
-	char const *plugin_instance;
-	char buffer[32];
-	gauge_t v = NAN;
-	_Bool discharging = 0;
-	int status;
-
-	/* Ignore non-battery directories, such as AC power. */
-	status = sysfs_file_to_buffer (dir, power_supply, "type", buffer, sizeof (buffer));
-	if (status != 0)
-		return (0);
-	if (strcasecmp ("Battery", buffer) != 0)
-		return (0);
-
-	(void) sysfs_file_to_buffer (dir, power_supply, "status", buffer, sizeof (buffer));
-	if (strcasecmp ("Discharging", buffer) == 0)
-		discharging = 1;
-
-	/* FIXME: This is a dirty hack for backwards compatibility: The battery
-	 * plugin, for a very long time, has had the plugin_instance
-	 * hard-coded to "0". So, to keep backwards compatibility, we'll use
-	 * "0" for the first battery we find and the power_supply name for all
-	 * following. This should be reverted in a future major version. */
-	plugin_instance = (*battery_index == 0) ? "0" : power_supply;
-	(*battery_index)++;
-
-	read_sysfs_capacity (dir, power_supply, plugin_instance);
-
-	if (sysfs_file_to_gauge (dir, power_supply, "power_now", &v) == 0)
-	{
-		if (discharging)
-			v *= -1.0;
-		battery_submit (plugin_instance, "power", v * SYSFS_FACTOR);
-	}
-	if (sysfs_file_to_gauge (dir, power_supply, "current_now", &v) == 0)
-	{
-		if (discharging)
-			v *= -1.0;
-		battery_submit (plugin_instance, "current", v * SYSFS_FACTOR);
-	}
-
-	if (sysfs_file_to_gauge (dir, power_supply, "voltage_now", &v) == 0)
-		battery_submit (plugin_instance, "voltage", v * SYSFS_FACTOR);
-
-	return (0);
+static int read_sysfs_callback(char const *dir, /* {{{ */
+                               char const *power_supply, void *user_data) {
+  int *battery_index = user_data;
+
+  char const *plugin_instance;
+  char buffer[32];
+  gauge_t v = NAN;
+  _Bool discharging = 0;
+  int status;
+
+  /* Ignore non-battery directories, such as AC power. */
+  status =
+      sysfs_file_to_buffer(dir, power_supply, "type", buffer, sizeof(buffer));
+  if (status != 0)
+    return (0);
+  if (strcasecmp("Battery", buffer) != 0)
+    return (0);
+
+  (void)sysfs_file_to_buffer(dir, power_supply, "status", buffer,
+                             sizeof(buffer));
+  if (strcasecmp("Discharging", buffer) == 0)
+    discharging = 1;
+
+  /* FIXME: This is a dirty hack for backwards compatibility: The battery
+   * plugin, for a very long time, has had the plugin_instance
+   * hard-coded to "0". So, to keep backwards compatibility, we'll use
+   * "0" for the first battery we find and the power_supply name for all
+   * following. This should be reverted in a future major version. */
+  plugin_instance = (*battery_index == 0) ? "0" : power_supply;
+  (*battery_index)++;
+
+  read_sysfs_capacity(dir, power_supply, plugin_instance);
+
+  if (sysfs_file_to_gauge(dir, power_supply, "power_now", &v) == 0) {
+    if (discharging)
+      v *= -1.0;
+    battery_submit(plugin_instance, "power", v * SYSFS_FACTOR);
+  }
+  if (sysfs_file_to_gauge(dir, power_supply, "current_now", &v) == 0) {
+    if (discharging)
+      v *= -1.0;
+    battery_submit(plugin_instance, "current", v * SYSFS_FACTOR);
+  }
+
+  if (sysfs_file_to_gauge(dir, power_supply, "voltage_now", &v) == 0)
+    battery_submit(plugin_instance, "voltage", v * SYSFS_FACTOR);
+
+  return (0);
 } /* }}} int read_sysfs_callback */
 
-static int read_sysfs (void) /* {{{ */
+static int read_sysfs(void) /* {{{ */
 {
-	int status;
-	int battery_counter = 0;
+  int status;
+  int battery_counter = 0;
 
-	if (access (SYSFS_PATH, R_OK) != 0)
-		return (ENOENT);
+  if (access(SYSFS_PATH, R_OK) != 0)
+    return (ENOENT);
 
-	status = walk_directory (SYSFS_PATH, read_sysfs_callback,
-			/* user_data = */ &battery_counter,
-			/* include hidden */ 0);
-	return (status);
+  status = walk_directory(SYSFS_PATH, read_sysfs_callback,
+                          /* user_data = */ &battery_counter,
+                          /* include hidden */ 0);
+  return (status);
 } /* }}} int read_sysfs */
 
-static int read_acpi_full_capacity (char const *dir, /* {{{ */
-		char const *power_supply,
-		gauge_t *ret_capacity_full,
-		gauge_t *ret_capacity_design)
+static int read_acpi_full_capacity(char const *dir, /* {{{ */
+                                   char const *power_supply,
+                                   gauge_t *ret_capacity_full,
+                                   gauge_t *ret_capacity_design)
 
 {
-	char filename[PATH_MAX];
-	char buffer[1024];
-
-	FILE *fh;
-
-	ssnprintf (filename, sizeof (filename), "%s/%s/info", dir, power_supply);
-	fh = fopen (filename, "r");
-	if (fh == NULL)
-		return (errno);
-
-	/* last full capacity:      40090 mWh */
-	while (fgets (buffer, sizeof (buffer), fh) != NULL)
-	{
-		gauge_t *value_ptr;
-		int fields_num;
-		char *fields[8];
-		int index;
-
-		if (strncmp ("last full capacity:", buffer, strlen ("last full capacity:")) == 0)
-		{
-			value_ptr = ret_capacity_full;
-			index = 3;
-		}
-		else if (strncmp ("design capacity:", buffer, strlen ("design capacity:")) == 0)
-		{
-			value_ptr = ret_capacity_design;
-			index = 2;
-		}
-		else
-		{
-			continue;
-		}
-
-		fields_num = strsplit (buffer, fields, STATIC_ARRAY_SIZE (fields));
-		if (fields_num <= index)
-			continue;
-
-		strtogauge (fields[index], value_ptr);
-	}
-
-	fclose (fh);
-	return (0);
+  char filename[PATH_MAX];
+  char buffer[1024];
+
+  FILE *fh;
+
+  ssnprintf(filename, sizeof(filename), "%s/%s/info", dir, power_supply);
+  fh = fopen(filename, "r");
+  if (fh == NULL)
+    return (errno);
+
+  /* last full capacity:      40090 mWh */
+  while (fgets(buffer, sizeof(buffer), fh) != NULL) {
+    gauge_t *value_ptr;
+    int fields_num;
+    char *fields[8];
+    int index;
+
+    if (strncmp("last full capacity:", buffer, strlen("last full capacity:")) ==
+        0) {
+      value_ptr = ret_capacity_full;
+      index = 3;
+    } else if (strncmp("design capacity:", buffer,
+                       strlen("design capacity:")) == 0) {
+      value_ptr = ret_capacity_design;
+      index = 2;
+    } else {
+      continue;
+    }
+
+    fields_num = strsplit(buffer, fields, STATIC_ARRAY_SIZE(fields));
+    if (fields_num <= index)
+      continue;
+
+    strtogauge(fields[index], value_ptr);
+  }
+
+  fclose(fh);
+  return (0);
 } /* }}} int read_acpi_full_capacity */
 
-static int read_acpi_callback (char const *dir, /* {{{ */
-		char const *power_supply,
-		void *user_data)
-{
-	int *battery_index = user_data;
-
-	gauge_t power = NAN;
-	gauge_t voltage = NAN;
-	gauge_t capacity_charged = NAN;
-	gauge_t capacity_full = NAN;
-	gauge_t capacity_design = NAN;
-	_Bool charging = 0;
-	_Bool is_current = 0;
-
-	char const *plugin_instance;
-	char filename[PATH_MAX];
-	char buffer[1024];
-
-	FILE *fh;
-
-	ssnprintf (filename, sizeof (filename), "%s/%s/state", dir, power_supply);
-	fh = fopen (filename, "r");
-	if (fh == NULL)
-	{
-		if ((errno == EAGAIN) || (errno == EINTR) || (errno == ENOENT))
-			return (0);
-		else
-			return (errno);
-	}
-
-	/*
-	 * [11:00] <@tokkee> $ cat /proc/acpi/battery/BAT1/state
-	 * [11:00] <@tokkee> present:                 yes
-	 * [11:00] <@tokkee> capacity state:          ok
-	 * [11:00] <@tokkee> charging state:          charging
-	 * [11:00] <@tokkee> present rate:            1724 mA
-	 * [11:00] <@tokkee> remaining capacity:      4136 mAh
-	 * [11:00] <@tokkee> present voltage:         12428 mV
-	 */
-	while (fgets (buffer, sizeof (buffer), fh) != NULL)
-	{
-		char *fields[8];
-		int numfields;
-
-		numfields = strsplit (buffer, fields, STATIC_ARRAY_SIZE (fields));
-		if (numfields < 3)
-			continue;
-
-		if ((strcmp (fields[0], "charging") == 0)
-				&& (strcmp (fields[1], "state:") == 0))
-		{
-			if (strcmp (fields[2], "charging") == 0)
-				charging = 1;
-			else
-				charging = 0;
-			continue;
-		}
-
-		/* The unit of "present rate" depends on the battery. Modern
-		 * batteries export power (watts), older batteries (used to)
-		 * export current (amperes). We check the fourth column and try
-		 * to find old batteries this way. */
-		if ((strcmp (fields[0], "present") == 0)
-				&& (strcmp (fields[1], "rate:") == 0))
-		{
-			strtogauge (fields[2], &power);
-
-			if ((numfields >= 4) && (strcmp ("mA", fields[3]) == 0))
-				is_current = 1;
-		}
-		else if ((strcmp (fields[0], "remaining") == 0)
-				&& (strcmp (fields[1], "capacity:") == 0))
-			strtogauge (fields[2], &capacity_charged);
-		else if ((strcmp (fields[0], "present") == 0)
-				&& (strcmp (fields[1], "voltage:") == 0))
-			strtogauge (fields[2], &voltage);
-	} /* while (fgets (buffer, sizeof (buffer), fh) != NULL) */
-
-	fclose (fh);
-
-	if (!charging)
-		power *= -1.0;
-
-	/* FIXME: This is a dirty hack for backwards compatibility: The battery
-	 * plugin, for a very long time, has had the plugin_instance
-	 * hard-coded to "0". So, to keep backwards compatibility, we'll use
-	 * "0" for the first battery we find and the power_supply name for all
-	 * following. This should be reverted in a future major version. */
-	plugin_instance = (*battery_index == 0) ? "0" : power_supply;
-	(*battery_index)++;
-
-	read_acpi_full_capacity (dir, power_supply, &capacity_full, &capacity_design);
-
-	submit_capacity (plugin_instance,
-			capacity_charged * PROC_ACPI_FACTOR,
-			capacity_full * PROC_ACPI_FACTOR,
-			capacity_design * PROC_ACPI_FACTOR);
-
-	battery_submit (plugin_instance,
-			is_current ? "current" : "power",
-			power * PROC_ACPI_FACTOR);
-	battery_submit (plugin_instance, "voltage", voltage * PROC_ACPI_FACTOR);
-
-	return 0;
+static int read_acpi_callback(char const *dir, /* {{{ */
+                              char const *power_supply, void *user_data) {
+  int *battery_index = user_data;
+
+  gauge_t power = NAN;
+  gauge_t voltage = NAN;
+  gauge_t capacity_charged = NAN;
+  gauge_t capacity_full = NAN;
+  gauge_t capacity_design = NAN;
+  _Bool charging = 0;
+  _Bool is_current = 0;
+
+  char const *plugin_instance;
+  char filename[PATH_MAX];
+  char buffer[1024];
+
+  FILE *fh;
+
+  ssnprintf(filename, sizeof(filename), "%s/%s/state", dir, power_supply);
+  fh = fopen(filename, "r");
+  if (fh == NULL) {
+    if ((errno == EAGAIN) || (errno == EINTR) || (errno == ENOENT))
+      return (0);
+    else
+      return (errno);
+  }
+
+  /*
+   * [11:00] <@tokkee> $ cat /proc/acpi/battery/BAT1/state
+   * [11:00] <@tokkee> present:                 yes
+   * [11:00] <@tokkee> capacity state:          ok
+   * [11:00] <@tokkee> charging state:          charging
+   * [11:00] <@tokkee> present rate:            1724 mA
+   * [11:00] <@tokkee> remaining capacity:      4136 mAh
+   * [11:00] <@tokkee> present voltage:         12428 mV
+   */
+  while (fgets(buffer, sizeof(buffer), fh) != NULL) {
+    char *fields[8];
+    int numfields;
+
+    numfields = strsplit(buffer, fields, STATIC_ARRAY_SIZE(fields));
+    if (numfields < 3)
+      continue;
+
+    if ((strcmp(fields[0], "charging") == 0) &&
+        (strcmp(fields[1], "state:") == 0)) {
+      if (strcmp(fields[2], "charging") == 0)
+        charging = 1;
+      else
+        charging = 0;
+      continue;
+    }
+
+    /* The unit of "present rate" depends on the battery. Modern
+     * batteries export power (watts), older batteries (used to)
+     * export current (amperes). We check the fourth column and try
+     * to find old batteries this way. */
+    if ((strcmp(fields[0], "present") == 0) &&
+        (strcmp(fields[1], "rate:") == 0)) {
+      strtogauge(fields[2], &power);
+
+      if ((numfields >= 4) && (strcmp("mA", fields[3]) == 0))
+        is_current = 1;
+    } else if ((strcmp(fields[0], "remaining") == 0) &&
+               (strcmp(fields[1], "capacity:") == 0))
+      strtogauge(fields[2], &capacity_charged);
+    else if ((strcmp(fields[0], "present") == 0) &&
+             (strcmp(fields[1], "voltage:") == 0))
+      strtogauge(fields[2], &voltage);
+  } /* while (fgets (buffer, sizeof (buffer), fh) != NULL) */
+
+  fclose(fh);
+
+  if (!charging)
+    power *= -1.0;
+
+  /* FIXME: This is a dirty hack for backwards compatibility: The battery
+   * plugin, for a very long time, has had the plugin_instance
+   * hard-coded to "0". So, to keep backwards compatibility, we'll use
+   * "0" for the first battery we find and the power_supply name for all
+   * following. This should be reverted in a future major version. */
+  plugin_instance = (*battery_index == 0) ? "0" : power_supply;
+  (*battery_index)++;
+
+  read_acpi_full_capacity(dir, power_supply, &capacity_full, &capacity_design);
+
+  submit_capacity(plugin_instance, capacity_charged * PROC_ACPI_FACTOR,
+                  capacity_full * PROC_ACPI_FACTOR,
+                  capacity_design * PROC_ACPI_FACTOR);
+
+  battery_submit(plugin_instance, is_current ? "current" : "power",
+                 power * PROC_ACPI_FACTOR);
+  battery_submit(plugin_instance, "voltage", voltage * PROC_ACPI_FACTOR);
+
+  return 0;
 } /* }}} int read_acpi_callback */
 
-static int read_acpi (void) /* {{{ */
+static int read_acpi(void) /* {{{ */
 {
-	int status;
-	int battery_counter = 0;
+  int status;
+  int battery_counter = 0;
 
-	if (access (PROC_ACPI_PATH, R_OK) != 0)
-		return (ENOENT);
+  if (access(PROC_ACPI_PATH, R_OK) != 0)
+    return (ENOENT);
 
-	status = walk_directory (PROC_ACPI_PATH, read_acpi_callback,
-			/* user_data = */ &battery_counter,
-			/* include hidden */ 0);
-	return (status);
+  status = walk_directory(PROC_ACPI_PATH, read_acpi_callback,
+                          /* user_data = */ &battery_counter,
+                          /* include hidden */ 0);
+  return (status);
 } /* }}} int read_acpi */
 
-static int read_pmu (void) /* {{{ */
+static int read_pmu(void) /* {{{ */
 {
-	int i = 0;
-	/* The upper limit here is just a safeguard. If there is a system with
-	 * more than 100 batteries, this can easily be increased. */
-	for (; i < 100; i++)
-	{
-		FILE *fh;
-
-		char buffer[1024];
-		char filename[PATH_MAX];
-		char plugin_instance[DATA_MAX_NAME_LEN];
-
-		gauge_t current = NAN;
-		gauge_t voltage = NAN;
-		gauge_t charge  = NAN;
-
-		ssnprintf (filename, sizeof (filename), PROC_PMU_PATH_FORMAT, i);
-		if (access (filename, R_OK) != 0)
-			break;
-
-		ssnprintf (plugin_instance, sizeof (plugin_instance), "%i", i);
-
-		fh = fopen (filename, "r");
-		if (fh == NULL)
-		{
-			if (errno == ENOENT)
-				break;
-			else if ((errno == EAGAIN) || (errno == EINTR))
-				continue;
-			else
-				return (errno);
-		}
-
-		while (fgets (buffer, sizeof (buffer), fh) != NULL)
-		{
-			char *fields[8];
-			int numfields;
-
-			numfields = strsplit (buffer, fields, STATIC_ARRAY_SIZE (fields));
-			if (numfields < 3)
-				continue;
-
-			if (strcmp ("current", fields[0]) == 0)
-				strtogauge (fields[2], &current);
-			else if (strcmp ("voltage", fields[0]) == 0)
-				strtogauge (fields[2], &voltage);
-			else if (strcmp ("charge", fields[0]) == 0)
-				strtogauge (fields[2], &charge);
-		}
-
-		fclose (fh);
-		fh = NULL;
-
-		battery_submit (plugin_instance, "charge", charge / 1000.0);
-		battery_submit (plugin_instance, "current", current / 1000.0);
-		battery_submit (plugin_instance, "voltage", voltage / 1000.0);
-	}
-
-	if (i == 0)
-		return (ENOENT);
-	return (0);
+  int i = 0;
+  /* The upper limit here is just a safeguard. If there is a system with
+   * more than 100 batteries, this can easily be increased. */
+  for (; i < 100; i++) {
+    FILE *fh;
+
+    char buffer[1024];
+    char filename[PATH_MAX];
+    char plugin_instance[DATA_MAX_NAME_LEN];
+
+    gauge_t current = NAN;
+    gauge_t voltage = NAN;
+    gauge_t charge = NAN;
+
+    ssnprintf(filename, sizeof(filename), PROC_PMU_PATH_FORMAT, i);
+    if (access(filename, R_OK) != 0)
+      break;
+
+    ssnprintf(plugin_instance, sizeof(plugin_instance), "%i", i);
+
+    fh = fopen(filename, "r");
+    if (fh == NULL) {
+      if (errno == ENOENT)
+        break;
+      else if ((errno == EAGAIN) || (errno == EINTR))
+        continue;
+      else
+        return (errno);
+    }
+
+    while (fgets(buffer, sizeof(buffer), fh) != NULL) {
+      char *fields[8];
+      int numfields;
+
+      numfields = strsplit(buffer, fields, STATIC_ARRAY_SIZE(fields));
+      if (numfields < 3)
+        continue;
+
+      if (strcmp("current", fields[0]) == 0)
+        strtogauge(fields[2], &current);
+      else if (strcmp("voltage", fields[0]) == 0)
+        strtogauge(fields[2], &voltage);
+      else if (strcmp("charge", fields[0]) == 0)
+        strtogauge(fields[2], &charge);
+    }
+
+    fclose(fh);
+    fh = NULL;
+
+    battery_submit(plugin_instance, "charge", charge / 1000.0);
+    battery_submit(plugin_instance, "current", current / 1000.0);
+    battery_submit(plugin_instance, "voltage", voltage / 1000.0);
+  }
+
+  if (i == 0)
+    return (ENOENT);
+  return (0);
 } /* }}} int read_pmu */
 
-static int battery_read (void) /* {{{ */
+static int battery_read(void) /* {{{ */
 {
-	int status;
+  int status;
 
-	if (query_statefs)
-		return battery_read_statefs ();
+  if (query_statefs)
+    return battery_read_statefs();
 
-	DEBUG ("battery plugin: Trying sysfs ...");
-	status = read_sysfs ();
-	if (status == 0)
-		return (0);
+  DEBUG("battery plugin: Trying sysfs ...");
+  status = read_sysfs();
+  if (status == 0)
+    return (0);
 
-	DEBUG ("battery plugin: Trying acpi ...");
-	status = read_acpi ();
-	if (status == 0)
-		return (0);
+  DEBUG("battery plugin: Trying acpi ...");
+  status = read_acpi();
+  if (status == 0)
+    return (0);
 
-	DEBUG ("battery plugin: Trying pmu ...");
-	status = read_pmu ();
-	if (status == 0)
-		return (0);
+  DEBUG("battery plugin: Trying pmu ...");
+  status = read_pmu();
+  if (status == 0)
+    return (0);
 
-	ERROR ("battery plugin: All available input methods failed.");
-	return (-1);
+  ERROR("battery plugin: All available input methods failed.");
+  return (-1);
 } /* }}} int battery_read */
 #endif /* KERNEL_LINUX */
 
-static int battery_config (oconfig_item_t *ci)
-{
-	for (int i = 0; i < ci->children_num; i++)
-	{
-		oconfig_item_t *child = ci->children + i;
-
-		if (strcasecmp ("ValuesPercentage", child->key) == 0)
-			cf_util_get_boolean (child, &report_percent);
-		else if (strcasecmp ("ReportDegraded", child->key) == 0)
-			cf_util_get_boolean (child, &report_degraded);
-		else if (strcasecmp ("QueryStateFS", child->key) == 0)
-			cf_util_get_boolean (child, &query_statefs);
-		else
-			WARNING ("battery plugin: Ignoring unknown "
-					"configuration option \"%s\".",
-					child->key);
-	}
-
-	return (0);
+static int battery_config(oconfig_item_t *ci) {
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("ValuesPercentage", child->key) == 0)
+      cf_util_get_boolean(child, &report_percent);
+    else if (strcasecmp("ReportDegraded", child->key) == 0)
+      cf_util_get_boolean(child, &report_degraded);
+    else if (strcasecmp("QueryStateFS", child->key) == 0)
+      cf_util_get_boolean(child, &query_statefs);
+    else
+      WARNING("battery plugin: Ignoring unknown "
+              "configuration option \"%s\".",
+              child->key);
+  }
+
+  return (0);
 } /* }}} int battery_config */
 
-void module_register (void)
-{
-	plugin_register_complex_config ("battery", battery_config);
-	plugin_register_read ("battery", battery_read);
+void module_register(void) {
+  plugin_register_complex_config("battery", battery_config);
+  plugin_register_read("battery", battery_read);
 } /* void module_register */
@@ -44,9 +44,9 @@ SOFTWARE.
 
  **/
 
-#include "collectd.h"
 #include "common.h"
 #include "plugin.h"
+#include "collectd.h"
 
 #include <stdio.h>
 
@@ -56,7 +56,7 @@ static void battery_submit(const char *type, gauge_t value,
                            const char *type_instance) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  vl.values = &(value_t) { .gauge = value };
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
   sstrncpy(vl.plugin, "battery", sizeof(vl.plugin));
   /* statefs supports 1 battery at present */
@@ -72,16 +72,18 @@ int battery_read_statefs(void) {
   value_t v;
   int success = 0;
 
-  if (parse_value_file(STATEFS_ROOT "ChargePercentage", &v, DS_TYPE_GAUGE) == 0) {
+  if (parse_value_file(STATEFS_ROOT "ChargePercentage", &v, DS_TYPE_GAUGE) ==
+      0) {
     battery_submit("charge", v.gauge, NULL);
     success++;
-  } else if (parse_value_file(STATEFS_ROOT "Capacity", &v, DS_TYPE_GAUGE) == 0) {
+  } else if (parse_value_file(STATEFS_ROOT "Capacity", &v, DS_TYPE_GAUGE) ==
+             0) {
     // Use capacity as a charge estimate if ChargePercentage is not available
     battery_submit("charge", v.gauge, NULL);
     success++;
   } else {
-    WARNING("battery plugin: Neither \""STATEFS_ROOT"ChargePercentage\" "
-            "nor \""STATEFS_ROOT"Capacity\" could be read.");
+    WARNING("battery plugin: Neither \"" STATEFS_ROOT "ChargePercentage\" "
+            "nor \"" STATEFS_ROOT "Capacity\" could be read.");
   }
 
   struct {
@@ -90,13 +92,13 @@ int battery_read_statefs(void) {
     char *type_instance;
     gauge_t factor;
   } metrics[] = {
-    {STATEFS_ROOT "Current",       "current",     NULL,  1e-6}, // from uA to A
-    {STATEFS_ROOT "Energy",        "energy_wh",   NULL,  1e-6}, // from uWh to Wh
-    {STATEFS_ROOT "Power",         "power",       NULL,  1e-6}, // from uW to W
-    {STATEFS_ROOT "Temperature",   "temperature", NULL,   0.1}, // from 10xC to C
-    {STATEFS_ROOT "TimeUntilFull", "duration",    "full", 1.0},
-    {STATEFS_ROOT "TimeUntilLow",  "duration",    "low",  1.0},
-    {STATEFS_ROOT "Voltage",       "voltage",     NULL,  1e-6}, // from uV to V
+      {STATEFS_ROOT "Current", "current", NULL, 1e-6},        // from uA to A
+      {STATEFS_ROOT "Energy", "energy_wh", NULL, 1e-6},       // from uWh to Wh
+      {STATEFS_ROOT "Power", "power", NULL, 1e-6},            // from uW to W
+      {STATEFS_ROOT "Temperature", "temperature", NULL, 0.1}, // from 10xC to C
+      {STATEFS_ROOT "TimeUntilFull", "duration", "full", 1.0},
+      {STATEFS_ROOT "TimeUntilLow", "duration", "low", 1.0},
+      {STATEFS_ROOT "Voltage", "voltage", NULL, 1e-6}, // from uV to V
   };
 
   for (size_t i = 0; i < STATIC_ARRAY_SIZE(metrics); i++) {
@@ -105,12 +107,14 @@ int battery_read_statefs(void) {
       continue;
     }
 
-    battery_submit(metrics[i].type, v.gauge * metrics[i].factor, metrics[i].type_instance);
+    battery_submit(metrics[i].type, v.gauge * metrics[i].factor,
+                   metrics[i].type_instance);
     success++;
   }
 
   if (success == 0) {
-    ERROR("battery plugin: statefs backend: none of the statistics are available");
+    ERROR("battery plugin: statefs backend: none of the statistics are "
+          "available");
     return (-1);
   }
 
@@ -24,15 +24,15 @@
 #include "config.h"
 
 #if STRPTIME_NEEDS_STANDARDS
-# ifndef _ISOC99_SOURCE
-#  define _ISOC99_SOURCE 1
-# endif
-# ifndef _POSIX_C_SOURCE
-#  define _POSIX_C_SOURCE 200112L
-# endif
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
+#ifndef _ISOC99_SOURCE
+#define _ISOC99_SOURCE 1
+#endif
+#ifndef _POSIX_C_SOURCE
+#define _POSIX_C_SOURCE 200112L
+#endif
+#ifndef _XOPEN_SOURCE
+#define _XOPEN_SOURCE 500
+#endif
 #endif /* STRPTIME_NEEDS_STANDARDS */
 
 #include "collectd.h"
@@ -43,27 +43,26 @@
 /* Some versions of libcurl don't include this themselves and then don't have
  * fd_set available. */
 #if HAVE_SYS_SELECT_H
-# include <sys/select.h>
+#include <sys/select.h>
 #endif
 
 #include <curl/curl.h>
 #include <libxml/parser.h>
 #include <libxml/xpath.h>
 
 #ifndef BIND_DEFAULT_URL
-# define BIND_DEFAULT_URL "http://localhost:8053/"
+#define BIND_DEFAULT_URL "http://localhost:8053/"
 #endif
 
 /*
  * Some types used for the callback functions. `translation_table_ptr_t' and
  * `list_info_ptr_t' are passed to the callbacks in the `void *user_data'
  * pointer.
  */
-typedef int (*list_callback_t) (const char *name, value_t value,
-    time_t current_time, void *user_data);
+typedef int (*list_callback_t)(const char *name, value_t value,
+                               time_t current_time, void *user_data);
 
-struct cb_view_s
-{
+struct cb_view_s {
   char *name;
 
   int qtypes;
@@ -75,24 +74,21 @@ struct cb_view_s
 };
 typedef struct cb_view_s cb_view_t;
 
-struct translation_info_s
-{
+struct translation_info_s {
   const char *xml_name;
   const char *type;
   const char *type_instance;
 };
 typedef struct translation_info_s translation_info_t;
 
-struct translation_table_ptr_s
-{
+struct translation_table_ptr_s {
   const translation_info_t *table;
   size_t table_length;
   const char *plugin_instance;
 };
 typedef struct translation_table_ptr_s translation_table_ptr_t;
 
-struct list_info_ptr_s
-{
+struct list_info_ptr_s {
   const char *plugin_instance;
   const char *type;
 };
@@ -102,62 +98,62 @@ typedef struct list_info_ptr_s list_info_ptr_t;
 /* TODO: Remove time parsing code. */
 static _Bool config_parse_time = 1;
 
-static char *url                   = NULL;
-static int global_opcodes          = 1;
-static int global_qtypes           = 1;
-static int global_server_stats     = 1;
+static char *url = NULL;
+static int global_opcodes = 1;
+static int global_qtypes = 1;
+static int global_server_stats = 1;
 static int global_zone_maint_stats = 1;
-static int global_resolver_stats   = 0;
-static int global_memory_stats     = 1;
-static int timeout                 = -1;
+static int global_resolver_stats = 0;
+static int global_memory_stats = 1;
+static int timeout = -1;
 
 static cb_view_t *views = NULL;
-static size_t     views_num = 0;
+static size_t views_num = 0;
 
 static CURL *curl = NULL;
 
-static char  *bind_buffer = NULL;
+static char *bind_buffer = NULL;
 static size_t bind_buffer_size = 0;
 static size_t bind_buffer_fill = 0;
-static char   bind_curl_error[CURL_ERROR_SIZE];
+static char bind_curl_error[CURL_ERROR_SIZE];
 
 /* Translation table for the `nsstats' values. */
 static const translation_info_t nsstats_translation_table[] = /* {{{ */
-{
-  /* Requests */
-  { "Requestv4",       "dns_request",  "IPv4"          },
-  { "Requestv6",       "dns_request",  "IPv6"          },
-  { "ReqEdns0",        "dns_request",  "EDNS0"         },
-  { "ReqBadEDNSVer",   "dns_request",  "BadEDNSVer"    },
-  { "ReqTSIG",         "dns_request",  "TSIG"          },
-  { "ReqSIG0",         "dns_request",  "SIG0"          },
-  { "ReqBadSIG",       "dns_request",  "BadSIG"        },
-  { "ReqTCP",          "dns_request",  "TCP"           },
-  /* Rejects */
-  { "AuthQryRej",      "dns_reject",   "authoritative" },
-  { "RecQryRej",       "dns_reject",   "recursive"     },
-  { "XfrRej",          "dns_reject",   "transfer"      },
-  { "UpdateRej",       "dns_reject",   "update"        },
-  /* Responses */
-  { "Response",        "dns_response", "normal"        },
-  { "TruncatedResp",   "dns_response", "truncated"     },
-  { "RespEDNS0",       "dns_response", "EDNS0"         },
-  { "RespTSIG",        "dns_response", "TSIG"          },
-  { "RespSIG0",        "dns_response", "SIG0"          },
-  /* Queries */
-  { "QryAuthAns",      "dns_query",    "authoritative" },
-  { "QryNoauthAns",    "dns_query",    "nonauth"       },
-  { "QryReferral",     "dns_query",    "referral"      },
-  { "QryRecursion",    "dns_query",    "recursion"     },
-  { "QryDuplicate",    "dns_query",    "duplicate"     },
-  { "QryDropped",      "dns_query",    "dropped"       },
-  { "QryFailure",      "dns_query",    "failure"       },
-  /* Response codes */
-  { "QrySuccess",      "dns_rcode",    "tx-NOERROR"    },
-  { "QryNxrrset",      "dns_rcode",    "tx-NXRRSET"    },
-  { "QrySERVFAIL",     "dns_rcode",    "tx-SERVFAIL"   },
-  { "QryFORMERR",      "dns_rcode",    "tx-FORMERR"    },
-  { "QryNXDOMAIN",     "dns_rcode",    "tx-NXDOMAIN"   }
+    {
+        /* Requests */
+        {"Requestv4", "dns_request", "IPv4"},
+        {"Requestv6", "dns_request", "IPv6"},
+        {"ReqEdns0", "dns_request", "EDNS0"},
+        {"ReqBadEDNSVer", "dns_request", "BadEDNSVer"},
+        {"ReqTSIG", "dns_request", "TSIG"},
+        {"ReqSIG0", "dns_request", "SIG0"},
+        {"ReqBadSIG", "dns_request", "BadSIG"},
+        {"ReqTCP", "dns_request", "TCP"},
+        /* Rejects */
+        {"AuthQryRej", "dns_reject", "authoritative"},
+        {"RecQryRej", "dns_reject", "recursive"},
+        {"XfrRej", "dns_reject", "transfer"},
+        {"UpdateRej", "dns_reject", "update"},
+        /* Responses */
+        {"Response", "dns_response", "normal"},
+        {"TruncatedResp", "dns_response", "truncated"},
+        {"RespEDNS0", "dns_response", "EDNS0"},
+        {"RespTSIG", "dns_response", "TSIG"},
+        {"RespSIG0", "dns_response", "SIG0"},
+        /* Queries */
+        {"QryAuthAns", "dns_query", "authoritative"},
+        {"QryNoauthAns", "dns_query", "nonauth"},
+        {"QryReferral", "dns_query", "referral"},
+        {"QryRecursion", "dns_query", "recursion"},
+        {"QryDuplicate", "dns_query", "duplicate"},
+        {"QryDropped", "dns_query", "dropped"},
+        {"QryFailure", "dns_query", "failure"},
+        /* Response codes */
+        {"QrySuccess", "dns_rcode", "tx-NOERROR"},
+        {"QryNxrrset", "dns_rcode", "tx-NXRRSET"},
+        {"QrySERVFAIL", "dns_rcode", "tx-SERVFAIL"},
+        {"QryFORMERR", "dns_rcode", "tx-FORMERR"},
+        {"QryNXDOMAIN", "dns_rcode", "tx-NXDOMAIN"}
 #if 0
   { "XfrReqDone",      "type",         "type_instance" },
   { "UpdateReqFwd",    "type",         "type_instance" },
@@ -169,128 +165,119 @@ static const translation_info_t nsstats_translation_table[] = /* {{{ */
 #endif
 };
 static int nsstats_translation_table_length =
-  STATIC_ARRAY_SIZE (nsstats_translation_table);
+    STATIC_ARRAY_SIZE(nsstats_translation_table);
 /* }}} */
 
 /* Translation table for the `zonestats' values. */
 static const translation_info_t zonestats_translation_table[] = /* {{{ */
-{
-  /* Notify's */
-  { "NotifyOutv4",     "dns_notify",   "tx-IPv4"     },
-  { "NotifyOutv6",     "dns_notify",   "tx-IPv6"     },
-  { "NotifyInv4",      "dns_notify",   "rx-IPv4"     },
-  { "NotifyInv6",      "dns_notify",   "rx-IPv6"     },
-  { "NotifyRej",       "dns_notify",   "rejected"    },
-  /* SOA/AXFS/IXFS requests */
-  { "SOAOutv4",        "dns_opcode",   "SOA-IPv4"    },
-  { "SOAOutv6",        "dns_opcode",   "SOA-IPv6"    },
-  { "AXFRReqv4",       "dns_opcode",   "AXFR-IPv4"   },
-  { "AXFRReqv6",       "dns_opcode",   "AXFR-IPv6"   },
-  { "IXFRReqv4",       "dns_opcode",   "IXFR-IPv4"   },
-  { "IXFRReqv6",       "dns_opcode",   "IXFR-IPv6"   },
-  /* Domain transfers */
-  { "XfrSuccess",      "dns_transfer", "success"     },
-  { "XfrFail",         "dns_transfer", "failure"     }
-};
+    {
+        /* Notify's */
+        {"NotifyOutv4", "dns_notify", "tx-IPv4"},
+        {"NotifyOutv6", "dns_notify", "tx-IPv6"},
+        {"NotifyInv4", "dns_notify", "rx-IPv4"},
+        {"NotifyInv6", "dns_notify", "rx-IPv6"},
+        {"NotifyRej", "dns_notify", "rejected"},
+        /* SOA/AXFS/IXFS requests */
+        {"SOAOutv4", "dns_opcode", "SOA-IPv4"},
+        {"SOAOutv6", "dns_opcode", "SOA-IPv6"},
+        {"AXFRReqv4", "dns_opcode", "AXFR-IPv4"},
+        {"AXFRReqv6", "dns_opcode", "AXFR-IPv6"},
+        {"IXFRReqv4", "dns_opcode", "IXFR-IPv4"},
+        {"IXFRReqv6", "dns_opcode", "IXFR-IPv6"},
+        /* Domain transfers */
+        {"XfrSuccess", "dns_transfer", "success"},
+        {"XfrFail", "dns_transfer", "failure"}};
 static int zonestats_translation_table_length =
-  STATIC_ARRAY_SIZE (zonestats_translation_table);
+    STATIC_ARRAY_SIZE(zonestats_translation_table);
 /* }}} */
 
 /* Translation table for the `resstats' values. */
 static const translation_info_t resstats_translation_table[] = /* {{{ */
-{
-  /* Generic resolver information */
-  { "Queryv4",         "dns_query",    "IPv4"        },
-  { "Queryv6",         "dns_query",    "IPv6"        },
-  { "Responsev4",      "dns_response", "IPv4"        },
-  { "Responsev6",      "dns_response", "IPv6"        },
-  /* Received response codes */
-  { "NXDOMAIN",        "dns_rcode",    "rx-NXDOMAIN" },
-  { "SERVFAIL",        "dns_rcode",    "rx-SERVFAIL" },
-  { "FORMERR",         "dns_rcode",    "rx-FORMERR"  },
-  { "OtherError",      "dns_rcode",    "rx-OTHER"    },
-  { "EDNS0Fail",       "dns_rcode",    "rx-EDNS0Fail"},
-  /* Received responses */
-  { "Mismatch",        "dns_response", "mismatch"    },
-  { "Truncated",       "dns_response", "truncated"   },
-  { "Lame",            "dns_response", "lame"        },
-  { "Retry",           "dns_query",    "retry"       },
+    {
+        /* Generic resolver information */
+        {"Queryv4", "dns_query", "IPv4"},
+        {"Queryv6", "dns_query", "IPv6"},
+        {"Responsev4", "dns_response", "IPv4"},
+        {"Responsev6", "dns_response", "IPv6"},
+        /* Received response codes */
+        {"NXDOMAIN", "dns_rcode", "rx-NXDOMAIN"},
+        {"SERVFAIL", "dns_rcode", "rx-SERVFAIL"},
+        {"FORMERR", "dns_rcode", "rx-FORMERR"},
+        {"OtherError", "dns_rcode", "rx-OTHER"},
+        {"EDNS0Fail", "dns_rcode", "rx-EDNS0Fail"},
+        /* Received responses */
+        {"Mismatch", "dns_response", "mismatch"},
+        {"Truncated", "dns_response", "truncated"},
+        {"Lame", "dns_response", "lame"},
+        {"Retry", "dns_query", "retry"},
 #if 0
   { "GlueFetchv4",     "type", "type_instance" },
   { "GlueFetchv6",     "type", "type_instance" },
   { "GlueFetchv4Fail", "type", "type_instance" },
   { "GlueFetchv6Fail", "type", "type_instance" },
 #endif
-  /* DNSSEC information */
-  { "ValAttempt",      "dns_resolver", "DNSSEC-attempt" },
-  { "ValOk",           "dns_resolver", "DNSSEC-okay"    },
-  { "ValNegOk",        "dns_resolver", "DNSSEC-negokay" },
-  { "ValFail",         "dns_resolver", "DNSSEC-fail"    }
-};
+        /* DNSSEC information */
+        {"ValAttempt", "dns_resolver", "DNSSEC-attempt"},
+        {"ValOk", "dns_resolver", "DNSSEC-okay"},
+        {"ValNegOk", "dns_resolver", "DNSSEC-negokay"},
+        {"ValFail", "dns_resolver", "DNSSEC-fail"}};
 static int resstats_translation_table_length =
-  STATIC_ARRAY_SIZE (resstats_translation_table);
+    STATIC_ARRAY_SIZE(resstats_translation_table);
 /* }}} */
 
 /* Translation table for the `memory/summary' values. */
 static const translation_info_t memsummary_translation_table[] = /* {{{ */
-{
-  { "TotalUse",        "memory",       "TotalUse"    },
-  { "InUse",           "memory",       "InUse"       },
-  { "BlockSize",       "memory",       "BlockSize"   },
-  { "ContextSize",     "memory",       "ContextSize" },
-  { "Lost",            "memory",       "Lost"        }
-};
+    {{"TotalUse", "memory", "TotalUse"},
+     {"InUse", "memory", "InUse"},
+     {"BlockSize", "memory", "BlockSize"},
+     {"ContextSize", "memory", "ContextSize"},
+     {"Lost", "memory", "Lost"}};
 static int memsummary_translation_table_length =
-  STATIC_ARRAY_SIZE (memsummary_translation_table);
+    STATIC_ARRAY_SIZE(memsummary_translation_table);
 /* }}} */
 
-static void submit (time_t ts, const char *plugin_instance, /* {{{ */
-    const char *type, const char *type_instance, value_t value)
-{
+static void submit(time_t ts, const char *plugin_instance, /* {{{ */
+                   const char *type, const char *type_instance, value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &value;
   vl.values_len = 1;
   if (config_parse_time)
-    vl.time = TIME_T_TO_CDTIME_T (ts);
+    vl.time = TIME_T_TO_CDTIME_T(ts);
   sstrncpy(vl.plugin, "bind", sizeof(vl.plugin));
   if (plugin_instance) {
-    sstrncpy(vl.plugin_instance, plugin_instance,
-        sizeof(vl.plugin_instance));
-    replace_special (vl.plugin_instance, sizeof (vl.plugin_instance));
+    sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
+    replace_special(vl.plugin_instance, sizeof(vl.plugin_instance));
   }
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance) {
-    sstrncpy(vl.type_instance, type_instance,
-        sizeof(vl.type_instance));
-    replace_special (vl.type_instance, sizeof (vl.type_instance));
+    sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
+    replace_special(vl.type_instance, sizeof(vl.type_instance));
   }
   plugin_dispatch_values(&vl);
 } /* }}} void submit */
 
-static size_t bind_curl_callback (void *buf, size_t size, /* {{{ */
-    size_t nmemb, void __attribute__((unused)) *stream)
-{
+static size_t bind_curl_callback(void *buf, size_t size, /* {{{ */
+                                 size_t nmemb,
+                                 void __attribute__((unused)) * stream) {
   size_t len = size * nmemb;
 
   if (len == 0)
     return (len);
 
-  if ((bind_buffer_fill + len) >= bind_buffer_size)
-  {
+  if ((bind_buffer_fill + len) >= bind_buffer_size) {
     char *temp;
 
-    temp = realloc (bind_buffer, bind_buffer_fill + len + 1);
-    if (temp == NULL)
-    {
-      ERROR ("bind plugin: realloc failed.");
+    temp = realloc(bind_buffer, bind_buffer_fill + len + 1);
+    if (temp == NULL) {
+      ERROR("bind plugin: realloc failed.");
       return (0);
     }
     bind_buffer = temp;
     bind_buffer_size = bind_buffer_fill + len + 1;
   }
 
-  memcpy (bind_buffer + bind_buffer_fill, (char *) buf, len);
+  memcpy(bind_buffer + bind_buffer_fill, (char *)buf, len);
   bind_buffer_fill += len;
   bind_buffer[bind_buffer_fill] = 0;
 
@@ -301,24 +288,19 @@ static size_t bind_curl_callback (void *buf, size_t size, /* {{{ */
  * Callback, that's called with a translation table.
  * (Plugin instance is fixed, type and type instance come from lookup table.)
  */
-static int bind_xml_table_callback (const char *name, value_t value, /* {{{ */
-    time_t current_time, void *user_data)
-{
-  translation_table_ptr_t *table = (translation_table_ptr_t *) user_data;
+static int bind_xml_table_callback(const char *name, value_t value, /* {{{ */
+                                   time_t current_time, void *user_data) {
+  translation_table_ptr_t *table = (translation_table_ptr_t *)user_data;
 
   if (table == NULL)
     return (-1);
 
-  for (size_t i = 0; i < table->table_length; i++)
-  {
-    if (strcmp (table->table[i].xml_name, name) != 0)
+  for (size_t i = 0; i < table->table_length; i++) {
+    if (strcmp(table->table[i].xml_name, name) != 0)
       continue;
 
-    submit (current_time,
-        table->plugin_instance,
-        table->table[i].type,
-        table->table[i].type_instance,
-        value);
+    submit(current_time, table->plugin_instance, table->table[i].type,
+           table->table[i].type_instance, value);
     break;
   }
 
@@ -329,42 +311,36 @@ static int bind_xml_table_callback (const char *name, value_t value, /* {{{ */
  * Callback, that's used for lists.
  * (Plugin instance and type are fixed, xml name is used as type instance.)
  */
-static int bind_xml_list_callback (const char *name, /* {{{ */
-    value_t value, time_t current_time, void *user_data)
-{
-  list_info_ptr_t *list_info = (list_info_ptr_t *) user_data;
+static int bind_xml_list_callback(const char *name, /* {{{ */
+                                  value_t value, time_t current_time,
+                                  void *user_data) {
+  list_info_ptr_t *list_info = (list_info_ptr_t *)user_data;
 
   if (list_info == NULL)
     return (-1);
 
-  submit (current_time,
-      list_info->plugin_instance,
-      list_info->type,
-      /* type instance = */ name,
-      value);
+  submit(current_time, list_info->plugin_instance, list_info->type,
+         /* type instance = */ name, value);
 
   return (0);
 } /* }}} int bind_xml_list_callback */
 
-static int bind_xml_read_derive (xmlDoc *doc, xmlNode *node, /* {{{ */
-    derive_t *ret_value)
-{
+static int bind_xml_read_derive(xmlDoc *doc, xmlNode *node, /* {{{ */
+                                derive_t *ret_value) {
   char *str_ptr;
   value_t value;
   int status;
 
-  str_ptr = (char *) xmlNodeListGetString (doc, node->xmlChildrenNode, 1);
-  if (str_ptr == NULL)
-  {
-    ERROR ("bind plugin: bind_xml_read_derive: xmlNodeListGetString failed.");
+  str_ptr = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
+  if (str_ptr == NULL) {
+    ERROR("bind plugin: bind_xml_read_derive: xmlNodeListGetString failed.");
     return (-1);
   }
 
-  status = parse_value (str_ptr, &value, DS_TYPE_DERIVE);
-  if (status != 0)
-  {
-    ERROR ("bind plugin: Parsing string \"%s\" to derive value failed.",
-        str_ptr);
+  status = parse_value(str_ptr, &value, DS_TYPE_DERIVE);
+  if (status != 0) {
+    ERROR("bind plugin: Parsing string \"%s\" to derive value failed.",
+          str_ptr);
     xmlFree(str_ptr);
     return (-1);
   }
@@ -374,97 +350,88 @@ static int bind_xml_read_derive (xmlDoc *doc, xmlNode *node, /* {{{ */
   return (0);
 } /* }}} int bind_xml_read_derive */
 
-static int bind_xml_read_gauge (xmlDoc *doc, xmlNode *node, /* {{{ */
-    gauge_t *ret_value)
-{
+static int bind_xml_read_gauge(xmlDoc *doc, xmlNode *node, /* {{{ */
+                               gauge_t *ret_value) {
   char *str_ptr, *end_ptr;
   double value;
 
-  str_ptr = (char *) xmlNodeListGetString (doc, node->xmlChildrenNode, 1);
-  if (str_ptr == NULL)
-  {
-    ERROR ("bind plugin: bind_xml_read_gauge: xmlNodeListGetString failed.");
+  str_ptr = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
+  if (str_ptr == NULL) {
+    ERROR("bind plugin: bind_xml_read_gauge: xmlNodeListGetString failed.");
     return (-1);
   }
 
   errno = 0;
-  value = strtod (str_ptr, &end_ptr);
+  value = strtod(str_ptr, &end_ptr);
   xmlFree(str_ptr);
-  if (str_ptr == end_ptr || errno)
-  {
+  if (str_ptr == end_ptr || errno) {
     if (errno && (value < 0))
-      ERROR ("bind plugin: bind_xml_read_gauge: strtod failed with underflow.");
+      ERROR("bind plugin: bind_xml_read_gauge: strtod failed with underflow.");
     else if (errno && (value > 0))
-      ERROR ("bind plugin: bind_xml_read_gauge: strtod failed with overflow.");
+      ERROR("bind plugin: bind_xml_read_gauge: strtod failed with overflow.");
     else
-      ERROR ("bind plugin: bind_xml_read_gauge: strtod failed.");
+      ERROR("bind plugin: bind_xml_read_gauge: strtod failed.");
     return (-1);
   }
 
-  *ret_value = (gauge_t) value;
+  *ret_value = (gauge_t)value;
   return (0);
 } /* }}} int bind_xml_read_gauge */
 
-static int bind_xml_read_timestamp (const char *xpath_expression, /* {{{ */
-    xmlDoc *doc, xmlXPathContext *xpathCtx, time_t *ret_value)
-{
+static int bind_xml_read_timestamp(const char *xpath_expression, /* {{{ */
+                                   xmlDoc *doc, xmlXPathContext *xpathCtx,
+                                   time_t *ret_value) {
   xmlXPathObject *xpathObj = NULL;
   xmlNode *node;
   char *str_ptr;
   char *tmp;
-  struct tm tm = { 0 };
+  struct tm tm = {0};
 
-  xpathObj = xmlXPathEvalExpression (BAD_CAST xpath_expression, xpathCtx);
-  if (xpathObj == NULL)
-  {
-    ERROR ("bind plugin: Unable to evaluate XPath expression `%s'.",
-        xpath_expression);
+  xpathObj = xmlXPathEvalExpression(BAD_CAST xpath_expression, xpathCtx);
+  if (xpathObj == NULL) {
+    ERROR("bind plugin: Unable to evaluate XPath expression `%s'.",
+          xpath_expression);
     return (-1);
   }
 
-  if ((xpathObj->nodesetval == NULL) || (xpathObj->nodesetval->nodeNr < 1))
-  {
-    xmlXPathFreeObject (xpathObj);
+  if ((xpathObj->nodesetval == NULL) || (xpathObj->nodesetval->nodeNr < 1)) {
+    xmlXPathFreeObject(xpathObj);
     return (-1);
   }
 
-  if (xpathObj->nodesetval->nodeNr != 1)
-  {
-    NOTICE ("bind plugin: Evaluating the XPath expression `%s' returned "
-        "%i nodes. Only handling the first one.",
-        xpath_expression, xpathObj->nodesetval->nodeNr);
+  if (xpathObj->nodesetval->nodeNr != 1) {
+    NOTICE("bind plugin: Evaluating the XPath expression `%s' returned "
+           "%i nodes. Only handling the first one.",
+           xpath_expression, xpathObj->nodesetval->nodeNr);
   }
 
   node = xpathObj->nodesetval->nodeTab[0];
 
-  if (node->xmlChildrenNode == NULL)
-  {
-    ERROR ("bind plugin: bind_xml_read_timestamp: "
-        "node->xmlChildrenNode == NULL");
-    xmlXPathFreeObject (xpathObj);
+  if (node->xmlChildrenNode == NULL) {
+    ERROR("bind plugin: bind_xml_read_timestamp: "
+          "node->xmlChildrenNode == NULL");
+    xmlXPathFreeObject(xpathObj);
     return (-1);
   }
 
-  str_ptr = (char *) xmlNodeListGetString (doc, node->xmlChildrenNode, 1);
-  if (str_ptr == NULL)
-  {
-    ERROR ("bind plugin: bind_xml_read_timestamp: xmlNodeListGetString failed.");
-    xmlXPathFreeObject (xpathObj);
+  str_ptr = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
+  if (str_ptr == NULL) {
+    ERROR("bind plugin: bind_xml_read_timestamp: xmlNodeListGetString failed.");
+    xmlXPathFreeObject(xpathObj);
     return (-1);
   }
 
-  tmp = strptime (str_ptr, "%Y-%m-%dT%T", &tm);
+  tmp = strptime(str_ptr, "%Y-%m-%dT%T", &tm);
   xmlFree(str_ptr);
-  if (tmp == NULL)
-  {
-    ERROR ("bind plugin: bind_xml_read_timestamp: strptime failed.");
-    xmlXPathFreeObject (xpathObj);
+  if (tmp == NULL) {
+    ERROR("bind plugin: bind_xml_read_timestamp: strptime failed.");
+    xmlXPathFreeObject(xpathObj);
     return (-1);
   }
 
   *ret_value = mktime(&tm);
 
-  xmlXPathFreeObject (xpathObj);
+  xmlXPathFreeObject(xpathObj);
   return (0);
 } /* }}} int bind_xml_read_timestamp */
 
@@ -477,74 +444,68 @@ static int bind_xml_read_timestamp (const char *xpath_expression, /* {{{ */
  *   <counter>123</counter>
  * </foo>
  */
-static int bind_parse_generic_name_value (const char *xpath_expression, /* {{{ */
-    list_callback_t list_callback,
-    void *user_data,
-    xmlDoc *doc, xmlXPathContext *xpathCtx,
-    time_t current_time, int ds_type)
-{
+static int bind_parse_generic_name_value(const char *xpath_expression, /* {{{ */
+                                         list_callback_t list_callback,
+                                         void *user_data, xmlDoc *doc,
+                                         xmlXPathContext *xpathCtx,
+                                         time_t current_time, int ds_type) {
   xmlXPathObject *xpathObj = NULL;
   int num_entries;
 
   xpathObj = xmlXPathEvalExpression(BAD_CAST xpath_expression, xpathCtx);
-  if (xpathObj == NULL)
-  {
+  if (xpathObj == NULL) {
     ERROR("bind plugin: Unable to evaluate XPath expression `%s'.",
-        xpath_expression);
+          xpath_expression);
     return (-1);
   }
 
   num_entries = 0;
   /* Iterate over all matching nodes. */
-  for (int i = 0; xpathObj->nodesetval && (i < xpathObj->nodesetval->nodeNr); i++)
-  {
+  for (int i = 0; xpathObj->nodesetval && (i < xpathObj->nodesetval->nodeNr);
+       i++) {
     xmlNode *name_node = NULL;
     xmlNode *counter = NULL;
     xmlNode *parent;
 
     parent = xpathObj->nodesetval->nodeTab[i];
-    DEBUG ("bind plugin: bind_parse_generic_name_value: parent->name = %s;",
-        (char *) parent->name);
+    DEBUG("bind plugin: bind_parse_generic_name_value: parent->name = %s;",
+          (char *)parent->name);
 
     /* Iterate over all child nodes. */
-    for (xmlNode *child = parent->xmlChildrenNode;
-        child != NULL;
-        child = child->next)
-    {
+    for (xmlNode *child = parent->xmlChildrenNode; child != NULL;
+         child = child->next) {
       if (child->type != XML_ELEMENT_NODE)
         continue;
 
-      if (xmlStrcmp (BAD_CAST "name", child->name) == 0)
+      if (xmlStrcmp(BAD_CAST "name", child->name) == 0)
         name_node = child;
-      else if (xmlStrcmp (BAD_CAST "counter", child->name) == 0)
+      else if (xmlStrcmp(BAD_CAST "counter", child->name) == 0)
         counter = child;
     }
 
-    if ((name_node != NULL) && (counter != NULL))
-    {
-      char *name = (char *) xmlNodeListGetString (doc,
-          name_node->xmlChildrenNode, 1);
+    if ((name_node != NULL) && (counter != NULL)) {
+      char *name =
+          (char *)xmlNodeListGetString(doc, name_node->xmlChildrenNode, 1);
       value_t value;
       int status;
 
       if (ds_type == DS_TYPE_GAUGE)
-        status = bind_xml_read_gauge (doc, counter, &value.gauge);
+        status = bind_xml_read_gauge(doc, counter, &value.gauge);
       else
-        status = bind_xml_read_derive (doc, counter, &value.derive);
+        status = bind_xml_read_derive(doc, counter, &value.derive);
       if (status != 0)
         continue;
 
-      status = (*list_callback) (name, value, current_time, user_data);
+      status = (*list_callback)(name, value, current_time, user_data);
       if (status == 0)
         num_entries++;
 
-      xmlFree (name);
+      xmlFree(name);
     }
   }
 
-  DEBUG ("bind plugin: Found %d %s for XPath expression `%s'",
-      num_entries, (num_entries == 1) ? "entry" : "entries",
-      xpath_expression);
+  DEBUG("bind plugin: Found %d %s for XPath expression `%s'", num_entries,
+        (num_entries == 1) ? "entry" : "entries", xpath_expression);
 
   xmlXPathFreeObject(xpathObj);
 
@@ -562,57 +523,52 @@ static int bind_parse_generic_name_value (const char *xpath_expression, /* {{{ *
  *   :
  * </foo>
  */
-static int bind_parse_generic_value_list (const char *xpath_expression, /* {{{ */
-    list_callback_t list_callback,
-    void *user_data,
-    xmlDoc *doc, xmlXPathContext *xpathCtx,
-    time_t current_time, int ds_type)
-{
+static int bind_parse_generic_value_list(const char *xpath_expression, /* {{{ */
+                                         list_callback_t list_callback,
+                                         void *user_data, xmlDoc *doc,
+                                         xmlXPathContext *xpathCtx,
+                                         time_t current_time, int ds_type) {
   xmlXPathObject *xpathObj = NULL;
   int num_entries;
 
   xpathObj = xmlXPathEvalExpression(BAD_CAST xpath_expression, xpathCtx);
-  if (xpathObj == NULL)
-  {
+  if (xpathObj == NULL) {
     ERROR("bind plugin: Unable to evaluate XPath expression `%s'.",
-        xpath_expression);
+          xpath_expression);
     return (-1);
   }
 
   num_entries = 0;
   /* Iterate over all matching nodes. */
-  for (int i = 0; xpathObj->nodesetval && (i < xpathObj->nodesetval->nodeNr); i++)
-  {
+  for (int i = 0; xpathObj->nodesetval && (i < xpathObj->nodesetval->nodeNr);
+       i++) {
     /* Iterate over all child nodes. */
     for (xmlNode *child = xpathObj->nodesetval->nodeTab[i]->xmlChildrenNode;
-        child != NULL;
-        child = child->next)
-    {
+         child != NULL; child = child->next) {
       char *node_name;
       value_t value;
       int status;
 
       if (child->type != XML_ELEMENT_NODE)
         continue;
 
-      node_name = (char *) child->name;
+      node_name = (char *)child->name;
 
       if (ds_type == DS_TYPE_GAUGE)
-        status = bind_xml_read_gauge (doc, child, &value.gauge);
+        status = bind_xml_read_gauge(doc, child, &value.gauge);
       else
-        status = bind_xml_read_derive (doc, child, &value.derive);
+        status = bind_xml_read_derive(doc, child, &value.derive);
       if (status != 0)
         continue;
 
-      status = (*list_callback) (node_name, value, current_time, user_data);
+      status = (*list_callback)(node_name, value, current_time, user_data);
       if (status == 0)
         num_entries++;
     }
   }
 
-  DEBUG ("bind plugin: Found %d %s for XPath expression `%s'",
-      num_entries, (num_entries == 1) ? "entry" : "entries",
-      xpath_expression);
+  DEBUG("bind plugin: Found %d %s for XPath expression `%s'", num_entries,
+        (num_entries == 1) ? "entry" : "entries", xpath_expression);
 
   xmlXPathFreeObject(xpathObj);
 
@@ -630,406 +586,355 @@ static int bind_parse_generic_value_list (const char *xpath_expression, /* {{{ *
  *   :
  * </foo>
  */
-static int bind_parse_generic_name_attr_value_list (const char *xpath_expression, /* {{{ */
-    list_callback_t list_callback,
-    void *user_data,
-    xmlDoc *doc, xmlXPathContext *xpathCtx,
-    time_t current_time, int ds_type)
-{
+static int bind_parse_generic_name_attr_value_list(
+    const char *xpath_expression, /* {{{ */
+    list_callback_t list_callback, void *user_data, xmlDoc *doc,
+    xmlXPathContext *xpathCtx, time_t current_time, int ds_type) {
   xmlXPathObject *xpathObj = NULL;
   int num_entries;
 
   xpathObj = xmlXPathEvalExpression(BAD_CAST xpath_expression, xpathCtx);
-  if (xpathObj == NULL)
-  {
+  if (xpathObj == NULL) {
     ERROR("bind plugin: Unable to evaluate XPath expression `%s'.",
-        xpath_expression);
+          xpath_expression);
     return (-1);
   }
 
   num_entries = 0;
   /* Iterate over all matching nodes. */
-  for (int i = 0; xpathObj->nodesetval && (i < xpathObj->nodesetval->nodeNr); i++)
-  {
+  for (int i = 0; xpathObj->nodesetval && (i < xpathObj->nodesetval->nodeNr);
+       i++) {
     /* Iterate over all child nodes. */
     for (xmlNode *child = xpathObj->nodesetval->nodeTab[i]->xmlChildrenNode;
-        child != NULL;
-        child = child->next)
-    {
+         child != NULL; child = child->next) {
       if (child->type != XML_ELEMENT_NODE)
         continue;
 
-      if (strncmp ("counter", (char *) child->name, strlen ("counter")) != 0)
+      if (strncmp("counter", (char *)child->name, strlen("counter")) != 0)
         continue;
 
       char *attr_name;
       value_t value;
       int status;
 
-      attr_name = (char *) xmlGetProp (child, BAD_CAST "name");
-      if (attr_name == NULL)
-      {
-        DEBUG ("bind plugin: found <counter> without name.");
+      attr_name = (char *)xmlGetProp(child, BAD_CAST "name");
+      if (attr_name == NULL) {
+        DEBUG("bind plugin: found <counter> without name.");
         continue;
       }
       if (ds_type == DS_TYPE_GAUGE)
-        status = bind_xml_read_gauge (doc, child, &value.gauge);
+        status = bind_xml_read_gauge(doc, child, &value.gauge);
       else
-        status = bind_xml_read_derive (doc, child, &value.derive);
+        status = bind_xml_read_derive(doc, child, &value.derive);
       if (status != 0)
         continue;
 
-      status = (*list_callback) (attr_name, value, current_time, user_data);
+      status = (*list_callback)(attr_name, value, current_time, user_data);
       if (status == 0)
         num_entries++;
     }
   }
 
-  DEBUG ("bind plugin: Found %d %s for XPath expression `%s'",
-      num_entries, (num_entries == 1) ? "entry" : "entries",
-      xpath_expression);
+  DEBUG("bind plugin: Found %d %s for XPath expression `%s'", num_entries,
+        (num_entries == 1) ? "entry" : "entries", xpath_expression);
 
   xmlXPathFreeObject(xpathObj);
 
   return (0);
 } /* }}} int bind_parse_generic_name_attr_value_list */
 
-static int bind_xml_stats_handle_zone (int version, xmlDoc *doc, /* {{{ */
-    xmlXPathContext *path_ctx, xmlNode *node, cb_view_t *view,
-    time_t current_time)
-{
+static int bind_xml_stats_handle_zone(int version, xmlDoc *doc, /* {{{ */
+                                      xmlXPathContext *path_ctx, xmlNode *node,
+                                      cb_view_t *view, time_t current_time) {
   xmlXPathObject *path_obj;
   char *zone_name = NULL;
   size_t j;
 
-  if (version >= 3)
-  {
-    char *n = (char *) xmlGetProp (node, BAD_CAST "name");
-    char *c = (char *) xmlGetProp (node, BAD_CAST "rdataclass");
-    if (n && c)
-    {
-      zone_name = (char *) xmlMalloc(strlen(n) + strlen(c) + 2);
+  if (version >= 3) {
+    char *n = (char *)xmlGetProp(node, BAD_CAST "name");
+    char *c = (char *)xmlGetProp(node, BAD_CAST "rdataclass");
+    if (n && c) {
+      zone_name = (char *)xmlMalloc(strlen(n) + strlen(c) + 2);
       snprintf(zone_name, strlen(n) + strlen(c) + 2, "%s/%s", n, c);
     }
     xmlFree(n);
     xmlFree(c);
-  }
-  else
-  {
-    path_obj = xmlXPathEvalExpression (BAD_CAST "name", path_ctx);
-    if (path_obj == NULL)
-    {
-      ERROR ("bind plugin: xmlXPathEvalExpression failed.");
+  } else {
+    path_obj = xmlXPathEvalExpression(BAD_CAST "name", path_ctx);
+    if (path_obj == NULL) {
+      ERROR("bind plugin: xmlXPathEvalExpression failed.");
       return (-1);
     }
 
-    for (int i = 0; path_obj->nodesetval && (i < path_obj->nodesetval->nodeNr); i++)
-    {
-      zone_name = (char *) xmlNodeListGetString (doc,
-          path_obj->nodesetval->nodeTab[i]->xmlChildrenNode, 1);
+    for (int i = 0; path_obj->nodesetval && (i < path_obj->nodesetval->nodeNr);
+         i++) {
+      zone_name = (char *)xmlNodeListGetString(
+          doc, path_obj->nodesetval->nodeTab[i]->xmlChildrenNode, 1);
       if (zone_name != NULL)
         break;
     }
-    xmlXPathFreeObject (path_obj);
+    xmlXPathFreeObject(path_obj);
   }
 
-  if (zone_name == NULL)
-  {
-    ERROR ("bind plugin: Could not determine zone name.");
+  if (zone_name == NULL) {
+    ERROR("bind plugin: Could not determine zone name.");
     return (-1);
   }
 
-  for (j = 0; j < view->zones_num; j++)
-  {
-    if (strcasecmp (zone_name, view->zones[j]) == 0)
+  for (j = 0; j < view->zones_num; j++) {
+    if (strcasecmp(zone_name, view->zones[j]) == 0)
       break;
   }
 
-  xmlFree (zone_name);
+  xmlFree(zone_name);
   zone_name = NULL;
 
   if (j >= view->zones_num)
     return (0);
 
   zone_name = view->zones[j];
 
-  DEBUG ("bind plugin: bind_xml_stats_handle_zone: Found zone `%s'.",
-      zone_name);
+  DEBUG("bind plugin: bind_xml_stats_handle_zone: Found zone `%s'.", zone_name);
 
   { /* Parse the <counters> tag {{{ */
     char plugin_instance[DATA_MAX_NAME_LEN];
-    translation_table_ptr_t table_ptr =
-    {
-      nsstats_translation_table,
-      nsstats_translation_table_length,
-      plugin_instance
-    };
-
-    ssnprintf (plugin_instance, sizeof (plugin_instance), "%s-zone-%s",
-        view->name, zone_name);
-
-    if (version == 3)
-    {
-      list_info_ptr_t list_info =
-      {
-        plugin_instance,
-        /* type = */ "dns_qtype"
-      };
-      bind_parse_generic_name_attr_value_list (/* xpath = */ "counters[@type='rcode']",
-        /* callback = */ bind_xml_table_callback,
-        /* user_data = */ &table_ptr,
-        doc, path_ctx, current_time, DS_TYPE_COUNTER);
-      bind_parse_generic_name_attr_value_list (/* xpath = */ "counters[@type='qtype']",
-        /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, path_ctx, current_time, DS_TYPE_COUNTER);
-    }
-    else
-    {
-      bind_parse_generic_value_list (/* xpath = */ "counters",
+    translation_table_ptr_t table_ptr = {nsstats_translation_table,
+                                         nsstats_translation_table_length,
+                                         plugin_instance};
+
+    ssnprintf(plugin_instance, sizeof(plugin_instance), "%s-zone-%s",
+              view->name, zone_name);
+
+    if (version == 3) {
+      list_info_ptr_t list_info = {plugin_instance,
+                                   /* type = */ "dns_qtype"};
+      bind_parse_generic_name_attr_value_list(
+          /* xpath = */ "counters[@type='rcode']",
           /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, path_ctx, current_time, DS_TYPE_COUNTER);
+          /* user_data = */ &table_ptr, doc, path_ctx, current_time,
+          DS_TYPE_COUNTER);
+      bind_parse_generic_name_attr_value_list(
+          /* xpath = */ "counters[@type='qtype']",
+          /* callback = */ bind_xml_list_callback,
+          /* user_data = */ &list_info, doc, path_ctx, current_time,
+          DS_TYPE_COUNTER);
+    } else {
+      bind_parse_generic_value_list(/* xpath = */ "counters",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, path_ctx,
+                                    current_time, DS_TYPE_COUNTER);
     }
   } /* }}} */
 
   return (0);
 } /* }}} int bind_xml_stats_handle_zone */
 
-static int bind_xml_stats_search_zones (int version, xmlDoc *doc, /* {{{ */
-    xmlXPathContext *path_ctx, xmlNode *node, cb_view_t *view,
-    time_t current_time)
-{
+static int bind_xml_stats_search_zones(int version, xmlDoc *doc, /* {{{ */
+                                       xmlXPathContext *path_ctx, xmlNode *node,
+                                       cb_view_t *view, time_t current_time) {
   xmlXPathObject *zone_nodes = NULL;
   xmlXPathContext *zone_path_context;
 
-  zone_path_context = xmlXPathNewContext (doc);
-  if (zone_path_context == NULL)
-  {
-    ERROR ("bind plugin: xmlXPathNewContext failed.");
+  zone_path_context = xmlXPathNewContext(doc);
+  if (zone_path_context == NULL) {
+    ERROR("bind plugin: xmlXPathNewContext failed.");
     return (-1);
   }
 
-  zone_nodes = xmlXPathEvalExpression (BAD_CAST "zones/zone", path_ctx);
-  if (zone_nodes == NULL)
-  {
-    ERROR ("bind plugin: Cannot find any <view> tags.");
-    xmlXPathFreeContext (zone_path_context);
+  zone_nodes = xmlXPathEvalExpression(BAD_CAST "zones/zone", path_ctx);
+  if (zone_nodes == NULL) {
+    ERROR("bind plugin: Cannot find any <view> tags.");
+    xmlXPathFreeContext(zone_path_context);
     return (-1);
   }
 
-  for (int i = 0; i < zone_nodes->nodesetval->nodeNr; i++)
-  {
+  for (int i = 0; i < zone_nodes->nodesetval->nodeNr; i++) {
     node = zone_nodes->nodesetval->nodeTab[i];
-    assert (node != NULL);
+    assert(node != NULL);
 
     zone_path_context->node = node;
 
-    bind_xml_stats_handle_zone (version, doc, zone_path_context, node, view,
-        current_time);
+    bind_xml_stats_handle_zone(version, doc, zone_path_context, node, view,
+                               current_time);
   }
 
-  xmlXPathFreeObject (zone_nodes);
-  xmlXPathFreeContext (zone_path_context);
+  xmlXPathFreeObject(zone_nodes);
+  xmlXPathFreeContext(zone_path_context);
   return (0);
 } /* }}} int bind_xml_stats_search_zones */
 
-static int bind_xml_stats_handle_view (int version, xmlDoc *doc, /* {{{ */
-    xmlXPathContext *path_ctx, xmlNode *node, time_t current_time)
-{
+static int bind_xml_stats_handle_view(int version, xmlDoc *doc, /* {{{ */
+                                      xmlXPathContext *path_ctx, xmlNode *node,
+                                      time_t current_time) {
   char *view_name = NULL;
   cb_view_t *view;
   size_t j;
 
-  if (version == 3)
-  {
-    view_name = (char*) xmlGetProp(node, BAD_CAST "name");
+  if (version == 3) {
+    view_name = (char *)xmlGetProp(node, BAD_CAST "name");
 
-    if (view_name == NULL)
-    {
-      ERROR ("bind plugin: Could not determine view name.");
+    if (view_name == NULL) {
+      ERROR("bind plugin: Could not determine view name.");
       return (-1);
     }
 
-    for (j = 0; j < views_num; j++)
-    {
-      if (strcasecmp (view_name, views[j].name) == 0)
+    for (j = 0; j < views_num; j++) {
+      if (strcasecmp(view_name, views[j].name) == 0)
         break;
     }
 
-    xmlFree (view_name);
+    xmlFree(view_name);
     view_name = NULL;
-  }
-  else
-  {
+  } else {
     xmlXPathObject *path_obj;
-    path_obj = xmlXPathEvalExpression (BAD_CAST "name", path_ctx);
-    if (path_obj == NULL)
-    {
-      ERROR ("bind plugin: xmlXPathEvalExpression failed.");
+    path_obj = xmlXPathEvalExpression(BAD_CAST "name", path_ctx);
+    if (path_obj == NULL) {
+      ERROR("bind plugin: xmlXPathEvalExpression failed.");
       return (-1);
     }
 
-    for (int i = 0; path_obj->nodesetval && (i < path_obj->nodesetval->nodeNr); i++)
-    {
-      view_name = (char *) xmlNodeListGetString (doc,
-          path_obj->nodesetval->nodeTab[i]->xmlChildrenNode, 1);
+    for (int i = 0; path_obj->nodesetval && (i < path_obj->nodesetval->nodeNr);
+         i++) {
+      view_name = (char *)xmlNodeListGetString(
+          doc, path_obj->nodesetval->nodeTab[i]->xmlChildrenNode, 1);
       if (view_name != NULL)
         break;
     }
 
-    if (view_name == NULL)
-    {
-      ERROR ("bind plugin: Could not determine view name.");
-      xmlXPathFreeObject (path_obj);
+    if (view_name == NULL) {
+      ERROR("bind plugin: Could not determine view name.");
+      xmlXPathFreeObject(path_obj);
       return (-1);
     }
 
-    for (j = 0; j < views_num; j++)
-    {
-      if (strcasecmp (view_name, views[j].name) == 0)
+    for (j = 0; j < views_num; j++) {
+      if (strcasecmp(view_name, views[j].name) == 0)
         break;
     }
 
-    xmlFree (view_name);
-    xmlXPathFreeObject (path_obj);
+    xmlFree(view_name);
+    xmlXPathFreeObject(path_obj);
 
     view_name = NULL;
     path_obj = NULL;
   }
 
-
   if (j >= views_num)
     return (0);
 
   view = views + j;
 
-  DEBUG ("bind plugin: bind_xml_stats_handle_view: Found view `%s'.",
-      view->name);
+  DEBUG("bind plugin: bind_xml_stats_handle_view: Found view `%s'.",
+        view->name);
 
   if (view->qtypes != 0) /* {{{ */
   {
     char plugin_instance[DATA_MAX_NAME_LEN];
-    list_info_ptr_t list_info =
-    {
-      plugin_instance,
-      /* type = */ "dns_qtype"
-    };
-
-    ssnprintf (plugin_instance, sizeof (plugin_instance), "%s-qtypes",
-        view->name);
-    if (version == 3)
-    {
-      bind_parse_generic_name_attr_value_list (/* xpath = */ "counters[@type='resqtype']",
-        /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, path_ctx, current_time, DS_TYPE_COUNTER);
-    }
-    else
-    {
-      bind_parse_generic_name_value (/* xpath = */ "rdtype",
-        /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, path_ctx, current_time, DS_TYPE_COUNTER);
+    list_info_ptr_t list_info = {plugin_instance,
+                                 /* type = */ "dns_qtype"};
+
+    ssnprintf(plugin_instance, sizeof(plugin_instance), "%s-qtypes",
+              view->name);
+    if (version == 3) {
+      bind_parse_generic_name_attr_value_list(
+          /* xpath = */ "counters[@type='resqtype']",
+          /* callback = */ bind_xml_list_callback,
+          /* user_data = */ &list_info, doc, path_ctx, current_time,
+          DS_TYPE_COUNTER);
+    } else {
+      bind_parse_generic_name_value(/* xpath = */ "rdtype",
+                                    /* callback = */ bind_xml_list_callback,
+                                    /* user_data = */ &list_info, doc, path_ctx,
+                                    current_time, DS_TYPE_COUNTER);
     }
   } /* }}} */
 
   if (view->resolver_stats != 0) /* {{{ */
   {
     char plugin_instance[DATA_MAX_NAME_LEN];
-    translation_table_ptr_t table_ptr =
-    {
-      resstats_translation_table,
-      resstats_translation_table_length,
-      plugin_instance
-    };
-
-    ssnprintf (plugin_instance, sizeof (plugin_instance),
-        "%s-resolver_stats", view->name);
-    if (version == 3)
-    {
-      bind_parse_generic_name_attr_value_list ("counters[@type='resstats']",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, path_ctx, current_time, DS_TYPE_COUNTER);
-    }
-    else
-    {
-      bind_parse_generic_name_value ("resstat",
+    translation_table_ptr_t table_ptr = {resstats_translation_table,
+                                         resstats_translation_table_length,
+                                         plugin_instance};
+
+    ssnprintf(plugin_instance, sizeof(plugin_instance), "%s-resolver_stats",
+              view->name);
+    if (version == 3) {
+      bind_parse_generic_name_attr_value_list(
+          "counters[@type='resstats']",
           /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, path_ctx, current_time, DS_TYPE_COUNTER);
+          /* user_data = */ &table_ptr, doc, path_ctx, current_time,
+          DS_TYPE_COUNTER);
+    } else {
+      bind_parse_generic_name_value("resstat",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, path_ctx,
+                                    current_time, DS_TYPE_COUNTER);
     }
   } /* }}} */
 
   /* Record types in the cache */
   if (view->cacherrsets != 0) /* {{{ */
   {
     char plugin_instance[DATA_MAX_NAME_LEN];
-    list_info_ptr_t list_info =
-    {
-      plugin_instance,
-      /* type = */ "dns_qtype_cached"
-    };
+    list_info_ptr_t list_info = {plugin_instance,
+                                 /* type = */ "dns_qtype_cached"};
 
-    ssnprintf (plugin_instance, sizeof (plugin_instance), "%s-cache_rr_sets",
-        view->name);
+    ssnprintf(plugin_instance, sizeof(plugin_instance), "%s-cache_rr_sets",
+              view->name);
 
-    bind_parse_generic_name_value (/* xpath = */ "cache/rrset",
-        /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, path_ctx, current_time, DS_TYPE_GAUGE);
+    bind_parse_generic_name_value(/* xpath = */ "cache/rrset",
+                                  /* callback = */ bind_xml_list_callback,
+                                  /* user_data = */ &list_info, doc, path_ctx,
+                                  current_time, DS_TYPE_GAUGE);
   } /* }}} */
 
   if (view->zones_num > 0)
-    bind_xml_stats_search_zones (version, doc, path_ctx, node, view,
-        current_time);
+    bind_xml_stats_search_zones(version, doc, path_ctx, node, view,
+                                current_time);
 
   return (0);
 } /* }}} int bind_xml_stats_handle_view */
 
-static int bind_xml_stats_search_views (int version, xmlDoc *doc, /* {{{ */
-    xmlXPathContext *xpathCtx, xmlNode *statsnode, time_t current_time)
-{
+static int bind_xml_stats_search_views(int version, xmlDoc *doc, /* {{{ */
+                                       xmlXPathContext *xpathCtx,
+                                       xmlNode *statsnode,
+                                       time_t current_time) {
   xmlXPathObject *view_nodes = NULL;
   xmlXPathContext *view_path_context;
 
-  view_path_context = xmlXPathNewContext (doc);
-  if (view_path_context == NULL)
-  {
-    ERROR ("bind plugin: xmlXPathNewContext failed.");
+  view_path_context = xmlXPathNewContext(doc);
+  if (view_path_context == NULL) {
+    ERROR("bind plugin: xmlXPathNewContext failed.");
     return (-1);
   }
 
-  view_nodes = xmlXPathEvalExpression (BAD_CAST "views/view", xpathCtx);
-  if (view_nodes == NULL)
-  {
-    ERROR ("bind plugin: Cannot find any <view> tags.");
-    xmlXPathFreeContext (view_path_context);
+  view_nodes = xmlXPathEvalExpression(BAD_CAST "views/view", xpathCtx);
+  if (view_nodes == NULL) {
+    ERROR("bind plugin: Cannot find any <view> tags.");
+    xmlXPathFreeContext(view_path_context);
     return (-1);
   }
 
-  for (int i = 0; i < view_nodes->nodesetval->nodeNr; i++)
-  {
+  for (int i = 0; i < view_nodes->nodesetval->nodeNr; i++) {
     xmlNode *node;
 
     node = view_nodes->nodesetval->nodeTab[i];
-    assert (node != NULL);
+    assert(node != NULL);
 
     view_path_context->node = node;
 
-    bind_xml_stats_handle_view (version, doc, view_path_context, node,
-        current_time);
+    bind_xml_stats_handle_view(version, doc, view_path_context, node,
+                               current_time);
   }
 
-  xmlXPathFreeObject (view_nodes);
-  xmlXPathFreeContext (view_path_context);
+  xmlXPathFreeObject(view_nodes);
+  xmlXPathFreeContext(view_path_context);
   return (0);
 } /* }}} int bind_xml_stats_search_views */
 
-static void bind_xml_stats_v3 (xmlDoc *doc, /* {{{ */
-    xmlXPathContext *xpathCtx, xmlNode *statsnode, time_t current_time)
-{
+static void bind_xml_stats_v3(xmlDoc *doc, /* {{{ */
+                              xmlXPathContext *xpathCtx, xmlNode *statsnode,
+                              time_t current_time) {
   /* XPath:     server/counters[@type='opcode']
    * Variables: QUERY, IQUERY, NOTIFY, UPDATE, ...
    * Layout v3:
@@ -1038,17 +943,14 @@ static void bind_xml_stats_v3 (xmlDoc *doc, /* {{{ */
    *     :
    *   </counters>
    */
-  if (global_opcodes != 0)
-  {
-    list_info_ptr_t list_info =
-    {
-      /* plugin instance = */ "global-opcodes",
-      /* type = */ "dns_opcode"
-    };
-    bind_parse_generic_name_attr_value_list (/* xpath = */ "server/counters[@type='opcode']",
-      /* callback = */ bind_xml_list_callback,
-      /* user_data = */ &list_info,
-      doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+  if (global_opcodes != 0) {
+    list_info_ptr_t list_info = {/* plugin instance = */ "global-opcodes",
+                                 /* type = */ "dns_opcode"};
+    bind_parse_generic_name_attr_value_list(
+        /* xpath = */ "server/counters[@type='opcode']",
+        /* callback = */ bind_xml_list_callback,
+        /* user_data = */ &list_info, doc, xpathCtx, current_time,
+        DS_TYPE_COUNTER);
   }
 
   /* XPath:     server/counters[@type='qtype']
@@ -1061,18 +963,15 @@ static void bind_xml_stats_v3 (xmlDoc *doc, /* {{{ */
    *     :
    *   </counters>
    */
-  if (global_qtypes != 0)
-  {
-    list_info_ptr_t list_info =
-    {
-      /* plugin instance = */ "global-qtypes",
-      /* type = */ "dns_qtype"
-    };
+  if (global_qtypes != 0) {
+    list_info_ptr_t list_info = {/* plugin instance = */ "global-qtypes",
+                                 /* type = */ "dns_qtype"};
 
-    bind_parse_generic_name_attr_value_list (/* xpath = */ "server/counters[@type='qtype']",
+    bind_parse_generic_name_attr_value_list(
+        /* xpath = */ "server/counters[@type='qtype']",
         /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+        /* user_data = */ &list_info, doc, xpathCtx, current_time,
+        DS_TYPE_COUNTER);
   }
 
   /* XPath:     server/counters[@type='nsstat']
@@ -1091,22 +990,20 @@ static void bind_xml_stats_v3 (xmlDoc *doc, /* {{{ */
    *     :
    *   </counter>
    */
-  if (global_server_stats)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      nsstats_translation_table,
-      nsstats_translation_table_length,
-      /* plugin_instance = */ "global-server_stats"
-    };
+  if (global_server_stats) {
+    translation_table_ptr_t table_ptr = {
+        nsstats_translation_table, nsstats_translation_table_length,
+        /* plugin_instance = */ "global-server_stats"};
 
-    bind_parse_generic_name_attr_value_list ("server/counters[@type='nsstat']",
+    bind_parse_generic_name_attr_value_list(
+        "server/counters[@type='nsstat']",
         /* callback = */ bind_xml_table_callback,
-        /* user_data = */ &table_ptr,
-        doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+        /* user_data = */ &table_ptr, doc, xpathCtx, current_time,
+        DS_TYPE_COUNTER);
   }
 
-  /* XPath:     server/zonestats, server/zonestat, server/counters[@type='zonestat']
+  /* XPath:     server/zonestats, server/zonestat,
+   * server/counters[@type='zonestat']
    * Variables: NotifyOutv4, NotifyOutv6, NotifyInv4, NotifyInv6, NotifyRej,
    *            SOAOutv4, SOAOutv6, AXFRReqv4, AXFRReqv6, IXFRReqv4, IXFRReqv6,
    *            XfrSuccess, XfrFail
@@ -1117,19 +1014,16 @@ static void bind_xml_stats_v3 (xmlDoc *doc, /* {{{ */
    *     :
    *   </counter>
    */
-  if (global_zone_maint_stats)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      zonestats_translation_table,
-      zonestats_translation_table_length,
-      /* plugin_instance = */ "global-zone_maint_stats"
-    };
+  if (global_zone_maint_stats) {
+    translation_table_ptr_t table_ptr = {
+        zonestats_translation_table, zonestats_translation_table_length,
+        /* plugin_instance = */ "global-zone_maint_stats"};
 
-    bind_parse_generic_name_attr_value_list ("server/counters[@type='zonestat']",
+    bind_parse_generic_name_attr_value_list(
+        "server/counters[@type='zonestat']",
         /* callback = */ bind_xml_table_callback,
-        /* user_data = */ &table_ptr,
-        doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+        /* user_data = */ &table_ptr, doc, xpathCtx, current_time,
+        DS_TYPE_COUNTER);
   }
 
   /* XPath:     server/resstats, server/counters[@type='resstat']
@@ -1144,25 +1038,22 @@ static void bind_xml_stats_v3 (xmlDoc *doc, /* {{{ */
    *     :
    *   </counter>
    */
-  if (global_resolver_stats != 0)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      resstats_translation_table,
-      resstats_translation_table_length,
-      /* plugin_instance = */ "global-resolver_stats"
-    };
+  if (global_resolver_stats != 0) {
+    translation_table_ptr_t table_ptr = {
+        resstats_translation_table, resstats_translation_table_length,
+        /* plugin_instance = */ "global-resolver_stats"};
 
-    bind_parse_generic_name_attr_value_list ("server/counters[@type='resstat']",
+    bind_parse_generic_name_attr_value_list(
+        "server/counters[@type='resstat']",
         /* callback = */ bind_xml_table_callback,
-        /* user_data = */ &table_ptr,
-        doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+        /* user_data = */ &table_ptr, doc, xpathCtx, current_time,
+        DS_TYPE_COUNTER);
   }
 } /* }}} bind_xml_stats_v3 */
 
-static void bind_xml_stats_v1_v2 (int version, xmlDoc *doc, /* {{{ */
-    xmlXPathContext *xpathCtx, xmlNode *statsnode, time_t current_time)
-{
+static void bind_xml_stats_v1_v2(int version, xmlDoc *doc, /* {{{ */
+                                 xmlXPathContext *xpathCtx, xmlNode *statsnode,
+                                 time_t current_time) {
   /* XPath:     server/requests/opcode, server/counters[@type='opcode']
    * Variables: QUERY, IQUERY, NOTIFY, UPDATE, ...
    * Layout V1 and V2:
@@ -1172,18 +1063,14 @@ static void bind_xml_stats_v1_v2 (int version, xmlDoc *doc, /* {{{ */
    *   </opcode>
    *   :
    */
-  if (global_opcodes != 0)
-  {
-    list_info_ptr_t list_info =
-    {
-      /* plugin instance = */ "global-opcodes",
-      /* type = */ "dns_opcode"
-    };
+  if (global_opcodes != 0) {
+    list_info_ptr_t list_info = {/* plugin instance = */ "global-opcodes",
+                                 /* type = */ "dns_opcode"};
 
-    bind_parse_generic_name_value (/* xpath = */ "server/requests/opcode",
-        /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+    bind_parse_generic_name_value(/* xpath = */ "server/requests/opcode",
+                                  /* callback = */ bind_xml_list_callback,
+                                  /* user_data = */ &list_info, doc, xpathCtx,
+                                  current_time, DS_TYPE_COUNTER);
   }
 
   /* XPath:     server/queries-in/rdtype, server/counters[@type='qtype']
@@ -1197,18 +1084,14 @@ static void bind_xml_stats_v1_v2 (int version, xmlDoc *doc, /* {{{ */
    *   </rdtype>
    *   :
    */
-  if (global_qtypes != 0)
-  {
-    list_info_ptr_t list_info =
-    {
-      /* plugin instance = */ "global-qtypes",
-      /* type = */ "dns_qtype"
-    };
+  if (global_qtypes != 0) {
+    list_info_ptr_t list_info = {/* plugin instance = */ "global-qtypes",
+                                 /* type = */ "dns_qtype"};
 
-    bind_parse_generic_name_value (/* xpath = */ "server/queries-in/rdtype",
-        /* callback = */ bind_xml_list_callback,
-        /* user_data = */ &list_info,
-        doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+    bind_parse_generic_name_value(/* xpath = */ "server/queries-in/rdtype",
+                                  /* callback = */ bind_xml_list_callback,
+                                  /* user_data = */ &list_info, doc, xpathCtx,
+                                  current_time, DS_TYPE_COUNTER);
   }
 
   /* XPath:     server/nsstats, server/nsstat, server/counters[@type='nsstat']
@@ -1237,32 +1120,26 @@ static void bind_xml_stats_v1_v2 (int version, xmlDoc *doc, /* {{{ */
    *   </nsstat>
    *   :
    */
-  if (global_server_stats)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      nsstats_translation_table,
-      nsstats_translation_table_length,
-      /* plugin_instance = */ "global-server_stats"
-    };
-
-    if (version == 1)
-    {
-      bind_parse_generic_value_list ("server/nsstats",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_COUNTER);
-    }
-    else
-    {
-      bind_parse_generic_name_value ("server/nsstat",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+  if (global_server_stats) {
+    translation_table_ptr_t table_ptr = {
+        nsstats_translation_table, nsstats_translation_table_length,
+        /* plugin_instance = */ "global-server_stats"};
+
+    if (version == 1) {
+      bind_parse_generic_value_list("server/nsstats",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, xpathCtx,
+                                    current_time, DS_TYPE_COUNTER);
+    } else {
+      bind_parse_generic_name_value("server/nsstat",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, xpathCtx,
+                                    current_time, DS_TYPE_COUNTER);
     }
   }
 
-  /* XPath:     server/zonestats, server/zonestat, server/counters[@type='zonestat']
+  /* XPath:     server/zonestats, server/zonestat,
+   * server/counters[@type='zonestat']
    * Variables: NotifyOutv4, NotifyOutv6, NotifyInv4, NotifyInv6, NotifyRej,
    *            SOAOutv4, SOAOutv6, AXFRReqv4, AXFRReqv6, IXFRReqv4, IXFRReqv6,
    *            XfrSuccess, XfrFail
@@ -1283,28 +1160,21 @@ static void bind_xml_stats_v1_v2 (int version, xmlDoc *doc, /* {{{ */
    *   </zonestat>
    *   :
    */
-  if (global_zone_maint_stats)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      zonestats_translation_table,
-      zonestats_translation_table_length,
-      /* plugin_instance = */ "global-zone_maint_stats"
-    };
-
-    if (version == 1)
-    {
-      bind_parse_generic_value_list ("server/zonestats",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_COUNTER);
-    }
-    else
-    {
-      bind_parse_generic_name_value ("server/zonestat",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+  if (global_zone_maint_stats) {
+    translation_table_ptr_t table_ptr = {
+        zonestats_translation_table, zonestats_translation_table_length,
+        /* plugin_instance = */ "global-zone_maint_stats"};
+
+    if (version == 1) {
+      bind_parse_generic_value_list("server/zonestats",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, xpathCtx,
+                                    current_time, DS_TYPE_COUNTER);
+    } else {
+      bind_parse_generic_name_value("server/zonestat",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, xpathCtx,
+                                    current_time, DS_TYPE_COUNTER);
     }
   }
 
@@ -1330,57 +1200,45 @@ static void bind_xml_stats_v1_v2 (int version, xmlDoc *doc, /* {{{ */
    *   </resstat>
    *   :
    */
-  if (global_resolver_stats != 0)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      resstats_translation_table,
-      resstats_translation_table_length,
-      /* plugin_instance = */ "global-resolver_stats"
-    };
-
-    if (version == 1)
-    {
-      bind_parse_generic_value_list ("server/resstats",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_COUNTER);
-    }
-    else
-    {
-      bind_parse_generic_name_value ("server/resstat",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_COUNTER);
+  if (global_resolver_stats != 0) {
+    translation_table_ptr_t table_ptr = {
+        resstats_translation_table, resstats_translation_table_length,
+        /* plugin_instance = */ "global-resolver_stats"};
+
+    if (version == 1) {
+      bind_parse_generic_value_list("server/resstats",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, xpathCtx,
+                                    current_time, DS_TYPE_COUNTER);
+    } else {
+      bind_parse_generic_name_value("server/resstat",
+                                    /* callback = */ bind_xml_table_callback,
+                                    /* user_data = */ &table_ptr, doc, xpathCtx,
+                                    current_time, DS_TYPE_COUNTER);
     }
   }
 } /* }}} bind_xml_stats_v1_v2 */
 
-static int bind_xml_stats (int version, xmlDoc *doc, /* {{{ */
-    xmlXPathContext *xpathCtx, xmlNode *statsnode)
-{
+static int bind_xml_stats(int version, xmlDoc *doc, /* {{{ */
+                          xmlXPathContext *xpathCtx, xmlNode *statsnode) {
   time_t current_time = 0;
   int status;
 
   xpathCtx->node = statsnode;
 
   /* TODO: Check `server/boot-time' to recognize server restarts. */
 
-  status = bind_xml_read_timestamp ("server/current-time",
-      doc, xpathCtx, &current_time);
-  if (status != 0)
-  {
-    ERROR ("bind plugin: Reading `server/current-time' failed.");
+  status = bind_xml_read_timestamp("server/current-time", doc, xpathCtx,
+                                   &current_time);
+  if (status != 0) {
+    ERROR("bind plugin: Reading `server/current-time' failed.");
     return (-1);
   }
-  DEBUG ("bind plugin: Current server time is %i.", (int) current_time);
+  DEBUG("bind plugin: Current server time is %i.", (int)current_time);
 
-  if (version == 3)
-  {
+  if (version == 3) {
     bind_xml_stats_v3(doc, xpathCtx, statsnode, current_time);
-  }
-  else
-  {
+  } else {
     bind_xml_stats_v1_v2(version, doc, xpathCtx, statsnode, current_time);
   }
 
@@ -1395,100 +1253,92 @@ static int bind_xml_stats (int version, xmlDoc *doc, /* {{{ */
    *     <Lost>0</Lost>
    *   </summary>
    */
-  if (global_memory_stats != 0)
-  {
-    translation_table_ptr_t table_ptr =
-    {
-      memsummary_translation_table,
-      memsummary_translation_table_length,
-      /* plugin_instance = */ "global-memory_stats"
-    };
+  if (global_memory_stats != 0) {
+    translation_table_ptr_t table_ptr = {
+        memsummary_translation_table, memsummary_translation_table_length,
+        /* plugin_instance = */ "global-memory_stats"};
 
-    bind_parse_generic_value_list ("memory/summary",
-          /* callback = */ bind_xml_table_callback,
-          /* user_data = */ &table_ptr,
-          doc, xpathCtx, current_time, DS_TYPE_GAUGE);
+    bind_parse_generic_value_list("memory/summary",
+                                  /* callback = */ bind_xml_table_callback,
+                                  /* user_data = */ &table_ptr, doc, xpathCtx,
+                                  current_time, DS_TYPE_GAUGE);
   }
 
   if (views_num > 0)
-    bind_xml_stats_search_views (version, doc, xpathCtx, statsnode,
-        current_time);
+    bind_xml_stats_search_views(version, doc, xpathCtx, statsnode,
+                                current_time);
 
   return 0;
 } /* }}} int bind_xml_stats */
 
-static int bind_xml (const char *data) /* {{{ */
+static int bind_xml(const char *data) /* {{{ */
 {
   xmlDoc *doc = NULL;
   xmlXPathContext *xpathCtx = NULL;
   xmlXPathObject *xpathObj = NULL;
   int ret = -1;
 
-  doc = xmlParseMemory (data, strlen (data));
-  if (doc == NULL)
-  {
-    ERROR ("bind plugin: xmlParseMemory failed.");
+  doc = xmlParseMemory(data, strlen(data));
+  if (doc == NULL) {
+    ERROR("bind plugin: xmlParseMemory failed.");
     return (-1);
   }
 
-  xpathCtx = xmlXPathNewContext (doc);
-  if (xpathCtx == NULL)
-  {
-    ERROR ("bind plugin: xmlXPathNewContext failed.");
-    xmlFreeDoc (doc);
+  xpathCtx = xmlXPathNewContext(doc);
+  if (xpathCtx == NULL) {
+    ERROR("bind plugin: xmlXPathNewContext failed.");
+    xmlFreeDoc(doc);
     return (-1);
   }
 
   //
   // version 3.* of statistics XML (since BIND9.9)
   //
 
-  xpathObj = xmlXPathEvalExpression (BAD_CAST "/statistics", xpathCtx);
-  if (xpathObj == NULL || xpathObj->nodesetval == NULL || xpathObj->nodesetval->nodeNr == 0)
-  {
-    DEBUG ("bind plugin: Statistics appears not to be v3");
+  xpathObj = xmlXPathEvalExpression(BAD_CAST "/statistics", xpathCtx);
+  if (xpathObj == NULL || xpathObj->nodesetval == NULL ||
+      xpathObj->nodesetval->nodeNr == 0) {
+    DEBUG("bind plugin: Statistics appears not to be v3");
     // we will fallback to v1 or v2 detection
-    if (xpathObj != NULL) { xmlXPathFreeObject (xpathObj); }
-  }
-  else
-  {
-    for (int i = 0; i < xpathObj->nodesetval->nodeNr; i++)
-    {
+    if (xpathObj != NULL) {
+      xmlXPathFreeObject(xpathObj);
+    }
+  } else {
+    for (int i = 0; i < xpathObj->nodesetval->nodeNr; i++) {
       xmlNode *node;
       char *attr_version;
 
       node = xpathObj->nodesetval->nodeTab[i];
-      assert (node != NULL);
+      assert(node != NULL);
 
-      attr_version = (char *) xmlGetProp (node, BAD_CAST "version");
-      if (attr_version == NULL)
-      {
-        NOTICE ("bind plugin: Found <statistics> tag doesn't have a "
-            "`version' attribute.");
+      attr_version = (char *)xmlGetProp(node, BAD_CAST "version");
+      if (attr_version == NULL) {
+        NOTICE("bind plugin: Found <statistics> tag doesn't have a "
+               "`version' attribute.");
         continue;
       }
-      DEBUG ("bind plugin: Found: <statistics version=\"%s\">", attr_version);
+      DEBUG("bind plugin: Found: <statistics version=\"%s\">", attr_version);
 
-      if (strncmp ("3.", attr_version, strlen ("3.")) != 0)
-      {
+      if (strncmp("3.", attr_version, strlen("3.")) != 0) {
         /* TODO: Use the complaint mechanism here. */
-        NOTICE ("bind plugin: Found <statistics> tag with version `%s'. "
-            "Unfortunately I have no clue how to parse that. "
-            "Please open a bug report for this.", attr_version);
-        xmlFree (attr_version);
+        NOTICE("bind plugin: Found <statistics> tag with version `%s'. "
+               "Unfortunately I have no clue how to parse that. "
+               "Please open a bug report for this.",
+               attr_version);
+        xmlFree(attr_version);
         continue;
       }
-      ret = bind_xml_stats (3, doc, xpathCtx, node);
+      ret = bind_xml_stats(3, doc, xpathCtx, node);
 
-      xmlFree (attr_version);
+      xmlFree(attr_version);
       /* One <statistics> node ought to be enough. */
       break;
     }
 
     // we are finished, early-return
-    xmlXPathFreeObject (xpathObj);
-    xmlXPathFreeContext (xpathCtx);
-    xmlFreeDoc (doc);
+    xmlXPathFreeObject(xpathObj);
+    xmlXPathFreeContext(xpathCtx);
+    xmlFreeDoc(doc);
 
     return (ret);
   }
@@ -1497,81 +1347,74 @@ static int bind_xml (const char *data) /* {{{ */
   // versions 1.* or 2.* of statistics XML
   //
 
-  xpathObj = xmlXPathEvalExpression (BAD_CAST "/isc/bind/statistics", xpathCtx);
-  if (xpathObj == NULL)
-  {
-    ERROR ("bind plugin: Cannot find the <statistics> tag.");
-    xmlXPathFreeContext (xpathCtx);
-    xmlFreeDoc (doc);
+  xpathObj = xmlXPathEvalExpression(BAD_CAST "/isc/bind/statistics", xpathCtx);
+  if (xpathObj == NULL) {
+    ERROR("bind plugin: Cannot find the <statistics> tag.");
+    xmlXPathFreeContext(xpathCtx);
+    xmlFreeDoc(doc);
     return (-1);
-  }
-  else if (xpathObj->nodesetval == NULL)
-  {
-    ERROR ("bind plugin: xmlXPathEvalExpression failed.");
-    xmlXPathFreeObject (xpathObj);
-    xmlXPathFreeContext (xpathCtx);
-    xmlFreeDoc (doc);
+  } else if (xpathObj->nodesetval == NULL) {
+    ERROR("bind plugin: xmlXPathEvalExpression failed.");
+    xmlXPathFreeObject(xpathObj);
+    xmlXPathFreeContext(xpathCtx);
+    xmlFreeDoc(doc);
     return (-1);
   }
 
-  for (int i = 0; i < xpathObj->nodesetval->nodeNr; i++)
-  {
+  for (int i = 0; i < xpathObj->nodesetval->nodeNr; i++) {
     xmlNode *node;
     char *attr_version;
     int parsed_version = 0;
 
     node = xpathObj->nodesetval->nodeTab[i];
-    assert (node != NULL);
+    assert(node != NULL);
 
-    attr_version = (char *) xmlGetProp (node, BAD_CAST "version");
-    if (attr_version == NULL)
-    {
-      NOTICE ("bind plugin: Found <statistics> tag doesn't have a "
-          "`version' attribute.");
+    attr_version = (char *)xmlGetProp(node, BAD_CAST "version");
+    if (attr_version == NULL) {
+      NOTICE("bind plugin: Found <statistics> tag doesn't have a "
+             "`version' attribute.");
       continue;
     }
-    DEBUG ("bind plugin: Found: <statistics version=\"%s\">", attr_version);
+    DEBUG("bind plugin: Found: <statistics version=\"%s\">", attr_version);
 
     /* At the time this plugin was written, version "1.0" was used by
      * BIND 9.5.0, version "2.0" was used by BIND 9.5.1 and 9.6.0. We assume
      * that "1.*" and "2.*" don't introduce structural changes, so we just
      * check for the first two characters here. */
-    if (strncmp ("1.", attr_version, strlen ("1.")) == 0)
+    if (strncmp("1.", attr_version, strlen("1.")) == 0)
       parsed_version = 1;
-    else if (strncmp ("2.", attr_version, strlen ("2.")) == 0)
+    else if (strncmp("2.", attr_version, strlen("2.")) == 0)
       parsed_version = 2;
-    else
-    {
+    else {
       /* TODO: Use the complaint mechanism here. */
-      NOTICE ("bind plugin: Found <statistics> tag with version `%s'. "
-          "Unfortunately I have no clue how to parse that. "
-          "Please open a bug report for this.", attr_version);
-      xmlFree (attr_version);
+      NOTICE("bind plugin: Found <statistics> tag with version `%s'. "
+             "Unfortunately I have no clue how to parse that. "
+             "Please open a bug report for this.",
+             attr_version);
+      xmlFree(attr_version);
       continue;
     }
 
-    ret = bind_xml_stats (parsed_version,
-        doc, xpathCtx, node);
+    ret = bind_xml_stats(parsed_version, doc, xpathCtx, node);
 
-    xmlFree (attr_version);
+    xmlFree(attr_version);
     /* One <statistics> node ought to be enough. */
     break;
   }
 
-  xmlXPathFreeObject (xpathObj);
-  xmlXPathFreeContext (xpathCtx);
-  xmlFreeDoc (doc);
+  xmlXPathFreeObject(xpathObj);
+  xmlXPathFreeContext(xpathCtx);
+  xmlFreeDoc(doc);
 
   return (ret);
 } /* }}} int bind_xml */
 
-static int bind_config_set_bool (const char *name, int *var, /* {{{ */
-    oconfig_item_t *ci)
-{
-  if ((ci->values_num != 1) || ( ci->values[0].type != OCONFIG_TYPE_BOOLEAN))
-  {
-    WARNING ("bind plugin: The `%s' option needs "
-        "exactly one boolean argument.", name);
+static int bind_config_set_bool(const char *name, int *var, /* {{{ */
+                                oconfig_item_t *ci) {
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_BOOLEAN)) {
+    WARNING("bind plugin: The `%s' option needs "
+            "exactly one boolean argument.",
+            name);
     return (-1);
   }
 
@@ -1582,209 +1425,193 @@ static int bind_config_set_bool (const char *name, int *var, /* {{{ */
   return 0;
 } /* }}} int bind_config_set_bool */
 
-static int bind_config_add_view_zone (cb_view_t *view, /* {{{ */
-    oconfig_item_t *ci)
-{
+static int bind_config_add_view_zone(cb_view_t *view, /* {{{ */
+                                     oconfig_item_t *ci) {
   char **tmp;
 
-  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
-  {
-    WARNING ("bind plugin: The `Zone' option needs "
-        "exactly one string argument.");
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
+    WARNING("bind plugin: The `Zone' option needs "
+            "exactly one string argument.");
     return (-1);
   }
 
-  tmp = realloc (view->zones,
-      sizeof (char *) * (view->zones_num + 1));
-  if (tmp == NULL)
-  {
-    ERROR ("bind plugin: realloc failed.");
+  tmp = realloc(view->zones, sizeof(char *) * (view->zones_num + 1));
+  if (tmp == NULL) {
+    ERROR("bind plugin: realloc failed.");
     return (-1);
   }
   view->zones = tmp;
 
-  view->zones[view->zones_num] = strdup (ci->values[0].value.string);
-  if (view->zones[view->zones_num] == NULL)
-  {
-    ERROR ("bind plugin: strdup failed.");
+  view->zones[view->zones_num] = strdup(ci->values[0].value.string);
+  if (view->zones[view->zones_num] == NULL) {
+    ERROR("bind plugin: strdup failed.");
     return (-1);
   }
   view->zones_num++;
 
   return (0);
 } /* }}} int bind_config_add_view_zone */
 
-static int bind_config_add_view (oconfig_item_t *ci) /* {{{ */
+static int bind_config_add_view(oconfig_item_t *ci) /* {{{ */
 {
   cb_view_t *tmp;
 
-  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
-  {
-    WARNING ("bind plugin: `View' blocks need exactly one string argument.");
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
+    WARNING("bind plugin: `View' blocks need exactly one string argument.");
     return (-1);
   }
 
-  tmp = realloc (views, sizeof (*views) * (views_num + 1));
-  if (tmp == NULL)
-  {
-    ERROR ("bind plugin: realloc failed.");
+  tmp = realloc(views, sizeof(*views) * (views_num + 1));
+  if (tmp == NULL) {
+    ERROR("bind plugin: realloc failed.");
     return (-1);
   }
   views = tmp;
   tmp = views + views_num;
 
-  memset (tmp, 0, sizeof (*tmp));
+  memset(tmp, 0, sizeof(*tmp));
   tmp->qtypes = 1;
   tmp->resolver_stats = 1;
   tmp->cacherrsets = 1;
   tmp->zones = NULL;
   tmp->zones_num = 0;
 
-  tmp->name = strdup (ci->values[0].value.string);
-  if (tmp->name == NULL)
-  {
-    ERROR ("bind plugin: strdup failed.");
-    sfree (views);
+  tmp->name = strdup(ci->values[0].value.string);
+  if (tmp->name == NULL) {
+    ERROR("bind plugin: strdup failed.");
+    sfree(views);
     return (-1);
   }
 
-  for (int i = 0; i < ci->children_num; i++)
-  {
+  for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
-    if (strcasecmp ("QTypes", child->key) == 0)
-      bind_config_set_bool ("QTypes", &tmp->qtypes, child);
-    else if (strcasecmp ("ResolverStats", child->key) == 0)
-      bind_config_set_bool ("ResolverStats", &tmp->resolver_stats, child);
-    else if (strcasecmp ("CacheRRSets", child->key) == 0)
-      bind_config_set_bool ("CacheRRSets", &tmp->cacherrsets, child);
-    else if (strcasecmp ("Zone", child->key) == 0)
-      bind_config_add_view_zone (tmp, child);
-    else
-    {
-      WARNING ("bind plugin: Unknown configuration option "
-          "`%s' in view `%s' will be ignored.", child->key, tmp->name);
+    if (strcasecmp("QTypes", child->key) == 0)
+      bind_config_set_bool("QTypes", &tmp->qtypes, child);
+    else if (strcasecmp("ResolverStats", child->key) == 0)
+      bind_config_set_bool("ResolverStats", &tmp->resolver_stats, child);
+    else if (strcasecmp("CacheRRSets", child->key) == 0)
+      bind_config_set_bool("CacheRRSets", &tmp->cacherrsets, child);
+    else if (strcasecmp("Zone", child->key) == 0)
+      bind_config_add_view_zone(tmp, child);
+    else {
+      WARNING("bind plugin: Unknown configuration option "
+              "`%s' in view `%s' will be ignored.",
+              child->key, tmp->name);
     }
   } /* for (i = 0; i < ci->children_num; i++) */
 
   views_num++;
   return (0);
 } /* }}} int bind_config_add_view */
 
-static int bind_config (oconfig_item_t *ci) /* {{{ */
+static int bind_config(oconfig_item_t *ci) /* {{{ */
 {
-  for (int i = 0; i < ci->children_num; i++)
-  {
+  for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
-    if (strcasecmp ("Url", child->key) == 0) {
-      if ((child->values_num != 1) || (child->values[0].type != OCONFIG_TYPE_STRING))
-      {
-        WARNING ("bind plugin: The `Url' option needs "
-                 "exactly one string argument.");
+    if (strcasecmp("Url", child->key) == 0) {
+      if ((child->values_num != 1) ||
+          (child->values[0].type != OCONFIG_TYPE_STRING)) {
+        WARNING("bind plugin: The `Url' option needs "
+                "exactly one string argument.");
         return (-1);
       }
 
-      sfree (url);
-      url = strdup (child->values[0].value.string);
-    } else if (strcasecmp ("OpCodes", child->key) == 0)
-      bind_config_set_bool ("OpCodes", &global_opcodes, child);
-    else if (strcasecmp ("QTypes", child->key) == 0)
-      bind_config_set_bool ("QTypes", &global_qtypes, child);
-    else if (strcasecmp ("ServerStats", child->key) == 0)
-      bind_config_set_bool ("ServerStats", &global_server_stats, child);
-    else if (strcasecmp ("ZoneMaintStats", child->key) == 0)
-      bind_config_set_bool ("ZoneMaintStats", &global_zone_maint_stats, child);
-    else if (strcasecmp ("ResolverStats", child->key) == 0)
-      bind_config_set_bool ("ResolverStats", &global_resolver_stats, child);
-    else if (strcasecmp ("MemoryStats", child->key) == 0)
-      bind_config_set_bool ("MemoryStats", &global_memory_stats, child);
-    else if (strcasecmp ("View", child->key) == 0)
-      bind_config_add_view (child);
-    else if (strcasecmp ("ParseTime", child->key) == 0)
-      cf_util_get_boolean (child, &config_parse_time);
-    else if (strcasecmp ("Timeout", child->key) == 0)
-      cf_util_get_int (child, &timeout);
-    else
-    {
-      WARNING ("bind plugin: Unknown configuration option "
-          "`%s' will be ignored.", child->key);
+      sfree(url);
+      url = strdup(child->values[0].value.string);
+    } else if (strcasecmp("OpCodes", child->key) == 0)
+      bind_config_set_bool("OpCodes", &global_opcodes, child);
+    else if (strcasecmp("QTypes", child->key) == 0)
+      bind_config_set_bool("QTypes", &global_qtypes, child);
+    else if (strcasecmp("ServerStats", child->key) == 0)
+      bind_config_set_bool("ServerStats", &global_server_stats, child);
+    else if (strcasecmp("ZoneMaintStats", child->key) == 0)
+      bind_config_set_bool("ZoneMaintStats", &global_zone_maint_stats, child);
+    else if (strcasecmp("ResolverStats", child->key) == 0)
+      bind_config_set_bool("ResolverStats", &global_resolver_stats, child);
+    else if (strcasecmp("MemoryStats", child->key) == 0)
+      bind_config_set_bool("MemoryStats", &global_memory_stats, child);
+    else if (strcasecmp("View", child->key) == 0)
+      bind_config_add_view(child);
+    else if (strcasecmp("ParseTime", child->key) == 0)
+      cf_util_get_boolean(child, &config_parse_time);
+    else if (strcasecmp("Timeout", child->key) == 0)
+      cf_util_get_int(child, &timeout);
+    else {
+      WARNING("bind plugin: Unknown configuration option "
+              "`%s' will be ignored.",
+              child->key);
     }
   }
 
   return (0);
 } /* }}} int bind_config */
 
-static int bind_init (void) /* {{{ */
+static int bind_init(void) /* {{{ */
 {
   if (curl != NULL)
     return (0);
 
-  curl = curl_easy_init ();
-  if (curl == NULL)
-  {
-    ERROR ("bind plugin: bind_init: curl_easy_init failed.");
+  curl = curl_easy_init();
+  if (curl == NULL) {
+    ERROR("bind plugin: bind_init: curl_easy_init failed.");
     return (-1);
   }
 
-  curl_easy_setopt (curl, CURLOPT_NOSIGNAL, 1L);
-  curl_easy_setopt (curl, CURLOPT_WRITEFUNCTION, bind_curl_callback);
-  curl_easy_setopt (curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
-  curl_easy_setopt (curl, CURLOPT_ERRORBUFFER, bind_curl_error);
-  curl_easy_setopt (curl, CURLOPT_URL, (url != NULL) ? url : BIND_DEFAULT_URL);
-  curl_easy_setopt (curl, CURLOPT_FOLLOWLOCATION, 1L);
-  curl_easy_setopt (curl, CURLOPT_MAXREDIRS, 50L);
+  curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
+  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, bind_curl_callback);
+  curl_easy_setopt(curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
+  curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, bind_curl_error);
+  curl_easy_setopt(curl, CURLOPT_URL, (url != NULL) ? url : BIND_DEFAULT_URL);
+  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
+  curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
 #ifdef HAVE_CURLOPT_TIMEOUT_MS
-  curl_easy_setopt (curl, CURLOPT_TIMEOUT_MS, (timeout >= 0) ?
-      (long) timeout : (long) CDTIME_T_TO_MS(plugin_get_interval()));
+  curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS,
+                   (timeout >= 0) ? (long)timeout : (long)CDTIME_T_TO_MS(
+                                                        plugin_get_interval()));
 #endif
 
-
   return (0);
 } /* }}} int bind_init */
 
-static int bind_read (void) /* {{{ */
+static int bind_read(void) /* {{{ */
 {
   int status;
 
-  if (curl == NULL)
-  {
-    ERROR ("bind plugin: I don't have a CURL object.");
+  if (curl == NULL) {
+    ERROR("bind plugin: I don't have a CURL object.");
     return (-1);
   }
 
   bind_buffer_fill = 0;
-  if (curl_easy_perform (curl) != CURLE_OK)
-  {
-    ERROR ("bind plugin: curl_easy_perform failed: %s",
-        bind_curl_error);
+  if (curl_easy_perform(curl) != CURLE_OK) {
+    ERROR("bind plugin: curl_easy_perform failed: %s", bind_curl_error);
     return (-1);
   }
 
-  status = bind_xml (bind_buffer);
+  status = bind_xml(bind_buffer);
   if (status != 0)
     return (-1);
   else
     return (0);
 } /* }}} int bind_read */
 
-static int bind_shutdown (void) /* {{{ */
+static int bind_shutdown(void) /* {{{ */
 {
-  if (curl != NULL)
-  {
-    curl_easy_cleanup (curl);
+  if (curl != NULL) {
+    curl_easy_cleanup(curl);
     curl = NULL;
   }
 
   return (0);
 } /* }}} int bind_shutdown */
 
-void module_register (void)
-{
-  plugin_register_complex_config ("bind", bind_config);
-  plugin_register_init ("bind", bind_init);
-  plugin_register_read ("bind", bind_read);
-  plugin_register_shutdown ("bind", bind_shutdown);
+void module_register(void) {
+  plugin_register_complex_config("bind", bind_config);
+  plugin_register_init("bind", bind_init);
+  plugin_register_read("bind", bind_read);
+  plugin_register_shutdown("bind", bind_shutdown);
 } /* void module_register */
 
 /* vim: set sw=2 sts=2 ts=8 et fdm=marker : */
@@ -39,10 +39,12 @@
 #include <yajl/yajl_version.h>
 #endif
 #ifdef HAVE_SYS_CAPABILITY_H
-# include <sys/capability.h>
+#include <sys/capability.h>
 #endif
 
+#include <inttypes.h>
 #include <limits.h>
+#include <math.h>
 #include <poll.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -53,30 +55,28 @@
 #include <sys/types.h>
 #include <sys/un.h>
 #include <unistd.h>
-#include <math.h>
-#include <inttypes.h>
 
 #define RETRY_AVGCOUNT -1
 
 #if defined(YAJL_MAJOR) && (YAJL_MAJOR > 1)
-# define HAVE_YAJL_V2 1
+#define HAVE_YAJL_V2 1
 #endif
 
-#define RETRY_ON_EINTR(ret, expr) \
-    while(1) { \
-        ret = expr; \
-        if(ret >= 0) \
-            break; \
-        ret = -errno; \
-        if(ret != -EINTR) \
-            break; \
-    }
+#define RETRY_ON_EINTR(ret, expr)                                              \
+  while (1) {                                                                  \
+    ret = expr;                                                                \
+    if (ret >= 0)                                                              \
+      break;                                                                   \
+    ret = -errno;                                                              \
+    if (ret != -EINTR)                                                         \
+      break;                                                                   \
+  }
 
 /** Timeout interval in seconds */
 #define CEPH_TIMEOUT_INTERVAL 1
 
 /** Maximum path length for a UNIX domain socket on this system */
-#define UNIX_DOMAIN_SOCK_PATH_MAX (sizeof(((struct sockaddr_un*)0)->sun_path))
+#define UNIX_DOMAIN_SOCK_PATH_MAX (sizeof(((struct sockaddr_un *)0)->sun_path))
 
 /** Yajl callback returns */
 #define CEPH_CB_CONTINUE 1
@@ -91,63 +91,60 @@ typedef unsigned int yajl_len_t;
 /** Number of types for ceph defined in types.db */
 #define CEPH_DSET_TYPES_NUM 3
 /** ceph types enum */
-enum ceph_dset_type_d
-{
-    DSET_LATENCY = 0,
-    DSET_BYTES = 1,
-    DSET_RATE = 2,
-    DSET_TYPE_UNFOUND = 1000
+enum ceph_dset_type_d {
+  DSET_LATENCY = 0,
+  DSET_BYTES = 1,
+  DSET_RATE = 2,
+  DSET_TYPE_UNFOUND = 1000
 };
 
 /** Valid types for ceph defined in types.db */
-static const char * const ceph_dset_types [CEPH_DSET_TYPES_NUM] =
-                                   {"ceph_latency", "ceph_bytes", "ceph_rate"};
+static const char *const ceph_dset_types[CEPH_DSET_TYPES_NUM] = {
+    "ceph_latency", "ceph_bytes", "ceph_rate"};
 
 /******* ceph_daemon *******/
-struct ceph_daemon
-{
-    /** Version of the admin_socket interface */
-    uint32_t version;
-    /** daemon name **/
-    char name[DATA_MAX_NAME_LEN];
-
-    /** Path to the socket that we use to talk to the ceph daemon */
-    char asok_path[UNIX_DOMAIN_SOCK_PATH_MAX];
-
-    /** Number of counters */
-    int ds_num;
-    /** Track ds types */
-    uint32_t *ds_types;
-    /** Track ds names to match with types */
-    char **ds_names;
-
-    /**
-     * Keep track of last data for latency values so we can calculate rate
-     * since last poll.
-     */
-    struct last_data **last_poll_data;
-    /** index of last poll data */
-    int last_idx;
+struct ceph_daemon {
+  /** Version of the admin_socket interface */
+  uint32_t version;
+  /** daemon name **/
+  char name[DATA_MAX_NAME_LEN];
+
+  /** Path to the socket that we use to talk to the ceph daemon */
+  char asok_path[UNIX_DOMAIN_SOCK_PATH_MAX];
+
+  /** Number of counters */
+  int ds_num;
+  /** Track ds types */
+  uint32_t *ds_types;
+  /** Track ds names to match with types */
+  char **ds_names;
+
+  /**
+   * Keep track of last data for latency values so we can calculate rate
+   * since last poll.
+   */
+  struct last_data **last_poll_data;
+  /** index of last poll data */
+  int last_idx;
 };
 
 /******* JSON parsing *******/
-typedef int (*node_handler_t)(void *, const char*, const char*);
+typedef int (*node_handler_t)(void *, const char *, const char *);
 
 /** Track state and handler while parsing JSON */
-struct yajl_struct
-{
-    node_handler_t handler;
-    void * handler_arg;
-
-    char *key;
-    char *stack[YAJL_MAX_DEPTH];
-    size_t depth;
+struct yajl_struct {
+  node_handler_t handler;
+  void *handler_arg;
+
+  char *key;
+  char *stack[YAJL_MAX_DEPTH];
+  size_t depth;
 };
 typedef struct yajl_struct yajl_struct;
 
-enum perfcounter_type_d
-{
-    PERFCOUNTER_LATENCY = 0x4, PERFCOUNTER_DERIVE = 0x8,
+enum perfcounter_type_d {
+  PERFCOUNTER_LATENCY = 0x4,
+  PERFCOUNTER_DERIVE = 0x8,
 };
 
 /** Give user option to use default (long run = since daemon started) avg */
@@ -172,1468 +169,1281 @@ static size_t g_num_daemons = 0;
 /**
  * A set of data that we build up in memory while parsing the JSON.
  */
-struct values_tmp
-{
-    /** ceph daemon we are processing data for*/
-    struct ceph_daemon *d;
-    /** track avgcount across counters for avgcount/sum latency pairs */
-    uint64_t avgcount;
-    /** current index of counters - used to get type of counter */
-    int index;
-    /** do we already have an avgcount for latency pair */
-    int avgcount_exists;
-    /**
-     * similar to index, but current index of latency type counters -
-     * used to get last poll data of counter
-     */
-    int latency_index;
-    /**
-     * values list - maintain across counters since
-     * host/plugin/plugin instance are always the same
-     */
-    value_list_t vlist;
+struct values_tmp {
+  /** ceph daemon we are processing data for*/
+  struct ceph_daemon *d;
+  /** track avgcount across counters for avgcount/sum latency pairs */
+  uint64_t avgcount;
+  /** current index of counters - used to get type of counter */
+  int index;
+  /** do we already have an avgcount for latency pair */
+  int avgcount_exists;
+  /**
+   * similar to index, but current index of latency type counters -
+   * used to get last poll data of counter
+   */
+  int latency_index;
+  /**
+   * values list - maintain across counters since
+   * host/plugin/plugin instance are always the same
+   */
+  value_list_t vlist;
 };
 
 /**
  * A set of count/sum pairs to keep track of latency types and get difference
  * between this poll data and last poll data.
  */
-struct last_data
-{
-    char ds_name[DATA_MAX_NAME_LEN];
-    double last_sum;
-    uint64_t last_count;
+struct last_data {
+  char ds_name[DATA_MAX_NAME_LEN];
+  double last_sum;
+  uint64_t last_count;
 };
 
 /******* network I/O *******/
-enum cstate_t
-{
-    CSTATE_UNCONNECTED = 0,
-    CSTATE_WRITE_REQUEST,
-    CSTATE_READ_VERSION,
-    CSTATE_READ_AMT,
-    CSTATE_READ_JSON,
+enum cstate_t {
+  CSTATE_UNCONNECTED = 0,
+  CSTATE_WRITE_REQUEST,
+  CSTATE_READ_VERSION,
+  CSTATE_READ_AMT,
+  CSTATE_READ_JSON,
 };
 
-enum request_type_t
-{
-    ASOK_REQ_VERSION = 0,
-    ASOK_REQ_DATA = 1,
-    ASOK_REQ_SCHEMA = 2,
-    ASOK_REQ_NONE = 1000,
+enum request_type_t {
+  ASOK_REQ_VERSION = 0,
+  ASOK_REQ_DATA = 1,
+  ASOK_REQ_SCHEMA = 2,
+  ASOK_REQ_NONE = 1000,
 };
 
-struct cconn
-{
-    /** The Ceph daemon that we're talking to */
-    struct ceph_daemon *d;
+struct cconn {
+  /** The Ceph daemon that we're talking to */
+  struct ceph_daemon *d;
 
-    /** Request type */
-    uint32_t request_type;
+  /** Request type */
+  uint32_t request_type;
 
-    /** The connection state */
-    enum cstate_t state;
+  /** The connection state */
+  enum cstate_t state;
 
-    /** The socket we use to talk to this daemon */
-    int asok;
+  /** The socket we use to talk to this daemon */
+  int asok;
 
-    /** The amount of data remaining to read / write. */
-    uint32_t amt;
+  /** The amount of data remaining to read / write. */
+  uint32_t amt;
 
-    /** Length of the JSON to read */
-    uint32_t json_len;
+  /** Length of the JSON to read */
+  uint32_t json_len;
 
-    /** Buffer containing JSON data */
-    unsigned char *json;
+  /** Buffer containing JSON data */
+  unsigned char *json;
 
-    /** Keep data important to yajl processing */
-    struct yajl_struct yajl;
+  /** Keep data important to yajl processing */
+  struct yajl_struct yajl;
 };
 
-static int ceph_cb_null(void *ctx)
-{
-    return CEPH_CB_CONTINUE;
-}
-
-static int ceph_cb_boolean(void *ctx, int bool_val)
-{
-    return CEPH_CB_CONTINUE;
-}
+static int ceph_cb_null(void *ctx) { return CEPH_CB_CONTINUE; }
+
+static int ceph_cb_boolean(void *ctx, int bool_val) { return CEPH_CB_CONTINUE; }
+
+#define BUFFER_ADD(dest, src)                                                  \
+  do {                                                                         \
+    size_t dest_size = sizeof(dest);                                           \
+    size_t dest_len = strlen(dest);                                            \
+    if (dest_size > dest_len) {                                                \
+      sstrncpy((dest) + dest_len, (src), dest_size - dest_len);                \
+    }                                                                          \
+    (dest)[dest_size - 1] = 0;                                                 \
+  } while (0)
+
+static int ceph_cb_number(void *ctx, const char *number_val,
+                          yajl_len_t number_len) {
+  yajl_struct *state = (yajl_struct *)ctx;
+  char buffer[number_len + 1];
+  char key[2 * DATA_MAX_NAME_LEN] = {0};
+  _Bool latency_type = 0;
+  int status;
+
+  memcpy(buffer, number_val, number_len);
+  buffer[sizeof(buffer) - 1] = '\0';
+
+  for (size_t i = 0; i < state->depth; i++) {
+    if (state->stack[i] == NULL)
+      continue;
+
+    if (strlen(key) != 0)
+      BUFFER_ADD(key, ".");
+    BUFFER_ADD(key, state->stack[i]);
+  }
 
-#define BUFFER_ADD(dest, src) do { \
-    size_t dest_size = sizeof (dest); \
-    size_t dest_len = strlen (dest); \
-    if (dest_size > dest_len) { \
-        sstrncpy ((dest) + dest_len, (src), dest_size - dest_len); \
-    } \
-    (dest)[dest_size - 1] = 0; \
-} while (0)
-
-static int
-ceph_cb_number(void *ctx, const char *number_val, yajl_len_t number_len)
-{
-    yajl_struct *state = (yajl_struct*) ctx;
-    char buffer[number_len+1];
-    char key[2 * DATA_MAX_NAME_LEN] = { 0 };
-    _Bool latency_type = 0;
-    int status;
-
-    memcpy(buffer, number_val, number_len);
-    buffer[sizeof(buffer) - 1] = '\0';
-
-    for (size_t i = 0; i < state->depth; i++)
-    {
-        if (state->stack[i] == NULL)
-            continue;
-
-        if (strlen (key) != 0)
-            BUFFER_ADD (key, ".");
-        BUFFER_ADD (key, state->stack[i]);
-    }
+  /* Special case for latency metrics. */
+  if ((strcmp("avgcount", state->key) == 0) ||
+      (strcmp("sum", state->key) == 0)) {
+    latency_type = 1;
+
+    /* depth >= 2  =>  (stack[-1] != NULL && stack[-2] != NULL) */
+    assert((state->depth < 2) || ((state->stack[state->depth - 1] != NULL) &&
+                                  (state->stack[state->depth - 2] != NULL)));
+
+    /* Super-special case for filestore.journal_wr_bytes.avgcount: For
+     * some reason, Ceph schema encodes this as a count/sum pair while all
+     * other "Bytes" data (excluding used/capacity bytes for OSD space) uses
+     * a single "Derive" type. To spare further confusion, keep this KPI as
+     * the same type of other "Bytes". Instead of keeping an "average" or
+     * "rate", use the "sum" in the pair and assign that to the derive
+     * value. */
+    if (convert_special_metrics && (state->depth >= 2) &&
+        (strcmp("filestore", state->stack[state->depth - 2]) == 0) &&
+        (strcmp("journal_wr_bytes", state->stack[state->depth - 1]) == 0) &&
+        (strcmp("avgcount", state->key) == 0)) {
+      DEBUG("ceph plugin: Skipping avgcount for filestore.JournalWrBytes");
+      return CEPH_CB_CONTINUE;
+    }
+  } else /* not a latency type */
+  {
+    BUFFER_ADD(key, ".");
+    BUFFER_ADD(key, state->key);
+  }
 
-    /* Special case for latency metrics. */
-    if ((strcmp ("avgcount", state->key) == 0)
-        || (strcmp ("sum", state->key) == 0))
-    {
-        latency_type = 1;
-
-        /* depth >= 2  =>  (stack[-1] != NULL && stack[-2] != NULL) */
-        assert ((state->depth < 2)
-                || ((state->stack[state->depth - 1] != NULL)
-                    && (state->stack[state->depth - 2] != NULL)));
-
-        /* Super-special case for filestore.journal_wr_bytes.avgcount: For
-         * some reason, Ceph schema encodes this as a count/sum pair while all
-         * other "Bytes" data (excluding used/capacity bytes for OSD space) uses
-         * a single "Derive" type. To spare further confusion, keep this KPI as
-         * the same type of other "Bytes". Instead of keeping an "average" or
-         * "rate", use the "sum" in the pair and assign that to the derive
-         * value. */
-        if (convert_special_metrics && (state->depth >= 2)
-            && (strcmp("filestore", state->stack[state->depth - 2]) == 0)
-            && (strcmp("journal_wr_bytes", state->stack[state->depth - 1]) == 0)
-            && (strcmp("avgcount", state->key) == 0))
-        {
-            DEBUG("ceph plugin: Skipping avgcount for filestore.JournalWrBytes");
-            return CEPH_CB_CONTINUE;
-        }
-    }
-    else /* not a latency type */
-    {
-        BUFFER_ADD (key, ".");
-        BUFFER_ADD (key, state->key);
-    }
+  status = state->handler(state->handler_arg, buffer, key);
+  if ((status == RETRY_AVGCOUNT) && latency_type) {
+    /* Add previously skipped part of the key, either "avgcount" or "sum",
+     * and try again. */
+    BUFFER_ADD(key, ".");
+    BUFFER_ADD(key, state->key);
 
     status = state->handler(state->handler_arg, buffer, key);
-    if((status == RETRY_AVGCOUNT) && latency_type)
-    {
-        /* Add previously skipped part of the key, either "avgcount" or "sum",
-         * and try again. */
-        BUFFER_ADD (key, ".");
-        BUFFER_ADD (key, state->key);
-
-        status = state->handler(state->handler_arg, buffer, key);
-    }
+  }
 
-    if (status != 0)
-    {
-        ERROR("ceph plugin: JSON handler failed with status %d.", status);
-        return CEPH_CB_ABORT;
-    }
+  if (status != 0) {
+    ERROR("ceph plugin: JSON handler failed with status %d.", status);
+    return CEPH_CB_ABORT;
+  }
 
-    return CEPH_CB_CONTINUE;
+  return CEPH_CB_CONTINUE;
 }
 
 static int ceph_cb_string(void *ctx, const unsigned char *string_val,
-        yajl_len_t string_len)
-{
-    return CEPH_CB_CONTINUE;
+                          yajl_len_t string_len) {
+  return CEPH_CB_CONTINUE;
 }
 
-static int ceph_cb_start_map(void *ctx)
-{
-    yajl_struct *state = (yajl_struct*) ctx;
+static int ceph_cb_start_map(void *ctx) {
+  yajl_struct *state = (yajl_struct *)ctx;
 
-    /* Push key to the stack */
-    if (state->depth == YAJL_MAX_DEPTH)
-        return CEPH_CB_ABORT;
+  /* Push key to the stack */
+  if (state->depth == YAJL_MAX_DEPTH)
+    return CEPH_CB_ABORT;
 
-    state->stack[state->depth] = state->key;
-    state->depth++;
-    state->key = NULL;
+  state->stack[state->depth] = state->key;
+  state->depth++;
+  state->key = NULL;
 
-    return CEPH_CB_CONTINUE;
+  return CEPH_CB_CONTINUE;
 }
 
-static int ceph_cb_end_map(void *ctx)
-{
-    yajl_struct *state = (yajl_struct*) ctx;
+static int ceph_cb_end_map(void *ctx) {
+  yajl_struct *state = (yajl_struct *)ctx;
 
-    /* Pop key from the stack */
-    if (state->depth == 0)
-        return CEPH_CB_ABORT;
+  /* Pop key from the stack */
+  if (state->depth == 0)
+    return CEPH_CB_ABORT;
 
-    sfree (state->key);
-    state->depth--;
-    state->key = state->stack[state->depth];
-    state->stack[state->depth] = NULL;
+  sfree(state->key);
+  state->depth--;
+  state->key = state->stack[state->depth];
+  state->stack[state->depth] = NULL;
 
-    return CEPH_CB_CONTINUE;
+  return CEPH_CB_CONTINUE;
 }
 
-static int
-ceph_cb_map_key(void *ctx, const unsigned char *key, yajl_len_t string_len)
-{
-    yajl_struct *state = (yajl_struct*) ctx;
-    size_t sz = ((size_t) string_len) + 1;
-
-    sfree (state->key);
-    state->key = malloc (sz);
-    if (state->key == NULL)
-    {
-        ERROR ("ceph plugin: malloc failed.");
-        return CEPH_CB_ABORT;
-    }
+static int ceph_cb_map_key(void *ctx, const unsigned char *key,
+                           yajl_len_t string_len) {
+  yajl_struct *state = (yajl_struct *)ctx;
+  size_t sz = ((size_t)string_len) + 1;
 
-    memmove (state->key, key, sz - 1);
-    state->key[sz - 1] = 0;
+  sfree(state->key);
+  state->key = malloc(sz);
+  if (state->key == NULL) {
+    ERROR("ceph plugin: malloc failed.");
+    return CEPH_CB_ABORT;
+  }
 
-    return CEPH_CB_CONTINUE;
-}
+  memmove(state->key, key, sz - 1);
+  state->key[sz - 1] = 0;
 
-static int ceph_cb_start_array(void *ctx)
-{
-    return CEPH_CB_CONTINUE;
+  return CEPH_CB_CONTINUE;
 }
 
-static int ceph_cb_end_array(void *ctx)
-{
-    return CEPH_CB_CONTINUE;
-}
+static int ceph_cb_start_array(void *ctx) { return CEPH_CB_CONTINUE; }
 
-static yajl_callbacks callbacks = {
-        ceph_cb_null,
-        ceph_cb_boolean,
-        NULL,
-        NULL,
-        ceph_cb_number,
-        ceph_cb_string,
-        ceph_cb_start_map,
-        ceph_cb_map_key,
-        ceph_cb_end_map,
-        ceph_cb_start_array,
-        ceph_cb_end_array
-};
+static int ceph_cb_end_array(void *ctx) { return CEPH_CB_CONTINUE; }
 
-static void ceph_daemon_print(const struct ceph_daemon *d)
-{
-    DEBUG("ceph plugin: name=%s, asok_path=%s", d->name, d->asok_path);
+static yajl_callbacks callbacks = {ceph_cb_null,
+                                   ceph_cb_boolean,
+                                   NULL,
+                                   NULL,
+                                   ceph_cb_number,
+                                   ceph_cb_string,
+                                   ceph_cb_start_map,
+                                   ceph_cb_map_key,
+                                   ceph_cb_end_map,
+                                   ceph_cb_start_array,
+                                   ceph_cb_end_array};
+
+static void ceph_daemon_print(const struct ceph_daemon *d) {
+  DEBUG("ceph plugin: name=%s, asok_path=%s", d->name, d->asok_path);
 }
 
-static void ceph_daemons_print(void)
-{
-    for(size_t i = 0; i < g_num_daemons; ++i)
-    {
-        ceph_daemon_print(g_daemons[i]);
-    }
+static void ceph_daemons_print(void) {
+  for (size_t i = 0; i < g_num_daemons; ++i) {
+    ceph_daemon_print(g_daemons[i]);
+  }
 }
 
-static void ceph_daemon_free(struct ceph_daemon *d)
-{
-    for(int i = 0; i < d->last_idx; i++)
-    {
-        sfree(d->last_poll_data[i]);
-    }
-    sfree(d->last_poll_data);
-    d->last_poll_data = NULL;
-    d->last_idx = 0;
+static void ceph_daemon_free(struct ceph_daemon *d) {
+  for (int i = 0; i < d->last_idx; i++) {
+    sfree(d->last_poll_data[i]);
+  }
+  sfree(d->last_poll_data);
+  d->last_poll_data = NULL;
+  d->last_idx = 0;
 
-    for(int i = 0; i < d->ds_num; i++)
-    {
-        sfree(d->ds_names[i]);
-    }
-    sfree(d->ds_types);
-    sfree(d->ds_names);
-    sfree(d);
+  for (int i = 0; i < d->ds_num; i++) {
+    sfree(d->ds_names[i]);
+  }
+  sfree(d->ds_types);
+  sfree(d->ds_names);
+  sfree(d);
 }
 
 /* compact_ds_name removed the special characters ":", "_", "-" and "+" from the
  * intput string. Characters following these special characters are capitalized.
  * Trailing "+" and "-" characters are replaces with the strings "Plus" and
  * "Minus". */
-static int compact_ds_name (char *buffer, size_t buffer_size, char const *src)
-{
-    char *src_copy;
-    size_t src_len;
-    char *ptr = buffer;
-    size_t ptr_size = buffer_size;
-    _Bool append_plus = 0;
-    _Bool append_minus = 0;
-
-    if ((buffer == NULL) || (buffer_size <= strlen ("Minus")) || (src == NULL))
-      return EINVAL;
-
-    src_copy = strdup (src);
-    src_len = strlen(src);
-
-    /* Remove trailing "+" and "-". */
-    if (src_copy[src_len - 1] == '+')
-    {
-        append_plus = 1;
-        src_len--;
-        src_copy[src_len] = 0;
-    }
-    else if (src_copy[src_len - 1] == '-')
-    {
-        append_minus = 1;
-        src_len--;
-        src_copy[src_len] = 0;
-    }
+static int compact_ds_name(char *buffer, size_t buffer_size, char const *src) {
+  char *src_copy;
+  size_t src_len;
+  char *ptr = buffer;
+  size_t ptr_size = buffer_size;
+  _Bool append_plus = 0;
+  _Bool append_minus = 0;
+
+  if ((buffer == NULL) || (buffer_size <= strlen("Minus")) || (src == NULL))
+    return EINVAL;
+
+  src_copy = strdup(src);
+  src_len = strlen(src);
+
+  /* Remove trailing "+" and "-". */
+  if (src_copy[src_len - 1] == '+') {
+    append_plus = 1;
+    src_len--;
+    src_copy[src_len] = 0;
+  } else if (src_copy[src_len - 1] == '-') {
+    append_minus = 1;
+    src_len--;
+    src_copy[src_len] = 0;
+  }
 
-    /* Split at special chars, capitalize first character, append to buffer. */
-    char *dummy = src_copy;
-    char *token;
-    char *save_ptr = NULL;
-    while ((token = strtok_r (dummy, ":_-+", &save_ptr)) != NULL)
-    {
-        size_t len;
+  /* Split at special chars, capitalize first character, append to buffer. */
+  char *dummy = src_copy;
+  char *token;
+  char *save_ptr = NULL;
+  while ((token = strtok_r(dummy, ":_-+", &save_ptr)) != NULL) {
+    size_t len;
 
-        dummy = NULL;
+    dummy = NULL;
 
-        token[0] = toupper ((int) token[0]);
+    token[0] = toupper((int)token[0]);
 
-        assert (ptr_size > 1);
+    assert(ptr_size > 1);
 
-        len = strlen (token);
-        if (len >= ptr_size)
-            len = ptr_size - 1;
+    len = strlen(token);
+    if (len >= ptr_size)
+      len = ptr_size - 1;
 
-        assert (len > 0);
-        assert (len < ptr_size);
+    assert(len > 0);
+    assert(len < ptr_size);
 
-        sstrncpy (ptr, token, len + 1);
-        ptr += len;
-        ptr_size -= len;
+    sstrncpy(ptr, token, len + 1);
+    ptr += len;
+    ptr_size -= len;
 
-        assert (*ptr == 0);
-        if (ptr_size <= 1)
-            break;
-    }
+    assert(*ptr == 0);
+    if (ptr_size <= 1)
+      break;
+  }
 
-    /* Append "Plus" or "Minus" if "+" or "-" has been stripped above. */
-    if (append_plus || append_minus)
-    {
-        char const *append = "Plus";
-        if (append_minus)
-            append = "Minus";
+  /* Append "Plus" or "Minus" if "+" or "-" has been stripped above. */
+  if (append_plus || append_minus) {
+    char const *append = "Plus";
+    if (append_minus)
+      append = "Minus";
 
-        size_t offset = buffer_size - (strlen (append) + 1);
-        if (offset > strlen (buffer))
-            offset = strlen (buffer);
+    size_t offset = buffer_size - (strlen(append) + 1);
+    if (offset > strlen(buffer))
+      offset = strlen(buffer);
 
-        sstrncpy (buffer + offset, append, buffer_size - offset);
-    }
+    sstrncpy(buffer + offset, append, buffer_size - offset);
+  }
 
-    sfree (src_copy);
-    return 0;
+  sfree(src_copy);
+  return 0;
 }
 
-static _Bool has_suffix (char const *str, char const *suffix)
-{
-    size_t str_len = strlen (str);
-    size_t suffix_len = strlen (suffix);
-    size_t offset;
+static _Bool has_suffix(char const *str, char const *suffix) {
+  size_t str_len = strlen(str);
+  size_t suffix_len = strlen(suffix);
+  size_t offset;
 
-    if (suffix_len > str_len)
-        return 0;
-    offset = str_len - suffix_len;
+  if (suffix_len > str_len)
+    return 0;
+  offset = str_len - suffix_len;
 
-    if (strcmp (str + offset, suffix) == 0)
-        return 1;
+  if (strcmp(str + offset, suffix) == 0)
+    return 1;
 
-    return 0;
+  return 0;
 }
 
 /* count_parts returns the number of elements a "foo.bar.baz" style key has. */
-static size_t count_parts (char const *key)
-{
-    size_t parts_num = 0;
+static size_t count_parts(char const *key) {
+  size_t parts_num = 0;
 
-    for (const char *ptr = key; ptr != NULL; ptr = strchr (ptr + 1, '.'))
-        parts_num++;
+  for (const char *ptr = key; ptr != NULL; ptr = strchr(ptr + 1, '.'))
+    parts_num++;
 
-    return parts_num;
+  return parts_num;
 }
 
 /**
  * Parse key to remove "type" if this is for schema and initiate compaction
  */
-static int parse_keys (char *buffer, size_t buffer_size, const char *key_str)
-{
-    char tmp[2 * buffer_size];
-
-    if (buffer == NULL || buffer_size == 0 || key_str == NULL || strlen (key_str) == 0)
-        return EINVAL;
-
-    if ((count_parts (key_str) > 2) && has_suffix (key_str, ".type"))
-    {
-        /* strip ".type" suffix iff the key has more than two parts. */
-        size_t sz = strlen (key_str) - strlen (".type") + 1;
-
-        if (sz > sizeof (tmp))
-            sz = sizeof (tmp);
-        sstrncpy (tmp, key_str, sz);
-    }
-    else
-    {
-        sstrncpy (tmp, key_str, sizeof (tmp));
-    }
+static int parse_keys(char *buffer, size_t buffer_size, const char *key_str) {
+  char tmp[2 * buffer_size];
+
+  if (buffer == NULL || buffer_size == 0 || key_str == NULL ||
+      strlen(key_str) == 0)
+    return EINVAL;
+
+  if ((count_parts(key_str) > 2) && has_suffix(key_str, ".type")) {
+    /* strip ".type" suffix iff the key has more than two parts. */
+    size_t sz = strlen(key_str) - strlen(".type") + 1;
+
+    if (sz > sizeof(tmp))
+      sz = sizeof(tmp);
+    sstrncpy(tmp, key_str, sz);
+  } else {
+    sstrncpy(tmp, key_str, sizeof(tmp));
+  }
 
-    return compact_ds_name (buffer, buffer_size, tmp);
+  return compact_ds_name(buffer, buffer_size, tmp);
 }
 
 /**
  * while parsing ceph admin socket schema, save counter name and type for later
  * data processing
  */
 static int ceph_daemon_add_ds_entry(struct ceph_daemon *d, const char *name,
-        int pc_type)
-{
-    uint32_t type;
-    char ds_name[DATA_MAX_NAME_LEN];
-
-    if(convert_special_metrics)
-    {
-        /**
-         * Special case for filestore:JournalWrBytes. For some reason, Ceph
-         * schema encodes this as a count/sum pair while all other "Bytes" data
-         * (excluding used/capacity bytes for OSD space) uses a single "Derive"
-         * type. To spare further confusion, keep this KPI as the same type of
-         * other "Bytes". Instead of keeping an "average" or "rate", use the
-         * "sum" in the pair and assign that to the derive value.
-         */
-        if((strcmp(name,"filestore.journal_wr_bytes.type") == 0))
-        {
-            pc_type = 10;
-        }
-    }
+                                    int pc_type) {
+  uint32_t type;
+  char ds_name[DATA_MAX_NAME_LEN];
 
-    d->ds_names = realloc(d->ds_names, sizeof(char *) * (d->ds_num + 1));
-    if(!d->ds_names)
-    {
-        return -ENOMEM;
+  if (convert_special_metrics) {
+    /**
+     * Special case for filestore:JournalWrBytes. For some reason, Ceph
+     * schema encodes this as a count/sum pair while all other "Bytes" data
+     * (excluding used/capacity bytes for OSD space) uses a single "Derive"
+     * type. To spare further confusion, keep this KPI as the same type of
+     * other "Bytes". Instead of keeping an "average" or "rate", use the
+     * "sum" in the pair and assign that to the derive value.
+     */
+    if ((strcmp(name, "filestore.journal_wr_bytes.type") == 0)) {
+      pc_type = 10;
     }
+  }
 
-    d->ds_types = realloc(d->ds_types, sizeof(uint32_t) * (d->ds_num + 1));
-    if(!d->ds_types)
-    {
-        return -ENOMEM;
-    }
+  d->ds_names = realloc(d->ds_names, sizeof(char *) * (d->ds_num + 1));
+  if (!d->ds_names) {
+    return -ENOMEM;
+  }
 
-    d->ds_names[d->ds_num] = malloc(DATA_MAX_NAME_LEN);
-    if(!d->ds_names[d->ds_num])
-    {
-        return -ENOMEM;
-    }
+  d->ds_types = realloc(d->ds_types, sizeof(uint32_t) * (d->ds_num + 1));
+  if (!d->ds_types) {
+    return -ENOMEM;
+  }
+
+  d->ds_names[d->ds_num] = malloc(DATA_MAX_NAME_LEN);
+  if (!d->ds_names[d->ds_num]) {
+    return -ENOMEM;
+  }
 
-    type = (pc_type & PERFCOUNTER_DERIVE) ? DSET_RATE :
-            ((pc_type & PERFCOUNTER_LATENCY) ? DSET_LATENCY : DSET_BYTES);
-    d->ds_types[d->ds_num] = type;
+  type = (pc_type & PERFCOUNTER_DERIVE)
+             ? DSET_RATE
+             : ((pc_type & PERFCOUNTER_LATENCY) ? DSET_LATENCY : DSET_BYTES);
+  d->ds_types[d->ds_num] = type;
 
-    if (parse_keys(ds_name, sizeof (ds_name), name))
-    {
-        return 1;
-    }
+  if (parse_keys(ds_name, sizeof(ds_name), name)) {
+    return 1;
+  }
 
-    sstrncpy(d->ds_names[d->ds_num], ds_name, DATA_MAX_NAME_LEN -1);
-    d->ds_num = (d->ds_num + 1);
+  sstrncpy(d->ds_names[d->ds_num], ds_name, DATA_MAX_NAME_LEN - 1);
+  d->ds_num = (d->ds_num + 1);
 
-    return 0;
+  return 0;
 }
 
 /******* ceph_config *******/
-static int cc_handle_str(struct oconfig_item_s *item, char *dest, int dest_len)
-{
-    const char *val;
-    if(item->values_num != 1)
-    {
-        return -ENOTSUP;
-    }
-    if(item->values[0].type != OCONFIG_TYPE_STRING)
-    {
-        return -ENOTSUP;
-    }
-    val = item->values[0].value.string;
-    if(snprintf(dest, dest_len, "%s", val) > (dest_len - 1))
-    {
-        ERROR("ceph plugin: configuration parameter '%s' is too long.\n",
-                item->key);
-        return -ENAMETOOLONG;
-    }
-    return 0;
+static int cc_handle_str(struct oconfig_item_s *item, char *dest,
+                         int dest_len) {
+  const char *val;
+  if (item->values_num != 1) {
+    return -ENOTSUP;
+  }
+  if (item->values[0].type != OCONFIG_TYPE_STRING) {
+    return -ENOTSUP;
+  }
+  val = item->values[0].value.string;
+  if (snprintf(dest, dest_len, "%s", val) > (dest_len - 1)) {
+    ERROR("ceph plugin: configuration parameter '%s' is too long.\n",
+          item->key);
+    return -ENAMETOOLONG;
+  }
+  return 0;
 }
 
-static int cc_handle_bool(struct oconfig_item_s *item, int *dest)
-{
-    if(item->values_num != 1)
-    {
-        return -ENOTSUP;
-    }
+static int cc_handle_bool(struct oconfig_item_s *item, int *dest) {
+  if (item->values_num != 1) {
+    return -ENOTSUP;
+  }
 
-    if(item->values[0].type != OCONFIG_TYPE_BOOLEAN)
-    {
-        return -ENOTSUP;
-    }
+  if (item->values[0].type != OCONFIG_TYPE_BOOLEAN) {
+    return -ENOTSUP;
+  }
 
-    *dest = (item->values[0].value.boolean) ? 1 : 0;
-    return 0;
+  *dest = (item->values[0].value.boolean) ? 1 : 0;
+  return 0;
 }
 
-static int cc_add_daemon_config(oconfig_item_t *ci)
-{
-    int ret;
-    struct ceph_daemon *nd, cd = { 0 };
-    struct ceph_daemon **tmp;
-
-    if((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
-    {
-        WARNING("ceph plugin: `Daemon' blocks need exactly one string "
-                "argument.");
-        return (-1);
-    }
+static int cc_add_daemon_config(oconfig_item_t *ci) {
+  int ret;
+  struct ceph_daemon *nd, cd = {0};
+  struct ceph_daemon **tmp;
 
-    ret = cc_handle_str(ci, cd.name, DATA_MAX_NAME_LEN);
-    if(ret)
-    {
-        return ret;
-    }
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
+    WARNING("ceph plugin: `Daemon' blocks need exactly one string "
+            "argument.");
+    return (-1);
+  }
 
-    for(int i=0; i < ci->children_num; i++)
-    {
-        oconfig_item_t *child = ci->children + i;
-
-        if(strcasecmp("SocketPath", child->key) == 0)
-        {
-            ret = cc_handle_str(child, cd.asok_path, sizeof(cd.asok_path));
-            if(ret)
-            {
-                return ret;
-            }
-        }
-        else
-        {
-            WARNING("ceph plugin: ignoring unknown option %s", child->key);
-        }
-    }
-    if(cd.name[0] == '\0')
-    {
-        ERROR("ceph plugin: you must configure a daemon name.\n");
-        return -EINVAL;
-    }
-    else if(cd.asok_path[0] == '\0')
-    {
-        ERROR("ceph plugin(name=%s): you must configure an administrative "
-        "socket path.\n", cd.name);
-        return -EINVAL;
-    }
-    else if(!((cd.asok_path[0] == '/') ||
-            (cd.asok_path[0] == '.' && cd.asok_path[1] == '/')))
-    {
-        ERROR("ceph plugin(name=%s): administrative socket paths must begin "
-                "with '/' or './' Can't parse: '%s'\n", cd.name, cd.asok_path);
-        return -EINVAL;
-    }
+  ret = cc_handle_str(ci, cd.name, DATA_MAX_NAME_LEN);
+  if (ret) {
+    return ret;
+  }
 
-    tmp = realloc(g_daemons, (g_num_daemons+1) * sizeof(*g_daemons));
-    if(tmp == NULL)
-    {
-        /* The positive return value here indicates that this is a
-         * runtime error, not a configuration error.  */
-        return ENOMEM;
-    }
-    g_daemons = tmp;
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
 
-    nd = malloc(sizeof (*nd));
-    if(!nd)
-    {
-        return ENOMEM;
+    if (strcasecmp("SocketPath", child->key) == 0) {
+      ret = cc_handle_str(child, cd.asok_path, sizeof(cd.asok_path));
+      if (ret) {
+        return ret;
+      }
+    } else {
+      WARNING("ceph plugin: ignoring unknown option %s", child->key);
     }
-    memcpy(nd, &cd, sizeof(*nd));
-    g_daemons[g_num_daemons] = nd;
-    g_num_daemons++;
-    return 0;
+  }
+  if (cd.name[0] == '\0') {
+    ERROR("ceph plugin: you must configure a daemon name.\n");
+    return -EINVAL;
+  } else if (cd.asok_path[0] == '\0') {
+    ERROR("ceph plugin(name=%s): you must configure an administrative "
+          "socket path.\n",
+          cd.name);
+    return -EINVAL;
+  } else if (!((cd.asok_path[0] == '/') ||
+               (cd.asok_path[0] == '.' && cd.asok_path[1] == '/'))) {
+    ERROR("ceph plugin(name=%s): administrative socket paths must begin "
+          "with '/' or './' Can't parse: '%s'\n",
+          cd.name, cd.asok_path);
+    return -EINVAL;
+  }
+
+  tmp = realloc(g_daemons, (g_num_daemons + 1) * sizeof(*g_daemons));
+  if (tmp == NULL) {
+    /* The positive return value here indicates that this is a
+     * runtime error, not a configuration error.  */
+    return ENOMEM;
+  }
+  g_daemons = tmp;
+
+  nd = malloc(sizeof(*nd));
+  if (!nd) {
+    return ENOMEM;
+  }
+  memcpy(nd, &cd, sizeof(*nd));
+  g_daemons[g_num_daemons] = nd;
+  g_num_daemons++;
+  return 0;
 }
 
-static int ceph_config(oconfig_item_t *ci)
-{
-    int ret;
-
-    for(int i = 0; i < ci->children_num; ++i)
-    {
-        oconfig_item_t *child = ci->children + i;
-        if(strcasecmp("Daemon", child->key) == 0)
-        {
-            ret = cc_add_daemon_config(child);
-            if(ret == ENOMEM)
-            {
-                ERROR("ceph plugin: Couldn't allocate memory");
-                return ret;
-            }
-            else if(ret)
-            {
-                //process other daemons and ignore this one
-                continue;
-            }
-        }
-        else if(strcasecmp("LongRunAvgLatency", child->key) == 0)
-        {
-            ret = cc_handle_bool(child, &long_run_latency_avg);
-            if(ret)
-            {
-                return ret;
-            }
-        }
-        else if(strcasecmp("ConvertSpecialMetricTypes", child->key) == 0)
-        {
-            ret = cc_handle_bool(child, &convert_special_metrics);
-            if(ret)
-            {
-                return ret;
-            }
-        }
-        else
-        {
-            WARNING("ceph plugin: ignoring unknown option %s", child->key);
-        }
+static int ceph_config(oconfig_item_t *ci) {
+  int ret;
+
+  for (int i = 0; i < ci->children_num; ++i) {
+    oconfig_item_t *child = ci->children + i;
+    if (strcasecmp("Daemon", child->key) == 0) {
+      ret = cc_add_daemon_config(child);
+      if (ret == ENOMEM) {
+        ERROR("ceph plugin: Couldn't allocate memory");
+        return ret;
+      } else if (ret) {
+        // process other daemons and ignore this one
+        continue;
+      }
+    } else if (strcasecmp("LongRunAvgLatency", child->key) == 0) {
+      ret = cc_handle_bool(child, &long_run_latency_avg);
+      if (ret) {
+        return ret;
+      }
+    } else if (strcasecmp("ConvertSpecialMetricTypes", child->key) == 0) {
+      ret = cc_handle_bool(child, &convert_special_metrics);
+      if (ret) {
+        return ret;
+      }
+    } else {
+      WARNING("ceph plugin: ignoring unknown option %s", child->key);
     }
-    return 0;
+  }
+  return 0;
 }
 
 /**
  * Parse JSON and get error message if present
  */
-static int
-traverse_json(const unsigned char *json, uint32_t json_len, yajl_handle hand)
-{
-    yajl_status status = yajl_parse(hand, json, json_len);
-    unsigned char *msg;
-
-    switch(status)
-    {
-        case yajl_status_error:
-            msg = yajl_get_error(hand, /* verbose = */ 1,
-                                       /* jsonText = */ (unsigned char *) json,
-                                                      (unsigned int) json_len);
-            ERROR ("ceph plugin: yajl_parse failed: %s", msg);
-            yajl_free_error(hand, msg);
-            return 1;
-        case yajl_status_client_canceled:
-            return 1;
-        default:
-            return 0;
-    }
+static int traverse_json(const unsigned char *json, uint32_t json_len,
+                         yajl_handle hand) {
+  yajl_status status = yajl_parse(hand, json, json_len);
+  unsigned char *msg;
+
+  switch (status) {
+  case yajl_status_error:
+    msg = yajl_get_error(hand, /* verbose = */ 1,
+                         /* jsonText = */ (unsigned char *)json,
+                         (unsigned int)json_len);
+    ERROR("ceph plugin: yajl_parse failed: %s", msg);
+    yajl_free_error(hand, msg);
+    return 1;
+  case yajl_status_client_canceled:
+    return 1;
+  default:
+    return 0;
+  }
 }
 
 /**
  * Add entry for each counter while parsing schema
  */
-static int
-node_handler_define_schema(void *arg, const char *val, const char *key)
-{
-    struct ceph_daemon *d = (struct ceph_daemon *) arg;
-    int pc_type;
-    pc_type = atoi(val);
-    return ceph_daemon_add_ds_entry(d, key, pc_type);
+static int node_handler_define_schema(void *arg, const char *val,
+                                      const char *key) {
+  struct ceph_daemon *d = (struct ceph_daemon *)arg;
+  int pc_type;
+  pc_type = atoi(val);
+  return ceph_daemon_add_ds_entry(d, key, pc_type);
 }
 
 /**
  * Latency counter does not yet have an entry in last poll data - add it.
  */
 static int add_last(struct ceph_daemon *d, const char *ds_n, double cur_sum,
-        uint64_t cur_count)
-{
-    d->last_poll_data[d->last_idx] = malloc(sizeof (*d->last_poll_data[d->last_idx]));
-    if(!d->last_poll_data[d->last_idx])
-    {
-        return -ENOMEM;
-    }
-    sstrncpy(d->last_poll_data[d->last_idx]->ds_name,ds_n,
-            sizeof(d->last_poll_data[d->last_idx]->ds_name));
-    d->last_poll_data[d->last_idx]->last_sum = cur_sum;
-    d->last_poll_data[d->last_idx]->last_count = cur_count;
-    d->last_idx = (d->last_idx + 1);
-    return 0;
+                    uint64_t cur_count) {
+  d->last_poll_data[d->last_idx] =
+      malloc(sizeof(*d->last_poll_data[d->last_idx]));
+  if (!d->last_poll_data[d->last_idx]) {
+    return -ENOMEM;
+  }
+  sstrncpy(d->last_poll_data[d->last_idx]->ds_name, ds_n,
+           sizeof(d->last_poll_data[d->last_idx]->ds_name));
+  d->last_poll_data[d->last_idx]->last_sum = cur_sum;
+  d->last_poll_data[d->last_idx]->last_count = cur_count;
+  d->last_idx = (d->last_idx + 1);
+  return 0;
 }
 
 /**
  * Update latency counter or add new entry if it doesn't exist
  */
 static int update_last(struct ceph_daemon *d, const char *ds_n, int index,
-        double cur_sum, uint64_t cur_count)
-{
-    if((d->last_idx > index) && (strcmp(d->last_poll_data[index]->ds_name, ds_n) == 0))
-    {
-        d->last_poll_data[index]->last_sum = cur_sum;
-        d->last_poll_data[index]->last_count = cur_count;
-        return 0;
-    }
+                       double cur_sum, uint64_t cur_count) {
+  if ((d->last_idx > index) &&
+      (strcmp(d->last_poll_data[index]->ds_name, ds_n) == 0)) {
+    d->last_poll_data[index]->last_sum = cur_sum;
+    d->last_poll_data[index]->last_count = cur_count;
+    return 0;
+  }
 
-    if(!d->last_poll_data)
-    {
-        d->last_poll_data = malloc(sizeof (*d->last_poll_data));
-        if(!d->last_poll_data)
-        {
-            return -ENOMEM;
-        }
+  if (!d->last_poll_data) {
+    d->last_poll_data = malloc(sizeof(*d->last_poll_data));
+    if (!d->last_poll_data) {
+      return -ENOMEM;
     }
-    else
-    {
-        struct last_data **tmp_last = realloc(d->last_poll_data,
-                ((d->last_idx+1) * sizeof(struct last_data *)));
-        if(!tmp_last)
-        {
-            return -ENOMEM;
-        }
-        d->last_poll_data = tmp_last;
+  } else {
+    struct last_data **tmp_last = realloc(
+        d->last_poll_data, ((d->last_idx + 1) * sizeof(struct last_data *)));
+    if (!tmp_last) {
+      return -ENOMEM;
     }
-    return add_last(d, ds_n, cur_sum, cur_count);
+    d->last_poll_data = tmp_last;
+  }
+  return add_last(d, ds_n, cur_sum, cur_count);
 }
 
 /**
  * If using index guess failed (shouldn't happen, but possible if counters
  * get rearranged), resort to searching for counter name
  */
-static int backup_search_for_last_avg(struct ceph_daemon *d, const char *ds_n)
-{
-    for(int i = 0; i < d->last_idx; i++)
-    {
-        if(strcmp(d->last_poll_data[i]->ds_name, ds_n) == 0)
-        {
-            return i;
-        }
+static int backup_search_for_last_avg(struct ceph_daemon *d, const char *ds_n) {
+  for (int i = 0; i < d->last_idx; i++) {
+    if (strcmp(d->last_poll_data[i]->ds_name, ds_n) == 0) {
+      return i;
     }
-    return -1;
+  }
+  return -1;
 }
 
 /**
  * Calculate average b/t current data and last poll data
  * if last poll data exists
  */
 static double get_last_avg(struct ceph_daemon *d, const char *ds_n, int index,
-        double cur_sum, uint64_t cur_count)
-{
-    double result = -1.1, sum_delt = 0.0;
-    uint64_t count_delt = 0;
-    int tmp_index = 0;
-    if(d->last_idx > index)
-    {
-        if(strcmp(d->last_poll_data[index]->ds_name, ds_n) == 0)
-        {
-            tmp_index = index;
-        }
-        //test previous index
-        else if((index > 0) && (strcmp(d->last_poll_data[index-1]->ds_name, ds_n) == 0))
-        {
-            tmp_index = (index - 1);
-        }
-        else
-        {
-            tmp_index = backup_search_for_last_avg(d, ds_n);
-        }
-
-        if((tmp_index > -1) && (cur_count > d->last_poll_data[tmp_index]->last_count))
-        {
-            sum_delt = (cur_sum - d->last_poll_data[tmp_index]->last_sum);
-            count_delt = (cur_count - d->last_poll_data[tmp_index]->last_count);
-            result = (sum_delt / count_delt);
-        }
+                           double cur_sum, uint64_t cur_count) {
+  double result = -1.1, sum_delt = 0.0;
+  uint64_t count_delt = 0;
+  int tmp_index = 0;
+  if (d->last_idx > index) {
+    if (strcmp(d->last_poll_data[index]->ds_name, ds_n) == 0) {
+      tmp_index = index;
+    }
+    // test previous index
+    else if ((index > 0) &&
+             (strcmp(d->last_poll_data[index - 1]->ds_name, ds_n) == 0)) {
+      tmp_index = (index - 1);
+    } else {
+      tmp_index = backup_search_for_last_avg(d, ds_n);
+    }
+
+    if ((tmp_index > -1) &&
+        (cur_count > d->last_poll_data[tmp_index]->last_count)) {
+      sum_delt = (cur_sum - d->last_poll_data[tmp_index]->last_sum);
+      count_delt = (cur_count - d->last_poll_data[tmp_index]->last_count);
+      result = (sum_delt / count_delt);
     }
+  }
 
-    if(result == -1.1)
-    {
-        result = NAN;
-    }
-    if(update_last(d, ds_n, tmp_index, cur_sum, cur_count) == -ENOMEM)
-    {
-        return -ENOMEM;
-    }
-    return result;
+  if (result == -1.1) {
+    result = NAN;
+  }
+  if (update_last(d, ds_n, tmp_index, cur_sum, cur_count) == -ENOMEM) {
+    return -ENOMEM;
+  }
+  return result;
 }
 
 /**
  * If using index guess failed, resort to searching for counter name
  */
-static uint32_t backup_search_for_type(struct ceph_daemon *d, char *ds_name)
-{
-    for(int i = 0; i < d->ds_num; i++)
-    {
-        if(strcmp(d->ds_names[i], ds_name) == 0)
-        {
-            return d->ds_types[i];
-        }
+static uint32_t backup_search_for_type(struct ceph_daemon *d, char *ds_name) {
+  for (int i = 0; i < d->ds_num; i++) {
+    if (strcmp(d->ds_names[i], ds_name) == 0) {
+      return d->ds_types[i];
     }
-    return DSET_TYPE_UNFOUND;
+  }
+  return DSET_TYPE_UNFOUND;
 }
 
 /**
  * Process counter data and dispatch values
  */
-static int node_handler_fetch_data(void *arg, const char *val, const char *key)
-{
-    value_t uv;
-    double tmp_d;
-    uint64_t tmp_u;
-    struct values_tmp *vtmp = (struct values_tmp*) arg;
-    uint32_t type = DSET_TYPE_UNFOUND;
-    int index = vtmp->index;
-
-    char ds_name[DATA_MAX_NAME_LEN];
-
-    if (parse_keys (ds_name, sizeof (ds_name), key))
-    {
-        return 1;
-    }
+static int node_handler_fetch_data(void *arg, const char *val,
+                                   const char *key) {
+  value_t uv;
+  double tmp_d;
+  uint64_t tmp_u;
+  struct values_tmp *vtmp = (struct values_tmp *)arg;
+  uint32_t type = DSET_TYPE_UNFOUND;
+  int index = vtmp->index;
+
+  char ds_name[DATA_MAX_NAME_LEN];
+
+  if (parse_keys(ds_name, sizeof(ds_name), key)) {
+    return 1;
+  }
 
-    if(index >= vtmp->d->ds_num)
-    {
-        //don't overflow bounds of array
-        index = (vtmp->d->ds_num - 1);
-    }
+  if (index >= vtmp->d->ds_num) {
+    // don't overflow bounds of array
+    index = (vtmp->d->ds_num - 1);
+  }
 
-    /**
-     * counters should remain in same order we parsed schema... we maintain the
-     * index variable to keep track of current point in list of counters. first
-     * use index to guess point in array for retrieving type. if that doesn't
-     * work, use the old way to get the counter type
-     */
-    if(strcmp(ds_name, vtmp->d->ds_names[index]) == 0)
-    {
-        //found match
-        type = vtmp->d->ds_types[index];
-    }
-    else if((index > 0) && (strcmp(ds_name, vtmp->d->ds_names[index-1]) == 0))
-    {
-        //try previous key
-        type = vtmp->d->ds_types[index-1];
-    }
+  /**
+   * counters should remain in same order we parsed schema... we maintain the
+   * index variable to keep track of current point in list of counters. first
+   * use index to guess point in array for retrieving type. if that doesn't
+   * work, use the old way to get the counter type
+   */
+  if (strcmp(ds_name, vtmp->d->ds_names[index]) == 0) {
+    // found match
+    type = vtmp->d->ds_types[index];
+  } else if ((index > 0) &&
+             (strcmp(ds_name, vtmp->d->ds_names[index - 1]) == 0)) {
+    // try previous key
+    type = vtmp->d->ds_types[index - 1];
+  }
 
-    if(type == DSET_TYPE_UNFOUND)
-    {
-        //couldn't find right type by guessing, check the old way
-        type = backup_search_for_type(vtmp->d, ds_name);
-    }
+  if (type == DSET_TYPE_UNFOUND) {
+    // couldn't find right type by guessing, check the old way
+    type = backup_search_for_type(vtmp->d, ds_name);
+  }
 
-    switch(type)
-    {
-        case DSET_LATENCY:
-            if(vtmp->avgcount_exists == -1)
-            {
-                sscanf(val, "%" PRIu64, &vtmp->avgcount);
-                vtmp->avgcount_exists = 0;
-                //return after saving avgcount - don't dispatch value
-                //until latency calculation
-                return 0;
-            }
-            else
-            {
-                double sum, result;
-                sscanf(val, "%lf", &sum);
-
-                if(vtmp->avgcount == 0)
-                {
-                    vtmp->avgcount = 1;
-                }
-
-                /** User wants latency values as long run avg */
-                if(long_run_latency_avg)
-                {
-                    result = (sum / vtmp->avgcount);
-                }
-                else
-                {
-                    result = get_last_avg(vtmp->d, ds_name, vtmp->latency_index, sum, vtmp->avgcount);
-                    if(result == -ENOMEM)
-                    {
-                        return -ENOMEM;
-                    }
-                }
-
-                uv.gauge = result;
-                vtmp->avgcount_exists = -1;
-                vtmp->latency_index = (vtmp->latency_index + 1);
-            }
-            break;
-        case DSET_BYTES:
-            sscanf(val, "%lf", &tmp_d);
-            uv.gauge = tmp_d;
-            break;
-        case DSET_RATE:
-            sscanf(val, "%" PRIu64, &tmp_u);
-            uv.derive = tmp_u;
-            break;
-        case DSET_TYPE_UNFOUND:
-        default:
-            ERROR("ceph plugin: ds %s was not properly initialized.", ds_name);
-            return -1;
-    }
+  switch (type) {
+  case DSET_LATENCY:
+    if (vtmp->avgcount_exists == -1) {
+      sscanf(val, "%" PRIu64, &vtmp->avgcount);
+      vtmp->avgcount_exists = 0;
+      // return after saving avgcount - don't dispatch value
+      // until latency calculation
+      return 0;
+    } else {
+      double sum, result;
+      sscanf(val, "%lf", &sum);
+
+      if (vtmp->avgcount == 0) {
+        vtmp->avgcount = 1;
+      }
+
+      /** User wants latency values as long run avg */
+      if (long_run_latency_avg) {
+        result = (sum / vtmp->avgcount);
+      } else {
+        result = get_last_avg(vtmp->d, ds_name, vtmp->latency_index, sum,
+                              vtmp->avgcount);
+        if (result == -ENOMEM) {
+          return -ENOMEM;
+        }
+      }
+
+      uv.gauge = result;
+      vtmp->avgcount_exists = -1;
+      vtmp->latency_index = (vtmp->latency_index + 1);
+    }
+    break;
+  case DSET_BYTES:
+    sscanf(val, "%lf", &tmp_d);
+    uv.gauge = tmp_d;
+    break;
+  case DSET_RATE:
+    sscanf(val, "%" PRIu64, &tmp_u);
+    uv.derive = tmp_u;
+    break;
+  case DSET_TYPE_UNFOUND:
+  default:
+    ERROR("ceph plugin: ds %s was not properly initialized.", ds_name);
+    return -1;
+  }
 
-    sstrncpy(vtmp->vlist.type, ceph_dset_types[type], sizeof(vtmp->vlist.type));
-    sstrncpy(vtmp->vlist.type_instance, ds_name, sizeof(vtmp->vlist.type_instance));
-    vtmp->vlist.values = &uv;
-    vtmp->vlist.values_len = 1;
+  sstrncpy(vtmp->vlist.type, ceph_dset_types[type], sizeof(vtmp->vlist.type));
+  sstrncpy(vtmp->vlist.type_instance, ds_name,
+           sizeof(vtmp->vlist.type_instance));
+  vtmp->vlist.values = &uv;
+  vtmp->vlist.values_len = 1;
 
-    vtmp->index = (vtmp->index + 1);
-    plugin_dispatch_values(&vtmp->vlist);
+  vtmp->index = (vtmp->index + 1);
+  plugin_dispatch_values(&vtmp->vlist);
 
-    return 0;
+  return 0;
 }
 
-static int cconn_connect(struct cconn *io)
-{
-    struct sockaddr_un address = { 0 };
-    int flags, fd, err;
-    if(io->state != CSTATE_UNCONNECTED)
-    {
-        ERROR("ceph plugin: cconn_connect: io->state != CSTATE_UNCONNECTED");
-        return -EDOM;
-    }
-    fd = socket(PF_UNIX, SOCK_STREAM, 0);
-    if(fd < 0)
-    {
-        err = -errno;
-        ERROR("ceph plugin: cconn_connect: socket(PF_UNIX, SOCK_STREAM, 0) "
-            "failed: error %d", err);
-        return err;
-    }
-    address.sun_family = AF_UNIX;
-    snprintf(address.sun_path, sizeof(address.sun_path), "%s",
-            io->d->asok_path);
-    RETRY_ON_EINTR(err,
-        connect(fd, (struct sockaddr *) &address, sizeof(struct sockaddr_un)));
-    if(err < 0)
-    {
-        ERROR("ceph plugin: cconn_connect: connect(%d) failed: error %d",
-            fd, err);
-        close(fd);
-        return err;
-    }
+static int cconn_connect(struct cconn *io) {
+  struct sockaddr_un address = {0};
+  int flags, fd, err;
+  if (io->state != CSTATE_UNCONNECTED) {
+    ERROR("ceph plugin: cconn_connect: io->state != CSTATE_UNCONNECTED");
+    return -EDOM;
+  }
+  fd = socket(PF_UNIX, SOCK_STREAM, 0);
+  if (fd < 0) {
+    err = -errno;
+    ERROR("ceph plugin: cconn_connect: socket(PF_UNIX, SOCK_STREAM, 0) "
+          "failed: error %d",
+          err);
+    return err;
+  }
+  address.sun_family = AF_UNIX;
+  snprintf(address.sun_path, sizeof(address.sun_path), "%s", io->d->asok_path);
+  RETRY_ON_EINTR(err, connect(fd, (struct sockaddr *)&address,
+                              sizeof(struct sockaddr_un)));
+  if (err < 0) {
+    ERROR("ceph plugin: cconn_connect: connect(%d) failed: error %d", fd, err);
+    close(fd);
+    return err;
+  }
 
-    flags = fcntl(fd, F_GETFL, 0);
-    if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) != 0)
-    {
-        err = -errno;
-        ERROR("ceph plugin: cconn_connect: fcntl(%d, O_NONBLOCK) error %d",
-            fd, err);
-        close(fd);
-        return err;
-    }
-    io->asok = fd;
-    io->state = CSTATE_WRITE_REQUEST;
-    io->amt = 0;
-    io->json_len = 0;
-    io->json = NULL;
-    return 0;
+  flags = fcntl(fd, F_GETFL, 0);
+  if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) != 0) {
+    err = -errno;
+    ERROR("ceph plugin: cconn_connect: fcntl(%d, O_NONBLOCK) error %d", fd,
+          err);
+    close(fd);
+    return err;
+  }
+  io->asok = fd;
+  io->state = CSTATE_WRITE_REQUEST;
+  io->amt = 0;
+  io->json_len = 0;
+  io->json = NULL;
+  return 0;
 }
 
-static void cconn_close(struct cconn *io)
-{
-    io->state = CSTATE_UNCONNECTED;
-    if(io->asok != -1)
-    {
-        int res;
-        RETRY_ON_EINTR(res, close(io->asok));
-    }
-    io->asok = -1;
-    io->amt = 0;
-    io->json_len = 0;
-    sfree(io->json);
-    io->json = NULL;
+static void cconn_close(struct cconn *io) {
+  io->state = CSTATE_UNCONNECTED;
+  if (io->asok != -1) {
+    int res;
+    RETRY_ON_EINTR(res, close(io->asok));
+  }
+  io->asok = -1;
+  io->amt = 0;
+  io->json_len = 0;
+  sfree(io->json);
+  io->json = NULL;
 }
 
 /* Process incoming JSON counter data */
-static int
-cconn_process_data(struct cconn *io, yajl_struct *yajl, yajl_handle hand)
-{
-    int ret;
-    struct values_tmp *vtmp = calloc(1, sizeof(struct values_tmp) * 1);
-    if(!vtmp)
-    {
-        return -ENOMEM;
-    }
+static int cconn_process_data(struct cconn *io, yajl_struct *yajl,
+                              yajl_handle hand) {
+  int ret;
+  struct values_tmp *vtmp = calloc(1, sizeof(struct values_tmp) * 1);
+  if (!vtmp) {
+    return -ENOMEM;
+  }
 
-    vtmp->vlist = (value_list_t)VALUE_LIST_INIT;
-    sstrncpy(vtmp->vlist.plugin, "ceph", sizeof(vtmp->vlist.plugin));
-    sstrncpy(vtmp->vlist.plugin_instance, io->d->name, sizeof(vtmp->vlist.plugin_instance));
-
-    vtmp->d = io->d;
-    vtmp->avgcount_exists = -1;
-    vtmp->latency_index = 0;
-    vtmp->index = 0;
-    yajl->handler_arg = vtmp;
-    ret = traverse_json(io->json, io->json_len, hand);
-    sfree(vtmp);
-    return ret;
+  vtmp->vlist = (value_list_t)VALUE_LIST_INIT;
+  sstrncpy(vtmp->vlist.plugin, "ceph", sizeof(vtmp->vlist.plugin));
+  sstrncpy(vtmp->vlist.plugin_instance, io->d->name,
+           sizeof(vtmp->vlist.plugin_instance));
+
+  vtmp->d = io->d;
+  vtmp->avgcount_exists = -1;
+  vtmp->latency_index = 0;
+  vtmp->index = 0;
+  yajl->handler_arg = vtmp;
+  ret = traverse_json(io->json, io->json_len, hand);
+  sfree(vtmp);
+  return ret;
 }
 
 /**
  * Initiate JSON parsing and print error if one occurs
  */
-static int cconn_process_json(struct cconn *io)
-{
-    if((io->request_type != ASOK_REQ_DATA) &&
-            (io->request_type != ASOK_REQ_SCHEMA))
-    {
-        return -EDOM;
-    }
+static int cconn_process_json(struct cconn *io) {
+  if ((io->request_type != ASOK_REQ_DATA) &&
+      (io->request_type != ASOK_REQ_SCHEMA)) {
+    return -EDOM;
+  }
 
-    int result = 1;
-    yajl_handle hand;
-    yajl_status status;
+  int result = 1;
+  yajl_handle hand;
+  yajl_status status;
 
-    hand = yajl_alloc(&callbacks,
+  hand = yajl_alloc(&callbacks,
 #if HAVE_YAJL_V2
-      /* alloc funcs = */ NULL,
+                    /* alloc funcs = */ NULL,
 #else
-      /* alloc funcs = */ NULL, NULL,
+                    /* alloc funcs = */ NULL, NULL,
 #endif
-      /* context = */ (void *)(&io->yajl));
+                    /* context = */ (void *)(&io->yajl));
 
-    if(!hand)
-    {
-        ERROR ("ceph plugin: yajl_alloc failed.");
-        return ENOMEM;
-    }
+  if (!hand) {
+    ERROR("ceph plugin: yajl_alloc failed.");
+    return ENOMEM;
+  }
 
-    io->yajl.depth = 0;
-
-    switch(io->request_type)
-    {
-        case ASOK_REQ_DATA:
-            io->yajl.handler = node_handler_fetch_data;
-            result = cconn_process_data(io, &io->yajl, hand);
-            break;
-        case ASOK_REQ_SCHEMA:
-            //init daemon specific variables
-            io->d->ds_num = 0;
-            io->d->last_idx = 0;
-            io->d->last_poll_data = NULL;
-            io->yajl.handler = node_handler_define_schema;
-            io->yajl.handler_arg = io->d;
-            result = traverse_json(io->json, io->json_len, hand);
-            break;
-    }
+  io->yajl.depth = 0;
+
+  switch (io->request_type) {
+  case ASOK_REQ_DATA:
+    io->yajl.handler = node_handler_fetch_data;
+    result = cconn_process_data(io, &io->yajl, hand);
+    break;
+  case ASOK_REQ_SCHEMA:
+    // init daemon specific variables
+    io->d->ds_num = 0;
+    io->d->last_idx = 0;
+    io->d->last_poll_data = NULL;
+    io->yajl.handler = node_handler_define_schema;
+    io->yajl.handler_arg = io->d;
+    result = traverse_json(io->json, io->json_len, hand);
+    break;
+  }
 
-    if(result)
-    {
-        goto done;
-    }
+  if (result) {
+    goto done;
+  }
 
 #if HAVE_YAJL_V2
-    status = yajl_complete_parse(hand);
+  status = yajl_complete_parse(hand);
 #else
-    status = yajl_parse_complete(hand);
+  status = yajl_parse_complete(hand);
 #endif
 
-    if (status != yajl_status_ok)
-    {
-      unsigned char *errmsg = yajl_get_error (hand, /* verbose = */ 0,
-          /* jsonText = */ NULL, /* jsonTextLen = */ 0);
-      ERROR ("ceph plugin: yajl_parse_complete failed: %s",
-          (char *) errmsg);
-      yajl_free_error (hand, errmsg);
-      yajl_free (hand);
-      return 1;
-    }
+  if (status != yajl_status_ok) {
+    unsigned char *errmsg =
+        yajl_get_error(hand, /* verbose = */ 0,
+                       /* jsonText = */ NULL, /* jsonTextLen = */ 0);
+    ERROR("ceph plugin: yajl_parse_complete failed: %s", (char *)errmsg);
+    yajl_free_error(hand, errmsg);
+    yajl_free(hand);
+    return 1;
+  }
 
-    done:
-    yajl_free (hand);
-    return result;
+done:
+  yajl_free(hand);
+  return result;
 }
 
-static int cconn_validate_revents(struct cconn *io, int revents)
-{
-    if(revents & POLLERR)
-    {
-        ERROR("ceph plugin: cconn_validate_revents(name=%s): got POLLERR",
-            io->d->name);
-        return -EIO;
-    }
-    switch (io->state)
-    {
-        case CSTATE_WRITE_REQUEST:
-            return (revents & POLLOUT) ? 0 : -EINVAL;
-        case CSTATE_READ_VERSION:
-        case CSTATE_READ_AMT:
-        case CSTATE_READ_JSON:
-            return (revents & POLLIN) ? 0 : -EINVAL;
-        default:
-            ERROR("ceph plugin: cconn_validate_revents(name=%s) got to "
-                "illegal state on line %d", io->d->name, __LINE__);
-            return -EDOM;
-    }
+static int cconn_validate_revents(struct cconn *io, int revents) {
+  if (revents & POLLERR) {
+    ERROR("ceph plugin: cconn_validate_revents(name=%s): got POLLERR",
+          io->d->name);
+    return -EIO;
+  }
+  switch (io->state) {
+  case CSTATE_WRITE_REQUEST:
+    return (revents & POLLOUT) ? 0 : -EINVAL;
+  case CSTATE_READ_VERSION:
+  case CSTATE_READ_AMT:
+  case CSTATE_READ_JSON:
+    return (revents & POLLIN) ? 0 : -EINVAL;
+  default:
+    ERROR("ceph plugin: cconn_validate_revents(name=%s) got to "
+          "illegal state on line %d",
+          io->d->name, __LINE__);
+    return -EDOM;
+  }
 }
 
 /** Handle a network event for a connection */
-static int cconn_handle_event(struct cconn *io)
-{
-    int ret;
-    switch (io->state)
-    {
-        case CSTATE_UNCONNECTED:
-            ERROR("ceph plugin: cconn_handle_event(name=%s) got to illegal "
-                "state on line %d", io->d->name, __LINE__);
-
-            return -EDOM;
-        case CSTATE_WRITE_REQUEST:
-        {
-            char cmd[32];
-            snprintf(cmd, sizeof(cmd), "%s%d%s", "{ \"prefix\": \"",
-                    io->request_type, "\" }\n");
-            size_t cmd_len = strlen(cmd);
-            RETRY_ON_EINTR(ret,
-                  write(io->asok, ((char*)&cmd) + io->amt, cmd_len - io->amt));
-            DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,amt=%d,ret=%d)",
-                    io->d->name, io->state, io->amt, ret);
-            if(ret < 0)
-            {
-                return ret;
-            }
-            io->amt += ret;
-            if(io->amt >= cmd_len)
-            {
-                io->amt = 0;
-                switch (io->request_type)
-                {
-                    case ASOK_REQ_VERSION:
-                        io->state = CSTATE_READ_VERSION;
-                        break;
-                    default:
-                        io->state = CSTATE_READ_AMT;
-                        break;
-                }
-            }
-            return 0;
-        }
-        case CSTATE_READ_VERSION:
-        {
-            RETRY_ON_EINTR(ret,
-                    read(io->asok, ((char*)(&io->d->version)) + io->amt,
-                            sizeof(io->d->version) - io->amt));
-            DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,ret=%d)",
-                    io->d->name, io->state, ret);
-            if(ret < 0)
-            {
-                return ret;
-            }
-            io->amt += ret;
-            if(io->amt >= sizeof(io->d->version))
-            {
-                io->d->version = ntohl(io->d->version);
-                if(io->d->version != 1)
-                {
-                    ERROR("ceph plugin: cconn_handle_event(name=%s) not "
-                        "expecting version %d!", io->d->name, io->d->version);
-                    return -ENOTSUP;
-                }
-                DEBUG("ceph plugin: cconn_handle_event(name=%s): identified as "
-                        "version %d", io->d->name, io->d->version);
-                io->amt = 0;
-                cconn_close(io);
-                io->request_type = ASOK_REQ_SCHEMA;
-            }
-            return 0;
-        }
-        case CSTATE_READ_AMT:
-        {
-            RETRY_ON_EINTR(ret,
-                    read(io->asok, ((char*)(&io->json_len)) + io->amt,
-                            sizeof(io->json_len) - io->amt));
-            DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,ret=%d)",
-                    io->d->name, io->state, ret);
-            if(ret < 0)
-            {
-                return ret;
-            }
-            io->amt += ret;
-            if(io->amt >= sizeof(io->json_len))
-            {
-                io->json_len = ntohl(io->json_len);
-                io->amt = 0;
-                io->state = CSTATE_READ_JSON;
-                io->json = calloc(1, io->json_len + 1);
-                if(!io->json)
-                {
-                    ERROR("ceph plugin: error callocing io->json");
-                    return -ENOMEM;
-                }
-            }
-            return 0;
-        }
-        case CSTATE_READ_JSON:
-        {
-            RETRY_ON_EINTR(ret,
+static int cconn_handle_event(struct cconn *io) {
+  int ret;
+  switch (io->state) {
+  case CSTATE_UNCONNECTED:
+    ERROR("ceph plugin: cconn_handle_event(name=%s) got to illegal "
+          "state on line %d",
+          io->d->name, __LINE__);
+
+    return -EDOM;
+  case CSTATE_WRITE_REQUEST: {
+    char cmd[32];
+    snprintf(cmd, sizeof(cmd), "%s%d%s", "{ \"prefix\": \"", io->request_type,
+             "\" }\n");
+    size_t cmd_len = strlen(cmd);
+    RETRY_ON_EINTR(
+        ret, write(io->asok, ((char *)&cmd) + io->amt, cmd_len - io->amt));
+    DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,amt=%d,ret=%d)",
+          io->d->name, io->state, io->amt, ret);
+    if (ret < 0) {
+      return ret;
+    }
+    io->amt += ret;
+    if (io->amt >= cmd_len) {
+      io->amt = 0;
+      switch (io->request_type) {
+      case ASOK_REQ_VERSION:
+        io->state = CSTATE_READ_VERSION;
+        break;
+      default:
+        io->state = CSTATE_READ_AMT;
+        break;
+      }
+    }
+    return 0;
+  }
+  case CSTATE_READ_VERSION: {
+    RETRY_ON_EINTR(ret, read(io->asok, ((char *)(&io->d->version)) + io->amt,
+                             sizeof(io->d->version) - io->amt));
+    DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,ret=%d)",
+          io->d->name, io->state, ret);
+    if (ret < 0) {
+      return ret;
+    }
+    io->amt += ret;
+    if (io->amt >= sizeof(io->d->version)) {
+      io->d->version = ntohl(io->d->version);
+      if (io->d->version != 1) {
+        ERROR("ceph plugin: cconn_handle_event(name=%s) not "
+              "expecting version %d!",
+              io->d->name, io->d->version);
+        return -ENOTSUP;
+      }
+      DEBUG("ceph plugin: cconn_handle_event(name=%s): identified as "
+            "version %d",
+            io->d->name, io->d->version);
+      io->amt = 0;
+      cconn_close(io);
+      io->request_type = ASOK_REQ_SCHEMA;
+    }
+    return 0;
+  }
+  case CSTATE_READ_AMT: {
+    RETRY_ON_EINTR(ret, read(io->asok, ((char *)(&io->json_len)) + io->amt,
+                             sizeof(io->json_len) - io->amt));
+    DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,ret=%d)",
+          io->d->name, io->state, ret);
+    if (ret < 0) {
+      return ret;
+    }
+    io->amt += ret;
+    if (io->amt >= sizeof(io->json_len)) {
+      io->json_len = ntohl(io->json_len);
+      io->amt = 0;
+      io->state = CSTATE_READ_JSON;
+      io->json = calloc(1, io->json_len + 1);
+      if (!io->json) {
+        ERROR("ceph plugin: error callocing io->json");
+        return -ENOMEM;
+      }
+    }
+    return 0;
+  }
+  case CSTATE_READ_JSON: {
+    RETRY_ON_EINTR(ret,
                    read(io->asok, io->json + io->amt, io->json_len - io->amt));
-            DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,ret=%d)",
-                    io->d->name, io->state, ret);
-            if(ret < 0)
-            {
-                return ret;
-            }
-            io->amt += ret;
-            if(io->amt >= io->json_len)
-            {
-                ret = cconn_process_json(io);
-                if(ret)
-                {
-                    return ret;
-                }
-                cconn_close(io);
-                io->request_type = ASOK_REQ_NONE;
-            }
-            return 0;
-        }
-        default:
-            ERROR("ceph plugin: cconn_handle_event(name=%s) got to illegal "
-                "state on line %d", io->d->name, __LINE__);
-            return -EDOM;
+    DEBUG("ceph plugin: cconn_handle_event(name=%s,state=%d,ret=%d)",
+          io->d->name, io->state, ret);
+    if (ret < 0) {
+      return ret;
+    }
+    io->amt += ret;
+    if (io->amt >= io->json_len) {
+      ret = cconn_process_json(io);
+      if (ret) {
+        return ret;
+      }
+      cconn_close(io);
+      io->request_type = ASOK_REQ_NONE;
     }
+    return 0;
+  }
+  default:
+    ERROR("ceph plugin: cconn_handle_event(name=%s) got to illegal "
+          "state on line %d",
+          io->d->name, __LINE__);
+    return -EDOM;
+  }
 }
 
-static int cconn_prepare(struct cconn *io, struct pollfd* fds)
-{
-    int ret;
-    if(io->request_type == ASOK_REQ_NONE)
-    {
-        /* The request has already been serviced. */
-        return 0;
-    }
-    else if((io->request_type == ASOK_REQ_DATA) && (io->d->ds_num == 0))
-    {
-        /* If there are no counters to report on, don't bother
-         * connecting */
-        return 0;
-    }
+static int cconn_prepare(struct cconn *io, struct pollfd *fds) {
+  int ret;
+  if (io->request_type == ASOK_REQ_NONE) {
+    /* The request has already been serviced. */
+    return 0;
+  } else if ((io->request_type == ASOK_REQ_DATA) && (io->d->ds_num == 0)) {
+    /* If there are no counters to report on, don't bother
+     * connecting */
+    return 0;
+  }
 
-    switch (io->state)
-    {
-        case CSTATE_UNCONNECTED:
-            ret = cconn_connect(io);
-            if(ret > 0)
-            {
-                return -ret;
-            }
-            else if(ret < 0)
-            {
-                return ret;
-            }
-            fds->fd = io->asok;
-            fds->events = POLLOUT;
-            return 1;
-        case CSTATE_WRITE_REQUEST:
-            fds->fd = io->asok;
-            fds->events = POLLOUT;
-            return 1;
-        case CSTATE_READ_VERSION:
-        case CSTATE_READ_AMT:
-        case CSTATE_READ_JSON:
-            fds->fd = io->asok;
-            fds->events = POLLIN;
-            return 1;
-        default:
-            ERROR("ceph plugin: cconn_prepare(name=%s) got to illegal state "
-                "on line %d", io->d->name, __LINE__);
-            return -EDOM;
-    }
+  switch (io->state) {
+  case CSTATE_UNCONNECTED:
+    ret = cconn_connect(io);
+    if (ret > 0) {
+      return -ret;
+    } else if (ret < 0) {
+      return ret;
+    }
+    fds->fd = io->asok;
+    fds->events = POLLOUT;
+    return 1;
+  case CSTATE_WRITE_REQUEST:
+    fds->fd = io->asok;
+    fds->events = POLLOUT;
+    return 1;
+  case CSTATE_READ_VERSION:
+  case CSTATE_READ_AMT:
+  case CSTATE_READ_JSON:
+    fds->fd = io->asok;
+    fds->events = POLLIN;
+    return 1;
+  default:
+    ERROR("ceph plugin: cconn_prepare(name=%s) got to illegal state "
+          "on line %d",
+          io->d->name, __LINE__);
+    return -EDOM;
+  }
 }
 
 /** Returns the difference between two struct timevals in milliseconds.
  * On overflow, we return max/min int.
  */
-static int milli_diff(const struct timeval *t1, const struct timeval *t2)
-{
-    int64_t ret;
-    int sec_diff = t1->tv_sec - t2->tv_sec;
-    int usec_diff = t1->tv_usec - t2->tv_usec;
-    ret = usec_diff / 1000;
-    ret += (sec_diff * 1000);
-    return (ret > INT_MAX) ? INT_MAX : ((ret < INT_MIN) ? INT_MIN : (int)ret);
+static int milli_diff(const struct timeval *t1, const struct timeval *t2) {
+  int64_t ret;
+  int sec_diff = t1->tv_sec - t2->tv_sec;
+  int usec_diff = t1->tv_usec - t2->tv_usec;
+  ret = usec_diff / 1000;
+  ret += (sec_diff * 1000);
+  return (ret > INT_MAX) ? INT_MAX : ((ret < INT_MIN) ? INT_MIN : (int)ret);
 }
 
 /** This handles the actual network I/O to talk to the Ceph daemons.
  */
-static int cconn_main_loop(uint32_t request_type)
-{
-    int ret, some_unreachable = 0;
-    struct timeval end_tv;
-    struct cconn io_array[g_num_daemons];
-
-    DEBUG ("ceph plugin: entering cconn_main_loop(request_type = %"PRIu32")", request_type);
-
-    if (g_num_daemons < 1)
-    {
-        ERROR ("ceph plugin: No daemons configured. See the \"Daemon\" config option.");
-        return ENOENT;
-    }
+static int cconn_main_loop(uint32_t request_type) {
+  int ret, some_unreachable = 0;
+  struct timeval end_tv;
+  struct cconn io_array[g_num_daemons];
+
+  DEBUG("ceph plugin: entering cconn_main_loop(request_type = %" PRIu32 ")",
+        request_type);
+
+  if (g_num_daemons < 1) {
+    ERROR("ceph plugin: No daemons configured. See the \"Daemon\" config "
+          "option.");
+    return ENOENT;
+  }
 
-    /* create cconn array */
-    for (size_t i = 0; i < g_num_daemons; i++)
-    {
-        io_array[i] = (struct cconn) {
-            .d = g_daemons[i],
-            .request_type = request_type,
-            .state = CSTATE_UNCONNECTED,
-        };
-    }
+  /* create cconn array */
+  for (size_t i = 0; i < g_num_daemons; i++) {
+    io_array[i] = (struct cconn){
+        .d = g_daemons[i],
+        .request_type = request_type,
+        .state = CSTATE_UNCONNECTED,
+    };
+  }
 
-    /** Calculate the time at which we should give up */
-    gettimeofday(&end_tv, NULL);
-    end_tv.tv_sec += CEPH_TIMEOUT_INTERVAL;
-
-    while (1)
-    {
-        int nfds, diff;
-        struct timeval tv;
-        struct cconn *polled_io_array[g_num_daemons];
-        struct pollfd fds[g_num_daemons];
-        memset(fds, 0, sizeof(fds));
-        nfds = 0;
-        for(size_t i = 0; i < g_num_daemons; ++i)
-        {
-            struct cconn *io = io_array + i;
-            ret = cconn_prepare(io, fds + nfds);
-            if(ret < 0)
-            {
-                WARNING("ceph plugin: cconn_prepare(name=%s,i=%zu,st=%d)=%d",
-                        io->d->name, i, io->state, ret);
-                cconn_close(io);
-                io->request_type = ASOK_REQ_NONE;
-                some_unreachable = 1;
-            }
-            else if(ret == 1)
-            {
-                polled_io_array[nfds++] = io_array + i;
-            }
-        }
-        if(nfds == 0)
-        {
-            /* finished */
-            ret = 0;
-            goto done;
-        }
-        gettimeofday(&tv, NULL);
-        diff = milli_diff(&end_tv, &tv);
-        if(diff <= 0)
-        {
-            /* Timed out */
-            ret = -ETIMEDOUT;
-            WARNING("ceph plugin: cconn_main_loop: timed out.");
-            goto done;
-        }
-        RETRY_ON_EINTR(ret, poll(fds, nfds, diff));
-        if(ret < 0)
-        {
-            ERROR("ceph plugin: poll(2) error: %d", ret);
-            goto done;
-        }
-        for(int i = 0; i < nfds; ++i)
-        {
-            struct cconn *io = polled_io_array[i];
-            int revents = fds[i].revents;
-            if(revents == 0)
-            {
-                /* do nothing */
-                continue;
-            }
-            else if(cconn_validate_revents(io, revents))
-            {
-                WARNING("ceph plugin: cconn(name=%s,i=%d,st=%d): "
+  /** Calculate the time at which we should give up */
+  gettimeofday(&end_tv, NULL);
+  end_tv.tv_sec += CEPH_TIMEOUT_INTERVAL;
+
+  while (1) {
+    int nfds, diff;
+    struct timeval tv;
+    struct cconn *polled_io_array[g_num_daemons];
+    struct pollfd fds[g_num_daemons];
+    memset(fds, 0, sizeof(fds));
+    nfds = 0;
+    for (size_t i = 0; i < g_num_daemons; ++i) {
+      struct cconn *io = io_array + i;
+      ret = cconn_prepare(io, fds + nfds);
+      if (ret < 0) {
+        WARNING("ceph plugin: cconn_prepare(name=%s,i=%zu,st=%d)=%d",
+                io->d->name, i, io->state, ret);
+        cconn_close(io);
+        io->request_type = ASOK_REQ_NONE;
+        some_unreachable = 1;
+      } else if (ret == 1) {
+        polled_io_array[nfds++] = io_array + i;
+      }
+    }
+    if (nfds == 0) {
+      /* finished */
+      ret = 0;
+      goto done;
+    }
+    gettimeofday(&tv, NULL);
+    diff = milli_diff(&end_tv, &tv);
+    if (diff <= 0) {
+      /* Timed out */
+      ret = -ETIMEDOUT;
+      WARNING("ceph plugin: cconn_main_loop: timed out.");
+      goto done;
+    }
+    RETRY_ON_EINTR(ret, poll(fds, nfds, diff));
+    if (ret < 0) {
+      ERROR("ceph plugin: poll(2) error: %d", ret);
+      goto done;
+    }
+    for (int i = 0; i < nfds; ++i) {
+      struct cconn *io = polled_io_array[i];
+      int revents = fds[i].revents;
+      if (revents == 0) {
+        /* do nothing */
+        continue;
+      } else if (cconn_validate_revents(io, revents)) {
+        WARNING("ceph plugin: cconn(name=%s,i=%d,st=%d): "
                 "revents validation error: "
-                "revents=0x%08x", io->d->name, i, io->state, revents);
-                cconn_close(io);
-                io->request_type = ASOK_REQ_NONE;
-                some_unreachable = 1;
-            }
-            else
-            {
-                ret = cconn_handle_event(io);
-                if(ret)
-                {
-                    WARNING("ceph plugin: cconn_handle_event(name=%s,"
-                    "i=%d,st=%d): error %d", io->d->name, i, io->state, ret);
-                    cconn_close(io);
-                    io->request_type = ASOK_REQ_NONE;
-                    some_unreachable = 1;
-                }
-            }
+                "revents=0x%08x",
+                io->d->name, i, io->state, revents);
+        cconn_close(io);
+        io->request_type = ASOK_REQ_NONE;
+        some_unreachable = 1;
+      } else {
+        ret = cconn_handle_event(io);
+        if (ret) {
+          WARNING("ceph plugin: cconn_handle_event(name=%s,"
+                  "i=%d,st=%d): error %d",
+                  io->d->name, i, io->state, ret);
+          cconn_close(io);
+          io->request_type = ASOK_REQ_NONE;
+          some_unreachable = 1;
         }
+      }
     }
-    done: for(size_t i = 0; i < g_num_daemons; ++i)
-    {
-        cconn_close(io_array + i);
-    }
-    if(some_unreachable)
-    {
-        DEBUG("ceph plugin: cconn_main_loop: some Ceph daemons were unreachable.");
-    }
-    else
-    {
-        DEBUG("ceph plugin: cconn_main_loop: reached all Ceph daemons :)");
-    }
-    return ret;
+  }
+done:
+  for (size_t i = 0; i < g_num_daemons; ++i) {
+    cconn_close(io_array + i);
+  }
+  if (some_unreachable) {
+    DEBUG("ceph plugin: cconn_main_loop: some Ceph daemons were unreachable.");
+  } else {
+    DEBUG("ceph plugin: cconn_main_loop: reached all Ceph daemons :)");
+  }
+  return ret;
 }
 
-static int ceph_read(void)
-{
-    return cconn_main_loop(ASOK_REQ_DATA);
-}
+static int ceph_read(void) { return cconn_main_loop(ASOK_REQ_DATA); }
 
 /******* lifecycle *******/
-static int ceph_init(void)
-{
+static int ceph_init(void) {
 #if defined(HAVE_SYS_CAPABILITY_H) && defined(CAP_DAC_OVERRIDE)
-  if (check_capability (CAP_DAC_OVERRIDE) != 0)
-  {
-    if (getuid () == 0)
-      WARNING ("ceph plugin: Running collectd as root, but the "
-          "CAP_DAC_OVERRIDE capability is missing. The plugin's read "
-          "function will probably fail. Is your init system dropping "
-          "capabilities?");
+  if (check_capability(CAP_DAC_OVERRIDE) != 0) {
+    if (getuid() == 0)
+      WARNING("ceph plugin: Running collectd as root, but the "
+              "CAP_DAC_OVERRIDE capability is missing. The plugin's read "
+              "function will probably fail. Is your init system dropping "
+              "capabilities?");
     else
-      WARNING ("ceph plugin: collectd doesn't have the CAP_DAC_OVERRIDE "
+      WARNING(
+          "ceph plugin: collectd doesn't have the CAP_DAC_OVERRIDE "
           "capability. If you don't want to run collectd as root, try running "
           "\"setcap cap_dac_override=ep\" on the collectd binary.");
   }
 #endif
 
-    ceph_daemons_print();
+  ceph_daemons_print();
 
-    if (g_num_daemons < 1)
-    {
-        ERROR ("ceph plugin: No daemons configured. See the \"Daemon\" config option.");
-        return ENOENT;
-    }
+  if (g_num_daemons < 1) {
+    ERROR("ceph plugin: No daemons configured. See the \"Daemon\" config "
+          "option.");
+    return ENOENT;
+  }
 
-    return cconn_main_loop(ASOK_REQ_VERSION);
+  return cconn_main_loop(ASOK_REQ_VERSION);
 }
 
-static int ceph_shutdown(void)
-{
-    for(size_t i = 0; i < g_num_daemons; ++i)
-    {
-        ceph_daemon_free(g_daemons[i]);
-    }
-    sfree(g_daemons);
-    g_daemons = NULL;
-    g_num_daemons = 0;
-    DEBUG("ceph plugin: finished ceph_shutdown");
-    return 0;
+static int ceph_shutdown(void) {
+  for (size_t i = 0; i < g_num_daemons; ++i) {
+    ceph_daemon_free(g_daemons[i]);
+  }
+  sfree(g_daemons);
+  g_daemons = NULL;
+  g_num_daemons = 0;
+  DEBUG("ceph plugin: finished ceph_shutdown");
+  return 0;
 }
 
-void module_register(void)
-{
-    plugin_register_complex_config("ceph", ceph_config);
-    plugin_register_init("ceph", ceph_init);
-    plugin_register_read("ceph", ceph_read);
-    plugin_register_shutdown("ceph", ceph_shutdown);
+void module_register(void) {
+  plugin_register_complex_config("ceph", ceph_config);
+  plugin_register_init("ceph", ceph_init);
+  plugin_register_read("ceph", ceph_read);
+  plugin_register_shutdown("ceph", ceph_shutdown);
 }
 /* vim: set sw=4 sts=4 et : */
@@ -22,48 +22,46 @@
 #include "ceph.c" /* sic */
 #include "testing.h"
 
-struct case_s
-{
+struct case_s {
   const char *key;
   const char *value;
 };
 typedef struct case_s case_t;
 
-struct test_s
-{
+struct test_s {
   case_t *cases;
-  size_t  cases_num;
+  size_t cases_num;
 };
 typedef struct test_s test_t;
 
-static int test_handler(void *user, char const *val, char const *key)
-{
+static int test_handler(void *user, char const *val, char const *key) {
   test_t *t = user;
   size_t i;
 
   char status[1024];
   _Bool ok;
 
   /* special case for latency metrics. */
-  if (strcmp ("filestore.example_latency", key) == 0)
+  if (strcmp("filestore.example_latency", key) == 0)
     return RETRY_AVGCOUNT;
 
-  snprintf (status, sizeof (status), "unexpected call: test_handler(\"%s\") = \"%s\"", key, val);
+  snprintf(status, sizeof(status),
+           "unexpected call: test_handler(\"%s\") = \"%s\"", key, val);
   ok = 0;
 
-  for (i = 0; i < t->cases_num; i++)
-  {
-    if (strcmp (key, t->cases[i].key) != 0)
+  for (i = 0; i < t->cases_num; i++) {
+    if (strcmp(key, t->cases[i].key) != 0)
       continue;
 
-    if (strcmp (val, t->cases[i].value) != 0)
-    {
-      snprintf (status, sizeof (status), "test_handler(\"%s\") = \"%s\", want \"%s\"", key, val, t->cases[i].value);
+    if (strcmp(val, t->cases[i].value) != 0) {
+      snprintf(status, sizeof(status),
+               "test_handler(\"%s\") = \"%s\", want \"%s\"", key, val,
+               t->cases[i].value);
       ok = 0;
       break;
     }
 
-    snprintf (status, sizeof (status), "test_handler(\"%s\") = \"%s\"", key, val);
+    snprintf(status, sizeof(status), "test_handler(\"%s\") = \"%s\"", key, val);
     ok = 1;
     break;
   }
@@ -72,9 +70,9 @@ static int test_handler(void *user, char const *val, char const *key)
   return ok ? 0 : -1;
 }
 
-DEF_TEST(traverse_json)
-{
-  char const *json = "{\n"
+DEF_TEST(traverse_json) {
+  char const *json =
+      "{\n"
       "    \"WBThrottle\": {\n"
       "        \"bytes_dirtied\": {\n"
       "            \"type\": 2,\n"
@@ -119,67 +117,71 @@ DEF_TEST(traverse_json)
       "    }\n"
       "}\n";
   case_t cases[] = {
-    {"WBThrottle.bytes_dirtied.type", "2"},
-    {"WBThrottle.bytes_wb.type", "2"},
-    {"WBThrottle.ios_dirtied.type", "2"},
-    {"WBThrottle.ios_wb.type", "2"},
-    {"WBThrottle.inodes_dirtied.type", "2"},
-    {"WBThrottle.inodes_wb.type", "10"},
-    {"filestore.journal_wr_bytes", "3117"},
-    {"filestore.example_latency.avgcount", "42"},
-    {"filestore.example_latency.sum", "4711"},
+      {"WBThrottle.bytes_dirtied.type", "2"},
+      {"WBThrottle.bytes_wb.type", "2"},
+      {"WBThrottle.ios_dirtied.type", "2"},
+      {"WBThrottle.ios_wb.type", "2"},
+      {"WBThrottle.inodes_dirtied.type", "2"},
+      {"WBThrottle.inodes_wb.type", "10"},
+      {"filestore.journal_wr_bytes", "3117"},
+      {"filestore.example_latency.avgcount", "42"},
+      {"filestore.example_latency.sum", "4711"},
   };
-  test_t t = {cases, STATIC_ARRAY_SIZE (cases)};
+  test_t t = {cases, STATIC_ARRAY_SIZE(cases)};
 
   yajl_struct ctx = {test_handler, &t};
 
   yajl_handle hndl;
 #if HAVE_YAJL_V2
-  hndl = yajl_alloc (&callbacks, NULL, &ctx);
-  CHECK_ZERO (traverse_json ((const unsigned char *) json, (uint32_t) strlen (json), hndl));
-  CHECK_ZERO (yajl_complete_parse (hndl));
+  hndl = yajl_alloc(&callbacks, NULL, &ctx);
+  CHECK_ZERO(
+      traverse_json((const unsigned char *)json, (uint32_t)strlen(json), hndl));
+  CHECK_ZERO(yajl_complete_parse(hndl));
 #else
-  hndl = yajl_alloc (&callbacks, NULL, NULL, &ctx);
-  CHECK_ZERO (traverse_json ((const unsigned char *) json, (uint32_t) strlen (json), hndl));
-  CHECK_ZERO (yajl_parse_complete (hndl));
+  hndl = yajl_alloc(&callbacks, NULL, NULL, &ctx);
+  CHECK_ZERO(
+      traverse_json((const unsigned char *)json, (uint32_t)strlen(json), hndl));
+  CHECK_ZERO(yajl_parse_complete(hndl));
 #endif
 
-  yajl_free (hndl);
+  yajl_free(hndl);
   return 0;
 }
 
-DEF_TEST(parse_keys)
-{
+DEF_TEST(parse_keys) {
   struct {
     const char *str;
     const char *want;
   } cases[] = {
-    {"WBThrottle.bytes_dirtied.description.bytes_wb.description.ios_dirtied.description.ios_wb.type", "WBThrottle.bytesDirtied.description.bytesWb.description.iosDirt"},
-    {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb", "Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},
-    {"foo:bar", "FooBar"},
-    {"foo:bar+", "FooBarPlus"},
-    {"foo:bar-", "FooBarMinus"},
-    {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa+", "AaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaPlus"},
-    {"aa.bb.cc.dd.ee.ff", "Aa.bb.cc.dd.ee.ff"},
-    {"aa.bb.cc.dd.ee.ff.type", "Aa.bb.cc.dd.ee.ff"},
-    {"aa.type", "Aa.type"},
-    {"WBThrottle.bytes_dirtied.type", "WBThrottle.bytesDirtied"},
+      {"WBThrottle.bytes_dirtied.description.bytes_wb.description.ios_dirtied."
+       "description.ios_wb.type",
+       "WBThrottle.bytesDirtied.description.bytesWb.description.iosDirt"},
+      {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:"
+       "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
+       "Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},
+      {"foo:bar", "FooBar"},
+      {"foo:bar+", "FooBarPlus"},
+      {"foo:bar-", "FooBarMinus"},
+      {"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa+",
+       "AaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaPlus"},
+      {"aa.bb.cc.dd.ee.ff", "Aa.bb.cc.dd.ee.ff"},
+      {"aa.bb.cc.dd.ee.ff.type", "Aa.bb.cc.dd.ee.ff"},
+      {"aa.type", "Aa.type"},
+      {"WBThrottle.bytes_dirtied.type", "WBThrottle.bytesDirtied"},
   };
   size_t i;
 
-  for (i = 0; i < STATIC_ARRAY_SIZE (cases); i++)
-  {
+  for (i = 0; i < STATIC_ARRAY_SIZE(cases); i++) {
     char got[64];
 
-    CHECK_ZERO (parse_keys (got, sizeof (got), cases[i].str));
-    EXPECT_EQ_STR (cases[i].want, got);
+    CHECK_ZERO(parse_keys(got, sizeof(got), cases[i].str));
+    EXPECT_EQ_STR(cases[i].want, got);
   }
 
   return 0;
 }
 
-int main (void)
-{
+int main(void) {
   RUN_TEST(traverse_json);
   RUN_TEST(parse_keys);
 
@@ -25,229 +25,202 @@
 
 #include "common.h"
 #include "plugin.h"
-#include "utils_mount.h"
 #include "utils_ignorelist.h"
+#include "utils_mount.h"
 
-static char const *config_keys[] =
-{
-	"CGroup",
-	"IgnoreSelected"
-};
-static int config_keys_num = STATIC_ARRAY_SIZE (config_keys);
+static char const *config_keys[] = {"CGroup", "IgnoreSelected"};
+static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
 static ignorelist_t *il_cgroup = NULL;
 
-__attribute__ ((nonnull(1)))
-__attribute__ ((nonnull(2)))
-static void cgroups_submit_one (char const *plugin_instance,
-		char const *type_instance, value_t value)
-{
-	value_list_t vl = VALUE_LIST_INIT;
-
-	vl.values = &value;
-	vl.values_len = 1;
-	sstrncpy (vl.plugin, "cgroups", sizeof (vl.plugin));
-	sstrncpy (vl.plugin_instance, plugin_instance,
-			sizeof (vl.plugin_instance));
-	sstrncpy (vl.type, "cpu", sizeof (vl.type));
-	sstrncpy (vl.type_instance, type_instance,
-			sizeof (vl.type_instance));
-
-	plugin_dispatch_values (&vl);
+__attribute__((nonnull(1))) __attribute__((nonnull(2))) static void
+cgroups_submit_one(char const *plugin_instance, char const *type_instance,
+                   value_t value) {
+  value_list_t vl = VALUE_LIST_INIT;
+
+  vl.values = &value;
+  vl.values_len = 1;
+  sstrncpy(vl.plugin, "cgroups", sizeof(vl.plugin));
+  sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
+  sstrncpy(vl.type, "cpu", sizeof(vl.type));
+  sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
+
+  plugin_dispatch_values(&vl);
 } /* void cgroups_submit_one */
 
 /*
  * This callback reads the user/system CPU time for each cgroup.
  */
-static int read_cpuacct_procs (const char *dirname, char const *cgroup_name,
-    void *user_data)
-{
-	char abs_path[PATH_MAX];
-	struct stat statbuf;
-	char buf[1024];
-	int status;
-
-	FILE *fh;
-
-	if (ignorelist_match (il_cgroup, cgroup_name))
-		return (0);
-
-	ssnprintf (abs_path, sizeof (abs_path), "%s/%s", dirname, cgroup_name);
-
-	status = lstat (abs_path, &statbuf);
-	if (status != 0)
-	{
-		ERROR ("cgroups plugin: stat (\"%s\") failed.",
-				abs_path);
-		return (-1);
-	}
-
-	/* We are only interested in directories, so skip everything else. */
-	if (!S_ISDIR (statbuf.st_mode))
-		return (0);
-
-	ssnprintf (abs_path, sizeof (abs_path), "%s/%s/cpuacct.stat",
-			dirname, cgroup_name);
-	fh = fopen (abs_path, "r");
-	if (fh == NULL)
-	{
-		char errbuf[1024];
-		ERROR ("cgroups plugin: fopen (\"%s\") failed: %s",
-				abs_path,
-				sstrerror (errno, errbuf, sizeof (errbuf)));
-		return (-1);
-	}
-
-	while (fgets (buf, sizeof (buf), fh) != NULL)
-	{
-		char *fields[8];
-		int numfields = 0;
-		char *key;
-		size_t key_len;
-		value_t value;
-
-		/* Expected format:
-		 *
-		 *   user: 12345
-		 *   system: 23456
-		 *
-		 * Or:
-		 *
-		 *   user 12345
-		 *   system 23456
-		 */
-		strstripnewline (buf);
-		numfields = strsplit (buf, fields, STATIC_ARRAY_SIZE (fields));
-		if (numfields != 2)
-			continue;
-
-		key = fields[0];
-		key_len = strlen (key);
-		if (key_len < 2)
-			continue;
-
-		/* Strip colon off the first column, if found */
-		if (key[key_len - 1] == ':')
-			key[key_len - 1] = 0;
-
-		status = parse_value (fields[1], &value, DS_TYPE_DERIVE);
-		if (status != 0)
-			continue;
-
-		cgroups_submit_one (cgroup_name, key, value);
-	}
-
-	fclose (fh);
-	return (0);
+static int read_cpuacct_procs(const char *dirname, char const *cgroup_name,
+                              void *user_data) {
+  char abs_path[PATH_MAX];
+  struct stat statbuf;
+  char buf[1024];
+  int status;
+
+  FILE *fh;
+
+  if (ignorelist_match(il_cgroup, cgroup_name))
+    return (0);
+
+  ssnprintf(abs_path, sizeof(abs_path), "%s/%s", dirname, cgroup_name);
+
+  status = lstat(abs_path, &statbuf);
+  if (status != 0) {
+    ERROR("cgroups plugin: stat (\"%s\") failed.", abs_path);
+    return (-1);
+  }
+
+  /* We are only interested in directories, so skip everything else. */
+  if (!S_ISDIR(statbuf.st_mode))
+    return (0);
+
+  ssnprintf(abs_path, sizeof(abs_path), "%s/%s/cpuacct.stat", dirname,
+            cgroup_name);
+  fh = fopen(abs_path, "r");
+  if (fh == NULL) {
+    char errbuf[1024];
+    ERROR("cgroups plugin: fopen (\"%s\") failed: %s", abs_path,
+          sstrerror(errno, errbuf, sizeof(errbuf)));
+    return (-1);
+  }
+
+  while (fgets(buf, sizeof(buf), fh) != NULL) {
+    char *fields[8];
+    int numfields = 0;
+    char *key;
+    size_t key_len;
+    value_t value;
+
+    /* Expected format:
+     *
+     *   user: 12345
+     *   system: 23456
+     *
+     * Or:
+     *
+     *   user 12345
+     *   system 23456
+     */
+    strstripnewline(buf);
+    numfields = strsplit(buf, fields, STATIC_ARRAY_SIZE(fields));
+    if (numfields != 2)
+      continue;
+
+    key = fields[0];
+    key_len = strlen(key);
+    if (key_len < 2)
+      continue;
+
+    /* Strip colon off the first column, if found */
+    if (key[key_len - 1] == ':')
+      key[key_len - 1] = 0;
+
+    status = parse_value(fields[1], &value, DS_TYPE_DERIVE);
+    if (status != 0)
+      continue;
+
+    cgroups_submit_one(cgroup_name, key, value);
+  }
+
+  fclose(fh);
+  return (0);
 } /* int read_cpuacct_procs */
 
 /*
  * Gets called for every file/folder in /sys/fs/cgroup/cpu,cpuacct (or
  * wherever cpuacct is mounted on the system). Calls walk_directory with the
  * read_cpuacct_procs callback on every folder it finds, such as "system".
  */
-static int read_cpuacct_root (const char *dirname, const char *filename,
-		void *user_data)
-{
-	char abs_path[PATH_MAX];
-	struct stat statbuf;
-	int status;
-
-	ssnprintf (abs_path, sizeof (abs_path), "%s/%s", dirname, filename);
-
-	status = lstat (abs_path, &statbuf);
-	if (status != 0)
-	{
-		ERROR ("cgroups plugin: stat (%s) failed.", abs_path);
-		return (-1);
-	}
-
-	if (S_ISDIR (statbuf.st_mode))
-	{
-		status = walk_directory (abs_path, read_cpuacct_procs,
-				/* user_data = */ NULL,
-				/* include_hidden = */ 0);
-		return (status);
-	}
-
-	return (0);
+static int read_cpuacct_root(const char *dirname, const char *filename,
+                             void *user_data) {
+  char abs_path[PATH_MAX];
+  struct stat statbuf;
+  int status;
+
+  ssnprintf(abs_path, sizeof(abs_path), "%s/%s", dirname, filename);
+
+  status = lstat(abs_path, &statbuf);
+  if (status != 0) {
+    ERROR("cgroups plugin: stat (%s) failed.", abs_path);
+    return (-1);
+  }
+
+  if (S_ISDIR(statbuf.st_mode)) {
+    status = walk_directory(abs_path, read_cpuacct_procs,
+                            /* user_data = */ NULL,
+                            /* include_hidden = */ 0);
+    return (status);
+  }
+
+  return (0);
 }
 
-static int cgroups_init (void)
-{
-	if (il_cgroup == NULL)
-		il_cgroup = ignorelist_create (1);
+static int cgroups_init(void) {
+  if (il_cgroup == NULL)
+    il_cgroup = ignorelist_create(1);
 
-	return (0);
+  return (0);
 }
 
-static int cgroups_config (const char *key, const char *value)
-{
-	cgroups_init ();
-
-	if (strcasecmp (key, "CGroup") == 0)
-	{
-		if (ignorelist_add (il_cgroup, value))
-			return (1);
-		return (0);
-	}
-	else if (strcasecmp (key, "IgnoreSelected") == 0)
-	{
-		if (IS_TRUE (value))
-			ignorelist_set_invert (il_cgroup, 0);
-		else
-			ignorelist_set_invert (il_cgroup, 1);
-		return (0);
-	}
-
-	return (-1);
+static int cgroups_config(const char *key, const char *value) {
+  cgroups_init();
+
+  if (strcasecmp(key, "CGroup") == 0) {
+    if (ignorelist_add(il_cgroup, value))
+      return (1);
+    return (0);
+  } else if (strcasecmp(key, "IgnoreSelected") == 0) {
+    if (IS_TRUE(value))
+      ignorelist_set_invert(il_cgroup, 0);
+    else
+      ignorelist_set_invert(il_cgroup, 1);
+    return (0);
+  }
+
+  return (-1);
 }
 
-static int cgroups_read (void)
-{
-	cu_mount_t *mnt_list = NULL;
-	_Bool cgroup_found = 0;
-
-	if (cu_mount_getlist (&mnt_list) == NULL)
-	{
-		ERROR ("cgroups plugin: cu_mount_getlist failed.");
-		return (-1);
-	}
-
-	for (cu_mount_t *mnt_ptr = mnt_list; mnt_ptr != NULL; mnt_ptr = mnt_ptr->next)
-	{
-		/* Find the cgroup mountpoint which contains the cpuacct
-		 * controller. */
-		if ((strcmp(mnt_ptr->type, "cgroup") != 0)
-				|| !cu_mount_checkoption(mnt_ptr->options,
-					"cpuacct", /* full = */ 1))
-			continue;
-
-		walk_directory (mnt_ptr->dir, read_cpuacct_root,
-				/* user_data = */ NULL,
-				/* include_hidden = */ 0);
-		cgroup_found = 1;
-		/* It doesn't make sense to check other cpuacct mount-points
-		 * (if any), they contain the same data. */
-		break;
-	}
-
-	cu_mount_freelist (mnt_list);
-
-	if (!cgroup_found)
-	{
-		WARNING ("cgroups plugin: Unable to find cgroup "
-				"mount-point with the \"cpuacct\" option.");
-		return (-1);
-	}
-
-	return (0);
+static int cgroups_read(void) {
+  cu_mount_t *mnt_list = NULL;
+  _Bool cgroup_found = 0;
+
+  if (cu_mount_getlist(&mnt_list) == NULL) {
+    ERROR("cgroups plugin: cu_mount_getlist failed.");
+    return (-1);
+  }
+
+  for (cu_mount_t *mnt_ptr = mnt_list; mnt_ptr != NULL;
+       mnt_ptr = mnt_ptr->next) {
+    /* Find the cgroup mountpoint which contains the cpuacct
+     * controller. */
+    if ((strcmp(mnt_ptr->type, "cgroup") != 0) ||
+        !cu_mount_checkoption(mnt_ptr->options, "cpuacct", /* full = */ 1))
+      continue;
+
+    walk_directory(mnt_ptr->dir, read_cpuacct_root,
+                   /* user_data = */ NULL,
+                   /* include_hidden = */ 0);
+    cgroup_found = 1;
+    /* It doesn't make sense to check other cpuacct mount-points
+     * (if any), they contain the same data. */
+    break;
+  }
+
+  cu_mount_freelist(mnt_list);
+
+  if (!cgroup_found) {
+    WARNING("cgroups plugin: Unable to find cgroup "
+            "mount-point with the \"cpuacct\" option.");
+    return (-1);
+  }
+
+  return (0);
 } /* int cgroup_read */
 
-void module_register (void)
-{
-	plugin_register_config ("cgroups", cgroups_config,
-			config_keys, config_keys_num);
-	plugin_register_init ("cgroups", cgroups_init);
-	plugin_register_read ("cgroups", cgroups_read);
+void module_register(void) {
+  plugin_register_config("cgroups", cgroups_config, config_keys,
+                         config_keys_num);
+  plugin_register_init("cgroups", cgroups_init);
+  plugin_register_read("cgroups", cgroups_read);
 } /* void module_register */
@@ -1,182 +1,161 @@
 /* chrony plugin for collectd (monitoring of chrony time server daemon)
  **********************************************************************
- * Copyright (C) Claudius M Zingerli, ZSeng, 2015-2016 
+ * Copyright (C) Claudius M Zingerli, ZSeng, 2015-2016
  *
  * Internals roughly based on the ntpd plugin
  * Some functions copied from chronyd/web (as marked)
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- * 
+ *
  * TODO:
  *	- More robust udp parsing (using offsets instead of structs?)
- *	  -> Currently chrony parses its data the same way as we do (using structs)
+ *	  -> Currently chrony parses its data the same way as we do (using
+ *structs)
  *	- Plausibility checks on values received
  *	  -> Done at higher levels
  */
 
 #include "collectd.h"
 
-#include "common.h"             /* auxiliary functions */
-#include "plugin.h"             /* plugin_register_*, plugin_dispatch_values */
+#include "common.h" /* auxiliary functions */
+#include "plugin.h" /* plugin_register_*, plugin_dispatch_values */
 
 #if HAVE_NETDB_H
-#  include <netdb.h>            /* struct addrinfo */
+#include <netdb.h> /* struct addrinfo */
 #endif
 #if HAVE_ARPA_INET_H
-#  include <arpa/inet.h>        /* ntohs/ntohl */
+#include <arpa/inet.h> /* ntohs/ntohl */
 #endif
 
-
-#define CONFIG_KEY_HOST    "Host"
-#define CONFIG_KEY_PORT    "Port"
+#define CONFIG_KEY_HOST "Host"
+#define CONFIG_KEY_PORT "Port"
 #define CONFIG_KEY_TIMEOUT "Timeout"
 
-#define URAND_DEVICE_PATH  "/dev/urandom"       /* Used to initialize seq nr generator */
-#define RAND_DEVICE_PATH   "/dev/random"        /* Used to initialize seq nr generator (fall back) */
-
-static const char *g_config_keys[] = {
-  CONFIG_KEY_HOST,
-  CONFIG_KEY_PORT,
-  CONFIG_KEY_TIMEOUT
-};
-
-static int       g_config_keys_num = STATIC_ARRAY_SIZE(g_config_keys);
-static int       g_chrony_is_connected;
-static int       g_chrony_socket  = -1;
-static time_t    g_chrony_timeout = -1;
-static char     *g_chrony_plugin_instance;
-static char     *g_chrony_host;
-static char     *g_chrony_port;
-static uint32_t  g_chrony_rand    = 1;
-static uint32_t  g_chrony_seq_is_initialized;
+#define URAND_DEVICE_PATH                                                      \
+  "/dev/urandom" /* Used to initialize seq nr generator */
+#define RAND_DEVICE_PATH                                                       \
+  "/dev/random" /* Used to initialize seq nr generator (fall back) */
+
+static const char *g_config_keys[] = {CONFIG_KEY_HOST, CONFIG_KEY_PORT,
+                                      CONFIG_KEY_TIMEOUT};
+
+static int g_config_keys_num = STATIC_ARRAY_SIZE(g_config_keys);
+static int g_chrony_is_connected;
+static int g_chrony_socket = -1;
+static time_t g_chrony_timeout = -1;
+static char *g_chrony_plugin_instance;
+static char *g_chrony_host;
+static char *g_chrony_port;
+static uint32_t g_chrony_rand = 1;
+static uint32_t g_chrony_seq_is_initialized;
 
 #define PLUGIN_NAME_SHORT "chrony"
-#define PLUGIN_NAME       PLUGIN_NAME_SHORT " plugin"
-#define DAEMON_NAME       PLUGIN_NAME_SHORT
+#define PLUGIN_NAME PLUGIN_NAME_SHORT " plugin"
+#define DAEMON_NAME PLUGIN_NAME_SHORT
 #define CHRONY_DEFAULT_HOST "localhost"
 #define CHRONY_DEFAULT_PORT "323"
 #define CHRONY_DEFAULT_TIMEOUT 2
 
 /* Return codes (collectd expects non-zero on errors) */
-#define CHRONY_RC_OK    0
-#define CHRONY_RC_FAIL  1
+#define CHRONY_RC_OK 0
+#define CHRONY_RC_FAIL 1
 
 /* Chronyd command packet variables adapted from chrony/candm.h (GPL2) */
 #define PROTO_VERSION_NUMBER 6
 #define IPADDR_UNSPEC 0
-#define IPADDR_INET4  1
-#define IPADDR_INET6  2
-#define IPV6_STR_MAX_SIZE (8*4+7+1)
-
-typedef enum
-{
-  PKT_TYPE_CMD_REQUEST = 1,
-  PKT_TYPE_CMD_REPLY   = 2
-} ePacketType;
-
-typedef enum
-{
-  REQ_N_SOURCES    = 14,
-  REQ_SOURCE_DATA  = 15,
-  REQ_TRACKING     = 33,
+#define IPADDR_INET4 1
+#define IPADDR_INET6 2
+#define IPV6_STR_MAX_SIZE (8 * 4 + 7 + 1)
+
+typedef enum { PKT_TYPE_CMD_REQUEST = 1, PKT_TYPE_CMD_REPLY = 2 } ePacketType;
+
+typedef enum {
+  REQ_N_SOURCES = 14,
+  REQ_SOURCE_DATA = 15,
+  REQ_TRACKING = 33,
   REQ_SOURCE_STATS = 34
 } eDaemonRequests;
 
-
-typedef enum
-{
-  RPY_NULL             = 1,
-  RPY_N_SOURCES        = 2,
-  RPY_SOURCE_DATA      = 3,
+typedef enum {
+  RPY_NULL = 1,
+  RPY_N_SOURCES = 2,
+  RPY_SOURCE_DATA = 3,
   RPY_MANUAL_TIMESTAMP = 4,
-  RPY_TRACKING         = 5,
-  RPY_SOURCE_STATS     = 6,
-  RPY_RTC              = 7
+  RPY_TRACKING = 5,
+  RPY_SOURCE_STATS = 6,
+  RPY_RTC = 7
 } eDaemonReplies;
 
-
-#if defined(__GNUC__) || defined (__SUNPRO_C) || defined(lint)
-#  /* extension to enforce struct packing. */
-#  define ATTRIB_PACKED __attribute__((packed))
+#if defined(__GNUC__) || defined(__SUNPRO_C) || defined(lint)
+#/* extension to enforce struct packing. */
+#define ATTRIB_PACKED __attribute__((packed))
 #else
-#  error Not defining packed attribute (unknown compiler)
-#  define ATTRIB_PACKED 
+#error Not defining packed attribute (unknown compiler)
+#define ATTRIB_PACKED
 #endif
 
-typedef struct ATTRIB_PACKED
-{
-  int32_t value;
-} tFloat;
+typedef struct ATTRIB_PACKED { int32_t value; } tFloat;
 
-typedef struct ATTRIB_PACKED
-{
+typedef struct ATTRIB_PACKED {
   uint32_t tv_sec_high;
   uint32_t tv_sec_low;
   uint32_t tv_nsec;
 } tTimeval;
 
-typedef enum
-{
-  STT_SUCCESS        =  0,
-  STT_FAILED         =  1,
-  STT_UNAUTH         =  2,
-  STT_INVALID        =  3,
-  STT_NOSUCHSOURCE   =  4,
-  STT_INVALIDTS      =  5,
-  STT_NOTENABLED     =  6,
-  STT_BADSUBNET      =  7,
-  STT_ACCESSALLOWED  =  8,
-  STT_ACCESSDENIED   =  9,
-  STT_NOHOSTACCESS   = 10,
+typedef enum {
+  STT_SUCCESS = 0,
+  STT_FAILED = 1,
+  STT_UNAUTH = 2,
+  STT_INVALID = 3,
+  STT_NOSUCHSOURCE = 4,
+  STT_INVALIDTS = 5,
+  STT_NOTENABLED = 6,
+  STT_BADSUBNET = 7,
+  STT_ACCESSALLOWED = 8,
+  STT_ACCESSDENIED = 9,
+  STT_NOHOSTACCESS = 10,
   STT_SOURCEALREADYKNOWN = 11,
   STT_TOOMANYSOURCES = 12,
-  STT_NORTC          = 13,
-  STT_BADRTCFILE     = 14,
-  STT_INACTIVE       = 15,
-  STT_BADSAMPLE      = 16,
-  STT_INVALIDAF      = 17,
-  STT_BADPKTVERSION  = 18,
-  STT_BADPKTLENGTH   = 19
+  STT_NORTC = 13,
+  STT_BADRTCFILE = 14,
+  STT_INACTIVE = 15,
+  STT_BADSAMPLE = 16,
+  STT_INVALIDAF = 17,
+  STT_BADPKTVERSION = 18,
+  STT_BADPKTLENGTH = 19
 } eChrony_Status;
 
 /* Chrony client request packets */
-typedef struct ATTRIB_PACKED
-{
-  uint8_t f_dummy0[80];         /* Chrony expects 80bytes dummy data (Avoiding UDP Amplification) */
+typedef struct ATTRIB_PACKED {
+  uint8_t f_dummy0[80]; /* Chrony expects 80bytes dummy data (Avoiding UDP
+                           Amplification) */
 } tChrony_Req_Tracking;
 
-typedef struct ATTRIB_PACKED
-{
-  uint32_t f_n_sources;
-} tChrony_Req_N_Sources;
+typedef struct ATTRIB_PACKED { uint32_t f_n_sources; } tChrony_Req_N_Sources;
 
-typedef struct ATTRIB_PACKED
-{
+typedef struct ATTRIB_PACKED {
   int32_t f_index;
   uint8_t f_dummy0[44];
 } tChrony_Req_Source_data;
 
-typedef struct ATTRIB_PACKED
-{
+typedef struct ATTRIB_PACKED {
   int32_t f_index;
   uint8_t f_dummy0[56];
 } tChrony_Req_Source_stats;
 
-typedef struct ATTRIB_PACKED
-{
-  struct
-  {
+typedef struct ATTRIB_PACKED {
+  struct {
     uint8_t f_version;
     uint8_t f_type;
     uint8_t f_dummy0;
@@ -187,71 +166,72 @@ typedef struct ATTRIB_PACKED
 
     uint32_t f_dummy2;
     uint32_t f_dummy3;
-  } header;                     /* Packed: 20Bytes */
-  union
-  {
+  } header; /* Packed: 20Bytes */
+  union {
     tChrony_Req_N_Sources n_sources;
     tChrony_Req_Source_data source_data;
     tChrony_Req_Source_stats source_stats;
     tChrony_Req_Tracking tracking;
   } body;
-  uint8_t padding[4 + 16];      /* Padding to match minimal response size */
+  uint8_t padding[4 + 16]; /* Padding to match minimal response size */
 } tChrony_Request;
 
 /* Chrony daemon response packets */
-typedef struct ATTRIB_PACKED
-{
-  uint32_t f_n_sources;
-} tChrony_Resp_N_Sources;
-
-typedef struct ATTRIB_PACKED
-{
-  union
-  {
+typedef struct ATTRIB_PACKED { uint32_t f_n_sources; } tChrony_Resp_N_Sources;
+
+typedef struct ATTRIB_PACKED {
+  union {
     uint32_t ip4;
     uint8_t ip6[16];
   } addr;
   uint16_t f_family;
 } tChrony_IPAddr;
 
-typedef struct ATTRIB_PACKED
-{
+typedef struct ATTRIB_PACKED {
   tChrony_IPAddr addr;
-  uint16_t dummy;               /* FIXME: Strange dummy space. Needed on gcc 4.8.3/clang 3.4.1 on x86_64 */
-  int16_t f_poll;               /* 2^f_poll = Time between polls (s) */
-  uint16_t f_stratum;           /* Remote clock stratum */
-  uint16_t f_state;             /* 0 = RPY_SD_ST_SYNC,    1 = RPY_SD_ST_UNREACH,   2 = RPY_SD_ST_FALSETICKER */
-                                /* 3 = RPY_SD_ST_JITTERY, 4 = RPY_SD_ST_CANDIDATE, 5 = RPY_SD_ST_OUTLIER     */
-  uint16_t f_mode;              /* 0 = RPY_SD_MD_CLIENT,  1 = RPY_SD_MD_PEER,      2 = RPY_SD_MD_REF         */
-  uint16_t f_flags;             /* unused */
-  uint16_t f_reachability;      /* Bit mask of successfull tries to reach the source */
-
-  uint32_t f_since_sample;      /* Time since last sample (s) */
-  tFloat f_origin_latest_meas;  /*  */
-  tFloat f_latest_meas;         /*  */
-  tFloat f_latest_meas_err;     /*  */
+  uint16_t
+      dummy; /* FIXME: Strange dummy space. Needed on gcc 4.8.3/clang 3.4.1 on
+                x86_64 */
+  int16_t f_poll;     /* 2^f_poll = Time between polls (s) */
+  uint16_t f_stratum; /* Remote clock stratum */
+  uint16_t f_state;   /* 0 = RPY_SD_ST_SYNC,    1 = RPY_SD_ST_UNREACH,   2 =
+                         RPY_SD_ST_FALSETICKER */
+  /* 3 = RPY_SD_ST_JITTERY, 4 = RPY_SD_ST_CANDIDATE, 5 = RPY_SD_ST_OUTLIER */
+  uint16_t f_mode;  /* 0 = RPY_SD_MD_CLIENT,  1 = RPY_SD_MD_PEER,      2 =
+                       RPY_SD_MD_REF         */
+  uint16_t f_flags; /* unused */
+  uint16_t
+      f_reachability; /* Bit mask of successfull tries to reach the source */
+
+  uint32_t f_since_sample;     /* Time since last sample (s) */
+  tFloat f_origin_latest_meas; /*  */
+  tFloat f_latest_meas;        /*  */
+  tFloat f_latest_meas_err;    /*  */
 } tChrony_Resp_Source_data;
 
-typedef struct ATTRIB_PACKED
-{
+typedef struct ATTRIB_PACKED {
   uint32_t f_ref_id;
   tChrony_IPAddr addr;
-  uint16_t dummy;               /* FIXME: Strange dummy space. Needed on gcc 4.8.3/clang 3.4.1 on x86_64 */
-  uint32_t f_n_samples;         /* Number of measurements done   */
-  uint32_t f_n_runs;            /* How many measurements to come */
-  uint32_t f_span_seconds;      /* For how long we're measuring  */
-  tFloat f_rtc_seconds_fast;    /* ??? */
-  tFloat f_rtc_gain_rate_ppm;   /* Estimated relative frequency error */
-  tFloat f_skew_ppm;            /* Clock skew (ppm) (worst case freq est error (skew: peak2peak)) */
-  tFloat f_est_offset;          /* Estimated offset of source */
-  tFloat f_est_offset_err;      /* Error of estimation        */
+  uint16_t
+      dummy; /* FIXME: Strange dummy space. Needed on gcc 4.8.3/clang 3.4.1 on
+                x86_64 */
+  uint32_t f_n_samples;       /* Number of measurements done   */
+  uint32_t f_n_runs;          /* How many measurements to come */
+  uint32_t f_span_seconds;    /* For how long we're measuring  */
+  tFloat f_rtc_seconds_fast;  /* ??? */
+  tFloat f_rtc_gain_rate_ppm; /* Estimated relative frequency error */
+  tFloat f_skew_ppm;       /* Clock skew (ppm) (worst case freq est error (skew:
+                              peak2peak)) */
+  tFloat f_est_offset;     /* Estimated offset of source */
+  tFloat f_est_offset_err; /* Error of estimation        */
 } tChrony_Resp_Source_stats;
 
-typedef struct ATTRIB_PACKED
-{
+typedef struct ATTRIB_PACKED {
   uint32_t f_ref_id;
   tChrony_IPAddr addr;
-  uint16_t dummy;               /* FIXME: Strange dummy space. Needed on gcc 4.8.3/clang 3.4.1 on x86_64 */
+  uint16_t
+      dummy; /* FIXME: Strange dummy space. Needed on gcc 4.8.3/clang 3.4.1 on
+                x86_64 */
   uint16_t f_stratum;
   uint16_t f_leap_status;
   tTimeval f_ref_time;
@@ -266,10 +246,8 @@ typedef struct ATTRIB_PACKED
   tFloat f_last_update_interval;
 } tChrony_Resp_Tracking;
 
-typedef struct ATTRIB_PACKED
-{
-  struct
-  {
+typedef struct ATTRIB_PACKED {
+  struct {
     uint8_t f_version;
     uint8_t f_type;
     uint8_t f_dummy0;
@@ -283,10 +261,9 @@ typedef struct ATTRIB_PACKED
     uint32_t f_seq;
     uint32_t f_dummy5;
     uint32_t f_dummy6;
-  } header;                     /* Packed: 28 Bytes */
+  } header; /* Packed: 28 Bytes */
 
-  union
-  {
+  union {
     tChrony_Resp_N_Sources n_sources;
     tChrony_Resp_Source_data source_data;
     tChrony_Resp_Source_stats source_stats;
@@ -296,44 +273,36 @@ typedef struct ATTRIB_PACKED
   uint8_t padding[1024];
 } tChrony_Response;
 
-
 /*****************************************************************************/
 /* Internal functions */
 /*****************************************************************************/
 
-/* connect_client code adapted from: http://long.ccaba.upc.edu/long/045Guidelines/eva/ipv6.html#daytimeClient6 */
-/* License granted by Eva M Castro via e-mail on 2016-02-18 under the terms of GPLv3 */
-static int
-connect_client(const char *p_hostname,
-               const char *p_service, int p_family, int p_socktype)
-{
+/* connect_client code adapted from:
+ * http://long.ccaba.upc.edu/long/045Guidelines/eva/ipv6.html#daytimeClient6 */
+/* License granted by Eva M Castro via e-mail on 2016-02-18 under the terms of
+ * GPLv3 */
+static int connect_client(const char *p_hostname, const char *p_service,
+                          int p_family, int p_socktype) {
   struct addrinfo *res, *ressave;
   int n, sockfd;
 
-  struct addrinfo ai_hints = {
-    .ai_family = p_family,
-    .ai_socktype = p_socktype
-  };
+  struct addrinfo ai_hints = {.ai_family = p_family, .ai_socktype = p_socktype};
 
   n = getaddrinfo(p_hostname, p_service, &ai_hints, &res);
 
-  if (n < 0)
-  {
+  if (n < 0) {
     ERROR(PLUGIN_NAME ": getaddrinfo error:: [%s]", gai_strerror(n));
     return -1;
   }
 
   ressave = res;
 
   sockfd = -1;
-  while (res)
-  {
+  while (res) {
     sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 
-    if (!(sockfd < 0))
-    {
-      if (connect(sockfd, res->ai_addr, res->ai_addrlen) == 0)
-      {
+    if (!(sockfd < 0)) {
+      if (connect(sockfd, res->ai_addr, res->ai_addrlen) == 0) {
         /* Success */
         break;
       }
@@ -348,18 +317,16 @@ connect_client(const char *p_hostname,
   return sockfd;
 }
 
-
-/* niptoha code originally from: git://git.tuxfamily.org/gitroot/chrony/chrony.git:util.c */
+/* niptoha code originally from:
+ * git://git.tuxfamily.org/gitroot/chrony/chrony.git:util.c */
 /* Original code licensed as GPLv2, by Richard P. Purnow, Miroslav Lichvar */
 /* Original name: char * UTI_IPToString(IPAddr *addr)*/
-static char *
-niptoha(const tChrony_IPAddr * addr, char *p_buf, size_t p_buf_size)
-{
+static char *niptoha(const tChrony_IPAddr *addr, char *p_buf,
+                     size_t p_buf_size) {
   int rc = 1;
   unsigned long a, b, c, d, ip;
 
-  switch (ntohs(addr->f_family))
-  {
+  switch (ntohs(addr->f_family)) {
   case IPADDR_UNSPEC:
     rc = snprintf(p_buf, p_buf_size, "[UNSPEC]");
     break;
@@ -371,12 +338,11 @@ niptoha(const tChrony_IPAddr * addr, char *p_buf, size_t p_buf_size)
     d = (ip >> 0) & 0xff;
     rc = snprintf(p_buf, p_buf_size, "%ld.%ld.%ld.%ld", a, b, c, d);
     break;
-  case IPADDR_INET6:
-  {
+  case IPADDR_INET6: {
     const char *rp = inet_ntop(AF_INET6, addr->addr.ip6, p_buf, p_buf_size);
-    if (rp == NULL)
-    {
-      ERROR(PLUGIN_NAME ": Error converting ipv6 address to string. Errno = %d", errno);
+    if (rp == NULL) {
+      ERROR(PLUGIN_NAME ": Error converting ipv6 address to string. Errno = %d",
+            errno);
       rc = snprintf(p_buf, p_buf_size, "[UNKNOWN]");
     }
     break;
@@ -388,159 +354,129 @@ niptoha(const tChrony_IPAddr * addr, char *p_buf, size_t p_buf_size)
   return p_buf;
 }
 
-
-static int
-chrony_set_timeout(void)
-{
-  /* Set the socket's  timeout to g_chrony_timeout; a value of 0 signals infinite timeout */
+static int chrony_set_timeout(void) {
+  /* Set the socket's  timeout to g_chrony_timeout; a value of 0 signals
+   * infinite timeout */
   /* Returns 0 on success, !0 on error (check errno) */
 
   struct timeval tv;
   tv.tv_sec = g_chrony_timeout;
   tv.tv_usec = 0;
 
   assert(g_chrony_socket >= 0);
-  if (setsockopt(g_chrony_socket, SOL_SOCKET,
-      SO_RCVTIMEO, (char *) &tv, sizeof(struct timeval)) < 0)
-  {
+  if (setsockopt(g_chrony_socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv,
+                 sizeof(struct timeval)) < 0) {
     return CHRONY_RC_FAIL;
   }
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_connect(void)
-{
+static int chrony_connect(void) {
   /* Connects to the chrony daemon */
   /* Returns 0 on success, !0 on error (check errno) */
   int socket;
 
-  if (g_chrony_host == NULL)
-  {
+  if (g_chrony_host == NULL) {
     g_chrony_host = strdup(CHRONY_DEFAULT_HOST);
-    if (g_chrony_host == NULL)
-    {
+    if (g_chrony_host == NULL) {
       ERROR(PLUGIN_NAME ": Error duplicating chrony host name");
       return CHRONY_RC_FAIL;
     }
   }
-  if (g_chrony_port == NULL)
-  {
+  if (g_chrony_port == NULL) {
     g_chrony_port = strdup(CHRONY_DEFAULT_PORT);
-    if (g_chrony_port == NULL)
-    {
+    if (g_chrony_port == NULL) {
       ERROR(PLUGIN_NAME ": Error duplicating chrony port string");
       return CHRONY_RC_FAIL;
     }
   }
-  if (g_chrony_timeout < 0)
-  {
+  if (g_chrony_timeout < 0) {
     g_chrony_timeout = CHRONY_DEFAULT_TIMEOUT;
     assert(g_chrony_timeout >= 0);
   }
 
   DEBUG(PLUGIN_NAME ": Connecting to %s:%s", g_chrony_host, g_chrony_port);
   socket = connect_client(g_chrony_host, g_chrony_port, AF_UNSPEC, SOCK_DGRAM);
-  if (socket < 0)
-  {
+  if (socket < 0) {
     ERROR(PLUGIN_NAME ": Error connecting to daemon. Errno = %d", errno);
     return CHRONY_RC_FAIL;
   }
   DEBUG(PLUGIN_NAME ": Connected");
   g_chrony_socket = socket;
 
-  if (chrony_set_timeout())
-  {
+  if (chrony_set_timeout()) {
     ERROR(PLUGIN_NAME ": Error setting timeout to %llds. Errno = %d",
           (long long)g_chrony_timeout, errno);
     return CHRONY_RC_FAIL;
   }
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_send_request(const tChrony_Request * p_req, size_t p_req_size)
-{
-  if (send(g_chrony_socket, p_req, p_req_size, 0) < 0)
-  {
+static int chrony_send_request(const tChrony_Request *p_req,
+                               size_t p_req_size) {
+  if (send(g_chrony_socket, p_req, p_req_size, 0) < 0) {
     ERROR(PLUGIN_NAME ": Error sending packet. Errno = %d", errno);
     return CHRONY_RC_FAIL;
   }
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_recv_response(tChrony_Response * p_resp, size_t p_resp_max_size,
-                     size_t * p_resp_size)
-{
+static int chrony_recv_response(tChrony_Response *p_resp,
+                                size_t p_resp_max_size, size_t *p_resp_size) {
   ssize_t rc = recv(g_chrony_socket, p_resp, p_resp_max_size, 0);
-  if (rc <= 0)
-  {
+  if (rc <= 0) {
     ERROR(PLUGIN_NAME ": Error receiving packet: %s (%d)", strerror(errno),
           errno);
     return CHRONY_RC_FAIL;
-  }
-  else
-  {
+  } else {
     *p_resp_size = rc;
     return CHRONY_RC_OK;
   }
 }
 
-
-static int
-chrony_query(const int p_command, tChrony_Request * p_req,
-             tChrony_Response * p_resp, size_t * p_resp_size)
-{
-  /* Check connection. We simply perform one try as collectd already handles retries */
+static int chrony_query(const int p_command, tChrony_Request *p_req,
+                        tChrony_Response *p_resp, size_t *p_resp_size) {
+  /* Check connection. We simply perform one try as collectd already handles
+   * retries */
   assert(p_req);
   assert(p_resp);
   assert(p_resp_size);
 
-  if (g_chrony_is_connected == 0)
-  {
-    if (chrony_connect() == CHRONY_RC_OK)
-    {
+  if (g_chrony_is_connected == 0) {
+    if (chrony_connect() == CHRONY_RC_OK) {
       g_chrony_is_connected = 1;
-    }
-    else
-    {
+    } else {
       ERROR(PLUGIN_NAME ": Unable to connect. Errno = %d", errno);
       return CHRONY_RC_FAIL;
     }
   }
 
-  do
-  {
+  do {
     int valid_command = 0;
-    size_t req_size  = sizeof(p_req->header) + sizeof(p_req->padding);
+    size_t req_size = sizeof(p_req->header) + sizeof(p_req->padding);
     size_t resp_size = sizeof(p_resp->header);
     uint16_t resp_code = RPY_NULL;
-    switch (p_command)
-    {
+    switch (p_command) {
     case REQ_TRACKING:
-      req_size  += sizeof(p_req->body.tracking);
+      req_size += sizeof(p_req->body.tracking);
       resp_size += sizeof(p_resp->body.tracking);
       resp_code = RPY_TRACKING;
       valid_command = 1;
       break;
     case REQ_N_SOURCES:
-      req_size  += sizeof(p_req->body.n_sources);
+      req_size += sizeof(p_req->body.n_sources);
       resp_size += sizeof(p_resp->body.n_sources);
       resp_code = RPY_N_SOURCES;
       valid_command = 1;
       break;
     case REQ_SOURCE_DATA:
-      req_size  += sizeof(p_req->body.source_data);
+      req_size += sizeof(p_req->body.source_data);
       resp_size += sizeof(p_resp->body.source_data);
       resp_code = RPY_SOURCE_DATA;
       valid_command = 1;
       break;
     case REQ_SOURCE_STATS:
-      req_size  += sizeof(p_req->body.source_stats);
+      req_size += sizeof(p_req->body.source_stats);
       resp_size += sizeof(p_resp->body.source_stats);
       resp_code = RPY_SOURCE_STATS;
       valid_command = 1;
@@ -567,48 +503,41 @@ chrony_query(const int p_command, tChrony_Request * p_req,
     if (chrony_recv_response(p_resp, resp_size, p_resp_size) != 0)
       break;
 
-    DEBUG(PLUGIN_NAME
-          ": Received response: .version = %u, .type = %u, .cmd = %u, .reply = %u, .status = %u, .seq = %u",
+    DEBUG(PLUGIN_NAME ": Received response: .version = %u, .type = %u, .cmd = "
+                      "%u, .reply = %u, .status = %u, .seq = %u",
           p_resp->header.f_version, p_resp->header.f_type,
           ntohs(p_resp->header.f_cmd), ntohs(p_resp->header.f_reply),
           ntohs(p_resp->header.f_status), p_resp->header.f_seq);
 
-    if (p_resp->header.f_version != p_req->header.f_version)
-    {
+    if (p_resp->header.f_version != p_req->header.f_version) {
       ERROR(PLUGIN_NAME ": Wrong protocol version (Was: %d, expected: %d)",
             p_resp->header.f_version, p_req->header.f_version);
       return CHRONY_RC_FAIL;
     }
-    if (p_resp->header.f_type != PKT_TYPE_CMD_REPLY)
-    {
+    if (p_resp->header.f_type != PKT_TYPE_CMD_REPLY) {
       ERROR(PLUGIN_NAME ": Wrong packet type (Was: %d, expected: %d)",
             p_resp->header.f_type, PKT_TYPE_CMD_REPLY);
       return CHRONY_RC_FAIL;
     }
-    if (p_resp->header.f_seq != seq_nr)
-    {
+    if (p_resp->header.f_seq != seq_nr) {
       /* FIXME: Implement sequence number handling */
-      ERROR(PLUGIN_NAME
-            ": Unexpected sequence number (Was: %d, expected: %d)",
+      ERROR(PLUGIN_NAME ": Unexpected sequence number (Was: %d, expected: %d)",
             p_resp->header.f_seq, p_req->header.f_seq);
       return CHRONY_RC_FAIL;
     }
-    if (p_resp->header.f_cmd != p_req->header.f_cmd)
-    {
+    if (p_resp->header.f_cmd != p_req->header.f_cmd) {
       ERROR(PLUGIN_NAME ": Wrong reply command (Was: %d, expected: %d)",
             p_resp->header.f_cmd, p_req->header.f_cmd);
       return CHRONY_RC_FAIL;
     }
 
-    if (ntohs(p_resp->header.f_reply) != resp_code)
-    {
+    if (ntohs(p_resp->header.f_reply) != resp_code) {
       ERROR(PLUGIN_NAME ": Wrong reply code (Was: %d, expected: %d)",
             ntohs(p_resp->header.f_reply), resp_code);
       return CHRONY_RC_FAIL;
     }
 
-    switch (p_resp->header.f_status)
-    {
+    switch (p_resp->header.f_status) {
     case STT_SUCCESS:
       DEBUG(PLUGIN_NAME ": Reply packet status STT_SUCCESS");
       break;
@@ -621,39 +550,33 @@ chrony_query(const int p_command, tChrony_Request * p_req,
 
     /* Good result */
     return CHRONY_RC_OK;
-  }
-  while (0);
+  } while (0);
 
   /* Some error occured */
   return CHRONY_RC_FAIL;
 }
 
-
-static void
-chrony_init_req(tChrony_Request * p_req)
-{
+static void chrony_init_req(tChrony_Request *p_req) {
   memset(p_req, 0, sizeof(*p_req));
   p_req->header.f_version = PROTO_VERSION_NUMBER;
-  p_req->header.f_type    = PKT_TYPE_CMD_REQUEST;
-  p_req->header.f_dummy0  = 0;
-  p_req->header.f_dummy1  = 0;
-  p_req->header.f_dummy2  = 0;
-  p_req->header.f_dummy3  = 0;
+  p_req->header.f_type = PKT_TYPE_CMD_REQUEST;
+  p_req->header.f_dummy0 = 0;
+  p_req->header.f_dummy1 = 0;
+  p_req->header.f_dummy2 = 0;
+  p_req->header.f_dummy3 = 0;
 }
 
-
-/* ntohf code originally from: git://git.tuxfamily.org/gitroot/chrony/chrony.git:util.c */
+/* ntohf code originally from:
+ * git://git.tuxfamily.org/gitroot/chrony/chrony.git:util.c */
 /* Original code licensed as GPLv2, by Richard P. Purnow, Miroslav Lichvar */
 /* Original name: double UTI_tFloatNetworkToHost(tFloat f) */
-static double
-ntohf(tFloat p_float)
-{
-  /* Convert tFloat in Network-bit-order to double in host-bit-order */
+static double ntohf(tFloat p_float) {
+/* Convert tFloat in Network-bit-order to double in host-bit-order */
 
 #define FLOAT_EXP_BITS 7
 #define FLOAT_EXP_MIN (-(1 << (FLOAT_EXP_BITS - 1)))
 #define FLOAT_EXP_MAX (-FLOAT_EXP_MIN - 1)
-#define FLOAT_COEF_BITS ((int)sizeof (int32_t) * 8 - FLOAT_EXP_BITS)
+#define FLOAT_COEF_BITS ((int)sizeof(int32_t) * 8 - FLOAT_EXP_BITS)
 #define FLOAT_COEF_MIN (-(1 << (FLOAT_COEF_BITS - 1)))
 #define FLOAT_COEF_MAX (-FLOAT_COEF_MIN - 1)
 
@@ -673,19 +596,17 @@ ntohf(tFloat p_float)
   return coef * pow(2.0, exp);
 }
 
-
-static void
-chrony_push_data(const char *p_type, const char *p_type_inst, double p_value)
-{
+static void chrony_push_data(const char *p_type, const char *p_type_inst,
+                             double p_value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  vl.values = &(value_t) { .gauge = p_value };
+  vl.values = &(value_t){.gauge = p_value};
   vl.values_len = 1;
 
-  /* XXX: Shall g_chrony_host/g_chrony_port be reflected in the plugin's output? */
+  /* XXX: Shall g_chrony_host/g_chrony_port be reflected in the plugin's output?
+   */
   sstrncpy(vl.plugin, PLUGIN_NAME_SHORT, sizeof(vl.plugin));
-  if (g_chrony_plugin_instance != NULL)
-  {
+  if (g_chrony_plugin_instance != NULL) {
     sstrncpy(vl.plugin_instance, g_chrony_plugin_instance,
              sizeof(vl.plugin_instance));
   }
@@ -698,53 +619,42 @@ chrony_push_data(const char *p_type, const char *p_type_inst, double p_value)
   plugin_dispatch_values(&vl);
 }
 
-
-static void
-chrony_push_data_valid(const char *p_type, const char *p_type_inst, const int p_is_valid,
-                       double p_value)
-{
-  /* Push real value if p_is_valid is true, push NAN if p_is_valid is not true (idea from ntp plugin) */
+static void chrony_push_data_valid(const char *p_type, const char *p_type_inst,
+                                   const int p_is_valid, double p_value) {
+  /* Push real value if p_is_valid is true, push NAN if p_is_valid is not true
+   * (idea from ntp plugin) */
   if (p_is_valid == 0)
     p_value = NAN;
 
   chrony_push_data(p_type, p_type_inst, p_value);
 }
 
-
-static int
-chrony_init_seq(void)
-{
+static int chrony_init_seq(void) {
   /* Initialize the sequence number generator from /dev/urandom */
   /* Fallbacks: /dev/random and time(NULL) */
 
   int fh;
 
   /* Try urandom */
   fh = open(URAND_DEVICE_PATH, O_RDONLY);
-  if (fh >= 0)
-  {
+  if (fh >= 0) {
     ssize_t rc = read(fh, &g_chrony_rand, sizeof(g_chrony_rand));
-    if (rc != sizeof(g_chrony_rand))
-    {
+    if (rc != sizeof(g_chrony_rand)) {
       ERROR(PLUGIN_NAME ": Reading from random source \'%s\'failed: %s (%d)",
             URAND_DEVICE_PATH, strerror(errno), errno);
       close(fh);
       return CHRONY_RC_FAIL;
     }
     close(fh);
     DEBUG(PLUGIN_NAME ": Seeding RNG from " URAND_DEVICE_PATH);
-  }
-  else
-  {
-    if (errno == ENOENT)
-    {
-      /* URAND_DEVICE_PATH device not found. Try RAND_DEVICE_PATH as fall-back */
+  } else {
+    if (errno == ENOENT) {
+      /* URAND_DEVICE_PATH device not found. Try RAND_DEVICE_PATH as fall-back
+       */
       fh = open(RAND_DEVICE_PATH, O_RDONLY);
-      if (fh >= 0)
-      {
+      if (fh >= 0) {
         ssize_t rc = read(fh, &g_chrony_rand, sizeof(g_chrony_rand));
-        if (rc != sizeof(g_chrony_rand))
-        {
+        if (rc != sizeof(g_chrony_rand)) {
           ERROR(PLUGIN_NAME
                 ": Reading from random source \'%s\'failed: %s (%d)",
                 RAND_DEVICE_PATH, strerror(errno), errno);
@@ -753,16 +663,12 @@ chrony_init_seq(void)
         }
         close(fh);
         DEBUG(PLUGIN_NAME ": Seeding RNG from " RAND_DEVICE_PATH);
-      }
-      else
-      {
+      } else {
         /* Error opening RAND_DEVICE_PATH. Try time(NULL) as fall-back */
         DEBUG(PLUGIN_NAME ": Seeding RNG from time(NULL)");
         g_chrony_rand = time(NULL) ^ getpid();
       }
-    }
-    else
-    {
+    } else {
       ERROR(PLUGIN_NAME ": Opening random source \'%s\' failed: %s (%d)",
             URAND_DEVICE_PATH, strerror(errno), errno);
       return CHRONY_RC_FAIL;
@@ -772,84 +678,73 @@ chrony_init_seq(void)
   return CHRONY_RC_OK;
 }
 
-
 /*****************************************************************************/
 /* Exported functions */
 /*****************************************************************************/
-static int
-chrony_config(const char *p_key, const char *p_value)
-{
+static int chrony_config(const char *p_key, const char *p_value) {
   assert(p_key);
   assert(p_value);
 
   /* Parse config variables */
-  if (strcasecmp(p_key, CONFIG_KEY_HOST) == 0)
-  {
+  if (strcasecmp(p_key, CONFIG_KEY_HOST) == 0) {
     if (g_chrony_host != NULL)
       free(g_chrony_host);
 
-    if ((g_chrony_host = strdup(p_value)) == NULL)
-    {
+    if ((g_chrony_host = strdup(p_value)) == NULL) {
       ERROR(PLUGIN_NAME ": Error duplicating host name");
       return CHRONY_RC_FAIL;
     }
-  }
-  else
-  {
-    if (strcasecmp(p_key, CONFIG_KEY_PORT) == 0)
-    {
+  } else {
+    if (strcasecmp(p_key, CONFIG_KEY_PORT) == 0) {
       if (g_chrony_port != NULL)
         free(g_chrony_port);
 
-      if ((g_chrony_port = strdup(p_value)) == NULL)
-      {
+      if ((g_chrony_port = strdup(p_value)) == NULL) {
         ERROR(PLUGIN_NAME ": Error duplicating port name");
         return CHRONY_RC_FAIL;
       }
-    }
-    else
-    {
-      if (strcasecmp(p_key, CONFIG_KEY_TIMEOUT) == 0)
-      {
+    } else {
+      if (strcasecmp(p_key, CONFIG_KEY_TIMEOUT) == 0) {
         time_t tosec = strtol(p_value, NULL, 0);
         g_chrony_timeout = tosec;
-      }
-      else
-      {
-        WARNING(PLUGIN_NAME ": Unknown configuration variable: %s %s", p_key, p_value);
+      } else {
+        WARNING(PLUGIN_NAME ": Unknown configuration variable: %s %s", p_key,
+                p_value);
         return CHRONY_RC_FAIL;
       }
     }
   }
-  /* XXX: We could set g_chrony_plugin_instance here to "g_chrony_host-g_chrony_port", but as multiple instances aren't yet supported, we skip this for now */
+  /* XXX: We could set g_chrony_plugin_instance here to
+   * "g_chrony_host-g_chrony_port", but as multiple instances aren't yet
+   * supported, we skip this for now */
 
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_request_daemon_stats(void)
-{
+static int chrony_request_daemon_stats(void) {
   /* Perform Tracking request */
   int rc;
   size_t chrony_resp_size;
   tChrony_Request chrony_req;
   tChrony_Response chrony_resp;
 
   chrony_init_req(&chrony_req);
-  rc =
-    chrony_query(REQ_TRACKING, &chrony_req, &chrony_resp, &chrony_resp_size);
-  if (rc != 0)
-  {
+  rc = chrony_query(REQ_TRACKING, &chrony_req, &chrony_resp, &chrony_resp_size);
+  if (rc != 0) {
     ERROR(PLUGIN_NAME ": chrony_query (REQ_TRACKING) failed with status %i",
           rc);
     return rc;
   }
 #if COLLECT_DEBUG
   {
-    char src_addr[IPV6_STR_MAX_SIZE] = { 0 };
+    char src_addr[IPV6_STR_MAX_SIZE] = {0};
     niptoha(&chrony_resp.body.tracking.addr, src_addr, sizeof(src_addr));
-    DEBUG(PLUGIN_NAME ": Daemon stat: .addr = %s, .ref_id= %u, .stratum = %u, .leap_status = %u, .ref_time = %u:%u:%u, .current_correction = %f, .last_offset = %f, .rms_offset = %f, .freq_ppm = %f, .skew_ppm = %f, .root_delay = %f, .root_dispersion = %f, .last_update_interval = %f", src_addr, ntohs(chrony_resp.body.tracking.f_ref_id),  
+    DEBUG(PLUGIN_NAME
+          ": Daemon stat: .addr = %s, .ref_id= %u, .stratum = %u, .leap_status "
+          "= %u, .ref_time = %u:%u:%u, .current_correction = %f, .last_offset "
+          "= %f, .rms_offset = %f, .freq_ppm = %f, .skew_ppm = %f, .root_delay "
+          "= %f, .root_dispersion = %f, .last_update_interval = %f",
+          src_addr, ntohs(chrony_resp.body.tracking.f_ref_id),
           ntohs(chrony_resp.body.tracking.f_stratum),
           ntohs(chrony_resp.body.tracking.f_leap_status),
           ntohl(chrony_resp.body.tracking.f_ref_time.tv_sec_high),
@@ -869,35 +764,52 @@ chrony_request_daemon_stats(void)
   double time_ref = ntohl(chrony_resp.body.tracking.f_ref_time.tv_nsec);
   time_ref /= 1000000000.0;
   time_ref += ntohl(chrony_resp.body.tracking.f_ref_time.tv_sec_low);
-  if (chrony_resp.body.tracking.f_ref_time.tv_sec_high)
-  {
-    double secs_high =
-      ntohl(chrony_resp.body.tracking.f_ref_time.tv_sec_high);
+  if (chrony_resp.body.tracking.f_ref_time.tv_sec_high) {
+    double secs_high = ntohl(chrony_resp.body.tracking.f_ref_time.tv_sec_high);
     secs_high *= 4294967296.0;
     time_ref += secs_high;
   }
 
   /* Forward results to collectd-daemon */
   /* Type_instance is always 'chrony' to tag daemon-wide data */
   /*                Type                Type_instan  Value */
-  chrony_push_data("clock_stratum",     DAEMON_NAME, ntohs(chrony_resp.body.tracking.f_stratum));
-  chrony_push_data("time_ref",          DAEMON_NAME, time_ref);  /* unit: s */
-  chrony_push_data("time_offset_ntp",   DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_current_correction));      /* Offset between system time and NTP, unit: s */
-  chrony_push_data("time_offset",       DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_last_offset)); /* Estimated Offset of the NTP time, unit: s */
-  chrony_push_data("time_offset_rms",   DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_rms_offset));  /* averaged value of the above, unit: s */
-  chrony_push_data("frequency_error",   DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_freq_ppm));    /* Frequency error of the local osc, unit: ppm */
-  chrony_push_data("clock_skew_ppm",    DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_skew_ppm));
-  chrony_push_data("root_delay",        DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_root_delay));  /* Network latency between local daemon and the current source */
-  chrony_push_data("root_dispersion",   DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_root_dispersion));
-  chrony_push_data("clock_last_update", DAEMON_NAME, ntohf(chrony_resp.body.tracking.f_last_update_interval));
+  chrony_push_data("clock_stratum", DAEMON_NAME,
+                   ntohs(chrony_resp.body.tracking.f_stratum));
+  chrony_push_data("time_ref", DAEMON_NAME, time_ref); /* unit: s */
+  chrony_push_data(
+      "time_offset_ntp", DAEMON_NAME,
+      ntohf(chrony_resp.body.tracking.f_current_correction)); /* Offset between
+                                                                 system time and
+                                                                 NTP, unit: s */
+  chrony_push_data(
+      "time_offset", DAEMON_NAME,
+      ntohf(
+          chrony_resp.body.tracking
+              .f_last_offset)); /* Estimated Offset of the NTP time, unit: s */
+  chrony_push_data(
+      "time_offset_rms", DAEMON_NAME,
+      ntohf(chrony_resp.body.tracking
+                .f_rms_offset)); /* averaged value of the above, unit: s */
+  chrony_push_data(
+      "frequency_error", DAEMON_NAME,
+      ntohf(chrony_resp.body.tracking
+                .f_freq_ppm)); /* Frequency error of the local osc, unit: ppm */
+  chrony_push_data("clock_skew_ppm", DAEMON_NAME,
+                   ntohf(chrony_resp.body.tracking.f_skew_ppm));
+  chrony_push_data(
+      "root_delay", DAEMON_NAME,
+      ntohf(chrony_resp.body.tracking.f_root_delay)); /* Network latency between
+                                                         local daemon and the
+                                                         current source */
+  chrony_push_data("root_dispersion", DAEMON_NAME,
+                   ntohf(chrony_resp.body.tracking.f_root_dispersion));
+  chrony_push_data("clock_last_update", DAEMON_NAME,
+                   ntohf(chrony_resp.body.tracking.f_last_update_interval));
 
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_request_sources_count(unsigned int *p_count)
-{
+static int chrony_request_sources_count(unsigned int *p_count) {
   /* Requests the number of time sources from the chrony daemon */
   int rc;
   size_t chrony_resp_size;
@@ -907,9 +819,8 @@ chrony_request_sources_count(unsigned int *p_count)
   DEBUG(PLUGIN_NAME ": Requesting data");
   chrony_init_req(&chrony_req);
   rc =
-    chrony_query(REQ_N_SOURCES, &chrony_req, &chrony_resp, &chrony_resp_size);
-  if (rc != 0)
-  {
+      chrony_query(REQ_N_SOURCES, &chrony_req, &chrony_resp, &chrony_resp_size);
+  if (rc != 0) {
     ERROR(PLUGIN_NAME ": chrony_query (REQ_N_SOURCES) failed with status %i",
           rc);
     return rc;
@@ -921,33 +832,30 @@ chrony_request_sources_count(unsigned int *p_count)
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_request_source_data(int p_src_idx, int *p_is_reachable)
-{
+static int chrony_request_source_data(int p_src_idx, int *p_is_reachable) {
   /* Perform Source data request for source #p_src_idx */
   int rc;
   size_t chrony_resp_size;
   tChrony_Request chrony_req;
   tChrony_Response chrony_resp;
 
-  char src_addr[IPV6_STR_MAX_SIZE] = { 0 };
+  char src_addr[IPV6_STR_MAX_SIZE] = {0};
 
   chrony_init_req(&chrony_req);
   chrony_req.body.source_data.f_index = htonl(p_src_idx);
-  rc =
-    chrony_query(REQ_SOURCE_DATA, &chrony_req, &chrony_resp,
-                 &chrony_resp_size);
-  if (rc != 0)
-  {
-    ERROR(PLUGIN_NAME
-          ": chrony_query (REQ_SOURCE_DATA) failed with status %i", rc);
+  rc = chrony_query(REQ_SOURCE_DATA, &chrony_req, &chrony_resp,
+                    &chrony_resp_size);
+  if (rc != 0) {
+    ERROR(PLUGIN_NAME ": chrony_query (REQ_SOURCE_DATA) failed with status %i",
+          rc);
     return rc;
   }
 
   niptoha(&chrony_resp.body.source_data.addr, src_addr, sizeof(src_addr));
-  DEBUG(PLUGIN_NAME
-        ": Source[%d] data: .addr = %s, .poll = %u, .stratum = %u, .state = %u, .mode = %u, .flags = %u, .reach = %u, .latest_meas_ago = %u, .orig_latest_meas = %f, .latest_meas = %f, .latest_meas_err = %f",
+  DEBUG(PLUGIN_NAME ": Source[%d] data: .addr = %s, .poll = %u, .stratum = %u, "
+                    ".state = %u, .mode = %u, .flags = %u, .reach = %u, "
+                    ".latest_meas_ago = %u, .orig_latest_meas = %f, "
+                    ".latest_meas = %f, .latest_meas_err = %f",
         p_src_idx, src_addr, ntohs(chrony_resp.body.source_data.f_poll),
         ntohs(chrony_resp.body.source_data.f_stratum),
         ntohs(chrony_resp.body.source_data.f_state),
@@ -960,8 +868,7 @@ chrony_request_source_data(int p_src_idx, int *p_is_reachable)
         ntohf(chrony_resp.body.source_data.f_latest_meas_err));
 
   /* Push NaN if source is currently not reachable */
-  int is_reachable =
-    ntohs(chrony_resp.body.source_data.f_reachability) & 0x01;
+  int is_reachable = ntohs(chrony_resp.body.source_data.f_reachability) & 0x01;
   *p_is_reachable = is_reachable;
 
   /* Forward results to collectd-daemon */
@@ -979,51 +886,44 @@ chrony_request_source_data(int p_src_idx, int *p_is_reachable)
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_request_source_stats(int p_src_idx, const int *p_is_reachable)
-{
+static int chrony_request_source_stats(int p_src_idx,
+                                       const int *p_is_reachable) {
   /* Perform Source stats request for source #p_src_idx */
   int rc;
   size_t chrony_resp_size;
   tChrony_Request chrony_req;
   tChrony_Response chrony_resp;
   double skew_ppm, frequency_error, time_offset;
 
-  char src_addr[IPV6_STR_MAX_SIZE] = { 0 };
+  char src_addr[IPV6_STR_MAX_SIZE] = {0};
 
-  if (*p_is_reachable == 0)
-  {
+  if (*p_is_reachable == 0) {
     skew_ppm = 0;
     frequency_error = 0;
     time_offset = 0;
-  }
-  else
-  {
+  } else {
     chrony_init_req(&chrony_req);
     chrony_req.body.source_stats.f_index = htonl(p_src_idx);
-    rc =
-      chrony_query(REQ_SOURCE_STATS, &chrony_req, &chrony_resp,
-                   &chrony_resp_size);
-    if (rc != 0)
-    {
+    rc = chrony_query(REQ_SOURCE_STATS, &chrony_req, &chrony_resp,
+                      &chrony_resp_size);
+    if (rc != 0) {
       ERROR(PLUGIN_NAME
-            ": chrony_query (REQ_SOURCE_STATS) failed with status %i", rc);
+            ": chrony_query (REQ_SOURCE_STATS) failed with status %i",
+            rc);
       return rc;
     }
 
     skew_ppm = ntohf(chrony_resp.body.source_stats.f_skew_ppm);
-    frequency_error =
-      ntohf(chrony_resp.body.source_stats.f_rtc_gain_rate_ppm);
+    frequency_error = ntohf(chrony_resp.body.source_stats.f_rtc_gain_rate_ppm);
     time_offset = ntohf(chrony_resp.body.source_stats.f_est_offset);
 
     niptoha(&chrony_resp.body.source_stats.addr, src_addr, sizeof(src_addr));
     DEBUG(PLUGIN_NAME
           ": Source[%d] stat: .addr = %s, .ref_id= %u, .n_samples = %u, "
           ".n_runs = %u, .span_seconds = %u, .rtc_seconds_fast = %f, "
-          ".rtc_gain_rate_ppm = %f, .skew_ppm= %f, .est_offset = %f, .est_offset_err = %f",
-          p_src_idx, src_addr,
-          ntohl(chrony_resp.body.source_stats.f_ref_id),
+          ".rtc_gain_rate_ppm = %f, .skew_ppm= %f, .est_offset = %f, "
+          ".est_offset_err = %f",
+          p_src_idx, src_addr, ntohl(chrony_resp.body.source_stats.f_ref_id),
           ntohl(chrony_resp.body.source_stats.f_n_samples),
           ntohl(chrony_resp.body.source_stats.f_n_runs),
           ntohl(chrony_resp.body.source_stats.f_span_seconds),
@@ -1035,22 +935,20 @@ chrony_request_source_stats(int p_src_idx, const int *p_is_reachable)
 
   /* Forward results to collectd-daemon */
   chrony_push_data_valid("clock_skew_ppm", src_addr, *p_is_reachable, skew_ppm);
-  chrony_push_data_valid("frequency_error", src_addr, *p_is_reachable, frequency_error); /* unit: ppm */
-  chrony_push_data_valid("time_offset", src_addr, *p_is_reachable, time_offset);         /* unit: s */
+  chrony_push_data_valid("frequency_error", src_addr, *p_is_reachable,
+                         frequency_error); /* unit: ppm */
+  chrony_push_data_valid("time_offset", src_addr, *p_is_reachable,
+                         time_offset); /* unit: s */
 
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_read(void)
-{
+static int chrony_read(void) {
   /* collectd read callback: Perform data acquisition */
   int rc;
   unsigned int n_sources;
 
-  if (g_chrony_seq_is_initialized == 0)
-  {
+  if (g_chrony_seq_is_initialized == 0) {
     /* Seed RNG for sequence number generation */
     rc = chrony_init_seq();
     if (rc != CHRONY_RC_OK)
@@ -1069,8 +967,7 @@ chrony_read(void)
   if (rc != CHRONY_RC_OK)
     return rc;
 
-  for (unsigned int now_src = 0; now_src < n_sources; ++now_src)
-  {
+  for (unsigned int now_src = 0; now_src < n_sources; ++now_src) {
     int is_reachable;
     rc = chrony_request_source_data(now_src, &is_reachable);
     if (rc != CHRONY_RC_OK)
@@ -1079,18 +976,13 @@ chrony_read(void)
     rc = chrony_request_source_stats(now_src, &is_reachable);
     if (rc != CHRONY_RC_OK)
       return rc;
-
   }
   return CHRONY_RC_OK;
 }
 
-
-static int
-chrony_shutdown(void)
-{
+static int chrony_shutdown(void) {
   /* Collectd shutdown callback: Free mem */
-  if (g_chrony_is_connected != 0)
-  {
+  if (g_chrony_is_connected != 0) {
     close(g_chrony_socket);
     g_chrony_is_connected = 0;
   }
@@ -1099,17 +991,14 @@ chrony_shutdown(void)
 
   if (g_chrony_port != NULL)
     sfree(g_chrony_port);
-  
+
   if (g_chrony_plugin_instance != NULL)
     sfree(g_chrony_plugin_instance);
-  
+
   return CHRONY_RC_OK;
 }
 
-
-void
-module_register(void)
-{
+void module_register(void) {
   plugin_register_config(PLUGIN_NAME_SHORT, chrony_config, g_config_keys,
                          g_config_keys_num);
   plugin_register_read(PLUGIN_NAME_SHORT, chrony_read);
@@ -25,69 +25,68 @@
  **/
 
 #if HAVE_CONFIG_H
-# include "config.h"
+#include "config.h"
 #endif
 
 #if !defined(__GNUC__) || !__GNUC__
-# define __attribute__(x) /**/
+#define __attribute__(x) /**/
 #endif
 
-#include <stdlib.h>
-#include <unistd.h>
-#include <stdio.h>
+#include <assert.h>
 #include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <strings.h>
-#include <assert.h>
+#include <unistd.h>
 
 #if NAN_STATIC_DEFAULT
-# include <math.h>
+#include <math.h>
 /* #endif NAN_STATIC_DEFAULT*/
 #elif NAN_STATIC_ISOC
-# ifndef __USE_ISOC99
-#  define DISABLE_ISOC99 1
-#  define __USE_ISOC99 1
-# endif /* !defined(__USE_ISOC99) */
-# include <math.h>
-# if DISABLE_ISOC99
-#  undef DISABLE_ISOC99
-#  undef __USE_ISOC99
-# endif /* DISABLE_ISOC99 */
+#ifndef __USE_ISOC99
+#define DISABLE_ISOC99 1
+#define __USE_ISOC99 1
+#endif /* !defined(__USE_ISOC99) */
+#include <math.h>
+#if DISABLE_ISOC99
+#undef DISABLE_ISOC99
+#undef __USE_ISOC99
+#endif /* DISABLE_ISOC99 */
 /* #endif NAN_STATIC_ISOC */
 #elif NAN_ZERO_ZERO
-# include <math.h>
-# ifdef NAN
-#  undef NAN
-# endif
-# define NAN (0.0 / 0.0)
-# ifndef isnan
-#  define isnan(f) ((f) != (f))
-# endif /* !defined(isnan) */
-# ifndef isfinite
-#  define isfinite(f) (((f) - (f)) == 0.0)
-# endif
-# ifndef isinf
-#  define isinf(f) (!isfinite(f) && !isnan(f))
-# endif
+#include <math.h>
+#ifdef NAN
+#undef NAN
+#endif
+#define NAN (0.0 / 0.0)
+#ifndef isnan
+#define isnan(f) ((f) != (f))
+#endif /* !defined(isnan) */
+#ifndef isfinite
+#define isfinite(f) (((f) - (f)) == 0.0)
+#endif
+#ifndef isinf
+#define isinf(f) (!isfinite(f) && !isnan(f))
+#endif
 #endif /* NAN_ZERO_ZERO */
 
 #include "libcollectdclient/collectd/client.h"
 
-#define RET_OKAY     0
-#define RET_WARNING  1
+#define RET_OKAY 0
+#define RET_WARNING 1
 #define RET_CRITICAL 2
-#define RET_UNKNOWN  3
+#define RET_UNKNOWN 3
 
-#define CON_NONE     0
-#define CON_AVERAGE  1
-#define CON_SUM      2
-#define CON_PERCENTAGE  3
+#define CON_NONE 0
+#define CON_AVERAGE 1
+#define CON_SUM 2
+#define CON_PERCENTAGE 3
 
-struct range_s
-{
-	double min;
-	double max;
-	int    invert;
+struct range_s {
+  double min;
+  double max;
+  int invert;
 };
 typedef struct range_s range_t;
 
@@ -109,631 +108,560 @@ static size_t match_ds_num_g = 0;
 /* `strdup' is an XSI extension. I don't want to pull in all of XSI just for
  * that, so here's an own implementation.. It's easy enough. The GCC attributes
  * are supposed to get good performance..  -octo */
-__attribute__((malloc, nonnull (1)))
-static char *cn_strdup (const char *str) /* {{{ */
+__attribute__((malloc, nonnull(1))) static char *
+cn_strdup(const char *str) /* {{{ */
 {
   size_t strsize;
   char *ret;
 
-  strsize = strlen (str) + 1;
-  ret = (char *) malloc (strsize);
+  strsize = strlen(str) + 1;
+  ret = (char *)malloc(strsize);
   if (ret != NULL)
-    memcpy (ret, str, strsize);
+    memcpy(ret, str, strsize);
   return (ret);
 } /* }}} char *cn_strdup */
 
-static int filter_ds (size_t *values_num,
-		double **values, char ***values_names)
-{
-	gauge_t *new_values;
-	char   **new_names;
-
-	if (match_ds_g == NULL)
-		return (RET_OKAY);
-
-	new_values = (gauge_t *)calloc (match_ds_num_g, sizeof (*new_values));
-	if (new_values == NULL)
-	{
-		fprintf (stderr, "calloc failed: %s\n", strerror (errno));
-		return (RET_UNKNOWN);
-	}
-
-	new_names = (char **)calloc (match_ds_num_g, sizeof (*new_names));
-	if (new_names == NULL)
-	{
-		fprintf (stderr, "calloc failed: %s\n", strerror (errno));
-		free (new_values);
-		return (RET_UNKNOWN);
-	}
-
-	for (size_t i = 0; i < match_ds_num_g; i++)
-	{
-		size_t j;
-
-		/* match_ds_g keeps pointers into argv but the names will be freed */
-		new_names[i] = cn_strdup (match_ds_g[i]);
-		if (new_names[i] == NULL)
-		{
-			fprintf (stderr, "cn_strdup failed: %s\n", strerror (errno));
-			free (new_values);
-			for (j = 0; j < i; j++)
-				free (new_names[j]);
-			free (new_names);
-			return (RET_UNKNOWN);
-		}
-
-		for (j = 0; j < *values_num; j++)
-			if (strcasecmp (new_names[i], (*values_names)[j]) == 0)
-				break;
-
-		if (j == *values_num)
-		{
-			printf ("ERROR: DS `%s' is not available.\n", new_names[i]);
-			free (new_values);
-			for (j = 0; j <= i; j++)
-				free (new_names[j]);
-			free (new_names);
-			return (RET_CRITICAL);
-		}
-
-		new_values[i] = (*values)[j];
-	}
-
-	free (*values);
-	for (size_t i = 0; i < *values_num; i++)
-		free ((*values_names)[i]);
-	free (*values_names);
-
-	*values       = new_values;
-	*values_names = new_names;
-	*values_num   = match_ds_num_g;
-	return (RET_OKAY);
+static int filter_ds(size_t *values_num, double **values,
+                     char ***values_names) {
+  gauge_t *new_values;
+  char **new_names;
+
+  if (match_ds_g == NULL)
+    return (RET_OKAY);
+
+  new_values = (gauge_t *)calloc(match_ds_num_g, sizeof(*new_values));
+  if (new_values == NULL) {
+    fprintf(stderr, "calloc failed: %s\n", strerror(errno));
+    return (RET_UNKNOWN);
+  }
+
+  new_names = (char **)calloc(match_ds_num_g, sizeof(*new_names));
+  if (new_names == NULL) {
+    fprintf(stderr, "calloc failed: %s\n", strerror(errno));
+    free(new_values);
+    return (RET_UNKNOWN);
+  }
+
+  for (size_t i = 0; i < match_ds_num_g; i++) {
+    size_t j;
+
+    /* match_ds_g keeps pointers into argv but the names will be freed */
+    new_names[i] = cn_strdup(match_ds_g[i]);
+    if (new_names[i] == NULL) {
+      fprintf(stderr, "cn_strdup failed: %s\n", strerror(errno));
+      free(new_values);
+      for (j = 0; j < i; j++)
+        free(new_names[j]);
+      free(new_names);
+      return (RET_UNKNOWN);
+    }
+
+    for (j = 0; j < *values_num; j++)
+      if (strcasecmp(new_names[i], (*values_names)[j]) == 0)
+        break;
+
+    if (j == *values_num) {
+      printf("ERROR: DS `%s' is not available.\n", new_names[i]);
+      free(new_values);
+      for (j = 0; j <= i; j++)
+        free(new_names[j]);
+      free(new_names);
+      return (RET_CRITICAL);
+    }
+
+    new_values[i] = (*values)[j];
+  }
+
+  free(*values);
+  for (size_t i = 0; i < *values_num; i++)
+    free((*values_names)[i]);
+  free(*values_names);
+
+  *values = new_values;
+  *values_names = new_names;
+  *values_num = match_ds_num_g;
+  return (RET_OKAY);
 } /* int filter_ds */
 
-static void parse_range (char *string, range_t *range)
-{
-	char *min_ptr;
-	char *max_ptr;
-
-	if (*string == '@')
-	{
-		range->invert = 1;
-		string++;
-	}
-
-	max_ptr = strchr (string, ':');
-	if (max_ptr == NULL)
-	{
-		min_ptr = NULL;
-		max_ptr = string;
-	}
-	else
-	{
-		min_ptr = string;
-		*max_ptr = '\0';
-		max_ptr++;
-	}
-
-	assert (max_ptr != NULL);
-
-	/* `10' == `0:10' */
-	if (min_ptr == NULL)
-		range->min = 0.0;
-	/* :10 == ~:10 == -inf:10 */
-	else if ((*min_ptr == '\0') || (*min_ptr == '~'))
-		range->min = NAN;
-	else
-		range->min = atof (min_ptr);
-
-	if ((*max_ptr == '\0') || (*max_ptr == '~'))
-		range->max = NAN;
-	else
-		range->max = atof (max_ptr);
+static void parse_range(char *string, range_t *range) {
+  char *min_ptr;
+  char *max_ptr;
+
+  if (*string == '@') {
+    range->invert = 1;
+    string++;
+  }
+
+  max_ptr = strchr(string, ':');
+  if (max_ptr == NULL) {
+    min_ptr = NULL;
+    max_ptr = string;
+  } else {
+    min_ptr = string;
+    *max_ptr = '\0';
+    max_ptr++;
+  }
+
+  assert(max_ptr != NULL);
+
+  /* `10' == `0:10' */
+  if (min_ptr == NULL)
+    range->min = 0.0;
+  /* :10 == ~:10 == -inf:10 */
+  else if ((*min_ptr == '\0') || (*min_ptr == '~'))
+    range->min = NAN;
+  else
+    range->min = atof(min_ptr);
+
+  if ((*max_ptr == '\0') || (*max_ptr == '~'))
+    range->max = NAN;
+  else
+    range->max = atof(max_ptr);
 } /* void parse_range */
 
-static int match_range (range_t *range, double value)
-{
-	int ret = 0;
+static int match_range(range_t *range, double value) {
+  int ret = 0;
 
-	if (!isnan (range->min) && (range->min > value))
-		ret = 1;
-	if (!isnan (range->max) && (range->max < value))
-		ret = 1;
+  if (!isnan(range->min) && (range->min > value))
+    ret = 1;
+  if (!isnan(range->max) && (range->max < value))
+    ret = 1;
 
-	return (((ret - range->invert) == 0) ? 0 : 1);
+  return (((ret - range->invert) == 0) ? 0 : 1);
 } /* int match_range */
 
-__attribute__((noreturn))
-static void usage (const char *name)
-{
-	fprintf (stderr, "Usage: %s <-s socket> <-n value_spec> <-H hostname> [options]\n"
-			"\n"
-			"Valid options are:\n"
-			"  -s <socket>    Path to collectd's UNIX-socket.\n"
-			"  -n <v_spec>    Value specification to get from collectd.\n"
-			"                 Format: `plugin-instance/type-instance'\n"
-			"  -d <ds>        Select the DS to examine. May be repeated to examine multiple\n"
-			"                 DSes. By default all DSes are used.\n"
-			"  -g <consol>    Method to use to consolidate several DSes.\n"
-			"                 See below for a list of valid arguments.\n"
-			"  -H <host>      Hostname to query the values for.\n"
-			"  -c <range>     Critical range\n"
-			"  -w <range>     Warning range\n"
-			"  -m             Treat \"Not a Number\" (NaN) as critical (default: warning)\n"
-			"\n"
-			"Consolidation functions:\n"
-			"  none:          Apply the warning- and critical-ranges to each data-source\n"
-			"                 individually.\n"
-			"  average:       Calculate the average of all matching DSes and apply the\n"
-			"                 warning- and critical-ranges to the calculated average.\n"
-			"  sum:           Apply the ranges to the sum of all DSes.\n"
-			"  percentage:    Apply the ranges to the ratio (in percent) of the first value\n"
-			"                 and the sum of all values."
-			"\n", name);
-	exit (1);
+__attribute__((noreturn)) static void usage(const char *name) {
+  fprintf(stderr,
+          "Usage: %s <-s socket> <-n value_spec> <-H hostname> [options]\n"
+          "\n"
+          "Valid options are:\n"
+          "  -s <socket>    Path to collectd's UNIX-socket.\n"
+          "  -n <v_spec>    Value specification to get from collectd.\n"
+          "                 Format: `plugin-instance/type-instance'\n"
+          "  -d <ds>        Select the DS to examine. May be repeated to "
+          "examine multiple\n"
+          "                 DSes. By default all DSes are used.\n"
+          "  -g <consol>    Method to use to consolidate several DSes.\n"
+          "                 See below for a list of valid arguments.\n"
+          "  -H <host>      Hostname to query the values for.\n"
+          "  -c <range>     Critical range\n"
+          "  -w <range>     Warning range\n"
+          "  -m             Treat \"Not a Number\" (NaN) as critical (default: "
+          "warning)\n"
+          "\n"
+          "Consolidation functions:\n"
+          "  none:          Apply the warning- and critical-ranges to each "
+          "data-source\n"
+          "                 individually.\n"
+          "  average:       Calculate the average of all matching DSes and "
+          "apply the\n"
+          "                 warning- and critical-ranges to the calculated "
+          "average.\n"
+          "  sum:           Apply the ranges to the sum of all DSes.\n"
+          "  percentage:    Apply the ranges to the ratio (in percent) of the "
+          "first value\n"
+          "                 and the sum of all values."
+          "\n",
+          name);
+  exit(1);
 } /* void usage */
 
-static int do_listval (lcc_connection_t *connection)
-{
-	lcc_identifier_t *ret_ident = NULL;
-	size_t ret_ident_num = 0;
-
-	char *hostname = NULL;
-
-	int status;
-
-	status = lcc_listval (connection, &ret_ident, &ret_ident_num);
-	if (status != 0) {
-		printf ("UNKNOWN: %s\n", lcc_strerror (connection));
-		if (ret_ident != NULL)
-			free (ret_ident);
-		return (RET_UNKNOWN);
-	}
-
-	status = lcc_sort_identifiers (connection, ret_ident, ret_ident_num);
-	if (status != 0) {
-		printf ("UNKNOWN: %s\n", lcc_strerror (connection));
-		if (ret_ident != NULL)
-			free (ret_ident);
-		return (RET_UNKNOWN);
-	}
-
-	for (size_t i = 0; i < ret_ident_num; ++i) {
-		char id[1024];
-
-		if ((hostname_g != NULL) && (strcasecmp (hostname_g, ret_ident[i].host)))
-			continue;
-
-		if ((hostname == NULL) || strcasecmp (hostname, ret_ident[i].host))
-		{
-			free (hostname);
-			hostname = strdup (ret_ident[i].host);
-			printf ("Host: %s\n", hostname);
-		}
-
-		/* empty hostname; not to be printed again */
-		ret_ident[i].host[0] = '\0';
-
-		status = lcc_identifier_to_string (connection,
-				id, sizeof (id), ret_ident + i);
-		if (status != 0) {
-			printf ("ERROR: listval: Failed to convert returned "
-					"identifier to a string: %s\n",
-					lcc_strerror (connection));
-			free (hostname);
-			hostname = NULL;
-			continue;
-		}
-
-		/* skip over the (empty) hostname and following '/' */
-		printf ("\t%s\n", id + 1);
-	}
-
-	free (ret_ident);
-	free (hostname);
-	return (RET_OKAY);
+static int do_listval(lcc_connection_t *connection) {
+  lcc_identifier_t *ret_ident = NULL;
+  size_t ret_ident_num = 0;
+
+  char *hostname = NULL;
+
+  int status;
+
+  status = lcc_listval(connection, &ret_ident, &ret_ident_num);
+  if (status != 0) {
+    printf("UNKNOWN: %s\n", lcc_strerror(connection));
+    if (ret_ident != NULL)
+      free(ret_ident);
+    return (RET_UNKNOWN);
+  }
+
+  status = lcc_sort_identifiers(connection, ret_ident, ret_ident_num);
+  if (status != 0) {
+    printf("UNKNOWN: %s\n", lcc_strerror(connection));
+    if (ret_ident != NULL)
+      free(ret_ident);
+    return (RET_UNKNOWN);
+  }
+
+  for (size_t i = 0; i < ret_ident_num; ++i) {
+    char id[1024];
+
+    if ((hostname_g != NULL) && (strcasecmp(hostname_g, ret_ident[i].host)))
+      continue;
+
+    if ((hostname == NULL) || strcasecmp(hostname, ret_ident[i].host)) {
+      free(hostname);
+      hostname = strdup(ret_ident[i].host);
+      printf("Host: %s\n", hostname);
+    }
+
+    /* empty hostname; not to be printed again */
+    ret_ident[i].host[0] = '\0';
+
+    status =
+        lcc_identifier_to_string(connection, id, sizeof(id), ret_ident + i);
+    if (status != 0) {
+      printf("ERROR: listval: Failed to convert returned "
+             "identifier to a string: %s\n",
+             lcc_strerror(connection));
+      free(hostname);
+      hostname = NULL;
+      continue;
+    }
+
+    /* skip over the (empty) hostname and following '/' */
+    printf("\t%s\n", id + 1);
+  }
+
+  free(ret_ident);
+  free(hostname);
+  return (RET_OKAY);
 } /* int do_listval */
 
-static int do_check_con_none (size_t values_num,
-		double *values, char **values_names)
-{
-	int num_critical = 0;
-	int num_warning  = 0;
-	int num_okay = 0;
-	const char *status_str = "UNKNOWN";
-	int status_code = RET_UNKNOWN;
-
-	for (size_t i = 0; i < values_num; i++)
-	{
-		if (isnan (values[i]))
-		{
-			if (nan_is_error_g)
-				num_critical++;
-			else
-				num_warning++;
-		}
-		else if (match_range (&range_critical_g, values[i]) != 0)
-			num_critical++;
-		else if (match_range (&range_warning_g, values[i]) != 0)
-			num_warning++;
-		else
-			num_okay++;
-	}
-
-	if ((num_critical == 0) && (num_warning == 0) && (num_okay == 0))
-	{
-		printf ("WARNING: No defined values found\n");
-		return (RET_WARNING);
-	}
-	else if ((num_critical == 0) && (num_warning == 0))
-	{
-		status_str = "OKAY";
-		status_code = RET_OKAY;
-	}
-	else if (num_critical == 0)
-	{
-		status_str = "WARNING";
-		status_code = RET_WARNING;
-	}
-	else
-	{
-		status_str = "CRITICAL";
-		status_code = RET_CRITICAL;
-	}
-
-	printf ("%s: %i critical, %i warning, %i okay", status_str,
-			num_critical, num_warning, num_okay);
-	if (values_num > 0)
-	{
-		printf (" |");
-		for (size_t i = 0; i < values_num; i++)
-			printf (" %s=%f;;;;", values_names[i], values[i]);
-	}
-	printf ("\n");
-
-	return (status_code);
+static int do_check_con_none(size_t values_num, double *values,
+                             char **values_names) {
+  int num_critical = 0;
+  int num_warning = 0;
+  int num_okay = 0;
+  const char *status_str = "UNKNOWN";
+  int status_code = RET_UNKNOWN;
+
+  for (size_t i = 0; i < values_num; i++) {
+    if (isnan(values[i])) {
+      if (nan_is_error_g)
+        num_critical++;
+      else
+        num_warning++;
+    } else if (match_range(&range_critical_g, values[i]) != 0)
+      num_critical++;
+    else if (match_range(&range_warning_g, values[i]) != 0)
+      num_warning++;
+    else
+      num_okay++;
+  }
+
+  if ((num_critical == 0) && (num_warning == 0) && (num_okay == 0)) {
+    printf("WARNING: No defined values found\n");
+    return (RET_WARNING);
+  } else if ((num_critical == 0) && (num_warning == 0)) {
+    status_str = "OKAY";
+    status_code = RET_OKAY;
+  } else if (num_critical == 0) {
+    status_str = "WARNING";
+    status_code = RET_WARNING;
+  } else {
+    status_str = "CRITICAL";
+    status_code = RET_CRITICAL;
+  }
+
+  printf("%s: %i critical, %i warning, %i okay", status_str, num_critical,
+         num_warning, num_okay);
+  if (values_num > 0) {
+    printf(" |");
+    for (size_t i = 0; i < values_num; i++)
+      printf(" %s=%f;;;;", values_names[i], values[i]);
+  }
+  printf("\n");
+
+  return (status_code);
 } /* int do_check_con_none */
 
-static int do_check_con_average (size_t values_num,
-		double *values, char **values_names)
-{
-	double total;
-	int total_num;
-	double average;
-	const char *status_str = "UNKNOWN";
-	int status_code = RET_UNKNOWN;
-
-	total = 0.0;
-	total_num = 0;
-	for (size_t i = 0; i < values_num; i++)
-	{
-		if (isnan (values[i]))
-		{
-			if (!nan_is_error_g)
-				continue;
-
-			printf ("CRITICAL: Data source \"%s\" is NaN\n",
-					values_names[i]);
-			return (RET_CRITICAL);
-		}
-
-		total += values[i];
-		total_num++;
-	}
-
-	if (total_num == 0)
-	{
-		printf ("WARNING: No defined values found\n");
-		return (RET_WARNING);
-	}
-
-	average = total / total_num;
-
-	if (match_range (&range_critical_g, average) != 0)
-	{
-		status_str = "CRITICAL";
-		status_code = RET_CRITICAL;
-	}
-	else if (match_range (&range_warning_g, average) != 0)
-	{
-		status_str = "WARNING";
-		status_code = RET_WARNING;
-	}
-	else
-	{
-		status_str = "OKAY";
-		status_code = RET_OKAY;
-	}
-
-	printf ("%s: %g average |", status_str, average);
-	for (size_t i = 0; i < values_num; i++)
-		printf (" %s=%f;;;;", values_names[i], values[i]);
-	printf ("\n");
-
-	return (status_code);
+static int do_check_con_average(size_t values_num, double *values,
+                                char **values_names) {
+  double total;
+  int total_num;
+  double average;
+  const char *status_str = "UNKNOWN";
+  int status_code = RET_UNKNOWN;
+
+  total = 0.0;
+  total_num = 0;
+  for (size_t i = 0; i < values_num; i++) {
+    if (isnan(values[i])) {
+      if (!nan_is_error_g)
+        continue;
+
+      printf("CRITICAL: Data source \"%s\" is NaN\n", values_names[i]);
+      return (RET_CRITICAL);
+    }
+
+    total += values[i];
+    total_num++;
+  }
+
+  if (total_num == 0) {
+    printf("WARNING: No defined values found\n");
+    return (RET_WARNING);
+  }
+
+  average = total / total_num;
+
+  if (match_range(&range_critical_g, average) != 0) {
+    status_str = "CRITICAL";
+    status_code = RET_CRITICAL;
+  } else if (match_range(&range_warning_g, average) != 0) {
+    status_str = "WARNING";
+    status_code = RET_WARNING;
+  } else {
+    status_str = "OKAY";
+    status_code = RET_OKAY;
+  }
+
+  printf("%s: %g average |", status_str, average);
+  for (size_t i = 0; i < values_num; i++)
+    printf(" %s=%f;;;;", values_names[i], values[i]);
+  printf("\n");
+
+  return (status_code);
 } /* int do_check_con_average */
 
-static int do_check_con_sum (size_t values_num,
-		double *values, char **values_names)
-{
-	double total;
-	int total_num;
-	const char *status_str = "UNKNOWN";
-	int status_code = RET_UNKNOWN;
-
-	total = 0.0;
-	total_num = 0;
-	for (size_t i = 0; i < values_num; i++)
-	{
-		if (isnan (values[i]))
-		{
-			if (!nan_is_error_g)
-				continue;
-
-			printf ("CRITICAL: Data source \"%s\" is NaN\n",
-					values_names[i]);
-			return (RET_CRITICAL);
-		}
-
-		total += values[i];
-		total_num++;
-	}
-
-	if (total_num == 0)
-	{
-		printf ("WARNING: No defined values found\n");
-		return (RET_WARNING);
-	}
-
-	if (match_range (&range_critical_g, total) != 0)
-	{
-		status_str = "CRITICAL";
-		status_code = RET_CRITICAL;
-	}
-	else if (match_range (&range_warning_g, total) != 0)
-	{
-		status_str = "WARNING";
-		status_code = RET_WARNING;
-	}
-	else
-	{
-		status_str = "OKAY";
-		status_code = RET_OKAY;
-	}
-
-	printf ("%s: %g sum |", status_str, total);
-	for (size_t i = 0; i < values_num; i++)
-		printf (" %s=%f;;;;", values_names[i], values[i]);
-	printf ("\n");
-
-	return (status_code);
+static int do_check_con_sum(size_t values_num, double *values,
+                            char **values_names) {
+  double total;
+  int total_num;
+  const char *status_str = "UNKNOWN";
+  int status_code = RET_UNKNOWN;
+
+  total = 0.0;
+  total_num = 0;
+  for (size_t i = 0; i < values_num; i++) {
+    if (isnan(values[i])) {
+      if (!nan_is_error_g)
+        continue;
+
+      printf("CRITICAL: Data source \"%s\" is NaN\n", values_names[i]);
+      return (RET_CRITICAL);
+    }
+
+    total += values[i];
+    total_num++;
+  }
+
+  if (total_num == 0) {
+    printf("WARNING: No defined values found\n");
+    return (RET_WARNING);
+  }
+
+  if (match_range(&range_critical_g, total) != 0) {
+    status_str = "CRITICAL";
+    status_code = RET_CRITICAL;
+  } else if (match_range(&range_warning_g, total) != 0) {
+    status_str = "WARNING";
+    status_code = RET_WARNING;
+  } else {
+    status_str = "OKAY";
+    status_code = RET_OKAY;
+  }
+
+  printf("%s: %g sum |", status_str, total);
+  for (size_t i = 0; i < values_num; i++)
+    printf(" %s=%f;;;;", values_names[i], values[i]);
+  printf("\n");
+
+  return (status_code);
 } /* int do_check_con_sum */
 
-static int do_check_con_percentage (size_t values_num,
-		double *values, char **values_names)
-{
-	double sum = 0.0;
-	double percentage;
-
-	const char *status_str  = "UNKNOWN";
-	int         status_code = RET_UNKNOWN;
-
-	if ((values_num < 1) || (isnan (values[0])))
-	{
-		printf ("WARNING: The first value is not defined\n");
-		return (RET_WARNING);
-	}
-
-	for (size_t i = 0; i < values_num; i++)
-	{
-		if (isnan (values[i]))
-		{
-			if (!nan_is_error_g)
-				continue;
-
-			printf ("CRITICAL: Data source \"%s\" is NaN\n",
-					values_names[i]);
-			return (RET_CRITICAL);
-		}
-
-		sum += values[i];
-	}
-
-	if (sum == 0.0)
-	{
-		printf ("WARNING: Values sum up to zero\n");
-		return (RET_WARNING);
-	}
-
-	percentage = 100.0 * values[0] / sum;
-
-	if (match_range (&range_critical_g, percentage) != 0)
-	{
-		status_str  = "CRITICAL";
-		status_code = RET_CRITICAL;
-	}
-	else if (match_range (&range_warning_g, percentage) != 0)
-	{
-		status_str  = "WARNING";
-		status_code = RET_WARNING;
-	}
-	else
-	{
-		status_str  = "OKAY";
-		status_code = RET_OKAY;
-	}
-
-	printf ("%s: %lf percent |", status_str, percentage);
-	for (size_t i = 0; i < values_num; i++)
-		printf (" %s=%lf;;;;", values_names[i], values[i]);
-	return (status_code);
+static int do_check_con_percentage(size_t values_num, double *values,
+                                   char **values_names) {
+  double sum = 0.0;
+  double percentage;
+
+  const char *status_str = "UNKNOWN";
+  int status_code = RET_UNKNOWN;
+
+  if ((values_num < 1) || (isnan(values[0]))) {
+    printf("WARNING: The first value is not defined\n");
+    return (RET_WARNING);
+  }
+
+  for (size_t i = 0; i < values_num; i++) {
+    if (isnan(values[i])) {
+      if (!nan_is_error_g)
+        continue;
+
+      printf("CRITICAL: Data source \"%s\" is NaN\n", values_names[i]);
+      return (RET_CRITICAL);
+    }
+
+    sum += values[i];
+  }
+
+  if (sum == 0.0) {
+    printf("WARNING: Values sum up to zero\n");
+    return (RET_WARNING);
+  }
+
+  percentage = 100.0 * values[0] / sum;
+
+  if (match_range(&range_critical_g, percentage) != 0) {
+    status_str = "CRITICAL";
+    status_code = RET_CRITICAL;
+  } else if (match_range(&range_warning_g, percentage) != 0) {
+    status_str = "WARNING";
+    status_code = RET_WARNING;
+  } else {
+    status_str = "OKAY";
+    status_code = RET_OKAY;
+  }
+
+  printf("%s: %lf percent |", status_str, percentage);
+  for (size_t i = 0; i < values_num; i++)
+    printf(" %s=%lf;;;;", values_names[i], values[i]);
+  return (status_code);
 } /* int do_check_con_percentage */
 
-static int do_check (lcc_connection_t *connection)
-{
-	gauge_t *values;
-	char   **values_names;
-	size_t   values_num;
-	char ident_str[1024];
-	lcc_identifier_t ident;
-	int status;
-
-	snprintf (ident_str, sizeof (ident_str), "%s/%s",
-			hostname_g, value_string_g);
-	ident_str[sizeof (ident_str) - 1] = 0;
-
-	status = lcc_string_to_identifier (connection, &ident, ident_str);
-	if (status != 0)
-	{
-		printf ("ERROR: Creating an identifier failed: %s.\n",
-				lcc_strerror (connection));
-		LCC_DESTROY (connection);
-		return (RET_CRITICAL);
-	}
-
-	status = lcc_getval (connection, &ident,
-			&values_num, &values, &values_names);
-	if (status != 0)
-	{
-		printf ("ERROR: Retrieving values from the daemon failed: %s.\n",
-				lcc_strerror (connection));
-		LCC_DESTROY (connection);
-		return (RET_CRITICAL);
-	}
-
-	LCC_DESTROY (connection);
-
-	status = filter_ds (&values_num, &values, &values_names);
-	if (status != RET_OKAY)
-		return (status);
-
-	status = RET_UNKNOWN;
-	if (consolitation_g == CON_NONE)
-		status = do_check_con_none (values_num, values, values_names);
-	else if (consolitation_g == CON_AVERAGE)
-		status = do_check_con_average (values_num, values, values_names);
-	else if (consolitation_g == CON_SUM)
-		status = do_check_con_sum (values_num, values, values_names);
-	else if (consolitation_g == CON_PERCENTAGE)
-		status = do_check_con_percentage (values_num, values, values_names);
-
-	free (values);
-	if (values_names != NULL)
-		for (size_t i = 0; i < values_num; i++)
-			free (values_names[i]);
-	free (values_names);
-
-	return (status);
+static int do_check(lcc_connection_t *connection) {
+  gauge_t *values;
+  char **values_names;
+  size_t values_num;
+  char ident_str[1024];
+  lcc_identifier_t ident;
+  int status;
+
+  snprintf(ident_str, sizeof(ident_str), "%s/%s", hostname_g, value_string_g);
+  ident_str[sizeof(ident_str) - 1] = 0;
+
+  status = lcc_string_to_identifier(connection, &ident, ident_str);
+  if (status != 0) {
+    printf("ERROR: Creating an identifier failed: %s.\n",
+           lcc_strerror(connection));
+    LCC_DESTROY(connection);
+    return (RET_CRITICAL);
+  }
+
+  status = lcc_getval(connection, &ident, &values_num, &values, &values_names);
+  if (status != 0) {
+    printf("ERROR: Retrieving values from the daemon failed: %s.\n",
+           lcc_strerror(connection));
+    LCC_DESTROY(connection);
+    return (RET_CRITICAL);
+  }
+
+  LCC_DESTROY(connection);
+
+  status = filter_ds(&values_num, &values, &values_names);
+  if (status != RET_OKAY)
+    return (status);
+
+  status = RET_UNKNOWN;
+  if (consolitation_g == CON_NONE)
+    status = do_check_con_none(values_num, values, values_names);
+  else if (consolitation_g == CON_AVERAGE)
+    status = do_check_con_average(values_num, values, values_names);
+  else if (consolitation_g == CON_SUM)
+    status = do_check_con_sum(values_num, values, values_names);
+  else if (consolitation_g == CON_PERCENTAGE)
+    status = do_check_con_percentage(values_num, values, values_names);
+
+  free(values);
+  if (values_names != NULL)
+    for (size_t i = 0; i < values_num; i++)
+      free(values_names[i]);
+  free(values_names);
+
+  return (status);
 } /* int do_check */
 
-int main (int argc, char **argv)
-{
-	char address[1024];
-	lcc_connection_t *connection;
-
-	int status;
-
-	range_critical_g.min = NAN;
-	range_critical_g.max = NAN;
-	range_critical_g.invert = 0;
-
-	range_warning_g.min = NAN;
-	range_warning_g.max = NAN;
-	range_warning_g.invert = 0;
-
-	while (42)
-	{
-		int c;
-
-		c = getopt (argc, argv, "w:c:s:n:H:g:d:hm");
-		if (c < 0)
-			break;
-
-		switch (c)
-		{
-			case 'c':
-				parse_range (optarg, &range_critical_g);
-				break;
-			case 'w':
-				parse_range (optarg, &range_warning_g);
-				break;
-			case 's':
-				socket_file_g = optarg;
-				break;
-			case 'n':
-				value_string_g = optarg;
-				break;
-			case 'H':
-				hostname_g = optarg;
-				break;
-			case 'g':
-				if (strcasecmp (optarg, "none") == 0)
-					consolitation_g = CON_NONE;
-				else if (strcasecmp (optarg, "average") == 0)
-					consolitation_g = CON_AVERAGE;
-				else if (strcasecmp (optarg, "sum") == 0)
-					consolitation_g = CON_SUM;
-				else if (strcasecmp (optarg, "percentage") == 0)
-					consolitation_g = CON_PERCENTAGE;
-				else
-				{
-					fprintf (stderr, "Unknown consolidation function `%s'.\n",
-							optarg);
-					usage (argv[0]);
-				}
-				break;
-			case 'd':
-			{
-				char **tmp;
-				tmp = realloc (match_ds_g,
-						(match_ds_num_g + 1)
-						* sizeof (char *));
-				if (tmp == NULL)
-				{
-					fprintf (stderr, "realloc failed: %s\n",
-							strerror (errno));
-					return (RET_UNKNOWN);
-				}
-				match_ds_g = tmp;
-				match_ds_g[match_ds_num_g] = cn_strdup (optarg);
-				if (match_ds_g[match_ds_num_g] == NULL)
-				{
-					fprintf (stderr, "cn_strdup failed: %s\n",
-							strerror (errno));
-					return (RET_UNKNOWN);
-				}
-				match_ds_num_g++;
-				break;
-			}
-			case 'm':
-				nan_is_error_g = 1;
-				break;
-			default:
-				usage (argv[0]);
-		} /* switch (c) */
-	}
-
-	if ((socket_file_g == NULL) || (value_string_g == NULL)
-			|| ((hostname_g == NULL) && (strcasecmp (value_string_g, "LIST"))))
-	{
-		fprintf (stderr, "Missing required arguments.\n");
-		usage (argv[0]);
-	}
-
-	snprintf (address, sizeof (address), "unix:%s", socket_file_g);
-	address[sizeof (address) - 1] = 0;
-
-	connection = NULL;
-	status = lcc_connect (address, &connection);
-	if (status != 0)
-	{
-		printf ("ERROR: Connecting to daemon at %s failed.\n",
-				socket_file_g);
-		return (RET_CRITICAL);
-	}
-
-	if (0 == strcasecmp (value_string_g, "LIST"))
-		return (do_listval (connection));
-
-	return (do_check (connection));
+int main(int argc, char **argv) {
+  char address[1024];
+  lcc_connection_t *connection;
+
+  int status;
+
+  range_critical_g.min = NAN;
+  range_critical_g.max = NAN;
+  range_critical_g.invert = 0;
+
+  range_warning_g.min = NAN;
+  range_warning_g.max = NAN;
+  range_warning_g.invert = 0;
+
+  while (42) {
+    int c;
+
+    c = getopt(argc, argv, "w:c:s:n:H:g:d:hm");
+    if (c < 0)
+      break;
+
+    switch (c) {
+    case 'c':
+      parse_range(optarg, &range_critical_g);
+      break;
+    case 'w':
+      parse_range(optarg, &range_warning_g);
+      break;
+    case 's':
+      socket_file_g = optarg;
+      break;
+    case 'n':
+      value_string_g = optarg;
+      break;
+    case 'H':
+      hostname_g = optarg;
+      break;
+    case 'g':
+      if (strcasecmp(optarg, "none") == 0)
+        consolitation_g = CON_NONE;
+      else if (strcasecmp(optarg, "average") == 0)
+        consolitation_g = CON_AVERAGE;
+      else if (strcasecmp(optarg, "sum") == 0)
+        consolitation_g = CON_SUM;
+      else if (strcasecmp(optarg, "percentage") == 0)
+        consolitation_g = CON_PERCENTAGE;
+      else {
+        fprintf(stderr, "Unknown consolidation function `%s'.\n", optarg);
+        usage(argv[0]);
+      }
+      break;
+    case 'd': {
+      char **tmp;
+      tmp = realloc(match_ds_g, (match_ds_num_g + 1) * sizeof(char *));
+      if (tmp == NULL) {
+        fprintf(stderr, "realloc failed: %s\n", strerror(errno));
+        return (RET_UNKNOWN);
+      }
+      match_ds_g = tmp;
+      match_ds_g[match_ds_num_g] = cn_strdup(optarg);
+      if (match_ds_g[match_ds_num_g] == NULL) {
+        fprintf(stderr, "cn_strdup failed: %s\n", strerror(errno));
+        return (RET_UNKNOWN);
+      }
+      match_ds_num_g++;
+      break;
+    }
+    case 'm':
+      nan_is_error_g = 1;
+      break;
+    default:
+      usage(argv[0]);
+    } /* switch (c) */
+  }
+
+  if ((socket_file_g == NULL) || (value_string_g == NULL) ||
+      ((hostname_g == NULL) && (strcasecmp(value_string_g, "LIST")))) {
+    fprintf(stderr, "Missing required arguments.\n");
+    usage(argv[0]);
+  }
+
+  snprintf(address, sizeof(address), "unix:%s", socket_file_g);
+  address[sizeof(address) - 1] = 0;
+
+  connection = NULL;
+  status = lcc_connect(address, &connection);
+  if (status != 0) {
+    printf("ERROR: Connecting to daemon at %s failed.\n", socket_file_g);
+    return (RET_CRITICAL);
+  }
+
+  if (0 == strcasecmp(value_string_g, "LIST"))
+    return (do_listval(connection));
+
+  return (do_check(connection));
 } /* int main */
@@ -25,32 +25,32 @@
  **/
 
 #if HAVE_CONFIG_H
-# include "config.h"
+#include "config.h"
 #endif
 
 #if !__GNUC__
-# define __attribute__(x) /**/
+#define __attribute__(x) /**/
 #endif
 
-#include <stdlib.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-#include <time.h>
-#include <signal.h>
 #include <errno.h>
 #include <math.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
 
 #include "utils_heap.h"
 
 #include "libcollectdclient/collectd/client.h"
 #include "libcollectdclient/collectd/network.h"
 
-#define DEF_NUM_HOSTS    1000
-#define DEF_NUM_PLUGINS    20
+#define DEF_NUM_HOSTS 1000
+#define DEF_NUM_PLUGINS 20
 #define DEF_NUM_VALUES 100000
-#define DEF_INTERVAL       10.0
+#define DEF_INTERVAL 10.0
 
 static int conf_num_hosts = DEF_NUM_HOSTS;
 static int conf_num_plugins = DEF_NUM_PLUGINS;
@@ -68,10 +68,10 @@ static struct sigaction sigterm_action;
 
 static _Bool loop = 1;
 
-__attribute__((noreturn))
-static void exit_usage (int exit_status) /* {{{ */
+__attribute__((noreturn)) static void exit_usage(int exit_status) /* {{{ */
 {
-  fprintf ((exit_status == EXIT_FAILURE) ? stderr : stdout,
+  fprintf(
+      (exit_status == EXIT_FAILURE) ? stderr : stdout,
       "collectd-tg -- collectd traffic generator\n"
       "\n"
       "  Usage: collectd-ng [OPTION]\n"
@@ -89,41 +89,40 @@ static void exit_usage (int exit_status) /* {{{ */
       "\n"
       "Copyright (C) 2010-2012  Florian Forster\n"
       "Licensed under the MIT license.\n",
-      DEF_NUM_VALUES, DEF_NUM_HOSTS, DEF_NUM_PLUGINS,
-      DEF_INTERVAL,
+      DEF_NUM_VALUES, DEF_NUM_HOSTS, DEF_NUM_PLUGINS, DEF_INTERVAL,
       NET_DEFAULT_V6_ADDR, NET_DEFAULT_PORT);
-  exit (exit_status);
+  exit(exit_status);
 } /* }}} void exit_usage */
 
-static void signal_handler (int signal) /* {{{ */
+static void signal_handler(int signal) /* {{{ */
 {
   loop = 0;
 } /* }}} void signal_handler */
 
 #if HAVE_CLOCK_GETTIME
-static double dtime (void) /* {{{ */
+static double dtime(void) /* {{{ */
 {
-  struct timespec ts = { 0 };
+  struct timespec ts = {0};
 
-  if (clock_gettime (CLOCK_MONOTONIC, &ts) != 0)
-    perror ("clock_gettime");
+  if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0)
+    perror("clock_gettime");
 
-  return ((double) ts.tv_sec) + (((double) ts.tv_nsec) / 1e9);
+  return ((double)ts.tv_sec) + (((double)ts.tv_nsec) / 1e9);
 } /* }}} double dtime */
 #else
 /* Work around for Mac OS X which doesn't have clock_gettime(2). *sigh* */
-static double dtime (void) /* {{{ */
+static double dtime(void) /* {{{ */
 {
-  struct timeval tv = { 0 };
+  struct timeval tv = {0};
 
-  if (gettimeofday (&tv, /* timezone = */ NULL) != 0)
-    perror ("gettimeofday");
+  if (gettimeofday(&tv, /* timezone = */ NULL) != 0)
+    perror("gettimeofday");
 
-  return ((double) tv.tv_sec) + (((double) tv.tv_usec) / 1e6);
+  return ((double)tv.tv_sec) + (((double)tv.tv_usec) / 1e6);
 } /* }}} double dtime */
 #endif
 
-static int compare_time (const void *v0, const void *v1) /* {{{ */
+static int compare_time(const void *v0, const void *v1) /* {{{ */
 {
   const lcc_value_list_t *vl0 = v0;
   const lcc_value_list_t *vl1 = v1;
@@ -136,7 +135,7 @@ static int compare_time (const void *v0, const void *v1) /* {{{ */
     return (0);
 } /* }}} int compare_time */
 
-static int get_boundet_random (int min, int max) /* {{{ */
+static int get_boundet_random(int min, int max) /* {{{ */
 {
   int range;
 
@@ -147,308 +146,282 @@ static int get_boundet_random (int min, int max) /* {{{ */
 
   range = max - min;
 
-  return (min + ((int) (((double) range) * ((double) random ()) / (((double) RAND_MAX) + 1.0))));
+  return (min + ((int)(((double)range) * ((double)random()) /
+                       (((double)RAND_MAX) + 1.0))));
 } /* }}} int get_boundet_random */
 
-static lcc_value_list_t *create_value_list (void) /* {{{ */
+static lcc_value_list_t *create_value_list(void) /* {{{ */
 {
   lcc_value_list_t *vl;
   int host_num;
 
-  vl = calloc (1, sizeof (*vl));
-  if (vl == NULL)
-  {
-    fprintf (stderr, "calloc failed.\n");
+  vl = calloc(1, sizeof(*vl));
+  if (vl == NULL) {
+    fprintf(stderr, "calloc failed.\n");
     return (NULL);
   }
 
-  vl->values = calloc (/* nmemb = */ 1, sizeof (*vl->values));
-  if (vl->values == NULL)
-  {
-    fprintf (stderr, "calloc failed.\n");
-    free (vl);
+  vl->values = calloc(/* nmemb = */ 1, sizeof(*vl->values));
+  if (vl->values == NULL) {
+    fprintf(stderr, "calloc failed.\n");
+    free(vl);
     return (NULL);
   }
 
-  vl->values_types = calloc (/* nmemb = */ 1, sizeof (*vl->values_types));
-  if (vl->values_types == NULL)
-  {
-    fprintf (stderr, "calloc failed.\n");
-    free (vl->values);
-    free (vl);
+  vl->values_types = calloc(/* nmemb = */ 1, sizeof(*vl->values_types));
+  if (vl->values_types == NULL) {
+    fprintf(stderr, "calloc failed.\n");
+    free(vl->values);
+    free(vl);
     return (NULL);
   }
 
   vl->values_len = 1;
 
-  host_num = get_boundet_random (0, conf_num_hosts);
+  host_num = get_boundet_random(0, conf_num_hosts);
 
   vl->interval = conf_interval;
-  vl->time = 1.0 + dtime ()
-    + (host_num % (1 + (int) vl->interval));
+  vl->time = 1.0 + dtime() + (host_num % (1 + (int)vl->interval));
 
-  if (get_boundet_random (0, 2) == 0)
+  if (get_boundet_random(0, 2) == 0)
     vl->values_types[0] = LCC_TYPE_GAUGE;
   else
     vl->values_types[0] = LCC_TYPE_DERIVE;
 
-  snprintf (vl->identifier.host, sizeof (vl->identifier.host),
-      "host%04i", host_num);
-  snprintf (vl->identifier.plugin, sizeof (vl->identifier.plugin),
-      "plugin%03i", get_boundet_random (0, conf_num_plugins));
-  strncpy (vl->identifier.type,
-      (vl->values_types[0] == LCC_TYPE_GAUGE) ? "gauge" : "derive",
-      sizeof (vl->identifier.type));
-  vl->identifier.type[sizeof (vl->identifier.type) - 1] = 0;
-  snprintf (vl->identifier.type_instance, sizeof (vl->identifier.type_instance),
-      "ti%li", random ());
+  snprintf(vl->identifier.host, sizeof(vl->identifier.host), "host%04i",
+           host_num);
+  snprintf(vl->identifier.plugin, sizeof(vl->identifier.plugin), "plugin%03i",
+           get_boundet_random(0, conf_num_plugins));
+  strncpy(vl->identifier.type,
+          (vl->values_types[0] == LCC_TYPE_GAUGE) ? "gauge" : "derive",
+          sizeof(vl->identifier.type));
+  vl->identifier.type[sizeof(vl->identifier.type) - 1] = 0;
+  snprintf(vl->identifier.type_instance, sizeof(vl->identifier.type_instance),
+           "ti%li", random());
 
   return (vl);
 } /* }}} int create_value_list */
 
-static void destroy_value_list (lcc_value_list_t *vl) /* {{{ */
+static void destroy_value_list(lcc_value_list_t *vl) /* {{{ */
 {
   if (vl == NULL)
     return;
 
-  free (vl->values);
-  free (vl->values_types);
-  free (vl);
+  free(vl->values);
+  free(vl->values_types);
+  free(vl);
 } /* }}} void destroy_value_list */
 
-static int send_value (lcc_value_list_t *vl) /* {{{ */
+static int send_value(lcc_value_list_t *vl) /* {{{ */
 {
   int status;
 
   if (vl->values_types[0] == LCC_TYPE_GAUGE)
-    vl->values[0].gauge = 100.0 * ((gauge_t) random ()) / (((gauge_t) RAND_MAX) + 1.0);
+    vl->values[0].gauge =
+        100.0 * ((gauge_t)random()) / (((gauge_t)RAND_MAX) + 1.0);
   else
-    vl->values[0].derive += (derive_t) get_boundet_random (0, 100);
+    vl->values[0].derive += (derive_t)get_boundet_random(0, 100);
 
-  status = lcc_network_values_send (net, vl);
+  status = lcc_network_values_send(net, vl);
   if (status != 0)
-    fprintf (stderr, "lcc_network_values_send failed with status %i.\n", status);
+    fprintf(stderr, "lcc_network_values_send failed with status %i.\n", status);
 
   vl->time += vl->interval;
 
   return (0);
 } /* }}} int send_value */
 
-static int get_integer_opt (const char *str, int *ret_value) /* {{{ */
+static int get_integer_opt(const char *str, int *ret_value) /* {{{ */
 {
   char *endptr;
   int tmp;
 
   errno = 0;
   endptr = NULL;
-  tmp = (int) strtol (str, &endptr, /* base = */ 0);
-  if (errno != 0)
-  {
-    fprintf (stderr, "Unable to parse option as a number: \"%s\": %s\n",
-        str, strerror (errno));
-    exit (EXIT_FAILURE);
-  }
-  else if (endptr == str)
-  {
-    fprintf (stderr, "Unable to parse option as a number: \"%s\"\n", str);
-    exit (EXIT_FAILURE);
-  }
-  else if (*endptr != 0)
-  {
-    fprintf (stderr, "Garbage after end of value: \"%s\"\n", str);
-    exit (EXIT_FAILURE);
+  tmp = (int)strtol(str, &endptr, /* base = */ 0);
+  if (errno != 0) {
+    fprintf(stderr, "Unable to parse option as a number: \"%s\": %s\n", str,
+            strerror(errno));
+    exit(EXIT_FAILURE);
+  } else if (endptr == str) {
+    fprintf(stderr, "Unable to parse option as a number: \"%s\"\n", str);
+    exit(EXIT_FAILURE);
+  } else if (*endptr != 0) {
+    fprintf(stderr, "Garbage after end of value: \"%s\"\n", str);
+    exit(EXIT_FAILURE);
   }
 
   *ret_value = tmp;
   return (0);
 } /* }}} int get_integer_opt */
 
-static int get_double_opt (const char *str, double *ret_value) /* {{{ */
+static int get_double_opt(const char *str, double *ret_value) /* {{{ */
 {
   char *endptr;
   double tmp;
 
   errno = 0;
   endptr = NULL;
-  tmp = strtod (str, &endptr);
-  if (errno != 0)
-  {
-    fprintf (stderr, "Unable to parse option as a number: \"%s\": %s\n",
-        str, strerror (errno));
-    exit (EXIT_FAILURE);
-  }
-  else if (endptr == str)
-  {
-    fprintf (stderr, "Unable to parse option as a number: \"%s\"\n", str);
-    exit (EXIT_FAILURE);
-  }
-  else if (*endptr != 0)
-  {
-    fprintf (stderr, "Garbage after end of value: \"%s\"\n", str);
-    exit (EXIT_FAILURE);
+  tmp = strtod(str, &endptr);
+  if (errno != 0) {
+    fprintf(stderr, "Unable to parse option as a number: \"%s\": %s\n", str,
+            strerror(errno));
+    exit(EXIT_FAILURE);
+  } else if (endptr == str) {
+    fprintf(stderr, "Unable to parse option as a number: \"%s\"\n", str);
+    exit(EXIT_FAILURE);
+  } else if (*endptr != 0) {
+    fprintf(stderr, "Garbage after end of value: \"%s\"\n", str);
+    exit(EXIT_FAILURE);
   }
 
   *ret_value = tmp;
   return (0);
 } /* }}} int get_double_opt */
 
-static int read_options (int argc, char **argv) /* {{{ */
+static int read_options(int argc, char **argv) /* {{{ */
 {
   int opt;
 
-  while ((opt = getopt (argc, argv, "n:H:p:i:d:D:h")) != -1)
-  {
-    switch (opt)
-    {
-      case 'n':
-        get_integer_opt (optarg, &conf_num_values);
-        break;
+  while ((opt = getopt(argc, argv, "n:H:p:i:d:D:h")) != -1) {
+    switch (opt) {
+    case 'n':
+      get_integer_opt(optarg, &conf_num_values);
+      break;
 
-      case 'H':
-        get_integer_opt (optarg, &conf_num_hosts);
-        break;
+    case 'H':
+      get_integer_opt(optarg, &conf_num_hosts);
+      break;
 
-      case 'p':
-        get_integer_opt (optarg, &conf_num_plugins);
-        break;
+    case 'p':
+      get_integer_opt(optarg, &conf_num_plugins);
+      break;
 
-      case 'i':
-        get_double_opt (optarg, &conf_interval);
-        break;
+    case 'i':
+      get_double_opt(optarg, &conf_interval);
+      break;
 
-      case 'd':
-        conf_destination = optarg;
-        break;
+    case 'd':
+      conf_destination = optarg;
+      break;
 
-      case 'D':
-        conf_service = optarg;
-        break;
+    case 'D':
+      conf_service = optarg;
+      break;
 
-      case 'h':
-        exit_usage (EXIT_SUCCESS);
+    case 'h':
+      exit_usage(EXIT_SUCCESS);
 
-      default:
-        exit_usage (EXIT_FAILURE);
+    default:
+      exit_usage(EXIT_FAILURE);
     } /* switch (opt) */
-  } /* while (getopt) */
+  }   /* while (getopt) */
 
   return (0);
 } /* }}} int read_options */
 
-int main (int argc, char **argv) /* {{{ */
+int main(int argc, char **argv) /* {{{ */
 {
   double last_time;
   int values_sent = 0;
 
-  read_options (argc, argv);
+  read_options(argc, argv);
 
   sigint_action.sa_handler = signal_handler;
-  sigaction (SIGINT, &sigint_action, /* old = */ NULL);
+  sigaction(SIGINT, &sigint_action, /* old = */ NULL);
 
   sigterm_action.sa_handler = signal_handler;
-  sigaction (SIGTERM, &sigterm_action, /* old = */ NULL);
-
+  sigaction(SIGTERM, &sigterm_action, /* old = */ NULL);
 
-  values_heap = c_heap_create (compare_time);
-  if (values_heap == NULL)
-  {
-    fprintf (stderr, "c_heap_create failed.\n");
-    exit (EXIT_FAILURE);
+  values_heap = c_heap_create(compare_time);
+  if (values_heap == NULL) {
+    fprintf(stderr, "c_heap_create failed.\n");
+    exit(EXIT_FAILURE);
   }
 
-  net = lcc_network_create ();
-  if (net == NULL)
-  {
-    fprintf (stderr, "lcc_network_create failed.\n");
-    exit (EXIT_FAILURE);
-  }
-  else
-  {
+  net = lcc_network_create();
+  if (net == NULL) {
+    fprintf(stderr, "lcc_network_create failed.\n");
+    exit(EXIT_FAILURE);
+  } else {
     lcc_server_t *srv;
 
-    srv = lcc_server_create (net, conf_destination, conf_service);
-    if (srv == NULL)
-    {
-      fprintf (stderr, "lcc_server_create failed.\n");
-      exit (EXIT_FAILURE);
+    srv = lcc_server_create(net, conf_destination, conf_service);
+    if (srv == NULL) {
+      fprintf(stderr, "lcc_server_create failed.\n");
+      exit(EXIT_FAILURE);
     }
 
-    lcc_server_set_ttl (srv, 42);
+    lcc_server_set_ttl(srv, 42);
 #if 0
     lcc_server_set_security_level (srv, ENCRYPT,
         "admin", "password1");
 #endif
   }
 
-  fprintf (stdout, "Creating %i values ... ", conf_num_values);
-  fflush (stdout);
-  for (int i = 0; i < conf_num_values; i++)
-  {
+  fprintf(stdout, "Creating %i values ... ", conf_num_values);
+  fflush(stdout);
+  for (int i = 0; i < conf_num_values; i++) {
     lcc_value_list_t *vl;
 
-    vl = create_value_list ();
-    if (vl == NULL)
-    {
-      fprintf (stderr, "create_value_list failed.\n");
-      exit (EXIT_FAILURE);
+    vl = create_value_list();
+    if (vl == NULL) {
+      fprintf(stderr, "create_value_list failed.\n");
+      exit(EXIT_FAILURE);
     }
 
-    c_heap_insert (values_heap, vl);
+    c_heap_insert(values_heap, vl);
   }
-  fprintf (stdout, "done\n");
+  fprintf(stdout, "done\n");
 
   last_time = 0;
-  while (loop)
-  {
-    lcc_value_list_t *vl = c_heap_get_root (values_heap);
+  while (loop) {
+    lcc_value_list_t *vl = c_heap_get_root(values_heap);
 
     if (vl == NULL)
       break;
 
-    if (vl->time != last_time)
-    {
-      printf ("%i values have been sent.\n", values_sent);
+    if (vl->time != last_time) {
+      printf("%i values have been sent.\n", values_sent);
 
       /* Check if we need to sleep */
-      double now = dtime ();
+      double now = dtime();
 
-      while (now < vl->time)
-      {
+      while (now < vl->time) {
         /* 1 / 100 second */
-        struct timespec ts = { 0, 10000000 };
+        struct timespec ts = {0, 10000000};
 
-        ts.tv_sec = (time_t) now;
-        ts.tv_nsec = (long) ((now - ((double) ts.tv_sec)) * 1e9);
+        ts.tv_sec = (time_t)now;
+        ts.tv_nsec = (long)((now - ((double)ts.tv_sec)) * 1e9);
 
-        nanosleep (&ts, /* remaining = */ NULL);
-        now = dtime ();
+        nanosleep(&ts, /* remaining = */ NULL);
+        now = dtime();
 
         if (!loop)
           break;
       }
       last_time = vl->time;
     }
 
-    send_value (vl);
+    send_value(vl);
     values_sent++;
 
-    c_heap_insert (values_heap, vl);
+    c_heap_insert(values_heap, vl);
   }
 
-  fprintf (stdout, "Shutting down.\n");
-  fflush (stdout);
+  fprintf(stdout, "Shutting down.\n");
+  fflush(stdout);
 
-  while (42)
-  {
-    lcc_value_list_t *vl = c_heap_get_root (values_heap);
+  while (42) {
+    lcc_value_list_t *vl = c_heap_get_root(values_heap);
     if (vl == NULL)
       break;
-    destroy_value_list (vl);
+    destroy_value_list(vl);
   }
-  c_heap_destroy (values_heap);
+  c_heap_destroy(values_heap);
 
-  lcc_network_destroy (net);
-  exit (EXIT_SUCCESS);
+  lcc_network_destroy(net);
+  exit(EXIT_SUCCESS);
 } /* }}} int main */
 
 /* vim: set sw=2 sts=2 et fdm=marker : */