----++++src/Downloader.cc
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include &quot;squid.h&quot;
+#include &quot;client_side.h&quot;
+#include &quot;client_side_request.h&quot;
+#include &quot;client_side_reply.h&quot;
+#include &quot;ClientRequestContext.h&quot;
+#include &quot;Downloader.h&quot;
+#include &quot;http/one/RequestParser.h&quot;
+#include &quot;http/Stream.h&quot;
+
+CBDATA_CLASS_INIT(Downloader);
+
+/// Used to hold and pass the required info and buffers to the
+/// clientStream callbacks
+class DownloaderContext: public RefCountable
+{
+    MEMPROXY_CLASS(DownloaderContext);
+
+public:
+    typedef RefCount&lt;DownloaderContext&gt; Pointer;
+
+    DownloaderContext(Downloader *dl, ClientHttpRequest *h);
+    ~DownloaderContext();
+    void finished();
+
+    CbcPointer&lt;Downloader&gt; downloader;
+    ClientHttpRequest *http;
+    char requestBuffer[HTTP_REQBUF_SZ];
+};
+
+DownloaderContext::DownloaderContext(Downloader *dl, ClientHttpRequest *h):
+    downloader(dl),
+    http(h)
+{
+    debugs(33, 6, &quot;DownloaderContext constructed, this=&quot; &lt;&lt; (void*)this);
+}
+
+DownloaderContext::~DownloaderContext()
+{
+    debugs(33, 6, &quot;DownloaderContext destructed, this=&quot; &lt;&lt; (void*)this);
+    if (http)
+        finished();
+}
+
+void
+DownloaderContext::finished()
+{
+    delete http;
+    http = nullptr;
+}
+
+void
+Downloader::CbDialer::print(std::ostream &amp;os) const
+{
+    os &lt;&lt; &quot; Http Status:&quot; &lt;&lt; status &lt;&lt; Raw(&quot;body data&quot;, object.rawContent(), 64).hex();
+}
+
+Downloader::Downloader(SBuf &amp;url, AsyncCall::Pointer &amp;aCallback, unsigned int level):
+    AsyncJob(&quot;Downloader&quot;),
+    url_(url),
+    callback_(aCallback),
+    level_(level)
+{
+}
+
+Downloader::~Downloader()
+{
+}
+
+bool
+Downloader::doneAll() const
+{
+    return (!callback_ || callback_-&gt;canceled()) &amp;&amp; AsyncJob::doneAll();
+}
+
+static void
+downloaderRecipient(clientStreamNode * node, ClientHttpRequest * http,
+                    HttpReply * rep, StoreIOBuffer receivedData)
+{
+    debugs(33, 6, MYNAME);
+     /* Test preconditions */
+    assert(node);
+
+    /* TODO: handle this rather than asserting
+     * - it should only ever happen if we cause an abort and
+     * the callback chain loops back to here, so we can simply return.
+     * However, that itself shouldn&#39;t happen, so it stays as an assert for now.
+     */
+    assert(cbdataReferenceValid(node));
+    assert(!node-&gt;node.next);
+    DownloaderContext::Pointer context = dynamic_cast&lt;DownloaderContext *&gt;(node-&gt;data.getRaw());
+    assert(context);
+
+    if (context-&gt;downloader.valid())
+        context-&gt;downloader-&gt;handleReply(node, http, rep, receivedData);
+}
+
+static void
+downloaderDetach(clientStreamNode * node, ClientHttpRequest * http)
+{
+    debugs(33, 5, MYNAME);
+    clientStreamDetach(node, http);
+}
+
+/// Initializes and starts the HTTP GET request to the remote server
+bool
+Downloader::buildRequest()
+{ 
+    const HttpRequestMethod method = Http::METHOD_GET;
+
+    char *uri = xstrdup(url_.c_str());
+    HttpRequest *const request = HttpRequest::CreateFromUrl(uri, method);
+    if (!request) {
+        debugs(33, 5, &quot;Invalid URI: &quot; &lt;&lt; url_);
+        xfree(uri);
+        return false; //earlyError(...)
+    }
+    request-&gt;http_ver = Http::ProtocolVersion();
+    request-&gt;header.putStr(Http::HdrType::HOST, request-&gt;url.host());
+    request-&gt;header.putTime(Http::HdrType::DATE, squid_curtime);
+    request-&gt;flags.internalClient = true;
+    request-&gt;client_addr.setNoAddr();
+#if FOLLOW_X_FORWARDED_FOR
+    request-&gt;indirect_client_addr.setNoAddr();
+#endif /* FOLLOW_X_FORWARDED_FOR */
+    request-&gt;my_addr.setNoAddr();   /* undefined for internal requests */
+    request-&gt;my_addr.port(0);
+    request-&gt;downloader = this;
+
+    debugs(11, 2, &quot;HTTP Client Downloader &quot; &lt;&lt; this &lt;&lt; &quot;/&quot; &lt;&lt; id);
+    debugs(11, 2, &quot;HTTP Client REQUEST:\n---------\n&quot; &lt;&lt;
+           request-&gt;method &lt;&lt; &quot; &quot; &lt;&lt; url_ &lt;&lt; &quot; &quot; &lt;&lt; request-&gt;http_ver &lt;&lt; &quot;\n&quot; &lt;&lt;
+           &quot;\n----------&quot;);
+
+    ClientHttpRequest *const http = new ClientHttpRequest(nullptr);
+    http-&gt;request = request;
+    HTTPMSGLOCK(http-&gt;request);
+    http-&gt;req_sz = 0;
+    http-&gt;uri = uri;
+    setLogUri (http, urlCanonicalClean(request));
+
+    context_ = new DownloaderContext(this, http);
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = context_-&gt;requestBuffer;
+    tempBuffer.length = HTTP_REQBUF_SZ;
+
+    ClientStreamData newServer = new clientReplyContext(http);
+    ClientStreamData newClient = context_.getRaw();
+    clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
+                     clientReplyStatus, newServer, downloaderRecipient,
+                     downloaderDetach, newClient, tempBuffer);
+
+    // Build a ClientRequestContext to start doCallouts
+    http-&gt;calloutContext = new ClientRequestContext(http);
+    http-&gt;doCallouts();
+    return true;
+}
+
+void
+Downloader::start()
+{
+    if (!buildRequest())
+        callBack(Http::scInternalServerError);
+}
+
+void
+Downloader::handleReply(clientStreamNode * node, ClientHttpRequest *http, HttpReply *reply, StoreIOBuffer receivedData)
+{
+    DownloaderContext::Pointer callerContext = dynamic_cast&lt;DownloaderContext *&gt;(node-&gt;data.getRaw());
+    // TODO: remove the following check:
+    assert(callerContext == context_);
+
+    debugs(33, 4, &quot;Received &quot; &lt;&lt; receivedData.length &lt;&lt;
+           &quot; object data, offset: &quot; &lt;&lt; receivedData.offset &lt;&lt;
+           &quot; error flag:&quot; &lt;&lt; receivedData.flags.error);
+
+    const bool failed = receivedData.flags.error;
+    if (failed) {
+        callBack(Http::scInternalServerError);
+        return;
+    }
+
+    const int64_t existingContent = reply ? reply-&gt;content_length : 0;
+    const size_t maxSize = MaxObjectSize &gt; SBuf::maxSize ? SBuf::maxSize : MaxObjectSize;
+    const bool tooLarge = (existingContent &gt; -1 &amp;&amp; existingContent &gt; static_cast&lt;int64_t&gt;(maxSize)) ||
+                          (maxSize &lt; object_.length()) ||
+                          ((maxSize - object_.length()) &lt; receivedData.length);
+
+    if (tooLarge) {
+        callBack(Http::scInternalServerError);
+        return;
+    }
+
+    object_.append(receivedData.data, receivedData.length);
+    http-&gt;out.size += receivedData.length;
+    http-&gt;out.offset += receivedData.length;
+
+    switch (clientStreamStatus(node, http)) {
+    case STREAM_NONE: {
+        debugs(33, 3, &quot;Get more data&quot;);
+        StoreIOBuffer tempBuffer;
+        tempBuffer.offset = http-&gt;out.offset;
+        tempBuffer.data = context_-&gt;requestBuffer;
+        tempBuffer.length = HTTP_REQBUF_SZ;
+        clientStreamRead(node, http, tempBuffer);
+    }
+        break;
+    case STREAM_COMPLETE:
+        debugs(33, 3, &quot;Object data transfer successfully complete&quot;);
+        callBack(Http::scOkay);
+        break;
+    case STREAM_UNPLANNED_COMPLETE:
+        debugs(33, 3, &quot;Object data transfer failed: STREAM_UNPLANNED_COMPLETE&quot;);
+        callBack(Http::scInternalServerError);
+        break;
+    case STREAM_FAILED:
+        debugs(33, 3, &quot;Object data transfer failed: STREAM_FAILED&quot;);
+        callBack(Http::scInternalServerError);
+        break;
+    default:
+        fatal(&quot;unreachable code&quot;);
+    }
+}
+
+void
+Downloader::downloadFinished()
+{
+    debugs(33, 7, this);
+    // We cannot delay http destruction until refcounting deletes 
+    // DownloaderContext. The http object destruction will cause 
+    // clientStream cleanup and will release the refcount to context_
+    // object hold by clientStream structures.
+    context_-&gt;finished();
+    context_ = nullptr;
+    Must(done());
+}
+
+/// Schedules for execution the &quot;callback&quot; with parameters the status
+/// and object.
+void
+Downloader::callBack(Http::StatusCode const statusCode)
+{
+     CbDialer *dialer = dynamic_cast&lt;CbDialer*&gt;(callback_-&gt;getDialer());
+     Must(dialer);
+     dialer-&gt;status = statusCode;
+     if (statusCode == Http::scOkay)
+         dialer-&gt;object = object_;
+     ScheduleCallHere(callback_);
+     callback_ = nullptr;
+
+     // Calling deleteThis method here to finish Downloader
+     // may result to squid crash.
+     // This method called by handleReply method which maybe called
+     // by ClientHttpRequest::doCallouts. The doCallouts after this object
+     // deleted, may operate on non valid objects.
+     // Schedule an async call here just to force squid to delete this object.
+     CallJobHere(33, 7, CbcPointer&lt;Downloader&gt;(this), Downloader, downloadFinished);
+}
+
----++++src/Downloader.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_DOWNLOADER_H
+#define SQUID_DOWNLOADER_H
+
+#include &quot;base/AsyncJob.h&quot;
+#include &quot;defines.h&quot;
+#include &quot;http/forward.h&quot;
+#include &quot;http/StatusCode.h&quot;
+#include &quot;sbuf/SBuf.h&quot;
+
+class ClientHttpRequest;
+class StoreIOBuffer;
+class clientStreamNode;
+class DownloaderContext;
+typedef RefCount&lt;DownloaderContext&gt; DownloaderContextPointer;
+
+/// The Downloader class fetches SBuf-storable things for other Squid
+/// components/transactions using internal requests. For example, it is used
+/// to fetch missing intermediate certificates when validating origin server
+/// certificate chains.
+class Downloader: virtual public AsyncJob
+{
+    CBDATA_CLASS(Downloader);
+public:
+
+    /// Callback data to use with Downloader callbacks.
+    class CbDialer: public CallDialer {
+    public:
+        CbDialer(): status(Http::scNone) {}
+        virtual ~CbDialer() {}
+
+        /* CallDialer API */
+        virtual bool canDial(AsyncCall &amp;call) = 0;
+        virtual void dial(AsyncCall &amp;call) = 0;
+        virtual void print(std::ostream &amp;os) const;
+
+        SBuf object;
+        Http::StatusCode status;
+    };
+
+    Downloader(SBuf &amp;url, AsyncCall::Pointer &amp;aCallback, unsigned int level = 0);
+    virtual ~Downloader();
+
+    /// delays destruction to protect doCallouts()
+    void downloadFinished();
+
+    /// The nested level of Downloader object (downloads inside downloads).
+    unsigned int nestedLevel() const {return level_;}
+    
+    void handleReply(clientStreamNode *, ClientHttpRequest *, HttpReply *, StoreIOBuffer);
+
+protected:
+
+    /* AsyncJob API */
+    virtual bool doneAll() const;
+    virtual void start();
+
+private:
+
+    bool buildRequest();
+    void callBack(Http::StatusCode const status);
+
+    /// The maximum allowed object size.
+    static const size_t MaxObjectSize = 1*1024*1024;
+
+    SBuf url_; ///&lt; the url to download
+    AsyncCall::Pointer callback_; ///&lt; callback to call when download finishes
+    SBuf object_; ///&lt; the object body data
+    const unsigned int level_; ///&lt; holds the nested downloads level
+
+    /// Pointer to an object that stores the clientStream required info
+    DownloaderContextPointer context_;
+};
+
+#endif
----++++src/HttpRequest.cc
@@ -14,6 +14,7 @@
 #include &quot;acl/FilledChecklist.h&quot;
 #include &quot;client_side.h&quot;
 #include &quot;dns/LookupDetails.h&quot;
+#include &quot;Downloader.h&quot;
 #include &quot;err_detail_type.h&quot;
 #include &quot;globals.h&quot;
 #include &quot;gopher.h&quot;
@@ -250,6 +251,8 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq-&gt;clientConnectionManager;
 
+    downloader = aReq-&gt;downloader;
+
     notes = aReq-&gt;notes;
 
     sources = aReq-&gt;sources;
----++++src/HttpRequest.h
@@ -34,6 +34,7 @@
 #endif
 
 class ConnStateData;
+class Downloader;
 
 /*  Http Request */
 void httpRequestPack(void *obj, Packable *p);
@@ -212,6 +213,9 @@ class HttpRequest: public HttpMsg
      */
     CbcPointer&lt;ConnStateData&gt; clientConnectionManager;
 
+    /// The Downloader object which initiated the HTTP request if any
+    CbcPointer&lt;Downloader&gt; downloader;
+
     /// forgets about the cached Range header (for a reason)
     void ignoreRange(const char *reason);
     int64_t getRangeOffsetLimit(); /* the result of this function gets cached in rangeOffsetLimit */
----++++src/Makefile.am
@@ -272,6 +272,8 @@ squid_SOURCES = \
 	dlink.h \
 	dlink.cc \
 	$(DNSSOURCE) \
+	Downloader.cc \
+	Downloader.h \
 	enums.h \
 	err_type.h \
 	err_detail_type.h \
----++++GitHub