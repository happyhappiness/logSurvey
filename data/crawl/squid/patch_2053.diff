@@ -1,4 +1,4 @@
-/* $Id: cache_cf.cc,v 1.5 1996/03/27 01:45:54 wessels Exp $ */
+/* $Id: cache_cf.cc,v 1.6 1996/03/27 18:15:40 wessels Exp $ */
 
 #include "squid.h"
 
@@ -13,14 +13,12 @@ static struct {
 	int maxObjSize;
 	int defaultTtl;
     } Gopher, Http, Ftp;
-#if USE_WAIS_RELAY
     struct {
 	int maxObjSize;
 	int defaultTtl;
 	char *relayHost;
 	int relayPort;
     } Wais;
-#endif
     int negativeTtl;
     int readTimeout;
     int lifetimeDefault;
@@ -51,7 +49,6 @@ static struct {
     int sourcePing;
     int quickAbort;
     int commonLogFormat;
-    int debugLevel;
     int neighborTimeout;
     int stallDelay;
     int singleParentBypass;
@@ -62,6 +59,7 @@ static struct {
 	int withProxy;
     } Accel;
     char *appendDomain;
+    char *debugOptions;
 } Config;
 
 #define DefaultMemMaxSize 	(16 << 20)	/* 16 MB */
@@ -77,12 +75,10 @@ static struct {
 #define DefaultGopherMaxObjSize	(4 << 20)	/* 4 MB */
 #define DefaultHttpDefaultTtl	(7 * 24 * 60 * 60)	/* 1 week */
 #define DefaultHttpMaxObjSize	(4 << 20)	/* 4 MB */
-#if USE_WAIS_RELAY
 #define DefaultWaisDefaultTtl	(7 * 24 * 60 * 60)	/* 1 week */
 #define DefaultWaisMaxObjSize	(4 << 20)	/* 4 MB */
 #define DefaultWaisRelayHost	(char *)NULL
 #define DefaultWaisRelayPort	-1
-#endif
 
 #define DefaultNegativeTtl	(5 * 60)	/* 5 min */
 #define DefaultReadTimeout	(15 * 60)	/* 15 min */
@@ -110,7 +106,7 @@ static struct {
 #define DefaultEffectiveGroup	(char *)NULL	/* default NONE */
 #define DefaultAppendDomain	(char *)NULL	/* default NONE */
 
-#define DefaultDebugLevel	1	/* default 1 */
+#define DefaultDebugOptions	"ALL,1"
 #define DefaultAccelHost	(char *)NULL	/* default NONE */
 #define DefaultAccelPrefix	(char *)NULL	/* default NONE */
 #define DefaultAccelPort	0	/* default off */
@@ -141,7 +137,7 @@ time_t neighbor_timeout = DefaultNeighborTimeout;	/* for fast access */
 int single_parent_bypass = 0;
 int getDnsChildren();
 
-static char w_space[] = " \t\n";
+char w_space[] = " \t\n";
 
 static void configSetFactoryDefaults();
 static void configDoConfigure();
@@ -201,13 +197,13 @@ ip_access_check(address, list)
     c3 = ((int) naddr & 0x0000ff00) >> 8;
     c4 = ((int) naddr & 0x000000ff);
 
-    debug(10, "ip_access_check: Using %d.%d.%d.%d\n", c1, c2, c3, c4);
+    debug(0, 10, "ip_access_check: Using %d.%d.%d.%d\n", c1, c2, c3, c4);
 
     if ((c1 == 127) && (c2 == 0) && (c3 == 0) && (c4 == 1))
 	return IP_ALLOW;	/* always allow localhost */
 
     for (p = list; p; p = p->next) {
-	debug(10, "ip_access_check: %d.%d.%d.%d vs %d.%d.%d.%d\n",
+	debug(0, 10, "ip_access_check: %d.%d.%d.%d vs %d.%d.%d.%d\n",
 	    c1, c2, c3, c4, p->a1, p->a2, p->a3, p->a4);
 	if (ip_acl_match(c1, c2, c3, c4, p->a1, p->a2, p->a3, p->a4))
 	    return p->access;
@@ -292,7 +288,7 @@ void addToStopList(list, key)
 		self_destruct(line_in);
 
 
-void parseCacheHostLine(line_in)
+static void parseCacheHostLine(line_in)
      char *line_in;
 {
     char *type = NULL;
@@ -317,7 +313,7 @@ void parseCacheHostLine(line_in)
     neighbors_cf_add(hostname, type, ascii_port, udp_port, proxy_only);
 }
 
-void parseHostDomainLine(line_in)
+static void parseHostDomainLine(line_in)
      char *line_in;
 {
     char *host = NULL;
@@ -331,14 +327,14 @@ void parseHostDomainLine(line_in)
     }
 }
 
-void parseMailTraceLine(line_in)
+static void parseMailTraceLine(line_in)
      char *line_in;
 {
     fprintf(stderr, "'mail_trace' not supported in this version; ignored.\n");
 }
 
 
-void parseSourcePingLine(line_in)
+static void parseSourcePingLine(line_in)
      char *line_in;
 {
     char *srcping;
@@ -357,7 +353,7 @@ void parseSourcePingLine(line_in)
 }
 
 
-void parseQuickAbortLine(line_in)
+static void parseQuickAbortLine(line_in)
      char *line_in;
 {
     char *abort;
@@ -375,7 +371,7 @@ void parseQuickAbortLine(line_in)
 
 }
 
-void parseMemLine(line_in)
+static void parseMemLine(line_in)
      char *line_in;
 {
     char *token;
@@ -384,7 +380,7 @@ void parseMemLine(line_in)
     Config.Mem.maxSize = i << 20;
 }
 
-void parseMemHighLine(line_in)
+static void parseMemHighLine(line_in)
      char *line_in;
 {
     char *token;
@@ -393,7 +389,7 @@ void parseMemHighLine(line_in)
     Config.Mem.highWatherMark = i;
 }
 
-void parseMemLowLine(line_in)
+static void parseMemLowLine(line_in)
      char *line_in;
 {
     char *token;
@@ -402,7 +398,7 @@ void parseMemLowLine(line_in)
     Config.Mem.lowWaterMark = i;
 }
 
-void parseHotVmFactorLine(line_in)
+static void parseHotVmFactorLine(line_in)
      char *line_in;
 {
     char *token = NULL;
@@ -418,7 +414,7 @@ void parseHotVmFactorLine(line_in)
     Config.hotVmFactor = d;
 }
 
-void parseSwapLine(line_in)
+static void parseSwapLine(line_in)
      char *line_in;
 {
     char *token;
@@ -427,7 +423,7 @@ void parseSwapLine(line_in)
     Config.Swap.maxSize = i << 10;
 }
 
-void parseSwapHighLine(line_in)
+static void parseSwapHighLine(line_in)
      char *line_in;
 {
     char *token;
@@ -436,7 +432,7 @@ void parseSwapHighLine(line_in)
     Config.Swap.highWatherMark = i;
 }
 
-void parseSwapLowLine(line_in)
+static void parseSwapLowLine(line_in)
      char *line_in;
 {
     char *token;
@@ -445,7 +441,7 @@ void parseSwapLowLine(line_in)
     Config.Swap.lowWaterMark = i;
 }
 
-void parseHttpLine(line_in)
+static void parseHttpLine(line_in)
      char *line_in;
 {
     char *token;
@@ -456,7 +452,7 @@ void parseHttpLine(line_in)
     Config.Http.defaultTtl = i * 60;
 }
 
-void parseGopherLine(line_in)
+static void parseGopherLine(line_in)
      char *line_in;
 {
     char *token;
@@ -467,7 +463,7 @@ void parseGopherLine(line_in)
     Config.Gopher.defaultTtl = i * 60;
 }
 
-void parseFtpLine(line_in)
+static void parseFtpLine(line_in)
      char *line_in;
 {
     char *token;
@@ -478,7 +474,7 @@ void parseFtpLine(line_in)
     Config.Ftp.defaultTtl = i * 60;
 }
 
-void parseTTLPattern(line_in)
+static void parseTTLPattern(line_in)
      char *line_in;
 {
     char *token;
@@ -512,7 +508,7 @@ void parseTTLPattern(line_in)
     safe_free(pattern);
 }
 
-void parseNegativeLine(line_in)
+static void parseNegativeLine(line_in)
      char *line_in;
 {
     char *token;
@@ -521,7 +517,7 @@ void parseNegativeLine(line_in)
     Config.negativeTtl = i * 60;
 }
 
-void parseReadTimeoutLine(line_in)
+static void parseReadTimeoutLine(line_in)
      char *line_in;
 {
     char *token;
@@ -530,7 +526,7 @@ void parseReadTimeoutLine(line_in)
     Config.readTimeout = i * 60;
 }
 
-void parseLifetimeLine(line_in)
+static void parseLifetimeLine(line_in)
      char *line_in;
 {
     char *token;
@@ -539,7 +535,7 @@ void parseLifetimeLine(line_in)
     Config.lifetimeDefault = i * 60;
 }
 
-void parseConnectTimeout(line_in)
+static void parseConnectTimeout(line_in)
      char *line_in;
 {
     char *token;
@@ -548,7 +544,7 @@ void parseConnectTimeout(line_in)
     Config.connectTimeout = i;
 }
 
-void parseCleanRateLine(line_in)
+static void parseCleanRateLine(line_in)
      char *line_in;
 {
     char *token;
@@ -557,7 +553,7 @@ void parseCleanRateLine(line_in)
     Config.cleanRate = i * 60;
 }
 
-void parseDnsChildrenLine(line_in)
+static void parseDnsChildrenLine(line_in)
      char *line_in;
 {
     char *token;
@@ -566,7 +562,7 @@ void parseDnsChildrenLine(line_in)
     Config.dnsChildren = i;
 }
 
-void parseMgrLine(line_in)
+static void parseMgrLine(line_in)
      char *line_in;
 {
     char *token;
@@ -577,7 +573,7 @@ void parseMgrLine(line_in)
     Config.adminEmail = xstrdup(token);
 }
 
-void parseDirLine(line_in)
+static void parseDirLine(line_in)
      char *line_in;
 {
     char *token;
@@ -589,7 +585,7 @@ void parseDirLine(line_in)
 
 }
 
-void parseHttpdAccelLine(line_in)
+static void parseHttpdAccelLine(line_in)
      char *line_in;
 {
     char *token;
@@ -609,7 +605,7 @@ void parseHttpdAccelLine(line_in)
     httpd_accel_mode = 1;
 }
 
-void parseHttpdAccelWithProxyLine(line_in)
+static void parseHttpdAccelWithProxyLine(line_in)
      char *line_in;
 {
     char *proxy;
@@ -627,7 +623,7 @@ void parseHttpdAccelWithProxyLine(line_in)
 	Config.Accel.withProxy = 0;
 }
 
-void parseEffectiveUserLine(line_in)
+static void parseEffectiveUserLine(line_in)
      char *line_in;
 {
     char *token;
@@ -645,21 +641,18 @@ void parseEffectiveUserLine(line_in)
     Config.effectiveGroup = xstrdup(token);
 }
 
-void parseLogLine(line_in)
+static void parseLogLine(line_in)
      char *line_in;
 {
     char *token;
-    int i;
     token = strtok(NULL, w_space);
     if (token == (char *) NULL)
 	self_destruct(line_in);
     safe_free(Config.Log.log);
     Config.Log.log = xstrdup(token);
-    GetInteger(i);
-    Config.debugLevel = i;
 }
 
-void parseAccessLogLine(line_in)
+static void parseAccessLogLine(line_in)
      char *line_in;
 {
     char *token;
@@ -670,7 +663,7 @@ void parseAccessLogLine(line_in)
     Config.Log.access = xstrdup(token);
 }
 
-void parseHierachyLogLine(line_in)
+static void parseHierachyLogLine(line_in)
      char *line_in;
 {
     char *token;
@@ -681,7 +674,7 @@ void parseHierachyLogLine(line_in)
     Config.Log.hierarchy = xstrdup(token);
 }
 
-void parseLogfileRotateLine(line_in)
+static void parseLogfileRotateLine(line_in)
      char *line_in;
 {
     char *token;
@@ -690,7 +683,7 @@ void parseLogfileRotateLine(line_in)
     Config.Log.rotateNumber = i;
 }
 
-void parseFtpProgramLine(line_in)
+static void parseFtpProgramLine(line_in)
      char *line_in;
 {
     char *token;
@@ -701,7 +694,7 @@ void parseFtpProgramLine(line_in)
     Config.Program.ftpget = xstrdup(token);
 }
 
-void parseFtpOptionsLine(line_in)
+static void parseFtpOptionsLine(line_in)
      char *line_in;
 {
     char *token;
@@ -712,7 +705,7 @@ void parseFtpOptionsLine(line_in)
     Config.Program.ftpget_opts = xstrdup(token);
 }
 
-void parseDnsProgramLine(line_in)
+static void parseDnsProgramLine(line_in)
      char *line_in;
 {
     char *token;
@@ -723,7 +716,7 @@ void parseDnsProgramLine(line_in)
     Config.Program.dnsserver = xstrdup(token);
 }
 
-void parseEmulateLine(line_in)
+static void parseEmulateLine(line_in)
      char *line_in;
 {
     char *token;
@@ -736,8 +729,7 @@ void parseEmulateLine(line_in)
 	Config.commonLogFormat = 0;
 }
 
-#if USE_WAIS_RELAY
-void parseWAISRelayLine(line_in)
+static void parseWAISRelayLine(line_in)
      char *line_in;
 {
     char *token;
@@ -753,9 +745,7 @@ void parseWAISRelayLine(line_in)
     Config.Wais.maxObjSize = i << 20;
 }
 
-#endif
-
-void parseProxyAllowLine(line_in)
+static void parseProxyAllowLine(line_in)
      char *line_in;
 {
     char *token;
@@ -765,7 +755,7 @@ void parseProxyAllowLine(line_in)
     addToIPACL(&proxy_ip_acl, token, IP_ALLOW);
 }
 
-void parseAccelAllowLine(line_in)
+static void parseAccelAllowLine(line_in)
      char *line_in;
 {
     char *token;
@@ -775,7 +765,7 @@ void parseAccelAllowLine(line_in)
     addToIPACL(&accel_ip_acl, token, IP_ALLOW);
 }
 
-void parseManagerAllowLine(line_in)
+static void parseManagerAllowLine(line_in)
      char *line_in;
 {
     char *token;
@@ -785,7 +775,7 @@ void parseManagerAllowLine(line_in)
     addToIPACL(&manager_ip_acl, token, IP_ALLOW);
 }
 
-void parseProxyDenyLine(line_in)
+static void parseProxyDenyLine(line_in)
      char *line_in;
 {
     char *token;
@@ -795,7 +785,7 @@ void parseProxyDenyLine(line_in)
     addToIPACL(&proxy_ip_acl, token, IP_DENY);
 }
 
-void parseAccelDenyLine(line_in)
+static void parseAccelDenyLine(line_in)
      char *line_in;
 {
     char *token;
@@ -805,7 +795,7 @@ void parseAccelDenyLine(line_in)
     addToIPACL(&accel_ip_acl, token, IP_DENY);
 }
 
-void parseManagerDenyLine(line_in)
+static void parseManagerDenyLine(line_in)
      char *line_in;
 {
     char *token;
@@ -815,7 +805,7 @@ void parseManagerDenyLine(line_in)
     addToIPACL(&manager_ip_acl, token, IP_DENY);
 }
 
-void parseLocalIPLine(line_in)
+static void parseLocalIPLine(line_in)
      char *line_in;
 {
     char *token;
@@ -824,7 +814,7 @@ void parseLocalIPLine(line_in)
     }
 }
 
-void parseHttpStopLine(line_in)
+static void parseHttpStopLine(line_in)
      char *line_in;
 {
     char *token;
@@ -834,7 +824,7 @@ void parseHttpStopLine(line_in)
     addToStopList(&http_stoplist, token);
 }
 
-void parseGopherStopLine(line_in)
+static void parseGopherStopLine(line_in)
      char *line_in;
 {
     char *token;
@@ -843,7 +833,7 @@ void parseGopherStopLine(line_in)
 	return;
     addToStopList(&gopher_stoplist, token);
 }
-void parseFtpStopLine(line_in)
+static void parseFtpStopLine(line_in)
      char *line_in;
 {
     char *token;
@@ -853,7 +843,7 @@ void parseFtpStopLine(line_in)
     addToStopList(&ftp_stoplist, token);
 }
 
-void parseAppendDomainLine(line_in)
+static void parseAppendDomainLine(line_in)
      char *line_in;
 {
     char *token;
@@ -866,18 +856,18 @@ void parseAppendDomainLine(line_in)
     Config.appendDomain = xstrdup(token);
 }
 
-void parseBindAddressLine(line_in)
+static void parseBindAddressLine(line_in)
      char *line_in;
 {
     char *token;
     token = strtok(NULL, w_space);
     if (token == (char *) NULL)
 	self_destruct(line_in);
-    debug(1, "parseBindAddressLine: adding %s\n", token);
+    debug(0, 1, "parseBindAddressLine: adding %s\n", token);
     addToStopList(&bind_addr_list, token);
 }
 
-void parseBlockListLine(line_in)
+static void parseBlockListLine(line_in)
      char *line_in;
 {
     char *token;
@@ -887,7 +877,7 @@ void parseBlockListLine(line_in)
     blockAddToList(token);
 }
 
-void parseLocalDomainLine(line_in)
+static void parseLocalDomainLine(line_in)
      char *line_in;
 {
     char *token;
@@ -896,7 +886,7 @@ void parseLocalDomainLine(line_in)
     }
 }
 
-void parseInsideFirewallLine(line_in)
+static void parseInsideFirewallLine(line_in)
      char *line_in;
 {
     char *token;
@@ -905,7 +895,7 @@ void parseInsideFirewallLine(line_in)
     }
 }
 
-void parseAsciiPortLine(line_in)
+static void parseAsciiPortLine(line_in)
      char *line_in;
 {
     char *token;
@@ -914,7 +904,7 @@ void parseAsciiPortLine(line_in)
     Config.Port.ascii = i;
 }
 
-void parseUdpPortLine(line_in)
+static void parseUdpPortLine(line_in)
      char *line_in;
 {
     char *token;
@@ -923,7 +913,7 @@ void parseUdpPortLine(line_in)
     Config.Port.udp = i;
 }
 
-void parseNeighborTimeout(line_in)
+static void parseNeighborTimeout(line_in)
      char *line_in;
 {
     char *token;
@@ -932,7 +922,7 @@ void parseNeighborTimeout(line_in)
     Config.neighborTimeout = i;
 }
 
-void parseSingleParentBypassLine(line_in)
+static void parseSingleParentBypassLine(line_in)
      char *line_in;
 {
     char *token;
@@ -943,48 +933,33 @@ void parseSingleParentBypassLine(line_in)
 	Config.singleParentBypass = 1;
 }
 
-void parseCacheNeighborObjLine(line_in)
-     char *line_in;
-{
-    printf("WARNING: 'cache_neighbor_obj' is no longer supported.  Please\n");
-    printf("         use 'proxy-only' on the 'cache_host' line instead now.\n");
-    fflush(stdout);
-}
-
-void parseBehindFirewallLine(line_in)
+static void parseDebugOptionsLine(line_in)
      char *line_in;
 {
-    printf("WARNING: 'behind_firewall' is no longer supported.  Please\n");
-    printf("         use the 'inside_firewall' and 'local_domain' lines\n");
-    printf("         instead now.\n");
-    fflush(stdout);
-}
-
-void parseDirectFetchLine(line_in)
-     char *line_in;
-{
-    printf("WARNING: 'direct_fetch' is no longer supported.  Please\n");
-    printf("         use the 'inside_firewall' and 'local_domain' lines\n");
-    printf("         instead now.\n");
-    fflush(stdout);
+    char *token;
+    token = strtok(NULL, "");	/* Note "", don't separate these */
+    safe_free(Config.debugOptions);
+    if (token == (char *) NULL) {
+	Config.debugOptions = NULL;
+	return;
+    }
+    Config.debugOptions = xstrdup(token);
 }
 
-/* Maybe a bit heavy handed, but parser is immune to virtually every sane
- * persons definition of white space */
-
 int parseConfigFile(file_name)
      char *file_name;
 {
-    FILE *fp = fopen(file_name, "r");
-    char *token, tmp_line[BUFSIZ];
-    char line_in[BUFSIZ];
-    char fatal_str[4096];
+    FILE *fp = NULL;
+    char *token = NULL;
+    static char tmp_line[BUFSIZ];
+    static char line_in[BUFSIZ];
+    static char fatal_str[4096];
 
     /* Initialize a few global strings, in case they aren't user defined */
 
     configSetFactoryDefaults();
 
-    if (fp == NULL) {
+    if ((fp = fopen(file_name, "r")) == NULL) {
 	sprintf(fatal_str, "Unable to open configuration file: %s", file_name);
 	fatal(fatal_str);
     }
@@ -993,11 +968,8 @@ int parseConfigFile(file_name)
 	if (line_in[0] == '#' || line_in[0] == '\n' || line_in[0] == '\0')
 	    continue;		/* skip comments */
 
-	/* Use tmp_line as a temporary pointer to the input line */
-	/* AWC Debug */
 	if (line_in[0] == '\n')
 	    continue;
-
 	strcpy(tmp_line, line_in);
 	if ((token = strtok(tmp_line, w_space)) == NULL)
 	    continue;
@@ -1016,11 +988,6 @@ int parseConfigFile(file_name)
 	else if (!strcmp(token, "neighbour_timeout"))	/* alternate spelling */
 	    parseNeighborTimeout(line_in);
 
-	/* XXX This has been replaced with proxy-only on cache-host line */
-	/* give warning if cache_neighbor_obj is used */
-	else if (!strcmp(token, "cache_neighbor_obj"))
-	    parseCacheNeighborObjLine(line_in);
-
 	/* Parse a cache_dir line */
 	else if (!strcmp(token, "cache_dir"))
 	    parseDirLine(line_in);
@@ -1094,16 +1061,6 @@ int parseConfigFile(file_name)
 	else if (!strcmp(token, "proxy_deny"))
 	    parseProxyDenyLine(line_in);
 
-#ifndef BACKWARDS_COMPATIBLE
-	/* Parse a access_allow line */
-	else if (!strcmp(token, "access_allow"))	/* now proxy_allow */
-	    parseProxyAllowLine(line_in);
-
-	/* Parse a access_deny line */
-	else if (!strcmp(token, "access_deny"))		/* now proxy_deny */
-	    parseProxyDenyLine(line_in);
-#endif
-
 	/* Parse a accel_allow line */
 	else if (!strcmp(token, "accel_allow"))
 	    parseAccelAllowLine(line_in);
@@ -1120,16 +1077,6 @@ int parseConfigFile(file_name)
 	else if (!strcmp(token, "manager_deny"))
 	    parseManagerDenyLine(line_in);
 
-#ifndef BACKWARDS_COMPATIBLE
-	/* Parse a manager_access_allow line */
-	else if (!strcmp(token, "manager_access_allow"))	/* now manager_allow */
-	    parseManagerAllowLine(line_in);
-
-	/* Parse a manager_access_deny line */
-	else if (!strcmp(token, "manager_access_deny"))		/* now manager_deny */
-	    parseManagerDenyLine(line_in);
-#endif
-
 	/* Parse a http_stop line */
 	else if (!strcmp(token, "http_stop"))
 	    parseHttpStopLine(line_in);
@@ -1208,33 +1155,19 @@ int parseConfigFile(file_name)
 	else if (!strcmp(token, "source_ping"))
 	    parseSourcePingLine(line_in);
 
-	/* Parse behind_firewall line */
-	else if (!strcmp(token, "behind_firewall"))
-	    parseBehindFirewallLine(line_in);
-
-	/* Parse direct_fetch line */
-	else if (!strcmp(token, "direct_fetch"))
-	    parseDirectFetchLine(line_in);
-
 	/* Parse quick_abort line */
 	else if (!strcmp(token, "quick_abort"))
 	    parseQuickAbortLine(line_in);
 
-	/* Parse old abort_mode line - FOR BACKWARDS COMPATIBILITY */
-	else if (!strcmp(token, "abort_mode"))
-	    parseQuickAbortLine(line_in);
-
 	/* Parse emulate_httpd_log line */
 	else if (!strcmp(token, "emulate_httpd_log"))
 	    parseEmulateLine(line_in);
 
 	else if (!strcmp(token, "append_domain"))
 	    parseAppendDomainLine(line_in);
 
-#if USE_WAIS_RELAY
 	else if (!strcmp(token, "wais_relay"))
 	    parseWAISRelayLine(line_in);
-#endif
 
 	/* Parse a local_ip line */
 	else if (!strcmp(token, "local_ip"))
@@ -1262,9 +1195,12 @@ int parseConfigFile(file_name)
 	else if (!strcmp(token, "single_parent_bypass"))
 	    parseSingleParentBypassLine(line_in);
 
+	else if (!strcmp(token, "debug_options"))
+	    parseDebugOptionsLine(line_in);
+
 	/* If unknown, treat as a comment line */
 	else {
-	    /*EMPTY */ ;
+	    /* EMPTY */ ;
 	}
     }
 
@@ -1318,58 +1254,6 @@ int parseConfigFile(file_name)
 }
 
 
-/* 
- * Daemonize a process according to guidlines in "Advanced Programming
- * For The UNIX Environment", W.R. Stevens ( Addison Wesley, 1992) - Ch. 13
- */
-int daemonize()
-{
-    int n_openf, i;
-    pid_t pid;
-
-
-    if ((pid = fork()) < 0)
-	return (-1);
-    else if (pid != 0)
-	exit(0);
-
-    /* Child continues */
-    setsid();			/* Become session leader */
-
-    n_openf = getMaxFD();	/* Close any inherited files */
-    for (i = 0; i < n_openf; i++)
-	close(i);
-
-    umask(0);			/* Clear file mode creation mask */
-
-    return (0);
-}
-
-
-int check_suid()
-{
-    struct passwd *pwd;
-    struct group *grp;
-
-    if (geteuid() == 0) {
-	/* Started as a root, check suid option */
-	if (Config.effectiveUser && (pwd = getpwnam(Config.effectiveUser))) {
-
-	    /* change current directory to swap space so we can get core */
-	    if (chdir(swappath(0))) {
-		debug(1, "Chdir Failed: Cached cannot write core file when it crash: %s\n",
-		    xstrerror());
-	    }
-	    if (Config.effectiveGroup && (grp = getgrnam(Config.effectiveGroup))) {
-		setgid(grp->gr_gid);
-	    } else {
-		setgid(pwd->pw_gid);
-	    }
-	    setuid(pwd->pw_uid);
-	}
-    }
-    return 0;
-}
 
 int getHttpMax()
 {
@@ -1391,7 +1275,6 @@ int getGopherTTL()
     return Config.Gopher.defaultTtl;
 }
 
-#if USE_WAIS_RELAY
 int getWAISMax()
 {
     return Config.Wais.maxObjSize;
@@ -1404,7 +1287,6 @@ int getWaisRelayPort()
 {
     return Config.Wais.relayPort;
 }
-#endif
 
 int getFtpMax()
 {
@@ -1550,9 +1432,9 @@ char *getAdminEmail()
 {
     return Config.adminEmail;
 }
-int getDebugLevel()
+char *getDebugOptions()
 {
-    return Config.debugLevel;
+    return Config.debugOptions;
 }
 int getStallDelay()
 {
@@ -1562,6 +1444,14 @@ char *getAppendDomain()
 {
     return Config.appendDomain;
 }
+char *getEffectiveUser()
+{
+    return Config.effectiveUser;
+}
+char *getEffectiveGroup()
+{
+    return Config.effectiveGroup;
+}
 int setAsciiPortNum(p)
      int p;
 {
@@ -1607,12 +1497,10 @@ static void configSetFactoryDefaults()
     Config.Gopher.maxObjSize = DefaultGopherMaxObjSize;
     Config.Http.defaultTtl = DefaultHttpDefaultTtl;
     Config.Http.maxObjSize = DefaultHttpMaxObjSize;
-#if USE_WAIS_RELAY
     Config.Wais.defaultTtl = DefaultWaisDefaultTtl;
     Config.Wais.maxObjSize = DefaultWaisMaxObjSize;
     Config.Wais.relayHost = safe_xstrdup(DefaultWaisRelayHost);
     Config.Wais.relayPort = DefaultWaisRelayPort;
-#endif
 
     Config.negativeTtl = DefaultNegativeTtl;
     Config.readTimeout = DefaultReadTimeout;
@@ -1625,7 +1513,7 @@ static void configSetFactoryDefaults()
     Config.sourcePing = DefaultSourcePing;
     Config.quickAbort = DefaultQuickAbort;
     Config.commonLogFormat = DefaultCommonLogFormat;
-    Config.debugLevel = DefaultDebugLevel;
+    Config.debugOptions = safe_xstrdup(DefaultDebugOptions);
     Config.neighborTimeout = DefaultNeighborTimeout;
     Config.stallDelay = DefaultStallDelay;
     Config.singleParentBypass = DefaultSingleParentBypass;
@@ -1,5 +1,5 @@
 
-/* $Id: comm.cc,v 1.8 1996/03/27 01:45:57 wessels Exp $ */
+/* $Id: comm.cc,v 1.9 1996/03/27 18:15:41 wessels Exp $ */
 
 #include "squid.h"
 
@@ -43,7 +43,7 @@ extern int fd_of_first_client _PARAMS((StoreEntry *));
 void comm_handler()
 {
     /* Call application installed handler. */
-    debug(5, "comm_handler:\n");
+    debug(0, 5, "comm_handler:\n");
     app_handler();
 }
 
@@ -59,15 +59,15 @@ int comm_port(fd)
 
     /* If the fd is closed already, just return */
     if (!fd_table[fd].openned) {
-	debug(0, "comm_port: FD %d has been closed.\n", fd);
+	debug(0, 0, "comm_port: FD %d has been closed.\n", fd);
 	return (COMM_ERROR);
     }
     addr_len = sizeof(addr);
     if (getsockname(fd, (struct sockaddr *) &addr, &addr_len)) {
-	debug(1, "comm_port: Failed to retrieve TCP/UDP port number for socket: FD %d: %s\n", fd, xstrerror());
+	debug(0, 1, "comm_port: Failed to retrieve TCP/UDP port number for socket: FD %d: %s\n", fd, xstrerror());
 	return (COMM_ERROR);
     }
-    debug(6, "comm_port: FD %d: sockaddr %u.\n", fd, addr.sin_addr.s_addr);
+    debug(0, 6, "comm_port: FD %d: sockaddr %u.\n", fd, addr.sin_addr.s_addr);
     fd_table[fd].port = ntohs(addr.sin_port);
 
     return fd_table[fd].port;
@@ -83,7 +83,7 @@ static int do_bind(s, host, port)
 
     addr = getAddress(host);
     if (addr == (struct in_addr *) NULL) {
-	debug(0, "do_bind: Unknown host: %s\n", host);
+	debug(0, 0, "do_bind: Unknown host: %s\n", host);
 	return COMM_ERROR;
     }
     memset(&S, '\0', sizeof(S));
@@ -94,7 +94,7 @@ static int do_bind(s, host, port)
     if (bind(s, (struct sockaddr *) &S, sizeof(S)) == 0)
 	return COMM_OK;
 
-    debug(0, "do_bind: Cannot bind socket FD %d to %s:%d: %s\n",
+    debug(0, 0, "do_bind: Cannot bind socket FD %d to %s:%d: %s\n",
 	s,
 	S.sin_addr.s_addr == htonl(INADDR_ANY) ? "*" : inet_ntoa(S.sin_addr),
 	port, xstrerror());
@@ -122,11 +122,11 @@ int comm_open(io_type, port, handler, note)
 	switch (errno) {
 	case ENFILE:
 	case EMFILE:
-	    debug(1, "comm_open: socket failure: %s\n", xstrerror());
+	    debug(0, 1, "comm_open: socket failure: %s\n", xstrerror());
 	    Reserve_More_FDs();
 	    break;
 	default:
-	    debug(0, "comm_open: socket failure: %s\n", xstrerror());
+	    debug(0, 0, "comm_open: socket failure: %s\n", xstrerror());
 	}
 	return (COMM_ERROR);
     }
@@ -139,12 +139,12 @@ int comm_open(io_type, port, handler, note)
     conn->openned = 1;
 
     if (fcntl(new_socket, F_SETFD, 1) < 0) {
-	debug(0, "comm_open: FD %d: failed to set close-on-exec flag: %s\n",
+	debug(0, 0, "comm_open: FD %d: failed to set close-on-exec flag: %s\n",
 	    new_socket, xstrerror());
     }
     if (port > 0) {
 	if (commSetNoLinger(new_socket) < 0) {
-	    debug(0, "comm_open: failed to turn off SO_LINGER: %s\n",
+	    debug(0, 0, "comm_open: failed to turn off SO_LINGER: %s\n",
 		xstrerror());
 	}
 	if (do_reuse) {
@@ -168,13 +168,13 @@ int comm_open(io_type, port, handler, note)
 	 */
 #if defined(O_NONBLOCK) && !defined(_SQUID_SUNOS_) && !defined(_SQUID_SOLARIS_)
 	if (fcntl(new_socket, F_SETFL, O_NONBLOCK)) {
-	    debug(0, "comm_open: FD %d: Failure to set O_NONBLOCK: %s\n",
+	    debug(0, 0, "comm_open: FD %d: Failure to set O_NONBLOCK: %s\n",
 		new_socket, xstrerror());
 	    return (COMM_ERROR);
 	}
 #else
 	if (fcntl(new_socket, F_SETFL, FNDELAY)) {
-	    debug(0, "comm_open: FD %d: Failure to set FNDELAY: %s\n",
+	    debug(0, 0, "comm_open: FD %d: Failure to set FNDELAY: %s\n",
 		new_socket, xstrerror());
 	    return (COMM_ERROR);
 	}
@@ -197,7 +197,7 @@ int comm_listen(sock)
     int x;
     FD_SET(sock, &receive_sockets);
     if ((x = listen(sock, 50)) < 0) {
-	debug(0, "comm_listen: listen(%d, 50): %s\n",
+	debug(0, 0, "comm_listen: listen(%d, 50): %s\n",
 	    sock, xstrerror());
 	return x;
     }
@@ -218,7 +218,7 @@ int comm_connect(sock, dest_host, dest_port)
     to_addr.sin_family = AF_INET;
 
     if ((hp = ipcache_gethostbyname(dest_host)) == 0) {
-	debug(1, "comm_connect: Failure to lookup host: %s.\n", dest_host);
+	debug(0, 1, "comm_connect: Failure to lookup host: %s.\n", dest_host);
 	return (COMM_ERROR);
     }
     memcpy(&to_addr.sin_addr, hp->h_addr, hp->h_length);
@@ -265,7 +265,7 @@ int comm_connect_addr(sock, address)
 
     /* sanity check */
     if (ntohs(address->sin_port) == 0) {
-	debug(10, "comm_connect_addr: %s:%d: URL uses port 0?\n",
+	debug(0, 10, "comm_connect_addr: %s:%d: URL uses port 0?\n",
 	    inet_ntoa(address->sin_addr), ntohs(address->sin_port));
 	errno = 0;
 	return COMM_ERROR;
@@ -287,7 +287,7 @@ int comm_connect_addr(sock, address)
 	    if (getsockopt(sock, SOL_SOCKET, SO_ERROR, (char *) &x, &len) >= 0)
 		errno = x;
 	default:
-	    debug(1, "comm_connect_addr: %s:%d: socket failure: %s.\n",
+	    debug(0, 1, "comm_connect_addr: %s:%d: socket failure: %s.\n",
 		inet_ntoa(address->sin_addr),
 		ntohs(address->sin_port),
 		xstrerror());
@@ -296,12 +296,12 @@ int comm_connect_addr(sock, address)
     /* set the lifetime for this client */
     if (status == COMM_OK) {
 	lft = comm_set_fd_lifetime(sock, getClientLifetime());
-	debug(10, "comm_connect_addr: FD %d (lifetime %d): connected to %s:%d.\n",
+	debug(0, 10, "comm_connect_addr: FD %d (lifetime %d): connected to %s:%d.\n",
 	    sock, lft, inet_ntoa(address->sin_addr),
 	    ntohs(address->sin_port));
     } else if (status == EINPROGRESS) {
 	lft = comm_set_fd_lifetime(sock, getConnectTimeout());
-	debug(10, "comm_connect_addr: FD %d connection pending, lifetime %d\n",
+	debug(0, 10, "comm_connect_addr: FD %d connection pending, lifetime %d\n",
 	    sock, lft);
     }
     /* Add new socket to list of open sockets. */
@@ -339,7 +339,7 @@ int comm_accept(fd, peer, me)
 	    Reserve_More_FDs();
 	    return COMM_ERROR;
 	default:
-	    debug(1, "comm_accept: FD %d: accept failure: %s\n",
+	    debug(0, 1, "comm_accept: FD %d: accept failure: %s\n",
 		fd, xstrerror());
 	    return COMM_ERROR;
 	}
@@ -376,7 +376,7 @@ int comm_close(fd)
 	return -1;
 
     if (fdstat_type(fd) == File) {
-	debug(0, "FD %d: Someone called comm_close() on a File\n", fd);
+	debug(0, 0, "FD %d: Someone called comm_close() on a File\n", fd);
 	fatal_dump(NULL);
     }
     conn = &fd_table[fd];
@@ -385,7 +385,7 @@ int comm_close(fd)
     FD_CLR(fd, &send_sockets);
 
     comm_set_fd_lifetime(fd, -1);	/* invalidate the lifetime */
-    debug(10, "comm_close: FD %d\n", fd);
+    debug(0, 10, "comm_close: FD %d\n", fd);
     /* update fdstat */
     fdstat_close(fd);
     memset(conn, '\0', sizeof(FD_ENTRY));
@@ -420,15 +420,15 @@ int comm_udp_send(fd, host, port, buf, len)
     to_addr.sin_family = AF_INET;
 
     if ((hp = ipcache_gethostbyname(host)) == 0) {
-	debug(1, "comm_udp_send: gethostbyname failure: %s: %s\n",
+	debug(0, 1, "comm_udp_send: gethostbyname failure: %s: %s\n",
 	    host, xstrerror());
 	return (COMM_ERROR);
     }
     memcpy(&to_addr.sin_addr, hp->h_addr, hp->h_length);
     to_addr.sin_port = htons(port);
     if ((bytes_sent = sendto(fd, buf, len, 0, (struct sockaddr *) &to_addr,
 		sizeof(to_addr))) < 0) {
-	debug(1, "comm_udp_send: sendto failure: FD %d: %s\n",
+	debug(0, 1, "comm_udp_send: sendto failure: FD %d: %s\n",
 	    fd, xstrerror());
 	return COMM_ERROR;
     }
@@ -446,10 +446,10 @@ int comm_udp_sendto(fd, to_addr, addr_len, buf, len)
     int bytes_sent;
 
     if ((bytes_sent = sendto(fd, buf, len, 0, (struct sockaddr *) to_addr, addr_len)) < 0) {
-	debug(1, "comm_udp_sendto: sendto failure: FD %d: %s\n", fd, xstrerror());
-	debug(1, "comm_udp_sendto: --> sin_family = %d\n", to_addr->sin_family);
-	debug(1, "comm_udp_sendto: --> sin_port   = %d\n", htons(to_addr->sin_port));
-	debug(1, "comm_udp_sendto: --> sin_addr   = %s\n", inet_ntoa(to_addr->sin_addr));
+	debug(0, 1, "comm_udp_sendto: sendto failure: FD %d: %s\n", fd, xstrerror());
+	debug(0, 1, "comm_udp_sendto: --> sin_family = %d\n", to_addr->sin_family);
+	debug(0, 1, "comm_udp_sendto: --> sin_port   = %d\n", htons(to_addr->sin_port));
+	debug(0, 1, "comm_udp_sendto: --> sin_addr   = %s\n", inet_ntoa(to_addr->sin_addr));
 	return COMM_ERROR;
     }
     return bytes_sent;
@@ -465,7 +465,7 @@ int comm_udp_recv(fd, buf, size, from_addr, from_size)
     int len = recvfrom(fd, buf, size, 0, (struct sockaddr *) from_addr,
 	from_size);
     if (len < 0) {
-	debug(1, "comm_udp_recv: recvfrom failure: FD %d: %s\n", fd,
+	debug(0, 1, "comm_udp_recv: recvfrom failure: FD %d: %s\n", fd,
 	    xstrerror());
 	return COMM_ERROR;
     }
@@ -538,15 +538,15 @@ int comm_select(sec, usec, failtime)
 		break;
 
 	    if (errno != EINTR) {
-		debug(0, "comm_select: select failure: %s (errno %d).\n",
+		debug(0, 0, "comm_select: select failure: %s (errno %d).\n",
 		    xstrerror(), errno);
 		examine_select(&readfds, &writefds, &exceptfds);
 		return COMM_ERROR;
 	    }
 	    /* if select interrupted, try again */
 	}
 
-	debug(num ? 5 : 8, "comm_select: %d sockets ready at %d\n",
+	debug(0, num ? 5 : 8, "comm_select: %d sockets ready at %d\n",
 	    num, cached_curtime);
 
 	/* Check lifetime and timeout handlers ONCE each second.
@@ -615,31 +615,31 @@ int comm_select(sec, usec, failtime)
 		    continue;
 
 		if (FD_ISSET(fd, &readfds)) {
-		    debug(6, "comm_select: FD %d ready for reading\n", fd);
+		    debug(0, 6, "comm_select: FD %d ready for reading\n", fd);
 		    if (fd_table[fd].read_handler) {
 			int (*tmp) () = fd_table[fd].read_handler;
 			fd_table[fd].read_handler = 0;
-			debug(10, "calling read handler %p(%d,%p)\n",
+			debug(0, 10, "calling read handler %p(%d,%p)\n",
 			    tmp, fd, fd_table[fd].read_data);
 			tmp(fd, fd_table[fd].read_data);
 		    }
 		}
 		if (FD_ISSET(fd, &writefds)) {
-		    debug(5, "comm_select: FD %d ready for writing\n", fd);
+		    debug(0, 5, "comm_select: FD %d ready for writing\n", fd);
 		    if (fd_table[fd].write_handler) {
 			int (*tmp) () = fd_table[fd].write_handler;
 			fd_table[fd].write_handler = 0;
-			debug(10, "calling write handler %p(%d,%p)\n",
+			debug(0, 10, "calling write handler %p(%d,%p)\n",
 			    tmp, fd, fd_table[fd].write_data);
 			tmp(fd, fd_table[fd].write_data);
 		    }
 		}
 		if (FD_ISSET(fd, &exceptfds)) {
-		    debug(5, "comm_select: FD %d has an exception\n", fd);
+		    debug(0, 5, "comm_select: FD %d has an exception\n", fd);
 		    if (fd_table[fd].except_handler) {
 			int (*tmp) () = fd_table[fd].except_handler;
 			fd_table[fd].except_handler = 0;
-			debug(10, "calling except handler %p(%d,%p)\n",
+			debug(0, 10, "calling except handler %p(%d,%p)\n",
 			    tmp, fd, fd_table[fd].except_data);
 			tmp(fd, fd_table[fd].except_data);
 		    }
@@ -649,7 +649,7 @@ int comm_select(sec, usec, failtime)
 	}
     }
 
-    debug(8, "comm_select: time out: %d.\n", cached_curtime);
+    debug(0, 8, "comm_select: time out: %d.\n", cached_curtime);
     return COMM_TIMEOUT;
 }
 
@@ -682,12 +682,12 @@ int comm_pending(fd, sec, usec)
 	case EINTR:
 	    break;		/* if select interrupted, try again */
 	default:
-	    debug(1, "comm_pending: select failure: %s\n", xstrerror());
+	    debug(0, 1, "comm_pending: select failure: %s\n", xstrerror());
 	    return COMM_ERROR;
 	}
     }
 
-    debug(5, "comm_pending: %d sockets ready for reading\n", num);
+    debug(0, 5, "comm_pending: %d sockets ready for reading\n", num);
 
     if (num && FD_ISSET(fd, &readfds)) {
 	return COMM_OK;
@@ -721,7 +721,7 @@ int comm_set_select_handler_plus_timeout(fd, type, handler, client_data, timeout
 	fd_table[fd].timeout_handler = handler;
 	fd_table[fd].timeout_data = client_data;
 	if ((timeout <= 0) && handler) {
-	    debug(2, "comm_set_select_handler_plus_timeout: Zero timeout doesn't make sense\n");
+	    debug(0, 2, "comm_set_select_handler_plus_timeout: Zero timeout doesn't make sense\n");
 	}
     }
     if (type & COMM_SELECT_READ) {
@@ -781,7 +781,7 @@ static int commSetNoLinger(fd)
     L.l_onoff = 0;		/* off */
     L.l_linger = 0;
 
-    debug(10, "commSetNoLinger: turning off SO_LINGER on FD %d\n", fd);
+    debug(0, 10, "commSetNoLinger: turning off SO_LINGER on FD %d\n", fd);
     return setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L));
 }
 
@@ -791,17 +791,17 @@ static int commSetReuseAddr(fd)
     int on = 1;
     int rc;
 
-    debug(10, "commSetReuseAddr: turning on SO_REUSEADDR on FD %d\n", fd);
+    debug(0, 10, "commSetReuseAddr: turning on SO_REUSEADDR on FD %d\n", fd);
     rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));
     if (rc < 0)
-	debug(1, "commSetReuseAddr: FD=%d: %s\n", fd, xstrerror());
+	debug(0, 1, "commSetReuseAddr: FD=%d: %s\n", fd, xstrerror());
     return rc;
 }
 
 int commSetNonBlocking(fd)
      int fd;
 {
-    debug(10, "commSetNonBlocking: setting FD %d to non-blocking i/o.\n",
+    debug(0, 10, "commSetNonBlocking: setting FD %d to non-blocking i/o.\n",
 	fd);
     /*
      * Set up the flag NOT to have the socket to wait for message from
@@ -810,13 +810,13 @@ int commSetNonBlocking(fd)
 
 #if defined(O_NONBLOCK) && !defined(_SQUID_SUNOS_) && !defined(_SQUID_SOLARIS_)
     if (fcntl(fd, F_SETFL, O_NONBLOCK)) {
-	debug(0, "comm_open: FD %d: error setting O_NONBLOCK: %s\n",
+	debug(0, 0, "comm_open: FD %d: error setting O_NONBLOCK: %s\n",
 	    fd, xstrerror());
 	return (COMM_ERROR);
     }
 #else
     if (fcntl(fd, F_SETFL, FNDELAY)) {
-	debug(0, "comm_open: FD %d: error setting FNDELAY: %s\n",
+	debug(0, 0, "comm_open: FD %d: error setting FNDELAY: %s\n",
 	    fd, xstrerror());
 	return (COMM_ERROR);
     }
@@ -832,7 +832,7 @@ char **getAddressList(name)
 	return NULL;
     if ((hp = ipcache_gethostbyname(name)))
 	return hp->h_addr_list;
-    debug(0, "getAddress: gethostbyname failure: %s: %s\n",
+    debug(0, 0, "getAddress: gethostbyname failure: %s: %s\n",
 	name, xstrerror());
     return NULL;
 }
@@ -848,7 +848,7 @@ struct in_addr *getAddress(name)
 	memcpy(&first.s_addr, *list, 4);
 	return (&first);
     }
-    debug(0, "getAddress: gethostbyname failure: %s: %s\n",
+    debug(0, 0, "getAddress: gethostbyname failure: %s: %s\n",
 	name, xstrerror());
     return NULL;
 }
@@ -896,7 +896,7 @@ static int examine_select(readfds, writefds, exceptfds)
     int num;
     struct timeval tv;
 
-    debug(0, "examine_select: Examining open file descriptors...\n");
+    debug(0, 0, "examine_select: Examining open file descriptors...\n");
     for (fd = 0; fd < getMaxFD(); ++fd) {
 	FD_ZERO(&read_x);
 	FD_ZERO(&write_x);
@@ -908,8 +908,8 @@ static int examine_select(readfds, writefds, exceptfds)
 	    FD_SET(fd, &read_x);
 	    num = select(FD_SETSIZE, &read_x, &read_x, &read_x, &tv);
 	    if (num < 0) {
-		debug(0, "WARNING: FD %d has handlers, but it's invalid.\n", fd);
-		debug(0, "Timeout handler:%x read:%x write:%x except:%x\n",
+		debug(0, 0, "WARNING: FD %d has handlers, but it's invalid.\n", fd);
+		debug(0, 0, "Timeout handler:%x read:%x write:%x except:%x\n",
 		    fd_table[fd].timeout_handler,
 		    fd_table[fd].read_handler,
 		    fd_table[fd].write_handler,
@@ -924,7 +924,7 @@ static int examine_select(readfds, writefds, exceptfds)
 	    }
 	}
     }
-    debug(0, "examine_select: Finished examining open file descriptors.\n");
+    debug(0, 0, "examine_select: Finished examining open file descriptors.\n");
     return 0;
 }
 
@@ -946,7 +946,7 @@ static void checkTimeouts()
 	if ((fd_table[fd].timeout_handler) &&
 	    (fd_table[fd].timeout_time <= cached_curtime)) {
 	    int (*tmp) () = fd_table[fd].timeout_handler;
-	    debug(5, "comm_select: timeout on socket %d at %d\n",
+	    debug(0, 5, "comm_select: timeout on socket %d at %d\n",
 		fd, cached_curtime);
 	    fd_table[fd].timeout_handler = 0;
 	    tmp(fd, fd_table[fd].timeout_data);
@@ -986,15 +986,15 @@ static void checkLifetimes()
 	    }
 	    if (tmp_local) {
 		if (use_lifetime_handler) {
-		    debug(2, "comm_select: FD %d lifetime expire: %d < %d (Lifetime handler %p)\n",
+		    debug(0, 2, "comm_select: FD %d lifetime expire: %d < %d (Lifetime handler %p)\n",
 			fd, lft, cached_curtime, tmp_local);
 		} else {
-		    debug(2, "comm_select: FD %d lifetime expire: %d < %d (%s handler %p)\n",
+		    debug(0, 2, "comm_select: FD %d lifetime expire: %d < %d (%s handler %p)\n",
 			fd, lft, cached_curtime,
 			use_read ? "read" : "write", tmp_local);
 		}
 	    } else {
-		debug(1, "comm_select: FD %d lifetime expire: %d < %d (handler not available.)\n",
+		debug(0, 1, "comm_select: FD %d lifetime expire: %d < %d (handler not available.)\n",
 		    fd, lft, cached_curtime);
 	    }
 
@@ -1012,20 +1012,20 @@ static void checkLifetimes()
 		}
 		if (fd_table[fd].openned) {
 		    /* hmm.. still openned. do full comm_close */
-		    debug(5, "comm_select: FD %d lifetime expire: %d < %d : Handler did not close the socket.\n comm_select will do.\n",
+		    debug(0, 5, "comm_select: FD %d lifetime expire: %d < %d : Handler did not close the socket.\n comm_select will do.\n",
 			fd, lft, cached_curtime);
 		    comm_close(fd);
 		} else {
 		    /* seems like handle closed it. 
 		     * clean up fd_table just to make sure */
-		    debug(5, "comm_select: FD %d lifetime expire: %d : Handler closed the socket.\n",
+		    debug(0, 5, "comm_select: FD %d lifetime expire: %d : Handler closed the socket.\n",
 			fd, lft);
 		    /* just to make sure here */
 		    comm_cleanup_fd_entry(fd);
 		}
 	    } else {
 		/* no handle. do full comm_close */
-		debug(5, "comm_select: FD %d lifetime expire: %d < %d : No handler to close the socket.\n comm_select will do.\n",
+		debug(0, 5, "comm_select: FD %d lifetime expire: %d < %d : No handler to close the socket.\n comm_select will do.\n",
 		    fd, lft, cached_curtime);
 		comm_close(fd);
 	    }
@@ -1042,7 +1042,7 @@ static void Reserve_More_FDs()
 	RESERVED_FD = RESERVED_FD + 1;
     } else if (RESERVED_FD == getMaxFD() - 64) {
 	RESERVED_FD = RESERVED_FD + 1;
-	debug(0, "Don't you have a tiny open-file table size of %d\n",
+	debug(0, 0, "Don't you have a tiny open-file table size of %d\n",
 	    getMaxFD() - RESERVED_FD);
     }
 }
@@ -1,109 +1,129 @@
-/* $Id: debug.cc,v 1.4 1996/03/27 05:12:38 wessels Exp $ */
+/* $Id: debug.cc,v 1.5 1996/03/27 18:15:42 wessels Exp $ */
 
 #include "squid.h"
 
-extern int getLogfileRotateNumber _PARAMS((void));
-
-static char *_db_modules = 0;	/* colon separated list of modules to debug. */
-int _db_level = 0;
 char *_db_file = __FILE__;
 int _db_line = 0;
 
-extern char *mkrfc850();
-extern int unbuffered_logs;	/* main.c */
-
 int syslog_enable = 0;
 int stderr_enable = 0;
 FILE *debug_log = NULL;
 static char *debug_log_file = NULL;
 static time_t last_cached_curtime = 0;
 static char the_time[81];
 
+#define MAX_DEBUG_SECTIONS 50
+static int debugLevels[MAX_DEBUG_SECTIONS];
+
 #if defined(__STRICT_ANSI__)
-void _db_print(int level,...)
+void _db_print(int section,...)
 {
-    char *format;
     va_list args;
 #else
 void _db_print(va_alist)
      va_dcl
 {
-    char *format;
-    int level;
     va_list args;
+    int section;
 #endif
+    int level;
+    char *format = NULL;
     static char f[BUFSIZ];
     static char tmpbuf[BUFSIZ];
-    char *module = NULL;
     char *s = NULL;
 
     if (debug_log == NULL)
 	return;
 
 #if defined(__STRICT_ANSI__)
-    /* strict ANSI compliance requires the second arg to va_start - we don't */
-    va_start(args, level);
-    format = va_arg(args, char *);
+    va_start(args, section);
 #else
     va_start(args);
+    section = va_arg(args, int);
+#endif
     level = va_arg(args, int);
     format = va_arg(args, char *);
-#endif
 
-    /* Obtain module name from filename. */
-    if ((module = strrchr(_db_file, '/')) != NULL)
-	module++;
-    else
-	module = _db_file;
-
-    if (_db_level >= level) {
-	if (!_db_modules || strstr(_db_modules, module)) {
-	    /* don't compute the curtime too much */
-	    if (last_cached_curtime != cached_curtime) {
-		last_cached_curtime = cached_curtime;
-		the_time[0] = '\0';
-		s = mkhttpdlogtime(&cached_curtime);
-		strcpy(the_time, s);
-	    }
-	    sprintf(f, "[%s] %s:%d:\t %s", the_time, module, _db_line, format);
+    if (debugLevels[section] > level) {
+	va_end(args);
+	return;
+    }
+    /* don't compute the curtime too much */
+    if (last_cached_curtime != cached_curtime) {
+	last_cached_curtime = cached_curtime;
+	the_time[0] = '\0';
+	s = mkhttpdlogtime(&cached_curtime);
+	strcpy(the_time, s);
+    }
+    sprintf(f, "[%s] %s:%d:\t %s",
+	the_time,
+	_db_file,
+	_db_line,
+	format);
 
 #if HAVE_SYSLOG
-	    /* level 0 go to syslog */
-	    if ((level == 0) && syslog_enable) {
-		tmpbuf[0] = '\0';
-		vsprintf(tmpbuf, f, args);
-		syslog(LOG_ERR, tmpbuf);
-	    }
+    /* level 0 go to syslog */
+    if ((level == 0) && syslog_enable) {
+	tmpbuf[0] = '\0';
+	vsprintf(tmpbuf, f, args);
+	syslog(LOG_ERR, tmpbuf);
+    }
 #endif /* HAVE_SYSLOG */
-	    /* write to log file */
-	    vfprintf(debug_log, f, args);
-	    if (unbuffered_logs)
-		fflush(debug_log);
-
-	    /* if requested, dump it to stderr also */
-	    if (stderr_enable) {
-		vfprintf(stderr, f, args);
-		fflush(stderr);
-	    }
-	}
+    /* write to log file */
+    vfprintf(debug_log, f, args);
+    if (unbuffered_logs)
+	fflush(debug_log);
+
+    /* if requested, dump it to stderr also */
+    if (stderr_enable) {
+	vfprintf(stderr, f, args);
+	fflush(stderr);
     }
     va_end(args);
 }
 
-void _db_init(prefix, initial_level, logfile)
+static void debugArg(arg)
+	char *arg;
+{
+	int s = 0;
+	int l = 0;
+	int i;
+
+	if (!strncasecmp(arg, "ALL", 3)) {
+		s = -1;
+		arg += 4;
+	} else {
+		s = atoi(arg);
+		while (*arg && *arg++ != ',');
+	}
+	l = atoi (arg);
+
+	if (s >= 0) {
+		debugLevels[s] = l;
+		return;
+	}
+	for (i = 0; i < MAX_DEBUG_SECTIONS; i++)
+        	debugLevels[i] = l;
+}
+
+void _db_init(prefix, logfile)
      char *prefix;
-     int initial_level;
      char *logfile;
 {
-    char *db_level_str, db_buf[MAXPATHLEN];
+    int i;
+    char *p = NULL;
+    char *s = NULL;
 
-    sprintf(db_buf, "%s_debug_level", prefix);
-    if ((db_level_str = getenv(db_buf)) != NULL)
-	_db_level = atoi(db_level_str);
-    else
-	_db_level = initial_level;
+    for (i = 0; i < MAX_DEBUG_SECTIONS; i++)
+	debugLevels[i] = -1;
 
-    _db_modules = getenv("DHT_DEBUG_MODULES");
+    if ((p = getDebugOptions())) {
+	p = xstrdup(p);
+	for (s=strtok(p, w_space); s; s=strtok(NULL, w_space)) {
+	    debugArg(s);
+	}
+	xfree(p);
+    }
 
     /* open error logging file */
     if (logfile != NULL) {
@@ -125,7 +145,6 @@ void _db_init(prefix, initial_level, logfile)
 	fprintf(stderr, "         messages will be sent to 'stderr'.\n");
 	fflush(stderr);
 	debug_log = stderr;
-	/* avoid reduntancy */
 	stderr_enable = 0;
     }
 
@@ -1,4 +1,4 @@
-/* $Id: disk.cc,v 1.4 1996/03/27 01:45:59 wessels Exp $ */
+/* $Id: disk.cc,v 1.5 1996/03/27 18:15:43 wessels Exp $ */
 
 #include "squid.h"
 
@@ -111,7 +111,7 @@ int file_open(path, handler, mode)
 
     /* Open file */
     if ((fd = open(path, mode | O_NDELAY, 0644)) < 0) {
-	debug(0, "file_open: error opening file %s: %s\n",
+	debug(0, 0, "file_open: error opening file %s: %s\n",
 	    path, xstrerror());
 	return (DISK_ERROR);
     }
@@ -138,13 +138,13 @@ int file_open(path, handler, mode)
     /* set non-blocking mode */
 #if defined(O_NONBLOCK) && !defined(_SQUID_SUNOS_) && !defined(_SQUID_SOLARIS_)
     if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {
-	debug(0, "file_open: FD %d: Failure to set O_NONBLOCK: %s\n",
+	debug(0, 0, "file_open: FD %d: Failure to set O_NONBLOCK: %s\n",
 	    fd, xstrerror());
 	return DISK_ERROR;
     }
 #else
     if (fcntl(fd, F_SETFL, FNDELAY) < 0) {
-	debug(0, "file_open: FD %d: Failure to set FNDELAY: %s\n",
+	debug(0, 0, "file_open: FD %d: Failure to set FNDELAY: %s\n",
 	    fd, xstrerror());
 	return DISK_ERROR;
     }
@@ -209,7 +209,7 @@ int file_close(fd)
 	file_table[fd].filename[0] = '\0';
 
 	if (fdstat_type(fd) == Socket) {
-	    debug(0, "FD %d: Someone called file_close() on a socket\n", fd);
+	    debug(0, 0, "FD %d: Someone called file_close() on a socket\n", fd);
 	    fatal_dump(NULL);
 	}
 	/* update fdstat */
@@ -249,7 +249,7 @@ int file_write_lock(fd)
      int fd;
 {
     if (file_table[fd].write_lock == LOCK) {
-	debug(0, "trying to lock a locked file\n");
+	debug(0, 0, "trying to lock a locked file\n");
 	return DISK_WRT_LOCK_FAIL;
     } else {
 	file_table[fd].write_lock = LOCK;
@@ -269,7 +269,7 @@ int file_write_unlock(fd, access_code)
 	file_table[fd].write_lock = UNLOCK;
 	return DISK_OK;
     } else {
-	debug(0, "trying to unlock the file with the wrong access code\n");
+	debug(0, 0, "trying to unlock the file with the wrong access code\n");
 	return DISK_WRT_WRONG_CODE;
     }
 }
@@ -308,7 +308,7 @@ int diskHandleWrite(fd, entry)
 		return DISK_OK;
 	    default:
 		/* disk i/o failure--flushing all outstanding writes  */
-		debug(1, "diskHandleWrite: disk write error %s\n",
+		debug(0, 1, "diskHandleWrite: disk write error %s\n",
 		    xstrerror());
 		entry->write_daemon = NOT_PRESENT;
 		entry->write_pending = NO_WRT_PENDING;
@@ -404,7 +404,7 @@ int file_write(fd, ptr_to_buf, len, access_code, handle, handle_data)
     }
     if ((file_table[fd].write_lock == LOCK) &&
 	(file_table[fd].access_code != access_code)) {
-	debug(0, "file write: access code checked failed. Sync problem.\n");
+	debug(0, 0, "file write: access code checked failed. Sync problem.\n");
 	return DISK_WRT_WRONG_CODE;
     }
     /* if we got here. Caller is eligible to write. */
@@ -460,7 +460,7 @@ int diskHandleRead(fd, ctrl_dat)
 	case EWOULDBLOCK:
 	    break;
 	default:
-	    debug(1, "diskHandleRead: FD %d: error reading: %s\n",
+	    debug(0, 1, "diskHandleRead: FD %d: error reading: %s\n",
 		fd, xstrerror());
 	    ctrl_dat->handler(fd, ctrl_dat->buf,
 		ctrl_dat->cur_len, DISK_ERROR,
@@ -550,7 +550,7 @@ int diskHandleWalk(fd, walk_dat)
 	case EWOULDBLOCK:
 	    break;
 	default:
-	    debug(1, "diskHandleWalk: FD %d: error readingd: %s\n",
+	    debug(0, 1, "diskHandleWalk: FD %d: error readingd: %s\n",
 		fd, xstrerror());
 	    walk_dat->handler(fd, DISK_ERROR, walk_dat->client_data);
 	    safe_free(walk_dat->buf);
@@ -1,4 +1,4 @@
-/* $Id: filemap.cc,v 1.5 1996/03/27 01:46:03 wessels Exp $ */
+/* $Id: filemap.cc,v 1.6 1996/03/27 18:15:44 wessels Exp $ */
 
 #include "squid.h"
 
@@ -32,8 +32,8 @@ fileMap *file_map_create(n)
 
     fm->max_n_files = n;
     fm->nwords = n >> LONG_BIT_SHIFT;
-    debug(1, "file_map_create: creating space for %d files\n", n);
-    debug(5, "--> %d words of %d bytes each\n",
+    debug(0, 1, "file_map_create: creating space for %d files\n", n);
+    debug(0, 5, "--> %d words of %d bytes each\n",
 	fm->nwords, sizeof(unsigned long));
     fm->file_map = (unsigned long *) xcalloc(fm->nwords, sizeof(unsigned long));
     return (fm);
@@ -46,7 +46,7 @@ int file_map_bit_set(file_number)
 
 #ifdef XTRA_DEBUG
     if (fm->file_map[file_number >> LONG_BIT_SHIFT] & bitmask)
-	debug(0, "file_map_bit_set: WARNING: file number %d is already set!\n",
+	debug(0, 0, "file_map_bit_set: WARNING: file number %d is already set!\n",
 	    file_number);
 #endif
 
@@ -55,9 +55,9 @@ int file_map_bit_set(file_number)
     fm->n_files_in_map++;
     if (!fm->toggle && (fm->n_files_in_map > ((fm->max_n_files * 7) >> 3))) {
 	fm->toggle++;
-	debug(0, "You should increment MAX_SWAP_FILE\n");
+	debug(0, 0, "You should increment MAX_SWAP_FILE\n");
     } else if (fm->n_files_in_map > (fm->max_n_files - 100)) {
-	debug(0, "You've run out of swap file numbers. Freeing 1MB\n");
+	debug(0, 0, "You've run out of swap file numbers. Freeing 1MB\n");
 	storeGetSwapSpace(1000000);
     }
     return (file_number);
@@ -106,8 +106,8 @@ int file_map_allocate(suggestion)
 	}
     }
 
-    debug(0, "file_map_allocate: All %d files are in use!\n", fm->max_n_files);
-    debug(0, "You need to recompile with a larger value for MAX_SWAP_FILE\n");
+    debug(0, 0, "file_map_allocate: All %d files are in use!\n", fm->max_n_files);
+    debug(0, 0, "You need to recompile with a larger value for MAX_SWAP_FILE\n");
     fatal_dump(NULL);
     return (0);			/* NOTREACHED */
 }
@@ -1,4 +1,4 @@
-/* $Id: ftp.cc,v 1.12 1996/03/27 01:46:04 wessels Exp $ */
+/* $Id: ftp.cc,v 1.13 1996/03/27 18:15:45 wessels Exp $ */
 
 #include "squid.h"
 
@@ -111,7 +111,7 @@ void ftpLifetimeExpire(fd, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(4, "ftpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(0, 4, "ftpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
     if (data->icp_page_ptr) {
 	put_free_8k_page(data->icp_page_ptr);
 	data->icp_page_ptr = NULL;
@@ -143,8 +143,8 @@ int ftpReadReply(fd, data)
 	    clen = entry->mem_obj->e_current_len;
 	    off = entry->mem_obj->e_lowest_offset;
 	    if ((clen - off) > FTP_DELETE_GAP) {
-		debug(3, "ftpReadReply: Read deferred for Object: %s\n", entry->key);
-		debug(3, "--> Current Gap: %d bytes\n", clen - off);
+		debug(0, 3, "ftpReadReply: Read deferred for Object: %s\n", entry->key);
+		debug(0, 3, "--> Current Gap: %d bytes\n", clen - off);
 		/* reschedule, so it will automatically be reactivated when
 		 * Gap is big enough. */
 		comm_set_select_handler(fd,
@@ -164,11 +164,11 @@ int ftpReadReply(fd, data)
     }
     errno = 0;
     len = read(fd, buf, READBUFSIZ);
-    debug(5, "ftpReadReply: FD %d, Read %d bytes\n", fd, len);
+    debug(0, 5, "ftpReadReply: FD %d, Read %d bytes\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
 	if (len < 0)
-	    debug(1, "ftpReadReply: read error: %s\n", xstrerror());
+	    debug(0, 1, "ftpReadReply: read error: %s\n", xstrerror());
 	cached_error_entry(entry, ERR_READ_ERROR, NULL);
 	comm_close(fd);
 	safe_free(data);
@@ -177,7 +177,7 @@ int ftpReadReply(fd, data)
 	if (!data->got_marker) {
 	    /* If we didn't see the magic marker, assume the transfer failed and arrange
 	     * so the object gets ejected and never gets to disk. */
-	    debug(1, "ftpReadReply: Didn't see magic marker, purging <URL:%s>.\n", entry->url);
+	    debug(0, 1, "ftpReadReply: Didn't see magic marker, purging <URL:%s>.\n", entry->url);
 	    entry->expires = cached_curtime + getNegativeTTL();
 	    BIT_RESET(entry->flag, CACHABLE);
 	    BIT_SET(entry->flag, RELEASE_REQUEST);
@@ -235,7 +235,7 @@ void ftpSendComplete(fd, buf, size, errflag, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(5, "ftpSendComplete: FD %d: size %d: errflag %d.\n",
+    debug(0, 5, "ftpSendComplete: FD %d: size %d: errflag %d.\n",
 	fd, size, errflag);
 
     if (buf) {
@@ -275,13 +275,12 @@ void ftpSendRequest(fd, data)
     static char tbuf[BUFSIZ];
     static char opts[BUFSIZ];
     static char *space = " ";
-    static char *w_space = " \t\r\n";
     char *s = NULL;
     int got_timeout = 0;
     int got_negttl = 0;
     int buflen;
 
-    debug(5, "ftpSendRequest: FD %d\n", fd);
+    debug(0, 5, "ftpSendRequest: FD %d\n", fd);
 
     buflen = strlen(data->request) + 256;
     buf = (char *) get_free_8k_page();
@@ -344,7 +343,7 @@ void ftpSendRequest(fd, data)
     strcat(buf, space);
     strcat(buf, data->password);
     strcat(buf, space);
-    debug(5, "ftpSendRequest: FD %d: buf '%s'\n", fd, buf);
+    debug(0, 5, "ftpSendRequest: FD %d: buf '%s'\n", fd, buf);
     data->icp_rwd_ptr = icpWrite(fd, buf, strlen(buf), 30, ftpSendComplete, (caddr_t) data);
 }
 
@@ -354,7 +353,7 @@ void ftpConnInProgress(fd, data)
 {
     StoreEntry *entry = data->entry;
 
-    debug(5, "ftpConnInProgress: FD %d\n", fd);
+    debug(0, 5, "ftpConnInProgress: FD %d\n", fd);
 
     if (comm_connect(fd, "localhost", 3131) != COMM_OK)
 	switch (errno) {
@@ -367,7 +366,7 @@ void ftpConnInProgress(fd, data)
 		(caddr_t) data);
 	    return;
 	case EISCONN:
-	    debug(5, "ftpConnInProgress: FD %d is now connected.", fd);
+	    debug(0, 5, "ftpConnInProgress: FD %d is now connected.", fd);
 	    break;		/* cool, we're connected */
 	default:
 	    comm_close(fd);
@@ -391,7 +390,7 @@ int ftpStart(unusedfd, url, entry)
     FtpData *data = NULL;
     int status;
 
-    debug(3, "FtpStart: FD %d <URL:%s>\n", unusedfd, url);
+    debug(0, 3, "FtpStart: FD %d <URL:%s>\n", unusedfd, url);
 
     data = (FtpData *) xcalloc(1, sizeof(FtpData));
     data->entry = entry;
@@ -402,7 +401,7 @@ int ftpStart(unusedfd, url, entry)
 	safe_free(data);
 	return COMM_ERROR;
     }
-    debug(5, "FtpStart: FD %d, host=%s, request=%s, user=%s, passwd=%s\n",
+    debug(0, 5, "FtpStart: FD %d, host=%s, request=%s, user=%s, passwd=%s\n",
 	unusedfd, data->host, data->request, data->user, data->password);
 
     data->ftp_fd = comm_open(COMM_NONBLOCKING, 0, 0, url);
@@ -421,7 +420,7 @@ int ftpStart(unusedfd, url, entry)
 	    safe_free(data);
 	    return COMM_ERROR;
 	} else {
-	    debug(5, "ftpStart: FD %d: EINPROGRESS.\n", data->ftp_fd);
+	    debug(0, 5, "ftpStart: FD %d: EINPROGRESS.\n", data->ftp_fd);
 	    comm_set_select_handler(data->ftp_fd, COMM_SELECT_LIFETIME,
 		(PF) ftpLifetimeExpire, (caddr_t) data);
 	    comm_set_select_handler(data->ftp_fd, COMM_SELECT_WRITE,
@@ -458,11 +457,11 @@ int ftpInitialize()
     char *ftpget = getFtpProgram();
 
     if (pipe(p) < 0) {
-	debug(0, "ftpInitialize: pipe: %s\n", xstrerror());
+	debug(0, 0, "ftpInitialize: pipe: %s\n", xstrerror());
 	return -1;
     }
     if ((pid = fork()) < 0) {
-	debug(0, "ftpInitialize: fork: %s\n", xstrerror());
+	debug(0, 0, "ftpInitialize: fork: %s\n", xstrerror());
 	return -1;
     }
     if (pid != 0) {		/* parent */
@@ -482,7 +481,7 @@ int ftpInitialize()
 	(void) close(fd);
     sprintf(pbuf, "%d", 3131);
     execlp(ftpget, ftpget, "-D26,1", "-S", pbuf, NULL);
-    debug(0, "ftpInitialize: %s: %s\n", ftpget, xstrerror());
+    debug(0, 0, "ftpInitialize: %s: %s\n", ftpget, xstrerror());
     _exit(1);
     return (1);			/* eliminate compiler warning */
 }
@@ -1,4 +1,4 @@
-/* $Id: gopher.cc,v 1.8 1996/03/27 01:46:06 wessels Exp $ */
+/* $Id: gopher.cc,v 1.9 1996/03/27 18:15:45 wessels Exp $ */
 
 #include "squid.h"
 
@@ -329,7 +329,7 @@ void gopherToHTML(data, inbuf, len)
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
 		if (data->len + len > TEMP_BUF_SIZE) {
-		    debug(1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
+		    debug(0, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
 		    len = TEMP_BUF_SIZE - data->len;
 		}
@@ -355,7 +355,7 @@ void gopherToHTML(data, inbuf, len)
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
 		if ((len - (pos - inbuf)) > TEMP_BUF_SIZE) {
-		    debug(1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
+		    debug(0, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
 		    len = TEMP_BUF_SIZE;
 		}
@@ -561,7 +561,7 @@ int gopherReadReplyTimeout(fd, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
+    debug(0, 4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
     cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     if (data->icp_page_ptr)
 	put_free_4k_page(data->icp_page_ptr);
@@ -579,7 +579,7 @@ void gopherLifetimeExpire(fd, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(4, "gopherLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(0, 4, "gopherLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
     cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     if (data->icp_page_ptr)
 	put_free_4k_page(data->icp_page_ptr);
@@ -614,9 +614,9 @@ int gopherReadReply(fd, data)
 	    clen = entry->mem_obj->e_current_len;
 	    off = entry->mem_obj->e_lowest_offset;
 	    if ((clen - off) > GOPHER_DELETE_GAP) {
-		debug(3, "gopherReadReply: Read deferred for Object: %s\n",
+		debug(0, 3, "gopherReadReply: Read deferred for Object: %s\n",
 		    entry->key);
-		debug(3, "                Current Gap: %d bytes\n",
+		debug(0, 3, "                Current Gap: %d bytes\n",
 		    clen - off);
 
 		/* reschedule, so it will automatically reactivated when
@@ -652,10 +652,10 @@ int gopherReadReply(fd, data)
     }
     buf = get_free_4k_page();
     len = read(fd, buf, TEMP_BUF_SIZE - 1);	/* leave one space for \0 in gopherToHTML */
-    debug(5, "gopherReadReply - fd: %d read len:%d\n", fd, len);
+    debug(0, 5, "gopherReadReply - fd: %d read len:%d\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
-	debug(1, "gopherReadReply - error reading: %s\n",
+	debug(0, 1, "gopherReadReply - error reading: %s\n",
 	    xstrerror());
 	cached_error_entry(entry, ERR_READ_ERROR, xstrerror());
 	comm_close(fd);
@@ -724,7 +724,7 @@ void gopherSendComplete(fd, buf, size, errflag, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(5, "gopherSendComplete - fd: %d size: %d errflag: %d\n",
+    debug(0, 5, "gopherSendComplete - fd: %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
 	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
@@ -818,7 +818,7 @@ int gopherSendRequest(fd, data)
 	sprintf(buf, "%s%c%c", data->request, CR, LF);
     }
 
-    debug(5, "gopherSendRequest - fd: %d\n", fd);
+    debug(0, 5, "gopherSendRequest - fd: %d\n", fd);
     data->icp_rwd_ptr = icpWrite(fd,
 	buf,
 	len,
@@ -839,7 +839,7 @@ int gopherStart(unusedfd, url, entry)
 
     data->entry = entry;
 
-    debug(3, "gopherStart - url: %s\n", url);
+    debug(0, 3, "gopherStart - url: %s\n", url);
 
     /* Parse url. */
     if (gopher_url_parser(url, data->host, &data->port,
@@ -851,7 +851,7 @@ int gopherStart(unusedfd, url, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(4, "gopherStart: Failed because we're out of sockets.\n");
+	debug(0, 4, "gopherStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
 	freeGopherData(data);
 	return COMM_ERROR;
@@ -860,7 +860,7 @@ int gopherStart(unusedfd, url, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(0, 4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
 	comm_close(sock);
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	freeGopherData(data);
@@ -896,7 +896,7 @@ int gopherStart(unusedfd, url, entry)
 	    freeGopherData(data);
 	    return COMM_ERROR;
 	} else {
-	    debug(5, "startGopher - conn %d EINPROGRESS\n", sock);
+	    debug(0, 5, "startGopher - conn %d EINPROGRESS\n", sock);
 	}
     }
     /* Install connection complete handler. */
@@ -1,4 +1,4 @@
-/* $Id: http.cc,v 1.10 1996/03/27 01:46:08 wessels Exp $ */
+/* $Id: http.cc,v 1.11 1996/03/27 18:15:46 wessels Exp $ */
 
 #include "squid.h"
 
@@ -89,7 +89,7 @@ void httpReadReplyTimeout(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(4, "httpReadReplyTimeout: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(0, 4, "httpReadReplyTimeout: FD %d: <URL:%s>\n", fd, entry->url);
     cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     if (data->icp_rwd_ptr)
 	safe_free(data->icp_rwd_ptr);
@@ -110,7 +110,7 @@ void httpLifetimeExpire(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(4, "httpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(0, 4, "httpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
 
     cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     if (data->icp_page_ptr) {
@@ -145,8 +145,8 @@ void httpReadReply(fd, data)
 	    clen = entry->mem_obj->e_current_len;
 	    off = entry->mem_obj->e_lowest_offset;
 	    if ((clen - off) > HTTP_DELETE_GAP) {
-		debug(3, "httpReadReply: Read deferred for Object: %s\n", entry->key);
-		debug(3, "                Current Gap: %d bytes\n", clen - off);
+		debug(0, 3, "httpReadReply: Read deferred for Object: %s\n", entry->key);
+		debug(0, 3, "                Current Gap: %d bytes\n", clen - off);
 		/* reschedule, so it will be automatically reactivated
 		 * when Gap is big enough. */
 		comm_set_select_handler(fd,
@@ -180,11 +180,11 @@ void httpReadReply(fd, data)
     }
     errno = 0;
     len = read(fd, buf, READBUFSIZ);
-    debug(5, "httpReadReply: FD %d: len %d.\n", fd, len);
+    debug(0, 5, "httpReadReply: FD %d: len %d.\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
 	/* XXX we we should log when len==0 and current_len==0 */
-	debug(2, "httpReadReply: FD %d: read failure: %s.\n",
+	debug(0, 2, "httpReadReply: FD %d: read failure: %s.\n",
 	    fd, xstrerror());
 	if (errno == ECONNRESET) {
 	    /* Connection reset by peer */
@@ -252,7 +252,7 @@ void httpSendComplete(fd, buf, size, errflag, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(5, "httpSendComplete: FD %d: size %d: errflag %d.\n",
+    debug(0, 5, "httpSendComplete: FD %d: size %d: errflag %d.\n",
 	fd, size, errflag);
 
     if (buf) {
@@ -293,7 +293,7 @@ void httpSendRequest(fd, data)
     int len = 0;
     int buflen;
 
-    debug(5, "httpSendRequest: FD %d: data %p.\n", fd, data);
+    debug(0, 5, "httpSendRequest: FD %d: data %p.\n", fd, data);
     buflen = strlen(data->type) + strlen(data->request);
     if (data->mime_hdr)
 	buflen += strlen(data->mime_hdr);
@@ -310,7 +310,7 @@ void httpSendRequest(fd, data)
     buf = (char *) get_free_8k_page();
     data->icp_page_ptr = buf;
     if (buflen > DISK_PAGE_SIZE) {
-	debug(0, "Mime header length %d is breaking ICP code\n", buflen);
+	debug(0, 0, "Mime header length %d is breaking ICP code\n", buflen);
     }
     memset(buf, '\0', buflen);
 
@@ -346,7 +346,7 @@ void httpSendRequest(fd, data)
 	len += strlen(post_buf);
 	xfree(post_buf);
     }
-    debug(6, "httpSendRequest: FD %d: buf '%s'\n", fd, buf);
+    debug(0, 6, "httpSendRequest: FD %d: buf '%s'\n", fd, buf);
     data->icp_rwd_ptr = icpWrite(fd, buf, len, 30, httpSendComplete, (caddr_t) data);
 }
 
@@ -389,8 +389,8 @@ int proxyhttpStart(e, url, entry)
     int sock, status;
     HttpData *data = (HttpData *) xmalloc(sizeof(HttpData));
 
-    debug(3, "proxyhttpStart: <URL:%s>\n", url);
-    debug(10, "proxyhttpStart: HTTP request header:\n%s\n",
+    debug(0, 3, "proxyhttpStart: <URL:%s>\n", url);
+    debug(0, 10, "proxyhttpStart: HTTP request header:\n%s\n",
 	entry->mem_obj->mime_hdr);
 
     memset(data, '\0', sizeof(HttpData));
@@ -408,7 +408,7 @@ int proxyhttpStart(e, url, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(4, "proxyhttpStart: Failed because we're out of sockets.\n");
+	debug(0, 4, "proxyhttpStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
@@ -417,7 +417,7 @@ int proxyhttpStart(e, url, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(4, "proxyhttpstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(0, 4, "proxyhttpstart: Called without IP entry in ipcache. OR lookup failed.\n");
 	comm_close(sock);
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	safe_free(data);
@@ -433,7 +433,7 @@ int proxyhttpStart(e, url, entry)
 	    e->neighbor_up = 0;
 	    return COMM_ERROR;
 	} else {
-	    debug(5, "proxyhttpStart: FD %d: EINPROGRESS.\n", sock);
+	    debug(0, 5, "proxyhttpStart: FD %d: EINPROGRESS.\n", sock);
 	    comm_set_select_handler(sock, COMM_SELECT_LIFETIME,
 		(PF) httpLifetimeExpire, (caddr_t) data);
 	    comm_set_select_handler(sock, COMM_SELECT_WRITE,
@@ -462,8 +462,8 @@ int httpStart(unusedfd, url, type, mime_hdr, entry)
     int sock, status;
     HttpData *data = (HttpData *) xmalloc(sizeof(HttpData));
 
-    debug(3, "httpStart: %s <URL:%s>\n", type, url);
-    debug(10, "httpStart: mime_hdr '%s'\n", mime_hdr);
+    debug(0, 3, "httpStart: %s <URL:%s>\n", type, url);
+    debug(0, 10, "httpStart: mime_hdr '%s'\n", mime_hdr);
 
     memset(data, '\0', sizeof(HttpData));
     data->entry = entry;
@@ -479,7 +479,7 @@ int httpStart(unusedfd, url, type, mime_hdr, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(4, "httpStart: Failed because we're out of sockets.\n");
+	debug(0, 4, "httpStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
@@ -488,7 +488,7 @@ int httpStart(unusedfd, url, type, mime_hdr, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(4, "httpstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(0, 4, "httpstart: Called without IP entry in ipcache. OR lookup failed.\n");
 	comm_close(sock);
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	safe_free(data);
@@ -502,7 +502,7 @@ int httpStart(unusedfd, url, type, mime_hdr, entry)
 	    safe_free(data);
 	    return COMM_ERROR;
 	} else {
-	    debug(5, "httpStart: FD %d: EINPROGRESS.\n", sock);
+	    debug(0, 5, "httpStart: FD %d: EINPROGRESS.\n", sock);
 	    comm_set_select_handler(sock, COMM_SELECT_LIFETIME,
 		(PF) httpLifetimeExpire, (caddr_t) data);
 	    comm_set_select_handler(sock, COMM_SELECT_WRITE,
@@ -1,4 +1,4 @@
-/* $Id: ipcache.cc,v 1.8 1996/03/27 01:46:11 wessels Exp $ */
+/* $Id: ipcache.cc,v 1.9 1996/03/27 18:15:48 wessels Exp $ */
 
 #include "squid.h"
 
@@ -63,7 +63,6 @@ static char *test_site[TEST_SITE] =
     "yale.edu"
 };
 
-static char w_space[] = " \t\n";
 static dnsserver_entry **dns_child_table = NULL;
 static int last_dns_dispatched = 2;
 static struct hostent *static_result = NULL;
@@ -121,7 +120,7 @@ int ipcache_create_dnsserver(command)
     int fd;
 
     if ((cfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	debug(0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
+	debug(0, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
 	return -1;
     }
     fdstat_open(cfd, Socket);
@@ -130,18 +129,18 @@ int ipcache_create_dnsserver(command)
     addr.sun_family = AF_UNIX;
     sprintf(socketname, "dns/dns%d.%d", (int) getpid(), n_dnsserver++);
     strcpy(addr.sun_path, socketname);
-    debug(4, "ipcache_create_dnsserver: path is %s\n", addr.sun_path);
+    debug(0, 4, "ipcache_create_dnsserver: path is %s\n", addr.sun_path);
 
     if (bind(cfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 	close(cfd);
-	debug(0, "ipcache_create_dnsserver: bind: %s\n", xstrerror());
+	debug(0, 0, "ipcache_create_dnsserver: bind: %s\n", xstrerror());
 	return -1;
     }
-    debug(4, "ipcache_create_dnsserver: bind to local host.\n");
+    debug(0, 4, "ipcache_create_dnsserver: bind to local host.\n");
     listen(cfd, 1);
 
     if ((pid = fork()) < 0) {
-	debug(0, "ipcache_create_dnsserver: fork: %s\n", xstrerror());
+	debug(0, 0, "ipcache_create_dnsserver: fork: %s\n", xstrerror());
 	close(cfd);
 	return -1;
     }
@@ -150,7 +149,7 @@ int ipcache_create_dnsserver(command)
 
 	/* open new socket for parent process */
 	if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	    debug(0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
+	    debug(0, 0, "ipcache_create_dnsserver: socket: %s\n", xstrerror());
 	    return -1;
 	}
 	fcntl(sfd, F_SETFD, 1);	/* set close-on-exec */
@@ -159,10 +158,10 @@ int ipcache_create_dnsserver(command)
 	strcpy(addr.sun_path, socketname);
 	if (connect(sfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
 	    close(sfd);
-	    debug(0, "ipcache_create_dnsserver: connect: %s\n", xstrerror());
+	    debug(0, 0, "ipcache_create_dnsserver: connect: %s\n", xstrerror());
 	    return -1;
 	}
-	debug(4, "ipcache_create_dnsserver: FD %d connected to %s #%d.\n",
+	debug(0, 4, "ipcache_create_dnsserver: FD %d connected to %s #%d.\n",
 	    sfd, command, n_dnsserver);
 	return sfd;
     }
@@ -187,21 +186,21 @@ int ipcache_release(e)
     ipcache_entry *result = 0;
     int i;
 
-    debug(5, "ipcache_release: ipcache_count before: %d \n", meta_data.ipcache_count);
+    debug(0, 5, "ipcache_release: ipcache_count before: %d \n", meta_data.ipcache_count);
 
     if (e != NULL && ip_table) {	/* sometimes called with NULL e */
 	hash_link *table_entry = hash_lookup(ip_table, e->name);
 	if (table_entry) {
 	    result = (ipcache_entry *) table_entry;
-	    debug(5, "HASH table count before delete: %d\n", ipcache_hash_entry_count());
+	    debug(0, 5, "HASH table count before delete: %d\n", ipcache_hash_entry_count());
 	    if (hash_remove_link(ip_table, table_entry)) {
-		debug(3, "ipcache_release: Cannot delete '%s' from hash table %d\n", e->name, ip_table);
+		debug(0, 3, "ipcache_release: Cannot delete '%s' from hash table %d\n", e->name, ip_table);
 	    }
-	    debug(5, "HASH table count after delete: %d\n", ipcache_hash_entry_count());
+	    debug(0, 5, "HASH table count after delete: %d\n", ipcache_hash_entry_count());
 	    if (result) {
 		if (result->status == PENDING) {
-		    debug(1, "ipcache_release: Try to release entry with PENDING status. ignored.\n");
-		    debug(5, "ipcache_release: ipcache_count: %d \n", meta_data.ipcache_count);
+		    debug(0, 1, "ipcache_release: Try to release entry with PENDING status. ignored.\n");
+		    debug(0, 5, "ipcache_release: ipcache_count: %d \n", meta_data.ipcache_count);
 		    return -1;
 		}
 		if (result->status == CACHED) {
@@ -216,19 +215,19 @@ int ipcache_release(e)
 		    if (result->entry.h_aliases)
 			safe_free(result->entry.h_aliases);
 		    safe_free(result->entry.h_name);
-		    debug(5, "ipcache_release: Released IP cached record for '%s'.\n", e->name);
+		    debug(0, 5, "ipcache_release: Released IP cached record for '%s'.\n", e->name);
 		}
 		/* XXX: we're having mem mgmt problems; zero, then free */
 		safe_free(result->name);
 		memset(result, '\0', sizeof(ipcache_entry));
 		safe_free(result);
 	    }
 	    --meta_data.ipcache_count;
-	    debug(5, "ipcache_release: ipcache_count when return: %d \n", meta_data.ipcache_count);
+	    debug(0, 5, "ipcache_release: ipcache_count when return: %d \n", meta_data.ipcache_count);
 	    return meta_data.ipcache_count;
 	}
     }
-    debug(3, "ipcache_release: can't delete entry\n");
+    debug(0, 3, "ipcache_release: can't delete entry\n");
     return -1;			/* can't delete entry */
 }
 
@@ -316,7 +315,7 @@ int ipcache_purgelru()
 	if (LRU_list_count >= LRU_cur_size) {
 	    /* have to realloc  */
 	    LRU_cur_size += 16;
-	    debug(3, "ipcache_purgelru: Have to grow LRU_list to %d. This shouldn't happen.\n",
+	    debug(0, 3, "ipcache_purgelru: Have to grow LRU_list to %d. This shouldn't happen.\n",
 		LRU_cur_size);
 	    LRU_list = (ipcache_entry **) xrealloc((char *) LRU_list,
 		LRU_cur_size * sizeof(ipcache_entry *));
@@ -327,12 +326,12 @@ int ipcache_purgelru()
 	}
     }
 
-    debug(3, "ipcache_purgelru: ipcache_count: %5d\n", meta_data.ipcache_count);
-    debug(3, "                  actual count : %5d\n", local_ip_count);
-    debug(3, "                  high W mark  : %5d\n", ipcache_high);
-    debug(3, "                  low  W mark  : %5d\n", ipcache_low);
-    debug(3, "                  not pending  : %5d\n", local_ip_notpending_count);
-    debug(3, "              LRU candidated   : %5d\n", LRU_list_count);
+    debug(0, 3, "ipcache_purgelru: ipcache_count: %5d\n", meta_data.ipcache_count);
+    debug(0, 3, "                  actual count : %5d\n", local_ip_count);
+    debug(0, 3, "                  high W mark  : %5d\n", ipcache_high);
+    debug(0, 3, "                  low  W mark  : %5d\n", ipcache_low);
+    debug(0, 3, "                  not pending  : %5d\n", local_ip_notpending_count);
+    debug(0, 3, "              LRU candidated   : %5d\n", LRU_list_count);
 
     /* sort LRU candidate list */
     qsort((char *) LRU_list, LRU_list_count, sizeof(e), (int (*)(const void *, const void *)) ipcache_compareLastRef);
@@ -344,7 +343,7 @@ int ipcache_purgelru()
 	removed++;
     }
 
-    debug(3, "                   removed      : %5d\n", removed);
+    debug(0, 3, "                   removed      : %5d\n", removed);
     safe_free(LRU_list);
     return (removed > 0) ? 0 : -1;
 }
@@ -355,25 +354,25 @@ ipcache_entry *ipcache_create()
 {
     static ipcache_entry *ipe;
     static ipcache_entry *new;
-    debug(5, "ipcache_create: when enter. ipcache_count == %d\n", meta_data.ipcache_count);
+    debug(0, 5, "ipcache_create: when enter. ipcache_count == %d\n", meta_data.ipcache_count);
 
     if (meta_data.ipcache_count > ipcache_high) {
 	if (ipcache_purgelru() < 0) {
-	    debug(1, "ipcache_create: Cannot release needed IP entry via LRU: %d > %d, removing first entry...\n", meta_data.ipcache_count, MAX_IP);
+	    debug(0, 1, "ipcache_create: Cannot release needed IP entry via LRU: %d > %d, removing first entry...\n", meta_data.ipcache_count, MAX_IP);
 	    ipe = ipcache_GetFirst();
 	    if (!ipe) {
-		debug(1, "ipcache_create: First entry is a null pointer ???\n");
+		debug(0, 1, "ipcache_create: First entry is a null pointer ???\n");
 		/* have to let it grow beyond limit here */
 	    } else if (ipe && ipe->status != PENDING) {
 		ipcache_release(ipe);
 	    } else {
-		debug(1, "ipcache_create: First entry is also PENDING entry.\n");
+		debug(0, 1, "ipcache_create: First entry is also PENDING entry.\n");
 		/* have to let it grow beyond limit here */
 	    }
 	}
     }
     meta_data.ipcache_count++;
-    debug(5, "ipcache_create: before return. ipcache_count == %d\n", meta_data.ipcache_count);
+    debug(0, 5, "ipcache_create: before return. ipcache_count == %d\n", meta_data.ipcache_count);
     new = (ipcache_entry *) xcalloc(1, sizeof(ipcache_entry));
     /* set default to 4, in case parser fail to get token $h_length from
      * dnsserver. */
@@ -388,11 +387,11 @@ void ipcache_add_to_hash(e)
     if (!ipcache_initialized)
 	ipcache_init();
     if (hash_join(ip_table, (hash_link *) e)) {
-	debug(1, "ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
+	debug(0, 1, "ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
 	    e->name, e, ip_table);
     }
-    debug(5, "ipcache_add_to_hash: name <%s>\n", e->name);
-    debug(5, "                     ipcache_count: %d\n", meta_data.ipcache_count);
+    debug(0, 5, "ipcache_add_to_hash: name <%s>\n", e->name);
+    debug(0, 5, "                     ipcache_count: %d\n", meta_data.ipcache_count);
 }
 
 
@@ -404,7 +403,7 @@ void ipcache_add(name, e, data, cached)
 {
     int addr_count, alias_count, i;
 
-    debug(10, "ipcache_add: Adding name '%s' (%s).\n", name,
+    debug(0, 10, "ipcache_add: Adding name '%s' (%s).\n", name,
 	cached ? "cached" : "not cached");
 
     e->name = xstrdup(name);
@@ -470,7 +469,7 @@ void ipcache_update_content(name, e, data, cached)
 {
     int addr_count, alias_count, i;
 
-    debug(10, "ipcache_update: Updating name '%s' (%s).\n", name,
+    debug(0, 10, "ipcache_update: Updating name '%s' (%s).\n", name,
 	cached ? "cached" : "not cached");
 
     if (cached) {
@@ -541,15 +540,15 @@ void ipcache_call_pending(entry)
 	safe_free(p);
     }
     entry->pending_head = entry->pending_tail = NULL;	/* nuke list */
-    debug(10, "ipcache_call_pending: Called %d handlers.\n", nhandler);
+    debug(0, 10, "ipcache_call_pending: Called %d handlers.\n", nhandler);
 }
 
 void ipcache_call_pending_badname(fd, handler, data)
      int fd;
      IPH handler;
      caddr_t data;
 {
-    debug(4, "ipcache_call_pending_badname: Bad Name: Calling handler with NULL result.\n");
+    debug(0, 4, "ipcache_call_pending_badname: Bad Name: Calling handler with NULL result.\n");
     handler(fd, NULL, data);
 }
 
@@ -627,7 +626,7 @@ void globalpending_remove(p, data)
     }
 
     if (q == NULL) {		/* 'p' is not in the list? */
-	debug(1, "globalpending_remove: Failure while deleting entry from global pending list.\n");
+	debug(0, 1, "globalpending_remove: Failure while deleting entry from global pending list.\n");
 	return;
     }
     /* nuke p from the list; do this carefully... */
@@ -680,7 +679,7 @@ int ipcache_parsebuffer(buf, offset, data)
 
 	/* no complete record here */
 	if ((endpos = strstr(pos, "$end\n")) == NULL) {
-	    debug(2, "ipcache_parsebuffer: DNS response incomplete.\n");
+	    debug(0, 2, "ipcache_parsebuffer: DNS response incomplete.\n");
 	    break;
 	}
 	line_head = line_tail = NULL;
@@ -690,12 +689,12 @@ int ipcache_parsebuffer(buf, offset, data)
 	    line_cur = (line_entry *) xcalloc(1, sizeof(line_entry));
 
 	    if ((tpos = memchr(pos, '\n', 4096)) == NULL) {
-		debug(2, "ipcache_parsebuffer: DNS response incomplete.\n");
+		debug(0, 2, "ipcache_parsebuffer: DNS response incomplete.\n");
 		return -1;
 	    }
 	    *tpos = '\0';
 	    line_cur->line = xstrdup(pos);
-	    debug(7, "ipcache_parsebuffer: %s\n", line_cur->line);
+	    debug(0, 7, "ipcache_parsebuffer: %s\n", line_cur->line);
 	    *tpos = '\n';
 
 	    if (line_tail)
@@ -718,7 +717,7 @@ int ipcache_parsebuffer(buf, offset, data)
 	if (strstr(line_head->line, "$alive")) {
 	    data->answer = cached_curtime;
 	    free_lines(line_head);
-	    debug(10, "ipcache_parsebuffer: $alive succeeded.\n");
+	    debug(0, 10, "ipcache_parsebuffer: $alive succeeded.\n");
 	} else if (strstr(line_head->line, "$fail")) {
 	    /*
 	     *  The $fail messages look like:
@@ -732,7 +731,7 @@ int ipcache_parsebuffer(buf, offset, data)
 		strcpy(dns_error_message, line_cur->line + 8);
 	    }
 	    if (token == NULL) {
-		debug(1, "ipcache_parsebuffer: Invalid $fail for DNS table?\n");
+		debug(0, 1, "ipcache_parsebuffer: Invalid $fail for DNS table?\n");
 	    } else {
 		plist = globalpending_search(token, data->global_pending);
 		if (plist) {
@@ -741,10 +740,10 @@ int ipcache_parsebuffer(buf, offset, data)
 		    plist->entry->status = NEGATIVE_CACHED;
 		    ipcache_call_pending(plist->entry);
 		    globalpending_remove(plist, data);
-		    debug(10, "ipcache_parsebuffer: $fail succeeded: %s.\n",
+		    debug(0, 10, "ipcache_parsebuffer: $fail succeeded: %s.\n",
 			dns_error_message[0] ? dns_error_message : "why?");
 		} else {
-		    debug(1, "ipcache_parsebuffer: No entry in DNS table?\n");
+		    debug(0, 1, "ipcache_parsebuffer: No entry in DNS table?\n");
 		}
 	    }
 	    free_lines(line_head);
@@ -755,15 +754,15 @@ int ipcache_parsebuffer(buf, offset, data)
 	    tmp_ptr = NULL;
 	    token = strtok(tmp_ptr, w_space);
 	    if (!token) {
-		debug(1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
+		debug(0, 1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
 	    } else {
 		plist = globalpending_search(token, data->global_pending);
 		if (plist) {
 		    int ipcount, aliascount;
 		    ipcache_entry *e = plist->entry;
 
 		    if (e->status != PENDING) {
-			debug(4, "ipcache_parsebuffer: DNS record already resolved.\n");
+			debug(0, 4, "ipcache_parsebuffer: DNS record already resolved.\n");
 		    } else {
 			e->lastref = e->timestamp = cached_curtime;
 			e->ttl = IP_POS_TTL;
@@ -774,7 +773,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $h_name */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$h_name")) {
-			    debug(1, "ipcache_parsebuffer: DNS record in invalid format? No $h_name.\n");
+			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $h_name.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -790,7 +789,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $h_length */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$h_len")) {
-			    debug(1, "ipcache_parsebuffer: DNS record in invalid format? No $h_len.\n");
+			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $h_len.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -806,7 +805,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $ipcount */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$ipcount")) {
-			    debug(1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount.\n");
+			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -829,7 +828,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			    line_cur = line_cur->next;
 			    while (i < ipcount) {
 				if (line_cur == NULL) {
-				    debug(1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount data.\n");
+				    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $ipcount data.\n");
 				    break;
 				}
 				e->entry.h_addr_list[i] = (char *) xcalloc(1, e->entry.h_length);
@@ -842,7 +841,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			/* get $aliascount */
 			if (line_cur == NULL ||
 			    !strstr(line_cur->line, "$aliascount")) {
-			    debug(1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount.\n");
+			    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount.\n");
 			    /* abandon this record */
 			    break;
 			}
@@ -865,7 +864,7 @@ int ipcache_parsebuffer(buf, offset, data)
 			    line_cur = line_cur->next;
 			    while (i < aliascount) {
 				if (line_cur == NULL) {
-				    debug(1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount data.\n");
+				    debug(0, 1, "ipcache_parsebuffer: DNS record in invalid format? No $aliascount data.\n");
 				    break;
 				}
 				e->entry.h_aliases[i] = xstrdup(line_cur->line);
@@ -876,16 +875,16 @@ int ipcache_parsebuffer(buf, offset, data)
 
 			ipcache_call_pending(e);
 			globalpending_remove(plist, data);
-			debug(10, "ipcache_parsebuffer: $name succeeded.\n");
+			debug(0, 10, "ipcache_parsebuffer: $name succeeded.\n");
 		    }
 		} else {
-		    debug(1, "ipcache_parsebuffer: No entries in DNS $name record?\n");
+		    debug(0, 1, "ipcache_parsebuffer: No entries in DNS $name record?\n");
 		}
 	    }
 	    free_lines(line_head);
 	} else {
 	    free_lines(line_head);
-	    debug(1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
+	    debug(0, 1, "ipcache_parsebuffer: Invalid OPCODE for DNS table?\n");
 	    return -1;
 	}
     }
@@ -900,11 +899,11 @@ int ipcache_dnsHandleRead(fd, data)
     int char_scanned;
     int len = read(fd, data->ip_inbuf + data->offset, data->size - data->offset);
 
-    debug(5, "ipcache_dnsHandleRead: Result from DNS ID %d.\n", data->id);
+    debug(0, 5, "ipcache_dnsHandleRead: Result from DNS ID %d.\n", data->id);
 
     if (len == 0) {
-	debug(1, "ipcache_dnsHandleRead: Connection from DNSSERVER is closed.\n");
-	debug(1, "                       Disabling this server ID %d.\n", data->id);
+	debug(0, 1, "ipcache_dnsHandleRead: Connection from DNSSERVER is closed.\n");
+	debug(0, 1, "                       Disabling this server ID %d.\n", data->id);
 	data->alive = 0;
 	update_dns_child_alive();
 	ipcache_cleanup_pendinglist(data);
@@ -939,16 +938,16 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
     IpPending *pending;
     dnsserver_entry *dns;
 
-    debug(4, "ipcache_nbgethostbyname: FD %d: Name '%s'.\n", fd, name);
+    debug(0, 4, "ipcache_nbgethostbyname: FD %d: Name '%s'.\n", fd, name);
 
     if (name == NULL || name[0] == '\0') {
-	debug(4, "ipcache_nbgethostbyname: Invalid name!\n");
+	debug(0, 4, "ipcache_nbgethostbyname: Invalid name!\n");
 	ipcache_call_pending_badname(fd, handler, data);
 	return 0;
     }
     if ((e = ipcache_get(name)) != NULL && (e->status != PENDING)) {
 	/* hit here */
-	debug(4, "ipcache_nbgethostbyname: Hit for name '%s'.\n", name);
+	debug(0, 4, "ipcache_nbgethostbyname: Hit for name '%s'.\n", name);
 	pending = (IpPending *) xcalloc(1, sizeof(IpPending));
 	pending->fd = fd;
 	pending->handler = handler;
@@ -963,7 +962,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
 	ipcache_call_pending(e);
 	return 0;
     }
-    debug(4, "ipcache_nbgethostbyname: Name '%s': MISS or PENDING.\n", name);
+    debug(0, 4, "ipcache_nbgethostbyname: Name '%s': MISS or PENDING.\n", name);
 
     pending = (IpPending *) xcalloc(1, sizeof(IpPending));
     pending->fd = fd;
@@ -972,7 +971,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
     pending->next = NULL;
     if (e == NULL) {
 	/* No entry, create the new one */
-	debug(5, "ipcache_nbgethostbyname: Creating new entry for '%s'...\n",
+	debug(0, 5, "ipcache_nbgethostbyname: Creating new entry for '%s'...\n",
 	    name);
 	e = ipcache_create();
 	e->name = xstrdup(name);
@@ -981,7 +980,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
 	ipcache_add_to_hash(e);
     } else {
 	/* There is an entry. Add handler to list */
-	debug(5, "ipcache_nbgethostbyname: Adding handler to pending list for '%s'.\n", name);
+	debug(0, 5, "ipcache_nbgethostbyname: Adding handler to pending list for '%s'.\n", name);
 	if (e->pending_head == NULL) {	/* empty list */
 	    e->pending_head = e->pending_tail = pending;
 	} else {		/* add to tail of list */
@@ -1018,7 +1017,7 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
     }
 
     dns = dns_child_table[last_dns_dispatched];
-    debug(5, "ipcache_nbgethostbyname: Dispatched DNS %d.\n",
+    debug(0, 5, "ipcache_nbgethostbyname: Dispatched DNS %d.\n",
 	last_dns_dispatched);
 
     /* add to global pending list */
@@ -1047,10 +1046,10 @@ int ipcache_nbgethostbyname(name, fd, handler, data)
 	    0,			/* Handler */
 	    0);			/* Handler-data */
 
-	debug(5, "ipcache_nbgethostbyname: Request sent DNS server ID %d.\n", last_dns_dispatched);
+	debug(0, 5, "ipcache_nbgethostbyname: Request sent DNS server ID %d.\n", last_dns_dispatched);
     } else {
 	/* do a blocking mode */
-	debug(4, "ipcache_nbgethostbyname: Fall back to blocking mode.  Server's dead...\n");
+	debug(0, 4, "ipcache_nbgethostbyname: Fall back to blocking mode.  Server's dead...\n");
 	ipcache_cleanup_pendinglist(dns);
     }
     return 0;
@@ -1063,26 +1062,26 @@ void ipcache_init()
     int i, dnssocket;
     char fd_note_buf[FD_ASCII_NOTE_SZ];
 
-    debug(3, "ipcache_init: Called.  ipcache_initialized=%d  getDnsChildren()=%d\n", ipcache_initialized, getDnsChildren());
+    debug(0, 3, "ipcache_init: Called.  ipcache_initialized=%d  getDnsChildren()=%d\n", ipcache_initialized, getDnsChildren());
 
     if (ipcache_initialized)
 	return;
 
     if (mkdir("dns", 0755) < 0 && errno != EEXIST) {
-	debug(0, "ipcache_init: mkdir %s\n", xstrerror());
+	debug(0, 0, "ipcache_init: mkdir %s\n", xstrerror());
     }
     last_dns_dispatched = getDnsChildren() - 1;
     dns_error_message = xcalloc(1, 256);
 
     /* test naming lookup */
     if (!do_dns_test) {
-	debug(4, "ipcache_init: Skipping DNS name lookup tests, -D flag given.\n");
+	debug(0, 4, "ipcache_init: Skipping DNS name lookup tests, -D flag given.\n");
     } else if (ipcache_testname() < 0) {
-	debug(0, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
+	debug(0, 0, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
 	fprintf(stderr, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
 	exit(-1);
     } else {
-	debug(4, "ipcache_init: Successful DNS name lookup tests...\n");
+	debug(0, 4, "ipcache_init: Successful DNS name lookup tests...\n");
     }
 
     ip_table = hash_create(urlcmp, 229);	/* small hash table */
@@ -1096,13 +1095,13 @@ void ipcache_init()
     /* start up companion process */
     dns_child_table = (dnsserver_entry **) xcalloc(getDnsChildren(), sizeof(dnsserver_entry));
     dns_child_alive = 0;
-    debug(1, "ipcache_init: Starting %d 'dns_server' processes\n",
+    debug(0, 1, "ipcache_init: Starting %d 'dns_server' processes\n",
 	getDnsChildren());
     for (i = 0; i < getDnsChildren(); i++) {
 	dns_child_table[i] = (dnsserver_entry *) xcalloc(1, sizeof(dnsserver_entry));
 	if ((dnssocket = ipcache_create_dnsserver(getDnsProgram())) < 0) {
-	    debug(1, "ipcache_init: WARNING: Cannot run 'dnsserver' process.\n");
-	    debug(1, "              Fallling back to the blocking version.\n");
+	    debug(0, 1, "ipcache_init: WARNING: Cannot run 'dnsserver' process.\n");
+	    debug(0, 1, "              Fallling back to the blocking version.\n");
 	    dns_child_table[i]->alive = 0;
 	} else {
 	    dns_child_alive = 1;
@@ -1123,7 +1122,7 @@ void ipcache_init()
 		dns_child_table[i]->id);
 	    file_update_open(dns_child_table[i]->inpipe, fd_note_buf);
 
-	    debug(5, "Calling fd_note() with FD %d and buf '%s'\n",
+	    debug(0, 5, "Calling fd_note() with FD %d and buf '%s'\n",
 		dns_child_table[i]->inpipe, fd_note_buf);
 
 	    fd_note(dns_child_table[i]->inpipe, fd_note_buf);
@@ -1144,7 +1143,7 @@ void ipcache_init()
 		COMM_SELECT_READ,
 		(PF) ipcache_dnsHandleRead,
 		(caddr_t) dns_child_table[i]);
-	    debug(3, "ipcache_init: 'dns_server' %d started\n", i);
+	    debug(0, 3, "ipcache_init: 'dns_server' %d started\n", i);
 	}
     }
     ipcache_high = (long) (((float) MAX_IP *
@@ -1179,7 +1178,7 @@ int ipcache_unregister(name, fd)
 
     if (p == NULL) {
 	/* Can not find this ipcache_entry, weird */
-	debug(1, "ipcache_unregister: Failed to unregister FD %d from name: %s, can't find this FD.\n",
+	debug(0, 1, "ipcache_unregister: Failed to unregister FD %d from name: %s, can't find this FD.\n",
 	    fd, name);
 	return 0;
     }
@@ -1225,13 +1224,13 @@ struct hostent *ipcache_gethostbyname(name)
 	ipcache_init();
 
     if (!name) {
-	debug(5, "ipcache_gethostbyname: Invalid argument?\n");
+	debug(0, 5, "ipcache_gethostbyname: Invalid argument?\n");
 	return (NULL);
     }
     if (!(result = ipcache_get(name))) {
 	/* cache miss */
 	if (name) {
-	    debug(5, "ipcache_gethostbyname: IPcache miss for '%s'.\n", name);
+	    debug(0, 5, "ipcache_gethostbyname: IPcache miss for '%s'.\n", name);
 	}
 	/* check if it's already a IP address in text form. */
 	if (sscanf(name, "%u.%u.%u.%u", &a1, &a2, &a3, &a4) == 4) {
@@ -1244,20 +1243,20 @@ struct hostent *ipcache_gethostbyname(name)
 
 	if (s_result && s_result->h_name && (s_result->h_name[0] != '\0')) {
 	    /* good address, cached */
-	    debug(10, "ipcache_gethostbyname: DNS success: cache for '%s'.\n", name);
+	    debug(0, 10, "ipcache_gethostbyname: DNS success: cache for '%s'.\n", name);
 	    ipcache_add(name, ipcache_create(), s_result, 1);
 	    result = ipcache_get(name);
 	    return &(result->entry);
 	} else {
 	    /* bad address, negative cached */
-	    debug(3, "ipcache_gethostbyname: DNS failure: negative cache for '%s'.\n", name);
+	    debug(0, 3, "ipcache_gethostbyname: DNS failure: negative cache for '%s'.\n", name);
 	    ipcache_add(name, ipcache_create(), s_result, 0);
 	    return NULL;
 	}
 
     }
     /* cache hit */
-    debug(5, "ipcache_gethostbyname: Hit for '%s'.\n", name ? name : "NULL");
+    debug(0, 5, "ipcache_gethostbyname: Hit for '%s'.\n", name ? name : "NULL");
     result->lastref = cached_curtime;
     return (result->status == CACHED) ? &(result->entry) : NULL;
 }
@@ -1324,7 +1323,7 @@ char ipcache_status_char(e)
     case NEGATIVE_CACHED:
 	return ('N');
     default:
-	debug(1, "ipcache_status_char: unexpected IP cache status.\n");
+	debug(0, 1, "ipcache_status_char: unexpected IP cache status.\n");
     }
     return ('X');
 }
@@ -1,4 +1,4 @@
-/* $Id: main.cc,v 1.9 1996/03/27 04:42:08 wessels Exp $ */
+/* $Id: main.cc,v 1.10 1996/03/27 18:15:49 wessels Exp $ */
 
 #include "squid.h"
 
@@ -14,7 +14,6 @@ int theAsciiConnection = -1;
 int theBinaryConnection = -1;
 int theUdpConnection = -1;
 int do_reuse = 1;
-int debug_level = 0;
 int catch_signals = 1;
 int do_dns_test = 1;
 char *config_file = NULL;
@@ -36,16 +35,12 @@ static int asciiPortNumOverride = 0;
 static int binaryPortNumOverride = 0;
 static int udpPortNumOverride = 0;
 
-void raise_debug_lvl(), reset_debug_lvl();
-void sig_child();
-
 int main(argc, argv)
      int argc;
      char **argv;
 {
     int c;
     int malloc_debug_level = 0;
-    int debug_level_overwrite = 0;
     extern char *optarg;
     int errcount = 0;
     static int neighbors = 0;
@@ -175,12 +170,6 @@ int main(argc, argv)
 	case 'u':
 	    udpPortNumOverride = atoi(optarg);
 	    break;
-	case 'd':
-	    stderr_enable = 1;
-	    debug_level_overwrite = 1;
-	    debug_level = atoi(optarg);
-	    unbuffered_logs = 1;
-	    break;
 	case 'm':
 	    malloc_debug_level = atoi(optarg);
 	    break;
@@ -191,7 +180,7 @@ int main(argc, argv)
 	case 'h':
 	default:
 	    printf("\
-Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
+Usage: cached [-Rsehvz] [-f config-file] [-[apu] port]\n\
        -e        Print messages to stderr.\n\
        -h        Print help message.\n\
        -s        Disable syslog output.\n\
@@ -202,7 +191,6 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
        -R        Do not set REUSEADDR on port.\n\
        -f file   Use given config-file instead of\n\
                  $HARVEST_HOME/lib/cached.conf.\n\
-       -d level  Use given debug-level, prints messages to stderr.\n\
        -a port	 Specify ASCII port number (default: %d).\n\
        -u port	 Specify UDP port number (default: %d).\n",
 		CACHE_HTTP_PORT, CACHE_ICP_PORT);
@@ -235,26 +223,11 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
     if (udpPortNumOverride > 0)
 	setUdpPortNum(udpPortNumOverride);
 
-    if (!debug_level_overwrite) {
-	debug_level = getDebugLevel();
-    }
-    /* to toggle debugging */
-#ifdef SIGUSR1
-    signal(SIGUSR1, raise_debug_lvl);
-#endif
-#ifdef SIGUSR2
-    signal(SIGUSR2, reset_debug_lvl);
-#endif
-
-#ifdef NO_LOGGING
-    _db_init("cached", 0, getCacheLogFile());
-#else
-    _db_init("cached", debug_level, getCacheLogFile());
-#endif
+    _db_init("cached", getCacheLogFile());
     fdstat_open(fileno(debug_log), LOG);
     fd_note(fileno(debug_log), getCacheLogFile());
 
-    debug(0, "Starting Harvest Cache (version %s)...\n", SQUID_VERSION);
+    debug(0, 0, "Starting Harvest Cache (version %s)...\n", SQUID_VERSION);
 
     /* init ipcache */
     ipcache_init();
@@ -266,7 +239,7 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 
 
 #if defined(MALLOC_DBG)
-    malloc_debug(malloc_debug_level);
+    malloc_debug(0, malloc_debug_level);
 #endif
 
     theAsciiConnection = comm_open(COMM_NONBLOCKING,
@@ -283,7 +256,7 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 	COMM_SELECT_READ,
 	asciiHandleConn,
 	0);
-    debug(1, "Accepting HTTP (ASCII) connections on FD %d.\n",
+    debug(0, 1, "Accepting HTTP (ASCII) connections on FD %d.\n",
 	theAsciiConnection);
 
     if (!httpd_accel_mode || getAccelWithProxy()) {
@@ -301,7 +274,7 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 	    COMM_SELECT_READ,
 	    icpHandleTcp,
 	    0);
-	debug(1, "Binary connection opened on fd %d\n", theBinaryConnection);
+	debug(0, 1, "Binary connection opened on fd %d\n", theBinaryConnection);
 #endif
 	if (getUdpPortNum() > -1) {
 	    theUdpConnection = comm_open(COMM_NONBLOCKING | COMM_DGRAM,
@@ -316,7 +289,7 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 		COMM_SELECT_READ,
 		icpHandleUdp,
 		0);
-	    debug(1, "Accepting ICP (UDP) connections on FD %d.\n",
+	    debug(0, 1, "Accepting ICP (UDP) connections on FD %d.\n",
 		theUdpConnection);
 	}
     }
@@ -353,7 +326,7 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 
     /* after this point we want to see the mallinfo() output */
     do_mallinfo = 1;
-    debug(0, "Ready to serve requests.\n");
+    debug(0, 0, "Ready to serve requests.\n");
 
     /* main loop */
     if (getCleanRate() > 0)
@@ -370,7 +343,7 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 	    break;
 	case COMM_ERROR:
 	    errcount++;
-	    debug(0, "Select loop Error. Retry. %d\n", errcount);
+	    debug(0, 0, "Select loop Error. Retry. %d\n", errcount);
 	    if (errcount == 10)
 		fatal_dump("Select Loop failed.!\n");
 	    break;
@@ -379,38 +352,18 @@ Usage: cached [-Rsehvz] [-f config-file] [-d debug-level] [-[apu] port]\n\
 	     * when next_cleaning has arrived */
 	    /* garbage collection */
 	    if (getCleanRate() > 0 && cached_curtime >= next_cleaning) {
-		debug(1, "Performing a garbage collection...\n");
+		debug(0, 1, "Performing a garbage collection...\n");
 		n = storePurgeOld();
-		debug(1, "Garbage collection done, %d objects removed\n", n);
+		debug(0, 1, "Garbage collection done, %d objects removed\n", n);
 		next_cleaning = cached_curtime + getCleanRate();
 	    }
 	    /* house keeping */
 	    break;
 	default:
-	    debug(0, "MAIN: Internal error -- this should never happen.\n");
+	    debug(0, 0, "MAIN: Internal error -- this should never happen.\n");
 	    break;
 	}
     }
     /* NOTREACHED */
     exit(0);
 }
-
-void raise_debug_lvl()
-{
-    extern int _db_level;
-    _db_level = 10;
-
-#if defined(_SQUID_SYSV_SIGNALS_) && defined(SIGUSR1)
-    signal(SIGUSR1, raise_debug_lvl);
-#endif
-}
-
-void reset_debug_lvl()
-{
-    extern int _db_level;
-    _db_level = debug_level;
-
-#if defined(_SQUID_SYSV_SIGNALS_) && defined(SIGUSR2)
-    signal(SIGUSR2, reset_debug_lvl);
-#endif
-}
@@ -1,4 +1,4 @@
-/* $Id: neighbors.cc,v 1.4 1996/03/27 01:46:14 wessels Exp $ */
+/* $Id: neighbors.cc,v 1.5 1996/03/27 18:15:50 wessels Exp $ */
 
 #include "squid.h"
 
@@ -42,7 +42,7 @@ edge *whichEdge(header, from)
     port = ntohs(from->sin_port);
     ip = from->sin_addr;
 
-    debug(3, "whichEdge: from %s port %d\n", inet_ntoa(ip), port);
+    debug(0, 3, "whichEdge: from %s port %d\n", inet_ntoa(ip), port);
 
     for (e = friends->edges_head; e; e = e->next) {
 	for (j = 0; j < e->n_addresses; j++) {
@@ -213,7 +213,7 @@ void neighbors_install(host, type, ascii_port, udp_port, proxy_only, domains)
 {
     edge *e;
 
-    debug(1, "Adding a %s: %s\n", type, host);
+    debug(0, 1, "Adding a %s: %s\n", type, host);
 
     e = (edge *) xcalloc(1, sizeof(edge));
 
@@ -263,7 +263,7 @@ void neighbors_open(fd)
 
     if (getsockname(fd, (struct sockaddr *) &our_socket_name,
 	    &sock_name_length) == -1) {
-	debug(1, "getsockname(%d,%p,%p) failed.\n",
+	debug(0, 1, "getsockname(%d,%p,%p) failed.\n",
 	    fd, &our_socket_name, &sock_name_length);
     }
     friends->fd = fd;
@@ -272,16 +272,16 @@ void neighbors_open(fd)
     if ((fname = getHierarchyLogFile())) {
 	log_fd = file_open(fname, NULL, O_WRONLY | O_CREAT | O_APPEND);
 	if (log_fd < 0) {
-	    debug(1, "%s: %s\n", fname, xstrerror());
-	    debug(1, "Hierachical logging is disabled.\n");
+	    debug(0, 1, "%s: %s\n", fname, xstrerror());
+	    debug(0, 1, "Hierachical logging is disabled.\n");
 	} else if (!(cache_hierarchy_log = fdopen(log_fd, "a"))) {
-	    debug(1, "%s: %s\n", fname, xstrerror());
-	    debug(1, "Hierachical logging is disabled.\n");
+	    debug(0, 1, "%s: %s\n", fname, xstrerror());
+	    debug(0, 1, "Hierachical logging is disabled.\n");
 	}
     }
     /* Prepare neighbor connections, one at a time */
     for (e = friends->edges_head; e; e = e->next) {
-	debug(2, "Finding IP addresses for '%s'\n", e->host);
+	debug(0, 2, "Finding IP addresses for '%s'\n", e->host);
 	if ((list = getAddressList(e->host)) == NULL) {
 	    sprintf(tmp_error_buf, "DNS lookup for '%s' failed! Cannot continue.\n",
 		e->host);
@@ -299,7 +299,7 @@ void neighbors_open(fd)
 	    fatal(tmp_error_buf);
 	}
 	for (j = 0; j < e->n_addresses; j++) {
-	    debug(2, "--> IP address #%d: %s\n", j, inet_ntoa(e->addresses[j]));
+	    debug(0, 2, "--> IP address #%d: %s\n", j, inet_ntoa(e->addresses[j]));
 	}
 	e->rtt = 1000;
 
@@ -318,12 +318,12 @@ void neighbors_open(fd)
 	ap->sin_port = htons(e->udp_port);
 
 	if (e->type == is_a_parent) {
-	    debug(3, "parent_install: host %s addr %s port %d\n",
+	    debug(0, 3, "parent_install: host %s addr %s port %d\n",
 		e->host, inet_ntoa(ap->sin_addr),
 		e->udp_port);
 	    e->neighbor_up = 1;
 	} else {
-	    debug(3, "neighbor_install: host %s addr %s port %d\n",
+	    debug(0, 3, "neighbor_install: host %s addr %s port %d\n",
 		e->host, inet_ntoa(ap->sin_addr),
 		e->udp_port);
 	    e->neighbor_up = 1;
@@ -383,7 +383,7 @@ int neighborsUdpPing(proto)
     for (i = 0, e = friends->first_ping; i++ < friends->n; e = e->next) {
 	if (e == (edge *) NULL)
 	    e = friends->edges_head;
-	debug(5, "neighborsUdpPing: Edge %s\n", e->host);
+	debug(0, 5, "neighborsUdpPing: Edge %s\n", e->host);
 
 	/* Don't resolve refreshes through neighbors because we don't resolve
 	 * misses through neighbors */
@@ -398,13 +398,13 @@ int neighborsUdpPing(proto)
 	if (!edgeWouldBePinged(e, host))
 	    continue;		/* next edge */
 
-	debug(4, "neighborsUdpPing: pinging cache %s for <URL:%s>\n",
+	debug(0, 4, "neighborsUdpPing: pinging cache %s for <URL:%s>\n",
 	    e->host, url);
 
 	e->header.reqnum++;
 
 	if (e->udp_port == echo_port) {
-	    debug(4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
+	    debug(0, 4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
 	    icpUdpSend(friends->fd, url, &echo_hdr, &e->in_addr, ICP_OP_DECHO);
 	} else {
 	    icpUdpSend(friends->fd, url, &e->header, &e->in_addr, ICP_OP_QUERY);
@@ -425,7 +425,7 @@ int neighborsUdpPing(proto)
 		/* do this to prevent wrap around but we still want it
 		 * to move a bit so we can debug it easier. */
 		e->ack_deficit = HIER_MAX_DEFICIT + 1;
-	    debug(6, "cache %s is considered dead but send PING anyway, hope it comes up soon.\n",
+	    debug(0, 6, "cache %s is considered dead but send PING anyway, hope it comes up soon.\n",
 		inet_ntoa(e->in_addr.sin_addr));
 	    /* log it once at the threshold */
 	    if ((e->ack_deficit == HIER_MAX_DEFICIT)) {
@@ -446,19 +446,19 @@ int neighborsUdpPing(proto)
     /* only do source_ping if we have neighbors */
     if (echo_hdr.opcode) {
 	if (proto->source_ping && (hep = ipcache_gethostbyname(host))) {
-	    debug(6, "neighborsUdpPing: Send to original host\n");
-	    debug(6, "neighborsUdpPing: url=%s, host=%s, t=%d\n",
+	    debug(0, 6, "neighborsUdpPing: Send to original host\n");
+	    debug(0, 6, "neighborsUdpPing: url=%s, host=%s, t=%d\n",
 		url, host, t);
 	    to_addr.sin_family = AF_INET;
 	    memcpy(&to_addr.sin_addr, hep->h_addr, hep->h_length);
 	    to_addr.sin_port = echo_port;
 	    echo_hdr.reqnum = cached_curtime;
-	    debug(6, "neighborsUdpPing - url: %s to url-host %s \n",
+	    debug(0, 6, "neighborsUdpPing - url: %s to url-host %s \n",
 		url, inet_ntoa(to_addr.sin_addr));
 	    /* send to original site */
 	    icpUdpSend(friends->fd, url, &echo_hdr, &to_addr, ICP_OP_SECHO);
 	} else {
-	    debug(6, "neighborsUdpPing: Source Ping is disabled.\n");
+	    debug(0, 6, "neighborsUdpPing: Source Ping is disabled.\n");
 	}
     }
     return (entry->mem_obj->e_pings_n_pings);
@@ -480,12 +480,12 @@ void neighborsUdpAck(fd, url, header, from, entry)
 {
     edge *e = NULL;
 
-    debug(6, "neighborsUdpAck: url=%s (%d chars), header=0x%x, from=0x%x, ent=0x%x\n",
+    debug(0, 6, "neighborsUdpAck: url=%s (%d chars), header=0x%x, from=0x%x, ent=0x%x\n",
 	url, strlen(url), header, from, entry);
-    debug(6, "     hdr: opcode=%d, ver=%d, shostid=%x, len=%d, rn=0x%x\n",
+    debug(0, 6, "     hdr: opcode=%d, ver=%d, shostid=%x, len=%d, rn=0x%x\n",
 	header->opcode, header->version, header->shostid,
 	header->length, header->reqnum);
-    debug(6, "     from: fam=%d, port=%d, addr=0x%x\n",
+    debug(0, 6, "     from: fam=%d, port=%d, addr=0x%x\n",
 	from->sin_family, from->sin_port, from->sin_addr.s_addr);
 
     /* look up for neighbor/parent entry */
@@ -510,33 +510,33 @@ void neighborsUdpAck(fd, url, header, from, entry)
     /* check if someone is already fetching it */
     if (BIT_TEST(entry->flag, REQ_DISPATCHED) || (entry->ping_status != WAITING)) {
 	if (entry->ping_status == DONE) {
-	    debug(5, "There is already a cache/source dispatched for this object\n");
-	    debug(5, "--> <URL:%s>\n", entry->url);
-	    debug(5, "--> entry->flag & REQ_DISPATCHED = %d\n",
+	    debug(0, 5, "There is already a cache/source dispatched for this object\n");
+	    debug(0, 5, "--> <URL:%s>\n", entry->url);
+	    debug(0, 5, "--> entry->flag & REQ_DISPATCHED = %d\n",
 		BIT_TEST(entry->flag, REQ_DISPATCHED));
-	    debug(5, "--> entry->ping_status = %d\n", entry->ping_status);
+	    debug(0, 5, "--> entry->ping_status = %d\n", entry->ping_status);
 	} else {
-	    debug(5, "The ping already timed out.\n");
-	    debug(5, "--> <URL:%s>\n", entry->url);
-	    debug(5, "--> entry->flag & REQ_DISPATCHED = %lx\n",
+	    debug(0, 5, "The ping already timed out.\n");
+	    debug(0, 5, "--> <URL:%s>\n", entry->url);
+	    debug(0, 5, "--> entry->flag & REQ_DISPATCHED = %lx\n",
 		BIT_TEST(entry->flag, REQ_DISPATCHED));
-	    debug(5, "--> entry->ping_status = %d\n", entry->ping_status);
+	    debug(0, 5, "--> entry->ping_status = %d\n", entry->ping_status);
 	}
 	return;
     }
-    debug(6, "neighborsUdpAck - url: %s to us %s \n",
+    debug(0, 6, "neighborsUdpAck - url: %s to us %s \n",
 	url, e ? inet_ntoa(e->in_addr.sin_addr) : "url-host");
 
     if (header->opcode == ICP_OP_SECHO) {
 	/* receive ping back from source or from non-cached cache */
 	if (e) {
-	    debug(6, "Got SECHO from non-cached cache:%s\n",
+	    debug(0, 6, "Got SECHO from non-cached cache:%s\n",
 		inet_ntoa(e->in_addr.sin_addr));
-	    debug(6, "This is not supposed to happen.  Ignored.\n");
+	    debug(0, 6, "This is not supposed to happen.  Ignored.\n");
 	} else {
 	    /* if we reach here, source is the one has the fastest respond. */
 	    /* fetch directly from source */
-	    debug(6, "Source is the first to respond.\n");
+	    debug(0, 6, "Source is the first to respond.\n");
 	    hierarchy_log_append(entry->url,
 		HIER_SOURCE_FASTEST,
 		0,
@@ -555,7 +555,7 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	    return;
 	}
 	/* GOT a HIT here */
-	debug(6, "HIT: Getting %s from host: %s\n", entry->url, e->host);
+	debug(0, 6, "HIT: Getting %s from host: %s\n", entry->url, e->host);
 	if (e->type == is_a_neighbor) {
 	    hierarchy_log_append(entry->url, HIER_NEIGHBOR_HIT, 0, e->host);
 	} else {
@@ -576,24 +576,24 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	    /* receive ping back from non-cached cache */
 
 	    if (e) {
-		debug(6, "Got DECHO from non-cached cache:%s\n",
+		debug(0, 6, "Got DECHO from non-cached cache:%s\n",
 		    inet_ntoa(e->in_addr.sin_addr));
-		debug(6, "Good.");
+		debug(0, 6, "Good.");
 
 		if (e->type == is_a_parent) {
 		    if (entry->mem_obj->e_pings_first_miss == NULL) {
-			debug(6, "OK. We got dumb-cached parent as the first miss here.\n");
+			debug(0, 6, "OK. We got dumb-cached parent as the first miss here.\n");
 			entry->mem_obj->e_pings_first_miss = e;
 		    }
 		} else {
-		    debug(6, "Dumb Cached as a neighbor does not make sense.\n");
-		    debug(6, "Count it anyway.\n");
+		    debug(0, 6, "Dumb Cached as a neighbor does not make sense.\n");
+		    debug(0, 6, "Count it anyway.\n");
 		}
 
 
 	    } else {
-		debug(6, "Got DECHO from non-cached cache: But the host is not in the list.\n");
-		debug(6, "Count it anyway.\n");
+		debug(0, 6, "Got DECHO from non-cached cache: But the host is not in the list.\n");
+		debug(0, 6, "Count it anyway.\n");
 	    }
 
 	} else {
@@ -607,14 +607,14 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	if (entry->mem_obj->e_pings_n_acks == entry->mem_obj->e_pings_n_pings) {
 	    BIT_SET(entry->flag, REQ_DISPATCHED);
 	    entry->ping_status = DONE;
-	    debug(6, "Receive MISSes from all neighbors and parents\n");
+	    debug(0, 6, "Receive MISSes from all neighbors and parents\n");
 	    /* pass in fd=0 here so getFromCache() looks up the real FD
 	     * and resets the timeout handler */
 	    getFromDefaultSource(0, entry);
 	    return;
 	}
     } else {
-	debug(0, "neighborsUdpAck: WHY ARE WE HERE?  header->opcode = %d\n",
+	debug(0, 0, "neighborsUdpAck: WHY ARE WE HERE?  header->opcode = %d\n",
 	    header->opcode);
     }
 }
@@ -686,9 +686,9 @@ void neighbors_init()
 		t->ascii_port, t->udp_port, t->proxy_only,
 		t->domains);
 	} else {
-	    debug(0, "neighbors_init: skipping cache_host %s %s %d %d\n",
+	    debug(0, 0, "neighbors_init: skipping cache_host %s %s %d %d\n",
 		t->type, t->host, t->ascii_port, t->udp_port);
-	    debug(0, "neighbors_init: because it seems to be identical to this cached\n");
+	    debug(0, 0, "neighbors_init: because it seems to be identical to this cached\n");
 	}
 	xfree(t->host);
 	xfree(t->type);
@@ -707,7 +707,7 @@ void neighbors_rotate_log()
     if ((fname = getHierarchyLogFile()) == NULL)
 	return;
 
-    debug(1, "neighbors_rotate_log: Rotating.\n");
+    debug(0, 1, "neighbors_rotate_log: Rotating.\n");
 
     /* Rotate numbers 0 through N up one */
     for (i = getLogfileRotateNumber(); i > 1;) {
@@ -726,11 +726,11 @@ void neighbors_rotate_log()
     fclose(cache_hierarchy_log);
     log_fd = file_open(fname, NULL, O_WRONLY | O_CREAT | O_APPEND);
     if (log_fd < 0) {
-	debug(0, "rotate_logs: %s: %s\n", fname, xstrerror());
-	debug(1, "Hierachical logging is disabled.\n");
+	debug(0, 0, "rotate_logs: %s: %s\n", fname, xstrerror());
+	debug(0, 1, "Hierachical logging is disabled.\n");
     } else if ((cache_hierarchy_log = fdopen(log_fd, "a")) == NULL) {
-	debug(0, "rotate_logs: %s: %s\n",
+	debug(0, 0, "rotate_logs: %s: %s\n",
 	    fname, xstrerror());
-	debug(1, "Hierachical logging is disabled.\n");
+	debug(0, 1, "Hierachical logging is disabled.\n");
     }
 }
@@ -1,5 +1,5 @@
 
-/* $Id: squid.h,v 1.3 1996/03/27 05:12:39 wessels Exp $ */
+/* $Id: squid.h,v 1.4 1996/03/27 18:15:52 wessels Exp $ */
 
 #include "config.h"
 #include "autoconf.h"
@@ -114,5 +114,4 @@ typedef unsigned long u_num32;
 
 extern time_t cached_starttime;	/* main.c */
 extern time_t next_cleaning;	/* main.c */
-extern int debug_level;		/* main.c */
 extern int catch_signals;	/* main.c */
@@ -1,4 +1,4 @@
-/* $Id: stat.cc,v 1.7 1996/03/27 01:46:20 wessels Exp $ */
+/* $Id: stat.cc,v 1.8 1996/03/27 18:15:53 wessels Exp $ */
 
 #include "squid.h"
 
@@ -156,7 +156,7 @@ void stat_objects_get(obj, sentry, vm_or_not)
 	    continue;
 	if ((++N & 0xFF) == 0) {
 	    cached_curtime = time(NULL);
-	    debug(3, "stat_objects_get:  Processed %d objects...\n", N);
+	    debug(0, 3, "stat_objects_get:  Processed %d objects...\n", N);
 	}
 	obj_size = entry->object_len;
 	npend = storePendingNClients(entry);
@@ -739,10 +739,6 @@ void parameter_get(obj, sentry)
 	httpd_accel_mode);
     storeAppend(sentry, line, strlen(line));
 
-    sprintf(line, "{DebugLevel %d \"# Cache debug level\"}\n",
-	debug_level);
-    storeAppend(sentry, line, strlen(line));
-
     /* end of stats */
     storeAppend(sentry, close_bracket, strlen(close_bracket));
 }
@@ -788,7 +784,7 @@ void log_append(obj, url, id, size, action, method)
 
 	if (file_write(obj->logfile_fd, buf = xstrdup(tmp), strlen(tmp),
 		obj->logfile_access, NULL, NULL) != DISK_OK) {
-	    debug(1, "log_append: File write failed.\n");
+	    debug(0, 1, "log_append: File write failed.\n");
 	    safe_free(buf);
 	}
     }
@@ -806,7 +802,7 @@ void log_enable(obj, sentry)
 	/* open the logfile */
 	obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
 	if (obj->logfile_fd == DISK_ERROR) {
-	    debug(0, "Cannot open logfile: %s\n", obj->logfilename);
+	    debug(0, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	    obj->logfile_status = LOG_DISABLE;
 	}
 	obj->logfile_access = file_write_lock(obj->logfile_fd);
@@ -852,7 +848,7 @@ void log_clear(obj, sentry)
     /* reopen it anyway */
     obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
     if (obj->logfile_fd == DISK_ERROR) {
-	debug(0, "Cannot open logfile: %s\n", obj->logfilename);
+	debug(0, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	obj->logfile_status = LOG_DISABLE;
     }
     /* at the moment, store one char to make a storage manager happy */
@@ -974,7 +970,7 @@ void stat_init(object, logfilename)
     memcpy(obj->logfilename, logfilename, (int) (strlen(logfilename) + 1) % 256);
     obj->logfile_fd = file_open(obj->logfilename, NULL, O_RDWR | O_CREAT);
     if (obj->logfile_fd == DISK_ERROR) {
-	debug(0, "Cannot open logfile: %s\n", obj->logfilename);
+	debug(0, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	obj->logfile_status = LOG_DISABLE;
 	fatal("Cannot open logfile.\n");
     }
@@ -1199,7 +1195,7 @@ void stat_rotate_log()
     if ((fname = CacheInfo->logfilename) == NULL)
 	return;
 
-    debug(1, "stat_rotate_log: Rotating\n");
+    debug(0, 1, "stat_rotate_log: Rotating\n");
 
     /* Rotate numbers 0 through N up one */
     for (i = getLogfileRotateNumber(); i > 1;) {
@@ -1218,7 +1214,7 @@ void stat_rotate_log()
     file_close(CacheInfo->logfile_fd);
     CacheInfo->logfile_fd = file_open(fname, NULL, O_RDWR | O_CREAT | O_APPEND);
     if (CacheInfo->logfile_fd == DISK_ERROR) {
-	debug(0, "rotate_logs: Cannot open logfile: %s\n", fname);
+	debug(0, 0, "rotate_logs: Cannot open logfile: %s\n", fname);
 	CacheInfo->logfile_status = LOG_DISABLE;
 	fatal("Cannot open logfile.\n");
     }
@@ -1,4 +1,4 @@
-/* $Id: stmem.cc,v 1.3 1996/03/27 01:46:22 wessels Exp $ */
+/* $Id: stmem.cc,v 1.4 1996/03/27 18:15:54 wessels Exp $ */
 
 #include "squid.h"
 
@@ -83,8 +83,8 @@ int memFreeDataUpto(mem, target_offset)
 	return current_offset;
     }
     if (current_offset != target_offset) {
-	debug(1, "memFreeDataBehind: This shouldn't happen. Some odd condition.\n");
-	debug(1, "   Current offset: %d  Target offset: %d  p: %p\n",
+	debug(0, 1, "memFreeDataBehind: This shouldn't happen. Some odd condition.\n");
+	debug(0, 1, "   Current offset: %d  Target offset: %d  p: %p\n",
 	    current_offset, target_offset, p);
     }
     return current_offset;
@@ -102,7 +102,7 @@ int memAppend(mem, data, len)
     int avail_len;
     int len_to_copy;
 
-    debug(6, "memAppend: len %d\n", len);
+    debug(0, 6, "memAppend: len %d\n", len);
 
     /* Does the last block still contain empty space? 
      * If so, fill out the block before dropping into the
@@ -148,14 +148,14 @@ int memGrep(mem, string, nbytes)
     char *str_i, *mem_i;
     int i = 0, blk_idx = 0, state, goal;
 
-    debug(6, "memGrep: looking for %s in less than %d bytes.\n",
+    debug(0, 6, "memGrep: looking for %s in less than %d bytes.\n",
 	string, nbytes);
 
     if (!p)
 	return 0;
 
     if (mem->origin_offset != 0) {
-	debug(1, "memGrep: Some lower chunk of data has been erased. Can't do memGrep!\n");
+	debug(0, 1, "memGrep: Some lower chunk of data has been erased. Can't do memGrep!\n");
 	return 0;
     }
     str_i = string;
@@ -203,7 +203,7 @@ int memCopy(mem, offset, buf, size)
     int bytes_from_this_packet = 0;
     int bytes_into_this_packet = 0;
 
-    debug(6, "memCopy: offset %d: size %d\n", offset, size);
+    debug(0, 6, "memCopy: offset %d: size %d\n", offset, size);
 
     if (size <= 0)
 	return size;
@@ -214,7 +214,7 @@ int memCopy(mem, offset, buf, size)
 	if (p->next)
 	    p = p->next;
 	else {
-	    debug(1, "memCopy: Offset: %d is off limit of current object of %d\n", t_off, offset);
+	    debug(0, 1, "memCopy: Offset: %d is off limit of current object of %d\n", t_off, offset);
 	    return 0;
 	}
     }
@@ -286,7 +286,7 @@ char *
     }
     sm_stats.n_pages_in_use++;
     if (page == NULL) {
-	debug(0, "Null page pointer?");
+	debug(0, 0, "Null page pointer?");
 	fatal_dump(NULL);
     }
     return (page);
@@ -299,14 +299,14 @@ void put_free_4k_page(page)
 
 #if USE_MEMALIGN
     if ((int) page % SM_PAGE_SIZE) {
-	debug(0, "Someone tossed a string into the 4k page pool\n");
+	debug(0, 0, "Someone tossed a string into the 4k page pool\n");
 	fatal_dump(NULL);
     }
 #endif
     if (full_stack(&sm_stats.free_page_stack)) {
 	sm_stats.total_pages_allocated--;
 	if (!stack_overflow_warning_toggle) {
-	    debug(0, "Stack of free stmem pages overflowed.  Resize it?");
+	    debug(0, 0, "Stack of free stmem pages overflowed.  Resize it?");
 	    stack_overflow_warning_toggle++;
 	}
     }
@@ -334,7 +334,7 @@ char *get_free_8k_page()
     }
     disk_stats.n_pages_in_use++;
     if (page == NULL) {
-	debug(0, "Null page pointer?");
+	debug(0, 0, "Null page pointer?");
 	fatal_dump(NULL);
     }
     return (page);
@@ -347,15 +347,15 @@ void put_free_8k_page(page)
 
 #if USE_MEMALIGN
     if ((int) page % DISK_PAGE_SIZE) {
-	debug(0, "Someone tossed a string into the 8k page pool\n");
+	debug(0, 0, "Someone tossed a string into the 8k page pool\n");
 	fatal_dump(NULL);
     }
 #endif
 
     if (full_stack(&disk_stats.free_page_stack)) {
 	disk_stats.total_pages_allocated--;
 	if (!stack_overflow_warning_toggle) {
-	    debug(0, "Stack of free disk pages overflowed.  Resize it?");
+	    debug(0, 0, "Stack of free disk pages overflowed.  Resize it?");
 	    stack_overflow_warning_toggle++;
 	}
     }
@@ -1,5 +1,5 @@
 
-/* $Id: store.cc,v 1.12 1996/03/27 05:12:39 wessels Exp $ */
+/* $Id: store.cc,v 1.13 1996/03/27 18:15:54 wessels Exp $ */
 
 /* 
  * Here is a summary of the routines which change mem_status and swap_status:
@@ -143,7 +143,7 @@ void create_store_mem_obj(e)
 {
     if (e) {
 	if (has_mem_obj(e))
-	    debug(1, "create_store_mem_obj: old memory not released\n");
+	    debug(0, 1, "create_store_mem_obj: old memory not released\n");
 	e->mem_obj = (MemObject *) xcalloc(1, sizeof(MemObject));
 	meta_data.store_in_mem_objects++;
     }
@@ -207,7 +207,7 @@ void storeSetMemStatus(e, status)
 
     if (e->mem_status == IN_MEMORY && status != IN_MEMORY) {
 	if (e->key == NULL) {
-	    debug(0, "storeSetMemStatus: NULL key for %s\n", e->url);
+	    debug(0, 0, "storeSetMemStatus: NULL key for %s\n", e->url);
 	    return;
 	}
 	if ((ptr = hash_lookup(in_mem_table, e->key)))
@@ -229,13 +229,13 @@ void storeFreeEntry(e)
     if (e == (StoreEntry *) NULL)
 	return;
 
-    debug(5, "storeFreeEntry: Freeing %s\n", e->url);
+    debug(0, 5, "storeFreeEntry: Freeing %s\n", e->url);
 
     if (has_mem_obj(e)) {
 	store_mem_size -= e->mem_obj->e_current_len - e->mem_obj->e_lowest_offset;
-	debug(8, "storeFreeEntry: Freeing %d in-memory bytes\n",
+	debug(0, 8, "storeFreeEntry: Freeing %d in-memory bytes\n",
 	    e->mem_obj->e_current_len);
-	debug(8, "storeFreeEntry: store_mem_size = %d\n", store_mem_size);
+	debug(0, 8, "storeFreeEntry: store_mem_size = %d\n", store_mem_size);
 	if (e->mem_obj->data) {
 	    e->mem_obj->data->mem_free(e->mem_obj->data);
 	    e->mem_obj->data = NULL;
@@ -270,11 +270,11 @@ void storeFreeEntry(e)
 void storeFreeEntryData(e)
      StoreEntry *e;
 {
-    debug(5, "storeFreeEntryData: Freeing data-buffer only %s\n", e->url);
+    debug(0, 5, "storeFreeEntryData: Freeing data-buffer only %s\n", e->url);
     store_mem_size -= e->mem_obj->e_current_len - e->mem_obj->e_lowest_offset;
-    debug(8, "storeFreeEntryData: Freeing %d in-memory bytes\n",
+    debug(0, 8, "storeFreeEntryData: Freeing %d in-memory bytes\n",
 	e->mem_obj->e_current_len);
-    debug(8, "storeFreeEntryData: store_mem_size = %d\n", store_mem_size);
+    debug(0, 8, "storeFreeEntryData: store_mem_size = %d\n", store_mem_size);
     e->object_len = 0;
     e->mem_obj->e_current_len = 0;
     if (e->mem_obj->data) {
@@ -288,13 +288,13 @@ void storeFreeEntryData(e)
 void storePurgeMem(e)
      StoreEntry *e;
 {
-    debug(5, "storePurgeMem: Freeing memory-copy of %s\n", e->url);
+    debug(0, 5, "storePurgeMem: Freeing memory-copy of %s\n", e->url);
     if (!has_mem_obj(e))
 	return;
 
     if (storeEntryLocked(e)) {
-	debug(0, "storePurgeMem: someone (storeGetMemSpace?) is purging a locked object?\n");
-	debug(0, "%s", storeToString(e));
+	debug(0, 0, "storePurgeMem: someone (storeGetMemSpace?) is purging a locked object?\n");
+	debug(0, 0, "%s", storeToString(e));
 	fatal_dump(NULL);
     }
     /* free up memory data */
@@ -304,9 +304,9 @@ void storePurgeMem(e)
 	--meta_data.hot_vm;
     }
     store_mem_size -= e->object_len - e->mem_obj->e_lowest_offset;
-    debug(8, "storePurgeMem: Freeing %d in-memory bytes\n",
+    debug(0, 8, "storePurgeMem: Freeing %d in-memory bytes\n",
 	e->object_len);
-    debug(8, "storePurgeMem: store_mem_size = %d\n", store_mem_size);
+    debug(0, 8, "storePurgeMem: store_mem_size = %d\n", store_mem_size);
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->mem_obj->e_current_len = 0;
     /* free up pending list table */
@@ -332,13 +332,13 @@ int storeLockObject(e)
     int status = 0;
 
     e->lock_count++;
-    debug(5, "storeLockObject: locks %d: <URL:%s>\n", e->lock_count, e->url);
+    debug(0, 5, "storeLockObject: locks %d: <URL:%s>\n", e->lock_count, e->url);
 
     if ((e->mem_status == NOT_IN_MEMORY) &&	/* Not in memory */
 	(e->swap_status != SWAP_OK) &&	/* Not on disk */
 	(e->status != STORE_PENDING)	/* Not being fetched */
 	) {
-	debug(0, "storeLockObject: NOT_IN_MEMORY && !SWAP_OK && !STORE_PENDING conflict: <URL:%s>. aborting...\n", e->url);
+	debug(0, 0, "storeLockObject: NOT_IN_MEMORY && !SWAP_OK && !STORE_PENDING conflict: <URL:%s>. aborting...\n", e->url);
 	/* If this sanity check fails, we should just ... */
 	fatal_dump(NULL);
     }
@@ -372,7 +372,7 @@ int storeUnlockObject(e)
     if ((int) e->lock_count > 0)
 	e->lock_count--;
     else if (e->lock_count == 0) {
-	debug(0, "Entry lock count %d is out-of-whack\n", e->lock_count);
+	debug(0, 0, "Entry lock count %d is out-of-whack\n", e->lock_count);
     }
     /* Prevent UMR if we end up freeing the entry */
     e_lock_count = (int) e->lock_count;
@@ -405,7 +405,7 @@ StoreEntry *storeGet(url)
 {
     hash_link *hptr = NULL;
 
-    debug(5, "storeGet: looking up %s\n", url);
+    debug(0, 5, "storeGet: looking up %s\n", url);
 
     if (table != (HashID) 0) {
 	if ((hptr = hash_lookup(table, url)) != NULL)
@@ -418,7 +418,7 @@ char *storeGenerateKey(url, request_type_id)
      char *url;
      int request_type_id;
 {
-    debug(5, "storeGenerateKey: type=%d %s\n", request_type_id, url);
+    debug(0, 5, "storeGenerateKey: type=%d %s\n", request_type_id, url);
     if (request_type_id == REQUEST_OP_POST) {
 	sprintf(key_temp_buffer, "/post/%s", url);
 	return key_temp_buffer;
@@ -442,7 +442,7 @@ StoreEntry *storeAdd(url, type_notused, mime_hdr, cachable, html_request, reques
     char key[MAX_URL + 16];
     StoreEntry *e = NULL;
 
-    debug(5, "storeAdd: %s\n", url);
+    debug(0, 5, "storeAdd: %s\n", url);
 
     meta_data.store_entries++;
     meta_data.url_strings += strlen(url);
@@ -533,13 +533,13 @@ StoreEntry *storeAddDiskRestore(url, file_number, size, expires, timestamp)
 {
     StoreEntry *e = NULL;
 
-    debug(5, "StoreAddDiskRestore: <URL:%s>: size %d: expires %d: file_number %d\n",
+    debug(0, 5, "StoreAddDiskRestore: <URL:%s>: size %d: expires %d: file_number %d\n",
 	url, size, expires, file_number);
 
     if (file_map_bit_test(file_number)) {
-	debug(0, "This file number is already allocated!\n");
-	debug(0, "    --> file_number %d\n", file_number);
-	debug(0, "    --> <URL:%s>\n", url);
+	debug(0, 0, "This file number is already allocated!\n");
+	debug(0, 0, "    --> file_number %d\n", file_number);
+	debug(0, 0, "    --> <URL:%s>\n", url);
 	return (NULL);
     }
     meta_data.store_entries++;
@@ -588,7 +588,7 @@ int storeRegister(e, fd, handler, data)
     PendingEntry *pe = (PendingEntry *) xmalloc(sizeof(PendingEntry));
     int old_size, i, j;
 
-    debug(5, "storeRegister: FD %d <URL:%s>\n", fd, e->url);
+    debug(0, 5, "storeRegister: FD %d <URL:%s>\n", fd, e->url);
 
     memset(pe, '\0', sizeof(PendingEntry));
     pe->fd = fd;
@@ -626,7 +626,7 @@ int storeRegister(e, fd, handler, data)
 	safe_free(e->mem_obj->pending);
 	e->mem_obj->pending = tmp;
 
-	debug(10, "storeRegister: grew pending list to %d for slot %d.\n",
+	debug(0, 10, "storeRegister: grew pending list to %d for slot %d.\n",
 	    e->mem_obj->pending_list_size, i);
 
     }
@@ -644,7 +644,7 @@ int storeUnregister(e, fd)
     int i;
     int freed = 0;
 
-    debug(10, "storeUnregister: called for FD %d <URL:%s>\n", fd, e->url);
+    debug(0, 10, "storeUnregister: called for FD %d <URL:%s>\n", fd, e->url);
 
     /* look for entry in client_list */
     if (e->mem_obj->client_list) {
@@ -666,7 +666,7 @@ int storeUnregister(e, fd)
 	}
     }
 
-    debug(10, "storeUnregister: returning %d\n", freed);
+    debug(0, 10, "storeUnregister: returning %d\n", freed);
     return freed;
 }
 
@@ -681,8 +681,8 @@ void storeDeleteBehind(e)
     int n_client = 0;
     int i;
 
-    debug(3, "storeDeleteBehind: Object: %s\n", e->key);
-    debug(3, "storeDeleteBehind:\tOriginal Lowest Offset: %d \n", e->mem_obj->e_lowest_offset);
+    debug(0, 3, "storeDeleteBehind: Object: %s\n", e->key);
+    debug(0, 3, "storeDeleteBehind:\tOriginal Lowest Offset: %d \n", e->mem_obj->e_lowest_offset);
 
     free_up_to = e->mem_obj->e_lowest_offset;
     target_offset = 0;
@@ -698,18 +698,18 @@ void storeDeleteBehind(e)
     }
 
     if (n_client == 0) {
-	debug(3, "storeDeleteBehind:\tThere is no client in the list.\n");
-	debug(3, "\t\tTry to delete as fast as possible.\n");
+	debug(0, 3, "storeDeleteBehind:\tThere is no client in the list.\n");
+	debug(0, 3, "\t\tTry to delete as fast as possible.\n");
 	target_offset = e->mem_obj->e_current_len;
     }
-    debug(3, "storeDeleteBehind:\tThe target offset is : %d\n", target_offset);
+    debug(0, 3, "storeDeleteBehind:\tThe target offset is : %d\n", target_offset);
     if (target_offset) {
 	free_up_to = (int) e->mem_obj->data->mem_free_data_upto(e->mem_obj->data,
 	    target_offset);
-	debug(3, "                   Object is freed upto : %d\n", free_up_to);
+	debug(0, 3, "                   Object is freed upto : %d\n", free_up_to);
 	store_mem_size -= free_up_to - e->mem_obj->e_lowest_offset;
     }
-    debug(3, "storeDeleteBehind:\tOutgoing Lowest Offset : %d\n", free_up_to);
+    debug(0, 3, "storeDeleteBehind:\tOutgoing Lowest Offset : %d\n", free_up_to);
     e->mem_obj->e_lowest_offset = free_up_to;
 }
 
@@ -742,12 +742,12 @@ static void InvokeHandlers(e)
 void storeStartDeleteBehind(e)
      StoreEntry *e;
 {
-    debug(2, "storeStartDeleteBehind: Object: %s\n", e->key);
+    debug(0, 2, "storeStartDeleteBehind: Object: %s\n", e->key);
     if (e->flag & DELETE_BEHIND) {
-	debug(2, "storeStartDeleteBehind:\tis already in delete behind mode.\n");
+	debug(0, 2, "storeStartDeleteBehind:\tis already in delete behind mode.\n");
 	return;
     }
-    debug(2, "storeStartDeleteBehind:\tis now in delete behind mode.\n");
+    debug(0, 2, "storeStartDeleteBehind:\tis now in delete behind mode.\n");
     /* change its key, so it couldn't be found by other client */
     storeChangeKey(e);
     BIT_SET(e->flag, DELETE_BEHIND);
@@ -764,26 +764,26 @@ int storeAppend(e, data, len)
 {
     /* validity check -- sometimes it's called with bogus values */
     if (e == NULL || !has_mem_obj(e) || e->mem_obj->data == NULL) {
-	debug(0, "storeAppend (len = %d): Invalid StoreEntry, aborting...\n",
+	debug(0, 0, "storeAppend (len = %d): Invalid StoreEntry, aborting...\n",
 	    len);
 	if (len < 512)
 	    fwrite(data, len, 1, debug_log);
-	debug(0, "%s", storeToString(e));
+	debug(0, 0, "%s", storeToString(e));
 	fatal_dump(NULL);
     }
     if (len) {
-	debug(5, "storeAppend: appending %d bytes for %s\n", len, e->url);
+	debug(0, 5, "storeAppend: appending %d bytes for %s\n", len, e->url);
 
 	/* get some extra storage if needed */
 	(void) storeGetMemSpace(len, 0);
 	store_mem_size += len;
-	debug(8, "storeAppend: growing store_mem_size by %d\n", len);
-	debug(8, "storeAppend: store_mem_size = %d\n", store_mem_size);
+	debug(0, 8, "storeAppend: growing store_mem_size by %d\n", len);
+	debug(0, 8, "storeAppend: store_mem_size = %d\n", store_mem_size);
 
 	(void) e->mem_obj->data->mem_append(e->mem_obj->data,
 	    data, len);
 	e->mem_obj->e_current_len += len;
-	debug(8, "storeAppend: e_current_len = %d\n",
+	debug(0, 8, "storeAppend: e_current_len = %d\n",
 	    e->mem_obj->e_current_len);
     }
     if ((e->status != STORE_ABORTED) && !(e->flag & DELAY_SENDING))
@@ -841,23 +841,23 @@ int storeSwapInHandle(fd_notused, buf, len, flag, e, offset_notused)
      StoreEntry *e;
      int offset_notused;
 {
-    debug(2, "storeSwapInHandle: <URL:%s>\n", e->url);
+    debug(0, 2, "storeSwapInHandle: <URL:%s>\n", e->url);
 
     if ((flag < 0) && (flag != DISK_EOF)) {
-	debug(0, "storeSwapInHandle: SwapIn failure (err code = %d).\n", flag);
+	debug(0, 0, "storeSwapInHandle: SwapIn failure (err code = %d).\n", flag);
 	put_free_8k_page(e->mem_obj->e_swap_buf);
 	storeSetMemStatus(e, NOT_IN_MEMORY);
 	file_close(e->mem_obj->swap_fd);
 	swapInError(-1, e);	/* Invokes storeAbort() and completes the I/O */
 	return -1;
     }
-    debug(5, "storeSwapInHandle: e->swap_offset   = %d\n",
+    debug(0, 5, "storeSwapInHandle: e->swap_offset   = %d\n",
 	e->mem_obj->swap_offset);
-    debug(5, "storeSwapInHandle: len              = %d\n",
+    debug(0, 5, "storeSwapInHandle: len              = %d\n",
 	len);
-    debug(5, "storeSwapInHandle: e->e_current_len = %d\n",
+    debug(0, 5, "storeSwapInHandle: e->e_current_len = %d\n",
 	e->mem_obj->e_current_len);
-    debug(5, "storeSwapInHandle: e->object_len    = %d\n",
+    debug(0, 5, "storeSwapInHandle: e->object_len    = %d\n",
 	e->object_len);
 
     /* always call these, even if len == 0 */
@@ -877,14 +877,14 @@ int storeSwapInHandle(fd_notused, buf, len, flag, e, offset_notused)
 	storeSetMemStatus(e, IN_MEMORY);
 	put_free_8k_page(e->mem_obj->e_swap_buf);
 	file_close(e->mem_obj->swap_fd);
-	debug(5, "storeSwapInHandle: SwapIn complete: <URL:%s> from %s.\n",
+	debug(0, 5, "storeSwapInHandle: SwapIn complete: <URL:%s> from %s.\n",
 	    e->url, storeSwapFullPath(e->swap_file_number, NULL));
 	if (e->mem_obj->e_current_len != e->object_len) {
-	    debug(0, "storeSwapInHandle: WARNING! Object size mismatch.\n");
-	    debug(0, "  --> <URL:%s>\n", e->url);
-	    debug(0, "  --> Expecting %d bytes from file: %s\n", e->object_len,
+	    debug(0, 0, "storeSwapInHandle: WARNING! Object size mismatch.\n");
+	    debug(0, 0, "  --> <URL:%s>\n", e->url);
+	    debug(0, 0, "  --> Expecting %d bytes from file: %s\n", e->object_len,
 		storeSwapFullPath(e->swap_file_number, NULL));
-	    debug(0, "  --> Only read %d bytes\n",
+	    debug(0, 0, "  --> Only read %d bytes\n",
 		e->mem_obj->e_current_len);
 	}
 	if (e->flag & RELEASE_REQUEST)
@@ -901,7 +901,7 @@ int storeSwapInStart(e)
 
     /* sanity check! */
     if ((e->swap_status != SWAP_OK) || (e->swap_file_number < 0)) {
-	debug(0, "storeSwapInStart: <No filename:%d> ? <URL:%s>\n", e->swap_file_number, e->url);
+	debug(0, 0, "storeSwapInStart: <No filename:%d> ? <URL:%s>\n", e->swap_file_number, e->url);
 	if (has_mem_obj(e))
 	    e->mem_obj->swap_fd = -1;
 	return -1;
@@ -912,13 +912,13 @@ int storeSwapInStart(e)
     e->mem_obj->swap_fd = fd =
 	file_open(storeSwapFullPath(e->swap_file_number, NULL), NULL, O_RDONLY);
     if (fd < 0) {
-	debug(0, "storeSwapInStart: Unable to open swapfile: %s for\n\t<URL:%s>\n",
+	debug(0, 0, "storeSwapInStart: Unable to open swapfile: %s for\n\t<URL:%s>\n",
 	    storeSwapFullPath(e->swap_file_number, NULL), e->url);
 	storeSetMemStatus(e, NOT_IN_MEMORY);
 	/* Invoke a store abort that should free the destroy_store_mem_obj(e); */
 	return -1;
     }
-    debug(5, "storeSwapInStart: initialized swap file '%s' for <URL:%s>\n",
+    debug(0, 5, "storeSwapInStart: initialized swap file '%s' for <URL:%s>\n",
 	storeSwapFullPath(e->swap_file_number, NULL), e->url);
 
     e->mem_obj->data = memInit();
@@ -948,14 +948,14 @@ void storeSwapOutHandle(fd, flag, e)
     static char logmsg[6000];
     char *page_ptr = NULL;
 
-    debug(5, "storeSwapOutHandle: <URL:%s>\n", e->url);
+    debug(0, 5, "storeSwapOutHandle: <URL:%s>\n", e->url);
 
     e->timestamp = cached_curtime;
     storeSwapFullPath(e->swap_file_number, filename);
     page_ptr = e->mem_obj->e_swap_buf;
 
     if (flag < 0) {
-	debug(1, "storeSwapOutHandle: SwapOut failure (err code = %d).\n",
+	debug(0, 1, "storeSwapOutHandle: SwapOut failure (err code = %d).\n",
 	    flag);
 	e->swap_status = NO_SWAP;
 	put_free_8k_page(page_ptr);
@@ -976,13 +976,13 @@ void storeSwapOutHandle(fd, flag, e)
 	}
 	return;
     }
-    debug(6, "storeSwapOutHandle: e->swap_offset    = %d\n",
+    debug(0, 6, "storeSwapOutHandle: e->swap_offset    = %d\n",
 	e->mem_obj->swap_offset);
-    debug(6, "storeSwapOutHandle: e->e_swap_buf_len = %d\n",
+    debug(0, 6, "storeSwapOutHandle: e->e_swap_buf_len = %d\n",
 	e->mem_obj->e_swap_buf_len);
-    debug(6, "storeSwapOutHandle: e->object_len     = %d\n",
+    debug(0, 6, "storeSwapOutHandle: e->object_len     = %d\n",
 	e->object_len);
-    debug(6, "storeSwapOutHandle: store_swap_size   = %dk\n",
+    debug(0, 6, "storeSwapOutHandle: store_swap_size   = %dk\n",
 	store_swap_size);
 
     e->mem_obj->swap_offset += e->mem_obj->e_swap_buf_len;
@@ -992,7 +992,7 @@ void storeSwapOutHandle(fd, flag, e)
 	/* swapping complete */
 	e->swap_status = SWAP_OK;
 	file_close(e->mem_obj->swap_fd);
-	debug(5, "storeSwapOutHandle: SwapOut complete: <URL:%s> to %s.\n",
+	debug(0, 5, "storeSwapOutHandle: SwapOut complete: <URL:%s> to %s.\n",
 	    e->url, storeSwapFullPath(e->swap_file_number, NULL));
 	put_free_8k_page(page_ptr);
 	sprintf(logmsg, "FILE: %s URL: %s %d %d %d\n",
@@ -1039,19 +1039,19 @@ int storeSwapOutStart(e)
 
     fd = file_open(swapfilename, NULL, O_RDWR | O_CREAT | O_TRUNC);
     if (fd < 0) {
-	debug(0, "storeSwapOutStart: Unable to open swapfile: %s\n",
+	debug(0, 0, "storeSwapOutStart: Unable to open swapfile: %s\n",
 	    swapfilename);
 	file_map_bit_reset(swapfileno);
 	e->swap_file_number = -1;
 	return -1;
     }
     e->mem_obj->swap_fd = fd;
-    debug(5, "storeSwapOutStart: Begin SwapOut <URL:%s> to FD %d FILE %s.\n",
+    debug(0, 5, "storeSwapOutStart: Begin SwapOut <URL:%s> to FD %d FILE %s.\n",
 	e->url, fd, swapfilename);
 
     e->swap_file_number = swapfileno;
     if ((e->mem_obj->e_swap_access = file_write_lock(e->mem_obj->swap_fd)) < 0) {
-	debug(0, "storeSwapOutStart: Unable to lock swapfile: %s\n",
+	debug(0, 0, "storeSwapOutStart: Unable to lock swapfile: %s\n",
 	    swapfilename);
 	file_map_bit_reset(e->swap_file_number);
 	e->swap_file_number = -1;
@@ -1105,7 +1105,7 @@ void storeRebuildFromDisk()
     int fast_mode = 0;
 
     for (i = 0; i < ncache_dirs; ++i)
-	debug(1, "Rebuilding storage from disk image in %s\n", swappath(i));
+	debug(0, 1, "Rebuilding storage from disk image in %s\n", swappath(i));
     start = cached_curtime = time(NULL);
 
     sprintf(line_in, "%s/log-last-clean", swappath(0));
@@ -1117,7 +1117,7 @@ void storeRebuildFromDisk()
 	}
     }
     if (fast_mode)
-	debug(1, "Rebuilding in FAST MODE.\n");
+	debug(0, 1, "Rebuilding in FAST MODE.\n");
 
     /* go to top of the file */
     (void) lseek(swaplog_fd, 0L, SEEK_SET);
@@ -1129,9 +1129,9 @@ void storeRebuildFromDisk()
 	    cached_curtime = time(NULL);
 
 	if ((linecount & 0xFFF) == 0)
-	    debug(1, "  %7d Lines read so far.\n", linecount);
+	    debug(0, 1, "  %7d Lines read so far.\n", linecount);
 
-	debug(10, "line_in: %s", line_in);
+	debug(0, 10, "line_in: %s", line_in);
 	if ((line_in[0] == '\0') || (line_in[0] == '\n') ||
 	    (line_in[0] == '#'))
 	    continue;		/* skip bad lines */
@@ -1167,13 +1167,13 @@ void storeRebuildFromDisk()
 
 	    if (stat(swapfile, &sb) < 0) {
 		if (expires < cached_curtime) {
-		    debug(3, "storeRebuildFromDisk: Expired: <URL:%s>\n", url);
+		    debug(0, 3, "storeRebuildFromDisk: Expired: <URL:%s>\n", url);
 #ifdef UNLINK_ON_RELOAD
 		    safeunlink(swapfile, 1);
 #endif
 		    expcount++;
 		} else {
-		    debug(3, "storeRebuildFromDisk: Swap file missing: <URL:%s>: %s: %s.\n", url, swapfile, xstrerror());
+		    debug(0, 3, "storeRebuildFromDisk: Swap file missing: <URL:%s>: %s: %s.\n", url, swapfile, xstrerror());
 #ifdef UNLINK_ON_RELOAD
 		    safeunlink(log_swapfile, 1);
 #endif
@@ -1194,17 +1194,17 @@ void storeRebuildFromDisk()
 		continue;
 	    }
 	    timestamp = sb.st_mtime;
-	    debug(10, "storeRebuildFromDisk: Cached file exists: <URL:%s>: %s\n",
+	    debug(0, 10, "storeRebuildFromDisk: Cached file exists: <URL:%s>: %s\n",
 		url, swapfile);
 	}
 	if ((e = storeGet(url))) {
-	    debug(6, "storeRebuildFromDisk: Duplicate: <URL:%s>\n", url);
+	    debug(0, 6, "storeRebuildFromDisk: Duplicate: <URL:%s>\n", url);
 	    storeRelease(e);
 	    objcount--;
 	    dupcount++;
 	}
 	if (expires < cached_curtime) {
-	    debug(3, "storeRebuildFromDisk: Expired: <URL:%s>\n", url);
+	    debug(0, 3, "storeRebuildFromDisk: Expired: <URL:%s>\n", url);
 #ifdef UNLINK_ON_RELOAD
 	    safeunlink(swapfile, 1);
 #endif
@@ -1228,15 +1228,15 @@ void storeRebuildFromDisk()
     r = stop - start;
     /* swapfileno = sfileno; */
     /* PBD: Start swapfileno at zero, so that old swap files are overwritten */
-    debug(1, "Finished rebuilding storage from disk image.\n");
-    debug(1, "  %7d Lines read from previous logfile.\n", linecount);
-    debug(1, "  %7d Objects loaded.\n", objcount);
-    debug(1, "  %7d Objects expired.\n", expcount);
-    debug(1, "  %7d Duplicate URLs purged.\n", dupcount);
-    debug(1, "  %7d Swapfile clashes avoided.\n", clashcount);
-    debug(1, "  Took %d seconds (%6.1lf objects/sec).\n",
+    debug(0, 1, "Finished rebuilding storage from disk image.\n");
+    debug(0, 1, "  %7d Lines read from previous logfile.\n", linecount);
+    debug(0, 1, "  %7d Objects loaded.\n", objcount);
+    debug(0, 1, "  %7d Objects expired.\n", expcount);
+    debug(0, 1, "  %7d Duplicate URLs purged.\n", dupcount);
+    debug(0, 1, "  %7d Swapfile clashes avoided.\n", clashcount);
+    debug(0, 1, "  Took %d seconds (%6.1lf objects/sec).\n",
 	r > 0 ? r : 0, (double) objcount / (r > 0 ? r : 1));
-    debug(1, "  store_swap_size = %dk\n", store_swap_size);
+    debug(0, 1, "  store_swap_size = %dk\n", store_swap_size);
 
     /* touch a timestamp file */
     sprintf(line_in, "%s/log-last-clean", swappath(0));
@@ -1261,7 +1261,7 @@ int storeGetMemSize()
 void storeComplete(e)
      StoreEntry *e;
 {
-    debug(5, "storeComplete: <URL:%s>\n", e->url);
+    debug(0, 5, "storeComplete: <URL:%s>\n", e->url);
 
     e->object_len = e->mem_obj->e_current_len;
     InvokeHandlers(e);
@@ -1295,7 +1295,7 @@ int storeAbort(e, msg)
     static char mime_hdr[300];
     static char abort_msg[2000];
 
-    debug(6, "storeAbort: <URL:%s>\n", e->url);
+    debug(0, 6, "storeAbort: <URL:%s>\n", e->url);
     e->expires = cached_curtime + getNegativeTTL();
     e->status = STORE_ABORTED;
     storeSetMemStatus(e, IN_MEMORY);
@@ -1326,7 +1326,7 @@ int storeAbort(e, msg)
 	if ((int) (strlen(msg) + strlen(mime_hdr) + 50) < 2000) {
 	    sprintf(abort_msg, "HTTP/1.0 400 Cache Detected Error\r\n%s\r\n\r\n%s", mime_hdr, msg);
 	} else {
-	    debug(0, "storeAbort: WARNING: Must increase msg length!");
+	    debug(0, 0, "storeAbort: WARNING: Must increase msg length!");
 	}
 	storeAppend(e, abort_msg, strlen(abort_msg));
 	e->mem_obj->e_abort_msg = xstrdup(abort_msg);
@@ -1409,7 +1409,7 @@ int storeWalkThrough(proc, data)
 	if ((++n & 0xFF) == 0)
 	    cached_curtime = time(NULL);
 	if ((n & 0xFFF) == 0)
-	    debug(2, "storeWalkThrough: %7d objects so far.\n", n);
+	    debug(0, 2, "storeWalkThrough: %7d objects so far.\n", n);
 	count += proc(e, data);
     }
     return count;
@@ -1424,12 +1424,12 @@ int removeOldEntry(e, data)
 {
     time_t curtime = *((time_t *) data);
 
-    debug(5, "removeOldEntry: Checking: %s\n", e->url);
-    debug(6, "removeOldEntry:   *       curtime: %8ld\n", curtime);
-    debug(6, "removeOldEntry:   *  e->timestamp: %8ld\n", e->timestamp);
-    debug(6, "removeOldEntry:   * time in cache: %8ld\n",
+    debug(0, 5, "removeOldEntry: Checking: %s\n", e->url);
+    debug(0, 6, "removeOldEntry:   *       curtime: %8ld\n", curtime);
+    debug(0, 6, "removeOldEntry:   *  e->timestamp: %8ld\n", e->timestamp);
+    debug(0, 6, "removeOldEntry:   * time in cache: %8ld\n",
 	curtime - e->timestamp);
-    debug(6, "removeOldEntry:   *  time-to-live: %8ld\n",
+    debug(0, 6, "removeOldEntry:   *  time-to-live: %8ld\n",
 	e->expires - cached_curtime);
 
     if ((cached_curtime > e->expires) && (e->status != STORE_PENDING)) {
@@ -1444,10 +1444,10 @@ int storePurgeOld()
 {
     int n;
 
-    debug(3, "storePurgeOld: Begin purging TTL-expired objects\n");
+    debug(0, 3, "storePurgeOld: Begin purging TTL-expired objects\n");
     n = storeWalkThrough(removeOldEntry, (caddr_t) & cached_curtime);
-    debug(3, "storePurgeOld: Done purging TTL-expired objects.\n");
-    debug(3, "storePurgeOld: %d objects expired\n", n);
+    debug(0, 3, "storePurgeOld: Done purging TTL-expired objects.\n");
+    debug(0, 3, "storePurgeOld: %d objects expired\n", n);
     return n;
 }
 
@@ -1482,7 +1482,7 @@ int storeGetMemSpace(size, check_vm_number)
     if (!check_vm_number && ((store_mem_size + size) < store_mem_high))
 	return 0;
 
-    debug(2, "storeGetMemSpace: Starting...\n");
+    debug(0, 2, "storeGetMemSpace: Starting...\n");
 
     LRU_list = create_dynamic_array(meta_data.store_in_mem_objects, MEM_LRUSCAN_BLOCK);
     pending_entry_list = create_dynamic_array(meta_data.store_in_mem_objects, MEM_LRUSCAN_BLOCK);
@@ -1500,7 +1500,7 @@ int storeGetMemSpace(size, check_vm_number)
 	    continue;
 	}
 	if (cached_curtime > e->expires) {
-	    debug(2, "storeGetMemSpace: Expired: %s\n", e->url);
+	    debug(0, 2, "storeGetMemSpace: Expired: %s\n", e->url);
 	    n_expired++;
 	    /* Delayed release */
 	    storeRelease(e);
@@ -1517,26 +1517,26 @@ int storeGetMemSpace(size, check_vm_number)
 	} else {
 	    n_cantpurge++;
 	    mem_cantpurge += e->mem_obj->e_current_len;
-	    debug(5, "storeGetMemSpace: Can't purge %7d bytes: %s\n",
+	    debug(0, 5, "storeGetMemSpace: Can't purge %7d bytes: %s\n",
 		e->mem_obj->e_current_len, e->url);
 	    if (e->swap_status != SWAP_OK)
-		debug(5, "storeGetMemSpace: --> e->swap_status != SWAP_OK\n");
+		debug(0, 5, "storeGetMemSpace: --> e->swap_status != SWAP_OK\n");
 	    if (e->lock_count)
-		debug(5, "storeGetMemSpace: --> e->lock_count %d\n", e->lock_count);
+		debug(0, 5, "storeGetMemSpace: --> e->lock_count %d\n", e->lock_count);
 	}
     }
-    debug(2, "storeGetMemSpace: Current size:     %7d bytes\n", store_mem_size);
-    debug(2, "storeGetMemSpace: High W Mark:      %7d bytes\n", store_mem_high);
-    debug(2, "storeGetMemSpace: Low W Mark:       %7d bytes\n", store_mem_low);
-    debug(2, "storeGetMemSpace: Entry count:      %7d items\n", meta_data.store_entries);
-    debug(2, "storeGetMemSpace: Scanned:          %7d items\n", n_scanned);
-    debug(2, "storeGetMemSpace: In memory:        %7d items\n", n_inmem);
-    debug(2, "storeGetMemSpace: Hot vm count:     %7d items\n", meta_data.hot_vm);
-    debug(2, "storeGetMemSpace: Expired:          %7d items\n", n_expired);
-    debug(2, "storeGetMemSpace: Negative Cached:  %7d items\n", n_aborted);
-    debug(2, "storeGetMemSpace: Can't purge:      %7d items\n", n_cantpurge);
-    debug(2, "storeGetMemSpace: Can't purge size: %7d bytes\n", mem_cantpurge);
-    debug(2, "storeGetMemSpace: Sorting LRU_list: %7d items\n", LRU_list->index);
+    debug(0, 2, "storeGetMemSpace: Current size:     %7d bytes\n", store_mem_size);
+    debug(0, 2, "storeGetMemSpace: High W Mark:      %7d bytes\n", store_mem_high);
+    debug(0, 2, "storeGetMemSpace: Low W Mark:       %7d bytes\n", store_mem_low);
+    debug(0, 2, "storeGetMemSpace: Entry count:      %7d items\n", meta_data.store_entries);
+    debug(0, 2, "storeGetMemSpace: Scanned:          %7d items\n", n_scanned);
+    debug(0, 2, "storeGetMemSpace: In memory:        %7d items\n", n_inmem);
+    debug(0, 2, "storeGetMemSpace: Hot vm count:     %7d items\n", meta_data.hot_vm);
+    debug(0, 2, "storeGetMemSpace: Expired:          %7d items\n", n_expired);
+    debug(0, 2, "storeGetMemSpace: Negative Cached:  %7d items\n", n_aborted);
+    debug(0, 2, "storeGetMemSpace: Can't purge:      %7d items\n", n_cantpurge);
+    debug(0, 2, "storeGetMemSpace: Can't purge size: %7d bytes\n", mem_cantpurge);
+    debug(0, 2, "storeGetMemSpace: Sorting LRU_list: %7d items\n", LRU_list->index);
     qsort((char *) LRU_list->collection, LRU_list->index, sizeof(e), (int (*)(const void *, const void *)) compareLastRef);
 
     /* Kick LRU out until we have enough memory space */
@@ -1569,29 +1569,29 @@ int storeGetMemSpace(size, check_vm_number)
 
     destroy_dynamic_array(LRU_list);
 
-    debug(2, "storeGetMemSpace: After freeing size: %7d bytes\n", store_mem_size);
-    debug(2, "storeGetMemSpace: Purged:             %7d items\n", n_purged);
-    debug(2, "storeGetMemSpace: Released:           %7d items\n", n_released);
+    debug(0, 2, "storeGetMemSpace: After freeing size: %7d bytes\n", store_mem_size);
+    debug(0, 2, "storeGetMemSpace: Purged:             %7d items\n", n_purged);
+    debug(0, 2, "storeGetMemSpace: Released:           %7d items\n", n_released);
 
 
     if (check_vm_number) {
 	/* don't check for size */
 	destroy_dynamic_array(pending_entry_list);
-	debug(2, "storeGetMemSpace: Done.\n");
+	debug(0, 2, "storeGetMemSpace: Done.\n");
 	return 0;
     }
     if ((store_mem_size + size) < store_mem_high) {
 	/* we don't care for hot_vm count here, just the storage size. */
 	over_highwater = over_max = 0;
 	destroy_dynamic_array(pending_entry_list);
-	debug(2, "storeGetMemSpace: Done.\n");
+	debug(0, 2, "storeGetMemSpace: Done.\n");
 	return 0;
     }
     if ((store_mem_size + size) < getCacheMemMax()) {
 	/* We're over high water mark here, but still under absolute max */
 	if (!over_highwater) {
 	    /* print only once when the condition occur until it clears. */
-	    debug(1, "storeGetMemSpace: Allocating beyond the high water mark with total size of %d\n",
+	    debug(0, 1, "storeGetMemSpace: Allocating beyond the high water mark with total size of %d\n",
 		store_mem_size + size);
 	    over_highwater = 1;
 	}
@@ -1601,11 +1601,11 @@ int storeGetMemSpace(size, check_vm_number)
 	/* We're over absolute max */
 	if (!over_max) {
 	    /* print only once when the condition occur until it clears. */
-	    debug(1, "storeGetMemSpace: Allocating beyond the MAX Store with total size of %d\n",
+	    debug(0, 1, "storeGetMemSpace: Allocating beyond the MAX Store with total size of %d\n",
 		store_mem_size + size);
-	    debug(1, "       Start Deleting Behind for every pending objects\n:");
-	    debug(1, "       You should really adjust your cache_mem, high/low water mark,\n");
-	    debug(1, "       max object size to suit your need.\n");
+	    debug(0, 1, "       Start Deleting Behind for every pending objects\n:");
+	    debug(0, 1, "       You should really adjust your cache_mem, high/low water mark,\n");
+	    debug(0, 1, "       max object size to suit your need.\n");
 	    over_max = 1;
 	}
 	/* delete all of them, we desperate for a space. */
@@ -1620,19 +1620,19 @@ int storeGetMemSpace(size, check_vm_number)
 	    storeStartDeleteBehind(pending_entry_list->collection[i]);
 	}
     if (n_deleted_behind) {
-	debug(1, "storeGetMemSpace: Due to memory flucuation, put %d objects to DELETE_BEHIND MODE.\n",
+	debug(0, 1, "storeGetMemSpace: Due to memory flucuation, put %d objects to DELETE_BEHIND MODE.\n",
 	    n_deleted_behind);
     }
     destroy_dynamic_array(pending_entry_list);
-    debug(2, "storeGetMemSpace: Done.\n");
+    debug(0, 2, "storeGetMemSpace: Done.\n");
     return 0;
 }
 
 int compareSize(e1, e2)
      StoreEntry **e1, **e2;
 {
     if (!e1 || !e2) {
-	debug(1, "compareSize: Called with at least one null argument, shouldn't happen.\n");
+	debug(0, 1, "compareSize: Called with at least one null argument, shouldn't happen.\n");
 	return 0;
     }
     if ((*e1)->mem_obj->e_current_len > (*e2)->mem_obj->e_current_len)
@@ -1704,13 +1704,13 @@ int storeGetSwapSpace(size)
     if (!fReduceSwap && (store_swap_size + kb_size <= store_swap_high)) {
 	return 0;
     }
-    debug(2, "storeGetSwapSpace: Starting...\n");
+    debug(0, 2, "storeGetSwapSpace: Starting...\n");
 
     /* Set flag if swap size over high-water-mark */
     if (store_swap_size + kb_size > store_swap_high)
 	fReduceSwap = 1;
 
-    debug(2, "storeGetSwapSpace: Need %d bytes...\n", size);
+    debug(0, 2, "storeGetSwapSpace: Need %d bytes...\n", size);
 
     LRU_list = create_dynamic_array(LRU_cur_size, LRU_cur_size);
     /* remove expired objects until recover enough space or no expired objects */
@@ -1733,7 +1733,7 @@ int storeGetSwapSpace(size)
 		(e->lock_count == 0) &&		/* Be overly cautious */
 		(e->mem_status != SWAPPING_IN)) {	/* Not if it's being faulted into memory */
 		if (cached_curtime > e->expires) {
-		    debug(2, "storeRemoveExpiredObj: Expired: <URL:%s>\n", e->url);
+		    debug(0, 2, "storeRemoveExpiredObj: Expired: <URL:%s>\n", e->url);
 		    /* just call release. don't have to check for lock status.
 		     * storeRelease will take care of that and set a pending flag
 		     * if it's still locked. */
@@ -1745,13 +1745,13 @@ int storeGetSwapSpace(size)
 		    ++scan_in_objs;
 		}
 	    } else {
-		debug(2, "storeGetSwapSpace: Can't purge %7d bytes: <URL:%s>\n",
+		debug(0, 2, "storeGetSwapSpace: Can't purge %7d bytes: <URL:%s>\n",
 		    e->object_len, e->url);
 		if (e->lock_count) {
-		    debug(2, "\t\te->lock_count %d\n", e->lock_count);
+		    debug(0, 2, "\t\te->lock_count %d\n", e->lock_count);
 		}
 		if (e->swap_status == SWAPPING_OUT) {
-		    debug(2, "\t\te->swap_status == SWAPPING_OUT\n");
+		    debug(0, 2, "\t\te->swap_status == SWAPPING_OUT\n");
 		}
 		locked++;
 		locked_size += e->mem_obj->e_current_len;
@@ -1766,7 +1766,7 @@ int storeGetSwapSpace(size)
 	    ) {
 	    fReduceSwap = 0;
 	    destroy_dynamic_array(LRU_list);
-	    debug(2, "storeGetSwapSpace: Finished, %d objects expired.\n",
+	    debug(0, 2, "storeGetSwapSpace: Finished, %d objects expired.\n",
 		expired);
 	    return 0;
 	}
@@ -1780,16 +1780,16 @@ int storeGetSwapSpace(size)
     }				/* for */
 
     /* end of candidate selection */
-    debug(2, "storeGetSwapSpace: Current Size:   %7d kbytes\n", store_swap_size);
-    debug(2, "storeGetSwapSpace: High W Mark:    %7d kbytes\n", store_swap_high);
-    debug(2, "storeGetSwapSpace: Low W Mark:     %7d kbytes\n", store_swap_low);
-    debug(2, "storeGetSwapSpace: Entry count:    %7d items\n", meta_data.store_entries);
-    debug(2, "storeGetSwapSpace: Scanned:        %7d items\n", scanned);
-    debug(2, "storeGetSwapSpace: Expired:        %7d items\n", expired);
-    debug(2, "storeGetSwapSpace: Locked:         %7d items\n", locked);
-    debug(2, "storeGetSwapSpace: Locked Space:   %7d bytes\n", locked_size);
-    debug(2, "storeGetSwapSpace: Scan in array:  %7d bytes\n", scan_in_objs);
-    debug(2, "storeGetSwapSpace: LRU candidate:  %7d items\n", LRU_list->index);
+    debug(0, 2, "storeGetSwapSpace: Current Size:   %7d kbytes\n", store_swap_size);
+    debug(0, 2, "storeGetSwapSpace: High W Mark:    %7d kbytes\n", store_swap_high);
+    debug(0, 2, "storeGetSwapSpace: Low W Mark:     %7d kbytes\n", store_swap_low);
+    debug(0, 2, "storeGetSwapSpace: Entry count:    %7d items\n", meta_data.store_entries);
+    debug(0, 2, "storeGetSwapSpace: Scanned:        %7d items\n", scanned);
+    debug(0, 2, "storeGetSwapSpace: Expired:        %7d items\n", expired);
+    debug(0, 2, "storeGetSwapSpace: Locked:         %7d items\n", locked);
+    debug(0, 2, "storeGetSwapSpace: Locked Space:   %7d bytes\n", locked_size);
+    debug(0, 2, "storeGetSwapSpace: Scan in array:  %7d bytes\n", scan_in_objs);
+    debug(0, 2, "storeGetSwapSpace: LRU candidate:  %7d items\n", LRU_list->index);
 
     /* Although all expired objects removed, still didn't recover enough */
     /* space.  Kick LRU out until we have enough swap space */
@@ -1802,34 +1802,34 @@ int storeGetSwapSpace(size)
 	    if (storeRelease(LRU) == 0) {
 		removed++;
 	    } else {
-		debug(2, "storeGetSwapSpace: Help! Can't remove objects. <%s>\n",
+		debug(0, 2, "storeGetSwapSpace: Help! Can't remove objects. <%s>\n",
 		    LRU->url);
 	    }
 	}
     }
-    debug(2, "storeGetSwapSpace: After Freeing Size:   %7d kbytes\n", store_swap_size);
+    debug(0, 2, "storeGetSwapSpace: After Freeing Size:   %7d kbytes\n", store_swap_size);
 
     /* free the list */
     destroy_dynamic_array(LRU_list);
 
     if ((store_swap_size + kb_size > store_swap_high)) {
 	if (++swap_help > SWAP_MAX_HELP) {
-	    debug(0, "storeGetSwapSpace: Nothing to free with %d Kbytes in use.\n",
+	    debug(0, 0, "storeGetSwapSpace: Nothing to free with %d Kbytes in use.\n",
 		store_swap_size);
-	    debug(0, "--> Asking for %d bytes\n", size);
-	    debug(0, "WARNING! Repeated failures to allocate swap space!\n");
-	    debug(0, "WARNING! Please check your disk space.\n");
+	    debug(0, 0, "--> Asking for %d bytes\n", size);
+	    debug(0, 0, "WARNING! Repeated failures to allocate swap space!\n");
+	    debug(0, 0, "WARNING! Please check your disk space.\n");
 	    swap_help = 0;
 	} else {
-	    debug(2, "storeGetSwapSpace: Nothing to free with %d Kbytes in use.\n",
+	    debug(0, 2, "storeGetSwapSpace: Nothing to free with %d Kbytes in use.\n",
 		store_swap_size);
-	    debug(2, "--> Asking for %d bytes\n", size);
+	    debug(0, 2, "--> Asking for %d bytes\n", size);
 	}
     } else {
 	swap_help = 0;
     }
 
-    debug(2, "storeGetSwapSpace: Finished, %d objects removed.\n", removed);
+    debug(0, 2, "storeGetSwapSpace: Finished, %d objects removed.\n", removed);
     return 0;
 }
 
@@ -1849,28 +1849,28 @@ int storeRelease(e)
 	BIT_SET(e->flag, RELEASE_REQUEST);
 	return -1;
     }
-    debug(5, "storeRelease: Releasing: %s\n", e->url);
+    debug(0, 5, "storeRelease: Releasing: %s\n", e->url);
 
     if (table == (HashID) 0)
 	return -1;
 
     if (e->key == NULL) {
-	debug(0, "storeRelease: NULL key for %s\n", e->url);
-	debug(0, "Dump of Entry 'e':\n %s\n", storeToString(e));
+	debug(0, 0, "storeRelease: NULL key for %s\n", e->url);
+	debug(0, 0, "Dump of Entry 'e':\n %s\n", storeToString(e));
 	fatal_dump(NULL);
     }
     if ((hptr = hash_lookup(table, e->key)) == NULL) {
-	debug(0, "storeRelease: Not Found: %s\n", e->url);
-	debug(0, "Dump of Entry 'e':\n %s\n", storeToString(e));
+	debug(0, 0, "storeRelease: Not Found: %s\n", e->url);
+	debug(0, 0, "Dump of Entry 'e':\n %s\n", storeToString(e));
 	fatal_dump(NULL);
     }
     result = (StoreEntry *) hptr;
 
     if (result != e) {
-	debug(0, "storeRelease: Duplicated entry? <URL:%s>\n",
+	debug(0, 0, "storeRelease: Duplicated entry? <URL:%s>\n",
 	    result->url ? result->url : "NULL");
-	debug(0, "Dump of Entry 'e':\n%s", storeToString(e));
-	debug(0, "Dump of Entry 'result':\n%s", storeToString(result));
+	debug(0, 0, "Dump of Entry 'e':\n%s", storeToString(e));
+	debug(0, 0, "Dump of Entry 'result':\n%s", storeToString(result));
 	fatal_dump(NULL);
     }
     if (e->type_id == REQUEST_OP_GET) {
@@ -1885,7 +1885,7 @@ int storeRelease(e)
 	    }
 	}
     }
-    debug(3, "storeRelease: Release object key: %s \n", e->key);
+    debug(0, 3, "storeRelease: Release object key: %s \n", e->key);
 
     if (e->swap_status == SWAP_OK && (e->swap_file_number > -1)) {
 	(void) safeunlink(storeSwapFullPath(e->swap_file_number, NULL), 0);
@@ -1914,7 +1914,7 @@ void storeChangeKey(e)
 	return;
 
     if (e->key == NULL) {
-	debug(0, "storeChangeKey: NULL key for %s\n", e->url);
+	debug(0, 0, "storeChangeKey: NULL key for %s\n", e->url);
 	return;
     }
     if (table != (HashID) 0) {
@@ -1934,7 +1934,7 @@ void storeChangeKey(e)
 	    BIT_SET(result->flag, KEY_CHANGE);
 	    BIT_RESET(result->flag, KEY_URL);
 	} else {
-	    debug(1, "storeChangeKey: Key is not unique for key: %s\n", e->key);
+	    debug(0, 1, "storeChangeKey: Key is not unique for key: %s\n", e->key);
 	}
     }
 }
@@ -1954,8 +1954,8 @@ int storeEntryLocked(e)
      StoreEntry *e;
 {
     if (!e) {
-	debug(0, "This entry should be valid.\n");
-	debug(0, "%s", storeToString(e));
+	debug(0, 0, "This entry should be valid.\n");
+	debug(0, 0, "%s", storeToString(e));
 	fatal_dump(NULL);
     }
     return ((e->lock_count) ||
@@ -1979,16 +1979,16 @@ int storeCopy(e, stateoffset, maxSize, buf, size)
 
     if (stateoffset < e->mem_obj->e_lowest_offset) {
 	/* this should not happen. Logic race !!! */
-	debug(1, "storeCopy: Client Request a chunk of data in area lower than the lowest_offset\n");
-	debug(1, "           Current Lowest offset : %d\n", e->mem_obj->e_lowest_offset);
-	debug(1, "           Requested offset      : %d\n", stateoffset);
+	debug(0, 1, "storeCopy: Client Request a chunk of data in area lower than the lowest_offset\n");
+	debug(0, 1, "           Current Lowest offset : %d\n", e->mem_obj->e_lowest_offset);
+	debug(0, 1, "           Requested offset      : %d\n", stateoffset);
 	/* can't really do anything here. Client may hang until lifetime runout. */
 	return 0;
     }
     *size = (available_to_write >= maxSize) ?
 	maxSize : available_to_write;
 
-    debug(6, "storeCopy: avail_to_write=%d, store_offset=%d\n",
+    debug(0, 6, "storeCopy: avail_to_write=%d, store_offset=%d\n",
 	*size, stateoffset);
 
     if (*size > 0)
@@ -2081,17 +2081,17 @@ int storeClientCopy(e, stateoffset, maxSize, buf, size, fd)
 
     if (stateoffset < e->mem_obj->e_lowest_offset) {
 	/* this should not happen. Logic race !!! */
-	debug(1, "storeClientCopy: Client Request a chunk of data in area lower than the lowest_offset\n");
-	debug(1, "                              fd : %d\n", fd);
-	debug(1, "           Current Lowest offset : %d\n", e->mem_obj->e_lowest_offset);
-	debug(1, "           Requested offset      : %d\n", stateoffset);
+	debug(0, 1, "storeClientCopy: Client Request a chunk of data in area lower than the lowest_offset\n");
+	debug(0, 1, "                              fd : %d\n", fd);
+	debug(0, 1, "           Current Lowest offset : %d\n", e->mem_obj->e_lowest_offset);
+	debug(0, 1, "           Requested offset      : %d\n", stateoffset);
 	/* can't really do anything here. Client may hang until lifetime runout. */
 	return 0;
     }
     *size = (available_to_write >= maxSize) ?
 	maxSize : available_to_write;
 
-    debug(6, "storeCopy: avail_to_write=%d, store_offset=%d\n",
+    debug(0, 6, "storeCopy: avail_to_write=%d, store_offset=%d\n",
 	*size, stateoffset);
 
     /* update the lowest requested offset */
@@ -2183,7 +2183,7 @@ int storeInit()
 
     for (inx = 0; inx < ncache_dirs; ++inx) {
 	path = swappath(inx);
-	debug(10, "storeInit: Creating swap space in %s\n", path);
+	debug(0, 10, "storeInit: Creating swap space in %s\n", path);
 	if (stat(path, &sb) < 0) {
 	    /* we need to create a directory for swap file here. */
 	    if (mkdir(path, 0777) < 0) {
@@ -2199,16 +2199,16 @@ int storeInit()
 		    path, xstrerror());
 		fatal(tmpbuf);
 	    }
-	    debug(1, "storeInit: Created swap directory %s\n", path);
+	    debug(0, 1, "storeInit: Created swap directory %s\n", path);
 	    directory_created = 1;
 	}
 	if (zap_disk_store) {
-	    debug(1, "storeInit: Zapping all objects on disk storage.\n");
+	    debug(0, 1, "storeInit: Zapping all objects on disk storage.\n");
 	    /* This could be dangerous, second copy of cache can destroy the existing
 	     * swap files of the previous cache. We may use rc file do it. */
 	    tmpbuf[0] = '\0';
 	    sprintf(tmpbuf, "cd %s; rm -rf log [0-9][0-9]", path);
-	    debug(1, "storeInit: Running '%s'\n", tmpbuf);
+	    debug(0, 1, "storeInit: Running '%s'\n", tmpbuf);
 	    system(tmpbuf);
 	}
     }
@@ -2221,7 +2221,7 @@ int storeInit()
     }
     swaplog_stream = fdopen(swaplog_fd, "w");
     if (!swaplog_stream) {
-	debug(1, "storeInit: fdopen(%d, \"w\"): %s\n", swaplog_fd, xstrerror());
+	debug(0, 1, "storeInit: fdopen(%d, \"w\"): %s\n", swaplog_fd, xstrerror());
 	sprintf(tmpbuf, "Cannot open a stream for swap logfile: %s\n", swaplog_file);
 	fatal(tmpbuf);
     }
@@ -2361,7 +2361,7 @@ int parse_file_number(s)
 	    return (atoi(&s[len + 1]));
 	}
     }
-    debug(1, "parse_file_number: Could not determine the swap file number from %s.\n", s);
+    debug(0, 1, "parse_file_number: Could not determine the swap file number from %s.\n", s);
     return (0);
 }
 
@@ -2398,7 +2398,7 @@ int storeMaintainSwapSpace()
 	    e = (StoreEntry *) link_ptr;
 	    if ((cached_curtime > e->expires) &&
 		(e->swap_status == SWAP_OK)) {
-		debug(2, "storeMaintainSwapSpace: Expired: <TTL:%d> <URL:%s>\n",
+		debug(0, 2, "storeMaintainSwapSpace: Expired: <TTL:%d> <URL:%s>\n",
 		    e->expires - cached_curtime, e->url);
 		/* just call release. don't have to check for lock status.
 		 * storeRelease will take care of that and set a pending flag
@@ -2430,20 +2430,20 @@ int storeWriteCleanLog()
     time_t start, stop, r;
 
     if (!ok_write_clean_log) {
-	debug(1, "storeWriteCleanLog: Not currently OK to rewrite swap log.\n");
-	debug(1, "storeWriteCleanLog: Operation aborted.\n");
+	debug(0, 1, "storeWriteCleanLog: Not currently OK to rewrite swap log.\n");
+	debug(0, 1, "storeWriteCleanLog: Operation aborted.\n");
 	return 0;
     }
-    debug(1, "storeWriteCleanLog: Starting...\n");
+    debug(0, 1, "storeWriteCleanLog: Starting...\n");
     start = cached_curtime = time(NULL);
     sprintf(clean_log, "%s/log_clean", swappath(0));
     sprintf(swaplog_file, "%s/log", swappath(0));
     if ((fp = fopen(clean_log, "a+")) == NULL) {
-	debug(0, "storeWriteCleanLog: %s: %s", clean_log, xstrerror());
+	debug(0, 0, "storeWriteCleanLog: %s: %s", clean_log, xstrerror());
 	return 0;
     }
     for (e = storeGetFirst(); e; e = storeGetNext()) {
-	debug(5, "storeWriteCleanLog: <URL:%s>\n", e->url);
+	debug(0, 5, "storeWriteCleanLog: <URL:%s>\n", e->url);
 	if (e->swap_file_number < 0)
 	    continue;
 	if (e->swap_status != SWAP_OK)
@@ -2456,18 +2456,18 @@ int storeWriteCleanLog()
 	    e->object_len);
 	if ((++n & 0xFFF) == 0) {
 	    cached_curtime = time(NULL);
-	    debug(1, "  %7d lines written so far.\n", n);
+	    debug(0, 1, "  %7d lines written so far.\n", n);
 	}
     }
     fclose(fp);
 
     if (file_write_unlock(swaplog_fd, swaplog_lock) != DISK_OK) {
-	debug(0, "storeWriteCleanLog: Failed to unlock swaplog!\n");
-	debug(0, "storeWriteCleanLog: Current swap logfile not replaced.\n");
+	debug(0, 0, "storeWriteCleanLog: Failed to unlock swaplog!\n");
+	debug(0, 0, "storeWriteCleanLog: Current swap logfile not replaced.\n");
 	return 0;
     }
     if (rename(clean_log, swaplog_file) < 0) {
-	debug(0, "storeWriteCleanLog: rename failed: %s\n",
+	debug(0, 0, "storeWriteCleanLog: rename failed: %s\n",
 	    xstrerror());
 	return 0;
     }
@@ -2487,8 +2487,8 @@ int storeWriteCleanLog()
 
     stop = cached_curtime = time(NULL);
     r = stop - start;
-    debug(1, "  Finished.  Wrote %d lines.\n", n);
-    debug(1, "  Took %d seconds (%6.1lf lines/sec).\n",
+    debug(0, 1, "  Finished.  Wrote %d lines.\n", n);
+    debug(0, 1, "  Took %d seconds (%6.1lf lines/sec).\n",
 	r > 0 ? r : 0, (double) n / (r > 0 ? r : 1));
 
     /* touch a timestamp file */
@@ -1,5 +1,5 @@
 
-/* $Id: tools.cc,v 1.9 1996/03/27 05:12:40 wessels Exp $ */
+/* $Id: tools.cc,v 1.10 1996/03/27 18:15:55 wessels Exp $ */
 
 #include "squid.h"
 
@@ -56,14 +56,14 @@ void print_warranty()
 }
 
 void death(sig)
-	int sig;
+     int sig;
 {
     if (sig == SIGSEGV)
-    	fprintf(stderr, "FATAL: Received Segment Violation...dying.\n");
+	fprintf(stderr, "FATAL: Received Segment Violation...dying.\n");
     else if (sig == SIGBUS)
-        fprintf(stderr, "FATAL: Received bus error...dying.\n");
+	fprintf(stderr, "FATAL: Received bus error...dying.\n");
     else
-        fprintf(stderr, "FATAL: Received signal %d...dying.\n", sig);
+	fprintf(stderr, "FATAL: Received signal %d...dying.\n", sig);
     signal(SIGSEGV, SIG_DFL);
     signal(SIGBUS, SIG_DFL);
     signal(sig, SIG_DFL);
@@ -77,7 +77,7 @@ void death(sig)
 void rotate_logs(sig)
      int sig;
 {
-    debug(1, "rotate_logs: SIGHUP received.\n");
+    debug(0, 1, "rotate_logs: SIGHUP received.\n");
 
     storeWriteCleanLog();
     neighbors_rotate_log();
@@ -91,10 +91,10 @@ void rotate_logs(sig)
 void shut_down(sig)
      int sig;
 {
-    debug(1, "Shutting down...\n");
+    debug(0, 1, "Shutting down...\n");
     storeWriteCleanLog();
     PrintRusage(NULL, stderr);
-    debug(0, "Harvest Cache (Version %s): Exiting due to signal %d.\n",
+    debug(0, 0, "Harvest Cache (Version %s): Exiting due to signal %d.\n",
 	SQUID_VERSION, sig);
     exit(1);
 }
@@ -112,8 +112,8 @@ void fatal_common(message)
     fflush(stderr);
     PrintRusage(NULL, stderr);
     if (debug_log != stderr) {
-	debug(0, "FATAL: %s\n", message);
-	debug(0, "Harvest Cache (Version %s): Terminated abnormally.\n",
+	debug(0, 0, "FATAL: %s\n", message);
+	debug(0, 0, "Harvest Cache (Version %s): Terminated abnormally.\n",
 	    SQUID_VERSION);
     }
 }
@@ -220,7 +220,7 @@ void sig_child(sig)
     int pid;
 
     if ((pid = waitpid(-1, &status, WNOHANG)) > 0)
-	debug(3, "sig_child: Ate pid %d\n", pid);
+	debug(0, 3, "sig_child: Ate pid %d\n", pid);
 
 #if defined(_SQUID_SYSV_SIGNALS_)
     signal(sig, sig_child);
@@ -248,7 +248,7 @@ int getMaxFD()
 #else
 	i = 64;			/* 64 is a safe default */
 #endif
-	debug(10, "getMaxFD set MaxFD at %d\n", i);
+	debug(0, 10, "getMaxFD set MaxFD at %d\n", i);
     }
     return (i);
 }
@@ -263,7 +263,7 @@ char *getMyHostname()
     if (!present) {
 	host[0] = '\0';
 	if (gethostname(host, SQUIDHOSTNAMELEN) == -1) {
-	    debug(1, "comm_hostname: gethostname failed: %s\n",
+	    debug(0, 1, "comm_hostname: gethostname failed: %s\n",
 		xstrerror());
 	    return NULL;
 	} else {
@@ -285,6 +285,51 @@ int safeunlink(s, quiet)
     int err;
     if ((err = unlink(s)) < 0)
 	if (!quiet)
-	    debug(1, "safeunlink: Couldn't delete %s. %s\n", s, xstrerror());
+	    debug(0, 1, "safeunlink: Couldn't delete %s. %s\n", s, xstrerror());
     return (err);
 }
+
+/* 
+ * Daemonize a process according to guidlines in "Advanced Programming
+ * For The UNIX Environment", W.R. Stevens ( Addison Wesley, 1992) - Ch. 13
+ */
+int daemonize()
+{
+    int n_openf, i;
+    pid_t pid;
+    if ((pid = fork()) < 0)
+	return -1;
+    else if (pid != 0)
+	exit(0);
+    /* Child continues */
+    setsid();			/* Become session leader */
+    n_openf = getMaxFD();	/* Close any inherited files */
+    for (i = 0; i < n_openf; i++)
+	close(i);
+    umask(0);			/* Clear file mode creation mask */
+    return 0;
+}
+
+void check_suid()
+{
+    struct passwd *pwd = NULL;
+    struct group *grp = NULL;
+    if (geteuid() != 0)
+	return;
+    /* Started as a root, check suid option */
+    if (getEffectiveUser() == NULL)
+	return;
+    if ((pwd = getpwnam(getEffectiveUser())) == NULL)
+	return;
+    /* change current directory to swap space so we can get core */
+    if (chdir(swappath(0))) {
+	debug(0, 1, "Chdir Failed: Cached cannot write core file when it crash: %s\n",
+	    xstrerror());
+    }
+    if (getEffectiveGroup() && (grp = getgrnam(getEffectiveGroup()))) {
+	setgid(grp->gr_gid);
+    } else {
+	setgid(pwd->pw_gid);
+    }
+    setuid(pwd->pw_uid);
+}
@@ -1,4 +1,4 @@
-/* $Id: url.cc,v 1.3 1996/03/27 01:46:28 wessels Exp $ */
+/* $Id: url.cc,v 1.4 1996/03/27 18:15:57 wessels Exp $ */
 
 #include "squid.h"
 
@@ -125,7 +125,7 @@ char *the_url(e)
 	/* discard "/head/" or "head/" from the key and get url */
 	return URL;
     } else {
-	debug(0, "Should not be here. Unknown format of the key: %s\n",
+	debug(0, 0, "Should not be here. Unknown format of the key: %s\n",
 	    e->key);
 	return (NULL);
     }
@@ -1,4 +1,4 @@
-/* $Id: wais.cc,v 1.9 1996/03/27 01:46:29 wessels Exp $ */
+/* $Id: wais.cc,v 1.10 1996/03/27 18:15:58 wessels Exp $ */
 
 #include "squid.h"
 
@@ -39,7 +39,7 @@ void waisReadReplyTimeout(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(4, "waisReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
+    debug(0, 4, "waisReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
     cached_error_entry(entry, ERR_READ_TIMEOUT);
     comm_set_select_handler(fd, COMM_SELECT_READ, 0, 0);
     comm_close(fd);
@@ -54,7 +54,7 @@ void waisLifetimeExpire(fd, data)
     StoreEntry *entry = NULL;
 
     entry = data->entry;
-    debug(4, "waisLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
+    debug(0, 4, "waisLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
     cached_error_entry(entry, ERR_LIFETIME_EXP);
     comm_set_select_handler(fd, COMM_SELECT_READ | COMM_SELECT_WRITE, 0, 0);
     comm_close(fd);
@@ -80,8 +80,8 @@ void waisReadReply(fd, data)
 	    /* check if we want to defer reading */
 	    if ((entry->mem_obj->e_current_len -
 		    entry->mem_obj->e_lowest_offset) > WAIS_DELETE_GAP) {
-		debug(3, "waisReadReply: Read deferred for Object: %s\n", entry->key);
-		debug(3, "                Current Gap: %d bytes\n",
+		debug(0, 3, "waisReadReply: Read deferred for Object: %s\n", entry->key);
+		debug(0, 3, "                Current Gap: %d bytes\n",
 		    entry->mem_obj->e_current_len -
 		    entry->mem_obj->e_lowest_offset);
 
@@ -115,10 +115,10 @@ void waisReadReply(fd, data)
 	}
     }
     len = read(fd, buf, 4096);
-    debug(5, "waisReadReply - fd: %d read len:%d\n", fd, len);
+    debug(0, 5, "waisReadReply - fd: %d read len:%d\n", fd, len);
 
     if (len < 0 || ((len == 0) && (entry->mem_obj->e_current_len == 0))) {
-	debug(1, "waisReadReply - error reading errno %d: %s\n",
+	debug(0, 1, "waisReadReply - error reading errno %d: %s\n",
 	    errno, xstrerror());
 	if (errno == ECONNRESET) {
 	    /* Connection reset by peer */
@@ -168,7 +168,7 @@ void waisSendComplete(fd, buf, size, errflag, data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
-    debug(5, "waisSendComplete - fd: %d size: %d errflag: %d\n",
+    debug(0, 5, "waisSendComplete - fd: %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
 	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
@@ -193,7 +193,7 @@ void waisSendRequest(fd, data)
     int len = strlen(data->request) + 4;
     char *buf;
 
-    debug(5, "waisSendRequest - fd: %d\n", fd);
+    debug(0, 5, "waisSendRequest - fd: %d\n", fd);
 
     if (data->type)
 	len += strlen(data->type);
@@ -207,7 +207,7 @@ void waisSendRequest(fd, data)
 	    data->mime_hdr, CR, LF);
     else
 	sprintf(buf, "%s %s%c%c", data->type, data->request, CR, LF);
-    debug(6, "waisSendRequest - buf:%s\n", buf);
+    debug(0, 6, "waisSendRequest - buf:%s\n", buf);
     icpWrite(fd, buf, len, 30, waisSendComplete, data);
 }
 
@@ -222,14 +222,14 @@ int waisStart(unusedfd, url, type, mime_hdr, entry)
     int sock, status;
     WAISData *data = NULL;
 
-    debug(3, "waisStart - url:%s, type:%s\n", url, type);
-    debug(4, "            header: %s\n", mime_hdr);
+    debug(0, 3, "waisStart - url:%s, type:%s\n", url, type);
+    debug(0, 4, "            header: %s\n", mime_hdr);
 
     data = (WAISData *) xcalloc(1, sizeof(WAISData));
     data->entry = entry;
 
     if (!getWaisRelayHost()) {
-	debug(0, "waisStart: Failed because no relay host defined!\n");
+	debug(0, 0, "waisStart: Failed because no relay host defined!\n");
 	cached_error_entry(entry, ERR_NO_RELAY);
 	safe_free(data);
 	return COMM_ERROR;
@@ -242,7 +242,7 @@ int waisStart(unusedfd, url, type, mime_hdr, entry)
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
-	debug(4, "waisStart: Failed because we're out of sockets.\n");
+	debug(0, 4, "waisStart: Failed because we're out of sockets.\n");
 	cached_error_entry(entry, ERR_NO_FDS);
 	safe_free(data);
 	return COMM_ERROR;
@@ -251,7 +251,7 @@ int waisStart(unusedfd, url, type, mime_hdr, entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
-	debug(4, "waisstart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(0, 4, "waisstart: Called without IP entry in ipcache. OR lookup failed.\n");
 	comm_close(sock);
 	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	safe_free(data);
@@ -265,7 +265,7 @@ int waisStart(unusedfd, url, type, mime_hdr, entry)
 	    safe_free(data);
 	    return COMM_ERROR;
 	} else {
-	    debug(5, "waisStart - conn %d EINPROGRESS\n", sock);
+	    debug(0, 5, "waisStart - conn %d EINPROGRESS\n", sock);
 	}
     }
     /* Install connection complete handler. */