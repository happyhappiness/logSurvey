@@ -42,7 +42,6 @@ typedef union {
 #include <sys/resource.h>
 SQUIDCEXTERN int getrusage(int, struct rusage *);
 
-
 /**
  * prototypes for system function missing from system includes
  * on some Solaris systems.
@@ -79,7 +79,7 @@ xcalloc(size_t n, size_t sz)
         if (failure_notify) {
             static char msg[128];
             snprintf(msg, 128, "xcalloc: Unable to allocate %Zu blocks of %Zu bytes!\n", n, sz);
-            (*failure_notify) (msg);
+            failure_notify(msg);
         } else {
             perror("xcalloc");
         }
@@ -120,7 +120,7 @@ xmalloc(size_t sz)
         if (failure_notify) {
             static char msg[128];
             snprintf(msg, 128, "xmalloc: Unable to allocate %Zu bytes!\n", sz);
-            (*failure_notify) (msg);
+            failure_notify(msg);
         } else {
             perror("malloc");
         }
@@ -168,7 +168,7 @@ xrealloc(void *s, size_t sz)
         if (failure_notify) {
             static char msg[128];
             snprintf(msg, 128, "xrealloc: Unable to reallocate %Zu bytes!\n", sz);
-            (*failure_notify) (msg);
+            failure_notify(msg);
         } else {
             perror("realloc");
         }
@@ -39,7 +39,11 @@ AC_CANONICAL_HOST
 AC_MSG_CHECKING([simplified host os])
 simple_host_os=`echo $host_os|sed 's/[0-9].*//g;s/-.*//g'`
 squid_host_os_version=`echo $host_os|tr -d "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-"`
-squid_host_os=`echo $simple_host_os| sed s/$squid_host_os_version//g`
+if test -n "$squid_host_os_version"; then
+	squid_host_os="`echo $simple_host_os| sed s/$squid_host_os_version//g`"
+else
+	squid_host_os="$simple_host_os"
+fi
 AC_MSG_RESULT($squid_host_os (version $squid_host_os_version))
 # on windows squid_host_os is either mingw or cygwin, version is 32
 
@@ -117,27 +117,22 @@ struct squid_radix_node_head {
     (void *v, void *mask, struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
 
     struct squid_radix_node *(*rnh_deladdr)	/* remove based on sockaddr */
-
     (void *v, void *mask, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_delpkt)	/* remove based on packet hdr */
-
     (void *v, void *mask, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_matchaddr)		/* locate based on sockaddr */
-
     (void *v, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_lookup)	/* locate based on sockaddr */
 
     (void *v, void *mask, struct squid_radix_node_head * head);
 
     struct squid_radix_node *(*rnh_matchpkt)	/* locate based on packet hdr */
-
     (void *v, struct squid_radix_node_head * head);
 
     int (*rnh_walktree)		/* traverse tree */
-
     (struct squid_radix_node_head * head, int (*f) (struct squid_radix_node *, void *), void *w);
 
     struct squid_radix_node rnh_nodes[3];	/* empty tree for common case */
@@ -11,7 +11,6 @@
 #include "Stack.h"
 
 template <class V>
-
 class SplayNode
 {
 
@@ -32,8 +31,7 @@ class SplayNode
     SplayNode<V> const * start() const;
     SplayNode<V> const * finish() const;
 
-    SplayNode<V> * remove
-    (const Value data, SPLAYCMP * compare);
+    SplayNode<V> * remove(const Value data, SPLAYCMP * compare);
 
     SplayNode<V> * insert(Value data, SPLAYCMP * compare);
 
@@ -43,15 +41,12 @@ class SplayNode
 typedef SplayNode<void *> splayNode;
 
 template <class V>
-
 class SplayConstIterator;
 
 template <class V>
-
 class SplayIterator;
 
 template <class V>
-
 class Splay
 {
 
@@ -67,8 +62,7 @@ class Splay
     template <class FindValue> Value const *find (FindValue const &, int( * compare)(FindValue const &a, Value const &b)) const;
     void insert(Value const &, SPLAYCMP *compare);
 
-    void remove
-    (Value const &, SPLAYCMP *compare);
+    void remove(Value const &, SPLAYCMP *compare);
 
     void destroy(SPLAYFREE *);
 
@@ -158,8 +152,7 @@ SplayNode<V>::destroy(SPLAYFREE * free_func)
 
 template<class V>
 SplayNode<V> *
-SplayNode<V>::remove
-(Value const dataToRemove, SPLAYCMP * compare)
+SplayNode<V>::remove(Value const dataToRemove, SPLAYCMP * compare)
 {
     if (this == NULL)
         return NULL;
@@ -311,13 +304,11 @@ Splay<V>::insert(Value const &value, SPLAYCMP *compare)
 
 template <class V>
 void
-Splay<V>::remove
-(Value const &value, SPLAYCMP *compare)
+Splay<V>::remove(Value const &value, SPLAYCMP *compare)
 {
     assert (find (value, compare));
 
-    head = head->remove
-           (value, compare);
+    head = head->remove(value, compare);
 
     --elements;
 }
@@ -376,7 +367,6 @@ Splay<V>::end() const
 }
 
 template <class V>
-
 class SplayConstIterator
 {
 
@@ -29,55 +29,50 @@
 #include "Trie.cci"
 #endif
 
-Trie::Trie (TrieCharTransform *aTransform) : head (0) , transform (aTransform)
+Trie::Trie(TrieCharTransform *aTransform) : head(0) , transform(aTransform)
 {}
 
-extern "C" void *TrieCreate ()
+extern "C" void *TrieCreate()
 {
     return new Trie;
 }
 
-Trie::~Trie ()
+Trie::~Trie()
 {
     delete head;
     delete transform;
 }
 
-extern "C" void TrieDestroy (void *aTrie)
+extern "C" void TrieDestroy(void *aTrie)
 {
     delete (Trie *)aTrie;
 }
 
-extern "C" void *TrieFind (void *aTrie, char const *aString, size_t theLength)
+extern "C" void *TrieFind(void *aTrie, char const *aString, size_t theLength)
 {
-    return ((Trie *)aTrie)->find (aString, theLength);
+    return ((Trie *)aTrie)->find(aString, theLength);
 }
 
 bool
-
-Trie::add
-(char const *aString, size_t theLength, void *privatedata)
+Trie::add(char const *aString, size_t theLength, void *privatedata)
 {
     if (!privatedata)
         return false;
 
     if (head) {
-        if (find (aString, theLength))
+        if (find(aString, theLength))
             return false;
 
-        return head->add
-               (aString, theLength, privatedata, transform);
+        return head->add(aString, theLength, privatedata, transform);
     }
 
     head = new TrieNode;
 
-    return head->add
-           (aString, theLength, privatedata, transform);
+    return head->add(aString, theLength, privatedata, transform);
 }
 
-extern "C" int TrieAdd (void *aTrie, char const *aString, size_t theLength, void *privatedata)
+extern "C" int TrieAdd(void *aTrie, char const *aString, size_t theLength, void *privatedata)
 {
 
-    return ((Trie *)aTrie)->add
-           (aString, theLength, privatedata);
+    return ((Trie *)aTrie)->add(aString, theLength, privatedata);
 }
@@ -24,34 +24,31 @@
 #include <unistd.h>
 #endif
 
-TrieNode::TrieNode () : _privateData (NULL)
+TrieNode::TrieNode() : _privateData(NULL)
 {
     for (int i = 0; i < 256; ++i)
         internal[i] = NULL;
 }
 
-TrieNode::~TrieNode ()
+TrieNode::~TrieNode()
 {
     for (int i = 0; i < 256; ++i)
         delete internal[i];
 }
 
 /* as for find */
 bool
-
-TrieNode::add
-(char const *aString, size_t theLength, void *privatedata, TrieCharTransform *transform)
+TrieNode::add(char const *aString, size_t theLength, void *privatedata, TrieCharTransform *transform)
 {
     /* We trust that privatedata and existant keys have already been checked */
 
     if (theLength) {
-        int index = transform ? (*transform) (*aString): *aString;
+        int index = transform ? (*transform)(*aString): *aString;
 
         if (!internal[index])
             internal[index] = new TrieNode;
 
-        return internal[index]->add
-               (aString + 1, theLength - 1, privatedata, transform);
+        return internal[index]->add(aString + 1, theLength - 1, privatedata, transform);
     } else {
         /* terminal node */
 
@@ -45,10 +45,8 @@ main(int argc, char **argv)
     MDString("abc");
     MDString("message digest");
     MDString("abcdefghijklmnopqrstuvwxyz");
-    MDString
-    ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
-    MDString
-    ("1234567890123456789012345678901234567890\
-1234567890123456789012345678901234567890");
+    MDString("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
+    MDString("1234567890123456789012345678901234567890"
+             "1234567890123456789012345678901234567890");
     return 0;
 }
@@ -1,33 +1,33 @@
 /*
-   Unix SMB/Netbios implementation.
-   Version 1.9.
-   SMB Byte handling
-   Copyright (C) Andrew Tridgell 1992-1995
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * Unix SMB/Netbios implementation.
+ * Version 1.9.
+ * SMB Byte handling
+ * Copyright (C) Andrew Tridgell 1992-1995
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /*
-   This file implements macros for machine independent short and
-   int manipulation
-*/
+ * This file implements macros for machine independent short and
+ * int manipulation
+ */
 
 #undef CAREFUL_ALIGNMENT
 
 /* we know that the 386 can handle misalignment and has the "right"
-   byteorder */
+ * byteorder */
 #ifdef __i386__
 #define CAREFUL_ALIGNMENT 0
 #endif
@@ -54,11 +54,11 @@
 #define SIVALS(buf,pos,val) SIVALX((buf),(pos),((int32)(val)))
 #else
 /* this handles things for architectures like the 386 that can handle
-   alignment errors */
+ * alignment errors */
 /*
-   WARNING: This section is dependent on the length of int16 and int32
-   being correct
-*/
+ * WARNING: This section is dependent on the length of int16 and int32
+ * being correct
+ */
 #define SVAL(buf,pos) (*(uint16 *)((char *)(buf) + (pos)))
 #define IVAL(buf,pos) (*(uint32 *)((char *)(buf) + (pos)))
 #define SVALS(buf,pos) (*(int16 *)((char *)(buf) + (pos)))
@@ -1,27 +1,27 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB Common Structures etc Defines
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB Common Structures etc Defines
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #ifndef _RFCNB_RFCNB_COMMON_H
 #define _RFCNB_RFCNB_COMMON_H
@@ -34,13 +34,14 @@ extern "C" {
 
     typedef struct RFCNB_Pkt {
 
-        char * data;			/* The data in this portion */
+        char *data;             /* The data in this portion */
         int len;
         struct RFCNB_Pkt *next;
 
     } RFCNB_Pkt;
 
 #ifdef __cplusplus
 }
+
 #endif
-#endif /* _RFCNB_RFCNB_COMMON_H */
+#endif                          /* _RFCNB_RFCNB_COMMON_H */
@@ -1,27 +1,27 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB Error Response Defines
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB Error Response Defines
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #ifndef _RFCNB_ERROR_H_
 #define _RFCNB_ERROR_H_
@@ -32,33 +32,34 @@ extern "C" {
 
     /* Error responses */
 
-#define RFCNBE_Bad -1          /* Bad response */
+#define RFCNBE_Bad -1           /* Bad response */
 #define RFCNBE_OK 0
 
-    /* these should follow the spec ... is there one ?*/
+    /* these should follow the spec ... is there one ? */
 
-#define RFCNBE_NoSpace 1       /* Could not allocate space for a struct */
-#define RFCNBE_BadName 2       /* Could not translate a name            */
-#define RFCNBE_BadRead 3       /* Read sys call failed                  */
-#define RFCNBE_BadWrite 4      /* Write Sys call failed                 */
-#define RFCNBE_ProtErr 5       /* Protocol Error                        */
-#define RFCNBE_ConGone 6       /* Connection dropped                    */
-#define RFCNBE_BadHandle 7     /* Handle passed was bad                 */
-#define RFCNBE_BadSocket 8     /* Problems creating socket              */
-#define RFCNBE_ConnectFailed 9 /* Connect failed                        */
-#define RFCNBE_CallRejNLOCN 10 /* Call rejected, not listening on CN    */
-#define RFCNBE_CallRejNLFCN 11 /* Call rejected, not listening for CN   */
-#define RFCNBE_CallRejCNNP  12 /* Call rejected, called name not present */
-#define RFCNBE_CallRejInfRes 13/* Call rejetced, name ok, no resources   */
-#define RFCNBE_CallRejUnSpec 14/* Call rejected, unspecified error      */
-#define RFCNBE_BadParam      15/* Bad parameters passed ...             */
-#define RFCNBE_Timeout       16/* IO Timed out                          */
+#define RFCNBE_NoSpace 1        /* Could not allocate space for a struct */
+#define RFCNBE_BadName 2        /* Could not translate a name            */
+#define RFCNBE_BadRead 3        /* Read sys call failed                  */
+#define RFCNBE_BadWrite 4       /* Write Sys call failed                 */
+#define RFCNBE_ProtErr 5        /* Protocol Error                        */
+#define RFCNBE_ConGone 6        /* Connection dropped                    */
+#define RFCNBE_BadHandle 7      /* Handle passed was bad                 */
+#define RFCNBE_BadSocket 8      /* Problems creating socket              */
+#define RFCNBE_ConnectFailed 9  /* Connect failed                        */
+#define RFCNBE_CallRejNLOCN 10  /* Call rejected, not listening on CN    */
+#define RFCNBE_CallRejNLFCN 11  /* Call rejected, not listening for CN   */
+#define RFCNBE_CallRejCNNP  12  /* Call rejected, called name not present */
+#define RFCNBE_CallRejInfRes 13 /* Call rejetced, name ok, no resources   */
+#define RFCNBE_CallRejUnSpec 14 /* Call rejected, unspecified error      */
+#define RFCNBE_BadParam      15 /* Bad parameters passed ...             */
+#define RFCNBE_Timeout       16 /* IO Timed out                          */
 
     /* Text strings for the error responses                                 */
 
     extern const char *RFCNB_Error_Strings[];
 
 #ifdef __cplusplus
 }
+
 #endif
-#endif /* _RFCNB_ERROR_H_ */
+#endif                          /* _RFCNB_ERROR_H_ */
@@ -1,29 +1,29 @@
 #include "config.h"
 
 /* UNIX RFCNB (RFC1001/RFC1002) NEtBIOS implementation
-
-   Version 1.0
-   RFCNB IO Routines ...
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB IO Routines ...
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #include "rfcnb/std-includes.h"
 #include "rfcnb/rfcnb-priv.h"
@@ -36,23 +36,25 @@
 #include <string.h>
 #endif
 
-int RFCNB_Timeout = 0;    /* Timeout in seconds ... */
+int RFCNB_Timeout = 0;          /* Timeout in seconds ... */
 
 int RFCNB_Discard_Rest(struct RFCNB_Con *con, int len);
 
 #ifdef NOT_USED
-void rfcnb_alarm(int sig)
-
+void
+rfcnb_alarm(int sig)
 {
 
     fprintf(stderr, "IO Timed out ...\n");
 
 }
 
-/* Set timeout value and setup signal handling */
-
-int RFCNB_Set_Timeout(int seconds)
+#endif /* NOT_USED */
 
+#ifdef NOT_USED
+/* Set timeout value and setup signal handling */
+int
+RFCNB_Set_Timeout(int seconds)
 {
     /* If we are on a Bezerkeley system, use sigvec, else sigaction */
 
@@ -65,36 +67,35 @@ int RFCNB_Set_Timeout(int seconds)
 
     RFCNB_Timeout = seconds;
 
-    if (RFCNB_Timeout > 0) { /* Set up handler to ignore but not restart */
+    if (RFCNB_Timeout > 0) {    /* Set up handler to ignore but not restart */
 
 #ifndef SA_RESTART
-        invec.sv_handler = (void (*)())rfcnb_alarm;
+        invec.sv_handler = (void (*)()) rfcnb_alarm;
         invec.sv_mask = 0;
         invec.sv_flags = SV_INTERRUPT;
 
-        if (sigvec(SIGALRM, &invec, &outvec)  < 0)
-            return(-1);
-#else
-        inact.sa_handler = (void (*)())rfcnb_alarm;
+        if (sigvec(SIGALRM, &invec, &outvec) < 0)
+            return (-1);
+#else /* !SA_RESTART */
+        inact.sa_handler = (void (*)()) rfcnb_alarm;
 #ifdef Solaris
         /* Solaris seems to have an array of vectors ... */
         inact.sa_mask.__sigbits[0] = 0;
         inact.sa_mask.__sigbits[1] = 0;
         inact.sa_mask.__sigbits[2] = 0;
         inact.sa_mask.__sigbits[3] = 0;
-#else
-        inact.sa_mask = (sigset_t)0;
-#endif
-        inact.sa_flags = 0;    /* Don't restart */
+#else /* !Solaris */
+        inact.sa_mask = (sigset_t) 0;
+#endif /* Solaris */
+        inact.sa_flags = 0;     /* Don't restart */
 
         if (sigaction(SIGALRM, &inact, &outact) < 0)
-            return(-1);
+            return (-1);
 
-#endif
+#endif /* !SA_RESTART */
 
     }
-
-#else /* ADAPTED SQUID CODE */
+#else /* !ORIGINAL_SAMBA_CODE ADAPTED SQUID CODE */
 #if HAVE_SIGACTION
     struct sigaction inact, outact;
 #else
@@ -112,28 +113,27 @@ int RFCNB_Set_Timeout(int seconds)
 
         if (sigaction(SIGALRM, &inact, &outact) < 0)
             return (-1);
-#else
+#else /* !HAVE_SIGACTION */
     invec.sv_handler = (void (*)()) rfcnb_alarm;
     invec.sv_mask = 0;
     invec.sv_flags = SV_INTERRUPT;
 
     if (sigvec(SIGALRM, &invec, &outvec) < 0)
         return (-1);
-#endif
-
-#endif
-    return(0);
-
+#endif /* !HAVE_SIGACTION */
+    }
+#endif /* !ORIGINAL_SAMBA_CODE ADAPTED SQUID CODE */
+    return (0);
 }
-#endif
+#endif /* NOT_USED */
 
 /* Discard the rest of an incoming packet as we do not have space for it
-   in the buffer we allocated or were passed ...                         */
-
-int RFCNB_Discard_Rest(struct RFCNB_Con *con, int len)
+ * in the buffer we allocated or were passed ...                         */
 
+int
+RFCNB_Discard_Rest(struct RFCNB_Con *con, int len)
 {
-    char temp[100];   /* Read into here */
+    char temp[100];             /* Read into here */
     int rest, this_read, bytes_read;
 
     /* len is the amount we should read */
@@ -146,63 +146,62 @@ int RFCNB_Discard_Rest(struct RFCNB_Con *con, int len)
 
     while (rest > 0) {
 
-        this_read = (rest > sizeof(temp)?sizeof(temp):rest);
+        this_read = (rest > sizeof(temp) ? sizeof(temp) : rest);
 
-        bytes_read = read(con -> fd, temp, this_read);
+        bytes_read = read(con->fd, temp, this_read);
 
-        if (bytes_read <= 0) { /* Error so return */
+        if (bytes_read <= 0) {  /* Error so return */
 
             if (bytes_read < 0)
                 RFCNB_errno = RFCNBE_BadRead;
             else
                 RFCNB_errno = RFCNBE_ConGone;
 
             RFCNB_saved_errno = errno;
-            return(RFCNBE_Bad);
+            return (RFCNBE_Bad);
 
         }
-
         rest = rest - bytes_read;
 
     }
 
-    return(0);
+    return (0);
 
 }
 
 
 /* Send an RFCNB packet to the connection.
-
-   We just send each of the blocks linked together ...
-
-   If we can, try to send it as one iovec ...
-
-*/
-
-int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
-
+ *
+ * We just send each of the blocks linked together ...
+ *
+ * If we can, try to send it as one iovec ...
+ *
+ */
+
+int
+RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 {
     int len_sent, tot_sent, this_len;
     struct RFCNB_Pkt *pkt_ptr;
     char *this_data;
     int i;
-    struct iovec io_list[10];          /* We should never have more      */
-    /* If we do, this will blow up ...*/
+    struct iovec io_list[10];   /* We should never have more      */
+    /* If we do, this will blow up ... */
 
     /* Try to send the data ... We only send as many bytes as len claims */
     /* We should try to stuff it into an IOVEC and send as one write     */
 
 
     pkt_ptr = pkt;
-    len_sent =  tot_sent = 0;             /* Nothing sent so far */
+    len_sent = tot_sent = 0;    /* Nothing sent so far */
     i = 0;
 
-    while ((pkt_ptr != NULL) & (i < 10)) {  /* Watch that magic number! */
+    while ((pkt_ptr != NULL) & (i < 10)) {      /* Watch that magic number! */
 
-        this_len = pkt_ptr -> len;
-        this_data = pkt_ptr -> data;
+        this_len = pkt_ptr->len;
+        this_data = pkt_ptr->data;
         if ((tot_sent + this_len) > len)
-            this_len = len - tot_sent;        /* Adjust so we don't send too much */
+            this_len = len - tot_sent;  /* Adjust so we don't send too much */
 
         /* Now plug into the iovec ... */
 
@@ -212,9 +211,10 @@ int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
         tot_sent += this_len;
 
-        if (tot_sent == len) break;   /* Let's not send too much */
+        if (tot_sent == len)
+            break;              /* Let's not send too much */
 
-        pkt_ptr = pkt_ptr -> next;
+        pkt_ptr = pkt_ptr->next;
 
     }
 
@@ -227,79 +227,76 @@ int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
     if (RFCNB_Timeout > 0)
         alarm(RFCNB_Timeout);
 
-    if ((len_sent = writev(con -> fd, io_list, i)) < 0) { /* An error */
+    if ((len_sent = writev(con->fd, io_list, i)) < 0) {         /* An error */
 
-        con -> errn = errno;
-        if (errno == EINTR)  /* We were interrupted ... */
+        con->errn = errno;
+        if (errno == EINTR)     /* We were interrupted ... */
             RFCNB_errno = RFCNBE_Timeout;
         else
             RFCNB_errno = RFCNBE_BadWrite;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
-
-    if (len_sent < tot_sent) { /* Less than we wanted */
-        if (errno == EINTR)      /* We were interrupted */
+    if (len_sent < tot_sent) {  /* Less than we wanted */
+        if (errno == EINTR)     /* We were interrupted */
             RFCNB_errno = RFCNBE_Timeout;
         else
             RFCNB_errno = RFCNBE_BadWrite;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
     }
-
     if (RFCNB_Timeout > 0)
-        alarm(0);                /* Reset that sucker */
+        alarm(0);               /* Reset that sucker */
 
 #ifdef RFCNB_DEBUG
 
     fprintf(stderr, "Len sent = %i ...\n", len_sent);
-    RFCNB_Print_Pkt(stderr, "sent", pkt, len_sent); /* Print what send ... */
+    RFCNB_Print_Pkt(stderr, "sent", pkt, len_sent);     /* Print what send ... */
 
 #endif
 
-    return(len_sent);
+    return (len_sent);
 
 }
 
 /* Read an RFCNB packet off the connection.
+ *
+ * We read the first 4 bytes, that tells us the length, then read the
+ * rest. We should implement a timeout, but we don't just yet
+ *
+ */
 
-   We read the first 4 bytes, that tells us the length, then read the
-   rest. We should implement a timeout, but we don't just yet
-
-*/
-
-
-int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
+int
+RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 {
     int read_len, pkt_len;
-    char hdr[RFCNB_Pkt_Hdr_Len];      /* Local space for the header */
+    char hdr[RFCNB_Pkt_Hdr_Len];        /* Local space for the header */
     struct RFCNB_Pkt *pkt_frag;
     int more, this_time, offset, frag_len, this_len;
     BOOL seen_keep_alive = TRUE;
 
     /* Read that header straight into the buffer */
 
-    if (len < RFCNB_Pkt_Hdr_Len) { /* What a bozo */
+    if (len < RFCNB_Pkt_Hdr_Len) {      /* What a bozo */
 
 #ifdef RFCNB_DEBUG
         fprintf(stderr, "Trying to read less than a packet:");
         perror("");
 #endif
         RFCNB_errno = RFCNBE_BadParam;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
-
     /* We discard keep alives here ... */
 
     if (RFCNB_Timeout > 0)
         alarm(RFCNB_Timeout);
 
     while (seen_keep_alive) {
 
-        if ((read_len = read(con -> fd, hdr, sizeof(hdr))) < 0) { /* Problems */
+        if ((read_len = read(con->fd, hdr, sizeof(hdr))) < 0) {         /* Problems */
 #ifdef RFCNB_DEBUG
             fprintf(stderr, "Reading the packet, we got:");
             perror("");
@@ -309,13 +306,12 @@ int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
             else
                 RFCNB_errno = RFCNBE_BadRead;
             RFCNB_saved_errno = errno;
-            return(RFCNBE_Bad);
+            return (RFCNBE_Bad);
 
         }
-
         /* Now we check out what we got */
 
-        if (read_len == 0) { /* Connection closed, send back eof?  */
+        if (read_len == 0) {    /* Connection closed, send back eof?  */
 
 #ifdef RFCNB_DEBUG
             fprintf(stderr, "Connection closed reading\n");
@@ -326,10 +322,9 @@ int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
             else
                 RFCNB_errno = RFCNBE_ConGone;
             RFCNB_saved_errno = errno;
-            return(RFCNBE_Bad);
+            return (RFCNBE_Bad);
 
         }
-
         if (RFCNB_Pkt_Type(hdr) == RFCNB_SESSION_KEEP_ALIVE) {
 
 #ifdef RFCNB_DEBUG
@@ -344,20 +339,19 @@ int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
     /* What if we got less than or equal to a hdr size in bytes? */
 
-    if (read_len < sizeof(hdr)) { /* We got a small packet */
+    if (read_len < sizeof(hdr)) {       /* We got a small packet */
 
         /* Now we need to copy the hdr portion we got into the supplied packet */
 
-        memcpy(pkt -> data, hdr, read_len);  /*Copy data */
+        memcpy(pkt->data, hdr, read_len);       /*Copy data */
 
 #ifdef RFCNB_DEBUG
         RFCNB_Print_Pkt(stderr, "rcvd", pkt, read_len);
 #endif
 
-        return(read_len);
+        return (read_len);
 
     }
-
     /* Now, if we got at least a hdr size, alloc space for rest, if we need it */
 
     pkt_len = RFCNB_Pkt_Len(hdr);
@@ -368,13 +362,13 @@ int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
     /* Now copy in the hdr */
 
-    memcpy(pkt -> data, hdr, sizeof(hdr));
+    memcpy(pkt->data, hdr, sizeof(hdr));
 
     /* Get the rest of the packet ... first figure out how big our buf is? */
     /* And make sure that we handle the fragments properly ... Sure should */
     /* use an iovec ...                                                    */
 
-    if (len < pkt_len)            /* Only get as much as we have space for */
+    if (len < pkt_len)          /* Only get as much as we have space for */
         more = len - RFCNB_Pkt_Hdr_Len;
     else
         more = pkt_len;
@@ -383,24 +377,24 @@ int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
     /* We read for each fragment ... */
 
-    if (pkt -> len == read_len) {    /* If this frag was exact size */
-        pkt_frag = pkt -> next;        /* Stick next lot in next frag */
-        offset = 0;                    /* then we start at 0 in next  */
+    if (pkt->len == read_len) { /* If this frag was exact size */
+        pkt_frag = pkt->next;   /* Stick next lot in next frag */
+        offset = 0;             /* then we start at 0 in next  */
     } else {
-        pkt_frag = pkt;                /* Otherwise use rest of this frag */
-        offset = RFCNB_Pkt_Hdr_Len;    /* Otherwise skip the header       */
+        pkt_frag = pkt;         /* Otherwise use rest of this frag */
+        offset = RFCNB_Pkt_Hdr_Len;     /* Otherwise skip the header       */
     }
 
-    frag_len = pkt_frag -> len;
+    frag_len = pkt_frag->len;
 
-    if (more <= frag_len)     /* If len left to get less than frag space */
+    if (more <= frag_len)       /* If len left to get less than frag space */
         this_len = more;        /* Get the rest ...                        */
     else
         this_len = frag_len - offset;
 
     while (more > 0) {
 
-        if ((this_time = read(con -> fd, (pkt_frag -> data) + offset, this_len)) <= 0) { /* Problems */
+        if ((this_time = read(con->fd, (pkt_frag->data) + offset, this_len)) <= 0) {    /* Problems */
 
             if (errno == EINTR) {
 
@@ -414,42 +408,41 @@ int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
             }
 
             RFCNB_saved_errno = errno;
-            return(RFCNBE_Bad);
+            return (RFCNBE_Bad);
 
         }
-
 #ifdef RFCNB_DEBUG
         fprintf(stderr, "Frag_Len = %i, this_time = %i, this_len = %i, more = %i\n", frag_len,
                 this_time, this_len, more);
 #endif
 
-        read_len = read_len + this_time;  /* How much have we read ... */
+        read_len = read_len + this_time;        /* How much have we read ... */
 
         /* Now set up the next part */
 
-        if (pkt_frag -> next == NULL) break;       /* That's it here */
+        if (pkt_frag->next == NULL)
+            break;              /* That's it here */
 
-        pkt_frag = pkt_frag -> next;
-        this_len = pkt_frag -> len;
+        pkt_frag = pkt_frag->next;
+        this_len = pkt_frag->len;
         offset = 0;
 
         more = more - this_time;
 
     }
 
 #ifdef RFCNB_DEBUG
-    fprintf(stderr,"Pkt Len = %i, read_len = %i\n", pkt_len, read_len);
+    fprintf(stderr, "Pkt Len = %i, read_len = %i\n", pkt_len, read_len);
     RFCNB_Print_Pkt(stderr, "rcvd", pkt, read_len + sizeof(hdr));
 #endif
 
-    if (read_len < (pkt_len + sizeof(hdr))) {  /* Discard the rest */
+    if (read_len < (pkt_len + sizeof(hdr))) {   /* Discard the rest */
 
-        return(RFCNB_Discard_Rest(con, (pkt_len + sizeof(hdr)) - read_len));
+        return (RFCNB_Discard_Rest(con, (pkt_len + sizeof(hdr)) - read_len));
 
     }
-
     if (RFCNB_Timeout > 0)
-        alarm(0);                /* Reset that sucker */
+        alarm(0);               /* Reset that sucker */
 
-    return(read_len + sizeof(RFCNB_Hdr));
+    return (read_len + sizeof(RFCNB_Hdr));
 }
@@ -1,27 +1,27 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB IO Routines Defines
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB IO Routines Defines
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
 
@@ -1,27 +1,27 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB Defines
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB Defines
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #ifndef _RFCNB_RFCNB_PRIV_H
 #define _RFCNB_RFCNB_PRIV_H
@@ -55,7 +55,7 @@ typedef unsigned short uint16;
 
 /* Structures      */
 
-typedef struct redirect_addr * redirect_ptr;
+typedef struct redirect_addr *redirect_ptr;
 
 struct redirect_addr {
 
@@ -68,28 +68,28 @@ struct redirect_addr {
 typedef struct RFCNB_Con {
 
     int fd;                     /* File descripter for TCP/IP connection */
-    int errn;                  /* last error                            */
-    int timeout;		      /* How many milli-secs before IO times out */
-    int redirects;	      /* How many times we were redirected     */
-    struct redirect_addr *redirect_list;  /* First is first address */
+    int errn;                   /* last error                            */
+    int timeout;                /* How many milli-secs before IO times out */
+    int redirects;              /* How many times we were redirected     */
+    struct redirect_addr *redirect_list;        /* First is first address */
     struct redirect_addr *last_addr;
 
 } RFCNB_Con;
 
-typedef char RFCNB_Hdr[4]; /* The header is 4 bytes long with  */
+typedef char RFCNB_Hdr[4];      /* The header is 4 bytes long with  */
 /* char[0] as the type, char[1] the */
 /* flags, and char[2..3] the length */
 
 /* Macros to extract things from the header. These are for portability
-   between architecture types where we are worried about byte order     */
+ * between architecture types where we are worried about byte order     */
 
 #define RFCNB_Pkt_Hdr_Len        4
 #define RFCNB_Pkt_Sess_Len       72
 #define RFCNB_Pkt_Retarg_Len     10
 #define RFCNB_Pkt_Nack_Len       5
 #define RFCNB_Pkt_Type_Offset    0
 #define RFCNB_Pkt_Flags_Offset   1
-#define RFCNB_Pkt_Len_Offset     2   /* Length is 2 bytes plus a flag bit */
+#define RFCNB_Pkt_Len_Offset     2      /* Length is 2 bytes plus a flag bit */
 #define RFCNB_Pkt_N1Len_Offset   4
 #define RFCNB_Pkt_Called_Offset  5
 #define RFCNB_Pkt_N2Len_Offset   38
@@ -99,24 +99,23 @@ typedef char RFCNB_Hdr[4]; /* The header is 4 bytes long with  */
 #define RFCNB_Pkt_Port_Offset    8
 
 /* The next macro isolates the length of a packet, including the bit in the
-   flags                                                                   */
+ * flags                                                                   */
 
 #define RFCNB_Pkt_Len(p)  (PVAL((p), 3) | (PVAL((p), 2) << 8) |     \
                           ((PVAL((p), RFCNB_Pkt_Flags_Offset) & 0x01) << 16))
 
 #define RFCNB_Put_Pkt_Len(p, v) ((p)[1] = (((v) >> 16) & 1)); \
-				((p)[2] = (((v) >> 8) & 0xFF)); \
-				((p)[3] = ((v) & 0xFF));
+                                ((p)[2] = (((v) >> 8) & 0xFF)); \
+                                ((p)[3] = ((v) & 0xFF));
 
 #define RFCNB_Pkt_Type(p) (CVAL((p), RFCNB_Pkt_Type_Offset))
 
-/*typedef struct RFCNB_Hdr {
-
-  unsigned char type;
-  unsigned char flags;
-  int16 len;
-
-  } RFCNB_Hdr;
+#if UNUSED_CODE
+typedef struct RFCNB_Hdr {
+    unsigned char type;
+    unsigned char flags;
+    int16 len;
+} RFCNB_Hdr;
 
 typedef struct RFCNB_Sess_Pkt {
     unsigned char type;
@@ -126,31 +125,28 @@ typedef struct RFCNB_Sess_Pkt {
     char called_name[33];
     unsigned char n2_len;
     char calling_name[33];
-  } RFCNB_Sess_Pkt;
+} RFCNB_Sess_Pkt;
 
 
 typedef struct RFCNB_Nack_Pkt {
-
-  struct RFCNB_Hdr hdr;
-  unsigned char error;
-
-  } RFCNB_Nack_Pkt;
+    struct RFCNB_Hdr hdr;
+    unsigned char error;
+} RFCNB_Nack_Pkt;
 
 typedef struct RFCNB_Retarget_Pkt {
-
-  struct RFCNB_Hdr hdr;
-  int dest_ip;
-  unsigned char port;
-
-  } RFCNB_Redir_Pkt; */
+    struct RFCNB_Hdr hdr;
+    int dest_ip;
+    unsigned char port;
+} RFCNB_Redir_Pkt;
+#endif /* UNUSED_CODE */
 
 /* Static variables */
 
 /* Only declare this if not defined */
 
 #ifndef RFCNB_ERRNO
 extern int RFCNB_errno;
-extern int RFCNB_saved_errno;    /* Save this from point of error */
+extern int RFCNB_saved_errno;   /* Save this from point of error */
 #endif
 
 #endif /* _RFCNB_RFCNB_PRIV_H */
@@ -1,29 +1,29 @@
 #include "config.h"
 
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB Utility Routines ...
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB Utility Routines ...
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #include "rfcnb/rfcnb.h"
 #include "rfcnb/std-includes.h"
@@ -38,10 +38,9 @@
 #include <string.h>
 #endif
 
-extern void (*Prot_Print_Routine)(); /* Pointer to protocol print routine */
+extern void (*Prot_Print_Routine) (FILE * fd, int dir, struct RFCNB_Pkt * pkt, int header, int payload);   /* Pointer to protocol print routine */
 
 const char *RFCNB_Error_Strings[] = {
-
     "RFCNBE_OK: Routine completed successfully.",
     "RFCNBE_NoSpace: No space available for a malloc call.",
     "RFCNBE_BadName: NetBIOS name could not be translated to IP address.",
@@ -59,15 +58,13 @@ const char *RFCNB_Error_Strings[] = {
     "RFCNBE_CallRejUnSpec: Call rejected. Unspecified error.",
     "RFCNBE_BadParam: Bad parameters passed to a routine.",
     "RFCNBE_Timeout: IO Operation timed out ..."
-
 };
 
 /* Convert name and pad to 16 chars as needed */
 /* Name 1 is a C string with null termination, name 2 may not be */
 /* If SysName is true, then put a <00> on end, else space>       */
-
-void RFCNB_CvtPad_Name(char *name1, char *name2)
-
+void
+RFCNB_CvtPad_Name(char *name1, char *name2)
 {
     char c, c1, c2;
     int i, len;
@@ -79,81 +76,75 @@ void RFCNB_CvtPad_Name(char *name1, char *name2)
         if (i >= len) {
 
             c1 = 'C';
-            c2 = 'A'; /* CA is a space */
+            c2 = 'A';           /* CA is a space */
 
         } else {
 
             c = name1[i];
-            c1 = (char)((int)c/16 + (int)'A');
-            c2 = (char)((int)c%16 + (int)'A');
+            c1 = (char) ((int) c / 16 + (int) 'A');
+            c2 = (char) ((int) c % 16 + (int) 'A');
         }
 
-        name2[i*2] = c1;
-        name2[i*2+1] = c2;
+        name2[i * 2] = c1;
+        name2[i * 2 + 1] = c2;
 
     }
 
-    name2[32] = 0;   /* Put in the nll ...*/
+    name2[32] = 0;              /* Put in the nll ... */
 
 }
 
 /* Converts an Ascii NB Name (16 chars) to an RFCNB Name (32 chars)
-   Uses the encoding in RFC1001. Each nibble of byte is added to 'A'
-   to produce the next byte in the name.
-
-   This routine assumes that AName is 16 bytes long and that NBName has
-   space for 32 chars, so be careful ...
-
-*/
-
-void RFCNB_AName_To_NBName(char *AName, char *NBName)
-
+ * Uses the encoding in RFC1001. Each nibble of byte is added to 'A'
+ * to produce the next byte in the name.
+ *
+ * This routine assumes that AName is 16 bytes long and that NBName has
+ * space for 32 chars, so be careful ...
+ */
+void
+RFCNB_AName_To_NBName(char *AName, char *NBName)
 {
     char c, c1, c2;
     int i;
 
-    for (i=0; i < 16; i++) {
+    for (i = 0; i < 16; i++) {
 
         c = AName[i];
 
-        c1 = (char)((c >> 4) + 'A');
-        c2 = (char)((c & 0xF) + 'A');
+        c1 = (char) ((c >> 4) + 'A');
+        c2 = (char) ((c & 0xF) + 'A');
 
-        NBName[i*2] = c1;
-        NBName[i*2+1] = c2;
+        NBName[i * 2] = c1;
+        NBName[i * 2 + 1] = c2;
     }
 
-    NBName[32] = 0; /* Put in a null */
-
+    NBName[32] = 0;             /* Put in a null */
 }
 
 /* Do the reverse of the above ... */
-
-void RFCNB_NBName_To_AName(char *NBName, char *AName)
-
+void
+RFCNB_NBName_To_AName(char *NBName, char *AName)
 {
     char c, c1, c2;
     int i;
 
-    for (i=0; i < 16; i++) {
+    for (i = 0; i < 16; i++) {
 
-        c1 = NBName[i*2];
-        c2 = NBName[i*2+1];
+        c1 = NBName[i * 2];
+        c2 = NBName[i * 2 + 1];
 
-        c = (char)(((int)c1 - (int)'A') * 16 + ((int)c2 - (int)'A'));
+        c = (char) (((int) c1 - (int) 'A') * 16 + ((int) c2 - (int) 'A'));
 
         AName[i] = c;
 
     }
 
-    AName[i] = 0;   /* Put a null on the end ... */
-
+    AName[i] = 0;               /* Put a null on the end ... */
 }
 
 /* Print a string of bytes in HEX etc */
-
-void RFCNB_Print_Hex(FILE *fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
-
+void
+RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
 {
     char c1, c2, outbuf1[33];
     unsigned char c;
@@ -168,27 +159,26 @@ void RFCNB_Print_Hex(FILE *fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
     while (pkt_ptr != NULL) {
 
         for (i = 0;
-                i < ((Len > (pkt_ptr -> len)?pkt_ptr -> len:Len) - Offset);
+                i < ((Len > (pkt_ptr->len) ? pkt_ptr->len : Len) - Offset);
                 i++) {
 
-            c = pkt_ptr -> data[i + Offset];
+            c = pkt_ptr->data[i + Offset];
             c1 = Hex_List[c >> 4];
             c2 = Hex_List[c & 0xF];
 
             outbuf1[j++] = c1;
             outbuf1[j++] = c2;
 
-            if (j == 32) { /* Print and reset */
+            if (j == 32) {      /* Print and reset */
                 outbuf1[j] = 0;
                 fprintf(fd, "    %s\n", outbuf1);
                 j = 0;
             }
-
         }
 
         Offset = 0;
-        Len = Len - pkt_ptr -> len;   /* Reduce amount by this much */
-        pkt_ptr = pkt_ptr -> next;
+        Len = Len - pkt_ptr->len;       /* Reduce amount by this much */
+        pkt_ptr = pkt_ptr->next;
 
     }
 
@@ -200,57 +190,50 @@ void RFCNB_Print_Hex(FILE *fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
         fprintf(fd, "    %s\n", outbuf1);
 
     }
-
     fprintf(fd, "\n");
-
 }
 
 /* Get a packet of size n */
-
-struct RFCNB_Pkt *RFCNB_Alloc_Pkt(int n)
-
-{
+struct RFCNB_Pkt *
+RFCNB_Alloc_Pkt(int n) {
     RFCNB_Pkt *pkt;
 
-    if ((pkt = (struct RFCNB_Pkt *)malloc(sizeof(struct RFCNB_Pkt))) == NULL) {
+    if ((pkt = (struct RFCNB_Pkt *) malloc(sizeof(struct RFCNB_Pkt))) == NULL) {
 
         RFCNB_errno = RFCNBE_NoSpace;
         RFCNB_saved_errno = errno;
-        return(NULL);
+        return (NULL);
 
     }
+    pkt->next = NULL;
+    pkt->len = n;
 
-    pkt -> next = NULL;
-    pkt -> len = n;
+    if (n == 0)
+        return (pkt);
 
-    if (n == 0) return(pkt);
-
-    if ((pkt -> data = (char *)malloc(n)) == NULL) {
+    if ((pkt->data = (char *) malloc(n)) == NULL) {
 
         RFCNB_errno = RFCNBE_NoSpace;
         RFCNB_saved_errno = errno;
         free(pkt);
-        return(NULL);
+        return (NULL);
 
     }
-
-    return(pkt);
-
+    return (pkt);
 }
 
 /* Free up a packet */
-
-void RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt)
-
+void
+RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt)
 {
     struct RFCNB_Pkt *pkt_next;
     char *data_ptr;
 
     while (pkt != NULL) {
 
-        pkt_next = pkt -> next;
+        pkt_next = pkt->next;
 
-        data_ptr = pkt -> data;
+        data_ptr = pkt->data;
 
         if (data_ptr != NULL)
             free(data_ptr);
@@ -260,13 +243,11 @@ void RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt)
         pkt = pkt_next;
 
     }
-
 }
 
 /* Print an RFCNB packet */
-
-void RFCNB_Print_Pkt(FILE *fd, char *dirn, struct RFCNB_Pkt *pkt, int len)
-
+void
+RFCNB_Print_Pkt(FILE * fd, char *dirn, struct RFCNB_Pkt *pkt, int len)
 {
     char lname[17];
 
@@ -275,61 +256,60 @@ void RFCNB_Print_Pkt(FILE *fd, char *dirn, struct RFCNB_Pkt *pkt, int len)
 
     fprintf(fd, "RFCNB Pkt %s:", dirn);
 
-    switch (RFCNB_Pkt_Type(pkt -> data)) {
+    switch (RFCNB_Pkt_Type(pkt->data)) {
 
     case RFCNB_SESSION_MESSAGE:
 
-        fprintf(fd, "SESSION MESSAGE: Length = %i\n", RFCNB_Pkt_Len(pkt -> data));
+        fprintf(fd, "SESSION MESSAGE: Length = %i\n", RFCNB_Pkt_Len(pkt->data));
         RFCNB_Print_Hex(fd, pkt, RFCNB_Pkt_Hdr_Len,
 #ifdef RFCNB_PRINT_DATA
-                        RFCNB_Pkt_Len(pkt -> data) - RFCNB_Pkt_Hdr_Len);
+                        RFCNB_Pkt_Len(pkt->data) - RFCNB_Pkt_Hdr_Len);
 #else
                         40);
 #endif
 
-        if (Prot_Print_Routine != 0) { /* Print the rest of the packet */
+        if (Prot_Print_Routine) {       /* Print the rest of the packet */
 
             Prot_Print_Routine(fd, strcmp(dirn, "sent"), pkt, RFCNB_Pkt_Hdr_Len,
-                               RFCNB_Pkt_Len(pkt -> data) - RFCNB_Pkt_Hdr_Len);
+                               RFCNB_Pkt_Len(pkt->data) - RFCNB_Pkt_Hdr_Len);
 
         }
-
         break;
 
     case RFCNB_SESSION_REQUEST:
 
         fprintf(fd, "SESSION REQUEST: Length = %i\n",
-                RFCNB_Pkt_Len(pkt -> data));
-        RFCNB_NBName_To_AName((char *)(pkt -> data + RFCNB_Pkt_Called_Offset), lname);
+                RFCNB_Pkt_Len(pkt->data));
+        RFCNB_NBName_To_AName((char *) (pkt->data + RFCNB_Pkt_Called_Offset), lname);
         fprintf(fd, "  Called Name: %s\n", lname);
-        RFCNB_NBName_To_AName((char *)(pkt -> data + RFCNB_Pkt_Calling_Offset), lname);
+        RFCNB_NBName_To_AName((char *) (pkt->data + RFCNB_Pkt_Calling_Offset), lname);
         fprintf(fd, "  Calling Name: %s\n", lname);
 
         break;
 
     case RFCNB_SESSION_ACK:
 
         fprintf(fd, "RFCNB SESSION ACK: Length = %i\n",
-                RFCNB_Pkt_Len(pkt -> data));
+                RFCNB_Pkt_Len(pkt->data));
 
         break;
 
     case RFCNB_SESSION_REJ:
         fprintf(fd, "RFCNB SESSION REJECT: Length = %i\n",
-                RFCNB_Pkt_Len(pkt -> data));
+                RFCNB_Pkt_Len(pkt->data));
 
-        if (RFCNB_Pkt_Len(pkt -> data) < 1) {
+        if (RFCNB_Pkt_Len(pkt->data) < 1) {
             fprintf(fd, "   Protocol Error, short Reject packet!\n");
         } else {
-            fprintf(fd, "   Error = %x\n", CVAL(pkt -> data, RFCNB_Pkt_Error_Offset));
+            fprintf(fd, "   Error = %x\n", CVAL(pkt->data, RFCNB_Pkt_Error_Offset));
         }
 
         break;
 
     case RFCNB_SESSION_RETARGET:
 
         fprintf(fd, "RFCNB SESSION RETARGET: Length = %i\n",
-                RFCNB_Pkt_Len(pkt -> data));
+                RFCNB_Pkt_Len(pkt->data));
 
         /* Print out the IP address etc and the port? */
 
@@ -338,117 +318,106 @@ void RFCNB_Print_Pkt(FILE *fd, char *dirn, struct RFCNB_Pkt *pkt, int len)
     case RFCNB_SESSION_KEEP_ALIVE:
 
         fprintf(fd, "RFCNB SESSION KEEP ALIVE: Length = %i\n",
-                RFCNB_Pkt_Len(pkt -> data));
+                RFCNB_Pkt_Len(pkt->data));
         break;
 
     default:
 
         break;
     }
-
 }
 
 /* Resolve a name into an address */
-
-int RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP)
-
+int
+RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP)
 {
-    int addr;         /* Assumes IP4, 32 bit network addresses */
+    int addr;                   /* Assumes IP4, 32 bit network addresses */
     struct hostent *hp;
 
     /* Use inet_addr to try to convert the address */
 
-    if ((addr = inet_addr(host)) == INADDR_NONE) { /* Oh well, a good try :-) */
+    if ((addr = inet_addr(host)) == INADDR_NONE) {      /* Oh well, a good try :-) */
 
         /* Now try a name look up with gethostbyname */
 
-        if ((hp = gethostbyname(host)) == NULL) { /* Not in DNS */
+        if ((hp = gethostbyname(host)) == NULL) {       /* Not in DNS */
 
             /* Try NetBIOS name lookup, how the hell do we do that? */
 
-            RFCNB_errno = RFCNBE_BadName;   /* Is this right? */
+            RFCNB_errno = RFCNBE_BadName;       /* Is this right? */
             RFCNB_saved_errno = errno;
-            return(RFCNBE_Bad);
+            return (RFCNBE_Bad);
 
-        } else { /* We got a name */
+        } else {                /* We got a name */
 
-            memcpy((void *)Dest_IP, (void *)hp -> h_addr_list[0], sizeof(struct in_addr));
+            memcpy((void *) Dest_IP, (void *) hp->h_addr_list[0], sizeof(struct in_addr));
 
         }
-    } else { /* It was an IP address */
+    } else {                    /* It was an IP address */
 
-        memcpy((void *)Dest_IP, (void *)&addr, sizeof(struct in_addr));
+        memcpy((void *) Dest_IP, (void *) &addr, sizeof(struct in_addr));
 
     }
 
     return 0;
-
 }
 
 /* Disconnect the TCP connection to the server */
-
-int RFCNB_Close(int socket)
-
+int
+RFCNB_Close(int socket)
 {
 
     close(socket);
 
     /* If we want to do error recovery, here is where we put it */
 
     return 0;
-
 }
 
 /* Connect to the server specified in the IP address.
-   Not sure how to handle socket options etc.         */
-
-int RFCNB_IP_Connect(struct in_addr Dest_IP, int port)
-
+ * Not sure how to handle socket options etc.         */
+int
+RFCNB_IP_Connect(struct in_addr Dest_IP, int port)
 {
     struct sockaddr_in Socket;
     int fd;
 
     /* Create a socket */
 
-    if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) { /* Handle the error */
+    if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {   /* Handle the error */
 
         RFCNB_errno = RFCNBE_BadSocket;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
     }
-
-    memset((char *)&Socket, 0, sizeof(Socket));
-    memcpy((char *)&Socket.sin_addr, (char *)&Dest_IP, sizeof(Dest_IP));
+    memset((char *) &Socket, 0, sizeof(Socket));
+    memcpy((char *) &Socket.sin_addr, (char *) &Dest_IP, sizeof(Dest_IP));
 
     Socket.sin_port = htons(port);
     Socket.sin_family = PF_INET;
 
     /* Now connect to the destination */
 
-    if (connect(fd, (struct sockaddr *)&Socket, sizeof(Socket)) < 0) { /* Error */
+    if (connect(fd, (struct sockaddr *) &Socket, sizeof(Socket)) < 0) {         /* Error */
 
         close(fd);
         RFCNB_errno = RFCNBE_ConnectFailed;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
     }
-
-    return(fd);
-
+    return (fd);
 }
 
 /* handle the details of establishing the RFCNB session with remote
-   end
-
-*/
-
-int RFCNB_Session_Req(struct RFCNB_Con *con,
-                      char *Called_Name,
-                      char *Calling_Name,
-                      BOOL *redirect,
-                      struct in_addr *Dest_IP,
-                      int * port)
-
+ * end
+ */
+int
+RFCNB_Session_Req(struct RFCNB_Con *con,
+                  char *Called_Name,
+                  char *Calling_Name,
+                  BOOL * redirect,
+                  struct in_addr *Dest_IP,
+                  int *port)
 {
     char *sess_pkt;
 
@@ -464,15 +433,12 @@ int RFCNB_Session_Req(struct RFCNB_Con *con,
     pkt = RFCNB_Alloc_Pkt(RFCNB_Pkt_Sess_Len);
 
     if (pkt == NULL) {
-
-        return(RFCNBE_Bad);  /* Leave the error that RFCNB_Alloc_Pkt gives) */
-
+        return (RFCNBE_Bad);    /* Leave the error that RFCNB_Alloc_Pkt gives) */
     }
+    sess_pkt = pkt->data;       /* Get pointer to packet proper */
 
-    sess_pkt = pkt -> data;    /* Get pointer to packet proper */
-
-    sess_pkt[RFCNB_Pkt_Type_Offset]  = RFCNB_SESSION_REQUEST;
-    RFCNB_Put_Pkt_Len(sess_pkt, RFCNB_Pkt_Sess_Len-RFCNB_Pkt_Hdr_Len);
+    sess_pkt[RFCNB_Pkt_Type_Offset] = RFCNB_SESSION_REQUEST;
+    RFCNB_Put_Pkt_Len(sess_pkt, RFCNB_Pkt_Sess_Len - RFCNB_Pkt_Hdr_Len);
     sess_pkt[RFCNB_Pkt_N1Len_Offset] = 32;
     sess_pkt[RFCNB_Pkt_N2Len_Offset] = 32;
 
@@ -482,42 +448,36 @@ int RFCNB_Session_Req(struct RFCNB_Con *con,
     /* Now send the packet */
 
 #ifdef RFCNB_DEBUG
-
     fprintf(stderr, "Sending packet: ");
-
 #endif
 
     if ((len = RFCNB_Put_Pkt(con, pkt, RFCNB_Pkt_Sess_Len)) < 0) {
 
-        return(RFCNBE_Bad);       /* Should be able to write that lot ... */
+        return (RFCNBE_Bad);    /* Should be able to write that lot ... */
 
     }
-
 #ifdef RFCNB_DEBUG
-
     fprintf(stderr, "Getting packet.\n");
-
 #endif
 
     res_pkt.data = resp;
-    res_pkt.len  = sizeof(resp);
+    res_pkt.len = sizeof(resp);
     res_pkt.next = NULL;
 
     if ((len = RFCNB_Get_Pkt(con, &res_pkt, sizeof(resp))) < 0) {
 
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
-
     /* Now analyze the packet ... */
 
     switch (RFCNB_Pkt_Type(resp)) {
 
-    case RFCNB_SESSION_REJ:         /* Didnt like us ... too bad */
+    case RFCNB_SESSION_REJ:     /* Didnt like us ... too bad */
 
         /* Why did we get rejected ? */
 
-        switch (CVAL(resp,RFCNB_Pkt_Error_Offset)) {
+        switch (CVAL(resp, RFCNB_Pkt_Error_Offset)) {
 
         case 0x80:
             RFCNB_errno = RFCNBE_CallRejNLOCN;
@@ -539,37 +499,28 @@ int RFCNB_Session_Req(struct RFCNB_Con *con,
             break;
         }
 
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
         break;
 
-    case RFCNB_SESSION_ACK:        /* Got what we wanted ...      */
+    case RFCNB_SESSION_ACK:     /* Got what we wanted ...      */
 
-        return(0);
+        return (0);
         break;
 
-    case RFCNB_SESSION_RETARGET:   /* Go elsewhere                */
+    case RFCNB_SESSION_RETARGET:        /* Go elsewhere                */
 
         *redirect = TRUE;       /* Copy port and ip addr       */
 
         memcpy(Dest_IP, (resp + RFCNB_Pkt_IP_Offset), sizeof(struct in_addr));
         *port = SVAL(resp, RFCNB_Pkt_Port_Offset);
 
-        return(0);
+        return (0);
         break;
 
-    default:  /* A protocol error */
+    default:                    /* A protocol error */
 
         RFCNB_errno = RFCNBE_ProtErr;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
         break;
     }
 }
-
-
-
-
-
-
-
-
-
@@ -1,37 +1,37 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB Utility Defines
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB Utility Defines
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 void RFCNB_CvtPad_Name(char *name1, char *name2);
 
 void RFCNB_AName_To_NBName(char *AName, char *NBName);
 
 void RFCNB_NBName_To_AName(char *NBName, char *AName);
 
-void RFCNB_Print_Hex(FILE *fd, struct RFCNB_Pkt *pkt, int Offset, int Len);
+void RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len);
 
-void RFCNB_Print_Pkt(FILE *fd, char *dirn, struct RFCNB_Pkt *pkt, int len);
+void RFCNB_Print_Pkt(FILE * fd, char *dirn, struct RFCNB_Pkt *pkt, int len);
 
 int RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP);
 
@@ -42,7 +42,6 @@ int RFCNB_IP_Connect(struct in_addr Dest_IP, int port);
 int RFCNB_Session_Req(struct RFCNB_Con *con,
                       char *Called_Name,
                       char *Calling_Name,
-                      BOOL *redirect,
+                      BOOL * redirect,
                       struct in_addr *Dest_IP,
-                      int * port);
-
+                      int *port);
@@ -1,27 +1,27 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   RFCNB Defines
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * RFCNB Defines
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #ifndef _RFCNB_RFCNB_H
 #define _RFCNB_RFCNB_H
@@ -52,7 +52,7 @@ extern "C" {
 
     int RFCNB_Hangup(struct RFCNB_Con *con_Handle);
 
-    void *RFCNB_Listen();
+    void *RFCNB_Listen(void);
 
     void RFCNB_Get_Error(char *buffer, int buf_len);
 
@@ -66,5 +66,6 @@ extern "C" {
 
 #ifdef __cplusplus
 }
+
 #endif
-#endif /* _RFCNB_RFCNB_H */
+#endif                          /* _RFCNB_RFCNB_H */
@@ -1,29 +1,29 @@
 #include "config.h"
 
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
-
-   Version 1.0
-   Session Routines ...
-
-   Copyright (C) Richard Sharpe 1996
-
-*/
+ *
+ * Version 1.0
+ * Session Routines ...
+ *
+ * Copyright (C) Richard Sharpe 1996
+ *
+ */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 int RFCNB_errno = 0;
 int RFCNB_saved_errno = 0;
@@ -42,22 +42,22 @@ int RFCNB_saved_errno = 0;
 
 int RFCNB_Stats[RFCNB_MAX_STATS];
 
-void (*Prot_Print_Routine)() = NULL;      /* Pointer to print routine */
+typedef void RFCNB_Prot_Print_Routine(FILE * fd, int dir, struct RFCNB_Pkt *pkt, int header, int payload);
+RFCNB_Prot_Print_Routine *Prot_Print_Routine = NULL;   /* Pointer to protocol print routine */
 
 int RFCNB_Get_Last_Errno(void);
 int RFCNB_Get_Error_Msg(int code, char *msg_buf, int len);
-void RFCNB_Register_Print_Routine(void (*fn)());
+void RFCNB_Register_Print_Routine(RFCNB_Prot_Print_Routine * fn);
 
 /* Set up a session with a remote name. We are passed Called_Name as a
-   string which we convert to a NetBIOS name, ie space terminated, up to
-   16 characters only if we need to. If Called_Address is not empty, then
-   we use it to connect to the remote end, but put in Called_Name ... Called
-   Address can be a DNS based name, or a TCP/IP address ...
-*/
-
-void *RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
-                 int port)
-
+ * string which we convert to a NetBIOS name, ie space terminated, up to
+ * 16 characters only if we need to. If Called_Address is not empty, then
+ * we use it to connect to the remote end, but put in Called_Name ... Called
+ * Address can be a DNS based name, or a TCP/IP address ...
+ */
+
+void *
+RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address, int port)
 {
     struct RFCNB_Con *con;
     struct in_addr Dest_IP;
@@ -68,88 +68,84 @@ void *RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
 
     /* Now, we really should look up the port in /etc/services ... */
 
-    if (port == 0) port = RFCNB_Default_Port;
+    if (port == 0)
+        port = RFCNB_Default_Port;
 
     /* Create a connection structure first */
 
-    if ((con = (struct RFCNB_Con *)malloc(sizeof(struct RFCNB_Con))) == NULL) { /* Error in size */
+    if ((con = (struct RFCNB_Con *) malloc(sizeof(struct RFCNB_Con))) == NULL) {        /* Error in size */
 
         RFCNB_errno = RFCNBE_NoSpace;
         RFCNB_saved_errno = errno;
-        return(NULL);
+        return (NULL);
 
     }
-
-    con -> fd = -0;             /* no descriptor yet */
-    con -> errn = 0;            /* no error yet */
-    con -> timeout = 0;         /* no timeout   */
-    con -> redirects = 0;
+    con->fd = -0;               /* no descriptor yet */
+    con->errn = 0;              /* no error yet */
+    con->timeout = 0;           /* no timeout   */
+    con->redirects = 0;
 
     /* Resolve that name into an IP address */
 
     Service_Address = Called_Name;
-    if (strcmp(Called_Address, "") != 0) { /* If the Called Address = "" */
+    if (strcmp(Called_Address, "") != 0) {      /* If the Called Address = "" */
         Service_Address = Called_Address;
     }
-
-    if ((errno = RFCNB_Name_To_IP(Service_Address, &Dest_IP)) < 0) { /* Error */
+    if ((errno = RFCNB_Name_To_IP(Service_Address, &Dest_IP)) < 0) {    /* Error */
 
         /* No need to modify RFCNB_errno as it was done by RFCNB_Name_To_IP */
         free(con);
-        return(NULL);
+        return (NULL);
 
     }
-
     /* Now connect to the remote end */
 
-    redirect = TRUE;     /* Fudge this one so we go once through */
+    redirect = TRUE;            /* Fudge this one so we go once through */
 
-    while (redirect) {   /* Connect and get session info etc */
+    while (redirect) {          /* Connect and get session info etc */
 
-        redirect = FALSE;  /* Assume all OK */
+        redirect = FALSE;       /* Assume all OK */
 
         /* Build the redirect info. First one is first addr called */
         /* And tack it onto the list of addresses we called        */
 
-        if ((redir_addr = (struct redirect_addr *)malloc(sizeof(struct redirect_addr))) == NULL) { /* Could not get space */
+        if ((redir_addr = (struct redirect_addr *) malloc(sizeof(struct redirect_addr))) == NULL) {     /* Could not get space */
 
             RFCNB_errno = RFCNBE_NoSpace;
             RFCNB_saved_errno = errno;
             free(con);
-            return(NULL);
+            return (NULL);
 
         }
+        memcpy((char *) &(redir_addr->ip_addr), (char *) &Dest_IP, sizeof(Dest_IP));
+        redir_addr->port = port;
+        redir_addr->next = NULL;
 
-        memcpy((char *)&(redir_addr -> ip_addr), (char *)&Dest_IP, sizeof(Dest_IP));
-        redir_addr -> port = port;
-        redir_addr -> next = NULL;
+        if (con->redirect_list == NULL) {       /* Stick on head */
 
-        if (con -> redirect_list == NULL) { /* Stick on head */
-
-            con -> redirect_list = con -> last_addr = redir_addr;
+            con->redirect_list = con->last_addr = redir_addr;
 
         } else {
 
-            con -> last_addr -> next = redir_addr;
-            con -> last_addr = redir_addr;
+            con->last_addr->next = redir_addr;
+            con->last_addr = redir_addr;
 
         }
 
         /* Now, make that connection */
 
-        if ((Client = RFCNB_IP_Connect(Dest_IP, port)) < 0) { /* Error */
+        if ((Client = RFCNB_IP_Connect(Dest_IP, port)) < 0) {   /* Error */
 
             /* No need to modify RFCNB_errno as it was done by RFCNB_IP_Connect */
             free(con);
-            return(NULL);
+            return (NULL);
 
         }
-
-        con -> fd = Client;
+        con->fd = Client;
 
         /* Now send and handle the RFCNB session request              */
         /* If we get a redirect, we will comeback with redirect true
-           and a new IP address in DEST_IP                            */
+         * and a new IP address in DEST_IP                            */
 
         if ((errno = RFCNB_Session_Req(con,
                                        Called_Name,
@@ -158,33 +154,30 @@ void *RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
 
             /* No need to modify RFCNB_errno as it was done by RFCNB_Session.. */
 
-            RFCNB_Close(con->fd);      /* Close it */
+            RFCNB_Close(con->fd);       /* Close it */
             free(con);
-            return(NULL);
+            return (NULL);
 
         }
-
         if (redirect) {
 
             /* We have to close the connection, and then try again */
 
-            (con -> redirects)++;
+            (con->redirects)++;
 
-            RFCNB_Close(con -> fd);  /* Close it */
+            RFCNB_Close(con->fd);       /* Close it */
 
         }
     }
 
-    return(con);
-
+    return (con);
 }
 
 /* We send a packet to the other end ... for the moment, we treat the
-   data as a series of pointers to blocks of data ... we should check the
-   length ... */
-
-int RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)
-
+ * data as a series of pointers to blocks of data ... we should check the
+ * length ... */
+int
+RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)
 {
     struct RFCNB_Pkt *pkt;
     char *hdr;
@@ -198,17 +191,16 @@ int RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length
 
         RFCNB_errno = RFCNBE_NoSpace;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
+    pkt->next = udata;          /* The user data we want to send */
 
-    pkt -> next = udata;   /* The user data we want to send */
-
-    hdr = pkt -> data;
+    hdr = pkt->data;
 
     /* Following crap is for portability across multiple UNIX machines */
 
-    *(hdr + RFCNB_Pkt_Type_Offset)  = RFCNB_SESSION_MESSAGE;
+    *(hdr + RFCNB_Pkt_Type_Offset) = RFCNB_SESSION_MESSAGE;
     RFCNB_Put_Pkt_Len(hdr, Length);
 
 #ifdef RFCNB_DEBUG
@@ -221,25 +213,22 @@ int RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length
 
         /* No need to change RFCNB_errno as it was done by put_pkt ...     */
 
-        return(RFCNBE_Bad);   /* Should be able to write that lot ... */
+        return (RFCNBE_Bad);    /* Should be able to write that lot ... */
 
     }
-
     /* Now we have sent that lot, let's get rid of the RFCNB Header and return */
 
-    pkt -> next = NULL;
+    pkt->next = NULL;
 
     RFCNB_Free_Pkt(pkt);
 
-    return(len);
-
+    return (len);
 }
 
 /* We pick up a message from the internet ... We have to worry about
-   non-message packets ...                                           */
-
-int RFCNB_Recv(void *con_Handle, struct RFCNB_Pkt *Data, int Length)
-
+ * non-message packets ...                                           */
+int
+RFCNB_Recv(void *con_Handle, struct RFCNB_Pkt *Data, int Length)
 {
     struct RFCNB_Pkt *pkt;
 //    struct RFCNB_Hdr *hdr;
@@ -249,10 +238,9 @@ int RFCNB_Recv(void *con_Handle, struct RFCNB_Pkt *Data, int Length)
 
         RFCNB_errno = RFCNBE_BadHandle;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
-
     /* Now get a packet from below. We allocate a header first */
 
     /* Plug in the header and send the data */
@@ -263,124 +251,99 @@ int RFCNB_Recv(void *con_Handle, struct RFCNB_Pkt *Data, int Length)
 
         RFCNB_errno = RFCNBE_NoSpace;
         RFCNB_saved_errno = errno;
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
-
-    pkt -> next = Data;  /* Plug in the data portion */
+    pkt->next = Data;           /* Plug in the data portion */
 
     if ((ret_len = RFCNB_Get_Pkt(con_Handle, pkt, Length + RFCNB_Pkt_Hdr_Len)) < 0) {
 
 #ifdef RFCNB_DEBUG
         fprintf(stderr, "Bad packet return in RFCNB_Recv... \n");
 #endif
 
-        return(RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
-
     /* We should check that we go a message and not a keep alive */
 
-    pkt -> next = NULL;
+    pkt->next = NULL;
 
     RFCNB_Free_Pkt(pkt);
 
-    return(ret_len);
-
+    return (ret_len);
 }
 
 /* We just disconnect from the other end, as there is nothing in the RFCNB */
 /* protocol that specifies any exchange as far as I can see                */
-
-int RFCNB_Hangup(struct RFCNB_Con *con_Handle)
-
+int
+RFCNB_Hangup(struct RFCNB_Con *con_Handle)
 {
 
     if (con_Handle != NULL) {
-        RFCNB_Close(con_Handle -> fd);  /* Could this fail? */
+        RFCNB_Close(con_Handle->fd);    /* Could this fail? */
         free(con_Handle);
     }
-
     return 0;
-
-
 }
 
 /* Set TCP_NODELAY on the socket                                          */
-
-int RFCNB_Set_Sock_NoDelay(struct RFCNB_Con *con_Handle, BOOL yn)
-
+int
+RFCNB_Set_Sock_NoDelay(struct RFCNB_Con *con_Handle, BOOL yn)
 {
 
-    return(setsockopt(con_Handle -> fd, IPPROTO_TCP, TCP_NODELAY,
-                      (char *)&yn, sizeof(yn)));
-
+    return (setsockopt(con_Handle->fd, IPPROTO_TCP, TCP_NODELAY,
+                       (char *) &yn, sizeof(yn)));
 }
 
 #if NOT_IMPLEMENTED
-
 /* Listen for a connection on a port???, when                             */
 /* the connection comes in, we return with the connection                 */
-
-void *RFCNB_Listen()
-
+void *
+RFCNB_Listen()
 {
-
 }
+
 #endif
 
 /* Pick up the last error response as a string, hmmm, this routine should */
 /* have been different ...                                                */
-
-void RFCNB_Get_Error(char *buffer, int buf_len)
-
+void
+RFCNB_Get_Error(char *buffer, int buf_len)
 {
 
     if (RFCNB_saved_errno <= 0) {
-        snprintf(buffer, (buf_len-1) ,"%s", RFCNB_Error_Strings[RFCNB_errno]);
+        snprintf(buffer, (buf_len - 1), "%s", RFCNB_Error_Strings[RFCNB_errno]);
     } else {
-        snprintf(buffer, (buf_len-1), "%s\n\terrno:%s", RFCNB_Error_Strings[RFCNB_errno],
+        snprintf(buffer, (buf_len - 1), "%s\n\terrno:%s", RFCNB_Error_Strings[RFCNB_errno],
                  strerror(RFCNB_saved_errno));
     }
-
 }
 
 /* Pick up the last error response and returns as a code                 */
-
-int RFCNB_Get_Last_Error()
-
+int
+RFCNB_Get_Last_Error()
 {
-
-    return(RFCNB_errno);
-
+    return (RFCNB_errno);
 }
 
 /* Pick up saved errno as well */
-
-int RFCNB_Get_Last_Errno()
-
+int
+RFCNB_Get_Last_Errno()
 {
-
-    return(RFCNB_saved_errno);
-
+    return (RFCNB_saved_errno);
 }
 
 /* Pick up the last error response and return in string ...             */
-
-int RFCNB_Get_Error_Msg(int code, char *msg_buf, int len)
-
+int
+RFCNB_Get_Error_Msg(int code, char *msg_buf, int len)
 {
-
     return (strncpy(msg_buf, RFCNB_Error_Strings[abs(code)], len) != NULL);
-
 }
 
 /* Register a higher level protocol print routine */
-
-void RFCNB_Register_Print_Routine(void (*fn)())
-
+void
+RFCNB_Register_Print_Routine(RFCNB_Prot_Print_Routine * fn)
 {
-
     Prot_Print_Routine = fn;
-
 }
@@ -1,28 +1,28 @@
 /* RFCNB Standard includes ... */
 /*
-
-   RFCNB Standard Includes
-
-   Copyright (C) 1996, Richard Sharpe
-*/
+ *
+ * RFCNB Standard Includes
+ *
+ * Copyright (C) 1996, Richard Sharpe
+ */
 
 /* One day we will conditionalize these on OS types ... */
 
 /*
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 #ifndef _RFCNB_STD_INCLUDES_H
 #define _RFCNB_STD_INCLUDES_H
 
@@ -47,7 +47,7 @@ class ConfigOption
     virtual ~ConfigOption() {}
 
     virtual bool parse(char const *option, const char *value, int reconfiguring) = 0;
-    virtual void dump (StoreEntry * e) const = 0;
+    virtual void dump(StoreEntry * e) const = 0;
 };
 
 class ConfigOptionVector : public ConfigOption
@@ -65,7 +65,7 @@ class ConfigOptionAdapter : public ConfigOption
 {
 
 public:
-    ConfigOptionAdapter(C& theObject, bool (C::*parseFP)(char const *option, const char *value, int reconfiguring), void (C::*dumpFP) (StoreEntry * e) const) : object(theObject), parser (parseFP), dumper(dumpFP) {}
+    ConfigOptionAdapter(C& theObject, bool (C::*parseFP)(char const *option, const char *value, int reconfiguring), void (C::*dumpFP)(StoreEntry * e) const) : object(theObject), parser(parseFP), dumper(dumpFP) {}
 
     bool parse(char const *option, const char *value, int isaReconf) {
         if (parser)
@@ -76,12 +76,12 @@ class ConfigOptionAdapter : public ConfigOption
 
     void dump(StoreEntry * e) const {
         if (dumper)
-            (object.*dumper) (e);
+            (object.*dumper)(e);
     }
 
 private:
     C &object;
-    bool (C::*parser) (char const *option, const char *value, int reconfiguring) ;
+    bool (C::*parser)(char const *option, const char *value, int reconfiguring) ;
     void (C::*dumper)(StoreEntry * e) const;
 };
 
@@ -88,15 +88,16 @@ do_open(diomsg * r, int len, const char *buf)
 
     fs = (file_state *)xcalloc(1, sizeof(*fs));
     fs->id = r->id;
-    fs->key = &fs->id;		/* gack */
+    fs->key = &fs->id;          /* gack */
     fs->fd = fd;
     hash_join(hash, (hash_link *) fs);
-    DEBUG(2)
-    fprintf(stderr, "%d OPEN  id %d, FD %d, fs %p\n",
-            (int) mypid,
-            fs->id,
-            fs->fd,
-            fs);
+    DEBUG(2) {
+        fprintf(stderr, "%d OPEN  id %d, FD %d, fs %p\n",
+                (int) mypid,
+                fs->id,
+                fs->fd,
+                fs);
+    }
     return fd;
 }
 
@@ -119,12 +120,13 @@ do_close(diomsg * r, int len)
 
     fd = fs->fd;
     hash_remove_link(hash, (hash_link *) fs);
-    DEBUG(2)
-    fprintf(stderr, "%d CLOSE id %d, FD %d, fs %p\n",
-            (int) mypid,
-            r->id,
-            fs->fd,
-            fs);
+    DEBUG(2) {
+        fprintf(stderr, "%d CLOSE id %d, FD %d, fs %p\n",
+                (int) mypid,
+                r->id,
+                fs->fd,
+                fs);
+    }
     xfree(fs);
     return close(fd);
 }
@@ -148,8 +150,9 @@ do_read(diomsg * r, int len, char *buf)
     }
 
     if (r->offset > -1 && r->offset != fs->offset) {
-        DEBUG(2)
-        fprintf(stderr, "seeking to %"PRId64"\n", (int64_t)r->offset);
+        DEBUG(2) {
+            fprintf(stderr, "seeking to %"PRId64"\n", (int64_t)r->offset);
+        }
 
         if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
             DEBUG(1) {
@@ -160,9 +163,10 @@ do_read(diomsg * r, int len, char *buf)
     }
 
     x = read(fs->fd, buf, readlen);
-    DEBUG(2)
-    fprintf(stderr, "%d READ %d,%d,%"PRId64" ret %d\n", (int) mypid,
-            fs->fd, readlen, (int64_t)r->offset, x);
+    DEBUG(2) {
+        fprintf(stderr, "%d READ %d,%d,%"PRId64" ret %d\n", (int) mypid,
+                fs->fd, readlen, (int64_t)r->offset, x);
+    }
 
     if (x < 0) {
         DEBUG(1) {
@@ -204,9 +208,10 @@ do_write(diomsg * r, int len, const char *buf)
         }
     }
 
-    DEBUG(2)
-    fprintf(stderr, "%d WRITE %d,%d,%"PRId64"\n", (int) mypid,
-            fs->fd, wrtlen, (int64_t)r->offset);
+    DEBUG(2) {
+        fprintf(stderr, "%d WRITE %d,%d,%"PRId64"\n", (int) mypid,
+                fs->fd, wrtlen, (int64_t)r->offset);
+    }
     x = write(fs->fd, buf, wrtlen);
 
     if (x < 0) {
@@ -234,8 +239,9 @@ do_unlink(diomsg * r, int len, const char *buf)
         return -errno;
     }
 
-    DEBUG(2)
-    fprintf(stderr, "%d UNLNK %s\n", (int) mypid, buf);
+    DEBUG(2) {
+        fprintf(stderr, "%d UNLNK %s\n", (int) mypid, buf);
+    }
     return 0;
 }
 
@@ -245,11 +251,11 @@ msg_handle(diomsg * r, int rl, diomsg * s)
     char *buf = NULL;
     s->mtype = r->mtype;
     s->id = r->id;
-    s->seq_no = r->seq_no;	/* optional, debugging */
+    s->seq_no = r->seq_no;      /* optional, debugging */
     s->callback_data = r->callback_data;
     s->requestor = r->requestor;
-    s->size = 0;		/* optional, debugging */
-    s->offset = 0;		/* optional, debugging */
+    s->size = 0;                /* optional, debugging */
+    s->offset = 0;              /* optional, debugging */
     s->shm_offset = r->shm_offset;
     s->newstyle = r->newstyle;
 
@@ -368,10 +374,11 @@ main(int argc, char *argv[])
     for (;;) {
         alarm(1);
         memset(&rmsg, '\0', sizeof(rmsg));
-        DEBUG(2)
-        std::cerr << "msgrcv: " << rmsgid << ", "
-                  << &rmsg << ", " << diomsg::msg_snd_rcv_sz
-                  << ", " << 0 << ", " << 0 << std::endl;
+        DEBUG(2) {
+            std::cerr << "msgrcv: " << rmsgid << ", "
+                      << &rmsg << ", " << diomsg::msg_snd_rcv_sz
+                      << ", " << 0 << ", " << 0 << std::endl;
+        }
         rlen = msgrcv(rmsgid, &rmsg, diomsg::msg_snd_rcv_sz, 0, 0);
 
         if (rlen < 0) {
@@ -403,8 +410,9 @@ main(int argc, char *argv[])
         }
     }
 
-    DEBUG(2)
-    fprintf(stderr, "%d diskd exiting\n", (int) mypid);
+    DEBUG(2) {
+        fprintf(stderr, "%d diskd exiting\n", (int) mypid);
+    }
 
     if (msgctl(rmsgid, IPC_RMID, 0) < 0)
         perror("msgctl IPC_RMID");
@@ -287,17 +287,13 @@ StringRegistry::StringRegistry()
 }
 
 void
-
-StringRegistry::add
-(String const *entry)
+StringRegistry::add(String const *entry)
 {
     entries.insert(entry, ptrcmp);
 }
 
 void
-
-StringRegistry::remove
-(String const *entry)
+StringRegistry::remove(String const *entry)
 {
     entries.remove(entry, ptrcmp);
 }
@@ -273,17 +273,13 @@ SwapDir::optionObjectSizeDump(StoreEntry * e) const
  * but the parent child relationship isn't implemented yet
  */
 StoreEntry *
-
-SwapDir::get
-(const cache_key *key)
+SwapDir::get(const cache_key *key)
 {
     return Store::Root().get(key);
 }
 
 void
-
-SwapDir::get
-(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+SwapDir::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
 {
     fatal("not implemented");
 }
@@ -201,7 +201,7 @@ diskCombineWrites(struct _fde_disk *fdd)
             fdd->write_q = q->next;
 
             if (q->free_func)
-                (q->free_func) (q->buf);
+                q->free_func(q->buf);
 
             memFree(q, MEM_DWRITE_Q);
         };
@@ -285,7 +285,7 @@ diskHandleWrite(int fd, void *notused)
                 fdd->write_q = q->next;
 
                 if (q->free_func)
-                    (q->free_func) (q->buf);
+                    q->free_func(q->buf);
 
                 if (q) {
                     memFree(q, MEM_DWRITE_Q);
@@ -314,7 +314,7 @@ diskHandleWrite(int fd, void *notused)
             fdd->write_q = q->next;
 
             if (q->free_func)
-                (q->free_func) (q->buf);
+                q->free_func(q->buf);
 
             if (q) {
                 memFree(q, MEM_DWRITE_Q);
@@ -522,10 +522,7 @@ xrename(const char *from, const char *to)
 {
     debugs(21, 2, "xrename: renaming " << from << " to " << to);
 #if defined (_SQUID_OS2_) || defined (_SQUID_WIN32_)
-
-    remove
-    (to);
-
+    remove(to);
 #endif
 
     if (0 == rename(from, to))
@@ -54,8 +54,8 @@
 
 typedef struct _stackmember stackmember;
 
-typedef int evaluate (stackmember * stack, int *depth, int whereAmI,
-                      stackmember * candidate);
+typedef int evaluate(stackmember * stack, int *depth, int whereAmI,
+                     stackmember * candidate);
 
 typedef enum {
     ESI_EXPR_INVALID,
@@ -94,27 +94,27 @@ struct _stackmember {
     int precedence;
 };
 
-static void cleanmember (stackmember *);
-static void stackpop (stackmember * s, int *depth);
+static void cleanmember(stackmember *);
+static void stackpop(stackmember * s, int *depth);
 
 void
-cleanmember (stackmember * s)
+cleanmember(stackmember * s)
 {
     if (s->valuetype == ESI_EXPR_LITERAL
             && s->valuestored == ESI_LITERAL_STRING) {
-        safe_free (s->value.string);
+        safe_free(s->value.string);
         s->value.string = NULL;
     }
 
 }
 
 void
-stackpop (stackmember * s, int *depth)
+stackpop(stackmember * s, int *depth)
 {
     if (!(*depth)--)
         return;
 
-    cleanmember (&s[*depth]);
+    cleanmember(&s[*depth]);
 }
 
 static evaluate evalnegate;
@@ -130,22 +130,22 @@ static evaluate evalnotequals;
 static evaluate evalstartexpr;
 static evaluate evalendexpr;
 static evaluate evalexpr;
-static void dumpstack (stackmember * stack, int depth);
-static int addmember (stackmember * stack, int *stackdepth,
-                      stackmember * candidate);
-static int membercompare (stackmember a, stackmember b);
-static char const *trim (char const *s);
-static stackmember getsymbol (const char *s, char const **endptr);
-static void printliteral (stackmember s);
-static void printmember (stackmember s);
+static void dumpstack(stackmember * stack, int depth);
+static int addmember(stackmember * stack, int *stackdepth,
+                     stackmember * candidate);
+static int membercompare(stackmember a, stackmember b);
+static char const *trim(char const *s);
+static stackmember getsymbol(const char *s, char const **endptr);
+static void printliteral(stackmember s);
+static void printmember(stackmember s);
 
 /* -2 = failed to compate
  * -1 = a less than b
  * 0 = a equal b
  * 2 - a more than b
  */
 int
-membercompare (stackmember a, stackmember b)
+membercompare(stackmember a, stackmember b)
 {
     /* we can compare: sub expressions to sub expressions ,
      * literals to literals
@@ -163,7 +163,7 @@ membercompare (stackmember a, stackmember b)
             return 1;
     } else if (a.valuestored == ESI_LITERAL_STRING) {
         if (b.valuestored == ESI_LITERAL_STRING) {
-            int i =strcmp (a.value.string, b.value.string);
+            int i =strcmp(a.value.string, b.value.string);
 
             if (i < 0)
                 return -1;
@@ -223,8 +223,8 @@ membercompare (stackmember a, stackmember b)
 }
 
 /* return 0 on success, 1 on failure */
-int evalnegate
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalnegate(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     if (whereAmI != *depth - 2)
         /* invalid stack */
@@ -239,7 +239,7 @@ int evalnegate
 
     stack[whereAmI] = stack[(*depth)];
 
-    cleanmember (candidate);
+    cleanmember(candidate);
 
     if (stack[whereAmI].value.integral == 1)
         stack[whereAmI].value.integral = 0;
@@ -249,25 +249,25 @@ int evalnegate
     return 0;
 }
 
-int evalliteral
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalliteral(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     debugs(86, 1, "attempt to evaluate a literal");
     /* literals can't be evaluated */
     return 1;
 }
 
-int evalexpr
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalexpr(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     debugs(86, 1, "attempt to evaluate a sub-expression result");
     /* sub-scpr's can't be evaluated */
     return 1;
 }
 
 
-int evalor
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalor(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -291,11 +291,11 @@ int evalor
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);      /* arg rhs */
+    stackpop(stack, depth);      /* arg rhs */
 
-    stackpop (stack, depth);      /* me */
+    stackpop(stack, depth);      /* me */
 
-    stackpop (stack, depth);      /* arg lhs */
+    stackpop(stack, depth);      /* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -310,15 +310,15 @@ int evalor
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
     return 0;
 }
 
-int evaland
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evaland(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -342,11 +342,11 @@ int evaland
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);      /* arg rhs */
+    stackpop(stack, depth);      /* arg rhs */
 
-    stackpop (stack, depth);      /* me */
+    stackpop(stack, depth);      /* me */
 
-    stackpop (stack, depth);      /* arg lhs */
+    stackpop(stack, depth);      /* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -361,15 +361,15 @@ int evaland
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
     return 0;
 }
 
-int evallesseq
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evallesseq(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -382,17 +382,17 @@ int evallesseq
         /* invalid stack */
         return 1;
 
-    rv = membercompare (stack[whereAmI - 1], stack[whereAmI + 1]);
+    rv = membercompare(stack[whereAmI - 1], stack[whereAmI + 1]);
 
     if (rv == -2)
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);      /* arg rhs */
+    stackpop(stack, depth);      /* arg rhs */
 
-    stackpop (stack, depth);      /* me */
+    stackpop(stack, depth);      /* me */
 
-    stackpop (stack, depth);      /* arg lhs */
+    stackpop(stack, depth);      /* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -407,7 +407,7 @@ int evallesseq
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
@@ -417,8 +417,8 @@ int evallesseq
 
 }
 
-int evallessthan
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evallessthan(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -431,17 +431,17 @@ int evallessthan
         /* invalid stack */
         return 1;
 
-    rv = membercompare (stack[whereAmI - 1], stack[whereAmI + 1]);
+    rv = membercompare(stack[whereAmI - 1], stack[whereAmI + 1]);
 
     if (rv == -2)
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);      /* arg rhs */
+    stackpop(stack, depth);      /* arg rhs */
 
-    stackpop (stack, depth);      /* me */
+    stackpop(stack, depth);      /* me */
 
-    stackpop (stack, depth);      /* arg lhs */
+    stackpop(stack, depth);      /* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -456,7 +456,7 @@ int evallessthan
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
@@ -466,8 +466,8 @@ int evallessthan
 
 }
 
-int evalmoreeq
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalmoreeq(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -480,17 +480,17 @@ int evalmoreeq
         /* invalid stack */
         return 1;
 
-    rv = membercompare (stack[whereAmI - 1], stack[whereAmI + 1]);
+    rv = membercompare(stack[whereAmI - 1], stack[whereAmI + 1]);
 
     if (rv == -2)
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);      /* arg rhs */
+    stackpop(stack, depth);      /* arg rhs */
 
-    stackpop (stack, depth);      /* me */
+    stackpop(stack, depth);      /* me */
 
-    stackpop (stack, depth);      /* arg lhs */
+    stackpop(stack, depth);      /* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -505,7 +505,7 @@ int evalmoreeq
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
@@ -515,8 +515,8 @@ int evalmoreeq
 
 }
 
-int evalmorethan
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalmorethan(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -529,17 +529,17 @@ int evalmorethan
         /* invalid stack */
         return 1;
 
-    rv = membercompare (stack[whereAmI - 1], stack[whereAmI + 1]);
+    rv = membercompare(stack[whereAmI - 1], stack[whereAmI + 1]);
 
     if (rv == -2)
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);	/* arg rhs */
+    stackpop(stack, depth);	/* arg rhs */
 
-    stackpop (stack, depth);	/* me */
+    stackpop(stack, depth);	/* me */
 
-    stackpop (stack, depth);	/* arg lhs */
+    stackpop(stack, depth);	/* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -554,7 +554,7 @@ int evalmorethan
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
@@ -564,8 +564,8 @@ int evalmorethan
 }
 
 int
-evalequals (stackmember * stack, int *depth, int whereAmI,
-            stackmember * candidate)
+evalequals(stackmember * stack, int *depth, int whereAmI,
+           stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -578,17 +578,17 @@ evalequals (stackmember * stack, int *depth, int whereAmI,
         /* invalid stack */
         return 1;
 
-    rv = membercompare (stack[whereAmI - 1], stack[whereAmI + 1]);
+    rv = membercompare(stack[whereAmI - 1], stack[whereAmI + 1]);
 
     if (rv == -2)
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);	/* arg rhs */
+    stackpop(stack, depth);	/* arg rhs */
 
-    stackpop (stack, depth);	/* me */
+    stackpop(stack, depth);	/* me */
 
-    stackpop (stack, depth);	/* arg lhs */
+    stackpop(stack, depth);	/* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -603,16 +603,16 @@ evalequals (stackmember * stack, int *depth, int whereAmI,
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
     /* debugs(86, 1, "?= " << srv.value.integral << " "); */
     return 0;
 }
 
-int evalnotequals
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalnotequals(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     int rv;
     stackmember srv;
@@ -625,17 +625,17 @@ int evalnotequals
         /* invalid stack */
         return 1;
 
-    rv = membercompare (stack[whereAmI - 1], stack[whereAmI + 1]);
+    rv = membercompare(stack[whereAmI - 1], stack[whereAmI + 1]);
 
     if (rv == -2)
         /* invalid comparison */
         return 1;
 
-    stackpop (stack, depth);	/* arg rhs */
+    stackpop(stack, depth);	/* arg rhs */
 
-    stackpop (stack, depth);	/* me */
+    stackpop(stack, depth);	/* me */
 
-    stackpop (stack, depth);	/* arg lhs */
+    stackpop(stack, depth);	/* arg lhs */
 
     srv.valuetype = ESI_EXPR_EXPR;
 
@@ -650,16 +650,16 @@ int evalnotequals
     stack[(*depth)++] = srv;
 
     /* we're out of way, try adding now */
-    if (!addmember (stack, depth, candidate))
+    if (!addmember(stack, depth, candidate))
         /* Something wrong upstream */
         return 1;
 
     /* debugs(86, 1, "?= " << srv.value.integral << " "); */
     return 0;
 }
 
-int evalstartexpr
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalstartexpr(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     /* debugs(86, 1, "?("); */
 
@@ -675,20 +675,20 @@ int evalstartexpr
 
     stack[whereAmI] = stack[(*depth)];
 
-    cleanmember (candidate);
+    cleanmember(candidate);
 
     return 0;
 }
 
-int evalendexpr
-(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
+int
+evalendexpr(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 {
     /* Can't evaluate ) brackets */
     return 1;
 }
 
 char const *
-trim (char const *s)
+trim(char const *s)
 {
     while (*s == ' ')
         ++s;
@@ -697,33 +697,33 @@ trim (char const *s)
 }
 
 stackmember
-getsymbol (const char *s, char const **endptr)
+getsymbol(const char *s, char const **endptr)
 {
     stackmember rv;
     char *end;
     char const *origs = s;
     /* trim whitespace */
-    s = trim (s);
+    s = trim(s);
     rv.eval = NULL;		/* A literal */
     rv.valuetype = ESI_EXPR_INVALID;
     rv.valuestored = ESI_LITERAL_INVALID;
     rv.precedence = 1; /* A literal */
 
     if (('0' <= *s && *s <= '9') || *s == '-') {
-        size_t length = strspn (s, "0123456789.");
+        size_t length = strspn(s, "0123456789.");
         char const *point;
 
-        if ((point = strchr (s, '.')) && point - s < (ssize_t)length) {
+        if ((point = strchr(s, '.')) && point - s < (ssize_t)length) {
             /* floating point */
             errno=0; /* reset errno */
-            rv.value.floating = strtod (s, &end);
+            rv.value.floating = strtod(s, &end);
 
             if (s == end || errno) {
                 /* Couldn't convert to float */
                 debugs(86, 1, "failed to convert '" << s << "' to float ");
                 *endptr = origs;
             } else {
-                debugs (86,6, "found " << rv.value.floating << " of length " << end - s);
+                debugs(86,6, "found " << rv.value.floating << " of length " << end - s);
                 *endptr = end;
                 rv.eval = evalliteral;
                 rv.valuestored = ESI_LITERAL_FLOAT;
@@ -733,14 +733,14 @@ getsymbol (const char *s, char const **endptr)
         } else {
             /* INT */
             errno=0; /* reset errno */
-            rv.value.integral = strtol (s, &end, 0);
+            rv.value.integral = strtol(s, &end, 0);
 
             if (s == end || errno) {
                 /* Couldn't convert to int */
                 debugs(86, 1, "failed to convert '" << s << "' to int ");
                 *endptr = origs;
             } else {
-                debugs (86,6, "found " << rv.value.integral << " of length " << end - s);
+                debugs(86,6, "found " << rv.value.integral << " of length " << end - s);
                 *endptr = end;
                 rv.eval = evalliteral;
                 rv.valuestored = ESI_LITERAL_INT;
@@ -777,9 +777,9 @@ getsymbol (const char *s, char const **endptr)
             /* Special case for zero length strings */
 
             if (t - s - 1)
-                rv.value.string = xstrndup (s + 1, t - s - 1);
+                rv.value.string = xstrndup(s + 1, t - s - 1);
             else
-                rv.value.string = static_cast<char *>(xcalloc (1,1));
+                rv.value.string = static_cast<char *>(xcalloc(1,1));
 
             rv.eval = evalliteral;
 
@@ -854,15 +854,15 @@ getsymbol (const char *s, char const **endptr)
             rv.precedence = 5;
             rv.eval = evalmorethan;
         }
-    } else if (!strncmp (s, "false", 5)) {
+    } else if (!strncmp(s, "false", 5)) {
         debugs(86, 5, "getsymbol: found variable result 'false'");
         *endptr = s + 5;
         rv.valuetype = ESI_EXPR_EXPR;
         rv.valuestored = ESI_LITERAL_BOOL;
         rv.value.integral = 0;
         rv.precedence = 1;
         rv.eval = evalexpr;
-    } else if (!strncmp (s, "true", 4)) {
+    } else if (!strncmp(s, "true", 4)) {
         debugs(86, 5, "getsymbol: found variable result 'true'");
         *endptr = s + 4;
         rv.valuetype = ESI_EXPR_EXPR;
@@ -879,24 +879,24 @@ getsymbol (const char *s, char const **endptr)
 }
 
 void
-printliteral (stackmember s)
+printliteral(stackmember s)
 {
     switch (s.valuestored) {
 
     case ESI_LITERAL_INVALID:
-        old_debug(86, 1) ( " Invalid " );
+        old_debug(86, 1)( " Invalid " );
         break;
 
     case ESI_LITERAL_FLOAT:
-        old_debug(86,1) ("%f", s.value.floating);
+        old_debug(86,1)("%f", s.value.floating);
         break;
 
     case ESI_LITERAL_STRING:
-        old_debug(86,1) ("'%s'", s.value.string);
+        old_debug(86,1)("'%s'", s.value.string);
         break;
 
     case ESI_LITERAL_INT:
-        old_debug(86,1) ("%d", s.value.integral);
+        old_debug(86,1)("%d", s.value.integral);
         break;
 
     case ESI_LITERAL_BOOL:
@@ -905,82 +905,82 @@ printliteral (stackmember s)
 }
 
 void
-printmember (stackmember s)
+printmember(stackmember s)
 {
     switch (s.valuetype) {
 
     case ESI_EXPR_INVALID:
-        old_debug(86,1) (" Invalid ");
+        old_debug(86,1)(" Invalid ");
         break;
 
     case ESI_EXPR_LITERAL:
-        printliteral (s);
+        printliteral(s);
         break;
 
     case ESI_EXPR_EXPR:
-        old_debug(86,1) ("%s", s.value.integral ? "true" : "false");
+        old_debug(86,1)("%s", s.value.integral ? "true" : "false");
         break;
 
     case ESI_EXPR_OR:
-        old_debug(86,1) ("|");
+        old_debug(86,1)("|");
         break;
 
     case ESI_EXPR_AND:
-        old_debug(86,1) ("&");
+        old_debug(86,1)("&");
         break;
 
     case ESI_EXPR_NOT:
-        old_debug(86,1) ("!");
+        old_debug(86,1)("!");
         break;
 
     case ESI_EXPR_START:
-        old_debug(86,1) ("(");
+        old_debug(86,1)("(");
         break;
 
     case ESI_EXPR_END:
-        old_debug(86,1) (")");
+        old_debug(86,1)(")");
         break;
 
     case ESI_EXPR_EQ:
-        old_debug(86,1) ("==");
+        old_debug(86,1)("==");
         break;
 
     case ESI_EXPR_NOTEQ:
-        old_debug(86,1) ("!=");
+        old_debug(86,1)("!=");
         break;
 
     case ESI_EXPR_LESS:
-        old_debug(86,1) ("<");
+        old_debug(86,1)("<");
         break;
 
     case ESI_EXPR_LESSEQ:
-        old_debug(86,1) ("<=");
+        old_debug(86,1)("<=");
         break;
 
     case ESI_EXPR_MORE:
-        old_debug(86,1) (">");
+        old_debug(86,1)(">");
         break;
 
     case ESI_EXPR_MOREEQ:
-        old_debug(86,1) (">=");
+        old_debug(86,1)(">=");
         break;
     }
 }
 
 void
-dumpstack (stackmember * stack, int depth)
+dumpstack(stackmember * stack, int depth)
 {
     int i;
 
     for (i = 0; i < depth; ++i)
-        printmember (stack[i]);
+        printmember(stack[i]);
 
     if (depth)
-        old_debug(86,1) ("\n");
+        old_debug(86,1)("\n");
 }
 
 int
-addmember (stackmember * stack, int *stackdepth, stackmember * candidate)
+addmember(stackmember * stack, int *stackdepth, stackmember * candidate)
 {
     if (candidate->valuetype != ESI_EXPR_LITERAL && *stackdepth > 1) {
         /* !(!(a==b))) is why thats safe */
@@ -992,11 +992,11 @@ addmember (stackmember * stack, int *stackdepth, stackmember * candidate)
 
             if (stack[*stackdepth - 2].valuetype == ESI_EXPR_LITERAL ||
                     stack[*stackdepth - 2].valuetype == ESI_EXPR_INVALID ||
-                    stack[*stackdepth - 2].eval (stack, stackdepth,
-                                                 *stackdepth - 2, candidate)) {
+                    stack[*stackdepth - 2].eval(stack, stackdepth,
+                                                *stackdepth - 2, candidate)) {
                 /* cleanup candidate and stack */
-                dumpstack (stack, *stackdepth);
-                cleanmember (candidate);
+                dumpstack(stack, *stackdepth);
+                cleanmember(candidate);
                 debugs(86, 1, "invalid expression");
                 return 0;
             }
@@ -1010,20 +1010,20 @@ addmember (stackmember * stack, int *stackdepth, stackmember * candidate)
 }
 
 int
-ESIExpression::Evaluate (char const *s)
+ESIExpression::Evaluate(char const *s)
 {
     stackmember stack[20];
     int stackdepth = 0;
     char const *end;
     PROF_start(esiExpressionEval);
 
     while (*s) {
-        stackmember candidate = getsymbol (s, &end);
+        stackmember candidate = getsymbol(s, &end);
 
         if (candidate.valuetype != ESI_EXPR_INVALID) {
-            assert (s != end);
+            assert(s != end);
 
-            if (!addmember (stack, &stackdepth, &candidate)) {
+            if (!addmember(stack, &stackdepth, &candidate)) {
                 PROF_stop(esiExpressionEval);
                 return 0;
             }
@@ -1043,7 +1043,7 @@ ESIExpression::Evaluate (char const *s)
         rv.precedence = 0;
 
         if (stack[stackdepth - 2].
-                eval (stack, &stackdepth, stackdepth - 2, &rv)) {
+                eval(stack, &stackdepth, stackdepth - 2, &rv)) {
             /* special case - leading operator failed */
             debugs(86, 1, "invalid expression");
             PROF_stop(esiExpressionEval);
@@ -1058,9 +1058,9 @@ ESIExpression::Evaluate (char const *s)
     }
 
     /* if we hit here, we think we have a valid result */
-    assert (stackdepth == 1);
+    assert(stackdepth == 1);
 
-    assert (stack[0].valuetype == ESI_EXPR_EXPR);
+    assert(stack[0].valuetype == ESI_EXPR_EXPR);
 
     PROF_stop(esiExpressionEval);
 
@@ -94,8 +94,7 @@ class external_acl
 public:
     external_acl *next;
 
-    void add
-    (ExternalACLEntry *);
+    void add(ExternalACLEntry *);
 
     void trimCache();
 
@@ -628,9 +627,7 @@ find_externalAclHelper(const char *name)
 }
 
 void
-
-external_acl::add
-(ExternalACLEntry *anEntry)
+external_acl::add(ExternalACLEntry *anEntry)
 {
     trimCache();
     assert (anEntry->def == NULL);
@@ -1131,8 +1128,7 @@ external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData
     entry->key = xstrdup(key);
     entry->update (data);
 
-    def->add
-    (entry);
+    def->add(entry);
 
     return entry;
 }
@@ -690,8 +690,7 @@ ipc_thread_1(void *in_params)
     else
         thread_params.rfd = prfd_ipc;
 
-    thread =
-        (HANDLE) _beginthreadex(NULL, 0, ipc_thread_2, &thread_params, 0, NULL);
+    thread = (HANDLE)_beginthreadex(NULL, 0, ipc_thread_2, &thread_params, 0, NULL);
 
     if (!thread) {
         debugs(54, 0, "ipcCreate: CHILD: _beginthreadex: " << xstrerror());
@@ -367,9 +367,7 @@ PconnModule::registerWithCacheManager(void)
 }
 
 void
-
-PconnModule::add
-(PconnPool *aPool)
+PconnModule::add(PconnPool *aPool)
 {
     assert(poolCount < MAX_NUM_PCONN_POOLS);
     *(pools+poolCount) = aPool;
@@ -689,19 +689,14 @@ StoreController::dereference(StoreEntry & e)
 }
 
 StoreEntry *
-
-StoreController::get
-(const cache_key *key)
+StoreController::get(const cache_key *key)
 {
 
-    return swapDir->get
-           (key);
+    return swapDir->get(key);
 }
 
 void
-
-StoreController::get
-(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+StoreController::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
 {
     fatal("not implemented");
 }
@@ -764,9 +759,7 @@ StoreHashIndex::create()
 /* Lookup an object in the cache.
  * return just a reference to object, don't start swapping in yet. */
 StoreEntry *
-
-StoreHashIndex::get
-(const cache_key *key)
+StoreHashIndex::get(const cache_key *key)
 {
     PROF_start(storeGet);
     debugs(20, 3, "storeGet: looking up " << storeKeyText(key));
@@ -776,9 +769,7 @@ StoreHashIndex::get
 }
 
 void
-
-StoreHashIndex::get
-(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
+StoreHashIndex::get(String const key, STOREGETCLIENT aCallback, void *aCallbackData)
 {
     fatal("not implemented");
 }
@@ -13,17 +13,13 @@ TestStore::callback()
 }
 
 StoreEntry*
-
-TestStore::get
-(const cache_key*)
+TestStore::get(const cache_key*)
 {
     return NULL;
 }
 
 void
-
-TestStore::get
-(String, void (*)(StoreEntry*, void*), void*)
+TestStore::get(String, void (*)(StoreEntry*, void*), void*)
 {}
 
 void
@@ -58,7 +54,7 @@ TestStore::search(String const url, HttpRequest *)
 void
 testStore::testSetRoot()
 {
-    StorePointer aStore (new TestStore);
+    StorePointer aStore(new TestStore);
     Store::Root(aStore);
 
     CPPUNIT_ASSERT(&Store::Root() == aStore.getRaw());
@@ -68,8 +64,8 @@ testStore::testSetRoot()
 void
 testStore::testUnsetRoot()
 {
-    StorePointer aStore (new TestStore);
-    StorePointer aStore2 (new TestStore);
+    StorePointer aStore(new TestStore);
+    StorePointer aStore2(new TestStore);
     Store::Root(aStore);
     Store::Root(aStore2);
     CPPUNIT_ASSERT(&Store::Root() == aStore2.getRaw());
@@ -79,7 +75,7 @@ testStore::testUnsetRoot()
 void
 testStore::testStats()
 {
-    TestStorePointer aStore (new TestStore);
+    TestStorePointer aStore(new TestStore);
     Store::Root(aStore.getRaw());
     CPPUNIT_ASSERT(aStore->statsCalled == false);
     Store::Stats(NullStoreEntry::getInstance());
@@ -90,7 +86,7 @@ testStore::testStats()
 void
 testStore::testMaxSize()
 {
-    StorePointer aStore (new TestStore);
+    StorePointer aStore(new TestStore);
     Store::Root(aStore.getRaw());
     CPPUNIT_ASSERT(aStore->maxSize() == 3);
     Store::Root(NULL);