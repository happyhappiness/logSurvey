@@ -1,3 +1,129 @@
+Changes to Squid-2.3.DEVEL3 ():
+
+	- Added --enable-underscores configure option.  This allows
+	  Squid to accept hostnames with underscores in them.  Your
+	  DNS resolver may still complain about them, however.
+	- Added --heap-replacement configure option.  This enables
+	  the alternative cache replacement policies, such as
+	  GDSF, and LFUDA.
+	- WCCP establishes and registers with the router faster.	
+	- Added 'maxconn' acl type to limit the number of established
+	  connections from a single client IP address.  Submitted
+	  by Vadim Kolontsov.
+	- Close FTP data socket as soon as transfer completes
+	  (Alexander V. Lukyanov).
+	- Fixed ftpReadPass() to not clobber ctrl.message when
+	  the PASS command fails.
+	- Added a redirect.c patch so squidGuard is able to do
+	  per-user access control (Antony T Curtis).
+	- discard the pumpMethod() function, and instead use the
+	  fact that the request has a request entity (content-length
+	  present) (Henrik).
+	- Reload the MIME icons at reconfigure time (Radu Greab).
+	- Updated Richard Huveneers' SMB authentication module to
+	  his version 0.05 package.
+	- Fixed lib/heap.c::heap_delete() bug when deleting the
+	  last node.
+	- Fixed an integer conversion bug in
+	  lib/rfc1035.c::rfc1035AnswersUnpack().
+	- Fixed lib/rfc1738 routines to encode reserved characters,
+	  in addition to encoding the unsafe characters (Henrik).
+	- Changed the interface for splay compare and "walk"
+	  functions to take a void pointer, instead of a splayNode
+	  pointer (Henrik).
+	- Changed numerous HTTP parsing routines to use ssize_t
+	  instead of size_t.  This was done because size_t may be
+	  signed or unsigned.  When it is unsigned, gcc emits
+	  numerous "comparison is always true" warnings.  At least
+	  we know ssize_t is always signed.
+	- Fixed src/HttpHeaderTools::httpHeaderHasConnDir() and
+	  friends so that it properly handles multi-value lists.
+	- Added an "end" (ssize_t) parameter to
+	  src/HttpReply::httpReplyParse() so that we know exactly
+	  where to terminate the header buffer.
+	- Changed src/access_log.c::log_quote() so that it only
+	  encodes whitespace characters, and not all URL-special
+	  characters (Henrik).
+	- Added local port ACL type ("myport") (Henrik).
+	- Added maximum number of connections per client ("maxconn")
+	  as an ACL type.
+	- Fixed proxy authentication username/password parsing to
+	  be more robust (Henrik).
+	- Fixed ACL domain/host and domain/domain comparison
+	  functions yet again.  Eliminated duplicate code so that
+	  only src/url.c::matchDomainName() contains this mysterious
+	  code.
+	- Changed the 'http_port' option to accept an IP address
+	  or hostname as well (Henrik).
+	- Removed 'tcp_incoming_addr' option.
+	- Added an access control list for the redirector
+	  ('redirector_access').  Requests which match are sent to
+	  the redirector.  All requests. are redirected by default.
+	- Added the 'authenticate_ip_ttl' option.  It specifies
+	  how long a valid proxy authentication credential is
+	  bound to a specific address.
+	- Added 280, 488, 591, and 777 to "Safe_ports" ACL.
+	- Removed the unused and highly questionable 'forward_snmpd_port'
+	  option.
+	- Added an option to accept DNS messages from unknown nameservers.
+	  This may be necessary if replies come from a different address
+	  than queries are sent to.
+	- Added #includes for IP Filter files in netinet directory.
+	- Fixed a bug with retrying forwarded IMS requests (Henrik).
+	- Fixed a bug in src/client_side.c::clientInterpretRequestHeaders()
+	  where we were checking a cache-control bit before getting the
+	  mask from the HTTP headers (pallo@initio.no).
+	- Fixed a bug with "no_cache" access list.  If not defined,
+	  everything was uncachable by default.
+	- Fixed a bug with timed-out client-side HTTP connections.
+	  We didn't cancel the read handler, which could lead to 
+	  "rwstate != NULL" warnings.
+	- Changed comm_open() to only call fdAdjustReserved() for
+	  specific errors (ENFILE, EMFILE);
+	- Fixed NULL pointer bug in idnsParseResolvConf().
+	- Split CACHE_DIGEST_HIT into CD_PARENT_HIT and CD_SIBLING_HIT.
+	- Added DELETE request method.
+	- Added RFC 2518 HTTP status codes.
+	- Fixed handling of URL passwords when we need to rewrite a
+	  BASE HREF URL (Henrik).
+	- Fixed a bug with FTP requests where a request gets aborted,
+	  but we try to complete it anyway.  It would result in a
+	  "store_status != STORE_PENDING" assertion.  The solution
+	  is to check for ENTRY_ABORTED before reading from
+	  the control channel too.
+	- Changed FTP to retry a request if Squid fails to establish
+	  a PASV data connection (Henrik).
+	- Fixed numerous HTCP memory leaks and an uninitialized memory
+	  bug.
+	- Changed httpMaybeRemovePublic() with RFC 2518 and 2616 in
+	  mind (Henrik).
+	- Minor fixes for Rhapsody systems.
+	- Define _XOPEN_SOURCE_EXTENDED in squid.h so that AIX systems
+	  don't include varargs.h.
+	- Changed src/store_client.c::storeClientType() so that
+	  an entry can have more than one STORE_MEM_CLIENT.
+	- Changed src/store_client.c::storeClientReadHeader()
+	  to check swapfile metadata (Henrik).
+	- Changed src/url.c::urlCheckRequest() to return FALSE for
+	  any "https://" URL.  These should always be CONNECT
+	  instead.  If Squid gets an "https://" URL, it is a browser
+	  bug.
+	- Added numerous squid.conf options for controlling cache
+	  digests.   Previously these were hard-coded in
+	  src/store_digest.c.  (Martin Hamilton)
+	- Added 'cache_peer' option called 'digest-url' that
+	  lets you specify the URL for a peer's digest.
+	  (Martin Hamilton)
+	- Added DELAY_POOLS hacks to scan "slow" connections in
+	  a random order (David Luyer).
+	- ARP_ACL fixes from Damien Miller.  Linux 2.2.x uses a
+	  per-interface arp/neighbour cache, whereas 2.0.x uses a
+	  unified cache. Under 2.2.x you are required to specify
+	  a interface name when looking up ARP table entries with
+	  SIOCGARP.
+	- If the process umask is not set (i.e. 0), then Squid
+	  changes it to 007.
+
 Changes to Squid-2.3.DEVEL2 ():
 
 	- Added --enable-truncate configure option.
@@ -31,12 +157,6 @@ Changes to Squid-2.3.DEVEL2 ():
 	  (Henrik Nordstrom).
 	- Added queue length to async I/O cachemgr stats (Henrik Nordstrom).
 	- Added OPTIONS request method.
-	- WCCP establishes and registers with the router faster.	
-	- Added 'maxconn' acl type to limit the number of established
-	  connections from a single client IP address.  Submitted
-	  by Vadim Kolontsov.
-	- Close FTP data socket as soon as transfer completes
-	  (Alexander V. Lukyanov).
 
 Changes to Squid-2.3.DEVEL1 ():
 
@@ -90,11 +90,11 @@ ac_help="$ac_help
                           This allows you to remove code that performs
                           Ident (RFC 931) lookups."
 ac_help="$ac_help
-  --disable-internal-dns This prevents Squid from directly sending and
+  --disable-internal-dns  This prevents Squid from directly sending and
                           receiving DNS messages, and instead enables the
                           old external 'dnsserver' processes."
 ac_help="$ac_help
-  --enable-truncate      This uses truncate() instead of unlink() when
+  --enable-truncate       This uses truncate() instead of unlink() when
                           removing cache files.  Truncate gives a little
                           performance improvement, but may cause problems
                           when used with async I/O.  Truncate uses more
@@ -106,6 +106,12 @@ ac_help="$ac_help
                           hostnames by using this switch, provided that
                           the resolver library on the host where Squid runs
                           does not reject _ in hostnames..."
+ac_help="$ac_help
+  --enable-heap-replacement
+                          This option allows you to use various cache
+                          replacement algorithms, instead of the standard
+                          LRU algorithm.
+                          "
 ac_help="$ac_help
   --enable-diskd          Uses shared memory, message queues, and external
                           processes for disk I/O."
@@ -617,7 +623,7 @@ fi
 
 
 
-# From configure.in Revision: 1.180 
+# From configure.in Revision: 1.181 
 ac_aux_dir=
 for ac_dir in cfgaux $srcdir/cfgaux; do
   if test -f $ac_dir/install-sh; then
@@ -645,7 +651,7 @@ else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:649: checking host system type" >&5
+echo "configure:655: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -713,7 +719,7 @@ PRESET_CFLAGS="$CFLAGS"
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:717: checking for $ac_word" >&5
+echo "configure:723: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -742,7 +748,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:746: checking for $ac_word" >&5
+echo "configure:752: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -790,7 +796,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:794: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:800: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -800,11 +806,11 @@ ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext <<EOF
-#line 804 "configure"
+#line 810 "configure"
 #include "confdefs.h"
 main(){return(0);}
 EOF
-if { (eval echo configure:808: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:814: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -824,12 +830,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:828: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:834: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:833: checking whether we are using GNU C" >&5
+echo "configure:839: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -838,7 +844,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:842: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:848: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -853,7 +859,7 @@ if test $ac_cv_prog_gcc = yes; then
   ac_save_CFLAGS="$CFLAGS"
   CFLAGS=
   echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:857: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:863: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -939,15 +945,6 @@ if test -z "$PRESET_LDFLAGS"; then
     fi
 fi
 
-if test "x$ac_cv_enabled_dlmalloc" = "x"; then
-    case "$host" in
-	i386-*-solaris2.*)
-		echo "Enabling dlmalloc for $host"
-		ac_cv_enabled_dlmalloc="yes"
-		;;
-    esac
-fi
-
 # Check whether --enable-dlmalloc or --disable-dlmalloc was given.
 if test "${enable_dlmalloc+set}" = set; then
   enableval="$enable_dlmalloc"
@@ -1506,11 +1503,25 @@ EOF
 fi
 
 
+# Check whether --enable-heap-replacement or --disable-heap-replacement was given.
+if test "${enable_heap_replacement+set}" = set; then
+  enableval="$enable_heap_replacement"
+   if test "$enableval" = "yes" ; then
+    echo "Enabling HEAP_REPLACEMENT"
+    cat >> confdefs.h <<\EOF
+#define HEAP_REPLACEMENT 1
+EOF
+
+  fi
+
+fi
+
+
 # Check whether --enable-diskd or --disable-diskd was given.
 if test "${enable_diskd+set}" = set; then
   enableval="$enable_diskd"
    if test "$enableval" = "yes" ; then
-    echo "Enabling DISKD"
+    echo "DISKD enabled"
     cat >> confdefs.h <<\EOF
 #define USE_DISKD 1
 EOF
@@ -1544,7 +1555,7 @@ case "$host" in
 esac
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1548: checking how to run the C preprocessor" >&5
+echo "configure:1559: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -1559,13 +1570,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1563 "configure"
+#line 1574 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1569: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1580: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1576,13 +1587,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1580 "configure"
+#line 1591 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1586: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1597: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1615,7 +1626,7 @@ echo "$ac_t""$CPP" 1>&6
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:1619: checking for a BSD compatible install" >&5
+echo "configure:1630: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1667,7 +1678,7 @@ test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1671: checking for $ac_word" >&5
+echo "configure:1682: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1694,7 +1705,7 @@ else
 fi
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:1698: checking whether ln -s works" >&5
+echo "configure:1709: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1717,7 +1728,7 @@ fi
 # Extract the first word of "sh", so it can be a program name with args.
 set dummy sh; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1721: checking for $ac_word" >&5
+echo "configure:1732: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SH'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1749,7 +1760,7 @@ fi
 # Extract the first word of "false", so it can be a program name with args.
 set dummy false; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1753: checking for $ac_word" >&5
+echo "configure:1764: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_FALSE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1781,7 +1792,7 @@ fi
 # Extract the first word of "true", so it can be a program name with args.
 set dummy true; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1785: checking for $ac_word" >&5
+echo "configure:1796: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_TRUE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1813,7 +1824,7 @@ fi
 # Extract the first word of "rm", so it can be a program name with args.
 set dummy rm; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1817: checking for $ac_word" >&5
+echo "configure:1828: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_RM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1845,7 +1856,7 @@ fi
 # Extract the first word of "mv", so it can be a program name with args.
 set dummy mv; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1849: checking for $ac_word" >&5
+echo "configure:1860: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MV'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1877,7 +1888,7 @@ fi
 # Extract the first word of "mkdir", so it can be a program name with args.
 set dummy mkdir; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1881: checking for $ac_word" >&5
+echo "configure:1892: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MKDIR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1909,7 +1920,7 @@ fi
 # Extract the first word of "ln", so it can be a program name with args.
 set dummy ln; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1913: checking for $ac_word" >&5
+echo "configure:1924: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LN'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1941,7 +1952,7 @@ fi
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1945: checking for $ac_word" >&5
+echo "configure:1956: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1973,7 +1984,7 @@ fi
 # Extract the first word of "makedepend", so it can be a program name with args.
 set dummy makedepend; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1977: checking for $ac_word" >&5
+echo "configure:1988: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPEND'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2005,7 +2016,7 @@ fi
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2009: checking for $ac_word" >&5
+echo "configure:2020: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2055,20 +2066,20 @@ for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:2059: checking for $ac_hdr that defines DIR" >&5
+echo "configure:2070: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2064 "configure"
+#line 2075 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
 int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2072: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2083: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -2093,15 +2104,15 @@ done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:2097: checking for opendir in -ldir" >&5
+echo "configure:2108: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2105 "configure"
+#line 2116 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2112,7 +2123,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:2116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2127: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2134,15 +2145,15 @@ fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:2138: checking for opendir in -lx" >&5
+echo "configure:2149: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2146 "configure"
+#line 2157 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2153,7 +2164,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:2157: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2176,20 +2187,20 @@ fi
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:2180: checking for ANSI C header files" >&5
+echo "configure:2191: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2185 "configure"
+#line 2196 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2193: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2204: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2206,7 +2217,7 @@ rm -f conftest*
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2210 "configure"
+#line 2221 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -2224,7 +2235,7 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2228 "configure"
+#line 2239 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -2245,7 +2256,7 @@ if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 2249 "configure"
+#line 2260 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -2256,7 +2267,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:2260: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2271: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -2344,17 +2355,17 @@ for ac_hdr in \
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2348: checking for $ac_hdr" >&5
+echo "configure:2359: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2353 "configure"
+#line 2364 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2358: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2369: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2382,12 +2393,12 @@ done
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:2386: checking for working const" >&5
+echo "configure:2397: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2391 "configure"
+#line 2402 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -2436,7 +2447,7 @@ ccp = (char const *const *) p;
 
 ; return 0; }
 EOF
-if { (eval echo configure:2440: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2451: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -2457,14 +2468,14 @@ EOF
 fi
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:2461: checking whether byte ordering is bigendian" >&5
+echo "configure:2472: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 2468 "configure"
+#line 2479 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2475,11 +2486,11 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2479: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2490: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 2483 "configure"
+#line 2494 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2490,7 +2501,7 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2494: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2505: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
@@ -2510,7 +2521,7 @@ if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2514 "configure"
+#line 2525 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
@@ -2523,7 +2534,7 @@ main () {
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:2527: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2538: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
@@ -2548,20 +2559,20 @@ fi
 
 
 echo $ac_n "checking if ANSI prototypes work""... $ac_c" 1>&6
-echo "configure:2552: checking if ANSI prototypes work" >&5
+echo "configure:2563: checking if ANSI prototypes work" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ansi_prototypes'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2558 "configure"
+#line 2569 "configure"
 #include "confdefs.h"
 int foo(char *); int foo (char *bar) {return 1;}
 int main() {
 foo("bar")
 ; return 0; }
 EOF
-if { (eval echo configure:2565: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2576: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ansi_prototypes="yes"
 else
@@ -2583,13 +2594,13 @@ EOF
 fi
 
 echo $ac_n "checking for tm->tm_gmtoff""... $ac_c" 1>&6
-echo "configure:2587: checking for tm->tm_gmtoff" >&5
+echo "configure:2598: checking for tm->tm_gmtoff" >&5
 if eval "test \"`echo '$''{'ac_cv_have_tm_gmoff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2593 "configure"
+#line 2604 "configure"
 #include "confdefs.h"
 #include <time.h>
 #include <sys/time.h>
@@ -2598,7 +2609,7 @@ struct tm foo;
       foo.tm_gmtoff = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2602: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2613: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_tm_gmoff="yes"
 else
@@ -2620,13 +2631,13 @@ EOF
 fi
 
 echo $ac_n "checking for struct mallinfo""... $ac_c" 1>&6
-echo "configure:2624: checking for struct mallinfo" >&5
+echo "configure:2635: checking for struct mallinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_have_struct_mallinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2630 "configure"
+#line 2641 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if HAVE_MALLOC_H
@@ -2644,7 +2655,7 @@ struct mallinfo foo;
     foo.keepcost = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2648: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2659: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_struct_mallinfo="yes"
 else
@@ -2666,13 +2677,13 @@ EOF
 fi
 
 echo $ac_n "checking for extended mallinfo""... $ac_c" 1>&6
-echo "configure:2670: checking for extended mallinfo" >&5
+echo "configure:2681: checking for extended mallinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ext_mallinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2676 "configure"
+#line 2687 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <malloc.h>
@@ -2681,7 +2692,7 @@ struct mallinfo foo;
       foo.mxfast = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2685: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2696: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ext_mallinfo="yes"
 else
@@ -2703,13 +2714,13 @@ EOF
 fi
 
 echo $ac_n "checking for struct rusage""... $ac_c" 1>&6
-echo "configure:2707: checking for struct rusage" >&5
+echo "configure:2718: checking for struct rusage" >&5
 if eval "test \"`echo '$''{'ac_cv_have_struct_rusage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2713 "configure"
+#line 2724 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TIME_H
@@ -2722,7 +2733,7 @@ int main() {
 struct rusage R;
 ; return 0; }
 EOF
-if { (eval echo configure:2726: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2737: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_struct_rusage="yes"
 else
@@ -2744,13 +2755,13 @@ EOF
 fi
 
 echo $ac_n "checking for ip->ip_hl""... $ac_c" 1>&6
-echo "configure:2748: checking for ip->ip_hl" >&5
+echo "configure:2759: checking for ip->ip_hl" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ip_hl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2754 "configure"
+#line 2765 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -2767,7 +2778,7 @@ struct iphdr ip;
       ip.ip_hl= 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2771: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2782: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ip_hl="yes"
 else
@@ -2789,15 +2800,15 @@ EOF
 fi
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:2793: checking size of int" >&5
+echo "configure:2804: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2801 "configure"
+#line 2812 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2808,7 +2819,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2812: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2823: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -2828,15 +2839,15 @@ EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:2832: checking size of long" >&5
+echo "configure:2843: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2840 "configure"
+#line 2851 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2847,7 +2858,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2851: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2862: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -2867,15 +2878,15 @@ EOF
 
 
 echo $ac_n "checking size of void *""... $ac_c" 1>&6
-echo "configure:2871: checking size of void *" >&5
+echo "configure:2882: checking size of void *" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2879 "configure"
+#line 2890 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2886,7 +2897,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2890: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_void_p=`cat conftestval`
 else
@@ -2909,19 +2920,19 @@ EOF
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:2913: checking for working alloca.h" >&5
+echo "configure:2924: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2918 "configure"
+#line 2929 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:2925: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2936: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -2942,12 +2953,12 @@ EOF
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:2946: checking for alloca" >&5
+echo "configure:2957: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2951 "configure"
+#line 2962 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -2970,7 +2981,7 @@ int main() {
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:2974: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -3002,12 +3013,12 @@ EOF
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:3006: checking whether alloca needs Cray hooks" >&5
+echo "configure:3017: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3011 "configure"
+#line 3022 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -3032,12 +3043,12 @@ echo "$ac_t""$ac_cv_os_cray" 1>&6
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3036: checking for $ac_func" >&5
+echo "configure:3047: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3041 "configure"
+#line 3052 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3060,7 +3071,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:3064: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3075: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3087,15 +3098,15 @@ done
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:3091: checking stack direction for C alloca" >&5
+echo "configure:3102: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3099 "configure"
+#line 3110 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -3114,7 +3125,7 @@ main ()
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:3118: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3129: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -3137,12 +3148,12 @@ fi
 
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:3141: checking for pid_t" >&5
+echo "configure:3152: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3146 "configure"
+#line 3157 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3170,12 +3181,12 @@ EOF
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:3174: checking for size_t" >&5
+echo "configure:3185: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3179 "configure"
+#line 3190 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3203,12 +3214,12 @@ EOF
 fi
 
 echo $ac_n "checking for ssize_t""... $ac_c" 1>&6
-echo "configure:3207: checking for ssize_t" >&5
+echo "configure:3218: checking for ssize_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ssize_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3212 "configure"
+#line 3223 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3236,12 +3247,12 @@ EOF
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:3240: checking for off_t" >&5
+echo "configure:3251: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3245 "configure"
+#line 3256 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3269,12 +3280,12 @@ EOF
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:3273: checking for mode_t" >&5
+echo "configure:3284: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3278 "configure"
+#line 3289 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3302,12 +3313,12 @@ EOF
 fi
 
 echo $ac_n "checking for fd_mask""... $ac_c" 1>&6
-echo "configure:3306: checking for fd_mask" >&5
+echo "configure:3317: checking for fd_mask" >&5
 if eval "test \"`echo '$''{'ac_cv_type_fd_mask'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3311 "configure"
+#line 3322 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3335,12 +3346,12 @@ EOF
 fi
 
 echo $ac_n "checking for mtyp_t""... $ac_c" 1>&6
-echo "configure:3339: checking for mtyp_t" >&5
+echo "configure:3350: checking for mtyp_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mtyp_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3344 "configure"
+#line 3355 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3369,13 +3380,13 @@ fi
 
 
 echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
-echo "configure:3373: checking for socklen_t" >&5
+echo "configure:3384: checking for socklen_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_socklen_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 3379 "configure"
+#line 3390 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -3406,22 +3417,22 @@ EOF
 fi
 
 echo $ac_n "checking for main in -lnsl""... $ac_c" 1>&6
-echo "configure:3410: checking for main in -lnsl" >&5
+echo "configure:3421: checking for main in -lnsl" >&5
 ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3418 "configure"
+#line 3429 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3425: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3436: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3449,22 +3460,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lsocket""... $ac_c" 1>&6
-echo "configure:3453: checking for main in -lsocket" >&5
+echo "configure:3464: checking for main in -lsocket" >&5
 ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3461 "configure"
+#line 3472 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3468: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3479: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3496,22 +3507,22 @@ if test "x$ac_cv_enabled_dlmalloc" = "xyes" ; then
   echo "skipping libmalloc check (--enable-dlmalloc specified)"
 else
   echo $ac_n "checking for main in -lgnumalloc""... $ac_c" 1>&6
-echo "configure:3500: checking for main in -lgnumalloc" >&5
+echo "configure:3511: checking for main in -lgnumalloc" >&5
 ac_lib_var=`echo gnumalloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lgnumalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3508 "configure"
+#line 3519 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3515: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3526: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3554,22 +3565,22 @@ fi
 			*)
   
 				echo $ac_n "checking for main in -lmalloc""... $ac_c" 1>&6
-echo "configure:3558: checking for main in -lmalloc" >&5
+echo "configure:3569: checking for main in -lmalloc" >&5
 ac_lib_var=`echo malloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3566 "configure"
+#line 3577 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3573: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3584: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3602,22 +3613,22 @@ fi
 fi
 
 echo $ac_n "checking for main in -lbsd""... $ac_c" 1>&6
-echo "configure:3606: checking for main in -lbsd" >&5
+echo "configure:3617: checking for main in -lbsd" >&5
 ac_lib_var=`echo bsd'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3614 "configure"
+#line 3625 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3621: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3632: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3645,22 +3656,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lregex""... $ac_c" 1>&6
-echo "configure:3649: checking for main in -lregex" >&5
+echo "configure:3660: checking for main in -lregex" >&5
 ac_lib_var=`echo regex'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lregex  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3657 "configure"
+#line 3668 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3675: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3681,15 +3692,15 @@ else
 fi
 
 echo $ac_n "checking for gethostbyname in -lbind""... $ac_c" 1>&6
-echo "configure:3685: checking for gethostbyname in -lbind" >&5
+echo "configure:3696: checking for gethostbyname in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3693 "configure"
+#line 3704 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3700,7 +3711,7 @@ int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:3704: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3715: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3734,15 +3745,15 @@ if test $ac_cv_lib_bind_gethostbyname = "no" ; then
 		;;
 	*)
 		echo $ac_n "checking for inet_aton in -lresolv""... $ac_c" 1>&6
-echo "configure:3738: checking for inet_aton in -lresolv" >&5
+echo "configure:3749: checking for inet_aton in -lresolv" >&5
 ac_lib_var=`echo resolv'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3746 "configure"
+#line 3757 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3753,7 +3764,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3757: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3768: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3769,15 +3780,15 @@ fi
 if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for inet_aton in -l44bsd""... $ac_c" 1>&6
-echo "configure:3773: checking for inet_aton in -l44bsd" >&5
+echo "configure:3784: checking for inet_aton in -l44bsd" >&5
 ac_lib_var=`echo 44bsd'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-l44bsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3781 "configure"
+#line 3792 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3788,7 +3799,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3792: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3803: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3820,22 +3831,22 @@ else
 fi
 
 		echo $ac_n "checking for main in -lresolv""... $ac_c" 1>&6
-echo "configure:3824: checking for main in -lresolv" >&5
+echo "configure:3835: checking for main in -lresolv" >&5
 ac_lib_var=`echo resolv'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3832 "configure"
+#line 3843 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3839: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3850: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3866,22 +3877,22 @@ fi
     esac
 fi
 echo $ac_n "checking for main in -lm""... $ac_c" 1>&6
-echo "configure:3870: checking for main in -lm" >&5
+echo "configure:3881: checking for main in -lm" >&5
 ac_lib_var=`echo m'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3878 "configure"
+#line 3889 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3885: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3896: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3910,15 +3921,15 @@ fi
 
 
 echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
-echo "configure:3914: checking for crypt in -lcrypt" >&5
+echo "configure:3925: checking for crypt in -lcrypt" >&5
 ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3922 "configure"
+#line 3933 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3929,7 +3940,7 @@ int main() {
 crypt()
 ; return 0; }
 EOF
-if { (eval echo configure:3933: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3944: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3962,22 +3973,22 @@ fi
 
 
 echo $ac_n "checking for main in -lpthread""... $ac_c" 1>&6
-echo "configure:3966: checking for main in -lpthread" >&5
+echo "configure:3977: checking for main in -lpthread" >&5
 ac_lib_var=`echo pthread'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lpthread  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3974 "configure"
+#line 3985 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3981: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3992: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4012,15 +4023,15 @@ fi
 case "$host" in
 	*-pc-sco3.2*)
 		echo $ac_n "checking for strftime in -lintl""... $ac_c" 1>&6
-echo "configure:4016: checking for strftime in -lintl" >&5
+echo "configure:4027: checking for strftime in -lintl" >&5
 ac_lib_var=`echo intl'_'strftime | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4024 "configure"
+#line 4035 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4031,7 +4042,7 @@ int main() {
 strftime()
 ; return 0; }
 EOF
-if { (eval echo configure:4035: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4046: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4193,12 +4204,12 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4197: checking for $ac_func" >&5
+echo "configure:4208: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4202 "configure"
+#line 4213 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4221,7 +4232,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4225: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4236: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4254,12 +4265,12 @@ if test "$async_io" = "yes" ; then
 	
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4258: checking for $ac_func" >&5
+echo "configure:4269: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4263 "configure"
+#line 4274 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4282,7 +4293,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4286: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4297: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4309,15 +4320,15 @@ done
 fi
 
 echo $ac_n "checking if setresuid is implemented""... $ac_c" 1>&6
-echo "configure:4313: checking if setresuid is implemented" >&5
+echo "configure:4324: checking if setresuid is implemented" >&5
 if eval "test \"`echo '$''{'ac_cv_func_setresuid'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 4321 "configure"
+#line 4332 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4330,7 +4341,7 @@ else
   }
   
 EOF
-if { (eval echo configure:4334: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4345: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_setresuid="yes"
 else
@@ -4355,7 +4366,7 @@ fi
 
 if test "$IPF_TRANSPARENT" ; then
     echo $ac_n "checking if IP-Filter header files are installed""... $ac_c" 1>&6
-echo "configure:4359: checking if IP-Filter header files are installed" >&5
+echo "configure:4370: checking if IP-Filter header files are installed" >&5
     if test "$ac_cv_header_ip_compat_h" = "yes" &&
        test "$ac_cv_header_ip_fil_h" = "yes" &&
        test "$ac_cv_header_ip_nat_h" = "yes" ; then
@@ -4398,21 +4409,21 @@ if test -z "$USE_GNUREGEX" ; then
     esac
 fi
 echo $ac_n "checking if GNUregex needs to be compiled""... $ac_c" 1>&6
-echo "configure:4402: checking if GNUregex needs to be compiled" >&5
+echo "configure:4413: checking if GNUregex needs to be compiled" >&5
 if test -z "$USE_GNUREGEX"; then
 if test "$ac_cv_func_regcomp" = "no" || test "$USE_GNUREGEX" = "yes" ; then
 	USE_GNUREGEX="yes"
 else
 	cat > conftest.$ac_ext <<EOF
-#line 4408 "configure"
+#line 4419 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <regex.h>
 int main() {
 regex_t t; regcomp(&t,"",0);
 ; return 0; }
 EOF
-if { (eval echo configure:4416: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4427: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   USE_GNUREGEX="no"
 else
@@ -4443,12 +4454,12 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4447: checking for $ac_func" >&5
+echo "configure:4458: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4452 "configure"
+#line 4463 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4471,7 +4482,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4475: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4486: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4499,12 +4510,12 @@ done
 
 
 echo $ac_n "checking Default FD_SETSIZE value""... $ac_c" 1>&6
-echo "configure:4503: checking Default FD_SETSIZE value" >&5
+echo "configure:4514: checking Default FD_SETSIZE value" >&5
 if test "$cross_compiling" = yes; then
   DEFAULT_FD_SETSIZE=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4508 "configure"
+#line 4519 "configure"
 #include "confdefs.h"
 
 #if HAVE_STDIO_H
@@ -4529,7 +4540,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4533: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4544: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   DEFAULT_FD_SETSIZE=`cat conftestval`
 else
@@ -4548,7 +4559,7 @@ EOF
 
 
 echo $ac_n "checking Maximum number of filedescriptors we can open""... $ac_c" 1>&6
-echo "configure:4552: checking Maximum number of filedescriptors we can open" >&5
+echo "configure:4563: checking Maximum number of filedescriptors we can open" >&5
 TLDFLAGS="$LDFLAGS"
 case $host in
 i386-unknown-freebsd*)
@@ -4560,7 +4571,7 @@ if test "$cross_compiling" = yes; then
   SQUID_MAXFD=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4564 "configure"
+#line 4575 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -4617,7 +4628,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4621: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4632: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_MAXFD=`cat conftestval`
 else
@@ -4644,12 +4655,12 @@ fi
 LDFLAGS="$TLDFLAGS"
 
 echo $ac_n "checking Default UDP send buffer size""... $ac_c" 1>&6
-echo "configure:4648: checking Default UDP send buffer size" >&5
+echo "configure:4659: checking Default UDP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4653 "configure"
+#line 4664 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4670,7 +4681,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4674: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4685: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_SNDBUF=`cat conftestval`
 else
@@ -4689,12 +4700,12 @@ EOF
 
 
 echo $ac_n "checking Default UDP receive buffer size""... $ac_c" 1>&6
-echo "configure:4693: checking Default UDP receive buffer size" >&5
+echo "configure:4704: checking Default UDP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4698 "configure"
+#line 4709 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4715,7 +4726,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4730: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_RCVBUF=`cat conftestval`
 else
@@ -4734,12 +4745,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP send buffer size""... $ac_c" 1>&6
-echo "configure:4738: checking Default TCP send buffer size" >&5
+echo "configure:4749: checking Default TCP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4743 "configure"
+#line 4754 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4760,7 +4771,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4764: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4775: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_SNDBUF=`cat conftestval`
 else
@@ -4779,12 +4790,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP receive buffer size""... $ac_c" 1>&6
-echo "configure:4783: checking Default TCP receive buffer size" >&5
+echo "configure:4794: checking Default TCP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4788 "configure"
+#line 4799 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4805,7 +4816,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4809: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4820: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_RCVBUF=`cat conftestval`
 else
@@ -4824,19 +4835,19 @@ EOF
 
 
 echo $ac_n "checking if sys_errlist is already defined""... $ac_c" 1>&6
-echo "configure:4828: checking if sys_errlist is already defined" >&5
+echo "configure:4839: checking if sys_errlist is already defined" >&5
 if eval "test \"`echo '$''{'ac_cv_needs_sys_errlist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4833 "configure"
+#line 4844 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 int main() {
 char *s = sys_errlist;
 ; return 0; }
 EOF
-if { (eval echo configure:4840: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4851: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_needs_sys_errlist="no"
 else
@@ -4858,16 +4869,16 @@ EOF
 fi
 
 echo $ac_n "checking for libresolv _dns_ttl_ hack""... $ac_c" 1>&6
-echo "configure:4862: checking for libresolv _dns_ttl_ hack" >&5
+echo "configure:4873: checking for libresolv _dns_ttl_ hack" >&5
 cat > conftest.$ac_ext <<EOF
-#line 4864 "configure"
+#line 4875 "configure"
 #include "confdefs.h"
 extern int _dns_ttl_;
 int main() {
 return _dns_ttl_;
 ; return 0; }
 EOF
-if { (eval echo configure:4871: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4882: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 cat >> confdefs.h <<\EOF
@@ -4883,12 +4894,12 @@ fi
 rm -f conftest*
 
 echo $ac_n "checking if inet_ntoa() actually works""... $ac_c" 1>&6
-echo "configure:4887: checking if inet_ntoa() actually works" >&5
+echo "configure:4898: checking if inet_ntoa() actually works" >&5
 if test "$cross_compiling" = yes; then
   INET_NTOA_RESULT="broken"
 else
   cat > conftest.$ac_ext <<EOF
-#line 4892 "configure"
+#line 4903 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4907,7 +4918,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4911: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4922: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   INET_NTOA_RESULT=`cat conftestval`
 else
@@ -4933,9 +4944,9 @@ fi
 
 if test "$ac_cv_header_sys_statvfs_h" = "yes" ; then
 echo $ac_n "checking for working statvfs() interface""... $ac_c" 1>&6
-echo "configure:4937: checking for working statvfs() interface" >&5
+echo "configure:4948: checking for working statvfs() interface" >&5
 cat > conftest.$ac_ext <<EOF
-#line 4939 "configure"
+#line 4950 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4952,7 +4963,7 @@ statvfs("/tmp", &sfs);
 
 ; return 0; }
 EOF
-if { (eval echo configure:4956: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4967: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_func_statvfs=yes
 else
@@ -4972,12 +4983,12 @@ fi
 fi
 
 echo $ac_n "checking for _res.nsaddr_list""... $ac_c" 1>&6
-echo "configure:4976: checking for _res.nsaddr_list" >&5
+echo "configure:4987: checking for _res.nsaddr_list" >&5
 if eval "test \"`echo '$''{'ac_cv_have_res_nsaddr_list'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4981 "configure"
+#line 4992 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H
@@ -5000,7 +5011,7 @@ int main() {
 _res.nsaddr_list[0];
 ; return 0; }
 EOF
-if { (eval echo configure:5004: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5015: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_res_nsaddr_list="yes"
 else
@@ -5022,12 +5033,12 @@ fi
 
 if test $ac_cv_have_res_nsaddr_list = "no" ; then
 echo $ac_n "checking for _res.ns_list""... $ac_c" 1>&6
-echo "configure:5026: checking for _res.ns_list" >&5
+echo "configure:5037: checking for _res.ns_list" >&5
 if eval "test \"`echo '$''{'ac_cv_have_res_ns_list'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5031 "configure"
+#line 5042 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TYPES_H
@@ -5050,7 +5061,7 @@ int main() {
 _res.ns_list[0].addr;
 ; return 0; }
 EOF
-if { (eval echo configure:5054: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5065: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_res_ns_list="yes"
 else
@@ -3,13 +3,13 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.181 1999/12/13 06:01:58 wessels Exp $
+dnl  $Id: configure.in,v 1.182 1999/12/30 17:35:50 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.181 $)dnl
+AC_REVISION($Revision: 1.182 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(cfgaux)
 
@@ -124,15 +124,6 @@ if test -z "$PRESET_LDFLAGS"; then
     fi
 fi
 
-if test "x$ac_cv_enabled_dlmalloc" = "x"; then
-    case "$host" in
-	i386-*-solaris2.*)
-		echo "Enabling dlmalloc for $host"
-		ac_cv_enabled_dlmalloc="yes"
-		;;
-    esac
-fi
-
 dnl Enable optional modules
 AC_ARG_ENABLE(dlmalloc,
 [  --enable-dlmalloc[=LIB] Compile & use the malloc package by Doug Lea],
@@ -513,7 +504,7 @@ AC_ARG_ENABLE(ident-lookups,
 ])
 
 AC_ARG_ENABLE(internal-dns,
-[  --disable-internal-dns This prevents Squid from directly sending and
+[  --disable-internal-dns  This prevents Squid from directly sending and
                           receiving DNS messages, and instead enables the
                           old external 'dnsserver' processes.],
 [ if test "$enableval" = "no" ; then
@@ -525,7 +516,7 @@ AC_ARG_ENABLE(internal-dns,
 ])
 
 AC_ARG_ENABLE(truncate,
-[  --enable-truncate      This uses truncate() instead of unlink() when
+[  --enable-truncate       This uses truncate() instead of unlink() when
                           removing cache files.  Truncate gives a little
                           performance improvement, but may cause problems
                           when used with async I/O.  Truncate uses more
@@ -550,12 +541,25 @@ AC_ARG_ENABLE(underscores,
   fi
 ])
 
+dnl Enable HEAP_REPLACEMENT
+AC_ARG_ENABLE(heap-replacement,
+[  --enable-heap-replacement
+                          This option allows you to use various cache
+                          replacement algorithms, instead of the standard
+                          LRU algorithm.
+                          ],
+[ if test "$enableval" = "yes" ; then
+    echo "Enabling HEAP_REPLACEMENT"
+    AC_DEFINE(HEAP_REPLACEMENT, 1)
+  fi
+])
+
 dnl Enable "diskd" code
 AC_ARG_ENABLE(diskd,
 [  --enable-diskd          Uses shared memory, message queues, and external
                           processes for disk I/O.],
 [ if test "$enableval" = "yes" ; then
-    echo "Enabling DISKD"
+    echo "DISKD enabled"
     AC_DEFINE(USE_DISKD, 1)
     OPT_DISKD_EXE='$(DISKD_EXE)'
     AC_SUBST(OPT_DISKD_EXE)
@@ -1641,4 +1641,97 @@ struct _storeSwapLogData {
 Note that <em/storeSwapLogData/ entries are written in native machine
 byte order.  They are not necessarily portable across architectures.
 
+<sect>Store ``swap meta'' Description
+<p>
+``swap meta'' refers to a section of meta data stored at the beginning
+of an object that is stored on disk.  This meta data includes information
+such as the object's cache key (MD5), URL, and part of the StoreEntry
+structure.
+
+<p>
+The meta data is stored using a TYPE-LENGTH-VALUE format.  That is,
+each chunk of meta information consists of a TYPE identifier, a
+LENGTH field, and then the VALUE (which is LENGTH octets long).
+
+<sect1>Types
+
+<p>
+As of Squid-2.3, the following TYPES are defined (from <em/enums.h/):
+<descrip>
+<tag/STORE_META_VOID/
+	Just a placeholder for the zeroth value.   It is never used
+	on disk.
+
+<tag/STORE_META_KEY_URL/
+	This represents the case when we use the URL as the cache
+	key, as Squid-1.1 does.  Currently we don't support using
+	a URL as a cache key, so this is not used.
+
+<tag/STORE_META_KEY_SHA/
+	For a brief time we considered supporting SHA (secure
+	hash algorithm) as a cache key.  Nobody liked it, and
+	this type is not currently used.
+
+<tag/STORE_META_KEY_MD5/
+	This represents the MD5 cache key that Squid currently uses.
+	When Squid opens a disk file for reading, it can check that
+	this MD5 matches the MD5 of the user's request.  If not, then
+	something went wrong and this is probably the wrong object.
+
+<tag/STORE_META_URL/
+	The object's URL.  This also may be matched against a user's
+	request for cache hits to make sure we got the right object.
+
+<tag/STORE_META_STD/
+	This is the ``standard metadata'' for an object.  Really
+	its just this middle chunk of the StoreEntry structure:
+<verb>
+	time_t timestamp;
+	time_t lastref;
+	time_t expires;
+	time_t lastmod;
+	size_t swap_file_sz;
+	u_short refcount;
+	u_short flags;
+</verb>
+
+<tag/STORE_META_HITMETERING/
+	Reserved for future hit-metering (RFC 2227) stuff.
+
+<tag/STORE_META_VALID/
+	?
+
+<tag/STORE_META_END/
+	Marks the last valid META type.
+
+</descrip>
+
+
+<sect1>Implementation Notes
+
+<p>
+When writing an object to disk, we must first write the meta data.
+This is done with a couple of functions.  First, <tt/storeSwapMetaPack()/
+takes a <em/StoreEntry/ as a parameter and returns a <em/tlv/ linked
+list.  Second, <tt/storeSwapMetaPack()/ converts the <em/tlv/ list
+into a character buffer that we can write.
+
+<p>
+Note that the <em/MemObject/ has a member called <em/swap_hdr_sz/.
+This value is the size of that character buffer; the size of the
+swap file meta data.  The <em/StoreEntry/ has a member named
+<em/swap_file_sz/ that represents the size of the disk file.
+Thus, the size of the object ``content'' is
+<verb>
+	StoreEntry->swap_file_sz  - MemObject->swap_hdr_sz;
+</verb>
+Note that the swap file content includes the HTTP reply headers
+and the HTTP reply body (if any).
+
+<p>
+When reading a swap file, there is a similar process to extract
+the swap meta data.  First, <tt/storeSwapMetaUnpack()/ converts a
+character buffer into a <em/tlv/ linked list.  It also tells us
+the value for <em/MemObject->swap_hdr_sz/.
+
 </article>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:       </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:    </TITLE>
 </HEAD>
 <BODY>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:     </TITLE>
 </HEAD>
 <BODY>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,17 +1,17 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
+<TITLE>:        </TITLE>
 </HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<H1></H1>
+<H2>        </H2>
 <HR>
 <P>
-An FTP authentication failure occurred
-while trying to retrieve the URL:
+      FTP     URL:
 <A HREF="%U">%U</A>
 <P>
-Squid sent the following FTP command:
+    FTP :
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-and then received this reply
+   
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 </P>
@@ -1,21 +1,25 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
+<TITLE>:        </TITLE>
 </HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<H1></H1>
+<H2>        </H2>
 <HR>
 <P>
-The following URL could not be retrieved:
+      :
 <A HREF="%U">%U</A>
 <P>
-Squid sent the following FTP command:
+    FTP :
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-and then received this reply
+   
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 <P>
-This might be caused by an FTP URL with an absolute path (which does
-not comply with RFC 1738).  If this is the cause, then the file
-can be found at <A HREF="%B">%B</A>.
+<PRE>
+          ,    
+     (     RFC 1738).
+      ,        
+    <A HREF="%B">%B</A>.
+</PRE>
 </P>
 
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>FTP PUT  :  </TITLE>
 </HEAD><BODY>
 <H1> </H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:  FTP  </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE> FTP PUT :  </TITLE>
 </HEAD><BODY>
 <H1> </H1>
@@ -1,16 +1,17 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
+<TITLE>:        </TITLE>
 </HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<H1></H1>
+<H2>        </H2>
 <HR>
 <P>
-The FTP server was too busy while trying to retrieve the URL:
+FTP     
 <A HREF="%U">%U</A>
 <P>
-Squid sent the following FTP command:
+    FTP :
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-and then received this reply
+   
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 </P>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,17 +1,17 @@
 <HTML><HEAD>
-<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
+<TITLE>:        </TITLE>
 </HEAD><BODY>
-<H1>ERROR</H1>
-<H2>The requested URL could not be retrieved</H2>
+<H1></H1>
+<H2>        </H2>
 <HR>
 <P>
-While trying to retrieve the URL:
+     URL-a:
 <A HREF="%U">%U</A>
 <P>
-The following error was encountered:
+  :
 <UL>
 <P>
-This cache is in the process of shutting down and can not
-service your request at this time.  Please retry your
-request again soon.
+               . 
+     .
 </P>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE> :        </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -1,2 +1,3 @@
-Thank you to Evgeny Gechev <etg@setcom.bg> for
+Thank you to Evgeny Gechev <etg@setcom.bg> and 
+Svetlin Simeonov <simeonov@netplusdb.bg> for
 creating these error pages in Bulgarian!
@@ -1,4 +1,5 @@
 <HTML><HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <TITLE>:       </TITLE>
 </HEAD><BODY>
 <H1></H1>
@@ -10,12 +10,12 @@ FTP protokoll hiba t
 <P>
 A Squid az albbi FTP parancsot kldte:
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-s ezt a vlaszt kapta:
+s ezt a vlaszt kapta
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 <P>
 A hibt lehet hogy az okozta, hogy az FTP URL abszolt elrsi utat tartalmaz
-(ami nem felel meg az RFC 1738 elrsnak). Amennyiben az a hiba oka, akkor a
+(ami nem felel meg az RFC 1738 elrsnak). Amennyiben ez a hiba oka, akkor
 az llomnyt a <A HREF="%B">%B</A> cmen lehet megtallni.
 </P>
 
@@ -1,17 +1,19 @@
 <HTML><HEAD>
 <TITLE>HIBA: A krt URL nem tlthet le</TITLE>
-<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2"></HEAD>
-<BODY>
+<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
+</HEAD><BODY>
 <H1>HIBA</H1>
 <H2>A krt URL nem tlthet le</H2>
 <HR>
 <P>
-FTP autentikcis hiba trtnt az albbi URL letltsekor:
+FTP autentikcis hiba trtnt
+az albbi URL letltsekor:
 <A HREF="%U">%U</A>
 <P>
 A Squid az albbi FTP parancsot kldte:
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-s a kvetkez vlaszt kapta:
+s ezt a vlaszt kapta
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 </P>
+
@@ -1,19 +1,22 @@
 <HTML><HEAD>
 <TITLE>HIBA: A krt URL nem tlthet le</TITLE>
-<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2"></HEAD>
-<BODY>
+<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
+</HEAD><BODY>
 <H1>HIBA</H1>
 <H2>A krt URL nem tlthet le</H2>
 <HR>
 <P>
-A krt URL nem tlthet le:
+Az albbi URL nem tlthet le:
 <A HREF="%U">%U</A>
 <P>
 A Squid az albbi FTP parancsot kldte:
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-s ezt a vlaszt kapta:
+s ezt a vlaszt kapta
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 <P>
-A hibt lehet hogy az okozta, hogy az FTP URL abszolt elrsi utat tartalmaz (ami nem felel meg az RFC 1738 elrsnak). Amennyiben ez a hiba oka, akkor az llomnyt a <A HREF="%B">%B</A> cmen lehet megtallni.
+A hibt lehet hogy az okozta, hogy az FTP URL abszolt elrsi utat tartalmaz
+(ami nem felel meg az RFC 1738 elrsnak). Amennyiben ez a hiba oka, akkor 
+az llomnyt a <A HREF="%B">%B</A> cmen lehet megtallni.
 </P>
+
@@ -1,17 +1,18 @@
 <HTML><HEAD>
 <TITLE>HIBA: A krt URL nem tlthet le</TITLE>
-<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2"></HEAD>
-<BODY>
+<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
+</HEAD><BODY>
 <H1>HIBA</H1>
 <H2>A krt URL nem tlthet le</H2>
 <HR>
 <P>
 Az FTP kiszolgl tlterheltsge miatt az albbi URL nem tlthet le:
 <A HREF="%U">%U</A>
 <P>
-A Squid az albbi FTP parancsot kldte:
+A Squid az albbi parancsot kldte:
 <blockquote><strong><pre>%f</pre></strong></blockquote>
-s ezt a vlaszt kapta:
+s ezt a vlaszt kapta
 <blockquote><strong><pre>%F</pre></strong></blockquote>
 <blockquote><strong><pre>%g</pre></strong></blockquote>
 </P>
+
@@ -275,6 +275,11 @@
  */
 #undef ALLOW_HOSTNAME_UNDERSCORES
 
+/*
+ * Use the heap-based replacement techniques
+ */
+#undef HEAP_REPLACEMENT
+
 /*
  * Use DISKD
  */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: heap.c,v 1.4 1999/10/04 05:04:50 wessels Exp $
+ * $Id: heap.c,v 1.5 1999/12/30 17:36:14 wessels Exp $
  *
  * AUTHOR: John Dilley, Hewlett Packard
  *
@@ -53,6 +53,7 @@
 #endif
 
 #include "heap.h"
+#include "util.h"
 
 /*
  * Hacks for non-synchronized heap implementation.
@@ -95,12 +96,12 @@ void _heap_print_tree(heap * hp, heap_node * node);
 heap *
 new_heap(int initSize, heap_key_func gen_key)
 {
-    heap *hp = malloc(sizeof(*hp));
+    heap *hp = xmalloc(sizeof(*hp));
     assert(hp != NULL);
 
     if (initSize <= 0)
 	initSize = MinSize;
-    hp->nodes = calloc(initSize, sizeof(heap_node *));
+    hp->nodes = xcalloc(initSize, sizeof(heap_node *));
     assert(hp->nodes != NULL);
 
     hp->size = initSize;
@@ -122,25 +123,26 @@ delete_heap(heap * hp)
     int i;
     assert(hp);
     for (i = 0; i < hp->last; i++) {
-	free(hp->nodes[i]);
+	xfree(hp->nodes[i]);
     }
-    free(hp->nodes);
-    free(hp);
+    xfree(hp->nodes);
+    xfree(hp);
 }
 
 /*
- * Insert DAT based on KY into HP maintaining the heap property.  Return the
- * newly inserted heap node. The fields of ELM other than ID are never
- * changed until ELM is deleted from HP, i.e. caller can assume that the
- * heap node always exist at the same place in memory unless heap_delete or
- * heap_extractmin is called on that node.  This function exposes the heap's
- * internal data structure to the caller.  This is required in order to do
- * O(lgN) deletion.
+ * Insert DAT based on KY into HP maintaining the heap property.
+ * Return the newly inserted heap node. The fields of ELM other
+ * than ID are never changed until ELM is deleted from HP, i.e.
+ * caller can assume that the heap node always exist at the same
+ * place in memory unless heap_delete or heap_extractmin is called
+ * on that node.  This function exposes the heap's internal data
+ * structure to the caller.  This is required in order to do O(lgN)
+ * deletion.
  */
 heap_node *
 heap_insert(heap * hp, void *dat)
 {
-    heap_node *elm = (heap_node *) malloc(sizeof(heap_node));
+    heap_node *elm = xmalloc(sizeof(*elm));
 
     elm->key = heap_gen_key(hp, dat);
     elm->data = dat;
@@ -175,7 +177,13 @@ heap_delete(heap * hp, heap_node * elm)
     _heap_swap_element(hp, lastNode, elm);
     heap_extractlast(hp);
 
-    if (hp->last > 0) {
+    if (elm == lastNode) {
+	/*
+	 * lastNode just got freed, so don't access it in the next
+	 * block.
+	 */
+	(void) 0;
+    } else if (hp->last > 0) {
 	if (lastNode->key < hp->nodes[Parent(lastNode->id)]->key)
 	    _heap_ify_up(hp, lastNode);		/* COOL! */
 	_heap_ify_down(hp, lastNode);
@@ -234,7 +242,7 @@ heap_extractlast(heap * hp)
     assert(_heap_node_exist(hp, hp->last - 1));
     hp->last -= 1;
     data = hp->nodes[hp->last]->data;
-    free(hp->nodes[hp->last]);
+    xfree(hp->nodes[hp->last]);
     return data;
 }
 
@@ -445,11 +453,11 @@ _heap_grow(heap * hp)
     else
 	newSize = hp->size * NormalRate;
 
-    hp->nodes = (heap_node * *)realloc(hp->nodes, newSize * sizeof(heap_node *));
+    hp->nodes = xrealloc(hp->nodes, newSize * sizeof(heap_node *));
 #if COMMENTED_OUT
     for (i = 0; i < hp->size; i++)
 	newNodes[i] = hp->nodes[i];
-    free(hp->nodes);
+    xfree(hp->nodes);
     hp->nodes = newNodes;
 #endif
     hp->size = newSize;
@@ -558,7 +566,7 @@ calc_heap_skew(heap * heap, int replace)
     /* 
      * Copy the heap nodes to a new storage area for offline sorting.
      */
-    nodes = (heap_node **) malloc(max * sizeof(heap_node *));
+    nodes = xmalloc(max * sizeof(heap_node *));
     memcpy(nodes, heap->nodes, max * sizeof(heap_node *));
 
     if (replace == 0) {
@@ -612,7 +620,7 @@ calc_heap_skew(heap * heap, int replace)
     /* 
      * Free the nodes array; note this is just an array of pointers, not data!
      */
-    free(nodes);
+    xfree(nodes);
     return norm;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: rfc1035.c,v 1.10 1999/10/04 05:04:51 wessels Exp $
+ * $Id: rfc1035.c,v 1.11 1999/12/30 17:36:15 wessels Exp $
  *
  * Low level DNS protocol routines
  * AUTHOR: Duane Wessels
@@ -424,14 +424,7 @@ rfc1035AnswersUnpack(const char *buf,
 	    }
 	} while (l > 0);	/* a zero-length label terminates */
 	off += 4;		/* qtype, qclass */
-	if (off > sz) {
-	    /*
-	     * This used be an assertion and it triggered once, but the
-	     * core file was useless for debugging.   Sigh, I guess we
-	     * need a debug_hook.
-	     */
-	    return 0;
-	}
+	assert (off <= sz);
     }
     i = (int) hdr.ancount;
     if (i == 0)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrCc.cc,v 1.18 1999/10/04 05:04:53 wessels Exp $
+ * $Id: HttpHdrCc.cc,v 1.19 1999/12/30 17:36:16 wessels Exp $
  *
  * DEBUG: section 65    HTTP Cache Control Header
  * AUTHOR: Alex Rousskov
@@ -47,6 +47,7 @@ static const HttpHeaderFieldAttrs CcAttrs[CC_ENUM_END] =
     {"proxy-revalidate", CC_PROXY_REVALIDATE},
     {"only-if-cached", CC_ONLY_IF_CACHED},
     {"max-age", CC_MAX_AGE},
+    {"s-maxage", CC_S_MAXAGE},
     {"Other,", CC_OTHER}	/* ',' will protect from matches */
 };
 HttpHeaderFieldInfo *CcFieldsInfo = NULL;
@@ -76,7 +77,7 @@ HttpHdrCc *
 httpHdrCcCreate(void)
 {
     HttpHdrCc *cc = memAllocate(MEM_HTTP_HDR_CC);
-    cc->max_age = -1;
+    cc->max_age = cc->s_maxage = -1;
     return cc;
 }
 
@@ -132,6 +133,13 @@ httpHdrCcParseInit(HttpHdrCc * cc, const String * str)
 		EBIT_CLR(cc->mask, type);
 	    }
 	    break;
+	case CC_S_MAXAGE:
+	    if (!p || !httpHeaderParseInt(p, &cc->s_maxage)) {
+		debug(65, 2) ("cc: invalid s-maxage specs near '%s'\n", item);
+		cc->s_maxage = -1;
+		EBIT_CLR(cc->mask, type);
+	    }
+	    break;
 	default:
 	    /* note that we ignore most of '=' specs */
 	    break;
@@ -155,6 +163,7 @@ httpHdrCcDup(const HttpHdrCc * cc)
     dup = httpHdrCcCreate();
     dup->mask = cc->mask;
     dup->max_age = cc->max_age;
+    dup->s_maxage = cc->s_maxage;
     return dup;
 }
 
@@ -174,6 +183,9 @@ httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p)
 	    if (flag == CC_MAX_AGE)
 		packerPrintf(p, "=%d", (int) cc->max_age);
 
+	    if (flag == CC_S_MAXAGE)
+		packerPrintf(p, "=%d", (int) cc->s_maxage);
+
 	    pcount++;
 	}
     }
@@ -185,6 +197,8 @@ httpHdrCcJoinWith(HttpHdrCc * cc, const HttpHdrCc * new_cc)
     assert(cc && new_cc);
     if (cc->max_age < 0)
 	cc->max_age = new_cc->max_age;
+    if (cc->s_maxage < 0)
+	cc->s_maxage = new_cc->s_maxage;
     cc->mask |= new_cc->mask;
 }
 
@@ -200,6 +214,18 @@ httpHdrCcSetMaxAge(HttpHdrCc * cc, int max_age)
 	EBIT_CLR(cc->mask, CC_MAX_AGE);
 }
 
+/* negative s_maxage will clean old s-maxage setting */
+void
+httpHdrCcSetSMaxAge(HttpHdrCc * cc, int s_maxage)
+{
+    assert(cc);
+    cc->s_maxage = s_maxage;
+    if (s_maxage >= 0)
+	EBIT_SET(cc->mask, CC_S_MAXAGE);
+    else
+	EBIT_CLR(cc->mask, CC_S_MAXAGE);
+}
+
 void
 httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.64 1999/10/04 05:04:55 wessels Exp $
+ * $Id: HttpHeader.cc,v 1.65 1999/12/30 17:36:17 wessels Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -384,22 +384,18 @@ httpHeaderParse(HttpHeader * hdr, const char *header_start, const char *header_e
     HttpHeaderStats[hdr->owner].parsedCount++;
     /* commonn format headers are "<name>:[ws]<value>" lines delimited by <CRLF> */
     while (field_start < header_end) {
-	const char *field_end = field_start;
+	const char *field_end;
+	const char *field_ptr = field_start;
 	do {
-	    field_end = field_end + strcspn(field_end, "\r\n");
+	    field_end = field_ptr = field_ptr + strcspn(field_ptr, "\r\n");
 	    /* skip CRLF */
-	    if (*field_end == '\r')
-		field_end++;
-	    if (*field_end == '\n')
-		field_end++;
-	} while (*field_end == ' ' || *field_end == '\t');
+	    if (*field_ptr == '\r')
+		field_ptr++;
+	    if (*field_ptr == '\n')
+		field_ptr++;
+	} while (*field_ptr == ' ' || *field_ptr == '\t');
 	if (!*field_end || field_end > header_end)
 	    return httpHeaderReset(hdr);	/* missing <CRLF> */
-	/* back up over CRLF */
-	if (field_end > field_start && field_end[-1] == '\n')
-	    field_end--;
-	if (field_end > field_start && field_end[-1] == '\r')
-	    field_end--;
 	e = httpHeaderEntryParseCreate(field_start, field_end);
 	if (e != NULL)
 	    httpHeaderAddEntry(hdr, e);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpReply.cc,v 1.38 1999/10/04 05:04:57 wessels Exp $
+ * $Id: HttpReply.cc,v 1.39 1999/12/30 17:36:17 wessels Exp $
  *
  * DEBUG: section 58    HTTP Reply (Response)
  * AUTHOR: Alex Rousskov
@@ -311,8 +311,10 @@ httpReplyHdrCacheInit(HttpReply * rep)
     rep->content_range = httpHeaderGetContRange(hdr);
     rep->keep_alive = httpMsgIsPersistent(rep->sline.version, &rep->header);
     /* final adjustments */
-    /* The max-age directive takes priority over Expires, check it first */
-    if (rep->cache_control && rep->cache_control->max_age >= 0)
+    /* The s-maxage and max-age directive takes priority over Expires */
+    if (rep->cache_control && rep->cache_control->s_maxage >= 0)
+	rep->expires = squid_curtime + rep->cache_control->s_maxage;
+    else if (rep->cache_control && rep->cache_control->max_age >= 0)
 	rep->expires = squid_curtime + rep->cache_control->max_age;
     else
 	/*
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpRequest.cc,v 1.24 1999/10/04 05:04:57 wessels Exp $
+ * $Id: HttpRequest.cc,v 1.25 1999/12/30 17:36:18 wessels Exp $
  *
  * DEBUG: section 73    HTTP Request
  * AUTHOR: Duane Wessels
@@ -45,6 +45,8 @@ requestCreate(method_t method, protocol_t protocol, const char *urlpath)
 	stringReset(&req->urlpath, urlpath);
     req->max_forwards = -1;
     req->lastmod = -1;
+    req->client_addr = no_addr;
+    req->my_addr = no_addr;
     httpHeaderInit(&req->header, hoRequest);
     return req;
 }
@@ -152,3 +154,13 @@ httpRequestHdrAllowed(const HttpHeaderEntry * e, String * strConn)
 	return 0;
     return 1;
 }
+
+/* returns true if header is allowed to be passed on */
+int
+httpRequestHdrAllowedByName(http_hdr_type id)
+{
+    /* check with anonymizer tables */
+    if (CBIT_TEST(Config.anonymize_headers, id))
+	return 0;
+    return 1;
+}
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.180 1999/12/10 18:13:50 wessels Exp $
+#  $Id: Makefile.in,v 1.181 1999/12/30 17:36:19 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -375,6 +375,7 @@ clean:
 
 distclean:	clean
 	-rm -f Makefile squid.conf squid.conf.pre
+	-rm -f Makefile.bak
 
 tags:
 	ctags *.[ch] ../include/*.h ../lib/*.[ch]
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: access_log.cc,v 1.52 1999/08/02 06:18:26 wessels Exp $
+ * $Id: access_log.cc,v 1.53 1999/12/30 17:36:19 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -135,28 +135,44 @@ log_quote(const char *header)
      * more readable.
      */
     while ((c = *(const unsigned char *) header++) != '\0') {
-	if (c <= 0x1F
-	    || c >= 0x7F
-	    || c == '"'
-	    || c == '#'
-	    || c == '%'
-	    || c == ';'
-	    || c == '<'
-	    || c == '>'
-	    || c == '?'
-	    || c == '{'
-	    || c == '}'
-	    || c == '|'
-	    || c == '\\'
-	    || c == '^'
-	    || c == '~'
-	    || c == '`'
-	    || c == '['
+#if !OLD_LOG_MIME
+	if (c == '\r') {
+	    *buf_cursor++ = '\\';
+	    *buf_cursor++ = 'r';
+	} else if (c == '\n') {
+	    *buf_cursor++ = '\\';
+	    *buf_cursor++ = 'n';
+	} else
+#endif
+	    if (c <= 0x1F
+		|| c >= 0x7F
+#if OLD_LOG_MIME
+		|| c == '"'
+		|| c == '#'
+		|| c == '%'
+		|| c == ';'
+		|| c == '<'
+		|| c == '>'
+		|| c == '?'
+		|| c == '{'
+		|| c == '}'
+		|| c == '|'
+		|| c == '\\'
+		|| c == '^'
+		|| c == '~'
+		|| c == '`'
+#endif
+		|| c == '['
 	    || c == ']') {
 	    *buf_cursor++ = '%';
 	    i = c * 2;
 	    *buf_cursor++ = c2x[i];
 	    *buf_cursor++ = c2x[i + 1];
+#if !OLD_LOG_MIME
+	} else if (c == '\\') {
+	    *buf_cursor++ = '\\';
+	    *buf_cursor++ = '\\';
+#endif
 	} else {
 	    *buf_cursor++ = (char) c;
 	}
@@ -371,7 +387,7 @@ accessLogInit(void)
 	    fatal("Cannot open Multicast Miss Stream Socket");
 	debug(46, 1) ("Multicast Miss Stream Socket opened on FD %d\n",
 	    mcast_miss_fd);
-	mcastSetTtl(mcast_miss_fd, 128);
+	mcastSetTtl(mcast_miss_fd, Config.mcast_miss.ttl);
 	if (strlen(Config.mcast_miss.encode_key) < 16)
 	    fatal("mcast_encode_key is too short, must be 16 characters");
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.208 1999/10/04 05:04:59 wessels Exp $
+ * $Id: acl.cc,v 1.209 1999/12/30 17:36:20 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -175,6 +175,8 @@ aclStrToType(const char *s)
 	return ACL_URL_REGEX;
     if (!strcmp(s, "port"))
 	return ACL_URL_PORT;
+    if (!strcmp(s, "myport"))
+	return ACL_MY_PORT;
     if (!strcmp(s, "maxconn"))
 	return ACL_MAXCONN;
 #if USE_IDENT
@@ -231,6 +233,8 @@ aclTypeToStr(squid_acl type)
 	return "url_regex";
     if (type == ACL_URL_PORT)
 	return "port";
+    if (type == ACL_MY_PORT)
+	return "myport";
     if (type == ACL_MAXCONN)
 	return "maxconn";
 #if USE_IDENT
@@ -709,6 +713,7 @@ aclParseAclLine(acl ** head)
 	aclParseIntlist(&A->data);
 	break;
     case ACL_URL_PORT:
+    case ACL_MY_PORT:
 	aclParseIntRange(&A->data);
 	break;
 #if USE_IDENT
@@ -998,20 +1003,27 @@ aclDecodeProxyAuth(const char *proxy_auth, char **user, char **password, char *b
 {
     char *sent_auth;
     char *cleartext;
-    debug(28, 6) ("aclDecodeProxyAuth: header = '%s'\n", proxy_auth);
     if (proxy_auth == NULL)
 	return 0;
-    if (strlen(proxy_auth) < SKIP_BASIC_SZ)
+    debug(28, 6) ("aclDecodeProxyAuth: header = '%s'\n", proxy_auth);
+    if (strncasecmp(proxy_auth, "Basic ", 6) != 0) {
+	debug(28, 1) ("aclDecodeProxyAuth: Unsupported proxy-auth sheme, '%s'\n", proxy_auth);
 	return 0;
-    proxy_auth += SKIP_BASIC_SZ;
-    sent_auth = xstrdup(proxy_auth);	/* username and password */
-    /* Trim trailing \n before decoding */
-    strtok(sent_auth, "\n");
+    }
+    proxy_auth += 6;		/* "Basic " */
     /* Trim leading whitespace before decoding */
     while (xisspace(*proxy_auth))
 	proxy_auth++;
+    sent_auth = xstrdup(proxy_auth);	/* username and password */
+    /* Trim trailing \n before decoding */
+    strtok(sent_auth, "\n");
     cleartext = uudecode(sent_auth);
     xfree(sent_auth);
+    /*
+     * Don't allow NL or CR in the credentials.
+     * Oezguer Kesim <oec@codeblau.de>
+     */
+    strtok(cleartext, "\r\n");
     debug(28, 6) ("aclDecodeProxyAuth: cleartext = '%s'\n", cleartext);
     xstrncpy(buf, cleartext, bufsize);
     xfree(cleartext);
@@ -1364,7 +1376,10 @@ aclMatchAcl(acl * ae, aclCheck_t * checklist)
 	return ((k > ((intlist *) ae->data)->i) ? 0 : 1);
 	/* NOTREACHED */
     case ACL_URL_PORT:
-	return aclMatchIntegerRange(ae->data, r->port);
+	return aclMatchIntegerRange(ae->data, (int) r->port);
+	/* NOTREACHED */
+    case ACL_MY_PORT:
+	return aclMatchIntegerRange(ae->data, (int) checklist->my_port);
 	/* NOTREACHED */
 #if USE_IDENT
     case ACL_IDENT:
@@ -1709,8 +1724,6 @@ aclLookupProxyAuthDone(void *data, char *result)
 aclCheck_t *
 aclChecklistCreate(const acl_access * A,
     request_t * request,
-    struct in_addr src_addr,
-    struct in_addr my_addr,
     const char *user_agent,
     const char *ident)
 {
@@ -1723,10 +1736,12 @@ aclChecklistCreate(const acl_access * A,
      * pointer, so lock it.
      */
     cbdataLock(A);
-    if (request != NULL)
+    if (request != NULL) {
 	checklist->request = requestLink(request);
-    checklist->src_addr = src_addr;
-    checklist->my_addr = my_addr;
+	checklist->src_addr = request->client_addr;
+	checklist->my_addr = request->my_addr;
+	checklist->my_port = request->my_port;
+    }
     for (i = 0; i < ACL_ENUM_MAX; i++)
 	checklist->state[i] = ACL_LOOKUP_NONE;
     if (user_agent)
@@ -1842,6 +1857,7 @@ aclDestroyAcls(acl ** head)
 	    intlistDestroy((intlist **) & a->data);
 	    break;
 	case ACL_URL_PORT:
+	case ACL_MY_PORT:
 	    aclDestroyIntRange(a->data);
 	    break;
 	case ACL_NONE:
@@ -1963,7 +1979,7 @@ aclHostDomainCompare(const void *a, const void *b)
 {
     const char *h = a;
     const char *d = b;
-    return matchDomainName(d, h);
+    return matchDomainName(h, d);
 }
 
 /* compare two network specs
@@ -2170,6 +2186,7 @@ aclDumpGeneric(const acl * a)
 	return aclDumpIntlistList(a->data);
 	break;
     case ACL_URL_PORT:
+    case ACL_MY_PORT:
 	return aclDumpIntRangeList(a->data);
 	break;
     case ACL_PROTO:
@@ -2299,27 +2316,122 @@ aclMatchArp(void *dataptr, struct in_addr c)
 {
     struct arpreq arpReq;
     struct sockaddr_in ipAddr;
+    unsigned char ifbuffer[sizeof(struct ifreq) * 64];
+    struct ifconf ifc;
+    struct ifreq *ifr;
+    int offset;
     splayNode **Top = dataptr;
+    /*
+     * The linux kernel 2.2 maintains per interface ARP caches and
+     * thus requires an interface name when doing ARP queries.
+     * 
+     * The older 2.0 kernels appear to use a unified ARP cache,
+     * and require an empty interface name
+     * 
+     * To support both, we attempt the lookup with a blank interface
+     * name first. If that does not succeed, the try each interface
+     * in turn
+     */
+    /*
+     * Set up structures for ARP lookup with blank interface name
+     */
     ipAddr.sin_family = AF_INET;
     ipAddr.sin_port = 0;
     ipAddr.sin_addr = c;
+    memset(&arpReq, '\0', sizeof(arpReq));
     memcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
-    arpReq.arp_dev[0] = '\0';
-    arpReq.arp_flags = 0;
-    /* any AF_INET socket will do... gives back hardware type, device, etc */
-    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) == -1) {
-	debug(28, 1) ("ARP query failed - %d", errno);
+    /* Query ARP table */
+    if (ioctl(HttpSockets[0], SIOCGARP, &arpReq) != -1) {
+	/* Skip non-ethernet interfaces */
+	if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
+	    return 0;
+	}
+	debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	    arpReq.arp_ha.sa_data[0] & 0xff, arpReq.arp_ha.sa_data[1] & 0xff,
+	    arpReq.arp_ha.sa_data[2] & 0xff, arpReq.arp_ha.sa_data[3] & 0xff,
+	    arpReq.arp_ha.sa_data[4] & 0xff, arpReq.arp_ha.sa_data[5] & 0xff);
+	/* Do lookup */
+	*Top = splay_splay(&arpReq.arp_ha.sa_data, *Top, aclArpCompare);
+	debug(28, 3) ("aclMatchArp: '%s' %s\n",
+	    inet_ntoa(c), splayLastResult ? "NOT found" : "found");
+	return (0 == splayLastResult);
+    }
+    /* lookup list of interface names */
+    ifc.ifc_len = sizeof(ifbuffer);
+    ifc.ifc_buf = ifbuffer;
+    if (ioctl(HttpSockets[0], SIOCGIFCONF, &ifc) < 0) {
+	debug(28, 1) ("Attempt to retrieve interface list failed: %s\n",
+	    xstrerror());
 	return 0;
-    } else if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
-	debug(28, 1) ("Non-ethernet interface returned from ARP query - %d",
-	    arpReq.arp_ha.sa_family);
-	/* update here and MAC address parsing to handle non-ethernet */
+    }
+    if (ifc.ifc_len > sizeof(ifbuffer)) {
+	debug(28, 1) ("Interface list too long - %d\n", ifc.ifc_len);
 	return 0;
-    } else
+    }
+    /* Attempt ARP lookup on each interface */
+    offset = 0;
+    while (offset < ifc.ifc_len) {
+	ifr = (struct ifreq *) (ifbuffer + offset);
+	offset += sizeof(*ifr);
+	/* Skip loopback and aliased interfaces */
+	if (0 == strncmp(ifr->ifr_name, "lo", 2))
+	    continue;
+	if (NULL != strchr(ifr->ifr_name, ':'))
+	    continue;
+	debug(28, 4) ("Looking up ARP address for %s on %s\n", inet_ntoa(c),
+	    ifr->ifr_name);
+	/* Set up structures for ARP lookup */
+	ipAddr.sin_family = AF_INET;
+	ipAddr.sin_port = 0;
+	ipAddr.sin_addr = c;
+	memset(&arpReq, '\0', sizeof(arpReq));
+	memcpy(&arpReq.arp_pa, &ipAddr, sizeof(struct sockaddr_in));
+	strncpy(arpReq.arp_dev, ifr->ifr_name, sizeof(arpReq.arp_dev) - 1);
+	arpReq.arp_dev[sizeof(arpReq.arp_dev) - 1] = '\0';
+	/* Query ARP table */
+	if (-1 == ioctl(HttpSockets[0], SIOCGARP, &arpReq)) {
+	    /*
+	     * Query failed.  Do not log failed lookups or "device
+	     * not supported"
+	     */
+	    if (ENXIO == errno)
+		(void) 0;
+	    else if (ENODEV == errno)
+		(void) 0;
+	    else
+		debug(28, 1) ("ARP query failed: %s: %s\n",
+		    ifr->ifr_name, xstrerror());
+	    continue;
+	}
+	/* Skip non-ethernet interfaces */
+	if (arpReq.arp_ha.sa_family != ARPHRD_ETHER)
+	    continue;
+	debug(28, 4) ("Got address %02x:%02x:%02x:%02x:%02x:%02x on %s\n",
+	    arpReq.arp_ha.sa_data[0] & 0xff,
+	    arpReq.arp_ha.sa_data[1] & 0xff,
+	    arpReq.arp_ha.sa_data[2] & 0xff,
+	    arpReq.arp_ha.sa_data[3] & 0xff,
+	    arpReq.arp_ha.sa_data[4] & 0xff,
+	    arpReq.arp_ha.sa_data[5] & 0xff,
+	    ifr->ifr_name);
+	/* Do lookup */
 	*Top = splay_splay(&arpReq.arp_ha.sa_data, *Top, aclArpCompare);
-    debug(28, 3) ("aclMatchArp: '%s' %s\n",
-	inet_ntoa(c), splayLastResult ? "NOT found" : "found");
-    return !splayLastResult;
+	/* Return if match, otherwise continue to other interfaces */
+	if (0 == splayLastResult) {
+	    debug(28, 3) ("aclMatchArp: %s found on %s\n",
+		inet_ntoa(c), ifr->ifr_name);
+	    return 1;
+	}
+	/*
+	 * Should we stop looking here? Can the same IP address
+	 * exist on multiple interfaces?
+	 */
+    }
+    /*
+     * Address was not found on any interface
+     */
+    debug(28, 3) ("aclMatchArp: %s NOT found\n", inet_ntoa(c));
+    return 0;
 }
 
 static int
@@ -1,5 +1,5 @@
 /*
- * $Id: asn.cc,v 1.57 1999/04/15 06:15:44 wessels Exp $
+ * $Id: asn.cc,v 1.58 1999/12/30 17:36:22 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -196,7 +196,7 @@ asnCacheStart(int as)
     if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
 	e = storeCreateEntry(asres, asres, null_request_flags, METHOD_GET);
 	storeClientListAdd(e, asState);
-	fwdStart(-1, e, asState->request, no_addr, no_addr);
+	fwdStart(-1, e, asState->request);
     } else {
 	storeLockObject(e);
 	storeClientListAdd(e, asState);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.334 1999/06/30 05:49:39 wessels Exp $
+ * $Id: cache_cf.cc,v 1.335 1999/12/30 17:36:23 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -76,6 +76,10 @@ static OBJH dump_config;
 static void dump_http_header(StoreEntry * entry, const char *name, HttpHeaderMask header);
 static void parse_http_header(HttpHeaderMask * header);
 static void free_http_header(HttpHeaderMask * header);
+static void parse_sockaddr_in_list(sockaddr_in_list **);
+static void dump_sockaddr_in_list(StoreEntry *, const char *, const sockaddr_in_list *);
+static void free_sockaddr_in_list(sockaddr_in_list **);
+static int check_null_sockaddr_in_list(const sockaddr_in_list *);
 
 void
 self_destruct(void)
@@ -276,19 +280,19 @@ configDoConfigure(void)
     storeConfigure();
     if (Config2.Accel.on && !strcmp(Config.Accel.host, "virtual"))
 	vhost_mode = 1;
-    if (Config.Port.http == NULL)
+    if (Config.Sockaddr.http == NULL)
 	fatal("No http_port specified!");
     snprintf(ThisCache, sizeof(ThisCache), "%s:%d (%s)",
 	uniqueHostname(),
-	(int) Config.Port.http->i,
+	(int) ntohs(Config.Sockaddr.http->s.sin_port),
 	full_appname_string);
     /*
      * the extra space is for loop detection in client_side.c -- we search
      * for substrings in the Via header.
      */
     snprintf(ThisCache2, sizeof(ThisCache), " %s:%d (%s)",
 	uniqueHostname(),
-	(int) Config.Port.http->i,
+	(int) ntohs(Config.Sockaddr.http->s.sin_port),
 	full_appname_string);
     if (!Config.udpMaxHitObjsz || Config.udpMaxHitObjsz > SQUID_UDP_SO_SNDBUF)
 	Config.udpMaxHitObjsz = SQUID_UDP_SO_SNDBUF;
@@ -911,7 +915,7 @@ parse_peer(peer ** head)
     char *token = NULL;
     peer *p;
     int i;
-    ushortlist *u;
+    sockaddr_in_list *s;
     const char *me = null_string;	/* XXX */
     p = memAllocate(MEM_PEER);
     p->http_port = CACHE_HTTP_PORT;
@@ -929,8 +933,8 @@ parse_peer(peer ** head)
     i = GetInteger();
     p->icp.port = (u_short) i;
     if (strcmp(p->host, me) == 0) {
-	for (u = Config.Port.http; u; u = u->next) {
-	    if (p->http_port != u->i)
+	for (s = Config.Sockaddr.http; s; s = s->next) {
+	    if (p->http_port != ntohs(s->s.sin_port))
 		continue;
 	    debug(15, 0) ("parse_peer: Peer looks like myself: %s %s/%d/%d\n",
 		p->type, p->host, p->http_port, p->icp.port);
@@ -981,6 +985,10 @@ parse_peer(peer ** head)
 	    p->login = xstrdup(token + 6);
 	} else if (!strncasecmp(token, "connect-timeout=", 16)) {
 	    p->connect_timeout = atoi(token + 16);
+#if USE_CACHE_DIGESTS
+	} else if (!strncasecmp(token, "digest-url=", 11)) {
+	    p->digest_url = xstrdup(token + 11);
+#endif
 	} else {
 	    debug(3, 0) ("parse_peer: token='%s'\n", token);
 	    self_destruct();
@@ -1180,6 +1188,7 @@ parse_hostdomaintype(void)
     }
 }
 
+#if UNUSED_CODE
 static void
 dump_ushortlist(StoreEntry * entry, const char *name, ushortlist * u)
 {
@@ -1223,6 +1232,7 @@ free_ushortlist(ushortlist ** P)
 	xfree(u);
     }
 }
+#endif
 
 static void
 dump_int(StoreEntry * entry, const char *name, int var)
@@ -1561,7 +1571,9 @@ parse_uri_whitespace(int *var)
     char *token = strtok(NULL, w_space);
     if (token == NULL)
 	self_destruct();
-    if (!strcasecmp(token, "deny"))
+    if (!strcasecmp(token, "strip"))
+	*var = URI_WHITESPACE_STRIP;
+    else if (!strcasecmp(token, "deny"))
 	*var = URI_WHITESPACE_DENY;
     else if (!strcasecmp(token, "allow"))
 	*var = URI_WHITESPACE_ALLOW;
@@ -1584,8 +1596,10 @@ dump_uri_whitespace(StoreEntry * entry, const char *name, int var)
 	s = "encode";
     else if (var == URI_WHITESPACE_CHOP)
 	s = "chop";
-    else
+    else if (var == URI_WHITESPACE_DENY)
 	s = "deny";
+    else
+	s = "strip";
     storeAppendPrintf(entry, "%s %s\n", name, s);
 }
 
@@ -1608,6 +1622,72 @@ parseNeighborType(const char *s)
     return PEER_SIBLING;
 }
 
+static void
+parse_sockaddr_in_list(sockaddr_in_list ** head)
+{
+    char *token;
+    char *t;
+    char *host = NULL;
+    const struct hostent *hp;
+    int i;
+    sockaddr_in_list *s;
+    while ((token = strtok(NULL, w_space))) {
+	if ((t = strchr(token, ':'))) {
+	    /* host:port */
+	    host = token;
+	    *t = '\0';
+	    i = atoi(t + 1);
+	    if (i <= 0)
+		self_destruct();
+	} else if ((i = atoi(token)) > 0) {
+	    /* port */
+	} else {
+	    self_destruct();
+	}
+	s = xcalloc(1, sizeof(*s));
+	s->s.sin_port = htons(i);
+	if (NULL == host)
+	    s->s.sin_addr = any_addr;
+	else if (1 == safe_inet_addr(host, &s->s.sin_addr))
+	    (void) 0;
+	else if ((hp = gethostbyname(token)))	/* dont use ipcache */
+	    s->s.sin_addr = inaddrFromHostent(hp);
+	else
+	    self_destruct();
+	while (*head)
+	    head = &(*head)->next;
+	*head = s;
+    }
+}
+
+static void
+dump_sockaddr_in_list(StoreEntry * e, const char *n, const sockaddr_in_list * s)
+{
+    while (s) {
+	storeAppendPrintf(e, "%s %s:%d\n",
+	    n,
+	    inet_ntoa(s->s.sin_addr),
+	    ntohs(s->s.sin_port));
+	s = s->next;
+    }
+}
+
+static void
+free_sockaddr_in_list(sockaddr_in_list ** head)
+{
+    sockaddr_in_list *s;
+    while ((s = *head) != NULL) {
+	*head = s->next;
+	xfree(s);
+    }
+}
+
+static int
+check_null_sockaddr_in_list(const sockaddr_in_list * s)
+{
+    return NULL == s;
+}
+
 void
 configFreeMemory(void)
 {
@@ -1,6 +1,6 @@
 
 #
-# $Id: cf.data.pre,v 1.163 1999/12/11 15:57:43 wessels Exp $
+# $Id: cf.data.pre,v 1.164 1999/12/30 17:36:24 wessels Exp $
 #
 #
 # SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -54,17 +54,32 @@ COMMENT_START
 COMMENT_END
 
 NAME: http_port ascii_port
-TYPE: ushortlist
+TYPE: sockaddr_in_list
 DEFAULT: none
 DEFAULT_IF_NONE: 3128
-LOC: Config.Port.http
+LOC: Config.Sockaddr.http
 DOC_START
-	The port number where Squid will listen for HTTP client
-	requests.  Default is 3128, for httpd-accel mode use port 80.
-	May be overridden with -a on the command line.
+	Usage:	port
+		hostname:port
+		1.2.3.4:port
 
-	You may specify multiple ports here, but they MUST all be on
-	a single line.
+	The socket addresses where Squid will listen for HTTP client
+	requests.  You may specify multiple socket addresses.
+	There are three forms: port alone, hostname with port, and
+	IP address with port.  If you specify a hostname or IP
+	address, then Squid binds the socket to that specific
+	address.  This replaces the old 'tcp_incoming_address'
+	option.  Most likely, you do not need to bind to a specific
+	address, so you can use the port number alone.
+
+	The default port number is 3128.
+
+	If you are running Squid in accelerateor mode, then you
+	probably want to listen on port 80 also, or instead.
+
+	The -a command line option will override the *first* port
+	number listed here.   That option will NOT override an IP
+	address, however.
 
 http_port 3128
 DOC_END
@@ -131,12 +146,6 @@ mcast_groups 239.128.16.128
 DOC_END
 
 
-NAME: tcp_incoming_address bind_address
-TYPE: address
-LOC: Config.Addrs.tcp_incoming
-DEFAULT: 0.0.0.0
-DOC_NONE
-
 NAME: tcp_outgoing_address outbound_address
 TYPE: address
 LOC: Config.Addrs.tcp_outgoing
@@ -157,8 +166,6 @@ DOC_START
 	Usage: tcp_incoming_address 10.20.30.40
 	       udp_outgoing_address fully.qualified.domain.name
 
-	tcp_incoming_address	is used for the HTTP socket which accepts
-				connections from clients and other caches.
 	tcp_outgoing_address	is used for connections made to remote
 				servers and other caches.
 	udp_incoming_address	is used for the ICP socket receiving packets
@@ -172,7 +179,9 @@ DOC_START
 	have the same value (unless it is 0.0.0.0) since they both use
 	port 3130.
 
-tcp_incoming_address 0.0.0.0
+	NOTE, tcp_incoming_address has been removed.  You can now
+	specify IP addresses on the 'http_port' line.
+
 tcp_outgoing_address 0.0.0.0
 udp_incoming_address 0.0.0.0
 udp_outgoing_address 0.0.0.0
@@ -225,6 +234,7 @@ DOC_START
 		     no-delay
 		     login=user:password
 		     connect-timeout=nn
+		     digest-url=url
 
 		     use 'proxy-only' to specify that objects fetched
 		     from this cache should not be saved locally.
@@ -277,6 +287,10 @@ DOC_START
 		     specific connect timeout (also see the
 		     peer_connect_timeout directive)
 
+		     use 'digest-url=url' to tell Squid to fetch the cache
+		     digest (if digests are enabled) for this host from
+		     the specified URL rather than the Squid default
+		     location.
 
 	NOTE: non-ICP neighbors must be specified as 'parent'.
 
@@ -965,9 +979,9 @@ TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.redir_rewrites_host
 DOC_START
-	By default Squid rewrites any Host: header in redirected requests.
-	If you are running a accelerator then this may not be a wanted effect
-	of a redirector.
+	By default Squid rewrites any Host: header in redirected
+	requests.  If you are running a accelerator then this may
+	not be a wanted effect of a redirector.
 redirect_rewrites_host_header on
 DOC_END
 
@@ -1135,10 +1149,20 @@ DOC_START
 	By default, regular expressions are CASE-SENSITIVE.  To make
 	them case-insensitive, use the -i option.
 
-	min and max are specified in MINUTES.
-	percent is an integer number.
+	'Min' is the time (in minutes) an object without an explicit
+	expiry time should be considered fresh. The recommended
+	value is 0, any higher values may cause dynamic applications
+	to be erronously cached unless the application designer
+	has taken the appropriate actions.
+
+	'Percent' is a percentage of the objects age (time since last
+	modification age) an object without explicit exipry time
+	will be considered fresh.
+
+	'Max' is an upper limit on how long objects without an explicit
+	expiry time will be considered fresh.
 
-	options: override-expire
+	options: overrsde-expire
 		 override-lastmod
 		 reload-into-ims
 		 ignore-reload
@@ -1242,7 +1266,7 @@ DOC_START
 	The 'reference_age' parameter defines the maximum LRU age.  For
 	example, setting reference_age to '1 week' will cause objects
 	to be removed if they have not been accessed for a week or
-	more.  The default value is one month.
+	more.  The default value is one year.
 
 	Specify a number here, followed by units of time.  For example:
 		1 week
@@ -1579,6 +1603,7 @@ DOC_START
 	acl aclname urlpath_regex [-i] \.gif$ ...	# regex matching on URL path
 	acl aclname port     80 70 21 ...
 	acl aclname port     0-1024 ...		# ranges allowed
+	acl aclname myport   3128 ...		# (local socket TCP port)
 	acl aclname proto    HTTP FTP ...
 	acl aclname method   GET POST ...
 	acl aclname browser  [-i] regexp
@@ -2270,7 +2295,7 @@ LOC: Config.Store.objectsPerBucket
 DOC_START
 	Target number of objects per bucket in the store hash table.
 	Lowering this value increases the total number of buckets and
-	also the storage maintenance rate.  The default is 20.
+	also the storage maintenance rate.  The default is 50.
 
 store_objects_per_bucket 20
 DOC_END
@@ -2893,11 +2918,13 @@ DOC_END
 NAME: uri_whitespace
 TYPE: uri_whitespace
 LOC: Config.uri_whitespace
-DEFAULT: deny
+DEFAULT: strip
 DOC_START
 	What to do with requests that have whitespace characters in the
 	URI.  Options:
 
+	strip:  The whitespace characters are stripped out of the URL.
+		This is the behavior recommended by RFC2616.
 	deny:   The request is denied.  The user receives an "Invalid
 		Request" message.
 	allow:  The request is allowed and the URI is not changed.  The
@@ -2911,7 +2938,7 @@ DOC_START
 	chop:	The request is allowed and the URI is chopped at the
 		first whitespace.  This might also be considered a
 		violation.
-uri_whitespace deny
+uri_whitespace strip
 DOC_END
 
 NAME: broken_posts
@@ -2949,6 +2976,17 @@ DOC_START
 	certain you understand what you are doing.
 DOC_END
 
+NAME: mcast_miss_ttl
+IFDEF: MULTICAST_MISS_TTL
+TYPE: ushort
+LOC: Config.mcast_miss.ttl
+DEFAULT: 16
+DOC_START
+	This is the time-to-live value for packets multicasted
+	when multicasting off cache miss URLs is enabled.  By
+	default this is set to 'site scope', i.e. 16.
+DOC_END
+
 NAME: mcast_miss_port
 IFDEF: MULTICAST_MISS_STREAM
 TYPE: ushort
@@ -3034,4 +3072,83 @@ DOC_START
 ignore_unknown_nameservers on
 DOC_END
 
+NAME: digest_generation
+IFDEF: USE_CACHE_DIGESTS
+TYPE: onoff
+LOC: Config.onoff.digest_generation
+DEFAULT: on
+DOC_START
+	This controls whether the server will generate a Cache Digest
+	of its contents.  By default, Cache Digest generation is
+	enabled if Squid is compiled with USE_CACHE_DIGESTS defined.
+
+digest_generation on
+DOC_END
+
+NAME: digest_bits_per_entry
+IFDEF: USE_CACHE_DIGESTS
+TYPE: int
+LOC: Config.digest.bits_per_entry
+DEFAULT: 5
+DOC_START
+	This is the number of bits of the server's Cache Digest which
+	will be associated with the Digest entry for a given HTTP
+	Method and URL (public key) combination.  The default is 5.
+
+digest_bits_per_entry 5
+DOC_END
+
+NAME: digest_rebuild_period
+IFDEF: USE_CACHE_DIGESTS
+TYPE: int
+LOC: Config.digest.rebuild_period
+DEFAULT: 3600
+DOC_START
+	This is the number of seconds between Cache Digest rebuilds.
+	By default the server's Digest is rebuilt every hour - 60
+	minutes * 60 seconds per minute, 3600 seconds.
+
+digest_rebuild_period 3600
+DOC_END
+
+NAME: digest_rewrite_period
+IFDEF: USE_CACHE_DIGESTS
+TYPE: int
+LOC: Config.digest.rewrite_period
+DEFAULT: 3600
+DOC_START
+	This is the number of seconds between Cache Digest writes to
+	disk.  By default the server's Digest is written to disk every
+	hour - 60 minutes * 60 seconds per minute, 3600 seconds.
+
+digest_rewrite_period 3600
+DOC_END
+
+NAME: digest_swapout_chunk_size
+IFDEF: USE_CACHE_DIGESTS
+TYPE: int
+LOC: Config.digest.swapout_chunk_size
+DEFAULT: 4096
+DOC_START
+	This is the number of bytes of the Cache Digest to write to
+	disk at a time.  It defaults to 4096 (4KB), the Squid default
+	swap page.
+
+digest_swapout_chunk_size 4096
+DOC_END
+
+NAME: digest_rebuild_chunk_percentage
+IFDEF: USE_CACHE_DIGESTS
+TYPE: int
+LOC: Config.digest.rebuild_chunk_percentage
+DEFAULT: 10
+DOC_START
+	This is the portion (where 0 < portion <= 100) of the Cache Digest
+	to be scanned at a time.  By default it is set to 10 (10%) of
+	the Cache Digest.
+
+digest_rebuild_chunk_percentage 10
+DOC_END
+
 EOF
+
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.464 1999/12/13 05:54:54 wessels Exp $
+ * $Id: client_side.cc,v 1.465 1999/12/30 17:36:26 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -147,8 +147,6 @@ clientAccessCheck(void *data)
     browser = httpHeaderGetStr(&http->request->header, HDR_USER_AGENT);
     http->acl_checklist = aclChecklistCreate(Config.accessList.http,
 	http->request,
-	conn->peer.sin_addr,
-	conn->me.sin_addr,
 	browser,
 	conn->ident);
 #if USE_IDENT
@@ -280,12 +278,14 @@ clientRedirectDone(void *data, char *result)
 	httpHeaderAppend(&new_request->header, &old_request->header);
 	new_request->client_addr = old_request->client_addr;
 	new_request->my_addr = old_request->my_addr;
+	new_request->my_port = old_request->my_port;
 	new_request->flags.redirected = 1;
 	if (old_request->body) {
 	    new_request->body = xmalloc(old_request->body_sz);
 	    xmemcpy(new_request->body, old_request->body, old_request->body_sz);
 	    new_request->body_sz = old_request->body_sz;
 	}
+	new_request->content_length = old_request->content_length;
 	requestUnlink(old_request);
 	http->request = requestLink(new_request);
     }
@@ -331,14 +331,9 @@ clientProcessExpired(void *data)
 #endif
     http->request->lastmod = http->old_entry->lastmod;
     debug(33, 5) ("clientProcessExpired: lastmod %d\n", (int) entry->lastmod);
-    entry->refcount++;		/* EXPIRED CASE */
-#if HEAP_REPLACEMENT
-    storeHeapPositionUpdate(entry);
-#endif
     http->entry = entry;
     http->out.offset = 0;
-    fwdStart(http->conn->fd, http->entry, http->request,
-	http->conn->peer.sin_addr, http->conn->me.sin_addr);
+    fwdStart(http->conn->fd, http->entry, http->request);
     /* Register with storage manager to receive updates when data comes in. */
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED))
 	debug(33, 0) ("clientProcessExpired: found ENTRY_ABORTED object\n");
@@ -419,10 +414,6 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	storeUnregister(entry, http);
 	storeUnlockObject(entry);
 	entry = http->entry = http->old_entry;
-	entry->refcount++;
-#if HEAP_REPLACEMENT
-	storeHeapPositionUpdate(entry);
-#endif
     } else if (STORE_PENDING == entry->store_status && 0 == status) {
 	debug(33, 3) ("clientHandleIMSReply: Incomplete headers for '%s'\n", url);
 	if (size >= CLIENT_SOCK_SZ) {
@@ -433,10 +424,6 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	    storeUnregister(entry, http);
 	    storeUnlockObject(entry);
 	    entry = http->entry = http->old_entry;
-	    entry->refcount++;
-#if HEAP_REPLACEMENT
-	    storeHeapPositionUpdate(entry);
-#endif
 	    /* continue */
 	} else {
 	    storeClientCopy(entry,
@@ -479,10 +466,6 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	    httpReplyUpdateOnNotModified(http->old_entry->mem_obj->reply,
 		mem->reply);
 	    storeTimestampsSet(http->old_entry);
-	    http->old_entry->refcount++;
-#if HEAP_REPLACEMENT
-	    storeHeapPositionUpdate(http->old_entry);
-#endif
 	    http->log_type = LOG_TCP_REFRESH_HIT;
 	}
 	storeUnregister(http->old_entry, http);
@@ -911,14 +894,16 @@ clientCachable(clientHttpRequest * http)
      */
     ch.src_addr = http->conn->peer.sin_addr;
     ch.my_addr = http->conn->me.sin_addr;
+    ch.my_port = ntohs(http->conn->me.sin_port);
     ch.request = http->request;
     /*
      * aclCheckFast returns 1 for ALLOW and 0 for DENY.  The default
      * is ALLOW, so we require 'no_cache DENY foo' in squid.conf
      * to indicate uncachable objects.
      */
-    if (!aclCheckFast(Config.accessList.noCache, &ch))
-	return 0;
+    if (Config.accessList.noCache)
+	if (!aclCheckFast(Config.accessList.noCache, &ch))
+	    return 0;
     if (req->protocol == PROTO_HTTP)
 	return httpCachable(method);
     /* FTP is always cachable */
@@ -1202,7 +1187,7 @@ clientBuildReplyHeader(clientHttpRequest * http, HttpReply * rep)
     /* Append X-Cache-Lookup: -- temporary hack, to be removed @?@ @?@ */
     httpHeaderPutStrf(hdr, HDR_X_CACHE_LOOKUP, "%s from %s:%d",
 	http->lookup_type ? http->lookup_type : "NONE",
-	getMyHostname(), Config.Port.http->i);
+	getMyHostname(), ntohs(Config.Sockaddr.http->s.sin_port));
 #endif
     if (httpReplyBodySize(request->method, rep) < 0) {
 	debug(33, 3) ("clientBuildReplyHeader: can't keep-alive, unknown body size\n");
@@ -1966,10 +1951,6 @@ clientProcessRequest(clientHttpRequest * http)
 	storeClientListAdd(http->entry, http);
 #if DELAY_POOLS
 	delaySetStoreClient(http->entry, http, delayClient(r));
-#endif
-	http->entry->refcount++;
-#if HEAP_REPLACEMENT
-	storeHeapPositionUpdate(http->entry);
 #endif
 	storeClientCopy(http->entry,
 	    http->out.offset,
@@ -2025,10 +2006,6 @@ clientProcessMiss(clientHttpRequest * http)
     }
     assert(http->out.offset == 0);
     http->entry = clientCreateStoreEntry(http, r->method, r->flags);
-    http->entry->refcount++;
-#if HEAP_REPLACEMENT
-    storeHeapPositionUpdate(http->entry);
-#endif
     if (http->redirect.status) {
 	HttpReply *rep = httpReplyCreate();
 	storeReleaseRequest(http->entry);
@@ -2040,8 +2017,7 @@ clientProcessMiss(clientHttpRequest * http)
     }
     if (http->flags.internal)
 	r->protocol = PROTO_INTERNAL;
-    fwdStart(http->conn->fd, http->entry, r,
-	http->conn->peer.sin_addr, http->conn->me.sin_addr);
+    fwdStart(http->conn->fd, http->entry, r);
 }
 
 static clientHttpRequest *
@@ -2275,7 +2251,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 	strcpy(http->uri, url);
 	http->flags.accel = 0;
     }
-    if (!stringHasCntl((unsigned char *) http->uri))
+    if (!stringHasCntl(http->uri))
 	http->log_uri = xstrndup(http->uri, MAX_URL);
     else
 	http->log_uri = xstrndup(rfc1738_escape_unescaped(http->uri), MAX_URL);
@@ -2428,11 +2404,11 @@ clientReadRequest(int fd, void *data)
 	    if (!http->flags.internal) {
 		if (internalCheck(strBuf(request->urlpath))) {
 		    if (internalHostnameIs(request->host) &&
-			request->port == Config.Port.http->i) {
+			request->port == ntohs(Config.Sockaddr.http->s.sin_port)) {
 			http->flags.internal = 1;
 		    } else if (internalStaticCheck(strBuf(request->urlpath))) {
 			xstrncpy(request->host, internalHostname(), SQUIDHOSTNAMELEN);
-			request->port = Config.Port.http->i;
+			request->port = ntohs(Config.Sockaddr.http->s.sin_port);
 			http->flags.internal = 1;
 		    }
 		}
@@ -2448,6 +2424,7 @@ clientReadRequest(int fd, void *data)
 	    http->log_uri = xstrdup(urlCanonicalClean(request));
 	    request->client_addr = conn->peer.sin_addr;
 	    request->my_addr = conn->me.sin_addr;
+	    request->my_port = ntohs(conn->me.sin_port);
 	    request->http_ver = http->http_ver;
 	    if (!urlCheckRequest(request)) {
 		err = errorCon(ERR_UNSUP_REQ, HTTP_NOT_IMPLEMENTED);
@@ -2525,7 +2502,7 @@ clientReadRequest(int fd, void *data)
 			close(fd);
 		    }
 		    /* The request is too large to handle */
-		    debug(33, 0) ("Request header is too large (%d bytes)\n",
+		    debug(33, 1) ("Request header is too large (%d bytes)\n",
 			(int) conn->in.offset);
 		    debug(33, 1) ("Config 'request_header_max_size'= %d bytes.\n",
 			Config.maxRequestHeaderSize);
@@ -2586,6 +2563,10 @@ requestTimeout(int fd, void *data)
 	 * if we don't close() here, we still need a timeout handler!
 	 */
 	commSetTimeout(fd, 30, requestTimeout, conn);
+	/*
+	 * Aha, but we don't want a read handler!
+	 */
+	commSetSelect(fd, COMM_SELECT_READ, NULL, NULL, 0);
     }
 }
 
@@ -2643,6 +2624,7 @@ httpAccept(int sock, void *data)
 #if USE_IDENT
 	identChecklist.src_addr = peer.sin_addr;
 	identChecklist.my_addr = me.sin_addr;
+	identChecklist.my_port = ntohs(me.sin_port);
 	if (aclCheckFast(Config.accessList.identLookup, &identChecklist))
 	    identStart(&me, &peer, clientIdentDone, connState);
 #endif
@@ -2780,14 +2762,14 @@ checkFailureRatio(err_type etype, hier_code hcode)
 void
 clientHttpConnectionsOpen(void)
 {
-    ushortlist *u;
+    sockaddr_in_list *s;
     int fd;
-    for (u = Config.Port.http; u; u = u->next) {
+    for (s = Config.Sockaddr.http; s; s = s->next) {
 	enter_suid();
 	fd = comm_open(SOCK_STREAM,
 	    0,
-	    Config.Addrs.tcp_incoming,
-	    u->i,
+	    s->s.sin_addr,
+	    ntohs(s->s.sin_port),
 	    COMM_NONBLOCKING,
 	    "HTTP Socket");
 	leave_suid();
@@ -2796,8 +2778,10 @@ clientHttpConnectionsOpen(void)
 	comm_listen(fd);
 	commSetSelect(fd, COMM_SELECT_READ, httpAccept, NULL, 0);
 	/*commSetDefer(fd, httpAcceptDefer, NULL); */
-	debug(1, 1) ("Accepting HTTP connections on port %d, FD %d.\n",
-	    (int) u->i, fd);
+	debug(1, 1) ("Accepting HTTP connections at %s, port %d, FD %d.\n",
+	    inet_ntoa(s->s.sin_addr),
+	    (int) ntohs(s->s.sin_port),
+	    fd);
 	HttpSockets[NHttpSockets++] = fd;
     }
     if (NHttpSockets < 1)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.303 1999/10/04 05:05:06 wessels Exp $
+ * $Id: comm.cc,v 1.304 1999/12/30 17:36:27 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -720,6 +720,23 @@ commSetNonBlocking(int fd)
     return 0;
 }
 
+int
+commUnsetNonBlocking(int fd)
+{
+    int flags;
+    int dummy = 0;
+    if ((flags = fcntl(fd, F_GETFL, dummy)) < 0) {
+	debug(50, 0) ("FD %d: fcntl F_GETFL: %s\n", fd, xstrerror());
+	return COMM_ERROR;
+    }
+    if (fcntl(fd, F_SETFL, flags & (~SQUID_NONBLOCK)) < 0) {
+	debug(50, 0) ("commUnsetNonBlocking: FD %d: %s\n", fd, xstrerror());
+	return COMM_ERROR;
+    }
+    fd_table[fd].flags.nonblocking = 0;
+    return 0;
+}
+
 void
 commSetCloseOnExec(int fd)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_select.cc,v 1.37 1999/07/13 14:51:10 wessels Exp $
+ * $Id: comm_select.cc,v 1.38 1999/12/30 17:36:28 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -174,6 +174,31 @@ fdIsHttp(int fd)
     return 0;
 }
 
+#if DELAY_POOLS
+static int slowfdcnt = 0;
+static int slowfdarr[SQUID_MAXFD];
+
+static void
+commAddSlowFd(int fd)
+{
+    assert(slowfdcnt < SQUID_MAXFD);
+    slowfdarr[slowfdcnt++] = fd;
+}
+
+static int
+commGetSlowFd(void)
+{
+    int whichfd, retfd;
+
+    if (!slowfdcnt)
+	return -1;
+    whichfd = squid_random() % slowfdcnt;
+    retfd = slowfdarr[whichfd];
+    slowfdarr[whichfd] = slowfdarr[--slowfdcnt];
+    return retfd;
+}
+#endif
+
 #if HAVE_POLL
 static int
 comm_check_incoming_poll_handlers(int nfds, int *fds)
@@ -288,6 +313,9 @@ int
 comm_poll(int msec)
 {
     struct pollfd pfds[SQUID_MAXFD];
+#if DELAY_POOLS
+    fd_set slowfds;
+#endif
     PF *hdl = NULL;
     int fd;
     int i;
@@ -309,6 +337,9 @@ comm_poll(int msec)
 #endif
 #if USE_DISKD
 	storeDiskdReadQueue();
+#endif
+#if DELAY_POOLS
+	FD_ZERO(&slowfds);
 #endif
 	if (commCheckICPIncoming)
 	    comm_poll_icp_incoming();
@@ -323,8 +354,23 @@ comm_poll(int msec)
 	    int events;
 	    events = 0;
 	    /* Check each open socket for a handler. */
-	    if (fd_table[i].read_handler && !commDeferRead(i))
-		events |= POLLRDNORM;
+	    if (fd_table[i].read_handler) {
+		switch (commDeferRead(i)) {
+		case 0:
+		    events |= POLLRDNORM;
+		    break;
+		case 1:
+		    break;
+#if DELAY_POOLS
+		case -1:
+		    events |= POLLRDNORM;
+		    FD_SET(i, &slowfds);
+		    break;
+#endif
+		default:
+		    fatalf("bad return value from commDeferRead(FD %d)\n", i);
+		}
+	    }
 	    if (fd_table[i].write_handler)
 		events |= POLLWRNORM;
 	    if (events) {
@@ -385,31 +431,37 @@ comm_poll(int msec)
 	    F = &fd_table[fd];
 	    if (revents & (POLLRDNORM | POLLIN | POLLHUP | POLLERR)) {
 		debug(5, 6) ("comm_poll: FD %d ready for reading\n", fd);
-		if ((hdl = F->read_handler)) {
+		if (NULL == (hdl = F->read_handler))
+		    (void) 0;
+#if DELAY_POOLS
+		else if (FD_ISSET(fd, &slowfds))
+		    commAddSlowFd(fd);
+#endif
+		else {
 		    F->read_handler = NULL;
 		    hdl(fd, F->read_data);
 		    Counter.select_fds++;
+		    if (commCheckICPIncoming)
+			comm_poll_icp_incoming();
+		    if (commCheckDNSIncoming)
+			comm_poll_dns_incoming();
+		    if (commCheckHTTPIncoming)
+			comm_poll_http_incoming();
 		}
-		if (commCheckICPIncoming)
-		    comm_poll_icp_incoming();
-		if (commCheckDNSIncoming)
-		    comm_poll_dns_incoming();
-		if (commCheckHTTPIncoming)
-		    comm_poll_http_incoming();
 	    }
 	    if (revents & (POLLWRNORM | POLLOUT | POLLHUP | POLLERR)) {
 		debug(5, 5) ("comm_poll: FD %d ready for writing\n", fd);
 		if ((hdl = F->write_handler)) {
 		    F->write_handler = NULL;
 		    hdl(fd, F->write_data);
 		    Counter.select_fds++;
+		    if (commCheckICPIncoming)
+			comm_poll_icp_incoming();
+		    if (commCheckDNSIncoming)
+			comm_poll_dns_incoming();
+		    if (commCheckHTTPIncoming)
+			comm_poll_http_incoming();
 		}
-		if (commCheckICPIncoming)
-		    comm_poll_icp_incoming();
-		if (commCheckDNSIncoming)
-		    comm_poll_dns_incoming();
-		if (commCheckHTTPIncoming)
-		    comm_poll_http_incoming();
 	    }
 	    if (revents & POLLNVAL) {
 		close_handler *ch;
@@ -442,6 +494,23 @@ comm_poll(int msec)
 	    comm_poll_dns_incoming();
 	if (callhttp)
 	    comm_poll_http_incoming();
+#if DELAY_POOLS
+	while ((fd = commGetSlowFd()) != -1) {
+	    fde *F = &fd_table[fd];
+	    debug(5, 6) ("comm_select: slow FD %d selected for reading\n", fd);
+	    if ((hdl = F->read_handler)) {
+		F->read_handler = NULL;
+		hdl(fd, F->read_data);
+		Counter.select_fds++;
+		if (commCheckICPIncoming)
+		    comm_poll_icp_incoming();
+		if (commCheckDNSIncoming)
+		    comm_poll_dns_incoming();
+		if (commCheckHTTPIncoming)
+		    comm_poll_http_incoming();
+	    }
+	}
+#endif
 #if !ALARM_UPDATES_TIME
 	getCurrentTime();
 	Counter.select_time += (current_dtime - start);
@@ -572,6 +641,9 @@ comm_select(int msec)
 {
     fd_set readfds;
     fd_set writefds;
+#if DELAY_POOLS
+    fd_set slowfds;
+#endif
     PF *hdl = NULL;
     int fd;
     int maxfd;
@@ -599,6 +671,9 @@ comm_select(int msec)
 #endif
 #if USE_DISKD
 	storeDiskdReadQueue();
+#endif
+#if DELAY_POOLS
+	FD_ZERO(&slowfds);
 #endif
 	if (commCheckICPIncoming)
 	    comm_select_icp_incoming();
@@ -623,14 +698,30 @@ comm_select(int msec)
 		    continue;
 		/* Found a set bit */
 		fd = (j * FD_MASK_BITS) + k;
-		if (commDeferRead(fd))
+		switch (commDeferRead(fd)) {
+		case 0:
+		    break;
+		case 1:
 		    FD_CLR(fd, &readfds);
+		    break;
+#if DELAY_POOLS
+		case -1:
+		    FD_SET(fd, &slowfds);
+		    break;
+#endif
+		default:
+		    fatalf("bad return value from commDeferRead(FD %d)\n", fd);
+		}
 	    }
 	}
 #if DEBUG_FDBITS
 	for (i = 0; i < maxfd; i++) {
 	    /* Check each open socket for a handler. */
+#if DELAY_POOLS
+	    if (fd_table[i].read_handler && commDeferRead(i) != 1) {
+#else
 	    if (fd_table[i].read_handler && !commDeferRead(i)) {
+#endif
 		assert(FD_ISSET(i, &readfds));
 	    }
 	    if (fd_table[i].write_handler) {
@@ -684,10 +775,13 @@ comm_select(int msec)
 	    if ((tmask = fdsp[j]) == 0)
 		continue;	/* no bits here */
 	    for (k = 0; k < FD_MASK_BITS; k++) {
+		if (tmask == 0)
+		    break;	/* no more bits left */
 		if (!EBIT_TEST(tmask, k))
 		    continue;
 		/* Found a set bit */
 		fd = (j * FD_MASK_BITS) + k;
+		EBIT_CLR(tmask, k);	/* this will be done */
 #if DEBUG_FDBITS
 		debug(5, 9) ("FD %d bit set for reading\n", fd);
 		assert(FD_ISSET(fd, &readfds));
@@ -706,33 +800,38 @@ comm_select(int msec)
 		}
 		F = &fd_table[fd];
 		debug(5, 6) ("comm_select: FD %d ready for reading\n", fd);
-		if (F->read_handler) {
-		    hdl = F->read_handler;
+		if (NULL == (hdl = F->read_handler))
+		    (void) 0;
+#if DELAY_POOLS
+		else if (FD_ISSET(fd, &slowfds))
+		    commAddSlowFd(fd);
+#endif
+		else {
 		    F->read_handler = NULL;
 		    commUpdateReadBits(fd, NULL);
 		    hdl(fd, F->read_data);
 		    Counter.select_fds++;
+		    if (commCheckICPIncoming)
+			comm_select_icp_incoming();
+		    if (commCheckDNSIncoming)
+			comm_select_dns_incoming();
+		    if (commCheckHTTPIncoming)
+			comm_select_http_incoming();
 		}
-		if (commCheckICPIncoming)
-		    comm_select_icp_incoming();
-		if (commCheckDNSIncoming)
-		    comm_select_dns_incoming();
-		if (commCheckHTTPIncoming)
-		    comm_select_http_incoming();
-		EBIT_CLR(tmask, k);	/* this bit is done */
-		if (tmask == 0)
-		    break;	/* and no more bits left */
 	    }
 	}
 	fdsp = (fd_mask *) & writefds;
 	for (j = 0; j < maxindex; j++) {
 	    if ((tmask = fdsp[j]) == 0)
 		continue;	/* no bits here */
 	    for (k = 0; k < FD_MASK_BITS; k++) {
+		if (tmask == 0)
+		    break;	/* no more bits left */
 		if (!EBIT_TEST(tmask, k))
 		    continue;
 		/* Found a set bit */
 		fd = (j * FD_MASK_BITS) + k;
+		EBIT_CLR(tmask, k);	/* this will be done */
 #if DEBUG_FDBITS
 		debug(5, 9) ("FD %d bit set for writing\n", fd);
 		assert(FD_ISSET(fd, &writefds));
@@ -751,22 +850,18 @@ comm_select(int msec)
 		}
 		F = &fd_table[fd];
 		debug(5, 5) ("comm_select: FD %d ready for writing\n", fd);
-		if (F->write_handler) {
-		    hdl = F->write_handler;
+		if ((hdl = F->write_handler)) {
 		    F->write_handler = NULL;
 		    commUpdateWriteBits(fd, NULL);
 		    hdl(fd, F->write_data);
 		    Counter.select_fds++;
+		    if (commCheckICPIncoming)
+			comm_select_icp_incoming();
+		    if (commCheckDNSIncoming)
+			comm_select_dns_incoming();
+		    if (commCheckHTTPIncoming)
+			comm_select_http_incoming();
 		}
-		if (commCheckICPIncoming)
-		    comm_select_icp_incoming();
-		if (commCheckDNSIncoming)
-		    comm_select_dns_incoming();
-		if (commCheckHTTPIncoming)
-		    comm_select_http_incoming();
-		EBIT_CLR(tmask, k);	/* this bit is done */
-		if (tmask == 0)
-		    break;	/* and no more bits left */
 	    }
 	}
 	if (callicp)
@@ -775,6 +870,24 @@ comm_select(int msec)
 	    comm_select_dns_incoming();
 	if (callhttp)
 	    comm_select_http_incoming();
+#if DELAY_POOLS
+	while ((fd = commGetSlowFd()) != -1) {
+	    F = &fd_table[fd];
+	    debug(5, 6) ("comm_select: slow FD %d selected for reading\n", fd);
+	    if ((hdl = F->read_handler)) {
+		F->read_handler = NULL;
+		commUpdateReadBits(fd, NULL);
+		hdl(fd, F->read_data);
+		Counter.select_fds++;
+		if (commCheckICPIncoming)
+		    comm_select_icp_incoming();
+		if (commCheckDNSIncoming)
+		    comm_select_dns_incoming();
+		if (commCheckHTTPIncoming)
+		    comm_select_http_incoming();
+	    }
+	}
+#endif
 	return COMM_OK;
     }
     while (timeout > current_dtime);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: defines.h,v 1.76 1999/08/02 06:18:34 wessels Exp $
+ * $Id: defines.h,v 1.77 1999/12/30 17:36:29 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -206,8 +206,6 @@
 #define STORE_ENTRY_WITH_MEMOBJ		1
 #define STORE_ENTRY_WITHOUT_MEMOBJ	0
 
-#define SKIP_BASIC_SZ ((size_t) 6)
-
 #define PINGER_PAYLOAD_SZ 8192
 
 #define COUNT_INTERVAL 60
@@ -262,10 +260,11 @@
 
 #define CLIENT_SOCK_SZ 4096
 
-#define URI_WHITESPACE_DENY 0
+#define URI_WHITESPACE_STRIP 0
 #define URI_WHITESPACE_ALLOW 1
 #define URI_WHITESPACE_ENCODE 2
 #define URI_WHITESPACE_CHOP 3
+#define URI_WHITESPACE_DENY 4
 
 #ifndef _PATH_DEVNULL
 #define _PATH_DEVNULL "/dev/null"
@@ -1,6 +1,6 @@
 
 /*
- * $Id: delay_pools.cc,v 1.11 1999/10/04 05:05:08 wessels Exp $
+ * $Id: delay_pools.cc,v 1.12 1999/12/30 17:36:30 wessels Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: David Luyer <luyer@ucs.uwa.edu.au>
@@ -283,6 +283,7 @@ delayClient(request_t * r)
     memset(&ch, '\0', sizeof(ch));
     ch.src_addr = r->client_addr;
     ch.my_addr = r->my_addr;
+    ch.my_port = r->my_port;
     ch.request = r;
     for (pool = 0; pool < Config.Delay.pools; pool++) {
 	if (aclCheckFast(Config.Delay.access[pool], &ch))
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dns.cc,v 1.79 1999/06/17 22:20:37 wessels Exp $
+ * $Id: dns.cc,v 1.80 1999/12/30 17:36:30 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -72,8 +72,8 @@ dnsInit(void)
 	cachemgrRegister("dns",
 	    "Dnsserver Statistics",
 	    dnsStats, 0, 1);
+	init = 1;
     }
-    init++;
 #endif
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.161 1999/10/04 05:05:09 wessels Exp $
+ * $Id: enums.h,v 1.162 1999/12/30 17:36:31 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -102,6 +102,7 @@ typedef enum {
     ACL_URLPATH_REGEX,
     ACL_URL_REGEX,
     ACL_URL_PORT,
+    ACL_MY_PORT,
 #if USE_IDENT
     ACL_IDENT,
 #endif
@@ -247,6 +248,7 @@ typedef enum {
     CC_MUST_REVALIDATE,
     CC_PROXY_REVALIDATE,
     CC_MAX_AGE,
+    CC_S_MAXAGE,
     CC_ONLY_IF_CACHED,
     CC_OTHER,
     CC_ENUM_END
@@ -367,15 +369,14 @@ enum {
     METHOD_TRACE,		/* 110 */
     METHOD_PURGE,		/* 111 */
     METHOD_OPTIONS,
-#ifndef RFC_2518
+    METHOD_DELETE,		/* RFC2616 section 9.7 */
     METHOD_PROPFIND,
     METHOD_PROPPATCH,
     METHOD_MKCOL,
     METHOD_COPY,
     METHOD_MOVE,
     METHOD_LOCK,
     METHOD_UNLOCK,
-#endif
     METHOD_ENUM_END
 };
 typedef unsigned int method_t;
@@ -402,13 +403,15 @@ typedef enum {
     HTTP_STATUS_NONE = 0,
     HTTP_CONTINUE = 100,
     HTTP_SWITCHING_PROTOCOLS = 101,
+    HTTP_PROCESSING = 102,	/* RFC2518 section 10.1 */
     HTTP_OK = 200,
     HTTP_CREATED = 201,
     HTTP_ACCEPTED = 202,
     HTTP_NON_AUTHORITATIVE_INFORMATION = 203,
     HTTP_NO_CONTENT = 204,
     HTTP_RESET_CONTENT = 205,
     HTTP_PARTIAL_CONTENT = 206,
+    HTTP_MULTI_STATUS = 207,	/* RFC2518 section 10.2 */
     HTTP_MULTIPLE_CHOICES = 300,
     HTTP_MOVED_PERMANENTLY = 301,
     HTTP_MOVED_TEMPORARILY = 302,
@@ -431,12 +434,16 @@ typedef enum {
     HTTP_REQUEST_ENTITY_TOO_LARGE = 413,
     HTTP_REQUEST_URI_TOO_LARGE = 414,
     HTTP_UNSUPPORTED_MEDIA_TYPE = 415,
+    HTTP_UNPROCESSABLE_ENTITY = 422,	/* RFC2518 section 10.3 */
+    HTTP_LOCKED = 423,		/* RFC2518 section 10.4 */
+    HTTP_FAILED_DEPENDENCY = 424,	/* RFC2518 section 10.5 */
     HTTP_INTERNAL_SERVER_ERROR = 500,
     HTTP_NOT_IMPLEMENTED = 501,
     HTTP_BAD_GATEWAY = 502,
     HTTP_SERVICE_UNAVAILABLE = 503,
     HTTP_GATEWAY_TIMEOUT = 504,
     HTTP_HTTP_VERSION_NOT_SUPPORTED = 505,
+    HTTP_INSUFFICIENT_STORAGE = 507,	/* RFC2518 section 10.6 */
     HTTP_INVALID_HEADER = 600	/* Squid header parsing error */
 } http_status;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.66 1999/10/04 05:05:11 wessels Exp $
+ * $Id: forward.cc,v 1.67 1999/12/30 17:36:32 wessels Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -413,8 +413,7 @@ fwdServersFree(FwdServer ** FS)
 }
 
 void
-fwdStart(int fd, StoreEntry * e, request_t * r, struct in_addr client_addr,
-    struct in_addr my_addr)
+fwdStart(int fd, StoreEntry * e, request_t * r)
 {
     FwdState *fwdState;
     aclCheck_t ch;
@@ -425,19 +424,20 @@ fwdStart(int fd, StoreEntry * e, request_t * r, struct in_addr client_addr,
      * from peer_digest.c, asn.c, netdb.c, etc and should always
      * be allowed.  yuck, I know.
      */
-    if (client_addr.s_addr != no_addr.s_addr) {
+    if (r->client_addr.s_addr != no_addr.s_addr) {
 	/*      
 	 * Check if this host is allowed to fetch MISSES from us (miss_access)
 	 */
 	memset(&ch, '\0', sizeof(aclCheck_t));
-	ch.src_addr = client_addr;
-	ch.my_addr = my_addr;
+	ch.src_addr = r->client_addr;
+	ch.my_addr = r->my_addr;
+	ch.my_port = r->my_port;
 	ch.request = r;
 	answer = aclCheckFast(Config.accessList.miss, &ch);
 	if (answer == 0) {
 	    err = errorCon(ERR_FORWARDING_DENIED, HTTP_FORBIDDEN);
 	    err->request = requestLink(r);
-	    err->src_addr = client_addr;
+	    err->src_addr = r->client_addr;
 	    errorAppendEntry(e, err);
 	    return;
 	}
@@ -489,6 +489,7 @@ fwdCheckDeferRead(int fd, void *data)
 {
     StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
+    int rc = 0;
     if (mem == NULL)
 	return 0;
 #if URL_CHECKSUM_DEBUG
@@ -499,13 +500,21 @@ fwdCheckDeferRead(int fd, void *data)
 	(void) 0;
     else if (delayIsNoDelay(fd))
 	(void) 0;
-    else if (delayMostBytesWanted(mem, 1) == 0)
-	return 1;
+    else {
+	int i = delayMostBytesWanted(mem, INT_MAX);
+	if (0 == i)
+	    return 1;
+	/* was: rc = -(rc != INT_MAX); */
+	else if (INT_MAX == i)
+	    rc = 0;
+	else
+	    rc = -1;
+    }
 #endif
     if (EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT))
-	return 0;
+	return rc;
     if (mem->inmem_hi - storeLowestMemReaderOffset(e) < READ_AHEAD_GAP)
-	return 0;
+	return rc;
     return 1;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.287 1999/10/04 05:05:12 wessels Exp $
+ * $Id: ftp.cc,v 1.288 1999/12/30 17:36:33 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -165,10 +165,11 @@ static void ftpUnhack(FtpStateData * ftpState);
 static void ftpScheduleReadControlReply(FtpStateData *, int);
 static void ftpHandleControlReply(FtpStateData *);
 static char *ftpHtmlifyListEntry(char *line, FtpStateData * ftpState);
-static void ftpFailed(FtpStateData *, err_type /* ERR_NONE if unknown */ );
-static void ftpFailedErrorMessage(FtpStateData *, err_type /* ERR_NONE if unknown */ );
+static void ftpFailed(FtpStateData *, err_type);
+static void ftpFailedErrorMessage(FtpStateData *, err_type);
 
-/* State machine functions
+/*
+ * State machine functions
  * send == state transition
  * read == wait for response, and select next state transition
  * other == Transition logic
@@ -336,6 +337,12 @@ ftpTimeout(int fd, void *data)
     FtpStateData *ftpState = data;
     StoreEntry *entry = ftpState->entry;
     debug(9, 4) ("ftpTimeout: FD %d: '%s'\n", fd, storeUrl(entry));
+    if (SENT_PASV == ftpState->state && fd == ftpState->data.fd) {
+	/* stupid ftp.netscape.com */
+	ftpState->fwd->flags.dont_retry = 0;
+	ftpState->fwd->flags.ftp_pasv_failed = 1;
+	debug(9, 1) ("ftpTimeout: timeout in SENT_PASV state\n");
+    }
     ftpFailed(ftpState, ERR_READ_TIMEOUT);
     /* ftpFailed closes ctrl.fd and frees ftpState */
 }
@@ -1084,7 +1091,6 @@ ftpStart(FwdState * fwd)
     ftpState->data.size = SQUID_TCP_SO_RCVBUF;
     ftpState->data.freefunc = xfree;
     ftpScheduleReadControlReply(ftpState, 0);
-    commSetTimeout(fd, Config.Timeout.read, ftpTimeout, ftpState);
 }
 
 /* ====================================================================== */
@@ -1203,6 +1209,14 @@ ftpScheduleReadControlReply(FtpStateData * ftpState, int buffered_ok)
 	    ftpReadControlReply,
 	    ftpState,
 	    Config.Timeout.read);
+	/*
+	 * Cancel the timeout on the Data socket (if any) and
+	 * establish one on the control socket.
+	 */
+	if (ftpState->data.fd > -1)
+	    commSetTimeout(ftpState->data.fd, -1, NULL, NULL);
+	commSetTimeout(ftpState->ctrl.fd, Config.Timeout.read, ftpTimeout,
+	    ftpState);
     }
 }
 
@@ -1671,6 +1685,11 @@ ftpSendPasv(FtpStateData * ftpState)
     snprintf(cbuf, 1024, "PASV\r\n");
     ftpWriteCommand(cbuf, ftpState);
     ftpState->state = SENT_PASV;
+    /*
+     * ugly hack for ftp servers like ftp.netscape.com that sometimes
+     * dont acknowledge PORT commands.
+     */
+    commSetTimeout(ftpState->data.fd, 15, ftpTimeout, ftpState);
 }
 
 static void
@@ -1687,8 +1706,6 @@ ftpReadPasv(FtpStateData * ftpState)
     debug(9, 3) ("This is ftpReadPasv\n");
     if (code != 227) {
 	debug(9, 3) ("PASV not supported by remote end\n");
-	comm_close(ftpState->data.fd);
-	ftpState->data.fd = -1;
 	ftpSendPort(ftpState);
 	return;
     }
@@ -1753,6 +1770,14 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
     socklen_t addr_len;
     int on = 1;
     u_short port = 0;
+    /*
+     * * Tear down any old data connection if any. We are about to
+     * * establish a new one.
+     */
+    if (ftpState->data.fd > 0) {
+	comm_close(ftpState->data.fd);
+	ftpState->data.fd = -1;
+    }
     /*
      * Set up a listen socket on the same local address as the
      * control connection.
@@ -1827,8 +1852,6 @@ ftpReadPort(FtpStateData * ftpState)
     if (code != 200) {
 	/* Fall back on using the same port as the control connection */
 	debug(9, 3) ("PORT not supported by remote end\n");
-	comm_close(ftpState->data.fd);
-	ftpState->data.fd = -1;
 	ftpOpenListenSocket(ftpState, 1);
     }
     ftpRestOrList(ftpState);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.85 1999/07/13 14:51:13 wessels Exp $
+ * $Id: globals.h,v 1.86 1999/12/30 17:36:35 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -112,7 +112,7 @@ extern struct timeval squid_start;
 extern time_t squid_curtime;	/* 0 */
 extern int shutting_down;	/* 0 */
 extern int reconfiguring;	/* 0 */
-extern int store_dirs_rebuilding;	/* 0 */
+extern int store_dirs_rebuilding;	/* 1 */
 extern int store_swap_size;	/* 0 */
 extern unsigned long store_mem_size;	/* 0 */
 extern time_t hit_only_mode_until;	/* 0 */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: htcp.cc,v 1.28 1999/10/04 05:05:14 wessels Exp $
+ * $Id: htcp.cc,v 1.29 1999/12/30 17:36:35 wessels Exp $
  *
  * DEBUG: section 31    Hypertext Caching Protocol
  * AUTHOR: Duane Wesssels
@@ -57,20 +57,20 @@ struct _htcpHeader {
 struct _htcpDataHeader {
     u_short length;
 #if !WORDS_BIGENDIAN
-    u_char opcode:4;
-    u_char response:4;
+    unsigned int opcode:4;
+    unsigned int response:4;
 #else
-    u_char response:4;
-    u_char opcode:4;
+    unsigned int response:4;
+    unsigned int opcode:4;
 #endif
 #if !WORDS_BIGENDIAN
-    u_char reserved:6;
-    u_char F1:1;
-    u_char RR:1;
+    unsigned int reserved:6;
+    unsigned int F1:1;
+    unsigned int RR:1;
 #else
-    u_char RR:1;
-    u_char F1:1;
-    u_char reserved:6;
+    unsigned int RR:1;
+    unsigned int F1:1;
+    unsigned int reserved:6;
 #endif
     u_num32 msg_id;
 };
@@ -552,6 +552,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, struct
     stuff.rr = RR_RESPONSE;
     stuff.f1 = 0;
     stuff.response = e ? 0 : 1;
+    debug(31, 3) ("htcpTstReply: response = %d\n", stuff.response);
     stuff.msg_id = dhdr->msg_id;
     if (spec) {
 	memBufDefInit(&mb);
@@ -614,17 +615,30 @@ htcpCheckHit(const htcpSpecifier * s)
     request_t *request;
     method_t m = urlParseMethod(s->method);
     StoreEntry *e = storeGetPublic(s->uri, m);
-    if (NULL == e)
+    char *blk_end;
+    if (NULL == e) {
+	debug(31, 3) ("htcpCheckHit: NO; public object not found\n");
 	return NULL;
-    if (!storeEntryValidToSend(e))
+    }
+    if (!storeEntryValidToSend(e)) {
+	debug(31, 3) ("htcpCheckHit: NO; entry not valid to send\n");
 	return NULL;
+    }
     request = urlParse(m, s->uri);
-    if (NULL == request)
+    if (NULL == request) {
+	debug(31, 3) ("htcpCheckHit: NO; failed to parse URL\n");
 	return NULL;
-    if (!httpRequestParseHeader(request, s->req_hdrs))
+    }
+    blk_end = s->req_hdrs + strlen(s->req_hdrs);
+    if (!httpHeaderParse(&request->header, s->req_hdrs, blk_end)) {
+	debug(31, 3) ("htcpCheckHit: NO; failed to parse request headers\n");
 	e = NULL;
-    else if (refreshCheckHTCP(e, request))
+    } else if (refreshCheckHTCP(e, request)) {
+	debug(31, 3) ("htcpCheckHit: NO; cached response is stale\n");
 	e = NULL;
+    } else {
+	debug(31, 3) ("htcpCheckHit: YES!?\n");
+    }
     requestDestroy(request);
     return e;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.354 1999/10/04 05:05:15 wessels Exp $
+ * $Id: http.cc,v 1.355 1999/12/30 17:36:36 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -132,6 +132,7 @@ static void
 httpMaybeRemovePublic(StoreEntry * e, http_status status)
 {
     int remove = 0;
+    int forbidden = 0;
     StoreEntry *pe;
     if (!EBIT_TEST(e->flags, KEY_PRIVATE))
 	return;
@@ -141,34 +142,61 @@ httpMaybeRemovePublic(StoreEntry * e, http_status status)
     case HTTP_MULTIPLE_CHOICES:
     case HTTP_MOVED_PERMANENTLY:
     case HTTP_MOVED_TEMPORARILY:
-    case HTTP_FORBIDDEN:
-    case HTTP_NOT_FOUND:
-    case HTTP_METHOD_NOT_ALLOWED:
     case HTTP_GONE:
+    case HTTP_NOT_FOUND:
 	remove = 1;
 	break;
+    case HTTP_FORBIDDEN:
+    case HTTP_METHOD_NOT_ALLOWED:
+	forbidden = 1;
+	break;
 #if WORK_IN_PROGRESS
     case HTTP_UNAUTHORIZED:
-	remove = 1;
+	forbidden = 1;
 	break;
 #endif
     default:
-	remove = 0;
+#if QUESTIONABLE
+	/*
+	 * Any 2xx response should eject previously cached entities...
+	 */
+	if (status >= 200 && status < 300)
+	    remove = 1;
+#endif
 	break;
     }
-    if (!remove)
+    if (!remove && !forbidden)
 	return;
     assert(e->mem_obj);
     if ((pe = storeGetPublic(e->mem_obj->url, e->mem_obj->method)) != NULL) {
 	assert(e != pe);
 	storeRelease(pe);
     }
-    if (e->mem_obj->method == METHOD_GET) {
-	/* A fresh GET should eject old HEAD objects */
-	if ((pe = storeGetPublic(e->mem_obj->url, METHOD_HEAD)) != NULL) {
+    /*
+     * Also remove any cached HEAD response in case the object has
+     * changed.
+     */
+    if ((pe = storeGetPublic(e->mem_obj->url, METHOD_HEAD)) != NULL) {
+	assert(e != pe);
+	storeRelease(pe);
+    }
+    if (forbidden)
+	return;
+    switch (e->mem_obj->method) {
+    case METHOD_PUT:
+    case METHOD_DELETE:
+    case METHOD_PROPPATCH:
+    case METHOD_MKCOL:
+    case METHOD_MOVE:
+	/*
+	 * Remove any cached GET object if it is beleived that the
+	 * object may have changed as a result of other methods
+	 */
+	if ((pe = storeGetPublic(e->mem_obj->url, METHOD_GET)) != NULL) {
 	    assert(e != pe);
 	    storeRelease(pe);
 	}
+	break;
     }
 }
 
@@ -653,9 +681,16 @@ httpBuildRequestHeader(request_t * request,
 		request->flags.auth = 0;	/* We have used the authentication */
 	    break;
 	case HDR_HOST:
-	    /* Don't use client's Host: header for redirected requests */
-	    if (!request->flags.redirected || !Config.onoff.redir_rewrites_host)
-		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+	    /*
+	     * Normally Squid does not copy the Host: header from
+	     * a client request into the forwarded request headers.
+	     * However, there is one case when we do: If the URL
+	     * went through our redirector and the admin configured
+	     * 'redir_rewrites_host' to be off.
+	     */
+	    if (request->flags.redirected)
+		if (!Config.onoff.redir_rewrites_host)
+		    httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
 	    break;
 	case HDR_IF_MODIFIED_SINCE:
 	    /* append unless we added our own;
@@ -696,15 +731,15 @@ httpBuildRequestHeader(request_t * request,
 	httpHeaderPutStr(hdr_out, HDR_USER_AGENT, Config.fake_ua);
 
     /* append Via */
-    {
+    if (httpRequestHdrAllowedByName(HDR_VIA)) {
 	String strVia = httpHeaderGetList(hdr_in, HDR_VIA);
 	snprintf(bbuf, BBUF_SZ, "%3.1f %s", orig_request->http_ver, ThisCache);
 	strListAdd(&strVia, bbuf, ',');
 	httpHeaderPutStr(hdr_out, HDR_VIA, strBuf(strVia));
 	stringClean(&strVia);
     }
     /* append X-Forwarded-For */
-    {
+    if (httpRequestHdrAllowedByName(HDR_X_FORWARDED_FOR)) {
 	String strFwd = httpHeaderGetList(hdr_in, HDR_X_FORWARDED_FOR);
 	strListAdd(&strFwd, (cfd < 0 ? "unknown" : fd_table[cfd].ipaddr), ',');
 	httpHeaderPutStr(hdr_out, HDR_X_FORWARDED_FOR, strBuf(strFwd));
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icp_v2.cc,v 1.60 1999/06/14 03:02:06 wessels Exp $
+ * $Id: icp_v2.cc,v 1.61 1999/12/30 17:36:37 wessels Exp $
  *
  * DEBUG: section 12    Internet Cache Protocol
  * AUTHOR: Duane Wessels
@@ -427,7 +427,8 @@ icpConnectionsOpen(void)
 	0);
     for (s = Config.mcast_group_list; s; s = s->next)
 	ipcache_nbgethostbyname(s->key, mcastJoinGroups, NULL);
-    debug(12, 1) ("Accepting ICP messages on port %d, FD %d.\n",
+    debug(12, 1) ("Accepting ICP messages at %s, port %d, FD %d.\n",
+	inet_ntoa(Config.Addrs.udp_incoming),
 	(int) port, theInIcpConnection);
     if ((addr = Config.Addrs.udp_outgoing).s_addr != no_addr.s_addr) {
 	enter_suid();
@@ -1,6 +1,6 @@
 
 /*
- * $Id: internal.cc,v 1.16 1999/08/02 06:18:38 wessels Exp $
+ * $Id: internal.cc,v 1.17 1999/12/30 17:36:38 wessels Exp $
  *
  * DEBUG: section 76    Internal Squid Object handling
  * AUTHOR: Duane, Alex, Henrik
@@ -117,7 +117,8 @@ internalRemoteUri(const char *host, u_short port, const char *dir, const char *n
 char *
 internalLocalUri(const char *dir, const char *name)
 {
-    return internalRemoteUri(getMyHostname(), Config.Port.http->i, dir, name);
+    return internalRemoteUri(getMyHostname(),
+	ntohs(Config.Sockaddr.http->s.sin_port), dir, name);
 }
 
 const char *
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipc.cc,v 1.16 1999/10/04 05:05:16 wessels Exp $
+ * $Id: ipc.cc,v 1.17 1999/12/30 17:36:39 wessels Exp $
  *
  * DEBUG: section 54    Interprocess Communication
  * AUTHOR: Duane Wessels
@@ -252,7 +252,8 @@ ipcCreate(int type, const char *prog, char *const args[], const char *name, int
      */
     do {
 	x = open(_PATH_DEVNULL, 0, 0444);
-	commSetCloseOnExec(x);
+	if (x > -1)
+	    commSetCloseOnExec(x);
     } while (x < 3);
     t1 = dup(crfd);
     t2 = dup(cwfd);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.217 1999/06/17 22:20:40 wessels Exp $
+ * $Id: ipcache.cc,v 1.218 1999/12/30 17:36:40 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -155,7 +155,8 @@ ipcacheExpiredEntry(ipcache_entry * i)
     if (i->locks != 0)
 	return 0;
     if (i->addrs.count == 0)
-	return 1;
+	if (i->status != IP_NEGATIVE_CACHED)
+	    return 1;
     if (i->expires > squid_curtime)
 	return 0;
     return 1;
@@ -340,7 +341,7 @@ ipcacheParse(rfc1035_rr * answers, int nr)
     int j;
     int na = 0;
     memset(&i, '\0', sizeof(i));
-    i.expires = squid_curtime;
+    i.expires = squid_curtime + Config.negativeDnsTtl;
     i.status = IP_NEGATIVE_CACHED;
     if (nr < 0) {
 	debug(14, 3) ("ipcacheParse: Lookup failed (error %d)\n",
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.306 1999/12/10 18:11:02 wessels Exp $
+ * $Id: main.cc,v 1.307 1999/12/30 17:36:41 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -439,9 +439,9 @@ mainInitialize(void)
     squid_signal(SIGCHLD, sig_child, SA_NODEFER | SA_RESTART);
 
     setEffectiveUser();
-    assert(Config.Port.http);
+    assert(Config.Sockaddr.http);
     if (httpPortNumOverride != 1)
-	Config.Port.http->i = (u_short) httpPortNumOverride;
+	Config.Sockaddr.http->s.sin_port = htons(httpPortNumOverride);
     if (icpPortNumOverride != 1)
 	Config.Port.icp = (u_short) icpPortNumOverride;
 
@@ -546,6 +546,7 @@ main(int argc, char **argv)
     int errcount = 0;
     int n;			/* # of GC'd objects */
     time_t loop_delay;
+    mode_t oldmask;
 
     debug_log = stderr;
     if (FD_SETSIZE < Squid_MaxFD)
@@ -567,6 +568,16 @@ main(int argc, char **argv)
 #endif
 #endif /* HAVE_MALLOPT */
 
+    /*
+     * The plan here is to set the umask to 007 (deny others for
+     * read,write,execute), but only if the umask is not already
+     * set.  Unfortunately, there is no way to get the current
+     * umask value without setting it.
+     */
+    oldmask = umask(S_IRWXO);
+    if (oldmask)
+	umask(oldmask);
+
     memset(&local_addr, '\0', sizeof(struct in_addr));
     safe_inet_addr(localhost, &local_addr);
     memset(&any_addr, '\0', sizeof(struct in_addr));
@@ -786,9 +797,6 @@ watch_child(char *argv[])
 #endif
     for (i = 0; i < Squid_MaxFD; i++)
 	close(i);
-#if NOT_NEEDED
-    umask(0);
-#endif
     for (;;) {
 	mainStartScript(argv[0]);
 	if ((pid = fork()) == 0) {
@@ -906,6 +914,7 @@ SquidShutdown(void *unused)
 #endif
     debug(1, 1) ("Squid Cache (Version %s): Exiting normally.\n",
 	version_string);
-    fclose(debug_log);
+    if (debug_log)
+	fclose(debug_log);
     exit(0);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.276 1999/10/04 05:05:19 wessels Exp $
+ * $Id: neighbors.cc,v 1.277 1999/12/30 17:36:43 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -102,7 +102,7 @@ neighborType(const peer * p, const request_t * request)
 {
     const struct _domain_type *d = NULL;
     for (d = p->typelist; d; d = d->next) {
-	if (0 == matchDomainName(d->domain, request->host))
+	if (0 == matchDomainName(request->host, d->domain))
 	    if (d->type != PEER_NONE)
 		return d->type;
     }
@@ -136,7 +136,7 @@ peerAllowedToUse(const peer * p, request_t * request)
 	return do_ping;
     do_ping = 0;
     for (d = p->peer_domain; d; d = d->next) {
-	if (0 == matchDomainName(d->domain, request->host)) {
+	if (0 == matchDomainName(request->host, d->domain)) {
 	    do_ping = d->do_ping;
 	    break;
 	}
@@ -148,6 +148,7 @@ peerAllowedToUse(const peer * p, request_t * request)
 	return do_ping;
     checklist.src_addr = request->client_addr;
     checklist.my_addr = request->my_addr;
+    checklist.my_port = request->my_port;
     checklist.request = request;
     return aclCheckFast(p->access, &checklist);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.140 1999/10/04 05:05:20 wessels Exp $
+ * $Id: net_db.cc,v 1.141 1999/12/30 17:36:44 wessels Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -975,7 +975,7 @@ netdbExchangeStart(void *data)
     ex->r->flags.loopdetect = 1;	/* cheat! -- force direct */
     if (p->login)
 	xstrncpy(ex->r->login, p->login, MAX_LOGIN_SZ);
-    fwdStart(-1, ex->e, ex->r, no_addr, no_addr);
+    fwdStart(-1, ex->e, ex->r);
 #endif
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.71 1999/10/04 05:05:20 wessels Exp $
+ * $Id: peer_digest.cc,v 1.72 1999/12/30 17:36:45 wessels Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -275,7 +275,12 @@ peerDigestRequest(PeerDigest * pd)
     pd->flags.requested = 1;
 
     /* compute future request components */
-    url = internalRemoteUri(p->host, p->http_port, "/squid-internal-periodic/", StoreDigestFileName);
+    if (p->digest_url)
+	url = xstrdup(p->digest_url);
+    else
+	url = internalRemoteUri(p->host, p->http_port,
+	    "/squid-internal-periodic/", StoreDigestFileName);
+
     key = storeKeyPublic(url, METHOD_GET);
     debug(72, 2) ("peerDigestRequest: %s key: %s\n", url, storeKeyText(key));
     req = urlParse(METHOD_GET, url);
@@ -318,7 +323,7 @@ peerDigestRequest(PeerDigest * pd)
 
     /* push towards peer cache */
     debug(72, 3) ("peerDigestRequest: forwarding to fwdStart...\n");
-    fwdStart(-1, e, req, no_addr, no_addr);
+    fwdStart(-1, e, req);
     cbdataLock(fetch);
     cbdataLock(fetch->pd);
     storeClientCopy(e, 0, 0, 4096, memAllocate(MEM_4K_BUF),
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.101 1999/10/04 05:05:21 wessels Exp $
+ * $Id: peer_select.cc,v 1.102 1999/12/30 17:36:45 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -237,8 +237,6 @@ peerSelectFoo(ps_state * ps)
 	    ps->acl_checklist = aclChecklistCreate(
 		Config.accessList.AlwaysDirect,
 		request,
-		request->client_addr,
-		request->my_addr,
 		NULL,		/* user agent */
 		NULL);		/* ident */
 	    aclNBCheck(ps->acl_checklist,
@@ -251,8 +249,6 @@ peerSelectFoo(ps_state * ps)
 	    ps->acl_checklist = aclChecklistCreate(
 		Config.accessList.NeverDirect,
 		request,
-		request->client_addr,
-		request->my_addr,
 		NULL,		/* user agent */
 		NULL);		/* ident */
 	    aclNBCheck(ps->acl_checklist,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.348 1999/12/01 04:28:08 wessels Exp $
+ * $Id: protos.h,v 1.349 1999/12/30 17:36:46 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -44,8 +44,6 @@ extern void fvdbCountForw(const char *key);
 
 extern aclCheck_t *aclChecklistCreate(const struct _acl_access *,
     request_t *,
-    struct in_addr src,
-    struct in_addr me,
     const char *user_agent,
     const char *ident);
 extern void aclNBCheck(aclCheck_t *, PF *, void *);
@@ -143,6 +141,7 @@ extern StoreEntry *clientCreateStoreEntry(clientHttpRequest *, method_t, request
 extern int isTcpHit(log_type);
 
 extern int commSetNonBlocking(int fd);
+extern int commUnsetNonBlocking(int fd);
 extern void commSetCloseOnExec(int fd);
 extern int comm_accept(int fd, struct sockaddr_in *, struct sockaddr_in *);
 extern void comm_close(int fd);
@@ -336,6 +335,7 @@ extern HttpHdrCc *httpHdrCcDup(const HttpHdrCc * cc);
 extern void httpHdrCcPackInto(const HttpHdrCc * cc, Packer * p);
 extern void httpHdrCcJoinWith(HttpHdrCc * cc, const HttpHdrCc * new_cc);
 extern void httpHdrCcSetMaxAge(HttpHdrCc * cc, int max_age);
+extern void httpHdrCcSetSMaxAge(HttpHdrCc * cc, int s_maxage);
 extern void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
 extern void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
@@ -487,6 +487,7 @@ extern void httpRequestSwapOut(const request_t * req, StoreEntry * e);
 extern void httpRequestPack(const request_t * req, Packer * p);
 extern int httpRequestPrefixLen(const request_t * req);
 extern int httpRequestHdrAllowed(const HttpHeaderEntry * e, String * strConnection);
+extern int httpRequestHdrAllowedByName(http_hdr_type id);
 
 extern void icmpOpen(void);
 extern void icmpClose(void);
@@ -677,7 +678,7 @@ extern void peerDigestNotePeerGone(PeerDigest * pd);
 extern void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
 
 /* forward.c */
-extern void fwdStart(int, StoreEntry *, request_t *, struct in_addr, struct in_addr);
+extern void fwdStart(int, StoreEntry *, request_t *);
 extern DEFER fwdCheckDeferRead;
 extern void fwdFail(FwdState *, ErrorState *);
 extern void fwdUnregister(int fd, FwdState *);
@@ -831,7 +832,9 @@ extern int storeClientCopyPending(StoreEntry *, void *);
 extern void InvokeHandlers(StoreEntry *);
 extern int storeEntryValidToSend(StoreEntry *);
 extern void storeTimestampsSet(StoreEntry *);
+#if !HEAP_REPLACEMENT
 extern time_t storeExpiredReferenceAge(void);
+#endif
 extern void storeRegisterAbort(StoreEntry * e, STABH * cb, void *);
 extern void storeUnregisterAbort(StoreEntry * e);
 extern void storeMemObjectDump(MemObject * mem);
@@ -1074,7 +1077,7 @@ extern request_t *urlParse(method_t, char *);
 extern const char *urlCanonical(request_t *);
 extern char *urlRInternal(const char *host, u_short port, const char *dir, const char *name);
 extern char *urlInternal(const char *dir, const char *name);
-extern int matchDomainName(const char *d, const char *h);
+extern int matchDomainName(const char *host, const char *domain);
 extern int urlCheckRequest(const request_t *);
 extern int urlDefaultPort(protocol_t p);
 extern char *urlCanonicalClean(const request_t *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.82 1999/10/04 05:05:24 wessels Exp $
+ * $Id: redirect.cc,v 1.83 1999/12/30 17:36:48 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -163,8 +163,8 @@ redirectInit(void)
 	cachemgrRegister("redirector",
 	    "URL Redirector Stats",
 	    redirectStats, 0, 1);
+	init = 1;
     }
-    init++;
 }
 
 void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.56 1999/05/26 17:08:02 wessels Exp $
+ * $Id: send-announce.cc,v 1.57 1999/12/30 17:36:49 wessels Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -72,10 +72,10 @@ send_announce(const ipcache_addrs * ia, void *junk)
     sndbuf[0] = '\0';
     snprintf(tbuf, 256, "cache_version SQUID/%s\n", version_string);
     strcat(sndbuf, tbuf);
-    assert(Config.Port.http);
+    assert(Config.Sockaddr.http);
     snprintf(tbuf, 256, "Running on %s %d %d\n",
 	getMyHostname(),
-	(int) Config.Port.http->i,
+	(int) ntohs(Config.Sockaddr.http->s.sin_port),
 	(int) Config.Port.icp);
     strcat(sndbuf, tbuf);
     if (Config.adminEmail) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.195 1999/10/04 05:05:27 wessels Exp $
+ * $Id: squid.h,v 1.196 1999/12/30 17:36:50 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -186,6 +186,9 @@
 #if HAVE_GETOPT_H
 #include <getopt.h>
 #endif
+#if HAVE_LIMITS_H
+#include <limits.h>
+#endif
 
 #if HAVE_DIRENT_H
 #include <dirent.h>
@@ -233,6 +236,7 @@
 #ifdef HAVE_SYSLOG_H
 #ifdef _SQUID_AIX_
 #define _XOPEN_EXTENDED_SOURCE
+#define _XOPEN_SOURCE_EXTENDED 1
 #endif
 #include <syslog.h>
 #endif
@@ -374,7 +378,7 @@ struct rusage {
 /*
  * Mac OS X Server already has radix.h as a standard header, so
  * this causes conflicts.
-*/
+ */
 #ifndef _SQUID_APPLE_
 #include "radix.h"
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.100 1999/10/04 05:05:28 wessels Exp $
+ * $Id: ssl.cc,v 1.101 1999/12/30 17:36:51 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -119,7 +119,12 @@ static int
 sslDeferServerRead(int fdnotused, void *data)
 {
     SslStateData *s = data;
-    return delayBytesWanted(s->delay_id, 0, 1) == 0;
+    int i = delayBytesWanted(s->delay_id, 0, INT_MAX);
+    if (i == INT_MAX)
+	return 0;
+    if (i == 0)
+	return 1;
+    return -1;
 }
 #endif
 
@@ -155,7 +160,8 @@ sslSetSelect(SslStateData * sslState)
 		0);
 	}
 #if DELAY_POOLS
-	/* If this was allowed to return 0, there would be a possibility
+	/*
+	 * If this was allowed to return 0, there would be a possibility
 	 * of the socket becoming "hung" with data accumulating but no
 	 * write handler (server.len==0) and no read handler (!(0<0)) and
 	 * no data flowing in the other direction.  Hence the argument of
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.321 1999/10/04 05:05:29 wessels Exp $
+ * $Id: stat.cc,v 1.322 1999/12/30 17:36:52 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -385,7 +385,7 @@ statOpenfdObj(StoreEntry * sentry)
 static void
 info_get_mallstat(int size, int number, void *data)
 {
-    StoreEntry * sentry = data;
+    StoreEntry *sentry = data;
     if (number > 0)
 	storeAppendPrintf(sentry, "\t%d = %d\n", size, number);
 }
@@ -490,7 +490,8 @@ info_get(StoreEntry * sentry)
     storeAppendPrintf(sentry, "\tStorage Mem size:\t%d KB\n",
 	(int) (store_mem_size >> 10));
 #if HEAP_REPLACEMENT
-    /* The non-LRU policies do not use referenceAge */
+    storeAppendPrintf(sentry, "\tStorage Replacement Threshold:\t%f\n",
+	heap_peepminkey(store_heap));
 #else
     storeAppendPrintf(sentry, "\tStorage LRU Expiration Age:\t%6.2f days\n",
 	(double) storeExpiredReferenceAge() / 86400.0);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.509 1999/10/04 05:05:31 wessels Exp $
+ * $Id: store.cc,v 1.510 1999/12/30 17:36:53 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -107,7 +107,6 @@ static dlink_list inmem_list;
 static int store_pages_max = 0;
 static int store_swap_high = 0;
 static int store_swap_low = 0;
-static int store_swap_mid = 0;
 static Stack LateReleaseStack;
 
 #if URL_CHECKSUM_DEBUG
@@ -209,7 +208,7 @@ storeHashInsert(StoreEntry * e, const cache_key * key)
 	(void) 0;
     } else {
 	e->node = heap_insert(store_heap, e);
-	debug(20, 4) ("storeHashInsert: inserted node 0x%x\n", e->node);
+	debug(20, 4) ("storeHashInsert: inserted node %p\n", e->node);
     }
 #else
     dlinkAdd(e, &e->lru, &store_list);
@@ -222,7 +221,7 @@ storeHashDelete(StoreEntry * e)
     hash_remove_link(store_table, (hash_link *) e);
 #if HEAP_REPLACEMENT
     if (e->node) {
-	debug(20, 4) ("storeHashDelete: deleting node 0x%x\n", e->node);
+	debug(20, 4) ("storeHashDelete: deleting node %p\n", e->node);
 	heap_delete(store_heap, e->node);
 	e->node = NULL;
     }
@@ -263,7 +262,7 @@ storeLockObject(StoreEntry * e)
 	 * replacement algorithm.  We can't do that so we will just
 	 * have to handle them.
 	 */
-	debug(20, 4) ("storeLockObject: just locked node 0x%x\n", e->node);
+	debug(20, 4) ("storeLockObject: just locked node %p\n", e->node);
 #else
 	dlinkDelete(&e->lru, &store_list);
 	dlinkAdd(e, &e->lru, &store_list);
@@ -303,6 +302,9 @@ storeUnlockObject(StoreEntry * e)
     if (e->store_status == STORE_PENDING)
 	EBIT_SET(e->flags, RELEASE_REQUEST);
     assert(storePendingNClients(e) == 0);
+#if HEAP_REPLACEMENT
+    storeHeapPositionUpdate(e);
+#endif
     if (EBIT_TEST(e->flags, RELEASE_REQUEST))
 	storeRelease(e);
     else if (storeKeepInMemory(e)) {
@@ -317,7 +319,7 @@ storeUnlockObject(StoreEntry * e)
 	     * Squid/LRU is moving things around in the linked list in order
 	     * to keep from bumping into them when purging from the LRU list.
 	     */
-	    debug(20, 4) ("storeUnlockObject: purged private node 0x%x\n",
+	    debug(20, 4) ("storeUnlockObject: purged private node %p\n",
 		e->node);
 #else
 	    dlinkDelete(&e->lru, &store_list);
@@ -565,6 +567,9 @@ storeCheckCachable(StoreEntry * e)
     } else if (e->mem_obj->inmem_hi > Config.Store.maxObjectSize) {
 	debug(20, 2) ("storeCheckCachable: NO: too big\n");
 	store_check_cachable_hist.no.too_big++;
+    } else if (e->mem_obj->reply->content_length > (int) Config.Store.maxObjectSize) {
+	debug(20, 2) ("storeCheckCachable: NO: too big\n");
+	store_check_cachable_hist.no.too_big++;
     } else if (EBIT_TEST(e->flags, KEY_PRIVATE)) {
 	debug(20, 3) ("storeCheckCachable: NO: private key\n");
 	store_check_cachable_hist.no.private_key++;
@@ -717,8 +722,8 @@ storeGetMemSpace(int size)
     dlink_node *m;
     dlink_node *prev = NULL;
 #else
-    heap *heap = inmem_heap;
-    heap_key age, min_age = 0.0;
+    heap_key age;
+    heap_key min_age = 0.0;
     link_list *locked_entries = NULL;
 #endif
     if (squid_curtime == last_check)
@@ -731,9 +736,9 @@ storeGetMemSpace(int size)
 	return;
     debug(20, 2) ("storeGetMemSpace: Starting, need %d pages\n", pages_needed);
 #if HEAP_REPLACEMENT
-    while (heap_nodes(heap) > 0) {
-	age = heap_peepminkey(heap);
-	e = heap_extractmin(heap);
+    while (heap_nodes(inmem_heap) > 0) {
+	age = heap_peepminkey(inmem_heap);
+	e = heap_extractmin(inmem_heap);
 	e->mem_obj->node = NULL;	/* no longer in the heap */
 	if (storeEntryLocked(e)) {
 	    locked++;
@@ -754,7 +759,7 @@ storeGetMemSpace(int size)
      * Increase the heap age factor.
      */
     if (min_age > 0)
-	heap->age = min_age;
+	inmem_heap->age = min_age;
     /*
      * Reinsert all bumped locked entries back into heap...
      */
@@ -812,8 +817,8 @@ storeMaintainSwapSpace(void *datanotused)
     dlink_node *m;
     dlink_node *prev = NULL;
 #else
-    heap *heap = store_heap;
-    heap_key age, min_age = 0.0;
+    heap_key age;
+    heap_key min_age = 0.0;
     link_list *locked_entries = NULL;
 #if HEAP_REPLACEMENT_DEBUG
     if (!verify_heap_property(store_heap)) {
@@ -835,15 +840,15 @@ storeMaintainSwapSpace(void *datanotused)
     debug(20, 3) ("storeMaintainSwapSpace: f=%f, max_scan=%d, max_remove=%d\n",
 	f, max_scan, max_remove);
 #if HEAP_REPLACEMENT
-    while (heap_nodes(heap) > 0) {
+    while (heap_nodes(store_heap) > 0) {
 	if (store_swap_size < store_swap_low)
 	    break;
 	if (expired >= max_remove)
 	    break;
 	if (scanned >= max_scan)
 	    break;
-	age = heap_peepminkey(heap);
-	e = heap_extractmin(heap);
+	age = heap_peepminkey(store_heap);
+	e = heap_extractmin(store_heap);
 	e->node = NULL;		/* no longer in the heap */
 	scanned++;
 	if (storeEntryLocked(e)) {
@@ -882,12 +887,18 @@ storeMaintainSwapSpace(void *datanotused)
 	    linklistPush(&locked_entries, e);
 	    continue;
 	}
+	if (store_swap_size < store_swap_low)
+	    break;
+	else if (expired >= max_remove)
+	    break;
+	else if (scanned >= max_scan)
+	    break;
     }
     /*
      * Bump the heap age factor.
      */
-    if (min_age > 0)
-	heap->age = min_age;
+    if (min_age > 0.0)
+	store_heap->age = min_age;
     /*
      * Reinsert all bumped locked entries back into heap...
      */
@@ -1148,7 +1159,6 @@ storeConfigure(void)
 	    (float) Config.Swap.highWaterMark) / (float) 100);
     store_swap_low = (long) (((float) Config.Swap.maxSize *
 	    (float) Config.Swap.lowWaterMark) / (float) 100);
-    store_swap_mid = (store_swap_high >> 1) + (store_swap_low >> 1);
     store_pages_max = Config.memMaxSize / SM_PAGE_SIZE;
 }
 
@@ -1185,11 +1195,7 @@ storeCheckExpired(const StoreEntry * e)
 #endif
 }
 
-#if HEAP_REPLACEMENT
-/*
- * The non-LRU cache replacement policies do not use LRU referenceAge
- */
-#else
+#if !HEAP_REPLACEMENT
 /*
  * storeExpiredReferenceAge
  *
@@ -1360,7 +1366,7 @@ storeSetMemStatus(StoreEntry * e, int new_status)
 		    mem->url);
 	    } else {
 		mem->node = heap_insert(inmem_heap, e);
-		debug(20, 4) ("storeSetMemStatus: inserted mem node 0x%x\n",
+		debug(20, 4) ("storeSetMemStatus: inserted mem node %p\n",
 		    mem->node);
 	    }
 	}
@@ -1375,7 +1381,7 @@ storeSetMemStatus(StoreEntry * e, int new_status)
 	 */
 	if (mem->node) {
 	    heap_delete(inmem_heap, mem->node);
-	    debug(20, 4) ("storeSetMemStatus: deleted mem node 0x%x\n",
+	    debug(20, 4) ("storeSetMemStatus: deleted mem node %p\n",
 		mem->node);
 	    mem->node = NULL;
 	}
@@ -1466,8 +1472,7 @@ storeHeapPositionUpdate(StoreEntry * e)
 {
     if (e->node)
 	heap_update(store_heap, e->node, e);
-    assert(e->mem_obj);
-    if (e->mem_obj->node)
+    if (e->mem_obj && e->mem_obj->node)
 	heap_update(inmem_heap, e->mem_obj->node, e);
 }
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_client.cc,v 1.79 1999/12/01 04:24:27 wessels Exp $
+ * $Id: store_client.cc,v 1.80 1999/12/30 17:36:54 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Client-Side Interface
  * AUTHOR: Duane Wessels
@@ -102,7 +102,7 @@ storeClientType(StoreEntry * e)
      * If there is no disk file to open yet, we must make this a
      * mem client.  If we can't open the swapin file before writing
      * to the client, there is no guarantee that we will be able
-     * to open it later.
+     * to open it later when we really need it.
      */
     else if (e->swap_status == SWAPOUT_NONE)
 	return STORE_MEM_CLIENT;
@@ -124,9 +124,11 @@ storeClientListAdd(StoreEntry * e, void *data)
     assert(mem);
     if (storeClientListSearch(mem, data) != NULL)
 	return;
+    e->refcount++;
     mem->nclients++;
     sc = memAllocate(MEM_STORE_CLIENT);
     cbdataAdd(sc, memFree, MEM_STORE_CLIENT);	/* sc is callback_data for file_read */
+    cbdataLock(data);		/* locked while we point to it */
     sc->callback_data = data;
     sc->seen_offset = 0;
     sc->copy_offset = 0;
@@ -276,7 +278,18 @@ storeClientCopy3(StoreEntry * e, store_client * sc)
 	    /* yuck -- this causes a TCP_SWAPFAIL_MISS on the client side */
 	    sc->callback = NULL;
 	    callback(sc->callback_data, sc->copy_buf, -1);
-	    return;
+	} else if (!sc->flags.disk_io_pending) {
+	    sc->flags.disk_io_pending = 1;
+	    storeSwapInStart(sc);
+	    if (NULL == sc->swapin_sio) {
+		sc->flags.disk_io_pending = 0;
+		sc->callback = NULL;
+		callback(sc->callback_data, sc->copy_buf, -1);
+	    } else {
+		storeClientFileRead(sc);
+	    }
+	} else {
+	    debug(20, 2) ("storeClientCopy2: Averted multiple fd operation\n");
 	}
 	assert(!sc->flags.disk_io_pending);
 	storeSwapInStart(sc);
@@ -357,6 +370,8 @@ storeClientReadHeader(void *data, const char *buf, ssize_t len)
     size_t body_sz;
     size_t copy_sz;
     tlv *tlv_list;
+    tlv *t;
+    int swap_object_ok = 1;
     assert(sc->flags.disk_io_pending);
     sc->flags.disk_io_pending = 0;
     assert(sc->callback != NULL);
@@ -382,10 +397,40 @@ storeClientReadHeader(void *data, const char *buf, ssize_t len)
 	return;
     }
     /*
-     * XXX Here we should check the meta data and make sure we got
-     * the right object.
+     * Check the meta data and make sure we got the right object.
      */
+    for (t = tlv_list; t; t = t->next) {
+	switch (t->type) {
+	case STORE_META_KEY:
+	    assert(t->length == MD5_DIGEST_CHARS);
+	    if (memcmp(t->value, e->key, MD5_DIGEST_CHARS))
+		debug(20, 1) ("WARNING: swapin MD5 mismatch\n");
+	    break;
+	case STORE_META_URL:
+	    if (NULL == mem->url)
+		(void) 0;	/* can't check */
+	    else if (0 == strcasecmp(mem->url, t->value))
+		(void) 0;	/* a match! */
+	    else {
+		debug(20, 1) ("storeClientReadHeader: URL mismatch\n");
+		debug(20, 1) ("\t{%s} != {%s}\n", t->value, mem->url);
+		swap_object_ok = 0;
+		break;
+	    }
+	    break;
+	case STORE_META_STD:
+	    break;
+	default:
+	    debug(20, 1) ("WARNING: got unused STORE_META type %d\n", t->type);
+	    break;
+	}
+    }
     storeSwapTLVFree(tlv_list);
+    if (!swap_object_ok) {
+	sc->callback = NULL;
+	callback(sc->callback_data, sc->copy_buf, -1);
+	return;
+    }
     mem->swap_hdr_sz = swap_hdr_sz;
     mem->object_sz = e->swap_file_sz - swap_hdr_sz;
     /*
@@ -465,11 +510,13 @@ storeUnregister(StoreEntry * e, void *data)
 	debug(20, 3) ("storeUnregister: store_client for %s has a callback\n",
 	    mem->url);
 	sc->callback = NULL;
-	callback(sc->callback_data, sc->copy_buf, -1);
+	if (cbdataValid(sc->callback_data))
+	    callback(sc->callback_data, sc->copy_buf, -1);
     }
 #if DELAY_POOLS
     delayUnregisterDelayIdPtr(&sc->delay_id);
 #endif
+    cbdataUnlock(sc->callback_data);	/* we're done with it now */
     cbdataFree(sc);
     assert(e->lock_count > 0);
     if (mem->nclients == 0)
@@ -1,5 +1,5 @@
 /*
- * $Id: store_digest.cc,v 1.35 1999/09/07 22:15:11 wessels Exp $
+ * $Id: store_digest.cc,v 1.36 1999/12/30 17:36:55 wessels Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -66,21 +66,6 @@ typedef struct {
     int rej_coll_count;		/* #not accepted entries that collided with existing ones */
 } StoreDigestStats;
 
-/*
- * local constants (many of these are good candidates for SquidConfig
- */
-
-/* #bits per entry in store digest */
-static const int StoreDigestBitsPerEntry = 5;
-/* how often we want to rebuild the digest, in seconds */
-static const time_t StoreDigestRebuildPeriod = 60 * 60;
-/* how often we want to rewrite the digest after rebuild, in seconds */
-static const int StoreDigestRewritePeriod = 60 * 60;
-/* how many bytes to swap out at a time */
-static const int StoreDigestSwapOutChunkSize = SM_PAGE_SIZE;
-/* portion (0,1] of a hash table to be rescanned at a time */
-static const double StoreDigestRebuildChunkPercent = 0.10;
-
 /* local vars */
 static StoreDigestState sd_state;
 static StoreDigestStats sd_stats;
@@ -110,9 +95,15 @@ storeDigestInit(void)
 {
 #if USE_CACHE_DIGESTS
     const int cap = storeDigestCalcCap();
-    store_digest = cacheDigestCreate(cap, StoreDigestBitsPerEntry);
+
+    if (!Config.onoff.digest_generation) {
+	store_digest = NULL;
+	debug(71, 3) ("Local cache digest generation disabled\n");
+	return;
+    }
+    store_digest = cacheDigestCreate(cap, Config.digest.bits_per_entry);
     debug(71, 1) ("Local cache digest enabled; rebuild/rewrite every %d/%d sec\n",
-	StoreDigestRebuildPeriod, StoreDigestRewritePeriod);
+	Config.digest.rebuild_period, Config.digest.rewrite_period);
     memset(&sd_state, 0, sizeof(sd_state));
     cachemgrRegister("store_digest", "Store Digest",
 	storeDigestReport, 0, 1);
@@ -127,15 +118,20 @@ void
 storeDigestNoteStoreReady(void)
 {
 #if USE_CACHE_DIGESTS
-    storeDigestRebuildStart(NULL);
-    storeDigestRewriteStart(NULL);
+    if (Config.onoff.digest_generation) {
+	storeDigestRebuildStart(NULL);
+	storeDigestRewriteStart(NULL);
+    }
 #endif
 }
 
 void
 storeDigestDel(const StoreEntry * entry)
 {
 #if USE_CACHE_DIGESTS
+    if (!Config.onoff.digest_generation) {
+	return;
+    }
     assert(entry && store_digest);
     debug(71, 6) ("storeDigestDel: checking entry, key: %s\n",
 	storeKeyText(entry->key));
@@ -158,6 +154,9 @@ void
 storeDigestReport(StoreEntry * e)
 {
 #if USE_CACHE_DIGESTS
+    if (!Config.onoff.digest_generation) {
+	return;
+    }
     if (store_digest) {
 	cacheDigestReport(store_digest, "store", e);
 	storeAppendPrintf(e, "\t added: %d rejected: %d ( %.2f %%) del-ed: %d\n",
@@ -217,9 +216,9 @@ storeDigestAddable(const StoreEntry * e)
     }
     /* still here? check staleness */
     /* Note: We should use the time of the next rebuild, not (cur_time+period) */
-    if (refreshCheckDigest(e, StoreDigestRebuildPeriod)) {
+    if (refreshCheckDigest(e, Config.digest.rebuild_period)) {
 	debug(71, 6) ("storeDigestAdd: entry expires within %d secs, ignoring\n",
-	    StoreDigestRebuildPeriod);
+	    Config.digest.rebuild_period);
 	return 0;
     }
     /*
@@ -298,7 +297,8 @@ storeDigestRebuildFinish(void)
     sd_state.rebuild_lock = 0;
     sd_state.rebuild_count++;
     debug(71, 2) ("storeDigestRebuildFinish: done.\n");
-    eventAdd("storeDigestRebuildStart", storeDigestRebuildStart, NULL, (double) StoreDigestRebuildPeriod, 1);
+    eventAdd("storeDigestRebuildStart", storeDigestRebuildStart, NULL, (double)
+	Config.digest.rebuild_period, 1);
     /* resume pending Rewrite if any */
     if (sd_state.rewrite_lock)
 	storeDigestRewriteResume();
@@ -308,7 +308,8 @@ storeDigestRebuildFinish(void)
 static void
 storeDigestRebuildStep(void *datanotused)
 {
-    int bcount = (int) ceil(store_hash_buckets * StoreDigestRebuildChunkPercent);
+    int bcount = (int) ceil((double) store_hash_buckets *
+	(double) Config.digest.rebuild_chunk_percentage / 100.0);
     assert(sd_state.rebuild_lock);
     if (sd_state.rebuild_offset + bcount > store_hash_buckets)
 	bcount = store_hash_buckets - sd_state.rebuild_offset;
@@ -376,7 +377,7 @@ storeDigestRewriteResume(void)
     httpReplyReset(e->mem_obj->reply);
     httpReplySetHeaders(e->mem_obj->reply, 1.0, 200, "Cache Digest OK",
 	"application/cache-digest", store_digest->mask_size + sizeof(sd_state.cblock),
-	squid_curtime, squid_curtime + StoreDigestRewritePeriod);
+	squid_curtime, squid_curtime + Config.digest.rewrite_period);
     debug(71, 3) ("storeDigestRewrite: entry expires on %d (%+d)\n",
 	e->mem_obj->reply->expires, e->mem_obj->reply->expires - squid_curtime);
     storeBuffer(e);
@@ -406,7 +407,8 @@ storeDigestRewriteFinish(StoreEntry * e)
     cbdataFree(sd_state.rewrite_lock);
     sd_state.rewrite_lock = e = NULL;
     sd_state.rewrite_count++;
-    eventAdd("storeDigestRewriteStart", storeDigestRewriteStart, NULL, (double) StoreDigestRewritePeriod, 1);
+    eventAdd("storeDigestRewriteStart", storeDigestRewriteStart, NULL, (double)
+	Config.digest.rewrite_period, 1);
     /* resume pending Rebuild if any */
     if (sd_state.rebuild_lock)
 	storeDigestRebuildResume();
@@ -417,7 +419,7 @@ static void
 storeDigestSwapOutStep(void *data)
 {
     StoreEntry *e = data;
-    int chunk_size = StoreDigestSwapOutChunkSize;
+    int chunk_size = Config.digest.swapout_chunk_size;
     assert(e);
     assert(e == sd_state.rewrite_lock);
     /* _add_ check that nothing bad happened while we were waiting @?@ @?@ */
@@ -444,7 +446,8 @@ storeDigestCBlockSwapOut(StoreEntry * e)
     sd_state.cblock.count = htonl(store_digest->count);
     sd_state.cblock.del_count = htonl(store_digest->del_count);
     sd_state.cblock.mask_size = htonl(store_digest->mask_size);
-    sd_state.cblock.bits_per_entry = (unsigned char) StoreDigestBitsPerEntry;
+    sd_state.cblock.bits_per_entry = (unsigned char)
+	Config.digest.bits_per_entry;
     sd_state.cblock.hash_func_count = (unsigned char) CacheDigestHashFuncCount;
     storeAppend(e, (char *) &sd_state.cblock, sizeof(sd_state.cblock));
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir.cc,v 1.99 1999/12/01 04:28:08 wessels Exp $
+ * $Id: store_dir.cc,v 1.100 1999/12/30 17:36:56 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -394,6 +394,8 @@ storeDirWriteCleanLogs(int reopen)
 	}
     }
 #if HEAP_REPLACEMENT
+    if (NULL == store_heap)
+	return 0;
     for (node = 0; node < heap_nodes(store_heap); node++)
 #else
     for (m = store_list.tail; m; m = m->prev)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_rebuild.cc,v 1.66 1999/05/27 03:13:12 wessels Exp $
+ * $Id: store_rebuild.cc,v 1.67 1999/12/30 17:36:58 wessels Exp $
  *
  * DEBUG: section 20    Store Rebuild Routines
  * AUTHOR: Duane Wessels
@@ -173,10 +173,9 @@ storeRebuildStart(void)
     memset(&counts, '\0', sizeof(counts));
     rebuild_start = current_time;
     /*
-     * Normally store_dirs_rebuilding is incremented once for each
-     * cache_dir.  We increment it here as well for the disk storage
-     * system as a whole.  The corresponding decrement occurs in
-     * storeCleanup(), when it is finished.
+     * Note: store_dirs_rebuilding is initialized to 1 in globals.c.
+     * This prevents us from trying to write clean logs until we
+     * finished rebuilding for sure.  The corresponding decrement
+     * occurs in storeCleanup(), when it is finished.
      */
-    store_dirs_rebuilding++;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapout.cc,v 1.58 1999/08/02 06:18:47 wessels Exp $
+ * $Id: store_swapout.cc,v 1.59 1999/12/30 17:36:59 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapout Functions
  * AUTHOR: Duane Wessels
@@ -254,9 +254,6 @@ storeSwapOutFileClosed(void *data, int errflag, storeIOState * sio)
 	debug(20, 3) ("storeSwapOutFileClosed: SwapOut complete: '%s' to %08X\n",
 	    storeUrl(e), e->swap_file_number);
 	e->swap_file_sz = objectLen(e) + mem->swap_hdr_sz;
-#if HEAP_REPLACEMENT
-	storeHeapPositionUpdate(e);
-#endif
 	e->swap_status = SWAPOUT_DONE;
 	storeDirUpdateSwapSize(e->swap_file_number, e->swap_file_sz, 1);
 	if (storeCheckCachable(e)) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.307 1999/10/04 05:05:35 wessels Exp $
+ * $Id: structs.h,v 1.308 1999/12/30 17:37:00 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -144,6 +144,7 @@ struct _aclCheck_t {
     struct in_addr src_addr;
     struct in_addr dst_addr;
     struct in_addr my_addr;
+    unsigned short my_port;
     request_t *request;
 #if USE_IDENT
     ConnStateData *conn;	/* hack for ident */
@@ -191,6 +192,11 @@ struct _relist {
     relist *next;
 };
 
+struct _sockaddr_in_list {
+    struct sockaddr_in s;
+    sockaddr_in_list *next;
+};
+
 #if DELAY_POOLS
 struct _delaySpec {
     int restore_bps;
@@ -266,7 +272,6 @@ struct _SquidConfig {
     size_t maxRequestBodySize;
     size_t maxReplyBodySize;
     struct {
-	ushortlist *http;
 	u_short icp;
 #if USE_HTCP
 	u_short htcp;
@@ -275,6 +280,9 @@ struct _SquidConfig {
 	u_short snmp;
 #endif
     } Port;
+    struct {
+	sockaddr_in_list *http;
+    } Sockaddr;
 #if SQUID_SNMP
     struct {
 	char *configFile;
@@ -332,7 +340,6 @@ struct _SquidConfig {
 	u_short port;
     } Announce;
     struct {
-	struct in_addr tcp_incoming;
 	struct in_addr tcp_outgoing;
 	struct in_addr udp_incoming;
 	struct in_addr udp_outgoing;
@@ -399,6 +406,9 @@ struct _SquidConfig {
 	int strip_query_terms;
 	int redirector_bypass;
 	int ignore_unknown_nameservers;
+#if USE_CACHE_DIGESTS
+	int digest_generation;
+#endif
     } onoff;
     acl *aclList;
     struct {
@@ -460,12 +470,22 @@ struct _SquidConfig {
 #if MULTICAST_MISS_STREAM
     struct {
 	struct in_addr addr;
+	int ttl;
 	unsigned short port;
 	char *encode_key;
     } mcast_miss;
 #endif
     HttpHeaderMask anonymize_headers;
     char *coredump_dir;
+#if USE_CACHE_DIGESTS
+    struct {
+	int bits_per_entry;
+	int rebuild_period;
+	int rewrite_period;
+	int swapout_chunk_size;
+	int rebuild_chunk_percentage;
+    } digest;
+#endif
 };
 
 struct _SquidConfig2 {
@@ -625,6 +645,7 @@ struct _HttpHdrExtField {
 struct _HttpHdrCc {
     int mask;
     int max_age;
+    int s_maxage;
 };
 
 /* http byte-range-spec */
@@ -1067,6 +1088,7 @@ struct _peer {
     } mcast;
 #if USE_CACHE_DIGESTS
     PeerDigest *digest;
+    char *digest_url;
 #endif
     int tcp_up;			/* 0 if a connect() fails */
     time_t last_fail_time;
@@ -1432,8 +1454,10 @@ struct _request_t {
     time_t ims;
     int imslen;
     int max_forwards;
+    /* these in_addr's could probably be sockaddr_in's */
     struct in_addr client_addr;
     struct in_addr my_addr;
+    unsigned short my_port;
     HttpHeader header;
     char *body;
     size_t body_sz;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.187 1999/10/04 05:05:36 wessels Exp $
+ * $Id: tools.cc,v 1.188 1999/12/30 17:37:01 wessels Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -53,6 +53,8 @@ extern void log_trace_done();
 extern void log_trace_init(char *);
 #endif
 
+extern void (*failure_notify) (const char *);
+
 void
 releaseServerSockets(void)
 {
@@ -364,6 +366,7 @@ fatalvf(const char *fmt, va_list args)
 void
 fatal_dump(const char *message)
 {
+    failure_notify = NULL;
     releaseServerSockets();
     if (message)
 	fatal_common(message);
@@ -413,13 +416,16 @@ getMyHostname(void)
     const struct hostent *h = NULL;
     if (Config.visibleHostname != NULL)
 	return Config.visibleHostname;
-    /*
-     * If tcp_incoming is set then try to get the corresponding hostname
-     */
-    if (!present && Config.Addrs.tcp_incoming.s_addr != INADDR_ANY) {
+    if (present) {
+	(void) 0;
+    } else if (Config.Sockaddr.http->s.sin_addr.s_addr != any_addr.s_addr) {
+	/*
+	 * If the first http_port address has a specific address, try a
+	 * reverse DNS lookup on it.
+	 */
 	host[0] = '\0';
-	h = gethostbyaddr((char *) &Config.Addrs.tcp_incoming,
-	    sizeof(Config.Addrs.tcp_incoming), AF_INET);
+	h = gethostbyaddr((char *) &Config.Sockaddr.http->s.sin_addr,
+	    sizeof(Config.Sockaddr.http->s.sin_addr), AF_INET);
 	if (h != NULL) {
 	    /* DNS lookup successful */
 	    /* use the official name from DNS lookup */
@@ -430,11 +436,10 @@ getMyHostname(void)
 	} else {
 	    debug(50, 6) ("getMyHostname: failed to resolve tcp_incoming_addr\n");
 	}
-    }
-    /*
-     * Get the host name and store it in host to return
-     */
-    if (!present) {
+    } else {
+	/*
+	 * Get the host name and store it in host to return
+	 */
 	host[0] = '\0';
 	if (gethostname(host, SQUIDHOSTNAMELEN) == -1) {
 	    debug(50, 1) ("getMyHostname: gethostname failed: %s\n",
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.100 1999/10/04 05:05:28 wessels Exp $
+ * $Id: tunnel.cc,v 1.101 1999/12/30 17:36:51 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -119,7 +119,12 @@ static int
 sslDeferServerRead(int fdnotused, void *data)
 {
     SslStateData *s = data;
-    return delayBytesWanted(s->delay_id, 0, 1) == 0;
+    int i = delayBytesWanted(s->delay_id, 0, INT_MAX);
+    if (i == INT_MAX)
+	return 0;
+    if (i == 0)
+	return 1;
+    return -1;
 }
 #endif
 
@@ -155,7 +160,8 @@ sslSetSelect(SslStateData * sslState)
 		0);
 	}
 #if DELAY_POOLS
-	/* If this was allowed to return 0, there would be a possibility
+	/*
+	 * If this was allowed to return 0, there would be a possibility
 	 * of the socket becoming "hung" with data accumulating but no
 	 * write handler (server.len==0) and no read handler (!(0<0)) and
 	 * no data flowing in the other direction.  Hence the argument of
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.98 1999/10/04 05:05:37 wessels Exp $
+ * $Id: typedefs.h,v 1.99 1999/12/30 17:37:02 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -74,6 +74,7 @@ typedef struct _intlist intlist;
 typedef struct _intrange intrange;
 typedef struct _ushortlist ushortlist;
 typedef struct _relist relist;
+typedef struct _sockaddr_in_list sockaddr_in_list;
 typedef struct _SquidConfig SquidConfig;
 typedef struct _SquidConfig2 SquidConfig2;
 typedef struct _close_handler close_handler;
@@ -1,5 +1,5 @@
 /*
- * $Id: unlinkd.cc,v 1.32 1999/10/04 05:05:38 wessels Exp $
+ * $Id: unlinkd.cc,v 1.33 1999/12/30 17:37:03 wessels Exp $
  *
  * DEBUG: section 12    Unlink Daemon
  * AUTHOR: Duane Wessels
@@ -188,11 +188,15 @@ unlinkdInit(void)
     commSetTimeout(unlinkd_rfd, -1, NULL, NULL);
     commSetTimeout(unlinkd_wfd, -1, NULL, NULL);
     /*
-     * We leave unlinkd_wfd blocking, because we never want to lose an
-     * unlink request, and we don't have code to retry if we get
-     * EWOULDBLOCK.
+     * unlinkd_rfd should already be non-blocking because of
+     * ipcCreate.  We change unlinkd_wfd to blocking mode because
+     * we never want to lose an unlink request, and we don't have
+     * code to retry if we get EWOULDBLOCK.  Unfortunately, we can
+     * do this only for the IPC_FIFO case.
      */
-    commSetNonBlocking(unlinkd_rfd);
+    assert(fd_table[unlinkd_rfd].flags.nonblocking);
+    if (FD_PIPE == fd_table[unlinkd_wfd].type)
+	commUnsetNonBlocking(unlinkd_wfd);
     debug(12, 1) ("Unlinkd pipe opened on FD %d\n", unlinkd_wfd);
 #else
     debug(12, 1) ("Unlinkd is disabled\n");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.119 1999/10/04 05:05:38 wessels Exp $
+ * $Id: url.cc,v 1.120 1999/12/30 17:37:03 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -46,15 +46,14 @@ const char *RequestMethodStr[] =
     "TRACE",
     "PURGE",
     "OPTIONS",
-#ifndef RFC_2518
+    "DELETE",
     "PROPFIND",
     "PROPPATCH",
     "MKCOL",
     "COPY",
     "MOVE",
     "LOCK",
     "UNLOCK",
-#endif
     "ERROR"
 };
 
@@ -147,38 +146,10 @@ urlInitialize(void)
 method_t
 urlParseMethod(const char *s)
 {
-    if (strcasecmp(s, "GET") == 0) {
-	return METHOD_GET;
-    } else if (strcasecmp(s, "POST") == 0) {
-	return METHOD_POST;
-    } else if (strcasecmp(s, "PUT") == 0) {
-	return METHOD_PUT;
-    } else if (strcasecmp(s, "HEAD") == 0) {
-	return METHOD_HEAD;
-    } else if (strcasecmp(s, "CONNECT") == 0) {
-	return METHOD_CONNECT;
-    } else if (strcasecmp(s, "TRACE") == 0) {
-	return METHOD_TRACE;
-    } else if (strcasecmp(s, "PURGE") == 0) {
-	return METHOD_PURGE;
-    } else if (strcasecmp(s, "OPTIONS") == 0) {
-	return METHOD_OPTIONS;
-#ifndef RFC_2518
-    } else if (strcasecmp(s, "PROPFIND") == 0) {
-	return METHOD_PROPFIND;
-    } else if (strcasecmp(s, "PROPPATCH") == 0) {
-	return METHOD_PROPPATCH;
-    } else if (strcasecmp(s, "MKCOL") == 0) {
-	return METHOD_MKCOL;
-    } else if (strcasecmp(s, "COPY") == 0) {
-	return METHOD_COPY;
-    } else if (strcasecmp(s, "MOVE") == 0) {
-	return METHOD_MOVE;
-    } else if (strcasecmp(s, "LOCK") == 0) {
-	return METHOD_LOCK;
-    } else if (strcasecmp(s, "UNLOCK") == 0) {
-	return METHOD_UNLOCK;
-#endif
+    method_t method = METHOD_NONE;
+    for (method++; method < METHOD_ENUM_END; method++) {
+	if (0 == strcasecmp(s, RequestMethodStr[method]))
+	    return method;
     }
     return METHOD_NONE;
 }
@@ -245,6 +216,7 @@ urlParse(method_t method, char *url)
     LOCAL_ARRAY(char, urlpath, MAX_URL);
     request_t *request = NULL;
     char *t = NULL;
+    char *q = NULL;
     int port;
     protocol_t protocol = PROTO_NONE;
     int l;
@@ -317,6 +289,15 @@ urlParse(method_t method, char *url)
 	case URI_WHITESPACE_CHOP:
 	    *(urlpath + strcspn(urlpath, w_space)) = '\0';
 	    break;
+	case URI_WHITESPACE_STRIP:
+	default:
+	    t = q = urlpath;
+	    while (*t) {
+		if (!xisspace(*t))
+		    *q++ = *t;
+		t++;
+	    }
+	    *q = '\0';
 	}
     }
     request = requestCreate(method, protocol, urlpath);
@@ -1,7 +1,7 @@
 
 /*
  *
- * $Id: urn.cc,v 1.56 1999/10/04 05:05:39 wessels Exp $
+ * $Id: urn.cc,v 1.57 1999/12/30 17:37:04 wessels Exp $
  *
  * DEBUG: section 52    URN Parsing
  * AUTHOR: Kostas Anagnostakis
@@ -138,7 +138,7 @@ urnStart(request_t * r, StoreEntry * e)
     if ((urlres_e = storeGetPublic(urlres, METHOD_GET)) == NULL) {
 	urlres_e = storeCreateEntry(urlres, urlres, null_request_flags, METHOD_GET);
 	storeClientListAdd(urlres_e, urnState);
-	fwdStart(-1, urlres_e, urlres_r, no_addr, no_addr);
+	fwdStart(-1, urlres_e, urlres_r);
     } else {
 	storeLockObject(urlres_e);
 	storeClientListAdd(urlres_e, urnState);
@@ -1,8 +1,8 @@
 
 /*
- * $Id: wccp.cc,v 1.11 1999/12/11 15:56:11 wessels Exp $
+ * $Id: wccp.cc,v 1.12 1999/12/30 17:37:05 wessels Exp $
  *
- * DEBUG: section 80	WCCP Support
+ * DEBUG: section 80    WCCP Support
  * AUTHOR: Glenn Chisholm
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -43,6 +43,7 @@
 #define WCCP_ACTIVE_CACHES 32
 #define WCCP_HASH_SIZE 32
 #define WCCP_BUCKETS 256
+#define WCCP_CACHE_LEN 4
 
 #define WCCP_HERE_I_AM 7
 #define WCCP_I_SEE_YOU 8
@@ -89,7 +90,7 @@ static struct in_addr local_ip;
 static PF wccpHandleUdp;
 static int wccpLowestIP(void);
 static EVH wccpHereIam;
-static EVH wccpAssignBuckets;
+static void wccpAssignBuckets(void);
 
 /*
  * The functions used during startup:
@@ -109,10 +110,10 @@ wccpInit(void)
     wccp_here_i_am.type = htonl(WCCP_HERE_I_AM);
     wccp_here_i_am.version = htonl(WCCP_VERSION);
     wccp_here_i_am.revision = htonl(WCCP_REVISION);
-    change = 1;
+    change = 0;
     if (Config.Wccp.router.s_addr != any_addr.s_addr)
 	if (!eventFind(wccpHereIam, NULL))
-	    eventAdd("wccpHereIam", wccpHereIam, NULL, 10.0, 1);
+	    eventAdd("wccpHereIam", wccpHereIam, NULL, 5.0, 1);
 }
 
 void
@@ -241,9 +242,8 @@ wccpHandleUdp(int sock, void *not_used)
     }
     if (change != wccp_i_see_you.change) {
 	change = wccp_i_see_you.change;
-	if (wccpLowestIP())
-	    if (!eventFind(wccpAssignBuckets, NULL))
-		eventAdd("wccpAssignBuckets", wccpAssignBuckets, NULL, 30.0, 1);
+	if (wccpLowestIP() && wccp_i_see_you.number)
+	    wccpAssignBuckets();
     }
 }
 
@@ -274,26 +274,35 @@ wccpHereIam(void *voidnotused)
 }
 
 static void
-wccpAssignBuckets(void *voidnotused)
+wccpAssignBuckets(void)
 {
-    struct wccp_assign_bucket_t wccp_assign_bucket;
+    struct wccp_assign_bucket_t *wccp_assign_bucket;
+    int wab_len;
+    char *buckets;
     int buckets_per_cache;
     int loop;
     int number_caches;
     int bucket = 0;
     int *caches;
-    int offset;
-    char buckets[WCCP_BUCKETS];
+    int cache_len;
     char *buf;
 
     debug(80, 6) ("wccpAssignBuckets: Called\n");
-    memset(&wccp_assign_bucket, '\0', sizeof(wccp_assign_bucket));
-    memset(buckets, 0xFF, WCCP_BUCKETS);
-
     number_caches = ntohl(wccp_i_see_you.number);
     if (number_caches > WCCP_ACTIVE_CACHES)
 	number_caches = WCCP_ACTIVE_CACHES;
-    caches = xmalloc(sizeof(int) * number_caches);
+    wab_len = sizeof(struct wccp_assign_bucket_t);
+    cache_len = WCCP_CACHE_LEN * number_caches;
+
+    buf = xmalloc(wab_len +
+	WCCP_BUCKETS +
+	cache_len);
+    wccp_assign_bucket = (struct wccp_assign_bucket_t *) buf;
+    caches = (int *) (buf + wab_len);
+    buckets = buf + wab_len + cache_len;
+
+    memset(wccp_assign_bucket, '\0', sizeof(wccp_assign_bucket));
+    memset(buckets, 0xFF, WCCP_BUCKETS);
 
     buckets_per_cache = WCCP_BUCKETS / number_caches;
     for (loop = 0; loop < number_caches; loop++) {
@@ -306,23 +315,15 @@ wccpAssignBuckets(void *voidnotused)
 	    buckets[bucket++] = loop;
 	}
     }
-    offset = sizeof(wccp_assign_bucket);
-    buf = xmalloc(offset + WCCP_BUCKETS + (sizeof(*caches) * number_caches));
-    wccp_assign_bucket.type = htonl(WCCP_ASSIGN_BUCKET);
-    wccp_assign_bucket.id = wccp_i_see_you.id;
-    wccp_assign_bucket.number = wccp_i_see_you.number;
-
-    xmemcpy(buf, &wccp_assign_bucket, offset);
-    xmemcpy(buf + offset, caches, (sizeof(*caches) * number_caches));
-    offset += (sizeof(*caches) * number_caches);
-    xmemcpy(buf + offset, buckets, WCCP_BUCKETS);
-    offset += WCCP_BUCKETS;
+    wccp_assign_bucket->type = htonl(WCCP_ASSIGN_BUCKET);
+    wccp_assign_bucket->id = wccp_i_see_you.id;
+    wccp_assign_bucket->number = wccp_i_see_you.number;
+
     send(theOutWccpConnection,
 	buf,
-	offset,
+	wab_len + WCCP_BUCKETS + cache_len,
 	0);
     change = 0;
-    xfree(caches);
     xfree(buf);
 }
 