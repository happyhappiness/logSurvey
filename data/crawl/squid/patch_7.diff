----++++lib/libTrie/Trie.cc
@@ -15,7 +15,7 @@
 #include &lt;unistd.h&gt;
 #endif
 
-Trie::Trie(TrieCharTransform *aTransform) : head(0) , transform(aTransform)
+Trie::Trie(TrieCharTransform *aTransform) : head(0), transform(aTransform)
 {}
 
 Trie::~Trie()
----++++lib/libTrie/test/trie.cc
@@ -47,12 +47,12 @@ CaseSensitiveCheck()
         return 1;
     }
 
-    if (aTrie.findPrefix("User-AgentFoo" , 13) != (void *)1) {
+    if (aTrie.findPrefix("User-AgentFoo", 13) != (void *)1) {
         std::cerr &lt;&lt; &quot;Could not find User prefix&quot; &lt;&lt; std::endl;
         return 1;
     }
 
-    if (aTrie.findPrefix("user-agentFoo" , 13) == (void *)1) {
+    if (aTrie.findPrefix("user-agentFoo", 13) == (void *)1) {
         std::cerr &lt;&lt; &quot;found user prefix&quot; &lt;&lt; std::endl;
         return 1;
     }
@@ -95,12 +95,12 @@ CaseInsensitiveCheck()
         return 1;
     }
 
-    if (aTrie.findPrefix("User-AgentFoo" , 13) != (void *)1) {
+    if (aTrie.findPrefix("User-AgentFoo", 13) != (void *)1) {
         std::cerr &lt;&lt; &quot;Could not find User prefix&quot; &lt;&lt; std::endl;
         return 1;
     }
 
-    if (aTrie.findPrefix("user-agentFoo" , 13) != (void *)1) {
+    if (aTrie.findPrefix("user-agentFoo", 13) != (void *)1) {
         std::cerr &lt;&lt; &quot;Could not find user prefix&quot; &lt;&lt; std::endl;
         return 1;
     }
----++++lib/ntlmauth/ntlmauth.cc
@@ -257,7 +257,7 @@ ntlm_unpack_auth(const ntlm_authenticate *auth, char *user, char *domain, const
         debug(&quot;ntlm_unpack_auth: Domain &#39;%s&#39; (len=%d).\n&quot;, domain, rv.l);
     }
     if (rv.l &gt;= size) {
-        debug("ntlm_unpack_auth: Domain length %d too big for %d byte packet.\n", rv.l , size);
+        debug("ntlm_unpack_auth: Domain length %d too big for %d byte packet.\n", rv.l, size);
         return NTLM_ERR_BLOB;
     }
 
----++++lib/smblib/smb-errors.c
@@ -125,7 +125,7 @@ err_code_struct hard_msgs[] = {
     {&quot;ERRbadcmd&quot;,22,&quot;Unknown command.&quot;},
     {&quot;ERRdata&quot;,23,&quot;Data error (CRC).&quot;},
     {&quot;ERRbadreq&quot;,24,&quot;Bad request structure length.&quot;},
-    {"ERRseek",25 ,"Seek error."},
+    {"ERRseek",25,"Seek error."},
     {&quot;ERRbadmedia&quot;,26,&quot;Unknown media type.&quot;},
     {&quot;ERRbadsector&quot;,27,&quot;Sector not found.&quot;},
     {&quot;ERRnopaper&quot;,28,&quot;Printer out of paper.&quot;},
----++++src/AclRegs.cc
@@ -124,7 +124,7 @@ Acl::Init()
     RegisterMaker(&quot;dst_as&quot;, [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;Ip::Address&gt;(new ACLASN, new ACLDestinationASNStrategy, name); });
     RegisterMaker(&quot;browser&quot;, [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;char const *&gt;(new ACLRegexData, new ACLRequestHeaderStrategy&lt;Http::HdrType::USER_AGENT&gt;, name); });
     RegisterMaker(&quot;dstdomain&quot;, [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;char const *&gt;(new ACLDomainData, new ACLDestinationDomainStrategy, name); });
-    RegisterMaker("dstdom_regex", [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;char const *&gt;(new ACLRegexData, new ACLDestinationDomainStrategy , name); });
+    RegisterMaker("dstdom_regex", [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;char const *&gt;(new ACLRegexData, new ACLDestinationDomainStrategy, name); });
     RegisterMaker(&quot;dst&quot;, [](TypeName)-&gt;ACL* { return new ACLDestinationIP; }); // XXX: Add name parameter to ctor
     RegisterMaker(&quot;hier_code&quot;, [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;hier_code&gt;(new ACLHierCodeData, new ACLHierCodeStrategy, name); });
     RegisterMaker(&quot;rep_header&quot;, [](TypeName name)-&gt;ACL* { return new ACLStrategised&lt;HttpHeader*&gt;(new ACLHTTPHeaderData, new ACLHTTPRepHeaderStrategy, name); });
----++++src/DiskIO/AIO/AIODiskFile.cc
@@ -58,7 +58,7 @@ AIODiskFile::open(int flags, mode_t, RefCount&lt;IORequestor&gt; callback)
 #if _SQUID_WINDOWS_
     fd = aio_open(path.termedBuf(), flags);
 #else
-    fd = file_open(path.termedBuf() , flags);
+    fd = file_open(path.termedBuf(), flags);
 #endif
 
     ioRequestor = callback;
----++++src/DiskIO/Blocking/BlockingFile.cc
@@ -39,7 +39,7 @@ void
 BlockingFile::open(int flags, mode_t, RefCount&lt;IORequestor&gt; callback)
 {
     /* Simulate async calls */
-    fd = file_open(path_ , flags);
+    fd = file_open(path_, flags);
     ioRequestor = callback;
 
     if (fd &lt; 0) {
----++++src/DiskIO/DiskDaemon/DiskdIOStrategy.cc
@@ -86,7 +86,7 @@ DiskdIOStrategy::newFile(char const *path)
     return new DiskdFile (path, this);
 }
 
-DiskdIOStrategy::DiskdIOStrategy() : magic1(64), magic2(72), away(0) , smsgid(-1), rmsgid(-1), wfd(-1) , instanceID(newInstance())
+DiskdIOStrategy::DiskdIOStrategy() : magic1(64), magic2(72), away(0), smsgid(-1), rmsgid(-1), wfd(-1), instanceID(newInstance())
 {}
 
 bool
----++++src/DiskIO/Mmapped/MmappedFile.cc
@@ -74,7 +74,7 @@ MmappedFile::open(int flags, mode_t, RefCount&lt;IORequestor&gt; callback)
     assert(fd &lt; 0);
 
     /* Simulate async calls */
-    fd = file_open(path_ , flags);
+    fd = file_open(path_, flags);
     ioRequestor = callback;
 
     if (fd &lt; 0) {
----++++src/Generic.h
@@ -68,7 +68,7 @@ class InstanceToSingletonAdapter : public C
     C const *theInstance;
 };
 
-template &lt;class InputIterator , class Visitor&gt;
+template &lt;class InputIterator, class Visitor&gt;
 Visitor&amp; for_each(InputIterator from, InputIterator to, Visitor&amp; visitor)
 {
     while (!(from == to)) {
----++++src/HttpHdrCc.cc
@@ -257,7 +257,7 @@ HttpHdrCc::packInto(Packable * p) const
         if (isSet(flag) &amp;&amp; flag != HttpHdrCcType::CC_OTHER) {
 
             /* print option name for all options */
-            p-&gt;appendf((pcount ? ", %s": "%s") , CcAttrs[flag].name);
+            p-&gt;appendf((pcount ? ", %s": "%s"), CcAttrs[flag].name);
 
             /* for all options having values, &quot;=value&quot; after the name */
             switch (flag) {
----++++src/LeakFinder.cc
@@ -22,7 +22,7 @@
 
 /* ========================================================================= */
 
-LeakFinderPtr::LeakFinderPtr(void *p , const char *f, const int l) :
+LeakFinderPtr::LeakFinderPtr(void *p, const char *f, const int l) :
     file(f),
     line(l),
     when(squid_curtime)
----++++src/SBufStatsAction.cc
@@ -85,6 +85,6 @@ SBufStatsAction::unpack(const Ipc::TypedMsgHdr&amp; msg)
 void
 SBufStatsAction::RegisterWithCacheManager()
 {
-    Mgr::RegisterAction("sbuf", "String-Buffer statistics", &amp;SBufStatsAction::Create, 0 , 1);
+    Mgr::RegisterAction("sbuf", "String-Buffer statistics", &amp;SBufStatsAction::Create, 0, 1);
 }
 
----++++src/StatCounters.h
@@ -57,7 +57,7 @@ class StatCounters
             int errors;
             ByteCounter kbytes_in;
             ByteCounter kbytes_out;
-        } all , http, ftp, other;
+        } all, http, ftp, other;
     } server;
 
     struct {
----++++src/acl/Random.cc
@@ -25,7 +25,7 @@ ACLRandom::clone() const
 
 ACLRandom::ACLRandom(char const *theClass) : data(0.0), class_(theClass)
 {
-    memset(pattern, 0 , sizeof(pattern));
+    memset(pattern, 0, sizeof(pattern));
 }
 
 ACLRandom::ACLRandom(ACLRandom const &amp; old) : data(old.data), class_(old.class_)
----++++src/acl/RegexData.cc
@@ -231,7 +231,7 @@ compileUnoptimisedREs(std::list&lt;RegexPattern&gt; &amp;curlist, const SBufList &amp;sl)
         } else if (configurationLineWord == plus_i) {
             flags &amp;= ~REG_ICASE;
         } else {
-            if (!compileRE(curlist, configurationLineWord.c_str() , flags))
+            if (!compileRE(curlist, configurationLineWord.c_str(), flags))
                 debugs(28, DBG_CRITICAL, &quot;ERROR: Skipping regular expression. &quot;
                        &quot;Compile failed: &#39;&quot; &lt;&lt; configurationLineWord &lt;&lt; &quot;&#39;&quot;);
         }
----++++src/acl/external/kerberos_ldap_group/support.h
@@ -126,11 +126,11 @@ SQUIDCEXTERN int log_enabled;
 #define error(X...) \
                      fprintf(stderr, &quot;%s(%d): pid=%ld :&quot;, __FILE__, __LINE__, (long)getpid() ); \
                      fprintf(stderr,X); \
- 
+
 #define warn(X...) \
                      fprintf(stderr, &quot;%s(%d): pid=%ld :&quot;, __FILE__, __LINE__, (long)getpid() ); \
                      fprintf(stderr,X); \
- 
+
 #else /* __GNUC__ */
 
 /* non-GCC compilers can&#39;t do the above macro define yet. */
----++++src/acl/external/kerberos_ldap_group/support_krb5.cc
@@ -333,7 +333,7 @@ krb5_create_cache(char *domain)
 #endif
 
                 if (code) {
-                    k5_error("Error while initialising credentials from keytab" ,code);
+                    k5_error("Error while initialising credentials from keytab",code);
                     safe_free(principal_name);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
@@ -345,7 +345,7 @@ krb5_create_cache(char *domain)
                 }
                 code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal);
                 if (code) {
-                    k5_error("Error while initialising  memory caches" ,code);
+                    k5_error("Error while initialising  memory caches",code);
                     safe_free(principal_name);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
@@ -357,7 +357,7 @@ krb5_create_cache(char *domain)
                 }
                 code = krb5_cc_store_cred(kparam.context, kparam.cc[ccindex], creds);
                 if (code) {
-                    k5_error("Error while storing credentials" ,code);
+                    k5_error("Error while storing credentials",code);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
                     safe_free(principal_name);
@@ -373,13 +373,13 @@ krb5_create_cache(char *domain)
         }
 
         if (code &amp;&amp; code != KRB5_KT_END) {
-            k5_error("Error while scanning keytab" ,code);
+            k5_error("Error while scanning keytab",code);
             retval = 1;
             goto cleanup;
         }
         code = krb5_kt_end_seq_get(kparam.context, keytab, &amp;cursor);
         if (code) {
-            k5_error("Error while ending keytab scan" ,code);
+            k5_error("Error while ending keytab scan",code);
             retval = 1;
             goto cleanup;
         }
@@ -401,7 +401,7 @@ krb5_create_cache(char *domain)
                  */
                 code = krb5_unparse_name(kparam.context, principal_list[i], &amp;principal_name);
                 if (code) {
-                    k5_error("Error while unparsing principal name" ,code);
+                    k5_error("Error while unparsing principal name",code);
                     goto loop_end;
                 }
                 debug((char *) &quot;%s| %s: DEBUG: Keytab entry has principal: %s\n&quot;, LogTime(), PROGRAM, principal_name);
@@ -417,17 +417,17 @@ krb5_create_cache(char *domain)
                 code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
                 if (code) {
-                    k5_error("Error while initialising credentials from keytab" ,code);
+                    k5_error("Error while initialising credentials from keytab",code);
                     goto loop_end;
                 }
                 code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal_list[i]);
                 if (code) {
-                    k5_error("Error while initialising memory caches" ,code);
+                    k5_error("Error while initialising memory caches",code);
                     goto loop_end;
                 }
                 code = krb5_cc_store_cred(kparam.context, kparam.cc[ccindex], creds);
                 if (code) {
-                    k5_error("Error while storing credentials" ,code);
+                    k5_error("Error while storing credentials",code);
                     goto loop_end;
                 }
                 if (creds-&gt;server)
@@ -442,12 +442,12 @@ krb5_create_cache(char *domain)
                 code = krb5_parse_name(kparam.context, service, &amp;creds-&gt;server);
                 xfree(service);
                 if (code) {
-                    k5_error("Error while initialising TGT credentials" ,code);
+                    k5_error("Error while initialising TGT credentials",code);
                     goto loop_end;
                 }
                 code = krb5_get_credentials(kparam.context, 0, kparam.cc[ccindex], creds, &amp;tgt_creds);
                 if (code) {
-                    k5_error("Error while getting tgt" ,code);
+                    k5_error("Error while getting tgt",code);
                     goto loop_end;
                 } else {
                     debug((char *) &quot;%s| %s: DEBUG: Found trusted principal name: %s\n&quot;, LogTime(), PROGRAM, principal_name);
@@ -479,7 +479,7 @@ krb5_create_cache(char *domain)
          */
         code = krb5_unparse_name(kparam.context, principal, &amp;principal_name);
         if (code) {
-            k5_error("Error while unparsing principal name" ,code);
+            k5_error("Error while unparsing principal name",code);
             retval = 1;
             goto cleanup;
         }
----++++src/acl/external/kerberos_ldap_group/support_ldap.cc
@@ -75,9 +75,9 @@ LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 #define ATTRIBUTE_AD &quot;memberof&quot;
 
 size_t get_attributes(LDAP * ld, LDAPMessage * res,
-                      const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
+                      const char *attribute /* IN */, char ***out_val /* OUT (caller frees) */ );
 size_t get_bin_attributes(LDAP * ld, LDAPMessage * res,
-                          const char *attribute /* IN */ , char ***out_val,
+                          const char *attribute /* IN */, char ***out_val,
                           int **out_len /* OUT (caller frees) */ );
 int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp,
                       char *ldap_group, char *group, int depth);
----++++src/acl/external/session/ext_session_acl.cc
@@ -73,7 +73,7 @@ static void init_db(void)
                 /* If directory then open database environment. This prevents sync problems
                     between different processes. Otherwise fallback to single file */
                 db_env_create(&amp;db_env, 0);
-                if (db_env-&gt;open(db_env, db_path, DB_CREATE | DB_INIT_MPOOL | DB_INIT_LOCK , 0666)) {
+                if (db_env-&gt;open(db_env, db_path, DB_CREATE | DB_INIT_MPOOL | DB_INIT_LOCK, 0666)) {
                     fprintf(stderr, &quot;FATAL: %s: Failed to open database environment in &#39;%s&#39;\n&quot;, program_name, db_path);
                     db_env-&gt;close(db_env, 0);
                     exit(EXIT_FAILURE);
----++++src/adaptation/ecap/ServiceRep.cc
@@ -152,7 +152,7 @@ Adaptation::Ecap::Engine::kickAsyncServices(timeval &amp;timeout)
 /* Adaptation::Ecap::ServiceRep */
 
 Adaptation::Ecap::ServiceRep::ServiceRep(const ServiceConfigPointer &amp;cfg):
-/*AsyncJob("Adaptation::Ecap::ServiceRep"),*/ Adaptation::Service(cfg),
+    /*AsyncJob("Adaptation::Ecap::ServiceRep"),*/ Adaptation::Service(cfg),
     isDetached(false)
 {
 }
----++++src/esi/Esi.cc
@@ -1575,7 +1575,7 @@ esiLiteral::makeCacheable() const
 }
 
 ESIElement::Pointer
-esiLiteral::makeUsable(esiTreeParentPtr , ESIVarState &amp;newVarState) const
+esiLiteral::makeUsable(esiTreeParentPtr, ESIVarState &amp;newVarState) const
 {
     debugs(86, 5, &quot;esiLiteral::makeUsable: Creating usable literal&quot;);
     esiLiteral * result = new esiLiteral (*this);
----++++src/format/Format.cc
@@ -1391,7 +1391,7 @@ Format::Format::assemble(MemBuf &amp;mb, const AccessLogEntry::Pointer &amp;al, int logS
             out = sb.c_str();
         } else if (doMsec) {
             if (fmt-&gt;widthMax &lt; 0) {
-                sb.appendf("%0*ld", fmt-&gt;widthMin , tvToMsec(outtv));
+                sb.appendf("%0*ld", fmt-&gt;widthMin, tvToMsec(outtv));
             } else {
                 int precision = fmt-&gt;widthMax;
                 sb.appendf(&quot;%0*&quot; PRId64 &quot;.%0*&quot; PRId64 &quot;&quot;, fmt-&gt;zero &amp;&amp; (fmt-&gt;widthMin - precision - 1 &gt;= 0) ? fmt-&gt;widthMin - precision - 1 : 0, static_cast&lt;int64_t&gt;(outtv.tv_sec * 1000 + outtv.tv_usec / 1000), precision, static_cast&lt;int64_t&gt;((outtv.tv_usec % 1000 )* (1000 / fmt-&gt;divisor)));
----++++src/ip/Address.cc
@@ -67,7 +67,7 @@ Ip::Address::cidr() const
             continue ;  /* A short-cut */
         }
 
-        for (caught = 0 , bit= 7 ; !caught &amp;&amp; (bit &lt;= 7); --bit) {
+        for (caught = 0, bit= 7 ; !caught &amp;&amp; (bit &lt;= 7); --bit) {
             caught = ((ipbyte &amp; 0x80) == 0x00);  /* Found a &#39;0&#39; at &#39;bit&#39; ? */
 
             if (!caught)
----++++src/ipc/Messages.h
@@ -24,8 +24,8 @@ typedef enum { mtNone = 0, mtRegistration,
                mtCollapsedForwardingNotification,
                mtCacheMgrRequest, mtCacheMgrResponse
 #if SQUID_SNMP
-               ,
-               mtSnmpRequest, mtSnmpResponse
+,
+mtSnmpRequest, mtSnmpResponse
 #endif
              } MessageType;
 
----++++src/main.cc
@@ -659,7 +659,7 @@ mainParseOptions(int argc, char *argv[])
         case &#39;v&#39;:
             /** \par v
              * Display squid version and build information. Then exit. */
-            printf("Squid Cache: Version %s\n" ,version_string);
+            printf("Squid Cache: Version %s\n",version_string);
             printf(&quot;Service Name: &quot; SQUIDSBUFPH &quot;\n&quot;, SQUIDSBUFPRINT(service_name));
             if (strlen(SQUID_BUILD_INFO))
                 printf(&quot;%s\n&quot;,SQUID_BUILD_INFO);
----++++src/mem/PoolChunked.cc
@@ -136,7 +136,7 @@ MemChunk::MemChunk(MemPoolChunked *aPool)
 }
 
 MemPoolChunked::MemPoolChunked(const char *aLabel, size_t aSize) :
-    MemImplementingAllocator(aLabel, aSize) , chunk_size(0),
+    MemImplementingAllocator(aLabel, aSize), chunk_size(0),
     chunk_capacity(0), chunkCount(0), freeCache(0), nextFreeChunk(0),
     Chunks(0), allChunks(Splay&lt;MemChunk *&gt;())
 {
----++++src/mem/old_api.cc
@@ -717,7 +717,7 @@ Mem::Report(std::ostream &amp;stream)
     /* Get stats for Totals report line */
     memPoolGetGlobalStats(&amp;mp_total);
 
-    MemPoolStats *sortme = (MemPoolStats *) xcalloc(mp_total.tot_pools_alloc ,sizeof(*sortme));
+    MemPoolStats *sortme = (MemPoolStats *) xcalloc(mp_total.tot_pools_alloc,sizeof(*sortme));
     int npools = 0;
 
     /* main table */
----++++src/sbuf/SBuf.cc
@@ -658,7 +658,7 @@ SBuf::find(const SBuf &amp;needle, size_type startPos) const
                &quot;, lastPossible=&quot; &lt;&lt; (void*) lastPossible );
         tmp = static_cast&lt;char *&gt;(memchr(start, needleBegin, lastPossible-start));
         if (tmp == NULL) {
-            debugs(24, 8 , "First byte not found");
+            debugs(24, 8, "First byte not found");
             return npos;
         }
         // lastPossible guarrantees no out-of-bounds with memcmp()
----++++src/snmp_core.cc
@@ -745,7 +745,7 @@ peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
         int no = name[current-&gt;len] ;
         int i;
         // Note: This works because the Config.peers keeps its index according to its position.
-        for ( i=0 ; peers &amp;&amp; (i &lt; no) ; peers = peers-&gt;next , ++i ) ;
+        for ( i=0 ; peers &amp;&amp; (i &lt; no) ; peers = peers-&gt;next, ++i ) ;
 
         if (peers) {
             debugs(49, 6, &quot;snmp peer_Inst: Encode peer #&quot; &lt;&lt; i);
----++++src/ssl/cert_validate_message.cc
@@ -71,7 +71,7 @@ get_error_id(const char *label, size_t len)
     const char *e = label + len -1;
     while (e != label &amp;&amp; xisdigit(*e)) --e;
     if (e != label) ++e;
-    return strtol(e, 0 , 10);
+    return strtol(e, 0, 10);
 }
 
 bool
----++++GitHub