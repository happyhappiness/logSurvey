@@ -1,12 +1,12 @@
-	- use cached_error() instead of CACHED_RETRIEVE_ERROR_MSG
+	- use squid_error() instead of CACHED_RETRIEVE_ERROR_MSG
 	- fix some fd discprencies in the cachemgr/info page
 	- Fixed "defer/spin" problem
-	- Changed ftpget to be a server so cached never forks
+	- Changed ftpget to be a server so squid never forks
 	- Added blocklist patch
 	- Changed #includes and such.
 	- the -d (debug) option is now gone.  Use new "debug" in the
 	  config file instead.  Debugging is section,level.
-	- Added 'pid_filename' to cached.conf
+	- Added 'pid_filename' to squid.conf
 	- Changed default behaviour to unbuffered, use -b to make buffered.
 	- fix byte order conversion bug on echo port
 	- Removed all code and references to binary port
@@ -55,7 +55,7 @@
 	- Open server sockets _after_ storeRebuild() so many incoming
 	  connections don't stack up on the listen queue.
 	- Created "store.log" which logs RELEASE/SWAPIN/SWAPOUT events.
-	- Added announce to cached; no longer external program.
+	- Added announce to squid; no longer external program.
 	- Added ftpProcessReplyHeader() (a twin of the one in http.c).
 	- Fixed bad free() in ipcacheShtudownServers()
 	- Cleaned up FTP url parsing; support port.
@@ -71,6 +71,8 @@
 	- Check specifically for tm_gmtoff and set HAVE_TM_GMTOFF
 	- Fixed memory problem for colon but no port ("http://foo.com:/")
 	- Added support for weighted neighbors.
-	-fixed SSL/CONNECT
-	-Added background processing for rebuilding store
-	-Removed check for "\r\n" in icpRead, use 'immed' flag instead
+	- fixed SSL/CONNECT
+	- Added background processing for rebuilding store
+	- Removed check for "\r\n" in icpRead, use 'immed' flag instead
+	- Invented request_t struct and urlParse to avoid sscanf'ing
+	  the URL string too often.
@@ -1,40 +1,17 @@
-Change the prefix variable in ./Makefile to be the directory in which
-you would like to install the Harvest Cache.  The default is
-/usr/local/harvest.
-
 To build and install the Harvest Cache, type:
 
+	% ./configure --prefix=/usr/local/squid
         % make all
         % make install
 
 To run a Cache, you will need to:
 
-	1. set the HARVEST_HOME environment variable, as appropriate:
-	      % setenv HARVEST_HOME /usr/local/harvest
-
-	2. customize the cached.conf configuration file:
-	      % vi $HARVEST_HOME/lib/cached.conf
+	1. customize the squid.conf configuration file:
+	      % vi /usr/local/squid/etc/squid.conf
 
-	3. start the cache:
-	      % $HARVEST_HOME/bin/RunCache
+	2. start the cache:
+	      % /usr/local/squid/bin/squid
 
 If you want to use the WWW interface to the Cache Manager, copy
 the cachemgr.cgi program into your httpd server's cgi-bin
 directory.
-
-Alternatively, you can configure your HTTP server to recognize CGI
-scripts in $HARVEST_HOME/cgi-bin.  For example, with NCSA httpd, add
-this line to the srm.conf file:
-
-        ScriptAlias /Harvest/cgi-bin/ Your-HARVEST_HOME/cgi-bin/
-
-Then, use <URL:http://host/Harvest/cgi-bin/cachemgr.cgi> to access the
-WWW interface to the Cache Manager.
-
-For further or more detailed instructions on how to run the Cache, 
-refer to the Harvest User's Manual:
-        http://harvest.cs.colorado.edu/harvest/doc.html
-
-To run the Cache as an httpd accelerator, follow the instructions here:
-        http://harvest.cs.colorado.edu/harvest/httpd_accel.html
-
@@ -517,7 +517,7 @@ fi
 
 
 
-# From configure.in Revision: 1.15 
+# From configure.in Revision: 1.16 
 ac_aux_dir=
 for ac_dir in aux $srcdir/aux; do
   if test -f $ac_dir/install-sh; then
@@ -2170,7 +2170,7 @@ trap 'rm -fr `echo "\
 	./scripts/RunCache \
 	./scripts/RunAccel \
 	./src/Makefile \
-	./src/cached.conf \
+	./src/squid.conf \
  include/autoconf.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
@@ -2248,7 +2248,7 @@ CONFIG_FILES=\${CONFIG_FILES-"\
 	./scripts/RunCache \
 	./scripts/RunAccel \
 	./src/Makefile \
-	./src/cached.conf \
+	./src/squid.conf \
 "}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
@@ -3,13 +3,13 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.7)
 dnl
-dnl  $Id: configure.in,v 1.16 1996/04/15 18:00:24 wessels Exp $
+dnl  $Id: configure.in,v 1.17 1996/04/16 05:07:10 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.16 $)dnl
+AC_REVISION($Revision: 1.17 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(aux)
 
@@ -157,7 +157,7 @@ AC_CHECK_LIB(44bsd, inet_aton, [HAVE_LIB44BSD="yes"])
 AC_CHECK_LIB(resolv, inet_aton, [if test "$HAVE_LIB44BSD" = "yes"; then LIBS="$LIBS -l44bsd"; fi])
 
 dnl Check for libcrypt
-dnl cached uses crypt(3) which may be in libc, or in libcrypt (eg FreeBSD)
+dnl We use crypt(3) which may be in libc, or in libcrypt (eg FreeBSD)
 AC_CHECK_LIB(crypt, crypt, [CRYPT_LIB="-lcrypt"])
 AC_SUBST(CRYPT_LIB)
 
@@ -255,5 +255,5 @@ AC_OUTPUT(\
 	./scripts/RunCache \
 	./scripts/RunAccel \
 	./src/Makefile \
-	./src/cached.conf \
+	./src/squid.conf \
 )
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Harvest Object Cache server
 #
-#  $Id: Makefile.in,v 1.18 1996/04/15 22:50:00 wessels Exp $
+#  $Id: Makefile.in,v 1.19 1996/04/16 05:05:16 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -47,10 +47,10 @@ LDFLAGS         = $(STD_LDFLAGS)
 LIBS		= -L../lib -lregex -lutil $(XTRA_LIBS)
 CLIENT_LIBS	= -L../lib -lutil $(XTRA_LIBS)
 
-PROGS		= cached 
+PROGS		= squid 
 UTILS		= client dnsserver ftpget
 CGIPROGS	= cachemgr.cgi
-OBJS	 	= acl.o background.o cache_cf.o cached_error.o comm.o \
+OBJS	 	= acl.o background.o cache_cf.o errorpage.o comm.o \
 		connect.o debug.o disk.o dynamic_array.o \
 		fdstat.o filemap.o ftp.o gopher.o \
 		hash.o http.o icp.o ipcache.o \
@@ -60,7 +60,7 @@ OBJS	 	= acl.o background.o cache_cf.o cached_error.o comm.o \
 		url.o wais.o $(XTRA_OBJS)
 
 DEFAULTS        = \
-	-DDEFAULT_CONFIG_FILE=\"$(sysconfdir)/cached.conf\" \
+	-DDEFAULT_CONFIG_FILE=\"$(sysconfdir)/squid.conf\" \
 	-DDEFAULT_FTPGET=\"$(bindir)/ftpget\" \
 	-DDEFAULT_DNSSERVER=\"$(bindir)/dnsserver\" \
 	-DDEFAULT_CACHE_LOG=\"$(prefix)/logs/cache.log\" \
@@ -70,7 +70,7 @@ DEFAULTS        = \
 
 all:	$(PROGS) $(UTILS) $(CGIPROGS)
 
-cached:	$(OBJS)
+squid:	$(OBJS)
 	$(CC) -o $@ $(LDFLAGS) $(OBJS) $(CRYPT_LIB) $(LIBS)
 
 cache_cf.o: cache_cf.c
@@ -123,19 +123,15 @@ install: all install-mkdirs
 		echo $(INSTALL_BIN) $$f $(bindir); \
 		$(INSTALL_BIN) $$f $(bindir); \
 	done
-	@if test -f $(sysconfdir)/cached.conf ; then \
-		echo "$@ will not overwrite existing $(sysconfdir)/cached.conf" ; \
+	@if test -f $(sysconfdir)/squid.conf ; then \
+		echo "$@ will not overwrite existing $(sysconfdir)/squid.conf" ; \
 	else \
-		echo "$(INSTALL_FILE) cached.conf $(sysconfdir)"; \
-		$(INSTALL_FILE) cached.conf $(sysconfdir); \
+		echo "$(INSTALL_FILE) squid.conf $(sysconfdir)"; \
+		$(INSTALL_FILE) squid.conf $(sysconfdir); \
 	fi
 
 clean: 
-	-rm -rf *.o *pure_* core $(PROGS) $(UTILS) $(CGIPROGS)
+	-rm -rf *.o *pure_* core $(PROGS) $(UTILS) $(CGIPROGS) squid.conf
 
 realclean:	clean
 	-rm -f Makefile
-
-tar:
-	-rm -f cache.tar
-	tar cf cache.tar *.c *.h cached.conf Makefile*
@@ -1,4 +1,4 @@
-#ident "$Id: acl.cc,v 1.11 1996/04/12 21:44:19 wessels Exp $"
+#ident "$Id: acl.cc,v 1.12 1996/04/16 05:05:17 wessels Exp $"
 
 /*
  * DEBUG: Section 28          acl
@@ -129,7 +129,8 @@ struct _acl_ip_data *aclParseIpList()
 		break;
 	    case 5:
 		if (m1 < 0 || m1 > 32) {
-		    debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+		    debug(28, 0, "%s line %d: %s\n",
+			cfg_filename, config_lineno, config_input_line);
 		    debug(28, 0, "aclParseIpList: Ignoring invalid IP acl entry '%s'\n", t);
 		    safe_free(q);
 		    continue;
@@ -140,7 +141,8 @@ struct _acl_ip_data *aclParseIpList()
 		lmask.s_addr = htonl(m1 * 0x1000000 + m2 * 0x10000 + m3 * 0x100 + m4);
 		break;
 	    default:
-		debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+		debug(28, 0, "%s line %d: %s\n",
+		    cfg_filename, config_lineno, config_input_line);
 		debug(28, 0, "aclParseIpList: Ignoring invalid IP acl entry '%s'\n", t);
 		safe_free(q);
 		continue;
@@ -188,9 +190,8 @@ struct _acl_time_data *aclParseTimeSpec()
 		    data->weekbits |= ACL_SATURDAY;
 		    break;
 		default:
-		    debug(28, 0, "cached.conf line %d: %s\n",
-			config_lineno,
-			config_input_line);
+		    debug(28, 0, "%s line %d: %s\n",
+			cfg_filename, config_lineno, config_input_line);
 		    debug(28, 0, "aclParseTimeSpec: Bad Day '%c'\n",
 			*t);
 		    break;
@@ -199,9 +200,8 @@ struct _acl_time_data *aclParseTimeSpec()
 	} else {
 	    /* assume its time-of-day spec */
 	    if (sscanf(t, "%d:%d-%d:%d", &h1, &m1, &h2, &m2) < 4) {
-		debug(28, 0, "cached.conf line %d: %s\n",
-		    config_lineno,
-		    config_input_line);
+		debug(28, 0, "%s line %d: %s\n",
+		    cfg_filename, config_lineno, config_input_line);
 		debug(28, 0, "aclParseTimeSpec: Bad time range '%s'\n",
 		    t);
 		xfree(&data);
@@ -210,9 +210,8 @@ struct _acl_time_data *aclParseTimeSpec()
 	    data->start = h1 * 60 + m1;
 	    data->stop = h2 * 60 + m2;
 	    if (data->start > data->stop) {
-		debug(28, 0, "cached.conf line %d: %s\n",
-		    config_lineno,
-		    config_input_line);
+		debug(28, 0, "%s line %d: %s\n",
+		    cfg_filename, config_lineno, config_input_line);
 		debug(28, 0, "aclParseTimeSpec: Reversed time range '%s'\n",
 		    t);
 		xfree(&data);
@@ -236,7 +235,8 @@ struct _relist *aclParseRegexList()
     regex_t comp;
     while ((t = strtok(NULL, w_space))) {
 	if (regcomp(&comp, t, REG_EXTENDED) != REG_NOERROR) {
-	    debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	    debug(28, 0, "%s line %d: %s\n",
+		cfg_filename, config_lineno, config_input_line);
 	    debug(28, 0, "aclParseRegexList: Invalid regular expression: '%s'\n", t);
 	    continue;
 	}
@@ -275,13 +275,15 @@ void aclParseAclLine()
     A = (struct _acl *) xcalloc(1, sizeof(struct _acl));
     /* snarf the ACL name */
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAclLine: missing ACL name.\n");
 	xfree(A);
 	return;
     }
     if (aclFindByName(t)) {
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAclLine: ACL name '%s' already exists.\n", t);
 	xfree(A);
 	return;
@@ -290,7 +292,8 @@ void aclParseAclLine()
     /* snarf the ACL type */
     if ((t = strtok(NULL, w_space)) == NULL) {
 	xfree(A);
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAclLine: missing ACL type.\n");
 	return;
     }
@@ -321,7 +324,8 @@ void aclParseAclLine()
 	break;
     case ACL_NONE:
     default:
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAclLine: Invalid ACL type '%s'\n", t);
 	xfree(A);
 	return;
@@ -345,7 +349,8 @@ void aclParseAccessLine(head)
 
     /* first expect either 'allow' or 'deny' */
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAccessLine: missing 'allow' or 'deny'.\n");
 	return;
     }
@@ -355,7 +360,8 @@ void aclParseAccessLine(head)
     else if (!strcmp(t, "deny"))
 	A->allow = 0;
     else {
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAccessLine: expecting 'allow' or 'deny', got '%s'.\n", t);
 	xfree(A);
 	return;
@@ -375,7 +381,8 @@ void aclParseAccessLine(head)
 	debug(28, 3, "aclParseAccessLine: looking for ACL name '%s'\n", t);
 	a = aclFindByName(t);
 	if (a == NULL) {
-	    debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	    debug(28, 0, "%s line %d: %s\n",
+		cfg_filename, config_lineno, config_input_line);
 	    debug(28, 0, "aclParseAccessLine: ACL name '%s' not found.\n", t);
 	    xfree(L);
 	    continue;
@@ -385,7 +392,8 @@ void aclParseAccessLine(head)
 	Tail = &L->next;
     }
     if (A->acl_list == NULL) {
-	debug(28, 0, "cached.conf line %d: %s\n", config_lineno, config_input_line);
+	debug(28, 0, "%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0, "aclParseAccessLine: Access line contains no ACL's, skipping\n");
 	xfree(A);
 	return;
@@ -493,7 +501,7 @@ static int aclMatchAcl(acl, c, m, pr, h, po, r)
 	return aclMatchWord(acl->data, h);
 	break;
     case ACL_TIME:
-	return aclMatchTime(acl->data, cached_curtime);
+	return aclMatchTime(acl->data, squid_curtime);
 	return 0;
 	break;
     case ACL_URL_REGEX:
@@ -1,4 +1,4 @@
-/* $Id: cache_cf.cc,v 1.43 1996/04/16 01:51:17 wessels Exp $ */
+/* $Id: cache_cf.cc,v 1.44 1996/04/16 05:05:17 wessels Exp $ */
 
 /* DEBUG: Section 3             cache_cf: Configuration file parsing */
 
@@ -142,14 +142,12 @@ static struct {
 #define DefaultSingleParentBypass 0	/* default off */
 #define DefaultPidFilename      (char *)NULL	/* default NONE */
 #define DefaultVisibleHostname  (char *)NULL	/* default NONE */
-#define DefaultFtpUser		"cached@"	/* Default without domain */
+#define DefaultFtpUser		"squid@"	/* Default without domain */
 #define DefaultAnnounceHost	"sd.cache.nlanr.net"
 #define DefaultAnnouncePort	3131
 #define DefaultAnnounceFile	(char *)NULL	/* default NONE */
 #define DefaultAnnounceRate	86400	/* every 24 hours */
 
-extern char *config_file;
-
  /* default CONNECT ports */
 intlist snews =
 {
@@ -176,6 +174,7 @@ int emulate_httpd_log = DefaultCommonLogFormat;		/* for fast access */
 time_t neighbor_timeout = DefaultNeighborTimeout;	/* for fast access */
 int single_parent_bypass = 0;
 int DnsPositiveTtl = DefaultPositiveDnsTtl;
+char *cfg_filename = NULL;
 
 char w_space[] = " \t\n";
 char config_input_line[BUFSIZ];
@@ -188,8 +187,8 @@ static char fatal_str[BUFSIZ];
 
 void self_destruct()
 {
-    sprintf(fatal_str, "Bungled cached.conf line %d: %s",
-	config_lineno, config_input_line);
+    sprintf(fatal_str, "Bungled %s line %d: %s",
+	cfg_filename, config_lineno, config_input_line);
     fatal(fatal_str);
 }
 
@@ -1069,6 +1068,9 @@ int parseConfigFile(file_name)
 	sprintf(fatal_str, "Unable to open configuration file: %s", file_name);
 	fatal(fatal_str);
     }
+    cfg_filename = file_name;
+    if ((token = strrchr(cfg_filename, '/')))
+	cfg_filename = token+1;
     memset(config_input_line, '\0', BUFSIZ);
     config_lineno = 0;
     while (fgets(config_input_line, BUFSIZ, fp)) {
@@ -1335,23 +1337,23 @@ int parseConfigFile(file_name)
 	printf("WARNING: client_lifetime (%d seconds) is less than read_timeout (%d seconds).\n",
 	    getClientLifetime(), getReadTimeout());
 	printf("         This may cause serious problems with your cache!!!\n");
-	printf("         Change your cached.conf file.\n");
+	printf("         Change your configuration file.\n");
 	fflush(stdout);		/* print message */
     }
     if (getCacheSwapMax() < (getCacheMemMax() >> 10)) {
 	printf("WARNING: cache_swap (%d kbytes) is less than cache_mem (%d bytes).\n", getCacheSwapMax(), getCacheMemMax());
 	printf("         This will cause serious problems with your cache!!!\n");
-	printf("         Change your cached.conf file.\n");
+	printf("         Change your configuration file.\n");
 	Config.Swap.maxSize = getCacheMemMax() >> 10;
-	printf("         For this run, however, cached will use %d kbytes for cache_swap.\n", getCacheSwapMax());
+	printf("         For this run, however, %s will use %d kbytes for cache_swap.\n", appname, getCacheSwapMax());
 	fflush(stdout);		/* print message */
     }
     if (getCleanRate() > -1 && getCleanRate() < 60) {
 	Config.cleanRate = (30 * 60);
 	printf("WARNING: clean_rate is less than one minute.\n");
 	printf("         This will cause serious problems with your cache!!!\n");
-	printf("         Change your cached.conf file.\n");
-	printf("         For this run, however, cached will use %d minutes for clean_rate.\n", (int) (getCleanRate() / 60));
+	printf("         Change your configuration file.\n");
+	printf("         For this run, however, %s will use %d minutes for clean_rate.\n", appname, (int) (getCleanRate() / 60));
 	fflush(stdout);		/* print message */
     }
     if (accel_ip_acl == NULL)
@@ -1,4 +1,4 @@
-/* $Id: cachemgr.cc,v 1.5 1996/04/01 23:22:03 wessels Exp $ */
+/* $Id: cachemgr.cc,v 1.6 1996/04/16 05:05:18 wessels Exp $ */
 
 #include "squid.h"
 
@@ -76,7 +76,7 @@ void noargs_html()
     printf("<BR><STRONG>Operation :</STRONG>");
     printf("<SELECT NAME=\"operation\">\n");
     printf("<OPTION SELECTED VALUE=\"info\">Cache Information\n");
-    printf("<OPTION VALUE=\"cached.conf\">Cache Configuration File\n");
+    printf("<OPTION VALUE=\"squid.conf\">Cache Configuration File\n");
     printf("<OPTION VALUE=\"parameter\">Cache Parameters\n");
 #ifdef MENU_RESPONSETIME
     printf("<OPTION VALUE=\"responsetime\">Cache Response Time Histogram\n");
@@ -356,10 +356,10 @@ int main(int argc, char *argv[])
 	!strncmp(operation, "Cache Information", 17)) {
 	op = INFO;
 	sprintf(msg, "GET cache_object://%s/info\r\n", hostname);
-    } else if (!strncmp(operation, "cached.conf", 10) ||
+    } else if (!strncmp(operation, "squid.conf", 10) ||
 	!strncmp(operation, "Cache Configuration File", 24)) {
 	op = CACHED;
-	sprintf(msg, "GET cache_object://%s/cached.conf\r\n", hostname);
+	sprintf(msg, "GET cache_object://%s/squid.conf\r\n", hostname);
     } else if (!strncmp(operation, "server_list", 11) ||
 	!strncmp(operation, "Cache Server List", 17)) {
 	op = SERVER;
@@ -423,7 +423,7 @@ int main(int argc, char *argv[])
     printf("<SELECT NAME=\"operation\">\n");
     printf("<OPTION SELECTED VALUE=\"%s\">Current\n", operation);
     printf("<OPTION VALUE=\"info\">Cache Information\n");
-    printf("<OPTION VALUE=\"cached.conf\">Cache Configuration File\n");
+    printf("<OPTION VALUE=\"squid.conf\">Cache Configuration File\n");
     printf("<OPTION VALUE=\"parameter\">Cache Parameters\n");
 #ifdef MENU_RESPONSETIME
     printf("<OPTION VALUE=\"responsetime\">Cache Response Time Histogram\n");
@@ -1,5 +1,5 @@
 
-/* $Id: comm.cc,v 1.24 1996/04/15 22:50:55 wessels Exp $ */
+/* $Id: comm.cc,v 1.25 1996/04/16 05:05:18 wessels Exp $ */
 
 /* DEBUG: Section 5             comm: socket level functions */
 
@@ -222,7 +222,7 @@ int comm_set_fd_lifetime(fd, lifetime)
 	return 0;
     if (lifetime < 0)
 	return fd_lifetime[fd] = -1;
-    return fd_lifetime[fd] = (int) cached_curtime + lifetime;
+    return fd_lifetime[fd] = (int) squid_curtime + lifetime;
 }
 
 int comm_get_fd_lifetime(fd)
@@ -463,7 +463,7 @@ void comm_set_stall(fd, delta)
 {
     if (fd < 0)
 	return;
-    fd_table[fd].stall_until = cached_curtime + delta;
+    fd_table[fd].stall_until = squid_curtime + delta;
 }
 
 
@@ -496,10 +496,10 @@ int comm_select(sec, failtime)
     /* use only 1 second granularity */
     zero_tv.tv_sec = 0;
     zero_tv.tv_usec = 0;
-    timeout = cached_curtime + sec;
+    timeout = squid_curtime + sec;
 
     while (timeout > getCurrentTime()) {
-	if (0 < failtime && failtime < cached_curtime)
+	if (0 < failtime && failtime < squid_curtime)
 	    break;
 
 	FD_ZERO(&readfds);
@@ -510,7 +510,7 @@ int comm_select(sec, failtime)
 	maxfd = fdstat_biggest_fd() + 1;
 	for (i = 0; i < maxfd; i++) {
 	    /* Check each open socket for a handler. */
-	    if (fd_table[i].read_handler && fd_table[i].stall_until <= cached_curtime) {
+	    if (fd_table[i].read_handler && fd_table[i].stall_until <= squid_curtime) {
 		nfds++;
 		FD_SET(i, &readfds);
 	    }
@@ -546,12 +546,12 @@ int comm_select(sec, failtime)
 	    continue;
 
 	debug(5, num ? 5 : 8, "comm_select: %d sockets ready at %d\n",
-	    num, cached_curtime);
+	    num, squid_curtime);
 
 	/* Check lifetime and timeout handlers ONCE each second.
 	 * Replaces brain-dead check every time through the loop! */
-	if (cached_curtime > last_timeout) {
-	    last_timeout = cached_curtime;
+	if (squid_curtime > last_timeout) {
+	    last_timeout = squid_curtime;
 	    checkTimeouts();
 	    checkLifetimes();
 	}
@@ -649,7 +649,7 @@ int comm_select(sec, failtime)
 	return COMM_OK;
     }
 
-    debug(5, 8, "comm_select: time out: %d.\n", cached_curtime);
+    debug(5, 8, "comm_select: time out: %d.\n", squid_curtime);
     return COMM_TIMEOUT;
 }
 
@@ -856,9 +856,9 @@ struct in_addr *getAddress(name)
 /*
  *  the fd_lifetime is used as a hardlimit to timeout dead sockets.
  *  The basic problem is that many WWW clients are abusive and
- *  it results in cached having lots of CLOSE_WAIT states.  Until
+ *  it results in squid having lots of CLOSE_WAIT states.  Until
  *  we can find a better solution, we give all asciiPort or
- *  cached initiated clients a maximum lifetime.
+ *  squid initiated clients a maximum lifetime.
  */
 int comm_init()
 {
@@ -962,10 +962,10 @@ static void checkTimeouts()
     for (fd = 0; fd < maxfd; ++fd) {
 	f = &fd_table[fd];
 	if ((f->timeout_handler) &&
-	    (f->timeout_time <= cached_curtime)) {
+	    (f->timeout_time <= squid_curtime)) {
 	    tmp = f->timeout_handler;
 	    debug(5, 5, "comm_select: timeout on socket %d at %d\n",
-		fd, cached_curtime);
+		fd, squid_curtime);
 	    f->timeout_handler = 0;
 	    tmp(fd, f->timeout_data);
 	}
@@ -984,7 +984,7 @@ static void checkLifetimes()
     /* scan for hardwired lifetime expires, do the timeouts first though */
     for (fd = 0; fd < max_fd; fd++) {
 	lft = comm_get_fd_lifetime(fd);
-	if ((lft != -1) && (lft < cached_curtime)) {
+	if ((lft != -1) && (lft < squid_curtime)) {
 	    if (fd_table[fd].lifetime_handler != NULL) {
 		use_lifetime_handler = 1;
 		tmp_local = fd_table[fd].lifetime_handler;
@@ -1004,15 +1004,15 @@ static void checkLifetimes()
 	    if (tmp_local) {
 		if (use_lifetime_handler) {
 		    debug(5, 2, "comm_select: FD %d lifetime expire: %d < %d (Lifetime handler %p)\n",
-			fd, lft, cached_curtime, tmp_local);
+			fd, lft, squid_curtime, tmp_local);
 		} else {
 		    debug(5, 2, "comm_select: FD %d lifetime expire: %d < %d (%s handler %p)\n",
-			fd, lft, cached_curtime,
+			fd, lft, squid_curtime,
 			use_read ? "read" : "write", tmp_local);
 		}
 	    } else {
 		debug(5, 1, "comm_select: FD %d lifetime expire: %d < %d (handler not available.)\n",
-		    fd, lft, cached_curtime);
+		    fd, lft, squid_curtime);
 	    }
 
 	    if (tmp_local != NULL) {
@@ -1030,7 +1030,7 @@ static void checkLifetimes()
 		if (fd_table[fd].openned) {
 		    /* hmm.. still openned. do full comm_close */
 		    debug(5, 5, "comm_select: FD %d lifetime expire: %d < %d : Handler did not close the socket.\n comm_select will do.\n",
-			fd, lft, cached_curtime);
+			fd, lft, squid_curtime);
 		    comm_close(fd);
 		} else {
 		    /* seems like handle closed it. 
@@ -1043,7 +1043,7 @@ static void checkLifetimes()
 	    } else {
 		/* no handle. do full comm_close */
 		debug(5, 5, "comm_select: FD %d lifetime expire: %d < %d : No handler to close the socket.\n comm_select will do.\n",
-		    fd, lft, cached_curtime);
+		    fd, lft, squid_curtime);
 		comm_close(fd);
 	    }
 	}
@@ -1,5 +1,5 @@
 
-/* $Id: debug.cc,v 1.15 1996/04/15 22:51:20 wessels Exp $ */
+/* $Id: debug.cc,v 1.16 1996/04/16 05:05:19 wessels Exp $ */
 
 #include "squid.h"
 
@@ -9,7 +9,7 @@ int _db_line = 0;
 int syslog_enable = 0;
 FILE *debug_log = NULL;
 static char *debug_log_file = NULL;
-static time_t last_cached_curtime = 0;
+static time_t last_squid_curtime = 0;
 static char the_time[81];
 
 #define MAX_DEBUG_SECTIONS 50
@@ -49,10 +49,10 @@ void _db_print(va_alist)
 	return;
     }
     /* don't compute the curtime too much */
-    if (last_cached_curtime != cached_curtime) {
-	last_cached_curtime = cached_curtime;
+    if (last_squid_curtime != squid_curtime) {
+	last_squid_curtime = squid_curtime;
 	the_time[0] = '\0';
-	s = mkhttpdlogtime(&cached_curtime);
+	s = mkhttpdlogtime(&squid_curtime);
 	strcpy(the_time, s);
     }
     sprintf(f, "[%s] %s:%d:\t %s",
@@ -145,7 +145,7 @@ void _db_init(logfile)
 
 #if HAVE_SYSLOG
     if (syslog_enable)
-	openlog("cached", LOG_PID | LOG_NDELAY | LOG_CONS, LOG_LOCAL4);
+	openlog(appname, LOG_PID | LOG_NDELAY | LOG_CONS, LOG_LOCAL4);
 #endif /* HAVE_SYSLOG */
 
 }
@@ -1,4 +1,4 @@
-/* $Id: dnsserver.cc,v 1.4 1996/03/27 01:46:00 wessels Exp $ */
+/* $Id: dnsserver.cc,v 1.5 1996/04/16 05:05:20 wessels Exp $ */
 
 #include "squid.h"
 
@@ -21,24 +21,24 @@ int do_debug = 0;
 		"Unknown DNS problem")
 
 /* 
- * Modified to use UNIX domain sockets between cached and the dnsservers to
+ * Modified to use UNIX domain sockets between squid and the dnsservers to
  * save an FD per DNS server, Hong Mei, USC.
  * 
- * Before forking a dnsserver, cached creates listens on a UNIX domain
- * socket.  After the fork(), cached closes its end of the rendevouz socket
+ * Before forking a dnsserver, squid creates listens on a UNIX domain
+ * socket.  After the fork(), squid closes its end of the rendevouz socket
  * but then immediately connects to it to establish the connection to the
  * dnsserver process.  We use AF_UNIX to prevent other folks from
  * connecting to our little dnsservers after we fork but before we connect
  * to them.
  * 
- * Cached creates UNIX domain sockets named dns.PID.NN, e.g. dns.19215.11
+ * Squid creates UNIX domain sockets named dns.PID.NN, e.g. dns.19215.11
  * 
  * In ipcache_init():
  *       . dnssocket = ipcache_opensocket(getDnsProgram())
  *       . dns_child_table[i]->inpipe = dnssocket
  *       . dns_child_table[i]->outpipe = dnssocket
  * 
- * The dnsserver inherits socket(socket_from_ipcache) from cached which it
+ * The dnsserver inherits socket(socket_from_ipcache) from squid which it
  * uses to rendevouz with.  The child takes responsibility for cleaning up
  * the UNIX domain pathnames by setting a few signal handlers.
  * 
@@ -1,12 +1,12 @@
-/* $Id: errorpage.cc,v 1.19 1996/04/11 22:52:27 wessels Exp $ */
+/* $Id: errorpage.cc,v 1.20 1996/04/16 05:05:20 wessels Exp $ */
 
-/* DEBUG: Section 4             cached_error: Error printing routines */
+/* DEBUG: Section 4             errorpage: Error printing routines */
 
 #include "squid.h"
 
 
 
-#define CACHED_ERROR_MSG_P1 "\
+#define SQUID_ERROR_MSG_P1 "\
 <TITLE>ERROR: The requested URL could not be retrieved</TITLE>\n\
 <H2>The requested URL could not be retrieved</H2>\n\
 <HR>\n\
@@ -20,19 +20,19 @@ The following error was encountered:\n\
 </UL>\n\
 "
 
-#define CACHED_ERROR_MSG_P2 "\
+#define SQUID_ERROR_MSG_P2 "\
 <P>The system returned:\n\
 <PRE><I>    %s</I></PRE>\n\
 "
 
-#define CACHED_ERROR_MSG_P3 "\
+#define SQUID_ERROR_MSG_P3 "\
 <P>This means that:\n\
 <PRE>\n\
     %s\n\
 </PRE>\n\
 <P> <HR>\n\
 <ADDRESS>\n\
-Generated by cached/%s@%s\n\
+Generated by %s/%s@%s\n\
 </ADDRESS>\n\
 \n"
 
@@ -112,25 +112,26 @@ void errorInitialize()
 }
 
 
-void cached_error_entry(entry, type, msg)
+void squid_error_entry(entry, type, msg)
      StoreEntry *entry;
      int type;
      char *msg;
 {
     int index;
     if (type < ERR_MIN || type > ERR_MAX)
-	fatal_dump("cached_error_entry: type out of range.");
+	fatal_dump("squid_error_entry: type out of range.");
     index = (int) (type - ERR_MIN);
-    sprintf(tmp_error_buf, CACHED_ERROR_MSG_P1,
+    sprintf(tmp_error_buf, SQUID_ERROR_MSG_P1,
 	entry->url,
 	entry->url,
 	ErrorData[index].shrt);
     if (msg) {
-	sprintf(tbuf, CACHED_ERROR_MSG_P2, msg);
+	sprintf(tbuf, SQUID_ERROR_MSG_P2, msg);
 	strcat(tmp_error_buf, tbuf);
     }
-    sprintf(tbuf, CACHED_ERROR_MSG_P3,
+    sprintf(tbuf, SQUID_ERROR_MSG_P3,
 	ErrorData[index].lng,
+	appname,
 	version_string,
 	getMyHostname());
     strcat(tmp_error_buf, tbuf);
@@ -142,7 +143,7 @@ void cached_error_entry(entry, type, msg)
 
 
 
-char *cached_error_url(url, method, type, address, code, msg)
+char *squid_error_url(url, method, type, address, code, msg)
      char *url;
      int method;
      int type;
@@ -154,20 +155,21 @@ char *cached_error_url(url, method, type, address, code, msg)
 
     *tmp_error_buf = '\0';
     if (type == ERR_MIN || type > ERR_MAX)
-	fatal_dump("cached_error_url: type out of range.");
+	fatal_dump("squid_error_url: type out of range.");
     index = (int) (type - ERR_MIN);
     sprintf(tmp_error_buf, "HTTP/1.0 %d Cache Detected Error\r\nContent-type: text/html\r\n\r\n", code);
-    sprintf(tbuf, CACHED_ERROR_MSG_P1,
+    sprintf(tbuf, SQUID_ERROR_MSG_P1,
 	url,
 	url,
 	ErrorData[index].shrt);
     strcat(tmp_error_buf, tbuf);
     if (msg) {
-	sprintf(tbuf, CACHED_ERROR_MSG_P2, msg);
+	sprintf(tbuf, SQUID_ERROR_MSG_P2, msg);
 	strcat(tmp_error_buf, tbuf);
     }
-    sprintf(tbuf, CACHED_ERROR_MSG_P3,
+    sprintf(tbuf, SQUID_ERROR_MSG_P3,
 	ErrorData[index].lng,
+	appname,
 	version_string,
 	getMyHostname());
     if (!log_errors)
@@ -176,7 +178,7 @@ char *cached_error_url(url, method, type, address, code, msg)
 }
 
 
-#define CACHED_REQUEST_ERROR_MSG "\
+#define SQUID_REQUEST_ERROR_MSG "\
 <TITLE>ERROR: Invalid HTTP Request</TITLE>\n\
 <H2>Invalid HTTP Request</H2>\n\
 <HR>\n\
@@ -185,11 +187,11 @@ char *cached_error_url(url, method, type, address, code, msg)
 </PRE>\n\
 <HR>\n\
 <ADDRESS>\n\
-Generated by cached/%s@%s\n\
+Generated by %s/%s@%s\n\
 </ADDRESS>\n\
 \n"
 
-char *cached_error_request(request, type, address, code)
+char *squid_error_request(request, type, address, code)
      char *request;
      int type;
      char *address;
@@ -199,12 +201,13 @@ char *cached_error_request(request, type, address, code)
 
     *tmp_error_buf = '\0';
     if (type == ERR_MIN || type > ERR_MAX)
-	fatal_dump("cached_error_url: type out of range.");
+	fatal_dump("squid_error_url: type out of range.");
     index = (int) (type - ERR_MIN);
 
     sprintf(tmp_error_buf, "HTTP/1.0 %d Cache Detected Error\r\nContent-type: text/html\r\n\r\n", code);
-    sprintf(tbuf, CACHED_REQUEST_ERROR_MSG,
+    sprintf(tbuf, SQUID_REQUEST_ERROR_MSG,
 	request,
+	appname,
 	version_string,
 	getMyHostname());
     strcat(tmp_error_buf, tbuf);
@@ -232,11 +235,12 @@ From this cache.  Please check with the cache administrator if you\n\
 believe this is incorrect.\n\
 <HR>\n\
 <ADDRESS>\n\
-Generated by cached/%s@%s\n\
+Generated by %s/%s@%s\n\
 </ADDRESS>\n\
 \n",
 	code,
 	url,
+	appname,
 	version_string,
 	getMyHostname());
     return tmp_error_buf;
@@ -1,4 +1,4 @@
-/* $Id: ftp.cc,v 1.35 1996/04/15 04:08:51 wessels Exp $ */
+/* $Id: ftp.cc,v 1.36 1996/04/16 05:05:22 wessels Exp $ */
 
 /*
  * DEBUG: Section 9           ftp: FTP
@@ -142,7 +142,7 @@ void ftpLifetimeExpire(fd, data)
     StoreEntry *entry = NULL;
     entry = data->entry;
     debug(9, 4, "ftpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
-    cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
+    squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     ftpCloseAndFree(fd, data);
 }
 
@@ -252,7 +252,7 @@ static void ftpProcessReplyHeader(data, buf, size)
 	case 301:		/* Moved Permanently */
 	case 410:		/* Gone */
 	    /* These can be cached for a long time, make the key public */
-	    entry->expires = cached_curtime + ttlSet(entry);
+	    entry->expires = squid_curtime + ttlSet(entry);
 	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
 		storeSetPublicKey(entry);
 	    break;
@@ -267,7 +267,7 @@ static void ftpProcessReplyHeader(data, buf, size)
 	    break;
 	default:
 	    /* These can be negative cached, make key public */
-	    entry->expires = cached_curtime + getNegativeTTL();
+	    entry->expires = squid_curtime + getNegativeTTL();
 	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
 		storeSetPublicKey(entry);
 	    break;
@@ -310,7 +310,7 @@ int ftpReadReply(fd, data)
 	    }
 	} else {
 	    /* we can terminate connection right now */
-	    cached_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
+	    squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
 	    ftpCloseAndFree(fd, data);
 	    return 0;
 	}
@@ -331,11 +331,11 @@ int ftpReadReply(fd, data)
 	} else {
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
-	    cached_error_entry(entry, ERR_READ_ERROR, xstrerror());
+	    squid_error_entry(entry, ERR_READ_ERROR, xstrerror());
 	    ftpCloseAndFree(fd, data);
 	}
     } else if (len == 0 && entry->mem_obj->e_current_len == 0) {
-	cached_error_entry(entry,
+	squid_error_entry(entry,
 	    ERR_ZERO_SIZE_OBJECT,
 	    errno ? xstrerror() : NULL);
 	ftpCloseAndFree(fd, data);
@@ -346,11 +346,11 @@ int ftpReadReply(fd, data)
 	     * failed and arrange so the object gets ejected and
 	     * never gets to disk. */
 	    debug(9, 1, "ftpReadReply: Didn't see magic marker, purging <URL:%s>.\n", entry->url);
-	    entry->expires = cached_curtime + getNegativeTTL();
+	    entry->expires = squid_curtime + getNegativeTTL();
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
 	} else if (!(entry->flag & DELETE_BEHIND)) {
-	    entry->expires = cached_curtime + ttlSet(entry);
+	    entry->expires = squid_curtime + ttlSet(entry);
 	}
 	/* update fdstat and fdtable */
 	storeComplete(entry);
@@ -367,7 +367,7 @@ int ftpReadReply(fd, data)
     } else if (entry->flag & CLIENT_ABORT_REQUEST) {
 	/* append the last bit of info we get */
 	storeAppend(entry, buf, len);
-	cached_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
 	ftpCloseAndFree(fd, data);
     } else {
 	/* check for a magic marker at the end of the read */
@@ -415,7 +415,7 @@ void ftpSendComplete(fd, buf, size, errflag, data)
     data->icp_rwd_ptr = NULL;	/* Don't double free in lifetimeexpire */
 
     if (errflag) {
-	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	ftpCloseAndFree(fd, data);
 	return;
     } else {
@@ -548,7 +548,7 @@ void ftpConnInProgress(fd, data)
 	    debug(9, 5, "ftpConnInProgress: FD %d is now connected.", fd);
 	    break;		/* cool, we're connected */
 	default:
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    ftpCloseAndFree(fd, data);
 	    return;
 	}
@@ -575,7 +575,7 @@ int ftpStart(unusedfd, url, entry)
 
     /* Parse url. */
     if (ftp_url_parser(url, data)) {
-	cached_error_entry(entry, ERR_INVALID_URL, NULL);
+	squid_error_entry(entry, ERR_INVALID_URL, NULL);
 	safe_free(data);
 	return COMM_ERROR;
     }
@@ -584,7 +584,7 @@ int ftpStart(unusedfd, url, entry)
 
     data->ftp_fd = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (data->ftp_fd == COMM_ERROR) {
-	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
     }
@@ -593,7 +593,7 @@ int ftpStart(unusedfd, url, entry)
     /* Now connect ... */
     if ((status = comm_connect(data->ftp_fd, "localhost", CACHE_FTP_PORT))) {
 	if (status != EINPROGRESS) {
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    ftpCloseAndFree(data->ftp_fd, data);
 	    return COMM_ERROR;
 	} else {
@@ -1,4 +1,4 @@
-/* $Id: gopher.cc,v 1.25 1996/04/12 21:41:37 wessels Exp $ */
+/* $Id: gopher.cc,v 1.26 1996/04/16 05:05:22 wessels Exp $ */
 
 /*
  * DEBUG: Section 10          gopher: GOPHER
@@ -567,7 +567,7 @@ int gopherReadReplyTimeout(fd, data)
     StoreEntry *entry = NULL;
     entry = data->entry;
     debug(10, 4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
-    cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
+    squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     if (data->icp_page_ptr)
 	put_free_4k_page(data->icp_page_ptr);
     if (data->icp_rwd_ptr)
@@ -584,7 +584,7 @@ void gopherLifetimeExpire(fd, data)
     StoreEntry *entry = NULL;
     entry = data->entry;
     debug(10, 4, "gopherLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
-    cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
+    squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     if (data->icp_page_ptr)
 	put_free_4k_page(data->icp_page_ptr);
     if (data->icp_rwd_ptr)
@@ -639,7 +639,7 @@ int gopherReadReply(fd, data)
 	    }
 	} else {
 	    /* we can terminate connection right now */
-	    cached_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
+	    squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
 	    gopherCloseAndFree(fd, data);
 	    return 0;
 	}
@@ -661,11 +661,11 @@ int gopherReadReply(fd, data)
 	} else {
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
-	    cached_error_entry(entry, ERR_READ_ERROR, xstrerror());
+	    squid_error_entry(entry, ERR_READ_ERROR, xstrerror());
 	    gopherCloseAndFree(fd, data);
 	}
     } else if (len == 0 && entry->mem_obj->e_current_len == 0) {
-	cached_error_entry(entry,
+	squid_error_entry(entry,
 	    ERR_ZERO_SIZE_OBJECT,
 	    errno ? xstrerror() : NULL);
 	gopherCloseAndFree(fd, data);
@@ -675,7 +675,7 @@ int gopherReadReply(fd, data)
 	if (data->conversion != NORMAL)
 	    gopherEndHTML(data);
 	if (!(entry->flag & DELETE_BEHIND))
-	    entry->expires = cached_curtime + ttlSet(entry);
+	    entry->expires = squid_curtime + ttlSet(entry);
 	BIT_RESET(entry->flag, DELAY_SENDING);
 	storeComplete(entry);
 	gopherCloseAndFree(fd, data);
@@ -705,7 +705,7 @@ int gopherReadReply(fd, data)
 	} else {
 	    storeAppend(entry, buf, len);
 	}
-	cached_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
 	if (data->conversion != NORMAL)
 	    gopherEndHTML(data);
 	BIT_RESET(entry->flag, DELAY_SENDING);
@@ -744,7 +744,7 @@ void gopherSendComplete(fd, buf, size, errflag, data)
     debug(10, 5, "gopherSendComplete: FD %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
-	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	gopherCloseAndFree(fd, data);
 	if (buf)
 	    put_free_4k_page(buf);	/* Allocated by gopherSendRequest. */
@@ -859,15 +859,15 @@ int gopherStart(unusedfd, url, entry)
     /* Parse url. */
     if (gopher_url_parser(url, data->host, &data->port,
 	    &data->type_id, data->request)) {
-	cached_error_entry(entry, ERR_INVALID_URL, NULL);
+	squid_error_entry(entry, ERR_INVALID_URL, NULL);
 	gopherCloseAndFree(-1, data);
 	return COMM_ERROR;
     }
     /* Create socket. */
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
 	debug(10, 4, "gopherStart: Failed because we're out of sockets.\n");
-	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
+	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	gopherCloseAndFree(-1, data);
 	return COMM_ERROR;
     }
@@ -876,7 +876,7 @@ int gopherStart(unusedfd, url, entry)
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->host)) {
 	debug(10, 4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
-	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
+	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	gopherCloseAndFree(sock, data);
 	return COMM_ERROR;
     }
@@ -904,7 +904,7 @@ int gopherStart(unusedfd, url, entry)
     /* Open connection. */
     if ((status = comm_connect(sock, data->host, data->port)) != 0) {
 	if (status != EINPROGRESS) {
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    gopherCloseAndFree(sock, data);
 	    return COMM_ERROR;
 	} else {
@@ -1,4 +1,4 @@
-/* $Id: http.cc,v 1.48 1996/04/16 04:23:12 wessels Exp $ */
+/* $Id: http.cc,v 1.49 1996/04/16 05:05:23 wessels Exp $ */
 
 /*
  * DEBUG: Section 11          http: HTTP
@@ -76,7 +76,7 @@ static void httpReadReplyTimeout(fd, data)
 
     entry = data->entry;
     debug(11, 4, "httpReadReplyTimeout: FD %d: <URL:%s>\n", fd, entry->url);
-    cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
+    squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     comm_set_select_handler(fd, COMM_SELECT_READ, 0, 0);
     httpCloseAndFree(fd, data);
 }
@@ -91,7 +91,7 @@ static void httpLifetimeExpire(fd, data)
     entry = data->entry;
     debug(11, 4, "httpLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
 
-    cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
+    squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     comm_set_select_handler(fd, COMM_SELECT_READ | COMM_SELECT_WRITE, 0, 0);
     httpCloseAndFree(fd, data);
 }
@@ -200,7 +200,7 @@ static void httpProcessReplyHeader(data, buf, size)
 	case 301:		/* Moved Permanently */
 	case 410:		/* Gone */
 	    /* These can be cached for a long time, make the key public */
-	    entry->expires = cached_curtime + ttlSet(entry);
+	    entry->expires = squid_curtime + ttlSet(entry);
 	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
 		storeSetPublicKey(entry);
 	    break;
@@ -215,7 +215,7 @@ static void httpProcessReplyHeader(data, buf, size)
 	    break;
 	default:
 	    /* These can be negative cached, make key public */
-	    entry->expires = cached_curtime + getNegativeTTL();
+	    entry->expires = squid_curtime + getNegativeTTL();
 	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
 		storeSetPublicKey(entry);
 	    break;
@@ -265,7 +265,7 @@ static void httpReadReply(fd, data)
 	    }
 	} else {
 	    /* we can terminate connection right now */
-	    cached_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
+	    squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
 	    httpCloseAndFree(fd, data);
 	    return;
 	}
@@ -287,11 +287,11 @@ static void httpReadReply(fd, data)
 	} else {
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
-	    cached_error_entry(entry, ERR_READ_ERROR, xstrerror());
+	    squid_error_entry(entry, ERR_READ_ERROR, xstrerror());
 	    httpCloseAndFree(fd, data);
 	}
     } else if (len == 0 && entry->mem_obj->e_current_len == 0) {
-	cached_error_entry(entry,
+	squid_error_entry(entry,
 	    ERR_ZERO_SIZE_OBJECT,
 	    errno ? xstrerror() : NULL);
 	httpCloseAndFree(fd, data);
@@ -316,7 +316,7 @@ static void httpReadReply(fd, data)
     } else if (entry->flag & CLIENT_ABORT_REQUEST) {
 	/* append the last bit of info we get */
 	storeAppend(entry, buf, len);
-	cached_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
 	httpCloseAndFree(fd, data);
     } else {
 	storeAppend(entry, buf, len);
@@ -357,7 +357,7 @@ static void httpSendComplete(fd, buf, size, errflag, data)
     data->icp_rwd_ptr = NULL;	/* Don't double free in lifetimeexpire */
 
     if (errflag) {
-	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	httpCloseAndFree(fd, data);
 	return;
     } else {
@@ -492,7 +492,7 @@ static void httpConnInProgress(fd, data)
 	case EISCONN:
 	    break;		/* cool, we're connected */
 	default:
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    httpCloseAndFree(fd, data);
 	    return;
 	}
@@ -535,7 +535,7 @@ int proxyhttpStart(e, url, entry)
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
 	debug(11, 4, "proxyhttpStart: Failed because we're out of sockets.\n");
-	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
+	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
     }
@@ -544,16 +544,16 @@ int proxyhttpStart(e, url, entry)
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(request->host)) {
 	debug(11, 4, "proxyhttpstart: Called without IP entry in ipcache. OR lookup failed.\n");
-	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
+	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	httpCloseAndFree(sock, data);
 	return COMM_ERROR;
     }
     /* Open connection. */
     if ((status = comm_connect(sock, request->host, request->port))) {
 	if (status != EINPROGRESS) {
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    httpCloseAndFree(sock, data);
-	    e->last_fail_time = cached_curtime;
+	    e->last_fail_time = squid_curtime;
 	    e->neighbor_up = 0;
 	    return COMM_ERROR;
 	} else {
@@ -598,7 +598,7 @@ int httpStart(unusedfd, url, request, req_hdr, entry)
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
 	debug(11, 4, "httpStart: Failed because we're out of sockets.\n");
-	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
+	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
     }
@@ -607,14 +607,14 @@ int httpStart(unusedfd, url, request, req_hdr, entry)
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(request->host)) {
 	debug(11, 4, "httpstart: Called without IP entry in ipcache. OR lookup failed.\n");
-	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
+	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	httpCloseAndFree(sock, data);
 	return COMM_ERROR;
     }
     /* Open connection. */
     if ((status = comm_connect(sock, request->host, request->port))) {
 	if (status != EINPROGRESS) {
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    httpCloseAndFree(sock, data);
 	    return COMM_ERROR;
 	} else {
@@ -1,4 +1,4 @@
-/* $Id: ipcache.cc,v 1.23 1996/04/14 03:06:34 wessels Exp $ */
+/* $Id: ipcache.cc,v 1.24 1996/04/16 05:05:24 wessels Exp $ */
 
 /*
  * DEBUG: Section 14          ipcache: IP Cache
@@ -120,7 +120,7 @@ int ipcache_create_dnsserver(command)
     static int n_dnsserver = 0;
     char socketname[256];
     int cfd;			/* socket for child (dnsserver) */
-    int sfd;			/* socket for server (cached) */
+    int sfd;			/* socket for server (squid) */
     int fd;
 
     if ((cfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
@@ -250,7 +250,7 @@ ipcache_entry *ipcache_get(name)
     if (result == NULL)
 	return NULL;
 
-    if (((result->timestamp + result->ttl) < cached_curtime) &&
+    if (((result->timestamp + result->ttl) < squid_curtime) &&
 	(result->status != PENDING)) {	/* expired? */
 	ipcache_release(result);
 	return NULL;
@@ -445,11 +445,11 @@ void ipcache_add(name, e, data, cached)
 	}
 	e->entry.h_length = data->h_length;
 	e->entry.h_name = xstrdup(data->h_name);
-	e->lastref = e->timestamp = cached_curtime;
+	e->lastref = e->timestamp = squid_curtime;
 	e->status = CACHED;
 	e->ttl = DnsPositiveTtl;
     } else {
-	e->lastref = e->timestamp = cached_curtime;
+	e->lastref = e->timestamp = squid_curtime;
 	e->status = NEGATIVE_CACHED;
 	e->ttl = getNegativeDNSTTL();
     }
@@ -508,11 +508,11 @@ void ipcache_update_content(name, e, data, cached)
 
 	e->entry.h_length = data->h_length;
 	e->entry.h_name = xstrdup(data->h_name);
-	e->lastref = e->timestamp = cached_curtime;
+	e->lastref = e->timestamp = squid_curtime;
 	e->status = CACHED;
 	e->ttl = DnsPositiveTtl;
     } else {
-	e->lastref = e->timestamp = cached_curtime;
+	e->lastref = e->timestamp = squid_curtime;
 	e->status = NEGATIVE_CACHED;
 	e->ttl = getNegativeDNSTTL();
     }
@@ -528,7 +528,7 @@ void ipcache_call_pending(entry)
     IpPending *p;
     int nhandler = 0;
 
-    entry->lastref = cached_curtime;
+    entry->lastref = squid_curtime;
 
     while (entry->pending_head != NULL) {
 	p = entry->pending_head;
@@ -719,7 +719,7 @@ int ipcache_parsebuffer(buf, offset, data)
 	 *  Start parsing...
 	 */
 	if (strstr(line_head->line, "$alive")) {
-	    data->answer = cached_curtime;
+	    data->answer = squid_curtime;
 	    free_lines(line_head);
 	    debug(14, 10, "ipcache_parsebuffer: $alive succeeded.\n");
 	} else if (strstr(line_head->line, "$fail")) {
@@ -739,7 +739,7 @@ int ipcache_parsebuffer(buf, offset, data)
 	    } else {
 		plist = globalpending_search(token, data->global_pending);
 		if (plist) {
-		    plist->entry->lastref = plist->entry->timestamp = cached_curtime;
+		    plist->entry->lastref = plist->entry->timestamp = squid_curtime;
 		    plist->entry->ttl = getNegativeDNSTTL();
 		    plist->entry->status = NEGATIVE_CACHED;
 		    ipcache_call_pending(plist->entry);
@@ -768,7 +768,7 @@ int ipcache_parsebuffer(buf, offset, data)
 		    if (e->status != PENDING) {
 			debug(14, 4, "ipcache_parsebuffer: DNS record already resolved.\n");
 		    } else {
-			e->lastref = e->timestamp = cached_curtime;
+			e->lastref = e->timestamp = squid_curtime;
 			e->ttl = DnsPositiveTtl;
 			e->status = CACHED;
 
@@ -1089,7 +1089,7 @@ void ipcacheOpenServers()
 	    dns_child_table[i]->id = i;
 	    dns_child_table[i]->inpipe = dnssocket;
 	    dns_child_table[i]->outpipe = dnssocket;
-	    dns_child_table[i]->lastcall = cached_curtime;
+	    dns_child_table[i]->lastcall = squid_curtime;
 	    dns_child_table[i]->pending_count = 0;
 	    dns_child_table[i]->size = IP_INBUF - 1;	/* spare one for \0 */
 	    dns_child_table[i]->offset = 0;
@@ -1272,7 +1272,7 @@ struct hostent *ipcache_gethostbyname(name)
     }
     /* cache hit */
     debug(14, 5, "ipcache_gethostbyname: Hit for '%s'.\n", name ? name : "NULL");
-    result->lastref = cached_curtime;
+    result->lastref = squid_curtime;
     return (result->status == CACHED) ? &(result->entry) : NULL;
 }
 
@@ -1294,7 +1294,7 @@ void stat_ipcache_get(sentry, obj)
 
     for (e = ipcache_GetFirst(); (e); e = ipcache_GetNext()) {
 	if (e) {
-	    ttl = (e->ttl - cached_curtime + e->lastref);
+	    ttl = (e->ttl - squid_curtime + e->lastref);
 	    status = ipcache_status_char(e);
 	    if (status == 'P')
 		ttl = 0;
@@ -1,10 +1,10 @@
-/* $Id: main.cc,v 1.34 1996/04/16 04:23:14 wessels Exp $ */
+/* $Id: main.cc,v 1.35 1996/04/16 05:05:25 wessels Exp $ */
 
 /* DEBUG: Section 1             main: startup and main loop */
 
 #include "squid.h"
 
-time_t cached_starttime = 0;
+time_t squid_starttime = 0;
 time_t next_cleaning = 0;
 int theAsciiConnection = -1;
 int theUdpConnection = -1;
@@ -18,6 +18,7 @@ int unbuffered_logs = 1;	/* debug and hierarhcy unbuffered by default */
 int shutdown_pending = 0;	/* set by SIGTERM handler (shut_down()) */
 int reread_pending = 0;		/* set by SIGHUP handler */
 char *version_string = SQUID_VERSION;
+char *appname = "squid";
 
 extern void (*failure_notify) ();	/* for error reporting from xmalloc */
 
@@ -28,7 +29,7 @@ static int malloc_debug_level = 0;
 static void usage()
 {
     fprintf(stderr, "\
-Usage: cached [-Rsehvz] [-f config-file] [-[apu] port]\n\
+Usage: %s [-Rsehvz] [-f config-file] [-[apu] port]\n\
        -h        Print help message.\n\
        -s        Enable logging to syslog.\n\
        -v        Print version.\n\
@@ -38,10 +39,10 @@ Usage: cached [-Rsehvz] [-f config-file] [-[apu] port]\n\
        -R        Do not set REUSEADDR on port.\n\
        -U        Unlink expired objects on reload.\n\
        -f file   Use given config-file instead of\n\
-                 $HARVEST_HOME/lib/cached.conf.\n\
+                 %s\n\
        -a port	 Specify ASCII port number (default: %d).\n\
        -u port	 Specify UDP port number (default: %d).\n",
-	CACHE_HTTP_PORT, CACHE_ICP_PORT);
+	appname, DEFAULT_CONFIG_FILE, CACHE_HTTP_PORT, CACHE_ICP_PORT);
     exit(1);
 }
 
@@ -255,7 +256,7 @@ int main(argc, argv)
 
     errorInitialize();
 
-    cached_starttime = getCurrentTime();
+    squid_starttime = getCurrentTime();
     failure_notify = fatal_dump;
 
     mainParseOptions(argc, argv);
@@ -306,9 +307,9 @@ int main(argc, argv)
     while (1) {
 	loop_delay = (time_t) 60;
 	/* maintain cache storage */
-	if (cached_curtime > last_maintain) {
+	if (squid_curtime > last_maintain) {
 	    storeMaintainSwapSpace();
-	    last_maintain = cached_curtime;
+	    last_maintain = squid_curtime;
 	}
 	/* do background processing */
 	if (doBackgroundProcessing())
@@ -327,16 +328,16 @@ int main(argc, argv)
 	    /* this happens after 1 minute of idle time, or
 	     * when next_cleaning has arrived */
 	    /* garbage collection */
-	    if (getCleanRate() > 0 && cached_curtime >= next_cleaning) {
+	    if (getCleanRate() > 0 && squid_curtime >= next_cleaning) {
 		debug(1, 1, "Performing a garbage collection...\n");
 		n = storePurgeOld();
 		debug(1, 1, "Garbage collection done, %d objects removed\n", n);
-		next_cleaning = cached_curtime + getCleanRate();
+		next_cleaning = squid_curtime + getCleanRate();
 	    }
 	    if ((n = getAnnounceRate()) > 0) {
-		if (cached_curtime > last_announce + n)
+		if (squid_curtime > last_announce + n)
 		    send_announce();
-		last_announce = cached_curtime;
+		last_announce = squid_curtime;
 	    }
 	    /* house keeping */
 	    break;
@@ -1,5 +1,5 @@
 
-/* $Id: mime.cc,v 1.11 1996/04/04 01:30:48 wessels Exp $ */
+/* $Id: mime.cc,v 1.12 1996/04/16 05:05:25 wessels Exp $ */
 
 /*
  * DEBUG: Section 25          mime
@@ -119,7 +119,7 @@ int mk_mime_hdr(result, ttl, size, lmt, type)
     if (result == NULL)
 	return 1;
 
-    t = cached_curtime;
+    t = squid_curtime;
     expiretime = t + ttl;
 
     date[0] = expire[0] = last_modified_time[0] = result[0] = '\0';
@@ -1,4 +1,4 @@
-/* $Id: neighbors.cc,v 1.20 1996/04/16 04:23:15 wessels Exp $ */
+/* $Id: neighbors.cc,v 1.21 1996/04/16 05:05:26 wessels Exp $ */
 
 /* TODO:
  * - change 'neighbor' to 'sibling'
@@ -83,10 +83,10 @@ void hierarchy_log_append(url, code, timeout, cache_host)
 	code = HIER_MAX;
 
     if (emulate_httpd_log) {
-	if (cached_curtime != last_time) {
-	    s = mkhttpdlogtime(&cached_curtime);
+	if (squid_curtime != last_time) {
+	    s = mkhttpdlogtime(&squid_curtime);
 	    strcpy(time_str, s);
-	    last_time = cached_curtime;
+	    last_time = squid_curtime;
 	}
 	if (cache_host) {
 	    fprintf(cache_hierarchy_log, "[%s] %s %s%s %s\n",
@@ -105,14 +105,14 @@ void hierarchy_log_append(url, code, timeout, cache_host)
     } else {
 	if (cache_host) {
 	    fprintf(cache_hierarchy_log, "%d %s %s%s %s\n",
-		(int) cached_curtime,
+		(int) squid_curtime,
 		url,
 		timeout ? "TIMEOUT_" : "",
 		hier_strings[code],
 		cache_host);
 	} else {
 	    fprintf(cache_hierarchy_log, "%d %s %s%s\n",
-		(int) cached_curtime,
+		(int) squid_curtime,
 		url,
 		timeout ? "TIMEOUT_" : "",
 		hier_strings[code]);
@@ -371,7 +371,7 @@ int neighborsUdpPing(proto)
 
 	/* skip dumb caches where we failed to connect() w/in the last 60s */
 	if (e->udp_port == echo_port &&
-	    (cached_curtime - e->last_fail_time < 60))
+	    (squid_curtime - e->last_fail_time < 60))
 	    continue;
 
 	if (!edgeWouldBePinged(e, host))
@@ -437,7 +437,7 @@ int neighborsUdpPing(proto)
 	    to_addr.sin_family = AF_INET;
 	    memcpy(&to_addr.sin_addr, hep->h_addr, hep->h_length);
 	    to_addr.sin_port = echo_port;
-	    echo_hdr.reqnum = cached_curtime;
+	    echo_hdr.reqnum = squid_curtime;
 	    debug(15, 6, "neighborsUdpPing - url: %s to url-host %s \n",
 		url, inet_ntoa(to_addr.sin_addr));
 	    /* send to original site */
@@ -517,9 +517,9 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	url, e ? inet_ntoa(e->in_addr.sin_addr) : "url-host");
 
     if (header->opcode == ICP_OP_SECHO) {
-	/* receive ping back from source or from non-cached cache */
+	/* receive ping back from source or from non-ICP cache */
 	if (e) {
-	    debug(15, 6, "Got SECHO from non-cached cache:%s\n",
+	    debug(15, 6, "Got SECHO from non-ICP cache:%s\n",
 		inet_ntoa(e->in_addr.sin_addr));
 	    debug(15, 6, "This is not supposed to happen.  Ignored.\n");
 	} else {
@@ -562,10 +562,10 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	    e->misses++;
 
 	if (header->opcode == ICP_OP_DECHO) {
-	    /* receive ping back from non-cached cache */
+	    /* receive ping back from non-ICP cache */
 
 	    if (e) {
-		debug(15, 6, "Got DECHO from non-cached cache:%s\n",
+		debug(15, 6, "Got DECHO from non-ICP cache:%s\n",
 		    inet_ntoa(e->in_addr.sin_addr));
 
 		if (e->type == EDGE_PARENT) {
@@ -577,12 +577,11 @@ void neighborsUdpAck(fd, url, header, from, entry)
 		    }
 		} else {
 		    debug(15, 6, "Dumb Cached as a neighbor does not make sense.\n");
-		    debug(15, 6, "Count it anyway.\n");
 		}
 
 
 	    } else {
-		debug(15, 6, "Got DECHO from non-cached cache: But the host is not in the list.\n");
+		debug(15, 6, "Got DECHO from non-ICP cache: But the host is not in the list.\n");
 		debug(15, 6, "Count it anyway.\n");
 	    }
 
@@ -1,4 +1,4 @@
-/* $Id: recv-announce.cc,v 1.2 1996/02/29 07:23:19 wessels Exp $ */
+/* $Id: recv-announce.cc,v 1.3 1996/04/16 05:05:28 wessels Exp $ */
 
 #include <stdio.h>
 #include <fcntl.h>
@@ -15,7 +15,7 @@
  * This program must be run from inetd.  First add something like this
  * to /etc/services:
  * 
- * cached_announce 3131/udp             # harvest cached announcements
+ * cached_announce 3131/udp             # harvest cache announcements
  * 
  * And then add something like this to /etc/inetd/conf:
  * 
@@ -1,4 +1,4 @@
-/* $Id: send-announce.cc,v 1.8 1996/04/11 04:47:24 wessels Exp $ */
+/* $Id: send-announce.cc,v 1.9 1996/04/16 05:05:29 wessels Exp $ */
 
 /*
  * DEBUG: Section 27          send-announce
@@ -30,8 +30,8 @@ void send_announce()
 	getUdpPortNum());
     strcat(sndbuf, tbuf);
     sprintf(tbuf, "generated %d [%s]\n",
-	(int) cached_curtime,
-	mkhttpdlogtime(&cached_curtime));
+	(int) squid_curtime,
+	mkhttpdlogtime(&squid_curtime));
     strcat(sndbuf, tbuf);
     l = strlen(sndbuf);
 
@@ -1,5 +1,5 @@
 
-/* $Id: squid.h,v 1.17 1996/04/15 22:56:06 wessels Exp $ */
+/* $Id: squid.h,v 1.18 1996/04/16 05:05:29 wessels Exp $ */
 
 #include "config.h"
 #include "autoconf.h"
@@ -98,7 +98,7 @@ typedef unsigned long u_num32;
 #include "url.h"
 #include "proto.h"
 #include "icp.h"
-#include "cached_error.h"	/* must go after icp.h */
+#include "errorpage.h"	/* must go after icp.h */
 #include "ipcache.h"
 #include "mime.h"
 #include "neighbors.h"
@@ -120,7 +120,7 @@ typedef unsigned long u_num32;
 #include "util.h"
 #include "background.h"
 
-extern time_t cached_starttime;	/* main.c */
+extern time_t squid_starttime;	/* main.c */
 extern time_t next_cleaning;	/* main.c */
 extern int catch_signals;	/* main.c */
 extern int do_reuse;		/* main.c */
@@ -131,3 +131,4 @@ extern int reread_pending;	/* main.c */
 extern int opt_unlink_on_reload;	/* main.c */
 extern int vhost_mode;		/* main.c */
 extern char *version_string;	/* main.c */
+extern char *appname;		/* main.c */
@@ -1,4 +1,4 @@
-/* $Id: stat.cc,v 1.25 1996/04/15 18:06:33 wessels Exp $ */
+/* $Id: stat.cc,v 1.26 1996/04/16 05:05:30 wessels Exp $ */
 
 /*
  * DEBUG: Section 18          stat
@@ -22,10 +22,10 @@ typedef struct _log_read_data_t {
     StoreEntry *sentry;
 } log_read_data_t;
 
-typedef struct _cached_read_data_t {
+typedef struct _squid_read_data_t {
     StoreEntry *sentry;
     int fd;
-} cached_read_data_t;
+} squid_read_data_t;
 
 /* GLOBALS */
 Meta_data meta_data;
@@ -53,7 +53,7 @@ void stat_utilization_get(obj, sentry)
     proto_stat *q = NULL;
     int secs = 0;
 
-    secs = (int) (cached_curtime - cached_starttime);
+    secs = (int) (squid_curtime - squid_starttime);
 
     storeAppend(sentry, open_bracket, (int) strlen(open_bracket));
 
@@ -275,13 +275,13 @@ void log_get_start(obj, sentry)
 }
 
 
-/* cached convert handler */
+/* squid convert handler */
 /* call for each line in file, use fileWalk routine */
-int cachedReadHandler(fd_unused, buf, size_unused, data)
+int squidReadHandler(fd_unused, buf, size_unused, data)
      int fd_unused;
      char *buf;
      int size_unused;
-     cached_read_data_t *data;
+     squid_read_data_t *data;
 {
     static char tempbuf[MAX_LINELEN];
     tempbuf[0] = '\0';
@@ -292,12 +292,12 @@ int cachedReadHandler(fd_unused, buf, size_unused, data)
     return 0;
 }
 
-/* cached convert end handler */
+/* squid convert end handler */
 /* call when a walk is completed or error. */
-void cachedReadEndHandler(fd_unused, errflag_unused, data)
+void squidReadEndHandler(fd_unused, errflag_unused, data)
      int fd_unused;
      int errflag_unused;
-     cached_read_data_t *data;
+     squid_read_data_t *data;
 {
     storeAppend(data->sentry, close_bracket, strlen(close_bracket));
     storeComplete(data->sentry);
@@ -306,21 +306,21 @@ void cachedReadEndHandler(fd_unused, errflag_unused, data)
 }
 
 
-/* start convert cached.conf file to processed format */
-void cached_get_start(obj, sentry)
+/* start convert squid.conf file to processed format */
+void squid_get_start(obj, sentry)
      cacheinfo *obj;
      StoreEntry *sentry;
 {
-    cached_read_data_t *data;
+    squid_read_data_t *data;
     extern char *config_file;
 
-    data = (cached_read_data_t *) xmalloc(sizeof(cached_read_data_t));
-    memset(data, '\0', sizeof(cached_read_data_t));
+    data = (squid_read_data_t *) xmalloc(sizeof(squid_read_data_t));
+    memset(data, '\0', sizeof(squid_read_data_t));
     data->sentry = sentry;
     data->fd = file_open((char *) config_file, NULL, O_RDONLY);
     storeAppend(sentry, open_bracket, (int) strlen(open_bracket));
-    file_walk(data->fd, (FILE_WALK_HD) cachedReadEndHandler, (void *) data,
-	(FILE_WALK_LHD) cachedReadHandler, (void *) data);
+    file_walk(data->fd, (FILE_WALK_HD) squidReadEndHandler, (void *) data,
+	(FILE_WALK_LHD) squidReadHandler, (void *) data);
 }
 
 
@@ -411,26 +411,26 @@ void info_get(obj, sentry)
     sprintf(line, "{Harvest Object Cache: Version %s}\n", version_string);
     storeAppend(sentry, line, strlen(line));
 
-    tod = mkrfc850(&cached_starttime);
+    tod = mkrfc850(&squid_starttime);
 
     sprintf(line, "{Start Time:\t%s}\n", tod);
     storeAppend(sentry, line, strlen(line));
 
-    tod = mkrfc850(&cached_curtime);
+    tod = mkrfc850(&squid_curtime);
     sprintf(line, "{Current Time:\t%s}\n", tod);
     storeAppend(sentry, line, strlen(line));
 
     /* -------------------------------------------------- */
 
-    sprintf(line, "{Connection information for cached:}\n");
+    sprintf(line, "{Connection information for %s:}\n", appname);
     storeAppend(sentry, line, strlen(line));
 
     sprintf(line, "{\tNumber of connections:\t%lu}\n", nconn);
     storeAppend(sentry, line, strlen(line));
 
     {
 	float f;
-	f = cached_curtime - cached_starttime;
+	f = squid_curtime - squid_starttime;
 	sprintf(line, "{\tConnections per hour:\t%.1f}\n", f == 0.0 ? 0.0 :
 	    (nconn / (f / 3600)));
 	storeAppend(sentry, line, strlen(line));
@@ -440,7 +440,7 @@ void info_get(obj, sentry)
 
 
 
-    sprintf(line, "{Cache information for cached:}\n");
+    sprintf(line, "{Cache information for %s:}\n", appname);
     storeAppend(sentry, line, strlen(line));
 
     sprintf(line, "{\tStorage Swap size:\t%d MB}\n", storeGetSwapSize() >> 10);
@@ -454,7 +454,7 @@ void info_get(obj, sentry)
     storeAppend(sentry, line, strlen(line));
 
 #if defined(HAVE_GETRUSAGE) && defined(RUSAGE_SELF)
-    sprintf(line, "{Resource usage for cached:}\n");
+    sprintf(line, "{Resource usage for %s:}\n", appname);
     storeAppend(sentry, line, strlen(line));
 
     getrusage(RUSAGE_SELF, &rusage);
@@ -472,7 +472,7 @@ void info_get(obj, sentry)
 #if HAVE_MALLINFO
     mp = mallinfo();
 
-    sprintf(line, "{Memory usage for cached via mallinfo():}\n");
+    sprintf(line, "{Memory usage for %s via mallinfo():}\n", appname);
     storeAppend(sentry, line, strlen(line));
 
     sprintf(line, "{\ttotal space in arena:\t%d KB}\n", mp.arena >> 10);
@@ -527,7 +527,7 @@ void info_get(obj, sentry)
 
 #endif /* HAVE_MALLINFO */
 
-    sprintf(line, "{File descriptor usage for cached:}\n");
+    sprintf(line, "{File descriptor usage for %s:}\n", appname);
     storeAppend(sentry, line, strlen(line));
 
     sprintf(line, "{\tMax number of file desc available:\t%d}\n", getMaxFD());
@@ -564,8 +564,8 @@ void info_get(obj, sentry)
 		to = comm_get_fd_timeout(i);
 		sprintf(line, "{\t\t(%3d = %3d, %3d) NET %s}\n",
 		    i,
-		    (int) (lft > 0 ? lft - cached_curtime : -1),
-		    (int) max((to - cached_curtime), 0),
+		    (int) (lft > 0 ? lft - squid_curtime : -1),
+		    (int) max((to - squid_curtime), 0),
 		    fd_note(i, NULL));
 		break;
 	    case File:
@@ -798,7 +798,7 @@ void log_append(obj, url, id, size, action, method, http_code, msec)
     if (obj->logfile_status == LOG_ENABLE) {
 	if (emulate_httpd_log)
 	    sprintf(tmp, "%s - - [%s] \"%s %s\" %s %d\n",
-		id, mkhttpdlogtime(&cached_curtime), method, url, action, size);
+		id, mkhttpdlogtime(&squid_curtime), method, url, action, size);
 	else
 	    sprintf(tmp, "%9d.%03d %6d %s %s/%03d %d %s %s\n",
 		(int) current_time.tv_sec,
@@ -971,7 +971,7 @@ void stat_init(object, logfilename)
     obj->log_disable = log_disable;
     obj->logfile_status = LOG_ENABLE;
 
-    obj->cached_get_start = cached_get_start;
+    obj->squid_get_start = squid_get_start;
 
     obj->parameter_get = parameter_get;
     obj->server_list = server_list;
@@ -1109,7 +1109,7 @@ char *ttl_describe(entry)
 
     TTL[0] = '\0';
     strcpy(TTL, "UNKNOWN");	/* sometimes the TTL isn't set below */
-    ttl = entry->expires - cached_curtime;
+    ttl = entry->expires - squid_curtime;
     if (ttl < 0)
 	strcpy(TTL, "EXPIRED");
     else {
@@ -1134,7 +1134,7 @@ char *elapsed_time(entry, since, TTL)
 
     TTL[0] = '\0';
     strcpy(TTL, "UNKNOWN");	/* sometimes TTL doesn't get set */
-    ttl = cached_curtime - since;
+    ttl = squid_curtime - since;
     if (since == 0) {
 	strcpy(TTL, "NEVER");
     } else if (ttl < 0) {
@@ -1,6 +1,6 @@
 
-/* $Id: store.cc,v 1.53 1996/04/15 23:02:28 wessels Exp $ */
-#ident "$Id: store.cc,v 1.53 1996/04/15 23:02:28 wessels Exp $"
+/* $Id: store.cc,v 1.54 1996/04/16 05:05:32 wessels Exp $ */
+#ident "$Id: store.cc,v 1.54 1996/04/16 05:05:32 wessels Exp $"
 
 /*
  * DEBUG: Section 20          store
@@ -325,7 +325,7 @@ static void storeLog(tag, e)
     int code = 0;
     if (storelog_fd < 0)
 	return;
-    t = e->expires - cached_curtime;
+    t = e->expires - squid_curtime;
     if (e->mem_obj) {
 	code = e->mem_obj->reply->code;
 	expect_len = (int) e->mem_obj->reply->content_length;
@@ -404,7 +404,7 @@ int storeLockObject(e)
 	/* If this sanity check fails, we should just ... */
 	fatal_dump(NULL);
     }
-    e->lastref = cached_curtime;
+    e->lastref = squid_curtime;
 
     /* StoreLockObject() is called during icp_hit_or_miss and once by storeAbort 
      * If the object is NOT_IN_MEMORY, fault it in. */
@@ -644,7 +644,7 @@ StoreEntry *storeCreateEntry(url, req_hdr, flags, method)
     e->lock_count = 0;
     m->data = new_MemObjectData();
     e->refcount = 0;
-    e->lastref = cached_curtime;
+    e->lastref = squid_curtime;
     e->timestamp = 0;		/* set in storeSwapOutHandle() */
     e->ping_status = NOPING;
 
@@ -699,7 +699,7 @@ StoreEntry *storeAddDiskRestore(url, file_number, size, expires, timestamp)
     e->lock_count = 0;
     BIT_RESET(e->flag, CLIENT_ABORT_REQUEST);
     e->refcount = 0;
-    e->lastref = cached_curtime;
+    e->lastref = squid_curtime;
     e->timestamp = (u_num32) timestamp;
     e->expires = (u_num32) expires;
     e->ping_status = NOPING;
@@ -871,7 +871,7 @@ void storeExpireNow(e)
      StoreEntry *e;
 {
     debug(20, 3, "storeExpireNow: '%s'\n", e->key);
-    e->expires = cached_curtime;
+    e->expires = squid_curtime;
 }
 
 /* switch object to deleting behind mode call by
@@ -1087,7 +1087,7 @@ void storeSwapOutHandle(fd, flag, e)
 
     debug(20, 3, "storeSwapOutHandle: '%s'\n", e->key);
 
-    e->timestamp = cached_curtime;
+    e->timestamp = squid_curtime;
     storeSwapFullPath(e->swap_file_number, filename);
     page_ptr = e->mem_obj->e_swap_buf;
 
@@ -1253,7 +1253,7 @@ static int storeDoRebuildFromDisk(data)
 	return 1;		/* skip bad lines */
 
     url[0] = log_swapfile[0] = '\0';
-    expires = cached_curtime;
+    expires = squid_curtime;
 
     scan3 = 0;
     size = 0;
@@ -1279,7 +1279,7 @@ static int storeDoRebuildFromDisk(data)
 
     if (!data->fast_mode) {
 	if (stat(swapfile, &sb) < 0) {
-	    if (expires < cached_curtime) {
+	    if (expires < squid_curtime) {
 		debug(20, 3, "storeRebuildFromDisk: Expired: <URL:%s>\n", url);
 		if (opt_unlink_on_reload)
 		    safeunlink(swapfile, 1);
@@ -1311,7 +1311,7 @@ static int storeDoRebuildFromDisk(data)
 	    return 1;
 	}
 	timestamp = sb.st_mtime;
-	debug(20, 10, "storeRebuildFromDisk: Cached file exists: <URL:%s>: %s\n",
+	debug(20, 10, "storeRebuildFromDisk: swap file exists: <URL:%s>: %s\n",
 	    url, swapfile);
     }
     if ((e = storeGet(url))) {
@@ -1328,7 +1328,7 @@ static int storeDoRebuildFromDisk(data)
 	data->objcount--;
 	data->dupcount++;
     }
-    if (expires < cached_curtime) {
+    if (expires < squid_curtime) {
 	debug(20, 3, "storeRebuildFromDisk: Expired: <URL:%s>\n", url);
 	if (opt_unlink_on_reload)
 	    safeunlink(swapfile, 1);
@@ -1487,7 +1487,7 @@ static int storeCheckSwapable(e)
 
     if (BIT_TEST(e->flag, ENTRY_PRIVATE)) {
 	debug(20, 2, "storeCheckSwapable: NO: private entry\n");
-    } else if (e->expires <= cached_curtime) {
+    } else if (e->expires <= squid_curtime) {
 	debug(20, 2, "storeCheckSwapable: NO: already expired\n");
     } else if (e->method != METHOD_GET) {
 	debug(20, 2, "storeCheckSwapable: NO: non-GET method\n");
@@ -1515,7 +1515,7 @@ void storeComplete(e)
 
     e->object_len = e->mem_obj->e_current_len;
     InvokeHandlers(e);
-    e->lastref = cached_curtime;
+    e->lastref = squid_curtime;
     e->status = STORE_OK;
     storeSetMemStatus(e, IN_MEMORY);
     e->swap_status = NO_SWAP;
@@ -1541,12 +1541,12 @@ int storeAbort(e, msg)
     static char abort_msg[2000];
 
     debug(20, 6, "storeAbort: '%s'\n", e->key);
-    e->expires = cached_curtime + getNegativeTTL();
+    e->expires = squid_curtime + getNegativeTTL();
     e->status = STORE_ABORTED;
     storeSetMemStatus(e, IN_MEMORY);
     /* No DISK swap for negative cached object */
     e->swap_status = NO_SWAP;
-    e->lastref = cached_curtime;
+    e->lastref = squid_curtime;
     /* In case some parent responds late and 
      * tries to restart the fetch, say that it's been
      * dispatched already.
@@ -1564,7 +1564,7 @@ int storeAbort(e, msg)
     mk_mime_hdr(mime_hdr,
 	(time_t) getNegativeTTL(),
 	6 + strlen(msg),
-	cached_curtime,
+	squid_curtime,
 	"text/html");
     if (msg) {
 	/* This can run off the end here. Be careful */
@@ -1675,9 +1675,9 @@ int removeOldEntry(e, data)
     debug(20, 6, "removeOldEntry:   * time in cache: %8ld\n",
 	curtime - e->timestamp);
     debug(20, 6, "removeOldEntry:   *  time-to-live: %8ld\n",
-	e->expires - cached_curtime);
+	e->expires - squid_curtime);
 
-    if ((cached_curtime > e->expires) && (e->status != STORE_PENDING)) {
+    if ((squid_curtime > e->expires) && (e->status != STORE_PENDING)) {
 	return (storeRelease(e) == 0 ? 1 : 0);
     }
     return 0;
@@ -1690,7 +1690,7 @@ int storePurgeOld()
     int n;
 
     debug(20, 3, "storePurgeOld: Begin purging TTL-expired objects\n");
-    n = storeWalkThrough(removeOldEntry, (void *) &cached_curtime);
+    n = storeWalkThrough(removeOldEntry, (void *) &squid_curtime);
     debug(20, 3, "storePurgeOld: Done purging TTL-expired objects.\n");
     debug(20, 3, "storePurgeOld: %d objects expired\n", n);
     return n;
@@ -1744,7 +1744,7 @@ int storeGetMemSpace(size, check_vm_number)
 	    }
 	    continue;
 	}
-	if (cached_curtime > e->expires) {
+	if (squid_curtime > e->expires) {
 	    debug(20, 2, "storeGetMemSpace: Expired: %s\n", e->url);
 	    n_expired++;
 	    /* Delayed release */
@@ -1977,7 +1977,7 @@ int storeGetSwapSpace(size)
 		(e->swap_status == SWAP_OK) &&	/* Only release it if it is on disk */
 		(e->lock_count == 0) &&		/* Be overly cautious */
 		(e->mem_status != SWAPPING_IN)) {	/* Not if it's being faulted into memory */
-		if (cached_curtime > e->expires) {
+		if (squid_curtime > e->expires) {
 		    debug(20, 2, "storeGetSwapSpace: Expired: <URL:%s>\n", e->url);
 		    /* just call release. don't have to check for lock status.
 		     * storeRelease will take care of that and set a pending flag
@@ -2326,7 +2326,7 @@ int storeClientCopy(e, stateoffset, maxSize, buf, size, fd)
 int storeEntryValidToSend(e)
      StoreEntry *e;
 {
-    if (cached_curtime < e->expires)
+    if (squid_curtime < e->expires)
 	return 1;
     if (e->expires == 0 && e->status == STORE_PENDING)
 	return 1;
@@ -2511,13 +2511,15 @@ void storeSanityCheck()
 	errno = 0;
 	if (access(name, W_OK)) {
 	    /* A very annoying problem occurs when access() fails because
-	     * the system file table is full.  To prevent cached from
+	     * the system file table is full.  To prevent squid from
 	     * deleting your entire disk cache on a whim, insist that the
 	     * errno indicates that the directory doesn't exist */
 	    if (errno != ENOENT)
 		continue;
-	    debug(20, 0, "WARNING: Cannot write to '%s' for storage swap area.\n", name);
-	    debug(20, 0, "Forcing a *full restart* (e.g., cached -z)...\n");
+	    debug(20, 0, "WARNING: Cannot write to swap directory '%s'\n",
+		name);
+	    debug(20, 0, "Forcing a *full restart* (e.g., %s -z)...\n",
+		appname);
 	    zap_disk_store = 1;
 	    return;
 	}
@@ -2575,10 +2577,10 @@ int storeMaintainSwapSpace()
 	while (link_ptr) {
 	    next = link_ptr->next;
 	    e = (StoreEntry *) link_ptr;
-	    if ((cached_curtime > e->expires) &&
+	    if ((squid_curtime > e->expires) &&
 		(e->swap_status == SWAP_OK)) {
 		debug(20, 2, "storeMaintainSwapSpace: Expired: <TTL:%d> <URL:%s>\n",
-		    e->expires - cached_curtime, e->url);
+		    e->expires - squid_curtime, e->url);
 		/* just call release. don't have to check for lock status.
 		 * storeRelease will take care of that and set a pending flag
 		 * if it's still locked. */
@@ -2670,7 +2672,7 @@ int swapInError(fd_unused, entry)
      int fd_unused;
      StoreEntry *entry;
 {
-    cached_error_entry(entry, ERR_DISK_IO, xstrerror());
+    squid_error_entry(entry, ERR_DISK_IO, xstrerror());
     return 0;
 }
 
@@ -1,5 +1,5 @@
 
-/* $Id: tools.cc,v 1.33 1996/04/15 22:54:55 wessels Exp $ */
+/* $Id: tools.cc,v 1.34 1996/04/16 05:05:33 wessels Exp $ */
 
 /*
  * DEBUG: Section 21          tools
@@ -8,7 +8,7 @@
 #include "squid.h"
 
 int do_mallinfo = 0;		/* don't do mallinfo() unless this gets set */
-time_t cached_curtime;
+time_t squid_curtime;
 struct timeval current_time;
 
 extern void serverConnectionsClose _PARAMS((void));
@@ -18,7 +18,7 @@ The Harvest Cache (version %s) died.\n\
 \n\
 You've encountered a fatal error in the Harvest Cache version %s.\n\
 If a core file was created (possibly in the swap directory),\n\
-please execute 'gdb cached core' or 'dbx cached core', then type 'where',\n\
+please execute 'gdb squid core' or 'dbx squid core', then type 'where',\n\
 and report the trace back to harvest-dvl@cs.colorado.edu.\n\
 \n\
 Thanks!\n"
@@ -39,7 +39,7 @@ void mail_warranty()
     sprintf(filename, "/tmp/mailin%d", (int) getpid());
     fp = fopen(filename, "w");
     if (fp != NULL) {
-	fprintf(fp, "From: cached\n");
+	fprintf(fp, "From: %s\n", appname);
 	fprintf(fp, "To: %s\n", getAdminEmail());
 	fprintf(fp, "Subject: %s\n", dead_msg());
 	fclose(fp);
@@ -339,9 +339,9 @@ void check_suid()
     if ((pwd = getpwnam(getEffectiveUser())) == NULL)
 	return;
     /* change current directory to swap space so we can get core */
-    if (chdir(swappath(0))) {
-	debug(21, 1, "Chdir Failed: Cached cannot write core file when it crash: %s\n",
-	    xstrerror());
+    if (chdir(swappath(0)))
+	debug(21, 0, "%s: %s\n", swappath(0), xstrerror());
+	fatal_dump("Cannot cd to swap directory?");
     }
     if (getEffectiveGroup() && (grp = getgrnam(getEffectiveGroup()))) {
 	setgid(grp->gr_gid);
@@ -402,7 +402,7 @@ void setMaxFD()
 time_t getCurrentTime()
 {
     gettimeofday(&current_time, NULL);
-    return cached_curtime = current_time.tv_sec;
+    return squid_curtime = current_time.tv_sec;
 }
 
 
@@ -1,4 +1,4 @@
-/* $Id: wais.cc,v 1.25 1996/04/16 04:23:18 wessels Exp $ */
+/* $Id: wais.cc,v 1.26 1996/04/16 05:05:35 wessels Exp $ */
 
 /*
  * DEBUG: Section 24          wais
@@ -35,7 +35,7 @@ static void waisReadReplyTimeout(fd, data)
 
     entry = data->entry;
     debug(24, 4, "waisReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
-    cached_error_entry(entry, ERR_READ_TIMEOUT, NULL);
+    squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     comm_set_select_handler(fd, COMM_SELECT_READ, 0, 0);
     waisCloseAndFree(fd, data);
 }
@@ -49,7 +49,7 @@ void waisLifetimeExpire(fd, data)
 
     entry = data->entry;
     debug(24, 4, "waisLifeTimeExpire: FD %d: <URL:%s>\n", fd, entry->url);
-    cached_error_entry(entry, ERR_LIFETIME_EXP, NULL);
+    squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     comm_set_select_handler(fd, COMM_SELECT_READ | COMM_SELECT_WRITE, 0, 0);
     waisCloseAndFree(fd, data);
 }
@@ -96,7 +96,7 @@ void waisReadReply(fd, data)
 	    }
 	} else {
 	    /* we can terminate connection right now */
-	    cached_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
+	    squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
 	    waisCloseAndFree(fd, data);
 	    return;
 	}
@@ -116,17 +116,17 @@ void waisReadReply(fd, data)
 	} else {
 	    BIT_RESET(entry->flag, CACHABLE);
 	    storeReleaseRequest(entry);
-	    cached_error_entry(entry, ERR_READ_ERROR, xstrerror());
+	    squid_error_entry(entry, ERR_READ_ERROR, xstrerror());
 	    waisCloseAndFree(fd, data);
 	}
     } else if (len == 0 && entry->mem_obj->e_current_len == 0) {
-	cached_error_entry(entry,
+	squid_error_entry(entry,
 	    ERR_ZERO_SIZE_OBJECT,
 	    errno ? xstrerror() : NULL);
 	waisCloseAndFree(fd, data);
     } else if (len == 0) {
 	/* Connection closed; retrieval done. */
-	entry->expires = cached_curtime;
+	entry->expires = squid_curtime;
 	storeComplete(entry);
 	waisCloseAndFree(fd, data);
     } else if (((entry->mem_obj->e_current_len + len) > getWAISMax()) &&
@@ -171,7 +171,7 @@ void waisSendComplete(fd, buf, size, errflag, data)
     debug(24, 5, "waisSendComplete - fd: %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
-	cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	waisCloseAndFree(fd, data);
     } else {
 	/* Schedule read reply. */
@@ -246,7 +246,7 @@ int waisStart(unusedfd, url, method, mime_hdr, entry)
 
     if (!getWaisRelayHost()) {
 	debug(24, 0, "waisStart: Failed because no relay host defined!\n");
-	cached_error_entry(entry, ERR_NO_RELAY, NULL);
+	squid_error_entry(entry, ERR_NO_RELAY, NULL);
 	safe_free(data);
 	return COMM_ERROR;
     }
@@ -255,7 +255,7 @@ int waisStart(unusedfd, url, method, mime_hdr, entry)
     sock = comm_open(COMM_NONBLOCKING, 0, 0, url);
     if (sock == COMM_ERROR) {
 	debug(24, 4, "waisStart: Failed because we're out of sockets.\n");
-	cached_error_entry(entry, ERR_NO_FDS, xstrerror());
+	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	safe_free(data);
 	return COMM_ERROR;
     }
@@ -264,14 +264,14 @@ int waisStart(unusedfd, url, method, mime_hdr, entry)
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(data->relayhost)) {
 	debug(24, 4, "waisstart: Called without IP entry in ipcache. OR lookup failed.\n");
-	cached_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
+	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	waisCloseAndFree(sock, data);
 	return COMM_ERROR;
     }
     /* Open connection. */
     if ((status = comm_connect(sock, data->relayhost, data->relayport))) {
 	if (status != EINPROGRESS) {
-	    cached_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
+	    squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
 	    waisCloseAndFree(sock, data);
 	    return COMM_ERROR;
 	} else {