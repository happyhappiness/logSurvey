@@ -1,4 +1,4 @@
-Changes to squid-3.4.0.1 (-- --- 2013):
+Changes to squid-3.4.0.1 (29 Jul 2013):
 
 	- Port from 2.7: StoreURL (renamed Store-ID) support
 	- Bug 3795: fix several mistakes in the MIB file
@@ -170,8 +170,8 @@ AC_DEFUN([SQUID_CC_GUESS_OPTIONS], [
    squid_cv_cc_arg_pipe=""
    ;;
   clang) 
-   squid_cv_cxx_option_werror="-Werror -Wno-error=parentheses-equality -Qunused-arguments"
-   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
+   squid_cv_cxx_option_werror="-Werror -Qunused-arguments"
+   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror"
    squid_cv_cc_option_wall="-Wall"
    squid_cv_cc_option_optimize="-O2"
    squid_cv_cc_arg_pipe=""
@@ -216,10 +216,8 @@ AC_DEFUN([SQUID_EMBED_BUILD_INFO],[
       ;;
   esac
   ])
-  if test "x${squid_build_info:=no}" != "xno"; then
-    AC_DEFINE_UNQUOTED([SQUID_BUILD_INFO],["$squid_build_info"],
-       [Squid extended build info field for "squid -v" output])
-  fi
+  AC_DEFINE_UNQUOTED([SQUID_BUILD_INFO],["$squid_build_info"],
+     [Squid extended build info field for "squid -v" output])
 ])
 
 dnl like AC_SEARCH_LIBS, with an extra argument which is
@@ -90,8 +90,6 @@ init_syntax_once(void)
 
 #endif /* not SYNTAX_TABLE */
 
-#define SYNTAX(c) re_syntax_table[c]
-
 /* Get the interface, including the syntax bits.  */
 #include "compat/GnuRegex.h"
 
@@ -889,9 +887,6 @@ static reg_errcode_t compile_range(const char **p_ptr, const char *pend, char *t
 
 #define INIT_COMPILE_STACK_SIZE 32
 
-#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
-#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
-
 /* The next available element.  */
 #define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
 
@@ -1420,7 +1415,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                 bufp->re_nsub++;
                 regnum++;
 
-                if (COMPILE_STACK_FULL) {
+                if (compile_stack.avail == compile_stack.size) {
                     RETALLOC(compile_stack.stack, compile_stack.size << 1,
                              compile_stack_elt_t);
                     if (compile_stack.stack == NULL)
@@ -1461,7 +1456,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                 if (syntax & RE_NO_BK_PARENS)
                     goto normal_backslash;
 
-                if (COMPILE_STACK_EMPTY) {
+                if (compile_stack.avail == 0) {
                     if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                         goto normal_backslash;
                     else
@@ -1479,7 +1474,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                     STORE_JUMP(jump_past_alt, fixup_alt_jump, b - 1);
                 }
                 /* See similar code for backslashed left paren above.  */
-                if (COMPILE_STACK_EMPTY) {
+                if (compile_stack.avail == 0) {
                     if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                         goto normal_char;
                     else
@@ -1832,7 +1827,7 @@ handle_interval: {
     if (fixup_alt_jump)
         STORE_JUMP(jump_past_alt, fixup_alt_jump, b);
 
-    if (!COMPILE_STACK_EMPTY)
+    if (compile_stack.avail != 0)
         return REG_EPAREN;
 
     free(compile_stack.stack);
@@ -2374,13 +2369,13 @@ struct re_pattern_buffer *bufp;
 
         case wordchar:
             for (j = 0; j < (1 << BYTEWIDTH); j++)
-                if (SYNTAX(j) == Sword)
+                if (re_syntax_table[j] == Sword)
                     fastmap[j] = 1;
             break;
 
         case notwordchar:
             for (j = 0; j < (1 << BYTEWIDTH); j++)
-                if (SYNTAX(j) != Sword)
+                if (re_syntax_table[j] != Sword)
                     fastmap[j] = 1;
             break;
 
@@ -2732,21 +2727,31 @@ static boolean group_match_null_string_p(unsigned char **p, unsigned char *end,
 /* Test if at very beginning or at very end of the virtual concatenation
  * of `string1' and `string2'.  If only one string, it's `string2'.  */
 #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
-#define AT_STRINGS_END(d) ((d) == end2)
+static int at_strings_end(const char *d, const char *end2)
+{
+    return d == end2;
+}
 
 /* Test if D points to a character which is word-constituent.  We have
  * two special cases to check for: if past the end of string1, look at
  * the first character in string2; and if before the beginning of
  * string2, look at the last character in string1.  */
 #define WORDCHAR_P(d)							\
-  (SYNTAX ((d) == end1 ? *string2					\
-           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
+  (re_syntax_table[(d) == end1 ? *string2					\
+           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]			\
    == Sword)
+static int
+wordchar_p(const char *d, const char *end1, const char *string2)
+{
+    return re_syntax_table[(d) == end1 ? *string2
+                           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]
+           == Sword;
+}
 
 /* Test if the character before D and the one at D differ with respect
  * to being word-constituent.  */
 #define AT_WORD_BOUNDARY(d)						\
-  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
+  (AT_STRINGS_BEG (d) || at_strings_end(d,end2)				\
    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
 
 /* Free everything we malloc.  */
@@ -3440,7 +3445,7 @@ int stop;
         case endline:
             DEBUG_PRINT1("EXECUTING endline.\n");
 
-            if (AT_STRINGS_END(d)) {
+            if (at_strings_end(d,end2)) {
                 if (!bufp->not_eol)
                     break;
             }
@@ -3461,7 +3466,7 @@ int stop;
             /* Match at the very end of the data.  */
         case endbuf:
             DEBUG_PRINT1("EXECUTING endbuf.\n");
-            if (AT_STRINGS_END(d))
+            if (at_strings_end(d,end2))
                 break;
             goto fail;
 
@@ -3739,21 +3744,21 @@ int stop;
 
         case wordbeg:
             DEBUG_PRINT1("EXECUTING wordbeg.\n");
-            if (WORDCHAR_P(d) && (AT_STRINGS_BEG(d) || !WORDCHAR_P(d - 1)))
+            if (wordchar_p(d,end1,string2) && (AT_STRINGS_BEG(d) || !WORDCHAR_P(d - 1)))
                 break;
             goto fail;
 
         case wordend:
             DEBUG_PRINT1("EXECUTING wordend.\n");
             if (!AT_STRINGS_BEG(d) && WORDCHAR_P(d - 1)
-                    && (!WORDCHAR_P(d) || AT_STRINGS_END(d)))
+                    && (!wordchar_p(d,end1,string2) || at_strings_end(d,end2)))
                 break;
             goto fail;
 
         case wordchar:
             DEBUG_PRINT1("EXECUTING non-Emacs wordchar.\n");
             PREFETCH();
-            if (!WORDCHAR_P(d))
+            if (!wordchar_p(d,end1,string2))
                 goto fail;
             SET_REGS_MATCHED();
             d++;
@@ -3762,7 +3767,7 @@ int stop;
         case notwordchar:
             DEBUG_PRINT1("EXECUTING non-Emacs notwordchar.\n");
             PREFETCH();
-            if (WORDCHAR_P(d))
+            if (wordchar_p(d,end1,string2))
                 goto fail;
             SET_REGS_MATCHED();
             d++;
@@ -71,7 +71,8 @@ fi
 
 # Check for C++0x compiler support
 AX_CXX_COMPILE_STDCXX_0X
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" ; then
+if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
+  "x$squid_host_os" != "xmingw" ; then
     #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
     # in the system libraries, which makes some c99 methods unavailable
     # (e.g. strtoll), yet configure detects them as avilable.
@@ -0,0 +1 @@
+</div>
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.0.0 release notes</title>
+<title>Squid 3.4.0.1 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,9 +13,9 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.0.1 for testing.
 
-This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.HEAD/"> or the
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
 While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
@@ -31,7 +31,7 @@ Although this release is deemed good enough for use in many setups, please note
 
 <sect1>Changes since earlier releases of Squid-3.4
 <p>
-The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.HEAD/changesets/" name="viewed here">.
+The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.4/changesets/" name="viewed here">.
 
 <sect>Major new features since Squid-3.3
 <p>Squid 3.4 represents a new feature release above 3.3.
@@ -180,11 +180,13 @@ Most user-facing changes are reflected in squid.conf (see below).
 <p>The internal DNS component fof Squid now supports multicast DNS (mDNS) resolution in
     accordance with RFC 6762.
 
-<p>There is no additional or special configuration required. The multicast DNS group IP
-   addresses for IPv4 and IPv6 resolving are added to the set of available DNS resolvers
-   and used automatically for domain names ending in <em>.local</em> before attempting a
-   secondary resolution on the configured resolvers. Domains without <em>.local</em> are
-   resolved using only the configured DNS resolvers.
+<p>The <em>dns_multicast_local</em> directive must be set to <em>on</em> to enable this
+   feature. 
+
+<p>The multicast DNS group IP addresses for IPv4 and IPv6 resolving are added to the set
+   of available DNS resolvers and used automatically for domain names ending in <em>.local</em>
+   and reverse-DNS lookups before attempting a secondary resolution on the configured
+   resolvers. Domains without <em>.local</em> are resolved using only the configured resolvers.
 
 <p>Statistics for multicast DNS resolution can be found on the <em>idns</em> cache manager
    report.
@@ -218,6 +220,9 @@ This section gives a thorough account of those changes in three categories:
 	<p>Whether Squid supports directive parameters with spaces, quotes, and other
 	   special characters. Surround such parameters with "double quotes".
 
+	<tag>dns_multicast_local</tag>
+	<p>Use multicast DNS for <em>.local</em> domains and reverse-DNS resolution.
+
 	<tag>note</tag>
 	<p>Use ACLs to annotate a transaction with customized annotations
 	   which can be logged in access.log
@@ -1,3 +1,7 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
@@ -130,6 +134,90 @@ name: X509_V_ERR_KEYUSAGE_NO_CERTSIGN
 detail: "%ssl_error_descr: %ssl_subject"
 descr: "Key usage does not include certificate signing"
 
+name: X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unable to get CRL issuer certificate"
+
+name: X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unhandled critical extension"
+
+name: X509_V_ERR_KEYUSAGE_NO_CRL_SIGN
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "key usage does not include CRL signing"
+
+name: X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unhandled critical CRL extension"
+
+name: X509_V_ERR_INVALID_NON_CA
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "invalid non-CA certificate (has CA markings)"
+
+name: X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "proxy path length constraint exceeded"
+
+name: X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "key usage does not include digital signature"
+
+name: X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "proxy certificates not allowed, please set the appropriate flag"
+
+name: X509_V_ERR_INVALID_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "invalid or inconsistent certificate extension"
+
+name: X509_V_ERR_INVALID_POLICY_EXTENSION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "invalid or inconsistent certificate policy extension"
+
+name: X509_V_ERR_NO_EXPLICIT_POLICY
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "no explicit policy"
+
+name: X509_V_ERR_DIFFERENT_CRL_SCOPE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Different CRL scope"
+
+name: X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Unsupported extension feature"
+
+name: X509_V_ERR_UNNESTED_RESOURCE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "RFC 3779 resource not subset of parent's resources"
+
+name: X509_V_ERR_PERMITTED_VIOLATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "permitted subtree violation"
+
+name: X509_V_ERR_EXCLUDED_VIOLATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "excluded subtree violation"
+
+name: X509_V_ERR_SUBTREE_MINMAX
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "name constraints minimum and maximum not supported"
+
+name: X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unsupported name constraint type"
+
+name: X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unsupported or invalid name constraint syntax"
+
+name: X509_V_ERR_UNSUPPORTED_NAME_SYNTAX
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "unsupported or invalid name syntax"
+
+name: X509_V_ERR_CRL_PATH_VALIDATION_ERROR
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "CRL path validation error"
+
 name: X509_V_ERR_APPLICATION_VERIFICATION
 detail: "%ssl_error_descr: %ssl_subject"
 descr: "Application verification failure"
@@ -45,7 +45,7 @@ char *optarg;			/* argument associated with option */
 
 #define	BADCH	(int)'?'
 #define	BADARG	(int)':'
-#define	EMSG	""
+#define	EMSG	(char*)""
 
 /*
  * getopt --
@@ -84,7 +84,7 @@ RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address, int port
     /* Resolve that name into an IP address */
 
     Service_Address = Called_Name;
-    if (strcmp(Called_Address, "") != 0) {      /* If the Called Address = "" */
+    if (strlen(Called_Address) != 0) {      /* If the Called Address = "" */
         Service_Address = Called_Address;
     }
     if ((errno = RFCNB_Name_To_IP(Service_Address, &Dest_IP)) < 0) {    /* Error */
@@ -152,7 +152,7 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
-    if (strcmp(con -> address, "") == 0)
+    if (strlen(con -> address) == 0)
         address = con -> desthost;
     else
         address = con -> address;
@@ -268,7 +268,7 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
 
     calling[strlen(con -> myname)] = 0;    /* Make it a string */
 
-    if (strcmp(con -> address, "") == 0)
+    if (strlen(con -> address) == 0)
         address = con -> desthost;
     else
         address = con -> address;
@@ -790,7 +790,7 @@ HTML_HEADER            = ./doc/Programming-Guide/doxygen.header.dyn
 # each generated HTML page. If it is left blank doxygen will generate a 
 # standard footer.
 
-#HTML_FOOTER            = ./doc/Programming-Guide/doxygen.footer.dyn
+HTML_FOOTER            = ./doc/Programming-Guide/doxygen.footer.dyn
 
 # The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
 # style sheet that is used by each HTML page. It can be used to 
@@ -38,14 +38,19 @@
 #include "fatal.h"
 #include "globals.h"
 
-int ConfigParser::RecognizeQuotedValues = true;
+bool ConfigParser::RecognizeQuotedValues = true;
+bool ConfigParser::StrictMode = true;
 std::stack<ConfigParser::CfgFile *> ConfigParser::CfgFiles;
 ConfigParser::TokenType ConfigParser::LastTokenType = ConfigParser::SimpleToken;
-char *ConfigParser::LastToken = NULL;
-char *ConfigParser::CfgLine = NULL;
-char *ConfigParser::CfgPos = NULL;
+const char *ConfigParser::CfgLine = NULL;
+const char *ConfigParser::CfgPos = NULL;
+std::queue<char *> ConfigParser::CfgLineTokens_;
 std::queue<std::string> ConfigParser::Undo_;
 bool ConfigParser::AllowMacros_ = false;
+bool ConfigParser::ParseQuotedOrToEol_ = false;
+bool ConfigParser::PreviewMode_ = false;
+
+static const char *SQUID_ERROR_TOKEN = "[invalid token]";
 
 void
 ConfigParser::destruct()
@@ -74,13 +79,6 @@ ConfigParser::destruct()
                cfg_filename, config_lineno, config_input_line);
 }
 
-void
-ConfigParser::TokenUndo()
-{
-    assert(LastToken);
-    Undo_.push(LastToken);
-}
-
 void
 ConfigParser::TokenPutBack(const char *tok)
 {
@@ -95,7 +93,8 @@ ConfigParser::Undo()
     if (!Undo_.empty()) {
         strncpy(undoToken, Undo_.front().c_str(), sizeof(undoToken));
         undoToken[sizeof(undoToken) - 1] = '\0';
-        Undo_.pop();
+        if (!PreviewMode_)
+            Undo_.pop();
         return undoToken;
     }
     return NULL;
@@ -113,21 +112,27 @@ ConfigParser::strtokFile()
     char *t;
     LOCAL_ARRAY(char, buf, CONFIG_LINE_LIMIT);
 
-    if ((LastToken = ConfigParser::Undo()))
-        return LastToken;
+    if ((t = ConfigParser::Undo()))
+        return t;
 
     do {
 
         if (!fromFile) {
             ConfigParser::TokenType tokenType;
-            t = ConfigParser::NextElement(tokenType, true);
+            t = ConfigParser::NextElement(tokenType);
             if (!t) {
                 return NULL;
-            } else if (tokenType == ConfigParser::QuotedToken) {
+            } else if (*t == '\"' || *t == '\'') {
                 /* quote found, start reading from file */
                 debugs(3, 8,"Quoted token found : " << t);
+                char *fn = ++t;
 
-                if ((wordFile = fopen(t, "r")) == NULL) {
+                while (*t && *t != '\"' && *t != '\'')
+                    ++t;
+
+                *t = '\0';
+
+                if ((wordFile = fopen(fn, "r")) == NULL) {
                     debugs(3, DBG_CRITICAL, "Can not open file " << t << " for reading");
                     return NULL;
                 }
@@ -138,7 +143,7 @@ ConfigParser::strtokFile()
 
                 fromFile = 1;
             } else {
-                return LastToken = t;
+                return t;
             }
         }
 
@@ -169,118 +174,216 @@ ConfigParser::strtokFile()
         /* skip blank lines */
     } while ( *t == '#' || !*t );
 
-    return LastToken = t;
+    return t;
 }
 
 char *
-ConfigParser::UnQuote(char *token, char **end)
+ConfigParser::UnQuote(const char *token, const char **next)
 {
+    const char *errorStr = NULL;
+    const char *errorPos = NULL;
     char quoteChar = *token;
     assert(quoteChar == '"' || quoteChar == '\'');
-    char  *s = token + 1;
-    /* scan until the end of the quoted string, unescaping " and \  */
-    while (*s && *s != quoteChar) {
-        if (*s == '\\' && isalnum(*( s + 1))) {
-            debugs(3, DBG_CRITICAL, "Unsupported escape sequence: " << s);
-            self_destruct();
+    LOCAL_ARRAY(char, UnQuoted, CONFIG_LINE_LIMIT);
+    const char  *s = token + 1;
+    char *d = UnQuoted;
+    /* scan until the end of the quoted string, handling escape sequences*/
+    while (*s && *s != quoteChar && !errorStr && (size_t)(d - UnQuoted) < sizeof(UnQuoted)) {
+        if (*s == '\\') {
+            s++;
+            switch (*s) {
+            case 'r':
+                *d = '\r';
+                break;
+            case 'n':
+                *d = '\n';
+                break;
+            case 't':
+                *d = '\t';
+                break;
+            default:
+                if (isalnum(*s)) {
+                    errorStr = "Unsupported escape sequence";
+                    errorPos = s;
+                }
+                *d = *s;
+                break;
+            }
+#if 0
         } else if (*s == '$' && quoteChar == '"') {
-            debugs(3, DBG_CRITICAL, "Unsupported cfg macro: " << s);
-            self_destruct();
+            errorStr = "Unsupported cfg macro";
+            errorPos = s;
+#endif
         } else if (*s == '%' && quoteChar == '"' && (!AllowMacros_ )) {
-            debugs(3, DBG_CRITICAL, "Macros are not supported here: " << s);
-            self_destruct();
-        } else if (*s == '\\') {
-            const char * next = s+1; // may point to 0
-            memmove(s, next, strlen(next) + 1);
-        }
+            errorStr = "Macros are not supported here";
+            errorPos = s;
+        } else
+            *d = *s;
         ++s;
+        ++d;
     }
 
-    if (*s != quoteChar) {
-        debugs(3, DBG_CRITICAL, "missing '" << quoteChar << "' at the end of quoted string: " << (s-1));
-        self_destruct();
+    if (*s != quoteChar && !errorStr) {
+        errorStr = "missing quote char at the end of quoted string";
+        errorPos = s - 1;
     }
-    *end = s;
-    return (token+1);
+    // The end of token
+    *d = '\0';
+
+    // We are expecting a separator after quoted string, space or one of "()#"
+    if (*(s + 1) != '\0' && !strchr(w_space "()#", *(s + 1)) && !errorStr) {
+        errorStr = "Expecting space after the end of quoted token";
+        errorPos = token;
+    }
+
+    if (errorStr) {
+        if (PreviewMode_)
+            strncpy(UnQuoted, SQUID_ERROR_TOKEN, sizeof(UnQuoted));
+        else {
+            debugs(3, DBG_CRITICAL, errorStr << ": " << errorPos);
+            self_destruct();
+        }
+    }
+
+    if (next)
+        *next = s + 1;
+    return UnQuoted;
 }
 
 void
 ConfigParser::SetCfgLine(char *line)
 {
     CfgLine = line;
     CfgPos = line;
+    while (!CfgLineTokens_.empty()) {
+        char *token = CfgLineTokens_.front();
+        CfgLineTokens_.pop();
+        free(token);
+    }
 }
 
 char *
-ConfigParser::TokenParse(char * &nextToken, ConfigParser::TokenType &type, bool legacy)
+ConfigParser::TokenParse(const char * &nextToken, ConfigParser::TokenType &type)
 {
     if (!nextToken || *nextToken == '\0')
         return NULL;
     type = ConfigParser::SimpleToken;
     nextToken += strspn(nextToken, w_space);
-    if (*nextToken == '"' || *nextToken == '\'') {
+
+    if (*nextToken == '#')
+        return NULL;
+
+    if (ConfigParser::RecognizeQuotedValues && (*nextToken == '"' || *nextToken == '\'')) {
         type = ConfigParser::QuotedToken;
-        char *token = UnQuote(nextToken, &nextToken);
-        *nextToken = '\0';
-        ++nextToken;
+        char *token = xstrdup(UnQuote(nextToken, &nextToken));
+        CfgLineTokens_.push(token);
         return token;
     }
 
-    char *token = nextToken;
-    if (char *t = strchr(nextToken, '#'))
-        *t = '\0';
+    const char *tokenStart = nextToken;
     const char *sep;
-    if (legacy)
+    if (ConfigParser::ParseQuotedOrToEol_)
+        sep = "\n";
+    else if (!ConfigParser::RecognizeQuotedValues || *nextToken == '(')
         sep = w_space;
     else
         sep = w_space "(";
     nextToken += strcspn(nextToken, sep);
 
-    if (!legacy && *nextToken == '(')
-        type = ConfigParser::FunctionNameToken;
-    else
+    if (ConfigParser::RecognizeQuotedValues && *nextToken == '(') {
+        if (strncmp(tokenStart, "parameters", nextToken - tokenStart) == 0)
+            type = ConfigParser::FunctionParameters;
+        else {
+            if (PreviewMode_) {
+                char *err = xstrdup(SQUID_ERROR_TOKEN);
+                CfgLineTokens_.push(err);
+                return err;
+            } else {
+                debugs(3, DBG_CRITICAL, "Unknown cfg function: " << tokenStart);
+                self_destruct();
+            }
+        }
+    } else
         type = ConfigParser::SimpleToken;
 
-    if (*nextToken != '\0') {
-        *nextToken = '\0';
-        ++nextToken;
+    char *token = NULL;
+    if (nextToken - tokenStart) {
+        if (ConfigParser::StrictMode && type == ConfigParser::SimpleToken) {
+            bool tokenIsNumber = true;
+            for (const char *s = tokenStart; s != nextToken; ++s) {
+                const bool isValidChar = isalnum(*s) || strchr(".,()-=_/:", *s) ||
+                                         (tokenIsNumber && *s == '%' && (s + 1 == nextToken));
+
+                if (!isdigit(*s))
+                    tokenIsNumber = false;
+
+                if (!isValidChar) {
+                    if (PreviewMode_) {
+                        char *err = xstrdup(SQUID_ERROR_TOKEN);
+                        CfgLineTokens_.push(err);
+                        return err;
+                    } else {
+                        debugs(3, DBG_CRITICAL, "Not alphanumeric character '"<< *s << "' in unquoted token " << tokenStart);
+                        self_destruct();
+                    }
+                }
+            }
+        }
+        token = xstrndup(tokenStart, nextToken - tokenStart + 1);
+        CfgLineTokens_.push(token);
     }
 
-    if (*token == '\0')
-        return NULL;
+    if (*nextToken != '\0' && *nextToken != '#') {
+        ++nextToken;
+    }
 
     return token;
 }
 
 char *
-ConfigParser::NextElement(ConfigParser::TokenType &type, bool legacy)
+ConfigParser::NextElement(ConfigParser::TokenType &type)
 {
-    char *token = TokenParse(CfgPos, type, legacy);
+    const char *pos = CfgPos;
+    char *token = TokenParse(pos, type);
+    // If not in preview mode the next call of this method should start
+    // parsing after the end of current token.
+    // For function "parameters(...)" we need always to update current parsing
+    // position to allow parser read the arguments of "parameters(..)"
+    if (!PreviewMode_ || type == FunctionParameters)
+        CfgPos = pos;
+    // else next call will read the same token
     return token;
 }
 
 char *
 ConfigParser::NextToken()
 {
-    if ((LastToken = ConfigParser::Undo()))
-        return LastToken;
-
     char *token = NULL;
+    if ((token = ConfigParser::Undo())) {
+        debugs(3, 6, "TOKEN (undone): " << token);
+        return token;
+    }
+
     do {
         while (token == NULL && !CfgFiles.empty()) {
             ConfigParser::CfgFile *wordfile = CfgFiles.top();
             token = wordfile->parse(LastTokenType);
             if (!token) {
                 assert(!wordfile->isOpen());
                 CfgFiles.pop();
+                debugs(3, 4, "CfgFiles.pop " << wordfile->filePath);
                 delete wordfile;
             }
         }
 
         if (!token)
             token = NextElement(LastTokenType);
 
-        if (token &&  LastTokenType == ConfigParser::FunctionNameToken && strcmp("parameters", token) == 0) {
+        if (token &&  LastTokenType == ConfigParser::FunctionParameters) {
+            //Disable temporary preview mode, we need to parse function parameters
+            const bool savePreview = ConfigParser::PreviewMode_;
+            ConfigParser::PreviewMode_ = false;
+
             char *path = NextToken();
             if (LastTokenType != ConfigParser::QuotedToken) {
                 debugs(3, DBG_CRITICAL, "Quoted filename missing: " << token);
@@ -290,6 +393,7 @@ ConfigParser::NextToken()
 
             // The next token in current cfg file line must be a ")"
             char *end = NextToken();
+            ConfigParser::PreviewMode_ = savePreview;
             if (LastTokenType != ConfigParser::SimpleToken || strcmp(end, ")") != 0) {
                 debugs(3, DBG_CRITICAL, "missing ')' after " << token << "(\"" << path << "\"");
                 self_destruct();
@@ -311,40 +415,70 @@ ConfigParser::NextToken()
             }
             CfgFiles.push(wordfile);
             token = NULL;
-        } else if (token &&  LastTokenType == ConfigParser::FunctionNameToken) {
-            debugs(3, DBG_CRITICAL, "Unknown cfg function: " << token);
-            self_destruct();
-            return NULL;
         }
     } while (token == NULL && !CfgFiles.empty());
 
-    return (LastToken = token);
+    return token;
+}
+
+char *
+ConfigParser::PeekAtToken()
+{
+    PreviewMode_ = true;
+    char *token = NextToken();
+    PreviewMode_ = false;
+    return token;
 }
 
 char *
 ConfigParser::NextQuotedOrToEol()
 {
-    char *token;
+    ParseQuotedOrToEol_ = true;
+    char *token = NextToken();
+    ParseQuotedOrToEol_ = false;
+
+    // Assume end of current config line
+    // Close all open configuration files for this config line
+    while (!CfgFiles.empty()) {
+        ConfigParser::CfgFile *wordfile = CfgFiles.top();
+        CfgFiles.pop();
+        delete wordfile;
+    }
 
-    if ((token = CfgPos) == NULL) {
-        debugs(3, DBG_CRITICAL, "token is missing");
+    return token;
+}
+
+char *
+ConfigParser::RegexStrtokFile()
+{
+    if (ConfigParser::RecognizeQuotedValues) {
+        debugs(3, DBG_CRITICAL, "Can not read regex expresion while configuration_includes_quoted_values is enabled");
         self_destruct();
-        return NULL;
     }
-    token += strspn(token, w_space);
-
-    if (*token == '\"' || *token == '\'') {
-        //TODO: eat the spaces at the end and check if it is untill the end of file.
-        char *end;
-        token = UnQuote(token, &end);
-        *end = '\0';
-        CfgPos = end + 1;
-        LastTokenType = ConfigParser::QuotedToken;
-    } else
-        LastTokenType = ConfigParser::SimpleToken;
+    char * token = strtokFile();
+    return token;
+}
 
-    CfgPos = NULL;
-    return (LastToken = token);
+char *
+ConfigParser::RegexPattern()
+{
+    if (ConfigParser::RecognizeQuotedValues) {
+        debugs(3, DBG_CRITICAL, "Can not read regex expresion while configuration_includes_quoted_values is enabled");
+        self_destruct();
+    }
+
+    char * token = NextToken();
+    return token;
+}
+
+char *
+ConfigParser::NextQuotedToken()
+{
+    const bool saveRecognizeQuotedValues = ConfigParser::RecognizeQuotedValues;
+    ConfigParser::RecognizeQuotedValues = true;
+    char *token = NextToken();
+    ConfigParser::RecognizeQuotedValues = saveRecognizeQuotedValues;
+    return token;
 }
 
 const char *
@@ -375,6 +509,7 @@ bool
 ConfigParser::CfgFile::startParse(char *path)
 {
     assert(wordFile == NULL);
+    debugs(3, 3, "Parsing from " << path);
     if ((wordFile = fopen(path, "r")) == NULL) {
         debugs(3, DBG_CRITICAL, "file :" << path << " not found");
         return false;
@@ -425,7 +560,12 @@ ConfigParser::CfgFile::parse(ConfigParser::TokenType &type)
 char *
 ConfigParser::CfgFile::nextElement(ConfigParser::TokenType &type)
 {
-    return TokenParse(parsePos, type);
+    const char *pos = parsePos;
+    char *token = TokenParse(pos, type);
+    if (!PreviewMode_ || type == FunctionParameters)
+        parsePos = pos;
+    // else next call will read the same token;
+    return token;
 }
 
 ConfigParser::CfgFile::~CfgFile()
@@ -70,7 +70,7 @@ class ConfigParser
      * Parsed tokens type: simple tokens, quoted tokens or function
      * like parameters.
      */
-    enum TokenType {SimpleToken, QuotedToken, FunctionNameToken};
+    enum TokenType {SimpleToken, QuotedToken, FunctionParameters};
 
     void destruct();
     static void ParseUShort(unsigned short *var);
@@ -93,6 +93,25 @@ class ConfigParser
      */
     static char *NextToken();
 
+    /**
+     * Backward compatibility wrapper for ConfigParser::RegexPattern method.
+     * If the configuration_includes_quoted_values configuration parameter is
+     * set to 'off' this interprets the quoted tokens as filenames.
+     */
+    static char *RegexStrtokFile();
+
+    /**
+     * Parse the next token as a regex patern. The regex patterns are non quoted
+     * tokens.
+     */
+    static char *RegexPattern();
+
+    /**
+     * Parse the next token with support for quoted values enabled even if
+     * the configuration_includes_quoted_values is set to off
+     */
+    static char *NextQuotedToken();
+
     /// \return true if the last parsed token was quoted
     static bool LastTokenWasQuoted() {return (LastTokenType == ConfigParser::QuotedToken);}
 
@@ -104,12 +123,12 @@ class ConfigParser
     static char *NextQuotedOrToEol();
 
     /**
-     * Undo last NextToken call. The next call to NextToken() method will return
-     * again the last parsed element.
-     * Can not be called repeatedly to undo multiple NextToken calls. In this case
-     * the behaviour is undefined.
+     * Preview the next token. The next NextToken() and strtokFile() call
+     * will return the same token.
+     * On parse error (eg invalid characters in token) will return an
+     * error message as token.
      */
-    static void TokenUndo();
+    static char *PeekAtToken();
 
     /**
      * The next NextToken call will return the token as next element
@@ -127,7 +146,15 @@ class ConfigParser
     static void DisableMacros() {AllowMacros_ = false;}
 
     /// configuration_includes_quoted_values in squid.conf
-    static int RecognizeQuotedValues;
+    static bool RecognizeQuotedValues;
+
+    /**
+     * Strict syntax mode. Does not allow not alphanumeric characters in unquoted tokens.
+     * Controled by the  configuration_includes_quoted_values in squid.conf but remains
+     * false when the the legacy ConfigParser::NextQuotedToken() call forces
+     * RecognizeQuotedValues to be temporary true.
+     */
+    static bool StrictMode;
 
 protected:
     /**
@@ -165,44 +192,42 @@ class ConfigParser
         char *nextElement(TokenType &type);
         FILE *wordFile; ///< Pointer to the file.
         char parseBuffer[CONFIG_LINE_LIMIT]; ///< Temporary buffer to store data to parse
-        char *parsePos; ///< The next element position in parseBuffer string
+        const char *parsePos; ///< The next element position in parseBuffer string
     public:
         std::string filePath; ///< The file path
         std::string currentLine; ///< The current line to parse
         int lineNo; ///< Current line number
     };
 
-    /**
-     * Return the last TokenUndo() or TokenPutBack() queued element, or NULL
-     * if none exist
-     */
+    /// Return the last TokenPutBack() queued element or NULL if none exist
     static char *Undo();
 
     /**
      * Unquotes the token, which must be quoted.
-     * \param end if it is not NULL, it is set to the end of token.
+     * \param next if it is not NULL, it is set after the end of token.
      */
-    static char *UnQuote(char *token, char **end = NULL);
+    static char *UnQuote(const char *token, const char **next = NULL);
 
     /**
      * Does the real tokens parsing job: Ignore comments, unquote an
      * element if required.
      * \return the next token, or NULL if there are no available tokens in the nextToken string.
      * \param nextToken updated to point to the pos after parsed token.
      * \param type      The token type
-     * \param legacy    If it is true function-like parameters are not allowed
      */
-    static char *TokenParse(char * &nextToken, TokenType &type, bool legacy = false);
+    static char *TokenParse(const char * &nextToken, TokenType &type);
 
     /// Wrapper method for TokenParse.
-    static char *NextElement(TokenType &type, bool legacy = false);
+    static char *NextElement(TokenType &type);
     static std::stack<CfgFile *> CfgFiles; ///< The stack of open cfg files
     static TokenType LastTokenType; ///< The type of last parsed element
-    static char *LastToken; ///< Points to the last parsed token
-    static char *CfgLine; ///< The current line to parse
-    static char *CfgPos; ///< Pointer to the next element in cfgLine string
-    static std::queue<std::string> Undo_; ///< The list with TokenUndo() or TokenPutBack() queued elements
+    static const char *CfgLine; ///< The current line to parse
+    static const char *CfgPos; ///< Pointer to the next element in cfgLine string
+    static std::queue<char *> CfgLineTokens_; ///< Store the list of tokens for current configuration line
+    static std::queue<std::string> Undo_; ///< The list with TokenPutBack() queued elements
     static bool AllowMacros_;
+    static bool ParseQuotedOrToEol_; ///< The next tokens will be handled as quoted or to_eol token
+    static bool PreviewMode_; ///< The next token will not poped from cfg files, will just previewd.
 };
 
 int parseConfigFile(const char *file_name);
@@ -50,7 +50,7 @@ AIODiskIOModule::init()
 {}
 
 void
-AIODiskIOModule::shutdown()
+AIODiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy *
@@ -42,7 +42,7 @@ class AIODiskIOModule : public DiskIOModule
     static AIODiskIOModule &GetInstance();
     AIODiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -32,8 +32,11 @@
  */
 
 #include "squid.h"
+#include "DiskIO/AIO/aio_win32.h"
 #include "comm.h"
-#include "aio_win32.h"
+#include "fd.h"
+#include "StatCounters.h"
+#include "win32.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
@@ -49,7 +49,7 @@ BlockingDiskIOModule::init()
 {}
 
 void
-BlockingDiskIOModule::shutdown()
+BlockingDiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy*
@@ -41,7 +41,7 @@ class BlockingDiskIOModule : public DiskIOModule
     static BlockingDiskIOModule &GetInstance();
     BlockingDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -79,7 +79,7 @@ DiskDaemonDiskIOModule::registerWithCacheManager(void)
 }
 
 void
-DiskDaemonDiskIOModule::shutdown()
+DiskDaemonDiskIOModule::gracefulShutdown()
 {
     initialised = false;
 }
@@ -41,7 +41,7 @@ class DiskDaemonDiskIOModule : public DiskIOModule
     static DiskDaemonDiskIOModule &GetInstance();
     DiskDaemonDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -95,7 +95,7 @@ DiskIOModule::FreeAllModules()
     while (GetModules().size()) {
         DiskIOModule *fs = GetModules().back();
         GetModules().pop_back();
-        fs->shutdown();
+        fs->gracefulShutdown();
     }
 }
 
@@ -65,7 +65,7 @@ class DiskIOModule
 
     virtual void init() = 0;
     //virtual void registerWithCacheManager(void);
-    virtual void shutdown() = 0;
+    virtual void gracefulShutdown() = 0;
     virtual DiskIOStrategy *createStrategy() = 0;
 
     virtual char const *type () const = 0;
@@ -37,6 +37,7 @@
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "fd.h"
 #include "globals.h"
+#include "win32.h"
 
 void
 CommIO::Initialize()
@@ -52,7 +52,7 @@ DiskThreadsDiskIOModule::init()
 }
 
 void
-DiskThreadsDiskIOModule::shutdown()
+DiskThreadsDiskIOModule::gracefulShutdown()
 {
     DiskThreadsIOStrategy::Instance.done();
 }
@@ -42,7 +42,7 @@ class DiskThreadsDiskIOModule : public DiskIOModule
     DiskThreadsDiskIOModule();
     virtual void init();
     //virtual void registerWithCacheManager(void);
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -35,6 +35,7 @@
 #include "squid.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "DiskThreads.h"
+#include "fd.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -209,7 +210,7 @@ squidaio_xfree(void *p, int size)
     MemAllocator *pool;
 
     if ((pool = squidaio_get_pool(size)) != NULL) {
-        pool->free(p);
+        pool->freeOne(p);
     } else
         xfree(p);
 }
@@ -221,7 +222,7 @@ squidaio_xstrfree(char *str)
     int len = strlen(str) + 1;
 
     if ((pool = squidaio_get_pool(len)) != NULL) {
-        pool->free(str);
+        pool->freeOne(str);
     } else
         xfree(str);
 }
@@ -295,7 +296,9 @@ squidaio_init(void)
 
     done_queue.blocked = 0;
 
-    CommIO::NotifyIOCompleted();
+    // Initialize the thread I/O pipes before creating any threads
+    // see bug 3189 comment 5 about race conditions.
+    CommIO::Initialize();
 
     /* Create threads and get them to sit in their wait loop */
     squidaio_thread_pool = memPoolCreate("aio_thread", sizeof(squidaio_thread_t));
@@ -715,7 +718,7 @@ squidaio_cleanup_request(squidaio_request_t * requestp)
         resultp->aio_errno = requestp->err;
     }
 
-    squidaio_request_pool->free(requestp);
+    squidaio_request_pool->freeOne(requestp);
 }				/* squidaio_cleanup_request */
 
 int
@@ -18,7 +18,7 @@ IpcIoDiskIOModule::init()
 {}
 
 void
-IpcIoDiskIOModule::shutdown()
+IpcIoDiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy*
@@ -10,7 +10,7 @@ class IpcIoDiskIOModule : public DiskIOModule
     static IpcIoDiskIOModule &GetInstance();
     IpcIoDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -18,7 +18,7 @@ MmappedDiskIOModule::init()
 {}
 
 void
-MmappedDiskIOModule::shutdown()
+MmappedDiskIOModule::gracefulShutdown()
 {}
 
 DiskIOStrategy*
@@ -10,7 +10,7 @@ class MmappedDiskIOModule : public DiskIOModule
     static MmappedDiskIOModule &GetInstance();
     MmappedDiskIOModule();
     virtual void init();
-    virtual void shutdown();
+    virtual void gracefulShutdown();
     virtual char const *type () const;
     virtual DiskIOStrategy* createStrategy();
 
@@ -1100,7 +1100,7 @@ FwdState::connectStart()
         ctimeout = ftimeout;
 
     if (serverDestinations[0]->getPeer() && request->flags.sslBumped) {
-        debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parrent proxy are not allowed");
+        debugs(50, 4, "fwdConnectStart: Ssl bumped connections through parent proxy are not allowed");
         ErrorState *anErr = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request);
         fail(anErr);
         self = NULL; // refcounted
@@ -1119,6 +1119,7 @@ FwdState::connectStart()
         else
             serverConn = NULL;
         if (Comm::IsConnOpen(serverConn)) {
+            pinned_connection->stopPinnedConnectionMonitoring();
             flags.connected_okay = true;
             ++n_tries;
             request->flags.pinned = true;
@@ -107,6 +107,7 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] = {
     {"Expires", HDR_EXPIRES, ftDate_1123},
     {"From", HDR_FROM, ftStr},
     {"Host", HDR_HOST, ftStr},
+    {"HTTP2-Settings", HDR_HTTP2_SETTINGS, ftStr}, /* for now */
     {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
     {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
     {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
@@ -254,6 +255,7 @@ static http_hdr_type ReplyHeadersArr[] = {
 static HttpHeaderMask RequestHeadersMask;	/* set run-time using RequestHeaders */
 static http_hdr_type RequestHeadersArr[] = {
     HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
+    HDR_HTTP2_SETTINGS,
     HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
     HDR_IF_RANGE, HDR_MAX_FORWARDS,
     HDR_ORIGIN,
@@ -264,7 +266,7 @@ static http_hdr_type RequestHeadersArr[] = {
 
 static HttpHeaderMask HopByHopHeadersMask;
 static http_hdr_type HopByHopHeadersArr[] = {
-    HDR_CONNECTION, HDR_KEEP_ALIVE, /*HDR_PROXY_AUTHENTICATE,*/ HDR_PROXY_AUTHORIZATION,
+    HDR_CONNECTION, HDR_HTTP2_SETTINGS, HDR_KEEP_ALIVE, /*HDR_PROXY_AUTHENTICATE,*/ HDR_PROXY_AUTHORIZATION,
     HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE, HDR_PROXY_CONNECTION
 };
 
@@ -83,6 +83,7 @@ typedef enum {
     HDR_EXPIRES,                        /**< RFC 2608, 2616 */
     HDR_FROM,                           /**< RFC 2608, 2616 */
     HDR_HOST,                           /**< RFC 2608, 2616 */
+    HDR_HTTP2_SETTINGS,                 /**< HTTP/2.0 upgrade header. see draft-ietf-httpbis-http2-04 */
     /*HDR_IF,*/                         /* RFC 2518 */
     HDR_IF_MATCH,                       /**< RFC 2608, 2616 */
     HDR_IF_MODIFIED_SINCE,              /**< RFC 2608, 2616 */
@@ -93,7 +93,7 @@ Note::Pointer
 Notes::parse(ConfigParser &parser)
 {
     String key = ConfigParser::NextToken();
-    String value = ConfigParser::NextToken();
+    String value = ConfigParser::NextQuotedToken();
     Note::Pointer note = add(key);
     Note::Value::Pointer noteValue = note->addValue(value);
 
@@ -189,8 +189,7 @@ GetInteger(void)
 int
 GetPercentage(void)
 {
-    int p;
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::NextToken();
 
     if (!token) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: A percentage value is missing.");
@@ -203,7 +202,7 @@ GetPercentage(void)
         *end = '\0';
     }
 
-    p = xatoi(token);
+    int p = xatoi(token);
 
     if (p < 0 || p > 100) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The value '" << token << "' is out of range. A percentage should be within [0, 100].");
@@ -355,6 +355,7 @@ class SquidConfig
         int memory_cache_disk;
         int hostStrictVerify;
         int client_dst_passthru;
+        int dns_mdns;
     } onoff;
 
     int pipeline_max_prefetch;
@@ -55,8 +55,8 @@ void
 ACLFlags::parseFlags()
 {
     char *nextToken;
-    while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
-
+    while ((nextToken = ConfigParser::PeekAtToken()) != NULL && nextToken[0] == '-') {
+        (void)ConfigParser::NextToken(); //Get token from cfg line
         //if token is the "--" break flag
         if (strcmp(nextToken, "--") == 0)
             break;
@@ -74,9 +74,6 @@ ACLFlags::parseFlags()
     /*Regex code needs to parse -i file*/
     if ( isSet(ACL_F_REGEX_CASE))
         ConfigParser::TokenPutBack("-i");
-
-    if (nextToken != NULL && strcmp(nextToken, "--") != 0 )
-        ConfigParser::TokenUndo();
 }
 
 const char *
@@ -322,7 +322,7 @@ aclParseRegexList(RegexList **curlist)
 
     debugs(28, 2, HERE << "aclParseRegexList: new Regex line or file");
 
-    while ((t = ConfigParser::strtokFile()) != NULL) {
+    while ((t = ConfigParser::RegexStrtokFile()) != NULL) {
         const char *clean = removeUnnecessaryWildcards(t);
         if (strlen(clean) > BUFSIZ-1) {
             debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
@@ -18,13 +18,50 @@ int HttpSockets[MAXTCPLISTENPORTS];
 
 AnyP::PortCfg::PortCfg() :
         next(NULL),
+        s(),
         transport(AnyP::PROTO_HTTP,1,1), // "Squid is an HTTP proxy", etc.
         name(NULL),
-        defaultsite(NULL)
+        defaultsite(NULL),
+        flags(),
+        allow_direct(false),
+        vhost(false),
+        actAsOrigin(false),
+        ignore_cc(false),
+        connection_auth_disabled(false),
+        vport(0),
+        disable_pmtu_discovery(0),
+        listenConn()
 #if USE_SSL
-        ,dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
+        ,cert(NULL),
+        key(NULL),
+        version(0),
+        cipher(NULL),
+        options(NULL),
+        clientca(NULL),
+        cafile(NULL),
+        capath(NULL),
+        crlfile(NULL),
+        dhfile(NULL),
+        sslflags(NULL),
+        sslContextSessionId(NULL),
+        generateHostCertificates(false),
+        dynamicCertMemCacheSize(std::numeric_limits<size_t>::max()),
+        staticSslContext(),
+        signingCert(),
+        signPkey(),
+        certsToChain(),
+        untrustedSigningCert(),
+        untrustedSignPkey(),
+        clientVerifyCrls(),
+        clientCA(),
+        dhParams(),
+        contextMethod(),
+        sslContextFlags(0),
+        sslOptions(0)
 #endif
-{}
+{
+    memset(&tcp_keepalive, 0, sizeof(tcp_keepalive));
+}
 
 AnyP::PortCfg::~PortCfg()
 {
@@ -816,7 +816,7 @@ Auth::Digest::Config::decode(char const *proxy_auth)
             vlen = 0;
         }
 
-        StringArea keyName(item, nlen-1);
+        StringArea keyName(item, nlen);
         String value;
 
         if (vlen > 0) {
@@ -255,6 +255,13 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
     case HelperReply::Okay: {
         /* we're finished, release the helper */
         const char *userLabel = reply.notes.findFirst("user");
+        if (!userLabel) {
+            auth_user_request->user()->credentials(Auth::Failed);
+            safe_free(lm_request->server_blob);
+            lm_request->releaseAuthServer();
+            debugs(29, DBG_CRITICAL, "ERROR: NTLM Authentication helper returned no username. Result: " << reply);
+            break;
+        }
         auth_user_request->user()->username(userLabel);
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
@@ -260,6 +260,10 @@ static void free_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap);
 
 static int parseOneConfigFile(const char *file_name, unsigned int depth);
 
+static void parse_configuration_includes_quoted_values(bool *recognizeQuotedValues);
+static void dump_configuration_includes_quoted_values(StoreEntry *const entry, const char *const name, bool recognizeQuotedValues);
+static void free_configuration_includes_quoted_values(bool *recognizeQuotedValues);
+
 /*
  * LegacyParser is a parser for legacy code that uses the global
  * approach.  This is static so that it is only exposed to cache_cf.
@@ -1381,8 +1385,12 @@ parse_address(Ip::Address *addr)
         addr->setNoAddr();
     else if ( (*addr = token) ) // try parse numeric/IPA
         (void) 0;
-    else
-        addr->GetHostByName(token); // dont use ipcache
+    else if (addr->GetHostByName(token)) // dont use ipcache
+        (void) 0;
+    else { // not an IP and not a hostname
+        debugs(3, DBG_CRITICAL, "FATAL: invalid IP address or domain name '" << token << "'");
+        self_destruct();
+    }
 }
 
 static void
@@ -1794,7 +1802,7 @@ parse_http_header_replace(HeaderManglers **pm)
         return;
     }
 
-    const char *value = t + strlen(t) + 1;
+    const char *value = ConfigParser::NextQuotedOrToEol();
 
     if (!*pm)
         *pm = new HeaderManglers;
@@ -2699,21 +2707,23 @@ parse_tristate(int *var)
 void
 parse_pipelinePrefetch(int *var)
 {
-    char *token = ConfigParser::strtokFile();
+    char *token = ConfigParser::PeekAtToken();
 
     if (token == NULL)
         self_destruct();
 
     if (!strcmp(token, "on")) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'pipeline_prefetch on' is deprecated. Please update to use 1 (or a higher number).");
         *var = 1;
+        //pop the token
+        (void)ConfigParser::NextToken();
     } else if (!strcmp(token, "off")) {
         debugs(0, DBG_PARSE_NOTE(2), "WARNING: 'pipeline_prefetch off' is deprecated. Please update to use '0'.");
         *var = 0;
-    } else {
-        ConfigParser::TokenUndo();
+        //pop the token
+        (void)ConfigParser::NextToken();
+    } else
         parse_int(var);
-    }
 }
 
 #define free_pipelinePrefetch free_int
@@ -2804,20 +2814,20 @@ parse_refreshpattern(RefreshPattern ** head)
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
 
-    if ((token = ConfigParser::NextToken()) == NULL) {
-        self_destruct();
-        return;
-    }
+    if ((token = ConfigParser::RegexPattern()) != NULL) {
+
+        if (strcmp(token, "-i") == 0) {
+            flags |= REG_ICASE;
+            token = ConfigParser::RegexPattern();
+        } else if (strcmp(token, "+i") == 0) {
+            flags &= ~REG_ICASE;
+            token = ConfigParser::RegexPattern();
+        }
 
-    if (strcmp(token, "-i") == 0) {
-        flags |= REG_ICASE;
-        token = ConfigParser::NextToken();
-    } else if (strcmp(token, "+i") == 0) {
-        flags &= ~REG_ICASE;
-        token = ConfigParser::NextToken();
     }
 
     if (token == NULL) {
+        debugs(3, DBG_CRITICAL, "FATAL: refresh_pattern missing the regex pattern parameter");
         self_destruct();
         return;
     }
@@ -2899,6 +2909,7 @@ parse_refreshpattern(RefreshPattern ** head)
         regerror(errcode, &comp, errbuf, sizeof errbuf);
         debugs(22, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(22, DBG_CRITICAL, "refreshAddToList: Invalid regular expression '" << pattern << "': " << errbuf);
+        xfree(pattern);
         return;
     }
 
@@ -3245,7 +3256,7 @@ void
 parse_wordlist(wordlist ** list)
 {
     char *token;
-    while ((token = ConfigParser::NextToken()))
+    while ((token = ConfigParser::NextQuotedToken()))
         wordlistAdd(list, token);
 }
 
@@ -4076,14 +4087,14 @@ parse_access_log(CustomLog ** logs)
     cl->filename = xstrdup(filename);
     cl->type = Log::Format::CLF_UNKNOWN;
 
-    const char *token = ConfigParser::strtokFile();
+    const char *token = ConfigParser::PeekAtToken();
     if (!token) { // style #1
         // no options to deal with
     } else if (!strchr(token, '=')) { // style #3
-        // if logformat name is not recognized,
-        // put back the token; it must be an ACL name
-        if (!setLogformat(cl, token, false))
-            ConfigParser::TokenUndo();
+        // if logformat name is recognized,
+        // pop the previewed token; Else it must be an ACL name
+        if (setLogformat(cl, token, false))
+            (void)ConfigParser::NextToken();
     } else { // style #4
         do {
             if (strncasecmp(token, "on-error=", 9) == 0) {
@@ -4101,14 +4112,16 @@ parse_access_log(CustomLog ** logs)
             } else if (strncasecmp(token, "logformat=", 10) == 0) {
                 setLogformat(cl, token+10, true);
             } else if (!strchr(token, '=')) {
-                // put back the token; it must be an ACL name
-                ConfigParser::TokenUndo();
+                // Do not pop the token; it must be an ACL name
                 break; // done with name=value options, now to ACLs
             } else {
                 debugs(3, DBG_CRITICAL, "Unknown access_log option " << token);
                 self_destruct();
             }
-        } while ((token = ConfigParser::strtokFile()) != NULL);
+            // Pop the token, it was a valid "name=value" option
+            (void)ConfigParser::NextToken();
+            // Get next with preview ConfigParser::NextToken call.
+        } while ((token = ConfigParser::PeekAtToken()) != NULL);
     }
 
     // set format if it has not been specified explicitly
@@ -4760,7 +4773,7 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
 
     Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
     ConfigParser::EnableMacros();
-    String buf = ConfigParser::NextToken();
+    String buf = ConfigParser::NextQuotedToken();
     ConfigParser::DisableMacros();
     hwa.fieldValue = buf.termedBuf();
     hwa.quoted = ConfigParser::LastTokenWasQuoted();
@@ -4809,3 +4822,33 @@ static void free_note(Notes *notes)
 {
     notes->clean();
 }
+
+static void
+parse_configuration_includes_quoted_values(bool *recognizeQuotedValues)
+{
+    int val = 0;
+    parse_onoff(&val);
+
+    // If quoted values is set to on then enable new strict mode parsing
+    if (val) {
+        ConfigParser::RecognizeQuotedValues = true;
+        ConfigParser::StrictMode = true;
+    } else {
+        ConfigParser::RecognizeQuotedValues = false;
+        ConfigParser::StrictMode = false;
+    }
+}
+
+static void
+dump_configuration_includes_quoted_values(StoreEntry *const entry, const char *const name, bool recognizeQuotedValues)
+{
+    int val = ConfigParser::RecognizeQuotedValues ? 1 : 0;
+    dump_onoff(entry, name, val);
+}
+
+static void
+free_configuration_includes_quoted_values(bool *recognizeQuotedValues)
+{
+    ConfigParser::RecognizeQuotedValues = false;
+    ConfigParser::StrictMode = false;
+}
@@ -14,6 +14,7 @@ b_ssize_t
 cachedir		cache_replacement_policy
 cachemgrpasswd
 ConfigAclTos
+configuration_includes_quoted_values
 CpuAffinityMap
 debug
 delay_pool_access	acl	delay_class
@@ -2453,6 +2453,9 @@ DOC_START
 	Without this option, all server certificate validation errors
 	terminate the transaction to protect Squid and the client.
 
+	SQUID_X509_V_ERR_INFINITE_VALIDATION error cannot be bypassed
+	but should not happen unless your OpenSSL library is buggy.
+
 	SECURITY WARNING:
 		Bypassing validation errors is dangerous because an
 		error usually implies that the server cannot be trusted
@@ -3133,7 +3136,7 @@ DOC_START
 DOC_END
 
 NAME: forward_max_tries
-DEFAULT: 10
+DEFAULT: 25
 TYPE: int
 LOC: Config.forward_max_tries
 DOC_START
@@ -8329,6 +8332,19 @@ DOC_START
 	Squid to handle single-component names, enable this option.
 DOC_END
 
+NAME: dns_multicast_local
+COMMENT: on|off
+TYPE: onoff
+DEFAULT: off
+DEFAULT_DOC: Search for .local and .arpa names is disabled.
+LOC: Config.onoff.dns_mdns
+DOC_START
+	When set to on, Squid sends multicast DNS lookups on the local
+	network for domains ending in .local and .arpa.
+	This enables local servers and devices to be contacted in an
+	ad-hoc or zero-configuration network environment.
+DOC_END
+
 NAME: dns_nameservers
 TYPE: wordlist
 DEFAULT: none
@@ -8466,8 +8482,8 @@ COMMENT_END
 
 NAME: configuration_includes_quoted_values
 COMMENT: on|off
-TYPE: onoff
-DEFAULT: on
+TYPE: configuration_includes_quoted_values
+DEFAULT: off
 LOC: ConfigParser::RecognizeQuotedValues
 DOC_START
 	If set, Squid will recognize each "quoted string" after a configuration
@@ -4483,7 +4483,7 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
     pinning.closeHandler = NULL; // Comm unregisters handlers before calling
     const bool sawZeroReply = pinning.zeroReply; // reset when unpinning
     unpinConnection();
-    if (sawZeroReply) {
+    if (sawZeroReply && clientConnection != NULL) {
         debugs(33, 3, "Closing client connection on pinned zero reply.");
         clientConnection->close();
     }
@@ -4495,8 +4495,10 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
     char desc[FD_DESC_SZ];
 
     if (Comm::IsConnOpen(pinning.serverConnection)) {
-        if (pinning.serverConnection->fd == pinServer->fd)
+        if (pinning.serverConnection->fd == pinServer->fd) {
+            startPinnedConnectionMonitoring();
             return;
+        }
     }
 
     unpinConnection(); // closes pinned connection, if any, and resets fields
@@ -4533,6 +4535,57 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
     Params &params = GetCommParams<Params>(pinning.closeHandler);
     params.conn = pinning.serverConnection;
     comm_add_close_handler(pinning.serverConnection->fd, pinning.closeHandler);
+
+    startPinnedConnectionMonitoring();
+}
+
+/// Assign a read handler to an idle pinned connection so that we can detect connection closures.
+void
+ConnStateData::startPinnedConnectionMonitoring()
+{
+    if (pinning.readHandler != NULL)
+        return; // already monitoring
+
+    typedef CommCbMemFunT<ConnStateData, CommIoCbParams> Dialer;
+    pinning.readHandler = JobCallback(33, 3,
+                                      Dialer, this, ConnStateData::clientPinnedConnectionRead);
+    static char unusedBuf[8];
+    comm_read(pinning.serverConnection, unusedBuf, sizeof(unusedBuf), pinning.readHandler);
+}
+
+void
+ConnStateData::stopPinnedConnectionMonitoring()
+{
+    if (pinning.readHandler != NULL) {
+        comm_read_cancel(pinning.serverConnection->fd, pinning.readHandler);
+        pinning.readHandler = NULL;
+    }
+}
+
+/// Our read handler called by Comm when the server either closes an idle pinned connection or
+/// perhaps unexpectedly sends something on that idle (from Squid p.o.v.) connection.
+void
+ConnStateData::clientPinnedConnectionRead(const CommIoCbParams &io)
+{
+    pinning.readHandler = NULL; // Comm unregisters handlers before calling
+
+    if (io.flag == COMM_ERR_CLOSING)
+        return; // close handler will clean up
+
+    // We could use getConcurrentRequestCount(), but this may be faster.
+    const bool clientIsIdle = !getCurrentContext();
+
+    debugs(33, 3, "idle pinned " << pinning.serverConnection << " read " <<
+           io.size << (clientIsIdle ? " with idle client" : ""));
+
+    assert(pinning.serverConnection == io.conn);
+    pinning.serverConnection->close();
+
+    // If we are still sending data to the client, do not close now. When we are done sending,
+    // ClientSocketContext::keepaliveNextRequest() checks pinning.serverConnection and will close.
+    // However, if we are idle, then we must close to inform the idle client and minimize races.
+    if (clientIsIdle && clientConnection != NULL)
+        clientConnection->close();
 }
 
 const Comm::ConnectionPointer
@@ -267,6 +267,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         bool auth;               /* pinned for www authentication */
         bool zeroReply; ///< server closed w/o response (ERR_ZERO_SIZE_OBJECT)
         CachePeer *peer;             /* CachePeer the connection goes via */
+        AsyncCall::Pointer readHandler; ///< detects serverConnection closure
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
@@ -333,6 +334,9 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /// the client-side-detected error response instead of getting stuck.
     void quitAfterError(HttpRequest *request); // meant to be private
 
+    /// The caller assumes responsibility for connection closure detection.
+    void stopPinnedConnectionMonitoring();
+
 #if USE_SSL
     /// called by FwdState when it is done bumping the server
     void httpsPeeked(Comm::ConnectionPointer serverConnection);
@@ -380,6 +384,9 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     void abortChunkedRequestBody(const err_type error);
     err_type handleChunkedRequestBody(size_t &putSize);
 
+    void startPinnedConnectionMonitoring();
+    void clientPinnedConnectionRead(const CommIoCbParams &io);
+
 private:
     int connReadWasError(comm_err_t flag, int size, int xerrno);
     int connFinishedWithConn(int size);
@@ -339,7 +339,7 @@ Comm::ConnOpener::connect()
 
         if (failRetries_ < Config.connect_retries) {
             debugs(5, 5, HERE << conn_ << ": * - try again");
-            sleep();
+            retrySleep();
             return;
         } else {
             // send ERROR back to the upper layer.
@@ -352,7 +352,7 @@ Comm::ConnOpener::connect()
 
 /// Close and wait a little before trying to open and connect again.
 void
-Comm::ConnOpener::sleep()
+Comm::ConnOpener::retrySleep()
 {
     Must(!calls_.sleep_);
     closeFd();
@@ -47,7 +47,7 @@ class ConnOpener : public AsyncJob
     void connected();
     void lookupLocalAddress();
 
-    void sleep();
+    void retrySleep();
     void restart();
 
     bool createFd();
@@ -268,6 +268,9 @@ static void idnsSendSlaveAAAAQuery(idns_query *q);
 static void
 idnsCheckMDNS(idns_query *q)
 {
+    if (!Config.onoff.dns_mdns || q->permit_mdns)
+        return;
+
     size_t slen = strlen(q->name);
     if (slen > 6 && memcmp(q->name +(slen-6),".local", 6) == 0) {
         q->permit_mdns = true;
@@ -279,6 +282,10 @@ idnsAddMDNSNameservers()
 {
     nns_mdns_count=0;
 
+    // mDNS is disabled
+    if (!Config.onoff.dns_mdns)
+        return;
+
     // mDNS resolver addresses are explicit multicast group IPs
     if (Ip::EnableIpv6) {
         idnsAddNameserver("FF02::FB");
@@ -717,21 +724,23 @@ idnsStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "Internal DNS Statistics:\n");
     storeAppendPrintf(sentry, "\nThe Queue:\n");
     storeAppendPrintf(sentry, "                       DELAY SINCE\n");
-    storeAppendPrintf(sentry, "  ID   SIZE SENDS FIRST SEND LAST SEND\n");
-    storeAppendPrintf(sentry, "------ ---- ----- ---------- ---------\n");
+    storeAppendPrintf(sentry, "  ID   SIZE SENDS FIRST SEND LAST SEND M FQDN\n");
+    storeAppendPrintf(sentry, "------ ---- ----- ---------- --------- - ----\n");
 
     for (n = lru_list.head; n; n = n->next) {
         q = (idns_query *)n->data;
-        storeAppendPrintf(sentry, "%#06x %4d %5d %10.3f %9.3f\n",
+        storeAppendPrintf(sentry, "%#06x %4d %5d %10.3f %9.3f %c %s\n",
                           (int) q->query_id, (int) q->sz, q->nsends,
                           tvSubDsec(q->start_t, current_time),
-                          tvSubDsec(q->sent_t, current_time));
+                          tvSubDsec(q->sent_t, current_time),
+                          (q->permit_mdns? 'M':' '),
+                          q->name);
     }
 
     if (Config.dns.packet_max > 0)
-        storeAppendPrintf(sentry, "DNS jumbo-grams: %zd Bytes\n", Config.dns.packet_max);
+        storeAppendPrintf(sentry, "\nDNS jumbo-grams: %zd Bytes\n", Config.dns.packet_max);
     else
-        storeAppendPrintf(sentry, "DNS jumbo-grams: not working\n");
+        storeAppendPrintf(sentry, "\nDNS jumbo-grams: not working\n");
 
     storeAppendPrintf(sentry, "\nNameservers:\n");
     storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES Type\n");
@@ -1816,7 +1825,7 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
     debugs(78, 3, "idnsPTRLookup: buf is " << q->sz << " bytes for " << ip <<
            ", id = 0x" << std::hex << q->query_id);
 
-    q->permit_mdns = true;
+    q->permit_mdns = Config.onoff.dns_mdns;
     idnsStartQuery(q, callback, data);
 }
 
@@ -369,6 +369,7 @@ fdAdjustReserved(void)
     if (Squid_MaxFD - newReserve < min(256, Squid_MaxFD / 2))
         fatalf("Too few filedescriptors available in the system (%d usable of %d).\n", Squid_MaxFD - newReserve, Squid_MaxFD);
 
-    debugs(51, DBG_CRITICAL, "Reserved FD adjusted from " << RESERVED_FD << " to " << newReserve << " due to failures");
+    debugs(51, DBG_CRITICAL, "Reserved FD adjusted from " << RESERVED_FD << " to " << newReserve <<
+           " due to failures (" << (Squid_MaxFD - newReserve) << "/" << Squid_MaxFD << " file descriptors available)");
     RESERVED_FD = newReserve;
 }
@@ -137,6 +137,7 @@ extern int ssl_ex_index_ssl_error_detail;      /* -1 */
 extern int ssl_ex_index_ssl_peeked_cert;      /* -1 */
 extern int ssl_ex_index_ssl_errors;   /* -1 */
 extern int ssl_ex_index_ssl_cert_chain;  /* -1 */
+extern int ssl_ex_index_ssl_validation_counter;  /* -1 */
 
 extern const char *external_acl_message;      /* NULL */
 extern int opt_send_signal;	/* -1 */
@@ -163,10 +163,6 @@ void WIN32_svcstatusupdate(DWORD, DWORD);
 void WINAPI WIN32_svcHandler(DWORD);
 #endif
 
-#if !defined(SQUID_BUILD_INFO)
-#define SQUID_BUILD_INFO ""
-#endif
-
 static char *opt_syslog_facility = NULL;
 static int icpPortNumOverride = 1;	/* Want to detect "-u 0" */
 static int configured_once = 0;
@@ -204,8 +204,6 @@ peerAllowedToUse(const CachePeer * p, HttpRequest * request)
         return do_ping;
 
     ACLFilledChecklist checklist(p->access, request, NULL);
-    checklist.src_addr = request->client_addr;
-    checklist.my_addr = request->my_addr;
 
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
@@ -19,8 +19,10 @@ typedef std::map<Ssl::ssl_error_t, const SslErrorEntry *> SslErrors;
 SslErrors TheSslErrors;
 
 static SslErrorEntry TheSslErrorArray[] = {
+    {SQUID_X509_V_ERR_INFINITE_VALIDATION,
+        "SQUID_X509_V_ERR_INFINITE_VALIDATION"},
     {SQUID_X509_V_ERR_CERT_CHANGE,
-        "SQUID_X509_V_ERR_CERT_CHANGE"},
+     "SQUID_X509_V_ERR_CERT_CHANGE"},
     {SQUID_ERR_SSL_HANDSHAKE,
      "SQUID_ERR_SSL_HANDSHAKE"},
     {SQUID_X509_V_ERR_DOMAIN_MISMATCH,
@@ -87,6 +89,132 @@ static SslErrorEntry TheSslErrorArray[] = {
      "X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH"},
     {X509_V_ERR_KEYUSAGE_NO_CERTSIGN,
      "X509_V_ERR_KEYUSAGE_NO_CERTSIGN"},
+#if defined(X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER)
+    {
+        X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER, //33
+        "X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER"
+    },
+#endif
+#if defined(X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION)
+    {
+        X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION, //34
+        "X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION"
+    },
+#endif
+#if defined(X509_V_ERR_KEYUSAGE_NO_CRL_SIGN)
+    {
+        X509_V_ERR_KEYUSAGE_NO_CRL_SIGN, //35
+        "X509_V_ERR_KEYUSAGE_NO_CRL_SIGN"
+    },
+#endif
+#if defined(X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION)
+    {
+        X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION, //36
+        "X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION"
+    },
+#endif
+#if defined(X509_V_ERR_INVALID_NON_CA)
+    {
+        X509_V_ERR_INVALID_NON_CA, //37
+        "X509_V_ERR_INVALID_NON_CA"
+    },
+#endif
+#if defined(X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED)
+    {
+        X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED, //38
+        "X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED"
+    },
+#endif
+#if defined(X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE)
+    {
+        X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE, //39
+        "X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE"
+    },
+#endif
+#if defined(X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED)
+    {
+        X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED, //40
+        "X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED"
+    },
+#endif
+#if defined(X509_V_ERR_INVALID_EXTENSION)
+    {
+        X509_V_ERR_INVALID_EXTENSION, //41
+        "X509_V_ERR_INVALID_EXTENSION"
+    },
+#endif
+#if defined(X509_V_ERR_INVALID_POLICY_EXTENSION)
+    {
+        X509_V_ERR_INVALID_POLICY_EXTENSION, //42
+        "X509_V_ERR_INVALID_POLICY_EXTENSION"
+    },
+#endif
+#if defined(X509_V_ERR_NO_EXPLICIT_POLICY)
+    {
+        X509_V_ERR_NO_EXPLICIT_POLICY, //43
+        "X509_V_ERR_NO_EXPLICIT_POLICY"
+    },
+#endif
+#if defined(X509_V_ERR_DIFFERENT_CRL_SCOPE)
+    {
+        X509_V_ERR_DIFFERENT_CRL_SCOPE, //44
+        "X509_V_ERR_DIFFERENT_CRL_SCOPE"
+    },
+#endif
+#if defined(X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE)
+    {
+        X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE, //45
+        "X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE"
+    },
+#endif
+#if defined(X509_V_ERR_UNNESTED_RESOURCE)
+    {
+        X509_V_ERR_UNNESTED_RESOURCE, //46
+        "X509_V_ERR_UNNESTED_RESOURCE"
+    },
+#endif
+#if defined(X509_V_ERR_PERMITTED_VIOLATION)
+    {
+        X509_V_ERR_PERMITTED_VIOLATION, //47
+        "X509_V_ERR_PERMITTED_VIOLATION"
+    },
+#endif
+#if defined(X509_V_ERR_EXCLUDED_VIOLATION)
+    {
+        X509_V_ERR_EXCLUDED_VIOLATION, //48
+        "X509_V_ERR_EXCLUDED_VIOLATION"
+    },
+#endif
+#if defined(X509_V_ERR_SUBTREE_MINMAX)
+    {
+        X509_V_ERR_SUBTREE_MINMAX, //49
+        "X509_V_ERR_SUBTREE_MINMAX"
+    },
+#endif
+#if defined(X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE)
+    {
+        X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE, //51
+        "X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE"
+    },
+#endif
+#if defined(X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX)
+    {
+        X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX, //52
+        "X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX"
+    },
+#endif
+#if defined(X509_V_ERR_UNSUPPORTED_NAME_SYNTAX)
+    {
+        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX, //53
+        "X509_V_ERR_UNSUPPORTED_NAME_SYNTAX"
+    },
+#endif
+#if defined(X509_V_ERR_CRL_PATH_VALIDATION_ERROR)
+    {
+        X509_V_ERR_CRL_PATH_VALIDATION_ERROR, //54
+        "X509_V_ERR_CRL_PATH_VALIDATION_ERROR"
+    },
+#endif
     {X509_V_ERR_APPLICATION_VERIFICATION,
      "X509_V_ERR_APPLICATION_VERIFICATION"},
     { SSL_ERROR_NONE, "SSL_ERROR_NONE"},
@@ -410,7 +410,7 @@ static  BIGNUM *createCertSerial(unsigned char *md, unsigned int n)
     serial = BN_bin2bn(md, n, NULL);
 
     // if the serial is "0" set it to '1'
-    if (BN_is_zero(serial))
+    if (BN_is_zero(serial) == true)
         BN_one(serial);
 
     // serial size does not exceed 20 bytes
@@ -239,6 +239,23 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
     X509_NAME_oneline(X509_get_subject_name(peer_cert), buffer,
                       sizeof(buffer));
 
+    // detect infinite loops
+    uint32_t *validationCounter = static_cast<uint32_t *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_validation_counter));
+    if (!validationCounter) {
+        validationCounter = new uint32_t(1);
+        SSL_set_ex_data(ssl, ssl_ex_index_ssl_validation_counter, validationCounter);
+    } else {
+        // overflows allowed if SQUID_CERT_VALIDATION_ITERATION_MAX >= UINT32_MAX
+        (*validationCounter)++;
+    }
+
+    if ((*validationCounter) >= SQUID_CERT_VALIDATION_ITERATION_MAX) {
+        ok = 0; // or the validation loop will never stop
+        error_no = SQUID_X509_V_ERR_INFINITE_VALIDATION;
+        debugs(83, 2, "SQUID_X509_V_ERR_INFINITE_VALIDATION: " <<
+               *validationCounter << " iterations while checking " << buffer);
+    }
+
     if (ok) {
         debugs(83, 5, "SSL Certificate signature OK: " << buffer);
 
@@ -282,30 +299,34 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
         else
             debugs(83, DBG_IMPORTANT, "SSL unknown certificate error " << error_no << " in " << buffer);
 
-        if (check) {
-            ACLFilledChecklist *filledCheck = Filled(check);
-            assert(!filledCheck->sslErrors);
-            filledCheck->sslErrors = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
-            filledCheck->serverCert.resetAndLock(peer_cert);
-            if (check->fastCheck() == ACCESS_ALLOWED) {
-                debugs(83, 3, "bypassing SSL error " << error_no << " in " << buffer);
-                ok = 1;
-            } else {
-                debugs(83, 5, "confirming SSL error " << error_no);
+        // Check if the certificate error can be bypassed.
+        // Infinity validation loop errors can not bypassed.
+        if (error_no != SQUID_X509_V_ERR_INFINITE_VALIDATION) {
+            if (check) {
+                ACLFilledChecklist *filledCheck = Filled(check);
+                assert(!filledCheck->sslErrors);
+                filledCheck->sslErrors = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
+                filledCheck->serverCert.resetAndLock(peer_cert);
+                if (check->fastCheck() == ACCESS_ALLOWED) {
+                    debugs(83, 3, "bypassing SSL error " << error_no << " in " << buffer);
+                    ok = 1;
+                } else {
+                    debugs(83, 5, "confirming SSL error " << error_no);
+                }
+                delete filledCheck->sslErrors;
+                filledCheck->sslErrors = NULL;
+                filledCheck->serverCert.reset(NULL);
             }
-            delete filledCheck->sslErrors;
-            filledCheck->sslErrors = NULL;
-            filledCheck->serverCert.reset(NULL);
-        }
-        // If the certificate validator is used then we need to allow all errors and
-        // pass them to certficate validator for more processing
-        else if (Ssl::TheConfig.ssl_crt_validator) {
-            ok = 1;
-            // Check if we have stored certificates chain. Store if not.
-            if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
-                STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
-                if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
-                    sk_X509_pop_free(certStack, X509_free);
+            // If the certificate validator is used then we need to allow all errors and
+            // pass them to certficate validator for more processing
+            else if (Ssl::TheConfig.ssl_crt_validator) {
+                ok = 1;
+                // Check if we have stored certificates chain. Store if not.
+                if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
+                    STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
+                    if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
+                        sk_X509_pop_free(certStack, X509_free);
+                }
             }
         }
     }
@@ -651,6 +672,15 @@ ssl_free_SslErrors(void *, void *ptr, CRYPTO_EX_DATA *,
     delete errs;
 }
 
+// "free" function for SSL_get_ex_new_index("ssl_ex_index_ssl_validation_counter")
+static void
+ssl_free_int(void *, void *ptr, CRYPTO_EX_DATA *,
+             int, long, void *)
+{
+    uint32_t *counter = static_cast <uint32_t *>(ptr);
+    delete counter;
+}
+
 /// \ingroup ServerProtocolSSLInternal
 /// Callback handler function to release STACK_OF(X509) "ex" data stored
 /// in an SSL object.
@@ -713,6 +743,7 @@ ssl_initialize(void)
     ssl_ex_index_ssl_peeked_cert  = SSL_get_ex_new_index(0, (void *) "ssl_peeked_cert", NULL, NULL, &ssl_free_X509);
     ssl_ex_index_ssl_errors =  SSL_get_ex_new_index(0, (void *) "ssl_errors", NULL, NULL, &ssl_free_SslErrors);
     ssl_ex_index_ssl_cert_chain = SSL_get_ex_new_index(0, (void *) "ssl_cert_chain", NULL, NULL, &ssl_free_CertChain);
+    ssl_ex_index_ssl_validation_counter = SSL_get_ex_new_index(0, (void *) "ssl_validation_counter", NULL, NULL, &ssl_free_int);
 }
 
 /// \ingroup ServerProtocolSSLInternal
@@ -55,13 +55,22 @@
  */
 
 // Custom SSL errors; assumes all official errors are positive
+#define SQUID_X509_V_ERR_INFINITE_VALIDATION -4
 #define SQUID_X509_V_ERR_CERT_CHANGE -3
 #define SQUID_ERR_SSL_HANDSHAKE -2
 #define SQUID_X509_V_ERR_DOMAIN_MISMATCH -1
 // All SSL errors range: from smallest (negative) custom to largest SSL error
 #define SQUID_SSL_ERROR_MIN SQUID_X509_V_ERR_CERT_CHANGE
 #define SQUID_SSL_ERROR_MAX INT_MAX
 
+// Maximum certificate validation callbacks. OpenSSL versions exceeding this
+// limit are deemed stuck in an infinite validation loop (OpenSSL bug #3090)
+// and will trigger the SQUID_X509_V_ERR_INFINITE_VALIDATION error.
+// Can be set to a number up to UINT32_MAX
+#ifndef SQUID_CERT_VALIDATION_ITERATION_MAX
+#define SQUID_CERT_VALIDATION_ITERATION_MAX 16384
+#endif
+
 namespace AnyP
 {
 class PortCfg;
@@ -673,6 +673,8 @@ DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "Squid Object Cache: Version %s\n",
                       version_string);
 
+    storeAppendPrintf(sentry, "Build Info: " SQUID_BUILD_INFO "\n");
+
 #if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
         storeAppendPrintf(sentry,"\nRunning as %s Windows System Service on %s\n",
@@ -34,10 +34,6 @@
 // Initial revision
 //
 //
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
-#pragma implementation
-#endif
-
 #include "conffile.hh"
 #include <sys/types.h>
 #include <errno.h>
@@ -39,16 +39,12 @@
 #define _CONFFILE_HH
 
 #if !defined(__cplusplus)
-#if defined(__GNUC__) || defined(__GNUG__)
-#pragma interface
-#else
 #ifndef HAVE_BOOL
 #define HAVE_BOOL
 typedef int bool;
 #define false 0
 #define true  1
 #endif
-#endif
 #endif /* __cplusplus */
 
 
@@ -40,9 +40,6 @@
 // Initial revision
 //
 //
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__) && !defined(__INTEL_COMPILER)
-#pragma implementation
-#endif
 
 #include "convert.hh"
 #include <string.h>
@@ -39,16 +39,12 @@
 #define _CONVERT_HH
 
 #if !defined(__cplusplus)
-#if defined(__GNUC__) || defined(__GNUG__)
-#pragma interface
-#else
 #ifndef HAVE_BOOL
 #define HAVE_BOOL 1
 typedef char bool;
 #define false 0
 #define true  1
 #endif
-#endif
 #endif /* __cplusplus */
 
 #include <sys/types.h>
@@ -35,10 +35,6 @@
 // Initial revision
 //
 //
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
-#pragma implementation
-#endif
-
 #include "squid.h"
 #include "copyout.hh"
 
@@ -35,16 +35,12 @@
 #define _COPYOUT_HH
 
 #if !defined(__cplusplus)
-#if defined(__GNUC__) || defined(__GNUG__)
-#pragma interface
-#else
 #ifndef HAVE_BOOL
 #define HAVE_BOOL
 typedef int bool;
 #define false 0
 #define true  1
 #endif
-#endif
 #endif /* __cplusplus */
 
 int
@@ -90,10 +90,6 @@
 // Initial revision
 //
 //
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
-#pragma implementation
-#endif
-
 #include "squid.h"
 #include "util.h"
 
@@ -41,11 +41,6 @@
 // Initial revision
 //
 //
-
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
-#pragma implementation
-#endif
-
 #include "squid.h"
 #include "signal.hh"
 
@@ -55,16 +55,12 @@
 #endif
 
 #if !defined(__cplusplus)
-#if defined(__GNUC__) || defined(__GNUG__)
-#pragma interface
-#else
 #ifndef HAVE_BOOL
 #define HAVE_BOOL
 typedef int bool;
 #define false 0
 #define true  1
 #endif
-#endif
 #endif /* __cplusplus */
 
 #if 1 // so far, all systems I know use void
@@ -42,10 +42,6 @@
 // Initial revision
 //
 //
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__) && !defined(__INTEL_COMPILER)
-#pragma implementation
-#endif
-
 #include "socket.hh"
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
@@ -45,16 +45,12 @@
 #define _SOCKET_HH
 
 #if !defined(__cplusplus)
-#if defined(__GNUC__) || defined(__GNUG__)
-#pragma interface
-#else
 #ifndef HAVE_BOOL
 #define HAVE_BOOL
 typedef int bool;
 #define false 0
 #define true  1
 #endif
-#endif
 #endif /* __cplusplus */
 
 #include <sys/types.h>
@@ -32,10 +32,6 @@
 // Initial revision
 //
 //
-#if (defined(__GNUC__) || defined(__GNUG__)) && !defined(__clang__)
-#pragma implementation
-#endif
-
 #include "squid.h"
 //#include <assert.h>
 #include "squid-tlv.hh"
@@ -35,16 +35,12 @@
 #define SQUID_TLV_HH
 
 #if !defined(__cplusplus)
-#if defined(__GNUC__) || defined(__GNUG__)
-#pragma interface
-#else
 #ifndef HAVE_BOOL
 #define HAVE_BOOL
 typedef int bool;
 #define false 0
 #define true  1
 #endif
-#endif
 #endif /* __cplusplus */
 
 #include <sys/types.h>