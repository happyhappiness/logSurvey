@@ -127,6 +127,12 @@ sub open_db()
     $_dbh = DBI->connect($dsn, $db_user, $db_passwd);
     if (!defined $_dbh) {
     	warn ("Could not connect to $dsn\n");
+	my @driver_names = DBI->available_drivers();
+	my $msg = "DSN drivers apparently installed, available:\n";
+	foreach my $dn (@driver_names) {
+		$msg .= "\t$dn";
+	}
+	warn($msg."\n");
 	return undef;
     }
     my $sql_query;
@@ -17,6 +17,9 @@ branchpath=${1:-trunk}
 tag=${2:-`basename $branchpath`}
 startdir=${PWD}
 date=`env TZ=GMT date +%Y%m%d`
+revision=`bzr revno`
+
+suffix="${date}-r${revision}"
 
 tmpdir=${TMPDIR:-${PWD}}/${module}-${tag}-mksnapshot
 
@@ -36,74 +39,75 @@ cd ${tmpdir}
 eval `grep "^ *PACKAGE_VERSION=" configure | sed -e 's/-BZR//' | sed -e 's/PACKAGE_//'`
 eval `grep "^ *PACKAGE_TARNAME=" configure | sed -e 's/_TARNAME//'`
 ed -s configure.ac <<EOS
-g/${VERSION}-[A-Z]*/ s//${VERSION}-${date}/
+g/${VERSION}-[A-Z]*/ s//${VERSION}-${suffix}/
 w
 EOS
 ed -s configure <<EOS
-g/${VERSION}-[A-Z]*/ s//${VERSION}-${date}/
+g/${VERSION}-[A-Z]*/ s//${VERSION}-${suffix}/
 w
 EOS
 
 echo "STATE..."
 echo "PACKAGE: ${PACKAGE}"
 echo "VERSION: ${VERSION}"
 echo "TAG: ${tag}"
+echo "REVISION: ${revision}"
 echo "STARTDIR: ${startdir}"
 echo "TMPDIR: ${tmpdir}"
 
 ./test-builds.sh --cleanup || exit 1
-./configure --silent
+./configure --silent --enable-build-info="DATE: ${date} REVISION: ${revision}"
 make -s dist-all
 
 webbase=/server/httpd/htdocs/squid-cache.org/content/
 basetarball=${webbase}/Versions/v`echo ${VERSION} | cut -d. -f1`/`echo ${VERSION} | cut -d. -f-2|cut -d- -f1`/${PACKAGE}-${VERSION}.tar.bz2
 
 echo "Building Tarball diff (${basetarball}) ..."
 if [ -f ${basetarball} ]; then
-	tar jxf ${PACKAGE}-${VERSION}-${date}.tar.bz2
+	tar jxf ${PACKAGE}-${VERSION}-${suffix}.tar.bz2
 	tar jxf ${basetarball}
-	echo "Differences from ${PACKAGE}-${VERSION} to ${PACKAGE}-${VERSION}-${date}" >${PACKAGE}-${VERSION}-${date}.diff
-	diff -ruN ${PACKAGE}-${VERSION} ${PACKAGE}-${VERSION}-${date} >>${PACKAGE}-${VERSION}-${date}.diff || true
+	echo "Differences from ${PACKAGE}-${VERSION} to ${PACKAGE}-${VERSION}-${suffix}" >${PACKAGE}-${VERSION}-${suffix}.diff
+	diff -ruN ${PACKAGE}-${VERSION} ${PACKAGE}-${VERSION}-${suffix} >>${PACKAGE}-${VERSION}-${suffix}.diff || true
 else
 	echo "Building Tarball diff ... skipped (no tarball exists)."
 fi
 
 cd ${startdir}
-echo "Preparing to publish: ${tmpdir}/${PACKAGE}-${VERSION}-${date}.tar.* ..."
+echo "Preparing to publish: ${tmpdir}/${PACKAGE}-${VERSION}-${suffix}.tar.* ..."
 #echo "LOCAL: " ; pwd
 #echo "BUILT TARS: " ; ls -1 ${tmpdir}/*.tar.* || true
 
-cp -p ${tmpdir}/${PACKAGE}-${VERSION}-${date}.tar.gz .
-echo ${PACKAGE}-${VERSION}-${date}.tar.gz >>${tag}.out
-cp -p ${tmpdir}/${PACKAGE}-${VERSION}-${date}.tar.bz2 .
-echo ${PACKAGE}-${VERSION}-${date}.tar.bz2 >>${tag}.out
-if [ -f ${tmpdir}/${PACKAGE}-${VERSION}-${date}.diff ]; then
-    cp -p ${tmpdir}/${PACKAGE}-${VERSION}-${date}.diff .
-    echo ${PACKAGE}-${VERSION}-${date}.diff >>${tag}.out
+cp -p ${tmpdir}/${PACKAGE}-${VERSION}-${suffix}.tar.gz .
+echo ${PACKAGE}-${VERSION}-${suffix}.tar.gz >>${tag}.out
+cp -p ${tmpdir}/${PACKAGE}-${VERSION}-${suffix}.tar.bz2 .
+echo ${PACKAGE}-${VERSION}-${suffix}.tar.bz2 >>${tag}.out
+if [ -f ${tmpdir}/${PACKAGE}-${VERSION}-${suffix}.diff ]; then
+    cp -p ${tmpdir}/${PACKAGE}-${VERSION}-${suffix}.diff .
+    echo ${PACKAGE}-${VERSION}-${suffix}.diff >>${tag}.out
 fi
 
 relnotes=${tmpdir}/doc/release-notes/release-`echo ${VERSION} | cut -d. -f1,2 | cut -d- -f1`.html
 if [ -f ${relnotes} ]; then
-	cp -p ${relnotes} ${PACKAGE}-${VERSION}-${date}-RELEASENOTES.html
-	echo ${PACKAGE}-${VERSION}-${date}-RELEASENOTES.html >>${tag}.out
-	ed -s ${PACKAGE}-${VERSION}-${date}-RELEASENOTES.html <<EOF
-g/"ChangeLog"/ s//"${PACKAGE}-${VERSION}-${date}-ChangeLog.txt"/g
+	cp -p ${relnotes} ${PACKAGE}-${VERSION}-${suffix}-RELEASENOTES.html
+	echo ${PACKAGE}-${VERSION}-${suffix}-RELEASENOTES.html >>${tag}.out
+	ed -s ${PACKAGE}-${VERSION}-${suffix}-RELEASENOTES.html <<EOF
+g/"ChangeLog"/ s//"${PACKAGE}-${VERSION}-${suffix}-ChangeLog.txt"/g
 w
 EOF
 fi
-cp -p ${tmpdir}/ChangeLog ${PACKAGE}-${VERSION}-${date}-ChangeLog.txt
-echo ${PACKAGE}-${VERSION}-${date}-ChangeLog.txt >>${tag}.out
+cp -p ${tmpdir}/ChangeLog ${PACKAGE}-${VERSION}-${suffix}-ChangeLog.txt
+echo ${PACKAGE}-${VERSION}-${suffix}-ChangeLog.txt >>${tag}.out
 
 # Generate Configuration Manual HTML
 if [ -x ${tmpdir}/scripts/www/build-cfg-help.pl ]; then
 	make -C ${tmpdir}/src cf.data
 	mkdir -p ${tmpdir}/doc/cfgman
 	${tmpdir}/scripts/www/build-cfg-help.pl --version ${VERSION} -o ${tmpdir}/doc/cfgman ${tmpdir}/src/cf.data
-	sh -c "cd ${tmpdir}/doc/cfgman && tar -zcf ${PWD}/${PACKAGE}-${VERSION}-${date}-cfgman.tar.gz *"
-	echo ${PACKAGE}-${VERSION}-${date}-cfgman.tar.gz >>${tag}.out
-	${tmpdir}/scripts/www/build-cfg-help.pl --version ${VERSION} -o ${PACKAGE}-${VERSION}-${date}-cfgman.html -f singlehtml ${tmpdir}/src/cf.data
-	gzip -f -9 ${PACKAGE}-${VERSION}-${date}-cfgman.html
-	echo ${PACKAGE}-${VERSION}-${date}-cfgman.html.gz >>${tag}.out
+	sh -c "cd ${tmpdir}/doc/cfgman && tar -zcf ${PWD}/${PACKAGE}-${VERSION}-${suffix}-cfgman.tar.gz *"
+	echo ${PACKAGE}-${VERSION}-${suffix}-cfgman.tar.gz >>${tag}.out
+	${tmpdir}/scripts/www/build-cfg-help.pl --version ${VERSION} -o ${PACKAGE}-${VERSION}-${suffix}-cfgman.html -f singlehtml ${tmpdir}/src/cf.data
+	gzip -f -9 ${PACKAGE}-${VERSION}-${suffix}-cfgman.html
+	echo ${PACKAGE}-${VERSION}-${suffix}-cfgman.html.gz >>${tag}.out
 fi
 
 # Collate Manual Pages and generate HTML versions
@@ -118,13 +122,13 @@ if (groff --help >/dev/null); then
 	for f in `ls -1 ${tmpdir}/doc/manuals/*.1  ${tmpdir}/doc/manuals/*.8 2>/dev/null` ; do
 		cat ${f} | groff -E -Thtml -mandoc >${f}.html
 	done
-	sh -c "cd ${tmpdir}/doc/manuals && tar -zcf ${PWD}/${PACKAGE}-${VERSION}-${date}-manuals.tar.gz *.html *.1 *.8"
-	echo ${PACKAGE}-${VERSION}-${date}-manuals.tar.gz >>${tag}.out
+	sh -c "cd ${tmpdir}/doc/manuals && tar -zcf ${PWD}/${PACKAGE}-${VERSION}-${suffix}-manuals.tar.gz *.html *.1 *.8"
+	echo ${PACKAGE}-${VERSION}-${suffix}-manuals.tar.gz >>${tag}.out
 fi
 
 # Generate language-pack tarballs
 # NP: Only to be done on trunk.
 if test "${tag}" = "trunk" ; then
-	sh -c "cd ${tmpdir}/errors && tar -zcf ${PWD}/${PACKAGE}-${VERSION}-${date}-langpack.tar.gz ./*/* ./alias* ./TRANSLATORS ./COPYRIGHT "
-	echo ${PACKAGE}-${VERSION}-${date}-langpack.tar.gz >>${tag}.out
+	sh -c "cd ${tmpdir}/errors && tar -zcf ${PWD}/${PACKAGE}-${VERSION}-${suffix}-langpack.tar.gz ./*/* ./alias* ./TRANSLATORS ./COPYRIGHT "
+	echo ${PACKAGE}-${VERSION}-${suffix}-langpack.tar.gz >>${tag}.out
 fi
@@ -39,6 +39,7 @@
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
+#include "ProtoPort.h"
 
 /* forward decls */
 class HttpReply;
@@ -148,6 +149,7 @@ class AccessLogEntry
 
         const char *ssluser;
 #endif
+        http_port_list *port;
 
     } cache;
 
@@ -205,7 +205,7 @@ void Adaptation::Icap::Xaction::closeConnection()
             disableRetries();
 
         const bool reset = !reuseConnection &&
-            (al.icap.outcome == xoGone || al.icap.outcome == xoError);
+                           (al.icap.outcome == xoGone || al.icap.outcome == xoError);
 
         Adaptation::Icap::ServiceRep &s = service();
         s.putConnection(connection, reuseConnection, reset, status());
@@ -19,9 +19,12 @@
  *
  */
 
-/// well-known registries (currently, deactivation is not performed for these)
+/// well-known registries
 typedef enum {
-    rrAfterConfig, ///< activated by main.cc after parsing squid.conf
+    /// managed by main.cc; activated after parsing squid.conf and
+    /// deactivated before freeing configuration-related memory or exit()-ing
+    rrAfterConfig,
+
     rrEnd ///< not a real registry, just a label to mark the end of enum
 } RunnerRegistry;
 
@@ -2952,6 +2952,9 @@ DOC_START
 		>la	Local IP address the client connected to
 		>lp	Local port number the client connected to
 
+		la	Local listening IP address the client connection was connected to.
+		lp	Local listening port number the client connection was connected to.
+
 		<a	Server IP address of the last server or peer connection
 		<A	Server FQDN or peer name
 		<p	Server port number of the last server or peer connection
@@ -3752,12 +3755,20 @@ TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.redir_rewrites_host
 DOC_START
-	By default Squid rewrites any Host: header in redirected
-	requests.  If you are running an accelerator this may
-	not be a wanted effect of a redirector.
-
+	To preserve same-origin security policies in browsers and
+	prevent Host: header forgery by redirectors Squid rewrites
+	any Host: header in redirected requests.
+	
+	If you are running an accelerator this may not be a wanted
+	effect of a redirector. This directive enables you disable
+	Host: alteration in reverse-proxy traffic.
+	
 	WARNING: Entries are cached on the result of the URL rewriting
 	process, so be careful if you have domain-virtual hosts.
+	
+	WARNING: Squid and other software verifies the URL and Host
+	are matching, so be careful not to relay through other proxies
+	or inspecting firewalls with this disabled.
 DOC_END
 
 NAME: url_rewrite_access redirector_access
@@ -7421,10 +7432,16 @@ TYPE: onoff
 LOC: Config.retry.onerror
 DEFAULT: off
 DOC_START
-	If set to on Squid will automatically retry requests when
-	receiving an error response. This is mainly useful if you
-	are in a complex cache hierarchy to work around access
-	control errors.
+	If set to ON Squid will automatically retry requests when
+	receiving an error response with status 403 (Forbidden),
+	500 (Internal Error), 501 or 503 (Service not available).
+	Status 502 and 504 (Gateway errors) are always retried.
+	
+	This is mainly useful if you are in a complex cache hierarchy to
+	work around access control errors.
+	
+	NOTE: This retry will attempt to find another working destination.
+	Which is different from the server which just failed.
 DOC_END
 
 NAME: as_whois_server
@@ -640,7 +640,10 @@ ClientHttpRequest::logRequest()
 
     al.cache.caddr.SetNoAddr();
 
-    if (getConn() != NULL) al.cache.caddr = getConn()->log_addr;
+    if (getConn() != NULL) {
+        al.cache.caddr = getConn()->log_addr;
+        al.cache.port =  cbdataReference(getConn()->port);
+    }
 
     al.cache.requestSize = req_sz;
     al.cache.requestHeadersSize = req_sz;
@@ -892,8 +892,8 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'I':
-        if (request && request->hier.host[0] != '\0') // if non-empty string
-            mb.Printf("%s", request->hier.host);
+        if (request && request->hier.tcpServer != NULL)
+            p = request->hier.tcpServer->remote.NtoA(ntoabuf,MAX_IPSTRLEN);
         else if (!building_deny_info_url)
             p = "[unknown]";
         break;
@@ -367,14 +367,32 @@ Format::Format::assemble(MemBuf &mb, AccessLogEntry *al, int logSequenceNumber)
             }
             break;
 
-        case LFT_CLIENT_LOCAL_IP_OLD_31:
+        case LFT_LOCAL_LISTENING_IP: {
+            // avoid logging a dash if we have reliable info
+            const bool interceptedAtKnownPort = (al->request->flags.spoof_client_ip ||
+                                                 al->request->flags.intercepted) && al->cache.port;
+            if (interceptedAtKnownPort) {
+                const bool portAddressConfigured = !al->cache.port->s.IsAnyAddr();
+                if (portAddressConfigured)
+                    out = al->cache.port->s.NtoA(tmp, sizeof(tmp));
+            } else if (al->tcpClient != NULL)
+                out = al->tcpClient->local.NtoA(tmp, sizeof(tmp));
+        }
+        break;
+
         case LFT_CLIENT_LOCAL_IP:
             if (al->tcpClient != NULL) {
                 out = al->tcpClient->local.NtoA(tmp,sizeof(tmp));
             }
             break;
 
-        case LFT_CLIENT_LOCAL_PORT_OLD_31:
+        case LFT_LOCAL_LISTENING_PORT:
+            if (al->cache.port) {
+                outint = al->cache.port->s.GetPort();
+                doint = 1;
+            }
+            break;
+
         case LFT_CLIENT_LOCAL_PORT:
             if (al->tcpClient != NULL) {
                 outint = al->tcpClient->local.GetPort();
@@ -62,9 +62,9 @@ static struct TokenTableEntry TokenTable1C[] = {
 static struct TokenTableEntry TokenTable2C[] = {
 
     {">la", LFT_CLIENT_LOCAL_IP},
-    {"la", LFT_CLIENT_LOCAL_IP_OLD_31},
+    {"la", LFT_LOCAL_LISTENING_IP},
     {">lp", LFT_CLIENT_LOCAL_PORT},
-    {"lp", LFT_CLIENT_LOCAL_PORT_OLD_31},
+    {"lp", LFT_LOCAL_LISTENING_PORT},
     /*{ "lA", LFT_LOCAL_NAME }, */
 
     {"<la", LFT_SERVER_LOCAL_IP},
@@ -496,16 +496,6 @@ Format::Token::parse(char *def, Quoting *quoting)
         type = LFT_HTTP_SENT_STATUS_CODE;
         break;
 
-    case LFT_CLIENT_LOCAL_IP_OLD_31:
-        debugs(46, 0, "WARNING: The \"la\" formatting code is deprecated. Use the \">la\" instead.");
-        type = LFT_CLIENT_LOCAL_IP;
-        break;
-
-    case LFT_CLIENT_LOCAL_PORT_OLD_31:
-        debugs(46, 0, "WARNING: The \"lp\" formatting code is deprecated. Use the \">lp\" instead.");
-        type = LFT_CLIENT_LOCAL_PORT;
-        break;
-
     case LFT_SERVER_LOCAL_IP_OLD_27:
         debugs(46, 0, "WARNING: The \"oa\" formatting code is deprecated. Use the \"<la\" instead.");
         type = LFT_SERVER_LOCAL_IP;
@@ -35,9 +35,9 @@ typedef enum {
     LFT_SERVER_PORT,
 
     LFT_CLIENT_LOCAL_IP,
-    LFT_CLIENT_LOCAL_IP_OLD_31,
+    LFT_LOCAL_LISTENING_IP,
     LFT_CLIENT_LOCAL_PORT,
-    LFT_CLIENT_LOCAL_PORT_OLD_31,
+    LFT_LOCAL_LISTENING_PORT,
     /*LFT_LOCAL_NAME, */
 
     LFT_SERVER_LOCAL_IP,
@@ -1199,9 +1199,13 @@ aclMapNfmark(acl_nfmark * head, ACLChecklist * ch)
 void
 getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
 {
-    /* skip if an outgoing address is already set. */
+    // skip if an outgoing address is already set.
     if (!conn->local.IsAnyAddr()) return;
 
+    // ensure that at minimum the wildcard local matches remote protocol
+    if (conn->remote.IsIPv4())
+        conn->local.SetIPv4();
+
     // maybe use TPROXY client address
     if (request && request->flags.spoof_client_ip) {
         if (!conn->getPeer() || !conn->getPeer()->options.no_tproxy) {
@@ -2723,6 +2723,7 @@ ftpReadPasv(FtpStateData * ftpState)
 
     Comm::ConnectionPointer conn = new Comm::Connection;
     conn->local = ftpState->ctrl.conn->local;
+    conn->local.SetPort(0);
     conn->remote = ipaddr;
     conn->remote.SetPort(port);
 
@@ -596,6 +596,7 @@ accessLogFreeMemory(AccessLogEntry * aLogEntry)
     HTTPMSGUNLOCK(aLogEntry->icap.reply);
     HTTPMSGUNLOCK(aLogEntry->icap.request);
 #endif
+    cbdataReferenceDone(aLogEntry->cache.port);
 }
 
 int
@@ -156,8 +156,6 @@ peerSelect(Comm::ConnectionList * paths,
 
     psstate->callback_data = cbdataReference(callback_data);
 
-    psstate->direct = DIRECT_UNKNOWN;
-
 #if USE_CACHE_DIGESTS
 
     request->hier.peer_select_start = current_time;
@@ -177,6 +175,18 @@ peerCheckNeverDirectDone(allow_t answer, void *data)
     psstate->acl_checklist = NULL;
     debugs(44, 3, "peerCheckNeverDirectDone: " << answer);
     psstate->never_direct = answer;
+    switch (answer) {
+    case ACCESS_ALLOWED:
+        /** if always_direct says YES, do that. */
+        psstate->direct = DIRECT_YES;
+        debugs(44, 3, HERE << "direct = " << DirectStr[psstate->direct] << " (never_direct allow)");
+        break;
+    case ACCESS_DENIED: // not relevant.
+        break;
+    default: // Oops. Failed to get a result.
+        debugs(44, DBG_IMPORTANT, "WARNING: never_direct resulted in " << answer << ". Username ACLs are not reliable here.");
+        assert(answer != ACCESS_DUNNO);
+    }
     peerSelectFoo(psstate);
 }
 
@@ -187,6 +197,18 @@ peerCheckAlwaysDirectDone(allow_t answer, void *data)
     psstate->acl_checklist = NULL;
     debugs(44, 3, "peerCheckAlwaysDirectDone: " << answer);
     psstate->always_direct = answer;
+    switch (answer) {
+    case ACCESS_ALLOWED:
+        /** if always_direct says YES, do that. */
+        psstate->direct = DIRECT_YES;
+        debugs(44, 3, HERE << "direct = " << DirectStr[psstate->direct] << " (always_direct allow)");
+        break;
+    case ACCESS_DENIED: // not relevant.
+        break;
+    default: // Oops. Failed to get a result.
+        debugs(44, DBG_IMPORTANT, "WARNING: always_direct resulted in " << answer << ". Username ACLs are not reliable here.");
+        assert(answer != ACCESS_DUNNO);
+    }
     peerSelectFoo(psstate);
 }
 
@@ -279,13 +301,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
 
             // check for a configured outgoing address for this destination...
             getOutgoingAddress(psstate->request, p);
-            if (p->remote.IsIPv4() && !p->local.SetIPv4()) {
-                // This should never happen. getOutgoing should match by family or skip.
-                assert(p->local.IsAnyAddr());
-                continue;
-            } else {
-                psstate->paths->push_back(p);
-            }
+            psstate->paths->push_back(p);
         }
     } else {
         debugs(44, 3, HERE << "Unknown host: " << fs->_peer ? fs->_peer->host : psstate->request->GetHost());
@@ -350,41 +366,34 @@ peerSelectFoo(ps_state * ps)
     HttpRequest *request = ps->request;
     debugs(44, 3, "peerSelectFoo: '" << RequestMethodStr(request->method) << " " << request->GetHost() << "'");
 
-    /** If we don't known whether DIRECT is permitted ... */
+    /** If we don't know whether DIRECT is permitted ... */
     if (ps->direct == DIRECT_UNKNOWN) {
-        if (ps->always_direct == ACCESS_DUNNO && Config.accessList.AlwaysDirect) {
+        if (ps->always_direct == ACCESS_DUNNO) {
+            debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (always_direct to be checked)");
             /** check always_direct; */
-            ps->acl_checklist = new ACLFilledChecklist(
-                Config.accessList.AlwaysDirect,
-                request,
-                NULL);		/* ident */
+            ps->acl_checklist = new ACLFilledChecklist(Config.accessList.AlwaysDirect, request, NULL);
             ps->acl_checklist->nonBlockingCheck(peerCheckAlwaysDirectDone, ps);
             return;
-        } else if (ps->always_direct == ACCESS_ALLOWED) {
-            /** if always_direct says YES, do that. */
-            ps->direct = DIRECT_YES;
-        } else if (ps->never_direct == ACCESS_DUNNO && Config.accessList.NeverDirect) {
+        } else if (ps->never_direct == ACCESS_DUNNO) {
+            debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (never_direct to be checked)");
             /** check never_direct; */
-            ps->acl_checklist = new ACLFilledChecklist(
-                Config.accessList.NeverDirect,
-                request,
-                NULL);		/* ident */
-            ps->acl_checklist->nonBlockingCheck(peerCheckNeverDirectDone,
-                                                ps);
+            ps->acl_checklist = new ACLFilledChecklist(Config.accessList.NeverDirect, request, NULL);
+            ps->acl_checklist->nonBlockingCheck(peerCheckNeverDirectDone, ps);
             return;
-        } else if (ps->never_direct == ACCESS_ALLOWED) {
-            /** if always_direct says NO, do that. */
-            ps->direct = DIRECT_NO;
         } else if (request->flags.no_direct) {
             /** if we are accelerating, direct is not an option. */
             ps->direct = DIRECT_NO;
+            debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (forced non-direct)");
         } else if (request->flags.loopdetect) {
             /** if we are in a forwarding-loop, direct is not an option. */
             ps->direct = DIRECT_YES;
+            debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (forwarding loop detected)");
         } else if (peerCheckNetdbDirect(ps)) {
             ps->direct = DIRECT_YES;
+            debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (checkNetdbDirect)");
         } else {
             ps->direct = DIRECT_MAYBE;
+            debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct] << " (default)");
         }
 
         debugs(44, 3, "peerSelectFoo: direct = " << DirectStr[ps->direct]);
@@ -871,9 +880,9 @@ ps_state::operator new(size_t)
 
 ps_state::ps_state() : request (NULL),
         entry (NULL),
-        always_direct(ACCESS_DUNNO),
-        never_direct(ACCESS_DUNNO),
-        direct (0),
+        always_direct(Config.accessList.AlwaysDirect?ACCESS_DUNNO:ACCESS_DENIED),
+        never_direct(Config.accessList.NeverDirect?ACCESS_DUNNO:ACCESS_DENIED),
+        direct(DIRECT_UNKNOWN),
         callback (NULL),
         callback_data (NULL),
         servers (NULL),
@@ -1,11 +1,43 @@
 #ifndef STUB
 #include "fatal.h"
 
+/** \group STUB
+ *
+ *  A set of useful macros to create stub_* files.
+ *
+ * Intended for use building unit tests, if a stubbed function is called
+ * by any code it is linked to it will abort with a message indicating
+ * which API file is missing from the linked dependencies.
+ *
+ * Usage:
+ *    at the top of your intended stub file define STUB_API to be the
+ *    name of the .cc file or library you are providing a stub of
+ *    then include this STUB.h header.
+ *
+ *   #define STUB_API "foo/libexample.la"
+ *   #include "tests/STUB.h"
+ */
+
+/// macro to stub a void function.
 #define STUB { fatal(STUB_API " required"); }
+
+/** macro to stub a function with return value.
+ *  Aborts unit tests requiring its definition with a message about the missing linkage
+ */
 #define STUB_RETVAL(x) { fatal(STUB_API " required"); return x; }
-//#define STUB_RETREF(x) { fatal(STUB_API " required"); x* o = new (x); return *o; }
-// NP: no () around the x here
+
+/** macro to stub a function which returns a reference to dynamic
+ *  Aborts unit tests requiring its definition with a message about the missing linkage
+ *  This macro uses 'new x' to construct a stack vailable for the reference, may leak.
+ *  \param x may be the type to define or a constructor call with parameter values
+ */
 #define STUB_RETREF(x) { fatal(STUB_API " required"); return new x; }
+
+/** macro to stub a function which returns a reference to static
+ *  Aborts unit tests requiring its definition with a message about the missing linkage
+ *  This macro uses static variable definition to avoid leaks.
+ *  \param x  the type name to define
+ */
 #define STUB_RETSTATREF(x) { fatal(STUB_API " required"); static x v; return v; }
 
 #endif /* STUB */