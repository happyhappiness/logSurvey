@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.80 1997/07/06 05:14:07 wessels Exp $
+#  $Id: Makefile.in,v 1.81 1997/07/07 05:29:37 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -93,6 +93,7 @@ OBJS	 	= \
 		filemap.o \
 		fqdncache.o \
 		ftp.o \
+		globals.o \
 		gopher.o \
 		hash.o \
 		http.o \
@@ -138,9 +139,12 @@ $(OBJS): ../include/version.h
 squid:	$(OBJS)
 	$(CC) -o $@ $(LDFLAGS) $(OBJS) $(SQUID_LIBS)
 
-cache_cf.o: cache_cf.c Makefile
+globals.o: globals.c Makefile
 	$(CC) -c $< $(CFLAGS) $(DEFAULTS)
 
+globals.c: globals.h mk-globals-c.pl
+	perl mk-globals-c.pl < globals.h > $@
+
 client:	client.o
 	$(CC) -o $@ $(LDFLAGS) $@.o $(CLIENT_LIBS)
 
@@ -275,7 +279,7 @@ install-pinger:
 
 clean: 
 	-rm -rf *.o *pure_* core $(PROGS) $(UTILS) $(CGIPROGS) $(SUID_UTILS)
-	-rm -f cf_gen cf_parser.c cf.data
+	-rm -f cf_gen cf_parser.c cf.data globals.c
 
 distclean:	clean
 	-rm -f Makefile squid.conf squid.conf.pre
@@ -1,5 +1,5 @@
 /*
- * $Id: acl.cc,v 1.101 1997/07/06 05:14:08 wessels Exp $
+ * $Id: acl.cc,v 1.102 1997/07/07 05:29:38 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -41,8 +41,6 @@
 /* Global */
 const char *AclMatchedName = NULL;
 
-static struct _acl *AclList = NULL;
-static struct _acl **AclListTail = &AclList;
 static int aclFromFile = 0;
 static FILE *aclFile;
 
@@ -174,7 +172,7 @@ struct _acl *
 aclFindByName(const char *name)
 {
     struct _acl *a;
-    for (a = AclList; a; a = a->next)
+    for (a = Config.aclList; a; a = a->next)
 	if (!strcasecmp(a->name, name))
 	    return a;
     return NULL;
@@ -575,7 +573,7 @@ aclParseDomainList(void *curlist)
 #endif /* USE_SPLAY_TREE */
 
 void
-aclParseAclLine(void)
+aclParseAclLine(acl **head)
 {
     /* we're already using strtok() to grok the line */
     char *t = NULL;
@@ -634,7 +632,7 @@ aclParseAclLine(void)
 	break;
     case ACL_URL_REGEX:
     case ACL_URLPATH_REGEX:
-	aclParseRegexList(&A->data, 0);
+	aclParseRegexList(&A->data);
 	break;
     case ACL_URL_PORT:
 	aclParseIntlist(&A->data);
@@ -650,7 +648,7 @@ aclParseAclLine(void)
 	aclParseMethodList(&A->data);
 	break;
     case ACL_BROWSER:
-	aclParseRegexList(&A->data, 0);
+	aclParseRegexList(&A->data);
 	break;
     case ACL_NONE:
     default:
@@ -665,8 +663,10 @@ aclParseAclLine(void)
 	xfree(A);
 	return;
     }
-    *AclListTail = A;
-    AclListTail = &A->next;
+    /* append */
+    while (*head)
+	head = &(*head)->next;
+    *head = A;
 }
 
 /* maex@space.net (06.09.96)
@@ -1355,11 +1355,11 @@ aclDestroyRegexList(struct _relist *data)
 }
 
 void
-aclDestroyAcls(void)
+aclDestroyAcls(acl **head)
 {
     struct _acl *a = NULL;
     struct _acl *next = NULL;
-    for (a = AclList; a; a = next) {
+    for (a = *head; a; a = next) {
 	next = a->next;
 	debug(28, 3) ("aclDestroyAcls: '%s'\n", a->cfgline);
 	switch (a->type) {
@@ -1407,8 +1407,7 @@ aclDestroyAcls(void)
 	safe_free(a->cfgline);
 	safe_free(a);
     }
-    AclList = NULL;
-    AclListTail = &AclList;
+    *head = NULL;
 }
 
 static void
@@ -1,5 +1,5 @@
 /*
- * $Id: cache_cf.cc,v 1.199 1997/07/06 05:14:09 wessels Exp $
+ * $Id: cache_cf.cc,v 1.200 1997/07/07 05:29:39 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -28,85 +28,8 @@
  *  
  */
 
-/*
- * Copyright (c) 1994, 1995.  All rights reserved.
- *  
- *   The Harvest software was developed by the Internet Research Task
- *   Force Research Group on Resource Discovery (IRTF-RD):
- *  
- *         Mic Bowman of Transarc Corporation.
- *         Peter Danzig of the University of Southern California.
- *         Darren R. Hardy of the University of Colorado at Boulder.
- *         Udi Manber of the University of Arizona.
- *         Michael F. Schwartz of the University of Colorado at Boulder.
- *         Duane Wessels of the University of Colorado at Boulder.
- *  
- *   This copyright notice applies to software in the Harvest
- *   ``src/'' directory only.  Users should consult the individual
- *   copyright notices in the ``components/'' subdirectories for
- *   copyright information about other software bundled with the
- *   Harvest source code distribution.
- *  
- * TERMS OF USE
- *   
- *   The Harvest software may be used and re-distributed without
- *   charge, provided that the software origin and research team are
- *   cited in any use of the system.  Most commonly this is
- *   accomplished by including a link to the Harvest Home Page
- *   (http://harvest.cs.colorado.edu/) from the query page of any
- *   Broker you deploy, as well as in the query result pages.  These
- *   links are generated automatically by the standard Broker
- *   software distribution.
- *   
- *   The Harvest software is provided ``as is'', without express or
- *   implied warranty, and with no support nor obligation to assist
- *   in its use, correction, modification or enhancement.  We assume
- *   no liability with respect to the infringement of copyrights,
- *   trade secrets, or any patents, and are not responsible for
- *   consequential damages.  Proper use of the Harvest software is
- *   entirely the responsibility of the user.
- *  
- * DERIVATIVE WORKS
- *  
- *   Users may make derivative works from the Harvest software, subject 
- *   to the following constraints:
- *  
- *     - You must include the above copyright notice and these 
- *       accompanying paragraphs in all forms of derivative works, 
- *       and any documentation and other materials related to such 
- *       distribution and use acknowledge that the software was 
- *       developed at the above institutions.
- *  
- *     - You must notify IRTF-RD regarding your distribution of 
- *       the derivative work.
- *  
- *     - You must clearly notify users that your are distributing 
- *       a modified version and not the original Harvest software.
- *  
- *     - Any derivative product is also subject to these copyright 
- *       and use restrictions.
- *  
- *   Note that the Harvest software is NOT in the public domain.  We
- *   retain copyright, as specified above.
- *  
- * HISTORY OF FREE SOFTWARE STATUS
- *  
- *   Originally we required sites to license the software in cases
- *   where they were going to build commercial products/services
- *   around Harvest.  In June 1995 we changed this policy.  We now
- *   allow people to use the core Harvest software (the code found in
- *   the Harvest ``src/'' directory) for free.  We made this change
- *   in the interest of encouraging the widest possible deployment of
- *   the technology.  The Harvest software is really a reference
- *   implementation of a set of protocols and formats, some of which
- *   we intend to standardize.  We encourage commercial
- *   re-implementations of code complying to this set of standards.  
- */
-
 #include "squid.h"
 
-struct SquidConfig Config;
-
 static const char *const T_SECOND_STR = "second";
 static const char *const T_MINUTE_STR = "minute";
 static const char *const T_HOUR_STR = "hour";
@@ -117,30 +40,23 @@ static const char *const T_MONTH_STR = "month";
 static const char *const T_YEAR_STR = "year";
 static const char *const T_DECADE_STR = "decade";
 
-int httpd_accel_mode = 0;	/* for fast access */
-const char *DefaultSwapDir = DEFAULT_SWAP_DIR;
-const char *DefaultConfigFile = DEFAULT_CONFIG_FILE;
-char *ConfigFile = NULL;	/* the whole thing */
-const char *cfg_filename = NULL;	/* just the last part */
-
 static const char *const list_sep = ", \t\n\r";
-char config_input_line[BUFSIZ];
-int config_lineno = 0;
 
 static char fatal_str[BUFSIZ];
 static void self_destruct _PARAMS((void));
 static void wordlistAdd _PARAMS((wordlist **, const char *));
 
 static void configDoConfigure _PARAMS((void));
-static void parseRefreshPattern _PARAMS((int icase));
+static void parse_refreshpattern _PARAMS((refresh_t **));
 static int parseTimeUnits _PARAMS((const char *unit));
-static void parseTimeLine _PARAMS((int *iptr, const char *units));
+static void parseTimeLine _PARAMS((time_t *tptr, const char *units));
 
 static void parse_string _PARAMS((char **));
 static void parse_wordlist _PARAMS((wordlist **));
 static void dump_all _PARAMS((void));
 static void default_all _PARAMS((void));
 static int parse_line _PARAMS((char *));
+static cache_peer *configFindPeer _PARAMS((const char *name));
 
 /* These come from cf_gen.c */
 static void default_all _PARAMS((void));
@@ -215,48 +131,14 @@ intlistDestroy(intlist ** list)
 	if (sscanf(token, "%d", &var) != 1) \
 		self_destruct();
 
-static void
-parseRefreshPattern(int icase)
-{
-    char *token;
-    char *pattern;
-    time_t min = 0;
-    int pct = 0;
-    time_t max = 0;
-    int i;
-    token = strtok(NULL, w_space);	/* token: regex pattern */
-    if (token == NULL)
-	self_destruct();
-    pattern = xstrdup(token);
-    GetInteger(i);		/* token: min */
-    min = (time_t) (i * 60);	/* convert minutes to seconds */
-    GetInteger(i);		/* token: pct */
-    pct = i;
-    GetInteger(i);		/* token: max */
-    max = (time_t) (i * 60);	/* convert minutes to seconds */
-    refreshAddToList(pattern, icase, min, pct, max);
-    safe_free(pattern);
-}
-
 int
 parseConfigFile(const char *file_name)
 {
     FILE *fp = NULL;
     char *token = NULL;
     LOCAL_ARRAY(char, tmp_line, BUFSIZ);
-
     free_all();
     default_all();
-    aclDestroyAcls();
-    aclDestroyDenyInfoList(&Config.denyInfoList);
-    aclDestroyAccessList(&Config.accessList.HTTP);
-    aclDestroyAccessList(&Config.accessList.ICP);
-    aclDestroyAccessList(&Config.accessList.MISS);
-    aclDestroyAccessList(&Config.accessList.NeverDirect);
-    aclDestroyAccessList(&Config.accessList.AlwaysDirect);
-    aclDestroyRegexList(Config.cache_stop_relist);
-    Config.cache_stop_relist = NULL;
-
     if ((fp = fopen(file_name, "r")) == NULL) {
 	sprintf(fatal_str, "Unable to open configuration file: %s: %s",
 	    file_name, xstrerror());
@@ -296,10 +178,8 @@ parseConfigFile(const char *file_name)
 	printf("         Change your configuration file.\n");
 	fflush(stdout);		/* print message */
     }
-    if (Config.cleanRate < 1)
-	Config.cleanRate = 86400 * 365;		/* one year */
-    if (Config.Announce.rate < 1) {
-	Config.Announce.rate = 86400 * 365;	/* one year */
+    if (Config.Announce.period < 1) {
+	Config.Announce.period = 86400 * 365;	/* one year */
 	Config.Announce.on = 0;
     }
     if (Config.dnsChildren < 0)
@@ -333,11 +213,20 @@ parseConfigFile(const char *file_name)
 static void
 configDoConfigure(void)
 {
-    httpd_accel_mode = Config.Accel.prefix ? 1 : 0;
+    LOCAL_ARRAY(char, buf, BUFSIZ);
+    memset(&Config2, '\0', sizeof(SquidConfig2));
+    if (Config.Accel.host) {
+        snprintf(buf, BUFSIZ, "http://%s:%d", Config.Accel.host, Config.Accel.port);
+        Config2.Accel.prefix = xstrdup(buf);
+        Config2.Accel.on = 1;
+    }
+    if (Config.appendDomain)
+	if (*Config.appendDomain != '.')
+	    fatal("append_domain must begin with a '.'");
     if (Config.errHtmlText == NULL)
 	Config.errHtmlText = xstrdup(null_string);
     storeConfigure();
-    if (httpd_accel_mode && !strcmp(Config.Accel.host, "virtual"))
+    if (Config2.Accel.on && !strcmp(Config.Accel.host, "virtual"))
 	vhost_mode = 1;
     if (Config.Port.http == NULL)
 	fatal("No http_port specified!");
@@ -351,17 +240,19 @@ configDoConfigure(void)
 	Config.appendDomainLen = strlen(Config.appendDomain);
     else
 	Config.appendDomainLen = 0;
+    safe_free(debug_options)
+	debug_options = xstrdup(Config.debugOptions);
 }
 
 /* Parse a time specification from the config file.  Store the
- * result in 'iptr', after converting it to 'units' */
+ * result in 'tptr', after converting it to 'units' */
 static void
-parseTimeLine(int *iptr, const char *units)
+parseTimeLine(time_t *tptr, const char *units)
 {
     char *token;
     double d;
-    int m;
-    int u;
+    time_t m;
+    time_t u;
     if ((u = parseTimeUnits(units)) == 0)
 	self_destruct();
     if ((token = strtok(NULL, w_space)) == NULL)
@@ -372,7 +263,7 @@ parseTimeLine(int *iptr, const char *units)
 	if ((m = parseTimeUnits(token)) == 0)
 	    self_destruct();
     }
-    *iptr = m * d / u;
+    *tptr = m * d / u;
 }
 
 static int
@@ -405,15 +296,21 @@ parseTimeUnits(const char *unit)
  *****************************************************************************/
 
 static void
-dump_acl(void)
+dump_acl(acl *acl)
 {
     debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parse_acl(void)
+parse_acl(acl **acl)
 {
-    aclParseAclLine();
+    aclParseAclLine(acl);
+}
+
+static void
+free_acl(acl **acl)
+{
+    aclDestroyAcls(acl);
 }
 
 static void
@@ -463,120 +360,86 @@ free_address(struct in_addr *addr)
 }
 
 static void
-dump_announceto(void)
+dump_cachedir(struct _cacheSwap swap)
 {
     debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parse_announceto(void)
+parse_cachedir(struct _cacheSwap *swap)
 {
     char *token;
-    int i;
-
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    safe_free(Config.Announce.host);
-    Config.Announce.host = xstrdup(token);
-    if ((token = strchr(Config.Announce.host, ':'))) {
-	*token++ = '\0';
-	if (sscanf(token, "%d", &i) != 1)
-	    Config.Announce.port = i;
-    }
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	return;
-    safe_free(Config.Announce.file);
-    Config.Announce.file = xstrdup(token);
-}
-
-static void
-dump_appenddomain(void)
-{
-    debug(0,0)("XXX need to fix\n");
-}
-
-static void
-parse_appenddomain(void)
-{
-    char *token = strtok(NULL, w_space);
-
-    if (token == NULL)
-	self_destruct();
-    if (*token != '.')
-	self_destruct();
-    safe_free(Config.appendDomain);
-    Config.appendDomain = xstrdup(token);
-}
-
-static void
-dump_cacheannounce(void)
-{
-    debug(0,0)("XXX need to fix\n");
-}
-
-static void
-parse_cacheannounce(void)
-{
-    char *token;
-    int i;
-    GetInteger(i);
-    Config.Announce.rate = i * 3600;	/* hours to seconds */
-    if (Config.Announce.rate > 0)
-	Config.Announce.on = 1;
-}
-
-static void
-dump_cachedir(void)
-{
-    debug(0,0)("XXX need to fix\n");
-}
-
-static void
-parse_cachedir(void)
-{
-    char *token;
-    char *dir;
+    char *path;
     int i;
     int size;
     int l1;
     int l2;
     int readonly = 0;
-
-    if ((token = strtok(NULL, w_space)) == NULL)
+    SwapDir *tmp = NULL;
+    if ((path = strtok(NULL, w_space)) == NULL)
 	self_destruct();
-    dir = token;
+    if (strlen(path) > (SQUID_MAXPATHLEN - 32))
+	fatal_dump("cache_dir pathname is too long");
     GetInteger(i);
     size = i << 10;		/* Mbytes to kbytes */
-    Config.Swap.maxSize += size;
     GetInteger(i);
     l1 = i;
     GetInteger(i);
     l2 = i;
     if ((token = strtok(NULL, w_space)))
 	if (!strcasecmp(token, "read-only"))
 	    readonly = 1;
-    if (configured_once)
-	storeReconfigureSwapDisk(dir, size, l1, l2, readonly);
-    else
-	storeAddSwapDisk(dir, size, l1, l2, readonly);
+    for (i = 0; i < swap->n_configured; i++) {
+	tmp = swap->swapDirs+i;
+	if (!strcmp(path, tmp->path)) {
+	    /* just reconfigure it */
+            tmp->max_size = size;
+            tmp->read_only = readonly;
+	    return;
+	}
+    }
+    if (swap->swapDirs == NULL) {
+	swap->n_allocated = 4;
+	swap->swapDirs = xcalloc(swap->n_allocated, sizeof(SwapDir));
+    }
+    if (swap->n_allocated == swap->n_configured) {
+	swap->n_allocated <<= 1;
+	tmp = xcalloc(swap->n_allocated, sizeof(SwapDir));
+	xmemcpy(tmp, swap->swapDirs, swap->n_configured * sizeof(SwapDir));
+	xfree(swap->swapDirs);
+	swap->swapDirs = tmp;
+    }
+    debug(20, 1) ("Creating Swap Dir #%d in %s\n", swap->n_configured + 1, path);
+    tmp = swap->swapDirs + swap->n_configured;
+    tmp->path = xstrdup(path);
+    tmp->max_size = size;
+    tmp->l1 = l1;
+    tmp->l2 = l2;
+    tmp->read_only = readonly;
+    tmp->map = file_map_create(MAX_FILES_PER_DIR);
+    tmp->swaplog_fd = -1;
 }
 
 static void
-dump_cache_peer(struct cache_peer *p)
+free_cachedir(struct _cacheSwap *swap)
+{
+	assert(0);
+}
+
+static void
+dump_cache_peer(cache_peer *p)
 {
     debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parse_cache_peer(struct cache_peer **head)
+parse_cache_peer(cache_peer **head)
 {
     char *token = NULL;
-    struct cache_peer peer;
-    struct cache_peer *p;
+    cache_peer peer;
+    cache_peer *p;
     int i;
-    memset(&peer, '\0', sizeof(struct cache_peer));
+    memset(&peer, '\0', sizeof(cache_peer));
     peer.http = CACHE_HTTP_PORT;
     peer.icp = CACHE_ICP_PORT;
     peer.weight = 1;
@@ -614,7 +477,7 @@ parse_cache_peer(struct cache_peer **head)
     }
     if (peer.weight < 1)
 	peer.weight = 1;
-    p = xcalloc(1, sizeof(struct cache_peer));
+    p = xcalloc(1, sizeof(cache_peer));
     *p = peer;
     p->host = xstrdup(peer.host);
     p->type = xstrdup(peer.type);
@@ -624,9 +487,9 @@ parse_cache_peer(struct cache_peer **head)
 }
 
 static void
-free_cache_peer(struct cache_peer **P)
+free_cache_peer(cache_peer **P)
 {
-	struct cache_peer *p;
+	cache_peer *p;
 	while ((p = *P)) {
 		*P = p->next;
 		xfree(p->host);
@@ -636,69 +499,95 @@ free_cache_peer(struct cache_peer **P)
 }
 
 static void
-dump_cachemgrpasswd(void)
+dump_cachemgrpasswd(cachemgr_passwd *list)
 {
     debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parse_cachemgrpasswd(void)
+parse_cachemgrpasswd(cachemgr_passwd **head)
 {
     char *passwd = NULL;
     wordlist *actions = NULL;
     parse_string(&passwd);
     parse_wordlist(&actions);
-    objcachePasswdAdd(&Config.passwd_list, passwd, actions);
+    objcachePasswdAdd(head, passwd, actions);
     wordlistDestroy(&actions);
 }
 
 static void
-dump_denyinfo(struct _acl_deny_info_list *var)
+free_cachemgrpasswd(cachemgr_passwd **head)
 {
-    debug(0,0)("XXX need to fix\n");
+	assert(0);
 }
 
-static void
-parse_denyinfo(struct _acl_deny_info_list **var)
-{
-    aclParseDenyInfoLine(var);
-}
 
 static void
-dump_errhtml(void)
+dump_denyinfo(struct _acl_deny_info_list *var)
 {
     debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parse_errhtml(void)
+parse_denyinfo(struct _acl_deny_info_list **var)
 {
-    char *token;
-    if ((token = strtok(NULL, null_string)))
-	Config.errHtmlText = xstrdup(token);
+    aclParseDenyInfoLine(var);
 }
 
 static void
-dump_hostacl(void)
+free_denyinfo(acl_deny_info_list **head)
 {
-    debug(0,0)("XXX need to fix\n");
+	assert(0);
 }
 
+
 static void
-parse_hostacl(void)
+parse_peeracl(void)
 {
     char *host = NULL;
     char *aclname = NULL;
     if (!(host = strtok(NULL, w_space)))
 	self_destruct();
-    while ((aclname = strtok(NULL, list_sep)))
-	neighborAddAcl(host, aclname);
+    while ((aclname = strtok(NULL, list_sep))) {
+	cache_peer *p;
+	acl_list *L = NULL;
+	acl_list **Tail = NULL;
+	acl *a = NULL;
+	if ((p = configFindPeer(host)) == NULL) {
+	    debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
+		cfg_filename, config_lineno, host);
+	    return;
+	}
+	L = xcalloc(1, sizeof(struct _acl_list));
+	L->op = 1;
+	if (*aclname == '!') {
+	    L->op = 0;
+	    aclname++;
+	}
+	debug(15, 3) ("neighborAddAcl: looking for ACL name '%s'\n", aclname);
+	a = aclFindByName(aclname);
+	if (a == NULL) {
+	    debug(15, 0) ("%s line %d: %s\n",
+		cfg_filename, config_lineno, config_input_line);
+	    debug(15, 0) ("neighborAddAcl: ACL name '%s' not found.\n", aclname);
+	    xfree(L);
+	    return;
+	}
+	L->acl = a;
+	for (Tail = &p->acls; *Tail; Tail = &(*Tail)->next);
+	*Tail = L;
+    }
 }
 
-static void
-dump_hostdomain(void)
+static cache_peer *
+configFindPeer (const char *name)
 {
-    debug(0,0)("XXX need to fix\n");
+    cache_peer *p = NULL;
+    for (p = Config.peers; p; p = p->next) {
+        if (!strcasecmp(name, p->host))
+            break;
+    }
+    return p;
 }
 
 static void
@@ -708,14 +597,25 @@ parse_hostdomain(void)
     char *domain = NULL;
     if (!(host = strtok(NULL, w_space)))
 	self_destruct();
-    while ((domain = strtok(NULL, list_sep)))
-	neighborAddDomainPing(host, domain);
-}
-
-static void
-dump_hostdomaintype(void)
-{
-    debug(0,0)("XXX need to fix\n");
+    while ((domain = strtok(NULL, list_sep))) {
+	domain_ping *l = NULL;
+	domain_ping **L = NULL;
+	cache_peer *p;
+	if ((p = configFindPeer(host)) == NULL) {
+	    debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
+		cfg_filename, config_lineno, host);
+	    continue;
+	}
+	l = xcalloc(1, sizeof(struct _domain_ping));
+	l->do_ping = 1;
+	if (*domain == '!') {	/* check for !.edu */
+	    l->do_ping = 0;
+	    domain++;
+	}
+	l->domain = xstrdup(domain);
+	for (L = &(p->pinglist); *L; L = &((*L)->next));
+	*L = l;
+    }
 }
 
 static void
@@ -728,8 +628,21 @@ parse_hostdomaintype(void)
 	self_destruct();
     if (!(type = strtok(NULL, w_space)))
 	self_destruct();
-    while ((domain = strtok(NULL, list_sep)))
-	neighborAddDomainType(host, domain, type);
+    while ((domain = strtok(NULL, list_sep))) {
+	domain_type *l = NULL;
+	domain_type **L = NULL;
+	cache_peer *p;
+	if ((p = configFindPeer(host)) == NULL) {
+	    debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
+		cfg_filename, config_lineno, host);
+	    return;
+	}
+	l = xcalloc(1, sizeof(struct _domain_type));
+	l->type = parseNeighborType(type);
+	l->domain = xstrdup(domain);
+	for (L = &(p->typelist); *L; L = &((*L)->next));
+	*L = l;
+    }
 }
 
 static void
@@ -763,30 +676,6 @@ parse_httpanonymizer(int *var)
 	*var = ANONYMIZER_STANDARD;
 }
 
-static void
-dump_httpdaccel(void)
-{
-    debug(0,0)("XXX need to fix\n");
-}
-
-static void
-parse_httpdaccel(void)
-{
-    char *token;
-    LOCAL_ARRAY(char, buf, BUFSIZ);
-    int i;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    safe_free(Config.Accel.host);
-    Config.Accel.host = xstrdup(token);
-    GetInteger(i);
-    Config.Accel.port = i;
-    safe_free(Config.Accel.prefix);
-    sprintf(buf, "http://%s:%d", Config.Accel.host, Config.Accel.port);
-    Config.Accel.prefix = xstrdup(buf);
-    httpd_accel_mode = 1;
-}
 
 static void
 dump_ushortlist(ushortlist *u)
@@ -868,8 +757,11 @@ parse_onoff(int *var)
 }
 
 #define free_onoff free_int
+#define free_httpanonymizer free_int
 #define dump_pathname_stat dump_string
 #define free_pathname_stat free_string
+#define dump_eol dump_string
+#define free_eol free_string
 
 static void
 parse_pathname_stat(char **path)
@@ -883,27 +775,76 @@ parse_pathname_stat(char **path)
 }
 
 static void
-dump_refreshpattern(void)
+dump_refreshpattern(refresh_t *head)
 {
     debug(0,0)("XXX need to fix\n");
 }
 
 static void
-parse_refreshpattern(void)
-{
-    parseRefreshPattern(0);
-}
-
-static void
-dump_refreshpattern_icase(void)
+parse_refreshpattern(refresh_t ** head)
 {
-    debug(0,0)("XXX need to fix\n");
+    char *token;
+    char *pattern;
+    time_t min = 0;
+    int pct = 0;
+    time_t max = 0;
+    int i;
+    refresh_t *t;
+    regex_t comp;
+    int errcode;
+    int flags = REG_EXTENDED | REG_NOSUB;
+    if ((token = strtok(NULL, w_space)) == NULL)
+	self_destruct();
+    if (strcmp(token, "-i") == 0) {
+	flags |= REG_ICASE;
+	token = strtok(NULL, w_space);
+    } else if (strcmp(token, "+i") == 0) {
+	flags &= ~REG_ICASE;
+	token = strtok(NULL, w_space);
+    }
+    if (token == NULL)
+	self_destruct();
+    pattern = xstrdup(token);
+    GetInteger(i);		/* token: min */
+    min = (time_t) (i * 60);	/* convert minutes to seconds */
+    GetInteger(i);		/* token: pct */
+    pct = i;
+    GetInteger(i);		/* token: max */
+    max = (time_t) (i * 60);	/* convert minutes to seconds */
+    if ((errcode = regcomp(&comp, pattern, flags)) != 0) {
+	char errbuf[256];
+	regerror(errcode, &comp, errbuf, sizeof errbuf);
+	debug(22, 0) ("%s line %d: %s\n",
+	    cfg_filename, config_lineno, config_input_line);
+	debug(22, 0) ("refreshAddToList: Invalid regular expression '%s': %s\n",
+	    pattern, errbuf);
+	return;
+    }
+    pct = pct < 0 ? 0 : pct;
+    max = max < 0 ? 0 : max;
+    t = xcalloc(1, sizeof(refresh_t));
+    t->pattern = (char *) xstrdup(pattern);
+    t->compiled_pattern = comp;
+    t->min = min;
+    t->pct = pct;
+    t->max = max;
+    t->next = NULL;
+    while (*head)
+	head = &(*head)->next;
+    *head = t;
+    safe_free(pattern);
 }
 
 static void
-parse_refreshpattern_icase(void)
+free_refreshpattern(refresh_t **head)
 {
-    parseRefreshPattern(1);
+    refresh_t *t;
+    while ((t = *head)) {
+	*head = t->next;
+	safe_free(t->pattern);
+	regfree(&t->compiled_pattern);
+	safe_free(t);
+    }
 }
 
 static void
@@ -947,47 +888,35 @@ free_string(char **var)
 	xfree(*var);
 	*var = NULL;
 }
-static void
-dump_string_optional(const char *var)
-{
-    printf("%s", var);
-}
 
 static void
-parse_volatile_string(char *volatile *var)
+parse_eol(char *volatile *var)
 {
     char *token = strtok(NULL, null_string);
     safe_free(*var);
-    if (token == NULL) {
-	*var = NULL;
-	return;
-    }
+    if (token == NULL)
+	self_destruct();
     *var = xstrdup(token);
 }
 
 static void
-dump_time_min(int var)
-{
-    printf("%d", var / 60);
-}
-
-static void
-parse_time_min(int *var)
+dump_time_t(time_t var)
 {
-    parseTimeLine(var, T_MINUTE_STR);
+    printf("%d", (int) var);
 }
 
 static void
-dump_time_sec(int var)
+parse_time_t(time_t *var)
 {
-    printf("%d", var);
+    parseTimeLine(var, T_SECOND_STR);
 }
 
 static void
-parse_time_sec(int *var)
+free_time_t(time_t *var)
 {
-    parseTimeLine(var, T_SECOND_STR);
+	*var = 0;
 }
+	
 
 static void
 dump_ushort(u_short var)
@@ -1013,38 +942,6 @@ parse_ushort(u_short * var)
     *var = (u_short) i;
 }
 
-static void
-dump_vizhack(void)
-{
-    debug(0,0)("XXX need to fix\n");
-}
-
-static void
-parse_vizhack(void)
-{
-    char *token;
-    int i;
-    const struct hostent *hp;
-    token = strtok(NULL, w_space);
-    if (token == NULL)
-	self_destruct();
-    if (safe_inet_addr(token, &Config.vizHack.addr) == 1)
-	(void) 0;
-    else if ((hp = gethostbyname(token)))	/* dont use ipcache */
-	Config.vizHack.addr = inaddrFromHostent(hp);
-    else
-	self_destruct();
-    if ((token = strtok(NULL, w_space)) == NULL)
-	self_destruct();
-    if (sscanf(token, "%d", &i) == 1)
-	Config.vizHack.port = i;
-    Config.vizHack.mcast_ttl = 64;
-    if ((token = strtok(NULL, w_space)) == NULL)
-	return;
-    if (sscanf(token, "%d", &i) == 1)
-	Config.vizHack.mcast_ttl = i;
-}
-
 static void
 dump_wordlist(wordlist * list)
 {
@@ -1068,3 +965,21 @@ parse_wordlist(wordlist ** list)
 #define free_wordlist wordlistDestroy
 
 #include "cf_parser.c"
+
+peer_t
+parseNeighborType(const char *s)
+{
+    if (!strcasecmp(s, "parent"))
+	return PEER_PARENT;
+    if (!strcasecmp(s, "neighbor"))
+	return PEER_SIBLING;
+    if (!strcasecmp(s, "neighbour"))
+	return PEER_SIBLING;
+    if (!strcasecmp(s, "sibling"))
+	return PEER_SIBLING;
+    if (!strcasecmp(s, "multicast"))
+	return PEER_MULTICAST;
+    debug(15, 0) ("WARNING: Unknown neighbor type: %s\n", s);
+    return PEER_SIBLING;
+}
+
@@ -183,6 +183,8 @@ DOC_END
 
 NAME: cache_host_domain
 TYPE: hostdomain
+DEFAULT: none
+LOC: none
 DOC_START
 	Use to limit the domains for which a neighbor cache will be queried.
 	Usage:
@@ -214,6 +216,8 @@ DOC_END
 
 NAME: neighbor_type_domain
 TYPE: hostdomaintype
+DEFAULT: none
+LOC: none
 DOC_START
 	usage: neighbor_type_domain parent|sibling domain domain ...
 
@@ -233,7 +237,7 @@ DOC_END
 NAME: single_parent_bypass
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.singleParentBypass
 DOC_START
 	This tag specifies that it is okay to bypass the hierarchy
@@ -267,7 +271,7 @@ DOC_END
 NAME: source_ping
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.sourcePing
 DOC_START
 	If source_ping is enabled, then squid will include the source
@@ -290,7 +294,7 @@ DOC_END
 NAME: neighbor_timeout neighbour_timeout
 COMMENT: (seconds)
 DEFAULT: 2
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.neighborTimeout
 DOC_START
 	This controls how long to wait for replies from neighbor caches.
@@ -477,7 +481,8 @@ DOC_END
 
 NAME: cache_dir
 TYPE: cachedir
-DEFAULT: NULL
+DEFAULT: none
+LOC: Config.cacheSwap
 DOC_START
 	Directory for on-disk cache storage.  The cache will change into
 	this directory when running.  The default is
@@ -545,7 +550,7 @@ DOC_END
 NAME: emulate_httpd_log
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.commonLogFormat
 DOC_START
 	The Cache can emulate the log file format which many 'httpd'
@@ -574,6 +579,7 @@ NAME: log_mime_hdrs
 COMMENT: on|off
 TYPE: onoff
 LOC: Config.logMimeHdrs
+DEFAULT: off
 DOC_START
 	The Cache can record both the request and the response
 	MIME headers for each HTTP transaction.  The headers are
@@ -592,6 +598,7 @@ DOC_END
 NAME: useragent_log
 TYPE: string
 LOC: Config.Log.useragent
+DEFAULT: none
 DOC_START
 	If compiled with "-DUSE_USERAGENT_LOG=1" Squid will write
 	the User-Agent field from HTTP requests to the filename
@@ -613,7 +620,7 @@ DOC_END
 
 
 NAME: debug_options
-TYPE: string_optional
+TYPE: eol
 DEFAULT: ALL,1
 LOC: Config.debugOptions
 DOC_START
@@ -631,7 +638,7 @@ DOC_END
 NAME: ident_lookup
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.identLookup
 DOC_START
 	If you wish to make an RFC931/ident lookup of the client username
@@ -644,7 +651,7 @@ DOC_END
 NAME: log_fqdn
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.Log.log_fqdn
 DOC_START
 	Turn this on if you wish to log fully qualified domain names
@@ -657,6 +664,7 @@ DOC_END
 NAME: client_netmask
 TYPE: address
 LOC: Config.Addrs.client_netmask
+DEFAULT: 255.255.255.255
 DOC_START
 	A netmask for client addresses in logfiles and cachemgr output.
 	Change this to protect the privacy of your cache clients.
@@ -738,7 +746,7 @@ DOC_END
 NAME: dns_defnames
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.Options.res_defnames
 DOC_START
 	Normally the 'dnsserver' disables the RES_DEFNAMES resolver
@@ -832,13 +840,9 @@ DOC_END
 
 
 NAME: refresh_pattern
-COMMENT: # case sensitive
 TYPE: refreshpattern
-DOC_NONE
-
-NAME: refresh_pattern/i
-COMMENT: # case insensitive
-TYPE: refreshpattern_icase
+LOC: Config.Refresh
+DEFAULT: NONE
 DOC_START
 	usage: refresh_pattern regex min percent max
 
@@ -864,8 +868,9 @@ DOC_END
 
 
 NAME: reference_age
-TYPE: time_min
+TYPE: time_t
 LOC: Config.referenceAge
+DEFAULT: 1 year
 DOC_START
 	As a part of normal operation, Squid performs Least Recently
 	Used removal of cached objects.  The LRU age for removal is
@@ -883,7 +888,7 @@ DOC_START
 		4 months
 		2.2 hours
 
-reference_age 1 year
+reference_age 1 month
 DOC_END
 
 
@@ -937,8 +942,9 @@ DOC_END
 
 NAME: negative_ttl
 COMMENT: (in minutes)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.negativeTtl
+DEFAULT: 300
 DOC_START
 	Time-to-Live (TTL) for failed requests.  Certain types of
 	failures (such as "connection refused" and "404 Not Found") are
@@ -952,8 +958,9 @@ DOC_END
 
 NAME: positive_dns_ttl
 COMMENT: (in minutes)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.positiveDnsTtl
+DEFAULT: 21600
 DOC_START
 	Time-to-Live (TTL) for positive caching of successful DNS lookups.
 	Default is 6 hours (360 minutes).  If you want to minimize the
@@ -965,8 +972,9 @@ DOC_END
 
 NAME: negative_dns_ttl
 COMMENT: (in minutes)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.negativeDnsTtl
+DEFAULT: 300
 DOC_START
 	Time-to-Live (TTL) for negative caching of failed DNS lookups.
 
@@ -979,8 +987,9 @@ DOC_END
 
 NAME: connect_timeout
 COMMENT: (in seconds)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.Timeout.connect
+DEFAULT: 120
 DOC_START
 	Some systems (notably Linux) can not be relied upon to properly
 	time out connect(2) requests.  Therefore the squid process
@@ -994,8 +1003,9 @@ DOC_END
 
 NAME: read_timeout
 COMMENT: (in minutes)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.Timeout.read
+DEFAULT: 900
 DOC_START
 	The read_timeout is applied on server-side connections.  After
 	each successful read(), the timeout will be extended by this
@@ -1009,8 +1019,9 @@ DOC_END
 
 NAME: defer_timeout
 COMMENT: (in minutes)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.Timeout.defer
+DEFAULT: 3600
 DOC_START
 	If your clients are behind slow (e.g. PPP/SLIP) connections,
 	then data may come in from the server-side faster than it can
@@ -1025,8 +1036,9 @@ DOC_END
 
 
 NAME: request_timeout
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.Timeout.request
+DEFAULT: 30
 DOC_START
 	How long to wait for an HTTP request after connection
 	establishment.  For persistent connections, wait this long
@@ -1038,8 +1050,9 @@ DOC_END
 
 NAME: client_lifetime
 COMMENT: (in minutes)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.Timeout.lifetime
+DEFAULT: 86400
 DOC_START
 	The maximum amount of time that a client (browser) is allowed to
 	remain connected to the cache process.  This protects the Cache
@@ -1062,8 +1075,9 @@ DOC_END
 
 NAME: shutdown_lifetime
 COMMENT: (in seconds)
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.shutdownLifetime
+DEFAULT: 30
 DOC_START
 	When SIGTERM or SIGHUP is received, the cache is put into
 	"shutdown pending" mode until all active sockets are closed.
@@ -1080,6 +1094,8 @@ DOC_END
 
 NAME: acl
 TYPE: acl
+LOC: Config.aclList
+DEFAULT: none
 DOC_START
 	Defining an Access List
 
@@ -1127,7 +1143,8 @@ DOC_END
 
 NAME: http_access
 TYPE: acl_access
-LOC: Config.accessList.HTTP
+LOC: Config.accessList.http
+DEFAULT: none
 DOC_START
 	Allowing or Denying access based on defined access lists
 
@@ -1162,7 +1179,8 @@ DOC_END
 
 NAME: icp_access
 TYPE: acl_access
-LOC: Config.accessList.ICP
+LOC: Config.accessList.icp
+DEFAULT: none
 DOC_START
 	Reply to all ICP queries we receive
 
@@ -1172,7 +1190,8 @@ DOC_END
 
 NAME: miss_access
 TYPE: acl_access
-LOC: Config.accessList.MISS
+LOC: Config.accessList.miss
+DEFAULT: none
 DOC_START
 	Use to force your neighbors to use you as a sibling instead of
 	a parent.  For example:
@@ -1192,7 +1211,9 @@ DOC_END
 
 
 NAME: cache_host_acl
-TYPE: hostacl
+TYPE: peeracl
+DEFAULT: none
+LOC: none
 DOC_START
 	Just like 'cache_host_domain' but provides more flexibility by
 	using ACL's.
@@ -1247,6 +1268,7 @@ DOC_END
 NAME: visible_hostname
 TYPE: string
 LOC: Config.visibleHostname
+DEFAULT: none
 DOC_START
 	If you want to present a special hostname in error messages, etc,
 	then define this.  Otherwise, the return value of gethostname()
@@ -1279,20 +1301,30 @@ DOC_END
 #	available on the Web at http://www.nlanr.net/Cache/Tracker/.
 
 
-NAME: cache_announce
-TYPE: cacheannounce
+NAME: announce_period
+TYPE: time_t
+LOC: Config.Announce.period
+DEFAULT: 86400
 DOC_START
 	This is how frequently to send cache announcements.  The default
 	is `0' which disables sending the announcement messages.
 
 	To enable announcing your cache, just uncomment the line below.
 
-cache_announce 24
+announce_period 24 hours
 DOC_END
 
 
-NAME: announce_to
-TYPE: announceto
+NAME: announce_host
+TYPE: string
+DEFAULT: sd.cache.nlanr.net
+LOC: Config.Announce.host
+DOC_NONE
+
+NAME: announce_port
+TYPE: ushort
+DEFAULT: 3131
+LOC: Config.Announce.port
 DOC_START
 	This is the hostname and portnumber where the registration message
 	will be sent.
@@ -1303,30 +1335,46 @@ DOC_START
 	to 3131.  If the 'filename' argument is given, the contents of that
 	file will be included in the announce message.
 
-announce_to sd.cache.nlanr.net:3131
+announce_host sd.cache.nlanr.net
+announce_port 3131
 DOC_END
 
+NAME: announce_file
+TYPE: pathname_stat
+DEFAULT: /dev/null
+LOC: Config.Announce.file
+DOC_NONE
+
 
 # HTTPD-ACCELERATOR OPTIONS
 #-----------------------------------------------------------------------------
 
-NAME: httpd_accel
-TYPE: httpdaccel
+NAME: httpd_accel_host
+TYPE: string
+LOC: Config.Accel.host
+DEFAULT: none
+DOC_NONE
+
+NAME: httpd_accel_port
+TYPE: ushort
+LOC: Config.Accel.port
+DEFAULT: 0
 DOC_START
 	If you want to run squid as an httpd accelerator, define the
 	host name and port number where the real HTTP server is.
 
 	If you want virtual host support then specify the hostname
 	as "virtual".
 
-httpd_accel real_httpd_host real_httpd_port
+httpd_accel_host hostname
+httpd_accel_port port
 DOC_END
 
 
 NAME: httpd_accel_with_proxy
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.Accel.withProxy
 DOC_START
 	If you want to use squid as both a local httpd accelerator
@@ -1339,6 +1387,7 @@ DOC_END
 NAME: httpd_accel_uses_host_header
 COMMENT: on|off
 TYPE: onoff
+DEFAULT: off
 LOC: opt_accel_uses_host
 DOC_START
 	HTTP/1.1 requests include a Host: header which is basically the
@@ -1358,6 +1407,7 @@ DOC_END
 NAME: dns_testnames
 TYPE: wordlist
 LOC: Config.dns_testname_list
+DEFAULT: none
 DOC_START
 	The DNS tests exit as soon as the first site is successfully looked up
 
@@ -1385,7 +1435,9 @@ DOC_END
 
 
 NAME: append_domain
-TYPE: appenddomain
+TYPE: string
+LOC:  Config.appendDomain
+DEFAULT: none
 DOC_START
 	Appends local domain name to hostnames without any dots in them.
 	append_domain must begin with a period.
@@ -1475,7 +1527,9 @@ DOC_END
 
 
 NAME: err_html_text
-TYPE: errhtml
+TYPE: eol
+LOC: Config.errHtmlText
+DEFAULT: none
 DOC_START
 	HTML text to include in error messages.  Make this a "mailto"
 	URL to your admin address, or maybe just a link to your
@@ -1488,6 +1542,7 @@ DOC_END
 NAME: deny_info
 TYPE: denyinfo
 LOC: Config.denyInfoList
+DEFAULT: none
 DOC_START
 	Usage: deny_info URL acl
 
@@ -1501,6 +1556,7 @@ DOC_END
 NAME: udp_hit_obj
 COMMENT: on|off
 TYPE: onoff
+DEFAULT: off
 LOC: opt_udp_hit_obj
 DOC_START
 	If set, Squid will request UDP_HIT_OBJ replies from its
@@ -1517,6 +1573,7 @@ DOC_END
 NAME: udp_hit_obj_size
 TYPE: int
 LOC: Config.udpMaxHitObjsz
+DEFAULT: 0
 DOC_START
 	If set, Squid will limit UDP_HIT_OBJ size to be less than
 	this value.  Setting this value to more than SQUID_UDP_SO_SNDBUF
@@ -1529,6 +1586,7 @@ DOC_END
 NAME: memory_pools
 COMMENT: on|off
 TYPE: onoff
+DEFAULT: on
 LOC: opt_mem_pools
 DOC_START
 	If set, Squid will keep pools of allocated (but unused) memory
@@ -1541,6 +1599,7 @@ DOC_END
 NAME: forwarded_for
 COMMENT: on|off
 TYPE: onoff
+DEFAULT: on
 LOC: opt_forwarded_for
 DOC_START
 	If set, Squid will include your system's IP address or name
@@ -1559,7 +1618,7 @@ DOC_END
 NAME: log_icp_queries
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 1
+DEFAULT: on
 LOC: Config.Options.log_udp
 DOC_START
 	If set, ICP queries are logged to access.log.  ICP logging
@@ -1584,6 +1643,8 @@ DOC_END
 
 NAME: cachemgr_passwd
 TYPE: cachemgrpasswd
+DEFAULT: disable all
+LOC: Config.passwd_list
 DOC_START
 	Specify passwords for cachemgr operations.
 
@@ -1668,6 +1729,7 @@ DOC_END
 NAME: http_anonymizer
 TYPE: httpanonymizer
 LOC: Config.Options.anonymizer
+DEFAULT: off
 DOC_START
 	If you want to filter out certain HTTP request headers for
 	privacy reasons, enable this option.  There are three
@@ -1685,7 +1747,7 @@ DOC_END
 NAME: client_db
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 1
+DEFAULT: on
 LOC: Config.Options.client_db
 DOC_START
 	If you want to disable collecting per-client statistics, then
@@ -1717,8 +1779,9 @@ DOC_END
 
 
 NAME: netdb_ping_period
-TYPE: time_sec
+TYPE: time_t
 LOC: Config.Netdb.period
+DEFAULT: 300
 DOC_START
 	The minimum period for measuring a site.  There will be at
 	least this much delay between successive pings to the same
@@ -1731,7 +1794,7 @@ DOC_END
 NAME: query_icmp
 COMMENT: on|off
 TYPE: onoff
-DEFAULT: 0
+DEFAULT: off
 LOC: Config.Options.query_icmp
 DOC_START
 	If you want to ask your peers to include ICMP data in their ICP
@@ -1749,29 +1812,18 @@ DOC_START
 query_icmp off
 DOC_END
 
-NAME: clean_rate
-TYPE: time_sec
-LOC: Config.cleanRate
-DOC_START
-	XXX need docs
-DOC_END
-
 NAME: always_direct
 TYPE: acl_access
 LOC: Config.accessList.AlwaysDirect
+DEFAULT: none
 DOC_START
 	XXX need docs
 DOC_END
 
 NAME: never_direct
 TYPE: acl_access
 LOC: Config.accessList.NeverDirect
-DOC_START
-	XXX need docs
-DOC_END
-
-NAME: viz_hack_addr
-TYPE: vizhack
+DEFAULT: none
 DOC_START
 	XXX need docs
 DOC_END
@@ -1,5 +1,5 @@
 /*
- * $Id: cf_gen.cc,v 1.3 1997/07/06 05:14:10 wessels Exp $
+ * $Id: cf_gen.cc,v 1.4 1997/07/07 05:29:41 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Max Okumoto
@@ -76,7 +76,7 @@ typedef struct Entry {
 
 
 static const char WS[] = " \t";
-static void gen_default(Entry *, FILE *);
+static int gen_default(Entry *, FILE *);
 static void gen_parse(Entry *, FILE *);
 static void gen_dump(Entry *, FILE *);
 static void gen_free(Entry *, FILE *);
@@ -93,6 +93,7 @@ main(int argc, char *argv[])
     Entry *entries = NULL;
     Entry *curr = NULL;
     enum State state;
+    int rc = 0;
 
     /*-------------------------------------------------------------------*
      * Parse input file
@@ -263,7 +264,7 @@ main(int argc, char *argv[])
 	"\n",
 	input_filename, argv[0]
 	);
-    gen_default(entries, fp);
+    rc = gen_default(entries, fp);
     gen_parse(entries, fp);
     gen_dump(entries, fp);
     gen_free(entries, fp);
@@ -277,13 +278,14 @@ main(int argc, char *argv[])
     gen_conf(entries, fp);
     fclose(fp);
 
-    return (0);
+    return (rc);
 }
 
-static void
+static int
 gen_default(Entry * head, FILE * fp)
 {
     Entry *entry;
+    int rc = 0;
     fprintf(fp,
 	"void\n"
 	"default_all(void)\n"
@@ -293,33 +295,25 @@ gen_default(Entry * head, FILE * fp)
 	assert(entry->name);
 	if (entry->loc == NULL) {
 	    fprintf(stderr, "NO LOCATION FOR %s\n", entry->name);
+	    rc |= 1;
 	    continue;
 	}
 	if (entry->default_value == NULL) {
 	    fprintf(stderr, "NO DEFAULT FOR %s\n", entry->name);
+	    rc |= 1;
 	    continue;
 	}
-#ifdef OLD
-	if (!strcmp(entry->type, "string")) {
-	    fprintf(fp, "\t%s = xstrdup(\"%s\");\n",
-		entry->loc, entry->default_value);
-	} else if (!strcmp(entry->type, "string_optional")) {
-	    fprintf(fp, "\t%s = xstrdup(\"%s\");\n",
-		entry->loc, entry->default_value);
-	} else if (!strcmp(entry->type, "pathname_check")) {
-	    fprintf(fp, "\t%s = xstrdup(\"%s\");\n",
-		entry->loc, entry->default_value);
+	assert(entry->default_value);
+	if (strcmp(entry->default_value, "none") == 0) {
+	    fprintf(fp, "\t/* No default for %s */\n", entry->name);
 	} else {
-	    fprintf(fp, "\t%s = %s;\n",
-		entry->loc, entry->default_value);
-	}
-#else
-	fprintf(fp, "\tparse_line(\"%s %s\");\n",
+	    fprintf(fp, "\tparse_line(\"%s %s\");\n",
 		entry->name,
 		entry->default_value);
-#endif
+	}
     }
     fprintf(fp, "}\n\n");
+    return rc;
 }
 
 static void
@@ -343,7 +337,8 @@ gen_parse(Entry * head, FILE * fp)
 	    "\t} else if (!strcmp(token, \"%s\")) {\n",
 	    entry->name
 	    );
-	if (entry->loc == NULL) {
+	assert(entry->loc);
+	if (strcmp(entry->loc, "none") == 0) {
 	    fprintf(fp,
 		"\t\tparse_%s();\n",
 		entry->type
@@ -375,15 +370,12 @@ gen_dump(Entry * head, FILE * fp)
 	"{\n"
 	);
     for (entry = head; entry != NULL; entry = entry->next) {
-	if (entry->loc == NULL) {
-	    fprintf(fp, "\tprintf(\"%s = \");\n", entry->type);
-	    fprintf(fp, "\tdump_%s();\n", entry->type);
-	} else {
-	    fprintf(fp, "\tprintf(\"%s = \");\n", entry->loc);
-	    fprintf(fp, "\tdump_%s(%s);\n", entry->type, entry->loc);
-	}
+	assert(entry->loc);
+	if (strcmp(entry->loc, "none") == 0)
+	    continue;
+	fprintf(fp, "\tprintf(\"%s = \");\n", entry->loc);
+	fprintf(fp, "\tdump_%s(%s);\n", entry->type, entry->loc);
 	fprintf(fp, "\tprintf(\"\\n\");\n");
-	fprintf(fp, "\n");
     }
     fprintf(fp, "}\n\n");
 }
@@ -398,11 +390,10 @@ gen_free(Entry * head, FILE * fp)
 	"{\n"
 	);
     for (entry = head; entry != NULL; entry = entry->next) {
-	if (entry->loc == NULL) {
-	    fprintf(fp, "\tfree_%s();\n", entry->type);
-	} else {
-	    fprintf(fp, "\tfree_%s(&%s);\n", entry->type, entry->loc);
-	}
+	assert(entry->loc);
+	if (strcmp(entry->loc, "none") == 0)
+	    continue;
+	fprintf(fp, "\tfree_%s(&%s);\n", entry->type, entry->loc);
     }
     fprintf(fp, "}\n\n");
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.115 1997/07/02 22:42:54 wessels Exp $
+ * $Id: client_side.cc,v 1.116 1997/07/07 05:29:41 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -73,7 +73,7 @@ checkAccelOnly(clientHttpRequest * http)
 {
     /* return TRUE if someone makes a proxy request to us and
      * we are in httpd-accel only mode */
-    if (!httpd_accel_mode)
+    if (!Config2.Accel.on)
 	return 0;
     if (Config.Accel.withProxy)
 	return 0;
@@ -115,7 +115,7 @@ clientAccessCheck(void *data)
 	return;
     }
     browser = mime_get_header(http->request->headers, "User-Agent");
-    http->acl_checklist = aclChecklistCreate(Config.accessList.HTTP,
+    http->acl_checklist = aclChecklistCreate(Config.accessList.http,
 	http->request,
 	conn->peer.sin_addr,
 	browser,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.171 1997/06/26 22:35:43 wessels Exp $
+ * $Id: comm.cc,v 1.172 1997/07/07 05:29:42 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -143,7 +143,7 @@ typedef struct {
 } ConnectStateData;
 
 /* GLOBAL */
-FD_ENTRY *fd_table = NULL;	/* also used in disk.c */
+fde *fd_table = NULL;	/* also used in disk.c */
 
 /* STATIC */
 static int commBind _PARAMS((int s, struct in_addr, u_short port));
@@ -210,7 +210,7 @@ comm_local_port(int fd)
 {
     struct sockaddr_in addr;
     int addr_len = 0;
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
 
     /* If the fd is closed already, just return */
     if (!fde->open) {
@@ -259,7 +259,7 @@ comm_open(int sock_type,
     const char *note)
 {
     int new_socket;
-    FD_ENTRY *fde = NULL;
+    fde *fde = NULL;
     int tcp_rcv_bufsz = Config.tcpRcvBufsz;
 
     /* Create socket for accepting new connections. */
@@ -419,8 +419,6 @@ commConnectHandle(int fd, void *data)
 	commSetSelect(fd, COMM_SELECT_WRITE, commConnectHandle, cs, 0);
 	break;
     case COMM_OK:
-	if (vizSock > -1)
-	    vizHackSendPkt(&cs->S, 2);
 	ipcacheCycleAddr(cs->host);
 	commConnectCallback(cs, COMM_OK);
 	break;
@@ -442,7 +440,7 @@ commConnectHandle(int fd, void *data)
 int
 commSetTimeout(int fd, int timeout, PF * handler, void *data)
 {
-    FD_ENTRY *fde;
+    fde *fde;
     debug(5, 3) ("commSetTimeout: FD %d timeout %d\n", fd, timeout);
     assert(fd >= 0);
     assert(fd < Squid_MaxFD);
@@ -469,7 +467,7 @@ int
 comm_connect_addr(int sock, const struct sockaddr_in *address)
 {
     int status = COMM_OK;
-    FD_ENTRY *fde = &fd_table[sock];
+    fde *fde = &fd_table[sock];
     int len;
     int x;
     assert(ntohs(address->sin_port) != 0);
@@ -522,7 +520,7 @@ comm_accept(int fd, struct sockaddr_in *peer, struct sockaddr_in *me)
     struct sockaddr_in P;
     struct sockaddr_in M;
     int Slen;
-    FD_ENTRY *fde = NULL;
+    fde *fde = NULL;
 
     Slen = sizeof(P);
     while ((sock = accept(fd, (struct sockaddr *) &P, &Slen)) < 0) {
@@ -564,8 +562,8 @@ comm_accept(int fd, struct sockaddr_in *peer, struct sockaddr_in *me)
 void
 commCallCloseHandlers(int fd)
 {
-    FD_ENTRY *fde = &fd_table[fd];
-    struct close_handler *ch;
+    fde *fde = &fd_table[fd];
+    close_handler *ch;
     debug(5, 5) ("commCallCloseHandlers: FD %d\n", fd);
     while ((ch = fde->close_handler) != NULL) {
 	fde->close_handler = ch->next;
@@ -577,7 +575,7 @@ commCallCloseHandlers(int fd)
 void
 comm_close(int fd)
 {
-    FD_ENTRY *fde = NULL;
+    fde *fde = NULL;
     debug(5, 5) ("comm_close: FD %d\n", fd);
     assert(fd >= 0);
     assert(fd < Squid_MaxFD);
@@ -910,9 +908,9 @@ comm_poll(time_t sec)
 		}
 	    }
 	    if (revents & POLLNVAL) {
-		struct close_handler *ch;
-		struct close_handler *next;
-		FD_ENTRY *fde = &fd_table[fd];
+		close_handler *ch;
+		close_handler *next;
+		fde *fde = &fd_table[fd];
 		debug(5, 0) ("WARNING: FD %d has handlers, but it's invalid.\n", fd);
 		debug(5, 0) ("FD %d is a %s\n", fd, fdstatTypeStr[fd_table[fd].type]);
 		debug(5, 0) ("--> %s\n", fd_table[fd].desc);
@@ -1076,7 +1074,7 @@ comm_select(time_t sec)
 void
 commSetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t timeout)
 {
-    FD_ENTRY *fde;
+    fde *fde;
     assert(fd >= 0);
     fde = &fd_table[fd];
     debug(5, 5) ("commSetSelect: FD %d, handler=%p, data=%p\n", fd, handler, client_data);
@@ -1095,7 +1093,7 @@ commSetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t
 void
 comm_add_close_handler(int fd, PF * handler, void *data)
 {
-    struct close_handler *new = xmalloc(sizeof(*new));
+    close_handler *new = xmalloc(sizeof(*new));
     debug(5, 5) ("comm_add_close_handler: FD %d, handler=%p, data=%p\n",
 	fd, handler, data);
     new->handler = handler;
@@ -1107,8 +1105,8 @@ comm_add_close_handler(int fd, PF * handler, void *data)
 void
 comm_remove_close_handler(int fd, PF * handler, void *data)
 {
-    struct close_handler *p;
-    struct close_handler *last = NULL;
+    close_handler *p;
+    close_handler *last = NULL;
     /* Find handler in list */
     for (p = fd_table[fd].close_handler; p != NULL; last = p, p = p->next)
 	if (p->handler == handler && p->data == data)
@@ -1191,8 +1189,8 @@ commSetTcpNoDelay(int fd)
 int
 comm_init(void)
 {
-    fd_table = xcalloc(Squid_MaxFD, sizeof(FD_ENTRY));
-    meta_data.misc += Squid_MaxFD * sizeof(FD_ENTRY);
+    fd_table = xcalloc(Squid_MaxFD, sizeof(fde));
+    meta_data.misc += Squid_MaxFD * sizeof(fde);
     /* Keep a few file descriptors free so that we don't run out of FD's
      * after accepting a client but before it opens a socket or a file.
      * Since Squid_MaxFD can be as high as several thousand, don't waste them */
@@ -1224,9 +1222,9 @@ examine_select(fd_set * readfds, fd_set * writefds)
     fd_set write_x;
     int num;
     struct timeval tv;
-    struct close_handler *ch = NULL;
-    struct close_handler *next = NULL;
-    FD_ENTRY *fde = NULL;
+    close_handler *ch = NULL;
+    close_handler *next = NULL;
+    fde *fde = NULL;
 
     debug(5, 0) ("examine_select: Examining open file descriptors...\n");
     for (fd = 0; fd < Squid_MaxFD; fd++) {
@@ -1282,7 +1280,7 @@ static void
 checkTimeouts(void)
 {
     int fd;
-    FD_ENTRY *fde = NULL;
+    fde *fde = NULL;
     PF *callback;
     for (fd = 0; fd <= Biggest_FD; fd++) {
 	fde = &fd_table[fd];
@@ -1,5 +1,5 @@
 /*
- * $Id: disk.cc,v 1.75 1997/06/26 22:35:44 wessels Exp $
+ * $Id: disk.cc,v 1.76 1997/07/07 05:29:43 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -181,7 +181,7 @@ static void
 file_open_complete(void *data, int fd, int errcode)
 {
     open_ctrl_t *ctrlp = (open_ctrl_t *) data;
-    FD_ENTRY *fde;
+    fde *fde;
     if (fd < 0) {
 	errno = errcode;
 	debug(50, 0) ("file_open: error opening file %s: %s\n", ctrlp->path,
@@ -206,7 +206,7 @@ file_open_complete(void *data, int fd, int errcode)
 void
 file_close(int fd)
 {
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     assert(fd >= 0);
     assert(fde->open);
     if (BIT_TEST(fde->flags, FD_WRITE_DAEMON)) {
@@ -235,7 +235,7 @@ diskHandleWrite(int fd, void *unused)
     disk_ctrl_t *ctrlp;
     dwrite_q *q = NULL;
     dwrite_q *wq = NULL;
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     struct _fde_disk *fdd = &fde->disk;
     if (!fdd->write_q)
 	return;
@@ -284,7 +284,7 @@ diskHandleWriteComplete(void *data, int len, int errcode)
 {
     disk_ctrl_t *ctrlp = data;
     int fd = ctrlp->fd;
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     struct _fde_disk *fdd = &fde->disk;
     dwrite_q *q = fdd->write_q;
     int status = DISK_OK;
@@ -350,7 +350,7 @@ file_write(int fd,
     FREE * free_func)
 {
     dwrite_q *wq = NULL;
-    FD_ENTRY *fde;
+    fde *fde;
     if (fd < 0)
 	fatal_dump("file_write: bad FD");
     fde = &fd_table[fd];
@@ -1,5 +1,5 @@
 /*
- * $Id: dns.cc,v 1.35 1997/06/04 06:15:50 wessels Exp $
+ * $Id: dns.cc,v 1.36 1997/07/07 05:29:44 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -112,13 +112,8 @@ struct dnsQueueData {
 
 static int dnsOpenServer _PARAMS((const char *command));
 static PF dnsShutdownRead;
-
 static dnsserver_t **dns_child_table = NULL;
 
-int NDnsServersAlloc = 0;
-char *dns_error_message = NULL;	/* possible error message */
-struct _dnsStats DnsStats;
-
 static int
 dnsOpenServer(const char *command)
 {
@@ -22,20 +22,20 @@ fdUpdateBiggest(int fd, unsigned int status)
 void
 fd_close(int fd)
 {
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     if (fde->type == FD_FILE) {
 	assert(fde->read_handler == NULL);
 	assert(fde->write_handler == NULL);
     }
     fdUpdateBiggest(fd, fde->open = FD_CLOSE);
-    memset(fde, '\0', sizeof(FD_ENTRY));
+    memset(fde, '\0', sizeof(fde));
     fde->timeout = 0;
 }
 
 void
 fd_open(int fd, unsigned int type, const char *desc)
 {
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     assert(fde->open == 0);
     fde->type = type;
     fdUpdateBiggest(fd, fde->open = FD_OPEN);
@@ -46,14 +46,14 @@ fd_open(int fd, unsigned int type, const char *desc)
 void
 fd_note(int fd, const char *s)
 {
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     xstrncpy(fde->desc, s, FD_DESC_SZ);
 }
 
 void
 fd_bytes(int fd, int len, unsigned int type)
 {
-    FD_ENTRY *fde = &fd_table[fd];
+    fde *fde = &fd_table[fd];
     if (len < 0)
 	return;
     assert(type == FD_READ || type == FD_WRITE);
@@ -73,7 +73,7 @@ void
 fdDumpOpen(void)
 {
     int i;
-    FD_ENTRY *fde;
+    fde *fde;
     for (i = 0; i < Squid_MaxFD; i++) {
 	fde = &fd_table[i];
 	if (!fde->open)
@@ -1,5 +1,5 @@
 /*
- * $Id: filemap.cc,v 1.18 1997/06/04 06:15:52 wessels Exp $
+ * $Id: filemap.cc,v 1.19 1997/07/07 05:29:45 wessels Exp $
  *
  * DEBUG: section 8     Swap File Bitmap
  * AUTHOR: Harvest Derived
@@ -104,7 +104,6 @@
  */
 
 #include "squid.h"
-#include "filemap.h"
 
 /* Number of bits in a long */
 #if SIZEOF_LONG == 8
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icmp.cc,v 1.37 1997/06/04 06:15:58 wessels Exp $
+ * $Id: icmp.cc,v 1.38 1997/07/07 05:29:46 wessels Exp $
  *
  * DEBUG: section 37    ICMP Routines
  * AUTHOR: Duane Wessels
@@ -31,7 +31,6 @@
 
 
 #include "squid.h"
-#include "pinger.h"
 
 int icmp_sock = -1;
 
@@ -1,5 +1,5 @@
 /*
- * $Id: main.cc,v 1.157 1997/06/26 22:41:43 wessels Exp $
+ * $Id: main.cc,v 1.158 1997/07/07 05:29:48 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -105,49 +105,10 @@
 
 #include "squid.h"
 
-time_t squid_starttime = 0;
-int HttpSockets[MAXHTTPPORTS];
-int NHttpSockets = 0;
-int theInIcpConnection = -1;
-int theOutIcpConnection = -1;
-int vizSock = -1;
-int do_reuse = 1;
-int opt_reload_hit_only = 0;	/* only UDP_HIT during store relaod */
-int opt_catch_signals = 1;
-int opt_dns_tests = 1;
-int opt_foreground_rebuild = 0;
-int opt_zap_disk_store = 0;
-int opt_syslog_enable = 0;	/* disabled by default */
-int opt_no_ipcache = 0;		/* use ipcache by default */
-static int opt_send_signal = -1;	/* no signal to send */
-int opt_udp_hit_obj = 0;	/* ask for HIT_OBJ's */
-int opt_mem_pools = 1;
-int opt_forwarded_for = 1;
-int opt_accel_uses_host = 0;
-int opt_debug_stderr = 0;
-int vhost_mode = 0;
-int Squid_MaxFD = SQUID_MAXFD;
-int Biggest_FD = -1;
-int select_loops = 0;		/* how many times thru select loop */
-int configured_once = 0;
-volatile int unbuffered_logs = 1;	/* debug and hierarchy unbuffered by default */
-volatile int shutdown_pending = 0;	/* set by SIGTERM handler (shut_down()) */
-volatile int reconfigure_pending = 0;	/* set by SIGHUP handler */
-const char *const version_string = SQUID_VERSION;
-const char *const appname = "squid";
-const char *const localhost = "127.0.0.1";
-struct in_addr local_addr;
-struct in_addr no_addr;
-struct in_addr any_addr;
-struct in_addr theOutICPAddr;
-const char *const dash_str = "-";
-const char *const null_string = "";
-const char *const w_space = " \t\n\r";
-char ThisCache[SQUIDHOSTNAMELEN << 1];
-
 /* for error reporting from xmalloc and friends */
 extern void (*failure_notify) _PARAMS((const char *));
 
+static int opt_send_signal = -1;
 static volatile int rotate_pending = 0;		/* set by SIGUSR1 handler */
 static int httpPortNumOverride = 1;
 static int icpPortNumOverride = 1;	/* Want to detect "-u 0" */
@@ -373,7 +334,7 @@ serverConnectionsOpen(void)
     }
     if (NHttpSockets < 1)
 	fatal("Cannot open HTTP Port");
-    if (!httpd_accel_mode || Config.Accel.withProxy) {
+    if (!Config2.Accel.on || Config.Accel.withProxy) {
 	if ((port = Config.Port.icp) > (u_short) 0) {
 	    enter_suid();
 	    theInIcpConnection = comm_open(SOCK_DGRAM,
@@ -429,21 +390,6 @@ serverConnectionsOpen(void)
 		theOutICPAddr = xaddr.sin_addr;
 	}
     }
-    if (Config.vizHack.port) {
-	vizSock = comm_open(SOCK_DGRAM,
-	    0,
-	    any_addr,
-	    0,
-	    COMM_NONBLOCKING,
-	    "VizHack Port");
-	if (vizSock < 0)
-	    fatal("Could not open Viz Socket");
-	mcastJoinVizSock();
-	memset(&Config.vizHack.S, '\0', sizeof(struct sockaddr_in));
-	Config.vizHack.S.sin_family = AF_INET;
-	Config.vizHack.S.sin_addr = Config.vizHack.addr;
-	Config.vizHack.S.sin_port = htons(Config.vizHack.port);
-    }
     clientdbInit();
     icmpOpen();
     netdbInit();
@@ -499,7 +445,7 @@ mainReconfigure(void)
     dnsOpenServers();
     redirectOpenServers();
     serverConnectionsOpen();
-    if (theOutIcpConnection >= 0 && (!httpd_accel_mode || Config.Accel.withProxy))
+    if (theOutIcpConnection >= 0 && (!Config2.Accel.on || Config.Accel.withProxy))
 	neighbors_open(theOutIcpConnection);
     debug(1, 0) ("Ready to serve requests.\n");
 }
@@ -577,7 +523,7 @@ mainInitialize(void)
 	mimeInit(Config.mimeTablePathname);
     }
     serverConnectionsOpen();
-    if (theOutIcpConnection >= 0 && (!httpd_accel_mode || Config.Accel.withProxy))
+    if (theOutIcpConnection >= 0 && (!Config2.Accel.on || Config.Accel.withProxy))
 	neighbors_open(theOutIcpConnection);
 
     if (!configured_once)
@@ -593,7 +539,6 @@ mainInitialize(void)
     debug(1, 0) ("Ready to serve requests.\n");
 
     if (!configured_once) {
-	eventAdd("storePurgeOld", storePurgeOld, NULL, Config.cleanRate);
 	eventAdd("storeMaintain", storeMaintainSwapSpace, NULL, 1);
 	eventAdd("storeDirClean", storeDirClean, NULL, 15);
 	if (Config.Announce.on)
@@ -0,0 +1,20 @@
+print "#include \"squid.h\"\n";
+while (<>) {
+	$init = undef;
+	if (/^#/) {
+		print;
+		next;
+	}
+	next unless (/./);
+	next if (/\[\];$/);
+	die unless (/^extern\s+([^;]+);(.*)$/);
+	$var = $1;
+	$comments = $2;
+	if ($comments =~ m+/\*\s*(.*)\s*\*/+) {
+		$init = $1;
+	}
+	print $var;
+	print " = $init" if (defined $init);
+	print ";\n";
+}
+exit 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: multicast.cc,v 1.2 1997/06/26 22:35:54 wessels Exp $
+ * $Id: multicast.cc,v 1.3 1997/07/07 05:29:49 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Martin Hamilton
@@ -72,40 +72,3 @@ mcastJoinGroups(const ipcache_addrs * ia, void *data)
     }
 #endif
 }
-
-void
-mcastJoinVizSock(void)
-{
-#if defined(IP_ADD_MEMBERSHIP) && defined(IP_MULTICAST_TTL)
-    int x;
-    if (Config.vizHack.addr.s_addr > inet_addr("224.0.0.0")) {
-	struct ip_mreq mr;
-	char ttl = (char) Config.vizHack.mcast_ttl;
-	memset(&mr, '\0', sizeof(struct ip_mreq));
-	mr.imr_multiaddr.s_addr = Config.vizHack.addr.s_addr;
-	mr.imr_interface.s_addr = INADDR_ANY;
-	x = setsockopt(vizSock,
-	    IPPROTO_IP,
-	    IP_ADD_MEMBERSHIP,
-	    (char *) &mr,
-	    sizeof(struct ip_mreq));
-	if (x < 0)
-	    debug(50, 1) ("IP_ADD_MEMBERSHIP: FD %d, addr %s: %s\n",
-		vizSock, inet_ntoa(Config.vizHack.addr), xstrerror());
-	x = setsockopt(vizSock,
-	    IPPROTO_IP,
-	    IP_MULTICAST_TTL,
-	    &ttl,
-	    sizeof(char));
-	if (x < 0)
-	    debug(50, 1) ("IP_MULTICAST_TTL: FD %d, TTL %d: %s\n",
-		vizSock, Config.vizHack.mcast_ttl, xstrerror());
-	ttl = 0;
-	x = sizeof(char);
-	getsockopt(vizSock, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, &x);
-	debug(1, 0) ("vizSock on FD %d, ttl=%d\n", vizSock, (int) ttl);
-    }
-#else
-    debug(1, 0) ("vizSock: Could not join multicast group\n");
-#endif
-}
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.148 1997/06/26 22:41:44 wessels Exp $
+ * $Id: neighbors.cc,v 1.149 1997/07/07 05:29:49 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -115,7 +115,6 @@ static void neighborRemove _PARAMS((peer *));
 static peer *whichPeer _PARAMS((const struct sockaddr_in * from));
 static void neighborAlive _PARAMS((peer *, const MemObject *, const icp_common_t *));
 static void neighborCountIgnored _PARAMS((peer *, icp_opcode op_unused));
-static peer_t parseNeighborType _PARAMS((const char *s));
 static void peerRefreshDNS _PARAMS((void *));
 static IPH peerDNSConfigure;
 static void peerCheckConnect _PARAMS((void *));
@@ -137,6 +136,8 @@ static struct {
     peer *peers_tail;
     peer *first_ping;
     peer *removed;
+    peer *ssl_parent;
+    peer *pass_parent;
 } Peers = {
 
     0, NULL, NULL, NULL
@@ -342,6 +343,18 @@ getDefaultParent(request_t * request)
     return NULL;
 }
 
+peer *
+getSslParent(void)
+{
+	return Peers.ssl_parent;
+}
+
+peer *
+getPassParent(void)
+{
+	return Peers.pass_parent;
+}
+
 peer *
 getNextPeer(peer * p)
 {
@@ -767,90 +780,6 @@ neighborAdd(const char *host,
 	Peers.first_ping = p;
 }
 
-void
-neighborAddDomainPing(const char *host, const char *domain)
-{
-    struct _domain_ping *l = NULL;
-    struct _domain_ping **L = NULL;
-    peer *p;
-    if ((p = neighborFindByName(host)) == NULL) {
-	debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
-	    cfg_filename, config_lineno, host);
-	return;
-    }
-    l = xmalloc(sizeof(struct _domain_ping));
-    l->do_ping = 1;
-    if (*domain == '!') {	/* check for !.edu */
-	l->do_ping = 0;
-	domain++;
-    }
-    l->domain = xstrdup(domain);
-    l->next = NULL;
-    for (L = &(p->pinglist); *L; L = &((*L)->next));
-    *L = l;
-}
-
-void
-neighborAddDomainType(const char *host, const char *domain, const char *type)
-{
-    struct _domain_type *l = NULL;
-    struct _domain_type **L = NULL;
-    peer *p;
-    if ((p = neighborFindByName(host)) == NULL) {
-	debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
-	    cfg_filename, config_lineno, host);
-	return;
-    }
-    l = xmalloc(sizeof(struct _domain_type));
-    l->type = parseNeighborType(type);
-    l->domain = xstrdup(domain);
-    l->next = NULL;
-    for (L = &(p->typelist); *L; L = &((*L)->next));
-    *L = l;
-}
-
-void
-neighborAddAcl(const char *host, const char *aclname)
-{
-    peer *p;
-    struct _acl_list *L = NULL;
-    struct _acl_list **Tail = NULL;
-    struct _acl *a = NULL;
-
-    if ((p = neighborFindByName(host)) == NULL) {
-	debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
-	    cfg_filename, config_lineno, host);
-	return;
-    }
-    L = xcalloc(1, sizeof(struct _acl_list));
-    L->op = 1;
-    if (*aclname == '!') {
-	L->op = 0;
-	aclname++;
-    }
-    debug(15, 3) ("neighborAddAcl: looking for ACL name '%s'\n", aclname);
-    a = aclFindByName(aclname);
-    if (a == NULL) {
-	debug(15, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(15, 0) ("neighborAddAcl: ACL name '%s' not found.\n", aclname);
-	xfree(L);
-	return;
-    }
-#ifdef NOW_SUPPORTED
-    if (a->type == ACL_SRC_IP) {
-	debug(15, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(15, 0) ("neighborAddAcl: 'src' ACL's not supported for 'cache_host_acl'\n");
-	xfree(L);
-	return;
-    }
-#endif
-    L->acl = a;
-    for (Tail = &(p->acls); *Tail; Tail = &((*Tail)->next));
-    *Tail = L;
-}
-
 peer *
 neighborFindByName(const char *name)
 {
@@ -862,23 +791,6 @@ neighborFindByName(const char *name)
     return p;
 }
 
-static peer_t
-parseNeighborType(const char *s)
-{
-    if (!strcasecmp(s, "parent"))
-	return PEER_PARENT;
-    if (!strcasecmp(s, "neighbor"))
-	return PEER_SIBLING;
-    if (!strcasecmp(s, "neighbour"))
-	return PEER_SIBLING;
-    if (!strcasecmp(s, "sibling"))
-	return PEER_SIBLING;
-    if (!strcasecmp(s, "multicast"))
-	return PEER_MULTICAST;
-    debug(15, 0) ("WARNING: Unknown neighbor type: %s\n", s);
-    return PEER_SIBLING;
-}
-
 int
 neighborUp(const peer * p)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.16 1997/06/26 22:35:56 wessels Exp $
+ * $Id: peer_select.cc,v 1.17 1997/07/07 05:29:51 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -103,12 +103,12 @@ peerGetSomeParent(request_t * request, hier_code * code)
 {
     peer *p;
     if (request->method == METHOD_CONNECT)
-	if ((p = Config.sslProxy)) {
+	if ((p = getSslParent())) {
 	    *code = SSL_PARENT;
 	    return p;
 	}
     if (request->method != METHOD_GET)
-	if ((p = Config.passProxy)) {
+	if ((p = getPassParent())) {
 	    *code = PASS_PARENT;
 	    return p;
 	}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: pinger.cc,v 1.23 1997/06/04 06:16:06 wessels Exp $
+ * $Id: pinger.cc,v 1.24 1997/07/07 05:29:51 wessels Exp $
  *
  * DEBUG: section 42    ICMP Pinger program
  * AUTHOR: Duane Wessels
@@ -30,7 +30,6 @@
  */
 
 #include "squid.h"
-#include "pinger.h"
 
 /* Junk so we can link with debug.o */
 int opt_syslog_enable = 0;
@@ -39,7 +38,7 @@ const char *const appname = "pinger";
 const char *const w_space = " \r\n\t";
 struct timeval current_time;
 time_t squid_curtime;
-struct SquidConfig Config;
+SquidConfig Config;
 int opt_debug_stderr = 0;
 
 #if USE_ICMP
@@ -1,6 +1,6 @@
 
 /*
- * $Id: refresh.cc,v 1.13 1997/07/02 22:42:57 wessels Exp $
+ * $Id: refresh.cc,v 1.14 1997/07/07 05:29:52 wessels Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -45,72 +45,6 @@
 #define REFRESH_DEFAULT_PCT	(time_t)20
 #define REFRESH_DEFAULT_MAX	(time_t)259200
 
-typedef struct _refresh_t {
-    char *pattern;
-    regex_t compiled_pattern;
-    time_t min;
-    int pct;
-    time_t max;
-    struct _refresh_t *next;
-} refresh_t;
-
-static refresh_t *Refresh_tbl = NULL;
-static refresh_t *Refresh_tail = NULL;
-
-static void
-refreshFreeList(refresh_t * t)
-{
-    refresh_t *tnext;
-
-    for (; t; t = tnext) {
-	tnext = t->next;
-	safe_free(t->pattern);
-	regfree(&t->compiled_pattern);
-	safe_free(t);
-    }
-}
-
-void
-refreshFreeMemory(void)
-{
-    refreshFreeList(Refresh_tbl);
-    Refresh_tail = Refresh_tbl = NULL;
-}
-
-void
-refreshAddToList(const char *pattern, int opts, time_t min, int pct, time_t max)
-{
-    refresh_t *t;
-    regex_t comp;
-    int errcode;
-    int flags = REG_EXTENDED | REG_NOSUB;
-    if (opts & REFRESH_ICASE)
-	flags |= REG_ICASE;
-    if ((errcode = regcomp(&comp, pattern, flags)) != 0) {
-	char errbuf[256];
-	regerror(errcode, &comp, errbuf, sizeof errbuf);
-	debug(22, 0) ("%s line %d: %s\n",
-	    cfg_filename, config_lineno, config_input_line);
-	debug(22, 0) ("refreshAddToList: Invalid regular expression '%s': %s\n",
-	    pattern, errbuf);
-	return;
-    }
-    pct = pct < 0 ? 0 : pct;
-    max = max < 0 ? 0 : max;
-    t = xcalloc(1, sizeof(refresh_t));
-    t->pattern = (char *) xstrdup(pattern);
-    t->compiled_pattern = comp;
-    t->min = min;
-    t->pct = pct;
-    t->max = max;
-    t->next = NULL;
-    if (!Refresh_tbl)
-	Refresh_tbl = t;
-    if (Refresh_tail)
-	Refresh_tail->next = t;
-    Refresh_tail = t;
-}
-
 /*
  * refreshCheck():
  *     return 1 if its time to revalidate this entry, 0 otherwise
@@ -131,7 +65,7 @@ refreshCheck(const StoreEntry * entry, const request_t * request, time_t delta)
 	debug(22, 3)("refreshCheck: YES: Required Authorization\n");
 	return 1;
     }
-    for (R = Refresh_tbl; R; R = R->next) {
+    for (R = Config.Refresh; R; R = R->next) {
 	if (regexec(&(R->compiled_pattern), entry->url, 0, 0, 0) != 0)
 	    continue;
 	min = R->min;
@@ -189,7 +123,7 @@ getMaxAge(const char *url)
 {
     refresh_t *R;
     debug(22, 3) ("getMaxAge: '%s'\n", url);
-    for (R = Refresh_tbl; R; R = R->next) {
+    for (R = Config.Refresh; R; R = R->next) {
 	if (regexec(&(R->compiled_pattern), url, 0, 0, 0) == 0)
 	    return R->max;
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.40 1997/06/26 22:41:45 wessels Exp $
+ * $Id: send-announce.cc,v 1.41 1997/07/07 05:29:52 wessels Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -39,7 +39,7 @@ start_announce(void *unused)
     if (!Config.Announce.on)
 	return;
     ipcache_nbgethostbyname(Config.Announce.host, send_announce, NULL);
-    eventAdd("send_announce", start_announce, NULL, Config.Announce.rate);
+    eventAdd("send_announce", start_announce, NULL, Config.Announce.period);
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.126 1997/06/26 22:43:51 wessels Exp $
+ * $Id: squid.h,v 1.127 1997/07/07 05:29:53 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -224,21 +224,6 @@
 #define SA_RESETHAND SA_ONESHOT
 #endif
 
-typedef struct sentry StoreEntry;
-typedef struct mem_hdr *mem_ptr;
-typedef struct _peer peer;
-typedef struct icp_common_s icp_common_t;
-typedef struct _cacheinfo cacheinfo;
-typedef struct _aclCheck_t aclCheck_t;
-typedef struct _request request_t;
-typedef struct _MemObject MemObject;
-typedef struct _cachemgr_passwd cachemgr_passwd;
-typedef struct _fileMap fileMap;
-typedef struct _cwstate CommWriteStateData;
-typedef struct _ipcache_addrs ipcache_addrs;
-typedef struct _AccessLogEntry AccessLogEntry;
-typedef struct _HierarchyLogEntry HierarchyLogEntry;
-
 /* 32 bit integer compatability hack */
 #if SIZEOF_INT == 4
 typedef int num32;
@@ -269,53 +254,14 @@ typedef unsigned long u_num32;
 #include <regex.h>
 #endif
 
-typedef void SIH _PARAMS((void *, int));	/* swap in */
-typedef int QS _PARAMS((const void *, const void *));	/* qsort */
-typedef void STCB _PARAMS((void *, char *, ssize_t));	/* store callback */
-
+#include "defines.h"
 #include "enums.h"
-#include "cache_cf.h"
-#include "fd.h"
-#include "comm.h"
-#include "disk.h"
-#include "debug.h"
-#include "fdstat.h"
-#include "hash.h"
-#include "proto.h"		/* must go before neighbors.h */
-#include "peer_select.h"	/* must go before neighbors.h */
-#include "neighbors.h"		/* must go before url.h */
-#include "access_log.h"
-#include "url.h"
-#include "icp.h"
-#include "errorpage.h"		/* must go after icp.h */
-#include "dns.h"
-#include "event.h"
-#include "ipcache.h"
-#include "fqdncache.h"
-#include "mime.h"
-#include "stack.h"
-#include "stat.h"
-#include "stmem.h"
-#include "store.h"
-#include "store_dir.h"
-#include "tools.h"
-#include "http.h"
-#include "ftp.h"
-#include "gopher.h"
+#include "typedefs.h"
+#include "structs.h"
+#include "protos.h"
+#include "globals.h"
+
 #include "util.h"
-#include "acl.h"
-#include "async_io.h"
-#include "redirect.h"
-#include "client_side.h"
-#include "useragent.h"
-#include "icmp.h"
-#include "net_db.h"
-#include "client_db.h"
-#include "objcache.h"
-#include "refresh.h"
-#include "unlinkd.h"
-#include "multicast.h"
-#include "cbdata.h"
 
 #if !HAVE_TEMPNAM
 #include "tempnam.h"
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.146 1997/06/26 22:35:57 wessels Exp $
+ * $Id: stat.cc,v 1.147 1997/07/07 05:29:54 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -119,17 +119,6 @@ typedef struct _squid_read_data_t {
     int fd;
 } squid_read_data_t;
 
-/* GLOBALS */
-Meta_data meta_data;
-volatile unsigned long ntcpconn = 0;
-volatile unsigned long nudpconn = 0;
-struct _iostats IOStats;
-const char *const open_bracket = "{\n";
-const char *const close_bracket = "}\n";
-
-extern int unlinkd_count;
-extern int fileno_stack_count;
-
 /* LOCALS */
 static const char *describeStatuses _PARAMS((const StoreEntry *));
 static const char *describeFlags _PARAMS((const StoreEntry *));
@@ -479,7 +468,7 @@ info_get_mallstat(int size, int number, StoreEntry * sentry)
 #endif
 
 static const char *
-fdRemoteAddr(const FD_ENTRY * f)
+fdRemoteAddr(const fde * f)
 {
     LOCAL_ARRAY(char, buf, 32);
     if (f->type != FD_SOCKET)
@@ -492,7 +481,7 @@ static void
 statFiledescriptors(StoreEntry * sentry)
 {
     int i;
-    FD_ENTRY *f;
+    fde *f;
 
     storeAppendPrintf(sentry, open_bracket);
     storeAppendPrintf(sentry, "{Active file descriptors:}\n");
@@ -803,13 +792,10 @@ parameter_get(StoreEntry * sentry)
 	Config.Timeout.read);
     storeAppendPrintf(sentry, "{DeferTimeout %d\n", Config.Timeout.defer);
     storeAppendPrintf(sentry, "{ClientLifetime %d\n", Config.Timeout.lifetime);
-    storeAppendPrintf(sentry,
-	"{CleanRate %d \"# Rate for periodic object expiring\"}\n",
-	Config.cleanRate);
     /* Cachemgr.cgi expects an integer in the second field of the string */
     storeAppendPrintf(sentry,
 	"{HttpAccelMode %d \"# Is operating as an HTTP accelerator\"}\n",
-	httpd_accel_mode);
+	Config2.Accel.on);
     storeAppendPrintf(sentry, close_bracket);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stmem.cc,v 1.44 1997/06/20 00:00:15 wessels Exp $
+ * $Id: stmem.cc,v 1.45 1997/07/07 05:29:55 wessels Exp $
  *
  * DEBUG: section 19    Memory Primitives
  * AUTHOR: Harvest Derived
@@ -122,9 +122,10 @@ static void put_free_thing _PARAMS((stmem_stats *, void *));
 static void stmemFreeThingMemory _PARAMS((stmem_stats *));
 
 void
-memFree(mem_ptr mem)
+memFree(mem_hdr * mem)
 {
-    mem_node lastp, p = mem->head;
+    mem_node *lastp;
+    mem_node *p = mem->head;
 
     if (p) {
 	while (p && (p != mem->tail)) {
@@ -141,15 +142,16 @@ memFree(mem_ptr mem)
 	    safe_free(p);
 	}
     }
-    memset(mem, '\0', sizeof(mem_ptr));		/* nuke in case ref'ed again */
+    memset(mem, '\0', sizeof(mem_hdr *));		/* nuke in case ref'ed again */
     safe_free(mem);
 }
 
 #ifdef UNUSED_CODE
 void
-memFreeData(mem_ptr mem)
+memFreeData(mem_hdr * mem)
 {
-    mem_node lastp, p = mem->head;
+    mem_node *lastp;
+    mem_node *p = mem->head;
     while (p != mem->tail) {
 	lastp = p;
 	p = p->next;
@@ -167,10 +169,11 @@ memFreeData(mem_ptr mem)
 #endif
 
 int
-memFreeDataUpto(mem_ptr mem, int target_offset)
+memFreeDataUpto(mem_hdr * mem, int target_offset)
 {
     int current_offset = mem->origin_offset;
-    mem_node lastp, p = mem->head;
+    mem_node *lastp;
+    mem_node *p = mem->head;
 
     while (p && ((current_offset + p->len) <= target_offset)) {
 	if (p == mem->tail) {
@@ -204,9 +207,9 @@ memFreeDataUpto(mem_ptr mem, int target_offset)
 
 /* Append incoming data. */
 void
-memAppend(mem_ptr mem, const char *data, int len)
+memAppend(mem_hdr * mem, const char *data, int len)
 {
-    mem_node p;
+    mem_node *p;
     int avail_len;
     int len_to_copy;
 
@@ -227,7 +230,7 @@ memAppend(mem_ptr mem, const char *data, int len)
     }
     while (len > 0) {
 	len_to_copy = min(len, SM_PAGE_SIZE);
-	p = xcalloc(1, sizeof(Mem_Node));
+	p = xcalloc(1, sizeof(mem_node));
 	p->next = NULL;
 	p->len = len_to_copy;
 	p->data = get_free_4k_page();
@@ -247,9 +250,9 @@ memAppend(mem_ptr mem, const char *data, int len)
 }
 
 ssize_t
-memCopy(const mem_ptr mem, off_t offset, char *buf, size_t size)
+memCopy(const mem_hdr * mem, off_t offset, char *buf, size_t size)
 {
-    mem_node p = mem->head;
+    mem_node *p = mem->head;
     off_t t_off = mem->origin_offset;
     size_t bytes_to_go = size;
     char *ptr_to_buf = NULL;
@@ -290,10 +293,10 @@ memCopy(const mem_ptr mem, off_t offset, char *buf, size_t size)
 
 
 /* Do whatever is necessary to begin storage of new object */
-mem_ptr
+mem_hdr *
 memInit(void)
 {
-    mem_ptr new = xcalloc(1, sizeof(Mem_Hdr));
+    mem_hdr * new = xcalloc(1, sizeof(mem_hdr));
     new->tail = new->head = NULL;
     return new;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.264 1997/07/02 22:42:58 wessels Exp $
+ * $Id: store.cc,v 1.265 1997/07/07 05:29:56 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -130,8 +130,6 @@
  */
 
 #include "squid.h"		/* goes first */
-#include "filemap.h"
-#include "store_dir.h"
 
 #define REBUILD_TIMESTAMP_DELTA_MAX 2
 #define SWAP_BUF		DISK_PAGE_SIZE
@@ -264,7 +262,7 @@ static DRCB storeSwapInHandle;
 static VCB storeSwapInValidateComplete;
 static void storeSwapInStartComplete _PARAMS((void *, int));
 static int swapInError _PARAMS((int, StoreEntry *));
-static mem_ptr new_MemObjectData _PARAMS((void));
+static mem_hdr *new_MemObjectData _PARAMS((void));
 static MemObject *new_MemObject _PARAMS((void));
 static StoreEntry *new_StoreEntry _PARAMS((int));
 static StoreEntry *storeAddDiskRestore _PARAMS((const char *,
@@ -398,7 +396,7 @@ destroy_StoreEntry(StoreEntry * e)
     meta_data.store_entries--;
 }
 
-static mem_ptr
+static mem_hdr *
 new_MemObjectData(void)
 {
     debug(20, 3) ("new_MemObjectData: calling memInit()\n");
@@ -1596,7 +1594,7 @@ storeStartRebuildFromDisk(void)
     int clean;
     RB = xcalloc(1, sizeof(struct storeRebuildState));
     RB->start = squid_curtime;
-    for (i = 0; i < ncache_dirs; i++) {
+    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
 	fp = storeDirOpenTmpSwapLog(i, &clean);
 	if (fp == NULL)
 	    continue;
@@ -1745,28 +1743,6 @@ storeGetNext(void)
     return ((StoreEntry *) hash_next(store_table));
 }
 
-/* free up all ttl-expired objects */
-void
-storePurgeOld(void *unused)
-{
-    StoreEntry *e = NULL;
-    int n = 0;
-    int count = 0;
-    /* reschedule */
-    eventAdd("storePurgeOld", storePurgeOld, NULL, Config.cleanRate);
-    for (e = storeGetFirst(); e; e = storeGetNext()) {
-	if ((++n & 0xFF) == 0) {
-	    if (shutdown_pending || reconfigure_pending)
-		break;
-	}
-	if ((n & 0xFFF) == 0)
-	    debug(20, 2) ("storeWalkThrough: %7d objects so far.\n", n);
-	if (storeCheckExpired(e, 1))
-	    count += storeRelease(e);
-    }
-    debug(20, 0) ("storePurgeOld: Removed %d objects\n", count);
-}
-
 
 /* Clear Memory storage to accommodate the given object len */
 static void
@@ -2312,7 +2288,7 @@ storeInit(void)
 	storelog_fd = file_open(fname, O_WRONLY | O_CREAT, NULL, NULL);
     if (storelog_fd < 0)
 	debug(20, 1) ("Store logging disabled\n");
-    if (ncache_dirs < 1)
+    if (Config.cacheSwap.n_configured < 1)
 	fatal("No cache_dir's specified in config file");
     storeVerifySwapDirs();
     storeDirOpenSwapLogs();
@@ -2434,11 +2410,11 @@ storeWriteCleanLogs(void)
     }
     debug(20, 1) ("storeWriteCleanLogs: Starting...\n");
     start = squid_curtime;
-    fd = xcalloc(ncache_dirs, sizeof(int));
-    cur = xcalloc(ncache_dirs, sizeof(char *));
-    new = xcalloc(ncache_dirs, sizeof(char *));
-    cln = xcalloc(ncache_dirs, sizeof(char *));
-    for (dirn = 0; dirn < ncache_dirs; dirn++) {
+    fd = xcalloc(Config.cacheSwap.n_configured, sizeof(int));
+    cur = xcalloc(Config.cacheSwap.n_configured, sizeof(char *));
+    new = xcalloc(Config.cacheSwap.n_configured, sizeof(char *));
+    cln = xcalloc(Config.cacheSwap.n_configured, sizeof(char *));
+    for (dirn = 0; dirn < Config.cacheSwap.n_configured; dirn++) {
 	fd[dirn] = -1;
 	cur[dirn] = xstrdup(storeDirSwapLogFile(dirn, NULL));
 	new[dirn] = xstrdup(storeDirSwapLogFile(dirn, ".clean"));
@@ -2470,7 +2446,7 @@ storeWriteCleanLogs(void)
 	    continue;
 	if (BIT_TEST(e->flag, KEY_PRIVATE))
 	    continue;
-	if ((dirn = storeDirNumber(e->swap_file_number)) >= ncache_dirs) {
+	if ((dirn = storeDirNumber(e->swap_file_number)) >= Config.cacheSwap.n_configured) {
 	    debug_trap("storeWriteCleanLogss: dirn out of range");
 	    continue;
 	}
@@ -2496,7 +2472,7 @@ storeWriteCleanLogs(void)
 	}
     }
     safe_free(line);
-    for (dirn = 0; dirn < ncache_dirs; dirn++) {
+    for (dirn = 0; dirn < Config.cacheSwap.n_configured; dirn++) {
 	file_close(fd[dirn]);
 	fd[dirn] = -1;
 	if (rename(new[dirn], cur[dirn]) < 0) {
@@ -2512,7 +2488,7 @@ storeWriteCleanLogs(void)
     debug(20, 1) ("  Took %d seconds (%6.1lf lines/sec).\n",
 	r > 0 ? r : 0, (double) n / (r > 0 ? r : 1));
     /* touch a timestamp file if we're not still validating */
-    for (dirn = 0; dirn < ncache_dirs; dirn++) {
+    for (dirn = 0; dirn < Config.cacheSwap.n_configured; dirn++) {
 	if (!store_rebuilding)
 	    file_close(file_open(cln[dirn],
 		    O_WRONLY | O_CREAT | O_TRUNC, NULL, NULL));
@@ -2742,7 +2718,6 @@ storeTimestampsSet(StoreEntry * entry)
 
 #define FILENO_STACK_SIZE 128
 static int fileno_stack[FILENO_STACK_SIZE];
-int fileno_stack_count = 0;
 
 static int
 storeGetUnusedFileno(void)
@@ -1,33 +1,55 @@
+
+/*
+ * $Id: store_dir.cc,v 1.24 1997/07/07 05:29:57 wessels Exp $
+ *
+ * DEBUG: section 47    Store Directory Routines
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
+ * --------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from the
+ *  Internet community.  Development is led by Duane Wessels of the
+ *  National Laboratory for Applied Network Research and funded by
+ *  the National Science Foundation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  
+ */
+
 #include "squid.h"
-#include "filemap.h"
-#include "store_dir.h"
 
 #define SWAP_DIR_SHIFT 24
 #define SWAP_FILE_MASK 0x00FFFFFF
 #define DefaultLevelOneDirs     16
 #define DefaultLevelTwoDirs     256
 
-/* GLOBALS */
-int ncache_dirs = 0;
-
-/* LOCALS */
-static int SwapDirsAllocated = 0;
-static SwapDir *SwapDirs = NULL;
-
 /* return full name to swapfile */
 char *
 storeSwapFullPath(int fn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
-    int dirn = (fn >> SWAP_DIR_SHIFT) % ncache_dirs;
+    int dirn = (fn >> SWAP_DIR_SHIFT) % Config.cacheSwap.n_configured;
     int filn = fn & SWAP_FILE_MASK;
     if (!fullpath)
 	fullpath = fullfilename;
     fullpath[0] = '\0';
     sprintf(fullpath, "%s/%02X/%02X/%08X",
-	SwapDirs[dirn].path,
-	filn % SwapDirs[dirn].l1,
-	filn / SwapDirs[dirn].l1 % SwapDirs[dirn].l2,
+	Config.cacheSwap.swapDirs[dirn].path,
+	filn % Config.cacheSwap.swapDirs[dirn].l1,
+	filn / Config.cacheSwap.swapDirs[dirn].l1 % Config.cacheSwap.swapDirs[dirn].l2,
 	filn);
     return fullpath;
 }
@@ -37,71 +59,24 @@ char *
 storeSwapSubSubDir(int fn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
-    int dirn = (fn >> SWAP_DIR_SHIFT) % ncache_dirs;
+    int dirn = (fn >> SWAP_DIR_SHIFT) % Config.cacheSwap.n_configured;
     int filn = fn & SWAP_FILE_MASK;
     if (!fullpath)
 	fullpath = fullfilename;
     fullpath[0] = '\0';
     sprintf(fullpath, "%s/%02X/%02X",
-	SwapDirs[dirn].path,
-	filn % SwapDirs[dirn].l1,
-	filn / SwapDirs[dirn].l1 % SwapDirs[dirn].l2);
+	Config.cacheSwap.swapDirs[dirn].path,
+	filn % Config.cacheSwap.swapDirs[dirn].l1,
+	filn / Config.cacheSwap.swapDirs[dirn].l1 % Config.cacheSwap.swapDirs[dirn].l2);
     return fullpath;
 }
 
-/* add directory to swap disk */
-int
-storeAddSwapDisk(const char *path, int size, int l1, int l2, int read_only)
-{
-    SwapDir *tmp = NULL;
-    int i;
-    if (strlen(path) > (SQUID_MAXPATHLEN - 32))
-	fatal_dump("cache_dir pathname is too long");
-    if (SwapDirs == NULL) {
-	SwapDirsAllocated = 4;
-	SwapDirs = xcalloc(SwapDirsAllocated, sizeof(SwapDir));
-    }
-    if (SwapDirsAllocated == ncache_dirs) {
-	SwapDirsAllocated <<= 1;
-	tmp = xcalloc(SwapDirsAllocated, sizeof(SwapDir));
-	for (i = 0; i < ncache_dirs; i++)
-	    tmp[i] = SwapDirs[i];
-	xfree(SwapDirs);
-	SwapDirs = tmp;
-    }
-    debug(20, 1) ("Creating Swap Dir #%d in %s\n", ncache_dirs + 1, path);
-    tmp = SwapDirs + ncache_dirs;
-    tmp->path = xstrdup(path);
-    tmp->max_size = size;
-    tmp->l1 = l1;
-    tmp->l2 = l2;
-    tmp->read_only = read_only;
-    tmp->map = file_map_create(MAX_FILES_PER_DIR);
-    tmp->swaplog_fd = -1;
-    return ++ncache_dirs;
-}
-
-void
-storeReconfigureSwapDisk(const char *path, int size, int l1, int l2, int read_only)
-{
-    int i;
-    for (i = 0; i < ncache_dirs; i++) {
-	if (!strcmp(path, SwapDirs[i].path))
-	    break;
-    }
-    if (i == ncache_dirs)
-	return;
-    SwapDirs[i].max_size = size;
-    SwapDirs[i].read_only = read_only;
-    /* ignore the rest */
-}
-
 static int
 storeVerifyOrCreateDir(const char *path)
 {
     struct stat sb;
     if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) {
-	debug(20, 3) ("%s exists\n", path);
+	debug(47, 3) ("%s exists\n", path);
 	return 0;
     }
     safeunlink(path, 1);
@@ -113,7 +88,7 @@ storeVerifyOrCreateDir(const char *path)
 	    fatal(tmp_error_buf);
 	}
     }
-    debug(20, 1) ("Created directory %s\n", path);
+    debug(47, 1) ("Created directory %s\n", path);
     if (stat(path, &sb) < 0 || !S_ISDIR(sb.st_mode)) {
 	sprintf(tmp_error_buf,
 	    "Failed to create directory %s: %s", path, xstrerror());
@@ -128,9 +103,9 @@ storeVerifySwapDirs(void)
     int i;
     const char *path = NULL;
     int directory_created = 0;
-    for (i = 0; i < ncache_dirs; i++) {
-	path = SwapDirs[i].path;
-	debug(20, 3) ("storeVerifySwapDirs: Creating swap space in %s\n", path);
+    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+	path = Config.cacheSwap.swapDirs[i].path;
+	debug(47, 3) ("storeVerifySwapDirs: Creating swap space in %s\n", path);
 	storeVerifyOrCreateDir(path);
 	storeCreateSwapSubDirs(i);
     }
@@ -141,13 +116,13 @@ void
 storeCreateSwapSubDirs(int j)
 {
     int i, k;
-    SwapDir *SD = &SwapDirs[j];
+    SwapDir *SD = &Config.cacheSwap.swapDirs[j];
     LOCAL_ARRAY(char, name, MAXPATHLEN);
     for (i = 0; i < SD->l1; i++) {
 	sprintf(name, "%s/%02X", SD->path, i);
 	if (storeVerifyOrCreateDir(name) == 0)
 	    continue;
-	debug(20, 1) ("Making directories in %s\n", name);
+	debug(47, 1) ("Making directories in %s\n", name);
 	for (k = 0; k < SD->l2; k++) {
 	    sprintf(name, "%s/%02X/%02X", SD->path, i, k);
 	    storeVerifyOrCreateDir(name);
@@ -163,8 +138,8 @@ storeMostFreeSwapDir(void)
     int dirn = 0;
     int i;
     SwapDir *SD;
-    for (i = 0; i < ncache_dirs; i++) {
-	SD = &SwapDirs[i];
+    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+	SD = &Config.cacheSwap.swapDirs[i];
 	this_used = (double) SD->cur_size / SD->max_size;
 	if (this_used > least_used)
 	    continue;
@@ -181,43 +156,43 @@ storeDirMapBitTest(int fn)
 {
     int dirn = fn >> SWAP_DIR_SHIFT;
     int filn = fn & SWAP_FILE_MASK;
-    return file_map_bit_test(SwapDirs[dirn].map, filn);
+    return file_map_bit_test(Config.cacheSwap.swapDirs[dirn].map, filn);
 }
 
 void
 storeDirMapBitSet(int fn)
 {
     int dirn = fn >> SWAP_DIR_SHIFT;
     int filn = fn & SWAP_FILE_MASK;
-    file_map_bit_set(SwapDirs[dirn].map, filn);
-    SwapDirs[dirn].suggest++;
+    file_map_bit_set(Config.cacheSwap.swapDirs[dirn].map, filn);
+    Config.cacheSwap.swapDirs[dirn].suggest++;
 }
 
 void
 storeDirMapBitReset(int fn)
 {
     int dirn = fn >> SWAP_DIR_SHIFT;
     int filn = fn & SWAP_FILE_MASK;
-    file_map_bit_reset(SwapDirs[dirn].map, filn);
-    if (fn < SwapDirs[dirn].suggest)
-	SwapDirs[dirn].suggest = fn;
+    file_map_bit_reset(Config.cacheSwap.swapDirs[dirn].map, filn);
+    if (fn < Config.cacheSwap.swapDirs[dirn].suggest)
+	Config.cacheSwap.swapDirs[dirn].suggest = fn;
 }
 
 int
 storeDirMapAllocate(void)
 {
     int dirn = storeMostFreeSwapDir();
-    SwapDir *SD = &SwapDirs[dirn];
+    SwapDir *SD = &Config.cacheSwap.swapDirs[dirn];
     int filn = file_map_allocate(SD->map, SD->suggest);
     return (dirn << SWAP_DIR_SHIFT) | (filn & SWAP_FILE_MASK);
 }
 
 char *
 storeSwapDir(int dirn)
 {
-    if (dirn < 0 || dirn >= ncache_dirs)
+    if (dirn < 0 || dirn >= Config.cacheSwap.n_configured)
 	fatal_dump("storeSwapDir: bad index");
-    return SwapDirs[dirn].path;
+    return Config.cacheSwap.swapDirs[dirn].path;
 }
 
 int
@@ -240,7 +215,7 @@ storeDirSwapLog(const StoreEntry * e)
     if (e->swap_file_number < 0)
 	fatal_dump("storeDirSwapLog: swap_file_number < 0");
     dirn = e->swap_file_number >> SWAP_DIR_SHIFT;
-    assert(dirn < ncache_dirs);
+    assert(dirn < Config.cacheSwap.n_configured);
     /* Note this printf format appears in storeWriteCleanLog() too */
     sprintf(logmsg, "%08x %08x %08x %08x %9d %6d %08x %s\n",
 	(int) e->swap_file_number,
@@ -251,7 +226,7 @@ storeDirSwapLog(const StoreEntry * e)
 	e->refcount,
 	e->flag,
 	e->url);
-    file_write(SwapDirs[dirn].swaplog_fd,
+    file_write(Config.cacheSwap.swapDirs[dirn].swaplog_fd,
 	xstrdup(logmsg),
 	strlen(logmsg),
 	NULL,
@@ -285,15 +260,15 @@ storeDirOpenSwapLogs(void)
     char *path;
     int fd;
     SwapDir *SD;
-    for (i = 0; i < ncache_dirs; i++) {
-	SD = &SwapDirs[i];
+    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+	SD = &Config.cacheSwap.swapDirs[i];
 	path = storeDirSwapLogFile(i, NULL);
 	fd = file_open(path, O_WRONLY | O_CREAT, NULL, NULL);
 	if (fd < 0) {
 	    debug(50, 1) ("%s: %s\n", path, xstrerror());
 	    fatal("storeDirOpenSwapLogs: Failed to open swap log.");
 	}
-	debug(20, 3) ("Cache Dir #%d log opened on FD %d\n", i, fd);
+	debug(47, 3) ("Cache Dir #%d log opened on FD %d\n", i, fd);
 	SD->swaplog_fd = fd;
     }
 }
@@ -303,10 +278,10 @@ storeDirCloseSwapLogs(void)
 {
     int i;
     SwapDir *SD;
-    for (i = 0; i < ncache_dirs; i++) {
-	SD = &SwapDirs[i];
+    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+	SD = &Config.cacheSwap.swapDirs[i];
 	file_close(SD->swaplog_fd);
-	debug(20, 3) ("Cache Dir #%d log closed on FD %d\n", i, SD->swaplog_fd);
+	debug(47, 3) ("Cache Dir #%d log closed on FD %d\n", i, SD->swaplog_fd);
 	SD->swaplog_fd = -1;
     }
 }
@@ -319,11 +294,11 @@ storeDirOpenTmpSwapLog(int dirn, int *clean_flag)
     char *new_path = xstrdup(storeDirSwapLogFile(dirn, ".new"));
     struct stat log_sb;
     struct stat clean_sb;
-    SwapDir *SD = &SwapDirs[dirn];
+    SwapDir *SD = &Config.cacheSwap.swapDirs[dirn];
     FILE *fp;
     int fd;
     if (stat(swaplog_path, &log_sb) < 0) {
-	debug(20, 1) ("Cache Dir #%d: No log file\n", dirn);
+	debug(47, 1) ("Cache Dir #%d: No log file\n", dirn);
 	safe_free(swaplog_path);
 	safe_free(clean_path);
 	safe_free(new_path);
@@ -364,7 +339,7 @@ storeDirCloseTmpSwapLog(int dirn)
 {
     char *swaplog_path = xstrdup(storeDirSwapLogFile(dirn, NULL));
     char *new_path = xstrdup(storeDirSwapLogFile(dirn, ".new"));
-    SwapDir *SD = &SwapDirs[dirn];
+    SwapDir *SD = &Config.cacheSwap.swapDirs[dirn];
     int fd;
     if (rename(new_path, swaplog_path) < 0) {
 	debug(50, 0) ("%s,%s: %s\n", new_path, swaplog_path, xstrerror());
@@ -379,15 +354,15 @@ storeDirCloseTmpSwapLog(int dirn)
     safe_free(swaplog_path);
     safe_free(new_path);
     SD->swaplog_fd = fd;
-    debug(20, 3) ("Cache Dir #%d log opened on FD %d\n", dirn, fd);
+    debug(47, 3) ("Cache Dir #%d log opened on FD %d\n", dirn, fd);
 }
 
 void
 storeDirUpdateSwapSize(int fn, size_t size, int sign)
 {
-    int dirn = (fn >> SWAP_DIR_SHIFT) % ncache_dirs;
+    int dirn = (fn >> SWAP_DIR_SHIFT) % Config.cacheSwap.n_configured;
     int k = ((size + 1023) >> 10) * sign;
-    SwapDirs[dirn].cur_size += k;
+    Config.cacheSwap.swapDirs[dirn].cur_size += k;
     store_swap_size += k;
 }
 
@@ -399,8 +374,8 @@ storeDirStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "Store Directory Statistics:\n");
     storeAppendPrintf(sentry, "Store Entries: %d\n", meta_data.store_entries);
     storeAppendPrintf(sentry, "Store Swap Size: %d KB\n", store_swap_size);
-    for (i = 0; i < ncache_dirs; i++) {
-	SD = &SwapDirs[i];
+    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+	SD = &Config.cacheSwap.swapDirs[i];
 	storeAppendPrintf(sentry, "\n");
 	storeAppendPrintf(sentry, "Store Directory #%d: %s\n", i, SD->path);
 	storeAppendPrintf(sentry, "First level subdirectories: %d\n", SD->l1);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.110 1997/06/21 02:38:18 wessels Exp $
+ * $Id: tools.cc,v 1.111 1997/07/07 05:29:57 wessels Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -324,7 +324,7 @@ shutdownTimeoutHandler(int fd, void *data)
 void
 setSocketShutdownLifetimes(int to)
 {
-    FD_ENTRY *f = NULL;
+    fde *f = NULL;
     int i;
     for (i = Biggest_FD; i >= 0; i--) {
 	f = &fd_table[i];
@@ -1,5 +1,5 @@
 /*
- * $Id: unlinkd.cc,v 1.6 1997/06/04 06:16:15 wessels Exp $
+ * $Id: unlinkd.cc,v 1.7 1997/07/07 05:29:58 wessels Exp $
  *
  * DEBUG: section 43    Unlink Daemon
  * AUTHOR: Duane Wessels
@@ -74,7 +74,6 @@ main(int argc, char *argv[])
 #include "squid.h"
 
 static int unlinkd_fd = -1;
-int unlinkd_count;
 
 static int unlinkdCreate _PARAMS((void));
 