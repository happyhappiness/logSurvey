@@ -1134,7 +1134,7 @@ if test "x${enable_eui:=yes}" = "xyes" ; then
       AC_MSG_WARN([EUI support probably will not work on host $host.])
       ;;
   esac
-  #Iphlpapi.h check delayed after winsock2.h
+  # iphlpapi.h check delayed after winsock2.h
   AC_CHECK_HEADERS( \
     windows.h \
     sys/sockio.h \
@@ -2514,7 +2514,7 @@ if test "x$squid_host_os" = "xmingw" ; then
   AC_CHECK_HEADERS( \
     windows.h \
     ws2tcpip.h \
-    Iphlpapi.h ,,,[
+    iphlpapi.h ,,,[
 #if HAVE_WINDOWS_H
 #include <windows.h>
 #endif
@@ -376,8 +376,6 @@ This section gives an account of those changes in three categories:
 <sect1>New options<label id="newoptions">
 <p>
 <descrip>
-	<p><em>There are no new ./configure options in Squid-3.5.</em>
-
 	<tag>BUILDCXX=</tag>
 	<p>Used when cross-compiling Squid.
 	<p>The path and name of a compiler for building cf_gen and related
@@ -34,7 +34,7 @@ LDADD = \
 	$(XTRA_LIBS)
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir) -I$(top_srcdir)/lib
+AM_CPPFLAGS += -I$(srcdir) -I$(top_srcdir)/lib
 
 
 install-data-local: msntauth.conf.default
@@ -14,4 +14,4 @@ LDADD = \
 	$(XTRA_LIBS)
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 libexec_PROGRAMS = basic_nis_auth
 
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 libexec_PROGRAMS 	= basic_radius_auth
 man_MANS 		= basic_radius_auth.8
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 if ENABLE_WIN32SPECIFIC
 libexec_PROGRAMS = basic_sspi_auth
@@ -46,4 +46,7 @@
 /* send ERR result to Squid with a string parameter. */
 #define SEND_BH(x)	fprintf(stdout, "BH %s\n",x)
 
+/* send TT result to Squid with a string parameter. */
+#define SEND_TT(x)	fprintf(stdout, "TT %s\n",x)
+
 #endif /* __SQUID_HELPERS_DEFINES_H */
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 libexec_PROGRAMS = digest_ldap_auth
 digest_ldap_auth_SOURCES = digest_pw_auth.cc \
@@ -1,8 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
-
+AM_CPPFLAGS += -I$(srcdir)
 
 libexec_PROGRAMS = digest_edirectory_auth
 digest_edirectory_auth_SOURCES = digest_pw_auth.cc \
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 man_MANS = digest_file_auth.8
 libexec_PROGRAMS = digest_file_auth
@@ -4,6 +4,7 @@ libexec_PROGRAMS = ext_lm_group_acl
 ext_lm_group_acl_SOURCES = ext_lm_group_acl.cc
 
 LDADD = \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
@@ -90,7 +90,7 @@ int _wcsicmp(const wchar_t *, const wchar_t *);
 
 int use_global = 0;
 int use_PDC_only = 0;
-char *program_name;
+const char *program_name;
 pid_t mypid;
 char *machinedomain;
 int use_case_insensitive_compare = 0;
@@ -534,12 +534,15 @@ main(int argc, char *argv[])
     }
     debug("External ACL win32 group helper build " __DATE__ ", " __TIME__
           " starting up...\n");
-    if (use_global)
+    if (use_global) {
         debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
-    if (use_case_insensitive_compare)
+    }
+    if (use_case_insensitive_compare) {
         debug("Warning: running in case insensitive mode !!!\n");
-    if (use_PDC_only)
+    }
+    if (use_PDC_only) {
         debug("Warning: using only PDCs for group validation !!!\n");
+    }
 
     /* Main Loop */
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin)) {
@@ -3,7 +3,7 @@ include $(top_srcdir)/src/Common.am
 EXTRA_DIST = README required.m4 cert_tool ext_kerberos_ldap_group_acl.8
 SUBDIRS = 
 
-AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 libexec_SCRIPTS = cert_tool
 
@@ -6,6 +6,7 @@ negotiate_sspi_auth_SOURCES = negotiate_sspi_auth.cc
 
 LDADD	= \
 	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-ladvapi32 \
 	$(XTRA_LIBS)
@@ -37,8 +37,10 @@
  *
  */
 #include "squid.h"
+#include "base64.h"
 #include "helpers/defines.h"
-#include "libntlmauth/support_bits.cci"
+#include "ntlmauth/ntlmauth.h"
+#include "ntlmauth/support_bits.cci"
 #include "sspwin32.h"
 #include "util.h"
 
@@ -135,7 +137,7 @@ manage_request()
     if (fgets(buf, HELPER_INPUT_BUFFER, stdin))
         return 0;
 
-    c = memchr(buf, '\n', HELPER_INPUT_BUFFER);		/* safer against overrun than strchr */
+    c = static_cast<char*>(memchr(buf, '\n', HELPER_INPUT_BUFFER));
     if (c) {
         if (oversized) {
             SEND("BH illegal request received");
@@ -153,13 +155,13 @@ manage_request()
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
         strncpy(helper_command, buf, 2);
         debug("Got '%s' from Squid with data:\n", helper_command);
-        hex_dump(decoded, decodedLen);
+        hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
     } else
         debug("Got '%s' from Squid\n", buf);
 
     if (memcmp(buf, "YR ", 3) == 0) {	/* refresh-request */
         /* figure out what we got */
-        decoded = base64_decode(buf + 3);
+        decodedLen = base64_decode(decoded, sizeof(decoded), buf + 3);
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
             SEND("NA * Packet format error, couldn't base64-decode");
             return 1;
@@ -176,7 +178,7 @@ manage_request()
                     decodedLen = base64_decode(decoded, sizeof(decoded), c);
                     debug("sending 'AF' %s to squid with data:\n", cred);
                     if (c != NULL)
-                        hex_dump(decoded, decodedLen);
+                        hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                     else
                         fprintf(stderr, "No data available.\n");
                     printf("AF %s %s\n", c, cred);
@@ -186,7 +188,7 @@ manage_request()
                 if (Negotiate_packet_debug_enabled) {
                     decodedLen = base64_decode(decoded, sizeof(decoded), c);
                     debug("sending 'TT' to squid with data:\n");
-                    hex_dump(decoded, decodedLen);
+                    hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                     printf("TT %s\n", c);
                 } else {
                     SEND2("TT %s", c);
@@ -236,7 +238,7 @@ manage_request()
                 decodedLen = base64_decode(decoded, sizeof(decoded), c);
                 debug("sending 'AF' %s to squid with data:\n", cred);
                 if (c != NULL)
-                    hex_dump(decoded, decodedLen);
+                    hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                 else
                     fprintf(stderr, "No data available.\n");
                 printf("AF %s %s\n", c, cred);
@@ -248,7 +250,7 @@ manage_request()
             if (Negotiate_packet_debug_enabled) {
                 decodedLen = base64_decode(decoded, sizeof(decoded), c);
                 debug("sending 'TT' to squid with data:\n");
-                hex_dump(decoded, decodedLen);
+                hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                 printf("TT %s\n", c);
             } else
                 SEND2("TT %s", c);
@@ -5,7 +5,7 @@ SUBDIRS =
 
 libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
 
-AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc negotiate_kerberos_pac.cc negotiate_kerberos.h
 negotiate_kerberos_auth_LDFLAGS = 
@@ -1 +1 @@
-BUILD_HELPER="wrapper"
+AC_CHECK_FUNCS(vfork,[BUILD_HELPER="wrapper"])
@@ -9,6 +9,7 @@ ntlm_sspi_auth_SOURCES = ntlm_sspi_auth.cc
 LDADD = \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
@@ -61,12 +61,13 @@
 
 /************* END CONFIGURATION ***************/
 
-typedef unsigned char uchar;
+//typedef unsigned char uchar;
 
 #include "squid.h"
+#include "base64.h"
 #include "helpers/defines.h"
-#include "libntlmauth/ntlmauth.h"
-#include "libntlmauth/support_bits.h"
+#include "ntlmauth/ntlmauth.h"
+#include "ntlmauth/support_bits.cci"
 #include "sspwin32.h"
 #include "util.h"
 
@@ -82,8 +83,6 @@ typedef unsigned char uchar;
 #include <lm.h>
 #include <ntsecapi.h>
 
-#define BUFFER_SIZE 10240
-
 int NTLM_packet_debug_enabled = 0;
 static int have_challenge;
 char * NTAllowedGroup;
@@ -272,10 +271,10 @@ char * GetDomainName(void)
     return DomainName;
 }
 
-/* returns NULL on failure, or a pointer to
- * the user's credentials (domain\\username)
- * upon success. WARNING. It's pointing to static storage.
- * In case of problem sets as side-effect ntlm_errno to one of the
+/*
+ * Fills auth with the user's credentials.
+ *
+ * In case of problem returns one of the
  * codes defined in libntlmauth/ntlmauth.h
  */
 int
@@ -284,7 +283,6 @@ ntlm_check_auth(ntlm_authenticate * auth, char *user, char *domain, int auth_len
     int x;
     int rv;
     char credentials[DNLEN+UNLEN+2];	/* we can afford to waste */
-    lstring tmp;
 
     if (!NTLM_LocalCall) {
 
@@ -341,7 +339,7 @@ helperfail(const char *reason)
 #if FAIL_DEBUG
     fail_debug_enabled =1;
 #endif
-    SEND2("BH %s", reason);
+    SEND_BH(reason);
 }
 
 /*
@@ -411,11 +409,10 @@ int
 manage_request()
 {
     ntlmhdr *fast_header;
-    char buf[BUFFER_SIZE];
-    char decoded[BUFFER_SIZE];
+    char buf[HELPER_INPUT_BUFFER];
+    char decoded[HELPER_INPUT_BUFFER];
     int decodedLen;
     char helper_command[3];
-    char *c, *cred;
     int oversized = 0;
     char * ErrorMessage;
     static ntlm_negotiate local_nego;
@@ -424,38 +421,40 @@ manage_request()
 
     /* NP: for some reason this helper sometimes needs to accept
      * from clients that send no negotiate packet. */
-    if (memcpy(local_nego.signature, "NTLMSSP", 8) != 0) {
+    if (memcpy(local_nego.hdr.signature, "NTLMSSP", 8) != 0) {
         memset(&local_nego, 0, sizeof(ntlm_negotiate));	/* reset */
-        memcpy(local_nego.signature, "NTLMSSP", 8);     /* set the signature */
-        local_nego.type = le32toh(NTLM_NEGOTIATE);      /* this is a challenge */
+        memcpy(local_nego.hdr.signature, "NTLMSSP", 8);     /* set the signature */
+        local_nego.hdr.type = le32toh(NTLM_NEGOTIATE);      /* this is a challenge */
         local_nego.flags = le32toh(NTLM_NEGOTIATE_ALWAYS_SIGN |
                                    NTLM_NEGOTIATE_USE_NTLM |
                                    NTLM_NEGOTIATE_USE_LM |
                                    NTLM_NEGOTIATE_ASCII );
     }
 
-try_again:
-    if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
-        return 0;
+    do {
+        if (fgets(buf, sizeof(buf), stdin) == NULL)
+            return 0;
 
-    c = memchr(buf, '\n', BUFFER_SIZE);	/* safer against overrun than strchr */
-    if (c) {
-        if (oversized) {
-            helperfail("illegal request received");
-            fprintf(stderr, "Illegal request received: '%s'\n", buf);
-            return 1;
+        char *c = static_cast<char*>(memchr(buf, '\n', sizeof(buf)));
+        if (c) {
+            if (oversized) {
+                helperfail("messge=\"illegal request received\"");
+                fprintf(stderr, "Illegal request received: '%s'\n", buf);
+                return 1;
+            }
+            *c = '\0';
+        } else {
+            fprintf(stderr, "No newline in '%s'\n", buf);
+            oversized = 1;
+            continue;
         }
-        *c = '\0';
-    } else {
-        fprintf(stderr, "No newline in '%s'\n", buf);
-        oversized = 1;
-        goto try_again;
-    }
+    } while (false);
+
     if ((strlen(buf) > 3) && NTLM_packet_debug_enabled) {
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
         strncpy(helper_command, buf, 2);
         debug("Got '%s' from Squid with data:\n", helper_command);
-        hex_dump(decoded, decodedLen);
+        hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
     } else
         debug("Got '%s' from Squid\n", buf);
     if (memcmp(buf, "YR", 2) == 0) {	/* refresh-request */
@@ -464,102 +463,102 @@ manage_request()
             decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
         else {
             debug("Negotiate packet not supplied - self generated\n");
-            memcpy(decoded, local_lego, sizeof(local_nego));
-            decodedLen = sizeof(localnego);
+            memcpy(decoded, &local_nego, sizeof(local_nego));
+            decodedLen = sizeof(local_nego);
         }
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
-            SEND("NA Packet format error, couldn't base64-decode");
+            SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
             return 1;
         }
         /* fast-track-decode request type. */
         fast_header = (struct _ntlmhdr *) decoded;
 
         /* sanity-check: it IS a NTLMSSP packet, isn't it? */
         if (ntlm_validate_packet(fast_header, NTLM_ANY) != NTLM_ERR_NONE) {
-            SEND("NA Broken authentication packet");
+            SEND_ERR("message=\"Broken authentication packet\"");
             return 1;
         }
         switch (fast_header->type) {
-        case NTLM_NEGOTIATE:
+        case NTLM_NEGOTIATE: {
             /* Obtain challenge against SSPI */
             debug("attempting SSPI challenge retrieval\n");
-            if ((c = (char *) SSP_MakeChallenge((ntlm_negotiate *) decoded, decodedLen)) != NULL ) {
+            char *c = (char *) SSP_MakeChallenge((ntlm_negotiate *) decoded, decodedLen);
+            if (c) {
+                SEND_TT(c);
                 if (NTLM_packet_debug_enabled) {
-                    printf("TT %s\n",c);
                     decodedLen = base64_decode(decoded, sizeof(decoded), c);
-                    debug("sending 'TT' to squid with data:\n");
-                    hex_dump(decoded, decodedLen);
-                    if (NTLM_LocalCall)
+                    debug("send 'TT' to squid with data:\n");
+                    hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
+                    if (NTLM_LocalCall) {
                         debug("NTLM Local Call detected\n");
-                } else {
-                    SEND2("TT %s", c);
+                    }
                 }
                 have_challenge = 1;
             } else
-                helperfail("can't obtain challenge");
+                helperfail("message=\"can't obtain challenge\"");
 
             return 1;
-            /* notreached */
+        }
+        /* notreached */
         case NTLM_CHALLENGE:
-            SEND("NA Got a challenge. We refuse to have our authority disputed");
+            SEND_ERR("message=\"Got a challenge. We refuse to have our authority disputed\"");
             return 1;
             /* notreached */
         case NTLM_AUTHENTICATE:
-            SEND("NA Got authentication request instead of negotiate request");
+            SEND_ERR("message=\"Got authentication request instead of negotiate request\"");
             return 1;
             /* notreached */
         default:
-            helperfail("unknown refresh-request packet type");
+            helperfail("message=\"unknown refresh-request packet type\"");
             return 1;
         }
         return 1;
     }
     if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
         if (!have_challenge) {
-            helperfail("invalid challenge");
+            helperfail("message=\"invalid challenge\"");
             return 1;
         }
         /* figure out what we got */
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
 
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
-            SEND("NA Packet format error, couldn't base64-decode");
+            SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
             return 1;
         }
         /* fast-track-decode request type. */
         fast_header = (struct _ntlmhdr *) decoded;
 
         /* sanity-check: it IS a NTLMSSP packet, isn't it? */
         if (ntlm_validate_packet(fast_header, NTLM_ANY) != NTLM_ERR_NONE) {
-            SEND("NA Broken authentication packet");
+            SEND_ERR("message=\"Broken authentication packet\"");
             return 1;
         }
         switch (fast_header->type) {
         case NTLM_NEGOTIATE:
-            SEND("NA Invalid negotiation request received");
+            SEND_ERR("message=\"Invalid negotiation request received\"");
             return 1;
             /* notreached */
         case NTLM_CHALLENGE:
-            SEND
-            ("NA Got a challenge. We refuse to have our authority disputed");
+            SEND_ERR("message=\"Got a challenge. We refuse to have our authority disputed\"");
             return 1;
             /* notreached */
-        case NTLM_AUTHENTICATE:
+        case NTLM_AUTHENTICATE: {
             /* check against SSPI */
-            err = ntlm_check_auth((ntlm_authenticate *) decoded, user, domain, decodedLen);
+            int err = ntlm_check_auth((ntlm_authenticate *) decoded, user, domain, decodedLen);
             have_challenge = 0;
             if (err != NTLM_ERR_NONE) {
 #if FAIL_DEBUG
                 fail_debug_enabled =1;
 #endif
-                switch (ntlm_errno) {
+                switch (err) {
                 case NTLM_ERR_NONE:
                     break;
                 case NTLM_BAD_NTGROUP:
-                    SEND("NA Incorrect Group Membership");
+                    SEND_ERR("message=\"Incorrect Group Membership\"");
                     return 1;
                 case NTLM_BAD_REQUEST:
-                    SEND("NA Incorrect Request Format");
+                    SEND_ERR("message=\"Incorrect Request Format\"");
                     return 1;
                 case NTLM_SSPI_ERROR:
                     FormatMessage(
@@ -576,28 +575,31 @@ manage_request()
                         ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
                     if (ErrorMessage[strlen(ErrorMessage) - 1] == '\r')
                         ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
-                    SEND2("NA %s", ErrorMessage);
+                    SEND_ERR(ErrorMessage); // TODO update to new syntax
                     LocalFree(ErrorMessage);
                     return 1;
                 default:
-                    SEND("NA Unknown Error");
+                    SEND_ERR("message=\"Unknown Error\"");
                     return 1;
                 }
             }
             /* let's lowercase them for our convenience */
-            SEND3("AF %s\\%s", lc(domain), lc(user));
+            lc(domain);
+            lc(user);
+            fprintf(stdout, "OK user=\"%s\\%s\"", domain, user);
             return 1;
+        }
         default:
-            helperfail("unknown authentication packet type");
+            helperfail("message=\"unknown authentication packet type\"");
             return 1;
         }
         return 1;
     } else {	/* not an auth-request */
-        helperfail("illegal request received");
+        helperfail("message=\"illegal request received\"");
         fprintf(stderr, "Illegal request received: '%s'\n", buf);
         return 1;
     }
-    helperfail("detected protocol error");
+    helperfail("message=\"detected protocol error\"");
     return 1;
     /********* END ********/
 }
@@ -11,7 +11,7 @@ ntlm_fake_auth_LDADD = \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-INCLUDES += -I$(top_srcdir)/lib
+AM_CPPFLAGS += -I$(top_srcdir)/lib
 
 ## Demo using perl.
 ## ntlm_fake_auth.pl: ntlm_fake_auth.pl.in
@@ -13,6 +13,6 @@ ntlm_smb_lm_auth_LDADD = \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-INCLUDES += -I$(top_srcdir)/lib
+AM_CPPFLAGS += -I$(top_srcdir)/lib
 
 EXTRA_DIST = required.m4
@@ -70,7 +70,7 @@ extern "C" {
 
     HMODULE LoadSecurityDll(int, const char *);
     void UnloadSecurityDll(void);
-    BOOL WINAPI SSP_LogonUser(unsigned char *, unsigned char *, unsigned char *);
+    BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
     BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
     const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
     const char * WINAPI SSP_MakeChallenge(PVOID, int);
@@ -1,10 +1,10 @@
 include $(top_srcdir)/src/Common.am
 
-INCLUDES += -I$(top_srcdir)/include
+AM_CPPFLAGS += -I$(top_srcdir)/include
 
 TESTS += trie
 
 check_PROGRAMS += trie
 
 trie_SOURCES = trie.cc
-trie_LDADD = $(top_builddir)/lib/libTrie/libTrie.a
\ No newline at end of file
+trie_LDADD = $(top_builddir)/lib/libTrie/libTrie.a
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
-INCLUDES += -I$(top_srcdir)/lib
+AM_CPPFLAGS += -I$(top_srcdir)/lib
 
 noinst_LTLIBRARIES = libntlmauth.la
 
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-INCLUDES += -I$(top_srcdir)/lib
+AM_CPPFLAGS += -I$(top_srcdir)/lib
 
 noinst_LTLIBRARIES = librfcnb.la
 
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-INCLUDES += -I$(top_srcdir)/lib
+AM_CPPFLAGS += -I$(top_srcdir)/lib
 
 noinst_LTLIBRARIES = libsmblib.la
 
@@ -4,17 +4,17 @@
 ## 
 AM_CFLAGS = $(SQUID_CFLAGS)
 AM_CXXFLAGS = $(SQUID_CXXFLAGS)
+AM_CPPFLAGS = \
+	-I$(top_srcdir) \
+	-I$(top_builddir)/include \
+	-I$(top_srcdir)/include
+
 noinst_LTLIBRARIES = libsnmplib.la
 libsnmplib_la_SOURCES  = asn1.c parse.c snmp_vars.c \
 	coexistance.c snmp_api.c snmp_error.c  \
 	mib.c snmp_api_error.c   \
 	snmp_msg.c \
 	snmp_pdu.c  snmplib_debug.c
 
-INCLUDES = \
-	-I$(top_srcdir) \
-	-I$(top_builddir)/include \
-	-I$(top_srcdir)/include
-
 VERSION		= 3.4
 DEFS		= -DSQUID_SNMP=1
@@ -60,5 +60,4 @@ AccessLogEntry::~AccessLogEntry()
     HTTPMSGUNLOCK(icap.reply);
     HTTPMSGUNLOCK(icap.request);
 #endif
-    cbdataReferenceDone(cache.port);
 }
@@ -185,7 +185,7 @@ class AccessLogEntry: public RefCountable
         const char *ssluser;
         Ssl::X509_Pointer sslClientCert; ///< cert received from the client
 #endif
-        AnyP::PortCfg *port;
+        AnyP::PortCfgPointer port;
 
     } cache;
 
@@ -1,4 +1,5 @@
 #include "squid.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "CommCalls.h"
 #include "fde.h"
@@ -13,7 +13,7 @@ CLEANFILES =
 check_PROGRAMS = 
 TESTS =
 
-INCLUDES = \
+AM_CPPFLAGS = \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/lib \
@@ -23,12 +23,12 @@ INCLUDES = \
 
 ## Kerberos headers require their include path.
 ## Because we use libcompat for comm_err.h header protections ...
-INCLUDES += $(KRB5INCS)
+AM_CPPFLAGS += $(KRB5INCS)
 
 ## Loadable Modules requires LTDL include paths.
 ## Because we need this to use the libray linking headers...
 if ENABLE_LOADABLE_MODULES
-INCLUDES += $(INCLTDL)
+AM_CPPFLAGS += $(INCLTDL)
 endif
 
 ## make all compiled sources depend on generated files
@@ -825,6 +825,20 @@ FwdState::connectStart()
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = true;
             comm_add_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
+
+            /* Update server side TOS and Netfilter mark on the connection. */
+            if (Ip::Qos::TheConfig.isAclTosActive()) {
+                debugs(17, 3, HERE << "setting tos for pinned connection to " << (int)serverConn->tos );
+                serverConn->tos = GetTosToServer(request);
+                Ip::Qos::setSockTos(serverConn, serverConn->tos);
+            }
+#if SO_MARK
+            if (Ip::Qos::TheConfig.isAclNfmarkActive()) {
+                serverConn->nfmark = GetNfmarkToServer(request);
+                Ip::Qos::setSockNfmark(serverConn, serverConn->nfmark);
+            }
+#endif
+
             // the server may close the pinned connection before this request
             pconnRace = racePossible;
             dispatch();
@@ -234,7 +234,7 @@ cf_gen_LDADD=
 cf_gen.$(OBJEXT): cf_gen_defines.cci
 
 ## cf_gen.cc needs src/cf_gen_defines.cci
-INCLUDES += -I$(top_builddir)/src
+AM_CPPFLAGS += -I$(top_builddir)/src
 
 
 ACL_REGISTRATION_SOURCES = AclRegs.cc AuthReg.cc
@@ -686,11 +686,11 @@ squid_LDFLAGS = -export-dynamic -dlopen force
 ## squid_LDFLAGS = -all-static -dlopen self
 ##
 ## LTDL headers require their local include path...
-INCLUDES += $(INCLTDL)
+AM_CPPFLAGS += $(INCLTDL)
 endif
 
 ## Kerberos libraries require their include path...
-INCLUDES += $(KRB5INCS)
+AM_CPPFLAGS += $(KRB5INCS)
 
 
 unlinkd_SOURCES = unlinkd_daemon.cc
@@ -1148,6 +1148,8 @@ tests_testHttpReply_SOURCES=\
 	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	tests/stub_mem.cc \
 	RegexList.h \
@@ -1174,11 +1176,17 @@ tests_testHttpReply_SOURCES=\
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_comm.cc \
 	tests/stub_debug.cc \
 	tests/stub_errorpage.cc \
+	tests/stub_event.cc \
+	tests/stub_fd.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libauth.cc \
+	tests/stub_libcomm.cc \
+	tests/stub_libmgr.cc \
+	tests/stub_libsslsquid.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -1200,14 +1208,15 @@ nodist_tests_testHttpReply_SOURCES=\
 	$(TESTSOURCES)
 tests_testHttpReply_LDFLAGS = $(LIBADD_DL)
 tests_testHttpReply_LDADD=\
+	CommCalls.o \
 	http/libsquid-http.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	anyp/libanyp.la \
 	ip/libip.la \
 	base/libbase.la \
-	$(SSL_LIBS) \
+	ipc/libipc.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -1369,12 +1378,14 @@ tests_testBoilerplate_SOURCES = \
 	tests/testBoilerplate.cc \
 	tests/testMain.cc \
 	tests/testBoilerplate.h \
+	tests/stub_debug.cc \
 	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	$(TESTSOURCES)
 tests_testBoilerplate_LDADD= \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
+	base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testBoilerplate_LDFLAGS = $(LIBADD_DL)
@@ -1787,14 +1798,14 @@ tests_testDiskIO_LDADD = \
 	acl/libstate.la \
 	libsquid.la \
 	comm/libcomm.la \
-	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
+	anyp/libanyp.la \
 	mgr/libmgr.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
@@ -2955,6 +2966,7 @@ tests_testStore_SOURCES= \
 	tests/stub_libauth.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
+	tests/stub_libsslsquid.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	tests/stub_HttpReply.cc \
@@ -3009,7 +3021,6 @@ tests_testStore_LDADD= \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
-	$(SSL_LIBS) \
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -3418,7 +3429,6 @@ tests_testRock_LDADD = \
 	http/libsquid-http.la \
 	libsquid.la \
 	comm/libcomm.la \
-	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(COMMON_LIBS) \
@@ -3428,6 +3438,7 @@ tests_testRock_LDADD = \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
+	anyp/libanyp.la \
 	eui/libeui.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
@@ -3441,7 +3452,7 @@ tests_testRock_LDADD = \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
-tests_testRock_LDFLAGS = $(INCLUDES) $(LIBADD_DL)
+tests_testRock_LDFLAGS = $(AM_CPPFLAGS) $(LIBADD_DL)
 tests_testRock_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
@@ -2,7 +2,6 @@
 #define SQUID_SRC_MASTERXACTION_H
 
 #include "anyp/forward.h"
-#include "base/CbcPointer.h"
 #include "base/InstanceId.h"
 #include "base/Lock.h"
 #include "comm/forward.h"
@@ -136,12 +136,6 @@ class SquidConfig
 #endif
     } Port;
 
-    struct {
-        AnyP::PortCfg *http;
-#if USE_OPENSSL
-        AnyP::PortCfg *https;
-#endif
-    } Sockaddr;
 #if SQUID_SNMP
 
     struct {
@@ -510,7 +510,7 @@ int WIN32_Subsystem_Init(int * argc, char *** argv)
             return 1;
 
         /* Register the service Handler function */
-        svcHandle = RegisterServiceCtrlHandler(service_name, WIN32_svcHandler);
+        svcHandle = RegisterServiceCtrlHandler(service_name.c_str(), WIN32_svcHandler);
 
         if (svcHandle == 0)
             return 1;
@@ -671,12 +671,13 @@ WIN32_RemoveService()
     SC_HANDLE schService;
     SC_HANDLE schSCManager;
 
-    if (!service_name)
-        service_name = xstrdup(APP_SHORTNAME);
+    if (service_name.isEmpty())
+        service_name = SBuf(APP_SHORTNAME);
 
-    strcat(REGKEY, service_name);
+    const char *service =  service_name.c_str();
+    strcat(REGKEY, service);
 
-    keys[4] = service_name;
+    keys[4] = service;
 
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
@@ -686,7 +687,7 @@ WIN32_RemoveService()
     if (!schSCManager)
         fprintf(stderr, "OpenSCManager failed\n");
     else {
-        schService = OpenService(schSCManager, service_name, SERVICE_ALL_ACCESS);
+        schService = OpenService(schSCManager, service, SERVICE_ALL_ACCESS);
 
         if (schService == NULL)
             fprintf(stderr, "OpenService failed\n");
@@ -711,7 +712,7 @@ WIN32_RemoveService()
             if (DeleteService(schService) == 0)
                 fprintf(stderr, "DeleteService failed.\n");
             else
-                printf("Service %s deleted successfully.\n", service_name);
+                printf("Service " SQUIDSBUFPH " deleted successfully.\n", SQUIDSBUFPRINT(service_name));
 
             CloseServiceHandle(schService);
         }
@@ -723,12 +724,13 @@ WIN32_RemoveService()
 void
 WIN32_SetServiceCommandLine()
 {
-    if (!service_name)
-        service_name = xstrdup(APP_SHORTNAME);
+    if (service_name.isEmpty())
+        service_name = SBuf(APP_SHORTNAME);
 
-    strcat(REGKEY, service_name);
+    const char *service = servie_name.c_str();
+    strcat(REGKEY, service);
 
-    keys[4] = service_name;
+    keys[4] = service;
 
     /* Now store the Service Command Line in the registry */
     WIN32_StoreKey(COMMANDLINE, REG_SZ, (unsigned char *) WIN32_Command_Line, strlen(WIN32_Command_Line) + 1);
@@ -743,19 +745,20 @@ WIN32_InstallService()
     char szPath[512];
     int lenpath;
 
-    if (!service_name)
-        service_name = xstrdup(APP_SHORTNAME);
+    if (service_name.isEmpty())
+        service_name = SBuf(APP_SHORTNAME);
 
-    strcat(REGKEY, service_name);
+    const char *service = service_name.c_str();
+    strcat(REGKEY, service);
 
-    keys[4] = service_name;
+    keys[4] = service;
 
     if ((lenpath = GetModuleFileName(NULL, ServicePath, 512)) == 0) {
         fprintf(stderr, "Can't get executable path\n");
         exit(1);
     }
 
-    snprintf(szPath, sizeof(szPath), "%s %s:%s", ServicePath, _WIN_SQUID_SERVICE_OPTION, service_name);
+    snprintf(szPath, sizeof(szPath), "%s %s:" SQUIDSBUFPH, ServicePath, _WIN_SQUID_SERVICE_OPTION, SQUIDSBUFPRINT(service_name));
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
                                  SC_MANAGER_ALL_ACCESS	/* access required            */
@@ -766,8 +769,8 @@ WIN32_InstallService()
         exit(1);
     } else {
         schService = CreateService(schSCManager,    /* SCManager database     */
-                                   service_name,			    /* name of service        */
-                                   service_name,			    /* name to display        */
+                                   service,			    /* name of service        */
+                                   service,			    /* name to display        */
                                    SERVICE_ALL_ACCESS,			    /* desired access         */
                                    SERVICE_WIN32_OWN_PROCESS,		    /* service type           */
                                    SERVICE_AUTO_START,			    /* start type             */
@@ -801,7 +804,7 @@ WIN32_InstallService()
             WIN32_StoreKey(CONFIGFILE, REG_SZ, (unsigned char *) ConfigFile, strlen(ConfigFile) + 1);
 
             printf("Squid Cache version %s for %s\n", version_string, CONFIG_HOST_TYPE);
-            printf("installed successfully as %s Windows System Service.\n", service_name);
+            printf("installed successfully as " SQUIDSBUFPH " Windows System Service.\n", SQUIDSBUFPRINT(service_name));
             printf("To run, start it from the Services Applet of Control Panel.\n");
             printf("Don't forget to edit squid.conf before starting it.\n\n");
         } else {
@@ -821,8 +824,8 @@ WIN32_sendSignal(int WIN32_signal)
     SC_HANDLE schService;
     SC_HANDLE schSCManager;
 
-    if (!service_name)
-        service_name = xstrdup(APP_SHORTNAME);
+    if (service_name.isEmpty())
+        service_name = SBuf(APP_SHORTNAME);
 
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
@@ -875,24 +878,24 @@ WIN32_sendSignal(int WIN32_signal)
 
     /* Open a handle to the service. */
     schService = OpenService(schSCManager,	/* SCManager database */
-                             service_name,	/* name of service    */
+                             service_name.c_str(),	/* name of service    */
                              fdwAccess);		/* specify access     */
 
     if (schService == NULL) {
-        fprintf(stderr, "%s: ERROR: Could not open Service %s\n", APP_SHORTNAME, service_name);
+        fprintf(stderr, "%s: ERROR: Could not open Service " SQUIDSBUFPH "\n", APP_SHORTNAME, SQUIDSBUFPRINT(service_name));
         exit(1);
     } else {
         /* Send a control value to the service. */
 
         if (!ControlService(schService,	/* handle of service      */
                             fdwControl,	/* control value to send  */
                             &ssStatus)) {	/* address of status info */
-            fprintf(stderr, "%s: ERROR: Could not Control Service %s\n",
-                    APP_SHORTNAME, service_name);
+            fprintf(stderr, "%s: ERROR: Could not Control Service " SQUIDSBUFPH "\n",
+                    APP_SHORTNAME, SQUIDSBUFPRINT(service_name));
             exit(1);
         } else {
             /* Print the service status. */
-            printf("\nStatus of %s Service:\n", service_name);
+            printf("\nStatus of " SQUIDSBUFPH " Service:\n", SQUIDSBUFPRINT(service_name));
             printf("  Service Type: 0x%lx\n", ssStatus.dwServiceType);
             printf("  Current State: 0x%lx\n", ssStatus.dwCurrentState);
             printf("  Controls Accepted: 0x%lx\n", ssStatus.dwControlsAccepted);
@@ -931,10 +934,11 @@ int main(int argc, char **argv)
             return 1;
         }
 
-        service_name = xstrdup(c+1);
-        DispatchTable[0].lpServiceName=service_name;
-        strcat(REGKEY, service_name);
-        keys[4] = service_name;
+        service_name = SBuf(c+1);
+        const char *service = service_name.c_str();
+        DispatchTable[0].lpServiceName=service;
+        strcat(REGKEY, service);
+        keys[4] = service;
 
         if (!StartServiceCtrlDispatcher(DispatchTable)) {
             fprintf(stderr, "StartServiceCtrlDispatcher error = %ld\n",
@@ -225,8 +225,8 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 
     // Is this ACL going to work?
     if (strcmp(theType, "myip") == 0) {
-        AnyP::PortCfg *p = Config.Sockaddr.http;
-        while (p) {
+        AnyP::PortCfgPointer p = HttpPortList;
+        while (p != NULL) {
             // Bug 3239: not reliable when there is interception traffic coming
             if (p->flags.natIntercept)
                 debugs(28, DBG_CRITICAL, "WARNING: 'myip' ACL is not reliable for interception proxies. Please use 'myportname' instead.");
@@ -235,8 +235,8 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myip' type is has been renamed to 'localip' and matches the IP the client connected to.");
         theType = "localip";
     } else if (strcmp(theType, "myport") == 0) {
-        AnyP::PortCfg *p = Config.Sockaddr.http;
-        while (p) {
+        AnyP::PortCfgPointer p = HttpPortList;
+        while (p != NULL) {
             // Bug 3239: not reliable when there is interception traffic coming
             // Bug 3239: myport - not reliable (yet) when there is interception traffic coming
             if (p->flags.natIntercept)
@@ -9,13 +9,16 @@
 #include <cstring>
 #include <limits>
 
-CBDATA_NAMESPACED_CLASS_INIT(AnyP, PortCfg);
+AnyP::PortCfgPointer HttpPortList;
+#if USE_OPENSSL
+AnyP::PortCfgPointer HttpsPortList;
+#endif
 
 int NHttpSockets = 0;
 int HttpSockets[MAXTCPLISTENPORTS];
 
 AnyP::PortCfg::PortCfg() :
-        next(NULL),
+        next(),
         s(),
         transport(AnyP::PROTO_HTTP,1,1), // "Squid is an HTTP proxy", etc.
         name(NULL),
@@ -84,10 +87,10 @@ AnyP::PortCfg::~PortCfg()
 #endif
 }
 
-AnyP::PortCfg *
+AnyP::PortCfgPointer
 AnyP::PortCfg::clone() const
 {
-    AnyP::PortCfg *b = new AnyP::PortCfg();
+    AnyP::PortCfgPointer b = new AnyP::PortCfg();
     b->s = s;
     if (name)
         b->name = xstrdup(name);
@@ -13,12 +13,12 @@
 namespace AnyP
 {
 
-class PortCfg
+class PortCfg : public RefCountable
 {
 public:
     PortCfg();
     ~PortCfg();
-    AnyP::PortCfg *clone() const;
+    AnyP::PortCfgPointer clone() const;
 #if USE_OPENSSL
     /// creates, configures, and validates SSL context and related port options
     void configureSslServerContext();
@@ -31,7 +31,7 @@ class PortCfg
      */
     void setTransport(const char *aProtocol);
 
-    PortCfg *next;
+    PortCfgPointer next;
 
     Ip::Address s;
     AnyP::ProtocolVersion transport; ///< transport protocol and version received by this port
@@ -94,12 +94,18 @@ class PortCfg
     long sslContextFlags; ///< flags modifying the use of SSL
     long sslOptions; ///< SSL engine options
 #endif
-
-    CBDATA_CLASS2(PortCfg); // namespaced
 };
 
 } // namespace AnyP
 
+/// list of Squid http_port configured
+extern AnyP::PortCfgPointer HttpPortList;
+
+#if USE_OPENSSL
+/// list of Squid https_port configured
+extern AnyP::PortCfgPointer HttpsPortList;
+#endif
+
 // Max number of TCP listening ports
 #define MAXTCPLISTENPORTS 128
 
@@ -1,13 +1,13 @@
 #ifndef _SQUID_SRC_ANYP_FORWARD_H
 #define _SQUID_SRC_ANYP_FORWARD_H
 
-#include "base/CbcPointer.h"
+#include "base/RefCount.h"
 
 namespace AnyP
 {
 
 class PortCfg;
-typedef CbcPointer<PortCfg> PortCfgPointer;
+typedef RefCount<PortCfg> PortCfgPointer;
 
 class UriScheme;
 
@@ -228,10 +228,10 @@ static int check_null_IpAddress_list(const Ip::Address_list *);
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
-static void parsePortCfg(AnyP::PortCfg **, const char *protocol);
+static void parsePortCfg(AnyP::PortCfgPointer *, const char *protocol);
 #define parse_PortCfg(l) parsePortCfg((l), token)
-static void dump_PortCfg(StoreEntry *, const char *, const AnyP::PortCfg *);
-static void free_PortCfg(AnyP::PortCfg **);
+static void dump_PortCfg(StoreEntry *, const char *, const AnyP::PortCfgPointer &);
+#define free_PortCfg(h)  *(h)=NULL
 
 #if USE_OPENSSL
 static void parse_sslproxy_cert_sign(sslproxy_cert_sign **cert_sign);
@@ -358,7 +358,7 @@ SubstituteMacro(char*& line, int& len, const char* macroName, const char* substS
 static void
 ProcessMacros(char*& line, int& len)
 {
-    SubstituteMacro(line, len, "${service_name}", service_name);
+    SubstituteMacro(line, len, "${service_name}", service_name.c_str());
     SubstituteMacro(line, len, "${process_name}", TheKidName);
     SubstituteMacro(line, len, "${process_number}", xitoa(KidIdentifier));
 }
@@ -911,15 +911,15 @@ configDoConfigure(void)
         }
     }
 
-    for (AnyP::PortCfg *s = Config.Sockaddr.http; s != NULL; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (!s->flags.tunnelSslBumping)
             continue;
 
         debugs(3, DBG_IMPORTANT, "Initializing http_port " << s->s << " SSL context");
         s->configureSslServerContext();
     }
 
-    for (AnyP::PortCfg *s = Config.Sockaddr.https; s != NULL; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
         debugs(3, DBG_IMPORTANT, "Initializing https_port " << s->s << " SSL context");
         s->configureSslServerContext();
     }
@@ -1463,6 +1463,12 @@ parse_acl_tos(acl_tos ** head)
         return;
     }
 
+    const unsigned int chTos = tos & 0xFC;
+    if (chTos != tos) {
+        debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: Tos value '" << tos << "' adjusted to '" << chTos << "'");
+        tos = chTos;
+    }
+
     CBDATA_INIT_TYPE_FREECB(acl_tos, freed_acl_tos);
 
     l = cbdataAlloc(acl_tos);
@@ -3484,7 +3490,7 @@ check_null_IpAddress_list(const Ip::Address_list * s)
 #endif /* USE_WCCPv2 */
 
 static void
-parsePortSpecification(AnyP::PortCfg * s, char *token)
+parsePortSpecification(const AnyP::PortCfgPointer &s, char *token)
 {
     char *host = NULL;
     unsigned short port = 0;
@@ -3561,7 +3567,7 @@ parsePortSpecification(AnyP::PortCfg * s, char *token)
 }
 
 static void
-parse_port_option(AnyP::PortCfg * s, char *token)
+parse_port_option(AnyP::PortCfgPointer &s, char *token)
 {
     /* modes first */
 
@@ -3763,18 +3769,17 @@ parse_port_option(AnyP::PortCfg * s, char *token)
 void
 add_http_port(char *portspec)
 {
-    AnyP::PortCfg *s = new AnyP::PortCfg();
+    AnyP::PortCfgPointer s = new AnyP::PortCfg();
     s->setTransport("HTTP");
     parsePortSpecification(s, portspec);
     // we may need to merge better if the above returns a list with clones
     assert(s->next == NULL);
-    s->next = cbdataReference(Config.Sockaddr.http);
-    cbdataReferenceDone(Config.Sockaddr.http);
-    Config.Sockaddr.http = cbdataReference(s);
+    s->next = HttpPortList;
+    HttpPortList = s;
 }
 
 static void
-parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
+parsePortCfg(AnyP::PortCfgPointer *head, const char *optionName)
 {
     const char *protocol = NULL;
     if (strcmp(optionName, "http_port") == 0 ||
@@ -3794,7 +3799,7 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
         return;
     }
 
-    AnyP::PortCfg *s = new AnyP::PortCfg();
+    AnyP::PortCfgPointer s = new AnyP::PortCfg();
     s->setTransport(protocol);
     parsePortSpecification(s, token);
 
@@ -3824,19 +3829,19 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
 
     if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.isAnyAddr()) {
         // clone the port options from *s to *(s->next)
-        s->next = cbdataReference(s->clone());
+        s->next = s->clone();
         s->next->s.setIPv4();
         debugs(3, 3, AnyP::UriScheme(s->transport.protocol).c_str() << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
 
-    while (*head)
-        head = &(*head)->next;
+    while (*head != NULL)
+        head = &((*head)->next);
 
-    *head = cbdataReference(s);
+    *head = s;
 }
 
 static void
-dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
+dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfgPointer &s)
 {
     char buf[MAX_IPSTRLEN];
 
@@ -3963,23 +3968,11 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 }
 
 static void
-dump_PortCfg(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
+dump_PortCfg(StoreEntry * e, const char *n, const AnyP::PortCfgPointer &s)
 {
-    while (s) {
-        dump_generic_port(e, n, s);
+    for (AnyP::PortCfgPointer p = s; p != NULL; p = p->next) {
+        dump_generic_port(e, n, p);
         storeAppendPrintf(e, "\n");
-        s = s->next;
-    }
-}
-
-static void
-free_PortCfg(AnyP::PortCfg ** head)
-{
-    AnyP::PortCfg *s;
-
-    while ((s = *head) != NULL) {
-        *head = s->next;
-        cbdataReferenceDone(s);
     }
 }
 
@@ -173,7 +173,7 @@ DOC_END
 NAME: ignore_ims_on_miss
 TYPE: obsolete
 DOC_START
-	Remove this line. The HTTP/1.1 feature is now fully supported by default.
+	Remove this line. The HTTP/1.1 feature is now configured by 'cache_miss_revalidate'.
 DOC_END
 
 # Options Removed in 3.2
@@ -1508,7 +1508,7 @@ COMMENT_END
 NAME: http_port ascii_port
 TYPE: PortCfg
 DEFAULT: none
-LOC: Config.Sockaddr.http
+LOC: HttpPortList
 DOC_START
 	Usage:	port [mode] [options]
 		hostname:port [mode] [options]
@@ -1750,7 +1750,7 @@ NAME: https_port
 IFDEF: USE_OPENSSL
 TYPE: PortCfg
 DEFAULT: none
-LOC: Config.Sockaddr.https
+LOC: HttpsPortList
 DOC_START
 	Usage:  [ip:]port cert=certificate.pem [key=key.pem] [mode] [options...]
 
@@ -1906,6 +1906,8 @@ DOC_START
 
 	Processing proceeds in the order specified, and stops at first fully
 	matching line.
+
+	Only fast ACLs are supported.
 DOC_END
 
 NAME: clientside_tos
@@ -1948,6 +1950,8 @@ DOC_START
 	acl good_service_net src 10.0.1.0/24
 	tcp_outgoing_mark 0x00 normal_service_net
 	tcp_outgoing_mark 0x20 good_service_net
+
+	Only fast ACLs are supported.
 DOC_END
 
 NAME: clientside_mark
@@ -5176,7 +5180,7 @@ DOC_START
 	downloads.
 
 	When the user aborts a request, Squid will check the
-	quick_abort values to the amount of data transfered until
+	quick_abort values to the amount of data transferred until
 	then.
 
 	If the transfer has less than 'quick_abort_min' KB remaining,
@@ -7523,17 +7527,25 @@ TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.cache_miss_revalidate
 DOC_START
-	Whether Squid on cache MISS will pass client revalidation requests
-	to the server or tries to fetch new content for caching.
-	This is useful while the cache is mostly empty to more quickly
-	have the cache populated.
+	RFC 7232 defines a conditional request mechanism to prevent
+	response objects being unnecessarily transferred over the network.
+	If that mechanism is used by the client and a cache MISS occurs
+	it can prevent new cache entries being created.
+
+	This option determines whether Squid on cache MISS will pass the
+	client revalidation request to the server or tries to fetch new
+	content for caching. It can be useful while the cache is mostly
+	empty to more quickly have the cache populated by generating
+	non-conditional GETs.
 
 	When set to 'on' (default), Squid will pass all client If-* headers
-	to the server.
+	to the server. This permits server responses without a cacheable
+	payload to be delivered and on MISS no new cache entry is created.
 
 	When set to 'off' and if the request is cacheable, Squid will
 	remove the clients If-Modified-Since and If-None-Match headers from
-	the request sent to the server.
+	the request sent to the server. This requests a 200 status response
+	from the server to create a new cache entry with.
 DOC_END
 
 NAME: always_direct
@@ -162,13 +162,13 @@
 class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
 {
 public:
-    typedef void (*Handler)(AnyP::PortCfg *portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
-    ListeningStartedDialer(Handler aHandler, AnyP::PortCfg *aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
+    typedef void (*Handler)(AnyP::PortCfgPointer &portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
+    ListeningStartedDialer(Handler aHandler, AnyP::PortCfgPointer &aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
             handler(aHandler), portCfg(aPortCfg), portTypeNote(note), sub(aSub) {}
 
     virtual void print(std::ostream &os) const {
         startPrint(os) <<
-        ", " << FdNote(portTypeNote) << " port=" << (void*)portCfg << ')';
+        ", " << FdNote(portTypeNote) << " port=" << (void*)&portCfg << ')';
     }
 
     virtual bool canDial(AsyncCall &) const { return true; }
@@ -178,12 +178,12 @@ class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
     Handler handler;
 
 private:
-    AnyP::PortCfg *portCfg;   ///< from Config.Sockaddr.http
+    AnyP::PortCfgPointer portCfg;   ///< from HttpPortList
     Ipc::FdNoteId portTypeNote;    ///< Type of IPC socket being opened
     Subscription::Pointer sub; ///< The handler to be subscribed for this connetion listener
 };
 
-static void clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
+static void clientListenerConnectionOpened(AnyP::PortCfgPointer &s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
 
 /* our socket-related context */
 
@@ -879,8 +879,6 @@ ConnStateData::~ConnStateData()
     if (!flags.swanSang)
         debugs(33, DBG_IMPORTANT, "BUG: ConnStateData was not destroyed properly; " << clientConnection);
 
-    cbdataReferenceDone(port);
-
     if (bodyPipe != NULL)
         stopProducingFor(bodyPipe, false);
 
@@ -2264,7 +2262,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
     *method_p = HttpRequestMethod(&hp->buf[hp->req.m_start], &hp->buf[hp->req.m_end]+1);
 
     /* deny CONNECT via accelerated ports */
-    if (*method_p == Http::METHOD_CONNECT && csd->port && csd->port->flags.accelSurrogate) {
+    if (*method_p == Http::METHOD_CONNECT && csd->port != NULL && csd->port->flags.accelSurrogate) {
         debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->transport.protocol << " Accelerator port " << csd->port->s.port());
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "WARNING: for request: " << hp->buf);
@@ -3526,7 +3524,7 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
 
     // store the details required for creating more MasterXaction objects as new requests come in
     clientConnection = xact->tcpClient;
-    port = cbdataReference(xact->squidPort.get());
+    port = xact->squidPort;
     log_addr = xact->tcpClient->remote;
     log_addr.applyMask(Config.Addrs.client_netmask);
 
@@ -3594,11 +3592,7 @@ httpAccept(const CommAcceptCbParams &params)
     MasterXaction::Pointer xact = params.xaction;
     AnyP::PortCfgPointer s = xact->squidPort;
 
-    if (!s.valid()) {
-        // it is possible the call or accept() was still queued when the port was reconfigured
-        debugs(33, 2, "HTTP accept failure: port reconfigured.");
-        return;
-    }
+    // NP: it is possible the port was reconfigured when the call or accept() was queued.
 
     if (params.flag != Comm::OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3912,11 +3906,7 @@ httpsAccept(const CommAcceptCbParams &params)
     MasterXaction::Pointer xact = params.xaction;
     const AnyP::PortCfgPointer s = xact->squidPort;
 
-    if (!s.valid()) {
-        // it is possible the call or accept() was still queued when the port was reconfigured
-        debugs(33, 2, "HTTPS accept failure: port reconfigured.");
-        return;
-    }
+    // NP: it is possible the port was reconfigured when the call or accept() was queued.
 
     if (params.flag != Comm::OK) {
         // Its possible the call was still queued when the client disconnected
@@ -4302,9 +4292,7 @@ AddOpenedHttpSocket(const Comm::ConnectionPointer &conn)
 static void
 clientHttpConnectionsOpen(void)
 {
-    AnyP::PortCfg *s = NULL;
-
-    for (s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, DBG_IMPORTANT, "WARNING: You have too many 'http_port' lines.");
             debugs(1, DBG_IMPORTANT, "         The limit is " << MAXTCPLISTENPORTS << " HTTP ports.");
@@ -4337,7 +4325,7 @@ clientHttpConnectionsOpen(void)
 
         // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
-        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpAccept", CommAcceptCbPtrFun(httpAccept, s));
+        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpAccept", CommAcceptCbPtrFun(httpAccept, CommAcceptCbParams(NULL)));
         Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
 
         AsyncCall::Pointer listenCall = asyncCall(33,2, "clientListenerConnectionOpened",
@@ -4353,9 +4341,7 @@ clientHttpConnectionsOpen(void)
 static void
 clientHttpsConnectionsOpen(void)
 {
-    AnyP::PortCfg *s;
-
-    for (s = Config.Sockaddr.https; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
         if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, DBG_IMPORTANT, "Ignoring 'https_port' lines exceeding the limit.");
             debugs(1, DBG_IMPORTANT, "The limit is " << MAXTCPLISTENPORTS << " HTTPS ports.");
@@ -4392,7 +4378,7 @@ clientHttpsConnectionsOpen(void)
 
         // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
-        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpsAccept", CommAcceptCbPtrFun(httpsAccept, s));
+        RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpsAccept", CommAcceptCbPtrFun(httpsAccept, CommAcceptCbParams(NULL)));
         Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
 
         AsyncCall::Pointer listenCall = asyncCall(33, 2, "clientListenerConnectionOpened",
@@ -4407,16 +4393,17 @@ clientHttpsConnectionsOpen(void)
 
 /// process clientHttpConnectionsOpen result
 static void
-clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
+clientListenerConnectionOpened(AnyP::PortCfgPointer &s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
 {
+    Must(s != NULL);
+
     if (!OpenedHttpSocket(s->listenConn, portTypeNote))
         return;
 
-    Must(s);
     Must(Comm::IsConnOpen(s->listenConn));
 
     // TCP: setup a job to handle accept() with subscribed handler
-    AsyncJob::Start(new Comm::TcpAcceptor(s->listenConn, FdNote(portTypeNote), sub));
+    AsyncJob::Start(new Comm::TcpAcceptor(s, FdNote(portTypeNote), sub));
 
     debugs(1, DBG_IMPORTANT, "Accepting " <<
            (s->flags.natIntercept ? "NAT intercepted " : "") <<
@@ -4444,7 +4431,7 @@ clientOpenListenSockets(void)
 void
 clientHttpConnectionsClose(void)
 {
-    for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, DBG_IMPORTANT, "Closing HTTP port " << s->listenConn->local);
             s->listenConn->close();
@@ -4453,7 +4440,7 @@ clientHttpConnectionsClose(void)
     }
 
 #if USE_OPENSSL
-    for (AnyP::PortCfg *s = Config.Sockaddr.https; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, DBG_IMPORTANT, "Closing HTTPS port " << s->listenConn->local);
             s->listenConn->close();
@@ -275,7 +275,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     } pinning;
 
     /// Squid listening port details where this connection arrived.
-    AnyP::PortCfg *port;
+    AnyP::PortCfgPointer port;
 
     bool transparent() const;
     bool reading() const;
@@ -164,7 +164,7 @@ ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
     al = new AccessLogEntry;
     al->cache.start_time = current_time;
     al->tcpClient = clientConnection = aConn->clientConnection;
-    al->cache.port =  cbdataReference(aConn->port);
+    al->cache.port = aConn->port;
     al->cache.caddr = aConn->log_addr;
 
 #if USE_OPENSSL
@@ -82,7 +82,7 @@
  */
 
 static IOCB commHalfClosedReader;
-static void comm_init_opened(const Comm::ConnectionPointer &conn, tos_t tos, nfmark_t nfmark, const char *note, struct addrinfo *AI);
+static void comm_init_opened(const Comm::ConnectionPointer &conn, const char *note, struct addrinfo *AI);
 static int comm_apply_flags(int new_socket, Ip::Address &addr, int flags, struct addrinfo *AI);
 
 #if USE_DELAY_POOLS
@@ -245,7 +245,7 @@ comm_open(int sock_type,
           int flags,
           const char *note)
 {
-    return comm_openex(sock_type, proto, addr, flags, 0, 0, note);
+    return comm_openex(sock_type, proto, addr, flags, note);
 }
 
 void
@@ -258,7 +258,7 @@ comm_open_listener(int sock_type,
     conn->flags |= COMM_DOBIND;
 
     /* attempt native enabled port. */
-    conn->fd = comm_openex(sock_type, proto, conn->local, conn->flags, 0, 0, note);
+    conn->fd = comm_openex(sock_type, proto, conn->local, conn->flags, note);
 }
 
 int
@@ -274,7 +274,7 @@ comm_open_listener(int sock_type,
     flags |= COMM_DOBIND;
 
     /* attempt native enabled port. */
-    sock = comm_openex(sock_type, proto, addr, flags, 0, 0, note);
+    sock = comm_openex(sock_type, proto, addr, flags, note);
 
     return sock;
 }
@@ -349,8 +349,6 @@ comm_openex(int sock_type,
             int proto,
             Ip::Address &addr,
             int flags,
-            tos_t tos,
-            nfmark_t nfmark,
             const char *note)
 {
     int new_socket;
@@ -408,14 +406,6 @@ comm_openex(int sock_type,
 
     debugs(50, 3, "comm_openex: Opened socket " << conn << " : family=" << AI->ai_family << ", type=" << AI->ai_socktype << ", protocol=" << AI->ai_protocol );
 
-    /* set TOS if needed */
-    if (tos)
-        Ip::Qos::setSockTos(conn, tos);
-
-    /* set netfilter mark if needed */
-    if (nfmark)
-        Ip::Qos::setSockNfmark(conn, nfmark);
-
     if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && addr.isIPv6() )
         comm_set_v6only(conn->fd, 1);
 
@@ -424,7 +414,7 @@ comm_openex(int sock_type,
     if ( Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING && addr.isIPv6() )
         comm_set_v6only(conn->fd, 0);
 
-    comm_init_opened(conn, tos, nfmark, note, AI);
+    comm_init_opened(conn, note, AI);
     new_socket = comm_apply_flags(conn->fd, addr, flags, AI);
 
     Ip::Address::FreeAddrInfo(AI);
@@ -439,8 +429,6 @@ comm_openex(int sock_type,
 /// update FD tables after a local or remote (IPC) comm_openex();
 void
 comm_init_opened(const Comm::ConnectionPointer &conn,
-                 tos_t tos,
-                 nfmark_t nfmark,
                  const char *note,
                  struct addrinfo *AI)
 {
@@ -458,9 +446,6 @@ comm_init_opened(const Comm::ConnectionPointer &conn,
 
     fde *F = &fd_table[conn->fd];
     F->local_addr = conn->local;
-    F->tosToServer = tos;
-
-    F->nfmarkToServer = nfmark;
 
     F->sock_family = AI->ai_family;
 }
@@ -537,7 +522,7 @@ comm_import_opened(const Comm::ConnectionPointer &conn,
     assert(Comm::IsConnOpen(conn));
     assert(AI);
 
-    comm_init_opened(conn, 0, 0, note, AI);
+    comm_init_opened(conn, note, AI);
 
     if (!(conn->flags & COMM_NOCLOEXEC))
         fd_table[conn->fd].flags.close_on_exec = true;
@@ -51,7 +51,7 @@ void comm_import_opened(const Comm::ConnectionPointer &, const char *note, struc
 int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note);
 void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note);
 
-int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *);
+int comm_openex(int, int, Ip::Address &, int, const char *);
 unsigned short comm_local_port(int fd);
 
 int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen);
@@ -12,6 +12,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "icmp/net_db.h"
+#include "ip/QosConfig.h"
 #include "ip/tools.h"
 #include "ipcache.h"
 #include "SquidConfig.h"
@@ -254,12 +255,25 @@ Comm::ConnOpener::createFd()
     if (callback_ == NULL || callback_->canceled())
         return false;
 
-    temporaryFd_ = comm_openex(SOCK_STREAM, IPPROTO_TCP, conn_->local, conn_->flags, conn_->tos, conn_->nfmark, host_);
+    temporaryFd_ = comm_openex(SOCK_STREAM, IPPROTO_TCP, conn_->local, conn_->flags, host_);
     if (temporaryFd_ < 0) {
         sendAnswer(Comm::ERR_CONNECT, 0, "Comm::ConnOpener::createFd");
         return false;
     }
 
+    // Set TOS if needed.
+    if (conn_->tos &&
+            Ip::Qos::setSockTos(temporaryFd_, conn_->tos, conn_->remote.isIPv4() ? AF_INET : AF_INET6) < 0)
+        conn_->tos = 0;
+#if SO_MARK
+    if (conn_->nfmark &&
+            Ip::Qos::setSockNfmark(temporaryFd_, conn_->nfmark) < 0)
+        conn_->nfmark = 0;
+#endif
+
+    fd_table[temporaryFd_].tosToServer = conn_->tos;
+    fd_table[temporaryFd_].nfmarkToServer = conn_->nfmark;
+
     typedef CommCbMemFunT<Comm::ConnOpener, CommCloseCbParams> abortDialer;
     calls_.earlyAbort_ = JobCallback(5, 4, abortDialer, this, Comm::ConnOpener::earlyAbort);
     comm_add_close_handler(temporaryFd_, calls_.earlyAbort_);
@@ -45,8 +45,7 @@ Comm::Connection::copyDetails() const
 {
     ConnectionPointer c = new Comm::Connection;
 
-    c->local = local;
-    c->remote = remote;
+    c->setAddrs(local, remote);
     c->peerType = peerType;
     c->tos = tos;
     c->nfmark = nfmark;
@@ -104,6 +104,11 @@ class Connection : public RefCountable
     /** determine whether this object describes an active connection or not. */
     bool isOpen() const { return (fd >= 0); }
 
+    /** Alter the stored IP address pair.
+     * WARNING: Does not ensure matching IPv4/IPv6 are supplied.
+     */
+    void setAddrs(const Ip::Address &aLocal, const Ip::Address &aRemote) {local = aLocal; remote = aRemote;}
+
     /** retrieve the CachePeer pointer for use.
      * The caller is responsible for all CBDATA operations regarding the
      * used of the pointer returned.
@@ -196,7 +196,7 @@ fdIsDns(int fd)
 static int
 fdIsTcpListen(int fd)
 {
-    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
@@ -197,7 +197,7 @@ fdIsDns(int fd)
 static int
 fdIsTcpListener(int fd)
 {
-    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
@@ -320,7 +320,7 @@ comm_select_tcp_incoming(void)
 
     // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (Comm::IsConnOpen(s->listenConn)) {
             fds[nfds] = s->listenConn->fd;
             ++nfds;
@@ -191,7 +191,7 @@ fdIsDns(int fd)
 static int
 fdIsTcpListener(int fd)
 {
-    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
@@ -317,7 +317,7 @@ comm_select_tcp_incoming(void)
 
     // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (Comm::IsConnOpen(s->listenConn)) {
             fds[nfds] = s->listenConn->fd;
             ++nfds;
@@ -47,6 +47,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "ip/Intercept.h"
+#include "ip/QosConfig.h"
 #include "MasterXaction.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
@@ -66,7 +67,17 @@ Comm::TcpAcceptor::TcpAcceptor(const Comm::ConnectionPointer &newConn, const cha
         errcode(0),
         isLimited(0),
         theCallSub(aSub),
-        conn(newConn)
+        conn(newConn),
+        listenPort_()
+{}
+
+Comm::TcpAcceptor::TcpAcceptor(const AnyP::PortCfgPointer &p, const char *note, const Subscription::Pointer &aSub) :
+        AsyncJob("Comm::TcpAcceptor"),
+        errcode(0),
+        isLimited(0),
+        theCallSub(aSub),
+        conn(p->listenConn),
+        listenPort_(p)
 {}
 
 void
@@ -189,6 +200,21 @@ Comm::TcpAcceptor::setListen()
 #endif
     }
 
+#if 0
+    // Untested code.
+    // Set TOS if needed.
+    // To correctly implement TOS values on listening sockets, probably requires
+    // more work to inherit TOS values to created connection objects.
+    if (conn->tos &&
+            Ip::Qos::setSockTos(conn->fd, conn->tos, conn->remote.isIPv4() ? AF_INET : AF_INET6) < 0)
+        conn->tos = 0;
+#if SO_MARK
+    if (conn->nfmark &&
+            Ip::Qos::setSockNfmark(conn->fd, conn->nfmark) < 0)
+        conn->nfmark = 0;
+#endif
+#endif
+
     typedef CommCbMemFunT<Comm::TcpAcceptor, CommCloseCbParams> Dialer;
     closer_ = JobCallback(5, 4, Dialer, this, Comm::TcpAcceptor::handleClosure);
     comm_add_close_handler(conn->fd, closer_);
@@ -309,7 +335,7 @@ Comm::TcpAcceptor::notify(const Comm::Flag flag, const Comm::ConnectionPointer &
         AsyncCall::Pointer call = theCallSub->callback();
         CommAcceptCbParams &params = GetCommParams<CommAcceptCbParams>(call);
         params.xaction = new MasterXaction;
-        params.xaction->squidPort = static_cast<AnyP::PortCfg*>(params.data);
+        params.xaction->squidPort = listenPort_;
         params.fd = conn->fd;
         params.conn = params.xaction->tcpClient = newConnDetails;
         params.flag = flag;
@@ -1,6 +1,7 @@
 #ifndef SQUID_COMM_TCPACCEPTOR_H
 #define SQUID_COMM_TCPACCEPTOR_H
 
+#include "anyp/forward.h"
 #include "base/AsyncJob.h"
 #include "base/CbcPointer.h"
 #include "base/Subscription.h"
@@ -41,6 +42,7 @@ class TcpAcceptor : public AsyncJob
 
 public:
     TcpAcceptor(const Comm::ConnectionPointer &conn, const char *note, const Subscription::Pointer &aSub);
+    TcpAcceptor(const AnyP::PortCfgPointer &listenPort, const char *note, const Subscription::Pointer &aSub);
 
     /** Subscribe a handler to receive calls back about new connections.
      * Unsubscribes any existing subscribed handler.
@@ -75,6 +77,9 @@ class TcpAcceptor : public AsyncJob
     /// Reserved for read-only use.
     ConnectionPointer conn;
 
+    /// configuration details of the listening port (if provided)
+    AnyP::PortCfgPointer listenPort_;
+
     /// listen socket closure handler
     AsyncCall::Pointer closer_;
 
@@ -899,15 +899,12 @@ idnsInitVC(int nsv)
     Comm::ConnectionPointer conn = new Comm::Connection();
 
     if (!Config.Addrs.udp_outgoing.isNoAddr())
-        conn->local = Config.Addrs.udp_outgoing;
+        conn->setAddrs(Config.Addrs.udp_outgoing, nameservers[nsv].S);
     else
-        conn->local = Config.Addrs.udp_incoming;
+        conn->setAddrs(Config.Addrs.udp_incoming, nameservers[nsv].S);
 
-    conn->remote = nameservers[nsv].S;
-
-    if (conn->remote.isIPv4()) {
+    if (conn->remote.isIPv4())
         conn->local.setIPv4();
-    }
 
     AsyncCall::Pointer call = commCbCall(78,3, "idnsInitVCConnected", CommConnectCbPtrFun(idnsInitVCConnected, vc));
 
@@ -57,8 +57,9 @@ struct arpreq {
     struct sockaddr arp_ha;   /* hardware address */
     int arp_flags;            /* flags */
 };
-
-#include <Iphlpapi.h>
+#if HAVE_IPHLPAPI_H
+#include <iphlpapi.h>
+#endif
 #endif
 
 #if HAVE_SYS_PARAM_H
@@ -384,7 +384,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             // avoid logging a dash if we have reliable info
             const bool interceptedAtKnownPort = al->request ?
                                                 (al->request->flags.interceptTproxy ||
-                                                 al->request->flags.intercepted) && al->cache.port :
+                                                 al->request->flags.intercepted) && al->cache.port != NULL :
                                                 false;
             if (interceptedAtKnownPort) {
                 const bool portAddressConfigured = !al->cache.port->s.isAnyAddr();
@@ -416,7 +416,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_LOCAL_LISTENING_PORT:
-            if (al->cache.port) {
+            if (al->cache.port != NULL) {
                 outint = al->cache.port->s.port();
                 doint = 1;
             }
@@ -47,7 +47,7 @@ libfs_la_LIBADD =  $(STORE_LIBS_TO_BUILD)
 libfs_la_DEPENDENCIES = $(STORE_LIBS_TO_BUILD)
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 
 ## targets below to emulate distributed makefiles
@@ -643,6 +643,9 @@ FtpStateData::listenForDataChannel(const Comm::ConnectionPointer &conn, const ch
         debugs(9, 3, HERE << "Unconnected data socket created on " << conn);
     }
 
+    conn->tos = ctrl.conn->tos;
+    conn->nfmark = ctrl.conn->nfmark;
+
     assert(Comm::IsConnOpen(conn));
     AsyncJob::Start(new Comm::TcpAcceptor(conn, note, sub));
 
@@ -2465,10 +2468,11 @@ ftpReadEPSV(FtpStateData* ftpState)
 
     // Generate a new data channel descriptor to be opened.
     Comm::ConnectionPointer conn = new Comm::Connection;
-    conn->local = ftpState->ctrl.conn->local;
+    conn->setAddrs(ftpState->ctrl.conn->local, ftpState->ctrl.conn->remote);
     conn->local.port(0);
-    conn->remote = ftpState->ctrl.conn->remote;
     conn->remote.port(port);
+    conn->tos = ftpState->ctrl.conn->tos;
+    conn->nfmark = ftpState->ctrl.conn->nfmark;
 
     debugs(9, 3, HERE << "connecting to " << conn->remote);
 
@@ -2719,9 +2723,8 @@ ftpReadPasv(FtpStateData * ftpState)
     ftpState->ctrl.last_command = xstrdup("Connect to server data port");
 
     Comm::ConnectionPointer conn = new Comm::Connection;
-    conn->local = ftpState->ctrl.conn->local;
+    conn->setAddrs(ftpState->ctrl.conn->local, ipaddr);
     conn->local.port(0);
-    conn->remote = ipaddr;
     conn->remote.port(port);
 
     debugs(9, 3, HERE << "connecting to " << conn->remote);
@@ -36,6 +36,7 @@
 #include "hash.h"
 #include "IoStats.h"
 #include "rfc2181.h"
+#include "SBuf.h"
 
 extern char *ConfigFile;	/* NULL */
 extern char *IcpOpcodeStr[];
@@ -52,7 +53,6 @@ extern const char *null_string;	/* "" */
 extern const char *version_string;	/* VERSION */
 extern const char *appname_string;	/* PACKAGE */
 extern char const *visible_appname_string; /* NULL */
-extern char *service_name;        /* xstrdup(APP_SHORTNAME) */
 extern const char *fdTypeStr[];
 extern const char *hier_strings[];
 extern const char *memStatusStr[];
@@ -114,6 +114,7 @@ testIcmp_LDADD=\
 	$(SQUID_CPPUNIT_LA) \
 	libicmp-core.la \
 	../ip/libip.la \
+	../base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 testIcmp_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
@@ -28,6 +28,7 @@ nodist_testIpAddress_SOURCES= \
 	$(top_srcdir)/src/tests/testMain.cc
 testIpAddress_LDADD= \
 	libip.la \
+	../base/libbase.la \
 	$(XTRA_LIBS) \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LA) \
@@ -3,34 +3,29 @@
 #include "Debug.h"
 
 int
-Ip::Qos::setSockTos(const Comm::ConnectionPointer &conn, tos_t tos)
+Ip::Qos::setSockTos(const int fd, tos_t tos, int type)
 {
     // Bug 3731: FreeBSD produces 'invalid option'
     // unless we pass it a 32-bit variable storing 8-bits of data.
     // NP: it is documented as 'int' for all systems, even those like Linux which accept 8-bit char
     //     so we convert to a int before setting.
     int bTos = tos;
 
-    if (conn->remote.isIPv4()) {
+    if (type == AF_INET) {
 #if defined(IP_TOS)
-        int x = setsockopt(conn->fd, IPPROTO_IP, IP_TOS, &bTos, sizeof(bTos));
+        const int x = setsockopt(fd, IPPROTO_IP, IP_TOS, &bTos, sizeof(bTos));
         if (x < 0)
-            debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IP_TOS) on " << conn << ": " << xstrerror());
-        else
-            conn->tos = tos;
+            debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IP_TOS) on " << fd << ": " << xstrerror());
         return x;
 #else
         debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(IP_TOS) not supported on this platform");
         return -1;
 #endif
-
-    } else { // if (conn->remote.isIPv6()) {
+    } else { // type == AF_INET6
 #if defined(IPV6_TCLASS)
-        int x = setsockopt(conn->fd, IPPROTO_IPV6, IPV6_TCLASS, &bTos, sizeof(bTos));
+        const int x = setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS, &bTos, sizeof(bTos));
         if (x < 0)
-            debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IPV6_TCLASS) on " << conn << ": " << xstrerror());
-        else
-            conn->tos = tos;
+            debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IPV6_TCLASS) on " << fd << ": " << xstrerror());
         return x;
 #else
         debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(IPV6_TCLASS) not supported on this platform");
@@ -42,14 +37,22 @@ Ip::Qos::setSockTos(const Comm::ConnectionPointer &conn, tos_t tos)
 }
 
 int
-Ip::Qos::setSockNfmark(const Comm::ConnectionPointer &conn, nfmark_t mark)
+Ip::Qos::setSockTos(const Comm::ConnectionPointer &conn, tos_t tos)
+{
+    const int x = Ip::Qos::setSockTos(conn->fd, tos, conn->remote.isIPv4() ? AF_INET : AF_INET6);
+    if (x >= 0)
+        conn->tos = tos;
+
+    return x;
+}
+
+int
+Ip::Qos::setSockNfmark(const int fd, nfmark_t mark)
 {
 #if SO_MARK && USE_LIBCAP
-    int x = setsockopt(conn->fd, SOL_SOCKET, SO_MARK, &mark, sizeof(nfmark_t));
+    const int x = setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(nfmark_t));
     if (x < 0)
-        debugs(50, 2, "setSockNfmark: setsockopt(SO_MARK) on " << conn << ": " << xstrerror());
-    else
-        conn->nfmark = mark;
+        debugs(50, 2, "setSockNfmark: setsockopt(SO_MARK) on " << fd << ": " << xstrerror());
     return x;
 #elif USE_LIBCAP
     debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(SO_MARK) not supported on this platform");
@@ -60,6 +63,15 @@ Ip::Qos::setSockNfmark(const Comm::ConnectionPointer &conn, nfmark_t mark)
 #endif
 }
 
+int
+Ip::Qos::setSockNfmark(const Comm::ConnectionPointer &conn, nfmark_t mark)
+{
+    const int x = Ip::Qos::setSockNfmark(conn->fd, mark);
+    if (x >= 0)
+        conn->nfmark = mark;
+    return x;
+}
+
 bool
 Ip::Qos::Config::isHitTosActive() const
 {
@@ -122,13 +122,29 @@ int doNfmarkLocalHit(const Comm::ConnectionPointer &conn);
 */
 _SQUID_INLINE_ int setSockTos(const Comm::ConnectionPointer &conn, tos_t tos);
 
+/**
+* The low level variant of setSockTos function to set TOS value of packets.
+* Avoid if you can use the Connection-based setSockTos().
+* @param fd Descriptor of socket to set the TOS for
+* @param type The socket family, AF_INET or AF_INET6
+*/
+_SQUID_INLINE_ int setSockTos(const int fd, tos_t tos, int type);
+
 /**
 * Function to set the netfilter mark value of packets. Sets the value on the
 * socket which then gets copied to the packets. Called from Ip::Qos::doNfmarkLocalMiss
 * @param conn Descriptor of socket to set the mark for
 */
 _SQUID_INLINE_ int setSockNfmark(const Comm::ConnectionPointer &conn, nfmark_t mark);
 
+/**
+* The low level variant of setSockNfmark function to set the netfilter mark
+* value of packets.
+* Avoid if you can use the Connection-based setSockNfmark().
+* @param fd Descriptor of socket to set the mark for
+*/
+_SQUID_INLINE_ int setSockNfmark(const int fd, nfmark_t mark);
+
 /**
  * QOS configuration class. Contains all the parameters for QOS functions as well
  * as functions to check whether either TOS or MARK QOS is enabled.
@@ -19,6 +19,8 @@
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testIpAddress );
 
+#include "tests/stub_SBuf.cc"
+
 /* so that we don't break POD dependency just for the test */
 struct timeval current_time;
 double current_dtime;
@@ -8,8 +8,8 @@
 #include "comm/Connection.h"
 #include "comm/Read.h"
 #include "CommCalls.h"
-#include "globals.h"
 #include "ipc/Port.h"
+#include "tools.h"
 
 static const char channelPathPfx[] = DEFAULT_STATEDIR "/";
 static const char coordinatorAddrLabel[] = "-coordinator";
@@ -46,7 +46,7 @@ String Ipc::Port::MakeAddr(const char* processLabel, int id)
 {
     assert(id >= 0);
     String addr = channelPathPfx;
-    addr.append(service_name);
+    addr.append(service_name.c_str());
     addr.append(processLabel);
     addr.append('-');
     addr.append(xitoa(id));
@@ -60,7 +60,7 @@ Ipc::Port::CoordinatorAddr()
     static String coordinatorAddr;
     if (!coordinatorAddr.size()) {
         coordinatorAddr= channelPathPfx;
-        coordinatorAddr.append(service_name);
+        coordinatorAddr.append(service_name.c_str());
         coordinatorAddr.append(coordinatorAddrLabel);
         coordinatorAddr.append(".ipc");
     }
@@ -73,6 +73,7 @@
 #include "MemPool.h"
 #include "mime.h"
 #include "neighbors.h"
+#include "parser/Tokenizer.h"
 #include "pconn.h"
 #include "peer_sourcehash.h"
 #include "peer_userhash.h"
@@ -506,10 +507,18 @@ mainParseOptions(int argc, char *argv[])
             /** \par n
              * Set global option opt_signal_service (to true).
              * Stores the additional parameter given in global service_name */
-            // XXX: verify that the new name has ONLY alphanumeric characters
-            xfree(service_name);
-            service_name = xstrdup(optarg);
-            opt_signal_service = true;
+            if (optarg && *optarg != '\0') {
+                const SBuf t(optarg);
+                ::Parser::Tokenizer tok(t);
+                const CharacterSet chr = CharacterSet::ALPHA+CharacterSet::DIGIT;
+                if (!tok.prefix(service_name, chr) || !tok.atEnd())
+                    fatalf("Expected alphanumeric service name for the -n option but got: " SQUIDSBUFPH, SQUIDSBUFPRINT(service_name));
+                if (service_name.length() > 32)
+                    fatalf("Service name (-n option) must be limited to 32 characters but got %u", service_name.length());
+                opt_signal_service = true;
+            } else {
+                fatal("A service name is required for the -n option");
+            }
             break;
 
 #if USE_WIN32_SERVICE
@@ -561,7 +570,7 @@ mainParseOptions(int argc, char *argv[])
             /** \par v
              * Display squid version and build information. Then exit. */
             printf("Squid Cache: Version %s\n" ,version_string);
-            printf("Service Name: %s\n", service_name);
+            printf("Service Name: " SQUIDSBUFPH "\n", SQUIDSBUFPRINT(service_name));
             if (strlen(SQUID_BUILD_INFO))
                 printf("%s\n",SQUID_BUILD_INFO);
             printf( "configure options: %s\n", SQUID_CONFIGURE_OPTIONS);
@@ -583,7 +583,7 @@ neighbors_init(void)
             if (0 != strcmp(thisPeer->host, me))
                 continue;
 
-            for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+            for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
                 if (thisPeer->http_port != s->s.port())
                     continue;
 
@@ -3,7 +3,7 @@
 include $(top_srcdir)/src/Common.am
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 AUTOMAKE_OPTIONS = subdir-objects
 
@@ -31,6 +31,7 @@
  */
 
 #include "squid.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "disk.h"
 #include "event.h"
@@ -81,7 +82,7 @@ send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *junk)
     sndbuf[0] = '\0';
     snprintf(tbuf, 256, "cache_version SQUID/%s\n", version_string);
     strcat(sndbuf, tbuf);
-    assert(Config.Sockaddr.http);
+    assert(HttpPortList != NULL);
     snprintf(tbuf, 256, "Running on %s %d %d\n",
              getMyHostname(),
              getMyPort(),
@@ -33,9 +33,9 @@ void Ssl::Helper::Init()
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL
     bool found = false;
-    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; !found && s; s = s->next)
+    for (AnyP::PortCfgPointer s = HttpPortList; !found && s != NULL; s = s->next)
         found = s->flags.tunnelSslBumping;
-    for (AnyP::PortCfg *s = ::Config.Sockaddr.https; !found && s; s = s->next)
+    for (AnyP::PortCfgPointer s = HttpsPortList; !found && s != NULL; s = s->next)
         found = s->flags.tunnelSslBumping;
     if (!found)
         return;
@@ -134,9 +134,9 @@ void Ssl::CertValidationHelper::Init()
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL
     bool found = false;
-    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; !found && s; s = s->next)
+    for (AnyP::PortCfgPointer s = HttpPortList; !found && s != NULL; s = s->next)
         found = s->flags.tunnelSslBumping;
-    for (AnyP::PortCfg *s = ::Config.Sockaddr.https; !found && s; s = s->next)
+    for (AnyP::PortCfgPointer s = HttpsPortList; !found && s != NULL; s = s->next)
         found = s->flags.tunnelSslBumping;
     if (!found)
         return;
@@ -1774,10 +1774,10 @@ setSessionCallbacks(SSL_CTX *ctx)
 static bool
 isSslServer()
 {
-    if (Config.Sockaddr.https)
+    if (HttpsPortList != NULL)
         return true;
 
-    for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->flags.tunnelSslBumping)
             return true;
     }
@@ -1808,12 +1808,12 @@ Ssl::initialize_session_cache()
         return;
     }
 
-    for (AnyP::PortCfg *s = ::Config.Sockaddr.https; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpsPortList; s != NULL; s = s->next) {
         if (s->staticSslContext.get() != NULL)
             setSessionCallbacks(s->staticSslContext.get());
     }
 
-    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s->next) {
         if (s->staticSslContext.get() != NULL)
             setSessionCallbacks(s->staticSslContext.get());
     }
@@ -625,13 +625,13 @@ DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
 
 #if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
-        storeAppendPrintf(sentry,"\nRunning as %s Windows System Service on %s\n",
-                          Service_name, WIN32_OS_string);
+        storeAppendPrintf(sentry,"\nRunning as " SQUIDSBUFPH " Windows System Service on %s\n",
+                          SQUIDBUFPRINT(service_name), WIN32_OS_string);
         storeAppendPrintf(sentry,"Service command line is: %s\n", WIN32_Service_Command_Line);
     } else
         storeAppendPrintf(sentry,"Running on %s\n",WIN32_OS_string);
 #else
-    storeAppendPrintf(sentry,"Service Name: %s\n", service_name);
+    storeAppendPrintf(sentry,"Service Name: " SQUIDSBUFPH "\n", SQUIDSBUFPRINT(service_name));
 #endif
 
     storeAppendPrintf(sentry, "Start Time:\t%s\n",
@@ -13,6 +13,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_Port.cc \
+	tests/stub_SBuf.cc \
 	tests/stub_SBufDetailedStats.cc \
 	tests/stub_StatHist.cc \
 	tests/stub_StoreMeta.cc \
@@ -0,0 +1,60 @@
+#include "squid.h"
+
+#define STUB_API "SBuf.cc"
+#include "tests/STUB.h"
+
+#include "SBuf.h"
+
+InstanceIdDefinitions(SBuf, "SBuf");
+
+SBufStats SBuf::stats;
+const SBuf::size_type SBuf::npos;
+const SBuf::size_type SBuf::maxSize;
+
+SBufStats::SBufStats() {}
+std::ostream& SBufStats::dump(std::ostream &os) const STUB_RETVAL(os)
+SBufStats& SBufStats::operator +=(const SBufStats&) STUB_RETVAL(*this)
+
+SBuf::SBuf() {}
+SBuf::SBuf(const SBuf &S) {}
+SBuf::SBuf(const char *S, size_type n) {}
+SBuf::SBuf(const String &S) {}
+SBuf::SBuf(const std::string &s) {}
+SBuf::~SBuf() {}
+SBuf& SBuf::assign(const SBuf &S) STUB_RETVAL(*this)
+SBuf& SBuf::assign(const char *S, size_type n) STUB_RETVAL(*this)
+void clear() STUB
+SBuf& SBuf::append(const SBuf & S) STUB_RETVAL(*this)
+SBuf& SBuf::append(const char * S, size_type Ssize) STUB_RETVAL(*this)
+SBuf& Printf(const char *fmt, ...);
+SBuf& SBuf::appendf(const char *fmt, ...) STUB_RETVAL(*this)
+SBuf& SBuf::vappendf(const char *fmt, va_list vargs) STUB_RETVAL(*this)
+std::ostream& SBuf::print(std::ostream &os) const STUB_RETVAL(os)
+std::ostream& SBuf::dump(std::ostream &os) const STUB_RETVAL(os)
+void SBuf::setAt(size_type pos, char toset) STUB
+int SBuf::compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n) const STUB_RETVAL(-1)
+int SBuf::compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n) const STUB_RETVAL(-1)
+bool SBuf::startsWith(const SBuf &S, const SBufCaseSensitive isCaseSensitive) const STUB_RETVAL(false)
+bool SBuf::operator ==(const SBuf & S) const STUB_RETVAL(false)
+bool SBuf::operator !=(const SBuf & S) const STUB_RETVAL(false)
+SBuf SBuf::consume(size_type n) STUB_RETVAL(*this)
+const SBufStats& SBuf::GetStats() STUB_RETVAL(SBuf::stats)
+SBuf::size_type SBuf::copy(char *dest, size_type n) const STUB_RETVAL(0)
+const char* SBuf::rawContent() const STUB_RETVAL(NULL)
+char *SBuf::rawSpace(size_type minSize) STUB_RETVAL(NULL)
+void SBuf::forceSize(size_type newSize) STUB
+const char* SBuf::c_str() STUB_RETVAL("")
+void SBuf::reserveCapacity(size_type minCapacity) STUB
+SBuf& SBuf::chop(size_type pos, size_type n) STUB_RETVAL(*this)
+SBuf& SBuf::trim(const SBuf &toRemove, bool atBeginning, bool atEnd) STUB_RETVAL(*this)
+SBuf SBuf::substr(size_type pos, size_type n) const STUB_RETVAL(*this)
+SBuf::size_type SBuf::find(char c, size_type startPos) const STUB_RETVAL(SBuf::npos)
+SBuf::size_type SBuf::find(const SBuf & str, size_type startPos) const STUB_RETVAL(SBuf::npos)
+SBuf::size_type SBuf::rfind(char c, size_type endPos) const STUB_RETVAL(SBuf::npos)
+SBuf::size_type SBuf::rfind(const SBuf &str, size_type endPos) const STUB_RETVAL(SBuf::npos)
+SBuf::size_type SBuf::findFirstOf(const CharacterSet &set, size_type startPos) const STUB_RETVAL(SBuf::npos)
+SBuf::size_type SBuf::findFirstNotOf(const CharacterSet &set, size_type startPos) const STUB_RETVAL(SBuf::npos)
+int SBuf::scanf(const char *format, ...) STUB_RETVAL(-1)
+SBuf SBuf::toLower() const STUB_RETVAL(*this)
+SBuf SBuf::toUpper() const STUB_RETVAL(*this)
+String SBuf::toString() const STUB_RETVAL(String(""))
@@ -1,37 +1,4 @@
-/*
- * DEBUG: section 84    Helper process maintenance
- * AUTHOR: Robert Collins
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
 #include "squid.h"
-#include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -51,15 +18,45 @@ DeferredRead::DeferredRead(DeferrableRead *, void *, CommRead const &) STUB
 void DeferredReadManager::delayRead(DeferredRead const &aRead) STUB
 void DeferredReadManager::kickReads(int const count) STUB
 
-void commSetCloseOnExec(int fd) STUB_NOP
-int ignoreErrno(int ierrno) STUB_RETVAL(-1)
-
-void commUnsetFdTimeout(int fd) STUB
+#include "comm.h"
+bool comm_iocallbackpending(void) STUB_RETVAL(false)
 int commSetNonBlocking(int fd) STUB_RETVAL(Comm::COMM_ERROR)
 int commUnsetNonBlocking(int fd) STUB_RETVAL(-1)
-
-// MinGW needs also a stub of _comm_close()
+void commSetCloseOnExec(int fd) STUB_NOP
+void commSetTcpKeepalive(int fd, int idle, int interval, int timeout) STUB
 void _comm_close(int fd, char const *file, int line) STUB
-int commSetTimeout(int fd, int timeout, AsyncCall::Pointer& callback) STUB_RETVAL(-1)
+void old_comm_reset_close(int fd) STUB
+void comm_reset_close(const Comm::ConnectionPointer &conn) STUB
+#if LINGERING_CLOSE
+void comm_lingering_close(int fd) STUB
+#endif
+int comm_connect_addr(int sock, const Ip::Address &addr) STUB_RETVAL(-1)
+void comm_init(void) STUB
+void comm_exit(void) STUB
+int comm_open(int, int, Ip::Address &, int, const char *note) STUB_RETVAL(-1)
 int comm_open_uds(int sock_type, int proto, struct sockaddr_un* addr, int flags) STUB_RETVAL(-1)
-void comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE * free_func) STUB
+void comm_import_opened(const Comm::ConnectionPointer &, const char *note, struct addrinfo *AI) STUB
+int comm_open_listener(int sock_type, int proto, Ip::Address &addr, int flags, const char *note) STUB_RETVAL(-1)
+void comm_open_listener(int sock_type, int proto, Comm::ConnectionPointer &conn, const char *note) STUB
+int comm_openex(int, int, Ip::Address &, int, tos_t tos, nfmark_t nfmark, const char *) STUB_RETVAL(-1)
+unsigned short comm_local_port(int fd) STUB_RETVAL(0)
+int comm_udp_sendto(int sock, const Ip::Address &to, const void *buf, int buflen) STUB_RETVAL(-1)
+void commCallCloseHandlers(int fd) STUB
+void commUnsetFdTimeout(int fd) STUB
+int commSetTimeout(const Comm::ConnectionPointer &, int, AsyncCall::Pointer&) STUB_RETVAL(-1)
+int commSetConnTimeout(const Comm::ConnectionPointer &conn, int seconds, AsyncCall::Pointer &callback) STUB_RETVAL(-1)
+int commUnsetConnTimeout(const Comm::ConnectionPointer &conn) STUB_RETVAL(-1)
+int ignoreErrno(int ierrno) STUB_RETVAL(-1)
+void commCloseAllSockets(void) STUB
+void checkTimeouts(void) STUB
+void comm_add_close_handler(int fd, CLCB *, void *) STUB
+void comm_add_close_handler(int fd, AsyncCall::Pointer &) STUB
+void comm_remove_close_handler(int fd, CLCB *, void *) STUB
+void comm_remove_close_handler(int fd, AsyncCall::Pointer &)STUB
+int comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from) STUB_RETVAL(-1)
+int comm_udp_recv(int fd, void *buf, size_t len, int flags) STUB_RETVAL(-1)
+ssize_t comm_udp_send(int s, const void *buf, size_t len, int flags) STUB_RETVAL(-1)
+bool comm_has_incomplete_write(int) STUB_RETVAL(false)
+void commStartHalfClosedMonitor(int fd) STUB
+bool commHasHalfClosedMonitor(int fd) STUB_RETVAL(false)
+int CommSelectEngine::checkEvents(int timeout) STUB_RETVAL(0)
@@ -4,7 +4,7 @@
 #define STUB_API "event.cc"
 #include "tests/STUB.h"
 
-void eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata) STUB
+void eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata) STUB_NOP
 void eventAddIsh(const char *name, EVH * func, void *arg, double delta_ish, int) STUB
 void eventDelete(EVH * func, void *arg) STUB
 void eventInit(void) STUB
@@ -40,20 +40,47 @@ Ssl::ErrorDetail::ErrorDetail(ErrorDetail const &) STUB
 const String & Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 
 #include "ssl/support.h"
-SSL_CTX *sslCreateServerContext(AnyP::PortCfg &) STUB_RETVAL(NULL)
+namespace Ssl
+{
+//CertError::CertError(ssl_error_t anErr, X509 *aCert) STUB
+//CertError::CertError(CertError const &err) STUB
+CertError & CertError::operator = (const CertError &old) STUB_RETVAL(*this)
+bool CertError::operator == (const CertError &ce) const STUB_RETVAL(false)
+bool CertError::operator != (const CertError &ce) const STUB_RETVAL(false)
+} // namespace Ssl
+SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port) STUB_RETVAL(NULL)
 SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
-void ssl_shutdown_method(SSL *) STUB
+void ssl_shutdown_method(SSL *ssl) STUB
 const char *sslGetUserEmail(SSL *ssl) STUB_RETVAL(NULL)
-// typedef char const *Ssl::GETATTRIBUTE(X509 *, const char *);
-// Ssl::GETATTRIBUTE Ssl::GetX509UserAttribute;
-// Ssl::GETATTRIBUTE Ssl::GetX509CAAttribute;
+const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
+const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name) STUB_RETVAL(NULL)
 const char *sslGetUserCertificatePEM(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserCertificateChainPEM(SSL *ssl) STUB_RETVAL(NULL)
-SSL_CTX * Ssl::generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &) STUB_RETVAL(NULL)
-SSL_CTX * Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &) STUB_RETVAL(NULL)
-int Ssl::matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_func)(void *check_data,  ASN1_STRING *cn_data)) STUB_RETVAL(0)
-int Ssl::asn1timeToString(ASN1_TIME *tm, char *buf, int len) STUB_RETVAL(0)
+namespace Ssl
+{
+//GETX509ATTRIBUTE GetX509UserAttribute;
+//GETX509ATTRIBUTE GetX509CAAttribute;
+//GETX509ATTRIBUTE GetX509Fingerprint;
+const char *BumpModeStr[] = {""};
+long parse_flags(const char *flags) STUB_RETVAL(0)
+long parse_options(const char *options) STUB_RETVAL(0)
+STACK_OF(X509_CRL) *loadCrl(const char *CRLFile, long &flags) STUB_RETVAL(NULL)
+DH *readDHParams(const char *dhfile) STUB_RETVAL(NULL)
+ContextMethod contextMethod(int version) STUB_RETVAL(ContextMethod())
+bool generateUntrustedCert(X509_Pointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey) STUB_RETVAL(false)
+SSL_CTX * generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port) STUB_RETVAL(NULL)
+bool verifySslCertificate(SSL_CTX * sslContext,  CertificateProperties const &properties) STUB_RETVAL(false)
+SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &port) STUB_RETVAL(NULL)
+void addChainToSslContext(SSL_CTX *sslContext, STACK_OF(X509) *certList) STUB
+void readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename) STUB
+int matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_func)(void *check_data,  ASN1_STRING *cn_data)) STUB_RETVAL(0)
+bool checkX509ServerValidity(X509 *cert, const char *server) STUB_RETVAL(false)
+int asn1timeToString(ASN1_TIME *tm, char *buf, int len) STUB_RETVAL(0)
+bool setClientSNI(SSL *ssl, const char *fqdn) STUB_RETVAL(false)
+void initialize_session_cache() STUB
+void destruct_session_cache() STUB
+} //namespace Ssl
 
 #endif
@@ -1,10 +1,12 @@
 #include "squid.h"
-#include "tools.h"
+// XXX: need src/ to avoid clashes with ip/tools.h in testIpAddress
+#include "src/tools.h"
 
 #define STUB_API "tools.cc"
 #include "tests/STUB.h"
 
 int DebugSignal = -1;
+SBuf service_name(APP_SHORTNAME);
 void releaseServerSockets(void) STUB
 char * dead_msg(void) STUB_RETVAL(NULL)
 void mail_warranty(void) STUB
@@ -22,15 +22,6 @@ MemObject::endOffset() const
     return 0;
 }
 
-#include "ConfigParser.h"
-
-void
-eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata)
-{
-// CALLED as setUp no-op
-//    fatal("eventAdd. Not implemented.");
-}
-
 /* end */
 
 void
@@ -82,6 +82,7 @@ Thanks!\n"
 static void mail_warranty(void);
 static void restoreCapabilities(int keep);
 int DebugSignal = -1;
+SBuf service_name(APP_SHORTNAME);
 
 #if _SQUID_LINUX_
 /* Workaround for crappy glic header files */
@@ -477,13 +478,13 @@ getMyHostname(void)
 
     host[0] = '\0';
 
-    if (Config.Sockaddr.http && sa.isAnyAddr())
-        sa = Config.Sockaddr.http->s;
+    if (HttpPortList != NULL && sa.isAnyAddr())
+        sa = HttpPortList->s;
 
 #if USE_OPENSSL
 
-    if (Config.Sockaddr.https && sa.isAnyAddr())
-        sa = Config.Sockaddr.https->s;
+    if (HttpsPortList != NULL && sa.isAnyAddr())
+        sa = HttpsPortList->s;
 
 #endif
 
@@ -1131,21 +1132,21 @@ parseEtcHosts(void)
 int
 getMyPort(void)
 {
-    AnyP::PortCfg *p = NULL;
-    if ((p = Config.Sockaddr.http)) {
+    AnyP::PortCfgPointer p;
+    if ((p = HttpPortList) != NULL) {
         // skip any special interception ports
-        while (p && p->flags.isIntercepted())
+        while (p != NULL && p->flags.isIntercepted())
             p = p->next;
-        if (p)
+        if (p != NULL)
             return p->s.port();
     }
 
 #if USE_OPENSSL
-    if ((p = Config.Sockaddr.https)) {
+    if ((p = HttpsPortList) != NULL) {
         // skip any special interception ports
-        while (p && p->flags.isIntercepted())
+        while (p != NULL && p->flags.isIntercepted())
             p = p->next;
-        if (p)
+        if (p != NULL)
             return p->s.port();
     }
 #endif
@@ -34,13 +34,18 @@
 #define SQUID_TOOLS_H_
 
 #include "Packer.h"
+#include "SBuf.h"
 #include "SquidString.h"
 #include "typedefs.h"
 
 class MemBuf;
 
 extern int DebugSignal;
 
+/// The Squid -n parameter service name.
+/// Default is APP_SHORTNAME ('squid').
+extern SBuf service_name;
+
 void kb_incr(kb_t *, size_t);
 void parseEtcHosts(void);
 int getMyPort(void);
@@ -3,9 +3,10 @@ include $(top_srcdir)/src/Common.am
 AUTOMAKE_OPTIONS = subdir-objects
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 LDADD = \
+	$(top_builddir)/src/base/libbase.la \
 	$(top_builddir)/src/globals.o \
 	$(top_builddir)/src/time.o \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -51,20 +52,22 @@ check_PROGRAMS += debug \
 
 tcp_banger2_LDADD = $(top_builddir)/lib/libmiscutil.la
 
-
-DEBUG_SOURCE = test_tools.cc stub_debug.cc stub_tools.cc stub_fatal.cc
+STUBS = stub_debug.cc stub_SBuf.cc stub_tools.cc stub_fatal.cc
+DEBUG_SOURCE = test_tools.cc $(STUBS)
+CLEANFILES += $(STUBS)
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
 	cp $(top_srcdir)/src/tests/stub_debug.cc .
 
+stub_SBuf.cc: $(top_srcdir)/src/tests/stub_SBuf.cc
+	cp $(top_srcdir)/src/tests/stub_SBuf.cc .
+
 stub_tools.cc: $(top_srcdir)/src/tests/stub_tools.cc
 	cp $(top_srcdir)/src/tests/stub_tools.cc .
 
 stub_fatal.cc: $(top_srcdir)/src/tests/stub_fatal.cc
 	cp $(top_srcdir)/src/tests/stub_fatal.cc .
 
-CLEANFILES += stub_debug.cc stub_tools.cc stub_fatal.cc
-
 ## XXX: somewhat broken. Its meant to test our debugs() implementation.
 ## but it has never been linked to the actual src/debug.cc implementation !!
 ## all it tests are the stream operators and macro in src/Debug.h
@@ -74,7 +77,7 @@ ESIExpressions_SOURCES = ESIExpressions.cc $(DEBUG_SOURCE)
 ESIExpressions_LDADD = $(top_builddir)/src/esi/Expression.o \
 		$(LDADD)
 
-mem_node_test_SOURCES = mem_node_test.cc
+mem_node_test_SOURCES = mem_node_test.cc $(DEBUG_SOURCE)
 mem_node_test_LDADD = $(top_builddir)/src/mem_node.o $(LDADD)
 
 mem_hdr_test_SOURCES = mem_hdr_test.cc $(DEBUG_SOURCE)
@@ -83,9 +86,9 @@ mem_hdr_test_LDADD = \
 	$(top_builddir)/src/mem_node.o \
 	$(LDADD)
 
-MemPoolTest_SOURCES = MemPoolTest.cc
+MemPoolTest_SOURCES = MemPoolTest.cc $(DEBUG_SOURCE)
 
-splay_SOURCES = splay.cc
+splay_SOURCES = splay.cc $(DEBUG_SOURCE)
 
 syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
 
@@ -36,13 +36,15 @@
 
 #include <iostream>
 
+#if 0
 /* TODO: put this in a libTest */
 void
 xassert(const char *msg, const char *file, int line)
 {
     std::cout << "Assertion failed: (" << msg << ") at " << file << ":" << line << std::endl;
     exit (1);
 }
+#endif
 
 int
 main(int argc, char **argv)
@@ -9,7 +9,7 @@ include $(top_srcdir)/src/Common.am
 AUTOMAKE_OPTIONS = subdir-objects
 
 ## we need our local files too (but avoid -I. at all costs)
-INCLUDES += -I$(srcdir)
+AM_CPPFLAGS += -I$(srcdir)
 
 SUBDIRS = purge squidclient
 EXTRA_DIST = 
@@ -194,7 +194,7 @@ main(int argc, char *argv[])
         url[BUFSIZ - 1] = '\0';
 
         int optIndex = 0;
-        const char *shortOpStr = "aA:h:j:V:l:P:i:kmnN:p:rsvt:H:T:u:U:w:W:?";
+        const char *shortOpStr = "aA:h:j:V:l:P:i:km:nNp:rsvt:H:T:u:U:w:W:?";
 
         // options for controlling squidclient
         static struct option basicOptions[] = {