@@ -1,3 +1,21 @@
+Changes to squid-3.2.0.12 (17 Sep 2011):
+
+	- Regression Bug 3335: ICAP service is down
+	- Regression Bug 3322: adapt:: and icap:: format codes do not parse
+	- Regression Bug 3303: Support for non-English usernames in log files
+	- Regression Bug 3259: assertion failed: Connection.cc:29: 'fd<0' after REVIVED PARENT
+	- Regression: %I shows hostname on SSL error page
+	- Regression: FTP outgoing port always 'in use' on PASV connections
+	- Bug 3337: (partial) status 200 is not accepted for deny_info
+	- Bug 3319: Inconsistencies in error messages
+	- Bug 3281: pconn in-use while closing assertion
+	- Bug 3243: Fix cases: raw-IPv6, case variant FQDN, internal request
+	- Fixed max-stale check. Entities not exceeding max-stale were marked as stale
+	- Adjust format code %la for intercepted connections
+	- Log ICAP_ERR_GONE ICAP transaction outcome when ICAP initiator disappears early
+	- Send RST packet when closing an ICAP connection after a transaction error
+	- Support maximum field width for string access.log fields
+
 Changes to squid-3.2.0.11 (28 Aug 2011):
 
 	- Bug 3243: CVE-2009-0801 Bypass of browser same-origin access control
@@ -383,9 +383,10 @@ AC_MSG_CHECKING([for atomic operations support])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     int n = 0;
 ]],[[
-    __sync_add_and_fetch(&n, 1); // n becomes 1
-    __sync_fetch_and_add(&n, 1); // n becomes 2
-    __sync_bool_compare_and_swap(&n, 2, 201); // n becomes 201
+    __sync_add_and_fetch(&n, 10); // n becomes 10
+    __sync_fetch_and_add(&n, 20); // n becomes 30
+    __sync_sub_and_fetch(&n, 15); // n becomes 15
+    __sync_bool_compare_and_swap(&n, 15, 201); // n becomes 201
     __sync_fetch_and_and(&n, 200); // n becomes 200
     return (n == 200) ? 0 : -1;
 ]])],
@@ -36,6 +36,7 @@ section 16    Cache Manager Objects
 section 17    Request Forwarding
 section 18    Cache Manager Statistics
 section 19    Store Memory Primitives
+section 20    Memory Cache
 section 20    Storage Manager
 section 20    Storage Manager Heap-based replacement
 section 20    Storage Manager Logging Functions
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.11 release notes</title>
+<title>Squid 3.2.0.12 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.11 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.12 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -50,7 +50,7 @@ NOTIDY=`$(PO2HTML) --help | grep -o "\-\-notidy"`
 		page=`basename $$f`; \
 		$(PO2HTML) $(NOTIDY) --progress=none -i $(top_srcdir)/errors/$$lang.po -t $(top_srcdir)/errors/$$f >$(top_builddir)/errors/$$lang/$$page || exit 1; \
 	    done; \
-	    $(PO2TEXT) -t $(top_srcdir)/errors/templates/error-details.txt -i $(top_srcdir)/errors/$$lang.po > $(top_builddir)/errors/$$lang/error-details.txt || exit 1; \
+	    cp $(top_srcdir)/errors/templates/error-details.txt $(top_builddir)/errors/$$lang/error-details.txt || exit 1; \
 	    echo "done."; \
 	fi; \
 	touch $@
@@ -25,7 +25,7 @@ body
 
 <p>Sorry, you are not currently allowed to request %U from this cache until you have authenticated yourself.</p>
 
-<p>Please contact the <a href="mailto:%w%W">cache administrator</a> if you have difficulties authenticating yourself or <a href="http://%h/cgi-bin/chpasswd.cgi">change</a> your default password.</p>
+<p>Please contact the <a href="mailto:%w%W">cache administrator</a> if you have difficulties authenticating yourself.</p>
 
 <br>
 </div>
@@ -1,11 +1,11 @@
-.if !'po4a'hide' .TH ext_session_acl 8 "19 March 2006"
+.if !'po4a'hide' .TH ext_session_acl 8 "19 September 2011"
 .
 .SH NAME
 .if !'po4a'hide' .B ext_session_acl
 .if !'po4a'hide' \-
 Squid session tracking external acl helper.
 .PP
-Version 1.0
+Version 1.1
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_session_acl
@@ -18,37 +18,61 @@ database
 .SH DESCRIPTION
 .B ext_session_acl
 maintains a concept of sessions by monitoring requests
-and timing out sessions if no requests have been seen for the idle timeout
-timer.
-.PP
-Intended use is for displaying "terms of use" pages, ad popups etc.
+and timing out sessions. The timeout is based either on idle use (
+.B \-t
+) or a fixed period of time (
+.B \-T
+). The former is suitable for displaying terms and conditions to a user; the
+latter is suitable for the display of advertisments or other notices (both as a
+splash page \- see config examples in the wiki online). The session helper can also be used
+to force users to re\-authenticate if the 
+.B %LOGIN 
+and 
+.B \-a
+are both used.
 .
 .SH OPTIONS
 .if !'po4a'hide' .TP 12
 .if !'po4a'hide' .B "\-t timeout"
-.B Timeout
-for any session. If not specified the default is 3600 seconds.
+Idle timeout for any session. The default if not specified (set to 3600 seconds).
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-T timeout"
+Fixed timeout for any session. This will end the session after the timeout regardless
+of a user's activity. If used with
+.B active
+mode, this will terminate the user's session after
+.B timeout
+, after which another
+.B LOGIN
+will be required.
+.B LOGOUT
+will reset the session and timeout.
 .
 .if !'po4a'hide' .TP
 .if !'po4a'hide' .B "\-b path"
 .B Path
 to persistent database. If not specified the session details
 will be kept in memory only and all sessions will reset each time
-Squid restarts it's helpers (Squid restart or rotation of logs).
+Squid restarts its helpers (Squid restart or rotation of logs).
 .
 .if !'po4a'hide' .TP
 .if !'po4a'hide' .B \-a
 Active mode. In this mode sessions are started by evaluating an
 acl with the argument
 .B LOGIN
 , or terminated by the argument
-.B LOGOUT
-.PP
+.B LOGOUT .
 Without this flag the helper automatically starts the session after
 the first request.
-.
 .SH CONFIGURATION
 .PP
+The
+.B ext_session_acl
+helper is a concurrent helper; therefore, the concurrency= option
+.B must
+be specified in the configuration.
+.PP
 Configuration example using the default automatic mode
 .if !'po4a'hide' .RS
 .if !'po4a'hide' .B external_acl_type session ttl=300 negative_ttl=0 children=1 concurrency=200 %LOGIN /usr/local/squid/libexec/ext_session_acl
@@ -52,6 +52,7 @@
 #endif
 
 static int session_ttl = 3600;
+static int fixed_timeout = 0;
 char *db_path = NULL;
 const char *program_name;
 
@@ -101,6 +102,7 @@ static void session_login(const char *details, size_t len)
     data.data = &now;
     data.size = sizeof(now);
     db->put(db, &key, &data, 0);
+    db->sync(db, 0);
 }
 
 static void session_logout(const char *details, size_t len)
@@ -113,8 +115,9 @@ static void session_logout(const char *details, size_t len)
 
 static void usage(void)
 {
-    fprintf(stderr, "Usage: %s [-t session_timeout] [-b dbpath] [-a]\n", program_name);
-    fprintf(stderr, "	-t sessiontimeout	Idle timeout after which sessions will be forgotten\n");
+    fprintf(stderr, "Usage: %s [-t|-T session_timeout] [-b dbpath] [-a]\n", program_name);
+    fprintf(stderr, "	-t sessiontimeout	Idle timeout after which sessions will be forgotten (user activity will reset)\n");
+    fprintf(stderr, "	-T sessiontimeout	Fixed timeout after which sessions will be forgotten (regardless of user activity)\n");
     fprintf(stderr, "	-b dbpath		Path where persistent session database will be kept\n");
     fprintf(stderr, "	-a			Active mode requiring LOGIN argument to start a session\n");
 }
@@ -126,8 +129,10 @@ int main(int argc, char **argv)
 
     program_name = argv[0];
 
-    while ((opt = getopt(argc, argv, "t:b:a?")) != -1) {
+    while ((opt = getopt(argc, argv, "t:T:b:a?")) != -1) {
         switch (opt) {
+        case 'T':
+            fixed_timeout = 1;
         case 't':
             session_ttl = strtol(optarg, NULL, 0);
             break;
@@ -150,8 +155,13 @@ int main(int argc, char **argv)
 
     while (fgets(request, HELPER_INPUT_BUFFER, stdin)) {
         int action = 0;
-        const char *user_key = strtok(request, " \n");
+        const char *channel_id = strtok(request, " ");
         const char *detail = strtok(NULL, "\n");
+        if (detail == NULL) {
+            // Only 1 paramater supplied. We are expecting at least 2 (including the channel ID)
+            fprintf(stderr, "FATAL: %s is concurrent and requires the concurrency option to be specified.\n", program_name);
+            exit(1);
+        }
         const char *lastdetail = strrchr(detail, ' ');
         size_t detail_len = strlen(detail);
         if (lastdetail) {
@@ -165,18 +175,20 @@ int main(int argc, char **argv)
         }
         if (action == -1) {
             session_logout(detail, detail_len);
-            printf("%s OK message=\"Bye\"\n", user_key);
+            printf("%s OK message=\"Bye\"\n", channel_id);
         } else if (action == 1) {
             session_login(detail, detail_len);
-            printf("%s OK message=\"Welcome\"\n", user_key);
+            printf("%s OK message=\"Welcome\"\n", channel_id);
         } else if (session_active(detail, detail_len)) {
-            session_login(detail, detail_len);
-            printf("%s OK\n", user_key);
+            if (fixed_timeout == 0) {
+                session_login(detail, detail_len);
+            }
+            printf("%s OK\n", channel_id);
         } else if (default_action == 1) {
             session_login(detail, detail_len);
-            printf("%s ERR message=\"Welcome\"\n", user_key);
+            printf("%s ERR message=\"Welcome\"\n", channel_id);
         } else {
-            printf("%s ERR message=\"No session available\"\n", user_key);
+            printf("%s ERR message=\"No session available\"\n", channel_id);
         }
     }
     shutdown_db();
@@ -83,14 +83,6 @@ make_snapshot()
 	;;
     esac
   done
-
-  # update web page
-  if [ -x ${dst}/make.sh ]; then
-    cd ${dst}
-    ./make.sh
-    cd ${top}/../release
-  fi
-
 } }
 
 set +e
@@ -1,5 +1,5 @@
 #!/bin/sh -e
-
+echo "RUN: $0"
 if [ $# -lt 1 ]; then
 	echo "Usage: $0 [branch]"
 	echo "Where [branch] is the path under /bzr/ to the branch to snapshot."
@@ -17,9 +17,6 @@ branchpath=${1:-trunk}
 tag=${2:-`basename $branchpath`}
 startdir=${PWD}
 date=`env TZ=GMT date +%Y%m%d`
-revision=`bzr revno`
-
-suffix="${date}-r${revision}"
 
 tmpdir=${TMPDIR:-${PWD}}/${module}-${tag}-mksnapshot
 
@@ -36,6 +33,8 @@ if [ ! -f ${tmpdir}/configure ]; then
 fi
 
 cd ${tmpdir}
+revision=`bzr revno ${BZRROOT}/${module}/${branchpath}`
+suffix="${date}-r${revision}"
 eval `grep "^ *PACKAGE_VERSION=" configure | sed -e 's/-BZR//' | sed -e 's/PACKAGE_//'`
 eval `grep "^ *PACKAGE_TARNAME=" configure | sed -e 's/_TARNAME//'`
 ed -s configure.ac <<EOS
@@ -49,7 +49,8 @@ class DiskFile : public RefCountable
 public:
 
     /// generally useful configuration options supported by some children
-    class Config {
+    class Config
+    {
     public:
         Config(): ioTimeout(0), ioRate(-1) {}
 
@@ -195,7 +195,6 @@ IpcIoFile::read(ReadRequest *readRequest)
            readRequest->offset << ")");
 
     assert(ioRequestor != NULL);
-    assert(readRequest->len >= 0);
     assert(readRequest->offset >= 0);
     Must(!error_);
 
@@ -242,7 +241,6 @@ IpcIoFile::write(WriteRequest *writeRequest)
            writeRequest->offset << ")");
 
     assert(ioRequestor != NULL);
-    assert(writeRequest->len >= 0);
     assert(writeRequest->len > 0); // TODO: work around mmap failures on zero-len?
     assert(writeRequest->offset >= 0);
     Must(!error_);
@@ -147,7 +147,6 @@ MmappedFile::read(ReadRequest *aRequest)
 
     assert(fd >= 0);
     assert(ioRequestor != NULL);
-    assert(aRequest->len >= 0);
     assert(aRequest->len > 0); // TODO: work around mmap failures on zero-len?
     assert(aRequest->offset >= 0);
     assert(!error_); // TODO: propagate instead?
@@ -178,7 +177,6 @@ MmappedFile::write(WriteRequest *aRequest)
 
     assert(fd >= 0);
     assert(ioRequestor != NULL);
-    assert(aRequest->len >= 0);
     assert(aRequest->len > 0); // TODO: work around mmap failures on zero-len?
     assert(aRequest->offset >= 0);
     assert(!error_); // TODO: propagate instead?
@@ -843,7 +843,6 @@ DEFAULT_CACHE_LOG	= $(DEFAULT_LOG_PREFIX)/cache.log
 DEFAULT_ACCESS_LOG	= $(DEFAULT_LOG_PREFIX)/access.log
 DEFAULT_STORE_LOG	= $(DEFAULT_LOG_PREFIX)/store.log
 DEFAULT_NETDB_FILE	= $(DEFAULT_LOG_PREFIX)/netdb.state
-DEFAULT_SWAP_DIR	= $(localstatedir)/cache
 DEFAULT_SSL_DB_DIR	= $(localstatedir)/lib/ssl_db
 DEFAULT_PINGER		= $(libexecdir)/`echo pinger | sed '$(transform);s/$$/$(EXEEXT)/'`
 DEFAULT_UNLINKD		= $(libexecdir)/`echo unlinkd | sed '$(transform);s/$$/$(EXEEXT)/'`
@@ -310,8 +310,17 @@ SwapDir::optionObjectSizeParse(char const *option, const char *value, int isaRec
 
     int64_t size = strtoll(value, NULL, 10);
 
-    if (isaReconfig && *val != size)
-        debugs(3, 1, "Cache dir '" << path << "' object " << option << " now " << size);
+    if (isaReconfig && *val != size) {
+        if (allowOptionReconfigure(option)) {
+            debugs(3, DBG_IMPORTANT, "cache_dir '" << path << "' object " <<
+                   option << " now " << size << " Bytes");
+        } else {
+            debugs(3, DBG_IMPORTANT, "WARNING: cache_dir '" << path << "' "
+                   "object " << option << " cannot be changed dynamically, " <<
+                   "value left unchanged (" << *val << " Bytes)");
+            return true;
+        }
+    }
 
     *val = size;
 
@@ -125,7 +125,7 @@ class SwapDir : public Store
 
     SwapDir(char const *aType);
     virtual ~SwapDir();
-    virtual void reconfigure(int, char *) = 0;
+    virtual void reconfigure() = 0;
     char const *type() const;
 
     virtual bool needsDiskStrand() const; ///< needs a dedicated kid process
@@ -162,6 +162,7 @@ class SwapDir : public Store
     void parseOptions(int reconfiguring);
     void dumpOptions(StoreEntry * e) const;
     virtual ConfigOption *getOptionTree() const;
+    virtual bool allowOptionReconfigure(const char *const) const { return true; }
 
     int64_t sizeInBlocks(const int64_t size) const { return (size + fs.blksize - 1) / fs.blksize; }
 
@@ -1953,13 +1953,13 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
             sd = dynamic_cast<SwapDir *>(swap->swapDirs[i].getRaw());
 
-            if (sd->type() != StoreFileSystem::FileSystems().items[fs]->type()) {
+            if (strcmp(sd->type(), StoreFileSystem::FileSystems().items[fs]->type()) != 0) {
                 debugs(3, 0, "ERROR: Can't change type of existing cache_dir " <<
                        sd->type() << " " << sd->path << " to " << type_str << ". Restart required");
                 return;
             }
 
-            sd->reconfigure (i, path_str);
+            sd->reconfigure();
 
             update_maxobjsize();
 
@@ -3458,7 +3458,7 @@ DOC_END
 
 NAME: netdb_filename
 TYPE: string
-DEFAULT: @DEFAULT_NETDB_FILE@
+DEFAULT: stdio:@DEFAULT_NETDB_FILE@
 LOC: Config.netdbFilename
 IFDEF: USE_ICMP
 DOC_START
@@ -39,7 +39,9 @@
 #include "auth/UserRequest.h"
 #endif
 #include "SquidTime.h"
+#if USE_SSL
 #include "ssl/ErrorDetailManager.h"
+#endif
 #include "Store.h"
 #include "html_quote.h"
 #include "HttpReply.h"
@@ -146,6 +146,11 @@ FwdState::completed()
 
     flags.forward_completed = 1;
 
+    if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
+        debugs(17, 3, HERE << "entry aborted");
+        return ;
+    }
+
 #if URL_CHECKSUM_DEBUG
 
     entry->mem_obj->checkUrlChecksum();
@@ -361,7 +366,6 @@ FwdState::unregister(int fd)
 void
 FwdState::complete()
 {
-    assert(entry->store_status == STORE_PENDING);
     debugs(17, 3, HERE << entry->url() << "\n\tstatus " << entry->getReply()->sline.status  );
 #if URL_CHECKSUM_DEBUG
 
@@ -1017,6 +1021,12 @@ FwdState::reforward()
 {
     StoreEntry *e = entry;
     http_status s;
+
+    if (EBIT_TEST(e->flags, ENTRY_ABORTED)) {
+        debugs(17, 3, HERE << "entry aborted");
+        return 0;
+    }
+
     assert(e->store_status == STORE_PENDING);
     assert(e->mem_obj);
 #if URL_CHECKSUM_DEBUG
@@ -48,7 +48,7 @@ class CossSwapDir : public SwapDir, public IORequestor
     virtual void writeCleanDone();
     virtual void logEntry(const StoreEntry & e, int op) const;
     virtual void parse (int index, char *path);
-    virtual void reconfigure (int, char *);
+    virtual void reconfigure();
     virtual void swappedOut(const StoreEntry &e);
     virtual uint64_t currentSize() const { return cur_size; }
     virtual uint64_t currentCount() const { return n_disk_objects; }
@@ -1036,7 +1036,7 @@ CossSwapDir::parse(int anIndex, char *aPath)
 
 
 void
-CossSwapDir::reconfigure(int index, char *path)
+CossSwapDir::reconfigure()
 {
     const int i = GetInteger();
     if (i <= 0)
@@ -41,6 +41,12 @@ Rock::SwapDir::search(String const url, HttpRequest *)
     return NULL; // XXX: implement
 }
 
+void
+Rock::SwapDir::get(String const key, STOREGETCLIENT cb, void *data)
+{
+    ::SwapDir::get(key, cb, data);
+}
+
 // called when Squid core needs a StoreEntry with a given key
 StoreEntry *
 Rock::SwapDir::get(const cache_key *key)
@@ -248,7 +254,7 @@ Rock::SwapDir::parse(int anIndex, char *aPath)
     fname.append("/rock");
     filePath = xstrdup(fname.termedBuf());
 
-    parseSize();
+    parseSize(false);
     parseOptions(0);
 
     // Current openForWriting() code overwrites the old slot if needed
@@ -259,24 +265,30 @@ Rock::SwapDir::parse(int anIndex, char *aPath)
 }
 
 void
-Rock::SwapDir::reconfigure(int, char *)
+Rock::SwapDir::reconfigure()
 {
-    // TODO: do not update a parameter if we cannot propagate that change
-    // TODO: warn if reconfigure changes any parameter that we cannot update
-    parseSize();
+    parseSize(true);
     parseOptions(1);
     // TODO: can we reconfigure the replacement policy (repl)?
     validateOptions();
 }
 
 /// parse maximum db disk size
 void
-Rock::SwapDir::parseSize()
+Rock::SwapDir::parseSize(const bool reconfiguring)
 {
     const int i = GetInteger();
     if (i < 0)
         fatal("negative Rock cache_dir size value");
-    max_size = static_cast<uint64_t>(i) << 20; // MBytes to Bytes
+    const uint64_t new_max_size =
+        static_cast<uint64_t>(i) << 20; // MBytes to Bytes
+    if (!reconfiguring)
+        max_size = new_max_size;
+    else if (new_max_size != max_size) {
+        debugs(3, DBG_IMPORTANT, "WARNING: cache_dir '" << path << "' size "
+               "cannot be changed dynamically, value left unchanged (" <<
+               (max_size >> 20) << " MB)");
+    }
 }
 
 ConfigOption *
@@ -289,6 +301,13 @@ Rock::SwapDir::getOptionTree() const
     return vector;
 }
 
+bool
+Rock::SwapDir::allowOptionReconfigure(const char *const option) const
+{
+    return strcmp(option, "max-size") != 0 &&
+           ::SwapDir::allowOptionReconfigure(option);
+}
+
 /// parses time-specific options; mimics ::SwapDir::optionObjectSizeParse()
 bool
 Rock::SwapDir::parseTimeOption(char const *option, const char *value, int reconfiguring)
@@ -24,9 +24,10 @@ class SwapDir: public ::SwapDir, public IORequestor
     virtual ~SwapDir();
 
     /* public ::SwapDir API */
-    virtual void reconfigure(int, char *);
+    virtual void reconfigure();
     virtual StoreSearch *search(String const url, HttpRequest *);
     virtual StoreEntry *get(const cache_key *key);
+    virtual void get(String const, STOREGETCLIENT, void * cbdata);
     virtual void disconnect(StoreEntry &e);
     virtual uint64_t currentSize() const;
     virtual uint64_t currentCount() const;
@@ -44,6 +45,7 @@ class SwapDir: public ::SwapDir, public IORequestor
     virtual void create();
     virtual void init();
     virtual ConfigOption *getOptionTree() const;
+    virtual bool allowOptionReconfigure(const char *const option) const;
     virtual bool canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const;
     virtual StoreIOState::Pointer createStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
     virtual StoreIOState::Pointer openStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
@@ -61,7 +63,7 @@ class SwapDir: public ::SwapDir, public IORequestor
     virtual void writeCompleted(int errflag, size_t len, RefCount< ::WriteRequest>);
 
     virtual void parse(int index, char *path);
-    void parseSize(); ///< parses anonymous cache_dir size option
+    void parseSize(const bool reconfiguring); ///< parses anonymous cache_dir size option
     void validateOptions(); ///< warns of configuration problems; may quit
     bool parseTimeOption(char const *option, const char *value, int reconfiguring);
     void dumpTimeOption(StoreEntry * e) const;
@@ -110,7 +110,7 @@ UFSSwapDir::parseSizeL1L2()
  */
 
 void
-UFSSwapDir::reconfigure(int aIndex, char *aPath)
+UFSSwapDir::reconfigure()
 {
     parseSizeL1L2();
     parseOptions(1);
@@ -73,7 +73,7 @@ class UFSSwapDir : public SwapDir
     virtual void writeCleanDone();
     virtual void logEntry(const StoreEntry & e, int op) const;
     virtual void parse(int index, char *path);
-    virtual void reconfigure(int, char *);
+    virtual void reconfigure();
     virtual int callback();
     virtual void sync();
     virtual void swappedOut(const StoreEntry &e);
@@ -669,6 +669,9 @@ FtpStateData::ftpTimeout(const CommTimeoutCbParams &io)
 {
     debugs(9, 4, HERE << io.conn << ": '" << entry->url() << "'" );
 
+    if (abortOnBadEntry("entry went bad while waiting for a timeout"))
+        return;
+
     if (SENT_PASV == state && io.conn->fd == data.conn->fd) {
         /* stupid ftp.netscape.com */
         flags.pasv_supported = false;
@@ -185,7 +185,7 @@ Ip::Address::IsIPv6() const
 bool
 Ip::Address::IsAnyAddr() const
 {
-    return IN6_IS_ADDR_UNSPECIFIED( &m_SocketAddr.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_anyaddr); ;
+    return IN6_IS_ADDR_UNSPECIFIED(&m_SocketAddr.sin6_addr) || IN6_ARE_ADDR_EQUAL(&m_SocketAddr.sin6_addr, &v4_anyaddr);
 }
 
 /// NOTE: Does NOT clear the Port stored. Ony the Address and Type.
@@ -204,7 +204,7 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
 
     natLookup.nl_inport = htons(newConn->local.GetPort());
     newConn->local.GetInAddr(natLookup.nl_inip);
-    natLookup.nl_outport = htons(neConn->remote.GetPort());
+    natLookup.nl_outport = htons(newConn->remote.GetPort());
     newConn->remote.GetInAddr(natLookup.nl_outip);
     natLookup.nl_flags = IPN_TCP;
 
@@ -19,10 +19,11 @@ class AtomicWordT
     AtomicWordT(Value aValue): value(aValue) {} // XXX: unsafe
 
     Value operator +=(int delta) { return __sync_add_and_fetch(&value, delta); }
+    Value operator -=(int delta) { return __sync_sub_and_fetch(&value, delta); }
     Value operator ++() { return *this += 1; }
-    Value operator --() { return *this += -1; }
+    Value operator --() { return *this -= 1; }
     Value operator ++(int) { return __sync_fetch_and_add(&value, 1); }
-    Value operator --(int) { return __sync_fetch_and_add(&value, -1); }
+    Value operator --(int) { return __sync_fetch_and_sub(&value, 1); }
 
     bool swap_if(const int comparand, const int replacement) { return __sync_bool_compare_and_swap(&value, comparand, replacement); }
 
@@ -168,8 +168,7 @@ Ipc::Coordinator::handleCacheMgrRequest(const Mgr::Request& request)
         Mgr::Action::Pointer action =
             CacheManager::GetInstance()->createRequestedAction(request.params);
         AsyncJob::Start(new Mgr::Inquirer(action, request, strands_));
-    }
-    catch (const std::exception &ex) {
+    } catch (const std::exception &ex) {
         debugs(54, DBG_IMPORTANT, "BUG: cannot aggregate mgr:" <<
                request.params.actionName << ": " << ex.what());
         // TODO: Avoid half-baked Connections or teach them how to close.
@@ -13,7 +13,6 @@ Ipc::StoreMap::Owner *
 Ipc::StoreMap::Init(const char *const path, const int limit, const size_t extrasSize)
 {
     assert(limit > 0); // we should not be created otherwise
-    assert(extrasSize >= 0);
     Owner *const owner = shm_new(Shared)(path, limit, extrasSize);
     debugs(54, 5, HERE << "new map [" << path << "] created: " << limit);
     return owner;
@@ -55,8 +55,10 @@ class StoreMap
 public:
     typedef StoreMapSlot Slot;
 
-private:
-    struct Shared {
+    /// data shared across maps in different processes
+    class Shared
+    {
+    public:
         Shared(const int aLimit, const size_t anExtrasSize);
         size_t sharedMemorySize() const;
         static size_t SharedMemorySize(const int limit, const size_t anExtrasSize);
@@ -80,7 +80,7 @@ class Pointer: public RefCount< Object<Class> >
 
     Class *operator ->() const { return Base::operator ->()->theObject; }
     Class &operator *() const { return *Base::operator *().theObject; }
-    Class *const getRaw() const { return Base::getRaw()->theObject; }
+    const Class *getRaw() const { return Base::getRaw()->theObject; }
     Class *getRaw() { return Base::getRaw()->theObject; }
 };
 
@@ -182,10 +182,13 @@ peerCheckNeverDirectDone(allow_t answer, void *data)
         debugs(44, 3, HERE << "direct = " << DirectStr[psstate->direct] << " (never_direct allow)");
         break;
     case ACCESS_DENIED: // not relevant.
+    case ACCESS_DUNNO:  // not relevant.
         break;
-    default: // Oops. Failed to get a result.
+    case ACCESS_AUTH_REQUIRED:
+    case ACCESS_AUTH_EXPIRED_OK:
+    case ACCESS_AUTH_EXPIRED_BAD:
         debugs(44, DBG_IMPORTANT, "WARNING: never_direct resulted in " << answer << ". Username ACLs are not reliable here.");
-        assert(answer != ACCESS_DUNNO);
+        break;
     }
     peerSelectFoo(psstate);
 }
@@ -204,10 +207,13 @@ peerCheckAlwaysDirectDone(allow_t answer, void *data)
         debugs(44, 3, HERE << "direct = " << DirectStr[psstate->direct] << " (always_direct allow)");
         break;
     case ACCESS_DENIED: // not relevant.
+    case ACCESS_DUNNO:  // not relevant.
         break;
-    default: // Oops. Failed to get a result.
+    case ACCESS_AUTH_REQUIRED:
+    case ACCESS_AUTH_EXPIRED_OK:
+    case ACCESS_AUTH_EXPIRED_BAD:
         debugs(44, DBG_IMPORTANT, "WARNING: always_direct resulted in " << answer << ". Username ACLs are not reliable here.");
-        assert(answer != ACCESS_DUNNO);
+        break;
     }
     peerSelectFoo(psstate);
 }
@@ -427,6 +427,35 @@ void Ssl::CertificateDb::save()
         throw std::runtime_error("Failed to write " + db_full + " file");
 }
 
+// Normally defined in defines.h file
+#define countof(arr) (sizeof(arr)/sizeof(*arr))
+void Ssl::CertificateDb::deleteRow(const char **row, int rowIndex)
+{
+    const std::string filename(cert_full + "/" + row[cnlSerial] + ".pem");
+    const FileLocker cert_locker(filename);
+#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+    sk_OPENSSL_PSTRING_delete(db.get()->data, rowIndex);
+#else
+    sk_delete(db.get()->data, rowIndex);
+#endif
+
+    const Columns db_indexes[]={cnlSerial, cnlName};
+    for (unsigned int i = 0; i < countof(db_indexes); i++) {
+#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
+        if (LHASH_OF(OPENSSL_STRING) *fieldIndex =  db.get()->index[db_indexes[i]])
+            lh_OPENSSL_STRING_delete(fieldIndex, (char **)row);
+#else
+        if (LHASH *fieldIndex = db.get()->index[db_indexes[i]])
+            lh_delete(fieldIndex, row);
+#endif
+    }
+
+    subSize(filename);
+    int ret = remove(filename.c_str());
+    if (ret < 0)
+        throw std::runtime_error("Failed to remove certficate file " + filename + " from db");
+}
+
 bool Ssl::CertificateDb::deleteInvalidCertificate()
 {
     if (!db)
@@ -442,15 +471,7 @@ bool Ssl::CertificateDb::deleteInvalidCertificate()
 #endif
 
         if (!sslDateIsInTheFuture(current_row[cnlExp_date])) {
-            std::string filename(cert_full + "/" + current_row[cnlSerial] + ".pem");
-            FileLocker cert_locker(filename);
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
-            sk_OPENSSL_PSTRING_delete(db.get()->data, i);
-#else
-            sk_delete(db.get()->data, i);
-#endif
-            subSize(filename);
-            remove(filename.c_str());
+            deleteRow(current_row, i);
             removed_one = true;
             break;
         }
@@ -478,17 +499,8 @@ bool Ssl::CertificateDb::deleteOldestCertificate()
 #else
     const char **row = (const char **)sk_value(db.get()->data, 0);
 #endif
-    std::string filename(cert_full + "/" + row[cnlSerial] + ".pem");
-    FileLocker cert_locker(filename);
-
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
-    sk_OPENSSL_PSTRING_delete(db.get()->data, 0);
-#else
-    sk_delete(db.get()->data, 0);
-#endif
 
-    subSize(filename);
-    remove(filename.c_str());
+    deleteRow(row, 0);
 
     return true;
 }
@@ -506,15 +518,7 @@ bool Ssl::CertificateDb::deleteByHostname(std::string const & host)
         const char ** current_row = ((const char **)sk_value(db.get()->data, i));
 #endif
         if (host == current_row[cnlName]) {
-            std::string filename(cert_full + "/" + current_row[cnlSerial] + ".pem");
-            FileLocker cert_locker(filename);
-#if OPENSSL_VERSION_NUMBER >= 0x1000004fL
-            sk_OPENSSL_PSTRING_delete(db.get()->data, i);
-#else
-            sk_delete(db.get()->data, i);
-#endif
-            subSize(filename);
-            remove(filename.c_str());
+            deleteRow(current_row, i);
             return true;
         }
     }
@@ -98,6 +98,7 @@ class CertificateDb
     /// Only find certificate in current db and return it.
     bool pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey);
 
+    void deleteRow(const char **row, int rowIndex); ///< Delete a row from TXT_DB
     bool deleteInvalidCertificate(); ///< Delete invalid certificate.
     bool deleteOldestCertificate(); ///< Delete oldest certificate.
     bool deleteByHostname(std::string const & host); ///< Delete using host name.
@@ -28,7 +28,7 @@ TestSwapDir::stat(StoreEntry &) const
 }
 
 void
-TestSwapDir::reconfigure(int, char*)
+TestSwapDir::reconfigure()
 {}
 
 void
@@ -18,7 +18,7 @@ class TestSwapDir : public SwapDir
     virtual void stat(StoreEntry &) const; /* output stats to the provided store entry */
     virtual void swappedOut(const StoreEntry &e) {}
 
-    virtual void reconfigure(int, char*);
+    virtual void reconfigure();
     virtual void init();
     virtual bool canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const;
     virtual StoreIOState::Pointer createStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
@@ -0,0 +1,11 @@
+#include "config.h"
+#include "wordlist.h"
+
+#define STUB_API "wordlist.cc"
+#include "tests/STUB.h"
+
+const char *wordlistAdd(wordlist **, const char *) STUB_RETVAL(NULL);
+void wordlistAddWl(wordlist **, wordlist *) STUB;
+void wordlistJoin(wordlist **, wordlist **) STUB;
+wordlist *wordlistDup(const wordlist *) STUB_RETVAL(NULL);
+void wordlistDestroy(wordlist **) STUB;