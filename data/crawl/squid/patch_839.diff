@@ -66,7 +66,7 @@ void ICAPXaction::start()
 // TODO: obey service-specific, OPTIONS-reported connection limit
 void ICAPXaction::openConnection()
 {
-    IPAddress client_addr;
+    IpAddress client_addr;
 
     Must(connection < 0);
 
@@ -94,7 +94,7 @@ void ICAPXaction::openConnection()
 
     disableRetries(); // we only retry pconn failures
 
-    IPAddress outgoing;
+    IpAddress outgoing;
     connection = comm_open(SOCK_STREAM, 0, outgoing,
                            COMM_NONBLOCKING, s.cfg().uri.buf());
 
@@ -153,7 +153,7 @@ void ICAPXaction::closeConnection()
         }
 
         if (reuseConnection) {
-            IPAddress client_addr;
+            IpAddress client_addr;
             debugs(93,3, HERE << "pushing pconn" << status());
             AsyncCall::Pointer call = NULL;
             commSetTimeout(connection, -1, call);
@@ -107,7 +107,7 @@ Icmp::ipHops(int ttl)
 }
 
 void
-Icmp::Log(const IPAddress &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops)
+Icmp::Log(const IpAddress &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops)
 {
     debugs(42, 2, "pingerLog: " << std::setw(9) << current_time.tv_sec  <<
            "." << std::setfill('0') << std::setw(6) <<
@@ -35,7 +35,7 @@
 #define _INCLUDE_ICMP_H
 
 #include "config.h"
-#include "IPAddress.h"
+#include "IpAddress.h"
 
 #define PINGER_PAYLOAD_SZ	8192
 
@@ -49,15 +49,15 @@
 
 /* This is a line-data format struct. DO NOT alter. */
 struct pingerEchoData {
-    IPAddress to;
+    IpAddress to;
     unsigned char opcode;
     int psize;
     char payload[PINGER_PAYLOAD_SZ];
 };
 
 /* This is a line-data format struct. DO NOT alter. */
 struct pingerReplyData {
-    IPAddress from;
+    IpAddress from;
     unsigned char opcode;
     int rtt;
     int hops;
@@ -111,7 +111,7 @@ class Icmp
      *                Content longer than MAX_PAYLOAD will be truncated.
      \param len       Length of the payload in bytes if any is to be sent or 0.
      */
-    virtual void SendEcho(IPAddress &to, int opcode, const char *payload=NULL, int len=0) =0;
+    virtual void SendEcho(IpAddress &to, int opcode, const char *payload=NULL, int len=0) =0;
 
     /// Handle ICMP responses.
     virtual void Recv(void) =0;
@@ -139,7 +139,7 @@ class Icmp
     int ipHops(int ttl);
 
     /// Log the packet.
-    void Log(const IPAddress &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops);
+    void Log(const IpAddress &addr, const u_int8_t type, const char* pkt_str, const int rtt, const int hops);
 
     /* no use wasting memory */
     int icmp_sock;
@@ -90,7 +90,7 @@ Icmp4::Open(void)
 }
 
 void
-Icmp4::SendEcho(IPAddress &to, int opcode, const char *payload, int len)
+Icmp4::SendEcho(IpAddress &to, int opcode, const char *payload, int len)
 {
     int x;
     LOCAL_ARRAY(char, pkt, MAX_PKT4_SZ);
@@ -36,7 +36,7 @@
 
 #include "config.h"
 #include "Icmp.h"
-#include "IPAddress.h"
+#include "IpAddress.h"
 
 #if HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
@@ -171,7 +171,7 @@ class Icmp4 : public Icmp
     virtual int Open();
 
 #if USE_ICMP
-    virtual void SendEcho(IPAddress &, int, const char*, int);
+    virtual void SendEcho(IpAddress &, int, const char*, int);
     virtual void Recv(void);
 #endif
 };
@@ -133,7 +133,7 @@ Icmp6::Open(void)
  * Generates an RFC 4443 Icmp6 ECHO Packet and sends into the network.
  */
 void
-Icmp6::SendEcho(IPAddress &to, int opcode, const char *payload, int len)
+Icmp6::SendEcho(IpAddress &to, int opcode, const char *payload, int len)
 {
     int x;
     LOCAL_ARRAY(char, pkt, MAX_PKT6_SZ);
@@ -39,7 +39,7 @@
 #if USE_IPV6
 
 #include "Icmp.h"
-#include "IPAddress.h"
+#include "IpAddress.h"
 
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
@@ -79,7 +79,7 @@ class Icmp6 : public Icmp
     virtual int Open();
 
 #if USE_ICMP
-    virtual void SendEcho(IPAddress &, int, const char*, int);
+    virtual void SendEcho(IpAddress &, int, const char*, int);
     virtual void Recv(void);
 #endif
 };
@@ -62,7 +62,7 @@ class IcmpPinger : public Icmp
 
 private:
     // unused in IcmpPinger
-    virtual void SendEcho(IPAddress &to, int opcode, const char *payload, int len) {};
+    virtual void SendEcho(IpAddress &to, int opcode, const char *payload, int len) {};
 
     /**
      * Control channel(s) to squid.
@@ -69,7 +69,7 @@ IcmpSquid::~IcmpSquid()
 #if USE_ICMP
 
 void
-IcmpSquid::SendEcho(IPAddress &to, int opcode, const char *payload, int len)
+IcmpSquid::SendEcho(IpAddress &to, int opcode, const char *payload, int len)
 {
     static pingerEchoData pecho;
     int x, slen;
@@ -141,7 +141,7 @@ IcmpSquid::Recv()
     int n;
     static int fail_count = 0;
     pingerReplyData preply;
-    static IPAddress F;
+    static IpAddress F;
 
     commSetSelect(icmp_sock, COMM_SELECT_READ, icmpSquidRecv, NULL, 0);
     memset(&preply, '\0', sizeof(pingerReplyData));
@@ -196,7 +196,7 @@ IcmpSquid::Recv()
 #endif /* USE_ICMP */
 
 void
-IcmpSquid::DomainPing(IPAddress &to, const char *domain)
+IcmpSquid::DomainPing(IpAddress &to, const char *domain)
 {
 #if USE_ICMP
     debugs(37, 4, HERE << "'" << domain << "' (" << to << ")");
@@ -211,7 +211,7 @@ IcmpSquid::Open(void)
     const char *args[2];
     int rfd;
     int wfd;
-    IPAddress localhost;
+    IpAddress localhost;
 
     /* User configured disabled. */
     if (!Config.pinger.enable) {
@@ -36,7 +36,7 @@
 
 #include "config.h"
 #include "Icmp.h"
-#include "IPAddress.h"
+#include "IpAddress.h"
 
 /**
  * Implements a non-blocking pseudo-ICMP engine for squid internally.
@@ -55,10 +55,10 @@ class IcmpSquid : public Icmp
     virtual int Open();
     virtual void Close();
 
-    void DomainPing(IPAddress &to, const char *domain);
+    void DomainPing(IpAddress &to, const char *domain);
 
 #if USE_ICMP
-    virtual void SendEcho(IPAddress &to, int opcode, const char* payload=NULL, int len=0);
+    virtual void SendEcho(IpAddress &to, int opcode, const char* payload=NULL, int len=0);
     virtual void Recv(void);
 #endif
 };
@@ -54,7 +54,7 @@
 #include "forward.h"
 #include "SquidTime.h"
 #include "wordlist.h"
-#include "IPAddress.h"
+#include "IpAddress.h"
 
 #if USE_ICMP
 #include "icmp/IcmpSquid.h"
@@ -83,10 +83,10 @@ typedef struct {
 static hash_table *addr_table = NULL;
 static hash_table *host_table = NULL;
 
-IPAddress networkFromInaddr(const IPAddress &a);
+IpAddress networkFromInaddr(const IPAddress &a);
 static void netdbRelease(netdbEntry * n);
 
-static void netdbHashInsert(netdbEntry * n, IPAddress &addr);
+static void netdbHashInsert(netdbEntry * n, IpAddress &addr);
 static void netdbHashDelete(const char *key);
 static void netdbHostInsert(netdbEntry * n, const char *hostname);
 static void netdbHostDelete(const net_db_name * x);
@@ -111,7 +111,7 @@ static void netdbExchangeDone(void *);
 static wordlist *peer_names = NULL;
 
 static void
-netdbHashInsert(netdbEntry * n, IPAddress &addr)
+netdbHashInsert(netdbEntry * n, IpAddress &addr)
 {
     networkFromInaddr(addr).NtoA(n->network, MAX_IPSTRLEN);
     n->hash.key = n->network;
@@ -247,7 +247,7 @@ netdbPurgeLRU(void)
 }
 
 static netdbEntry *
-netdbLookupAddr(const IPAddress &addr)
+netdbLookupAddr(const IpAddress &addr)
 {
     netdbEntry *n;
     char *key = new char[MAX_IPSTRLEN];
@@ -257,7 +257,7 @@ netdbLookupAddr(const IPAddress &addr)
 }
 
 static netdbEntry *
-netdbAdd(IPAddress &addr)
+netdbAdd(IpAddress &addr)
 {
     netdbEntry *n;
 
@@ -275,7 +275,7 @@ netdbAdd(IPAddress &addr)
 static void
 netdbSendPing(const ipcache_addrs * ia, void *data)
 {
-    IPAddress addr;
+    IpAddress addr;
     char *hostname = NULL;
     static_cast<generic_cbdata *>(data)->unwrap(&hostname);
     netdbEntry *n;
@@ -340,10 +340,10 @@ netdbSendPing(const ipcache_addrs * ia, void *data)
     xfree(hostname);
 }
 
-IPAddress
-networkFromInaddr(const IPAddress &in)
+IpAddress
+networkFromInaddr(const IpAddress &in)
 {
-    IPAddress out;
+    IpAddress out;
 
     out = in;
 #if USE_IPV6
@@ -536,7 +536,7 @@ netdbReloadState(void)
     netdbEntry *n;
     netdbEntry N;
 
-    IPAddress addr;
+    IpAddress addr;
     int count = 0;
 
     struct timeval start = current_time;
@@ -677,7 +677,7 @@ netdbFreeNameEntry(void *data)
 static void
 netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 {
-    IPAddress addr;
+    IpAddress addr;
 
     netdbExchangeState *ex = (netdbExchangeState *)data;
     int rec_sz = 0;
@@ -937,7 +937,7 @@ netdbPingSite(const char *hostname)
 }
 
 void
-netdbHandlePingReply(const IPAddress &from, int hops, int rtt)
+netdbHandlePingReply(const IpAddress &from, int hops, int rtt)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -984,7 +984,7 @@ netdbFreeMemory(void)
 
 #if 0 // AYJ: Looks to be unused code.
 int
-netdbHops(IPAddress &addr)
+netdbHops(IpAddress &addr)
 {
 #if USE_ICMP
     netdbEntry *n = netdbLookupAddr(addr);
@@ -1151,7 +1151,7 @@ netdbUpdatePeer(HttpRequest * r, peer * e, int irtt, int ihops)
 }
 
 void
-netdbExchangeUpdatePeer(IPAddress &addr, peer * e, double rtt, double hops)
+netdbExchangeUpdatePeer(IpAddress &addr, peer * e, double rtt, double hops)
 {
 #if USE_ICMP
     netdbEntry *n;
@@ -1193,7 +1193,7 @@ netdbExchangeUpdatePeer(IPAddress &addr, peer * e, double rtt, double hops)
 }
 
 void
-netdbDeleteAddrNetwork(IPAddress &addr)
+netdbDeleteAddrNetwork(IpAddress &addr)
 {
 #if USE_ICMP
     netdbEntry *n = netdbLookupAddr(addr);
@@ -1214,7 +1214,7 @@ netdbBinaryExchange(StoreEntry * s)
     HttpReply *reply = new HttpReply;
 #if USE_ICMP
 
-    IPAddress addr;
+    IpAddress addr;
 
     netdbEntry *n;
     int i;
@@ -3,7 +3,7 @@
 
 #include "config.h"
 
-class IPAddress;
+class IpAddress;
 class StoreEntry;
 class HttpRequest;
 
@@ -13,24 +13,24 @@ class HttpRequest;
 
 SQUIDCEXTERN void netdbInit(void);
 
-SQUIDCEXTERN void netdbHandlePingReply(const IPAddress &from, int hops, int rtt);
+SQUIDCEXTERN void netdbHandlePingReply(const IpAddress &from, int hops, int rtt);
 SQUIDCEXTERN void netdbPingSite(const char *hostname);
 SQUIDCEXTERN void netdbDump(StoreEntry *);
 
 #if 0 // AYJ: Looks to be unused now.
-SQUIDCEXTERN int netdbHops(IPAddress &);
+SQUIDCEXTERN int netdbHops(IpAddress &);
 #endif
 
 SQUIDCEXTERN void netdbFreeMemory(void);
 SQUIDCEXTERN int netdbHostHops(const char *host);
 SQUIDCEXTERN int netdbHostRtt(const char *host);
 SQUIDCEXTERN void netdbUpdatePeer(HttpRequest *, peer * e, int rtt, int hops);
 
-SQUIDCEXTERN void netdbDeleteAddrNetwork(IPAddress &addr);
+SQUIDCEXTERN void netdbDeleteAddrNetwork(IpAddress &addr);
 SQUIDCEXTERN void netdbBinaryExchange(StoreEntry *);
 SQUIDCEXTERN void netdbExchangeStart(void *);
 
-SQUIDCEXTERN void netdbExchangeUpdatePeer(IPAddress &, peer *, double, double);
+SQUIDCEXTERN void netdbExchangeUpdatePeer(IpAddress &, peer *, double, double);
 SQUIDCEXTERN peer *netdbClosestParent(HttpRequest *);
 SQUIDCEXTERN void netdbHostData(const char *host, int *samp, int *rtt, int *hops);
 
@@ -16,7 +16,7 @@ class stubIcmp : public Icmp
     virtual void Close() {};
 
     /// Construct ECHO request
-    virtual void SendEcho(IPAddress &to, int opcode, const char *payload, int len) {};
+    virtual void SendEcho(IpAddress &to, int opcode, const char *payload, int len) {};
 
     /// Handle ICMP responses.
     virtual void Recv(void) {};
@@ -1,5 +1,5 @@
 /*
- * $Id: IPAddress.cc,v 1.4 2008/02/15 09:45:57 amosjeffries Exp $
+ * $Id: IpAddress.cc,v 1.4 2008/02/15 09:45:57 amosjeffries Exp $
  *
  * DEBUG: section 14   IP Storage and Handling
  * AUTHOR: Amos Jeffries
@@ -16,7 +16,7 @@
  *  developed and/or copyrighted by other sources.  Please see the
  *  CREDITS file for full details.
  *
- *  This IPAddress code is copyright (C) 2007 by Treehouse Networks Ltd
+ *  This IpAddress code is copyright (C) 2007 by Treehouse Networks Ltd
  *  of New Zealand. It is published and Lisenced as an extension of
  *  squid under the same conditions as the main squid application.
  *
@@ -37,7 +37,7 @@
  */
 
 #include "config.h"
-#include "IPAddress.h"
+#include "IpAddress.h"
 #include "util.h"
 
 
@@ -63,7 +63,7 @@
 #ifndef SQUID_DEBUG
 #    define debugs(a,b,c)        //  drop.
 #else
-#warning "IPAddress built with Debugs!!"
+#warning "IpAddress built with Debugs!!"
 #    include "../src/Debug.h"
 #endif
 
@@ -91,7 +91,7 @@ static const unsigned int MAX_IP6_STRLEN = STRLEN_IP6R;
 #if USE_IPV6
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("IPAddress invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
+		printf("IpAddress invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
 		printf("ADDRESS:"); \
 		for(unsigned int i = 0; i < sizeof(m_SocketAddr.sin6_addr); i++) { \
 			printf(" %x", m_SocketAddr.sin6_addr.s6_addr[i]); \
@@ -100,24 +100,24 @@ static const unsigned int MAX_IP6_STRLEN = STRLEN_IP6R;
 #else
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("IPAddress invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
+		printf("IpAddress invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
 		printf("ADDRESS: %x\n", (unsigned int)m_SocketAddr.sin_addr.s_addr); \
 		assert(b); \
 	}
 #endif
 
-IPAddress::IPAddress()
+IpAddress::IPAddress()
 {
     SetEmpty();
 }
 
-IPAddress::~IPAddress()
+IpAddress::~IPAddress()
 {
-    memset(this,0,sizeof(IPAddress));
+    memset(this,0,sizeof(IpAddress));
 }
 
 int
-IPAddress::GetCIDR() const
+IpAddress::GetCIDR() const
 {
     uint8_t shift,byte;
     uint8_t bit,caught;
@@ -166,7 +166,7 @@ IPAddress::GetCIDR() const
     return len;
 }
 
-const int IPAddress::ApplyMask(IPAddress const &mask_addr)
+const int IpAddress::ApplyMask(IPAddress const &mask_addr)
 {
     uint32_t *p1 = (uint32_t*)(&m_SocketAddr.sin6_addr);
     uint32_t const *p2 = (uint32_t const *)(&mask_addr.m_SocketAddr.sin6_addr);
@@ -186,7 +186,7 @@ const int IPAddress::ApplyMask(IPAddress const &mask_addr)
     return changes;
 }
 
-bool IPAddress::ApplyMask(const unsigned int cidr, int mtype)
+bool IpAddress::ApplyMask(const unsigned int cidr, int mtype)
 {
     uint8_t clearbits = 0;
     uint8_t* p = NULL;
@@ -239,12 +239,12 @@ bool IPAddress::ApplyMask(const unsigned int cidr, int mtype)
     return true;
 }
 
-bool IPAddress::IsSockAddr() const
+bool IpAddress::IsSockAddr() const
 {
     return (m_SocketAddr.sin6_port != 0);
 }
 
-bool IPAddress::IsIPv4() const
+bool IpAddress::IsIPv4() const
 {
 #if USE_IPV6
 
@@ -262,7 +262,7 @@ bool IPAddress::IsIPv4() const
 #endif
 }
 
-bool IPAddress::IsIPv6() const
+bool IpAddress::IsIPv6() const
 {
 #if USE_IPV6
 
@@ -279,7 +279,7 @@ bool IPAddress::IsIPv6() const
 #endif
 }
 
-bool IPAddress::IsAnyAddr() const
+bool IpAddress::IsAnyAddr() const
 {
 #if USE_IPV6
     return     m_SocketAddr.sin6_addr.s6_addr32[0] == 0
@@ -294,7 +294,7 @@ bool IPAddress::IsAnyAddr() const
 }
 
 /// NOTE: Does NOT clear the Port stored. Ony the Address and Type.
-void IPAddress::SetAnyAddr()
+void IpAddress::SetAnyAddr()
 {
 #if USE_IPV6
     memset(&m_SocketAddr.sin6_addr, 0, sizeof(struct in6_addr) );
@@ -303,13 +303,13 @@ void IPAddress::SetAnyAddr()
 #endif
 }
 
-/// NOTE: completely empties the IPAddress structure. Address, Port, Type, everything.
-void IPAddress::SetEmpty()
+/// NOTE: completely empties the IpAddress structure. Address, Port, Type, everything.
+void IpAddress::SetEmpty()
 {
     memset(&m_SocketAddr, 0, sizeof(m_SocketAddr) );
 }
 
-bool IPAddress::SetIPv4()
+bool IpAddress::SetIPv4()
 {
 #if USE_IPV6
 
@@ -336,7 +336,7 @@ bool IPAddress::SetIPv4()
 #endif
 }
 
-bool IPAddress::IsLocalhost() const
+bool IpAddress::IsLocalhost() const
 {
 #if USE_IPV6
     return    (   m_SocketAddr.sin6_addr.s6_addr32[0] == 0
@@ -359,7 +359,7 @@ bool IPAddress::IsLocalhost() const
 #endif
 }
 
-void IPAddress::SetLocalhost()
+void IpAddress::SetLocalhost()
 {
 #if USE_IPV6
     SetAnyAddr();
@@ -372,7 +372,7 @@ void IPAddress::SetLocalhost()
 #endif
 }
 
-bool IPAddress::IsNoAddr() const
+bool IpAddress::IsNoAddr() const
 {
     // IFF the address == 0xff..ff (all ones)
 #if USE_IPV6
@@ -387,7 +387,7 @@ bool IPAddress::IsNoAddr() const
 #endif
 }
 
-void IPAddress::SetNoAddr()
+void IpAddress::SetNoAddr()
 {
 #if USE_IPV6
     memset(&m_SocketAddr.sin6_addr, 0xFFFFFFFF, sizeof(struct in6_addr) );
@@ -400,7 +400,7 @@ void IPAddress::SetNoAddr()
 
 #if USE_IPV6
 
-bool IPAddress::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
+bool IpAddress::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
 {
     char *p = buf;
     unsigned char const *r = dat.s6_addr;
@@ -428,7 +428,7 @@ bool IPAddress::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr
 
 #endif
 
-bool IPAddress::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
+bool IpAddress::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
 {
     unsigned int i = (unsigned int) ntohl(dat.s_addr);
     snprintf(buf, 32, "%u.%u.%u.%u.in-addr.arpa.",
@@ -439,7 +439,7 @@ bool IPAddress::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &
     return true;
 }
 
-bool IPAddress::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
+bool IpAddress::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
 {
 
     if (show_type == AF_UNSPEC) {
@@ -468,29 +468,29 @@ bool IPAddress::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
     return false;
 }
 
-IPAddress& IPAddress::operator =(const IPAddress &s)
+IpAddress& IPAddress::operator =(const IPAddress &s)
 {
-    memcpy(this, &s, sizeof(IPAddress));
+    memcpy(this, &s, sizeof(IpAddress));
     return *this;
 };
 
-IPAddress::IPAddress(const char*s)
+IpAddress::IPAddress(const char*s)
 {
     SetEmpty();
     operator=(s);
 }
 
-bool IPAddress::operator =(const char* s)
+bool IpAddress::operator =(const char* s)
 {
     return LookupHostIP(s, true);
 }
 
-bool IPAddress::GetHostByName(const char* s)
+bool IpAddress::GetHostByName(const char* s)
 {
     return LookupHostIP(s, false);
 }
 
-bool IPAddress::LookupHostIP(const char *s, bool nodns)
+bool IpAddress::LookupHostIP(const char *s, bool nodns)
 {
     int err = 0;
 
@@ -534,13 +534,13 @@ bool IPAddress::LookupHostIP(const char *s, bool nodns)
     return true;
 }
 
-IPAddress::IPAddress(struct sockaddr_in const &s)
+IpAddress::IPAddress(struct sockaddr_in const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IPAddress& IPAddress::operator =(struct sockaddr_in const &s)
+IpAddress& IPAddress::operator =(struct sockaddr_in const &s)
 {
 #if USE_IPV6
     Map4to6((const in_addr)s.sin_addr, m_SocketAddr.sin6_addr);
@@ -557,7 +557,7 @@ IPAddress& IPAddress::operator =(struct sockaddr_in const &s)
     return *this;
 };
 
-IPAddress& IPAddress::operator =(const struct sockaddr_storage &s)
+IpAddress& IPAddress::operator =(const struct sockaddr_storage &s)
 {
 #if USE_IPV6
     /* some AF_* magic to tell socket types apart and what we need to do */
@@ -574,20 +574,20 @@ IPAddress& IPAddress::operator =(const struct sockaddr_storage &s)
     return *this;
 };
 
-void IPAddress::check4Mapped()
+void IpAddress::check4Mapped()
 {
     // obsolete.
     // TODO use this NOW to set the sin6_family properly on exporting. not on import.
 }
 
 #if USE_IPV6
-IPAddress::IPAddress(struct sockaddr_in6 const &s)
+IpAddress::IPAddress(struct sockaddr_in6 const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IPAddress& IPAddress::operator =(struct sockaddr_in6 const &s)
+IpAddress& IPAddress::operator =(struct sockaddr_in6 const &s)
 {
     memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in6));
 
@@ -598,13 +598,13 @@ IPAddress& IPAddress::operator =(struct sockaddr_in6 const &s)
 
 #endif
 
-IPAddress::IPAddress(struct in_addr const &s)
+IpAddress::IPAddress(struct in_addr const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IPAddress& IPAddress::operator =(struct in_addr const &s)
+IpAddress& IPAddress::operator =(struct in_addr const &s)
 {
 #if USE_IPV6
     Map4to6((const in_addr)s, m_SocketAddr.sin6_addr);
@@ -624,13 +624,13 @@ IPAddress& IPAddress::operator =(struct in_addr const &s)
 
 #if USE_IPV6
 
-IPAddress::IPAddress(struct in6_addr const &s)
+IpAddress::IPAddress(struct in6_addr const &s)
 {
     SetEmpty();
     operator=(s);
 };
 
-IPAddress& IPAddress::operator =(struct in6_addr const &s)
+IpAddress& IPAddress::operator =(struct in6_addr const &s)
 {
 
     memcpy(&m_SocketAddr.sin6_addr, &s, sizeof(struct in6_addr));
@@ -644,34 +644,34 @@ IPAddress& IPAddress::operator =(struct in6_addr const &s)
 
 #endif
 
-IPAddress::IPAddress(const IPAddress &s)
+IpAddress::IPAddress(const IPAddress &s)
 {
     SetEmpty();
     operator=(s);
 }
 
-IPAddress::IPAddress(IPAddress *s)
+IpAddress::IPAddress(IPAddress *s)
 {
     SetEmpty();
     operator=(s);
 }
 
-IPAddress& IPAddress::operator =(IPAddress *s)
+IpAddress& IPAddress::operator =(IPAddress *s)
 {
-    IPAddress *tmp = NULL;
+    IpAddress *tmp = NULL;
     if (!s) return *this;
-    tmp = dynamic_cast<IPAddress*>(s);
+    tmp = dynamic_cast<IpAddress*>(s);
     if (!tmp) return *this;
     return operator=(*tmp);
 }
 
-IPAddress::IPAddress(const struct hostent &s)
+IpAddress::IPAddress(const struct hostent &s)
 {
     SetEmpty();
     operator=(s);
 }
 
-bool IPAddress::operator =(const struct hostent &s)
+bool IpAddress::operator =(const struct hostent &s)
 {
 
     struct in_addr* ipv4 = NULL;
@@ -717,13 +717,13 @@ bool IPAddress::operator =(const struct hostent &s)
     return true;
 }
 
-IPAddress::IPAddress(const struct addrinfo &s)
+IpAddress::IPAddress(const struct addrinfo &s)
 {
     SetEmpty();
     operator=(s);
 }
 
-bool IPAddress::operator =(const struct addrinfo &s)
+bool IpAddress::operator =(const struct addrinfo &s)
 {
 
     struct sockaddr_in* ipv4 = NULL;
@@ -792,7 +792,7 @@ bool IPAddress::operator =(const struct addrinfo &s)
     return true;
 }
 
-void IPAddress::GetAddrInfo(struct addrinfo *&dst, int force) const
+void IpAddress::GetAddrInfo(struct addrinfo *&dst, int force) const
 {
     if (dst == NULL) {
         dst = new addrinfo;
@@ -858,7 +858,7 @@ void IPAddress::GetAddrInfo(struct addrinfo *&dst, int force) const
         }
 }
 
-void IPAddress::InitAddrInfo(struct addrinfo *&ai) const
+void IpAddress::InitAddrInfo(struct addrinfo *&ai) const
 {
     if (ai == NULL) {
         ai = new addrinfo;
@@ -875,7 +875,7 @@ void IPAddress::InitAddrInfo(struct addrinfo *&ai) const
 
 }
 
-void IPAddress::FreeAddrInfo(struct addrinfo *&ai) const
+void IpAddress::FreeAddrInfo(struct addrinfo *&ai) const
 {
     if (ai == NULL) return;
 
@@ -891,7 +891,7 @@ void IPAddress::FreeAddrInfo(struct addrinfo *&ai) const
     ai = NULL;
 }
 
-int IPAddress::matchIPAddr(const IPAddress &rhs) const
+int IpAddress::matchIPAddr(const IPAddress &rhs) const
 {
 #if USE_IPV6
     uint8_t *l = (uint8_t*)m_SocketAddr.sin6_addr.s6_addr;
@@ -916,54 +916,54 @@ int IPAddress::matchIPAddr(const IPAddress &rhs) const
     return 0;
 }
 
-bool IPAddress::operator ==(const IPAddress &s) const
+bool IpAddress::operator ==(const IPAddress &s) const
 {
     return (0 == matchIPAddr(s));
 }
 
-bool IPAddress::operator !=(const IPAddress &s) const
+bool IpAddress::operator !=(const IPAddress &s) const
 {
     return ! ( operator==(s) );
 }
 
-bool IPAddress::operator <=(const IPAddress &rhs) const
+bool IpAddress::operator <=(const IPAddress &rhs) const
 {
     if (IsAnyAddr() && !rhs.IsAnyAddr())
         return true;
 
     return (matchIPAddr(rhs) <= 0);
 }
 
-bool IPAddress::operator >=(const IPAddress &rhs) const
+bool IpAddress::operator >=(const IPAddress &rhs) const
 {
     if (IsNoAddr() && !rhs.IsNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) >= 0);
 }
 
-bool IPAddress::operator >(const IPAddress &rhs) const
+bool IpAddress::operator >(const IPAddress &rhs) const
 {
     if (IsNoAddr() && !rhs.IsNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) > 0);
 }
 
-bool IPAddress::operator <(const IPAddress &rhs) const
+bool IpAddress::operator <(const IPAddress &rhs) const
 {
     if (IsNoAddr() && !rhs.IsNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) < 0);
 }
 
-u_short IPAddress::GetPort() const
+u_short IpAddress::GetPort() const
 {
     return ntohs( m_SocketAddr.sin6_port );
 }
 
-u_short IPAddress::SetPort(u_short prt)
+u_short IpAddress::SetPort(u_short prt)
 {
     m_SocketAddr.sin6_port = htons(prt);
 
@@ -980,7 +980,7 @@ u_short IPAddress::SetPort(u_short prt)
  *
  * A copy of the buffer is also returned for simple immediate display.
  */
-char* IPAddress::NtoA(char* buf, const unsigned int blen, int force) const
+char* IpAddress::NtoA(char* buf, const unsigned int blen, int force) const
 {
     // Ensure we have a buffer.
     if (buf == NULL) {
@@ -1035,7 +1035,7 @@ char* IPAddress::NtoA(char* buf, const unsigned int blen, int force) const
     return buf;
 }
 
-unsigned int IPAddress::ToHostname(char *buf, const unsigned int blen) const {
+unsigned int IpAddress::ToHostname(char *buf, const unsigned int blen) const {
     char *p = buf;
 
     if (IsIPv6() && blen > 0) {
@@ -1065,7 +1065,7 @@ unsigned int IPAddress::ToHostname(char *buf, const unsigned int blen) const {
     return (p - buf);
 }
 
-char* IPAddress::ToURL(char* buf, unsigned int blen) const {
+char* IpAddress::ToURL(char* buf, unsigned int blen) const {
     char *p = buf;
 
     // Ensure we have a buffer.
@@ -1087,12 +1087,12 @@ char* IPAddress::ToURL(char* buf, unsigned int blen) const {
     return buf;
 }
 
-void IPAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) const {
+void IpAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) const {
     struct sockaddr_in *sin = NULL;
 
     if ( family == AF_INET && !IsIPv4()) {
         // FIXME INET6: caller using the wrong socket type!
-        debugs(14, DBG_CRITICAL, HERE << "IPAddress::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
+        debugs(14, DBG_CRITICAL, HERE << "IpAddress::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
         assert(false);
     }
 
@@ -1112,15 +1112,15 @@ void IPAddress::GetSockAddr(struct sockaddr_storage &addr, const int family) con
 #endif /* USE_IPV6 */
 }
 
-void IPAddress::GetSockAddr(struct sockaddr_in &buf) const {
+void IpAddress::GetSockAddr(struct sockaddr_in &buf) const {
 #if USE_IPV6
 
     if ( IsIPv4() ) {
         buf.sin_family = AF_INET;
         buf.sin_port = m_SocketAddr.sin6_port;
         Map6to4( m_SocketAddr.sin6_addr, buf.sin_addr);
     } else {
-        debugs(14, DBG_CRITICAL, HERE << "IPAddress::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
+        debugs(14, DBG_CRITICAL, HERE << "IpAddress::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
 
         memset(&buf,0xFFFFFFFF,sizeof(struct sockaddr_in));
         assert(false);
@@ -1145,7 +1145,7 @@ void IPAddress::GetSockAddr(struct sockaddr_in &buf) const {
 
 #if USE_IPV6
 
-void IPAddress::GetSockAddr(struct sockaddr_in6 &buf) const {
+void IpAddress::GetSockAddr(struct sockaddr_in6 &buf) const {
     memcpy(&buf, &m_SocketAddr, sizeof(struct sockaddr_in6));
     /* maintain address family. It may have changed inside us. */
     buf.sin6_family = AF_INET6;
@@ -1160,7 +1160,7 @@ void IPAddress::GetSockAddr(struct sockaddr_in6 &buf) const {
 
 #if USE_IPV6
 
-void IPAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const {
+void IpAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const {
     /* check for special cases */
 
     if ( in.s_addr == 0x00000000) {
@@ -1192,7 +1192,7 @@ void IPAddress::Map4to6(const struct in_addr &in, struct in6_addr &out) const {
     }
 }
 
-void IPAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const {
+void IpAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const {
     /* ANYADDR */
     /* NOADDR */
     /* general */
@@ -1213,13 +1213,13 @@ void IPAddress::Map6to4(const struct in6_addr &in, struct in_addr &out) const {
 #endif
 
 #if USE_IPV6
-void IPAddress::GetInAddr(in6_addr &buf) const {
+void IpAddress::GetInAddr(in6_addr &buf) const {
     memcpy(&buf, &m_SocketAddr.sin6_addr, sizeof(struct in6_addr));
 }
 
 #endif
 
-bool IPAddress::GetInAddr(struct in_addr &buf) const {
+bool IpAddress::GetInAddr(struct in_addr &buf) const {
 
 #if USE_IPV6
     if ( IsIPv4() ) {
@@ -1237,7 +1237,7 @@ bool IPAddress::GetInAddr(struct in_addr &buf) const {
     // default:
     // non-compatible IPv6 Pure Address
 
-    debugs(14,1, HERE << "IPAddress::GetInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
+    debugs(14,1, HERE << "IpAddress::GetInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
     memset(&buf,0xFFFFFFFF,sizeof(struct in_addr));
     assert(false);
     return false;
@@ -1,5 +1,5 @@
 /*
- * $Id: IPAddress.h,v 1.3 2008/02/05 22:39:42 amosjeffries Exp $
+ * $Id: IpAddress.h,v 1.3 2008/02/05 22:39:42 amosjeffries Exp $
  *
  * DEBUG: section 14    IP Storage and Handling
  * AUTHOR: Amos Jeffries
@@ -16,7 +16,7 @@
  *  developed and/or copyrighted by other sources.  Please see the
  *  CREDITS file for full details.
  *
- *  This IPAddress code is copyright (C) 2007 by Treehouse Networks Ltd
+ *  This IpAddress code is copyright (C) 2007 by Treehouse Networks Ltd
  *  of New Zealand. It is published and Lisenced as an extension of
  *  squid under the same conditions as the main squid application.
  *
@@ -97,14 +97,14 @@
 /**
  * Holds and manipulates IPv4, IPv6, and Socket Addresses.
  */
-class IPAddress
+class IpAddress
 {
 
 public:
     /** @name Constructors and Destructor */
     /*@{*/
-    IPAddress();
-    IPAddress(const IPAddress &);
+    IpAddress();
+    IpAddress(const IPAddress &);
 
     /**
      * This constructor takes its own copy of the object pointed to for memory-safe usage later.
@@ -113,35 +113,35 @@ class IPAddress
      \deprecated Use of pointers can be nasty. Consider this a last-resort.
      *           Prefer the by-reference (&) version instead.
      */
-    IPAddress(IPAddress *);
+    IpAddress(IPAddress *);
 
-    IPAddress(const struct in_addr &);
+    IpAddress(const struct in_addr &);
 
-    IPAddress(const struct sockaddr_in &);
+    IpAddress(const struct sockaddr_in &);
 #if USE_IPV6
 
-    IPAddress(const struct in6_addr &);
+    IpAddress(const struct in6_addr &);
 
-    IPAddress(const struct sockaddr_in6 &);
+    IpAddress(const struct sockaddr_in6 &);
 #endif
 
-    IPAddress(const struct hostent &);
-    IPAddress(const struct addrinfo &);
-    IPAddress(const char*);
+    IpAddress(const struct hostent &);
+    IpAddress(const struct addrinfo &);
+    IpAddress(const char*);
     /// Default destructor.
-    ~IPAddress();
+    ~IpAddress();
     /*@}*/
 
     /** @name Assignment Operators */
     /*@{*/
-    IPAddress& operator =(const IPAddress &s);
-    IPAddress& operator =(IPAddress *s);
-    IPAddress& operator =(struct sockaddr_in const &s);
-    IPAddress& operator =(struct sockaddr_storage const &s);
-    IPAddress& operator =(struct in_addr const &s);
+    IpAddress& operator =(const IPAddress &s);
+    IpAddress& operator =(IPAddress *s);
+    IpAddress& operator =(struct sockaddr_in const &s);
+    IpAddress& operator =(struct sockaddr_storage const &s);
+    IpAddress& operator =(struct in_addr const &s);
 #if USE_IPV6
-    IPAddress& operator =(struct in6_addr const &s);
-    IPAddress& operator =(struct sockaddr_in6 const &s);
+    IpAddress& operator =(struct in6_addr const &s);
+    IpAddress& operator =(struct sockaddr_in6 const &s);
 #endif
     bool operator =(const struct hostent &s);
     bool operator =(const struct addrinfo &s);
@@ -150,12 +150,12 @@ class IPAddress
 
     /** @name Boolean Operators */
     /*@{*/
-    bool operator ==(IPAddress const &s) const;
-    bool operator !=(IPAddress const &s) const;
-    bool operator >=(IPAddress const &rhs) const;
-    bool operator <=(IPAddress const &rhs) const;
-    bool operator >(IPAddress const &rhs) const;
-    bool operator <(IPAddress const &rhs) const;
+    bool operator ==(IpAddress const &s) const;
+    bool operator !=(IpAddress const &s) const;
+    bool operator >=(IpAddress const &rhs) const;
+    bool operator <=(IpAddress const &rhs) const;
+    bool operator >(IpAddress const &rhs) const;
+    bool operator <(IpAddress const &rhs) const;
 
 public:
     /* methods */
@@ -182,7 +182,7 @@ class IPAddress
     bool IsSockAddr() const;
 
     /** Content-neutral test for whether the specific IP case ANY_ADDR is stored.
-     *  This is the default content of a new undefined IPAddress object.
+     *  This is the default content of a new undefined IpAddress object.
      \retval true IPv4 0.0.0.0
      \retval true IPv6 ::
      \retval false anything else.
@@ -197,7 +197,7 @@ class IPAddress
     bool IsNoAddr() const;
 
     /** Content-neutral test for whether the specific IP case LOCALHOST is stored.
-     *  This is the default content of a new undefined IPAddress object.
+     *  This is the default content of a new undefined IpAddress object.
      \retval true IPv4 127.0.0.1
      \retval true IPv6 ::1
      \retval false anything else.
@@ -251,7 +251,7 @@ class IPAddress
     /** Apply a mask to the stored address.
      \param mask Netmask format to be bit-mask-AND'd over the stored address.
      */
-    const int ApplyMask(const IPAddress &mask);
+    const int ApplyMask(const IpAddress &mask);
 
     /** Apply a mask to the stored address.
      *  CIDR will be converted appropriate to map the stored content.
@@ -309,10 +309,10 @@ class IPAddress
      \retval  1  IP rhs is greater (numerically) than that stored.
      \retval -1  IP rhs is less (numerically) than that stored.
      */
-    int matchIPAddr(const IPAddress &rhs) const;
+    int matchIPAddr(const IpAddress &rhs) const;
 
     /**
-     *  Get RFC 3493 addrinfo structure from the IPAddress data
+     *  Get RFC 3493 addrinfo structure from the IpAddress data
      *  for protocol-neutral socket operations.
      *  Should be passed a NULL pointer of type struct addrinfo* it will
      *  allocate memory for the structures involved. (see FreeAddrInfo to clear).
@@ -321,7 +321,7 @@ class IPAddress
      *  Some situations may also require an actual call to the system getaddrinfo()
      *  to pull relevant OS details for the socket.
      \par
-     *  IPAddress allocated objects MUST be destructed by IPAddress::FreeAddrInfo
+     *  IpAddress allocated objects MUST be destructed by IPAddress::FreeAddrInfo
      *  System getaddrinfo() allocated objects MUST be freed with system freeaddrinfo()
      \par
      *  Some OS require that IPv4 addresses are pre-mapped by the client.
@@ -337,7 +337,7 @@ class IPAddress
 #endif
 
     /**
-     *  Equivalent to the sysem call freeaddrinfo() but for IPAddress allocated data
+     *  Equivalent to the sysem call freeaddrinfo() but for IpAddress allocated data
      */
     void FreeAddrInfo(struct addrinfo *&ai) const;
 
@@ -370,17 +370,17 @@ class IPAddress
 
     void GetSockAddr(struct sockaddr_storage &addr, const int family) const;
 
-    /// \deprecated Deprecated for public use. Use IPAddress::GetAddrInfo()
+    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     void GetSockAddr(struct sockaddr_in &) const;
 
-    /// \deprecated Deprecated for public use. Use IPAddress::GetAddrInfo()
+    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     bool GetInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
 #if USE_IPV6
 
-    /// \deprecated Deprecated for public use. Use IPAddress::GetAddrInfo()
+    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     void GetSockAddr(struct sockaddr_in6 &) const;
 
-    /// \deprecated Deprecated for public use. Use IPAddress::GetAddrInfo()
+    /// \deprecated Deprecated for public use. Use IpAddress::GetAddrInfo()
     void GetInAddr(struct in6_addr &) const;
 #endif
 
@@ -415,22 +415,22 @@ class IPAddress
 
 
 inline std::ostream &
-operator << (std::ostream &os, const IPAddress &ipa)
+operator << (std::ostream &os, const IpAddress &ipa)
 {
     char buf[MAX_IPSTRLEN];
     os << ipa.ToURL(buf,MAX_IPSTRLEN);
     return os;
 }
 
 // WAS _sockaddr_in_list in an earlier incarnation
-class IPAddress_list
+class IpAddress_list
 {
 public:
-    IPAddress_list() { next = NULL; };
-    ~IPAddress_list() { if (next) delete next; next = NULL; };
+    IpAddress_list() { next = NULL; };
+    ~IpAddress_list() { if (next) delete next; next = NULL; };
 
-    IPAddress s;
-    IPAddress_list *next;
+    IpAddress s;
+    IpAddress_list *next;
 };
 
 
@@ -118,7 +118,7 @@ IpIntercept::StopInterception(const char *str)
 }
 
 int
-IpIntercept::NetfilterInterception(int fd, const IPAddress &me, IPAddress &dst, int silent)
+IpIntercept::NetfilterInterception(int fd, const IpAddress &me, IPAddress &dst, int silent)
 {
 #if LINUX_NETFILTER
     struct addrinfo *lookup = NULL;
@@ -149,7 +149,7 @@ IpIntercept::NetfilterInterception(int fd, const IPAddress &me, IPAddress &dst,
 }
 
 int
-IpIntercept::NetfilterTransparent(int fd, const IPAddress &me, IPAddress &client, int silent)
+IpIntercept::NetfilterTransparent(int fd, const IpAddress &me, IPAddress &client, int silent)
 {
 #if LINUX_NETFILTER
 
@@ -165,7 +165,7 @@ IpIntercept::NetfilterTransparent(int fd, const IPAddress &me, IPAddress &client
 }
 
 int
-IpIntercept::IpfwInterception(int fd, const IPAddress &me, IPAddress &dst, int silent)
+IpIntercept::IpfwInterception(int fd, const IpAddress &me, IPAddress &dst, int silent)
 {
 #if IPFW_TRANSPARENT
     struct addrinfo *lookup = NULL;
@@ -196,7 +196,7 @@ IpIntercept::IpfwInterception(int fd, const IPAddress &me, IPAddress &dst, int s
 }
 
 int
-IpIntercept::NatLookup(int fd, const IPAddress &me, const IPAddress &peer, IPAddress &client, IPAddress &dst)
+IpIntercept::NatLookup(int fd, const IpAddress &me, const IPAddress &peer, IPAddress &client, IPAddress &dst)
 {
 #if IPF_TRANSPARENT  /* --enable-ipf-transparent */
     client = me;
@@ -398,9 +398,9 @@ IpIntercept::NatLookup(int fd, const IPAddress &me, const IPAddress &peer, IPAdd
 }
 
 #if LINUX_TPROXY2
-IpIntercept::SetTproxy2OutgoingAddr(int fd, const IPAddress &src)
+IpIntercept::SetTproxy2OutgoingAddr(int fd, const IpAddress &src)
 {
-    IPAddress addr;
+    IpAddress addr;
     struct in_tproxy itp;
 
     src.GetInAddr(itp.v.addr.faddr);
@@ -7,7 +7,7 @@
 #ifndef SQUID_IPINTERCEPTION_H
 #define SQUID_IPINTERCEPTION_H
 
-class IPAddress;
+class IpAddress;
 
 /* for time_t */
 #include "SquidTime.h"
@@ -27,12 +27,12 @@ class IpIntercept
     ~IpIntercept() {};
 
     /** Perform NAT lookups */
-    int NatLookup(int fd, const IPAddress &me, const IPAddress &peer, IPAddress &client, IPAddress &dst);
+    int NatLookup(int fd, const IpAddress &me, const IPAddress &peer, IPAddress &client, IPAddress &dst);
 
 #if LINUX_TPROXY2
     // only relevant to TPROXY v2 connections.
     // which require the address be set specifically post-connect.
-    int SetTproxy2OutgoingAddr(int fd, const IPAddress &src);
+    int SetTproxy2OutgoingAddr(int fd, const IpAddress &src);
 #endif
 
     /**
@@ -87,7 +87,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int NetfilterInterception(int fd, const IPAddress &me, IPAddress &client, int silent);
+    int NetfilterInterception(int fd, const IpAddress &me, IPAddress &client, int silent);
 
     /**
      * perform Lookups on Netfilter fully-transparent interception targets (TPROXY).
@@ -96,7 +96,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int NetfilterTransparent(int fd, const IPAddress &me, IPAddress &dst, int silent);
+    int NetfilterTransparent(int fd, const IpAddress &me, IPAddress &dst, int silent);
 
     /**
      * perform Lookups on IPFW interception.
@@ -105,7 +105,7 @@ class IpIntercept
      \retval 0     Successfuly located the new address.
      \retval -1    An error occured during NAT lookups.
      */
-    int IpfwInterception(int fd, const IPAddress &me, IPAddress &client, int silent);
+    int IpfwInterception(int fd, const IpAddress &me, IPAddress &client, int silent);
 
 
     int transparent_active;
@@ -7,16 +7,16 @@
 #include <netdb.h>
 #include <string>
 
-#include "testIPAddress.h"
-#include "IPAddress.h"
+#include "testIpAddress.h"
+#include "IpAddress.h"
 
-CPPUNIT_TEST_SUITE_REGISTRATION( testIPAddress );
+CPPUNIT_TEST_SUITE_REGISTRATION( testIpAddress );
 
 
 void
-testIPAddress::testDefaults()
+testIpAddress::testDefaults()
 {
-    IPAddress anIPA;
+    IpAddress anIPA;
 
     /* test stored values */
     CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
@@ -32,15 +32,15 @@ testIPAddress::testDefaults()
 }
 
 void
-testIPAddress::testInAddrConstructor()
+testIpAddress::testInAddrConstructor()
 {
     struct in_addr inval;
     struct in_addr outval;
 
     inval.s_addr = htonl(0xC0A8640C);
     outval.s_addr = htonl(0x00000000);
 
-    IPAddress anIPA(inval);
+    IpAddress anIPA(inval);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -55,7 +55,7 @@ testIPAddress::testInAddrConstructor()
 
 #if USE_IPV6
 void
-testIPAddress::testInAddr6Constructor()
+testIpAddress::testInAddr6Constructor()
 {
     struct in6_addr inval;
     struct in6_addr outval = IN6ADDR_ANY_INIT;
@@ -65,7 +65,7 @@ testIPAddress::testInAddr6Constructor()
     inval.s6_addr32[2] = htonl(0xFFFFFFFF);
     inval.s6_addr32[3] = htonl(0xFFFFFFFF);
 
-    IPAddress anIPA(inval);
+    IpAddress anIPA(inval);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -80,7 +80,7 @@ testIPAddress::testInAddr6Constructor()
 #endif
 
 void
-testIPAddress::testSockAddrConstructor()
+testIpAddress::testSockAddrConstructor()
 {
     struct sockaddr_in insock;
     struct sockaddr_in outsock;
@@ -95,7 +95,7 @@ testIPAddress::testSockAddrConstructor()
     insock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-    IPAddress anIPA((const struct sockaddr_in)insock);
+    IpAddress anIPA((const struct sockaddr_in)insock);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -110,7 +110,7 @@ testIPAddress::testSockAddrConstructor()
 
 #if USE_IPV6
 void
-testIPAddress::testSockAddr6Constructor()
+testIpAddress::testSockAddr6Constructor()
 {
     struct sockaddr_in6 insock;
     struct sockaddr_in6 outsock;
@@ -128,7 +128,7 @@ testIPAddress::testSockAddr6Constructor()
     insock.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 
-    IPAddress anIPA((const struct sockaddr_in6)insock);
+    IpAddress anIPA((const struct sockaddr_in6)insock);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -144,7 +144,7 @@ testIPAddress::testSockAddr6Constructor()
 
 
 void
-testIPAddress::testCopyConstructor()
+testIpAddress::testCopyConstructor()
 {
     struct sockaddr_in insock;
     struct sockaddr_in outsock;
@@ -159,8 +159,8 @@ testIPAddress::testCopyConstructor()
     insock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-    IPAddress inIPA(insock);
-    IPAddress outIPA(inIPA);
+    IpAddress inIPA(insock);
+    IpAddress outIPA(inIPA);
 
 
     /* test stored values */
@@ -175,7 +175,7 @@ testIPAddress::testCopyConstructor()
 }
 
 void
-testIPAddress::testHostentConstructor()
+testIpAddress::testHostentConstructor()
 {
     struct hostent *hp = NULL;
     struct in_addr outval;
@@ -186,7 +186,7 @@ testIPAddress::testHostentConstructor()
     hp = gethostbyname("192.168.100.12");
     CPPUNIT_ASSERT( hp != NULL /* gethostbyname failure.*/ );
 
-    IPAddress anIPA(*hp);
+    IpAddress anIPA(*hp);
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -200,14 +200,14 @@ testIPAddress::testHostentConstructor()
 }
 
 void
-testIPAddress::testStringConstructor()
+testIpAddress::testStringConstructor()
 {
     struct in_addr outval;
     struct in_addr expectval;
 
     expectval.s_addr = htonl(0xC0A8640C);
 
-    IPAddress anIPA = "192.168.100.12";
+    IpAddress anIPA = "192.168.100.12";
 
     /* test stored values */
     CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
@@ -228,7 +228,7 @@ testIPAddress::testStringConstructor()
     expectv6.s6_addr32[2] = htonl(0x00000000);
     expectv6.s6_addr32[3] = htonl(0x00000045);
 
-    IPAddress bnIPA = "2000:800::45";
+    IpAddress bnIPA = "2000:800::45";
 
     /* test stored values */
     CPPUNIT_ASSERT( !bnIPA.IsAnyAddr() );
@@ -241,7 +241,7 @@ testIPAddress::testStringConstructor()
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 
     /* test IPv6 as an old netmask format. This is invalid but sometimes use. */
-    IPAddress cnIPA = "ffff:ffff:fff0::";
+    IpAddress cnIPA = "ffff:ffff:fff0::";
 
     expectv6.s6_addr32[0] = htonl(0xFFFFFFFF);
     expectv6.s6_addr32[1] = htonl(0xFFF00000);
@@ -261,9 +261,9 @@ testIPAddress::testStringConstructor()
 }
 
 void
-testIPAddress::testSetEmpty()
+testIpAddress::testSetEmpty()
 {
-    IPAddress anIPA;
+    IpAddress anIPA;
     struct in_addr inval;
 
     inval.s_addr = htonl(0xC0A8640C);
@@ -294,10 +294,10 @@ testIPAddress::testSetEmpty()
 }
 
 void
-testIPAddress::testBooleans()
+testIpAddress::testBooleans()
 {
-    IPAddress lhsIPA;
-    IPAddress rhsIPA;
+    IpAddress lhsIPA;
+    IpAddress rhsIPA;
     struct in_addr valLow;
     struct in_addr valHigh;
 
@@ -340,11 +340,11 @@ testIPAddress::testBooleans()
 }
 
 void
-testIPAddress::testNtoA()
+testIpAddress::testNtoA()
 {
     struct in_addr inval;
     char buf[MAX_IPSTRLEN];
-    IPAddress anIPA;
+    IpAddress anIPA;
 
     anIPA.SetAnyAddr();
 
@@ -372,15 +372,15 @@ testIPAddress::testNtoA()
 }
 
 void
-testIPAddress::testToURL_fromInAddr()
+testIpAddress::testToURL_fromInAddr()
 {
     char buf[MAX_IPSTRLEN];
     buf[0] = '\0';
     struct in_addr inval;
 
     inval.s_addr = htonl(0xC0A8640C);
 
-    IPAddress anIPA(inval);
+    IpAddress anIPA(inval);
 
     /* test values */
     anIPA.ToURL(buf,MAX_IPSTRLEN);
@@ -396,7 +396,7 @@ testIPAddress::testToURL_fromInAddr()
     ip6val.s6_addr32[2] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[3] = htonl(0xFFFFFFFF);
 
-    IPAddress bnIPA(ip6val);
+    IpAddress bnIPA(ip6val);
 
     bnIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]", buf, 41) == 0 );
@@ -405,7 +405,7 @@ testIPAddress::testToURL_fromInAddr()
 }
 
 void
-testIPAddress::testToURL_fromSockAddr()
+testIpAddress::testToURL_fromSockAddr()
 {
     struct sockaddr_in sock;
     sock.sin_addr.s_addr = htonl(0xC0A8640C);
@@ -415,7 +415,7 @@ testIPAddress::testToURL_fromSockAddr()
     sock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
-    IPAddress anIPA(sock);
+    IpAddress anIPA(sock);
     char buf[MAX_IPSTRLEN];
 
     /* test values */
@@ -437,7 +437,7 @@ testIPAddress::testToURL_fromSockAddr()
     ip6val.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 
-    IPAddress bnIPA(ip6val);
+    IpAddress bnIPA(ip6val);
 
     bnIPA.ToURL(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]:80", buf, 44) == 0 );
@@ -447,14 +447,14 @@ testIPAddress::testToURL_fromSockAddr()
 }
 
 void
-testIPAddress::testGetReverseString()
+testIpAddress::testGetReverseString()
 {
     char buf[MAX_IPSTRLEN];
 
     struct in_addr ipv4val;
     ipv4val.s_addr = htonl(0xC0A8640C);
 
-    IPAddress v4IPA(ipv4val);
+    IpAddress v4IPA(ipv4val);
 
     /* test IPv4 output */
     v4IPA.GetReverseString(buf);
@@ -475,7 +475,7 @@ testIPAddress::testGetReverseString()
     ip6val.s6_addr32[2] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[3] = htonl(0xFFFFFFFF);
 
-    IPAddress v6IPA(ip6val);
+    IpAddress v6IPA(ip6val);
 
     /* test IPv6 output */
     v6IPA.GetReverseString(buf);
@@ -486,11 +486,11 @@ testIPAddress::testGetReverseString()
 }
 
 void
-testIPAddress::testMasking()
+testIpAddress::testMasking()
 {
     char buf[MAX_IPSTRLEN];
-    IPAddress anIPA;
-    IPAddress maskIPA;
+    IpAddress anIPA;
+    IpAddress maskIPA;
 
     /* Test Basic CIDR Routine */
     anIPA.SetAnyAddr();
@@ -529,7 +529,7 @@ testIPAddress::testMasking()
     CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff::", buf, 26) == 0 );
 #endif
 
-    /* Test Network Bitmask from IPAddress */
+    /* Test Network Bitmask from IpAddress */
     anIPA.SetNoAddr();
     maskIPA = "255.255.240.0";
     CPPUNIT_ASSERT_EQUAL( 20 , maskIPA.GetCIDR() );
@@ -580,7 +580,7 @@ testIPAddress::testMasking()
 }
 
 void
-testIPAddress::testAddrInfo()
+testIpAddress::testAddrInfo()
 {
     struct addrinfo *expect;
     struct addrinfo *ipval = NULL;
@@ -590,7 +590,7 @@ testIPAddress::testAddrInfo()
 
     hints.ai_flags = AI_NUMERICHOST;
 
-    IPAddress anIP = "127.0.0.1";
+    IpAddress anIP = "127.0.0.1";
 
     /* assert this just to check that getaddrinfo is working properly */
     CPPUNIT_ASSERT( xgetaddrinfo("127.0.0.1", NULL, &hints, &expect ) == 0 );
@@ -677,7 +677,7 @@ testIPAddress::testAddrInfo()
 }
 
 void
-testIPAddress::testBugNullingDisplay()
+testIpAddress::testBugNullingDisplay()
 {
     // Weird Bug: address set to empty during string conversion somewhere.
     // initial string gets created and returned OK.
@@ -692,7 +692,7 @@ testIPAddress::testBugNullingDisplay()
 
     expectval.s_addr = htonl(0xC0A8640C);
 
-    IPAddress anIPA = "192.168.100.12";
+    IpAddress anIPA = "192.168.100.12";
 
 
     /* test stored values */
@@ -7,9 +7,9 @@
  * test the IP storage type
  */
 
-class testIPAddress : public CPPUNIT_NS::TestFixture
+class testIpAddress : public CPPUNIT_NS::TestFixture
 {
-    CPPUNIT_TEST_SUITE( testIPAddress );
+    CPPUNIT_TEST_SUITE( testIpAddress );
     CPPUNIT_TEST( testDefaults );
     CPPUNIT_TEST( testInAddrConstructor );
 #if USE_IPV6