diff --git a/ChangeLog b/ChangeLog
index 4d443eb..7302bad 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,59 @@
+2005-05-03  Paul D. Smith  <psmith@gnu.org>
+
+	Rename .DEFAULT_TARGET to .DEFAULT_GOAL: in GNU make terminology
+	the targets which are to ultimately be made are called "goals";
+	see the GNU make manual.  Also, MAKECMDGOALS, etc.
+
+	* filedef.h, read.c, main.c: Change .DEFAULT_TARGET to
+	.DEFAULT_GOAL, and default_target_name to default_goal_name.
+	* doc/make.texi (Special Variables): Document .DEFAULT_GOAL.
+
+2005-05-02  Paul D. Smith  <psmith@gnu.org>
+
+	* job.c, vmsjobs.c (vmsWaitForChildren, vms_redirect,
+	vms_handle_apos, vmsHandleChildTerm, reEnableAst, astHandler,
+	tryToSetupYAst, child_execute_job) [VMS]: Move VMS-specific
+	functions to vmsjobs.c.  #include it into jobs.c.
+
+	Grant Taylor <gtaylor@picante.com> reports that -j# can lose
+	jobserver tokens.  I found that this happens when an exported
+	recursive variable contains a $(shell ...) function reference: in
+	this situation we could "forget" to write back a token.
+
+	* job.c, job.h: Add variable jobserver_tokens: counts the tokens
+	we have.  It's not reliable to depend on the number of children in
+	our linked list so keep a separate count.
+	(new_job): Check jobserver_tokens rather than children &&
+	waiting_jobs.  Increment jobserver_tokens when we get one.
+	(free_child): If jobserver_tokens is 0, internal error.  If it's
+	>1, write a token back to the jobserver pipe (we don't write a
+	token for the "free" job).  Decrement jobserver_tokens.
+
+	* main.c: Add variable master_job_slots.
+	(main): Set it to hold the number of jobs requested if we're the
+	master process, when using the jobserver.
+	(die): Sanity checks: first test jobserver_tokens to make sure
+	this process isn't holding any tokens we didn't write back.
+	Second, if master_job_slots is set count the tokens left in the
+	jobserver pipe and ensure it's the same as master_job_slots (- 1).
+
+2005-04-24  Paul D. Smith  <psmith@gnu.org>
+
+	Grant Taylor <gtaylor@picante.com> reports that -j# in conjunction
+	with -l# can lose jobserver tokens, because waiting jobs are not
+	consulted properly when checking for the "free" token.
+
+	* job.c (free_child): Count waiting_jobs as having tokens.
+	* job.c (new_job): Ditto.  Plus, call start_waiting_jobs() here to
+	handle jobs waiting for the load to drop.
+
+2005-04-23  Paul D. Smith  <psmith@gnu.org>
+
+	* main.c (main): Be careful to not core if a variable setting in
+	the environment doesn't contain an '='.  This is illegal but can
+	happen in broken setups.
+	Reported by Joerg Schilling <schilling@fokus.fraunhofer.de>.
+
 2005-04-12  Paul D. Smith  <psmith@gnu.org>
 
 	The second expansion feature causes significant slowdown.  Timing
diff --git a/NEWS b/NEWS
index 3a350da..5ee75ac 100644
--- a/NEWS
+++ b/NEWS
@@ -52,9 +52,8 @@ Version 3.81beta3
 * New special variables available in this release:
    - .FEATURES: Contains a list of special features available in this
      version of GNU make.
-   - .DEFAULT_TARGET: Contains the name of the default target make will
-     use if no targets are provided on the command line.  It can be set
-     to change the default target.
+   - .DEFAULT_GOAL: Set the name of the default goal make will
+     use if no goals are provided on the command line.
    - New automatic variable: $| (added in 3.80, actually): contains all
      the order-only prerequisites defined for the target.
 
diff --git a/doc/make.texi b/doc/make.texi
index 0b2ada9..4d66963 100644
--- a/doc/make.texi
+++ b/doc/make.texi
@@ -671,7 +671,10 @@ from @code{rm} or any other command.
 By default, @code{make} starts with the first target (not targets whose
 names start with @samp{.}).  This is called the @dfn{default goal}.
 (@dfn{Goals} are the targets that @code{make} strives ultimately to
-update.  @xref{Goals, , Arguments to Specify the Goals}.)
+update.    You can override this behavior using the command line
+(@pxref{Goals, , Arguments to Specify the Goals}) or with the
+@code{.DEFAULT_GOAL} special variable (@pxref{Special Variables, ,
+Other Special Variables}).
 @cindex default goal
 @cindex goal, default
 @cindex goal
@@ -1276,6 +1279,55 @@ if they are set by a makefile or on the command line.
 
 @table @code
 
+@vindex $(.DEFAULT_GOAL)
+@vindex .DEFAULT_GOAL @r{(define default goal)}
+@item .DEFAULT_GOAL
+Sets the default goal to be used if no targets were specified on the
+command line (@pxref{Goals, , Arguments to Specify the Goals}).  The
+@code{.DEFAULT_GOAL} variable allows you to discover the current
+default goal, restart the default goal selection algorithm by clearing
+its value, or to explicitly set the default goal. The following
+example illustrates these cases:
+
+@example
+@group
+# Query the default goal.
+ifeq ($(.DEFAULT_GOAL),)
+  $(warning no default goal is set)
+endif
+
+.PHONY: foo
+foo: ; @@echo $@@
+
+$(warning default target is $(.DEFAULT_GOAL))
+
+# Reset the default goal.
+.DEFAULT_GOAL :=
+
+.PHONY: bar
+bar: ; @@echo $@@
+
+$(warning default target is $(.DEFAULT_GOAL))
+
+# Set our own.
+.DEFAULT_GOAL := foo
+@end group
+@end example
+
+This makefile prints:
+
+@example
+@group
+no default goal is set
+default goal is foo
+default goal is bar
+foo
+@end group
+@end example
+
+Note that assigning more than one target name to .DEFAULT_GOAL is
+illegal and will result in an error.
+
 @vindex $(.VARIABLES)
 @vindex .VARIABLES @r{(list of variables)}
 @item .VARIABLES
@@ -6870,11 +6922,14 @@ targets that start with a period).  Therefore, makefiles are usually
 written so that the first target is for compiling the entire program or
 programs they describe.  If the first rule in the makefile has several
 targets, only the first target in the rule becomes the default goal, not
-the whole list.
-
-You can specify a different goal or goals with arguments to @code{make}.
-Use the name of the goal as an argument.  If you specify several goals,
-@code{make} processes each of them in turn, in the order you name them.
+the whole list.  You can manage the selection of the default goal from
+within your makefile using the @code{.DEFAULT_GOAL} variable
+(@pxref{Special Variables, , Other Special Variables}).
+
+You can also specify a different goal or goals with command-line
+arguments to @code{make}.  Use the name of the goal as an argument.
+If you specify several goals, @code{make} processes each of them in
+turn, in the order you name them.
 
 Any target in the makefile may be specified as a goal (unless it
 starts with @samp{-} or contains an @samp{=}, in which case it will be
diff --git a/filedef.h b/filedef.h
index ae45f89..ea5c5bd 100644
--- a/filedef.h
+++ b/filedef.h
@@ -100,7 +100,7 @@ struct file
 
 
 extern struct file *default_goal_file, *suffix_file, *default_file;
-extern char **default_target_name;
+extern char **default_goal_name;
 
 
 extern struct file *lookup_file PARAMS ((char *name));
diff --git a/job.c b/job.c
index 48048d1..75a0133 100644
--- a/job.c
+++ b/job.c
@@ -172,10 +172,6 @@ extern int wait ();
 
 #endif	/* Don't have `union wait'.  */
 
-#ifdef VMS
-static int vms_jobsefnmask = 0;
-#endif /* !VMS */
-
 #ifndef	HAVE_UNISTD_H
 extern int dup2 ();
 extern int execve ();
@@ -203,9 +199,6 @@ static void start_job_command PARAMS ((struct child *child));
 static int load_too_high PARAMS ((void));
 static int job_next_command PARAMS ((struct child *));
 static int start_waiting_job PARAMS ((struct child *));
-#ifdef VMS
-static void vmsWaitForChildren PARAMS ((int *));
-#endif
 
 /* Chain of all live (or recently deceased) children.  */
 
@@ -231,6 +224,9 @@ int unixy_shell = 1;
 
 unsigned long job_counter = 0;
 
+/* Number of jobserver tokens this instance is currently using.  */
+
+unsigned int jobserver_tokens = 0;
 
 #ifdef WINDOWS32
 /*
@@ -400,95 +396,6 @@ child_error (char *target_name, int exit_code, int exit_sig, int coredump,
 #endif /* VMS */
 }
 
-#ifdef VMS
-/* Wait for nchildren children to terminate */
-static void
-vmsWaitForChildren(int *status)
-{
-  while (1)
-    {
-      if (!vms_jobsefnmask)
-	{
-	  *status = 0;
-	  return;
-	}
-
-      *status = sys$wflor (32, vms_jobsefnmask);
-    }
-  return;
-}
-
-/* Set up IO redirection.  */
-
-char *
-vms_redirect (struct dsc$descriptor_s *desc, char *fname, char *ibuf)
-{
-  char *fptr;
-  extern char *vmsify ();
-
-  ibuf++;
-  while (isspace ((unsigned char)*ibuf))
-    ibuf++;
-  fptr = ibuf;
-  while (*ibuf && !isspace ((unsigned char)*ibuf))
-    ibuf++;
-  *ibuf = 0;
-  if (strcmp (fptr, "/dev/null") != 0)
-    {
-      strcpy (fname, vmsify (fptr, 0));
-      if (strchr (fname, '.') == 0)
-	strcat (fname, ".");
-    }
-  desc->dsc$w_length = strlen(fname);
-  desc->dsc$a_pointer = fname;
-  desc->dsc$b_dtype = DSC$K_DTYPE_T;
-  desc->dsc$b_class = DSC$K_CLASS_S;
-
-  if (*fname == 0)
-    printf (_("Warning: Empty redirection\n"));
-  return ibuf;
-}
-
-
-/* found apostrophe at (p-1)
-   inc p until after closing apostrophe.
- */
-
-static char *
-vms_handle_apos (char *p)
-{
-  int alast;
-
-#define SEPCHARS ",/()= "
-
-  alast = 0;
-
-  while (*p != 0)
-    {
-      if (*p == '"')
-	{
-          if (alast)
-            {
-              alast = 0;
-              p++;
-	    }
-	  else
-	    {
-	      p++;
-	      if (strchr (SEPCHARS, *p))
-		break;
-	      alast = 1;
-	    }
-	}
-      else
-	p++;
-    }
-
-  return p;
-}
-
-#endif
-
 
 /* Handle a dead child.  This handler may or may not ever be installed.
 
@@ -525,8 +432,6 @@ child_handler (int sig UNUSED)
 
 extern int shell_function_pid, shell_function_completed;
 
-static int reap_lock = 0;
-
 /* Reap all dead children, storing the returned status and the new command
    state (`cs_finished') in the `file' member of the `struct child' for the
    dead child, and removing the child from the chain.  In addition, if BLOCK
@@ -547,9 +452,6 @@ reap_children (int block, int err)
 # define REAP_MORE dead_children
 #endif
 
-  if (reap_lock)
-    fatal (NILF, _("INTERNAL: reap_children invoked while reap_lock set."));
-
   /* As long as:
 
        We have at least one child outstanding OR a shell function in progress,
@@ -631,6 +533,7 @@ reap_children (int block, int err)
 	  if (any_local)
 	    {
 #ifdef VMS
+              static void vmsWaitForChildren PARAMS ((int *));
 	      vmsWaitForChildren (&status);
 	      pid = c->pid;
 #else
@@ -904,11 +807,14 @@ reap_children (int block, int err)
 static void
 free_child (struct child *child)
 {
-  /* If this child is the only one it was our "free" job, so don't put a
-     token back for it.  This child has already been removed from the list,
-     so if there any left this wasn't the last one.  */
+  if (!jobserver_tokens)
+    fatal (NILF, "INTERNAL: Freeing child 0x%08lx (%s) but no tokens left!\n",
+           (unsigned long int) child, child->file->name);
+
+  /* If we're using the jobserver and this child is not the only outstanding
+     job, put a token back into the pipe for it.  */
 
-  if (job_fds[1] >= 0 && children)
+  if (job_fds[1] >= 0 && jobserver_tokens > 1)
     {
       char token = '+';
       int r;
@@ -923,6 +829,8 @@ free_child (struct child *child)
                     (unsigned long int) child, child->file->name));
     }
 
+  --jobserver_tokens;
+
   if (handling_fatal_signal) /* Don't bother free'ing if about to die.  */
     return;
 
@@ -961,7 +869,7 @@ block_sigs (void)
 #endif
 }
 
-#ifdef	POSIX
+#ifdef POSIX
 void
 unblock_sigs (void)
 {
@@ -1249,7 +1157,6 @@ start_job_command (struct child *child)
       child->remote = 0;
 
 #ifdef VMS
-
       if (!child_execute_job (argv, child)) {
         /* Fork failed!  */
         perror_with_name ("vfork", "");
@@ -1475,7 +1382,6 @@ start_waiting_job (struct child *c)
     }
 
   /* Start the first command; reap_children will run later command lines.  */
-  reap_lock = 1;
   start_job_command (c);
 
   switch (f->command_state)
@@ -1506,8 +1412,6 @@ start_waiting_job (struct child *c)
       break;
     }
 
-  reap_lock = 0;
-
   return 1;
 }
 
@@ -1676,7 +1580,7 @@ new_job (struct file *file)
                       children ? "" : "don't "));
 
         /* If we don't already have a job started, use our "free" token.  */
-        if (!children)
+        if (!jobserver_tokens)
           break;
 
         /* Read a token.  As long as there's no token available we'll block.
@@ -1711,10 +1615,20 @@ new_job (struct file *file)
         /* Reap anything that's currently waiting.  */
         reap_children (0, 0);
 
-        /* If our "free" token has become available, use it.  */
-        if (!children)
+        /* Kick off any jobs we have waiting for an opportunity that
+           can run now (ie waiting for load). */
+        start_waiting_jobs ();
+
+        /* If our "free" slot has become available, use it; we don't need an
+           actual token.  */
+        if (!jobserver_tokens)
           break;
 
+        /* There must be at least one child already, or we have no business
+           waiting for a token. */
+        if (!children)
+          fatal (NILF, "INTERNAL: no children as we go to sleep on read\n");
+
         /* Set interruptible system calls, and read() for a job token.  */
 	set_child_handler_action_flags (0);
 	got_token = read (job_rfd, &token, 1);
@@ -1743,6 +1657,8 @@ new_job (struct file *file)
       }
 #endif
 
+  ++jobserver_tokens;
+
   /* The job is now primed.  Start it running.
      (This will notice if there are in fact no commands.)  */
   (void) start_waiting_job (c);
@@ -1904,578 +1820,9 @@ start_waiting_jobs (void)
 }
 
 #ifndef WINDOWS32
-#ifdef VMS
-#include <descrip.h>
-#include <clidef.h>
-
-/* This is called as an AST when a child process dies (it won't get
-   interrupted by anything except a higher level AST).
-*/
-int vmsHandleChildTerm(struct child *child)
-{
-    int status;
-    register struct child *lastc, *c;
-    int child_failed;
-
-    vms_jobsefnmask &= ~(1 << (child->efn - 32));
-
-    lib$free_ef(&child->efn);
-
-    (void) sigblock (fatal_signal_mask);
-
-    child_failed = !(child->cstatus & 1 || ((child->cstatus & 7) == 0));
-
-    /* Search for a child matching the deceased one.  */
-    lastc = 0;
-#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
-    for (c = children; c != 0 && c != child; lastc = c, c = c->next);
-#else
-    c = child;
-#endif
-
-    if (child_failed && !c->noerror && !ignore_errors_flag)
-      {
-	/* The commands failed.  Write an error message,
-	   delete non-precious targets, and abort.  */
-	child_error (c->file->name, c->cstatus, 0, 0, 0);
-	c->file->update_status = 1;
-	delete_child_targets (c);
-      }
-    else
-      {
-	if (child_failed)
-	  {
-	    /* The commands failed, but we don't care.  */
-	    child_error (c->file->name, c->cstatus, 0, 0, 1);
-	    child_failed = 0;
-	  }
-
-#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
-	/* If there are more commands to run, try to start them.  */
-	start_job (c);
-
-	switch (c->file->command_state)
-	  {
-	  case cs_running:
-	    /* Successfully started.  */
-	    break;
-
-	  case cs_finished:
-	    if (c->file->update_status != 0) {
-		/* We failed to start the commands.  */
-		delete_child_targets (c);
-	    }
-	    break;
-
-	  default:
-	    error (NILF, _("internal error: `%s' command_state"),
-                   c->file->name);
-	    abort ();
-	    break;
-	  }
-#endif /* RECURSIVEJOBS */
-      }
-
-    /* Set the state flag to say the commands have finished.  */
-    c->file->command_state = cs_finished;
-    notice_finished_file (c->file);
-
-#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
-    /* Remove the child from the chain and free it.  */
-    if (lastc == 0)
-      children = c->next;
-    else
-      lastc->next = c->next;
-    free_child (c);
-#endif /* RECURSIVEJOBS */
-
-    /* There is now another slot open.  */
-    if (job_slots_used > 0)
-      --job_slots_used;
-
-    /* If the job failed, and the -k flag was not given, die.  */
-    if (child_failed && !keep_going_flag)
-      die (EXIT_FAILURE);
-
-    (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
-
-    return 1;
-}
-
-/* VMS:
-   Spawn a process executing the command in ARGV and return its pid. */
-
-#define MAXCMDLEN 200
-
-/* local helpers to make ctrl+c and ctrl+y working, see below */
-#include <iodef.h>
-#include <libclidef.h>
-#include <ssdef.h>
-
-static int ctrlMask= LIB$M_CLI_CTRLY;
-static int oldCtrlMask;
-static int setupYAstTried= 0;
-static int pidToAbort= 0;
-static int chan= 0;
-
-static void reEnableAst(void) {
-	lib$enable_ctrl (&oldCtrlMask,0);
-}
-
-static astHandler (void) {
-	if (pidToAbort) {
-		sys$forcex (&pidToAbort, 0, SS$_ABORT);
-		pidToAbort= 0;
-	}
-	kill (getpid(),SIGQUIT);
-}
-
-static void tryToSetupYAst(void) {
-	$DESCRIPTOR(inputDsc,"SYS$COMMAND");
-	int	status;
-	struct {
-		short int	status, count;
-		int	dvi;
-	} iosb;
-
-	setupYAstTried++;
-
-	if (!chan) {
-		status= sys$assign(&inputDsc,&chan,0,0);
-		if (!(status&SS$_NORMAL)) {
-			lib$signal(status);
-			return;
-		}
-	}
-	status= sys$qiow (0, chan, IO$_SETMODE|IO$M_CTRLYAST,&iosb,0,0,
-		astHandler,0,0,0,0,0);
-	if (status==SS$_NORMAL)
-		status= iosb.status;
-        if (status==SS$_ILLIOFUNC || status==SS$_NOPRIV) {
-		sys$dassgn(chan);
-#ifdef	CTRLY_ENABLED_ANYWAY
-		fprintf (stderr,
-                         _("-warning, CTRL-Y will leave sub-process(es) around.\n"));
-#else
-		return;
-#endif
-	}
-	else if (!(status&SS$_NORMAL)) {
-		sys$dassgn(chan);
-		lib$signal(status);
-		return;
-	}
-
-	/* called from AST handler ? */
-	if (setupYAstTried>1)
-		return;
-	if (atexit(reEnableAst))
-		fprintf (stderr,
-                         _("-warning, you may have to re-enable CTRL-Y handling from DCL.\n"));
-	status= lib$disable_ctrl (&ctrlMask, &oldCtrlMask);
-	if (!(status&SS$_NORMAL)) {
-		lib$signal(status);
-		return;
-	}
-}
-int
-child_execute_job (char *argv, struct child *child)
-{
-  int i;
-  static struct dsc$descriptor_s cmddsc;
-  static struct dsc$descriptor_s pnamedsc;
-  static struct dsc$descriptor_s ifiledsc;
-  static struct dsc$descriptor_s ofiledsc;
-  static struct dsc$descriptor_s efiledsc;
-  int have_redirection = 0;
-  int have_newline = 0;
-
-  int spflags = CLI$M_NOWAIT;
-  int status;
-  char *cmd = alloca (strlen (argv) + 512), *p, *q;
-  char ifile[256], ofile[256], efile[256];
-  char *comname = 0;
-  char procname[100];
-  int in_string;
-
-  /* Parse IO redirection.  */
-
-  ifile[0] = 0;
-  ofile[0] = 0;
-  efile[0] = 0;
-
-  DB (DB_JOBS, ("child_execute_job (%s)\n", argv));
-
-  while (isspace ((unsigned char)*argv))
-    argv++;
-
-  if (*argv == 0)
-    return 0;
-
-  sprintf (procname, "GMAKE_%05x", getpid () & 0xfffff);
-  pnamedsc.dsc$w_length = strlen(procname);
-  pnamedsc.dsc$a_pointer = procname;
-  pnamedsc.dsc$b_dtype = DSC$K_DTYPE_T;
-  pnamedsc.dsc$b_class = DSC$K_CLASS_S;
-
-  in_string = 0;
-  /* Handle comments and redirection. */
-  for (p = argv, q = cmd; *p; p++, q++)
-    {
-      if (*p == '"')
-        in_string = !in_string;
-      if (in_string)
-        {
-          *q = *p;
-          continue;
-        }
-      switch (*p)
-	{
-	  case '#':
-	    *p-- = 0;
-	    *q-- = 0;
-	    break;
-	  case '\\':
-	    p++;
-	    if (*p == '\n')
-	      p++;
-	    if (isspace ((unsigned char)*p))
-	      {
-		do { p++; } while (isspace ((unsigned char)*p));
-		p--;
-	      }
-	    *q = *p;
-	    break;
-	  case '<':
-	    p = vms_redirect (&ifiledsc, ifile, p);
-	    *q = ' ';
-	    have_redirection = 1;
-	    break;
-	  case '>':
-	    have_redirection = 1;
-	    if (*(p-1) == '2')
-	      {
-		q--;
-		if (strncmp (p, ">&1", 3) == 0)
-		  {
-		    p += 3;
-		    strcpy (efile, "sys$output");
-		    efiledsc.dsc$w_length = strlen(efile);
-		    efiledsc.dsc$a_pointer = efile;
-		    efiledsc.dsc$b_dtype = DSC$K_DTYPE_T;
-		    efiledsc.dsc$b_class = DSC$K_CLASS_S;
-		  }
-		else
-		  {
-		    p = vms_redirect (&efiledsc, efile, p);
-		  }
-	      }
-	    else
-	      {
-		p = vms_redirect (&ofiledsc, ofile, p);
-	      }
-	    *q = ' ';
-	    break;
-	  case '\n':
-	    have_newline = 1;
-	  default:
-	    *q = *p;
-	    break;
-	}
-    }
-  *q = *p;
-  while (isspace ((unsigned char)*--q))
-    *q = '\0';
-
-  if (strncmp (cmd, "builtin_", 8) == 0)
-    {
-      child->pid = 270163;
-      child->efn = 0;
-      child->cstatus = 1;
-
-      DB (DB_JOBS, (_("BUILTIN [%s][%s]\n"), cmd, cmd+8));
-
-      p = cmd + 8;
-
-      if ((*(p) == 'c')
-	  && (*(p+1) == 'd')
-	  && ((*(p+2) == ' ') || (*(p+2) == '\t')))
-	{
-	  p += 3;
-	  while ((*p == ' ') || (*p == '\t'))
-	    p++;
-	  DB (DB_JOBS, (_("BUILTIN CD %s\n"), p));
-	  if (chdir (p))
-	    return 0;
-	  else
-	    return 1;
-	}
-      else if ((*(p) == 'r')
-	  && (*(p+1) == 'm')
-	  && ((*(p+2) == ' ') || (*(p+2) == '\t')))
-	{
-	  int in_arg;
-
-	  /* rm  */
-	  p += 3;
-	  while ((*p == ' ') || (*p == '\t'))
-	    p++;
-	  in_arg = 1;
-
-	  DB (DB_JOBS, (_("BUILTIN RM %s\n"), p));
-	  while (*p)
-	    {
-	      switch (*p)
-		{
-		  case ' ':
-		  case '\t':
-		    if (in_arg)
-		      {
-			*p++ = ';';
-			in_arg = 0;
-		      }
-		    break;
-		  default:
-		    break;
-		}
-	      p++;
-	    }
-	}
-      else
-	{
-	  printf(_("Unknown builtin command '%s'\n"), cmd);
-	  fflush(stdout);
-	  return 0;
-	}
-    }
-
-  /* Create a *.com file if either the command is too long for
-     lib$spawn, or the command contains a newline, or if redirection
-     is desired. Forcing commands with newlines into DCLs allows to
-     store search lists on user mode logicals.  */
-
-  if (strlen (cmd) > MAXCMDLEN
-      || (have_redirection != 0)
-      || (have_newline != 0))
-    {
-      FILE *outfile;
-      char c;
-      char *sep;
-      int alevel = 0;	/* apostrophe level */
-
-      if (strlen (cmd) == 0)
-	{
-	  printf (_("Error, empty command\n"));
-	  fflush (stdout);
-	  return 0;
-	}
-
-      outfile = open_tmpfile (&comname, "sys$scratch:CMDXXXXXX.COM");
-      if (outfile == 0)
-	pfatal_with_name (_("fopen (temporary file)"));
-
-      if (ifile[0])
-	{
-	  fprintf (outfile, "$ assign/user %s sys$input\n", ifile);
-          DB (DB_JOBS, (_("Redirected input from %s\n"), ifile));
-	  ifiledsc.dsc$w_length = 0;
-	}
-
-      if (efile[0])
-	{
-	  fprintf (outfile, "$ define sys$error %s\n", efile);
-          DB (DB_JOBS, (_("Redirected error to %s\n"), efile));
-	  efiledsc.dsc$w_length = 0;
-	}
-
-      if (ofile[0])
-	{
-	  fprintf (outfile, "$ define sys$output %s\n", ofile);
-	  DB (DB_JOBS, (_("Redirected output to %s\n"), ofile));
-	  ofiledsc.dsc$w_length = 0;
-	}
-
-      p = sep = q = cmd;
-      for (c = '\n'; c; c = *q++)
-	{
-	  switch (c)
-	    {
-            case '\n':
-              /* At a newline, skip any whitespace around a leading $
-                 from the command and issue exactly one $ into the DCL. */
-              while (isspace ((unsigned char)*p))
-                p++;
-              if (*p == '$')
-                p++;
-              while (isspace ((unsigned char)*p))
-                p++;
-              fwrite (p, 1, q - p, outfile);
-              fputc ('$', outfile);
-              fputc (' ', outfile);
-              /* Reset variables. */
-              p = sep = q;
-              break;
-
-	      /* Nice places for line breaks are after strings, after
-		 comma or space and before slash. */
-            case '"':
-              q = vms_handle_apos (q);
-              sep = q;
-              break;
-            case ',':
-            case ' ':
-              sep = q;
-              break;
-            case '/':
-            case '\0':
-              sep = q - 1;
-              break;
-            default:
-              break;
-	    }
-	  if (sep - p > 78)
-	    {
-	      /* Enough stuff for a line. */
-	      fwrite (p, 1, sep - p, outfile);
-	      p = sep;
-	      if (*sep)
-		{
-		  /* The command continues.  */
-		  fputc ('-', outfile);
-		}
-	      fputc ('\n', outfile);
-	    }
-  	}
-
-      fwrite (p, 1, q - p, outfile);
-      fputc ('\n', outfile);
-
-      fclose (outfile);
-
-      sprintf (cmd, "$ @%s", comname);
-
-      DB (DB_JOBS, (_("Executing %s instead\n"), cmd));
-    }
-
-  cmddsc.dsc$w_length = strlen(cmd);
-  cmddsc.dsc$a_pointer = cmd;
-  cmddsc.dsc$b_dtype = DSC$K_DTYPE_T;
-  cmddsc.dsc$b_class = DSC$K_CLASS_S;
-
-  child->efn = 0;
-  while (child->efn < 32 || child->efn > 63)
-    {
-      status = lib$get_ef ((unsigned long *)&child->efn);
-      if (!(status & 1))
-	return 0;
-    }
-
-  sys$clref (child->efn);
-
-  vms_jobsefnmask |= (1 << (child->efn - 32));
-
-/*
-             LIB$SPAWN  [command-string]
-			[,input-file]
-			[,output-file]
-			[,flags]
-			[,process-name]
-			[,process-id] [,completion-status-address] [,byte-integer-event-flag-num]
-			[,AST-address] [,varying-AST-argument]
-			[,prompt-string] [,cli] [,table]
-*/
-
-#ifndef DONTWAITFORCHILD
-/*
- *	Code to make ctrl+c and ctrl+y working.
- *	The problem starts with the synchronous case where after lib$spawn is
- *	called any input will go to the child. But with input re-directed,
- *	both control characters won't make it to any of the programs, neither
- *	the spawning nor to the spawned one. Hence the caller needs to spawn
- *	with CLI$M_NOWAIT to NOT give up the input focus. A sys$waitfr
- *	has to follow to simulate the wanted synchronous behaviour.
- *	The next problem is ctrl+y which isn't caught by the crtl and
- *	therefore isn't converted to SIGQUIT (for a signal handler which is
- *	already established). The only way to catch ctrl+y, is an AST
- *	assigned to the input channel. But ctrl+y handling of DCL needs to be
- *	disabled, otherwise it will handle it. Not to mention the previous
- *	ctrl+y handling of DCL needs to be re-established before make exits.
- *	One more: At the time of LIB$SPAWN signals are blocked. SIGQUIT will
- *	make it to the signal handler after the child "normally" terminates.
- *	This isn't enough. It seems reasonable for simple command lines like
- *	a 'cc foobar.c' spawned in a subprocess but it is unacceptable for
- *	spawning make. Therefore we need to abort the process in the AST.
- *
- *	Prior to the spawn it is checked if an AST is already set up for
- *	ctrl+y, if not one is set up for a channel to SYS$COMMAND. In general
- *	this will work except if make is run in a batch environment, but there
- *	nobody can press ctrl+y. During the setup the DCL handling of ctrl+y
- *	is disabled and an exit handler is established to re-enable it.
- *	If the user interrupts with ctrl+y, the assigned AST will fire, force
- *	an abort to the subprocess and signal SIGQUIT, which will be caught by
- *	the already established handler and will bring us back to common code.
- *	After the spawn (now /nowait) a sys$waitfr simulates the /wait and
- *	enables the ctrl+y be delivered to this code. And the ctrl+c too,
- *	which the crtl converts to SIGINT and which is caught by the common
- *	signal handler. Because signals were blocked before entering this code
- *	sys$waitfr will always complete and the SIGQUIT will be processed after
- *	it (after termination of the current block, somewhere in common code).
- *	And SIGINT too will be delayed. That is ctrl+c can only abort when the
- *	current command completes. Anyway it's better than nothing :-)
- */
-
-  if (!setupYAstTried)
-    tryToSetupYAst();
-  status = lib$spawn (&cmddsc,					/* cmd-string  */
-		      (ifiledsc.dsc$w_length == 0)?0:&ifiledsc, /* input-file  */
-		      (ofiledsc.dsc$w_length == 0)?0:&ofiledsc, /* output-file */
-		      &spflags,					/* flags  */
-		      &pnamedsc,				/* proc name  */
-		      &child->pid, &child->cstatus, &child->efn,
-		      0, 0,
-		      0, 0, 0);
-  if (status & 1)
-    {
-      pidToAbort= child->pid;
-      status= sys$waitfr (child->efn);
-      pidToAbort= 0;
-      vmsHandleChildTerm(child);
-    }
-#else
-  status = lib$spawn (&cmddsc,
-		      (ifiledsc.dsc$w_length == 0)?0:&ifiledsc,
-		      (ofiledsc.dsc$w_length == 0)?0:&ofiledsc,
-		      &spflags,
-		      &pnamedsc,
-		      &child->pid, &child->cstatus, &child->efn,
-		      vmsHandleChildTerm, child,
-		      0, 0, 0);
-#endif
-
-  if (!(status & 1))
-    {
-      printf (_("Error spawning, %d\n") ,status);
-      fflush (stdout);
-      switch (status)
-        {
-        case 0x1c:
-          errno = EPROCLIM;
-          break;
-        default:
-          errno = EFAIL;
-        }
-    }
-
-  if (comname && !ISDB (DB_JOBS))
-    unlink (comname);
-
-  return (status & 1);
-}
-
-#else /* !VMS */
 
 /* EMX: Start a child process. This function returns the new pid.  */
-# if defined __MSDOS__ ||  defined __EMX__
+# if defined __MSDOS__ || defined __EMX__
 int
 child_execute_job (int stdin_fd, int stdout_fd, char **argv, char **envp)
 {
@@ -2555,7 +1902,6 @@ child_execute_job (int stdin_fd, int stdout_fd, char **argv, char **envp)
   exec_command (argv, envp);
 }
 #endif /* !AMIGA && !__MSDOS__ */
-#endif /* !VMS */
 #endif /* !WINDOWS32 */
 
 #ifndef _AMIGA
@@ -2566,7 +1912,7 @@ child_execute_job (int stdin_fd, int stdout_fd, char **argv, char **envp)
 # ifdef __EMX__
 int
 # else
- void
+void
 # endif
 exec_command (char **argv, char **envp)
 {
@@ -3630,3 +2976,9 @@ dup2 (int old, int new)
   return fd;
 }
 #endif /* !HAPE_DUP2 && !_AMIGA */
+
+/* On VMS systems, include special VMS functions.  */
+
+#ifdef VMS
+#include "vmsjobs.c"
+#endif
diff --git a/job.h b/job.h
index 85176ea..5a0ae75 100644
--- a/job.h
+++ b/job.h
@@ -101,4 +101,6 @@ extern int fatal_signal_mask;
 #endif
 #endif
 
+extern unsigned int jobserver_tokens;
+
 #endif /* SEEN_JOB_H */
diff --git a/main.c b/main.c
index b99bf27..be0bac5 100644
--- a/main.c
+++ b/main.c
@@ -218,6 +218,7 @@ static struct stringlist *makefiles = 0;
 
 unsigned int job_slots = 1;
 unsigned int default_job_slots = 1;
+static unsigned int master_job_slots = 0;
 
 /* Value of job_slots that means no limit.  */
 
@@ -469,9 +470,9 @@ unsigned int makelevel;
 
 struct file *default_goal_file;
 
-/* Pointer to the value of the .DEFAULT_TARGET special
+/* Pointer to the value of the .DEFAULT_GOAL special
    variable.  */
-char ** default_target_name;
+char ** default_goal_name;
 
 /* Pointer to structure for the file .DEFAULT
    whose commands are used for any file that has none of its own.
@@ -1116,7 +1117,7 @@ main (int argc, char **argv, char **envp)
       int do_not_define = 0;
       char *ep = envp[i];
 
-      while (*ep != '=')
+      while (*ep != '\0' && *ep != '=')
         ++ep;
 #ifdef WINDOWS32
       if (!unix_path && strneq(envp[i], "PATH=", 5))
@@ -1558,10 +1559,8 @@ main (int argc, char **argv, char **envp)
   default_file = enter_file (".DEFAULT");
 
   {
-    struct variable *v = define_variable (
-      ".DEFAULT_TARGET", 15, "", o_file, 0);
-
-    default_target_name = &v->value;
+    struct variable *v = define_variable (".DEFAULT_GOAL", 13, "", o_file, 0);
+    default_goal_name = &v->value;
   }
 
   /* Read all the makefiles.  */
@@ -1694,6 +1693,8 @@ main (int argc, char **argv, char **envp)
          top make, we just subtract one from the number the user wants.  We
          want job_slots to be 0 to indicate we're using the jobserver.  */
 
+      master_job_slots = job_slots;
+
       while (--job_slots)
         {
           int r;
@@ -2091,28 +2092,28 @@ main (int argc, char **argv, char **envp)
     /* If there were no command-line goals, use the default.  */
     if (goals == 0)
       {
-        if (**default_target_name != '\0')
+        if (**default_goal_name != '\0')
           {
             if (default_goal_file == 0 ||
-                strcmp (*default_target_name, default_goal_file->name) != 0)
+                strcmp (*default_goal_name, default_goal_file->name) != 0)
               {
-                default_goal_file = lookup_file (*default_target_name);
+                default_goal_file = lookup_file (*default_goal_name);
 
-                /* In case user set .DEFAULT_TARGET to a non-existent target
+                /* In case user set .DEFAULT_GOAL to a non-existent target
                    name let's just enter this name into the table and let
                    the standard logic sort it out. */
                 if (default_goal_file == 0)
                   {
                     struct nameseq *ns;
-                    char *p = *default_target_name;
+                    char *p = *default_goal_name;
 
                     ns = multi_glob (
                       parse_file_seq (&p, '\0', sizeof (struct nameseq), 1),
                       sizeof (struct nameseq));
 
-                    /* .DEFAULT_TARGET should contain one target. */
+                    /* .DEFAULT_GOAL should contain one target. */
                     if (ns->next != 0)
-                      fatal (NILF, _(".DEFAULT_TARGET contains more than one target"));
+                      fatal (NILF, _(".DEFAULT_GOAL contains more than one target"));
 
                     default_goal_file = enter_file (ns->name);
 
@@ -2957,6 +2958,33 @@ die (int status)
       if (print_data_base_flag)
 	print_data_base ();
 
+      /* Sanity: have we written all our jobserver tokens back?  */
+
+      if (jobserver_tokens)
+        error (NILF,
+               "INTERNAL: Exiting with %u jobserver tokens (should be 0)!",
+               jobserver_tokens);
+
+      /* Sanity: If we're the master, were all the tokens written back?  */
+
+      if (master_job_slots)
+        {
+          char token;
+          /* We didn't write one for ourself, so start at 1.  */
+          unsigned int tcnt = 1;
+
+          /* Close the write side, so the read() won't hang.  */
+          close (job_fds[1]);
+
+          while ((err = read (job_fds[0], &token, 1)) == 1)
+            ++tcnt;
+
+          if (tcnt != master_job_slots)
+            error (NILF,
+                   "INTERNAL: Exiting with %u jobserver tokens available; should be %u!",
+                   tcnt, master_job_slots);
+        }
+
       /* Try to move back to the original directory.  This is essential on
 	 MS-DOS (where there is really only one process), and on Unix it
 	 puts core files in the original directory instead of the -C
diff --git a/read.c b/read.c
index fb62ca6..404c803 100644
--- a/read.c
+++ b/read.c
@@ -1215,16 +1215,16 @@ eval (struct ebuffer *ebuf, int set_default)
 
            foo:
 
-           ifeq ($(.DEFAULT_TARGET),foo)
+           ifeq ($(.DEFAULT_GOAL),foo)
               ...
            endif
 
            Because the target is not recorded until after ifeq directive is
-           evaluated the .DEFAULT_TARGET does not contain foo yet as one
+           evaluated the .DEFAULT_GOAL does not contain foo yet as one
            would expect. Because of this we have to move some of the logic
            here.  */
 
-        if (**default_target_name == '\0' && set_default)
+        if (**default_goal_name == '\0' && set_default)
           {
             char* name;
             struct dep *d;
@@ -1277,8 +1277,8 @@ eval (struct ebuffer *ebuf, int set_default)
 
                 if (!reject)
                   {
-                    (void) define_variable_global (
-                      ".DEFAULT_TARGET", 15, t->name, o_file, 0, NILF);
+                    define_variable_global (".DEFAULT_GOAL", 13, t->name,
+                                            o_file, 0, NILF);
                     break;
                   }
               }
@@ -2095,14 +2095,11 @@ record_files (struct nameseq *filenames, char *pattern, char *pattern_percent,
 	  name = f->name;
 	}
 
-      /* See if this target is a default target and update
-         DEFAULT_GOAL_FILE if necessary.  */
-      if (strcmp (*default_target_name, name) == 0 &&
-          (default_goal_file == 0 ||
-           strcmp (default_goal_file->name, name) != 0))
-	{
-          default_goal_file = f;
-	}
+      /* If this target is a default target, update DEFAULT_GOAL_FILE.  */
+      if (strcmp (*default_goal_name, name) == 0
+          && (default_goal_file == 0
+              || strcmp (default_goal_file->name, name) != 0))
+        default_goal_file = f;
     }
 
   if (implicit)
diff --git a/tests/ChangeLog b/tests/ChangeLog
index 698cffb..2a19918 100644
--- a/tests/ChangeLog
+++ b/tests/ChangeLog
@@ -1,3 +1,14 @@
+2005-05-03  Paul D. Smith  <psmith@gnu.org>
+
+	* scripts/variables/DEFAULT_GOAL: Rename DEFAULT_TARGET to
+	DEFAULT_GOAL.
+
+2005-05-02  Paul D. Smith  <psmith@gnu.org>
+
+	* scripts/features/parallelism: Add a test for exporting recursive
+	variables containing $(shell ) calls.  Rewrite this script to use
+	run_make_test() everywhere.
+
 2005-04-07  Paul D. Smith  <psmith@gnu.org>
 
 	* scripts/targets/SECONDARY: Add a test for Savannah bug #12331.
diff --git a/tests/scripts/features/parallelism b/tests/scripts/features/parallelism
index f500352..4768539 100644
--- a/tests/scripts/features/parallelism
+++ b/tests/scripts/features/parallelism
@@ -26,58 +26,32 @@ else {
   $sleep_command = "sleep";
 }
 
-open(MAKEFILE,"> $makefile");
 
-print MAKEFILE <<"EOF";
+run_make_test("
 all : def_1 def_2 def_3
 def_1 : ; \@echo ONE; $sleep_command 3 ; echo TWO
 def_2 : ; \@$sleep_command 2 ; echo THREE
-def_3 : ; \@$sleep_command 1 ; echo FOUR
-EOF
-
-close(MAKEFILE);
-
-&run_make_with_options($makefile, "-j 4", &get_logfile);
-$answer = "ONE\nFOUR\nTHREE\nTWO\n";
-&compare_output($answer, &get_logfile(1));
-
+def_3 : ; \@$sleep_command 1 ; echo FOUR",
+              '-j4', "ONE\nFOUR\nTHREE\nTWO");
 
 # Test parallelism with included files.  Here we sleep/echo while
 # building the included files, to test that they are being built in
 # parallel.
-
-$makefile2 = &get_tmpfile;
-
-open(MAKEFILE,"> $makefile2");
-
-print MAKEFILE <<"EOF";
+run_make_test("
 all: 1 2; \@echo success
-
 -include 1.inc 2.inc
-
-1.inc: ; \@echo ONE.inc; $sleep_command 2; echo TWO.inc; echo "1: ; \@echo ONE; $sleep_command 2; echo TWO" > \$\@
-2.inc: ; \@$sleep_command 1; echo THREE.inc; echo "2: ; \@$sleep_command 1; echo THREE" > \$\@
-EOF
-
-close(MAKEFILE);
-
-&run_make_with_options("$makefile2", "-j 4", &get_logfile);
-$answer = "ONE.inc\nTHREE.inc\nTWO.inc\nONE\nTHREE\nTWO\nsuccess\n";
-&compare_output($answer, &get_logfile(1));
+1.inc: ; \@echo ONE.inc; $sleep_command 2; echo TWO.inc; echo '1: ; \@echo ONE; $sleep_command 2; echo TWO' > \$\@
+2.inc: ; \@$sleep_command 1; echo THREE.inc; echo '2: ; \@$sleep_command 1; echo THREE' > \$\@",
+              "-j4",
+              "ONE.inc\nTHREE.inc\nTWO.inc\nONE\nTHREE\nTWO\nsuccess\n");
 
 unlink('1.inc', '2.inc');
 
 
 # Test parallelism with included files--this time recurse first and make
 # sure the jobserver works.
-
-$makefile3 = &get_tmpfile;
-
-open(MAKEFILE,"> $makefile3");
-
-print MAKEFILE <<"EOF";
-recurse: ; \@\$(MAKE) --no-print-directory -f $makefile3 INC=yes all
-
+run_make_test("
+recurse: ; \@\$(MAKE) --no-print-directory -f #MAKEFILE# INC=yes all
 all: 1 2; \@echo success
 
 INC = no
@@ -85,23 +59,28 @@ ifeq (\$(INC),yes)
 -include 1.inc 2.inc
 endif
 
-1.inc: ; \@echo ONE.inc; $sleep_command 2; echo TWO.inc; echo "1: ; \@echo ONE; $sleep_command 2; echo TWO" > \$\@
-2.inc: ; \@$sleep_command 1; echo THREE.inc; echo "2: ; \@$sleep_command 1; echo THREE" > \$\@
-EOF
+1.inc: ; \@echo ONE.inc; $sleep_command 2; echo TWO.inc; echo '1: ; \@echo ONE; $sleep_command 2; echo TWO' > \$\@
+2.inc: ; \@$sleep_command 1; echo THREE.inc; echo '2: ; \@$sleep_command 1; echo THREE' > \$\@",
+              "-j4",
+              "ONE.inc\nTHREE.inc\nTWO.inc\nONE\nTHREE\nTWO\nsuccess\n");
 
-close(MAKEFILE);
+unlink('1.inc', '2.inc');
 
-&run_make_with_options("$makefile3", "-j 4", &get_logfile);
-$answer = "ONE.inc\nTHREE.inc\nTWO.inc\nONE\nTHREE\nTWO\nsuccess\n";
-&compare_output($answer, &get_logfile(1));
+# Grant Taylor reports a problem where tokens can be lost (not written back
+# to the pipe when they should be): this happened when there is a $(shell ...)
+# function in an exported recursive variable.  I added some code to check
+# for this situation and print a message if it occurred.  This test used
+# to trigger this code when I added it but no longer does after the fix.
 
-unlink('1.inc', '2.inc');
+run_make_test("
+export HI = \$(shell \$(\$\@.CMD))
+first.CMD = echo hi
+second.CMD = $sleep_command 4; echo hi
 
-# Test shell functions within commands: make sure they're not reducing our
-# parallelism.
+.PHONY: all first second
+all: first second
 
-run_make_test('.PHONY: all
-all: ; @echo $(shell echo hi)
-','','hi');
+first second: ; \@echo \$\@; $sleep_command 1; echo \$\@",
+              '-j2', "first\nfirst\nsecond\nsecond");
 
 1;
diff --git a/tests/scripts/variables/DEFAULT_GOAL b/tests/scripts/variables/DEFAULT_GOAL
new file mode 100644
index 0000000..897bd4a
--- /dev/null
+++ b/tests/scripts/variables/DEFAULT_GOAL
@@ -0,0 +1,78 @@
+#                                                                    -*-perl-*-
+$description = "Test the .DEFAULT_GOAL special variable.";
+
+$details = "";
+
+
+# Test #1: basic logic.
+#
+run_make_test('
+# Basics.
+#
+foo: ; @:
+
+ifneq ($(.DEFAULT_GOAL),foo)
+$(error )
+endif
+
+# Reset to empty.
+#
+.DEFAULT_GOAL :=
+
+bar: ; @:
+
+ifneq ($(.DEFAULT_GOAL),bar)
+$(error )
+endif
+
+# Change to a different goal.
+#
+
+.DEFAULT_GOAL := baz
+
+baz: ; @echo $@
+',
+'',
+'baz');
+
+
+# Test #2: unknown goal.
+#
+run_make_test('
+.DEFAULT_GOAL = foo
+',
+'',
+'#MAKE#: *** No rule to make target `foo\'.  Stop.',
+512);
+
+
+# Test #3: more than one goal.
+#
+run_make_test('
+.DEFAULT_GOAL := foo bar
+',
+'',
+'#MAKE#: *** .DEFAULT_GOAL contains more than one target.  Stop.',
+512);
+
+
+# Test #4: Savannah bug #12226.
+#
+run_make_test('
+define rule
+foo: ; @echo $$@
+endef
+
+define make-rule
+$(eval $(rule))
+endef
+
+$(call make-rule)
+
+',
+'',
+'foo');
+
+
+# This tells the test driver that the perl test script executed properly.
+1;
diff --git a/tests/scripts/variables/DEFAULT_TARGET b/tests/scripts/variables/DEFAULT_TARGET
deleted file mode 100644
index d8f1173..0000000
--- a/tests/scripts/variables/DEFAULT_TARGET
+++ /dev/null
@@ -1,78 +0,0 @@
-#                                                                    -*-perl-*-
-$description = "Test the .DEFAULT_TARGET special variable.";
-
-$details = "";
-
-
-# Test #1: basic logic.
-#
-run_make_test('
-# Basics.
-#
-foo: ; @:
-
-ifneq ($(.DEFAULT_TARGET),foo)
-$(error )
-endif
-
-# Reset to empty.
-#
-.DEFAULT_TARGET :=
-
-bar: ; @:
-
-ifneq ($(.DEFAULT_TARGET),bar)
-$(error )
-endif
-
-# Change to a different target.
-#
-
-.DEFAULT_TARGET := baz
-
-baz: ; @echo $@
-',
-'',
-'baz');
-
-
-# Test #2: unknown target.
-#
-run_make_test('
-.DEFAULT_TARGET := foo
-',
-'',
-'make: *** No rule to make target `foo\'.  Stop.',
-512);
-
-
-# Test #3: more than one target.
-#
-run_make_test('
-.DEFAULT_TARGET := foo bar
-',
-'',
-'make: *** .DEFAULT_TARGET contains more than one target.  Stop.',
-512);
-
-
-# Test #4: Savannah bug #12226.
-#
-run_make_test('
-define rule
-foo: ; @echo $$@
-endef
-
-define make-rule
-$(eval $(rule))
-endef
-
-$(call make-rule)
-
-',
-'',
-'foo');
-
-
-# This tells the test driver that the perl test script executed properly.
-1;
diff --git a/vmsfunctions.c b/vmsfunctions.c
index 48cb9a5..02e93d3 100644
--- a/vmsfunctions.c
+++ b/vmsfunctions.c
@@ -2,6 +2,7 @@
 
 #include "make.h"
 #include "debug.h"
+#include "job.h"
 
 #ifdef __DECC
 #include <starlet.h>
diff --git a/vmsjobs.c b/vmsjobs.c
new file mode 100644
index 0000000..bc15276
--- /dev/null
+++ b/vmsjobs.c
@@ -0,0 +1,667 @@
+
+
+/* --------------- Moved here from job.c ---------------
+   This file must be #included in job.c, as it accesses static functions.
+*/
+
+static int vms_jobsefnmask = 0;
+
+/* Wait for nchildren children to terminate */
+void
+vmsWaitForChildren(int *status)
+{
+  while (1)
+    {
+      if (!vms_jobsefnmask)
+	{
+	  *status = 0;
+	  return;
+	}
+
+      *status = sys$wflor (32, vms_jobsefnmask);
+    }
+  return;
+}
+
+/* Set up IO redirection.  */
+
+char *
+vms_redirect (struct dsc$descriptor_s *desc, char *fname, char *ibuf)
+{
+  char *fptr;
+
+  ibuf++;
+  while (isspace ((unsigned char)*ibuf))
+    ibuf++;
+  fptr = ibuf;
+  while (*ibuf && !isspace ((unsigned char)*ibuf))
+    ibuf++;
+  *ibuf = 0;
+  if (strcmp (fptr, "/dev/null") != 0)
+    {
+      strcpy (fname, vmsify (fptr, 0));
+      if (strchr (fname, '.') == 0)
+	strcat (fname, ".");
+    }
+  desc->dsc$w_length = strlen(fname);
+  desc->dsc$a_pointer = fname;
+  desc->dsc$b_dtype = DSC$K_DTYPE_T;
+  desc->dsc$b_class = DSC$K_CLASS_S;
+
+  if (*fname == 0)
+    printf (_("Warning: Empty redirection\n"));
+  return ibuf;
+}
+
+
+/* found apostrophe at (p-1)
+   inc p until after closing apostrophe.
+ */
+
+char *
+vms_handle_apos (char *p)
+{
+  int alast;
+
+#define SEPCHARS ",/()= "
+
+  alast = 0;
+
+  while (*p != 0)
+    {
+      if (*p == '"')
+	{
+          if (alast)
+            {
+              alast = 0;
+              p++;
+	    }
+	  else
+	    {
+	      p++;
+	      if (strchr (SEPCHARS, *p))
+		break;
+	      alast = 1;
+	    }
+	}
+      else
+	p++;
+    }
+
+  return p;
+}
+
+#include <descrip.h>
+#include <clidef.h>
+
+/* This is called as an AST when a child process dies (it won't get
+   interrupted by anything except a higher level AST).
+*/
+int
+vmsHandleChildTerm(struct child *child)
+{
+    int status;
+    register struct child *lastc, *c;
+    int child_failed;
+
+    vms_jobsefnmask &= ~(1 << (child->efn - 32));
+
+    lib$free_ef(&child->efn);
+
+    (void) sigblock (fatal_signal_mask);
+
+    child_failed = !(child->cstatus & 1 || ((child->cstatus & 7) == 0));
+
+    /* Search for a child matching the deceased one.  */
+    lastc = 0;
+#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
+    for (c = children; c != 0 && c != child; lastc = c, c = c->next)
+      ;
+#else
+    c = child;
+#endif
+
+    if (child_failed && !c->noerror && !ignore_errors_flag)
+      {
+	/* The commands failed.  Write an error message,
+	   delete non-precious targets, and abort.  */
+	child_error (c->file->name, c->cstatus, 0, 0, 0);
+	c->file->update_status = 1;
+	delete_child_targets (c);
+      }
+    else
+      {
+	if (child_failed)
+	  {
+	    /* The commands failed, but we don't care.  */
+	    child_error (c->file->name, c->cstatus, 0, 0, 1);
+	    child_failed = 0;
+	  }
+
+#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
+	/* If there are more commands to run, try to start them.  */
+	start_job (c);
+
+	switch (c->file->command_state)
+	  {
+	  case cs_running:
+	    /* Successfully started.  */
+	    break;
+
+	  case cs_finished:
+	    if (c->file->update_status != 0) {
+		/* We failed to start the commands.  */
+		delete_child_targets (c);
+	    }
+	    break;
+
+	  default:
+	    error (NILF, _("internal error: `%s' command_state"),
+                   c->file->name);
+	    abort ();
+	    break;
+	  }
+#endif /* RECURSIVEJOBS */
+      }
+
+    /* Set the state flag to say the commands have finished.  */
+    c->file->command_state = cs_finished;
+    notice_finished_file (c->file);
+
+#if defined(RECURSIVEJOBS) /* I've had problems with recursive stuff and process handling */
+    /* Remove the child from the chain and free it.  */
+    if (lastc == 0)
+      children = c->next;
+    else
+      lastc->next = c->next;
+    free_child (c);
+#endif /* RECURSIVEJOBS */
+
+    /* There is now another slot open.  */
+    if (job_slots_used > 0)
+      --job_slots_used;
+
+    /* If the job failed, and the -k flag was not given, die.  */
+    if (child_failed && !keep_going_flag)
+      die (EXIT_FAILURE);
+
+    (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
+
+    return 1;
+}
+
+/* VMS:
+   Spawn a process executing the command in ARGV and return its pid. */
+
+#define MAXCMDLEN 200
+
+/* local helpers to make ctrl+c and ctrl+y working, see below */
+#include <libclidef.h>
+#include <ssdef.h>
+
+static int ctrlMask= LIB$M_CLI_CTRLY;
+static int oldCtrlMask;
+static int setupYAstTried= 0;
+static int pidToAbort= 0;
+static int chan= 0;
+
+static void
+reEnableAst(void)
+{
+	lib$enable_ctrl (&oldCtrlMask,0);
+}
+
+static void
+astHandler (void)
+{
+	if (pidToAbort) {
+		sys$forcex (&pidToAbort, 0, SS$_ABORT);
+		pidToAbort= 0;
+	}
+	kill (getpid(),SIGQUIT);
+}
+
+static void
+tryToSetupYAst(void)
+{
+	$DESCRIPTOR(inputDsc,"SYS$COMMAND");
+	int	status;
+	struct {
+		short int	status, count;
+		int	dvi;
+	} iosb;
+
+	setupYAstTried++;
+
+	if (!chan) {
+		status= sys$assign(&inputDsc,&chan,0,0);
+		if (!(status&SS$_NORMAL)) {
+			lib$signal(status);
+			return;
+		}
+	}
+	status= sys$qiow (0, chan, IO$_SETMODE|IO$M_CTRLYAST,&iosb,0,0,
+		astHandler,0,0,0,0,0);
+	if (status==SS$_NORMAL)
+		status= iosb.status;
+        if (status==SS$_ILLIOFUNC || status==SS$_NOPRIV) {
+		sys$dassgn(chan);
+#ifdef	CTRLY_ENABLED_ANYWAY
+		fprintf (stderr,
+                         _("-warning, CTRL-Y will leave sub-process(es) around.\n"));
+#else
+		return;
+#endif
+	}
+	else if (!(status&SS$_NORMAL)) {
+		sys$dassgn(chan);
+		lib$signal(status);
+		return;
+	}
+
+	/* called from AST handler ? */
+	if (setupYAstTried>1)
+		return;
+	if (atexit(reEnableAst))
+		fprintf (stderr,
+                         _("-warning, you may have to re-enable CTRL-Y handling from DCL.\n"));
+	status= lib$disable_ctrl (&ctrlMask, &oldCtrlMask);
+	if (!(status&SS$_NORMAL)) {
+		lib$signal(status);
+		return;
+	}
+}
+
+int
+child_execute_job (char *argv, struct child *child)
+{
+  int i;
+  static struct dsc$descriptor_s cmddsc;
+  static struct dsc$descriptor_s pnamedsc;
+  static struct dsc$descriptor_s ifiledsc;
+  static struct dsc$descriptor_s ofiledsc;
+  static struct dsc$descriptor_s efiledsc;
+  int have_redirection = 0;
+  int have_newline = 0;
+
+  int spflags = CLI$M_NOWAIT;
+  int status;
+  char *cmd = alloca (strlen (argv) + 512), *p, *q;
+  char ifile[256], ofile[256], efile[256];
+  char *comname = 0;
+  char procname[100];
+  int in_string;
+
+  /* Parse IO redirection.  */
+
+  ifile[0] = 0;
+  ofile[0] = 0;
+  efile[0] = 0;
+
+  DB (DB_JOBS, ("child_execute_job (%s)\n", argv));
+
+  while (isspace ((unsigned char)*argv))
+    argv++;
+
+  if (*argv == 0)
+    return 0;
+
+  sprintf (procname, "GMAKE_%05x", getpid () & 0xfffff);
+  pnamedsc.dsc$w_length = strlen(procname);
+  pnamedsc.dsc$a_pointer = procname;
+  pnamedsc.dsc$b_dtype = DSC$K_DTYPE_T;
+  pnamedsc.dsc$b_class = DSC$K_CLASS_S;
+
+  in_string = 0;
+  /* Handle comments and redirection. */
+  for (p = argv, q = cmd; *p; p++, q++)
+    {
+      if (*p == '"')
+        in_string = !in_string;
+      if (in_string)
+        {
+          *q = *p;
+          continue;
+        }
+      switch (*p)
+	{
+	  case '#':
+	    *p-- = 0;
+	    *q-- = 0;
+	    break;
+	  case '\\':
+	    p++;
+	    if (*p == '\n')
+	      p++;
+	    if (isspace ((unsigned char)*p))
+	      {
+		do { p++; } while (isspace ((unsigned char)*p));
+		p--;
+	      }
+	    *q = *p;
+	    break;
+	  case '<':
+	    p = vms_redirect (&ifiledsc, ifile, p);
+	    *q = ' ';
+	    have_redirection = 1;
+	    break;
+	  case '>':
+	    have_redirection = 1;
+	    if (*(p-1) == '2')
+	      {
+		q--;
+		if (strncmp (p, ">&1", 3) == 0)
+		  {
+		    p += 3;
+		    strcpy (efile, "sys$output");
+		    efiledsc.dsc$w_length = strlen(efile);
+		    efiledsc.dsc$a_pointer = efile;
+		    efiledsc.dsc$b_dtype = DSC$K_DTYPE_T;
+		    efiledsc.dsc$b_class = DSC$K_CLASS_S;
+		  }
+		else
+		  {
+		    p = vms_redirect (&efiledsc, efile, p);
+		  }
+	      }
+	    else
+	      {
+		p = vms_redirect (&ofiledsc, ofile, p);
+	      }
+	    *q = ' ';
+	    break;
+	  case '\n':
+	    have_newline = 1;
+	  default:
+	    *q = *p;
+	    break;
+	}
+    }
+  *q = *p;
+  while (isspace ((unsigned char)*--q))
+    *q = '\0';
+
+  if (strncmp (cmd, "builtin_", 8) == 0)
+    {
+      child->pid = 270163;
+      child->efn = 0;
+      child->cstatus = 1;
+
+      DB (DB_JOBS, (_("BUILTIN [%s][%s]\n"), cmd, cmd+8));
+
+      p = cmd + 8;
+
+      if ((*(p) == 'c')
+	  && (*(p+1) == 'd')
+	  && ((*(p+2) == ' ') || (*(p+2) == '\t')))
+	{
+	  p += 3;
+	  while ((*p == ' ') || (*p == '\t'))
+	    p++;
+	  DB (DB_JOBS, (_("BUILTIN CD %s\n"), p));
+	  if (chdir (p))
+	    return 0;
+	  else
+	    return 1;
+	}
+      else if ((*(p) == 'r')
+	  && (*(p+1) == 'm')
+	  && ((*(p+2) == ' ') || (*(p+2) == '\t')))
+	{
+	  int in_arg;
+
+	  /* rm  */
+	  p += 3;
+	  while ((*p == ' ') || (*p == '\t'))
+	    p++;
+	  in_arg = 1;
+
+	  DB (DB_JOBS, (_("BUILTIN RM %s\n"), p));
+	  while (*p)
+	    {
+	      switch (*p)
+		{
+		  case ' ':
+		  case '\t':
+		    if (in_arg)
+		      {
+			*p++ = ';';
+			in_arg = 0;
+		      }
+		    break;
+		  default:
+		    break;
+		}
+	      p++;
+	    }
+	}
+      else
+	{
+	  printf(_("Unknown builtin command '%s'\n"), cmd);
+	  fflush(stdout);
+	  return 0;
+	}
+    }
+
+  /* Create a *.com file if either the command is too long for
+     lib$spawn, or the command contains a newline, or if redirection
+     is desired. Forcing commands with newlines into DCLs allows to
+     store search lists on user mode logicals.  */
+
+  if (strlen (cmd) > MAXCMDLEN
+      || (have_redirection != 0)
+      || (have_newline != 0))
+    {
+      FILE *outfile;
+      char c;
+      char *sep;
+      int alevel = 0;	/* apostrophe level */
+
+      if (strlen (cmd) == 0)
+	{
+	  printf (_("Error, empty command\n"));
+	  fflush (stdout);
+	  return 0;
+	}
+
+      outfile = open_tmpfile (&comname, "sys$scratch:CMDXXXXXX.COM");
+      if (outfile == 0)
+	pfatal_with_name (_("fopen (temporary file)"));
+
+      if (ifile[0])
+	{
+	  fprintf (outfile, "$ assign/user %s sys$input\n", ifile);
+          DB (DB_JOBS, (_("Redirected input from %s\n"), ifile));
+	  ifiledsc.dsc$w_length = 0;
+	}
+
+      if (efile[0])
+	{
+	  fprintf (outfile, "$ define sys$error %s\n", efile);
+          DB (DB_JOBS, (_("Redirected error to %s\n"), efile));
+	  efiledsc.dsc$w_length = 0;
+	}
+
+      if (ofile[0])
+	{
+	  fprintf (outfile, "$ define sys$output %s\n", ofile);
+	  DB (DB_JOBS, (_("Redirected output to %s\n"), ofile));
+	  ofiledsc.dsc$w_length = 0;
+	}
+
+      p = sep = q = cmd;
+      for (c = '\n'; c; c = *q++)
+	{
+	  switch (c)
+	    {
+            case '\n':
+              /* At a newline, skip any whitespace around a leading $
+                 from the command and issue exactly one $ into the DCL. */
+              while (isspace ((unsigned char)*p))
+                p++;
+              if (*p == '$')
+                p++;
+              while (isspace ((unsigned char)*p))
+                p++;
+              fwrite (p, 1, q - p, outfile);
+              fputc ('$', outfile);
+              fputc (' ', outfile);
+              /* Reset variables. */
+              p = sep = q;
+              break;
+
+	      /* Nice places for line breaks are after strings, after
+		 comma or space and before slash. */
+            case '"':
+              q = vms_handle_apos (q);
+              sep = q;
+              break;
+            case ',':
+            case ' ':
+              sep = q;
+              break;
+            case '/':
+            case '\0':
+              sep = q - 1;
+              break;
+            default:
+              break;
+	    }
+	  if (sep - p > 78)
+	    {
+	      /* Enough stuff for a line. */
+	      fwrite (p, 1, sep - p, outfile);
+	      p = sep;
+	      if (*sep)
+		{
+		  /* The command continues.  */
+		  fputc ('-', outfile);
+		}
+	      fputc ('\n', outfile);
+	    }
+  	}
+
+      fwrite (p, 1, q - p, outfile);
+      fputc ('\n', outfile);
+
+      fclose (outfile);
+
+      sprintf (cmd, "$ @%s", comname);
+
+      DB (DB_JOBS, (_("Executing %s instead\n"), cmd));
+    }
+
+  cmddsc.dsc$w_length = strlen(cmd);
+  cmddsc.dsc$a_pointer = cmd;
+  cmddsc.dsc$b_dtype = DSC$K_DTYPE_T;
+  cmddsc.dsc$b_class = DSC$K_CLASS_S;
+
+  child->efn = 0;
+  while (child->efn < 32 || child->efn > 63)
+    {
+      status = lib$get_ef ((unsigned long *)&child->efn);
+      if (!(status & 1))
+	return 0;
+    }
+
+  sys$clref (child->efn);
+
+  vms_jobsefnmask |= (1 << (child->efn - 32));
+
+/*
+             LIB$SPAWN  [command-string]
+			[,input-file]
+			[,output-file]
+			[,flags]
+			[,process-name]
+			[,process-id] [,completion-status-address] [,byte-integer-event-flag-num]
+			[,AST-address] [,varying-AST-argument]
+			[,prompt-string] [,cli] [,table]
+*/
+
+#ifndef DONTWAITFORCHILD
+/*
+ *	Code to make ctrl+c and ctrl+y working.
+ *	The problem starts with the synchronous case where after lib$spawn is
+ *	called any input will go to the child. But with input re-directed,
+ *	both control characters won't make it to any of the programs, neither
+ *	the spawning nor to the spawned one. Hence the caller needs to spawn
+ *	with CLI$M_NOWAIT to NOT give up the input focus. A sys$waitfr
+ *	has to follow to simulate the wanted synchronous behaviour.
+ *	The next problem is ctrl+y which isn't caught by the crtl and
+ *	therefore isn't converted to SIGQUIT (for a signal handler which is
+ *	already established). The only way to catch ctrl+y, is an AST
+ *	assigned to the input channel. But ctrl+y handling of DCL needs to be
+ *	disabled, otherwise it will handle it. Not to mention the previous
+ *	ctrl+y handling of DCL needs to be re-established before make exits.
+ *	One more: At the time of LIB$SPAWN signals are blocked. SIGQUIT will
+ *	make it to the signal handler after the child "normally" terminates.
+ *	This isn't enough. It seems reasonable for simple command lines like
+ *	a 'cc foobar.c' spawned in a subprocess but it is unacceptable for
+ *	spawning make. Therefore we need to abort the process in the AST.
+ *
+ *	Prior to the spawn it is checked if an AST is already set up for
+ *	ctrl+y, if not one is set up for a channel to SYS$COMMAND. In general
+ *	this will work except if make is run in a batch environment, but there
+ *	nobody can press ctrl+y. During the setup the DCL handling of ctrl+y
+ *	is disabled and an exit handler is established to re-enable it.
+ *	If the user interrupts with ctrl+y, the assigned AST will fire, force
+ *	an abort to the subprocess and signal SIGQUIT, which will be caught by
+ *	the already established handler and will bring us back to common code.
+ *	After the spawn (now /nowait) a sys$waitfr simulates the /wait and
+ *	enables the ctrl+y be delivered to this code. And the ctrl+c too,
+ *	which the crtl converts to SIGINT and which is caught by the common
+ *	signal handler. Because signals were blocked before entering this code
+ *	sys$waitfr will always complete and the SIGQUIT will be processed after
+ *	it (after termination of the current block, somewhere in common code).
+ *	And SIGINT too will be delayed. That is ctrl+c can only abort when the
+ *	current command completes. Anyway it's better than nothing :-)
+ */
+
+  if (!setupYAstTried)
+    tryToSetupYAst();
+  status = lib$spawn (&cmddsc,					/* cmd-string  */
+		      (ifiledsc.dsc$w_length == 0)?0:&ifiledsc, /* input-file  */
+		      (ofiledsc.dsc$w_length == 0)?0:&ofiledsc, /* output-file */
+		      &spflags,					/* flags  */
+		      &pnamedsc,				/* proc name  */
+		      &child->pid, &child->cstatus, &child->efn,
+		      0, 0,
+		      0, 0, 0);
+  if (status & 1)
+    {
+      pidToAbort= child->pid;
+      status= sys$waitfr (child->efn);
+      pidToAbort= 0;
+      vmsHandleChildTerm(child);
+    }
+#else
+  status = lib$spawn (&cmddsc,
+		      (ifiledsc.dsc$w_length == 0)?0:&ifiledsc,
+		      (ofiledsc.dsc$w_length == 0)?0:&ofiledsc,
+		      &spflags,
+		      &pnamedsc,
+		      &child->pid, &child->cstatus, &child->efn,
+		      vmsHandleChildTerm, child,
+		      0, 0, 0);
+#endif
+
+  if (!(status & 1))
+    {
+      printf (_("Error spawning, %d\n") ,status);
+      fflush (stdout);
+      switch (status)
+        {
+        case 0x1c:
+          errno = EPROCLIM;
+          break;
+        default:
+          errno = EFAIL;
+        }
+    }
+
+  if (comname && !ISDB (DB_JOBS))
+    unlink (comname);
+
+  return (status & 1);
+}
-- 
cgit v1.0-41-gc330

