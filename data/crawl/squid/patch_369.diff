@@ -484,28 +484,6 @@ helpers/negotiate_auth/kerberos/ *
 
 ==============================================================================
 
-compat/strsep.h, lib/strsep.c
-
- * Copyright (C) 2004 Free Software Foundation, Inc.
- * Written by Yoann Vandoorselaere <yoann@prelude-ids.org>
- * 
- * The file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- * 
- * This file is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public
- * License along with this file; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA.
-
-==============================================================================
-
 helpers/external_acl/kerberos_ldap_group/support_ldap.cc
 
 /* get_attributes is partly from OpenLDAP Software <http://www.openldap.org/>.
@@ -1,3 +1,18 @@
+Changes to squid-3.4.3 (02 Feb 2014):
+
+	- Bug 4008: HttpHeader warnOnError should be an int not a bool
+	- Bug 4002: clang 3.4 unable to compile
+	- Bug 3996: Malformed DNS reply leads to crash
+	- Bug 3995: compile error on CentOS 5 with GCC 4.1.2
+	- Bug 3975: atomic detection cross-compilation failure
+	- Bug 3971: "cannot aggregate mgr:client_list: cmd->profile != NULL" in SMP mode
+	- Bug 3954: compile failure in CpuAffinity.cc
+	- Bug 3927: tests/testRock fatal.cc required
+	- Fix memory leak in peer Cache Digest exchange
+	- Fix external_acl_type async loop failures
+	- Fix destination IP address cycling
+	- ... and a few polishing changes
+
 Changes to squid-3.4.2 (30 Dec 2013):
 
 	- Regression Bug 3980: FATAL ERROR due to max_user_ip -s option
@@ -39,13 +39,11 @@ libcompat_squid_la_SOURCES = \
 	stdio.h \
 	stdvarargs.h \
 	strnstr.cc \
-	strsep.h \
 	strtoll.h \
 	strnrchr.h \
 	strnrchr.c \
 	tempnam.h \
 	types.h \
-	unsafe.h \
 	valgrind.h \
 	xalloc.cc \
 	xalloc.h \
@@ -4,7 +4,7 @@
 \title Squid Portability
 
 
-\section 1 Aim
+\section sec1 Aim
 
 \par 
 Squid aims to build and run on many modern systems. To do this we have traditionally
@@ -18,25 +18,25 @@ The Portability library libcompat-squid.la has been created to correct the three
 stable build portability, code cleanliness, and clearer licensing.
 
 
-\section 2 Requirements
+\section sec2 Requirements
 
 \par
 The system calls used by Squid are not required to be standard. Often we depend on
 some non-standard call which can give great performance benefits.
 But they are required to meet several other criteria:
  \li  They must be of actual benefit to Squid during its operation.
  \li  A better alternative must not exist.
- \li  If not available on all OS an open-source GPLv2+ implementation must be available
-      to be included with the Squid sources and used when required.
+ \li  If not available on all OS an open-source GPLv2+ compatible implementation must be
+      available to be included with the Squid sources and used when required.
 
 \par
-To be built into the libcompat-squid.la as a layer below all Squid-bundled binaries. The code
-must also qualify by being provided natively by some OS where Squid builds. \br
+To be built into the libcompat-squid.la as a layer below all Squid-bundled binaries. The
+code must also qualify by being provided natively by some OS where Squid builds. \br
 Code and Algorithms which do not meet this final criteria are relegated to the slightly
 higher level of basic component, rather than portability.
 
 
-\section 3 Component Types
+\section sec3 Component Types
 
 \par Macro re-definition
 Where the only difference between systems is their naming scheme. One of the schemes is
@@ -62,16 +62,16 @@ same name with an 'x' pre-pended. Currently these extra protections are added on
 handling and memory allocation.
 
 
-\section 4 Layout
+\section sec4 Layout
 The internal code structure of libcompat-squid.la files has a hierarchy. The API has a flat
 global scope separate from the file layout. The API is pulled in by including compat/compat.h.
-The strict dependency requirements which exist within the compat API make including
+The strict dependency requirements which exist within the compat API make including an
 individual part separately a risky operation.
 
 \par
-Squid coding guidelines require each .c and .cc file to include squid.h first
-in their included files. squid.h begin with an order-specific sequence of defines and
-includes compat/compat.h to incorporate the compat layer appropriately in every soure file.
+Squid coding guidelines require each .c and .cc file to include squid.h first in their
+included files. squid.h begins with an order-specific sequence of defines and includes
+compat/compat.h to incorporate the compat layer appropriately in every source file.
 
 \par
 Internally the compat/ directory contains the public API file compat/compat.h which structures
@@ -84,9 +84,9 @@ special compat layer handling. Hacks for specific systems should be restricted t
 as much as possible.
 
 \par
-compat/compat_shared.h file contains the shared portability definitions which are shared
-across a great many systems. These should be written with protective macros to prevent any
-symbols or code being defined which is not necessary. Protections here must not be system-specific.
+compat/compat_shared.h file contains the portability definitions which are shared across a
+great many systems. These should be written with protective macros to prevent any symbols or
+code being defined which is not necessary. Protections here must not be system-specific.
 
 \par
 Also in compat/ directory are the .h and .c files for emulators detected by autoconf. These
@@ -103,9 +103,6 @@
  */
 #include "compat/GnuRegex.h"
 
-/* some functions are unsafe to be used in Squid. */
-#include "compat/unsafe.h"
-
 /* cppunit is not quite C++0x compatible yet */
 #include "compat/cppunit.h"
 
@@ -1,5 +1,5 @@
 #ifndef SQUID_OS_HPUX_H
-#define SQUID_OS_PHUX_H
+#define SQUID_OS_HPUX_H
 
 #if _SQUID_HPUX_
 
@@ -114,7 +114,6 @@ typedef unsigned long ino_t;
 #define snprintf _snprintf
 #define stat _stati64
 #define strcasecmp _stricmp
-#define strdup _strdup
 #define strlwr _strlwr
 #define strncasecmp _strnicmp
 #define tempnam _tempnam
@@ -962,7 +961,5 @@ void syslog(int priority, const char *fmt, ...);
 /* prototypes */
 void WIN32_maperror(unsigned long WIN32_oserrno);
 
-#include "compat/strsep.h"
-
 #endif /* _SQUID_WINDOWS_ */
 #endif /* SQUID_OS_MSWINDOWS_H */
@@ -101,8 +101,5 @@ SQUIDCEXTERN int gethostname(char *, int);
 #define _PATH_DEVNULL "/dev/null"
 #endif
 
-/* Solaris 10 does not define strsep() */
-#include "compat/strsep.h"
-
 #endif /* _SQUID_SOLARIS_ */
 #endif /* SQUID_OS_SOALRIS_H */
@@ -46,8 +46,8 @@ inline FILE * tmpfile(void) { return tmpfile64(); }
 #endif /* __USE_FILE_OFFSET64 && !__REDIRECT */
 
 // Finally import the <cstdio> stuff we actually use
-#if HAVE_CSTDIO
-#include<cstdio>
+#if HAVE_CSTDIO && defined(__cplusplus)
+#include <cstdio>
 #endif
 
 #ifndef MAXPATHLEN
@@ -1,48 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
- * Written by Yoann Vandoorselaere <yoann@prelude-ids.org>
- *
- * The file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This file is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this file; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA.
- */
-
-#include "squid.h"
-#include "compat/strsep.h"
-
-#include <string.h>
-
-char *
-strsep(char **stringp, const char *delim)
-{
-    char *start = *stringp;
-    char *ptr;
-
-    if (!start)
-        return NULL;
-
-    if (!*delim)
-        ptr = start + strlen (start);
-    else {
-        ptr = strpbrk (start, delim);
-        if (!ptr) {
-            *stringp = NULL;
-            return start;
-        }
-    }
-
-    *ptr = '\0';
-    *stringp = ptr + 1;
-
-    return start;
-}
@@ -1,56 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
- * Written by Yoann Vandoorselaere <yoann@prelude-ids.org>
- *
- * The file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This file is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this file; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA.
- */
-#ifndef GNULIB_STRSEP_H_
-#define GNULIB_STRSEP_H_
-
-#if HAVE_STRSEP
-
-/*
- * Get strsep() declaration.
- */
-#if HAVE_STRING_H
-#include <string.h>
-#endif
-
-#else
-
-/**
- *\par
- * Searches the next delimiter (char listed in DELIM) starting at *STRINGP.
- * If one is found, it is overwritten with a NULL, and *STRINGP is advanced
- * to point to the next char after it.  Otherwise, *STRINGP is set to NULL.
- * If *STRINGP was already NULL, nothing happens.
- * Returns the old value of *STRINGP.
- *
- *\par
- * This is a variant of strtok() that is multithread-safe and supports
- * empty fields.
- *
- * \note   Caveat: It modifies the original string.
- * \note   Caveat: These functions cannot be used on constant strings.
- * \note   Caveat: The identity of the delimiting character is lost.
- * \note   Caveat: It doesn't work with multibyte strings unless all of the delimiter
- * characters are ASCII characters < 0x30.
- *
- * See also strtok_r().
- */
-SQUIDCEXTERN char *strsep(char **stringp, const char *delim);
-
-#endif /* HAVE_STRSEP */
-#endif /* GNULIB_STRSEP_H_ */
@@ -1,17 +0,0 @@
-#ifndef _SQUID_COMPAT_UNSAFE_H
-#define _SQUID_COMPAT_UNSAFE_H
-
-/*
- * Trap unintentional use of functions unsafe for use within squid.
- */
-
-#if !SQUID_NO_STRING_BUFFER_PROTECT
-#ifndef sprintf
-#define sprintf ERROR_sprintf_UNSAFE_IN_SQUID
-#endif
-#ifndef strdup
-#define strdup ERROR_strdup_UNSAFE_IN_SQUID
-#endif
-#endif /* SQUID_NO_STRING_BUFFER_PROTECT */
-
-#endif /* _SQUID_COMPAT_UNSAFE_H */
@@ -431,9 +431,9 @@ AC_RUN_IFELSE([AC_LANG_PROGRAM([[
     AC_MSG_RESULT(yes)
 ],[
     AC_MSG_RESULT(no)
+],[ AC_MSG_RESULT(cross-compiler cant tell)
 ])
 
-
 AC_ARG_ENABLE(debug-cbdata,
   AS_HELP_STRING([--enable-debug-cbdata],
       [Provide some debug information in cbdata]), [ 
@@ -1833,7 +1833,7 @@ if test "x$ac_krb5_config" = "xyes" ; then
   CPPFLAGS="$CPPFLAGS $KRB5INCS"
   LIBS="$LIBS $KRB5LIBS"
   AC_CHECK_HEADERS(gssapi.h gssapi/gssapi.h gssapi/gssapi_krb5.h)
-  if test "x$ac_heimdal" == "x" ; then
+  if test "x$ac_heimdal" = "x" ; then
     AC_CHECK_HEADERS(gssapi/gssapi_generic.h)
     AC_CHECK_HEADERS(profile.h)
   fi
@@ -1853,9 +1853,9 @@ if test "x$ac_krb5_config" = "xyes" ; then
   AC_CHECK_HEADERS(krb5.h com_err.h et/com_err.h)
 
   ac_com_error_message=no
-  if test "x$ac_cv_header_com_err_h" == "xyes" ; then
+  if test "x$ac_cv_header_com_err_h" = "xyes" ; then
       AC_EGREP_HEADER(error_message,com_err.h,ac_com_error_message=yes)
-  elif test "x$ac_cv_header_et_com_err_h" == "xyes" ; then
+  elif test "x$ac_cv_header_et_com_err_h" = "xyes" ; then
       AC_EGREP_HEADER(error_message,et/com_err.h,ac_com_error_message=yes)
   fi
 
@@ -1864,11 +1864,11 @@ if test "x$ac_krb5_config" = "xyes" ; then
     AC_DEFINE(HAVE_MAX_SKEW_IN_KRB5_CONTEXT, 1, [Define to 1 if max_skew in struct krb5_context])
   fi
 
-  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" == "xyes" ; then
+  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
     AC_CHECK_LIB(com_err,error_message,
       AC_DEFINE(HAVE_ERROR_MESSAGE,1,
         [Define to 1 if you have error_message]),)
-  elif test  "x$ac_com_error_message" == "xyes" ; then
+  elif test  "x$ac_com_error_message" = "xyes" ; then
     AC_CHECK_LIB(krb5,error_message,
       AC_DEFINE(HAVE_ERROR_MESSAGE,1,
         [Define to 1 if you have error_message]),)
@@ -2169,6 +2169,7 @@ AC_CHECK_HEADERS( \
   cassert \
   crypt.h \
   cstdarg \
+  cstdio \
   cstdlib \
   cstring \
   list \
@@ -2886,6 +2887,7 @@ case "$host" in
       CFLAGS="`echo $CFLAGS | sed -e 's/-O[[0-9]]*//'`"
     fi
   ;;
+
   *-sgi-irix*)
     AC_MSG_NOTICE([Removing -lsocket for IRIX...])
     LIBS=`echo $LIBS | sed -e s/-lsocket//`
@@ -2948,7 +2950,7 @@ assert(myBar != NULL);
 # Remove optimization for GCC 2.95.[123]
 # gcc -O[2] on *BSD and Linux (x86) causes pointers to magically become NULL
 if test "x$GCC" = "xyes"; then
-	GCCVER=`$CC -v 2>&1 | awk '$2 ==  "version" {print $3}'`
+	GCCVER=`$CC -v 2>&1 | awk '$2 == "version" {print $3}'`
 	case "$GCCVER" in
 	[2.95.[123]])
 		AC_MSG_NOTICE([Removing -O for gcc on $host with GCC $GCCVER])
@@ -3079,7 +3081,6 @@ AC_REPLACE_FUNCS(\
 	getnameinfo \
 	psignal \
 	strerror \
-	strsep \
 	strtoll \
 	tempnam \
 )
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.2 release notes</title>
+<title>Squid 3.4.3 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.2 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.3 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -413,6 +413,11 @@ This section gives an account of those changes in three categories:
 	   the getsockname() API in recent PF versions require <em>--with-nat-devpf</em>
 	   to re-enable /dev/pf support when using PF firewall.
 
+	<tag>--disable-translation</tag>
+	<p>Default changed to prevent translating error page templates during build.
+	    Use --enable-translation to explicitly build and install the templates.
+	<p>The latest pre-translated templates can be downloaded from <url url="http://www.squid-cache.org/Versions/langpack/">
+
 </descrip>
 </p>
 
@@ -187,7 +187,7 @@ Get_primaryGroup(IADs * pUser)
         CoTaskMemFree(pByte);
 
         *(strrchr(szSID, '-') + 1) = '\0';
-        sprintf(tmpSID, "%s%u", szSID, User_primaryGroupID);
+        snprintf(tmpSID, sizeof(tmpSID)-1, "%s%u", szSID, User_primaryGroupID);
 
         wcsize = MultiByteToWideChar(CP_ACP, 0, tmpSID, -1, wc, 0);
         wc = (wchar_t *) xmalloc(wcsize * sizeof(wchar_t));
@@ -239,15 +239,15 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t n
         if (ls->domain && !strcasecmp(ls->domain, domain)) {
             debug((char *) "%s| %s: DEBUG: Found lserver@domain %s@%s\n", LogTime(), PROGRAM, ls->lserver, ls->domain);
             hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
-            hp[nhosts].host = strdup(ls->lserver);
+            hp[nhosts].host = xstrdup(ls->lserver);
             hp[nhosts].port = -1;
             hp[nhosts].priority = -2;
             hp[nhosts].weight = -2;
             ++nhosts;
         } else if ( !ls->domain || !strcasecmp(ls->domain, "") ) {
             debug((char *) "%s| %s: DEBUG: Found lserver@domain %s@%s\n", LogTime(), PROGRAM, ls->lserver, ls->domain?ls->domain:"NULL");
             hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
-            hp[nhosts].host = strdup(ls->lserver);
+            hp[nhosts].host = xstrdup(ls->lserver);
             hp[nhosts].port = -1;
             hp[nhosts].priority = -2;
             hp[nhosts].weight = -2;
@@ -401,7 +401,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t n
     debug("%s| %s: DEBUG: Adding %s to list\n", LogTime(), PROGRAM, domain);
 
     hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
-    hp[nhosts].host = strdup(domain);
+    hp[nhosts].host = xstrdup(domain);
     hp[nhosts].port = -1;
     hp[nhosts].priority = -2;
     hp[nhosts].weight = -2;
@@ -95,7 +95,7 @@ class CbDataListIterator
 
 /* implementation follows */
 
-/** \cond AUTODOCS-IGNORE */
+/** \cond AUTODOCS_IGNORE */
 template <class C>
 cbdata_type CbDataList<C>::CBDATA_CbDataList = CBDATA_UNKNOWN;
 /** \endcond */
@@ -22,6 +22,8 @@
 
 #include "MemPool.h"
 
+#include <stack>
+
 /// \ingroup MemPoolsAPI
 class MemPoolMalloc : public MemImplementingAllocator
 {
@@ -42,7 +44,7 @@ class MemPoolMalloc : public MemImplementingAllocator
     virtual void *allocate();
     virtual void deallocate(void *, bool aggressive);
 private:
-    Stack<void *> freelist;
+    std::stack<void *> freelist;
 };
 
 #endif /* _MEM_POOL_MALLOC_H_ */
@@ -31,7 +31,7 @@
 #ifndef SQUID_NEW_H
 #define SQUID_NEW_H
 
-#ifndef __SUNPRO_CC
+#if !defined(__SUNPRO_CC) && !defined(__clang__)
 /* Any code using libstdc++ must have externally resolvable overloads
  * for void * operator new - which means in the .o for the binary,
  * or in a shared library. static libs don't propogate the symbol
@@ -57,6 +57,6 @@ _SQUID_EXTERNNEW_ void operator delete[] (void *address) throw()
     xfree(address);
 }
 
-#endif /* __SUNPRO_CC */
+#endif /* !__SUNPRO_CC && !__clang__*/
 
 #endif /* SQUID_NEW_H */
@@ -1,67 +0,0 @@
-/*
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#ifndef SQUID_STACK_H
-#define SQUID_STACK_H
-
-#include "base/Vector.h"
-
-/* RBC: 20030714 Composition might be better long-term, but for now,
- * there's no reason to do so.
- */
-
-template <class S = void *>
-
-class Stack : public Vector<S>
-{
-public:
-    using Vector<S>::count;
-    using Vector<S>::items;
-    typedef typename Vector<S>::value_type value_type;
-    typedef typename Vector<S>::pointer pointer;
-    value_type pop() {
-        if (!count)
-            return value_type();
-
-        value_type result = items[--count];
-
-        this->items[count] = value_type();
-
-        return result;
-    }
-
-    /* todo, fatal on empty Top call */
-    value_type top() const {
-        return count ? items[count - 1] : value_type();
-    }
-};
-
-#endif /* SQUID_STACK_H */
@@ -158,7 +158,7 @@ SQUIDCEXTERN int heap_empty(heap *);
 SQUIDCEXTERN int heap_nodes(heap *);
 #else /* MACRO_DEBUG */
 #define	heap_nodes(heap)	((heap)->last)
-#define	heap_empty(heap)	(((heap)->last <= 0) ? 1 : 0)
+#define	heap_empty(heap)	((heap)->last <= 0 ? 1 : 0)
 #endif /* MACRO_DEBUG */
 
 /*
@@ -1,5 +1,5 @@
 #ifndef _SQUID_RFC1123_H
-#define _SQUID_RFC1123_
+#define _SQUID_RFC1123_H
 
 #ifdef __cplusplus
 extern "C" {
@@ -3,7 +3,9 @@
 
 #if defined(__cplusplus)
 
-#include "Stack.h"
+#include "fatal.h"
+
+#include <stack>
 
 template <class V>
 class SplayNode
@@ -376,7 +378,7 @@ class SplayConstIterator
     void advance();
     void addLeftPath(SplayNode<V> *aNode);
     void init(SplayNode<V> *);
-    Stack<SplayNode<V> *> toVisit;
+    std::stack<SplayNode<V> *> toVisit;
 };
 
 template <class V>
@@ -389,7 +391,12 @@ template <class V>
 bool
 SplayConstIterator<V>::operator == (SplayConstIterator const &right) const
 {
-    return toVisit.top() == right.toVisit.top();
+    if (toVisit.empty() && right.toVisit.empty())
+        return true;
+    if (!toVisit.empty() && !right.toVisit.empty())
+        return toVisit.top() == right.toVisit.top();
+    // only one of the two is empty
+    return false;
 }
 
 template <class V>
@@ -421,19 +428,21 @@ template <class V>
 void
 SplayConstIterator<V>::advance()
 {
-    if (toVisit.size() == 0)
+    if (toVisit.empty())
         return;
 
     toVisit.pop();
 
-    if (toVisit.size() == 0)
+    if (toVisit.empty())
         return;
 
-    SplayNode<V> *currentNode = toVisit.pop();
+    // not empty
+    SplayNode<V> *currentNode = toVisit.top();
+    toVisit.pop();
 
     addLeftPath(currentNode->right);
 
-    toVisit.push_back(currentNode);
+    toVisit.push(currentNode);
 }
 
 template <class V>
@@ -444,7 +453,7 @@ SplayConstIterator<V>::addLeftPath(SplayNode<V> *aNode)
         return;
 
     do {
-        toVisit.push_back(aNode);
+        toVisit.push(aNode);
         aNode = aNode->left;
     } while (aNode != NULL);
 }
@@ -1,5 +1,5 @@
 #ifndef _SQUID_UUDECODE_H
-#define _SQUID_UUDECODE_
+#define _SQUID_UUDECODE_H
 
 #ifdef __cplusplus
 extern "C"
@@ -51,7 +51,11 @@ extern time_t squid_curtime;
 void *
 MemPoolMalloc::allocate()
 {
-    void *obj = freelist.pop();
+    void *obj = NULL;
+    if (!freelist.empty()) {
+        obj = freelist.top();
+        freelist.pop();
+    }
     if (obj) {
         memMeterDec(meter.idle);
         ++saved_calls;
@@ -77,7 +81,7 @@ MemPoolMalloc::deallocate(void *obj, bool aggressive)
         if (doZero)
             memset(obj, 0, obj_size);
         memMeterInc(meter.idle);
-        freelist.push_back(obj);
+        freelist.push(obj);
     }
 }
 
@@ -127,13 +131,15 @@ MemPoolMalloc::~MemPoolMalloc()
 bool
 MemPoolMalloc::idleTrigger(int shift) const
 {
-    return freelist.count >> (shift ? 8 : 0);
+    return freelist.size() >> (shift ? 8 : 0);
 }
 
 void
 MemPoolMalloc::clean(time_t maxage)
 {
-    while (void *obj = freelist.pop()) {
+    while (!freelist.empty()) {
+        void *obj = freelist.top();
+        freelist.pop();
         memMeterDec(meter.idle);
         memMeterDec(meter.alloc);
         xfree(obj);
@@ -71,7 +71,6 @@ typedef enum {
     XPROF_storeGetMemSpace,
     XPROF_storeMaintainSwapSpace,
     XPROF_storeRelease,
-    XPROF_storeWriteComplete,
     XPROF_write,
     XPROF_xcalloc,
     XPROF_xmalloc,
@@ -382,7 +382,7 @@ RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
         offset = RFCNB_Pkt_Hdr_Len;     /* Otherwise skip the header       */
     }
 
-    frag_len = pkt_frag->len;
+    frag_len = (pkt_frag ? pkt_frag->len : 0);
 
     if (more <= frag_len)       /* If len left to get less than frag space */
         this_len = more;        /* Get the rest ...                        */
@@ -97,7 +97,7 @@ char *print_password(char * password)
         if (((unsigned)password[i] <= ' ') || ((unsigned)password[i] > 127)) {
 
             pwd_str[j] = '\\';
-            sprintf(temp, "%03i", (int)password[i]);
+            snprintf(temp, sizeof(temp)-1, "%03i", (int)password[i]);
             strcpy(&pwd_str[j + 1], temp);
             j = j + 3;                       /* Space for \ accounted for below */
 
@@ -228,7 +228,7 @@ main(int argc, char *argv[])
 
     }
 
-    sprintf(service_name, "\\\\%s\\%s", server, service); /* Could blow up */
+    sprintf(service_name, sizeof(service_name)-1, "\\\\%s\\%s", server, service); /* Could blow up */
 
     /* Now loop through all password possibilities ... */
 
@@ -190,7 +190,7 @@ int SMB_Get_SMB_Error_Msg(int err_class, int err_code, char *msg_buf, int len)
 
                 strncpy(msg_buf, err_classes[i].class, len);
                 strncat(msg_buf, " - ", len - strlen(msg_buf));
-                sprintf(internal_buf, "%d", err_code);
+                snprintf(internal_buf, sizeof(internal_buf)-1, "%d", err_code);
                 strncat(msg_buf, internal_buf, len - strlen(msg_buf));
                 strncat(msg_buf, " (Unknown error code).", len - strlen(msg_buf));
 
@@ -200,7 +200,7 @@ int SMB_Get_SMB_Error_Msg(int err_class, int err_code, char *msg_buf, int len)
 
                 strncpy(msg_buf, err_classes[i].class, len);
                 strncat(msg_buf, " - ", len - strlen(msg_buf));
-                sprintf(internal_buf, "%d", err_code);
+                snprintf(internal_buf, sizeof(internal_buf)-1, "%d", err_code);
                 strncat(msg_buf, internal_buf, len - strlen(msg_buf));
 
                 return(strlen(msg_buf));
@@ -211,10 +211,10 @@ int SMB_Get_SMB_Error_Msg(int err_class, int err_code, char *msg_buf, int len)
 
     /* If we get here, we did not recognize the error class */
 
-    sprintf(internal_buf, "%d", err_class);
+    snprintf(internal_buf, sizeof(internal_buf)-1, "%d", err_class);
     strncat(msg_buf, internal_buf, len - strlen(msg_buf));
     strncat(msg_buf, " (Unknown Error Class) - ", len - strlen(msg_buf));
-    sprintf(internal_buf, "%d", err_code);
+    snprintf(internal_buf, sizeof(internal_buf)-1, "%d", err_code);
     strncat(msg_buf, internal_buf, len - strlen(msg_buf));
     strncat(msg_buf, "(error code).", len - strlen(msg_buf));
 
@@ -105,6 +105,20 @@ for FILENAME in `ls -1`; do
 		echo "ERROR: ${PWD}/${FILENAME} contains reference to forward.h without path"
 	fi
 
+	#
+	# detect functions unsafe for use within Squid.
+	# strdup() - only allowed in compat/xstring.h which defines a safe replacement.
+	# sprintf() - not allowed anywhere.
+	#
+	STRDUP=`grep -e "[^x]strdup(" ${FILENAME}`;
+	if test "x${STRDUP}" != "x" -a "${FILENAME}" != "xstring.h"; then
+		echo "ERROR: ${PWD}/${FILENAME} contains unprotected use of strdup()"
+	fi
+	SPRINTF=`grep -e "[^v]sprintf(" ${FILENAME}`;
+	if test "x${SPRINTF}" != "x" ; then
+		echo "ERROR: ${PWD}/${FILENAME} contains unsafe use of sprintf()"
+	fi
+
 	#
 	# DEBUG Section list maintenance
 	#
@@ -1262,6 +1262,7 @@ PREDEFINED             = __cplusplus \
                          X_ACCELERATOR_VARY \
                          USE_ARP_ACL \
                          USE_ASYNC_IO \
+                         USE_AUTH \
                          USE_CACHE_DIGESTS \
                          USE_CLASSFUL \
                          USE_DELAY_POOLS \
@@ -1303,8 +1304,14 @@ EXPAND_AS_DEFINED      = AsyncCallWrapper \
                          AsyncCallEnter \
                          AsyncCallExit \
                          CBDATA_CLASS2 \
+                         CBDATA_CLASS_INIT \
+                         CBDATA_NAMESPACED_CLASS_INIT \
                          MEMPROXY_CLASS_INLINE \
-                         MEMPROXY_CLASS
+                         MEMPROXY_CLASS \
+                         MEMPROXY_CLASS_INIT \
+                         STUB \
+                         STUB_NOP \
+                         STUB_RETVAL
 
 # If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
 # doxygen's preprocessor will remove all function-like macros that are alone 
@@ -15,17 +15,30 @@ AccessLogEntry::SslDetails::SslDetails(): user(NULL), bumpMode(::Ssl::bumpEnd)
 void
 AccessLogEntry::getLogClientIp(char *buf, size_t bufsz) const
 {
+    Ip::Address log_ip;
+
 #if FOLLOW_X_FORWARDED_FOR
     if (Config.onoff.log_uses_indirect_client && request)
-        request->indirect_client_addr.toStr(buf, bufsz);
+        log_ip = request->indirect_client_addr;
     else
 #endif
         if (tcpClient != NULL)
-            tcpClient->remote.toStr(buf, bufsz);
-        else if (cache.caddr.isNoAddr()) // e.g., ICAP OPTIONS lack client
+            log_ip = tcpClient->remote;
+        else if (cache.caddr.isNoAddr()) { // e.g., ICAP OPTIONS lack client
             strncpy(buf, "-", bufsz);
-        else
-            cache.caddr.toStr(buf, bufsz);
+            return;
+        } else
+            log_ip = cache.caddr;
+
+    // Apply so-called 'privacy masking' to IPv4 clients
+    // - localhost IP is always shown in full
+    // - IPv4 clients masked with client_netmask
+    // - IPv6 clients use 'privacy addressing' instead.
+
+    if (!log_ip.isLocalhost() && log_ip.isIPv4())
+        log_ip.applyMask(Config.Addrs.client_netmask);
+
+    log_ip.toStr(buf, bufsz);
 }
 
 AccessLogEntry::~AccessLogEntry()
@@ -30,7 +30,7 @@ ClientDelayConfig::finalize()
 
 void ClientDelayConfig::freePoolCount()
 {
-    pools.clean();
+    pools.clear();
 }
 
 void ClientDelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
@@ -2,7 +2,8 @@
 #define SQUID_CLIENTDELAYCONFIG_H
 
 #include "acl/forward.h"
-#include "base/Vector.h"
+
+#include <vector>
 
 class StoreEntry;
 class ConfigParser;
@@ -21,7 +22,7 @@ class ClientDelayPool
     int64_t highwatermark;
 };
 
-typedef Vector<ClientDelayPool> ClientDelayPools;
+typedef std::vector<ClientDelayPool> ClientDelayPools;
 
 /* represents configuration of client write limiting delay pools */
 class ClientDelayConfig
@@ -87,7 +87,7 @@ CollapsedForwarding::Notify(const int workerId)
     Ipc::TypedMsgHdr msg;
     msg.setType(Ipc::mtCollapsedForwardingNotification);
     msg.putInt(KidIdentifier);
-    const String addr = Ipc::Port::MakeAddr(Ipc::strandAddrPfx, workerId);
+    const String addr = Ipc::Port::MakeAddr(Ipc::strandAddrLabel, workerId);
     Ipc::SendMessage(addr, msg);
 }
 
@@ -110,7 +110,8 @@ CollapsedForwarding::HandleNewData(const char *const when)
         debugs(17, 7, "handled entry " << msg.xitIndex << " in transients_map");
 
         // XXX: stop and schedule an async call to continue
-        assert(++poppedCount < SQUID_MAXFD);
+        ++poppedCount;
+        assert(poppedCount < SQUID_MAXFD);
     }
 }
 
@@ -66,13 +66,13 @@ class CommCommonCbParams
     void *data; // cbdata-protected
 
     /** The connection which this call pertains to.
-     * \itemize On accept() calls this is the new client connection.
-     * \itemize On connect() finished calls this is the newely opened connection.
-     * \itemize On write calls this is the connection just written to.
-     * \itemize On read calls this is the connection just read from.
-     * \itemize On close calls this describes the connection which is now closed.
-     * \itemize On timeouts this is the connection whose operation timed out.
-     *          NP: timeouts might also return to the connect/read/write handler with COMM_ERR_TIMEOUT.
+     *  - On accept() calls this is the new client connection.
+     *  - On connect() finished calls this is the newely opened connection.
+     *  - On write calls this is the connection just written to.
+     *  - On read calls this is the connection just read from.
+     *  - On close calls this describes the connection which is now closed.
+     *  - On timeouts this is the connection whose operation timed out.
+     *   + NP: timeouts might also return to the connect/read/write handler with COMM_ERR_TIMEOUT.
      */
     Comm::ConnectionPointer conn;
 
@@ -176,7 +176,7 @@ class CommCbMemFunT: public JobDialer<C>, public CommDialerParamsT<Params_>
     typedef void (C::*Method)(const Params &io);
 
     CommCbMemFunT(const CbcPointer<C> &aJob, Method aMeth): JobDialer<C>(aJob),
-            CommDialerParamsT<Params_>(aJob.get()),
+            CommDialerParamsT<Params_>(aJob->toCbdata()),
             method(aMeth) {}
 
     virtual bool canDial(AsyncCall &c) {
@@ -35,7 +35,7 @@
 
 ConfigOptionVector::~ConfigOptionVector()
 {
-    while (options.size()) {
+    while (!options.empty()) {
         delete options.back();
         options.pop_back();
     }
@@ -44,7 +44,7 @@ ConfigOptionVector::~ConfigOptionVector()
 bool
 ConfigOptionVector::parse(char const *option, const char *value, int isaReconfig)
 {
-    Vector<ConfigOption *>::iterator i = options.begin();
+    std::vector<ConfigOption *>::iterator i = options.begin();
 
     while (i != options.end()) {
         if ((*i)->parse(option,value, isaReconfig))
@@ -59,7 +59,7 @@ ConfigOptionVector::parse(char const *option, const char *value, int isaReconfig
 void
 ConfigOptionVector::dump(StoreEntry * e) const
 {
-    for (Vector<ConfigOption *>::const_iterator i = options.begin();
+    for (std::vector<ConfigOption *>::const_iterator i = options.begin();
             i != options.end(); ++i)
         (*i)->dump(e);
 }
@@ -30,7 +30,7 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-#include "base/Vector.h"
+#include <vector>
 
 class StoreEntry;
 
@@ -53,7 +53,7 @@ class ConfigOptionVector : public ConfigOption
     virtual ~ConfigOptionVector();
     virtual bool parse(char const *option, const char *value, int reconfiguring);
     virtual void dump(StoreEntry * e) const;
-    Vector<ConfigOption *>options;
+    std::vector<ConfigOption *>options;
 };
 
 template <class C>
@@ -10,7 +10,7 @@
 #include "Debug.h"
 
 bool
-CpuAffinityMap::add(const Vector<int> &aProcesses, const Vector<int> &aCores)
+CpuAffinityMap::add(const std::vector<int> &aProcesses, const std::vector<int> &aCores)
 {
     if (aProcesses.size() != aCores.size())
         return false;
@@ -4,7 +4,7 @@
 #ifndef SQUID_CPU_AFFINITY_MAP_H
 #define SQUID_CPU_AFFINITY_MAP_H
 
-#include "base/Vector.h"
+#include <vector>
 
 class CpuAffinitySet;
 
@@ -13,20 +13,20 @@ class CpuAffinityMap
 {
 public:
     /// append cpu_affinity_map option
-    bool add(const Vector<int> &aProcesses, const Vector<int> &aCores);
+    bool add(const std::vector<int> &aProcesses, const std::vector<int> &aCores);
 
     /// calculate CPU set for this process
     CpuAffinitySet *calculateSet(const int targetProcess) const;
 
     /// returns list of process numbers
-    const Vector<int> &processes() const { return theProcesses; }
+    const std::vector<int> &processes() const { return theProcesses; }
 
     /// returns list of cores
-    const Vector<int> &cores() const { return theCores; }
+    const std::vector<int> &cores() const { return theCores; }
 
 private:
-    Vector<int> theProcesses; ///< list of process numbers
-    Vector<int> theCores; ///< list of cores
+    std::vector<int> theProcesses; ///< list of process numbers
+    std::vector<int> theCores; ///< list of cores
 };
 
 #endif // SQUID_CPU_AFFINITY_MAP_H
@@ -32,7 +32,7 @@
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
-#include "base/Vector.h"
+#include <vector>
 
 class DelayPool;
 class Updateable;
@@ -75,7 +75,7 @@ class DelayPools
     static time_t LastUpdate;
     static unsigned short pools_;
     static void FreeDelayData ();
-    static Vector<Updateable *> toUpdate;
+    static std::vector<Updateable *> toUpdate;
     static void RegisterWithCacheManager(void);
 };
 
@@ -37,7 +37,6 @@
 #if USE_DELAY_POOLS
 
 #include "auth/Gadgets.h"
-#include "base/Vector.h"
 #include "CompositePoolNode.h"
 #include "DelayBucket.h"
 #include "DelayIdComposite.h"
@@ -38,7 +38,6 @@
 
 #include "auth/Gadgets.h"
 #include "auth/User.h"
-#include "base/Vector.h"
 #include "CompositePoolNode.h"
 #include "DelayBucket.h"
 #include "DelayIdComposite.h"
@@ -72,16 +72,16 @@ class DelayVector : public CompositePoolNode
 
     private:
         RefCount<DelayVector> theVector;
-        Vector<DelayIdComposite::Pointer> ids;
-        typedef Vector<DelayIdComposite::Pointer>::iterator iterator;
-        typedef Vector<DelayIdComposite::Pointer>::const_iterator const_iterator;
+        std::vector<DelayIdComposite::Pointer> ids;
+        typedef std::vector<DelayIdComposite::Pointer>::iterator iterator;
+        typedef std::vector<DelayIdComposite::Pointer>::const_iterator const_iterator;
     };
 
     friend class Id;
 
-    Vector<CompositePoolNode::Pointer> pools;
-    typedef Vector<CompositePoolNode::Pointer>::iterator iterator;
-    typedef Vector<CompositePoolNode::Pointer>::const_iterator const_iterator;
+    std::vector<CompositePoolNode::Pointer> pools;
+    typedef std::vector<CompositePoolNode::Pointer>::iterator iterator;
+    typedef std::vector<CompositePoolNode::Pointer>::const_iterator const_iterator;
 };
 
 #endif /* USE_DELAY_POOLS */
@@ -46,16 +46,16 @@
 
 CBDATA_CLASS_INIT(BlockingFile);
 
-BlockingFile::BlockingFile(char const *aPath) : fd (-1), closed (true), error_(false)
+BlockingFile::BlockingFile(char const *aPath) : fd(-1), closed(true), error_(false)
 {
     assert(aPath);
     debugs(79, 3, "BlockingFile::BlockingFile: " << aPath);
-    path_ = xstrdup (aPath);
+    path_ = xstrdup(aPath);
 }
 
 BlockingFile::~BlockingFile()
 {
-    safe_free (path_);
+    safe_free(path_);
     doClose();
 }
 
@@ -59,26 +59,26 @@ DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) :
         mode(0),
         inProgressIOs(0)
 {
-    assert (aPath);
+    assert(aPath);
     debugs(79, 3, "DiskdFile::DiskdFile: " << aPath);
-    path_ = xstrdup (aPath);
+    path_ = xstrdup(aPath);
     id = diskd_stats.sio_id;
     ++diskd_stats.sio_id;
 }
 
 DiskdFile::~DiskdFile()
 {
-    assert (inProgressIOs == 0);
+    assert(inProgressIOs == 0);
     safe_free (path_);
 }
 
 void
 DiskdFile::open(int flags, mode_t aMode, RefCount< IORequestor > callback)
 {
     debugs(79, 3, "DiskdFile::open: " << this << " opening for " << callback.getRaw());
-    assert (ioRequestor.getRaw() == NULL);
+    assert(ioRequestor.getRaw() == NULL);
     ioRequestor = callback;
-    assert (callback.getRaw());
+    assert(callback.getRaw());
     mode = flags;
     ssize_t shm_offset;
     char *buf = (char *)IO->shm.get(&shm_offset);
@@ -35,7 +35,7 @@
 #include "squid.h"
 #include "DiskIOModule.h"
 
-Vector<DiskIOModule*> *DiskIOModule::_Modules = NULL;
+std::vector<DiskIOModule*> *DiskIOModule::_Modules = NULL;
 
 //DiskIOModule() : initialised (false) {}
 
@@ -70,17 +70,17 @@ DiskIOModule::ModuleAdd(DiskIOModule &instance)
     GetModules().push_back (&instance);
 }
 
-Vector<DiskIOModule *> const &
+std::vector<DiskIOModule *> const &
 DiskIOModule::Modules()
 {
     return GetModules();
 }
 
-Vector<DiskIOModule*> &
+std::vector<DiskIOModule*> &
 DiskIOModule::GetModules()
 {
     if (!_Modules)
-        _Modules = new Vector<DiskIOModule *>;
+        _Modules = new std::vector<DiskIOModule *>;
 
     return *_Modules;
 }
@@ -92,7 +92,7 @@ DiskIOModule::GetModules()
 void
 DiskIOModule::FreeAllModules()
 {
-    while (GetModules().size()) {
+    while (!GetModules().empty()) {
         DiskIOModule *fs = GetModules().back();
         GetModules().pop_back();
         fs->gracefulShutdown();
@@ -32,7 +32,7 @@
 #ifndef SQUID_DISKIOMODULE_H
 #define SQUID_DISKIOMODULE_H
 
-#include "base/Vector.h"
+#include <vector>
 
 /* forward decls */
 
@@ -57,9 +57,9 @@ class DiskIOModule
      * available module for this system.
      */
     static DiskIOModule *FindDefault();
-    static Vector<DiskIOModule*> const &Modules();
-    typedef Vector<DiskIOModule*>::iterator iterator;
-    typedef Vector<DiskIOModule*>::const_iterator const_iterator;
+    static std::vector<DiskIOModule*> const &Modules();
+    typedef std::vector<DiskIOModule*>::iterator iterator;
+    typedef std::vector<DiskIOModule*>::const_iterator const_iterator;
     DiskIOModule();
     virtual ~DiskIOModule() {}
 
@@ -78,8 +78,8 @@ class DiskIOModule
     static void RegisterAllModulesWithCacheManager(void);
 
 private:
-    static Vector<DiskIOModule*> &GetModules();
-    static Vector<DiskIOModule*> *_Modules;
+    static std::vector<DiskIOModule*> &GetModules();
+    static std::vector<DiskIOModule*> *_Modules;
 };
 
 #endif /* SQUID_DISKIOMODULE_H */
@@ -54,14 +54,14 @@ CBDATA_CLASS_INIT(DiskThreadsDiskFile);
 DiskThreadsDiskFile::DiskThreadsDiskFile(char const *aPath, DiskThreadsIOStrategy *anIO):fd(-1), errorOccured (false), IO(anIO),
         inProgressIOs (0)
 {
-    assert (aPath);
+    assert(aPath);
     debugs(79, 3, "UFSFile::UFSFile: " << aPath);
-    path_ = xstrdup (aPath);
+    path_ = xstrdup(aPath);
 }
 
 DiskThreadsDiskFile::~DiskThreadsDiskFile()
 {
-    safe_free (path_);
+    safe_free(path_);
     doClose();
 }
 
@@ -350,7 +350,7 @@ DiskThreadsDiskFile::writeDone(int rvfd, int errflag, size_t len, RefCount<Write
     --loop_detect;
 }
 
-/** \cond AUTODOCS-IGNORE */
+/** \cond AUTODOCS_IGNORE */
 template <class RT>
 cbdata_type IoResult<RT>::CBDATA_IoResult = CBDATA_UNKNOWN;
 /** \endcond */
@@ -114,7 +114,7 @@ IpcIoFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
         ann.strand.tag = dbName;
         Ipc::TypedMsgHdr message;
         ann.pack(message);
-        SendMessage(Ipc::coordinatorAddr, message);
+        SendMessage(Ipc::Port::CoordinatorAddr(), message);
 
         ioRequestor->ioCompletedNotification();
         return;
@@ -126,7 +126,7 @@ IpcIoFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
 
     Ipc::TypedMsgHdr msg;
     request.pack(msg);
-    Ipc::SendMessage(Ipc::coordinatorAddr, msg);
+    Ipc::SendMessage(Ipc::Port::CoordinatorAddr(), msg);
 
     WaitingForOpen.push_back(this);
 
@@ -460,7 +460,7 @@ IpcIoFile::Notify(const int peerId)
     Ipc::TypedMsgHdr msg;
     msg.setType(Ipc::mtIpcIoNotification); // TODO: add proper message type?
     msg.putInt(KidIdentifier);
-    const String addr = Ipc::Port::MakeAddr(Ipc::strandAddrPfx, peerId);
+    const String addr = Ipc::Port::MakeAddr(Ipc::strandAddrLabel, peerId);
     Ipc::SendMessage(addr, msg);
 }
 
@@ -31,7 +31,7 @@
 #ifndef SQUID_EVENTLOOP_H
 #define SQUID_EVENTLOOP_H
 
-#include "base/Vector.h"
+#include <vector>
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
@@ -104,7 +104,7 @@ class EventLoop
     bool dispatchCalls();
 
     bool last_loop;
-    typedef Vector<AsyncEngine *> engine_vector;
+    typedef std::vector<AsyncEngine *> engine_vector;
     engine_vector engines;
     TimeEngine * timeService;
     AsyncEngine * primaryEngine;
@@ -70,7 +70,7 @@ ExternalACLEntry::update(ExternalACLEntryData const &someData)
     result = someData.result;
 
     // replace all notes. not combine
-    notes.entries.clean();
+    notes.entries.clear();
     notes.append(&someData.notes);
 
 #if USE_AUTH
@@ -1,7 +1,7 @@
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
-#include "base/Vector.h"
+#include <vector>
 
 /// Counts events, forgetting old ones. Usefull for "3 errors/minute" limits.
 class FadingCounter
@@ -25,7 +25,7 @@ class FadingCounter
     double delta; ///< sub-interval duration = horizon/precision
 
     double lastTime; ///< time of the last update
-    Vector<int> counters; ///< events per delta (possibly stale)
+    std::vector<int> counters; ///< events per delta (possibly stale)
     int total; ///< number of remembered events (possibly stale)
 };
 
@@ -112,7 +112,7 @@ FwdState::abort(void* d)
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
-    fwd->serverDestinations.clean();
+    fwd->serverDestinations.clear();
     fwd->self = NULL;
 }
 
@@ -277,7 +277,7 @@ FwdState::~FwdState()
         serverConn->close();
     }
 
-    serverDestinations.clean();
+    serverDestinations.clear();
 
     debugs(17, 3, HERE << "FwdState destructor done");
 }
@@ -472,7 +472,7 @@ FwdState::complete()
         entry->reset();
 
         // drop the last path off the selection list. try the next one.
-        serverDestinations.shift();
+        serverDestinations.erase(serverDestinations.begin());
         startConnectionOrFail();
 
     } else {
@@ -611,7 +611,7 @@ FwdState::retryOrBail()
         if (pconnRace == raceHappened)
             debugs(17, 4, HERE << "retrying the same destination");
         else
-            serverDestinations.shift(); // last one failed. try another.
+            serverDestinations.erase(serverDestinations.begin()); // last one failed. try another.
         startConnectionOrFail();
         return;
     }
@@ -2,7 +2,6 @@
 #define SQUID_FORWARD_H
 
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "err_type.h"
@@ -60,18 +60,6 @@ T& for_each(dlink_list const &collection, T& visitor)
     return visitor;
 }
 
-template <class S>
-class Stack;
-
-template <class E, class T>
-T& for_each(Stack<E> const &collection, T& visitor)
-{
-    for (size_t index = 0; index < collection.count; ++index)
-        visitor(*(typename T::argument_type const *)collection.items[index]);
-
-    return visitor;
-};
-
 /* RBC 20030718 - use this to provide instance expecting classes a pointer to a
  * singleton
  */
@@ -266,8 +266,10 @@ HttpHdrRange::parseInit(const String * range_spec)
          * at least one syntactically invalid byte-range-specs.
          */
         if (!spec) {
-            while (!specs.empty())
-                delete specs.pop_back();
+            while (!specs.empty()) {
+                delete specs.back();
+                specs.pop_back();
+            }
             debugs(64, 2, "ignoring invalid range field: '" << range_spec << "'");
             break;
         }
@@ -281,8 +283,10 @@ HttpHdrRange::parseInit(const String * range_spec)
 
 HttpHdrRange::~HttpHdrRange()
 {
-    while (specs.size())
-        delete specs.pop_back();
+    while (!specs.empty()) {
+        delete specs.back();
+        specs.pop_back();
+    }
 }
 
 HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) :
@@ -338,10 +342,10 @@ HttpHdrRange::packInto(Packer * packer) const
 }
 
 void
-HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
+HttpHdrRange::merge (std::vector<HttpHdrRangeSpec *> &basis)
 {
     /* reset old array */
-    specs.clean();
+    specs.clear();
     /* merge specs:
      * take one spec from "goods" and merge it with specs from
      * "specs" (if any) until there is no overlap */
@@ -350,7 +354,8 @@ HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
     while (i != basis.end()) {
         if (specs.size() && (*i)->mergeWith(specs.back())) {
             /* merged with current so get rid of the prev one */
-            delete specs.pop_back();
+            delete specs.back();
+            specs.pop_back();
             continue;	/* re-iterate */
         }
 
@@ -363,7 +368,7 @@ HttpHdrRange::merge (Vector<HttpHdrRangeSpec *> &basis)
 }
 
 void
-HttpHdrRange::getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy)
+HttpHdrRange::getCanonizedSpecs(std::vector<HttpHdrRangeSpec *> &copy)
 {
     /* canonize each entry and destroy bad ones if any */
 
@@ -374,8 +379,7 @@ HttpHdrRange::getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy)
             delete (*pos);
     }
 
-    debugs(64, 3, "HttpHdrRange::getCanonizedSpecs: found " <<
-           specs.size() - copy.size() << " bad specs");
+    debugs(64, 3, "found " << specs.size() - copy.size() << " bad specs");
 }
 
 #include "HttpHdrContRange.h"
@@ -404,14 +408,14 @@ int
 HttpHdrRange::canonize (int64_t newClen)
 {
     clen = newClen;
-    debugs(64, 3, "HttpHdrRange::canonize: started with " << specs.count <<
+    debugs(64, 3, "HttpHdrRange::canonize: started with " << specs.size() <<
            " specs, clen: " << clen);
-    Vector<HttpHdrRangeSpec*> goods;
+    std::vector<HttpHdrRangeSpec*> goods;
     getCanonizedSpecs(goods);
     merge (goods);
-    debugs(64, 3, "HttpHdrRange::canonize: finished with " << specs.count <<
+    debugs(64, 3, "HttpHdrRange::canonize: finished with " << specs.size() <<
            " specs");
-    return specs.count > 0;
+    return specs.size() > 0; // fixme, should return bool
 }
 
 /* hack: returns true if range specs are too "complex" for Squid to handle */
@@ -574,7 +578,7 @@ HttpHdrRange::contains(HttpHdrRangeSpec& r) const
 const HttpHdrRangeSpec *
 HttpHdrRangeIter::currentSpec() const
 {
-    if (pos.incrementable())
+    if (pos != end)
         return *pos;
 
     return NULL;
@@ -586,7 +590,7 @@ HttpHdrRangeIter::updateSpec()
     assert (debt_size == 0);
     assert (valid);
 
-    if (pos.incrementable()) {
+    if (pos != end) {
         debt(currentSpec()->length);
     }
 }
@@ -50,6 +50,12 @@
 #include "StrList.h"
 #include "TimeOrTag.h"
 
+#include <algorithm>
+
+/* XXX: the whole set of API managing the entries vector should be rethought
+ *      after the parse4r-ng effort is complete.
+ */
+
 /*
  * On naming conventions:
  *
@@ -435,8 +441,6 @@ HttpHeader::operator =(const HttpHeader &other)
 void
 HttpHeader::clean()
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
 
     assert(owner > hoNone && owner < hoEnd);
     debugs(55, 7, "cleaning hdr: " << this << " owner: " << owner);
@@ -454,27 +458,28 @@ HttpHeader::clean()
          * has been used.  As a hack, just never count zero-sized header
          * arrays.
          */
-        if (0 != entries.count)
-            HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
+        if (!entries.empty())
+            HttpHeaderStats[owner].hdrUCountDistr.count(entries.size());
 
         ++ HttpHeaderStats[owner].destroyedCount;
 
-        HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
+        HttpHeaderStats[owner].busyDestroyedCount += entries.size() > 0;
     } // if (owner <= hoReply)
 
-    while ((e = getEntry(&pos))) {
-        /* tmp hack to try to avoid coredumps */
-
+    for (std::vector<HttpHeaderEntry *>::iterator i = entries.begin(); i != entries.end(); ++i) {
+        HttpHeaderEntry *e = *i;
+        if (e == NULL)
+            continue;
         if (e->id < 0 || e->id >= HDR_ENUM_END) {
-            debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
+            debugs(55, DBG_CRITICAL, "BUG: invalid entry (" << e->id << "). Ignored.");
         } else {
             if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
-            /* yes, this deletion leaves us in an inconsistent state */
             delete e;
         }
     }
-    entries.clean();
+
+    entries.clear();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
     PROF_stop(HttpHeaderClean);
@@ -550,7 +555,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
     const char *field_ptr = header_start;
     const char *header_end = header_start + hdrLen; // XXX: remove
     HttpHeaderEntry *e, *e2;
-    bool warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
+    int warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
 
     PROF_start(HttpHeaderParse);
 
@@ -749,11 +754,11 @@ HttpHeaderEntry *
 HttpHeader::getEntry(HttpHeaderPos * pos) const
 {
     assert(pos);
-    assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)entries.count);
+    assert(*pos >= HttpHeaderInitPos && *pos < static_cast<ssize_t>(entries.size()));
 
-    for (++(*pos); *pos < (ssize_t)entries.count; ++(*pos)) {
-        if (entries.items[*pos])
-            return (HttpHeaderEntry*)entries.items[*pos];
+    for (++(*pos); *pos < static_cast<ssize_t>(entries.size()); ++(*pos)) {
+        if (entries[*pos])
+            return static_cast<HttpHeaderEntry*>(entries[*pos]);
     }
 
     return NULL;
@@ -872,9 +877,9 @@ void
 HttpHeader::delAt(HttpHeaderPos pos, int &headers_deleted)
 {
     HttpHeaderEntry *e;
-    assert(pos >= HttpHeaderInitPos && pos < (ssize_t)entries.count);
-    e = (HttpHeaderEntry*)entries.items[pos];
-    entries.items[pos] = NULL;
+    assert(pos >= HttpHeaderInitPos && pos < static_cast<ssize_t>(entries.size()));
+    e = static_cast<HttpHeaderEntry*>(entries[pos]);
+    entries[pos] = NULL;
     /* decrement header length, allow for ": " and crlf */
     len -= e->name.size() + 2 + e->value.size() + 2;
     assert(len >= 0);
@@ -888,7 +893,7 @@ HttpHeader::delAt(HttpHeaderPos pos, int &headers_deleted)
 void
 HttpHeader::compact()
 {
-    entries.prune(NULL);
+    std::remove(entries.begin(), entries.end(), static_cast<HttpHeaderEntry *>(NULL));
 }
 
 /*
@@ -915,7 +920,7 @@ HttpHeader::addEntry(HttpHeaderEntry * e)
     assert_eid(e->id);
     assert(e->name.size());
 
-    debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
+    debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
     if (CBIT_TEST(mask, e->id))
         ++ Headers[e->id].stat.repCount;
@@ -937,14 +942,14 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
     assert(e);
     assert_eid(e->id);
 
-    debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
+    debugs(55, 7, this << " adding entry: " << e->id << " at " << entries.size());
 
     if (CBIT_TEST(mask, e->id))
         ++ Headers[e->id].stat.repCount;
     else
         CBIT_SET(mask, e->id);
 
-    entries.insert(e);
+    entries.insert(entries.begin(),e);
 
     /* increment header length, allow for ": " and crlf */
     len += e->name.size() + 2 + e->value.size() + 2;
@@ -37,6 +37,9 @@
 #include "MemPool.h"
 #include "SquidString.h"
 
+#include <vector>
+
+/* class forward declarations */
 class HttpHdrCc;
 class HttpHdrContRange;
 class HttpHdrRange;
@@ -176,7 +179,7 @@ class HttpHeader
     inline bool chunked() const; ///< whether message uses chunked Transfer-Encoding
 
     /* protected, do not use these, use interface functions instead */
-    Vector<HttpHeaderEntry *> entries;		/**< parsed fields in raw format */
+    std::vector<HttpHeaderEntry *> entries;		/**< parsed fields in raw format */
     HttpHeaderMask mask;	/**< bit set <=> entry present */
     http_hdr_owner_type owner;	/**< request or reply */
     int len;			/**< length when packed, not counting terminating null-byte */
@@ -1,4 +1,3 @@
-
 /*
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -32,12 +31,13 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "base/Vector.h"
 #include "MemPool.h"
 #include "Packer.h"
 #include "Range.h"
 #include "SquidString.h"
 
+#include <vector>
+
 class HttpReply;
 /* http byte-range-spec */
 
@@ -83,8 +83,8 @@ class HttpHdrRange
     ~HttpHdrRange();
     HttpHdrRange &operator= (HttpHdrRange const &);
 
-    typedef Vector<HttpHdrRangeSpec *>::iterator iterator;
-    typedef Vector<HttpHdrRangeSpec *>::const_iterator const_iterator;
+    typedef std::vector<HttpHdrRangeSpec *>::iterator iterator;
+    typedef std::vector<HttpHdrRangeSpec *>::const_iterator const_iterator;
     iterator begin();
     const_iterator begin () const;
     iterator end();
@@ -103,11 +103,11 @@ class HttpHdrRange
     int64_t lowestOffset(int64_t) const;
     bool offsetLimitExceeded(const int64_t limit) const;
     bool contains(HttpHdrRangeSpec& r) const;
-    Vector<HttpHdrRangeSpec *> specs;
+    std::vector<HttpHdrRangeSpec *> specs;
 
 private:
-    void getCanonizedSpecs (Vector<HttpHdrRangeSpec *> &copy);
-    void merge (Vector<HttpHdrRangeSpec *> &basis);
+    void getCanonizedSpecs (std::vector<HttpHdrRangeSpec *> &copy);
+    void merge (std::vector<HttpHdrRangeSpec *> &basis);
     int64_t clen;
 };
 
@@ -121,6 +121,7 @@ class HttpHdrRangeIter
 
 public:
     HttpHdrRange::iterator pos;
+    HttpHdrRange::iterator end;
     const HttpHdrRangeSpec *currentSpec() const;
     void updateSpec();
     int64_t debt() const;
@@ -478,7 +478,7 @@ HttpRequest::adaptHistoryImport(const HttpRequest &them)
 bool
 HttpRequest::multipartRangeRequest() const
 {
-    return (range && range->specs.count > 1);
+    return (range && range->specs.size() > 1);
 }
 
 bool
@@ -551,8 +551,6 @@ squid_SOURCES = \
 	$(UNLINKDSOURCE) \
 	url.cc \
 	URL.h \
-	URLScheme.cc \
-	URLScheme.h \
 	urn.h \
 	urn.cc \
 	wccp.h \
@@ -623,6 +621,7 @@ squid_LDADD = \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
+	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
@@ -640,7 +639,6 @@ squid_LDADD = \
 	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
-	$(SSL_LIBS) \
 	$(SNMP_LIBS) \
 	parser/libsquid-parser.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -1076,8 +1074,7 @@ check_PROGRAMS+=\
 	tests/testSBuf \
 	tests/testSBufList \
 	tests/testConfigParser \
-	tests/testStatHist \
-	tests/testVector
+	tests/testStatHist
 
 if HAVE_FS_ROCK
 check_PROGRAMS += tests/testRock
@@ -1190,7 +1187,6 @@ tests_testHttpReply_SOURCES=\
 	tests/testMain.cc \
 	tests/stub_time.cc \
 	url.cc \
-	URLScheme.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpReply_SOURCES=\
@@ -1323,8 +1319,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_time.cc \
 	url.cc \
 	URL.h \
-	URLScheme.cc \
-	URLScheme.h \
 	Mem.h \
 	tests/stub_mem.cc \
 	MemBuf.cc \
@@ -1567,7 +1561,6 @@ tests_testCacheManager_SOURCES = \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
-	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
@@ -1754,7 +1747,6 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_time.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
-	URLScheme.cc \
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc \
@@ -1785,9 +1777,9 @@ tests_testDiskIO_LDADD = \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
 	mgr/libmgr.la \
+	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
-	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -1996,7 +1988,6 @@ tests_testEvent_SOURCES = \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
-	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
@@ -2241,7 +2232,6 @@ tests_testEventLoop_SOURCES = \
 	MemStore.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
-	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
@@ -2479,7 +2469,6 @@ tests_test_http_range_SOURCES = \
 	tests/stub_tunnel.cc \
 	$(UNLINKDSOURCE) \
 	url.cc \
-	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
@@ -2767,7 +2756,6 @@ tests_testHttpRequest_SOURCES = \
 	tests/stub_SwapDir.cc \
 	MemStore.cc \
 	url.cc \
-	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
@@ -2788,6 +2776,7 @@ tests_testHttpRequest_LDADD = \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
+	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
 	mgr/libmgr.la \
@@ -2801,7 +2790,6 @@ tests_testHttpRequest_LDADD = \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
-	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -2953,7 +2941,6 @@ tests_testStore_SOURCES= \
 	tests/TestSwapDir.h \
 	tests/stub_time.cc \
 	url.cc \
-	URLScheme.cc \
 	wordlist.h \
 	wordlist.cc
 
@@ -2974,9 +2961,9 @@ tests_testStore_LDADD= \
 	ip/libip.la \
 	fs/libfs.la \
 	mgr/libmgr.la \
+	$(SSL_LIBS) \
 	ipc/libipc.la \
 	anyp/libanyp.la \
-	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -3181,7 +3168,6 @@ tests_testUfs_SOURCES = \
 	tests/testStoreSupport.cc \
 	tests/testStoreSupport.h \
 	time.cc \
-	URLScheme.cc \
 	wordlist.h \
 	wordlist.cc \
 	$(DISKIO_SOURCE)
@@ -3209,8 +3195,8 @@ tests_testUfs_LDADD = \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
-	ipc/libipc.la \
 	$(SSL_LIBS) \
+	ipc/libipc.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	base/libbase.la \
@@ -3255,7 +3241,7 @@ tests_testRock_SOURCES = \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
-	tests/stub_fatal.cc \
+	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
@@ -3363,7 +3349,6 @@ tests_testRock_SOURCES = \
 	tests/stub_tools.cc \
 	time.cc \
 	url.cc \
-	URLScheme.cc \
 	wordlist.h \
 	wordlist.cc \
 	$(DELAY_POOL_SOURCE) \
@@ -3389,9 +3374,10 @@ tests_testRock_LDADD = \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
+	eui/libeui.la \
+	$(SSL_LIBS) \
 	ipc/libipc.la \
 	base/libbase.la \
-	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -3588,16 +3574,15 @@ tests_testURL_SOURCES = \
 	tests/stub_store_stats.cc \
 	tests/testURL.cc \
 	tests/testURL.h \
-	tests/testURLScheme.cc \
-	tests/testURLScheme.h \
+	tests/testUriScheme.cc \
+	tests/testUriScheme.h \
 	tests/testMain.cc \
 	tests/stub_time.cc \
 	tests/stub_EventLoop.cc \
 	tools.h \
 	tools.cc \
 	tests/stub_tunnel.cc \
 	url.cc \
-	URLScheme.cc \
 	urn.h \
 	urn.cc \
 	wccp2.h \
@@ -3622,6 +3607,7 @@ tests_testURL_LDADD = \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
+	$(SSL_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -3634,7 +3620,6 @@ tests_testURL_LDADD = \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
-	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -3815,21 +3800,6 @@ tests_testStatHist_LDADD = \
 	$(COMPAT_LIB)
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
-tests_testVector_SOURCES = \
-	tests/testVector.cc \
-	tests/testMain.cc \
-	tests/testVector.h
-nodist_tests_testVector_SOURCES = \
-	$(TESTSOURCES)
-tests_testVector_LDADD= \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-tests_testVector_LDFLAGS = $(LIBADD_DL)
-tests_testVector_DEPENDENCIES = \
-	$(SQUID_CPPUNIT_LA)
-
-
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script
@@ -146,21 +146,23 @@ Notes::dump(StoreEntry *entry, const char *key)
 void
 Notes::clean()
 {
-    notes.clean();
+    notes.clear();
 }
 
 NotePairs::~NotePairs()
 {
-    while (!entries.empty())
-        delete entries.pop_back();
+    while (!entries.empty()) {
+        delete entries.back();
+        entries.pop_back();
+    }
 }
 
 const char *
 NotePairs::find(const char *noteKey) const
 {
     static String value;
     value.clean();
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0) {
             if (value.size())
                 value.append(", ");
@@ -175,7 +177,7 @@ NotePairs::toString(const char *sep) const
 {
     static String value;
     value.clean();
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         value.append((*i)->name);
         value.append(": ");
         value.append(ConfigParser::QuoteString((*i)->value));
@@ -187,7 +189,7 @@ NotePairs::toString(const char *sep) const
 const char *
 NotePairs::findFirst(const char *noteKey) const
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0)
             return (*i)->value.termedBuf();
     }
@@ -217,7 +219,7 @@ NotePairs::addStrList(const char *key, const char *values)
 bool
 NotePairs::hasPair(const char *key, const char *value) const
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(key) == 0 && (*i)->value.cmp(value) == 0)
             return true;
     }
@@ -227,15 +229,15 @@ NotePairs::hasPair(const char *key, const char *value) const
 void
 NotePairs::append(const NotePairs *src)
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
         entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
     }
 }
 
 void
 NotePairs::appendNewOnly(const NotePairs *src)
 {
-    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
         if (!hasPair((*i)->name.termedBuf(), (*i)->value.termedBuf()))
             entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
     }
@@ -3,7 +3,6 @@
 
 #include "acl/forward.h"
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "CbDataList.h"
 #include "format/Format.h"
 #include "MemPool.h"
@@ -13,6 +12,7 @@
 #if HAVE_STRING
 #include <string>
 #endif
+#include <vector>
 
 class HttpRequest;
 class HttpReply;
@@ -40,7 +40,7 @@ class Note: public RefCountable
         explicit Value(const String &aVal) : value(aVal), aclList(NULL), valueFormat(NULL) {}
         ~Value();
     };
-    typedef Vector<Value::Pointer> Values;
+    typedef std::vector<Value::Pointer> Values;
 
     explicit Note(const String &aKey): key(aKey) {}
 
@@ -70,13 +70,13 @@ class ConfigParser;
 class Notes
 {
 public:
-    typedef Vector<Note::Pointer> NotesList;
+    typedef std::vector<Note::Pointer> NotesList;
     typedef NotesList::iterator iterator; ///< iterates over the notes list
     typedef NotesList::const_iterator const_iterator; ///< iterates over the notes list
 
     Notes(const char *aDescr, const char **metasBlacklist, bool allowFormatted = false): descr(aDescr), blacklisted(metasBlacklist), formattedValues(allowFormatted) {}
     Notes(): descr(NULL), blacklisted(NULL) {}
-    ~Notes() { notes.clean(); }
+    ~Notes() { notes.clear(); }
     /**
      * Parse a notes line and returns a pointer to the
      * parsed Note object.
@@ -184,7 +184,7 @@ class NotePairs: public RefCountable
      */
     bool empty() const {return entries.empty();}
 
-    Vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
+    std::vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
 
 private:
     NotePairs &operator = (NotePairs const &); // Not implemented
@@ -35,7 +35,6 @@
 
 #include "AccessLogEntry.h"
 #include "acl/Checklist.h"
-#include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
@@ -240,6 +240,7 @@ SBuf::append(const char * S, size_type Ssize)
     if (Ssize == npos)
         Ssize = strlen(S);
     debugs(24, 7, "from c-string to id " << id);
+    // coverity[access_dbuff_in_call]
     return lowAppend(S, Ssize);
 }
 
@@ -11,7 +11,7 @@ class SBufEqual
 {
 public:
     explicit SBufEqual(const SBuf &reference, SBufCaseSensitive sensitivity = caseSensitive) :
-        reference_(reference), sensitivity_(sensitivity) {}
+            reference_(reference), sensitivity_(sensitivity) {}
     bool operator() (const SBuf & checking) { return checking.compare(reference_,sensitivity_) == 0; }
 private:
     SBuf reference_;
@@ -23,7 +23,7 @@ class SBufStartsWith
 {
 public:
     explicit SBufStartsWith(const SBuf &prefix, SBufCaseSensitive sensitivity = caseSensitive) :
-        prefix_(prefix), sensitivity_(sensitivity) {}
+            prefix_(prefix), sensitivity_(sensitivity) {}
     bool operator() (const SBuf & checking) { return checking.startsWith(prefix_,sensitivity_); }
 private:
     SBuf prefix_;
@@ -38,7 +38,7 @@ class SBufAddLength
 {
 public:
     explicit SBufAddLength(const SBuf &separator) :
-        separatorLen_(separator.length()) {}
+            separatorLen_(separator.length()) {}
     SBuf::size_type operator()(const SBuf::size_type sz, const SBuf & item) {
         return sz + item.length() + separatorLen_;
     }
@@ -68,7 +68,7 @@ SBufContainerJoin(const Container &items, const SBuf& separator)
     typename Container::const_iterator i(items.begin());
     rv.append(*i);
     ++i;
-    for (;i != items.end(); ++i)
+    for (; i != items.end(); ++i)
         rv.append(separator).append(*i);
     return rv;
 }
@@ -10,16 +10,16 @@
 static StatHist sbufDestructTimeStats;
 static StatHist memblobDestructTimeStats;
 
-namespace SBufDetailedStatsHistInitializer {
-    // run the post-instantiation initialization methods for StatHist objects
-    struct Initializer
-    {
-        Initializer() {
-            sbufDestructTimeStats.logInit(300,30.0,128000.0);
-            memblobDestructTimeStats.logInit(300,30.0,128000.0);
-        }
-    };
-    Initializer initializer;
+namespace SBufDetailedStatsHistInitializer
+{
+// run the post-instantiation initialization methods for StatHist objects
+struct Initializer {
+    Initializer() {
+        sbufDestructTimeStats.logInit(300,30.0,128000.0);
+        memblobDestructTimeStats.logInit(300,30.0,128000.0);
+    }
+};
+Initializer initializer;
 }
 
 void
@@ -67,8 +67,8 @@ SBufStatsAction::dump(StoreEntry* entry)
 {
     StoreEntryStream ses(entry);
     ses << "\n\n\nThese statistics are experimental; their format and contents "
-        "should not be relied upon, they are bound to change as "
-        "the SBuf feature is evolved\n";
+    "should not be relied upon, they are bound to change as "
+    "the SBuf feature is evolved\n";
     sbdata.dump(ses);
     mbdata.dump(ses);
     ses << "\n";
@@ -492,6 +492,8 @@ class SquidConfig
     struct {
         int unclean_shutdown;
         char *ssl_engine;
+        int session_ttl;
+        size_t sessionCacheSize;
     } SSL;
 #endif
 
@@ -35,7 +35,7 @@
 #include "squid.h"
 #include "StoreFileSystem.h"
 
-Vector<StoreFileSystem*> *StoreFileSystem::_FileSystems = NULL;
+std::vector<StoreFileSystem*> *StoreFileSystem::_FileSystems = NULL;
 
 void
 StoreFileSystem::RegisterAllFsWithCacheManager(void)
@@ -65,17 +65,17 @@ StoreFileSystem::FsAdd(StoreFileSystem &instance)
     GetFileSystems().push_back (&instance);
 }
 
-Vector<StoreFileSystem *> const &
+std::vector<StoreFileSystem *> const &
 StoreFileSystem::FileSystems()
 {
     return GetFileSystems();
 }
 
-Vector<StoreFileSystem*> &
+std::vector<StoreFileSystem*> &
 StoreFileSystem::GetFileSystems()
 {
     if (!_FileSystems)
-        _FileSystems = new Vector<StoreFileSystem *>;
+        _FileSystems = new std::vector<StoreFileSystem *>;
 
     return *_FileSystems;
 }
@@ -87,7 +87,7 @@ StoreFileSystem::GetFileSystems()
 void
 StoreFileSystem::FreeAllFs()
 {
-    while (GetFileSystems().size()) {
+    while (!GetFileSystems().empty()) {
         StoreFileSystem *fs = GetFileSystems().back();
         GetFileSystems().pop_back();
         fs->done();
@@ -31,7 +31,7 @@
 #ifndef SQUID_STOREFILESYSTEM_H
 #define SQUID_STOREFILESYSTEM_H
 
-#include "base/Vector.h"
+#include <vector>
 
 /* ****** DOCUMENTATION ***** */
 
@@ -116,9 +116,9 @@ class StoreFileSystem
     static void SetupAllFs();
     static void FsAdd(StoreFileSystem &);
     static void FreeAllFs();
-    static Vector<StoreFileSystem*> const &FileSystems();
-    typedef Vector<StoreFileSystem*>::iterator iterator;
-    typedef Vector<StoreFileSystem*>::const_iterator const_iterator;
+    static std::vector<StoreFileSystem*> const &FileSystems();
+    typedef std::vector<StoreFileSystem*>::iterator iterator;
+    typedef std::vector<StoreFileSystem*>::const_iterator const_iterator;
     StoreFileSystem() : initialised(false) {}
 
     virtual ~StoreFileSystem() {}
@@ -136,8 +136,8 @@ class StoreFileSystem
     virtual void registerWithCacheManager(void);
 
 private:
-    static Vector<StoreFileSystem*> &GetFileSystems();
-    static Vector<StoreFileSystem*> *_FileSystems;
+    static std::vector<StoreFileSystem*> &GetFileSystems();
+    static std::vector<StoreFileSystem*> *_FileSystems;
     static void RegisterAllFsWithCacheManager(void);
 };
 
@@ -117,7 +117,7 @@ class StoreSearchHashIndex : public StoreSearch
     void *cbdata;
     bool _done;
     int bucket;
-    Vector<StoreEntry *> entries;
+    std::vector<StoreEntry *> entries;
 
     // keep this last. it plays with private/public
     CBDATA_CLASS2(StoreSearchHashIndex);
@@ -31,9 +31,8 @@
 #ifndef SQUID_SRC_URL_H
 #define SQUID_SRC_URL_H
 
-#include "anyp/ProtocolType.h"
+#include "anyp/UriScheme.h"
 #include "MemPool.h"
-#include "URLScheme.h"
 
 /**
  \ingroup POD
@@ -42,13 +41,11 @@
  */
 class URL
 {
-
 public:
-
     MEMPROXY_CLASS(URL);
-    URL();
-    URL(URLScheme const &);
-    URLScheme const & getScheme() const {return scheme; }
+    URL() : scheme_() {}
+    URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme) {}
+    AnyP::UriScheme const & getScheme() const {return scheme_;}
 
 private:
     /**
@@ -62,7 +59,7 @@ class URL
      * is to have one prototype URL with no host etc for each scheme,
      * another is to have an explicit scheme class, and then each URL class
      * could be a subclass of the scheme. Another way is one instance of
-     * a URLScheme class instance for each URLScheme we support, and one URL
+     * a AnyP::UriScheme class instance for each URL scheme we support, and one URL
      * class for each manner of treating the scheme : a Hierarchical URL, a
      * non-hierarchical URL etc.
      \par
@@ -71,7 +68,7 @@ class URL
      * In order to make taking any of these routes easy, scheme is private
      * and immutable, only settable at construction time,
      */
-    URLScheme const scheme;
+    AnyP::UriScheme const scheme_;
 };
 
 MEMPROXY_CLASS_INLINE(URL);
@@ -1,54 +0,0 @@
-
-/*
- * DEBUG: section 23    URL Scheme parsing
- * AUTHOR: Robert Collins
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-#include "URLScheme.h"
-#include "wordlist.h"
-
-char const *
-URLScheme::const_str() const
-{
-    if (theScheme_ == AnyP::PROTO_UNKNOWN)
-        return "(unknown)";
-
-    static char out[BUFSIZ];
-    int p = 0;
-
-    if (theScheme_ > AnyP::PROTO_NONE && theScheme_ < AnyP::PROTO_MAX) {
-        const char *in = AnyP::ProtocolType_str[theScheme_];
-        for (; p < (BUFSIZ-1) && in[p] != '\0'; ++p)
-            out[p] = xtolower(in[p]);
-    }
-    out[p] = '\0';
-    return out;
-}
@@ -1,74 +0,0 @@
-
-/*
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#ifndef SQUID_URLSCHEME_H
-#define SQUID_URLSCHEME_H
-
-#include "anyp/ProtocolType.h"
-#if HAVE_IOSFWD
-#include <iosfwd>
-#endif
-
-/** This class represents a URL Scheme such as HTTPS, HTTP, WAIS etc.
- * It does not represent the PROTOCOL that such schemes refer to.
- */
-class URLScheme
-{
-
-public:
-    URLScheme() : theScheme_(AnyP::PROTO_NONE) {}
-    URLScheme(AnyP::ProtocolType const aScheme) : theScheme_(aScheme) {}
-    ~URLScheme() {}
-
-    operator AnyP::ProtocolType() const { return theScheme_; }
-
-    bool operator != (AnyP::ProtocolType const & aProtocol) const { return theScheme_ != aProtocol; }
-
-    /** Get a char string representation of the scheme.
-     * An upper bound length of BUFSIZ bytes converted. Remainder will be truncated.
-     * The result of this call will remain usable only until any subsequest call
-     * and must be copied if persistence is needed.
-     */
-    char const *const_str() const;
-
-private:
-    /// This is a typecode pointer into the enum/registry of protocols handled.
-    AnyP::ProtocolType theScheme_;
-};
-
-inline std::ostream &
-operator << (std::ostream &os, URLScheme const &scheme)
-{
-    os << scheme.const_str();
-    return os;
-}
-
-#endif /* SQUID_URLSCHEME_H */
@@ -510,7 +510,7 @@ int WIN32_Subsystem_Init(int * argc, char *** argv)
             return 1;
 
         /* Register the service Handler function */
-        svcHandle = RegisterServiceCtrlHandler(WIN32_Service_name, WIN32_svcHandler);
+        svcHandle = RegisterServiceCtrlHandler(service_name, WIN32_svcHandler);
 
         if (svcHandle == 0)
             return 1;
@@ -671,12 +671,12 @@ WIN32_RemoveService()
     SC_HANDLE schService;
     SC_HANDLE schSCManager;
 
-    if (!WIN32_Service_name)
-        WIN32_Service_name = xstrdup(_WIN_SQUID_DEFAULT_SERVICE_NAME);
+    if (!service_name)
+        service_name = xstrdup(APP_SHORTNAME);
 
-    strcat(REGKEY, WIN32_Service_name);
+    strcat(REGKEY, service_name);
 
-    keys[4] = WIN32_Service_name;
+    keys[4] = service_name;
 
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
@@ -686,7 +686,7 @@ WIN32_RemoveService()
     if (!schSCManager)
         fprintf(stderr, "OpenSCManager failed\n");
     else {
-        schService = OpenService(schSCManager, WIN32_Service_name, SERVICE_ALL_ACCESS);
+        schService = OpenService(schSCManager, service_name, SERVICE_ALL_ACCESS);
 
         if (schService == NULL)
             fprintf(stderr, "OpenService failed\n");
@@ -711,8 +711,7 @@ WIN32_RemoveService()
             if (DeleteService(schService) == 0)
                 fprintf(stderr, "DeleteService failed.\n");
             else
-                printf("Service %s deleted successfully.\n",
-                       WIN32_Service_name);
+                printf("Service %s deleted successfully.\n", service_name);
 
             CloseServiceHandle(schService);
         }
@@ -724,12 +723,12 @@ WIN32_RemoveService()
 void
 WIN32_SetServiceCommandLine()
 {
-    if (!WIN32_Service_name)
-        WIN32_Service_name = xstrdup(_WIN_SQUID_DEFAULT_SERVICE_NAME);
+    if (!service_name)
+        service_name = xstrdup(APP_SHORTNAME);
 
-    strcat(REGKEY, WIN32_Service_name);
+    strcat(REGKEY, service_name);
 
-    keys[4] = WIN32_Service_name;
+    keys[4] = service_name;
 
     /* Now store the Service Command Line in the registry */
     WIN32_StoreKey(COMMANDLINE, REG_SZ, (unsigned char *) WIN32_Command_Line, strlen(WIN32_Command_Line) + 1);
@@ -744,19 +743,19 @@ WIN32_InstallService()
     char szPath[512];
     int lenpath;
 
-    if (!WIN32_Service_name)
-        WIN32_Service_name = xstrdup(_WIN_SQUID_DEFAULT_SERVICE_NAME);
+    if (!service_name)
+        service_name = xstrdup(APP_SHORTNAME);
 
-    strcat(REGKEY, WIN32_Service_name);
+    strcat(REGKEY, service_name);
 
-    keys[4] = WIN32_Service_name;
+    keys[4] = service_name;
 
     if ((lenpath = GetModuleFileName(NULL, ServicePath, 512)) == 0) {
         fprintf(stderr, "Can't get executable path\n");
         exit(1);
     }
 
-    snprintf(szPath, sizeof(szPath), "%s %s:%s", ServicePath, _WIN_SQUID_SERVICE_OPTION, WIN32_Service_name);
+    snprintf(szPath, sizeof(szPath), "%s %s:%s", ServicePath, _WIN_SQUID_SERVICE_OPTION, service_name);
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
                                  SC_MANAGER_ALL_ACCESS	/* access required            */
@@ -767,8 +766,8 @@ WIN32_InstallService()
         exit(1);
     } else {
         schService = CreateService(schSCManager,    /* SCManager database     */
-                                   WIN32_Service_name,			    /* name of service        */
-                                   WIN32_Service_name,			    /* name to display        */
+                                   service_name,			    /* name of service        */
+                                   service_name,			    /* name to display        */
                                    SERVICE_ALL_ACCESS,			    /* desired access         */
                                    SERVICE_WIN32_OWN_PROCESS,		    /* service type           */
                                    SERVICE_AUTO_START,			    /* start type             */
@@ -801,15 +800,9 @@ WIN32_InstallService()
 
             WIN32_StoreKey(CONFIGFILE, REG_SZ, (unsigned char *) ConfigFile, strlen(ConfigFile) + 1);
 
-            printf("Squid Cache version %s for %s\n", version_string,
-                   CONFIG_HOST_TYPE);
-
-            printf("installed successfully as %s Windows System Service.\n",
-                   WIN32_Service_name);
-
-            printf
-            ("To run, start it from the Services Applet of Control Panel.\n");
-
+            printf("Squid Cache version %s for %s\n", version_string, CONFIG_HOST_TYPE);
+            printf("installed successfully as %s Windows System Service.\n", service_name);
+            printf("To run, start it from the Services Applet of Control Panel.\n");
             printf("Don't forget to edit squid.conf before starting it.\n\n");
         } else {
             fprintf(stderr, "CreateService failed\n");
@@ -828,8 +821,8 @@ WIN32_sendSignal(int WIN32_signal)
     SC_HANDLE schService;
     SC_HANDLE schSCManager;
 
-    if (!WIN32_Service_name)
-        WIN32_Service_name = xstrdup(_WIN_SQUID_DEFAULT_SERVICE_NAME);
+    if (!service_name)
+        service_name = xstrdup(APP_SHORTNAME);
 
     schSCManager = OpenSCManager(NULL,	/* machine (NULL == local)    */
                                  NULL,			/* database (NULL == default) */
@@ -882,12 +875,11 @@ WIN32_sendSignal(int WIN32_signal)
 
     /* Open a handle to the service. */
     schService = OpenService(schSCManager,	/* SCManager database */
-                             WIN32_Service_name,	/* name of service    */
+                             service_name,	/* name of service    */
                              fdwAccess);		/* specify access     */
 
     if (schService == NULL) {
-        fprintf(stderr, "%s: ERROR: Could not open Service %s\n", APP_SHORTNAME,
-                WIN32_Service_name);
+        fprintf(stderr, "%s: ERROR: Could not open Service %s\n", APP_SHORTNAME, service_name);
         exit(1);
     } else {
         /* Send a control value to the service. */
@@ -896,11 +888,11 @@ WIN32_sendSignal(int WIN32_signal)
                             fdwControl,	/* control value to send  */
                             &ssStatus)) {	/* address of status info */
             fprintf(stderr, "%s: ERROR: Could not Control Service %s\n",
-                    APP_SHORTNAME, WIN32_Service_name);
+                    APP_SHORTNAME, service_name);
             exit(1);
         } else {
             /* Print the service status. */
-            printf("\nStatus of %s Service:\n", WIN32_Service_name);
+            printf("\nStatus of %s Service:\n", service_name);
             printf("  Service Type: 0x%lx\n", ssStatus.dwServiceType);
             printf("  Current State: 0x%lx\n", ssStatus.dwCurrentState);
             printf("  Controls Accepted: 0x%lx\n", ssStatus.dwControlsAccepted);
@@ -939,10 +931,10 @@ int main(int argc, char **argv)
             return 1;
         }
 
-        WIN32_Service_name = xstrdup(c+1);
-        DispatchTable[0].lpServiceName=WIN32_Service_name;
-        strcat(REGKEY, WIN32_Service_name);
-        keys[4] = WIN32_Service_name;
+        service_name = xstrdup(c+1);
+        DispatchTable[0].lpServiceName=service_name;
+        strcat(REGKEY, service_name);
+        keys[4] = service_name;
 
         if (!StartServiceCtrlDispatcher(DispatchTable)) {
             fprintf(stderr, "StartServiceCtrlDispatcher error = %ld\n",
@@ -41,6 +41,8 @@
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
+#include <vector>
+
 const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
 
 const char *AclMatchedName = NULL;
@@ -405,7 +407,7 @@ ACL::Prototype::Prototype (ACL const *aPrototype, char const *aType) : prototype
     registerMe ();
 }
 
-Vector<ACL::Prototype const *> * ACL::Prototype::Registry;
+std::vector<ACL::Prototype const *> * ACL::Prototype::Registry;
 void *ACL::Prototype::Initialized;
 
 bool
@@ -429,7 +431,7 @@ ACL::Prototype::registerMe ()
     if (!Registry || (Initialized != ((char *)Registry - 5))  ) {
         /* TODO: extract this */
         /* Not initialised */
-        Registry = new Vector <ACL::Prototype const *>;
+        Registry = new std::vector<ACL::Prototype const *>;
         Initialized = (char *)Registry - 5;
     }
 
@@ -34,7 +34,6 @@
 #define SQUID_ACL_H
 
 #include "acl/forward.h"
-#include "base/Vector.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
@@ -46,6 +45,7 @@
 #if HAVE_STRING
 #include <string>
 #endif
+#include <vector>
 
 class ConfigParser;
 
@@ -101,10 +101,10 @@ class ACL
     void *operator new(size_t);
     void operator delete(void *);
 
-    static ACL *Factory (char const *);
+    static ACL *Factory(char const *);
     static void ParseAclLine(ConfigParser &parser, ACL ** head);
     static void Initialize();
-    static ACL* FindByName(const char *name);
+    static ACL *FindByName(const char *name);
 
     ACL();
     explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs) { memset(name, '\0', sizeof(name)); }
@@ -119,15 +119,15 @@ class ACL
     /// Updates the checklist state on match, async, and failure.
     bool matches(ACLChecklist *checklist) const;
 
-    virtual ACL *clone()const = 0;
+    virtual ACL *clone() const = 0;
 
     /// parses node represenation in squid.conf; dies on failures
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
     virtual wordlist *dump() const = 0;
-    virtual bool empty () const = 0;
-    virtual bool valid () const;
+    virtual bool empty() const = 0;
+    virtual bool valid() const;
 
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
@@ -146,21 +146,21 @@ class ACL
     {
 
     public:
-        Prototype ();
-        Prototype (ACL const *, char const *);
+        Prototype();
+        Prototype(ACL const *, char const *);
         ~Prototype();
         static bool Registered(char const *);
-        static ACL *Factory (char const *);
+        static ACL *Factory(char const *);
 
     private:
-        ACL const*prototype;
+        ACL const *prototype;
         char const *typeString;
 
     private:
-        static Vector<Prototype const *> * Registry;
+        static std::vector<Prototype const *> * Registry;
         static void *Initialized;
-        typedef Vector<Prototype const*>::iterator iterator;
-        typedef Vector<Prototype const*>::const_iterator const_iterator;
+        typedef std::vector<Prototype const*>::iterator iterator;
+        typedef std::vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
 
@@ -75,7 +75,7 @@ struct squid_radix_node_head *AS_tree_head;
 
 /* explicit instantiation required for some systems */
 
-/// \cond AUTODOCS-IGNORE
+/// \cond AUTODOCS_IGNORE
 template cbdata_type CbDataList<int>::CBDATA_CbDataList;
 /// \endcond
 
@@ -59,7 +59,7 @@ ACLCertificateData::ACLCertificateData(ACLCertificateData const &old) : attribut
     validAttributes.assign (old.validAttributes.begin(), old.validAttributes.end());
     attributeIsOptional = old.attributeIsOptional;
     if (old.attribute)
-        attribute = xstrdup (old.attribute);
+        attribute = xstrdup(old.attribute);
 }
 
 template<class T>
@@ -64,6 +64,7 @@ ACLChecklist::preCheck(const char *what)
     // concurrent checks using the same Checklist are not supported
     assert(!occupied_);
     occupied_ = true;
+    asyncLoopDepth_ = 0;
 
     AclMatchedName = NULL;
     finished_ = false;
@@ -77,6 +78,7 @@ ACLChecklist::matchChild(const Acl::InnerNode *current, Acl::Nodes::const_iterat
     // Remember the current tree location to prevent "async loop" cases where
     // the same child node wants to go async more than once.
     matchLoc_ = Breadcrumb(current, pos);
+    asyncLoopDepth_ = 0;
 
     // if there are any breadcrumbs left, then follow them on the way down
     bool result = false;
@@ -116,11 +118,16 @@ ACLChecklist::goAsync(AsyncState *state)
 
     // TODO: add a once-in-a-while WARNING about async loops?
     if (matchLoc_ == asyncLoc_) {
-        debugs(28, 2, this << " a slow ACL resumes by going async again!");
-        return false;
+        debugs(28, 2, this << " a slow ACL resumes by going async again! (loop #" << asyncLoopDepth_ << ")");
+        // external_acl_type may cause async auth lookup plus its own async check
+        // which has the appearance of a loop. Allow some retries.
+        // TODO: make it configurable and check BH retry attempts vs this check?
+        if (asyncLoopDepth_ > 5)
+            return false;
     }
 
     asyncLoc_ = matchLoc_; // prevent async loops
+    ++asyncLoopDepth_;
 
     asyncStage_ = asyncStarting;
     changeState(state);
@@ -168,7 +175,8 @@ ACLChecklist::ACLChecklist() :
         finished_(false),
         allow_(ACCESS_DENIED),
         asyncStage_(asyncNone),
-        state_(NullState::Instance())
+        state_(NullState::Instance()),
+        asyncLoopDepth_(0)
 {
 }
 
@@ -233,6 +233,7 @@ class ACLChecklist
     AsyncState *state_;
     Breadcrumb matchLoc_; ///< location of the node running matches() now
     Breadcrumb asyncLoc_; ///< currentNode_ that called goAsync()
+    unsigned asyncLoopDepth_; ///< how many times the current async state has resumed
 
     bool callerGone();
 
@@ -53,7 +53,6 @@
 #include <set>
 #include <algorithm>
 
-
 typedef std::set<ACL*> AclSet;
 /// Accumulates all ACLs to facilitate their clean deletion despite reuse.
 static AclSet *RegisteredAcls; // TODO: Remove when ACLs are refcounted
@@ -80,7 +80,7 @@ Acl::InnerNode::match(ACLChecklist *checklist)
 }
 
 bool
-Acl::InnerNode::resumeMatchingAt(ACLChecklist *checklist, Nodes::const_iterator pos) const
+Acl::InnerNode::resumeMatchingAt(ACLChecklist *checklist, Acl::Nodes::const_iterator pos) const
 {
     debugs(28, 5, "checking " << name << " at " << (pos-nodes.begin()));
     const int result = doMatch(checklist, pos);
@@ -40,7 +40,7 @@
 #include "wordlist.h"
 
 /* explicit instantiation required for some systems */
-/** \cond AUTODOCS-IGNORE */
+/** \cond AUTODOCS_IGNORE */
 template cbdata_type CbDataList< Range<int> >::CBDATA_CbDataList;
 /** \endcond */
 
@@ -63,7 +63,7 @@ ACLMethodData::match(HttpRequestMethod toFind)
 
 /* explicit instantiation required for some systems */
 
-/// \cond AUTODOCS-IGNORE
+/// \cond AUTODOCS_IGNORE
 template cbdata_type CbDataList<HttpRequestMethod>::CBDATA_CbDataList;
 /// \endcond
 
@@ -29,7 +29,7 @@ ACLNoteData::matchNotes(NotePairs *note)
     if (values->empty())
         return (note->findFirst(name.termedBuf()) != NULL);
 
-    for (Vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
+    for (std::vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
         if ((*i)->name.cmp(name.termedBuf()) == 0) {
             if (values->match((*i)->value.termedBuf()))
                 return true;
@@ -37,7 +37,6 @@
 #include "acl/ProtocolData.h"
 #include "cache_cf.h"
 #include "Debug.h"
-#include "URLScheme.h"
 #include "wordlist.h"
 
 ACLProtocolData::ACLProtocolData() : values (NULL)
@@ -62,7 +61,7 @@ ACLProtocolData::match(AnyP::ProtocolType toFind)
 
 /* explicit instantiation required for some systems */
 
-/// \cond AUTODOCS-IGNORE
+/// \cond AUTODOCS_IGNORE
 template cbdata_type CbDataList<AnyP::ProtocolType>::CBDATA_CbDataList;
 /// \endcond
 
@@ -62,7 +62,7 @@ ACLSslErrorData::match(const Ssl::CertErrors *toFind)
 }
 
 /* explicit instantiation required for some systems */
-/** \cond AUTODOCS-IGNORE */
+/** \cond AUTODOCS_IGNORE */
 // AYJ: 2009-05-20 : Removing. clashes with template <int> instantiation for other ACLs.
 // template cbdata_type Ssl::Errors::CBDATA_CbDataList;
 /** \endcond */
@@ -14,7 +14,7 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
-/** \cond AUTODOCS-IGNORE */
+/** \cond AUTODOCS_IGNORE */
 cbdata_type Adaptation::AccessCheck::CBDATA_AccessCheck = CBDATA_UNKNOWN;
 /** \endcond */
 
@@ -102,7 +102,7 @@ Adaptation::AccessCheck::check()
         AccessRule *r = *i;
         if (isCandidate(*r)) {
             debugs(93, 5, HERE << "check: rule '" << r->id << "' is a candidate");
-            candidates += r->id;
+            candidates.push_back(r->id);
         }
     }
 
@@ -131,7 +131,7 @@ Adaptation::AccessCheck::checkCandidates()
             return;
         }
 
-        candidates.shift(); // the rule apparently went away (reconfigure)
+        candidates.erase(candidates.begin()); // the rule apparently went away (reconfigure)
     }
 
     debugs(93, 4, HERE << "NO candidates left");
@@ -176,7 +176,7 @@ Adaptation::AccessCheck::noteAnswer(allow_t answer)
     }
 
     // no match or the group disappeared during reconfiguration
-    candidates.shift();
+    candidates.erase(candidates.begin());
     checkCandidates();
 }
 
@@ -1,8 +1,8 @@
 #ifndef SQUID_ADAPTATION__ACCESS_CHECK_H
 #define SQUID_ADAPTATION__ACCESS_CHECK_H
 
-#include "acl/Acl.h"
 #include "AccessLogEntry.h"
+#include "acl/Acl.h"
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
@@ -39,7 +39,7 @@ class AccessCheck: public virtual AsyncJob
     ACLFilledChecklist *acl_checklist;
 
     typedef int Candidate;
-    typedef Vector<Candidate> Candidates;
+    typedef std::vector<Candidate> Candidates;
     Candidates candidates;
     Candidate topCandidate() const { return *candidates.begin(); }
     ServiceGroupPointer topGroup() const; // may return nil
@@ -5,6 +5,8 @@
 #include "adaptation/forward.h"
 #include "SquidString.h"
 
+#include <vector>
+
 class ConfigParser;
 
 namespace Adaptation
@@ -34,7 +36,7 @@ class AccessRule
     static Id LastId;
 };
 
-typedef Vector<Adaptation::AccessRule*> AccessRules;
+typedef std::vector<Adaptation::AccessRule*> AccessRules;
 AccessRules &AllRules();
 AccessRule *FindRule(const AccessRule::Id &id);
 AccessRule *FindRuleByGroupId(const String &groupId);
@@ -36,13 +36,14 @@
 #include "adaptation/History.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
-#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Store.h"
 
+#include <algorithm>
+
 bool Adaptation::Config::Enabled = false;
 char *Adaptation::Config::masterx_shared_name = NULL;
 int Adaptation::Config::service_iteration_limit = 16;
@@ -87,15 +88,15 @@ Adaptation::Config::removeService(const String& service)
         for (SGSI it = services.begin(); it != services.end(); ++it) {
             if (*it == service) {
                 group->removedServices.push_back(service);
-                group->services.prune(service);
-                debugs(93, 5, HERE << "adaptation service " << service <<
+                std::remove(group->services.begin(), group->services.end(), service);
+                debugs(93, 5, "adaptation service " << service <<
                        " removed from group " << group->id);
                 break;
             }
         }
         if (services.empty()) {
             removeRule(group->id);
-            AllGroups().prune(group);
+            std::remove(AllGroups().begin(), AllGroups().end(), group);
         } else {
             ++i;
         }
@@ -122,8 +123,8 @@ Adaptation::Config::removeRule(const String& id)
     for (ARI it = rules.begin(); it != rules.end(); ++it) {
         AccessRule* rule = *it;
         if (rule->groupId == id) {
-            debugs(93, 5, HERE << "removing access rules for:" << id);
-            AllRules().prune(rule);
+            debugs(93, 5, "removing access rules for:" << id);
+            std::remove(AllRules().begin(), AllRules().end(), rule);
             delete (rule);
             break;
         }
@@ -139,7 +140,7 @@ Adaptation::Config::clear()
     const ServiceConfigs& configs = serviceConfigs;
     for (SCI cfg = configs.begin(); cfg != configs.end(); ++cfg)
         removeService((*cfg)->key);
-    serviceConfigs.clean();
+    serviceConfigs.clear();
     debugs(93, 3, HERE << "rules: " << AllRules().size() << ", groups: " <<
            AllGroups().size() << ", services: " << serviceConfigs.size());
 }
@@ -163,7 +164,7 @@ Adaptation::Config::freeService()
 
     DetachServices();
 
-    serviceConfigs.clean();
+    serviceConfigs.clear();
 }
 
 void
@@ -210,7 +211,7 @@ Adaptation::Config::finalize()
     debugs(93,3, HERE << "Created " << created << " adaptation services");
 
     // services remember their configs; we do not have to
-    serviceConfigs.clean();
+    serviceConfigs.clear();
     return true;
 }
 
@@ -51,7 +51,7 @@ class Config
 
     static bool needHistory; ///< HttpRequest adaptation history should recorded
 
-    typedef Vector<ServiceConfigPointer> ServiceConfigs;
+    typedef std::vector<ServiceConfigPointer> ServiceConfigs;
     ServiceConfigs serviceConfigs;
 
     Config();
@@ -18,5 +18,5 @@ void
 Adaptation::DynamicGroupCfg::clear()
 {
     id.clean();
-    services.clean();
+    services.clear();
 }
@@ -1,17 +1,18 @@
 #ifndef SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 #define SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 
-#include "base/Vector.h"
 #include "SquidString.h"
 
+#include <vector>
+
 namespace Adaptation
 {
 
 /// DynamicServiceGroup configuration to remember future dynamic chains
 class DynamicGroupCfg
 {
 public:
-    typedef Vector<String> Store;
+    typedef std::vector<String> Store;
     typedef String Id;
 
     Id id; ///< group id
@@ -3,7 +3,6 @@
 
 #include "adaptation/DynamicGroupCfg.h"
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "HttpHeader.h"
 #include "Notes.h"
 #include "SBuf.h"
@@ -57,7 +56,7 @@ class History: public RefCountable
     /// AccessLogEntry::notes when ALE becomes available
     NotePairs::Pointer metaHeaders;
 
-    typedef Vector<SBuf> AdaptationServices;
+    typedef std::vector<SBuf> AdaptationServices;
     AdaptationServices theAdaptationServices; ///< The service groups used
 
     /// sets future services for the Adaptation::AccessCheck to notice
@@ -87,7 +86,7 @@ class History: public RefCountable
         bool retried; ///< whether the xaction was replaced by another
     };
 
-    typedef Vector<Entry> Entries;
+    typedef std::vector<Entry> Entries;
     Entries theEntries; ///< historical record, in the order of xact starts
 
     // theXx* will become a map<string,string>, but we only support one record
@@ -71,6 +71,8 @@ Adaptation::FindService(const Service::Id& key)
 
 void Adaptation::DetachServices()
 {
-    while (!AllServices().empty())
-        AllServices().pop_back()->detach();
+    while (!AllServices().empty()) {
+        AllServices().back()->detach();
+        AllServices().pop_back();
+    }
 }
@@ -61,7 +61,7 @@ class Service: public RefCountable
 
 typedef Service::Pointer ServicePointer;
 
-typedef Vector<Adaptation::ServicePointer> Services;
+typedef std::vector<Adaptation::ServicePointer> Services;
 Services &AllServices();
 ServicePointer FindService(const Service::Id &key);
 
@@ -48,7 +48,7 @@ Adaptation::ServiceGroup::finalize()
         }
         s.cut(s.size() - 1);
         debugs(93, DBG_IMPORTANT, "Adaptation group '" << id << "' contains disabled member(s) after reconfiguration: " << s);
-        removedServices.clean();
+        removedServices.clear();
     }
 
     String baselineKey;
@@ -4,9 +4,10 @@
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
 #include "base/RefCount.h"
-#include "base/Vector.h"
 #include "SquidString.h"
 
+#include <vector>
+
 namespace Adaptation
 {
 
@@ -17,9 +18,9 @@ class ServiceGroup: public RefCountable
 public:
     typedef RefCount<ServiceGroup> Pointer;
 
-    typedef Vector<String> Store;
+    typedef std::vector<String> Store;
     typedef String Id;
-    typedef unsigned int Pos; // Vector<>::poistion_type
+    typedef unsigned int Pos; // vector<>::position_type
     friend class ServicePlan;
 
 public:
@@ -113,7 +114,7 @@ class DynamicServiceChain: public ServiceChain
 class ServicePlan
 {
 public:
-    typedef unsigned int Pos; // Vector<>::poistion_type
+    typedef unsigned int Pos; // vector<>::position_type
 
 public:
     ServicePlan();
@@ -141,7 +142,7 @@ std::ostream &operator <<(std::ostream &os, const ServicePlan &p)
     return p.print(os);
 }
 
-typedef Vector<ServiceGroupPointer> Groups;
+typedef std::vector<ServiceGroupPointer> Groups;
 Groups &AllGroups();
 ServiceGroupPointer FindGroup(const ServiceGroup::Id &id);
 
@@ -78,7 +78,7 @@ EssentialVersion(const SBuf &raw)
     // everything after the second period
     const SBuf::size_type minorPos = raw.find('.');
     const SBuf::size_type microPos = minorPos == SBuf::npos ?
-        SBuf::npos : raw.find('.', minorPos+1);
+                                     SBuf::npos : raw.find('.', minorPos+1);
     return raw.substr(0, microPos); // becomes raw if microPos is npos
 }
 
@@ -2,14 +2,14 @@
  * DEBUG: section 93    eCAP Interface
  */
 #include "squid.h"
-#include "Debug.h"
-#include "EventLoop.h"
 #include "adaptation/ecap/Config.h"
 #include "adaptation/ecap/Host.h"
 #include "adaptation/ecap/ServiceRep.h"
 #include "adaptation/ecap/XactionRep.h"
 #include "AsyncEngine.h"
 #include "base/TextException.h"
+#include "Debug.h"
+#include "EventLoop.h"
 
 #include <libecap/adapter/service.h>
 #include <libecap/common/options.h>
@@ -105,7 +105,7 @@ Adaptation::Ecap::Engine::checkEvents(int)
     // Start with the default I/O loop timeout, convert from milliseconds.
     static const struct timeval maxTimeout {
         EVENT_LOOP_TIMEOUT/1000, // seconds
-        (EVENT_LOOP_TIMEOUT % 1000)*1000 
+        (EVENT_LOOP_TIMEOUT % 1000)*1000
     }; // microseconds
     struct timeval timeout = maxTimeout;
 
@@ -33,7 +33,6 @@
 #include "squid.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
-#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -1262,7 +1262,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         reply_ = dynamic_cast<HttpReply*>(adapted.header);
     }
 
-    Adaptation::Icap::History::Pointer h = request_->icapHistory();
+    Adaptation::Icap::History::Pointer h = (request_ ? request_->icapHistory() : NULL);
     Must(h != NULL); // ICAPXaction::maybeLog calls only if there is a log
     al.icp.opcode = ICP_INVALID;
     al.url = h->log_uri.termedBuf();
@@ -125,7 +125,7 @@ void Adaptation::Icap::Options::configure(const HttpReply *reply)
 void Adaptation::Icap::Options::cfgMethod(ICAP::Method m)
 {
     Must(m != ICAP::methodNone);
-    methods += m;
+    methods.push_back(m);
 }
 
 // TODO: HttpHeader should provide a general method for this type of conversion
@@ -71,7 +71,7 @@ class Options
     const char *error; // human-readable information; set iff !valid()
 
     // ICAP server MUST supply this info
-    Vector<ICAP::Method> methods;
+    std::vector<ICAP::Method> methods;
     String istag;
 
     // ICAP server MAY supply this info. If not, Squid supplies defaults.
@@ -375,7 +375,8 @@ void Adaptation::Icap::ServiceRep::noteTimeToNotify()
     Pointer us = NULL;
 
     while (!theClients.empty()) {
-        Client i = theClients.pop_back();
+        Client i = theClients.back();
+        theClients.pop_back();
         ScheduleCallHere(i.callback);
         i.callback = 0;
     }
@@ -469,7 +470,7 @@ void Adaptation::Icap::ServiceRep::checkOptions()
     if (!theOptions->methods.empty()) {
         bool method_found = false;
         String method_list;
-        Vector <ICAP::Method>::iterator iter = theOptions->methods.begin();
+        std::vector <ICAP::Method>::iterator iter = theOptions->methods.begin();
 
         while (iter != theOptions->methods.end()) {
 
@@ -711,7 +712,7 @@ bool Adaptation::Icap::ServiceRep::detached() const
     return isDetached;
 }
 
-Adaptation::Icap::ConnWaiterDialer::ConnWaiterDialer(const CbcPointer<ModXact> &xact,
+Adaptation::Icap::ConnWaiterDialer::ConnWaiterDialer(const CbcPointer<Adaptation::Icap::ModXact> &xact,
         Adaptation::Icap::ConnWaiterDialer::Parent::Method aHandler):
         Parent(xact, aHandler)
 {
@@ -140,7 +140,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
         AsyncCall::Pointer callback;
     };
 
-    typedef Vector<Client> Clients;
+    typedef std::vector<Client> Clients;
     // TODO: rename to theUpWaiters
     Clients theClients; // all clients waiting for a call back
 
@@ -216,7 +216,7 @@ class ConnWaiterDialer: public NullaryMemFunT<ModXact>
 public:
     typedef NullaryMemFunT<ModXact> Parent;
     ServiceRep::Pointer theService;
-    ConnWaiterDialer(const CbcPointer<ModXact> &xact, Parent::Method aHandler);
+    ConnWaiterDialer(const CbcPointer<Adaptation::Icap::ModXact> &xact, Adaptation::Icap::ConnWaiterDialer::Parent::Method aHandler);
     ConnWaiterDialer(const Adaptation::Icap::ConnWaiterDialer &aConnWaiter);
     ~ConnWaiterDialer();
 };
@@ -10,7 +10,9 @@ libanyp_la_SOURCES = \
 	ProtocolType.cc \
 	ProtocolType.h \
 	ProtocolVersion.h \
-	TrafficMode.h
+	TrafficMode.h \
+	UriScheme.cc \
+	UriScheme.h
 
 ProtocolType.cc: ProtocolType.h $(top_srcdir)/src/mk-string-arrays.awk
 	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk <$(srcdir)/ProtocolType.h | sed -e 's%PROTO_%%' >$@) || ($(RM) -f $@ && exit 1)
@@ -0,0 +1,24 @@
+/*
+ * DEBUG: section 23    URL Scheme parsing
+ * AUTHOR: Robert Collins, Amos Jeffries
+ */
+#include "squid.h"
+#include "anyp/UriScheme.h"
+
+char const *
+AnyP::UriScheme::c_str() const
+{
+    if (theScheme_ == AnyP::PROTO_UNKNOWN)
+        return "(unknown)";
+
+    static char out[BUFSIZ];
+    int p = 0;
+
+    if (theScheme_ > AnyP::PROTO_NONE && theScheme_ < AnyP::PROTO_MAX) {
+        const char *in = AnyP::ProtocolType_str[theScheme_];
+        for (; p < (BUFSIZ-1) && in[p] != '\0'; ++p)
+            out[p] = xtolower(in[p]);
+    }
+    out[p] = '\0';
+    return out;
+}
@@ -0,0 +1,49 @@
+#ifndef SQUID_ANYP_URISCHEME_H
+#define SQUID_ANYP_URISCHEME_H
+
+#include "anyp/ProtocolType.h"
+#if HAVE_IOSFWD
+#include <iosfwd>
+#endif
+
+namespace AnyP
+{
+
+/** This class represents a URI Scheme such as http:// https://, wais://, urn: etc.
+ * It does not represent the PROTOCOL that such schemes refer to.
+ */
+class UriScheme
+{
+public:
+    UriScheme() : theScheme_(AnyP::PROTO_NONE) {}
+    UriScheme(AnyP::ProtocolType const aScheme) : theScheme_(aScheme) {}
+    ~UriScheme() {}
+
+    operator AnyP::ProtocolType() const { return theScheme_; }
+
+    bool operator != (AnyP::ProtocolType const & aProtocol) const { return theScheme_ != aProtocol; }
+
+    /** Get a char string representation of the scheme.
+     * Does not include the ':' or '://" terminators.
+     *
+     * An upper bound length of BUFSIZ bytes converted. Remainder will be truncated.
+     * The result of this call will remain usable only until any subsequest call
+     * and must be copied if persistence is needed.
+     */
+    char const *c_str() const;
+
+private:
+    /// This is a typecode pointer into the enum/registry of protocols handled.
+    AnyP::ProtocolType theScheme_;
+};
+
+} // namespace AnyP
+
+inline std::ostream &
+operator << (std::ostream &os, AnyP::UriScheme const &scheme)
+{
+    os << scheme.c_str();
+    return os;
+}
+
+#endif /* SQUID_ANYP_URISCHEME_H */
@@ -9,6 +9,8 @@ namespace AnyP
 class PortCfg;
 typedef CbcPointer<PortCfg> PortCfgPointer;
 
+class UriScheme;
+
 } // namespace AnyP
 
 #endif /* _SQUID_SRC_ANYP_FORWARD_H */
@@ -13,40 +13,44 @@
 #include "Parsing.h"
 #include "wordlist.h"
 
-ACLFlag
-ACLMaxUserIP::SupportedFlags[] = {ACL_F_STRICT, ACL_F_END};
+ACLFlag ACLMaxUserIP::SupportedFlags[] = {ACL_F_STRICT, ACL_F_END};
 
-ACL *
-ACLMaxUserIP::clone() const
-{
-    return new ACLMaxUserIP(*this);
-}
-
-ACLMaxUserIP::ACLMaxUserIP (char const *theClass) : ACL(SupportedFlags), class_ (theClass), maximum(0)
+ACLMaxUserIP::ACLMaxUserIP(char const *theClass) :
+        ACL(SupportedFlags),
+        class_(theClass),
+        maximum(0)
 {}
 
-ACLMaxUserIP::ACLMaxUserIP (ACLMaxUserIP const & old) : class_ (old.class_), maximum (old.maximum)
+ACLMaxUserIP::ACLMaxUserIP(ACLMaxUserIP const &old) :
+        class_(old.class_),
+        maximum(old.maximum)
 {
-   flags = old.flags;
+    flags = old.flags;
 }
 
 ACLMaxUserIP::~ACLMaxUserIP()
 {}
 
+ACL *
+ACLMaxUserIP::clone() const
+{
+    return new ACLMaxUserIP(*this);
+}
+
 char const *
 ACLMaxUserIP::typeString() const
 {
     return class_;
 }
 
 bool
-ACLMaxUserIP::empty () const
+ACLMaxUserIP::empty() const
 {
     return false;
 }
 
 bool
-ACLMaxUserIP::valid () const
+ACLMaxUserIP::valid() const
 {
     return maximum > 0;
 }
@@ -42,22 +42,21 @@
 /// \ingroup ACLAPI
 class ACLMaxUserIP : public ACL
 {
-
 public:
     MEMPROXY_CLASS(ACLMaxUserIP);
 
-    ACLMaxUserIP(char const *);
-    ACLMaxUserIP(ACLMaxUserIP const &);
+    ACLMaxUserIP(char const *theClass);
+    ACLMaxUserIP(ACLMaxUserIP const &old);
     ~ACLMaxUserIP();
-    ACLMaxUserIP&operator=(ACLMaxUserIP const &);
+    ACLMaxUserIP &operator =(ACLMaxUserIP const &);
 
-    virtual ACL *clone()const;
+    virtual ACL *clone() const;
     virtual char const *typeString() const;
     virtual void parse();
-    virtual int match(ACLChecklist *checklist);
+    virtual int match(ACLChecklist *cl);
     virtual wordlist *dump() const;
-    virtual bool empty () const;
-    virtual bool valid () const;
+    virtual bool empty() const;
+    virtual bool valid() const;
     virtual bool requiresRequest() const {return true;}
 
     int getMaximum() const {return maximum;}
@@ -67,9 +66,9 @@ class ACLMaxUserIP : public ACL
 private:
     static Prototype RegistryProtoype;
     static ACLMaxUserIP RegistryEntry_;
-    static ACLFlag  SupportedFlags[];
+    static ACLFlag SupportedFlags[];
 
-    int match(Auth::UserRequest::Pointer, Ip::Address const &);
+    int match(Auth::UserRequest::Pointer auth_user_request, Ip::Address const &src_addr);
     char const *class_;
     int maximum;
 };
@@ -49,13 +49,13 @@ ACLProxyAuth::~ACLProxyAuth()
     delete data;
 }
 
-ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) : data (newData), type_(theType) {}
+ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) : data(newData), type_(theType) {}
 
-ACLProxyAuth::ACLProxyAuth (ACLProxyAuth const &old) : data (old.data->clone()), type_(old.type_)
+ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) : data(old.data->clone()), type_(old.type_)
 {}
 
 ACLProxyAuth &
-ACLProxyAuth::operator= (ACLProxyAuth const &rhs)
+ACLProxyAuth::operator=(ACLProxyAuth const &rhs)
 {
     data = rhs.data->clone();
     type_ = rhs.type_;
@@ -106,13 +106,13 @@ ACLProxyAuth::dump() const
 }
 
 bool
-ACLProxyAuth::empty () const
+ACLProxyAuth::empty() const
 {
     return data->empty();
 }
 
 bool
-ACLProxyAuth::valid () const
+ACLProxyAuth::valid() const
 {
     if (authenticateSchemeCount() == 0) {
         debugs(28, DBG_CRITICAL, "Can't use proxy auth because no authentication schemes were compiled.");
@@ -43,7 +43,7 @@ class ProxyAuthLookup : public ACLChecklist::AsyncState
 
 public:
     static ProxyAuthLookup *Instance();
-    virtual void checkForAsync(ACLChecklist *)const;
+    virtual void checkForAsync(ACLChecklist *) const;
 
 private:
     static ProxyAuthLookup instance_;
@@ -52,23 +52,22 @@ class ProxyAuthLookup : public ACLChecklist::AsyncState
 
 class ACLProxyAuth : public ACL
 {
-
 public:
     MEMPROXY_CLASS(ACLProxyAuth);
 
     ~ACLProxyAuth();
     ACLProxyAuth(ACLData<char const *> *, char const *);
-    ACLProxyAuth (ACLProxyAuth const &);
-    ACLProxyAuth &operator= (ACLProxyAuth const &);
+    ACLProxyAuth(ACLProxyAuth const &);
+    ACLProxyAuth &operator =(ACLProxyAuth const &);
 
     virtual char const *typeString() const;
     virtual void parse();
     virtual bool isProxyAuth() const {return true;}
 
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
-    virtual bool valid () const;
-    virtual bool empty () const;
+    virtual bool valid() const;
+    virtual bool empty() const;
     virtual bool requiresRequest() const {return true;}
 
     virtual ACL *clone() const;
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "auth/Config.h"
+#include "auth/Gadgets.h"
 #include "auth/UserRequest.h"
 #include "cache_cf.h"
 #include "ConfigParser.h"
@@ -105,10 +106,10 @@ Auth::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
             delete keyExtras;
 
         keyExtras = nlf;
-        
+
         if (char *t = strtok(NULL, w_space)) {
-               debugs(29, DBG_CRITICAL, "FATAL: Unexpected argument '" << t << "' after request_format specification");
-               self_destruct();
+            debugs(29, DBG_CRITICAL, "FATAL: Unexpected argument '" << t << "' after request_format specification");
+            self_destruct();
         }
     } else {
         debugs(29, DBG_CRITICAL, "Unrecognised " << scheme->type() << " auth scheme parameter '" << param_str << "'");
@@ -126,6 +127,25 @@ void
 Auth::Config::done()
 {
     delete keyExtras;
-    keyExtras = NULL; 
+    keyExtras = NULL;
     keyExtrasLine.clean();
 }
+
+Auth::User::Pointer
+Auth::Config::findUserInCache(const char *nameKey, Auth::Type authType)
+{
+    AuthUserHashPointer *usernamehash;
+    debugs(29, 9, "Looking for user '" << nameKey << "'");
+
+    if (nameKey && (usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, nameKey)))) {
+        while (usernamehash) {
+            if ((usernamehash->user()->auth_type == authType) &&
+                    !strcmp(nameKey, (char const *)usernamehash->key))
+                return usernamehash->user();
+
+            usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
+        }
+    }
+
+    return NULL;
+}
@@ -46,7 +46,7 @@ class wordlist;
 
 namespace Format
 {
-    class Format;
+class Format;
 }
 
 namespace Auth
@@ -128,6 +128,9 @@ class Config
     /** add headers as needed when challenging for auth */
     virtual void fixHeader(UserRequest::Pointer, HttpReply *, http_hdr_type, HttpRequest *) = 0;
 
+    /// Find any existing user credentials in the authentication cache by name and type.
+    virtual Auth::User::Pointer findUserInCache(const char *nameKey, Auth::Type type);
+
     /** prepare to handle requests */
     virtual void init(Config *) = 0;
 
@@ -147,7 +150,7 @@ class Config
     Format::Format *keyExtras; ///< The compiled request format
 };
 
-typedef Vector<Config *> ConfigVector;
+typedef std::vector<Config *> ConfigVector;
 
 extern ConfigVector TheConfig;
 
@@ -133,7 +133,7 @@ authenticateReset(void)
     authenticateRotate();
 
     /* free current global config details too. */
-    Auth::TheConfig.clean();
+    Auth::TheConfig.clear();
 }
 
 AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user):
@@ -37,7 +37,7 @@
 #include "auth/Scheme.h"
 #include "globals.h"
 
-Vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
+std::vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
 
 void
 Auth::Scheme::AddScheme(Auth::Scheme::Pointer instance)
@@ -63,11 +63,11 @@ Auth::Scheme::Find(const char *typestr)
     return Auth::Scheme::Pointer(NULL);
 }
 
-Vector<Auth::Scheme::Pointer> &
+std::vector<Auth::Scheme::Pointer> &
 Auth::Scheme::GetSchemes()
 {
     if (!_Schemes)
-        _Schemes = new Vector<Auth::Scheme::Pointer>;
+        _Schemes = new std::vector<Auth::Scheme::Pointer>;
 
     return *_Schemes;
 }
@@ -34,7 +34,8 @@
 #if USE_AUTH
 
 #include "base/RefCount.h"
-#include "base/Vector.h"
+
+#include <vector>
 
 /**
  \defgroup AuthSchemeAPI	Authentication Scheme API
@@ -60,8 +61,8 @@ class Scheme : public RefCountable
 {
 public:
     typedef RefCount<Scheme> Pointer;
-    typedef Vector<Scheme::Pointer>::iterator iterator;
-    typedef Vector<Scheme::Pointer>::const_iterator const_iterator;
+    typedef std::vector<Scheme::Pointer>::iterator iterator;
+    typedef std::vector<Scheme::Pointer>::const_iterator const_iterator;
 
 public:
     Scheme() : initialised (false) {};
@@ -93,13 +94,13 @@ class Scheme : public RefCountable
     Scheme(Scheme const &);
     Scheme &operator=(Scheme const&);
 
-    static Vector<Scheme::Pointer> &GetSchemes();
+    static std::vector<Scheme::Pointer> &GetSchemes();
 
 protected:
     bool initialised;
 
 private:
-    static Vector<Scheme::Pointer> *_Schemes;
+    static std::vector<Scheme::Pointer> *_Schemes;
 };
 
 } // namespace Auth
@@ -41,9 +41,9 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "comm/Connection.h"
+#include "format/Format.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-#include "format/Format.h"
 #include "MemBuf.h"
 
 /* Generic Functions */
@@ -6,10 +6,10 @@
 #include "auth/State.h"
 #include "charset.h"
 #include "Debug.h"
+#include "format/Format.h"
 #include "HelperReply.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
-#include "format/Format.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
 #include "SquidTime.h"
@@ -197,25 +197,6 @@ authenticateBasicStats(StoreEntry * sentry)
     helperStats(sentry, basicauthenticators, "Basic Authenticator Statistics");
 }
 
-static Auth::User::Pointer
-authBasicAuthUserFindUsername(const char *userkey)
-{
-    AuthUserHashPointer *usernamehash;
-    debugs(29, 9, "Looking for user '" << userkey << "'");
-
-    if (userkey && (usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, userkey)))) {
-        while (usernamehash) {
-            if ((usernamehash->user()->auth_type == Auth::AUTH_BASIC) &&
-                    !strcmp(userkey, (char const *)usernamehash->key))
-                return usernamehash->user();
-
-            usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
-        }
-    }
-
-    return NULL;
-}
-
 char *
 Auth::Basic::Config::decodeCleartext(const char *httpAuthHeader)
 {
@@ -289,7 +270,6 @@ Auth::Basic::Config::decode(char const *proxy_auth, const char *aRequestRealm)
         Tolower(cleartext);
     local_basic->username(cleartext);
 
-
     if (local_basic->passwd == NULL) {
         debugs(29, 4, HERE << "no password in proxy authorization header '" << proxy_auth << "'");
         auth_user_request->setDenyMessage("no password was present in the HTTP [proxy-]authorization header. This is most likely a browser bug");
@@ -312,7 +292,7 @@ Auth::Basic::Config::decode(char const *proxy_auth, const char *aRequestRealm)
     /* now lookup and see if we have a matching auth_user structure in memory. */
     Auth::User::Pointer auth_user;
 
-    if ((auth_user = authBasicAuthUserFindUsername(lb->userKey())) == NULL) {
+    if ((auth_user = findUserInCache(lb->userKey(), Auth::AUTH_BASIC)) == NULL) {
         /* the user doesn't exist in the username cache yet */
         /* save the credentials */
         debugs(29, 9, HERE << "Creating new user '" << lb->username() << "'");
@@ -5,10 +5,10 @@
 #include "auth/digest/UserRequest.h"
 #include "auth/State.h"
 #include "charset.h"
+#include "format/Format.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-#include "format/Format.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
@@ -194,7 +194,7 @@ authenticateDigestNonceNew(void)
     /* the cache's link */
     authDigestNonceLink(newnonce);
     newnonce->flags.incache = true;
-    debugs(29, 5, "authenticateDigestNonceNew: created nonce " << newnonce << " at " << newnonce->noncedata.creationtime);
+    debugs(29, 5, "created nonce " << newnonce << " at " << newnonce->noncedata.creationtime);
     return newnonce;
 }
 
@@ -240,7 +240,7 @@ authenticateDigestNonceShutdown(void)
     digest_nonce_h *nonce;
 
     if (digest_nonce_cache) {
-        debugs(29, 2, "authenticateDigestNonceShutdown: Shutting down nonce cache ");
+        debugs(29, 2, "Shutting down nonce cache");
         hash_first(digest_nonce_cache);
 
         while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
@@ -256,7 +256,7 @@ authenticateDigestNonceShutdown(void)
     }
 
 #endif
-    debugs(29, 2, "authenticateDigestNonceShutdown: Nonce cache shutdown");
+    debugs(29, 2, "Nonce cache shutdown");
 }
 
 static void
@@ -269,16 +269,16 @@ authenticateDigestNonceCacheCleanup(void *data)
      * first.
      */
     digest_nonce_h *nonce;
-    debugs(29, 3, "authenticateDigestNonceCacheCleanup: Cleaning the nonce cache now");
-    debugs(29, 3, "authenticateDigestNonceCacheCleanup: Current time: " << current_time.tv_sec);
+    debugs(29, 3, "Cleaning the nonce cache now");
+    debugs(29, 3, "Current time: " << current_time.tv_sec);
     hash_first(digest_nonce_cache);
 
     while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {
-        debugs(29, 3, "authenticateDigestNonceCacheCleanup: nonce entry  : " << nonce << " '" << (char *) nonce->key << "'");
-        debugs(29, 4, "authenticateDigestNonceCacheCleanup: Creation time: " << nonce->noncedata.creationtime);
+        debugs(29, 3, "nonce entry  : " << nonce << " '" << (char *) nonce->key << "'");
+        debugs(29, 4, "Creation time: " << nonce->noncedata.creationtime);
 
         if (authDigestNonceIsStale(nonce)) {
-            debugs(29, 4, "authenticateDigestNonceCacheCleanup: Removing nonce " << (char *) nonce->key << " from cache due to timeout.");
+            debugs(29, 4, "Removing nonce " << (char *) nonce->key << " from cache due to timeout.");
             assert(nonce->flags.incache);
             /* invalidate nonce so future requests fail */
             nonce->flags.valid = false;
@@ -288,7 +288,7 @@ authenticateDigestNonceCacheCleanup(void *data)
         }
     }
 
-    debugs(29, 3, "authenticateDigestNonceCacheCleanup: Finished cleaning the nonce cache.");
+    debugs(29, 3, "Finished cleaning the nonce cache.");
 
     if (static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->active())
         eventAdd("Digest none cache maintenance", authenticateDigestNonceCacheCleanup, NULL, static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->nonceGCInterval, 1);
@@ -299,7 +299,7 @@ authDigestNonceLink(digest_nonce_h * nonce)
 {
     assert(nonce != NULL);
     ++nonce->references;
-    debugs(29, 9, "authDigestNonceLink: nonce '" << nonce << "' now at '" << nonce->references << "'.");
+    debugs(29, 9, "nonce '" << nonce << "' now at '" << nonce->references << "'.");
 }
 
 #if NOT_USED
@@ -322,10 +322,10 @@ authDigestNonceUnlink(digest_nonce_h * nonce)
     if (nonce->references > 0) {
         -- nonce->references;
     } else {
-        debugs(29, DBG_IMPORTANT, "authDigestNonceUnlink; Attempt to lower nonce " << nonce << " refcount below 0!");
+        debugs(29, DBG_IMPORTANT, "Attempt to lower nonce " << nonce << " refcount below 0!");
     }
 
-    debugs(29, 9, "authDigestNonceUnlink: nonce '" << nonce << "' now at '" << nonce->references << "'.");
+    debugs(29, 9, "nonce '" << nonce << "' now at '" << nonce->references << "'.");
 
     if (nonce->references == 0)
         authenticateDigestNonceDelete(nonce);
@@ -348,14 +348,14 @@ authenticateDigestNonceFindNonce(const char *nonceb64)
     if (nonceb64 == NULL)
         return NULL;
 
-    debugs(29, 9, "authDigestNonceFindNonce:looking for nonceb64 '" << nonceb64 << "' in the nonce cache.");
+    debugs(29, 9, "looking for nonceb64 '" << nonceb64 << "' in the nonce cache.");
 
     nonce = static_cast < digest_nonce_h * >(hash_lookup(digest_nonce_cache, nonceb64));
 
     if ((nonce == NULL) || (strcmp(authenticateDigestNonceNonceb64(nonce), nonceb64)))
         return NULL;
 
-    debugs(29, 9, "authDigestNonceFindNonce: Found nonce '" << nonce << "'");
+    debugs(29, 9, "Found nonce '" << nonce << "'");
 
     return nonce;
 }
@@ -373,7 +373,7 @@ authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
 
     /* has it already been invalidated ? */
     if (!nonce->flags.valid) {
-        debugs(29, 4, "authDigestNonceIsValid: Nonce already invalidated");
+        debugs(29, 4, "Nonce already invalidated");
         return 0;
     }
 
@@ -385,7 +385,7 @@ authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
 
     if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->NonceStrictness && intnc != nonce->nc + 1) ||
             intnc < nonce->nc + 1) {
-        debugs(29, 4, "authDigestNonceIsValid: Nonce count doesn't match");
+        debugs(29, 4, "Nonce count doesn't match");
         nonce->flags.valid = false;
         return 0;
     }
@@ -409,7 +409,7 @@ authDigestNonceIsStale(digest_nonce_h * nonce)
 
     /* has it's max duration expired? */
     if (nonce->noncedata.creationtime + static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxduration < current_time.tv_sec) {
-        debugs(29, 4, "authDigestNonceIsStale: Nonce is too old. " <<
+        debugs(29, 4, "Nonce is too old. " <<
                nonce->noncedata.creationtime << " " <<
                static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxduration << " " <<
                current_time.tv_sec);
@@ -419,13 +419,13 @@ authDigestNonceIsStale(digest_nonce_h * nonce)
     }
 
     if (nonce->nc > 99999998) {
-        debugs(29, 4, "authDigestNonceIsStale: Nonce count overflow");
+        debugs(29, 4, "Nonce count overflow");
         nonce->flags.valid = false;
         return -1;
     }
 
     if (nonce->nc > static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxuses) {
-        debugs(29, 4, "authDigestNoncelastRequest: Nonce count over user limit");
+        debugs(29, 4, "Nonce count over user limit");
         nonce->flags.valid = false;
         return -1;
     }
@@ -445,12 +445,12 @@ authDigestNonceLastRequest(digest_nonce_h * nonce)
         return -1;
 
     if (nonce->nc == 99999997) {
-        debugs(29, 4, "authDigestNoncelastRequest: Nonce count about to overflow");
+        debugs(29, 4, "Nonce count about to overflow");
         return -1;
     }
 
     if (nonce->nc >= static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxuses - 1) {
-        debugs(29, 4, "authDigestNoncelastRequest: Nonce count about to hit user limit");
+        debugs(29, 4, "Nonce count about to hit user limit");
         return -1;
     }
 
@@ -475,25 +475,6 @@ authDigestNoncePurge(digest_nonce_h * nonce)
     authDigestNonceUnlink(nonce);
 }
 
-/* USER related functions */
-static Auth::User::Pointer
-authDigestUserFindUsername(const char *userkey)
-{
-    AuthUserHashPointer *usernamehash;
-    debugs(29, 9, "Looking for user '" << userkey << "'");
-
-    if ((usernamehash = static_cast < AuthUserHashPointer * >(hash_lookup(proxy_auth_username_cache, userkey)))) {
-        while ((usernamehash->user()->auth_type != Auth::AUTH_DIGEST) && (usernamehash->next))
-            usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
-
-        if (usernamehash->user()->auth_type == Auth::AUTH_DIGEST) {
-            return usernamehash->user();
-        }
-    }
-
-    return NULL;
-}
-
 void
 Auth::Digest::Config::rotateHelpers()
 {
@@ -509,7 +490,7 @@ void
 Auth::Digest::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme)
 {
     wordlist *list = authenticateProgram;
-    debugs(29, 9, "authDigestCfgDump: Dumping configuration");
+    debugs(29, 9, "Dumping configuration");
     storeAppendPrintf(entry, "%s %s", name, "digest");
 
     while (list != NULL) {
@@ -562,7 +543,7 @@ Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Ht
     /* on a 407 or 401 we always use a new nonce */
     digest_nonce_h *nonce = authenticateDigestNonceNew();
 
-    debugs(29, 9, HERE << "Sending type:" << hdrType <<
+    debugs(29, 9, "Sending type:" << hdrType <<
            " header: 'Digest realm=\"" << digestAuthRealm << "\", nonce=\"" <<
            authenticateDigestNonceNonceb64(nonce) << "\", qop=\"" << QOP_AUTH <<
            "\", stale=" << (stale ? "true" : "false"));
@@ -730,7 +711,7 @@ authDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce)
 {
     dlink_node *node;
 
-    if (!user || !nonce)
+    if (!user || !nonce || !nonce->user)
         return;
 
     Auth::Digest::User *digest_user = user;
@@ -790,7 +771,7 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
     digest_nonce_h *nonce;
     int ilen;
 
-    debugs(29, 9, "authenticateDigestDecodeAuth: beginning");
+    debugs(29, 9, "beginning");
 
     Auth::Digest::UserRequest *digest_request = new Auth::Digest::UserRequest();
 
@@ -841,14 +822,14 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
                 }
             } else if (*p == '"') {
                 if (!httpHeaderParseQuotedString(p, vlen, &value)) {
-                    debugs(29, 9, HERE << "Failed to parse attribute '" << item << "' in '" << temp << "'");
+                    debugs(29, 9, "Failed to parse attribute '" << item << "' in '" << temp << "'");
                     continue;
                 }
             } else {
                 value.limitInit(p, vlen);
             }
         } else {
-            debugs(29, 9, HERE << "Failed to parse attribute '" << item << "' in '" << temp << "'");
+            debugs(29, 9, "Failed to parse attribute '" << item << "' in '" << temp << "'");
             continue;
         }
 
@@ -860,68 +841,68 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
             safe_free(username);
             if (value.size() != 0)
                 username = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found Username '" << username << "'");
+            debugs(29, 9, "Found Username '" << username << "'");
             break;
 
         case DIGEST_REALM:
             safe_free(digest_request->realm);
             if (value.size() != 0)
                 digest_request->realm = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found realm '" << digest_request->realm << "'");
+            debugs(29, 9, "Found realm '" << digest_request->realm << "'");
             break;
 
         case DIGEST_QOP:
             safe_free(digest_request->qop);
             if (value.size() != 0)
                 digest_request->qop = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found qop '" << digest_request->qop << "'");
+            debugs(29, 9, "Found qop '" << digest_request->qop << "'");
             break;
 
         case DIGEST_ALGORITHM:
             safe_free(digest_request->algorithm);
             if (value.size() != 0)
                 digest_request->algorithm = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found algorithm '" << digest_request->algorithm << "'");
+            debugs(29, 9, "Found algorithm '" << digest_request->algorithm << "'");
             break;
 
         case DIGEST_URI:
             safe_free(digest_request->uri);
             if (value.size() != 0)
                 digest_request->uri = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found uri '" << digest_request->uri << "'");
+            debugs(29, 9, "Found uri '" << digest_request->uri << "'");
             break;
 
         case DIGEST_NONCE:
             safe_free(digest_request->nonceb64);
             if (value.size() != 0)
                 digest_request->nonceb64 = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found nonce '" << digest_request->nonceb64 << "'");
+            debugs(29, 9, "Found nonce '" << digest_request->nonceb64 << "'");
             break;
 
         case DIGEST_NC:
             if (value.size() != 8) {
-                debugs(29, 9, HERE << "Invalid nc '" << value << "' in '" << temp << "'");
+                debugs(29, 9, "Invalid nc '" << value << "' in '" << temp << "'");
             }
             xstrncpy(digest_request->nc, value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found noncecount '" << digest_request->nc << "'");
+            debugs(29, 9, "Found noncecount '" << digest_request->nc << "'");
             break;
 
         case DIGEST_CNONCE:
             safe_free(digest_request->cnonce);
             if (value.size() != 0)
                 digest_request->cnonce = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found cnonce '" << digest_request->cnonce << "'");
+            debugs(29, 9, "Found cnonce '" << digest_request->cnonce << "'");
             break;
 
         case DIGEST_RESPONSE:
             safe_free(digest_request->response);
             if (value.size() != 0)
                 digest_request->response = xstrndup(value.rawBuf(), value.size() + 1);
-            debugs(29, 9, HERE << "Found response '" << digest_request->response << "'");
+            debugs(29, 9, "Found response '" << digest_request->response << "'");
             break;
 
         default:
-            debugs(29, 3, HERE << "Unknown attribute '" << item << "' in '" << temp << "'");
+            debugs(29, 3, "Unknown attribute '" << item << "' in '" << temp << "'");
             break;
         }
     }
@@ -1078,9 +1059,9 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
     Auth::User::Pointer auth_user;
 
     SBuf key = Auth::User::BuildUserKey(username, aRequestRealm);
-    if (key.isEmpty() || (auth_user = authDigestUserFindUsername(key.c_str())) == NULL) {
+    if (key.isEmpty() || (auth_user = findUserInCache(key.c_str(), Auth::AUTH_DIGEST)) == NULL) {
         /* the user doesn't exist in the username cache yet */
-        debugs(29, 9, HERE << "Creating new digest user '" << username << "'");
+        debugs(29, 9, "Creating new digest user '" << username << "'");
         digest_user = new Auth::Digest::User(this, aRequestRealm);
         /* auth_user is a parent */
         auth_user = digest_user;
@@ -1100,7 +1081,7 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
          */
         authDigestUserLinkNonce(digest_user, nonce);
     } else {
-        debugs(29, 9, HERE << "Found user '" << username << "' in the user cache as '" << auth_user << "'");
+        debugs(29, 9, "Found user '" << username << "' in the user cache as '" << auth_user << "'");
         digest_user = static_cast<Auth::Digest::User *>(auth_user.getRaw());
         digest_user->credentials(Auth::Unchecked);
         xfree(username);
@@ -1110,7 +1091,7 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
     assert(digest_request != NULL);
 
     digest_request->user(digest_user);
-    debugs(29, 9, HERE << "username = '" << digest_user->username() << "'\nrealm = '" <<
+    debugs(29, 9, "username = '" << digest_user->username() << "'\nrealm = '" <<
            digest_request->realm << "'\nqop = '" << digest_request->qop <<
            "'\nalgorithm = '" << digest_request->algorithm << "'\nuri = '" <<
            digest_request->uri << "'\nnonce = '" << digest_request->nonceb64 <<
@@ -5,12 +5,12 @@
 #include "auth/State.h"
 #include "auth/User.h"
 #include "client_side.h"
+#include "format/Format.h"
 #include "globals.h"
 #include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-#include "format/Format.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
@@ -5,10 +5,10 @@
 #include "auth/State.h"
 #include "cbdata.h"
 #include "client_side.h"
+#include "format/Format.h"
 #include "globals.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
-#include "format/Format.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
 
@@ -41,16 +41,18 @@ CharacterSet::addRange(unsigned char low, unsigned char high)
     return *this;
 }
 
-CharacterSet::CharacterSet(const char *label, const char * const c)
-: name(label == NULL ? "anonymous" : label), chars_(Storage(256,0))
+CharacterSet::CharacterSet(const char *label, const char * const c) :
+        name(label == NULL ? "anonymous" : label),
+        chars_(Storage(256,0))
 {
     const size_t clen = strlen(c);
     for (size_t i = 0; i < clen; ++i)
         add(c[i]);
 }
 
-CharacterSet::CharacterSet(const char *label, unsigned char low, unsigned char high)
-: name(label == NULL ? "anonymous" : label), chars_(Storage(256,0))
+CharacterSet::CharacterSet(const char *label, unsigned char low, unsigned char high) :
+        name(label == NULL ? "anonymous" : label),
+        chars_(Storage(256,0))
 {
     addRange(low,high);
 }
@@ -76,7 +76,7 @@ class CharacterSet
      *  constructor. This assumption is relied upon in operator[], add,
      *  operator+=
      */
-   Storage chars_;
+    Storage chars_;
 };
 
 #endif /* _SQUID_SRC_PARSER_CHARACTERSET_H */
@@ -23,9 +23,7 @@ libbase_la_SOURCES = \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
-	TextException.h \
-	Vector.cc \
-	Vector.h
+	TextException.h
 
 EXTRA_PROGRAMS = \
 	testCharacterSet
@@ -1,48 +0,0 @@
-/*
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-/*
- * Array is an array of (void*) items with unlimited capacity
- *
- * Array grows when arrayAppend() is called and no space is left
- * Currently, array does not have an interface for deleting an item because
- *     we do not need such an interface yet.
- */
-
-#include "squid.h"
-#include "base/Vector.h"
-
-#if HAVE_ASSERT_H
-#include <assert.h>
-#endif
-#if HAVE_STRING_H
-#include <string.h>
-#endif
@@ -1,448 +0,0 @@
-/*
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-#ifndef SQUID_ARRAY_H
-#define SQUID_ARRAY_H
-
-/**
- \todo CLEANUP: this file should be called Vector.h at least, and probably be replaced by STL Vector<C>
- */
-
-#include "fatal.h"
-#include "util.h"
-
-/* users of this template also need assert() */
-#include "compat/assert.h"
-
-/* iterator support */
-
-template <class C>
-class VectorIteratorBase
-{
-
-public:
-    VectorIteratorBase();
-    VectorIteratorBase(C &);
-    VectorIteratorBase(size_t, C &);
-    VectorIteratorBase & operator =(VectorIteratorBase const &);
-    bool operator != (VectorIteratorBase const &rhs) const;
-    bool operator == (VectorIteratorBase const &rhs) const;
-    VectorIteratorBase & operator ++();
-    VectorIteratorBase operator ++(int);
-    typename C::value_type & operator *() const {
-        return theVector->items[pos];
-    }
-
-    typename C::value_type * operator -> () const {
-        return &theVector->items[pos];
-    }
-
-    ssize_t operator - (VectorIteratorBase const &rhs) const;
-    bool incrementable() const;
-
-private:
-    size_t pos;
-    C * theVector;
-};
-
-template<class E>
-class Vector
-{
-
-public:
-    typedef E value_type;
-    typedef E* pointer;
-    typedef VectorIteratorBase<Vector<E> > iterator;
-    typedef VectorIteratorBase<Vector<E> const> const_iterator;
-
-    void *operator new (size_t);
-    void operator delete (void *);
-
-    Vector();
-    ~Vector();
-    Vector(Vector const &);
-    Vector &operator = (Vector const &);
-    void clean();
-    void reserve (size_t capacity);
-    void push_back (E);
-    Vector &operator += (E item) {push_back(item); return *this;};
-
-    void insert (E);
-    const E &front() const;
-    E &front();
-    E &back();
-    E pop_back();
-    E shift();         // aka pop_front
-    void prune(E);
-    void preAppend(int app_count);
-    bool empty() const;
-    size_t size() const;
-    iterator begin();
-    const_iterator begin () const;
-    iterator end();
-    const_iterator end () const;
-    E& operator [] (unsigned i);
-    const E& operator [] (unsigned i) const;
-
-    /* Do not change these, until the entry C struct is removed */
-    size_t capacity;
-    size_t count;
-    E *items;
-};
-
-template<class E>
-void *
-Vector<E>::operator new(size_t size)
-{
-    return xmalloc(size);
-}
-
-template<class E>
-void
-Vector<E>::operator delete (void *address)
-{
-    xfree (address);
-}
-
-template<class E>
-Vector<E>::Vector() : capacity (0), count(0), items (NULL)
-{}
-
-template<class E>
-Vector<E>::~Vector()
-{
-    clean();
-}
-
-template<class E>
-void
-Vector<E>::clean()
-{
-    /* could also warn if some objects are left */
-    delete[] items;
-    items = NULL;
-    capacity = 0;
-    count = 0;
-}
-
-/* grows internal buffer to satisfy required minimal capacity */
-template<class E>
-void
-Vector<E>::reserve(size_t min_capacity)
-{
-    const int min_delta = 16;
-    int delta;
-
-    if (capacity >= min_capacity)
-        return;
-
-    delta = min_capacity;
-
-    /* make delta a multiple of min_delta */
-    delta += min_delta - 1;
-
-    delta /= min_delta;
-
-    delta *= min_delta;
-
-    /* actual grow */
-    if (delta < 0)
-        delta = min_capacity - capacity;
-
-    E*newitems = new E[capacity + delta];
-
-    for (size_t counter = 0; counter < size(); ++counter) {
-        newitems[counter] = items[counter];
-    }
-
-    capacity += delta;
-    delete[]items;
-    items = newitems;
-}
-
-template<class E>
-void
-Vector<E>::push_back(E obj)
-{
-    if (size() >= capacity)
-        reserve (size() + 1);
-
-    items[count++] = obj;
-}
-
-template<class E>
-void
-Vector<E>::insert(E obj)
-{
-    if (size() >= capacity)
-        reserve (size() + 1);
-
-    int i;
-
-    for (i = count; i > 0; i--)
-        items[i] = items[i - 1];
-
-    items[i] = obj;
-
-    count += 1;
-}
-
-template<class E>
-E
-Vector<E>::shift()
-{
-    assert (size());
-    value_type result = items[0];
-
-    for (unsigned int i = 1; i < count; i++)
-        items[i-1] = items[i];
-
-    count--;
-
-    /*reset the last (unused) element...*/
-    items[count] = value_type();
-
-    return result;
-}
-
-template<class E>
-E
-Vector<E>::pop_back()
-{
-    assert (size());
-    value_type result = items[--count];
-    items[count] = value_type();
-    return result;
-}
-
-template<class E>
-E &
-Vector<E>::back()
-{
-    assert (size());
-    return items[size() - 1];
-}
-
-template<class E>
-const E &
-Vector<E>::front() const
-{
-    assert (size());
-    return items[0];
-}
-
-template<class E>
-E &
-Vector<E>::front()
-{
-    assert (size());
-    return items[0];
-}
-
-template<class E>
-void
-Vector<E>::prune(E item)
-{
-    unsigned int n = 0;
-    for (unsigned int i = 0; i < count; i++) {
-        if (items[i] != item) {
-            if (i != n)
-                items[n] = items[i];
-            n++;
-        }
-    }
-
-    count = n;
-}
-
-/* if you are going to append a known and large number of items, call this first */
-template<class E>
-void
-Vector<E>::preAppend(int app_count)
-{
-    if (size() + app_count > capacity)
-        reserve(size() + app_count);
-}
-
-template<class E>
-Vector<E>::Vector (Vector<E> const &rhs)
-{
-    items = NULL;
-    capacity = 0;
-    count = 0;
-    reserve (rhs.size());
-
-    for (size_t counter = 0; counter < rhs.size(); ++counter)
-        push_back (rhs.items[counter]);
-}
-
-template<class E>
-Vector<E> &
-Vector<E>::operator = (Vector<E> const &old)
-{
-    clean();
-    reserve (old.size());
-
-    for (size_t counter = 0; counter < old.size(); ++counter)
-        push_back (old.items[counter]);
-
-    return *this;
-}
-
-template<class E>
-bool
-Vector<E>::empty() const
-{
-    return size() == 0;
-}
-
-template<class E>
-size_t
-Vector<E>::size() const
-{
-    return count;
-}
-
-template<class E>
-typename Vector<E>::iterator
-Vector<E>::begin()
-{
-    return iterator (0, *this);
-}
-
-template<class E>
-typename Vector<E>::iterator
-Vector<E>::end()
-{
-    return iterator(size(), *this);
-}
-
-template<class E>
-typename Vector<E>::const_iterator
-Vector<E>::begin() const
-{
-    return const_iterator (0, *this);
-}
-
-template<class E>
-typename Vector<E>::const_iterator
-Vector<E>::end() const
-{
-    return const_iterator(size(), *this);
-}
-
-template<class E>
-E &
-Vector<E>::operator [] (unsigned i)
-{
-    assert (size() > i);
-    return items[i];
-}
-
-template<class E>
-const E &
-Vector<E>::operator [] (unsigned i) const
-{
-    assert (size() > i);
-    return items[i];
-}
-
-template<class C>
-VectorIteratorBase<C>::VectorIteratorBase() : pos(0), theVector(NULL)
-{}
-
-template<class C>
-VectorIteratorBase<C>::VectorIteratorBase(C &container) : pos(container.begin()), theVector(&container)
-{}
-
-template<class C>
-VectorIteratorBase<C>::VectorIteratorBase(size_t aPos, C &container) : pos(aPos), theVector(&container) {}
-
-template<class C>
-bool VectorIteratorBase<C>:: operator != (VectorIteratorBase<C> const &rhs) const
-{
-    assert (theVector);
-    return pos != rhs.pos;
-}
-
-template<class C>
-bool VectorIteratorBase<C>:: operator == (VectorIteratorBase<C> const &rhs) const
-{
-    assert (theVector);
-    return pos == rhs.pos;
-}
-
-template<class C>
-bool
-VectorIteratorBase<C>::incrementable() const
-{
-    assert (theVector);
-    return pos != theVector->size();
-}
-
-template<class C>
-VectorIteratorBase<C> & VectorIteratorBase<C>:: operator ++()
-{
-    assert (theVector);
-
-    if (!incrementable())
-        fatal ("domain error");
-
-    ++pos;
-
-    return *this;
-}
-
-template<class C>
-VectorIteratorBase<C> VectorIteratorBase<C>:: operator ++(int)
-{
-    VectorIteratorBase result(*this);
-    ++*this;
-    return result;
-}
-
-template<class C>
-VectorIteratorBase<C>&
-VectorIteratorBase<C>::operator =(VectorIteratorBase<C> const &old)
-{
-    pos = old.pos;
-    theVector = old.theVector;
-    return *this;
-}
-
-template<class C>
-ssize_t
-VectorIteratorBase<C>::operator - (VectorIteratorBase<C> const &rhs) const
-{
-    assert(theVector == rhs.theVector);
-    return pos - rhs.pos;
-}
-
-#endif /* SQUID_ARRAY_H */
@@ -40,6 +40,7 @@
 #include "acl/MethodData.h"
 #include "acl/Tree.h"
 #include "anyp/PortCfg.h"
+#include "anyp/UriScheme.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
 #include "cache_cf.h"
@@ -77,7 +78,6 @@
 #include "StoreFileSystem.h"
 #include "SwapDir.h"
 #include "tools.h"
-#include "URLScheme.h"
 #include "wordlist.h"
 /* wccp2 has its own conditional definitions */
 #include "wccp2.h"
@@ -249,7 +249,7 @@ static void free_sslproxy_ssl_bump(acl_access **ssl_bump);
 static void parse_b_size_t(size_t * var);
 static void parse_b_int64_t(int64_t * var);
 
-static bool parseNamedIntList(const char *data, const String &name, Vector<int> &list);
+static bool parseNamedIntList(const char *data, const String &name, std::vector<int> &list);
 
 static void parse_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap);
 static void dump_CpuAffinityMap(StoreEntry *const entry, const char *const name, const CpuAffinityMap *const cpuAffinityMap);
@@ -378,6 +378,7 @@ SubstituteMacro(char*& line, int& len, const char* macroName, const char* substS
 static void
 ProcessMacros(char*& line, int& len)
 {
+    SubstituteMacro(line, len, "${service_name}", service_name);
     SubstituteMacro(line, len, "${process_name}", TheKidName);
     SubstituteMacro(line, len, "${process_number}", xitoa(KidIdentifier));
 }
@@ -488,7 +489,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
 
     config_lineno = 0;
 
-    Vector<bool> if_states;
+    std::vector<bool> if_states;
     while (fgets(config_input_line, BUFSIZ, fp)) {
         ++config_lineno;
 
@@ -1869,12 +1870,7 @@ static void
 free_authparam(Auth::ConfigVector * cfg)
 {
     /* Wipe the Auth globals and Detach/Destruct component config + state. */
-    cfg->clean();
-
-    /* remove our pointers to the probably-dead sub-configs */
-    while (cfg->size()) {
-        cfg->pop_back();
-    }
+    cfg->clear();
 
     /* on reconfigure initialize new auth schemes for the new config. */
     if (reconfiguring) {
@@ -1895,7 +1891,7 @@ static int
 find_fstype(char *type)
 {
     for (size_t i = 0; i < StoreFileSystem::FileSystems().size(); ++i)
-        if (strcasecmp(type, StoreFileSystem::FileSystems().items[i]->type()) == 0)
+        if (strcasecmp(type, StoreFileSystem::FileSystems().at(i)->type()) == 0)
             return (int)i;
 
     return (-1);
@@ -1938,7 +1934,7 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
             sd = dynamic_cast<SwapDir *>(swap->swapDirs[i].getRaw());
 
-            if (strcmp(sd->type(), StoreFileSystem::FileSystems().items[fs]->type()) != 0) {
+            if (strcmp(sd->type(), StoreFileSystem::FileSystems().at(fs)->type()) != 0) {
                 debugs(3, DBG_CRITICAL, "ERROR: Can't change type of existing cache_dir " <<
                        sd->type() << " " << sd->path << " to " << type_str << ". Restart required");
                 return;
@@ -1963,7 +1959,7 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
     allocate_new_swapdir(swap);
 
-    swap->swapDirs[swap->n_configured] = StoreFileSystem::FileSystems().items[fs]->createSwapDir();
+    swap->swapDirs[swap->n_configured] = StoreFileSystem::FileSystems().at(fs)->createSwapDir();
 
     sd = dynamic_cast<SwapDir *>(swap->swapDirs[swap->n_configured].getRaw());
 
@@ -3511,7 +3507,7 @@ parsePortSpecification(AnyP::PortCfg * s, char *token)
     s->name = xstrdup(token);
     s->connection_auth_disabled = false;
 
-    const char *portType = URLScheme(s->transport.protocol).const_str();
+    const char *portType = AnyP::UriScheme(s->transport.protocol).c_str();
 
     if (*token == '[') {
         /* [ipv6]:port */
@@ -3830,7 +3826,7 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
         // clone the port options from *s to *(s->next)
         s->next = cbdataReference(s->clone());
         s->next->s.setIPv4();
-        debugs(3, 3, URLScheme(s->transport.protocol) << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
+        debugs(3, 3, AnyP::UriScheme(s->transport.protocol).c_str() << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
 
     while (*head)
@@ -3871,7 +3867,7 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 
         // TODO: compare against prefix of 'n' instead of assuming http_port
         if (s->transport.protocol != AnyP::PROTO_HTTP)
-            storeAppendPrintf(e, " protocol=%s", URLScheme(s->transport.protocol).const_str());
+            storeAppendPrintf(e, " protocol=%s", AnyP::UriScheme(s->transport.protocol).c_str());
 
         if (s->allow_direct)
             storeAppendPrintf(e, " allow-direct");
@@ -4264,7 +4260,7 @@ free_access_log(CustomLog ** definitions)
 
 /// parses list of integers form name=N1,N2,N3,...
 static bool
-parseNamedIntList(const char *data, const String &name, Vector<int> &list)
+parseNamedIntList(const char *data, const String &name, std::vector<int> &list)
 {
     if (data && (strncmp(data, name.rawBuf(), name.size()) == 0)) {
         data += name.size();
@@ -4297,7 +4293,7 @@ parse_CpuAffinityMap(CpuAffinityMap **const cpuAffinityMap)
 
     const char *const pToken = ConfigParser::NextToken();
     const char *const cToken = ConfigParser::NextToken();
-    Vector<int> processes, cores;
+    std::vector<int> processes, cores;
     if (!parseNamedIntList(pToken, "process_numbers", processes)) {
         debugs(3, DBG_CRITICAL, "FATAL: bad 'process_numbers' parameter " <<
                "in 'cpu_affinity_map'");
@@ -4497,10 +4493,10 @@ static void parse_sslproxy_cert_adapt(sslproxy_cert_adapt **cert_adapt)
 
     if (strcmp(al, Ssl::CertAdaptAlgorithmStr[Ssl::algSetValidAfter]) == 0) {
         ca->alg = Ssl::algSetValidAfter;
-        ca->param = strdup("on");
+        ca->param = xstrdup("on");
     } else if (strcmp(al, Ssl::CertAdaptAlgorithmStr[Ssl::algSetValidBefore]) == 0) {
         ca->alg = Ssl::algSetValidBefore;
-        ca->param = strdup("on");
+        ca->param = xstrdup("on");
     } else if (strcmp(al, Ssl::CertAdaptAlgorithmStr[Ssl::algSetCommonName]) == 0) {
         ca->alg = Ssl::algSetCommonName;
         if (param) {
@@ -4509,7 +4505,7 @@ static void parse_sslproxy_cert_adapt(sslproxy_cert_adapt **cert_adapt)
                 self_destruct();
                 return;
             }
-            ca->param = strdup(param);
+            ca->param = xstrdup(param);
         }
     } else {
         debugs(3, DBG_CRITICAL, "FATAL: sslproxy_cert_adapt: unknown cert adaptation algorithm: " << al);
@@ -40,7 +40,6 @@
 #include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
-#include "URLScheme.h"
 
 #if HAVE_MATH_H
 #include <math.h>
@@ -195,8 +194,8 @@ carpSelectParent(HttpRequest * request)
             //   corner cases should use the canonical URL
             if (tp->options.carp_key.scheme) {
                 // temporary, until bug 1961 URL handling is fixed.
-                const URLScheme sch = request->protocol;
-                key.append(sch.const_str());
+                const AnyP::UriScheme sch(request->protocol);
+                key.append(sch.c_str());
                 if (key.size()) //if the scheme is not empty
                     key.append("://");
             }
@@ -50,14 +50,15 @@
 #include "cbdata.h"
 #include "mgr/Registration.h"
 #include "Store.h"
-#if USE_CBDATA_DEBUG
-#include "Stack.h"
-#endif
 #include "Generic.h"
 
 #if HAVE_LIMITS_H
 #include <limits.h>
 #endif
+#if USE_CBDATA_DEBUG
+#include <vector>
+#include <algorithm>
+#endif
 
 #if WITH_VALGRIND
 #define HASHED_CBDATA 1
@@ -124,7 +125,7 @@ class cbdata
     dlink_node link;
     const char *file;
     int line;
-    Stack<CBDataCall*> calls;
+    std::vector<CBDataCall*> calls; // used as a stack with random access operator
 #endif
 
     /* cookie used while debugging */
@@ -209,10 +210,11 @@ cbdata_hash(const void *p, unsigned int mod)
 cbdata::~cbdata()
 {
 #if USE_CBDATA_DEBUG
-    CBDataCall *aCall;
 
-    while ((aCall = calls.pop()))
-        delete aCall;
+    while (!calls.empty()) {
+        delete calls.back();
+        calls.pop_back();
+    }
 
 #endif
 
@@ -316,7 +318,7 @@ cbdataInternalAlloc(cbdata_type type)
 
     c->file = file;
     c->line = line;
-    c->calls = Stack<CBDataCall *> ();
+    c->calls = std::vector<CBDataCall *> ();
     c->addHistory("Alloc", file, line);
     dlinkAdd(c, &c->link, &cbdataEntries);
     debugs(45, 3, "cbdataAlloc: " << p << " " << file << ":" << line);
@@ -614,8 +616,8 @@ CBDATA_CLASS_INIT(generic_cbdata);
 struct CBDataCallDumper : public unary_function<CBDataCall, void> {
     CBDataCallDumper (StoreEntry *anEntry):where(anEntry) {}
 
-    void operator()(CBDataCall const &x) {
-        storeAppendPrintf(where, "%s\t%s\t%d\n", x.label, x.file, x.line);
+    void operator()(CBDataCall * const &x) {
+        storeAppendPrintf(where, "%s\t%s\t%d\n", x->label, x->file, x->line);
     }
 
     StoreEntry *where;
@@ -628,7 +630,7 @@ struct CBDataHistoryDumper : public CBDataDumper {
         CBDataDumper::operator()(x);
         storeAppendPrintf(where, "\n");
         storeAppendPrintf(where, "Action\tFile\tLine\n");
-        for_each (x.calls,callDumper);
+        std::for_each (x.calls.begin(), x.calls.end(), callDumper);
         storeAppendPrintf(where, "\n");
     }
 
@@ -114,7 +114,11 @@ COMMENT_START
 
 	${process_number} expands to the current Squid process
 	identifier, which is an integer number (e.g., 1, 2, 3) unique
-	across all Squid processes.
+	across all Squid processes of the current service instance.
+
+	${service_name} expands into the current Squid service instance
+	name identifier which is provided by -n on the command line.
+
 COMMENT_END
 
 # options still not yet ported from 2.7 to 3.x
@@ -330,6 +334,16 @@ DOC_START
 	sent before the required macro information is available to Squid.
 	By default, Squid uses request formats provided in scheme-specific
 	examples below (search for %credentials).
+	The expanded key_extras value is added to the Squid credentials
+	cache and, hence, will affect authentication. It can be used to
+	autenticate different users with identical user names (e.g., when user
+	authentication depends on http_port).
+	Avoid adding frequently changing information to key_extras. For
+	example, if you add user source IP, and it changes frequently
+	in your environment, then max_user_ip ACL is going to treat every
+	user+IP combination as a unique "user", breaking the ACL and
+	wasting a lot of memory on those user records. It will also force
+	users to authenticate from scratch whenever their IP changes.
 
 	=== Parameters for the basic scheme follow. ===
 
@@ -2376,6 +2390,24 @@ DOC_START
 	server certificates while proxying https:// URLs
 DOC_END
 
+NAME: sslproxy_session_ttl
+IFDEF: USE_SSL
+DEFAULT: 300
+LOC: Config.SSL.session_ttl
+TYPE: int
+DOC_START
+	Sets the timeout value for SSL sessions
+DOC_END
+
+NAME: sslproxy_session_cache_size
+IFDEF: USE_SSL
+DEFAULT: 2 MB
+LOC: Config.SSL.sessionCacheSize
+TYPE: b_size_t
+DOC_START
+        Sets the cache size to use for ssl session
+DOC_END
+
 NAME: ssl_bump
 IFDEF: USE_SSL
 TYPE: sslproxy_ssl_bump
@@ -31,6 +31,7 @@
  */
 
 #include "squid.h"
+#include "base/RunnersRegistry.h"
 #include "client_db.h"
 #include "ClientInfo.h"
 #include "event.h"
@@ -112,22 +113,28 @@ clientdbAdd(const Ip::Address &addr)
 }
 
 static void
-clientdbRegisterWithCacheManager(void)
-{
-    Mgr::RegisterAction("client_list", "Cache Client List", clientdbDump, 0, 1);
-}
-
-void
 clientdbInit(void)
 {
-    clientdbRegisterWithCacheManager();
-
     if (client_table)
         return;
 
     client_table = hash_create((HASHCMP *) strcmp, CLIENT_DB_HASH_SIZE, hash_string);
 }
 
+class ClientDbRr: public RegisteredRunner
+{
+public:
+    virtual void run(const RunnerRegistry &);
+};
+RunnerRegistrationEntry(rrAfterConfig, ClientDbRr);
+
+void
+ClientDbRr::run(const RunnerRegistry &r)
+{
+    clientdbInit();
+    Mgr::RegisterAction("client_list", "Cache Client List", clientdbDump, 0, 1);
+}
+
 #if USE_DELAY_POOLS
 /* returns ClientInfo for given IP addr
    Returns NULL if no such client (or clientdb turned off)
@@ -46,7 +46,6 @@ class Address;
 class StoreEntry;
 class ClientInfo;
 
-void clientdbInit(void);
 void clientdbUpdate(const Ip::Address &, LogTags, AnyP::ProtocolType, size_t);
 int clientdbCutoffDenied(const Ip::Address &);
 void clientdbDump(StoreEntry *);
@@ -1362,7 +1362,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         bool replyMatchRequest = rep->content_range != NULL ?
                                  request->range->contains(rep->content_range->spec) :
                                  true;
-        const int spec_count = http->request->range->specs.count;
+        const int spec_count = http->request->range->specs.size();
         int64_t actual_clen = -1;
 
         debugs(33, 3, "clientBuildRangeHeader: range spec count: " <<
@@ -1714,7 +1714,7 @@ ClientSocketContext::canPackMoreRanges() const
     if (!http->range_iter.debt()) {
         debugs(33, 5, HERE << "At end of current range spec for " << clientConnection);
 
-        if (http->range_iter.pos.incrementable())
+        if (http->range_iter.pos != http->range_iter.end)
             ++http->range_iter.pos;
 
         http->range_iter.updateSpec();
@@ -1783,6 +1783,9 @@ ClientSocketContext::pullData()
     clientStreamRead(getTail(), http, readBuffer);
 }
 
+/** Adapt stream status to account for Range cases
+ *
+ */
 clientStream_status_t
 ClientSocketContext::socketState()
 {
@@ -1799,11 +1802,8 @@ ClientSocketContext::socketState()
             if (!canPackMoreRanges()) {
                 debugs(33, 5, HERE << "Range request at end of returnable " <<
                        "range sequence on " << clientConnection);
-
-                if (http->request->flags.proxyKeepalive)
-                    return STREAM_COMPLETE;
-                else
-                    return STREAM_UNPLANNED_COMPLETE;
+                // we got everything we wanted from the store
+                return STREAM_COMPLETE;
             }
         } else if (reply && reply->content_range) {
             /* reply has content-range, but Squid is not managing ranges */
@@ -1816,24 +1816,11 @@ ClientSocketContext::socketState()
 
             // did we get at least what we expected, based on range specs?
 
-            if (bytesSent == bytesExpected) { // got everything
-                if (http->request->flags.proxyKeepalive)
-                    return STREAM_COMPLETE;
-                else
-                    return STREAM_UNPLANNED_COMPLETE;
-            }
-
-            // The logic below is not clear: If we got more than we
-            // expected why would persistency matter? Should not this
-            // always be an error?
-            if (bytesSent > bytesExpected) { // got extra
-                if (http->request->flags.proxyKeepalive)
-                    return STREAM_COMPLETE;
-                else
-                    return STREAM_UNPLANNED_COMPLETE;
-            }
+            if (bytesSent == bytesExpected) // got everything
+                return STREAM_COMPLETE;
 
-            // did not get enough yet, expecting more
+            if (bytesSent > bytesExpected) // Error: Sent more than expected
+                return STREAM_UNPLANNED_COMPLETE;
         }
 
         return STREAM_NONE;
@@ -1940,8 +1927,11 @@ ClientSocketContext::writeComplete(const Comm::ConnectionPointer &conn, char *bu
         break;
 
     case STREAM_COMPLETE:
-        debugs(33, 5, HERE << conn << " Keeping Alive");
-        keepaliveNextRequest();
+        debugs(33, 5, conn << "Stream complete, keepalive is " << http->request->flags.proxyKeepalive);
+        if (http->request->flags.proxyKeepalive)
+            keepaliveNextRequest();
+        else
+            initiateClose("STREAM_COMPLETE NOKEEPALIVE");
         return;
 
     case STREAM_UNPLANNED_COMPLETE:
@@ -2133,7 +2123,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, Http1::Requ
                      strlen(host);
         http->uri = (char *)xcalloc(url_sz, 1);
         const char *protocol = switchedToHttps ?
-                               "https" : URLScheme(conn->port->transport.protocol).const_str();
+                               "https" : AnyP::UriScheme(conn->port->transport.protocol).c_str();
         snprintf(http->uri, url_sz, "%s://%s%s", protocol, host, url);
         debugs(33, 5, "ACCEL VHOST REWRITE: '" << http->uri << "'");
     } else if (conn->port->defaultsite /* && !vhost */) {
@@ -2147,7 +2137,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, Http1::Requ
             snprintf(vportStr, sizeof(vportStr),":%d",vport);
         }
         snprintf(http->uri, url_sz, "%s://%s%s%s",
-                 URLScheme(conn->port->transport.protocol).const_str(), conn->port->defaultsite, vportStr, url);
+                 AnyP::UriScheme(conn->port->transport.protocol).c_str(), conn->port->defaultsite, vportStr, url);
         debugs(33, 5, "ACCEL DEFAULTSITE REWRITE: '" << http->uri <<"'");
     } else if (vport > 0 /* && (!vhost || no Host:) */) {
         debugs(33, 5, "ACCEL VPORT REWRITE: http_port IP + vport=" << vport);
@@ -2156,7 +2146,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, Http1::Requ
         http->uri = (char *)xcalloc(url_sz, 1);
         http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
-                 URLScheme(conn->port->transport.protocol).const_str(),
+                 AnyP::UriScheme(conn->port->transport.protocol).c_str(),
                  ipbuf, vport, url);
         debugs(33, 5, "ACCEL VPORT REWRITE: '" << http->uri << "'");
     }
@@ -2177,15 +2167,15 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, Http1::Requ
         const int url_sz = hp.requestUri().length() + 32 + Config.appendDomainLen +
                      strlen(host);
         http->uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http->uri, url_sz, "%s://%s%s", URLScheme(conn->port->transport.protocol).const_str(), host, SBuf(hp.requestUri()).c_str());
+        snprintf(http->uri, url_sz, "%s://%s%s", AnyP::UriScheme(conn->port->transport.protocol).c_str(), host, SBuf(hp.requestUri()).c_str());
         debugs(33, 5, "TRANSPARENT HOST REWRITE: '" << http->uri <<"'");
     } else {
         /* Put the local socket IP address as the hostname.  */
         const int url_sz = hp.requestUri().length() + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
         http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
-                 URLScheme(http->getConn()->port->transport.protocol).const_str(),
+                 AnyP::UriScheme(http->getConn()->port->transport.protocol).c_str(),
                  ipbuf, http->getConn()->clientConnection->local.port(), SBuf(hp.requestUri()).c_str());
         debugs(33, 5, "TRANSPARENT REWRITE: '" << http->uri << "'");
     }
@@ -3980,7 +3970,7 @@ clientHttpConnectionsOpen(void)
 
 #if USE_SSL
         if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
-            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << URLScheme(s->transport.protocol) << "_port " << s->s);
+            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << AnyP::UriScheme(s->transport.protocol) << "_port " << s->s);
             s->flags.tunnelSslBumping = false;
         }
 
@@ -4037,7 +4027,7 @@ clientHttpsConnectionsOpen(void)
 
         // TODO: merge with similar code in clientHttpConnectionsOpen()
         if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
-            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << URLScheme(s->transport.protocol) << "_port " << s->s);
+            debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << AnyP::UriScheme(s->transport.protocol) << "_port " << s->s);
             s->flags.tunnelSslBumping = false;
         }
 
@@ -853,11 +853,12 @@ ClientHttpRequest::noteAdaptationAclCheckDone(Adaptation::ServiceGroupPointer g)
 #if ICAP_CLIENT
     Adaptation::Icap::History::Pointer ih = request->icapHistory();
     if (ih != NULL) {
-        if (getConn() != NULL) {
+        if (getConn() != NULL && getConn()->clientConnection != NULL) {
             ih->rfc931 = getConn()->clientConnection->rfc931;
 #if USE_SSL
-            assert(getConn()->clientConnection != NULL);
-            ih->ssluser = sslGetUserEmail(fd_table[getConn()->clientConnection->fd].ssl);
+            if (getConn()->clientConnection->isOpen()) {
+                ih->ssluser = sslGetUserEmail(fd_table[getConn()->clientConnection->fd].ssl);
+            }
 #endif
         }
         ih->log_uri = log_uri;
@@ -1139,6 +1140,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
              */
             node->readBuffer.offset = request->range->lowestOffset(0);
             http->range_iter.pos = request->range->begin();
+            http->range_iter.end = request->range->end();
             http->range_iter.valid = true;
         }
     }
@@ -1927,7 +1927,7 @@ DeferredReadManager::~DeferredReadManager()
 
 /* explicit instantiation required for some systems */
 
-/// \cond AUTODOCS-IGNORE
+/// \cond AUTODOCS_IGNORE
 template cbdata_type CbDataList<DeferredRead>::CBDATA_CbDataList;
 /// \endcond
 
@@ -47,7 +47,8 @@ Comm::AcceptLimiter::kick()
     debugs(5, 5, "size=" << deferred_.size());
     while (deferred_.size() > 0 && fdNFree() >= RESERVED_FD) {
         /* NP: shift() is equivalent to pop_front(). Giving us a FIFO queue. */
-        TcpAcceptor::Pointer temp = deferred_.shift();
+        TcpAcceptor::Pointer temp = deferred_.front();
+        deferred_.erase(deferred_.begin());
         if (temp.valid()) {
             debugs(5, 5, "doing one.");
             -- temp->isLimited;
@@ -1,9 +1,10 @@
 #ifndef _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 #define _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 
-#include "base/Vector.h"
 #include "comm/TcpAcceptor.h"
 
+#include <vector>
+
 namespace Comm
 {
 
@@ -24,7 +25,7 @@ namespace Comm
  * or to NULL an entry while scanning the list for empty spaces.
  * Side effect: TcpAcceptor->kick() becomes allowed to pull off multiple accept()'s in bunches
  *
- * 2) re-implement as a list instead of vector?
+ * 2) re-implement as a std::queue instead of std::vector
  * storing head/tail pointers for fast push/pop and avoiding the whole shift() overhead
  */
 class AcceptLimiter
@@ -47,7 +48,7 @@ class AcceptLimiter
     static AcceptLimiter Instance_;
 
     /** FIFO queue */
-    Vector<TcpAcceptor::Pointer> deferred_;
+    std::vector<TcpAcceptor::Pointer> deferred_;
 };
 
 }; // namepace Comm
@@ -2,7 +2,8 @@
 #define _SQUID_COMM_FORWARD_H
 
 #include "base/RefCount.h"
-#include "base/Vector.h"
+
+#include <vector>
 
 namespace Comm
 {
@@ -11,7 +12,7 @@ class Connection;
 
 typedef RefCount<Comm::Connection> ConnectionPointer;
 
-typedef Vector<Comm::ConnectionPointer> ConnectionList;
+typedef std::vector<Comm::ConnectionPointer> ConnectionList;
 
 bool IsConnOpen(const Comm::ConnectionPointer &conn);
 
@@ -247,7 +247,6 @@
 #define _WIN_SQUID_SERVICE_CONTROL_RECONFIGURE	129
 #define _WIN_SQUID_SERVICE_CONTROL_DEBUG	130
 #define _WIN_SQUID_SERVICE_CONTROL_INTERRUPT 	131
-#define _WIN_SQUID_DEFAULT_SERVICE_NAME		"Squid"
 #define _WIN_SQUID_SERVICE_OPTION		"--ntservice"
 #define _WIN_SQUID_RUN_MODE_INTERACTIVE		0
 #define _WIN_SQUID_RUN_MODE_SERVICE		1
@@ -42,7 +42,6 @@
 #include "squid.h"
 
 #if USE_DELAY_POOLS
-#include "base/Vector.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
 #include "CommonPool.h"
@@ -592,7 +591,7 @@ DelayPools::Update(void *unused)
 
     LastUpdate = squid_curtime;
 
-    Vector<Updateable *>::iterator pos = toUpdate.begin();
+    std::vector<Updateable *>::iterator pos = toUpdate.begin();
 
     while (pos != toUpdate.end()) {
         (*pos)->update(incr);
@@ -610,15 +609,15 @@ DelayPools::registerForUpdates(Updateable *anObject)
 void
 DelayPools::deregisterForUpdates (Updateable *anObject)
 {
-    Vector<Updateable *>::iterator pos = toUpdate.begin();
+    std::vector<Updateable *>::iterator pos = toUpdate.begin();
 
     while (pos != toUpdate.end() && *pos != anObject) {
         ++pos;
     }
 
     if (pos != toUpdate.end()) {
         /* move all objects down one */
-        Vector<Updateable *>::iterator temp = pos;
+        std::vector<Updateable *>::iterator temp = pos;
         ++pos;
 
         while (pos != toUpdate.end()) {
@@ -631,7 +630,7 @@ DelayPools::deregisterForUpdates (Updateable *anObject)
     }
 }
 
-Vector<Updateable *> DelayPools::toUpdate;
+std::vector<Updateable *> DelayPools::toUpdate;
 
 void
 DelayPools::Stats(StoreEntry * sentry)
@@ -1500,6 +1500,12 @@ idnsReadVCHeader(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
 
     vc->msglen = ntohs(vc->msglen);
 
+    if (!vc->msglen) {
+        if (Comm::IsConnOpen(conn))
+            conn->close();
+        return;
+    }
+
     vc->msg->init(vc->msglen, vc->msglen);
     AsyncCall::Pointer call = commCbCall(5,4, "idnsReadVC",
                                          CommIoCbPtrFun(idnsReadVC, vc));
@@ -49,8 +49,6 @@
 #include "Store.h"
 #include "tools.h"
 #include "URL.h"
-#include "URL.h"
-#include "URLScheme.h"
 #include "wordlist.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -121,7 +119,7 @@ error_hard_text[] = {
 };
 
 /// \ingroup ErrorPageInternal
-static Vector<ErrorDynamicPageInfo *> ErrorDynamicPages;
+static std::vector<ErrorDynamicPageInfo *> ErrorDynamicPages;
 
 /* local prototypes */
 
@@ -206,7 +204,7 @@ errorInitialize(void)
             /** \par
              * Index any unknown file names used by deny_info.
              */
-            ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
+            ErrorDynamicPageInfo *info = ErrorDynamicPages.at(i - ERR_MAX);
             assert(info && info->id == i && info->page_name);
 
             const char *pg = info->page_name;
@@ -247,8 +245,10 @@ errorClean(void)
         safe_free(error_text);
     }
 
-    while (ErrorDynamicPages.size())
-        errorDynamicPageInfoDestroy(ErrorDynamicPages.pop_back());
+    while (!ErrorDynamicPages.empty()) {
+        errorDynamicPageInfoDestroy(ErrorDynamicPages.back());
+        ErrorDynamicPages.pop_back();
+    }
 
     error_page_count = 0;
 
@@ -533,7 +533,7 @@ errorPageId(const char *page_name)
     }
 
     for (size_t j = 0; j < ErrorDynamicPages.size(); ++j) {
-        if (strcmp(ErrorDynamicPages.items[j]->page_name, page_name) == 0)
+        if (strcmp(ErrorDynamicPages[j]->page_name, page_name) == 0)
             return j + ERR_MAX;
     }
 
@@ -563,7 +563,7 @@ errorPageName(int pageId)
         return err_type_str[pageId];
 
     if (pageId >= ERR_MAX && pageId - ERR_MAX < (ssize_t)ErrorDynamicPages.size())
-        return ErrorDynamicPages.items[pageId - ERR_MAX]->page_name;
+        return ErrorDynamicPages[pageId - ERR_MAX]->page_name;
 
     return "ERR_UNKNOWN";	/* should not happen */
 }
@@ -595,8 +595,8 @@ ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
 {
     memset(&ftp, 0, sizeof(ftp));
 
-    if (page_id >= ERR_MAX && ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect != Http::scNone)
-        httpStatus = ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect;
+    if (page_id >= ERR_MAX && ErrorDynamicPages[page_id - ERR_MAX]->page_redirect != Http::scNone)
+        httpStatus = ErrorDynamicPages[page_id - ERR_MAX]->page_redirect;
 
     if (req != NULL) {
         request = req;
@@ -1166,7 +1166,7 @@ ErrorState::BuildHttpReply()
                 status = Http::scTemporaryRedirect;
         }
 
-        rep->setHeaders(status, NULL, "text/html", 0, 0, -1);
+        rep->setHeaders(status, NULL, "text/html;charset=utf-8", 0, 0, -1);
 
         if (request) {
             MemBuf redirect_location;
@@ -1178,7 +1178,7 @@ ErrorState::BuildHttpReply()
         httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s", httpStatus, "Access Denied");
     } else {
         MemBuf *content = BuildContent();
-        rep->setHeaders(httpStatus, NULL, "text/html", content->contentSize(), 0, -1);
+        rep->setHeaders(httpStatus, NULL, "text/html;charset=utf-8", content->contentSize(), 0, -1);
         /*
          * include some information for downstream caches. Implicit
          * replaceable content. This isn't quite sufficient. xerrno is not
@@ -1303,6 +1303,8 @@ MemBuf *ErrorState::ConvertText(const char *text, bool allowRecursion)
     if (*m)
         content->Printf("%s", m);	/* copy tail */
 
+    content->terminate();
+
     assert((size_t)content->contentSize() == strlen(content->content()));
 
     return content;
@@ -108,7 +108,7 @@ void
 ESIContext::setErrorMessage(char const *anError)
 {
     if (!errormessage)
-        errormessage = xstrdup (anError);
+        errormessage = xstrdup(anError);
 }
 
 #endif /* USE_SQUID_ESI == 1 */
@@ -32,12 +32,14 @@
  */
 
 #include "squid.h"
-#include "base/Vector.h"
 #include "Debug.h"
 #include "esi/CustomParser.h"
+#include "fatal.h"
 #include "libTrie/Trie.h"
 #include "libTrie/TrieCharTransform.h"
 
+#include <vector>
+
 Trie *ESICustomParser::SearchTrie=NULL;
 
 EsiParserDefinition(ESICustomParser);
@@ -147,7 +149,7 @@ ESICustomParser::parse(char const *dataToParse, size_t const lengthOfData, bool
 
             *tagEnd = '\0';
 
-            Vector<char *>attributes;
+            std::vector<char *>attributes;
 
             char *attribute = const_cast<char *>(endofName + 1);
 
@@ -205,7 +207,8 @@ ESICustomParser::parse(char const *dataToParse, size_t const lengthOfData, bool
                 attribute = end + 1;
             }
 
-            theClient->start (tag + 1, (const char **)attributes.items, attributes.size() >> 1);
+            // TODO: after c++11, replace &attributes.front() with attributes.data()
+            theClient->start (tag + 1, const_cast<const char **>(&attributes.front()), attributes.size() >> 1);
             /* TODO: attributes */
 
             if (*(tagEnd - 1) == '/')
@@ -295,10 +295,10 @@ ESIInclude::ESIInclude(ESIInclude const &old) :
     flags.onerrorcontinue = old.flags.onerrorcontinue;
 
     if (old.srcurl)
-        srcurl = xstrdup (old.srcurl);
+        srcurl = xstrdup(old.srcurl);
 
     if (old.alturl)
-        alturl = xstrdup (old.alturl);
+        alturl = xstrdup(old.alturl);
 }
 
 void
@@ -353,7 +353,7 @@ ESIInclude::ESIInclude(esiTreeParentPtr aParent, int attrcount, char const **att
             assert (src.getRaw() == NULL);
             src = ESIStreamContextNew (this);
             assert (src.getRaw() != NULL);
-            srcurl = xstrdup ( attr[i+1]);
+            srcurl = xstrdup(attr[i+1]);
         } else if (!strcmp(attr[i],"alt")) {
             /* Start a secondary request for thisNode url */
             /* TODO: make a config parameter to wait on requesting alt's
@@ -364,7 +364,7 @@ ESIInclude::ESIInclude(esiTreeParentPtr aParent, int attrcount, char const **att
             assert (alt.getRaw() == NULL); /* TODO: FIXME */
             alt = ESIStreamContextNew (this);
             assert (alt.getRaw() != NULL);
-            alturl = xstrdup (attr[i+1]);
+            alturl = xstrdup(attr[i+1]);
         } else if (!strcmp(attr[i],"onerror")) {
             if (!strcmp(attr[i+1], "continue")) {
                 flags.onerrorcontinue = 1;
@@ -167,8 +167,10 @@ ESIVarState::~ESIVarState()
 {
     freeResources();
 
-    while (variablesForCleanup.size())
-        delete variablesForCleanup.pop_back();
+    while (!variablesForCleanup.empty()) {
+        delete variablesForCleanup.back();
+        variablesForCleanup.pop_back();
+    }
 
     delete defaultVariable;
 }
@@ -202,14 +204,14 @@ ESIVariableUserAgent::getProductVersion (char const *s)
 {
     char const *t;
     int len;
-    t = index (s,'/');
+    t = index(s,'/');
 
     if (!t || !*(++t))
-        return xstrdup ("");
+        return xstrdup("");
 
-    len = strcspn (t, " \r\n()<>@,;:\\\"/[]?={}");
+    len = strcspn(t, " \r\n()<>@,;:\\\"/[]?={}");
 
-    return xstrndup (t, len + 1);
+    return xstrndup(t, len + 1);
 }
 
 ESIVariableQuery::ESIVariableQuery(char const *uri) : query (NULL), query_sz (0), query_elements (0), query_string (NULL)
@@ -219,11 +221,11 @@ ESIVariableQuery::ESIVariableQuery(char const *uri) : query (NULL), query_sz (0)
 
     if (query_start && query_start[1] != '\0' ) {
         unsigned int n;
-        query_string = xstrdup (query_start + 1);
+        query_string = xstrdup(query_start + 1);
         query_elements = 1;
         char const *query_pos = query_start + 1;
 
-        while ((query_pos = strchr (query_pos, '&'))) {
+        while ((query_pos = strchr(query_pos, '&'))) {
             ++query_elements;
             ++query_pos;
         }
@@ -234,8 +236,8 @@ ESIVariableQuery::ESIVariableQuery(char const *uri) : query (NULL), query_sz (0)
         n = 0;
 
         while (query_pos) {
-            char const *next = strchr (query_pos, '&');
-            char const *div = strchr (query_pos, '=');
+            char const *next = strchr(query_pos, '&');
+            char const *div = strchr(query_pos, '=');
 
             if (next)
                 ++next;
@@ -249,19 +251,19 @@ ESIVariableQuery::ESIVariableQuery(char const *uri) : query (NULL), query_sz (0)
                 /* zero length between & and = or & and & */
                 continue;
 
-            query[n].var = xstrndup (query_pos, div - query_pos + 1) ;
+            query[n].var = xstrndup(query_pos, div - query_pos + 1) ;
 
             if (div == next) {
-                query[n].val = xstrdup ("");
+                query[n].val = xstrdup("");
             } else {
-                query[n].val = xstrndup (div + 1, next - div - 1);
+                query[n].val = xstrndup(div + 1, next - div - 1);
             }
 
             query_pos = next;
             ++n;
         }
     } else {
-        query_string = xstrdup ("");
+        query_string = xstrdup("");
     }
 
     if (query) {
@@ -383,14 +385,14 @@ ESIVariableUserAgent::ESIVariableUserAgent(ESIVarState &state)
             t = index (t, ' ');
 
             if (!t)
-                browserversion = xstrdup ("");
+                browserversion = xstrdup("");
             else {
-                t1 = index (t, ';');
+                t1 = index(t, ';');
 
                 if (!t1)
-                    browserversion = xstrdup (t + 1);
+                    browserversion = xstrdup(t + 1);
                 else
-                    browserversion = xstrndup (t + 1, t1-t);
+                    browserversion = xstrndup(t + 1, t1-t);
             }
         } else if (strstr (s, "Mozilla")) {
             browser = ESI_BROWSER_MOZILLA;
@@ -402,7 +404,7 @@ ESIVariableUserAgent::ESIVariableUserAgent(ESIVarState &state)
     } else {
         UserOs = ESI_OS_OTHER;
         browser = ESI_BROWSER_OTHER;
-        browserversion = xstrdup ("");
+        browserversion = xstrdup("");
     }
 }
 
@@ -32,11 +32,12 @@
 #ifndef SQUID_ESIVARSTATE_H
 #define SQUID_ESIVARSTATE_H
 
-#include "base/Vector.h"
 #include "esi/Segment.h"
 #include "HttpHeader.h"
 #include "libTrie/Trie.h"
 
+#include <vector>
+
 class HttpReply;
 
 /* esi variable replacement logic */
@@ -117,7 +118,7 @@ class ESIVarState
     void doIt ();
     void setupUserAgent();
     Trie variables;
-    Vector<Variable*> variablesForCleanup;
+    std::vector<Variable*> variablesForCleanup;
     Variable *defaultVariable;
 };
 
@@ -33,7 +33,6 @@
 #define SQUID_EVENT_H
 
 #include "AsyncEngine.h"
-#include "base/Vector.h"
 #include "MemPool.h"
 
 class StoreEntry;
@@ -62,7 +62,6 @@
 #include "Store.h"
 #include "tools.h"
 #include "URL.h"
-#include "URLScheme.h"
 #include "wordlist.h"
 #if USE_SSL
 #include "ssl/support.h"
@@ -1637,13 +1636,13 @@ ACLExternal::clone() const
     return new ACLExternal(*this);
 }
 
-ACLExternal::ACLExternal (char const *theClass) : data (NULL), class_ (xstrdup (theClass))
+ACLExternal::ACLExternal(char const *theClass) : data(NULL), class_(xstrdup(theClass))
 {}
 
-ACLExternal::ACLExternal (ACLExternal const & old) : data (NULL), class_ (old.class_ ? xstrdup (old.class_) : NULL)
+ACLExternal::ACLExternal(ACLExternal const & old) : data(NULL), class_(old.class_ ? xstrdup(old.class_) : NULL)
 {
     /* we don't have copy constructors for the data yet */
-    assert (!old.data);
+    assert(!old.data);
 }
 
 char const *
@@ -496,7 +496,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
         break;
 
         case LFT_TIME_START: {
-            int precision = fmt->widthMax >=0 ? fmt->widthMax : 3;
+            int precision = fmt->widthMax >=0 ? fmt->widthMax :3;
             snprintf(tmp, sizeof(tmp), "%0*" PRId64 ".%0*d", fmt->zero && (fmt->widthMin - precision - 1 >= 0) ? fmt->widthMin - precision - 1 : 0, static_cast<int64_t>(al->cache.start_time.tv_sec), precision, (int)(al->cache.start_time.tv_usec / fmt->divisor));
             out = tmp;
         }
@@ -19,64 +19,6 @@ static const char c2x[] =
     "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
     "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
 
-#if DEAD_USING_QUOTEMIMEBLOB
-/** copy of Log::QuoteMimeBlob. Bugs there will be found here.
- * This omits [] characters but is otherwise identical to Log::QuoteMimeBlob when OLD_LOG_MIME = 1
- */
-static char *
-username_quote(const char *header)
-{
-    int c;
-    int i;
-    char *buf;
-    char *buf_cursor;
-
-    if (header == NULL) {
-        buf = static_cast<char *>(xcalloc(1, 1));
-        *buf = '\0';
-        return buf;
-    }
-
-    buf = static_cast<char *>(xcalloc(1, (strlen(header) * 3) + 1));
-    buf_cursor = buf;
-    /*
-     * We escape: space \x00-\x1F and space (0x40) and \x7F-\xFF
-     * to prevent garbage in the logs. CR and LF are also there just in case.
-     */
-
-    while ((c = *(const unsigned char *) header++) != '\0') {
-        if (c == '\r') {
-            *buf_cursor = '\\';
-            ++buf_cursor;
-            *buf_cursor = 'r';
-            ++buf_cursor;
-        } else if (c == '\n') {
-            *buf_cursor = '\\';
-            ++buf_cursor;
-            *buf_cursor = 'n';
-            ++buf_cursor;
-        } else if (c <= 0x1F
-                   || c >= 0x7F
-                   || c == '%'
-                   || c == ' ') {
-            *buf_cursor = '%';
-            ++buf_cursor;
-            i = c * 2;
-            *buf_cursor = c2x[i];
-            ++buf_cursor;
-            *buf_cursor = c2x[i + 1];
-            ++buf_cursor;
-        } else {
-            *buf_cursor = (char) c;
-            ++buf_cursor;
-        }
-    }
-
-    *buf_cursor = '\0';
-    return buf;
-}
-#endif // DEAD
-
 char *
 Format::QuoteUrlEncodeUsername(const char *name)
 {
@@ -87,7 +29,6 @@ Format::QuoteUrlEncodeUsername(const char *name)
         return NULL;
 
     return QuoteMimeBlob(name);
-//    return username_quote(name);
 }
 
 char *
@@ -106,7 +47,7 @@ Format::QuoteMimeBlob(const char *header)
 
     buf = static_cast<char *>(xcalloc(1, (strlen(header) * 3) + 1));
     buf_cursor = buf;
-    /**
+    /*
      * Whe OLD_LOG_MIME is defined we escape: \x00-\x1F"#%;<>?{}|\\\\^~`\[\]\x7F-\xFF
      * which is the default escape list for the CPAN Perl5 URI module
      * modulo the inclusion of space (x40) to make the raw logs a bit
@@ -35,7 +35,7 @@ class Token
             left(false),
             space(false),
             zero(false),
-            divisor(0),
+            divisor(1),
             next(NULL)
     { data.string = NULL; }
 
@@ -68,7 +68,7 @@ class Token
     bool left;
     bool space;
     bool zero;
-    int divisor;
+    int divisor;    // class invariant: MUST NOT be zero.
     Token *next;	/* todo: move from linked list to array */
 
 private:
@@ -146,8 +146,8 @@ class SwapDirRr: public Ipc::Mem::RegisteredRunner
     virtual void create(const RunnerRegistry &);
 
 private:
-    Vector<SwapDir::DirMap::Owner *> mapOwners;
-    Vector< Ipc::Mem::Owner<Ipc::Mem::PageStack> *> freeSlotsOwners;
+    std::vector<SwapDir::DirMap::Owner *> mapOwners;
+    std::vector< Ipc::Mem::Owner<Ipc::Mem::PageStack> *> freeSlotsOwners;
 };
 
 } // namespace Rock
@@ -230,8 +230,10 @@ Fs::Ufs::UFSSwapDir::changeIO(DiskIOModule *module)
     IO->io = anIO;
     /* Change the IO Options */
 
-    if (currentIOOptions && currentIOOptions->options.size() > 2)
-        delete currentIOOptions->options.pop_back();
+    if (currentIOOptions && currentIOOptions->options.size() > 2) {
+        delete currentIOOptions->options.back();
+        currentIOOptions->options.pop_back();
+    }
 
     /* TODO: factor out these 4 lines */
     ConfigOption *ioOptions = IO->io->getOptionTree();
@@ -60,7 +60,6 @@
 #include "Store.h"
 #include "tools.h"
 #include "URL.h"
-#include "URLScheme.h"
 #include "wordlist.h"
 
 #if USE_DELAY_POOLS
@@ -56,6 +56,7 @@ extern const char *null_string;	/* "" */
 extern const char *version_string;	/* VERSION */
 extern const char *appname_string;	/* PACKAGE */
 extern char const *visible_appname_string; /* NULL */
+extern char *service_name;        /* xstrdup(APP_SHORTNAME) */
 extern const char *fdTypeStr[];
 extern const char *hier_strings[];
 extern const char *memStatusStr[];
@@ -121,7 +122,6 @@ extern unsigned int WIN32_Socks_initialized;	/* 0 */
 #if _SQUID_WINDOWS_
 extern unsigned int WIN32_OS_version;	/* 0 */
 extern char *WIN32_OS_string;           /* NULL */
-extern char *WIN32_Service_name;        /* NULL */
 extern char *WIN32_Command_Line;        /* NULL */
 extern char *WIN32_Service_Command_Line; /* NULL */
 extern unsigned int WIN32_run_mode;     /* _WIN_SQUID_RUN_MODE_INTERACTIVE */
@@ -20,7 +20,7 @@ namespace One {
 
 /** HTTP protocol parser.
  *
- * Works on a raw character I/O buffer and separates the content into
+ * Works on a raw character I/O buffer and tokenizes the content into
  * either an error state or HTTP procotol major sections:
  *
  * \item first-line (request-line / simple-request / status-line)
@@ -501,21 +501,15 @@ doV2Query(int fd, Ip::Address &from, char *buf, icp_common_t header)
 #endif /* USE_ICMP */
 
     /* The peer is allowed to use this cache */
-    ICP2State *state = new ICP2State (header, icp_request);
-
+    ICP2State *state = new ICP2State(header, icp_request);
     state->fd = fd;
-
     state->from = from;
-
-    state->url = xstrdup (url);
-
+    state->url = xstrdup(url);
     state->flags = flags;
-
     state->rtt = rtt;
-
     state->src_rtt = src_rtt;
 
-    StoreEntry::getPublic (state, url, Http::METHOD_GET);
+    StoreEntry::getPublic(state, url, Http::METHOD_GET);
 
     HTTPMSGUNLOCK(icp_request);
 }
@@ -58,7 +58,7 @@ doV3Query(int fd, Ip::Address &from, char *buf, icp_common_t header)
 {
     /* We have a valid packet */
     char *url = buf + sizeof(icp_common_t) + sizeof(uint32_t);
-    HttpRequest *icp_request = icpGetRequest (url, header.reqnum, fd, from);
+    HttpRequest *icp_request = icpGetRequest(url, header.reqnum, fd, from);
 
     if (!icp_request)
         return;
@@ -71,12 +71,9 @@ doV3Query(int fd, Ip::Address &from, char *buf, icp_common_t header)
 
     /* The peer is allowed to use this cache */
     ICP3State *state = new ICP3State (header, icp_request);
-
     state->fd = fd;
-
     state->from = from;
-
-    state->url = xstrdup (url);
+    state->url = xstrdup(url);
 
     StoreEntry::getPublic (state, url, Http::METHOD_GET);
 }
@@ -142,7 +142,7 @@ class Config
 public:
 
     Config();
-    ~Config() {};
+    ~Config() {}
 
     void parseConfigLine();
 
@@ -28,7 +28,7 @@ CBDATA_NAMESPACED_CLASS_INIT(Ipc, Coordinator);
 Ipc::Coordinator* Ipc::Coordinator::TheInstance = NULL;
 
 Ipc::Coordinator::Coordinator():
-        Port(coordinatorAddr)
+        Port(Ipc::Port::CoordinatorAddr())
 {
 }
 
@@ -136,7 +136,7 @@ void Ipc::Coordinator::handleRegistrationRequest(const HereIamMessage& msg)
     // send back an acknowledgement; TODO: remove as not needed?
     TypedMsgHdr message;
     msg.pack(message);
-    SendMessage(MakeAddr(strandAddrPfx, msg.strand.kidId), message);
+    SendMessage(MakeAddr(strandAddrLabel, msg.strand.kidId), message);
 }
 
 void
@@ -156,7 +156,7 @@ Ipc::Coordinator::handleSharedListenRequest(const SharedListenRequest& request)
     SharedListenResponse response(c->fd, errNo, request.mapId);
     TypedMsgHdr message;
     response.pack(message);
-    SendMessage(MakeAddr(strandAddrPfx, request.requestorId), message);
+    SendMessage(MakeAddr(strandAddrLabel, request.requestorId), message);
 }
 
 void
@@ -181,7 +181,7 @@ Ipc::Coordinator::handleCacheMgrRequest(const Mgr::Request& request)
     Mgr::Response response(request.requestId);
     TypedMsgHdr message;
     response.pack(message);
-    SendMessage(MakeAddr(strandAddrPfx, request.requestorId), message);
+    SendMessage(MakeAddr(strandAddrLabel, request.requestorId), message);
 
 }
 
@@ -221,7 +221,7 @@ Ipc::Coordinator::notifySearcher(const Ipc::StrandSearchRequest &request,
     const StrandSearchResponse response(strand);
     TypedMsgHdr message;
     response.pack(message);
-    SendMessage(MakeAddr(strandAddrPfx, request.requestorId), message);
+    SendMessage(MakeAddr(strandAddrLabel, request.requestorId), message);
 }
 
 #if SQUID_SNMP
@@ -233,7 +233,7 @@ Ipc::Coordinator::handleSnmpRequest(const Snmp::Request& request)
     Snmp::Response response(request.requestId);
     TypedMsgHdr message;
     response.pack(message);
-    SendMessage(MakeAddr(strandAddrPfx, request.requestorId), message);
+    SendMessage(MakeAddr(strandAddrLabel, request.requestorId), message);
 
     AsyncJob::Start(new Snmp::Inquirer(request, strands_));
 }
@@ -6,7 +6,6 @@
 #ifndef SQUID_IPC_COORDINATOR_H
 #define SQUID_IPC_COORDINATOR_H
 
-#include "base/Vector.h"
 #include "ipc/Messages.h"
 #include "ipc/Port.h"
 #include "ipc/SharedListen.h"
@@ -59,7 +59,7 @@ Ipc::Forwarder::start()
         handleError();
     }
 
-    SendMessage(coordinatorAddr, message);
+    SendMessage(Ipc::Port::CoordinatorAddr(), message);
     eventAdd("Ipc::Forwarder::requestTimedOut", &Forwarder::RequestTimedOut,
              this, timeout, 0, false);
 }
@@ -72,7 +72,7 @@ Ipc::Inquirer::inquire()
     TheRequestsMap[request->requestId] = callback;
     TypedMsgHdr message;
     request->pack(message);
-    SendMessage(Port::MakeAddr(strandAddrPfx, kidId), message);
+    SendMessage(Port::MakeAddr(strandAddrLabel, kidId), message);
     eventAdd("Ipc::Inquirer::requestTimedOut", &Inquirer::RequestTimedOut,
              this, timeout, 0, false);
 }
@@ -19,8 +19,7 @@ Kids::Kids()
 /// maintain n kids
 void Kids::init()
 {
-    if (storage.size() > 0)
-        storage.clean();
+    storage.clear();
 
     storage.reserve(NumberOfKids());
 
@@ -4,9 +4,10 @@
 #ifndef SQUID_IPC_KIDS_H
 #define SQUID_IPC_KIDS_H
 
-#include "base/Vector.h"
 #include "ipc/Kid.h"
 
+#include <vector>
+
 /// a collection of kids
 class Kids
 {
@@ -46,7 +47,7 @@ class Kids
     size_t count() const;
 
 private:
-    Vector<Kid> storage;
+    std::vector<Kid> storage;
 };
 
 extern Kids TheKids; ///< All kids being maintained
@@ -13,6 +13,8 @@ libipc_la_SOURCES = \
 	Kids.cc \
 	Kids.h \
 	Messages.h \
+	MemMap.cc \
+	MemMap.h \
 	Queue.cc \
 	Queue.h \
 	ReadWriteLock.cc \
@@ -0,0 +1,332 @@
+/*
+ * DEBUG: section 54    Interprocess Communication
+ */
+
+#include "squid.h"
+#include "ipc/MemMap.h"
+#include "store_key_md5.h"
+#include "tools.h"
+
+Ipc::MemMap::MemMap(const char *const aPath) :
+        cleaner(NULL),
+        path(aPath),
+        shared(shm_old(Shared)(aPath))
+{
+    assert(shared->limit > 0); // we should not be created otherwise
+    debugs(54, 5, "attached map [" << path << "] created: " <<
+           shared->limit);
+}
+
+Ipc::MemMap::Owner *
+Ipc::MemMap::Init(const char *const path, const int limit, const size_t extrasSize)
+{
+    assert(limit > 0); // we should not be created otherwise
+    Owner *const owner = shm_new(Shared)(path, limit, extrasSize);
+    debugs(54, 5, "new map [" << path << "] created: " << limit);
+    return owner;
+}
+
+Ipc::MemMap::Owner *
+Ipc::MemMap::Init(const char *const path, const int limit)
+{
+    return Init(path, limit, 0);
+}
+
+Ipc::MemMap::Slot *
+Ipc::MemMap::openForWriting(const cache_key *const key, sfileno &fileno)
+{
+    debugs(54, 5, "trying to open slot for key " << storeKeyText(key)
+           << " for writing in map [" << path << ']');
+    const int idx = slotIndexByKey(key);
+
+    if (Slot *slot = openForWritingAt(idx)) {
+        fileno = idx;
+        return slot;
+    }
+
+    return NULL;
+}
+
+Ipc::MemMap::Slot *
+Ipc::MemMap::openForWritingAt(const sfileno fileno, bool overwriteExisting)
+{
+    Slot &s = shared->slots[fileno];
+    ReadWriteLock &lock = s.lock;
+
+    if (lock.lockExclusive()) {
+        assert(s.writing() && !s.reading());
+
+        // bail if we cannot empty this position
+        if (!s.waitingToBeFreed && !s.empty() && !overwriteExisting) {
+            lock.unlockExclusive();
+            debugs(54, 5, "cannot open existing entry " << fileno <<
+                   " for writing " << path);
+            return NULL;
+        }
+
+        // free if the entry was used, keeping the entry locked
+        if (s.waitingToBeFreed || !s.empty())
+            freeLocked(s, true);
+
+        assert(s.empty());
+        ++shared->count;
+
+        debugs(54, 5, "opened slot at " << fileno <<
+               " for writing in map [" << path << ']');
+        return &s; // and keep the entry locked
+    }
+
+    debugs(54, 5, "failed to open slot at " << fileno <<
+           " for writing in map [" << path << ']');
+    return NULL;
+}
+
+void
+Ipc::MemMap::closeForWriting(const sfileno fileno, bool lockForReading)
+{
+    debugs(54, 5, "closing slot at " << fileno << " for writing and "
+           "openning for reading in map [" << path << ']');
+    assert(valid(fileno));
+    Slot &s = shared->slots[fileno];
+    assert(s.writing());
+    if (lockForReading)
+        s.lock.switchExclusiveToShared();
+    else
+        s.lock.unlockExclusive();
+}
+
+/// terminate writing the entry, freeing its slot for others to use
+void
+Ipc::MemMap::abortWriting(const sfileno fileno)
+{
+    debugs(54, 5, "abort writing slot at " << fileno <<
+           " in map [" << path << ']');
+    assert(valid(fileno));
+    Slot &s = shared->slots[fileno];
+    assert(s.writing());
+    freeLocked(s, false);
+}
+
+const Ipc::MemMap::Slot *
+Ipc::MemMap::peekAtReader(const sfileno fileno) const
+{
+    assert(valid(fileno));
+    const Slot &s = shared->slots[fileno];
+    if (s.reading())
+        return &s; // immediate access by lock holder so no locking
+    if (s.writing())
+        return NULL; // cannot read the slot when it is being written
+    assert(false); // must be locked for reading or writing
+    return NULL;
+}
+
+void
+Ipc::MemMap::free(const sfileno fileno)
+{
+    debugs(54, 5, "marking slot at " << fileno << " to be freed in"
+           " map [" << path << ']');
+
+    assert(valid(fileno));
+    Slot &s = shared->slots[fileno];
+
+    if (s.lock.lockExclusive())
+        freeLocked(s, false);
+    else
+        s.waitingToBeFreed = true; // mark to free it later
+}
+
+const Ipc::MemMap::Slot *
+Ipc::MemMap::openForReading(const cache_key *const key, sfileno &fileno)
+{
+    debugs(54, 5, "trying to open slot for key " << storeKeyText(key)
+           << " for reading in map [" << path << ']');
+    const int idx = slotIndexByKey(key);
+    if (const Slot *slot = openForReadingAt(idx)) {
+        if (slot->sameKey(key)) {
+            fileno = idx;
+            debugs(54, 5, "opened slot at " << fileno << " for key "
+                   << storeKeyText(key) << " for reading in map [" << path <<
+                   ']');
+            return slot; // locked for reading
+        }
+        slot->lock.unlockShared();
+    }
+    debugs(54, 5, "failed to open slot for key " << storeKeyText(key)
+           << " for reading in map [" << path << ']');
+    return NULL;
+}
+
+const Ipc::MemMap::Slot *
+Ipc::MemMap::openForReadingAt(const sfileno fileno)
+{
+    debugs(54, 5, "trying to open slot at " << fileno << " for "
+           "reading in map [" << path << ']');
+    assert(valid(fileno));
+    Slot &s = shared->slots[fileno];
+
+    if (!s.lock.lockShared()) {
+        debugs(54, 5, "failed to lock slot at " << fileno << " for "
+               "reading in map [" << path << ']');
+        return NULL;
+    }
+
+    if (s.empty()) {
+        s.lock.unlockShared();
+        debugs(54, 7, "empty slot at " << fileno << " for "
+               "reading in map [" << path << ']');
+        return NULL;
+    }
+
+    if (s.waitingToBeFreed) {
+        s.lock.unlockShared();
+        debugs(54, 7, "dirty slot at " << fileno << " for "
+               "reading in map [" << path << ']');
+        return NULL;
+    }
+
+    debugs(54, 5, "opened slot at " << fileno << " for reading in"
+           " map [" << path << ']');
+    return &s;
+}
+
+void
+Ipc::MemMap::closeForReading(const sfileno fileno)
+{
+    debugs(54, 5, "closing slot at " << fileno << " for reading in "
+           "map [" << path << ']');
+    assert(valid(fileno));
+    Slot &s = shared->slots[fileno];
+    assert(s.reading());
+    s.lock.unlockShared();
+}
+
+int
+Ipc::MemMap::entryLimit() const
+{
+    return shared->limit;
+}
+
+int
+Ipc::MemMap::entryCount() const
+{
+    return shared->count;
+}
+
+bool
+Ipc::MemMap::full() const
+{
+    return entryCount() >= entryLimit();
+}
+
+void
+Ipc::MemMap::updateStats(ReadWriteLockStats &stats) const
+{
+    for (int i = 0; i < shared->limit; ++i)
+        shared->slots[i].lock.updateStats(stats);
+}
+
+bool
+Ipc::MemMap::valid(const int pos) const
+{
+    return 0 <= pos && pos < entryLimit();
+}
+
+static
+unsigned int
+hash_key(const unsigned char *data, unsigned int len, unsigned int hashSize)
+{
+    unsigned int n;
+    unsigned int j;
+    for (j = 0, n = 0; j < len; j++ ) {
+        n ^= 271 * *data;
+        ++data;
+    }
+    return (n ^ (j * 271)) % hashSize;
+}
+
+int
+Ipc::MemMap::slotIndexByKey(const cache_key *const key) const
+{
+    const unsigned char *k = reinterpret_cast<const unsigned char *>(key);
+    return hash_key(k, MEMMAP_SLOT_KEY_SIZE, shared->limit);
+}
+
+Ipc::MemMap::Slot &
+Ipc::MemMap::slotByKey(const cache_key *const key)
+{
+    return shared->slots[slotIndexByKey(key)];
+}
+
+/// unconditionally frees the already exclusively locked slot and releases lock
+void
+Ipc::MemMap::freeLocked(Slot &s, bool keepLocked)
+{
+    if (!s.empty() && cleaner)
+        cleaner->noteFreeMapSlot(&s - shared->slots.raw());
+
+    s.waitingToBeFreed = false;
+    memset(s.key, 0, sizeof(s.key));
+    if (!keepLocked)
+        s.lock.unlockExclusive();
+    --shared->count;
+    debugs(54, 5, "freed slot at " << (&s - shared->slots.raw()) <<
+           " in map [" << path << ']');
+}
+
+/* Ipc::MemMapSlot */
+Ipc::MemMapSlot::MemMapSlot() :
+        pSize(0),
+        expire(0)
+{
+    memset(key, 0, sizeof(key));
+    memset(p, 0, sizeof(p));
+}
+
+void
+Ipc::MemMapSlot::set(const unsigned char *aKey, const void *block, size_t blockSize, time_t expireAt)
+{
+    memcpy(key, aKey, sizeof(key));
+    if (block)
+        memcpy(p, block, blockSize);
+    pSize = blockSize;
+    expire = expireAt;
+}
+
+bool
+Ipc::MemMapSlot::sameKey(const cache_key *const aKey) const
+{
+    return (memcmp(key, aKey, sizeof(key)) == 0);
+}
+
+bool
+Ipc::MemMapSlot::empty() const
+{
+    for (unsigned char const*u = key; u < key + sizeof(key); ++u) {
+        if (*u)
+            return false;
+    }
+    return true;
+}
+
+/* Ipc::MemMap::Shared */
+
+Ipc::MemMap::Shared::Shared(const int aLimit, const size_t anExtrasSize):
+        limit(aLimit), extrasSize(anExtrasSize), count(0), slots(aLimit)
+{
+}
+
+Ipc::MemMap::Shared::~Shared()
+{
+}
+
+size_t
+Ipc::MemMap::Shared::sharedMemorySize() const
+{
+    return SharedMemorySize(limit, extrasSize);
+}
+
+size_t
+Ipc::MemMap::Shared::SharedMemorySize(const int limit, const size_t extrasSize)
+{
+    return sizeof(Shared) + limit * (sizeof(Slot) + extrasSize);
+}
@@ -0,0 +1,140 @@
+#ifndef SQUID_IPC_STORE_MAP_H
+#define SQUID_IPC_STORE_MAP_H
+
+#include "Debug.h"
+#include "ipc/mem/FlexibleArray.h"
+#include "ipc/mem/Pointer.h"
+#include "ipc/ReadWriteLock.h"
+#include "SBuf.h"
+#include "tools.h"
+#include "typedefs.h"
+
+namespace Ipc
+{
+
+// The MEMMAP_SLOT_KEY_SIZE and MEMMAP_SLOT_DATA_SIZE must be enough big
+// to hold cached keys and data. Currently MemMap used only to store SSL
+// shared session data which have keys of 32bytes and at most 10K data
+#define MEMMAP_SLOT_KEY_SIZE 32
+#define MEMMAP_SLOT_DATA_SIZE 10*1024
+
+/// a MemMap basic element, holding basic shareable memory block info
+class MemMapSlot
+{
+public:
+    MemMapSlot();
+    size_t size() const {return sizeof(MemMapSlot);}
+    size_t keySize() const {return sizeof(key);}
+    bool sameKey(const cache_key *const aKey) const;
+    void set(const unsigned char *aKey, const void *block, size_t blockSize, time_t expire = 0);
+    bool empty() const;
+    bool reading() const { return lock.readers; }
+    bool writing() const { return lock.writing; }
+
+    Atomic::WordT<uint8_t> waitingToBeFreed; ///< may be accessed w/o a lock
+    mutable ReadWriteLock lock; ///< protects slot data below
+    unsigned char key[MEMMAP_SLOT_KEY_SIZE]; ///< The entry key
+    unsigned char p[MEMMAP_SLOT_DATA_SIZE]; ///< The memory block;
+    size_t pSize;
+    time_t expire;
+};
+
+class MemMapCleaner;
+
+/// A map of MemMapSlots indexed by their keys, with read/write slot locking.
+class MemMap
+{
+public:
+    typedef MemMapSlot Slot;
+
+    /// data shared across maps in different processes
+    class Shared
+    {
+    public:
+        Shared(const int aLimit, const size_t anExtrasSize);
+        size_t sharedMemorySize() const;
+        static size_t SharedMemorySize(const int limit, const size_t anExtrasSize);
+        ~Shared();
+
+        const int limit; ///< maximum number of map slots
+        const size_t extrasSize; ///< size of slot extra data
+        Atomic::Word count; ///< current number of map slots
+        Ipc::Mem::FlexibleArray<Slot> slots; ///< storage
+    };
+
+public:
+    typedef Mem::Owner<Shared> Owner;
+
+    /// initialize shared memory
+    static Owner *Init(const char *const path, const int limit);
+
+    MemMap(const char *const aPath);
+
+    /// finds, locks and return a slot for an empty key position,
+    /// erasing the old entry (if any)
+    Slot *openForWriting(const cache_key *const key, sfileno &fileno);
+
+    /// locks and returns a slot for the empty fileno position; if
+    /// overwriteExisting is false and the position is not empty, returns nil
+    Slot *openForWritingAt(sfileno fileno, bool overwriteExisting = true);
+
+    /// successfully finish writing the entry
+    void closeForWriting(const sfileno fileno, bool lockForReading = false);
+
+    /// only works on locked entries; returns nil unless the slot is readable
+    const Slot *peekAtReader(const sfileno fileno) const;
+
+    /// mark the slot as waiting to be freed and, if possible, free it
+    void free(const sfileno fileno);
+
+    /// open slot for reading, increments read level
+    const Slot *openForReading(const cache_key *const key, sfileno &fileno);
+
+    /// open slot for reading, increments read level
+    const Slot *openForReadingAt(const sfileno fileno);
+
+    /// close slot after reading, decrements read level
+    void closeForReading(const sfileno fileno);
+
+    bool full() const; ///< there are no empty slots left
+    bool valid(const int n) const; ///< whether n is a valid slot coordinate
+    int entryCount() const; ///< number of used slots
+    int entryLimit() const; ///< maximum number of slots that can be used
+
+    /// adds approximate current stats to the supplied ones
+    void updateStats(ReadWriteLockStats &stats) const;
+
+    /// The cleaner MemMapCleaner::noteFreeMapSlot method called when a
+    /// readable entry is freed.
+    MemMapCleaner *cleaner;
+
+protected:
+    static Owner *Init(const char *const path, const int limit, const size_t extrasSize);
+
+    const SBuf path; ///< cache_dir path, used for logging
+    Mem::Pointer<Shared> shared;
+    int ttl;
+
+private:
+    int slotIndexByKey(const cache_key *const key) const;
+    Slot &slotByKey(const cache_key *const key);
+
+    Slot *openForReading(Slot &s);
+    void abortWriting(const sfileno fileno);
+    void freeIfNeeded(Slot &s);
+    void freeLocked(Slot &s, bool keepLocked);
+};
+
+/// API for adjusting external state when dirty map slot is being freed
+class MemMapCleaner
+{
+public:
+    virtual ~MemMapCleaner() {}
+
+    /// adjust slot-linked state before a locked Readable slot is erased
+    virtual void noteFreeMapSlot(const sfileno slotId) = 0;
+};
+
+} // namespace Ipc
+
+#endif /* SQUID_IPC_STORE_MAP_H */
@@ -7,10 +7,12 @@
 #include "comm.h"
 #include "comm/Connection.h"
 #include "CommCalls.h"
+#include "globals.h"
 #include "ipc/Port.h"
 
-const char Ipc::coordinatorAddr[] = DEFAULT_STATEDIR "/coordinator.ipc";
-const char Ipc::strandAddrPfx[] = DEFAULT_STATEDIR "/kid";
+static const char channelPathPfx[] = DEFAULT_STATEDIR "/";
+static const char coordinatorAddrLabel[] = "-coordinator";
+const char Ipc::strandAddrLabel[] =  "-kid";
 
 Ipc::Port::Port(const String& aListenAddr):
         UdsOp(aListenAddr)
@@ -39,16 +41,31 @@ bool Ipc::Port::doneAll() const
     return false; // listen forever
 }
 
-String Ipc::Port::MakeAddr(const char* pathAddr, int id)
+String Ipc::Port::MakeAddr(const char* processLabel, int id)
 {
     assert(id >= 0);
-    String addr = pathAddr;
+    String addr = channelPathPfx;
+    addr.append(service_name);
+    addr.append(processLabel);
     addr.append('-');
     addr.append(xitoa(id));
     addr.append(".ipc");
     return addr;
 }
 
+String
+Ipc::Port::CoordinatorAddr()
+{
+    static String coordinatorAddr;
+    if (!coordinatorAddr.size()) {
+        coordinatorAddr= channelPathPfx;
+        coordinatorAddr.append(service_name);
+        coordinatorAddr.append(coordinatorAddrLabel);
+        coordinatorAddr.append(".ipc");
+    }
+    return coordinatorAddr;
+}
+
 void Ipc::Port::noteRead(const CommIoCbParams& params)
 {
     debugs(54, 6, HERE << params.conn << " flag " << params.flag <<
@@ -17,8 +17,11 @@ class Port: public UdsOp
 {
 public:
     Port(const String &aListenAddr);
-    /// calculates IPC message address for strand #id at path
-    static String MakeAddr(const char *path, int id);
+    /// calculates IPC message address for strand #id of processLabel type
+    static String MakeAddr(const char *proccessLabel, int id);
+
+    /// get the IPC message address for coordinator process
+    static String CoordinatorAddr();
 
 protected:
     virtual void start() = 0; // UdsOp (AsyncJob) API; has body
@@ -37,8 +40,7 @@ class Port: public UdsOp
     TypedMsgHdr buf; ///< msghdr struct filled by Comm
 };
 
-extern const char coordinatorAddr[]; ///< where coordinator listens
-extern const char strandAddrPfx[]; ///< strand's listening address prefix
+extern const char strandAddrLabel[]; ///< strand's listening address unique label
 
 } // namespace Ipc
 
@@ -5,7 +5,6 @@
 #define SQUID_IPC_QUEUE_H
 
 #include "base/InstanceId.h"
-#include "base/Vector.h"
 #include "Debug.h"
 #include "ipc/AtomicWord.h"
 #include "ipc/mem/FlexibleArray.h"
@@ -117,7 +117,7 @@ void Ipc::JoinSharedListen(const OpenListenerParams &params,
 
     TypedMsgHdr message;
     request.pack(message);
-    SendMessage(coordinatorAddr, message);
+    SendMessage(Ipc::Port::CoordinatorAddr(), message);
 }
 
 void Ipc::SharedListenJoined(const SharedListenResponse &response)
@@ -32,7 +32,7 @@
 CBDATA_NAMESPACED_CLASS_INIT(Ipc, Strand);
 
 Ipc::Strand::Strand():
-        Port(MakeAddr(strandAddrPfx, KidIdentifier)),
+        Port(MakeAddr(strandAddrLabel, KidIdentifier)),
         isRegistered(false)
 {
 }
@@ -51,7 +51,7 @@ void Ipc::Strand::registerSelf()
     HereIamMessage ann(StrandCoord(KidIdentifier, getpid()));
     TypedMsgHdr message;
     ann.pack(message);
-    SendMessage(coordinatorAddr, message);
+    SendMessage(Port::CoordinatorAddr(), message);
     setTimeout(6, "Ipc::Strand::timeoutHandler"); // TODO: make 6 configurable?
 }
 
@@ -157,12 +157,12 @@
 
 static int opt_install_service = FALSE;
 static int opt_remove_service = FALSE;
-static int opt_signal_service = FALSE;
 static int opt_command_line = FALSE;
 void WIN32_svcstatusupdate(DWORD, DWORD);
 void WINAPI WIN32_svcHandler(DWORD);
 #endif
 
+static int opt_signal_service = FALSE;
 static char *opt_syslog_facility = NULL;
 static int icpPortNumOverride = 1;	/* Want to detect "-u 0" */
 static int configured_once = 0;
@@ -281,11 +281,11 @@ static void
 usage(void)
 {
     fprintf(stderr,
+            "Usage: %s [-cdhvzCFNRVYX] [-n name] [-s | -l facility] [-f config-file] [-[au] port] [-k signal]"
 #if USE_WIN32_SERVICE
-            "Usage: %s [-cdhirvzCFNRVYX] [-s | -l facility] [-f config-file] [-[au] port] [-k signal] [-n name] [-O CommandLine]\n"
-#else
-            "Usage: %s [-cdhvzCFNRVYX] [-s | -l facility] [-f config-file] [-[au] port] [-k signal]\n"
+            "[-ir] [-O CommandLine]"
 #endif
+            "\n"
             "       -a port   Specify HTTP port number (default: %d).\n"
             "       -d level  Write debugging to stderr also.\n"
             "       -f file   Use given config-file instead of\n"
@@ -297,9 +297,9 @@ usage(void)
             "       -k reconfigure|rotate|shutdown|interrupt|kill|debug|check|parse\n"
             "                 Parse configuration file, then send signal to \n"
             "                 running copy (except -k parse) and exit.\n"
+            "       -n name   Specify service name to use for service operations\n"
+            "                 default is: " APP_SHORTNAME ".\n"
 #if USE_WIN32_SERVICE
-            "       -n name   Specify Windows Service name to use for service operations\n"
-            "                 default is: " _WIN_SQUID_DEFAULT_SERVICE_NAME ".\n"
             "       -r        Removes a Windows Service (see -n option).\n"
 #endif
             "       -s | -l facility\n"
@@ -338,7 +338,7 @@ mainParseOptions(int argc, char *argv[])
 #if USE_WIN32_SERVICE
     while ((c = getopt(argc, argv, "CDFNO:RSVYXa:d:f:hik:m::n:rsl:u:vz?")) != -1)
 #else
-    while ((c = getopt(argc, argv, "CDFNRSYXa:d:f:hk:m::sl:u:vz?")) != -1)
+    while ((c = getopt(argc, argv, "CDFNRSYXa:d:f:hk:m::n:sl:u:vz?")) != -1)
 #endif
     {
 
@@ -508,20 +508,18 @@ mainParseOptions(int argc, char *argv[])
             }
             break;
 
-#if USE_WIN32_SERVICE
-
         case 'n':
             /** \par n
-             * Set global option opt_signal_service (to TRUE).
-             * Stores the additional parameter given in global WIN32_Service_name */
-            xfree(WIN32_Service_name);
-
-            WIN32_Service_name = xstrdup(optarg);
-
-            opt_signal_service = TRUE;
-
+             * Set global option opt_signal_service (to true).
+             * Stores the additional parameter given in global service_name */
+            // XXX: verify that the new name has ONLY alphanumeric characters
+            xfree(service_name);
+            service_name = xstrdup(optarg);
+            opt_signal_service = true;
             break;
 
+#if USE_WIN32_SERVICE
+
         case 'r':
             /** \par r
              * Set global option opt_remove_service (to TRUE) */
@@ -569,6 +567,7 @@ mainParseOptions(int argc, char *argv[])
             /** \par v
              * Display squid version and build information. Then exit. */
             printf("Squid Cache: Version %s\n" ,version_string);
+            printf("Service Name: %s\n", service_name);
             if (strlen(SQUID_BUILD_INFO))
                 printf("%s\n",SQUID_BUILD_INFO);
             printf( "configure options: %s\n", SQUID_CONFIGURE_OPTIONS);
@@ -698,7 +697,6 @@ serverConnectionsOpen(void)
         snmpOpenPorts();
 #endif
 
-        clientdbInit();
         icmpEngine.Open();
         netdbInit();
         asnInit();
@@ -1012,10 +1010,10 @@ mainInitialize(void)
 #endif
 
     debugs(1, DBG_CRITICAL, "Starting Squid Cache version " << version_string << " for " << CONFIG_HOST_TYPE << "...");
+    debugs(1, DBG_CRITICAL, "Service Name: " << service_name);
 
 #if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
-        debugs(1, DBG_CRITICAL, "Running as " << WIN32_Service_name << " Windows System Service on " << WIN32_OS_string);
         debugs(1, DBG_CRITICAL, "Service command line is: " << WIN32_Service_Command_Line);
     } else
         debugs(1, DBG_CRITICAL, "Running on " << WIN32_OS_string);
@@ -1057,6 +1055,9 @@ mainInitialize(void)
 #endif
 
 #if USE_SSL
+    if (!configured_once)
+        Ssl::initialize_session_cache();
+
     if (Ssl::CertValidationHelper::GetInstance())
         Ssl::CertValidationHelper::GetInstance()->Init();
 #endif
@@ -79,7 +79,7 @@ Mgr::Action::sendResponse(unsigned int requestId)
     Response response(requestId, this);
     Ipc::TypedMsgHdr message;
     response.pack(message);
-    Ipc::SendMessage(Ipc::coordinatorAddr, message);
+    Ipc::SendMessage(Ipc::Port::CoordinatorAddr(), message);
 }
 
 void
@@ -98,7 +98,7 @@ Mgr::Action::fillEntry(StoreEntry* entry, bool writeHttpHeader)
 
     if (writeHttpHeader) {
         HttpReply *rep = new HttpReply;
-        rep->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
+        rep->setHeaders(Http::scOkay, NULL, contentType(), -1, squid_curtime, squid_curtime);
         // Allow cachemgr and other XHR scripts access to our version string
         const ActionParams &params = command().params;
         if (params.httpOrigin.size() > 0) {
@@ -63,6 +63,9 @@ class Action: public RefCountable
 
     StoreEntry *createStoreEntry() const; ///< creates store entry from params
 
+    ///< Content-Type: header value for this report
+    virtual const char *contentType() const {return "text/plain;charset=utf-8";}
+
 protected:
     /// calculate and keep local action-specific information
     virtual void collect() {}
@@ -300,7 +300,7 @@ peerDigestRequest(PeerDigest * pd)
 {
     CachePeer *p = pd->peer;
     StoreEntry *e, *old_e;
-    char *url;
+    char *url = NULL;
     const cache_key *key;
     HttpRequest *req;
     DigestFetchState *fetch = NULL;
@@ -398,6 +398,8 @@ peerDigestRequest(PeerDigest * pd)
 
     storeClientCopy(fetch->sc, e, tempBuffer,
                     peerDigestHandleReply, fetch);
+
+    safe_free(url);
 }
 
 /* Handle the data copying .. */
@@ -339,14 +339,14 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
 
             // for TPROXY spoofing we must skip unusable addresses.
             if (psstate->request->flags.spoofClientIp && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
-                if (ia->in_addrs[n].isIPv4() != psstate->request->client_addr.isIPv4()) {
+                if (ia->in_addrs[ip].isIPv4() != psstate->request->client_addr.isIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
                     continue;
                 }
             }
 
             p = new Comm::Connection();
-            p->remote = ia->in_addrs[n];
+            p->remote = ia->in_addrs[ip];
 
             // when IPv6 is disabled we cannot use it
             if (!Ip::EnableIpv6 && p->remote.isIPv6()) {
@@ -60,11 +60,14 @@ typedef enum {
     rcCount
 } refreshCountsEnum;
 
+/**
+ * Flags indicating which staleness algorithm has been applied.
+ */
 typedef struct {
-    bool expires;
-    bool min;
-    bool lmfactor;
-    bool max;
+    bool expires;  ///< Expires: header absolute timestamp limit
+    bool min;      ///< Heuristic minimum age limited
+    bool lmfactor; ///< Last-Modified with heuristic determines limit
+    bool max;      ///< Configured maximum age limit
 } stale_flags;
 
 /*
@@ -96,9 +99,7 @@ static struct RefreshCounts {
     const char *proto;
     int total;
     int status[STALE_DEFAULT + 1];
-}
-
-refreshCounts[rcCount];
+} refreshCounts[rcCount];
 
 /*
  * Defaults:
@@ -116,6 +117,12 @@ static int refreshStaleness(const StoreEntry * entry, time_t check_time, const t
 
 static RefreshPattern DefaultRefresh;
 
+/** Locate the first refresh_pattern rule that matches the given URL by regex.
+ *
+ * \note regexec() returns 0 if matched, and REG_NOMATCH otherwise
+ *
+ * \return A pointer to the refresh_pattern parameters to use, or NULL if there is no match.
+ */
 const RefreshPattern *
 refreshLimits(const char *url)
 {
@@ -129,6 +136,14 @@ refreshLimits(const char *url)
     return NULL;
 }
 
+/** Locate the first refresh_pattern rule that has the given uncompiled regex.
+ *
+ * \note There is only one reference to this function, below. It always passes "." as the pattern.
+ * This function is only ever called if there is no URI. Because a regex match is impossible, Squid
+ * forces the "." rule to apply (if it exists)
+ *
+ * \return A pointer to the refresh_pattern parameters to use, or NULL if there is no match.
+ */
 static const RefreshPattern *
 refreshUncompiledPattern(const char *pat)
 {
@@ -144,25 +159,30 @@ refreshUncompiledPattern(const char *pat)
 
 /**
  * Calculate how stale the response is (or will be at the check_time).
- * Staleness calculation is based on the following: (1) response
- * expiration time, (2) age greater than configured maximum, (3)
- * last-modified factor, and (4) age less than configured minimum.
+ *
+ * We try the following ways until one gives a result:
+ *
+ * 1. response expiration time, if one was set
+ * 2. age greater than configured maximum
+ * 3. last-modified factor algorithm
+ * 4. age less than configured minimum
+ * 5. default (stale)
+ *
+ * \param entry       the StoreEntry being examined
+ * \param check_time  the time (maybe future) at which we want to know whether $
+ * \param age         the age of the entry at check_time
+ * \param R           the refresh_pattern rule that matched this entry
+ * \param sf          small struct to indicate reason for stale/fresh decision
  *
  * \retval -1  If the response is fresh.
- * \retval >0  Otherwise return it's staleness.
+ * \retval >0  The amount of staleness.
  * \retval 0   NOTE return value of 0 means the response is stale.
- *
- * The 'stale_flags' structure is used to tell the calling function
- * _why_ this response is fresh or stale.  Its used, for example,
- * when the admin wants to override expiration and last-modified
- * times.
  */
 static int
 refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf)
 {
-    /** \par
-     * Check for an explicit expiration time (Expires: header).
-     */
+    // 1. If the cached object has an explicit expiration time, then we rely on this and
+    //    completely ignore the Min, Percent and Max values in the refresh_pattern.
     if (entry->expires > -1) {
         sf->expires = true;
 
@@ -179,25 +199,31 @@ refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age,
         }
     }
 
-    /** \par
-     * Use local heuristics to determine staleness.  Start with the
-     * max age from the refresh_pattern rule.
-     */
+    debugs(22, 3, "No explicit expiry given, using heuristics to determine freshness");
+
+    // 2. If the entry is older than the maximum age in the refresh_pattern, it is STALE.
     if (age > R->max) {
         debugs(22, 3, "STALE: age " << age << " > max " << R->max << " ");
         sf->max = true;
         return (age - R->max);
     }
 
-    /** \par
-     * Try the last-modified factor algorithm:  refresh_pattern n% percentage of Last-Modified: age.
-     */
+    // 3. If there is a Last-Modified header, try the last-modified factor algorithm.
     if (entry->lastmod > -1 && entry->timestamp > entry->lastmod) {
-        /*
-         * stale_age is the Age of the response when it became/becomes
-         * stale according to the last-modified factor algorithm.
+
+        /* lastmod_delta is the difference between the last-modified date of the response
+         * and the time we cached it. It's how "old" the response was when we got it.
          */
-        time_t stale_age = static_cast<time_t>((entry->timestamp - entry->lastmod) * R->pct);
+        time_t lastmod_delta = entry->timestamp - entry->lastmod;
+
+        /* stale_age is the age of the response when it became/becomes stale according to
+         * the last-modified factor algorithm. It's how long we can consider the response
+         * fresh from the time we cached it.
+         */
+        time_t stale_age = static_cast<time_t>(lastmod_delta * R->pct);
+
+        debugs(22,3, "Last modified " << lastmod_delta << " sec before we cached it, L-M factor " <<
+               (100.0 * R->pct) << "% = " << stale_age << " sec freshness lifetime");
         sf->lmfactor = true;
 
         if (age >= stale_age) {
@@ -209,55 +235,107 @@ refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age,
         }
     }
 
-    /** \par
-     * Finally, if all else fails;  staleness is determined by the refresh_pattern
-     * configured minimum age.
-     */
+    // 4. If the entry is not as old as the minimum age in the refresh_pattern, it is FRESH.
     if (age < R->min) {
-        debugs(22, 3, "FRESH: age " << age << " < min " << R->min);
+        debugs(22, 3, "FRESH: age (" << age << " sec) is less than configured minimum (" << R->min << " sec)");
         sf->min = true;
         return -1;
     }
 
-    debugs(22, 3, "STALE: age " << age << " >= min " << R->min);
+    // 5. default is stale, by the amount we missed the minimum by
+    debugs(22, 3, "STALE: No explicit expiry, no last modified, and older than configured minimum.");
     return (age - R->min);
 }
 
-/**
- * \retval 1 if the entry must be revalidated within delta seconds
- * \retval 0 otherwise
+/** Checks whether a store entry is fresh or stale, and why.
+ *
+ * This is where all aspects of request, response and squid configuration
+ * meet to decide whether a response is cacheable or not:
+ *
+ * 1. Client request headers that affect cacheability, e.g.
+ *  - Cache-Control: no-cache
+ *  - Cache-Control: max-age=N
+ *  - Cache-Control: max-stale[=N]
+ *  - Pragma: no-cache
+ *
+ * 2. Server response headers that affect cacheability, e.g.
+ *  - Age:
+ *  - Cache-Control: proxy-revalidate
+ *  - Cache-Control: must-revalidate
+ *  - Cache-Control: no-cache
+ *  - Cache-Control: max-age=N
+ *  - Cache-Control: s-maxage=N
+ *  - Date:
+ *  - Expires:
+ *  - Last-Modified:
+ *
+ * 3. Configuration options, e.g.
+ *  - reload-into-ims (refresh_pattern)
+ *  - ignore-reload (refresh_pattern)
+ *  - refresh-ims (refresh_pattern)
+ *  - override-lastmod (refresh_pattern)
+ *  - override-expire (refresh_pattern)
+ *  - reload_into_ims (global option)
+ *  - refresh_all_ims (global option)
+ *
+ * \returns a status code (from enum above):
+ *  - FRESH_REQUEST_MAX_STALE_ALL
+ *  - FRESH_REQUEST_MAX_STALE_VALUE
+ *  - FRESH_EXPIRES
+ *  - FRESH_LMFACTOR_RULE
+ *  - FRESH_MIN_RULE
+ *  - FRESH_OVERRIDE_EXPIRES
+ *  - FRESH_OVERRIDE_LASTMOD
+ *  - STALE_MUST_REVALIDATE
+ *  - STALE_RELOAD_INTO_IMS
+ *  - STALE_FORCED_RELOAD
+ *  - STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE
+ *  - STALE_EXPIRES
+ *  - STALE_MAX_RULE
+ *  - STALE_LMFACTOR_RULE
+ *  - STALE_MAX_STALE
+ *  - STALE_DEFAULT
+ *
+ * \note request may be NULL (e.g. for cache digests build)
  *
- *  note: request maybe null (e.g. for cache digests build)
+ * \note the store entry being examined is not necessarily cached (e.g. if
+ *       this response is being evaluated for the first time)
  */
 static int
 refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 {
-    const RefreshPattern *R;
     const char *uri = NULL;
     time_t age = 0;
     time_t check_time = squid_curtime + delta;
     int staleness;
     stale_flags sf;
 
+    // get the URL of this entry, if there is one
     if (entry->mem_obj)
         uri = entry->mem_obj->storeId();
     else if (request)
         uri = urlCanonical(request);
 
-    debugs(22, 3, "refreshCheck: '" << (uri ? uri : "<none>") << "'");
+    debugs(22, 3, "checking freshness of '" << (uri ? uri : "<none>") << "'");
 
+    // age is not necessarily the age now, but the age at the given check_time
     if (check_time > entry->timestamp)
         age = check_time - entry->timestamp;
 
     // FIXME: what to do when age < 0 or counter overflow?
     assert(age >= 0);
 
-    R = uri ? refreshLimits(uri) : refreshUncompiledPattern(".");
-
+    /* We need a refresh rule. In order of preference:
+     *
+     *   1. the rule that matches this URI by regex
+     *   2. the "." rule from the config file
+     *   3. the default "." rule
+     */
+    const RefreshPattern *R = uri ? refreshLimits(uri) : refreshUncompiledPattern(".");
     if (NULL == R)
         R = &DefaultRefresh;
 
-    debugs(22, 3, "refreshCheck: Matched '" << R->pattern << " " <<
+    debugs(22, 3, "Matched '" << R->pattern << " " <<
            (int) R->min << " " << (int) (100.0 * R->pct) << "%% " <<
            (int) R->max << "'");
 
@@ -292,16 +370,21 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
             entry->mem_obj->getReply()->cache_control->hasStaleIfError() &&
             entry->mem_obj->getReply()->cache_control->staleIfError() < staleness) {
 
-        debugs(22, 3, "refreshCheck: stale-if-error period expired.");
+        debugs(22, 3, "stale-if-error period expired. Will produce error if validation fails.");
         request->flags.failOnValidationError = true;
     }
 
+    /* If the origin server specified either of:
+     *   Cache-Control: must-revalidate
+     *   Cache-Control: proxy-revalidate
+     * the spec says the response must always be revalidated if stale.
+     */
     if (EBIT_TEST(entry->flags, ENTRY_REVALIDATE) && staleness > -1
 #if USE_HTTP_VIOLATIONS
             && !R->flags.ignore_must_revalidate
 #endif
        ) {
-        debugs(22, 3, "refreshCheck: YES: Must revalidate stale response");
+        debugs(22, 3, "YES: Must revalidate stale object (origin set must-revalidate or proxy-revalidate)");
         if (request)
             request->flags.failOnValidationError = true;
         return STALE_MUST_REVALIDATE;
@@ -311,81 +394,111 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
     if (request && !request->flags.ignoreCc) {
         HttpHdrCc *cc = request->cache_control;
 
+        /* If the request is an IMS request, and squid is configured NOT to service this from cache
+         * (either by 'refresh-ims' in the refresh pattern or 'refresh_all_ims on' globally)
+         * then force a reload from the origin.
+         */
         if (request->flags.ims && (R->flags.refresh_ims || Config.onoff.refresh_all_ims)) {
-            /* The clients no-cache header is changed into a IMS query */
-            debugs(22, 3, "refreshCheck: YES: refresh-ims");
+            // The client's no-cache header is changed into a IMS query
+            debugs(22, 3, "YES: Client IMS request forcing revalidation of object (refresh-ims option)");
             return STALE_FORCED_RELOAD;
         }
 
 #if USE_HTTP_VIOLATIONS
-
-        if (!request->flags.noCacheHack()) {
-            (void) 0;
-        } else if (R->flags.ignore_reload) {
-            /* The clients no-cache header is ignored */
-            debugs(22, 3, "refreshCheck: MAYBE: ignore-reload");
-        } else if (R->flags.reload_into_ims || Config.onoff.reload_into_ims) {
-            /* The clients no-cache header is changed into a IMS query */
-            debugs(22, 3, "refreshCheck: YES: reload-into-ims");
-            return STALE_RELOAD_INTO_IMS;
-        } else {
-            /* The clients no-cache header is not overridden on this request */
-            debugs(22, 3, "refreshCheck: YES: client reload");
-            request->flags.noCache = true;
-            return STALE_FORCED_RELOAD;
+        /* Normally a client reload request ("Cache-Control: no-cache" or "Pragma: no-cache")
+         * means we must treat this reponse as STALE and fetch a new one.
+         *
+         * However, some options exist to override this behaviour. For example, we might just
+         * revalidate our existing response, or even just serve it up without revalidating it.
+         *
+         *     ---- Note on the meaning of nocache_hack -----
+         *
+         * The nocache_hack flag has a very specific and complex meaning:
+         *
+         * (a) this is a reload request ("Cache-Control: no-cache" or "Pragma: no-cache" header)
+         * and (b) the configuration file either has at least one refresh_pattern with
+         * ignore-reload or reload-into-ims (not necessarily the rule matching this request) or
+         * the global reload_into_ims is set to on
+         *
+         * In other words: this is a client reload, and we might need to override
+         * the default behaviour (but we might not).
+         *
+         * "nocache_hack" is a pretty deceptive name for such a complicated meaning.
+         */
+        if (request->flags.noCacheHack()) {
+
+            if (R->flags.ignore_reload) {
+                /* The client's no-cache header is ignored completely - we'll try to serve
+                 * what we have (assuming it's still fresh, etc.)
+                 */
+                debugs(22, 3, "MAYBE: Ignoring client reload request - trying to serve from cache (ignore-reload option)");
+            } else if (R->flags.reload_into_ims || Config.onoff.reload_into_ims) {
+                /* The client's no-cache header is not honoured completely - we'll just try
+                 * to revalidate our cached copy (IMS to origin) instead of fetching a new
+                 * copy with an unconditional GET.
+                 */
+                debugs(22, 3, "YES: Client reload request - cheating, only revalidating with origin (reload-into-ims option)");
+                return STALE_RELOAD_INTO_IMS;
+            } else {
+                /* The client's no-cache header is honoured - we fetch a new copy from origin */
+                debugs(22, 3, "YES: Client reload request - fetching new copy from origin");
+                request->flags.noCache = true;
+                return STALE_FORCED_RELOAD;
+            }
         }
-
 #endif
+
+        // Check the Cache-Control client request header
         if (NULL != cc) {
+
+            // max-age directive
             if (cc->hasMaxAge()) {
 #if USE_HTTP_VIOLATIONS
+                // Ignore client "Cache-Control: max-age=0" header
                 if (R->flags.ignore_reload && cc->maxAge() == 0) {
-                    debugs(22, 3, "refreshCheck: MAYBE: client-max-age = 0 and ignore-reload");
+                    debugs(22, 3, "MAYBE: Ignoring client reload request - trying to serve from cache (ignore-reload option)");
                 } else
 #endif
                 {
-                    if (cc->maxAge() == 0) {
-                        debugs(22, 3, "refreshCheck: YES: client-max-age = 0");
-                        return STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE;
-                    }
-
-                    if (age > cc->maxAge()) {
-                        debugs(22, 3, "refreshCheck: YES: age > client-max-age");
+                    // Honour client "Cache-Control: max-age=x" header
+                    if (age > cc->maxAge() || cc->maxAge() == 0) {
+                        debugs(22, 3, "YES: Revalidating object - client 'Cache-Control: max-age=" << cc->maxAge() << "'");
                         return STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE;
                     }
                 }
             }
 
+            // max-stale directive
             if (cc->hasMaxStale() && staleness > -1) {
                 if (cc->maxStale()==HttpHdrCc::MAX_STALE_ANY) {
-                    /* max-stale directive without a value */
-                    debugs(22, 3, "refreshCheck: NO: max-stale wildcard");
+                    debugs(22, 3, "NO: Client accepts a stale response of any age - 'Cache-Control: max-stale'");
                     return FRESH_REQUEST_MAX_STALE_ALL;
                 } else if (staleness < cc->maxStale()) {
-                    debugs(22, 3, "refreshCheck: NO: staleness < max-stale");
+                    debugs(22, 3, "NO: Client accepts a stale response - 'Cache-Control: max-stale=" << cc->maxStale() << "'");
                     return FRESH_REQUEST_MAX_STALE_VALUE;
                 }
             }
         }
     }
 
+    // If the object is fresh, return the right FRESH_ code
     if (-1 == staleness) {
-        debugs(22, 3, "refreshCheck: object isn't stale..");
+        debugs(22, 3, "Object isn't stale..");
         if (sf.expires) {
-            debugs(22, 3, "refreshCheck: returning FRESH_EXPIRES");
+            debugs(22, 3, "returning FRESH_EXPIRES");
             return FRESH_EXPIRES;
         }
 
         assert(!sf.max);
 
         if (sf.lmfactor) {
-            debugs(22, 3, "refreshCheck: returning FRESH_LMFACTOR_RULE");
+            debugs(22, 3, "returning FRESH_LMFACTOR_RULE");
             return FRESH_LMFACTOR_RULE;
         }
 
         assert(sf.min);
 
-        debugs(22, 3, "refreshCheck: returning FRESH_MIN_RULE");
+        debugs(22, 3, "returning FRESH_MIN_RULE");
         return FRESH_MIN_RULE;
     }
 
@@ -396,7 +509,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
      */
     int max_stale = (R->max_stale >= 0 ? R->max_stale : Config.maxStale);
     if ( max_stale >= 0 && staleness > max_stale) {
-        debugs(22, 3, "refreshCheck: YES: max-stale limit");
+        debugs(22, 3, "YES: refresh_pattern max-stale=N limit from squid.conf");
         if (request)
             request->flags.failOnValidationError = true;
         return STALE_MAX_STALE;
@@ -406,7 +519,7 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 #if USE_HTTP_VIOLATIONS
 
         if (R->flags.override_expire && age < R->min) {
-            debugs(22, 3, "refreshCheck: NO: age < min && override-expire");
+            debugs(22, 3, "NO: Serving from cache - even though explicit expiry has passed, we enforce Min value (override-expire option)");
             return FRESH_OVERRIDE_EXPIRES;
         }
 
@@ -419,21 +532,30 @@ refreshCheck(const StoreEntry * entry, HttpRequest * request, time_t delta)
 
     if (sf.lmfactor) {
 #if USE_HTTP_VIOLATIONS
-
         if (R->flags.override_lastmod && age < R->min) {
-            debugs(22, 3, "refreshCheck: NO: age < min && override-lastmod");
+            debugs(22, 3, "NO: Serving from cache - even though L-M factor says the object is stale, we enforce Min value (override-lastmod option)");
             return FRESH_OVERRIDE_LASTMOD;
         }
-
 #endif
+        debugs(22, 3, "YES: L-M factor says the object is stale'");
         return STALE_LMFACTOR_RULE;
     }
 
-    debugs(22, 3, "refreshCheck: returning STALE_DEFAULT");
+    debugs(22, 3, "returning STALE_DEFAULT");
     return STALE_DEFAULT;
 }
 
-int
+/**
+ * This is called by http.cc once it has received and parsed the origin server's
+ * response headers. It uses the result as part of its algorithm to decide whether a
+ * response should be cached.
+ *
+ * \retval true if the entry is cacheable, regardless of whether FRESH or STALE
+ * \retval false if the entry is not cacheable
+ *
+ * TODO: this algorithm seems a bit odd and might not be quite right. Verify against HTTPbis.
+ */
+bool
 refreshIsCachable(const StoreEntry * entry)
 {
     /*
@@ -449,26 +571,26 @@ refreshIsCachable(const StoreEntry * entry)
 
     if (reason < STALE_MUST_REVALIDATE)
         /* Does not need refresh. This is certainly cachable */
-        return 1;
+        return true;
 
     if (entry->lastmod < 0)
         /* Last modified is needed to do a refresh */
-        return 0;
+        return false;
 
     if (entry->mem_obj == NULL)
         /* no mem_obj? */
-        return 1;
+        return true;
 
     if (entry->getReply() == NULL)
         /* no reply? */
-        return 1;
+        return true;
 
     if (entry->getReply()->content_length == 0)
         /* No use refreshing (caching?) 0 byte objects */
-        return 0;
+        return false;
 
     /* This seems to be refreshable. Cache it */
-    return 1;
+    return true;
 }
 
 /// whether reply is stale if it is a hit
@@ -485,9 +607,14 @@ refreshIsStaleIfHit(const int reason)
     }
 }
 
-/* refreshCheck... functions below are protocol-specific wrappers around
- * refreshCheck() function above */
-
+/**
+ * Protocol-specific wrapper around refreshCheck() function.
+ *
+ * Note the reason for STALE/FRESH then return true/false respectively.
+ *
+ * \retval 1 if STALE
+ * \retval 0 if FRESH
+ */
 int
 refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
 {
@@ -498,6 +625,7 @@ refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
     return (Config.onoff.offline || reason < 200) ? 0 : 1;
 }
 
+/// \see int refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
 int
 refreshCheckICP(const StoreEntry * entry, HttpRequest * request)
 {
@@ -508,6 +636,7 @@ refreshCheckICP(const StoreEntry * entry, HttpRequest * request)
 }
 
 #if USE_HTCP
+/// \see int refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
 int
 refreshCheckHTCP(const StoreEntry * entry, HttpRequest * request)
 {
@@ -520,6 +649,7 @@ refreshCheckHTCP(const StoreEntry * entry, HttpRequest * request)
 #endif
 
 #if USE_CACHE_DIGESTS
+/// \see int refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
 int
 refreshCheckDigest(const StoreEntry * entry, time_t delta)
 {
@@ -530,9 +660,18 @@ refreshCheckDigest(const StoreEntry * entry, time_t delta)
     ++ refreshCounts[rcCDigest].status[reason];
     return (reason < 200) ? 0 : 1;
 }
-
 #endif
 
+/**
+ * Get the configured maximum caching time for objects with this URL
+ * according to refresh_pattern.
+ *
+ * Used by http.cc when generating a upstream requests to ensure that
+ * responses it is given are fresh enough to be worth caching.
+ *
+ * \retval pattern-max if there is a refresh_pattern matching the URL configured.
+ * \retval REFRESH_DEFAULT_MAX if there are no explicit limits configured
+ */
 time_t
 getMaxAge(const char *url)
 {
@@ -545,57 +684,40 @@ getMaxAge(const char *url)
         return REFRESH_DEFAULT_MAX;
 }
 
-static void
+static int
+refreshCountsStatsEntry(StoreEntry * sentry, struct RefreshCounts &rc, int code, const char *desc)
+{
+    storeAppendPrintf(sentry, "%6d\t%6.2f\t%s\n", rc.status[code], xpercent(rc.status[code], rc.total), desc);
+    return rc.status[code];
+}
 
-refreshCountsStats(StoreEntry * sentry, struct RefreshCounts *rc)
+static void
+refreshCountsStats(StoreEntry * sentry, struct RefreshCounts &rc)
 {
-    int sum = 0;
-    int tot = rc->total;
+    if (!rc.total)
+        return;
 
-    storeAppendPrintf(sentry, "\n\n%s histogram:\n", rc->proto);
+    storeAppendPrintf(sentry, "\n\n%s histogram:\n", rc.proto);
     storeAppendPrintf(sentry, "Count\t%%Total\tCategory\n");
 
-#define refreshCountsStatsEntry(code,desc) { \
-	storeAppendPrintf(sentry, "%6d\t%6.2f\t%s\n", \
-	    rc->status[code], xpercent(rc->status[code], tot), desc); \
-    sum += rc->status[code]; \
-}
-
-    refreshCountsStatsEntry(FRESH_REQUEST_MAX_STALE_ALL,
-                            "Fresh: request max-stale wildcard");
-    refreshCountsStatsEntry(FRESH_REQUEST_MAX_STALE_VALUE,
-                            "Fresh: request max-stale value");
-    refreshCountsStatsEntry(FRESH_EXPIRES,
-                            "Fresh: expires time not reached");
-    refreshCountsStatsEntry(FRESH_LMFACTOR_RULE,
-                            "Fresh: refresh_pattern last-mod factor percentage");
-    refreshCountsStatsEntry(FRESH_MIN_RULE,
-                            "Fresh: refresh_pattern min value");
-    refreshCountsStatsEntry(FRESH_OVERRIDE_EXPIRES,
-                            "Fresh: refresh_pattern override expires");
-    refreshCountsStatsEntry(FRESH_OVERRIDE_LASTMOD,
-                            "Fresh: refresh_pattern override lastmod");
-    refreshCountsStatsEntry(STALE_MUST_REVALIDATE,
-                            "Stale: response has must-revalidate");
-    refreshCountsStatsEntry(STALE_RELOAD_INTO_IMS,
-                            "Stale: changed reload into IMS");
-    refreshCountsStatsEntry(STALE_FORCED_RELOAD,
-                            "Stale: request has no-cache directive");
-    refreshCountsStatsEntry(STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE,
-                            "Stale: age exceeds request max-age value");
-    refreshCountsStatsEntry(STALE_EXPIRES,
-                            "Stale: expires time reached");
-    refreshCountsStatsEntry(STALE_MAX_RULE,
-                            "Stale: refresh_pattern max age rule");
-    refreshCountsStatsEntry(STALE_LMFACTOR_RULE,
-                            "Stale: refresh_pattern last-mod factor percentage");
-    refreshCountsStatsEntry(STALE_DEFAULT,
-                            "Stale: by default");
-
-    tot = sum;			/* paranoid: "total" line shows 100% if we forgot nothing */
-    storeAppendPrintf(sentry, "%6d\t%6.2f\tTOTAL\n",
-                      rc->total, xpercent(rc->total, tot));
-    \
+    int sum = 0;
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_REQUEST_MAX_STALE_ALL, "Fresh: request max-stale wildcard");
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_REQUEST_MAX_STALE_VALUE, "Fresh: request max-stale value");
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_EXPIRES, "Fresh: expires time not reached");
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_LMFACTOR_RULE, "Fresh: refresh_pattern last-mod factor percentage");
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_MIN_RULE, "Fresh: refresh_pattern min value");
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_OVERRIDE_EXPIRES, "Fresh: refresh_pattern override-expires");
+    sum += refreshCountsStatsEntry(sentry, rc, FRESH_OVERRIDE_LASTMOD, "Fresh: refresh_pattern override-lastmod");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_MUST_REVALIDATE, "Stale: response has must-revalidate");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_RELOAD_INTO_IMS, "Stale: changed reload into IMS");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_FORCED_RELOAD, "Stale: request has no-cache directive");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_EXCEEDS_REQUEST_MAX_AGE_VALUE, "Stale: age exceeds request max-age value");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_EXPIRES, "Stale: expires time reached");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_MAX_RULE, "Stale: refresh_pattern max age rule");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_LMFACTOR_RULE, "Stale: refresh_pattern last-mod factor percentage");
+    sum += refreshCountsStatsEntry(sentry, rc, STALE_DEFAULT, "Stale: by default");
+
+    storeAppendPrintf(sentry, "%6d\t%6.2f\tTOTAL\n", rc.total, xpercent(rc.total, sum));
     storeAppendPrintf(sentry, "\n");
 }
 
@@ -625,7 +747,7 @@ refreshStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "\n\nRefreshCheck histograms for various protocols\n");
 
     for (i = 0; i < rcCount; ++i)
-        refreshCountsStats(sentry, &refreshCounts[i]);
+        refreshCountsStats(sentry, refreshCounts[i]);
 }
 
 static void
@@ -36,7 +36,7 @@
 class RefreshPattern;
 
 void refreshAddToList(const char *, int, time_t, int, time_t);
-int refreshIsCachable(const StoreEntry *);
+bool refreshIsCachable(const StoreEntry *);
 int refreshCheckHTTP(const StoreEntry *, HttpRequest *);
 int refreshCheckICP(const StoreEntry *, HttpRequest *);
 int refreshCheckHTCP(const StoreEntry *, HttpRequest *);
@@ -221,7 +221,7 @@ heap_purgeNext(RemovalPurgeWalker * walker)
 
 try_again:
 
-    if (!heap_nodes(h->theHeap) > 0)
+    if (heap_empty(h->theHeap))
         return NULL;		/* done */
 
     age = heap_peepminkey(h->theHeap);
@@ -101,5 +101,5 @@ Snmp::SendResponse(unsigned int requestId, const Pdu& pdu)
     }
     Ipc::TypedMsgHdr message;
     response.pack(message);
-    Ipc::SendMessage(Ipc::coordinatorAddr, message);
+    Ipc::SendMessage(Ipc::Port::CoordinatorAddr(), message);
 }
@@ -59,7 +59,7 @@ static mib_tree_entry * snmpAddNodeStr(const char *base_str, int o, oid_ParseFn
 static mib_tree_entry *snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, instance_Fn * instancefunction, AggrType aggrType, int children,...);
 static oid *snmpCreateOid(int length,...);
 mib_tree_entry * snmpLookupNodeStr(mib_tree_entry *entry, const char *str);
-int snmpCreateOidFromStr(const char *str, oid **name, int *nl);
+bool snmpCreateOidFromStr(const char *str, oid **name, int *nl);
 SQUIDCEXTERN void (*snmplib_debug_hook) (int, char *);
 static oid *static_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static oid *time_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
@@ -951,26 +951,29 @@ snmpLookupNodeStr(mib_tree_entry *root, const char *str)
     return e;
 }
 
-int
+bool
 snmpCreateOidFromStr(const char *str, oid **name, int *nl)
 {
     char const *delim = ".";
-    char *p;
 
     *name = NULL;
     *nl = 0;
-    char *s = xstrdup(str);
-    char *s_ = s;
+    const char *s = str;
 
     /* Parse the OID string into oid bits */
-    while ( (p = strsep(&s_, delim)) != NULL) {
+    while (size_t len = strcspn(s, delim)) {
         *name = (oid*)xrealloc(*name, sizeof(oid) * ((*nl) + 1));
-        (*name)[*nl] = atoi(p);
+        (*name)[*nl] = atoi(s); // stops at the '.' delimiter
         ++(*nl);
+        // exit with true when the last octet has been parsed
+        if (s[len] == '\0')
+            return true;
+        s += len+1;
     }
 
-    xfree(s);
-    return 1;
+    // if we aborted before the lst octet was found, return false.
+    safe_free(name);
+    return false;
 }
 
 /*
@@ -5,10 +5,10 @@ Ssl::Config Ssl::TheConfig;
 
 Ssl::Config::Config():
 #if USE_SSL_CRTD
-            ssl_crtd(NULL),
+        ssl_crtd(NULL),
 #endif
-            ssl_crt_validator(NULL)
-{ 
+        ssl_crt_validator(NULL)
+{
     ssl_crt_validator_Children.concurrency = 1;
 }
 
@@ -1,12 +1,10 @@
-/*
- */
-
 #ifndef SQUID_SSL_CERT_VALIDATE_MESSAGE_H
 #define SQUID_SSL_CERT_VALIDATE_MESSAGE_H
 
 #include "HelperReply.h"
 #include "ssl/crtd_message.h"
 #include "ssl/support.h"
+
 #include <vector>
 
 namespace Ssl
@@ -41,7 +39,7 @@ class CertValidationResponse
     public:
         RecvdError(): id(0), error_no(SSL_ERROR_NONE), cert(NULL) {}
         RecvdError(const RecvdError &);
-        RecvdError & operator = (const RecvdError &);
+        RecvdError & operator =(const RecvdError &);
         void setCert(X509 *);  ///< Sets cert to the given certificate
         int id; ///<  The id of the error
         ssl_error_t error_no; ///< The OpenSSL error code
@@ -62,9 +60,9 @@ class CertValidationResponse
  * This class is responsible for composing or parsing messages destined to
  * or comming from a cert validator helper.
  * The messages format is:
- *   <response/request code> <whitespace> <body length> <whitespace> <key=value> ...\1
+ *   response/request-code SP body-length SP [key=value ...] \x01
  */
-class CertValidationMsg: public CrtdMessage
+class CertValidationMsg : public CrtdMessage
 {
 private:
     /**
@@ -78,7 +76,7 @@ class CertValidationMsg: public CrtdMessage
         X509_Pointer cert;       ///< A pointer to certificate
         CertItem(): cert(NULL) {}
         CertItem(const CertItem &);
-        CertItem & operator = (const CertItem &);
+        CertItem & operator =(const CertItem &);
         void setCert(X509 *); ///< Sets cert to the given certificate
     };
 
@@ -110,4 +108,5 @@ class CertValidationMsg: public CrtdMessage
 };
 
 }//namespace Ssl
+
 #endif // SQUID_SSL_CERT_VALIDATE_MESSAGE_H
@@ -15,7 +15,7 @@ class CertificateProperties;
 /**
  * This class is responsible for composing and parsing messages destined to, or comming
  * from an ssl_crtd server. Format of these mesages is:
- *   <response/request code> <whitespace> <body length> <whitespace> <body>
+ *   response/request-code SP body length SP body
  */
 class CrtdMessage
 {
@@ -98,4 +98,5 @@ class CrtdMessage
 };
 
 } //namespace Ssl
+
 #endif // SQUID_SSL_CRTD_MESSAGE_H
@@ -42,7 +42,9 @@
 #include "anyp/PortCfg.h"
 #include "fde.h"
 #include "globals.h"
+#include "ipc/MemMap.h"
 #include "SquidConfig.h"
+#include "SquidTime.h"
 #include "ssl/Config.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/gadgets.h"
@@ -53,6 +55,10 @@
 #include <errno.h>
 #endif
 
+static void setSessionCallbacks(SSL_CTX *ctx);
+Ipc::MemMap *SslSessionCache = NULL;
+const char *SslSessionCacheName = "ssl_session_cache";
+
 const char *Ssl::BumpModeStr[] = {
     "none",
     "client-first",
@@ -733,7 +739,6 @@ ssl_initialize(void)
         }
 
 #endif
-
     }
 
     ssl_ex_index_server = SSL_get_ex_new_index(0, (void *) "server", NULL, NULL, NULL);
@@ -914,6 +919,8 @@ configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
     if (port.sslContextFlags & SSL_FLAG_DONT_VERIFY_DOMAIN)
         SSL_CTX_set_ex_data(sslContext, ssl_ctx_ex_index_dont_verify_domain, (void *) -1);
 
+    setSessionCallbacks(sslContext);
+
     return true;
 }
 
@@ -1673,4 +1680,198 @@ Ssl::CertError::operator != (const CertError &ce) const
     return code != ce.code || cert.get() != ce.cert.get();
 }
 
+static int
+store_session_cb(SSL *ssl, SSL_SESSION *session)
+{
+    if (!SslSessionCache)
+        return 0;
+
+    debugs(83, 5, "Request to store SSL Session ");
+
+    SSL_SESSION_set_timeout(session, Config.SSL.session_ttl);
+
+    unsigned char *id = session->session_id;
+    unsigned int idlen = session->session_id_length;
+    unsigned char key[MEMMAP_SLOT_KEY_SIZE];
+    // Session ids are of size 32bytes. They should always fit to a
+    // MemMap::Slot::key
+    assert(idlen <= MEMMAP_SLOT_KEY_SIZE);
+    memset(key, 0, sizeof(key));
+    memcpy(key, id, idlen);
+    int pos;
+    Ipc::MemMap::Slot *slotW = SslSessionCache->openForWriting((const cache_key*)key, pos);
+    if (slotW) {
+        int lenRequired =  i2d_SSL_SESSION(session, NULL);
+        if (lenRequired <  MEMMAP_SLOT_DATA_SIZE) {
+            unsigned char *p = (unsigned char *)slotW->p;
+            lenRequired = i2d_SSL_SESSION(session, &p);
+            slotW->set(key, NULL, lenRequired, squid_curtime + Config.SSL.session_ttl);
+        }
+        SslSessionCache->closeForWriting(pos);
+        debugs(83, 5, "wrote an ssl session entry of size " << lenRequired << " at pos " << pos);
+    }
+    return 0;
+}
+
+static void
+remove_session_cb(SSL_CTX *, SSL_SESSION *sessionID)
+{
+    if (!SslSessionCache)
+        return ;
+
+    debugs(83, 5, "Request to remove corrupted or not valid SSL Session ");
+    int pos;
+    Ipc::MemMap::Slot const *slot = SslSessionCache->openForReading((const cache_key*)sessionID, pos);
+    if (slot == NULL)
+        return;
+    SslSessionCache->closeForReading(pos);
+    // TODO:
+    // What if we are not able to remove the session?
+    // Maybe schedule a job to remove it later?
+    // For now we just have an invalid entry in cache until will be expired
+    // The openSSL will reject it when we try to use it
+    SslSessionCache->free(pos);
+}
+
+static SSL_SESSION *
+get_session_cb(SSL *, unsigned char *sessionID, int len, int *copy)
+{
+    if (!SslSessionCache)
+        return NULL;
+
+    SSL_SESSION *session = NULL;
+    const unsigned int *p;
+    p = (unsigned int *)sessionID;
+    debugs(83, 5, "Request to search for SSL Session of len:" <<
+           len << p[0] << ":" << p[1]);
+
+    int pos;
+    Ipc::MemMap::Slot const *slot = SslSessionCache->openForReading((const cache_key*)sessionID, pos);
+    if (slot != NULL) {
+        if (slot->expire > squid_curtime) {
+            const unsigned char *ptr = slot->p;
+            session = d2i_SSL_SESSION(NULL, &ptr, slot->pSize);
+            debugs(83, 5, "Session retrieved from cache at pos " << pos);
+        } else
+            debugs(83, 5, "Session in cache expired");
+        SslSessionCache->closeForReading(pos);
+    }
+
+    if (!session)
+        debugs(83, 5, "Failed to retrieved from cache\n");
+
+    // With the parameter copy the callback can require the SSL engine
+    // to increment the reference count of the SSL_SESSION object, Normally
+    // the reference count is not incremented and therefore the session must
+    // not be explicitly freed with SSL_SESSION_free(3).
+    *copy = 0;
+    return session;
+}
+
+static void
+setSessionCallbacks(SSL_CTX *ctx)
+{
+    if (SslSessionCache) {
+        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER|SSL_SESS_CACHE_NO_INTERNAL);
+        SSL_CTX_sess_set_new_cb(ctx, store_session_cb);
+        SSL_CTX_sess_set_remove_cb(ctx, remove_session_cb);
+        SSL_CTX_sess_set_get_cb(ctx, get_session_cb);
+    }
+}
+
+static bool
+isSslServer()
+{
+    if (Config.Sockaddr.https)
+        return true;
+
+    for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->flags.tunnelSslBumping)
+            return true;
+    }
+
+    return false;
+}
+
+#define SSL_SESSION_ID_SIZE 32
+#define SSL_SESSION_MAX_SIZE 10*1024
+
+void
+Ssl::initialize_session_cache()
+{
+
+    if (!isSslServer()) //no need to configure ssl session cache.
+        return;
+
+    // Check if the MemMap keys and data are enough big to hold
+    // session ids and session data
+    assert(SSL_SESSION_ID_SIZE >= MEMMAP_SLOT_KEY_SIZE);
+    assert(SSL_SESSION_MAX_SIZE >= MEMMAP_SLOT_DATA_SIZE);
+
+    int configuredItems = ::Config.SSL.sessionCacheSize / sizeof(Ipc::MemMap::Slot);
+    if (IamWorkerProcess() && configuredItems)
+        SslSessionCache = new Ipc::MemMap(SslSessionCacheName);
+    else {
+        SslSessionCache = NULL;
+        return;
+    }
+
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.https; s; s = s->next) {
+        if (s->staticSslContext.get() != NULL)
+            setSessionCallbacks(s->staticSslContext.get());
+    }
+
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; s; s = s->next) {
+        if (s->staticSslContext.get() != NULL)
+            setSessionCallbacks(s->staticSslContext.get());
+    }
+}
+
+void
+destruct_session_cache()
+{
+    delete SslSessionCache;
+}
+
+/// initializes shared memory segments used by MemStore
+class SharedSessionCacheRr: public Ipc::Mem::RegisteredRunner
+{
+public:
+    /* RegisteredRunner API */
+    SharedSessionCacheRr(): owner(NULL) {}
+    virtual void run(const RunnerRegistry &);
+    virtual ~SharedSessionCacheRr();
+
+protected:
+    virtual void create(const RunnerRegistry &);
+
+private:
+    Ipc::MemMap::Owner *owner;
+};
+
+RunnerRegistrationEntry(rrAfterConfig, SharedSessionCacheRr);
+
+void
+SharedSessionCacheRr::run(const RunnerRegistry &r)
+{
+    Ipc::Mem::RegisteredRunner::run(r);
+}
+
+void
+SharedSessionCacheRr::create(const RunnerRegistry &)
+{
+    if (!isSslServer()) //no need to configure ssl session cache.
+        return;
+
+    int items;
+    items = Config.SSL.sessionCacheSize / sizeof(Ipc::MemMap::Slot);
+    if (items)
+        owner =  Ipc::MemMap::Init(SslSessionCacheName, items);
+}
+
+SharedSessionCacheRr::~SharedSessionCacheRr()
+{
+    delete owner;
+}
+
 #endif /* USE_SSL */
@@ -277,6 +277,18 @@ int asn1timeToString(ASN1_TIME *tm, char *buf, int len);
    \return true if SNI set false otherwise
 */
 bool setClientSNI(SSL *ssl, const char *fqdn);
+
+/**
+   \ingroup ServerProtocolSSLAPI
+   * Initializes the shared session cache if configured
+*/
+void initialize_session_cache();
+
+/**
+   \ingroup ServerProtocolSSLAPI
+   * Destroy the shared session cache if configured
+*/
+void destruct_session_cache();
 } //namespace Ssl
 
 #if _SQUID_WINDOWS_
@@ -675,10 +675,12 @@ DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
 #if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
         storeAppendPrintf(sentry,"\nRunning as %s Windows System Service on %s\n",
-                          WIN32_Service_name, WIN32_OS_string);
+                          Service_name, WIN32_OS_string);
         storeAppendPrintf(sentry,"Service command line is: %s\n", WIN32_Service_Command_Line);
     } else
         storeAppendPrintf(sentry,"Running on %s\n",WIN32_OS_string);
+#else
+    storeAppendPrintf(sentry,"Service Name: %s\n", service_name);
 #endif
 
     storeAppendPrintf(sentry, "Start Time:\t%s\n",
@@ -51,7 +51,6 @@
 #include "RequestFlags.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
-#include "Stack.h"
 #include "StatCounters.h"
 #include "stmem.h"
 #include "Store.h"
@@ -74,6 +73,8 @@
 #include <limits.h>
 #endif
 
+#include <stack>
+
 #define REBUILD_TIMESTAMP_DELTA_MAX 2
 
 #define STORE_IN_MEM_BUCKETS            (229)
@@ -125,7 +126,7 @@ static EVH storeLateRelease;
 /*
  * local variables
  */
-static Stack<StoreEntry*> LateReleaseStack;
+static std::stack<StoreEntry*> LateReleaseStack;
 MemAllocator *StoreEntry::pool = NULL;
 
 StorePointer Store::CurrentRoot = NULL;
@@ -1253,7 +1254,7 @@ StoreEntry::release()
             // lock the entry until rebuilding is done
             lock("storeLateRelease");
             setReleaseFlag();
-            LateReleaseStack.push_back(this);
+            LateReleaseStack.push(this);
         } else {
             destroyStoreEntry(static_cast<hash_link *>(this));
             // "this" is no longer valid
@@ -1281,21 +1282,21 @@ static void
 storeLateRelease(void *unused)
 {
     StoreEntry *e;
-    int i;
     static int n = 0;
 
     if (StoreController::store_dirs_rebuilding) {
         eventAdd("storeLateRelease", storeLateRelease, NULL, 1.0, 1);
         return;
     }
 
-    for (i = 0; i < 10; ++i) {
-        e = LateReleaseStack.count ? LateReleaseStack.pop() : NULL;
-
-        if (e == NULL) {
-            /* done! */
+    // TODO: this works but looks unelegant.
+    for (int i = 0; i < 10; ++i) {
+        if (LateReleaseStack.empty()) {
             debugs(20, DBG_IMPORTANT, "storeLateRelease: released " << n << " objects");
             return;
+        } else {
+            e = LateReleaseStack.top();
+            LateReleaseStack.pop();
         }
 
         e->unlock("storeLateRelease");
@@ -132,18 +132,19 @@ storeClientListAdd(StoreEntry * e, void *data)
 void
 store_client::callback(ssize_t sz, bool error)
 {
-    StoreIOBuffer result(sz, 0 ,copyInto.data);
+    size_t bSz = 0;
 
-    if (sz < 0) {
+    if (sz >= 0 && !error)
+        bSz = sz;
+
+    StoreIOBuffer result(bSz, 0 ,copyInto.data);
+
+    if (sz < 0 || error)
         result.flags.error = 1;
-        result.length = 0;
-    } else {
-        result.flags.error = error ? 1 : 0;
-    }
 
     result.offset = cmp_offset;
     assert(_callback.pending());
-    cmp_offset = copyInto.offset + sz;
+    cmp_offset = copyInto.offset + bSz;
     STCB *temphandler = _callback.callback_handler;
     void *cbdata = _callback.callback_data;
     _callback = Callback(NULL, NULL);
@@ -1370,7 +1370,7 @@ StoreSearchHashIndex::next(void (aCallback)(void *), void *aCallbackData)
 bool
 StoreSearchHashIndex::next()
 {
-    if (entries.size())
+    if (!entries.empty())
         entries.pop_back();
 
     while (!isDone() && !entries.size())
@@ -1,16 +1,19 @@
 STUB_SOURCE= tests/STUB.h \
 	tests/stub_CacheDigest.cc \
+	tests/stub_CollapsedForwarding.cc \
 	tests/stub_CommIO.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_ETag.cc \
+	tests/stub_EventLoop.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_HttpReply.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_MemBuf.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_Port.cc \
+	tests/stub_SBufDetailedStats.cc \
 	tests/stub_StatHist.cc \
 	tests/stub_StoreMeta.cc \
 	tests/stub_SwapDir.cc \
@@ -4,10 +4,13 @@
 #include "tests/STUB.h"
 
 #include "DiskIO/DiskIOModule.h"
+
+#include <vector>
+
 void DiskIOModule::SetupAllModules() STUB
 void DiskIOModule::ModuleAdd(DiskIOModule &) STUB
 void DiskIOModule::FreeAllModules() STUB
 void DiskIOModule::PokeAllModules() STUB
 DiskIOModule *DiskIOModule::Find(char const *) STUB_RETVAL(NULL)
 DiskIOModule *DiskIOModule::FindDefault() STUB_RETVAL(NULL)
-Vector<DiskIOModule*> const &DiskIOModule::Modules() STUB_RETSTATREF(Vector<DiskIOModule*>)
+std::vector<DiskIOModule*> const &DiskIOModule::Modules() STUB_RETSTATREF(std::vector<DiskIOModule*>)
@@ -10,4 +10,4 @@ EventLoop::EventLoop(): errcount(0), last_loop(false), timeService(NULL),
         primaryEngine(NULL), loop_delay(0), error(false), runOnceResult(false)
         STUB_NOP
 
-void EventLoop::registerEngine(AsyncEngine *engine) STUB
+        void EventLoop::registerEngine(AsyncEngine *engine) STUB
@@ -4,7 +4,7 @@
 #define STUB_API "ipc/Port.cc"
 #include "tests/STUB.h"
 
-const char Ipc::coordinatorAddr[] = "";
-const char Ipc::strandAddrPfx[] = "";
+const char Ipc::strandAddrLabel[] = "-kid";
 
 String Ipc::Port::MakeAddr(char const*, int) STUB_RETVAL("")
+String Ipc::Port::CoordinatorAddr() STUB_RETVAL("")
@@ -21,10 +21,11 @@ AuthUserHashPointer::AuthUserHashPointer(Auth::User::Pointer anAuth_user) STUB
 Auth::User::Pointer AuthUserHashPointer::user() const STUB_RETVAL(NULL)
 
 #include "auth/Scheme.h"
-Vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
+#include <vector>
+std::vector<Auth::Scheme::Pointer> *Auth::Scheme::_Schemes = NULL;
 void Auth::Scheme::AddScheme(Auth::Scheme::Pointer) STUB
 Auth::Scheme::Pointer Auth::Scheme::Find(const char *) STUB_RETVAL(NULL)
-Vector<Auth::Scheme::Pointer> & Auth::Scheme::GetSchemes() STUB_RETVAL(*_Schemes);
+std::vector<Auth::Scheme::Pointer> & Auth::Scheme::GetSchemes() STUB_RETVAL(*_Schemes);
 void Auth::Scheme::FreeAll() STUB
 
 #include "auth/User.h"
@@ -12,9 +12,9 @@
 #include "ssl/Config.h"
 Ssl::Config::Config():
 #if USE_SSL_CRTD
-            ssl_crtd(NULL),
+        ssl_crtd(NULL),
 #endif
-            ssl_crt_validator(NULL)
+        ssl_crt_validator(NULL)
 {
     ssl_crt_validator_Children.concurrency = 1;
     STUB_NOP
@@ -41,12 +41,13 @@ testACLMaxUserIP::testParseLine()
     ACL::ParseAclLine(LegacyParser, &anACL);
     ACLMaxUserIP *maxUserIpACL = dynamic_cast<ACLMaxUserIP *>(anACL);
     CPPUNIT_ASSERT(maxUserIpACL);
-
-    /* we want a maximum of one, and strict to be true */
-    CPPUNIT_ASSERT_EQUAL(1, maxUserIpACL->getMaximum());
-    CPPUNIT_ASSERT_EQUAL(true, maxUserIpACL->getStrict());
-    /* the acl must be vaid */
-    CPPUNIT_ASSERT_EQUAL(true, maxUserIpACL->valid());
+    if (maxUserIpACL) {
+        /* we want a maximum of one, and strict to be true */
+        CPPUNIT_ASSERT_EQUAL(1, maxUserIpACL->getMaximum());
+        CPPUNIT_ASSERT_EQUAL(true, maxUserIpACL->getStrict());
+        /* the acl must be vaid */
+        CPPUNIT_ASSERT_EQUAL(true, maxUserIpACL->valid());
+    }
     delete anACL;
     xfree(line);
 }
@@ -117,17 +117,13 @@ testRock::commonInit()
     StoreFileSystem::SetupAllFs();
 
     Config.Store.avgObjectSize = 1024;
-
     Config.Store.objectsPerBucket = 20;
-
     Config.Store.maxObjectSize = 2048;
 
     Config.store_dir_select_algorithm = xstrdup("round-robin");
 
     Config.replPolicy = new RemovalPolicySettings;
-
-    Config.replPolicy->type = xstrdup ("lru");
-
+    Config.replPolicy->type = xstrdup("lru");
     Config.replPolicy->args = NULL;
 
     /* garh garh */
@@ -799,7 +799,6 @@ testSBuf::testFindFirstNotOf()
     CPPUNIT_ASSERT_EQUAL(3U,idx);
 }
 
-
 void
 testSBuf::testAutoFind()
 {
@@ -22,17 +22,17 @@ testURL::setUp()
 }
 
 /*
- * we can construct a URL with a URLScheme.
+ * we can construct a URL with a AnyP::UriScheme.
  * This creates a URL for that scheme.
  */
 void
 testURL::testConstructScheme()
 {
-    URLScheme empty_scheme;
+    AnyP::UriScheme empty_scheme;
     URL protoless_url(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(empty_scheme, protoless_url.getScheme());
 
-    URLScheme ftp_scheme(AnyP::PROTO_FTP);
+    AnyP::UriScheme ftp_scheme(AnyP::PROTO_FTP);
     URL ftp_url(AnyP::PROTO_FTP);
     CPPUNIT_ASSERT_EQUAL(ftp_scheme, ftp_url.getScheme());
 }
@@ -45,7 +45,7 @@ testURL::testConstructScheme()
 void
 testURL::testDefaultConstructor()
 {
-    URLScheme aScheme;
+    AnyP::UriScheme aScheme;
     URL aUrl;
     CPPUNIT_ASSERT_EQUAL(aScheme, aUrl.getScheme());
 
@@ -53,16 +53,13 @@ testUfs::commonInit()
         return;
 
     Config.Store.avgObjectSize = 1024;
-
     Config.Store.objectsPerBucket = 20;
-
     Config.Store.maxObjectSize = 2048;
 
     Config.store_dir_select_algorithm = xstrdup("round-robin");
 
     Config.replPolicy = new RemovalPolicySettings;
-
-    Config.replPolicy->type = xstrdup ("lru");
+    Config.replPolicy->type = xstrdup("lru");
 
     /* garh garh */
     storeReplAdd("lru", createRemovalPolicy_lru);
@@ -240,7 +237,7 @@ testUfs::testUfsDefaultEngine()
     addSwapDir(aStore);
     commonInit();
     Config.replPolicy = new RemovalPolicySettings;
-    Config.replPolicy->type = xstrdup ("lru");
+    Config.replPolicy->type = xstrdup("lru");
     mem_policy = createRemovalPolicy(Config.replPolicy);
 
     char *path=xstrdup(TESTDIR);
@@ -4,16 +4,16 @@
 
 #include <cppunit/TestAssert.h>
 
+#include "anyp/UriScheme.h"
 #include "Mem.h"
 #include "SquidString.h"
-#include "testURLScheme.h"
-#include "URLScheme.h"
+#include "tests/testUriScheme.h"
 
 #if HAVE_SSTREAM
 #include <sstream>
 #endif
 
-CPPUNIT_TEST_SUITE_REGISTRATION( testURLScheme );
+CPPUNIT_TEST_SUITE_REGISTRATION( testUriScheme );
 
 #if 0
 /*
@@ -47,58 +47,58 @@ testHttpRequestMethod::testConstructCharStartEnd()
 #endif
 
 /*
- * we should be able to assign a protocol_t to a URLScheme for ease
+ * we should be able to assign a protocol_t to a AnyP::UriScheme for ease
  * of code conversion
  */
 void
-testURLScheme::testAssignFromprotocol_t()
+testUriScheme::testAssignFromprotocol_t()
 {
-    URLScheme empty_scheme;
-    URLScheme scheme;
+    AnyP::UriScheme empty_scheme;
+    AnyP::UriScheme scheme;
     scheme = AnyP::PROTO_NONE;
     CPPUNIT_ASSERT_EQUAL(empty_scheme, scheme);
 
-    URLScheme https_scheme(AnyP::PROTO_HTTPS);
+    AnyP::UriScheme https_scheme(AnyP::PROTO_HTTPS);
     scheme = AnyP::PROTO_HTTPS;
     CPPUNIT_ASSERT_EQUAL(https_scheme, scheme);
 }
 
 /*
- * We should be able to get a protocol_t from a URLScheme for ease
+ * We should be able to get a protocol_t from a AnyP::UriScheme for ease
  * of migration
  */
 void
-testURLScheme::testCastToprotocol_t()
+testUriScheme::testCastToprotocol_t()
 {
     /* explicit cast */
-    AnyP::ProtocolType protocol = static_cast<AnyP::ProtocolType>(URLScheme());
+    AnyP::ProtocolType protocol = static_cast<AnyP::ProtocolType>(AnyP::UriScheme());
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, protocol);
     /* and implicit */
-    protocol = URLScheme(AnyP::PROTO_HTTP);
+    protocol = AnyP::UriScheme(AnyP::PROTO_HTTP);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, protocol);
 }
 
 /*
- * a default constructed URLScheme is == AnyP::PROTO_NONE
+ * a default constructed AnyP::UriScheme is == AnyP::PROTO_NONE
  */
 void
-testURLScheme::testDefaultConstructor()
+testUriScheme::testDefaultConstructor()
 {
-    URLScheme lhs;
-    URLScheme rhs(AnyP::PROTO_NONE);
+    AnyP::UriScheme lhs;
+    AnyP::UriScheme rhs(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
 
 /*
- * we should be able to construct a URLScheme from the old 'protocol_t' enum.
+ * we should be able to construct a AnyP::UriScheme from the old 'protocol_t' enum.
  */
 void
-testURLScheme::testConstructprotocol_t()
+testUriScheme::testConstructprotocol_t()
 {
-    URLScheme lhs_none(AnyP::PROTO_NONE), rhs_none(AnyP::PROTO_NONE);
+    AnyP::UriScheme lhs_none(AnyP::PROTO_NONE), rhs_none(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(lhs_none, rhs_none);
 
-    URLScheme lhs_cacheobj(AnyP::PROTO_CACHE_OBJECT), rhs_cacheobj(AnyP::PROTO_CACHE_OBJECT);
+    AnyP::UriScheme lhs_cacheobj(AnyP::PROTO_CACHE_OBJECT), rhs_cacheobj(AnyP::PROTO_CACHE_OBJECT);
     CPPUNIT_ASSERT_EQUAL(lhs_cacheobj, rhs_cacheobj);
     CPPUNIT_ASSERT(lhs_none != rhs_cacheobj);
 }
@@ -107,47 +107,47 @@ testURLScheme::testConstructprotocol_t()
  * we should be able to get a char const * version of the method.
  */
 void
-testURLScheme::testConst_str()
+testUriScheme::testC_str()
 {
     String lhs("wais");
-    URLScheme wais(AnyP::PROTO_WAIS);
-    String rhs(wais.const_str());
+    AnyP::UriScheme wais(AnyP::PROTO_WAIS);
+    String rhs(wais.c_str());
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
 
 /*
- * a URLScheme replaces protocol_t, so we should be able to test for equality on
+ * a AnyP::UriScheme replaces protocol_t, so we should be able to test for equality on
  * either the left or right hand side seamlessly.
  */
 void
-testURLScheme::testEqualprotocol_t()
+testUriScheme::testEqualprotocol_t()
 {
-    CPPUNIT_ASSERT(URLScheme() == AnyP::PROTO_NONE);
-    CPPUNIT_ASSERT(not (URLScheme(AnyP::PROTO_WAIS) == AnyP::PROTO_HTTP));
-    CPPUNIT_ASSERT(AnyP::PROTO_HTTP == URLScheme(AnyP::PROTO_HTTP));
-    CPPUNIT_ASSERT(not (AnyP::PROTO_CACHE_OBJECT == URLScheme(AnyP::PROTO_HTTP)));
+    CPPUNIT_ASSERT(AnyP::UriScheme() == AnyP::PROTO_NONE);
+    CPPUNIT_ASSERT(not (AnyP::UriScheme(AnyP::PROTO_WAIS) == AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(AnyP::PROTO_HTTP == AnyP::UriScheme(AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(not (AnyP::PROTO_CACHE_OBJECT == AnyP::UriScheme(AnyP::PROTO_HTTP)));
 }
 
 /*
- * a URLScheme should testable for inequality with a protocol_t.
+ * a AnyP::UriScheme should testable for inequality with a protocol_t.
  */
 void
-testURLScheme::testNotEqualprotocol_t()
+testUriScheme::testNotEqualprotocol_t()
 {
-    CPPUNIT_ASSERT(URLScheme(AnyP::PROTO_NONE) != AnyP::PROTO_HTTP);
-    CPPUNIT_ASSERT(not (URLScheme(AnyP::PROTO_HTTP) != AnyP::PROTO_HTTP));
-    CPPUNIT_ASSERT(AnyP::PROTO_NONE != URLScheme(AnyP::PROTO_HTTP));
-    CPPUNIT_ASSERT(not (AnyP::PROTO_WAIS != URLScheme(AnyP::PROTO_WAIS)));
+    CPPUNIT_ASSERT(AnyP::UriScheme(AnyP::PROTO_NONE) != AnyP::PROTO_HTTP);
+    CPPUNIT_ASSERT(not (AnyP::UriScheme(AnyP::PROTO_HTTP) != AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(AnyP::PROTO_NONE != AnyP::UriScheme(AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(not (AnyP::PROTO_WAIS != AnyP::UriScheme(AnyP::PROTO_WAIS)));
 }
 
 /*
  * we should be able to send it to a stream and get the normalised version
  */
 void
-testURLScheme::testStream()
+testUriScheme::testStream()
 {
     std::ostringstream buffer;
-    buffer << URLScheme(AnyP::PROTO_HTTP);
+    buffer << AnyP::UriScheme(AnyP::PROTO_HTTP);
     String http_str("http");
     String from_buf(buffer.str().c_str());
     CPPUNIT_ASSERT_EQUAL(http_str, from_buf);
@@ -1,16 +1,16 @@
 
-#ifndef SQUID_SRC_TEST_URL_SCHEME_H
-#define SQUID_SRC_TEST_URL_SCHEME_H
+#ifndef SQUID_SRC_TESTS_TESTURISCHEME_H
+#define SQUID_SRC_TESTS_TESTURISCHEME_H
 
 #include <cppunit/extensions/HelperMacros.h>
 
 /*
- * test URLScheme
+ * test UriScheme
  */
 
-class testURLScheme : public CPPUNIT_NS::TestFixture
+class testUriScheme : public CPPUNIT_NS::TestFixture
 {
-    CPPUNIT_TEST_SUITE( testURLScheme );
+    CPPUNIT_TEST_SUITE( testUriScheme );
     CPPUNIT_TEST( testAssignFromprotocol_t );
     CPPUNIT_TEST( testCastToprotocol_t );
     CPPUNIT_TEST( testConstructprotocol_t );
@@ -23,7 +23,7 @@ class testURLScheme : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testDefaultConstructor );
     CPPUNIT_TEST( testEqualprotocol_t );
     CPPUNIT_TEST( testNotEqualprotocol_t );
-    CPPUNIT_TEST( testConst_str );
+    CPPUNIT_TEST( testC_str );
     CPPUNIT_TEST( testStream );
     CPPUNIT_TEST_SUITE_END();
 
@@ -39,7 +39,7 @@ class testURLScheme : public CPPUNIT_NS::TestFixture
     void testConstructCharStartEnd();
 #endif
 
-    void testConst_str();
+    void testC_str();
     void testDefaultConstructor();
     void testEqualprotocol_t();
     void testNotEqualprotocol_t();
@@ -1,19 +0,0 @@
-#define SQUID_UNIT_TEST 1
-#include "squid.h"
-#include "base/Vector.h"
-#include "tests/testVector.h"
-
-#include <cppunit/TestAssert.h>
-
-CPPUNIT_TEST_SUITE_REGISTRATION( testVector );
-
-void testVector::all()
-{
-    CPPUNIT_ASSERT_EQUAL(1 ,  1);
-    Vector<int> aArray;
-    CPPUNIT_ASSERT_EQUAL(static_cast<size_t>(0), aArray.size());
-    aArray.push_back(2);
-    CPPUNIT_ASSERT_EQUAL(static_cast<size_t>(1), aArray.size());
-    CPPUNIT_ASSERT_EQUAL(2, aArray.back());
-    CPPUNIT_ASSERT_EQUAL(static_cast<size_t>(1), aArray.size());
-}
@@ -1,24 +0,0 @@
-#ifndef SQUID_SRC_TESTS_TESTVECTOR_H
-#define SQUID_SRC_TESTS_TESTVECTOR_H
-
-#include <cppunit/extensions/HelperMacros.h>
-
-/*
- * A test case that is designed to produce
- * example errors and failures
- *
- */
-
-class testVector : public CPPUNIT_NS::TestFixture
-{
-    CPPUNIT_TEST_SUITE( testVector );
-    CPPUNIT_TEST( all );
-    CPPUNIT_TEST_SUITE_END();
-
-public:
-
-protected:
-    void all();
-};
-
-#endif
@@ -86,7 +86,7 @@ testRangeParser(char const *rangestring)
 
     HttpHdrRange copy(*range);
 
-    assert (copy.specs.count == range->specs.count);
+    assert (copy.specs.size() == range->specs.size());
 
     HttpHdrRange::iterator pos = range->begin();
 
@@ -111,7 +111,7 @@ void
 testRangeIter ()
 {
     HttpHdrRange *range=rangeFromString("bytes=0-3, 1-, -2");
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
     size_t counter = 0;
     HttpHdrRange::iterator i = range->begin();
 
@@ -132,21 +132,21 @@ void
 testRangeCanonization()
 {
     HttpHdrRange *range=rangeFromString("bytes=0-3, 1-, -2");
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
 
     /* 0-3 needs a content length of 4 */
     /* This passes in the extant code - but should it? */
 
     if (!range->canonize(3))
         exit(1);
 
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
 
     delete range;
 
     range=rangeFromString("bytes=0-3, 1-, -2");
 
-    assert (range->specs.count == 3);
+    assert (range->specs.size() == 3);
 
     /* 0-3 needs a content length of 4 */
     if (!range->canonize(4))
@@ -156,7 +156,7 @@ testRangeCanonization()
 
     range=rangeFromString("bytes=3-6");
 
-    assert (range->specs.count == 1);
+    assert (range->specs.size() == 1);
 
     /* 3-6 needs a content length of 4 or more */
     if (range->canonize(3))
@@ -166,7 +166,7 @@ testRangeCanonization()
 
     range=rangeFromString("bytes=3-6");
 
-    assert (range->specs.count == 1);
+    assert (range->specs.size() == 1);
 
     /* 3-6 needs a content length of 4 or more */
     if (!range->canonize(4))
@@ -176,12 +176,12 @@ testRangeCanonization()
 
     range=rangeFromString("bytes=1-1,2-3");
 
-    assert (range->specs.count == 2);
+    assert (range->specs.size()== 2);
 
     if (!range->canonize(4))
         exit(1);
 
-    assert (range->specs.count == 2);
+    assert (range->specs.size() == 2);
 
     delete range;
 }
@@ -33,7 +33,6 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
-#include "base/Vector.h"
 #include "CachePeer.h"
 #include "client_side.h"
 #include "client_side_request.h"
@@ -238,7 +237,7 @@ TunnelStateData::~TunnelStateData()
     debugs(26, 3, "TunnelStateData destructed this=" << this);
     assert(noConnections());
     xfree(url);
-    serverDestinations.clean();
+    serverDestinations.clear();
     delete connectRespBuf;
 }
 
@@ -779,7 +778,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
         /* At this point only the TCP handshake has failed. no data has been passed.
          * we are allowed to re-try the TCP-level connection to alternate IPs for CONNECT.
          */
-        tunnelState->serverDestinations.shift();
+        tunnelState->serverDestinations.erase(tunnelState->serverDestinations.begin());
         if (status != COMM_TIMEOUT && tunnelState->serverDestinations.size() > 0) {
             /* Try another IP of this destination host */
 
@@ -38,7 +38,6 @@
 #include "SquidConfig.h"
 #include "SquidString.h"
 #include "URL.h"
-#include "URLScheme.h"
 
 static HttpRequest *urlParseFinish(const HttpRequestMethod& method,
                                    const AnyP::ProtocolType protocol,
@@ -515,9 +514,9 @@ urlCanonical(HttpRequest * request)
         if (request->port != urlDefaultPort(request->protocol))
             snprintf(portbuf, 32, ":%d", request->port);
 
-        const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
+        const AnyP::UriScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
         snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
-                 sch.const_str(),
+                 sch.c_str(),
                  request->login,
                  *request->login ? "@" : null_string,
                  request->GetHost(),
@@ -562,9 +561,9 @@ urlCanonicalClean(const HttpRequest * request)
             strcat(loginbuf, "@");
         }
 
-        const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
+        const AnyP::UriScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
         snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
-                 sch.const_str(),
+                 sch.c_str(),
                  loginbuf,
                  request->GetHost(),
                  portbuf,
@@ -662,18 +661,18 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 
     size_t urllen;
 
-    const URLScheme sch = req->protocol; // temporary, until bug 1961 URL handling is fixed.
+    const AnyP::UriScheme sch = req->protocol; // temporary, until bug 1961 URL handling is fixed.
     if (req->port != urlDefaultPort(req->protocol)) {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s:%d",
-                          sch.const_str(),
+                          sch.c_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost(),
                           req->port
                          );
     } else {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s",
-                          sch.const_str(),
+                          sch.c_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost()
@@ -980,9 +979,3 @@ URLHostName::extract(char const *aUrl)
 
     return Host;
 }
-
-URL::URL() : scheme()
-{}
-
-URL::URL(URLScheme const &aScheme): scheme(aScheme)
-{}
@@ -190,9 +190,9 @@ UrnState::createUriResRequest (String &uri)
     char *host = getHost (uri);
     snprintf(local_urlres, 4096, "http://%s/uri-res/N2L?urn:" SQUIDSTRINGPH,
              host, SQUIDSTRINGPRINT(uri));
-    safe_free (host);
-    safe_free (urlres);
-    urlres = xstrdup (local_urlres);
+    safe_free(host);
+    safe_free(urlres);
+    urlres = xstrdup(local_urlres);
     urlres_r = HttpRequest::CreateFromUrl(urlres);
 }
 
@@ -38,7 +38,6 @@
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
-#include "compat/strsep.h"
 #include "ConfigParser.h"
 #include "event.h"
 #include "ip/Address.h"
@@ -2207,82 +2206,72 @@ check_null_wccp2_service(void *v)
 static int
 parse_wccp2_service_flags(char *flags)
 {
-    char *tmp, *tmp2;
-    char *flag;
-    int retflag = 0;
-
-    if (!flags) {
+    if (!flags)
         return 0;
-    }
 
-    tmp = xstrdup(flags);
-    tmp2 = tmp;
+    char *flag = flags;
+    int retflag = 0;
 
-    flag = strsep(&tmp2, ",");
+    while (size_t len = strcspn(flag, ",")) {
 
-    while (flag) {
-        if (strcmp(flag, "src_ip_hash") == 0) {
+        if (strncmp(flag, "src_ip_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_IP_HASH;
-        } else if (strcmp(flag, "dst_ip_hash") == 0) {
+        } else if (strncmp(flag, "dst_ip_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_IP_HASH;
-        } else if (strcmp(flag, "source_port_hash") == 0) {
+        } else if (strncmp(flag, "source_port_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_PORT_HASH;
-        } else if (strcmp(flag, "dst_port_hash") == 0) {
+        } else if (strncmp(flag, "dst_port_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_PORT_HASH;
-        } else if (strcmp(flag, "ports_source") == 0) {
+        } else if (strncmp(flag, "ports_source", len) == 0) {
             retflag |= WCCP2_SERVICE_PORTS_SOURCE;
-        } else if (strcmp(flag, "src_ip_alt_hash") == 0) {
+        } else if (strncmp(flag, "src_ip_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_IP_ALT_HASH;
-        } else if (strcmp(flag, "dst_ip_alt_hash") == 0) {
+        } else if (strncmp(flag, "dst_ip_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_IP_ALT_HASH;
-        } else if (strcmp(flag, "src_port_alt_hash") == 0) {
+        } else if (strncmp(flag, "src_port_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_PORT_ALT_HASH;
-        } else if (strcmp(flag, "dst_port_alt_hash") == 0) {
+        } else if (strncmp(flag, "dst_port_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_PORT_ALT_HASH;
         } else {
+            flag[len] = '\0';
             fatalf("Unknown wccp2 service flag: %s\n", flag);
         }
 
-        flag = strsep(&tmp2, ",");
+        if (flag[len] == '\0')
+            break;
+
+        flag += len+1;
     }
 
-    xfree(tmp);
     return retflag;
 }
 
 static void
 parse_wccp2_service_ports(char *options, int portlist[])
 {
-    int i = 0;
-    int p;
-    char *tmp, *tmp2, *port;
-
     if (!options) {
         return;
     }
 
-    tmp = xstrdup(options);
-    tmp2 = tmp;
-
-    port = strsep(&tmp2, ",");
+    int i = 0;
+    char *tmp = options;
 
-    while (port && i < WCCP2_NUMPORTS) {
-        p = xatoi(port);
+    while (size_t len = strcspn(tmp, ",")) {
+        if (i >= WCCP2_NUMPORTS) {
+            fatalf("parse_wccp2_service_ports: too many ports (maximum: 8) in list '%s'\n", options);
+        }
+        int p = xatoi(tmp);
 
         if (p < 1 || p > 65535) {
-            fatalf("parse_wccp2_service_ports: port value '%s' isn't valid (1..65535)\n", port);
+            fatalf("parse_wccp2_service_ports: port value '%s' isn't valid (1..65535)\n", tmp);
         }
 
         portlist[i] = p;
         ++i;
-        port = strsep(&tmp2, ",");
-    }
-
-    if (i == WCCP2_NUMPORTS && port) {
-        fatalf("parse_wccp2_service_ports: too many ports (maximum: 8) in list '%s'\n", options);
+        if (tmp[len] == '\0')
+            return;
+        tmp += len+1;
     }
-
-    xfree(tmp);
 }
 
 void
@@ -31,7 +31,6 @@ endif
 TESTS += debug \
 	syntheticoperators \
 	VirtualDeleteOperator \
-	StackTest \
 	splay\
 	MemPoolTest\
 	mem_node_test\
@@ -46,7 +45,6 @@ check_PROGRAMS += debug \
 		mem_node_test\
 		mem_hdr_test \
 		splay \
-		StackTest \
 		syntheticoperators \
 		VirtualDeleteOperator
 
@@ -89,8 +87,6 @@ MemPoolTest_SOURCES = MemPoolTest.cc
 
 splay_SOURCES = splay.cc
 
-StackTest_SOURCES = StackTest.cc $(DEBUG_SOURCE)
-
 syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
 
 VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
@@ -1,56 +0,0 @@
-
-/*
- * DEBUG: section 19    Store Memory Primitives
- * AUTHOR: Robert Collins
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003  Robert Collins <robertc@squid-cache.org>
- */
-
-#include "squid.h"
-#include "Stack.h"
-
-int
-main(int argc, char **argv)
-{
-    Stack<int> aStack;
-    assert (aStack.size() == 0);
-    aStack.push_back(2);
-    assert (aStack.size() == 1);
-    assert (aStack.top() == 2);
-    assert (aStack.pop() == 2);
-    assert (aStack.size() == 0);
-    Stack<> oldStack;
-    assert (oldStack.size() == 0);
-    oldStack.push_back(&aStack);
-    assert (oldStack.size() == 1);
-    assert (oldStack.top() == &aStack);
-    assert (oldStack.pop() == &aStack);
-    assert (oldStack.size() == 0);
-    return 0;
-}
@@ -98,7 +98,7 @@ main(int argc, char **argv)
             run_stats = atoi(optarg);
             break;
         case 'f':
-            fn = strdup(optarg);
+            fn = xstrdup(optarg);
             fp = fopen(fn, "r");
             break;
         case 'i':
@@ -291,7 +291,7 @@ const char *
 make_nam(int id, int size)
 {
     const char *buf = malloc(30);	/* argh */
-    sprintf((char *) buf, "pl:%d/%d", id, size);
+    snprintf((char *)buf, sizeof(buf)-1, "pl:%d/%d", id, size);
     return buf;
 }
 
@@ -158,7 +158,7 @@ send_request(int fd, const char *data)
     struct _r *r;
     struct _r **R;
     char *method, *url, *file, *size, *checksum;
-    char *tmp = strdup(data);
+    char *tmp = xstrdup(data);
     struct stat st;
     int file_fd = -1;
     method = strtok(tmp, " ");
@@ -177,13 +177,13 @@ send_request(int fd, const char *data)
     if (checksum && strcmp(checksum, "-") == 0)
         checksum = NULL;
     msg[0] = '\0';
-    sprintf(buf, "%s %s HTTP/1.0\r\n", method, url);
+    snprintf(buf, sizeof(buf)-1, "%s %s HTTP/1.0\r\n", method, url);
     strcat(msg, buf);
     strcat(msg, "Accept: */*\r\n");
     strcat(msg, "Proxy-Connection: Keep-Alive\r\n");
     if (opt_ims && (lrand48() & 0x03) == 0) {
         w = time(NULL) - (lrand48() & 0x3FFFF);
-        sprintf(buf, "If-Modified-Since: %s\r\n", mkrfc850(&w));
+        snprintf(buf, sizeof(buf)-1, "If-Modified-Since: %s\r\n", mkrfc850(&w));
         strcat(msg, buf);
     }
     if (file) {
@@ -196,7 +196,7 @@ send_request(int fd, const char *data)
             close(file_fd);
             return -1;
         }
-        sprintf(buf, "Content-length: %d\r\n", st.st_size);
+        snprintf(buf, sizeof(buf)-1, "Content-length: %d\r\n", st.st_size);
         strcat(msg, buf);
     }
     strcat(msg, "\r\n");
@@ -557,14 +557,14 @@ char *argv[];
     int c;
     setbuf(stdout, NULL);
     setbuf(stderr, NULL);
-    progname = strdup(argv[0]);
+    progname = xstrdup(argv[0]);
     while ((c = getopt(argc, argv, "p:h:n:t:icl:r")) != -1) {
         switch (c) {
         case 'p':
             proxy_port = atoi(optarg);
             break;
         case 'h':
-            proxy_addr = strdup(optarg);
+            proxy_addr = xstrdup(optarg);
             break;
         case 'n':
             max_outstanding = atoi(optarg);
@@ -329,7 +329,7 @@ request(char *urlin) {
         checksum = "-";
     r = calloc(1, sizeof *r);
     assert(r != NULL);
-    r->url = strdup(url);
+    r->url = xstrdup(url);
     assert(r->url);
     strcpy(r->method, method);
     strcpy(r->requestbodyfile, file);
@@ -349,17 +349,17 @@ request(char *urlin) {
     } else {
         host = NULL;
     }
-    sprintf(msg, "%s %s HTTP/1.0\r\n", method, url);
+    snprintf(msg, sizeof(msg)-1, "%s %s HTTP/1.0\r\n", method, url);
     if (host) {
         url[0] = '\0';
-        sprintf(buf, "Host: %s\r\n", host);
+        snprintf(buf, sizeof(buf)-1, "Host: %s\r\n", host);
         strcat(msg, buf);
         url[0] = '/';
     }
     strcat(msg, "Accept: */*\r\n");
     if (opt_ims && (lrand48() & 0x03) == 0) {
         w = time(NULL) - (lrand48() & 0x3FFFF);
-        sprintf(buf, "If-Modified-Since: %s\r\n", mkrfc850(&w));
+        snprintf(buf, sizeof(buf)-1, "If-Modified-Since: %s\r\n", mkrfc850(&w));
         strcat(msg, buf);
     }
     if (file && strcmp(file, "-") != 0) {
@@ -369,7 +369,7 @@ request(char *urlin) {
             exit(1);
         }
         fstat(f, &st);
-        sprintf(buf, "Content-Length: %d\r\n", (int) st.st_size);
+        snprintf(buf, sizeof(buf)-1, "Content-Length: %d\r\n", (int) st.st_size);
         strcat(msg, buf);
     }
     if (opt_range && (lrand48() & 0x03) == 0) {
@@ -382,13 +382,13 @@ request(char *urlin) {
                 strcat(msg, ",");
             switch (lrand48() & 0x03) {
             case 0:
-                sprintf(buf, "-%d", len);
+                snprintf(buf, sizeof(buf)-1, "-%d", len);
                 break;
             case 1:
-                sprintf(buf, "%d-", offset);
+                snprintf(buf, sizeof(buf)-1, "%d-", offset);
                 break;
             default:
-                sprintf(buf, "%d-%d", offset, offset + len);
+                snprintf(buf, sizeof(buf)-1, "%d-%d", offset, offset + len);
                 break;
             }
             strcat(msg, buf);
@@ -480,10 +480,10 @@ char *argv[];
     struct timeval to;
     setbuf(stdout, NULL);
     setbuf(stderr, NULL);
-    progname = strdup(argv[0]);
+    progname = xstrdup(argv[0]);
     gettimeofday(&now, NULL);
     start = last = now;
-    custom_header = strdup("");
+    custom_header = xstrdup("");
     while ((c = getopt(argc, argv, "ap:h:H:n:icrl:L:t:")) != -1) {
         switch (c) {
         case 'a':
@@ -493,7 +493,7 @@ char *argv[];
             proxy_port = atoi(optarg);
             break;
         case 'h':
-            proxy_addr = strdup(optarg);
+            proxy_addr = xstrdup(optarg);
             break;
         case 'n':
             max_connections = atoi(optarg);
@@ -139,7 +139,7 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
                                       (int)subs[offset].rm_so,
                                       (int)subs[offset].rm_eo,
                                       line+subs[offset].rm_so );
-            cd.base = strdup( line+subs[offset].rm_so );
+            cd.base = xstrdup( line+subs[offset].rm_so );
             ++offset;
 
             // extract size information
@@ -43,12 +43,12 @@ using namespace Squid;
 /** \endcond */
 #endif
 
+#include <cstdio>
+#include <iostream>
+
 #if _SQUID_WINDOWS_
 #include <io.h>
 #endif
-#if HAVE_STDIO_H
-#include <stdio.h>
-#endif
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -120,6 +120,19 @@ gss_OID gss_mech_spnego = &_gss_mech_spnego;
 
 typedef void SIGHDLR(int sig);
 
+/// display debug messages at varying verbosity levels
+#define debugVerbose(LEVEL, MESSAGE) \
+    while ((LEVEL) <= verbosityLevel) {std::cerr << MESSAGE << std::endl; break;}
+
+/**
+ * What verbosity level to display.
+ *
+ *  0  : display no debug traces
+ *  1  : display outgoing request message
+ *  2+ : display all actions taken
+ */
+int verbosityLevel = 0;
+
 /* Local functions */
 static int client_comm_bind(int, const Ip::Address &);
 
@@ -134,7 +147,7 @@ static ssize_t myread(int fd, void *buf, size_t len);
 static ssize_t mywrite(int fd, void *buf, size_t len);
 
 #if HAVE_GSSAPI
-static int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status, const char *function);
+static bool check_gss_err(OM_uint32 major_status, OM_uint32 minor_status, const char *function);
 static char *GSSAPI_token(const char *server);
 #endif
 
@@ -164,59 +177,57 @@ Win32SockCleanup(void)
 static void
 usage(const char *progname)
 {
-    fprintf(stderr,
-            "Version: %s\n"
-            "Usage: %s [-arsv] [-A 'string'] [-g count] [-h remote host] [-H 'string'] [-i IMS] [-I ping-interval] [-j 'Host-header']"
-            "[-k] [-l local-host] [-m method] "
-#if HAVE_GSSAPI
-            "[-n] [-N] "
-#endif
-            "[-p port] [-P file] [-t count] [-T timeout] [-u proxy-user] [-U www-user] "
-            "[-V version] [-w proxy-password] [-W www-password] url\n"
-            "\n"
-            "Options:\n"
-            "    -a           Do NOT include Accept: header.\n"
-            "    -A           User-Agent: header. Use \"\" to omit.\n"
-            "    -g count     Ping mode, perform \"count\" iterations (0 to loop until interrupted).\n"
-            "    -h host      Retrieve URL from cache on hostname.  Default is localhost.\n"
-            "    -H 'string'  Extra headers to send. Use '\\n' for new lines.\n"
-            "    -i IMS       If-Modified-Since time (in Epoch seconds).\n"
-            "    -I interval  Ping interval in seconds (default 1 second).\n"
-            "    -j hosthdr   Host header content\n"
-            "    -k           Keep the connection active. Default is to do only one request then close.\n"
-            "    -l host      Specify a local IP address to bind to.  Default is none.\n"
-            "    -m method    Request method, default is GET.\n"
+    std::cerr << "Version: " << VERSION << std::endl
+            << "Usage: " << progname << " [Basic Options] [HTTP Options]" << std::endl
+            << std::endl
+            << "Basic Options:" << std::endl
+            << "    -g count        Ping mode, perform \"count\" iterations (0 to loop until interrupted)." << std::endl
+            << "    -h host         Send message to server on 'host'.  Default is localhost." << std::endl
+            << "    -I interval     Ping interval in seconds (default 1 second)." << std::endl
+            << "    -l host         Specify a local IP address to bind to.  Default is none." << std::endl
+            << "    -p port         Port number on server to contact. Default is " << CACHE_HTTP_PORT << "." << std::endl
+            << "    -s | --quiet    Silent.  Do not print response message to stdout." << std::endl
+            << "    -T timeout      Timeout value (seconds) for read/write operations" << std::endl
+            << "    -v | --verbose  Verbose debugging. Repeat (-vv) to increase output level." << std::endl
+            << "                    Levels:" << std::endl
+            << "                      1 - Print outgoing request message to stderr." << std::endl
+            << "                      2 - Print action trace to stderr." << std::endl
+            << "    --help          Display this help text." << std::endl
+            << std::endl
+            << "HTTP Options:" << std::endl
+            << "    -a           Do NOT include Accept: header." << std::endl
+            << "    -A           User-Agent: header. Use \"\" to omit." << std::endl
+            << "    -H 'string'  Extra headers to send. Use '\\n' for new lines." << std::endl
+            << "    -i IMS       If-Modified-Since time (in Epoch seconds)." << std::endl
+            << "    -j hosthdr   Host header content" << std::endl
+            << "    -k           Keep the connection active. Default is to do only one request then close." << std::endl
+            << "    -m method    Request method, default is GET." << std::endl
 #if HAVE_GSSAPI
-            "    -n           Proxy Negotiate(Kerberos) authentication\n"
-            "    -N           WWW Negotiate(Kerberos) authentication\n"
-#endif
-            "    -p port      Port number of cache.  Default is %d.\n"
-            "    -P file      PUT request. Using the named file\n"
-            "    -r           Force cache to reload URL.\n"
-            "    -s           Silent.  Do not print data to stdout.\n"
-            "    -t count     Trace count cache-hops\n"
-            "    -T timeout   Timeout value (seconds) for read/write operations.\n"
-            "    -u user      Proxy authentication username\n"
-            "    -U user      WWW authentication username\n"
-            "    -v           Verbose. Print outgoing message to stderr.\n"
-            "    -V version   HTTP Version. Use '-' for HTTP/0.9 omitted case\n"
-            "    -w password  Proxy authentication password\n"
-            "    -W password  WWW authentication password\n",
-            VERSION, progname, CACHE_HTTP_PORT);
+            << "    -n           Proxy Negotiate(Kerberos) authentication" << std::endl
+            << "    -N           WWW Negotiate(Kerberos) authentication" << std::endl
+#endif
+            << "    -P file      Send content from the named file as request payload" << std::endl
+            << "    -r           Force cache to reload URL" << std::endl
+            << "    -t count     Trace count cache-hops" << std::endl
+            << "    -u user      Proxy authentication username" << std::endl
+            << "    -U user      WWW authentication username" << std::endl
+            << "    -V version   HTTP Version. Use '-' for HTTP/0.9 omitted case" << std::endl
+            << "    -w password  Proxy authentication password" << std::endl
+            << "    -W password  WWW authentication password" << std::endl
+    ;
     exit(1);
 }
 
 static int interrupted = 0;
 int
 main(int argc, char *argv[])
 {
-    int conn, c, len, bytesWritten;
+    int conn, len, bytesWritten;
     uint16_t port;
     bool to_stdout, reload;
     int ping, pcount;
     int keep_alive = 0;
     int opt_noaccept = 0;
-    bool opt_verbose = false;
 #if HAVE_GSSAPI
     int www_neg = 0, proxy_neg = 0;
 #endif
@@ -253,19 +264,27 @@ main(int argc, char *argv[])
     ping_int = 1 * 1000;
 
     Ip::ProbeTransport(); // determine IPv4 or IPv6 capabilities before parsing.
-    if (argc < 2) {
+    if (argc < 2 || argv[argc-1][0] == '-') {
         usage(argv[0]);		/* need URL */
     } else if (argc >= 2) {
         strncpy(url, argv[argc - 1], BUFSIZ);
         url[BUFSIZ - 1] = '\0';
 
-        if (url[0] == '-')
-            usage(argv[0]);
-#if HAVE_GSSAPI
-        while ((c = getopt(argc, argv, "aA:h:j:V:l:P:i:km:p:rsvt:g:p:I:H:T:u:U:w:W:nN?")) != -1)
-#else
-        while ((c = getopt(argc, argv, "aA:h:j:V:l:P:i:km:p:rsvt:g:p:I:H:T:u:U:w:W:?")) != -1)
-#endif
+        int optIndex = 0;
+        const char *shortOpStr = "aA:h:j:V:l:P:i:kmnN:p:rsvt:g:p:I:H:T:u:U:w:W:?";
+
+        // options for controlling squidclient
+        static struct option basicOptions[] =
+        {
+          /* These are the generic options for squidclient itself */
+          {"help",    no_argument, 0, '?'},
+          {"verbose", no_argument, 0, 'v'},
+          {"quiet",   no_argument, 0, 's'},
+          {0, 0, 0, 0}
+        };
+
+        int c;
+        while ((c = getopt_long(argc, argv, shortOpStr, basicOptions, &optIndex)) != -1) {
             switch (c) {
 
             case 'a':
@@ -367,18 +386,28 @@ main(int argc, char *argv[])
                 www_password = optarg;
                 break;
 
-#if HAVE_GSSAPI
             case 'n':
+#if HAVE_GSSAPI
                 proxy_neg = 1;
+#else
+                std::cerr << "ERROR: Negotiate authentication not supported." << std::endl;
+                usage(argv[0]);
+#endif
                 break;
 
             case 'N':
+#if HAVE_GSSAPI
                 www_neg = 1;
-                break;
+#else
+                std::cerr << "ERROR: Negotiate authentication not supported." << std::endl;
+                usage(argv[0]);
 #endif
+                break;
+
             case 'v':
                 /* undocumented: may increase verb-level by giving more -v's */
-                opt_verbose=true;
+                ++verbosityLevel;
+                debugVerbose(2, "verbosity level set to " << verbosityLevel);
                 break;
 
             case '?':		/* usage */
@@ -387,6 +416,7 @@ main(int argc, char *argv[])
                 usage(argv[0]);
                 break;
             }
+        }
     }
 #if _SQUID_WINDOWS_
     {
@@ -414,16 +444,15 @@ main(int argc, char *argv[])
         set_our_signal();
 
         if (put_fd < 0) {
-            fprintf(stderr, "%s: can't open file (%s)\n", argv[0],
-                    xstrerror());
+            std::cerr << "ERROR: can't open file (" << xstrerror() << ")" << std::endl;
             exit(-1);
         }
 #if _SQUID_WINDOWS_
         setmode(put_fd, O_BINARY);
 #endif
 
         if (fstat(put_fd, &sb) < 0) {
-            fprintf(stderr, "%s: can't identify length of file (%s)\n", argv[0], xstrerror());
+            std::cerr << "ERROR: can't identify length of file (" << xstrerror() << ")" << std::endl;
         }
     }
 
@@ -493,7 +522,7 @@ main(int argc, char *argv[])
                 password = getpass("Proxy password: ");
 #endif
             if (!password) {
-                fprintf(stderr, "ERROR: Proxy password missing\n");
+                std::cerr << "ERROR: Proxy password missing" << std::endl;
                 exit(1);
             }
             snprintf(buf, BUFSIZ, "%s:%s", user, password);
@@ -508,7 +537,7 @@ main(int argc, char *argv[])
                 password = getpass("WWW password: ");
 #endif
             if (!password) {
-                fprintf(stderr, "ERROR: WWW password missing\n");
+                std::cerr << "ERROR: WWW password missing" << std::endl;
                 exit(1);
             }
             snprintf(buf, BUFSIZ, "%s:%s", user, password);
@@ -521,14 +550,14 @@ main(int argc, char *argv[])
                 snprintf(buf, BUFSIZ, "Authorization: Negotiate %s\r\n", GSSAPI_token(host));
                 strcat(msg, buf);
             } else
-                fprintf(stderr, "ERROR: server host missing\n");
+                std::cerr << "ERROR: server host missing" << std::endl;
         }
         if (proxy_neg) {
             if (hostname) {
                 snprintf(buf, BUFSIZ, "Proxy-Authorization: Negotiate %s\r\n", GSSAPI_token(hostname));
                 strcat(msg, buf);
             } else
-                fprintf(stderr, "ERROR: proxy server host missing\n");
+                std::cerr << "ERROR: proxy server host missing" << std::endl;
         }
 #endif
 
@@ -544,8 +573,7 @@ main(int argc, char *argv[])
         strcat(msg, "\r\n");
     }
 
-    if (opt_verbose)
-        fprintf(stderr, "Request:'%s'\n", msg);
+    debugVerbose(1, "Request:" << std::endl << msg << std::endl << ".");
 
     if (ping) {
 #if HAVE_SIGACTION
@@ -573,83 +601,71 @@ main(int argc, char *argv[])
         int fsize = 0;
         struct addrinfo *AI = NULL;
 
-        if (opt_verbose)
-            fprintf(stderr, "Resolving... %s\n", hostname);
+        debugVerbose(2, "Resolving... " << hostname);
 
         /* Connect to the server */
 
         if (localhost) {
             if ( !iaddr.GetHostByName(localhost) ) {
-                fprintf(stderr, "client: ERROR: Cannot resolve %s: Host unknown.\n", localhost);
+                std::cerr << "ERROR: Cannot resolve " << localhost << ": Host unknown." << std::endl;
                 exit(1);
             }
         } else {
             /* Process the remote host name to locate the Protocol required
                in case we are being asked to link to another version of squid */
             if ( !iaddr.GetHostByName(hostname) ) {
-                fprintf(stderr, "client: ERROR: Cannot resolve %s: Host unknown.\n", hostname);
+                std::cerr << "ERROR: Cannot resolve " << hostname << ": Host unknown." << std::endl;
                 exit(1);
             }
         }
 
         iaddr.getAddrInfo(AI);
         if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
-            perror("client: socket");
+            std::cerr << "ERROR: could not open socket to " << iaddr << std::endl;
             Ip::Address::FreeAddrInfo(AI);
             exit(1);
         }
         Ip::Address::FreeAddrInfo(AI);
 
         if (localhost && client_comm_bind(conn, iaddr) < 0) {
-            perror("client: bind");
+            std::cerr << "ERROR: could not bind socket to " << iaddr << std::endl;
             exit(1);
         }
 
         iaddr.setEmpty();
         if ( !iaddr.GetHostByName(hostname) ) {
-            fprintf(stderr, "client: ERROR: Cannot resolve %s: Host unknown.\n", hostname);
+            std::cerr << "ERROR: Cannot resolve " << hostname << ": Host unknown." << std::endl;
             exit(1);
         }
 
         iaddr.port(port);
 
-        if (opt_verbose) {
-            char ipbuf[MAX_IPSTRLEN];
-            fprintf(stderr, "Connecting... %s(%s)\n", hostname, iaddr.toStr(ipbuf, MAX_IPSTRLEN));
-        }
+        debugVerbose(2, "Connecting... " << hostname << " (" << iaddr << ")");
 
         if (client_comm_connect(conn, iaddr, ping ? &tv1 : NULL) < 0) {
             char hostnameBuf[MAX_IPSTRLEN];
             iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
-            if (errno == 0) {
-                fprintf(stderr, "client: ERROR: Cannot connect to %s: Host unknown.\n", hostnameBuf);
-            } else {
-                char tbuf[BUFSIZ];
-                snprintf(tbuf, BUFSIZ, "client: ERROR: Cannot connect to %s", hostnameBuf);
-                perror(tbuf);
-            }
+            std::cerr << "ERROR: Cannot connect to " << hostnameBuf
+                      << (!errno ?": Host unknown." : "") << std::endl;
             exit(1);
         }
-        if (opt_verbose) {
-            char ipbuf[MAX_IPSTRLEN];
-            fprintf(stderr, "Connected to: %s (%s)\n", hostname, iaddr.toStr(ipbuf, MAX_IPSTRLEN));
-        }
+        debugVerbose(2, "Connected to: " << hostname << " (" << iaddr << ")");
 
         /* Send the HTTP request */
-        fprintf(stderr, "Sending HTTP request ... ");
+        debugVerbose(2, "Sending HTTP request ... ");
         bytesWritten = mywrite(conn, msg, strlen(msg));
 
         if (bytesWritten < 0) {
-            perror("client: ERROR: write");
+            std::cerr << "ERROR: write" << std::endl;
             exit(1);
         } else if ((unsigned) bytesWritten != strlen(msg)) {
-            fprintf(stderr, "client: ERROR: Cannot send request?: %s\n", msg);
+            std::cerr << "ERROR: Cannot send request?: " << std::endl << msg << std::endl;
             exit(1);
         }
-        fprintf(stderr, "done.\n");
+        debugVerbose(2, "done.");
 
         if (put_file) {
-            fprintf(stderr, "Sending HTTP request payload ... ");
+            debugVerbose(1, "Sending HTTP request payload ...");
             int x;
             lseek(put_fd, 0, SEEK_SET);
             while ((x = read(put_fd, buf, sizeof(buf))) > 0) {
@@ -663,9 +679,9 @@ main(int argc, char *argv[])
             }
 
             if (x != 0)
-                fprintf(stderr, "client: ERROR: Cannot send file.\n");
+                std::cerr << "ERROR: Cannot send file." << std::endl;
             else
-                fprintf(stderr, "done.\n");
+                debugVerbose(1, "done.");
         }
         /* Read the data */
 
@@ -677,7 +693,7 @@ main(int argc, char *argv[])
             fsize += len;
 
             if (to_stdout && fwrite(buf, len, 1, stdout) != 1)
-                perror("client: ERROR writing to stdout");
+                std::cerr << "ERROR: writing to stdout: " << xstrerror() << std::endl;
         }
 
 #if _SQUID_WINDOWS_
@@ -699,11 +715,13 @@ main(int argc, char *argv[])
             elapsed_msec = tvSubMsec(tv1, tv2);
             t2s = tv2.tv_sec;
             tmp = localtime(&t2s);
-            fprintf(stderr, "%d-%02d-%02d %02d:%02d:%02d [%d]: %ld.%03ld secs, %f KB/s\n",
+            char tbuf[4096];
+            snprintf(tbuf, sizeof(tbuf)-1, "%d-%02d-%02d %02d:%02d:%02d [%d]: %ld.%03ld secs, %f KB/s",
                     tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
                     tmp->tm_hour, tmp->tm_min, tmp->tm_sec, i + 1,
                     elapsed_msec / 1000, elapsed_msec % 1000,
                     elapsed_msec ? (double) fsize / elapsed_msec : -1.0);
+            std::cerr << tbuf << std::endl;
 
             if (i == 0 || elapsed_msec < ping_min)
                 ping_min = elapsed_msec;
@@ -728,31 +746,30 @@ main(int argc, char *argv[])
 
     if (ping && i) {
         ping_mean = ping_sum / i;
-        fprintf(stderr, "%d requests, round-trip (secs) min/avg/max = "
-                "%ld.%03ld/%ld.%03ld/%ld.%03ld\n", i,
-                ping_min / 1000, ping_min % 1000, ping_mean / 1000, ping_mean % 1000,
-                ping_max / 1000, ping_max % 1000);
+        std::cerr << i << " requests, round-trip (secs) min/avg/max = "
+                  << (ping_min/1000) << "." << (ping_min%1000)
+                  << "/" << (ping_mean/1000) << "." << (ping_mean%1000)
+                  << "/" << (ping_max/1000) << "." << (ping_max%1000)
+                  << std::endl;
     }
-    exit(0);
-    /*NOTREACHED */
     return 0;
 }
 
+/// Set up the source socket address from which to send.
 static int
 client_comm_bind(int sock, const Ip::Address &addr)
 {
-    /* Set up the source socket address from which to send. */
     static struct addrinfo *AI = NULL;
     addr.getAddrInfo(AI);
     int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
     Ip::Address::FreeAddrInfo(AI);
     return res;
 }
 
+/// Set up the destination socket address for message to send to.
 static int
 client_comm_connect(int sock, const Ip::Address &addr, struct timeval *tvp)
 {
-    /* Set up the destination socket address for message to send to. */
     static struct addrinfo *AI = NULL;
     addr.getAddrInfo(AI);
     int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
@@ -776,34 +793,31 @@ void
 catchSignal(int sig)
 {
     interrupted = 1;
-    fprintf(stderr, "Interrupted.\n");
+    std::cerr << "SIGNAL " << sig << " Interrupted." << std::endl;
 }
 
 void
 pipe_handler(int sig)
 {
-    fprintf(stderr, "SIGPIPE received.\n");
+    std::cerr << "SIGPIPE received." << std::endl;
 }
 
 static void
 set_our_signal(void)
 {
 #if HAVE_SIGACTION
-
     struct sigaction sa;
     sa.sa_handler = pipe_handler;
     sa.sa_flags = SA_RESTART;
     sigemptyset(&sa.sa_mask);
 
     if (sigaction(SIGPIPE, &sa, NULL) < 0) {
-        fprintf(stderr, "Cannot set PIPE signal.\n");
+        std::cerr << "ERROR: Cannot set PIPE signal." << std::endl;
         exit(-1);
     }
 #else
     signal(SIGPIPE, pipe_handler);
-
 #endif
-
 }
 
 static ssize_t
@@ -829,14 +843,15 @@ mywrite(int fd, void *buf, size_t len)
 }
 
 #if HAVE_GSSAPI
-/*
+#define BUFFER_SIZE 8192
+/**
  * Check return valuse major_status, minor_status for error and print error description
  * in case of an error.
- * Returns 1 in case of gssapi error
- *         0 in case of no gssapi error
+ *
+ * \retval true in case of gssapi error
+ * \retval false in case of no gssapi error
  */
-#define BUFFER_SIZE 8192
-static int
+static bool
 check_gss_err(OM_uint32 major_status, OM_uint32 minor_status, const char *function)
 {
     if (GSS_ERROR(major_status)) {
@@ -879,17 +894,18 @@ check_gss_err(OM_uint32 major_status, OM_uint32 minor_status, const char *functi
             }
             gss_release_buffer(&min_stat, &status_string);
         }
-        fprintf(stderr, "%s failed: %s\n", function, buf);
-        return (1);
+        std::cerr << "ERROR: " << function << " failed: " << buf << std::endl;
+        return true;
     }
-    return (0);
+    return false;
 }
 
-/*
+/**
  * Get gssapi token for service HTTP/<server>
  * User has to initiate a kinit user@DOMAIN on commandline first for the
  * function to be successful
- * Returns base64 encoded token if successful
+ *
+ * \return base64 encoded token if successful,
  *         string "ERROR" if unsuccessful
  */
 static char *
@@ -907,7 +923,7 @@ GSSAPI_token(const char *server)
     setbuf(stdin, NULL);
 
     if (!server) {
-        fprintf(stderr, "Error: No server name\n");
+        std::cerr << "ERROR: GSSAPI: No server name" << std::endl;
         return (char *)"ERROR";
     }
     service.value = xmalloc(strlen("HTTP") + strlen(server) + 2);