@@ -3626,6 +3626,7 @@ AC_CONFIG_FILES([\
 	helpers/log_daemon/file/Makefile \
 	helpers/url_rewrite/Makefile \
 	helpers/url_rewrite/fake/Makefile \
+	helpers/ssl/Makefile \
 	tools/Makefile
 	tools/purge/Makefile
 ])
@@ -7,7 +7,8 @@ DIST_SUBDIRS = \
 	log_daemon \
 	negotiate_auth \
 	ntlm_auth \
-	url_rewrite
+	url_rewrite \
+	ssl
 
 SUBDIRS = \
 	basic_auth \
@@ -20,3 +21,8 @@ SUBDIRS = \
 if ENABLE_AUTH_NTLM
 SUBDIRS += ntlm_auth
 endif
+
+if ENABLE_SSL
+SUBDIRS += ssl
+endif
+
@@ -0,0 +1,5 @@
+include $(top_srcdir)/src/Common.am
+
+libexec_SCRIPTS = cert_valid.pl
+EXTRA_DIST= \
+	cert_valid.pl
@@ -0,0 +1,204 @@
+#!/usr/bin/perl -w
+#
+# A dummy SSL certificate validator helper that
+# echos back all the SSL errors sent by Squid.
+#
+
+use warnings;
+use strict;
+use Getopt::Long;
+use Pod::Usage;
+use Crypt::OpenSSL::X509;
+use FileHandle;
+use POSIX qw(strftime);
+
+my $debug = 0;
+my $help = 0;
+
+=pod
+
+=head1 NAME
+
+cert_valid.pl - A fake cert validation helper for Squid
+
+=head1 SYNOPSIS
+
+cert_valid.pl [-d | --debug] [-h | --help]
+
+=over 8
+
+=item  B<-h | --help>
+
+brief help message
+
+=item B<-d | --debug>
+
+enable debug messages to stderr
+
+=back
+
+=head1 DESCRIPTION
+
+Retrieves the SSL certificate error list from squid and echo back without any change.
+
+=head1 COPYRIGHT
+
+(C) 2012 The Measurement Factory, Author: Tsantilas Christos
+
+This program is free software. You may redistribute copies of it under the
+terms of the GNU General Public License version 2, or (at your opinion) any
+later version.
+
+=cut
+
+GetOptions(
+    'help' => \$help,
+    'debug' => \$debug,
+    ) or pod2usage(1);
+
+pod2usage(1) if ($help);
+
+$|=1;
+while (<>) {
+    my $first_line = $_;
+    my @line_args = split;
+
+    if ($first_line =~ /^\s*$/) {
+        next;
+    }
+
+    my $response;
+    my $haserror = 0;
+    my $channelId = $line_args[0];
+    my $code = $line_args[1];
+    my $bodylen = $line_args[2];
+    my $body = $line_args[3] . "\n";
+    if ($channelId !~ /\d+/) {
+        $response = $channelId." BH message=\"This helper is  concurrent and requires the concurrency option to be specified.\"\1";
+    } elsif ($bodylen !~ /\d+/) {
+        $response = $channelId." BH message=\"cert validator request syntax error \" \1";
+    } else {
+        my $readlen = length($body);
+        my %certs = ();
+        my @errors = ();
+        my @responseErrors = ();
+
+        while($readlen < $bodylen) {
+	    my $t = <>;
+            if (defined $t) {
+                $body  = $body . $t;
+                $readlen = length($body);
+            }
+        }
+
+        print(STDERR logPrefix()."GOT ". "Code=".$code." $bodylen \n") if ($debug); #.$body;
+        my $hostname;
+        parseRequest($body, \$hostname, \@errors, \%certs);
+        print(STDERR logPrefix()."Parse result: \n") if ($debug);
+        print(STDERR logPrefix()."\tFOUND host:".$hostname."\n") if ($debug);
+        print(STDERR logPrefix()."\tFOUND ERRORS:") if ($debug);
+        foreach my $err (@errors) {
+            print(STDERR logPrefix()."$err ,")  if ($debug);
+        }
+        print(STDERR "\n") if ($debug);
+        foreach my $key (keys %certs) {
+            ## Use "perldoc Crypt::OpenSSL::X509" for X509 available methods.
+            print(STDERR logPrefix()."\tFOUND cert ".$key.": ".$certs{$key}->subject() . "\n") if ($debug);
+        }
+
+        #got the peer certificate ID. Assume that the peer certificate is the first one.
+        my $peerCertId = (keys %certs)[0];
+
+        # Echo back the errors: fill the responseErrors array  with the errors we read.
+        foreach my $err (@errors) {
+            $haserror = 1;
+            appendError (\@responseErrors, 
+                         $err, #The error name
+                         "Checked by Cert Validator", # An error reason
+                         $peerCertId # The cert ID. We are always filling with the peer certificate.
+                );
+        }
+
+        $response = createResponse(\@responseErrors);
+        my $len = length($response);
+        if ($haserror) {
+            $response = $channelId." ERR ".$len." ".$response."\1";
+        } else {
+            $response = $channelId." OK ".$len." ".$response."\1";
+        }
+    }
+
+    print $response;
+    print(STDERR logPrefix().">> ".$response."\n") if ($debug);
+}
+
+sub trim
+{
+    my $s = shift;
+    $s =~ s/^\s+//;
+    $s =~ s/\s+$//;
+    return $s;
+}
+
+sub appendError
+{
+    my ($errorArrays) = shift;
+    my($errorName) = shift;
+    my($errorReason) = shift;
+    my($errorCert) = shift;
+    push @$errorArrays, { "error_name" => $errorName, "error_reason" => $errorReason, "error_cert" => $errorCert};
+}
+
+sub createResponse
+{
+    my ($responseErrors) = shift;
+    my $response="";
+    my $i = 0;
+    foreach my $err (@$responseErrors) {
+        $response=$response."error_name_".$i."=".$err->{"error_name"}."\n".
+            "error_reason_".$i."=".$err->{"error_reason"}."\n".
+            "error_cert_".$i."=".$err->{"error_cert"}."\n";
+        $i++;
+    }
+    return $response;
+}
+
+sub parseRequest
+{
+    my($request)=shift;
+    my $hostname = shift;
+    my $errors = shift;
+    my $certs = shift;
+    while ($request !~ /^\s*$/) {
+        $request = trim($request);
+        if ($request =~ /^host=/) {
+            my($vallen) = index($request, "\n");
+            my $host = substr($request, 5, $vallen - 5);
+            $$hostname = $host;
+            $request =~ s/^host=.*\n//;
+        }
+        if ($request =~ /^errors=/) {
+            my($vallen) = index($request, "\n");
+            my $listerrors = substr($request, 7, $vallen - 7);
+            @$errors = split /,/, $listerrors;
+            $request =~ s/^errors=.*\n//;
+        }
+        elsif ($request =~ /^cert_(\d+)=/) {
+            my $certId = "cert_".$1;
+            my($vallen) = index($request, "-----END CERTIFICATE-----") + length("-----END CERTIFICATE-----");
+            my $x509 = Crypt::OpenSSL::X509->new_from_string(substr($request, index($request, "-----BEGIN")));
+            $certs->{$certId} = $x509;
+            $request = substr($request, $vallen);
+        }
+        else {
+            print(STDERR logPrefix()."ParseError on \"".$request."\"\n") if ($debug);
+            $request = "";# finish processing....
+        }
+    }
+}
+
+
+sub logPrefix
+{
+  return strftime("%Y/%m/%d %H:%M:%S.0", localtime)." ".$0." ".$$." | " ;
+}
@@ -2424,6 +2424,59 @@ DOC_START
 	You must have at least one ssl_crtd process.
 DOC_END
 
+NAME: sslcrtvalidator_program
+TYPE: eol
+IFDEF: USE_SSL
+DEFAULT: none
+LOC: Ssl::TheConfig.ssl_crt_validator
+DOC_START
+	Specify the location and options of the executable for ssl_crt_validator
+	process.
+DOC_END
+
+NAME: sslcrtvalidator_children
+TYPE: HelperChildConfig
+IFDEF: USE_SSL
+DEFAULT: 32 startup=5 idle=1 concurrency=1
+LOC: Ssl::TheConfig.ssl_crt_validator_Children
+DOC_START
+	The maximum number of processes spawn to service ssl server.
+	The maximum this may be safely set to is 32.
+	
+	The startup= and idle= options allow some measure of skew in your
+	tuning.
+	
+		startup=N
+	
+	Sets the minimum number of processes to spawn when Squid
+	starts or reconfigures. When set to zero the first request will
+	cause spawning of the first child process to handle it.
+	
+	Starting too few children temporary slows Squid under load while it
+	tries to spawn enough additional processes to cope with traffic.
+	
+		idle=N
+	
+	Sets a minimum of how many processes Squid is to try and keep available
+	at all times. When traffic begins to rise above what the existing
+	processes can handle this many more will be spawned up to the maximum
+	configured. A minimum setting of 1 is required.
+
+		concurrency=
+	
+	The number of requests each certificate validator helper can handle in
+	parallel. Defaults to 0 which indicates the certficate validator
+	is a old-style single threaded redirector.
+	
+	When this directive is set to a value >= 1 then the protocol
+	used to communicate with the helper is modified to include
+	a request ID in front of the request/response. The request
+	ID from the request must be echoed back with the response
+	to that request.
+	
+	You must have at least one ssl_crt_validator process.
+DOC_END
+
 COMMENT_START
  OPTIONS WHICH AFFECT THE NEIGHBOR SELECTION ALGORITHM
  -----------------------------------------------------------------------------
@@ -72,6 +72,11 @@
 #include "urn.h"
 #include "whois.h"
 #if USE_SSL
+#if 1 // USE_SSL_CERT_VALIDATOR
+#include "ssl/cert_validate_message.h"
+#include "ssl/Config.h"
+#include "ssl/helper.h"
+#endif
 #include "ssl/support.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/ServerBump.h"
@@ -739,9 +744,192 @@ FwdState::negotiateSSL(int fd)
         serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
     }
 
+#if 1 // USE_SSL_CERT_VALIDATOR
+    if (Ssl::TheConfig.ssl_crt_validator) {
+        Ssl::CertValidationRequest validationRequest;
+        // WARNING: The STACK_OF(*) OpenSSL objects does not support locking.
+        // If we need to support locking we need to sk_X509_dup the STACK_OF(X509)
+        // list and lock all of the X509 members of the list.
+        // Currently we do not use any locking for any of the members of the
+        // Ssl::CertValidationRequest class. If the ssl object gone, the value returned
+        // from SSL_get_peer_cert_chain may not exist any more. In this code the
+        // Ssl::CertValidationRequest object used only to pass data to
+        // Ssl::CertValidationHelper::submit method.
+        validationRequest.peerCerts = SSL_get_peer_cert_chain(ssl);
+        validationRequest.domainName = request->GetHost();
+        if (Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+            // validationRequest disappears on return so no need to cbdataReference
+            validationRequest.errors = errs;
+        else
+            validationRequest.errors = NULL;
+        try {
+            debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
+            Ssl::CertValidationMsg requestMsg(Ssl::CrtdMessage::REQUEST);
+            requestMsg.setCode(Ssl::CertValidationMsg::code_cert_validate);
+            requestMsg.composeRequest(validationRequest);
+            debugs(83, 5, "SSL crtvd request: " << requestMsg.compose().c_str());
+            Ssl::CertValidationHelper::GetInstance()->sslSubmit(requestMsg, sslCrtvdHandleReplyWrapper, this);
+            return;
+        } catch (const std::exception &e) {
+            debugs(33, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
+                   "request for " << validationRequest.domainName <<
+                   " certificate: " << e.what() << "; will now block to " <<
+                   "validate that certificate.");
+            // fall through to do blocking in-process generation.
+            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+            fail(anErr);
+            if (serverConnection()->getPeer()) {
+                peerConnectFailed(serverConnection()->getPeer());
+            }
+            serverConn->close();
+            self = NULL;
+            return;
+        }
+    }
+#endif // USE_SSL_CERT_VALIDATOR
+
     dispatch();
 }
 
+#if 1 // USE_SSL_CERT_VALIDATOR
+void
+FwdState::sslCrtvdHandleReplyWrapper(void *data, const HelperReply &reply)
+{
+    FwdState * fwd = (FwdState *)(data);
+    fwd->sslCrtvdHandleReply(reply);
+}
+
+void
+FwdState::sslCrtvdHandleReply(const HelperReply &reply)
+{
+    Ssl::Errors *errs = NULL;
+    Ssl::ErrorDetail *errDetails = NULL;
+    bool validatorFailed = false;
+    if (!Comm::IsConnOpen(serverConnection())) {
+        return;
+    }
+    SSL *ssl = fd_table[serverConnection()->fd].ssl;
+
+    if (!reply.other().hasContent()) {
+        debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper return <NULL> reply");
+        validatorFailed = true;
+    } else if (reply.result == HelperReply::BrokenHelper) {
+        debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper error response: " << reply.other().content());
+        validatorFailed = true;
+    } else  {
+        Ssl::CertValidationMsg replyMsg(Ssl::CrtdMessage::REPLY);
+        Ssl::CertValidationResponse validationResponse;
+        std::string error;
+        STACK_OF(X509) *peerCerts = SSL_get_peer_cert_chain(ssl);
+        if (replyMsg.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK ||
+                   !replyMsg.parseResponse(validationResponse, peerCerts, error) ) {
+            debugs(83, 5, "Reply from ssl_crtvd for " << request->GetHost() << " is incorrect");
+            validatorFailed = true;
+        } else {
+            if (reply.result == HelperReply::Okay) {
+                debugs(83, 5, "Certificate for " << request->GetHost() << " was successfully validated from ssl_crtvd");
+            } else if (reply.result == HelperReply::Error) {
+                debugs(83, 5, "Certificate for " << request->GetHost() << " found buggy by ssl_crtvd");
+                errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
+            } else {
+                debugs(83, 5, "Certificate for " << request->GetHost() << " cannot be validated. ssl_crtvd response: " << replyMsg.getBody());
+                validatorFailed = true;
+            }
+
+            if (!errDetails && !validatorFailed) {
+                dispatch();
+                return;
+            }
+        }
+    }
+
+    ErrorState *anErr = NULL;
+    if (validatorFailed) {
+        anErr = new ErrorState(ERR_GATEWAY_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+    }  else {
+
+        // Check the list error with
+        if (errDetails && request->clientConnectionManager.valid()) {
+            // remember the server certificate from the ErrorDetail object
+            if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+                // remember validation errors, if any
+                if (errs) {
+                    if (serverBump->sslErrors)
+                        cbdataReferenceDone(serverBump->sslErrors);
+                    serverBump->sslErrors = cbdataReference(errs);
+                }
+            }
+        }
+
+        anErr = makeConnectingError(ERR_SECURE_CONNECT_FAIL);
+        anErr->detail = errDetails;
+        /*anErr->xerrno= Should preserved*/
+    }
+
+    fail(anErr);
+    if (serverConnection()->getPeer()) {
+        peerConnectFailed(serverConnection()->getPeer());
+    }
+    serverConn->close();
+    self = NULL;
+    return;
+}
+
+/// Checks errors in the cert. validator response against sslproxy_cert_error.
+/// The first honored error, if any, is returned via errDetails parameter.
+/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::Errors.
+Ssl::Errors *
+FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse &resp, Ssl::ErrorDetail *& errDetails)
+{
+    Ssl::Errors *errs = NULL;
+
+    ACLFilledChecklist *check = NULL;
+    if (acl_access *acl = Config.ssl_client.cert_error)
+        check = new ACLFilledChecklist(acl, request, dash_str);
+
+    SSL *ssl = fd_table[serverConnection()->fd].ssl;
+    typedef Ssl::CertValidationResponse::RecvdErrors::const_iterator SVCRECI;
+    for (SVCRECI i = resp.errors.begin(); i != resp.errors.end(); ++i) {
+        debugs(83, 7, "Error item: " << i->error_no << " " << i->error_reason);
+
+        assert(i->error_no != SSL_ERROR_NONE);
+
+        if (!errDetails) {
+            bool allowed = false;
+            if (check) {
+                check->sslErrors = new Ssl::Errors(i->error_no);
+                if (check->fastCheck() == ACCESS_ALLOWED)
+                    allowed = true;
+            }
+            // else the Config.ssl_client.cert_error access list is not defined
+            // and the first error will cause the error page
+
+            if (allowed) {
+                debugs(83, 3, "bypassing SSL error " << i->error_no << " in " << "buffer");
+            } else {
+                debugs(83, 5, "confirming SSL error " << i->error_no);
+                X509 *brokenCert = i->cert.get();
+                Ssl::X509_Pointer peerCert(SSL_get_peer_certificate(ssl));
+                const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
+                errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
+            }
+            delete check->sslErrors;
+            check->sslErrors = NULL;
+        }
+
+        if (!errs)
+            errs = new Ssl::Errors(i->error_no);
+        else
+            errs->push_back_unique(i->error_no);
+    }
+    if (check)
+        delete check;
+
+    return errs;
+}
+
+#endif // USE_SSL_CERT_VALIDATOR
+
 void
 FwdState::initiateSSL()
 {
@@ -804,12 +992,20 @@ FwdState::initiateSSL()
             Ssl::setClientSNI(ssl, hostname);
     }
 
-    // Create the ACL check list now, while we have access to more info.
-    // The list is used in ssl_verify_cb() and is freed in ssl_free().
-    if (acl_access *acl = Config.ssl_client.cert_error) {
-        ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
-        SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
+#if 1 // USE_SSL_CERT_VALIDATOR
+    // If CertValidation Helper used do not lookup checklist for errors,
+    // but keep a list of errors to send it to CertValidator
+    if (!Ssl::TheConfig.ssl_crt_validator) {
+#endif
+        // Create the ACL check list now, while we have access to more info.
+        // The list is used in ssl_verify_cb() and is freed in ssl_free().
+        if (acl_access *acl = Config.ssl_client.cert_error) {
+            ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
+            SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
+        }
+#if 1 // USE_SSL_CERT_VALIDATOR
     }
+#endif
 
     // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
     X509 *peeked_cert;
@@ -9,6 +9,9 @@
 #include "fde.h"
 #include "HttpStatusCode.h"
 #include "ip/Address.h"
+#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+#include "ssl/support.h"
+#endif
 
 /* forward decls */
 
@@ -17,6 +20,14 @@ typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class ErrorState;
 class HttpRequest;
 
+#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+namespace Ssl
+{
+class ErrorDetail;
+class CertValidationResponse;
+};
+#endif
+
 /**
  * Returns the TOS value that we should be setting on the connection
  * to the server, based on the ACL.
@@ -29,6 +40,8 @@ tos_t GetTosToServer(HttpRequest * request);
  */
 nfmark_t GetNfmarkToServer(HttpRequest * request);
 
+class HelperReply;
+
 class FwdState : public RefCountable
 {
 public:
@@ -71,6 +84,14 @@ class FwdState : public RefCountable
     /** return a ConnectionPointer to the current server connection (may or may not be open) */
     Comm::ConnectionPointer const & serverConnection() const { return serverConn; };
 
+#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+    /// Callback function called when squid receive message from cert validator helper
+    static void sslCrtvdHandleReplyWrapper(void *data, const HelperReply &reply);
+    /// Process response from cert validator helper
+    void sslCrtvdHandleReply(const HelperReply &reply);
+    /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
+    Ssl::Errors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse &, Ssl::ErrorDetail *&);
+#endif
 private:
     // hidden for safer management of self; use static fwdStart
     FwdState(const Comm::ConnectionPointer &client, StoreEntry *, HttpRequest *, const AccessLogEntryPointer &alp);
@@ -120,10 +120,10 @@
 #include "LoadableModules.h"
 #endif
 #if USE_SSL_CRTD
-#include "ssl/helper.h"
 #include "ssl/certificate_db.h"
 #endif
 #if USE_SSL
+#include "ssl/helper.h"
 #include "ssl/context_storage.h"
 #endif
 #if ICAP_CLIENT
@@ -767,6 +767,10 @@ mainReconfigureStart(void)
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
 #if USE_SSL
+#if 1 // USE_SSL_CERT_VALIDATOR
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Shutdown();
+#endif
     Ssl::TheGlobalContextStorage.reconfigureStart();
 #endif
     redirectShutdown();
@@ -849,6 +853,10 @@ mainReconfigureFinish(void *)
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
 #endif
+#if USE_SSL // && USE_SSL_CERT_VALIDATOR
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Init();
+#endif
 
     redirectInit();
 #if USE_AUTH
@@ -1046,6 +1054,11 @@ mainInitialize(void)
     Ssl::Helper::GetInstance()->Init();
 #endif
 
+#if USE_SSL // && USE_SSL_CERT_VALIDATOR
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Init();
+#endif
+
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
@@ -1838,6 +1851,10 @@ SquidShutdown()
     dnsShutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
+#endif
+#if USE_SSL //&& USE_SSL_CERT_VALIDATOR
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Shutdown();
 #endif
     redirectShutdown();
     externalAclShutdown();
@@ -3,11 +3,11 @@
 
 Ssl::Config Ssl::TheConfig;
 
-Ssl::Config::Config()
+Ssl::Config::Config():
 #if USE_SSL_CRTD
-        :
-        ssl_crtd(NULL)
+        ssl_crtd(NULL),
 #endif
+        ssl_crt_validator(NULL)
 {
 }
 
@@ -16,4 +16,5 @@ Ssl::Config::~Config()
 #if USE_SSL_CRTD
     xfree(ssl_crtd);
 #endif
+    xfree(ssl_crt_validator);
 }
@@ -13,6 +13,10 @@ class Config
     char *ssl_crtd; ///< Name of external ssl_crtd application.
     /// The number of processes spawn for ssl_crtd.
     HelperChildConfig ssl_crtdChildren;
+#endif
+#if 1 // USE_SSL_CERT_VALIDATOR
+    char *ssl_crt_validator;
+    HelperChildConfig ssl_crt_validator_Children;
 #endif
     Config();
     ~Config();
@@ -338,7 +338,9 @@ const char *Ssl::ErrorDetail::err_descr() const
 
 const char *Ssl::ErrorDetail::err_lib_error() const
 {
-    if (lib_error_no != SSL_ERROR_NONE)
+    if (errReason.defined())
+        return errReason.termedBuf();
+    else if (lib_error_no != SSL_ERROR_NONE)
         return ERR_error_string(lib_error_no, NULL);
     else
         return "[No Error]";
@@ -414,7 +416,7 @@ const String &Ssl::ErrorDetail::toString() const
     return errDetailStr;
 }
 
-Ssl::ErrorDetail::ErrorDetail( Ssl::ssl_error_t err_no, X509 *cert, X509 *broken): error_no (err_no), lib_error_no(SSL_ERROR_NONE)
+Ssl::ErrorDetail::ErrorDetail( Ssl::ssl_error_t err_no, X509 *cert, X509 *broken, const char *aReason): error_no (err_no), lib_error_no(SSL_ERROR_NONE), errReason(aReason)
 {
     if (cert)
         peer_cert.resetAndLock(cert);
@@ -49,7 +49,7 @@ class ErrorDetail
 {
 public:
     // if broken certificate is nil, the peer certificate is broken
-    ErrorDetail(ssl_error_t err_no, X509 *peer, X509 *broken);
+    ErrorDetail(ssl_error_t err_no, X509 *peer, X509 *broken, const char *aReason = NULL);
     ErrorDetail(ErrorDetail const &);
     const String &toString() const;  ///< An error detail string to embed in squid error pages
     void useRequest(HttpRequest *aRequest) { if (aRequest != NULL) request = aRequest;}
@@ -93,6 +93,7 @@ class ErrorDetail
     unsigned long lib_error_no; ///< low-level error returned by OpenSSL ERR_get_error(3SSL)
     X509_Pointer peer_cert; ///< A pointer to the peer certificate
     X509_Pointer broken_cert; ///< A pointer to the broken certificate (peer or intermediate)
+    String errReason; ///< A custom reason for error, else retrieved from OpenSSL.
     mutable ErrorDetailEntry detailEntry;
     HttpRequest::Pointer request;
 };
@@ -11,16 +11,14 @@ EXTRA_DIST = \
 
 if USE_SSL_CRTD
 SSL_CRTD = ssl_crtd
-SSL_CRTD_SOURCE = \
-    helper.cc \
-    helper.h
 else
 SSL_CRTD =
-SSL_CRTD_SOURCE =
 endif
 
 ## SSL stuff used by main Squid but not by ssl_crtd
 libsslsquid_la_SOURCES = \
+	cert_validate_message.cc \
+	cert_validate_message.h \
 	context_storage.cc \
 	context_storage.h \
 	Config.cc \
@@ -34,8 +32,8 @@ libsslsquid_la_SOURCES = \
 	ServerBump.h \
 	support.cc \
 	support.h \
-	\
-	$(SSL_CRTD_SOURCE)
+	helper.cc \
+	helper.h
 
 ## SSL stuff used by main Squid and ssl_crtd
 libsslutil_la_SOURCES = \
@@ -0,0 +1,218 @@
+#include "squid.h"
+#include "acl/FilledChecklist.h"
+#include "ssl/support.h"
+#include "ssl/cert_validate_message.h"
+#include "ssl/ErrorDetail.h"
+
+void
+Ssl::CertValidationMsg::composeRequest(CertValidationRequest const &vcert)
+{
+    body.clear();
+    body += Ssl::CertValidationMsg::param_host + "=" + vcert.domainName;
+    if (vcert.errors) {
+        body += "\n" + Ssl::CertValidationMsg::param_error + "=";
+        bool comma = false;
+        for (const Ssl::Errors *err = vcert.errors; err; err = err->next ) {
+            if (comma)
+                body += ",";
+            body += GetErrorName(err->element);
+            comma = true;
+        }
+    }
+
+    if (vcert.peerCerts) {
+        body +="\n";
+        Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
+        for (int i = 0; i < sk_X509_num(vcert.peerCerts); ++i) {
+            X509 *cert = sk_X509_value(vcert.peerCerts, i);
+            PEM_write_bio_X509(bio.get(), cert);
+            body = body + "cert_" + xitoa(i) + "=";
+            char *ptr;
+            long len = BIO_get_mem_data(bio.get(), &ptr);
+            body.append(ptr, len);
+            // Normally openssl toolkit terminates Certificate with a '\n'.
+            if (ptr[len-1] != '\n')
+                body +="\n";
+            if (!BIO_reset(bio.get())) {
+                // print an error?
+            }
+        }
+    }
+}
+
+static int
+get_error_id(const char *label, size_t len)
+{
+    const char *e = label + len -1;
+    while (e != label && xisdigit(*e)) --e;
+    if (e != label) ++e;
+    return strtol(e, 0 , 10);
+}
+
+bool
+Ssl::CertValidationMsg::parseResponse(CertValidationResponse &resp, STACK_OF(X509) *peerCerts, std::string &error)
+{
+    std::vector<CertItem> certs;
+
+    const char *param = body.c_str();
+    while (*param) {
+        while (xisspace(*param)) param++;
+        if (! *param)
+            break;
+
+        size_t param_len = strcspn(param, "=\r\n");
+        if (param[param_len] !=  '=') {
+            debugs(83, DBG_IMPORTANT, "WARNING: cert validator response parse error: " << param);
+            return false;
+        }
+        const char *value=param+param_len+1;
+
+        if (param_len > param_cert.length() &&
+                strncmp(param, param_cert.c_str(), param_cert.length()) == 0) {
+            CertItem ci;
+            ci.name.assign(param, param_len);
+            X509_Pointer x509;
+            readCertFromMemory(x509, value);
+            ci.setCert(x509.get());
+            certs.push_back(ci);
+
+            const char *b = strstr(value, "-----END CERTIFICATE-----");
+            if (b == NULL) {
+                debugs(83, DBG_IMPORTANT, "WARNING: cert Validator response parse error: Failed  to find certificate boundary " << value);
+                return false;
+            }
+            b += strlen("-----END CERTIFICATE-----");
+            param = b + 1;
+            continue;
+        }
+
+        size_t value_len = strcspn(value, "\r\n");
+        std::string v(value, value_len);
+
+        debugs(83, 5, "Returned value: " << std::string(param, param_len).c_str() << ": " <<
+               v.c_str());
+
+        int errorId = get_error_id(param, param_len);
+        Ssl::CertValidationResponse::RecvdError &currentItem = resp.getError(errorId);
+
+        if (param_len > param_error_name.length() &&
+                strncmp(param, param_error_name.c_str(), param_error_name.length()) == 0) {
+            currentItem.error_no = Ssl::GetErrorCode(v.c_str());
+            if (currentItem.error_no == SSL_ERROR_NONE) {
+                debugs(83, DBG_IMPORTANT, "WARNING: cert validator response parse error: Unknown SSL Error: " << v);
+                return false;
+            }
+        } else if (param_len > param_error_reason.length() &&
+                   strncmp(param, param_error_reason.c_str(), param_error_reason.length()) == 0) {
+            currentItem.error_reason = v;
+        } else if (param_len > param_error_cert.length() &&
+                   strncmp(param, param_error_cert.c_str(), param_error_cert.length()) == 0) {
+
+            if (X509 *cert = getCertByName(certs, v)) {
+                debugs(83, 6, "The certificate with id \"" << v << "\" found.");
+                currentItem.setCert(cert);
+            } else {
+                //In this case we assume that the certID is one of the certificates sent
+                // to cert validator. The certificates sent to cert validator have names in
+                // form "cert_xx" where the "xx" is an integer represents the position of
+                // the certificate inside peer certificates list.
+                const int certId = get_error_id(v.c_str(), v.length());
+                debugs(83, 6, "Cert index in peer certificates list:" << certId);
+                //if certId is not correct sk_X509_value returns NULL
+                currentItem.setCert(sk_X509_value(peerCerts, certId));
+            }
+        } else {
+            debugs(83, DBG_IMPORTANT, "WARNING: cert validator response parse error: Unknown parameter name " << std::string(param, param_len).c_str());
+            return false;
+        }
+
+        param = value + value_len +1;
+    }
+
+    /*Run through parsed errors to check for errors*/
+    typedef Ssl::CertValidationResponse::RecvdErrors::const_iterator SVCRECI;
+    for (SVCRECI i = resp.errors.begin(); i != resp.errors.end(); ++i) {
+        if (i->error_no != SSL_ERROR_NONE) {
+            debugs(83, DBG_IMPORTANT, "WARNING: cert validator incomplete response: Missing error name from error_id: " << i->id);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+X509 *
+Ssl::CertValidationMsg::getCertByName(std::vector<CertItem> const &certs, std::string const & name)
+{
+    typedef std::vector<CertItem>::const_iterator SVCI;
+    for (SVCI ci = certs.begin(); ci != certs.end(); ++ci) {
+        if (ci->name.compare(name) == 0)
+            return ci->cert.get();
+    }
+    return NULL;
+}
+
+Ssl::CertValidationResponse::RecvdError &
+Ssl::CertValidationResponse::getError(int errorId)
+{
+    typedef Ssl::CertValidationResponse::RecvdErrors::iterator SVCREI;
+    for (SVCREI i = errors.begin(); i != errors.end(); ++i) {
+        if (i->id == errorId)
+            return *i;
+    }
+    Ssl::CertValidationResponse::RecvdError errItem;
+    errItem.id = errorId;
+    errors.push_back(errItem);
+    return errors.back();
+}
+
+Ssl::CertValidationResponse::RecvdError::RecvdError(const RecvdError &old)
+{
+    id = old.id;
+    error_no = old.error_no;
+    error_reason = old.error_reason;
+    setCert(old.cert.get());
+}
+
+Ssl::CertValidationResponse::RecvdError & Ssl::CertValidationResponse::RecvdError::operator = (const RecvdError &old)
+{
+    id = old.id;
+    error_no = old.error_no;
+    error_reason = old.error_reason;
+    setCert(old.cert.get());
+    return *this;
+}
+
+void
+Ssl::CertValidationResponse::RecvdError::setCert(X509 *aCert)
+{
+    cert.resetAndLock(aCert);
+}
+
+Ssl::CertValidationMsg::CertItem::CertItem(const CertItem &old)
+{
+    name = old.name;
+    setCert(old.cert.get());
+}
+
+Ssl::CertValidationMsg::CertItem & Ssl::CertValidationMsg::CertItem::operator = (const CertItem &old)
+{
+    name = old.name;
+    setCert(old.cert.get());
+    return *this;
+}
+
+void
+Ssl::CertValidationMsg::CertItem::setCert(X509 *aCert)
+{
+    cert.resetAndLock(aCert);
+}
+
+const std::string Ssl::CertValidationMsg::code_cert_validate("cert_validate");
+const std::string Ssl::CertValidationMsg::param_domain("domain");
+const std::string Ssl::CertValidationMsg::param_error("errors");
+const std::string Ssl::CertValidationMsg::param_cert("cert_");
+const std::string Ssl::CertValidationMsg::param_error_name("error_name_");
+const std::string Ssl::CertValidationMsg::param_error_reason("error_reason_");
+const std::string Ssl::CertValidationMsg::param_error_cert("error_cert_");
+
@@ -0,0 +1,113 @@
+/*
+ */
+
+#ifndef SQUID_SSL_CERT_VALIDATE_MESSAGE_H
+#define SQUID_SSL_CERT_VALIDATE_MESSAGE_H
+
+#include "ssl/support.h"
+#include "ssl/crtd_message.h"
+#include <vector>
+
+namespace Ssl
+{
+
+/**
+ * This class is used to hold the required informations to build
+ * a request message for the certificate validator helper
+ */
+class CertValidationRequest
+{
+public:
+    STACK_OF(X509) *peerCerts; ///< The list of sent by SSL server
+    Errors *errors; ///< The list of errors detected
+    std::string domainName; ///< The server name
+    CertValidationRequest() : peerCerts(NULL), errors(NULL) {}
+};
+
+/**
+ * This class is used to store informations found in certificate validation
+ * response messages read from certificate validator helper
+ */
+class CertValidationResponse
+{
+public:
+    /**
+     * This class used to hold error informations returned from
+     * cert validator helper.
+     */
+    class  RecvdError
+    {
+    public:
+        RecvdError(): id(0), error_no(SSL_ERROR_NONE), cert(NULL) {}
+        RecvdError(const RecvdError &);
+        RecvdError & operator = (const RecvdError &);
+        void setCert(X509 *);  ///< Sets cert to the given certificate
+        int id; ///<  The id of the error
+        ssl_error_t error_no; ///< The OpenSSL error code
+        std::string error_reason; ///< A string describing the error
+        X509_Pointer cert; ///< The broken certificate
+    };
+
+    typedef std::vector<RecvdError> RecvdErrors;
+
+    /// Search in errors list for the error item with id=errorId.
+    /// If none found a new RecvdError item added with the given id;
+    RecvdError &getError(int errorId);
+    RecvdErrors errors; ///< The list of parsed errors
+};
+
+/**
+ * This class is responsible for composing or parsing messages destined to
+ * or comming from a cert validator helper.
+ * The messages format is:
+ *   <response/request code> <whitespace> <body length> <whitespace> <key=value> ...\1
+ */
+class CertValidationMsg: public CrtdMessage
+{
+private:
+    /**
+     * This class used to hold the certId/cert pairs found
+     * in cert validation messages.
+     */
+    class CertItem
+    {
+    public:
+        std::string name; ///< The certificate Id to use
+        X509_Pointer cert;       ///< A pointer to certificate
+        CertItem(): cert(NULL) {}
+        CertItem(const CertItem &);
+        CertItem & operator = (const CertItem &);
+        void setCert(X509 *); ///< Sets cert to the given certificate
+    };
+
+public:
+    CertValidationMsg(MessageKind kind): CrtdMessage(kind) {}
+
+    /// Build a request message for the cert validation helper
+    /// using informations provided by vcert object
+    void composeRequest(CertValidationRequest const &vcert);
+
+    /// Parse a response message and fill the resp object with parsed informations
+    bool parseResponse(CertValidationResponse &resp, STACK_OF(X509) *peerCerts, std::string &error);
+
+    /// Search a CertItems list for the certificate with ID "name"
+    X509 *getCertByName(std::vector<CertItem> const &, std::string const & name);
+
+    /// String code for "cert_validate" messages
+    static const std::string code_cert_validate;
+    /// Parameter name for passing intended domain name
+    static const std::string param_domain;
+    /// Parameter name for passing SSL errors
+    static const std::string param_error;
+    /// Parameter name for passing SSL certificates
+    static const std::string param_cert;
+    /// Parameter name for passing the major SSL error
+    static const std::string param_error_name;
+    /// Parameter name for passing the error reason
+    static const std::string param_error_reason;
+    /// Parameter name for passing the error cert ID
+    static const std::string param_error_cert;
+};
+
+}//namespace Ssl
+#endif // SQUID_SSL_CERT_VALIDATE_MESSAGE_H
@@ -80,7 +80,7 @@ class CrtdMessage
     static const std::string param_SetCommonName;
     /// Parameter name for passing signing algorithm
     static const std::string param_Sign;
-private:
+protected:
     enum ParseState {
         BEFORE_CODE,
         CODE,
@@ -8,6 +8,7 @@
 #include "wordlist.h"
 #include "SquidConfig.h"
 
+#if USE_SSL_CRTD
 Ssl::Helper * Ssl::Helper::GetInstance()
 {
     static Ssl::Helper sslHelper;
@@ -105,3 +106,91 @@ void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void
     msg += '\n';
     helperSubmit(ssl_crtd, msg.c_str(), callback, data);
 }
+#endif //USE_SSL_CRTD
+
+#if 1 // USE_SSL_CERT_VALIDATOR
+/*ssl_crtd_validator*/
+
+Ssl::CertValidationHelper * Ssl::CertValidationHelper::GetInstance()
+{
+    static Ssl::CertValidationHelper sslHelper;
+    if (!Ssl::TheConfig.ssl_crt_validator)
+        return NULL;
+    return &sslHelper;
+}
+
+Ssl::CertValidationHelper::CertValidationHelper() : ssl_crt_validator(NULL)
+{
+}
+
+Ssl::CertValidationHelper::~CertValidationHelper()
+{
+    Shutdown();
+}
+
+void Ssl::CertValidationHelper::Init()
+{
+    assert(ssl_crt_validator == NULL);
+
+    // we need to start ssl_crtd only if some port(s) need to bump SSL
+    bool found = false;
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; !found && s; s = s->next)
+        found = s->sslBump;
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.https; !found && s; s = s->next)
+        found = s->sslBump;
+    if (!found)
+        return;
+
+    ssl_crt_validator = new helper("ssl_crt_validator");
+    ssl_crt_validator->childs.updateLimits(Ssl::TheConfig.ssl_crt_validator_Children);
+    ssl_crt_validator->ipc_type = IPC_STREAM;
+    // The crtd messages may contain the eol ('\n') character. We are
+    // going to use the '\1' char as the end-of-message mark.
+    ssl_crt_validator->eom = '\1';
+    assert(ssl_crt_validator->cmdline == NULL);
+    {
+        char *tmp = xstrdup(Ssl::TheConfig.ssl_crt_validator);
+        char *tmp_begin = tmp;
+        char * token = NULL;
+        while ((token = strwordtok(NULL, &tmp))) {
+            wordlistAdd(&ssl_crt_validator->cmdline, token);
+        }
+        xfree(tmp_begin);
+    }
+    helperOpenServers(ssl_crt_validator);
+}
+
+void Ssl::CertValidationHelper::Shutdown()
+{
+    if (!ssl_crt_validator)
+        return;
+    helperShutdown(ssl_crt_validator);
+    wordlistDestroy(&ssl_crt_validator->cmdline);
+    delete ssl_crt_validator;
+    ssl_crt_validator = NULL;
+}
+
+void Ssl::CertValidationHelper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void * data)
+{
+    static time_t first_warn = 0;
+    assert(ssl_crt_validator);
+
+    if (ssl_crt_validator->stats.queue_size >= (int)(ssl_crt_validator->childs.n_running * 2)) {
+        if (first_warn == 0)
+            first_warn = squid_curtime;
+        if (squid_curtime - first_warn > 3 * 60)
+            fatal("ssl_crtvd queue being overloaded for long time");
+        debugs(83, DBG_IMPORTANT, "WARNING: ssl_crtvd queue overload, rejecting");
+        HelperReply failReply;
+        failReply.result = HelperReply::BrokenHelper;
+        failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
+        callback(data, failReply);
+        return;
+    }
+
+    first_warn = 0;
+    std::string msg = message.compose();
+    msg += '\n';
+    helperSubmit(ssl_crt_validator, msg.c_str(), callback, data);
+}
+#endif // USE_SSL_CERT_VALIDATOR
@@ -11,6 +11,7 @@ namespace Ssl
  * over GetIntance() static method. This class use helper structure
  * for threads management.
  */
+#if USE_SSL_CRTD
 class Helper
 {
 public:
@@ -25,6 +26,24 @@ class Helper
 
     helper * ssl_crtd; ///< helper for management of ssl_crtd.
 };
+#endif
+
+#if 1 // USE_SSL_CERT_VALIDATOR
+class CertValidationHelper
+{
+public:
+    static CertValidationHelper * GetInstance(); ///< Instance class.
+    void Init(); ///< Init helper structure.
+    void Shutdown(); ///< Shutdown helper structure.
+    /// Submit crtd message to external crtd server.
+    void sslSubmit(CrtdMessage const & message, HLPCB * callback, void *data);
+private:
+    CertValidationHelper();
+    ~CertValidationHelper();
+
+    helper * ssl_crt_validator; ///< helper for management of ssl_crtd.
+};
+#endif // USE_SSL_CERT_VALIDATOR
 
 } //namespace Ssl
 #endif // SQUID_SSL_HELPER_H
@@ -43,6 +43,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "SquidConfig.h"
+#include "ssl/Config.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/support.h"
 #include "ssl/gadgets.h"
@@ -287,6 +288,12 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
             delete filledCheck->sslErrors;
             filledCheck->sslErrors = NULL;
         }
+#if 1 // USE_SSL_CERT_VALIDATOR
+        // If the certificate validator is used then we need to allow all errors and 
+        // pass them to certficate validator for more processing
+        else if (Ssl::TheConfig.ssl_crt_validator)
+            ok = 1;
+#endif
     }
 
     if (!dont_verify_domain && server) {}
@@ -37,7 +37,7 @@ void Ssl::GlobalContextStorage::reconfigureStart() STUB
 #include "ssl/ErrorDetail.h"
 Ssl::ssl_error_t parseErrorString(const char *name) STUB_RETVAL(0)
 //const char *Ssl::getErrorName(ssl_error_t value) STUB_RETVAL(NULL)
-Ssl::ErrorDetail::ErrorDetail(ssl_error_t err_no, X509 *, X509 *) STUB
+Ssl::ErrorDetail::ErrorDetail(ssl_error_t err_no, X509 *, X509 *, const char *) STUB
 Ssl::ErrorDetail::ErrorDetail(ErrorDetail const &) STUB
 const String & Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 