@@ -1,12 +1,4 @@
 
-/* DEBUG: section 00    Hash Tables */
-/* DEBUG: section 81    CPU Profiling Routines */
-section
-section --    CGI Cache Manager
-section --    External DISKD process implementation.
-section --    Refcount allocator
-section --    Unlink Daemon
-section --    WWW Client
 section 00    Announcement Server
 section 00    Client Database
 section 00    Debug Routines
@@ -57,14 +49,14 @@ section 21    Time Functions
 section 22    Refresh Calculation
 section 23    URL Parsing
 section 23    URL Scheme parsing
-section 25    MIME Parsing and Internal Icons
 section 25    MiME Header Parsing
+section 25    MIME Parsing and Internal Icons
 section 26    Secure Sockets Layer Proxy
 section 27    Cache Announcer
 section 28    Access Control
 section 29    Authenticator
-section 29    NTLM Authenticator
 section 29    Negotiate Authenticator
+section 29    NTLM Authenticator
 section 30    Ident (RFC 931)
 section 31    Hypertext Caching Protocol
 section 32    Asynchronous Disk I/O
@@ -86,8 +78,8 @@ section 46    Access Log
 section 46    Access Log - Apache combined format
 section 46    Access Log - Apache common format
 section 46    Access Log - Squid Custom format
-section 46    Access Log - Squid ICAP Logging
 section 46    Access Log - Squid format
+section 46    Access Log - Squid ICAP Logging
 section 46    Access Log - Squid referer format
 section 46    Access Log - Squid useragent format
 section 47    Store Directory Routines
@@ -129,11 +121,10 @@ section 79    Disk IO Routines
 section 79    Squid-side DISKD I/O functions.
 section 79    Squid-side Disk I/O functions.
 section 79    Storage Manager UFS Interface
-section 79   Disk IO Routines
 section 80    WCCP Support
+section 81    aio_xxx() POSIX emulation on Windows
 section 81    CPU Profiling Routines
 section 81    Store HEAP Removal Policies
-section 81    aio_xxx() POSIX emulation on Windows
 section 82    External ACL
 section 83    SSL accelerator support
 section 84    Helper process maintenance
@@ -149,5 +140,8 @@ section 90    HTTP Cache Control Header
 section 90    Storage Manager Client-Side Interface
 section 92    Storage File System
 section 93    Adaptation
-section 93    ICAP (RFC 3507) Client
 section 93    eCAP Interface
+section 93    ICAP (RFC 3507) Client
+section --    External DISKD process implementation.
+section --    Refcount allocator
+section --    Unlink Daemon
@@ -2,8 +2,8 @@ TRANSLATE_LANGUAGES= \
     ar.lang \
     cs.lang \
     de.lang \
-    en.lang \
     en_AU.lang \
+    en.lang \
     es.lang \
     fr.lang \
     it.lang \
@@ -14,8 +14,8 @@ ICONS= \
     silk/database.png \
     silk/database_table.png \
     silk/drive_disk.png \
-    silk/film.png \
     silk/film_key.png \
+    silk/film.png \
     silk/folder.png \
     silk/folder_table.png \
     silk/image.png \
@@ -24,18 +24,18 @@ ICONS= \
     silk/layout.png \
     silk/link.png \
     silk/music.png \
-    silk/package.png \
     silk/package_go.png \
+    silk/package.png \
     silk/page_code.png \
     silk/page_excel.png \
     silk/page_green.png \
-    silk/page_white.png \
     silk/page_white_acrobat.png \
-    silk/page_white_c.png \
     silk/page_white_cplusplus.png \
+    silk/page_white_c.png \
     silk/page_white_flash.png \
     silk/page_white_magnify.png \
     silk/page_white_picture.png \
+    silk/page_white.png \
     silk/page_white_powerpoint.png \
     silk/page_white_stack.png \
     silk/page_white_text.png \
@@ -44,8 +44,8 @@ ICONS= \
     silk/page_world.png \
     silk/photo.png \
     silk/picture.png \
-    silk/plugin.png \
     silk/plugin_add.png \
-    silk/script.png \
+    silk/plugin.png \
     silk/script_gear.png \
-    silk/script_palette.png 
+    silk/script_palette.png \
+    silk/script.png 
@@ -3,79 +3,78 @@
 /* AUTO-GENERATED FILE */
 #if USE_XPROF_STATS
 typedef enum {
-    XPROF_PROF_UNACCOUNTED,
-    XPROF_ACL_matches,
-    XPROF_HttpHeaderClean,
-    XPROF_HttpHeaderParse,
-    XPROF_HttpHeader_getCc,
-    XPROF_HttpMsg_httpMsgParseStep,
-    XPROF_HttpParserParseReqLine,
-    XPROF_HttpServer_parseOneRequest,
-    XPROF_HttpStateData_processReplyBody,
-    XPROF_HttpStateData_processReplyHeader,
-    XPROF_HttpStateData_readReply,
-    XPROF_InvokeHandlers,
-    XPROF_MemBuf_append,
-    XPROF_MemBuf_consume,
-    XPROF_MemBuf_consumeWhitespace,
-    XPROF_MemBuf_grow,
-    XPROF_MemObject_write,
-    XPROF_PROF_OVERHEAD,
-    XPROF_SignalEngine_checkEvents,
-    XPROF_StoreEntry_write,
-    XPROF_StringAllocAndFill,
-    XPROF_StringAppend,
-    XPROF_StringClean,
-    XPROF_StringInitBuf,
-    XPROF_StringReset,
-    XPROF_aclCheckFast,
-    XPROF_calloc,
-    XPROF_clientSocketRecipient,
-    XPROF_commHandleWrite,
-    XPROF_comm_accept,
-    XPROF_comm_check_incoming,
-    XPROF_comm_close,
-    XPROF_comm_connect_addr,
-    XPROF_comm_handle_ready_fd,
-    XPROF_comm_open,
-    XPROF_comm_poll_normal,
-    XPROF_comm_poll_prep_pfds,
-    XPROF_comm_read_handler,
-    XPROF_comm_udp_sendto,
-    XPROF_comm_write_handler,
-    XPROF_diskHandleRead,
-    XPROF_diskHandleWrite,
-    XPROF_esiExpressionEval,
-    XPROF_esiParsing,
-    XPROF_esiProcessing,
-    XPROF_eventRun,
-    XPROF_file_close,
-    XPROF_file_open,
-    XPROF_file_read,
-    XPROF_file_write,
-    XPROF_free,
-    XPROF_free_const,
-    XPROF_hash_lookup,
-    XPROF_headersEnd,
-    XPROF_httpRequestFree,
-    XPROF_httpStart,
-    XPROF_malloc,
-    XPROF_mem_hdr_write,
-    XPROF_read,
-    XPROF_realloc,
-    XPROF_recv,
-    XPROF_send,
-    XPROF_storeClient_kickReads,
-    XPROF_storeDirCallback,
-    XPROF_storeGet,
-    XPROF_storeGetMemSpace,
-    XPROF_storeMaintainSwapSpace,
-    XPROF_storeRelease,
-    XPROF_write,
-    XPROF_xcalloc,
-    XPROF_xmalloc,
-    XPROF_xrealloc,
-    XPROF_LAST
-} xprof_type;
+XPROF_PROF_UNACCOUNTED,
+XPROF_aclCheckFast,
+XPROF_ACL_matches,
+XPROF_calloc,
+XPROF_clientSocketRecipient,
+XPROF_comm_accept,
+XPROF_comm_check_incoming,
+XPROF_comm_close,
+XPROF_comm_connect_addr,
+XPROF_comm_handle_ready_fd,
+XPROF_commHandleWrite,
+XPROF_comm_open,
+XPROF_comm_poll_normal,
+XPROF_comm_poll_prep_pfds,
+XPROF_comm_read_handler,
+XPROF_comm_udp_sendto,
+XPROF_comm_write_handler,
+XPROF_diskHandleRead,
+XPROF_diskHandleWrite,
+XPROF_esiExpressionEval,
+XPROF_esiParsing,
+XPROF_esiProcessing,
+XPROF_eventRun,
+XPROF_file_close,
+XPROF_file_open,
+XPROF_file_read,
+XPROF_file_write,
+XPROF_free,
+XPROF_free_const,
+XPROF_hash_lookup,
+XPROF_headersEnd,
+XPROF_HttpHeaderClean,
+XPROF_HttpHeader_getCc,
+XPROF_HttpHeaderParse,
+XPROF_HttpMsg_httpMsgParseStep,
+XPROF_HttpParserParseReqLine,
+XPROF_httpRequestFree,
+XPROF_HttpServer_parseOneRequest,
+XPROF_httpStart,
+XPROF_HttpStateData_processReplyBody,
+XPROF_HttpStateData_processReplyHeader,
+XPROF_HttpStateData_readReply,
+XPROF_InvokeHandlers,
+XPROF_malloc,
+XPROF_MemBuf_append,
+XPROF_MemBuf_consume,
+XPROF_MemBuf_consumeWhitespace,
+XPROF_MemBuf_grow,
+XPROF_mem_hdr_write,
+XPROF_MemObject_write,
+XPROF_PROF_OVERHEAD,
+XPROF_read,
+XPROF_realloc,
+XPROF_recv,
+XPROF_send,
+XPROF_SignalEngine_checkEvents,
+XPROF_storeClient_kickReads,
+XPROF_storeDirCallback,
+XPROF_StoreEntry_write,
+XPROF_storeGet,
+XPROF_storeGetMemSpace,
+XPROF_storeMaintainSwapSpace,
+XPROF_storeRelease,
+XPROF_StringAllocAndFill,
+XPROF_StringAppend,
+XPROF_StringClean,
+XPROF_StringInitBuf,
+XPROF_StringReset,
+XPROF_write,
+XPROF_xcalloc,
+XPROF_xmalloc,
+XPROF_xrealloc,
+  XPROF_LAST } xprof_type;
 #endif
 #endif
@@ -145,3 +145,8 @@ make_snapshot ../commit/squid-3/mksnapshot.sh 3.3 v3 3.3 30
 #make_snapshot ../commit/squid-2.5/mksnapshot.sh SQUID_2_5 v2 2.5 3
 
 #../commit/squid3-SQUID2.sync
+
+
+../commit/bootstrap squid-3.5
+make_snapshot ../commit/squid-3/mksnapshot.sh 3.5 v3 3.5 30
+
@@ -10,6 +10,8 @@
 #define SQUID_EXTERNALACL_H
 
 #include "acl/Checklist.h"
+#include "base/RefCount.h"
+
 class external_acl;
 class StoreEntry;
 
@@ -29,7 +31,7 @@ class ExternalACLLookup : public ACLChecklist::AsyncState
 
 private:
     static ExternalACLLookup instance_;
-    static void LookupDone(void *data, void *result);
+    static void LookupDone(void *data, const ExternalACLEntryPointer &result);
 };
 
 #include "acl/Acl.h"
@@ -73,7 +75,7 @@ MEMPROXY_CLASS_INLINE(ACLExternal);
 void parse_externalAclHelper(external_acl **);
 void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 void free_externalAclHelper(external_acl **);
-typedef void EAH(void *data, void *result);
+typedef void EAH(void *data, const ExternalACLEntryPointer &result);
 void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
 void externalAclInit(void);
 void externalAclShutdown(void);
@@ -16,8 +16,6 @@
  * external_acl cache
  */
 
-CBDATA_CLASS_INIT(ExternalACLEntry);
-
 ExternalACLEntry::ExternalACLEntry() :
         notes()
 {
@@ -12,7 +12,7 @@
 #define SQUID_EXTERNALACLENTRY_H
 
 #include "acl/Acl.h"
-#include "cbdata.h"
+#include "acl/forward.h"
 #include "hash.h"
 #include "Notes.h"
 #include "SquidString.h"
@@ -51,9 +51,8 @@ class ExternalACLEntryData
  * Used opaqueue in the interface
  */
 
-class ExternalACLEntry: public hash_link
+class ExternalACLEntry: public hash_link, public RefCountable
 {
-
 public:
     ExternalACLEntry();
     ~ExternalACLEntry();
@@ -75,10 +74,9 @@ class ExternalACLEntry: public hash_link
     String log;
     external_acl *def;
 
-private:
-    CBDATA_CLASS2(ExternalACLEntry);
+    MEMPROXY_CLASS(ExternalACLEntry);
 };
 
-typedef class ExternalACLEntry external_acl_entry;
+MEMPROXY_CLASS_INLINE(ExternalACLEntry);
 
 #endif
@@ -476,6 +476,7 @@ class SquidConfig
         char *ssl_engine;
         int session_ttl;
         size_t sessionCacheSize;
+        char *certSignHash;
     } SSL;
 #endif
 
@@ -11,6 +11,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "comm/forward.h"
+#include "ExternalACLEntry.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -35,7 +36,6 @@ ACLFilledChecklist::ACLFilledChecklist() :
 #if USE_OPENSSL
         sslErrors(NULL),
 #endif
-        extacl_entry (NULL),
         conn_(NULL),
         fd_(-1),
         destinationDomainChecked_(false),
@@ -53,9 +53,6 @@ ACLFilledChecklist::~ACLFilledChecklist()
 
     safe_free(dst_rdns); // created by xstrdup().
 
-    if (extacl_entry)
-        cbdataReferenceDone(extacl_entry);
-
     HTTPMSGUNLOCK(request);
 
     HTTPMSGUNLOCK(reply);
@@ -151,7 +148,6 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
 #if USE_OPENSSL
         sslErrors(NULL),
 #endif
-        extacl_entry (NULL),
         conn_(NULL),
         fd_(-1),
         destinationDomainChecked_(false),
@@ -12,6 +12,7 @@
 #include "AccessLogEntry.h"
 #include "acl/Checklist.h"
 #include "acl/forward.h"
+#include "base/CbcPointer.h"
 #include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -22,7 +23,6 @@
 
 class CachePeer;
 class ConnStateData;
-class ExternalACLEntry;
 class HttpRequest;
 class HttpReply;
 
@@ -86,7 +86,7 @@ class ACLFilledChecklist: public ACLChecklist
 
     AccessLogEntry::Pointer al; ///< info for the future access.log entry
 
-    ExternalACLEntry *extacl_entry;
+    ExternalACLEntryPointer extacl_entry;
 
 private:
     ConnStateData * conn_;          /**< hack for ident and NTLM */
@@ -9,6 +9,8 @@
 #ifndef SQUID_ACL_FORWARD_H
 #define SQUID_ACL_FORWARD_H
 
+#include "base/RefCount.h"
+
 class ACL;
 class ACLChecklist;
 class ACLFilledChecklist;
@@ -39,4 +41,7 @@ typedef void ACLCB(allow_t, void *);
 #define acl_access Acl::Tree
 #define ACLList Acl::Tree
 
+class ExternalACLEntry;
+typedef RefCount<ExternalACLEntry> ExternalACLEntryPointer;
+
 #endif /* SQUID_ACL_FORWARD_H */
@@ -11,6 +11,7 @@
 
 #include "base/TextException.h"
 #include "cbdata.h"
+#include "Debug.h"
 
 /**
  \ingroup CBDATAAPI
@@ -120,6 +121,9 @@ template<class Cbc>
 void
 CbcPointer<Cbc>::clear()
 {
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, "cbc=" << (void*)cbc << ", lock=" << (void*)lock);
+#endif
     cbdataReferenceDone(lock); // lock may be nil before and will be nil after
     cbc = NULL;
 }
@@ -294,9 +294,9 @@ cbdataInternalAlloc(cbdata_type type)
     c->calls = std::vector<CBDataCall *> ();
     c->addHistory("Alloc", file, line);
     dlinkAdd(c, &c->link, &cbdataEntries);
-    debugs(45, 3, "cbdataAlloc: " << p << " " << file << ":" << line);
+    debugs(45, 3, "Allocating " << p << " " << file << ":" << line);
 #else
-    debugs(45, 9, "cbdataAlloc: " << p);
+    debugs(45, 9, "Allocating " << p);
 #endif
 
     return p;
@@ -316,11 +316,9 @@ cbdataInternalFree(void *p)
     c = (cbdata *) (((char *) p) - cbdata::Offset);
 #endif
 #if USE_CBDATA_DEBUG
-
-    debugs(45, 3, "cbdataFree: " << p << " " << file << ":" << line);
+    debugs(45, 3, p << " " << file << ":" << line);
 #else
-
-    debugs(45, 9, "cbdataFree: " << p);
+    debugs(45, 9, p);
 #endif
 
     c->check(__LINE__);
@@ -332,12 +330,12 @@ cbdataInternalFree(void *p)
 #endif
 
     if (c->locks) {
-        debugs(45, 9, "cbdataFree: " << p << " has " << c->locks << " locks, not freeing");
+        debugs(45, 9, p << " has " << c->locks << " locks, not freeing");
         return NULL;
     }
 
     --cbdataCount;
-    debugs(45, 9, "cbdataFree: Freeing " << p);
+    debugs(45, 9, "Freeing " << p);
 #if USE_CBDATA_DEBUG
 
     dlinkDelete(&c->link, &cbdataEntries);
@@ -356,9 +354,15 @@ cbdataInternalFree(void *p)
     cbdata_type theType = c->type;
 #if HASHED_CBDATA
     hash_remove_link(cbdata_htable, &c->hash);
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, "Call delete " << (void*)c << " " << file << ":" << line);
+#endif
     delete c;
     cbdata_index[theType].pool->freeOne((void *)p);
 #else
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, "Call cbdata::~cbdata() " << (void*)c << " " << file << ":" << line);
+#endif
     c->cbdata::~cbdata();
     cbdata_index[theType].pool->freeOne(c);
 #endif
@@ -384,15 +388,10 @@ cbdataInternalLock(const void *p)
 #endif
 
 #if USE_CBDATA_DEBUG
-
-    debugs(45, 3, "cbdataLock: " << p << "=" << (c ? c->locks + 1 : -1) << " " << file << ":" << line);
-
+    debugs(45, 3, p << "=" << (c ? c->locks + 1 : -1) << " " << file << ":" << line);
     c->addHistory("Reference", file, line);
-
 #else
-
-    debugs(45, 9, "cbdataLock: " << p << "=" << (c ? c->locks + 1 : -1));
-
+    debugs(45, 9, p << "=" << (c ? c->locks + 1 : -1));
 #endif
 
     c->check(__LINE__);
@@ -421,15 +420,10 @@ cbdataInternalUnlock(const void *p)
 #endif
 
 #if USE_CBDATA_DEBUG
-
-    debugs(45, 3, "cbdataUnlock: " << p << "=" << (c ? c->locks - 1 : -1) << " " << file << ":" << line);
-
+    debugs(45, 3, p << "=" << (c ? c->locks - 1 : -1) << " " << file << ":" << line);
     c->addHistory("Dereference", file, line);
-
 #else
-
-    debugs(45, 9, "cbdataUnlock: " << p << "=" << (c ? c->locks - 1 : -1));
-
+    debugs(45, 9, p << "=" << (c ? c->locks - 1 : -1));
 #endif
 
     c->check(__LINE__);
@@ -445,7 +439,7 @@ cbdataInternalUnlock(const void *p)
 
     --cbdataCount;
 
-    debugs(45, 9, "cbdataUnlock: Freeing " << p);
+    debugs(45, 9, "Freeing " << p);
 
 #if USE_CBDATA_DEBUG
 
@@ -466,9 +460,15 @@ cbdataInternalUnlock(const void *p)
     cbdata_type theType = c->type;
 #if HASHED_CBDATA
     hash_remove_link(cbdata_htable, &c->hash);
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, "Call delete " << (void*)c << " " << file << ":" << line);
+#endif
     delete c;
     cbdata_index[theType].pool->freeOne((void *)p);
 #else
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, "Call cbdata::~cbdata() " << (void*)c << " " << file << ":" << line);
+#endif
     c->cbdata::~cbdata();
     cbdata_index[theType].pool->freeOne(c);
 #endif
@@ -482,7 +482,7 @@ cbdataReferenceValid(const void *p)
     if (p == NULL)
         return 1;		/* A NULL pointer cannot become invalid */
 
-    debugs(45, 9, "cbdataReferenceValid: " << p);
+    debugs(45, 9, p);
 
 #if HASHED_CBDATA
     c = (cbdata *) hash_lookup(cbdata_htable, p);
@@ -2505,6 +2505,24 @@ DOC_START
         Sets the cache size to use for ssl session
 DOC_END
 
+NAME: sslproxy_cert_sign_hash
+IFDEF: USE_OPENSSL
+DEFAULT: none
+LOC: Config.SSL.certSignHash
+TYPE: string
+DOC_START
+	Sets the hashing algorithm to use when signing generated certificates.
+	Valid algorithm names depend on the OpenSSL library used. The following
+	names are usually available: sha1, sha256, sha512, and md5. Please see
+	your OpenSSL library manual for the available hashes. By default, Squids
+	that support this option use sha256 hashes.
+
+	Squid does not forcefully purge cached certificates that were generated
+	with an algorithm other than the currently configured one. They remain
+	in the cache, subject to the regular cache eviction policy, and become
+	useful if the algorithm changes again.
+DOC_END
+
 NAME: ssl_bump
 IFDEF: USE_OPENSSL
 TYPE: sslproxy_ssl_bump
@@ -3973,6 +3973,8 @@ void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &cer
             certProperties.signWithPkey.resetAndLock(port->signPkey.get());
     }
     signAlgorithm = certProperties.signAlgorithm;
+
+    certProperties.signHash = Ssl::DefaultSignHash;
 }
 
 void
@@ -56,11 +56,11 @@
 #endif
 
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
-static void external_acl_cache_delete(external_acl * def, external_acl_entry * entry);
-static int external_acl_entry_expired(external_acl * def, external_acl_entry * entry);
-static int external_acl_grace_expired(external_acl * def, external_acl_entry * entry);
-static void external_acl_cache_touch(external_acl * def, external_acl_entry * entry);
-static external_acl_entry *external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
+static void external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry);
+static int external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry);
+static int external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry);
+static void external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry);
+static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
 
 /******************************************************************
  * external_acl directive
@@ -94,7 +94,7 @@ class external_acl
 public:
     external_acl *next;
 
-    void add(ExternalACLEntry *);
+    void add(const ExternalACLEntryPointer &);
 
     void trimCache();
 
@@ -163,8 +163,10 @@ free_external_acl(void *data)
         p->theHelper = NULL;
     }
 
-    while (p->lru_list.tail)
-        external_acl_cache_delete(p, static_cast<external_acl_entry *>(p->lru_list.tail->data));
+    while (p->lru_list.tail) {
+        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(p->lru_list.tail->data));
+        external_acl_cache_delete(p, e);
+    }
     if (p->cache)
         hashFreeMemory(p->cache);
 }
@@ -580,21 +582,26 @@ find_externalAclHelper(const char *name)
 }
 
 void
-external_acl::add(ExternalACLEntry *anEntry)
+external_acl::add(const ExternalACLEntryPointer &anEntry)
 {
     trimCache();
+    assert(anEntry != NULL);
     assert (anEntry->def == NULL);
     anEntry->def = this;
-    hash_join(cache, anEntry);
-    dlinkAdd(anEntry, &anEntry->lru, &lru_list);
+    ExternalACLEntry *e = const_cast<ExternalACLEntry *>(anEntry.getRaw()); // XXX: make hash a std::map of Pointer.
+    hash_join(cache, e);
+    dlinkAdd(e, &e->lru, &lru_list);
+    e->lock(); //cbdataReference(e); // lock it on behalf of the hash
     ++cache_entries;
 }
 
 void
 external_acl::trimCache()
 {
-    if (cache_size && cache_entries >= cache_size)
-        external_acl_cache_delete(this, static_cast<external_acl_entry *>(lru_list.tail->data));
+    if (cache_size && cache_entries >= cache_size) {
+        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(lru_list.tail->data));
+        external_acl_cache_delete(this, e);
+    }
 }
 
 /******************************************************************
@@ -681,7 +688,7 @@ ACLExternal::~ACLExternal()
 }
 
 static void
-copyResultsFromEntry(HttpRequest *req, external_acl_entry *entry)
+copyResultsFromEntry(HttpRequest *req, const ExternalACLEntryPointer &entry)
 {
     if (req) {
 #if USE_AUTH
@@ -706,32 +713,30 @@ static allow_t
 aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 {
     debugs(82, 9, HERE << "acl=\"" << acl->def->name << "\"");
-    external_acl_entry *entry = ch->extacl_entry;
+    ExternalACLEntryPointer entry = ch->extacl_entry;
 
     external_acl_message = "MISSING REQUIRED INFORMATION";
 
-    if (entry) {
-        if (cbdataReferenceValid(entry) && entry->def == acl->def) {
+    if (entry != NULL) {
+        if (entry->def == acl->def) {
             /* Ours, use it.. if the key matches */
             const char *key = makeExternalAclKey(ch, acl);
             if (!key)
                 return ACCESS_DUNNO; // insufficent data to continue
             if (strcmp(key, (char*)entry->key) != 0) {
-                debugs(82, 9, HERE << "entry key='" << (char *)entry->key << "', our key='" << key << "' dont match. Discarded.");
+                debugs(82, 9, "entry key='" << (char *)entry->key << "', our key='" << key << "' dont match. Discarded.");
                 // too bad. need a new lookup.
-                cbdataReferenceDone(ch->extacl_entry);
-                entry = NULL;
+                entry = ch->extacl_entry = NULL;
             }
         } else {
-            /* Not valid, or not ours.. get rid of it */
-            debugs(82, 9, HERE << "entry " << entry << " not valid or not ours. Discarded.");
-            if (entry) {
-                debugs(82, 9, HERE << "entry def=" << entry->def << ", our def=" << acl->def);
+            /* Not ours.. get rid of it */
+            debugs(82, 9, "entry " << entry << " not valid or not ours. Discarded.");
+            if (entry != NULL) {
+                debugs(82, 9, "entry def=" << entry->def << ", our def=" << acl->def);
                 const char *key = makeExternalAclKey(ch, acl); // may be nil
-                debugs(82, 9, HERE << "entry key='" << (char *)entry->key << "', our key='" << key << "'");
+                debugs(82, 9, "entry key='" << (char *)entry->key << "', our key='" << key << "'");
             }
-            cbdataReferenceDone(ch->extacl_entry);
-            entry = NULL;
+            entry = ch->extacl_entry = NULL;
         }
     }
 
@@ -756,13 +761,13 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
             return ACCESS_DUNNO;
         }
 
-        entry = static_cast<external_acl_entry *>(hash_lookup(acl->def->cache, key));
+        entry = static_cast<ExternalACLEntry *>(hash_lookup(acl->def->cache, key));
 
-        external_acl_entry *staleEntry = entry;
-        if (entry && external_acl_entry_expired(acl->def, entry))
+        const ExternalACLEntryPointer staleEntry = entry;
+        if (entry != NULL && external_acl_entry_expired(acl->def, entry))
             entry = NULL;
 
-        if (entry && external_acl_grace_expired(acl->def, entry)) {
+        if (entry != NULL && external_acl_grace_expired(acl->def, entry)) {
             // refresh in the background
             ExternalACLLookup::Start(ch, acl, true);
             debugs(82, 4, HERE << "no need to wait for the refresh of '" <<
@@ -771,8 +776,6 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 
         if (!entry) {
             debugs(82, 2, HERE << acl->def->name << "(\"" << key << "\") = lookup needed");
-            debugs(82, 2, HERE << "\"" << key << "\": entry=@" <<
-                   entry << ", age=" << (entry ? (long int) squid_curtime - entry->date : 0));
 
             if (acl->def->theHelper->stats.queue_size < (int)acl->def->theHelper->childs.n_active) {
                 debugs(82, 2, HERE << "\"" << key << "\": queueing a call.");
@@ -858,14 +861,15 @@ ACLExternal::dump() const
  */
 
 static void
-external_acl_cache_touch(external_acl * def, external_acl_entry * entry)
+external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     // this must not be done when nothing is being cached.
     if (def->cache_size <= 0 || (def->ttl <= 0 && entry->result == 1) || (def->negative_ttl <= 0 && entry->result != 1))
         return;
 
     dlinkDelete(&entry->lru, &def->lru_list);
-    dlinkAdd(entry, &entry->lru, &def->lru_list);
+    ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
+    dlinkAdd(e, &entry->lru, &def->lru_list);
 }
 
 static char *
@@ -1166,7 +1170,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 }
 
 static int
-external_acl_entry_expired(external_acl * def, external_acl_entry * entry)
+external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;
@@ -1178,7 +1182,7 @@ external_acl_entry_expired(external_acl * def, external_acl_entry * entry)
 }
 
 static int
-external_acl_grace_expired(external_acl * def, external_acl_entry * entry)
+external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;
@@ -1193,10 +1197,10 @@ external_acl_grace_expired(external_acl * def, external_acl_entry * entry)
         return 0;
 }
 
-static external_acl_entry *
+static ExternalACLEntryPointer
 external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const & data)
 {
-    ExternalACLEntry *entry;
+    ExternalACLEntryPointer entry;
 
     // do not bother caching this result if TTL is going to expire it immediately
     if (def->cache_size <= 0 || (def->ttl <= 0 && data.result == 1) || (def->negative_ttl <= 0 && data.result != 1)) {
@@ -1211,11 +1215,10 @@ external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData
     entry = static_cast<ExternalACLEntry *>(hash_lookup(def->cache, key));
     debugs(82, 2, "external_acl_cache_add: Adding '" << key << "' = " << data.result);
 
-    if (entry) {
-        debugs(82, 3, "ExternalACLEntry::update: updating existing entry");
+    if (entry != NULL) {
+        debugs(82, 3, "updating existing entry");
         entry->update(data);
         external_acl_cache_touch(def, entry);
-
         return entry;
     }
 
@@ -1229,13 +1232,15 @@ external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData
 }
 
 static void
-external_acl_cache_delete(external_acl * def, external_acl_entry * entry)
+external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry)
 {
+    assert(entry != NULL);
     assert(def->cache_size > 0 && entry->def == def);
-    hash_remove_link(def->cache, entry);
-    dlinkDelete(&entry->lru, &def->lru_list);
+    ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
+    hash_remove_link(def->cache, e);
+    dlinkDelete(&e->lru, &def->lru_list);
+    e->unlock(); // unlock on behalf of the hash
     def->cache_entries -= 1;
-    delete entry;
 }
 
 /******************************************************************
@@ -1292,7 +1297,6 @@ externalAclHandleReply(void *data, const Helper::Reply &reply)
     externalAclState *next;
     ExternalACLEntryData entryData;
     entryData.result = ACCESS_DENIED;
-    external_acl_entry *entry = NULL;
 
     debugs(82, 2, HERE << "reply=" << reply);
 
@@ -1328,14 +1332,15 @@ externalAclHandleReply(void *data, const Helper::Reply &reply)
 
     dlinkDelete(&state->list, &state->def->queue);
 
+    ExternalACLEntryPointer entry;
     if (cbdataReferenceValid(state->def)) {
         // only cache OK and ERR results.
         if (reply.result == Helper::Okay || reply.result == Helper::Error)
             entry = external_acl_cache_add(state->def, state->key, entryData);
         else {
-            external_acl_entry *oldentry = (external_acl_entry *)hash_lookup(state->def->cache, state->key);
+            const ExternalACLEntryPointer oldentry = static_cast<ExternalACLEntry *>(hash_lookup(state->def->cache, state->key));
 
-            if (oldentry)
+            if (oldentry != NULL)
                 external_acl_cache_delete(state->def, oldentry);
         }
     }
@@ -1523,13 +1528,13 @@ ExternalACLLookup::checkForAsync(ACLChecklist *checklist)const
 
 /// Called when an async lookup returns
 void
-ExternalACLLookup::LookupDone(void *data, void *result)
+ExternalACLLookup::LookupDone(void *data, const ExternalACLEntryPointer &result)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
-    checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
+    checklist->extacl_entry = result;
 
     // attach the helper kv-pair to the transaction
-    if (checklist->extacl_entry) {
+    if (checklist->extacl_entry != NULL) {
         if (HttpRequest * req = checklist->request) {
             // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
             // workaround by using anything already set in HttpRequest
@@ -44,7 +44,8 @@ Ssl::PeerConnector::PeerConnector(
         clientConn(aClientConn),
         callback(aCallback),
         negotiationTimeout(timeout),
-        startTime(squid_curtime)
+        startTime(squid_curtime),
+        splice(false)
 {
     // if this throws, the caller's cb dialer is not our CbDialer
     Must(dynamic_cast<CbDialer*>(callback->getDialer()));
@@ -230,6 +231,25 @@ Ssl::PeerConnector::negotiateSsl()
         return; // we might be gone by now
     }
 
+    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
+        if (serverConnection()->getPeer()->sslSession)
+            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
+
+        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
+    }
+
+    if (!sslFinalized())
+        return;
+
+    callBack();
+}
+
+bool
+Ssl::PeerConnector::sslFinalized()
+{
+    const int fd = serverConnection()->fd;
+    SSL *ssl = fd_table[fd].ssl;
+
     if (request->clientConnectionManager.valid()) {
         // remember the server certificate from the ErrorDetail object
         if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
@@ -241,13 +261,6 @@ Ssl::PeerConnector::negotiateSsl()
         }
     }
 
-    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
-        if (serverConnection()->getPeer()->sslSession)
-            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
-
-        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
-    }
-
     if (Ssl::TheConfig.ssl_crt_validator) {
         Ssl::CertValidationRequest validationRequest;
         // WARNING: Currently we do not use any locking for any of the
@@ -264,7 +277,7 @@ Ssl::PeerConnector::negotiateSsl()
         try {
             debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
             Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, sslCrtvdHandleReplyWrapper, this);
-            return;
+            return false;
         } catch (const std::exception &e) {
             debugs(83, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
                    "request for " << validationRequest.domainName <<
@@ -277,14 +290,13 @@ Ssl::PeerConnector::negotiateSsl()
                 peerConnectFailed(serverConnection()->getPeer());
             }
             serverConn->close();
-            return;
+            return true;
         }
     }
-
-    callBack();
+    return true;
 }
 
-void switchToTunnel(HttpRequest *request, int *status_ptr, Comm::ConnectionPointer & clientConn, Comm::ConnectionPointer &srvConn);
+void switchToTunnel(HttpRequest *request, Comm::ConnectionPointer & clientConn, Comm::ConnectionPointer &srvConn);
 
 void
 Ssl::PeerConnector::cbCheckForPeekAndSpliceDone(allow_t answer, void *data)
@@ -346,9 +358,11 @@ Ssl::PeerConnector::checkForPeekAndSpliceDone(Ssl::BumpMode const action)
         Comm::SetSelect(serverConn->fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
         debugs(83,5, "Retry the fwdNegotiateSSL on FD " << serverConn->fd);
     } else {
-        static int status_code = 0;
-        debugs(83,5, "Revert to tunnel FD " << clientConn->fd << " with FD " << serverConn->fd);
-        switchToTunnel(request.getRaw(), &status_code, clientConn, serverConn);
+        splice = true;
+        // Ssl Negotiation stops here. Last SSL checks for valid certificates 
+        // and if done, switch to tunnel mode
+        if (sslFinalized())
+            switchToTunnel(request.getRaw(), clientConn, serverConn);
     }
 }
 
@@ -377,7 +391,10 @@ Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse const &valid
         validatorFailed = true;
 
     if (!errDetails && !validatorFailed) {
-        callBack();
+        if (splice)
+            switchToTunnel(request.getRaw(), clientConn, serverConn);
+        else
+            callBack();
         return;
     }
 
@@ -116,6 +116,11 @@ class PeerConnector: virtual public AsyncJob
     /// It is called multiple times untill the negotiation finish or aborted.
     void negotiateSsl();
 
+    /// Called after SSL negotiations have finished. Cleans up SSL state.
+    /// Returns false if we are now waiting for the certs validation job.
+    /// Otherwise, returns true, regardless of negotiation success/failure.
+    bool sslFinalized();
+
     /// Initiates the ssl_bump acl check in step3 SSL bump step to decide
     /// about bumping, splicing or terminating the connection.
     void checkForPeekAndSplice();
@@ -165,6 +170,7 @@ class PeerConnector: virtual public AsyncJob
     AsyncCall::Pointer closeHandler; ///< we call this when the connection closed
     time_t negotiationTimeout; ///< the ssl connection timeout to use
     time_t startTime; ///< when the peer connector negotiation started
+    bool splice; ///< Whether we are going to splice or not
 
     CBDATA_CLASS2(PeerConnector);
 };
@@ -206,12 +206,21 @@ bool Ssl::CrtdMessage::parseRequest(Ssl::CertificateProperties &certProperties,
     i = map.find(Ssl::CrtdMessage::param_Sign);
     if (i != map.end()) {
         if ((certProperties.signAlgorithm = Ssl::certSignAlgorithmId(i->second.c_str())) == Ssl::algSignEnd) {
-            error = "Wrong signing algoritm: " + i->second;
+            error = "Wrong signing algoritm: ";
+            error += i->second;
             return false;
         }
     } else
         certProperties.signAlgorithm = Ssl::algSignTrusted;
 
+    i = map.find(Ssl::CrtdMessage::param_SignHash);
+    const char *signHashName = i != map.end() ? i->second.c_str() : SQUID_SSL_SIGN_HASH_IF_NONE;
+    if (!(certProperties.signHash = EVP_get_digestbyname(signHashName))) {
+        error = "Wrong signing hash: ";
+        error += signHashName;
+        return false;
+    }
+
     if (!Ssl::readCertAndPrivateKeyFromMemory(certProperties.signWithX509, certProperties.signWithPkey, certs_part.c_str())) {
         error = "Broken signing certificate!";
         return false;
@@ -239,6 +248,8 @@ void Ssl::CrtdMessage::composeRequest(Ssl::CertificateProperties const &certProp
         body +=  "\n" + Ssl::CrtdMessage::param_SetValidBefore + "=on";
     if (certProperties.signAlgorithm != Ssl::algSignEnd)
         body +=  "\n" +  Ssl::CrtdMessage::param_Sign + "=" +  certSignAlgorithm(certProperties.signAlgorithm);
+    if (certProperties.signHash)
+        body +=  "\n" + Ssl::CrtdMessage::param_SignHash + "=" + EVP_MD_name(certProperties.signHash);
 
     std::string certsPart;
     if (!Ssl::writeCertAndPrivateKeyToMemory(certProperties.signWithX509, certProperties.signWithPkey, certsPart))
@@ -256,3 +267,4 @@ const std::string Ssl::CrtdMessage::param_SetValidAfter(Ssl::CertAdaptAlgorithmS
 const std::string Ssl::CrtdMessage::param_SetValidBefore(Ssl::CertAdaptAlgorithmStr[algSetValidBefore]);
 const std::string Ssl::CrtdMessage::param_SetCommonName(Ssl::CertAdaptAlgorithmStr[algSetCommonName]);
 const std::string Ssl::CrtdMessage::param_Sign("Sign");
+const std::string Ssl::CrtdMessage::param_SignHash("SignHash");
@@ -84,6 +84,8 @@ class CrtdMessage
     static const std::string param_SetCommonName;
     /// Parameter name for passing signing algorithm
     static const std::string param_Sign;
+    /// The signing hash to use
+    static const std::string param_SignHash;
 protected:
     enum ParseState {
         BEFORE_CODE,
@@ -221,7 +221,8 @@ Ssl::CertificateProperties::CertificateProperties():
         setValidAfter(false),
         setValidBefore(false),
         setCommonName(false),
-        signAlgorithm(Ssl::algSignEnd)
+        signAlgorithm(Ssl::algSignEnd),
+        signHash(NULL)
 {}
 
 std::string & Ssl::CertificateProperties::dbKey() const
@@ -255,6 +256,11 @@ std::string & Ssl::CertificateProperties::dbKey() const
         certKey.append(certSignAlgorithm(signAlgorithm));
     }
 
+    if (signHash != NULL) {
+        certKey.append("+SignHash=", 10);
+        certKey.append(EVP_MD_name(signHash));
+    }
+
     return certKey;
 }
 
@@ -434,11 +440,13 @@ static bool generateFakeSslCertificate(Ssl::X509_Pointer & certToStore, Ssl::EVP
     if (!ret)
         return false;
 
+    const  EVP_MD *hash = properties.signHash ? properties.signHash : EVP_get_digestbyname(SQUID_SSL_SIGN_HASH_IF_NONE);
+    assert(hash);
     /*Now sign the request */
     if (properties.signAlgorithm != Ssl::algSignSelf && properties.signWithPkey.get())
-        ret = X509_sign(cert.get(), properties.signWithPkey.get(), EVP_sha1());
+        ret = X509_sign(cert.get(), properties.signWithPkey.get(), hash);
     else //else sign with self key (self signed request)
-        ret = X509_sign(cert.get(), pkey.get(), EVP_sha1());
+        ret = X509_sign(cert.get(), pkey.get(), hash);
 
     if (!ret)
         return false;
@@ -34,6 +34,10 @@ typedef const SSL_METHOD * ContextMethod;
 typedef SSL_METHOD * ContextMethod;
 #endif
 
+#if !defined(SQUID_SSL_SIGN_HASH_IF_NONE)
+#define SQUID_SSL_SIGN_HASH_IF_NONE "sha256"
+#endif
+
 /**
    \ingroup SslCrtdSslAPI
   * Add SSL locking (a.k.a. reference counting) to TidyPointer
@@ -234,6 +238,7 @@ class CertificateProperties
     bool setCommonName; ///< Replace the CN field of the mimicing subject with the given
     std::string commonName; ///< A CN to use for the generated certificate
     CertSignAlgorithm signAlgorithm; ///< The signing algorithm to use
+    const EVP_MD *signHash; ///< The signing hash to use
     /// Returns certificate database primary key. New fake certificates
     /// purge old fake certificates with the same key.
     std::string & dbKey() const;
@@ -7,8 +7,8 @@
  */
 
 #include "squid.h"
-#include "anyp/PortCfg.h"
 #include "../helper.h"
+#include "anyp/PortCfg.h"
 #include "helper/Reply.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
@@ -295,6 +295,9 @@ int main(int argc, char *argv[])
         {
             Ssl::CertificateDb::check(db_path, max_db_size);
         }
+        // Initialize SSL subsystem
+        SSL_load_error_strings();
+        SSLeay_add_ssl_algorithms();
         // proccess request.
         for (;;) {
             char request[HELPER_INPUT_BUFFER];
@@ -36,6 +36,8 @@ static void setSessionCallbacks(SSL_CTX *ctx);
 Ipc::MemMap *SslSessionCache = NULL;
 const char *SslSessionCacheName = "ssl_session_cache";
 
+const EVP_MD *Ssl::DefaultSignHash = NULL;
+
 const char *Ssl::BumpModeStr[] = {
     "none",
     "client-first",
@@ -718,6 +720,11 @@ ssl_initialize(void)
         fatalf("Your OpenSSL has no SSL engine support\n");
 #endif
 
+    const char *defName = Config.SSL.certSignHash ? Config.SSL.certSignHash : SQUID_SSL_SIGN_HASH_IF_NONE;
+    Ssl::DefaultSignHash = EVP_get_digestbyname(defName);
+    if (!Ssl::DefaultSignHash)
+        fatalf("Sign hash '%s' is not supported\n", defName);
+
     ssl_ex_index_server = SSL_get_ex_new_index(0, (void *) "server", NULL, NULL, NULL);
     ssl_ctx_ex_index_dont_verify_domain = SSL_CTX_get_ex_new_index(0, (void *) "dont_verify_domain", NULL, NULL, NULL);
     ssl_ex_index_cert_error_check = SSL_get_ex_new_index(0, (void *) "cert_error_check", NULL, &ssl_dupAclChecklist, &ssl_freeAclChecklist);
@@ -132,6 +132,8 @@ GETX509ATTRIBUTE GetX509CAAttribute;
 /// \ingroup ServerProtocolSSLAPI
 GETX509ATTRIBUTE GetX509Fingerprint;
 
+extern const EVP_MD *DefaultSignHash;
+
 /**
   \ingroup ServerProtocolSSLAPI
  * Supported ssl-bump modes
@@ -1,74 +1,74 @@
 STUB_SOURCE= tests/STUB.h \
-	tests/stub_CacheDigest.cc \
-	tests/stub_CollapsedForwarding.cc \
-	tests/stub_CommIO.cc \
-	tests/stub_DelayId.cc \
-	tests/stub_DiskIOModule.cc \
-	tests/stub_ETag.cc \
-	tests/stub_EventLoop.cc \
-	tests/stub_HelperChildConfig.cc \
-	tests/stub_HttpReply.cc \
-	tests/stub_HttpRequest.cc \
-	tests/stub_MemBuf.cc \
-	tests/stub_MemObject.cc \
-	tests/stub_MemStore.cc \
-	tests/stub_Port.cc \
-	tests/stub_SBuf.cc \
-	tests/stub_SBufDetailedStats.cc \
-	tests/stub_StatHist.cc \
-	tests/stub_StoreMeta.cc \
-	tests/stub_SwapDir.cc \
-	tests/stub_UdsOp.cc \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	tests/stub_cache_cf.cc \
+	tests/stub_CacheDigest.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_carp.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_client_db.cc \
 	tests/stub_client_side.cc \
 	tests/stub_client_side_request.cc \
+	tests/stub_CollapsedForwarding.cc \
 	tests/stub_comm.cc \
+	tests/stub_CommIO.cc \
 	tests/stub_debug.cc \
+	tests/stub_DelayId.cc \
+	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
+	tests/stub_ETag.cc \
 	tests/stub_event.cc \
+	tests/stub_EventLoop.cc \
 	tests/stub_external_acl.cc \
 	tests/stub_fatal.cc \
 	tests/stub_fd.cc \
 	tests/stub_helper.cc \
+	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_HttpReply.cc \
+	tests/stub_HttpRequest.cc \
 	tests/stub_icp.cc \
 	tests/stub_internal.cc \
+	tests/stub_ipcache.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_ipc_TypedMsgHdr.cc \
-	tests/stub_ipcache.cc \
-	tests/stub_libauth.cc \
 	tests/stub_libauth_acls.cc \
+	tests/stub_libauth.cc \
 	tests/stub_libcomm.cc \
 	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_libsslsquid.cc \
 	tests/stub_main_cc.cc \
+	tests/stub_MemBuf.cc \
 	tests/stub_mem.cc \
 	tests/stub_mem_node.cc \
+	tests/stub_MemObject.cc \
+	tests/stub_MemStore.cc \
 	tests/stub_mime.cc \
 	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
+	tests/stub_Port.cc \
 	tests/stub_redirect.cc \
+	tests/stub_SBuf.cc \
+	tests/stub_SBufDetailedStats.cc \
 	tests/stub_stat.cc \
+	tests/stub_StatHist.cc \
 	tests/stub_stmem.cc \
 	tests/stub_store.cc \
 	tests/stub_store_client.cc \
 	tests/stub_store_digest.cc \
+	tests/stub_StoreMeta.cc \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_store_swapout.cc \
+	tests/stub_SwapDir.cc \
 	tests/stub_time.cc \
 	tests/stub_tools.cc \
 	tests/stub_tunnel.cc \
+	tests/stub_UdsOp.cc \
 	tests/stub_wccp2.cc \
 	tests/stub_whois.cc \
 	tests/stub_wordlist.cc 
@@ -28,4 +28,4 @@ void externalAclInit(void) STUB_NOP
 void externalAclShutdown(void) STUB_NOP
 ExternalACLLookup * ExternalACLLookup::Instance() STUB_RETVAL(NULL)
 void ExternalACLLookup::checkForAsync(ACLChecklist *) const STUB
-void ExternalACLLookup::LookupDone(void *, void *) STUB
+void ExternalACLLookup::LookupDone(void *, const ExternalACLEntryPointer &) STUB
@@ -75,4 +75,4 @@ int getMyPort(void) STUB_RETVAL(0)
 void setUmask(mode_t mask) STUB
 void strwordquote(MemBuf * mb, const char *str) STUB
 void keepCapabilities(void) STUB
-void restoreCapabilities(int keep) STUB
+void restoreCapabilities(bool keep) STUB
@@ -16,5 +16,5 @@ class ClientHttpRequest;
 
 void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntryPointer &al) STUB
 
-void switchToTunnel(HttpRequest *request, int *status_ptr, Comm::ConnectionPointer &clientConn, Comm::ConnectionPointer &srvConn) STUB
+void switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::ConnectionPointer &srvConn) STUB
 
@@ -58,7 +58,7 @@ and report the trace back to squid-bugs@squid-cache.org.\n\
 Thanks!\n"
 
 static void mail_warranty(void);
-static void restoreCapabilities(int keep);
+static void restoreCapabilities(bool keep);
 int DebugSignal = -1;
 SBuf service_name(APP_SHORTNAME);
 
@@ -593,7 +593,7 @@ leave_suid(void)
 
 #endif
 
-    restoreCapabilities(1);
+    restoreCapabilities(true);
 
 #if HAVE_PRCTL && defined(PR_SET_DUMPABLE)
     /* Set Linux DUMPABLE flag */
@@ -641,7 +641,7 @@ no_suid(void)
     if (setuid(uid) < 0)
         debugs(50, DBG_IMPORTANT, "ERROR: no_suid: setuid(" << uid << "): " << xstrerror());
 
-    restoreCapabilities(0);
+    restoreCapabilities(false);
 
 #if HAVE_PRCTL && defined(PR_SET_DUMPABLE)
     /* Set Linux DUMPABLE flag */
@@ -1210,7 +1210,7 @@ keepCapabilities(void)
 }
 
 static void
-restoreCapabilities(int keep)
+restoreCapabilities(bool keep)
 {
     /* NP: keep these two if-endif separate. Non-Linux work perfectly well without Linux syscap support. */
 #if USE_LIBCAP
@@ -1093,9 +1093,9 @@ TunnelStateData::Connection::setDelayId(DelayId const &newDelay)
 
 #if USE_OPENSSL
 void
-switchToTunnel(HttpRequest *request, int *status_ptr, Comm::ConnectionPointer &clientConn, Comm::ConnectionPointer &srvConn)
+switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::ConnectionPointer &srvConn)
 {
-    debugs(26, 3, HERE);
+    debugs(26,5, "Revert to tunnel FD " << clientConn->fd << " with FD " << srvConn->fd);
     /* Create state structure. */
     TunnelStateData *tunnelState = NULL;
     const char *url = urlCanonical(request);
@@ -1108,7 +1108,10 @@ switchToTunnel(HttpRequest *request, int *status_ptr, Comm::ConnectionPointer &c
     tunnelState->url = xstrdup(url);
     tunnelState->request = request;
     tunnelState->server.size_ptr = NULL; //Set later if ClientSocketContext is available
-    tunnelState->status_ptr = status_ptr;
+
+    // Temporary static variable to store the unneeded for our case status code 
+    static int status_code = 0;
+    tunnelState->status_ptr = &status_code;
     tunnelState->client.conn = clientConn;
 
     ConnStateData *conn;