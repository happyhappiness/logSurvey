@@ -3,7 +3,7 @@
 
 AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5 foreign
 DIST_SUBDIRS	= lib snmplib scripts src icons errors contrib doc helpers test-suite tools
-SUBDIRS		= lib @makesnmplib@ scripts src/ip src icons errors doc helpers test-suite tools
+SUBDIRS		= src/compat lib @makesnmplib@ scripts src/ip src icons errors doc helpers test-suite tools
 
 DISTCLEANFILES = include/stamp-h include/stamp-h[0-9]*
 DEFAULT_PINGER		= $(libexecdir)/`echo pinger | sed '$(transform);s/$$/$(EXEEXT)/'`
@@ -3815,6 +3815,7 @@ AC_CONFIG_FILES([\
 	scripts/RunCache \
 	scripts/RunAccel \
 	src/Makefile \
+	src/compat/Makefile \
 	src/fs/Makefile \
 	src/repl/Makefile \
 	src/auth/Makefile \
@@ -1,5 +1,5 @@
 /*
- * $Id: assert.h,v 1.3 2006/05/12 21:52:24 hno Exp $
+ * $Id$
  *
  * AUTHOR: Duane Wessels
  *
@@ -1,5 +1,5 @@
 /*
- * $Id: config.h,v 1.27 2008/01/07 15:47:08 hno Exp $
+ * $Id$
  *
  * AUTHOR: Duane Wessels
  *
@@ -55,6 +55,8 @@
  *--------------------------------------------------------------------------*
  ****************************************************************************/
 
+#include "compat/compat.h"
+
 #ifdef USE_POSIX_REGEX
 #ifndef USE_RE_SYNTAX
 #define USE_RE_SYNTAX	REG_EXTENDED	/* default Syntax */
@@ -143,64 +145,6 @@
 */
 #endif
 
-/* FD_SETSIZE must be redefined before including sys/types.h */
-
-/*
- * On some systems, FD_SETSIZE is set to something lower than the
- * actual number of files which can be opened.  IRIX is one case,
- * NetBSD is another.  So here we increase FD_SETSIZE to our
- * configure-discovered maximum *before* any system includes.
- */
-#define CHANGE_FD_SETSIZE 1
-
-/*
- * Cannot increase FD_SETSIZE on Linux, but we can increase __FD_SETSIZE
- * with glibc 2.2 (or later? remains to be seen). We do this by including
- * bits/types.h which defines __FD_SETSIZE first, then we redefine
- * __FD_SETSIZE. Ofcourse a user program may NEVER include bits/whatever.h
- * directly, so this is a dirty hack!
- */
-#if defined(_SQUID_LINUX_)
-#undef CHANGE_FD_SETSIZE
-#define CHANGE_FD_SETSIZE 0
-#include <features.h>
-#if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)
-#if SQUID_MAXFD > DEFAULT_FD_SETSIZE
-#include <bits/types.h>
-#undef __FD_SETSIZE
-#define __FD_SETSIZE SQUID_MAXFD
-#endif
-#endif
-#endif
-
-/*
- * Cannot increase FD_SETSIZE on FreeBSD before 2.2.0, causes select(2)
- * to return EINVAL.
- * --Marian Durkovic <marian@svf.stuba.sk>
- * --Peter Wemm <peter@spinner.DIALix.COM>
- */
-#if defined(_SQUID_FREEBSD_)
-#include <osreldate.h>
-#if __FreeBSD_version < 220000
-#undef CHANGE_FD_SETSIZE
-#define CHANGE_FD_SETSIZE 0
-#endif
-#endif
-
-/*
- * Trying to redefine CHANGE_FD_SETSIZE causes a slew of warnings
- * on Mac OS X Server.
- */
-#if defined(_SQUID_APPLE_)
-#undef CHANGE_FD_SETSIZE
-#define CHANGE_FD_SETSIZE 0
-#endif
-
-/* Increase FD_SETSIZE if SQUID_MAXFD is bigger */
-#if CHANGE_FD_SETSIZE && SQUID_MAXFD > DEFAULT_FD_SETSIZE
-#define FD_SETSIZE SQUID_MAXFD
-#endif
-
 /* Typedefs for missing entries on a system */
 
 #include "squid_types.h"
@@ -108,7 +108,7 @@ libntlmauth_a_LIBADD = \
 libsspwin32_a_SOURCES = \
 	sspwin32.c
 
-INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include @SQUID_CPPUNIT_INC@
+INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include @SQUID_CPPUNIT_INC@ -I$(top_srcdir)/src
 ##FIXME - set these in configure.in and reuse
 
 check_PROGRAMS= \
@@ -10,7 +10,7 @@ libsnmp_a_SOURCES  = asn1.c parse.c snmp_vars.c \
 	mib.c snmp_api_error.c   \
 	snmp_msg.c \
 	snmp_pdu.c  snmplib_debug.c
-INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include
+INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/src
 
 VERSION		= 3.4
 DEFS		= -DSQUID_SNMP=1
@@ -1,10 +1,28 @@
-/*
- * $Id: GNUregex.h,v 1.9 2003/08/03 22:53:47 hno Exp $
- */
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
 #ifndef SQUID_REGEXP_LIBRARY_H
 #define SQUID_REGEXP_LIBRARY_H
 
-#include "config.h"
+#if !USE_GNUREGEX /* try the system one by default */
+
+/* POSIX says that <sys/types.h> must be included (by the caller) before
+ * <regex.h>.  */
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_REGEX_H
+#include <regex.h>
+#endif
+
+
+#else  /* USE_GNUREGEX */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
 
 /* Definitions for data structures and routines for the regular
  * expression library, version 0.12.
@@ -405,6 +423,11 @@ extern size_t regerror
               size_t errbuf_size));
 extern void regfree _RE_ARGS((regex_t * preg));
 
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* USE_GNUREGEX */
 #endif /* SQUID_REGEXP_LIBRARY_H */
 
 /*
@@ -0,0 +1,68 @@
+#
+#  Makefile for the Squid Portability Library
+#
+
+# Housekeeping, shared by all Squid Makefiles.
+# TODO: make this set by configure?
+AM_CFLAGS = @SQUID_CFLAGS@
+AM_CXXFLAGS = @SQUID_CXXFLAGS@
+DEFS = @DEFS@
+CLEANFILES = 
+
+INCLUDES = -I$(top_srcdir)/src @SQUID_CPPUNIT_INC@ -I$(top_srcdir)/include -I$(top_builddir)/lib
+$(OBJS): $(top_srcdir)/include/version.h $(top_srcdir)/include/autoconf.h
+
+# Ideally this would be 100% inline functions and macro wrappers.
+
+# Port Specific Configurations
+
+noinst_LTLIBRARIES = libcompat.la
+
+libcompat_la_SOURCES = \
+	compat.h \
+	osdetect.h \
+	compat_shared.h \
+	squid_fdsetsize.h \
+	\
+	os/squid_aix.h \
+	os/squid_freebsd.h \
+	os/squid_hpux.h \
+	os/squid_linux.h \
+	os/squid_mswin.h \
+	os/squid_next.h \
+	os/squid_openbsd.h \
+	os/squid_qnx.h \
+	os/squid_sgi.h \
+	os/squid_solaris.h \
+	os/squid_sunos.h \
+	os/squid_windows.h \
+	\
+	compat.cc
+
+
+check_PROGRAMS= testHeaders
+TESTS= $(check_PROGRAMS)
+
+## Special Universal .h dependency test script
+## aborts if error encountered
+testHeaders: $(top_srcdir)/src/compat/*.h $(top_srcdir)/src/compat/os/*.h
+	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "$(top_srcdir)/src/compat/" || exit 1
+	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "$(top_srcdir)/src/compat/os/" || exit 1
+
+## No such file...
+testHeaders.c:
+	touch testHeaders.c
+CLEANFILES += testHeaders.c
+
+#
+#testIpAddress_SOURCES= \
+#	testIpAddress.cc \
+#	testIpAddress.h
+#nodist_testIpAddress_SOURCES= \
+#	../tests/testMain.cc
+#testIpAddress_LDADD= \
+#	libip.la \
+#	-L$(top_builddir)/lib -lmiscutil \
+#	@SQUID_CPPUNIT_LA@ \
+#	@SQUID_CPPUNIT_LIBS@
+#testIpAddress_LDFLAGS= $(LIBADD_DL)
@@ -0,0 +1,50 @@
+/*
+ * $Id$
+ *
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef SQUID_ASSERT_H
+#define SQUID_ASSERT_H
+
+#if defined(NODEBUG)
+#define assert(EX) ((void)0)
+#elif STDC_HEADERS
+#define assert(EX)  ((EX)?((void)0):xassert( # EX , __FILE__, __LINE__))
+#else
+#define assert(EX)  ((EX)?((void)0):xassert("EX", __FILE__, __LINE__))
+#endif
+SQUIDCEXTERN void xassert(const char *, const char *, int);
+
+#endif /* SQUID_ASSERT_H */
@@ -0,0 +1,91 @@
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef _SQUID_COMPAT_H
+#define _SQUID_COMPAT_H
+
+/*
+ * From discussions it was chosen to push compat code as far down as possible.
+ * That means we can eventually have a seperate libcompat for most
+ *  compatability and portability hacks and resolutions.
+ * 
+ * This file is meant to collate all those hacks files together and
+ * provide a simple include form them in the core squid headers
+ * (presently squid.h and config.h) 
+ *
+ * It should not be included directly in any of the squid sources.
+ * If your code requires any symbols from here you should be importing
+ * squid.h at the top line of your .cc or .h file.
+ */
+
+
+/******************************************************/
+/* Define the _SQUID_TYPE_ based on a guess of the OS */
+/* NP: this MUST come first within compat.h           */
+/******************************************************/
+#include "compat/osdetect.h"
+
+
+/*****************************************************/
+/* FDSETSIZE is messy and needs to be done before    */
+/* sys/types.h are defined.                          */
+/*****************************************************/
+#include "compat/squid_fdsetsize.h"
+
+
+/*****************************************************/
+/* Global type re-definitions                        */
+/* this also takes care of the basic system includes */
+/*****************************************************/
+
+/** On linux this must be defined to get PRId64 and friends */
+#define __STDC_FORMAT_MACROS
+
+#include "squid_types.h"
+
+/*****************************************************/
+/* per-OS hacks. One file per OS.                    */
+/* OS-macro wrapping should be done inside the OS .h */
+/*****************************************************/
+
+#include "os/squid_aix.h"
+#include "os/squid_freebsd.h"
+#include "os/squid_hpux.h"
+#include "os/squid_linux.h"
+#include "os/squid_mswin.h"
+#include "os/squid_next.h"
+#include "os/squid_openbsd.h"
+#include "os/squid_qnx.h"
+#include "os/squid_sgi.h"
+#include "os/squid_solaris.h"
+#include "os/squid_windows.h"
+
+/*****************************************************/
+/* portabilities shared between all platforms and    */
+/* components as found to be needed                  */
+/*****************************************************/
+
+#include "compat_shared.h"
+#include "squid_stdvarargs.h"
+#include "compat/assert.h"
+
+/*****************************************************/
+/* component-specific portabilities                  */
+/*****************************************************/
+
+/* Valgrind API macros changed between two versions squid supports */
+#include "squid_valgrind.h"
+
+/* Endian functions are usualy handled by the OS but not always. */
+#include "squid_endian.h"
+
+/**
+ * A Regular Expression library is bundled with Squid.
+ * Default is to use a system provided one, but the bundle
+ * may be used instead with explicit configuration.
+ */
+#include "compat/GnuRegex.h"
+
+
+#endif /* _SQUID_COMPAT_H */
@@ -0,0 +1,206 @@
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef _SQUID_COMPAT_SHARED_H
+#define _SQUID_COMPAT_SHARED_H
+
+/*
+ * This file contains all the compatibility and portability hacks
+ * Which are general-case and shared between all OS and support programs.
+ * 
+ * If an OS-specific hack is needed there are per-OS files for that in
+ * the os/ sub-directory here.
+ *
+ * These hacks should be platform and location agnostic.
+ * A quick look-over of the code already here should give you an idea
+ * of the requirements for wrapping your hack for safe portability.
+ */
+
+
+/*
+ * sys/resource.h and sys/time.h are apparently order-dependant.
+ */
+#if HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#if HAVE_SYS_RESOURCE_H
+#include <sys/resource.h>       /* needs sys/time.h above it */
+#endif
+
+/*
+ * DIRENT functionality can apparently come from many places.
+ * I believe these should really be done by OS-specific compat
+ * files, but for now its left here.
+ */
+#if HAVE_DIRENT_H
+#include <dirent.h>
+#define NAMLEN(dirent) strlen((dirent)->d_name)
+
+#else /* if not HAVE_DIRENT_H */
+#define dirent direct
+#define NAMLEN(dirent) (dirent)->d_namlen
+#if HAVE_SYS_NDIR_H
+#include <sys/ndir.h>
+#endif /* HAVE_SYS_NDIR_H */
+#if HAVE_SYS_DIR_H
+#include <sys/dir.h>
+#endif /* HAVE_SYS_DIR_H */
+#if HAVE_NDIR_H
+#include <ndir.h>
+#endif /* HAVE_NDIR_H */
+#endif /* HAVE_DIRENT_H */
+
+
+/*
+ * Filedescriptor limits in the different select loops
+ */
+#if defined(USE_SELECT) || defined(USE_SELECT_WIN32)
+/* Limited by design */
+# define SQUID_MAXFD_LIMIT FD_SETSIZE
+
+#elif defined(USE_POLL)
+/* Limited due to delay pools */
+# define SQUID_MAXFD_LIMIT FD_SETSIZE
+
+#elif defined(USE_KQUEUE) || defined(USE_EPOLL)
+# define SQUID_FDSET_NOUSE 1
+
+#else
+# error Unknown select loop model!
+#endif
+
+
+
+#if !HAVE_STRUCT_RUSAGE
+/**
+ * If we don't have getrusage() then we create a fake structure
+ * with only the fields Squid cares about.  This just makes the
+ * source code cleaner, so we don't need lots of #ifdefs in other
+ * places
+ */
+struct rusage
+{
+    struct timeval ru_stime;
+    struct timeval ru_utime;
+    int ru_maxrss;
+    int ru_majflt;
+};
+#endif /* !HAVE_STRUCT_RUSAGE */
+
+
+/* templates require C++ */
+#ifdef __cplusplus
+
+#ifndef min
+/**
+ * min() comparison may not always be provided.
+ * Squid bundles this template for when its needed.
+ * May be used on any type which provides operator '<'
+ */
+template<class A>
+inline A const &
+min(A const & lhs, A const & rhs)
+{
+    if (rhs < lhs)
+        return rhs;
+    return lhs;
+}
+#endif
+#define XMIN(x,y) (min (x,y))
+
+#ifndef max
+/**
+ * max() comparison may not always be provided.
+ * Squid bundles this template for when its needed.
+ * May be used on any type which provides operator '>'
+ */
+template<class A>
+inline A const &
+max(A const & lhs, A const & rhs)
+{
+    if (rhs > lhs)
+        return rhs;
+    return lhs;
+}
+#endif
+#define XMAX(a,b) (max (a,b))
+
+#endif /* __cplusplus */
+
+/**
+ * tempnam() not provided by all systems
+ * TODO: detect WHICH systems and move to their OS-specific compat files
+ */
+#if !HAVE_TEMPNAM
+#include "tempnam.h"
+#endif
+
+/**
+ * strsep() not provided by all systems
+ * TODO: detect WHICH systems and move to their OS-specific compat files
+ */
+#if !HAVE_STRSEP
+#include "strsep.h"
+#endif
+
+/**
+ * strtoll() not provided by all systems
+ * TODO: detect WHICH systems and move to their OS-specific compat files
+ */
+#if !HAVE_STRTOLL
+#include "strtoll.h"
+#endif
+
+/**
+ * Common shared definition of what whitespace consists of for string tests
+ */
+#define w_space     " \t\n\r"
+
+/**
+ * initgroups() not provided by all systems
+ * TODO: detect WHICH systems and move to their OS-specific compat files
+ */
+#if !HAVE_INITGROUPS
+#include "initgroups.h"
+#endif
+
+
+/* REQUIRED for the below logics. If they move this needs to as well */
+#if HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+#if defined(O_NONBLOCK)
+/**
+ * We used to assume O_NONBLOCK was broken on Solaris, but evidence
+ * now indicates that its fine on Solaris 8, and in fact required for
+ * properly detecting EOF on FIFOs.  So now we assume that if
+ * its defined, it works correctly on all operating systems.
+ */
+#define SQUID_NONBLOCK O_NONBLOCK
+#else
+/** O_NDELAY is our fallback. */
+#define SQUID_NONBLOCK O_NDELAY
+#endif
+
+
+/**
+ * Signalling flags are apparently not always provided.
+ * TODO find out if these can be moved into specific OS portability files.
+ */
+#ifndef SA_RESTART
+#define SA_RESTART 0
+#endif
+#ifndef SA_NODEFER
+#define SA_NODEFER 0
+#endif
+#ifndef SA_RESETHAND
+#define SA_RESETHAND 0
+#endif
+#if SA_RESETHAND == 0 && defined(SA_ONESHOT)
+#undef SA_RESETHAND
+#define SA_RESETHAND SA_ONESHOT
+#endif
+
+
+#endif /* _SQUID_COMPAT_SHARED_H */
@@ -0,0 +1,27 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_AIX_H
+#define SQUID_OS_AIX_H
+
+#ifdef _SQUID_AIX_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+
+/*
+ * Syslog facility on AIX requires some portability wrappers
+ */
+#ifdef HAVE_SYSLOG_H
+#define _XOPEN_EXTENDED_SOURCE
+#define _XOPEN_SOURCE_EXTENDED 1
+#endif
+
+
+#endif /* _SQUID_AIX_ */
+#endif /* SQUID_OS_AIX_H */
@@ -0,0 +1,31 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_FREEBSD_H
+#define SQUID_OS_FREEBSD_H
+
+#ifdef _SQUID_FREEBSD_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+
+#if USE_ASYNC_IO && defined(LINUXTHREADS)
+#define _SQUID_LINUX_THREADS_
+#endif
+
+/*
+ * Don't allow inclusion of malloc.h
+ */
+#if defined(HAVE_MALLOC_H)
+#undef HAVE_MALLOC_H
+#endif
+
+#define _etext etext
+
+#endif /* _SQUID_FREEBSD_ */
+#endif /* SQUID_OS_FREEBSD_H */
@@ -0,0 +1,32 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_HPUX_H
+#define SQUID_OS_PHUX_H
+
+#ifdef _SQUID_HPUX_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+
+#if !defined(HAVE_GETPAGESIZE)
+#define HAVE_GETPAGESIZE
+#define getpagesize( )   sysconf(_SC_PAGE_SIZE)
+#endif
+
+/*
+ * getrusage(...) not available on some HPUX
+ */
+#if !HAVE_GETRUSAGE
+#define HAVE_GETRUSAGE 1
+#define getrusage(a, b)  syscall(SYS_GETRUSAGE, a, b)
+#endif
+
+
+#endif /* _SQUID_HPUX_ */
+#endif /* SQUID_OS_HPUX_H */
@@ -0,0 +1,31 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_LINUX_H
+#define SQUID_OS_LINUX_H
+
+#ifdef _SQUID_LINUX_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+
+#if USE_ASYNC_IO
+#define _SQUID_LINUX_THREADS_
+#endif
+
+/*
+ * res_init() is just a macro re-definition of __res_init on Linux (Debian/Ubuntu)
+ */
+#if !defined(HAVE_RES_INIT) && defined(HAVE___RES_INIT) && !defined(res_init)
+#define res_init  __res_init
+#define HAVE_RES_INIT  HAVE___RES_INIT
+#endif
+
+
+#endif /* _SQUID_LINUX_ */
+#endif /* SQUID_OS_LINUX_H */
@@ -0,0 +1,768 @@
+/*
+ * $Id$
+ *
+ * AUTHOR: Andrey Shorin <tolsty@tushino.com>
+ * AUTHOR: Guido Serassio <serassio@squid-cache.org>
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_MSWIN_H
+#define SQUID_OS_MSWIN_H
+
+#ifdef _SQUID_WIN32_
+
+#define ACL WindowsACL
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#if _MSC_VER == 1400
+#define _CRT_SECURE_NO_DEPRECATE
+#pragma warning( disable : 4290 )
+#pragma warning( disable : 4996 )
+#endif
+#endif
+
+#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
+# define __USE_FILE_OFFSET64	1
+#endif
+
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned __int64 uint64_t;
+
+typedef long pid_t;
+
+#if defined __USE_FILE_OFFSET64
+typedef int64_t off_t;
+typedef uint64_t ino_t;
+
+#else
+typedef long off_t;
+typedef unsigned long ino_t;
+
+#endif
+
+#define INT64_MAX _I64_MAX
+#define INT64_MIN _I64_MIN
+
+#include "default_config_file.h"
+/* Some tricks for MS Compilers */
+#define __STDC__ 1
+#define THREADLOCAL __declspec(thread)
+
+#elif defined(__GNUC__) /* gcc environment */
+
+#define THREADLOCAL __attribute__((section(".tls")))
+
+#endif
+
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#define alloca _alloca
+#endif
+#define chdir _chdir
+#define dup _dup
+#define dup2 _dup2
+#define fdopen _fdopen
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#define fileno _fileno
+#define fstat _fstati64
+#endif
+#define ftruncate WIN32_ftruncate
+#define getcwd _getcwd
+#define getpid _getpid
+#define getrusage WIN32_getrusage
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#define lseek _lseeki64
+#define memccpy _memccpy
+#define mkdir(p) _mkdir(p)
+#define mktemp _mktemp
+#endif
+#define pclose _pclose
+#define pipe WIN32_pipe
+#define popen _popen
+#define putenv _putenv
+#define setmode _setmode
+#define sleep(t) Sleep((t)*1000)
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#define snprintf _snprintf
+#define stat _stati64
+#define strcasecmp _stricmp
+#define strdup _strdup
+#define strlwr _strlwr
+#define strncasecmp _strnicmp
+#define tempnam _tempnam
+#endif
+#define truncate WIN32_truncate
+#define umask _umask
+#define unlink _unlink
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#define vsnprintf _vsnprintf
+#endif
+
+#define O_RDONLY        _O_RDONLY
+#define O_WRONLY        _O_WRONLY
+#define O_RDWR          _O_RDWR
+#define O_APPEND        _O_APPEND
+
+#define O_CREAT         _O_CREAT
+#define O_TRUNC         _O_TRUNC
+#define O_EXCL          _O_EXCL
+
+#define O_TEXT          _O_TEXT
+#define O_BINARY        _O_BINARY
+#define O_RAW           _O_BINARY
+#define O_TEMPORARY     _O_TEMPORARY
+#define O_NOINHERIT     _O_NOINHERIT
+#define O_SEQUENTIAL    _O_SEQUENTIAL
+#define O_RANDOM        _O_RANDOM
+#define O_NDELAY	0
+
+#define S_IFMT   _S_IFMT
+#define S_IFDIR  _S_IFDIR
+#define S_IFCHR  _S_IFCHR
+#define S_IFREG  _S_IFREG
+#define S_IREAD  _S_IREAD
+#define S_IWRITE _S_IWRITE
+#define S_IEXEC  _S_IEXEC
+
+#define S_IRWXO 007
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#define	S_ISDIR(m) (((m) & _S_IFDIR) == _S_IFDIR)
+#endif
+
+#define	SIGHUP	1	/* hangup */
+#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
+#define	SIGBUS	10	/* bus error */
+#define	SIGPIPE	13	/* write on a pipe with no one to read it */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define SIGUSR1 30	/* user defined signal 1 */
+#define SIGUSR2 31	/* user defined signal 2 */
+
+typedef unsigned short int ushort;
+typedef int uid_t;
+typedef int gid_t;
+
+struct passwd {
+    char    *pw_name;      /* user name */
+    char    *pw_passwd;    /* user password */
+    uid_t   pw_uid;        /* user id */
+    gid_t   pw_gid;        /* group id */
+    char    *pw_gecos;     /* real name */
+    char    *pw_dir;       /* home directory */
+    char    *pw_shell;     /* shell program */
+};
+
+struct group {
+    char    *gr_name;      /* group name */
+    char    *gr_passwd;    /* group password */
+    gid_t   gr_gid;        /* group id */
+    char    **gr_mem;      /* group members */
+};
+
+struct statfs {
+    long    f_type;     /* type of filesystem (see below) */
+    long    f_bsize;    /* optimal transfer block size */
+    long    f_blocks;   /* total data blocks in file system */
+    long    f_bfree;    /* free blocks in fs */
+    long    f_bavail;   /* free blocks avail to non-superuser */
+    long    f_files;    /* total file nodes in file system */
+    long    f_ffree;    /* free file nodes in fs */
+    long    f_fsid;     /* file system id */
+    long    f_namelen;  /* maximum length of filenames */
+    long    f_spare[6]; /* spare for later */
+};
+
+#ifndef HAVE_GETTIMEOFDAY
+struct timezone {
+    int	tz_minuteswest;	/* minutes west of Greenwich */
+    int	tz_dsttime;	/* type of dst correction */
+};
+#endif
+
+#define CHANGE_FD_SETSIZE 1
+#if CHANGE_FD_SETSIZE && SQUID_MAXFD > DEFAULT_FD_SETSIZE
+#define FD_SETSIZE SQUID_MAXFD
+#endif
+
+#include <stddef.h>
+#include <process.h>
+#include <errno.h>
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#include <winsock2.h>
+#endif
+#include <ws2tcpip.h>
+#if (EAI_NODATA == EAI_NONAME)
+#undef EAI_NODATA
+#define EAI_NODATA WSANO_DATA
+#endif
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+/* Hack to suppress compiler warnings on FD_SET() & FD_CLR() */
+#pragma warning (push)
+#pragma warning (disable:4142)
+#endif
+/* prevent inclusion of wingdi.h */
+#define NOGDI
+#include <ws2spi.h>
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#pragma warning (pop)
+#endif
+#include <io.h>
+#include <stdlib.h>
+
+typedef char * caddr_t;
+
+#undef FD_CLOSE
+#undef FD_OPEN
+#undef FD_READ
+#undef FD_WRITE
+#define EISCONN WSAEISCONN
+#define EINPROGRESS WSAEINPROGRESS
+#define EWOULDBLOCK WSAEWOULDBLOCK
+#define EALREADY WSAEALREADY
+#define ETIMEDOUT WSAETIMEDOUT
+#define ECONNREFUSED WSAECONNREFUSED
+#define ECONNRESET WSAECONNRESET
+#define ENOTCONN WSAENOTCONN
+#define ERESTART WSATRY_AGAIN
+#define EAFNOSUPPORT WSAEAFNOSUPPORT
+
+#undef h_errno
+#define h_errno errno /* we'll set it ourselves */
+
+#undef FD_CLR
+#define FD_CLR(fd, set) do { \
+    u_int __i; \
+    SOCKET __sock = _get_osfhandle(fd); \
+    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
+        if (((fd_set FAR *)(set))->fd_array[__i] == __sock) { \
+            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
+                ((fd_set FAR *)(set))->fd_array[__i] = \
+                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
+                __i++; \
+            } \
+            ((fd_set FAR *)(set))->fd_count--; \
+            break; \
+        } \
+    } \
+} while(0)
+
+#undef FD_SET
+#define FD_SET(fd, set) do { \
+    u_int __i; \
+    SOCKET __sock = _get_osfhandle(fd); \
+    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count; __i++) { \
+        if (((fd_set FAR *)(set))->fd_array[__i] == (__sock)) { \
+            break; \
+        } \
+    } \
+    if (__i == ((fd_set FAR *)(set))->fd_count) { \
+        if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) { \
+            ((fd_set FAR *)(set))->fd_array[__i] = (__sock); \
+            ((fd_set FAR *)(set))->fd_count++; \
+        } \
+    } \
+} while(0)
+
+#undef FD_ISSET
+#define FD_ISSET(fd, set) Win32__WSAFDIsSet(fd, (fd_set FAR *)(set))
+
+/* internal to Microsoft CRTLIB */
+typedef struct {
+    long osfhnd;    /* underlying OS file HANDLE */
+    char osfile;    /* attributes of file (e.g., open in text mode?) */
+    char pipech;    /* one char buffer for handles opened on pipes */
+#ifdef _MT
+    int lockinitflag;
+    CRITICAL_SECTION lock;
+#endif  /* _MT */
+}   ioinfo;
+#define IOINFO_L2E          5
+#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)
+#define _pioinfo(i) ( __pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)) )
+#define _osfile(i)  ( _pioinfo(i)->osfile )
+#define _osfhnd(i)  ( _pioinfo(i)->osfhnd )
+#define FOPEN           0x01    /* file handle open */
+
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+
+SQUIDCEXTERN _CRTIMP ioinfo * __pioinfo[];
+SQUIDCEXTERN int __cdecl _free_osfhnd(int);
+
+#elif defined(__MINGW32__) /* MinGW environment */
+
+__MINGW_IMPORT ioinfo * __pioinfo[];
+SQUIDCEXTERN int _free_osfhnd(int);
+
+#endif
+
+SQUIDCEXTERN THREADLOCAL int ws32_result;
+
+#define strerror(e) WIN32_strerror(e)
+
+#ifdef __cplusplus
+
+inline
+int close(int fd)
+{
+    char l_so_type[sizeof(int)];
+    int l_so_type_siz = sizeof(l_so_type);
+    SOCKET sock = _get_osfhandle(fd);
+
+    if (::getsockopt(sock, SOL_SOCKET, SO_TYPE, l_so_type, &l_so_type_siz) == 0) {
+        int result = 0;
+        if (closesocket(sock) == SOCKET_ERROR) {
+            errno = WSAGetLastError();
+            result = 1;
+        }
+        _free_osfhnd(fd);
+        _osfile(fd) = 0;
+        return result;
+    } else
+        return _close(fd);
+}
+
+#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+
+#ifndef _S_IREAD
+#define _S_IREAD 0x0100
+#endif
+
+#ifndef _S_IWRITE
+#define _S_IWRITE 0x0080
+#endif
+
+inline
+int open(const char *filename, int oflag, int pmode = 0)
+{
+    return _open(filename, oflag, pmode & (_S_IREAD | _S_IWRITE));
+}
+#endif
+
+inline
+int read(int fd, void * buf, size_t siz)
+{
+    char l_so_type[sizeof(int)];
+    int l_so_type_siz = sizeof(l_so_type);
+    SOCKET sock = _get_osfhandle(fd);
+
+    if (::getsockopt(sock, SOL_SOCKET, SO_TYPE, l_so_type, &l_so_type_siz) == 0)
+        return ::recv(sock, (char FAR *) buf, (int)siz, 0);
+    else
+        return _read(fd, buf, (unsigned int)siz);
+}
+
+inline
+int write(int fd, const void * buf, size_t siz)
+{
+    char l_so_type[sizeof(int)];
+    int l_so_type_siz = sizeof(l_so_type);
+    SOCKET sock = _get_osfhandle(fd);
+
+    if (::getsockopt(sock, SOL_SOCKET, SO_TYPE, l_so_type, &l_so_type_siz) == 0)
+        return ::send(sock, (char FAR *) buf, siz, 0);
+    else
+        return _write(fd, buf, siz);
+}
+
+inline
+char *index(const char *s, int c)
+{
+    return (char *)strchr(s,c);
+}
+
+/** \cond AUTODOCS-IGNORE */
+namespace Squid
+{
+/** \endcond */
+
+inline
+int accept(int s, struct sockaddr * a, size_t * l)
+{
+    SOCKET result;
+    if ((result = ::accept(_get_osfhandle(s), a, (int *)l)) == INVALID_SOCKET) {
+        if (WSAEMFILE == (errno = WSAGetLastError()))
+            errno = EMFILE;
+        return -1;
+    } else
+        return _open_osfhandle(result, 0);
+}
+
+inline
+int bind(int s, struct sockaddr * n, int l)
+{
+    if (::bind(_get_osfhandle(s),n,l) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+inline
+int connect(int s, const struct sockaddr * n, int l)
+{
+    if (::connect(_get_osfhandle(s),n,l) == SOCKET_ERROR) {
+        if (WSAEMFILE == (errno = WSAGetLastError()))
+            errno = EMFILE;
+        return -1;
+    } else
+        return 0;
+}
+
+inline
+struct hostent * gethostbyname (const char *n) {
+    HOSTENT FAR * result;
+    if ((result = ::gethostbyname(n)) == NULL)
+        errno = WSAGetLastError();
+    return result;
+}
+#define gethostbyname(n) Squid::gethostbyname(n)
+
+inline
+SERVENT FAR* getservbyname (const char * n, const char * p)
+{
+    SERVENT FAR * result;
+    if ((result = ::getservbyname(n, p)) == NULL)
+        errno = WSAGetLastError();
+    return result;
+}
+#define getservbyname(n,p) Squid::getservbyname(n,p)
+
+inline
+HOSTENT FAR * gethostbyaddr(const char * a, int l, int t)
+{
+    HOSTENT FAR * result;
+    if ((result = ::gethostbyaddr(a, l, t)) == NULL)
+        errno = WSAGetLastError();
+    return result;
+}
+#define gethostbyaddr(a,l,t) Squid::gethostbyaddr(a,l,t)
+
+inline
+int getsockname(int s, struct sockaddr * n, size_t * l)
+{
+    if ((::getsockname(_get_osfhandle(s), n, (int *)l)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+inline
+int gethostname(char * n, size_t l)
+{
+    if ((::gethostname(n, l)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+#define gethostname(n,l) Squid::gethostname(n,l)
+
+inline
+int getsockopt(int s, int l, int o, void * v, int * n)
+{
+    Sleep(1);
+    if ((::getsockopt(_get_osfhandle(s), l, o,(char *) v, n)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+/* Simple ioctl() emulation */
+inline
+int ioctl(int s, int c, void * a)
+{
+    if ((::ioctlsocket(_get_osfhandle(s), c, (u_long FAR *)a)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+inline
+int ioctlsocket(int s, long c, u_long FAR * a)
+{
+    if ((::ioctlsocket(_get_osfhandle(s), c, a)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+inline
+int listen(int s, int b)
+{
+    if (::listen(_get_osfhandle(s), b) == SOCKET_ERROR) {
+        if (WSAEMFILE == (errno = WSAGetLastError()))
+            errno = EMFILE;
+        return -1;
+    } else
+        return 0;
+}
+#define listen(s,b) Squid::listen(s,b)
+
+inline
+int recv(int s, void * b, size_t l, int f)
+{
+    int result;
+    if ((result = ::recv(_get_osfhandle(s), (char *)b, l, f)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return result;
+}
+
+inline
+int recvfrom(int s, void * b, size_t l, int f, struct sockaddr * fr, size_t * fl)
+{
+    int result;
+    if ((result = ::recvfrom(_get_osfhandle(s), (char *)b, l, f, fr, (int *)fl)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return result;
+}
+
+inline
+int select(int n, fd_set * r, fd_set * w, fd_set * e, struct timeval * t)
+{
+    int result;
+    if ((result = ::select(n,r,w,e,t)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return result;
+}
+#define select(n,r,w,e,t) Squid::select(n,r,w,e,t)
+
+inline
+int send(int s, const void * b, size_t l, int f)
+{
+    int result;
+    if ((result = ::send(_get_osfhandle(s), (char *)b, l, f)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return result;
+}
+
+inline
+int sendto(int s, const void * b, size_t l, int f, const struct sockaddr * t, int tl)
+{
+    int result;
+    if ((result = ::sendto(_get_osfhandle(s), (char *)b, l, f, t, tl)) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return result;
+}
+
+inline
+int setsockopt(SOCKET s, int l, int o, const char * v, int n)
+{
+    SOCKET socket;
+
+    socket = ((s == INVALID_SOCKET) ? s : (SOCKET)_get_osfhandle((int)s));
+
+    if (::setsockopt(socket, l, o, v, n) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+#define setsockopt(s,l,o,v,n) Squid::setsockopt(s,l,o,v,n)
+
+inline
+int shutdown(int s, int h)
+{
+    if (::shutdown(_get_osfhandle(s),h) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+inline
+int socket(int f, int t, int p)
+{
+    SOCKET result;
+    if ((result = ::socket(f, t, p)) == INVALID_SOCKET) {
+        if (WSAEMFILE == (errno = WSAGetLastError()))
+            errno = EMFILE;
+        return -1;
+    } else
+        return _open_osfhandle(result, 0);
+}
+#define socket(f,t,p) Squid::socket(f,t,p)
+
+inline
+int WSAAsyncSelect(int s, HWND h, unsigned int w, long e)
+{
+    if (::WSAAsyncSelect(_get_osfhandle(s), h, w, e) == SOCKET_ERROR) {
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+#undef WSADuplicateSocket
+inline
+int WSADuplicateSocket(int s, DWORD n, LPWSAPROTOCOL_INFO l)
+{
+#ifdef UNICODE
+    if (::WSADuplicateSocketW(_get_osfhandle(s), n, l) == SOCKET_ERROR) {
+#else
+    if (::WSADuplicateSocketA(_get_osfhandle(s), n, l) == SOCKET_ERROR) {
+#endif
+        errno = WSAGetLastError();
+        return -1;
+    } else
+        return 0;
+}
+
+#undef WSASocket
+inline
+int WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f) {
+    SOCKET result;
+#ifdef UNICODE
+    if ((result = ::WSASocketW(a, t, p, i, g, f)) == INVALID_SOCKET) {
+#else
+    if ((result = ::WSASocketA(a, t, p, i, g, f)) == INVALID_SOCKET) {
+#endif
+        if (WSAEMFILE == (errno = WSAGetLastError()))
+            errno = EMFILE;
+        return -1;
+    } else
+        return _open_osfhandle(result, 0);
+}
+
+} /* namespace Squid */
+
+#else /* #ifdef __cplusplus */
+#define connect(s,n,l) \
+	(SOCKET_ERROR == connect(_get_osfhandle(s),n,l) ? \
+	(WSAEMFILE == (errno = WSAGetLastError()) ? errno = EMFILE : -1, -1) : 0)
+#define gethostbyname(n) \
+	(NULL == ((HOSTENT FAR*)(ws32_result = (int)gethostbyname(n))) ? \
+	(errno = WSAGetLastError()), (HOSTENT FAR*)NULL : (HOSTENT FAR*)ws32_result)
+#define gethostname(n,l) \
+	(SOCKET_ERROR == gethostname(n,l) ? \
+	(errno = WSAGetLastError()), -1 : 0)
+#define recv(s,b,l,f) \
+	(SOCKET_ERROR == (ws32_result = recv(_get_osfhandle(s),b,l,f)) ? \
+	(errno = WSAGetLastError()), -1 : ws32_result)
+#define sendto(s,b,l,f,t,tl) \
+	(SOCKET_ERROR == (ws32_result = sendto(_get_osfhandle(s),b,l,f,t,tl)) ? \
+	(errno = WSAGetLastError()), -1 : ws32_result)
+#define select(n,r,w,e,t) \
+	(SOCKET_ERROR == (ws32_result = select(n,r,w,e,t)) ? \
+	(errno = WSAGetLastError()), -1 : ws32_result)
+#define socket(f,t,p) \
+	(INVALID_SOCKET == ((SOCKET)(ws32_result = (int)socket(f,t,p))) ? \
+	((WSAEMFILE == (errno = WSAGetLastError()) ? errno = EMFILE : -1), -1) : \
+	(SOCKET)_open_osfhandle(ws32_result,0))
+#define write      _write /* Needed in util.c */
+#define open       _open /* Needed in win32lib.c */
+#endif /* #ifdef __cplusplus */
+
+#define	RUSAGE_SELF	0		/* calling process */
+#define	RUSAGE_CHILDREN	-1		/* terminated child processes */
+
+struct rusage {
+    struct timeval ru_utime;	/* user time used */
+    struct timeval ru_stime;	/* system time used */
+    long ru_maxrss;			/* integral max resident set size */
+    long ru_ixrss;			/* integral shared text memory size */
+    long ru_idrss;			/* integral unshared data size */
+    long ru_isrss;			/* integral unshared stack size */
+    long ru_minflt;			/* page reclaims */
+    long ru_majflt;			/* page faults */
+    long ru_nswap;			/* swaps */
+    long ru_inblock;		/* block input operations */
+    long ru_oublock;		/* block output operations */
+    long ru_msgsnd;			/* messages sent */
+    long ru_msgrcv;			/* messages received */
+    long ru_nsignals;		/* signals received */
+    long ru_nvcsw;			/* voluntary context switches */
+    long ru_nivcsw;			/* involuntary context switches */
+};
+
+#undef ACL
+
+
+/** \cond AUTODOCS-IGNORE */
+using namespace Squid;
+/** \endcond */
+
+
+/* win32lib.c */
+SQUIDCEXTERN int chroot (const char *);
+SQUIDCEXTERN int ftruncate(int, off_t);
+#ifndef HAVE_GETTIMEOFDAY
+SQUIDCEXTERN int gettimeofday(struct timeval * ,void *);
+#endif
+SQUIDCEXTERN int kill(pid_t, int);
+SQUIDCEXTERN int statfs(const char *, struct statfs *);
+SQUIDCEXTERN int truncate(const char *, off_t);
+SQUIDCEXTERN const char * wsastrerror(int);
+SQUIDCEXTERN struct passwd *getpwnam(char *);
+SQUIDCEXTERN struct group *getgrnam(char *);
+SQUIDCEXTERN uid_t geteuid(void);
+SQUIDCEXTERN uid_t getuid(void);
+SQUIDCEXTERN int setuid(uid_t);
+SQUIDCEXTERN int seteuid(uid_t);
+SQUIDCEXTERN gid_t getgid(void);
+SQUIDCEXTERN gid_t getegid(void);
+SQUIDCEXTERN int setgid(gid_t);
+SQUIDCEXTERN int setegid(gid_t);
+SQUIDCEXTERN const char *WIN32_strerror(int);
+SQUIDCEXTERN void WIN32_maperror(unsigned long);
+
+// Moved in from squid.h and other duplicates.
+// BUT was already included up the top there with a wrapped conditional.
+// that may need checking....
+//#include <io.h>
+
+/* Windows may lack getpagesize() prototype */
+// Moved in from squid.h
+// NP: there may be a header include needed before this to prevent duplicate-definitions
+//     if that is true it will need including here as part of the hack.
+//     if not then this comment can be dropped.
+#if !defined(getpagesize)
+SQUIDCEXTERN size_t getpagesize(void);
+#endif
+
+
+#endif /* _SQUID_WIN32_ */
+#endif /* SQUID_OS_MSWIN_H */
@@ -0,0 +1,53 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_NEXT_H
+#define SQUID_OS_NEXT_H
+
+#ifdef _SQUID_NEXT_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+
+/*
+ * Don't allow inclusion of malloc.h
+ */
+#if defined(HAVE_MALLOC_H)
+#undef HAVE_MALLOC_H
+#endif
+
+/*
+ * S_ISDIR() may not be defined on Next
+ */
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if !defined(S_ISDIR)
+#define S_ISDIR(mode) (((mode) & (_S_IFMT)) == (_S_IFDIR))
+#endif
+
+/*
+ * WAS: lots of special wrappers labeled only 'protect NEXTSTEP'
+ * I'm assuming its an incomplete definition problem on that OS.
+ * Or a missing safety wrapper by the looks of the _SQUID_NETDB_H_
+ * 
+ * Anyway, this file is included before all general non-type headers.
+ * doing the include here for Next and undefining HAVE_NETDB_H will
+ * save us from including it again in general.
+ */
+// All the hacks included this first without safety wrapping, then netdb.h.
+#include <netinet/in_systm.h>
+#if HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#undef HAVE_NETDB_H
+#define HAVE_NETDB_H 0
+
+
+#endif /* _SQUID_NEXT_ */
+#endif /* SQUID_OS_NEXT_H */
@@ -0,0 +1,25 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_OPENBSD_H
+#define SQUID_OS_OPENBSD_H
+
+#ifdef _SQUID_OPENBSD_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+/*
+ * Don't allow inclusion of malloc.h
+ */
+#ifdef HAVE_MALLOC_H
+#undef HAVE_MALLOC_H
+#endif
+
+
+#endif /* _SQUID_OPENBSD_ */
+#endif /* SQUID_OS_OPENBSD_H */
@@ -0,0 +1,23 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_QNX_H
+#define SQUID_OS_QNX_H
+
+#ifdef _SQUID_QNX_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+/*
+ * Requires unix.h header file
+ */
+#include <unix.h>
+
+
+#endif /* _SQUID_QNX_ */
+#endif /* SQUID_OS_QNX_H */
@@ -0,0 +1,26 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_SGI_H
+#define SQUID_OS_SGI_H
+
+#if _SQUID_SGI_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+#if !defined(_SVR4_SOURCE)
+#define _SVR4_SOURCE		/* for tempnam(3) */
+#endif
+
+#if USE_ASYNC_IO
+#define _ABI_SOURCE
+#endif /* USE_ASYNC_IO */
+
+
+#endif /* _SQUID_SGI_ */
+#endif /* SQUID_OS_SGI_H */
@@ -0,0 +1,49 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_SOLARIS_H
+#define SQUID_OS_SOLARIS_H
+
+#ifdef _SQUID_SOLARIS_
+
+/*
+ * On Solaris 9 x86, gcc may includes a "fixed" set of old system
+ * include files that is incompatible with the updated Solaris
+ * header files.
+ */
+#if defined(i386) || defined(__i386)
+#ifndef HAVE_PAD128_T
+typedef union {
+	long double	_q;
+	int32_t		_l[4];
+} pad128_t;
+#endif
+#ifndef HAVE_UPAD128_T
+typedef union {
+	long double	_q;
+	uint32_t	_l[4];
+} upad128_t;
+#endif
+#endif
+
+/**
+ * prototypes for system function missing from system includes
+ */
+SQUIDCEXTERN int getrusage(int, struct rusage *);
+
+
+/**
+ * prototypes for system function missing from system includes
+ * on some Solaris systems.
+ */
+SQUIDCEXTERN int getpagesize(void);
+#if !defined(_XPG4_2) && !(defined(__EXTENSIONS__) || \
+        (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)))
+SQUIDCEXTERN int gethostname(char *, int);
+#endif
+
+
+
+#endif /* _SQUID_SOLARIS_ */
+#endif /* SQUID_OS_SOALRIS_H */
@@ -0,0 +1,25 @@
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_SUNOS_H
+#define SQUID_OS_SUNOS_H
+
+#ifdef _SQUID_SUNOS_
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+
+/*
+ * We assume O_NONBLOCK is broken, or does not exist, on SunOS.
+ */
+#define SQUID_NONBLOCK O_NDELAY
+
+
+
+#endif /* _SQUID_SUNOS_ */
+#endif /* SQUID_OS_SUNOS_H */
@@ -0,0 +1,53 @@
+/*
+ * $Id$
+ *
+ * AUTHOR: Guido Serassio <serassio@squid-cache.org>
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#ifndef SQUID_CONFIG_H
+#include "squid.h"
+#endif
+
+#ifndef SQUID_OS_WINDOWS_H
+#define SQUID_OS_WINDOWS_H
+
+#ifdef _SQUID_WIN32_
+
+#ifndef ACL
+#define ACL WindowsACL
+#define _MSWIN_ACL_WAS_NOT_DEFINED 1
+#endif
+#include <windows.h>
+#if _MSWIN_ACL_WAS_NOT_DEFINED
+#undef ACL
+#undef _MSWIN_ACL_WAS_NOT_DEFINED
+#endif
+
+#endif /* _SQUID_WIN32_ */
+#endif /* SQUID_OS_WINDOWS_H */
@@ -0,0 +1,92 @@
+#ifndef SQUID_COMPAT_OSDETECT_H
+#define SQUID_COMPAT_OSDETECT_H
+
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+/*
+ * Define the _SQUID_TYPE_ based on a guess of the OS.
+ *
+ * NP: This MUST come first in compat.h with no OS-specific includes
+ *     or other definitions within this if-else structure.
+ */
+
+#if defined(__sun__) || defined(__sun)	/* SUN */
+#define _SQUID_SUN_
+#if defined(__SVR4)		/* SOLARIS */
+#define _SQUID_SOLARIS_
+#else /* SUNOS */
+#define _SQUID_SUNOS_
+#endif
+
+#elif defined(__hpux)		/* HP-UX - SysV-like? */
+#define _SQUID_HPUX_
+#define _SQUID_SYSV_
+
+#elif defined(__osf__)		/* OSF/1 */
+#define _SQUID_OSF_
+
+#elif defined(__ultrix)		/* Ultrix */
+#define _SQUID_ULTRIX_
+
+#elif defined(_AIX)		/* AIX */
+#define _SQUID_AIX_
+
+#elif defined(__linux__)	/* Linux */
+#define _SQUID_LINUX_
+
+#elif defined(__FreeBSD__)	/* FreeBSD */
+#define _SQUID_FREEBSD_
+
+#elif defined(__sgi__)	|| defined(sgi) || defined(__sgi)	/* SGI */
+#define _SQUID_SGI_
+
+#elif defined(__NeXT__)
+#define _SQUID_NEXT_
+
+#elif defined(__bsdi__)
+#define _SQUID_BSDI_		/* BSD/OS */
+
+#elif defined(__NetBSD__)
+#define _SQUID_NETBSD_
+
+#elif defined(__OpenBSD__)
+#define _SQUID_OPENBSD_
+
+#elif defined(__DragonFly__)
+#define _SQUID_DRAGONFLY_
+
+#elif defined(__CYGWIN32__)  || defined(__CYGWIN__)
+#define _SQUID_CYGWIN_
+#define _SQUID_WIN32_
+
+#elif defined(WIN32) || defined(WINNT) || defined(__WIN32__) || defined(__WIN32)
+#define _SQUID_MSWIN_
+#define _SQUID_WIN32_
+
+#elif defined(__APPLE__)
+#define _SQUID_APPLE_
+
+#elif defined(sony_news) && defined(__svr4)
+#define _SQUID_NEWSOS6_
+
+#elif defined(__QNX__)
+#define _SQUID_QNX_
+
+#elif defined(__EMX__) || defined(OS2) || defined(__OS2__)
+#define _SQUID_OS2_
+/*
+ *  FIXME: the os2 port of bash seems to have problems checking
+ *  the return codes of programs in if statements.  These options
+ *  need to be overridden.
+ */
+
+#endif /* OS automatic detection */
+
+
+
+#endif /* SQUID_COMPAT_OSDETECT_H */
@@ -0,0 +1,90 @@
+#ifndef SQUID_FDSETSIZE_H
+#define SQUID_FDSETSIZE_H
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+/* FD_SETSIZE must be redefined before including sys/types.h */
+#if 0
+/* AYJ: would dearly like to use this to enforce include order
+	but at present some helpers don't follow the squid include methodology.
+	that will need fixing later.
+*/
+#ifdef _SYS_TYPES_H
+#error squid_fdsetsize.h for FDSETSIZE must be included before sys/types.h
+#error Make sure that squid.h or config.h is the first file included by your .cc
+#endif
+#endif /* 0 */
+/*
+ * On some systems, FD_SETSIZE is set to something lower than the
+ * actual number of files which can be opened.  IRIX is one case,
+ * NetBSD is another.  So here we increase FD_SETSIZE to our
+ * configure-discovered maximum *before* any system includes.
+ */
+#define CHANGE_FD_SETSIZE 1
+
+/*
+ * Cannot increase FD_SETSIZE on Linux, but we can increase __FD_SETSIZE
+ * with glibc 2.2 (or later? remains to be seen). We do this by including
+ * bits/types.h which defines __FD_SETSIZE first, then we redefine
+ * __FD_SETSIZE. Ofcourse a user program may NEVER include bits/whatever.h
+ * directly, so this is a dirty hack!
+ */
+#if defined(_SQUID_LINUX_)
+#undef CHANGE_FD_SETSIZE
+#define CHANGE_FD_SETSIZE 0
+#include <features.h>
+#if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)
+#if SQUID_MAXFD > DEFAULT_FD_SETSIZE
+#include <bits/types.h>
+#undef __FD_SETSIZE
+#define __FD_SETSIZE SQUID_MAXFD
+#endif
+#endif
+#endif
+
+/*
+ * Cannot increase FD_SETSIZE on FreeBSD before 2.2.0, causes select(2)
+ * to return EINVAL.
+ * --Marian Durkovic <marian@svf.stuba.sk>
+ * --Peter Wemm <peter@spinner.DIALix.COM>
+ */
+#if defined(_SQUID_FREEBSD_)
+#include <osreldate.h>
+#if __FreeBSD_version < 220000
+#undef CHANGE_FD_SETSIZE
+#define CHANGE_FD_SETSIZE 0
+#endif
+#endif
+
+/*
+ * Trying to redefine CHANGE_FD_SETSIZE causes a slew of warnings
+ * on Mac OS X Server.
+ */
+#if defined(_SQUID_APPLE_)
+#undef CHANGE_FD_SETSIZE
+#define CHANGE_FD_SETSIZE 0
+#endif
+
+/* Increase FD_SETSIZE if SQUID_MAXFD is bigger */
+#if CHANGE_FD_SETSIZE && SQUID_MAXFD > DEFAULT_FD_SETSIZE
+#define FD_SETSIZE SQUID_MAXFD
+#endif
+
+
+/*
+ * Trap unintentional use of fd_set. Must not be used outside the
+ * select code as it only supports FD_SETSIZE number of filedescriptors
+ * and Squid may be running with a lot more..
+ * But only for code linked into Squid, not the helpers.. (unlinkd, pinger)
+ */
+#ifdef SQUID_FDSET_NOUSE
+# ifndef SQUID_HELPER
+#  define fd_set ERROR_FD_SET_USED
+# endif
+#endif
+
+#endif /* SQUID_FDSETSIZE_H */
@@ -0,0 +1,38 @@
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef _SQUID_STDVARARGS_H
+#define _SQUID_STDVARARGS_H
+
+/*
+ * va_* variables come from various places on different platforms.
+ * We provide a clean set of wrappers for the variosu operations
+ * Depending on what is available and needed.
+ */
+#if defined(HAVE_STDARG_H)
+#include <stdarg.h>
+#define HAVE_STDARGS            /* let's hope that works everywhere (mj) */
+#define VA_LOCAL_DECL va_list ap;
+#define VA_START(f) va_start(ap, f)
+#define VA_SHIFT(v,t) ;         /* no-op for ANSI */
+#define VA_END va_end(ap)
+#else
+#if defined(HAVE_VARARGS_H)
+#include <varargs.h>
+#undef HAVE_STDARGS
+#define VA_LOCAL_DECL va_list ap;
+#define VA_START(f) va_start(ap)        /* f is ignored! */
+#define VA_SHIFT(v,t) v = va_arg(ap,t)
+#define VA_END va_end(ap)
+#else
+#error XX **NO VARARGS ** XX
+#endif
+#endif
+
+/* Make sure syslog goes after stdarg/varargs */
+#ifdef HAVE_SYSLOG_H
+#include <syslog.h>
+#endif
+
+#endif /* _SQUID_STDVARARGS_H */
@@ -0,0 +1,40 @@
+#ifndef SQUID_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef SQUID_VALGRIND_H
+#define SQUID_VALGRIND_H
+
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+
+/*
+ * valgrind debug support
+ */
+#if WITH_VALGRIND
+#include <valgrind/memcheck.h>
+#undef VALGRIND_MAKE_NOACCESS
+#undef VALGRIND_MAKE_WRITABLE
+#undef VALGRIND_MAKE_READABLE
+/* A little glue for older valgrind version prior to 3.2.0 */
+#ifndef VALGRIND_MAKE_MEM_NOACCESS
+#define VALGRIND_MAKE_MEM_NOACCESS VALGRIND_MAKE_NOACCESS
+#define VALGRIND_MAKE_MEM_UNDEFINED VALGRIND_MAKE_WRITABLE
+#define VALGRIND_MAKE_MEM_DEFINED VALGRIND_MAKE_READABLE
+#define VALGRIND_CHECK_MEM_IS_ADDRESSABLE VALGRIND_CHECK_WRITABLE
+#endif
+#else
+#define VALGRIND_MAKE_MEM_NOACCESS(a,b) (0)
+#define VALGRIND_MAKE_MEM_UNDEFINED(a,b) (0)
+#define VALGRIND_MAKE_MEM_DEFINED(a,b) (0)
+#define VALGRIND_CHECK_MEM_IS_ADDRESSABLE(a,b) (0)
+#define VALGRIND_CHECK_MEM_IS_DEFINED(a,b) (0)
+#define VALGRIND_MALLOCLIKE_BLOCK(a,b,c,d)
+#define VALGRIND_FREELIKE_BLOCK(a,b)
+#define RUNNING_ON_VALGRIND 0
+#endif /* WITH_VALGRIND */
+
+#endif /* SQUID_CONFIG_H */
@@ -70,7 +70,6 @@ extern "C"
     extern const char *const version_string;	/* VERSION */
 //MOVED:versions.h:APP_FULLNAME    extern const char *const full_appname_string;	/* PACKAGE "/" VERSION */
     extern const char *const appname_string;	/* PACKAGE */
-    extern const char *const w_space;	/* " \t\n\r" */
     extern char const * visible_appname_string; /* NULL */
     extern const char *fdTypeStr[];
     extern const char *hier_strings[];
@@ -1585,7 +1585,7 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
     http_state_flags flags;
 
     if (htcpInSocket < 0)
-        return 0;
+        return;
 
     old_squid_format = p->options.htcp_oldsquid;
     memset(&flags, '\0', sizeof(flags));
@@ -32,11 +32,6 @@
 #ifndef SQUID_H
 #define SQUID_H
 
-/*
- * On linux this must be defined to get PRId64 and friends
- */
-#define __STDC_FORMAT_MACROS
-
 #include "config.h"
 
 #ifdef _SQUID_MSWIN_
@@ -392,36 +387,6 @@ extern "C"
 #include "initgroups.h"
 #endif
 
-#ifndef min
-
-template<class A>
-inline A const &
-min(A const & lhs, A const & rhs)
-{
-    if (rhs < lhs)
-        return rhs;
-
-    return lhs;
-}
-
-#endif
-
-#define XMIN(x,y) (min (x,y))
-#ifndef max
-template<class A>
-inline A const &
-max(A const & lhs, A const & rhs)
-{
-    if (rhs > lhs)
-        return rhs;
-
-    return lhs;
-}
-
-#endif
-
-#define XMAX(a,b) (max (a,b))
-
 #include "structs.h"
 #include "protos.h"
 #include "globals.h"