        debug(9, 1) ("ftpTimeout: timeout in SENT_PASV state\n");
    }

    ftpFailed(ftpState, ERR_READ_TIMEOUT, 0);
    /* ftpFailed closes ctrl.fd and frees ftpState */
}

static void
ftpListingStart(FtpStateData * ftpState)
{
    StoreEntry *e = ftpState->entry;
    wordlist *w;
    char *dirup;
    int i, j, k;
    const char *title = ftpState->title_url.buf();
    storeAppendPrintf(e, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n");
    storeAppendPrintf(e, "<!-- HTML listing generated by Squid %s -->\n",
                      version_string);
    storeAppendPrintf(e, "<!-- %s -->\n", mkrfc1123(squid_curtime));
    storeAppendPrintf(e, "<HTML><HEAD><TITLE>\n");
    {
        char *t = xstrdup(title);
        rfc1738_unescape(t);
        storeAppendPrintf(e, "FTP Directory: %s\n", html_quote(t));
        xfree(t);
    }

    storeAppendPrintf(e, "</TITLE>\n");
    storeAppendPrintf(e, "<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n");

    if (ftpState->flags.need_base_href)
        storeAppendPrintf(e, "<BASE HREF=\"%s\">\n",
                          html_quote(ftpState->base_href.buf()));

    storeAppendPrintf(e, "</HEAD><BODY>\n");

    if (ftpState->cwd_message) {
        storeAppendPrintf(e, "<PRE>\n");

        for (w = ftpState->cwd_message; w; w = w->next)
            storeAppendPrintf(e, "%s\n", html_quote(w->key));

        storeAppendPrintf(e, "</PRE>\n");

        storeAppendPrintf(e, "<HR noshade size=\"1px\">\n");

        wordlistDestroy(&ftpState->cwd_message);
    }

    storeAppendPrintf(e, "<H2>\n");
    storeAppendPrintf(e, "FTP Directory: ");
    /* "ftp://" == 6 characters */
    assert(ftpState->title_url.size() >= 6);
    k = 6 + strcspn(&title[6], "/");

    for (i = 6, j = 0; title[i]; j = i) {
        storeAppendPrintf(e, "<A HREF=\"");
        i += strcspn(&title[i], "/");

        if (i > j) {
            char *url = xstrdup(title);
            url[i] = '\0';
            storeAppendPrintf(e, "%s", html_quote(url + k));
            storeAppendPrintf(e, "/");
            storeAppendPrintf(e, "\">");
            rfc1738_unescape(url + j);
            storeAppendPrintf(e, "%s", html_quote(url + j));
            safe_free(url);
            storeAppendPrintf(e, "</A>");
        }

        storeAppendPrintf(e, "/");

        if (title[i] == '/')
            i++;

        if (i == j) {
            /* Error guard, or "assert" */
            storeAppendPrintf(e, "ERROR: Failed to parse URL: %s\n",
                              html_quote(title));
            debug(9, 0) ("Failed to parse URL: %s\n", title);
            break;
        }
    }

    storeAppendPrintf(e, "</H2>\n");
    storeAppendPrintf(e, "<PRE>\n");
    dirup = ftpHtmlifyListEntry("<internal-dirup>", ftpState);
    storeAppend(e, dirup, strlen(dirup));
    ftpState->flags.html_header_sent = 1;
}

static void
ftpListingFinish(FtpStateData * ftpState)
{
    StoreEntry *e = ftpState->entry;
    storeBuffer(e);
    storeAppendPrintf(e, "</PRE>\n");

    if (ftpState->flags.listformat_unknown && !ftpState->flags.tried_nlst) {
        storeAppendPrintf(e, "<A HREF=\"%s/;type=d\">[As plain directory]</A>\n",
                          ftpState->flags.dir_slash ? rfc1738_escape_part(ftpState->old_filepath) : ".");
    } else if (ftpState->typecode == 'D') {
        const char *path = ftpState->flags.dir_slash ? ftpState->filepath : ".";
        storeAppendPrintf(e, "<A HREF=\"%s/\">[As extended directory]</A>\n", html_quote(path));
    }

    storeAppendPrintf(e, "<HR noshade size=\"1px\">\n");
    storeAppendPrintf(e, "<ADDRESS>\n");
    storeAppendPrintf(e, "Generated %s by %s (%s)\n",
                      mkrfc1123(squid_curtime),
                      getMyHostname(),
                      visible_appname_string);
    storeAppendPrintf(e, "</ADDRESS></BODY></HTML>\n");
}

static const char *Month[] =
