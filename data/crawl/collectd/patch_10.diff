@@ -676,14 +676,31 @@
 #</Plugin>
 
 #<Plugin ipmi>
-#	Sensor "some_sensor"
-#	Sensor "another_one"
-#	IgnoreSelected false
-#	NotifySensorAdd false
-#	NotifySensorRemove true
-#	NotifySensorNotPresent false
-#	SELEnabled false
-#	SELClearEvent false
+#	<Instance "local">
+#		Sensor "some_sensor"
+#		Sensor "another_one"
+#		IgnoreSelected false
+#		NotifySensorAdd false
+#		NotifySensorRemove true
+#		NotifySensorNotPresent false
+#		SELEnabled false
+#		SELClearEvent false
+#	</Instance>
+#	<Instance "remote">
+#		Host "server.example.com"
+#		Address  "1.2.3.4"
+#		Username "user"
+#		Password "secret"
+#		#AuthType "md5"
+#		Sensor "some_sensor"
+#		Sensor "another_one"
+#		IgnoreSelected false
+#		NotifySensorAdd false
+#		NotifySensorRemove true
+#		NotifySensorNotPresent false
+#		SELEnabled false
+#		SELClearEvent false
+#	</Instance>
 #</Plugin>
 
 #<Plugin iptables>
@@ -3351,8 +3351,36 @@ This option is only available on Solaris.
 
 =head2 Plugin C<ipmi>
 
+The B<ipmi plugin> allows to monitor server platform status using the Intelligent
+Platform Management Interface (IPMI). Local and remote interfaces are supported.
+
+The plugin configuration consists of one or more B<Instance> blocks which
+specify one I<ipmi> connection each. Within the B<Instance> blocks, the
+following options are allowed:
+
 =over 4
 
+=item B<Address> I<Address>
+
+Hostname or IP to connect to. If not specified, plugin will try to connect to
+local management controller (BMC).
+
+=item B<Username> I<Username>
+
+=item B<Password> I<Password>
+
+The username and the password to use for the connection to remote BMC.
+
+=item B<AuthType> I<MD5>|I<rmcp+>
+
+Forces the authentication type to use for the connection to remote BMC.
+By default most secure type is seleted.
+
+=item B<Host> I<Hostname>
+
+Sets the B<host> field of dispatched values. Defaults to the global hostname
+setting.
+
 =item B<Sensor> I<Sensor>
 
 Selects sensors to collect or to ignore, depending on B<IgnoreSelected>.
@@ -21,6 +21,7 @@
  *   Florian octo Forster <octo at collectd.org>
  *   Peter Holik <peter at holik.at>
  *   Bruno Pr√©mont <bonbons at linux-vserver.org>
+ *   Pavel Rochnyak <pavel2000 ngs.ru>
  **/
 
 #include "collectd.h"
@@ -29,8 +30,10 @@
 #include "plugin.h"
 #include "utils_ignorelist.h"
 
+#include <OpenIPMI/ipmi_auth.h>
 #include <OpenIPMI/ipmi_conn.h>
 #include <OpenIPMI/ipmi_err.h>
+#include <OpenIPMI/ipmi_lan.h>
 #include <OpenIPMI/ipmi_posix.h>
 #include <OpenIPMI/ipmi_smi.h>
 #include <OpenIPMI/ipmiif.h>
@@ -41,51 +44,58 @@
 struct c_ipmi_sensor_list_s;
 typedef struct c_ipmi_sensor_list_s c_ipmi_sensor_list_t;
 
+struct c_ipmi_instance_s {
+  char *name;
+  ignorelist_t *ignorelist;
+  _Bool notify_add;
+  _Bool notify_remove;
+  _Bool notify_notpresent;
+  _Bool sel_enabled;
+  _Bool sel_clear_event;
+
+  char *host;
+  char *connaddr;
+  char *username;
+  char *password;
+  unsigned int authtype;
+
+  ipmi_con_t *connection;
+  pthread_mutex_t sensor_list_lock;
+  c_ipmi_sensor_list_t *sensor_list;
+
+  _Bool active;
+  pthread_t thread_id;
+  int init_in_progress;
+
+  struct c_ipmi_instance_s *next;
+};
+typedef struct c_ipmi_instance_s c_ipmi_instance_t;
+
 struct c_ipmi_sensor_list_s {
   ipmi_sensor_id_t sensor_id;
   char sensor_name[DATA_MAX_NAME_LEN];
   char sensor_type[DATA_MAX_NAME_LEN];
   int sensor_not_present;
   c_ipmi_sensor_list_t *next;
+  c_ipmi_instance_t *instance;
+  unsigned int use;
 };
 
 /*
  * Module global variables
  */
-static pthread_mutex_t sensor_list_lock = PTHREAD_MUTEX_INITIALIZER;
-static c_ipmi_sensor_list_t *sensor_list = NULL;
-
-static int c_ipmi_init_in_progress = 0;
-static int c_ipmi_active = 0;
-static pthread_t thread_id = (pthread_t)0;
-
-static const char *config_keys[] = {"Sensor",
-                                    "IgnoreSelected",
-                                    "NotifySensorAdd",
-                                    "NotifySensorRemove",
-                                    "NotifySensorNotPresent",
-                                    "SELEnabled",
-                                    "SELClearEvent"};
-static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
-
-static ignorelist_t *ignorelist = NULL;
-
-static _Bool c_ipmi_notify_add = 0;
-static _Bool c_ipmi_notify_remove = 0;
-static _Bool c_ipmi_notify_notpresent = 0;
-static _Bool c_ipmi_sel_enabled = 0;
-static _Bool c_ipmi_sel_clear_event = 0;
+static os_handler_t *os_handler;
+static c_ipmi_instance_t *instances = NULL;
 
 /*
  * Misc private functions
  */
 static void c_ipmi_error(const char *func, int status) {
   char errbuf[4096] = {0};
 
-  if (IPMI_IS_OS_ERR(status)) {
-    sstrerror(IPMI_GET_OS_ERR(status), errbuf, sizeof(errbuf));
-  } else if (IPMI_IS_IPMI_ERR(status)) {
-    ipmi_get_error_string(IPMI_GET_IPMI_ERR(status), errbuf, sizeof(errbuf));
+  if (IPMI_IS_OS_ERR(status) || IPMI_IS_RMCPP_ERR(status) ||
+      IPMI_IS_IPMI_ERR(status)) {
+    ipmi_get_error_string(status, errbuf, sizeof(errbuf));
   }
 
   if (errbuf[0] == 0) {
@@ -96,36 +106,81 @@ static void c_ipmi_error(const char *func, int status) {
   ERROR("ipmi plugin: %s failed: %s", func, errbuf);
 } /* void c_ipmi_error */
 
+static void c_ipmi_log(os_handler_t *handler, const char *format,
+                       enum ipmi_log_type_e log_type, va_list ap) {
+  char msg[1024];
+
+  vsnprintf(msg, sizeof(msg), format, ap);
+
+  switch (log_type) {
+  case IPMI_LOG_INFO:
+    INFO("ipmi plugin: %s", msg);
+    break;
+  case IPMI_LOG_WARNING:
+    NOTICE("ipmi plugin: %s", msg);
+    break;
+  case IPMI_LOG_SEVERE:
+    WARNING("ipmi plugin: %s", msg);
+    break;
+  case IPMI_LOG_FATAL:
+    ERROR("ipmi plugin: %s", msg);
+    break;
+  case IPMI_LOG_ERR_INFO:
+    ERROR("ipmi plugin: %s", msg);
+    break;
+#if COLLECT_DEBUG
+  case IPMI_LOG_DEBUG_START:
+  case IPMI_LOG_DEBUG:
+    fprintf(stderr, "ipmi plugin: %s\n", msg);
+    break;
+  case IPMI_LOG_DEBUG_CONT:
+  case IPMI_LOG_DEBUG_END:
+    fprintf(stderr, "%s\n", msg);
+    break;
+#else
+  case IPMI_LOG_DEBUG_START:
+  case IPMI_LOG_DEBUG:
+  case IPMI_LOG_DEBUG_CONT:
+  case IPMI_LOG_DEBUG_END:
+    break;
+#endif
+  }
+} /* void c_ipmi_log */
+
 /*
  * Sensor handlers
  */
 /* Prototype for sensor_list_remove, so sensor_read_handler can call it. */
-static int sensor_list_remove(ipmi_sensor_t *sensor);
+static int sensor_list_remove(c_ipmi_instance_t *st, ipmi_sensor_t *sensor);
 
 static void sensor_read_handler(ipmi_sensor_t *sensor, int err,
                                 enum ipmi_value_present_e value_present,
                                 unsigned int __attribute__((unused)) raw_value,
-                                double value,
-                                ipmi_states_t __attribute__((unused)) * states,
+                                double value, ipmi_states_t *states,
                                 void *user_data) {
   value_list_t vl = VALUE_LIST_INIT;
 
   c_ipmi_sensor_list_t *list_item = (c_ipmi_sensor_list_t *)user_data;
+  c_ipmi_instance_t *st = list_item->instance;
+
+  list_item->use--;
 
   if (err != 0) {
-    if ((err & 0xff) == IPMI_NOT_PRESENT_CC) {
+    if (IPMI_IS_IPMI_ERR(err) &&
+        IPMI_GET_IPMI_ERR(err) == IPMI_NOT_PRESENT_CC) {
       if (list_item->sensor_not_present == 0) {
         list_item->sensor_not_present = 1;
 
-        INFO("ipmi plugin: sensor_read_handler: sensor %s "
+        INFO("ipmi plugin: sensor_read_handler: sensor `%s` of `%s` "
              "not present.",
-             list_item->sensor_name);
+             list_item->sensor_name, st->name);
 
-        if (c_ipmi_notify_notpresent) {
+        if (st->notify_notpresent) {
           notification_t n = {
               NOTIF_WARNING, cdtime(), "", "", "ipmi", "", "", "", NULL};
 
-          sstrncpy(n.host, hostname_g, sizeof(n.host));
+          sstrncpy(n.host, (st->host != NULL) ? st->host : hostname_g,
+                   sizeof(n.host));
           sstrncpy(n.type_instance, list_item->sensor_name,
                    sizeof(n.type_instance));
           sstrncpy(n.type, list_item->sensor_type, sizeof(n.type));
@@ -138,43 +193,50 @@ static void sensor_read_handler(ipmi_sensor_t *sensor, int err,
     } else if (IPMI_IS_IPMI_ERR(err) &&
                IPMI_GET_IPMI_ERR(err) ==
                    IPMI_NOT_SUPPORTED_IN_PRESENT_STATE_CC) {
-      INFO("ipmi plugin: sensor_read_handler: Sensor %s not ready",
-           list_item->sensor_name);
+      INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` not ready.",
+           list_item->sensor_name, st->name);
+    } else if (IPMI_IS_IPMI_ERR(err) &&
+               IPMI_GET_IPMI_ERR(err) == IPMI_TIMEOUT_CC) {
+      INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` timed out.",
+           list_item->sensor_name, st->name);
     } else {
+      char errbuf[128] = {0};
+      ipmi_get_error_string(err, errbuf, sizeof(errbuf) - 1);
+
       if (IPMI_IS_IPMI_ERR(err))
-        INFO("ipmi plugin: sensor_read_handler: Removing sensor %s, "
-             "because it failed with IPMI error %#x.",
-             list_item->sensor_name, IPMI_GET_IPMI_ERR(err));
+        INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` failed: "
+             "%s.",
+             list_item->sensor_name, st->name, errbuf);
       else if (IPMI_IS_OS_ERR(err))
-        INFO("ipmi plugin: sensor_read_handler: Removing sensor %s, "
-             "because it failed with OS error %#x.",
-             list_item->sensor_name, IPMI_GET_OS_ERR(err));
+        INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` failed: "
+             "%s (%#x).",
+             list_item->sensor_name, st->name, errbuf, IPMI_GET_OS_ERR(err));
       else if (IPMI_IS_RMCPP_ERR(err))
-        INFO("ipmi plugin: sensor_read_handler: Removing sensor %s, "
-             "because it failed with RMCPP error %#x.",
-             list_item->sensor_name, IPMI_GET_RMCPP_ERR(err));
+        INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` failed: "
+             "%s.",
+             list_item->sensor_name, st->name, errbuf);
       else if (IPMI_IS_SOL_ERR(err))
-        INFO("ipmi plugin: sensor_read_handler: Removing sensor %s, "
-             "because it failed with RMCPP error %#x.",
-             list_item->sensor_name, IPMI_GET_SOL_ERR(err));
+        INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` failed: "
+             "%s (%#x).",
+             list_item->sensor_name, st->name, errbuf, IPMI_GET_SOL_ERR(err));
       else
-        INFO("ipmi plugin: sensor_read_handler: Removing sensor %s, "
-             "because it failed with error %#x. of class %#x",
-             list_item->sensor_name, err & 0xff, err & 0xffffff00);
-      sensor_list_remove(sensor);
+        INFO("ipmi plugin: sensor_read_handler: Sensor `%s` of `%s` failed "
+             "with error %#x. of class %#x",
+             list_item->sensor_name, st->name, err & 0xff, err & 0xffffff00);
     }
     return;
   } else if (list_item->sensor_not_present == 1) {
     list_item->sensor_not_present = 0;
 
-    INFO("ipmi plugin: sensor_read_handler: sensor %s present.",
-         list_item->sensor_name);
+    INFO("ipmi plugin: sensor_read_handler: sensor `%s` of `%s` present.",
+         list_item->sensor_name, st->name);
 
-    if (c_ipmi_notify_notpresent) {
+    if (st->notify_notpresent) {
       notification_t n = {NOTIF_OKAY, cdtime(), "", "",  "ipmi",
                           "",         "",       "", NULL};
 
-      sstrncpy(n.host, hostname_g, sizeof(n.host));
+      sstrncpy(n.host, (st->host != NULL) ? st->host : hostname_g,
+               sizeof(n.host));
       sstrncpy(n.type_instance, list_item->sensor_name,
                sizeof(n.type_instance));
       sstrncpy(n.type, list_item->sensor_type, sizeof(n.type));
@@ -186,19 +248,35 @@ static void sensor_read_handler(ipmi_sensor_t *sensor, int err,
   }
 
   if (value_present != IPMI_BOTH_VALUES_PRESENT) {
-    INFO("ipmi plugin: sensor_read_handler: Removing sensor %s, "
+    INFO("ipmi plugin: sensor_read_handler: Removing sensor `%s` of `%s`, "
          "because it provides %s. If you need this sensor, "
          "please file a bug report.",
-         list_item->sensor_name,
+         list_item->sensor_name, st->name,
          (value_present == IPMI_RAW_VALUE_PRESENT) ? "only the raw value"
                                                    : "no value");
-    sensor_list_remove(sensor);
+    sensor_list_remove(st, sensor);
+    return;
+  }
+
+  if (!ipmi_is_sensor_scanning_enabled(states)) {
+    DEBUG("ipmi plugin: sensor_read_handler: Skipping sensor `%s` of `%s`, "
+          "it is in 'scanning disabled' state.",
+          list_item->sensor_name, st->name);
+    return;
+  }
+
+  if (ipmi_is_initial_update_in_progress(states)) {
+    DEBUG("ipmi plugin: sensor_read_handler: Skipping sensor `%s` of `%s`, "
+          "it is in 'initial update in progress' state.",
+          list_item->sensor_name, st->name);
     return;
   }
 
   vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
+  if (st->host != NULL)
+    sstrncpy(vl.host, st->host, sizeof(vl.host));
   sstrncpy(vl.plugin, "ipmi", sizeof(vl.plugin));
   sstrncpy(vl.type, list_item->sensor_type, sizeof(vl.type));
   sstrncpy(vl.type_instance, list_item->sensor_name, sizeof(vl.type_instance));
@@ -254,7 +332,7 @@ static void sensor_get_name(ipmi_sensor_t *sensor, char *buffer, int buf_len) {
   sstrncpy(buffer, sensor_name, buf_len);
 }
 
-static int sensor_list_add(ipmi_sensor_t *sensor) {
+static int sensor_list_add(c_ipmi_instance_t *st, ipmi_sensor_t *sensor) {
   ipmi_sensor_id_t sensor_id;
   c_ipmi_sensor_list_t *list_item;
   c_ipmi_sensor_list_t *list_prev;
@@ -267,13 +345,51 @@ static int sensor_list_add(ipmi_sensor_t *sensor) {
   sensor_id = ipmi_sensor_convert_to_id(sensor);
   sensor_get_name(sensor, buffer, sizeof(buffer));
 
-  /* Both `ignorelist' and `plugin_instance' may be NULL. */
-  if (ignorelist_match(ignorelist, sensor_name_ptr) != 0)
+  DEBUG("ipmi plugin: sensor_list_add: Found sensor `%s` of `%s`,"
+        " Type: %#x"
+        " Event reading type: %#x"
+        " Direction: %#x"
+        " Event support: %#x",
+        sensor_name_ptr, st->name, ipmi_sensor_get_sensor_type(sensor),
+        ipmi_sensor_get_event_reading_type(sensor),
+        ipmi_sensor_get_sensor_direction(sensor),
+        ipmi_sensor_get_event_support(sensor));
+
+  /* Both `ignorelist' and `sensor_name_ptr' may be NULL. */
+  if (ignorelist_match(st->ignorelist, sensor_name_ptr) != 0)
     return 0;
 
   /* FIXME: Use rate unit or base unit to scale the value */
 
   sensor_type = ipmi_sensor_get_sensor_type(sensor);
+
+  /*
+   * ipmitool/lib/ipmi_sdr.c sdr_sensor_has_analog_reading() has a notice
+   * about 'Threshold sensors' and 'analog readings'. Discrete sensor may
+   * have analog data, but discrete sensors support is not implemented
+   * in Collectd yet.
+   *
+   * ipmi_sensor_id_get_reading() supports only 'Threshold' sensors.
+   * See lib/sensor.c:4842, stand_ipmi_sensor_get_reading() for details.
+  */
+  if (!ipmi_sensor_get_is_readable(sensor)) {
+    INFO("ipmi plugin: sensor_list_add: Ignore sensor `%s` of `%s`, "
+         "because it don't readable! Its type: (%#x, %s). ",
+         sensor_name_ptr, st->name, sensor_type,
+         ipmi_sensor_get_sensor_type_string(sensor));
+    return -1;
+  }
+
+  if (ipmi_sensor_get_event_reading_type(sensor) !=
+      IPMI_EVENT_READING_TYPE_THRESHOLD) {
+    INFO("ipmi plugin: sensor_list_add: Ignore sensor `%s` of `%s`, "
+         "because it is discrete (%#x)! Its type: (%#x, %s). ",
+         sensor_name_ptr, st->name, sensor_type,
+         ipmi_sensor_get_event_reading_type(sensor),
+         ipmi_sensor_get_sensor_type_string(sensor));
+    return -1;
+  }
+
   switch (sensor_type) {
   case IPMI_SENSOR_TYPE_TEMPERATURE:
     type = "temperature";
@@ -292,55 +408,55 @@ static int sensor_list_add(ipmi_sensor_t *sensor) {
     break;
 
   default: {
-    const char *sensor_type_str;
-
-    sensor_type_str = ipmi_sensor_get_sensor_type_string(sensor);
-    INFO("ipmi plugin: sensor_list_add: Ignore sensor %s, "
+    INFO("ipmi plugin: sensor_list_add: Ignore sensor `%s` of `%s`, "
          "because I don't know how to handle its type (%#x, %s). "
          "If you need this sensor, please file a bug report.",
-         sensor_name_ptr, sensor_type, sensor_type_str);
+         sensor_name_ptr, st->name, sensor_type,
+         ipmi_sensor_get_sensor_type_string(sensor));
     return -1;
   }
   } /* switch (sensor_type) */
 
-  pthread_mutex_lock(&sensor_list_lock);
+  pthread_mutex_lock(&st->sensor_list_lock);
 
   list_prev = NULL;
-  for (list_item = sensor_list; list_item != NULL;
+  for (list_item = st->sensor_list; list_item != NULL;
        list_item = list_item->next) {
     if (ipmi_cmp_sensor_id(sensor_id, list_item->sensor_id) == 0)
       break;
     list_prev = list_item;
   } /* for (list_item) */
 
   if (list_item != NULL) {
-    pthread_mutex_unlock(&sensor_list_lock);
+    pthread_mutex_unlock(&st->sensor_list_lock);
     return 0;
   }
 
   list_item = (c_ipmi_sensor_list_t *)calloc(1, sizeof(c_ipmi_sensor_list_t));
   if (list_item == NULL) {
-    pthread_mutex_unlock(&sensor_list_lock);
+    pthread_mutex_unlock(&st->sensor_list_lock);
     return -1;
   }
 
+  list_item->instance = st;
   list_item->sensor_id = ipmi_sensor_convert_to_id(sensor);
 
   if (list_prev != NULL)
     list_prev->next = list_item;
   else
-    sensor_list = list_item;
+    st->sensor_list = list_item;
 
   sstrncpy(list_item->sensor_name, sensor_name_ptr,
            sizeof(list_item->sensor_name));
   sstrncpy(list_item->sensor_type, type, sizeof(list_item->sensor_type));
 
-  pthread_mutex_unlock(&sensor_list_lock);
+  pthread_mutex_unlock(&st->sensor_list_lock);
 
-  if (c_ipmi_notify_add && (c_ipmi_init_in_progress == 0)) {
+  if (st->notify_add && (st->init_in_progress == 0)) {
     notification_t n = {NOTIF_OKAY, cdtime(), "", "", "ipmi", "", "", "", NULL};
 
-    sstrncpy(n.host, hostname_g, sizeof(n.host));
+    sstrncpy(n.host, (st->host != NULL) ? st->host : hostname_g,
+             sizeof(n.host));
     sstrncpy(n.type_instance, list_item->sensor_name, sizeof(n.type_instance));
     sstrncpy(n.type, list_item->sensor_type, sizeof(n.type));
     snprintf(n.message, sizeof(n.message), "sensor %s added",
@@ -352,43 +468,44 @@ static int sensor_list_add(ipmi_sensor_t *sensor) {
   return 0;
 } /* int sensor_list_add */
 
-static int sensor_list_remove(ipmi_sensor_t *sensor) {
+static int sensor_list_remove(c_ipmi_instance_t *st, ipmi_sensor_t *sensor) {
   ipmi_sensor_id_t sensor_id;
   c_ipmi_sensor_list_t *list_item;
   c_ipmi_sensor_list_t *list_prev;
 
   sensor_id = ipmi_sensor_convert_to_id(sensor);
 
-  pthread_mutex_lock(&sensor_list_lock);
+  pthread_mutex_lock(&st->sensor_list_lock);
 
   list_prev = NULL;
-  for (list_item = sensor_list; list_item != NULL;
+  for (list_item = st->sensor_list; list_item != NULL;
        list_item = list_item->next) {
     if (ipmi_cmp_sensor_id(sensor_id, list_item->sensor_id) == 0)
       break;
     list_prev = list_item;
   } /* for (list_item) */
 
   if (list_item == NULL) {
-    pthread_mutex_unlock(&sensor_list_lock);
+    pthread_mutex_unlock(&st->sensor_list_lock);
     return -1;
   }
 
   if (list_prev == NULL)
-    sensor_list = list_item->next;
+    st->sensor_list = list_item->next;
   else
     list_prev->next = list_item->next;
 
   list_prev = NULL;
   list_item->next = NULL;
 
-  pthread_mutex_unlock(&sensor_list_lock);
+  pthread_mutex_unlock(&st->sensor_list_lock);
 
-  if (c_ipmi_notify_remove && c_ipmi_active) {
+  if (st->notify_remove && st->active) {
     notification_t n = {NOTIF_WARNING, cdtime(), "", "", "ipmi", "", "", "",
                         NULL};
 
-    sstrncpy(n.host, hostname_g, sizeof(n.host));
+    sstrncpy(n.host, (st->host != NULL) ? st->host : hostname_g,
+             sizeof(n.host));
     sstrncpy(n.type_instance, list_item->sensor_name, sizeof(n.type_instance));
     sstrncpy(n.type, list_item->sensor_type, sizeof(n.type));
     snprintf(n.message, sizeof(n.message), "sensor %s removed",
@@ -401,29 +518,37 @@ static int sensor_list_remove(ipmi_sensor_t *sensor) {
   return 0;
 } /* int sensor_list_remove */
 
-static int sensor_list_read_all(void) {
-  pthread_mutex_lock(&sensor_list_lock);
+static int sensor_list_read_all(c_ipmi_instance_t *st) {
+  pthread_mutex_lock(&st->sensor_list_lock);
 
-  for (c_ipmi_sensor_list_t *list_item = sensor_list; list_item != NULL;
+  for (c_ipmi_sensor_list_t *list_item = st->sensor_list; list_item != NULL;
        list_item = list_item->next) {
+    DEBUG("ipmi plugin: try read sensor `%s` of `%s`, use: %d",
+          list_item->sensor_name, st->name, list_item->use);
+
+    /* Reading already initiated */
+    if (list_item->use)
+      continue;
+
+    list_item->use++;
     ipmi_sensor_id_get_reading(list_item->sensor_id, sensor_read_handler,
-                               /* user data = */ list_item);
+                               /* user data = */ (void *)list_item);
   } /* for (list_item) */
 
-  pthread_mutex_unlock(&sensor_list_lock);
+  pthread_mutex_unlock(&st->sensor_list_lock);
 
   return 0;
 } /* int sensor_list_read_all */
 
-static int sensor_list_remove_all(void) {
+static int sensor_list_remove_all(c_ipmi_instance_t *st) {
   c_ipmi_sensor_list_t *list_item;
 
-  pthread_mutex_lock(&sensor_list_lock);
+  pthread_mutex_lock(&st->sensor_list_lock);
 
-  list_item = sensor_list;
-  sensor_list = NULL;
+  list_item = st->sensor_list;
+  st->sensor_list = NULL;
 
-  pthread_mutex_unlock(&sensor_list_lock);
+  pthread_mutex_unlock(&st->sensor_list_lock);
 
   while (list_item != NULL) {
     c_ipmi_sensor_list_t *list_next = list_item->next;
@@ -476,6 +601,8 @@ static int sensor_threshold_event_handler(
     enum ipmi_value_present_e value_present, unsigned int raw_value,
     double value, void *cb_data, ipmi_event_t *event) {
 
+  c_ipmi_instance_t *st = (c_ipmi_instance_t *)cb_data;
+
   /* From the IPMI specification Chapter 2: Events.
    * If a callback handles the event, then all future callbacks called due to
    * the event will receive a NULL for the event. So be ready to handle a NULL
@@ -504,7 +631,7 @@ static int sensor_threshold_event_handler(
 
   DEBUG("Threshold event received for sensor %s", n.type_instance);
 
-  sstrncpy(n.host, hostname_g, sizeof(n.host));
+  sstrncpy(n.host, (st->host != NULL) ? st->host : hostname_g, sizeof(n.host));
   sstrncpy(n.type, ipmi_sensor_get_sensor_type_string(sensor), sizeof(n.type));
   n.severity = sensor_convert_threshold_severity(threshold);
   n.time = NS_TO_CDTIME_T(ipmi_event_get_timestamp(event));
@@ -533,7 +660,7 @@ static int sensor_threshold_event_handler(
   plugin_notification_meta_free(n.meta);
 
   /* Delete handled ipmi event from the list */
-  if (c_ipmi_sel_clear_event) {
+  if (st->sel_clear_event) {
     ipmi_event_delete(event, NULL, NULL);
     return IPMI_EVENT_HANDLED;
   }
@@ -545,6 +672,9 @@ static int sensor_discrete_event_handler(ipmi_sensor_t *sensor,
                                          enum ipmi_event_dir_e dir, int offset,
                                          int severity, int prev_severity,
                                          void *cb_data, ipmi_event_t *event) {
+
+  c_ipmi_instance_t *st = (c_ipmi_instance_t *)cb_data;
+
   /* From the IPMI specification Chapter 2: Events.
    * If a callback handles the event, then all future callbacks called due to
    * the event will receive a NULL for the event. So be ready to handle a NULL
@@ -564,7 +694,7 @@ static int sensor_discrete_event_handler(ipmi_sensor_t *sensor,
 
   DEBUG("Discrete event received for sensor %s", n.type_instance);
 
-  sstrncpy(n.host, hostname_g, sizeof(n.host));
+  sstrncpy(n.host, (st->host != NULL) ? st->host : hostname_g, sizeof(n.host));
   sstrncpy(n.type, ipmi_sensor_get_sensor_type_string(sensor), sizeof(n.type));
   n.time = NS_TO_CDTIME_T(ipmi_event_get_timestamp(event));
 
@@ -582,7 +712,7 @@ static int sensor_discrete_event_handler(ipmi_sensor_t *sensor,
   plugin_notification_meta_free(n.meta);
 
   /* Delete handled ipmi event from the list */
-  if (c_ipmi_sel_clear_event) {
+  if (st->sel_clear_event) {
     ipmi_event_delete(event, NULL, NULL);
     return IPMI_EVENT_HANDLED;
   }
@@ -593,28 +723,29 @@ static int sensor_discrete_event_handler(ipmi_sensor_t *sensor,
 /*
  * Entity handlers
  */
-static void entity_sensor_update_handler(
-    enum ipmi_update_e op, ipmi_entity_t __attribute__((unused)) * entity,
-    ipmi_sensor_t *sensor, void __attribute__((unused)) * user_data) {
-  /* TODO: Ignore sensors we cannot read */
+static void
+entity_sensor_update_handler(enum ipmi_update_e op,
+                             ipmi_entity_t __attribute__((unused)) * entity,
+                             ipmi_sensor_t *sensor, void *user_data) {
+  c_ipmi_instance_t *st = (c_ipmi_instance_t *)user_data;
 
   if ((op == IPMI_ADDED) || (op == IPMI_CHANGED)) {
     /* Will check for duplicate entries.. */
-    sensor_list_add(sensor);
+    sensor_list_add(st, sensor);
 
-    if (c_ipmi_sel_enabled) {
+    if (st->sel_enabled) {
       int status = 0;
       /* register threshold event if threshold sensor support events */
       if ((ipmi_sensor_get_event_reading_type(sensor) ==
            IPMI_EVENT_READING_TYPE_THRESHOLD) &&
           (ipmi_sensor_get_threshold_access(sensor) !=
            IPMI_THRESHOLD_ACCESS_SUPPORT_NONE))
         status = ipmi_sensor_add_threshold_event_handler(
-            sensor, sensor_threshold_event_handler, NULL);
+            sensor, sensor_threshold_event_handler, st);
       /* register discrete handler if discrete/specific sensor support events */
       else if (ipmi_sensor_get_event_support(sensor) != IPMI_EVENT_SUPPORT_NONE)
         status = ipmi_sensor_add_discrete_event_handler(
-            sensor, sensor_discrete_event_handler, NULL);
+            sensor, sensor_discrete_event_handler, st);
 
       if (status) {
         char buf[DATA_MAX_NAME_LEN] = {0};
@@ -623,37 +754,39 @@ static void entity_sensor_update_handler(
       }
     }
   } else if (op == IPMI_DELETED) {
-    sensor_list_remove(sensor);
+    sensor_list_remove(st, sensor);
 
-    if (c_ipmi_sel_enabled) {
+    if (st->sel_enabled) {
       if (ipmi_sensor_get_event_reading_type(sensor) ==
           IPMI_EVENT_READING_TYPE_THRESHOLD)
         ipmi_sensor_remove_threshold_event_handler(
-            sensor, sensor_threshold_event_handler, NULL);
+            sensor, sensor_threshold_event_handler, st);
       else
         ipmi_sensor_remove_discrete_event_handler(
-            sensor, sensor_discrete_event_handler, NULL);
+            sensor, sensor_discrete_event_handler, st);
     }
   }
 } /* void entity_sensor_update_handler */
 
 /*
  * Domain handlers
  */
-static void domain_entity_update_handler(
-    enum ipmi_update_e op, ipmi_domain_t __attribute__((unused)) * domain,
-    ipmi_entity_t *entity, void __attribute__((unused)) * user_data) {
+static void
+domain_entity_update_handler(enum ipmi_update_e op,
+                             ipmi_domain_t __attribute__((unused)) * domain,
+                             ipmi_entity_t *entity, void *user_data) {
   int status;
+  c_ipmi_instance_t *st = (c_ipmi_instance_t *)user_data;
 
   if (op == IPMI_ADDED) {
     status = ipmi_entity_add_sensor_update_handler(
-        entity, entity_sensor_update_handler, /* user data = */ NULL);
+        entity, entity_sensor_update_handler, /* user data = */ (void *)st);
     if (status != 0) {
       c_ipmi_error("ipmi_entity_add_sensor_update_handler", status);
     }
   } else if (op == IPMI_DELETED) {
     status = ipmi_entity_remove_sensor_update_handler(
-        entity, entity_sensor_update_handler, /* user data = */ NULL);
+        entity, entity_sensor_update_handler, /* user data = */ (void *)st);
     if (status != 0) {
       c_ipmi_error("ipmi_entity_remove_sensor_update_handler", status);
     }
@@ -682,166 +815,410 @@ static void domain_connection_change_handler(ipmi_domain_t *domain, int err,
                                              unsigned int port_num,
                                              int still_connected,
                                              void *user_data) {
-  int status;
 
   DEBUG("domain_connection_change_handler (domain = %p, err = %i, "
         "conn_num = %u, port_num = %u, still_connected = %i, "
-        "user_data = %p);\n",
+        "user_data = %p);",
         (void *)domain, err, conn_num, port_num, still_connected, user_data);
 
-  status = ipmi_domain_add_entity_update_handler(
-      domain, domain_entity_update_handler, /* user data = */ NULL);
+  if (err != 0)
+    c_ipmi_error("domain_connection_change_handler", err);
+
+  if (!still_connected)
+    return;
+
+  c_ipmi_instance_t *st = (c_ipmi_instance_t *)user_data;
+
+  int status = ipmi_domain_add_entity_update_handler(
+      domain, domain_entity_update_handler, /* user data = */ st);
   if (status != 0) {
     c_ipmi_error("ipmi_domain_add_entity_update_handler", status);
   }
 
-  ipmi_con_t *smi_connection = user_data;
-  status = smi_connection->add_event_handler(smi_connection, smi_event_handler,
+  status = st->connection->add_event_handler(st->connection, smi_event_handler,
                                              (void *)domain);
 
   if (status != 0)
     c_ipmi_error("Failed to register smi event handler", status);
 } /* void domain_connection_change_handler */
 
-static int thread_init(os_handler_t **ret_os_handler) {
-  os_handler_t *os_handler;
-  ipmi_con_t *smi_connection = NULL;
+static int c_ipmi_thread_init(c_ipmi_instance_t *st) {
   ipmi_domain_id_t domain_id;
   int status;
 
-  os_handler = ipmi_posix_thread_setup_os_handler(SIGIO);
-  if (os_handler == NULL) {
-    ERROR("ipmi plugin: ipmi_posix_thread_setup_os_handler failed.");
-    return -1;
-  }
+  if (st->connaddr != NULL) {
+    char *ip_addrs[1] = {NULL}, *ports[1] = {NULL};
 
-  ipmi_init(os_handler);
+    ip_addrs[0] = strdup(st->connaddr);
+    ports[0] = strdup(IPMI_LAN_STD_PORT_STR);
 
-  status = ipmi_smi_setup_con(/* if_num = */ 0, os_handler,
-                              /* user data = */ NULL, &smi_connection);
-  if (status != 0) {
-    c_ipmi_error("ipmi_smi_setup_con", status);
-    return -1;
+    status = ipmi_ip_setup_con(ip_addrs, ports, 1, st->authtype,
+                               (unsigned int)IPMI_PRIVILEGE_USER, st->username,
+                               strlen(st->username), st->password,
+                               strlen(st->password), os_handler,
+                               /* user data = */ NULL, &st->connection);
+    if (status != 0) {
+      c_ipmi_error("ipmi_ip_setup_con", status);
+      return -1;
+    }
+  } else {
+    status = ipmi_smi_setup_con(/* if_num = */ 0, os_handler,
+                                /* user data = */ NULL, &st->connection);
+    if (status != 0) {
+      c_ipmi_error("ipmi_smi_setup_con", status);
+      return -1;
+    }
   }
 
-  ipmi_open_option_t open_option[1] = {[0] = {.option = IPMI_OPEN_OPTION_ALL,
-                                              {.ival = 1}}};
+  size_t open_option_num = 0;
+  ipmi_open_option_t open_option[2];
 
+  open_option[open_option_num].option = IPMI_OPEN_OPTION_ALL;
+  open_option[open_option_num].ival = 1;
+  open_option_num++;
+
+#ifdef IPMI_OPEN_OPTION_USE_CACHE
+  // This option appeared in OpenIPMI-2.0.17
+  open_option[open_option_num].option = IPMI_OPEN_OPTION_USE_CACHE;
+  open_option[open_option_num].ival = 0; /* Disable SDR cache in local file */
+  open_option_num++;
+#endif
+
+  /*
+   * NOTE: Domain names must be unique. There is static `domains_list` common
+   * to all threads inside lib/domain.c and some ops are done by name.
+   */
   status = ipmi_open_domain(
-      "mydomain", &smi_connection, /* num_con = */ 1,
-      domain_connection_change_handler,
-      /* user data = */ (void *)smi_connection,
+      st->name, &st->connection, /* num_con = */ 1,
+      domain_connection_change_handler, /* user data = */ (void *)st,
       /* domain_fully_up_handler = */ NULL, /* user data = */ NULL, open_option,
-      sizeof(open_option) / sizeof(open_option[0]), &domain_id);
+      open_option_num, &domain_id);
   if (status != 0) {
     c_ipmi_error("ipmi_open_domain", status);
     return -1;
   }
 
-  *ret_os_handler = os_handler;
   return 0;
-} /* int thread_init */
+} /* int c_ipmi_thread_init */
 
-static void *thread_main(void __attribute__((unused)) * user_data) {
+static void *c_ipmi_thread_main(void *user_data) {
   int status;
-  os_handler_t *os_handler = NULL;
+  c_ipmi_instance_t *st = (c_ipmi_instance_t *)user_data;
 
-  status = thread_init(&os_handler);
+  status = c_ipmi_thread_init(st);
   if (status != 0) {
-    ERROR("ipmi plugin: thread_init failed.\n");
+    ERROR("ipmi plugin: c_ipmi_thread_init failed.");
+    st->active = 0;
     return (void *)-1;
   }
 
-  while (c_ipmi_active != 0) {
+  while (st->active != 0) {
     struct timeval tv = {1, 0};
     os_handler->perform_one_op(os_handler, &tv);
   }
+  return (void *)0;
+} /* void *c_ipmi_thread_main */
 
-  ipmi_posix_thread_free_os_handler(os_handler);
+static c_ipmi_instance_t *c_ipmi_init_instance() {
+  c_ipmi_instance_t *st;
 
-  return (void *)0;
-} /* void *thread_main */
-
-static int c_ipmi_config(const char *key, const char *value) {
-  if (ignorelist == NULL)
-    ignorelist = ignorelist_create(/* invert = */ 1);
-  if (ignorelist == NULL)
-    return 1;
-
-  if (strcasecmp("Sensor", key) == 0) {
-    ignorelist_add(ignorelist, value);
-  } else if (strcasecmp("IgnoreSelected", key) == 0) {
-    ignorelist_set_invert(ignorelist, !IS_TRUE(value));
-  } else if (strcasecmp("NotifySensorAdd", key) == 0) {
-    c_ipmi_notify_add = IS_TRUE(value);
-  } else if (strcasecmp("NotifySensorRemove", key) == 0) {
-    c_ipmi_notify_remove = IS_TRUE(value);
-  } else if (strcasecmp("NotifySensorNotPresent", key) == 0) {
-    c_ipmi_notify_notpresent = IS_TRUE(value);
-  } else if (strcasecmp("SELEnabled", key) == 0) {
-    c_ipmi_sel_enabled = IS_TRUE(value);
-  } else if (strcasecmp("SELClearEvent", key) == 0) {
-    c_ipmi_sel_clear_event = IS_TRUE(value);
-  } else {
-    return -1;
+  st = calloc(1, sizeof(*st));
+  if (st == NULL) {
+    ERROR("ipmi plugin: calloc failed.");
+    return NULL;
   }
 
-  return 0;
-} /* int c_ipmi_config */
+  st->name = strdup("main");
+  if (st->name == NULL) {
+    sfree(st);
+    ERROR("ipmi plugin: strdup() failed.");
+    return NULL;
+  }
 
-static int c_ipmi_init(void) {
-  int status;
+  st->ignorelist = ignorelist_create(/* invert = */ 1);
+  if (st->ignorelist == NULL) {
+    sfree(st->name);
+    sfree(st);
+    ERROR("ipmi plugin: ignorelist_create() failed.");
+    return NULL;
+  }
 
-  /* Don't send `ADD' notifications during startup (~ 1 minute) */
-  time_t iv = CDTIME_T_TO_TIME_T(plugin_get_interval());
-  c_ipmi_init_in_progress = 1 + (60 / iv);
+  st->sensor_list = NULL;
+  pthread_mutex_init(&st->sensor_list_lock, /* attr = */ NULL);
+
+  st->host = NULL;
+  st->connaddr = NULL;
+  st->username = NULL;
+  st->password = NULL;
+  st->authtype = IPMI_AUTHTYPE_DEFAULT;
+
+  st->next = NULL;
+
+  return st;
+} /* c_ipmi_instance_t *c_ipmi_init_instance */
+
+static void c_ipmi_free_instance(c_ipmi_instance_t *st) {
+  if (st == NULL)
+    return;
+
+  assert(st->next == NULL);
+
+  sfree(st->name);
+  sfree(st->host);
+  sfree(st->connaddr);
+  sfree(st->username);
+  sfree(st->password);
+
+  ignorelist_free(st->ignorelist);
+  pthread_mutex_destroy(&st->sensor_list_lock);
+  sfree(st);
+} /* void c_ipmi_free_instance */
+
+void c_ipmi_add_instance(c_ipmi_instance_t *instance) {
+  if (instances == NULL) {
+    instances = instance;
+    return;
+  }
+
+  c_ipmi_instance_t *last = instances;
+
+  while (last->next != NULL)
+    last = last->next;
 
-  c_ipmi_active = 1;
+  last->next = instance;
+
+  return;
+} /* void c_ipmi_add_instance */
+
+static int c_ipmi_config_add_instance(oconfig_item_t *ci) {
+  int status = 0;
+  c_ipmi_instance_t *st = c_ipmi_init_instance();
+  if (st == NULL)
+    return ENOMEM;
+
+  if (strcasecmp(ci->key, "Instance") == 0)
+    status = cf_util_get_string(ci, &st->name);
 
-  status = plugin_thread_create(&thread_id, /* attr = */ NULL, thread_main,
-                                /* user data = */ NULL, "ipmi");
   if (status != 0) {
-    c_ipmi_active = 0;
-    thread_id = (pthread_t)0;
-    ERROR("ipmi plugin: pthread_create failed.");
-    return -1;
+    c_ipmi_free_instance(st);
+    return status;
+  }
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("Sensor", child->key) == 0)
+      ignorelist_add(st->ignorelist, ci->values[0].value.string);
+    else if (strcasecmp("IgnoreSelected", child->key) == 0) {
+      if (ci->values[0].value.boolean)
+        ignorelist_set_invert(st->ignorelist, /* invert = */ 0);
+      else
+        ignorelist_set_invert(st->ignorelist, /* invert = */ 1);
+    } else if (strcasecmp("NotifySensorAdd", child->key) == 0) {
+      if (ci->values[0].value.boolean)
+        st->notify_add = 1;
+    } else if (strcasecmp("NotifySensorRemove", child->key) == 0) {
+      if (ci->values[0].value.boolean)
+        st->notify_remove = 1;
+    } else if (strcasecmp("NotifySensorNotPresent", child->key) == 0) {
+      if (ci->values[0].value.boolean)
+        st->notify_notpresent = 1;
+    } else if (strcasecmp("SELEnabled", child->key) == 0) {
+      if (ci->values[0].value.boolean)
+        st->sel_enabled = 1;
+    } else if (strcasecmp("SELClearEvent", child->key) == 0) {
+      if (ci->values[0].value.boolean)
+        st->sel_clear_event = 1;
+    } else if (strcasecmp("Host", child->key) == 0)
+      status = cf_util_get_string(child, &st->host);
+    else if (strcasecmp("Address", child->key) == 0)
+      status = cf_util_get_string(child, &st->connaddr);
+    else if (strcasecmp("Username", child->key) == 0)
+      status = cf_util_get_string(child, &st->username);
+    else if (strcasecmp("Password", child->key) == 0)
+      status = cf_util_get_string(child, &st->password);
+    else if (strcasecmp("AuthType", child->key) == 0) {
+      char tmp[8];
+      status = cf_util_get_string_buffer(child, tmp, sizeof(tmp));
+      if (status != 0)
+        break;
+
+      if (strcasecmp("MD5", tmp) == 0)
+        st->authtype = IPMI_AUTHTYPE_MD5;
+      else if (strcasecmp("rmcp+", tmp) == 0)
+        st->authtype = IPMI_AUTHTYPE_RMCP_PLUS;
+      else
+        WARNING("ipmi plugin: The value \"%s\" is not valid for the "
+                "\"AuthType\" option.",
+                tmp);
+    } else {
+      WARNING("ipmi plugin: Option `%s' not allowed here.", child->key);
+      status = -1;
+    }
+
+    if (status != 0)
+      break;
   }
 
+  if (status != 0) {
+    c_ipmi_free_instance(st);
+    return status;
+  }
+
+  c_ipmi_add_instance(st);
+
   return 0;
-} /* int c_ipmi_init */
+} /* int c_ipmi_config_add_instance */
+
+static int c_ipmi_config(oconfig_item_t *ci) {
+  _Bool have_instance_block = 0;
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("Instance", child->key) == 0) {
+      c_ipmi_config_add_instance(child);
+      have_instance_block = 1;
+    } else if (!have_instance_block) {
+      /* Non-instance option: Assume legacy configuration (without <Instance />
+       * blocks) and call c_ipmi_config_add_instance with the <Plugin /> block.
+       */
+      return c_ipmi_config_add_instance(ci);
+    } else
+      WARNING("ipmi plugin: The configuration option "
+              "\"%s\" is not allowed here. Did you "
+              "forget to add an <Instance /> block "
+              "around the configuration?",
+              child->key);
+  } /* for (ci->children) */
 
-static int c_ipmi_read(void) {
-  if ((c_ipmi_active == 0) || (thread_id == (pthread_t)0)) {
+  return 0;
+} /* int c_ipmi_config */
+
+static int c_ipmi_read(user_data_t *user_data) {
+  c_ipmi_instance_t *st;
+  st = user_data->data;
+
+  if ((st->active == 0) || (st->thread_id == (pthread_t)0)) {
     INFO("ipmi plugin: c_ipmi_read: I'm not active, returning false.");
     return -1;
   }
 
-  sensor_list_read_all();
+  sensor_list_read_all(st);
 
-  if (c_ipmi_init_in_progress > 0)
-    c_ipmi_init_in_progress--;
+  if (st->init_in_progress > 0)
+    st->init_in_progress--;
   else
-    c_ipmi_init_in_progress = 0;
+    st->init_in_progress = 0;
 
   return 0;
 } /* int c_ipmi_read */
 
+static int c_ipmi_init(void) {
+  int status;
+  c_ipmi_instance_t *st;
+  char callback_name[3 * DATA_MAX_NAME_LEN];
+
+  os_handler = ipmi_posix_thread_setup_os_handler(SIGIO);
+  if (os_handler == NULL) {
+    ERROR("ipmi plugin: ipmi_posix_thread_setup_os_handler failed.");
+    return -1;
+  }
+
+  os_handler->set_log_handler(os_handler, c_ipmi_log);
+
+  if (ipmi_init(os_handler) != 0) {
+    ERROR("ipmi plugin: ipmi_init() failed.");
+    os_handler->free_os_handler(os_handler);
+    return -1;
+  };
+
+  /* Don't send `ADD' notifications during startup (~ 1 minute) */
+  time_t iv = CDTIME_T_TO_TIME_T(plugin_get_interval());
+
+  if (instances == NULL) {
+    /* No instances were configured, let's start a default instance. */
+    st = c_ipmi_init_instance();
+    if (st == NULL)
+      return ENOMEM;
+
+    c_ipmi_add_instance(st);
+  }
+
+  st = instances;
+  while (NULL != st) {
+    /* The `st->name` is used as "domain name" for ipmi_open_domain().
+     * That value should be unique, so we do plugin_register_complex_read()
+     * at first as it checks the uniqueness. */
+    snprintf(callback_name, sizeof(callback_name), "ipmi/%s", st->name);
+
+    user_data_t ud = {
+        .data = st,
+    };
+
+    status = plugin_register_complex_read(
+        /* group     = */ "ipmi",
+        /* name      = */ callback_name,
+        /* callback  = */ c_ipmi_read,
+        /* interval  = */ 0,
+        /* user_data = */ &ud);
+
+    if (status != 0) {
+      st->active = 0;
+      st = st->next;
+      continue;
+    }
+
+    st->init_in_progress = 1 + (60 / iv);
+    st->active = 1;
+
+    status = plugin_thread_create(&st->thread_id, /* attr = */ NULL,
+                                  c_ipmi_thread_main,
+                                  /* user data = */ (void *)st, "ipmi");
+
+    if (status != 0) {
+      st->active = 0;
+      st->thread_id = (pthread_t)0;
+
+      plugin_unregister_read(callback_name);
+
+      ERROR("ipmi plugin: pthread_create failed for `%s`.", callback_name);
+    }
+
+    st = st->next;
+  }
+
+  return 0;
+} /* int c_ipmi_init */
+
 static int c_ipmi_shutdown(void) {
-  c_ipmi_active = 0;
+  c_ipmi_instance_t *st = instances;
+  instances = NULL;
+
+  while (st != NULL) {
+    c_ipmi_instance_t *next = st->next;
+
+    st->next = NULL;
+    st->active = 0;
+
+    if (st->thread_id != (pthread_t)0) {
+      pthread_join(st->thread_id, NULL);
+      st->thread_id = (pthread_t)0;
+    }
+
+    sensor_list_remove_all(st);
+    c_ipmi_free_instance(st);
 
-  if (thread_id != (pthread_t)0) {
-    pthread_join(thread_id, NULL);
-    thread_id = (pthread_t)0;
+    st = next;
   }
 
-  sensor_list_remove_all();
+  os_handler->free_os_handler(os_handler);
 
   return 0;
 } /* int c_ipmi_shutdown */
 
 void module_register(void) {
-  plugin_register_config("ipmi", c_ipmi_config, config_keys, config_keys_num);
+  plugin_register_complex_config("ipmi", c_ipmi_config);
   plugin_register_init("ipmi", c_ipmi_init);
-  plugin_register_read("ipmi", c_ipmi_read);
   plugin_register_shutdown("ipmi", c_ipmi_shutdown);
 } /* void module_register */