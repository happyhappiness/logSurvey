@@ -1,5 +1,5 @@
 /*
- * $Id: acl.cc,v 1.95 1997/05/15 01:18:41 wessels Exp $
+ * $Id: acl.cc,v 1.96 1997/06/04 06:15:44 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -113,7 +113,7 @@ strtokFile(void)
 		t++;
 	    *t = '\0';
 	    if ((aclFile = fopen(fn, "r")) == NULL) {
-		debug(28, 0, "strtokFile: %s not found\n", fn);
+		debug(28, 0) ("strtokFile: %s not found\n", fn);
 		return (NULL);
 	    }
 	    aclFromFile = 1;
@@ -240,7 +240,7 @@ decode_addr(const char *asc, struct in_addr *addr, struct in_addr *mask)
     switch (sscanf(asc, "%d.%d.%d.%d", &a1, &a2, &a3, &a4)) {
     case 4:			/* a dotted quad */
 	if (!safe_inet_addr(asc, addr)) {
-	    debug(28, 0, "decode_addr: unsafe IP address: '%s'\n", asc);
+	    debug(28, 0) ("decode_addr: unsafe IP address: '%s'\n", asc);
 	    fatal("decode_addr: unsafe IP address");
 	}
 	break;
@@ -256,7 +256,7 @@ decode_addr(const char *asc, struct in_addr *addr, struct in_addr *mask)
 	    *addr = inaddrFromHostent(hp);
 	} else {
 	    /* XXX: Here we could use getnetbyname */
-	    debug(28, 0, "decode_addr: Invalid IP address or hostname '%s'\n", asc);
+	    debug(28, 0) ("decode_addr: Invalid IP address or hostname '%s'\n", asc);
 	    return 0;		/* This is not valid address */
 	}
 	break;
@@ -287,7 +287,7 @@ aclParseIpData(const char *t)
     LOCAL_ARRAY(char, addr2, 256);
     LOCAL_ARRAY(char, mask, 256);
     struct _acl_ip_data *q = xcalloc(1, sizeof(struct _acl_ip_data));
-    debug(28, 5, "aclParseIpData: %s\n", t);
+    debug(28, 5) ("aclParseIpData: %s\n", t);
     if (!strcasecmp(t, "all")) {
 	q->addr1.s_addr = 0;
 	q->addr2.s_addr = 0;
@@ -309,31 +309,31 @@ aclParseIpData(const char *t)
 	addr2[0] = '\0';
 	mask[0] = '\0';
     } else {
-	debug(28, 0, "aclParseIpData: Bad host/IP: '%s'\n", t);
+	debug(28, 0) ("aclParseIpData: Bad host/IP: '%s'\n", t);
 	safe_free(q);
 	return NULL;
     }
     /* Decode addr1 */
     if (!decode_addr(addr1, &q->addr1, &q->mask)) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseIpData: Ignoring invalid IP acl entry: unknown first address '%s'\n", addr1);
+	debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown first address '%s'\n", addr1);
 	safe_free(q);
 	return NULL;
     }
     /* Decode addr2 */
     if (*addr2 && !decode_addr(addr2, &q->addr2, &q->mask)) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseIpData: Ignoring invalid IP acl entry: unknown second address '%s'\n", addr2);
+	debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown second address '%s'\n", addr2);
 	safe_free(q);
 	return NULL;
     }
     /* Decode mask */
     if (*mask && !decode_addr(mask, &q->mask, NULL)) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseIpData: Ignoring invalid IP acl entry: unknown netmask '%s'\n", mask);
+	debug(28, 0) ("aclParseIpData: Ignoring invalid IP acl entry: unknown netmask '%s'\n", mask);
 	safe_free(q);
 	return NULL;
     }
@@ -435,28 +435,28 @@ aclParseTimeSpec(void *curlist)
 		    q->weekbits |= ACL_WEEKDAYS;
 		    break;
 		default:
-		    debug(28, 0, "%s line %d: %s\n",
+		    debug(28, 0) ("%s line %d: %s\n",
 			cfg_filename, config_lineno, config_input_line);
-		    debug(28, 0, "aclParseTimeSpec: Bad Day '%c'\n",
+		    debug(28, 0) ("aclParseTimeSpec: Bad Day '%c'\n",
 			*t);
 		    break;
 		}
 	    }
 	} else {
 	    /* assume its time-of-day spec */
 	    if (sscanf(t, "%d:%d-%d:%d", &h1, &m1, &h2, &m2) < 4) {
-		debug(28, 0, "%s line %d: %s\n",
+		debug(28, 0) ("%s line %d: %s\n",
 		    cfg_filename, config_lineno, config_input_line);
-		debug(28, 0, "aclParseTimeSpec: IGNORING Bad time range\n");
+		debug(28, 0) ("aclParseTimeSpec: IGNORING Bad time range\n");
 		xfree(q);
 		return;
 	    }
 	    q->start = h1 * 60 + m1;
 	    q->stop = h2 * 60 + m2;
 	    if (q->start > q->stop) {
-		debug(28, 0, "%s line %d: %s\n",
+		debug(28, 0) ("%s line %d: %s\n",
 		    cfg_filename, config_lineno, config_input_line);
-		debug(28, 0, "aclParseTimeSpec: IGNORING Reversed time range\n");
+		debug(28, 0) ("aclParseTimeSpec: IGNORING Reversed time range\n");
 		xfree(q);
 		return;
 	    }
@@ -486,9 +486,9 @@ aclParseRegexList(void *curlist, int icase)
 	if ((errcode = regcomp(&comp, t, flags)) != 0) {
 	    char errbuf[256];
 	    regerror(errcode, &comp, errbuf, sizeof errbuf);
-	    debug(28, 0, "%s line %d: %s\n",
+	    debug(28, 0) ("%s line %d: %s\n",
 		cfg_filename, config_lineno, config_input_line);
-	    debug(28, 0, "aclParseRegexList: Invalid regular expression '%s': %s\n",
+	    debug(28, 0) ("aclParseRegexList: Invalid regular expression '%s': %s\n",
 		t, errbuf);
 	    continue;
 	}
@@ -580,38 +580,38 @@ aclParseAclLine(void)
 
     /* snarf the ACL name */
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseAclLine: missing ACL name.\n");
+	debug(28, 0) ("aclParseAclLine: missing ACL name.\n");
 	return;
     }
     xstrncpy(aclname, t, ACL_NAME_SZ);
     /* snarf the ACL type */
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseAclLine: missing ACL type.\n");
+	debug(28, 0) ("aclParseAclLine: missing ACL type.\n");
 	return;
     }
     if ((acltype = aclType(t)) == ACL_NONE) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseAclLine: Invalid ACL type '%s'\n", t);
+	debug(28, 0) ("aclParseAclLine: Invalid ACL type '%s'\n", t);
 	return;
     }
     if ((A = aclFindByName(aclname)) == NULL) {
-	debug(28, 3, "aclParseAclLine: Creating ACL '%s'\n", aclname);
+	debug(28, 3) ("aclParseAclLine: Creating ACL '%s'\n", aclname);
 	A = xcalloc(1, sizeof(struct _acl));
 	xstrncpy(A->name, aclname, ACL_NAME_SZ);
 	A->type = acltype;
 	A->cfgline = xstrdup(config_input_line);
 	new_acl = 1;
     } else {
 	if (acltype != A->type) {
-	    debug(28, 0, "aclParseAclLine: ACL '%s' already exists with different type, skipping.\n", A->name);
+	    debug(28, 0) ("aclParseAclLine: ACL '%s' already exists with different type, skipping.\n", A->name);
 	    return;
 	}
-	debug(28, 3, "aclParseAclLine: Appending to '%s'\n", aclname);
+	debug(28, 3) ("aclParseAclLine: Appending to '%s'\n", aclname);
 	new_acl = 0;
     }
     switch (A->type) {
@@ -654,7 +654,7 @@ aclParseAclLine(void)
     if (!new_acl)
 	return;
     if (A->data == NULL) {
-	debug(28, 0, "aclParseAclLine: IGNORING invalid ACL: %s\n",
+	debug(28, 0) ("aclParseAclLine: IGNORING invalid ACL: %s\n",
 	    A->cfgline);
 	xfree(A);
 	return;
@@ -711,9 +711,9 @@ aclParseDenyInfoLine(struct _acl_deny_info_list **head)
 
     /* first expect an url */
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseDenyInfoLine: missing 'url' parameter.\n");
+	debug(28, 0) ("aclParseDenyInfoLine: missing 'url' parameter.\n");
 	return;
     }
     A = xcalloc(1, sizeof(struct _acl_deny_info_list));
@@ -728,9 +728,9 @@ aclParseDenyInfoLine(struct _acl_deny_info_list **head)
 	Tail = &L->next;
     }
     if (A->acl_list == NULL) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseDenyInfoLine: deny_info line contains no ACL's, skipping\n");
+	debug(28, 0) ("aclParseDenyInfoLine: deny_info line contains no ACL's, skipping\n");
 	xfree(A);
 	return;
     }
@@ -751,9 +751,9 @@ aclParseAccessLine(struct _acl_access **head)
 
     /* first expect either 'allow' or 'deny' */
     if ((t = strtok(NULL, w_space)) == NULL) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseAccessLine: missing 'allow' or 'deny'.\n");
+	debug(28, 0) ("aclParseAccessLine: missing 'allow' or 'deny'.\n");
 	return;
     }
     A = xcalloc(1, sizeof(struct _acl_access));
@@ -762,9 +762,9 @@ aclParseAccessLine(struct _acl_access **head)
     else if (!strcmp(t, "deny"))
 	A->allow = 0;
     else {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseAccessLine: expecting 'allow' or 'deny', got '%s'.\n", t);
+	debug(28, 0) ("aclParseAccessLine: expecting 'allow' or 'deny', got '%s'.\n", t);
 	xfree(A);
 	return;
     }
@@ -780,12 +780,12 @@ aclParseAccessLine(struct _acl_access **head)
 	    L->op = 0;
 	    t++;
 	}
-	debug(28, 3, "aclParseAccessLine: looking for ACL name '%s'\n", t);
+	debug(28, 3) ("aclParseAccessLine: looking for ACL name '%s'\n", t);
 	a = aclFindByName(t);
 	if (a == NULL) {
-	    debug(28, 0, "%s line %d: %s\n",
+	    debug(28, 0) ("%s line %d: %s\n",
 		cfg_filename, config_lineno, config_input_line);
-	    debug(28, 0, "aclParseAccessLine: ACL name '%s' not found.\n", t);
+	    debug(28, 0) ("aclParseAccessLine: ACL name '%s' not found.\n", t);
 	    xfree(L);
 	    continue;
 	}
@@ -794,9 +794,9 @@ aclParseAccessLine(struct _acl_access **head)
 	Tail = &L->next;
     }
     if (A->acl_list == NULL) {
-	debug(28, 0, "%s line %d: %s\n",
+	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(28, 0, "aclParseAccessLine: Access line contains no ACL's, skipping\n");
+	debug(28, 0) ("aclParseAccessLine: Access line contains no ACL's, skipping\n");
 	xfree(A);
 	return;
     }
@@ -815,7 +815,7 @@ aclMatchIp(void *dataptr, struct in_addr c)
 {
     splayNode **Top = dataptr;
     *Top = splay_splay(&c, *Top, aclIpNetworkCompare);
-    debug(28, 3, "aclMatchIp: '%s' %s\n",
+    debug(28, 3) ("aclMatchIp: '%s' %s\n",
 	inet_ntoa(c), splayLastResult ? "NOT found" : "found");
     return !splayLastResult;
 }
@@ -826,10 +826,10 @@ aclMatchIp(void *dataptr, struct in_addr c)
 {
     tree **data = dataptr;
     if (tree_srch(data, bintreeIpNetworkCompare, &c)) {
-	debug(28, 3, "aclMatchIp: '%s' found\n", inet_ntoa(c));
+	debug(28, 3) ("aclMatchIp: '%s' found\n", inet_ntoa(c));
 	return 1;
     }
-    debug(28, 3, "aclMatchIp: '%s' NOT found\n", inet_ntoa(c));
+    debug(28, 3) ("aclMatchIp: '%s' NOT found\n", inet_ntoa(c));
     return 0;
 }
 
@@ -847,12 +847,12 @@ aclMatchIp(void *dataptr, struct in_addr c)
     prev = NULL;		/* previous element in the list */
     while (data) {
 	h.s_addr = c.s_addr & data->mask.s_addr;
-	debug(28, 3, "aclMatchIp: h     = %s\n", inet_ntoa(h));
-	debug(28, 3, "aclMatchIp: addr1 = %s\n", inet_ntoa(data->addr1));
-	debug(28, 3, "aclMatchIp: addr2 = %s\n", inet_ntoa(data->addr2));
+	debug(28, 3) ("aclMatchIp: h     = %s\n", inet_ntoa(h));
+	debug(28, 3) ("aclMatchIp: addr1 = %s\n", inet_ntoa(data->addr1));
+	debug(28, 3) ("aclMatchIp: addr2 = %s\n", inet_ntoa(data->addr2));
 	if (!data->addr2.s_addr) {
 	    if (h.s_addr == data->addr1.s_addr) {
-		debug(28, 3, "aclMatchIp: returning 1\n");
+		debug(28, 3) ("aclMatchIp: returning 1\n");
 		if (prev != NULL) {
 		    /* shift the element just found to the second position
 		     * in the list */
@@ -868,7 +868,7 @@ aclMatchIp(void *dataptr, struct in_addr c)
 	    la1 = ntohl(data->addr1.s_addr);
 	    la2 = ntohl(data->addr2.s_addr);
 	    if (lh >= la1 && lh <= la2) {
-		debug(28, 3, "aclMatchIp: returning 1\n");
+		debug(28, 3) ("aclMatchIp: returning 1\n");
 		if (prev != NULL) {
 		    /* shift the element just found to the second position
 		     * in the list */
@@ -882,7 +882,7 @@ aclMatchIp(void *dataptr, struct in_addr c)
 	prev = data;
 	data = data->next;
     }
-    debug(28, 3, "aclMatchIp: returning 0\n");
+    debug(28, 3) ("aclMatchIp: returning 0\n");
     return 0;
 }
 
@@ -899,9 +899,9 @@ aclMatchDomainList(void *dataptr, const char *host)
     splayNode **Top = dataptr;
     if (host == NULL)
 	return 0;
-    debug(28, 3, "aclMatchDomainList: checking '%s'\n", host);
+    debug(28, 3) ("aclMatchDomainList: checking '%s'\n", host);
     *Top = splay_splay(host, *Top, aclHostDomainCompare);
-    debug(28, 3, "aclMatchDomainList: '%s' %s\n",
+    debug(28, 3) ("aclMatchDomainList: '%s' %s\n",
 	host, splayLastResult ? "NOT found" : "found");
     return !splayLastResult;
 }
@@ -913,12 +913,12 @@ aclMatchDomainList(void *dataptr, const char *host)
     tree **data = dataptr;
     if (host == NULL)
 	return 0;
-    debug(28, 3, "aclMatchDomainList: checking '%s'\n", host);
+    debug(28, 3) ("aclMatchDomainList: checking '%s'\n", host);
     if (tree_srch(data, bintreeHostDomainCompare, (void *) host)) {
-	debug(28, 3, "aclMatchDomainList: '%s' found\n", host);
+	debug(28, 3) ("aclMatchDomainList: '%s' found\n", host);
 	return 1;
     }
-    debug(28, 3, "aclMatchDomainList: '%s' NOT found\n", host);
+    debug(28, 3) ("aclMatchDomainList: '%s' NOT found\n", host);
     return 0;
 }
 
@@ -931,9 +931,9 @@ aclMatchDomainList(void *dataptr, const char *host)
     wordlist *prev = NULL;
     if (host == NULL)
 	return 0;
-    debug(28, 3, "aclMatchDomainList: checking '%s'\n", host);
+    debug(28, 3) ("aclMatchDomainList: checking '%s'\n", host);
     for (data = *Head; data; data = data->next) {
-	debug(28, 3, "aclMatchDomainList: looking for '%s'\n", data->key);
+	debug(28, 3) ("aclMatchDomainList: looking for '%s'\n", data->key);
 	if (matchDomainName(data->key, host)) {
 	    if (prev) {
 		/* shift the element just found to the top of the list */
@@ -956,11 +956,11 @@ aclMatchRegex(relist * data, const char *word)
     relist *first, *prev;
     if (word == NULL)
 	return 0;
-    debug(28, 3, "aclMatchRegex: checking '%s'\n", word);
+    debug(28, 3) ("aclMatchRegex: checking '%s'\n", word);
     first = data;
     prev = NULL;
     while (data) {
-	debug(28, 3, "aclMatchRegex: looking for '%s'\n", data->pattern);
+	debug(28, 3) ("aclMatchRegex: looking for '%s'\n", data->pattern);
 	if (regexec(&data->regex, word, 0, 0, 0) == 0) {
 	    if (prev != NULL) {
 		/* shift the element just found to the second position
@@ -982,9 +982,9 @@ aclMatchIdent(wordlist * data, const char *ident)
 {
     if (ident == NULL)
 	return 0;
-    debug(28, 3, "aclMatchIdent: checking '%s'\n", ident);
+    debug(28, 3) ("aclMatchIdent: checking '%s'\n", ident);
     while (data) {
-	debug(28, 3, "aclMatchIdent: looking for '%s'\n", data->key);
+	debug(28, 3) ("aclMatchIdent: looking for '%s'\n", data->key);
 	if (strcmp(data->key, "REQUIRED") == 0 && *ident != '\0')
 	    return 1;
 	if (strcmp(data->key, ident) == 0)
@@ -1030,7 +1030,7 @@ aclMatchTime(struct _acl_time_data *data, time_t when)
 	xmemcpy(&tm, localtime(&when), sizeof(struct tm));
     }
     t = (time_t) (tm.tm_hour * 60 + tm.tm_min);
-    debug(28, 3, "aclMatchTime: checking %d in %d-%d, weekbits=%x\n",
+    debug(28, 3) ("aclMatchTime: checking %d in %d-%d, weekbits=%x\n",
 	(int) t, (int) data->start, (int) data->stop, data->weekbits);
 
     if (t < data->start || t > data->stop)
@@ -1047,7 +1047,7 @@ aclMatchAcl(struct _acl *acl, aclCheck_t * checklist)
     int k;
     if (!acl)
 	return 0;
-    debug(28, 3, "aclMatchAcl: checking '%s'\n", acl->cfgline);
+    debug(28, 3) ("aclMatchAcl: checking '%s'\n", acl->cfgline);
     switch (acl->type) {
     case ACL_SRC_IP:
 	return aclMatchIp(&acl->data, checklist->src_addr);
@@ -1061,7 +1061,7 @@ aclMatchAcl(struct _acl *acl, aclCheck_t * checklist)
 	    }
 	    return 0;
 	} else if (checklist->state[ACL_DST_IP] == ACL_LOOKUP_NONE) {
-	    debug(28, 3, "aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+	    debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
 		acl->name, r->host);
 	    checklist->state[ACL_DST_IP] = ACL_LOOKUP_NEEDED;
 	    return 0;
@@ -1076,7 +1076,7 @@ aclMatchAcl(struct _acl *acl, aclCheck_t * checklist)
 	if (fqdn)
 	    return aclMatchDomainList(&acl->data, fqdn);
 	if (checklist->state[ACL_DST_DOMAIN] == ACL_LOOKUP_NONE) {
-	    debug(28, 3, "aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+	    debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
 		acl->name, inet_ntoa(ia->in_addrs[0]));
 	    checklist->state[ACL_DST_DOMAIN] = ACL_LOOKUP_NEEDED;
 	    return 0;
@@ -1088,7 +1088,7 @@ aclMatchAcl(struct _acl *acl, aclCheck_t * checklist)
 	if (fqdn) {
 	    return aclMatchDomainList(&acl->data, fqdn);
 	} else if (checklist->state[ACL_SRC_DOMAIN] == ACL_LOOKUP_NONE) {
-	    debug(28, 3, "aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
+	    debug(28, 3) ("aclMatchAcl: Can't yet compare '%s' ACL for '%s'\n",
 		acl->name, inet_ntoa(checklist->src_addr));
 	    checklist->state[ACL_SRC_DOMAIN] = ACL_LOOKUP_NEEDED;
 	    return 0;
@@ -1109,7 +1109,7 @@ aclMatchAcl(struct _acl *acl, aclCheck_t * checklist)
 	return aclMatchInteger(acl->data, r->port);
 	/* NOTREACHED */
     case ACL_USER:
-	/* debug(28, 0, "aclMatchAcl: ACL_USER unimplemented\n"); */
+	/* debug(28, 0)("aclMatchAcl: ACL_USER unimplemented\n"); */
 	/* return 0; */
 	return aclMatchIdent(acl->data, checklist->ident);
 	/* NOTREACHED */
@@ -1124,7 +1124,7 @@ aclMatchAcl(struct _acl *acl, aclCheck_t * checklist)
 	/* NOTREACHED */
     case ACL_NONE:
     default:
-	debug(28, 0, "aclMatchAcl: '%s' has bad type %d\n",
+	debug(28, 0) ("aclMatchAcl: '%s' has bad type %d\n",
 	    acl->name, acl->type);
 	return 0;
     }
@@ -1136,15 +1136,15 @@ aclMatchAclList(const struct _acl_list *list, aclCheck_t * checklist)
 {
     while (list) {
 	AclMatchedName = list->acl->name;
-	debug(28, 3, "aclMatchAclList: checking %s%s\n",
+	debug(28, 3) ("aclMatchAclList: checking %s%s\n",
 	    list->op ? null_string : "!", list->acl->name);
 	if (aclMatchAcl(list->acl, checklist) != list->op) {
-	    debug(28, 3, "aclMatchAclList: returning 0\n");
+	    debug(28, 3) ("aclMatchAclList: returning 0\n");
 	    return 0;
 	}
 	list = list->next;
     }
-    debug(28, 3, "aclMatchAclList: returning 1\n");
+    debug(28, 3) ("aclMatchAclList: returning 1\n");
     return 1;
 }
 
@@ -1169,7 +1169,7 @@ aclCheck(aclCheck_t * checklist)
     int match;
     ipcache_addrs *ia;
     while ((A = checklist->access_list)) {
-	debug(28, 3, "aclCheck: checking '%s'\n", A->cfgline);
+	debug(28, 3) ("aclCheck: checking '%s'\n", A->cfgline);
 	allow = A->allow;
 	match = aclMatchAclList(A->acl_list, checklist);
 	if (checklist->state[ACL_DST_IP] == ACL_LOOKUP_NEEDED) {
@@ -1199,13 +1199,13 @@ aclCheck(aclCheck_t * checklist)
 	    return;
 	}
 	if (match) {
-	    debug(28, 3, "aclCheck: match found, returning %d\n", allow);
+	    debug(28, 3) ("aclCheck: match found, returning %d\n", allow);
 	    aclCheckCallback(checklist, allow);
 	    return;
 	}
 	checklist->access_list = A->next;
     }
-    debug(28, 3, "aclCheck: NO match found, returning %d\n", !allow);
+    debug(28, 3) ("aclCheck: NO match found, returning %d\n", !allow);
     aclCheckCallback(checklist, !allow);
 }
 
@@ -1225,7 +1225,7 @@ aclChecklistFree(aclCheck_t * checklist)
 static void
 aclCheckCallback(aclCheck_t * checklist, int answer)
 {
-    debug(28, 3, "aclCheckCallback: answer=%d\n", answer);
+    debug(28, 3) ("aclCheckCallback: answer=%d\n", answer);
     checklist->callback(answer, checklist->callback_data);
     checklist->callback = NULL;
     checklist->callback_data = NULL;
@@ -1351,7 +1351,7 @@ aclDestroyAcls(void)
     struct _acl *next = NULL;
     for (a = AclList; a; a = next) {
 	next = a->next;
-	debug(28, 3, "aclDestroyAcls: '%s'\n", a->cfgline);
+	debug(28, 3) ("aclDestroyAcls: '%s'\n", a->cfgline);
 	switch (a->type) {
 	case ACL_SRC_IP:
 	case ACL_DST_IP:
@@ -1417,7 +1417,7 @@ aclDestroyAccessList(struct _acl_access **list)
     struct _acl_access *l = NULL;
     struct _acl_access *next = NULL;
     for (l = *list; l; l = next) {
-	debug(28, 3, "aclDestroyAccessList: '%s'\n", l->cfgline);
+	debug(28, 3) ("aclDestroyAccessList: '%s'\n", l->cfgline);
 	next = l->next;
 	aclDestroyAclList(l->acl_list);
 	l->acl_list = NULL;
@@ -1,5 +1,5 @@
 /*
- * $Id: cache_cf.cc,v 1.195 1997/06/02 19:55:58 wessels Exp $
+ * $Id: cache_cf.cc,v 1.196 1997/06/04 06:15:46 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -382,7 +382,7 @@ parseCacheHostLine(void)
 	} else if (!strncasecmp(token, "round-robin", 11)) {
 	    options |= NEIGHBOR_ROUNDROBIN;
 	} else {
-	    debug(3, 0, "parseCacheHostLine: token='%s'\n", token);
+	    debug(3, 0) ("parseCacheHostLine: token='%s'\n", token);
 	    self_destruct();
 	}
     }
@@ -569,7 +569,7 @@ parsePathname(char **path, int fatal)
     safe_free(*path);
     *path = xstrdup(token);
     if (fatal && stat(token, &sb) < 0) {
-	debug(50, 1, "parsePathname: %s: %s\n", token, xstrerror());
+	debug(50, 1) ("parsePathname: %s: %s\n", token, xstrerror());
 	self_destruct();
     }
 }
@@ -898,7 +898,7 @@ parseConfigFile(const char *file_name)
 	    continue;
 	if (config_input_line[0] == '\0')
 	    continue;
-	debug(3, 5, "Processing: '%s'\n", config_input_line);
+	debug(3, 5) ("Processing: '%s'\n", config_input_line);
 	strcpy(tmp_line, config_input_line);
 	if ((token = strtok(tmp_line, w_space)) == NULL)
 	    continue;
@@ -1197,7 +1197,7 @@ parseConfigFile(const char *file_name)
 
 	/* If unknown, treat as a comment line */
 	else {
-	    debug(3, 0, "parseConfigFile: line %d unrecognized: '%s'\n",
+	    debug(3, 0) ("parseConfigFile: line %d unrecognized: '%s'\n",
 		config_lineno,
 		config_input_line);
 	}
@@ -1468,6 +1468,6 @@ parseTimeUnits(const char *unit)
 	return 86400 * 365.2522;
     if (!strncasecmp(unit, T_DECADE_STR, strlen(T_DECADE_STR)))
 	return 86400 * 365.2522 * 10;
-    debug(3, 1, "parseTimeUnits: unknown time unit '%s'\n", unit);
+    debug(3, 1) ("parseTimeUnits: unknown time unit '%s'\n", unit);
     return 0;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.110 1997/06/03 20:08:22 wessels Exp $
+ * $Id: client_side.cc,v 1.111 1997/06/04 06:15:47 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -54,13 +54,13 @@ clientProxyAuthCheck(clientHttpRequest * http)
 
     if (Config.proxyAuth.IgnoreDomains) {
 	if (aclMatchRegex(Config.proxyAuth.IgnoreDomains, http->request->host)) {
-	    debug(33, 2, "clientProxyAuthCheck: host \"%s\" matched proxyAuthIgnoreDomains\n", http->request->host);
+	    debug(33, 2) ("clientProxyAuthCheck: host \"%s\" matched proxyAuthIgnoreDomains\n", http->request->host);
 	    return 1;
 	}
     }
     proxy_user = proxyAuthenticate(http->request_hdr);
     xstrncpy(http->ident.ident, proxy_user, ICP_IDENT_SZ);
-    debug(33, 6, "clientProxyAuthCheck: user = %s\n", http->ident.ident);
+    debug(33, 6) ("clientProxyAuthCheck: user = %s\n", http->ident.ident);
 
     if (strcmp(http->ident.ident, dash_str) == 0)
 	return 0;
@@ -98,7 +98,7 @@ clientAccessCheck(void *data)
     if (clientProxyAuthCheck(http) == 0) {
 	char *wbuf = NULL;
 	int fd = conn->fd;
-	debug(33, 4, "Proxy Denied: %s\n", http->url);
+	debug(33, 4) ("Proxy Denied: %s\n", http->url);
 	http->log_type = ERR_PROXY_DENIED;
 	http->http_code = 407;
 	wbuf = xstrdup(proxy_denied_msg(http->http_code,
@@ -131,7 +131,7 @@ clientAccessCheckDone(int answer, void *data)
     int fd = conn->fd;
     char *buf = NULL;
     char *redirectUrl = NULL;
-    debug(33, 5, "clientAccessCheckDone: '%s' answer=%d\n", http->url, answer);
+    debug(33, 5) ("clientAccessCheckDone: '%s' answer=%d\n", http->url, answer);
     http->acl_checklist = NULL;
     if (answer) {
 	urlCanonical(http->request, http->url);
@@ -140,7 +140,7 @@ clientAccessCheckDone(int answer, void *data)
 	http->redirect_state = REDIRECT_PENDING;
 	redirectStart(http, clientRedirectDone, http);
     } else {
-	debug(33, 5, "Access Denied: %s\n", http->url);
+	debug(33, 5) ("Access Denied: %s\n", http->url);
 	redirectUrl = aclGetDenyInfoUrl(&Config.denyInfoList, AclMatchedName);
 	if (redirectUrl) {
 	    http->http_code = 302,
@@ -167,7 +167,7 @@ clientRedirectDone(void *data, char *result)
     int fd = http->conn->fd;
     request_t *new_request = NULL;
     request_t *old_request = http->request;
-    debug(33, 5, "clientRedirectDone: '%s' result=%s\n", http->url,
+    debug(33, 5) ("clientRedirectDone: '%s' result=%s\n", http->url,
 	result ? result : "NULL");
     if (http->redirect_state != REDIRECT_PENDING)
 	fatal_dump("clientRedirectDone: wrong redirect_state");
@@ -220,7 +220,7 @@ proxyAuthenticate(const char *headers)
      * headers sent by the client
      */
     if ((s = mime_get_header(headers, "Proxy-authorization:")) == NULL) {
-	debug(33, 5, "proxyAuthenticate: Can't find authorization header\n");
+	debug(33, 5) ("proxyAuthenticate: Can't find authorization header\n");
 	return (dash_str);
     }
     /* Skip the 'Basic' part */
@@ -232,31 +232,31 @@ proxyAuthenticate(const char *headers)
 
     xstrncpy(sent_user, clear_userandpw, ICP_IDENT_SZ);
     strtok(sent_user, ":");	/* Remove :password */
-    debug(33, 5, "proxyAuthenticate: user = %s\n", sent_user);
+    debug(33, 5) ("proxyAuthenticate: user = %s\n", sent_user);
 
     /* Look at the Last-modified time of the proxy.passwords
      * file every five minutes, to see if it's been changed via
      * a cgi-bin script, etc. If so, reload a fresh copy into memory
      */
 
     if ((squid_curtime - last_time) > CHECK_PROXY_FILE_TIME) {
-	debug(33, 5, "proxyAuthenticate: checking password file %s hasn't changed\n", Config.proxyAuth.File);
+	debug(33, 5) ("proxyAuthenticate: checking password file %s hasn't changed\n", Config.proxyAuth.File);
 
 	if (stat(Config.proxyAuth.File, &buf) == 0) {
 	    if (buf.st_mtime != change_time) {
-		debug(33, 0, "proxyAuthenticate: reloading changed proxy authentication password file %s \n", Config.proxyAuth.File);
+		debug(33, 0) ("proxyAuthenticate: reloading changed proxy authentication password file %s \n", Config.proxyAuth.File);
 		change_time = buf.st_mtime;
 
 		if (validated != 0) {
-		    debug(33, 5, "proxyAuthenticate: invalidating old entries\n");
+		    debug(33, 5) ("proxyAuthenticate: invalidating old entries\n");
 		    for (i = 0, hashr = hash_first(validated); hashr; hashr = hash_next(validated)) {
-			debug(33, 6, "proxyAuthenticate: deleting %s\n", hashr->key);
+			debug(33, 6) ("proxyAuthenticate: deleting %s\n", hashr->key);
 			hash_delete(validated, hashr->key);
 		    }
 		} else {
 		    /* First time around, 7921 should be big enough */
 		    if ((validated = hash_create(urlcmp, 7921, hash_string)) < 0) {
-			debug(33, 1, "ERK: can't create hash table. Turning auth off");
+			debug(33, 1) ("ERK: can't create hash table. Turning auth off");
 			xfree(Config.proxyAuth.File);
 			Config.proxyAuth.File = NULL;
 			return (dash_str);
@@ -273,10 +273,10 @@ proxyAuthenticate(const char *headers)
 		user = strtok(passwords, ":");
 		passwd = strtok(NULL, "\n");
 
-		debug(33, 5, "proxyAuthenticate: adding new passwords to hash table\n");
+		debug(33, 5) ("proxyAuthenticate: adding new passwords to hash table\n");
 		while (user != NULL) {
 		    if (strlen(user) > 1 && strlen(passwd) > 1) {
-			debug(33, 6, "proxyAuthenticate: adding %s, %s to hash table\n", user, passwd);
+			debug(33, 6) ("proxyAuthenticate: adding %s, %s to hash table\n", user, passwd);
 			hash_insert(validated, xstrdup(user), xstrdup(passwd));
 		    }
 		    user = strtok(NULL, ":");
@@ -286,7 +286,7 @@ proxyAuthenticate(const char *headers)
 		xfree(passwords);
 	    }
 	} else {
-	    debug(33, 1, "ERK: can't access proxy_auth file %s. Turning authentication off", Config.proxyAuth.File);
+	    debug(33, 1) ("ERK: can't access proxy_auth file %s. Turning authentication off", Config.proxyAuth.File);
 	    xfree(Config.proxyAuth.File);
 	    Config.proxyAuth.File = NULL;
 	    return (dash_str);
@@ -297,7 +297,7 @@ proxyAuthenticate(const char *headers)
     hashr = hash_lookup(validated, sent_user);
     if (hashr == NULL) {
 	/* User doesn't exist; deny them */
-	debug(33, 4, "proxyAuthenticate: user %s doesn't exist\n", sent_user);
+	debug(33, 4) ("proxyAuthenticate: user %s doesn't exist\n", sent_user);
 	xfree(clear_userandpw);
 	return (dash_str);
     }
@@ -306,17 +306,17 @@ proxyAuthenticate(const char *headers)
 
     /* See if we've already validated them */
     if (strcmp(hashr->item, passwd) == 0) {
-	debug(33, 5, "proxyAuthenticate: user %s previously validated\n", sent_user);
+	debug(33, 5) ("proxyAuthenticate: user %s previously validated\n", sent_user);
 	xfree(clear_userandpw);
 	return sent_user;
     }
     if (strcmp(hashr->item, (char *) crypt(passwd, hashr->item))) {
 	/* Passwords differ, deny access */
-	debug(33, 4, "proxyAuthenticate: authentication failed: user %s passwords differ\n", sent_user);
+	debug(33, 4) ("proxyAuthenticate: authentication failed: user %s passwords differ\n", sent_user);
 	xfree(clear_userandpw);
 	return (dash_str);
     }
-    debug(33, 5, "proxyAuthenticate: user %s validated\n", sent_user);
+    debug(33, 5) ("proxyAuthenticate: user %s validated\n", sent_user);
     hash_delete(validated, sent_user);
     hash_insert(validated, xstrdup(sent_user), xstrdup(passwd));
 
@@ -332,7 +332,7 @@ icpProcessExpired(int fd, void *data)
     char *url = http->url;
     StoreEntry *entry = NULL;
 
-    debug(33, 3, "icpProcessExpired: FD %d '%s'\n", fd, http->url);
+    debug(33, 3) ("icpProcessExpired: FD %d '%s'\n", fd, http->url);
 
     BIT_SET(http->request->flags, REQ_REFRESH);
     http->old_entry = http->entry;
@@ -344,7 +344,7 @@ icpProcessExpired(int fd, void *data)
     storeClientListAdd(http->old_entry, http);
 
     entry->lastmod = http->old_entry->lastmod;
-    debug(33, 5, "icpProcessExpired: setting lmt = %d\n",
+    debug(33, 5) ("icpProcessExpired: setting lmt = %d\n",
 	entry->lastmod);
 
     entry->refcount++;		/* EXPIRED CASE */
@@ -367,22 +367,22 @@ clientGetsOldEntry(StoreEntry * new_entry, StoreEntry * old_entry, request_t * r
     /* If the reply is anything but "Not Modified" then
      * we must forward it to the client */
     if (new_entry->mem_obj->reply->code != 304) {
-	debug(33, 5, "clientGetsOldEntry: NO, reply=%d\n", new_entry->mem_obj->reply->code);
+	debug(33, 5) ("clientGetsOldEntry: NO, reply=%d\n", new_entry->mem_obj->reply->code);
 	return 0;
     }
     /* If the client did not send IMS in the request, then it
      * must get the old object, not this "Not Modified" reply */
     if (!BIT_TEST(request->flags, REQ_IMS)) {
-	debug(33, 5, "clientGetsOldEntry: YES, no client IMS\n");
+	debug(33, 5) ("clientGetsOldEntry: YES, no client IMS\n");
 	return 1;
     }
     /* If the client IMS time is prior to the entry LASTMOD time we
      * need to send the old object */
     if (modifiedSince(old_entry, request)) {
-	debug(33, 5, "clientGetsOldEntry: YES, modified since %d\n", request->ims);
+	debug(33, 5) ("clientGetsOldEntry: YES, modified since %d\n", request->ims);
 	return 1;
     }
-    debug(33, 5, "clientGetsOldEntry: NO, new one is fine\n");
+    debug(33, 5) ("clientGetsOldEntry: NO, new one is fine\n");
     return 0;
 }
 
@@ -397,10 +397,10 @@ icpHandleIMSReply(void *data, char *buf, size_t size)
     MemObject *mem = entry->mem_obj;
     int unlink_request = 0;
     StoreEntry *oldentry;
-    debug(33, 3, "icpHandleIMSReply: FD %d '%s'\n", fd, entry->url);
+    debug(33, 3) ("icpHandleIMSReply: FD %d '%s'\n", fd, entry->url);
     /* unregister this handler */
     if (entry->store_status == STORE_ABORTED) {
-	debug(33, 3, "icpHandleIMSReply: ABORTED/%s '%s'\n",
+	debug(33, 3) ("icpHandleIMSReply: ABORTED/%s '%s'\n",
 	    log_tags[entry->mem_obj->abort_code], entry->url);
 	/* We have an existing entry, but failed to validate it,
 	 * so send the old one anyway */
@@ -410,7 +410,7 @@ icpHandleIMSReply(void *data, char *buf, size_t size)
 	entry = http->entry = http->old_entry;
 	entry->refcount++;
     } else if (mem->reply->code == 0) {
-	debug(33, 3, "icpHandleIMSReply: Incomplete headers for '%s'\n",
+	debug(33, 3) ("icpHandleIMSReply: Incomplete headers for '%s'\n",
 	    entry->url);
 	storeClientCopy(entry,
 	    http->out.offset + size,
@@ -472,7 +472,7 @@ modifiedSince(StoreEntry * entry, request_t * request)
 {
     int object_length;
     MemObject *mem = entry->mem_obj;
-    debug(33, 3, "modifiedSince: '%s'\n", entry->url);
+    debug(33, 3) ("modifiedSince: '%s'\n", entry->url);
     if (entry->lastmod < 0)
 	return 1;
     /* Find size of the object */
@@ -481,19 +481,19 @@ modifiedSince(StoreEntry * entry, request_t * request)
     else
 	object_length = entry->object_len - mem->reply->hdr_sz;
     if (entry->lastmod > request->ims) {
-	debug(33, 3, "--> YES: entry newer than client\n");
+	debug(33, 3) ("--> YES: entry newer than client\n");
 	return 1;
     } else if (entry->lastmod < request->ims) {
-	debug(33, 3, "-->  NO: entry older than client\n");
+	debug(33, 3) ("-->  NO: entry older than client\n");
 	return 0;
     } else if (request->imslen < 0) {
-	debug(33, 3, "-->  NO: same LMT, no client length\n");
+	debug(33, 3) ("-->  NO: same LMT, no client length\n");
 	return 0;
     } else if (request->imslen == object_length) {
-	debug(33, 3, "-->  NO: same LMT, same length\n");
+	debug(33, 3) ("-->  NO: same LMT, same length\n");
 	return 0;
     } else {
-	debug(33, 3, "--> YES: same LMT, different length\n");
+	debug(33, 3) ("--> YES: same LMT, different length\n");
 	return 1;
     }
 }
@@ -534,7 +534,7 @@ clientPurgeRequest(clientHttpRequest * http)
     LOCAL_ARRAY(char, msg, 8192);
     LOCAL_ARRAY(char, line, 256);
     StoreEntry *entry;
-    debug(0, 0, "Config.Options.enable_purge = %d\n", Config.Options.enable_purge);
+    debug(0, 0) ("Config.Options.enable_purge = %d\n", Config.Options.enable_purge);
     if (!Config.Options.enable_purge) {
 	buf = access_denied_msg(http->http_code = 401,
 	    http->request->method,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.158 1997/06/02 19:55:59 wessels Exp $
+ * $Id: comm.cc,v 1.159 1997/06/04 06:15:48 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -166,7 +166,7 @@ static void commConnectHandle _PARAMS((int fd, void *data));
 static void commHandleWrite _PARAMS((int fd, void *data));
 static int fdIsHttpOrIcp _PARAMS((int fd));
 static IPH commConnectDnsHandle;
-static void commConnectCallback _PARAMS((int fd, ConnectStateData *cs, int status));
+static void commConnectCallback _PARAMS((int fd, ConnectStateData * cs, int status));
 
 static struct timeval zero_tv;
 
@@ -214,17 +214,17 @@ comm_local_port(int fd)
 
     /* If the fd is closed already, just return */
     if (!fde->open) {
-	debug(5, 0, "comm_local_port: FD %d has been closed.\n", fd);
+	debug(5, 0) ("comm_local_port: FD %d has been closed.\n", fd);
 	return 0;
     }
     if (fde->local_port)
 	return fde->local_port;
     addr_len = sizeof(addr);
     if (getsockname(fd, (struct sockaddr *) &addr, &addr_len)) {
-	debug(50, 1, "comm_local_port: Failed to retrieve TCP/UDP port number for socket: FD %d: %s\n", fd, xstrerror());
+	debug(50, 1) ("comm_local_port: Failed to retrieve TCP/UDP port number for socket: FD %d: %s\n", fd, xstrerror());
 	return 0;
     }
-    debug(5, 6, "comm_local_port: FD %d: sockaddr %u.\n", fd, addr.sin_addr.s_addr);
+    debug(5, 6) ("comm_local_port: FD %d: sockaddr %u.\n", fd, addr.sin_addr.s_addr);
     fde->local_port = ntohs(addr.sin_port);
     return fde->local_port;
 }
@@ -240,7 +240,7 @@ commBind(int s, struct in_addr in_addr, u_short port)
     S.sin_addr = in_addr;
     if (bind(s, (struct sockaddr *) &S, sizeof(S)) == 0)
 	return COMM_OK;
-    debug(50, 0, "commBind: Cannot bind socket FD %d to %s:%d: %s\n",
+    debug(50, 0) ("commBind: Cannot bind socket FD %d to %s:%d: %s\n",
 	s,
 	S.sin_addr.s_addr == INADDR_ANY ? "*" : inet_ntoa(S.sin_addr),
 	(int) port,
@@ -270,10 +270,10 @@ comm_open(int sock_type,
 	switch (errno) {
 	case ENFILE:
 	case EMFILE:
-	    debug(50, 1, "comm_open: socket failure: %s\n", xstrerror());
+	    debug(50, 1) ("comm_open: socket failure: %s\n", xstrerror());
 	    break;
 	default:
-	    debug(50, 0, "comm_open: socket failure: %s\n", xstrerror());
+	    debug(50, 0) ("comm_open: socket failure: %s\n", xstrerror());
 	}
 	return (COMM_ERROR);
     }
@@ -316,7 +316,7 @@ comm_listen(int sock)
 {
     int x;
     if ((x = listen(sock, Squid_MaxFD >> 2)) < 0) {
-	debug(50, 0, "comm_listen: listen(%d, %d): %s\n",
+	debug(50, 0) ("comm_listen: listen(%d, %d): %s\n",
 	    Squid_MaxFD >> 2,
 	    sock, xstrerror());
 	return x;
@@ -344,7 +344,7 @@ commConnectDnsHandle(int fd, const ipcache_addrs * ia, void *data)
     assert(cs->locks == 1);
     cs->locks--;
     if (ia == NULL) {
-	debug(5, 3, "commConnectDnsHandle: Unknown host: %s\n", cs->host);
+	debug(5, 3) ("commConnectDnsHandle: Unknown host: %s\n", cs->host);
 	commConnectCallback(fd, cs, COMM_ERR_DNS);
 	return;
     }
@@ -353,13 +353,13 @@ commConnectDnsHandle(int fd, const ipcache_addrs * ia, void *data)
 }
 
 static void
-commConnectCallback(int fd, ConnectStateData *cs, int status)
+commConnectCallback(int fd, ConnectStateData * cs, int status)
 {
-        CNCB *callback = cs->callback;
-	void *data = cs->data;
-	comm_remove_close_handler(fd, commConnectFree, cs);
-	commConnectFree(fd, cs);
-	callback(fd, status, data);
+    CNCB *callback = cs->callback;
+    void *data = cs->data;
+    comm_remove_close_handler(fd, commConnectFree, cs);
+    commConnectFree(fd, cs);
+    callback(fd, status, data);
 }
 
 static void
@@ -380,11 +380,11 @@ commRetryConnect(int fd, ConnectStateData * cs)
 	return 0;
     fd2 = socket(AF_INET, SOCK_STREAM, 0);
     if (fd2 < 0) {
-	debug(5, 0, "commRetryConnect: socket: %s\n", xstrerror());
+	debug(5, 0) ("commRetryConnect: socket: %s\n", xstrerror());
 	return 0;
     }
     if (dup2(fd2, fd) < 0) {
-	debug(5, 0, "commRetryConnect: dup2: %s\n", xstrerror());
+	debug(5, 0) ("commRetryConnect: dup2: %s\n", xstrerror());
 	return 0;
     }
     commSetNonBlocking(fd);
@@ -416,7 +416,7 @@ commConnectHandle(int fd, void *data)
 	break;
     default:
 	if (commRetryConnect(fd, cs)) {
-	    debug(5, 1, "Retrying connection to %s: %s\n",
+	    debug(5, 1) ("Retrying connection to %s: %s\n",
 		cs->host, xstrerror());
 	    cs->S.sin_addr.s_addr = 0;
 	    ipcacheCycleAddr(cs->host);
@@ -433,7 +433,7 @@ int
 commSetTimeout(int fd, int timeout, PF * handler, void *data)
 {
     FD_ENTRY *fde;
-    debug(5, 3, "commSetTimeout: FD %d timeout %d\n", fd, timeout);
+    debug(5, 3) ("commSetTimeout: FD %d timeout %d\n", fd, timeout);
     if (fd < 0 || fd > Squid_MaxFD)
 	fatal_dump("commSetTimeout: bad FD");
     fde = &fd_table[fd];
@@ -465,7 +465,7 @@ comm_connect_addr(int sock, const struct sockaddr_in *address)
     int x;
     /* sanity check */
     if (ntohs(address->sin_port) == 0) {
-	debug(5, 10, "comm_connect_addr: %s:%d: URL uses port 0?\n",
+	debug(5, 10) ("comm_connect_addr: %s:%d: URL uses port 0?\n",
 	    inet_ntoa(address->sin_addr), ntohs(address->sin_port));
 	errno = 0;
 	return COMM_ERROR;
@@ -490,7 +490,7 @@ comm_connect_addr(int sock, const struct sockaddr_in *address)
 	    if (getsockopt(sock, SOL_SOCKET, SO_ERROR, (char *) &x, &len) >= 0)
 		errno = x;
 	default:
-	    debug(50, 2, "connect: %s:%d: %s.\n",
+	    debug(50, 2) ("connect: %s:%d: %s.\n",
 		fqdnFromAddr(address->sin_addr),
 		ntohs(address->sin_port),
 		xstrerror());
@@ -500,10 +500,10 @@ comm_connect_addr(int sock, const struct sockaddr_in *address)
     xstrncpy(fde->ipaddr, inet_ntoa(address->sin_addr), 16);
     fde->remote_port = ntohs(address->sin_port);
     if (status == COMM_OK) {
-	debug(5, 10, "comm_connect_addr: FD %d connected to %s:%d\n",
+	debug(5, 10) ("comm_connect_addr: FD %d connected to %s:%d\n",
 	    sock, fde->ipaddr, fde->remote_port);
     } else if (status == COMM_INPROGRESS) {
-	debug(5, 10, "comm_connect_addr: FD %d connection pending\n", sock);
+	debug(5, 10) ("comm_connect_addr: FD %d connection pending\n", sock);
     }
     /* Add new socket to list of open sockets. */
     return status;
@@ -533,7 +533,7 @@ comm_accept(int fd, struct sockaddr_in *peer, struct sockaddr_in *me)
 	case EMFILE:
 	    return COMM_ERROR;
 	default:
-	    debug(50, 1, "comm_accept: FD %d: accept failure: %s\n",
+	    debug(50, 1) ("comm_accept: FD %d: accept failure: %s\n",
 		fd, xstrerror());
 	    return COMM_ERROR;
 	}
@@ -562,7 +562,7 @@ commCallCloseHandlers(int fd)
 {
     FD_ENTRY *fde = &fd_table[fd];
     struct close_handler *ch;
-    debug(5, 5, "commCallCloseHandlers: FD %d\n", fd);
+    debug(5, 5) ("commCallCloseHandlers: FD %d\n", fd);
     while ((ch = fde->close_handler) != NULL) {
 	fde->close_handler = ch->next;
 	ch->handler(fd, ch->data);
@@ -574,7 +574,7 @@ void
 comm_close(int fd)
 {
     FD_ENTRY *fde = NULL;
-    debug(5, 5, "comm_close: FD %d\n", fd);
+    debug(5, 5) ("comm_close: FD %d\n", fd);
     if (fd < 0)
 	fatal_dump("comm_close: bad FD");
     if (fd >= Squid_MaxFD)
@@ -608,15 +608,15 @@ comm_udp_send(int fd, const char *host, u_short port, const char *buf, int len)
     to_addr.sin_family = AF_INET;
 
     if ((ia = ipcache_gethostbyname(host, IP_BLOCKING_LOOKUP)) == 0) {
-	debug(50, 1, "comm_udp_send: gethostbyname failure: %s: %s\n",
+	debug(50, 1) ("comm_udp_send: gethostbyname failure: %s: %s\n",
 	    host, xstrerror());
 	return (COMM_ERROR);
     }
     to_addr.sin_addr = ia->in_addrs[ia->cur];
     to_addr.sin_port = htons(port);
     if ((bytes_sent = sendto(fd, buf, len, 0, (struct sockaddr *) &to_addr,
 		sizeof(to_addr))) < 0) {
-	debug(50, 1, "comm_udp_send: sendto failure: FD %d: %s\n",
+	debug(50, 1) ("comm_udp_send: sendto failure: FD %d: %s\n",
 	    fd, xstrerror());
 	return COMM_ERROR;
     }
@@ -634,7 +634,7 @@ comm_udp_sendto(int fd,
     int x;
     x = sendto(fd, buf, len, 0, (struct sockaddr *) to_addr, addr_len);
     if (x < 0) {
-	debug(50, 1, "comm_udp_sendto: FD %d, %s, port %d: %s\n",
+	debug(50, 1) ("comm_udp_sendto: FD %d, %s, port %d: %s\n",
 	    fd,
 	    inet_ntoa(to_addr->sin_addr),
 	    (int) htons(to_addr->sin_port),
@@ -855,7 +855,7 @@ comm_poll(time_t sec)
 	    }
 	}
 	if (shutdown_pending || reconfigure_pending)
-	    debug(5, 2, "comm_poll: Still waiting on %d FDs\n", nfds);
+	    debug(5, 2) ("comm_poll: Still waiting on %d FDs\n", nfds);
 	if (nfds == 0)
 	    return COMM_SHUTDOWN;
 	poll_time = sec > 0 ? 100 : 0;
@@ -871,14 +871,14 @@ comm_poll(time_t sec)
 		break;
 	    if (errno == EINTR)
 		continue;
-	    debug(5, 0, "comm_poll: poll failure: %s\n", xstrerror());
+	    debug(5, 0) ("comm_poll: poll failure: %s\n", xstrerror());
 	    if (errno == EINVAL)
 		fatal_dump("Poll returned EINVAL");
 	    return COMM_ERROR;
 	    /* NOTREACHED */
 	}
 	getCurrentTime();
-	debug(5, num ? 5 : 8, "comm_poll: %d sockets ready\n", num);
+	debug(5, num ? 5 : 8) ("comm_poll: %d sockets ready\n", num);
 	/* Check timeout handlers ONCE each second. */
 	if (squid_curtime > last_timeout) {
 	    last_timeout = squid_curtime;
@@ -898,14 +898,14 @@ comm_poll(time_t sec)
 	    if (fdIsHttpOrIcp(fd))
 		continue;
 	    if (revents & (POLLRDNORM | POLLIN | POLLHUP | POLLERR)) {
-		debug(5, 6, "comm_poll: FD %d ready for reading\n", fd);
+		debug(5, 6) ("comm_poll: FD %d ready for reading\n", fd);
 		if ((hdl = fd_table[fd].read_handler)) {
 		    fd_table[fd].read_handler = 0;
 		    hdl(fd, fd_table[fd].read_data);
 		}
 	    }
 	    if (revents & (POLLWRNORM | POLLOUT | POLLHUP | POLLERR)) {
-		debug(5, 5, "comm_poll: FD %d ready for writing\n", fd);
+		debug(5, 5) ("comm_poll: FD %d ready for writing\n", fd);
 		if ((hdl = fd_table[fd].write_handler)) {
 		    fd_table[fd].write_handler = 0;
 		    hdl(fd, fd_table[fd].write_data);
@@ -915,23 +915,23 @@ comm_poll(time_t sec)
 		struct close_handler *ch;
 		struct close_handler *next;
 		FD_ENTRY *fde = &fd_table[fd];
-		debug(5, 0, "WARNING: FD %d has handlers, but it's invalid.\n", fd);
-		debug(5, 0, "FD %d is a %s\n", fd, fdstatTypeStr[fd_table[fd].type]);
-		debug(5, 0, "--> %s\n", fd_table[fd].desc);
-		debug(5, 0, "tmout:%p read:%p write:%p\n",
+		debug(5, 0) ("WARNING: FD %d has handlers, but it's invalid.\n", fd);
+		debug(5, 0) ("FD %d is a %s\n", fd, fdstatTypeStr[fd_table[fd].type]);
+		debug(5, 0) ("--> %s\n", fd_table[fd].desc);
+		debug(5, 0) ("tmout:%p read:%p write:%p\n",
 		    fde->timeout_handler,
 		    fde->read_handler,
 		    fde->write_handler);
 		for (ch = fde->close_handler; ch; ch = ch->next)
-		    debug(5, 0, " close handler: %p\n", ch->handler);
+		    debug(5, 0) (" close handler: %p\n", ch->handler);
 		if (fde->close_handler) {
 		    for (ch = fde->close_handler; ch; ch = next) {
 			next = ch->next;
 			ch->handler(fd, ch->data);
 			safe_free(ch);
 		    }
 		} else if (fde->timeout_handler) {
-		    debug(5, 0, "comm_poll: Calling Timeout Handler\n");
+		    debug(5, 0) ("comm_poll: Calling Timeout Handler\n");
 		    fde->timeout_handler(fd, fde->timeout_data);
 		}
 		fde->close_handler = NULL;
@@ -942,7 +942,7 @@ comm_poll(time_t sec)
 	}
 	return COMM_OK;
     } while (timeout > getCurrentTime());
-    debug(5, 8, "comm_poll: time out: %d.\n", squid_curtime);
+    debug(5, 8) ("comm_poll: time out: %d.\n", squid_curtime);
     return COMM_TIMEOUT;
 }
 
@@ -1005,7 +1005,7 @@ comm_select(time_t sec)
 	    }
 	}
 	if (shutdown_pending || reconfigure_pending)
-	    debug(5, 2, "comm_select: Still waiting on %d FDs\n", nfds);
+	    debug(5, 2) ("comm_select: Still waiting on %d FDs\n", nfds);
 	if (nfds == 0)
 	    return COMM_SHUTDOWN;
 #if USE_ASYNC_IO
@@ -1021,15 +1021,15 @@ comm_select(time_t sec)
 		break;
 	    if (errno == EINTR)
 		break;
-	    debug(50, 0, "comm_select: select failure: %s\n",
+	    debug(50, 0) ("comm_select: select failure: %s\n",
 		xstrerror());
 	    examine_select(&readfds, &writefds);
 	    return COMM_ERROR;
 	    /* NOTREACHED */
 	}
 	if (num < 0)
 	    continue;
-	debug(5, num ? 5 : 8, "comm_select: %d sockets ready at %d\n",
+	debug(5, num ? 5 : 8) ("comm_select: %d sockets ready at %d\n",
 	    num, (int) squid_curtime);
 
 	/* Check lifetime and timeout handlers ONCE each second.
@@ -1057,7 +1057,7 @@ comm_select(time_t sec)
 	    if (fdIsHttpOrIcp(fd))
 		continue;
 	    if (FD_ISSET(fd, &readfds)) {
-		debug(5, 6, "comm_select: FD %d ready for reading\n", fd);
+		debug(5, 6) ("comm_select: FD %d ready for reading\n", fd);
 		if (fd_table[fd].read_handler) {
 		    hdl = fd_table[fd].read_handler;
 		    fd_table[fd].read_handler = 0;
@@ -1066,7 +1066,7 @@ comm_select(time_t sec)
 		}
 	    }
 	    if (FD_ISSET(fd, &writefds)) {
-		debug(5, 5, "comm_select: FD %d ready for writing\n", fd);
+		debug(5, 5) ("comm_select: FD %d ready for writing\n", fd);
 		if (fd_table[fd].write_handler) {
 		    hdl = fd_table[fd].write_handler;
 		    fd_table[fd].write_handler = 0;
@@ -1078,7 +1078,7 @@ comm_select(time_t sec)
 	return COMM_OK;
     } while (timeout > getCurrentTime());
 
-    debug(5, 8, "comm_select: time out: %d.\n", squid_curtime);
+    debug(5, 8) ("comm_select: time out: %d.\n", squid_curtime);
     return COMM_TIMEOUT;
 }
 #endif
@@ -1106,7 +1106,7 @@ void
 comm_add_close_handler(int fd, PF * handler, void *data)
 {
     struct close_handler *new = xmalloc(sizeof(*new));
-    debug(5, 5, "comm_add_close_handler: FD %d, handler=%p, data=%p\n",
+    debug(5, 5) ("comm_add_close_handler: FD %d, handler=%p, data=%p\n",
 	fd, handler, data);
     new->handler = handler;
     new->data = data;
@@ -1138,7 +1138,7 @@ comm_set_mcast_ttl(int fd, int mcast_ttl)
 #ifdef IP_MULTICAST_TTL
     char ttl = (char) mcast_ttl;
     if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, 1) < 0)
-	debug(50, 1, "comm_set_mcast_ttl: FD %d, TTL: %d: %s\n",
+	debug(50, 1) ("comm_set_mcast_ttl: FD %d, TTL: %d: %s\n",
 	    fd, mcast_ttl, xstrerror());
 #endif
     return 0;
@@ -1153,24 +1153,22 @@ comm_join_mcast_groups(int fd, const ipcache_addrs * ia, void *data)
     int x;
     char c = 0;
     if (ia == NULL) {
-	debug(5, 0, "comm_join_mcast_groups: Unknown host\n");
+	debug(5, 0) ("comm_join_mcast_groups: Unknown host\n");
 	return;
     }
     for (i = 0; i < (int) ia->count; i++) {
-	debug(5, 10, "Listening for ICP requests on %s\n",
+	debug(5, 10) ("Listening for ICP requests on %s\n",
 	    inet_ntoa(*(ia->in_addrs + i)));
 	mr.imr_multiaddr.s_addr = (ia->in_addrs + i)->s_addr;
 	mr.imr_interface.s_addr = INADDR_ANY;
 	x = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 	    (char *) &mr, sizeof(struct ip_mreq));
 	if (x < 0)
-	    debug(5, 1, "comm_join_mcast_groups: FD %d, [%s]\n",
+	    debug(5, 1) ("comm_join_mcast_groups: FD %d, [%s]\n",
 		fd, inet_ntoa(*(ia->in_addrs + i)));
 	x = setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, &c, 1);
 	if (x < 0)
-	    debug(5, 1,
-		"comm_join_mcast_groups: can't disable m'cast loopback: %s\n",
-		xstrerror());
+	    debug(5, 1) ("Can't disable multicast loopback: %s\n", xstrerror());
     }
 #endif
 }
@@ -1182,22 +1180,22 @@ commSetNoLinger(int fd)
     L.l_onoff = 0;		/* off */
     L.l_linger = 0;
     if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0)
-	debug(50, 0, "commSetNoLinger: FD %d: %s\n", fd, xstrerror());
+	debug(50, 0) ("commSetNoLinger: FD %d: %s\n", fd, xstrerror());
 }
 
 static void
 commSetReuseAddr(int fd)
 {
     int on = 1;
     if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on)) < 0)
-	debug(50, 1, "commSetReuseAddr: FD %d: %s\n", fd, xstrerror());
+	debug(50, 1) ("commSetReuseAddr: FD %d: %s\n", fd, xstrerror());
 }
 
 static void
 commSetTcpRcvbuf(int fd, int size)
 {
     if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char *) &size, sizeof(size)) < 0)
-	debug(50, 1, "commSetTcpRcvbuf: FD %d, SIZE %d: %s\n",
+	debug(50, 1) ("commSetTcpRcvbuf: FD %d, SIZE %d: %s\n",
 	    fd, size, xstrerror());
 }
 
@@ -1207,11 +1205,11 @@ commSetNonBlocking(int fd)
     int flags;
     int dummy = 0;
     if ((flags = fcntl(fd, F_GETFL, dummy)) < 0) {
-	debug(50, 0, "FD %d: fcntl F_GETFL: %s\n", fd, xstrerror());
+	debug(50, 0) ("FD %d: fcntl F_GETFL: %s\n", fd, xstrerror());
 	return COMM_ERROR;
     }
     if (fcntl(fd, F_SETFL, flags | SQUID_NONBLOCK) < 0) {
-	debug(50, 0, "commSetNonBlocking: FD %d: %s\n", fd, xstrerror());
+	debug(50, 0) ("commSetNonBlocking: FD %d: %s\n", fd, xstrerror());
 	return COMM_ERROR;
     }
     return 0;
@@ -1223,11 +1221,11 @@ commSetCloseOnExec(int fd)
 #ifdef FD_CLOEXEC
     int flags;
     if ((flags = fcntl(fd, F_GETFL)) < 0) {
-	debug(50, 0, "FD %d: fcntl F_GETFL: %s\n", fd, xstrerror());
+	debug(50, 0) ("FD %d: fcntl F_GETFL: %s\n", fd, xstrerror());
 	return;
     }
     if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)
-	debug(50, 0, "FD %d: set close-on-exec failed: %s\n", fd, xstrerror());
+	debug(50, 0) ("FD %d: set close-on-exec failed: %s\n", fd, xstrerror());
 #endif
 }
 
@@ -1237,7 +1235,7 @@ commSetTcpNoDelay(int fd)
 {
     int on = 1;
     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0)
-	debug(50, 1, "commSetTcpNoDelay: FD %d: %s\n", fd, xstrerror());
+	debug(50, 1) ("commSetTcpNoDelay: FD %d: %s\n", fd, xstrerror());
 }
 #endif
 
@@ -1281,7 +1279,7 @@ examine_select(fd_set * readfds, fd_set * writefds)
     struct close_handler *next = NULL;
     FD_ENTRY *fde = NULL;
 
-    debug(5, 0, "examine_select: Examining open file descriptors...\n");
+    debug(5, 0) ("examine_select: Examining open file descriptors...\n");
     for (fd = 0; fd < Squid_MaxFD; fd++) {
 	FD_ZERO(&read_x);
 	FD_ZERO(&write_x);
@@ -1294,30 +1292,30 @@ examine_select(fd_set * readfds, fd_set * writefds)
 	    continue;
 	num = select(Squid_MaxFD, &read_x, &write_x, NULL, &tv);
 	if (num > -1) {
-	    debug(5, 5, "FD %d is valid.\n", fd);
+	    debug(5, 5) ("FD %d is valid.\n", fd);
 	    continue;
 	}
 	fde = &fd_table[fd];
-	debug(5, 0, "FD %d: %s\n", fd, xstrerror());
-	debug(5, 0, "WARNING: FD %d has handlers, but it's invalid.\n", fd);
-	debug(5, 0, "FD %d is a %s called '%s'\n",
+	debug(5, 0) ("FD %d: %s\n", fd, xstrerror());
+	debug(5, 0) ("WARNING: FD %d has handlers, but it's invalid.\n", fd);
+	debug(5, 0) ("FD %d is a %s called '%s'\n",
 	    fd,
 	    fdstatTypeStr[fd_table[fd].type],
 	    fde->desc);
-	debug(5, 0, "tmout:%p read:%p write:%p\n",
+	debug(5, 0) ("tmout:%p read:%p write:%p\n",
 	    fde->timeout_handler,
 	    fde->read_handler,
 	    fde->write_handler);
 	for (ch = fde->close_handler; ch; ch = ch->next)
-	    debug(5, 0, " close handler: %p\n", ch->handler);
+	    debug(5, 0) (" close handler: %p\n", ch->handler);
 	if (fde->close_handler) {
 	    for (ch = fde->close_handler; ch; ch = next) {
 		next = ch->next;
 		ch->handler(fd, ch->data);
 		safe_free(ch);
 	    }
 	} else if (fde->timeout_handler) {
-	    debug(5, 0, "examine_select: Calling Timeout Handler\n");
+	    debug(5, 0) ("examine_select: Calling Timeout Handler\n");
 	    fde->timeout_handler(fd, fde->timeout_data);
 	}
 	fde->close_handler = NULL;
@@ -1345,14 +1343,14 @@ checkTimeouts(void)
 	    continue;
 	if (fde->timeout > squid_curtime)
 	    continue;
-	debug(5, 5, "checkTimeouts: FD %d Expired\n", fd);
+	debug(5, 5) ("checkTimeouts: FD %d Expired\n", fd);
 	if (fde->timeout_handler) {
-	    debug(5, 5, "checkTimeouts: FD %d: Call timeout handler\n", fd);
+	    debug(5, 5) ("checkTimeouts: FD %d: Call timeout handler\n", fd);
 	    callback = fde->timeout_handler;
 	    fde->timeout_handler = NULL;
 	    callback(fd, fde->timeout_data);
 	} else {
-	    debug(5, 5, "checkTimeouts: FD %d: Forcing comm_close()\n", fd);
+	    debug(5, 5) ("checkTimeouts: FD %d: Forcing comm_close()\n", fd);
 	    comm_close(fd);
 	}
     }
@@ -1366,7 +1364,7 @@ commHandleWrite(int fd, void *data)
     int len = 0;
     int nleft;
 
-    debug(5, 5, "commHandleWrite: FD %d: state=%p, off %d, sz %d.\n",
+    debug(5, 5) ("commHandleWrite: FD %d: state=%p, off %d, sz %d.\n",
 	fd, state, state->offset, state->size);
 
     nleft = state->size - state->offset;
@@ -1377,20 +1375,20 @@ commHandleWrite(int fd, void *data)
 	/* Note we even call write if nleft == 0 */
 	/* We're done */
 	if (nleft != 0)
-	    debug(5, 2, "commHandleWrite: FD %d: write failure: connection closed with %d bytes remaining.\n", fd, nleft);
+	    debug(5, 2) ("commHandleWrite: FD %d: write failure: connection closed with %d bytes remaining.\n", fd, nleft);
 	CommWriteStateCallbackAndFree(fd, nleft ? COMM_ERROR : COMM_OK);
     } else if (len < 0) {
 	/* An error */
 	if (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR) {
-	    debug(50, 10, "commHandleWrite: FD %d: write failure: %s.\n",
+	    debug(50, 10) ("commHandleWrite: FD %d: write failure: %s.\n",
 		fd, xstrerror());
 	    commSetSelect(fd,
 		COMM_SELECT_WRITE,
 		commHandleWrite,
 		state,
 		0);
 	} else {
-	    debug(50, 2, "commHandleWrite: FD %d: write failure: %s.\n",
+	    debug(50, 2) ("commHandleWrite: FD %d: write failure: %s.\n",
 		fd, xstrerror());
 	    CommWriteStateCallbackAndFree(fd, COMM_ERROR);
 	}
@@ -1418,7 +1416,7 @@ void
 comm_write(int fd, char *buf, int size, CWCB * handler, void *handler_data, FREE * free_func)
 {
     CommWriteStateData *state = NULL;
-    debug(5, 5, "comm_write: FD %d: sz %d: hndl %p: data %p.\n",
+    debug(5, 5) ("comm_write: FD %d: sz %d: hndl %p: data %p.\n",
 	fd, size, handler, handler_data);
     if (fd_table[fd].rwstate)
 	fatal_dump("comm_write: comm_write is already active");
@@ -1,5 +1,5 @@
 /*
- * $Id: debug.cc,v 1.44 1997/05/15 23:33:43 wessels Exp $
+ * $Id: debug.cc,v 1.45 1997/06/04 06:15:49 wessels Exp $
  *
  * DEBUG: section 0     Debug Routines
  * AUTHOR: Harvest Derived
@@ -107,16 +107,17 @@
 
 FILE *debug_log = NULL;
 static char *debug_log_file = NULL;
-
-#define MAX_DEBUG_SECTIONS 100
-static int debugLevels[MAX_DEBUG_SECTIONS];
-
+int debugLevels[MAX_DEBUG_SECTIONS];
 static char *accessLogTime _PARAMS((time_t));
 extern int opt_debug_stderr;
 
+#ifdef HAVE_SYSLOG
+int _db_level = 0;
+#endif
+
 #ifdef __STDC__
 void
-_db_print(int section, int level, const char *format,...)
+_db_print(const char *format,...)
 {
     va_list args;
 #else
@@ -125,8 +126,6 @@ _db_print(va_alist)
      va_dcl
 {
     va_list args;
-    int section;
-    int level;
     const char *format = NULL;
 #endif
     LOCAL_ARRAY(char, f, BUFSIZ);
@@ -135,17 +134,9 @@ _db_print(va_alist)
 #endif
 
 #ifdef __STDC__
-    if (level > debugLevels[section])
-	return;
     va_start(args, format);
 #else
     va_start(args);
-    section = va_arg(args, int);
-    level = va_arg(args, int);
-    if (level > debugLevels[section]) {
-	va_end(args);
-	return;
-    }
     format = va_arg(args, const char *);
 #endif
 
@@ -156,7 +147,7 @@ _db_print(va_alist)
 	format);
 #if HAVE_SYSLOG
     /* level 0 go to syslog */
-    if (level == 0 && opt_syslog_enable) {
+    if (_db_level == 0 && opt_syslog_enable) {
 	tmpbuf[0] = '\0';
 	vsprintf(tmpbuf, format, args);
 	tmpbuf[1023] = '\0';
@@ -1,5 +1,5 @@
 /*
- * $Id: disk.cc,v 1.72 1997/06/04 05:50:27 wessels Exp $
+ * $Id: disk.cc,v 1.73 1997/06/04 06:15:50 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -184,7 +184,7 @@ file_open_complete(void *data, int fd, int errcode)
     FD_ENTRY *fde;
     if (fd < 0) {
 	errno = errcode;
-	debug(50, 0, "file_open: error opening file %s: %s\n", ctrlp->path,
+	debug(50, 0) ("file_open: error opening file %s: %s\n", ctrlp->path,
 	    xstrerror());
 	if (ctrlp->callback)
 	    (ctrlp->callback) (ctrlp->callback_data, DISK_ERROR);
@@ -296,7 +296,7 @@ diskHandleWriteComplete(void *data, int len, int errcode)
 	    (void) 0;
 	} else {
 	    status = errno == ENOSPC ? DISK_NO_SPACE_LEFT : DISK_ERROR;
-	    debug(50, 1, "diskHandleWrite: FD %d: disk write error: %s\n",
+	    debug(50, 1) ("diskHandleWrite: FD %d: disk write error: %s\n",
 		fd, xstrerror());
 	    if (fdd->wrt_handle == NULL) {
 		/* FLUSH PENDING BUFFERS */
@@ -432,7 +432,7 @@ diskHandleReadComplete(void *data, int len, int errcode)
 		0);
 	    return;
 	}
-	debug(50, 1, "diskHandleRead: FD %d: error reading: %s\n",
+	debug(50, 1) ("diskHandleRead: FD %d: error reading: %s\n",
 	    fd, xstrerror());
 	ctrl_dat->handler(fd, ctrl_dat->buf,
 	    ctrl_dat->offset,
@@ -555,7 +555,7 @@ diskHandleWalkComplete(void *data, int retcode, int errcode)
 	    commSetSelect(fd, COMM_SELECT_READ, diskHandleWalk, walk_dat, 0);
 	    return;
 	}
-	debug(50, 1, "diskHandleWalk: FD %d: error readingd: %s\n",
+	debug(50, 1) ("diskHandleWalk: FD %d: error readingd: %s\n",
 	    fd, xstrerror());
 	walk_dat->handler(fd, DISK_ERROR, walk_dat->client_data);
 	safe_free(walk_dat->buf);
@@ -1,5 +1,5 @@
 /*
- * $Id: dns.cc,v 1.34 1997/05/05 03:43:40 wessels Exp $
+ * $Id: dns.cc,v 1.35 1997/06/04 06:15:50 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -137,19 +137,19 @@ dnsOpenServer(const char *command)
 	COMM_NOCLOEXEC,
 	"dnsserver listen socket");
     if (cfd == COMM_ERROR) {
-	debug(34, 0, "dnsOpenServer: Failed to create dnsserver\n");
+	debug(34, 0) ("dnsOpenServer: Failed to create dnsserver\n");
 	return -1;
     }
     len = sizeof(S);
     memset(&S, '\0', len);
     if (getsockname(cfd, (struct sockaddr *) &S, &len) < 0) {
-	debug(50, 0, "dnsOpenServer: getsockname: %s\n", xstrerror());
+	debug(50, 0) ("dnsOpenServer: getsockname: %s\n", xstrerror());
 	comm_close(cfd);
 	return -1;
     }
     listen(cfd, 1);
     if ((pid = fork()) < 0) {
-	debug(50, 0, "dnsOpenServer: fork: %s\n", xstrerror());
+	debug(50, 0) ("dnsOpenServer: fork: %s\n", xstrerror());
 	comm_close(cfd);
 	return -1;
     }
@@ -169,19 +169,19 @@ dnsOpenServer(const char *command)
 	    return -1;
 	}
 	if (write(sfd, "$hello\n", 7) < 0) {
-	    debug(34, 0, "dnsOpenServer: $hello write test failed\n");
+	    debug(34, 0) ("dnsOpenServer: $hello write test failed\n");
 	    comm_close(sfd);
 	    return -1;
 	}
 	memset(buf, '\0', 128);
 	if (read(sfd, buf, 127) < 0) {
-	    debug(50, 0, "dnsOpenServer: $hello read test failed\n");
-	    debug(50, 0, "--> read: %s\n", xstrerror());
+	    debug(50, 0) ("dnsOpenServer: $hello read test failed\n");
+	    debug(50, 0) ("--> read: %s\n", xstrerror());
 	    comm_close(sfd);
 	    return -1;
 	} else if (strcmp(buf, "$alive\n$end\n")) {
-	    debug(50, 0, "dnsOpenServer: $hello read test failed\n");
-	    debug(50, 0, "--> got '%s'\n", rfc1738_escape(buf));
+	    debug(50, 0) ("dnsOpenServer: $hello read test failed\n");
+	    debug(50, 0) ("--> got '%s'\n", rfc1738_escape(buf));
 	    comm_close(sfd);
 	    return -1;
 	}
@@ -191,7 +191,7 @@ dnsOpenServer(const char *command)
     /* child */
     no_suid();			/* give up extra priviliges */
     if ((fd = accept(cfd, NULL, NULL)) < 0) {
-	debug(50, 0, "dnsOpenServer: FD %d accept: %s\n", cfd, xstrerror());
+	debug(50, 0) ("dnsOpenServer: FD %d accept: %s\n", cfd, xstrerror());
 	_exit(1);
     }
     dup2(fd, 0);
@@ -204,7 +204,7 @@ dnsOpenServer(const char *command)
 	execlp(command, "(dnsserver)", "-D", NULL);
     else
 	execlp(command, "(dnsserver)", NULL);
-    debug(50, 0, "dnsOpenServer: %s: %s\n", command, xstrerror());
+    debug(50, 0) ("dnsOpenServer: %s: %s\n", command, xstrerror());
     _exit(1);
     return 0;
 }
@@ -256,13 +256,13 @@ dnsOpenServers(void)
     for (k = 0; k < N; k++) {
 	dns_child_table[k] = xcalloc(1, sizeof(dnsserver_t));
 	if ((dnssocket = dnsOpenServer(prg)) < 0) {
-	    debug(34, 1, "dnsOpenServers: WARNING: Failed to start 'dnsserver' #%d.\n", k + 1);
+	    debug(34, 1) ("dnsOpenServers: WARNING: Failed to start 'dnsserver' #%d.\n", k + 1);
 	    dns_child_table[k]->flags &= ~DNS_FLAG_ALIVE;
 	    dns_child_table[k]->id = k + 1;
 	    dns_child_table[k]->inpipe = -1;
 	    dns_child_table[k]->outpipe = -1;
 	} else {
-	    debug(34, 4, "dnsOpenServers: FD %d connected to %s #%d.\n",
+	    debug(34, 4) ("dnsOpenServers: FD %d connected to %s #%d.\n",
 		dnssocket, prg, k + 1);
 	    dns_child_table[k]->flags |= DNS_FLAG_ALIVE;
 	    dns_child_table[k]->id = k + 1;
@@ -281,13 +281,13 @@ dnsOpenServers(void)
 	    sprintf(fd_note_buf, "%s #%d", s, dns_child_table[k]->id);
 	    fd_note(dns_child_table[k]->inpipe, fd_note_buf);
 	    commSetNonBlocking(dns_child_table[k]->inpipe);
-	    debug(34, 3, "dnsOpenServers: 'dns_server' %d started\n", k);
+	    debug(34, 3) ("dnsOpenServers: 'dns_server' %d started\n", k);
 	    NDnsServersAlloc++;
 	}
     }
     if (NDnsServersAlloc == 0 && Config.dnsChildren > 0)
 	fatal("Failed to start any dnsservers");
-    debug(34, 1, "Started %d 'dnsserver' processes\n", NDnsServersAlloc);
+    debug(34, 1) ("Started %d 'dnsserver' processes\n", NDnsServersAlloc);
 }
 
 
@@ -344,27 +344,27 @@ dnsShutdownServers(void)
     int k;
     static char *shutdown_cmd = "$shutdown\n";
 
-    debug(34, 3, "dnsShutdownServers:\n");
+    debug(34, 3) ("dnsShutdownServers:\n");
 
     k = ipcacheQueueDrain();
     if (fqdncacheQueueDrain() || k)
 	return;
     for (k = 0; k < NDnsServersAlloc; k++) {
 	dnsData = *(dns_child_table + k);
 	if (!(dnsData->flags & DNS_FLAG_ALIVE)) {
-	    debug(34, 3, "dnsShutdownServers: #%d is NOT ALIVE.\n", dnsData->id);
+	    debug(34, 3) ("dnsShutdownServers: #%d is NOT ALIVE.\n", dnsData->id);
 	    continue;
 	}
 	if (dnsData->flags & DNS_FLAG_BUSY) {
-	    debug(34, 3, "dnsShutdownServers: #%d is BUSY.\n", dnsData->id);
+	    debug(34, 3) ("dnsShutdownServers: #%d is BUSY.\n", dnsData->id);
 	    continue;
 	}
 	if (dnsData->flags & DNS_FLAG_CLOSING) {
-	    debug(34, 3, "dnsShutdownServers: #%d is CLOSING.\n", dnsData->id);
+	    debug(34, 3) ("dnsShutdownServers: #%d is CLOSING.\n", dnsData->id);
 	    continue;
 	}
-	debug(34, 3, "dnsShutdownServers: sending '$shutdown' to dnsserver #%d\n", dnsData->id);
-	debug(34, 3, "dnsShutdownServers: --> FD %d\n", dnsData->outpipe);
+	debug(34, 3) ("dnsShutdownServers: sending '$shutdown' to dnsserver #%d\n", dnsData->id);
+	debug(34, 3) ("dnsShutdownServers: --> FD %d\n", dnsData->outpipe);
 	comm_write(dnsData->outpipe,
 	    xstrdup(shutdown_cmd),
 	    strlen(shutdown_cmd),
@@ -384,8 +384,8 @@ static void
 dnsShutdownRead(int fd, void *data)
 {
     dnsserver_t *dnsData = data;
-    debug(14, dnsData->flags & DNS_FLAG_CLOSING ? 5 : 1,
-	"FD %d: Connection from DNSSERVER #%d is closed, disabling\n",
+    debug(14, dnsData->flags & DNS_FLAG_CLOSING ? 5 : 1)
+	("FD %d: Connection from DNSSERVER #%d is closed, disabling\n",
 	fd,
 	dnsData->id);
     dnsData->flags = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.55 1997/05/26 04:04:58 wessels Exp $
+ * $Id: errorpage.cc,v 1.56 1997/06/04 06:15:51 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -167,7 +167,7 @@ squid_error_entry(StoreEntry * entry, log_type type, const char *msg)
     if (type < ERR_MIN || type > ERR_MAX)
 	fatal_dump("squid_error_entry: type out of range.");
     error_index = (int) (type - ERR_MIN);
-    debug(4, 1, "%s: %s\n", ErrorData[error_index].tag, entry->url);
+    debug(4, 1) ("%s: %s\n", ErrorData[error_index].tag, entry->url);
     sprintf(tmp_error_buf, SQUID_ERROR_MSG_P1,
 	entry->url,
 	entry->url,
@@ -204,7 +204,7 @@ squid_error_url(const char *url, int method, int type, const char *address, int
     if (!code)
 	code = 500;
     error_index = (int) (type - ERR_MIN);
-    debug(4, 1, "%s: %s\n", ErrorData[error_index].tag, url);
+    debug(4, 1) ("%s: %s\n", ErrorData[error_index].tag, url);
     sprintf(tmp_error_buf, "HTTP/1.0 %d Cache Detected Error\r\nContent-type: text/html\r\n\r\n", code);
     sprintf(tbuf, SQUID_ERROR_MSG_P1,
 	url,
@@ -251,7 +251,7 @@ squid_error_request(const char *request, int type, int code)
     if (type < ERR_MIN || type > ERR_MAX)
 	fatal_dump("squid_error_request: type out of range.");
     error_index = (int) (type - ERR_MIN);
-    debug(4, 1, "%s: %s\n", ErrorData[error_index].tag, request);
+    debug(4, 1) ("%s: %s\n", ErrorData[error_index].tag, request);
     sprintf(tmp_error_buf, "HTTP/1.0 %d Cache Detected Error\r\nContent-type: text/html\r\n\r\n", code);
     sprintf(tbuf, SQUID_REQUEST_ERROR_MSG,
 	request,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: event.cc,v 1.7 1997/05/17 15:59:45 wessels Exp $
+ * $Id: event.cc,v 1.8 1997/06/04 06:15:51 wessels Exp $
  *
  * DEBUG: section 41    Event Processing
  * AUTHOR: Henrik Nordstrom
@@ -51,7 +51,7 @@ eventAdd(const char *name, EVH * func, void *arg, time_t when)
     event->arg = arg;
     event->name = name;
     event->when = squid_curtime + when;
-    debug(41, 7, "eventAdd: Adding '%s', in %d seconds\n", name, when);
+    debug(41, 7) ("eventAdd: Adding '%s', in %d seconds\n", name, when);
     /* Insert after the last event with the same or earlier time */
     for (E = &tasks; *E; E = &(*E)->next) {
 	if ((*E)->when > event->when)
@@ -88,7 +88,7 @@ eventRun(void)
 	return;
     if (event->when > squid_curtime)
 	return;
-    debug(41, 7, "eventRun: Running '%s'\n", event->name);
+    debug(41, 7) ("eventRun: Running '%s'\n", event->name);
     func = event->func;
     arg = event->arg;
     event->func = NULL;
@@ -83,6 +83,6 @@ fdDumpOpen(void)
 	    continue;
 	if (i == fileno(debug_log))
 	    continue;
-	debug(5, 1, "Open FD %4d %s\n", i, fde->desc);
+	debug(5, 1) ("Open FD %4d %s\n", i, fde->desc);
     }
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: filemap.cc,v 1.17 1997/05/16 07:44:32 wessels Exp $
+ * $Id: filemap.cc,v 1.18 1997/06/04 06:15:52 wessels Exp $
  *
  * DEBUG: section 8     Swap File Bitmap
  * AUTHOR: Harvest Derived
@@ -130,8 +130,8 @@ file_map_create(int n)
     fileMap *fm = xcalloc(1, sizeof(fileMap));
     fm->max_n_files = n;
     fm->nwords = n >> LONG_BIT_SHIFT;
-    debug(8, 3, "file_map_create: creating space for %d files\n", n);
-    debug(8, 5, "--> %d words of %d bytes each\n",
+    debug(8, 3) ("file_map_create: creating space for %d files\n", n);
+    debug(8, 5) ("--> %d words of %d bytes each\n",
 	fm->nwords, sizeof(unsigned long));
     fm->file_map = xcalloc(fm->nwords, sizeof(unsigned long));
     meta_data.misc += fm->nwords * sizeof(unsigned long);
@@ -146,9 +146,9 @@ file_map_bit_set(fileMap * fm, int file_number)
     fm->n_files_in_map++;
     if (!fm->toggle && (fm->n_files_in_map > ((fm->max_n_files * 7) >> 3))) {
 	fm->toggle++;
-	debug(8, 0, "You should increment MAX_SWAP_FILE\n");
+	debug(8, 0) ("You should increment MAX_SWAP_FILE\n");
     } else if (fm->n_files_in_map > (fm->max_n_files - 100)) {
-	debug(8, 0, "You've run out of swap file numbers. Freeing 1MB\n");
+	debug(8, 0) ("You've run out of swap file numbers. Freeing 1MB\n");
 	storeGetSwapSpace(1000000);
     }
     return (file_number);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.54 1997/05/15 01:18:43 wessels Exp $
+ * $Id: fqdncache.cc,v 1.55 1997/06/04 06:15:53 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -208,30 +208,30 @@ fqdncache_release(fqdncache_entry * f)
     int k;
 
     if ((table_entry = hash_lookup(fqdn_table, f->name)) == NULL) {
-	debug(35, 0, "fqdncache_release: Could not find key '%s'\n", f->name);
+	debug(35, 0) ("fqdncache_release: Could not find key '%s'\n", f->name);
 	return;
     }
     if (f != (fqdncache_entry *) table_entry)
 	fatal_dump("fqdncache_release: f != table_entry!");
     if (f->status == FQDN_PENDING) {
-	debug(35, 1, "fqdncache_release: Someone called on a PENDING entry\n");
+	debug(35, 1) ("fqdncache_release: Someone called on a PENDING entry\n");
 	return;
     }
     if (f->status == FQDN_DISPATCHED) {
-	debug(35, 1, "fqdncache_release: Someone called on a DISPATCHED entry\n");
+	debug(35, 1) ("fqdncache_release: Someone called on a DISPATCHED entry\n");
 	return;
     }
     if (f->pending_head)
 	fatal_dump("fqdncache_release: still have pending clients");
     if (hash_remove_link(fqdn_table, table_entry)) {
-	debug(35, 0, "fqdncache_release: hash_remove_link() failed for '%s'\n",
+	debug(35, 0) ("fqdncache_release: hash_remove_link() failed for '%s'\n",
 	    f->name);
 	return;
     }
     if (f->status == FQDN_CACHED) {
 	for (k = 0; k < (int) f->name_count; k++)
 	    safe_free(f->names[k]);
-	debug(35, 5, "fqdncache_release: Released FQDN record for '%s'.\n",
+	debug(35, 5) ("fqdncache_release: Released FQDN record for '%s'.\n",
 	    f->name);
     }
     safe_free(f->name);
@@ -320,7 +320,7 @@ fqdncache_purgelru(void)
 	if (LRU_list_count >= LRU_cur_size) {
 	    /* have to realloc  */
 	    LRU_cur_size += 16;
-	    debug(35, 3, "fqdncache_purgelru: Have to grow LRU_list to %d. This shouldn't happen.\n",
+	    debug(35, 3) ("fqdncache_purgelru: Have to grow LRU_list to %d. This shouldn't happen.\n",
 		LRU_cur_size);
 	    LRU_list = xrealloc((char *) LRU_list,
 		LRU_cur_size * sizeof(fqdncache_entry *));
@@ -333,12 +333,12 @@ fqdncache_purgelru(void)
 	LRU_list[LRU_list_count++] = f;
     }
 
-    debug(35, 3, "fqdncache_purgelru: fqdncache_count: %5d\n", meta_data.fqdncache_count);
-    debug(35, 3, "                  actual count : %5d\n", local_fqdn_count);
-    debug(35, 3, "                   high W mark : %5d\n", fqdncache_high);
-    debug(35, 3, "                   low  W mark : %5d\n", fqdncache_low);
-    debug(35, 3, "                   not pending : %5d\n", local_fqdn_notpending_count);
-    debug(35, 3, "                LRU candidates : %5d\n", LRU_list_count);
+    debug(35, 3) ("fqdncache_purgelru: fqdncache_count: %5d\n", meta_data.fqdncache_count);
+    debug(35, 3) ("                  actual count : %5d\n", local_fqdn_count);
+    debug(35, 3) ("                   high W mark : %5d\n", fqdncache_high);
+    debug(35, 3) ("                   low  W mark : %5d\n", fqdncache_low);
+    debug(35, 3) ("                   not pending : %5d\n", local_fqdn_notpending_count);
+    debug(35, 3) ("                LRU candidates : %5d\n", LRU_list_count);
 
     /* sort LRU candidate list */
     qsort((char *) LRU_list,
@@ -354,7 +354,7 @@ fqdncache_purgelru(void)
 	removed++;
     }
 
-    debug(35, 3, "                       removed : %5d\n", removed);
+    debug(35, 3) ("                       removed : %5d\n", removed);
     safe_free(LRU_list);
     return (removed > 0) ? 0 : -1;
 }
@@ -368,7 +368,7 @@ fqdncache_create(const char *name)
 
     if (meta_data.fqdncache_count > fqdncache_high) {
 	if (fqdncache_purgelru() < 0)
-	    debug(35, 0, "HELP!! FQDN Cache is overflowing!\n");
+	    debug(35, 0) ("HELP!! FQDN Cache is overflowing!\n");
     }
     meta_data.fqdncache_count++;
     new = xcalloc(1, sizeof(fqdncache_entry));
@@ -382,10 +382,10 @@ static void
 fqdncache_add_to_hash(fqdncache_entry * f)
 {
     if (hash_join(fqdn_table, (hash_link *) f)) {
-	debug(35, 1, "fqdncache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
+	debug(35, 1) ("fqdncache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
 	    f->name, f, fqdn_table);
     }
-    debug(35, 5, "fqdncache_add_to_hash: name <%s>\n", f->name);
+    debug(35, 5) ("fqdncache_add_to_hash: name <%s>\n", f->name);
 }
 
 static void
@@ -407,7 +407,7 @@ fqdncacheAddNew(const char *name, const struct hostent *hp, fqdncache_status_t s
     fqdncache_entry *f;
     if (fqdncache_get(name))
 	fatal_dump("fqdncacheAddNew: somebody adding a duplicate!");
-    debug(14, 10, "fqdncacheAddNew: Adding '%s', status=%c\n",
+    debug(14, 10) ("fqdncacheAddNew: Adding '%s', status=%c\n",
 	name,
 	fqdncache_status_char[status]);
     f = fqdncache_create(name);
@@ -440,7 +440,7 @@ fqdncache_call_pending(fqdncache_entry * f)
 	safe_free(p);
     }
     f->pending_head = NULL;	/* nuke list */
-    debug(35, 10, "fqdncache_call_pending: Called %d handlers.\n", nhandler);
+    debug(35, 10) ("fqdncache_call_pending: Called %d handlers.\n", nhandler);
     fqdncacheUnlockEntry(f);
 }
 
@@ -453,7 +453,7 @@ fqdncache_parsebuffer(const char *inbuf, dnsserver_t * dnsData)
     int k;
     int ipcount;
     int aliascount;
-    debug(35, 5, "fqdncache_parsebuffer: parsing:\n%s", inbuf);
+    debug(35, 5) ("fqdncache_parsebuffer: parsing:\n%s", inbuf);
     memset(&f, '\0', sizeof(fqdncache_entry));
     f.expires = squid_curtime + Config.positiveDnsTtl;
     f.status = FQDN_DISPATCHED;
@@ -533,7 +533,7 @@ fqdncache_dnsHandleRead(int fd, void *data)
 	dnsData->ip_inbuf + dnsData->offset,
 	dnsData->size - dnsData->offset);
     fd_bytes(fd, len, FD_READ);
-    debug(35, 5, "fqdncache_dnsHandleRead: Result from DNS ID %d (%d bytes)\n",
+    debug(35, 5) ("fqdncache_dnsHandleRead: Result from DNS ID %d (%d bytes)\n",
 	dnsData->id, len);
     if (len <= 0) {
 	if (len < 0 && (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)) {
@@ -543,8 +543,8 @@ fqdncache_dnsHandleRead(int fd, void *data)
 		dnsData, 0);
 	    return;
 	}
-	debug(35, dnsData->flags & DNS_FLAG_CLOSING ? 5 : 1,
-	    "FD %d: Connection from DNSSERVER #%d is closed, disabling\n",
+	debug(35, dnsData->flags & DNS_FLAG_CLOSING ? 5 : 1)
+	    ("FD %d: Connection from DNSSERVER #%d is closed, disabling\n",
 	    fd, dnsData->id);
 	dnsData->flags = 0;
 	commSetSelect(fd,
@@ -569,7 +569,7 @@ fqdncache_dnsHandleRead(int fd, void *data)
 	    tvSubMsec(dnsData->dispatch_time, current_time),
 	    n, FQDNCACHE_AV_FACTOR);
 	if ((x = fqdncache_parsebuffer(dnsData->ip_inbuf, dnsData)) == NULL) {
-	    debug(35, 0, "fqdncache_dnsHandleRead: fqdncache_parsebuffer failed?!\n");
+	    debug(35, 0) ("fqdncache_dnsHandleRead: fqdncache_parsebuffer failed?!\n");
 	} else {
 	    dnsData->offset = 0;
 	    dnsData->ip_inbuf[0] = '\0';
@@ -619,11 +619,11 @@ fqdncache_nbgethostbyaddr(struct in_addr addr, FQDNH * handler, void *handlerDat
     if (!handler)
 	fatal_dump("fqdncache_nbgethostbyaddr: NULL handler");
 
-    debug(35, 4, "fqdncache_nbgethostbyaddr: Name '%s'.\n", name);
+    debug(35, 4) ("fqdncache_nbgethostbyaddr: Name '%s'.\n", name);
     FqdncacheStats.requests++;
 
     if (name == NULL || name[0] == '\0') {
-	debug(35, 4, "fqdncache_nbgethostbyaddr: Invalid name!\n");
+	debug(35, 4) ("fqdncache_nbgethostbyaddr: Invalid name!\n");
 	handler(NULL, handlerData);
 	return;
     }
@@ -635,13 +635,13 @@ fqdncache_nbgethostbyaddr(struct in_addr addr, FQDNH * handler, void *handlerDat
     }
     if (f == NULL) {
 	/* MISS: No entry, create the new one */
-	debug(35, 5, "fqdncache_nbgethostbyaddr: MISS for '%s'\n", name);
+	debug(35, 5) ("fqdncache_nbgethostbyaddr: MISS for '%s'\n", name);
 	FqdncacheStats.misses++;
 	f = fqdncacheAddNew(name, NULL, FQDN_PENDING);
 	fqdncacheAddPending(f, handler, handlerData);
     } else if (f->status == FQDN_CACHED || f->status == FQDN_NEGATIVE_CACHED) {
 	/* HIT */
-	debug(35, 4, "fqdncache_nbgethostbyaddr: HIT for '%s'\n", name);
+	debug(35, 4) ("fqdncache_nbgethostbyaddr: HIT for '%s'\n", name);
 	if (f->status == FQDN_NEGATIVE_CACHED)
 	    FqdncacheStats.negative_hits++;
 	else
@@ -650,11 +650,11 @@ fqdncache_nbgethostbyaddr(struct in_addr addr, FQDNH * handler, void *handlerDat
 	fqdncache_call_pending(f);
 	return;
     } else if (f->status == FQDN_PENDING || f->status == FQDN_DISPATCHED) {
-	debug(35, 4, "fqdncache_nbgethostbyaddr: PENDING for '%s'\n", name);
+	debug(35, 4) ("fqdncache_nbgethostbyaddr: PENDING for '%s'\n", name);
 	FqdncacheStats.pending_hits++;
 	fqdncacheAddPending(f, handler, handlerData);
 	if (squid_curtime - f->expires > 600) {
-	    debug(14, 0, "fqdncache_nbgethostbyname: '%s' PENDING for %d seconds, aborting\n", name, squid_curtime + Config.negativeDnsTtl - f->expires);
+	    debug(14, 0) ("fqdncache_nbgethostbyname: '%s' PENDING for %d seconds, aborting\n", name, squid_curtime + Config.negativeDnsTtl - f->expires);
 	    fqdncacheChangeKey(f);
 	    fqdncache_call_pending(f);
 	}
@@ -684,7 +684,7 @@ fqdncache_dnsDispatch(dnsserver_t * dns, fqdncache_entry * f)
     if (!BIT_TEST(dns->flags, DNS_FLAG_ALIVE))
 	debug_trap("Dispatching a dead DNS server");
     if (!fqdncacheHasPending(f)) {
-	debug(35, 0, "fqdncache_dnsDispatch: skipping '%s' because no handler.\n",
+	debug(35, 0) ("fqdncache_dnsDispatch: skipping '%s' because no handler.\n",
 	    f->name);
 	f->status = FQDN_NEGATIVE_CACHED;
 	fqdncache_release(f);
@@ -708,7 +708,7 @@ fqdncache_dnsDispatch(dnsserver_t * dns, fqdncache_entry * f)
 	fqdncache_dnsHandleRead,
 	dns,
 	0);
-    debug(35, 5, "fqdncache_dnsDispatch: Request sent to DNS server #%d.\n",
+    debug(35, 5) ("fqdncache_dnsDispatch: Request sent to DNS server #%d.\n",
 	dns->id);
     dns->dispatch_time = current_time;
     DnsStats.requests++;
@@ -723,7 +723,7 @@ fqdncache_init(void)
 {
     if (fqdn_table)
 	return;
-    debug(35, 3, "Initializing FQDN Cache...\n");
+    debug(35, 3) ("Initializing FQDN Cache...\n");
     memset(&FqdncacheStats, '\0', sizeof(FqdncacheStats));
     /* small hash table */
     fqdn_table = hash_create(urlcmp, 229, hash4);
@@ -742,7 +742,7 @@ fqdncacheUnregister(struct in_addr addr, void *data)
     fqdncache_entry *f = NULL;
     struct _fqdn_pending *p = NULL;
     int n = 0;
-    debug(35, 3, "fqdncacheUnregister: FD %d, name '%s'\n", name);
+    debug(35, 3) ("fqdncacheUnregister: FD %d, name '%s'\n", name);
     if ((f = fqdncache_get(name)) == NULL)
 	return 0;
     if (f->status == FQDN_PENDING || f->status == FQDN_DISPATCHED) {
@@ -755,7 +755,7 @@ fqdncacheUnregister(struct in_addr addr, void *data)
     }
     if (n == 0)
 	debug_trap("fqdncacheUnregister: callback data not found");
-    debug(35, 3, "fqdncacheUnregister: unregistered %d handlers\n", n);
+    debug(35, 3) ("fqdncacheUnregister: unregistered %d handlers\n", n);
     return n;
 }
 
@@ -799,7 +799,7 @@ fqdncache_gethostbyaddr(struct in_addr addr, int flags)
     FqdncacheStats.misses++;
     if (BIT_TEST(flags, FQDN_BLOCKING_LOOKUP)) {
 	if (NDnsServersAlloc)
-	    debug(14, 0, "WARNING: blocking on gethostbyaddr() for '%s'\n", name);
+	    debug(14, 0) ("WARNING: blocking on gethostbyaddr() for '%s'\n", name);
 	FqdncacheStats.ghba_calls++;
 	hp = gethostbyaddr((char *) &ip.s_addr, 4, AF_INET);
 	if (hp && hp->h_name && (hp->h_name[0] != '\0') && fqdn_table) {
@@ -982,7 +982,7 @@ fqdncacheChangeKey(fqdncache_entry * f)
     LOCAL_ARRAY(char, new_key, 256);
     hash_link *table_entry = hash_lookup(fqdn_table, f->name);
     if (table_entry == NULL) {
-	debug(14, 0, "fqdncacheChangeKey: Could not find key '%s'\n", f->name);
+	debug(14, 0) ("fqdncacheChangeKey: Could not find key '%s'\n", f->name);
 	return;
     }
     if (f != (fqdncache_entry *) table_entry) {
@@ -995,7 +995,7 @@ fqdncacheChangeKey(fqdncache_entry * f)
     }
     sprintf(new_key, "%d/", ++index);
     strncat(new_key, f->name, 128);
-    debug(14, 1, "fqdncacheChangeKey: from '%s' to '%s'\n", f->name, new_key);
+    debug(14, 1) ("fqdncacheChangeKey: from '%s' to '%s'\n", f->name, new_key);
     safe_free(f->name);
     f->name = xstrdup(new_key);
     fqdncache_add_to_hash(f);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.119 1997/06/02 19:56:44 wessels Exp $
+ * $Id: ftp.cc,v 1.120 1997/06/04 06:15:54 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -227,7 +227,7 @@ ftpTimeout(int fd, void *data)
 {
     FtpStateData *ftpState = data;
     StoreEntry *entry = ftpState->entry;
-    debug(9, 4, "ftpLifeTimeExpire: FD %d: '%s'\n", fd, entry->url);
+    debug(9, 4) ("ftpLifeTimeExpire: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     if (ftpState->data.fd >= 0)
 	comm_close(ftpState->data.fd);
@@ -561,7 +561,7 @@ ftpParseListing(FtpStateData * ftpState, int len)
 	end--;
     usable = end - buf;
     if (usable == 0) {
-	debug(9, 3, "ftpParseListing: didn't find end for %s\n", e->url);
+	debug(9, 3) ("ftpParseListing: didn't find end for %s\n", e->url);
 	return;
     }
     line = get_free_4k_page();
@@ -571,7 +571,7 @@ ftpParseListing(FtpStateData * ftpState, int len)
 	if (linelen > 4096)
 	    linelen = 4096;
 	xstrncpy(line, s, linelen);
-	debug(9, 7, "%s\n", line);
+	debug(9, 7) ("%s\n", line);
 	if (!strncmp(line, "total", 5))
 	    continue;
 	t = ftpHtmlifyListEntry(line, ftpState->flags);
@@ -603,16 +603,16 @@ ftpReadData(int fd, void *data)
     StoreEntry *entry = ftpState->entry;
     assert(fd == ftpState->data.fd);
     if (protoAbortFetch(entry)) {
-        squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
-        ftpDataTransferDone(ftpState);
-        return;
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	ftpDataTransferDone(ftpState);
+	return;
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->e_current_len;
     off = storeGetLowestReaderOffset(entry);
     if ((clen - off) > FTP_DELETE_GAP) {
 	IOStats.Ftp.reads_deferred++;
-	debug(9, 3, "ftpReadData: Read deferred for Object: %s\n",
+	debug(9, 3) ("ftpReadData: Read deferred for Object: %s\n",
 	    entry->url);
 	commSetSelect(fd, COMM_SELECT_READ, ftpReadData, data, 0);
 	if (!BIT_TEST(entry->flag, READ_DEFERRED)) {
@@ -635,7 +635,7 @@ ftpReadData(int fd, void *data)
 	ftpState->data.buf + ftpState->data.offset,
 	ftpState->data.size - ftpState->data.offset);
     fd_bytes(fd, len, FD_READ);
-    debug(9, 5, "ftpReadData: FD %d, Read %d bytes\n", fd, len);
+    debug(9, 5) ("ftpReadData: FD %d, Read %d bytes\n", fd, len);
     if (len > 0) {
 	commSetTimeout(fd, Config.Timeout.read, NULL, NULL);
 	IOStats.Ftp.reads++;
@@ -644,7 +644,7 @@ ftpReadData(int fd, void *data)
 	IOStats.Ftp.read_hist[bin]++;
     }
     if (len < 0) {
-	debug(50, 1, "ftpReadData: read error: %s\n", xstrerror());
+	debug(50, 1) ("ftpReadData: read error: %s\n", xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    commSetSelect(fd, COMM_SELECT_READ,
 		ftpReadData, data, 0);
@@ -818,7 +818,7 @@ ftpStart(request_t * request, StoreEntry * entry)
     FtpStateData *ftpState = xcalloc(1, sizeof(FtpStateData));
     char *response;
     int fd;
-    debug(9, 3, "FtpStart: '%s'\n", entry->url);
+    debug(9, 3) ("FtpStart: '%s'\n", entry->url);
     storeLockObject(entry);
     ftpState->entry = entry;
     ftpState->request = requestLink(request);
@@ -843,7 +843,7 @@ ftpStart(request_t * request, StoreEntry * entry)
     }
     ftpCleanupUrlpath(ftpState);
     ftpBuildTitleUrl(ftpState);
-    debug(9, 5, "FtpStart: host=%s, path=%s, user=%s, passwd=%s\n",
+    debug(9, 5) ("FtpStart: host=%s, path=%s, user=%s, passwd=%s\n",
 	ftpState->request->host, ftpState->request->urlpath,
 	ftpState->user, ftpState->password);
     fd = comm_open(SOCK_STREAM,
@@ -853,7 +853,7 @@ ftpStart(request_t * request, StoreEntry * entry)
 	COMM_NONBLOCKING,
 	url);
     if (fd == COMM_ERROR) {
-	debug(9, 4, "ftpStart: Failed because we're out of sockets.\n");
+	debug(9, 4) ("ftpStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	return;
     }
@@ -873,12 +873,12 @@ ftpConnect(int fd, const ipcache_addrs * ia, void *data)
     EBIT_RESET(ftpState->flags, FTP_IP_LOOKUP_PENDING);
     assert(fd == ftpState->ctrl.fd);
     if (ia == NULL) {
-	debug(9, 4, "ftpConnect: Unknown host: %s\n", request->host);
+	debug(9, 4) ("ftpConnect: Unknown host: %s\n", request->host);
 	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	comm_close(fd);
 	return;
     }
-    debug(9, 3, "ftpConnect: %s is %s\n", request->host,
+    debug(9, 3) ("ftpConnect: %s is %s\n", request->host,
 	inet_ntoa(ia->in_addrs[0]));
     /* Open connection. */
     commSetTimeout(fd, Config.Timeout.connect, ftpTimeout, ftpState);
@@ -893,7 +893,7 @@ static void
 ftpConnectDone(int fd, int status, void *data)
 {
     FtpStateData *ftpState = data;
-    debug(9, 3, "ftpConnectDone\n");
+    debug(9, 3) ("ftpConnectDone\n");
     if (status == COMM_ERROR) {
 	squid_error_entry(ftpState->entry, ERR_CONNECT_FAIL, xstrerror());
 	comm_close(fd);
@@ -916,7 +916,7 @@ ftpConnectDone(int fd, int status, void *data)
 static void
 ftpWriteCommand(const char *buf, FtpStateData * ftpState)
 {
-    debug(9, 5, "ftpWriteCommand: %s\n", buf);
+    debug(9, 5) ("ftpWriteCommand: %s\n", buf);
     comm_write(ftpState->ctrl.fd,
 	xstrdup(buf),
 	strlen(buf),
@@ -935,7 +935,7 @@ ftpWriteCommandCallback(int fd, char *buf, int size, int errflag, void *data)
 {
     FtpStateData *ftpState = data;
     StoreEntry *entry = ftpState->entry;
-    debug(9, 7, "ftpWriteCommandCallback: wrote %d bytes\n", size);
+    debug(9, 7) ("ftpWriteCommandCallback: wrote %d bytes\n", size);
     if (errflag) {
 	BIT_RESET(entry->flag, ENTRY_CACHABLE);
 	storeReleaseRequest(entry);
@@ -955,7 +955,7 @@ ftpParseControlReply(char *buf, size_t len, int *codep)
     off_t offset;
     size_t linelen;
     int code = -1;
-    debug(9, 5, "ftpParseControlReply\n");
+    debug(9, 5) ("ftpParseControlReply\n");
     if (*(buf + len - 1) != '\n')
 	return NULL;
     for (s = buf; s - buf < len; s += strcspn(s, crlf), s += strspn(s, crlf)) {
@@ -971,7 +971,7 @@ ftpParseControlReply(char *buf, size_t len, int *codep)
 	list = xcalloc(1, sizeof(wordlist));
 	list->key = xmalloc(linelen - offset);
 	xstrncpy(list->key, s + offset, linelen - offset);
-	debug(9, 7, "%p: %s\n", list->key, list->key);
+	debug(9, 7) ("%p: %s\n", list->key, list->key);
 	*tail = list;
 	tail = &list->next;
     }
@@ -990,17 +990,17 @@ ftpReadControlReply(int fd, void *data)
     char *oldbuf;
     wordlist **W;
     int len;
-    debug(9, 5, "ftpReadControlReply\n");
+    debug(9, 5) ("ftpReadControlReply\n");
     assert(ftpState->ctrl.offset < ftpState->ctrl.size);
     len = read(fd,
 	ftpState->ctrl.buf + ftpState->ctrl.offset,
 	ftpState->ctrl.size - ftpState->ctrl.offset);
     fd_bytes(fd, len, FD_READ);
-    debug(9, 5, "ftpReadControlReply: FD %d, Read %d bytes\n", fd, len);
+    debug(9, 5) ("ftpReadControlReply: FD %d, Read %d bytes\n", fd, len);
     if (len > 0)
 	commSetTimeout(fd, Config.Timeout.read, NULL, NULL);
     if (len < 0) {
-	debug(50, 1, "ftpReadControlReply: read error: %s\n", xstrerror());
+	debug(50, 1) ("ftpReadControlReply: read error: %s\n", xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    commSetSelect(fd,
 		COMM_SELECT_READ,
@@ -1016,7 +1016,7 @@ ftpReadControlReply(int fd, void *data)
 	return;
     }
     if (len == 0) {
-	debug(9, 1, "Read 0 bytes from FTP control socket?\n");
+	debug(9, 1) ("Read 0 bytes from FTP control socket?\n");
 	BIT_RESET(entry->flag, ENTRY_CACHABLE);
 	storeReleaseRequest(entry);
 	squid_error_entry(entry, ERR_READ_ERROR, xstrerror());
@@ -1030,7 +1030,7 @@ ftpReadControlReply(int fd, void *data)
     ftpState->ctrl.message = ftpParseControlReply(ftpState->ctrl.buf, len,
 	&ftpState->ctrl.replycode);
     if (ftpState->ctrl.message == NULL) {
-	debug(9, 5, "ftpReadControlReply: partial server reply\n");
+	debug(9, 5) ("ftpReadControlReply: partial server reply\n");
 	if (len == ftpState->ctrl.size) {
 	    oldbuf = ftpState->ctrl.buf;
 	    ftpState->ctrl.buf = xcalloc(ftpState->ctrl.size << 1, 1);
@@ -1056,7 +1056,7 @@ static void
 ftpReadWelcome(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "ftpReadWelcome\n");
+    debug(9, 3) ("ftpReadWelcome\n");
     if (EBIT_TEST(ftpState->flags, FTP_PASV_ONLY))
 	ftpState->login_att++;
     if (code == 220) {
@@ -1080,7 +1080,7 @@ static void
 ftpReadUser(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "ftpReadUser\n");
+    debug(9, 3) ("ftpReadUser\n");
     if (code == 230) {
 	ftpReadPass(ftpState);
     } else if (code == 331) {
@@ -1099,7 +1099,7 @@ ftpReadPass(FtpStateData * ftpState)
     char *t;
     char *filename;
     char mode;
-    debug(9, 3, "ftpReadPass\n");
+    debug(9, 3) ("ftpReadPass\n");
     if (code == 230) {
 	t = strrchr(ftpState->request->urlpath, '/');
 	filename = t ? t + 1 : ftpState->request->urlpath;
@@ -1120,7 +1120,7 @@ ftpReadType(FtpStateData * ftpState)
     wordlist **T;
     char *path;
     char *d;
-    debug(9, 3, "This is ftpReadType\n");
+    debug(9, 3) ("This is ftpReadType\n");
     if (code == 200) {
 	if (EBIT_TEST(ftpState->flags, FTP_ROOT_DIR)) {
 	    ftpSendPasv(ftpState);
@@ -1145,9 +1145,9 @@ static void
 ftpSendCwd(FtpStateData * ftpState)
 {
     wordlist *w;
-    debug(9, 3, "ftpSendCwd\n");
+    debug(9, 3) ("ftpSendCwd\n");
     if ((w = ftpState->pathcomps) == NULL) {
-	debug(9, 3, "the final component was a directory\n");
+	debug(9, 3) ("the final component was a directory\n");
 	EBIT_SET(ftpState->flags, FTP_ISDIR);
 	if (!EBIT_TEST(ftpState->flags, FTP_ROOT_DIR))
 	    strcat(ftpState->title_url, "/");
@@ -1165,7 +1165,7 @@ ftpReadCwd(FtpStateData * ftpState)
     int code = ftpState->ctrl.replycode;
     size_t len = 0;
     wordlist *w;
-    debug(9, 3, "This is ftpReadCwd\n");
+    debug(9, 3) ("This is ftpReadCwd\n");
     w = ftpState->pathcomps;
     assert(w != NULL);
     if (code >= 200 && code < 300) {
@@ -1202,7 +1202,7 @@ static void
 ftpReadMdtm(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "This is ftpReadMdtm\n");
+    debug(9, 3) ("This is ftpReadMdtm\n");
     if (code == 213) {
 	ftpState->mdtm = parse_iso3307_time(ftpState->ctrl.last_message);
 	assert(ftpState->filepath != NULL);
@@ -1219,7 +1219,7 @@ static void
 ftpReadSize(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "This is ftpReadSize\n");
+    debug(9, 3) ("This is ftpReadSize\n");
     if (code == 213) {
 	ftpState->size = atoi(ftpState->ctrl.last_message);
 	ftpSendPasv(ftpState);
@@ -1265,44 +1265,44 @@ ftpReadPasv(FtpStateData * ftpState)
     int fd = ftpState->data.fd;
     char *buf = ftpState->ctrl.last_message;
     LOCAL_ARRAY(char, junk, 1024);
-    debug(9, 3, "This is ftpReadPasv\n");
+    debug(9, 3) ("This is ftpReadPasv\n");
     if (code != 227) {
-	debug(9, 3, "PASV not supported by remote end\n");
+	debug(9, 3) ("PASV not supported by remote end\n");
 	ftpSendPort(ftpState);
 	return;
     }
     if (strlen(buf) > 1024) {
-	debug(9, 1, "Avoiding potential buffer overflow\n");
+	debug(9, 1) ("Avoiding potential buffer overflow\n");
 	ftpSendPort(ftpState);
 	return;
     }
     /*  227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).  */
     /*  ANSI sez [^0-9] is undefined, it breaks on Watcom cc */
-    debug(9, 5, "scanning: %s\n", buf);
+    debug(9, 5) ("scanning: %s\n", buf);
     n = sscanf(buf, "%[^0123456789]%d,%d,%d,%d,%d,%d",
 	junk, &h1, &h2, &h3, &h4, &p1, &p2);
     if (n != 7 || p1 < 0 || p2 < 0 || p1 > 255 || p2 > 255) {
-	debug(9, 3, "Bad 227 reply\n");
-	debug(9, 3, "n=%d, p1=%d, p2=%d\n", n, p1, p2);
+	debug(9, 3) ("Bad 227 reply\n");
+	debug(9, 3) ("n=%d, p1=%d, p2=%d\n", n, p1, p2);
 	ftpSendPort(ftpState);
 	return;
     }
     sprintf(junk, "%d.%d.%d.%d", h1, h2, h3, h4);
     if (!safe_inet_addr(junk, NULL)) {
-	debug(9, 1, "unsafe address (%s)\n", junk);
+	debug(9, 1) ("unsafe address (%s)\n", junk);
 	ftpSendPort(ftpState);
 	return;
     }
     port = ((p1 << 8) + p2);
-    debug(9, 5, "ftpReadPasv: connecting to %s, port %d\n", junk, port);
+    debug(9, 5) ("ftpReadPasv: connecting to %s, port %d\n", junk, port);
     commConnectStart(fd, junk, port, ftpPasvCallback, ftpState);
 }
 
 static void
 ftpPasvCallback(int fd, int status, void *data)
 {
     FtpStateData *ftpState = data;
-    debug(9, 3, "ftpPasvCallback\n");
+    debug(9, 3) ("ftpPasvCallback\n");
     if (status == COMM_ERROR) {
 	squid_error_entry(ftpState->entry, ERR_CONNECT_FAIL, xstrerror());
 	comm_close(fd);
@@ -1314,20 +1314,20 @@ ftpPasvCallback(int fd, int status, void *data)
 static void
 ftpSendPort(FtpStateData * ftpState)
 {
-    debug(9, 3, "This is ftpSendPort\n");
+    debug(9, 3) ("This is ftpSendPort\n");
     EBIT_RESET(ftpState->flags, FTP_PASV_SUPPORTED);
 }
 
 static void
 ftpReadPort(FtpStateData * ftpState)
 {
-    debug(9, 3, "This is ftpReadPort\n");
+    debug(9, 3) ("This is ftpReadPort\n");
 }
 
 static void
 ftpRestOrList(FtpStateData * ftpState)
 {
-    debug(9, 3, "This is ftpRestOrList\n");
+    debug(9, 3) ("This is ftpRestOrList\n");
     if (EBIT_TEST(ftpState->flags, FTP_ISDIR)) {
 	sprintf(cbuf, "LIST\r\n");
 	ftpWriteCommand(cbuf, ftpState);
@@ -1348,15 +1348,15 @@ static void
 ftpReadRest(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "This is ftpReadRest\n");
+    debug(9, 3) ("This is ftpReadRest\n");
     assert(ftpState->restart_offset > 0);
     if (code == 350) {
 	assert(ftpState->filepath != NULL);
 	sprintf(cbuf, "RETR %s\r\n", ftpState->filepath);
 	ftpWriteCommand(cbuf, ftpState);
 	ftpState->state = SENT_RETR;
     } else if (code > 0) {
-	debug(9, 3, "ftpReadRest: REST not supported\n");
+	debug(9, 3) ("ftpReadRest: REST not supported\n");
 	EBIT_RESET(ftpState->flags, FTP_REST_SUPPORTED);
     } else {
 	ftpFail(ftpState);
@@ -1367,7 +1367,7 @@ static void
 ftpReadList(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "This is ftpReadList\n");
+    debug(9, 3) ("This is ftpReadList\n");
     if (code == 150 || code == 125) {
 	ftpAppendSuccessHeader(ftpState);
 	commSetSelect(ftpState->data.fd,
@@ -1392,9 +1392,9 @@ static void
 ftpReadRetr(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "This is ftpReadRetr\n");
+    debug(9, 3) ("This is ftpReadRetr\n");
     if (code >= 100 && code < 200) {
-	debug(9, 3, "reading data channel\n");
+	debug(9, 3) ("reading data channel\n");
 	ftpAppendSuccessHeader(ftpState);
 	commSetSelect(ftpState->data.fd,
 	    COMM_SELECT_READ,
@@ -1411,20 +1411,20 @@ static void
 ftpReadTransferDone(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    debug(9, 3, "This is ftpReadTransferDone\n");
+    debug(9, 3) ("This is ftpReadTransferDone\n");
     if (code != 226) {
-	debug(9, 1, "Got code %d after reading data, releasing entry\n");
+	debug(9, 1) ("Got code %d after reading data, releasing entry\n");
 	storeReleaseRequest(ftpState->entry);
     }
 }
 
 static void
 ftpDataTransferDone(FtpStateData * ftpState)
 {
-    debug(9, 3, "This is ftpDataTransferDone\n");
+    debug(9, 3) ("This is ftpDataTransferDone\n");
     if (ftpState->data.fd > -1) {
-        comm_close(ftpState->data.fd);
-        ftpState->data.fd = -1;
+	comm_close(ftpState->data.fd);
+	ftpState->data.fd = -1;
     }
     assert(ftpState->ctrl.fd > -1);
     sprintf(cbuf, "QUIT\r\n");
@@ -1441,7 +1441,7 @@ ftpReadQuit(FtpStateData * ftpState)
 static void
 ftpFail(FtpStateData * ftpState)
 {
-    debug(9, 3, "ftpFail\n");
+    debug(9, 3) ("ftpFail\n");
     comm_close(ftpState->ctrl.fd);
 }
 
@@ -1474,11 +1474,11 @@ ftpAppendSuccessHeader(FtpStateData * ftpState)
     storeAppendPrintf(e, "Server: Squid %s\r\n", version_string);
     if (ftpState->size > 0) {
 	storeAppendPrintf(e, "Content-Length: %d\r\n", ftpState->size);
-        reply->content_length = ftpState->size;
+	reply->content_length = ftpState->size;
     }
     if (mime_type) {
 	storeAppendPrintf(e, "Content-Type: %s\r\n", mime_type);
-    	xstrncpy(reply->content_type, mime_type, HTTP_REPLY_FIELD_SZ);
+	xstrncpy(reply->content_type, mime_type, HTTP_REPLY_FIELD_SZ);
     }
     if (mime_enc)
 	storeAppendPrintf(e, "Content-Encoding: %s\r\n", mime_enc);
@@ -1496,6 +1496,6 @@ static void
 ftpAbort(void *data)
 {
     FtpStateData *ftpState = data;
-    debug(9, 1, "ftpAbort: %s\n", ftpState->entry->url);
+    debug(9, 1) ("ftpAbort: %s\n", ftpState->entry->url);
     ftpDataTransferDone(ftpState);
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: gopher.cc,v 1.83 1997/06/02 19:56:02 wessels Exp $
+ * $Id: gopher.cc,v 1.84 1997/06/04 06:15:56 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -415,7 +415,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
 		if (gopherState->len + len > TEMP_BUF_SIZE) {
-		    debug(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
+		    debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
 		    len = TEMP_BUF_SIZE - gopherState->len;
 		}
@@ -441,7 +441,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
 		if ((len - (pos - inbuf)) > TEMP_BUF_SIZE) {
-		    debug(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
+		    debug(10, 1) ("GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
 		    len = TEMP_BUF_SIZE;
 		}
@@ -645,7 +645,7 @@ gopherTimeout(int fd, void *data)
 {
     GopherStateData *gopherState = data;
     StoreEntry *entry = gopherState->entry;
-    debug(10, 4, "gopherTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(10, 4) ("gopherTimeout: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     comm_close(fd);
 }
@@ -663,18 +663,18 @@ gopherReadReply(int fd, void *data)
     int off;
     int bin;
     if (protoAbortFetch(entry)) {
-        squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
-        comm_close(fd);
-        return;
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	comm_close(fd);
+	return;
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->e_current_len;
     off = storeGetLowestReaderOffset(entry);
     if ((clen - off) > GOPHER_DELETE_GAP) {
 	IOStats.Gopher.reads_deferred++;
-	debug(10, 3, "gopherReadReply: Read deferred for Object: %s\n",
+	debug(10, 3) ("gopherReadReply: Read deferred for Object: %s\n",
 	    entry->url);
-	debug(10, 3, "                Current Gap: %d bytes\n", clen - off);
+	debug(10, 3) ("                Current Gap: %d bytes\n", clen - off);
 	/* reschedule, so it will automatically reactivated when
 	 * Gap is big enough.  */
 	commSetSelect(fd,
@@ -697,7 +697,7 @@ gopherReadReply(int fd, void *data)
     /* leave one space for \0 in gopherToHTML */
     len = read(fd, buf, TEMP_BUF_SIZE - 1);
     fd_bytes(fd, len, FD_READ);
-    debug(10, 5, "gopherReadReply: FD %d read len=%d\n", fd, len);
+    debug(10, 5) ("gopherReadReply: FD %d read len=%d\n", fd, len);
     if (len > 0) {
 	commSetTimeout(fd, Config.Timeout.read, NULL, NULL);
 	IOStats.Gopher.reads++;
@@ -706,7 +706,7 @@ gopherReadReply(int fd, void *data)
 	IOStats.Gopher.read_hist[bin]++;
     }
     if (len < 0) {
-	debug(50, 1, "gopherReadReply: error reading: %s\n", xstrerror());
+	debug(50, 1) ("gopherReadReply: error reading: %s\n", xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    /* reinstall handlers */
 	    /* XXX This may loop forever */
@@ -757,7 +757,7 @@ gopherSendComplete(int fd, char *buf, int size, int errflag, void *data)
     GopherStateData *gopherState = (GopherStateData *) data;
     StoreEntry *entry = NULL;
     entry = gopherState->entry;
-    debug(10, 5, "gopherSendComplete: FD %d size: %d errflag: %d\n",
+    debug(10, 5) ("gopherSendComplete: FD %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
 	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
@@ -830,7 +830,7 @@ gopherSendRequest(int fd, void *data)
     } else {
 	sprintf(buf, "%s\r\n", gopherState->request);
     }
-    debug(10, 5, "gopherSendRequest: FD %d\n", fd);
+    debug(10, 5) ("gopherSendRequest: FD %d\n", fd);
     comm_write(fd,
 	buf,
 	strlen(buf),
@@ -849,7 +849,7 @@ gopherStart(StoreEntry * entry)
     int fd;
     storeLockObject(entry);
     gopherState->entry = entry;
-    debug(10, 3, "gopherStart: url: %s\n", url);
+    debug(10, 3) ("gopherStart: url: %s\n", url);
     /* Parse url. */
     if (gopher_url_parser(url, gopherState->host, &gopherState->port,
 	    &gopherState->type_id, gopherState->request)) {
@@ -865,7 +865,7 @@ gopherStart(StoreEntry * entry)
 	COMM_NONBLOCKING,
 	url);
     if (fd == COMM_ERROR) {
-	debug(10, 4, "gopherStart: Failed because we're out of sockets.\n");
+	debug(10, 4) ("gopherStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	gopherStateFree(-1, gopherState);
 	return;
@@ -876,7 +876,7 @@ gopherStart(StoreEntry * entry)
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
     if (!ipcache_gethostbyname(gopherState->host, 0)) {
-	debug(10, 4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
+	debug(10, 4) ("gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
 	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	comm_close(fd);
 	return;
@@ -941,6 +941,6 @@ static void
 gopherAbort(void *data)
 {
     GopherStateData *gopherState = data;
-    debug(10,1,"gopherAbort: %s\n", gopherState->entry->url);
+    debug(10, 1) ("gopherAbort: %s\n", gopherState->entry->url);
     comm_close(gopherState->fd);
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: http.cc,v 1.169 1997/06/03 20:08:23 wessels Exp $
+ * $Id: http.cc,v 1.170 1997/06/04 06:15:57 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -242,7 +242,7 @@ httpTimeout(int fd, void *data)
 {
     HttpStateData *httpState = data;
     StoreEntry *entry = httpState->entry;
-    debug(11, 4, "httpTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(11, 4) ("httpTimeout: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     comm_close(fd);
 }
@@ -308,7 +308,7 @@ httpParseReplyHeaders(const char *buf, struct _http_reply *reply)
 	    l = 4096;
 	xstrncpy(line, s, l);
 	t = line;
-	debug(11, 3, "httpParseReplyHeaders: %s\n", t);
+	debug(11, 3) ("httpParseReplyHeaders: %s\n", t);
 	if (!strncasecmp(t, "HTTP/", 5)) {
 	    reply->version = atof(t + 5);
 	    if ((t = strchr(t, ' ')))
@@ -410,7 +410,7 @@ httpProcessReplyHeader(HttpStateData * httpState, const char *buf, int size)
     int hdr_len;
     struct _http_reply *reply = entry->mem_obj->reply;
 
-    debug(11, 3, "httpProcessReplyHeader: key '%s'\n", entry->key);
+    debug(11, 3) ("httpProcessReplyHeader: key '%s'\n", entry->key);
 
     if (httpState->reply_hdr == NULL)
 	httpState->reply_hdr = get_free_8k_page();
@@ -420,7 +420,7 @@ httpProcessReplyHeader(HttpStateData * httpState, const char *buf, int size)
 	strncat(httpState->reply_hdr, buf, room < size ? room : size);
 	hdr_len += room < size ? room : size;
 	if (hdr_len > 4 && strncmp(httpState->reply_hdr, "HTTP/", 5)) {
-	    debug(11, 3, "httpProcessReplyHeader: Non-HTTP-compliant header: '%s'\n", entry->key);
+	    debug(11, 3) ("httpProcessReplyHeader: Non-HTTP-compliant header: '%s'\n", entry->key);
 	    httpState->reply_hdr_state += 2;
 	    reply->code = 555;
 	    return;
@@ -435,13 +435,13 @@ httpProcessReplyHeader(HttpStateData * httpState, const char *buf, int size)
     }
     if (httpState->reply_hdr_state == 1) {
 	httpState->reply_hdr_state++;
-	debug(11, 9, "GOT HTTP REPLY HDR:\n---------\n%s\n----------\n",
+	debug(11, 9) ("GOT HTTP REPLY HDR:\n---------\n%s\n----------\n",
 	    httpState->reply_hdr);
 	/* Parse headers into reply structure */
 	httpParseReplyHeaders(httpState->reply_hdr, reply);
 	storeTimestampsSet(entry);
 	/* Check if object is cacheable or not based on reply code */
-	debug(11, 3, "httpProcessReplyHeader: HTTP CODE: %d\n", reply->code);
+	debug(11, 3) ("httpProcessReplyHeader: HTTP CODE: %d\n", reply->code);
 	switch (reply->code) {
 	    /* Responses that are cacheable */
 	case 200:		/* OK */
@@ -529,18 +529,18 @@ httpReadReply(int fd, void *data)
     int clen;
     int off;
     if (protoAbortFetch(entry)) {
-        squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
-        comm_close(fd);
-        return;
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	comm_close(fd);
+	return;
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->e_current_len;
     off = storeGetLowestReaderOffset(entry);
     if ((clen - off) > HTTP_DELETE_GAP) {
 	IOStats.Http.reads_deferred++;
-	debug(11, 3, "httpReadReply: Read deferred for Object: %s\n",
+	debug(11, 3) ("httpReadReply: Read deferred for Object: %s\n",
 	    entry->url);
-	debug(11, 3, "                Current Gap: %d bytes\n", clen - off);
+	debug(11, 3) ("                Current Gap: %d bytes\n", clen - off);
 	/* reschedule, so it will be automatically reactivated
 	 * when Gap is big enough. */
 	commSetSelect(fd,
@@ -561,7 +561,7 @@ httpReadReply(int fd, void *data)
     errno = 0;
     len = read(fd, buf, SQUID_TCP_SO_RCVBUF);
     fd_bytes(fd, len, FD_READ);
-    debug(11, 5, "httpReadReply: FD %d: len %d.\n", fd, len);
+    debug(11, 5) ("httpReadReply: FD %d: len %d.\n", fd, len);
     if (len > 0) {
 	commSetTimeout(fd, Config.Timeout.read, NULL, NULL);
 	IOStats.Http.reads++;
@@ -581,7 +581,7 @@ httpReadReply(int fd, void *data)
 	    squid_error_entry(entry, ERR_READ_ERROR, xstrerror());
 	    comm_close(fd);
 	}
-	debug(50, 2, "httpReadReply: FD %d: read failure: %s.\n",
+	debug(50, 2) ("httpReadReply: FD %d: read failure: %s.\n",
 	    fd, xstrerror());
     } else if (len == 0 && entry->mem_obj->e_current_len == 0) {
 	httpState->eof = 1;
@@ -617,7 +617,7 @@ httpSendComplete(int fd, char *buf, int size, int errflag, void *data)
     StoreEntry *entry = NULL;
 
     entry = httpState->entry;
-    debug(11, 5, "httpSendComplete: FD %d: size %d: errflag %d.\n",
+    debug(11, 5) ("httpSendComplete: FD %d: size %d: errflag %d.\n",
 	fd, size, errflag);
 
     if (errflag) {
@@ -647,7 +647,7 @@ httpAppendRequestHeader(char *hdr, const char *line, size_t * sz, size_t max)
 	    return;
     }
     /* allowed header, explicitly known to be not dangerous */
-    debug(11, 5, "httpAppendRequestHeader: %s\n", line);
+    debug(11, 5) ("httpAppendRequestHeader: %s\n", line);
     strcpy(hdr + (*sz), line);
     strcat(hdr + (*sz), crlf);
     *sz = n;
@@ -679,7 +679,7 @@ httpBuildRequestHeader(request_t * request,
     char *hdr_in = orig_request->headers;
 
     assert(hdr_in != NULL);
-    debug(11, 3, "httpBuildRequestHeader: INPUT:\n%s\n", hdr_in);
+    debug(11, 3) ("httpBuildRequestHeader: INPUT:\n%s\n", hdr_in);
     xstrncpy(fwdbuf, "X-Forwarded-For: ", 4096);
     xstrncpy(viabuf, "Via: ", 4096);
     sprintf(ybuf, "%s %s HTTP/1.0",
@@ -699,7 +699,7 @@ httpBuildRequestHeader(request_t * request,
 	if (l > 4096)
 	    l = 4096;
 	xstrncpy(xbuf, t, l);
-	debug(11, 5, "httpBuildRequestHeader: %s\n", xbuf);
+	debug(11, 5) ("httpBuildRequestHeader: %s\n", xbuf);
 	if (strncasecmp(xbuf, "Proxy-Connection:", 17) == 0)
 	    continue;
 	if (strncasecmp(xbuf, "Connection:", 11) == 0)
@@ -761,7 +761,7 @@ httpBuildRequestHeader(request_t * request,
 	debug_trap("httpBuildRequestHeader: size mismatch");
 	len = l;
     }
-    debug(11, 3, "httpBuildRequestHeader: OUTPUT:\n%s\n", hdr_out);
+    debug(11, 3) ("httpBuildRequestHeader: OUTPUT:\n%s\n", hdr_out);
     return len;
 }
 
@@ -778,7 +778,7 @@ httpSendRequest(int fd, void *data)
     StoreEntry *entry = httpState->entry;
     int cfd;
 
-    debug(11, 5, "httpSendRequest: FD %d: httpState %p.\n", fd, httpState);
+    debug(11, 5) ("httpSendRequest: FD %d: httpState %p.\n", fd, httpState);
     buflen = strlen(req->urlpath);
     if (req->headers)
 	buflen += req->headers_sz + 1;
@@ -809,7 +809,7 @@ httpSendRequest(int fd, void *data)
 	buf,
 	buflen,
 	cfd);
-    debug(11, 6, "httpSendRequest: FD %d:\n%s\n", fd, buf);
+    debug(11, 6) ("httpSendRequest: FD %d:\n%s\n", fd, buf);
     comm_write(fd,
 	buf,
 	len,
@@ -828,7 +828,7 @@ proxyhttpStart(request_t * orig_request,
     HttpStateData *httpState;
     request_t *request;
     int fd;
-    debug(11, 3, "proxyhttpStart: \"%s %s\"\n",
+    debug(11, 3) ("proxyhttpStart: \"%s %s\"\n",
 	RequestMethodStr[orig_request->method], entry->url);
     if (e->options & NEIGHBOR_PROXY_ONLY)
 #if DONT_USE_VM
@@ -844,7 +844,7 @@ proxyhttpStart(request_t * orig_request,
 	COMM_NONBLOCKING,
 	entry->url);
     if (fd == COMM_ERROR) {
-	debug(11, 4, "proxyhttpStart: Failed because we're out of sockets.\n");
+	debug(11, 4) ("proxyhttpStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	return;
     }
@@ -880,7 +880,7 @@ httpConnectDone(int fd, int status, void *data)
     request_t *request = httpState->request;
     StoreEntry *entry = httpState->entry;
     if (status == COMM_ERR_DNS) {
-	debug(11, 4, "httpConnectDone: Unknown host: %s\n", request->host);
+	debug(11, 4) ("httpConnectDone: Unknown host: %s\n", request->host);
 	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	comm_close(fd);
     } else if (status != COMM_OK) {
@@ -902,7 +902,7 @@ httpStart(request_t * request, StoreEntry * entry)
 {
     int fd;
     HttpStateData *httpState;
-    debug(11, 3, "httpStart: \"%s %s\"\n",
+    debug(11, 3) ("httpStart: \"%s %s\"\n",
 	RequestMethodStr[request->method], entry->url);
     /* Create socket. */
     fd = comm_open(SOCK_STREAM,
@@ -912,7 +912,7 @@ httpStart(request_t * request, StoreEntry * entry)
 	COMM_NONBLOCKING,
 	entry->url);
     if (fd == COMM_ERROR) {
-	debug(11, 4, "httpStart: Failed because we're out of sockets.\n");
+	debug(11, 4) ("httpStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	return;
     }
@@ -956,6 +956,6 @@ static void
 httpAbort(void *data)
 {
     HttpStateData *httpState = data;
-    debug(11, 1, "httpAbort: %s\n", httpState->entry->url);
+    debug(11, 1) ("httpAbort: %s\n", httpState->entry->url);
     comm_close(httpState->fd);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: icmp.cc,v 1.36 1997/06/04 04:32:58 wessels Exp $
+ * $Id: icmp.cc,v 1.37 1997/06/04 06:15:58 wessels Exp $
  *
  * DEBUG: section 37    ICMP Routines
  * AUTHOR: Duane Wessels
@@ -84,7 +84,7 @@ icmpRecv(int unused1, void *unused2)
 	sizeof(pingerReplyData),
 	0);
     if (n < 0) {
-	debug(50, 0, "icmpRecv: recv: %s\n", xstrerror());
+	debug(50, 0) ("icmpRecv: recv: %s\n", xstrerror());
 	if (++fail_count == 10 || errno == ECONNREFUSED)
 	    icmpClose();
 	return;
@@ -105,7 +105,7 @@ icmpRecv(int unused1, void *unused2)
 	netdbHandlePingReply(&F, preply.hops, preply.rtt);
 	break;
     default:
-	debug(37, 0, "icmpRecv: Bad opcode: %d\n", (int) preply.opcode);
+	debug(37, 0) ("icmpRecv: Bad opcode: %d\n", (int) preply.opcode);
 	break;
     }
 }
@@ -122,7 +122,7 @@ icmpQueueSend(pingerEchoData * pkt,
 	    free_func(pkt);
 	return;
     }
-    debug(37, 3, "icmpQueueSend: Queueing %d bytes\n", len);
+    debug(37, 3) ("icmpQueueSend: Queueing %d bytes\n", len);
     q = xcalloc(1, sizeof(icmpQueueData));
     q->msg = (char *) pkt;
     q->len = len;
@@ -145,13 +145,13 @@ icmpSend(int fd, void *data)
 	if (x < 0) {
 	    if (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR)
 		break;		/* don't de-queue */
-	    debug(50, 0, "icmpSend: send: %s\n", xstrerror());
+	    debug(50, 0) ("icmpSend: send: %s\n", xstrerror());
 	    if (errno == ECONNREFUSED) {
 		icmpClose();
 		return;
 	    }
 	} else if (x != queue->len) {
-	    debug(37, 0, "icmpSend: Wrote %d of %d bytes\n", x, queue->len);
+	    debug(37, 0) ("icmpSend: Wrote %d of %d bytes\n", x, queue->len);
 	}
 	IcmpQueueHead = queue->next;
 	if (queue->free_func)
@@ -180,7 +180,7 @@ icmpHandleSourcePing(const struct sockaddr_in *from, const char *buf)
     } else {
 	key = storeGeneratePublicKey(url, METHOD_GET);
     }
-    debug(37, 3, "icmpHandleSourcePing: from %s, key=%s\n",
+    debug(37, 3) ("icmpHandleSourcePing: from %s, key=%s\n",
 	inet_ntoa(from->sin_addr),
 	key);
     if ((entry = storeGet(key)) == NULL)
@@ -213,7 +213,7 @@ icmpSourcePing(struct in_addr to, const icp_common_t * header, const char *url)
     char *payload;
     int len;
     int ulen;
-    debug(37, 3, "icmpSourcePing: '%s'\n", url);
+    debug(37, 3) ("icmpSourcePing: '%s'\n", url);
     if ((ulen = strlen(url)) > MAX_URL)
 	return;
     payload = get_free_8k_page();
@@ -230,7 +230,7 @@ void
 icmpDomainPing(struct in_addr to, const char *domain)
 {
 #if USE_ICMP
-    debug(37, 3, "icmpDomainPing: '%s'\n", domain);
+    debug(37, 3) ("icmpDomainPing: '%s'\n", domain);
     icmpSendEcho(to, S_ICMP_DOM, domain, 0);
 #endif
 }
@@ -250,7 +250,7 @@ icmpOpen(void)
 	COMM_NONBLOCKING,
 	"Pinger Socket");
     if (icmp_sock < 0) {
-	debug(50, 0, "icmpOpen: icmp_sock: %s\n", xstrerror());
+	debug(50, 0) ("icmpOpen: icmp_sock: %s\n", xstrerror());
 	return;
     }
     child_sock = comm_open(SOCK_DGRAM,
@@ -260,7 +260,7 @@ icmpOpen(void)
 	0,
 	"ICMP Socket");
     if (child_sock < 0) {
-	debug(50, 0, "icmpOpen: child_sock: %s\n", xstrerror());
+	debug(50, 0) ("icmpOpen: child_sock: %s\n", xstrerror());
 	return;
     }
     getsockname(icmp_sock, (struct sockaddr *) &S, &namelen);
@@ -270,7 +270,7 @@ icmpOpen(void)
     if (comm_connect_addr(icmp_sock, &S) != COMM_OK)
 	fatal_dump(xstrerror());
     if ((pid = fork()) < 0) {
-	debug(50, 0, "icmpOpen: fork: %s\n", xstrerror());
+	debug(50, 0) ("icmpOpen: fork: %s\n", xstrerror());
 	comm_close(icmp_sock);
 	comm_close(child_sock);
 	return;
@@ -287,13 +287,13 @@ icmpOpen(void)
 	fclose(debug_log);
 	enter_suid();
 	execlp(Config.Program.pinger, "(pinger)", NULL);
-	debug(50, 0, "icmpOpen: %s: %s\n", Config.Program.pinger, xstrerror());
+	debug(50, 0) ("icmpOpen: %s: %s\n", Config.Program.pinger, xstrerror());
 	_exit(1);
     }
     comm_close(child_sock);
     commSetSelect(icmp_sock, COMM_SELECT_READ, icmpRecv, NULL, 0);
     commSetTimeout(icmp_sock, -1, NULL, NULL);
-    debug(29, 0, "Pinger socket opened on FD %d\n", icmp_sock);
+    debug(29, 0) ("Pinger socket opened on FD %d\n", icmp_sock);
 #endif
 }
 
@@ -304,7 +304,7 @@ icmpClose(void)
     icmpQueueData *queue;
     if (icmp_sock < 0)
 	return;
-    debug(29, 0, "Closing ICMP socket on FD %d\n", icmp_sock);
+    debug(29, 0) ("Closing ICMP socket on FD %d\n", icmp_sock);
     comm_close(icmp_sock);
     commSetSelect(icmp_sock, COMM_SELECT_READ, NULL, NULL, 0);
     commSetSelect(icmp_sock, COMM_SELECT_WRITE, NULL, NULL, 0);
@@ -1,5 +1,5 @@
 /*
- * $Id: ident.cc,v 1.29 1997/05/08 07:22:05 wessels Exp $
+ * $Id: ident.cc,v 1.30 1997/06/04 06:16:00 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -102,7 +102,7 @@ identConnectDone(int fd, int status, void *data)
 static void
 identRequestComplete(int fd, char *buf, int size, int errflag, void *data)
 {
-    debug(30, 5, "identRequestComplete: FD %d: wrote %d bytes\n", fd, size);
+    debug(30, 5) ("identRequestComplete: FD %d: wrote %d bytes\n", fd, size);
 }
 
 static void
@@ -121,7 +121,7 @@ identReadReply(int fd, void *data)
 	    *t = '\0';
 	if ((t = strchr(buf, '\n')))
 	    *t = '\0';
-	debug(30, 5, "identReadReply: FD %d: Read '%s'\n", fd, buf);
+	debug(30, 5) ("identReadReply: FD %d: Read '%s'\n", fd, buf);
 	if (strstr(buf, "USERID")) {
 	    if ((t = strrchr(buf, ':'))) {
 		while (isspace(*++t));
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.119 1997/06/01 23:22:23 wessels Exp $
+ * $Id: ipcache.cc,v 1.120 1997/06/04 06:16:01 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -193,11 +193,11 @@ ipcacheEnqueue(ipcache_entry * i)
     if (squid_curtime - last_warning < 600)
 	return;
     last_warning = squid_curtime;
-    debug(14, 1, "ipcacheEnqueue: WARNING: All dnsservers are busy.\n");
-    debug(14, 1, "ipcacheEnqueue: WARNING: %d DNS lookups queued\n", queue_length);
+    debug(14, 1) ("ipcacheEnqueue: WARNING: All dnsservers are busy.\n");
+    debug(14, 1) ("ipcacheEnqueue: WARNING: %d DNS lookups queued\n", queue_length);
     if (Config.dnsChildren >= DefaultDnsChildrenMax)
 	return;
-    debug(14, 1, "ipcacheEnqueue: Consider increasing 'dns_children' in your config file.\n");
+    debug(14, 1) ("ipcacheEnqueue: Consider increasing 'dns_children' in your config file.\n");
 }
 
 static void *
@@ -223,7 +223,7 @@ static int
 ipcache_testname(void)
 {
     wordlist *w = NULL;
-    debug(14, 1, "Performing DNS Tests...\n");
+    debug(14, 1) ("Performing DNS Tests...\n");
     if ((w = Config.dns_testname_list) == NULL)
 	return 1;
     for (; w; w = w->next) {
@@ -241,7 +241,7 @@ ipcache_release(ipcache_entry * i)
     hash_link *table_entry = NULL;
 
     if ((table_entry = hash_lookup(ip_table, i->name)) == NULL) {
-	debug(14, 0, "ipcache_release: Could not find key '%s'\n", i->name);
+	debug(14, 0) ("ipcache_release: Could not find key '%s'\n", i->name);
 	return;
     }
     if (i != (ipcache_entry *) table_entry)
@@ -253,13 +253,13 @@ ipcache_release(ipcache_entry * i)
 	return;
     }
     if (hash_remove_link(ip_table, table_entry)) {
-	debug(14, 0, "ipcache_release: hash_remove_link() failed for '%s'\n",
+	debug(14, 0) ("ipcache_release: hash_remove_link() failed for '%s'\n",
 	    i->name);
 	return;
     }
     if (i->status == IP_CACHED) {
 	safe_free(i->addrs.in_addrs);
-	debug(14, 5, "ipcache_release: Released IP cached record for '%s'.\n",
+	debug(14, 5) ("ipcache_release: Released IP cached record for '%s'.\n",
 	    i->name);
     }
     safe_free(i->name);
@@ -381,7 +381,7 @@ ipcache_purgelru(void *unused)
     }
     if (meta_data.ipcache_count > ipcache_low)
 	debug_trap("ipcache_purgelru: Couldn't reach the low water mark");
-    debug(14, 3, "ipcache_purgelru: removed %d entries\n", removed);
+    debug(14, 3) ("ipcache_purgelru: removed %d entries\n", removed);
     safe_free(LRU_list);
 }
 
@@ -405,10 +405,10 @@ static void
 ipcache_add_to_hash(ipcache_entry * i)
 {
     if (hash_join(ip_table, (hash_link *) i)) {
-	debug(14, 1, "ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
+	debug(14, 1) ("ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
 	    i->name, i, ip_table);
     }
-    debug(14, 5, "ipcache_add_to_hash: name <%s>\n", i->name);
+    debug(14, 5) ("ipcache_add_to_hash: name <%s>\n", i->name);
 }
 
 static void
@@ -433,7 +433,7 @@ ipcacheAddNew(const char *name, const struct hostent *hp, ipcache_status_t statu
     ipcache_entry *i;
     if (ipcache_get(name))
 	fatal_dump("ipcacheAddNew: somebody adding a duplicate!");
-    debug(14, 10, "ipcacheAddNew: Adding '%s', status=%c\n",
+    debug(14, 10) ("ipcacheAddNew: Adding '%s', status=%c\n",
 	name,
 	ipcache_status_char[status]);
     i = ipcache_create(name);
@@ -467,7 +467,7 @@ ipcache_call_pending(ipcache_entry * i)
 	safe_free(p);
     }
     i->pending_head = NULL;	/* nuke list */
-    debug(14, 10, "ipcache_call_pending: Called %d handlers.\n", nhandler);
+    debug(14, 10) ("ipcache_call_pending: Called %d handlers.\n", nhandler);
     ipcacheUnlockEntry(i);
 }
 
@@ -480,7 +480,7 @@ ipcache_parsebuffer(const char *inbuf, dnsserver_t * dnsData)
     int k;
     int ipcount;
     int aliascount;
-    debug(14, 5, "ipcache_parsebuffer: parsing:\n%s", inbuf);
+    debug(14, 5) ("ipcache_parsebuffer: parsing:\n%s", inbuf);
     memset(&i, '\0', sizeof(ipcache_entry));
     i.expires = squid_curtime + Config.positiveDnsTtl;
     for (token = strtok(buf, w_space); token; token = strtok(NULL, w_space)) {
@@ -538,7 +538,7 @@ ipcache_parsebuffer(const char *inbuf, dnsserver_t * dnsData)
 		fatal_dump("Invalid $ttl");
 	    i.expires = squid_curtime + atoi(token);
 	} else {
-	    debug(14, 0, "--> %s <--\n", inbuf);
+	    debug(14, 0) ("--> %s <--\n", inbuf);
 	    debug_trap("Invalid dnsserver output");
 	}
     }
@@ -568,7 +568,7 @@ ipcache_dnsHandleRead(int fd, void *data)
 	dnsData->ip_inbuf + dnsData->offset,
 	dnsData->size - dnsData->offset);
     fd_bytes(fd, len, FD_READ);
-    debug(14, 5, "ipcache_dnsHandleRead: Result from DNS ID %d (%d bytes)\n",
+    debug(14, 5) ("ipcache_dnsHandleRead: Result from DNS ID %d (%d bytes)\n",
 	dnsData->id, len);
     if (len <= 0) {
 	if (len < 0 && (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR)) {
@@ -579,8 +579,8 @@ ipcache_dnsHandleRead(int fd, void *data)
 		0);
 	    return;
 	}
-	debug(14, dnsData->flags & DNS_FLAG_CLOSING ? 5 : 1,
-	    "FD %d: Connection from DNSSERVER #%d is closed, disabling\n",
+	debug(14, dnsData->flags & DNS_FLAG_CLOSING ? 5 : 1)
+	    ("FD %d: Connection from DNSSERVER #%d is closed, disabling\n",
 	    fd, dnsData->id);
 	dnsData->flags = 0;
 	commSetSelect(fd,
@@ -603,7 +603,7 @@ ipcache_dnsHandleRead(int fd, void *data)
 	    tvSubMsec(dnsData->dispatch_time, current_time),
 	    n, IPCACHE_AV_FACTOR);
 	if ((x = ipcache_parsebuffer(dnsData->ip_inbuf, dnsData)) == NULL) {
-	    debug(14, 0, "ipcache_dnsHandleRead: ipcache_parsebuffer failed?!\n");
+	    debug(14, 0) ("ipcache_dnsHandleRead: ipcache_parsebuffer failed?!\n");
 	} else {
 	    dnsData->offset = 0;
 	    dnsData->ip_inbuf[0] = '\0';
@@ -615,7 +615,7 @@ ipcache_dnsHandleRead(int fd, void *data)
 	}
 	ipcacheUnlockEntry(i);	/* unlock from IP_DISPATCHED */
     } else {
-	debug(14, 5, "ipcache_dnsHandleRead: Incomplete reply\n");
+	debug(14, 5) ("ipcache_dnsHandleRead: Incomplete reply\n");
 	commSetSelect(fd,
 	    COMM_SELECT_READ,
 	    ipcache_dnsHandleRead,
@@ -654,11 +654,11 @@ ipcache_nbgethostbyname(const char *name, int fd, IPH * handler, void *handlerDa
     if (!handler)
 	fatal_dump("ipcache_nbgethostbyname: NULL handler");
 
-    debug(14, 4, "ipcache_nbgethostbyname: FD %d: Name '%s'.\n", fd, name);
+    debug(14, 4) ("ipcache_nbgethostbyname: FD %d: Name '%s'.\n", fd, name);
     IpcacheStats.requests++;
 
     if (name == NULL || name[0] == '\0') {
-	debug(14, 4, "ipcache_nbgethostbyname: Invalid name!\n");
+	debug(14, 4) ("ipcache_nbgethostbyname: Invalid name!\n");
 	handler(fd, NULL, handlerData);
 	return;
     }
@@ -674,13 +674,13 @@ ipcache_nbgethostbyname(const char *name, int fd, IPH * handler, void *handlerDa
     }
     if (i == NULL) {
 	/* MISS: No entry, create the new one */
-	debug(14, 5, "ipcache_nbgethostbyname: MISS for '%s'\n", name);
+	debug(14, 5) ("ipcache_nbgethostbyname: MISS for '%s'\n", name);
 	IpcacheStats.misses++;
 	i = ipcacheAddNew(name, NULL, IP_PENDING);
 	ipcacheAddPending(i, fd, handler, handlerData);
     } else if (i->status == IP_CACHED || i->status == IP_NEGATIVE_CACHED) {
 	/* HIT */
-	debug(14, 4, "ipcache_nbgethostbyname: HIT for '%s'\n", name);
+	debug(14, 4) ("ipcache_nbgethostbyname: HIT for '%s'\n", name);
 	if (i->status == IP_NEGATIVE_CACHED)
 	    IpcacheStats.negative_hits++;
 	else
@@ -689,11 +689,11 @@ ipcache_nbgethostbyname(const char *name, int fd, IPH * handler, void *handlerDa
 	ipcache_call_pending(i);
 	return;
     } else if (i->status == IP_PENDING || i->status == IP_DISPATCHED) {
-	debug(14, 4, "ipcache_nbgethostbyname: PENDING for '%s'\n", name);
+	debug(14, 4) ("ipcache_nbgethostbyname: PENDING for '%s'\n", name);
 	IpcacheStats.pending_hits++;
 	ipcacheAddPending(i, fd, handler, handlerData);
 	if (squid_curtime - i->expires > 600) {
-	    debug(14, 0, "ipcache_nbgethostbyname: '%s' PENDING for %d seconds, aborting\n", name, squid_curtime + Config.negativeDnsTtl - i->expires);
+	    debug(14, 0) ("ipcache_nbgethostbyname: '%s' PENDING for %d seconds, aborting\n", name, squid_curtime + Config.negativeDnsTtl - i->expires);
 	    ipcacheChangeKey(i);
 	    ipcache_call_pending(i);
 	}
@@ -723,7 +723,7 @@ ipcache_dnsDispatch(dnsserver_t * dns, ipcache_entry * i)
     if (!BIT_TEST(dns->flags, DNS_FLAG_ALIVE))
 	debug_trap("Dispatching a dead DNS server");
     if (!ipcacheHasPending(i)) {
-	debug(14, 0, "Skipping lookup of '%s' because client(s) disappeared.\n",
+	debug(14, 0) ("Skipping lookup of '%s' because client(s) disappeared.\n",
 	    i->name);
 	i->status = IP_NEGATIVE_CACHED;
 	ipcache_release(i);
@@ -746,7 +746,7 @@ ipcache_dnsDispatch(dnsserver_t * dns, ipcache_entry * i)
 	COMM_SELECT_READ,
 	ipcache_dnsHandleRead,
 	dns, 0);
-    debug(14, 5, "ipcache_dnsDispatch: Request sent to DNS server #%d.\n",
+    debug(14, 5) ("ipcache_dnsDispatch: Request sent to DNS server #%d.\n",
 	dns->id);
     dns->dispatch_time = current_time;
     DnsStats.requests++;
@@ -759,17 +759,17 @@ ipcache_dnsDispatch(dnsserver_t * dns, ipcache_entry * i)
 void
 ipcache_init(void)
 {
-    debug(14, 3, "Initializing IP Cache...\n");
+    debug(14, 3) ("Initializing IP Cache...\n");
 
     memset(&IpcacheStats, '\0', sizeof(IpcacheStats));
 
     /* test naming lookup */
     if (!opt_dns_tests) {
-	debug(14, 4, "ipcache_init: Skipping DNS name lookup tests.\n");
+	debug(14, 4) ("ipcache_init: Skipping DNS name lookup tests.\n");
     } else if (!ipcache_testname()) {
 	fatal("ipcache_init: DNS name lookup tests failed.");
     } else {
-	debug(14, 1, "Successful DNS name lookup tests...\n");
+	debug(14, 1) ("Successful DNS name lookup tests...\n");
     }
 
     ip_table = hash_create(urlcmp, 229, hash4);		/* small hash table */
@@ -790,7 +790,7 @@ ipcacheUnregister(const char *name, void *data)
     ipcache_entry *i = NULL;
     struct _ip_pending *p = NULL;
     int n = 0;
-    debug(14, 3, "ipcacheUnregister: FD %d, name '%s'\n", name);
+    debug(14, 3) ("ipcacheUnregister: FD %d, name '%s'\n", name);
     if ((i = ipcache_get(name)) == NULL)
 	return 0;
     if (i->status == IP_PENDING || i->status == IP_DISPATCHED) {
@@ -804,7 +804,7 @@ ipcacheUnregister(const char *name, void *data)
     }
     if (n == 0)
 	debug_trap("ipcacheUnregister: callback data not found");
-    debug(14, 3, "ipcacheUnregister: unregistered %d handlers\n", n);
+    debug(14, 3) ("ipcacheUnregister: unregistered %d handlers\n", n);
     return n;
 }
 
@@ -817,7 +817,7 @@ ipcache_gethostbyname(const char *name, int flags)
 
     if (!name)
 	fatal_dump("ipcache_gethostbyname: NULL name");
-    debug(14, 3, "ipcache_gethostbyname: '%s', flags=%x\n", name, flags);
+    debug(14, 3) ("ipcache_gethostbyname: '%s', flags=%x\n", name, flags);
     IpcacheStats.requests++;
     if ((i = ipcache_get(name))) {
 	if (ipcacheExpiredEntry(i)) {
@@ -846,7 +846,7 @@ ipcache_gethostbyname(const char *name, int flags)
     IpcacheStats.misses++;
     if (BIT_TEST(flags, IP_BLOCKING_LOOKUP)) {
 	if (NDnsServersAlloc)
-	    debug(14, 0, "WARNING: blocking on gethostbyname() for '%s'\n", name);
+	    debug(14, 0) ("WARNING: blocking on gethostbyname() for '%s'\n", name);
 	IpcacheStats.ghbn_calls++;
 	hp = gethostbyname(name);
 	if (hp && hp->h_name && (hp->h_name[0] != '\0') && ip_table) {
@@ -1104,7 +1104,7 @@ ipcacheChangeKey(ipcache_entry * i)
     LOCAL_ARRAY(char, new_key, 256);
     hash_link *table_entry = hash_lookup(ip_table, i->name);
     if (table_entry == NULL) {
-	debug(14, 0, "ipcacheChangeKey: Could not find key '%s'\n", i->name);
+	debug(14, 0) ("ipcacheChangeKey: Could not find key '%s'\n", i->name);
 	return;
     }
     if (i != (ipcache_entry *) table_entry) {
@@ -1117,7 +1117,7 @@ ipcacheChangeKey(ipcache_entry * i)
     }
     sprintf(new_key, "%d/", ++index);
     strncat(new_key, i->name, 128);
-    debug(14, 1, "ipcacheChangeKey: from '%s' to '%s'\n", i->name, new_key);
+    debug(14, 1) ("ipcacheChangeKey: from '%s' to '%s'\n", i->name, new_key);
     safe_free(i->name);
     i->name = xstrdup(new_key);
     ipcache_add_to_hash(i);
@@ -1,5 +1,5 @@
 /*
- * $Id: main.cc,v 1.150 1997/06/01 23:22:25 wessels Exp $
+ * $Id: main.cc,v 1.151 1997/06/04 06:16:01 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -297,7 +297,7 @@ mainParseOptions(int argc, char *argv[])
 static void
 rotate_logs(int sig)
 {
-    debug(1, 1, "rotate_logs: SIGUSR1 received.\n");
+    debug(1, 1) ("rotate_logs: SIGUSR1 received.\n");
     rotate_pending = 1;
 #if !HAVE_SIGACTION
     signal(sig, rotate_logs);
@@ -317,12 +317,12 @@ void
 shut_down(int sig)
 {
     shutdown_pending = sig == SIGINT ? -1 : 1;
-    debug(1, 1, "Preparing for shutdown after %d connections\n",
+    debug(1, 1) ("Preparing for shutdown after %d connections\n",
 	ntcpconn + nudpconn);
-    debug(1, 1, "Waiting %d seconds for active connections to finish\n",
+    debug(1, 1) ("Waiting %d seconds for active connections to finish\n",
 	shutdown_pending > 0 ? Config.shutdownLifetime : 0);
 #ifdef KILL_PARENT_OPT
-    debug(1, 1, "Killing RunCache, pid %d\n", getppid());
+    debug(1, 1) ("Killing RunCache, pid %d\n", getppid());
     kill(getppid(), sig);
 #endif
 #if SA_RESETHAND == 0
@@ -354,7 +354,7 @@ serverConnectionsOpen(void)
 	    continue;
 	comm_listen(fd);
 	commSetSelect(fd, COMM_SELECT_READ, httpAccept, NULL, 0);
-	debug(1, 1, "Accepting HTTP connections on port %d, FD %d.\n",
+	debug(1, 1) ("Accepting HTTP connections on port %d, FD %d.\n",
 	    (int) Config.Port.http[x], fd);
 	HttpSockets[NHttpSockets++] = fd;
     }
@@ -382,7 +382,7 @@ serverConnectionsOpen(void)
 		    theInIcpConnection,
 		    comm_join_mcast_groups,
 		    NULL);
-	    debug(1, 1, "Accepting ICP connections on port %d, FD %d.\n",
+	    debug(1, 1) ("Accepting ICP connections on port %d, FD %d.\n",
 		(int) port, theInIcpConnection);
 
 	    if ((addr = Config.Addrs.udp_outgoing).s_addr != no_addr.s_addr) {
@@ -400,7 +400,7 @@ serverConnectionsOpen(void)
 		    COMM_SELECT_READ,
 		    icpHandleUdp,
 		    NULL, 0);
-		debug(1, 1, "Accepting ICP connections on port %d, FD %d.\n",
+		debug(1, 1) ("Accepting ICP connections on port %d, FD %d.\n",
 		    (int) port, theInIcpConnection);
 		fd_note(theOutIcpConnection, "Outgoing ICP socket");
 		fd_note(theInIcpConnection, "Incoming ICP socket");
@@ -413,7 +413,7 @@ serverConnectionsOpen(void)
 	    x = getsockname(theOutIcpConnection,
 		(struct sockaddr *) &xaddr, &len);
 	    if (x < 0)
-		debug(50, 1, "theOutIcpConnection FD %d: getsockname: %s\n",
+		debug(50, 1) ("theOutIcpConnection FD %d: getsockname: %s\n",
 		    theOutIcpConnection, xstrerror());
 	    else
 		theOutICPAddr = xaddr.sin_addr;
@@ -441,23 +441,23 @@ serverConnectionsOpen(void)
 		(char *) &mr,
 		sizeof(struct ip_mreq));
 	    if (x < 0)
-		debug(50, 1, "IP_ADD_MEMBERSHIP: FD %d, addr %s: %s\n",
+		debug(50, 1) ("IP_ADD_MEMBERSHIP: FD %d, addr %s: %s\n",
 		    vizSock, inet_ntoa(Config.vizHack.addr), xstrerror());
 	    x = setsockopt(vizSock,
 		IPPROTO_IP,
 		IP_MULTICAST_TTL,
 		&ttl,
 		sizeof(char));
 	    if (x < 0)
-		debug(50, 1, "IP_MULTICAST_TTL: FD %d, TTL %d: %s\n",
+		debug(50, 1) ("IP_MULTICAST_TTL: FD %d, TTL %d: %s\n",
 		    vizSock, Config.vizHack.mcast_ttl, xstrerror());
 	    ttl = 0;
 	    x = sizeof(char);
 	    getsockopt(vizSock, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, &x);
-	    debug(1, 0, "vizSock on FD %d, ttl=%d\n", vizSock, (int) ttl);
+	    debug(1, 0) ("vizSock on FD %d, ttl=%d\n", vizSock, (int) ttl);
 	}
 #else
-	debug(1, 0, "vizSock: Could not join multicast group\n");
+	debug(1, 0) ("vizSock: Could not join multicast group\n");
 #endif
 	memset(&Config.vizHack.S, '\0', sizeof(struct sockaddr_in));
 	Config.vizHack.S.sin_family = AF_INET;
@@ -478,7 +478,7 @@ serverConnectionsClose(void)
     int i;
     for (i = 0; i < NHttpSockets; i++) {
 	if (HttpSockets[i] >= 0) {
-	    debug(1, 1, "FD %d Closing HTTP connection\n", HttpSockets[i]);
+	    debug(1, 1) ("FD %d Closing HTTP connection\n", HttpSockets[i]);
 	    comm_close(HttpSockets[i]);
 	    HttpSockets[i] = -1;
 	}
@@ -487,7 +487,7 @@ serverConnectionsClose(void)
     if (theInIcpConnection >= 0) {
 	/* NOTE, don't close outgoing ICP connection, we need to write to
 	 * it during shutdown */
-	debug(1, 1, "FD %d Closing ICP connection\n",
+	debug(1, 1) ("FD %d Closing ICP connection\n",
 	    theInIcpConnection);
 	if (theInIcpConnection != theOutIcpConnection)
 	    comm_close(theInIcpConnection);
@@ -509,7 +509,7 @@ serverConnectionsClose(void)
 static void
 mainReconfigure(void)
 {
-    debug(1, 0, "Restarting Squid Cache (version %s)...\n", version_string);
+    debug(1, 0) ("Restarting Squid Cache (version %s)...\n", version_string);
     /* Already called serverConnectionsClose and ipcacheShutdownServers() */
     neighborsDestroy();
     parseConfigFile(ConfigFile);
@@ -521,7 +521,7 @@ mainReconfigure(void)
     serverConnectionsOpen();
     if (theOutIcpConnection >= 0 && (!httpd_accel_mode || Config.Accel.withProxy))
 	neighbors_open(theOutIcpConnection);
-    debug(1, 0, "Ready to serve requests.\n");
+    debug(1, 0) ("Ready to serve requests.\n");
 }
 
 static void
@@ -540,10 +540,10 @@ mainInitialize(void)
 
     leave_suid();		/* Run as non privilegied user */
     if (geteuid() == 0) {
-	debug(0, 0, "Squid is not safe to run as root!  If you must\n");
-	debug(0, 0, "start Squid as root, then you must configure\n");
-	debug(0, 0, "it to run as a non-priveledged user with the\n");
-	debug(0, 0, "'cache_effective_user' option in the config file.\n");
+	debug(0, 0) ("Squid is not safe to run as root!  If you must\n");
+	debug(0, 0) ("start Squid as root, then you must configure\n");
+	debug(0, 0) ("it to run as a non-priveledged user with the\n");
+	debug(0, 0) ("'cache_effective_user' option in the config file.\n");
 	fatal("Don't run Squid as root, set 'cache_effective_user'!");
     }
     if (httpPortNumOverride != 1)
@@ -554,10 +554,10 @@ mainInitialize(void)
     _db_init(Config.Log.log, Config.debugOptions);
     fd_open(fileno(debug_log), FD_LOG, Config.Log.log);
 
-    debug(1, 0, "Starting Squid Cache version %s for %s...\n",
+    debug(1, 0) ("Starting Squid Cache version %s for %s...\n",
 	version_string,
 	CONFIG_HOST_TYPE);
-    debug(1, 1, "With %d file descriptors available\n", Squid_MaxFD);
+    debug(1, 1) ("With %d file descriptors available\n", Squid_MaxFD);
 
     if (!configured_once) {
 	stmemInit();		/* stmem must go before at least redirect */
@@ -585,7 +585,7 @@ mainInitialize(void)
 	    /* we were probably started as root, so cd to a swap
 	     * directory in case we dump core */
 	    if (chdir(storeSwapDir(0)) < 0) {
-		debug(50, 0, "%s: %s\n", storeSwapDir(0), xstrerror());
+		debug(50, 0) ("%s: %s\n", storeSwapDir(0), xstrerror());
 		fatal_dump("Cannot cd to swap directory?");
 	    }
 	}
@@ -605,7 +605,7 @@ mainInitialize(void)
     squid_signal(SIGHUP, reconfigure, SA_RESTART);
     squid_signal(SIGTERM, shut_down, SA_NODEFER | SA_RESETHAND | SA_RESTART);
     squid_signal(SIGINT, shut_down, SA_NODEFER | SA_RESETHAND | SA_RESTART);
-    debug(1, 0, "Ready to serve requests.\n");
+    debug(1, 0) ("Ready to serve requests.\n");
 
     if (!configured_once) {
 	eventAdd("storePurgeOld", storePurgeOld, NULL, Config.cleanRate);
@@ -717,7 +717,7 @@ main(int argc, char **argv)
 	    break;
 	case COMM_ERROR:
 	    errcount++;
-	    debug(1, 0, "Select loop Error. Retry %d\n", errcount);
+	    debug(1, 0) ("Select loop Error. Retry %d\n", errcount);
 	    if (errcount == 10)
 		fatal_dump("Select Loop failed!");
 	    break;
@@ -1,5 +1,5 @@
 /*
- * $Id: mime.cc,v 1.29 1997/05/15 01:18:46 wessels Exp $
+ * $Id: mime.cc,v 1.30 1997/06/04 06:16:02 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -133,7 +133,7 @@ mime_get_header(const char *mime, const char *name)
     if (!mime || !name)
 	return NULL;
 
-    debug(25, 5, "mime_get_header: looking for '%s'\n", name);
+    debug(25, 5) ("mime_get_header: looking for '%s'\n", name);
 
     for (p = mime; *p; p += strcspn(p, "\n\r")) {
 	if (strcmp(p, "\r\n\r\n") == 0 || strcmp(p, "\n\n") == 0)
@@ -148,15 +148,15 @@ mime_get_header(const char *mime, const char *name)
 	if (l > GET_HDR_SZ)
 	    l = GET_HDR_SZ;
 	xstrncpy(header, p, l);
-	debug(25, 5, "mime_get_header: checking '%s'\n", header);
+	debug(25, 5) ("mime_get_header: checking '%s'\n", header);
 	q = header;
 	q += namelen;
 	if (*q == ':')
 	    q++, got = 1;
 	while (isspace(*q))
 	    q++, got = 1;
 	if (got) {
-	    debug(25, 5, "mime_get_header: returning '%s'\n", q);
+	    debug(25, 5) ("mime_get_header: returning '%s'\n", q);
 	    return q;
 	}
     }
@@ -317,7 +317,7 @@ mimeInit(char *filename)
     if (filename == NULL)
 	return;
     if ((fp = fopen(filename, "r")) == NULL) {
-	debug(50, 1, "mimeInit: %s: %s\n", filename, xstrerror());
+	debug(50, 1) ("mimeInit: %s: %s\n", filename, xstrerror());
 	return;
     }
     if (MimeTableTail == NULL)
@@ -329,27 +329,27 @@ mimeInit(char *filename)
 	    continue;
 	xstrncpy(chopbuf, buf, BUFSIZ);
 	if ((pattern = strtok(chopbuf, w_space)) == NULL) {
-	    debug(25, 1, "mimeInit: parse error: '%s'\n", buf);
+	    debug(25, 1) ("mimeInit: parse error: '%s'\n", buf);
 	    continue;
 	}
 	if ((type = strtok(NULL, w_space)) == NULL) {
-	    debug(25, 1, "mimeInit: parse error: '%s'\n", buf);
+	    debug(25, 1) ("mimeInit: parse error: '%s'\n", buf);
 	    continue;
 	}
 	if ((icon = strtok(NULL, w_space)) == NULL) {
-	    debug(25, 1, "mimeInit: parse error: '%s'\n", buf);
+	    debug(25, 1) ("mimeInit: parse error: '%s'\n", buf);
 	    continue;
 	}
 	if ((encoding = strtok(NULL, w_space)) == NULL) {
-	    debug(25, 1, "mimeInit: parse error: '%s'\n", buf);
+	    debug(25, 1) ("mimeInit: parse error: '%s'\n", buf);
 	    continue;
 	}
 	if ((mode = strtok(NULL, w_space)) == NULL) {
-	    debug(25, 1, "mimeInit: parse error: '%s'\n", buf);
+	    debug(25, 1) ("mimeInit: parse error: '%s'\n", buf);
 	    continue;
 	}
 	if (regcomp(&re, pattern, re_flags) != 0) {
-	    debug(25, 1, "mimeInit: regcomp error: '%s'\n", buf);
+	    debug(25, 1) ("mimeInit: regcomp error: '%s'\n", buf);
 	    continue;
 	}
 	m = xcalloc(1, sizeof(mimeEntry));
@@ -364,7 +364,7 @@ mimeInit(char *filename)
 	    m->transfer_mode = 'A';
 	else
 	    m->transfer_mode = 'I';
-	debug(25, 5, "mimeInit: added '%s'\n", buf);
+	debug(25, 5) ("mimeInit: added '%s'\n", buf);
 	*MimeTableTail = m;
 	MimeTableTail = &m->next;
     }
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.142 1997/06/01 23:23:46 wessels Exp $
+ * $Id: neighbors.cc,v 1.143 1997/06/04 06:16:03 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -160,7 +160,7 @@ whichPeer(const struct sockaddr_in *from)
     u_short port = ntohs(from->sin_port);
     struct in_addr ip = from->sin_addr;
     peer *p = NULL;
-    debug(15, 3, "whichPeer: from %s port %d\n", inet_ntoa(ip), port);
+    debug(15, 3) ("whichPeer: from %s port %d\n", inet_ntoa(ip), port);
     for (p = Peers.peers_head; p; p = p->next) {
 	for (j = 0; j < p->n_addresses; j++) {
 	    if (ip.s_addr == p->addresses[j].s_addr && port == p->icp_port) {
@@ -279,7 +279,7 @@ neighborsCount(request_t * request)
     for (p = Peers.peers_head; p; p = p->next)
 	if (peerWouldBePinged(p, request))
 	    count++;
-    debug(15, 3, "neighborsCount: %d\n", count);
+    debug(15, 3) ("neighborsCount: %d\n", count);
     return count;
 }
 
@@ -297,7 +297,7 @@ getSingleParent(request_t * request)
 	    return NULL;	/* oops, found second parent */
 	p = q;
     }
-    debug(15, 3, "getSingleParent: returning %s\n", p ? p->host : "NULL");
+    debug(15, 3) ("getSingleParent: returning %s\n", p ? p->host : "NULL");
     return p;
 }
 
@@ -314,7 +314,7 @@ getFirstUpParent(request_t * request)
 	    continue;
 	break;
     }
-    debug(15, 3, "getFirstUpParent: returning %s\n", p ? p->host : "NULL");
+    debug(15, 3) ("getFirstUpParent: returning %s\n", p ? p->host : "NULL");
     return p;
 }
 
@@ -336,7 +336,7 @@ getRoundRobinParent(request_t * request)
     }
     if (q)
 	q->rr_count++;
-    debug(15, 3, "getRoundRobinParent: returning %s\n", q ? q->host : "NULL");
+    debug(15, 3) ("getRoundRobinParent: returning %s\n", q ? q->host : "NULL");
     return q;
 }
 
@@ -351,7 +351,7 @@ getDefaultParent(request_t * request)
 	    continue;
 	if (!peerHTTPOkay(p, request))
 	    continue;
-	debug(15, 3, "getDefaultParent: returning %s\n", p->host);
+	debug(15, 3) ("getDefaultParent: returning %s\n", p->host);
 	return p;
     }
     return NULL;
@@ -398,7 +398,7 @@ neighborsDestroy(void)
     peer *p = NULL;
     peer *next = NULL;
 
-    debug(15, 3, "neighborsDestroy: called\n");
+    debug(15, 3) ("neighborsDestroy: called\n");
 
     for (p = Peers.peers_head; p; p = next) {
 	next = p->next;
@@ -420,7 +420,7 @@ neighbors_open(int fd)
     struct servent *sep = NULL;
     memset(&name, '\0', sizeof(struct sockaddr_in));
     if (getsockname(fd, (struct sockaddr *) &name, &len) < 0)
-	debug(15, 1, "getsockname(%d,%p,%p) failed.\n", fd, &name, &len);
+	debug(15, 1) ("getsockname(%d,%p,%p) failed.\n", fd, &name, &len);
     peerRefreshDNS(NULL);
     if (0 == echo_hdr.opcode) {
 	echo_hdr.opcode = ICP_OP_SECHO;
@@ -459,9 +459,9 @@ neighborsUdpPing(request_t * request,
     if (Peers.peers_head == NULL)
 	return 0;
     if (theOutIcpConnection < 0) {
-	debug(15, 0, "neighborsUdpPing: There is no ICP socket!\n");
-	debug(15, 0, "Cannot query neighbors for '%s'.\n", url);
-	debug(15, 0, "Check 'icp_port' in your config file\n");
+	debug(15, 0) ("neighborsUdpPing: There is no ICP socket!\n");
+	debug(15, 0) ("Cannot query neighbors for '%s'.\n", url);
+	debug(15, 0) ("Check 'icp_port' in your config file\n");
 	fatal_dump(NULL);
     }
     if (entry->swap_status != NO_SWAP)
@@ -475,20 +475,20 @@ neighborsUdpPing(request_t * request,
     for (i = 0, p = Peers.first_ping; i++ < Peers.n; p = p->next) {
 	if (p == NULL)
 	    p = Peers.peers_head;
-	debug(15, 5, "neighborsUdpPing: Peer %s\n", p->host);
+	debug(15, 5) ("neighborsUdpPing: Peer %s\n", p->host);
 	if (!peerWouldBePinged(p, request))
 	    continue;		/* next peer */
 	peers_pinged++;
-	debug(15, 4, "neighborsUdpPing: pinging peer %s for '%s'\n",
+	debug(15, 4) ("neighborsUdpPing: pinging peer %s for '%s'\n",
 	    p->host, url);
 	if (p->type == PEER_MULTICAST)
 	    comm_set_mcast_ttl(theOutIcpConnection, p->mcast.ttl);
 	reqnum = storeReqnum(entry, request->method);
-	debug(15, 3, "neighborsUdpPing: key = '%s'\n", entry->key);
-	debug(15, 3, "neighborsUdpPing: reqnum = %d\n", reqnum);
+	debug(15, 3) ("neighborsUdpPing: key = '%s'\n", entry->key);
+	debug(15, 3) ("neighborsUdpPing: reqnum = %d\n", reqnum);
 
 	if (p->icp_port == echo_port) {
-	    debug(15, 4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
+	    debug(15, 4) ("neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
 	    echo_hdr.reqnum = reqnum;
 	    query = icpCreateMessage(ICP_OP_DECHO, 0, url, reqnum, 0);
 	    icpUdpSend(theOutIcpConnection,
@@ -517,7 +517,7 @@ neighborsUdpPing(request_t * request,
 
 	p->stats.ack_deficit++;
 	p->stats.pings_sent++;
-	debug(15, 3, "neighborsUdpPing: %s: ack_deficit = %d\n",
+	debug(15, 3) ("neighborsUdpPing: %s: ack_deficit = %d\n",
 	    p->host, p->stats.ack_deficit);
 	if (p->type == PEER_MULTICAST) {
 	    p->stats.ack_deficit = 0;
@@ -529,7 +529,7 @@ neighborsUdpPing(request_t * request,
 	    /* Neighbor is dead; ping it anyway, but don't expect a reply */
 	    /* log it once at the threshold */
 	    if ((p->stats.ack_deficit == HIER_MAX_DEFICIT)) {
-		debug(15, 0, "Detected DEAD %s: %s/%d/%d\n",
+		debug(15, 0) ("Detected DEAD %s: %s/%d/%d\n",
 		    neighborTypeStr(p),
 		    p->host, p->http_port, p->icp_port);
 	    }
@@ -541,9 +541,9 @@ neighborsUdpPing(request_t * request,
     /* only do source_ping if we have neighbors */
     if (Peers.n) {
 	if (!Config.sourcePing) {
-	    debug(15, 6, "neighborsUdpPing: Source Ping is disabled.\n");
+	    debug(15, 6) ("neighborsUdpPing: Source Ping is disabled.\n");
 	} else if ((ia = ipcache_gethostbyname(host, 0))) {
-	    debug(15, 6, "neighborsUdpPing: Source Ping: to %s for '%s'\n",
+	    debug(15, 6) ("neighborsUdpPing: Source Ping: to %s for '%s'\n",
 		host, url);
 	    echo_hdr.reqnum = reqnum;
 	    if (icmp_sock != -1) {
@@ -560,7 +560,7 @@ neighborsUdpPing(request_t * request,
 		    PROTO_NONE);
 	    }
 	} else {
-	    debug(15, 6, "neighborsUdpPing: Source Ping: unknown host: %s\n",
+	    debug(15, 6) ("neighborsUdpPing: Source Ping: unknown host: %s\n",
 		host);
 	}
     }
@@ -578,7 +578,7 @@ neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
     int n;
     /* Neighbor is alive, reset the ack deficit */
     if (p->stats.ack_deficit >= HIER_MAX_DEFICIT) {
-	debug(15, 0, "Detected REVIVED %s: %s/%d/%d\n",
+	debug(15, 0) ("Detected REVIVED %s: %s/%d/%d\n",
 	    neighborTypeStr(p),
 	    p->host, p->http_port, p->icp_port);
     }
@@ -635,34 +635,34 @@ neighborsUdpAck(int fd, const char *url, icp_common_t * header, const struct soc
     char *opcode_d;
     icp_opcode opcode = (icp_opcode) header->opcode;
 
-    debug(15, 6, "neighborsUdpAck: opcode %d '%s'\n", (int) opcode, url);
+    debug(15, 6) ("neighborsUdpAck: opcode %d '%s'\n", (int) opcode, url);
     if ((p = whichPeer(from)))
 	neighborAlive(p, mem, header);
     if (opcode > ICP_OP_END)
 	return;
     opcode_d = IcpOpcodeStr[opcode];
     /* check if someone is already fetching it */
     if (BIT_TEST(entry->flag, ENTRY_DISPATCHED)) {
-	debug(15, 3, "neighborsUdpAck: '%s' already being fetched.\n", url);
+	debug(15, 3) ("neighborsUdpAck: '%s' already being fetched.\n", url);
 	neighborCountIgnored(p, opcode);
 	return;
     }
     if (mem == NULL) {
-	debug(15, 2, "Ignoring %s for missing mem_obj: %s\n", opcode_d, url);
+	debug(15, 2) ("Ignoring %s for missing mem_obj: %s\n", opcode_d, url);
 	neighborCountIgnored(p, opcode);
 	return;
     }
     if (entry->ping_status != PING_WAITING) {
-	debug(15, 2, "neighborsUdpAck: Unexpected %s for %s\n", opcode_d, url);
+	debug(15, 2) ("neighborsUdpAck: Unexpected %s for %s\n", opcode_d, url);
 	neighborCountIgnored(p, opcode);
 	return;
     }
     if (entry->lock_count == 0) {
-	debug(12, 1, "neighborsUdpAck: '%s' has no locks\n", url);
+	debug(12, 1) ("neighborsUdpAck: '%s' has no locks\n", url);
 	neighborCountIgnored(p, opcode);
 	return;
     }
-    debug(15, 3, "neighborsUdpAck: %s for '%s' from %s \n",
+    debug(15, 3) ("neighborsUdpAck: %s for '%s' from %s \n",
 	opcode_d, url, p ? p->host : "source");
     if (p)
 	ntype = neighborType(p, mem->request);
@@ -671,17 +671,17 @@ neighborsUdpAck(int fd, const char *url, icp_common_t * header, const struct soc
     } else if (opcode == ICP_OP_SECHO) {
 	/* Received source-ping reply */
 	if (p) {
-	    debug(15, 1, "Ignoring SECHO from neighbor %s\n", p->host);
+	    debug(15, 1) ("Ignoring SECHO from neighbor %s\n", p->host);
 	    neighborCountIgnored(p, opcode);
 	} else {
 	    /* if we reach here, source-ping reply is the first 'parent',
 	     * so fetch directly from the source */
-	    debug(15, 6, "Source is the first to respond.\n");
+	    debug(15, 6) ("Source is the first to respond.\n");
 	    mem->icp_reply_callback(NULL, ntype, opcode, mem->ircb_data);
 	}
     } else if (opcode == ICP_OP_MISS) {
 	if (p == NULL) {
-	    debug(15, 1, "Ignoring MISS from non-peer %s\n",
+	    debug(15, 1) ("Ignoring MISS from non-peer %s\n",
 		inet_ntoa(from->sin_addr));
 	} else if (ntype != PEER_PARENT) {
 	    (void) 0;		/* ignore MISS from non-parent */
@@ -690,14 +690,14 @@ neighborsUdpAck(int fd, const char *url, icp_common_t * header, const struct soc
 	}
     } else if (opcode == ICP_OP_HIT || opcode == ICP_OP_HIT_OBJ) {
 	if (p == NULL) {
-	    debug(15, 1, "Ignoring HIT from non-peer %s\n",
+	    debug(15, 1) ("Ignoring HIT from non-peer %s\n",
 		inet_ntoa(from->sin_addr));
 	} else {
 	    mem->icp_reply_callback(p, ntype, ICP_OP_HIT, mem->ircb_data);
 	}
     } else if (opcode == ICP_OP_DECHO) {
 	if (p == NULL) {
-	    debug(15, 1, "Ignoring DECHO from non-peer %s\n",
+	    debug(15, 1) ("Ignoring DECHO from non-peer %s\n",
 		inet_ntoa(from->sin_addr));
 	} else if (ntype == PEER_SIBLING) {
 	    debug_trap("neighborsUdpAck: Found non-ICP cache as SIBLING\n");
@@ -707,21 +707,21 @@ neighborsUdpAck(int fd, const char *url, icp_common_t * header, const struct soc
 	}
     } else if (opcode == ICP_OP_SECHO) {
 	if (p) {
-	    debug(15, 1, "Ignoring SECHO from neighbor %s\n", p->host);
+	    debug(15, 1) ("Ignoring SECHO from neighbor %s\n", p->host);
 	    neighborCountIgnored(p, opcode);
 	} else if (!Config.sourcePing) {
-	    debug(15, 1, "Unsolicited SECHO from %s\n", inet_ntoa(from->sin_addr));
+	    debug(15, 1) ("Unsolicited SECHO from %s\n", inet_ntoa(from->sin_addr));
 	} else {
 	    mem->icp_reply_callback(NULL, ntype, opcode, mem->ircb_data);
 	}
     } else if (opcode == ICP_OP_DENIED) {
 	if (p == NULL) {
-	    debug(15, 1, "Ignoring DENIED from non-peer %s\n",
+	    debug(15, 1) ("Ignoring DENIED from non-peer %s\n",
 		inet_ntoa(from->sin_addr));
 	} else if (p->stats.pings_acked > 100) {
 	    if (100 * p->stats.counts[ICP_OP_DENIED] / p->stats.pings_acked > 95) {
-		debug(15, 0, "95%% of replies from '%s' are UDP_DENIED\n", p->host);
-		debug(15, 0, "Disabling '%s', please check your configuration.\n", p->host);
+		debug(15, 0) ("95%% of replies from '%s' are UDP_DENIED\n", p->host);
+		debug(15, 0) ("Disabling '%s', please check your configuration.\n", p->host);
 		neighborRemove(p);
 		p = NULL;
 	    } else {
@@ -731,7 +731,7 @@ neighborsUdpAck(int fd, const char *url, icp_common_t * header, const struct soc
     } else if (opcode == ICP_OP_MISS_NOFETCH) {
 	mem->icp_reply_callback(p, ntype, opcode, mem->ircb_data);
     } else {
-	debug(15, 0, "neighborsUdpAck: Unexpected ICP reply: %s\n", opcode_d);
+	debug(15, 0) ("neighborsUdpAck: Unexpected ICP reply: %s\n", opcode_d);
     }
 }
 
@@ -750,7 +750,7 @@ neighborAdd(const char *host,
     if (!strcmp(host, me)) {
 	for (j = 0; j < Config.Port.n_http; j++) {
 	    if (http_port == Config.Port.http[j]) {
-		debug(15, 0, "neighborAdd: skipping cache_host %s %s/%d/%d\n",
+		debug(15, 0) ("neighborAdd: skipping cache_host %s %s/%d/%d\n",
 		    type, host, http_port, icp_port);
 		return;
 	    }
@@ -788,7 +788,7 @@ neighborAddDomainPing(const char *host, const char *domain)
     struct _domain_ping **L = NULL;
     peer *p;
     if ((p = neighborFindByName(host)) == NULL) {
-	debug(15, 0, "%s, line %d: No cache_host '%s'\n",
+	debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
 	    cfg_filename, config_lineno, host);
 	return;
     }
@@ -811,7 +811,7 @@ neighborAddDomainType(const char *host, const char *domain, const char *type)
     struct _domain_type **L = NULL;
     peer *p;
     if ((p = neighborFindByName(host)) == NULL) {
-	debug(15, 0, "%s, line %d: No cache_host '%s'\n",
+	debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
 	    cfg_filename, config_lineno, host);
 	return;
     }
@@ -832,7 +832,7 @@ neighborAddAcl(const char *host, const char *aclname)
     struct _acl *a = NULL;
 
     if ((p = neighborFindByName(host)) == NULL) {
-	debug(15, 0, "%s, line %d: No cache_host '%s'\n",
+	debug(15, 0) ("%s, line %d: No cache_host '%s'\n",
 	    cfg_filename, config_lineno, host);
 	return;
     }
@@ -842,20 +842,20 @@ neighborAddAcl(const char *host, const char *aclname)
 	L->op = 0;
 	aclname++;
     }
-    debug(15, 3, "neighborAddAcl: looking for ACL name '%s'\n", aclname);
+    debug(15, 3) ("neighborAddAcl: looking for ACL name '%s'\n", aclname);
     a = aclFindByName(aclname);
     if (a == NULL) {
-	debug(15, 0, "%s line %d: %s\n",
+	debug(15, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(15, 0, "neighborAddAcl: ACL name '%s' not found.\n", aclname);
+	debug(15, 0) ("neighborAddAcl: ACL name '%s' not found.\n", aclname);
 	xfree(L);
 	return;
     }
 #ifdef NOW_SUPPORTED
     if (a->type == ACL_SRC_IP) {
-	debug(15, 0, "%s line %d: %s\n",
+	debug(15, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(15, 0, "neighborAddAcl: 'src' ACL's not supported for 'cache_host_acl'\n");
+	debug(15, 0) ("neighborAddAcl: 'src' ACL's not supported for 'cache_host_acl'\n");
 	xfree(L);
 	return;
     }
@@ -889,7 +889,7 @@ parseNeighborType(const char *s)
 	return PEER_SIBLING;
     if (!strcasecmp(s, "multicast"))
 	return PEER_MULTICAST;
-    debug(15, 0, "WARNING: Unknown neighbor type: %s\n", s);
+    debug(15, 0) ("WARNING: Unknown neighbor type: %s\n", s);
     return PEER_SIBLING;
 }
 
@@ -937,23 +937,23 @@ peerDNSConfigure(int fd, const ipcache_addrs * ia, void *data)
     int j;
     p->ip_lookup_pending = 0;
     if (p->n_addresses == 0) {
-	debug(15, 1, "Configuring %s %s/%d/%d\n", neighborTypeStr(p),
+	debug(15, 1) ("Configuring %s %s/%d/%d\n", neighborTypeStr(p),
 	    p->host, p->http_port, p->icp_port);
 	if (p->type == PEER_MULTICAST)
-	    debug(15, 1, "    Multicast TTL = %d\n", p->mcast.ttl);
+	    debug(15, 1) ("    Multicast TTL = %d\n", p->mcast.ttl);
     }
     p->n_addresses = 0;
     if (ia == NULL) {
-	debug(0, 0, "WARNING: DNS lookup for '%s' failed!\n", p->host);
+	debug(0, 0) ("WARNING: DNS lookup for '%s' failed!\n", p->host);
 	return;
     }
     if ((int) ia->count < 1) {
-	debug(0, 0, "WARNING: No IP address found for '%s'!\n", p->host);
+	debug(0, 0) ("WARNING: No IP address found for '%s'!\n", p->host);
 	return;
     }
     for (j = 0; j < (int) ia->count && j < PEER_MAX_ADDRESSES; j++) {
 	p->addresses[j] = ia->in_addrs[j];
-	debug(15, 2, "--> IP address #%d: %s\n", j, inet_ntoa(p->addresses[j]));
+	debug(15, 2) ("--> IP address #%d: %s\n", j, inet_ntoa(p->addresses[j]));
 	p->n_addresses++;
     }
     ap = &p->in_addr;
@@ -1013,7 +1013,7 @@ peerCheckConnectDone(int fd, int status, void *data)
     peer *p = data;
     p->tcp_up = status == COMM_OK ? 1 : 0;
     if (p->tcp_up) {
-	debug(15, 0, "TCP connection to %s/%d succeeded\n",
+	debug(15, 0) ("TCP connection to %s/%d succeeded\n",
 	    p->host, p->http_port);
     } else {
 	eventAdd("peerCheckConnect", peerCheckConnect, p, 80);
@@ -1027,7 +1027,7 @@ peerCheckConnectStart(peer * p)
 {
     if (!p->tcp_up)
 	return;
-    debug(15, 0, "TCP connection to %s/%d failed\n", p->host, p->http_port);
+    debug(15, 0) ("TCP connection to %s/%d failed\n", p->host, p->http_port);
     p->tcp_up = 0;
     p->last_fail_time = squid_curtime;
     eventAdd("peerCheckConnect", peerCheckConnect, p, 80);
@@ -1098,7 +1098,7 @@ peerCountMcastPeersDone(void *data)
 	(double) psstate->icp.n_recv,
 	++p->mcast.n_times_counted,
 	10);
-    debug(15, 1, "Group %s: %d replies, %4.1f average\n",
+    debug(15, 1) ("Group %s: %d replies, %4.1f average\n",
 	p->host,
 	psstate->icp.n_recv,
 	p->mcast.avg_n_members);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.37 1997/06/04 04:32:59 wessels Exp $
+ * $Id: net_db.cc,v 1.38 1997/06/04 06:16:04 wessels Exp $
  *
  * DEBUG: section 37    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -219,7 +219,7 @@ netdbSendPing(int fdunused, const ipcache_addrs * ia, void *data)
     addr = ia->in_addrs[ia->cur];
     if ((n = netdbLookupHost(hostname)) == NULL)
 	n = netdbAdd(addr, hostname);
-    debug(37, 3, "netdbSendPing: pinging %s\n", hostname);
+    debug(37, 3) ("netdbSendPing: pinging %s\n", hostname);
     icmpDomainPing(addr, hostname);
     n->pings_sent++;
     n->next_ping_time = squid_curtime + Config.Netdb.period;
@@ -284,7 +284,7 @@ netdbPeerAdd(netdbEntry * n, peer * e)
 	    n->n_peers_alloc = 2;
 	else
 	    n->n_peers_alloc <<= 1;
-	debug(37, 3, "netdbPeerAdd: Growing peer list for '%s' to %d\n",
+	debug(37, 3) ("netdbPeerAdd: Growing peer list for '%s' to %d\n",
 	    n->network, n->n_peers_alloc);
 	n->peers = xcalloc(n->n_peers_alloc, sizeof(net_db_peer));
 	meta_data.netdb_peers += n->n_peers_alloc;
@@ -325,7 +325,7 @@ netdbSaveState(void *foo)
     sprintf(path, "%s/netdb_state", storeSwapDir(0));
     fp = fopen(path, "w");
     if (fp == NULL) {
-	debug(50, 1, "netdbSaveState: %s: %s\n", path, xstrerror());
+	debug(50, 1) ("netdbSaveState: %s: %s\n", path, xstrerror());
 	return;
     }
     next = (netdbEntry *) hash_first(addr_table);
@@ -348,7 +348,7 @@ netdbSaveState(void *foo)
     }
     fclose(fp);
     getCurrentTime();
-    debug(37, 0, "NETDB state saved; %d entries, %d msec\n",
+    debug(37, 0) ("NETDB state saved; %d entries, %d msec\n",
 	count, tvSubMsec(start, current_time));
     eventAdd("netdbSaveState", netdbSaveState, NULL, 3617);
 }
@@ -408,7 +408,7 @@ netdbReloadState(void)
     put_free_4k_page(buf);
     fclose(fp);
     getCurrentTime();
-    debug(37, 0, "NETDB state reloaded; %d entries, %d msec\n",
+    debug(37, 0) ("NETDB state reloaded; %d entries, %d msec\n",
 	count, tvSubMsec(start, current_time));
 }
 
@@ -467,15 +467,15 @@ netdbHandlePingReply(const struct sockaddr_in *from, int hops, int rtt)
 #if USE_ICMP
     netdbEntry *n;
     int N;
-    debug(37, 3, "netdbHandlePingReply: from %s\n", inet_ntoa(from->sin_addr));
+    debug(37, 3) ("netdbHandlePingReply: from %s\n", inet_ntoa(from->sin_addr));
     if ((n = netdbLookupAddr(from->sin_addr)) == NULL)
 	return;
     N = ++n->pings_recv;
     if (N > 5)
 	N = 5;
     n->hops = ((n->hops * (N - 1)) + hops) / N;
     n->rtt = ((n->rtt * (N - 1)) + rtt) / N;
-    debug(37, 3, "netdbHandlePingReply: %s; rtt=%5.1f  hops=%4.1f\n",
+    debug(37, 3) ("netdbHandlePingReply: %s; rtt=%5.1f  hops=%4.1f\n",
 	n->network,
 	n->rtt,
 	n->hops);
@@ -568,7 +568,7 @@ netdbDump(StoreEntry * sentry)
     for (n = netdbGetFirst(addr_table); n; n = netdbGetNext(addr_table))
 	*(list + i++) = n;
     if (i != meta_data.netdb_addrs)
-	debug(37, 0, "WARNING: netdb_addrs count off, found %d, expected %d\n",
+	debug(37, 0) ("WARNING: netdb_addrs count off, found %d, expected %d\n",
 	    i, meta_data.netdb_addrs);
     qsort((char *) list,
 	i,
@@ -632,10 +632,10 @@ netdbUpdatePeer(request_t * r, peer * e, int irtt, int ihops)
     double rtt = (double) irtt;
     double hops = (double) ihops;
     net_db_peer *p;
-    debug(37, 3, "netdbUpdatePeer: '%s', %d hops, %d rtt\n", r->host, ihops, irtt);
+    debug(37, 3) ("netdbUpdatePeer: '%s', %d hops, %d rtt\n", r->host, ihops, irtt);
     n = netdbLookupHost(r->host);
     if (n == NULL) {
-	debug(37, 3, "netdbUpdatePeer: host '%s' not found\n", r->host);
+	debug(37, 3) ("netdbUpdatePeer: host '%s' not found\n", r->host);
 	return;
     }
     if ((p = netdbPeerByName(n, e->host)) == NULL)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.12 1997/05/02 04:28:37 wessels Exp $
+ * $Id: peer_select.cc,v 1.13 1997/06/04 06:16:05 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -69,7 +69,7 @@ static void
 peerSelectStateFree(ps_state * psstate)
 {
     if (psstate->acl_checklist) {
-	debug(0, 0, "calling aclChecklistFree() from peerSelectStateFree\n");
+	debug(0, 0) ("calling aclChecklistFree() from peerSelectStateFree\n");
 	aclChecklistFree(psstate->acl_checklist);
     }
     requestUnlink(psstate->request);
@@ -152,7 +152,7 @@ peerCheckNeverDirectDone(int answer, void *data)
 {
     ps_state *psstate = data;
     psstate->acl_checklist = NULL;
-    debug(44, 3, "peerCheckNeverDirectDone: %d\n", answer);
+    debug(44, 3) ("peerCheckNeverDirectDone: %d\n", answer);
     psstate->never_direct = answer ? 1 : -1;
     peerSelectFoo(psstate);
 }
@@ -162,7 +162,7 @@ peerCheckAlwaysDirectDone(int answer, void *data)
 {
     ps_state *psstate = data;
     psstate->acl_checklist = NULL;
-    debug(44, 3, "peerCheckAlwaysDirectDone: %d\n", answer);
+    debug(44, 3) ("peerCheckAlwaysDirectDone: %d\n", answer);
     psstate->always_direct = answer ? 1 : -1;
     peerSelectFoo(psstate);
 }
@@ -185,10 +185,10 @@ peerSelectCallbackFail(ps_state * psstate)
 {
     request_t *request = psstate->request;
     char *url = psstate->entry ? psstate->entry->url : urlCanonical(request, NULL);
-    debug(44, 1, "Failed to select source for '%s'\n", url);
-    debug(44, 1, "  always_direct = %d\n", psstate->always_direct);
-    debug(44, 1, "   never_direct = %d\n", psstate->never_direct);
-    debug(44, 1, "        timeout = %d\n", psstate->icp.timeout);
+    debug(44, 1) ("Failed to select source for '%s'\n", url);
+    debug(44, 1) ("  always_direct = %d\n", psstate->always_direct);
+    debug(44, 1) ("   never_direct = %d\n", psstate->never_direct);
+    debug(44, 1) ("        timeout = %d\n", psstate->icp.timeout);
     psstate->fail_callback(NULL, psstate->callback_data);
     peerSelectStateFree(psstate);
 }
@@ -201,7 +201,7 @@ peerSelectFoo(ps_state * psstate)
     StoreEntry *entry = psstate->entry;
     request_t *request = psstate->request;
     int direct;
-    debug(44, 3, "peerSelect: '%s %s'\n",
+    debug(44, 3) ("peerSelect: '%s %s'\n",
 	RequestMethodStr[request->method],
 	request->host);
     if (psstate->never_direct == 0 && Config.accessList.NeverDirect) {
@@ -233,17 +233,17 @@ peerSelectFoo(ps_state * psstate)
     } else {
 	direct = DIRECT_MAYBE;
     }
-    debug(44, 3, "peerSelect: direct = %d\n", direct);
+    debug(44, 3) ("peerSelect: direct = %d\n", direct);
     if (direct == DIRECT_YES) {
-	debug(44, 3, "peerSelect: DIRECT\n");
+	debug(44, 3) ("peerSelect: DIRECT\n");
 	hierarchyNote(request, DIRECT, &psstate->icp, request->host);
 	peerSelectCallback(psstate, NULL);
 	return;
     }
     if (peerSelectIcpPing(request, direct, entry)) {
 	if (entry->ping_status != PING_NONE)
 	    fatal_dump("peerSelectFoo: bad ping_status");
-	debug(44, 3, "peerSelect: Doing ICP pings\n");
+	debug(44, 3) ("peerSelect: Doing ICP pings\n");
 	psstate->icp.n_sent = neighborsUdpPing(request,
 	    entry,
 	    peerHandleIcpReply,
@@ -261,16 +261,16 @@ peerSelectFoo(ps_state * psstate)
     }
     if ((p = psstate->first_parent_miss)) {
 	code = FIRST_PARENT_MISS;
-	debug(44, 3, "peerSelect: %s/%s\n", hier_strings[code], p->host);
+	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
 	hierarchyNote(request, code, &psstate->icp, p->host);
 	peerSelectCallback(psstate, p);
     } else if (direct != DIRECT_NO) {
 	code = DIRECT;
-	debug(44, 3, "peerSelect: %s/%s\n", hier_strings[code], request->host);
+	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], request->host);
 	hierarchyNote(request, code, &psstate->icp, request->host);
 	peerSelectCallback(psstate, NULL);
     } else if ((p = peerGetSomeParent(request, &code))) {
-	debug(44, 3, "peerSelect: %s/%s\n", hier_strings[code], p->host);
+	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
 	hierarchyNote(request, code, &psstate->icp, p->host);
 	peerSelectCallback(psstate, p);
     } else {
@@ -285,7 +285,7 @@ peerPingTimeout(void *data)
 {
     ps_state *psstate = data;
     StoreEntry *entry = psstate->entry;
-    debug(44, 3, "peerPingTimeout: '%s'\n", entry->url);
+    debug(44, 3) ("peerPingTimeout: '%s'\n", entry->url);
     entry->ping_status = PING_TIMEOUT;
     PeerStats.timeouts++;
     psstate->icp.timeout = 1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: pinger.cc,v 1.22 1997/05/15 23:40:58 wessels Exp $
+ * $Id: pinger.cc,v 1.23 1997/06/04 06:16:06 wessels Exp $
  *
  * DEBUG: section 42    ICMP Pinger program
  * AUTHOR: Duane Wessels
@@ -123,16 +123,16 @@ pingerOpen(void)
 {
     struct protoent *proto = NULL;
     if ((proto = getprotobyname("icmp")) == 0) {
-	debug(42, 0, "pingerOpen: unknown protocol: icmp\n");
+	debug(42, 0) ("pingerOpen: unknown protocol: icmp\n");
 	exit(1);
     }
     icmp_sock = socket(PF_INET, SOCK_RAW, proto->p_proto);
     if (icmp_sock < 0) {
-	debug(50, 0, "pingerOpen: icmp_sock: %s\n", xstrerror());
+	debug(50, 0) ("pingerOpen: icmp_sock: %s\n", xstrerror());
 	exit(1);
     }
     icmp_ident = getpid() & 0xffff;
-    debug(42, 0, "ICMP socket opened\n", icmp_sock);
+    debug(42, 0) ("ICMP socket opened\n", icmp_sock);
 }
 
 void
@@ -204,7 +204,7 @@ pingerRecv(void)
 	(struct sockaddr *) &from,
 	&fromlen);
     gettimeofday(&now, NULL);
-    debug(42, 9, "pingerRecv: %d bytes from %s\n", n, inet_ntoa(from.sin_addr));
+    debug(42, 9) ("pingerRecv: %d bytes from %s\n", n, inet_ntoa(from.sin_addr));
     ip = (struct iphdr *) (void *) pkt;
 #if HAVE_IP_HL
     iphdrlen = ip->ip_hl << 2;
@@ -257,7 +257,7 @@ in_cksum(unsigned short *ptr, int size)
 static void
 pingerLog(struct icmphdr *icmp, struct in_addr addr, int rtt, int hops)
 {
-    debug(42, 2, "pingerLog: %9d.%06d %-16s %d %-15.15s %dms %d hops\n",
+    debug(42, 2) ("pingerLog: %9d.%06d %-16s %d %-15.15s %dms %d hops\n",
 	(int) current_time.tv_sec,
 	(int) current_time.tv_usec,
 	inet_ntoa(addr),
@@ -309,7 +309,7 @@ pingerSendtoSquid(pingerReplyData * preply)
 {
     int len = sizeof(pingerReplyData) - MAX_PKT_SZ + preply->psize;
     if (send(1, (char *) preply, len, 0) < 0) {
-	debug(50, 0, "pinger: send: %s\n", xstrerror());
+	debug(50, 0) ("pinger: send: %s\n", xstrerror());
 	exit(1);
     }
 }
@@ -354,7 +354,7 @@ main(int argc, char *argv[])
 	    return 1;
 	if (FD_ISSET(0, &R))
 	    if (pingerReadRequest() < 0) {
-		debug(42, 0, "Pinger exiting.\n");
+		debug(42, 0) ("Pinger exiting.\n");
 		return 1;
 	    }
 	if (FD_ISSET(icmp_sock, &R))
@@ -1,5 +1,5 @@
 /*
- * $Id: redirect.cc,v 1.43 1997/05/16 07:44:21 wessels Exp $
+ * $Id: redirect.cc,v 1.44 1997/06/04 06:16:07 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -102,19 +102,19 @@ redirectCreateRedirector(const char *command)
 	COMM_NOCLOEXEC,
 	"socket to redirector");
     if (cfd == COMM_ERROR) {
-	debug(29, 0, "redirect_create_redirector: Failed to create redirector\n");
+	debug(29, 0) ("redirect_create_redirector: Failed to create redirector\n");
 	return -1;
     }
     len = sizeof(S);
     memset(&S, '\0', len);
     if (getsockname(cfd, (struct sockaddr *) &S, &len) < 0) {
-	debug(50, 0, "redirect_create_redirector: getsockname: %s\n", xstrerror());
+	debug(50, 0) ("redirect_create_redirector: getsockname: %s\n", xstrerror());
 	comm_close(cfd);
 	return -1;
     }
     listen(cfd, 1);
     if ((pid = fork()) < 0) {
-	debug(50, 0, "redirect_create_redirector: fork: %s\n", xstrerror());
+	debug(50, 0) ("redirect_create_redirector: fork: %s\n", xstrerror());
 	comm_close(cfd);
 	return -1;
     }
@@ -134,7 +134,7 @@ redirectCreateRedirector(const char *command)
 	    return -1;
 	}
 	commSetTimeout(sfd, -1, NULL, NULL);
-	debug(29, 4, "redirect_create_redirector: FD %d connected to %s #%d.\n",
+	debug(29, 4) ("redirect_create_redirector: FD %d connected to %s #%d.\n",
 	    sfd, command, ++n_redirector);
 	slp.tv_sec = 0;
 	slp.tv_usec = 250000;
@@ -144,7 +144,7 @@ redirectCreateRedirector(const char *command)
     /* child */
     no_suid();			/* give up extra priviliges */
     if ((fd = accept(cfd, NULL, NULL)) < 0) {
-	debug(50, 0, "redirect_create_redirector: FD %d accept: %s\n",
+	debug(50, 0) ("redirect_create_redirector: FD %d accept: %s\n",
 	    cfd, xstrerror());
 	_exit(1);
     }
@@ -155,7 +155,7 @@ redirectCreateRedirector(const char *command)
     close(fd);
     close(cfd);
     execlp(command, "(redirector)", NULL);
-    debug(50, 0, "redirect_create_redirector: %s: %s\n", command, xstrerror());
+    debug(50, 0) ("redirect_create_redirector: %s: %s\n", command, xstrerror());
     _exit(1);
     return 0;
 }
@@ -173,13 +173,13 @@ redirectHandleRead(int fd, void *data)
 	redirector->inbuf + redirector->offset,
 	redirector->size - redirector->offset);
     fd_bytes(fd, len, FD_READ);
-    debug(29, 5, "redirectHandleRead: %d bytes from Redirector #%d.\n",
+    debug(29, 5) ("redirectHandleRead: %d bytes from Redirector #%d.\n",
 	len, redirector->index + 1);
     if (len <= 0) {
 	if (len < 0)
-	    debug(50, 1, "redirectHandleRead: FD %d read: %s\n", fd, xstrerror());
-	debug(29, redirector->flags & REDIRECT_FLAG_CLOSING ? 5 : 1,
-	    "FD %d: Connection from Redirector #%d is closed, disabling\n",
+	    debug(50, 1) ("redirectHandleRead: FD %d read: %s\n", fd, xstrerror());
+	debug(29, redirector->flags & REDIRECT_FLAG_CLOSING ? 5 : 1)
+	    ("FD %d: Connection from Redirector #%d is closed, disabling\n",
 	    fd, redirector->index + 1);
 	redirector->flags = 0;
 	put_free_8k_page(redirector->inbuf);
@@ -206,11 +206,11 @@ redirectHandleRead(int fd, void *data)
 	if (r == NULL) {
 	    /* A naughty redirector has spoken without being spoken to */
 	    /* B.R.Foster@massey.ac.nz, SQUID/1.1.3 */
-	    debug(29, 0, "redirectHandleRead: unexpected reply: '%s'\n",
+	    debug(29, 0) ("redirectHandleRead: unexpected reply: '%s'\n",
 		redirector->inbuf);
 	    redirector->offset = 0;
 	} else {
-	    debug(29, 5, "redirectHandleRead: reply: '%s'\n",
+	    debug(29, 5) ("redirectHandleRead: reply: '%s'\n",
 		redirector->inbuf);
 	    /* careful here.  r->data might point to something which
 	     * has recently been freed.  If so, we require that r->handler
@@ -292,7 +292,7 @@ redirectDispatch(redirector_t * redirect, redirectStateData * r)
     const char *fqdn = NULL;
     int len;
     if (r->handler == NULL) {
-	debug(29, 1, "redirectDispatch: skipping '%s' because no handler\n",
+	debug(29, 1) ("redirectDispatch: skipping '%s' because no handler\n",
 	    r->orig_url);
 	redirectStateFree(r);
 	return;
@@ -316,7 +316,7 @@ redirectDispatch(redirector_t * redirect, redirectStateData * r)
 	NULL,			/* Handler */
 	NULL,			/* Handler-data */
 	put_free_8k_page);
-    debug(29, 5, "redirectDispatch: Request sent to Redirector #%d, %d bytes\n",
+    debug(29, 5) ("redirectDispatch: Request sent to Redirector #%d, %d bytes\n",
 	redirect->index + 1, len);
     RedirectStats.use_hist[redirect->index]++;
     RedirectStats.requests++;
@@ -336,7 +336,7 @@ redirectStart(clientHttpRequest * http, RH * handler, void *data)
 	fatal_dump("redirectStart: NULL clientHttpRequest");
     if (!handler)
 	fatal_dump("redirectStart: NULL handler");
-    debug(29, 5, "redirectStart: '%s'\n", http->url);
+    debug(29, 5) ("redirectStart: '%s'\n", http->url);
     if (Config.Program.redirect == NULL) {
 	handler(data, NULL);
 	return;
@@ -388,12 +388,12 @@ redirectOpenServers(void)
 	return;
     NRedirectors = NRedirectorsOpen = Config.redirectChildren;
     redirect_child_table = xcalloc(NRedirectors, sizeof(redirector_t *));
-    debug(29, 1, "redirectOpenServers: Starting %d '%s' processes\n",
+    debug(29, 1) ("redirectOpenServers: Starting %d '%s' processes\n",
 	NRedirectors, prg);
     for (k = 0; k < NRedirectors; k++) {
 	redirect_child_table[k] = xcalloc(1, sizeof(redirector_t));
 	if ((redirectsocket = redirectCreateRedirector(prg)) < 0) {
-	    debug(29, 1, "WARNING: Cannot run '%s' process.\n", prg);
+	    debug(29, 1) ("WARNING: Cannot run '%s' process.\n", prg);
 	    redirect_child_table[k]->flags &= ~REDIRECT_FLAG_ALIVE;
 	} else {
 	    redirect_child_table[k]->flags |= REDIRECT_FLAG_ALIVE;
@@ -416,7 +416,7 @@ redirectOpenServers(void)
 		COMM_SELECT_READ,
 		redirectHandleRead,
 		redirect_child_table[k], 0);
-	    debug(29, 3, "redirectOpenServers: 'redirect_server' %d started\n",
+	    debug(29, 3) ("redirectOpenServers: 'redirect_server' %d started\n",
 		k);
 	}
     }
@@ -447,7 +447,7 @@ redirectShutdownServers(void)
 	    continue;
 	if (redirect->flags & REDIRECT_FLAG_CLOSING)
 	    continue;
-	debug(29, 3, "redirectShutdownServers: closing redirector #%d, FD %d\n",
+	debug(29, 3) ("redirectShutdownServers: closing redirector #%d, FD %d\n",
 	    redirect->index + 1, redirect->fd);
 	comm_close(redirect->fd);
 	redirect->flags |= REDIRECT_FLAG_CLOSING;
@@ -466,7 +466,7 @@ redirectUnregister(const char *url, void *data)
     int n = 0;
     if (Config.Program.redirect == NULL)
 	return 0;
-    debug(29, 3, "redirectUnregister: '%s'\n", url);
+    debug(29, 3) ("redirectUnregister: '%s'\n", url);
     for (k = 0; k < NRedirectors; k++) {
 	redirect = *(redirect_child_table + k);
 	if ((r = redirect->redirectState) == NULL)
@@ -475,7 +475,7 @@ redirectUnregister(const char *url, void *data)
 	    continue;
 	if (strcmp(r->orig_url, url))
 	    continue;
-	debug(29, 3, "redirectUnregister: Found match\n");
+	debug(29, 3) ("redirectUnregister: Found match\n");
 	r->handler = NULL;
 	n++;
     }
@@ -486,11 +486,11 @@ redirectUnregister(const char *url, void *data)
 	    continue;
 	if (strcmp(r->orig_url, url))
 	    continue;
-	debug(29, 3, "redirectUnregister: Found match.\n");
+	debug(29, 3) ("redirectUnregister: Found match.\n");
 	r->handler = NULL;
 	n++;
     }
-    debug(29, 3, "redirectUnregister: Unregistered %d handlers\n", n);
+    debug(29, 3) ("redirectUnregister: Unregistered %d handlers\n", n);
     return n;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: refresh.cc,v 1.11 1996/12/20 23:23:01 wessels Exp $
+ * $Id: refresh.cc,v 1.12 1997/06/04 06:16:08 wessels Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -89,9 +89,9 @@ refreshAddToList(const char *pattern, int opts, time_t min, int pct, time_t max)
     if ((errcode = regcomp(&comp, pattern, flags)) != 0) {
 	char errbuf[256];
 	regerror(errcode, &comp, errbuf, sizeof errbuf);
-	debug(22, 0, "%s line %d: %s\n",
+	debug(22, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
-	debug(22, 0, "refreshAddToList: Invalid regular expression '%s': %s\n",
+	debug(22, 0) ("refreshAddToList: Invalid regular expression '%s': %s\n",
 	    pattern, errbuf);
 	return;
     }
@@ -126,7 +126,7 @@ refreshCheck(const StoreEntry * entry, const request_t * request, time_t delta)
     time_t age;
     int factor;
     time_t check_time = squid_curtime + delta;
-    debug(22, 3, "refreshCheck: '%s'\n", entry->url);
+    debug(22, 3) ("refreshCheck: '%s'\n", entry->url);
     for (R = Refresh_tbl; R; R = R->next) {
 	if (regexec(&(R->compiled_pattern), entry->url, 0, 0, 0) != 0)
 	    continue;
@@ -136,45 +136,45 @@ refreshCheck(const StoreEntry * entry, const request_t * request, time_t delta)
 	pattern = R->pattern;
 	break;
     }
-    debug(22, 3, "refreshCheck: Matched '%s %d %d%% %d'\n",
+    debug(22, 3) ("refreshCheck: Matched '%s %d %d%% %d'\n",
 	pattern, (int) min, pct, (int) max);
     age = check_time - entry->timestamp;
-    debug(22, 3, "refreshCheck: age = %d\n", (int) age);
+    debug(22, 3) ("refreshCheck: age = %d\n", (int) age);
     if (request->max_age > -1) {
 	if (age > request->max_age) {
-	    debug(22, 3, "refreshCheck: YES: age > client-max-age\n");
+	    debug(22, 3) ("refreshCheck: YES: age > client-max-age\n");
 	    return 1;
 	}
     }
     if (age <= min) {
-	debug(22, 3, "refreshCheck: NO: age < min\n");
+	debug(22, 3) ("refreshCheck: NO: age < min\n");
 	return 0;
     }
     if (-1 < entry->expires) {
 	if (entry->expires <= check_time) {
-	    debug(22, 3, "refreshCheck: YES: expires <= curtime\n");
+	    debug(22, 3) ("refreshCheck: YES: expires <= curtime\n");
 	    return 1;
 	} else {
-	    debug(22, 3, "refreshCheck: NO: expires > curtime\n");
+	    debug(22, 3) ("refreshCheck: NO: expires > curtime\n");
 	    return 0;
 	}
     }
     if (age > max) {
-	debug(22, 3, "refreshCheck: YES: age > max\n");
+	debug(22, 3) ("refreshCheck: YES: age > max\n");
 	return 1;
     }
     if (entry->timestamp <= entry->lastmod) {
 	if (request->protocol != PROTO_HTTP) {
-	    debug(22, 3, "refreshCheck: NO: non-HTTP request\n");
+	    debug(22, 3) ("refreshCheck: NO: non-HTTP request\n");
 	    return 0;
 	}
-	debug(22, 3, "refreshCheck: YES: lastvalid <= lastmod\n");
+	debug(22, 3) ("refreshCheck: YES: lastvalid <= lastmod\n");
 	return 1;
     }
     factor = 100 * age / (entry->timestamp - entry->lastmod);
-    debug(22, 3, "refreshCheck: factor = %d\n", factor);
+    debug(22, 3) ("refreshCheck: factor = %d\n", factor);
     if (factor < pct) {
-	debug(22, 3, "refreshCheck: NO: factor < pct\n");
+	debug(22, 3) ("refreshCheck: NO: factor < pct\n");
 	return 0;
     }
     return 1;
@@ -184,7 +184,7 @@ time_t
 getMaxAge(const char *url)
 {
     refresh_t *R;
-    debug(22, 3, "getMaxAge: '%s'\n", url);
+    debug(22, 3) ("getMaxAge: '%s'\n", url);
     for (R = Refresh_tbl; R; R = R->next) {
 	if (regexec(&(R->compiled_pattern), url, 0, 0, 0) == 0)
 	    return R->max;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.35 1997/05/15 01:07:01 wessels Exp $
+ * $Id: send-announce.cc,v 1.36 1997/06/04 06:16:08 wessels Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -54,10 +54,10 @@ send_announce(int fd, const ipcache_addrs * ia, void *data)
     int l;
     int n;
     if (ia == NULL) {
-	debug(27, 1, "send_announce: Unknown host '%s'\n", host);
+	debug(27, 1) ("send_announce: Unknown host '%s'\n", host);
 	return;
     }
-    debug(27, 0, "Sending Announcement to %s\n", host);
+    debug(27, 0) ("Sending Announcement to %s\n", host);
     sndbuf[0] = '\0';
     sprintf(tbuf, "cache_version SQUID/%s\n", version_string);
     strcat(sndbuf, tbuf);
@@ -83,7 +83,7 @@ send_announce(int fd, const ipcache_addrs * ia, void *data)
 	    sndbuf[l] = '\0';
 	    file_close(fd);
 	} else {
-	    debug(50, 1, "send_announce: %s: %s\n", file, xstrerror());
+	    debug(50, 1) ("send_announce: %s: %s\n", file, xstrerror());
 	}
     }
     qdata = xcalloc(1, sizeof(icpUdpData));
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.53 1997/06/02 01:06:16 wessels Exp $
+ * $Id: ssl.cc,v 1.54 1997/06/04 06:16:09 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -86,7 +86,7 @@ static void
 sslClientClosed(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslClientClosed: FD %d\n", fd);
+    debug(26, 3) ("sslClientClosed: FD %d\n", fd);
     /* we have been called from comm_close for the client side, so
      * just need to clean up the server side */
     protoUnregister(NULL, sslState->request, no_addr);
@@ -97,7 +97,7 @@ static void
 sslStateFree(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslStateFree: FD %d, sslState=%p\n", fd, sslState);
+    debug(26, 3) ("sslStateFree: FD %d, sslState=%p\n", fd, sslState);
     if (sslState == NULL)
 	return;
     if (fd != sslState->server.fd)
@@ -123,9 +123,9 @@ sslReadServer(int fd, void *data)
     int len;
     len = read(sslState->server.fd, sslState->server.buf, SQUID_TCP_SO_RCVBUF);
     fd_bytes(sslState->server.fd, len, FD_READ);
-    debug(26, 5, "sslReadServer FD %d, read %d bytes\n", fd, len);
+    debug(26, 5) ("sslReadServer FD %d, read %d bytes\n", fd, len);
     if (len < 0) {
-	debug(50, 1, "sslReadServer: FD %d: read failure: %s\n",
+	debug(50, 1) ("sslReadServer: FD %d: read failure: %s\n",
 	    sslState->server.fd, xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    /* reinstall handlers */
@@ -160,10 +160,10 @@ sslReadClient(int fd, void *data)
     int len;
     len = read(sslState->client.fd, sslState->client.buf, SQUID_TCP_SO_RCVBUF);
     fd_bytes(sslState->client.fd, len, FD_READ);
-    debug(26, 5, "sslReadClient FD %d, read %d bytes\n",
+    debug(26, 5) ("sslReadClient FD %d, read %d bytes\n",
 	sslState->client.fd, len);
     if (len < 0) {
-	debug(50, 1, "sslReadClient: FD %d: read failure: %s\n",
+	debug(50, 1) ("sslReadClient: FD %d: read failure: %s\n",
 	    fd, xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    /* reinstall handlers */
@@ -198,7 +198,7 @@ sslWriteServer(int fd, void *data)
 	sslState->client.buf + sslState->client.offset,
 	sslState->client.len - sslState->client.offset);
     fd_bytes(fd, len, FD_WRITE);
-    debug(26, 5, "sslWriteServer FD %d, wrote %d bytes\n", fd, len);
+    debug(26, 5) ("sslWriteServer FD %d, wrote %d bytes\n", fd, len);
     if (len < 0) {
 	if (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK) {
 	    commSetSelect(sslState->server.fd,
@@ -207,7 +207,7 @@ sslWriteServer(int fd, void *data)
 		sslState, 0);
 	    return;
 	}
-	debug(50, 2, "sslWriteServer: FD %d: write failure: %s.\n",
+	debug(50, 2) ("sslWriteServer: FD %d: write failure: %s.\n",
 	    sslState->server.fd, xstrerror());
 	sslClose(sslState);
 	return;
@@ -233,15 +233,15 @@ sslWriteClient(int fd, void *data)
 {
     SslStateData *sslState = data;
     int len;
-    debug(26, 5, "sslWriteClient FD %d len=%d offset=%d\n",
+    debug(26, 5) ("sslWriteClient FD %d len=%d offset=%d\n",
 	fd,
 	sslState->server.len,
 	sslState->server.offset);
     len = write(sslState->client.fd,
 	sslState->server.buf + sslState->server.offset,
 	sslState->server.len - sslState->server.offset);
     fd_bytes(fd, len, FD_WRITE);
-    debug(26, 5, "sslWriteClient FD %d, wrote %d bytes\n", fd, len);
+    debug(26, 5) ("sslWriteClient FD %d, wrote %d bytes\n", fd, len);
     if (len < 0) {
 	if (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK) {
 	    commSetSelect(sslState->client.fd,
@@ -250,7 +250,7 @@ sslWriteClient(int fd, void *data)
 		sslState, 0);
 	    return;
 	}
-	debug(50, 2, "sslWriteClient: FD %d: write failure: %s.\n",
+	debug(50, 2) ("sslWriteClient: FD %d: write failure: %s.\n",
 	    sslState->client.fd, xstrerror());
 	sslClose(sslState);
 	return;
@@ -276,15 +276,15 @@ static void
 sslTimeout(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslTimeout: FD %d\n", fd);
+    debug(26, 3) ("sslTimeout: FD %d\n", fd);
     sslClose(sslState);
 }
 
 static void
 sslConnected(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslConnected: FD %d sslState=%p\n", fd, sslState);
+    debug(26, 3) ("sslConnected: FD %d sslState=%p\n", fd, sslState);
     strcpy(sslState->server.buf, conn_established);
     sslState->server.len = strlen(conn_established);
     sslState->server.offset = 0;
@@ -318,7 +318,7 @@ sslConnectDone(int fd, int status, void *data)
     request_t *request = sslState->request;
     char *buf = NULL;
     if (status == COMM_ERR_DNS) {
-	debug(26, 4, "sslConnect: Unknown host: %s\n", sslState->host);
+	debug(26, 4) ("sslConnect: Unknown host: %s\n", sslState->host);
 	buf = squid_error_url(sslState->url,
 	    request->method,
 	    ERR_DNS_FAIL,
@@ -362,7 +362,7 @@ sslStart(int fd, const char *url, request_t * request, int *size_ptr)
     SslStateData *sslState = NULL;
     int sock;
     char *buf = NULL;
-    debug(26, 3, "sslStart: '%s %s'\n",
+    debug(26, 3) ("sslStart: '%s %s'\n",
 	RequestMethodStr[request->method], url);
     /* Create socket. */
     sock = comm_open(SOCK_STREAM,
@@ -372,7 +372,7 @@ sslStart(int fd, const char *url, request_t * request, int *size_ptr)
 	COMM_NONBLOCKING,
 	url);
     if (sock == COMM_ERROR) {
-	debug(26, 4, "sslStart: Failed because we're out of sockets.\n");
+	debug(26, 4) ("sslStart: Failed because we're out of sockets.\n");
 	buf = squid_error_url(url,
 	    request->method,
 	    ERR_NO_FDS,
@@ -417,9 +417,9 @@ static void
 sslProxyConnected(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslProxyConnected: FD %d sslState=%p\n", fd, sslState);
+    debug(26, 3) ("sslProxyConnected: FD %d sslState=%p\n", fd, sslState);
     sprintf(sslState->client.buf, "CONNECT %s HTTP/1.0\r\n\r\n", sslState->url);
-    debug(26, 3, "sslProxyConnected: Sending 'CONNECT %s HTTP/1.0'\n", sslState->url);
+    debug(26, 3) ("sslProxyConnected: Sending 'CONNECT %s HTTP/1.0'\n", sslState->url);
     sslState->client.len = strlen(sslState->client.buf);
     sslState->client.offset = 0;
     commSetSelect(sslState->server.fd,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.140 1997/06/02 05:39:48 wessels Exp $
+ * $Id: stat.cc,v 1.141 1997/06/04 06:16:10 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -396,7 +396,7 @@ stat_objects_get(const cacheinfo * obj, StoreEntry * sentry, int vm_or_not)
 	    continue;
 	if ((++N & 0xFF) == 0) {
 	    getCurrentTime();
-	    debug(18, 3, "stat_objects_get:  Processed %d objects...\n", N);
+	    debug(18, 3) ("stat_objects_get:  Processed %d objects...\n", N);
 	}
 	storeAppendPrintf(sentry, "{%s %dL %-25s %s %3d %2d %8d %s}\n",
 	    describeStatuses(entry),
@@ -496,7 +496,7 @@ log_get_start(const cacheinfo * obj, StoreEntry * sentry)
     }
     fd = file_open(obj->logfilename, O_RDONLY, NULL, NULL);
     if (fd < 0) {
-	debug(50, 0, "Cannot open logfile: %s: %s\n",
+	debug(50, 0) ("Cannot open logfile: %s: %s\n",
 	    obj->logfilename, xstrerror());
 	return;
     }
@@ -1148,7 +1148,7 @@ log_append(const cacheinfo * obj,
 	if (msize + strlen(ereq) + strlen(erep) + 7 <= sizeof(tmp))
 	    sprintf(tmp + msize - 1, " [%s] [%s]\n", ereq, erep);
 	else
-	    debug(18, 1, "log_append: Long headers not logged.\n");
+	    debug(18, 1) ("log_append: Long headers not logged.\n");
 	safe_free(ereq);
 	safe_free(erep);
     }
@@ -1160,7 +1160,7 @@ log_append(const cacheinfo * obj,
 	NULL,
 	xfree);
     if (x != DISK_OK)
-	debug(18, 1, "log_append: File write failed.\n");
+	debug(18, 1) ("log_append: File write failed.\n");
 }
 
 static void
@@ -1172,7 +1172,7 @@ log_enable(cacheinfo * obj, StoreEntry * sentry)
 	/* open the logfile */
 	obj->logfile_fd = file_open(obj->logfilename, O_WRONLY | O_CREAT, NULL, NULL);
 	if (obj->logfile_fd == DISK_ERROR) {
-	    debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
+	    debug(18, 0) ("Cannot open logfile: %s\n", obj->logfilename);
 	    obj->logfile_status = LOG_DISABLE;
 	}
     }
@@ -1205,7 +1205,7 @@ log_clear(cacheinfo * obj, StoreEntry * sentry)
     /* reopen it anyway */
     obj->logfile_fd = file_open(obj->logfilename, O_WRONLY | O_CREAT, NULL, NULL);
     if (obj->logfile_fd == DISK_ERROR) {
-	debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
+	debug(18, 0) ("Cannot open logfile: %s\n", obj->logfilename);
 	obj->logfile_status = LOG_DISABLE;
     }
     /* at the moment, store one char to make a storage manager happy */
@@ -1278,7 +1278,7 @@ stat_init(cacheinfo ** object, const char *logfilename)
     cacheinfo *obj = NULL;
     int i;
 
-    debug(18, 5, "stat_init: Initializing...\n");
+    debug(18, 5) ("stat_init: Initializing...\n");
     obj = xcalloc(1, sizeof(cacheinfo));
     obj->stat_get = stat_get;
     obj->info_get = info_get;
@@ -1298,7 +1298,7 @@ stat_init(cacheinfo ** object, const char *logfilename)
 	xstrncpy(obj->logfilename, logfilename, SQUID_MAXPATHLEN);
 	obj->logfile_fd = file_open(obj->logfilename, O_WRONLY | O_CREAT, NULL, NULL);
 	if (obj->logfile_fd == DISK_ERROR) {
-	    debug(50, 0, "%s: %s\n", obj->logfilename, xstrerror());
+	    debug(50, 0) ("%s: %s\n", obj->logfilename, xstrerror());
 	    fatal("Cannot open logfile.");
 	}
     }
@@ -1365,7 +1365,7 @@ stat_rotate_log(void)
 	    return;
 #endif
 
-    debug(18, 1, "stat_rotate_log: Rotating\n");
+    debug(18, 1) ("stat_rotate_log: Rotating\n");
 
     /* Rotate numbers 0 through N up one */
     for (i = Config.Log.rotateNumber; i > 1;) {
@@ -1384,7 +1384,7 @@ stat_rotate_log(void)
     file_close(HTTPCacheInfo->logfile_fd);
     HTTPCacheInfo->logfile_fd = file_open(fname, O_WRONLY | O_CREAT, NULL, NULL);
     if (HTTPCacheInfo->logfile_fd == DISK_ERROR) {
-	debug(18, 0, "stat_rotate_log: Cannot open logfile: %s\n", fname);
+	debug(18, 0) ("stat_rotate_log: Cannot open logfile: %s\n", fname);
 	HTTPCacheInfo->logfile_status = LOG_DISABLE;
 	fatal("Cannot open logfile.");
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stmem.cc,v 1.42 1997/06/01 23:21:49 wessels Exp $
+ * $Id: stmem.cc,v 1.43 1997/06/04 06:16:10 wessels Exp $
  *
  * DEBUG: section 19    Memory Primitives
  * AUTHOR: Harvest Derived
@@ -194,8 +194,8 @@ memFreeDataUpto(mem_ptr mem, int target_offset)
 	return current_offset;
     }
     if (current_offset != target_offset) {
-	debug(19, 1, "memFreeDataUpto: This shouldn't happen. Some odd condition.\n");
-	debug(19, 1, "   Current offset: %d  Target offset: %d  p: %p\n",
+	debug(19, 1) ("memFreeDataUpto: This shouldn't happen. Some odd condition.\n");
+	debug(19, 1) ("   Current offset: %d  Target offset: %d  p: %p\n",
 	    current_offset, target_offset, p);
     }
     return current_offset;
@@ -210,7 +210,7 @@ memAppend(mem_ptr mem, const char *data, int len)
     int avail_len;
     int len_to_copy;
 
-    debug(19, 6, "memAppend: len %d\n", len);
+    debug(19, 6) ("memAppend: len %d\n", len);
 
     /* Does the last block still contain empty space? 
      * If so, fill out the block before dropping into the
@@ -255,7 +255,7 @@ memCopy(const mem_ptr mem, off_t offset, char *buf, size_t size)
     char *ptr_to_buf = NULL;
     int bytes_from_this_packet = 0;
     int bytes_into_this_packet = 0;
-    debug(19, 6, "memCopy: offset %d: size %d\n", offset, size);
+    debug(19, 6) ("memCopy: offset %d: size %d\n", offset, size);
     if (p == NULL)
 	return -1;
     /*      fatal_dump("memCopy: NULL mem_node"); *//* Can happen on async */
@@ -404,7 +404,7 @@ stmemInit(void)
     mem_obj_pool.max_pages = Squid_MaxFD >> 3;
 
 #if PURIFY
-    debug(19, 0, "Disabling stacks under purify\n");
+    debug(19, 0) ("Disabling stacks under purify\n");
     sm_stats.max_pages = 0;
     disk_stats.max_pages = 0;
     request_pool.max_pages = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.251 1997/06/04 05:50:29 wessels Exp $
+ * $Id: store.cc,v 1.252 1997/06/04 06:16:11 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -340,7 +340,7 @@ new_MemObject(void)
     mem->request = NULL;
     meta_data.mem_obj_count++;
     meta_data.misc += sizeof(struct _http_reply);
-    debug(20, 3, "new_MemObject: returning %p\n", mem);
+    debug(20, 3) ("new_MemObject: returning %p\n", mem);
     return mem;
 }
 
@@ -353,14 +353,14 @@ new_StoreEntry(int mem_obj_flag)
     meta_data.store_entries++;
     if (mem_obj_flag)
 	e->mem_obj = new_MemObject();
-    debug(20, 3, "new_StoreEntry: returning %p\n", e);
+    debug(20, 3) ("new_StoreEntry: returning %p\n", e);
     return e;
 }
 
 static void
 destroy_MemObject(MemObject * mem)
 {
-    debug(20, 3, "destroy_MemObject: destroying %p\n", mem);
+    debug(20, 3) ("destroy_MemObject: destroying %p\n", mem);
     destroy_MemObjectData(mem);
     safe_free(mem->clients);
     safe_free(mem->reply);
@@ -375,7 +375,7 @@ destroy_MemObject(MemObject * mem)
 static void
 destroy_StoreEntry(StoreEntry * e)
 {
-    debug(20, 3, "destroy_StoreEntry: destroying %p\n", e);
+    debug(20, 3) ("destroy_StoreEntry: destroying %p\n", e);
     if (!e) {
 	debug_trap("destroy_StoreEntry: NULL Entry");
 	return;
@@ -386,7 +386,7 @@ destroy_StoreEntry(StoreEntry * e)
 	meta_data.url_strings -= strlen(e->url);
 	safe_free(e->url);
     } else {
-	debug(20, 3, "destroy_StoreEntry: WARNING: Entry without URL string!\n");
+	debug(20, 3) ("destroy_StoreEntry: WARNING: Entry without URL string!\n");
     }
     if (BIT_TEST(e->flag, KEY_URL))
 	e->key = NULL;
@@ -399,15 +399,15 @@ destroy_StoreEntry(StoreEntry * e)
 static mem_ptr
 new_MemObjectData(void)
 {
-    debug(20, 3, "new_MemObjectData: calling memInit()\n");
+    debug(20, 3) ("new_MemObjectData: calling memInit()\n");
     meta_data.mem_data_count++;
     return memInit();
 }
 
 static void
 destroy_MemObjectData(MemObject * mem)
 {
-    debug(20, 3, "destroy_MemObjectData: destroying %p, %d bytes\n",
+    debug(20, 3) ("destroy_MemObjectData: destroying %p, %d bytes\n",
 	mem->data, mem->e_current_len);
     store_mem_size -= ENTRY_INMEM_SIZE(mem);
     if (mem->data) {
@@ -455,7 +455,7 @@ storeHashMemDelete(StoreEntry * e)
 static int
 storeHashInsert(StoreEntry * e)
 {
-    debug(20, 3, "storeHashInsert: Inserting Entry %p key '%s'\n",
+    debug(20, 3) ("storeHashInsert: Inserting Entry %p key '%s'\n",
 	e, e->key);
     if (e->mem_status == IN_MEMORY)
 	storeHashMemInsert(e);
@@ -528,7 +528,7 @@ storeLog(int tag, const StoreEntry * e)
 static void
 storePurgeMem(StoreEntry * e)
 {
-    debug(20, 3, "storePurgeMem: Freeing memory-copy of %s\n", e->key);
+    debug(20, 3) ("storePurgeMem: Freeing memory-copy of %s\n", e->key);
     if (e->mem_obj == NULL)
 	return;
     storeSetMemStatus(e, NOT_IN_MEMORY);
@@ -540,7 +540,7 @@ void
 storeLockObject(StoreEntry * e)
 {
     e->lock_count++;
-    debug(20, 3, "storeLockObject: key '%s' count=%d\n",
+    debug(20, 3) ("storeLockObject: key '%s' count=%d\n",
 	e->key, (int) e->lock_count);
     e->lastref = squid_curtime;
 }
@@ -552,7 +552,7 @@ storeReleaseRequest(StoreEntry * e)
 	return;
     if (!storeEntryLocked(e))
 	fatal_dump("storeReleaseRequest: unlocked entry");
-    debug(20, 3, "storeReleaseRequest: '%s'\n", e->key);
+    debug(20, 3) ("storeReleaseRequest: '%s'\n", e->key);
     BIT_SET(e->flag, RELEASE_REQUEST);
     storeSetPrivateKey(e);
 }
@@ -564,7 +564,7 @@ storeUnlockObject(StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
     e->lock_count--;
-    debug(20, 3, "storeUnlockObject: key '%s' count=%d\n",
+    debug(20, 3) ("storeUnlockObject: key '%s' count=%d\n",
 	e->key, e->lock_count);
     if (e->lock_count)
 	return (int) e->lock_count;
@@ -598,7 +598,7 @@ storeUnlockObject(StoreEntry * e)
 StoreEntry *
 storeGet(const char *url)
 {
-    debug(20, 3, "storeGet: looking up %s\n", url);
+    debug(20, 3) ("storeGet: looking up %s\n", url);
     return (StoreEntry *) hash_lookup(store_table, url);
 }
 
@@ -633,7 +633,7 @@ storeGeneratePrivateKey(const char *url, method_t method, int num)
 	method = (method_t) (num >> 24);
 	num &= 0x00FFFFFF;
     }
-    debug(20, 3, "storeGeneratePrivateKey: '%s'\n", url);
+    debug(20, 3) ("storeGeneratePrivateKey: '%s'\n", url);
     key_temp_buffer[0] = '\0';
     sprintf(key_temp_buffer, "%d/%s/%s",
 	num,
@@ -645,7 +645,7 @@ storeGeneratePrivateKey(const char *url, method_t method, int num)
 const char *
 storeGeneratePublicKey(const char *url, method_t method)
 {
-    debug(20, 3, "storeGeneratePublicKey: type=%d %s\n", method, url);
+    debug(20, 3) ("storeGeneratePublicKey: type=%d %s\n", method, url);
     switch (method) {
     case METHOD_GET:
 	return url;
@@ -703,7 +703,7 @@ storeSetPublicKey(StoreEntry * e)
 
     newkey = storeGeneratePublicKey(e->url, e->method);
     while ((table_entry = hash_lookup(store_table, newkey))) {
-	debug(20, 3, "storeSetPublicKey: Making old '%s' private.\n", newkey);
+	debug(20, 3) ("storeSetPublicKey: Making old '%s' private.\n", newkey);
 	e2 = (StoreEntry *) table_entry;
 	storeSetPrivateKey(e2);
 	storeRelease(e2);
@@ -733,7 +733,7 @@ storeCreateEntry(const char *url, int flags, method_t method)
 {
     StoreEntry *e = NULL;
     MemObject *mem = NULL;
-    debug(20, 3, "storeCreateEntry: '%s' icp flags=%x\n", url, flags);
+    debug(20, 3) ("storeCreateEntry: '%s' icp flags=%x\n", url, flags);
 
     e = new_StoreEntry(WITH_MEMOBJ);
     e->lock_count = 1;		/* Note lock here w/o calling storeLock() */
@@ -783,7 +783,7 @@ storeAddDiskRestore(const char *url, int file_number, int size, time_t expires,
 {
     StoreEntry *e = NULL;
 
-    debug(20, 5, "StoreAddDiskRestore: '%s': size %d: expires %d: fileno=%08X\n",
+    debug(20, 5) ("StoreAddDiskRestore: '%s': size %d: expires %d: fileno=%08X\n",
 	url, size, expires, file_number);
 
     /* if you call this you'd better be sure file_number is not 
@@ -829,15 +829,15 @@ storeUnregister(StoreEntry * e, void *data)
     struct _store_client *sc;
     if (mem == NULL)
 	return 0;
-    debug(20, 3, "storeUnregister: called for '%s'\n", e->key);
+    debug(20, 3) ("storeUnregister: called for '%s'\n", e->key);
     if ((i = storeClientListSearch(mem, data)) < 0)
 	return 0;
     sc = &mem->clients[i];
     sc->seen_offset = 0;
     sc->copy_offset = 0;
     sc->callback = NULL;
     sc->callback_data = NULL;
-    debug(20, 9, "storeUnregister: returning 1\n");
+    debug(20, 9) ("storeUnregister: returning 1\n");
     return 1;
 }
 
@@ -907,7 +907,7 @@ InvokeHandlers(StoreEntry * e)
 void
 storeExpireNow(StoreEntry * e)
 {
-    debug(20, 3, "storeExpireNow: '%s'\n", e->key);
+    debug(20, 3) ("storeExpireNow: '%s'\n", e->key);
     e->expires = squid_curtime;
 }
 
@@ -918,8 +918,8 @@ storeStartDeleteBehind(StoreEntry * e)
 {
     if (BIT_TEST(e->flag, DELETE_BEHIND))
 	return;
-    debug(20, e->mem_obj->e_current_len ? 1 : 3,
-	"storeStartDeleteBehind: '%s' at %d bytes\n",
+    debug(20, e->mem_obj->e_current_len ? 1 : 3)
+	("storeStartDeleteBehind: '%s' at %d bytes\n",
 	e->url, e->mem_obj->e_current_len);
     storeSetPrivateKey(e);
     BIT_SET(e->flag, DELETE_BEHIND);
@@ -936,7 +936,7 @@ storeAppend(StoreEntry * e, const char *buf, int len)
     assert(mem != NULL);
     assert(len >= 0);
     if (len) {
-	debug(20, 5, "storeAppend: appending %d bytes for '%s'\n", len, e->key);
+	debug(20, 5) ("storeAppend: appending %d bytes for '%s'\n", len, e->key);
 	storeGetMemSpace(len);
 	if (sm_stats.n_pages_in_use > store_pages_low) {
 	    if (mem->e_current_len > Config.Store.maxObjectSize)
@@ -983,18 +983,18 @@ storeSwapInHandle(int u1, const char *buf, int len, int flag, void *data)
     StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
     assert(mem);
-    debug(20, 2, "storeSwapInHandle: '%s'\n", e->key);
+    debug(20, 2) ("storeSwapInHandle: '%s'\n", e->key);
     if ((flag < 0) && (flag != DISK_EOF)) {
-	debug(20, 0, "storeSwapInHandle: SwapIn failure (err code = %d).\n", flag);
+	debug(20, 0) ("storeSwapInHandle: SwapIn failure (err code = %d).\n", flag);
 	put_free_8k_page(mem->e_swap_buf);
 	storeSetMemStatus(e, NOT_IN_MEMORY);
 	file_close(mem->swapin_fd);
 	swapInError(-1, e);	/* Invokes storeAbort() and completes the I/O */
 	return;
     }
-    debug(20, 5, "storeSwapInHandle: e->swap_offset   = %d\n", mem->swap_offset);
-    debug(20, 5, "storeSwapInHandle: e->e_current_len = %d\n", mem->e_current_len);
-    debug(20, 5, "storeSwapInHandle: e->object_len    = %d\n", e->object_len);
+    debug(20, 5) ("storeSwapInHandle: e->swap_offset   = %d\n", mem->swap_offset);
+    debug(20, 5) ("storeSwapInHandle: e->e_current_len = %d\n", mem->e_current_len);
+    debug(20, 5) ("storeSwapInHandle: e->object_len    = %d\n", e->object_len);
     if (len && mem->swap_offset == 0)
 	httpParseReplyHeaders(buf, mem->reply);
     /* Assumes we got all the headers in one read() */
@@ -1018,14 +1018,14 @@ storeSwapInHandle(int u1, const char *buf, int len, int flag, void *data)
     put_free_8k_page(mem->e_swap_buf);
     file_close(mem->swapin_fd);
     storeLog(STORE_LOG_SWAPIN, e);
-    debug(20, 5, "storeSwapInHandle: SwapIn complete: '%s' from %s.\n",
+    debug(20, 5) ("storeSwapInHandle: SwapIn complete: '%s' from %s.\n",
 	e->url, storeSwapFullPath(e->swap_file_number, NULL));
     if (mem->e_current_len != e->object_len) {
 	debug_trap("storeSwapInHandle: Object size mismatch");
-	debug(20, 0, "  --> '%s'\n", e->url);
-	debug(20, 0, "  --> Expecting %d bytes from file: %s\n", e->object_len,
+	debug(20, 0) ("  --> '%s'\n", e->url);
+	debug(20, 0) ("  --> Expecting %d bytes from file: %s\n", e->object_len,
 	    storeSwapFullPath(e->swap_file_number, NULL));
-	debug(20, 0, "  --> Only read %d bytes\n",
+	debug(20, 0) ("  --> Only read %d bytes\n",
 	    mem->e_current_len);
     }
     e->lock_count++;		/* lock while calling handler */
@@ -1101,7 +1101,7 @@ storeSwapInStartComplete(void *data, int fd)
     assert(e->mem_status == NOT_IN_MEMORY);
     assert(e->swap_status == SWAP_OK);
     if (fd < 0) {
-	debug(20, 0, "storeSwapInStartComplete: Failed for '%s'\n", e->url);
+	debug(20, 0) ("storeSwapInStartComplete: Failed for '%s'\n", e->url);
 	/* Invoke a store abort that should free the memory object */
 	(ctrlp->callback) (ctrlp->callback_data, -1);
 	xfree(ctrlp->path);
@@ -1110,7 +1110,7 @@ storeSwapInStartComplete(void *data, int fd)
     }
     storeSetMemStatus(e, SWAPPING_IN);
     mem->swapin_fd = (short) fd;
-    debug(20, 5, "storeSwapInStart: initialized swap file '%s' for '%s'\n",
+    debug(20, 5) ("storeSwapInStart: initialized swap file '%s' for '%s'\n",
 	ctrlp->path, e->url);
     mem->data = new_MemObjectData();
     mem->swap_offset = 0;
@@ -1132,11 +1132,11 @@ storeSwapOutHandle(int fd, int flag, size_t len, void *data)
 {
     StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
-    debug(20, 3, "storeSwapOutHandle: '%s'\n", e->key);
+    debug(20, 3) ("storeSwapOutHandle: '%s'\n", e->key);
     if (mem == NULL)
 	fatal_dump("storeSwapOutHandle: NULL mem_obj");
     if (flag < 0) {
-	debug(20, 1, "storeSwapOutHandle: SwapOut failure (err code = %d).\n",
+	debug(20, 1) ("storeSwapOutHandle: SwapOut failure (err code = %d).\n",
 	    flag);
 	e->swap_status = NO_SWAP;
 	put_free_8k_page(mem->e_swap_buf);
@@ -1153,10 +1153,10 @@ storeSwapOutHandle(int fd, int flag, size_t len, void *data)
 	}
 	return;
     }
-    debug(20, 6, "storeSwapOutHandle: e->swap_offset    = %d\n", mem->swap_offset);
-    debug(20, 6, "storeSwapOutHandle: e->e_swap_buf_len = %d\n", mem->e_swap_buf_len);
-    debug(20, 6, "storeSwapOutHandle: e->object_len     = %d\n", e->object_len);
-    debug(20, 6, "storeSwapOutHandle: store_swap_size   = %dk\n", store_swap_size);
+    debug(20, 6) ("storeSwapOutHandle: e->swap_offset    = %d\n", mem->swap_offset);
+    debug(20, 6) ("storeSwapOutHandle: e->e_swap_buf_len = %d\n", mem->e_swap_buf_len);
+    debug(20, 6) ("storeSwapOutHandle: e->object_len     = %d\n", e->object_len);
+    debug(20, 6) ("storeSwapOutHandle: store_swap_size   = %dk\n", store_swap_size);
     mem->swap_offset += mem->e_swap_buf_len;
     /* round up */
     storeDirUpdateSwapSize(e->swap_file_number, mem->e_swap_buf_len, 1);
@@ -1165,7 +1165,7 @@ storeSwapOutHandle(int fd, int flag, size_t len, void *data)
 	e->swap_status = SWAP_OK;
 	file_close(mem->swapout_fd);
 	storeLog(STORE_LOG_SWAPOUT, e);
-	debug(20, 5, "storeSwapOutHandle: SwapOut complete: '%s' to %s.\n",
+	debug(20, 5) ("storeSwapOutHandle: SwapOut complete: '%s' to %s.\n",
 	    e->url, storeSwapFullPath(e->swap_file_number, NULL));
 	put_free_8k_page(mem->e_swap_buf);
 	storeDirSwapLog(e);
@@ -1186,7 +1186,7 @@ storeSwapOutHandle(int fd, int flag, size_t len, void *data)
     }
     /* write some more data, reschedule itself. */
     if (storeCopy(e, mem->swap_offset, SWAP_BUF, mem->e_swap_buf, &(mem->e_swap_buf_len)) < 0) {
-	debug(20, 1, "storeSwapOutHandle: SwapOut failure (err code = %d).\n",
+	debug(20, 1) ("storeSwapOutHandle: SwapOut failure (err code = %d).\n",
 	    flag);
 	e->swap_status = NO_SWAP;
 	put_free_8k_page(mem->e_swap_buf);
@@ -1239,7 +1239,7 @@ storeSwapOutStartComplete(void *data, int fd)
     MemObject *mem;
     xfree(ctrlp);
     if (fd < 0) {
-	debug(20, 0, "storeSwapOutStart: Unable to open swapfile: %s\n",
+	debug(20, 0) ("storeSwapOutStart: Unable to open swapfile: %s\n",
 	    swapfilename);
 	storeDirMapBitReset(e->swap_file_number);
 	e->swap_file_number = -1;
@@ -1250,9 +1250,9 @@ storeSwapOutStartComplete(void *data, int fd)
     }
     mem = e->mem_obj;
     mem->swapout_fd = (short) fd;
-    debug(20, 5, "storeSwapOutStart: Begin SwapOut '%s' to FD %d FILE %s.\n",
+    debug(20, 5) ("storeSwapOutStart: Begin SwapOut '%s' to FD %d FILE %s.\n",
 	e->url, fd, swapfilename);
-    debug(20, 5, "swap_file_number=%08X\n", e->swap_file_number);
+    debug(20, 5) ("swap_file_number=%08X\n", e->swap_file_number);
     e->swap_status = SWAPPING_OUT;
     mem->swap_offset = 0;
     mem->e_swap_buf = get_free_8k_page();
@@ -1263,7 +1263,7 @@ storeSwapOutStartComplete(void *data, int fd)
 	mem->e_swap_buf,
 	&mem->e_swap_buf_len);
     if (x < 0) {
-	debug(20, 1, "storeCopy returned %d for '%s'\n", x, e->key);
+	debug(20, 1) ("storeCopy returned %d for '%s'\n", x, e->key);
 	e->swap_file_number = -1;
 	file_close(fd);
 	storeDirMapBitReset(e->swap_file_number);
@@ -1318,7 +1318,7 @@ storeDoRebuildFromDisk(void *data)
     }
     for (count = 0; count < d->speed; count++) {
 	if (fgets(RB->line_in, RB->line_in_sz, d->log) == NULL) {
-	    debug(20, 1, "Done reading Cache Dir #%d swap log\n", d->dirn);
+	    debug(20, 1) ("Done reading Cache Dir #%d swap log\n", d->dirn);
 	    fclose(d->log);
 	    d->log = NULL;
 	    storeDirCloseTmpSwapLog(d->dirn);
@@ -1328,8 +1328,8 @@ storeDoRebuildFromDisk(void *data)
 	    return;
 	}
 	if ((++RB->linecount & 0x3FFF) == 0)
-	    debug(20, 1, "  %7d Lines read so far.\n", RB->linecount);
-	debug(20, 9, "line_in: %s", RB->line_in);
+	    debug(20, 1) ("  %7d Lines read so far.\n", RB->linecount);
+	debug(20, 9) ("line_in: %s", RB->line_in);
 	if (RB->line_in[0] == '\0')
 	    continue;
 	if (RB->line_in[0] == '\n')
@@ -1388,7 +1388,7 @@ storeDoRebuildFromDisk(void *data)
 	     * point.  If the log is dirty, the filesize check should have
 	     * caught this.  If the log is clean, there should never be a
 	     * newer entry. */
-	    debug(20, 1, "WARNING: newer swaplog entry for fileno %08X\n",
+	    debug(20, 1) ("WARNING: newer swaplog entry for fileno %08X\n",
 		sfileno);
 	    assert(newer == 0);
 	    /* I'm tempted to remove the swapfile here just to be safe,
@@ -1444,8 +1444,8 @@ storeCleanup(void *data)
     hash_link *link_ptr = NULL;
     if (list == NULL) {
 	if (++bucketnum >= store_buckets) {
-	    debug(20, 1, "  Completed Validation Procedure\n");
-	    debug(20, 1, "  Validated %d Entries\n", validnum);
+	    debug(20, 1) ("  Completed Validation Procedure\n");
+	    debug(20, 1) ("  Validated %d Entries\n", validnum);
 	    store_rebuilding = 0;
 	    return;
 	}
@@ -1473,8 +1473,8 @@ storeCleanup(void *data)
     }
     if (!BIT_TEST(e->flag, ENTRY_VALIDATED)) {
 	storeValidate(e, storeCleanupComplete, e);
-        if ((++validnum & 0xFFF) == 0)
-	    debug(20, 1, "  %7d Entries Validated so far.\n", validnum);
+	if ((++validnum & 0xFFF) == 0)
+	    debug(20, 1) ("  %7d Entries Validated so far.\n", validnum);
     }
     xfree(curr->key);
     xfree(curr);
@@ -1554,20 +1554,20 @@ storeRebuiltFromDisk(struct storeRebuildState *data)
     time_t stop;
     stop = getCurrentTime();
     r = stop - data->start;
-    debug(20, 1, "Finished rebuilding storage from disk image.\n");
-    debug(20, 1, "  %7d Lines read from previous logfile.\n", data->linecount);
-    debug(20, 1, "  %7d Objects loaded.\n", data->objcount);
-    debug(20, 1, "  %7d Objects expired.\n", data->expcount);
-    debug(20, 1, "  %7d Duplicate URLs purged.\n", data->dupcount);
-    debug(20, 1, "  %7d Swapfile clashes avoided.\n", data->clashcount);
-    debug(20, 1, "  Took %d seconds (%6.1lf objects/sec).\n",
+    debug(20, 1) ("Finished rebuilding storage from disk image.\n");
+    debug(20, 1) ("  %7d Lines read from previous logfile.\n", data->linecount);
+    debug(20, 1) ("  %7d Objects loaded.\n", data->objcount);
+    debug(20, 1) ("  %7d Objects expired.\n", data->expcount);
+    debug(20, 1) ("  %7d Duplicate URLs purged.\n", data->dupcount);
+    debug(20, 1) ("  %7d Swapfile clashes avoided.\n", data->clashcount);
+    debug(20, 1) ("  Took %d seconds (%6.1lf objects/sec).\n",
 	r > 0 ? r : 0, (double) data->objcount / (r > 0 ? r : 1));
-    debug(20, 1, "  store_swap_size = %dk\n", store_swap_size);
+    debug(20, 1) ("  store_swap_size = %dk\n", store_swap_size);
     if (data->need_to_validate) {
-	debug(20, 1, "Beginning Validation Procedure\n");
+	debug(20, 1) ("Beginning Validation Procedure\n");
 	eventAdd("storeCleanup", storeCleanup, NULL, 0);
     } else {
-        store_rebuilding = 0;
+	store_rebuilding = 0;
     }
     safe_free(data->line_in);
     safe_free(data);
@@ -1596,7 +1596,7 @@ storeStartRebuildFromDisk(void)
 	RB->rebuild_dir = d;
 	if (!clean)
 	    RB->need_to_validate = 1;
-	debug(20, 1, "Rebuilding storage in Cache Dir #%d (%s)\n",
+	debug(20, 1) ("Rebuilding storage in Cache Dir #%d (%s)\n",
 	    i, clean ? "CLEAN" : "DIRTY");
     }
     RB->line_in_sz = 4096;
@@ -1612,18 +1612,18 @@ static int
 storeCheckSwapable(StoreEntry * e)
 {
     if (e->method != METHOD_GET) {
-	debug(20, 2, "storeCheckSwapable: NO: non-GET method\n");
+	debug(20, 2) ("storeCheckSwapable: NO: non-GET method\n");
     } else if (!BIT_TEST(e->flag, ENTRY_CACHABLE)) {
-	debug(20, 2, "storeCheckSwapable: NO: not cachable\n");
+	debug(20, 2) ("storeCheckSwapable: NO: not cachable\n");
     } else if (BIT_TEST(e->flag, RELEASE_REQUEST)) {
-	debug(20, 2, "storeCheckSwapable: NO: release requested\n");
+	debug(20, 2) ("storeCheckSwapable: NO: release requested\n");
     } else if (!storeEntryValidLength(e)) {
-	debug(20, 2, "storeCheckSwapable: NO: wrong content-length\n");
+	debug(20, 2) ("storeCheckSwapable: NO: wrong content-length\n");
     } else if (BIT_TEST(e->flag, ENTRY_NEGCACHED)) {
-	debug(20, 2, "storeCheckSwapable: NO: negative cached\n");
+	debug(20, 2) ("storeCheckSwapable: NO: negative cached\n");
 	return 0;		/* avoid release call below */
     } else if (e->mem_obj->e_current_len > Config.Store.maxObjectSize) {
-	debug(20, 2, "storeCheckSwapable: NO: too big\n");
+	debug(20, 2) ("storeCheckSwapable: NO: too big\n");
     } else {
 	return 1;
     }
@@ -1639,7 +1639,7 @@ storeCheckSwapable(StoreEntry * e)
 void
 storeComplete(StoreEntry * e)
 {
-    debug(20, 3, "storeComplete: '%s'\n", e->key);
+    debug(20, 3) ("storeComplete: '%s'\n", e->key);
     e->object_len = e->mem_obj->e_current_len;
     e->lastref = squid_curtime;
     e->store_status = STORE_OK;
@@ -1668,8 +1668,8 @@ storeAbort(StoreEntry * e, const char *msg)
     MemObject *mem = e->mem_obj;
     assert(e->store_status == STORE_PENDING);
     assert(mem != NULL);
-    /*assert(ping_status != PING_WAITING);*/
-    debug(20, 6, "storeAbort: '%s'\n", e->key);
+    /*assert(ping_status != PING_WAITING); */
+    debug(20, 6) ("storeAbort: '%s'\n", e->key);
     storeNegativeCache(e);
     e->store_status = STORE_ABORTED;
     storeSetMemStatus(e, IN_MEMORY);
@@ -1762,11 +1762,11 @@ storePurgeOld(void *unused)
 		break;
 	}
 	if ((n & 0xFFF) == 0)
-	    debug(20, 2, "storeWalkThrough: %7d objects so far.\n", n);
+	    debug(20, 2) ("storeWalkThrough: %7d objects so far.\n", n);
 	if (storeCheckExpired(e, 1))
 	    count += storeRelease(e);
     }
-    debug(20, 0, "storePurgeOld: Removed %d objects\n", count);
+    debug(20, 0) ("storePurgeOld: Removed %d objects\n", count);
 }
 
 
@@ -1794,7 +1794,7 @@ storeGetMemSpace(int size)
 	return;
     if (store_rebuilding)
 	return;
-    debug(20, 2, "storeGetMemSpace: Starting, need %d pages\n", pages_needed);
+    debug(20, 2) ("storeGetMemSpace: Starting, need %d pages\n", pages_needed);
 
     list = xcalloc(meta_data.mem_obj_count, sizeof(ipcache_entry *));
     for (e = storeGetInMemFirst(); e; e = storeGetInMemNext()) {
@@ -1803,22 +1803,22 @@ storeGetMemSpace(int size)
 	if (storeEntryLocked(e))
 	    continue;
 	if (storeCheckExpired(e, 0)) {
-	    debug(20, 2, "storeGetMemSpace: Expired: %s\n", e->url);
+	    debug(20, 2) ("storeGetMemSpace: Expired: %s\n", e->url);
 	    n_expired++;
 	    storeRelease(e);
 	} else if (storeCheckPurgeMem(e)) {
-	    debug(20, 3, "storeGetMemSpace: Adding '%s'\n", e->url);
+	    debug(20, 3) ("storeGetMemSpace: Adding '%s'\n", e->url);
 	    *(list + list_count) = e;
 	    list_count++;
 	} else if (!storeEntryLocked(e)) {
-	    debug(20, 3, "storeGetMemSpace: Adding '%s'\n", e->url);
+	    debug(20, 3) ("storeGetMemSpace: Adding '%s'\n", e->url);
 	    *(list + list_count) = e;
 	    list_count++;
 	} else {
 	    n_locked++;
 	}
     }
-    debug(20, 5, "storeGetMemSpace: Sorting LRU_list: %7d items\n", list_count);
+    debug(20, 5) ("storeGetMemSpace: Sorting LRU_list: %7d items\n", list_count);
     qsort((char *) list,
 	list_count,
 	sizeof(StoreEntry *),
@@ -1843,18 +1843,18 @@ storeGetMemSpace(int size)
     i = 3;
     if (sm_stats.n_pages_in_use > store_pages_max) {
 	if (squid_curtime - last_warning > 600) {
-	    debug(20, 0, "WARNING: Exceeded 'cache_mem' size (%dK > %dK)\n",
+	    debug(20, 0) ("WARNING: Exceeded 'cache_mem' size (%dK > %dK)\n",
 		sm_stats.n_pages_in_use * 4, store_pages_max * 4);
 	    last_warning = squid_curtime;
-	    debug(20, 0, "Perhaps you should increase cache_mem?\n");
+	    debug(20, 0) ("Perhaps you should increase cache_mem?\n");
 	    i = 0;
 	}
     }
-    debug(20, i, "storeGetMemSpace stats:\n");
-    debug(20, i, "  %6d objects locked in memory\n", n_locked);
-    debug(20, i, "  %6d LRU candidates\n", list_count);
-    debug(20, i, "  %6d were purged\n", n_purged);
-    debug(20, i, "  %6d were released\n", n_released);
+    debug(20, i) ("storeGetMemSpace stats:\n");
+    debug(20, i) ("  %6d objects locked in memory\n", n_locked);
+    debug(20, i) ("  %6d LRU candidates\n", list_count);
+    debug(20, i) ("  %6d were purged\n", n_purged);
+    debug(20, i) ("  %6d were released\n", n_released);
     xfree(list);
 }
 
@@ -1930,13 +1930,13 @@ storeGetSwapSpace(int size)
     if (!fReduceSwap && (store_swap_size + kb_size <= store_swap_high)) {
 	return 0;
     }
-    debug(20, 2, "storeGetSwapSpace: Starting...\n");
+    debug(20, 2) ("storeGetSwapSpace: Starting...\n");
 
     /* Set flag if swap size over high-water-mark */
     if (store_swap_size + kb_size > store_swap_high)
 	fReduceSwap = 1;
 
-    debug(20, 2, "storeGetSwapSpace: Need %d bytes...\n", size);
+    debug(20, 2) ("storeGetSwapSpace: Need %d bytes...\n", size);
 
     LRU_list = xcalloc(max_list_count, sizeof(StoreEntry *));
     /* remove expired objects until recover enough or no expired objects */
@@ -1954,7 +1954,7 @@ storeGetSwapSpace(int size)
 	    if (!BIT_TEST(e->flag, ENTRY_VALIDATED))
 		continue;
 	    if (storeCheckExpired(e, 0)) {
-		debug(20, 3, "storeGetSwapSpace: Expired '%s'\n", e->url);
+		debug(20, 3) ("storeGetSwapSpace: Expired '%s'\n", e->url);
 		storeRelease(e);
 	    } else if (!storeEntryLocked(e)) {
 		*(LRU_list + list_count) = e;
@@ -1977,55 +1977,55 @@ storeGetSwapSpace(int size)
 
 #ifdef LOTSA_DEBUGGING
     /* end of candidate selection */
-    debug(20, 2, "storeGetSwapSpace: Current Size:   %7d kbytes\n",
+    debug(20, 2) ("storeGetSwapSpace: Current Size:   %7d kbytes\n",
 	store_swap_size);
-    debug(20, 2, "storeGetSwapSpace: High W Mark:    %7d kbytes\n",
+    debug(20, 2) ("storeGetSwapSpace: High W Mark:    %7d kbytes\n",
 	store_swap_high);
-    debug(20, 2, "storeGetSwapSpace: Low W Mark:     %7d kbytes\n",
+    debug(20, 2) ("storeGetSwapSpace: Low W Mark:     %7d kbytes\n",
 	store_swap_low);
-    debug(20, 2, "storeGetSwapSpace: Entry count:    %7d items\n",
+    debug(20, 2) ("storeGetSwapSpace: Entry count:    %7d items\n",
 	meta_data.store_entries);
-    debug(20, 2, "storeGetSwapSpace: Visited:        %7d buckets\n",
+    debug(20, 2) ("storeGetSwapSpace: Visited:        %7d buckets\n",
 	i + 1);
-    debug(20, 2, "storeGetSwapSpace: Scanned:        %7d items\n",
+    debug(20, 2) ("storeGetSwapSpace: Scanned:        %7d items\n",
 	scanned);
-    debug(20, 2, "storeGetSwapSpace: Expired:        %7d items\n",
+    debug(20, 2) ("storeGetSwapSpace: Expired:        %7d items\n",
 	expired);
-    debug(20, 2, "storeGetSwapSpace: Locked:         %7d items\n",
+    debug(20, 2) ("storeGetSwapSpace: Locked:         %7d items\n",
 	locked);
-    debug(20, 2, "storeGetSwapSpace: Locked Space:   %7d bytes\n",
+    debug(20, 2) ("storeGetSwapSpace: Locked Space:   %7d bytes\n",
 	locked_size);
-    debug(20, 2, "storeGetSwapSpace: Scan in array:  %7d bytes\n",
+    debug(20, 2) ("storeGetSwapSpace: Scan in array:  %7d bytes\n",
 	scan_in_objs);
-    debug(20, 2, "storeGetSwapSpace: LRU candidate:  %7d items\n",
+    debug(20, 2) ("storeGetSwapSpace: LRU candidate:  %7d items\n",
 	LRU_list->index);
 #endif /* LOTSA_DEBUGGING */
 
     for (i = 0; i < list_count; i++)
 	removed += storeRelease(*(LRU_list + i));
     if (store_swap_size + kb_size <= store_swap_low)
 	fReduceSwap = 0;
-    debug(20, 2, "storeGetSwapSpace: After Freeing Size:   %7d kbytes\n",
+    debug(20, 2) ("storeGetSwapSpace: After Freeing Size:   %7d kbytes\n",
 	store_swap_size);
     /* free the list */
     safe_free(LRU_list);
 
     if ((store_swap_size + kb_size > store_swap_high)) {
 	i = 2;
 	if (++swap_help > SWAP_MAX_HELP) {
-	    debug(20, 0, "WARNING: Repeated failures to free up disk space!\n");
+	    debug(20, 0) ("WARNING: Repeated failures to free up disk space!\n");
 	    i = 0;
 	}
-	debug(20, i, "storeGetSwapSpace: Disk usage is over high water mark\n");
-	debug(20, i, "--> store_swap_high = %d KB\n", store_swap_high);
-	debug(20, i, "--> store_swap_size = %d KB\n", store_swap_size);
-	debug(20, i, "--> asking for        %d KB\n", kb_size);
+	debug(20, i) ("storeGetSwapSpace: Disk usage is over high water mark\n");
+	debug(20, i) ("--> store_swap_high = %d KB\n", store_swap_high);
+	debug(20, i) ("--> store_swap_size = %d KB\n", store_swap_size);
+	debug(20, i) ("--> asking for        %d KB\n", kb_size);
     } else {
 	swap_help = 0;
     }
 
     getCurrentTime();		/* we may have taken more than one second */
-    debug(20, 2, "Removed %d objects\n", removed);
+    debug(20, 2) ("Removed %d objects\n", removed);
     return 0;
 }
 
@@ -2037,12 +2037,12 @@ storeRelease(StoreEntry * e)
 {
     StoreEntry *hentry = NULL;
     const char *hkey;
-    debug(20, 3, "storeRelease: Releasing: '%s'\n", e->key);
+    debug(20, 3) ("storeRelease: Releasing: '%s'\n", e->key);
     /* If, for any reason we can't discard this object because of an
      * outstanding request, mark it for pending release */
     if (storeEntryLocked(e)) {
 	storeExpireNow(e);
-	debug(20, 3, "storeRelease: Only setting RELEASE_REQUEST bit\n");
+	debug(20, 3) ("storeRelease: Only setting RELEASE_REQUEST bit\n");
 	storeReleaseRequest(e);
 	return 0;
     }
@@ -2053,7 +2053,7 @@ storeRelease(StoreEntry * e)
 	    storeExpireNow(hentry);
     }
     if (store_rebuilding) {
-	debug(20, 2, "storeRelease: Delaying release until store is rebuilt: '%s'\n",
+	debug(20, 2) ("storeRelease: Delaying release until store is rebuilt: '%s'\n",
 	    e->key ? e->key : e->url ? e->url : "NO URL");
 	storeExpireNow(e);
 	storeSetPrivateKey(e);
@@ -2150,7 +2150,7 @@ storeClientListAdd(StoreEntry * e, void *data)
 	    break;
     }
     if (i == mem->nclients) {
-	debug(20, 3, "storeClientListAdd: Growing clients for '%s'\n", e->url);
+	debug(20, 3) ("storeClientListAdd: Growing clients for '%s'\n", e->url);
 	oldlist = mem->clients;
 	oldsize = mem->nclients;
 	mem->nclients <<= 1;
@@ -2220,24 +2220,24 @@ storeEntryValidLength(const StoreEntry * e)
     hdr_sz = e->mem_obj->reply->hdr_sz;
     content_length = e->mem_obj->reply->content_length;
 
-    debug(20, 3, "storeEntryValidLength: Checking '%s'\n", e->key);
-    debug(20, 5, "storeEntryValidLength:     object_len = %d\n", e->object_len);
-    debug(20, 5, "storeEntryValidLength:         hdr_sz = %d\n", hdr_sz);
-    debug(20, 5, "storeEntryValidLength: content_length = %d\n", content_length);
+    debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", e->key);
+    debug(20, 5) ("storeEntryValidLength:     object_len = %d\n", e->object_len);
+    debug(20, 5) ("storeEntryValidLength:         hdr_sz = %d\n", hdr_sz);
+    debug(20, 5) ("storeEntryValidLength: content_length = %d\n", content_length);
 
     if (content_length == 0) {
-	debug(20, 5, "storeEntryValidLength: Zero content length; assume valid; '%s'\n",
+	debug(20, 5) ("storeEntryValidLength: Zero content length; assume valid; '%s'\n",
 	    e->key);
 	return 1;
     }
     if (hdr_sz == 0) {
-	debug(20, 5, "storeEntryValidLength: Zero header size; assume valid; '%s'\n",
+	debug(20, 5) ("storeEntryValidLength: Zero header size; assume valid; '%s'\n",
 	    e->key);
 	return 1;
     }
     diff = hdr_sz + content_length - e->object_len;
     if (diff != 0) {
-	debug(20, 3, "storeEntryValidLength: %d bytes too %s; '%s'\n",
+	debug(20, 3) ("storeEntryValidLength: %d bytes too %s; '%s'\n",
 	    diff < 0 ? -diff : diff,
 	    diff < 0 ? "small" : "big",
 	    e->key);
@@ -2278,10 +2278,10 @@ storeInitHashValues(void)
     int i;
     /* Calculate size of hash table (maximum currently 64k buckets).  */
     i = Config.Swap.maxSize / Config.Store.avgObjectSize;
-    debug(20, 1, "Swap maxSize %d kB, estimated %d objects\n",
+    debug(20, 1) ("Swap maxSize %d kB, estimated %d objects\n",
 	Config.Swap.maxSize, i);
     i /= Config.Store.objectsPerBucket;
-    debug(20, 1, "Target number of buckets: %d\n", i);
+    debug(20, 1) ("Target number of buckets: %d\n", i);
     /* ideally the full scan period should be configurable, for the
      * moment it remains at approximately 24 hours.  */
     if (i < 8192)
@@ -2296,7 +2296,7 @@ storeInitHashValues(void)
 	store_buckets = 65357, store_maintain_rate = 1;
     store_maintain_buckets = 1;
     storeRandomizeBuckets();
-    debug(20, 1, "Using %d Store buckets, maintain %d bucket%s every %d second%s\n",
+    debug(20, 1) ("Using %d Store buckets, maintain %d bucket%s every %d second%s\n",
 	store_buckets,
 	store_maintain_buckets,
 	store_maintain_buckets == 1 ? null_string : "s",
@@ -2315,7 +2315,7 @@ storeInit(void)
     else
 	storelog_fd = file_open(fname, O_WRONLY | O_CREAT, NULL, NULL);
     if (storelog_fd < 0)
-	debug(20, 1, "Store logging disabled\n");
+	debug(20, 1) ("Store logging disabled\n");
     if (ncache_dirs < 1)
 	fatal("No cache_dir's specified in config file");
     storeVerifySwapDirs();
@@ -2389,7 +2389,7 @@ storeMaintainSwapSpace(void *unused)
 	    if (bucket_index >= store_buckets) {
 		bucket_index = 0;
 		scan_revolutions++;
-		debug(51, 1, "Completed %d full expiration scans of store table\n",
+		debug(51, 1) ("Completed %d full expiration scans of store table\n",
 		    scan_revolutions);
 		storeRandomizeBuckets();
 	    }
@@ -2405,7 +2405,7 @@ storeMaintainSwapSpace(void *unused)
 	    }
 	}
     }
-    debug(51, rm_obj ? 2 : 9, "Removed %d of %d objects from bucket %d\n",
+    debug(51, rm_obj ? 2 : 9) ("Removed %d of %d objects from bucket %d\n",
 	rm_obj, scan_obj, (int) b->bucket);
     /* Scan row of hash table each second and free storage if we're
      * over the high-water mark */
@@ -2432,11 +2432,11 @@ storeWriteCleanLogs(void)
     char **cln;
     int dirn;
     if (store_rebuilding) {
-	debug(20, 1, "Not currently OK to rewrite swap log.\n");
-	debug(20, 1, "storeWriteCleanLogs: Operation aborted.\n");
+	debug(20, 1) ("Not currently OK to rewrite swap log.\n");
+	debug(20, 1) ("storeWriteCleanLogs: Operation aborted.\n");
 	return 0;
     }
-    debug(20, 1, "storeWriteCleanLogs: Starting...\n");
+    debug(20, 1) ("storeWriteCleanLogs: Starting...\n");
     start = getCurrentTime();
     fd = xcalloc(ncache_dirs, sizeof(int));
     cur = xcalloc(ncache_dirs, sizeof(char *));
@@ -2454,7 +2454,7 @@ storeWriteCleanLogs(void)
 	    NULL,
 	    NULL);
 	if (fd[dirn] < 0) {
-	    debug(50, 0, "storeWriteCleanLogs: %s: %s\n", new[dirn], xstrerror());
+	    debug(50, 0) ("storeWriteCleanLogs: %s: %s\n", new[dirn], xstrerror());
 	    continue;
 	}
 #if HAVE_FCHMOD
@@ -2488,33 +2488,33 @@ storeWriteCleanLogs(void)
 	    e->object_len,
 	    e->url);
 	if (write(fd[dirn], line, strlen(line)) < 0) {
-	    debug(50, 0, "storeWriteCleanLogs: %s: %s\n", new[dirn], xstrerror());
-	    debug(20, 0, "storeWriteCleanLogs: Current swap logfile not replaced.\n");
+	    debug(50, 0) ("storeWriteCleanLogs: %s: %s\n", new[dirn], xstrerror());
+	    debug(20, 0) ("storeWriteCleanLogs: Current swap logfile not replaced.\n");
 	    file_close(fd[dirn]);
 	    fd[dirn] = -1;
 	    safeunlink(cln[dirn], 0);
 	    continue;
 	}
 	if ((++n & 0x3FFF) == 0) {
 	    getCurrentTime();
-	    debug(20, 1, "  %7d lines written so far.\n", n);
+	    debug(20, 1) ("  %7d lines written so far.\n", n);
 	}
     }
     safe_free(line);
     for (dirn = 0; dirn < ncache_dirs; dirn++) {
 	file_close(fd[dirn]);
 	fd[dirn] = -1;
 	if (rename(new[dirn], cur[dirn]) < 0) {
-	    debug(50, 0, "storeWriteCleanLogs: rename failed: %s\n",
+	    debug(50, 0) ("storeWriteCleanLogs: rename failed: %s\n",
 		xstrerror());
 	}
     }
     storeDirCloseSwapLogs();
     storeDirOpenSwapLogs();
     stop = getCurrentTime();
     r = stop - start;
-    debug(20, 1, "  Finished.  Wrote %d lines.\n", n);
-    debug(20, 1, "  Took %d seconds (%6.1lf lines/sec).\n",
+    debug(20, 1) ("  Finished.  Wrote %d lines.\n", n);
+    debug(20, 1) ("  Took %d seconds (%6.1lf lines/sec).\n",
 	r > 0 ? r : 0, (double) n / (r > 0 ? r : 1));
     /* touch a timestamp file if we're not still validating */
     for (dirn = 0; dirn < ncache_dirs; dirn++) {
@@ -2578,7 +2578,7 @@ storeRotateLog(void)
 	    return;
 #endif
 
-    debug(20, 1, "storeRotateLog: Rotating.\n");
+    debug(20, 1) ("storeRotateLog: Rotating.\n");
 
     /* Rotate numbers 0 through N up one */
     for (i = Config.Log.rotateNumber; i > 1;) {
@@ -2594,8 +2594,8 @@ storeRotateLog(void)
     }
     storelog_fd = file_open(fname, O_WRONLY | O_CREAT, NULL, NULL);
     if (storelog_fd < 0) {
-	debug(50, 0, "storeRotateLog: %s: %s\n", fname, xstrerror());
-	debug(20, 1, "Store logging disabled\n");
+	debug(50, 0) ("storeRotateLog: %s: %s\n", fname, xstrerror());
+	debug(20, 1) ("Store logging disabled\n");
     }
 }
 
@@ -2789,4 +2789,3 @@ storeUnregisterAbort(StoreEntry * e)
     assert(mem);
     mem->abort.callback = NULL;
 }
-
@@ -69,7 +69,7 @@ storeAddSwapDisk(const char *path, int size, int l1, int l2, int read_only)
 	xfree(SwapDirs);
 	SwapDirs = tmp;
     }
-    debug(20, 1, "Creating Swap Dir #%d in %s\n", ncache_dirs + 1, path);
+    debug(20, 1) ("Creating Swap Dir #%d in %s\n", ncache_dirs + 1, path);
     tmp = SwapDirs + ncache_dirs;
     tmp->path = xstrdup(path);
     tmp->max_size = size;
@@ -101,7 +101,7 @@ storeVerifyOrCreateDir(const char *path)
 {
     struct stat sb;
     if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode)) {
-	debug(20, 3, "%s exists\n", path);
+	debug(20, 3) ("%s exists\n", path);
 	return 0;
     }
     safeunlink(path, 1);
@@ -113,7 +113,7 @@ storeVerifyOrCreateDir(const char *path)
 	    fatal(tmp_error_buf);
 	}
     }
-    debug(20, 1, "Created directory %s\n", path);
+    debug(20, 1) ("Created directory %s\n", path);
     if (stat(path, &sb) < 0 || !S_ISDIR(sb.st_mode)) {
 	sprintf(tmp_error_buf,
 	    "Failed to create directory %s: %s", path, xstrerror());
@@ -130,7 +130,7 @@ storeVerifySwapDirs(void)
     int directory_created = 0;
     for (i = 0; i < ncache_dirs; i++) {
 	path = SwapDirs[i].path;
-	debug(20, 3, "storeVerifySwapDirs: Creating swap space in %s\n", path);
+	debug(20, 3) ("storeVerifySwapDirs: Creating swap space in %s\n", path);
 	storeVerifyOrCreateDir(path);
 	storeCreateSwapSubDirs(i);
     }
@@ -147,7 +147,7 @@ storeCreateSwapSubDirs(int j)
 	sprintf(name, "%s/%02X", SD->path, i);
 	if (storeVerifyOrCreateDir(name) == 0)
 	    continue;
-	debug(20, 1, "Making directories in %s\n", name);
+	debug(20, 1) ("Making directories in %s\n", name);
 	for (k = 0; k < SD->l2; k++) {
 	    sprintf(name, "%s/%02X/%02X", SD->path, i, k);
 	    storeVerifyOrCreateDir(name);
@@ -288,10 +288,10 @@ storeDirOpenSwapLogs(void)
 	path = storeDirSwapLogFile(i, NULL);
 	fd = file_open(path, O_WRONLY | O_CREAT, NULL, NULL);
 	if (fd < 0) {
-	    debug(50, 1, "%s: %s\n", path, xstrerror());
+	    debug(50, 1) ("%s: %s\n", path, xstrerror());
 	    fatal("storeDirOpenSwapLogs: Failed to open swap log.");
 	}
-	debug(20, 3, "Cache Dir #%d log opened on FD %d\n", i, fd);
+	debug(20, 3) ("Cache Dir #%d log opened on FD %d\n", i, fd);
 	SD->swaplog_fd = fd;
     }
 }
@@ -304,7 +304,7 @@ storeDirCloseSwapLogs(void)
     for (i = 0; i < ncache_dirs; i++) {
 	SD = &SwapDirs[i];
 	file_close(SD->swaplog_fd);
-	debug(20, 3, "Cache Dir #%d log closed on FD %d\n", i, SD->swaplog_fd);
+	debug(20, 3) ("Cache Dir #%d log closed on FD %d\n", i, SD->swaplog_fd);
 	SD->swaplog_fd = -1;
     }
 }
@@ -321,7 +321,7 @@ storeDirOpenTmpSwapLog(int dirn, int *clean_flag)
     FILE *fp;
     int fd;
     if (stat(swaplog_path, &log_sb) < 0) {
-	debug(20, 1, "Cache Dir #%d: No log file\n", dirn);
+	debug(20, 1) ("Cache Dir #%d: No log file\n", dirn);
 	safe_free(swaplog_path);
 	safe_free(clean_path);
 	safe_free(new_path);
@@ -333,14 +333,14 @@ storeDirOpenTmpSwapLog(int dirn, int *clean_flag)
     /* open a write-only FD for the new log */
     fd = file_open(new_path, O_WRONLY | O_CREAT | O_TRUNC, NULL, NULL);
     if (fd < 0) {
-	debug(50, 1, "%s: %s\n", new_path, xstrerror());
+	debug(50, 1) ("%s: %s\n", new_path, xstrerror());
 	fatal("storeDirOpenTmpSwapLog: Failed to open swap log.");
     }
     SD->swaplog_fd = fd;
     /* open a read-only stream of the old log */
     fp = fopen(swaplog_path, "r");
     if (fp == NULL) {
-	debug(50, 0, "%s: %s\n", swaplog_path, xstrerror());
+	debug(50, 0) ("%s: %s\n", swaplog_path, xstrerror());
 	fatal("Failed to open swap log for reading");
     }
     memset(&clean_sb, '\0', sizeof(struct stat));
@@ -365,19 +365,19 @@ storeDirCloseTmpSwapLog(int dirn)
     SwapDir *SD = &SwapDirs[dirn];
     int fd;
     if (rename(new_path, swaplog_path) < 0) {
-	debug(50, 0, "%s,%s: %s\n", new_path, swaplog_path, xstrerror());
+	debug(50, 0) ("%s,%s: %s\n", new_path, swaplog_path, xstrerror());
 	fatal("storeDirCloseTmpSwapLog: rename failed");
     }
     file_close(SD->swaplog_fd);
     fd = file_open(swaplog_path, O_WRONLY | O_CREAT, NULL, NULL);
     if (fd < 0) {
-	debug(50, 1, "%s: %s\n", swaplog_path, xstrerror());
+	debug(50, 1) ("%s: %s\n", swaplog_path, xstrerror());
 	fatal("storeDirCloseTmpSwapLog: Failed to open swap log.");
     }
     safe_free(swaplog_path);
     safe_free(new_path);
     SD->swaplog_fd = fd;
-    debug(20, 3, "Cache Dir #%d log opened on FD %d\n", dirn, fd);
+    debug(20, 3) ("Cache Dir #%d log opened on FD %d\n", dirn, fd);
 }
 
 void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.108 1997/06/01 23:21:38 wessels Exp $
+ * $Id: tools.cc,v 1.109 1997/06/04 06:16:14 wessels Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -317,7 +317,7 @@ sigusr2_handle(int sig)
 static void
 shutdownTimeoutHandler(int fd, void *data)
 {
-    debug(21, 1, "Forcing close of FD %d\n", fd);
+    debug(21, 1) ("Forcing close of FD %d\n", fd);
     comm_close(fd);
 }
 
@@ -344,7 +344,7 @@ setSocketShutdownLifetimes(int to)
 void
 normal_shutdown(void)
 {
-    debug(21, 1, "Shutting down...\n");
+    debug(21, 1) ("Shutting down...\n");
     if (Config.pidFilename && strcmp(Config.pidFilename, "none")) {
 	enter_suid();
 	safeunlink(Config.pidFilename, 0);
@@ -373,7 +373,7 @@ normal_shutdown(void)
     file_close(2);
     fdDumpOpen();
     fdFreeMemory();
-    debug(21, 0, "Squid Cache (Version %s): Exiting normally.\n",
+    debug(21, 0) ("Squid Cache (Version %s): Exiting normally.\n",
 	version_string);
     fclose(debug_log);
     exit(0);
@@ -420,13 +420,13 @@ fatal_dump(const char *message)
     abort();
 }
 
-/* fatal with dumping core */
 void
-_debug_trap(const char *message)
+debug_trap(const char *message)
 {
     if (!opt_catch_signals)
 	fatal_dump(message);
-    _db_print(0, 0, "WARNING: %s\n", message);
+    _db_level = 0;
+    _db_print("WARNING: %s\n", message);
 }
 
 void
@@ -469,7 +469,7 @@ getMyHostname(void)
     if (!present) {
 	host[0] = '\0';
 	if (gethostname(host, SQUIDHOSTNAMELEN) == -1) {
-	    debug(50, 1, "getMyHostname: gethostname failed: %s\n",
+	    debug(50, 1) ("getMyHostname: gethostname failed: %s\n",
 		xstrerror());
 	    return NULL;
 	} else {
@@ -493,7 +493,7 @@ safeunlink(const char *s, int quiet)
 	quiet ? NULL : xstrdup(s));
 #else
     if (unlink(s) < 0 && !quiet)
-	debug(50, 1, "safeunlink: Couldn't delete %s: %s\n", s, xstrerror());
+	debug(50, 1) ("safeunlink: Couldn't delete %s: %s\n", s, xstrerror());
 #endif
 }
 
@@ -504,7 +504,7 @@ safeunlinkComplete(void *data, int retcode, int errcode)
     char *s = data;
     if (retcode < 0) {
 	errno = errcode;
-	debug(50, 1, "safeunlink: Couldn't delete %s. %s\n", s, xstrerror());
+	debug(50, 1) ("safeunlink: Couldn't delete %s. %s\n", s, xstrerror());
 	errno = 0;
     }
     xfree(s);
@@ -521,7 +521,7 @@ leave_suid(void)
 {
     struct passwd *pwd = NULL;
     struct group *grp = NULL;
-    debug(21, 3, "leave_suid: PID %d called\n", getpid());
+    debug(21, 3) ("leave_suid: PID %d called\n", getpid());
     if (geteuid() != 0)
 	return;
     /* Started as a root, check suid option */
@@ -531,30 +531,30 @@ leave_suid(void)
 	return;
     if (Config.effectiveGroup && (grp = getgrnam(Config.effectiveGroup))) {
 	if (setgid(grp->gr_gid) < 0)
-	    debug(50, 1, "leave_suid: setgid: %s\n", xstrerror());
+	    debug(50, 1) ("leave_suid: setgid: %s\n", xstrerror());
     } else {
 	if (setgid(pwd->pw_gid) < 0)
-	    debug(50, 1, "leave_suid: setgid: %s\n", xstrerror());
+	    debug(50, 1) ("leave_suid: setgid: %s\n", xstrerror());
     }
-    debug(21, 3, "leave_suid: PID %d giving up root, becoming '%s'\n",
+    debug(21, 3) ("leave_suid: PID %d giving up root, becoming '%s'\n",
 	getpid(), pwd->pw_name);
 #if HAVE_SETRESUID
     if (setresuid(pwd->pw_uid, pwd->pw_uid, 0) < 0)
-	debug(50, 1, "leave_suid: setresuid: %s\n", xstrerror());
+	debug(50, 1) ("leave_suid: setresuid: %s\n", xstrerror());
 #elif HAVE_SETEUID
     if (seteuid(pwd->pw_uid) < 0)
-	debug(50, 1, "leave_suid: seteuid: %s\n", xstrerror());
+	debug(50, 1) ("leave_suid: seteuid: %s\n", xstrerror());
 #else
     if (setuid(pwd->pw_uid) < 0)
-	debug(50, 1, "leave_suid: setuid: %s\n", xstrerror());
+	debug(50, 1) ("leave_suid: setuid: %s\n", xstrerror());
 #endif
 }
 
 /* Enter a privilegied section */
 void
 enter_suid(void)
 {
-    debug(21, 3, "enter_suid: PID %d taking root priveleges\n", getpid());
+    debug(21, 3) ("enter_suid: PID %d taking root priveleges\n", getpid());
 #if HAVE_SETRESUID
     setresuid(-1, 0, -1);
 #else
@@ -571,14 +571,14 @@ no_suid(void)
     uid_t uid;
     leave_suid();
     uid = geteuid();
-    debug(21, 3, "leave_suid: PID %d giving up root priveleges forever\n", getpid());
+    debug(21, 3) ("leave_suid: PID %d giving up root priveleges forever\n", getpid());
 #if HAVE_SETRESUID
     if (setresuid(uid, uid, uid) < 0)
-	debug(50, 1, "no_suid: setresuid: %s\n", xstrerror());
+	debug(50, 1) ("no_suid: setresuid: %s\n", xstrerror());
 #else
     setuid(0);
     if (setuid(uid) < 0)
-	debug(50, 1, "no_suid: setuid: %s\n", xstrerror());
+	debug(50, 1) ("no_suid: setuid: %s\n", xstrerror());
 #endif
 }
 
@@ -599,7 +599,7 @@ writePidFile(void)
     umask(old_umask);
     leave_suid();
     if (fd < 0) {
-	debug(50, 0, "%s: %s\n", f, xstrerror());
+	debug(50, 0) ("%s: %s\n", f, xstrerror());
 	debug_trap("Could not write pid file");
 	return;
     }
@@ -647,7 +647,7 @@ setMaxFD(void)
     struct rlimit rl;
 #if defined(RLIMIT_NOFILE)
     if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
-	debug(50, 0, "setrlimit: RLIMIT_NOFILE: %s\n", xstrerror());
+	debug(50, 0) ("setrlimit: RLIMIT_NOFILE: %s\n", xstrerror());
     } else {
 	rl.rlim_cur = Squid_MaxFD;
 	if (rl.rlim_cur > rl.rlim_max)
@@ -659,7 +659,7 @@ setMaxFD(void)
     }
 #elif defined(RLIMIT_OFILE)
     if (getrlimit(RLIMIT_OFILE, &rl) < 0) {
-	debug(50, 0, "setrlimit: RLIMIT_NOFILE: %s\n", xstrerror());
+	debug(50, 0) ("setrlimit: RLIMIT_NOFILE: %s\n", xstrerror());
     } else {
 	rl.rlim_cur = Squid_MaxFD;
 	if (rl.rlim_cur > rl.rlim_max)
@@ -671,12 +671,12 @@ setMaxFD(void)
     }
 #endif
 #else /* HAVE_SETRLIMIT */
-    debug(21, 1, "setMaxFD: Cannot increase: setrlimit() not supported on this system\n");
+    debug(21, 1) ("setMaxFD: Cannot increase: setrlimit() not supported on this system\n");
 #endif /* HAVE_SETRLIMIT */
 
 #if HAVE_SETRLIMIT && defined(RLIMIT_DATA)
     if (getrlimit(RLIMIT_DATA, &rl) < 0) {
-	debug(50, 0, "getrlimit: RLIMIT_DATA: %s\n", xstrerror());
+	debug(50, 0) ("getrlimit: RLIMIT_DATA: %s\n", xstrerror());
     } else {
 	rl.rlim_cur = rl.rlim_max;	/* set it to the max */
 	if (setrlimit(RLIMIT_DATA, &rl) < 0) {
@@ -687,7 +687,7 @@ setMaxFD(void)
 #endif /* RLIMIT_DATA */
 #if HAVE_SETRLIMIT && defined(RLIMIT_VMEM)
     if (getrlimit(RLIMIT_VMEM, &rl) < 0) {
-	debug(50, 0, "getrlimit: RLIMIT_VMEM: %s\n", xstrerror());
+	debug(50, 0) ("getrlimit: RLIMIT_VMEM: %s\n", xstrerror());
     } else {
 	rl.rlim_cur = rl.rlim_max;	/* set it to the max */
 	if (setrlimit(RLIMIT_VMEM, &rl) < 0) {
@@ -724,7 +724,7 @@ squid_signal(int sig, void (*func) _PARAMS((int)), int flags)
     sa.sa_flags = flags;
     sigemptyset(&sa.sa_mask);
     if (sigaction(sig, &sa, NULL) < 0)
-	debug(50, 0, "sigaction: sig=%d func=%p: %s\n", sig, func, xstrerror());
+	debug(50, 0) ("sigaction: sig=%d func=%p: %s\n", sig, func, xstrerror());
 #else
     (void) signal(sig, func);
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.53 1997/06/02 01:06:16 wessels Exp $
+ * $Id: tunnel.cc,v 1.54 1997/06/04 06:16:09 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -86,7 +86,7 @@ static void
 sslClientClosed(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslClientClosed: FD %d\n", fd);
+    debug(26, 3) ("sslClientClosed: FD %d\n", fd);
     /* we have been called from comm_close for the client side, so
      * just need to clean up the server side */
     protoUnregister(NULL, sslState->request, no_addr);
@@ -97,7 +97,7 @@ static void
 sslStateFree(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslStateFree: FD %d, sslState=%p\n", fd, sslState);
+    debug(26, 3) ("sslStateFree: FD %d, sslState=%p\n", fd, sslState);
     if (sslState == NULL)
 	return;
     if (fd != sslState->server.fd)
@@ -123,9 +123,9 @@ sslReadServer(int fd, void *data)
     int len;
     len = read(sslState->server.fd, sslState->server.buf, SQUID_TCP_SO_RCVBUF);
     fd_bytes(sslState->server.fd, len, FD_READ);
-    debug(26, 5, "sslReadServer FD %d, read %d bytes\n", fd, len);
+    debug(26, 5) ("sslReadServer FD %d, read %d bytes\n", fd, len);
     if (len < 0) {
-	debug(50, 1, "sslReadServer: FD %d: read failure: %s\n",
+	debug(50, 1) ("sslReadServer: FD %d: read failure: %s\n",
 	    sslState->server.fd, xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    /* reinstall handlers */
@@ -160,10 +160,10 @@ sslReadClient(int fd, void *data)
     int len;
     len = read(sslState->client.fd, sslState->client.buf, SQUID_TCP_SO_RCVBUF);
     fd_bytes(sslState->client.fd, len, FD_READ);
-    debug(26, 5, "sslReadClient FD %d, read %d bytes\n",
+    debug(26, 5) ("sslReadClient FD %d, read %d bytes\n",
 	sslState->client.fd, len);
     if (len < 0) {
-	debug(50, 1, "sslReadClient: FD %d: read failure: %s\n",
+	debug(50, 1) ("sslReadClient: FD %d: read failure: %s\n",
 	    fd, xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    /* reinstall handlers */
@@ -198,7 +198,7 @@ sslWriteServer(int fd, void *data)
 	sslState->client.buf + sslState->client.offset,
 	sslState->client.len - sslState->client.offset);
     fd_bytes(fd, len, FD_WRITE);
-    debug(26, 5, "sslWriteServer FD %d, wrote %d bytes\n", fd, len);
+    debug(26, 5) ("sslWriteServer FD %d, wrote %d bytes\n", fd, len);
     if (len < 0) {
 	if (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK) {
 	    commSetSelect(sslState->server.fd,
@@ -207,7 +207,7 @@ sslWriteServer(int fd, void *data)
 		sslState, 0);
 	    return;
 	}
-	debug(50, 2, "sslWriteServer: FD %d: write failure: %s.\n",
+	debug(50, 2) ("sslWriteServer: FD %d: write failure: %s.\n",
 	    sslState->server.fd, xstrerror());
 	sslClose(sslState);
 	return;
@@ -233,15 +233,15 @@ sslWriteClient(int fd, void *data)
 {
     SslStateData *sslState = data;
     int len;
-    debug(26, 5, "sslWriteClient FD %d len=%d offset=%d\n",
+    debug(26, 5) ("sslWriteClient FD %d len=%d offset=%d\n",
 	fd,
 	sslState->server.len,
 	sslState->server.offset);
     len = write(sslState->client.fd,
 	sslState->server.buf + sslState->server.offset,
 	sslState->server.len - sslState->server.offset);
     fd_bytes(fd, len, FD_WRITE);
-    debug(26, 5, "sslWriteClient FD %d, wrote %d bytes\n", fd, len);
+    debug(26, 5) ("sslWriteClient FD %d, wrote %d bytes\n", fd, len);
     if (len < 0) {
 	if (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK) {
 	    commSetSelect(sslState->client.fd,
@@ -250,7 +250,7 @@ sslWriteClient(int fd, void *data)
 		sslState, 0);
 	    return;
 	}
-	debug(50, 2, "sslWriteClient: FD %d: write failure: %s.\n",
+	debug(50, 2) ("sslWriteClient: FD %d: write failure: %s.\n",
 	    sslState->client.fd, xstrerror());
 	sslClose(sslState);
 	return;
@@ -276,15 +276,15 @@ static void
 sslTimeout(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslTimeout: FD %d\n", fd);
+    debug(26, 3) ("sslTimeout: FD %d\n", fd);
     sslClose(sslState);
 }
 
 static void
 sslConnected(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslConnected: FD %d sslState=%p\n", fd, sslState);
+    debug(26, 3) ("sslConnected: FD %d sslState=%p\n", fd, sslState);
     strcpy(sslState->server.buf, conn_established);
     sslState->server.len = strlen(conn_established);
     sslState->server.offset = 0;
@@ -318,7 +318,7 @@ sslConnectDone(int fd, int status, void *data)
     request_t *request = sslState->request;
     char *buf = NULL;
     if (status == COMM_ERR_DNS) {
-	debug(26, 4, "sslConnect: Unknown host: %s\n", sslState->host);
+	debug(26, 4) ("sslConnect: Unknown host: %s\n", sslState->host);
 	buf = squid_error_url(sslState->url,
 	    request->method,
 	    ERR_DNS_FAIL,
@@ -362,7 +362,7 @@ sslStart(int fd, const char *url, request_t * request, int *size_ptr)
     SslStateData *sslState = NULL;
     int sock;
     char *buf = NULL;
-    debug(26, 3, "sslStart: '%s %s'\n",
+    debug(26, 3) ("sslStart: '%s %s'\n",
 	RequestMethodStr[request->method], url);
     /* Create socket. */
     sock = comm_open(SOCK_STREAM,
@@ -372,7 +372,7 @@ sslStart(int fd, const char *url, request_t * request, int *size_ptr)
 	COMM_NONBLOCKING,
 	url);
     if (sock == COMM_ERROR) {
-	debug(26, 4, "sslStart: Failed because we're out of sockets.\n");
+	debug(26, 4) ("sslStart: Failed because we're out of sockets.\n");
 	buf = squid_error_url(url,
 	    request->method,
 	    ERR_NO_FDS,
@@ -417,9 +417,9 @@ static void
 sslProxyConnected(int fd, void *data)
 {
     SslStateData *sslState = data;
-    debug(26, 3, "sslProxyConnected: FD %d sslState=%p\n", fd, sslState);
+    debug(26, 3) ("sslProxyConnected: FD %d sslState=%p\n", fd, sslState);
     sprintf(sslState->client.buf, "CONNECT %s HTTP/1.0\r\n\r\n", sslState->url);
-    debug(26, 3, "sslProxyConnected: Sending 'CONNECT %s HTTP/1.0'\n", sslState->url);
+    debug(26, 3) ("sslProxyConnected: Sending 'CONNECT %s HTTP/1.0'\n", sslState->url);
     sslState->client.len = strlen(sslState->client.buf);
     sslState->client.offset = 0;
     commSetSelect(sslState->server.fd,
@@ -1,5 +1,5 @@
 /*
- * $Id: unlinkd.cc,v 1.5 1997/04/30 18:34:59 wessels Exp $
+ * $Id: unlinkd.cc,v 1.6 1997/06/04 06:16:15 wessels Exp $
  *
  * DEBUG: section 43    Unlink Daemon
  * AUTHOR: Duane Wessels
@@ -92,19 +92,19 @@ unlinkdCreate(void)
     char buf[HELLO_BUFSIZ];
     struct timeval slp;
     if (pipe(squid_to_unlinkd) < 0) {
-	debug(50, 0, "unlinkdCreate: pipe: %s\n", xstrerror());
+	debug(50, 0) ("unlinkdCreate: pipe: %s\n", xstrerror());
 	return -1;
     }
     if (pipe(unlinkd_to_squid) < 0) {
-	debug(50, 0, "unlinkdCreate: pipe: %s\n", xstrerror());
+	debug(50, 0) ("unlinkdCreate: pipe: %s\n", xstrerror());
 	return -1;
     }
     rfd1 = squid_to_unlinkd[0];
     wfd1 = squid_to_unlinkd[1];
     rfd2 = unlinkd_to_squid[0];
     wfd2 = unlinkd_to_squid[1];
     if ((pid = fork()) < 0) {
-	debug(50, 0, "unlinkdCreate: fork: %s\n", xstrerror());
+	debug(50, 0) ("unlinkdCreate: fork: %s\n", xstrerror());
 	close(rfd1);
 	close(wfd1);
 	close(rfd2);
@@ -119,12 +119,12 @@ unlinkdCreate(void)
 	fd_bytes(rfd2, n, FD_READ);
 	close(rfd2);
 	if (n <= 0) {
-	    debug(50, 0, "unlinkdCreate: handshake failed\n");
+	    debug(50, 0) ("unlinkdCreate: handshake failed\n");
 	    close(wfd1);
 	    return -1;
 	} else if (strcmp(buf, hello_string)) {
-	    debug(50, 0, "unlinkdCreate: handshake failed\n");
-	    debug(50, 0, "--> got '%s'\n", rfc1738_escape(buf));
+	    debug(50, 0) ("unlinkdCreate: handshake failed\n");
+	    debug(50, 0) ("--> got '%s'\n", rfc1738_escape(buf));
 	    close(wfd1);
 	    return -1;
 	}
@@ -146,7 +146,7 @@ unlinkdCreate(void)
     close(wfd2);		/* close parent's FD */
     commSetCloseOnExec(fileno(debug_log));
     execlp(Config.Program.unlinkd, "(unlinkd)", NULL);
-    debug(50, 0, "unlinkdCreate: %s: %s\n",
+    debug(50, 0) ("unlinkdCreate: %s: %s\n",
 	Config.Program.unlinkd, xstrerror());
     _exit(1);
     return 0;
@@ -193,7 +193,7 @@ unlinkdInit(void)
     unlinkd_fd = unlinkdCreate();
     if (unlinkd_fd < 0)
 	fatal("unlinkdInit: failed to start unlinkd\n");
-    debug(43, 0, "Unlinkd pipe opened on FD %d\n", unlinkd_fd);
+    debug(43, 0) ("Unlinkd pipe opened on FD %d\n", unlinkd_fd);
 }
 
 #endif /* ndef UNLINK_DAEMON */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.57 1997/06/02 01:06:18 wessels Exp $
+ * $Id: url.cc,v 1.58 1997/06/04 06:16:16 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -97,7 +97,7 @@ urlInitialize(void)
     unsigned int i;
     char *good =
     "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
-    debug(23, 5, "urlInitialize: Initializing...\n");
+    debug(23, 5) ("urlInitialize: Initializing...\n");
     for (i = 0; i < 256; i++)
 	url_acceptable[i] = 0;
     for (; *good; good++)
@@ -207,7 +207,7 @@ urlParse(method_t method, char *url)
     if ((l = strlen(url)) + Config.appendDomainLen > (MAX_URL - 1)) {
 	/* terminate so it doesn't overflow other buffers */
 	*(url + (MAX_URL >> 1)) = '\0';
-	debug(23, 0, "urlParse: URL too large (%d bytes)\n", l);
+	debug(23, 0) ("urlParse: URL too large (%d bytes)\n", l);
 	return NULL;
     }
     if (method == METHOD_CONNECT) {
@@ -240,14 +240,14 @@ urlParse(method_t method, char *url)
     if (Config.appendDomain && !strchr(host, '.'))
 	strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN);
     if (port == 0) {
-	debug(23, 0, "urlParse: Invalid port == 0\n");
+	debug(23, 0) ("urlParse: Invalid port == 0\n");
 	return NULL;
     }
 #ifdef HARDCODE_DENY_PORTS
     /* These ports are filtered in the default squid.conf, but
      * maybe someone wants them hardcoded... */
     if (port == 7 || port == 9 || port = 19) {
-	debug(23, 0, "urlParse: Deny access to port %d\n", port);
+	debug(23, 0) ("urlParse: Deny access to port %d\n", port);
 	return NULL;
     }
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: useragent.cc,v 1.6 1997/05/02 21:34:18 wessels Exp $
+ * $Id: useragent.cc,v 1.7 1997/06/04 06:16:16 wessels Exp $
  *
  * DEBUG: section 40    User-Agent logging
  * AUTHOR: Joe Ramey <ramey@csc.ti.com>
@@ -50,14 +50,14 @@ useragentOpenLog(void)
     if (fname && strcmp(fname, "none") != 0) {
 	log_fd = file_open(fname, O_WRONLY | O_CREAT | O_APPEND, NULL, NULL);
 	if (log_fd < 0) {
-	    debug(50, 0, "useragentOpenLog: %s: %s\n", fname, xstrerror());
+	    debug(50, 0) ("useragentOpenLog: %s: %s\n", fname, xstrerror());
 	} else if ((cache_useragent_log = fdopen(log_fd, "a")) == NULL) {
 	    file_close(log_fd);
-	    debug(50, 0, "useragentOpenLog: %s: %s\n", fname, xstrerror());
+	    debug(50, 0) ("useragentOpenLog: %s: %s\n", fname, xstrerror());
 	}
     }
     if (log_fd < 0 || cache_useragent_log == NULL)
-	debug(40, 1, "User-Agent logging is disabled.\n");
+	debug(40, 1) ("User-Agent logging is disabled.\n");
 #endif
 }
 
@@ -79,7 +79,7 @@ useragentRotateLog(void)
 	if (S_ISREG(sb.st_mode) == 0)
 	    return;
 #endif
-    debug(40, 1, "useragentRotateLog: Rotating.\n");
+    debug(40, 1) ("useragentRotateLog: Rotating.\n");
     /* Rotate numbers 0 through N up one */
     for (i = Config.Log.rotateNumber; i > 1;) {
 	i--;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.75 1997/06/02 19:56:04 wessels Exp $
+ * $Id: wais.cc,v 1.76 1997/06/04 06:16:17 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -143,7 +143,7 @@ waisTimeout(int fd, void *data)
 {
     WaisStateData *waisState = data;
     StoreEntry *entry = waisState->entry;
-    debug(24, 4, "waisTimeout: FD %d: '%s'\n", fd, entry->url);
+    debug(24, 4) ("waisTimeout: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     comm_close(fd);
 }
@@ -163,9 +163,9 @@ waisReadReply(int fd, void *data)
     int off;
     int bin;
     if (protoAbortFetch(entry)) {
-        squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
-        comm_close(fd);
-        return;
+	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
+	comm_close(fd);
+	return;
     }
     if (entry->flag & DELETE_BEHIND && !storeClientWaiting(entry)) {
 	/* we can terminate connection right now */
@@ -178,9 +178,9 @@ waisReadReply(int fd, void *data)
     off = storeGetLowestReaderOffset(entry);
     if ((clen - off) > WAIS_DELETE_GAP) {
 	IOStats.Wais.reads_deferred++;
-	debug(24, 3, "waisReadReply: Read deferred for Object: %s\n",
+	debug(24, 3) ("waisReadReply: Read deferred for Object: %s\n",
 	    entry->url);
-	debug(24, 3, "                Current Gap: %d bytes\n", clen - off);
+	debug(24, 3) ("                Current Gap: %d bytes\n", clen - off);
 	/* reschedule, so it will automatically reactivated
 	 * when Gap is big enough. */
 	commSetSelect(fd,
@@ -200,7 +200,7 @@ waisReadReply(int fd, void *data)
     }
     len = read(fd, buf, 4096);
     fd_bytes(fd, len, FD_READ);
-    debug(24, 5, "waisReadReply: FD %d read len:%d\n", fd, len);
+    debug(24, 5) ("waisReadReply: FD %d read len:%d\n", fd, len);
     if (len > 0) {
 	commSetTimeout(fd, Config.Timeout.read, NULL, NULL);
 	IOStats.Wais.reads++;
@@ -209,7 +209,7 @@ waisReadReply(int fd, void *data)
 	IOStats.Wais.read_hist[bin]++;
     }
     if (len < 0) {
-	debug(50, 1, "waisReadReply: FD %d: read failure: %s.\n", xstrerror());
+	debug(50, 1) ("waisReadReply: FD %d: read failure: %s.\n", xstrerror());
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
 	    /* reinstall handlers */
 	    /* XXX This may loop forever */
@@ -247,7 +247,7 @@ waisSendComplete(int fd, char *buf, int size, int errflag, void *data)
 {
     WaisStateData *waisState = data;
     StoreEntry *entry = waisState->entry;
-    debug(24, 5, "waisSendComplete: FD %d size: %d errflag: %d\n",
+    debug(24, 5) ("waisSendComplete: FD %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
 	squid_error_entry(entry, ERR_CONNECT_FAIL, xstrerror());
@@ -270,7 +270,7 @@ waisSendRequest(int fd, void *data)
     char *buf = NULL;
     const char *Method = RequestMethodStr[waisState->method];
 
-    debug(24, 5, "waisSendRequest: FD %d\n", fd);
+    debug(24, 5) ("waisSendRequest: FD %d\n", fd);
 
     if (Method)
 	len += strlen(Method);
@@ -284,7 +284,7 @@ waisSendRequest(int fd, void *data)
 	    waisState->request_hdr);
     else
 	sprintf(buf, "%s %s\r\n", Method, waisState->request);
-    debug(24, 6, "waisSendRequest: buf: %s\n", buf);
+    debug(24, 6) ("waisSendRequest: buf: %s\n", buf);
     comm_write(fd,
 	buf,
 	len,
@@ -296,15 +296,15 @@ waisSendRequest(int fd, void *data)
 }
 
 void
-waisStart(request_t *request, StoreEntry * entry)
+waisStart(request_t * request, StoreEntry * entry)
 {
     WaisStateData *waisState = NULL;
     int fd;
     char *url = entry->url;
     method_t method = request->method;
-    debug(24, 3, "waisStart: \"%s %s\"\n", RequestMethodStr[method], url);
+    debug(24, 3) ("waisStart: \"%s %s\"\n", RequestMethodStr[method], url);
     if (!Config.Wais.relayHost) {
-	debug(24, 0, "waisStart: Failed because no relay host defined!\n");
+	debug(24, 0) ("waisStart: Failed because no relay host defined!\n");
 	squid_error_entry(entry, ERR_NO_RELAY, NULL);
 	return;
     }
@@ -315,7 +315,7 @@ waisStart(request_t *request, StoreEntry * entry)
 	COMM_NONBLOCKING,
 	url);
     if (fd == COMM_ERROR) {
-	debug(24, 4, "waisStart: Failed because we're out of sockets.\n");
+	debug(24, 4) ("waisStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
 	return;
     }
@@ -363,6 +363,6 @@ static void
 waisAbort(void *data)
 {
     HttpStateData *waisState = data;
-    debug(24, 1, "waisAbort: %s\n", waisState->entry->url);
+    debug(24, 1) ("waisAbort: %s\n", waisState->entry->url);
     comm_close(waisState->fd);
 }