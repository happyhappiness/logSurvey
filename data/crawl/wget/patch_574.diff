diff --git a/src/ChangeLog b/src/ChangeLog
index 237439b..f60e3c4 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,17 @@
+2000-11-22  Hrvoje Niksic  <hniksic@arsdigita.com>
+
+	* all: Use xfree() instead of free.
+
+	* utils.c (xfree): New function.
+
+2000-11-21  Hrvoje Niksic  <hniksic@arsdigita.com>
+
+	* url.c (convert_links): HTML-quote the converted string.
+
+	* utils.c (html_quote_string): Move here from ftp-ls.c
+	(html_quote_string): Make non-static; declare in utils.h.
+	(html_quote_string): Convert SP to &#32;.
+
 2000-11-21  Hrvoje Niksic  <hniksic@arsdigita.com>
 
 	* ftp.c (getftp): Reformat Jan's code according to GNU coding
diff --git a/src/ftp-basic.c b/src/ftp-basic.c
index 2de2596..1b2680f 100644
--- a/src/ftp-basic.c
+++ b/src/ftp-basic.c
@@ -139,41 +139,41 @@ ftp_login (struct rbuf *rbuf, const char *acc, const char *pass)
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPSRVERR;
     }
-  free (respline);
+  xfree (respline);
   /* Send USER username.  */
   request = ftp_request ("USER", acc);
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   /* An unprobable possibility of logging without a password.  */
   if (*respline == '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPOK;
     }
   /* Else, only response 3 is appropriate.  */
   if (*respline != '3')
     {
-      free (respline);
+      xfree (respline);
       return FTPLOGREFUSED;
     }
 #ifdef USE_OPIE
@@ -205,7 +205,7 @@ ftp_login (struct rbuf *rbuf, const char *acc, const char *pass)
 	else
 	  {
 	  bad:
-	    free (respline);
+	    xfree (respline);
 	    return FTPLOGREFUSED;
 	  }
 	if ((cp = calculate_skey_response (skey_sequence, cp, pass)) == 0)
@@ -214,29 +214,29 @@ ftp_login (struct rbuf *rbuf, const char *acc, const char *pass)
       }
   }
 #endif /* USE_OPIE */
-  free (respline);
+  xfree (respline);
   /* Send PASS password.  */
   request = ftp_request ("PASS", pass);
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPLOGINC;
     }
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -272,23 +272,23 @@ ftp_port (struct rbuf *rbuf)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPPORTERR;
     }
-  free (respline);
+  xfree (respline);
   return FTPOK;
 }
 
@@ -308,20 +308,20 @@ ftp_pasv (struct rbuf *rbuf, unsigned char *addr)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get the server response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPNOPASV;
     }
   /* Parse the request.  */
@@ -339,11 +339,11 @@ ftp_pasv (struct rbuf *rbuf, unsigned char *addr)
       else if (i < 5)
 	{
 	  /* When on the last number, anything can be a terminator.  */
-	  free (respline);
+	  xfree (respline);
 	  return FTPINVPASV;
 	}
     }
-  free (respline);
+  xfree (respline);
   return FTPOK;
 }
 
@@ -364,23 +364,23 @@ ftp_type (struct rbuf *rbuf, int type)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPUNKNOWNTYPE;
     }
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -399,28 +399,28 @@ ftp_cwd (struct rbuf *rbuf, const char *dir)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline == '5')
     {
-      free (respline);
+      xfree (respline);
       return FTPNSFOD;
     }
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       return FTPRERR;
     }
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -439,23 +439,23 @@ ftp_rest (struct rbuf *rbuf, long offset)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline != '3')
     {
-      free (respline);
+      xfree (respline);
       return FTPRESTFAIL;
     }
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -473,28 +473,28 @@ ftp_retr (struct rbuf *rbuf, const char *file)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline == '5')
     {
-      free (respline);
+      xfree (respline);
       return FTPNSFOD;
     }
   if (*respline != '1')
     {
-      free (respline);
+      xfree (respline);
       return FTPRERR;
     }
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -513,28 +513,28 @@ ftp_list (struct rbuf *rbuf, const char *file)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate respone.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline == '5')
     {
-      free (respline);
+      xfree (respline);
       return FTPNSFOD;
     }
   if (*respline != '1')
     {
-      free (respline);
+      xfree (respline);
       return FTPRERR;
     }
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -552,20 +552,20 @@ ftp_syst (struct rbuf *rbuf, enum stype *host_type)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline == '5')
     {
-      free (respline);
+      xfree (respline);
       return FTPSRVERR;
     }
 
@@ -584,7 +584,7 @@ ftp_syst (struct rbuf *rbuf, enum stype *host_type)
     else
       *host_type = ST_OTHER;
 
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
@@ -602,20 +602,20 @@ ftp_pwd (struct rbuf *rbuf, char **pwd)
   nwritten = iwrite (RBUF_FD (rbuf), request, strlen (request));
   if (nwritten < 0)
     {
-      free (request);
+      xfree (request);
       return WRITEFAILED;
     }
-  free (request);
+  xfree (request);
   /* Get appropriate response.  */
   err = ftp_response (rbuf, &respline);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       return err;
     }
   if (*respline == '5')
     {
-      free (respline);
+      xfree (respline);
       return FTPSRVERR;
     }
 
@@ -624,12 +624,12 @@ ftp_pwd (struct rbuf *rbuf, char **pwd)
   strtok (respline, "\"");
   request = strtok (NULL, "\"");
   
-  /* Has the `pwd' been already allocated? Free! */
-  if (*pwd) free (*pwd);
+  /* Has the `pwd' been already allocated?  Free! */
+  FREE_MAYBE (*pwd);
 
   *pwd = xstrdup (request);
 
-  free (respline);
+  xfree (respline);
   /* All OK.  */
   return FTPOK;
 }
diff --git a/src/ftp-ls.c b/src/ftp-ls.c
index 54e345e..61fdfa2 100644
--- a/src/ftp-ls.c
+++ b/src/ftp-ls.c
@@ -114,14 +114,14 @@ ftp_parse_unix_ls (const char *file)
       /* Skip if total...  */
       if (!strncasecmp (line, "total", 5))
 	{
-	  free (line);
+	  xfree (line);
 	  continue;
 	}
       /* Get the first token (permissions).  */
       tok = strtok (line, " ");
       if (!tok)
 	{
-	  free (line);
+	  xfree (line);
 	  continue;
 	}
 
@@ -330,7 +330,7 @@ ftp_parse_unix_ls (const char *file)
 	  DEBUGP (("Skipping.\n"));
 	  FREE_MAYBE (cur.name);
 	  FREE_MAYBE (cur.linkto);
-	  free (line);
+	  xfree (line);
 	  continue;
 	}
 
@@ -378,7 +378,7 @@ ftp_parse_unix_ls (const char *file)
       timestruct.tm_isdst = -1;
       l->tstamp = mktime (&timestruct); /* store the time-stamp */
 
-      free (line);
+      xfree (line);
     }
 
   fclose (fp);
@@ -459,7 +459,7 @@ ftp_parse_nonunix_ls (const char *file)
 	  l->tstamp = fp.mtime;
       }
 
-      free (line);
+      xfree (line);
     }
 
   fclose (fp);
@@ -494,68 +494,6 @@ ftp_parse_ls (const char *file, const enum stype system_type)
 
 /* Stuff for creating FTP index. */
 
-/* The function returns the pointer to the malloc-ed quoted version of
-   string s.  It will recognize and quote numeric and special graphic
-   entities, as per RFC1866:
-
-   `&' -> `&amp;'
-   `<' -> `&lt;'
-   `>' -> `&gt;'
-   `"' -> `&quot;'
-
-   No other entities are recognized or replaced.  */
-static char *
-html_quote_string (const char *s)
-{
-  const char *b = s;
-  char *p, *res;
-  int i;
-
-  /* Pass through the string, and count the new size.  */
-  for (i = 0; *s; s++, i++)
-    {
-      if (*s == '&')
-	i += 4;                /* `amp;' */
-      else if (*s == '<' || *s == '>')
-	i += 3;                /* `lt;' and `gt;' */
-      else if (*s == '\"')
-	i += 5;                /* `quot;' */
-    }
-  res = (char *)xmalloc (i + 1);
-  s = b;
-  for (p = res; *s; s++)
-    {
-      switch (*s)
-	{
-	case '&':
-	  *p++ = '&';
-	  *p++ = 'a';
-	  *p++ = 'm';
-	  *p++ = 'p';
-	  *p++ = ';';
-	  break;
-	case '<': case '>':
-	  *p++ = '&';
-	  *p++ = (*s == '<' ? 'l' : 'g');
-	  *p++ = 't';
-	  *p++ = ';';
-	  break;
-	case '\"':
-	  *p++ = '&';
-	  *p++ = 'q';
-	  *p++ = 'u';
-	  *p++ = 'o';
-	  *p++ = 't';
-	  *p++ = ';';
-	  break;
-	default:
-	  *p++ = *s;
-	}
-    }
-  *p = '\0';
-  return res;
-}
-
 /* The function creates an HTML index containing references to given
    directories and files on the appropriate host.  The references are
    FTP.  */
@@ -586,7 +524,7 @@ ftp_index (const char *file, struct urlinfo *u, struct fileinfo *f)
       upwd = (char *)xmalloc (strlen (tmpu)
 			     + (tmpp ? (1 + strlen (tmpp)) : 0) + 2);
       sprintf (upwd, "%s%s%s@", tmpu, tmpp ? ":" : "", tmpp ? tmpp : "");
-      free (tmpu);
+      xfree (tmpu);
       FREE_MAYBE (tmpp);
     }
   else
@@ -652,11 +590,11 @@ ftp_index (const char *file, struct urlinfo *u, struct fileinfo *f)
       else if (f->type == FT_SYMLINK)
 	fprintf (fp, "-> %s", f->linkto ? f->linkto : "(nil)");
       putc ('\n', fp);
-      free (htclfile);
+      xfree (htclfile);
       f = f->next;
     }
   fprintf (fp, "</pre>\n</body>\n</html>\n");
-  free (upwd);
+  xfree (upwd);
   if (!opt.dfp)
     fclose (fp);
   else
diff --git a/src/ftp.c b/src/ftp.c
index d628ad1..a8b7907 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -869,7 +869,7 @@ Error in server response, closing control connection.\n"));
   rbuf_discard (&con->rbuf);
   if (err != FTPOK)
     {
-      free (respline);
+      xfree (respline);
       /* The control connection is decidedly closed.  Print the time
 	 only if it hasn't already been printed.  */
       if (res != -1)
@@ -889,13 +889,13 @@ Error in server response, closing control connection.\n"));
      become apparent later.  */
   if (*respline != '2')
     {
-      free (respline);
+      xfree (respline);
       if (res != -1)
 	logprintf (LOG_NOTQUIET, "%s (%s) - ", tms, tmrate);
       logputs (LOG_NOTQUIET, _("Data transfer aborted.\n"));
       return FTPRETRINT;
     }
-  free (respline);
+  xfree (respline);
 
   if (res == -1)
     {
@@ -927,7 +927,7 @@ Error in server response, closing control connection.\n"));
 	  while ((line = read_whole_line (fp)))
 	    {
 	      logprintf (LOG_ALWAYS, "%s\n", line);
-	      free (line);
+	      xfree (line);
 	    }
 	  fclose (fp);
 	}
@@ -1041,7 +1041,7 @@ ftp_loop_internal (struct urlinfo *u, struct fileinfo *f, ccon *con)
 #ifdef WINDOWS
 	  ws_changetitle (hurl, 1);
 #endif
-	  free (hurl);
+	  xfree (hurl);
 	}
       /* Send getftp the proper length, if fileinfo was provided.  */
       if (f)
@@ -1109,7 +1109,7 @@ ftp_loop_internal (struct urlinfo *u, struct fileinfo *f, ccon *con)
 	  char *hurl = str_url (u->proxy ? u->proxy : u, 1);
 	  logprintf (LOG_NONVERBOSE, "%s URL: %s [%ld] -> \"%s\" [%d]\n",
 		     tms, hurl, len, locf, count);
-	  free (hurl);
+	  xfree (hurl);
 	}
 
       if ((con->cmd & DO_LIST))
@@ -1196,7 +1196,7 @@ ftp_get_listing (struct urlinfo *u, ccon *con)
       else
 	logprintf (LOG_VERBOSE, _("Removed `%s'.\n"), list_filename);
     }
-  free (list_filename);
+  xfree (list_filename);
   con->cmd &= ~DO_LIST;
   return f;
 }
@@ -1395,7 +1395,7 @@ Already have correct symlink %s -> %s\n\n"),
       else
 	DEBUGP (("Unrecognized permissions for %s.\n", u->local));
 
-      free (u->local);
+      xfree (u->local);
       u->local = olocal;
       u->file = ofile;
       /* Break on fatals.  */
@@ -1608,7 +1608,7 @@ ftp_loop (struct urlinfo *u, int *dt)
 			       _("Wrote HTML-ized index to `%s'.\n"),
 			       filename);
 		}
-	      free (filename);
+	      xfree (filename);
 	    }
 	  freefileinfo (f);
 	}
@@ -1646,9 +1646,9 @@ delelement (struct fileinfo *f, struct fileinfo **start)
   struct fileinfo *prev = f->prev;
   struct fileinfo *next = f->next;
 
-  free (f->name);
+  xfree (f->name);
   FREE_MAYBE (f->linkto);
-  free (f);
+  xfree (f);
 
   if (next)
     next->prev = prev;
@@ -1666,10 +1666,10 @@ freefileinfo (struct fileinfo *f)
   while (f)
     {
       struct fileinfo *next = f->next;
-      free (f->name);
+      xfree (f->name);
       if (f->linkto)
-	free (f->linkto);
-      free (f);
+	xfree (f->linkto);
+      xfree (f);
       f = next;
     }
 }
diff --git a/src/hash.c b/src/hash.c
index 705d8d3..1f730f2 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -192,8 +192,8 @@ hash_table_new (int initial_size,
 void
 hash_table_destroy (struct hash_table *ht)
 {
-  free (ht->mappings);
-  free (ht);
+  xfree (ht->mappings);
+  xfree (ht);
 }
 
 /* The heart of almost all functions in this file -- find the mapping
@@ -320,7 +320,7 @@ grow_hash_table (struct hash_table *ht)
 	hash_table_put (ht, mp_key, mp->value);
     }
   assert (ht->count == old_count);
-  free (old_mappings);
+  xfree (old_mappings);
 }
 
 /* Put VALUE in the hash table HT under the key KEY.  This regrows the
@@ -544,7 +544,7 @@ main (void)
 	  if (hash_table_get_pair (ht, line, &line_copy, NULL))
 	    {
 	      hash_table_remove (ht, line);
-	      free (line_copy);
+	      xfree (line_copy);
 	    }
 	}
 #endif
diff --git a/src/host.c b/src/host.c
index eeb4940..8b37d19 100644
--- a/src/host.c
+++ b/src/host.c
@@ -289,34 +289,34 @@ same_host (const char *u1, const char *u2)
   DEBUGP (("Comparing hosts %s and %s...\n", p1, p2));
   if (strcasecmp (p1, p2) == 0)
     {
-      free (p1);
-      free (p2);
+      xfree (p1);
+      xfree (p2);
       DEBUGP (("They are quite alike.\n"));
       return 1;
     }
   else if (opt.simple_check)
     {
-      free (p1);
-      free (p2);
+      xfree (p1);
+      xfree (p2);
       DEBUGP (("Since checking is simple, I'd say they are not the same.\n"));
       return 0;
     }
   real1 = realhost (p1);
   real2 = realhost (p2);
-  free (p1);
-  free (p2);
+  xfree (p1);
+  xfree (p2);
   if (strcasecmp (real1, real2) == 0)
     {
       DEBUGP (("They are alike, after realhost()->%s.\n", real1));
-      free (real1);
-      free (real2);
+      xfree (real1);
+      xfree (real2);
       return 1;
     }
   else
     {
       DEBUGP (("They are not the same (%s, %s).\n", real1, real2));
-      free (real1);
-      free (real2);
+      xfree (real1);
+      xfree (real2);
       return 0;
     }
 }
diff --git a/src/html-parse.c b/src/html-parse.c
index b5efa7f..0b42746 100644
--- a/src/html-parse.c
+++ b/src/html-parse.c
@@ -166,15 +166,15 @@ struct pool {
 /* Forget old pool contents.  The allocated memory is not freed. */
 #define POOL_REWIND(pool) pool.index = 0
 
-/* Free heap-allocated memory for contents of POOL.  This calls free()
-   if the memory was allocated through malloc.  It also restores
-   `contents' and `size' to their original, pre-malloc values.  That
-   way after POOL_FREE, the pool is fully usable, just as if it were
-   freshly initialized with POOL_INIT.  */
+/* Free heap-allocated memory for contents of POOL.  This calls
+   xfree() if the memory was allocated through malloc.  It also
+   restores `contents' and `size' to their original, pre-malloc
+   values.  That way after POOL_FREE, the pool is fully usable, just
+   as if it were freshly initialized with POOL_INIT.  */
 
 #define POOL_FREE(pool) do {			\
   if (!(pool).alloca_p)				\
-    free ((pool).contents);			\
+    xfree ((pool).contents);			\
   (pool).contents = (pool).orig_contents;	\
   (pool).size = (pool).orig_size;		\
   (pool).index = 0;				\
@@ -812,7 +812,7 @@ map_html_tags (const char *text, int size,
  finish:
   POOL_FREE (pool);
   if (!attr_pair_alloca_p)
-    free (pairs);
+    xfree (pairs);
 }
 
 #undef ADVANCE
diff --git a/src/html-url.c b/src/html-url.c
index dd59f18..58cbabf 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -416,7 +416,7 @@ collect_tags_mapper (struct taginfo *tag, void *arg)
 	    if (!newbase)
 	      break;
 	    if (closure->base)
-	      free (closure->base);
+	      xfree (closure->base);
 	    if (closure->parent_base)
 	      closure->base = url_concat (closure->parent_base, newbase);
 	    else
diff --git a/src/html.c b/src/html.c
index 5b2de9a..5ab0567 100644
--- a/src/html.c
+++ b/src/html.c
@@ -182,7 +182,7 @@ htmlfindurl (const char *buf, int bufsize, int *size, int init,
 	  s->tag = strdupdelim (p, buf);
 	  if (*buf == '>')
 	    {
-	      free (s->tag);
+	      xfree (s->tag);
 	      s->tag = NULL;
 	      ++buf, --bufsize;
 	      continue;
@@ -605,7 +605,7 @@ ftp_index (const char *file, struct urlinfo *u, struct fileinfo *f)
       upwd = (char *)xmalloc (strlen (tmpu)
 			     + (tmpp ? (1 + strlen (tmpp)) : 0) + 2);
       sprintf (upwd, "%s%s%s@", tmpu, tmpp ? ":" : "", tmpp ? tmpp : "");
-      free (tmpu);
+      xfree (tmpu);
       FREE_MAYBE (tmpp);
     }
   else
@@ -671,11 +671,11 @@ ftp_index (const char *file, struct urlinfo *u, struct fileinfo *f)
       else if (f->type == FT_SYMLINK)
 	fprintf (fp, "-> %s", f->linkto ? f->linkto : "(nil)");
       putc ('\n', fp);
-      free (htclfile);
+      xfree (htclfile);
       f = f->next;
     }
   fprintf (fp, "</pre>\n</body>\n</html>\n");
-  free (upwd);
+  xfree (upwd);
   if (!opt.dfp)
     fclose (fp);
   else
diff --git a/src/http.c b/src/http.c
index 8c36a25..b487cbc 100644
--- a/src/http.c
+++ b/src/http.c
@@ -763,7 +763,7 @@ Accept: %s\r\n\
 	     what you accept."  Oh boy.  */
 	  logputs (LOG_VERBOSE, "\n");
 	  logputs (LOG_NOTQUIET, _("End of file while parsing headers.\n"));
-	  free (hdr);
+	  xfree (hdr);
 	  FREE_MAYBE (type);
 	  FREE_MAYBE (hs->newloc);
 	  FREE_MAYBE (all_headers);
@@ -775,7 +775,7 @@ Accept: %s\r\n\
 	  logputs (LOG_VERBOSE, "\n");
 	  logprintf (LOG_NOTQUIET, _("Read error (%s) in headers.\n"),
 		     strerror (errno));
-	  free (hdr);
+	  xfree (hdr);
 	  FREE_MAYBE (type);
 	  FREE_MAYBE (hs->newloc);
 	  FREE_MAYBE (all_headers);
@@ -816,7 +816,7 @@ Accept: %s\r\n\
 		hs->error = xstrdup (_("No data received"));
 	      else
 		hs->error = xstrdup (_("Malformed status line"));
-	      free (hdr);
+	      xfree (hdr);
 	      break;
 	    }
 	  else if (!*error)
@@ -837,7 +837,7 @@ Accept: %s\r\n\
       /* Exit on empty header.  */
       if (!*hdr)
 	{
-	  free (hdr);
+	  xfree (hdr);
 	  break;
 	}
 
@@ -905,7 +905,7 @@ Accept: %s\r\n\
 	    }
 	}
     done_header:
-      free (hdr);
+      xfree (hdr);
     }
 
   logputs (LOG_VERBOSE, "\n");
@@ -935,12 +935,12 @@ Accept: %s\r\n\
 	     retrying it.  */
 	failed:
 	  logputs (LOG_NOTQUIET, _("Authorization failed.\n"));
-	  free (authenticate_h);
+	  xfree (authenticate_h);
 	  return AUTHFAILED;
 	}
       else if (!known_authentication_scheme_p (authenticate_h))
 	{
-	  free (authenticate_h);
+	  xfree (authenticate_h);
 	  logputs (LOG_NOTQUIET, _("Unknown authentication scheme.\n"));
 	  return AUTHFAILED;
 	}
@@ -960,7 +960,7 @@ Accept: %s\r\n\
   /* We do not need this anymore.  */
   if (authenticate_h)
     {
-      free (authenticate_h);
+      xfree (authenticate_h);
       authenticate_h = NULL;
     }
 
@@ -1192,8 +1192,8 @@ File `%s' already there, will not retrieve.\n"), u->local);
       if (((suf = suffix (u->local)) != NULL)
 	  && (!strcmp (suf, "html") || !strcmp (suf, "htm")))
 	*dt |= TEXTHTML;
-      free (suf);
-      free(filename_plus_orig_suffix);  /* must precede every return! */
+      xfree (suf);
+      xfree (filename_plus_orig_suffix); /* must precede every return! */
       /* Another harmless lie: */
       return RETROK;
     }
@@ -1286,7 +1286,7 @@ File `%s' already there, will not retrieve.\n"), u->local);
 #ifdef WINDOWS
 	  ws_changetitle (hurl, 1);
 #endif
-	  free (hurl);
+	  xfree (hurl);
 	}
 
       /* Default document type is empty.  However, if spider mode is
@@ -1341,7 +1341,7 @@ File `%s' already there, will not retrieve.\n"), u->local);
 	case HOSTERR: case CONREFUSED: case PROXERR: case AUTHFAILED:
 	  /* Fatal errors just return from the function.  */
 	  FREEHSTAT (hstat);
-	  free(filename_plus_orig_suffix);  /* must precede every return! */
+	  xfree (filename_plus_orig_suffix); /* must precede every return! */
 	  return err;
 	  break;
 	case FWRITEERR: case FOPENERR:
@@ -1350,7 +1350,7 @@ File `%s' already there, will not retrieve.\n"), u->local);
 	  logprintf (LOG_NOTQUIET, _("Cannot write to `%s' (%s).\n"),
 		     u->local, strerror (errno));
 	  FREEHSTAT (hstat);
-	  free(filename_plus_orig_suffix);  /* must precede every return! */
+	  xfree (filename_plus_orig_suffix); /* must precede every return! */
 	  return err;
 	  break;
 	case NEWLOCATION:
@@ -1360,11 +1360,11 @@ File `%s' already there, will not retrieve.\n"), u->local);
 	      logprintf (LOG_NOTQUIET,
 			 _("ERROR: Redirection (%d) without location.\n"),
 			 hstat.statcode);
-	      free(filename_plus_orig_suffix);  /* must precede every return! */
+	      xfree (filename_plus_orig_suffix); /* must precede every return! */
 	      return WRONGCODE;
 	    }
 	  FREEHSTAT (hstat);
-	  free(filename_plus_orig_suffix);  /* must precede every return! */
+	  xfree (filename_plus_orig_suffix); /* must precede every return! */
 	  return NEWLOCATION;
 	  break;
 	case RETRFINISHED:
@@ -1381,13 +1381,13 @@ File `%s' already there, will not retrieve.\n"), u->local);
 	      /* #### Ugly ugly ugly! */
 	      char *hurl = str_url (u->proxy ? u->proxy : u, 1);
 	      logprintf (LOG_NONVERBOSE, "%s:\n", hurl);
-	      free (hurl);
+	      xfree (hurl);
 	    }
 	  logprintf (LOG_NOTQUIET, _("%s ERROR %d: %s.\n"),
 		     tms, hstat.statcode, hstat.error);
 	  logputs (LOG_VERBOSE, "\n");
 	  FREEHSTAT (hstat);
-	  free(filename_plus_orig_suffix);  /* must precede every return! */
+	  xfree (filename_plus_orig_suffix); /* must precede every return! */
 	  return WRONGCODE;
 	}
 
@@ -1431,7 +1431,7 @@ Last-modified header invalid -- time-stamp ignored.\n"));
 Server file no newer than local file `%s' -- not retrieving.\n\n"),
 			     local_filename);
 		  FREEHSTAT (hstat);
-		  free(filename_plus_orig_suffix);/*must precede every return!*/
+		  xfree (filename_plus_orig_suffix); /*must precede every return!*/
 		  return RETROK;
 		}
 	      else if (tml >= tmr)
@@ -1459,7 +1459,7 @@ The sizes do not match (local %ld) -- retrieving.\n"), local_size);
       if (opt.spider)
 	{
 	  logprintf (LOG_NOTQUIET, "%d %s\n\n", hstat.statcode, hstat.error);
-	  free(filename_plus_orig_suffix);  /* must precede every return! */
+	  xfree (filename_plus_orig_suffix); /* must precede every return! */
 	  return RETROK;
 	}
 
@@ -1489,7 +1489,7 @@ The sizes do not match (local %ld) -- retrieving.\n"), local_size);
 	  else
 	    downloaded_file(FILE_DOWNLOADED_NORMALLY, locf);
 
-	  free(filename_plus_orig_suffix);  /* must precede every return! */
+	  xfree(filename_plus_orig_suffix); /* must precede every return! */
 	  return RETROK;
 	}
       else if (hstat.res == 0) /* No read error */
@@ -1515,7 +1515,7 @@ The sizes do not match (local %ld) -- retrieving.\n"), local_size);
 	      else
 		downloaded_file(FILE_DOWNLOADED_NORMALLY, locf);
 	      
-	      free(filename_plus_orig_suffix);  /* must precede every return! */
+	      xfree (filename_plus_orig_suffix); /* must precede every return! */
 	      return RETROK;
 	    }
 	  else if (hstat.len < hstat.contlen) /* meaning we lost the
@@ -1544,7 +1544,7 @@ The sizes do not match (local %ld) -- retrieving.\n"), local_size);
 	      else
 		downloaded_file(FILE_DOWNLOADED_NORMALLY, locf);
 	      
-	      free(filename_plus_orig_suffix);  /* must precede every return! */
+	      xfree (filename_plus_orig_suffix); /* must precede every return! */
 	      return RETROK;
 	    }
 	  else			/* the same, but not accepted */
@@ -1580,7 +1580,7 @@ The sizes do not match (local %ld) -- retrieving.\n"), local_size);
       break;
     }
   while (!opt.ntry || (count < opt.ntry));
-  free(filename_plus_orig_suffix);  /* must precede every return! */
+  xfree (filename_plus_orig_suffix); /* must precede every return! */
   return TRYLIMEXC;
 }
 
diff --git a/src/init.c b/src/init.c
index e7b974f..773f986 100644
--- a/src/init.c
+++ b/src/init.c
@@ -311,7 +311,7 @@ wgetrc_file_name (void)
     return NULL;
   if (!file_exists_p (file))
     {
-      free (file);
+      xfree (file);
       return NULL;
     }
   return file;
@@ -341,15 +341,15 @@ run_wgetrc (const char *file)
 
       /* Parse the line.  */
       status = parse_line (line, &com, &val);
-      free (line);
+      xfree (line);
       /* If everything is OK, set the value.  */
       if (status == 1)
 	{
 	  if (!setval (com, val))
 	    fprintf (stderr, _("%s: Error in %s at line %d.\n"), exec_name,
 		     file, ln);
-	  free (com);
-	  free (val);
+	  xfree (com);
+	  xfree (val);
 	}
       else if (status == 0)
 	fprintf (stderr, _("%s: Error in %s at line %d.\n"), exec_name,
@@ -390,7 +390,7 @@ initialize (void)
   else
 #endif
     run_wgetrc (file);
-  free (file);
+  xfree (file);
   return;
 }
 
@@ -436,7 +436,7 @@ parse_line (const char *line, char **com, char **val)
   /* If the command is invalid, exit now.  */
   if (comind (*com) == -1)
     {
-      free (*com);
+      xfree (*com);
       return 0;
     }
 
@@ -445,7 +445,7 @@ parse_line (const char *line, char **com, char **val)
   /* If '=' not found, bail out.  */
   if (*p != '=')
     {
-      free (*com);
+      xfree (*com);
       return 0;
     }
   /* Skip spaces after '='.  */
@@ -993,7 +993,7 @@ cleanup (void)
   if (opt.dfp)
     fclose (opt.dfp);
   FREE_MAYBE (opt.lfilename);
-  free (opt.dir_prefix);
+  xfree (opt.dir_prefix);
   FREE_MAYBE (opt.input_filename);
   FREE_MAYBE (opt.output_document);
   free_vec (opt.accepts);
@@ -1003,8 +1003,8 @@ cleanup (void)
   free_vec (opt.domains);
   free_vec (opt.follow_tags);
   free_vec (opt.ignore_tags);
-  free (opt.ftp_acc);
-  free (opt.ftp_pass);
+  xfree (opt.ftp_acc);
+  xfree (opt.ftp_pass);
   FREE_MAYBE (opt.ftp_proxy);
   FREE_MAYBE (opt.http_proxy);
   free_vec (opt.no_proxy);
diff --git a/src/log.c b/src/log.c
index a71edf3..c12ed22 100644
--- a/src/log.c
+++ b/src/log.c
@@ -112,7 +112,7 @@ free_log_line (int num)
   struct log_ln *ln = log_lines + num;
   if (ln->malloced_line)
     {
-      free (ln->malloced_line);
+      xfree (ln->malloced_line);
       ln->malloced_line = NULL;
     }
   ln->content = NULL;
@@ -346,7 +346,7 @@ logvprintf (enum log_options o, const char *fmt, va_list args)
       saved_append (write_ptr);
       fputs (write_ptr, logfp);
       if (bigmsg)
-	free (bigmsg);
+	xfree (bigmsg);
     }
   if (!opt.no_flush)
     fflush (logfp);
@@ -524,7 +524,7 @@ redirect_output (const char *messij)
       logfp = stdin;
     }
   fprintf (stderr, messij, logfile);
-  free (logfile);
+  xfree (logfile);
   /* Dump the previous screenful of output to LOGFILE.  */
   log_dump ();
   save_log_p = 0;
diff --git a/src/main.c b/src/main.c
index 5cbd692..1af9ba1 100644
--- a/src/main.c
+++ b/src/main.c
@@ -535,8 +535,8 @@ GNU General Public License for more details.\n"));
 			 optarg);
 		exit (1);
 	      }
-	    free (com);
-	    free (val);
+	    xfree (com);
+	    xfree (val);
 	  }
 	  break;
 	case 'G':
diff --git a/src/mswindows.c b/src/mswindows.c
index efc643c..bf09b09 100644
--- a/src/mswindows.c
+++ b/src/mswindows.c
@@ -208,7 +208,7 @@ ws_mypath (void)
       strcpy (wspathsave, buffer);
       return wspathsave;
     }
-  free (buffer);
+  xfree (buffer);
   return NULL;
 }
 
diff --git a/src/netrc.c b/src/netrc.c
index de9f69e..432a8c1 100644
--- a/src/netrc.c
+++ b/src/netrc.c
@@ -79,7 +79,7 @@ search_netrc (const char *host, const char **acc, const char **passwd,
 	  char *path = (char *)alloca (strlen (home) + 1
 				       + strlen (NETRC_FILE_NAME) + 1);
 	  sprintf (path, "%s/%s", home, NETRC_FILE_NAME);
-	  free (home);
+	  xfree (home);
 	  err = stat (path, &buf);
 	  if (err == 0)
 	    netrc_list = parse_netrc (path);
@@ -173,7 +173,7 @@ read_whole_line (FILE *fp)
     }
   if (c == EOF && !i)
     {
-      free(line);
+      xfree(line);
       return NULL;
     }
 
@@ -200,9 +200,9 @@ maybe_add_to_list (acc_t **newentry, acc_t **list)
   if (a && ! a->acc)
     {
       /* Free any allocated space.  */
-      free (a->host);
-      free (a->acc);
-      free (a->passwd);
+      xfree (a->host);
+      xfree (a->acc);
+      xfree (a->passwd);
     }
   else
     {
@@ -392,14 +392,14 @@ parse_netrc (const char *path)
 	    }
 	}
 
-      free (line);
+      xfree (line);
     }
 
   fclose (fp);
 
   /* Finalize the last machine entry we found.  */
   maybe_add_to_list (&current, &retval);
-  free (current);
+  xfree (current);
 
   /* Reverse the order of the list so that it appears in file order.  */
   current = retval;
@@ -433,7 +433,7 @@ free_netrc(acc_t *l)
       FREE_MAYBE (l->acc);
       FREE_MAYBE (l->passwd);
       FREE_MAYBE (l->host);
-      free(l);
+      xfree (l);
       l = t;
     }
 }
diff --git a/src/recur.c b/src/recur.c
index 904d367..98c5597 100644
--- a/src/recur.c
+++ b/src/recur.c
@@ -382,10 +382,10 @@ recursive_retrieve (const char *file, const char *this_url)
 	      /* Just lowercase the hostname.  */
 	      for (p = u->host; *p; p++)
 		*p = TOLOWER (*p);
-	      free (u->url);
+	      xfree (u->url);
 	      u->url = str_url (u, 0);
 	    }
-	  free (constr);
+	  xfree (constr);
 	  constr = xstrdup (u->url);
 	  string_set_add (undesirable_urls, constr);
 	  if (!inl && !((u->proto == URLFTP) && !this_url_ftp))
@@ -422,7 +422,7 @@ recursive_retrieve (const char *file, const char *this_url)
 		  rfile = url_filename (rurl);
 		  forbidden = parse_robots (rfile);
 		  freeurl (rurl, 1);
-		  free (rfile);
+		  xfree (rfile);
 		}
 	    }
 
@@ -463,7 +463,7 @@ recursive_retrieve (const char *file, const char *this_url)
 	    }
 	  if (newloc)
 	    {
-	      free (constr);
+	      xfree (constr);
 	      constr = newloc;
 	    }
 	  /* In case of convert_links: If there was no error, add it to
@@ -657,9 +657,9 @@ robots_url (const char *url, const char *robots_filename)
 
   err = parseurl (url, u, 0);
   assert (err == URLOK && u->proto == URLHTTP);
-  free (u->file);
-  free (u->dir);
-  free (u->url);
+  xfree (u->file);
+  xfree (u->dir);
+  xfree (u->url);
   u->dir = xstrdup ("");
   u->file = xstrdup (robots_filename);
   u->url = str_url (u, 0);
@@ -764,7 +764,7 @@ parse_robots (const char *robots_filename)
       for (cmd = line; *cmd && ISSPACE (*cmd); cmd++);
       if (!*cmd)
 	{
-	  free (line);
+	  xfree (line);
 	  DEBUGP (("(chucked out)\n"));
 	  continue;
 	}
@@ -772,7 +772,7 @@ parse_robots (const char *robots_filename)
       for (str = cmd; *str && *str != ':'; str++);
       if (!*str)
 	{
-	  free (line);
+	  xfree (line);
 	  DEBUGP (("(chucked out)\n"));
 	  continue;
 	}
@@ -831,7 +831,7 @@ parse_robots (const char *robots_filename)
 	}
       else if (!wget_matched)
 	{
-	  free (line);
+	  xfree (line);
 	  DEBUGP (("(chucking out since it is not applicable for Wget)\n"));
 	  continue;
 	}
@@ -861,7 +861,7 @@ parse_robots (const char *robots_filename)
 	  /* unknown command */
 	  DEBUGP (("(chucked out)\n"));
 	}
-      free (line);
+      xfree (line);
     }
   fclose (fp);
   return entries;
diff --git a/src/retr.c b/src/retr.c
index 30f4556..800ee5d 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -355,7 +355,7 @@ retrieve_url (const char *origurl, char **file, char **newloc,
       freeurl (u, 1);
       if (redirections)
 	string_set_free (redirections);
-      free (url);
+      xfree (url);
       return result;
     }
 
@@ -392,7 +392,7 @@ retrieve_url (const char *origurl, char **file, char **newloc,
 	  freeurl (u, 1);
 	  if (redirections)
 	    string_set_free (redirections);
-	  free (url);
+	  xfree (url);
 	  return PROXERR;
 	}
       /* Parse the proxy URL.  */
@@ -406,7 +406,7 @@ retrieve_url (const char *origurl, char **file, char **newloc,
 	  freeurl (u, 1);
 	  if (redirections)
 	    string_set_free (redirections);
-	  free (url);
+	  xfree (url);
 	  return PROXERR;
 	}
       u->proto = URLHTTP;
@@ -456,7 +456,7 @@ retrieve_url (const char *origurl, char **file, char **newloc,
 	 there break the rules and use relative URLs, and popular
 	 browsers are lenient about this, so wget should be too. */
       construced_newloc = url_concat (url, mynewloc);
-      free (mynewloc);
+      xfree (mynewloc);
       mynewloc = construced_newloc;
 
       /* Now, see if this new location makes sense. */
@@ -469,15 +469,15 @@ retrieve_url (const char *origurl, char **file, char **newloc,
 	  freeurl (u, 1);
 	  if (redirections)
 	    string_set_free (redirections);
-	  free (url);
-	  free (mynewloc);
+	  xfree (url);
+	  xfree (mynewloc);
 	  return result;
 	}
 
       /* Now mynewloc will become newloc_struct->url, because if the
          Location contained relative paths like .././something, we
          don't want that propagating as url.  */
-      free (mynewloc);
+      xfree (mynewloc);
       mynewloc = xstrdup (newloc_struct->url);
 
       if (!redirections)
@@ -498,13 +498,13 @@ retrieve_url (const char *origurl, char **file, char **newloc,
 	  freeurl (u, 1);
 	  if (redirections)
 	    string_set_free (redirections);
-	  free (url);
-	  free (mynewloc);
+	  xfree (url);
+	  xfree (mynewloc);
 	  return WRONGCODE;
 	}
       string_set_add (redirections, newloc_struct->url);
 
-      free (url);
+      xfree (url);
       url = mynewloc;
       freeurl (u, 1);
       u = newloc_struct;
@@ -525,7 +525,7 @@ retrieve_url (const char *origurl, char **file, char **newloc,
   if (newloc)
     *newloc = url;
   else
-    free (url);
+    xfree (url);
 
   return result;
 }
diff --git a/src/url.c b/src/url.c
index dcb51ac..857aada 100644
--- a/src/url.c
+++ b/src/url.c
@@ -61,7 +61,7 @@ static char unsafe_char_table[256];
   if (contains_unsafe (s))			\
     {						\
       char *uc_tmp = encode_string (s);		\
-      free (s);					\
+      xfree (s);				\
       (s) = uc_tmp;				\
     }						\
 } while (0)
@@ -377,7 +377,7 @@ freeurl (struct urlinfo *u, int complete)
   if (u->proxy)
     freeurl (u->proxy, 1);
   if (complete)
-    free (u);
+    xfree (u);
   return;
 }
 
@@ -697,7 +697,7 @@ str_url (const struct urlinfo *u, int hide)
       tmp[1] = '2';
       tmp[2] = 'F';
       strcpy (tmp + 3, dir + 1);
-      free (dir);
+      xfree (dir);
       dir = tmp;
     }
 
@@ -741,9 +741,9 @@ str_url (const struct urlinfo *u, int hide)
   if (*dir)
     res[l++] = '/';
   strcpy (res + l, file);
-  free (host);
-  free (dir);
-  free (file);
+  xfree (host);
+  xfree (dir);
+  xfree (file);
   FREE_MAYBE (user);
   FREE_MAYBE (passwd);
   return res;
@@ -839,9 +839,9 @@ free_urlpos (urlpos *l)
   while (l)
     {
       urlpos *next = l->next;
-      free (l->url);
+      xfree (l->url);
       FREE_MAYBE (l->local_name);
-      free (l);
+      xfree (l);
       l = next;
     }
 }
@@ -894,7 +894,7 @@ mkalldirs (const char *path)
     {
       if (S_ISDIR (st.st_mode))
 	{
-	  free (t);
+	  xfree (t);
 	  return 0;
 	}
       else
@@ -918,7 +918,7 @@ mkalldirs (const char *path)
   res = make_directory (t);
   if (res != 0)
     logprintf (LOG_NOTQUIET, "%s: %s", t, strerror (errno));
-  free (t);
+  xfree (t);
   return res;
 }
 
@@ -962,7 +962,7 @@ mkstruct (const struct urlinfo *u)
   if (opt.add_hostdir && !opt.simple_check)
     {
       char *nhost = realhost (host);
-      free (host);
+      xfree (host);
       host = nhost;
     }
   /* Add dir_prefix and hostname (if required) to the beginning of
@@ -985,7 +985,7 @@ mkstruct (const struct urlinfo *u)
       else
 	dirpref = "";
     }
-  free (host);
+  xfree (host);
 
   /* If there is a prefix, prepend it.  */
   if (*dirpref)
@@ -1008,7 +1008,7 @@ mkstruct (const struct urlinfo *u)
   /* Finally, construct the full name.  */
   res = (char *)xmalloc (strlen (dir) + 1 + strlen (file) + 1);
   sprintf (res, "%s%s%s", dir, *dir ? "/" : "", file);
-  free (dir);
+  xfree (dir);
   return res;
 }
 
@@ -1042,7 +1042,7 @@ url_filename (const struct urlinfo *u)
 	  char *nfile = (char *)xmalloc (strlen (opt.dir_prefix)
 					 + 1 + strlen (file) + 1);
 	  sprintf (nfile, "%s/%s", opt.dir_prefix, file);
-	  free (file);
+	  xfree (file);
 	  file = nfile;
 	}
     }
@@ -1071,7 +1071,7 @@ url_filename (const struct urlinfo *u)
 
   /* Find a unique name.  */
   name = unique_name (file);
-  free (file);
+  xfree (file);
   return name;
 }
 
@@ -1245,11 +1245,11 @@ opt_url (struct urlinfo *u)
 {
   /* Find the "true" host.  */
   char *host = realhost (u->host);
-  free (u->host);
+  xfree (u->host);
   u->host = host;
   assert (u->dir != NULL);      /* the URL must have been parsed */
   /* Refresh the printed representation.  */
-  free (u->url);
+  xfree (u->url);
   u->url = str_url (u, 0);
 }
 
@@ -1389,24 +1389,28 @@ convert_links (const char *file, urlpos *l)
 	{
 	  /* Convert absolute URL to relative. */
 	  char *newname = construct_relative (file, l->local_name);
+	  char *quoted_newname = html_quote_string (newname);
 	  putc (*p, fp);	/* quoting char */
-	  fputs (newname, fp);
+	  fputs (quoted_newname, fp);
 	  p += l->size - 1;
 	  putc (*p, fp);	/* close quote */
 	  ++p;
+	  xfree (newname);
+	  xfree (quoted_newname);
 	  DEBUGP (("TO_RELATIVE: %s to %s at position %d in %s.\n",
 		   l->url, newname, l->pos, file));
-	  free (newname);
 	}
       else if (l->convert == CO_CONVERT_TO_COMPLETE)
 	{
 	  /* Convert the link to absolute URL. */
 	  char *newlink = l->url;
+	  char *quoted_newlink = html_quote_string (newlink);
 	  putc (*p, fp);	/* quoting char */
-	  fputs (newlink, fp);
+	  fputs (quoted_newlink, fp);
 	  p += l->size - 1;
 	  putc (*p, fp);	/* close quote */
 	  ++p;
+	  xfree (quoted_newlink);
 	  DEBUGP (("TO_COMPLETE: <something> to %s at position %d in %s.\n",
 		   newlink, l->pos, file));
 	}
@@ -1553,7 +1557,19 @@ write_backup_file (const char *file, downloaded_file_t downloaded_file_return)
 	 rather than making a copy of the string...  Another note is that I
 	 thought I could just add a field to the urlpos structure saying
 	 that we'd written a .orig file for this URL, but that didn't work,
-	 so I had to make this separate list. */
+	 so I had to make this separate list.
+
+         This [adding a field to the urlpos structure] didn't work
+         because convert_file() is called twice: once after all its
+         sublinks have been retrieved in recursive_retrieve(), and
+         once at the end of the day in convert_all_links().  The
+         original linked list collected in recursive_retrieve() is
+         lost after the first invocation of convert_links(), and
+         convert_all_links() makes a new one (it calls get_urls_html()
+         for each file it covers.)  That's why your approach didn't
+         work.  The way to make it work is perhaps to make this flag a
+         field in the `urls_html' list.  */
+
       converted_file_ptr = xmalloc(sizeof(*converted_file_ptr));
       converted_file_ptr->string = xstrdup(file);  /* die on out-of-mem. */
       converted_file_ptr->next = converted_files;
diff --git a/src/utils.c b/src/utils.c
index 0d4de29..984b1f8 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -80,7 +80,9 @@ memfatal (const char *s)
 
 /* xmalloc, xrealloc and xstrdup exit the program if there is not
    enough memory.  xstrdup also implements strdup on systems that do
-   not have it.  */
+   not have it.  xfree is provided to make leak-tracking easier.
+   Currently it's a no-op.  */
+
 void *
 xmalloc (size_t size)
 {
@@ -92,6 +94,12 @@ xmalloc (size_t size)
   return res;
 }
 
+void
+xfree (void *ptr)
+{
+  free (ptr);
+}
+
 void *
 xrealloc (void *obj, size_t size)
 {
@@ -488,7 +496,7 @@ unique_name_1 (const char *fileprefix, int count)
     return filename;
   else
     {
-      free (filename);
+      xfree (filename);
       return NULL;
     }
 }
@@ -730,7 +738,7 @@ read_whole_line (FILE *fp)
     }
   if (length == 0 || ferror (fp))
     {
-      free (line);
+      xfree (line);
       return NULL;
     }
   if (length + 1 < bufsize)
@@ -858,13 +866,13 @@ read_file (const char *file)
  lose:
   if (!inhibit_close)
     close (fd);
-  free (fm->content);
-  free (fm);
+  xfree (fm->content);
+  xfree (fm);
   return NULL;
 }
 
 /* Release the resources held by FM.  Specifically, this calls
-   munmap() or free() on fm->content, depending whether mmap or
+   munmap() or xfree() on fm->content, depending whether mmap or
    malloc/read were used to read in the file.  It also frees the
    memory needed to hold the FM structure itself.  */
 
@@ -879,9 +887,9 @@ read_file_free (struct file_memory *fm)
   else
 #endif
     {
-      free (fm->content);
+      xfree (fm->content);
     }
-  free (fm);
+  xfree (fm);
 }
 
 /* Free the pointers in a NULL-terminated vector of pointers, then
@@ -893,8 +901,8 @@ free_vec (char **vec)
     {
       char **p = vec;
       while (*p)
-	free (*p++);
-      free (vec);
+	xfree (*p++);
+      xfree (vec);
     }
 }
 
@@ -913,7 +921,7 @@ merge_vecs (char **v1, char **v2)
   if (!*v2)
     {
       /* To avoid j == 0 */
-      free (v2);
+      xfree (v2);
       return v1;
     }
   /* Count v1.  */
@@ -923,7 +931,7 @@ merge_vecs (char **v1, char **v2)
   /* Reallocate v1.  */
   v1 = (char **)xrealloc (v1, (i + j + 1) * sizeof (char **));
   memcpy (v1 + i, v2, (j + 1) * sizeof (char *));
-  free (v2);
+  xfree (v2);
   return v1;
 }
 
@@ -1006,8 +1014,8 @@ slist_free (slist *l)
   while (l)
     {
       slist *n = l->next;
-      free (l->string);
-      free (l);
+      xfree (l->string);
+      xfree (l);
       l = n;
     }
 }
@@ -1044,7 +1052,7 @@ string_set_exists (struct hash_table *ht, const char *s)
 static int
 string_set_free_mapper (void *key, void *value_ignored, void *arg_ignored)
 {
-  free (key);
+  xfree (key);
   return 0;
 }
 
@@ -1058,8 +1066,8 @@ string_set_free (struct hash_table *ht)
 static int
 free_keys_and_values_mapper (void *key, void *value, void *arg_ignored)
 {
-  free (key);
-  free (value);
+  xfree (key);
+  xfree (value);
   return 0;
 }
 
@@ -1191,3 +1199,78 @@ long_to_string (char *buffer, long number)
   *p = '\0';
 #endif /* (SIZEOF_LONG == 4) || (SIZEOF_LONG == 8) */
 }
+
+/* This should probably be at a better place, but it doesn't really
+   fit into html-parse.c.  */
+
+/* The function returns the pointer to the malloc-ed quoted version of
+   string s.  It will recognize and quote numeric and special graphic
+   entities, as per RFC1866:
+
+   `&' -> `&amp;'
+   `<' -> `&lt;'
+   `>' -> `&gt;'
+   `"' -> `&quot;'
+   SP  -> `&#32;'
+
+   No other entities are recognized or replaced.  */
+char *
+html_quote_string (const char *s)
+{
+  const char *b = s;
+  char *p, *res;
+  int i;
+
+  /* Pass through the string, and count the new size.  */
+  for (i = 0; *s; s++, i++)
+    {
+      if (*s == '&')
+	i += 4;			/* `amp;' */
+      else if (*s == '<' || *s == '>')
+	i += 3;			/* `lt;' and `gt;' */
+      else if (*s == '\"')
+	i += 5;			/* `quot;' */
+      else if (*s == ' ')
+	i += 4;			/* #32; */
+    }
+  res = (char *)xmalloc (i + 1);
+  s = b;
+  for (p = res; *s; s++)
+    {
+      switch (*s)
+	{
+	case '&':
+	  *p++ = '&';
+	  *p++ = 'a';
+	  *p++ = 'm';
+	  *p++ = 'p';
+	  *p++ = ';';
+	  break;
+	case '<': case '>':
+	  *p++ = '&';
+	  *p++ = (*s == '<' ? 'l' : 'g');
+	  *p++ = 't';
+	  *p++ = ';';
+	  break;
+	case '\"':
+	  *p++ = '&';
+	  *p++ = 'q';
+	  *p++ = 'u';
+	  *p++ = 'o';
+	  *p++ = 't';
+	  *p++ = ';';
+	  break;
+	case ' ':
+	  *p++ = '&';
+	  *p++ = '#';
+	  *p++ = '3';
+	  *p++ = '2';
+	  *p++ = ';';
+	  break;
+	default:
+	  *p++ = *s;
+	}
+    }
+  *p = '\0';
+  return res;
+}
diff --git a/src/utils.h b/src/utils.h
index e4ac6f1..8e750b4 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -82,4 +82,6 @@ char *legible_very_long PARAMS ((VERY_LONG_TYPE));
 int numdigit PARAMS ((long));
 void long_to_string PARAMS ((char *, long));
 
+char *html_quote_string PARAMS ((const char *));
+
 #endif /* UTILS_H */
diff --git a/src/wget.h b/src/wget.h
index 718ee0b..6c41d0e 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -99,6 +99,7 @@ void logputs PARAMS ((enum log_options, const char *));
 
 /* Defined in `utils.c', but used literally everywhere.  */
 void *xmalloc PARAMS ((size_t));
+void xfree PARAMS ((void *));
 void *xrealloc PARAMS ((void *, size_t));
 char *xstrdup PARAMS ((const char *));
 
@@ -197,7 +198,7 @@ char *xstrdup PARAMS ((const char *));
 } while (0)
 
 /* Free FOO if it is non-NULL.  */
-#define FREE_MAYBE(foo) do { if (foo) free (foo); } while (0)
+#define FREE_MAYBE(foo) do { if (foo) xfree (foo); } while (0)
 
 /* #### Hack: OPTIONS_DEFINED_HERE is defined in main.c.  */
 /* [Is this weird hack really necessary on any compilers?  No ANSI C compiler
-- 
cgit v1.0-41-gc330

