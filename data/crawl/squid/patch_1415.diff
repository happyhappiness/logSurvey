@@ -1,5 +1,5 @@
 /*
- * $Id: hash.h,v 1.3 1998/09/23 20:13:46 wessels Exp $
+ * $Id: hash.h,v 1.4 2000/10/31 23:48:08 wessels Exp $
  */
 
 typedef void HASHFREE(void *);
@@ -9,7 +9,7 @@ typedef struct _hash_link hash_link;
 typedef struct _hash_table hash_table;
 
 struct _hash_link {
-    char *key;
+    void *key;
     hash_link *next;
 };
 
@@ -36,6 +36,7 @@ extern void hashFreeMemory(hash_table *);
 extern void hashFreeItems(hash_table *, HASHFREE *);
 extern HASHHASH hash_string;
 extern HASHHASH hash4;
+extern const char *hashKeyStr(hash_link *);
 
 /*
  *  Here are some good prime number choices.  It's important not to
@@ -54,4 +55,4 @@ extern HASHHASH hash4;
  *  HASH_SIZE 33493             // prime number < 32768
  *  HASH_SIZE 65357             // prime number < 65536
  */
-#define  DEFAULT_HASH_SIZE 7951 /* prime number < 8192 */
+#define  DEFAULT_HASH_SIZE 7951	/* prime number < 8192 */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: hash.c,v 1.9 2000/03/27 21:56:21 wessels Exp $
+ * $Id: hash.c,v 1.10 2000/10/31 23:48:12 wessels Exp $
  *
  * DEBUG: section 0     Hash Tables
  * AUTHOR: Harvest Derived
@@ -347,6 +347,15 @@ hashPrime(int n)
     return best_prime;
 }
 
+/*
+ * return the key of a hash_link as a const string
+ */
+const char *
+hashKeyStr(hash_link * hl)
+{
+    return (const char *) hl->key;
+}
+
 
 #ifdef USE_HASH_DRIVER
 /*
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrRange.cc,v 1.22 2000/10/04 15:32:13 wessels Exp $
+ * $Id: HttpHdrRange.cc,v 1.23 2000/10/31 23:48:12 wessels Exp $
  *
  * DEBUG: section 64    HTTP Range Header
  * AUTHOR: Alex Rousskov
@@ -467,7 +467,7 @@ httpHdrRangeBoundaryStr(clientHttpRequest * http)
     assert(http);
     stringAppend(&b, full_appname_string, strlen(full_appname_string));
     stringAppend(&b, ":", 1);
-    key = storeKeyText(http->entry->key);
+    key = storeKeyText(http->entry->hash.key);
     stringAppend(&b, key, strlen(key));
     return b;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.59 2000/10/10 18:15:30 wessels Exp $
+ * $Id: access_log.cc,v 1.60 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -397,8 +397,8 @@ fvdbCount(hash_table * hash, const char *key)
     fv = hash_lookup(hash, key);
     if (NULL == fv) {
 	fv = xcalloc(1, sizeof(fvdb_entry));
-	fv->key = xstrdup(key);
-	hash_join(hash, (hash_link *) fv);
+	fv->hash.key = xstrdup(key);
+	hash_join(hash, &fv->hash);
     }
     fv->n++;
 }
@@ -425,7 +425,7 @@ fvdbDumpTable(StoreEntry * e, hash_table * hash)
     hash_first(hash);
     while ((h = hash_next(hash))) {
 	fv = (fvdb_entry *) h;
-	storeAppendPrintf(e, "%9d %s\n", fv->n, fv->key);
+	storeAppendPrintf(e, "%9d %s\n", fv->n, hashKeyStr(&fv->hash));
     }
 }
 
@@ -446,7 +446,7 @@ void
 fvdbFreeEntry(void *data)
 {
     fvdb_entry *fv = data;
-    xfree(fv->key);
+    xfree(fv->hash.key);
     xfree(fv);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.224 2000/10/04 00:24:16 wessels Exp $
+ * $Id: acl.cc,v 1.225 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -1120,7 +1120,7 @@ aclMatchProxyAuth(void *data, const char *proxy_auth, acl_proxy_auth_user * auth
 	    auth_user->expiretime = current_time.tv_sec + Config.authenticateTTL;
 	    auth_user->ip_expiretime = squid_curtime + Config.authenticateIpTTL;
 	    auth_user->ipaddr = checklist->src_addr;
-	    hash_join(proxy_auth_cache, (hash_link *) auth_user);
+	    hash_join(proxy_auth_cache, &auth_user->hash);
 	    /* Continue checking below, as normal */
 	}
     }
@@ -1212,7 +1212,7 @@ aclLookupProxyAuthStart(aclCheck_t * checklist)
     debug(28, 4) ("aclLookupProxyAuthStart: going to ask authenticator on %s\n", user);
     /* we must still check this user's password */
     auth_user = memAllocate(MEM_ACL_PROXY_AUTH_USER);
-    auth_user->user = xstrdup(user);
+    auth_user->hash.key = xstrdup(user);
     auth_user->passwd = xstrdup(password);
     auth_user->passwd_ok = -1;
     auth_user->expiretime = -1;
@@ -1852,7 +1852,7 @@ static void
 aclFreeProxyAuthUser(void *data)
 {
     acl_proxy_auth_user *u = data;
-    xfree(u->user);
+    xfree(u->hash.key);
     xfree(u->passwd);
     memFree(u, MEM_ACL_PROXY_AUTH_USER);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.cc,v 1.12 2000/03/06 16:23:28 wessels Exp $
+ * $Id: authenticate.cc,v 1.13 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -88,7 +88,7 @@ authenticateStart(acl_proxy_auth_user * auth_user, RH * handler, void *data)
     char buf[8192];
     assert(auth_user);
     assert(handler);
-    debug(29, 5) ("authenticateStart: '%s:%s'\n", auth_user->user,
+    debug(29, 5) ("authenticateStart: '%s:%s'\n", hashKeyStr(&auth_user->hash),
 	auth_user->passwd);
     if (Config.Program.authenticate == NULL) {
 	handler(data, NULL);
@@ -100,7 +100,8 @@ authenticateStart(acl_proxy_auth_user * auth_user, RH * handler, void *data)
     cbdataLock(data);
     r->data = data;
     r->auth_user = auth_user;
-    snprintf(buf, 8192, "%s %s\n", r->auth_user->user, r->auth_user->passwd);
+    snprintf(buf, 8192, "%s %s\n", hashKeyStr(&r->auth_user->hash),
+	r->auth_user->passwd);
     helperSubmit(authenticators, buf, authenticateHandleReply, r);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_diff.cc,v 1.12 2000/06/06 19:34:31 hno Exp $
+ * $Id: cache_diff.cc,v 1.13 2000/10/31 23:48:13 wessels Exp $
  *
  * AUTHOR: Alex Rousskov
  *
@@ -172,7 +172,7 @@ cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file)
 		idx->bad_add_count++;
 	    } else {
 		CacheEntry *e = cacheEntryCreate(&s);
-		hash_join(idx->hash, (hash_link *) e);
+		hash_join(idx->hash, &e->hash);
 		idx->count++;
 	    }
 	} else if (s.op == SWAP_LOG_DEL) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cbdata.cc,v 1.30 2000/10/17 08:06:02 adrian Exp $
+ * $Id: cbdata.cc,v 1.31 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * AUTHOR: Duane Wessels
@@ -71,8 +71,7 @@ static hash_table *htable = NULL;
 static int cbdataCount = 0;
 
 typedef struct _cbdata {
-    const void *key;
-    struct _cbdata *next;
+    hash_link hash;		/* must be first */
     int valid;
     int locks;
     CBDUNL *unlock_func;
@@ -128,27 +127,27 @@ cbdataAdd(const void *p, CBDUNL * unlock_func, int id)
     assert(htable != NULL);
     assert(hash_lookup(htable, p) == NULL);
     c = memPoolAlloc(cbdata_pool);
-    c->key = p;
+    c->hash.key = (void *) p;
     c->valid = 1;
     c->unlock_func = unlock_func;
     c->id = id;
 #if CBDATA_DEBUG
     c->file = file;
     c->line = line;
 #endif
-    hash_join(htable, (hash_link *) c);
+    hash_join(htable, &c->hash);
     cbdataCount++;
 }
 
 static void
 cbdataReallyFree(cbdata * c)
 {
     CBDUNL *unlock_func = c->unlock_func;
-    void *p = (void *) c->key;
+    void *p = c->hash.key;
     int id = c->id;
     hash_remove_link(htable, (hash_link *) c);
     cbdataCount--;
-    memPoolFree(cbdata_pool,c);
+    memPoolFree(cbdata_pool, c);
     debug(45, 3) ("cbdataReallyFree: Freeing %p\n", p);
     if (unlock_func)
 	unlock_func(p, id);
@@ -246,13 +245,13 @@ cbdataDump(StoreEntry * sentry)
 	c = (cbdata *) hptr;
 #if CBDATA_DEBUG
 	storeAppendPrintf(sentry, "%20p %10s %d locks %s:%d\n",
-	    c->key,
+	    c->hash.key,
 	    c->valid ? "VALID" : "NOT VALID",
 	    c->locks,
 	    c->file, c->line);
 #else
 	storeAppendPrintf(sentry, "%20p %10s %d locks\n",
-	    c->key,
+	    c->hash.key,
 	    c->valid ? "VALID" : "NOT VALID",
 	    c->locks);
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_db.cc,v 1.50 2000/06/27 22:05:58 hno Exp $
+ * $Id: client_db.cc,v 1.51 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 0     Client Database
  * AUTHOR: Duane Wessels
@@ -44,9 +44,9 @@ clientdbAdd(struct in_addr addr)
 {
     ClientInfo *c;
     c = memAllocate(MEM_CLIENT_INFO);
-    c->key = xstrdup(inet_ntoa(addr));
+    c->hash.key = xstrdup(inet_ntoa(addr));
     c->addr = addr;
-    hash_join(client_table, (hash_link *) c);
+    hash_join(client_table, &c->hash);
     statCounter.client_http.clients++;
     return c;
 }
@@ -169,7 +169,7 @@ clientdbDump(StoreEntry * sentry)
     storeAppendPrintf(sentry, "Cache Clients:\n");
     hash_first(client_table);
     while ((c = (ClientInfo *) hash_next(client_table))) {
-	storeAppendPrintf(sentry, "Address: %s\n", c->key);
+	storeAppendPrintf(sentry, "Address: %s\n", hashKeyStr(&c->hash));
 	storeAppendPrintf(sentry, "Name: %s\n", fqdnFromAddr(c->addr));
 	storeAppendPrintf(sentry, "Currently established connections: %d\n",
 	    c->n_established);
@@ -214,7 +214,7 @@ static void
 clientdbFreeItem(void *data)
 {
     ClientInfo *c = data;
-    safe_free(c->key);
+    safe_free(c->hash.key);
     memFree(c, MEM_CLIENT_INFO);
 }
 
@@ -236,7 +236,7 @@ client_entry(struct in_addr *current)
 	key = inet_ntoa(*current);
 	hash_first(client_table);
 	while ((c = (ClientInfo *) hash_next(client_table))) {
-	    if (!strcmp(key, c->key))
+	    if (!strcmp(key, hashKeyStr(&c->hash)))
 		break;
 	}
 	c = (ClientInfo *) hash_next(client_table);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.141 2000/10/17 08:06:03 adrian Exp $
+ * $Id: fqdncache.cc,v 1.142 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -41,9 +41,7 @@
 typedef struct _fqdncache_entry fqdncache_entry;
 
 struct _fqdncache_entry {
-    /* first two items must be equivalent to hash_link */
-    char *name;
-    fqdncache_entry *next;
+    hash_link hash;		/* must be first */
     time_t lastref;
     time_t expires;
     unsigned char name_count;
@@ -103,9 +101,9 @@ fqdncacheRelease(fqdncache_entry * f)
     for (k = 0; k < (int) f->name_count; k++)
 	safe_free(f->names[k]);
     debug(35, 5) ("fqdncacheRelease: Released FQDN record for '%s'.\n",
-	f->name);
+	hashKeyStr(&f->hash));
     dlinkDelete(&f->lru, &lru_list);
-    safe_free(f->name);
+    safe_free(f->hash.key);
     safe_free(f->error_message);
     memFree(f, MEM_FQDNCACHE_ENTRY);
 }
@@ -161,21 +159,21 @@ fqdncacheCreateEntry(const char *name)
 {
     static fqdncache_entry *f;
     f = memAllocate(MEM_FQDNCACHE_ENTRY);
-    f->name = xstrdup(name);
+    f->hash.key = xstrdup(name);
     f->expires = squid_curtime + Config.negativeDnsTtl;
     return f;
 }
 
 static void
 fqdncacheAddEntry(fqdncache_entry * f)
 {
-    hash_link *e = hash_lookup(fqdn_table, f->name);
+    hash_link *e = hash_lookup(fqdn_table, f->hash.key);
     if (NULL != e) {
 	/* avoid colission */
 	fqdncache_entry *q = (fqdncache_entry *) e;
 	fqdncacheRelease(q);
     }
-    hash_join(fqdn_table, (hash_link *) f);
+    hash_join(fqdn_table, &f->hash);
     dlinkAdd(f, &f->lru, &lru_list);
     f->lastref = squid_curtime;
 }
@@ -371,7 +369,7 @@ fqdncache_nbgethostbyaddr(struct in_addr addr, FQDNH * handler, void *handlerDat
     c->data = f;
     cbdataAdd(c, memFree, MEM_GEN_CBDATA);
 #if USE_DNSSERVERS
-    dnsSubmit(f->name, fqdncacheHandleReply, c);
+    dnsSubmit(hashKeyStr(&f->hash), fqdncacheHandleReply, c);
 #else
     idnsPTRLookup(addr, fqdncacheHandleReply, c);
 #endif
@@ -461,7 +459,7 @@ fqdnStats(StoreEntry * sentry)
     while ((f = (fqdncache_entry *) hash_next(fqdn_table))) {
 	ttl = (f->expires - squid_curtime);
 	storeAppendPrintf(sentry, " %-32.32s %c %6d %d",
-	    f->name,
+	    hashKeyStr(&f->hash),
 	    f->flags.negcached ? 'N' : ' ',
 	    ttl,
 	    (int) f->name_count);
@@ -513,7 +511,7 @@ fqdncacheFreeEntry(void *data)
     int k;
     for (k = 0; k < (int) f->name_count; k++)
 	safe_free(f->names[k]);
-    safe_free(f->name);
+    safe_free(f->hash.key);
     safe_free(f->error_message);
     memFree(f, MEM_FQDNCACHE_ENTRY);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_aufs.cc,v 1.10 2000/10/17 08:06:07 adrian Exp $
+ * $Id: store_dir_aufs.cc,v 1.11 2000/10/31 23:48:17 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -467,7 +467,7 @@ storeAufsDirRebuildFromDirectory(void *data)
 	    storeAufsDirUnlinkFile(SD, sfileno);
 	    continue;
 	}
-	tmpe.key = key;
+	tmpe.hash.key = key;
 	/* check sizes */
 	if (tmpe.swap_file_sz == 0) {
 	    tmpe.swap_file_sz = sb.st_size;
@@ -1005,7 +1005,7 @@ storeAufsDirWriteCleanEntry(SwapDir * sd, const StoreEntry * e)
     s.swap_file_sz = e->swap_file_sz;
     s.refcount = e->refcount;
     s.flags = e->flags;
-    xmemcpy(&s.key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(&s.key, e->hash.key, MD5_DIGEST_CHARS);
     xmemcpy(state->outbuf + state->outbuf_offset, &s, ss);
     state->outbuf_offset += ss;
     /* buffered write */
@@ -1097,7 +1097,7 @@ storeAufsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
     s->swap_file_sz = e->swap_file_sz;
     s->refcount = e->refcount;
     s->flags = e->flags;
-    xmemcpy(s->key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(s->key, e->hash.key, MD5_DIGEST_CHARS);
     file_write(aioinfo->swaplog_fd,
 	-1,
 	s,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_coss.cc,v 1.5 2000/10/18 04:00:23 hno Exp $
+ * $Id: store_dir_coss.cc,v 1.6 2000/10/31 23:48:17 wessels Exp $
  *
  * DEBUG: section 81    Store COSS Directory Routines
  * AUTHOR: Eric Stern
@@ -523,7 +523,7 @@ storeCossDirWriteCleanEntry(SwapDir *sd, const StoreEntry * e)
     s.swap_file_sz = e->swap_file_sz;
     s.refcount = e->refcount;
     s.flags = e->flags;
-    xmemcpy(&s.key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(&s.key, e->hash.key, MD5_DIGEST_CHARS);
     xmemcpy(state->outbuf + state->outbuf_offset, &s, ss);
     state->outbuf_offset += ss;
     /* buffered write */
@@ -614,7 +614,7 @@ storeCossDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
     s->swap_file_sz = e->swap_file_sz;
     s->refcount = e->refcount;
     s->flags = e->flags;
-    xmemcpy(s->key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(s->key, e->hash.key, MD5_DIGEST_CHARS);
     file_write(cs->swaplog_fd,
 	-1,
 	s,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_diskd.cc,v 1.21 2000/10/17 08:06:08 adrian Exp $
+ * $Id: store_dir_diskd.cc,v 1.22 2000/10/31 23:48:18 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -633,7 +633,7 @@ storeDiskdDirRebuildFromDirectory(void *data)
 	    storeDiskdDirUnlinkFile(SD, sfileno);
 	    continue;
 	}
-	tmpe.key = key;
+	tmpe.hash.key = key;
 	/* check sizes */
 	if (tmpe.swap_file_sz == 0) {
 	    tmpe.swap_file_sz = sb.st_size;
@@ -1196,7 +1196,7 @@ storeDiskdDirWriteCleanEntry(SwapDir * sd, const StoreEntry * e)
     s.swap_file_sz = e->swap_file_sz;
     s.refcount = e->refcount;
     s.flags = e->flags;
-    xmemcpy(&s.key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(&s.key, e->hash.key, MD5_DIGEST_CHARS);
     xmemcpy(state->outbuf + state->outbuf_offset, &s, ss);
     state->outbuf_offset += ss;
     /* buffered write */
@@ -1288,7 +1288,7 @@ storeDiskdDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
     s->swap_file_sz = e->swap_file_sz;
     s->refcount = e->refcount;
     s->flags = e->flags;
-    xmemcpy(s->key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(s->key, e->hash.key, MD5_DIGEST_CHARS);
     file_write(diskdinfo->swaplog_fd,
 	-1,
 	s,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_ufs.cc,v 1.10 2000/10/17 08:06:09 adrian Exp $
+ * $Id: store_dir_ufs.cc,v 1.11 2000/10/31 23:48:18 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -465,7 +465,7 @@ storeUfsDirRebuildFromDirectory(void *data)
 	    storeUfsDirUnlinkFile(SD, sfileno);
 	    continue;
 	}
-	tmpe.key = key;
+	tmpe.hash.key = key;
 	/* check sizes */
 	if (tmpe.swap_file_sz == 0) {
 	    tmpe.swap_file_sz = sb.st_size;
@@ -959,7 +959,7 @@ storeUfsDirWriteCleanStart(SwapDir * sd)
     unlink(state->cln);
     state->fd = file_open(state->new, O_WRONLY | O_CREAT | O_TRUNC);
     if (state->fd < 0)
-	return -1;	/* state not free'd - possible leak */
+	return -1;		/* state not free'd - possible leak */
     debug(20, 3) ("storeDirWriteCleanLogs: opened %s, FD %d\n",
 	state->new, state->fd);
 #if HAVE_FCHMOD
@@ -1003,7 +1003,7 @@ storeUfsDirWriteCleanEntry(SwapDir * sd, const StoreEntry * e)
     s.swap_file_sz = e->swap_file_sz;
     s.refcount = e->refcount;
     s.flags = e->flags;
-    xmemcpy(&s.key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(&s.key, e->hash.key, MD5_DIGEST_CHARS);
     xmemcpy(state->outbuf + state->outbuf_offset, &s, ss);
     state->outbuf_offset += ss;
     /* buffered write */
@@ -1095,7 +1095,7 @@ storeUfsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
     s->swap_file_sz = e->swap_file_sz;
     s->refcount = e->refcount;
     s->flags = e->flags;
-    xmemcpy(s->key, e->key, MD5_DIGEST_CHARS);
+    xmemcpy(s->key, e->hash.key, MD5_DIGEST_CHARS);
     file_write(ufsinfo->swaplog_fd,
 	-1,
 	s,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.367 2000/10/04 15:32:13 wessels Exp $
+ * $Id: http.cc,v 1.368 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -325,7 +325,7 @@ httpProcessReplyHeader(HttpStateData * httpState, const char *buf, int size)
     HttpReply *reply = entry->mem_obj->reply;
     Ctx ctx;
     debug(11, 3) ("httpProcessReplyHeader: key '%s'\n",
-	storeKeyText(entry->key));
+	storeKeyText(entry->hash.key));
     if (httpState->reply_hdr == NULL)
 	httpState->reply_hdr = memAllocate(MEM_8K_BUF);
     assert(httpState->reply_hdr_state == 0);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ident.cc,v 1.53 2000/06/27 22:06:02 hno Exp $
+ * $Id: ident.cc,v 1.54 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -47,8 +47,7 @@ typedef struct _IdentClient {
 } IdentClient;
 
 typedef struct _IdentStateData {
-    char *key;
-    struct _IdentStateData *next;
+    hash_link hash;		/* must be first */
     int fd;			/* IDENT fd */
     struct sockaddr_in me;
     struct sockaddr_in my_peer;
@@ -216,12 +215,12 @@ identStart(struct sockaddr_in *me, struct sockaddr_in *my_peer, IDCB * callback,
     }
     state = xcalloc(1, sizeof(IdentStateData));
     cbdataAdd(state, cbdataXfree, 0);
-    state->key = xstrdup(key);
+    state->hash.key = xstrdup(key);
     state->fd = fd;
     state->me = *me;
     state->my_peer = *my_peer;
     identClientAdd(state, callback, data);
-    hash_join(ident_hash, (hash_link *) state);
+    hash_join(ident_hash, &state->hash);
     comm_add_close_handler(fd,
 	identClose,
 	state);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.226 2000/10/17 08:06:03 adrian Exp $
+ * $Id: ipcache.cc,v 1.227 2000/10/31 23:48:13 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -38,9 +38,7 @@
 typedef struct _ipcache_entry ipcache_entry;
 
 struct _ipcache_entry {
-    /* first two items must be equivalent to hash_link */
-    char *name;
-    ipcache_entry *next;
+    hash_link hash;		/* must be first */
     time_t lastref;
     time_t expires;
     ipcache_addrs addrs;
@@ -171,21 +169,21 @@ ipcacheCreateEntry(const char *name)
 {
     static ipcache_entry *i;
     i = memAllocate(MEM_IPCACHE_ENTRY);
-    i->name = xstrdup(name);
+    i->hash.key = xstrdup(name);
     i->expires = squid_curtime + Config.negativeDnsTtl;
     return i;
 }
 
 static void
 ipcacheAddEntry(ipcache_entry * i)
 {
-    hash_link *e = hash_lookup(ip_table, i->name);
+    hash_link *e = hash_lookup(ip_table, i->hash.key);
     if (NULL != e) {
 	/* avoid colission */
 	ipcache_entry *q = (ipcache_entry *) e;
 	ipcacheRelease(q);
     }
-    hash_join(ip_table, (hash_link *) i);
+    hash_join(ip_table, &i->hash);
     dlinkAdd(i, &i->lru, &lru_list);
     i->lastref = squid_curtime;
 }
@@ -417,9 +415,9 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     c->data = i;
     cbdataAdd(c, memFree, MEM_GEN_CBDATA);
 #if USE_DNSSERVERS
-    dnsSubmit(i->name, ipcacheHandleReply, c);
+    dnsSubmit(hashKeyStr(&i->hash), ipcacheHandleReply, c);
 #else
-    idnsALookup(i->name, ipcacheHandleReply, c);
+    idnsALookup(hashKeyStr(&i->hash), ipcacheHandleReply, c);
 #endif
 }
 
@@ -490,7 +488,7 @@ ipcacheStatPrint(ipcache_entry * i, StoreEntry * sentry)
 {
     int k;
     storeAppendPrintf(sentry, " %-32.32s  %c %6d %6d %2d(%2d)",
-	i->name,
+	hashKeyStr(&i->hash),
 	i->flags.negcached ? 'N' : ' ',
 	(int) (squid_curtime - i->lastref),
 	(int) (i->expires - squid_curtime),
@@ -675,7 +673,7 @@ ipcacheFreeEntry(void *data)
     ipcache_entry *i = data;
     safe_free(i->addrs.in_addrs);
     safe_free(i->addrs.bad_mask);
-    safe_free(i->name);
+    safe_free(i->hash.key);
     safe_free(i->error_message);
     memFree(i, MEM_IPCACHE_ENTRY);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: leakfinder.cc,v 1.3 2000/03/06 16:23:32 wessels Exp $
+ * $Id: leakfinder.cc,v 1.4 2000/10/31 23:48:14 wessels Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * AUTHOR: Duane Wessels
@@ -44,6 +44,7 @@ static hash_table *htable = NULL;
 static int leakCount = 0;
 
 typedef struct _ptr {
+    hash_link hash;		/* must be first */
     void *key;
     struct _ptr *next;
     const char *file;
@@ -79,7 +80,7 @@ leakAddFL(void *p, const char *file, int line)
     c->file = file;
     c->line = line;
     c->when = squid_curtime;
-    hash_join(htable, (hash_link *) c);
+    hash_join(htable, &c->hash);
     leakCount++;
     return p;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.286 2000/10/10 02:10:42 wessels Exp $
+ * $Id: neighbors.cc,v 1.287 2000/10/31 23:48:14 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -398,7 +398,7 @@ neighborsUdpPing(request_t * request,
     mem->start_ping = current_time;
     mem->ping_reply_callback = callback;
     mem->ircb_data = callback_data;
-    reqnum = icpSetCacheKey(entry->key);
+    reqnum = icpSetCacheKey(entry->hash.key);
     for (i = 0, p = first_ping; i++ < Config.npeers; p = p->next) {
 	if (p == NULL)
 	    p = Config.peers;
@@ -410,7 +410,7 @@ neighborsUdpPing(request_t * request,
 	    p->host, url);
 	if (p->type == PEER_MULTICAST)
 	    mcastSetTtl(theOutIcpConnection, p->mcast.ttl);
-	debug(15, 3) ("neighborsUdpPing: key = '%s'\n", storeKeyText(entry->key));
+	debug(15, 3) ("neighborsUdpPing: key = '%s'\n", storeKeyText(entry->hash.key));
 	debug(15, 3) ("neighborsUdpPing: reqnum = %d\n", reqnum);
 
 #if USE_HTCP
@@ -900,7 +900,7 @@ neighborUp(const peer * p)
 	return 0;
     /*
      * The peer can not be UP if we don't have any IP addresses
-     * for it.
+     * for it. 
      */
     if (0 == p->n_addresses)
 	return 0;
@@ -1113,7 +1113,7 @@ peerCountMcastPeersStart(void *data)
     mem->ircb_data = psstate;
     mcastSetTtl(theOutIcpConnection, p->mcast.ttl);
     p->mcast.id = mem->id;
-    reqnum = icpSetCacheKey(fake->key);
+    reqnum = icpSetCacheKey(fake->hash.key);
     query = icpCreateMessage(ICP_QUERY, 0, url, reqnum, 0);
     icpUdpSend(theOutIcpConnection,
 	&p->in_addr,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.150 2000/10/26 07:09:23 wessels Exp $
+ * $Id: net_db.cc,v 1.151 2000/10/31 23:48:14 wessels Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -81,9 +81,9 @@ static void
 netdbHashInsert(netdbEntry * n, struct in_addr addr)
 {
     xstrncpy(n->network, inet_ntoa(networkFromInaddr(addr)), 16);
-    n->key = n->network;
+    n->hash.key = n->network;
     assert(hash_lookup(addr_table, n->network) == NULL);
-    hash_join(addr_table, (hash_link *) n);
+    hash_join(addr_table, &n->hash);
 }
 
 static void
@@ -101,12 +101,12 @@ static void
 netdbHostInsert(netdbEntry * n, const char *hostname)
 {
     net_db_name *x = memAllocate(MEM_NET_DB_NAME);
-    x->name = xstrdup(hostname);
+    x->hash.key = xstrdup(hostname);
     x->next = n->hosts;
     n->hosts = x;
     x->net_db_entry = n;
     assert(hash_lookup(host_table, hostname) == NULL);
-    hash_join(host_table, (hash_link *) x);
+    hash_join(host_table, &x->hash);
     n->link_count++;
 }
 
@@ -126,7 +126,7 @@ netdbHostDelete(const net_db_name * x)
 	}
     }
     hash_remove_link(host_table, (hash_link *) x);
-    xfree(x->name);
+    xfree(x->hash.key);
     memFree((void *) x, MEM_NET_DB_NAME);
 }
 
@@ -402,7 +402,7 @@ netdbSaveState(void *foo)
 	    (int) n->next_ping_time,
 	    (int) n->last_use_time);
 	for (x = n->hosts; x; x = x->next)
-	    logfilePrintf(lf, " %s", x->name);
+	    logfilePrintf(lf, " %s", hashKeyStr(&x->hash));
 	logfilePrintf(lf, "\n");
 	count++;
 #undef RBUF_SZ
@@ -520,7 +520,7 @@ static void
 netdbFreeNameEntry(void *data)
 {
     net_db_name *x = data;
-    xfree(x->name);
+    xfree(x->hash.key);
     memFree(x, MEM_NET_DB_NAME);
 }
 
@@ -779,7 +779,7 @@ netdbDump(StoreEntry * sentry)
 	    n->rtt,
 	    n->hops);
 	for (x = n->hosts; x; x = x->next)
-	    storeAppendPrintf(sentry, " %s", x->name);
+	    storeAppendPrintf(sentry, " %s", hashKeyStr(&x->hash));
 	storeAppendPrintf(sentry, "\n");
 	p = n->peers;
 	for (j = 0; j < n->n_peers; j++, p++) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: pconn.cc,v 1.28 2000/10/17 08:06:04 adrian Exp $
+ * $Id: pconn.cc,v 1.29 2000/10/31 23:48:14 wessels Exp $
  *
  * DEBUG: section 48    Persistent Connections
  * AUTHOR: Duane Wessels
@@ -36,14 +36,13 @@
 #include "squid.h"
 
 struct _pconn {
-    char *key;
-    struct _pconn *next;
+    hash_link hash;		/* must be first */
     int *fds;
     int nfds_alloc;
     int nfds;
 };
 
-#define PCONN_FDS_SZ	8		/* pconn set size, increase for better memcache hit rate */
+#define PCONN_FDS_SZ	8	/* pconn set size, increase for better memcache hit rate */
 #define PCONN_HIST_SZ (1<<16)
 int client_pconn_hist[PCONN_HIST_SZ];
 int server_pconn_hist[PCONN_HIST_SZ];
@@ -71,24 +70,24 @@ static struct _pconn *
 pconnNew(const char *key)
 {
     struct _pconn *p = memPoolAlloc(pconn_data_pool);
-    p->key = xstrdup(key);
+    p->hash.key = xstrdup(key);
     p->nfds_alloc = PCONN_FDS_SZ;
     p->fds = memPoolAlloc(pconn_fds_pool);
-    debug(48, 3) ("pconnNew: adding %s\n", p->key);
-    hash_join(table, (hash_link *) p);
+    debug(48, 3) ("pconnNew: adding %s\n", hashKeyStr(&p->hash));
+    hash_join(table, &p->hash);
     return p;
 }
 
 static void
 pconnDelete(struct _pconn *p)
 {
-    debug(48, 3) ("pconnDelete: deleting %s\n", p->key);
+    debug(48, 3) ("pconnDelete: deleting %s\n", hashKeyStr(&p->hash));
     hash_remove_link(table, (hash_link *) p);
     if (p->nfds_alloc == PCONN_FDS_SZ)
-	memPoolFree(pconn_fds_pool,p->fds);
+	memPoolFree(pconn_fds_pool, p->fds);
     else
 	xfree(p->fds);
-    xfree(p->key);
+    xfree(p->hash.key);
     memPoolFree(pconn_data_pool, p);
 }
 
@@ -113,7 +112,7 @@ pconnTimeout(int fd, void *data)
 {
     struct _pconn *p = data;
     assert(table != NULL);
-    debug(48, 3) ("pconnTimeout: FD %d %s\n", fd, p->key);
+    debug(48, 3) ("pconnTimeout: FD %d %s\n", fd, hashKeyStr(&p->hash));
     pconnRemoveFD(p, fd);
     comm_close(fd);
 }
@@ -127,7 +126,8 @@ pconnRead(int fd, void *data)
     assert(table != NULL);
     statCounter.syscalls.sock.reads++;
     n = read(fd, buf, 256);
-    debug(48, 3) ("pconnRead: %d bytes from FD %d, %s\n", n, fd, p->key);
+    debug(48, 3) ("pconnRead: %d bytes from FD %d, %s\n", n, fd,
+	hashKeyStr(&p->hash));
     pconnRemoveFD(p, fd);
     comm_close(fd);
 }
@@ -210,7 +210,7 @@ pconnPush(int fd, const char *host, u_short port)
 	p->fds = xmalloc(p->nfds_alloc * sizeof(int));
 	xmemcpy(p->fds, old, p->nfds * sizeof(int));
 	if (p->nfds == PCONN_FDS_SZ)
-	    memPoolFree(pconn_fds_pool,old);
+	    memPoolFree(pconn_fds_pool, old);
 	else
 	    xfree(old);
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.383 2000/10/17 08:06:04 adrian Exp $
+ * $Id: protos.h,v 1.384 2000/10/31 23:48:14 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -883,7 +883,7 @@ extern void storeLogOpen(void);
 /*
  * store_key_*.c
  */
-extern const cache_key *storeKeyDup(const cache_key *);
+extern cache_key *storeKeyDup(const cache_key *);
 extern cache_key *storeKeyCopy(cache_key *, const cache_key *);
 extern void storeKeyFree(const cache_key *);
 extern const cache_key *storeKeyScan(const char *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.339 2000/10/17 08:06:04 adrian Exp $
+ * $Id: stat.cc,v 1.340 2000/10/31 23:48:14 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -259,7 +259,7 @@ statStoreEntry(StoreEntry * s, StoreEntry * e)
     int i;
     struct _store_client *sc;
     dlink_node *node;
-    storeAppendPrintf(s, "KEY %s\n", storeKeyText(e->key));
+    storeAppendPrintf(s, "KEY %s\n", storeKeyText(e->hash.key));
     if (mem)
 	storeAppendPrintf(s, "\t%s %s\n",
 	    RequestMethodStr[mem->method], mem->log_url);
@@ -394,7 +394,7 @@ info_get_mallstat(int size, int number, int oldnum, void *data)
 {
     StoreEntry *sentry = data;
     if (number > 0)
-	storeAppendPrintf(sentry, "%d\t %d\t %d\t %.1f\n", size, number, number - oldnum , xdiv((number - oldnum),xm_deltat));
+	storeAppendPrintf(sentry, "%d\t %d\t %d\t %.1f\n", size, number, number - oldnum, xdiv((number - oldnum), xm_deltat));
 }
 #endif
 
@@ -1424,9 +1424,9 @@ statClientRequests(StoreEntry * s)
 	    http->out.offset, http->out.size);
 	storeAppendPrintf(s, "req_sz %d\n", http->req_sz);
 	e = http->entry;
-	storeAppendPrintf(s, "entry %p/%s\n", e, e ? storeKeyText(e->key) : "N/A");
+	storeAppendPrintf(s, "entry %p/%s\n", e, e ? storeKeyText(e->hash.key) : "N/A");
 	e = http->old_entry;
-	storeAppendPrintf(s, "old_entry %p/%s\n", e, e ? storeKeyText(e->key) : "N/A");
+	storeAppendPrintf(s, "old_entry %p/%s\n", e, e ? storeKeyText(e->hash.key) : "N/A");
 	storeAppendPrintf(s, "start %d.%06d (%f seconds ago)\n", http->start.tv_sec,
 	    http->start.tv_usec,
 	    tvSubDsec(http->start, current_time));
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.530 2000/07/20 16:10:41 wessels Exp $
+ * $Id: store.cc,v 1.531 2000/10/31 23:48:14 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -178,7 +178,7 @@ destroy_StoreEntry(void *data)
     if (e->mem_obj)
 	destroy_MemObject(e);
     storeHashDelete(e);
-    assert(e->key == NULL);
+    assert(e->hash.key == NULL);
     memFree(e, MEM_STOREENTRY);
 }
 
@@ -189,16 +189,16 @@ storeHashInsert(StoreEntry * e, const cache_key * key)
 {
     debug(20, 3) ("storeHashInsert: Inserting Entry %p key '%s'\n",
 	e, storeKeyText(key));
-    e->key = storeKeyDup(key);
-    hash_join(store_table, (hash_link *) e);
+    e->hash.key = storeKeyDup(key);
+    hash_join(store_table, &e->hash);
 }
 
 static void
 storeHashDelete(StoreEntry * e)
 {
-    hash_remove_link(store_table, (hash_link *) e);
-    storeKeyFree(e->key);
-    e->key = NULL;
+    hash_remove_link(store_table, &e->hash);
+    storeKeyFree(e->hash.key);
+    e->hash.key = NULL;
 }
 
 /* -------------------------------------------------------------------------- */
@@ -212,7 +212,7 @@ storePurgeMem(StoreEntry * e)
     if (e->mem_obj == NULL)
 	return;
     debug(20, 3) ("storePurgeMem: Freeing memory-copy of %s\n",
-	storeKeyText(e->key));
+	storeKeyText(e->hash.key));
     storeSetMemStatus(e, NOT_IN_MEMORY);
     destroy_MemObject(e);
     if (e->swap_status != SWAPOUT_DONE)
@@ -260,7 +260,7 @@ storeLockObject(StoreEntry * e)
 {
     e->lock_count++;
     debug(20, 3) ("storeLockObject: key '%s' count=%d\n",
-	storeKeyText(e->key), (int) e->lock_count);
+	storeKeyText(e->hash.key), (int) e->lock_count);
     e->lastref = squid_curtime;
     storeEntryReferenced(e);
 }
@@ -270,7 +270,7 @@ storeReleaseRequest(StoreEntry * e)
 {
     if (EBIT_TEST(e->flags, RELEASE_REQUEST))
 	return;
-    debug(20, 3) ("storeReleaseRequest: '%s'\n", storeKeyText(e->key));
+    debug(20, 3) ("storeReleaseRequest: '%s'\n", storeKeyText(e->hash.key));
     EBIT_SET(e->flags, RELEASE_REQUEST);
     /*
      * Clear cachable flag here because we might get called before
@@ -288,7 +288,7 @@ storeUnlockObject(StoreEntry * e)
 {
     e->lock_count--;
     debug(20, 3) ("storeUnlockObject: key '%s' count=%d\n",
-	storeKeyText(e->key), e->lock_count);
+	storeKeyText(e->hash.key), e->lock_count);
     if (e->lock_count)
 	return (int) e->lock_count;
     if (e->store_status == STORE_PENDING)
@@ -339,9 +339,9 @@ storeSetPrivateKey(StoreEntry * e)
 {
     const cache_key *newkey;
     MemObject *mem = e->mem_obj;
-    if (e->key && EBIT_TEST(e->flags, KEY_PRIVATE))
+    if (e->hash.key && EBIT_TEST(e->flags, KEY_PRIVATE))
 	return;			/* is already private */
-    if (e->key) {
+    if (e->hash.key) {
 	if (e->swap_filen > -1)
 	    storeDirSwapLog(e, SWAP_LOG_DEL);
 	storeHashDelete(e);
@@ -363,7 +363,7 @@ storeSetPublicKey(StoreEntry * e)
     StoreEntry *e2 = NULL;
     const cache_key *newkey;
     MemObject *mem = e->mem_obj;
-    if (e->key && !EBIT_TEST(e->flags, KEY_PRIVATE))
+    if (e->hash.key && !EBIT_TEST(e->flags, KEY_PRIVATE))
 	return;			/* is already public */
     assert(mem);
     /*
@@ -379,7 +379,7 @@ storeSetPublicKey(StoreEntry * e)
 #if MORE_DEBUG_OUTPUT
     if (EBIT_TEST(e->flags, RELEASE_REQUEST))
 	debug(20, 1) ("assertion failed: RELEASE key %s, url %s\n",
-	    e->key, mem->url);
+	    e->hash.key, mem->url);
 #endif
     assert(!EBIT_TEST(e->flags, RELEASE_REQUEST));
     newkey = storeKeyPublic(mem->url, mem->method);
@@ -389,7 +389,7 @@ storeSetPublicKey(StoreEntry * e)
 	storeRelease(e2);
 	newkey = storeKeyPublic(mem->url, mem->method);
     }
-    if (e->key)
+    if (e->hash.key)
 	storeHashDelete(e);
     EBIT_CLR(e->flags, KEY_PRIVATE);
     storeHashInsert(e, newkey);
@@ -436,7 +436,7 @@ storeCreateEntry(const char *url, const char *log_url, request_flags flags, meth
 void
 storeExpireNow(StoreEntry * e)
 {
-    debug(20, 3) ("storeExpireNow: '%s'\n", storeKeyText(e->key));
+    debug(20, 3) ("storeExpireNow: '%s'\n", storeKeyText(e->hash.key));
     e->expires = squid_curtime;
 }
 
@@ -451,7 +451,7 @@ storeAppend(StoreEntry * e, const char *buf, int len)
     if (len) {
 	debug(20, 5) ("storeAppend: appending %d bytes for '%s'\n",
 	    len,
-	    storeKeyText(e->key));
+	    storeKeyText(e->hash.key));
 	storeGetMemSpace(len);
 	stmemAppend(&mem->data_hdr, buf, len);
 	mem->inmem_hi += len;
@@ -629,7 +629,7 @@ storeCheckCachableStats(StoreEntry * sentry)
 void
 storeComplete(StoreEntry * e)
 {
-    debug(20, 3) ("storeComplete: '%s'\n", storeKeyText(e->key));
+    debug(20, 3) ("storeComplete: '%s'\n", storeKeyText(e->hash.key));
     if (e->store_status != STORE_PENDING) {
 	/*
 	 * if we're not STORE_PENDING, then probably we got aborted
@@ -671,7 +671,7 @@ storeAbort(StoreEntry * e)
     MemObject *mem = e->mem_obj;
     assert(e->store_status == STORE_PENDING);
     assert(mem != NULL);
-    debug(20, 6) ("storeAbort: %s\n", storeKeyText(e->key));
+    debug(20, 6) ("storeAbort: %s\n", storeKeyText(e->hash.key));
     storeLockObject(e);		/* lock while aborting */
     storeNegativeCache(e);
     storeReleaseRequest(e);
@@ -774,7 +774,7 @@ storeMaintainSwapSpace(void *datanotused)
 void
 storeRelease(StoreEntry * e)
 {
-    debug(20, 3) ("storeRelease: Releasing: '%s'\n", storeKeyText(e->key));
+    debug(20, 3) ("storeRelease: Releasing: '%s'\n", storeKeyText(e->hash.key));
     /* If, for any reason we can't discard this object because of an
      * outstanding request, mark it for pending release */
     if (storeEntryLocked(e)) {
@@ -868,7 +868,7 @@ storeEntryValidLength(const StoreEntry * e)
     const HttpReply *reply;
     assert(e->mem_obj != NULL);
     reply = e->mem_obj->reply;
-    debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", storeKeyText(e->key));
+    debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", storeKeyText(e->hash.key));
     debug(20, 5) ("storeEntryValidLength:     object_len = %d\n",
 	objectLen(e));
     debug(20, 5) ("storeEntryValidLength:         hdr_sz = %d\n",
@@ -877,17 +877,17 @@ storeEntryValidLength(const StoreEntry * e)
 	reply->content_length);
     if (reply->content_length < 0) {
 	debug(20, 5) ("storeEntryValidLength: Unspecified content length: %s\n",
-	    storeKeyText(e->key));
+	    storeKeyText(e->hash.key));
 	return 1;
     }
     if (reply->hdr_sz == 0) {
 	debug(20, 5) ("storeEntryValidLength: Zero header size: %s\n",
-	    storeKeyText(e->key));
+	    storeKeyText(e->hash.key));
 	return 1;
     }
     if (e->mem_obj->method == METHOD_HEAD) {
 	debug(20, 5) ("storeEntryValidLength: HEAD request: %s\n",
-	    storeKeyText(e->key));
+	    storeKeyText(e->hash.key));
 	return 1;
     }
     if (reply->sline.status == HTTP_NOT_MODIFIED)
@@ -900,7 +900,7 @@ storeEntryValidLength(const StoreEntry * e)
     debug(20, 3) ("storeEntryValidLength: %d bytes too %s; '%s'\n",
 	diff < 0 ? -diff : diff,
 	diff < 0 ? "big" : "small",
-	storeKeyText(e->key));
+	storeKeyText(e->hash.key));
     return 0;
 }
 
@@ -1087,8 +1087,8 @@ storeMemObjectDump(MemObject * mem)
 void
 storeEntryDump(const StoreEntry * e, int l)
 {
-    debug(20, l) ("StoreEntry->key: %s\n", storeKeyText(e->key));
-    debug(20, l) ("StoreEntry->next: %p\n", e->next);
+    debug(20, l) ("StoreEntry->key: %s\n", storeKeyText(e->hash.key));
+    debug(20, l) ("StoreEntry->next: %p\n", e->hash.next);
     debug(20, l) ("StoreEntry->mem_obj: %p\n", e->mem_obj);
     debug(20, l) ("StoreEntry->timestamp: %d\n", (int) e->timestamp);
     debug(20, l) ("StoreEntry->lastref: %d\n", (int) e->lastref);
@@ -1292,7 +1292,7 @@ createRemovalPolicy(RemovalPolicySettings * settings)
 	if (strcmp(r->typestr, settings->type) == 0)
 	    return r->create(settings->args);
     }
-    debug(20,1)("Unknown policy %s\n", settings->type);
+    debug(20, 1) ("Unknown policy %s\n", settings->type);
     return NULL;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_client.cc,v 1.97 2000/10/10 02:10:43 wessels Exp $
+ * $Id: store_client.cc,v 1.98 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Client-Side Interface
  * AUTHOR: Duane Wessels
@@ -189,7 +189,7 @@ storeClientCopy(store_client * sc,
 {
     assert(!EBIT_TEST(e->flags, ENTRY_ABORTED));
     debug(20, 3) ("storeClientCopy: %s, seen %d, want %d, size %d, cb %p, cbdata %p\n",
-	storeKeyText(e->key),
+	storeKeyText(e->hash.key),
 	(int) seen_offset,
 	(int) copy_offset,
 	(int) size,
@@ -249,7 +249,7 @@ storeClientCopy2(StoreEntry * e, store_client * sc)
     }
     cbdataLock(sc);		/* ick, prevent sc from getting freed */
     sc->flags.store_copying = 1;
-    debug(20, 3) ("storeClientCopy2: %s\n", storeKeyText(e->key));
+    debug(20, 3) ("storeClientCopy2: %s\n", storeKeyText(e->hash.key));
     assert(sc->callback != NULL);
     /*
      * We used to check for ENTRY_ABORTED here.  But there were some
@@ -410,10 +410,10 @@ storeClientReadHeader(void *data, const char *buf, ssize_t len)
 	case STORE_META_KEY:
 	    assert(t->length == MD5_DIGEST_CHARS);
 	    if (!EBIT_TEST(e->flags, KEY_PRIVATE) &&
-		memcmp(t->value, e->key, MD5_DIGEST_CHARS)) {
+		memcmp(t->value, e->hash.key, MD5_DIGEST_CHARS)) {
 		debug(20, 2) ("storeClientReadHeader: swapin MD5 mismatch\n");
 		debug(20, 2) ("\t%s\n", storeKeyText(t->value));
-		debug(20, 2) ("\t%s\n", storeKeyText(e->key));
+		debug(20, 2) ("\t%s\n", storeKeyText(e->hash.key));
 		if (isPowTen(++md5_mismatches))
 		    debug(20, 1) ("WARNING: %d swapin MD5 mismatches\n",
 			md5_mismatches);
@@ -499,7 +499,7 @@ storeUnregister(store_client * sc, StoreEntry * e, void *data)
 #endif
     if (mem == NULL)
 	return 0;
-    debug(20, 3) ("storeUnregister: called for '%s'\n", storeKeyText(e->key));
+    debug(20, 3) ("storeUnregister: called for '%s'\n", storeKeyText(e->hash.key));
     if (sc == NULL)
 	return 0;
     if (mem->clients.head == NULL)
@@ -574,7 +574,7 @@ InvokeHandlers(StoreEntry * e)
     dlink_node *nx = NULL;
     dlink_node *node;
 
-    debug(20, 3) ("InvokeHandlers: %s\n", storeKeyText(e->key));
+    debug(20, 3) ("InvokeHandlers: %s\n", storeKeyText(e->hash.key));
     /* walk the entire list looking for valid callbacks */
     for (node = mem->clients.head; node; node = nx) {
 	sc = node->data;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir.cc,v 1.114 2000/07/18 06:16:42 wessels Exp $
+ * $Id: store_dir.cc,v 1.115 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -238,7 +238,7 @@ storeDirSwapLog(const StoreEntry * e, int op)
     assert(op > SWAP_LOG_NOP && op < SWAP_LOG_MAX);
     debug(20, 3) ("storeDirSwapLog: %s %s %d %08X\n",
 	swap_log_op_str[op],
-	storeKeyText(e->key),
+	storeKeyText(e->hash.key),
 	e->swap_dirn,
 	e->swap_filen);
     sd = &Config.cacheSwap.swapDirs[e->swap_dirn];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_key_md5.cc,v 1.23 2000/03/06 16:23:35 wessels Exp $
+ * $Id: store_key_md5.cc,v 1.24 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager MD5 Cache Keys
  * AUTHOR: Duane Wessels
@@ -120,7 +120,7 @@ storeKeyPublic(const char *url, const method_t method)
     return digest;
 }
 
-const cache_key *
+cache_key *
 storeKeyDup(const cache_key * key)
 {
     cache_key *dup = memAllocate(MEM_MD5_DIGEST);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_log.cc,v 1.19 2000/10/10 18:15:30 wessels Exp $
+ * $Id: store_log.cc,v 1.20 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Logging Functions
  * AUTHOR: Duane Wessels
@@ -73,7 +73,7 @@ storeLog(int tag, const StoreEntry * e)
 	    storeLogTags[tag],
 	    e->swap_dirn,
 	    e->swap_filen,
-	    storeKeyText(e->key),
+	    storeKeyText(e->hash.key),
 	    reply->sline.status,
 	    (int) reply->date,
 	    (int) reply->last_modified,
@@ -91,7 +91,7 @@ storeLog(int tag, const StoreEntry * e)
 	    storeLogTags[tag],
 	    e->swap_dirn,
 	    e->swap_filen,
-	    storeKeyText(e->key));
+	    storeKeyText(e->hash.key));
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapin.cc,v 1.26 2000/06/27 22:06:05 hno Exp $
+ * $Id: store_swapin.cc,v 1.27 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapin Functions
  * AUTHOR: Duane Wessels
@@ -48,7 +48,7 @@ storeSwapInStart(store_client * sc)
 	return;
     }
     debug(20, 3) ("storeSwapInStart: called for %d %08X %s \n",
-	e->swap_dirn, e->swap_filen, storeKeyText(e->key));
+	e->swap_dirn, e->swap_filen, storeKeyText(e->hash.key));
     if (e->swap_status != SWAPOUT_WRITING && e->swap_status != SWAPOUT_DONE) {
 	debug(20, 1) ("storeSwapInStart: bad swap_status (%s)\n",
 	    swapStatusStr[e->swap_status]);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapmeta.cc,v 1.12 2000/10/17 08:06:04 adrian Exp $
+ * $Id: store_swapmeta.cc,v 1.13 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapfile Metadata
  * AUTHOR: Kostas Anagnostakis
@@ -71,7 +71,7 @@ storeSwapMetaBuild(StoreEntry * e)
     assert(e->swap_status == SWAPOUT_WRITING);
     url = storeUrl(e);
     debug(20, 3) ("storeSwapMetaBuild: %s\n", url);
-    T = storeSwapTLVAdd(STORE_META_KEY, e->key, MD5_DIGEST_CHARS, T);
+    T = storeSwapTLVAdd(STORE_META_KEY, e->hash.key, MD5_DIGEST_CHARS, T);
     T = storeSwapTLVAdd(STORE_META_STD, &e->timestamp, STORE_HDR_METASIZE, T);
     T = storeSwapTLVAdd(STORE_META_URL, url, strlen(url) + 1, T);
     return TLV;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapout.cc,v 1.76 2000/10/17 08:06:04 adrian Exp $
+ * $Id: store_swapout.cc,v 1.77 2000/10/31 23:48:15 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapout Functions
  * AUTHOR: Duane Wessels
@@ -264,7 +264,7 @@ storeSwapOutFileClose(StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
     assert(mem != NULL);
-    debug(20, 3) ("storeSwapOutFileClose: %s\n", storeKeyText(e->key));
+    debug(20, 3) ("storeSwapOutFileClose: %s\n", storeKeyText(e->hash.key));
     debug(20, 3) ("storeSwapOutFileClose: sio = %p\n", mem->swapout.sio);
     if (mem->swapout.sio == NULL)
 	return;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.356 2000/10/17 08:06:05 adrian Exp $
+ * $Id: structs.h,v 1.357 2000/10/31 23:48:15 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -62,9 +62,7 @@ struct _acl_name_list {
 };
 
 struct _acl_proxy_auth_user {
-    /* first two items must be same as hash_link */
-    char *user;
-    acl_proxy_auth_user *next;
+    hash_link hash;		/* must be first */
     /* extra fields for proxy_auth */
     char *passwd;
     int passwd_ok;		/* 1 = passwd checked OK */
@@ -1102,8 +1100,7 @@ struct _peer {
 };
 
 struct _net_db_name {
-    char *name;
-    net_db_name *htbl_next;
+    hash_link hash;		/* must be first */
     net_db_name *next;
     netdbEntry *net_db_entry;
 };
@@ -1116,9 +1113,7 @@ struct _net_db_peer {
 };
 
 struct _netdbEntry {
-    /* first two items must be equivalent to hash_link */
-    char *key;
-    netdbEntry *next;
+    hash_link hash;		/* must be first */
     char network[16];
     int pings_sent;
     int pings_recv;
@@ -1306,9 +1301,7 @@ struct _MemObject {
 };
 
 struct _StoreEntry {
-    /* first two items must be same as hash_link */
-    const cache_key *key;
-    StoreEntry *next;
+    hash_link hash;		/* must be first */
     MemObject *mem_obj;
     time_t timestamp;
     time_t lastref;
@@ -1711,9 +1704,7 @@ struct _MemPool {
 };
 
 struct _ClientInfo {
-    /* first two items must be equivalent to hash_link */
-    char *key;
-    ClientInfo *next;
+    hash_link hash;		/* must be first */
     struct in_addr addr;
     struct {
 	int result_hist[LOG_TYPE_MAX];
@@ -1848,17 +1839,17 @@ struct _store_rebuild_data {
 struct _PumpStateData {
     FwdState *fwd;
     request_t *req;
-    store_client *sc;           /* The store client we're using */
-    int c_fd;                   /* client fd */
-    int s_fd;                   /* server end */
-    int rcvd;                   /* bytes received from client */
-    int sent;                   /* bytes sent to server */
-    StoreEntry *request_entry;  /* the request entry */
-    StoreEntry *reply_entry;    /* the reply entry */
-    CWCB *callback;             /* what to do when we finish sending */
-    void *cbdata;               /* callback data passed to callback func */
-    struct {
-        int closing:1;
+    store_client *sc;		/* The store client we're using */
+    int c_fd;			/* client fd */
+    int s_fd;			/* server end */
+    int rcvd;			/* bytes received from client */
+    int sent;			/* bytes sent to server */
+    StoreEntry *request_entry;	/* the request entry */
+    StoreEntry *reply_entry;	/* the reply entry */
+    CWCB *callback;		/* what to do when we finish sending */
+    void *cbdata;		/* callback data passed to callback func */
+    struct {
+	int closing:1;
     } flags;
     struct _PumpStateData *next;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: test_cache_digest.cc,v 1.25 2000/05/16 07:09:34 wessels Exp $
+ * $Id: test_cache_digest.cc,v 1.26 2000/10/31 23:48:15 wessels Exp $
  *
  * AUTHOR: Alex Rousskov
  *
@@ -467,7 +467,7 @@ cacheStore(Cache * cache, storeSwapLogData * s, int update_digest)
 	cache->bad_add_count++;
     } else {
 	CacheEntry *e = cacheEntryCreate(s);
-	hash_join(cache->hash, (hash_link *) e);
+	hash_join(cache->hash, &e->hash);
 	cache->count++;
 	if (update_digest)
 	    cacheDigestAdd(cache->digest, e->key);