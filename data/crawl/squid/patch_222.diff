@@ -1,3 +1,21 @@
+Changes to squid-3.5.2 (18 Feb 2015):
+
+	- Regression Bug 4176: Digest auth too many helper lookups
+	- Regression Bug 4180: not-fully-initialized data member in ACLUserData
+	- Bug 4172: Solaris broken krb5-config
+	- Bug 4073: Cygwin compile errors
+	- Bug 3919: remove several never-true / never-false comparisons
+	- HTTPS: Add missing root CAs when validating chains that passed internal checks
+	- Fix some cbdataFree related memory leaks
+	- Quieten CBDATA 'leak' messages
+	- Set SNI information in transparent bumping mode
+	- negotiate_kerberos_auth: fix krb5.conf backward compatibility
+	- Fix memory leaks in cachemgr.cgi URL parser
+	- Fix sslproxy_options in peek-and-splice mode
+	- ... and fix several portability and build issues
+	- ... and some documentation updates
+	- ... and all fixes from squid 3.4.11
+
 Changes to squid-3.5.1 (13 Jan 2015):
 
 	- Fix handling of invalid SSL server certificates when splicing connections
@@ -100,6 +118,18 @@ Changes to squid-3.5.0.1 (17 Oct 2014):
 	- ... and many error page translation updates
 	- ... and much code cleanup and polishing
 
+Changes to squid-3.4.12 (18 Feb 2015):
+
+	- Bug 4066: Digest auth nonce indefinite rollover
+	- Bug 3997: Excessive NTLM or Negotiate auth helper annotations
+	- Fix several crashes when debugging enabled
+	- Fix silent SSL/TLS failure on split-stack operating systems
+	- HTTP/1.1: Stop emitting (Proxy-)Authentication-Info for Negotiate
+	- HTTPS: Add TLS/SSL option NO_TICKET to http[s]_port
+	- Remove dst ACL dependency on HTTP request message existence
+	- Set cap_net_admin when Squid sets TOS/Diffserv packet values
+	- ... and some documentation updates
+
 Changes to squid-3.4.11 (13 Jan 2015):
 
 	- Bug 4164: SEGFAULT when %W formating code used in errorpages
@@ -64,9 +64,8 @@
 #elif defined(__DragonFly__)
 #define _SQUID_DRAGONFLY_ 1
 
-#elif defined(__CYGWIN32__) || defined(__CYGWIN__)
+#elif defined(__CYGWIN__)
 #define _SQUID_CYGWIN_ 1
-#define _SQUID_WINDOWS_ 1
 
 #elif defined(__MINGW32__) || defined(__MINGW__)
 #define _SQUID_MINGW_ 1
@@ -12,10 +12,6 @@
 // these functions are not used by the remaining Squid C code.
 #if defined(__cplusplus)
 
-#if HAVE_STDBOOL_H
-#include <stdbool.h>
-#endif
-
 /**
  * xstrtou{i,l} - string to number conversion
  * \param s     input string
@@ -206,8 +206,7 @@ else
 fi
 AC_SUBST(CGIEXT)
 
-AM_CONDITIONAL(ENABLE_WIN32SPECIFIC,
-               [test "x$squid_host_os" = "xmingw" -o "x$squid_host_os" = "xcygwin"])
+AM_CONDITIONAL(ENABLE_WIN32SPECIFIC,[test "x$squid_host_os" = "xmingw"])
 AM_CONDITIONAL(ENABLE_WIN32_IPC,[test "x$squid_host_os" = "xmingw"])
 
 case "$squid_host_os" in
@@ -1131,10 +1130,10 @@ SQUID_YESNO([$enableval],[--disable-eui expects no arguments])
 ])
 if test "x${enable_eui:=yes}" = "xyes" ; then
   case "$squid_host_os" in
-    linux|solaris|freebsd|openbsd|netbsd)
+    linux|solaris|freebsd|openbsd|netbsd|cygwin)
       ${TRUE}
       ;;
-    cygwin|mingw)
+    mingw)
       EUILIB="-liphlpapi"
       ;;
     *)
@@ -1606,8 +1605,12 @@ if test "x$with_solaris_krb5" = "xyes"; then
     AC_MSG_NOTICE([Use krb5-config to get CXXFLAGS and LIBS])
     LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags krb5 2>/dev/null`"
     LIB_KRB5_LIBS="`$ac_krb5_config --libs krb5 2>/dev/null`"
-    LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
-    LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+    # Solaris 10 Update 11 patches the krb5-config tool to produce stderr messages on stdout.
+    SOLARIS_BROKEN_KRB5CONFIG_GSSAPI="`$ac_krb5_config --libs gssapi 2>/dev/null | grep "krb5-config"`"
+    if test "x$SOLARIS_BROKEN_KRB5CONFIG_GSSAPI" = "x"; then
+      LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
+      LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+    fi
   else
     ## For some OS pkg-config is broken or unavailable.
     ## Detect libraries the hard way.
@@ -2799,7 +2802,6 @@ AC_CHECK_HEADERS( \
   siginfo.h \
   signal.h \
   stdarg.h \
-  stdbool.h \
   stddef.h \
   stdio.h \
   stdlib.h \
@@ -3859,6 +3861,7 @@ AC_CONFIG_FILES([
 	src/base/Makefile
 	src/clients/Makefile
 	src/comm/Makefile
+	src/dns/Makefile
 	src/esi/Makefile
 	src/eui/Makefile
 	src/format/Makefile
@@ -57,6 +57,7 @@ section 21    Time Functions
 section 22    Refresh Calculation
 section 23    URL Parsing
 section 23    URL Scheme parsing
+section 24    SBuf
 section 25    MiME Header Parsing
 section 25    MIME Parsing and Internal Icons
 section 26    Secure Sockets Layer Proxy
@@ -124,7 +125,7 @@ section 75    WHOIS protocol
 section 76    Internal Squid Object handling
 section 77    Delay Pools
 section 78    DNS lookups
-section 78    DNS lookups; interacts with lib/rfc1035.c
+section 78    DNS lookups; interacts with dns/rfc1035.cc
 section 79    Disk IO Routines
 section 79    Squid-side DISKD I/O functions.
 section 79    Squid-side Disk I/O functions.
@@ -15,7 +15,7 @@ for Applied Network Research and members of the Web Caching community.
 <p>
 The Squid Team are pleased to announce the release of Squid-3.0.STABLE26.
 
-This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.0/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.0/"> or the <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 A large number of the show-stopper bugs have been fixed along with general improvements to the ICAP support and additional Languages.
 
@@ -15,7 +15,7 @@ for Applied Network Research and members of the Web Caching community.
 <p>
 The Squid Team are pleased to announce the release of Squid-3.1.23
 
-This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 A large number of the show-stopper bugs have been fixed along with general improvements to the ICAP support.
 While this release is not fully bug-free we believe it is ready for use in production on many systems.
@@ -16,7 +16,7 @@ for Applied Network Research and members of the Web Caching community.
 The Squid Team are pleased to announce the release of Squid-3.2.13.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the
- <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+ <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 <p>A large number of the show-stopper bugs have been fixed along with general improvements to the IPv6 support.
 While this release is not fully bug-free we believe it is ready for use in production on many systems.
@@ -744,6 +744,9 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
+	<tag>chunked_request_body_max_size</tag>
+	<p>Obsolete. Squid is now HTTP/1.1 with support for streaming chunked encoded requests.
+
 	<tag>dns_v4_fallback</tag>
 	<p>Obsolete. Replaced by DNS parallel lookups.
 
@@ -16,7 +16,7 @@ for Applied Network Research and members of the Web Caching community.
 The Squid Team are pleased to announce the release of Squid-3.3.13.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
-<url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+<url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 <p>A large number of the design flaws in SSL-Bump feature have been fixed along with general improvements all around.
 While this release is not fully bug-free we believe it is ready for use in production on many systems.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.11 release notes</title>
+<title>Squid 3.4.12 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,10 +13,10 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.11 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.12.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
- <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+ <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 <p>Some interesting new features adding system flexibility have been added along with general improvements all around.
    While this release is not fully bug-free we believe it is ready for use in production on many systems.
@@ -347,6 +347,12 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
+	<tag>log_access</tag>
+	<p>Removed. Use access_log with ACLs instead
+
+	<tag>log_icap</tag>
+	<p>Removed. Use icap_log with ACLs instead
+
 	<tag>storeurl_access</tag>
 	<p>Replaced by <em>store_id_access</em>.
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.1 release notes</title>
+<title>Squid 3.5.2 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,10 +13,10 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.1 for testing.
+The Squid Team are pleased to announce the release of Squid-3.5.2.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
- <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+ <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 <p>Some interesting new features adding system flexibility have been added along with general improvements all around.
    While this release is not fully bug-free we believe it is ready for use in production on many systems.
@@ -239,7 +239,7 @@ Most user-facing changes are reflected in squid.conf (see below).
    receive traffic from client software sending in this protocol.
    HTTP traffic without the PROXY header is not accepted on such a port.
 
-<p>The <em>accel</em> and <em>intercept</em> options are still used to identify the
+<p>The <em>accel</em> and <em>intercept</em> options are still used to identify the HTTP
    traffic syntax being delivered by the client proxy.
 
 <p>Squid can be configured by adding an <em>http_port</em>
@@ -320,18 +320,14 @@ This section gives a thorough account of those changes in three categories:
 	<p>Ported from Squid-2 with no configuration or visible behaviour changes.
            Collapsing of requests is performed across SMP workers.
 
-	<tag>ftp_client_idle_timeout</tag>
-	<p>This new configuration directive controls how long Squid should
-	   wait for an FTP request on a connection to an ftp_port.  Many FTP
-	   clients do not deal with idle connection closures well,
-	   necessitating a longer default timeout (30 minutes) than
-	   client_idle_pconn_timeout used for incoming HTTP requests (2
-	   minutes). The current default may be changed as we get more
-	   experience with FTP relaying.
-
 	<tag>ftp_client_idle_timeout</tag>
 	<p>New directive controlling how long to wait for an FTP request on a
 	   client connection to Squid <em>ftp_port</em>.
+	<p>Many FTP clients do not deal with idle connection closures well,
+	   necessitating a longer default timeout (30 minutes) than
+	   <em>client_idle_pconn_timeout</em> used for incoming HTTP requests (2
+	   minutes).
+	<p>The current default may be changed as we get more experience with FTP relaying.
 
 	<tag>ftp_port</tag>
 	<p>New configuration directive to accept and relay native FTP
@@ -16,7 +16,7 @@ for Applied Network Research and members of the Web Caching community.
 The Squid Team are pleased to announce the release of Squid-3.6.0.0 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.6/"> or the
- <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
+ <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
 
 <p>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.
 
@@ -102,10 +102,11 @@ This section gives a thorough account of those changes in three categories:
 	<p>New tag to define TLS security context options for outgoing
 	   connections. For example to HTTPS servers.
 
-         <tag> url_rewrite_timeout </tag>
-         <p> Squid times active requests to redirector. This option sets
-             the timeout value and the Squid reaction to a timed out
-             request. </p>
+	<tag>url_rewrite_timeout</tag>
+	<p>Squid times active requests to redirector. This option sets
+	   the timeout value and the Squid reaction to a timed out
+	   request.
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -158,6 +159,15 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
+	<tag>cache_peer_domain</tag>
+	<p>Superceded by <em>cache_peer_access</em>. Use dstdomain ACL
+	   in the access control list to restrict domains requested.
+
+	<tag>refresh_pattern</tag>
+	<p>Option <em>ignore-auth</em> removed. Its original intent was
+	   to improve caching. HTTP/1.1 permits caching of authenticated
+	   messages under conditions which Squid does check for and obey.
+
 	<tag>sslproxy_cafile</tag>
 	<p>Replaced by <em>tls_outgoing_options cafile=</em>.
 
@@ -37,6 +37,7 @@ ERROR_TEMPLATES= \
     templates/ERR_NO_RELAY \
     templates/ERR_ONLY_IF_CACHED_MISS \
     templates/ERR_PRECONDITION_FAILED \
+    templates/ERR_PROTOCOL_UNKNOWN \
     templates/ERR_READ_ERROR \
     templates/ERR_READ_TIMEOUT \
     templates/ERR_SECURE_CONNECT_FAIL \
@@ -0,0 +1,38 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html><head>
+<meta type="copyright" content="Copyright (C) 1996-2015 The Squid Software Foundation and contributors">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<title>ERROR: The requested URL could not be retrieved</title>
+<style type="text/css"><!-- 
+ %l
+
+body
+:lang(fa) { direction: rtl; font-size: 100%; font-family: Tahoma, Roya, sans-serif; float: right; }
+:lang(he) { direction: rtl; }
+ --></style>
+</head><body id=%c>
+<div id="titles">
+<h1>ERROR</h1>
+<h2>The requested URL could not be retrieved</h2>
+</div>
+<hr>
+
+<div id="content">
+<p>The following error was encountered while trying to retrieve the URL: <a href="%U">%U</a></p>
+
+<blockquote id="error">
+<p><b>Unsupported Protocol</b></p>
+</blockquote>
+
+<p>Squid does not support some access protocols. For example, the SSH protocol is currently not supported.</p>
+
+<p>Your cache administrator is <a href="mailto:%w%W">%w</a>.</p>
+<br>
+</div>
+
+<hr>
+<div id="footer">
+<p>Generated %T by %h (%s)</p>
+<!-- %c -->
+</div>
+</body></html>
@@ -73,20 +73,22 @@ main(int argc, char **argv)
         if (!nispasswd) {
             /* User does not exist */
             printf("ERR No such user\n");
+            continue;
+        }
+
 #if HAVE_CRYPT
-        } else if (strcmp(nispasswd, (char *) crypt(passwd, nispasswd)) == 0) {
+        char *crypted = NULL;
+        if ((crypted = crypt(passwd, nispasswd)) && strcmp(nispasswd, crypted) == 0) {
             /* All ok !, thanks... */
             printf("OK\n");
         } else {
             /* Password incorrect */
             printf("ERR Wrong password\n");
-#else
         }
-        else {
-            /* Password incorrect */
-            printf("BH message=\"Missing crypto capability\"\n");
+#else
+        /* Password incorrect */
+        printf("BH message=\"Missing crypto capability\"\n");
 #endif
-        }
     }
     exit(0);
 }
@@ -59,7 +59,8 @@ passwd_auth(char *user, char *passwd)
     if (pwd == NULL) {
         return 0;       /* User does not exist */
     } else {
-        if (strcmp(pwd->pw_passwd, (char *) crypt(passwd, pwd->pw_passwd))) {
+        char *crypted = crypt(passwd, pwd->pw_passwd);
+        if (!crypted || strcmp(pwd->pw_passwd, crypted)) {
             return 2;       /* Wrong password */
         } else {
             return 1;       /* Authentication Sucessful */
@@ -76,7 +77,8 @@ shadow_auth(char *user, char *passwd)
     if (pwd == NULL) {
         return passwd_auth(user, passwd);   /* Fall back to passwd_auth */
     } else {
-        if (strcmp(pwd->sp_pwdp, crypt(passwd, pwd->sp_pwdp))) {
+        char *crypted = crypt(passwd, pwd->sp_pwdp);
+        if (!crypted || strcmp(pwd->sp_pwdp, crypted)) {
             return 2;       /* Wrong password */
         } else {
             return 1;       /* Authentication Sucessful */
@@ -7,19 +7,19 @@ Version 2.18
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_ldap_group_acl
-.if !'po4a'hide' .B "\-b \""
-base DN
-.if !'po4a'hide' .B "\" \-f \""
-LDAP search filter
-.if !'po4a'hide' .B "\" ["
+.if !'po4a'hide' .B \-b
+base\-DN
+.if !'po4a'hide' .B \-f
+filter
+.if !'po4a'hide' .B "["
 options
 .if !'po4a'hide' .B "] ["
-LDAP server name
-.if !'po4a'hide' .B "[:"
+server
+.if !'po4a'hide' .B "[ ':' "
 port
-.if !'po4a'hide' .B "]|"
+.if !'po4a'hide' .B "] |"
 URI
-.if !'po4a'hide' .B "]..."
+.if !'po4a'hide' .B "] ..."
 .
 .SH DESCRIPTION
 .B ext_ldap_group_acl
@@ -100,7 +100,7 @@ and the password is not being compromised if someone gets the squid
 configuration file without getting the secretfile.
 .
 .if !'po4a'hide' .TP
-.if !'po4a'hide' .BI \-E certpath
+.if !'po4a'hide' .BI "\-E " certpath
 Enable LDAP over SSL (requires Netscape LDAP API libraries)
 .
 .if !'po4a'hide' .TP
@@ -7,7 +7,7 @@ Version 1.3.0sq
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_kerberos_ldap_group_acl
-.if !'po4a'hide' .B [\-h] [\-d] [\-i] [\-s] [\-a] [\-D Realm ] [\-N Netbios-Realm-List] [\-m Max-Depth] [\-u Ldap-User] [\-p Ldap-Password] [\-b Ldap-Bind-Path] [\-l Ldap-URL] [\-S ldap server list] \-g Group-Realm-List \-t  Hex-Group-Realm-List \-T Hex-Group-Hex-Realm-List 
+.if !'po4a'hide' .B [\-h] [\-d] [\-i] [\-s] [\-a] [\-D Realm ] [\-N Netbios\-Realm\-List] [\-m Max\-Depth] [\-u Ldap\-User] [\-p Ldap\-Password] [\-b Ldap\-Bind\-Path] [\-l Ldap\-URL] [\-S ldap server list] \-g Group\-Realm\-List \-t  Hex\-Group\-Realm\-List \-T Hex\-Group\-Hex\-Realm\-List 
 .
 .SH DESCRIPTION
 .B ext_kerberos_ldap_group_acl
@@ -85,18 +85,18 @@ Allow SSL without certificate verification.
 Default Kerberos domain to use for usernames which do not contain domain 
 information (e.g. for users using basic authentication).
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-N Netbios-Realm-List
+.if !'po4a'hide' .B \-N Netbios\-Realm\-List
 A list of Netbios name mappings to Kerberos domain names of the form 
-Netbios-Name@Kerberos-Realm[:Netbios-Name@Kerberos-Realm] (e.g. for users 
+Netbios\-Name@Kerberos\-Realm[:Netbios\-Name@Kerberos\-Realm] (e.g. for users 
 using NTLM authentication).
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-m Max-Depth
+.if !'po4a'hide' .B \-m Max\-Depth
 Maximal depth of recursive group search.
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-u Ldap-User
+.if !'po4a'hide' .B \-u Ldap\-User
 Username for LDAP server.
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-u Ldap-Password
+.if !'po4a'hide' .B \-p Ldap\-Password
 Password for LDAP server.
 .IP
 As the password needs to be printed in plain text in your Squid configuration
@@ -105,29 +105,29 @@ This to limit the damage in case someone could get hold of a copy of your Squid
 configuration file or extracts the password used from a process listing.
 .
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-b Ldap-Bind-Path
+.if !'po4a'hide' .B \-b Ldap\-Bind\-Path
 LDAP server bind path.
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-u Ldap-URL
+.if !'po4a'hide' .B \-l Ldap\-URL
 LDAP server URL in form ldap[s]://server:port
 .if !'po4a'hide' .TP 12
 .if !'po4a'hide' .B \-S ldap server list
 list of ldap servers of the form
 lserver|lserver@|lserver@Realm[:lserver@|lserver@Realm]
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-g Group-Realm-List
+.if !'po4a'hide' .B \-g Group\-Realm\-List
 A list of group name per Kerberos domain of the form 
 Group|Group@|Group@Realm[:Group@|Group@Realm]
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-t  Hex-Group-Realm-List
+.if !'po4a'hide' .B \-t  Hex\-Group\-Realm\-List
 A list of group name per Kerberos domain of the 
 form Group|Group@|Group@Realm[:Group@|Group@Realm] where group is in 
-UTF-8 hex format
+UTF\-8 hex format
 .if !'po4a'hide' .TP 12
-.if !'po4a'hide' .B \-T Hex-Group-Hex-Realm-List
+.if !'po4a'hide' .B \-T Hex\-Group\-Hex\-Realm\-List
 A list of group name per Kerberos domain of the form 
 Group|Group@|Group@Realm[:Group@|Group@Realm] where group and domain 
-is in UTF-8 hex format
+is in UTF\-8 hex format
 .
 .SH CONFIGURATION
 .PP
@@ -138,9 +138,9 @@ helper in
 .if !'po4a'hide' .P
 .if !'po4a'hide' .ft CR
 .if !'po4a'hide' .nf
-.if !'po4a'hide' external_acl_type kerberos_ldap_group1  ttl=3600  negative_ttl=3600 %LOGIN /path/to/ext_kerberos_ldap_group_acl -g GROUP1
+.if !'po4a'hide' external_acl_type kerberos_ldap_group1  ttl=3600  negative_ttl=3600 %LOGIN /path/to/ext_kerberos_ldap_group_acl \-g GROUP1
 .if !'po4a'hide' .br
-.if !'po4a'hide' external_acl_type kerberos_ldap_group2  ttl=3600  negative_ttl=3600 %LOGIN /path/to/ext_kerberos_ldap_group_acl -g GROUP2
+.if !'po4a'hide' external_acl_type kerberos_ldap_group2  ttl=3600  negative_ttl=3600 %LOGIN /path/to/ext_kerberos_ldap_group_acl \-g GROUP2
 .if !'po4a'hide' .br
 .if !'po4a'hide' acl group1 external kerberos_ldap_group1
 .if !'po4a'hide' .br
@@ -168,7 +168,7 @@ script.
 .if !'po4a'hide' .P
 .if !'po4a'hide' .ft CR
 .if !'po4a'hide' .nf
-.if !'po4a'hide' KRB5_CONFIG=/etc/krb5-squid.conf
+.if !'po4a'hide' KRB5_CONFIG=/etc/krb5\-squid.conf
 .if !'po4a'hide' export KRB5_CONFIG
 .if !'po4a'hide' .fi
 .if !'po4a'hide' .ft
@@ -182,37 +182,37 @@ will determine automagically the right ldap server. The following method is used
    c) Use LDAP_URL if given
 
 2) For user
-   a) Use domain -D REALM and follow step 1)
+   a) Use domain \-D REALM and follow step 1)
    b) Use LDAP_URL if given
 
 The Groups to check against are determined as follows:
 
 1) For user@REALM
-   a) Use values given by -g option which contain a @REALM e.g. -g GROUP1@REALM:GROUP2@REALM
-   b) Use values given by -g option which contain a @ only e.g. -g GROUP1@:GROUP2@
-   c) Use values given by -g option which do not contain a realm e.g. -g GROUP1:GROUP2
+   a) Use values given by \-g option which contain a @REALM e.g. \-g GROUP1@REALM:GROUP2@REALM
+   b) Use values given by \-g option which contain a @ only e.g. \-g GROUP1@:GROUP2@
+   c) Use values given by \-g option which do not contain a realm e.g. \-g GROUP1:GROUP2
 
 2) For user
-   a) Use values given by -g option which do not contain a realm e.g. -g GROUP1:GROUP2
+   a) Use values given by \-g option which do not contain a realm e.g. \-g GROUP1:GROUP2
 
 3) For NDOMAIN\\user
-   a) Use realm given by -N NDOMAIN@REALM and then use values given by -g option which contain a @REALM e.g. -g GROUP1@REALM:GROUP2@REALM
+   a) Use realm given by \-N NDOMAIN@REALM and then use values given by \-g option which contain a @REALM e.g. \-g GROUP1@REALM:GROUP2@REALM
 
-To support Non-ASCII character use -t GROUP  or -t GROUP@REALM instead of -g where GROUP is the hex UTF-8 representation e.g.
+To support Non\-ASCII character use \-t GROUP  or \-t GROUP@REALM instead of \-g where GROUP is the hex UTF\-8 representation e.g.
 
-   -t 6d61726b7573 instead of -g markus
+   \-t 6d61726b7573 instead of \-g markus
 
-The REALM must still be based on the ASCII character set. If REALM contains also non ASCII characters use -T GROUP@REALM where GROUP and REALM are hex UTF-8 representation e.g.
+The REALM must still be based on the ASCII character set. If REALM contains also non ASCII characters use \-T GROUP@REALM where GROUP and REALM are hex UTF\-8 representation e.g.
 
-  -T 6d61726b7573@57494e3230303352322e484f4d45 instead of -g markus@WIN2003R2.HOME
+  \-T 6d61726b7573@57494e3230303352322e484f4d45 instead of \-g markus@WIN2003R2.HOME
 
-For a translation of hex UTF-8 see for example http://www.utf8-chartable.de/unicode-utf8-table.pl
+For a translation of hex UTF\-8 see for example http://www.utf8\-chartable.de/unicode\-utf8\-table.pl
 
 The ldap server list can be:
-server - In this case server can be used for all Kerberos domains
-server@  - In this case server can be used for all Kerberos domains
-server@domain  - In this case server can be used for Kerberos domain domain
-server1a@domain1:server1b@domain1:server2@domain2:server3@:server4 - A list is build with a colon as seperator
+server \- In this case server can be used for all Kerberos domains
+server@  \- In this case server can be used for all Kerberos domains
+server@domain  \- In this case server can be used for Kerberos domain domain
+server1a@domain1:server1b@domain1:server2@domain2:server3@:server4 \- A list is build with a colon as seperator
 
 .
 .SH AUTHOR
@@ -224,7 +224,7 @@ This manual was written by
 .
 .SH COPYRIGHT
 .PP
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ * Copyright (C) 1996\-2015 The Squid Software Foundation and contributors
  *
  * Squid software is distributed under GPLv2+ license and includes
  * contributions from numerous individuals and organizations.
@@ -237,36 +237,36 @@ Distributed under the GNU General Public License (GNU GPL) version 2 or later (G
 .SH QUESTIONS
 Questions on the usage of this program can be sent to the
 .I Squid Users mailing list
-.if !'po4a'hide' <squid-users@squid-cache.org>
+.if !'po4a'hide' <squid\-users@squid\-cache.org>
 .
 .SH REPORTING BUGS
 Bug reports need to be made in English.
-See http://wiki.squid-cache.org/SquidFaq/BugReporting for details of what you need to include with your bug report.
+See http://wiki.squid\-cache.org/SquidFaq/BugReporting for details of what you need to include with your bug report.
 .PP
-Report bugs or bug fixes using http://bugs.squid-cache.org/
+Report bugs or bug fixes using http://bugs.squid\-cache.org/
 .PP
 Report serious security bugs to
-.I Squid Bugs <squid-bugs@squid-cache.org>
+.I Squid Bugs <squid\-bugs@squid\-cache.org>
 .PP
 Report ideas for new improvements to the
 .I Squid Developers mailing list
-.if !'po4a'hide' <squid-dev@squid-cache.org>
+.if !'po4a'hide' <squid\-dev@squid\-cache.org>
 .
 .SH SEE ALSO
 .if !'po4a'hide' .BR squid "(8) "
 .if !'po4a'hide' .BR negotiate_kerberos_auth "(8) "
 .br
-.BR RFC1035 " - Domain names - implementation and specification,"
+.BR RFC1035 " \- Domain names \- implementation and specification,"
 .br
-.BR RFC2782 " - A DNS RR for specifying the location of services (DNS SRV),"
+.BR RFC2782 " \- A DNS RR for specifying the location of services (DNS SRV),"
 .br
-.BR RFC2254 " - The String Representation of LDAP Search Filters,"
+.BR RFC2254 " \- The String Representation of LDAP Search Filters,"
 .br
-.BR RFC2307bis " - An Approach for Using LDAP as a Network Information Service
+.BR RFC2307bis " \- An Approach for Using LDAP as a Network Information Service
 http://www.padl.com/~lukeh/rfc2307bis.txt,"
 .br
 The Squid FAQ wiki
-.if !'po4a'hide' http://wiki.squid-cache.org/SquidFaq
+.if !'po4a'hide' http://wiki.squid\-cache.org/SquidFaq
 .br
 The Squid Configuration Manual
-.if !'po4a'hide' http://www.squid-cache.org/Doc/config/
+.if !'po4a'hide' http://www.squid\-cache.org/Doc/config/
@@ -55,8 +55,6 @@ extern "C" {
 
 #if HAVE_COM_ERR_H
 #include <com_err.h>
-#elif USE_HEIMDAL_KRB5
-#define error_message(code) krb5_get_err_text(kparam.context,code)
 #endif /* HAVE_COM_ERR_H */
 
 #define LDAP_DEPRECATED 1
@@ -54,6 +54,28 @@ krb5_cleanup()
         }
     krb5_free_context(kparam.context);
 }
+
+static void
+k5_error2(const char* msg, char* msg2, krb5_error_code code)
+{
+    const char *errmsg;
+    errmsg = krb5_get_error_message(kparam.context, code);
+    error((char *) "%s| %s: ERROR: %s%s : %s\n", LogTime(), PROGRAM, msg, msg2, errmsg);
+#if HAVE_KRB5_FREE_ERROR_MESSAGE
+    krb5_free_error_message(kparam.context, errmsg);
+#elif HAVE_KRB5_FREE_ERROR_STRING
+    krb5_free_error_string(kparam.context, (char *)errmsg);
+#else
+    xfree(errmsg);
+#endif
+}
+
+static void
+k5_error(const char* msg, krb5_error_code code)
+{
+    k5_error2(msg, (char *)"", code);
+}
+
 /*
  * create Kerberos memory cache
  */
@@ -109,7 +131,7 @@ krb5_create_cache(char *domain)
         }
         code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
         if (code) {
-            error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+            k5_error("Error while resolving memory ccache",code);
             retval = 1;
             goto cleanup;
         }
@@ -123,23 +145,22 @@ krb5_create_cache(char *domain)
         if (principal)
             krb5_free_principal(kparam.context, principal);
         principal = NULL;
-        debug((char *) "%s| %s: DEBUG: No default principal found in ccache : %s\n", LogTime(), PROGRAM, error_message(code));
-
+        k5_error("No default principal found in ccache",code);
     } else {
         /*
          * Look for krbtgt and check if it is expired (or soon to be expired)
          */
         code = krb5_cc_start_seq_get(kparam.context, kparam.cc[ccindex], &ccursor);
         if (code) {
-            error((char *) "%s| %s: ERROR: Error while starting ccache scan : %s\n", LogTime(), PROGRAM, error_message(code));
+            k5_error("Error while starting ccache scan",code);
             code = krb5_cc_close (kparam.context, kparam.cc[ccindex]);
             if (code) {
-                error((char *) "%s| %s: ERROR: while closing ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                k5_error("Error while closing ccache",code);
             }
             if (kparam.cc[ccindex]) {
                 code = krb5_cc_destroy(kparam.context, kparam.cc[ccindex]);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: while destroying ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while destroying ccache",code);
                 }
             }
         } else {
@@ -148,10 +169,10 @@ krb5_create_cache(char *domain)
             while ((krb5_cc_next_cred(kparam.context, kparam.cc[ccindex], &ccursor, creds)) == 0) {
                 code2 = krb5_unparse_name(kparam.context, creds->server, &principal_name);
                 if (code2) {
-                    error((char *) "%s| %s: ERROR: Error while unparsing principal : %s\n", LogTime(), PROGRAM, error_message(code2));
+                    k5_error("Error while unparsing principal",code2);
                     code = krb5_cc_destroy(kparam.context, kparam.cc[ccindex]);
                     if (code) {
-                        error((char *) "%s| %s: ERROR: while destroying ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                        k5_error("Error while destroying ccache",code);
                     }
                     if (creds)
                         krb5_free_creds(kparam.context, creds);
@@ -160,7 +181,7 @@ krb5_create_cache(char *domain)
                     debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
                     code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
                     if (code) {
-                        error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                        k5_error("Error  while resolving memory ccache",code);
                         retval = 1;
                         goto cleanup;
                     }
@@ -184,7 +205,7 @@ krb5_create_cache(char *domain)
                         principal = NULL;
                         code = krb5_cc_destroy(kparam.context, kparam.cc[ccindex]);
                         if (code) {
-                            error((char *) "%s| %s: ERROR: while destroying ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                            k5_error("Error  while destroying ccache",code);
                         }
                         if (creds)
                             krb5_free_creds(kparam.context, creds);
@@ -193,7 +214,7 @@ krb5_create_cache(char *domain)
                         debug((char *) "%s| %s: DEBUG: Reset credential cache to %s\n", LogTime(), PROGRAM, mem_cache);
                         code = krb5_cc_resolve(kparam.context, mem_cache, &kparam.cc[ccindex]);
                         if (code) {
-                            error((char *) "%s| %s: ERROR: Error while resolving memory ccache : %s\n", LogTime(), PROGRAM, error_message(code));
+                            k5_error("Error  while resolving ccache",code);
                             retval = 1;
                             goto cleanup;
                         }
@@ -213,7 +234,7 @@ krb5_create_cache(char *domain)
             creds = NULL;
             code2 = krb5_cc_end_seq_get(kparam.context, kparam.cc[ccindex], &ccursor);
             if (code2) {
-                error((char *) "%s| %s: ERROR: Error while ending ccache scan : %s\n", LogTime(), PROGRAM, error_message(code));
+                k5_error("Error  while ending ccache scan",code2);
                 retval = 1;
                 goto cleanup;
             }
@@ -234,13 +255,13 @@ krb5_create_cache(char *domain)
 
         code = krb5_kt_resolve(kparam.context, keytab_name, &keytab);
         if (code) {
-            error((char *) "%s| %s: ERROR: Error while resolving keytab %s : %s\n", LogTime(), PROGRAM, keytab_name, error_message(code));
+            k5_error2("Error while resolving keytab ",keytab_name,code);
             retval = 1;
             goto cleanup;
         }
         code = krb5_kt_start_seq_get(kparam.context, keytab, &cursor);
         if (code) {
-            error((char *) "%s| %s: ERROR: Error while starting keytab scan : %s\n", LogTime(), PROGRAM, error_message(code));
+            k5_error("Error while starting keytab scan",code);
             retval = 1;
             goto cleanup;
         }
@@ -265,7 +286,7 @@ krb5_create_cache(char *domain)
             {
                 code = krb5_unparse_name(kparam.context, entry.principal, &principal_name);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while unparsing principal name",code);
                 } else {
                     debug((char *) "%s| %s: DEBUG: Found principal name: %s\n", LogTime(), PROGRAM, principal_name);
                     found = 1;
@@ -277,7 +298,7 @@ krb5_create_cache(char *domain)
             code = krb5_free_keytab_entry_contents(kparam.context, &entry);
 #endif
             if (code) {
-                error((char *) "%s| %s: ERROR: Error while freeing keytab entry : %s\n", LogTime(), PROGRAM, error_message(code));
+                k5_error("Error while freeing keytab entry",code);
                 retval = 1;
                 break;
             }
@@ -288,7 +309,7 @@ krb5_create_cache(char *domain)
                  */
                 code = krb5_parse_name(kparam.context, principal_name, &principal);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while parsing name %s : %s\n", LogTime(), PROGRAM, principal_name, error_message(code));
+                    k5_error2("Error while parsing name ", principal_name,code);
                     safe_free(principal_name);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
@@ -312,7 +333,7 @@ krb5_create_cache(char *domain)
 #endif
 
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while initialising credentials from keytab" ,code);
                     safe_free(principal_name);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
@@ -324,7 +345,7 @@ krb5_create_cache(char *domain)
                 }
                 code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while initialising  memory caches" ,code);
                     safe_free(principal_name);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
@@ -336,7 +357,7 @@ krb5_create_cache(char *domain)
                 }
                 code = krb5_cc_store_cred(kparam.context, kparam.cc[ccindex], creds);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while storing credentials" ,code);
                     if (principal)
                         krb5_free_principal(kparam.context, principal);
                     safe_free(principal_name);
@@ -352,13 +373,13 @@ krb5_create_cache(char *domain)
         }
 
         if (code && code != KRB5_KT_END) {
-            error((char *) "%s| %s: ERROR: Error while scanning keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+            k5_error("Error while scanning keytab" ,code);
             retval = 1;
             goto cleanup;
         }
         code = krb5_kt_end_seq_get(kparam.context, keytab, &cursor);
         if (code) {
-            error((char *) "%s| %s: ERROR: Error while ending keytab scan : %s\n", LogTime(), PROGRAM, error_message(code));
+            k5_error("Error while ending keytab scan" ,code);
             retval = 1;
             goto cleanup;
         }
@@ -380,7 +401,7 @@ krb5_create_cache(char *domain)
                  */
                 code = krb5_unparse_name(kparam.context, principal_list[i], &principal_name);
                 if (code) {
-                    debug((char *) "%s| %s: DEBUG: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while unparsing principal name" ,code);
                     goto loop_end;
                 }
                 debug((char *) "%s| %s: DEBUG: Keytab entry has principal: %s\n", LogTime(), PROGRAM, principal_name);
@@ -396,17 +417,17 @@ krb5_create_cache(char *domain)
                 code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
                 if (code) {
-                    debug((char *) "%s| %s: DEBUG: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while initialising credentials from keytab" ,code);
                     goto loop_end;
                 }
                 code = krb5_cc_initialize(kparam.context, kparam.cc[ccindex], principal_list[i]);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while initializing memory caches : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while initialising memory caches" ,code);
                     goto loop_end;
                 }
                 code = krb5_cc_store_cred(kparam.context, kparam.cc[ccindex], creds);
                 if (code) {
-                    debug((char *) "%s| %s: DEBUG: Error while storing credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while storing credentials" ,code);
                     goto loop_end;
                 }
                 if (creds->server)
@@ -421,12 +442,12 @@ krb5_create_cache(char *domain)
                 code = krb5_parse_name(kparam.context, service, &creds->server);
                 xfree(service);
                 if (code) {
-                    error((char *) "%s| %s: ERROR: Error while initialising TGT credentials : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while initialising TGT credentials" ,code);
                     goto loop_end;
                 }
                 code = krb5_get_credentials(kparam.context, 0, kparam.cc[ccindex], creds, &tgt_creds);
                 if (code) {
-                    debug((char *) "%s| %s: DEBUG: Error while getting tgt : %s\n", LogTime(), PROGRAM, error_message(code));
+                    k5_error("Error while getting tgt" ,code);
                     goto loop_end;
                 } else {
                     debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
@@ -458,7 +479,7 @@ krb5_create_cache(char *domain)
          */
         code = krb5_unparse_name(kparam.context, principal, &principal_name);
         if (code) {
-            debug((char *) "%s| %s: DEBUG: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
+            k5_error("Error while unparsing principal name" ,code);
             retval = 1;
             goto cleanup;
         }
@@ -121,6 +121,11 @@ The Squid Configuration Manual http://www.squid-cache.org/Doc/config/
 #
 use vars qw/ %opt /;
 
+my $user;
+my $group;
+my @groups;
+my $ans;
+
 # Disable output buffering
 $|=1;
 
@@ -132,7 +137,11 @@ sub debug {
 # Check if a user belongs to a group
 #
 sub check {
-        local($user, $group) = @_;
+	my $groupSID;
+	my $groupGID;
+	my @tmpuser;
+
+	our($user, $group) = @_;
 	if ($opt{K} && ($user =~ m/\@/)) {
 		@tmpuser = split(/\@/, $user);
 		$user = "$tmpuser[1]\\$tmpuser[0]";
@@ -105,7 +105,7 @@ gethost_name(void)
         return NULL;
     }
     rc = getaddrinfo(hostname, NULL, NULL, &hres);
-    if (rc != 0) {
+    if (rc != 0 || hres == NULL ) {
         debug((char *) "%s| %s: ERROR: resolving hostname with getaddrinfo: %s failed\n",
               LogTime(), PROGRAM, gai_strerror(rc));
         fprintf(stderr,
@@ -339,10 +339,8 @@ main(int argc, char *const argv[])
     gss_buffer_desc type_id = GSS_C_EMPTY_BUFFER;
 #endif
 #endif
-#if HAVE_PAC_SUPPORT || HAVE_KRB5_MEMORY_KEYTAB
     krb5_context context = NULL;
     krb5_error_code ret;
-#endif
     long length = 0;
     static int err = 0;
     int opt, log = 0, norealm = 0;
@@ -352,6 +350,7 @@ main(int argc, char *const argv[])
     char *service_principal = NULL;
     char *keytab_name = NULL;
     char *keytab_name_env = NULL;
+    char default_keytab[MAXPATHLEN];
 #if HAVE_KRB5_MEMORY_KEYTAB
     char *memory_keytab_name = NULL;
 #endif
@@ -536,9 +535,14 @@ main(int argc, char *const argv[])
         putenv(keytab_name_env);
     } else {
         keytab_name_env = getenv("KRB5_KTNAME");
-        if (!keytab_name_env)
-            keytab_name = xstrdup("/etc/krb5.keytab");
-        else
+        if (!keytab_name_env) {
+            ret = krb5_init_context(&context);
+            if (!check_k5_err(context, "krb5_init_context", ret)) {
+                krb5_kt_default_name(context, default_keytab, MAXPATHLEN);
+            }
+            keytab_name = default_keytab;
+            krb5_free_context(context);
+        } else
             keytab_name = xstrdup(keytab_name_env);
     }
     debug((char *) "%s| %s: INFO: Setting keytab to %s\n", LogTime(), PROGRAM, keytab_name);
@@ -40,7 +40,7 @@
 
 #include "negotiate_kerberos.h"
 
-#if HAVE_PAC_SUPPORT
+#if HAVE_GSSAPI && HAVE_PAC_SUPPORT
 
 static int bpos;
 static krb5_data *ad_data;
@@ -141,9 +141,9 @@ pstrcat( char *src, const char *dst)
 int
 checkustr(RPC_UNICODE_STRING *string)
 {
-    uint32_t size,off,len;
 
     if (string->pointer != 0) {
+        uint32_t size,off,len;
         align(4);
         size = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
         bpos = bpos+4;
@@ -168,7 +168,6 @@ getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
 {
     if (GroupIds!= 0) {
         uint32_t ngroup;
-        uint32_t sauth;
         int l;
 
         align(4);
@@ -182,6 +181,7 @@ getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
 
         Rids=(char **)xcalloc(GroupCount*sizeof(char*),1);
         for ( l=0; l<(int)GroupCount; l++) {
+            uint32_t sauth;
             Rids[l]=(char *)xcalloc(4*sizeof(char),1);
             memcpy((void *)Rids[l],(void *)&p[bpos],4);
             sauth = get4byt();
@@ -196,11 +196,16 @@ getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
 char *
 getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t GroupCount)
 {
+    if (!ad_groups) {
+        debug((char *) "%s| %s: ERR: No space to store groups\n",
+              LogTime(), PROGRAM);
+        return NULL;
+    }
+
     if (DomainLogonId!= 0) {
         uint32_t nauth;
         uint8_t rev;
         uint64_t idauth;
-        uint32_t sauth;
         char dli[256];
         char *ag;
         size_t length;
@@ -251,6 +256,7 @@ getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t Gro
 
         snprintf(dli,sizeof(dli),"S-%d-%lu",rev,(long unsigned int)idauth);
         for ( l=0; l<(int)nauth; l++ ) {
+            uint32_t sauth;
             sauth = get4byt();
             snprintf((char *)&dli[strlen(dli)],sizeof(dli)-strlen(dli),"-%u",sauth);
         }
@@ -286,23 +292,23 @@ getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
 
         for ( l=0; l<(int)SidCount; l++ ) {
             char es[256];
-            uint32_t nauth;
-            uint8_t rev;
-            uint64_t idauth;
-            uint32_t sauth;
-            int k;
 
             if (pa[l] != 0) {
+                uint32_t nauth;
+                uint8_t rev;
+                uint64_t idauth;
+
                 nauth = get4byt();
 
                 length = 1+1+6+nauth*4;
                 ag = (char *)xcalloc((length)*sizeof(char),1);
                 memcpy((void *)ag,(const void*)&p[bpos],length);
                 if (!ad_groups) {
-                    if (!pstrcpy(ad_groups,"group=")) {
-                        debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
-                              LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
-                    }
+                    debug((char *) "%s| %s: ERR: No space to store groups\n",
+                          LogTime(), PROGRAM);
+                    xfree(pa);
+                    xfree(ag);
+                    return NULL;
                 } else {
                     if (!pstrcat(ad_groups," group=")) {
                         debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
@@ -328,7 +334,8 @@ getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
                 idauth = get6byt_be();
 
                 snprintf(es,sizeof(es),"S-%d-%lu",rev,(long unsigned int)idauth);
-                for ( k=0; k<(int)nauth; k++ ) {
+                for (int k=0; k<(int)nauth; k++ ) {
+                    uint32_t sauth;
                     sauth = get4byt();
                     snprintf((char *)&es[strlen(es)],sizeof(es)-strlen(es),"-%u",sauth);
                 }
@@ -365,6 +372,12 @@ get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac)
     char **Rids=NULL;
     int l=0;
 
+    if (!ad_groups) {
+        debug((char *) "%s| %s: ERR: No space to store groups\n",
+              LogTime(), PROGRAM);
+        return NULL;
+    }
+
     ad_data = (krb5_data *)xcalloc(1,sizeof(krb5_data));
 
 #define KERB_LOGON_INFO 1
@@ -313,7 +313,9 @@ template <class V>
 void
 Splay<V>::remove(Value const &value, SPLAYCMP *compare)
 {
-    assert (find (value, compare));
+    // also catches the head==NULL case
+    if (find(value, compare) == NULL)
+        return;
 
     head = head->remove(value, compare);
 
@@ -9,6 +9,10 @@
 #ifndef SQUID_INCLUDE_UNITTESTMAIN_H
 #define SQUID_INCLUDE_UNITTESTMAIN_H
 
+#if ENABLE_DEBUG_SECTION
+#include "Debug.h"
+#endif /* ENABLE_DEBUG_SECTION */
+
 #include <cppunit/BriefTestProgressListener.h>
 #include <cppunit/TextTestProgressListener.h>
 #include <cppunit/CompilerOutputter.h>
@@ -20,6 +24,10 @@
 int
 main( int argc, char* argv[] )
 {
+#if ENABLE_DEBUG_SECTION
+    Debug::Levels[ENABLE_DEBUG_SECTION] = 99;
+#endif
+
     // Create the event manager and test controller
     CPPUNIT_NS::TestResult controller;
 
@@ -71,31 +71,16 @@ libmiscutil_la_SOURCES = \
 	heap.c \
 	iso3307.c \
 	radix.c \
-	rfc1035.c \
 	rfc1123.c \
-	rfc2671.c \
-	rfc3596.c \
 	$(SNPRINTFSOURCE) \
 	Splay.cc \
 	stub_memaccount.c \
 	util.c \
 	xusleep.c
 
-TESTS += tests/testRFC1035 tests/testRFC1738
+TESTS += tests/testRFC1738
 
-check_PROGRAMS += tests/testRFC1035 tests/testRFC1738
-
-tests_testRFC1035_SOURCES= \
-	tests/testRFC1035.h \
-	tests/testRFC1035.cc
-
-tests_testRFC1035_LDADD= \
-	$(SQUID_CPPUNIT_LA) $(SQUID_CPPUNIT_LIBS) \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(COMPAT_LIB)
-
-tests_testRFC1035_LDFLAGS = $(LIBADD_DL)
+check_PROGRAMS += tests/testRFC1738
 
 tests_testRFC1738_SOURCES= \
 	tests/testRFC1738.h \
@@ -69,6 +69,8 @@
 #include "acl/SourceAsn.h"
 #include "acl/SourceDomain.h"
 #include "acl/SourceIp.h"
+#include "acl/SquidError.h"
+#include "acl/SquidErrorData.h"
 #if USE_OPENSSL
 #include "acl/Certificate.h"
 #include "acl/CertificateData.h"
@@ -218,3 +220,6 @@ ACL::Prototype ACLAdaptationService::RegistryProtoype(&ACLAdaptationService::Reg
 ACLStrategised<const char *> ACLAdaptationService::RegistryEntry_(new ACLAdaptationServiceData, ACLAdaptationServiceStrategy::Instance(), "adaptation_service");
 #endif
 
+ACL::Prototype ACLSquidError::RegistryProtoype(&ACLSquidError::RegistryEntry_, "squid_error");
+ACLStrategised<err_type> ACLSquidError::RegistryEntry_(new ACLSquidErrorData, ACLSquidErrorStrategy::Instance(), "squid_error");
+
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "acl/Gadgets.h"
+#include "CachePeer.h"
+#include "defines.h"
+#include "NeighborTypeDomainList.h"
+#include "pconn.h"
+#include "PeerPoolMgr.h"
+
+CBDATA_CLASS_INIT(CachePeer);
+
+CachePeer::CachePeer() :
+    index(0),
+    name(NULL),
+    host(NULL),
+    type(PEER_NONE),
+    http_port(CACHE_HTTP_PORT),
+    typelist(NULL),
+    access(NULL),
+    weight(1),
+    basetime(0),
+#if USE_CACHE_DIGESTS
+    digest(NULL),
+    digest_url(NULL),
+#endif
+    tcp_up(0),
+    n_addresses(0),
+    rr_count(0),
+    next(NULL),
+    testing_now(false),
+    login(NULL),
+    connect_timeout(0),
+    connect_fail_limit(0),
+    max_conn(0),
+    domain(NULL),
+#if USE_OPENSSL
+    sslContext(NULL),
+    sslSession(NULL),
+#endif
+    front_end_https(0),
+    connection_auth(2 /* auto */)
+{
+    memset(&stats, 0, sizeof(stats));
+    stats.logged_state = PEER_ALIVE;
+
+    memset(&icp, 0, sizeof(icp));
+    icp.port = CACHE_ICP_PORT;
+    icp.version = ICP_VERSION_CURRENT;
+
+#if USE_HTCP
+    memset(&htcp, 0, sizeof(htcp));
+#endif
+    memset(&options, 0, sizeof(options));
+    memset(&mcast, 0, sizeof(mcast));
+    memset(&carp, 0, sizeof(carp));
+#if USE_AUTH
+    memset(&userhash, 0, sizeof(userhash));
+#endif
+    memset(&sourcehash, 0, sizeof(sourcehash));
+
+    standby.pool = NULL;
+    standby.limit = 0;
+    standby.waitingForClose = false;
+}
+
+CachePeer::~CachePeer()
+{
+    xfree(name);
+    xfree(host);
+
+    while (NeighborTypeDomainList *l = typelist) {
+        typelist = l->next;
+        xfree(l->domain);
+        xfree(l);
+    }
+
+    aclDestroyAccessList(&access);
+
+#if USE_CACHE_DIGESTS
+    cbdataReferenceDone(digest);
+    xfree(digest_url);
+#endif
+
+    delete next;
+
+    xfree(login);
+
+    delete standby.pool;
+
+    // the mgr job will notice that its owner is gone and stop
+    PeerPoolMgr::Checkpoint(standby.mgr, "peer gone");
+
+    xfree(domain);
+
+#if USE_OPENSSL
+    if (sslContext)
+        SSL_CTX_free(sslContext);
+
+    if (sslSession)
+        SSL_SESSION_free(sslSession);
+#endif
+}
+
@@ -23,16 +23,19 @@
 #include <openssl/ssl.h>
 #endif
 
-class CachePeerDomainList;
 class NeighborTypeDomainList;
 class PconnPool;
 class PeerDigest;
 class PeerPoolMgr;
 
-// currently a POD
 class CachePeer
 {
+    CBDATA_CLASS(CachePeer);
+
 public:
+    CachePeer();
+    ~CachePeer();
+
     u_int index;
     char *name;
     char *host;
@@ -72,7 +75,6 @@ class CachePeer
 #endif
 
     unsigned short http_port;
-    CachePeerDomainList *peer_domain;
     NeighborTypeDomainList *typelist;
     acl_access *access;
 
@@ -11,6 +11,7 @@
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "dns/forward.h"
 #include "helper/forward.h"
 #include "ipcache.h"
 
@@ -20,7 +21,6 @@
 
 class ACLChecklist;
 class ClientHttpRequest;
-class DnsLookupDetails;
 class ErrorState;
 
 class ClientRequestContext : public RefCountable
@@ -33,7 +33,7 @@ class ClientRequestContext : public RefCountable
 
     bool httpStateIsValid();
     void hostHeaderVerify();
-    void hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLookupDetails &dns);
+    void hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns);
     void hostHeaderVerifyFailed(const char *A, const char *B);
     void clientAccessCheck();
     void clientAccessCheck2();
@@ -88,7 +88,12 @@ extern FILE *debug_log;
 size_t BuildPrefixInit();
 const char * SkipBuildPrefix(const char* path);
 
-/* Debug stream */
+/* Debug stream
+ *
+ * Unit tests can enable full debugging to stderr for one
+ * debug section; to enable this, #define ENABLE_DEBUG_SECTION to the
+ * section number before any header
+ */
 #define debugs(SECTION, LEVEL, CONTENT) \
    do { \
         if ((Debug::level = (LEVEL)) <= Debug::Levels[SECTION]) { \
@@ -13,11 +13,9 @@
 #include "base/RefCount.h"
 
 class external_acl;
+class external_acl_data;
 class StoreEntry;
 
-/** \todo CLEANUP: kill this typedef. */
-typedef struct _external_acl_data external_acl_data;
-
 class ExternalACLLookup : public ACLChecklist::AsyncState
 {
 
@@ -10,7 +10,7 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "acl/AclAddress.h"
+#include "acl/Address.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
@@ -1197,9 +1197,7 @@ FwdState::logReplyStatus(int tries, const Http::StatusCode status)
 tos_t
 aclMapTOS(acl_tos * head, ACLChecklist * ch)
 {
-    acl_tos *l;
-
-    for (l = head; l; l = l->next) {
+    for (acl_tos *l = head; l; l = l->next) {
         if (!l->aclList || ch->fastCheck(l->aclList) == ACCESS_ALLOWED)
             return l->tos;
     }
@@ -1211,9 +1209,7 @@ aclMapTOS(acl_tos * head, ACLChecklist * ch)
 nfmark_t
 aclMapNfmark(acl_nfmark * head, ACLChecklist * ch)
 {
-    acl_nfmark *l;
-
-    for (l = head; l; l = l->next) {
+    for (acl_nfmark *l = head; l; l = l->next) {
         if (!l->aclList || ch->fastCheck(l->aclList) == ACCESS_ALLOWED)
             return l->nfmark;
     }
@@ -1259,8 +1255,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     // TODO use the connection details in ACL.
     // needs a bit of rework in ACLFilledChecklist to use Comm::Connection instead of ConnStateData
 
-    AclAddress *l;
-    for (l = Config.accessList.outgoing_address; l; l = l->next) {
+    for (Acl::Address *l = Config.accessList.outgoing_address; l; l = l->next) {
 
         /* check if the outgoing address is usable to the destination */
         if (conn->remote.isIPv4() != l->addr.isIPv4()) continue;
@@ -13,7 +13,7 @@
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
-#include "DnsLookupDetails.h"
+#include "dns/LookupDetails.h"
 #include "err_detail_type.h"
 #include "globals.h"
 #include "gopher.h"
@@ -616,7 +616,7 @@ HttpRequest::conditional() const
 }
 
 void
-HttpRequest::recordLookup(const DnsLookupDetails &dns)
+HttpRequest::recordLookup(const Dns::LookupDetails &dns)
 {
     if (dns.wait >= 0) { // known delay
         if (dnsWait >= 0) // have recorded DNS wait before
@@ -11,6 +11,7 @@
 
 #include "base/CbcPointer.h"
 #include "Debug.h"
+#include "dns/forward.h"
 #include "err_type.h"
 #include "HierarchyLogEntry.h"
 #include "http/RequestMethod.h"
@@ -39,7 +40,6 @@ class ConnStateData;
 void httpRequestPack(void *obj, Packer *p);
 
 class HttpHdrRange;
-class DnsLookupDetails;
 
 class HttpRequest: public HttpMsg
 {
@@ -100,7 +100,7 @@ class HttpRequest: public HttpMsg
     Adaptation::Icap::History::Pointer icapHistory() const;
 #endif
 
-    void recordLookup(const DnsLookupDetails &detail);
+    void recordLookup(const Dns::LookupDetails &detail);
 
     /// sets error detail if no earlier detail was available
     void detailError(err_type aType, int aDetail);
@@ -10,10 +10,7 @@ include $(top_srcdir)/src/Common.am
 AUTOMAKE_OPTIONS = subdir-objects
 
 DNSSOURCE = \
-	dns_internal.cc \
-	SquidDns.h \
-	DnsLookupDetails.h \
-	DnsLookupDetails.cc
+	dns_internal.cc
 
 SBUF_SOURCE= \
 	base/CharacterSet.h \
@@ -47,8 +44,8 @@ LOADABLE_MODULES_SOURCES = \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS	= mem base anyp helper ftp parser comm eui acl format clients servers fs repl
-DIST_SUBDIRS = mem base anyp helper ftp parser comm eui acl format clients servers fs repl
+SUBDIRS	= mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl
+DIST_SUBDIRS = mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl
 
 if ENABLE_AUTH
 SUBDIRS += auth
@@ -287,7 +284,7 @@ squid_SOURCES = \
 	CacheDigest.cc \
 	cache_manager.cc \
 	NeighborTypeDomainList.h \
-	CachePeerDomainList.h \
+	CachePeer.cc \
 	CachePeer.h \
 	CacheManager.h \
 	carp.h \
@@ -613,6 +610,7 @@ squid_LDADD = \
 	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
+	dns/libdns.la \
 	security/libsecurity.la \
 	base/libbase.la \
 	libsquid.la \
@@ -1059,6 +1057,7 @@ check_PROGRAMS+=\
 	tests/testBoilerplate \
 	tests/testCacheManager \
 	tests/testDiskIO \
+	tests/testDns \
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
@@ -1401,6 +1400,8 @@ tests_testCacheManager_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	carp.h \
@@ -1587,6 +1588,7 @@ tests_testCacheManager_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -1769,7 +1771,6 @@ tests_testDiskIO_LDADD = \
 	parser/libsquid-parser.la \
 	SquidConfig.o \
 	CommCalls.o \
-	DnsLookupDetails.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
@@ -1785,6 +1786,7 @@ tests_testDiskIO_LDADD = \
 	mgr/libmgr.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
+	dns/libdns.la \
 	base/libbase.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -1803,7 +1805,23 @@ tests_testDiskIO_DEPENDENCIES = \
 	$(SWAP_TEST_DS) \
 	$(SQUID_CPPUNIT_LA)
 
-## Tests of the Even module.
+tests_testDns_SOURCES= \
+	tests/testRFC1035.cc \
+	tests/testRFC1035.h
+nodist_tests_testDns_SOURCES= \
+	tests/stub_debug.cc \
+	tests/stub_SBuf.cc \
+	tests/stub_tools.cc
+tests_testDns_LDADD= \
+	dns/libdns.la \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS) \
+	$(SQUID_CPPUNIT_LA) \
+	$(SQUID_CPPUNIT_LIBS)
+tests_testDns_LDFLAGS= $(LIBADD_DL)
+
 tests_testEvent_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
@@ -1815,6 +1833,8 @@ tests_testEvent_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	cache_manager.cc \
 	carp.h \
 	tests/stub_carp.cc \
@@ -2014,6 +2034,7 @@ tests_testEvent_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2060,6 +2081,8 @@ tests_testEventLoop_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
@@ -2257,6 +2280,7 @@ tests_testEventLoop_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2299,6 +2323,8 @@ tests_test_http_range_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	cache_manager.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
@@ -2510,6 +2536,7 @@ tests_test_http_range_LDADD = \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
+	dns/libdns.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -2606,6 +2633,8 @@ tests_testHttpRequest_SOURCES = \
 	debug.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
@@ -2787,6 +2816,7 @@ tests_testHttpRequest_LDADD = \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	parser/libsquid-parser.la \
+	dns/libdns.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
@@ -2965,6 +2995,7 @@ tests_testStore_LDADD= \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2980,7 +3011,6 @@ tests_testStore_LDADD= \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
-	DnsLookupDetails.o \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testStore_LDFLAGS = $(LIBADD_DL)
@@ -3187,7 +3217,6 @@ tests_testUfs_LDADD = \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	CommCalls.o \
-	DnsLookupDetails.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
@@ -3205,6 +3234,7 @@ tests_testUfs_LDADD = \
 	ipc/libipc.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	mem/libmem.la \
@@ -3413,6 +3443,8 @@ tests_testURL_SOURCES = \
 	tests/stub_cache_manager.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
@@ -3612,6 +3644,7 @@ tests_testURL_LDADD = \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -44,7 +44,12 @@ class store_client;
 
 class DigestFetchState
 {
+    CBDATA_CLASS(DigestFetchState);
+
 public:
+    DigestFetchState(PeerDigest *,HttpRequest *);
+    ~DigestFetchState();
+
     PeerDigest *pd;
     StoreEntry *entry;
     StoreEntry *old_entry;
@@ -60,9 +65,8 @@ class DigestFetchState
     struct {
         int msg;
         int bytes;
-    }
+    } sent, recv;
 
-    sent, recv;
     char buf[SM_PAGE_SIZE];
     ssize_t bufofs;
     digest_read_state_t state;
@@ -34,10 +34,16 @@ class RefreshPattern
         bool ignore_no_store;
         bool ignore_must_revalidate;
         bool ignore_private;
-        bool ignore_auth;
 #endif
     } flags;
     int max_stale;
+
+    // statistics about how many matches this pattern has had
+    mutable struct stats_ {
+        uint64_t matchTests;
+        uint64_t matchCount;
+        // TODO: some stats to indicate how useful/less the flags are would be nice.
+    } stats;
 };
 
 #endif /* SQUID_REFRESHPATTERN_H_ */
@@ -37,7 +37,7 @@ const SBuf::size_type SBuf::maxSize;
 
 SBufStats::SBufStats()
     : alloc(0), allocCopy(0), allocFromString(0), allocFromCString(0),
-      assignFast(0), clear(0), append(0), toStream(0), setChar(0),
+      assignFast(0), clear(0), append(0), moves(0), toStream(0), setChar(0),
       getChar(0), compareSlow(0), compareFast(0), copyOut(0),
       rawAccess(0), nulTerminate(0), chop(0), trim(0), find(0), scanf(0),
       caseChange(0), cowFast(0), cowSlow(0), live(0)
@@ -53,6 +53,7 @@ SBufStats::operator +=(const SBufStats& ss)
     assignFast += ss.assignFast;
     clear += ss.clear;
     append += ss.append;
+    moves += ss.moves;
     toStream += ss.toStream;
     setChar += ss.setChar;
     getChar += ss.getChar;
@@ -119,6 +120,15 @@ SBuf::SBuf(const char *S, size_type n)
     ++stats.live;
 }
 
+SBuf::SBuf(const char *S)
+    : store_(GetStorePrototype()), off_(0), len_(0)
+{
+    append(S,npos);
+    ++stats.alloc;
+    ++stats.allocFromCString;
+    ++stats.live;
+}
+
 SBuf::~SBuf()
 {
     debugs(24, 8, id << " destructed");
@@ -365,23 +375,37 @@ memcasecmp(const char *b1, const char *b2, SBuf::size_type len)
 int
 SBuf::compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n) const
 {
-    if (n != npos)
+    if (n != npos) {
+        debugs(24, 8, "length specified. substr and recurse");
         return substr(0,n).compare(S.substr(0,n),isCaseSensitive);
+    }
 
     const size_type byteCompareLen = min(S.length(), length());
     ++stats.compareSlow;
     int rv = 0;
+    debugs(24, 8, "comparing length " << byteCompareLen);
     if (isCaseSensitive == caseSensitive) {
         rv = memcmp(buf(), S.buf(), byteCompareLen);
     } else {
         rv = memcasecmp(buf(), S.buf(), byteCompareLen);
     }
-    if (rv != 0)
+    if (rv != 0) {
+        debugs(24, 8, "result: " << rv);
         return rv;
-    if (length() == S.length())
+    }
+    if (n <= length() || n <= S.length()) {
+        debugs(24, 8, "same contents and bounded length. Equal");
+        return 0;
+    }
+    if (length() == S.length()) {
+        debugs(24, 8, "same contents and same length. Equal");
         return 0;
-    if (length() > S.length())
+    }
+    if (length() > S.length()) {
+        debugs(24, 8, "lhs is longer than rhs. Result is 1");
         return 1;
+    }
+    debugs(24, 8, "rhs is longer than lhs. Result is -1");
     return -1;
 }
 
@@ -630,17 +654,17 @@ SBuf::find(const SBuf &needle, size_type startPos) const
 
     ++stats.find;
 
-    char *begin = buf()+startPos;
+    char *start = buf()+startPos;
     char *lastPossible = buf()+length()-needle.length()+1;
     char needleBegin = needle[0];
 
     debugs(24, 7, "looking for " << needle << "starting at " << startPos <<
            " in id " << id);
-    while (begin < lastPossible) {
+    while (start < lastPossible) {
         char *tmp;
-        debugs(24, 8, " begin=" << (void *) begin <<
+        debugs(24, 8, " begin=" << (void *) start <<
                ", lastPossible=" << (void*) lastPossible );
-        tmp = static_cast<char *>(memchr(begin, needleBegin, lastPossible-begin));
+        tmp = static_cast<char *>(memchr(start, needleBegin, lastPossible-start));
         if (tmp == NULL) {
             debugs(24, 8 , "First byte not found");
             return npos;
@@ -650,7 +674,7 @@ SBuf::find(const SBuf &needle, size_type startPos) const
             debugs(24, 8, "Found at " << (tmp-buf()));
             return (tmp-buf());
         }
-        begin = tmp+1;
+        start = tmp+1;
     }
     debugs(24, 8, "not found");
     return npos;
@@ -736,8 +760,8 @@ SBuf::findFirstOf(const CharacterSet &set, size_type startPos) const
 
     debugs(24, 7, "first of characterset " << set.name << " in id " << id);
     char *cur = buf()+startPos;
-    const char *end = bufEnd();
-    while (cur < end) {
+    const char *bufend = bufEnd();
+    while (cur < bufend) {
         if (set[*cur])
             return cur-buf();
         ++cur;
@@ -759,8 +783,8 @@ SBuf::findFirstNotOf(const CharacterSet &set, size_type startPos) const
 
     debugs(24, 7, "first not of characterset " << set.name << " in id " << id);
     char *cur = buf()+startPos;
-    const char *end = bufEnd();
-    while (cur < end) {
+    const char *bufend = bufEnd();
+    while (cur < bufend) {
         if (!set[*cur])
             return cur-buf();
         ++cur;
@@ -799,6 +823,7 @@ SBufStats::dump(std::ostream& os) const
        "\nno-copy assignments: " << assignFast <<
        "\nclearing operations: " << clear <<
        "\nappend operations: " << append <<
+       "\nmove operations: " << moves <<
        "\ndump-to-ostream: " << toStream <<
        "\nset-char: " << setChar <<
        "\nget-char: " << getChar <<
@@ -6,6 +6,8 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
+/* DEBUG: section 24    SBuf */
+
 #ifndef SQUID_SBUF_H
 #define SQUID_SBUF_H
 
@@ -17,6 +19,7 @@
 #include <climits>
 #include <cstdarg>
 #include <iosfwd>
+#include <iterator>
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -50,6 +53,7 @@ class SBufStats
     uint64_t assignFast; ///<number of no-copy assignment operations
     uint64_t clear; ///<number of clear operations
     uint64_t append; ///<number of append operations
+    uint64_t moves; ///<number of move constructions/assignments
     uint64_t toStream;  ///<number of write operations to ostreams
     uint64_t setChar; ///<number of calls to setAt
     uint64_t getChar; ///<number of calls to at() and operator[]
@@ -75,6 +79,44 @@ class SBufStats
 };
 
 class CharacterSet;
+class SBuf;
+
+/** Forward input iterator for SBufs
+ *
+ * Please note that any operation on the underlying SBuf may invalidate
+ * all iterators over it, resulting in undefined behavior by them.
+ */
+class SBufIterator : public std::iterator<std::input_iterator_tag, char>
+{
+public:
+    friend class SBuf;
+    typedef MemBlob::size_type size_type;
+    bool operator==(const SBufIterator &s) const;
+    bool operator!=(const SBufIterator &s) const;
+
+    char operator*() const { return *iter; }
+    SBufIterator& operator++() { ++iter; return *this; }
+
+protected:
+    SBufIterator(const SBuf &, size_type);
+
+    const char *iter;
+};
+
+/** Reverse input iterator for SBufs
+ *
+ * Please note that any operation on the underlying SBuf may invalidate
+ * all iterators over it, resulting in undefined behavior by them.
+ */
+class SBufReverseIterator : public SBufIterator
+{
+    friend class SBuf;
+public:
+    SBufReverseIterator& operator++() { --iter; return *this;}
+    char operator*() const { return *(iter-1); }
+protected:
+    SBufReverseIterator(const SBuf &s, size_type sz) : SBufIterator(s,sz) {}
+};
 
 /**
  * A String or Buffer.
@@ -86,6 +128,8 @@ class SBuf
 {
 public:
     typedef MemBlob::size_type size_type;
+    typedef SBufIterator iterator;
+    typedef SBufReverseIterator reverse_iterator;
     static const size_type npos = 0xffffffff; // max(uint32_t)
 
     /// Maximum size of a SBuf. By design it MUST be < MAX(size_type)/2. Currently 256Mb.
@@ -94,6 +138,12 @@ class SBuf
     /// create an empty (zero-size) SBuf
     SBuf();
     SBuf(const SBuf &S);
+    SBuf(SBuf&& S) : store_(std::move(S.store_)), off_(S.off_), len_(S.len_) {
+        ++stats.moves;
+        S.store_=NULL;
+        S.off_=0;
+        S.len_=0; //RefCount supports NULL
+    }
 
     /** Constructor: import c-style string
      *
@@ -105,7 +155,8 @@ class SBuf
      * \note it is the caller's responsibility not to go out of bounds
      * \note bounds is 0 <= pos < length(); caller must pay attention to signedness
      */
-    explicit SBuf(const char *S, size_type n = npos);
+    explicit SBuf(const char *S, size_type n);
+    explicit SBuf(const char *S);
 
     /** Constructor: import SquidString, copying contents.
      *
@@ -129,6 +180,18 @@ class SBuf
      * Current SBuf will share backing store with the assigned one.
      */
     SBuf& operator =(const SBuf & S) {return assign(S);}
+    SBuf& operator =(SBuf &&S) {
+        ++stats.moves;
+        if (this != &S) {
+            store_ = std::move(S.store_);
+            off_ = S.off_;
+            len_ = S.len_;
+            S.store_ = NULL; //RefCount supports NULL, and S is about to be destructed
+            S.off_ = 0;
+            S.len_ = 0;
+        }
+        return *this;
+    }
 
     /** Import a c-string into a SBuf, copying the data.
      *
@@ -140,7 +203,8 @@ class SBuf
      * \note to assign a std::string use the pattern:
      *    assign(stdstr.data(), stdstd.length())
      */
-    SBuf& assign(const char *S, size_type n = npos);
+    SBuf& assign(const char *S, size_type n);
+    SBuf& assign(const char *S) {return assign(S,npos);}
 
     /** Assignment operator. Copy a NULL-terminated c-style string into a SBuf.
      *
@@ -177,7 +241,8 @@ class SBuf
      * \note to append a std::string use the pattern
      *     cstr_append(stdstr.data(), stdstd.length())
      */
-    SBuf& append(const char * S, size_type Ssize = npos);
+    SBuf& append(const char * S, size_type Ssize);
+    SBuf& append(const char * S) { return append(S,npos); }
 
     /** Assignment operation with printf(3)-style definition
      * \note arguments may be evaluated more than once, be careful
@@ -238,30 +303,48 @@ class SBuf
      * \retval <0 argument of the call is smaller than called SBuf
      * \retval 0  argument of the call has the same contents of called SBuf
      */
-    int compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n = npos) const;
+    int compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n) const;
+    int compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive) const {
+        return compare(S, isCaseSensitive, npos);
+    }
 
     /// shorthand version for compare()
-    inline int cmp(const SBuf &S, const size_type n = npos) const {
+    inline int cmp(const SBuf &S, const size_type n) const {
         return compare(S,caseSensitive,n);
     }
+    inline int cmp(const SBuf &S) const {
+        return compare(S,caseSensitive,npos);
+    }
 
     /// shorthand version for case-insensitive compare()
-    inline int caseCmp(const SBuf &S, const size_type n = npos) const {
+    inline int caseCmp(const SBuf &S, const size_type n) const {
         return compare(S,caseInsensitive,n);
     }
+    inline int caseCmp(const SBuf &S) const {
+        return compare(S,caseInsensitive,npos);
+    }
 
     /// Comparison with a C-string.
-    int compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n = npos) const;
+    int compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n) const;
+    int compare(const char *s, const SBufCaseSensitive isCaseSensitive) const {
+        return compare(s,isCaseSensitive,npos);
+    }
 
     /// Shorthand version for C-string compare().
-    inline int cmp(const char *S, const size_type n = npos) const {
+    inline int cmp(const char *S, const size_type n) const {
         return compare(S,caseSensitive,n);
     }
+    inline int cmp(const char *S) const {
+        return compare(S,caseSensitive,npos);
+    }
 
     /// Shorthand version for case-insensitive C-string compare().
-    inline int caseCmp(const char *S, const size_type n = npos) const {
+    inline int caseCmp(const char *S, const size_type n) const {
         return compare(S,caseInsensitive,n);
     }
+    inline int caseCmp(const char *S) const {
+        return compare(S,caseInsensitive,npos);
+    }
 
     /** check whether the entire supplied argument is a prefix of the SBuf.
      *  \param S the prefix to match against
@@ -541,6 +624,22 @@ class SBuf
     /// std::string export function
     std::string toStdString() const { return std::string(buf(),length()); }
 
+    iterator begin() {
+        return iterator(*this, 0);
+    }
+
+    iterator end() {
+        return iterator(*this, length());
+    }
+
+    reverse_iterator rbegin() {
+        return reverse_iterator(*this, length());
+    }
+
+    reverse_iterator rend() {
+        return reverse_iterator(*this, 0);
+    }
+
     // TODO: possibly implement erase() similar to std::string's erase
     // TODO: possibly implement a replace() call
 private:
@@ -619,5 +718,24 @@ ToLower(SBuf buf)
     return buf;
 }
 
+inline
+SBufIterator::SBufIterator(const SBuf &s, size_type pos)
+    : iter(s.rawContent()+pos)
+{}
+
+inline bool
+SBufIterator::operator==(const SBufIterator &s) const
+{
+    // note: maybe the sbuf comparison is unnecessary?
+    return iter == s.iter;
+}
+
+inline bool
+SBufIterator::operator!=(const SBufIterator &s) const
+{
+    // note: maybe the sbuf comparison is unnecessary?
+    return iter != s.iter;
+}
+
 #endif /* SQUID_SBUF_H */
 
@@ -92,6 +92,7 @@ class SquidConfig
         time_t pconnLifetime; ///< pconn_lifetime in squid.conf
         time_t siteSelect;
         time_t deadPeer;
+        time_t request_start_timeout;
         int icp_query;      /* msec */
         int icp_query_max;  /* msec */
         int icp_query_min;  /* msec */
@@ -102,7 +103,6 @@ class SquidConfig
     } Timeout;
     size_t maxRequestHeaderSize;
     int64_t maxRequestBodySize;
-    int64_t maxChunkedRequestBodySize;
     size_t maxRequestBufferSize;
     size_t maxReplyHeaderSize;
     AclSizeLimit *ReplyBodySize;
@@ -357,7 +357,7 @@ class SquidConfig
         acl_access *redirector;
         acl_access *store_id;
         acl_access *reply;
-        AclAddress *outgoing_address;
+        Acl::Address *outgoing_address;
 #if USE_HTCP
 
         acl_access *htcp;
@@ -377,6 +377,7 @@ class SquidConfig
         /// spoof_client_ip squid.conf acl.
         /// nil unless configured
         acl_access* spoof_client_ip;
+        acl_access *on_unsupported_protocol;
 
         acl_access *ftp_epsv;
 
@@ -14,7 +14,7 @@ TESTS += testHeaders
 ## .h dependency test script
 ## aborts build process on errors; XXX: even with "make -k"
 testHeaders: $(srcdir)/*.h
-	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "$(srcdir)" || exit 1
+	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" $^ || exit 1
 
 ## XXX: this is only needed because testheaders.sh creates a dummy file called
 ## testHeaders and distclean does not know about it.
@@ -7,7 +7,14 @@
  */
 
 #include "squid.h"
-#include "AclAddress.h"
+#include "acl/AclSizeLimit.h"
+#include "acl/Gadgets.h"
 
-//TODO: fill in
+CBDATA_CLASS_INIT(AclSizeLimit);
+
+AclSizeLimit::~AclSizeLimit()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
 
@@ -10,12 +10,17 @@
 #define SQUID_ACLSIZELIMIT_H_
 
 #include "acl/forward.h"
+#include "cbdata.h"
 
 /// representation of a class of Size-limit ACLs
-// a POD. TODO: convert to new ACL framework
 class AclSizeLimit
 {
+    CBDATA_CLASS(AclSizeLimit);
+
 public:
+    AclSizeLimit() : next(NULL), aclList(NULL), size(0) {}
+    ~AclSizeLimit();
+
     AclSizeLimit *next;
     ACLList *aclList;
     int64_t size;
@@ -6,17 +6,15 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_CACHEPEERDOMAINLIST_H_
-#define SQUID_CACHEPEERDOMAINLIST_H_
+#include "squid.h"
+#include "acl/Address.h"
+#include "acl/Gadgets.h"
 
-/// representation of the cache_peer_domain list. POD.
-class CachePeerDomainList
-{
-public:
-    char *domain;
-    bool do_ping;
-    CachePeerDomainList *next;
-};
+CBDATA_NAMESPACED_CLASS_INIT(Acl, Address);
 
-#endif /* SQUID_CACHEPEERDOMAINLIST_H_ */
+Acl::Address::~Address()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
 
@@ -6,21 +6,31 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef ACLADDRESS_H_
-#define ACLADDRESS_H_
+#ifndef _SQUID_SRC_ACL_ADDRESS_H_
+#define _SQUID_SRC_ACL_ADDRESS_H_
 
 #include "acl/Acl.h"
 #include "ip/Address.h"
 
+namespace Acl
+{
+
 /// list of address-based ACLs.
-class AclAddress
+class Address
 {
+    CBDATA_CLASS(Address);
+
 public:
-    AclAddress *next;
+    Address() : next(NULL), aclList(NULL) {}
+    ~Address();
+
+    Acl::Address *next;
     ACLList *aclList;
 
     Ip::Address addr;
 };
 
-#endif /* ACLADDRESS_H_ */
+} // namespace Acl
+
+#endif /* _SQUID_SRC_ACL_ADDRESS_H_ */
 
@@ -14,7 +14,6 @@
 
 #include "acl/Arp.h"
 #include "acl/FilledChecklist.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "eui/Eui48.h"
 #include "globals.h"
@@ -82,14 +81,14 @@ aclParseArpData(const char *t)
 
     if (sscanf(t, "%[0-9a-fA-F:]", buf) != 1) {
         debugs(28, DBG_CRITICAL, "aclParseArpData: Bad ethernet address: '" << t << "'");
-        safe_free(q);
+        delete q;
         return NULL;
     }
 
     if (!q->decode(buf)) {
         debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseArpData: Ignoring invalid ARP acl entry: can't parse '" << buf << "'");
-        safe_free(q);
+        delete q;
         return NULL;
     }
 
@@ -102,17 +101,12 @@ aclParseArpData(const char *t)
 void
 ACLARP::parse()
 {
-    char *t = NULL;
-    Eui::Eui48 *q = NULL;
-
-    while ((t = strtokFile())) {
-        if ((q = aclParseArpData(t)) == NULL)
-            continue;
-
-        aclArpData.insert(*q);
-        safe_free(q);
+    while (const char *t = ConfigParser::strtokFile()) {
+        if (Eui::Eui48 *q = aclParseArpData(t)) {
+            aclArpData.insert(*q);
+            delete q;
+        }
     }
-
 }
 
 int
@@ -135,7 +129,7 @@ SBufList
 ACLARP::dump() const
 {
     SBufList sl;
-    for (auto i = aclArpData.cbegin(); i != aclArpData.cend(); ++i) {
+    for (auto i = aclArpData.begin(); i != aclArpData.end(); ++i) {
         char buf[48];
         i->encode(buf,48);
         sl.push_back(SBuf(buf));
@@ -15,7 +15,6 @@
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
-#include "cache_cf.h"
 #include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -26,7 +25,6 @@
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
-#include "StoreClient.h"
 
 #define WHOIS_PORT 43
 #define AS_REQBUF_SZ    4096
@@ -559,7 +557,7 @@ ACLASN::parse()
     char *t = NULL;
 
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
-    while ((t = strtokFile())) {
+    while ((t = ConfigParser::strtokFile())) {
         q = new CbDataList<int> (atoi(t));
         *(Tail) = q;
         Tail = &q->next;
@@ -13,6 +13,7 @@
 #include "acl/AtStepData.h"
 #include "acl/Checklist.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -53,7 +54,7 @@ ACLAtStepData::dump() const
 void
 ACLAtStepData::parse()
 {
-    while (const char *t = strtokFile()) {
+    while (const char *t = ConfigParser::strtokFile()) {
         if (strcasecmp(t, "SslBump1") == 0) {
             values.push_back(Ssl::bumpStep1);
         } else if (strcasecmp(t, "SslBump2") == 0) {
@@ -12,6 +12,7 @@
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -78,15 +79,21 @@ ACLCertificateData::dump() const
     if (validAttributesStr)
         sl.push_back(SBuf(attribute));
 
+#if __cplusplus >= 201103L
     sl.splice(sl.end(),values.dump());
+#else
+    // temp is needed until c++11 move constructor
+    SBufList tmp = values.dump();
+    sl.splice(sl.end(),tmp);
+#endif
     return sl;
 }
 
 void
 ACLCertificateData::parse()
 {
     if (validAttributesStr) {
-        char *newAttribute = strtokFile();
+        char *newAttribute = ConfigParser::strtokFile();
 
         if (!newAttribute) {
             if (attributeIsOptional)
@@ -33,7 +33,7 @@ DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 }
 
 void
-DestinationDomainLookup::LookupDone(const char *, const DnsLookupDetails &details, void *data)
+DestinationDomainLookup::LookupDone(const char *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markDestinationDomainChecked();
@@ -48,7 +48,7 @@ class DestinationDomainLookup : public ACLChecklist::AsyncState
 
 private:
     static DestinationDomainLookup instance_;
-    static void LookupDone(const char *, const DnsLookupDetails &, void *);
+    static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };
 
 /// \ingroup ACLAPI
@@ -29,6 +29,10 @@ ACLDestinationIP::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
+    // if there is no HTTP request details fallback to the dst_addr
+    if (!checklist->request)
+        return ACLIP::match(checklist->dst_addr);
+
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
@@ -87,7 +91,7 @@ DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 }
 
 void
-DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &details, void *data)
+DestinationIPLookup::LookupDone(const ipcache_addrs *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->request->flags.destinationIpLookedUp = true;
@@ -33,7 +33,6 @@ class ACLDestinationIP : public ACLIP
     ACLDestinationIP(): ACLIP(ACLDestinationIP::SupportedFlags) {}
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
-    virtual bool requiresRequest() const {return true;}
 
     virtual ACL *clone()const;
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/DomainData.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "src/URL.h"
 #include "util.h"
@@ -134,12 +135,10 @@ ACLDomainData::dump() const
 void
 ACLDomainData::parse()
 {
-    char *t = NULL;
-
     if (!domains)
         domains = new Splay<char *>();
 
-    while ((t = strtokFile())) {
+    while (char *t = ConfigParser::strtokFile()) {
         Tolower(t);
         domains->insert(xstrdup(t), aclDomainCompare);
     }
@@ -14,7 +14,6 @@
 
 #include "acl/Eui64.h"
 #include "acl/FilledChecklist.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "eui/Eui64.h"
 #include "globals.h"
@@ -54,14 +53,14 @@ aclParseEuiData(const char *t)
 
     if (sscanf(t, "%[0-9a-fA-F:]", buf) != 1) {
         debugs(28, DBG_CRITICAL, "aclParseEuiData: Bad EUI-64 address: '" << t << "'");
-        safe_free(q);
+        delete q;
         return NULL;
     }
 
     if (!q->decode(buf)) {
         debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseEuiData: Ignoring invalid EUI-64 acl entry: can't parse '" << buf << "'");
-        safe_free(q);
+        delete q;
         return NULL;
     }
 
@@ -74,10 +73,10 @@ aclParseEuiData(const char *t)
 void
 ACLEui64::parse()
 {
-    while (const char * t = strtokFile()) {
+    while (const char * t = ConfigParser::strtokFile()) {
         if (Eui::Eui64 * q = aclParseEuiData(t)) {
             eui64Data.insert(*q);
-            safe_free(q);
+            delete q;
         }
     }
 }
@@ -108,7 +107,7 @@ SBufList
 ACLEui64::dump() const
 {
     SBufList sl;
-    for (auto i = eui64Data.cbegin(); i != eui64Data.end(); ++i) {
+    for (auto i = eui64Data.begin(); i != eui64Data.end(); ++i) {
         static char buf[48];
         i->encode(buf,48);
         sl.push_back(SBuf(buf));
@@ -36,6 +36,7 @@ ACLFilledChecklist::ACLFilledChecklist() :
 #if USE_OPENSSL
     sslErrors(NULL),
 #endif
+    requestErrorType(ERR_MAX),
     conn_(NULL),
     fd_(-1),
     destinationDomainChecked_(false),
@@ -13,6 +13,7 @@
 #include "acl/Checklist.h"
 #include "acl/forward.h"
 #include "base/CbcPointer.h"
+#include "err_type.h"
 #include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -91,6 +92,8 @@ class ACLFilledChecklist: public ACLChecklist
 
     ExternalACLEntryPointer extacl_entry;
 
+    err_type requestErrorType;
+
 private:
     ConnStateData * conn_;          /**< hack for ident and NTLM */
     int fd_;                        /**< may be available when conn_ is not */
@@ -9,7 +9,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/HierCodeData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "fatal.h"
 #include "hier_code.h"
 
@@ -51,7 +51,7 @@ ACLHierCodeData::parse()
 {
     char *t = NULL;
 
-    while ((t = strtokFile())) {
+    while ((t = ConfigParser::strtokFile())) {
         for (hier_code iter = HIER_NONE; iter <= HIER_MAX; ++iter) {
             if (iter == HIER_MAX) {
                 fatalf("ERROR: No such hier_code '%s'",t);
@@ -13,7 +13,6 @@
 #include "acl/Checklist.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/RegexData.h"
-#include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "HttpHeaderTools.h"
@@ -60,16 +59,20 @@ ACLHTTPHeaderData::dump() const
 {
     SBufList sl;
     sl.push_back(SBuf(hdrName));
+#if __cplusplus >= 201103L
+    sl.splice(sl.end(), regex_rule->dump());
+#else
     // temp is needed until c++11 move-constructor
     SBufList temp = regex_rule->dump();
     sl.splice(sl.end(), temp);
+#endif
     return sl;
 }
 
 void
 ACLHTTPHeaderData::parse()
 {
-    char* t = strtokFile();
+    char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
     hdrId = httpHeaderIdByNameDef(hdrName.rawBuf(), hdrName.size());
@@ -11,7 +11,6 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/HttpStatus.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "HttpReply.h"
 
@@ -120,14 +119,9 @@ ACLHTTPStatus::parse()
 void
 aclParseHTTPStatusList(Splay<acl_httpstatus_data *> **curlist)
 {
-    char *t = NULL;
-    acl_httpstatus_data *q = NULL;
-
-    while ((t = strtokFile())) {
-        if ((q = aclParseHTTPStatusData(t)) == NULL)
-            continue;
-
-        (*curlist)->insert(q, acl_httpstatus_data::compare);
+    while (char *t = ConfigParser::strtokFile()) {
+        if (acl_httpstatus_data *q = aclParseHTTPStatusData(t))
+            (*curlist)->insert(q, acl_httpstatus_data::compare);
     }
 }
 
@@ -11,16 +11,15 @@
 #include "squid.h"
 #include "acl/IntRange.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "fatal.h"
 #include "Parsing.h"
 
 void
 ACLIntRange::parse()
 {
-    char *a;
-
-    while ((a = strtokFile())) {
+    while (char *a = ConfigParser::strtokFile()) {
         char *b = strchr(a, '-');
         unsigned short port1, port2;
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/Ip.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
@@ -478,7 +479,7 @@ ACLIP::parse()
 
     flags.parseFlags();
 
-    while (char *t = strtokFile()) {
+    while (char *t = ConfigParser::strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
@@ -33,8 +33,8 @@ libstate_la_SOURCES = \
 	Strategised.h \
 	FilledChecklist.cc \
 	FilledChecklist.h \
-	AclAddress.h \
-	AclAddress.cc
+	Address.h \
+	Address.cc
 
 ## data-specific ACLs
 libacls_la_SOURCES = \
@@ -116,6 +116,10 @@ libacls_la_SOURCES = \
 	SourceDomain.h \
 	SourceIp.cc \
 	SourceIp.h \
+	SquidError.h \
+	SquidError.cc \
+	SquidErrorData.cc \
+	SquidErrorData.h \
 	Tag.cc \
 	Tag.h \
 	Url.cc \
@@ -132,6 +136,7 @@ libacls_la_SOURCES = \
 	AclDenyInfoList.h \
 	Gadgets.cc \
 	Gadgets.h \
+	AclSizeLimit.cc \
 	AclSizeLimit.h
 
 ## Add conditional sources
@@ -11,7 +11,6 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/MaxConnection.h"
-#include "cache_cf.h"
 #include "client_db.h"
 #include "Debug.h"
 #include "SquidConfig.h"
@@ -52,7 +51,7 @@ ACLMaxConnection::valid () const
 void
 ACLMaxConnection::parse()
 {
-    char *t = strtokFile();
+    char *t = ConfigParser::strtokFile();
 
     if (!t)
         return;
@@ -62,7 +61,7 @@ ACLMaxConnection::parse()
     /* suck out file contents */
     // ignore comments
     bool ignore = false;
-    while ((t = strtokFile())) {
+    while ((t = ConfigParser::strtokFile())) {
         ignore |= (*t != '#');
 
         if (ignore)
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/MethodData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "http/RequestMethod.h"
 
 int ACLMethodData::ThePurgeCount = 0;
@@ -54,7 +54,7 @@ ACLMethodData::dump() const
 void
 ACLMethodData::parse()
 {
-    while (char *t = strtokFile()) {
+    while (char *t = ConfigParser::strtokFile()) {
         HttpRequestMethod m;
         m.HttpRequestMethodXXX(t);
         values.push_back(m);
@@ -11,7 +11,6 @@
 #include "acl/Checklist.h"
 #include "acl/NoteData.h"
 #include "acl/StringData.h"
-#include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "HttpRequest.h"
@@ -64,16 +63,20 @@ ACLNoteData::dump() const
 {
     SBufList sl;
     sl.push_back(SBuf(name));
+#if __cplusplus >= 201103L
+    sl.splice(sl.end(), values->dump());
+#else
     // temp is needed until c++11 move constructor
     SBufList temp = values->dump();
     sl.splice(sl.end(), temp);
+#endif
     return sl;
 }
 
 void
 ACLNoteData::parse()
 {
-    char* t = strtokFile();
+    char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     name = t;
     values->parse();
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/ProtocolData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -53,7 +53,7 @@ ACLProtocolData::dump() const
 void
 ACLProtocolData::parse()
 {
-    while (char *t = strtokFile()) {
+    while (char *t = ConfigParser::strtokFile()) {
         int p = AnyP::PROTO_NONE;
         for (; p < AnyP::PROTO_UNKNOWN; ++p) {
             if (strcasecmp(t, AnyP::ProtocolType_str[p]) == 0) {
@@ -9,10 +9,8 @@
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
-
 #include "acl/FilledChecklist.h"
 #include "acl/Random.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "Parsing.h"
 #include "wordlist.h"
@@ -60,10 +58,9 @@ ACLRandom::valid() const
 void
 ACLRandom::parse()
 {
-    char *t;
     char bufa[256], bufb[256];
 
-    t = strtokFile();
+    char *t = ConfigParser::strtokFile();
     if (!t) {
         debugs(28, DBG_PARSE_NOTE(DBG_IMPORTANT), "ACL random missing pattern");
         return;
@@ -31,7 +31,7 @@ SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 }
 
 void
-SourceDomainLookup::LookupDone(const char *, const DnsLookupDetails &details, void *data)
+SourceDomainLookup::LookupDone(const char *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markSourceDomainChecked();
@@ -40,7 +40,7 @@ class SourceDomainLookup : public ACLChecklist::AsyncState
 
 private:
     static SourceDomainLookup instance_;
-    static void LookupDone(const char *, const DnsLookupDetails &, void *);
+    static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };
 
 class ACLSourceDomain
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "acl/Checklist.h"
+#include "acl/SquidError.h"
+#include "HttpRequest.h"
+
+int
+ACLSquidErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+{
+    if (checklist->requestErrorType != ERR_MAX)
+        return data->match(checklist->requestErrorType);
+    else if (checklist->request)
+        return data->match(checklist->request->errType);
+    return 0;
+}
+
+ACLSquidErrorStrategy *
+ACLSquidErrorStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLSquidErrorStrategy ACLSquidErrorStrategy::Instance_;
+
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_ACLSQUIDERROR_H
+#define SQUID_ACLSQUIDERROR_H
+
+#include "acl/Strategised.h"
+#include "acl/Strategy.h"
+#include "err_type.h"
+
+class ACLSquidErrorStrategy : public ACLStrategy<err_type>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+
+    static ACLSquidErrorStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLSquidErrorStrategy(ACLSquidErrorStrategy const &);
+
+private:
+    static ACLSquidErrorStrategy Instance_;
+    ACLSquidErrorStrategy() {}
+
+    ACLSquidErrorStrategy&operator=(ACLSquidErrorStrategy const &);
+};
+
+class ACLSquidError
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<err_type> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLSQUIDERROR_H */
+
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "acl/Data.h"
+#include "acl/SquidErrorData.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "err_type.h"
+#include "fatal.h"
+#include "wordlist.h"
+
+bool
+ACLSquidErrorData::match(err_type err)
+{
+    CbDataListIterator<err_type> iter(errors);
+    while (!iter.end()) {
+        err_type localErr = iter.next();
+        debugs(28, 4, "check (" << err << "):"  << errorTypeName(err) << " against " <<  errorTypeName(localErr));
+        if (err == localErr)
+            return true;
+    }
+
+    return false;
+}
+
+SBufList
+ACLSquidErrorData::dump() const
+{
+    SBufList sl;
+    CbDataListIterator<err_type> iter(errors);
+    while (!iter.end()) {
+        err_type err = iter.next();
+        const char *errName = errorTypeName(err);
+        sl.push_back(SBuf(errName));
+    }
+
+    return sl;
+}
+
+void
+ACLSquidErrorData::parse()
+{
+    while (char *token = ConfigParser::NextToken()) {
+        err_type err = errorTypeByName(token);
+
+        if (err < ERR_MAX)
+            errors.push_back(err);
+        else {
+            debugs(28, DBG_CRITICAL, "FATAL: Invalid squid error name");
+            if (!opt_parse_cfg_only)
+                self_destruct();
+        }
+    }
+}
+
+bool
+ACLSquidErrorData::empty() const
+{
+    return errors.empty();
+}
+
+ACLData<err_type> *
+ACLSquidErrorData::clone() const
+{
+    if (!errors.empty())
+        fatal("ACLSquidError::clone: attempt to clone used ACL");
+
+    return new ACLSquidErrorData (*this);
+}
+
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_ACLSQUIDERRORDATA_H
+#define SQUID_ACLSQUIDERRORDATA_H
+
+#include "acl/Data.h"
+#include "base/CbDataList.h"
+#include "err_type.h"
+
+/// \ingroup ACLAPI
+class ACLSquidErrorData : public ACLData<err_type>
+{
+
+public:
+    ACLSquidErrorData(): ACLData<err_type>() {};
+
+    virtual ~ACLSquidErrorData() {}
+    virtual bool match(err_type err);
+    virtual SBufList dump() const;
+    virtual void parse();
+    virtual bool empty() const;
+    virtual ACLData<err_type> *clone() const;
+
+private:
+    CbDataListContainer <err_type> errors;
+};
+
+#endif //SQUID_ACLSQUIDERRORDATA_H
+
@@ -9,7 +9,6 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/SslErrorData.h"
-#include "cache_cf.h"
 #include "wordlist.h"
 
 ACLSslErrorData::ACLSslErrorData() : values (NULL)
@@ -58,10 +57,9 @@ void
 ACLSslErrorData::parse()
 {
     Ssl::Errors **Tail;
-    char *t = NULL;
 
     for (Tail = &values; *Tail; Tail = &((*Tail)->next));
-    while ((t = strtokFile())) {
+    while (char *t = ConfigParser::strtokFile()) {
         Ssl::Errors *q = Ssl::ParseErrorString(t);
         *(Tail) = q;
         Tail = &q->tail()->next;
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/StringData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 
 ACLStringData::ACLStringData(ACLStringData const &old) : stringValues(old.stringValues)
@@ -50,8 +50,7 @@ ACLStringData::dump() const
 void
 ACLStringData::parse()
 {
-    char *t;
-    while ((t = strtokFile()))
+    while (const char *t = ConfigParser::strtokFile())
         stringValues.insert(SBuf(t));
 }
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/TimeData.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -108,9 +109,7 @@ ACLTimeData::parse()
 
     int h1, m1, h2, m2;
 
-    char *t = NULL;
-
-    while ((t = strtokFile())) {
+    while (char *t = ConfigParser::strtokFile()) {
         if (*t < '0' || *t > '9') {
             /* assume its day-of-week spec */
 
@@ -73,9 +73,13 @@ Acl::Tree::treeDump(const char *prefix, const ActionToString &convert) const
             ++action;
         }
 
+#if __cplusplus >= 201103L
+        text.splice(text.end(), (*node)->dump());
+#else
         // temp is needed until c++11 move constructor
         SBufList temp = (*node)->dump();
         text.splice(text.end(), temp);
+#endif
         text.push_back(SBuf("\n"));
     }
     return text;
@@ -48,7 +48,7 @@ ACLUserData::dump() const
     if (flags.case_insensitive)
         sl.push_back(SBuf("-i"));
 
-    sl.insert(sl.end(), userDataNames.cbegin(), userDataNames.cend());
+    sl.insert(sl.end(), userDataNames.begin(), userDataNames.end());
 
     debugs(28,5, "ACLUserData dump output: " << SBufContainerJoin(userDataNames,SBuf(" ")));
     return sl;
@@ -60,6 +60,16 @@ CaseInsensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
     return (lhs.caseCmp(rhs) < 0);
 }
 
+static bool
+CaseSensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
+{
+    return (lhs < rhs);
+}
+
+ACLUserData::ACLUserData() : userDataNames(CaseSensitveSBufCompare)
+{
+}
+
 void
 ACLUserData::parse()
 {
@@ -21,6 +21,7 @@ class ACLUserData : public ACLData<char const *>
 
 public:
     virtual ~ACLUserData() {}
+    ACLUserData();
     bool match(char const *user);
     virtual SBufList dump() const;
     void parse();
@@ -16,13 +16,13 @@ class ACLChecklist;
 class ACLFilledChecklist;
 class ACLList;
 
-class AclAddress;
 class AclDenyInfoList;
 class AclSizeLimit;
 
 namespace Acl
 {
 
+class Address;
 class InnerNode;
 class NotNode;
 class AndNode;
@@ -103,7 +103,7 @@ void Adaptation::Icap::Xaction::start()
 }
 
 static void
-icapLookupDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
+icapLookupDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
     Adaptation::Icap::Xaction *xa = static_cast<Adaptation::Icap::Xaction *>(data);
     xa->dnsLookupDone(ia);
@@ -52,7 +52,7 @@ icapLogRotate()
 {
     for (CustomLog* log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
-            logfileRotate(log->logfile);
+            logfileRotate(log->logfile, Config.Log.rotateNumber);
         }
     }
 }
@@ -119,22 +119,34 @@ AnyP::PortCfg::clone() const
     b->disable_pmtu_discovery = disable_pmtu_discovery;
     b->tcp_keepalive = tcp_keepalive;
 
-#if 0
-    // TODO: AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
-
 #if USE_OPENSSL
-    char *cert;
-    char *key;
-    int version;
-    char *cipher;
-    char *options;
-    char *clientca;
-    char *cafile;
-    char *capath;
-    char *crlfile;
-    char *dhfile;
-    char *sslflags;
-    char *sslContextSessionId;
+    if (cert)
+        b->cert = xstrdup(cert);
+    if (key)
+        b->key = xstrdup(key);
+    b->version = version;
+    if (cipher)
+        b->cipher = xstrdup(cipher);
+    if (options)
+        b->options = xstrdup(options);
+    if (clientca)
+        b->clientca = xstrdup(clientca);
+    if (cafile)
+        b->cafile = xstrdup(cafile);
+    if (capath)
+        b->capath = xstrdup(capath);
+    if (crlfile)
+        b->crlfile = xstrdup(crlfile);
+    if (dhfile)
+        b->dhfile = xstrdup(dhfile);
+    if (sslflags)
+        b->sslflags = xstrdup(sslflags);
+    if (sslContextSessionId)
+        b->sslContextSessionId = xstrdup(sslContextSessionId);
+
+#if 0
+    // TODO: AYJ: 2015-01-15: for now SSL does not clone the context object.
+    // cloning should only be done before the PortCfg is post-configure initialized and opened
     SSL_CTX *sslContext;
 #endif
 
@@ -309,7 +309,10 @@ SBuf
 Auth::User::BuildUserKey(const char *username, const char *realm)
 {
     SBuf key;
-    key.Printf("%s:%s", username, realm);
+    if (realm)
+        key.Printf("%s:%s", username, realm);
+    else
+        key.append(username, strlen(username));
     return key;
 }
 
@@ -365,10 +368,11 @@ Auth::User::username(char const *aString)
     if (aString) {
         assert(!username_);
         username_ = xstrdup(aString);
-        if (!requestRealm_.isEmpty())
-            userKey_ = BuildUserKey(username_, requestRealm_.c_str());
+        // NP: param #2 is working around a c_str() data-copy performance regression
+        userKey_ = BuildUserKey(username_, (!requestRealm_.isEmpty() ? requestRealm_.c_str() : NULL));
     } else {
         safe_free(username_);
+        userKey_.clear();
     }
 }
 
@@ -63,9 +63,10 @@ class User : public RefCountable
     void absorb(Auth::User::Pointer from);
     virtual ~User();
     char const *username() const { return username_; }
-    void username(char const *);
+    void username(char const *); ///< set stored username and userKey
 
-    const char *userKey() {return !userKey_.isEmpty() ? userKey_.c_str() : username_;}
+    // NP: key is set at the same time as username_. Until then both are empty/NULL.
+    const char *userKey() {return !userKey_.isEmpty() ? userKey_.c_str() : NULL;}
 
     /**
      * How long these credentials are still valid for.
@@ -1013,12 +1013,7 @@ Auth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)
         debugs(29, 2, "Username for the nonce does not equal the username for the request");
         nonce = NULL;
     }
-    /* check for stale nonce */
-    if (authDigestNonceIsStale(nonce)) {
-        debugs(29, 3, "The received nonce is stale from " << username);
-        digest_request->setDenyMessage("Stale nonce");
-        nonce = NULL;
-    }
+
     if (!nonce) {
         /* we couldn't find a matching nonce! */
         debugs(29, 2, "Unexpected or invalid nonce received from " << username);
@@ -173,10 +173,14 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData *,
     }
 
     /* check for stale nonce */
-    if (!authDigestNonceIsValid(digest_request->nonce, digest_request->nc)) {
-        debugs(29, 3, "user '" << auth_user->username() << "' validated OK but nonce stale");
-        auth_user->credentials(Auth::Handshake);
-        digest_request->setDenyMessage("Stale nonce");
+    /* check Auth::Pending to avoid loop */
+
+    if (!authDigestNonceIsValid(digest_request->nonce, digest_request->nc) && user()->credentials() != Auth::Pending) {
+        debugs(29, 3, auth_user->username() << "' validated OK but nonce stale: " << digest_request->nonceb64);
+        /* Pending prevent banner and makes a ldap control */
+        auth_user->credentials(Auth::Pending);
+        nonce->flags.valid = false;
+        authDigestNoncePurge(nonce);
         return;
     }
 
@@ -329,6 +333,8 @@ Auth::Digest::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
     // add new helper kv-pair notes to the credentials object
     // so that any transaction using those credentials can access them
     auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+    // remove any private credentials detail which got added.
+    auth_user_request->user()->notes.remove("ha1");
 
     static bool oldHelperWarningDone = false;
     switch (reply.result) {
@@ -252,7 +252,7 @@ authenticateNegotiateStats(StoreEntry * sentry)
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
-Auth::Negotiate::Config::decode(char const *, const char *aRequestRealm)
+Auth::Negotiate::Config::decode(char const *proxy_auth, const char *aRequestRealm)
 {
     Auth::Negotiate::User *newUser = new Auth::Negotiate::User(Auth::Config::Find("negotiate"), aRequestRealm);
     Auth::UserRequest *auth_user_request = new Auth::Negotiate::UserRequest();
@@ -261,6 +261,8 @@ Auth::Negotiate::Config::decode(char const *, const char *aRequestRealm)
     auth_user_request->user(newUser);
     auth_user_request->user()->auth_type = Auth::AUTH_NEGOTIATE;
 
+    auth_user_request->user()->BuildUserKey(proxy_auth, aRequestRealm);
+
     /* all we have to do is identify that it's Negotiate - the helper does the rest */
     debugs(29, 9, HERE << "decode Negotiate authentication");
     return auth_user_request;
@@ -259,6 +259,8 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const Helper::Reply &reply
     // add new helper kv-pair notes to the credentials object
     // so that any transaction using those credentials can access them
     auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+    // remove any private credentials detail which got added.
+    auth_user_request->user()->notes.remove("token");
 
     Auth::Negotiate::UserRequest *lm_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
     assert(lm_request != NULL);
@@ -311,8 +313,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const Helper::Reply &reply
 
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
-        /* see if this is an existing user with a different proxy_auth
-         * string */
+        /* see if this is an existing user */
         AuthUserHashPointer *usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, auth_user_request->user()->userKey()));
         Auth::User::Pointer local_auth_user = lm_request->user();
         while (usernamehash && (usernamehash->user()->auth_type != Auth::AUTH_NEGOTIATE ||
@@ -390,22 +391,3 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const Helper::Reply &reply
     delete r;
 }
 
-void
-Auth::Negotiate::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
-{
-    http_hdr_type type;
-
-    if (!server_blob)
-        return;
-
-    /* don't add to authentication error pages */
-    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
-            || (accel && rep->sline.status() == Http::scUnauthorized))
-        return;
-
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
-    httpHeaderPutStrf(&rep->header, type, "Negotiate %s", server_blob);
-
-    safe_free(server_blob);
-}
-
@@ -35,8 +35,6 @@ class UserRequest : public Auth::UserRequest
     virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
-    virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
-
     virtual const char * connLastHeader();
 
     /* we need to store the helper server between requests */
@@ -232,7 +232,7 @@ authenticateNTLMStats(StoreEntry * sentry)
  * Auth_user structure.
  */
 Auth::UserRequest::Pointer
-Auth::Ntlm::Config::decode(char const *, const char *aRequestRealm)
+Auth::Ntlm::Config::decode(char const *proxy_auth, const char *aRequestRealm)
 {
     Auth::Ntlm::User *newUser = new Auth::Ntlm::User(Auth::Config::Find("ntlm"), aRequestRealm);
     Auth::UserRequest::Pointer auth_user_request = new Auth::Ntlm::UserRequest();
@@ -241,6 +241,8 @@ Auth::Ntlm::Config::decode(char const *, const char *aRequestRealm)
     auth_user_request->user(newUser);
     auth_user_request->user()->auth_type = Auth::AUTH_NTLM;
 
+    auth_user_request->user()->BuildUserKey(proxy_auth, aRequestRealm);
+
     /* all we have to do is identify that it's NTLM - the helper does the rest */
     debugs(29, 9, HERE << "decode: NTLM authentication");
     return auth_user_request;
@@ -254,6 +254,8 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
     // add new helper kv-pair notes to the credentials object
     // so that any transaction using those credentials can access them
     auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+    // remove any private credentials detail which got added.
+    auth_user_request->user()->notes.remove("token");
 
     Auth::Ntlm::UserRequest *lm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
     assert(lm_request != NULL);
@@ -305,8 +307,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const Helper::Reply &reply)
         debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << userLabel << "'");
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
-        /* see if this is an existing user with a different proxy_auth
-         * string */
+        /* see if this is an existing user */
         AuthUserHashPointer *usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, auth_user_request->user()->userKey()));
         Auth::User::Pointer local_auth_user = lm_request->user();
         while (usernamehash && (usernamehash->user()->auth_type != Auth::AUTH_NTLM ||
@@ -39,6 +39,10 @@ class RefCount
         reference (p);
     }
 
+    RefCount (RefCount &&p) : p_(std::move(p.p_)) {
+        p.p_=NULL;
+    }
+
     RefCount& operator = (const RefCount& p) {
         // DO NOT CHANGE THE ORDER HERE!!!
         // This preserves semantics on self assignment
@@ -48,6 +52,14 @@ class RefCount
         return *this;
     }
 
+    RefCount& operator = (RefCount&& p) {
+        if (this != &p) {
+            dereference(p.p_);
+            p.p_ = NULL;
+        }
+        return *this;
+    }
+
     bool operator !() const { return !p_; }
 
     C * operator-> () const {return const_cast<C *>(p_); }
@@ -10,10 +10,10 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
-#include "acl/AclAddress.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/AclNameList.h"
 #include "acl/AclSizeLimit.h"
+#include "acl/Address.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
 #include "acl/Tree.h"
@@ -23,7 +23,6 @@
 #include "base/RunnersRegistry.h"
 #include "cache_cf.h"
 #include "CachePeer.h"
-#include "CachePeerDomainList.h"
 #include "ConfigParser.h"
 #include "CpuAffinityMap.h"
 #include "DiskIO/DiskIOModule.h"
@@ -133,8 +132,6 @@ static void free_ecap_service_type(Adaptation::Ecap::Config *);
 
 static peer_t parseNeighborType(const char *s);
 
-CBDATA_TYPE(CachePeer);
-
 static const char *const T_MILLISECOND_STR = "millisecond";
 static const char *const T_SECOND_STR = "second";
 static const char *const T_MINUTE_STR = "minute";
@@ -246,6 +243,9 @@ static int parseOneConfigFile(const char *file_name, unsigned int depth);
 static void parse_configuration_includes_quoted_values(bool *recognizeQuotedValues);
 static void dump_configuration_includes_quoted_values(StoreEntry *const entry, const char *const name, bool recognizeQuotedValues);
 static void free_configuration_includes_quoted_values(bool *recognizeQuotedValues);
+static void parse_on_unsupported_protocol(acl_access **access);
+static void dump_on_unsupported_protocol(StoreEntry *entry, const char *name, acl_access *access);
+static void free_on_unsupported_protocol(acl_access **access);
 
 /*
  * LegacyParser is a parser for legacy code that uses the global
@@ -798,16 +798,6 @@ configDoConfigure(void)
 
             break;
         }
-
-        for (R = Config.Refresh; R; R = R->next) {
-            if (!R->flags.ignore_auth)
-                continue;
-
-            debugs(22, DBG_IMPORTANT, "WARNING: use of 'ignore-auth' in 'refresh_pattern' violates HTTP");
-
-            break;
-        }
-
     }
 #endif
 #if !USE_HTTP_VIOLATIONS
@@ -885,7 +875,7 @@ configDoConfigure(void)
 
     debugs(3, DBG_IMPORTANT, "Initializing https proxy context");
 
-    Config.ssl_client.sslContext = Security::ProxyOutgoingConfig.createContext();
+    Config.ssl_client.sslContext = Security::ProxyOutgoingConfig.createContext(false);
 
     for (CachePeer *p = Config.peers; p != NULL; p = p->next) {
 
@@ -895,7 +885,7 @@ configDoConfigure(void)
 
         if (p->secure.encryptTransport) {
             debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " SSL context");
-            p->sslContext = p->secure.createContext();
+            p->sslContext = p->secure.createContext(true);
         }
     }
 
@@ -1018,43 +1008,37 @@ parse_obsolete(const char *name)
 static void
 parseTimeLine(time_msec_t * tptr, const char *units,  bool allowMsec,  bool expectMoreArguments = false)
 {
-    char *token;
-    double d;
-    time_msec_t m;
     time_msec_t u;
-
     if ((u = parseTimeUnits(units, allowMsec)) == 0)
         self_destruct();
 
+    char *token;
     if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
-    d = xatof(token);
+    double d = xatof(token);
 
-    m = u;          /* default to 'units' if none specified */
+    time_msec_t m = u; /* default to 'units' if none specified */
 
-    bool hasUnits = false;
-    if (0 == d)
-        (void) 0;
-    else if ((token = ConfigParser::PeekAtToken()) == NULL)
-        (void) 0;
-    else if ((m = parseTimeUnits(token, allowMsec)) == 0) {
-        if (!expectMoreArguments)
+    if (d) {
+        if ((token = ConfigParser::PeekAtToken()) && (m = parseTimeUnits(token, allowMsec))) {
+            (void)ConfigParser::NextToken();
+
+        } else if (!expectMoreArguments) {
             self_destruct();
-    } else { //pop the token
-        (void)ConfigParser::NextToken();
-        hasUnits = true;
-    }
-    if (!hasUnits)
-        debugs(3, DBG_CRITICAL, "WARNING: No units on '" <<
-               config_input_line << "', assuming " <<
-               d << " " << units  );
+
+        } else {
+            token = NULL; // show default units if dying below
+            debugs(3, DBG_CRITICAL, "WARNING: No units on '" << config_input_line << "', assuming " << d << " " << units);
+        }
+    } else
+        token = NULL; // show default units if dying below.
 
     *tptr = static_cast<time_msec_t>(m * d);
 
     if (static_cast<double>(*tptr) * 2 != m * d * 2) {
-        debugs(3, DBG_CRITICAL, "ERROR: Invalid value '" <<
-               d << " " << token << ": integer overflow (time_msec_t).");
+        debugs(3, DBG_CRITICAL, "FATAL: Invalid value '" <<
+               d << " " << (token ? token : units) << ": integer overflow (time_msec_t).");
         self_destruct();
     }
 }
@@ -1393,15 +1377,12 @@ free_address(Ip::Address *addr)
     addr->setEmpty();
 }
 
-CBDATA_TYPE(AclAddress);
-
 static void
-dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
+dump_acl_address(StoreEntry * entry, const char *name, Acl::Address * head)
 {
     char buf[MAX_IPSTRLEN];
-    AclAddress *l;
 
-    for (l = head; l; l = l->next) {
+    for (Acl::Address *l = head; l; l = l->next) {
         if (!l->addr.isAnyAddr())
             storeAppendPrintf(entry, "%s %s", name, l->addr.toStr(buf,MAX_IPSTRLEN));
         else
@@ -1414,40 +1395,26 @@ dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
 }
 
 static void
-freed_acl_address(void *data)
+parse_acl_address(Acl::Address ** head)
 {
-    AclAddress *l = static_cast<AclAddress *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
-static void
-parse_acl_address(AclAddress ** head)
-{
-    AclAddress *l;
-    AclAddress **tail = head;   /* sane name below */
-    CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
-    l = cbdataAlloc(AclAddress);
+    Acl::Address *l = new Acl::Address;
     parse_address(&l->addr);
     aclParseAclList(LegacyParser, &l->aclList, l->addr);
 
+    Acl::Address **tail = head;
     while (*tail)
         tail = &(*tail)->next;
 
     *tail = l;
 }
 
 static void
-free_acl_address(AclAddress ** head)
+free_acl_address(Acl::Address ** head)
 {
-    while (*head) {
-        AclAddress *l = *head;
-        *head = l->next;
-        cbdataFree(l);
-    }
+    delete *head;
+    *head = NULL;
 }
 
-CBDATA_TYPE(acl_tos);
-
 static void
 dump_acl_tos(StoreEntry * entry, const char *name, acl_tos * head)
 {
@@ -1465,18 +1432,9 @@ dump_acl_tos(StoreEntry * entry, const char *name, acl_tos * head)
     }
 }
 
-static void
-freed_acl_tos(void *data)
-{
-    acl_tos *l = static_cast<acl_tos *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
 static void
 parse_acl_tos(acl_tos ** head)
 {
-    acl_tos *l;
-    acl_tos **tail = head;  /* sane name below */
     unsigned int tos;           /* Initially uint for strtoui. Casted to tos_t before return */
     char *token = ConfigParser::NextToken();
 
@@ -1496,14 +1454,13 @@ parse_acl_tos(acl_tos ** head)
         tos = chTos;
     }
 
-    CBDATA_INIT_TYPE_FREECB(acl_tos, freed_acl_tos);
-
-    l = cbdataAlloc(acl_tos);
+    acl_tos *l = new acl_tos;
 
     l->tos = (tos_t)tos;
 
     aclParseAclList(LegacyParser, &l->aclList, token);
 
+    acl_tos **tail = head;  /* sane name below */
     while (*tail)
         tail = &(*tail)->next;
 
@@ -1513,24 +1470,16 @@ parse_acl_tos(acl_tos ** head)
 static void
 free_acl_tos(acl_tos ** head)
 {
-    while (*head) {
-        acl_tos *l = *head;
-        *head = l->next;
-        l->next = NULL;
-        cbdataFree(l);
-    }
+    delete *head;
+    head = NULL;
 }
 
 #if SO_MARK && USE_LIBCAP
 
-CBDATA_TYPE(acl_nfmark);
-
 static void
 dump_acl_nfmark(StoreEntry * entry, const char *name, acl_nfmark * head)
 {
-    acl_nfmark *l;
-
-    for (l = head; l; l = l->next) {
+    for (acl_nfmark *l = head; l; l = l->next) {
         if (l->nfmark > 0)
             storeAppendPrintf(entry, "%s 0x%02X", name, l->nfmark);
         else
@@ -1542,18 +1491,9 @@ dump_acl_nfmark(StoreEntry * entry, const char *name, acl_nfmark * head)
     }
 }
 
-static void
-freed_acl_nfmark(void *data)
-{
-    acl_nfmark *l = static_cast<acl_nfmark *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
 static void
 parse_acl_nfmark(acl_nfmark ** head)
 {
-    acl_nfmark *l;
-    acl_nfmark **tail = head;   /* sane name below */
     nfmark_t mark;
     char *token = ConfigParser::NextToken();
 
@@ -1567,14 +1507,13 @@ parse_acl_nfmark(acl_nfmark ** head)
         return;
     }
 
-    CBDATA_INIT_TYPE_FREECB(acl_nfmark, freed_acl_nfmark);
-
-    l = cbdataAlloc(acl_nfmark);
+    acl_nfmark *l = new acl_nfmark;
 
     l->nfmark = mark;
 
     aclParseAclList(LegacyParser, &l->aclList, token);
 
+    acl_nfmark **tail = head;   /* sane name below */
     while (*tail)
         tail = &(*tail)->next;
 
@@ -1584,23 +1523,15 @@ parse_acl_nfmark(acl_nfmark ** head)
 static void
 free_acl_nfmark(acl_nfmark ** head)
 {
-    while (*head) {
-        acl_nfmark *l = *head;
-        *head = l->next;
-        l->next = NULL;
-        cbdataFree(l);
-    }
+    delete *head;
+    head = NULL;
 }
 #endif /* SO_MARK */
 
-CBDATA_TYPE(AclSizeLimit);
-
 static void
 dump_acl_b_size_t(StoreEntry * entry, const char *name, AclSizeLimit * head)
 {
-    AclSizeLimit *l;
-
-    for (l = head; l; l = l->next) {
+    for (AclSizeLimit *l = head; l; l = l->next) {
         if (l->size != -1)
             storeAppendPrintf(entry, "%s %d %s\n", name, (int) l->size, B_BYTES_STR);
         else
@@ -1612,27 +1543,16 @@ dump_acl_b_size_t(StoreEntry * entry, const char *name, AclSizeLimit * head)
     }
 }
 
-static void
-freed_acl_b_size_t(void *data)
-{
-    AclSizeLimit *l = static_cast<AclSizeLimit *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
 static void
 parse_acl_b_size_t(AclSizeLimit ** head)
 {
-    AclSizeLimit *l;
-    AclSizeLimit **tail = head; /* sane name below */
-
-    CBDATA_INIT_TYPE_FREECB(AclSizeLimit, freed_acl_b_size_t);
-
-    l = cbdataAlloc(AclSizeLimit);
+    AclSizeLimit *l = new AclSizeLimit;
 
     parse_b_int64_t(&l->size);
 
     aclParseAclList(LegacyParser, &l->aclList, l->size);
 
+    AclSizeLimit **tail = head; /* sane name below */
     while (*tail)
         tail = &(*tail)->next;
 
@@ -1642,12 +1562,8 @@ parse_acl_b_size_t(AclSizeLimit ** head)
 static void
 free_acl_b_size_t(AclSizeLimit ** head)
 {
-    while (*head) {
-        AclSizeLimit *l = *head;
-        *head = l->next;
-        l->next = NULL;
-        cbdataFree(l);
-    }
+    delete *head;
+    *head = NULL;
 }
 
 #if USE_DELAY_POOLS
@@ -2000,7 +1916,6 @@ peer_type_str(const peer_t type)
 static void
 dump_peer(StoreEntry * entry, const char *name, CachePeer * p)
 {
-    CachePeerDomainList *d;
     NeighborTypeDomainList *t;
     LOCAL_ARRAY(char, xname, 128);
 
@@ -2014,13 +1929,6 @@ dump_peer(StoreEntry * entry, const char *name, CachePeer * p)
                           p->name);
         dump_peer_options(entry, p);
 
-        for (d = p->peer_domain; d; d = d->next) {
-            storeAppendPrintf(entry, "cache_peer_domain %s %s%s\n",
-                              p->host,
-                              d->do_ping ? null_string : "!",
-                              d->domain);
-        }
-
         if (p->access) {
             snprintf(xname, 128, "cache_peer_access %s", p->name);
             dump_acl_access(entry, xname, p->access);
@@ -2101,14 +2009,7 @@ static void
 parse_peer(CachePeer ** head)
 {
     char *token = NULL;
-    CachePeer *p;
-    CBDATA_INIT_TYPE_FREECB(CachePeer, peerDestroy);
-    p = cbdataAlloc(CachePeer);
-    p->http_port = CACHE_HTTP_PORT;
-    p->icp.port = CACHE_ICP_PORT;
-    p->weight = 1;
-    p->basetime = 0;
-    p->stats.logged_state = PEER_ALIVE;
+    CachePeer *p = new CachePeer;
 
     if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
@@ -2133,7 +2034,6 @@ parse_peer(CachePeer ** head)
         self_destruct();
 
     p->icp.port = GetUdpService();
-    p->connection_auth = 2;    /* auto */
 
     while ((token = ConfigParser::NextToken())) {
         if (!strcmp(token, "proxy-only")) {
@@ -2329,10 +2229,6 @@ parse_peer(CachePeer ** head)
     if (p->connect_fail_limit < 1)
         p->connect_fail_limit = 10;
 
-    p->icp.version = ICP_VERSION_CURRENT;
-
-    p->testing_now = false;
-
 #if USE_CACHE_DIGESTS
 
     if (!p->options.no_digest) {
@@ -2358,21 +2254,8 @@ parse_peer(CachePeer ** head)
 static void
 free_peer(CachePeer ** P)
 {
-    CachePeer *p;
-
-    while ((p = *P) != NULL) {
-        *P = p->next;
-#if USE_CACHE_DIGESTS
-
-        cbdataReferenceDone(p->digest);
-#endif
-
-        // the mgr job will notice that its owner is gone and stop
-        PeerPoolMgr::Checkpoint(p->standby.mgr, "peer gone");
-        delete p->standby.pool;
-        cbdataFree(p);
-    }
-
+    delete *P;
+    *P = NULL;
     Config.npeers = 0;
 }
 
@@ -2512,40 +2395,6 @@ parse_peer_access(void)
     aclParseAccessLine(directive.c_str(), LegacyParser, &p->access);
 }
 
-static void
-parse_hostdomain(void)
-{
-    char *host = NULL;
-    char *domain = NULL;
-
-    if (!(host = ConfigParser::NextToken()))
-        self_destruct();
-
-    while ((domain = ConfigParser::NextToken())) {
-        CachePeerDomainList *l = NULL;
-        CachePeerDomainList **L = NULL;
-        CachePeer *p;
-
-        if ((p = peerFindByName(host)) == NULL) {
-            debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
-            continue;
-        }
-
-        l = static_cast<CachePeerDomainList *>(xcalloc(1, sizeof(CachePeerDomainList)));
-        l->do_ping = true;
-
-        if (*domain == '!') {   /* check for !.edu */
-            l->do_ping = false;
-            ++domain;
-        }
-
-        l->domain = xstrdup(domain);
-
-        for (L = &(p->peer_domain); *L; L = &((*L)->next));
-        *L = l;
-    }
-}
-
 static void
 parse_hostdomaintype(void)
 {
@@ -2741,10 +2590,6 @@ dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 
         if (head->flags.ignore_private)
             storeAppendPrintf(entry, " ignore-private");
-
-        if (head->flags.ignore_auth)
-            storeAppendPrintf(entry, " ignore-auth");
-
 #endif
 
         storeAppendPrintf(entry, "\n");
@@ -2774,7 +2619,6 @@ parse_refreshpattern(RefreshPattern ** head)
     int ignore_no_store = 0;
     int ignore_must_revalidate = 0;
     int ignore_private = 0;
-    int ignore_auth = 0;
 #endif
 
     int i;
@@ -2856,7 +2700,7 @@ parse_refreshpattern(RefreshPattern ** head)
         else if (!strcmp(token, "ignore-private"))
             ignore_private = 1;
         else if (!strcmp(token, "ignore-auth"))
-            ignore_auth = 1;
+            debugs(22, DBG_PARSE_NOTE(2), "UPGRADE: refresh_pattern option 'ignore-auth' is obsolete. Remove it.");
         else if (!strcmp(token, "reload-into-ims")) {
             reload_into_ims = 1;
             refresh_nocache_hack = 1;
@@ -2924,10 +2768,6 @@ parse_refreshpattern(RefreshPattern ** head)
 
     if (ignore_private)
         t->flags.ignore_private = true;
-
-    if (ignore_auth)
-        t->flags.ignore_auth = true;
-
 #endif
 
     t->next = NULL;
@@ -4044,12 +3884,6 @@ requirePathnameExists(const char *name, const char *path)
     }
 }
 
-char *
-strtokFile(void)
-{
-    return ConfigParser::strtokFile();
-}
-
 #include "AccessLogEntry.h"
 
 /**
@@ -4100,6 +3934,7 @@ parse_access_log(CustomLog ** logs)
 
     cl->filename = xstrdup(filename);
     cl->type = Log::Format::CLF_UNKNOWN;
+    cl->rotateCount = -1; // default: use global logfile_rotate setting.
 
     const char *token = ConfigParser::PeekAtToken();
     if (!token) { // style #1
@@ -4123,6 +3958,8 @@ parse_access_log(CustomLog ** logs)
                 }
             } else if (strncasecmp(token, "buffer-size=", 12) == 0) {
                 parseBytesOptionValue(&cl->bufferSize, B_BYTES_STR, token+12);
+            } else if (strncasecmp(token, "rotate=", 7) == 0) {
+                cl->rotateCount = xatoi(token + 7);
             } else if (strncasecmp(token, "logformat=", 10) == 0) {
                 setLogformat(cl, token+10, true);
             } else if (!strchr(token, '=')) {
@@ -4227,42 +4064,53 @@ dump_access_log(StoreEntry * entry, const char *name, CustomLog * logs)
         switch (log->type) {
 
         case Log::Format::CLF_CUSTOM:
-            storeAppendPrintf(entry, "%s %s", log->filename, log->logFormat->name);
+            storeAppendPrintf(entry, "%s logformat=%s", log->filename, log->logFormat->name);
             break;
 
         case Log::Format::CLF_NONE:
-            storeAppendPrintf(entry, "none");
+            storeAppendPrintf(entry, "logformat=none");
             break;
 
         case Log::Format::CLF_SQUID:
-            storeAppendPrintf(entry, "%s squid", log->filename);
+            storeAppendPrintf(entry, "%s logformat=squid", log->filename);
             break;
 
         case Log::Format::CLF_COMBINED:
-            storeAppendPrintf(entry, "%s combined", log->filename);
+            storeAppendPrintf(entry, "%s logformat=combined", log->filename);
             break;
 
         case Log::Format::CLF_COMMON:
-            storeAppendPrintf(entry, "%s common", log->filename);
+            storeAppendPrintf(entry, "%s logformat=common", log->filename);
             break;
 
 #if ICAP_CLIENT
         case Log::Format::CLF_ICAP_SQUID:
-            storeAppendPrintf(entry, "%s icap_squid", log->filename);
+            storeAppendPrintf(entry, "%s logformat=icap_squid", log->filename);
             break;
 #endif
         case Log::Format::CLF_USERAGENT:
-            storeAppendPrintf(entry, "%s useragent", log->filename);
+            storeAppendPrintf(entry, "%s logformat=useragent", log->filename);
             break;
 
         case Log::Format::CLF_REFERER:
-            storeAppendPrintf(entry, "%s referrer", log->filename);
+            storeAppendPrintf(entry, "%s logformat=referrer", log->filename);
             break;
 
         case Log::Format::CLF_UNKNOWN:
             break;
         }
 
+        // default is on-error=die
+        if (!log->fatal)
+            storeAppendPrintf(entry, " on-error=drop");
+
+        // default: 64KB
+        if (log->bufferSize != 64*1024)
+            storeAppendPrintf(entry, " buffer-size=%" PRIuSIZE, log->bufferSize);
+
+        if (log->rotateCount >= 0)
+            storeAppendPrintf(entry, " rotate=%d", log->rotateCount);
+
         if (log->aclList)
             dump_acl_list(entry, log->aclList);
 
@@ -5010,3 +4858,58 @@ free_configuration_includes_quoted_values(bool *)
     ConfigParser::StrictMode = false;
 }
 
+static void
+parse_on_unsupported_protocol(acl_access **access)
+{
+    char *tm;
+    if ((tm = ConfigParser::NextToken()) == NULL) {
+        self_destruct();
+        return;
+    }
+
+    allow_t action = allow_t(ACCESS_ALLOWED);
+    if (strcmp(tm, "tunnel") == 0)
+        action.kind = 1;
+    else if (strcmp(tm, "respond") == 0)
+        action.kind = 2;
+    else {
+        debugs(3, DBG_CRITICAL, "FATAL: unknown on_unsupported_protocol mode: " << tm);
+        self_destruct();
+        return;
+    }
+
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context("(on_unsupported_protocol rule)", config_input_line);
+    rule->lineParse();
+    // empty rule OK
+
+    assert(access);
+    if (!*access) {
+        *access = new Acl::Tree;
+        (*access)->context("(on_unsupported_protocol rules)", config_input_line);
+    }
+
+    (*access)->add(rule, action);
+}
+
+static void
+dump_on_unsupported_protocol(StoreEntry *entry, const char *name, acl_access *access)
+{
+    const char *on_error_tunnel_mode_str[] = {
+        "none",
+        "tunnel",
+        "respond",
+        NULL
+    };
+    if (access) {
+        SBufList lines = access->treeDump(name, on_error_tunnel_mode_str);
+        dump_SBufList(entry, lines);
+    }
+}
+
+static void
+free_on_unsupported_protocol(acl_access **access)
+{
+    free_acl_access(access);
+}
+
@@ -24,7 +24,6 @@ void parse_eol(char *volatile *var);
 void parse_wordlist(wordlist ** list);
 void requirePathnameExists(const char *name, const char *path);
 void parse_time_t(time_t * var);
-char *strtokFile(void);
 
 #endif /* SQUID_CACHE_CF_H_ */
 
@@ -8,19 +8,6 @@
 
 /* DEBUG: section 45    Callback Data Registry */
 
-/**
- \defgroup CBDATAInternal Callback Data Allocator Internals
- \ingroup CBDATAAPI
- *
- * These routines manage a set of registered callback data pointers.
- * One of the easiest ways to make Squid coredump is to issue a
- * callback to for some data structure which has previously been
- * freed.  With these routines, we register (add) callback data
- * pointers, lock them just before registering the callback function,
- * validate them before issuing the callback, and then free them
- * when finished.
- */
-
 #include "squid.h"
 #include "cbdata.h"
 #include "Generic.h"
@@ -58,10 +45,17 @@ class CBDataCall
 
 #endif
 
-/// \ingroup CBDATAInternal
 #define OFFSET_OF(TYPE, MEMBER) ((size_t) &(((TYPE) *)0)->(MEMBER))
 
-/// \ingroup CBDATAInternal
+/**
+ * Manage a set of registered callback data pointers.
+ * One of the easiest ways to make Squid coredump is to issue a
+ * callback to for some data structure which has previously been
+ * freed.  With this class, we register (add) callback data
+ * pointers, lock them just before registering the callback function,
+ * validate them before issuing the callback, and then free them
+ * when finished.
+ */
 class cbdata
 {
 #if !HASHED_CBDATA
@@ -140,14 +134,12 @@ static OBJH cbdataDump;
 static OBJH cbdataDumpHistory;
 #endif
 
-/// \ingroup CBDATAInternal
 struct CBDataIndex {
     MemAllocator *pool;
     FREE *free_func;
 }
 *cbdata_index = NULL;
 
-/// \ingroup CBDATAInternal
 int cbdata_types = 0;
 
 #if HASHED_CBDATA
@@ -284,38 +276,14 @@ cbdataInternalAlloc(cbdata_type type, const char *file, int line)
     return p;
 }
 
-void *
-cbdataInternalFree(void *p, const char *file, int line)
+void
+cbdataRealFree(cbdata *c, const char *file, const int line)
 {
-    cbdata *c;
-#if HASHED_CBDATA
-    c = (cbdata *) hash_lookup(cbdata_htable, p);
-#else
-    c = (cbdata *) (((char *) p) - cbdata::Offset);
-#endif
-#if USE_CBDATA_DEBUG
-    debugs(45, 3, p << " " << file << ":" << line);
-#else
-    debugs(45, 9, p);
-#endif
-
-    c->check(__LINE__);
-    assert(c->valid);
-    c->valid = 0;
-#if USE_CBDATA_DEBUG
-
-    c->addHistory("Free", file, line);
-#endif
-
-    if (c->locks) {
-        debugs(45, 9, p << " has " << c->locks << " locks, not freeing");
-        return NULL;
-    }
+    void *p = c;
 
     --cbdataCount;
     debugs(45, 9, "Freeing " << p);
 #if USE_CBDATA_DEBUG
-
     dlinkDelete(&c->link, &cbdataEntries);
 #endif
 
@@ -333,17 +301,47 @@ cbdataInternalFree(void *p, const char *file, int line)
 #if HASHED_CBDATA
     hash_remove_link(cbdata_htable, &c->hash);
 #if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call delete " << (void*)c << " " << file << ":" << line);
+    debugs(45, 3, "Call delete " << p << " " << file << ":" << line);
 #endif
     delete c;
-    cbdata_index[theType].pool->freeOne((void *)p);
 #else
 #if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call cbdata::~cbdata() " << (void*)c << " " << file << ":" << line);
+    debugs(45, 3, "Call cbdata::~cbdata() " << p << " " << file << ":" << line);
 #endif
     c->cbdata::~cbdata();
-    cbdata_index[theType].pool->freeOne(c);
 #endif
+    cbdata_index[theType].pool->freeOne(p);
+}
+
+void *
+cbdataInternalFree(void *p, const char *file, int line)
+{
+    cbdata *c;
+#if HASHED_CBDATA
+    c = (cbdata *) hash_lookup(cbdata_htable, p);
+#else
+    c = (cbdata *) (((char *) p) - cbdata::Offset);
+#endif
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, p << " " << file << ":" << line);
+#else
+    debugs(45, 9, p);
+#endif
+
+    c->check(__LINE__);
+    assert(c->valid);
+    c->valid = 0;
+#if USE_CBDATA_DEBUG
+
+    c->addHistory("Free", file, line);
+#endif
+
+    if (c->locks) {
+        debugs(45, 9, p << " has " << c->locks << " locks, not freeing");
+        return NULL;
+    }
+
+    cbdataRealFree(c, file, line);
     return NULL;
 }
 
@@ -417,45 +415,15 @@ cbdataInternalUnlock(const void *p)
 
     if (c->valid) {
 #if USE_CBDATA_DEBUG
-        debugs(45, DBG_IMPORTANT, "CBDATA memory leak. cbdata=" << p << " " << file << ":" << line);
+        debugs(45, 3, "CBDATA valid with no references ... cbdata=" << p << " " << file << ":" << line);
 #endif
         return;
     }
 
-    --cbdataCount;
-
-    debugs(45, 9, "Freeing " << p);
-
 #if USE_CBDATA_DEBUG
-
-    dlinkDelete(&c->link, &cbdataEntries);
-
-#endif
-
-    /* This is ugly. But: operator delete doesn't get
-     * the type parameter, so we can't use that
-     * to free the memory.
-     * So, we free it ourselves.
-     * Note that this means a non-placement
-     * new would be a seriously bad idea.
-     * Lastly, if we where a templated class,
-     * we could use the normal delete operator
-     * and it would Just Work. RBC 20030902
-     */
-    cbdata_type theType = c->type;
-#if HASHED_CBDATA
-    hash_remove_link(cbdata_htable, &c->hash);
-#if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call delete " << (void*)c << " " << file << ":" << line);
-#endif
-    delete c;
-    cbdata_index[theType].pool->freeOne((void *)p);
+    cbdataRealFree(c, file, line);
 #else
-#if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call cbdata::~cbdata() " << (void*)c << " " << file << ":" << line);
-#endif
-    c->cbdata::~cbdata();
-    cbdata_index[theType].pool->freeOne(c);
+    cbdataRealFree(c, NULL, 0);
 #endif
 }
 
@@ -6,96 +6,96 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef   SQUID_CBDATA_H
-#define   SQUID_CBDATA_H
+#ifndef SQUID_SRC_CBDATA_H
+#define SQUID_SRC_CBDATA_H
 
 #include "typedefs.h"
 
 /**
- \defgroup CBDATAAPI Callback Data Allocator API
- \ingroup Components
+\page CBDATA Callback Data Allocator API
+
+ \section  Introduction
+
  \par
- *    Squid's extensive use of callback functions makes it very
- *    susceptible to memory access errors. To address this all callback
- *    functions make use of a construct called cbdata. This allows
- *    functions doing callbacks to verify that the caller is still
- *    valid before making the callback.
- *
- \note  cbdata is intended for callback data and is tailored specifically
- *      to make callbacks less dangerous leaving as few windows of errors as
- *      possible. It is not suitable or intended as a generic RefCount
- *      memory allocator.
- *
- *
+   Squid's extensive use of callback functions makes it very
+   susceptible to memory access errors. To address this all callback
+   functions make use of a construct called cbdata. This allows
+   functions doing callbacks to verify that the caller is still
+   valid before making the callback.
+
+ \note cbdata is intended for callback data and is tailored specifically
+       to make callbacks less dangerous leaving as few windows of errors as
+       possible. It is not suitable or intended as a generic RefCount
+       memory allocator.
+
+ \par
+   The AsyncJob/AsyncCall mechanism is preferred over CBDATA.
+   It replaces cbdata with an AsyncCall::Pointer object which
+   performs the same memory protection duties via other means.
+
  \section Examples Examples
  \par
- *  Here you can find some examples on how to use cbdata, and why.
- *
+   Here you can find some examples on how to use cbdata, and why.
+
  \subsection AsyncOpWithoutCBDATA Asynchronous operation without cbdata, showing why cbdata is needed
  \par
- *  For a asyncronous operation with callback functions, the normal
- *  sequence of events in programs NOT using cbdata is as follows:
- *
+   For a asyncronous operation with callback functions, the normal
+   sequence of events in programs NOT using cbdata is as follows:
+
  \code
     // initialization
-    type_of_data our_data;
-    ...
-    our_data = malloc(...);
+    type_of_data our_data = new ...;
     ...
     // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(bar, callback_func, our_data);
     ...
     // The asyncronous operation completes and makes the callback
     callback_func(callback_data, ....);
     // Some time later we clean up our data
-    free(our_data);
+    delete our_data;
  \endcode
- *
+
  \par
- *  However, things become more interesting if we want or need
- *  to free the callback_data, or otherwise cancel the callback,
- *  before the operation completes. In constructs like this you
- *  can quite easily end up with having the memory referenced
- *  pointed to by callback_data freed before the callback is invoked
- *  causing a program failure or memory corruption:
- *
+   However, things become more interesting if we want or need
+   to free the callback_data, or otherwise cancel the callback,
+   before the operation completes. In constructs like this you
+   can quite easily end up with having the memory referenced
+   pointed to by callback_data freed before the callback is invoked
+   causing a program failure or memory corruption:
+
  \code
     // initialization
-    type_of_data our_data;
-    ...
-    our_data = malloc(...);
+    type_of_data our_data = new ...;
     ...
     // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(bar, callback_func, our_data);
     ...
     // ouch, something bad happened elsewhere.. try to cleanup
     // but the programmer forgot there is a callback pending from
-    // fooOperationsStart() (an easy thing to forget when writing code
+    // fooOperationsStart(). An easy thing to forget when writing code
     // to deal with errors, especially if there may be many different
-    // pending operation)
-    free(our_data);
+    // pending operations.
+    delete our_data;
     ...
     // The asyncronous operation completes and makes the callback
     callback_func(callback_data, ....);
     // CRASH, the memory pointer to by callback_data is no longer valid
     // at the time of the callback
  \endcode
- *
+
  \subsection AsyncOpWithCBDATA Asyncronous operation with cbdata
- *
+
  \par
- *  The callback data allocator lets us do this in a uniform and
- *  safe manner.  The callback data allocator is used to allocate,
- *  track and free memory pool objects used during callback
- *  operations.  Allocated memory is locked while the asyncronous
- *  operation executes elsewhere, and is freed when the operation
- *  completes.  The normal sequence of events is:
- *
+   The callback data allocator lets us do this in a uniform and
+   safe manner.  The callback data allocator is used to allocate,
+   track and free memory pool objects used during callback
+   operations.  Allocated memory is locked while the asyncronous
+   operation executes elsewhere, and is freed when the operation
+   completes.  The normal sequence of events is:
+
  \code
     // initialization
-    type_of_data our_data;
-    ...
-    our_data = cbdataAlloc(type_of_data);
+    type_of_data our_data = new type_of_data;
     ...
     // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(..., callback_func, our_data);
@@ -107,102 +107,130 @@
     void *cbdata;
     if (cbdataReferenceValidDone(local_pointer, &amp;cbdata))
         callback_func(...., cbdata);
-    ...
-    cbdataFree(our_data);
+    delete our_data;
  \endcode
- *
+
  \subsection AsynchronousOpCancelledByCBDATA Asynchronous operation cancelled by cbdata
- *
+
  \par
- *  With this scheme, nothing bad happens if cbdataFree() gets called
- *  before fooOperantionComplete(...).
- *
+   With this scheme, nothing bad happens if delete gets called
+   before fooOperantionComplete(...).
+
  \par   Initalization
  \code
-    type_of_data our_data;
+    // initialization
+    type_of_data our_data = new type_of_data;
     ...
-    our_data = cbdataAlloc(type_of_data);
- \endcode
- *  Initiate a asyncronous operation, with our_data as callback_data
- \code
+    // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(..., callback_func, our_data);
- \endcode
- *  do some stuff with it
- \code
+    ...
+    // do some stuff with it
     void *local_pointer = cbdataReference(callback_data);
- \endcode
- *  something bad happened elsewhere.. cleanup
- \code
-    cbdataFree(our_data);
- \endcode
- *  The asyncronous operation completes and tries to make the callback
- \code
+    ...
+    // something bad happened elsewhere.. cleanup
+    delete our_data;
+    ....
+    // The asyncronous operation completes and makes the callback
     void *cbdata;
     if (cbdataReferenceValidDone(local_pointer, &amp;cbdata))
-        {
- \endcode
- *  won't be called, as the data is no longer valid
- \code
+        // won't be called, as the data is no longer valid
         callback_func(...., cbdata);
-    }
+    delete our_data;
  \endcode
- *
+
  \par
- *  In this case, when cbdataFree() is called before
- *  cbdataReferenceValidDone(), the callback_data gets marked as invalid.
- *  When the callback_data is invalid before executing the callback
- *  function, cbdataReferenceValidDone() will return 0 and
- *  callback_func is never executed.
- *
+   In this case, when delete is called before cbdataReferenceValidDone(),
+   the callback_data gets marked as invalid.
+   When the callback_data is invalid before executing the callback
+   function, cbdataReferenceValidDone() will return 0 and
+   callback_func is never executed.
+
  \subsection AddingCBDATAType Adding a new cbdata registered type
- *
+
+ \par
+   To add new module specific data types to the allocator one uses
+   the macro CBDATA_CLASS() in the class private section, and
+   CBDATA_CLASS_INIT() or CBDATA_NAMESPACED_CLASS_INIT() in the
+   class .cc file.
+
+ \code
+    class Foo
+    {
+        CBDATA_CLASS(Foo);
+
+    public:
+        Foo() {}
+        ~Foo() {}
+    };
+    ...
+    CBDATA_CLASS_INIT(Foo);
+ \endcode
+
+ \par
+   These macros create new(), delete() and toCbdata() methods
+   definition in class scope. Any allocate calls must be made with
+   new() and destruction with delete(), they may be called from
+   anywhere.
+
+ \par
+   The class constructor must make sure that all member
+   variables are initialized, and the class destructor that all
+   dynamic memory is released.
+
  \par
- *  To add new module specific data types to the allocator one uses the
- *  macro CBDATA_CLASS() in the class private section, and CBDATA_CLASS_INIT()
- *      or CBDATA_NAMESPACED_CLASS_INIT() in the .cc file.
- *      This creates new(), delete() and toCbdata() methods
- *  definition in class scope. Any allocate calls must be made with
- *      new() and destruction with delete(), they may be called from anywhere.
+   The CbcPointer<> template should be used to create a smart-pointer
+   type for simple reference tracking. It provides get() and valid()
+   accessors for use instead of cbdataReferenceValid(), and performs
+   reliable automatic cbdataReference() and cbdataReferenceDone()
+   tracking.
+   Note that it does NOT provide a replacement for cbdataReferenceValidDone().
+
  */
 
 /**
- *\ingroup CBDATAAPI
  * cbdata types. Similar to the MEM_* types, but managed in cbdata.cc
  * A big difference is that cbdata types are dynamically allocated.
- * Initially only UNKNOWN type is predefined. Other types are added runtime.
+ *
+ * Initially only UNKNOWN type is predefined.
+ * Other types are added at runtime by CBDATA_CLASS().
  */
 typedef int cbdata_type;
 static const cbdata_type CBDATA_UNKNOWN = 0;
 
-/// \ingroup CBDATAAPI
+/**
+ * Create a run-time registration of CBDATA component with
+ * the Squid cachemgr
+ */
 void cbdataRegisterWithCacheManager(void);
 
 /**
  * Allocates a new entry of a registered CBDATA type.
- * \deprecated use CBDATA_CLASS() instead
+ *
+ * \note For internal CBDATA use only.
  */
 void *cbdataInternalAlloc(cbdata_type type, const char *, int);
-/// \deprecated use CBDATA_CLASS() instead
-#define cbdataAlloc(type) ((type *)cbdataInternalAlloc(CBDATA_##type,__FILE__,__LINE__))
 
 /**
- * Frees a entry allocated by cbdataAlloc().
+ * Frees a entry allocated by cbdataInternalAlloc().
+ *
+ * Once this has been called cbdataReferenceValid() and
+ * cbdataReferenceValidDone() will return false regardless
+ * of whether there are remaining cbdata references.
  *
- \note  If there are active references to the entry then the entry
- *      will be freed with the last reference is removed. However,
- *      cbdataReferenceValid() will return false for those references.
- * \deprecated use CBDATA_CLASS() instead
+ * cbdataReferenceDone() must still be called for any active
+ * references to the cbdata entry. The cbdata entry will be freed
+ * only when the last reference is removed.
+ *
+ * \note For internal CBDATA use only.
  */
 void *cbdataInternalFree(void *p, const char *, int);
-/// \deprecated use CBDATA_CLASS() instead
-#define cbdataFree(var)     do {if (var) {cbdataInternalFree(var,__FILE__,__LINE__); var = NULL;}} while(0)
 
 #if USE_CBDATA_DEBUG
 void cbdataInternalLockDbg(const void *p, const char *, int);
-#define cbdataInternalLock(a)       cbdataInternalLockDbg(a,__FILE__,__LINE__)
+#define cbdataInternalLock(a) cbdataInternalLockDbg(a,__FILE__,__LINE__)
 
 void cbdataInternalUnlockDbg(const void *p, const char *, int);
-#define cbdataInternalUnlock(a)     cbdataInternalUnlockDbg(a,__FILE__,__LINE__)
+#define cbdataInternalUnlock(a) cbdataInternalUnlockDbg(a,__FILE__,__LINE__)
 
 int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
 #define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValidDbg((void **)&(var), (ptr), __FILE__,__LINE__)
@@ -223,8 +251,8 @@ void cbdataInternalUnlock(const void *p);
             callback(..., cbdata);
  \endcode
  *
- \param var The reference variable. Will be automatically cleared to NULL.
- \param ptr A temporary pointer to the referenced data (if valid).
+ * \param var The reference variable. Will be automatically cleared to NULL.
+ * \param ptr A temporary pointer to the referenced data (if valid).
  */
 int cbdataInternalReferenceDoneValid(void **p, void **tp);
 #define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValid((void **)&(var), (ptr))
@@ -234,123 +262,99 @@ int cbdataInternalReferenceDoneValid(void **p, void **tp);
 /**
  * \param p A cbdata entry reference pointer.
  *
- * \retval 0    A reference is stale. The pointer refers to a entry freed by cbdataFree().
+ * \retval 0    A reference is stale. The pointer refers to a entry already freed.
  * \retval true The reference is valid and active.
  */
 int cbdataReferenceValid(const void *p);
 
-/// \ingroup CBDATAAPI
+/**
+ * Create a run-time registration for the class type with cbdata memory allocator.
+ *
+ * \note For internal CBDATA use only.
+ */
 cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
 
 /**
  * This needs to be defined FIRST in the class definition.
  * It plays with private/public states in C++.
  */
-#define CBDATA_CLASS(type)  \
+#define CBDATA_CLASS(type) \
     public: \
         void *operator new(size_t size) { \
           assert(size == sizeof(type)); \
-          if (!CBDATA_##type) \
-                      CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), NULL); \
+          if (!CBDATA_##type) CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), NULL); \
           return (type *)cbdataInternalAlloc(CBDATA_##type,__FILE__,__LINE__); \
         } \
         void operator delete (void *address) { \
-          if (address) cbdataInternalFree(address,__FILE__,__LINE__);\
+          if (address) cbdataInternalFree(address,__FILE__,__LINE__); \
         } \
-                void *toCbdata() { return this; } \
+        void *toCbdata() { return this; } \
     private: \
-    static cbdata_type CBDATA_##type;
+       static cbdata_type CBDATA_##type;
 
 /**
- \par
- *    Creates a new reference to a cbdata entry. Used when you need to
- *    store a reference in another structure. The reference can later
- *    be verified for validity by cbdataReferenceValid().
+ * Creates a global instance pointer for the CBDATA memory allocator
+ * to allocate and free objects for the matching CBDATA_CLASS().
  *
- \param var
- *       The reference variable is a pointer to the entry, in all
- *       aspects identical to the original pointer. But semantically it
- *       is quite different. It is best if the reference is thought of
- *       and handled as a "void *".
- */
-#define cbdataReference(var)    (cbdataInternalLock(var), var)
-
-/**
- \ingroup CBDATAAPI
- * Removes a reference created by cbdataReference().
+ * Place this in the appropriate .cc file for the class being registered.
  *
- \param var The reference variable. Will be automatically cleared to NULL.
+ * May be placed inside an explicit namespace scope declaration,
+ * or CBDATA_NAMESPACED_CLASS_INIT() used instead.
  */
-#define cbdataReferenceDone(var) do {if (var) {cbdataInternalUnlock(var); var = NULL;}} while(0)
-
-/// \ingroup CBDATAAPI
 #define CBDATA_CLASS_INIT(type) cbdata_type type::CBDATA_##type = CBDATA_UNKNOWN
-#define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
- * Macro that defines a new cbdata datatype. Similar to a variable
- * or struct definition. Scope is always local to the file/block
- * where it is defined and all calls to cbdataAlloc() for this type
- * must be within the same scope as the CBDATA_TYPE declaration.
- * Allocated entries may be referenced or freed anywhere with no
- * restrictions on scope.
- * \deprecated Use CBDATA_CLASS() instead
+ * Creates a global instance pointer for the CBDATA memory allocator
+ * to allocate and free objects for the matching CBDATA_CLASS().
+ *
+ * Place this in the appropriate .cc file for the class being registered.
  */
-#define CBDATA_TYPE(type)   static cbdata_type CBDATA_##type = CBDATA_UNKNOWN
+#define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
- \ingroup CBDATAAPI
+ * Creates a new reference to a cbdata entry. Used when you need to
+ * store a reference in another structure. The reference can later
+ * be verified for validity by cbdataReferenceValid().
  *
- * Initializes the cbdatatype. Must be called prior to the first use of cbdataAlloc() for the type.
+ * \deprecated Prefer the use of CbcPointer<> smart pointer.
  *
- \par
- * Alternative to CBDATA_INIT_TYPE()
- *
- \param type        Type being initialized
- \param free_func   The freehandler called when the last known reference to an allocated entry goes away.
+ * \param var
+ *       The reference variable is a pointer to the entry, in all
+ *       aspects identical to the original pointer. But semantically it
+ *       is quite different. It is best if the reference is thought of
+ *       and handled as a "void *".
  */
-#define CBDATA_INIT_TYPE_FREECB(type, free_func) do { if (!CBDATA_##type) CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), free_func); } while (false)
+#define cbdataReference(var)    (cbdataInternalLock(var), var)
 
 /**
- * Initializes the cbdatatype. Must be called prior to the first use of cbdataAlloc() for the type.
- *
- \par
- * Alternative to CBDATA_INIT_TYPE_FREECB()
+ * Removes a reference created by cbdataReference().
  *
- \param type        Type being initialized
+ * \deprecated Prefer the use of CbcPointer<> smart pointer.
  *
- * \deprecated Use CBDATA_CLASS() instead
+ * \param var The reference variable. Will be automatically cleared to NULL.
  */
-#define CBDATA_INIT_TYPE(type)  CBDATA_INIT_TYPE_FREECB(type, NULL)
+#define cbdataReferenceDone(var) do {if (var) {cbdataInternalUnlock(var); var = NULL;}} while(0)
 
 /**
- \ingroup CBDATA
- *
- * A generic wrapper for passing objects through cbdata.
+ * A generic wrapper for passing object pointers through cbdata.
  * Use this when you need to pass callback data to a blocking
- * operation, but you don't want to/cannot have that pointer be cbdata itself.
+ * operation, but you don't want to/cannot have that pointer be
+ * cbdata itself.
  */
 class generic_cbdata
 {
     CBDATA_CLASS(generic_cbdata);
 
 public:
-
-    generic_cbdata(void * aData) : data(aData) {}
+    generic_cbdata(void *aData) : data(aData) {}
 
     template<typename wrapped_type>void unwrap(wrapped_type **output) {
         *output = static_cast<wrapped_type *>(data);
         delete this;
     }
 
-    /**
-     * The wrapped data - only public to allow the mild abuse of this facility
-     * done by store_swapout - it gives a wrapped StoreEntry to StoreIO as the
-     * object to be given to the callbacks. That needs to be fully cleaned up!
-     * - RBC 20060820
-     \todo CODE: make this a private field.
-     */
-    void *data; /* the wrapped data */
+private:
+    void *data;
 };
 
 #endif /* SQUID_CBDATA_H */
@@ -58,6 +58,7 @@ memcachemode
 note			acl
 obsolete
 onoff
+on_unsupported_protocol	acl
 peer
 peer_access		cache_peer acl
 pipelinePrefetch
@@ -149,6 +149,12 @@ DOC_START
 DOC_END
 
 # Options removed in 3.6
+NAME: cache_peer_domain cache_host_domain
+TYPE: obsolete
+DOC_START
+	Replace with dstdomain ACLs and cache_peer_access.
+DOC_END
+
 NAME: sslproxy_cafile
 TYPE: obsolete
 DOC_START
@@ -204,6 +210,7 @@ DOC_START
 	Remove this line. Use always_direct or cache_peer_access ACLs instead if you need to prevent cache_peer use.
 DOC_END
 
+# Options removed in 3.4
 NAME: log_access
 TYPE: obsolete
 DOC_START
@@ -224,6 +231,12 @@ DOC_START
 DOC_END
 
 # Options Removed in 3.2
+NAME: chunked_request_body_max_size
+TYPE: obsolete
+DOC_START
+	Remove this line. Squid is now HTTP/1.1 compliant.
+DOC_END
+
 NAME: dns_v4_fallback
 TYPE: obsolete
 DOC_START
@@ -1665,6 +1678,50 @@ DOC_START
 
 DOC_END
 
+NAME: on_unsupported_protocol
+TYPE: on_unsupported_protocol
+LOC: Config.accessList.on_unsupported_protocol
+DEFAULT: none
+DEFAULT_DOC: Respond with an error message to unidentifiable traffic
+DOC_START
+	Determines Squid behavior when encountering strange requests at the
+	beginning of an accepted TCP connection. This is especially useful in
+	interception environments where Squid is likely to see connections for
+	unsupported protocols that Squid should either terminate or tunnel at
+	TCP level.
+ 
+		on_unsupported_protocol <action> [!]acl ...
+ 
+	The first matching action wins.
+
+	Supported actions are:
+ 
+	tunnel: Establish a TCP connection with the intended server and
+		blindly shovel TCP packets between the client and server.
+
+	respond: Respond with an error message, using the transfer protocol
+		for the Squid port that received the request (e.g., HTTP
+		for connections intercepted at the http_port). This is the
+		default.
+ 
+	Currently, this directive is ignored for non-intercepted connections
+	because Squid cannot know what their intended destination is.
+
+	For example:
+	  # define what Squid errors indicate receiving non-HTTP traffic:
+	  acl foreignProtocol squid_error ERR_PROTOCOL_UNKNOWN ERR_TOO_BIG
+	  # define what Squid errors indicate receiving nothing:
+	  acl serverTalksFirstProtocol squid_error ERR_REQUEST_START_TIMEOUT
+	  # tunnel everything that does not look like HTTP:
+          on_unsupported_protocol tunnel foreignProtocol
+	  # tunnel if we think the client waits for the server to talk first:
+	  on_unsupported_protocol tunnel serverTalksFirstProtocol
+	  # in all other error cases, just send an HTTP "error page" response:
+	  on_unsupported_protocol respond all
+
+	See also: squid_error ACL
+DOC_END
+
 COMMENT_START
  NETWORK OPTIONS
  -----------------------------------------------------------------------------
@@ -1820,7 +1877,7 @@ DOC_START
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 
-			    SSL_OP_NO_TICKET
+			    NO_TICKET
 				      Disable use of RFC5077 session tickets.
 				      Some servers may have problems
 				      understanding the TLS extension due
@@ -3363,53 +3420,20 @@ DOC_START
 	
 DOC_END
 
-NAME: cache_peer_domain cache_host_domain
-TYPE: hostdomain
-DEFAULT: none
-LOC: none
-DOC_START
-	Use to limit the domains for which a neighbor cache will be
-	queried.
-
-	Usage:
-		cache_peer_domain cache-host domain [domain ...]
-		cache_peer_domain cache-host !domain
-
-	For example, specifying
-
-		cache_peer_domain parent.foo.net	.edu
-
-	has the effect such that UDP query packets are sent to
-	'bigserver' only when the requested object exists on a
-	server in the .edu domain.  Prefixing the domainname
-	with '!' means the cache will be queried for objects
-	NOT in that domain.
-
-	NOTE:	* Any number of domains may be given for a cache-host,
-		  either on the same or separate lines.
-		* When multiple domains are given for a particular
-		  cache-host, the first matched domain is applied.
-		* Cache hosts with no domain restrictions are queried
-		  for all requests.
-		* There are no defaults.
-		* There is also a 'cache_peer_access' tag in the ACL
-		  section.
-DOC_END
-
 NAME: cache_peer_access
 TYPE: peer_access
 DEFAULT: none
 LOC: none
 DOC_START
-	Similar to 'cache_peer_domain' but provides more flexibility by
-	using ACL elements.
+	Use to limit the requests for which a neighbor proxy will be
+	queried. Peers with no restrictions are queried for all requests.
 
 	Usage:
 		cache_peer_access cache-host allow|deny [!]aclname ...
 
 	The syntax is identical to 'http_access' and the other lists of
-	ACL elements.  See the comments for 'http_access' below, or
-	the Squid FAQ (http://wiki.squid-cache.org/SquidFaq/SquidAcl).
+	ACL elements.  See the comments for 'http_access', or the
+	Squid FAQ (http://wiki.squid-cache.org/SquidFaq/SquidAcl).
 DOC_END
 
 NAME: neighbor_type_domain
@@ -4277,6 +4301,15 @@ DOC_START
 				support has not been tested for modules other
 				than tcp.
 
+	rotate=N		Specifies the number of log file rotations to
+				make when you run 'squid -k rotate'. The default
+				is to obey the logfile_rotate directive. Setting
+				rotate=0 will disable the file name rotation,
+				but the log files are still closed and re-opened.
+				This will enable you to rename the logfiles
+				yourself just before sending the rotate signal.
+				Only supported by the stdio module.
+
 	===== Modules Currently available =====
 	
 	none	Do not log any requests matching these ACL.
@@ -4497,22 +4530,27 @@ TYPE: int
 DEFAULT: 10
 LOC: Config.Log.rotateNumber
 DOC_START
-	Specifies the number of logfile rotations to make when you
+	Specifies the default number of logfile rotations to make when you
 	type 'squid -k rotate'. The default is 10, which will rotate
 	with extensions 0 through 9. Setting logfile_rotate to 0 will
 	disable the file name rotation, but the logfiles are still closed
 	and re-opened. This will enable you to rename the logfiles
 	yourself just before sending the rotate signal.
 
+	Note, from Squid-3.1 this option is only a default for cache.log,
+	that log can be rotated separately by using debug_options.
+
+	Note, from Squid-3.6 this option is only a default for access.log
+	recorded by stdio: module. Those logs can be rotated separately by
+	using the rotate=N option on their access_log directive.
+
 	Note, the 'squid -k rotate' command normally sends a USR1
 	signal to the running squid process.  In certain situations
 	(e.g. on Linux with Async I/O), USR1 is used for other
 	purposes, so -k rotate uses another signal.  It is best to get
 	in the habit of using 'squid -k rotate' instead of 'kill -USR1
 	<pid>'.
 
-	Note, from Squid-3.1 this option is only a default for cache.log,
-	that log can be rotated separately by using debug_options.
 DOC_END
 
 NAME: mime_table
@@ -5687,33 +5725,6 @@ DOC_START
 	a large file.
 DOC_END
 
-NAME: chunked_request_body_max_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 64 KB
-LOC: Config.maxChunkedRequestBodySize
-DOC_START
-	A broken or confused HTTP/1.1 client may send a chunked HTTP
-	request to Squid. Squid does not have full support for that
-	feature yet. To cope with such requests, Squid buffers the
-	entire request and then dechunks request body to create a
-	plain HTTP/1.0 request with a known content length. The plain
-	request is then used by the rest of Squid code as usual.
-
-	The option value specifies the maximum size of the buffer used
-	to hold the request before the conversion. If the chunked
-	request size exceeds the specified limit, the conversion
-	fails, and the client receives an "unsupported request" error,
-	as if dechunking was disabled.
-
-	Dechunking is enabled by default. To disable conversion of
-	chunked requests, set the maximum to zero.
-
-	Request dechunking feature and this option in particular are a
-	temporary hack. When chunking requests and responses are fully
-	supported, there will be no need to buffer a chunked request.
-DOC_END
-
 NAME: broken_posts
 IFDEF: USE_HTTP_VIOLATIONS
 TYPE: acl_access
@@ -6156,6 +6167,15 @@ DOC_START
 	connection establishment.
 DOC_END
 
+NAME: request_start_timeout
+TYPE: time_t
+LOC: Config.Timeout.request_start_timeout
+DEFAULT: 5 minutes
+DOC_START
+	How long to wait for the first request byte after initial
+	connection establishment.
+DOC_END
+
 NAME: client_idle_pconn_timeout persistent_request_timeout
 TYPE: time_t
 LOC: Config.Timeout.clientIdlePconn
@@ -44,7 +44,7 @@
  \par
  * Each node including the HEAD of the clientStream has a cbdataReference
  * held by the stream. Freeing the stream then removes that reference
- * and cbdataFree()'s every node.
+ * and delete's every node.
  * Any node with other References, and all nodes downstream will only
  * free when those references are released.
  * Stream nodes MAY hold references to the data member of the node.
@@ -72,34 +72,30 @@
  \code
    mycontext = thisObject->data;
    thisObject->data = NULL;
-   clientStreamFree (thisObject->head);
+   delete thisObject->head;
    mycontext = NULL;
    return;
  \endcode
  *
  \todo rather than each node undeleting the next, have a clientStreamDelete that walks the list.
  */
 
-/// \ingroup ClientStreamInternal
-CBDATA_TYPE(clientStreamNode);
+CBDATA_CLASS_INIT(clientStreamNode);
 
-/* Local functions */
-static FREE clientStreamFree;
+clientStreamNode::clientStreamNode(CSR * aReadfunc, CSCB * aCallback, CSD * aDetach, CSS * aStatus, ClientStreamData aData) :
+    readfunc(aReadfunc),
+    callback(aCallback),
+    detach(aDetach),
+    status(aStatus),
+    data(aData)
+{}
 
-/// \ingroup ClientStreamInternal
-clientStreamNode *
-clientStreamNew(CSR * readfunc, CSCB * callback, CSD * detach, CSS * status,
-                ClientStreamData data)
+clientStreamNode::~clientStreamNode()
 {
-    clientStreamNode *temp;
-    CBDATA_INIT_TYPE_FREECB(clientStreamNode, clientStreamFree);
-    temp = cbdataAlloc(clientStreamNode);
-    temp->readfunc = readfunc;
-    temp->callback = callback;
-    temp->detach = detach;
-    temp->status = status;
-    temp->data = data;
-    return temp;
+    debugs(87, 3, "Freeing clientStreamNode " << this);
+
+    removeFromStream();
+    data = NULL;
 }
 
 /**
@@ -115,8 +111,7 @@ clientStreamInit(dlink_list * list, CSR * func, CSD * rdetach, CSS * readstatus,
                  ClientStreamData readdata, CSCB * callback, CSD * cdetach, ClientStreamData callbackdata,
                  StoreIOBuffer tailBuffer)
 {
-    clientStreamNode *temp = clientStreamNew(func, NULL, rdetach, readstatus,
-                             readdata);
+    clientStreamNode *temp = new clientStreamNode(func, NULL, rdetach, readstatus, readdata);
     dlinkAdd(cbdataReference(temp), &temp->node, list);
     temp->head = list;
     clientStreamInsertHead(list, NULL, callback, cdetach, NULL, callbackdata);
@@ -134,11 +129,10 @@ void
 clientStreamInsertHead(dlink_list * list, CSR * func, CSCB * callback,
                        CSD * detach, CSS * status, ClientStreamData data)
 {
-
     /* test preconditions */
     assert(list != NULL);
     assert(list->head);
-    clientStreamNode *temp = clientStreamNew(func, callback, detach, status, data);
+    clientStreamNode *temp = new clientStreamNode(func, callback, detach, status, data);
     temp->head = list;
     debugs(87, 3, "clientStreamInsertHead: Inserted node " << temp <<
            " with data " << data.getRaw() << " after head");
@@ -211,7 +205,7 @@ clientStreamDetach(clientStreamNode * thisObject, ClientHttpRequest * http)
 
     cbdataReferenceDone(temp);
 
-    cbdataFree(thisObject);
+    delete thisObject;
 
     /* and tell the prev that the detach has occured */
     /*
@@ -267,8 +261,6 @@ clientStreamStatus(clientStreamNode * thisObject, ClientHttpRequest * http)
     return prev->status(prev, http);
 }
 
-/* Local function bodies */
-
 void
 clientStreamNode::removeFromStream()
 {
@@ -278,18 +270,6 @@ clientStreamNode::removeFromStream()
     head = NULL;
 }
 
-/// \ingroup ClientStreamInternal
-void
-clientStreamFree(void *foo)
-{
-    clientStreamNode *thisObject = (clientStreamNode *)foo;
-
-    debugs(87, 3, "Freeing clientStreamNode " << thisObject);
-
-    thisObject->removeFromStream();
-    thisObject->data = NULL;
-}
-
 clientStreamNode *
 clientStreamNode::prev() const
 {
@@ -73,14 +73,18 @@
  \li        Because of the callback nature of squid, every node would have to keep these parameters in their context anyway, so this reduces programmer overhead.
  */
 
-/// \ingroup ClientStreamAPI
 class clientStreamNode
 {
+    CBDATA_CLASS(clientStreamNode);
 
 public:
+    clientStreamNode(CSR * aReadfunc, CSCB * aCallback, CSD * aDetach, CSS * aStatus, ClientStreamData);
+    ~clientStreamNode();
+
     clientStreamNode *prev() const;
     clientStreamNode *next() const;
     void removeFromStream();
+
     dlink_node node;
     dlink_list *head;       /* sucks I know, but hey, the interface is limited */
     CSR *readfunc;
@@ -97,9 +101,6 @@ void clientStreamInit(dlink_list *, CSR *, CSD *, CSS *, ClientStreamData, CSCB
 /// \ingroup ClientStreamAPI
 void clientStreamInsertHead(dlink_list *, CSR *, CSCB *, CSD *, CSS *, ClientStreamData);
 
-/// \ingroup ClientStreamAPI
-clientStreamNode *clientStreamNew(CSR *, CSCB *, CSD *, CSS *, ClientStreamData);
-
 /**
  \ingroup ClientStreamAPI
  *
@@ -623,15 +623,16 @@ ClientHttpRequest::logRequest()
 
 #endif
 
-    /*Add notes*/
-    // The al->notes and request->notes must point to the same object.
-    (void)SyncNotes(*al, *request);
-    typedef Notes::iterator ACAMLI;
-    for (ACAMLI i = Config.notes.begin(); i != Config.notes.end(); ++i) {
-        if (const char *value = (*i)->match(request, al->reply, NULL)) {
-            NotePairs &notes = SyncNotes(*al, *request);
-            notes.add((*i)->key.termedBuf(), value);
-            debugs(33, 3, HERE << (*i)->key.termedBuf() << " " << value);
+    /* Add notes (if we have a request to annotate) */
+    if (request) {
+        // The al->notes and request->notes must point to the same object.
+        (void)SyncNotes(*al, *request);
+        for (auto i = Config.notes.begin(); i != Config.notes.end(); ++i) {
+            if (const char *value = (*i)->match(request, al->reply, NULL)) {
+                NotePairs &notes = SyncNotes(*al, *request);
+                notes.add((*i)->key.termedBuf(), value);
+                debugs(33, 3, (*i)->key.termedBuf() << " " << value);
+            }
         }
     }
 
@@ -2152,6 +2153,8 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
     {
         const bool parsedOk = hp->parse(csd->in.buf);
 
+        if (csd->port->flags.isIntercepted() && Config.accessList.on_unsupported_protocol)
+            csd->preservedClientData = csd->in.buf;
         // sync the buffers after parsing.
         csd->in.buf = hp->remaining();
 
@@ -2457,6 +2460,62 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
 }
 #endif // USE_OPENSSL
 
+/**
+ * Check on_unsupported_protocol checklist and return true if tunnel mode selected
+ * or false otherwise
+ */
+bool
+clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
+{
+    if (conn->port->flags.isIntercepted() &&
+            Config.accessList.on_unsupported_protocol && conn->nrequests <= 1) {
+        ACLFilledChecklist checklist(Config.accessList.on_unsupported_protocol, request, NULL);
+        checklist.requestErrorType = requestError;
+        checklist.src_addr = conn->clientConnection->remote;
+        checklist.my_addr = conn->clientConnection->local;
+        checklist.conn(conn);
+        allow_t answer = checklist.fastCheck();
+        if (answer == ACCESS_ALLOWED && answer.kind == 1) {
+            debugs(33, 3, "Request will be tunneled to server");
+            if (context)
+                context->removeFromConnectionList(conn);
+            Comm::SetSelect(conn->clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
+
+            SBuf preReadData;
+            if (conn->preservedClientData.length())
+                preReadData.append(conn->preservedClientData);
+            static char ip[MAX_IPSTRLEN];
+            conn->clientConnection->local.toUrl(ip, sizeof(ip));
+            conn->in.buf.assign("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n").append(preReadData);
+
+            bool ret = conn->handleReadData();
+            if (ret)
+                ret = conn->clientParseRequests();
+
+            if (!ret) {
+                debugs(33, 2, "Failed to start fake CONNECT request for on_unsupported_protocol: " << conn->clientConnection);
+                conn->clientConnection->close();
+            }
+            return true;
+        } else {
+            debugs(33, 3, "Continue with returning the error: " << requestError);
+        }
+    }
+
+    if (context) {
+        conn->quitAfterError(request);
+        clientStreamNode *node = context->getClientReplyContext();
+        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert (repContext);
+
+        repContext->setReplyToError(requestError, errStatusCode, method, context->http->uri, conn->clientConnection->remote, NULL, requestErrorBytes, NULL);
+
+        assert(context->http->out.offset == 0);
+        context->pullData();
+    } // else Probably an ERR_REQUEST_START_TIMEOUT error so just return.
+    return false;
+}
+
 void
 clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request)
 {
@@ -2605,23 +2664,6 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
         return;
     }
 
-    if (request->header.has(HDR_EXPECT)) {
-        const String expect = request->header.getList(HDR_EXPECT);
-        const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
-        if (!supportedExpect) {
-            clientStreamNode *node = context->getClientReplyContext();
-            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-            assert (repContext);
-            conn->quitAfterError(request.getRaw());
-            repContext->setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request->method, http->uri,
-                                        conn->clientConnection->remote, request.getRaw(), NULL, NULL);
-            assert(context->http->out.offset == 0);
-            context->pullData();
-            clientProcessRequestFinished(conn, request);
-            return;
-        }
-    }
-
     clientSetKeepaliveFlag(http);
     // Let tunneling code be fully responsible for CONNECT requests
     if (http->request->method == Http::METHOD_CONNECT) {
@@ -2699,7 +2741,12 @@ ConnStateData::concurrentRequestQueueFilled() const
 
     // default to the configured pipeline size.
     // add 1 because the head of pipeline is counted in concurrent requests and not prefetch queue
-    const int concurrentRequestLimit = pipelinePrefetchMax() + 1;
+#if USE_OPENSSL
+    const int internalRequest = (transparent() && sslBumpMode == Ssl::bumpSplice) ? 1 : 0;
+#else
+    const int internalRequest = 0;
+#endif
+    const int concurrentRequestLimit = pipelinePrefetchMax() + 1 + internalRequest;
 
     // when queue filled already we cant add more.
     if (existingRequestCount >= concurrentRequestLimit) {
@@ -2976,6 +3023,20 @@ ConnStateData::parseProxy2p0()
     return true;
 }
 
+void
+ConnStateData::receivedFirstByte()
+{
+    if (receivedFirstByte_)
+        return;
+
+    receivedFirstByte_ = true;
+    // Set timeout to Config.Timeout.request
+    typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
+                                      TimeoutDialer, this, ConnStateData::requestTimeout);
+    commSetConnTimeout(clientConnection, Config.Timeout.request, timeoutCall);
+}
+
 /**
  * Attempt to parse one or more requests from the input buffer.
  * Returns true after completing parsing of at least one request [header]. That
@@ -3073,6 +3134,8 @@ ConnStateData::clientReadRequest(const CommIoCbParams &io)
 
     case Comm::OK:
         kb_incr(&(statCounter.client_http.kbytes_in), rd.size);
+        if (!receivedFirstByte_)
+            receivedFirstByte();
         // may comm_close or setReplyToError
         if (!handleReadData())
             return;
@@ -3294,6 +3357,24 @@ ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer )
 void
 ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
 {
+    if (Config.accessList.on_unsupported_protocol && !receivedFirstByte_) {
+#if USE_OPENSSL
+        if (serverBump() && (serverBump()->act.step1 == Ssl::bumpPeek || serverBump()->act.step1 == Ssl::bumpStare)) {
+            if (spliceOnError(ERR_REQUEST_START_TIMEOUT)) {
+                receivedFirstByte();
+                return;
+            }
+        } else if (fd_table[io.conn->fd].ssl == NULL)
+#endif
+        {
+            const HttpRequestMethod method;
+            if (clientTunnelOnError(this, NULL, NULL, method, ERR_REQUEST_START_TIMEOUT, Http::scNone, NULL)) {
+                // Tunnel established. Set receivedFirstByte to avoid loop.
+                receivedFirstByte();
+                return;
+            }
+        }
+    }
     /*
     * Just close the connection to not confuse browsers
     * using persistent connections. Some browsers open
@@ -3330,7 +3411,8 @@ ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
     signAlgorithm(Ssl::algSignTrusted),
 #endif
     stoppedSending_(NULL),
-    stoppedReceiving_(NULL)
+    stoppedReceiving_(NULL),
+    receivedFirstByte_(false)
 {
     flags.readMore = true; // kids may overwrite
     flags.swanSang = false;
@@ -3490,7 +3572,13 @@ httpsCreate(const Comm::ConnectionPointer &conn, SSL_CTX *sslContext)
     return NULL;
 }
 
-static bool
+/**
+ *
+ * \retval 1 on success
+ * \retval 0 when needs more data
+ * \retval -1 on error
+ */
+static int
 Squid_SSL_accept(ConnStateData *conn, PF *callback)
 {
     int fd = conn->clientConnection->fd;
@@ -3504,18 +3592,16 @@ Squid_SSL_accept(ConnStateData *conn, PF *callback)
 
         case SSL_ERROR_WANT_READ:
             Comm::SetSelect(fd, COMM_SELECT_READ, callback, conn, 0);
-            return false;
+            return 0;
 
         case SSL_ERROR_WANT_WRITE:
             Comm::SetSelect(fd, COMM_SELECT_WRITE, callback, conn, 0);
-            return false;
+            return 0;
 
         case SSL_ERROR_SYSCALL:
 
             if (ret == 0) {
                 debugs(83, 2, "Error negotiating SSL connection on FD " << fd << ": Aborted by client: " << ssl_error);
-                comm_close(fd);
-                return false;
             } else {
                 int hard = 1;
 
@@ -3524,28 +3610,23 @@ Squid_SSL_accept(ConnStateData *conn, PF *callback)
 
                 debugs(83, hard ? 1 : 2, "Error negotiating SSL connection on FD " <<
                        fd << ": " << strerror(errno) << " (" << errno << ")");
-
-                comm_close(fd);
-
-                return false;
             }
+            return -1;
 
         case SSL_ERROR_ZERO_RETURN:
             debugs(83, DBG_IMPORTANT, "Error negotiating SSL connection on FD " << fd << ": Closed by client");
-            comm_close(fd);
-            return false;
+            return -1;
 
         default:
             debugs(83, DBG_IMPORTANT, "Error negotiating SSL connection on FD " <<
                    fd << ": " << ERR_error_string(ERR_get_error(), NULL) <<
                    " (" << ssl_error << "/" << ret << ")");
-            comm_close(fd);
-            return false;
+            return -1;
         }
 
         /* NOTREACHED */
     }
-    return true;
+    return 1;
 }
 
 /** negotiate an SSL connection */
@@ -3556,8 +3637,12 @@ clientNegotiateSSL(int fd, void *data)
     X509 *client_cert;
     SSL *ssl = fd_table[fd].ssl;
 
-    if (!Squid_SSL_accept(conn, clientNegotiateSSL))
+    int ret;
+    if ((ret = Squid_SSL_accept(conn, clientNegotiateSSL)) <= 0) {
+        if (ret < 0) // An error
+            comm_close(fd);
         return;
+    }
 
     if (SSL_session_reused(ssl)) {
         debugs(83, 2, "clientNegotiateSSL: Session " << SSL_get_session(ssl) <<
@@ -4063,6 +4148,23 @@ ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode)
     getSslContextStart();
 }
 
+bool
+ConnStateData::spliceOnError(const err_type err)
+{
+    if (Config.accessList.on_unsupported_protocol) {
+        assert(serverBump());
+        ACLFilledChecklist checklist(Config.accessList.on_unsupported_protocol, serverBump()->request.getRaw(), NULL);
+        checklist.requestErrorType = err;
+        checklist.conn(this);
+        allow_t answer = checklist.fastCheck();
+        if (answer == ACCESS_ALLOWED && answer.kind == 1) {
+            splice();
+            return true;
+        }
+    }
+    return false;
+}
+
 /** negotiate an SSL connection */
 static void
 clientPeekAndSpliceSSL(int fd, void *data)
@@ -4072,12 +4174,23 @@ clientPeekAndSpliceSSL(int fd, void *data)
 
     debugs(83, 5, "Start peek and splice on FD " << fd);
 
-    if (!Squid_SSL_accept(conn, clientPeekAndSpliceSSL))
+    int ret = 0;
+    if ((ret = Squid_SSL_accept(conn, clientPeekAndSpliceSSL)) < 0)
         debugs(83, 2, "SSL_accept failed.");
 
     BIO *b = SSL_get_rbio(ssl);
     assert(b);
     Ssl::ClientBio *bio = static_cast<Ssl::ClientBio *>(b->ptr);
+    if (ret < 0) {
+        const err_type err = bio->noSslClient() ? ERR_PROTOCOL_UNKNOWN : ERR_SECURE_ACCEPT_FAIL;
+        if (!conn->spliceOnError(err))
+            conn->clientConnection->close();
+        return;
+    }
+
+    if (bio->rBufData().contentSize() > 0)
+        conn->receivedFirstByte();
+
     if (bio->gotHello()) {
         if (conn->serverBump()) {
             Ssl::Bio::sslFeatures const &features = bio->getFeatures();
@@ -4103,6 +4216,14 @@ void ConnStateData::startPeekAndSplice()
         return;
 
     // commSetConnTimeout() was called for this request before we switched.
+    // Fix timeout to request_start_timeout
+    typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
+                                      TimeoutDialer, this, ConnStateData::requestTimeout);
+    commSetConnTimeout(clientConnection, Config.Timeout.request_start_timeout, timeoutCall);
+    // Also reset receivedFirstByte_ flag to allow this timeout work in the case we have
+    // a bumbed "connect" request on non transparent port.
+    receivedFirstByte_ = false;
 
     // Disable the client read handler until CachePeer selection is complete
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
@@ -4143,44 +4264,49 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
         comm_close(connState->clientConnection->fd);
     } else if (bumpAction != Ssl::bumpSplice) {
         connState->startPeekAndSpliceDone();
-    } else {
-        //Normally we can splice here, because we just got client hello message
-        SSL *ssl = fd_table[connState->clientConnection->fd].ssl;
-        BIO *b = SSL_get_rbio(ssl);
-        Ssl::ClientBio *bio = static_cast<Ssl::ClientBio *>(b->ptr);
-        MemBuf const &rbuf = bio->rBufData();
-        debugs(83,5, "Bio for  " << connState->clientConnection << " read " << rbuf.contentSize() << " helo bytes");
-        // Do splice:
-        fd_table[connState->clientConnection->fd].read_method = &default_read_method;
-        fd_table[connState->clientConnection->fd].write_method = &default_write_method;
-
-        if (connState->transparent()) {
-            // set the current protocol to something sensible (was "HTTPS" for the bumping process)
-            // we are sending a faked-up HTTP/1.1 message wrapper, so go with that.
-            connState->transferProtocol = Http::ProtocolVersion();
-            // fake a CONNECT request to force connState to tunnel
-            static char ip[MAX_IPSTRLEN];
-            connState->clientConnection->local.toUrl(ip, sizeof(ip));
-            connState->in.buf.assign("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n").append(rbuf.content(), rbuf.contentSize());
-            bool ret = connState->handleReadData();
-            if (ret)
-                ret = connState->clientParseRequests();
+    } else
+        connState->splice();
+}
 
-            if (!ret) {
-                debugs(33, 2, "Failed to start fake CONNECT request for ssl spliced connection: " << connState->clientConnection);
-                connState->clientConnection->close();
-            }
-        } else {
-            // XXX: assuming that there was an HTTP/1.1 CONNECT to begin with...
-
-            // reset the current protocol to HTTP/1.1 (was "HTTPS" for the bumping process)
-            connState->transferProtocol = Http::ProtocolVersion();
-            // in.buf still has the "CONNECT ..." request data, reset it to SSL hello message
-            connState->in.buf.append(rbuf.content(), rbuf.contentSize());
-            ClientSocketContext::Pointer context = connState->getCurrentContext();
-            ClientHttpRequest *http = context->http;
-            tunnelStart(http, &http->out.size, &http->al->http.code, http->al);
+void
+ConnStateData::splice()
+{
+    //Normally we can splice here, because we just got client hello message
+    SSL *ssl = fd_table[clientConnection->fd].ssl;
+    BIO *b = SSL_get_rbio(ssl);
+    Ssl::ClientBio *bio = static_cast<Ssl::ClientBio *>(b->ptr);
+    MemBuf const &rbuf = bio->rBufData();
+    debugs(83,5, "Bio for  " << clientConnection << " read " << rbuf.contentSize() << " helo bytes");
+    // Do splice:
+    fd_table[clientConnection->fd].read_method = &default_read_method;
+    fd_table[clientConnection->fd].write_method = &default_write_method;
+
+    if (transparent()) {
+        // set the current protocol to something sensible (was "HTTPS" for the bumping process)
+        // we are sending a faked-up HTTP/1.1 message wrapper, so go with that.
+        transferProtocol = Http::ProtocolVersion();
+        // fake a CONNECT request to force connState to tunnel
+        static char ip[MAX_IPSTRLEN];
+        clientConnection->local.toUrl(ip, sizeof(ip));
+        in.buf.assign("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n").append(rbuf.content(), rbuf.contentSize());
+        bool ret = handleReadData();
+        if (ret)
+            ret = clientParseRequests();
+
+        if (!ret) {
+            debugs(33, 2, "Failed to start fake CONNECT request for ssl spliced connection: " << clientConnection);
+            clientConnection->close();
         }
+    } else {
+        // XXX: assuming that there was an HTTP/1.1 CONNECT to begin with...
+
+        // reset the current protocol to HTTP/1.1 (was "HTTPS" for the bumping process)
+        transferProtocol = Http::ProtocolVersion();
+        // in.buf still has the "CONNECT ..." request data, reset it to SSL hello message
+        in.buf.append(rbuf.content(), rbuf.contentSize());
+        ClientSocketContext::Pointer context = getCurrentContext();
+        ClientHttpRequest *http = context->http;
+        tunnelStart(http, &http->out.size, &http->al->http.code, http->al);
     }
 }
 
@@ -187,6 +187,9 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     int getConcurrentRequestCount() const;
     bool isOpen() const;
 
+    /// Update flags and timeout after the first byte received
+    void receivedFirstByte();
+
     // HttpControlMsgSink API
     virtual void sendControlMsg(HttpControlMsg msg);
 
@@ -347,6 +350,14 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /// called by FwdState when it is done bumping the server
     void httpsPeeked(Comm::ConnectionPointer serverConnection);
 
+    /// Splice a bumped client connection on peek-and-splice mode
+    void splice();
+
+    /// Check on_unsupported_protocol access list and splice if required
+    /// \retval true on splice
+    /// \retval false otherwise
+    bool spliceOnError(const err_type err);
+
     /// Start to create dynamic SSL_CTX for host or uses static port SSL context.
     void getSslContextStart();
     /**
@@ -403,6 +414,9 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     /// stop parsing the request and create context for relaying error info
     ClientSocketContext *abortRequestParsing(const char *const errUri);
 
+    /// client data which may need to forward as-is to server after an
+    /// on_unsupported_protocol tunnel decision.
+    SBuf preservedClientData;
 protected:
     void startDechunkingRequest();
     void finishDechunkingRequest(bool withSuccess);
@@ -472,6 +486,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
 
     AsyncCall::Pointer reader; ///< set when we are reading
 
+    bool receivedFirstByte_; ///< true if at least one byte received on this connection
     SBuf connectionTag_; ///< clt_conn_tag=Tag annotation for client connection
 };
 
@@ -500,14 +500,14 @@ clientFollowXForwardedForCheck(allow_t answer, void *data)
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
 static void
-hostHeaderIpVerifyWrapper(const ipcache_addrs* ia, const DnsLookupDetails &dns, void *data)
+hostHeaderIpVerifyWrapper(const ipcache_addrs* ia, const Dns::LookupDetails &dns, void *data)
 {
     ClientRequestContext *c = static_cast<ClientRequestContext*>(data);
     c->hostHeaderIpVerify(ia, dns);
 }
 
 void
-ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLookupDetails &dns)
+ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
 {
     Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;
 
@@ -1082,44 +1082,30 @@ commSetTcpRcvbuf(int fd, int size)
 int
 commSetNonBlocking(int fd)
 {
-#if !_SQUID_WINDOWS_
-    int flags;
-    int dummy = 0;
-#endif
 #if _SQUID_WINDOWS_
     int nonblocking = TRUE;
 
-#if _SQUID_CYGWIN_
-    if (fd_table[fd].type != FD_PIPE) {
-#endif
-
-        if (ioctl(fd, FIONBIO, &nonblocking) < 0) {
-            debugs(50, 0, "commSetNonBlocking: FD " << fd << ": " << xstrerror() << " " << fd_table[fd].type);
-            return Comm::COMM_ERROR;
-        }
-
-#if _SQUID_CYGWIN_
-    } else {
-#endif
-#endif
-#if !_SQUID_WINDOWS_
+    if (ioctl(fd, FIONBIO, &nonblocking) < 0) {
+        debugs(50, 0, "commSetNonBlocking: FD " << fd << ": " << xstrerror() << " " << fd_table[fd].type);
+        return Comm::COMM_ERROR;
+    }
 
-        if ((flags = fcntl(fd, F_GETFL, dummy)) < 0) {
-            debugs(50, 0, "FD " << fd << ": fcntl F_GETFL: " << xstrerror());
-            return Comm::COMM_ERROR;
-        }
+#else
+    int flags;
+    int dummy = 0;
 
-        if (fcntl(fd, F_SETFL, flags | SQUID_NONBLOCK) < 0) {
-            debugs(50, 0, "commSetNonBlocking: FD " << fd << ": " << xstrerror());
-            return Comm::COMM_ERROR;
-        }
+    if ((flags = fcntl(fd, F_GETFL, dummy)) < 0) {
+        debugs(50, 0, "FD " << fd << ": fcntl F_GETFL: " << xstrerror());
+        return Comm::COMM_ERROR;
+    }
 
-#endif
-#if _SQUID_CYGWIN_
+    if (fcntl(fd, F_SETFL, flags | SQUID_NONBLOCK) < 0) {
+        debugs(50, 0, "commSetNonBlocking: FD " << fd << ": " << xstrerror());
+        return Comm::COMM_ERROR;
     }
 #endif
-    fd_table[fd].flags.nonblocking = true;
 
+    fd_table[fd].flags.nonblocking = true;
     return 0;
 }
 
@@ -9,19 +9,10 @@
 /* DEBUG: section 78    DNS lookups */
 
 #include "squid.h"
-#include "DnsLookupDetails.h"
-
-DnsLookupDetails::DnsLookupDetails(): wait(-1)
-{
-}
-
-DnsLookupDetails::DnsLookupDetails(const String &e, int w):
-    error(e), wait(w)
-{
-}
+#include "dns/LookupDetails.h"
 
 std::ostream &
-DnsLookupDetails::print(std::ostream &os) const
+Dns::LookupDetails::print(std::ostream &os) const
 {
     if (wait > 0)
         os << "lookup_wait=" << wait;
@@ -8,30 +8,35 @@
 
 /* DEBUG: section 78    DNS lookups */
 
-#ifndef SQUID_DNS_LOOKUP_DETAILS_H
-#define SQUID_DNS_LOOKUP_DETAILS_H
+#ifndef SQUID_DNS_LOOKUPDETAILS_H
+#define SQUID_DNS_LOOKUPDETAILS_H
 
 #include "SquidString.h"
 
+namespace Dns
+{
+
 /// encapsulates DNS lookup results
-class DnsLookupDetails
+class LookupDetails
 {
 public:
-    DnsLookupDetails(); ///< no error, no lookup delay (i.e., no lookup)
-    DnsLookupDetails(const String &error, int wait);
+    LookupDetails() : wait(-1) {} ///< no error, no lookup delay (i.e., no lookup)
+    LookupDetails(const String &anError, int aWait) : error(anError), wait(aWait) {}
 
     std::ostream &print(std::ostream &os) const;
 
 public:
-    String error; ///< error message for unsuccessdul lookups; empty otherwise
+    String error; ///< error message for unsuccessful lookups; empty otherwise
     int wait; ///< msecs spent waiting for the lookup (if any) or -1 (if none)
 };
 
-inline
-std::ostream &operator << (std::ostream &os, const DnsLookupDetails &dns)
+} // namespace Dns
+
+inline std::ostream &
+operator <<(std::ostream &os, const Dns::LookupDetails &dns)
 {
     return dns.print(os);
 }
 
-#endif
+#endif /* SQUID_DNS_LOOKUPDETAILS_H */
 
@@ -0,0 +1,24 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+AUTOMAKE_OPTIONS = subdir-objects
+
+noinst_LTLIBRARIES = libdns.la
+
+libdns_la_SOURCES = \
+	forward.h \
+	LookupDetails.cc \
+	LookupDetails.h \
+	rfc1035.cc \
+	rfc1035.h \
+	rfc2671.cc \
+	rfc2671.h \
+	rfc3596.cc \
+	rfc3596.h
@@ -6,21 +6,32 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_DNS_H
-#define SQUID_DNS_H
+#ifndef _SQUID_SRC_DNS_FORWARD_H
+#define _SQUID_SRC_DNS_FORWARD_H
 
 namespace Ip
 {
 class Address;
 }
 
+class rfc1035_rr;
+
+typedef void IDNSCB(void *, const rfc1035_rr *, int, const char *);
+
 // generic DNS API
-void dnsInit(void);
-void dnsShutdown(void);
+namespace Dns
+{
+
+class LookupDetails;
+
+void Init(void);
+void Shutdown(void);
+
+} // namespace Dns
 
 // internal DNS client API
 void idnsALookup(const char *, IDNSCB *, void *);
 void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
 
-#endif /* SQUID_DNS_H */
+#endif /* _SQUID_SRC_DNS_FORWARD_H */
 
@@ -15,6 +15,8 @@
  */
 
 #include "squid.h"
+#include "dns/rfc1035.h"
+#include "dns/rfc2671.h"
 #include "util.h"
 
 #if HAVE_STRING_H
@@ -39,9 +41,6 @@
 #include <strings.h>
 #endif
 
-#include "rfc1035.h"
-#include "rfc2671.h"
-
 #define RFC1035_MAXLABELSZ 63
 #define rfc1035_unpack_error 15
 
@@ -33,8 +33,9 @@
 
 #define RFC1035_DEFAULT_PACKET_SZ 512
 
-typedef struct _rfc1035_rr rfc1035_rr;
-struct _rfc1035_rr {
+class rfc1035_rr
+{
+public:
     char name[RFC1035_MAXHOSTNAMESZ];
     unsigned short type;
     unsigned short _class;
@@ -7,8 +7,8 @@
  */
 
 #include "squid.h"
-#include "rfc1035.h"
-#include "rfc2671.h"
+#include "dns/rfc1035.h"
+#include "dns/rfc2671.h"
 
 int
 rfc2671RROptPack(char *buf, size_t sz, ssize_t edns_sz)
@@ -7,6 +7,8 @@
  */
 
 #include "squid.h"
+#include "dns/rfc2671.h"
+#include "dns/rfc3596.h"
 #include "util.h"
 
 #if HAVE_UNISTD_H
@@ -25,9 +27,6 @@
 #include <strings.h>
 #endif
 
-#include "rfc2671.h"
-#include "rfc3596.h"
-
 #ifndef SQUID_RFC1035_H
 #error RFC3596 Library depends on RFC1035
 #endif
@@ -10,7 +10,7 @@
 #define SQUID_RFC3596_H
 
 /* RFC 3596 extends RFC 1035 */
-#include "rfc1035.h"
+#include "dns/rfc1035.h"
 
 SQUIDCEXTERN ssize_t rfc3596BuildAQuery(const char *hostname,
                                         char *buf,
@@ -6,7 +6,7 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-/* DEBUG: section 78    DNS lookups; interacts with lib/rfc1035.c */
+/* DEBUG: section 78    DNS lookups; interacts with dns/rfc1035.cc */
 
 #include "squid.h"
 #include "base/InstanceId.h"
@@ -17,13 +17,14 @@
 #include "comm/Read.h"
 #include "comm/Write.h"
 #include "dlink.h"
+#include "dns/forward.h"
+#include "dns/rfc3596.h"
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
-#include "rfc3596.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -93,15 +94,54 @@ static const char *Rcodes[] = {
     "Bad OPT Version or TSIG Signature Failure"
 };
 
-typedef struct _idns_query idns_query;
-
 typedef struct _ns ns;
 
 typedef struct _sp sp;
 
-typedef struct _nsvc nsvc;
+class idns_query
+{
+    CBDATA_CLASS(idns_query);
+
+public:
+    idns_query() :
+        sz(0),
+        query_id(0),
+        nsends(0),
+        need_vc(0),
+        permit_mdns(false),
+        pending(0),
+        callback(NULL),
+        callback_data(NULL),
+        attempt(0),
+        rcode(0),
+        queue(NULL),
+        slave(NULL),
+        master(NULL),
+        domain(0),
+        do_searchpath(0),
+        message(NULL),
+        ancount(0),
+        error(NULL)
+    {
+        memset(&hash, 0, sizeof(hash));
+        memset(&query, 0, sizeof(query));
+        *buf = 0;
+        *name = 0;
+        *orig = 0;
+        memset(&start_t, 0, sizeof(start_t));
+        memset(&sent_t, 0, sizeof(sent_t));
+        memset(&queue_t, 0, sizeof(queue_t));
+    }
+
+    ~idns_query() {
+        if (message)
+            rfc1035MessageDestroy(&message);
+        delete queue;
+        delete slave;
+        // master is just a back-reference
+        cbdataReferenceDone(callback_data);
+    }
 
-struct _idns_query {
     hash_link hash;
     rfc1035_query query;
     char buf[RESOLV_BUFSZ];
@@ -133,9 +173,19 @@ struct _idns_query {
     int ancount;
     const char *error;
 };
+
 InstanceIdDefinitions(idns_query,  "dns");
 
-struct _nsvc {
+CBDATA_CLASS_INIT(idns_query);
+
+class nsvc
+{
+    CBDATA_CLASS(nsvc);
+
+public:
+    explicit nsvc(int nsv) : ns(nsv), msglen(0), read_msglen(0), msg(new MemBuf()), queue(new MemBuf()), busy(true) {}
+    ~nsvc();
+
     int ns;
     Comm::ConnectionPointer conn;
     unsigned short msglen;
@@ -145,6 +195,8 @@ struct _nsvc {
     bool busy;
 };
 
+CBDATA_CLASS_INIT(nsvc);
+
 struct _ns {
     Ip::Address S;
     int nqueries;
@@ -161,9 +213,6 @@ struct _sp {
     int queries;
 };
 
-CBDATA_TYPE(nsvc);
-CBDATA_TYPE(idns_query);
-
 static ns *nameservers = NULL;
 static sp *searchpath = NULL;
 static int nns = 0;
@@ -380,18 +429,14 @@ static bool
 idnsParseResolvConf(void)
 {
     bool result = false;
-#if !_SQUID_WINDOWS_ || _SQUID_CYGWIN_
+#if !_SQUID_WINDOWS_
     FILE *fp = fopen(_PATH_RESCONF, "r");
 
     if (fp == NULL) {
         debugs(78, DBG_IMPORTANT, "" << _PATH_RESCONF << ": " << xstrerror());
         return false;
     }
 
-#if _SQUID_CYGWIN_
-    setmode(fileno(fp), O_TEXT);
-#endif
-
     char buf[RESOLV_BUFSZ];
     const char *t = NULL;
     while (fgets(buf, RESOLV_BUFSZ, fp)) {
@@ -849,25 +894,24 @@ static void
 idnsVCClosed(const CommCloseCbParams &params)
 {
     nsvc * vc = (nsvc *)params.data;
-    delete vc->queue;
-    delete vc->msg;
-    vc->conn = NULL;
-    if (vc->ns < nns) // XXX: dnsShutdown may have freed nameservers[]
-        nameservers[vc->ns].vc = NULL;
-    cbdataFree(vc);
+    delete vc;
+}
+
+nsvc::~nsvc()
+{
+    delete queue;
+    delete msg;
+    if (ns < nns) // XXX: Dns::Shutdown may have freed nameservers[]
+        nameservers[ns].vc = NULL;
 }
 
 static void
 idnsInitVC(int nsv)
 {
-    nsvc *vc = cbdataAlloc(nsvc);
+    nsvc *vc = new nsvc(nsv);
     assert(nsv < nns);
     assert(vc->conn == NULL); // MUST be NULL from the construction process!
     nameservers[nsv].vc = vc;
-    vc->ns = nsv;
-    vc->queue = new MemBuf;
-    vc->msg = new MemBuf;
-    vc->busy = 1;
 
     Comm::ConnectionPointer conn = new Comm::Connection();
 
@@ -1055,6 +1099,7 @@ idnsCallback(idns_query *q, const char *error)
     while ( idns_query *q2 = q->slave ) {
         debugs(78, 6, HERE << "Merging DNS results " << q->name << " A has " << n << " RR, AAAA has " << q2->ancount << " RR");
         q->slave = q2->slave;
+        q2->slave = NULL;
         if ( !q2->error ) {
             if (n > 0) {
                 // two sets of RR need merging
@@ -1082,8 +1127,7 @@ idnsCallback(idns_query *q, const char *error)
                 error = NULL;
             }
         }
-        rfc1035MessageDestroy(&q2->message);
-        cbdataFree(q2);
+        delete q2;
     }
 
     debugs(78, 6, HERE << "Sending " << n << " (" << (error ? error : "OK") << ") DNS results to caller.");
@@ -1098,13 +1142,15 @@ idnsCallback(idns_query *q, const char *error)
     while (q->queue) {
         idns_query *q2 = q->queue;
         q->queue = q2->queue;
+        q2->queue = NULL;
+
         callback = q2->callback;
         q2->callback = NULL;
 
         if (cbdataReferenceValidDone(q2->callback_data, &cbdata))
             callback(cbdata, answers, n, error);
 
-        cbdataFree(q2);
+        delete q2;
     }
 
     if (q->hash.key) {
@@ -1113,17 +1159,15 @@ idnsCallback(idns_query *q, const char *error)
     }
 
     rfc1035MessageDestroy(&message);
-    cbdataFree(q);
+    delete q;
 }
 
 static void
 idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
 {
-    int n;
     rfc1035_message *message = NULL;
-    idns_query *q;
 
-    n = rfc1035MessageUnpack(buf, sz, &message);
+    int n = rfc1035MessageUnpack(buf, sz, &message);
 
     if (message == NULL) {
         debugs(78, DBG_IMPORTANT, "idnsGrokReply: Malformed DNS response");
@@ -1132,7 +1176,7 @@ idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
 
     debugs(78, 3, "idnsGrokReply: QID 0x" << std::hex <<   message->id << ", " << std::dec << n << " answers");
 
-    q = idnsFindQuery(message->id);
+    idns_query *q = idnsFindQuery(message->id);
 
     if (q == NULL) {
         debugs(78, 3, "idnsGrokReply: Late response");
@@ -1233,8 +1277,8 @@ idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
             while (idns_query *slave = q->slave) {
                 dlinkDelete(&slave->lru, &lru_list);
                 q->slave = slave->slave;
-                rfc1035MessageDestroy(&slave->message);
-                cbdataFree(slave);
+                slave->slave = NULL;
+                delete slave;
             }
 
             // Build new query
@@ -1497,22 +1541,11 @@ idnsRcodeCount(int rcode, int attempt)
             ++ RcodeMatrix[rcode][attempt];
 }
 
-/* ====================================================================== */
-
-static void
-idnsRegisterWithCacheManager(void)
-{
-    Mgr::RegisterAction("idns", "Internal DNS Statistics", idnsStats, 0, 1);
-}
-
 void
-dnsInit(void)
+Dns::Init(void)
 {
     static int init = 0;
 
-    CBDATA_INIT_TYPE(nsvc);
-    CBDATA_INIT_TYPE(idns_query);
-
     if (DnsSocketA < 0 && DnsSocketB < 0) {
         Ip::Address addrV6; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
@@ -1600,11 +1633,11 @@ dnsInit(void)
     }
 #endif
 
-    idnsRegisterWithCacheManager();
+    Mgr::RegisterAction("idns", "Internal DNS Statistics", idnsStats, 0, 1);
 }
 
 void
-dnsShutdown(void)
+Dns::Shutdown(void)
 {
     if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
@@ -1634,24 +1667,18 @@ dnsShutdown(void)
 static int
 idnsCachedLookup(const char *key, IDNSCB * callback, void *data)
 {
-    idns_query *q;
-
     idns_query *old = (idns_query *) hash_lookup(idns_lookup_hash, key);
 
     if (!old)
         return 0;
 
-    q = cbdataAlloc(idns_query);
-    // idns_query is POD so no constructors are called after allocation
-    q->xact_id.change();
+    idns_query *q = new idns_query;
     // no query_id on this instance.
 
     q->callback = callback;
-
     q->callback_data = cbdataReference(data);
 
     q->queue = old->queue;
-
     old->queue = q;
 
     return 1;
@@ -1673,21 +1700,23 @@ idnsStartQuery(idns_query *q, IDNSCB * callback, void *data)
 static void
 idnsSendSlaveAAAAQuery(idns_query *master)
 {
-    idns_query *q = cbdataAlloc(idns_query);
+    idns_query *q = new idns_query;
     memcpy(q->name, master->name, sizeof(q->name));
     memcpy(q->orig, master->orig, sizeof(q->orig));
     q->master = master;
     q->query_id = idnsQueryID();
     q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->query_id, &q->query, Config.dns.packet_max);
-    q->start_t = master->start_t;
-    q->slave = master->slave;
 
     debugs(78, 3, HERE << "buf is " << q->sz << " bytes for " << q->name <<
            ", id = 0x" << std::hex << q->query_id);
     if (!q->sz) {
-        cbdataFree(q);
+        delete q;
         return;
     }
+
+    q->start_t = master->start_t;
+    q->slave = master->slave;
+
     idnsCheckMDNS(q);
     master->slave = q;
     idnsSendQuery(q);
@@ -1708,9 +1737,7 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     if (idnsCachedLookup(name, callback, data))
         return;
 
-    idns_query *q = cbdataAlloc(idns_query);
-    // idns_query is POD so no constructors are called after allocation
-    q->xact_id.change();
+    idns_query *q = new idns_query;
     q->query_id = idnsQueryID();
 
     int nd = 0;
@@ -1740,7 +1767,7 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     if (q->sz < 0) {
         /* problem with query data -- query not sent */
         callback(data, NULL, 0, "Internal error");
-        cbdataFree(q);
+        delete q;
         return;
     }
 
@@ -1752,22 +1779,16 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
 
     if (Ip::EnableIpv6)
         idnsSendSlaveAAAAQuery(q);
-
 }
 
 void
 idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 {
-    idns_query *q;
-
     char ip[MAX_IPSTRLEN];
 
     addr.toStr(ip,MAX_IPSTRLEN);
 
-    q = cbdataAlloc(idns_query);
-
-    // idns_query is POD so no constructors are called after allocation
-    q->xact_id.change();
+    idns_query *q = new idns_query;
     q->query_id = idnsQueryID();
 
     if (addr.isIPv6()) {
@@ -1784,12 +1805,12 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
     if (q->sz < 0) {
         /* problem with query data -- query not sent */
         callback(data, NULL, 0, "Internal error");
-        cbdataFree(q);
+        delete q;
         return;
     }
 
     if (idnsCachedLookup(q->query.name, callback, data)) {
-        cbdataFree(q);
+        delete q;
         return;
     }
 
@@ -27,6 +27,7 @@ typedef enum {
     ERR_WRITE_ERROR,
     ERR_CONNECT_FAIL,
     ERR_SECURE_CONNECT_FAIL,
+    ERR_SECURE_ACCEPT_FAIL,
     ERR_SOCKET_FAILURE,
 
     /* DNS Errors */
@@ -68,6 +69,8 @@ typedef enum {
     ERR_DIR_LISTING,            /* Display of remote directory (FTP, Gopher) */
     ERR_SQUID_SIGNATURE,        /* not really an error */
     ERR_SHUTTING_DOWN,
+    ERR_PROTOCOL_UNKNOWN,
+    ERR_REQUEST_START_TIMEOUT,
 
     // NOTE: error types defined below TCP_RESET are optional and do not generate
     //       a log warning if the files are missing
@@ -81,5 +84,24 @@ typedef enum {
 
 extern const char *err_type_str[];
 
+inline
+err_type
+errorTypeByName(const char *name)
+{
+    for (int i = 0; i < ERR_MAX; ++i)
+        if (strcmp(name, err_type_str[i]) == 0)
+            return (err_type)i;
+    return ERR_MAX;
+}
+
+inline
+const char *
+errorTypeName(err_type err)
+{
+    if (err < ERR_NONE || err >= ERR_MAX)
+        return "UNKNOWN";
+    return err_type_str[err];
+}
+
 #endif /* _SQUID_ERR_TYPE_H */
 
@@ -14,11 +14,7 @@
 #include "esi/Element.h"
 #include "esi/Sequence.h"
 
-/* esiAttempt */
-
 struct esiAttempt : public esiSequence {
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     esiAttempt(esiTreeParentPtr aParent) : esiSequence (aParent) {}
 };
 
@@ -29,6 +29,7 @@
 #include "esi/Expression.h"
 #include "esi/Segment.h"
 #include "esi/VarState.h"
+#include "fatal.h"
 #include "HttpHdrSc.h"
 #include "HttpHdrScTarget.h"
 #include "HttpReply.h"
@@ -104,23 +105,19 @@ class esiComment : public ESIElement
 
 class esiRemove : public ESIElement
 {
+    MEMPROXY_CLASS(esiRemove);
 
 public:
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
-
-    esiRemove();
-    void render(ESISegment::Pointer);
-    bool addElement (ESIElement::Pointer);
-    Pointer makeCacheable() const;
-    Pointer makeUsable(esiTreeParentPtr, ESIVarState &) const;
-    void finish();
+    esiRemove() : ESIElement() {}
+    virtual ~esiRemove() {}
+
+    virtual void render(ESISegment::Pointer);
+    virtual bool addElement (ESIElement::Pointer);
+    virtual Pointer makeCacheable() const;
+    virtual Pointer makeUsable(esiTreeParentPtr, ESIVarState &) const;
+    virtual void finish() {}
 };
 
-CBDATA_TYPE (esiRemove);
-static FREE esiRemoveFree;
-static ESIElement * esiRemoveNew(void);
-
 class esiTry : public ESIElement
 {
     MEMPROXY_CLASS(esiTry);
@@ -213,8 +210,6 @@ class esiWhen : public esiSequence
 };
 
 struct esiOtherwise : public esiSequence {
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     esiOtherwise(esiTreeParentPtr aParent) : esiSequence (aParent) {}
 };
 
@@ -1021,7 +1016,7 @@ ESIContext::start(const char *el, const char **attr, size_t attrCount)
 
     case ESIElement::ESI_ELEMENT_REMOVE:
         /* Put on the stack to allow skipping of 'invalid' markup */
-        element = esiRemoveNew ();
+        element = new esiRemove();
         break;
 
     case ESIElement::ESI_ELEMENT_TRY:
@@ -1584,42 +1579,6 @@ esiLiteral::makeUsable(esiTreeParentPtr , ESIVarState &newVarState) const
 }
 
 /* esiRemove */
-void
-esiRemoveFree (void *data)
-{
-    esiRemove *thisNode = (esiRemove *)data;
-    debugs(86, 5, "esiRemoveFree " << thisNode);
-}
-
-void *
-esiRemove::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiRemove));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiRemove, esiRemoveFree);
-    rv = (void *)cbdataAlloc (esiRemove);
-    return rv;
-}
-
-void
-esiRemove::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-ESIElement *
-esiRemoveNew ()
-{
-    return new esiRemove;
-}
-
-esiRemove::esiRemove()
-{}
-
-void
-esiRemove::finish()
-{}
-
 void
 esiRemove::render(ESISegment::Pointer output)
 {
@@ -1916,63 +1875,6 @@ esiTry::finish()
     except = NULL;
 }
 
-/* esiAttempt */
-#if 0
-void *
-esiAttempt::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiAttempt));
-
-}
-
-void
-esiAttempt::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
-/* esiExcept */
-#if 0
-void *
-esiExcept::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiExcept));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiExcept, esiSequence::Free);
-    rv = (void *)cbdataAlloc (esiExcept);
-    return rv;
-}
-
-void
-esiExcept::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
-/* ESIVar */
-#if 0
-void *
-esiVar::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiVar));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiVar, esiSequence::Free);
-    rv = (void *)cbdataAlloc (esiVar);
-    return rv;
-}
-
-void
-esiVar::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
 /* esiChoose */
 esiChoose::~esiChoose()
 {
@@ -2369,26 +2271,6 @@ esiWhen::makeUsable(esiTreeParentPtr newParent, ESIVarState &newVarState) const
     return result;
 }
 
-/* esiOtherwise */
-#if 0
-void *
-esiOtherwise::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiOtherwise));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiOtherwise, esiSequence::Free);
-    rv = (void *)cbdataAlloc (esiOtherwise);
-    return rv;
-}
-
-void
-esiOtherwise::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
 /* TODO: implement surrogate targeting and control processing */
 int
 esiEnableProcessing (HttpReply *rep)
@@ -20,8 +20,6 @@ class esiExcept : public esiSequence
 {
 
 public:
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     esiExcept(esiTreeParentPtr aParent) : esiSequence (aParent) {}
 };
 
@@ -10,15 +10,13 @@
 
 #include "squid.h"
 
-/* MS Visual Studio Projects are monolithic, so we need the following
- * #if to exclude the ESI code from compile process when not needed.
- */
-#if (USE_SQUID_ESI == 1)
+#if USE_SQUID_ESI
 
 #include "client_side.h"
 #include "client_side_request.h"
 #include "esi/Include.h"
 #include "esi/VarState.h"
+#include "fatal.h"
 #include "HttpReply.h"
 #include "log/access_log.h"
 
@@ -559,5 +557,5 @@ ESIInclude::subRequestDone (ESIStreamContext::Pointer stream, bool success)
     }
 }
 
-#endif /* USE_SQUID_ESI == 1 */
+#endif /* USE_SQUID_ESI */
 
@@ -13,9 +13,8 @@
 #include "esi/Segment.h"
 #include "SquidString.h"
 
-CBDATA_TYPE(ESISegment);
+CBDATA_CLASS_INIT(ESISegment);
 
-/* ESISegment */
 void
 ESISegmentFreeList (ESISegment::Pointer &head)
 {
@@ -126,22 +125,6 @@ ESISegment::ListAppend (ESISegment::Pointer &head, char const *s, size_t len)
     head->tail()->listAppend (s, len);
 }
 
-void *
-ESISegment::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESISegment));
-    void *rv;
-    CBDATA_INIT_TYPE(ESISegment);
-    rv = (void *)cbdataAlloc (ESISegment);
-    return rv;
-}
-
-void
-ESISegment::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 /* XXX: if needed, make this iterative */
 ESISegment::Pointer
 ESISegment::cloneList () const
@@ -188,9 +171,6 @@ ESISegment::tail()
     return result.getRaw();
 }
 
-ESISegment::ESISegment() : len(0), next(NULL)
-{}
-
 ESISegment::ESISegment(ESISegment const &old) : len (0), next(NULL)
 {
     append (old.buf, old.len);
@@ -20,16 +20,17 @@
 
 class ESISegment : public RefCountable
 {
+    CBDATA_CLASS(ESISegment);
 
 public:
     typedef RefCount<ESISegment> Pointer;
     static void ListAppend (Pointer &, char const *, size_t);
     static void ListTransfer (Pointer &from, Pointer &to);
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
 
-    ESISegment();
+    ESISegment() : len(0), next(NULL) {*buf = 0;}
     ESISegment(ESISegment const &);
+    ~ESISegment() {}
+
     ESISegment::Pointer cloneList() const;
     char *listToChar() const;
     void listAppend (char const *s, size_t length);
@@ -20,8 +20,6 @@ class ESIVar:public esiSequence
 {
 
 public:
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     ESIVar(esiTreeParentPtr aParent) : esiSequence (aParent) {
         flags.dovars = 1;
     }
@@ -13,9 +13,6 @@
 #include "fatal.h"
 #include "HttpReply.h"
 
-CBDATA_TYPE (ESIVarState);
-FREE ESIVarStateFree;
-
 char const *ESIVariableUserAgent::esiUserOs[]= {
     "WIN",
     "MAC",
@@ -28,6 +25,8 @@ char const * esiBrowsers[]= {"MSIE",
                              "OTHER"
                             };
 
+CBDATA_CLASS_INIT(ESIVarState);
+
 void
 ESIVarState::Variable::eval (ESIVarState &state, char const *subref, char const *found_default) const
 {
@@ -131,17 +130,12 @@ ESIVarState::extractChar ()
     return rv;
 }
 
-/* ESIVarState */
-void
-esiVarStateFree (void *data)
-{
-    ESIVarState *thisNode = (ESIVarState*)data;
-    thisNode->freeResources();
-}
-
 ESIVarState::~ESIVarState()
 {
-    freeResources();
+    // freeResources
+    input = NULL;
+    ESISegmentFreeList(output);
+    hdr.clean();
 
     while (!variablesForCleanup.empty()) {
         delete variablesForCleanup.back();
@@ -151,30 +145,6 @@ ESIVarState::~ESIVarState()
     delete defaultVariable;
 }
 
-void
-ESIVarState::freeResources()
-{
-    input = NULL;
-    ESISegmentFreeList (output);
-    hdr.clean();
-}
-
-void *
-ESIVarState::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESIVarState));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(ESIVarState, esiVarStateFree);
-    rv = (void *)cbdataAlloc (ESIVarState);
-    return rv;
-}
-
-void
-ESIVarState::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 char *
 ESIVariableUserAgent::getProductVersion (char const *s)
 {
@@ -33,8 +33,12 @@ struct _query_elem {char *var, *val;};
 
 class ESIVarState
 {
+    CBDATA_CLASS(ESIVarState);
 
 public:
+    ESIVarState(HttpHeader const *hdr, char const *uri);
+    ~ESIVarState();
+
     ESISegment::Pointer extractList();
     char *extractChar();
     void feedData (const char *buf, size_t len);
@@ -44,12 +48,6 @@ class ESIVarState
     void addVariable (char const *, size_t, Variable *);
     void removeVariable (String const &);
 
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
-    void freeResources();
-    ESIVarState (HttpHeader const *hdr, char const *uri);
-    ~ESIVarState();
-
     /* For Variables */
     void cookieUsed();
     void hostUsed();
@@ -89,8 +89,15 @@ class external_acl_format : public RefCountable
 
 class external_acl
 {
+    /* FIXME: These are not really cbdata, but it is an easy way
+     * to get them pooled, refcounted, accounted and freed properly...
+     */
+    CBDATA_CLASS(external_acl);
 
 public:
+    external_acl();
+    ~external_acl();
+
     external_acl *next;
 
     void add(const ExternalACLEntryPointer &);
@@ -141,33 +148,52 @@ class external_acl
     Ip::Address local_addr;
 };
 
-/* FIXME: These are not really cbdata, but it is an easy way
- * to get them pooled, refcounted, accounted and freed properly...
- */
-CBDATA_TYPE(external_acl);
-
-static void
-free_external_acl(void *data)
+CBDATA_CLASS_INIT(external_acl);
+
+external_acl::external_acl() :
+    ttl(DEFAULT_EXTERNAL_ACL_TTL),
+    negative_ttl(-1),
+    grace(1),
+    name(NULL),
+    cmdline(NULL),
+    children(DEFAULT_EXTERNAL_ACL_CHILDREN),
+    theHelper(NULL),
+    cache(NULL),
+    cache_size(256*1024),
+    cache_entries(0),
+#if USE_AUTH
+    require_auth(0),
+#endif
+    quote(external_acl::QUOTE_METHOD_URL)
 {
-    external_acl *p = static_cast<external_acl *>(data);
-    safe_free(p->name);
-
-    p->format = NULL;
-
-    wordlistDestroy(&p->cmdline);
+    local_addr.setLocalhost();
+}
 
-    if (p->theHelper) {
-        helperShutdown(p->theHelper);
-        delete p->theHelper;
-        p->theHelper = NULL;
+external_acl::~external_acl()
+{
+    xfree(name);
+    format = NULL;
+    wordlistDestroy(&cmdline);
+
+    if (theHelper) {
+        helperShutdown(theHelper);
+        delete theHelper;
+        theHelper = NULL;
     }
 
-    while (p->lru_list.tail) {
-        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(p->lru_list.tail->data));
-        external_acl_cache_delete(p, e);
+    while (lru_list.tail) {
+        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(lru_list.tail->data));
+        external_acl_cache_delete(this, e);
+    }
+    if (cache)
+        hashFreeMemory(cache);
+
+    while (next) {
+        external_acl *node = next;
+        next = node->next;
+        node->next = NULL; // prevent recursion
+        delete node;
     }
-    if (p->cache)
-        hashFreeMemory(p->cache);
 }
 
 /**
@@ -223,24 +249,8 @@ parse_header_token(external_acl_format::Pointer format, char *header, const Form
 void
 parse_externalAclHelper(external_acl ** list)
 {
-    external_acl *a;
-    char *token;
-
-    CBDATA_INIT_TYPE_FREECB(external_acl, free_external_acl);
-
-    a = cbdataAlloc(external_acl);
-
-    /* set defaults */
-    a->ttl = DEFAULT_EXTERNAL_ACL_TTL;
-    a->negative_ttl = -1;
-    a->cache_size = 256*1024;
-    a->children.n_max = DEFAULT_EXTERNAL_ACL_CHILDREN;
-    a->children.n_startup = a->children.n_max;
-    a->children.n_idle = 1;
-    a->local_addr.setLocalhost();
-    a->quote = external_acl::QUOTE_METHOD_URL;
-
-    token = ConfigParser::NextToken();
+    external_acl *a = new external_acl;
+    char *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
@@ -565,12 +575,8 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
 void
 free_externalAclHelper(external_acl ** list)
 {
-    while (*list) {
-        external_acl *node = *list;
-        *list = node->next;
-        node->next = NULL;
-        cbdataFree(node);
-    }
+    delete *list;
+    *list = NULL;
 }
 
 static external_acl *
@@ -613,40 +619,40 @@ external_acl::trimCache()
  * external acl type
  */
 
-struct _external_acl_data {
+class external_acl_data
+{
+    CBDATA_CLASS(external_acl_data);
+
+public:
+    explicit external_acl_data(external_acl *aDef) : def(cbdataReference(aDef)), name(NULL), arguments(NULL) {}
+    ~external_acl_data();
+
     external_acl *def;
     const char *name;
     wordlist *arguments;
 };
 
-CBDATA_TYPE(external_acl_data);
-static void
-free_external_acl_data(void *data)
+CBDATA_CLASS_INIT(external_acl_data);
+
+external_acl_data::~external_acl_data()
 {
-    external_acl_data *p = static_cast<external_acl_data *>(data);
-    safe_free(p->name);
-    wordlistDestroy(&p->arguments);
-    cbdataReferenceDone(p->def);
+    xfree(name);
+    wordlistDestroy(&arguments);
+    cbdataReferenceDone(def);
 }
 
 void
 ACLExternal::parse()
 {
-    char *token;
-
     if (data)
         self_destruct();
 
-    CBDATA_INIT_TYPE_FREECB(external_acl_data, free_external_acl_data);
-
-    data = cbdataAlloc(external_acl_data);
-
-    token = strtokFile();
+    char *token = ConfigParser::strtokFile();
 
     if (!token)
         self_destruct();
 
-    data->def = cbdataReference(find_externalAclHelper(token));
+    data = new external_acl_data(find_externalAclHelper(token));
 
     if (!data->def)
         self_destruct();
@@ -655,7 +661,7 @@ ACLExternal::parse()
     // this is the name of the 'acl' directive being tested
     data->name = xstrdup(AclMatchedName);
 
-    while ((token = strtokFile())) {
+    while ((token = ConfigParser::strtokFile())) {
         wordlistAdd(&data->arguments, token);
     }
 }
@@ -688,8 +694,8 @@ ACLExternal::empty () const
 
 ACLExternal::~ACLExternal()
 {
-    cbdataFree(data);
-    safe_free (class_);
+    delete data;
+    xfree(class_);
 }
 
 static void
@@ -1252,9 +1258,20 @@ external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &ent
  * external_acl helpers
  */
 
-typedef struct _externalAclState externalAclState;
+class externalAclState
+{
+    CBDATA_CLASS(externalAclState);
+
+public:
+    externalAclState(external_acl* aDef, const char *aKey) :
+        callback(NULL),
+        callback_data(NULL),
+        key(xstrdup(aKey)),
+        def(cbdataReference(aDef)),
+        queue(NULL)
+    {}
+    ~externalAclState();
 
-struct _externalAclState {
     EAH *callback;
     void *callback_data;
     char *key;
@@ -1263,14 +1280,13 @@ struct _externalAclState {
     externalAclState *queue;
 };
 
-CBDATA_TYPE(externalAclState);
-static void
-free_externalAclState(void *data)
+CBDATA_CLASS_INIT(externalAclState);
+
+externalAclState::~externalAclState()
 {
-    externalAclState *state = static_cast<externalAclState *>(data);
-    safe_free(state->key);
-    cbdataReferenceDone(state->callback_data);
-    cbdataReferenceDone(state->def);
+    xfree(key);
+    cbdataReferenceDone(callback_data);
+    cbdataReferenceDone(def);
 }
 
 /*
@@ -1352,14 +1368,13 @@ externalAclHandleReply(void *data, const Helper::Reply &reply)
 
     do {
         void *cbdata;
-        cbdataReferenceDone(state->def);
-
         if (state->callback && cbdataReferenceValidDone(state->callback_data, &cbdata))
             state->callback(cbdata, entry);
 
         next = state->queue;
+        state->queue = NULL;
 
-        cbdataFree(state);
+        delete state;
 
         state = next;
     } while (state);
@@ -1404,10 +1419,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
         return;
     }
 
-    externalAclState *state = cbdataAlloc(externalAclState);
-    state->def = cbdataReference(def);
-
-    state->key = xstrdup(key);
+    externalAclState *state = new externalAclState(def, key);
 
     if (!inBackground) {
         state->callback = &ExternalACLLookup::LookupDone;
@@ -1431,7 +1443,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
         if (!def->theHelper->trySubmit(buf.buf, externalAclHandleReply, state)) {
             debugs(82, 7, HERE << "'" << def->name << "' submit to helper failed");
             assert(inBackground); // or the caller should have checked
-            cbdataFree(state);
+            delete state;
             return;
         }
 
@@ -1447,9 +1459,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
 static void
 externalAclStats(StoreEntry * sentry)
 {
-    external_acl *p;
-
-    for (p = Config.externalAclHelperList; p; p = p->next) {
+    for (external_acl *p = Config.externalAclHelperList; p; p = p->next) {
         storeAppendPrintf(sentry, "External ACL Statistics: %s\n", p->name);
         storeAppendPrintf(sentry, "Cache size: %d\n", p->cache->count);
         helperStats(sentry, p->theHelper);
@@ -1468,10 +1478,7 @@ externalAclRegisterWithCacheManager(void)
 void
 externalAclInit(void)
 {
-    static int firstTimeInit = 1;
-    external_acl *p;
-
-    for (p = Config.externalAclHelperList; p; p = p->next) {
+    for (external_acl *p = Config.externalAclHelperList; p; p = p->next) {
         if (!p->cache)
             p->cache = hash_create((HASHCMP *) strcmp, hashPrime(1024), hash4);
 
@@ -1489,11 +1496,6 @@ externalAclInit(void)
         helperOpenServers(p->theHelper);
     }
 
-    if (firstTimeInit) {
-        firstTimeInit = 0;
-        CBDATA_INIT_TYPE_FREECB(externalAclState, free_externalAclState);
-    }
-
     externalAclRegisterWithCacheManager();
 }
 
@@ -10,12 +10,13 @@
 
 #include "squid.h"
 #include "cbdata.h"
-#include "DnsLookupDetails.h"
+#include "dns/forward.h"
+#include "dns/LookupDetails.h"
+#include "dns/rfc1035.h"
 #include "event.h"
 #include "helper.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
-#include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -310,7 +311,7 @@ fqdncacheCallback(fqdncache_entry * f, int wait)
     f->handler = NULL;
 
     if (cbdataReferenceValidDone(f->handlerData, &cbdata)) {
-        const DnsLookupDetails details(f->error_message, wait);
+        const Dns::LookupDetails details(f->error_message, wait);
         callback(f->name_count ? f->names[0] : NULL, details, cbdata);
     }
 
@@ -427,7 +428,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
 
     if (name[0] == '\0') {
         debugs(35, 4, "fqdncache_nbgethostbyaddr: Invalid name!");
-        const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
+        const Dns::LookupDetails details("Invalid hostname", -1); // error, no lookup
         if (handler)
             handler(NULL, details, handlerData);
         return;
@@ -389,7 +389,7 @@ HttpStateData::cacheableReply()
 
     // RFC 2068, sec 14.9.4 - MUST NOT cache any response with Authentication UNLESS certain CC controls are present
     // allow HTTP violations to IGNORE those controls (ie re-block caching Auth)
-    if (request && (request->flags.auth || request->flags.authSent) && !REFRESH_OVERRIDE(ignore_auth)) {
+    if (request && (request->flags.auth || request->flags.authSent)) {
         if (!rep->cache_control) {
             debugs(22, 3, HERE << "NO because Authenticated and server reply missing Cache-Control");
             return 0;
@@ -408,7 +408,7 @@ HttpStateData::cacheableReply()
 
             // HTTPbis pt6 section 3.2: a response CC:must-revalidate is present
         } else if (rep->cache_control->mustRevalidate() && !REFRESH_OVERRIDE(ignore_must_revalidate)) {
-            debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:public");
+            debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:must-revalidate");
             mayStore = true;
 
 #if USE_HTTP_VIOLATIONS
@@ -10,6 +10,7 @@
 #include "Debug.h"
 #include "http/one/Parser.h"
 #include "parser/Tokenizer.h"
+#include "SquidConfig.h"
 
 /// RFC 7230 section 2.6 - 7 magic octets
 const SBuf Http::One::Parser::Http1magic("HTTP/1.");
@@ -23,6 +24,19 @@ Http::One::Parser::clear()
     mimeHeaderBlock_.clear();
 }
 
+bool
+Http::One::Parser::skipLineTerminator(::Parser::Tokenizer &tok) const
+{
+    static const SBuf crlf("\r\n");
+    if (tok.skip(crlf))
+        return true;
+
+    if (Config.onoff.relaxed_header_parser && tok.skipOne(CharacterSet::LF))
+        return true;
+
+    return false;
+}
+
 // arbitrary maximum-length for headers which can be found by Http1Parser::getHeaderField()
 #define GET_HDR_SZ  1024
 
@@ -13,6 +13,10 @@
 #include "http/one/forward.h"
 #include "SBuf.h"
 
+namespace Parser {
+class Tokenizer;
+}
+
 namespace Http {
 namespace One {
 
@@ -88,6 +92,10 @@ class Parser : public RefCountable
     const SBuf &remaining() const {return buf_;}
 
 protected:
+    /// detect and skip the CRLF or (if tolerant) LF line terminator
+    /// consume from the tokenizer and return true only if found
+    bool skipLineTerminator(::Parser::Tokenizer &tok) const;
+
     /// RFC 7230 section 2.6 - 7 magic octets
     static const SBuf Http1magic;
 
@@ -11,17 +11,22 @@
 #include "http/one/RequestParser.h"
 #include "http/ProtocolVersion.h"
 #include "mime_header.h"
+#include "parser/Tokenizer.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
 Http::One::RequestParser::RequestParser() :
     Parser(),
-    request_parse_status(Http::scNone)
+    request_parse_status(Http::scNone),
+    firstLineGarbage_(0)
+{}
+
+Http1::Parser::size_type
+Http::One::RequestParser::firstLineSize() const
 {
-    req.start = req.end = -1;
-    req.m_start = req.m_end = -1;
-    req.u_start = req.u_end = -1;
-    req.v_start = req.v_end = -1;
+    // RFC 7230 section 2.6
+    /* method SP request-target SP "HTTP/" DIGIT "." DIGIT CRLF */
+    return method_.image().length() + uri_.length() + 12;
 }
 
 /**
@@ -51,234 +56,309 @@ Http::One::RequestParser::skipGarbageLines()
             buf_.consume(1);
         }
     }
-
-    /* XXX: this is a Squid-specific tolerance
-     * it appears never to have been relevant outside out unit-tests
-     * because the ConnStateData parser loop starts with consumeWhitespace()
-     * which absorbs any SP HTAB VTAB CR LF characters.
-     * But unit-tests called the HttpParser method directly without that pruning.
-     */
-#if USE_HTTP_VIOLATIONS
-    if (Config.onoff.relaxed_header_parser) {
-        if (Config.onoff.relaxed_header_parser < 0 && buf_[0] == ' ')
-            debugs(74, DBG_IMPORTANT, "WARNING: Invalid HTTP Request: " <<
-                   "Whitespace bytes received ahead of method. " <<
-                   "Ignored due to relaxed_header_parser.");
-        // Be tolerant of prefix spaces (other bytes are valid method values)
-        while (!buf_.isEmpty() && buf_[0] == ' ') {
-            buf_.consume(1);
-        }
-    }
-#endif
 }
 
 /**
- * Attempt to parse the first line of a new request message.
+ * Attempt to parse the method field out of an HTTP message request-line.
  *
  * Governed by:
  *  RFC 1945 section 5.1
- *  RFC 7230 section 3.1 and 3.5
+ *  RFC 7230 section 2.6, 3.1 and 3.5
  *
- * Parsing state is stored between calls. However the current implementation
- * begins parsing from scratch on every call.
- * The return value tells you whether the parsing state fields are valid or not.
+ * Parsing state is stored between calls. The current implementation uses
+ * checkpoints after each successful request-line field.
+ * The return value tells you whether the parsing is completed or not.
  *
  * \retval -1  an error occurred. request_parse_status indicates HTTP status result.
- * \retval  1  successful parse. member fields contain the request-line items
+ * \retval  1  successful parse. method_ is filled and buffer consumed including first delimiter.
  * \retval  0  more data is needed to complete the parse
  */
 int
-Http::One::RequestParser::parseRequestFirstLine()
+Http::One::RequestParser::parseMethodField(::Parser::Tokenizer &tok, const CharacterSet &WspDelim)
 {
-    int second_word = -1; // track the suspected URI start
-    int first_whitespace = -1, last_whitespace = -1; // track the first and last SP byte
-    int line_end = -1; // tracks the last byte BEFORE terminal \r\n or \n sequence
-
-    debugs(74, 5, "parsing possible request: buf.length=" << buf_.length());
-    debugs(74, DBG_DATA, buf_);
+    // scan for up to 16 valid method characters.
+    static const size_t maxMethodLength = 16; // TODO: make this configurable?
 
-    // Single-pass parse: (provided we have the whole line anyways)
+    // method field is a sequence of TCHAR.
+    SBuf methodFound;
+    if (tok.prefix(methodFound, CharacterSet::TCHAR, maxMethodLength) && tok.skipOne(WspDelim)) {
 
-    req.start = 0;
-    req.end = -1;
-    for (SBuf::size_type i = 0; i < buf_.length(); ++i) {
-        // track first and last whitespace (SP only)
-        if (buf_[i] == ' ') {
-            last_whitespace = i;
-            if (first_whitespace < req.start)
-                first_whitespace = i;
-        }
+        method_ = HttpRequestMethod(methodFound);
+        buf_ = tok.remaining(); // incremental parse checkpoint
+        return 1;
 
-        // track next non-SP/non-HT byte after first_whitespace
-        if (second_word < first_whitespace && buf_[i] != ' ' && buf_[i] != '\t') {
-            second_word = i;
-        }
+    } else if (tok.atEnd()) {
+        debugs(74, 5, "Parser needs more data to find method");
+        return 0;
 
-        // locate line terminator
-        if (buf_[i] == '\n') {
-            req.end = i;
-            line_end = i - 1;
-            break;
-        }
-        if (i < buf_.length() - 1 && buf_[i] == '\r') {
-            if (Config.onoff.relaxed_header_parser) {
-                if (Config.onoff.relaxed_header_parser < 0 && buf_[i + 1] == '\r')
-                    debugs(74, DBG_IMPORTANT, "WARNING: Invalid HTTP Request: " <<
-                           "Series of carriage-return bytes received prior to line terminator. " <<
-                           "Ignored due to relaxed_header_parser.");
-
-                // Be tolerant of invalid multiple \r prior to terminal \n
-                if (buf_[i + 1] == '\n' || buf_[i + 1] == '\r')
-                    line_end = i - 1;
-                while (i < buf_.length() - 1 && buf_[i + 1] == '\r')
-                    ++i;
-
-                if (buf_[i + 1] == '\n') {
-                    req.end = i + 1;
-                    break;
-                }
-            } else {
-                if (buf_[i + 1] == '\n') {
-                    req.end = i + 1;
-                    line_end = i - 1;
-                    break;
-                }
-            }
+    } // else error(s)
 
-            // RFC 7230 section 3.1.1 does not prohibit embeded CR like RFC 2616 used to.
-            // However it does explicitly state an exact syntax which omits un-encoded CR
-            // and defines 400 (Bad Request) as the required action when
-            // handed an invalid request-line.
-            request_parse_status = Http::scBadRequest;
-            return -1;
-        }
+    // non-delimiter found after accepted method bytes means ...
+    if (methodFound.length() == maxMethodLength) {
+        // method longer than acceptible.
+        // RFC 7230 section 3.1.1 mandatory (SHOULD) 501 response
+        request_parse_status = Http::scNotImplemented;
+        debugs(33, 5, "invalid request-line. method too long");
+    } else {
+        // invalid character in the URL
+        // RFC 7230 section 3.1.1 required (SHOULD) 400 response
+        request_parse_status = Http::scBadRequest;
+        debugs(33, 5, "invalid request-line. missing method delimiter");
     }
+    return -1;
+}
 
-    if (req.end == -1) {
-        // DoS protection against long first-line
-        if ((size_t)buf_.length() >= Config.maxRequestHeaderSize) {
-            debugs(33, 5, "Too large request-line");
-            // RFC 7230 section 3.1.1 mandatory 414 response if URL longer than acceptible.
-            request_parse_status = Http::scUriTooLong;
-            return -1;
-        }
+static CharacterSet
+uriValidCharacters()
+{
+    CharacterSet UriChars("URI-Chars","");
 
-        debugs(74, 5, "Parser: retval 0: from " << req.start <<
-               "->" << req.end << ": needs more data to complete first line.");
-        return 0;
-    }
+    /* RFC 3986 section 2:
+     * "
+     *   A URI is composed from a limited set of characters consisting of
+     *   digits, letters, and a few graphic symbols.
+     * "
+     */
+    // RFC 3986 section 2.1 - percent encoding "%" HEXDIG
+    UriChars.add('%');
+    UriChars += CharacterSet::HEXDIG;
+    // RFC 3986 section 2.2 - reserved characters
+    UriChars += CharacterSet("gen-delims", ":/?#[]@");
+    UriChars += CharacterSet("sub-delims", "!$&'()*+,;=");
+    // RFC 3986 section 2.3 - unreserved characters
+    UriChars += CharacterSet::ALPHA;
+    UriChars += CharacterSet::DIGIT;
+    UriChars += CharacterSet("unreserved", "-._~");
+
+    return UriChars;
+}
 
-    // NP: we have now seen EOL, more-data (0) cannot occur.
-    //     From here on any failure is -1, success is 1
+int
+Http::One::RequestParser::parseUriField(::Parser::Tokenizer &tok)
+{
+    // URI field is a sequence of ... what? segments all have different valid charset
+    // go with non-whitespace non-binary characters for now
+    static CharacterSet UriChars = uriValidCharacters();
+
+    /* Arbitrary 64KB URI upper length limit.
+     *
+     * Not quite as arbitrary as it seems though. Old SquidString objects
+     * cannot store strings larger than 64KB, so we must limit until they
+     * have all been replaced with SBuf.
+     *
+     * Not that it matters but RFC 7230 section 3.1.1 requires (RECOMMENDED)
+     * at least 8000 octets for the whole line, including method and version.
+     */
+    const size_t maxUriLength = min(static_cast<size_t>(Config.maxRequestHeaderSize) - firstLineSize(),
+                                    static_cast<size_t>((64*1024)-1));
 
-    // Input Validation:
+    SBuf uriFound;
 
-    // DoS protection against long first-line
-    if ((size_t)(req.end-req.start) >= Config.maxRequestHeaderSize) {
-        debugs(33, 5, "Too large request-line");
-        request_parse_status = Http::scUriTooLong;
-        return -1;
+    // RFC 7230 HTTP/1.x URI are followed by at least one whitespace delimiter
+    if (tok.prefix(uriFound, UriChars, maxUriLength) && tok.skipOne(CharacterSet::SP)) {
+        uri_ = uriFound;
+        buf_ = tok.remaining(); // incremental parse checkpoint
+        return 1;
+
+        // RFC 1945 for GET the line terminator may follow URL instead of a delimiter
+    } else if (method_ == Http::METHOD_GET && skipLineTerminator(tok)) {
+        debugs(33, 5, "HTTP/0.9 syntax request-line detected");
+        msgProtocol_ = Http::ProtocolVersion(0,9);
+        uri_ = uriFound; // found by successful prefix() call earlier.
+        request_parse_status = Http::scOkay;
+        buf_ = tok.remaining(); // incremental parse checkpoint
+        return 1;
+
+    } else if (tok.atEnd()) {
+        debugs(74, 5, "Parser needs more data to find URI");
+        return 0;
     }
 
-    // Process what we now know about the line structure into field offsets
-    // generating HTTP status for any aborts as we go.
+    // else errors...
 
-    // First non-whitespace = beginning of method
-    if (req.start > line_end) {
+    if (uriFound.length() == maxUriLength) {
+        // RFC 7230 section 3.1.1 mandatory (MUST) 414 response
+        request_parse_status = Http::scUriTooLong;
+        debugs(33, 5, "invalid request-line. URI longer than " << maxUriLength << " bytes");
+    } else {
+        // RFC 7230 section 3.1.1 required (SHOULD) 400 response
         request_parse_status = Http::scBadRequest;
-        return -1;
+        debugs(33, 5, "invalid request-line. missing URI delimiter");
     }
-    req.m_start = req.start;
+    return -1;
+}
 
-    // First whitespace = end of method
-    if (first_whitespace > line_end || first_whitespace < req.start) {
-        request_parse_status = Http::scBadRequest; // no method
-        return -1;
+int
+Http::One::RequestParser::parseHttpVersionField(::Parser::Tokenizer &tok)
+{
+    // partial match of HTTP/1 magic prefix
+    if (tok.remaining().length() < Http1magic.length() && Http1magic.startsWith(tok.remaining())) {
+        debugs(74, 5, "Parser needs more data to find version");
+        return 0;
     }
-    req.m_end = first_whitespace - 1;
-    if (req.m_end < req.m_start) {
-        request_parse_status = Http::scBadRequest; // missing URI?
+
+    if (!tok.skip(Http1magic)) {
+        debugs(74, 5, "invalid request-line. not HTTP/1 protocol");
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
 
-    /* Set method_ */
-    const SBuf tmp = buf_.substr(req.m_start, req.m_end - req.m_start + 1);
-    method_ = HttpRequestMethod(tmp);
-
-    // First non-whitespace after first SP = beginning of URL+Version
-    if (second_word > line_end || second_word < req.start) {
-        request_parse_status = Http::scBadRequest; // missing URI
-        return -1;
+    if (tok.atEnd()) {
+        debugs(74, 5, "Parser needs more data to find version");
+        return 0;
     }
-    req.u_start = second_word;
 
-    // RFC 1945: SP and version following URI are optional, marking version 0.9
-    // we identify this by the last whitespace being earlier than URI start
-    if (last_whitespace < second_word && last_whitespace >= req.start) {
-        msgProtocol_ = Http::ProtocolVersion(0,9);
-        req.u_end = line_end;
-        uri_ = buf_.substr(req.u_start, req.u_end - req.u_start + 1);
-        request_parse_status = Http::scOkay; // HTTP/0.9
+    // get the version minor DIGIT
+    SBuf digit;
+    if (tok.prefix(digit, CharacterSet::DIGIT, 1) && skipLineTerminator(tok)) {
+
+        // found version fully AND terminator
+        msgProtocol_ = Http::ProtocolVersion(1, (*digit.rawContent() - '0'));
+        request_parse_status = Http::scOkay;
+        buf_ = tok.remaining(); // incremental parse checkpoint
         return 1;
-    } else {
-        // otherwise last whitespace is somewhere after end of URI.
-        req.u_end = last_whitespace;
-        // crop any trailing whitespace in the area we think of as URI
-        for (; req.u_end >= req.u_start && xisspace(buf_[req.u_end]); --req.u_end);
-    }
-    if (req.u_end < req.u_start) {
-        request_parse_status = Http::scBadRequest; // missing URI
-        return -1;
+
+    } else if (tok.atEnd() || (tok.skip('\r') && tok.atEnd())) {
+        debugs(74, 5, "Parser needs more data to find version");
+        return 0;
+
+    } // else error ...
+
+    // non-DIGIT. invalid version number.
+    request_parse_status = Http::scHttpVersionNotSupported;
+    debugs(33, 5, "invalid request-line. garbage before line terminator");
+    return -1;
+}
+
+/**
+ * Attempt to parse the first line of a new request message.
+ *
+ * Governed by:
+ *  RFC 1945 section 5.1
+ *  RFC 7230 section 2.6, 3.1 and 3.5
+ *
+ * Parsing state is stored between calls. The current implementation uses
+ * checkpoints after each successful request-line field.
+ * The return value tells you whether the parsing is completed or not.
+ *
+ * \retval -1  an error occurred. request_parse_status indicates HTTP status result.
+ * \retval  1  successful parse. member fields contain the request-line items
+ * \retval  0  more data is needed to complete the parse
+ */
+int
+Http::One::RequestParser::parseRequestFirstLine()
+{
+    ::Parser::Tokenizer tok(buf_);
+
+    debugs(74, 5, "parsing possible request: buf.length=" << buf_.length());
+    debugs(74, DBG_DATA, buf_);
+
+    // NP: would be static, except it need to change with reconfigure
+    CharacterSet WspDelim = CharacterSet::SP; // strict parse only accepts SP
+
+    if (Config.onoff.relaxed_header_parser) {
+        // RFC 7230 section 3.5
+        // tolerant parser MAY accept any of SP, HTAB, VT (%x0B), FF (%x0C), or bare CR
+        // as whitespace between request-line fields
+        WspDelim += CharacterSet::HTAB
+                    + CharacterSet("VT,FF","\x0B\x0C")
+                    + CharacterSet::CR;
     }
-    uri_ = buf_.substr(req.u_start, req.u_end - req.u_start + 1);
 
-    // Last whitespace SP = before start of protocol/version
-    if (last_whitespace >= line_end) {
-        request_parse_status = Http::scBadRequest; // missing version
-        return -1;
+    // only search for method if we have not yet found one
+    if (method_ == Http::METHOD_NONE) {
+        const int res = parseMethodField(tok, WspDelim);
+        if (res < 1)
+            return res;
+        // else keep going...
     }
-    req.v_start = last_whitespace + 1;
-    req.v_end = line_end;
 
-    /* RFC 7230 section 2.6 : handle unsupported HTTP major versions cleanly. */
-    if ((req.v_end - req.v_start +1) < (int)Http1magic.length() || !buf_.substr(req.v_start, SBuf::npos).startsWith(Http1magic)) {
-        // non-HTTP/1 protocols not supported / implemented.
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
+    // tolerant parser allows multiple whitespace characters between request-line fields
+    if (Config.onoff.relaxed_header_parser) {
+        const size_t garbage = tok.skipAll(WspDelim);
+        if (garbage > 0) {
+            firstLineGarbage_ += garbage;
+            buf_ = tok.remaining(); // re-checkpoint after garbage
+        }
+    }
+    if (tok.atEnd()) {
+        debugs(74, 5, "Parser needs more data");
+        return 0;
     }
-    // NP: magic octets include the protocol name and major version DIGIT.
-    msgProtocol_.protocol = AnyP::PROTO_HTTP;
-    msgProtocol_.major = 1;
 
-    int i = req.v_start + Http1magic.length() -1;
+    // from here on, we have two possible parse paths: whitespace tolerant, and strict
+    if (Config.onoff.relaxed_header_parser) {
+        // whitespace tolerant
+
+        // NOTES:
+        // * this would be static, except WspDelim changes with reconfigure
+        // * HTTP-version charset is included by uriValidCharacters()
+        // * terminal CR is included by WspDelim here in relaxed parsing
+        CharacterSet LfDelim = uriValidCharacters() + WspDelim;
+
+        // seek the LF character, then tokenize the line in reverse
+        SBuf line;
+        if (tok.prefix(line, LfDelim) && tok.skip('\n')) {
+            ::Parser::Tokenizer rTok(line);
+            SBuf nil;
+            (void)rTok.suffix(nil,CharacterSet::CR); // optional CR in terminator
+            SBuf digit;
+            if (rTok.suffix(digit,CharacterSet::DIGIT) && rTok.skipSuffix(Http1magic) && rTok.suffix(nil,WspDelim)) {
+                uri_ = rTok.remaining();
+                msgProtocol_ = Http::ProtocolVersion(1, (*digit.rawContent() - '0'));
+                if (uri_.isEmpty()) {
+                    debugs(33, 5, "invalid request-line. missing URL");
+                    request_parse_status = Http::scBadRequest;
+                    return -1;
+                }
 
-    // catch missing minor part
-    if (++i > line_end) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
+                request_parse_status = Http::scOkay;
+                buf_ = tok.remaining(); // incremental parse checkpoint
+                return 1;
+
+            } else if (method_ == Http::METHOD_GET) {
+                // RFC 1945 - for GET the line terminator may follow URL instead of a delimiter
+                debugs(33, 5, "HTTP/0.9 syntax request-line detected");
+                msgProtocol_ = Http::ProtocolVersion(0,9);
+                static const SBuf cr("\r",1);
+                uri_ = line.trim(cr,false,true);
+                request_parse_status = Http::scOkay;
+                buf_ = tok.remaining(); // incremental parse checkpoint
+                return 1;
+            }
+
+            debugs(33, 5, "invalid request-line. not HTTP");
+            request_parse_status = Http::scBadRequest;
+            return -1;
+        }
+
+        debugs(74, 5, "Parser needs more data");
+        return 0;
     }
-    /* next should be one or more digits */
-    if (!isdigit(buf_[i])) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
+    // else strict non-whitespace tolerant parse
+
+    // only search for request-target (URL) if we have not yet found one
+    if (uri_.isEmpty()) {
+        const int res = parseUriField(tok);
+        if (res < 1 || msgProtocol_.protocol == AnyP::PROTO_HTTP)
+            return res;
+        // else keep going...
     }
-    int min = 0;
-    for (; i <= line_end && (isdigit(buf_[i])) && min < 65536; ++i) {
-        min = min * 10;
-        min = min + (buf_[i]) - '0';
+
+    if (tok.atEnd()) {
+        debugs(74, 5, "Parser needs more data");
+        return 0;
     }
-    // catch too-big values or trailing garbage
-    if (min >= 65536 || i < line_end) {
-        request_parse_status = Http::scHttpVersionNotSupported;
-        return -1;
+
+    // HTTP/1 version suffix (protocol magic) followed by CR*LF
+    if (msgProtocol_.protocol == AnyP::PROTO_NONE) {
+        return parseHttpVersionField(tok);
     }
-    msgProtocol_.minor = min;
 
-    /*
-     * Rightio - we have all the schtuff. Return true; we've got enough.
-     */
-    request_parse_status = Http::scOkay;
-    return 1;
+    // If we got here this method has been called too many times
+    request_parse_status = Http::scInternalServerError;
+    debugs(33, 5, "ERROR: Parser already processed request-line");
+    return -1;
 }
 
 bool
@@ -305,15 +385,13 @@ Http::One::RequestParser::parse(const SBuf &aBuf)
 
         // first-line (or a look-alike) found successfully.
         if (retcode > 0) {
-            buf_.consume(firstLineSize()); // first line bytes including CRLF terminator are now done.
             parsingStage_ = HTTP_PARSE_MIME;
         }
 
-        debugs(74, 5, "request-line: retval " << retcode << ": from " << req.start << "->" << req.end <<
-               " line={" << aBuf.length() << ", data='" << aBuf << "'}");
-        debugs(74, 5, "request-line: method " << req.m_start << "->" << req.m_end << " (" << method_ << ")");
-        debugs(74, 5, "request-line: url " << req.u_start << "->" << req.u_end << " (" << uri_ << ")");
-        debugs(74, 5, "request-line: proto " << req.v_start << "->" << req.v_end << " (" << msgProtocol_ << ")");
+        debugs(74, 5, "request-line: retval " << retcode << ": line={" << aBuf.length() << ", data='" << aBuf << "'}");
+        debugs(74, 5, "request-line: method: " << method_);
+        debugs(74, 5, "request-line: url: " << uri_);
+        debugs(74, 5, "request-line: proto: " << msgProtocol_);
         debugs(74, 5, "Parser: bytes processed=" << (aBuf.length()-buf_.length()));
         PROF_stop(HttpParserParseReqLine);
 
@@ -13,6 +13,10 @@
 #include "http/RequestMethod.h"
 #include "http/StatusCode.h"
 
+namespace Parser {
+class Tokenizer;
+}
+
 namespace Http {
 namespace One {
 
@@ -32,7 +36,7 @@ class RequestParser : public Http1::Parser
 
     /* Http::One::Parser API */
     virtual void clear() {*this = RequestParser();}
-    virtual Http1::Parser::size_type firstLineSize() const {return req.end - req.start + 1;}
+    virtual Http1::Parser::size_type firstLineSize() const;
     virtual bool parse(const SBuf &aBuf);
 
     /// the HTTP method if this is a request message
@@ -50,21 +54,19 @@ class RequestParser : public Http1::Parser
 private:
     void skipGarbageLines();
     int parseRequestFirstLine();
-
-    /// Offsets for pieces of the (HTTP request) Request-Line as per RFC 7230 section 3.1.1.
-    /// only valid before and during parse stage HTTP_PARSE_FIRST
-    struct request_offsets {
-        int start, end;
-        int m_start, m_end; // method
-        int u_start, u_end; // url
-        int v_start, v_end; // version (full text)
-    } req;
+    int parseMethodField(::Parser::Tokenizer &, const CharacterSet &);
+    int parseUriField(::Parser::Tokenizer &);
+    int parseHttpVersionField(::Parser::Tokenizer &);
 
     /// what request method has been found on the first line
     HttpRequestMethod method_;
 
-    /// raw copy of the original client reqeust-line URI field
+    /// raw copy of the original client request-line URI field
     SBuf uri_;
+
+    /// amount of garbage bytes tolerantly skipped inside the request-line
+    /// may be -1 if sender only omitted CR on terminator
+    int64_t firstLineGarbage_;
 };
 
 } // namespace One
@@ -80,7 +80,8 @@ nodist_pinger_SOURCES = \
 pinger_LDFLAGS = $(LIBADD_DL)
 pinger_LDADD=\
 	libicmp-core.la \
-	../ip/libip.la \
+	$(top_builddir)/src/ip/libip.la \
+	$(top_builddir)/src/base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -58,7 +58,37 @@ typedef enum {
     STATE_BODY
 } netdb_conn_state_t;
 
-typedef struct {
+class netdbExchangeState
+{
+    CBDATA_CLASS(netdbExchangeState);
+
+public:
+    netdbExchangeState(CachePeer *aPeer, HttpRequest *theReq) :
+        p(cbdataReference(aPeer)),
+        e(NULL),
+        sc(NULL),
+        r(theReq),
+        used(0),
+        buf_sz(NETDB_REQBUF_SZ),
+        buf_ofs(0),
+        connstate(STATE_HEADER)
+    {
+        *buf = 0;
+
+        assert(NULL != r);
+        HTTPMSGLOCK(r);
+        // TODO: check if we actually need to do this. should be implicit
+        r->http_ver = Http::ProtocolVersion();
+    }
+
+    ~netdbExchangeState() {
+        debugs(38, 3, e->url());
+        storeUnregister(sc, e, this);
+        e->unlock("netdbExchangeDone");
+        HTTPMSGUNLOCK(r);
+        cbdataReferenceDone(p);
+    }
+
     CachePeer *p;
     StoreEntry *e;
     store_client *sc;
@@ -68,7 +98,9 @@ typedef struct {
     char buf[NETDB_REQBUF_SZ];
     int buf_ofs;
     netdb_conn_state_t connstate;
-} netdbExchangeState;
+};
+
+CBDATA_CLASS_INIT(netdbExchangeState);
 
 static hash_table *addr_table = NULL;
 static hash_table *host_table = NULL;
@@ -92,7 +124,6 @@ static QS netdbLRU;
 static FREE netdbFreeNameEntry;
 static FREE netdbFreeNetdbEntry;
 static STCB netdbExchangeHandleReply;
-static void netdbExchangeDone(void *);
 
 /* We have to keep a local list of CachePeer names.  The Peers structure
  * gets freed during a reconfigure.  We want this database to
@@ -264,7 +295,7 @@ netdbAdd(Ip::Address &addr)
 }
 
 static void
-netdbSendPing(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
+netdbSendPing(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
     Ip::Address addr;
     char *hostname = NULL;
@@ -689,16 +720,15 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
     if (!cbdataReferenceValid(ex->p)) {
         debugs(38, 3, "netdbExchangeHandleReply: Peer became invalid");
-        netdbExchangeDone(ex);
+        delete ex;
         return;
     }
 
     debugs(38, 3, "netdbExchangeHandleReply: for '" << ex->p->host << ":" << ex->p->http_port << "'");
 
-    if (receivedData.length == 0 &&
-            !receivedData.flags.error) {
+    if (receivedData.length == 0 && !receivedData.flags.error) {
         debugs(38, 3, "netdbExchangeHandleReply: Done");
-        netdbExchangeDone(ex);
+        delete ex;
         return;
     }
 
@@ -723,7 +753,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
             debugs(38, 3, "netdbExchangeHandleReply: reply status " << rep->sline.status());
 
             if (rep->sline.status() != Http::scOkay) {
-                netdbExchangeDone(ex);
+                delete ex;
                 return;
             }
 
@@ -789,7 +819,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
             default:
                 debugs(38, DBG_IMPORTANT, "netdbExchangeHandleReply: corrupt data, aborting");
-                netdbExchangeDone(ex);
+                delete ex;
                 return;
             }
         }
@@ -845,7 +875,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
     if (EBIT_TEST(ex->e->flags, ENTRY_ABORTED)) {
         debugs(38, 3, "netdbExchangeHandleReply: ENTRY_ABORTED");
-        netdbExchangeDone(ex);
+        delete ex;
     } else if (ex->e->store_status == STORE_PENDING) {
         StoreIOBuffer tempBuffer;
         tempBuffer.offset = ex->used;
@@ -857,18 +887,6 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
     }
 }
 
-static void
-netdbExchangeDone(void *data)
-{
-    netdbExchangeState *ex = (netdbExchangeState *)data;
-    debugs(38, 3, "netdbExchangeDone: " << ex->e->url()  );
-    HTTPMSGUNLOCK(ex->r);
-    storeUnregister(ex->sc, ex->e, ex);
-    ex->e->unlock("netdbExchangeDone");
-    cbdataReferenceDone(ex->p);
-    cbdataFree(ex);
-}
-
 static void
 netdbRegisterWithCacheManager(void)
 {
@@ -1266,42 +1284,31 @@ netdbBinaryExchange(StoreEntry * s)
     s->complete();
 }
 
-#if USE_ICMP
-CBDATA_TYPE(netdbExchangeState);
-#endif
-
 void
 netdbExchangeStart(void *data)
 {
 #if USE_ICMP
     CachePeer *p = (CachePeer *)data;
-    char *uri;
-    netdbExchangeState *ex;
-    StoreIOBuffer tempBuffer;
-    CBDATA_INIT_TYPE(netdbExchangeState);
-    ex = cbdataAlloc(netdbExchangeState);
-    ex->p = cbdataReference(p);
-    uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", "netdb");
+    char *uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", "netdb");
     debugs(38, 3, "netdbExchangeStart: Requesting '" << uri << "'");
     assert(NULL != uri);
-    ex->r = HttpRequest::CreateFromUrl(uri);
+    HttpRequest *req = HttpRequest::CreateFromUrl(uri);
 
-    if (NULL == ex->r) {
+    if (req == NULL) {
         debugs(38, DBG_IMPORTANT, "netdbExchangeStart: Bad URI " << uri);
         return;
     }
 
-    HTTPMSGLOCK(ex->r);
-    assert(NULL != ex->r);
-    ex->r->http_ver = Http::ProtocolVersion();
-    ex->connstate = STATE_HEADER;
+    netdbExchangeState *ex = new netdbExchangeState(p, req);
     ex->e = storeCreateEntry(uri, uri, RequestFlags(), Http::METHOD_GET);
-    ex->buf_sz = NETDB_REQBUF_SZ;
     assert(NULL != ex->e);
-    ex->sc = storeClientListAdd(ex->e, ex);
-    tempBuffer.offset = 0;
+
+    StoreIOBuffer tempBuffer;
     tempBuffer.length = ex->buf_sz;
     tempBuffer.data = ex->buf;
+
+    ex->sc = storeClientListAdd(ex->e, ex);
+
     storeClientCopy(ex->sc, ex->e, tempBuffer,
                     netdbExchangeHandleReply, ex);
     ex->r->flags.loopDetected = true;   /* cheat! -- force direct */
@@ -22,6 +22,22 @@
 
 #include <cerrno>
 
+CBDATA_CLASS_INIT(acl_tos);
+
+acl_tos::~acl_tos()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
+
+CBDATA_CLASS_INIT(acl_nfmark);
+
+acl_nfmark::~acl_nfmark()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
+
 void
 Ip::Qos::getTosFromServer(const Comm::ConnectionPointer &server, fde *clientFde)
 {
@@ -24,21 +24,28 @@
 class fde;
 
 // TODO: move to new ACL framework
-// not integrated in namespace, as this class uses a strange CBDATA definition
-// POD
 class acl_tos
 {
+    CBDATA_CLASS(acl_tos);
+
 public:
+    acl_tos() : next(NULL), aclList(NULL) {}
+    ~acl_tos();
+
     acl_tos *next;
     ACLList *aclList;
     tos_t tos;
 };
+
 // TODO: move to new ACL framework
-// not integrated in namespace, as this class uses a strange CBDATA definition
-// POD
 class acl_nfmark
 {
+    CBDATA_CLASS(acl_nfmark);
+
 public:
+    acl_nfmark() : next(NULL), aclList(NULL) {}
+    ~acl_nfmark();
+
     acl_nfmark *next;
     ACLList *aclList;
     nfmark_t nfmark;
@@ -251,7 +251,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         else
             x = read(prfd, hello_buf, sizeof(hello_buf)-1);
         if (x >= 0)
-            hello_buf[x+1] = '\0';
+            hello_buf[x] = '\0';
 
         if (x < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: PARENT: hello read test failed");
@@ -50,7 +50,8 @@ void Kid::start(pid_t cpid)
 }
 
 /// called when kid terminates, sets exiting status
-void Kid::stop(status_type theExitStatus)
+void
+Kid::stop(PidStatus const theExitStatus)
 {
     assert(running());
     assert(startTime != 0);
@@ -10,17 +10,13 @@
 #define SQUID_IPC_KID_H
 
 #include "SquidString.h"
+#include "tools.h"
 
 /// Squid child, including current forked process info and
 /// info persistent across restarts
 class Kid
 {
 public:
-#if _SQUID_NEXT_
-    typedef union wait status_type;
-#else
-    typedef int status_type;
-#endif
 
     /// keep restarting until the number of bad failures exceed this limit
     enum { badFailureLimit = 4 };
@@ -37,7 +33,7 @@ class Kid
     void start(pid_t cpid);
 
     /// called when kid terminates, sets exiting status
-    void stop(status_type exitStatus);
+    void stop(PidStatus const exitStatus);
 
     /// returns true if tracking of kid is stopped
     bool running() const;
@@ -84,7 +80,7 @@ class Kid
     pid_t  pid; ///< current (for a running kid) or last (for stopped kid) PID
     time_t startTime; ///< last start time
     bool   isRunning; ///< whether the kid is assumed to be alive
-    status_type status; ///< exit status of a stopped kid
+    PidStatus status; ///< exit status of a stopped kid
 };
 
 // TODO: processes may not be kids; is there a better place to put this?
@@ -88,7 +88,8 @@ Ipc::Mem::Segment::create(const off_t aSize)
     assert(aSize > 0);
     assert(theFD < 0);
 
-    theFD = shm_open(theName.termedBuf(), O_CREAT | O_RDWR | O_TRUNC,
+    // OS X does not allow using O_TRUNC here.
+    theFD = shm_open(theName.termedBuf(), O_CREAT | O_RDWR,
                      S_IRUSR | S_IWUSR);
     if (theFD < 0) {
         debugs(54, 5, HERE << "shm_open " << theName << ": " << xstrerror());
@@ -97,14 +98,19 @@ Ipc::Mem::Segment::create(const off_t aSize)
     }
 
     if (ftruncate(theFD, aSize)) {
-        debugs(54, 5, HERE << "ftruncate " << theName << ": " << xstrerror());
+        const int savedError = errno;
+        unlink();
+        debugs(54, 5, HERE << "ftruncate " << theName << ": " << xstrerr(savedError));
         fatalf("Ipc::Mem::Segment::create failed to ftruncate(%s): %s\n",
-               theName.termedBuf(), xstrerror());
+               theName.termedBuf(), xstrerr(savedError));
     }
+    // We assume that the shm_open(O_CREAT)+ftruncate() combo zeros the segment.
 
-    assert(statSize("Ipc::Mem::Segment::create") == aSize); // paranoid
+    theSize = statSize("Ipc::Mem::Segment::create");
+
+    // OS X will round up to a full page, so not checking for exact size match.
+    assert(theSize >= aSize);
 
-    theSize = aSize;
     theReserved = 0;
     doUnlink = true;
 
@@ -12,15 +12,14 @@
 #include "CacheManager.h"
 #include "cbdata.h"
 #include "dlink.h"
-#include "DnsLookupDetails.h"
+#include "dns/LookupDetails.h"
+#include "dns/rfc3596.h"
 #include "event.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
 #include "ipcache.h"
 #include "mgr/Registration.h"
-#include "rfc3596.h"
 #include "SquidConfig.h"
-#include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -321,7 +320,7 @@ ipcacheCallback(ipcache_entry *i, int wait)
     i->handler = NULL;
 
     if (cbdataReferenceValidDone(i->handlerData, &cbdata)) {
-        const DnsLookupDetails details(i->error_message, wait);
+        const Dns::LookupDetails details(i->error_message, wait);
         callback((i->addrs.count ? &i->addrs : NULL), details, cbdata);
     }
 
@@ -504,7 +503,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     if (name == NULL || name[0] == '\0') {
         debugs(14, 4, "ipcache_nbgethostbyname: Invalid name!");
         ++IpcacheStats.invalid;
-        const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
+        const Dns::LookupDetails details("Invalid hostname", -1); // error, no lookup
         if (handler)
             handler(NULL, details, handlerData);
         return;
@@ -513,7 +512,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     if ((addrs = ipcacheCheckNumeric(name))) {
         debugs(14, 4, "ipcache_nbgethostbyname: BYPASS for '" << name << "' (already numeric)");
         ++IpcacheStats.numeric_hits;
-        const DnsLookupDetails details(NULL, -1); // no error, no lookup
+        const Dns::LookupDetails details; // no error, no lookup
         if (handler)
             handler(addrs, details, handlerData);
         return;
@@ -9,13 +9,13 @@
 #ifndef _SQUID_IPCACHE_H
 #define _SQUID_IPCACHE_H
 
+#include "dns/forward.h"
+
 namespace Ip
 {
 class Address;
 }
 
-class DnsLookupDetails;
-
 typedef struct _ipcache_addrs {
     Ip::Address *in_addrs;
     unsigned char *bad_mask;
@@ -24,7 +24,7 @@ typedef struct _ipcache_addrs {
     unsigned char badcount;
 } ipcache_addrs;
 
-typedef void IPH(const ipcache_addrs *, const DnsLookupDetails &details, void *);
+typedef void IPH(const ipcache_addrs *, const Dns::LookupDetails &details, void *);
 
 void ipcache_purgelru(void *);
 void ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData);
@@ -19,7 +19,7 @@ namespace Format
 class Format;
 }
 
-/// representaiton of a custom log directive. Currently a POD.
+/// representation of a custom log directive.
 class CustomLog
 {
 public:
@@ -33,6 +33,8 @@ class CustomLog
     size_t bufferSize;
     /// whether unrecoverable errors (e.g., dropping a log record) kill worker
     bool fatal;
+    /// How many log files to retain when rotating. Default: obey logfile_rotate
+    int16_t rotateCount;
 };
 
 #endif /* SQUID_CUSTOMLOG_H_ */
@@ -18,7 +18,21 @@
 #include "log/ModUdp.h"
 #include "log/TcpLogger.h"
 
-CBDATA_TYPE(Logfile);
+CBDATA_CLASS_INIT(Logfile);
+
+Logfile::Logfile(const char *aPath) :
+    sequence_number(0),
+    data(NULL),
+    f_linestart(NULL),
+    f_linewrite(NULL),
+    f_lineend(NULL),
+    f_flush(NULL),
+    f_rotate(NULL),
+    f_close(NULL)
+{
+    xstrncpy(path, aPath, sizeof(path));
+    flags.fatal = 0;
+}
 
 Logfile *
 logfileOpen(const char *path, size_t bufsz, int fatal_flag)
@@ -27,10 +41,8 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
     const char *patharg;
 
     debugs(50, DBG_IMPORTANT, "Logfile: opening log " << path);
-    CBDATA_INIT_TYPE(Logfile);
 
-    Logfile *lf = cbdataAlloc(Logfile);
-    xstrncpy(lf->path, path, MAXPATHLEN);
+    Logfile *lf = new Logfile(path);
     patharg = path;
     /* need to call the per-logfile-type code */
     if (strncmp(path, "stdio:", 6) == 0) {
@@ -61,7 +73,7 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
         else
             debugs(50, DBG_IMPORTANT, "logfileOpen: " << path << ": couldn't open!");
         lf->f_close(lf);
-        cbdataFree(lf);
+        delete lf;
         return NULL;
     }
     assert(lf->data != NULL);
@@ -80,14 +92,14 @@ logfileClose(Logfile * lf)
     debugs(50, DBG_IMPORTANT, "Logfile: closing log " << lf->path);
     lf->f_flush(lf);
     lf->f_close(lf);
-    cbdataFree(lf);
+    delete lf;
 }
 
 void
-logfileRotate(Logfile * lf)
+logfileRotate(Logfile * lf, int16_t rotateCount)
 {
     debugs(50, DBG_IMPORTANT, "logfileRotate: " << lf->path);
-    lf->f_rotate(lf);
+    lf->f_rotate(lf, rotateCount);
 }
 
 void
@@ -9,6 +9,7 @@
 #ifndef SQUID_SRC_LOG_FILE_H
 #define SQUID_SRC_LOG_FILE_H
 
+#include "cbdata.h"
 #include "dlink.h"
 
 #if HAVE_SYS_PARAM_H
@@ -31,13 +32,17 @@ typedef void LOGLINESTART(Logfile *);
 typedef void LOGWRITE(Logfile *, const char *, size_t len);
 typedef void LOGLINEEND(Logfile *);
 typedef void LOGFLUSH(Logfile *);
-typedef void LOGROTATE(Logfile *);
+typedef void LOGROTATE(Logfile *, const int16_t);
 typedef void LOGCLOSE(Logfile *);
 
 class Logfile
 {
+    CBDATA_CLASS(Logfile);
 
 public:
+    explicit Logfile(const char *aPath);
+    ~Logfile() {}
+
     char path[MAXPATHLEN];
 
     struct {
@@ -60,7 +65,7 @@ class Logfile
 /* Legacy API */
 Logfile *logfileOpen(const char *path, size_t bufsz, int);
 void logfileClose(Logfile * lf);
-void logfileRotate(Logfile * lf);
+void logfileRotate(Logfile * lf, int16_t rotateCount);
 void logfileWrite(Logfile * lf, char *buf, size_t len);
 void logfileFlush(Logfile * lf);
 void logfilePrintf(Logfile * lf, const char *fmt,...) PRINTF_FORMAT_ARG2;
@@ -269,7 +269,7 @@ logfile_mod_daemon_close(Logfile * lf)
 }
 
 static void
-logfile_mod_daemon_rotate(Logfile * lf)
+logfile_mod_daemon_rotate(Logfile * lf, const int16_t)
 {
     char tb[3];
     debugs(50, DBG_IMPORTANT, "logfileRotate: " << lf->path);
@@ -98,14 +98,13 @@ logfile_mod_stdio_flush(Logfile * lf)
 }
 
 static void
-logfile_mod_stdio_rotate(Logfile * lf)
+logfile_mod_stdio_rotate(Logfile * lf, const int16_t nRotate)
 {
 #ifdef S_ISREG
 
     struct stat sb;
 #endif
 
-    int i;
     char from[MAXPATHLEN];
     char to[MAXPATHLEN];
     l_stdio_t *ll = (l_stdio_t *) lf->data;
@@ -123,7 +122,7 @@ logfile_mod_stdio_rotate(Logfile * lf)
     debugs(0, DBG_IMPORTANT, "Rotate log file " << lf->path);
 
     /* Rotate numbers 0 through N up one */
-    for (i = Config.Log.rotateNumber; i > 1;) {
+    for (int16_t i = nRotate; i > 1;) {
         --i;
         snprintf(from, MAXPATHLEN, "%s.%d", realpath, i - 1);
         snprintf(to, MAXPATHLEN, "%s.%d", realpath, i);
@@ -135,7 +134,7 @@ logfile_mod_stdio_rotate(Logfile * lf)
 
     file_close(ll->fd);     /* always close */
 
-    if (Config.Log.rotateNumber > 0) {
+    if (nRotate > 0) {
         snprintf(to, MAXPATHLEN, "%s.%d", realpath, 0);
         xrename(realpath, to);
     }
@@ -120,7 +120,7 @@ logfile_mod_syslog_flush(Logfile *)
 }
 
 static void
-logfile_mod_syslog_rotate(Logfile *)
+logfile_mod_syslog_rotate(Logfile *, const int16_t)
 {
 }
 
@@ -104,7 +104,7 @@ logfile_mod_udp_lineend(Logfile *)
 }
 
 static void
-logfile_mod_udp_rotate(Logfile *)
+logfile_mod_udp_rotate(Logfile *, const int16_t)
 {
 }
 
@@ -423,7 +423,7 @@ Log::TcpLogger::EndLine(Logfile * lf)
 }
 
 void
-Log::TcpLogger::Rotate(Logfile *)
+Log::TcpLogger::Rotate(Logfile *, const int16_t)
 {
 }
 
@@ -61,7 +61,7 @@ class TcpLogger : public AsyncJob
     static void WriteLine(Logfile *lf, const char *buf, size_t len);
     static void StartLine(Logfile *lf);
     static void EndLine(Logfile *lf);
-    static void Rotate(Logfile *lf);
+    static void Rotate(Logfile *lf, const int16_t);
     static void Close(Logfile *lf);
 
     static TcpLogger *StillLogging(Logfile *lf);
@@ -194,13 +194,14 @@ accessLogRotate(void)
 
     for (log = Config.Log.accesslogs; log; log = log->next) {
         if (log->logfile) {
-            logfileRotate(log->logfile);
+            int16_t rc = (log->rotateCount >= 0 ? log->rotateCount : Config.Log.rotateNumber);
+            logfileRotate(log->logfile, rc);
         }
     }
 
 #if HEADERS_LOG
 
-    logfileRotate(headerslog);
+    logfileRotate(headerslog, Config.Log.rotateNumber);
 
 #endif
 }
@@ -25,6 +25,7 @@
 #include "CpuAffinity.h"
 #include "disk.h"
 #include "DiskIO/DiskIOModule.h"
+#include "dns/forward.h"
 #include "errorpage.h"
 #include "event.h"
 #include "EventLoop.h"
@@ -59,7 +60,6 @@
 #include "refresh.h"
 #include "send-announce.h"
 #include "SquidConfig.h"
-#include "SquidDns.h"
 #include "SquidTime.h"
 #include "stat.h"
 #include "StatCounters.h"
@@ -151,6 +151,7 @@ static volatile int do_reconfigure = 0;
 static volatile int do_rotate = 0;
 static volatile int do_shutdown = 0;
 static volatile int shutdown_status = 0;
+static volatile int do_handle_stopped_child = 0;
 
 static int RotateSignal = -1;
 static int ReconfigureSignal = -1;
@@ -195,6 +196,12 @@ class SignalEngine: public AsyncEngine
 {
 
 public:
+#if KILL_PARENT_OPT
+    SignalEngine(): parentKillNotified(false) {
+        parentPid = getppid();
+    }
+#endif
+
     virtual int checkEvents(int timeout);
 
 private:
@@ -204,6 +211,12 @@ class SignalEngine: public AsyncEngine
     }
 
     void doShutdown(time_t wait);
+    void handleStoppedChild();
+
+#if KILL_PARENT_OPT
+    bool parentKillNotified;
+    pid_t parentPid;
+#endif
 };
 
 int
@@ -221,11 +234,10 @@ SignalEngine::checkEvents(int)
         doShutdown(do_shutdown > 0 ? (int) Config.shutdownLifetime : 0);
         do_shutdown = 0;
     }
-    BroadcastSignalIfAny(DebugSignal);
-    BroadcastSignalIfAny(RotateSignal);
-    BroadcastSignalIfAny(ReconfigureSignal);
-    BroadcastSignalIfAny(ShutdownSignal);
-
+    if (do_handle_stopped_child) {
+        do_handle_stopped_child = 0;
+        handleStoppedChild();
+    }
     PROF_stop(SignalEngine_checkEvents);
     return EVENT_IDLE;
 }
@@ -236,23 +248,63 @@ SignalEngine::doShutdown(time_t wait)
     debugs(1, DBG_IMPORTANT, "Preparing for shutdown after " << statCounter.client_http.requests << " requests");
     debugs(1, DBG_IMPORTANT, "Waiting " << wait << " seconds for active connections to finish");
 
-    shutting_down = 1;
+#if KILL_PARENT_OPT
+    if (!IamMasterProcess() && !parentKillNotified && ShutdownSignal > 0 && parentPid > 1) {
+        debugs(1, DBG_IMPORTANT, "Killing master process, pid " << parentPid);
+        if (kill(parentPid, ShutdownSignal) < 0)
+            debugs(1, DBG_IMPORTANT, "kill " << parentPid << ": " << xstrerror());
+        parentKillNotified = true;
+    }
+#endif
 
-#if USE_WIN32_SERVICE
-    WIN32_svcstatusupdate(SERVICE_STOP_PENDING, (wait + 1) * 1000);
+    if (shutting_down) {
+#if !KILL_PARENT_OPT
+        // Already a shutdown signal has received and shutdown is in progress.
+        // Shutdown as soon as possible.
+        wait = 0;
 #endif
+    } else {
+        shutting_down = 1;
 
-    /* run the closure code which can be shared with reconfigure */
-    serverConnectionsClose();
+        /* run the closure code which can be shared with reconfigure */
+        serverConnectionsClose();
 #if USE_AUTH
-    /* detach the auth components (only do this on full shutdown) */
-    Auth::Scheme::FreeAll();
+        /* detach the auth components (only do this on full shutdown) */
+        Auth::Scheme::FreeAll();
+#endif
+
+        RunRegisteredHere(RegisteredRunner::startShutdown);
+    }
+
+#if USE_WIN32_SERVICE
+    WIN32_svcstatusupdate(SERVICE_STOP_PENDING, (wait + 1) * 1000);
 #endif
 
-    RunRegisteredHere(RegisteredRunner::startShutdown);
     eventAdd("SquidShutdown", &StopEventLoop, this, (double) (wait + 1), 1, false);
 }
 
+void
+SignalEngine::handleStoppedChild()
+{
+#if !_SQUID_WINDOWS_
+    PidStatus status;
+    pid_t pid;
+
+    do {
+        pid = WaitForAnyPid(status, WNOHANG);
+
+#if HAVE_SIGACTION
+
+    } while (pid > 0);
+
+#else
+
+    }
+    while (pid > 0 || (pid < 0 && errno == EINTR));
+#endif
+#endif
+}
+
 static void
 usage(void)
 {
@@ -626,6 +678,21 @@ reconfigure(int sig)
 #endif
 }
 
+/// Shutdown signal handler for master process
+void
+master_shutdown(int sig)
+{
+    do_shutdown = 1;
+    ShutdownSignal = sig;
+
+#if !_SQUID_WINDOWS_
+#if !HAVE_SIGACTION
+    signal(sig, master_shutdown);
+#endif
+#endif
+
+}
+
 void
 shut_down(int sig)
 {
@@ -637,29 +704,20 @@ shut_down(int sig)
 #endif
 
 #if !_SQUID_WINDOWS_
-    const pid_t ppid = getppid();
-
-    if (!IamMasterProcess() && ppid > 1) {
-        // notify master that we are shutting down
-        if (kill(ppid, SIGUSR1) < 0)
-            debugs(1, DBG_IMPORTANT, "Failed to send SIGUSR1 to master process,"
-                   " pid " << ppid << ": " << xstrerror());
-    }
-
-#if KILL_PARENT_OPT
-    if (!IamMasterProcess() && ppid > 1) {
-        debugs(1, DBG_IMPORTANT, "Killing master process, pid " << ppid);
-
-        if (kill(ppid, sig) < 0)
-            debugs(1, DBG_IMPORTANT, "kill " << ppid << ": " << xstrerror());
-    }
-#endif /* KILL_PARENT_OPT */
-
-#if SA_RESETHAND == 0
-    signal(SIGTERM, SIG_DFL);
+#if !HAVE_SIGACTION
+    signal(sig, shut_down);
+#endif
+#endif
+}
 
-    signal(SIGINT, SIG_DFL);
+void
+sig_child(int sig)
+{
+    do_handle_stopped_child = 1;
 
+#if !_SQUID_WINDOWS_
+#if !HAVE_SIGACTION
+    signal(sig, sig_child);
 #endif
 #endif
 }
@@ -745,7 +803,7 @@ mainReconfigureStart(void)
 #if USE_HTCP
     htcpClosePorts();
 #endif
-    dnsShutdown();
+    Dns::Shutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
@@ -832,7 +890,7 @@ mainReconfigureFinish(void *)
     icapLogOpen();
 #endif
     storeLogOpen();
-    dnsInit();
+    Dns::Init();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
 #endif
@@ -881,7 +939,8 @@ mainReconfigureFinish(void *)
             eventDelete(start_announce, NULL);
     }
 
-    writePidFile();     /* write PID file */
+    if (!InDaemonMode())
+        writePidFile(); /* write PID file */
 
     reconfiguring = 0;
 }
@@ -1035,7 +1094,7 @@ mainInitialize(void)
 
     parseEtcHosts();
 
-    dnsInit();
+    Dns::Init();
 
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
@@ -1132,7 +1191,7 @@ mainInitialize(void)
     if (Config.chroot_dir)
         no_suid();
 
-    if (!configured_once)
+    if (!configured_once && !InDaemonMode())
         writePidFile();     /* write PID file */
 
 #if defined(_SQUID_LINUX_THREADS_)
@@ -1151,13 +1210,13 @@ mainInitialize(void)
 
     squid_signal(SIGHUP, reconfigure, SA_RESTART);
 
-    squid_signal(SIGTERM, shut_down, SA_NODEFER | SA_RESETHAND | SA_RESTART);
+    squid_signal(SIGTERM, shut_down, SA_RESTART);
 
-    squid_signal(SIGINT, shut_down, SA_NODEFER | SA_RESETHAND | SA_RESTART);
+    squid_signal(SIGINT, shut_down, SA_RESTART);
 
 #ifdef SIGTTIN
 
-    squid_signal(SIGTTIN, shut_down, SA_NODEFER | SA_RESETHAND | SA_RESTART);
+    squid_signal(SIGTTIN, shut_down, SA_RESTART);
 
 #endif
 
@@ -1439,8 +1498,10 @@ SquidMain(int argc, char **argv)
     RunRegisteredHere(RegisteredRunner::useConfig);
     enter_suid();
 
-    if (!opt_no_daemon && Config.workers > 0)
+    if (InDaemonMode() && IamMasterProcess()) {
         watch_child(argv);
+        // NOTREACHED
+    }
 
     if (opt_create_swap_dirs) {
         /* chroot if configured to run inside chroot */
@@ -1606,15 +1667,8 @@ mainStartScript(const char *prog)
         _exit(-1);
     } else {
         do {
-#if _SQUID_NEXT_
-            union wait status;
-            rpid = wait4(cpid, &status, 0, NULL);
-#else
-
-            int status;
-            rpid = waitpid(cpid, &status, 0);
-#endif
-
+            PidStatus status;
+            rpid = WaitForOnePid(cpid, status, 0);
         } while (rpid != cpid);
     }
 }
@@ -1646,19 +1700,35 @@ checkRunningPid(void)
     return 1;
 }
 
+#if !_SQUID_WINDOWS_
 static void
-watch_child(char *argv[])
+masterCheckAndBroadcastSignals()
 {
-#if !_SQUID_WINDOWS_
-    char *prog;
-#if _SQUID_NEXT_
+    // if (do_reconfigure)
+    //     TODO: hot-reconfiguration of the number of kids and PID file location
 
-    union wait status;
-#else
+    if (do_shutdown)
+        shutting_down = 1;
 
-    int status;
+    BroadcastSignalIfAny(DebugSignal);
+    BroadcastSignalIfAny(RotateSignal);
+    BroadcastSignalIfAny(ReconfigureSignal);
+    BroadcastSignalIfAny(ShutdownSignal);
+}
 #endif
 
+static inline bool
+masterSignaled()
+{
+    return (DebugSignal > 0 || RotateSignal > 0 || ReconfigureSignal > 0 || ShutdownSignal > 0);
+}
+
+static void
+watch_child(char *argv[])
+{
+#if !_SQUID_WINDOWS_
+    char *prog;
+    PidStatus status;
     pid_t pid;
 #ifdef TIOCNOTTY
 
@@ -1667,9 +1737,6 @@ watch_child(char *argv[])
 
     int nullfd;
 
-    if (!IamMasterProcess())
-        return;
-
     openlog(APP_SHORTNAME, LOG_PID | LOG_NDELAY | LOG_CONS, LOG_LOCAL4);
 
     if ((pid = fork()) < 0)
@@ -1709,8 +1776,23 @@ watch_child(char *argv[])
         dup2(nullfd, 2);
     }
 
-    // handle shutdown notifications from kids
-    squid_signal(SIGUSR1, sig_shutdown, SA_RESTART);
+    writePidFile();
+
+#if defined(_SQUID_LINUX_THREADS_)
+    squid_signal(SIGQUIT, rotate_logs, 0);
+    squid_signal(SIGTRAP, sigusr2_handle, 0);
+#else
+    squid_signal(SIGUSR1, rotate_logs, 0);
+    squid_signal(SIGUSR2, sigusr2_handle, 0);
+#endif
+
+    squid_signal(SIGHUP, reconfigure, 0);
+
+    squid_signal(SIGTERM, master_shutdown, 0);
+    squid_signal(SIGINT, master_shutdown, 0);
+#ifdef SIGTTIN
+    squid_signal(SIGTTIN, master_shutdown, 0);
+#endif
 
     if (Config.workers > 128) {
         syslog(LOG_ALERT, "Suspiciously high workers value: %d",
@@ -1723,14 +1805,18 @@ watch_child(char *argv[])
 
     // keep [re]starting kids until it is time to quit
     for (;;) {
-        mainStartScript(argv[0]);
-
+        bool mainStartScriptCalled = false;
         // start each kid that needs to be [re]started; once
-        for (int i = TheKids.count() - 1; i >= 0; --i) {
+        for (int i = TheKids.count() - 1; i >= 0 && !shutting_down; --i) {
             Kid& kid = TheKids.get(i);
             if (!kid.shouldRestart())
                 continue;
 
+            if (!mainStartScriptCalled) {
+                mainStartScript(argv[0]);
+                mainStartScriptCalled = true;
+            }
+
             if ((pid = fork()) == 0) {
                 /* child */
                 openlog(APP_SHORTNAME, LOG_PID | LOG_NDELAY | LOG_CONS, LOG_LOCAL4);
@@ -1748,50 +1834,45 @@ watch_child(char *argv[])
         /* parent */
         openlog(APP_SHORTNAME, LOG_PID | LOG_NDELAY | LOG_CONS, LOG_LOCAL4);
 
-        squid_signal(SIGINT, SIG_IGN, SA_RESTART);
-
-#if _SQUID_NEXT_
-
-        pid = wait3(&status, 0, NULL);
-
-#else
-
-        pid = waitpid(-1, &status, 0);
-
-#endif
-        // Loop to collect all stopped kids before we go to sleep below.
-        do {
-            Kid* kid = TheKids.find(pid);
-            if (kid) {
-                kid->stop(status);
-                if (kid->calledExit()) {
-                    syslog(LOG_NOTICE,
-                           "Squid Parent: %s process %d exited with status %d",
-                           kid->name().termedBuf(),
-                           kid->getPid(), kid->exitStatus());
-                } else if (kid->signaled()) {
-                    syslog(LOG_NOTICE,
-                           "Squid Parent: %s process %d exited due to signal %d with status %d",
-                           kid->name().termedBuf(),
-                           kid->getPid(), kid->termSignal(), kid->exitStatus());
-                } else {
-                    syslog(LOG_NOTICE, "Squid Parent: %s process %d exited",
-                           kid->name().termedBuf(), kid->getPid());
-                }
-                if (kid->hopeless()) {
-                    syslog(LOG_NOTICE, "Squid Parent: %s process %d will not"
-                           " be restarted due to repeated, frequent failures",
-                           kid->name().termedBuf(), kid->getPid());
-                }
+        // If Squid received a signal while checking for dying kids (below) or
+        // starting new kids (above), then do a fast check for a new dying kid
+        // (WaitForAnyPid with the WNOHANG option) and continue to forward
+        // signals to kids. Otherwise, wait for a kid to die or for a signal
+        // to abort the blocking WaitForAnyPid() call.
+        // With the WNOHANG option, we could check whether WaitForAnyPid() was
+        // aborted by a dying kid or a signal, but it is not required: The
+        // next do/while loop will check again for any dying kids.
+        int waitFlag = 0;
+        if (masterSignaled())
+            waitFlag = WNOHANG;
+        pid = WaitForAnyPid(status, waitFlag);
+
+        // check for a stopped kid
+        Kid* kid = pid > 0 ? TheKids.find(pid) : NULL;
+        if (kid) {
+            kid->stop(status);
+            if (kid->calledExit()) {
+                syslog(LOG_NOTICE,
+                       "Squid Parent: %s process %d exited with status %d",
+                       kid->name().termedBuf(),
+                       kid->getPid(), kid->exitStatus());
+            } else if (kid->signaled()) {
+                syslog(LOG_NOTICE,
+                       "Squid Parent: %s process %d exited due to signal %d with status %d",
+                       kid->name().termedBuf(),
+                       kid->getPid(), kid->termSignal(), kid->exitStatus());
             } else {
-                syslog(LOG_NOTICE, "Squid Parent: unknown child process %d exited", pid);
+                syslog(LOG_NOTICE, "Squid Parent: %s process %d exited",
+                       kid->name().termedBuf(), kid->getPid());
             }
-#if _SQUID_NEXT_
-        } while ((pid = wait3(&status, WNOHANG, NULL)) > 0);
-#else
+            if (kid->hopeless()) {
+                syslog(LOG_NOTICE, "Squid Parent: %s process %d will not"
+                       " be restarted due to repeated, frequent failures",
+                       kid->name().termedBuf(), kid->getPid());
+            }
+        } else if (pid > 0) {
+            syslog(LOG_NOTICE, "Squid Parent: unknown child process %d exited", pid);
         }
-        while ((pid = waitpid(-1, &status, WNOHANG)) > 0);
-#endif
 
         if (!TheKids.someRunning() && !TheKids.shouldRestartSome()) {
             leave_suid();
@@ -1800,6 +1881,7 @@ watch_child(char *argv[])
             RunRegisteredHere(RegisteredRunner::finishShutdown);
             enter_suid();
 
+            removePidFile();
             if (TheKids.someSignaled(SIGINT) || TheKids.someSignaled(SIGTERM)) {
                 syslog(LOG_ALERT, "Exiting due to unexpected forced shutdown");
                 exit(1);
@@ -1813,8 +1895,7 @@ watch_child(char *argv[])
             exit(0);
         }
 
-        squid_signal(SIGINT, SIG_DFL, SA_RESTART);
-        sleep(3);
+        masterCheckAndBroadcastSignals();
     }
 
     /* NOTREACHED */
@@ -1836,7 +1917,7 @@ SquidShutdown()
 #endif
 
     debugs(1, DBG_IMPORTANT, "Shutting down...");
-    dnsShutdown();
+    Dns::Shutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
@@ -1920,12 +2001,8 @@ SquidShutdown()
 
     memClean();
 
-    if (IamPrimaryProcess()) {
-        if (Config.pidFilename && strcmp(Config.pidFilename, "none") != 0) {
-            enter_suid();
-            safeunlink(Config.pidFilename, 0);
-            leave_suid();
-        }
+    if (!InDaemonMode()) {
+        removePidFile();
     }
 
     debugs(1, DBG_IMPORTANT, "Squid Cache (Version " << version_string << "): Exiting normally.");
@@ -31,7 +31,7 @@ mcastSetTtl(int fd, int mcast_ttl)
 }
 
 void
-mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *)
+mcastJoinGroups(const ipcache_addrs *ia, const Dns::LookupDetails &, void *)
 {
 #ifdef IP_MULTICAST_TTL
     struct ip_mreq mr;
@@ -13,7 +13,6 @@
 #include "anyp/PortCfg.h"
 #include "CacheDigest.h"
 #include "CachePeer.h"
-#include "CachePeerDomainList.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
@@ -137,7 +136,6 @@ bool
 peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 {
 
-    const CachePeerDomainList *d = NULL;
     assert(request != NULL);
 
     if (neighborType(p, request) == PEER_SIBLING) {
@@ -164,24 +162,8 @@ peerAllowedToUse(const CachePeer * p, HttpRequest * request)
     if (p->options.originserver && request->method == Http::METHOD_CONNECT && request->port != p->in_addr.port())
         return false;
 
-    if (p->peer_domain == NULL && p->access == NULL)
-        return true;
-
-    bool do_ping = false;
-    for (d = p->peer_domain; d; d = d->next) {
-        if (0 == matchDomainName(request->GetHost(), d->domain)) {
-            do_ping = d->do_ping;
-            break;
-        }
-
-        do_ping = !d->do_ping;
-    }
-
-    if (p->peer_domain && !do_ping)
-        return false;
-
     if (p->access == NULL)
-        return do_ping;
+        return true;
 
     ACLFilledChecklist checklist(p->access, request, NULL);
 
@@ -522,7 +504,8 @@ neighborRemove(CachePeer * target)
 
     if (p) {
         *P = p->next;
-        cbdataFree(p);
+        p->next = NULL;
+        delete p;
         --Config.npeers;
     }
 
@@ -945,7 +928,7 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
     }
 
     if (np == NULL) {
-        np = (CachePeer *)xcalloc(1, sizeof(CachePeer));
+        np = new CachePeer;
         np->in_addr = from;
         np->icp.port = from.port();
         np->type = PEER_NONE;
@@ -1169,31 +1152,6 @@ neighborUp(const CachePeer * p)
     return 1;
 }
 
-void
-peerDestroy(void *data)
-{
-    CachePeer *p = (CachePeer *)data;
-
-    if (p == NULL)
-        return;
-
-    CachePeerDomainList *nl = NULL;
-
-    for (CachePeerDomainList *l = p->peer_domain; l; l = nl) {
-        nl = l->next;
-        safe_free(l->domain);
-        xfree(l);
-    }
-
-    safe_free(p->host);
-    safe_free(p->name);
-    safe_free(p->domain);
-#if USE_CACHE_DIGESTS
-
-    cbdataReferenceDone(p->digest);
-#endif
-}
-
 void
 peerNoteDigestGone(CachePeer * p)
 {
@@ -1203,7 +1161,7 @@ peerNoteDigestGone(CachePeer * p)
 }
 
 static void
-peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
+peerDNSConfigure(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
     // TODO: connections to no-longer valid IP addresses should be
     // closed when we can detect such IP addresses.
@@ -1447,8 +1405,7 @@ peerCountMcastPeersDone(void *data)
     fake->abort(); // sets ENTRY_ABORTED and initiates releated cleanup
     HTTPMSGUNLOCK(fake->mem_obj->request);
     fake->unlock("peerCountMcastPeersDone");
-    HTTPMSGUNLOCK(psstate->request);
-    cbdataFree(psstate);
+    delete psstate;
 }
 
 static void
@@ -1605,16 +1562,14 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
 static void
 dump_peers(StoreEntry * sentry, CachePeer * peers)
 {
-    CachePeer *e = NULL;
     char ntoabuf[MAX_IPSTRLEN];
-    CachePeerDomainList *d = NULL;
     icp_opcode op;
     int i;
 
     if (peers == NULL)
         storeAppendPrintf(sentry, "There are no neighbors installed.\n");
 
-    for (e = peers; e; e = e->next) {
+    for (CachePeer *e = peers; e; e = e->next) {
         assert(e->host != NULL);
         storeAppendPrintf(sentry, "\n%-11.11s: %s\n",
                           neighborTypeStr(e),
@@ -1693,17 +1648,6 @@ dump_peers(StoreEntry * sentry, CachePeer * peers)
                               Time::FormatHttpd(e->stats.last_connect_failure));
         }
 
-        if (e->peer_domain != NULL) {
-            storeAppendPrintf(sentry, "DOMAIN LIST: ");
-
-            for (d = e->peer_domain; d; d = d->next) {
-                storeAppendPrintf(sentry, "%s%s ",
-                                  d->do_ping ? null_string : "!", d->domain);
-            }
-
-            storeAppendPrintf(sentry, "\n");
-        }
-
         storeAppendPrintf(sentry, "keep-alive ratio: %d%%\n", Math::intPercent(e->stats.n_keepalives_recv, e->stats.n_keepalives_sent));
     }
 }
@@ -51,7 +51,6 @@ CachePeer *neighborsDigestSelect(HttpRequest * request);
 void peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup);
 void peerNoteDigestGone(CachePeer * p);
 int neighborUp(const CachePeer * e);
-CBDUNL peerDestroy;
 const char *neighborTypeStr(const CachePeer * e);
 peer_t neighborType(const CachePeer *, const HttpRequest *);
 void peerConnectFailed(CachePeer *);
@@ -6,7 +6,10 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
+/* DEBUG: section 24    SBuf */
+
 #include "squid.h"
+#include "Debug.h"
 #include "parser/Tokenizer.h"
 
 #include <cerrno>
@@ -41,6 +44,7 @@ SBuf
 Parser::Tokenizer::consume(const SBuf::size_type n)
 {
     // careful: n may be npos!
+    debugs(24, 5, "consuming " << n << " bytes");
     const SBuf result = buf_.consume(n);
     parsed_ += result.length();
     return result;
@@ -60,56 +64,118 @@ Parser::Tokenizer::token(SBuf &returnedToken, const CharacterSet &delimiters)
     skipAll(delimiters);
     const SBuf::size_type tokenLen = buf_.findFirstOf(delimiters); // not found = npos => consume to end
     if (tokenLen == SBuf::npos) {
+        debugs(24, 8, "no token found for delimiters " << delimiters.name);
         *this = saved;
         return false;
     }
     returnedToken = consume(tokenLen); // cannot be empty
     skipAll(delimiters);
+    debugs(24, DBG_DATA, "token found for delimiters " << delimiters.name << ": '" <<
+           returnedToken << '\'');
     return true;
 }
 
 bool
 Parser::Tokenizer::prefix(SBuf &returnedToken, const CharacterSet &tokenChars, const SBuf::size_type limit)
 {
-    const SBuf::size_type prefixLen = buf_.substr(0,limit).findFirstNotOf(tokenChars);
-    if (prefixLen == 0)
+    SBuf::size_type prefixLen = buf_.substr(0,limit).findFirstNotOf(tokenChars);
+    if (prefixLen == 0) {
+        debugs(24, 8, "no prefix for set " << tokenChars.name);
         return false;
-    if (prefixLen == SBuf::npos && (atEnd() || limit == 0))
+    }
+    if (prefixLen == SBuf::npos && (atEnd() || limit == 0)) {
+        debugs(24, 8, "no char in set " << tokenChars.name << " while looking for prefix");
         return false;
+    }
+    if (prefixLen == SBuf::npos && limit > 0) {
+        debugs(24, 8, "whole haystack matched");
+        prefixLen = limit;
+    }
+    debugs(24, 8, "found with length " << prefixLen);
     returnedToken = consume(prefixLen); // cannot be empty after the npos check
     return true;
 }
 
+bool
+Parser::Tokenizer::suffix(SBuf &returnedToken, const CharacterSet &tokenChars, const SBuf::size_type limit)
+{
+    SBuf span = buf_;
+
+    if (limit < buf_.length())
+        span.consume(buf_.length() - limit); // ignore the N prefix characters
+
+    auto i = span.rbegin();
+    SBuf::size_type found = 0;
+    while (i != span.rend() && tokenChars[*i]) {
+        ++i;
+        ++found;
+    }
+    if (!found)
+        return false;
+    returnedToken = buf_;
+    buf_ = returnedToken.consume(buf_.length() - found);
+    return true;
+}
+
 SBuf::size_type
 Parser::Tokenizer::skipAll(const CharacterSet &tokenChars)
 {
     const SBuf::size_type prefixLen = buf_.findFirstNotOf(tokenChars);
-    if (prefixLen == 0)
+    if (prefixLen == 0) {
+        debugs(24, 8, "no match when trying to skipAll " << tokenChars.name);
         return 0;
+    }
+    debugs(24, 8, "skipping all in " << tokenChars.name << " len " << prefixLen);
     return success(prefixLen);
 }
 
 bool
 Parser::Tokenizer::skipOne(const CharacterSet &chars)
 {
-    if (!buf_.isEmpty() && chars[buf_[0]])
+    if (!buf_.isEmpty() && chars[buf_[0]]) {
+        debugs(24, 8, "skipping one-of " << chars.name);
         return success(1);
+    }
+    debugs(24, 8, "no match while skipping one-of " << chars.name);
+    return false;
+}
+
+bool
+Parser::Tokenizer::skipSuffix(const SBuf &tokenToSkip)
+{
+    if (buf_.length() < tokenToSkip.length())
+        return false;
+
+    SBuf::size_type offset = 0;
+    if (tokenToSkip.length() < buf_.length())
+        offset = buf_.length() - tokenToSkip.length();
+
+    if (buf_.substr(offset, SBuf::npos).cmp(tokenToSkip) == 0) {
+        buf_ = buf_.substr(0,offset);
+        return true;
+    }
     return false;
 }
 
 bool
 Parser::Tokenizer::skip(const SBuf &tokenToSkip)
 {
-    if (buf_.startsWith(tokenToSkip))
+    if (buf_.startsWith(tokenToSkip)) {
+        debugs(24, 8, "skipping " << tokenToSkip.length());
         return success(tokenToSkip.length());
+    }
+    debugs(24, 8, "no match, not skipping '" << tokenToSkip << '\'');
     return false;
 }
 
 bool
 Parser::Tokenizer::skip(const char tokenChar)
 {
-    if (!buf_.isEmpty() && buf_[0] == tokenChar)
+    if (!buf_.isEmpty() && buf_[0] == tokenChar) {
+        debugs(24, 8, "skipping char '" << tokenChar << '\'');
         return success(1);
+    }
+    debugs(24, 8, "no match, not skipping char '" << tokenChar << '\'');
     return false;
 }
 
@@ -70,6 +70,27 @@ class Tokenizer
      */
     bool prefix(SBuf &returnedToken, const CharacterSet &tokenChars, SBuf::size_type limit = SBuf::npos);
 
+    /** Extracts all sequential permitted characters up to an optional length limit.
+     * Operates on the trailing end of the buffer.
+     *
+     *  Note that Tokenizer cannot tell whether the buffer will
+     *  gain more data when/if more input becomes available later.
+     *
+     * \retval true one or more characters were found, the sequence (string) is placed in returnedToken
+     * \retval false no characters from the permitted set were found
+     */
+    bool suffix(SBuf &returnedToken, const CharacterSet &tokenChars, SBuf::size_type limit = SBuf::npos);
+
+    /** skips a given suffix character sequence (string)
+     * Operates on the trailing end of the buffer.
+     *
+     *  Note that Tokenizer cannot tell whether the buffer will
+     *  gain more data when/if more input becomes available later.
+     *
+     * \return whether the exact character sequence was found and skipped
+     */
+    bool skipSuffix(const SBuf &tokenToSkip);
+
     /** skips a given character sequence (string)
      *
      * \return whether the exact character sequence was found and skipped
@@ -99,6 +99,47 @@ peerDigestClean(PeerDigest * pd)
 
 CBDATA_CLASS_INIT(PeerDigest);
 
+CBDATA_CLASS_INIT(DigestFetchState);
+
+DigestFetchState::DigestFetchState(PeerDigest *aPd, HttpRequest *req) :
+    pd(cbdataReference(aPd)),
+    entry(NULL),
+    old_entry(NULL),
+    sc(NULL),
+    old_sc(NULL),
+    request(req),
+    offset(0),
+    mask_offset(0),
+    start_time(squid_curtime),
+    resp_time(0),
+    expires(0),
+    bufofs(0),
+    state(DIGEST_READ_REPLY)
+{
+    HTTPMSGLOCK(request);
+
+    sent.msg = 0;
+    sent.bytes = 0;
+
+    recv.msg = 0;
+    recv.bytes = 0;
+
+    *buf = 0;
+}
+
+DigestFetchState::~DigestFetchState()
+{
+    /* unlock everything */
+    storeUnregister(sc, entry, this);
+
+    entry->unlock("DigestFetchState destructed");
+    entry = NULL;
+
+    HTTPMSGUNLOCK(request);
+
+    assert(pd == NULL);
+}
+
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
 peerDigestCreate(CachePeer * p)
@@ -270,8 +311,6 @@ peerDigestCheck(void *data)
         peerDigestSetCheck(pd, req_time - squid_curtime);
 }
 
-CBDATA_TYPE(DigestFetchState);
-
 /* ask store for a digest */
 static void
 peerDigestRequest(PeerDigest * pd)
@@ -281,7 +320,6 @@ peerDigestRequest(PeerDigest * pd)
     char *url = NULL;
     const cache_key *key;
     HttpRequest *req;
-    DigestFetchState *fetch = NULL;
     StoreIOBuffer tempBuffer;
 
     pd->req_result = NULL;
@@ -318,26 +356,11 @@ peerDigestRequest(PeerDigest * pd)
         req->url.userInfo(SBuf(p->login)); // XXX: performance regression make peer login SBuf as well.
     }
     /* create fetch state structure */
-    CBDATA_INIT_TYPE(DigestFetchState);
-
-    fetch = cbdataAlloc(DigestFetchState);
-
-    fetch->request = req;
-    HTTPMSGLOCK(fetch->request);
-
-    fetch->pd = cbdataReference(pd);
-
-    fetch->offset = 0;
-
-    fetch->state = DIGEST_READ_REPLY;
+    DigestFetchState *fetch = new DigestFetchState(pd, req);
 
     /* update timestamps */
-    fetch->start_time = squid_curtime;
-
     pd->times.requested = squid_curtime;
-
     pd_last_req_time = squid_curtime;
-
     req->flags.cachable = true;
 
     /* the rest is based on clientProcessExpired() */
@@ -418,7 +441,7 @@ peerDigestHandleReply(void *data, StoreIOBuffer receivedData)
      * try to destroy the fetch structure, and we like to know if they
      * do
      */
-    fetch = cbdataReference(fetch);
+    CbcPointer<DigestFetchState> tmpLock = fetch;
 
     /* Repeat this loop until we're out of data OR the state changes */
     /* (So keep going if the state has changed and we still have data */
@@ -447,15 +470,15 @@ peerDigestHandleReply(void *data, StoreIOBuffer receivedData)
             break;
 
         case DIGEST_READ_DONE:
-            goto finish;
+            return;
             break;
 
         default:
             fatal("Bad digest transfer mode!\n");
         }
 
         if (retsize < 0)
-            goto finish;
+            return;
 
         /*
          * The returned size indicates how much of the buffer was read -
@@ -482,10 +505,6 @@ peerDigestHandleReply(void *data, StoreIOBuffer receivedData)
         storeClientCopy(fetch->sc, fetch->entry, tempBuffer,
                         peerDigestHandleReply, fetch);
     }
-
-finish:
-    /* Get rid of our reference, we've finished with it for now */
-    cbdataReferenceDone(fetch);
 }
 
 /* wait for full http headers to be received then parse them */
@@ -902,18 +921,7 @@ peerDigestFetchFinish(DigestFetchState * fetch, int err)
 
     statCounter.cd.msgs_recv += fetch->recv.msg;
 
-    /* unlock everything */
-    storeUnregister(fetch->sc, fetch->entry, fetch);
-
-    fetch->entry->unlock("peerDigestFetchFinish new");
-
-    HTTPMSGUNLOCK(fetch->request);
-
-    fetch->entry = NULL;
-
-    assert(fetch->pd == NULL);
-
-    cbdataFree(fetch);
+    delete fetch;
 }
 
 /* calculate fetch stats after completion */
@@ -13,7 +13,7 @@
 #include "CachePeer.h"
 #include "carp.h"
 #include "client_side.h"
-#include "DnsLookupDetails.h"
+#include "dns/LookupDetails.h"
 #include "errorpage.h"
 #include "event.h"
 #include "FwdState.h"
@@ -61,7 +61,7 @@ static void peerGetSomeParent(ps_state *);
 static void peerGetAllParents(ps_state *);
 static void peerAddFwdServer(FwdServer **, CachePeer *, hier_code);
 static void peerSelectPinned(ps_state * ps);
-static void peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data);
+static void peerSelectDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &details, void *data);
 
 CBDATA_CLASS_INIT(ps_state);
 
@@ -106,7 +106,7 @@ peerSelectIcpPing(HttpRequest * request, int direct, StoreEntry * entry)
     assert(entry);
     assert(entry->ping_status == PING_NONE);
     assert(direct != DIRECT_YES);
-    debugs(44, 3, "peerSelectIcpPing: " << entry->url()  );
+    debugs(44, 3, "peerSelectIcpPing: " << entry->url());
 
     if (!request->flags.hierarchical && direct != DIRECT_NO)
         return 0;
@@ -254,7 +254,7 @@ peerSelectDnsPaths(ps_state *psstate)
     if (fs && psstate->paths->size() < (unsigned int)Config.forward_max_tries) {
         // send the next one off for DNS lookup.
         const char *host = fs->_peer ? fs->_peer->host : psstate->request->GetHost();
-        debugs(44, 2, "Find IP destination for: " << psstate->entry->url() << "' via " << host);
+        debugs(44, 2, "Find IP destination for: " << psstate->url() << "' via " << host);
         ipcache_nbgethostbyname(host, peerSelectDnsResults, psstate);
         return;
     }
@@ -306,7 +306,7 @@ peerSelectDnsPaths(ps_state *psstate)
 }
 
 static void
-peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data)
+peerSelectDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &details, void *data)
 {
     ps_state *psstate = (ps_state *)data;
 
@@ -752,7 +752,7 @@ peerPingTimeout(void *data)
     StoreEntry *entry = psstate->entry;
 
     if (entry)
-        debugs(44, 3, "peerPingTimeout: '" << entry->url() << "'" );
+        debugs(44, 3, "peerPingTimeout: '" << psstate->url() << "'" );
 
     if (!cbdataReferenceValid(psstate->callback_data)) {
         /* request aborted */
@@ -820,7 +820,7 @@ peerHandleIcpReply(CachePeer * p, peer_t type, icp_common_t * header, void *data
 {
     ps_state *psstate = (ps_state *)data;
     icp_opcode op = header->getOpCode();
-    debugs(44, 3, "peerHandleIcpReply: " << icp_opcode_str[op] << " " << psstate->entry->url()  );
+    debugs(44, 3, "peerHandleIcpReply: " << icp_opcode_str[op] << " " << psstate->url()  );
 #if USE_CACHE_DIGESTS && 0
     /* do cd lookup to count false misses */
 
@@ -853,9 +853,7 @@ static void
 peerHandleHtcpReply(CachePeer * p, peer_t type, HtcpReplyData * htcp, void *data)
 {
     ps_state *psstate = (ps_state *)data;
-    debugs(44, 3, "peerHandleHtcpReply: " <<
-           (htcp->hit ? "HIT" : "MISS") << " " <<
-           psstate->entry->url()  );
+    debugs(44, 3, "" << (htcp->hit ? "HIT" : "MISS") << " " << psstate->url());
     ++ psstate->ping.n_recv;
 
     if (htcp->hit) {
@@ -107,8 +107,11 @@ refreshLimits(const char *url)
     const RefreshPattern *R;
 
     for (R = Config.Refresh; R; R = R->next) {
-        if (!regexec(&(R->compiled_pattern), url, 0, 0, 0))
+        ++(R->stats.matchTests);
+        if (!regexec(&(R->compiled_pattern), url, 0, 0, 0)) {
+            ++(R->stats.matchCount);
             return R;
+        }
     }
 
     return NULL;
@@ -694,14 +697,24 @@ refreshCountsStats(StoreEntry * sentry, struct RefreshCounts &rc)
     sum += refreshCountsStatsEntry(sentry, rc, STALE_MAX_RULE, "Stale: refresh_pattern max age rule");
     sum += refreshCountsStatsEntry(sentry, rc, STALE_LMFACTOR_RULE, "Stale: refresh_pattern last-mod factor percentage");
     sum += refreshCountsStatsEntry(sentry, rc, STALE_DEFAULT, "Stale: by default");
-
-    storeAppendPrintf(sentry, "%6d\t%6.2f\tTOTAL\n", rc.total, xpercent(rc.total, sum));
     storeAppendPrintf(sentry, "\n");
 }
 
 static void
 refreshStats(StoreEntry * sentry)
 {
+    // display per-rule counts of usage and tests
+    storeAppendPrintf(sentry, "\nRefresh pattern usage:\n\n");
+    storeAppendPrintf(sentry, "  Used      \tChecks    \t%% Matches\tPattern\n");
+    for (const RefreshPattern *R = Config.Refresh; R; R = R->next) {
+        storeAppendPrintf(sentry, "  %10" PRIu64 "\t%10" PRIu64 "\t%6.2f\t%s%s\n",
+                          R->stats.matchCount,
+                          R->stats.matchTests,
+                          xpercent(R->stats.matchCount, R->stats.matchTests),
+                          (R->flags.icase ? "-i " : ""),
+                          R->pattern);
+    }
+
     int i;
     int total = 0;
 
@@ -35,6 +35,12 @@ Security::PeerOptions::parse(const char *token)
         sslVersion = xatoi(token + 8);
     } else if (strncmp(token, "options=", 8) == 0) {
         sslOptions = SBuf(token + 8);
+#if USE_OPENSSL
+        // Pre-parse SSL client options to be applied when the client SSL objects created.
+        // Options must not used in the case of peek or stare bump mode.
+        // XXX: performance regression. c_str() can reallocate
+        parsedOptions = Ssl::parse_options(sslOptions.c_str());
+#endif
     } else if (strncmp(token, "cipher=", 7) == 0) {
         sslCipher = SBuf(token + 7);
     } else if (strncmp(token, "cafile=", 7) == 0) {
@@ -52,15 +58,16 @@ Security::PeerOptions::parse(const char *token)
 
 // XXX: make a GnuTLS variant
 Security::ContextPointer
-Security::PeerOptions::createContext()
+Security::PeerOptions::createContext(bool setOptions)
 {
     Security::ContextPointer t = NULL;
 
 #if USE_OPENSSL
     // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
     t = sslCreateClientContext(certFile.c_str(), privateKeyFile.c_str(), sslVersion, sslCipher.c_str(),
-                           sslOptions.c_str(), sslFlags.c_str(), caFile.c_str(), caDir.c_str(), crlFile.c_str());
+                           (setOptions ? sslOptions.c_str() : NULL), sslFlags.c_str(), caFile.c_str(), caDir.c_str(), crlFile.c_str());
 #endif
+
     return t;
 }
 
@@ -29,7 +29,7 @@ class PeerOptions
     void clear() {*this = PeerOptions();}
 
     /// generate a security context from these configured options
-    Security::ContextPointer createContext();
+    Security::ContextPointer createContext(bool setOptions);
 
     SBuf certFile;       ///< path of file containing PEM format X509 certificate
     SBuf privateKeyFile; ///< path of file containing private key in PEM format
@@ -42,6 +42,8 @@ class PeerOptions
     SBuf sslFlags;
     SBuf sslDomain;
 
+    long parsedOptions; ///< parsed value of sslOptions
+
     int sslVersion;
 
     /// whether transport encryption (TLS/SSL) is to be used on connections to the peer
@@ -39,7 +39,7 @@ start_announce(void *)
 }
 
 static void
-send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *)
+send_announce(const ipcache_addrs *ia, const Dns::LookupDetails &, void *)
 {
     LOCAL_ARRAY(char, tbuf, 256);
     LOCAL_ARRAY(char, sndbuf, BUFSIZ);
@@ -52,7 +52,7 @@ Http::One::Server::start()
     typedef CommCbMemFunT<Server, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
                                       TimeoutDialer, this, Http1::Server::requestTimeout);
-    commSetConnTimeout(clientConnection, Config.Timeout.request, timeoutCall);
+    commSetConnTimeout(clientConnection, Config.Timeout.request_start_timeout, timeoutCall);
     readSomeData();
 }
 
@@ -88,21 +88,15 @@ Http::One::Server::parseOneRequest()
 }
 
 void clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request);
+bool clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
 
 bool
 Http::One::Server::buildHttpRequest(ClientSocketContext *context)
 {
     HttpRequest::Pointer request;
     ClientHttpRequest *http = context->http;
     if (context->flags.parsed_ok == 0) {
-        clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 2, "Invalid Request");
-        quitAfterError(NULL);
-        // setLogUri should called before repContext->setReplyToError
-        setLogUri(http, http->uri, true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert(repContext);
-
         // determine which error page templates to use for specific parsing errors
         err_type errPage = ERR_INVALID_REQ;
         switch (parser_->request_parse_status) {
@@ -118,27 +112,33 @@ Http::One::Server::buildHttpRequest(ClientSocketContext *context)
             errPage = ERR_UNSUP_HTTPVERSION;
             break;
         default:
-            // use default ERR_INVALID_REQ set above.
+            if (parser_->method() == METHOD_NONE || parser_->requestUri().length() == 0)
+                // no method or url parsed, probably is wrong protocol
+                errPage = ERR_PROTOCOL_UNKNOWN;
+            // else use default ERR_INVALID_REQ set above.
             break;
         }
-        repContext->setReplyToError(errPage, parser_->request_parse_status, parser_->method(), http->uri,
-                                    clientConnection->remote, NULL, in.buf.c_str(), NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
+        // setLogUri should called before repContext->setReplyToError
+        setLogUri(http, http->uri, true);
+        const char * requestErrorBytes = in.buf.c_str();
+        if (!clientTunnelOnError(this, context, request.getRaw(), parser_->method(), errPage, parser_->request_parse_status, requestErrorBytes)) {
+            // HttpRequest object not build yet, there is no reason to call
+            // clientProcessRequestFinished method
+        }
+
         return false;
     }
 
     if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, parser_->method())) == NULL) {
-        clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Invalid URL: " << http->uri);
-        quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri, true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert(repContext);
-        repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, parser_->method(), http->uri, clientConnection->remote, NULL, NULL, NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
+
+        const char * requestErrorBytes = in.buf.c_str();
+        if (!clientTunnelOnError(this, context, request.getRaw(), parser_->method(), ERR_INVALID_URL, Http::scBadRequest, requestErrorBytes)) {
+            // HttpRequest object not build yet, there is no reason to call
+            // clientProcessRequestFinished method
+        }
         return false;
     }
 
@@ -148,34 +148,26 @@ Http::One::Server::buildHttpRequest(ClientSocketContext *context)
     if ( (parser_->messageProtocol().major == 0 && parser_->messageProtocol().minor != 9) ||
             (parser_->messageProtocol().major > 1) ) {
 
-        clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Unsupported HTTP version discovered. :\n" << parser_->messageProtocol());
-        quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, parser_->method(), http->uri,
-                                    clientConnection->remote, NULL, NULL, NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
-        clientProcessRequestFinished(this, request);
+
+        const char * requestErrorBytes = NULL; //HttpParserHdrBuf(parser_);
+        if (!clientTunnelOnError(this, context, request.getRaw(), parser_->method(), ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, requestErrorBytes)) {
+            clientProcessRequestFinished(this, request);
+        }
         return false;
     }
 
     /* compile headers */
     if (parser_->messageProtocol().major >= 1 && !request->parseHeader(*parser_.getRaw())) {
-        clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Failed to parse request headers:\n" << parser_->mimeHeader());
-        quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri, true);
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert(repContext);
-        repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, parser_->method(), http->uri, clientConnection->remote, NULL, NULL, NULL);
-        assert(context->http->out.offset == 0);
-        context->pullData();
-        clientProcessRequestFinished(this, request);
+        const char * requestErrorBytes = NULL; //HttpParserHdrBuf(parser_);
+        if (!clientTunnelOnError(this, context, request.getRaw(), parser_->method(), ERR_INVALID_REQ, Http::scBadRequest, requestErrorBytes)) {
+            clientProcessRequestFinished(this, request);
+        }
         return false;
     }
 
@@ -198,22 +190,42 @@ Http::One::Server::processParsedRequest(ClientSocketContext *context)
     if (!buildHttpRequest(context))
         return;
 
-    if (Config.accessList.forceRequestBodyContinuation) {
-        ClientHttpRequest *http = context->http;
-        HttpRequest *request = http->request;
-        ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request, NULL);
-        if (bodyContinuationCheck.fastCheck() == ACCESS_ALLOWED) {
-            debugs(33, 5, "Body Continuation forced");
-            request->forcedBodyContinuation = true;
-            //sendControlMsg
-            HttpReply::Pointer rep = new HttpReply;
-            rep->sline.set(Http::ProtocolVersion(), Http::scContinue);
-
-            typedef UnaryMemFunT<Http1::Server, ClientSocketContext::Pointer> CbDialer;
-            const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, ClientSocketContext::Pointer(context)));
-            sendControlMsg(HttpControlMsg(rep, cb));
+    ClientHttpRequest *http = context->http;
+    HttpRequest::Pointer request = http->request;
+
+    if (request->header.has(HDR_EXPECT)) {
+        const String expect = request->header.getList(HDR_EXPECT);
+        const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
+        if (!supportedExpect) {
+            clientStreamNode *node = context->getClientReplyContext();
+            quitAfterError(request.getRaw());
+            // setLogUri should called before repContext->setReplyToError
+            setLogUri(http, urlCanonicalClean(request.getRaw()));
+            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+            assert (repContext);
+            repContext->setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request->method, http->uri,
+                                        clientConnection->remote, request.getRaw(), NULL, NULL);
+            assert(context->http->out.offset == 0);
+            context->pullData();
+            clientProcessRequestFinished(this, request);
             return;
         }
+
+        if (Config.accessList.forceRequestBodyContinuation) {
+            ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request.getRaw(), NULL);
+            if (bodyContinuationCheck.fastCheck() == ACCESS_ALLOWED) {
+                debugs(33, 5, "Body Continuation forced");
+                request->forcedBodyContinuation = true;
+                //sendControlMsg
+                HttpReply::Pointer rep = new HttpReply;
+                rep->sline.set(Http::ProtocolVersion(), Http::scContinue);
+
+                typedef UnaryMemFunT<Http1::Server, ClientSocketContext::Pointer> CbDialer;
+                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, ClientSocketContext::Pointer(context)));
+                sendControlMsg(HttpControlMsg(rep, cb));
+                return;
+            }
+        }
     }
     clientProcessRequest(this, parser_, context);
 }
@@ -139,48 +139,61 @@ Ssl::PeerConnector::initializeSsl()
 
         if (peer->sslSession)
             SSL_set_session(ssl, peer->sslSession);
-
-    } else if (request->clientConnectionManager->sslBumpMode == Ssl::bumpPeek || request->clientConnectionManager->sslBumpMode == Ssl::bumpStare) {
-        // client connection is required for Peek or Stare mode in the case we need to splice
+    } else if (ConnStateData *csd = request->clientConnectionManager.valid()) {
+        // client connection is required in the case we need to splice
         // or terminate client and server connections
         assert(clientConn != NULL);
-        SSL *clientSsl = fd_table[request->clientConnectionManager->clientConnection->fd].ssl;
-        BIO *b = SSL_get_rbio(clientSsl);
-        Ssl::ClientBio *clnBio = static_cast<Ssl::ClientBio *>(b->ptr);
-        const Ssl::Bio::sslFeatures &features = clnBio->getFeatures();
-        if (features.sslVersion != -1) {
-            features.applyToSSL(ssl);
-            // Should we allow it for all protocols?
-            if (features.sslVersion >= 3) {
-                b = SSL_get_rbio(ssl);
-                Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
-                srvBio->setClientFeatures(features);
-                srvBio->recordInput(true);
-                srvBio->mode(request->clientConnectionManager->sslBumpMode);
-            }
+        const char *hostName = NULL;
+        Ssl::ClientBio *cltBio = NULL;
+
+        // In server-first bumping mode, clientSsl is NULL.
+        if (SSL *clientSsl = fd_table[clientConn->fd].ssl) {
+            BIO *b = SSL_get_rbio(clientSsl);
+            cltBio = static_cast<Ssl::ClientBio *>(b->ptr);
+            const Ssl::Bio::sslFeatures &features = cltBio->getFeatures();
+            if (!features.serverName.isEmpty())
+                hostName = features.serverName.c_str();
+        }
 
-            const bool isConnectRequest = request->clientConnectionManager.valid() &&
-                                          !request->clientConnectionManager->port->flags.isIntercepted();
-            if (isConnectRequest)
-                SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)request->GetHost());
-            else if (!features.serverName.isEmpty())
-                SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)features.serverName.c_str());
+        if (!hostName) {
+            // While we are peeking at the certificate, we may not know the server
+            // name that the client will request (after interception or CONNECT)
+            // unless it was the CONNECT request with a user-typed address.
+            const bool isConnectRequest = !csd->port->flags.isIntercepted();
+            if (!request->flags.sslPeek || isConnectRequest)
+                hostName = request->GetHost();
+        }
+
+        if (hostName)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostName);
+
+        Must(!csd->serverBump() || csd->serverBump()->step <= Ssl::bumpStep2);
+        if (csd->sslBumpMode == Ssl::bumpPeek || csd->sslBumpMode == Ssl::bumpStare) {
+            assert(cltBio);
+            const Ssl::Bio::sslFeatures &features = cltBio->getFeatures();
+            if (features.sslVersion != -1) {
+                features.applyToSSL(ssl);
+                // Should we allow it for all protocols?
+                if (features.sslVersion >= 3) {
+                    BIO *b = SSL_get_rbio(ssl);
+                    Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
+                    // Inherite client features, like SSL version, SNI and other
+                    srvBio->setClientFeatures(features);
+                    srvBio->recordInput(true);
+                    srvBio->mode(csd->sslBumpMode);
+                }
+            }
+        } else {
+            // Set client SSL options
+            SSL_set_options(ssl, ::Security::ProxyOutgoingConfig.parsedOptions);
+
+            // Use SNI TLS extension only when we connect directly
+            // to the origin server and we know the server host name.
+            const char *sniServer = hostName ? hostName :
+                                    (!request->GetHostIsNumeric() ? request->GetHost() : NULL);
+            if (sniServer)
+                Ssl::setClientSNI(ssl, sniServer);
         }
-    } else {
-        // While we are peeking at the certificate, we may not know the server
-        // name that the client will request (after interception or CONNECT)
-        // unless it was the CONNECT request with a user-typed address.
-        const char *hostname = request->GetHost();
-        const bool hostnameIsIp = request->GetHostIsNumeric();
-        const bool isConnectRequest = request->clientConnectionManager.valid() &&
-                                      !request->clientConnectionManager->port->flags.isIntercepted();
-        if (!request->flags.sslPeek || isConnectRequest)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
-
-        // Use SNI TLS extension only when we connect directly
-        // to the origin server and we know the server host name.
-        if (!hostnameIsIp)
-            Ssl::setClientSNI(ssl, hostname);
     }
 
     // If CertValidation Helper used do not lookup checklist for errors,
@@ -231,6 +231,7 @@ Ssl::ClientBio::read(char *buf, int size, BIO *table)
 #endif
         } else {
             debugs(83, 7, "Not an SSL acceptable handshake message (SSLv2 message?)");
+            wrongProtocol = true;
             return -1;
         }
 
@@ -100,7 +100,7 @@ class ClientBio: public Bio
 public:
     /// The ssl hello message read states
     typedef enum {atHelloNone = 0, atHelloStarted, atHelloReceived} HelloReadState;
-    explicit ClientBio(const int anFd): Bio(anFd), holdRead_(false), holdWrite_(false), helloState(atHelloNone), helloSize(0) {}
+    explicit ClientBio(const int anFd): Bio(anFd), holdRead_(false), holdWrite_(false), helloState(atHelloNone), helloSize(0), wrongProtocol(false) {}
 
     /// The ClientBio version of the Ssl::Bio::stateChanged method
     /// When the client hello message retrieved, fill the
@@ -118,7 +118,8 @@ class ClientBio: public Bio
     const Bio::sslFeatures &getFeatures() const {return features;}
     /// Prevents or allow writting on socket.
     void hold(bool h) {holdRead_ = holdWrite_ = h;}
-
+    /// True if client does not looks like an SSL client
+    bool noSslClient() {return wrongProtocol;}
 private:
     /// True if the SSL state corresponds to a hello message
     bool isClientHello(int state);
@@ -128,6 +129,7 @@ class ClientBio: public Bio
     bool holdWrite_;  ///< The write hold state of the bio.
     HelloReadState helloState; ///< The SSL hello read state
     int helloSize; ///< The SSL hello message sent by client size
+    bool wrongProtocol; ///< true if client SSL hello parsing failed
 };
 
 /// BIO node to handle socket IO for squid server side
@@ -313,16 +313,19 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
             // pass them to certficate validator for more processing
             else if (Ssl::TheConfig.ssl_crt_validator) {
                 ok = 1;
-                // Check if we have stored certificates chain. Store if not.
-                if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
-                    STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
-                    if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
-                        sk_X509_pop_free(certStack, X509_free);
-                }
             }
         }
     }
 
+    if (Ssl::TheConfig.ssl_crt_validator) {
+        // Check if we have stored certificates chain. Store if not.
+        if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
+            STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
+            if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
+                sk_X509_pop_free(certStack, X509_free);
+        }
+    }
+
     if (!ok && !SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) ) {
 
         // Find the broken certificate. It may be intermediate.
@@ -457,6 +460,11 @@ ssl_options[] = {
     {
         "No_Compression", SSL_OP_NO_COMPRESSION
     },
+#endif
+#if SSL_OP_NO_TICKET
+    {
+        "NO_TICKET", SSL_OP_NO_TICKET
+    },
 #endif
     {
         "", 0
@@ -371,11 +371,11 @@ statObjects(void *data)
             storeAppendPrintf(state->sentry, "} by kid%d\n\n", KidIdentifier);
         state->sentry->complete();
         state->sentry->unlock("statObjects+isDone");
-        cbdataFree(state);
+        delete state;
         return;
     } else if (EBIT_TEST(state->sentry->flags, ENTRY_ABORTED)) {
         state->sentry->unlock("statObjects+aborted");
-        cbdataFree(state);
+        delete state;
         return;
     } else if (state->sentry->checkDeferRead(-1)) {
         state->sentry->flush();
@@ -308,13 +308,11 @@ storeClientCopy2(StoreEntry * e, store_client * sc)
      * this function
      * XXX: Locking does not prevent calling sc destructor (it only prevents
      * freeing sc memory) so sc may become invalid from C++ p.o.v.
-     *
      */
-    cbdataInternalLock(sc);
+    CbcPointer<store_client> tmpLock = sc;
     assert (!sc->flags.store_copying);
     sc->doCopy(e);
-    assert (!sc->flags.store_copying);
-    cbdataInternalUnlock(sc);
+    assert(!sc->flags.store_copying);
 }
 
 void
@@ -95,7 +95,7 @@ storeLogRotate(void)
     if (NULL == storelog)
         return;
 
-    logfileRotate(storelog);
+    logfileRotate(storelog, Config.Log.rotateNumber);
 }
 
 void
@@ -89,8 +89,9 @@ storeSwapOutStart(StoreEntry * e)
 static void
 storeSwapOutFileNotify(void *data, int errflag, StoreIOState::Pointer self)
 {
-    generic_cbdata *c = (generic_cbdata *)data;
-    StoreEntry *e = (StoreEntry *)c->data;
+    StoreEntry *e;
+    static_cast<generic_cbdata *>(data)->unwrap(&e);
+
     MemObject *mem = e->mem_obj;
     assert(e->swap_status == SWAPOUT_WRITING);
     assert(mem);
@@ -281,12 +282,12 @@ StoreEntry::swapOutFileClose(int how)
 static void
 storeSwapOutFileClosed(void *data, int errflag, StoreIOState::Pointer self)
 {
-    generic_cbdata *c = (generic_cbdata *)data;
-    StoreEntry *e = (StoreEntry *)c->data;
+    StoreEntry *e;
+    static_cast<generic_cbdata *>(data)->unwrap(&e);
+
     MemObject *mem = e->mem_obj;
     assert(mem->swapout.sio == self);
     assert(e->swap_status == SWAPOUT_WRITING);
-    cbdataFree(c);
 
     // if object_size is still unknown, the entry was probably aborted
     if (errflag || e->objectLen() < 0) {
@@ -26,6 +26,7 @@ SBufStats& SBufStats::operator +=(const SBufStats&) STUB_RETVAL(*this)
 SBuf::SBuf() {}
 SBuf::SBuf(const SBuf &S) {}
 SBuf::SBuf(const char *S, size_type n) {}
+SBuf::SBuf(const char *S) {}
 SBuf::SBuf(const String &S) {}
 SBuf::SBuf(const std::string &s) {}
 SBuf::~SBuf() {}
@@ -17,14 +17,14 @@
 #define STUB_API "cache_cf.cc"
 #include "tests/STUB.h"
 
+#include "cache_cf.h"
 void self_destruct(void) STUB
 void parse_int(int *var) STUB
 void parse_onoff(int *var) STUB
 void parse_eol(char *volatile *var) STUB
 void parse_wordlist(wordlist ** list) STUB
 void requirePathnameExists(const char *name, const char *path) STUB_NOP
 void parse_time_t(time_t * var) STUB
-char * strtokFile(void) STUB_RETVAL(NULL)
 void ConfigParser::ParseUShort(unsigned short *var) STUB
 void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head) STUB
 void dump_acl_list(StoreEntry*, ACLList*) STUB
@@ -91,15 +91,8 @@ Debug::OutStream *Debug::CurrentDebug(NULL);
 std::ostream &
 Debug::getDebugOut()
 {
-    assert(TheDepth >= 0);
-    ++TheDepth;
-    if (TheDepth > 1) {
-        assert(CurrentDebug);
-        *CurrentDebug << std::endl << "reentrant debuging " << TheDepth << "-{";
-    } else {
-        assert(!CurrentDebug);
+    if (!CurrentDebug) {
         CurrentDebug = new Debug::OutStream;
-        // set default formatting flags
         CurrentDebug->setf(std::ios::fixed);
         CurrentDebug->precision(2);
     }
@@ -113,26 +106,16 @@ Debug::parseOptions(char const *)
 void
 Debug::finishDebug()
 {
-    assert(TheDepth >= 0);
-    assert(CurrentDebug);
-    if (TheDepth > 1) {
-        *CurrentDebug << "}-" << TheDepth << std::endl;
-    } else {
-        assert(TheDepth == 1);
-        _db_print("%s\n", CurrentDebug->str().c_str());
-        delete CurrentDebug;
-        CurrentDebug = NULL;
-    }
-    --TheDepth;
+    std::cerr << "debugs: " << CurrentDebug->str() << std::endl;
+    delete CurrentDebug;
+    CurrentDebug = NULL;
 }
 
 void
 Debug::xassert(const char *msg, const char *file, int line)
 {
-    if (CurrentDebug) {
-        *CurrentDebug << "assertion failed: " << file << ":" << line <<
-                      ": \"" << msg << "\"";
-    }
+    getDebugOut() << "assertion failed: " << file << ":" << line <<
+                  ": \"" << msg << "\"";
     abort();
 }
 
@@ -14,5 +14,5 @@
 #include "security/PeerOptions.h"
 Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
-Security::ContextPointer Security::PeerOptions::createContext() STUB_RETVAL(NULL)
+Security::ContextPointer Security::PeerOptions::createContext(bool) STUB_RETVAL(NULL)
 void parse_securePeerOptions(Security::PeerOptions *) STUB
@@ -29,7 +29,6 @@ void BroadcastSignalIfAny(int& sig) STUB
 void sigusr2_handle(int sig) STUB
 void debug_trap(const char *message) STUB
 void sig_child(int sig) STUB
-void sig_shutdown(int sig) STUB
 const char * getMyHostname(void) STUB_RETVAL(NULL)
 const char * uniqueHostname(void) STUB_RETVAL(NULL)
 void leave_suid(void) STUB
@@ -63,6 +62,7 @@ int NumberOfKids() STUB_RETVAL(0)
 //not yet needed in the Stub, causes dependency on String
 //String ProcessRoles() STUB_RETVAL(String())
 void writePidFile(void) STUB
+void removePidFile(void) STUB
 pid_t readPidFile(void) STUB_RETVAL(0)
 void setMaxFD(void) STUB
 void setSystemLimits(void) STUB
@@ -76,4 +76,5 @@ void setUmask(mode_t mask) STUB
 void strwordquote(MemBuf * mb, const char *str) STUB
 void keepCapabilities(void) STUB
 void restoreCapabilities(bool keep) STUB
+pid_t WaitForOnePid(pid_t pid, PidStatus &status, int flags) STUB_RETVAL(0)
 
@@ -13,6 +13,7 @@
 #define private public
 #define protected public
 
+#include "Debug.h"
 #include "http/one/RequestParser.h"
 #include "http/RequestMethod.h"
 #include "MemBuf.h"
@@ -46,17 +47,9 @@ struct resultSet {
     bool needsMore;
     Http1::ParseState parserState;
     Http::StatusCode status;
-    int msgStart;
-    int msgEnd;
     SBuf::size_type suffixSz;
-    int methodStart;
-    int methodEnd;
     HttpRequestMethod method;
-    int uriStart;
-    int uriEnd;
     const char *uri;
-    int versionStart;
-    int versionEnd;
     AnyP::ProtocolVersion version;
 };
 
@@ -67,24 +60,21 @@ testResults(int line, const SBuf &input, Http1::RequestParser &output, struct re
     printf("TEST @%d, in=%u: " SQUIDSBUFPH "\n", line, input.length(), SQUIDSBUFPRINT(input));
 #endif
 
+    // runs the parse
     CPPUNIT_ASSERT_EQUAL(expect.parsed, output.parse(input));
-    CPPUNIT_ASSERT_EQUAL(expect.needsMore, output.needsMoreData());
-    if (output.needsMoreData())
-        CPPUNIT_ASSERT_EQUAL(expect.parserState, output.parsingStage_);
-    CPPUNIT_ASSERT_EQUAL(expect.status, output.request_parse_status);
-    CPPUNIT_ASSERT_EQUAL(expect.msgStart, output.req.start);
-    CPPUNIT_ASSERT_EQUAL(expect.msgEnd, output.req.end);
-    CPPUNIT_ASSERT_EQUAL(expect.suffixSz, output.buf_.length());
-    CPPUNIT_ASSERT_EQUAL(expect.methodStart, output.req.m_start);
-    CPPUNIT_ASSERT_EQUAL(expect.methodEnd, output.req.m_end);
+
+    // check easily visible field outputs
     CPPUNIT_ASSERT_EQUAL(expect.method, output.method_);
-    CPPUNIT_ASSERT_EQUAL(expect.uriStart, output.req.u_start);
-    CPPUNIT_ASSERT_EQUAL(expect.uriEnd, output.req.u_end);
     if (expect.uri != NULL)
         CPPUNIT_ASSERT_EQUAL(0, output.uri_.cmp(expect.uri));
-    CPPUNIT_ASSERT_EQUAL(expect.versionStart, output.req.v_start);
-    CPPUNIT_ASSERT_EQUAL(expect.versionEnd, output.req.v_end);
     CPPUNIT_ASSERT_EQUAL(expect.version, output.msgProtocol_);
+    CPPUNIT_ASSERT_EQUAL(expect.status, output.request_parse_status);
+
+    // check more obscure states
+    CPPUNIT_ASSERT_EQUAL(expect.needsMore, output.needsMoreData());
+    if (output.needsMoreData())
+        CPPUNIT_ASSERT_EQUAL(expect.parserState, output.parsingStage_);
+    CPPUNIT_ASSERT_EQUAL(expect.suffixSz, output.buf_.length());
 }
 #endif /* __cplusplus >= 200103L */
 
@@ -96,18 +86,10 @@ testHttp1Parser::testParserConstruct()
         Http1::RequestParser output;
         CPPUNIT_ASSERT_EQUAL(true, output.needsMoreData());
         CPPUNIT_ASSERT_EQUAL(Http1::HTTP_PARSE_NONE, output.parsingStage_);
-        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status); // XXX: clear() not being called.
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
+        CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
         CPPUNIT_ASSERT(output.buf_.isEmpty());
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
         CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), output.method_);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
         CPPUNIT_ASSERT(output.uri_.isEmpty());
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output.req.v_end);
         CPPUNIT_ASSERT_EQUAL(AnyP::ProtocolVersion(), output.msgProtocol_);
     }
 
@@ -117,17 +99,9 @@ testHttp1Parser::testParserConstruct()
         CPPUNIT_ASSERT_EQUAL(true, output->needsMoreData());
         CPPUNIT_ASSERT_EQUAL(Http1::HTTP_PARSE_NONE, output->parsingStage_);
         CPPUNIT_ASSERT_EQUAL(Http::scNone, output->request_parse_status);
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.start);
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.end);
         CPPUNIT_ASSERT(output->buf_.isEmpty());
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.m_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.m_end);
         CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), output->method_);
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.u_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.u_end);
         CPPUNIT_ASSERT(output->uri_.isEmpty());
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.v_start);
-        CPPUNIT_ASSERT_EQUAL(-1, output->req.v_end);
         CPPUNIT_ASSERT_EQUAL(AnyP::ProtocolVersion(), output->msgProtocol_);
         delete output;
     }
@@ -144,7 +118,7 @@ testHttp1Parser::testParseRequestLineProtocols()
     Http1::RequestParser output;
 
     // TEST: Do we comply with RFC 1945 section 5.1 ?
-    // TEST: Do we comply with RFC 2616 section 5.1 ?
+    // TEST: Do we comply with RFC 7230 sections 2.6, 3.1.1 and 3.5 ?
 
     // RFC 1945 : HTTP/0.9 simple-request
     {
@@ -154,17 +128,9 @@ testHttp1Parser::testParseRequestLineProtocols()
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
         };
         output.clear();
@@ -173,103 +139,70 @@ testHttp1Parser::testParseRequestLineProtocols()
     }
 
     // RFC 1945 : invalid HTTP/0.9 simple-request (only GET is valid)
-#if WHEN_RFC_COMPLIANT
     {
-        input.append("POST /\r\n", 7);
+        input.append("POST /\r\n", 8);
         struct resultSet expect = {
-            .parsed = true,
+            .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
-            .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 3,
+            .status = Http::scBadRequest,
+            .suffixSz = 3,
             .method = HttpRequestMethod(Http::METHOD_POST),
-            .uriStart = 5,
-            .uriEnd = 5,
-            .uri = "/",
-            .versionStart = -1,
-            .versionEnd = -1,
+            .uri = NULL,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
-#endif
-    // RFC 1945 and 2616 : HTTP/1.0 request
+
+    // RFC 1945 and 7230 : HTTP/1.0 request
     {
         input.append("GET / HTTP/1.0\r\n", 16);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,0)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // RFC 2616 : HTTP/1.1 request
+    // RFC 7230 : HTTP/1.1 request
     {
         input.append("GET / HTTP/1.1\r\n", 16);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // RFC 2616 : future version full-request
+    // RFC 7230 : future version full-request
     {
         input.append("GET / HTTP/1.2\r\n", 16);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,2)
         };
         output.clear();
@@ -279,75 +212,66 @@ testHttp1Parser::testParseRequestLineProtocols()
 
     // RFC 7230 : future versions do not use request-line syntax
     {
+        input.append("GET / HTTP/2.0\r\n", 16);
+        struct resultSet expectA = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scHttpVersionNotSupported,
+            .suffixSz = input.length()-6,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uri = "/",
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectA);
+        input.clear();
+
         input.append("GET / HTTP/10.12\r\n", 18);
-        struct resultSet expect = {
+        struct resultSet expectB = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 15,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
-        testResults(__LINE__, input, output, expect);
+        testResults(__LINE__, input, output, expectB);
         input.clear();
     }
 
     // unknown non-HTTP protocol names
     {
-        input.append("GET / FOO/1.0\n", 14);
+        input.append("GET / FOO/1.0\r\n", 15);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 12,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // no version
+    // no version digits
     {
-        input.append("GET / HTTP/\n", 12);
+        input.append("GET / HTTP/\r\n", 13);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 10,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -357,23 +281,15 @@ testHttp1Parser::testParseRequestLineProtocols()
 
     // no major version
     {
-        input.append("GET / HTTP/.1\n", 14);
+        input.append("GET / HTTP/.1\r\n", 15);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 12,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -383,23 +299,15 @@ testHttp1Parser::testParseRequestLineProtocols()
 
     // no version dot
     {
-        input.append("GET / HTTP/11\n", 14);
+        input.append("GET / HTTP/11\r\n", 15);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 12,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -409,23 +317,15 @@ testHttp1Parser::testParseRequestLineProtocols()
 
     // negative major version (bug 3062)
     {
-        input.append("GET / HTTP/-999999.1\n", 21);
+        input.append("GET / HTTP/-999999.1\r\n", 22);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 19,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -435,24 +335,16 @@ testHttp1Parser::testParseRequestLineProtocols()
 
     // no minor version
     {
-        input.append("GET / HTTP/1.\n", 14);
+        input.append("GET / HTTP/1.\r\n", 15);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 12,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,0)
+            .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
@@ -461,24 +353,16 @@ testHttp1Parser::testParseRequestLineProtocols()
 
     // negative major version (bug 3062 corollary)
     {
-        input.append("GET / HTTP/1.-999999\n", 21);
+        input.append("GET / HTTP/1.-999999\r\n", 22);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scHttpVersionNotSupported,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 19,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,0)
+            .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
@@ -498,80 +382,87 @@ testHttp1Parser::testParseRequestLineStrange()
     // space padded URL
     {
         input.append("GET  /     HTTP/1.1\r\n", 21);
+        // when being tolerant extra (sequential) SP delimiters are acceptable
+        Config.onoff.relaxed_header_parser = 1;
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 5,
-            .uriEnd = 5,
             .uri = "/",
-            .versionStart = 11,
-            .versionEnd = 18,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
+
+        Config.onoff.relaxed_header_parser = 0;
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .suffixSz = input.length()-4,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 
     // whitespace inside URI. (nasty but happens)
-    // XXX: depends on tolerant parser...
     {
-        input.append("GET /fo o/ HTTP/1.1\n", 20);
+        input.append("GET /fo o/ HTTP/1.1\r\n", 21);
+        Config.onoff.relaxed_header_parser = 1;
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 9,
             .uri = "/fo o/",
-            .versionStart = 11,
-            .versionEnd = 18,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
+
+        Config.onoff.relaxed_header_parser = 0;
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported, // version being "o/ HTTP/1.1"
+            .suffixSz = 13,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 
     // additional data in buffer
     {
-        input.append("GET /     HTTP/1.1\nboo!", 23);
+        input.append("GET / HTTP/1.1\r\nboo!", 20);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-5,
             .suffixSz = 4, // strlen("boo!")
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 10,
-            .versionEnd = 17,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
+        Config.onoff.relaxed_header_parser = 0;
     }
 }
 
@@ -585,101 +476,67 @@ testHttp1Parser::testParseRequestLineTerminators()
     Http1::RequestParser output;
 
     // alternative EOL sequence: NL-only
+    // RFC 7230 tolerance permits omitted CR
     {
         input.append("GET / HTTP/1.1\n", 15);
+        Config.onoff.relaxed_header_parser = 1;
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
-        input.clear();
-    }
 
-    // alternative EOL sequence: double-NL-only
-    {
-        input.append("GET / HTTP/1.1\n\n", 16);
-        struct resultSet expect = {
-            .parsed = true,
+        Config.onoff.relaxed_header_parser = 0;
+        struct resultSet expectStrict = {
+            .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
-            .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-2,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
+            .status = Http::scHttpVersionNotSupported,
+            .suffixSz = 9,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+            .version = AnyP::ProtocolVersion()
         };
         output.clear();
-        testResults(__LINE__, input, output, expect);
+        testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 
-    // alternative EOL sequence: multi-CR-NL
+    // alternative EOL sequence: double-NL-only
+    // RFC 7230 tolerance permits omitted CR
+    // NP: represents a request with no mime headers
     {
-        input.append("GET / HTTP/1.1\r\r\r\n", 18);
-        // Being tolerant we can ignore and elide these apparently benign CR
+        input.append("GET / HTTP/1.1\n\n", 16);
         Config.onoff.relaxed_header_parser = 1;
-        struct resultSet expectRelaxed = {
-            .parsed = false,
-            .needsMore = true,
-            .parserState = Http1::HTTP_PARSE_MIME,
+        struct resultSet expect = {
+            .parsed = true,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
-        testResults(__LINE__, input, output, expectRelaxed);
+        testResults(__LINE__, input, output, expect);
 
-        // strict mode treats these as several bare-CR in the request line which is explicitly invalid.
         Config.onoff.relaxed_header_parser = 0;
         struct resultSet expectStrict = {
             .parsed = false,
             .needsMore = false,
-            .parserState = Http1::HTTP_PARSE_MIME,
-            .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = -1,
-            .suffixSz = input.length(),
-            .methodStart =-1,
-            .methodEnd = -1,
-            .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
-            .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scHttpVersionNotSupported,
+            .suffixSz = 10,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uri = "/",
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -689,25 +546,16 @@ testHttp1Parser::testParseRequestLineTerminators()
 
     // space padded version
     {
-        // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
-        // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
-        input.append("GET / HTTP/1.1 \n", 16);
+        // RFC 7230 specifies version is followed by CRLF. No intermediary bytes.
+        input.append("GET / HTTP/1.1 \r\n", 17);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
-            .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 2,
+            .status = Http::scHttpVersionNotSupported,
+            .suffixSz = input.length()-6,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 13,
-            .uri = "/ HTTP/1.1",
-            .versionStart = -1,
-            .versionEnd = -1,
+            .uri = "/",
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -725,25 +573,35 @@ testHttp1Parser::testParseRequestLineMethods()
     SBuf input;
     Http1::RequestParser output;
 
-    // RFC 2616 : . method
+    // RFC 7230 : dot method
     {
-        input.append(". / HTTP/1.1\n", 13);
+        input.append(". / HTTP/1.1\r\n", 14);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 0,
             .method = HttpRequestMethod(SBuf(".")),
-            .uriStart = 2,
-            .uriEnd = 2,
             .uri = "/",
-            .versionStart = 4,
-            .versionEnd = 11,
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
+    }
+
+    // RFC 7230 : special TCHAR method chars
+    {
+        input.append("!#$%&'*+-.^_`|~ / HTTP/1.1\r\n", 28);
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_MIME,
+            .status = Http::scOkay,
+            .suffixSz = 0,
+            .method = HttpRequestMethod(SBuf("!#$%&'*+-.^_`|~")),
+            .uri = "/",
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
@@ -753,23 +611,15 @@ testHttp1Parser::testParseRequestLineMethods()
 
     // OPTIONS with * URL
     {
-        input.append("OPTIONS * HTTP/1.1\n", 19);
+        input.append("OPTIONS * HTTP/1.1\r\n", 20);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 6,
             .method = HttpRequestMethod(Http::METHOD_OPTIONS),
-            .uriStart = 8,
-            .uriEnd = 8,
             .uri = "*",
-            .versionStart = 10,
-            .versionEnd = 17,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
@@ -779,30 +629,40 @@ testHttp1Parser::testParseRequestLineMethods()
 
     // unknown method
     {
-        input.append("HELLOWORLD / HTTP/1.1\n", 22);
+        input.append("HELLOWORLD / HTTP/1.1\r\n", 23);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 9,
             .method = HttpRequestMethod(SBuf("HELLOWORLD")),
-            .uriStart = 11,
-            .uriEnd = 11,
             .uri = "/",
-            .versionStart = 13,
-            .versionEnd = 20,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
+    // too-long method (over 16 bytes)
+    {
+        input.append("HELLOSTRANGEWORLD / HTTP/1.1\r\n", 31);
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scNotImplemented,
+            .suffixSz = input.length(),
+            .method = HttpRequestMethod(),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
+    }
+
     // method-only
     {
         input.append("A\n", 2);
@@ -811,17 +671,9 @@ testHttp1Parser::testParseRequestLineMethods()
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -836,149 +688,150 @@ testHttp1Parser::testParseRequestLineMethods()
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // space padded method (in strict mode SP is reserved so invalid as a method byte)
+    // space padded method (SP is reserved so invalid as a method byte)
     {
-        input.append(" GET / HTTP/1.1\n", 16);
-        // RELAXED mode Squid custom tolerance ignores SP
-#if USE_HTTP_VIOLATIONS
+        input.append(" GET / HTTP/1.1\r\n", 17);
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .suffixSz = input.length(),
+            .method = HttpRequestMethod(),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
+    }
+
+    // RFC 7230 defined tolerance: ignore empty line(s) prefix on messages
+    {
+        input.append("\r\n\r\n\nGET / HTTP/1.1\r\n", 21);
         Config.onoff.relaxed_header_parser = 1;
-        struct resultSet expectRelaxed = {
+        struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0, // garbage collection consumes the SP
-            .msgEnd = (int)input.length()-2,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
-        testResults(__LINE__, input, output, expectRelaxed);
-#endif
+        testResults(__LINE__, input, output, expect);
 
-        // STRICT mode obeys RFC syntax
         Config.onoff.relaxed_header_parser = 0;
         struct resultSet expectStrict = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 
-    // RFC 2616 defined tolerance: ignore empty line(s) prefix on messages
-#if WHEN_RFC_COMPLIANT
+    // forbidden character in method
     {
-        input.append("\r\n\r\n\nGET / HTTP/1.1\r\n", 21);
+        input.append("\tGET / HTTP/1.1\r\n", 17);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .suffixSz = input.length(),
+            .method = HttpRequestMethod(),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expect);
+        input.clear();
+    }
+
+    // CR in method delimiters
+    {
+        // RFC 7230 section 3.5 permits CR in whitespace but only for tolerant parsers
+        input.append("GET\r / HTTP/1.1\r\n", 17);
+        Config.onoff.relaxed_header_parser = 1;
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 5,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = 5,
-            .methodStart = 0,
-            .methodEnd = 2,
+            .suffixSz = 0,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 4,
             .uri = "/",
-            .versionStart = 6,
-            .versionEnd = 13,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
-        input.clear();
-    }
-#endif
 
-    // tab padded method (NP: tab is not SP so treated as any other binary)
-    {
-        input.append("\tGET / HTTP/1.1\n", 16);
-#if WHEN_RFC_COMPLIANT
-        struct resultSet expect = {
+        Config.onoff.relaxed_header_parser = 0;
+        struct resultSet expectStrict = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = -1,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
-#else // XXX: currently broken
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
+        input.clear();
+    }
+
+    // tolerant parser delimiters
+    {
+        // RFC 7230 section 3.5 permits certain binary characters as whitespace delimiters
+        input.append("GET\r\t\x0B\x0C / HTTP/1.1\r\n", 20);
+        Config.onoff.relaxed_header_parser = 1;
         struct resultSet expect = {
             .parsed = false,
             .needsMore = true,
             .parserState = Http1::HTTP_PARSE_MIME,
             .status = Http::scOkay,
-            .msgStart = 0, // garbage collection consumes the SP
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 3,
-            .method = HttpRequestMethod(SBuf("\tGET")),
-            .uriStart = 5,
-            .uriEnd = 5,
+            .method = HttpRequestMethod(Http::METHOD_GET),
             .uri = "/",
-            .versionStart = 7,
-            .versionEnd = 14,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
         };
-#endif
         output.clear();
         testResults(__LINE__, input, output, expect);
+
+        Config.onoff.relaxed_header_parser = 0;
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .suffixSz = input.length(),
+            .method = HttpRequestMethod(),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 }
@@ -992,274 +845,124 @@ testHttp1Parser::testParseRequestLineInvalid()
     SBuf input;
     Http1::RequestParser output;
 
-    // no method (but in a form which is ambiguous with HTTP/0.9 simple-request)
+    // no method (or method delimiter)
     {
-        // XXX: HTTP/0.9 requires method to be "GET"
+        // HTTP/0.9 requires method to be "GET"
         input.append("/ HTTP/1.0\n", 11);
         struct resultSet expect = {
-            .parsed = true,
-            .needsMore = false,
-            .parserState = Http1::HTTP_PARSE_MIME,
-            .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 0,
-            .method = HttpRequestMethod(SBuf("/")),
-            .uriStart = 2,
-            .uriEnd = 9,
-            .uri = "HTTP/1.0",
-            .versionStart = -1,
-            .versionEnd = -1,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
-        };
-        output.clear();
-        testResults(__LINE__, input, output, expect);
-        input.clear();
-    }
-
-    // no method (an invalid format)
-    {
-        input.append(" / HTTP/1.0\n", 12);
-#if USE_HTTP_VIOLATIONS
-        // squid custom tolerance consumes initial SP.
-        Config.onoff.relaxed_header_parser = 1;
-        struct resultSet expectRelaxed = {
-            .parsed = true,
-            .needsMore = false,
-            .parserState = Http1::HTTP_PARSE_MIME,
-            .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-2,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 0,
-            .method = HttpRequestMethod(SBuf("/")),
-            .uriStart = 2,
-            .uriEnd = 9,
-            .uri = "HTTP/1.0",
-            .versionStart = -1,
-            .versionEnd = -1,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
-        };
-        output.clear();
-        testResults(__LINE__, input, output, expectRelaxed);
-#endif
-
-#if !USE_HTTP_VIOLATIONS
-        // a compliant or strict parse, detects as invalid
-        Config.onoff.relaxed_header_parser = 0;
-        struct resultSet expectStrict = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
-#else
-        // XXX: for now Squid confuses this with HTTP/0.9
-        struct resultSet expectStrict = {
-            .parsed = true,
-            .needsMore = false,
-            .parserState = Http1::HTTP_PARSE_DONE,
-            .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-2,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 0,
-            .method = HttpRequestMethod(SBuf("/")),
-            .uriStart = 2,
-            .uriEnd = 9,
-            .uri = "HTTP/1.0",
-            .versionStart = -1,
-            .versionEnd = -1,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
-        };
-#endif
         output.clear();
-        testResults(__LINE__, input, output, expectStrict);
+        testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // binary code in method (invalid)
+    // no method (with method delimiter)
     {
-        input.append("GET\x0B / HTTP/1.1\n", 16);
-#if WHEN_RFC_COMPLIANT
-        struct resultSet expect = {
+        input.append(" / HTTP/1.0\n", 12);
+        struct resultSet expectStrict = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = -1,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
-#else
-        struct resultSet expect = {
-            .parsed = false,
-            .needsMore = true,
-            .parserState = Http1::HTTP_PARSE_MIME,
-            .status = Http::scOkay,
-            .msgStart = 0, // garbage collection consumes the SP
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 3,
-            .method = HttpRequestMethod(SBuf("GET\x0B", 4)),
-            .uriStart = 5,
-            .uriEnd = 5,
-            .uri = "/",
-            .versionStart = 7,
-            .versionEnd = 14,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
-        };
-#endif
         output.clear();
-        testResults(__LINE__, input, output, expect);
+        testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 
-    // CR in method
+    // binary code in method (invalid)
     {
-        // RFC 2616 sec 5.1 prohibits CR other than in terminator.
-        input.append("GET\r / HTTP/1.1\r\n", 16);
+        input.append("GET\x0A / HTTP/1.1\r\n", 17);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = -1, // halt at the first \r
             .suffixSz = input.length(),
-            .methodStart = -1,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // binary code NUL! in method (strange but ...)
+    // binary code NUL! in method (always invalid)
     {
-        input.append("GET\0 / HTTP/1.1\n", 16);
-#if WHEN_RFC_COMPLIANT
+        input.append("GET\0 / HTTP/1.1\r\n", 17);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = -1, // halt at the \0
             .suffixSz = input.length(),
-            .methodStart = -1,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
-#else
-        struct resultSet expect = {
-            .parsed = false,
-            .needsMore = true,
-            .parserState = Http1::HTTP_PARSE_MIME,
-            .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 3,
-            .method = HttpRequestMethod(SBuf("GET\0",4)),
-            .uriStart = 5,
-            .uriEnd = 5,
-            .uri = "/",
-            .versionStart = 7,
-            .versionEnd = 14,
-            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1)
-        };
-#endif
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
     // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
     {
-        input.append("GET  HTTP/1.1\n", 14);
+        input.append("GET  HTTP/1.1\r\n", 15);
+        // RFC 7230 tolerance allows sequence of SP to make this ambiguous
+        Config.onoff.relaxed_header_parser = 1;
         struct resultSet expect = {
             .parsed = true,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 5,
-            .uriEnd = 12,
             .uri = "HTTP/1.1",
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
+
+        Config.onoff.relaxed_header_parser = 0;
+        struct resultSet expectStrict = {
+            .parsed = false,
+            .needsMore = false,
+            .parserState = Http1::HTTP_PARSE_DONE,
+            .status = Http::scBadRequest,
+            .suffixSz = 11,
+            .method = HttpRequestMethod(Http::METHOD_GET),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
+        output.clear();
+        testResults(__LINE__, input, output, expectStrict);
         input.clear();
     }
 
     // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
     {
-        input.append("GET HTTP/1.1\n", 13);
+        input.append("GET HTTP/1.1\r\n", 14);
         struct resultSet expect = {
             .parsed = true,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scOkay,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = 0,
-            .methodStart = 0,
-            .methodEnd = 2,
             .method = HttpRequestMethod(Http::METHOD_GET),
-            .uriStart = 4,
-            .uriEnd = 11,
             .uri = "HTTP/1.1",
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
         };
         output.clear();
@@ -1275,17 +978,9 @@ testHttp1Parser::testParseRequestLineInvalid()
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -1295,53 +990,33 @@ testHttp1Parser::testParseRequestLineInvalid()
 
     // mixed whitespace line
     {
-        // We accept non-space binary bytes for method so first \t shows up as that
-        // but remaining space and tabs are skipped searching for URI-start
         input.append("\t \t \t\n", 6);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
             .suffixSz = input.length(),
-            .methodStart = 0,
-            .methodEnd = 0,
-            .method = HttpRequestMethod(SBuf("\t")),
-            .uriStart = -1,
-            .uriEnd = -1,
+            .method = HttpRequestMethod(),
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
         testResults(__LINE__, input, output, expect);
         input.clear();
     }
 
-    // mixed whitespace line with CR middle
+    // mixed whitespace line with CR
     {
-        // CR aborts on sight, so even initial \t method is not marked as above
-        // (not when parsing clean with whole line available anyway)
-        input.append("\t  \r \n", 6);
+        input.append("\r  \t \n", 6);
         struct resultSet expect = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
-            .msgStart = 0,
-            .msgEnd = -1, // halt on the \r
             .suffixSz = input.length(),
-            .methodStart = -1,
-            .methodEnd = -1,
             .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
             .uri = NULL,
-            .versionStart = -1,
-            .versionEnd = -1,
             .version = AnyP::ProtocolVersion()
         };
         output.clear();
@@ -1358,96 +1033,108 @@ testHttp1Parser::testDripFeed()
     // calling the parser repeatedly as visible data grows.
 
     SBuf data;
-#if USE_HTTP_VIOLATIONS
-    data.append("            ", 12);
-#else
     data.append("\n\n\n\n\n\n\n\n\n\n\n\n", 12);
-#endif
     SBuf::size_type garbageEnd = data.length();
-    data.append("GET http://example.com/ HTTP/1.1\r\n", 34);
+    data.append("GET ", 4);
+    SBuf::size_type methodEnd = data.length()-1;
+    data.append("http://example.com/ ", 20);
+    SBuf::size_type uriEnd = data.length()-1;
+    data.append("HTTP/1.1\r\n", 10);
     SBuf::size_type reqLineEnd = data.length() - 1;
     data.append("Host: example.com\r\n\r\n", 21);
     SBuf::size_type mimeEnd = data.length() - 1;
     data.append("...", 3); // trailer to catch mime EOS errors.
 
-    SBuf ioBuf; // begins empty
+    SBuf ioBuf;
     Http1::RequestParser hp;
 
-    // only relaxed parser accepts the garbage whitespace
-    Config.onoff.relaxed_header_parser = 1;
-
-    // state of things we expect right now
-    struct resultSet expect = {
-        .parsed = false,
-        .needsMore = true,
-        .parserState = Http1::HTTP_PARSE_NONE,
-        .status = Http::scNone,
-        .msgStart = -1,
-        .msgEnd = -1,
-        .suffixSz = 0,
-        .methodStart = -1,
-        .methodEnd = -1,
-        .method = HttpRequestMethod(),
-        .uriStart = -1,
-        .uriEnd = -1,
-        .uri = NULL,
-        .versionStart = -1,
-        .versionEnd = -1,
-        .version = AnyP::ProtocolVersion()
-    };
+    // start with strict and move on to relaxed
+    Config.onoff.relaxed_header_parser = 2;
 
     Config.maxRequestHeaderSize = 1024; // large enough to hold the test data.
 
-    for (SBuf::size_type pos = 0; pos <= data.length(); ++pos) {
+    do {
 
-        // simulate reading one more byte
-        ioBuf.append(data.substr(pos,1));
-
-        // when the garbage is passed we expect to start seeing first-line bytes
-        if (pos == garbageEnd) {
-            expect.parserState = Http1::HTTP_PARSE_FIRST;
-            expect.msgStart = 0;
-        }
-
-        // all points after garbage start to see accumulated bytes looking for end of current section
-        if (pos >= garbageEnd)
-            expect.suffixSz = ioBuf.length();
-
-        // at end of request line expect to see method, URI, version details
-        // and switch to seeking Mime header section
-        if (pos == reqLineEnd) {
-            expect.parserState = Http1::HTTP_PARSE_MIME;
-            expect.suffixSz = 0;
-            expect.msgEnd = reqLineEnd-garbageEnd;
-            expect.status = Http::scOkay;
-            expect.methodStart = 0;
-            expect.methodEnd = 2;
-            expect.method = HttpRequestMethod(Http::METHOD_GET);
-            expect.uriStart = 4;
-            expect.uriEnd = 22;
-            expect.uri = "http://example.com/";
-            expect.versionStart = 24;
-            expect.versionEnd = 31;
-            expect.version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1);
-        }
+        // state of things we expect right now
+        struct resultSet expect = {
+            .parsed = false,
+            .needsMore = true,
+            .parserState = Http1::HTTP_PARSE_NONE,
+            .status = Http::scNone,
+            .suffixSz = 0,
+            .method = HttpRequestMethod(),
+            .uri = NULL,
+            .version = AnyP::ProtocolVersion()
+        };
 
-        // one mime header is done we are expecting a new request
-        // parse results say true and initial data is all gone from the buffer
-        if (pos == mimeEnd) {
-            expect.parsed = true;
-            expect.needsMore = false;
-            expect.suffixSz = 0;
+        ioBuf.clear(); // begins empty for each parser type
+        hp.clear();
+
+        --Config.onoff.relaxed_header_parser;
+
+        for (SBuf::size_type pos = 0; pos <= data.length(); ++pos) {
+
+            // simulate reading one more byte
+            ioBuf.append(data.substr(pos,1));
+
+            // strict does not permit the garbage prefix
+            if (pos < garbageEnd && !Config.onoff.relaxed_header_parser) {
+                ioBuf.clear();
+                continue;
+            }
+
+            // when the garbage is passed we expect to start seeing first-line bytes
+            if (pos == garbageEnd)
+                expect.parserState = Http1::HTTP_PARSE_FIRST;
+
+            // all points after garbage start to see accumulated bytes looking for end of current section
+            if (pos >= garbageEnd)
+                expect.suffixSz = ioBuf.length();
+
+            // at end of request line expect to see method details
+            if (pos == methodEnd) {
+                expect.suffixSz = 0; // and a checkpoint buffer reset
+                expect.method = HttpRequestMethod(Http::METHOD_GET);
+            }
+
+            // at end of URI strict expects to see method, URI details
+            // relaxed must wait to end of line for whitespace tolerance
+            if (pos == uriEnd && !Config.onoff.relaxed_header_parser) {
+                expect.suffixSz = 0; // and a checkpoint buffer reset
+                expect.uri = "http://example.com/";
+            }
+
+            // at end of request line expect to see method, URI, version details
+            // and switch to seeking Mime header section
+            if (pos == reqLineEnd) {
+                expect.parserState = Http1::HTTP_PARSE_MIME;
+                expect.suffixSz = 0; // and a checkpoint buffer reset
+                expect.status = Http::scOkay;
+                expect.method = HttpRequestMethod(Http::METHOD_GET);
+                expect.uri = "http://example.com/";
+                expect.version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1);
+            }
+
+            // one mime header is done we are expecting a new request
+            // parse results say true and initial data is all gone from the buffer
+            if (pos == mimeEnd) {
+                expect.parsed = true;
+                expect.needsMore = false;
+                expect.suffixSz = 0; // and a checkpoint buffer reset
+            }
+
+            testResults(__LINE__, ioBuf, hp, expect);
+
+            // sync the buffers like Squid does
+            ioBuf = hp.remaining();
+
+            // Squid stops using the parser once it has parsed the first message.
+            if (!hp.needsMoreData())
+                break;
         }
 
-        testResults(__LINE__, ioBuf, hp, expect);
+    } while (Config.onoff.relaxed_header_parser);
 
-        // sync the buffers like Squid does
-        ioBuf = hp.remaining();
-
-        // Squid stops using the parser once it has parsed the first message.
-        if (!hp.needsMoreData())
-            break;
-    }
 }
 #endif /* __cplusplus >= 201103L */
 
@@ -14,15 +14,16 @@
 class testHttp1Parser : public CPPUNIT_NS::TestFixture
 {
     CPPUNIT_TEST_SUITE( testHttp1Parser );
+    // object basics are working, just in case.
     CPPUNIT_TEST( testParserConstruct );
 
 #if __cplusplus >= 201103L
-    CPPUNIT_TEST( testParseRequestLineTerminators );
+    CPPUNIT_TEST( testDripFeed );
     CPPUNIT_TEST( testParseRequestLineMethods );
     CPPUNIT_TEST( testParseRequestLineProtocols );
+    CPPUNIT_TEST( testParseRequestLineTerminators );
     CPPUNIT_TEST( testParseRequestLineStrange );
     CPPUNIT_TEST( testParseRequestLineInvalid );
-    CPPUNIT_TEST( testDripFeed );
 #endif
     CPPUNIT_TEST_SUITE_END();
 
@@ -7,15 +7,12 @@
  */
 
 #include "squid.h"
+#include "dns/rfc1035.h"
 #include "testRFC1035.h"
 #include "unitTestMain.h"
 
 #include <cassert>
 
-/* Being a C library code it is best bodily included and tested with C++ type-safe techniques. */
-#include "lib/rfc1035.c"
-#include "lib/rfc2671.c"
-
 CPPUNIT_TEST_SUITE_REGISTRATION( testRFC1035 );
 
 // TODO Test each function in the Library independently
@@ -915,3 +915,40 @@ testSBuf::testStdStringOps()
     CPPUNIT_ASSERT_EQUAL(astr,sb.toStdString());
 }
 
+void
+testSBuf::testIterators()
+{
+    SBuf text("foo"), text2("foo");
+    CPPUNIT_ASSERT(text.begin() == text.begin());
+    CPPUNIT_ASSERT(text.begin() != text.end());
+    CPPUNIT_ASSERT(text.begin() != text2.begin());
+    {
+        auto i = text.begin();
+        auto e = text.end();
+        CPPUNIT_ASSERT_EQUAL('f', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT(i == e);
+    }
+    {
+        auto i = text.rbegin();
+        auto e = text.rend();
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('f', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT(i == e);
+    }
+}
+
@@ -52,6 +52,7 @@ class testSBuf : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testSBufStream );
     CPPUNIT_TEST( testAutoFind );
     CPPUNIT_TEST( testStdStringOps );
+    CPPUNIT_TEST( testIterators );
 //    CPPUNIT_TEST( testDumpStats ); //fake test, to print alloc stats
     CPPUNIT_TEST_SUITE_END();
 protected:
@@ -91,6 +92,7 @@ class testSBuf : public CPPUNIT_NS::TestFixture
     void testFindFirstNotOf();
     void testAutoFind();
     void testStdStringOps();
+    void testIterators();
 };
 
 #endif
@@ -360,8 +360,12 @@ void
 BroadcastSignalIfAny(int& sig)
 {
     if (sig > 0) {
-        if (IamCoordinatorProcess())
-            Ipc::Coordinator::Instance()->broadcastSignal(sig);
+        if (IamMasterProcess()) {
+            for (int i = TheKids.count() - 1; i >= 0; --i) {
+                Kid& kid = TheKids.get(i);
+                kill(kid.getPid(), sig);
+            }
+        }
         sig = -1;
     }
 }
@@ -398,48 +402,6 @@ debug_trap(const char *message)
     _db_print("WARNING: %s\n", message);
 }
 
-void
-sig_child(int sig)
-{
-#if !_SQUID_WINDOWS_
-#if _SQUID_NEXT_
-    union wait status;
-#else
-
-    int status;
-#endif
-
-    pid_t pid;
-
-    do {
-#if _SQUID_NEXT_
-        pid = wait3(&status, WNOHANG, NULL);
-#else
-
-        pid = waitpid(-1, &status, WNOHANG);
-#endif
-        /* no debugs() here; bad things happen if the signal is delivered during _db_print() */
-#if HAVE_SIGACTION
-
-    } while (pid > 0);
-
-#else
-
-    }
-
-    while (pid > 0 || (pid < 0 && errno == EINTR));
-    signal(sig, sig_child);
-
-#endif
-#endif
-}
-
-void
-sig_shutdown(int)
-{
-    shutting_down = 1;
-}
-
 const char *
 getMyHostname(void)
 {
@@ -745,9 +707,6 @@ writePidFile(void)
     mode_t old_umask;
     char buf[32];
 
-    if (!IamPrimaryProcess())
-        return;
-
     if ((f = Config.pidFilename) == NULL)
         return;
 
@@ -758,7 +717,7 @@ writePidFile(void)
 
     old_umask = umask(022);
 
-    fd = file_open(f, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT);
+    fd = open(f, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, 0644);
 
     umask(old_umask);
 
@@ -771,8 +730,19 @@ writePidFile(void)
     }
 
     snprintf(buf, 32, "%d\n", (int) getpid());
-    FD_WRITE_METHOD(fd, buf, strlen(buf));
-    file_close(fd);
+    const size_t ws = write(fd, buf, strlen(buf));
+    assert(ws == strlen(buf));
+    close(fd);
+}
+
+void
+removePidFile()
+{
+    if (Config.pidFilename && strcmp(Config.pidFilename, "none") != 0) {
+        enter_suid();
+        safeunlink(Config.pidFilename, 0);
+        leave_suid();
+    }
 }
 
 pid_t
@@ -896,7 +866,7 @@ setSystemLimits(void)
     }
 #endif /* HAVE_SETRLIMIT */
 
-#if HAVE_SETRLIMIT && defined(RLIMIT_DATA)
+#if HAVE_SETRLIMIT && defined(RLIMIT_DATA) && !_SQUID_CYGWIN_
     if (getrlimit(RLIMIT_DATA, &rl) < 0) {
         debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_DATA: " << xstrerror());
     } else if (rl.rlim_max > rl.rlim_cur) {
@@ -912,7 +882,7 @@ setSystemLimits(void)
         debugs(50, DBG_IMPORTANT, "NOTICE: Could not increase the number of filedescriptors");
     }
 
-#if HAVE_SETRLIMIT && defined(RLIMIT_VMEM)
+#if HAVE_SETRLIMIT && defined(RLIMIT_VMEM) && !_SQUID_CYGWIN_
     if (getrlimit(RLIMIT_VMEM, &rl) < 0) {
         debugs(50, DBG_CRITICAL, "getrlimit: RLIMIT_VMEM: " << xstrerror());
     } else if (rl.rlim_max > rl.rlim_cur) {
@@ -1227,7 +1197,10 @@ restoreCapabilities(bool keep)
         cap_value_t cap_list[10];
         cap_list[ncaps] = CAP_NET_BIND_SERVICE;
         ++ncaps;
-        if (Ip::Interceptor.TransparentActive() || Ip::Qos::TheConfig.isHitNfmarkActive() || Ip::Qos::TheConfig.isAclNfmarkActive()) {
+        if (Ip::Interceptor.TransparentActive() ||
+                Ip::Qos::TheConfig.isHitNfmarkActive() ||
+                Ip::Qos::TheConfig.isAclNfmarkActive() ||
+                Ip::Qos::TheConfig.isAclTosActive()) {
             cap_list[ncaps] = CAP_NET_ADMIN;
             ++ncaps;
         }
@@ -1246,3 +1219,17 @@ restoreCapabilities(bool keep)
 #endif /* HAVE_SYS_CAPABILITY_H */
 }
 
+pid_t
+WaitForOnePid(pid_t pid, PidStatus &status, int flags)
+{
+#if _SQUID_NEXT_
+    if (pid < 0)
+        return wait3(&status, flags, NULL);
+    return wait4(cpid, &status, flags, NULL);
+#elif _SQUID_WINDOWS_
+    return 0; // function not used on Windows
+#else
+    return waitpid(pid, &status, flags);
+#endif
+}
+
@@ -44,6 +44,7 @@ void leave_suid(void);
 void enter_suid(void);
 void no_suid(void);
 void writePidFile(void);
+void removePidFile();
 void setMaxFD(void);
 void setSystemLimits(void);
 void squid_signal(int sig, SIGHDLR *, int flags);
@@ -85,5 +86,30 @@ void releaseServerSockets(void);
 void PrintRusage(void);
 void dumpMallocStats(void);
 
+#if _SQUID_NEXT_
+typedef union wait PidStatus;
+#else
+typedef int PidStatus;
+#endif
+
+/**
+ * Compatibility wrapper function for waitpid
+ * \pid the pid of child proccess to wait for.
+ * \param status the exit status returned by waitpid
+ * \param flags WNOHANG or 0
+ */
+pid_t WaitForOnePid(pid_t pid, PidStatus &status, int flags);
+
+/**
+ * Wait for state changes in any of the kid processes.
+ * Equivalent to waitpid(-1, ...) system call
+ * \param status the exit status returned by waitpid
+ * \param flags WNOHANG or 0
+ */
+inline pid_t WaitForAnyPid(PidStatus &status, int flags)
+{
+    return WaitForOnePid(-1, status, flags);
+}
+
 #endif /* SQUID_TOOLS_H_ */
 
@@ -12,6 +12,7 @@
 #include "acl/FilledChecklist.h"
 #include "base/CbcPointer.h"
 #include "CachePeer.h"
+#include "cbdata.h"
 #include "client_side.h"
 #include "client_side_request.h"
 #include "comm.h"
@@ -30,6 +31,7 @@
 #include "LogTags.h"
 #include "MemBuf.h"
 #include "PeerSelectState.h"
+#include "SBuf.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -114,7 +116,8 @@ class TunnelStateData
     {
 
     public:
-        Connection() : len (0), buf ((char *)xmalloc(SQUID_TCP_SO_RCVBUF)), size_ptr(NULL) {}
+        Connection() : len (0), buf ((char *)xmalloc(SQUID_TCP_SO_RCVBUF)), size_ptr(NULL), delayedLoops(0),
+                       readPending(NULL), readPendingFunc(NULL) {}
 
         ~Connection();
 
@@ -136,7 +139,11 @@ class TunnelStateData
         int64_t *size_ptr;      /* pointer to size in an ConnStateData for logging */
 
         Comm::ConnectionPointer conn;    ///< The currently connected connection.
+        uint8_t delayedLoops; ///< how many times a read on this connection has been postponed.
 
+        // XXX: make these an AsyncCall when event API can handle them
+        TunnelStateData *readPending;
+        EVH *readPendingFunc;
     private:
 #if USE_DELAY_POOLS
 
@@ -150,6 +157,7 @@ class TunnelStateData
     LogTags *logTag_ptr;    ///< pointer for logging Squid processing code
     MemBuf *connectRespBuf; ///< accumulates peer CONNECT response when we need it
     bool connectReqWriting; ///< whether we are writing a CONNECT request to a peer
+    SBuf preReadClientData;
 
     void copyRead(Connection &from, IOCB *completion);
 
@@ -197,6 +205,7 @@ class TunnelStateData
 
     static void ReadConnectResponseDone(const Comm::ConnectionPointer &, char *buf, size_t len, Comm::Flag errcode, int xerrno, void *data);
     void readConnectResponseDone(char *buf, size_t len, Comm::Flag errcode, int xerrno);
+    void copyClientBytes();
 };
 
 static const char *const conn_established = "HTTP/1.1 200 Connection established\r\n\r\n";
@@ -207,6 +216,8 @@ static CLCB tunnelServerClosed;
 static CLCB tunnelClientClosed;
 static CTCB tunnelTimeout;
 static PSC tunnelPeerSelectComplete;
+static EVH tunnelDelayedClientRead;
+static EVH tunnelDelayedServerRead;
 static void tunnelConnected(const Comm::ConnectionPointer &server, void *);
 static void tunnelRelayConnectRequest(const Comm::ConnectionPointer &server, void *);
 
@@ -259,6 +270,8 @@ TunnelStateData::TunnelStateData() :
     connectReqWriting(false)
 {
     debugs(26, 3, "TunnelStateData constructed this=" << this);
+    client.readPendingFunc = &tunnelDelayedClientRead;
+    server.readPendingFunc = &tunnelDelayedServerRead;
 }
 
 TunnelStateData::~TunnelStateData()
@@ -272,6 +285,9 @@ TunnelStateData::~TunnelStateData()
 
 TunnelStateData::Connection::~Connection()
 {
+    if (readPending)
+        eventDelete(readPendingFunc, readPending);
+
     safe_free(buf);
 }
 
@@ -328,6 +344,7 @@ void
 TunnelStateData::readServer(char *, size_t len, Comm::Flag errcode, int xerrno)
 {
     debugs(26, 3, HERE << server.conn << ", read " << len << " bytes, err=" << errcode);
+    server.delayedLoops=0;
 
     /*
      * Bail out early on Comm::ERR_CLOSING
@@ -473,6 +490,7 @@ void
 TunnelStateData::readClient(char *, size_t len, Comm::Flag errcode, int xerrno)
 {
     debugs(26, 3, HERE << client.conn << ", read " << len << " bytes, err=" << errcode);
+    client.delayedLoops=0;
 
     /*
      * Bail out early on Comm::ERR_CLOSING
@@ -591,7 +609,7 @@ TunnelStateData::writeServerDone(char *, size_t len, Comm::Flag flag, int xerrno
     const CbcPointer<TunnelStateData> safetyLock(this); /* ??? should be locked by the caller... */
 
     if (cbdataReferenceValid(this))
-        copyRead(client, ReadClient);
+        copyClientBytes();
 }
 
 /* Writes data from the server buffer to the client side */
@@ -673,13 +691,51 @@ TunnelStateData::Connection::closeIfOpen()
         conn->close();
 }
 
+static void
+tunnelDelayedClientRead(void *data)
+{
+    if (!data)
+        return;
+    TunnelStateData *tunnel = static_cast<TunnelStateData*>(data);
+    if (!tunnel)
+        return;
+    tunnel->client.readPending = NULL;
+    static uint64_t counter=0;
+    debugs(26, 7, "Client read(2) delayed " << ++counter << " times");
+    tunnel->copyRead(tunnel->client, TunnelStateData::ReadClient);
+}
+
+static void
+tunnelDelayedServerRead(void *data)
+{
+    if (!data)
+        return;
+    TunnelStateData *tunnel = static_cast<TunnelStateData*>(data);
+    if (!tunnel)
+        return;
+    tunnel->server.readPending = NULL;
+    static uint64_t counter=0;
+    debugs(26, 7, "Server read(2) delayed " << ++counter << " times");
+    tunnel->copyRead(tunnel->server, TunnelStateData::ReadServer);
+}
+
 void
 TunnelStateData::copyRead(Connection &from, IOCB *completion)
 {
     assert(from.len == 0);
+    // If only the minimum permitted read size is going to be attempted
+    // then we schedule an event to try again in a few I/O cycles.
+    // Allow at least 1 byte to be read every (0.3*10) seconds.
+    int bw = from.bytesWanted(1, SQUID_TCP_SO_RCVBUF);
+    if (bw == 1 && ++from.delayedLoops < 10) {
+        from.readPending = this;
+        eventAdd("tunnelDelayedServerRead", from.readPendingFunc, from.readPending, 0.3, true);
+        return;
+    }
+
     AsyncCall::Pointer call = commCbCall(5,4, "TunnelBlindCopyReadHandler",
                                          CommIoCbPtrFun(completion, this));
-    comm_read(from.conn, from.buf, from.bytesWanted(1, SQUID_TCP_SO_RCVBUF), call);
+    comm_read(from.conn, from.buf, bw, call);
 }
 
 void
@@ -693,6 +749,20 @@ TunnelStateData::readConnectResponse()
               server.bytesWanted(1, connectRespBuf->spaceSize()), call);
 }
 
+void
+TunnelStateData::copyClientBytes()
+{
+    if (preReadClientData.length()) {
+        size_t copyBytes = preReadClientData.length() > SQUID_TCP_SO_RCVBUF ? SQUID_TCP_SO_RCVBUF : preReadClientData.length();
+        memcpy(client.buf, preReadClientData.rawContent(), copyBytes);
+        preReadClientData.consume(copyBytes);
+        client.bytesIn(copyBytes);
+        if (keepGoingAfterRead(copyBytes, Comm::OK, 0, client, server))
+            copy(copyBytes, client, server, TunnelStateData::WriteServerDone);
+    } else
+        copyRead(client, ReadClient);
+}
+
 /**
  * Set the HTTP status for this request and sets the read handlers for client
  * and server side connections.
@@ -714,18 +784,13 @@ tunnelStartShoveling(TunnelStateData *tunnelState)
             tunnelState->copy(tunnelState->server.len, tunnelState->server, tunnelState->client, TunnelStateData::WriteClientDone);
         }
 
-        // Bug 3371: shovel any payload already pushed into ConnStateData by the client request
         if (tunnelState->http.valid() && tunnelState->http->getConn() && !tunnelState->http->getConn()->in.buf.isEmpty()) {
             struct ConnStateData::In *in = &tunnelState->http->getConn()->in;
             debugs(26, DBG_DATA, "Tunnel client PUSH Payload: \n" << in->buf << "\n----------");
-
-            // We just need to ensure the bytes from ConnStateData are in client.buf already to deliver
-            memcpy(tunnelState->client.buf, in->buf.rawContent(), in->buf.length());
-            // NP: readClient() takes care of buffer length accounting.
-            tunnelState->readClient(tunnelState->client.buf, in->buf.length(), Comm::OK, 0);
+            tunnelState->preReadClientData.append(in->buf);
             in->buf.consume(); // ConnStateData buffer accounting after the shuffle.
-        } else
-            tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
+        }
+        tunnelState->copyClientBytes();
     }
 }
 
@@ -7,7 +7,6 @@
  */
 
 #include "enums.h"
-#include "rfc1035.h"
 
 #ifndef SQUID_TYPEDEFS_H
 #define SQUID_TYPEDEFS_H
@@ -31,7 +30,6 @@ typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
 #endif
 
 typedef void FREE(void *);
-typedef void CBDUNL(void *);
 typedef void FOCB(void *, int fd, int errcode);
 typedef void PF(int, void *);
 
@@ -44,8 +42,11 @@ typedef void DCCB(int, int errflag, void *data);    /* disk close CB */
 typedef void DUCB(int errflag, void *data); /* disk unlink CB */
 typedef void DTCB(int errflag, void *data); /* disk trunc CB */
 
-class DnsLookupDetails;
-typedef void FQDNH(const char *, const DnsLookupDetails &details, void *);
+namespace Dns
+{
+class LookupDetails;
+}
+typedef void FQDNH(const char *, const Dns::LookupDetails &details, void *);
 
 #include "anyp/ProtocolType.h"
 class CachePeer;
@@ -68,7 +69,6 @@ typedef void STVLDCB(void *, int, int);
 typedef int HLPSAVAIL(void *);
 typedef void HLPSONEQ(void *);
 typedef void HLPCMDOPTS(int *argc, char **argv);
-typedef void IDNSCB(void *, const rfc1035_rr *, int, const char *);
 
 /* MD5 cache keys */
 typedef unsigned char cache_key;
@@ -980,7 +980,7 @@ read_request(void)
 
     cachemgr_request *req;
     char *s;
-    char *t;
+    char *t = NULL;
     char *q;
 
     if ((buf = read_post_request()) != NULL)
@@ -1005,6 +1005,7 @@ read_request(void)
     req = (cachemgr_request *)xcalloc(1, sizeof(cachemgr_request));
 
     for (s = strtok(buf, "&"); s != NULL; s = strtok(NULL, "&")) {
+        safe_free(t);
         t = xstrdup(s);
 
         if ((q = strchr(t, '=')) == NULL)
@@ -1035,8 +1036,8 @@ read_request(void)
             req->workers = xstrdup(q);
         else if (0 == strcmp(t, "processes") && strlen(q))
             req->processes = xstrdup(q);
-        safe_free(t);
     }
+    safe_free(t);
 
     if (req->server && !req->hostname) {
         char *p;
@@ -431,12 +431,14 @@ main(int argc, char *argv[])
                 std::cerr << "ERROR: Proxy password missing" << std::endl;
                 exit(1);
             }
-            blen = base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(buf), strlen(user), reinterpret_cast<const uint8_t*>(user));
-            blen += base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(buf+blen), 1, reinterpret_cast<const uint8_t*>(":"));
-            blen += base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(buf+blen), strlen(password), reinterpret_cast<const uint8_t*>(password));
-            blen += base64_encode_final(&ctx, reinterpret_cast<uint8_t*>(buf+blen));
-            snprintf(buf, BUFSIZ, "Proxy-Authorization: Basic %.*s\r\n", (int)blen, buf);
+            uint8_t *pwdBuf = new uint8_t[base64_encode_len(strlen(user)+1+strlen(password))];
+            blen = base64_encode_update(&ctx, pwdBuf, strlen(user), reinterpret_cast<const uint8_t*>(user));
+            blen += base64_encode_update(&ctx, pwdBuf+blen, 1, reinterpret_cast<const uint8_t*>(":"));
+            blen += base64_encode_update(&ctx, pwdBuf+blen, strlen(password), reinterpret_cast<const uint8_t*>(password));
+            blen += base64_encode_final(&ctx, pwdBuf+blen);
+            snprintf(buf, BUFSIZ, "Proxy-Authorization: Basic %.*s\r\n", (int)blen, reinterpret_cast<char*>(pwdBuf));
             strcat(msg, buf);
+            delete[] pwdBuf;
         }
         if (www_user) {
             const char *user = www_user;
@@ -449,12 +451,14 @@ main(int argc, char *argv[])
                 std::cerr << "ERROR: WWW password missing" << std::endl;
                 exit(1);
             }
-            blen = base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(buf), strlen(user), reinterpret_cast<const uint8_t*>(user));
-            blen += base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(buf+blen), 1, reinterpret_cast<const uint8_t*>(":"));
-            blen += base64_encode_update(&ctx, reinterpret_cast<uint8_t*>(buf+blen), strlen(password), reinterpret_cast<const uint8_t*>(password));
-            blen += base64_encode_final(&ctx, reinterpret_cast<uint8_t*>(buf+blen));
-            snprintf(buf, BUFSIZ, "Authorization: Basic %.*s\r\n", (int)blen, buf);
+            uint8_t *pwdBuf = new uint8_t[base64_encode_len(strlen(user)+1+strlen(password))];
+            blen = base64_encode_update(&ctx, pwdBuf, strlen(user), reinterpret_cast<const uint8_t*>(user));
+            blen += base64_encode_update(&ctx, pwdBuf+blen, 1, reinterpret_cast<const uint8_t*>(":"));
+            blen += base64_encode_update(&ctx, pwdBuf+blen, strlen(password), reinterpret_cast<const uint8_t*>(password));
+            blen += base64_encode_final(&ctx, pwdBuf+blen);
+            snprintf(buf, BUFSIZ, "Authorization: Basic %.*s\r\n", (int)blen, reinterpret_cast<char*>(pwdBuf));
             strcat(msg, buf);
+            delete[] pwdBuf;
         }
 #if HAVE_GSSAPI
         if (www_neg) {