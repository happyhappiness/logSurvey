@@ -28,15 +28,15 @@
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  * 
- * $Id: asn1.h,v 1.8 1998/02/24 22:46:13 kostas Exp $
+ * $Id: asn1.h,v 1.9 1998/04/04 01:43:39 kostas Exp $
  * 
  **********************************************************************/
 
 #ifndef EIGHTBIT_SUBIDS
-typedef u_int	oid;
+typedef u_int oid;
 #define MAX_SUBID   0xFFFFFFFF
 #else
-typedef u_char	oid;
+typedef u_char oid;
 #define MAX_SUBID   0xFF
 #endif
 
@@ -70,32 +70,32 @@ typedef u_char	oid;
 extern "C" {
 #endif
 
-u_char	*asn_build_header(u_char *, int *, u_char, int);
-u_char	*asn_parse_int(u_char *, int *, u_char *, int *, int);
-u_char	*asn_parse_unsigned_int(u_char *, int *, u_char *, u_int *, int);
-u_char	*asn_build_int(u_char *, int *, u_char, int *, int);
-u_char	*asn_build_unsigned_int(u_char *, int *, u_char, u_int *, int);
-u_char	*asn_parse_string(u_char *, int *, u_char *, u_char *, int *);
-u_char	*asn_build_string(u_char *, int *, u_char, u_char *, int);
-u_char	*asn_parse_header(u_char *, int *, u_char *);
-u_char	*asn_build_header_with_truth(u_char *, int *, u_char, int, int);
+    u_char *asn_build_header(u_char *, int *, u_char, int);
+    u_char *asn_parse_int(u_char *, int *, u_char *, int *, int);
+    u_char *asn_parse_unsigned_int(u_char *, int *, u_char *, u_int *, int);
+    u_char *asn_build_int(u_char *, int *, u_char, int *, int);
+    u_char *asn_build_unsigned_int(u_char *, int *, u_char, u_int *, int);
+    u_char *asn_parse_string(u_char *, int *, u_char *, u_char *, int *);
+    u_char *asn_build_string(u_char *, int *, u_char, u_char *, int);
+    u_char *asn_parse_header(u_char *, int *, u_char *);
+    u_char *asn_build_header_with_truth(u_char *, int *, u_char, int, int);
 
-u_char	*asn_parse_length(u_char *, u_int *);
-u_char	*asn_build_length(u_char *, int *, int, int);
-u_char	*asn_parse_objid(u_char *, int *, u_char *, oid *, int *);
-u_char	*asn_build_objid(u_char *, int *, u_char, oid *, int);
-u_char	*asn_parse_null(u_char *, int *, u_char *);
-u_char	*asn_build_null(u_char *, int *, u_char);
+    u_char *asn_parse_length(u_char *, u_int *);
+    u_char *asn_build_length(u_char *, int *, int, int);
+    u_char *asn_parse_objid(u_char *, int *, u_char *, oid *, int *);
+    u_char *asn_build_objid(u_char *, int *, u_char, oid *, int);
+    u_char *asn_parse_null(u_char *, int *, u_char *);
+    u_char *asn_build_null(u_char *, int *, u_char);
 
 #if 0
-u_char *asn_parse_bitstring(u_char *, int *, u_char *, u_char *, int *);
-u_char *asn_build_bitstring(u_char *, int *, u_char, u_char *, int);
+    u_char *asn_parse_bitstring(u_char *, int *, u_char *, u_char *, int *);
+    u_char *asn_build_bitstring(u_char *, int *, u_char, u_char *, int);
 
 #endif
-u_char *asn_build_exception(u_char *, int *, u_char);
+    u_char *asn_build_exception(u_char *, int *, u_char);
 
 #ifdef __cplusplus
 }
-#endif
 
-#endif /* _SNMP_ASN1_H_ */
+#endif
+#endif				/* _SNMP_ASN1_H_ */
@@ -8,14 +8,20 @@
 #define snint long
 #endif
 
+#ifndef MIN
+#define MIN(a,b) (a<b?a:b)
+#endif
+
 #include "snmp.h"
 #include "snmp_impl.h"
 #include "asn1.h"
 #include "snmp_api.h"
+#if 0
 #include "snmp_client.h"
+#include "mib.h"
+#endif
 #include "snmp_vars.h"
 #include "snmp_oidlist.h"
-#include "mib.h"
 
 /* mib stuff here */
 
@@ -30,15 +36,15 @@
  *                 1   3   6     1          3         25     17
  */
 
-#define SQUIDMIB 1, 3, 6, 1, 3, 25, 17     /* length is 7 */
+#define SQUIDMIB 1, 3, 6, 1, 3, 25, 17	/* length is 7 */
 #define LEN_SQUIDMIB 7
 
 #define SYSMIB 1, 3, 6, 1, 2, 1, 1	/* basic system vars */
 #define LEN_SYSMIB 7
 
 /* basic groups under .squid */
 
-#define SQ_SYS  SQUIDMIB, 1		/* length is 8 */
+#define SQ_SYS  SQUIDMIB, 1	/* length is 8 */
 #define LEN_SQ_SYS LEN_SQUIDMIB+1
 #define SQ_CONF SQUIDMIB, 2
 #define LEN_SQ_CONF LEN_SQUIDMIB+1
@@ -51,17 +57,17 @@
 #define SQ_ACC  SQUIDMIB, 6
 #define LEN_SQ_ACC LEN_SQUIDMIB+1
 
-enum {	/* basic system mib info group */
-SYSMIB_START,
-VERSION_DESCR,
-VERSION_ID,
-UPTIME,
-SYSCONTACT,
-SYSYSNAME,
-SYSLOCATION,
-SYSSERVICES,
-SYSORLASTCHANGE,
-SYSMIB_END
+enum {				/* basic system mib info group */
+    SYSMIB_START,
+    VERSION_DESCR,
+    VERSION_ID,
+    UPTIME,
+    SYSCONTACT,
+    SYSYSNAME,
+    SYSLOCATION,
+    SYSSERVICES,
+    SYSORLASTCHANGE,
+    SYSMIB_END
 };
 
 /* cacheSystem group */
@@ -108,7 +114,7 @@ enum {
     MESH_END
 };
 
-enum {	/* cachePeerTable */
+enum {				/* cachePeerTable */
     MESH_PTBL_START,
     MESH_PTBL_NAME,
     MESH_PTBL_IP,
@@ -126,18 +132,18 @@ enum {	/* cachePeerTable */
     MESH_PTBL_END
 };
 
-enum { /* cacheClientTable */
-	MESH_CTBL_START,
-	MESH_CTBL_ADDR,
-	MESH_CTBL_HTREQ,
-	MESH_CTBL_HTBYTES,
-	MESH_CTBL_HTHITS,
-	MESH_CTBL_HTHITBYTES,
-	MESH_CTBL_ICPREQ,
-	MESH_CTBL_ICPBYTES,
-	MESH_CTBL_ICPHITS,
-	MESH_CTBL_ICPHITBYTES,
-	MESH_CTBL_END
+enum {				/* cacheClientTable */
+    MESH_CTBL_START,
+    MESH_CTBL_ADDR,
+    MESH_CTBL_HTREQ,
+    MESH_CTBL_HTBYTES,
+    MESH_CTBL_HTHITS,
+    MESH_CTBL_HTHITBYTES,
+    MESH_CTBL_ICPREQ,
+    MESH_CTBL_ICPBYTES,
+    MESH_CTBL_ICPHITS,
+    MESH_CTBL_ICPHITBYTES,
+    MESH_CTBL_END
 };
 
 /* cacheNetwork group */
@@ -198,7 +204,7 @@ enum {
     NETSTAT_OUTHRPUT
 };
 
-enum { 
+enum {
     PERF_START,
     PERF_SYS,
     PERF_PROTO,
@@ -275,19 +281,19 @@ enum {
     SYS_CONN_FDNUM,
     SYS_CONN_READ,
     SYS_CONN_WRITE,
-    SYS_CONN_ADDR, 
+    SYS_CONN_ADDR,
     SYS_CONN_NAME,
     SYS_CONN_PORT,
     SYS_CONN_END
 };
 
 /* First, we have a huge array of MIBs this agent knows about */
- 
+
 struct MIBListEntry {
-  oid            Name[9]; /* Change as appropriate */
-  snint           NameLen;
-  oid_GetFn     *GetFn;
-  oid_GetNextFn *GetNextFn;
+    oid Name[9];		/* Change as appropriate */
+    snint NameLen;
+    oid_GetFn *GetFn;
+    oid_GetNextFn *GetNextFn;
 };
 
 variable_list *snmp_basicFn(variable_list *, snint *);
@@ -303,5 +309,61 @@ variable_list *snmp_dnsFn(variable_list *, snint *);
 variable_list *snmp_ipcacheFn(variable_list *, snint *);
 variable_list *snmp_fqdncacheFn(variable_list *, snint *);
 
+extern int snmpInitAgentAuth();
+extern void snmpAgentParse(void *);
+extern int snmpDefaultAuth();
+extern int get_median_svc(int, int);
+extern void snmpAgentParseDone(int, void *);
+extern int meshCtblGetRowFn(oid *, oid *);
+extern int netdbGetRowFn(oid *, oid *);
+extern int fqdn_getMax();
+extern int ipcache_getMax();
+extern struct snmp_pdu *snmpAgentResponse(struct snmp_pdu *PDU);
+extern void snmpAclCheckStart(void *);
+extern struct snmp_session *Session;
+extern oid_ParseFn *genericGetNextFn(oid * Src, snint SrcLen, oid ** Dest, snint * DestLen,
+    oid * MIBRoot, int MIBRootLen, oid_GetRowFn * getRowFn, int tblen, oid * MIBTail,
+    oid_ParseFn * mygetFn, int MIBTailLen, int MIB_ACTION_INDEX);
+
+extern int oidcmp(oid * A, snint ALen, oid * B, snint BLen);
+extern int oidncmp(oid * A, snint ALen, oid * B, snint BLen, snint CompLen);
+extern oid *oiddup(oid * A, snint ALen);
+
+
+/* group handler definition */
+
+extern oid_ParseFn *basicGetFn(oid *, snint);
+extern oid_ParseFn *basicGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *sysGetFn(oid *, snint);
+extern oid_ParseFn *sysGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *sysFdGetFn(oid *, snint);
+extern oid_ParseFn *sysFdGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *sysConnGetFn(oid *, snint);
+extern oid_ParseFn *sysConnGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *confGetFn(oid *, snint);
+extern oid_ParseFn *confGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *confStGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *prfSysGetFn(oid *, snint);
+extern oid_ParseFn *prfSysGetFn(oid *, snint);
+extern oid_ParseFn *prfSysGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *prfProtoGetFn(oid *, snint);
+extern oid_ParseFn *prfProtoGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *netdbGetFn(oid *, snint);
+extern oid_ParseFn *netdbGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *dnsGetFn(oid *, snint);
+extern oid_ParseFn *dnsGetNextFn(oid *, snint, oid **, snint *);
+extern oid_ParseFn *meshGetFn(oid *, snint);
+extern oid_ParseFn *meshPtblGetNextFn(oid *, snint, oid **, snint *);
+extern int meshPtblGetRowFn(oid *, oid *);
+extern int sysConnGetRowFn(oid *, oid *);
+extern int meshCtblGetRowFn(oid *, oid *);
+extern int netdbGetRowFn(oid *, oid *);
+oid_ParseFn *meshCtblGetNextFn(oid *, snint, oid **, snint *);
+
+extern int fqdn_getMax();
+extern int ipcache_getMax();
+extern int fd_getMax();
+extern struct in_addr *gen_getMax();
+
 #endif
 #endif
@@ -31,7 +31,7 @@ SOFTWARE.
  */
 struct enum_list {
     struct enum_list *next;
-    int	value;
+    int value;
     char *label;
 };
 
@@ -46,7 +46,7 @@ struct snmp_mib_tree {
     u_int subid;		/* This node's integer subidentifier */
     int type;			/* This node's object type */
     struct enum_list *enums;	/* (optional) list of enumerated integers (otherwise NULL) */
-    void (*printer)();     /* Value printing function */
+    void (*printer) ();		/* Value printing function */
 };
 
 /* non-aggregate types for tree end nodes */
@@ -66,25 +66,24 @@ struct snmp_mib_tree {
 extern "C" {
 #endif
 
-void init_mib(char *);
-int read_objid(char *, oid *, int *);
-void  print_objid(oid *, int);
-void sprint_objid(char *, oid *, int);
-void print_variable(oid *, int, struct variable_list *);
-void sprint_variable(char *, oid *, int, struct variable_list *);
-void sprint_value(char *, oid *, int, struct variable_list *);
-void print_value(oid *, int, struct variable_list *);
+    void init_mib(char *);
+    int read_objid(char *, oid *, int *);
+    void print_objid(oid *, int);
+    void sprint_objid(char *, oid *, int);
+    void print_variable(oid *, int, struct variable_list *);
+    void sprint_variable(char *, oid *, int, struct variable_list *);
+    void sprint_value(char *, oid *, int, struct variable_list *);
+    void print_value(oid *, int, struct variable_list *);
 
-/*void print_variable_list(struct variable_list *);*/
-/*void print_variable_list_value(struct variable_list *);*/
-/*void print_type(struct variable_list *);*/
-void print_oid_nums(oid *, int);
+/*void print_variable_list(struct variable_list *); */
+/*void print_variable_list_value(struct variable_list *); */
+/*void print_type(struct variable_list *); */
+    void print_oid_nums(oid *, int);
 
-struct snmp_mib_tree *read_mib();
+    struct snmp_mib_tree *read_mib();
 
 #ifdef __cplusplus
 }
-#endif
-
 
-#endif /* _HAVE_PARSE_H_ */
+#endif
+#endif				/* _HAVE_PARSE_H_ */
@@ -26,12 +26,13 @@
  * 
  * Author: Ryan Troll <ryan+@andrew.cmu.edu>
  * 
- * $Id: snmp-mib.h,v 1.1 1998/02/22 11:48:42 kostas Exp $
+ * $Id: snmp-mib.h,v 1.2 1998/04/04 01:43:42 kostas Exp $
  * 
  ***************************************************************************/
 
-#include <asn1.h>       /* Need OID Definition */
-#include <snmp_vars.h>  /* Need variable_list */
-#include <mib.h>        /* Then the function definitions */
-
+#include <asn1.h>		/* Need OID Definition */
+#include <snmp_vars.h>		/* Need variable_list */
+#if 0
+#include <mib.h>		/* Then the function definitions */
+#endif
 #endif /* _SNMP_MIB_H_ */
@@ -27,7 +27,7 @@
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  * 
- * $Id: snmp.h,v 1.12 1998/02/24 22:46:14 kostas Exp $
+ * $Id: snmp.h,v 1.13 1998/04/04 01:43:42 kostas Exp $
  * 
  **********************************************************************/
 
@@ -41,9 +41,11 @@
 /* These come first */
 #include "asn1.h"
 #include "snmp_error.h"
+#if 0
 #include "mibii.h"
 #include "snmp_extra.h"
 #include "snmp_dump.h"
+#endif
 
 /* I didn't touch this */
 #include "snmp_session.h"
@@ -61,9 +63,11 @@
 /* Other stuff I didn't touch */
 #include "snmp_impl.h"
 #include "snmp_api.h"
+#if 0
 #include "snmp_client.h"
-#include "snmp-internal.h"
 #include "mib.h"
+#endif
+#include "snmp-internal.h"
 #include "parse.h"
 #include "snmp_compat.h"
 #include "snmp_debug.h"
@@ -51,22 +51,22 @@ SOFTWARE.
 extern "C" {
 #endif
 
-  /* Parse the buffer pointed to by arg3, of length arg4, into pdu arg2.
-   *
-   * Returns the community of the incoming PDU, or NULL
-   */
-u_char *snmp_parse(struct snmp_session *, struct snmp_pdu *,
-		   u_char *, int);
+    /* Parse the buffer pointed to by arg3, of length arg4, into pdu arg2.
+     *
+     * Returns the community of the incoming PDU, or NULL
+     */
+    u_char *snmp_parse(struct snmp_session *, struct snmp_pdu *,
+	u_char *, int);
 
 /* Encode pdu arg2 into buffer arg3.  arg4 contains the size of
  * the buffer.
  */
-int snmp_build(struct snmp_session *, struct snmp_pdu *,
-	       u_char *, int *);
+    int snmp_build(struct snmp_session *, struct snmp_pdu *,
+	u_char *, int *);
 
 /*
  * struct snmp_session *snmp_open(session)
- *	struct snmp_session *session;
+ *      struct snmp_session *session;
  * 
  * Sets up the session with the snmp_session information provided
  * by the user.  Then opens and binds the necessary UDP port.
@@ -75,7 +75,7 @@ int snmp_build(struct snmp_session *, struct snmp_pdu *,
  * and snmp_errno is set to the appropriate error code.
  */
 #if 0
-struct snmp_session *snmp_open(struct snmp_session *);
+    struct snmp_session *snmp_open(struct snmp_session *);
 
 /*
  * int snmp_close(session)
@@ -85,13 +85,13 @@ struct snmp_session *snmp_open(struct snmp_session *);
  * dequeues any pending requests, and closes any sockets allocated for
  * the session.  Returns 0 on error, 1 otherwise.
  */
-int snmp_close(struct snmp_session *);
+    int snmp_close(struct snmp_session *);
 
 
 /*
  * int snmp_send(session, pdu)
  *     struct snmp_session *session;
- *     struct snmp_pdu	*pdu;
+ *     struct snmp_pdu  *pdu;
  * 
  * Sends the input pdu on the session after calling snmp_build to create
  * a serialized packet.  If necessary, set some of the pdu data from the
@@ -101,7 +101,7 @@ int snmp_close(struct snmp_session *);
  * On any error, 0 is returned.
  * The pdu is freed by snmp_send() unless a failure occured.
  */
-int snmp_send(struct snmp_session *, struct snmp_pdu *);
+    int snmp_send(struct snmp_session *, struct snmp_pdu *);
 
 /*
  * void snmp_read(fdset)
@@ -113,7 +113,7 @@ int snmp_send(struct snmp_session *, struct snmp_pdu *);
  * is passed to the callback routine for that session.  If the callback
  * routine returns successfully, the pdu and it's request are deleted.
  */
-void snmp_read(fd_set *);
+    void snmp_read(fd_set *);
 
 
 /*
@@ -142,7 +142,7 @@ void snmp_read(fd_set *);
  *
  * snmp_select_info returns the number of open sockets.  (i.e. The number of sessions open)
  */
-int snmp_select_info(int *, fd_set *, struct timeval *, int *);
+    int snmp_select_info(int *, fd_set *, struct timeval *, int *);
 
 /*
  * void snmp_timeout();
@@ -155,7 +155,7 @@ int snmp_select_info(int *, fd_set *, struct timeval *, int *);
  * resent.  If there are no more retries available, the callback for the session
  * is used to alert the user of the timeout.
  */
-void snmp_timeout(void);
+    void snmp_timeout(void);
 
 
 /*
@@ -164,9 +164,9 @@ void snmp_timeout(void);
  * int callback(operation, session, reqid, pdu, magic)
  * int operation;
  * struct snmp_session *session;    The session authenticated under.
- * int reqid;			    The request id of this pdu (0 for TRAP)
- * struct snmp_pdu *pdu;	    The pdu information.
- * void *magic			    A link to the data for this routine.
+ * int reqid;                       The request id of this pdu (0 for TRAP)
+ * struct snmp_pdu *pdu;            The pdu information.
+ * void *magic                      A link to the data for this routine.
  *
  * Returns 1 if request was successful, 0 if it should be kept pending.
  * Any data in the pdu must be copied because it will be freed elsewhere.
@@ -177,11 +177,10 @@ void snmp_timeout(void);
 
 
 
-void snmp_api_stats(void *);
+    void snmp_api_stats(void *);
 #endif
 #ifdef __cplusplus
 }
-#endif
-
 
-#endif /* _SNMP_API_H_ */
+#endif
+#endif				/* _SNMP_API_H_ */
@@ -26,16 +26,16 @@
  * 
  * Author: Ryan Troll <ryan+@andrew.cmu.edu>
  * 
- * $Id: snmp_api_error.h,v 1.1 1998/02/22 11:48:43 kostas Exp $
+ * $Id: snmp_api_error.h,v 1.2 1998/04/04 01:43:43 kostas Exp $
  * 
  ***************************************************************************/
 
 /* Error return values */
 #define SNMPERR_GENERR		-1
-#define SNMPERR_BAD_LOCPORT	-2  /* local port was already in use */
+#define SNMPERR_BAD_LOCPORT	-2	/* local port was already in use */
 #define SNMPERR_BAD_ADDRESS	-3
 #define SNMPERR_BAD_SESSION	-4
-#define SNMPERR_TOO_LONG	-5  /* data too long for provided buffer */
+#define SNMPERR_TOO_LONG	-5	/* data too long for provided buffer */
 
 #define SNMPERR_ASN_ENCODE      -6
 #define SNMPERR_ASN_DECODE      -7
@@ -49,22 +49,22 @@
 #define SNMPERR_PACKET_ERR      -14
 #define SNMPERR_NO_RESPONSE     -15
 
-#define SNMPERR_LAST            -16 /* Last error message */
+#define SNMPERR_LAST            -16	/* Last error message */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* extern int snmp_errno */
 
-char *snmp_api_error(int);
-int   snmp_api_errno(void);
+    char *snmp_api_error(int);
+    int snmp_api_errno(void);
 
-char *api_errstring(int); /* Backwards compatibility */
-void snmp_set_api_error(int);
+    char *api_errstring(int);	/* Backwards compatibility */
+    void snmp_set_api_error(int);
 
 #ifdef __cplusplus
 }
-#endif
 
-#endif /* _SNMP_API_ERROR_H_ */
+#endif
+#endif				/* _SNMP_API_ERROR_H_ */
@@ -35,12 +35,12 @@ SOFTWARE.
  */
 struct request_list {
     struct request_list *next_request;
-    int  request_id;	/* request id */
-    int	    retries;	/* Number of retries */
-    u_int timeout;	/* length to wait for timeout */
-    struct timeval time; /* Time this request was made */
-    struct timeval expire;  /* time this request is due to expire */
-    struct snmp_pdu *pdu;   /* The pdu for this request (saved so it can be retransmitted */
+    int request_id;		/* request id */
+    int retries;		/* Number of retries */
+    u_int timeout;		/* length to wait for timeout */
+    struct timeval time;	/* Time this request was made */
+    struct timeval expire;	/* time this request is due to expire */
+    struct snmp_pdu *pdu;	/* The pdu for this request (saved so it can be retransmitted */
 };
 
 /*
@@ -53,9 +53,9 @@ struct session_list {
 };
 
 struct snmp_internal_session {
-    int	    sd;		/* socket descriptor for this connection */
-    ipaddr  addr;	/* address of connected peer */
-    struct request_list *requests;/* Info about outstanding requests */
+    int sd;			/* socket descriptor for this connection */
+    ipaddr addr;		/* address of connected peer */
+    struct request_list *requests;	/* Info about outstanding requests */
 };
 
 /* Define these here, as they aren't defined normall under
@@ -82,12 +82,12 @@ struct snmp_internal_session {
 extern "C" {
 #endif
 
-  int snmp_get_socket_session(struct snmp_session *session_);
-  int snmp_select_info_session(struct snmp_session *session_, struct timeval* timeout);
-  int snmp_timeout_session(struct snmp_session *sp_);
+    int snmp_get_socket_session(struct snmp_session *session_);
+    int snmp_select_info_session(struct snmp_session *session_, struct timeval *timeout);
+    int snmp_timeout_session(struct snmp_session *sp_);
 
 #ifdef __cplusplus
 }
-#endif
 
-#endif /* _SNMP_API_UTIL_H_ */
+#endif
+#endif				/* _SNMP_API_UTIL_H_ */
@@ -26,19 +26,19 @@
  * 
  * Author: Ryan Troll <ryan+@andrew.cmu.edu>
  * 
- * $Id: snmp_coexist.h,v 1.1 1998/02/22 11:48:45 kostas Exp $
+ * $Id: snmp_coexist.h,v 1.2 1998/04/04 01:43:44 kostas Exp $
  * 
  **********************************************************************/
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-int snmp_coexist_V2toV1(struct snmp_pdu *);
-int snmp_coexist_V1toV2(struct snmp_pdu *);
+    int snmp_coexist_V2toV1(struct snmp_pdu *);
+    int snmp_coexist_V1toV2(struct snmp_pdu *);
 
 #ifdef __cplusplus
 }
-#endif
 
-#endif /* _SNMP_COEXISTANCE_H_ */
+#endif
+#endif				/* _SNMP_COEXISTANCE_H_ */
@@ -2,10 +2,9 @@
 #define SNMP_DEBUG_H
 
 #ifdef __STDC__
-extern void snmplib_debug(int,char *,...);
+extern void snmplib_debug(int, char *,...);
 #else
 extern void snmplib_debug(va_alist);
 #endif
 
 #endif
-
@@ -24,7 +24,7 @@
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  * 
- * $Id: snmp_error.h,v 1.1 1998/02/22 11:48:46 kostas Exp $
+ * $Id: snmp_error.h,v 1.2 1998/04/04 01:43:46 kostas Exp $
  * 
  **********************************************************************/
 
@@ -59,10 +59,10 @@
 extern "C" {
 #endif
 
-  char *snmp_errstring(int);
+    char *snmp_errstring(int);
 
 #ifdef __cplusplus
 }
-#endif
 
-#endif /* _SNMP_ERROR_H_ */
+#endif
+#endif				/* _SNMP_ERROR_H_ */
@@ -70,9 +70,9 @@ SOFTWARE.
 #define SNMP_COMMIT      2
 #define SNMP_FREE        3
 
-#define RONLY	0xAAAA	/* read access for everyone */
-#define RWRITE	0xAABA	/* add write access for community private */
-#define NOACCESS 0x0000	/* no access for anybody */
+#define RONLY	0xAAAA		/* read access for everyone */
+#define RWRITE	0xAABA		/* add write access for community private */
+#define NOACCESS 0x0000		/* no access for anybody */
 
 #ifndef INTEGER
 #define INTEGER	    ASN_INTEGER
@@ -82,15 +82,15 @@ SOFTWARE.
 #endif
 
 struct trapVar {
-    oid	    *varName;
-    int	    varNameLen;
-    u_char  varType;
-    int	    varLen;
-    u_char  *varVal;
-    struct trapVar *next;  
+    oid *varName;
+    int varNameLen;
+    u_char varType;
+    int varLen;
+    u_char *varVal;
+    struct trapVar *next;
 };
 
-/* from snmp.c*/
-extern u_char	sid[];	/* size SID_MAX_LEN */
+/* from snmp.c */
+extern u_char sid[];		/* size SID_MAX_LEN */
 
 #endif /* _SNMP_IMPL_H_ */
@@ -26,24 +26,24 @@
  * 
  * Author: Ryan Troll <ryan+@andrew.cmu.edu>
  * 
- * $Id: snmp_msg.h,v 1.1 1998/02/22 11:48:47 kostas Exp $
+ * $Id: snmp_msg.h,v 1.2 1998/04/04 01:43:48 kostas Exp $
  * 
  **********************************************************************/
 
-#define SNMP_VERSION_1	    0 /* RFC 1157 */
-#define SNMP_VERSION_2	    1 /* RFC 1901 */
+#define SNMP_VERSION_1	    0	/* RFC 1157 */
+#define SNMP_VERSION_2	    1	/* RFC 1901 */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-u_char *snmp_msg_Encode(u_char *, int *, u_char *, 
-			int, int, struct snmp_pdu *);
-u_char *snmp_msg_Decode(u_char *, int *, u_char *, 
-			int *, int *, struct snmp_pdu *);
+    u_char *snmp_msg_Encode(u_char *, int *, u_char *,
+	int, int, struct snmp_pdu *);
+    u_char *snmp_msg_Decode(u_char *, int *, u_char *,
+	int *, int *, struct snmp_pdu *);
 
 #ifdef __cplusplus
 }
-#endif
 
-#endif /* _SNMP_MSG_H_ */
+#endif
+#endif				/* _SNMP_MSG_H_ */
@@ -1,3 +1,4 @@
+
 /* -*- c++ -*- */
 #ifndef _SNMP_PDU_H_
 #define _SNMP_PDU_H_
@@ -26,98 +27,89 @@
  * 
  * Author: Ryan Troll <ryan+@andrew.cmu.edu>
  * 
- * $Id: snmp_pdu.h,v 1.1 1998/02/22 11:48:48 kostas Exp $
+ * $Id: snmp_pdu.h,v 1.2 1998/04/04 01:43:49 kostas Exp $
  * 
  **********************************************************************/
 
-typedef struct sockaddr_in  ipaddr;
+typedef struct sockaddr_in ipaddr;
 
 /* An SNMP PDU */
 struct snmp_pdu {
-  int command;         /* Type of this PDU */
-  ipaddr  address;     /* Address of peer */
-
-  int  reqid;	       /* Integer32: Request id */
-  int  errstat;       /* INTEGER:   Error status */
-  int  errindex;      /* INTEGER:   Error index */
-
-  /* SNMPv2 Bulk Request */
-  int non_repeaters;   /* INTEGER: */
-  int max_repetitions; /* INTEGER: */
-
-  struct variable_list *variables; /* Variable Bindings */
-
-  /* Trap information */
-  oid	    *enterprise;       /* System OID */
-  int	    enterprise_length;
-  ipaddr  agent_addr;	       /* address of object generating trap */
-  int	    trap_type;	       /* generic trap type */
-  int	    specific_type;     /* specific type */
-  u_int  time;	               /* Uptime */
+    int command;		/* Type of this PDU */
+    ipaddr address;		/* Address of peer */
+
+    int reqid;			/* Integer32: Request id */
+    int errstat;		/* INTEGER:   Error status */
+    int errindex;		/* INTEGER:   Error index */
+
+    /* SNMPv2 Bulk Request */
+    int non_repeaters;		/* INTEGER: */
+    int max_repetitions;	/* INTEGER: */
+
+    struct variable_list *variables;	/* Variable Bindings */
+
+    /* Trap information */
+    oid *enterprise;		/* System OID */
+    int enterprise_length;
+    ipaddr agent_addr;		/* address of object generating trap */
+    int trap_type;		/* generic trap type */
+    int specific_type;		/* specific type */
+    u_int time;			/* Uptime */
 };
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-  struct snmp_pdu *snmp_pdu_create(int);
-  struct snmp_pdu *snmp_pdu_clone(struct snmp_pdu *);
-  struct snmp_pdu *snmp_pdu_fix(struct snmp_pdu *, int);
-  struct snmp_pdu *snmp_fix_pdu(struct snmp_pdu *, int);
-  void snmp_free_pdu(struct snmp_pdu *);
-  void snmp_pdu_free(struct snmp_pdu *);
+    struct snmp_pdu *snmp_pdu_create(int);
+    struct snmp_pdu *snmp_pdu_clone(struct snmp_pdu *);
+    struct snmp_pdu *snmp_pdu_fix(struct snmp_pdu *, int);
+    struct snmp_pdu *snmp_fix_pdu(struct snmp_pdu *, int);
+    void snmp_free_pdu(struct snmp_pdu *);
+    void snmp_pdu_free(struct snmp_pdu *);
 
-  u_char *snmp_pdu_encode(u_char *, int *, struct snmp_pdu *);
-  u_char *snmp_pdu_decode(u_char *, int *, struct snmp_pdu *);
-  char *snmp_pdu_type(struct snmp_pdu *);
+    u_char *snmp_pdu_encode(u_char *, int *, struct snmp_pdu *);
+    u_char *snmp_pdu_decode(u_char *, int *, struct snmp_pdu *);
+    char *snmp_pdu_type(struct snmp_pdu *);
 
-  /* Add a NULL Variable to a PDU */
-  void snmp_add_null_var(struct snmp_pdu *, oid *, int);
+    /* Add a NULL Variable to a PDU */
+    void snmp_add_null_var(struct snmp_pdu *, oid *, int);
 
 #ifdef __cplusplus
 }
-#endif
-
-/*
- * RFC 1905: Protocol Operations for SNMPv2
- *
- * RFC 1157: A Simple Network Management Protocol (SNMP)
- *
- * PDU Types
- */
 
+#endif				/*
+				 * * RFC 1905: Protocol Operations for SNMPv2
+				 * *
+				 * * RFC 1157: A Simple Network Management Protocol (SNMP)
+				 * *
+				 * * PDU Types
+				 */
 #define SNMP_PDU_GET	    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
 #define SNMP_PDU_GETNEXT    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
 #define SNMP_PDU_RESPONSE   (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
 #define SNMP_PDU_SET        (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
-#define TRP_REQ_MSG	    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4) /*Obsolete*/
+#define TRP_REQ_MSG	    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)	/*Obsolete */
 #define SNMP_PDU_GETBULK    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
 #define SNMP_PDU_INFORM     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
 #define SNMP_PDU_V2TRAP     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)
 #define SNMP_PDU_REPORT     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x8)
-
-#define MAX_BINDINGS 2147483647
-
-/* PDU Defaults */
+#define MAX_BINDINGS 2147483647	/* PDU Defaults */
 #define SNMP_DEFAULT_ERRSTAT	    -1
 #define SNMP_DEFAULT_ERRINDEX	    -1
 #define SNMP_DEFAULT_ADDRESS	    0
-#define SNMP_DEFAULT_REQID	    0
-
-/*
- * RFC 1907: Management Information Base for SNMPv2
- *
- * RFC 1157: A Simple Network Management Protocol (SNMP)
- *
- * Trap Types
- */
-
+#define SNMP_DEFAULT_REQID	    0	/*
+					 * * RFC 1907: Management Information Base for SNMPv2
+					 * *
+					 * * RFC 1157: A Simple Network Management Protocol (SNMP)
+					 * *
+					 * * Trap Types
+					 */
 #define SNMP_TRAP_COLDSTART             (0x0)
 #define SNMP_TRAP_WARMSTART             (0x1)
 #define SNMP_TRAP_LINKDOWN              (0x2)
 #define SNMP_TRAP_LINKUP                (0x3)
 #define SNMP_TRAP_AUTHENTICATIONFAILURE (0x4)
 #define SNMP_TRAP_EGPNEIGHBORLOSS       (0x5)
 #define SNMP_TRAP_ENTERPRISESPECIFIC    (0x6)
-
-#endif /* _SNMP_PDU_H_ */
+#endif				/* _SNMP_PDU_H_ */
@@ -24,28 +24,28 @@
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  * 
- * $Id: snmp_session.h,v 1.1 1998/02/22 11:48:49 kostas Exp $
+ * $Id: snmp_session.h,v 1.2 1998/04/04 01:43:50 kostas Exp $
  * 
  **********************************************************************/
 
 struct snmp_session {
-  int Version; /* SNMP Version for this session */
+    int Version;		/* SNMP Version for this session */
 
 
-    u_char  *community;	/* community for outgoing requests. */
-    int	    community_len;  /* Length of community name. */
-    int	    retries;	/* Number of retries before timeout. */
-    int    timeout;    /* Number of uS until first timeout, then exponential backoff */
-    char    *peername;	/* Domain name or dotted IP address of default peer */
-    u_short remote_port;/* UDP port number of peer. */
-    u_short local_port; /* My UDP port number, 0 for default, picked randomly */
-  /* This isn't used, but is here so that libraries compiled with this
-   * in place still work.
-   */
-    u_char    *(*authenticator)();
-    int	    (*callback)();  /* Function to interpret incoming data */
+    u_char *community;		/* community for outgoing requests. */
+    int community_len;		/* Length of community name. */
+    int retries;		/* Number of retries before timeout. */
+    int timeout;		/* Number of uS until first timeout, then exponential backoff */
+    char *peername;		/* Domain name or dotted IP address of default peer */
+    u_short remote_port;	/* UDP port number of peer. */
+    u_short local_port;		/* My UDP port number, 0 for default, picked randomly */
+    /* This isn't used, but is here so that libraries compiled with this
+     * in place still work.
+     */
+    u_char *(*authenticator) ();
+    int (*callback) ();		/* Function to interpret incoming data */
     /* Pointer to data that the callback function may consider important */
-    void    *callback_magic;
+    void *callback_magic;
 };
 
 #define RECEIVED_MESSAGE   1
@@ -26,68 +26,58 @@
  * 
  * Author: Ryan Troll <ryan+@andrew.cmu.edu>
  * 
- * $Id: snmp_vars.h,v 1.6 1998/02/22 11:48:49 kostas Exp $
+ * $Id: snmp_vars.h,v 1.7 1998/04/04 01:43:51 kostas Exp $
  * 
  **********************************************************************/
 
 struct variable_list {
-    struct variable_list *next_variable;    /* NULL for last variable */
-    oid	    *name;  /* Object identifier of variable */
-    int	    name_length;    /* number of subid's in name */
-    u_char  type;   /* ASN type of variable */
-    union { /* value of variable */
-	int	*integer;
-	u_char	*string;
-	oid	*objid;
+    struct variable_list *next_variable;	/* NULL for last variable */
+    oid *name;			/* Object identifier of variable */
+    int name_length;		/* number of subid's in name */
+    u_char type;		/* ASN type of variable */
+    union {			/* value of variable */
+	int *integer;
+	u_char *string;
+	oid *objid;
     } val;
-    int	    val_len;
+    int val_len;
 };
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-  struct variable_list *snmp_var_new(oid *, int);
-  struct variable_list *snmp_var_clone(struct variable_list *);
-  void snmp_var_free(struct variable_list *);
+    struct variable_list *snmp_var_new(oid *, int);
+    struct variable_list *snmp_var_clone(struct variable_list *);
+    void snmp_var_free(struct variable_list *);
 
-  u_char *snmp_var_EncodeVarBind(u_char *, int *, struct variable_list *, int);
-  u_char *snmp_var_DecodeVarBind(u_char *, int *, struct variable_list **, int);
+    u_char *snmp_var_EncodeVarBind(u_char *, int *, struct variable_list *, int);
+    u_char *snmp_var_DecodeVarBind(u_char *, int *, struct variable_list **, int);
 
 #ifdef __cplusplus
 }
-#endif
-
-#define MAX_NAME_LEN	64  /* number of subid's in a objid */
-
-/*
- * RFC 1902: Structure of Management Information for SNMPv2
- *
- * Defined Types
- *
- */
 
+#endif
+#define MAX_NAME_LEN	64	/* number of subid's in a objid *//*      *RFC 1902:Structure of Management Information for SNMPv2
+*
+      *Defined Types
+*
+      */
 #define SMI_INTEGER     ASN_INTEGER
 #define SMI_STRING      ASN_OCTET_STR
 #define SMI_OBJID       ASN_OBJECT_ID
 #define SMI_NULLOBJ     ASN_NULL
-#define SMI_IPADDRESS  (ASN_APPLICATION | 0) /* OCTET STRING, net byte order */
-#define SMI_COUNTER32  (ASN_APPLICATION | 1) /* INTEGER */
-#define SMI_GAUGE32    (ASN_APPLICATION | 2) /* INTEGER */
-# define SMI_UNSIGNED32 SMI_GAUGE32
-#define SMI_TIMETICKS  (ASN_APPLICATION | 3) /* INTEGER */
-#define SMI_OPAQUE     (ASN_APPLICATION | 4) /* OCTET STRING */
-
-#define SMI_COUNTER64  (ASN_APPLICATION | 6) /* INTEGER */
-
+#define SMI_IPADDRESS  (ASN_APPLICATION | 0)	/* OCTET STRING, net byte order */
+#define SMI_COUNTER32  (ASN_APPLICATION | 1)	/* INTEGER */
+#define SMI_GAUGE32    (ASN_APPLICATION | 2)	/* INTEGER */
+#define SMI_UNSIGNED32 SMI_GAUGE32
+#define SMI_TIMETICKS  (ASN_APPLICATION | 3)	/* INTEGER */
+#define SMI_OPAQUE     (ASN_APPLICATION | 4)	/* OCTET STRING */
+#define SMI_COUNTER64  (ASN_APPLICATION | 6)	/* INTEGER */
 #define SMI_NOSUCHOBJECT   (ASN_CONTEXT | ASN_PRIMITIVE | 0x0)
 #define SMI_NOSUCHINSTANCE (ASN_CONTEXT | ASN_PRIMITIVE | 0x1)
 #define SMI_ENDOFMIBVIEW   (ASN_CONTEXT | ASN_PRIMITIVE | 0x2)
-
 typedef struct variable variable;
 typedef struct variable_list variable_list;
 
-typedef int SNMPWM(int, u_char *, u_char, int, u_char *, oid *, int);
-typedef u_char *SNMPFV(variable *, oid *, int *, int, int *, SNMPWM **);
-
 #endif /* _SNMP_VARS_H_ */
@@ -1,4 +1,5 @@
 
+
 /* Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
  * This file is part of the GNU C Library.
  * The GNU C Library is free software; you can redistribute it and/or
@@ -17,16 +17,16 @@ ALIB		= libsnmp.a
 
 TARG		= libsnmp.a
 
-CSRCS		= asn1.c parse.c snmp_dump.c snmp_vars.c \
+CSRCS		= asn1.c parse.c snmp_vars.c \
 		  coexistance.c snmp_api.c snmp_error.c  \
 		  mib.c snmp_api_error.c   \
-		  mibii.c snmp_api_util.c snmp_msg.c \
+		  snmp_msg.c \
 		  snmp_pdu.c  snmplib_debug.c
 
-OBJS		= asn1.o parse.o snmp_dump.o snmp_vars.o \
+OBJS		= asn1.o parse.o snmp_vars.o \
                   coexistance.o snmp_api.o snmp_error.o  \
                   mib.o snmp_api_error.o   \
-                  mibii.o snmp_api_util.o snmp_msg.o \
+                  snmp_msg.o \
                   snmp_pdu.o snmplib_debug.o
 
 CC		= @CC@
@@ -35,7 +35,6 @@ RANLIB		= @RANLIB@
 AC_CFLAGS	= @CFLAGS@
 DEFS		= -DSQUID_SNMP=1
 INCLUDE		= -I../include -I$(top_srcdir)/include
-MIBDEFS		= -DMIBFILEPATH=\"$(prefix)/lib\"
 CFLAGS		= $(AC_CFLAGS) $(DEFS) $(INCLUDE)
 
 
@@ -50,8 +49,6 @@ $(ALIB):    ${OBJS}
 ##
 ## special rule to include -DMIBFILEPATH=...:
 ##
-mib.o:		mib.c
-	$(CC) $(CFLAGS) $(MIBDEFS)	-c $(srcdir)/mib.c 
 
 distclean: clean
 	-rm -f Makefile
@@ -84,14 +84,15 @@
 #include "snmp_api_error.h"
 
 
-u_char *asn_build_header(u_char *data,       /* IN - ptr to start of object */
-			 int    *datalength, /* IN/OUT - # of valid bytes */
-                                             /*          left in buffer */
-			 u_char  type,       /* IN - ASN type of object */
-			 int     length)     /* IN - length of object */
-{
-  /* Truth is 0 'cause we don't know yet */
-  return(asn_build_header_with_truth(data, datalength, type, length, 0));
+u_char *
+asn_build_header(u_char * data,	/* IN - ptr to start of object */
+    int *datalength,		/* IN/OUT - # of valid bytes */
+					     /*          left in buffer */
+    u_char type,		/* IN - ASN type of object */
+    int length)
+{				/* IN - length of object */
+    /* Truth is 0 'cause we don't know yet */
+    return (asn_build_header_with_truth(data, datalength, type, length, 0));
 }
 
 
@@ -105,61 +106,59 @@ u_char *asn_build_header(u_char *data,       /* IN - ptr to start of object */
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_int(u_char *data, int *datalength, 
-		      u_char *type, int *intp, int intsize)
+u_char *
+asn_parse_int(u_char * data, int *datalength,
+    u_char * type, int *intp, int intsize)
   /*    u_char *data;        IN     - pointer to start of object */
   /*    int    *datalength;  IN/OUT - # of valid bytes left in buffer */
   /*    u_char *type;        OUT    - asn type of object */
   /*    int   *intp;         IN/OUT - pointer to start of output buffer */
   /*    int     intsize;     IN     - size of output buffer */
 {
-  /*
-   * ASN.1 integer ::= 0x02 asnlength byte {byte}*
-   */
-  u_char *bufp = data;
-  u_int   asn_length;
-  int   value = 0;
-  
-  /* Room to store int? */
-  if (intsize != sizeof (int)) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  /* Type */
-  *type = *bufp++;
-
-  /* Extract length */
-  bufp = asn_parse_length(bufp, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  /* Make sure the entire int is in the buffer */
-  if (asn_length + (bufp - data) > *datalength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  /* Can we store this int? */
-  if (asn_length > intsize) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  /* Remaining data */
-  *datalength -= (int)asn_length + (bufp - data);
-
-  /* Is the int negative? */
-  if (*bufp & 0x80)
-    value = -1; /* integer is negative */
-
-  /* Extract the bytes */
-  while(asn_length--)
-    value = (value << 8) | *bufp++;
-
-  /* That's it! */
-  *intp = value;
-  return(bufp);
+    /*
+     * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+     */
+    u_char *bufp = data;
+    u_int asn_length;
+    int value = 0;
+
+    /* Room to store int? */
+    if (intsize != sizeof(int)) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    /* Type */
+    *type = *bufp++;
+
+    /* Extract length */
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    /* Make sure the entire int is in the buffer */
+    if (asn_length + (bufp - data) > *datalength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    /* Can we store this int? */
+    if (asn_length > intsize) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    /* Remaining data */
+    *datalength -= (int) asn_length + (bufp - data);
+
+    /* Is the int negative? */
+    if (*bufp & 0x80)
+	value = -1;		/* integer is negative */
+
+    /* Extract the bytes */
+    while (asn_length--)
+	value = (value << 8) | *bufp++;
+
+    /* That's it! */
+    *intp = value;
+    return (bufp);
 }
 
 /*
@@ -172,62 +171,60 @@ u_char *asn_parse_int(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_unsigned_int(u_char *data, int *datalength, 
-			       u_char *type, u_int *intp, int intsize)
+u_char *
+asn_parse_unsigned_int(u_char * data, int *datalength,
+    u_char * type, u_int * intp, int intsize)
   /*    u_char *data;          IN     - pointer to start of object */
   /*    int    *datalength;    IN/OUT - # of valid bytes left in buffer */
   /*    u_char *type;          OUT    - asn type of object */
   /*    u_int *intp;           IN/OUT - pointer to start of output buffer */
   /*    int     intsize;       IN     - size of output buffer */
 {
-  /*
-   * ASN.1 integer ::= 0x02 asnlength byte {byte}*
-   */
-  u_char *bufp = data;
-  u_int  asn_length;
-  int    value = 0;
-  
-  /* Room to store int? */
-  if (intsize != sizeof (int)) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  /* Type */
-  *type = *bufp++;
-
-  /* Extract length */
-  bufp = asn_parse_length(bufp, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  /* Make sure the entire int is in the buffer */
-  if (asn_length + (bufp - data) > *datalength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  /* Can we store this int? */
-  if ((asn_length > (intsize + 1)) ||
-      ((asn_length == intsize + 1) && *bufp != 0x00)) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  /* Remaining data */
-  *datalength -= (int)asn_length + (bufp - data);
-
-  /* Is the int negative? */
-  if (*bufp & 0x80)
-    value = -1; /* integer is negative */
-
-  /* Extract the bytes */
-  while(asn_length--)
-    value = (value << 8) | *bufp++;
-
-  /* That's it! */
-  *intp = value;
-  return(bufp);
+    /*
+     * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+     */
+    u_char *bufp = data;
+    u_int asn_length;
+    int value = 0;
+
+    /* Room to store int? */
+    if (intsize != sizeof(int)) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    /* Type */
+    *type = *bufp++;
+
+    /* Extract length */
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    /* Make sure the entire int is in the buffer */
+    if (asn_length + (bufp - data) > *datalength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    /* Can we store this int? */
+    if ((asn_length > (intsize + 1)) ||
+	((asn_length == intsize + 1) && *bufp != 0x00)) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    /* Remaining data */
+    *datalength -= (int) asn_length + (bufp - data);
+
+    /* Is the int negative? */
+    if (*bufp & 0x80)
+	value = -1;		/* integer is negative */
+
+    /* Extract the bytes */
+    while (asn_length--)
+	value = (value << 8) | *bufp++;
+
+    /* That's it! */
+    *intp = value;
+    return (bufp);
 }
 
 /*
@@ -240,61 +237,60 @@ u_char *asn_parse_unsigned_int(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_build_int(u_char *data, int *datalength, 
-		      u_char type, int *intp, int intsize)
+u_char *
+asn_build_int(u_char * data, int *datalength,
+    u_char type, int *intp, int intsize)
   /*     u_char *data;         IN - pointer to start of output buffer */
   /*     int    *datalength;   IN/OUT - # of valid bytes left in buffer */
   /*     u_char  type;         IN - asn type of object */
   /*     int   *intp;          IN - pointer to start of integer */
   /*     int    intsize;       IN - size of *intp */
 {
-  /*
-   * ASN.1 integer ::= 0x02 asnlength byte {byte}*
-   */
-  int integer;
-  u_int mask;
-    
-  if (intsize != sizeof (int)) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  integer = *intp;
-
-  /*
-   * Truncate "unnecessary" bytes off of the most significant end of this
-   * 2's complement integer.  There should be no sequence of 9
-   * consecutive 1's or 0's at the most significant end of the
-   * integer.
-   */
-  mask = (u_int)0x1FF << ((8 * (sizeof(int) - 1)) - 1);
-  /* mask is 0xFF800000 on a big-endian machine */
-
-  while((((integer & mask) == 0) || ((integer & mask) == mask))
+    /*
+     * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+     */
+    int integer;
+    u_int mask;
+
+    if (intsize != sizeof(int)) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    integer = *intp;
+
+    /*
+     * Truncate "unnecessary" bytes off of the most significant end of this
+     * 2's complement integer.  There should be no sequence of 9
+     * consecutive 1's or 0's at the most significant end of the
+     * integer.
+     */
+    mask = (u_int) 0x1FF << ((8 * (sizeof(int) - 1)) - 1);
+    /* mask is 0xFF800000 on a big-endian machine */
+
+    while ((((integer & mask) == 0) || ((integer & mask) == mask))
 	&& intsize > 1) {
-    intsize--;
-    integer <<= 8;
-  }
-
-  data = asn_build_header_with_truth(data, datalength, type, intsize, 1);
-  if (data == NULL)
-    return(NULL);
-
-  /* Enough room for what we just encoded? */
-  if (*datalength < intsize) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  /* Insert it */
-  *datalength -= intsize;
-  mask = (u_int)0xFF << (8 * (sizeof(int) - 1));
-  /* mask is 0xFF000000 on a big-endian machine */
-  while(intsize--) {
-    *data++ = (u_char)((integer & mask) >> (8 * (sizeof(int) - 1)));
-    integer <<= 8;
-  }
-  return(data);
+	intsize--;
+	integer <<= 8;
+    }
+
+    data = asn_build_header_with_truth(data, datalength, type, intsize, 1);
+    if (data == NULL)
+	return (NULL);
+
+    /* Enough room for what we just encoded? */
+    if (*datalength < intsize) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    /* Insert it */
+    *datalength -= intsize;
+    mask = (u_int) 0xFF << (8 * (sizeof(int) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    while (intsize--) {
+	*data++ = (u_char) ((integer & mask) >> (8 * (sizeof(int) - 1)));
+	integer <<= 8;
+    }
+    return (data);
 }
 
 /*
@@ -307,71 +303,68 @@ u_char *asn_build_int(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_build_unsigned_int(u_char *data, int *datalength, 
-			       u_char type, u_int *intp, int intsize)
+u_char *
+asn_build_unsigned_int(u_char * data, int *datalength,
+    u_char type, u_int * intp, int intsize)
   /*     u_char *data;         IN     - pointer to start of output buffer */
   /*     int    *datalength;   IN/OUT - # of valid bytes left in buffer */
   /*     u_char  type;         IN     - asn type of object */
   /*     u_int  *intp;         IN     - pointer to start of integer */
   /*     int     intsize;      IN     - size of *intp */
 {
-  /*
-   * ASN.1 integer ::= 0x02 asnlength byte {byte}*
-   */
-  u_int integer;
-  u_int mask;
-  int add_null_byte = 0;
-    
-  if (intsize != sizeof (int)) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  integer = *intp;
-  mask = (u_int)0xFF << (8 * (sizeof(int) - 1));
-  /* mask is 0xFF000000 on a big-endian machine */
-  if ((u_char)((integer & mask) >> (8 * (sizeof(int) - 1))) & 0x80) {
-    /* if MSB is set */
-    add_null_byte = 1;
-    intsize++;
-  }
-
-  /*
-   * Truncate "unnecessary" bytes off of the most significant end of
-   * this 2's complement integer. 
-   * There should be no sequence of 9 consecutive 1's or 0's at the
-   * most significant end of the integer.
-   */
-  mask = (u_int)0x1FF << ((8 * (sizeof(int) - 1)) - 1);
-  /* mask is 0xFF800000 on a big-endian machine */
-  while((((integer & mask) == 0)
-	 || ((integer & mask) == mask)) && intsize > 1) {
-    intsize--;
-    integer <<= 8;
-  }
-  
-  data = asn_build_header_with_truth(data, datalength, type, intsize, 1);
-  if (data == NULL)
-    return(NULL);
-
-  if (*datalength < intsize) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  *datalength -= intsize;
-  if (add_null_byte == 1) {
-    *data++ = '\0';
-    intsize--;
-  }
-  
-  mask = (u_int)0xFF << (8 * (sizeof(int) - 1));
-  /* mask is 0xFF000000 on a big-endian machine */
-  while(intsize--) {
-    *data++ = (u_char)((integer & mask) >> (8 * (sizeof(int) - 1)));
-    integer <<= 8;
-  }
-  return(data);
+    /*
+     * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+     */
+    u_int integer;
+    u_int mask;
+    int add_null_byte = 0;
+
+    if (intsize != sizeof(int)) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    integer = *intp;
+    mask = (u_int) 0xFF << (8 * (sizeof(int) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    if ((u_char) ((integer & mask) >> (8 * (sizeof(int) - 1))) & 0x80) {
+	/* if MSB is set */
+	add_null_byte = 1;
+	intsize++;
+    }
+    /*
+     * Truncate "unnecessary" bytes off of the most significant end of
+     * this 2's complement integer. 
+     * There should be no sequence of 9 consecutive 1's or 0's at the
+     * most significant end of the integer.
+     */
+    mask = (u_int) 0x1FF << ((8 * (sizeof(int) - 1)) - 1);
+    /* mask is 0xFF800000 on a big-endian machine */
+    while ((((integer & mask) == 0)
+	    || ((integer & mask) == mask)) && intsize > 1) {
+	intsize--;
+	integer <<= 8;
+    }
+
+    data = asn_build_header_with_truth(data, datalength, type, intsize, 1);
+    if (data == NULL)
+	return (NULL);
+
+    if (*datalength < intsize) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    *datalength -= intsize;
+    if (add_null_byte == 1) {
+	*data++ = '\0';
+	intsize--;
+    }
+    mask = (u_int) 0xFF << (8 * (sizeof(int) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    while (intsize--) {
+	*data++ = (u_char) ((integer & mask) >> (8 * (sizeof(int) - 1)));
+	integer <<= 8;
+    }
+    return (data);
 }
 
 /*
@@ -386,41 +379,40 @@ u_char *asn_build_unsigned_int(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_string(u_char *data, int *datalength, 
-			 u_char *type, u_char *string, int *strlength)
+u_char *
+asn_parse_string(u_char * data, int *datalength,
+    u_char * type, u_char * string, int *strlength)
   /*    u_char *data;       IN - pointer to start of object */
   /*    int    *datalength; IN/OUT - # of valid bytes left in buffer */
   /*    u_char *type;       OUT - asn type of object */
   /*    u_char *string;     IN/OUT - pointer to start of output buffer */
   /*    int    *strlength;  IN/OUT - size of output buffer */
 {
-  /*
-   * ASN.1 octet string ::= primstring | cmpdstring
-   * primstring ::= 0x04 asnlength byte {byte}*
-   * cmpdstring ::= 0x24 asnlength string {string}*
-   */
-  u_char *bufp = data;
-  u_int          asn_length;
-    
-  *type = *bufp++;
-  bufp = asn_parse_length(bufp, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  if (asn_length + (bufp - data) > *datalength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  if (asn_length > *strlength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  xmemcpy((char *)string, (char *)bufp, (int)asn_length);
-  *strlength = (int)asn_length;
-  *datalength -= (int)asn_length + (bufp - data);
-  return(bufp + asn_length);
+    /*
+     * ASN.1 octet string ::= primstring | cmpdstring
+     * primstring ::= 0x04 asnlength byte {byte}*
+     * cmpdstring ::= 0x24 asnlength string {string}*
+     */
+    u_char *bufp = data;
+    u_int asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    if (asn_length + (bufp - data) > *datalength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    if (asn_length > *strlength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    xmemcpy((char *) string, (char *) bufp, (int) asn_length);
+    *strlength = (int) asn_length;
+    *datalength -= (int) asn_length + (bufp - data);
+    return (bufp + asn_length);
 }
 
 /*
@@ -433,32 +425,32 @@ u_char *asn_parse_string(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_build_string(u_char *data, int *datalength, 
-			 u_char type, u_char *string, int strlength)
+u_char *
+asn_build_string(u_char * data, int *datalength,
+    u_char type, u_char * string, int strlength)
   /*    u_char *data;       IN - pointer to start of object */
   /*    int    *datalength; IN/OUT - # of valid bytes left in buf */
   /*    u_char  type;       IN - ASN type of string */
   /*    u_char *string;     IN - pointer to start of input buffer */
   /*    int     strlength;  IN - size of input buffer */
 {
-  /*
-   * ASN.1 octet string ::= primstring | cmpdstring
-   * primstring ::= 0x04 asnlength byte {byte}*
-   * cmpdstring ::= 0x24 asnlength string {string}*
-   * This code will never send a compound string.
-   */
-  data = asn_build_header_with_truth(data, datalength, type, strlength, 1);
-  if (data == NULL)
-    return(NULL);
-
-  if (*datalength < strlength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  xmemcpy((char *)data, (char *)string, strlength);
-  *datalength -= strlength;
-  return(data + strlength);
+    /*
+     * ASN.1 octet string ::= primstring | cmpdstring
+     * primstring ::= 0x04 asnlength byte {byte}*
+     * cmpdstring ::= 0x24 asnlength string {string}*
+     * This code will never send a compound string.
+     */
+    data = asn_build_header_with_truth(data, datalength, type, strlength, 1);
+    if (data == NULL)
+	return (NULL);
+
+    if (*datalength < strlength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    xmemcpy((char *) data, (char *) string, strlength);
+    *datalength -= strlength;
+    return (data + strlength);
 }
 
 
@@ -471,34 +463,33 @@ u_char *asn_build_string(u_char *data, int *datalength,
  *  Returns a pointer to the first byte of the contents of this object.
  *  Returns NULL on any error.
  */
-u_char *asn_parse_header(u_char *data, int *datalength, u_char *type)
+u_char *
+asn_parse_header(u_char * data, int *datalength, u_char * type)
   /*    u_char  *data;       IN - pointer to start of object */
   /*    int     *datalength; IN/OUT - # of valid bytes left in buffer */
   /*    u_char  *type;       OUT - ASN type of object */
 {
-  u_char *bufp = data;
-  int     header_len;
-  u_int  asn_length;
-    
-  /* this only works on data types < 30, i.e. no extension octets */
-  if (IS_EXTENSION_ID(*bufp)) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  *type = *bufp;
-  bufp = asn_parse_length(bufp + 1, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  header_len = bufp - data;
-  if (header_len + asn_length > *datalength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  *datalength = (int)asn_length;
-  return(bufp);
+    u_char *bufp = data;
+    int header_len;
+    u_int asn_length;
+
+    /* this only works on data types < 30, i.e. no extension octets */
+    if (IS_EXTENSION_ID(*bufp)) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    *type = *bufp;
+    bufp = asn_parse_length(bufp + 1, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    header_len = bufp - data;
+    if (header_len + asn_length > *datalength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    *datalength = (int) asn_length;
+    return (bufp);
 }
 
 /*
@@ -515,22 +506,22 @@ u_char *asn_parse_header(u_char *data, int *datalength, u_char *type)
  *  Returns NULL on any error.
  */
 
-u_char *asn_build_header_with_truth(u_char *data, int *datalength, 
-				    u_char type, int length, int truth)
+u_char *
+asn_build_header_with_truth(u_char * data, int *datalength,
+    u_char type, int length, int truth)
   /*    u_char *data;       IN - pointer to start of object */
   /*    int    *datalength; IN/OUT - # of valid bytes left in buffer */
   /*    u_char  type;       IN - ASN type of object */
   /*    int     length;     IN - length of object */
   /*    int     truth;      IN - Whether length is truth */
 {
-  if (*datalength < 1) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  *data++ = type;
-  (*datalength)--;
-  return(asn_build_length(data, datalength, length, truth));
+    if (*datalength < 1) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    *data++ = type;
+    (*datalength)--;
+    return (asn_build_length(data, datalength, length, truth));
 }
 
 #if 0
@@ -547,25 +538,25 @@ u_char *asn_build_header_with_truth(u_char *data, int *datalength,
  *  Returns a pointer to the first byte of the contents of this object.
  *  Returns NULL on any error.
  */
-u_char *asn_build_sequence(u_char *data, int *datalength, 
-				  u_char type, int length)
+u_char *
+asn_build_sequence(u_char * data, int *datalength,
+    u_char type, int length)
   /*    u_char *data;       IN - pointer to start of object */
   /*    int    *datalength; IN/OUT - # of valid bytes left in buffer */
   /*    u_char  type;       IN - ASN type of object */
   /*    int     length;     IN - length of object */
 {
-  *datalength -= 4;
-  if (*datalength < 0) {
-    *datalength += 4;   /* fix up before punting */
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  *data++ = type;
-  *data++ = (u_char)(0x02 | ASN_LONG_LEN);
-  *data++ = (u_char)((length >> 8) & 0xFF);
-  *data++ = (u_char)(length & 0xFF);
-  return(data);
+    *datalength -= 4;
+    if (*datalength < 0) {
+	*datalength += 4;	/* fix up before punting */
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    *data++ = type;
+    *data++ = (u_char) (0x02 | ASN_LONG_LEN);
+    *data++ = (u_char) ((length >> 8) & 0xFF);
+    *data++ = (u_char) (length & 0xFF);
+    return (data);
 }
 #endif
 
@@ -577,92 +568,91 @@ u_char *asn_build_sequence(u_char *data, int *datalength,
  *  field (aka: the start of the data field).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_length(u_char *data, u_int *length)
+u_char *
+asn_parse_length(u_char * data, u_int * length)
   /*    u_char  *data;   IN - pointer to start of length field */
   /*    u_int  *length; OUT - value of length field */
 {
-  u_char lengthbyte = *data;
-    
-  if (lengthbyte & ASN_LONG_LEN) {
-    lengthbyte &= ~ASN_LONG_LEN;    /* turn MSb off */
+    u_char lengthbyte = *data;
 
-    if (lengthbyte == 0) {
-      snmp_set_api_error(SNMPERR_ASN_DECODE);
-      return(NULL);
-    }
+    if (lengthbyte & ASN_LONG_LEN) {
+	lengthbyte &= ~ASN_LONG_LEN;	/* turn MSb off */
 
-    if (lengthbyte > sizeof(int)) {
-      snmp_set_api_error(SNMPERR_ASN_DECODE);
-      return(NULL);
-    }
-
-    *length = (u_int)0;
-    xmemcpy((char *)(length), (char *)data + 1, (int)lengthbyte);
-    *length = ntohl(*length);
-    *length >>= (8 * ((sizeof *length) - lengthbyte));
-    return(data + lengthbyte + 1);
-
-  }
+	if (lengthbyte == 0) {
+	    snmp_set_api_error(SNMPERR_ASN_DECODE);
+	    return (NULL);
+	}
+	if (lengthbyte > sizeof(int)) {
+	    snmp_set_api_error(SNMPERR_ASN_DECODE);
+	    return (NULL);
+	}
+	*length = (u_int) 0;
+	xmemcpy((char *) (length), (char *) data + 1, (int) lengthbyte);
+	*length = ntohl(*length);
+	*length >>= (8 * ((sizeof *length) - lengthbyte));
+	return (data + lengthbyte + 1);
 
-  /* short asnlength */
+    }
+    /* short asnlength */
 
-  *length = (int)lengthbyte;
-  return(data + 1);
+    *length = (int) lengthbyte;
+    return (data + 1);
 }
 
 
-u_char *asn_build_length(u_char *data, int *datalength, 
-			 int length, int truth)
+u_char *
+asn_build_length(u_char * data, int *datalength,
+    int length, int truth)
   /*   u_char *data;       IN - pointer to start of object */
   /*   int    *datalength; IN/OUT - # of valid bytes left in buf */
   /*   int     length;     IN - length of object */
   /*   int     truth;      IN - If 1, this is the true len. */
 {
-  u_char    *start_data = data;
-
-  if (truth) {
-
-    /* no indefinite lengths sent */
-    if (length < 0x80) {
-      if (*datalength < 1) {
-	snmp_set_api_error(SNMPERR_ASN_ENCODE);
-	return(NULL);
-      }
-      *data++ = (u_char)length;
-
-    } else if (length <= 0xFF) {
-      if (*datalength < 2) {
-	snmp_set_api_error(SNMPERR_ASN_ENCODE);
-	return(NULL);
-      }
-      *data++ = (u_char)(0x01 | ASN_LONG_LEN);
-      *data++ = (u_char)length;
-    } else { /* 0xFF < length <= 0xFFFF */
-      if (*datalength < 3) {
-	snmp_set_api_error(SNMPERR_ASN_ENCODE);
-	return(NULL);
-      }
-      *data++ = (u_char)(0x02 | ASN_LONG_LEN);
-      *data++ = (u_char)((length >> 8) & 0xFF);
-      *data++ = (u_char)(length & 0xFF);
-    }
+    u_char *start_data = data;
+
+    if (truth) {
+
+	/* no indefinite lengths sent */
+	if (length < 0x80) {
+	    if (*datalength < 1) {
+		snmp_set_api_error(SNMPERR_ASN_ENCODE);
+		return (NULL);
+	    }
+	    *data++ = (u_char) length;
+
+	} else if (length <= 0xFF) {
+	    if (*datalength < 2) {
+		snmp_set_api_error(SNMPERR_ASN_ENCODE);
+		return (NULL);
+	    }
+	    *data++ = (u_char) (0x01 | ASN_LONG_LEN);
+	    *data++ = (u_char) length;
+	} else {		/* 0xFF < length <= 0xFFFF */
+	    if (*datalength < 3) {
+		snmp_set_api_error(SNMPERR_ASN_ENCODE);
+		return (NULL);
+	    }
+	    *data++ = (u_char) (0x02 | ASN_LONG_LEN);
+	    *data++ = (u_char) ((length >> 8) & 0xFF);
+	    *data++ = (u_char) (length & 0xFF);
+	}
 
-  } else {
+    } else {
 
-    /* Don't know if this is the true length.  Make sure it's large
-     * enough for later.
-     */
-    if (*datalength < 3) {
-      snmp_set_api_error(SNMPERR_ASN_ENCODE);
-      return(NULL);
+	/* Don't know if this is the true length.  Make sure it's large
+	 * enough for later.
+	 */
+	if (*datalength < 3) {
+	    snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	    return (NULL);
+	}
+	*data++ = (u_char) (0x02 | ASN_LONG_LEN);
+	*data++ = (u_char) ((length >> 8) & 0xFF);
+	*data++ = (u_char) (length & 0xFF);
     }
-    *data++ = (u_char)(0x02 | ASN_LONG_LEN);
-    *data++ = (u_char)((length >> 8) & 0xFF);
-    *data++ = (u_char)(length & 0xFF);
-  }
 
-  *datalength -= (data - start_data);
-  return(data);
+    *datalength -= (data - start_data);
+    return (data);
 }
 
 /*
@@ -678,77 +668,78 @@ u_char *asn_build_length(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_objid(u_char *data, int *datalength, 
-			u_char *type, oid *objid, int *objidlength)
+u_char *
+asn_parse_objid(u_char * data, int *datalength,
+    u_char * type, oid * objid, int *objidlength)
   /*    u_char  *data;        IN - pointer to start of object */
   /*    int     *datalength;  IN/OUT - # of valid bytes left in buf */
   /*    u_char  *type;        OUT - ASN type of object */
   /*    oid     *objid;       IN/OUT - pointer to start of output buffer */
   /*    int     *objidlength; IN/OUT - number of sub-id's in objid */
 {
-  /*
-   * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
-   * subidentifier ::= {leadingbyte}* lastbyte
-   * leadingbyte ::= 1 7bitvalue
-   * lastbyte ::= 0 7bitvalue
-   */
-  u_char     *bufp = data;
-  oid        *oidp = objid + 1;
-  u_int     subidentifier;
-  int       length;
-  u_int              asn_length;
-
-  *type = *bufp++;
-  bufp = asn_parse_length(bufp, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  if (asn_length + (bufp - data) > *datalength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-  *datalength -= (int)asn_length + (bufp - data);
-    
-  /* Handle invalid object identifier encodings of the form 06 00 robustly */
-  if (asn_length == 0)
-    objid[0] = objid[1] = 0;
-    
-  length = asn_length;
-  (*objidlength)--;   /* account for expansion of first byte */
-  while (length > 0 && (*objidlength)-- > 0) {
-    subidentifier = 0;
-
-    do {    /* shift and add in low order 7 bits */
-      subidentifier = (subidentifier << 7)
-	+ (*(u_char *)bufp & ~ASN_BIT8);
-      length--;
-    } while (*(u_char *)bufp++ & ASN_BIT8);
-
-    /* while last byte has high bit clear */
-    if (subidentifier > (u_int)MAX_SUBID) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-    }
-    *oidp++ = (oid)subidentifier;
-  }
-    
-  /*
-   * The first two subidentifiers are encoded into the first component
-   * with the value (X * 40) + Y, where:
-   *  X is the value of the first subidentifier.
-   *  Y is the value of the second subidentifier.
-   */
-  subidentifier = (u_int)objid[1];
-  if (subidentifier == 0x2B) {
-    objid[0] = 1;
-    objid[1] = 3;
-  } else {
-    objid[1] = (u_char)(subidentifier % 40);
-    objid[0] = (u_char)((subidentifier - objid[1]) / 40);
-  }
-  
-  *objidlength = (int)(oidp - objid);
-  return(bufp);
+    /*
+     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
+     * subidentifier ::= {leadingbyte}* lastbyte
+     * leadingbyte ::= 1 7bitvalue
+     * lastbyte ::= 0 7bitvalue
+     */
+    u_char *bufp = data;
+    oid *oidp = objid + 1;
+    u_int subidentifier;
+    int length;
+    u_int asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    if (asn_length + (bufp - data) > *datalength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    *datalength -= (int) asn_length + (bufp - data);
+
+    /* Handle invalid object identifier encodings of the form 06 00 robustly */
+    if (asn_length == 0)
+	objid[0] = objid[1] = 0;
+
+    length = asn_length;
+    (*objidlength)--;		/* account for expansion of first byte */
+    while (length > 0 && (*objidlength)-- > 0) {
+	subidentifier = 0;
+
+	do {			/* shift and add in low order 7 bits */
+	    subidentifier = (subidentifier << 7)
+		+ (*(u_char *) bufp & ~ASN_BIT8);
+	    length--;
+	} while (*(u_char *) bufp++ & ASN_BIT8);
+
+	/* while last byte has high bit clear */
+	if (subidentifier > (u_int) MAX_SUBID) {
+	    snmp_set_api_error(SNMPERR_ASN_DECODE);
+	    return (NULL);
+	}
+	*oidp++ = (oid) subidentifier;
+    }
+
+    /*
+     * The first two subidentifiers are encoded into the first component
+     * with the value (X * 40) + Y, where:
+     *  X is the value of the first subidentifier.
+     *  Y is the value of the second subidentifier.
+     */
+    subidentifier = (u_int) objid[1];
+    if (subidentifier == 0x2B) {
+	objid[0] = 1;
+	objid[1] = 3;
+    } else {
+	objid[1] = (u_char) (subidentifier % 40);
+	objid[0] = (u_char) ((subidentifier - objid[1]) / 40);
+    }
+
+    *objidlength = (int) (oidp - objid);
+    return (bufp);
 }
 
 /*
@@ -762,73 +753,74 @@ u_char *asn_parse_objid(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_build_objid(u_char *data, int *datalength, 
-			u_char type, oid *objid, int objidlength)
+u_char *
+asn_build_objid(u_char * data, int *datalength,
+    u_char type, oid * objid, int objidlength)
   /*    u_char *data;         IN - pointer to start of object */
   /*    int    *datalength;   IN/OUT - # of valid bytes left in buf */
   /*    u_char  type;         IN - ASN type of object */
   /*    oid    *objid;        IN - pointer to start of input buffer */
   /*    int     objidlength;  IN - number of sub-id's in objid */
 {
-  /*
-   * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
-   * subidentifier ::= {leadingbyte}* lastbyte
-   * leadingbyte ::= 1 7bitvalue
-   * lastbyte ::= 0 7bitvalue
-   */
-  u_char  buf[MAX_OID_LEN];
-  u_char *bp = buf;
-  oid    *op = objid;
-  int     asnlength;
-  u_int  subid, mask, testmask;
-  int     bits, testbits;
-    
-  if (objidlength < 2) {
-    *bp++ = 0;
-    objidlength = 0;
-  } else {
-    *bp++ = op[1] + (op[0] * 40);
-    objidlength -= 2;
-    op += 2;
-  }
-    
-  while(objidlength-- > 0) {
-    subid = *op++;
-    if (subid < 127) { /* off by one? */
-      *bp++ = subid;
+    /*
+     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
+     * subidentifier ::= {leadingbyte}* lastbyte
+     * leadingbyte ::= 1 7bitvalue
+     * lastbyte ::= 0 7bitvalue
+     */
+    u_char buf[MAX_OID_LEN];
+    u_char *bp = buf;
+    oid *op = objid;
+    int asnlength;
+    u_int subid, mask, testmask;
+    int bits, testbits;
+
+    if (objidlength < 2) {
+	*bp++ = 0;
+	objidlength = 0;
     } else {
-      mask = 0x7F; /* handle subid == 0 case */
-      bits = 0;
-      /* testmask *MUST* !!!! be of an unsigned type */
-      for(testmask = 0x7F, testbits = 0; testmask != 0;
-	  testmask <<= 7, testbits += 7) {
-	if (subid & testmask) {  /* if any bits set */
-	  mask = testmask;
-	  bits = testbits;
+	*bp++ = op[1] + (op[0] * 40);
+	objidlength -= 2;
+	op += 2;
+    }
+
+    while (objidlength-- > 0) {
+	subid = *op++;
+	if (subid < 127) {	/* off by one? */
+	    *bp++ = subid;
+	} else {
+	    mask = 0x7F;	/* handle subid == 0 case */
+	    bits = 0;
+	    /* testmask *MUST* !!!! be of an unsigned type */
+	    for (testmask = 0x7F, testbits = 0; testmask != 0;
+		testmask <<= 7, testbits += 7) {
+		if (subid & testmask) {		/* if any bits set */
+		    mask = testmask;
+		    bits = testbits;
+		}
+	    }
+	    /* mask can't be zero here */
+	    for (; mask != 0x7F; mask >>= 7, bits -= 7) {
+		/* fix a mask that got truncated above */
+		if (mask == 0x1E00000)
+		    mask = 0xFE00000;
+		*bp++ = (u_char) (((subid & mask) >> bits) | ASN_BIT8);
+	    }
+	    *bp++ = (u_char) (subid & mask);
 	}
-      }
-      /* mask can't be zero here */
-      for(;mask != 0x7F; mask >>= 7, bits -= 7) {
-	/* fix a mask that got truncated above */
-	if (mask == 0x1E00000)  
-	  mask = 0xFE00000;
-	*bp++ = (u_char)(((subid & mask) >> bits) | ASN_BIT8);
-      }
-      *bp++ = (u_char)(subid & mask);
-    }
-  }
-
-  asnlength = bp - buf;
-  data = asn_build_header_with_truth(data, datalength, type, asnlength, 1);
-  if (data == NULL) 
-    return(NULL);
-  if (*datalength < asnlength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-  xmemcpy((char *)data, (char *)buf, asnlength);
-  *datalength -= asnlength;
-  return(data + asnlength);
+    }
+
+    asnlength = bp - buf;
+    data = asn_build_header_with_truth(data, datalength, type, asnlength, 1);
+    if (data == NULL)
+	return (NULL);
+    if (*datalength < asnlength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    xmemcpy((char *) data, (char *) buf, asnlength);
+    *datalength -= asnlength;
+    return (data + asnlength);
 }
 
 #if 0
@@ -842,29 +834,29 @@ u_char *asn_build_objid(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_null(u_char *data, int *datalength, u_char *type)
+u_char *
+asn_parse_null(u_char * data, int *datalength, u_char * type)
   /*    u_char  *data;       IN - pointer to start of object */
   /*    int     *datalength; IN/OUT - # of valid bytes left in buf */
   /*    u_char  *type;       OUT - ASN type of object */
 {
-  /*
-   * ASN.1 null ::= 0x05 0x00
-   */
-  u_char     *bufp = data;
-  u_int              asn_length;
-    
-  *type = *bufp++;
-  bufp = asn_parse_length(bufp, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  if (asn_length != 0) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-    }
-
-  *datalength -= (bufp - data);
-  return(bufp + asn_length);
+    /*
+     * ASN.1 null ::= 0x05 0x00
+     */
+    u_char *bufp = data;
+    u_int asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    if (asn_length != 0) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    *datalength -= (bufp - data);
+    return (bufp + asn_length);
 }
 #endif
 
@@ -878,15 +870,16 @@ u_char *asn_parse_null(u_char *data, int *datalength, u_char *type)
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_build_null(u_char *data, int *datalength, u_char type)
+u_char *
+asn_build_null(u_char * data, int *datalength, u_char type)
   /*    u_char  *data;       IN - pointer to start of object */
   /*    int     *datalength; IN/OUT - # of valid bytes left in buf */
   /*    u_char   type;       IN - ASN type of object */
 {
-  /*
-   * ASN.1 null ::= 0x05 0x00
-   */
-  return(asn_build_header_with_truth(data, datalength, type, 0, 1));
+    /*
+     * ASN.1 null ::= 0x05 0x00
+     */
+    return (asn_build_header_with_truth(data, datalength, type, 0, 1));
 }
 
 #if 0
@@ -903,49 +896,46 @@ u_char *asn_build_null(u_char *data, int *datalength, u_char type)
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_parse_bitstring(u_char *data, int *datalength, 
-			    u_char *type, u_char *string, int *strlength)
+u_char *
+asn_parse_bitstring(u_char * data, int *datalength,
+    u_char * type, u_char * string, int *strlength)
   /*   u_char  *data;        IN - pointer to start of object */
   /*   int     *datalength;  IN/OUT - # of valid bytes left in buf */
   /*   u_char  *type;        OUT - asn type of object */
   /*   u_char  *string;      IN/OUT - pointer to start of output buf */
   /*   int     *strlength;   IN/OUT - size of output buffer */
 {
-  /*
-   * bitstring ::= 0x03 asnlength unused {byte}*
-   */
-  u_char     *bufp = data;
-  u_int              asn_length;
-    
-  *type = *bufp++;
-  bufp = asn_parse_length(bufp, &asn_length);
-  if (bufp == NULL)
-    return(NULL);
-
-  if (asn_length + (bufp - data) > *datalength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  if (asn_length > *strlength) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  if (asn_length < 1) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  if ((int)(*(char *)bufp) < 0 || (int)(*bufp) > 7) {
-    snmp_set_api_error(SNMPERR_ASN_DECODE);
-    return(NULL);
-  }
-
-  xmemcpy((char *)string, (char *)bufp, (int)asn_length);
-  *strlength = (int)asn_length;
-  *datalength -= (int)asn_length + (bufp - data);
-  return(bufp + asn_length);
+    /*
+     * bitstring ::= 0x03 asnlength unused {byte}*
+     */
+    u_char *bufp = data;
+    u_int asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return (NULL);
+
+    if (asn_length + (bufp - data) > *datalength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    if (asn_length > *strlength) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    if (asn_length < 1) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    if ((int) (*(char *) bufp) < 0 || (int) (*bufp) > 7) {
+	snmp_set_api_error(SNMPERR_ASN_DECODE);
+	return (NULL);
+    }
+    xmemcpy((char *) string, (char *) bufp, (int) asn_length);
+    *strlength = (int) asn_length;
+    *datalength -= (int) asn_length + (bufp - data);
+    return (bufp + asn_length);
 }
 
 /*
@@ -959,34 +949,33 @@ u_char *asn_parse_bitstring(u_char *data, int *datalength,
  *   of this object (i.e. the start of the next object).
  *  Returns NULL on any error.
  */
-u_char *asn_build_bitstring(u_char *data, int *datalength, 
-			    u_char type, u_char *string, int strlength)
+u_char *
+asn_build_bitstring(u_char * data, int *datalength,
+    u_char type, u_char * string, int strlength)
   /*   u_char  *data;       IN - pointer to start of object */
   /*   int     *datalength; IN/OUT - # of valid bytes left in buf */
   /*   u_char   type;       IN - ASN type of string */
   /*   u_char  *string;     IN - pointer to start of input buffer */
   /*   int      strlength;  IN - size of input buffer */
 {
-  /*
-   * ASN.1 bit string ::= 0x03 asnlength unused {byte}*
-   */
-  if ((strlength < 1) || ((*(char *)string) < 0) || ((*string) > 7)) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  data = asn_build_header_with_truth(data, datalength, type, strlength, 1);
-  if (data == NULL)
-    return(NULL);
-
-  if (*datalength < strlength) {
-    snmp_set_api_error(SNMPERR_ASN_ENCODE);
-    return(NULL);
-  }
-
-  xmemcpy((char *)data, (char *)string, strlength);
-  *datalength -= strlength;
-  return(data + strlength);
+    /*
+     * ASN.1 bit string ::= 0x03 asnlength unused {byte}*
+     */
+    if ((strlength < 1) || ((*(char *) string) < 0) || ((*string) > 7)) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    data = asn_build_header_with_truth(data, datalength, type, strlength, 1);
+    if (data == NULL)
+	return (NULL);
+
+    if (*datalength < strlength) {
+	snmp_set_api_error(SNMPERR_ASN_ENCODE);
+	return (NULL);
+    }
+    xmemcpy((char *) data, (char *) string, strlength);
+    *datalength -= strlength;
+    return (data + strlength);
 }
 
 #endif
@@ -1013,10 +1002,11 @@ u_char *asn_build_bitstring(u_char *data, int *datalength,
  *                                           1 -- noSuchInstance
  *                                           2 -- endOfMibView
  */
-u_char *asn_build_exception(u_char *data, int *datalength, u_char type)
+u_char *
+asn_build_exception(u_char * data, int *datalength, u_char type)
   /*    u_char  *data;       IN - pointer to start of object */
   /*    int     *datalength; IN/OUT - # of valid bytes left in buf */
   /*    u_char   type;       IN - ASN type of object */
 {
-  return(asn_build_header_with_truth(data, datalength, type, 0, 1));
+    return (asn_build_header_with_truth(data, datalength, type, 0, 1));
 }
@@ -100,29 +100,29 @@
  * valid V1 responses.  (I think. XXXXX)
  *
  */
-int snmp_coexist_V2toV1(struct snmp_pdu *PDU)
+int 
+snmp_coexist_V2toV1(struct snmp_pdu *PDU)
 {
-  /* Per 3.1.1:
-   */
-  switch (PDU->command) {
-    
-  case SNMP_PDU_GET:
-  case SNMP_PDU_GETNEXT:
-  case SNMP_PDU_SET:
-    return(1);
-    break;
+    /* Per 3.1.1:
+     */
+    switch (PDU->command) {
 
-  case SNMP_PDU_GETBULK:
-    PDU->non_repeaters = 0;
-    PDU->max_repetitions = 0;
-    PDU->command = SNMP_PDU_GETNEXT;
-    return(1);
-    break;
+    case SNMP_PDU_GET:
+    case SNMP_PDU_GETNEXT:
+    case SNMP_PDU_SET:
+	return (1);
+	break;
 
-  default:
-    snmplib_debug(2, "Unable to translate PDU %d to SNMPv1!\n", PDU->command);
-    snmp_set_api_error(SNMPERR_PDU_TRANSLATION);
-    return(0);
-  }
-}
+    case SNMP_PDU_GETBULK:
+	PDU->non_repeaters = 0;
+	PDU->max_repetitions = 0;
+	PDU->command = SNMP_PDU_GETNEXT;
+	return (1);
+	break;
 
+    default:
+	snmplib_debug(2, "Unable to translate PDU %d to SNMPv1!\n", PDU->command);
+	snmp_set_api_error(SNMPERR_PDU_TRANSLATION);
+	return (0);
+    }
+}
@@ -1,3 +1,4 @@
+
 /***********************************************************
 	Copyright 1988, 1989 by Carnegie Mellon University
 
@@ -88,10 +89,10 @@ static void sprint_by_type();
 #if 0
 static char *
 uptimeString(timeticks, buf)
-    int timeticks;
-    char *buf;
+     int timeticks;
+     char *buf;
 {
-    int	seconds, minutes, hours, days;
+    int seconds, minutes, hours, days;
 
     timeticks /= 100;
     days = timeticks / (60 * 60 * 24);
@@ -103,46 +104,48 @@ uptimeString(timeticks, buf)
     minutes = timeticks / 60;
     seconds = timeticks % 60;
 
-    if (days == 0){
-	snprintf(buf,32,  "%d:%02d:%02d", hours, minutes, seconds);
+    if (days == 0) {
+	snprintf(buf, 32, "%d:%02d:%02d", hours, minutes, seconds);
     } else if (days == 1) {
-	snprintf(buf,32, "%d day, %d:%02d:%02d", days, hours, minutes, seconds);
+	snprintf(buf, 32, "%d day, %d:%02d:%02d", days, hours, minutes, seconds);
     } else {
-	snprintf(buf,32,  "%d days, %d:%02d:%02d", days, hours, minutes, seconds);
+	snprintf(buf, 32, "%d days, %d:%02d:%02d", days, hours, minutes, seconds);
     }
     return buf;
 }
 
-static void sprint_hexstring(buf, cp, len)
-    char *buf;
-    u_char  *cp;
-    int	    len;
+static void 
+sprint_hexstring(buf, cp, len)
+     char *buf;
+     u_char *cp;
+     int len;
 {
 
-    for(; len >= 16; len -= 16){
-	snprintf(buf,26, "%02X %02X %02X %02X %02X %02X %02X %02X ", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
+    for (; len >= 16; len -= 16) {
+	snprintf(buf, 26, "%02X %02X %02X %02X %02X %02X %02X %02X ", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
 	buf += strlen(buf);
 	cp += 8;
-	snprintf(buf,26, "%02X %02X %02X %02X %02X %02X %02X %02X\n", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
+	snprintf(buf, 26, "%02X %02X %02X %02X %02X %02X %02X %02X\n", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
 	buf += strlen(buf);
 	cp += 8;
     }
-    for(; len > 0; len--){
+    for (; len > 0; len--) {
 	snprintf(buf, 4, "%02X ", *cp++);
 	buf += strlen(buf);
     }
     *buf = '\0';
 }
 
-static void sprint_asciistring(buf, cp, len)
-    char *buf;
-    u_char  *cp;
-    int	    len;
+static void 
+sprint_asciistring(buf, cp, len)
+     char *buf;
+     u_char *cp;
+     int len;
 {
-    int	x;
+    int x;
 
-    for(x = 0; x < len; x++){
-	if (isprint(*cp)){
+    for (x = 0; x < len; x++) {
+	if (isprint(*cp)) {
 	    *buf++ = *cp++;
 	} else {
 	    *buf++ = '.';
@@ -156,133 +159,131 @@ static void sprint_asciistring(buf, cp, len)
 
 static void
 sprint_octet_string(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
     int hex, x;
     u_char *cp;
 
-    if (var->type != ASN_OCTET_STR){
+    if (var->type != ASN_OCTET_STR) {
 	sprintf(buf, "Wrong Type (should be OCTET STRING): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     hex = 0;
-    for(cp = var->val.string, x = 0; x < var->val_len; x++, cp++){
+    for (cp = var->val.string, x = 0; x < var->val_len; x++, cp++) {
 	if (!(isprint(*cp) || isspace(*cp)))
 	    hex = 1;
     }
     if (var->val_len <= 4)
-	hex = 1;    /* not likely to be ascii */
-    if (hex){
-      if (!quiet) {
-	sprintf(buf, "OCTET STRING-   (hex):\t");
-	buf += strlen(buf);
-      }
+	hex = 1;		/* not likely to be ascii */
+    if (hex) {
+	if (!quiet) {
+	    sprintf(buf, "OCTET STRING-   (hex):\t");
+	    buf += strlen(buf);
+	}
 	sprint_hexstring(buf, var->val.string, var->val_len);
     } else {
-      if (!quiet) {
-	sprintf(buf, "OCTET STRING- (ascii):\t");
-	buf += strlen(buf);
-      }
+	if (!quiet) {
+	    sprintf(buf, "OCTET STRING- (ascii):\t");
+	    buf += strlen(buf);
+	}
 	sprint_asciistring(buf, var->val.string, var->val_len);
     }
 }
 
 static void
 sprint_opaque(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-    void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
 
-    if (var->type != SMI_OPAQUE){
+    if (var->type != SMI_OPAQUE) {
 	sprintf(buf, "Wrong Type (should be Opaque): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     if (!quiet) {
-      sprintf(buf, "OPAQUE -   (hex):\t");
-      buf += strlen(buf);
+	sprintf(buf, "OPAQUE -   (hex):\t");
+	buf += strlen(buf);
     }
     sprint_hexstring(buf, var->val.string, var->val_len);
 }
 
 static void
 sprint_object_identifier(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-    void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
-    if (var->type != SMI_OBJID){
+    if (var->type != SMI_OBJID) {
 	sprintf(buf, "Wrong Type (should be OBJECT IDENTIFIER): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     if (!quiet) {
-      sprintf(buf, "OBJECT IDENTIFIER:\t");
-      buf += strlen(buf);
+	sprintf(buf, "OBJECT IDENTIFIER:\t");
+	buf += strlen(buf);
     }
-    sprint_objid(buf, (oid *)(var->val.objid), var->val_len / sizeof(oid));
+    sprint_objid(buf, (oid *) (var->val.objid), var->val_len / sizeof(oid));
 }
 
 static void
 sprint_timeticks(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-    void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
     char timebuf[32];
 
-    if (var->type != SMI_TIMETICKS){
+    if (var->type != SMI_TIMETICKS) {
 	sprintf(buf, "Wrong Type (should be Timeticks): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     if (!quiet) {
-      sprintf(buf, "Timeticks: ");
-      buf += strlen(buf);
+	sprintf(buf, "Timeticks: ");
+	buf += strlen(buf);
     }
-    sprintf(buf, "(%u) %s", 
-	    *(var->val.integer), 
-	    uptimeString(*(var->val.integer), timebuf));
+    sprintf(buf, "(%u) %s",
+	*(var->val.integer),
+	uptimeString(*(var->val.integer), timebuf));
 }
 
 static void
 sprint_integer(buf, var, enums, quiet)
-    char *buf;
-    variable_list *var;
-    struct enum_list	    *enums;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     struct enum_list *enums;
+     int quiet;
 {
-    char    *enum_string = NULL;
+    char *enum_string = NULL;
 
-    if (var->type != SMI_INTEGER){
+    if (var->type != SMI_INTEGER) {
 	sprintf(buf, "Wrong Type (should be INTEGER): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     for (; enums; enums = enums->next)
-	if (enums->value == *var->val.integer){
+	if (enums->value == *var->val.integer) {
 	    enum_string = enums->label;
 	    break;
 	}
-
     if (!quiet) {
-      sprintf(buf, "INTEGER: ");
-      buf += strlen(buf);
+	sprintf(buf, "INTEGER: ");
+	buf += strlen(buf);
     }
- 
     if (enum_string == NULL)
 	sprintf(buf, "%u", *var->val.integer);
     else
@@ -291,61 +292,61 @@ sprint_integer(buf, var, enums, quiet)
 
 static void
 sprint_gauge(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
-    if (var->type != SMI_GAUGE32){
+    if (var->type != SMI_GAUGE32) {
 	sprintf(buf, "Wrong Type (should be Gauge): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     if (!quiet) {
-      sprintf(buf, "Gauge: ");
-      buf += strlen(buf);
+	sprintf(buf, "Gauge: ");
+	buf += strlen(buf);
     }
     sprintf(buf, "%u", *var->val.integer);
 }
 
 static void
 sprint_counter(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
-    if (var->type != SMI_COUNTER32){
+    if (var->type != SMI_COUNTER32) {
 	sprintf(buf, "Wrong Type (should be Counter): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     if (!quiet) {
-      sprintf(buf, "Counter: ");
-      buf += strlen(buf);
+	sprintf(buf, "Counter: ");
+	buf += strlen(buf);
     }
     sprintf(buf, "%u", *var->val.integer);
 }
 
 static void
 sprint_networkaddress(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
     int x, len;
     u_char *cp;
 
     if (!quiet) {
-      sprintf(buf, "Network Address:\t");
-      buf += strlen(buf);
+	sprintf(buf, "Network Address:\t");
+	buf += strlen(buf);
     }
-    cp = var->val.string;    
+    cp = var->val.string;
     len = var->val_len;
-    for(x = 0; x < len; x++){
+    for (x = 0; x < len; x++) {
 	sprintf(buf, "%02X", *cp++);
 	buf += strlen(buf);
 	if (x < (len - 1))
@@ -355,181 +356,183 @@ void *foo;
 
 static void
 sprint_ipaddress(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
     u_char *ip;
 
-    if (var->type != SMI_IPADDRESS){
+    if (var->type != SMI_IPADDRESS) {
 	sprintf(buf, "Wrong Type (should be Ipaddress): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     ip = var->val.string;
     if (!quiet) {
-      sprintf(buf, "IPAddress:\t");
-      buf += strlen(buf);
+	sprintf(buf, "IPAddress:\t");
+	buf += strlen(buf);
     }
-    sprintf(buf, "%d.%d.%d.%d",ip[0], ip[1], ip[2], ip[3]);
+    sprintf(buf, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
 }
 #endif
 
 #if 0
 static void
 sprint_unsigned_short(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-    int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
-    if (var->type != SMI_INTEGER){
+    if (var->type != SMI_INTEGER) {
 	sprintf(buf, "Wrong Type (should be INTEGER): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     if (!quiet) {
-      sprintf(buf, "INTEGER (0..65535): ");
-      buf += strlen(buf);
+	sprintf(buf, "INTEGER (0..65535): ");
+	buf += strlen(buf);
     }
     sprintf(buf, "%u", *var->val.integer);
 }
-#endif 
+#endif
 
 #if 0
 static void
 sprint_null(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
-    if (var->type != SMI_NULLOBJ){
+    if (var->type != SMI_NULLOBJ) {
 	sprintf(buf, "Wrong Type (should be NULL): ");
 	buf += strlen(buf);
-	sprint_by_type(buf, var, (struct enum_list *)NULL, quiet);
+	sprint_by_type(buf, var, (struct enum_list *) NULL, quiet);
 	return;
     }
     sprintf(buf, "NULL");
 }
 
 static void
 sprint_unknowntype(buf, var, foo, quiet)
-    char *buf;
-    variable_list *var;
-void *foo;
-int quiet;
+     char *buf;
+     variable_list *var;
+     void *foo;
+     int quiet;
 {
 /*    sprintf(buf, "Variable has bad type"); */
     sprint_by_type(buf, var, foo, quiet);
 }
 
 static void
 sprint_badtype(buf)
-    char *buf;
+     char *buf;
 {
     sprintf(buf, "Variable has bad type");
 }
 
 static void
 sprint_by_type(buf, var, enums, quiet)
-    char *buf;
-    variable_list *var;
-    struct enum_list	    *enums;
-    int quiet;
-{
-    switch (var->type){
-	case SMI_INTEGER:
-	    sprint_integer(buf, var, enums, quiet);
-	    break;
-	case SMI_STRING:
-	    sprint_octet_string(buf, var, enums, quiet);
-	    break;
-	case SMI_OPAQUE:
-	    sprint_opaque(buf, var, enums, quiet);
-	    break;
-	case SMI_OBJID:
-	    sprint_object_identifier(buf, var, enums, quiet);
-	    break;
-	case SMI_TIMETICKS:
-	    sprint_timeticks(buf, var, enums, quiet);
-	    break;
-	case SMI_GAUGE32:
-	    sprint_gauge(buf, var, enums, quiet);
-	    break;
-	case SMI_COUNTER32:
-	    sprint_counter(buf, var, enums, quiet);
-	    break;
-	case SMI_IPADDRESS:
-	    sprint_ipaddress(buf, var, enums, quiet);
-	    break;
-	case SMI_NULLOBJ:
-	    sprint_null(buf, var, enums, quiet);
-	    break;
-	default:
-	    sprint_badtype(buf, enums, quiet);
-	    break;
+     char *buf;
+     variable_list *var;
+     struct enum_list *enums;
+     int quiet;
+{
+    switch (var->type) {
+    case SMI_INTEGER:
+	sprint_integer(buf, var, enums, quiet);
+	break;
+    case SMI_STRING:
+	sprint_octet_string(buf, var, enums, quiet);
+	break;
+    case SMI_OPAQUE:
+	sprint_opaque(buf, var, enums, quiet);
+	break;
+    case SMI_OBJID:
+	sprint_object_identifier(buf, var, enums, quiet);
+	break;
+    case SMI_TIMETICKS:
+	sprint_timeticks(buf, var, enums, quiet);
+	break;
+    case SMI_GAUGE32:
+	sprint_gauge(buf, var, enums, quiet);
+	break;
+    case SMI_COUNTER32:
+	sprint_counter(buf, var, enums, quiet);
+	break;
+    case SMI_IPADDRESS:
+	sprint_ipaddress(buf, var, enums, quiet);
+	break;
+    case SMI_NULLOBJ:
+	sprint_null(buf, var, enums, quiet);
+	break;
+    default:
+	sprint_badtype(buf, enums, quiet);
+	break;
     }
 }
 #endif
 
 static struct snmp_mib_tree *get_symbol();
 
-oid RFC1066_MIB[] = { 1, 3, 6, 1, 2, 1 };
+oid RFC1066_MIB[] =
+{1, 3, 6, 1, 2, 1};
 unsigned char RFC1066_MIB_text[] = ".iso.org.dod.internet.mgmt.mib";
 struct snmp_mib_tree *Mib;
 
 #if 0
 static void
 set_functions(subtree)
-    struct snmp_mib_tree *subtree;
+     struct snmp_mib_tree *subtree;
 {
-    for(; subtree; subtree = subtree->next_peer){
-	switch(subtree->type){
-	    case TYPE_OBJID:
-		subtree->printer = sprint_object_identifier;
-		break;
-	    case TYPE_OCTETSTR:
-		subtree->printer = sprint_octet_string;
-		break;
-	    case TYPE_INTEGER:
-		subtree->printer = sprint_integer;
-		break;
-	    case TYPE_NETADDR:
-		subtree->printer = sprint_networkaddress;
-		break;
-	    case TYPE_IPADDR:
-		subtree->printer = sprint_ipaddress;
-		break;
-	    case TYPE_COUNTER:
-		subtree->printer = sprint_counter;
-		break;
-	    case TYPE_GAUGE:
-		subtree->printer = sprint_gauge;
-		break;
-	    case TYPE_TIMETICKS:
-		subtree->printer = sprint_timeticks;
-		break;
-	    case TYPE_OPAQUE:
-		subtree->printer = sprint_opaque;
-		break;
-	    case TYPE_NULL:
-		subtree->printer = sprint_null;
-		break;
-	    case TYPE_OTHER:
-	    default:
-		subtree->printer = sprint_unknowntype;
-		break;
+    for (; subtree; subtree = subtree->next_peer) {
+	switch (subtree->type) {
+	case TYPE_OBJID:
+	    subtree->printer = sprint_object_identifier;
+	    break;
+	case TYPE_OCTETSTR:
+	    subtree->printer = sprint_octet_string;
+	    break;
+	case TYPE_INTEGER:
+	    subtree->printer = sprint_integer;
+	    break;
+	case TYPE_NETADDR:
+	    subtree->printer = sprint_networkaddress;
+	    break;
+	case TYPE_IPADDR:
+	    subtree->printer = sprint_ipaddress;
+	    break;
+	case TYPE_COUNTER:
+	    subtree->printer = sprint_counter;
+	    break;
+	case TYPE_GAUGE:
+	    subtree->printer = sprint_gauge;
+	    break;
+	case TYPE_TIMETICKS:
+	    subtree->printer = sprint_timeticks;
+	    break;
+	case TYPE_OPAQUE:
+	    subtree->printer = sprint_opaque;
+	    break;
+	case TYPE_NULL:
+	    subtree->printer = sprint_null;
+	    break;
+	case TYPE_OTHER:
+	default:
+	    subtree->printer = sprint_unknowntype;
+	    break;
 	}
 	set_functions(subtree->child_list);
     }
 }
 #endif
 
-void init_mib(char *file)
+void 
+init_mib(char *file)
 {
     if (Mib != NULL)
 	return;
@@ -544,15 +547,15 @@ void init_mib(char *file)
 
 static struct snmp_mib_tree *
 find_rfc1066_mib(root)
-    struct snmp_mib_tree *root;
+     struct snmp_mib_tree *root;
 {
     oid *op = RFC1066_MIB;
     struct snmp_mib_tree *tp;
     int len;
 
-    for(len = sizeof(RFC1066_MIB)/sizeof(oid); len; len--, op++){
-	for(tp = root; tp; tp = tp->next_peer){
-	    if (tp->subid == *op){
+    for (len = sizeof(RFC1066_MIB) / sizeof(oid); len; len--, op++) {
+	for (tp = root; tp; tp = tp->next_peer) {
+	    if (tp->subid == *op) {
 		root = tp->child_list;
 		break;
 	    }
@@ -565,11 +568,11 @@ find_rfc1066_mib(root)
 
 static int
 lc_cmp(s1, s2)
-    char *s1, *s2;
+     char *s1, *s2;
 {
     char c1, c2;
 
-    while(*s1 && *s2){
+    while (*s1 && *s2) {
 	if (isupper(*s1))
 	    c1 = tolower(*s1);
 	else
@@ -593,10 +596,10 @@ lc_cmp(s1, s2)
 
 static int
 parse_subtree(subtree, input, output, out_len)
-    struct snmp_mib_tree *subtree;
-    char *input;
-    oid	*output;
-    int	*out_len;   /* number of subid's */
+     struct snmp_mib_tree *subtree;
+     char *input;
+     oid *output;
+     int *out_len;		/* number of subid's */
 {
     char buf[128], *to = buf;
     u_int subid = 0;
@@ -623,13 +626,12 @@ parse_subtree(subtree, input, output, out_len)
 		goto found;
 	}
 	tp = NULL;
-    }
-    else {
+    } else {
 	/*
 	 * Read the name into a buffer.
 	 */
 	while ((*input != '\0') &&
-	       (*input != '.')) {
+	    (*input != '.')) {
 	    *to++ = *input++;
 	}
 	*to = '\0';
@@ -653,13 +655,12 @@ parse_subtree(subtree, input, output, out_len)
 	}
     }
 
-found:
-    if(subid > (u_int)MAX_SUBID){
+  found:
+    if (subid > (u_int) MAX_SUBID) {
 	snmplib_debug(0, "sub-identifier too large: %s\n", buf);
 	return (0);
     }
-
-    if ((*out_len)-- <= 0){
+    if ((*out_len)-- <= 0) {
 	snmplib_debug(0, "object identifier too long\n");
 	return (0);
     }
@@ -668,15 +669,16 @@ parse_subtree(subtree, input, output, out_len)
     if (*input != '.')
 	return (1);
     if ((*out_len =
-	 parse_subtree(tp ? tp->child_list : NULL, ++input, output, out_len)) == 0)
+	    parse_subtree(tp ? tp->child_list : NULL, ++input, output, out_len)) == 0)
 	return (0);
     return (++*out_len);
 }
 
-int read_objid(input, output, out_len)
-    char *input;
-    oid *output;
-    int	*out_len;   /* number of subid's in "output" */
+int 
+read_objid(input, output, out_len)
+     char *input;
+     oid *output;
+     int *out_len;		/* number of subid's in "output" */
 {
     struct snmp_mib_tree *root = Mib;
     oid *op = output;
@@ -686,7 +688,7 @@ int read_objid(input, output, out_len)
 	input++;
     else {
 	root = find_rfc1066_mib(root);
-	for (i = 0; i < sizeof (RFC1066_MIB)/sizeof(oid); i++) {
+	for (i = 0; i < sizeof(RFC1066_MIB) / sizeof(oid); i++) {
 	    if ((*out_len)-- > 0)
 		*output++ = RFC1066_MIB[i];
 	    else {
@@ -696,7 +698,7 @@ int read_objid(input, output, out_len)
 	}
     }
 
-    if (root == NULL){
+    if (root == NULL) {
 	snmplib_debug(0, "Mib not initialized.\n");
 	return 0;
     }
@@ -707,111 +709,117 @@ int read_objid(input, output, out_len)
     return (1);
 }
 
-void print_objid(objid, objidlen)
-    oid	    *objid;
-    int	    objidlen;	/* number of subidentifiers */
+void 
+print_objid(objid, objidlen)
+     oid *objid;
+     int objidlen;		/* number of subidentifiers */
 {
-    char    buf[256];
-    struct snmp_mib_tree    *subtree = Mib;
+    char buf[256];
+    struct snmp_mib_tree *subtree = Mib;
 
-    *buf = '.';	/* this is a fully qualified name */
+    *buf = '.';			/* this is a fully qualified name */
     get_symbol(objid, objidlen, subtree, buf + 1);
     snmplib_debug(7, "%s\n", buf);
-        
+
 }
 
-void sprint_objid(buf, objid, objidlen)
-    char *buf;
-    oid	    *objid;
-    int	    objidlen;	/* number of subidentifiers */
+void 
+sprint_objid(buf, objid, objidlen)
+     char *buf;
+     oid *objid;
+     int objidlen;		/* number of subidentifiers */
 {
-    struct snmp_mib_tree    *subtree = Mib;
+    struct snmp_mib_tree *subtree = Mib;
 
-    *buf = '.';	/* this is a fully qualified name */
+    *buf = '.';			/* this is a fully qualified name */
     get_symbol(objid, objidlen, subtree, buf + 1);
 }
 
 #if 0
-void print_variable(objid, objidlen, pvariable)
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *pvariable;
+void 
+print_variable(objid, objidlen, pvariable)
+     oid *objid;
+     int objidlen;
+     struct variable_list *pvariable;
 {
-    char    buf[1024], *cp;
-    struct snmp_mib_tree    *subtree = Mib;
+    char buf[1024], *cp;
+    struct snmp_mib_tree *subtree = Mib;
 
-    *buf = '.';	/* this is a fully qualified name */
+    *buf = '.';			/* this is a fully qualified name */
     subtree = get_symbol(objid, objidlen, subtree, buf + 1);
     cp = buf;
-    if ((strlen(buf) >= strlen((char *)RFC1066_MIB_text)) && !memcmp(buf, (char *)RFC1066_MIB_text,
-	strlen((char *)RFC1066_MIB_text))){
-	    cp += sizeof(RFC1066_MIB_text);
+    if ((strlen(buf) >= strlen((char *) RFC1066_MIB_text)) && !memcmp(buf, (char *) RFC1066_MIB_text,
+	    strlen((char *) RFC1066_MIB_text))) {
+	cp += sizeof(RFC1066_MIB_text);
     }
     printf("Name: %s -> ", cp);
     *buf = '\0';
     if (subtree->printer)
-	(*subtree->printer)(buf, pvariable, subtree->enums, 0);
+	(*subtree->printer) (buf, pvariable, subtree->enums, 0);
     else {
 	sprint_by_type(buf, pvariable, subtree->enums, 0);
     }
     printf("%s\n", buf);
 }
 
 
-void sprint_variable(buf, objid, objidlen, pvariable)
-    char *buf;
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *pvariable;
+void 
+sprint_variable(buf, objid, objidlen, pvariable)
+     char *buf;
+     oid *objid;
+     int objidlen;
+     struct variable_list *pvariable;
 {
-    char    tempbuf[512], *cp;
-    struct snmp_mib_tree    *subtree = Mib;
+    char tempbuf[512], *cp;
+    struct snmp_mib_tree *subtree = Mib;
 
-    *tempbuf = '.';	/* this is a fully qualified name */
+    *tempbuf = '.';		/* this is a fully qualified name */
     subtree = get_symbol(objid, objidlen, subtree, tempbuf + 1);
     cp = tempbuf;
-    if ((strlen(buf) >= strlen((char *)RFC1066_MIB_text)) && !memcmp(buf, (char *)RFC1066_MIB_text,
-	strlen((char *)RFC1066_MIB_text))){
-	    cp += sizeof(RFC1066_MIB_text);
+    if ((strlen(buf) >= strlen((char *) RFC1066_MIB_text)) && !memcmp(buf, (char *) RFC1066_MIB_text,
+	    strlen((char *) RFC1066_MIB_text))) {
+	cp += sizeof(RFC1066_MIB_text);
     }
     sprintf(buf, "Name: %s -> ", cp);
     buf += strlen(buf);
     if (subtree->printer)
-	(*subtree->printer)(buf, pvariable, subtree->enums, 0);
+	(*subtree->printer) (buf, pvariable, subtree->enums, 0);
     else {
 	sprint_by_type(buf, pvariable, subtree->enums, 0);
     }
     strcat(buf, "\n");
 }
 
-void sprint_value(buf, objid, objidlen, pvariable)
-    char *buf;
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *pvariable;
+void 
+sprint_value(buf, objid, objidlen, pvariable)
+     char *buf;
+     oid *objid;
+     int objidlen;
+     struct variable_list *pvariable;
 {
-    char    tempbuf[512];
-    struct snmp_mib_tree    *subtree = Mib;
+    char tempbuf[512];
+    struct snmp_mib_tree *subtree = Mib;
 
     subtree = get_symbol(objid, objidlen, subtree, tempbuf);
     if (subtree->printer)
-	(*subtree->printer)(buf, pvariable, subtree->enums, 0);
+	(*subtree->printer) (buf, pvariable, subtree->enums, 0);
     else {
 	sprint_by_type(buf, pvariable, subtree->enums, 0);
     }
 }
 
-void print_value(objid, objidlen, pvariable)
-    oid     *objid;
-    int	    objidlen;
-    struct  variable_list *pvariable;
+void 
+print_value(objid, objidlen, pvariable)
+     oid *objid;
+     int objidlen;
+     struct variable_list *pvariable;
 {
-    char    tempbuf[512];
-    struct snmp_mib_tree    *subtree = Mib;
+    char tempbuf[512];
+    struct snmp_mib_tree *subtree = Mib;
 
     subtree = get_symbol(objid, objidlen, subtree, tempbuf);
     if (subtree->printer)
-	(*subtree->printer)(tempbuf, pvariable, subtree->enums, 0);
+	(*subtree->printer) (tempbuf, pvariable, subtree->enums, 0);
     else {
 	sprint_by_type(tempbuf, pvariable, subtree->enums, 0);
     }
@@ -821,37 +829,37 @@ void print_value(objid, objidlen, pvariable)
 
 static struct snmp_mib_tree *
 get_symbol(objid, objidlen, subtree, buf)
-    oid	    *objid;
-    int	    objidlen;
-    struct snmp_mib_tree    *subtree;
-    char    *buf;
+     oid *objid;
+     int objidlen;
+     struct snmp_mib_tree *subtree;
+     char *buf;
 {
-    struct snmp_mib_tree    *return_tree = NULL;
+    struct snmp_mib_tree *return_tree = NULL;
 
-    for(; subtree; subtree = subtree->next_peer){
-	if (*objid == subtree->subid){
+    for (; subtree; subtree = subtree->next_peer) {
+	if (*objid == subtree->subid) {
 	    strcpy(buf, subtree->label);
 	    goto found;
 	}
     }
 
     /* subtree not found */
-    while(objidlen--){	/* output rest of name, uninterpreted */
+    while (objidlen--) {	/* output rest of name, uninterpreted */
 	sprintf(buf, "%u.", *objid++);
-	while(*buf)
+	while (*buf)
 	    buf++;
     }
-    *(buf - 1) = '\0'; /* remove trailing dot */
+    *(buf - 1) = '\0';		/* remove trailing dot */
     return NULL;
 
-found:
-    if (objidlen > 1){
-	while(*buf)
+  found:
+    if (objidlen > 1) {
+	while (*buf)
 	    buf++;
 	*buf++ = '.';
 	*buf = '\0';
 	return_tree = get_symbol(objid + 1, objidlen - 1, subtree->child_list, buf);
-    } 
+    }
     if (return_tree != NULL)
 	return return_tree;
     else
@@ -862,69 +870,73 @@ get_symbol(objid, objidlen, subtree, buf)
 
 
 #if 0
-void print_variable_list(variable_list *V)
+void 
+print_variable_list(variable_list * V)
 {
-  print_variable(V->name, V->name_length, V);
+    print_variable(V->name, V->name_length, V);
 }
 
-void print_variable_list_value(variable_list *pvariable)
+void 
+print_variable_list_value(variable_list * pvariable)
 {
-  char    buf[512];
-  struct snmp_mib_tree    *subtree = Mib;
+    char buf[512];
+    struct snmp_mib_tree *subtree = Mib;
 
-  *buf = '.';	/* this is a fully qualified name */
-  subtree = get_symbol(pvariable->name, pvariable->name_length, subtree, buf + 1);
-  *buf = '\0';
+    *buf = '.';			/* this is a fully qualified name */
+    subtree = get_symbol(pvariable->name, pvariable->name_length, subtree, buf + 1);
+    *buf = '\0';
 
-  if (subtree->printer)
-    (*subtree->printer)(buf, pvariable, subtree->enums, 1);
-  else {
-    sprint_by_type(buf, pvariable, subtree->enums, 1);
-  }
-  printf("%s", buf);
+    if (subtree->printer)
+	(*subtree->printer) (buf, pvariable, subtree->enums, 1);
+    else {
+	sprint_by_type(buf, pvariable, subtree->enums, 1);
+    }
+    printf("%s", buf);
 }
 #endif
 
-void print_type(variable_list *var)
-{
-  switch (var->type){
-  case SMI_INTEGER:
-    printf("Integer");
-    break;
-  case SMI_STRING:
-    printf("Octet String");
-    break;
-  case SMI_OPAQUE:
-    printf("Opaque");
-    break;
-  case SMI_OBJID:
-    printf("Object Identifier");
-    break;
-  case SMI_TIMETICKS:
-    printf("Timeticks");
-    break;
-  case SMI_GAUGE32:
-    printf("Gauge");
-    break;
-  case SMI_COUNTER32:
-    printf("Counter");
-    break;
-  case SMI_IPADDRESS:
-    printf("IP Address");
-    break;
-  case SMI_NULLOBJ:
-    printf("NULL");
-    break;
-  default:
-    printf("Unknown type %d\n", var->type);
-    break;
-  }
-}
-
-void print_oid_nums(oid *O, int len)
-{
-  int x;
-
-  for (x=0;x<len;x++)
-    printf(".%u", O[x]);
+void 
+print_type(variable_list * var)
+{
+    switch (var->type) {
+    case SMI_INTEGER:
+	printf("Integer");
+	break;
+    case SMI_STRING:
+	printf("Octet String");
+	break;
+    case SMI_OPAQUE:
+	printf("Opaque");
+	break;
+    case SMI_OBJID:
+	printf("Object Identifier");
+	break;
+    case SMI_TIMETICKS:
+	printf("Timeticks");
+	break;
+    case SMI_GAUGE32:
+	printf("Gauge");
+	break;
+    case SMI_COUNTER32:
+	printf("Counter");
+	break;
+    case SMI_IPADDRESS:
+	printf("IP Address");
+	break;
+    case SMI_NULLOBJ:
+	printf("NULL");
+	break;
+    default:
+	printf("Unknown type %d\n", var->type);
+	break;
+    }
+}
+
+void 
+print_oid_nums(oid * O, int len)
+{
+    int x;
+
+    for (x = 0; x < len; x++)
+	printf(".%u", O[x]);
 }
@@ -99,10 +99,10 @@ struct subid {
  */
 struct node {
     struct node *next;
-    char label[64]; /* This node's (unique) textual name */
-    u_int  subid;  /* This node's integer subidentifier */
-    char parent[64];/* The parent's textual name */
-    int type;	    /* The type of object this represents */
+    char label[64];		/* This node's (unique) textual name */
+    u_int subid;		/* This node's integer subidentifier */
+    char parent[64];		/* The parent's textual name */
+    int type;			/* The type of object this represents */
     struct enum_list *enums;	/* (optional) list of enumerated integers (otherwise NULL) */
 };
 
@@ -127,7 +127,7 @@ int Line = 1;
 #define OPAQUE	    12
 #define NUL	    13
 #define SEQUENCE    14
-#define OF	    15	/* SEQUENCE OF */
+#define OF	    15		/* SEQUENCE OF */
 #define OBJTYPE	    16
 #define ACCESS	    17
 #define READONLY    18
@@ -154,116 +154,118 @@ int Line = 1;
 #define QUOTE       37
 
 struct tok {
-	char *name;			/* token name */
-	int len;			/* length not counting nul */
-	int token;			/* value */
-	int hash;			/* hash of name */
-	struct tok *next;		/* pointer to next in hash table */
+    char *name;			/* token name */
+    int len;			/* length not counting nul */
+    int token;			/* value */
+    int hash;			/* hash of name */
+    struct tok *next;		/* pointer to next in hash table */
 };
 
 
-struct tok tokens[] = {
-	{ "obsolete", sizeof ("obsolete")-1, OBSOLETE },
-	{ "Opaque", sizeof ("Opaque")-1, OPAQUE },
-	{ "recommended", sizeof("recommended")-1, RECOMMENDED }, 
-	{ "optional", sizeof ("optional")-1, OPTIONAL },
-	{ "mandatory", sizeof ("mandatory")-1, MANDATORY },
-	{ "current", sizeof ("current")-1, MANDATORY },
-	{ "not-accessible", sizeof ("not-accessible")-1, NOACCESS },
-	{ "write-only", sizeof ("write-only")-1, WRITEONLY },
-	{ "read-write", sizeof ("read-write")-1, READWRITE },
-	{ "TimeTicks", sizeof ("TimeTicks")-1, TIMETICKS },
-	{ "OBJECTIDENTIFIER", sizeof ("OBJECTIDENTIFIER")-1, OBJID },
+struct tok tokens[] =
+{
+    {"obsolete", sizeof("obsolete") - 1, OBSOLETE},
+    {"Opaque", sizeof("Opaque") - 1, OPAQUE},
+    {"recommended", sizeof("recommended") - 1, RECOMMENDED},
+    {"optional", sizeof("optional") - 1, OPTIONAL},
+    {"mandatory", sizeof("mandatory") - 1, MANDATORY},
+    {"current", sizeof("current") - 1, MANDATORY},
+    {"not-accessible", sizeof("not-accessible") - 1, NOACCESS},
+    {"write-only", sizeof("write-only") - 1, WRITEONLY},
+    {"read-write", sizeof("read-write") - 1, READWRITE},
+    {"TimeTicks", sizeof("TimeTicks") - 1, TIMETICKS},
+    {"OBJECTIDENTIFIER", sizeof("OBJECTIDENTIFIER") - 1, OBJID},
 	/*
 	 * This CONTINUE appends the next word onto OBJECT,
 	 * hopefully matching OBJECTIDENTIFIER above.
 	 */
-	{ "OBJECT", sizeof ("OBJECT")-1, CONTINUE },
-	{ "NetworkAddress", sizeof ("NetworkAddress")-1, NETADDR },
-	{ "Gauge", sizeof ("Gauge")-1, GAUGE },
-	{ "OCTETSTRING", sizeof ("OCTETSTRING")-1, OCTETSTR },
-	{ "OCTET", sizeof ("OCTET")-1, -1 },
-	{ "OF", sizeof ("OF")-1, OF },
-	{ "SEQUENCE", sizeof ("SEQUENCE")-1, SEQUENCE },
-	{ "NULL", sizeof ("NULL")-1, NUL },
-	{ "IpAddress", sizeof ("IpAddress")-1, IPADDR },
-	{ "INTEGER", sizeof ("INTEGER")-1, INTEGER },
-	{ "Counter", sizeof ("Counter")-1, COUNTER },
-	{ "read-only", sizeof ("read-only")-1, READONLY },
-	{ "ACCESS", sizeof ("ACCESS")-1, ACCESS },
-	{ "MAX-ACCESS", sizeof ("MAX-ACCESS")-1, ACCESS },
-	{ "STATUS", sizeof ("STATUS")-1, STATUS },
-	{ "SYNTAX", sizeof ("SYNTAX")-1, SYNTAX },
-	{ "OBJECT-TYPE", sizeof ("OBJECT-TYPE")-1, OBJTYPE },
-	{ "{", sizeof ("{")-1, LEFTBRACKET },
-	{ "}", sizeof ("}")-1, RIGHTBRACKET },
-	{ "::=", sizeof ("::=")-1, EQUALS },
-	{ "(", sizeof ("(")-1, LEFTPAREN },
-	{ ")", sizeof (")")-1, RIGHTPAREN },
-	{ ",", sizeof (",")-1, COMMA },
-	{ "DESCRIPTION", sizeof ("DESCRIPTION")-1, DESCRIPTION },
-	{ "INDEX", sizeof ("INDEX")-1, INDEX },
-	{ "\"", sizeof ("\"")-1, QUOTE },
-	{ "END", sizeof("END")-1, ENDOFFILE },
+    {"OBJECT", sizeof("OBJECT") - 1, CONTINUE},
+    {"NetworkAddress", sizeof("NetworkAddress") - 1, NETADDR},
+    {"Gauge", sizeof("Gauge") - 1, GAUGE},
+    {"OCTETSTRING", sizeof("OCTETSTRING") - 1, OCTETSTR},
+    {"OCTET", sizeof("OCTET") - 1, -1},
+    {"OF", sizeof("OF") - 1, OF},
+    {"SEQUENCE", sizeof("SEQUENCE") - 1, SEQUENCE},
+    {"NULL", sizeof("NULL") - 1, NUL},
+    {"IpAddress", sizeof("IpAddress") - 1, IPADDR},
+    {"INTEGER", sizeof("INTEGER") - 1, INTEGER},
+    {"Counter", sizeof("Counter") - 1, COUNTER},
+    {"read-only", sizeof("read-only") - 1, READONLY},
+    {"ACCESS", sizeof("ACCESS") - 1, ACCESS},
+    {"MAX-ACCESS", sizeof("MAX-ACCESS") - 1, ACCESS},
+    {"STATUS", sizeof("STATUS") - 1, STATUS},
+    {"SYNTAX", sizeof("SYNTAX") - 1, SYNTAX},
+    {"OBJECT-TYPE", sizeof("OBJECT-TYPE") - 1, OBJTYPE},
+    {"{", sizeof("{") - 1, LEFTBRACKET},
+    {"}", sizeof("}") - 1, RIGHTBRACKET},
+    {"::=", sizeof("::=") - 1, EQUALS},
+    {"(", sizeof("(") - 1, LEFTPAREN},
+    {")", sizeof(")") - 1, RIGHTPAREN},
+    {",", sizeof(",") - 1, COMMA},
+    {"DESCRIPTION", sizeof("DESCRIPTION") - 1, DESCRIPTION},
+    {"INDEX", sizeof("INDEX") - 1, INDEX},
+    {"\"", sizeof("\"") - 1, QUOTE},
+    {"END", sizeof("END") - 1, ENDOFFILE},
 /* Hacks for easier MIBFILE coercing */
-	{ "read-create", sizeof ("read-create")-1, READWRITE },
-	{ NULL }
+    {"read-create", sizeof("read-create") - 1, READWRITE},
+    {NULL}
 };
 
 #define	HASHSIZE	32
 #define	BUCKET(x)	(x & 0x01F)
 
-static struct tok	*buckets[HASHSIZE];
+static struct tok *buckets[HASHSIZE];
 
 static void
 hash_init()
 {
-	register struct tok	*tp;
-	register char	*cp;
-	register int	h;
-	register int	b;
-
-	memset((char *)buckets, '\0', sizeof(buckets));
-	for (tp = tokens; tp->name; tp++) {
-		for (h = 0, cp = tp->name; *cp; cp++)
-			h += *cp;
-		tp->hash = h;
-		b = BUCKET(h);
-		if (buckets[b])
-		    tp->next = buckets[b]; /* BUG ??? */
-		buckets[b] = tp;
-	}
+    register struct tok *tp;
+    register char *cp;
+    register int h;
+    register int b;
+
+    memset((char *) buckets, '\0', sizeof(buckets));
+    for (tp = tokens; tp->name; tp++) {
+	for (h = 0, cp = tp->name; *cp; cp++)
+	    h += *cp;
+	tp->hash = h;
+	b = BUCKET(h);
+	if (buckets[b])
+	    tp->next = buckets[b];	/* BUG ??? */
+	buckets[b] = tp;
+    }
 }
 
 #define NHASHSIZE    128
 #define NBUCKET(x)   (x & 0x7F)
 struct node *nbuckets[NHASHSIZE];
 
-static void init_node_hash(nodes)
+static void 
+init_node_hash(nodes)
      struct node *nodes;
 {
-     register struct node *np, *nextp;
-     register char *cp;
-     register int hash;
-
-     memset((char *)nbuckets, '\0', sizeof(nbuckets));
-     for(np = nodes; np;){
-         nextp = np->next;
-         hash = 0;
-	 for(cp = np->parent; *cp; cp++)
-	     hash += *cp;
-	 np->next = nbuckets[NBUCKET(hash)];
-	 nbuckets[NBUCKET(hash)] = np;
-	 np = nextp;
-     }
+    register struct node *np, *nextp;
+    register char *cp;
+    register int hash;
+
+    memset((char *) nbuckets, '\0', sizeof(nbuckets));
+    for (np = nodes; np;) {
+	nextp = np->next;
+	hash = 0;
+	for (cp = np->parent; *cp; cp++)
+	    hash += *cp;
+	np->next = nbuckets[NBUCKET(hash)];
+	nbuckets[NBUCKET(hash)] = np;
+	np = nextp;
+    }
 }
 
 
 static void
 print_error(string, token, type)
-    char *string;
-    char *token;
-    int type;
+     char *string;
+     char *token;
+     int type;
 {
     assert(string != NULL);
     if (type == ENDOFFILE)
@@ -276,67 +278,69 @@ print_error(string, token, type)
 
 #ifdef TEST
 print_subtree(tree, count)
-    struct snmp_mib_tree *tree;
-    int count;
+     struct snmp_mib_tree *tree;
+     int count;
 {
     struct snmp_mib_tree *tp;
     int i;
 
-    for(i = 0; i < count; i++)
+    for (i = 0; i < count; i++)
 	printf("  ");
     printf("Children of %s:\n", tree->label);
     count++;
-    for(tp = tree->child_list; tp; tp = tp->next_peer){
-	for(i = 0; i < count; i++)
+    for (tp = tree->child_list; tp; tp = tp->next_peer) {
+	for (i = 0; i < count; i++)
 	    printf("  ");
 	printf("%s\n", tp->label);
     }
-    for(tp = tree->child_list; tp; tp = tp->next_peer){
+    for (tp = tree->child_list; tp; tp = tp->next_peer) {
 	print_subtree(tp, count);
     }
 }
 #endif /* TEST */
 
 int translation_table[40];
 
-static void build_translation_table(){
+static void 
+build_translation_table()
+{
     int count;
 
-    for(count = 0; count < 40; count++){
-	switch(count){
-	    case OBJID:
-		translation_table[count] = TYPE_OBJID;
-		break;
-	    case OCTETSTR:
-		translation_table[count] = TYPE_OCTETSTR;
-		break;
-	    case INTEGER:
-		translation_table[count] = TYPE_INTEGER;
-		break;
-	    case NETADDR:
-		translation_table[count] = TYPE_IPADDR;
-		break;
-	    case IPADDR:
-		translation_table[count] = TYPE_IPADDR;
-		break;
-	    case COUNTER:
-		translation_table[count] = TYPE_COUNTER;
-		break;
-	    case GAUGE:
-		translation_table[count] = TYPE_GAUGE;
-		break;
-	    case TIMETICKS:
-		translation_table[count] = TYPE_TIMETICKS;
-		break;
-	    case OPAQUE:
-		translation_table[count] = TYPE_OPAQUE;
-		break;
-	    case NUL:
-		translation_table[count] = TYPE_NULL;
-		break;
-	    default:
-		translation_table[count] = TYPE_OTHER;
-		break;
+    for (count = 0; count < 40; count++) {
+	switch (count) {
+	case OBJID:
+	    translation_table[count] = TYPE_OBJID;
+	    break;
+	case OCTETSTR:
+	    translation_table[count] = TYPE_OCTETSTR;
+	    break;
+	case INTEGER:
+	    translation_table[count] = TYPE_INTEGER;
+	    break;
+	case NETADDR:
+	    translation_table[count] = TYPE_IPADDR;
+	    break;
+	case IPADDR:
+	    translation_table[count] = TYPE_IPADDR;
+	    break;
+	case COUNTER:
+	    translation_table[count] = TYPE_COUNTER;
+	    break;
+	case GAUGE:
+	    translation_table[count] = TYPE_GAUGE;
+	    break;
+	case TIMETICKS:
+	    translation_table[count] = TYPE_TIMETICKS;
+	    break;
+	case OPAQUE:
+	    translation_table[count] = TYPE_OPAQUE;
+	    break;
+	case NUL:
+	    translation_table[count] = TYPE_NULL;
+	    break;
+	default:
+	    translation_table[count] = TYPE_OTHER;
+	    break;
 	}
     }
 }
@@ -347,28 +351,28 @@ static void build_translation_table(){
  */
 static void
 do_subtree(root, nodes)
-    struct snmp_mib_tree *root;
-    struct node **nodes;
+     struct snmp_mib_tree *root;
+     struct node **nodes;
 {
     register struct snmp_mib_tree *tp;
     struct snmp_mib_tree *peer = NULL;
-    register struct node *np=NULL , **headp=NULL;
+    register struct node *np = NULL, **headp = NULL;
     struct node *oldnp = NULL, *child_list = NULL, *childp = NULL;
     char *cp;
     int hash;
-    
+
     tp = root;
     hash = 0;
-    for(cp = tp->label; *cp; cp++)
-        hash += *cp;
+    for (cp = tp->label; *cp; cp++)
+	hash += *cp;
     headp = &nbuckets[NBUCKET(hash)];
     /*
      * Search each of the nodes for one whose parent is root, and
      * move each into a separate list.
      */
-    for(np = *headp; np; np = np->next){
-	if ((*tp->label != *np->parent) || strcmp(tp->label, np->parent)){
-	    if ((*tp->label == *np->label) && !strcmp(tp->label, np->label)){
+    for (np = *headp; np; np = np->next) {
+	if ((*tp->label != *np->parent) || strcmp(tp->label, np->parent)) {
+	    if ((*tp->label == *np->label) && !strcmp(tp->label, np->label)) {
 		/* if there is another node with the same label, assume that
 		 * any children after this point in the list belong to the other node.
 		 * This adds some scoping to the table and allows vendors to
@@ -378,17 +382,17 @@ do_subtree(root, nodes)
 	    }
 	    oldnp = np;
 	} else {
-	    if (child_list == NULL){
-		child_list = childp = np;   /* first entry in child list */
+	    if (child_list == NULL) {
+		child_list = childp = np;	/* first entry in child list */
 	    } else {
 		childp->next = np;
 		childp = np;
 	    }
 	    /* take this node out of the node list */
-	    if (oldnp == NULL){
-		*headp = np->next;  /* fix root of node list */
+	    if (oldnp == NULL) {
+		*headp = np->next;	/* fix root of node list */
 	    } else {
-		oldnp->next = np->next;	/* link around this node */
+		oldnp->next = np->next;		/* link around this node */
 	    }
 	}
     }
@@ -397,8 +401,8 @@ do_subtree(root, nodes)
     /*
      * Take each element in the child list and place it into the tree.
      */
-    for(np = child_list; np; np = np->next){
-	tp = (struct snmp_mib_tree *)xmalloc(sizeof(struct snmp_mib_tree));
+    for (np = child_list; np; np = np->next) {
+	tp = (struct snmp_mib_tree *) xmalloc(sizeof(struct snmp_mib_tree));
 	tp->parent = root;
 	tp->next_peer = NULL;
 	tp->child_list = NULL;
@@ -407,18 +411,18 @@ do_subtree(root, nodes)
 	tp->type = translation_table[np->type];
 	tp->enums = np->enums;
 	np->enums = NULL;	/* so we don't free them later */
-	if (root->child_list == NULL){
+	if (root->child_list == NULL) {
 	    root->child_list = tp;
 	} else {
 	    peer->next_peer = tp;
 	}
 	peer = tp;
-/*	if (tp->type == TYPE_OTHER) */
-	    do_subtree(tp, nodes);	/* recurse on this child if it isn't an end node */
+/*      if (tp->type == TYPE_OTHER) */
+	do_subtree(tp, nodes);	/* recurse on this child if it isn't an end node */
     }
     /* free all nodes that were copied into tree */
     oldnp = NULL;
-    for(np = child_list; np; np = np->next){
+    for (np = child_list; np; np = np->next) {
 	if (oldnp)
 	    xfree(oldnp);
 	oldnp = np;
@@ -432,14 +436,14 @@ static
 #endif
 struct snmp_mib_tree *
 build_tree(nodes)
-    struct node *nodes;
+     struct node *nodes;
 {
     struct node *np;
     struct snmp_mib_tree *tp;
     int bucket, nodes_left = 0;
-    
+
     /* build root node */
-    tp = (struct snmp_mib_tree *)xmalloc(sizeof(struct snmp_mib_tree));
+    tp = (struct snmp_mib_tree *) xmalloc(sizeof(struct snmp_mib_tree));
     tp->parent = NULL;
     tp->next_peer = NULL;
     tp->child_list = NULL;
@@ -456,20 +460,20 @@ build_tree(nodes)
     print_subtree(tp, 0);
 #endif /* TEST */
     /* If any nodes are left, the tree is probably inconsistent */
-    for(bucket = 0; bucket < NHASHSIZE; bucket++){
-        if (nbuckets[bucket]){
+    for (bucket = 0; bucket < NHASHSIZE; bucket++) {
+	if (nbuckets[bucket]) {
 	    nodes_left = 1;
 	    break;
 	}
     }
-    if (nodes_left){
+    if (nodes_left) {
 	snmplib_debug(0, "The mib description doesn't seem to be consistent.\n");
 	snmplib_debug(0, "Some nodes couldn't be linked under the \"iso\" tree.\n");
 	snmplib_debug(0, "these nodes are left:\n");
-	for(bucket = 0; bucket < NHASHSIZE; bucket++){
-	    for(np = nbuckets[bucket]; np; np = np->next)
-	        snmplib_debug(0, "%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
-		        np->type);
+	for (bucket = 0; bucket < NHASHSIZE; bucket++) {
+	    for (np = nbuckets[bucket]; np; np = np->next)
+		snmplib_debug(0, "%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
+		    np->type);
 	}
     }
     return tp;
@@ -484,8 +488,8 @@ static char last = ' ';
 
 static int
 get_token(fp, token)
-    register FILE *fp;
-    register char *token;
+     register FILE *fp;
+     register char *token;
 {
     register int ch;
     register char *cp = token;
@@ -495,7 +499,7 @@ get_token(fp, token)
     *cp = 0;
     ch = last;
     /* skip all white space */
-    while(isspace(ch) && ch != -1){
+    while (isspace(ch) && ch != -1) {
 	ch = getc(fp);
 	if (ch == '\n')
 	    Line++;
@@ -511,10 +515,10 @@ get_token(fp, token)
     do {
 	if (ch == '\n')
 	    Line++;
-	if (isspace(ch) || ch == '(' || ch == ')' || 
+	if (isspace(ch) || ch == '(' || ch == ')' ||
 	    ch == '{' || ch == '}' || ch == ',' ||
-	    ch == '"' ) {
-	    if (!isspace(ch) && *token == 0){
+	    ch == '"') {
+	    if (!isspace(ch) && *token == 0) {
 		hash += ch;
 		*cp++ = ch;
 		last = ' ';
@@ -525,27 +529,26 @@ get_token(fp, token)
 
 	    for (tp = buckets[BUCKET(hash)]; tp; tp = tp->next) {
 		if ((tp->hash == hash) && (strcmp(tp->name, token) == 0))
-			break;
+		    break;
 	    }
-	    if (tp){
+	    if (tp) {
 		if (tp->token == CONTINUE)
 		    continue;
 		return (tp->token);
 	    }
-
-	    if (token[0] == '-' && token[1] == '-'){
+	    if (token[0] == '-' && token[1] == '-') {
 		/* strip comment */
 		while ((ch = getc(fp)) != -1)
-		    if (ch == '\n'){
+		    if (ch == '\n') {
 			Line++;
 			break;
 		    }
 		if (ch == -1)
 		    return ENDOFFILE;
 		last = ch;
-		return get_token(fp, token);		
+		return get_token(fp, token);
 	    }
-	    for(cp = token; *cp; cp++)
+	    for (cp = token; *cp; cp++)
 		if (!isdigit(*cp))
 		    return LABEL;
 	    return NUMBER;
@@ -555,7 +558,7 @@ get_token(fp, token)
 	    if (ch == '\n')
 		Line++;
 	}
-    
+
     } while ((ch = getc(fp)) != -1);
     return ENDOFFILE;
 }
@@ -567,41 +570,41 @@ get_token(fp, token)
  * Returns NULL on error.
  */
 static int
-getoid(fp, SubOid,  length)
-    register FILE *fp;
-    register struct subid *SubOid;	/* an array of subids */
-    int length;	    /* the length of the array */
+getoid(fp, SubOid, length)
+     register FILE *fp;
+     register struct subid *SubOid;	/* an array of subids */
+     int length;		/* the length of the array */
 {
     register int count;
     int type;
     char token[128];
     register char *cp;
 
-    if ((type = get_token(fp, token)) != LEFTBRACKET){
+    if ((type = get_token(fp, token)) != LEFTBRACKET) {
 	print_error("Expected \"{\"", token, type);
 	return 0;
     }
     type = get_token(fp, token);
-    for(count = 0; count < length; count++, SubOid++){
+    for (count = 0; count < length; count++, SubOid++) {
 	SubOid->label = 0;
 	SubOid->subid = -1;
-	if (type == RIGHTBRACKET){
+	if (type == RIGHTBRACKET) {
 	    return count;
-	} else if (type != LABEL && type != NUMBER){
+	} else if (type != LABEL && type != NUMBER) {
 	    print_error("Not valid for object identifier", token, type);
 	    return 0;
 	}
-	if (type == LABEL){
+	if (type == LABEL) {
 	    /* this entry has a label */
-	    cp = (char *)xmalloc((unsigned)strlen(token) + 1);
+	    cp = (char *) xmalloc((unsigned) strlen(token) + 1);
 	    strcpy(cp, token);
 	    SubOid->label = cp;
 	    type = get_token(fp, token);
-	    if (type == LEFTPAREN){
+	    if (type == LEFTPAREN) {
 		type = get_token(fp, token);
-		if (type == NUMBER){
+		if (type == NUMBER) {
 		    SubOid->subid = atoi(token);
-		    if ((type = get_token(fp, token)) != RIGHTPAREN){
+		    if ((type = get_token(fp, token)) != RIGHTPAREN) {
 			print_error("Unexpected a closing parenthesis", token, type);
 			return 0;
 		    }
@@ -625,17 +628,17 @@ getoid(fp, SubOid,  length)
 
 static void
 free_node(np)
-    struct node *np;
+     struct node *np;
 {
     struct enum_list *ep, *tep;
 
     ep = np->enums;
-    while(ep){
+    while (ep) {
 	tep = ep;
 	ep = ep->next;
-	xfree((char *)tep);
+	xfree((char *) tep);
     }
-    xfree((char *)np);
+    xfree((char *) np);
 }
 
 /*
@@ -646,8 +649,8 @@ free_node(np)
  */
 static struct node *
 parse_objectid(fp, name)
-    FILE *fp;
-    char *name;
+     FILE *fp;
+     char *name;
 {
     int type;
     char token[64];
@@ -658,21 +661,21 @@ parse_objectid(fp, name)
     struct node *np, *root, *oldnp = NULL;
 
     type = get_token(fp, token);
-    if (type != EQUALS){
+    if (type != EQUALS) {
 	print_error("Bad format", token, type);
 	return 0;
     }
-    if ((length = getoid(fp, SubOid, 32)) != 0){
-	np = root = (struct node *)xmalloc(sizeof(struct node));
-	memset((char *)np, '\0', sizeof(struct node));
+    if ((length = getoid(fp, SubOid, 32)) != 0) {
+	np = root = (struct node *) xmalloc(sizeof(struct node));
+	memset((char *) np, '\0', sizeof(struct node));
 	/*
 	 * For each parent-child subid pair in the subid array,
 	 * create a node and link it into the node list.
 	 */
-	for(count = 0, op = SubOid, nop=SubOid+1; count < (length - 2); count++,
-	    op++, nop++){
+	for (count = 0, op = SubOid, nop = SubOid + 1; count < (length - 2); count++,
+	    op++, nop++) {
 	    /* every node must have parent's name and child's name or number */
-	    if (op->label && (nop->label || (nop->subid != -1))){
+	    if (op->label && (nop->label || (nop->subid != -1))) {
 		strcpy(np->parent, op->label);
 		if (nop->label)
 		    strcpy(np->label, nop->label);
@@ -681,21 +684,21 @@ parse_objectid(fp, name)
 		np->type = 0;
 		np->enums = 0;
 		/* set up next entry */
-		np->next = (struct node *)xmalloc(sizeof(*np->next));
-		memset((char *)np->next, '\0', sizeof(struct node));
+		np->next = (struct node *) xmalloc(sizeof(*np->next));
+		memset((char *) np->next, '\0', sizeof(struct node));
 		oldnp = np;
 		np = np->next;
 	    }
 	}
-	np->next = (struct node *)NULL;
+	np->next = (struct node *) NULL;
 	/*
 	 * The above loop took care of all but the last pair.  This pair is taken
 	 * care of here.  The name for this node is taken from the label for this
 	 * entry.
 	 * np still points to an unused entry.
 	 */
-	if (count == (length - 2)){
-	    if (op->label){
+	if (count == (length - 2)) {
+	    if (op->label) {
 		strcpy(np->parent, op->label);
 		strcpy(np->label, name);
 		if (nop->subid != -1)
@@ -710,21 +713,21 @@ parse_objectid(fp, name)
 		    return NULL;
 	    }
 	} else {
-	    print_error("Missing end of oid", (char *)NULL, type);
-	    free_node(np);   /* the last node allocated wasn't used */
+	    print_error("Missing end of oid", (char *) NULL, type);
+	    free_node(np);	/* the last node allocated wasn't used */
 	    if (oldnp)
 		oldnp->next = NULL;
 	    return NULL;
 	}
 	/* free the oid array */
-	for(count = 0, op = SubOid; count < length; count++, op++){
+	for (count = 0, op = SubOid; count < length; count++, op++) {
 	    if (op->label)
 		xfree(op->label);
 	    op->label = 0;
 	}
 	return root;
     } else {
-	print_error("Bad object identifier", (char *)NULL, type);
+	print_error("Bad object identifier", (char *) NULL, type);
 	return 0;
     }
 }
@@ -735,17 +738,17 @@ parse_objectid(fp, name)
  */
 static int
 parse_asntype(fp)
-    FILE *fp;
+     FILE *fp;
 {
     int type;
     char token[64];
 
     type = get_token(fp, token);
-    if (type != SEQUENCE){
-	print_error("Not a sequence", token, type); /* should we handle this */
+    if (type != SEQUENCE) {
+	print_error("Not a sequence", token, type);	/* should we handle this */
 	return ENDOFFILE;
     }
-    while((type = get_token(fp, token)) != ENDOFFILE){
+    while ((type = get_token(fp, token)) != ENDOFFILE) {
 	if (type == RIGHTBRACKET)
 	    return type;
     }
@@ -759,8 +762,8 @@ parse_asntype(fp)
  */
 static struct node *
 parse_objecttype(fp, name)
-    register FILE *fp;
-    char *name;
+     register FILE *fp;
+     char *name;
 {
     register int type;
     char token[64];
@@ -769,124 +772,124 @@ parse_objecttype(fp, name)
     char syntax[64];
     int nexttype;
     char nexttoken[64];
-    register struct node *np=NULL;
-    register struct enum_list *ep=NULL;
+    register struct node *np = NULL;
+    register struct enum_list *ep = NULL;
 
     type = get_token(fp, token);
-    if (type != SYNTAX){
+    if (type != SYNTAX) {
 	print_error("Bad format for OBJECT TYPE", token, type);
 	return 0;
     }
-    np = (struct node *)xmalloc(sizeof(struct node));
+    np = (struct node *) xmalloc(sizeof(struct node));
     np->next = 0;
     np->enums = 0;
     type = get_token(fp, token);
     nexttype = get_token(fp, nexttoken);
     np->type = type;
-    switch(type){
-	case SEQUENCE:
-	    strcpy(syntax, token);
-	    if (nexttype == OF){
-		strcat(syntax, " ");
-		strcat(syntax, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-		strcat(syntax, " ");
-		strcat(syntax, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-	    }
-	    break;
-	case INTEGER:
-	    strcpy(syntax, token);
-	    if (nexttype == LEFTBRACKET) {
-		/* if there is an enumeration list, parse it */
-		while((type = get_token(fp, token)) != ENDOFFILE){
-		    if (type == RIGHTBRACKET)
-			break;
-		    if (type == LABEL){
-			/* this is an enumerated label */
-			if (np->enums == 0){
-			    ep = np->enums = (struct enum_list *)
-					xmalloc(sizeof(struct enum_list));
-			} else {
-			    ep->next = (struct enum_list *)
-					xmalloc(sizeof(struct enum_list));
-			    ep = ep->next;
-			}
-			ep->next = 0;
-			/* a reasonable approximation for the length */
-			ep->label = (char *)xmalloc((unsigned)strlen(token) + 1);
-			strcpy(ep->label, token);
-			type = get_token(fp, token);
-			if (type != LEFTPAREN){
-			    print_error("Expected \"(\"", token, type);
-			    free_node(np);
-			    return 0;
-			}
-			type = get_token(fp, token);
-			if (type != NUMBER){
-			    print_error("Expected integer", token, type);
-			    free_node(np);
-			    return 0;
-			}
-			ep->value = atoi(token);
-			type = get_token(fp, token);
-			if (type != RIGHTPAREN){
-			    print_error("Expected \")\"", token, type);
-			    free_node(np);
-			    return 0;
-			}
+    switch (type) {
+    case SEQUENCE:
+	strcpy(syntax, token);
+	if (nexttype == OF) {
+	    strcat(syntax, " ");
+	    strcat(syntax, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	    strcat(syntax, " ");
+	    strcat(syntax, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	}
+	break;
+    case INTEGER:
+	strcpy(syntax, token);
+	if (nexttype == LEFTBRACKET) {
+	    /* if there is an enumeration list, parse it */
+	    while ((type = get_token(fp, token)) != ENDOFFILE) {
+		if (type == RIGHTBRACKET)
+		    break;
+		if (type == LABEL) {
+		    /* this is an enumerated label */
+		    if (np->enums == 0) {
+			ep = np->enums = (struct enum_list *)
+			    xmalloc(sizeof(struct enum_list));
+		    } else {
+			ep->next = (struct enum_list *)
+			    xmalloc(sizeof(struct enum_list));
+			ep = ep->next;
+		    }
+		    ep->next = 0;
+		    /* a reasonable approximation for the length */
+		    ep->label = (char *) xmalloc((unsigned) strlen(token) + 1);
+		    strcpy(ep->label, token);
+		    type = get_token(fp, token);
+		    if (type != LEFTPAREN) {
+			print_error("Expected \"(\"", token, type);
+			free_node(np);
+			return 0;
+		    }
+		    type = get_token(fp, token);
+		    if (type != NUMBER) {
+			print_error("Expected integer", token, type);
+			free_node(np);
+			return 0;
+		    }
+		    ep->value = atoi(token);
+		    type = get_token(fp, token);
+		    if (type != RIGHTPAREN) {
+			print_error("Expected \")\"", token, type);
+			free_node(np);
+			return 0;
 		    }
 		}
-		if (type == ENDOFFILE){
-		    print_error("Expected \"}\"", token, type);
-		    free_node(np);
-		    return 0;
-		}
-		nexttype = get_token(fp, nexttoken);
-	    } else if (nexttype == LEFTPAREN){
-		/* ignore the "constrained integer" for now */
-		nexttype = get_token(fp, nexttoken);
-		nexttype = get_token(fp, nexttoken);
-		nexttype = get_token(fp, nexttoken);
 	    }
-	    break;
-	case OBJID:
-	case OCTETSTR:
-	case NETADDR:
-	case IPADDR:
-	case COUNTER:
-	case GAUGE:
-	case TIMETICKS:
-	case OPAQUE:
-	case NUL:
-	case LABEL:
-	    strcpy(syntax, token);
-	    break;
-	default:
-	    print_error("Bad syntax", token, type);
-	    free_node(np);
-	    return 0;
+	    if (type == ENDOFFILE) {
+		print_error("Expected \"}\"", token, type);
+		free_node(np);
+		return 0;
+	    }
+	    nexttype = get_token(fp, nexttoken);
+	} else if (nexttype == LEFTPAREN) {
+	    /* ignore the "constrained integer" for now */
+	    nexttype = get_token(fp, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	    nexttype = get_token(fp, nexttoken);
+	}
+	break;
+    case OBJID:
+    case OCTETSTR:
+    case NETADDR:
+    case IPADDR:
+    case COUNTER:
+    case GAUGE:
+    case TIMETICKS:
+    case OPAQUE:
+    case NUL:
+    case LABEL:
+	strcpy(syntax, token);
+	break;
+    default:
+	print_error("Bad syntax", token, type);
+	free_node(np);
+	return 0;
     }
-    if (nexttype != ACCESS){
+    if (nexttype != ACCESS) {
 	print_error("Should be ACCESS", nexttoken, nexttype);
 	free_node(np);
 	return 0;
     }
     type = get_token(fp, token);
     if (type != READONLY && type != READWRITE && type != WRITEONLY
-	&& type != NOACCESS){
+	&& type != NOACCESS) {
 	print_error("Bad access type", nexttoken, nexttype);
 	free_node(np);
 	return 0;
     }
     type = get_token(fp, token);
-    if (type != STATUS){
+    if (type != STATUS) {
 	print_error("Should be STATUS", token, nexttype);
 	free_node(np);
 	return 0;
     }
     type = get_token(fp, token);
-    if (type != MANDATORY && type != OPTIONAL && type != OBSOLETE && type != RECOMMENDED){
+    if (type != MANDATORY && type != OPTIONAL && type != OBSOLETE && type != RECOMMENDED) {
 	print_error("Bad status", token, type);
 	free_node(np);
 	return 0;
@@ -898,78 +901,72 @@ parse_objecttype(fp, name)
      */
     type = get_token(fp, token);
     if ((type != DESCRIPTION) && (type != INDEX) && (type != EQUALS)) {
-      print_error("Should be DESCRIPTION, INDEX, or EQUALS", token, nexttype);
-      free_node(np);
-      return 0;
-    }
-
-    if (type == DESCRIPTION) {
-
-      type = get_token(fp, token);
-      if (type != QUOTE) {
-	print_error("Should be Description open quote", token, nexttype);
+	print_error("Should be DESCRIPTION, INDEX, or EQUALS", token, nexttype);
 	free_node(np);
 	return 0;
-      }    
-
-      /* Fetch description string */
-      {
-	int   ReadChar;
+    }
+    if (type == DESCRIPTION) {
 
-	ReadChar = last;
-	/* skip everything until closing quote */
-	while((ReadChar != '"') && (ReadChar != -1)) {
-	  ReadChar = getc(fp);
-	  if (ReadChar == '\n')
-	    Line++;
+	type = get_token(fp, token);
+	if (type != QUOTE) {
+	    print_error("Should be Description open quote", token, nexttype);
+	    free_node(np);
+	    return 0;
+	}
+	/* Fetch description string */
+	{
+	    int ReadChar;
+
+	    ReadChar = last;
+	    /* skip everything until closing quote */
+	    while ((ReadChar != '"') && (ReadChar != -1)) {
+		ReadChar = getc(fp);
+		if (ReadChar == '\n')
+		    Line++;
+	    }
+	    last = ' ';
 	}
-	last = ' ';
-      }
-      /* ASSERT:  Done with description. */
-      type = get_token(fp, token);
+	/* ASSERT:  Done with description. */
+	type = get_token(fp, token);
     }
-
     if ((type != INDEX) && (type != EQUALS)) {
-      print_error("Should be INDEX, or EQUALS", token, nexttype);
-      free_node(np);
-      return 0;
-    }
-
-    if (type == INDEX) {
-
-      /* Scarf INDEX */
-
-      type = get_token(fp, token);
-      if (type != LEFTBRACKET){
-	print_error("Should be INDEX left brace", token, type);
+	print_error("Should be INDEX, or EQUALS", token, nexttype);
 	free_node(np);
 	return 0;
-      }
+    }
+    if (type == INDEX) {
 
-      /* Fetch description string */
-      {
-	int   ReadChar;
+	/* Scarf INDEX */
 
-	ReadChar = last;
-	/* skip everything until closing quote */
-	while((ReadChar != '}') && (ReadChar != -1)) {
-	  ReadChar = getc(fp);
-	  if (ReadChar == '\n')
-	    Line++;
+	type = get_token(fp, token);
+	if (type != LEFTBRACKET) {
+	    print_error("Should be INDEX left brace", token, type);
+	    free_node(np);
+	    return 0;
+	}
+	/* Fetch description string */
+	{
+	    int ReadChar;
+
+	    ReadChar = last;
+	    /* skip everything until closing quote */
+	    while ((ReadChar != '}') && (ReadChar != -1)) {
+		ReadChar = getc(fp);
+		if (ReadChar == '\n')
+		    Line++;
+	    }
+	    last = ' ';
 	}
-	last = ' ';
-      }
-      /* ASSERT:  Done with INDEX. */
-      type = get_token(fp, token);
+	/* ASSERT:  Done with INDEX. */
+	type = get_token(fp, token);
     }
-
-    if (type != EQUALS){
+    if (type != EQUALS) {
 	print_error("Bad format", token, type);
 	free_node(np);
 	return 0;
     }
     length = getoid(fp, SubOid, 32);
-    if (length > 1 && length <= 32){
+    if (length > 1 && length <= 32) {
 	/* just take the last pair in the oid list */
 	if (SubOid[length - 2].label)
 	    strncpy(np->parent, SubOid[length - 2].label, 64);
@@ -979,12 +976,12 @@ parse_objecttype(fp, name)
 	else
 	    print_error("Warning: This entry is pretty silly", np->label, type);
     } else {
-	print_error("No end to oid", (char *)NULL, type);
+	print_error("No end to oid", (char *) NULL, type);
 	free_node(np);
 	np = 0;
     }
     /* free oid array */
-    for(count = 0; count < length; count++){
+    for (count = 0; count < length; count++) {
 	if (SubOid[count].label)
 	    xfree(SubOid[count].label);
 	SubOid[count].label = 0;
@@ -1002,86 +999,86 @@ static
 #endif
 struct node *
 parse(fp)
-    FILE *fp;
+     FILE *fp;
 {
     char token[64];
     char name[64];
-    int	type = 1;
-    struct node *np=NULL, *root = NULL;
+    int type = 1;
+    struct node *np = NULL, *root = NULL;
 
     hash_init();
 
-    while(type != ENDOFFILE){
+    while (type != ENDOFFILE) {
 	type = get_token(fp, token);
-	if (type != LABEL){
-	    if (type == ENDOFFILE){
+	if (type != LABEL) {
+	    if (type == ENDOFFILE) {
 		return root;
 	    }
 	    print_error(token, "is a reserved word", type);
 	    return NULL;
 	}
 	strncpy(name, token, 64);
 	type = get_token(fp, token);
-	if (type == OBJTYPE){
-	    if (root == NULL){
+	if (type == OBJTYPE) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_objecttype(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of object type", (char *)NULL, type);
+		if (np == NULL) {
+		    print_error("Bad parse of object type", (char *) NULL, type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_objecttype(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of objecttype", (char *)NULL, type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of objecttype", (char *) NULL, type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == OBJID){
-	    if (root == NULL){
+	} else if (type == OBJID) {
+	    if (root == NULL) {
 		/* first link in chain */
 		np = root = parse_objectid(fp, name);
-		if (np == NULL){
-		    print_error("Bad parse of object id", (char *)NULL, type);
+		if (np == NULL) {
+		    print_error("Bad parse of object id", (char *) NULL, type);
 		    return NULL;
 		}
 	    } else {
 		np->next = parse_objectid(fp, name);
-		if (np->next == NULL){
-		    print_error("Bad parse of object type", (char *)NULL, type);
+		if (np->next == NULL) {
+		    print_error("Bad parse of object type", (char *) NULL, type);
 		    return NULL;
 		}
 	    }
 	    /* now find end of chain */
-	    while(np->next)
+	    while (np->next)
 		np = np->next;
-	} else if (type == EQUALS){
+	} else if (type == EQUALS) {
 	    type = parse_asntype(fp);
-	} else if (type == ENDOFFILE){
+	} else if (type == ENDOFFILE) {
 	    break;
 	} else {
-	    print_error("Bad operator", (char *)NULL, type);
+	    print_error("Bad operator", (char *) NULL, type);
 	    return NULL;
 	}
     }
 #ifdef TEST
-{
-    struct enum_list *ep;
-    
-    for(np = root; np; np = np->next){
-	printf("%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
+    {
+	struct enum_list *ep;
+
+	for (np = root; np; np = np->next) {
+	    printf("%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
 		np->type);
-	if (np->enums){
-	    printf("Enums: \n");
-	    for(ep = np->enums; ep; ep = ep->next){
-		printf("%s(%d)\n", ep->label, ep->value);
+	    if (np->enums) {
+		printf("Enums: \n");
+		for (ep = np->enums; ep; ep = ep->next) {
+		    printf("%s(%d)\n", ep->label, ep->value);
+		}
 	    }
 	}
     }
-}
 #endif /* TEST */
     return root;
 }
@@ -1098,29 +1095,25 @@ read_mib(char *filename)
     fp = fopen(filename, "r");
     if (fp == NULL) {
 	snmplib_debug(1, "init_mib: %s: %s\n", filename, xstrerror());
-	return(NULL);
+	return (NULL);
     }
-
-    mbuf[0]='\0';
-    while ( (p=fgets(mbuf, 256, fp)) && strncmp(mbuf, CURRENT_MIB_VERSION,
-		strlen(CURRENT_MIB_VERSION)));
+    mbuf[0] = '\0';
+    while ((p = fgets(mbuf, 256, fp)) && strncmp(mbuf, CURRENT_MIB_VERSION,
+	    strlen(CURRENT_MIB_VERSION)));
     if (!p) {
-        snmplib_debug(0, "Bad MIB version or tag missing, install original!\n");
-        return NULL;
+	snmplib_debug(0, "Bad MIB version or tag missing, install original!\n");
+	return NULL;
     }
-
     if (!strcmp(mbuf, CURRENT_MIB_VERSION)) {
-	snmplib_debug(0, "You need to update your MIB!\n");	
+	snmplib_debug(0, "You need to update your MIB!\n");
 	return NULL;
     }
     nodes = parse(fp);
-    if (!nodes){
+    if (!nodes) {
 	snmplib_debug(0, "Mib table is bad.  Exiting\n");
 	return NULL;
     }
     tree = build_tree(nodes);
     fclose(fp);
-    return(tree);
+    return (tree);
 }
-
-
@@ -1,3 +1,5 @@
+
+
 /**********************************************************************
  *
  *           Copyright 1997 by Carnegie Mellon University
@@ -77,16 +79,19 @@
 #include "snmp-internal.h"
 #include "snmp_impl.h"
 #include "snmp_session.h"
-
+#if 0
 #include "mibii.h"
 #include "snmp_dump.h"
+#endif
 #include "snmp_error.h"
 #include "snmp_vars.h"
 #include "snmp_pdu.h"
 #include "snmp_msg.h"
 
 #include "snmp_api.h"
+#if 0
 #include "snmp_client.h"
+#endif
 #include "snmp_api_error.h"
 #include "snmp_api_util.h"
 
@@ -95,14 +100,15 @@
 extern int snmp_errno;
 
 
-/*#define DEBUG_API 1*/
+/*#define DEBUG_API 1 */
 
 /*
  * RFC 1906: Transport Mappings for SNMPv2
  */
 
 
-oid default_enterprise[] = {1, 3, 6, 1, 4, 1, 3, 1, 1}; /* enterprises.cmu.systems.cmuSNMP */
+oid default_enterprise[] =
+{1, 3, 6, 1, 4, 1, 3, 1, 1};	/* enterprises.cmu.systems.cmuSNMP */
 
 #define DEFAULT_COMMUNITY   "public"
 #define DEFAULT_RETRIES	    4
@@ -122,32 +128,35 @@ struct session_list *Sessions = NULL;
  */
 static int Reqid = 0;
 
-static void init_snmp(void) 
+static void 
+init_snmp(void)
 {
-  struct timeval tv;
+    struct timeval tv;
 
-  gettimeofday(&tv, (struct timezone *)0);
-  squid_srandom(tv.tv_sec ^ tv.tv_usec);
-  Reqid = squid_random();
+    gettimeofday(&tv, (struct timezone *) 0);
+    squid_srandom(tv.tv_sec ^ tv.tv_usec);
+    Reqid = squid_random();
 }
 
 
 /*
  * Free each element in the input request list.
  */
-static void free_request_list(rp)
-    struct request_list *rp;
+static void 
+free_request_list(rp)
+     struct request_list *rp;
 {
     struct request_list *orp;
 
-    while(rp){
+    while (rp) {
 	orp = rp;
 	rp = rp->next_request;
 	if (orp->pdu != NULL)
 	    snmp_free_pdu(orp->pdu);
-	xfree((char *)orp);
+	xfree((char *) orp);
     }
 }
+
 #endif
 
 /**********************************************************************/
@@ -160,179 +169,173 @@ static void free_request_list(rp)
  * and snmp_errno is set to the appropriate error code.
  */
 #if 0
-struct snmp_session *snmp_open(struct snmp_session *session)
+struct snmp_session *
+snmp_open(struct snmp_session *session)
 {
-  struct session_list *slp;
-  struct snmp_internal_session *isp;
-  u_char *cp;
-  int sd;
-  u_int addr;
-  struct sockaddr_in	me;
-  struct hostent *hp;
-  struct servent *servp;
-
-  if (Reqid == 0)
-    init_snmp();
-
-  /* Copy session structure and link into list */
-  slp = (struct session_list *)xmalloc(sizeof(struct session_list));
-  if (slp == NULL) {
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-
-  /* Internal session */
-  isp = (struct snmp_internal_session *)xmalloc(sizeof(struct snmp_internal_session));
-  if (isp == NULL) {
-    xfree(slp);
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-
-  slp->internal = isp;
-  memset((char *)isp, '\0', sizeof(struct snmp_internal_session));
-  slp->internal->sd = -1; /* mark it not set */
-
-  /* The actual session */
-  slp->session = (struct snmp_session *)xmalloc(sizeof(struct snmp_session));
-  if (slp->session == NULL) {
-    xfree(isp);
-    xfree(slp);
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-
-  xmemcpy((char *)slp->session, (char *)session, sizeof(struct snmp_session));
-  session = slp->session;
-  /* now link it in. */
-  slp->next = Sessions;
-  Sessions = slp;
-
-  /*
-   * session now points to the new structure that still contains pointers to
-   * data allocated elsewhere.  Some of this data is copied to space malloc'd
-   * here, and the pointer replaced with the new one.
-   */
-
-  if (session->peername != NULL) {
-    cp = (u_char *)xmalloc((unsigned)strlen(session->peername) + 1);
-    if (cp == NULL) {
-      xfree(slp->session);
-      xfree(isp);
-      xfree(slp);
-      snmp_set_api_error(SNMPERR_OS_ERR);
-      return(NULL);
+    struct session_list *slp;
+    struct snmp_internal_session *isp;
+    u_char *cp;
+    int sd;
+    u_int addr;
+    struct sockaddr_in me;
+    struct hostent *hp;
+    struct servent *servp;
+
+    if (Reqid == 0)
+	init_snmp();
+
+    /* Copy session structure and link into list */
+    slp = (struct session_list *) xmalloc(sizeof(struct session_list));
+    if (slp == NULL) {
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
     }
-
-    strcpy((char *)cp, session->peername);
-    session->peername = (char *)cp;
-  }
-
-  /* Fill in defaults if necessary */
-  if (session->community_len != SNMP_DEFAULT_COMMUNITY_LEN) {
-    cp = (u_char *)xmalloc((unsigned)session->community_len);
-    if (cp)
-      xmemcpy((char *)cp, (char *)session->community, session->community_len);
-  } else {
-    session->community_len = strlen(DEFAULT_COMMUNITY);
-    cp = (u_char *)xmalloc((unsigned)session->community_len);
-    if (cp)
-      xmemcpy((char *)cp, (char *)DEFAULT_COMMUNITY, 
-	     session->community_len);
-  }
-  if (cp == NULL) {
-    xfree(session->peername);
-    xfree(slp->session);
-    xfree(isp);
-    xfree(slp);
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-
-  session->community = cp;	/* replace pointer with pointer to new data */
-
-  if (session->retries == SNMP_DEFAULT_RETRIES)
-    session->retries = DEFAULT_RETRIES;
-  if (session->timeout == SNMP_DEFAULT_TIMEOUT)
-    session->timeout = DEFAULT_TIMEOUT;
-  isp->requests = NULL;
-
-  /* Set up connections */
-  sd = socket(AF_INET, SOCK_DGRAM, 0);
-  if (sd < 0) {
-    perror("socket");
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    if (!snmp_close(session)) {
-      snmplib_debug(5, "Couldn't abort session: %s. Exiting\n", 
-	      api_errstring(snmp_errno));
-      exit(1);
+    /* Internal session */
+    isp = (struct snmp_internal_session *) xmalloc(sizeof(struct snmp_internal_session));
+    if (isp == NULL) {
+	xfree(slp);
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
+    slp->internal = isp;
+    memset((char *) isp, '\0', sizeof(struct snmp_internal_session));
+    slp->internal->sd = -1;	/* mark it not set */
+
+    /* The actual session */
+    slp->session = (struct snmp_session *) xmalloc(sizeof(struct snmp_session));
+    if (slp->session == NULL) {
+	xfree(isp);
+	xfree(slp);
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
     }
-    return(NULL);
-  }
+    xmemcpy((char *) slp->session, (char *) session, sizeof(struct snmp_session));
+    session = slp->session;
+    /* now link it in. */
+    slp->next = Sessions;
+    Sessions = slp;
 
-#ifdef SO_BSDCOMPAT
-  /* Patch for Linux.  Without this, UDP packets that fail get an ICMP
-   * response.  Linux turns the failed ICMP response into an error message
-   * and return value, unlike all other OS's.
-   */
-  {
-    int one=1;
-    setsockopt(sd, SOL_SOCKET, SO_BSDCOMPAT, &one, sizeof(one));
-  }
-#endif /* SO_BSDCOMPAT */
+    /*
+     * session now points to the new structure that still contains pointers to
+     * data allocated elsewhere.  Some of this data is copied to space malloc'd
+     * here, and the pointer replaced with the new one.
+     */
 
-  isp->sd = sd;
-  if (session->peername != SNMP_DEFAULT_PEERNAME) {
-    if ((addr = inet_addr(session->peername)) != -1) {
-      xmemcpy((char *)&isp->addr.sin_addr, (char *)&addr, 
-	     sizeof(isp->addr.sin_addr));
+    if (session->peername != NULL) {
+	cp = (u_char *) xmalloc((unsigned) strlen(session->peername) + 1);
+	if (cp == NULL) {
+	    xfree(slp->session);
+	    xfree(isp);
+	    xfree(slp);
+	    snmp_set_api_error(SNMPERR_OS_ERR);
+	    return (NULL);
+	}
+	strcpy((char *) cp, session->peername);
+	session->peername = (char *) cp;
+    }
+    /* Fill in defaults if necessary */
+    if (session->community_len != SNMP_DEFAULT_COMMUNITY_LEN) {
+	cp = (u_char *) xmalloc((unsigned) session->community_len);
+	if (cp)
+	    xmemcpy((char *) cp, (char *) session->community, session->community_len);
     } else {
-      hp = gethostbyname(session->peername);
-      if (hp == NULL){
-	snmplib_debug(3, "unknown host: %s\n", session->peername);
-	snmp_errno = SNMPERR_BAD_ADDRESS;
-	if (!snmp_close(session)){
-	  snmplib_debug(3, "Couldn't abort session: %s. Exiting\n", 
-		  api_errstring(snmp_errno));
-	  exit(2);
+	session->community_len = strlen(DEFAULT_COMMUNITY);
+	cp = (u_char *) xmalloc((unsigned) session->community_len);
+	if (cp)
+	    xmemcpy((char *) cp, (char *) DEFAULT_COMMUNITY,
+		session->community_len);
+    }
+    if (cp == NULL) {
+	xfree(session->peername);
+	xfree(slp->session);
+	xfree(isp);
+	xfree(slp);
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
+    session->community = cp;	/* replace pointer with pointer to new data */
+
+    if (session->retries == SNMP_DEFAULT_RETRIES)
+	session->retries = DEFAULT_RETRIES;
+    if (session->timeout == SNMP_DEFAULT_TIMEOUT)
+	session->timeout = DEFAULT_TIMEOUT;
+    isp->requests = NULL;
+
+    /* Set up connections */
+    sd = socket(AF_INET, SOCK_DGRAM, 0);
+    if (sd < 0) {
+	perror("socket");
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	if (!snmp_close(session)) {
+	    snmplib_debug(5, "Couldn't abort session: %s. Exiting\n",
+		api_errstring(snmp_errno));
+	    exit(1);
 	}
-	return(NULL);
-      } else {
-	xmemcpy((char *)&isp->addr.sin_addr, (char *)hp->h_addr, 
-	       hp->h_length);
-      }
+	return (NULL);
+    }
+#ifdef SO_BSDCOMPAT
+    /* Patch for Linux.  Without this, UDP packets that fail get an ICMP
+     * response.  Linux turns the failed ICMP response into an error message
+     * and return value, unlike all other OS's.
+     */
+    {
+	int one = 1;
+	setsockopt(sd, SOL_SOCKET, SO_BSDCOMPAT, &one, sizeof(one));
     }
+#endif /* SO_BSDCOMPAT */
 
-    isp->addr.sin_family = AF_INET;
-    if (session->remote_port == SNMP_DEFAULT_REMPORT) {
-      servp = getservbyname("snmp", "udp");
-      if (servp != NULL){
-	isp->addr.sin_port = servp->s_port;
-      } else {
-	isp->addr.sin_port = htons(SNMP_PORT);
-      }
+    isp->sd = sd;
+    if (session->peername != SNMP_DEFAULT_PEERNAME) {
+	if ((addr = inet_addr(session->peername)) != -1) {
+	    xmemcpy((char *) &isp->addr.sin_addr, (char *) &addr,
+		sizeof(isp->addr.sin_addr));
+	} else {
+	    hp = gethostbyname(session->peername);
+	    if (hp == NULL) {
+		snmplib_debug(3, "unknown host: %s\n", session->peername);
+		snmp_errno = SNMPERR_BAD_ADDRESS;
+		if (!snmp_close(session)) {
+		    snmplib_debug(3, "Couldn't abort session: %s. Exiting\n",
+			api_errstring(snmp_errno));
+		    exit(2);
+		}
+		return (NULL);
+	    } else {
+		xmemcpy((char *) &isp->addr.sin_addr, (char *) hp->h_addr,
+		    hp->h_length);
+	    }
+	}
+
+	isp->addr.sin_family = AF_INET;
+	if (session->remote_port == SNMP_DEFAULT_REMPORT) {
+	    servp = getservbyname("snmp", "udp");
+	    if (servp != NULL) {
+		isp->addr.sin_port = servp->s_port;
+	    } else {
+		isp->addr.sin_port = htons(SNMP_PORT);
+	    }
+	} else {
+	    isp->addr.sin_port = htons(session->remote_port);
+	}
     } else {
-      isp->addr.sin_port = htons(session->remote_port);
+	isp->addr.sin_addr.s_addr = SNMP_DEFAULT_ADDRESS;
     }
-  } else {
-    isp->addr.sin_addr.s_addr = SNMP_DEFAULT_ADDRESS;
-  }
-
-  memset(&me, '\0', sizeof(me));
-  me.sin_family = AF_INET;
-  me.sin_addr.s_addr = INADDR_ANY;
-  me.sin_port = htons(session->local_port);
-  if (bind(sd, (struct sockaddr *)&me, sizeof(me)) != 0) {
-    perror("bind");
-    snmp_errno = SNMPERR_BAD_LOCPORT;
-    if (!snmp_close(session)) {
-      snmplib_debug(3, "Couldn't abort session: %s. Exiting\n", 
-	      api_errstring(snmp_errno));
-      exit(3);
+
+    memset(&me, '\0', sizeof(me));
+    me.sin_family = AF_INET;
+    me.sin_addr.s_addr = INADDR_ANY;
+    me.sin_port = htons(session->local_port);
+    if (bind(sd, (struct sockaddr *) &me, sizeof(me)) != 0) {
+	perror("bind");
+	snmp_errno = SNMPERR_BAD_LOCPORT;
+	if (!snmp_close(session)) {
+	    snmplib_debug(3, "Couldn't abort session: %s. Exiting\n",
+		api_errstring(snmp_errno));
+	    exit(3);
+	}
+	return (NULL);
     }
-    return(NULL);
-  }
-  return(session);
+    return (session);
 }
 
 
@@ -341,41 +344,42 @@ struct snmp_session *snmp_open(struct snmp_session *session)
  * dequeues any pending requests, and closes any sockets allocated for
  * the session.  Returns 0 on error, 1 otherwise.
  */
-int snmp_close(struct snmp_session *session)
+int 
+snmp_close(struct snmp_session *session)
 {
-  struct session_list *slp = NULL, *oslp = NULL;
-
-  if (Sessions->session == session) {	/* If first entry */
-    slp = Sessions;
-    Sessions = slp->next;
-  } else {
-    for(slp = Sessions; slp; slp = slp->next){
-      if (slp->session == session){
-	if (oslp)   /* if we found entry that points here */
-	  oslp->next = slp->next;	/* link around this entry */
-	break;
-      }
-      oslp = slp;
+    struct session_list *slp = NULL, *oslp = NULL;
+
+    if (Sessions->session == session) {		/* If first entry */
+	slp = Sessions;
+	Sessions = slp->next;
+    } else {
+	for (slp = Sessions; slp; slp = slp->next) {
+	    if (slp->session == session) {
+		if (oslp)	/* if we found entry that points here */
+		    oslp->next = slp->next;	/* link around this entry */
+		break;
+	    }
+	    oslp = slp;
+	}
+    }
+
+    /* If we found the session, free all data associated with it */
+    if (slp) {
+	if (slp->session->community != NULL)
+	    xfree((char *) slp->session->community);
+	if (slp->session->peername != NULL)
+	    xfree((char *) slp->session->peername);
+	xfree((char *) slp->session);
+	if (slp->internal->sd != -1)
+	    close(slp->internal->sd);
+	free_request_list(slp->internal->requests);
+	xfree((char *) slp->internal);
+	xfree((char *) slp);
+    } else {
+	snmp_errno = SNMPERR_BAD_SESSION;
+	return (0);
     }
-  }
-
-  /* If we found the session, free all data associated with it */
-  if (slp) {
-    if (slp->session->community != NULL)
-      xfree((char *)slp->session->community);
-    if(slp->session->peername != NULL)
-      xfree((char *)slp->session->peername);
-    xfree((char *)slp->session);
-    if (slp->internal->sd != -1)
-      close(slp->internal->sd);
-    free_request_list(slp->internal->requests);
-    xfree((char *)slp->internal);
-    xfree((char *)slp);
-  } else {
-    snmp_errno = SNMPERR_BAD_SESSION;
-    return(0);
-  }
-  return(1);
+    return (1);
 }
 #endif
 
@@ -387,53 +391,54 @@ int snmp_close(struct snmp_session *session)
  */
 int
 snmp_build(session, pdu, packet, out_length)
-    struct snmp_session	*session;
-    struct snmp_pdu	*pdu;
-    u_char *packet;
-    int			*out_length;
+     struct snmp_session *session;
+     struct snmp_pdu *pdu;
+     u_char *packet;
+     int *out_length;
 {
     u_char *bufp;
 
     bufp = snmp_msg_Encode(packet, out_length,
-			   session->community, session->community_len, 
-			   session->Version,
-			   pdu);
-    snmplib_debug(8,"LIBSNMP: snmp_build():  Packet len %d (requid %d)\n",
-	   *out_length, pdu->reqid);
+	session->community, session->community_len,
+	session->Version,
+	pdu);
+    snmplib_debug(8, "LIBSNMP: snmp_build():  Packet len %d (requid %d)\n",
+	*out_length, pdu->reqid);
 
     if (bufp == NULL)
-      return(-1);
+	return (-1);
 
-    return(0);
+    return (0);
 }
 
 /*
  * Parses the packet recieved on the input session, and places the data into
  * the input pdu.  length is the length of the input packet.  If any errors
  * are encountered, NULL is returned.  If not, the community is.
  */
-u_char *snmp_parse(struct snmp_session *session, 
-	       struct snmp_pdu *pdu, 
-	       u_char *data, 
-	       int length)
+u_char *
+snmp_parse(struct snmp_session * session,
+    struct snmp_pdu * pdu,
+    u_char * data,
+    int length)
 {
     u_char Community[128];
     u_char *bufp;
     int CommunityLen = 128;
 
     /* Decode the entire message. */
-    data = snmp_msg_Decode(data, &length, 
-			   Community, &CommunityLen, 
-			   &session->Version, pdu);
+    data = snmp_msg_Decode(data, &length,
+	Community, &CommunityLen,
+	&session->Version, pdu);
     if (data == NULL)
-	return(NULL);
+	return (NULL);
 
-   bufp = (u_char *)xmalloc(CommunityLen+1);
-   if (bufp == NULL)
-    return(NULL);
+    bufp = (u_char *) xmalloc(CommunityLen + 1);
+    if (bufp == NULL)
+	return (NULL);
 
-   strcpy((char *)bufp, (char *)Community);
-   return(bufp);
+    strcpy((char *) bufp, (char *) Community);
+    return (bufp);
 }
 
 /*
@@ -446,127 +451,123 @@ u_char *snmp_parse(struct snmp_session *session,
  * The pdu is freed by snmp_send() unless a failure occured.
  */
 #if 0
-int snmp_send(struct snmp_session *session, struct snmp_pdu *pdu)
+int 
+snmp_send(struct snmp_session *session, struct snmp_pdu *pdu)
 {
     struct session_list *slp;
     struct snmp_internal_session *isp = NULL;
-    u_char  packet[PACKET_LENGTH];
+    u_char packet[PACKET_LENGTH];
     int length = PACKET_LENGTH;
     struct request_list *rp;
     struct timeval tv;
 
-  if (Reqid == 0)
-    init_snmp();
+    if (Reqid == 0)
+	init_snmp();
 
-    for(slp = Sessions; slp; slp = slp->next){
-	if (slp->session == session){
+    for (slp = Sessions; slp; slp = slp->next) {
+	if (slp->session == session) {
 	    isp = slp->internal;
 	    break;
 	}
     }
-    if (isp == NULL){
+    if (isp == NULL) {
 	snmp_errno = SNMPERR_BAD_SESSION;
 	return 0;
     }
-
-    if (pdu->command == SNMP_PDU_GET || 
+    if (pdu->command == SNMP_PDU_GET ||
 	pdu->command == SNMP_PDU_GETNEXT ||
-	pdu->command == SNMP_PDU_RESPONSE || 
+	pdu->command == SNMP_PDU_RESPONSE ||
 	pdu->command == SNMP_PDU_SET) {
 
-      if (pdu->reqid == SNMP_DEFAULT_REQID)
-	pdu->reqid = ++Reqid;
-      if (pdu->errstat == SNMP_DEFAULT_ERRSTAT)
-	pdu->errstat = 0;
-      if (pdu->errindex == SNMP_DEFAULT_ERRINDEX)
-	pdu->errindex = 0;
-
-    } else if (pdu->command == SNMP_PDU_INFORM || 
-	       pdu->command == SNMP_PDU_GETBULK ||
-	       pdu->command == SNMP_PDU_V2TRAP) {
-
-      if (session->Version != SNMP_VERSION_2){
-	snmplib_debug(3, "Cant send SNMPv2 PDU's in SNMP message.\n");
-	snmp_errno = SNMPERR_GENERR;/* Fix this XXXXX */
-	return 0;
-      }
-      if (pdu->reqid == SNMP_DEFAULT_REQID)
-	pdu->reqid = ++Reqid;
-      if (pdu->errstat == SNMP_DEFAULT_ERRSTAT)
-	pdu->errstat = 0;
-      if (pdu->errindex == SNMP_DEFAULT_ERRINDEX)
-	pdu->errindex = 0;
+	if (pdu->reqid == SNMP_DEFAULT_REQID)
+	    pdu->reqid = ++Reqid;
+	if (pdu->errstat == SNMP_DEFAULT_ERRSTAT)
+	    pdu->errstat = 0;
+	if (pdu->errindex == SNMP_DEFAULT_ERRINDEX)
+	    pdu->errindex = 0;
+
+    } else if (pdu->command == SNMP_PDU_INFORM ||
+	    pdu->command == SNMP_PDU_GETBULK ||
+	pdu->command == SNMP_PDU_V2TRAP) {
+
+	if (session->Version != SNMP_VERSION_2) {
+	    snmplib_debug(3, "Cant send SNMPv2 PDU's in SNMP message.\n");
+	    snmp_errno = SNMPERR_GENERR;	/* Fix this XXXXX */
+	    return 0;
+	}
+	if (pdu->reqid == SNMP_DEFAULT_REQID)
+	    pdu->reqid = ++Reqid;
+	if (pdu->errstat == SNMP_DEFAULT_ERRSTAT)
+	    pdu->errstat = 0;
+	if (pdu->errindex == SNMP_DEFAULT_ERRINDEX)
+	    pdu->errindex = 0;
 
     } else {
 	/* fill in trap defaults */
-      pdu->reqid = 1;	/* give a bogus non-error reqid for traps */
-      if (pdu->enterprise_length == SNMP_DEFAULT_ENTERPRISE_LENGTH) {
-	pdu->enterprise = (oid *)xmalloc(sizeof(DEFAULT_ENTERPRISE));
-	xmemcpy((char *)pdu->enterprise, (char *)DEFAULT_ENTERPRISE, 
-	       sizeof(DEFAULT_ENTERPRISE));
-	pdu->enterprise_length = sizeof(DEFAULT_ENTERPRISE)/sizeof(oid);
-      }
-      if (pdu->time == SNMP_DEFAULT_TIME)
-	pdu->time = DEFAULT_TIME;
+	pdu->reqid = 1;		/* give a bogus non-error reqid for traps */
+	if (pdu->enterprise_length == SNMP_DEFAULT_ENTERPRISE_LENGTH) {
+	    pdu->enterprise = (oid *) xmalloc(sizeof(DEFAULT_ENTERPRISE));
+	    xmemcpy((char *) pdu->enterprise, (char *) DEFAULT_ENTERPRISE,
+		sizeof(DEFAULT_ENTERPRISE));
+	    pdu->enterprise_length = sizeof(DEFAULT_ENTERPRISE) / sizeof(oid);
+	}
+	if (pdu->time == SNMP_DEFAULT_TIME)
+	    pdu->time = DEFAULT_TIME;
     }
 
     if (pdu->address.sin_addr.s_addr == SNMP_DEFAULT_ADDRESS) {
-      if (isp->addr.sin_addr.s_addr != SNMP_DEFAULT_ADDRESS) {
-	xmemcpy((char *)&pdu->address, (char *)&isp->addr, 		 
-	       sizeof(pdu->address));
-      } else {
-	snmplib_debug(3, "No remote IP address specified\n");
-	snmp_errno = SNMPERR_BAD_ADDRESS;
-	return 0;
-      }
+	if (isp->addr.sin_addr.s_addr != SNMP_DEFAULT_ADDRESS) {
+	    xmemcpy((char *) &pdu->address, (char *) &isp->addr,
+		sizeof(pdu->address));
+	} else {
+	    snmplib_debug(3, "No remote IP address specified\n");
+	    snmp_errno = SNMPERR_BAD_ADDRESS;
+	    return 0;
+	}
     }
-	
     if (snmp_build(session, pdu, packet, &length) < 0) {
-      snmplib_debug(3, "Error building packet\n");
-      snmp_errno = SNMPERR_GENERR;
-      return 0;
+	snmplib_debug(3, "Error building packet\n");
+	snmp_errno = SNMPERR_GENERR;
+	return 0;
     }
-
     snmp_dump(packet, length, "sending", pdu->address.sin_addr);
 
-    gettimeofday(&tv, (struct timezone *)0);
-    if (sendto(isp->sd, (char *)packet, length, 0, 
-	       (struct sockaddr *)&pdu->address, sizeof(pdu->address)) < 0){
-      perror("sendto");
-      snmp_errno = SNMPERR_GENERR;
-      return 0;
+    gettimeofday(&tv, (struct timezone *) 0);
+    if (sendto(isp->sd, (char *) packet, length, 0,
+	    (struct sockaddr *) &pdu->address, sizeof(pdu->address)) < 0) {
+	perror("sendto");
+	snmp_errno = SNMPERR_GENERR;
+	return 0;
     }
+    snmplib_debug(6, "LIBSNMP:  Sent PDU %s, Reqid %d\n",
+	snmp_pdu_type(pdu), pdu->reqid);
 
-    snmplib_debug(6,"LIBSNMP:  Sent PDU %s, Reqid %d\n", 
-	   snmp_pdu_type(pdu), pdu->reqid);
-
-    if (pdu->command == SNMP_PDU_GET || 
+    if (pdu->command == SNMP_PDU_GET ||
 	pdu->command == SNMP_PDU_GETNEXT ||
-	pdu->command == SNMP_PDU_SET || 
+	pdu->command == SNMP_PDU_SET ||
 	pdu->command == SNMP_PDU_GETBULK ||
 	pdu->command == SNMP_PDU_INFORM) {
 
-snmplib_debug(6,"LIBSNMP:  Setting up to recieve a response for reqid %d\n", 
-       pdu->reqid);
-
-      /* set up to expect a response */
-      rp = (struct request_list *)xmalloc(sizeof(struct request_list));
-      rp->next_request = isp->requests;
-      isp->requests = rp;
-
-      rp->pdu = pdu;
-      rp->request_id = pdu->reqid;
-      
-      rp->retries = 1;
-      rp->timeout = session->timeout;
-      rp->time = tv;
-      tv.tv_usec += rp->timeout;
-      tv.tv_sec += tv.tv_usec / 1000000L;
-      tv.tv_usec %= 1000000L;
-      rp->expire = tv;
-    }
+	snmplib_debug(6, "LIBSNMP:  Setting up to recieve a response for reqid %d\n",
+	    pdu->reqid);
+
+	/* set up to expect a response */
+	rp = (struct request_list *) xmalloc(sizeof(struct request_list));
+	rp->next_request = isp->requests;
+	isp->requests = rp;
 
-    return(pdu->reqid);
+	rp->pdu = pdu;
+	rp->request_id = pdu->reqid;
+
+	rp->retries = 1;
+	rp->timeout = session->timeout;
+	rp->time = tv;
+	tv.tv_usec += rp->timeout;
+	tv.tv_sec += tv.tv_usec / 1000000L;
+	tv.tv_usec %= 1000000L;
+	rp->expire = tv;
+    }
+    return (pdu->reqid);
 }
 
 /*
@@ -578,90 +579,90 @@ snmplib_debug(6,"LIBSNMP:  Setting up to recieve a response for reqid %d\n",
  */
 void
 snmp_read(fdset)
-    fd_set  *fdset;
+     fd_set *fdset;
 {
     struct session_list *slp;
     struct snmp_session *sp;
     struct snmp_internal_session *isp;
     u_char packet[PACKET_LENGTH];
-    struct sockaddr_in	from;
+    struct sockaddr_in from;
     int length, fromlength;
     struct snmp_pdu *pdu;
     struct request_list *rp, *orp;
     u_char *bufp;
 
-    for(slp = Sessions; slp; slp = slp->next) {
-      if (FD_ISSET(slp->internal->sd, fdset)) {
-	sp = slp->session;
-	isp = slp->internal;
-	fromlength = sizeof from;
-	length = recvfrom(isp->sd, (char *)packet, 
-			  PACKET_LENGTH, 0, (struct sockaddr *)&from, 
-			  &fromlength);
-	if (length == -1)
-	  perror("recvfrom");
-
-	snmp_dump(packet, length, "received", from.sin_addr);
-
-	pdu = snmp_pdu_create(0);
-	pdu->address = from;
-	pdu->reqid = 0;
-
-	/* Parse the incoming packet */
-	bufp = snmp_parse(sp, pdu, packet, length);
-	if (bufp == NULL) {
-	  snmplib_debug(3, "Mangled packet\n");
-	  snmp_free_pdu(pdu);
-	  return;
-	}
-	if (sp->community)
-	  xfree(sp->community);
-	sp->community = bufp;
-	sp->community_len = strlen((char *)bufp);
-
-snmplib_debug(6,"LIBSNMP:  Read PDU %s, ReqId %d\n", snmp_pdu_type(pdu), pdu->reqid);
-
-	if (pdu->command == SNMP_PDU_RESPONSE) {
-	  for(rp = isp->requests; rp; rp = rp->next_request) {
-	    if (rp->request_id == pdu->reqid) {
-snmplib_debug(6,"LIBSNMP:  ReqId %d:  Calling callback\n", pdu->reqid);
-	      if (sp->callback(RECEIVED_MESSAGE, sp, 
-			       pdu->reqid, pdu, 
-			       sp->callback_magic) == 1) {
-		/* successful, so delete request */
-snmplib_debug(6,"LIBSNMP:  ReqId %d:  Success.  Removing ReqId.\n", pdu->reqid);
-		orp = rp;
-		if (isp->requests == orp){
-		  /* first in list */
-		  isp->requests = orp->next_request;
-		} else {
-		  for(rp = isp->requests; rp; rp = rp->next_request){
-		    if (rp->next_request == orp){
-		      /* link around it */
-		      rp->next_request = orp->next_request;	
-		      break;
+    for (slp = Sessions; slp; slp = slp->next) {
+	if (FD_ISSET(slp->internal->sd, fdset)) {
+	    sp = slp->session;
+	    isp = slp->internal;
+	    fromlength = sizeof from;
+	    length = recvfrom(isp->sd, (char *) packet,
+		PACKET_LENGTH, 0, (struct sockaddr *) &from,
+		&fromlength);
+	    if (length == -1)
+		perror("recvfrom");
+
+	    snmp_dump(packet, length, "received", from.sin_addr);
+
+	    pdu = snmp_pdu_create(0);
+	    pdu->address = from;
+	    pdu->reqid = 0;
+
+	    /* Parse the incoming packet */
+	    bufp = snmp_parse(sp, pdu, packet, length);
+	    if (bufp == NULL) {
+		snmplib_debug(3, "Mangled packet\n");
+		snmp_free_pdu(pdu);
+		return;
+	    }
+	    if (sp->community)
+		xfree(sp->community);
+	    sp->community = bufp;
+	    sp->community_len = strlen((char *) bufp);
+
+	    snmplib_debug(6, "LIBSNMP:  Read PDU %s, ReqId %d\n", snmp_pdu_type(pdu), pdu->reqid);
+
+	    if (pdu->command == SNMP_PDU_RESPONSE) {
+		for (rp = isp->requests; rp; rp = rp->next_request) {
+		    if (rp->request_id == pdu->reqid) {
+			snmplib_debug(6, "LIBSNMP:  ReqId %d:  Calling callback\n", pdu->reqid);
+			if (sp->callback(RECEIVED_MESSAGE, sp,
+				pdu->reqid, pdu,
+				sp->callback_magic) == 1) {
+			    /* successful, so delete request */
+			    snmplib_debug(6, "LIBSNMP:  ReqId %d:  Success.  Removing ReqId.\n", pdu->reqid);
+			    orp = rp;
+			    if (isp->requests == orp) {
+				/* first in list */
+				isp->requests = orp->next_request;
+			    } else {
+				for (rp = isp->requests; rp; rp = rp->next_request) {
+				    if (rp->next_request == orp) {
+					/* link around it */
+					rp->next_request = orp->next_request;
+					break;
+				    }
+				}
+			    }
+			    snmp_free_pdu(orp->pdu);
+			    xfree((char *) orp);
+			    /* there shouldn't be another req with the same reqid */
+			    break;
+			}
 		    }
-		  }
 		}
-		snmp_free_pdu(orp->pdu);
-		xfree((char *)orp);
-		/* there shouldn't be another req with the same reqid */
-		break;  
-	      }
+	    } else if (pdu->command == SNMP_PDU_GET ||
+		    pdu->command == SNMP_PDU_GETNEXT ||
+		    pdu->command == TRP_REQ_MSG ||
+		    pdu->command == SNMP_PDU_SET ||
+		    pdu->command == SNMP_PDU_GETBULK ||
+		    pdu->command == SNMP_PDU_INFORM ||
+		pdu->command == SNMP_PDU_V2TRAP) {
+		sp->callback(RECEIVED_MESSAGE, sp, pdu->reqid,
+		    pdu, sp->callback_magic);
 	    }
-	  }
-	} else if (pdu->command == SNMP_PDU_GET || 
-		   pdu->command == SNMP_PDU_GETNEXT ||
-		   pdu->command == TRP_REQ_MSG || 
-		   pdu->command == SNMP_PDU_SET ||
-		   pdu->command == SNMP_PDU_GETBULK ||
-		   pdu->command == SNMP_PDU_INFORM ||
-		   pdu->command == SNMP_PDU_V2TRAP) {
-	  sp->callback(RECEIVED_MESSAGE, sp, pdu->reqid, 
-		       pdu, sp->callback_magic);
+	    snmp_free_pdu(pdu);
 	}
-	snmp_free_pdu(pdu);
-      }
     }
 }
 
@@ -687,10 +688,10 @@ snmplib_debug(6,"LIBSNMP:  ReqId %d:  Success.  Removing ReqId.\n", pdu->reqid);
  */
 int
 snmp_select_info(numfds, fdset, timeout, block)
-    int	    *numfds;
-    fd_set  *fdset;
-    struct timeval *timeout;
-    int	    *block; /* should the select block until input arrives (i.e. no input) */
+     int *numfds;
+     fd_set *fdset;
+     struct timeval *timeout;
+     int *block;		/* should the select block until input arrives (i.e. no input) */
 {
     struct session_list *slp;
     struct snmp_internal_session *isp;
@@ -703,51 +704,50 @@ snmp_select_info(numfds, fdset, timeout, block)
      * For each request outstanding, add it's socket to the fdset,
      * and if it is the earliest timeout to expire, mark it as lowest.
      */
-    for(slp = Sessions; slp; slp = slp->next){
+    for (slp = Sessions; slp; slp = slp->next) {
 
 	active++;
 	isp = slp->internal;
 	if ((isp->sd + 1) > *numfds)
 	    *numfds = (isp->sd + 1);
 	FD_SET(isp->sd, fdset);
-      snmplib_debug(6,"LIBSNMP:  select():  Adding port %d\n", isp->sd);
-	if (isp->requests){
+	snmplib_debug(6, "LIBSNMP:  select():  Adding port %d\n", isp->sd);
+	if (isp->requests) {
 	    /* found another session with outstanding requests */
 	    requests++;
-	    for(rp = isp->requests; rp; rp = rp->next_request){
-		if (!timerisset(&earliest) || 
+	    for (rp = isp->requests; rp; rp = rp->next_request) {
+		if (!timerisset(&earliest) ||
 		    timercmp(&rp->expire, &earliest, <))
 		    earliest = rp->expire;
 	    }
 	}
     }
-      snmplib_debug(6,"LIBSNMP:  Select Info:  %d active, %d requests pending.\n",
-	     active, requests);
+    snmplib_debug(6, "LIBSNMP:  Select Info:  %d active, %d requests pending.\n",
+	active, requests);
 
-    if (requests == 0)	/* if none are active, skip arithmetic */
+    if (requests == 0)		/* if none are active, skip arithmetic */
 	return active;
 
     /*
      * Now find out how much time until the earliest timeout.  This
      * transforms earliest from an absolute time into a delta time, the
      * time left until the select should timeout.
      */
-    gettimeofday(&now, (struct timezone *)0);
-    earliest.tv_sec--;	/* adjust time to make arithmetic easier */
+    gettimeofday(&now, (struct timezone *) 0);
+    earliest.tv_sec--;		/* adjust time to make arithmetic easier */
     earliest.tv_usec += 1000000L;
     earliest.tv_sec -= now.tv_sec;
     earliest.tv_usec -= now.tv_usec;
-    while (earliest.tv_usec >= 1000000L){
+    while (earliest.tv_usec >= 1000000L) {
 	earliest.tv_usec -= 1000000L;
 	earliest.tv_sec += 1;
     }
-    if (earliest.tv_sec < 0){
+    if (earliest.tv_sec < 0) {
 	earliest.tv_sec = 0;
 	earliest.tv_usec = 0;
     }
-
     /* if it was blocking before or our delta time is less, reset timeout */
-    if (*block == 1 || timercmp(&earliest, timeout, <)){
+    if (*block == 1 || timercmp(&earliest, timeout, <)) {
 	*timeout = earliest;
 	*block = 0;
     }
@@ -763,70 +763,69 @@ snmp_select_info(numfds, fdset, timeout, block)
  * from the pdu and is resent.  If there are no more retries available, the 
  * callback for the session is used to alert the user of the timeout.
  */
-void snmp_timeout(void)
+void 
+snmp_timeout(void)
 {
-  struct session_list *slp;
-  struct snmp_session *sp;
-  struct snmp_internal_session *isp;
-  struct request_list *rp, *orp, *freeme = NULL;
-  struct timeval now;
-
-  gettimeofday(&now, (struct timezone *)0);
-
-  /*
-   * For each request outstanding, check to see if it has expired.
-   */
-  for(slp = Sessions; slp; slp = slp->next) {
-    sp = slp->session;
-    isp = slp->internal;
-    orp = NULL;
-snmplib_debug(6,"LIBSNMP:  Checking session %s\n", 
-       (sp->peername != NULL) ? sp->peername : "<NULL>");
-    for(rp = isp->requests; rp; rp = rp->next_request) {
-snmplib_debug(6,"LIBSNMP:  Checking session request %d, expire at %u, Retry %d/%d\n", 
-       rp->request_id, rp->expire.tv_sec, rp->retries, sp->retries);
-
-      if (freeme != NULL) {
-	/* frees rp's after the for loop goes on to the next_request */
-	xfree((char *)freeme);
-	freeme = NULL;
-      }
-
-      if (timercmp(&rp->expire, &now, <)) {
-
-snmplib_debug(6,"LIBSNMP:  Expired.\n");
-
-	/* this timer has expired */
-	if (rp->retries >= sp->retries) {
-	  /* No more chances, delete this entry */
-	  sp->callback(TIMED_OUT, sp, rp->pdu->reqid, 
-		       rp->pdu, sp->callback_magic);
-	  if (orp == NULL) {
-	    isp->requests = rp->next_request;
-	  } else {
-	    orp->next_request = rp->next_request;
-	  }
-	  snmp_free_pdu(rp->pdu);
-	  freeme = rp;
-	  continue;	/* don't update orp below */
-	} else {
-		    u_char  packet[PACKET_LENGTH];
+    struct session_list *slp;
+    struct snmp_session *sp;
+    struct snmp_internal_session *isp;
+    struct request_list *rp, *orp, *freeme = NULL;
+    struct timeval now;
+
+    gettimeofday(&now, (struct timezone *) 0);
+
+    /*
+     * For each request outstanding, check to see if it has expired.
+     */
+    for (slp = Sessions; slp; slp = slp->next) {
+	sp = slp->session;
+	isp = slp->internal;
+	orp = NULL;
+	snmplib_debug(6, "LIBSNMP:  Checking session %s\n",
+	    (sp->peername != NULL) ? sp->peername : "<NULL>");
+	for (rp = isp->requests; rp; rp = rp->next_request) {
+	    snmplib_debug(6, "LIBSNMP:  Checking session request %d, expire at %u, Retry %d/%d\n",
+		rp->request_id, rp->expire.tv_sec, rp->retries, sp->retries);
+
+	    if (freeme != NULL) {
+		/* frees rp's after the for loop goes on to the next_request */
+		xfree((char *) freeme);
+		freeme = NULL;
+	    }
+	    if (timercmp(&rp->expire, &now, <)) {
+
+		snmplib_debug(6, "LIBSNMP:  Expired.\n");
+
+		/* this timer has expired */
+		if (rp->retries >= sp->retries) {
+		    /* No more chances, delete this entry */
+		    sp->callback(TIMED_OUT, sp, rp->pdu->reqid,
+			rp->pdu, sp->callback_magic);
+		    if (orp == NULL) {
+			isp->requests = rp->next_request;
+		    } else {
+			orp->next_request = rp->next_request;
+		    }
+		    snmp_free_pdu(rp->pdu);
+		    freeme = rp;
+		    continue;	/* don't update orp below */
+		} else {
+		    u_char packet[PACKET_LENGTH];
 		    int length = PACKET_LENGTH;
 		    struct timeval tv;
 
-snmplib_debug(6,"LIBSNMP:  Retransmitting.\n");
+		    snmplib_debug(6, "LIBSNMP:  Retransmitting.\n");
 		    /* retransmit this pdu */
 		    rp->retries++;
 		    rp->timeout <<= 1;
-		    if (snmp_build(sp, rp->pdu, packet, &length) < 0){
-		      snmplib_debug(3, "Error building packet\n");
+		    if (snmp_build(sp, rp->pdu, packet, &length) < 0) {
+			snmplib_debug(3, "Error building packet\n");
 		    }
+		    snmp_dump(packet, length,
+			"sending", rp->pdu->address.sin_addr);
 
-		    snmp_dump(packet, length, 
-			      "sending", rp->pdu->address.sin_addr);
-
-		    gettimeofday(&tv, (struct timezone *)0);
-		    if (sendto(isp->sd, (char *)packet, length, 0, (struct sockaddr *)&rp->pdu->address, sizeof(rp->pdu->address)) < 0){
+		    gettimeofday(&tv, (struct timezone *) 0);
+		    if (sendto(isp->sd, (char *) packet, length, 0, (struct sockaddr *) &rp->pdu->address, sizeof(rp->pdu->address)) < 0) {
 			perror("sendto");
 		    }
 		    rp->time = tv;
@@ -838,56 +837,57 @@ snmplib_debug(6,"LIBSNMP:  Retransmitting.\n");
 	    }
 	    orp = rp;
 	}
-	if (freeme != NULL){
-	    xfree((char *)freeme);
+	if (freeme != NULL) {
+	    xfree((char *) freeme);
 	    freeme = NULL;
 	}
     }
 }
 
 
 /* Print some API stats */
-void snmp_api_stats(void *outP)
+void 
+snmp_api_stats(void *outP)
 {
-  struct session_list *slp;
-  struct request_list *rp;
-  struct snmp_internal_session *isp;
-  FILE *out = (FILE *)outP;
-
-  int active = 0;
-  int requests = 0;
-  int count = 0;
-  int rcount = 0;
-
-  fprintf(out, "LIBSNMP: Session List Dump\n");
-  fprintf(out, "LIBSNMP: ----------------------------------------\n");
-  for(slp = Sessions; slp; slp = slp->next){
-
-    isp = slp->internal;
-    active++;
-    count++;
-    fprintf(out, "LIBSNMP: %2d: Host %s\n", count, 
+    struct session_list *slp;
+    struct request_list *rp;
+    struct snmp_internal_session *isp;
+    FILE *out = (FILE *) outP;
+
+    int active = 0;
+    int requests = 0;
+    int count = 0;
+    int rcount = 0;
+
+    fprintf(out, "LIBSNMP: Session List Dump\n");
+    fprintf(out, "LIBSNMP: ----------------------------------------\n");
+    for (slp = Sessions; slp; slp = slp->next) {
+
+	isp = slp->internal;
+	active++;
+	count++;
+	fprintf(out, "LIBSNMP: %2d: Host %s\n", count,
 	    (slp->session->peername == NULL) ? "NULL" : slp->session->peername);
 
-    if (isp->requests) {
-      /* found another session with outstanding requests */
-      requests++;
-      rcount=0;
-      for (rp=isp->requests; rp; rp=rp->next_request) {
-	rcount++;
-	{
-	  struct hostent *hp;
-	  hp = gethostbyaddr((char *)&(rp->pdu->address), 
-			     sizeof(u_int), AF_INET);
-	  fprintf(out, "LIBSNMP: %2d: ReqId %d (%s) (%s)\n", 
-		  rcount, rp->request_id, snmp_pdu_type(rp->pdu),
-		  (hp == NULL) ? "NULL" : hp->h_name);
+	if (isp->requests) {
+	    /* found another session with outstanding requests */
+	    requests++;
+	    rcount = 0;
+	    for (rp = isp->requests; rp; rp = rp->next_request) {
+		rcount++;
+		{
+		    struct hostent *hp;
+		    hp = gethostbyaddr((char *) &(rp->pdu->address),
+			sizeof(u_int), AF_INET);
+		    fprintf(out, "LIBSNMP: %2d: ReqId %d (%s) (%s)\n",
+			rcount, rp->request_id, snmp_pdu_type(rp->pdu),
+			(hp == NULL) ? "NULL" : hp->h_name);
+		}
+	    }
 	}
-      }
+	fprintf(out, "LIBSNMP: ----------------------------------------\n");
     }
-    fprintf(out, "LIBSNMP: ----------------------------------------\n");
-  }
-  fprintf(out, "LIBSNMP: Session List: %d active, %d have requests pending.\n",
-	  active, requests);
+    fprintf(out, "LIBSNMP: Session List: %d active, %d have requests pending.\n",
+	active, requests);
 }
 #endif
@@ -44,51 +44,56 @@
 
 int snmp_errno = 0;
 
-static char *api_errors[17] = {
-  "Unknown Error",
-  "Generic Error", 
-  "Invalid local port",
-  "Unknown host",
-  "Unknown session",
-  "Too Long",
+static char *api_errors[17] =
+{
+    "Unknown Error",
+    "Generic Error",
+    "Invalid local port",
+    "Unknown host",
+    "Unknown session",
+    "Too Long",
+
+    "Encoding ASN.1 Information",	/* 6 */
+    "Decoding ASN.1 Information",	/* 7 */
+    "PDU Translation error",
+    "OS Error",
+    "Invalid Textual OID",
 
-  "Encoding ASN.1 Information", /* 6 */
-  "Decoding ASN.1 Information", /* 7 */
-  "PDU Translation error",
-  "OS Error",
-  "Invalid Textual OID",
-  
-  "Unable to fix PDU",
-  "Unsupported SNMP Type",
-  "Unable to parse PDU",
-  "Packet Error",
-  "No Response From Host",
+    "Unable to fix PDU",
+    "Unsupported SNMP Type",
+    "Unable to parse PDU",
+    "Packet Error",
+    "No Response From Host",
 
 
-  "Unknown Error"
+    "Unknown Error"
 };
 
-void snmp_set_api_error(int x)
+void 
+snmp_set_api_error(int x)
 {
-  snmp_errno = x;
+    snmp_errno = x;
 }
 
-char *snmp_api_error(int err)
+char *
+snmp_api_error(int err)
 {
-  int foo = (err * -1);
-  if ((foo < SNMPERR_GENERR) ||
-      (foo > SNMPERR_LAST))
-    foo=0;
+    int foo = (err * -1);
+    if ((foo < SNMPERR_GENERR) ||
+	(foo > SNMPERR_LAST))
+	foo = 0;
 
-  return(api_errors[foo]);
+    return (api_errors[foo]);
 }
 
-int snmp_api_errno(void)
+int 
+snmp_api_errno(void)
 {
-  return(snmp_errno);
+    return (snmp_errno);
 }
 
-char *api_errstring(int snmp_errnumber)
+char *
+api_errstring(int snmp_errnumber)
 {
-  return(snmp_api_error(snmp_errnumber));
+    return (snmp_api_error(snmp_errnumber));
 }
@@ -33,37 +33,39 @@
 #include "snmp_error.h"
 
 
-static char *error_string[19] = {
-  "No Error",
-  "Response message would have been too large.",
-  "There is no such variable name in this MIB.",
-  "The value given has the wrong type, length, or value",
-  "This variable is read only",
-  "A general failure occured",
+static char *error_string[19] =
+{
+    "No Error",
+    "Response message would have been too large.",
+    "There is no such variable name in this MIB.",
+    "The value given has the wrong type, length, or value",
+    "This variable is read only",
+    "A general failure occured",
 
   /* SNMPv2 Errors */
-  "NOACCESS",
-  "WRONGTYPE",
-  "WRONGLENGTH",
-  "WRONGENCODING",
-  "WRONGVALUE",
-  "NOCREATION",
-  "INCONSISTENTVALUE",
-  "RESOURCEUNAVAILABLE",
-  "COMMITFAILED",
-  "UNDOFAILED",
-  "AUTHORIZATIONERROR",
-  "NOTWRITABLE",
-  "INCONSISTENTNAME",
+    "NOACCESS",
+    "WRONGTYPE",
+    "WRONGLENGTH",
+    "WRONGENCODING",
+    "WRONGVALUE",
+    "NOCREATION",
+    "INCONSISTENTVALUE",
+    "RESOURCEUNAVAILABLE",
+    "COMMITFAILED",
+    "UNDOFAILED",
+    "AUTHORIZATIONERROR",
+    "NOTWRITABLE",
+    "INCONSISTENTNAME",
 
 };
 
-char *snmp_errstring(int errstat)
+char *
+snmp_errstring(int errstat)
 {
-  if ((errstat <= (SNMP_ERR_INCONSISTENTNAME)) && 
-      (errstat >= (SNMP_ERR_NOERROR))) {
-    return error_string[errstat];
-  } else {
-    return "Unknown Error";
-  }
+    if ((errstat <= (SNMP_ERR_INCONSISTENTNAME)) &&
+	(errstat >= (SNMP_ERR_NOERROR))) {
+	return error_string[errstat];
+    } else {
+	return "Unknown Error";
+    }
 }
@@ -87,7 +87,6 @@
 #include "snmp_vars.h"
 #include "snmp_pdu.h"
 #include "snmp_msg.h"
-#include "mibii.h"
 
 
 /* 
@@ -115,7 +114,7 @@
  * data.
  */
 
-#define ASN_PARSE_ERROR(x) { snmpInASNParseErrs_Add(1); return(x); }
+#define ASN_PARSE_ERROR(x) {  return(x); }
 
 /* Encode an SNMP Message
  *
@@ -125,178 +124,175 @@
  *          in the buffer.
  */
 
-u_char *snmp_msg_Encode(u_char *Buffer, int *BufLenP,
-			u_char *Community, int CommLen,
-			int Version,
-			struct snmp_pdu *PDU)
+u_char *
+snmp_msg_Encode(u_char * Buffer, int *BufLenP,
+    u_char * Community, int CommLen,
+    int Version,
+    struct snmp_pdu * PDU)
 {
-  u_char *bufp, *tmp;
-  u_char *PDUHeaderPtr, *VARHeaderPtr;
-  u_char *PDUDataStart, *VARDataStart;
-  u_char *MsgPtr;
-  int FakeArg = 1024;
-
-   snmplib_debug(4, "Buffer=%x BufLenP=%x, buflen=%d\n",Buffer, BufLenP,
-		*BufLenP);
-  /* Header for the entire thing, with a false, large length */
-  bufp = asn_build_header(Buffer, BufLenP, 
-			  (u_char)(ASN_SEQUENCE |
-				   ASN_CONSTRUCTOR), 
-			  (*BufLenP));
-  if (bufp == NULL) {
-    snmplib_debug(4, "snmp_msg_Encode:Error encoding SNMP Message Header (Header)!\n");
-    return(NULL);
-  }
-  MsgPtr = bufp;
-
-  /* Version */
-  bufp = asn_build_int(bufp, BufLenP,
-		       (u_char)(ASN_UNIVERSAL | 
-				ASN_PRIMITIVE |
-				ASN_INTEGER),
-		       (int *)(&Version), sizeof(Version));
-  if (bufp == NULL){
-    snmplib_debug(4, "snmp_msg_Encode:Error encoding SNMP Message Header (Version)!\n");
-    return(NULL);
-  }
-
-  snmplib_debug(8, "snmp_msg_Encode: Encoding community (%s) (%d)\n", Community, CommLen);
-
-  /* Community */
-  bufp = asn_build_string(bufp, BufLenP,
-			  (u_char)(ASN_UNIVERSAL | 
-				   ASN_PRIMITIVE | 
-				   ASN_OCTET_STR), 
-			  Community, CommLen);
-  if (bufp == NULL){
-     snmplib_debug(4, "snmp_msg_Encode:Error encoding SNMP Message Header (Community)!\n");
-    return(NULL);
-  }
-
-  /* Encode the rest. */
-
-  /* A nice header for this PDU. 
-   * Encoded with the wrong length.  We'll fix it later.
-   */
-   snmplib_debug(8, "snmp_msg_Encode:Encoding PDU Header at 0x%x (fake len %d) (%d bytes so far)\n",
-	 bufp, *BufLenP, *BufLenP);
-  PDUHeaderPtr = bufp;
-  bufp = asn_build_header(bufp, BufLenP,
-			  (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 
-			  (*BufLenP));
-  if (bufp == NULL)
-    return(NULL);
-
-  /* Encode this PDU. */
-  PDUDataStart = bufp;
-  bufp = snmp_pdu_encode(bufp, BufLenP, PDU);
-  if (bufp == NULL)
-    return(NULL);  /* snmp_pdu_encode registered failure */
-
-  VARHeaderPtr = bufp;
-  bufp = asn_build_header(bufp, BufLenP,
-                          (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 
-                          FakeArg);
-  if (bufp == NULL)
-    return(NULL);
-  VARDataStart = bufp;
-
-  /* And build the variables */
-  bufp = snmp_var_EncodeVarBind(bufp, BufLenP, PDU->variables, Version);
-  if (bufp == NULL)
-    return(NULL);    /* snmp_var_EncodeVarBind registered failure */
-
-  /* Cool.  Now insert the appropriate lengths.
-   */
+    u_char *bufp, *tmp;
+    u_char *PDUHeaderPtr, *VARHeaderPtr;
+    u_char *PDUDataStart, *VARDataStart;
+    u_char *MsgPtr;
+    int FakeArg = 1024;
+
+    snmplib_debug(4, "Buffer=%x BufLenP=%x, buflen=%d\n", Buffer, BufLenP,
+	*BufLenP);
+    /* Header for the entire thing, with a false, large length */
+    bufp = asn_build_header(Buffer, BufLenP,
+	(u_char) (ASN_SEQUENCE |
+	    ASN_CONSTRUCTOR),
+	(*BufLenP));
+    if (bufp == NULL) {
+	snmplib_debug(4, "snmp_msg_Encode:Error encoding SNMP Message Header (Header)!\n");
+	return (NULL);
+    }
+    MsgPtr = bufp;
+
+    /* Version */
+    bufp = asn_build_int(bufp, BufLenP,
+	(u_char) (ASN_UNIVERSAL |
+	    ASN_PRIMITIVE |
+	    ASN_INTEGER),
+	(int *) (&Version), sizeof(Version));
+    if (bufp == NULL) {
+	snmplib_debug(4, "snmp_msg_Encode:Error encoding SNMP Message Header (Version)!\n");
+	return (NULL);
+    }
+    snmplib_debug(8, "snmp_msg_Encode: Encoding community (%s) (%d)\n", Community, CommLen);
+
+    /* Community */
+    bufp = asn_build_string(bufp, BufLenP,
+	(u_char) (ASN_UNIVERSAL |
+	    ASN_PRIMITIVE |
+	    ASN_OCTET_STR),
+	Community, CommLen);
+    if (bufp == NULL) {
+	snmplib_debug(4, "snmp_msg_Encode:Error encoding SNMP Message Header (Community)!\n");
+	return (NULL);
+    }
+    /* Encode the rest. */
+
+    /* A nice header for this PDU. 
+     * Encoded with the wrong length.  We'll fix it later.
+     */
+    snmplib_debug(8, "snmp_msg_Encode:Encoding PDU Header at 0x%x (fake len %d) (%d bytes so far)\n",
+	bufp, *BufLenP, *BufLenP);
+    PDUHeaderPtr = bufp;
+    bufp = asn_build_header(bufp, BufLenP,
+	(u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
+	(*BufLenP));
+    if (bufp == NULL)
+	return (NULL);
+
+    /* Encode this PDU. */
+    PDUDataStart = bufp;
+    bufp = snmp_pdu_encode(bufp, BufLenP, PDU);
+    if (bufp == NULL)
+	return (NULL);		/* snmp_pdu_encode registered failure */
+
+    VARHeaderPtr = bufp;
+    bufp = asn_build_header(bufp, BufLenP,
+	(u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
+	FakeArg);
+    if (bufp == NULL)
+	return (NULL);
+    VARDataStart = bufp;
+
+    /* And build the variables */
+    bufp = snmp_var_EncodeVarBind(bufp, BufLenP, PDU->variables, Version);
+    if (bufp == NULL)
+	return (NULL);		/* snmp_var_EncodeVarBind registered failure */
+
+    /* Cool.  Now insert the appropriate lengths.
+     */
 #ifdef DEBUG_MSG_ENCODE
-  snmplib_debug(9, "Msg:  Vars returned 0x%x.  PDU Started at 0x%x\n", 
-	 bufp, PDUHeaderPtr);
-  snmplib_debug(9, "MSG:  Entire PDU length is %d (0x%x - 0x%x)\n", 
-	 (int)(bufp - PDUDataStart), PDUHeaderPtr, bufp);
+    snmplib_debug(9, "Msg:  Vars returned 0x%x.  PDU Started at 0x%x\n",
+	bufp, PDUHeaderPtr);
+    snmplib_debug(9, "MSG:  Entire PDU length is %d (0x%x - 0x%x)\n",
+	(int) (bufp - PDUDataStart), PDUHeaderPtr, bufp);
 #endif
-  tmp = asn_build_header(PDUHeaderPtr, &FakeArg,
-			 (u_char)PDU->command,
-			 (int)(bufp - PDUDataStart)); 
-  /* Length of the PDU and Vars */
-  if (tmp == NULL)
-    return(NULL);
+    tmp = asn_build_header(PDUHeaderPtr, &FakeArg,
+	(u_char) PDU->command,
+	(int) (bufp - PDUDataStart));
+    /* Length of the PDU and Vars */
+    if (tmp == NULL)
+	return (NULL);
 
 #ifdef DEBUG_MSG_ENCODE
-  snmplib_debug(9, "MSG:  Entire message length is %d (0x%x - 0x%x)\n", 
- 	 (int)(bufp - MsgPtr), MsgPtr, bufp);
+    snmplib_debug(9, "MSG:  Entire message length is %d (0x%x - 0x%x)\n",
+	(int) (bufp - MsgPtr), MsgPtr, bufp);
 #endif
-  tmp = asn_build_header(Buffer,
-			 &FakeArg,
-			 (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 
-			 (bufp - MsgPtr)); /* Length of everything */
-  if (tmp == NULL)
-    return(NULL);
-
-  tmp = asn_build_header(VARHeaderPtr,
-			 &FakeArg,
-			 (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 
-			 (bufp - VARDataStart)); /* Length of everything */
-  if (tmp == NULL)
-    return(NULL);
-
-  *BufLenP = (bufp - Buffer);
-  return (u_char *)bufp;
+    tmp = asn_build_header(Buffer,
+	&FakeArg,
+	(u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
+	(bufp - MsgPtr));	/* Length of everything */
+    if (tmp == NULL)
+	return (NULL);
+
+    tmp = asn_build_header(VARHeaderPtr,
+	&FakeArg,
+	(u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
+	(bufp - VARDataStart));	/* Length of everything */
+    if (tmp == NULL)
+	return (NULL);
+
+    *BufLenP = (bufp - Buffer);
+    return (u_char *) bufp;
 }
 
 /**********************************************************************/
 
-u_char *snmp_msg_Decode(u_char *Packet, int *PacketLenP, 
-			u_char *Community, int *CommLenP, 
-			int *Version, struct snmp_pdu *PDU)
+u_char *
+snmp_msg_Decode(u_char * Packet, int *PacketLenP,
+    u_char * Community, int *CommLenP,
+    int *Version, struct snmp_pdu * PDU)
 {
-  u_char *bufp;
-  u_char    type;
-
-  bufp = asn_parse_header(Packet, PacketLenP, &type);
-  if (bufp == NULL){
-     snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
-    ASN_PARSE_ERROR(NULL);
-  }
-  if (type != (ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
-     snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
-    ASN_PARSE_ERROR(NULL);
-  }
-
-  bufp = asn_parse_int(bufp, PacketLenP, 
-		       &type, 
-		       (int *)Version, sizeof(*Version));
-  if (bufp == NULL){
-    snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Version)!\n");
-    ASN_PARSE_ERROR(NULL);
-  }
-  bufp = asn_parse_string(bufp, PacketLenP, &type, Community, CommLenP);
-  if (bufp == NULL){
-     snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Community)!\n");
-    ASN_PARSE_ERROR(NULL);
-  }
-  Community[*CommLenP] = '\0';
-
-  if ((*Version != SNMP_VERSION_1) && 
-      (*Version != SNMP_VERSION_2)) {
-
-    /* Don't know how to handle this one. */
-    snmpInBadVersions_Add(1);
-     snmplib_debug(4, "snmp_msg_Decode:Unable to parse Version %u\n", *Version);
-     snmplib_debug(4, "snmp_msg_Decode:Continuing anyway\n");
-  }
-
-  /* Now that we know the header, decode the PDU */
-
-  /* XXXXX -- More than one PDU? */
-  bufp = snmp_pdu_decode(bufp, PacketLenP, PDU);
-  if (bufp == NULL)
-    /* snmp_pdu_decode registered failure */
-    return(NULL);
-
-  bufp = snmp_var_DecodeVarBind(bufp, PacketLenP, &(PDU->variables), *Version);
-  if (bufp == NULL)
-    /* snmp_var_DecodeVarBind registered failure */
-    return(NULL);
-
-  return (u_char *)bufp;
+    u_char *bufp;
+    u_char type;
+
+    bufp = asn_parse_header(Packet, PacketLenP, &type);
+    if (bufp == NULL) {
+	snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
+	ASN_PARSE_ERROR(NULL);
+    }
+    if (type != (ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
+	snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
+	ASN_PARSE_ERROR(NULL);
+    }
+    bufp = asn_parse_int(bufp, PacketLenP,
+	&type,
+	(int *) Version, sizeof(*Version));
+    if (bufp == NULL) {
+	snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Version)!\n");
+	ASN_PARSE_ERROR(NULL);
+    }
+    bufp = asn_parse_string(bufp, PacketLenP, &type, Community, CommLenP);
+    if (bufp == NULL) {
+	snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Community)!\n");
+	ASN_PARSE_ERROR(NULL);
+    }
+    Community[*CommLenP] = '\0';
+
+    if ((*Version != SNMP_VERSION_1) &&
+	(*Version != SNMP_VERSION_2)) {
+
+	/* Don't know how to handle this one. */
+	snmplib_debug(4, "snmp_msg_Decode:Unable to parse Version %u\n", *Version);
+	snmplib_debug(4, "snmp_msg_Decode:Continuing anyway\n");
+    }
+    /* Now that we know the header, decode the PDU */
+
+    /* XXXXX -- More than one PDU? */
+    bufp = snmp_pdu_decode(bufp, PacketLenP, PDU);
+    if (bufp == NULL)
+	/* snmp_pdu_decode registered failure */
+	return (NULL);
+
+    bufp = snmp_var_DecodeVarBind(bufp, PacketLenP, &(PDU->variables), *Version);
+    if (bufp == NULL)
+	/* snmp_var_DecodeVarBind registered failure */
+	return (NULL);
+
+    return (u_char *) bufp;
 }
@@ -88,7 +88,6 @@
 #include "snmp_vars.h"
 #include "snmp_pdu.h"
 #include "snmp_msg.h"
-#include "mibii.h"
 #include "snmp_api_error.h"
 
 #include "util.h"
@@ -97,67 +96,68 @@
 /* #define DEBUG_PDU_DECODE 1 */
 /* #define DEBUG_PDU_ENCODE 1 */
 
-#define ASN_PARSE_ERROR(x) { snmpInASNParseErrs_Add(1); return(x); }
+#define ASN_PARSE_ERROR(x) {  return(x); }
 
 /**********************************************************************/
 
 /* Create a PDU.
  */
 
-struct snmp_pdu *snmp_pdu_create(int command)
+struct snmp_pdu *
+snmp_pdu_create(int command)
 {
-  struct snmp_pdu *pdu;
+    struct snmp_pdu *pdu;
 
 #ifdef DEBUG_PDU
-  snmplib_debug(8,"PDU:  Creating\n");
+    snmplib_debug(8, "PDU:  Creating\n");
 #endif
 
-  pdu = (struct snmp_pdu *)xmalloc(sizeof(struct snmp_pdu));
-  if (pdu == NULL) {
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-
-  memset((char *)pdu, '\0', sizeof(struct snmp_pdu));
+    pdu = (struct snmp_pdu *) xmalloc(sizeof(struct snmp_pdu));
+    if (pdu == NULL) {
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
+    memset((char *) pdu, '\0', sizeof(struct snmp_pdu));
 
-  pdu->command                 = command;
-  pdu->errstat                 = SNMP_DEFAULT_ERRSTAT;
-  pdu->errindex                = SNMP_DEFAULT_ERRINDEX;
-  pdu->address.sin_addr.s_addr = SNMP_DEFAULT_ADDRESS;
-  pdu->enterprise              = NULL;
-  pdu->enterprise_length       = 0;
-  pdu->variables               = NULL;
+    pdu->command = command;
+    pdu->errstat = SNMP_DEFAULT_ERRSTAT;
+    pdu->errindex = SNMP_DEFAULT_ERRINDEX;
+    pdu->address.sin_addr.s_addr = SNMP_DEFAULT_ADDRESS;
+    pdu->enterprise = NULL;
+    pdu->enterprise_length = 0;
+    pdu->variables = NULL;
 
 #ifdef DEBUG_PDU
-  snmplib_debug(8,"PDU:  Created %x\n", (unsigned int)pdu);
+    snmplib_debug(8, "PDU:  Created %x\n", (unsigned int) pdu);
 #endif
 
-  return(pdu);
+    return (pdu);
 }
 
 /**********************************************************************/
 
 /* Clone an existing PDU.
  */
-struct snmp_pdu *snmp_pdu_clone(struct snmp_pdu *Src)
+struct snmp_pdu *
+snmp_pdu_clone(struct snmp_pdu *Src)
 {
-  struct snmp_pdu *Dest;
+    struct snmp_pdu *Dest;
 
 #ifdef DEBUG_PDU
-  snmplib_debug(8,"PDU %x:  Cloning\n", (unsigned int)Src);
+    snmplib_debug(8, "PDU %x:  Cloning\n", (unsigned int) Src);
 #endif
 
-  Dest = (struct snmp_pdu *)xmalloc(sizeof(struct snmp_pdu));
-  if (Dest == NULL) {
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-  xmemcpy((char *)Dest, (char *)Src, sizeof(struct snmp_pdu));
+    Dest = (struct snmp_pdu *) xmalloc(sizeof(struct snmp_pdu));
+    if (Dest == NULL) {
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
+    xmemcpy((char *) Dest, (char *) Src, sizeof(struct snmp_pdu));
 
 #ifdef DEBUG_PDU
-  snmplib_debug(8,"PDU %x:  Created %x\n", (unsigned int)Src, (unsigned int)Dest);
+    snmplib_debug(8, "PDU %x:  Created %x\n", (unsigned int) Src, (unsigned int) Dest);
 #endif
-  return(Dest);
+    return (Dest);
 }
 
 /**********************************************************************/
@@ -173,129 +173,127 @@ struct snmp_pdu *snmp_pdu_clone(struct snmp_pdu *Src)
  * If everything was successful, a pointer to the fixed cloned pdu will
  * be returned.
  */
-struct snmp_pdu *snmp_pdu_fix(struct snmp_pdu *pdu, int command)
+struct snmp_pdu *
+snmp_pdu_fix(struct snmp_pdu *pdu, int command)
 {
-  return(snmp_fix_pdu(pdu, command));
+    return (snmp_fix_pdu(pdu, command));
 }
 
-struct snmp_pdu *snmp_fix_pdu(struct snmp_pdu *pdu, int command)
+struct snmp_pdu *
+snmp_fix_pdu(struct snmp_pdu *pdu, int command)
 {
-  struct variable_list *var, *newvar;
-  struct snmp_pdu *newpdu;
-  int index;
-  int copied = 0;
+    struct variable_list *var, *newvar;
+    struct snmp_pdu *newpdu;
+    int index;
+    int copied = 0;
 
 #ifdef DEBUG_PDU
-  snmplib_debug(8,"PDU %x:  Fixing.  Err index is %d\n", 
-	 (unsigned int)pdu, (unsigned int)pdu->errindex);
+    snmplib_debug(8, "PDU %x:  Fixing.  Err index is %d\n",
+	(unsigned int) pdu, (unsigned int) pdu->errindex);
 #endif
 
-  if (pdu->command != SNMP_PDU_RESPONSE || 
-      pdu->errstat == SNMP_ERR_NOERROR || 
-      pdu->errindex <= 0) {
-    snmp_set_api_error(SNMPERR_UNABLE_TO_FIX);
-    return(NULL);
-  }
-
-  /* clone the pdu */
-  newpdu            = snmp_pdu_clone(pdu);
-  if (newpdu == NULL)
-    return(NULL);
-
-  newpdu->variables = 0;
-  newpdu->command   = command;
-  newpdu->reqid     = SNMP_DEFAULT_REQID;
-  newpdu->errstat   = SNMP_DEFAULT_ERRSTAT;
-  newpdu->errindex  = SNMP_DEFAULT_ERRINDEX;
-
-  /* Loop through the variables, removing whatever isn't necessary */
-
-  var   = pdu->variables;
-  index = 1;
-
-  /* skip first variable if necessary*/
-  if (pdu->errindex == index) {
-    var = var->next_variable;
-    index++;
-  }
-
-  if (var != NULL) {
-
-    /* VAR is the first uncopied variable */
-
-    /* Clone this variable */
-    newpdu->variables = snmp_var_clone(var);
-    if (newpdu->variables == NULL) {
-      snmp_pdu_free(newpdu);
-      return(NULL);
+    if (pdu->command != SNMP_PDU_RESPONSE ||
+	pdu->errstat == SNMP_ERR_NOERROR ||
+	pdu->errindex <= 0) {
+	snmp_set_api_error(SNMPERR_UNABLE_TO_FIX);
+	return (NULL);
     }
-    copied++;
+    /* clone the pdu */
+    newpdu = snmp_pdu_clone(pdu);
+    if (newpdu == NULL)
+	return (NULL);
+
+    newpdu->variables = 0;
+    newpdu->command = command;
+    newpdu->reqid = SNMP_DEFAULT_REQID;
+    newpdu->errstat = SNMP_DEFAULT_ERRSTAT;
+    newpdu->errindex = SNMP_DEFAULT_ERRINDEX;
 
-    newvar = newpdu->variables;
+    /* Loop through the variables, removing whatever isn't necessary */
 
-    /* VAR has been copied to NEWVAR. */
-    while(var->next_variable) {
+    var = pdu->variables;
+    index = 1;
 
-      /* Skip the item that was bad */
-      if (++index == pdu->errindex) {
+    /* skip first variable if necessary */
+    if (pdu->errindex == index) {
 	var = var->next_variable;
-	continue;
-      }
-
-      /* Copy this var */
-      newvar->next_variable = snmp_var_clone(var->next_variable);
-      if (newvar->next_variable == NULL) {
-	snmp_pdu_free(newpdu);
-	return(NULL);
-      }
-
-      /* Move to the next one */
-      newvar = newvar->next_variable;
-      var = var->next_variable;
-      copied++;
+	index++;
+    }
+    if (var != NULL) {
+
+	/* VAR is the first uncopied variable */
+
+	/* Clone this variable */
+	newpdu->variables = snmp_var_clone(var);
+	if (newpdu->variables == NULL) {
+	    snmp_pdu_free(newpdu);
+	    return (NULL);
+	}
+	copied++;
+
+	newvar = newpdu->variables;
+
+	/* VAR has been copied to NEWVAR. */
+	while (var->next_variable) {
+
+	    /* Skip the item that was bad */
+	    if (++index == pdu->errindex) {
+		var = var->next_variable;
+		continue;
+	    }
+	    /* Copy this var */
+	    newvar->next_variable = snmp_var_clone(var->next_variable);
+	    if (newvar->next_variable == NULL) {
+		snmp_pdu_free(newpdu);
+		return (NULL);
+	    }
+	    /* Move to the next one */
+	    newvar = newvar->next_variable;
+	    var = var->next_variable;
+	    copied++;
+	}
+	newvar->next_variable = NULL;
+    }
+    /* If we didn't copy anything, free the new pdu. */
+    if (index < pdu->errindex || copied == 0) {
+	snmp_free_pdu(newpdu);
+	snmp_set_api_error(SNMPERR_UNABLE_TO_FIX);
+	return (NULL);
     }
-    newvar->next_variable = NULL;
-  }
-
-  /* If we didn't copy anything, free the new pdu. */
-  if (index < pdu->errindex || copied == 0) {
-    snmp_free_pdu(newpdu);
-    snmp_set_api_error(SNMPERR_UNABLE_TO_FIX);
-    return(NULL);
-  }
-
 #ifdef DEBUG_PDU
-  snmplib_debug(8,"PDU %x:  Fixed PDU is %x\n", 
-	 (unsigned int)pdu, (unsigned int)newpdu);
+    snmplib_debug(8, "PDU %x:  Fixed PDU is %x\n",
+	(unsigned int) pdu, (unsigned int) newpdu);
 #endif
-  return(newpdu);
+    return (newpdu);
 }
 
 
 /**********************************************************************/
 
-void snmp_pdu_free(struct snmp_pdu *pdu)
+void 
+snmp_pdu_free(struct snmp_pdu *pdu)
 {
-  snmp_free_pdu(pdu);
+    snmp_free_pdu(pdu);
 }
 
 /*
  * Frees the pdu and any xmalloc'd data associated with it.
  */
-void snmp_free_pdu(struct snmp_pdu *pdu)
+void 
+snmp_free_pdu(struct snmp_pdu *pdu)
 {
-  struct variable_list *vp, *ovp;
-
-  vp = pdu->variables;
-  while(vp) {
-    ovp = vp;
-    vp = vp->next_variable;
-    snmp_var_free(ovp);
-  }
-
-  if (pdu->enterprise)
-    xfree((char *)pdu->enterprise);
-  xfree((char *)pdu);
+    struct variable_list *vp, *ovp;
+
+    vp = pdu->variables;
+    while (vp) {
+	ovp = vp;
+	vp = vp->next_variable;
+	snmp_var_free(ovp);
+    }
+
+    if (pdu->enterprise)
+	xfree((char *) pdu->enterprise);
+    xfree((char *) pdu);
 }
 
 /**********************************************************************/
@@ -347,131 +345,132 @@ void snmp_free_pdu(struct snmp_pdu *pdu)
  *    }
  */
 
-u_char *snmp_pdu_encode(u_char *DestBuf, int *DestBufLen,
-			struct snmp_pdu *PDU)
+u_char *
+snmp_pdu_encode(u_char * DestBuf, int *DestBufLen,
+    struct snmp_pdu *PDU)
 {
-  u_char *bufp;
+    u_char *bufp;
 
 #ifdef DEBUG_PDU_ENCODE
-  snmplib_debug(8,"PDU: Encoding %d\n", PDU->command);
+    snmplib_debug(8, "PDU: Encoding %d\n", PDU->command);
 #endif
 
-  /* ASN.1 Header */
-  switch (PDU->command) {
-
-    /**********************************************************************/
+    /* ASN.1 Header */
+    switch (PDU->command) {
 
-  case TRP_REQ_MSG:
-
-    /* SNMPv1 Trap */
-
-    /* enterprise */
-    bufp = asn_build_objid(DestBuf, DestBufLen,
-			   (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OBJECT_ID),
-			   (oid *)PDU->enterprise, PDU->enterprise_length);
-    if (bufp == NULL)
-      return(NULL);
-
-    /* agent-addr */
-    bufp = asn_build_string(bufp, DestBufLen,
-			    (u_char)(SMI_IPADDRESS | ASN_PRIMITIVE),
-			    (u_char *)&PDU->agent_addr.sin_addr.s_addr,
-			    sizeof(PDU->agent_addr.sin_addr.s_addr));
-    if (bufp == NULL)
-      return(NULL);
-
-    /* generic trap */
-    bufp = asn_build_int(bufp, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 (int *)&PDU->trap_type, sizeof(PDU->trap_type));
-    if (bufp == NULL)
-      return(NULL);
-
-    /* specific trap */
-    bufp = asn_build_int(bufp, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 (int *)&PDU->specific_type, 
-			 sizeof(PDU->specific_type));
-    if (bufp == NULL)
-      return(NULL);
-
-    /* timestamp */
-    bufp = asn_build_unsigned_int(bufp, DestBufLen,
-				  (u_char)(SMI_TIMETICKS | ASN_PRIMITIVE),
-				  &PDU->time, sizeof(PDU->time));
-    if (bufp == NULL)
-      return(NULL);
-    break;
-
-    /**********************************************************************/
-
-  case SNMP_PDU_GETBULK:
+/**********************************************************************/
 
-    /* SNMPv2 Bulk Request */
+    case TRP_REQ_MSG:
+
+	/* SNMPv1 Trap */
+
+	/* enterprise */
+	bufp = asn_build_objid(DestBuf, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OBJECT_ID),
+	    (oid *) PDU->enterprise, PDU->enterprise_length);
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* agent-addr */
+	bufp = asn_build_string(bufp, DestBufLen,
+	    (u_char) (SMI_IPADDRESS | ASN_PRIMITIVE),
+	    (u_char *) & PDU->agent_addr.sin_addr.s_addr,
+	    sizeof(PDU->agent_addr.sin_addr.s_addr));
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* generic trap */
+	bufp = asn_build_int(bufp, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    (int *) &PDU->trap_type, sizeof(PDU->trap_type));
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* specific trap */
+	bufp = asn_build_int(bufp, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    (int *) &PDU->specific_type,
+	    sizeof(PDU->specific_type));
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* timestamp */
+	bufp = asn_build_unsigned_int(bufp, DestBufLen,
+	    (u_char) (SMI_TIMETICKS | ASN_PRIMITIVE),
+	    &PDU->time, sizeof(PDU->time));
+	if (bufp == NULL)
+	    return (NULL);
+	break;
 
-    /* request id */
-    bufp = asn_build_int(DestBuf, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 &PDU->reqid, sizeof(PDU->reqid));
-    if (bufp == NULL)
-      return(NULL);
-
-    /* non-repeaters */
-    bufp = asn_build_int(bufp, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 &PDU->non_repeaters, 
-			 sizeof(PDU->non_repeaters));
-    if (bufp == NULL)
-      return(NULL);
+/**********************************************************************/
 
-    /* max-repetitions */
-    bufp = asn_build_int(bufp, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 &PDU->max_repetitions,
-			 sizeof(PDU->max_repetitions));
-    if (bufp == NULL)
-      return(NULL);
-    break;
+    case SNMP_PDU_GETBULK:
+
+	/* SNMPv2 Bulk Request */
+
+	/* request id */
+	bufp = asn_build_int(DestBuf, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    &PDU->reqid, sizeof(PDU->reqid));
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* non-repeaters */
+	bufp = asn_build_int(bufp, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    &PDU->non_repeaters,
+	    sizeof(PDU->non_repeaters));
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* max-repetitions */
+	bufp = asn_build_int(bufp, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    &PDU->max_repetitions,
+	    sizeof(PDU->max_repetitions));
+	if (bufp == NULL)
+	    return (NULL);
+	break;
 
-    /**********************************************************************/
+/**********************************************************************/
 
-  default:
+    default:
 
-    /* Normal PDU Encoding */
+	/* Normal PDU Encoding */
 
-    /* request id */
+	/* request id */
 #ifdef DEBUG_PDU_ENCODE
-    snmplib_debug(8,"PDU: Request ID %d (0x%x)\n", PDU->reqid, DestBuf);
+	snmplib_debug(8, "PDU: Request ID %d (0x%x)\n", PDU->reqid, DestBuf);
 #endif
-    bufp = asn_build_int(DestBuf, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 &PDU->reqid, sizeof(PDU->reqid));
-    if (bufp == NULL)
-      return(NULL);
+	bufp = asn_build_int(DestBuf, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    &PDU->reqid, sizeof(PDU->reqid));
+	if (bufp == NULL)
+	    return (NULL);
 
-    /* error status */
+	/* error status */
 #ifdef DEBUG_PDU_ENCODE
-    snmplib_debug(8,"PDU: Error Status %d (0x%x)\n", PDU->errstat, bufp);
+	snmplib_debug(8, "PDU: Error Status %d (0x%x)\n", PDU->errstat, bufp);
 #endif
-    bufp = asn_build_int(bufp, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 &PDU->errstat, sizeof(PDU->errstat));
-    if (bufp == NULL)
-      return(NULL);
+	bufp = asn_build_int(bufp, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    &PDU->errstat, sizeof(PDU->errstat));
+	if (bufp == NULL)
+	    return (NULL);
 
-    /* error index */
+	/* error index */
 #ifdef DEBUG_PDU_ENCODE
-    snmplib_debug(8,"PDU: Error index %d (0x%x)\n", PDU->errindex, bufp);
+	snmplib_debug(8, "PDU: Error index %d (0x%x)\n", PDU->errindex, bufp);
 #endif
-    bufp = asn_build_int(bufp, DestBufLen,
-			 (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
-			 &PDU->errindex, sizeof(PDU->errindex));
-    if (bufp == NULL)
-      return(NULL);
-    break;
-  } /* End of encoding */
-
-  return(bufp);
+	bufp = asn_build_int(bufp, DestBufLen,
+	    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+	    &PDU->errindex, sizeof(PDU->errindex));
+	if (bufp == NULL)
+	    return (NULL);
+	break;
+    }				/* End of encoding */
+
+    return (bufp);
 }
 
 /**********************************************************************/
@@ -481,218 +480,218 @@ u_char *snmp_pdu_encode(u_char *DestBuf, int *DestBufLen,
  * Returns a pointer to the next byte of the packet, which is where the
  * Variable Bindings start.
  */
-u_char *snmp_pdu_decode(u_char *Packet,       /* data */
-			int *Length,          /* &length */
-			struct snmp_pdu *PDU) /* pdu */
-{
-  u_char *bufp;
-  u_char PDUType;
-  int four;
-  u_char ASNType;
-  oid objid[MAX_NAME_LEN];
-
-  bufp = asn_parse_header(Packet, Length, &PDUType);
-  if (bufp == NULL)
-    ASN_PARSE_ERROR(NULL);
+u_char *
+snmp_pdu_decode(u_char * Packet,	/* data */
+    int *Length,		/* &length */
+    struct snmp_pdu * PDU)
+{				/* pdu */
+    u_char *bufp;
+    u_char PDUType;
+    int four;
+    u_char ASNType;
+    oid objid[MAX_NAME_LEN];
+
+    bufp = asn_parse_header(Packet, Length, &PDUType);
+    if (bufp == NULL)
+	ASN_PARSE_ERROR(NULL);
 
 #ifdef DEBUG_PDU_DECODE
-  snmplib_debug(8,"PDU Type: %d\n", PDUType);
+    snmplib_debug(8, "PDU Type: %d\n", PDUType);
 #endif
 
-  PDU->command = PDUType;
-  switch (PDUType) {
-
-  case TRP_REQ_MSG:
-
-    /* SNMPv1 Trap Message */
-
-    /* enterprise */
-    PDU->enterprise_length = MAX_NAME_LEN;
-    bufp = asn_parse_objid(bufp, Length,
-			   &ASNType, objid, &PDU->enterprise_length);
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-
-    PDU->enterprise = (oid *)xmalloc(PDU->enterprise_length * sizeof(oid));
-    if (PDU->enterprise == NULL) {
-      snmp_set_api_error(SNMPERR_OS_ERR);
-      return(NULL);
-    }
-
-    xmemcpy((char *)PDU->enterprise, (char *)objid, 
-	   PDU->enterprise_length * sizeof(oid));
-	
-    /* Agent-addr */
-    four = 4;
-    bufp = asn_parse_string(bufp, Length, 
-			    &ASNType, 
-			    (u_char *)&PDU->agent_addr.sin_addr.s_addr, 
-			    &four);
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-
-    /* Generic trap */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 (int *)&PDU->trap_type, 
-			 sizeof(PDU->trap_type));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-
-    /* Specific Trap */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 (int *)&PDU->specific_type, 
-			 sizeof(PDU->specific_type));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
+    PDU->command = PDUType;
+    switch (PDUType) {
+
+    case TRP_REQ_MSG:
+
+	/* SNMPv1 Trap Message */
+
+	/* enterprise */
+	PDU->enterprise_length = MAX_NAME_LEN;
+	bufp = asn_parse_objid(bufp, Length,
+	    &ASNType, objid, &PDU->enterprise_length);
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+
+	PDU->enterprise = (oid *) xmalloc(PDU->enterprise_length * sizeof(oid));
+	if (PDU->enterprise == NULL) {
+	    snmp_set_api_error(SNMPERR_OS_ERR);
+	    return (NULL);
+	}
+	xmemcpy((char *) PDU->enterprise, (char *) objid,
+	    PDU->enterprise_length * sizeof(oid));
+
+	/* Agent-addr */
+	four = 4;
+	bufp = asn_parse_string(bufp, Length,
+	    &ASNType,
+	    (u_char *) & PDU->agent_addr.sin_addr.s_addr,
+	    &four);
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+
+	/* Generic trap */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    (int *) &PDU->trap_type,
+	    sizeof(PDU->trap_type));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+
+	/* Specific Trap */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    (int *) &PDU->specific_type,
+	    sizeof(PDU->specific_type));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+
+	/* Timestamp */
+	bufp = asn_parse_unsigned_int(bufp, Length,
+	    &ASNType,
+	    &PDU->time, sizeof(PDU->time));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+	break;
 
-    /* Timestamp */
-    bufp = asn_parse_unsigned_int(bufp, Length, 
-				  &ASNType, 
-				  &PDU->time, sizeof(PDU->time));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-    break;
+/**********************************************************************/
 
-    /**********************************************************************/
+    case SNMP_PDU_GETBULK:
 
-  case SNMP_PDU_GETBULK:
+	/* SNMPv2 Bulk Request */
 
-    /* SNMPv2 Bulk Request */
+	/* request id */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    &PDU->reqid, sizeof(PDU->reqid));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
-    /* request id */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 &PDU->reqid, sizeof(PDU->reqid));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-
-    /* non-repeaters */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 &PDU->non_repeaters, sizeof(PDU->non_repeaters));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
+	/* non-repeaters */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    &PDU->non_repeaters, sizeof(PDU->non_repeaters));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
-    /* max-repetitions */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 &PDU->max_repetitions, sizeof(PDU->max_repetitions));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
+	/* max-repetitions */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    &PDU->max_repetitions, sizeof(PDU->max_repetitions));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
-    break;
-    /**********************************************************************/
+	break;
+/**********************************************************************/
 
-  default:
+    default:
 
-    /* Normal PDU Encoding */
+	/* Normal PDU Encoding */
 
-    /* request id */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 &PDU->reqid, sizeof(PDU->reqid));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
+	/* request id */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    &PDU->reqid, sizeof(PDU->reqid));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
 #ifdef DEBUG_PDU_DECODE
-    snmplib_debug(8,"PDU Request ID: %d\n", PDU->reqid);
+	snmplib_debug(8, "PDU Request ID: %d\n", PDU->reqid);
 #endif
 
-    /* error status */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 &PDU->errstat, sizeof(PDU->errstat));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
+	/* error status */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    &PDU->errstat, sizeof(PDU->errstat));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
 #ifdef DEBUG_PDU_DECODE
-    snmplib_debug(8,"PDU Error Status: %d\n", PDU->errstat);
+	snmplib_debug(8, "PDU Error Status: %d\n", PDU->errstat);
 #endif
 
-    /* error index */
-    bufp = asn_parse_int(bufp, Length, 
-			 &ASNType, 
-			 &PDU->errindex, sizeof(PDU->errindex));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
+	/* error index */
+	bufp = asn_parse_int(bufp, Length,
+	    &ASNType,
+	    &PDU->errindex, sizeof(PDU->errindex));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
 #ifdef DEBUG_PDU_DECODE
-    snmplib_debug(8,"PDU Error Index: %d\n", PDU->errindex);
+	snmplib_debug(8, "PDU Error Index: %d\n", PDU->errindex);
 #endif
 
-    break;
-  }
+	break;
+    }
 
-  return(bufp);
+    return (bufp);
 }
 
 
-char *snmp_pdu_type(struct snmp_pdu *PDU)
+char *
+snmp_pdu_type(struct snmp_pdu *PDU)
 {
-  switch(PDU->command) {
-  case SNMP_PDU_GET:
-    return("GET");
-    break;
-  case SNMP_PDU_GETNEXT:
-    return("GETNEXT");
-    break;
-  case SNMP_PDU_RESPONSE:
-    return("RESPONSE");
-    break;
-  case SNMP_PDU_SET:
-    return("SET");
-    break;
-  case SNMP_PDU_GETBULK:
-    return("GETBULK");
-    break;
-  case SNMP_PDU_INFORM:
-    return("INFORM");
-    break;
-  case SNMP_PDU_V2TRAP:
-    return("V2TRAP");
-    break;
-  case SNMP_PDU_REPORT:
-    return("REPORT");
-    break;
-    
-  case TRP_REQ_MSG:
-    return("V1TRAP");
-    break;
-  default:
-    return("Unknown");
-    break;
-  }
+    switch (PDU->command) {
+    case SNMP_PDU_GET:
+	return ("GET");
+	break;
+    case SNMP_PDU_GETNEXT:
+	return ("GETNEXT");
+	break;
+    case SNMP_PDU_RESPONSE:
+	return ("RESPONSE");
+	break;
+    case SNMP_PDU_SET:
+	return ("SET");
+	break;
+    case SNMP_PDU_GETBULK:
+	return ("GETBULK");
+	break;
+    case SNMP_PDU_INFORM:
+	return ("INFORM");
+	break;
+    case SNMP_PDU_V2TRAP:
+	return ("V2TRAP");
+	break;
+    case SNMP_PDU_REPORT:
+	return ("REPORT");
+	break;
+
+    case TRP_REQ_MSG:
+	return ("V1TRAP");
+	break;
+    default:
+	return ("Unknown");
+	break;
+    }
 }
 
 /*
  * Add a null variable with the requested name to the end of the list of
  * variables for this pdu.
  */
-void snmp_add_null_var(struct snmp_pdu *pdu, oid *name, int name_length)
+void 
+snmp_add_null_var(struct snmp_pdu *pdu, oid * name, int name_length)
 {
-  struct variable_list *vars;
-  struct variable_list *ptr;
-
-  vars = snmp_var_new(name, name_length);
-  if (vars == NULL) {
-    perror("snmp_add_null_var:xmalloc");
-    return;
-  }
-
-  if (pdu->variables == NULL) {
-    pdu->variables = vars;
-  } else {
+    struct variable_list *vars;
+    struct variable_list *ptr;
 
-    /* Insert at the end */
-    for (ptr = pdu->variables; 
-	 ptr->next_variable; 
-	 ptr = ptr->next_variable)
-      /*EXIT*/;
-    ptr->next_variable = vars;
-  }
+    vars = snmp_var_new(name, name_length);
+    if (vars == NULL) {
+	perror("snmp_add_null_var:xmalloc");
+	return;
+    }
+    if (pdu->variables == NULL) {
+	pdu->variables = vars;
+    } else {
+
+	/* Insert at the end */
+	for (ptr = pdu->variables;
+	    ptr->next_variable;
+	    ptr = ptr->next_variable)
+	    /*EXIT */ ;
+	ptr->next_variable = vars;
+    }
 
-  return;
+    return;
 }
-
@@ -1,3 +1,4 @@
+
 /*
  * SNMP Variable Binding.  Complies with:
  *
@@ -83,7 +84,9 @@
 #include "snmp.h"
 #include "asn1.h"
 #include "snmp_vars.h"
+#if 0
 #include "mibii.h"
+#endif
 #include "snmp_api_error.h"
 #include "snmp_pdu.h"
 #include "snmp_msg.h"
@@ -96,153 +99,133 @@
 /* #define DEBUG_VARS_DECODE 1 */
 /* #define DEBUG_VARS_ENCODE 1 */
 
-#define ASN_PARSE_ERROR(x) { snmpInASNParseErrs_Add(1); return(x); }
+#define ASN_PARSE_ERROR(x) { return(x); }
 
 /* Create a new variable_list structure representing oid Name of length Len.
  *
  * Returns NULL upon error.
  */
 
-struct variable_list *snmp_var_new(oid *Name, int Len)
+struct variable_list *
+snmp_var_new(oid * Name, int Len)
 {
-  struct variable_list *New;
+    struct variable_list *New;
 
 #ifdef DEBUG_VARS
-  printf("VARS: Creating.\n");
+    printf("VARS: Creating.\n");
 #endif
 
-  New = (struct variable_list *)xmalloc(sizeof(struct variable_list));
-  if (New == NULL) {
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-  memset(New, '\0', sizeof(struct variable_list));
-  /*  New->next_variable = NULL; */
-
-  New->type = ASN_NULL;
-  New->name_length = Len;
-
-  if (New->name_length == 0) {
-    New->name = NULL;
-    return(New);
-  }
+    New = (struct variable_list *) xmalloc(sizeof(struct variable_list));
+    if (New == NULL) {
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
+    memset(New, '\0', sizeof(struct variable_list));
+    /*  New->next_variable = NULL; */
 
-  New->name = (oid *)xmalloc(Len * sizeof(oid));
-  if (New->name == NULL) {
-    xfree(New);
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
+    New->type = ASN_NULL;
+    New->name_length = Len;
 
+    if (New->name_length == 0) {
+	New->name = NULL;
+	return (New);
+    }
+    New->name = (oid *) xmalloc(Len * sizeof(oid));
+    if (New->name == NULL) {
+	xfree(New);
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
 #ifdef DEBUG_VARS
-  printf("VARS: Copying name, size (%d)\n", Len);
+    printf("VARS: Copying name, size (%d)\n", Len);
 #endif
 
-  /* Only copy a name if it was specified. */
-  if (Name)
-    xmemcpy((char *)New->name, (char *)Name, Len * sizeof(oid));
-  
-  /*  New->val.string = NULL; */
-  /*  New->val_len = 0; */
-
-#ifdef DEBUG_VARS
-  printf("VARS: Created %x.\n", (unsigned int)New);
-#endif
+    /* Only copy a name if it was specified. */
+    if (Name)
+	xmemcpy((char *) New->name, (char *) Name, Len * sizeof(oid));
 
-#ifdef DEBUG_VARS_MALLOC
-  printf("VARS: Created (%x)\n", (unsigned int)New);
-  printf("VARS: Name is (%x)\n", (unsigned int)New->name);
-#endif
-  return(New);
+    return (New);
 }
 
 /* Clone a variable list.
  *
  * Returns NULL upon error.
  */
 
-struct variable_list *snmp_var_clone(struct variable_list *Src)
+struct variable_list *
+snmp_var_clone(struct variable_list *Src)
 {
-  struct variable_list *Dest;
+    struct variable_list *Dest;
 
 #ifdef DEBUG_VARS
-  printf("VARS: Cloning.\n");
+    printf("VARS: Cloning.\n");
 #endif
 
-  Dest = (struct variable_list *)xmalloc(sizeof(struct variable_list));
-  if (Dest == NULL) {
-    snmp_set_api_error(SNMPERR_OS_ERR);
-    return(NULL);
-  }
-
+    Dest = (struct variable_list *) xmalloc(sizeof(struct variable_list));
+    if (Dest == NULL) {
+	snmp_set_api_error(SNMPERR_OS_ERR);
+	return (NULL);
+    }
 #ifdef DEBUG_VARS
-  printf("VARS: Copying entire variable list.  (Size %d)\n",
-	 sizeof(struct variable_list));
+    printf("VARS: Copying entire variable list.  (Size %d)\n",
+	sizeof(struct variable_list));
 #endif
 
-  xmemcpy((char *)Dest, (char *)Src, sizeof(struct variable_list));
+    xmemcpy((char *) Dest, (char *) Src, sizeof(struct variable_list));
 
-  if (Src->name != NULL){
-    Dest->name = (oid *)xmalloc(Src->name_length * sizeof(oid));
-    if (Dest->name == NULL) {
-      snmp_set_api_error(SNMPERR_OS_ERR);
-      xfree(Dest);
-      return(NULL);
-    }
+    if (Src->name != NULL) {
+	Dest->name = (oid *) xmalloc(Src->name_length * sizeof(oid));
+	if (Dest->name == NULL) {
+	    snmp_set_api_error(SNMPERR_OS_ERR);
+	    xfree(Dest);
+	    return (NULL);
+	}
 #ifdef DEBUG_VARS
-    printf("VARS: Copying name OID. (Size %d)\n", Src->name_length);
-#endif
-    xmemcpy((char *)Dest->name, (char *)Src->name,
-    	   Src->name_length * sizeof(oid));
-  }
-
-  /* CISCO Catalyst 2900 returns NULL strings as data of length 0. */
-  if ((Src->val.string != NULL) &&
-      (Src->val_len)) {
-    Dest->val.string = (u_char *)xmalloc(Src->val_len);
-    if (Dest->val.string == NULL) {
-      snmp_set_api_error(SNMPERR_OS_ERR);
-      xfree(Dest->name);
-      xfree(Dest);
-      return(NULL);
+	printf("VARS: Copying name OID. (Size %d)\n", Src->name_length);
+#endif
+	xmemcpy((char *) Dest->name, (char *) Src->name,
+	    Src->name_length * sizeof(oid));
     }
-
+    /* CISCO Catalyst 2900 returns NULL strings as data of length 0. */
+    if ((Src->val.string != NULL) &&
+	(Src->val_len)) {
+	Dest->val.string = (u_char *) xmalloc(Src->val_len);
+	if (Dest->val.string == NULL) {
+	    snmp_set_api_error(SNMPERR_OS_ERR);
+	    xfree(Dest->name);
+	    xfree(Dest);
+	    return (NULL);
+	}
 #ifdef DEBUG_VARS
-    printf("VARS: Copying value (Size %d)\n", Src->val_len);
+	printf("VARS: Copying value (Size %d)\n", Src->val_len);
 #endif
-    xmemcpy((char *)Dest->val.string, (char *)Src->val.string, Src->val_len);
-  }
-
+	xmemcpy((char *) Dest->val.string, (char *) Src->val.string, Src->val_len);
+    }
 #ifdef DEBUG_VARS
-  printf("VARS: Cloned %x.\n", (unsigned int)Dest);
+    printf("VARS: Cloned %x.\n", (unsigned int) Dest);
 #endif
 #ifdef DEBUG_VARS_MALLOC
-  printf("VARS: Cloned  (%x)\n", (unsigned int)Dest);
-  printf("VARS: Name is (%x)\n", (unsigned int)Dest->name);
+    printf("VARS: Cloned  (%x)\n", (unsigned int) Dest);
+    printf("VARS: Name is (%x)\n", (unsigned int) Dest->name);
 #endif
 
-  return(Dest);
+    return (Dest);
 }
 
 /* Free a variable_list.
  */
-void snmp_var_free(struct variable_list *Ptr)
+void 
+snmp_var_free(struct variable_list *Ptr)
 {
-#ifdef DEBUG_VARS_MALLOC
-  printf("VARS: Free'd  (%x)\n", (unsigned int)Ptr);
-  printf("VARS: Name was(%x)\n", (unsigned int)Ptr->name);
-#endif
+    if (Ptr->name && Ptr->name_length > 0)
+	xfree((char *) Ptr->name);
 
-  if (Ptr->name && Ptr->name_length > 0)
-    xfree((char *) Ptr->name);
+    if (Ptr->val.string && Ptr->val_len > 0)
+	xfree((char *) Ptr->val.string);
+    else if (Ptr->val.integer && Ptr->val_len > 0)
+	xfree((char *) Ptr->val.integer);
 
-  if (Ptr->val.string && Ptr->val_len > 0)
-    xfree((char *) Ptr->val.string);
-  else
-  if (Ptr->val.integer && Ptr->val_len > 0)
-    xfree((char *) Ptr->val.integer);
-
-  xfree(Ptr);
+    xfree(Ptr);
 }
 
 /**********************************************************************/
@@ -263,376 +246,317 @@ void snmp_var_free(struct variable_list *Ptr)
  *     }
  *   }
  */
-u_char *snmp_var_EncodeVarBind(u_char *Buffer, int *BufLenP,
-			       struct variable_list *VarList,
-			       int Version)
+u_char *
+snmp_var_EncodeVarBind(u_char * Buffer, int *BufLenP,
+    variable_list * VarList,
+    int Version)
 {
-  struct variable_list *Vars;
-  u_char *bufp;
-  u_char *HeaderStart;
-  u_char *HeaderEnd;
-  int FakeArg = *BufLenP;
-#ifdef DEBUG_VARS_ENCODE
-  int StartLen = *BufLenP;
-  int Counter = 1;
-#endif
-
-  bufp = Buffer;
-
-#ifdef DEBUG_VARS_ENCODE
-  printf("VARS: Encoding Variable list into buffer at 0x%x.\n", Buffer);
-#endif
-
-  for (Vars=VarList; Vars; Vars=Vars->next_variable) {
-
-#ifdef DEBUG_VARS_ENCODE
-    printf("VARS %d: Encoding Variable 0x%x.\n", Counter, Vars);
-    printf("VARS %d: Starting at 0x%x (%d bytes left)\n", 
-	   Counter, bufp, *BufLenP);
-#endif
-
-    /* Build the header for this variable
-     *
-     * Use Maximum size.
-     */
-    HeaderStart = bufp;
-    HeaderEnd = asn_build_header(HeaderStart, BufLenP,
-				 (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 
-				 FakeArg);
-    if (HeaderEnd == NULL)
-      return(NULL);
-
-#ifdef DEBUG_VARS_ENCODE
-    printf("VARS %d: Encoding Object Identifier 0x%x (%d bytes) at 0x%x (%d bytes left)\n", 
-	   Counter, Vars,
-	   Vars->name_length, HeaderEnd, *BufLenP);
-    print_oid(Vars->name, Vars->name_length),
-#endif
-    /* Now, let's put the Object Identifier into the buffer */
-    bufp = asn_build_objid(HeaderEnd, BufLenP,
-			   (u_char)(ASN_UNIVERSAL | 
-				    ASN_PRIMITIVE | 
-				    ASN_OBJECT_ID),
-			   Vars->name, Vars->name_length);
-    if (bufp == NULL)
-      return(NULL);
-
-    /* Now put the data in */
-    switch(Vars->type) {
-
-    case ASN_INTEGER:
-#ifdef DEBUG_VARS_ENCODE
-      printf("VARS %d: Encoding Integer %d at 0x%x\n", Counter,
-	     *(Vars->val.integer), bufp);
-#endif
-
-      bufp = asn_build_int(bufp, 
-			   BufLenP, Vars->type,
-			   (int *)Vars->val.integer, Vars->val_len);
-      break;
-
-    case SMI_COUNTER32:
-    case SMI_GAUGE32:
-      /*  case SMI_UNSIGNED32: */
-    case SMI_TIMETICKS:
-#ifdef DEBUG_VARS_ENCODE
-      printf("VARS %d: Encoding Timeticks %d at 0x%x\n", Counter,
-	     *(Vars->val.integer), bufp);
-#endif
-      bufp = asn_build_unsigned_int(bufp, BufLenP, 
-				    Vars->type,
-				    (u_int *)Vars->val.integer, Vars->val_len);
-      break;
-
-    case ASN_OCTET_STR:
-    case SMI_IPADDRESS:
-    case SMI_OPAQUE:
-#ifdef DEBUG_VARS_ENCODE
-      printf("VARS %d: Encoding String %s (%d bytes) at 0x%x\n", Counter,
-	     (Vars->val.string), Vars->val_len, bufp);
-#endif
-      bufp = asn_build_string(bufp, BufLenP, Vars->type,
-			      Vars->val.string, Vars->val_len);
-      break;
-
-    case ASN_OBJECT_ID:
-#ifdef DEBUG_VARS_ENCODE
-      printf("VARS %d: Encoding Object Identifier (%d bytes) at 0x%x\n",
-	     Counter,
-	     Vars->val_len, bufp);
-#endif
-      bufp = asn_build_objid(bufp, BufLenP, Vars->type,
-			     (oid *)Vars->val.objid, Vars->val_len / sizeof(oid));
-      break;
-
-    case SMI_NOSUCHINSTANCE:
-    case SMI_NOSUCHOBJECT:
-    case SMI_ENDOFMIBVIEW:
-
-#ifdef DEBUG_VARS_ENCODE
-      printf("VARS %d: Encoding NULL at 0x%x\n", Counter, bufp);
-#endif
-      if (Version == SNMP_VERSION_1) {
-        /* SNMP Version 1 does not support these error codes. */
-	bufp = asn_build_null(bufp, BufLenP, SMI_NOSUCHOBJECT);
-      } else {
-	bufp = asn_build_exception(bufp, BufLenP, Vars->type);
-      }
-      break;
-
-    case ASN_NULL:
-#ifdef DEBUG_VARS_ENCODE
-      printf("VARS %d: Encoding NULL at 0x%x\n", Counter, bufp);
-#endif
-      bufp = asn_build_null(bufp, BufLenP, Vars->type);
-      break;
-
-    case SMI_COUNTER64:
-      snmplib_debug(2, "Unable to encode type SMI_COUNTER64!\n");
-      /* Fall through */
-
-    default:
-      snmp_set_api_error(SNMPERR_UNSUPPORTED_TYPE);
-      return(NULL);
-    }
-
-    /* ASSERT:  bufp should now point to the next valid byte. */
-    if (bufp == NULL)
-      return(NULL);
-
-    /* Rebuild the header with the appropriate length */
-#ifdef DEBUG_VARS_ENCODE
-    printf("VARS %d: Resetting length to %d at 0x%x (%d bytes left)\n",
-	   Counter,
-	   (bufp - HeaderEnd), HeaderStart, *BufLenP);
-#endif
-    HeaderEnd = asn_build_header(HeaderStart, &FakeArg,
-				 (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 
-				 (bufp - HeaderEnd));
+    struct variable_list *Vars;
+    u_char *bufp;
+    u_char *HeaderStart;
+    u_char *HeaderEnd;
+    int FakeArg = *BufLenP;
+
+    bufp = Buffer;
+
+    for (Vars = VarList; Vars; Vars = Vars->next_variable) {
+
+	/* Build the header for this variable
+	 *
+	 * Use Maximum size.
+	 */
+	HeaderStart = bufp;
+	HeaderEnd = asn_build_header(HeaderStart, BufLenP,
+	    (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
+	    FakeArg);
+	if (HeaderEnd == NULL)
+	    return (NULL);
+
+	/* Now, let's put the Object Identifier into the buffer */
+	bufp = asn_build_objid(HeaderEnd, BufLenP,
+	    (u_char) (ASN_UNIVERSAL |
+		ASN_PRIMITIVE |
+		ASN_OBJECT_ID),
+	    Vars->name, Vars->name_length);
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* Now put the data in */
+	switch (Vars->type) {
+
+	case ASN_INTEGER:
+	    bufp = asn_build_int(bufp,
+		BufLenP, Vars->type,
+		(int *) Vars->val.integer, Vars->val_len);
+	    break;
+
+	case SMI_COUNTER32:
+	case SMI_GAUGE32:
+	    /*  case SMI_UNSIGNED32: */
+	case SMI_TIMETICKS:
+	    bufp = asn_build_unsigned_int(bufp, BufLenP,
+		Vars->type,
+		(u_int *) Vars->val.integer, Vars->val_len);
+	    break;
+
+	case ASN_OCTET_STR:
+	case SMI_IPADDRESS:
+	case SMI_OPAQUE:
+	    bufp = asn_build_string(bufp, BufLenP, Vars->type,
+		Vars->val.string, Vars->val_len);
+	    break;
+
+	case ASN_OBJECT_ID:
+	    bufp = asn_build_objid(bufp, BufLenP, Vars->type,
+		(oid *) Vars->val.objid, Vars->val_len / sizeof(oid));
+	    break;
+
+	case SMI_NOSUCHINSTANCE:
+	case SMI_NOSUCHOBJECT:
+	case SMI_ENDOFMIBVIEW:
+	    if (Version == SNMP_VERSION_1) {
+		/* SNMP Version 1 does not support these error codes. */
+		bufp = asn_build_null(bufp, BufLenP, SMI_NOSUCHOBJECT);
+	    } else {
+		bufp = asn_build_exception(bufp, BufLenP, Vars->type);
+	    }
+	    break;
+
+	case ASN_NULL:
+	    bufp = asn_build_null(bufp, BufLenP, Vars->type);
+	    break;
+
+	case SMI_COUNTER64:
+	    snmplib_debug(2, "Unable to encode type SMI_COUNTER64!\n");
+	    /* Fall through */
+
+	default:
+	    snmp_set_api_error(SNMPERR_UNSUPPORTED_TYPE);
+	    return (NULL);
+	}
+
+	/* ASSERT:  bufp should now point to the next valid byte. */
+	if (bufp == NULL)
+	    return (NULL);
+
+	/* Rebuild the header with the appropriate length */
+	HeaderEnd = asn_build_header(HeaderStart, &FakeArg,
+	    (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
+	    (bufp - HeaderEnd));
+
+	/* Returns NULL */
+	if (HeaderEnd == NULL)
+	    return (NULL);
 
-    /* Returns NULL */
-    if (HeaderEnd == NULL)
-      return(NULL);
-
-#ifdef DEBUG_VARS_ENCODE
-    Counter++;
-#endif
-  }
-
-#ifdef DEBUG_VARS_ENCODE
-  printf("VARS: Variable list of %d vars takes up %d bytes.\n",
-	 --Counter, StartLen - *BufLenP);
-#endif
+    }
 
-  /* or the end of the entire thing */
-  return(bufp);
+    /* or the end of the entire thing */
+    return (bufp);
 }
 
-			      
+
 
 
 /* Parse all Vars from the buffer */
-u_char *snmp_var_DecodeVarBind(u_char *Buffer, int *BufLen,
-			       struct variable_list **VarP,
-			       int Version)
+u_char *
+snmp_var_DecodeVarBind(u_char * Buffer, int *BufLen,
+    struct variable_list ** VarP,
+    int Version)
 {
-  struct variable_list *Var, **VarLastP;
-  u_char *bufp, *tmp;
-  u_char  VarBindType;
-  u_char *DataPtr;
-  int     DataLen;
-  oid TmpBuf[MAX_NAME_LEN];
+    struct variable_list *Var, **VarLastP;
+    u_char *bufp, *tmp;
+    u_char VarBindType;
+    u_char *DataPtr;
+    int DataLen;
+    oid TmpBuf[MAX_NAME_LEN];
 
-  int AllVarLen = *BufLen;
-  int ThisVarLen = 0;
+    int AllVarLen = *BufLen;
+    int ThisVarLen = 0;
 
-  VarLastP = VarP;
+    VarLastP = VarP;
 #ifdef DEBUG_VARS_DECODE
-  printf("VARS: Decoding buffer of length %d\n", *BufLen);
+    printf("VARS: Decoding buffer of length %d\n", *BufLen);
 #endif
 
-  /* Now parse the variables */
-  bufp = asn_parse_header(Buffer, &AllVarLen, &VarBindType);
-  if (bufp == NULL)
-    ASN_PARSE_ERROR(NULL);
-
-  if (VarBindType != (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
-      snmp_set_api_error(SNMPERR_PDU_PARSE);
-      ASN_PARSE_ERROR(NULL);
-  }
+    /* Now parse the variables */
+    bufp = asn_parse_header(Buffer, &AllVarLen, &VarBindType);
+    if (bufp == NULL)
+	ASN_PARSE_ERROR(NULL);
 
-#ifdef DEBUG_VARS_DECODE
-  printf("VARS: All Variable length %d\n", AllVarLen);
-#endif
-
-  /* We know how long the variable list is.  Parse it. */
-  while ((int)AllVarLen > 0) {
-
-    /* Create a new variable */
-    Var = snmp_var_new(NULL, MAX_NAME_LEN);
-    if (Var == NULL)
-      return(NULL);
-    
-    /* Parse the header to find out the length of this variable. */
-    ThisVarLen = AllVarLen;
-    tmp = asn_parse_header(bufp, &ThisVarLen, &VarBindType);
-    if (tmp == NULL)
-      ASN_PARSE_ERROR(NULL);
-
-    /* Now that we know the length , figure out how it relates to 
-     * the entire variable list
-     */
-    AllVarLen = AllVarLen - (ThisVarLen + (tmp - bufp));
-    bufp = tmp;
-
-    /* Is it valid? */
-    if (VarBindType != (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
-      snmp_set_api_error(SNMPERR_PDU_PARSE);
-      ASN_PARSE_ERROR(NULL);
+    if (VarBindType != (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
+	snmp_set_api_error(SNMPERR_PDU_PARSE);
+	ASN_PARSE_ERROR(NULL);
     }
-
 #ifdef DEBUG_VARS_DECODE
-    printf("VARS: Header type 0x%x (%d bytes left)\n", VarBindType, ThisVarLen);
+    printf("VARS: All Variable length %d\n", AllVarLen);
+#endif
+
+    /* We know how long the variable list is.  Parse it. */
+    while ((int) AllVarLen > 0) {
+
+	/* Create a new variable */
+	Var = snmp_var_new(NULL, MAX_NAME_LEN);
+	if (Var == NULL)
+	    return (NULL);
+
+	/* Parse the header to find out the length of this variable. */
+	ThisVarLen = AllVarLen;
+	tmp = asn_parse_header(bufp, &ThisVarLen, &VarBindType);
+	if (tmp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+
+	/* Now that we know the length , figure out how it relates to 
+	 * the entire variable list
+	 */
+	AllVarLen = AllVarLen - (ThisVarLen + (tmp - bufp));
+	bufp = tmp;
+
+	/* Is it valid? */
+	if (VarBindType != (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
+	    snmp_set_api_error(SNMPERR_PDU_PARSE);
+	    ASN_PARSE_ERROR(NULL);
+	}
+#ifdef DEBUG_VARS_DECODE
+	printf("VARS: Header type 0x%x (%d bytes left)\n", VarBindType, ThisVarLen);
 #endif
 
-    /* Parse the OBJID */
-    bufp = asn_parse_objid(bufp, &ThisVarLen, &VarBindType, 
-			   Var->name, &(Var->name_length));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-
-    if (VarBindType != (u_char)(ASN_UNIVERSAL | 
-				ASN_PRIMITIVE | 
-				ASN_OBJECT_ID)) {
-      snmp_set_api_error(SNMPERR_PDU_PARSE);
-      ASN_PARSE_ERROR(NULL);
-    }
+	/* Parse the OBJID */
+	bufp = asn_parse_objid(bufp, &ThisVarLen, &VarBindType,
+	    Var->name, &(Var->name_length));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
 
+	if (VarBindType != (u_char) (ASN_UNIVERSAL |
+		ASN_PRIMITIVE |
+		ASN_OBJECT_ID)) {
+	    snmp_set_api_error(SNMPERR_PDU_PARSE);
+	    ASN_PARSE_ERROR(NULL);
+	}
 #ifdef DEBUG_VARS_DECODE
-    printf("VARS: Decoded OBJID (%d bytes). (%d bytes left)\n", 
-	   Var->name_length, ThisVarLen);
+	printf("VARS: Decoded OBJID (%d bytes). (%d bytes left)\n",
+	    Var->name_length, ThisVarLen);
 #endif
 
-    /* Keep a pointer to this object */
-    DataPtr = bufp;
-    DataLen = ThisVarLen;
+	/* Keep a pointer to this object */
+	DataPtr = bufp;
+	DataLen = ThisVarLen;
 
-    /* find out type of object */
-    bufp = asn_parse_header(bufp, &ThisVarLen, &(Var->type));
-    if (bufp == NULL)
-      ASN_PARSE_ERROR(NULL);
-    ThisVarLen = DataLen;
+	/* find out type of object */
+	bufp = asn_parse_header(bufp, &ThisVarLen, &(Var->type));
+	if (bufp == NULL)
+	    ASN_PARSE_ERROR(NULL);
+	ThisVarLen = DataLen;
 
 #ifdef DEBUG_VARS_DECODE
-    printf("VARS: Data type %d\n", Var->type);
+	printf("VARS: Data type %d\n", Var->type);
 #endif
 
-    /* Parse the type */
-    
-    switch((short)Var->type){
+	/* Parse the type */
 
-    case ASN_INTEGER:
-      Var->val.integer = (int *)xmalloc(sizeof(int));
-      if (Var->val.integer == NULL) {
-	snmp_set_api_error(SNMPERR_OS_ERR);
-	return(NULL);
-      }
-      Var->val_len = sizeof(int);
-      bufp = asn_parse_int(DataPtr, &ThisVarLen, 
-			   &Var->type, (int *)Var->val.integer, 
-			   Var->val_len);
-#ifdef DEBUG_VARS_DECODE
-      printf("VARS: Decoded integer '%d' (%d bytes left)\n",
-	     *(Var->val.integer), ThisVarLen);
-#endif
-      break;
+	switch ((short) Var->type) {
 
-    case SMI_COUNTER32:
-    case SMI_GAUGE32:
-      /*  case SMI_UNSIGNED32: */
-    case SMI_TIMETICKS:
-      Var->val.integer = (int *)xmalloc(sizeof(u_int));
-      if (Var->val.integer == NULL) {
-	snmp_set_api_error(SNMPERR_OS_ERR);
-	return(NULL);
-      }
-      Var->val_len = sizeof(u_int);
-      bufp = asn_parse_unsigned_int(DataPtr, &ThisVarLen, 
-				    &Var->type, (u_int *)Var->val.integer, 
-				    Var->val_len);
+	case ASN_INTEGER:
+	    Var->val.integer = (int *) xmalloc(sizeof(int));
+	    if (Var->val.integer == NULL) {
+		snmp_set_api_error(SNMPERR_OS_ERR);
+		return (NULL);
+	    }
+	    Var->val_len = sizeof(int);
+	    bufp = asn_parse_int(DataPtr, &ThisVarLen,
+		&Var->type, (int *) Var->val.integer,
+		Var->val_len);
 #ifdef DEBUG_VARS_DECODE
-      printf("VARS: Decoded timeticks '%d' (%d bytes left)\n",
-	     *(Var->val.integer), ThisVarLen);
-#endif
-      break;
-
-    case ASN_OCTET_STR:
-    case SMI_IPADDRESS:
-    case SMI_OPAQUE:
-      Var->val_len = *&ThisVarLen; /* String is this at most */
-      Var->val.string = (u_char *)xmalloc((unsigned)Var->val_len);
-      if (Var->val.string == NULL) {
-	snmp_set_api_error(SNMPERR_OS_ERR);
-	return(NULL);
-      }
-      bufp = asn_parse_string(DataPtr, &ThisVarLen, 
-			      &Var->type, Var->val.string, 
-			      &Var->val_len);
+	    printf("VARS: Decoded integer '%d' (%d bytes left)\n",
+		*(Var->val.integer), ThisVarLen);
+#endif
+	    break;
+
+	case SMI_COUNTER32:
+	case SMI_GAUGE32:
+	    /*  case SMI_UNSIGNED32: */
+	case SMI_TIMETICKS:
+	    Var->val.integer = (int *) xmalloc(sizeof(u_int));
+	    if (Var->val.integer == NULL) {
+		snmp_set_api_error(SNMPERR_OS_ERR);
+		return (NULL);
+	    }
+	    Var->val_len = sizeof(u_int);
+	    bufp = asn_parse_unsigned_int(DataPtr, &ThisVarLen,
+		&Var->type, (u_int *) Var->val.integer,
+		Var->val_len);
 #ifdef DEBUG_VARS_DECODE
-      printf("VARS: Decoded string '%s' (length %d) (%d bytes left)\n",
-	     (Var->val.string), Var->val_len, ThisVarLen);
-#endif
-      break;
-         
-    case ASN_OBJECT_ID:
-      Var->val_len = MAX_NAME_LEN;
-      bufp = asn_parse_objid(DataPtr, &ThisVarLen, 
-			     &Var->type, TmpBuf, &Var->val_len);
-      Var->val_len *= sizeof(oid);
-      Var->val.objid = (oid *)xmalloc((unsigned)Var->val_len);
-      if (Var->val.integer == NULL) {
-	snmp_set_api_error(SNMPERR_OS_ERR);
-	return(NULL);
-      }
-      /* Only copy if we successfully decoded something */
-      if (bufp) {
-	xmemcpy((char *)Var->val.objid, (char *)TmpBuf, Var->val_len);
-      }
+	    printf("VARS: Decoded timeticks '%d' (%d bytes left)\n",
+		*(Var->val.integer), ThisVarLen);
+#endif
+	    break;
+
+	case ASN_OCTET_STR:
+	case SMI_IPADDRESS:
+	case SMI_OPAQUE:
+	    Var->val_len = *&ThisVarLen;	/* String is this at most */
+	    Var->val.string = (u_char *) xmalloc((unsigned) Var->val_len);
+	    if (Var->val.string == NULL) {
+		snmp_set_api_error(SNMPERR_OS_ERR);
+		return (NULL);
+	    }
+	    bufp = asn_parse_string(DataPtr, &ThisVarLen,
+		&Var->type, Var->val.string,
+		&Var->val_len);
 #ifdef DEBUG_VARS_DECODE
-      printf("VARS: Decoded OBJID (length %d) (%d bytes left)\n",
-	      Var->val_len, ThisVarLen);
-#endif
-      break;
-
-    case ASN_NULL:
-    case SMI_NOSUCHINSTANCE:
-    case SMI_NOSUCHOBJECT:
-    case SMI_ENDOFMIBVIEW:
-      break;
-
-    case SMI_COUNTER64:
-      snmplib_debug(2, "Unable to parse type SMI_COUNTER64!\n");
-      snmp_set_api_error(SNMPERR_UNSUPPORTED_TYPE);
-      return(NULL);
-      break;
-
-    default:
-      snmplib_debug(2, "bad type returned (%x)\n", Var->type);
-      snmp_set_api_error(SNMPERR_PDU_PARSE);
-      return(NULL);
-      break;
-    } /* End of var type switch */
+	    printf("VARS: Decoded string '%s' (length %d) (%d bytes left)\n",
+		(Var->val.string), Var->val_len, ThisVarLen);
+#endif
+	    break;
+
+	case ASN_OBJECT_ID:
+	    Var->val_len = MAX_NAME_LEN;
+	    bufp = asn_parse_objid(DataPtr, &ThisVarLen,
+		&Var->type, TmpBuf, &Var->val_len);
+	    Var->val_len *= sizeof(oid);
+	    Var->val.objid = (oid *) xmalloc((unsigned) Var->val_len);
+	    if (Var->val.integer == NULL) {
+		snmp_set_api_error(SNMPERR_OS_ERR);
+		return (NULL);
+	    }
+	    /* Only copy if we successfully decoded something */
+	    if (bufp) {
+		xmemcpy((char *) Var->val.objid, (char *) TmpBuf, Var->val_len);
+	    }
+#ifdef DEBUG_VARS_DECODE
+	    printf("VARS: Decoded OBJID (length %d) (%d bytes left)\n",
+		Var->val_len, ThisVarLen);
+#endif
+	    break;
 
-    if (bufp == NULL)
-      return(NULL);
+	case ASN_NULL:
+	case SMI_NOSUCHINSTANCE:
+	case SMI_NOSUCHOBJECT:
+	case SMI_ENDOFMIBVIEW:
+	    break;
+
+	case SMI_COUNTER64:
+	    snmplib_debug(2, "Unable to parse type SMI_COUNTER64!\n");
+	    snmp_set_api_error(SNMPERR_UNSUPPORTED_TYPE);
+	    return (NULL);
+	    break;
+
+	default:
+	    snmplib_debug(2, "bad type returned (%x)\n", Var->type);
+	    snmp_set_api_error(SNMPERR_PDU_PARSE);
+	    return (NULL);
+	    break;
+	}			/* End of var type switch */
+
+	if (bufp == NULL)
+	    return (NULL);
 
 #ifdef DEBUG_VARS_DECODE
-    printf("VARS:  Adding to list.\n");
+	printf("VARS:  Adding to list.\n");
 #endif
-    /* Add variable to the list */
-    *VarLastP = Var;
-    VarLastP = &(Var->next_variable);
-  }
+	/* Add variable to the list */
+	*VarLastP = Var;
+	VarLastP = &(Var->next_variable);
+    }
 
-  return(bufp);
+    return (bufp);
 }
@@ -13,7 +13,7 @@
 #endif
 
 #ifdef __STDC__
-void (*snmplib_debug_hook) (int,char *,...) = NULL;
+void (*snmplib_debug_hook) (int, char *,...) = NULL;
 #else
 void (*snmplib_debug_hook) (va_alist) = NULL;
 #endif
@@ -45,4 +45,3 @@ snmplib_debug(va_alist)
     }
     va_end(args);
 }
-
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.141 1998/04/02 17:11:21 rousskov Exp $
+#  $Id: Makefile.in,v 1.142 1998/04/04 01:43:59 kostas Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -151,10 +151,11 @@ OBJS	 	= \
 		$(XTRA_OBJS)
 
 SNMP_OBJS	= \
-		snmp.o \
+		snmp_core.o \
                 snmp_oidlist.o \
                 snmp_agent.o  \
-		snmp_config.o
+		snmp_config.o \
+		snmp_auth.o
 
 HTCP_OBJS	= htcp.o
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.155 1998/03/29 08:50:56 wessels Exp $
+ * $Id: acl.cc,v 1.156 1998/04/04 01:44:00 kostas Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -124,6 +124,7 @@ static void aclParseWordList(void *curlist);
 static void aclParseProtoList(void *curlist);
 static void aclParseMethodList(void *curlist);
 static void aclParseTimeSpec(void *curlist);
+static void aclParseSnmpComm(void *curlist);
 static char *strtokFile(void);
 
 static char *
@@ -206,6 +207,8 @@ aclStrToType(const char *s)
 	return ACL_SRC_ASN;
     if (!strcmp(s, "dst_as"))
 	return ACL_DST_ASN;
+    if (!strcmp(s, "snmp_community"))
+	return ACL_SNMP_COMM;
 #if USE_ARP_ACL
     if (!strcmp(s, "arp"))
 	return ACL_SRC_ARP;
@@ -250,6 +253,8 @@ aclTypeToStr(squid_acl type)
 	return "src_as";
     if (type == ACL_DST_ASN)
 	return "dst_as";
+    if (type == ACL_SNMP_COMM)
+	return "snmp_community";
 #if USE_ARP_ACL
     if (type == ACL_SRC_ARP)
 	return "arp";
@@ -736,6 +741,23 @@ aclParseProxyAuth(void *data)
     return;
 }
 
+static void
+aclParseSnmpComm(void *data)
+{
+    acl_snmp_comm **q=data;
+    acl_snmp_comm *p;
+    char *t;
+    t = strtok(NULL, w_space);
+    if (t) {
+	p=xcalloc(1, sizeof(acl_snmp_comm));
+	p->name=xstrdup(t);
+	p->community=NULL;
+	*q=p;
+    }
+    t=strtok(NULL, w_space);
+    return;
+}
+
 void
 aclParseAclLine(acl ** head)
 {
@@ -821,6 +843,9 @@ aclParseAclLine(acl ** head)
     case ACL_PROXY_AUTH:
 	aclParseProxyAuth(&A->data);
 	break;
+    case ACL_SNMP_COMM:
+	aclParseSnmpComm(&A->data);
+	break;
 #if USE_ARP_ACL
     case ACL_SRC_ARP:
 	aclParseArpList(&A->data);
@@ -1411,6 +1436,8 @@ aclMatchAcl(acl * acl, aclCheck_t * checklist)
 	    return 1;
 	}
 	/* NOTREACHED */
+    case ACL_SNMP_COMM:
+	return asnMatchIp(acl->data, checklist->src_addr);
     case ACL_SRC_ASN:
 	return asnMatchIp(acl->data, checklist->src_addr);
     case ACL_DST_ASN:
@@ -73,6 +73,7 @@ typedef enum {
     ACL_SRC_ASN,
     ACL_DST_ASN,
     ACL_SRC_ARP,
+    ACL_SNMP_COMM,
     ACL_ENUM_MAX
 } squid_acl;
 
@@ -394,10 +394,10 @@ extern int snmpInitConfig(void);
 extern void snmpConnectionOpen(void);
 extern void snmpConnectionShutdown(void);
 extern void snmpConnectionClose(void);
-extern int create_view(char **);
-extern int create_user(char **);
-extern int create_community(char **);
-extern void tokenize(char *, char **, int);
+extern int snmpCreateView(char **);
+extern int snmpCreateUser(char **);
+extern int snmpCreateCommunity(char **);
+extern void snmpTokenize(char *, char **, int);
 extern int snmpCompare(oid * name1, int len1, oid * name2, int len2);
 #endif /* SQUID_SNMP */
 
@@ -908,7 +908,7 @@ extern int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
 extern void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
 extern void cacheDigestDel(CacheDigest * cd, const cache_key * key);
 extern double cacheDigestUtil(const CacheDigest * cd, int *bit_cnt_p, int *on_cnt_p);
-extern void cacheDigestReport(CacheDigest *cd, const char *label, StoreEntry * e);
+extern void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
 
 /*
  * prototypes for system functions missing from system includes
@@ -1,289 +1,47 @@
+
+/*
+ * $Id: snmp_agent.cc,v 1.44 1998/04/04 01:44:02 kostas Exp $
+ *
+ * DEBUG: section 49     SNMP Interface
+ * AUTHOR: Kostas Anagnostakis
+ *
+ * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
+ * --------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from the
+ *  Internet community.  Development is led by Duane Wessels of the
+ *  National Laboratory for Applied Network Research and funded by
+ *  the National Science Foundation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  
+ */
+
+
 #include "squid.h"
 
 #include "snmp.h"
 #include "snmp_impl.h"
 #include "asn1.h"
 #include "snmp_api.h"
-#include "snmp_client.h"
 #include "snmp_vars.h"
 #include "snmp_oidlist.h"
 #include "cache_snmp.h"
 
-#include "mib.h"
-
-void snmpAclCheckDone(int answer, void *);
-static struct snmp_pdu *snmp_agent_response(struct snmp_pdu *PDU);
-static int community_check(char *b, oid * name, int namelen);
-struct snmp_session *Session;
 extern StatCounters *snmpStatGet(int);
-extern void snmp_agent_parse_done(int, snmp_request_t *);
-void addr2oid(struct in_addr addr, oid *);
-void snmpAclCheckStart(snmp_request_t * rq);
-
-
-/* returns: 
- * 2: no such object in this mib
- * 1: ok
- * 0: failed */
-
-void
-snmp_agent_parse(snmp_request_t * rq)
-{
-    snint this_reqid;
-    u_char *buf = rq->buf;
-    int len = rq->len;
-
-    struct snmp_pdu *PDU;
-    u_char *Community;
-
-    /* Now that we have the data, turn it into a PDU */
-    cbdataAdd(rq, MEM_NONE);
-    PDU = snmp_pdu_create(0);
-    Community = snmp_parse(Session, PDU, buf, len);
-
-    if (!snmp_coexist_V2toV1(PDU)) {	/* incompatibility */
-	debug(49, 3) ("snmp_agent_parse: Incompatible V2 packet.\n");
-	snmp_free_pdu(PDU);
-	snmp_agent_parse_done(0, rq);
-	return;
-    }
-    rq->community = Community;
-    rq->PDU = PDU;
-    this_reqid = PDU->reqid;
-    debug(49, 5) ("snmp_agent_parse: reqid=%d\n", PDU->reqid);
-
-    if (Community == NULL) {
-	debug(49, 8) ("snmp_agent_parse: Community == NULL\n");
-
-	snmp_free_pdu(PDU);
-	snmp_agent_parse_done(0, rq);
-	return;
-    }
-    snmpAclCheckStart(rq);
-}
-
-void
-snmpAclCheckStart(snmp_request_t * rq)
-{
-    communityEntry *cp;
-    for (cp = Config.Snmp.communities; cp != NULL; cp = cp->next)
-	if (!strcmp((char *) rq->community, cp->name) && cp->acls) {
-	    rq->acl_checklist = aclChecklistCreate(cp->acls,
-		NULL, rq->from.sin_addr, NULL, NULL);
-	    aclNBCheck(rq->acl_checklist, snmpAclCheckDone, rq);
-	    return;
-	}
-    snmpAclCheckDone(ACCESS_ALLOWED, rq);
-}
-
-void
-snmpAclCheckDone(int answer, void *data)
-{
-    snmp_request_t *rq = data;
-    u_char *outbuf = rq->outbuf;
-
-    struct snmp_pdu *PDU, *RespPDU;
-    u_char *Community;
-    variable_list *VarPtr;
-    variable_list **VarPtrP;
-    int ret;
-
-    debug(49, 5) ("snmpAclCheckDone: called with answer=%d.\n", answer);
-    rq->acl_checklist = NULL;
-    PDU = rq->PDU;
-    Community = rq->community;
-
-    if (answer == ACCESS_DENIED) {
-	debug(49, 5) ("snmpAclCheckDone: failed on acl.\n");
-	snmp_agent_parse_done(0, rq);
-	return;
-    }
-    for (VarPtrP = &(PDU->variables);
-	*VarPtrP;
-	VarPtrP = &((*VarPtrP)->next_variable)) {
-	VarPtr = *VarPtrP;
-
-	debug(49, 5) ("snmpAclCheckDone: checking.\n");
-	/* access check for each variable */
-
-	if (!community_check((char *) Community, VarPtr->name, VarPtr->name_length)) {
-	    debug(49, 5) ("snmpAclCheckDone: failed on community_check.\n");
-	    snmp_agent_parse_done(0, rq);
-	    return;
-	}
-    }
-    Session->community = Community;
-    Session->community_len = strlen((char *) Community);
-    RespPDU = snmp_agent_response(PDU);
-    snmp_free_pdu(PDU);
-    if (RespPDU == NULL) {
-	debug(49, 8) ("snmpAclCheckDone: RespPDU == NULL. Returning code 2.\n");
-	debug(49, 5) ("snmpAclCheckDone: failed on RespPDU==NULL.\n");
-	snmp_agent_parse_done(2, rq);
-	return;
-    }
-    debug(49, 8) ("snmpAclCheckDone: Response pdu (%x) errstat=%d reqid=%d.\n",
-	RespPDU, RespPDU->errstat, RespPDU->reqid);
-
-    /* Encode it */
-    ret = snmp_build(Session, RespPDU, outbuf, &rq->outlen);
-    /* XXXXX Handle failure */
-    snmp_free_pdu(RespPDU);
-    /* XXX maybe here */
-    debug(49, 5) ("snmpAclCheckDone: ok!\n");
-    snmp_agent_parse_done(1, rq);
-}
-
-
 
-static struct snmp_pdu *
-snmp_agent_response(struct snmp_pdu *PDU)
-{
-    struct snmp_pdu *Answer = NULL;
-    variable_list *VarPtr, *VarNew = NULL;
-    variable_list **VarPtrP, **RespVars;
-    int index = 0;
-    oid_ParseFn *ParseFn;
-
-    debug(49, 9) ("snmp_agent_response: Received a %d PDU\n", PDU->command);
-
-    /* Create a response */
-    Answer = snmp_pdu_create(SNMP_PDU_RESPONSE);
-    if (Answer == NULL)
-	return (NULL);
-    Answer->reqid = PDU->reqid;
-    Answer->errindex = 0;
-
-    if (PDU->command == SNMP_PDU_GET) {
-
-	RespVars = &(Answer->variables);
-	/* Loop through all variables */
-	for (VarPtrP = &(PDU->variables);
-	    *VarPtrP;
-	    VarPtrP = &((*VarPtrP)->next_variable)) {
-	    VarPtr = *VarPtrP;
-
-	    index++;
-
-	    /* Find the parsing function for this variable */
-	    ParseFn = oidlist_Find(VarPtr->name, VarPtr->name_length);
-
-	    if (ParseFn == NULL) {
-		Answer->errstat = SNMP_ERR_NOSUCHNAME;
-		debug(49, 5) ("snmp_agent_response: No such oid. ");
-	    } else
-		VarNew = (*ParseFn) (VarPtr, (snint *) & (Answer->errstat));
-
-	    /* Was there an error? */
-	    if ((Answer->errstat != SNMP_ERR_NOERROR) ||
-		(VarNew == NULL)) {
-		Answer->errindex = index;
-		debug(49, 5) ("snmp_agent_parse: successful.\n");
-		/* Just copy the rest of the variables.  Quickly. */
-		*RespVars = VarPtr;
-		*VarPtrP = NULL;
-		return (Answer);
-	    }
-	    /* No error.  Insert this var at the end, and move on to the next.
-	     */
-	    *RespVars = VarNew;
-	    RespVars = &(VarNew->next_variable);
-	}
-
-	return (Answer);
-    } else if (PDU->command == SNMP_PDU_GETNEXT) {
-	oid *TmpOidName;
-	int TmpOidNameLen = 0;
-
-	/* Find the next OID. */
-	VarPtr = PDU->variables;
-
-	ParseFn = oidlist_Next(VarPtr->name, VarPtr->name_length,
-	    &(TmpOidName), (snint *) & (TmpOidNameLen));
-
-	if (ParseFn == NULL) {
-	    Answer->errstat = SNMP_ERR_NOSUCHNAME;
-	    debug(49, 9) ("snmp_agent_response: No such oid: ");
-	    print_oid(VarPtr->name, VarPtr->name_length);
-	} else {
-	    xfree(VarPtr->name);
-	    VarPtr->name = TmpOidName;
-	    VarPtr->name_length = TmpOidNameLen;
-	    VarNew = (*ParseFn) (VarPtr, (snint *) & (Answer->errstat));
-	}
-
-	/* Was there an error? */
-	if (Answer->errstat != SNMP_ERR_NOERROR) {
-	    Answer->errindex = 1;
-
-	    /* Just copy this variable */
-	    Answer->variables = VarPtr;
-	    PDU->variables = NULL;
-	} else {
-	    Answer->variables = VarNew;
-	}
-
-	/* Done.  Return this PDU */
-	return (Answer);
-    }				/* end SNMP_PDU_GETNEXT */
-    debug(49, 9) ("snmp_agent_response: Ignoring PDU %d\n", PDU->command);
-    snmp_free_pdu(Answer);
-    return (NULL);
-}
-
-int
-in_view(oid * name, int namelen, int viewIndex)
-{
-    viewEntry *vwp, *savedvwp = NULL;
-
-    debug(49, 8) ("in_view: called with index=%d\n", viewIndex);
-    for (vwp = Config.Snmp.views; vwp; vwp = vwp->next) {
-	if (vwp->viewIndex != viewIndex)
-	    continue;
-	debug(49, 8) ("in_view: found view for subtree:\n");
-	print_oid(vwp->viewSubtree, vwp->viewSubtreeLen);
-	if (vwp->viewSubtreeLen > namelen
-	    || memcmp(vwp->viewSubtree, name, vwp->viewSubtreeLen * sizeof(oid)))
-	    continue;
-	/* no wildcards here yet */
-	if (!savedvwp) {
-	    savedvwp = vwp;
-	} else {
-	    if (vwp->viewSubtreeLen > savedvwp->viewSubtreeLen)
-		savedvwp = vwp;
-	}
-    }
-    if (!savedvwp)
-	return FALSE;
-    if (savedvwp->viewType == VIEWINCLUDED)
-	return TRUE;
-    return FALSE;
-}
-
-
-static int
-community_check(char *b, oid * name, int namelen)
-{
-    communityEntry *cp;
-    debug(49, 8) ("community_check: %s against:\n", b);
-    print_oid(name, namelen);
-    for (cp = Config.Snmp.communities; cp; cp = cp->next)
-	if (!strcmp(b, cp->name)) {
-	    return in_view(name, namelen, cp->readView);
-	}
-    return 0;
-}
-
-int
-init_agent_auth()
-{
-    Session = (struct snmp_session *) xmalloc(sizeof(struct snmp_session));
-    Session->Version = SNMP_VERSION_1;
-    Session->authenticator = NULL;
-    Session->community = (u_char *) xstrdup("public");
-    Session->community_len = 6;
-    return 1;
-}
 
 /************************************************************************
 
@@ -358,8 +116,8 @@ snmp_sysFn(variable_list * Var, snint * ErrP)
     static struct in_addr addr;
     static snint snint_return;
 
-    debug(49, 5) ("snmp_sysFn: Processing request with magic %d: \n", Var->name[8]);
-    print_oid(Var->name, Var->name_length);
+    debug(49, 5) ("snmp_sysFn: Processing request:\n", Var->name[8]);
+    snmpDebugOid(5, Var->name, Var->name_length);
 
     Answer = snmp_var_new(Var->name, Var->name_length);
     *ErrP = SNMP_ERR_NOERROR;
@@ -935,12 +693,6 @@ struct in_addr *
 oid2addr(oid * id)
 {
     static struct in_addr laddr;
-#if 0
-    static u_char buf[15];
-    snprintf(buf, 15, "%d.%d.%d.%d", id[0], id[1], id[2], id[3]);
-    safe_inet_addr(buf, &laddr);
-    return &laddr;
-#endif
     u_char *cp = (u_char *) & (laddr.s_addr);
     cp[0] = id[0];
     cp[1] = id[1];
@@ -0,0 +1,844 @@
+/*
+ * $Id: snmp_core.cc,v 1.1 1998/04/04 01:44:04 kostas Exp $
+ *
+ * DEBUG: section 49    SNMP support
+ * AUTHOR: Kostas Anagnostakis
+ *
+ * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
+ * --------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from the
+ *  Internet community.  Development is led by Duane Wessels of the
+ *  National Laboratory for Applied Network Research and funded by
+ *  the National Science Foundation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  
+ */
+
+/**********************************************************************
+ *
+ *           Copyright 1996 by Carnegie Mellon University
+ * 
+ *                       All Rights Reserved
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of CMU not be
+ * used in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.
+ * 
+ * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHAL
+ * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ * 
+ * Author: Ryan Troll <ryan+@andrew.cmu.edu>
+ * 
+ **********************************************************************/
+
+
+#include "squid.h"
+
+#include "cache_snmp.h"
+#include "squid_mib.h"
+
+#define SNMP_REQUEST_SIZE 4096
+#define MAX_PROTOSTAT 5
+
+int snmp_dump_packet;
+void *users, *communities;
+
+static struct sockaddr_in local_snmpd;
+static snmp_init_config = 0;
+struct snmp_session *Session;
+struct snmp_pdu *snmpAgentResponse(struct snmp_pdu *PDU);
+
+void snmpFwd_insertPending(struct sockaddr_in *, long);
+int snmpFwd_removePending(struct sockaddr_in *, long);
+
+extern void (*snmplib_debug_hook) (int, char *);
+static void snmpSnmplibDebug(int lvl, char *buf);
+
+struct snmpUdpData {
+    struct sockaddr_in address;
+    void *msg;
+    int len;
+    struct snmpUdpData *next;
+};
+
+typedef struct snmpUdpData snmpUdpData;
+
+struct snmpFwdQueue {
+    struct sockaddr_in addr;
+    long req_id;
+    time_t req_time;
+    struct snmpFwdQueue *next;
+};
+
+struct snmpFwdQueue *snmpHead = NULL;
+
+struct snmpUdpData *snmpUdpHead = NULL;
+struct snmpUdpData *snmpUdpTail = NULL;
+
+void snmpUdpReply(int, void *);
+void snmpAppendUdp(snmpUdpData *);
+void snmpUdpSend(int, const struct sockaddr_in *, void *, int);
+
+/* now include mib location definitions
+ * and magic numbers */
+
+#include "cache_snmp.h"
+
+
+static void
+snmpSnmplibDebug(int lvl, char *buf)
+{
+    debug(49, lvl) ("%s", buf);
+}
+
+void
+snmpHandleUdp(int sock, void *not_used)
+{
+    struct sockaddr_in from;
+    int from_len;
+    LOCAL_ARRAY(char, buf, SNMP_REQUEST_SIZE);
+    LOCAL_ARRAY(char, deb_line, 4096);
+    int len;
+    snmp_request_t *snmp_rq;
+
+    debug(49, 5) ("snmpHandleUdp: Called.\n");
+    commSetSelect(sock, COMM_SELECT_READ, snmpHandleUdp, NULL, 0);
+    from_len = sizeof(struct sockaddr_in);
+    memset(&from, '\0', from_len);
+    len = recvfrom(sock,
+	buf,
+	SNMP_REQUEST_SIZE,
+	0,
+	(struct sockaddr *) &from,
+	&from_len);
+    if (len < 0) {
+#ifdef _SQUID_LINUX_
+	/* Some Linux systems seem to set the FD for reading and then
+	 * return ECONNREFUSED when sendto() fails and generates an ICMP
+	 * port unreachable message. */
+	/* or maybe an EHOSTUNREACH "No route to host" message */
+	if (errno != ECONNREFUSED && errno != EHOSTUNREACH)
+#endif
+	    debug(49, 1) ("snmpHandleUdp: FD %d recvfrom: %s\n",
+		sock, xstrerror());
+	return;
+    }
+    if (snmp_dump_packet) {
+	int count;
+	debug(49, 6) ("received %d bytes from %s:\n", (int) len,
+	    inet_ntoa(from.sin_addr));
+	for (count = 0; count < len; count++) {
+	    snprintf(deb_line, 4096, "%s %02X ", deb_line, (u_char) buf[count]);
+	    if ((count % 16) == 15 || count == (len - 1)) {
+		debug(49, 8) ("snmp in: %s\n", deb_line);
+		deb_line[0] = '\0';
+	    }
+	}
+    }
+    buf[len] = '\0';
+    debug(49, 3) ("snmpHandleUdp: FD %d: received %d bytes from %s.\n",
+	sock,
+	len,
+	inet_ntoa(from.sin_addr));
+
+    snmp_rq = xcalloc(1, sizeof(snmp_request_t));
+    snmp_rq->buf = (u_char *) buf;
+    snmp_rq->len = len;
+    snmp_rq->sock = sock;
+    snmp_rq->outbuf = xmalloc(snmp_rq->outlen = SNMP_REQUEST_SIZE);
+    memcpy(&snmp_rq->from, &from, sizeof(struct sockaddr_in));
+    snmpAgentParse(snmp_rq);
+}
+
+void
+snmpAgentParseDone(int errstat, void * data)
+{
+    snmp_request_t *snmp_rq=(snmp_request_t *)data;
+    LOCAL_ARRAY(char, deb_line, 4096);
+    int sock = snmp_rq->sock;
+    long this_reqid = snmp_rq->reqid;
+    debug(49, 2) ("snmpAgentParseDone: errstat=%d, reqid=%d _t=%x\n",
+	errstat, this_reqid, snmp_rq);
+
+    if (memcmp(&snmp_rq->from, &local_snmpd, sizeof(struct sockaddr_in)) == 0) {
+	/* look it up */
+	if (snmpFwd_removePending(&snmp_rq->from, this_reqid)) { /* failed */
+	    debug(49, 2) ("snmp: bogus response from %s.\n",
+		inet_ntoa(snmp_rq->from.sin_addr));
+	    if (snmp_rq->community)
+		xfree(snmp_rq->community);
+	    xfree(snmp_rq->outbuf);
+	    xfree(snmp_rq);
+	    return;
+	}
+    }
+    switch (errstat) {
+    case 2:			/* we might have to forward */
+	if (Config.Snmp.localPort != 0) {
+	    snmpFwd_insertPending(&snmp_rq->from, this_reqid);
+	    snmpUdpSend(sock, &local_snmpd, snmp_rq->outbuf, snmp_rq->outlen);
+	    break;
+	}
+	debug(49, 4) ("snmp: can't forward.\n");
+	break;
+    case 1:			/* everything is ok */
+	debug(49, 5) ("snmp: parsed.\n");
+	if (snmp_dump_packet) {
+	    int count = 0;
+	    debug(49, 5) ("snmp: sent %d bytes to %s\n", (int) snmp_rq->outlen,
+		inet_ntoa(snmp_rq->from.sin_addr));
+	    for (count = 0; count < snmp_rq->outlen; count++) {
+		snprintf(deb_line, 4096, "%s %02X ", deb_line,
+		    (u_char) snmp_rq->outbuf[count]);
+		if ((count % 16) == 15 || count == (snmp_rq->len - 1)) {
+		    debug(49, 7) ("snmp out: %s\n", deb_line);
+		    deb_line[0] = '\0';
+		}
+	    }
+	}
+	snmpUdpSend(snmp_rq->sock, &snmp_rq->from, snmp_rq->outbuf, snmp_rq->outlen);
+	break;
+    case 0:
+	debug(49, 5) ("snmpagentparsedone failed\n");
+	if (snmp_rq->outbuf)
+	    xfree(snmp_rq->outbuf);
+	break;
+    }
+    if (snmp_rq->community)
+	xfree(snmp_rq->community);
+    cbdataFree(snmp_rq);
+    return;
+}
+
+void
+snmpInit(void)
+{
+    assert(NULL != Config.Snmp.mibPath);
+    if (!snmpInitConfig())
+	debug(49, 0) ("snmpInit: snmpInitConfig() failed.\n");
+    snmplib_debug_hook = snmpSnmplibDebug;
+
+}
+int
+snmpInitConfig()
+{
+    wordlist *w;
+    char *buf;
+    char *tokens[10];
+
+    if (snmp_init_config)
+	return 1;
+
+    snmp_init_config = 1;
+    assert(NULL != Config.Snmp.mibPath);
+    if (Mib == NULL) {
+	debug(49, 3) ("init_mib: calling with %s\n", Config.Snmp.mibPath);
+	init_mib(Config.Snmp.mibPath);
+    }
+    if (Mib == NULL) {
+	debug(49, 0) ("WARNING: Failed to open MIB '%s'\n",
+	    Config.Snmp.mibPath);
+	return 0;
+    }
+    /*
+     * Process 'snmp_agent_conf' lines
+     */
+    for (w = Config.Snmp.snmpconf; w != NULL; w = w->next) {
+	buf = xstrdup(w->key);
+	snmpTokenize(buf, tokens, 10);
+	if (0 == strcmp("view", tokens[0])) {
+	    if (snmpCreateView(tokens) < 0) {
+		debug(49, 1) ("snmpInit: error parsing '%s'\n", w->key);
+		safe_free(buf);
+		return 0;
+	    }
+	} else if (0 == strcmp("user", tokens[0])) {
+	    if (snmpCreateUser(tokens) < 0) {
+		debug(49, 1) ("snmpInit: error parsing '%s'\n", w->key);
+		safe_free(buf);
+		return 0;
+	    }
+	} else if (0 == strcmp("community", tokens[0])) {
+	    if (snmpCreateCommunity(tokens) < 0)
+		debug(49, 1) ("snmpInit: error parsing '%s'\n", w->key);
+	} else {
+	    debug(49, 1) ("snmpInit: error parsing '%s'\n", w->key);
+	    safe_free(buf);
+	    return 0;
+	}
+	safe_free(buf);
+    }
+    if (!Config.Snmp.communities) {
+	debug(49, 2) ("snmpInit: WARNING: communities not defined.\n");
+    } else
+	debug(49, 5) ("snmpInit: communities defined.\n");
+    snmpInitAgentAuth();
+    assert(0 <= snmpDefaultAuth());
+    return 1;
+}
+
+void
+snmpConnectionOpen(void)
+{
+    u_short port;
+    struct in_addr addr;
+    struct sockaddr_in xaddr;
+    int len;
+    int x;
+
+    if ((port = Config.Port.snmp) > (u_short) 0) {
+	enter_suid();
+	theInSnmpConnection = comm_open(SOCK_DGRAM,
+	    0,
+	    Config.Addrs.snmp_incoming,
+	    port,
+	    COMM_NONBLOCKING,
+	    "SNMP Port");
+	leave_suid();
+	if (theInSnmpConnection < 0)
+	    fatal("Cannot open snmp Port");
+	commSetSelect(theInSnmpConnection, COMM_SELECT_READ, snmpHandleUdp, NULL, 0);
+	debug(1, 1) ("Accepting SNMP messages on port %d, FD %d.\n",
+	    (int) port, theInSnmpConnection);
+	if ((addr = Config.Addrs.udp_outgoing).s_addr != no_addr.s_addr) {
+	    enter_suid();
+	    theOutSnmpConnection = comm_open(SOCK_DGRAM,
+		0,
+		addr,
+		port,
+		COMM_NONBLOCKING,
+		"SNMP Port");
+	    leave_suid();
+	    if (theOutSnmpConnection < 0)
+		fatal("Cannot open Outgoing SNMP Port");
+	    commSetSelect(theOutSnmpConnection,
+		COMM_SELECT_READ,
+		snmpHandleUdp,
+		NULL, 0);
+	    debug(1, 1) ("Outgoing SNMP messages on port %d, FD %d.\n",
+		(int) port, theOutSnmpConnection);
+	    fd_note(theOutSnmpConnection, "Outgoing SNMP socket");
+	    fd_note(theInSnmpConnection, "Incoming SNMP socket");
+	} else {
+	    theOutSnmpConnection = theInSnmpConnection;
+	}
+	memset(&theOutSNMPAddr, '\0', sizeof(struct in_addr));
+	len = sizeof(struct sockaddr_in);
+	memset(&xaddr, '\0', len);
+	x = getsockname(theOutSnmpConnection,
+	    (struct sockaddr *) &xaddr, &len);
+	if (x < 0)
+	    debug(51, 1) ("theOutSnmpConnection FD %d: getsockname: %s\n",
+		theOutSnmpConnection, xstrerror());
+	else {
+	    theOutSNMPAddr = xaddr.sin_addr;
+	    if (Config.Snmp.localPort != 0) {
+		local_snmpd.sin_addr = xaddr.sin_addr;
+		local_snmpd.sin_port = Config.Snmp.localPort;
+	    }
+	}
+    }
+}
+
+void
+snmpFwd_insertPending(struct sockaddr_in *ad, long reqid)
+{
+    struct snmpFwdQueue *new;
+
+    new = (struct snmpFwdQueue *) xcalloc(1, sizeof(struct snmpFwdQueue));
+    xmemcpy(&new->addr, ad, sizeof(struct sockaddr_in));
+    new->req_id = reqid;
+    new->req_time = squid_curtime;
+    if (snmpHead == NULL) {
+	new->next = NULL;
+	snmpHead = new;
+    }
+    new->next = snmpHead;
+    snmpHead = new;
+}
+
+int
+snmpFwd_removePending(struct sockaddr_in *fr, long reqid)
+{
+    struct snmpFwdQueue *p, *prev = NULL;
+    for (p = snmpHead; p != NULL; p = p->next, prev = p)
+	if (reqid == p->req_id) {
+	    xmemcpy(fr, &p->addr, sizeof(struct sockaddr_in));
+	    if (p == snmpHead)
+		snmpHead = p->next;
+	    else if (p->next == NULL)
+		prev->next = NULL;
+	    debug(49, 3) ("snmpFwd_removePending: freeing %p\n", p);
+	    xfree(p);
+	    return 0;
+	}
+    return 1;
+}
+
+void
+snmpUdpSend(int fd,
+    const struct sockaddr_in *to,
+    void *msg, int len)
+{
+    snmpUdpData *data = xcalloc(1, sizeof(snmpUdpData));
+    debug(49, 5) ("snmpUdpSend: Queueing response for %s\n",
+	inet_ntoa(to->sin_addr));
+    data->address = *to;
+    data->msg = msg;
+    data->len = len;
+    snmpAppendUdp(data);
+    commSetSelect(fd, COMM_SELECT_WRITE, snmpUdpReply, snmpUdpHead, 0);
+
+}
+void
+snmpUdpReply(int fd, void *data)
+{
+    snmpUdpData *queue = data;
+    int x;
+    /* Disable handler, in case of errors. */
+    commSetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
+    while ((queue = snmpUdpHead) != NULL) {
+	debug(49, 5) ("snmpUdpReply: FD %d sending %d bytes to %s port %d\n",
+	    fd,
+	    queue->len,
+	    inet_ntoa(queue->address.sin_addr),
+	    ntohs(queue->address.sin_port));
+	x = comm_udp_sendto(fd,
+	    &queue->address,
+	    sizeof(struct sockaddr_in),
+	    queue->msg,
+	    queue->len);
+	if (x < 0) {
+	    if (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR)
+		break;		/* don't de-queue */
+	}
+	snmpUdpHead = queue->next;
+	debug(49, 3) ("snmpUdpReply: freeing %p\n", queue->msg);
+	safe_free(queue->msg);
+	debug(49, 3) ("snmpUdpReply: freeing %p\n", queue);
+	safe_free(queue);
+    }
+    /* Reinstate handler if needed */
+    if (snmpUdpHead) {
+	commSetSelect(fd, COMM_SELECT_WRITE, snmpUdpReply, snmpUdpHead, 0);
+    }
+}
+
+void
+snmpAppendUdp(snmpUdpData * item)
+{
+    item->next = NULL;
+    if (snmpUdpHead == NULL) {
+	snmpUdpHead = item;
+	snmpUdpTail = item;
+    } else if (snmpUdpTail == snmpUdpHead) {
+	snmpUdpTail = item;
+	snmpUdpHead->next = item;
+    } else {
+	snmpUdpTail->next = item;
+	snmpUdpTail = item;
+    }
+
+}
+
+void
+snmpConnectionShutdown(void)
+{
+    if (theInSnmpConnection < 0)
+	return;
+    if (theInSnmpConnection != theOutSnmpConnection) {
+	debug(49, 1) ("FD %d Closing SNMP socket\n", theInSnmpConnection);
+	comm_close(theInSnmpConnection);
+    }
+    /*
+     * Here we set 'theInSnmpConnection' to -1 even though the SNMP 'in'
+     * and 'out' sockets might be just one FD.  This prevents this
+     * function from executing repeatedly.  When we are really ready to
+     * exit or restart, main will comm_close the 'out' descriptor.
+     */ theInSnmpConnection = -1;
+    /* 
+     * Normally we only write to the outgoing SNMP socket, but we
+     * also have a read handler there to catch messages sent to that
+     * specific interface.  During shutdown, we must disable reading
+     * on the outgoing socket.
+     */
+    assert(theOutSnmpConnection > -1);
+    commSetSelect(theOutSnmpConnection, COMM_SELECT_READ, NULL, NULL, 0);
+}
+
+void
+snmpConnectionClose(void)
+{
+    snmpConnectionShutdown();
+    if (theOutSnmpConnection > -1) {
+	debug(49, 1) ("FD %d Closing SNMP socket\n", theOutSnmpConnection);
+	comm_close(theOutSnmpConnection);
+    }
+}
+
+/* returns: 
+ * 2: no such object in this mib
+ * 1: ok
+ * 0: failed */
+
+void
+snmpAgentParse(void *data)
+{
+    snmp_request_t * rq=(snmp_request_t *)data;
+    u_char *buf = rq->buf;
+    int len = rq->len;
+
+    struct snmp_pdu *PDU;
+    u_char *Community;
+
+    /* Now that we have the data, turn it into a PDU */
+    cbdataAdd(rq, MEM_NONE);
+    PDU = snmp_pdu_create(0);
+    Community = snmp_parse(Session, PDU, buf, len);
+
+    if (!snmp_coexist_V2toV1(PDU)) {    /* incompatibility */
+        debug(49, 3) ("snmpAgentParse: Incompatible V2 packet.\n");
+        snmp_free_pdu(PDU);
+        snmpAgentParseDone(0, rq);
+        return;
+    }
+    rq->community = Community;
+    rq->PDU = PDU;
+    debug(49, 5) ("snmpAgentParse: reqid=[%d]\n", PDU->reqid);
+
+    if (!Community) {
+        debug(49, 2) ("snmpAgentParse: WARNING: Could not parse community\n");
+
+        snmp_free_pdu(PDU);
+        snmpAgentParseDone(0, rq);
+        return;
+    }
+    snmpAclCheckStart(rq);
+}
+
+struct snmp_pdu *
+snmpAgentResponse(struct snmp_pdu *PDU)
+{
+    struct snmp_pdu *Answer = NULL;
+    variable_list *VarPtr, *VarNew = NULL;
+    variable_list **VarPtrP, **RespVars;
+    int index = 0;
+    oid_ParseFn *ParseFn;
+
+    debug(49, 9) ("snmpAgentResponse: Received a %d PDU\n", PDU->command);
+
+    /* Create a response */
+    Answer = snmp_pdu_create(SNMP_PDU_RESPONSE);
+    if (Answer == NULL)
+        return (NULL);
+    Answer->reqid = PDU->reqid;
+    Answer->errindex = 0;
+
+    if (PDU->command == SNMP_PDU_GET) {
+
+        RespVars = &(Answer->variables);
+        /* Loop through all variables */
+        for (VarPtrP = &(PDU->variables);
+            *VarPtrP;
+            VarPtrP = &((*VarPtrP)->next_variable)) {
+            VarPtr = *VarPtrP;
+
+            index++;
+
+            /* Find the parsing function for this variable */
+            ParseFn = oidlist_Find(VarPtr->name, VarPtr->name_length);
+
+            if (ParseFn == NULL) {
+                Answer->errstat = SNMP_ERR_NOSUCHNAME;
+                debug(49, 5) ("snmpAgentResponse: No such oid. ");
+            } else
+                VarNew = (*ParseFn) (VarPtr, (snint *) & (Answer->errstat));
+
+            /* Was there an error? */
+            if ((Answer->errstat != SNMP_ERR_NOERROR) ||
+                (VarNew == NULL)) {
+                Answer->errindex = index;
+                debug(49, 5) ("snmpAgentParse: successful.\n");
+                /* Just copy the rest of the variables.  Quickly. */
+                *RespVars = VarPtr;
+                *VarPtrP = NULL;
+                return (Answer);
+            }
+            /* No error.  Insert this var at the end, and move on to the next.
+             */
+            *RespVars = VarNew;
+            RespVars = &(VarNew->next_variable);
+        }
+     return (Answer);
+    } else if (PDU->command == SNMP_PDU_GETNEXT) {
+        oid *TmpOidName;
+        int TmpOidNameLen = 0;
+
+        /* Find the next OID. */
+        VarPtr = PDU->variables;
+
+        ParseFn = oidlist_Next(VarPtr->name, VarPtr->name_length,
+            &(TmpOidName), (snint *) & (TmpOidNameLen));
+
+        if (ParseFn == NULL) {
+            Answer->errstat = SNMP_ERR_NOSUCHNAME;
+            debug(49, 5) ("snmpAgentResponse: No such oid: ");
+            snmpDebugOid(5, VarPtr->name, VarPtr->name_length);
+        } else {
+            xfree(VarPtr->name);
+            VarPtr->name = TmpOidName;
+            VarPtr->name_length = TmpOidNameLen;
+            VarNew = (*ParseFn) (VarPtr, (snint *) & (Answer->errstat));
+        }
+
+        /* Was there an error? */
+        if (Answer->errstat != SNMP_ERR_NOERROR) {
+            Answer->errindex = 1;
+
+            /* Just copy this variable */
+            Answer->variables = VarPtr;
+            PDU->variables = NULL;
+        } else {
+            Answer->variables = VarNew;
+        }
+
+        /* Done.  Return this PDU */
+        return (Answer);
+    }                           /* end SNMP_PDU_GETNEXT */
+    debug(49, 5) ("snmpAgentResponse: Ignoring PDU %d unknown command\n", PDU->command);
+    snmp_free_pdu(Answer);
+    return (NULL);
+}
+
+void
+snmpDebugOid(int lvl, oid * Name, snint Len)
+{
+    static char mbuf[16], objid[1024];
+    int x;
+    objid[0] = '\0';
+    for (x = 0; x < Len; x++) {
+        snprintf(mbuf, 16, ".%u", (unsigned char) Name[x]);
+        strcat(objid, mbuf);
+    }
+    debug(49, lvl) ("   oid = %s\n", objid);
+}
+
+int
+oidcmp(oid * A, snint ALen, oid * B, snint BLen)
+{
+    oid *aptr = A;
+    oid *bptr = B;
+    snint m = MIN(ALen, BLen);
+
+    /* Compare the first M bytes. */
+    while (m) {
+        if (*aptr < *bptr)
+            return (-1);
+        if (*aptr++ > *bptr++)
+            return (1);
+        m--;
+    }
+
+    /* The first M bytes were identical.  So, they share the same
+     * root.  The shorter one must come first.
+     */
+    if (ALen < BLen)
+        return (-1);
+
+    if (ALen > BLen)
+        return (1);
+
+    /* Same length, all bytes identical.  Must be the same OID. */
+    return (0);
+}
+
+int
+oidncmp(oid * A, snint ALen, oid * B, snint BLen, snint CompLen)
+{
+    oid *aptr = A;
+    oid *bptr = B;
+    snint m = MIN(MIN(ALen, BLen), CompLen);
+    snint count = 0;
+
+    /* Compare the first M bytes. */
+    while (count != m) {
+        if (*aptr < *bptr)
+            return (-1);
+        if (*aptr++ > *bptr++)
+            return (1);
+        count++;
+    }
+
+    if (m == CompLen)
+        return (0);
+
+
+    if (ALen < BLen)
+        return (-1);
+
+    if (ALen > BLen)
+        return (1);
+
+    /* Same length, all bytes identical.  Must be the same OID. */
+    return (0);
+}
+
+/* Allocate space for, and copy, an OID.  Returns new oid, or NULL.
+ */
+oid *
+oiddup(oid * A, snint ALen)
+{
+    oid *Ans;
+
+    Ans = (oid *) xmalloc(sizeof(oid) * ALen);
+    if (Ans)
+        memcpy(Ans, A, (sizeof(oid) * ALen));
+    return (Ans);
+}
+
+
+/**********************************************************************
+ * OIDLIST FUNCTIONS
+ *
+ * Find the parsing function for OIDs registered in this agent.
+ **********************************************************************/
+
+oid_ParseFn *
+oidlist_Find(oid * Src, snint SrcLen)
+{
+    struct MIBListEntry *Ptr;
+    int ret;
+
+    debug(49, 7) ("oidlist_Find:  Called.\n ");
+    snmpDebugOid(7,  Src, SrcLen);
+
+    for (Ptr = squidMIBList; Ptr->GetFn; Ptr++) {
+
+        ret = oidncmp(Src, SrcLen, Ptr->Name, Ptr->NameLen, Ptr->NameLen);
+
+        if (!ret) {
+
+            /* Cool.  We found the mib it's in.  Let it find the function.
+             */
+            debug(49, 7) ("oidlist_Find:  found, returning GetFn Ptr! \n");
+
+            return ((*Ptr->GetFn) (Src, SrcLen));
+        }
+        if (ret < 0) {
+            debug(49, 7) ("oidlist_Find:  We just passed it, so it doesn't exist.\n ");
+            /* We just passed it, so it doesn't exist. */
+            return (NULL);
+        }
+    }
+
+    debug(49, 5) ("oidlist_Find:  the request was past the end.  It doesn't exist.\n");
+    /* We get here if the request was past the end.  It doesn't exist. */
+    return (NULL);
+}
+/* Find the next item.  For SNMP_PDU_GETNEXT requests. 
+ *
+ * Returns a pointer to the parser function, and copies the oid to dest.
+ * 
+ */
+oid_ParseFn *
+oidlist_Next(oid * Src, snint SrcLen, oid ** DestP, snint * DestLenP)
+{
+    struct MIBListEntry *Ptr;
+    int ret;
+    oid_ParseFn *Fn = NULL;
+
+    debug(49, 7) ("oidlist_Next: Looking for next of:\n");
+    snmpDebugOid(7, Src, SrcLen);
+
+    for (Ptr = squidMIBList; Ptr->GetNextFn; Ptr++) {
+
+        /* Only look at as much as we have stored */
+        ret = oidncmp(Src, SrcLen, Ptr->Name, Ptr->NameLen, Ptr->NameLen);
+
+        if (!ret) {
+            debug(49, 6) ("oidlist_Next: Checking MIB\n");
+
+            /* Cool.  We found the mib it's in.  Ask it.
+             */
+            while (Ptr != NULL && Ptr->GetNextFn) {
+                Fn = ((*Ptr->GetNextFn) (Src, SrcLen, DestP, DestLenP));
+                if (Fn == NULL) {
+                    /* If this returned NULL, we're looking for the first
+                     * in the next MIB.
+                     */
+                    debug(49, 6) ("oidlist_Next: Not in this entry. Trying next.\n");
+                    Ptr++;
+                    continue;
+                }
+                return Fn;
+            }
+            /* Return what we found.  NULL if it wasn't in the MIB, and there
+             * were no more MIBs. 
+             */
+            debug(49, 3) ("oidlist_Next: No next mib.\n");
+            return NULL;
+        }
+        if (ret < 0) {
+            /* We just passed the mib it would be in.  Return 
+             * the next in this MIB.
+             */
+            debug(49, 3) ("oidlist_Next: Passed mib.  Checking this one.\n");
+            return ((*Ptr->GetNextFn) (Src, SrcLen, DestP, DestLenP));
+        }
+    }
+
+    /* We get here if the request was past the end.  It doesn't exist. */
+    debug(49, 7) ("oidlist_Next: Found nothing.\n");
+    return (NULL);
+}
+
+struct in_addr *
+gen_getMax()
+{
+    static struct in_addr maddr;
+#if USE_ICMP
+    safe_inet_addr("255.255.255.255", &maddr);
+#else
+    safe_inet_addr("0.0.0.0", &maddr);
+#endif
+    return &maddr;
+}
+
+int 
+fd_getMax()
+{
+    fde *f;
+    int cnt = 0, num = 0;
+    while (cnt < Squid_MaxFD) {
+        f = &fd_table[cnt++];
+        if (!f->open)
+            continue;
+        if (f->type != FD_SOCKET)
+            num++;
+    }
+    return num;
+}
+
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.168 1998/04/03 22:05:56 rousskov Exp $
+ * $Id: squid.h,v 1.169 1998/04/04 01:44:05 kostas Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -308,10 +308,6 @@ struct rusage {
 #include "md5.h"
 #include "Stack.h"
 
-#ifdef SQUID_SNMP
-#include "cache_snmp.h"
-#endif
-
 /* Needed for poll() on Linux at least */
 #if HAVE_POLL
 #ifndef POLLRDNORM
@@ -322,6 +318,10 @@ struct rusage {
 #endif
 #endif
 
+#ifdef SQUID_SNMP
+#include "cache_snmp.h"
+#endif
+
 #include "defines.h"
 #include "enums.h"
 #include "typedefs.h"
@@ -10,6 +10,12 @@ struct _acl_ip_data {
 #endif
 };
 
+struct _acl_snmp_comm {
+    char *name;
+    void *community;
+    acl_snmp_comm *next;
+};
+
 struct _acl_time_data {
     int weekbits;
     int start;
@@ -62,7 +68,8 @@ struct _String {
 };
 
 #if SQUID_SNMP
-struct _snmp_request_t {
+
+typedef struct _snmp_request_t {
     u_char *buf;
     u_char *outbuf;
     int len;
@@ -73,7 +80,7 @@ struct _snmp_request_t {
     struct snmp_pdu *PDU;
     aclCheck_t *acl_checklist;
     u_char *community;
-};
+} snmp_request_t;
 
 typedef struct _viewEntry {
     char viewName[32];
@@ -28,7 +28,7 @@ typedef struct _acl_proxy_auth acl_proxy_auth;
 typedef struct _acl_proxy_auth_user acl_proxy_auth_user;
 typedef struct _acl_arp_data acl_arp_data;
 typedef struct _acl acl;
-typedef struct _snmp_request_t snmp_request_t;
+typedef struct _acl_snmp_comm acl_snmp_comm;
 typedef struct _acl_list acl_list;
 typedef struct _acl_access acl_access;
 typedef struct _aclCheck_t aclCheck_t;