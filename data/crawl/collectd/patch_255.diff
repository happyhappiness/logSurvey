@@ -1,40 +0,0 @@
-##
-## lib/Makefile.am
-##
-## Copyright (C) 2000 Jeffrey Fulmer <jdfulmer@armstrong.com>
-## This file is part of libping
-##
-## This program is free software; you can redistribute it and/or modify
-## it under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 2 of the License, or
-## (at your option) any later version.
-##
-## This program is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with this program; if not, write to the Free Software
-## Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-##
-
-AUTOMAKE_OPTIONS = foreign no-dependencies
-
-noinst_LTLIBRARIES    = libping.la 
- 
-libping_la_LDFLAGS = -version-info 1:0:0
-
-libping_la_SOURCES =  \
-echo.c     echo.h     \
-http.c     http.h     \
-memory.c   memory.h   \
-ping.c     ping.h     \
-private.c  private.h  \
-pop3.c     pop3.h     \
-sock.c     sock.h     \
-smtp.c     smtp.h     \
-url.c      url.h      \
-util.c     util.h     \
-linux.h    setup.h
-
@@ -1,122 +0,0 @@
-/* src/libping/config.h.in.  Generated automatically from configure.in by autoheader.  */
-
-/* Define to empty if the keyword does not work.  */
-#undef const
-
-/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
-#undef HAVE_SYS_WAIT_H
-
-/* Define to `int' if <sys/types.h> doesn't define.  */
-#undef pid_t
-
-/* Define to `unsigned' if <sys/types.h> doesn't define.  */
-#undef size_t
-
-/* Define if you have the ANSI C header files.  */
-#undef STDC_HEADERS
-
-/* Define if you can safely include both <sys/time.h> and <time.h>.  */
-#undef TIME_WITH_SYS_TIME
-
-/* Define if you have the gethostbyname function.  */
-#undef HAVE_GETHOSTBYNAME
-
-/* Define if you have the gettimeofday function.  */
-#undef HAVE_GETTIMEOFDAY
-
-/* Define if you have the memcpy function.  */
-#undef HAVE_MEMCPY
-
-/* Define if you have the select function.  */
-#undef HAVE_SELECT
-
-/* Define if you have the socket function.  */
-#undef HAVE_SOCKET
-
-/* Define if you have the strcasecmp function.  */
-#undef HAVE_STRCASECMP
-
-/* Define if you have the strchr function.  */
-#undef HAVE_STRCHR
-
-/* Define if you have the strcmp function.  */
-#undef HAVE_STRCMP
-
-/* Define if you have the strdup function.  */
-#undef HAVE_STRDUP
-
-/* Define if you have the strlen function.  */
-#undef HAVE_STRLEN
-
-/* Define if you have the strncasecmp function.  */
-#undef HAVE_STRNCASECMP
-
-/* Define if you have the strncmp function.  */
-#undef HAVE_STRNCMP
-
-/* Define if you have the strncpy function.  */
-#undef HAVE_STRNCPY
-
-/* Define if you have the strstr function.  */
-#undef HAVE_STRSTR
-
-/* Define if you have the strtol function.  */
-#undef HAVE_STRTOL
-
-/* Define if you have the <arpa/inet.h> header file.  */
-#undef HAVE_ARPA_INET_H
-
-/* Define if you have the <dlfcn.h> header file.  */
-#undef HAVE_DLFCN_H
-
-/* Define if you have the <errno.h> header file.  */
-#undef HAVE_ERRNO_H
-
-/* Define if you have the <fcntl.h> header file.  */
-#undef HAVE_FCNTL_H
-
-/* Define if you have the <netdb.h> header file.  */
-#undef HAVE_NETDB_H
-
-/* Define if you have the <netinet/in.h> header file.  */
-#undef HAVE_NETINET_IN_H
-
-/* Define if you have the <signal.h> header file.  */
-#undef HAVE_SIGNAL_H
-
-/* Define if you have the <sys/resource.h> header file.  */
-#undef HAVE_SYS_RESOURCE_H
-
-/* Define if you have the <sys/select.h> header file.  */
-#undef HAVE_SYS_SELECT_H
-
-/* Define if you have the <sys/socket.h> header file.  */
-#undef HAVE_SYS_SOCKET_H
-
-/* Define if you have the <sys/time.h> header file.  */
-#undef HAVE_SYS_TIME_H
-
-/* Define if you have the <sys/times.h> header file.  */
-#undef HAVE_SYS_TIMES_H
-
-/* Define if you have the <sys/types.h> header file.  */
-#undef HAVE_SYS_TYPES_H
-
-/* Define if you have the <unistd.h> header file.  */
-#undef HAVE_UNISTD_H
-
-/* Define if you have the resolv library (-lresolv).  */
-#undef HAVE_LIBRESOLV
-
-/* Define if you have the rrd library (-lrrd).  */
-#undef HAVE_LIBRRD
-
-/* Define if you have the socket library (-lsocket).  */
-#undef HAVE_LIBSOCKET
-
-/* Name of package */
-#undef PACKAGE
-
-/* Version number of package */
-#undef VERSION
-
@@ -1,153 +0,0 @@
-/**
- * ECHO module
- *
- * Copyright (C) 2001,2002 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/ 
-
-#include <sock.h>
-#include <echo.h>
-#include <util.h>
-#include <stdlib.h>
-#include <stdio.h>  
-#include <errno.h>
-#include <setup.h>
-#include <string.h>
-
-#include "memory.h"
-
-#define MAXLINE  81921
-
-int 
-send_data( CONN *C, int bytes )
-{
-  char buf[MAXLINE];
-  char rec[MAXLINE];
-  int  ret;
-  int  x, n;
-
-  bytes = (bytes>MAXLINE-3)?MAXLINE-3:bytes;
-
-  memset( buf, 0, bytes+3 );
-  memset( rec, 0, bytes+3 );
-
-  for( x = 0; x < bytes; x++ )
-    buf[x] = '#';
-
-  (void)strcat( buf, "\015\012" );
-
-  if( JOEsocket_write( C, buf, sizeof( buf )) < 0 ){
-    return -1; 
-  }
-
-  if(( n = JOEreadline( C, rec, sizeof( rec ))) < 0 ){
-    return -1;
-  }
-
-  if(( ret = strlen( rec )) > 0 ){ 
-    return 1;
-  }
-  else
-    return -1;
-}
-
-int
-myecho( ECHODATA *E )
-{
-  CONN *C;               /* threadsafe connection */
-  int ret;               /* return conditional    */
-  struct timeval mytime;
- 
-  C = (CONN*)xmalloc( sizeof( CONN )); 
-  C->port    = 7; 
-  C->timeout = ( E->timeout == 0 )?60:E->timeout;  
-
-  (void) gettimeofday( &mytime, (struct timezone *)NULL);  
-
-  if(( C->sock = JOEsocket( C, E->hostname )) < 0 ){
-    return -1;
-  }
-
-  ret = send_data( C, E->bytes );
-  
-  E->rtt = elapsed_time( &mytime );
-  return ret;
-}
-
-int
-echohost( const char *hostname, int b )
-{
-  ECHODATA *E;
- 
-  E = (ECHODATA*)xmalloc( sizeof( ECHODATA ));
-  E->hostname = (char*)strdup( hostname );
-  E->bytes   = b;
-  E->timeout = 0;  
-  return ( myecho( E ));
-}
- 
-int
-echothost( const char *hostname, int b, int t )
-{
-  ECHODATA *E;
- 
-  E = (ECHODATA*)xmalloc( sizeof( ECHODATA ));
-  E->hostname = (char*)strdup( hostname );
-  E->bytes   = b;
-  E->timeout = t; 
- 
-  return ( myecho( E ));
-}
-
-int
-techohost( const char *hostname, int b )
-{
-  ECHODATA *E;
-  int ret;
- 
-  E = (ECHODATA*)xmalloc( sizeof( ECHODATA ));
-  E->hostname = (char*)strdup( hostname );
-  E->bytes   = b;
-  E->timeout = 0; 
- 
-  ret = myecho( E );
- 
-  if( ret > 0 ){ return E->rtt; }
-  else         { return ret; }
-}
- 
-int
-techothost( const char *hostname, int b, int t )
-{
-  ECHODATA *E; 
-  int ret;
-  
-  E = (ECHODATA*)xmalloc( sizeof( ECHODATA )); 
-  E->hostname = (char*)strdup( hostname );
-  E->bytes   = b;
-  E->timeout = t; 
-
-  ret = myecho( E );
-  if( ret > 0 ){ return E->rtt; }
-  else         { return ret; }
- 
-} 
-
@@ -1,37 +0,0 @@
-/**
- * ECHO Header
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifndef  ECHO_H
-#define  ECHO_H
-
-typedef struct
-{
-  char     *hostname; 
-  int      timeout;
-  int      bytes;
-  int      rtt;
-} ECHODATA; 
-
-int echohost( const char *hostname, int bytes );
- 
-int echothost( const char *hostname, int bytes, int t ); 
-
-#endif/*ECHO_H*/
@@ -1,340 +0,0 @@
-/**
- * HTTP/HTTPS protocol support 
- *
- * Copyright (C) 2000, 2001, 2002 by
- * Jeffrey Fulmer - <jdfulmer@armstrong.com>
- * This file is distributed as part of Libping
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/
- 
-#include <sock.h>
-#include <http.h>
-#include <util.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <errno.h>
-#include <string.h>
-#include <setup.h>
-
-#include "memory.h"
-
-#define MAXFILE 10240
-
-int
-myhttp( HTTPDATA *H )
-{
-  CONN    *C;    /* threadsafe connection */
-  URL     U;     /* defined in url.h      */
-  HEADERS *head; /* HTTP header structure */ 
-  int     bytes; /* bytes read from srv.  */
-  char    *tmp;  /* tmp storage for url   */
-  struct  timeval mytime; 
-
-  tmp = strdup( H->url ); 
-  U = add_url( tmp );
- 
-  C = (CONN*)xmalloc( sizeof( CONN ));
-  C->port    = U.port;
-  C->timeout = ( H->timeout == 0 )?60:H->timeout;
-
-  (void) gettimeofday( &mytime, (struct timezone *)NULL);
- 
-  if(( C->sock = JOEsocket( C, U.hostname )) <= 0 ){
-    return -1;
-  }
-
-  JOEhttp_send( C, U.hostname, U.pathname );
-  head  = JOEhttp_read_headers( C, U.hostname );
-  if( !head ){ 
-    JOEclose( C ); 
-    free( C ); 
-    return -1; 
-  }
-  
-  bytes =  JOEhttp_read( C, 0 );
-  if( bytes < 1 ){ 
-    JOEclose( C ); 
-    free( C ); 
-    free( head ); 
-    return -1; 
-  }
-  
-  JOEclose( C );
-
-  H->rtt = elapsed_time( &mytime ); 
- 
-  if( head->code > 499 ){ return -1; }
-  else                  { return  1; } 
-}
-
-/**
- * returns int, ( < 0 == error )
- * formats and sends an HTTP/1.0 request
- */
-void
-JOEhttp_send( CONN *C, char *host, char *path )
-{
-  int rlen;
-  char *protocol; 
-  char *keepalive;
-  char request[1024]; 
-  char fullpath[2048];
-
-  sprintf( fullpath, "%s", path );
-
-  memset( request, 0, sizeof( request ));
-
-  /* HTTP protocol string */
-  protocol  = "HTTP/1.0";
-  keepalive = "close";
-  
-  rlen=snprintf(
-    request, sizeof( request ),
-    "GET %s %s\015\012"
-    "Host: %s\015\012"
-    "Accept: */*\015\012"
-    "Accept-Encoding: * \015\012"
-    "User-Agent: JoeDog 1.00 [libping]\015\012"
-    "Connection: %s\015\012\015\012",
-    fullpath, protocol, host, keepalive
-  );
-  
-  if( rlen < 0 || rlen > sizeof(request)  ){ 
-    perror("http_send: request buffer overrun!"); 
-    exit( 1 ); 
-  }
-
-  if(( JOEsocket_check( C, WRITE )) < 0 ){
-    perror( "JOEsocket: not writeable" );
-    return;
-  } 
-
-  JOEsocket_write( C, request, rlen );
-
-  return;
-}
-
-/**
- * returns int, ( < 0 == error )
- * formats and sends an HTTP/1.0 request
- */
-void
-JOEhttp_post( CONN *C, char *host, char *path, char *data, size_t len )
-{
-  int  rlen;
-  char request[1024]; 
-  char *protocol; 
-  char *keepalive;
-  char fullpath[2048];
-  
-  sprintf( fullpath, "%s", path );
-
-  memset( request, 0, sizeof( request ));
-
-  /* HTTP protocol string */
-  protocol  = "HTTP/1.0";
-  keepalive = "close";
-    
-  rlen=snprintf(
-    request, sizeof( request ),
-    "POST %s %s\015\012"
-    "Host: %s\015\012"
-    "Accept: */*\015\012"
-    "Accept-Encoding: * \015\012"
-    "User-Agent: JoeDog 1.00 [libping]\015\012"
-    "Connection: %s\015\012"
-    "Content-type: application/x-www-form-urlencoded\015\012"
-    "Content-length: %d\015\012\015\012"
-    "%*.*s\015\012",
-    fullpath, protocol, host, keepalive, len, len, len, data
-  );
-
-  if( rlen < 0 || rlen > sizeof(request) ){ 
-    perror("http_post: request buffer overrun!"); 
-    exit( 1 ); 
-  }
-
-  if(( JOEsocket_check( C, WRITE )) < 0 ){
-    perror( "JOEsocket: not writeable" );
-    return;
-  } 
-
-  JOEsocket_write( C, request, rlen );
-
-  return;
-}
-
-/**
- * returns HEADERS struct
- * reads from http/https socket and parses
- * header information into the struct.
- */
-HEADERS *
-JOEhttp_read_headers( CONN *C, char *host )
-{ 
-  int  x;           /* while loop index      */
-  int  n;           /* assign socket_read    */
-  char c;           /* assign char read      */
-  char line[512];   /* assign chars read     */
-  HEADERS *h;       /* struct to hold it all */
-  h = (HEADERS*)malloc( sizeof(HEADERS));
-  memset( h, 0, sizeof( HEADERS ));
-  
-  if(( JOEsocket_check( C, READ )) < 0 ){
-    perror( "JOEsocket: not readable" );
-    return NULL;
-  } 
-
-  h->redirection[0]=0;
-
-  while( TRUE ){
-    x = 0;
-    memset( &line, 0, sizeof( line ));
-    while(( n = JOEsocket_read( C, &c, 1 )) == 1 ){
-      line[x] = c; 
-      if(( line[0] == '\n' ) || ( line[1] == '\n' )){ 
-        return h;
-      }
-      if( line[x] == '\n' ) break;
-      x ++;
-    }
-    line[x]=0;
-    /* strip trailing CR */
-    if (x > 0 && line[x-1] == '\r') line[x-1]=0;
-    if( strncasecmp( line, "http", 4 ) == 0 ){
-      strncpy( h->head, line, 8 );
-      h->code = atoi( line + 9 ); 
-    }
-    if( strncasecmp( line, "content-length: ", 16 ) == 0 ){ 
-      h->length = atol( line + 16 ); 
-    }
-    if( strncasecmp( line, "connection: ", 12 ) == 0 ){
-      if ( strncasecmp( line+12, "keep-alive", 10 ) == 0 ){
-        h->keepalive = 1;
-      }
-      else if( strncasecmp( line+12, "close", 5 ) == 0 ){
-        h->keepalive = 0;
-      }
-    }
-
-    if( strncasecmp(line, "location: ", 10) == 0) {
-      if (strlen(line) - 10 > sizeof(h->redirection) - 1) {
-	perror( "redirection URL too long, ignored");
-      }
-      else {
-        strcpy(h->redirection, line+10);
-      }  
-    }
-
-    if( n <  0 ){ 
-      perror("JOEhttp_read_headers"); 
-      return( NULL ); 
-    } /* socket closed */
-  } /* end of while TRUE */
-
-  return h;
-}
-
-/**
- * returns int
- * reads a http/https socket
- * ( you know what I mean :)
- */
-ssize_t
-JOEhttp_read( CONN *C, int len )
-{ 
-  int  n;
-  size_t bytes=0;
-  char body[MAXFILE];
-
-  if(( JOEsocket_check( C, READ )) < 0 ){
-    perror( "JOEsocket: not readable" );
-    return -1;
-  } 
-
-  memset( &body, 0, MAXFILE );  
-  while( TRUE ){
-    if(( n = JOEsocket_read( C, body, MAXFILE)) == 0 ){
-      break;
-    } 
-    /* IGV: should be accumulating bytes read, not just 
-       recording those in the last packet */
-    bytes += n;
-  }
-  return( bytes );
-}
-
-int
-pinghttp( char *hostname )
-{
-  HTTPDATA *H;
- 
-  H = (HTTPDATA*)xmalloc( sizeof( HTTPDATA ));
-  H->url     = (char*)strdup( hostname );
-  H->timeout = 0;
- 
-  return( myhttp( H )); 
-}
- 
-int
-pingthttp( char *hostname, int t )
-{
-  HTTPDATA *H;
- 
-  H = (HTTPDATA*)xmalloc( sizeof( HTTPDATA ));
-  H->url     = (char*)strdup( hostname );
-  H->timeout = t;
- 
-  return( myhttp( H )); 
-}
- 
-int
-tpinghttp( char *hostname )
-{
-  HTTPDATA *H;
-  int ret;
- 
-  H = (HTTPDATA*)xmalloc( sizeof( HTTPDATA ));
-  H->url     = (char*)strdup( hostname );
-  H->timeout = 0;
- 
-  ret = myhttp( H ); 
-
-  if( ret > 0 ){ return H->rtt; }
-  else         { return ret; }
-}
- 
-int
-tpingthttp( char *hostname, int t )
-{
-  HTTPDATA *H;
-  int ret;
- 
-  H = (HTTPDATA*)xmalloc( sizeof( HTTPDATA ));
-  H->url     = (char*)strdup( hostname );
-  H->timeout = t;
- 
-  ret = myhttp( H );
-
-  if( ret > 0 ){ return H->rtt; }
-  else         { return ret;    }
-} 
-
-
@@ -1,82 +0,0 @@
-/**
- * JOE http header file
- *
- * Copyright (C) 2000, 2001, 2002 by
- * Jeffrey Fulmer - <jdfulmer@armstrong.com>
- * This file is distributed as part of Siege 
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-#ifndef HTTP_H
-#define HTTP_H
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif /* HAVE_CONFIG_H */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <sock.h>
-
-#ifndef HAVE_SNPRINTF
-# define portable_snprintf  snprintf
-# define portable_vsnprintf vsnprintf
-#endif
-
-typedef struct
-{
-  char   *url;
-  int    rtt;
-  int    timeout;
-} HTTPDATA;
-
-typedef struct headers
-{
-  char                head[64];
-  int                 code;
-  unsigned long int   length;
-  char                cookie[128];
-  char                redirection[128];
-  int                 keepalive;
-} HEADERS;
-
-int myhttp( HTTPDATA *H ); 
-
-/**
- * construct a HTTP GET request with "my" 
- * data and send it to the server host.
- */
-void JOEhttp_send( CONN *C, char *host, char *path );
-
-/**
- * construct a HTTP POST request with "my"
- * data and send it to server host.
- */
-void JOEhttp_post( CONN *C, char *host, char *path, char *data, size_t len );
-
-/**
- * read http headers
- * int socket
- */
-HEADERS * JOEhttp_read_headers( CONN *C, char * );
-
-/**
- * read http content
- * int socket
- */
-ssize_t JOEhttp_read( CONN *C, int len );
-
-#endif /* HTTP_H */
-
@@ -1,66 +0,0 @@
-#define ICMP_ECHOREPLY          0 
-#define ICMP_ECHO               8
-#define ICMP_MINLEN             8
-
-struct ip {
-#if (BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN)
-        u_char  ip_hl:4,                /* header length */
-                ip_v:4;                 /* version */
-#else
-        u_char  ip_v:4,                 /* version */
-                ip_hl:4;                /* header length */
-#endif
-        u_char  ip_tos;                 /* type of service */
-        short   ip_len;                 /* total length */
-        u_short ip_id;                  /* identification */
-        short   ip_off;                 /* fragment offset field */
-#define IP_DF 0x4000                    /* dont fragment flag */
-#define IP_MF 0x2000                    /* more fragments flag */
-        u_char  ip_ttl;                 /* time to live */
-        u_char  ip_p;                   /* protocol */
-        u_short ip_sum;                 /* checksum */
-        struct  in_addr ip_src,ip_dst;  /* source and dest address */
-};
-
-#define n_short u_short                 /* normally defined in in_systm.h */
-#define n_long  u_int                   /* redefine for 64-bit machines */
-#define n_time  u_int                   /* redefine for 64-bit machines */
-
-struct icmp {
-        u_char  icmp_type;              /* type of message, see below */
-        u_char  icmp_code;              /* type sub code */
-        u_short icmp_cksum;             /* ones complement cksum of struct */
-        union {
-                u_char ih_pptr;                 /* ICMP_PARAMPROB */
-                struct in_addr ih_gwaddr;       /* ICMP_REDIRECT */
-                struct ih_idseq {
-                        n_short icd_id;
-                        n_short icd_seq;
-                } ih_idseq;
-                int ih_void;
-        } icmp_hun;
-#define icmp_pptr       icmp_hun.ih_pptr
-#define icmp_gwaddr     icmp_hun.ih_gwaddr
-#define icmp_id         icmp_hun.ih_idseq.icd_id
-#define icmp_seq        icmp_hun.ih_idseq.icd_seq
-#define icmp_void       icmp_hun.ih_void
-        union {
-                struct id_ts {
-                        n_time its_otime;
-                        n_time its_rtime;
-                        n_time its_ttime;
-                } id_ts;
-                struct id_ip  {
-                        struct ip idi_ip;
-                        /* options and then 64 bits of data */
-                } id_ip;
-                n_long  id_mask;
-                char    id_data[1];
-        } icmp_dun;
-#define icmp_otime      icmp_dun.id_ts.its_otime
-#define icmp_rtime      icmp_dun.id_ts.its_rtime
-#define icmp_ttime      icmp_dun.id_ts.its_ttime
-#define icmp_ip         icmp_dun.id_ip.idi_ip
-#define icmp_mask       icmp_dun.id_mask
-#define icmp_data       icmp_dun.id_data
-};
@@ -1,72 +0,0 @@
-/**
- * MEMORY module
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#include <stdio.h>
-#include <memory.h>
-#include <strings.h>
-
-/**
- * xrealloc    replaces realloc
- */
-void * 
-xrealloc( void *object, size_t size )
-{
-  void *new;
-  if( object )
-    new = realloc( object, size );
-  else
-    new = malloc( size );
-  if( !new ){
-    perror( "Memory exhausted" );
-    exit( 1 );
-  }
-  return new;
-} /** end xrealloc **/
-
-/**
- * xmalloc     replaces malloc
- */
-void *
-xmalloc( size_t size )
-{
-  void *new  =  malloc( size );
-  if( !new ){
-    perror( "Memory exhausted" );
-    exit( 1 );
-  }
-  
-  return new;
-} /** end of xmalloc **/
-
-/**
- * xcalloc     replaces calloc
- */
-void *
-xcalloc( size_t num, size_t size )
-{
-  void *new  =  xmalloc( num * size );
-  bzero( new, num * size );
-
-  return new;
-} /** end of xcalloc **/
-
-
-
@@ -1,43 +0,0 @@
-/**
- * MEMORY header
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifndef MEMORY_H
-#define MEMORY_H
-
-#include <stdlib.h>
-
-/**
- * a controlled realloc
- */
-void * xrealloc( void *, size_t );
-
-/**
- * a controlled malloc
- */
-void * xmalloc ( size_t );
-
-/**
- * a controlled calloc
- */
-void * xcalloc ( size_t, size_t );  
-
-
-#endif /* MEMORY_H */
@@ -1,337 +0,0 @@
-/**
- * PING module
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#include <ping.h>
-#include <util.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netdb.h>
-#include <pthread.h>
-#include <stdlib.h>
-
-#define  MAXPACKET   65535
-#define  PKTSIZE     64 
-#define  HDRLEN      ICMP_MINLEN
-#define  DATALEN     (PKTSIZE-HDRLEN)
-#define  MAXDATA     (MAXPKT-HDRLEN-TIMLEN)
-#define  DEF_TIMEOUT 5
-
-#include "private.h"
-
-void
-JOEfreeprotoent( struct protoent *p )
-{
-  char **a;
-  free( p->p_name );
-  if( p->p_aliases != NULL ){
-    for( a = p->p_aliases; *a != NULL; a++ ){
-      free( *a );
-    }
-  }
-  free( p );
-}
-
-void
-JOEfreehostent( struct hostent *h )
-{
-  char **p;
-
-  free( h->h_name );
-  if( h->h_aliases != NULL ){
-    for( p = h->h_aliases; *p != NULL; ++p )
-      free( *p );
-    free( h->h_aliases );
-  }
-  if( h->h_addr_list != NULL ){
-    for( p = h->h_addr_list; *p != NULL; ++p )
-      free( *p );
-    free (h->h_addr_list);
-  }
-  free( h );
-}
-
-static int 
-in_checksum( u_short *buf, int len )
-{
-  register long sum = 0;
-  u_short  answer = 0;
-
-  while( len > 1 ){
-    sum += *buf++;
-    len -= 2;
-  }
-
-  if( len == 1 ){
-    *( u_char* )( &answer ) = *( u_char* )buf;
-    sum += answer;
-  }
-  sum = ( sum >> 16 ) + ( sum & 0xffff );
-  sum += ( sum >> 16 );     
-  answer = ~sum;     
-
-  return ( answer );
-
-} 
-
-static int
-send_ping( const char *host, struct sockaddr_in *taddr, struct ping_priv * datum )
-{
-  int len;
-  int ss;
-  unsigned char buf[ HDRLEN + DATALEN ];
-
-  const int proto_buf_len = 1024;
-  char   proto_buf[proto_buf_len];
-  struct protoent *proto = NULL;
-  struct protoent proto_datum;
-
-  struct hostent  *hp = NULL;
-  struct hostent  hent;
-  int herrno;
-  char hbf[9000];
-#if defined(_AIX)
-  char *aixbuf;
-  char *probuf;
-  int  rc;
-#endif/*_AIX*/
-
-  struct icmp     *icp;
-  unsigned short  last;
-
-  len = HDRLEN + DATALEN;
-
-#if defined(__GLIBC__)
-  /* for systems using GNU libc */
-  getprotobyname_r("icmp", &proto_datum, proto_buf, proto_buf_len, &proto);
-  if(( gethostbyname_r( host, &hent, hbf, sizeof(hbf), &hp, &herrno ) < 0 )){
-    hp = NULL;
-  }
-#elif defined(sun)
-  /* Solaris 5++ */
-  proto = getprotobyname_r("icmp", &proto_datum, proto_buf, proto_buf_len);
-  hp    = gethostbyname_r( host, &hent, hbf, sizeof(hbf), &herrno );
-#elif defined(_AIX)
-  aixbuf = (char*)xmalloc( 9000 );
-  probuf = (char*)xmalloc( 9000 );
-  rc  = getprotobyname_r( "icmp", &proto,
-                        ( struct protoent_data *)(probuf + sizeof( struct protoent)));
-  rc  = gethostbyname_r ( host, (struct hostent *)aixbuf,
-                        (struct hostent_data *)(aixbuf + sizeof(struct hostent)));
-  hp = (struct hostent*)aixbuf;
-#elif ( defined(hpux) || defined(__osf__) )
-  proto  = getprotobyname( "icmp" ); 
-  hp     = gethostbyname( host );
-  herrno = h_errno;
-#else
-  /* simply hoping that get*byname is thread-safe */
-  proto  = getprotobyname( "icmp" ); 
-  hp     = gethostbyname( host );
-  herrno = h_errno;
-#endif/*OS SPECIFICS*/
-  
-  if( proto == NULL ) {
-    return -1;
-  }
-
-  if(hp != NULL ){
-    memcpy( &taddr->sin_addr, hp->h_addr_list[0], sizeof( taddr->sin_addr ));
-    taddr->sin_port = 0;
-    taddr->sin_family = AF_INET;
-  }
-  else if( inet_aton( host, &taddr->sin_addr ) == 0 ){
-    return -1;
-  }
-
-  last = ntohl( taddr->sin_addr.s_addr ) & 0xFF;
-  if(( last == 0x00 ) || ( last == 0xFF )){
-    return -1;
-  }
-
-  if(( datum->sock = socket( AF_INET, SOCK_RAW, proto->p_proto )) < 0 ){
-#ifdef  DEBUG
-  perror( "sock" );
-#endif/*DEBUG*/
-    return -2;
-  }
-
-  memset(buf, 0, sizeof(buf));
-  icp = (struct icmp *)buf;
-  icp->icmp_type  = ICMP_ECHO;
-  icp->icmp_code  = 0;
-  icp->icmp_cksum = 0;
-  icp->icmp_id    = getpid() & 0xFFFF;
-  icp->icmp_seq   = icp->icmp_id; /* FIXME this is not nice.. */
-  icp->icmp_cksum = in_checksum((u_short *)icp, len );
-
-  if(( ss = sendto( datum->sock, buf, sizeof( buf ), 0, 
-     (struct sockaddr*)taddr, sizeof( *taddr ))) < 0 ){
-#ifdef  DEBUG
-  perror( "sock" );
-#endif/*DEBUG*/
-    return -2;
-  }
-  if( ss != len ){
-#ifdef  DEBUG
-  perror( "malformed packet" );
-#endif/*DEBUG*/
-    return -2;
-  }
-
-#if defined(_AIX)
-  free( aixbuf );
-  free( probuf );
-#endif 
-  /* JOEfreeprotoent( proto ); */
-  /* JOEfreeprotoent( &proto_datum ); */
-  /* JOEfreehostent( hp ); */
-  /* JOEfreehostent( &hent ); */
-  return 0;
-}
-
-static int 
-recv_ping( struct sockaddr_in *taddr, struct ping_priv * datum )
-{
-  int len;
-  socklen_t from;
-  int nf, cc;
-  unsigned char buf[ HDRLEN + DATALEN ];
-  struct icmp        *icp;
-  struct sockaddr_in faddr;
-  struct timeval to;
-  fd_set readset;
-
-  to.tv_sec = datum->timo / 100000;
-  to.tv_usec = ( datum->timo - ( to.tv_sec * 100000 ) ) * 10;
-
-  FD_ZERO( &readset );
-  FD_SET( datum->sock, &readset );
-  /* we use select to see if there is any activity
-     on the socket.  If not, then we've requested an
-     unreachable network and we'll time out here. */
-  if(( nf = select( datum->sock + 1, &readset, NULL, NULL, &to )) < 0 ){
-    datum->rrt = -4;
-#ifdef  DEBUG
-    perror( "select" );
-#endif/*DEBUG*/    
-    return 0;
-  }
-  if( nf == 0 ){ 
-    return -1; 
-  }
-
-  len = HDRLEN + DATALEN;
-  from = sizeof( faddr ); 
-
-  cc = recvfrom( datum->sock, buf, len, 0, (struct sockaddr*)&faddr, &from );
-  if( cc < 0 ){
-    datum->rrt = -4;
-#ifdef  DEBUG
-    perror( "recvfrom" );
-#endif/*DEBUG*/    
-    return 0;
-  }
-
-  icp = (struct icmp *)(buf + HDRLEN + DATALEN );
-  if( faddr.sin_addr.s_addr != taddr->sin_addr.s_addr ){
-    return 1;
-  }
-  /*****
-  if( icp->icmp_id   != ( getpid() & 0xFFFF )){
-    printf( "id: %d\n",  icp->icmp_id );
-    return 1; 
-  }
-  *****/
-  return 0;
-}
-
-int 
-myping( const char *hostname, int t , struct ping_priv * datum)
-{
-  int err;
-  int rrt;
-  struct sockaddr_in sa;
-  struct timeval mytime;
- 
-  datum->ident = getpid() & 0xFFFF;
-
-  if( t == 0 ) datum->timo = 2; 
-  else         datum->timo = t;
-
-  datum->rrt = 0;
-  
-  (void) gettimeofday( &mytime, (struct timezone *)NULL); 
-  if(( err = send_ping( hostname, &sa, datum)) < 0 ){
-    close( datum->sock );
-    return err;
-  }
-  do {
-    rrt = elapsed_time( &mytime );
-    if (datum->rrt < 0)
-      return 0;
-    datum->rrt = rrt;
-    if (datum->rrt > datum->timo * 1000 ) {
-      close( datum->sock );
-      return 0;
-    }
-  } while( recv_ping( &sa, datum ));
-  close( datum->sock ); 
- 
-  return 1;
-}
-
-int
-pinghost( const char *hostname )
-{
-  struct ping_priv datum = ping_priv_default();
-  return myping( hostname, 0, &datum );
-}
-
-int
-pingthost( const char *hostname, int t )
-{
-  struct ping_priv datum = ping_priv_default();
-  return myping( hostname, t, &datum );
-}
-
-int
-tpinghost( const char *hostname )
-{
-  int ret;
-  struct ping_priv datum = ping_priv_default();
-
-  ret = myping( hostname, 0, &datum );
-  if(ret > 0 )
-    ret = datum.rrt;
-  return ret;
-} 
-
-int
-tpingthost( const char *hostname, int t )
-{
-  int ret;
-  struct ping_priv datum = ping_priv_default();
-
-  ret = myping( hostname, t, &datum );
-  if(ret > 0 )
-    ret = datum.rrt;
-  return ret;
-}
-
@@ -1,81 +0,0 @@
-/**
- * PING header
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifndef PING_H
-#define PING_H
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/
-
-#include <stdio.h>
-
-#ifdef  HAVE_UNISTD_H
-# include <unistd.h>
-#endif/*HAVE_UNISTD_H*/
-
-#ifdef  HAVE_STDLIB_H
-# include <stdlib.h>
-#endif/*HAVE_STDLIB_H*/
-
-#ifdef HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif /*HAVE_SYS_TIMES_H*/
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif /*TIME_WITH_SYS_TIME*/
-
-#include <string.h>
-#include <netinet/in_systm.h>
-#include <netinet/in.h>
-
-#ifdef  HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif/*HAVE_SYS_SOCKET_H*/
-
-#ifdef  HAVE_ARPA_INET_H
-# include <arpa/inet.h>
-#endif/*HAVE_ARPA_INET_H*/
-
-#ifdef  HAVE_NETDB_H
-# include <netdb.h>
-#endif/*HAVE_NETDB_H*/
-
-#if defined( __linux__ )
-# include "linux.h"
-#else
-# include <netinet/ip.h>
-# include <netinet/ip_icmp.h>
-#endif /* defined(__linux__) */   
-
-int pinghost  ( const char *hostname );
-int pingthost ( const char *hostname, int t );
-int tpinghost ( const char *hostname );
-int tpingthost( const char *hostname, int t );
-
-#endif/*PING_H*/
@@ -1,175 +0,0 @@
-/**
- * POP3 module
- *
- * Copyright (C) 2001, 2002 by
- * Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#include <pop3.h>
-#include <setup.h>
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/
-
-#include <sock.h>
-#include <util.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
- 
-#ifdef HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif /*HAVE_SYS_TIMES_H*/
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif /*TIME_WITH_SYS_TIME*/ 
-
-#include <signal.h>
-#include <setjmp.h> 
-
-#include "memory.h"
-
-#define MSGBUF  1024
-
-int send_cmd( CONN *C, char *cmd, char *val );
-
-int
-mypop3( POP3DATA *P )
-{
-  CONN *C;
-  char buf[MSGBUF];
-  int ret  = 0;
-  struct timeval mytime;
-
-  C = (CONN*)xmalloc( sizeof( CONN ));
-  C->port    =   110;
-  C->timeout = ( P->timeout == 0 )?60:P->timeout; 
-  
-  if(( C->sock = JOEsocket( C, P->hostname )) <= 0 ){
-    return -1;
-  }   
-
-  /* set the rrt timer */
-  (void) gettimeofday( &mytime, (struct timezone *)NULL); 
-
-  if(( ret = JOEreadline( C, buf, MSGBUF )) < 0 ){
-    return ret;
-  }
-  if( !strncmp( buf, "+OK", 3 )) ret = 1; 
-    
-  if(( ret = send_cmd( C, "QUIT", NULL )) < 0 ){
-    return ret; 
-  }
-
-  JOEclose( C );
-  P->rtt = elapsed_time( &mytime ); 
-
-  return ret;
-}
-
-int
-send_cmd( CONN *C, char *cmd, char *val )
-{
-  char buf[256];
-  char rec[MSGBUF];
-
-  if( val )
-    snprintf( buf, sizeof( buf ), "%s %s\r\n", cmd, val );
-  else
-    snprintf( buf, sizeof( buf ), "%s\r\n", cmd );
-
-  if( JOEsocket_write( C, buf, sizeof( buf ))  < 0 )
-    return -1;
-
-  JOEreadline( C, rec, MSGBUF );
-  *rec='\0';
-
-  if( !strncmp( rec, "-ERR", 4 )){
-    return -1;
-  }
-
-  return 1; 
-}
-
-int 
-pingpop3( const char *hostname )
-{
-  POP3DATA *P;
- 
-  P = (POP3DATA*)xmalloc( sizeof( POP3DATA ));
-  P->hostname = (char*)strdup( hostname );
-  P->timeout = 0;
- 
-  return mypop3( P );
-}
-
-int
-pingtpop3( const char *hostname, int t )
-{
-  POP3DATA *P;
-  int ret;
- 
-  P = (POP3DATA*)xmalloc( sizeof( POP3DATA ));
-  P->hostname = (char*)strdup( hostname );
-  P->timeout = t;
- 
-  ret = mypop3( P ); 
-
-  return mypop3( P );
-}
-
-int
-tpingpop3( const char *hostname )
-{
-  POP3DATA *P;
-  int ret;
- 
-  P = (POP3DATA*)xmalloc( sizeof( POP3DATA ));
-  P->hostname = (char*)strdup( hostname );
-  P->timeout = 0;
- 
-  ret = mypop3( P ); 
-
-  if( ret > 0 ){ return P->rtt; }
-  else         { return ret; }
-}
- 
-int
-tpingtpop3( const char *hostname, int t )
-{
-  POP3DATA *P;
-  int ret;
- 
-  P = (POP3DATA*)xmalloc( sizeof( POP3DATA ));
-  P->hostname = (char*)strdup( hostname );
-  P->timeout = t; 
-  
-  ret = mypop3( P );
- 
-  if( ret > 0 ){ return P->rtt; }
-  else         { return ret; }
- 
-} 
@@ -1,39 +0,0 @@
-/**
- * POP3 header
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifndef  POP3_H
-#define  POP3_H
-
-typedef struct
-{
-  char   *hostname;
-  int    rtt;
-  int    timeout;
-} POP3DATA;
-
-int mypop3( POP3DATA *P );
-
-int pingpop3 ( const char *hostname );
-int pingtpop3( const char *hostname, int t );
-int tpingpop3( const char *hostname );
-int tpingtpop3( const char *hostname, int t ); 
-
-#endif /*POP3_H*/
@@ -1,32 +0,0 @@
-/**
- * PING lib private data type
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include "private.h"
-
-struct ping_priv
-ping_priv_default (void)
-{
-  struct ping_priv datum;
-  datum.ident = IDENT_DEFAULT;
-  datum.timo = TIMO_DEFAULT;
-  return datum;
-}
@@ -1,37 +0,0 @@
-/**
- * PING lib private data type
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#ifndef PING_PRIVATE_H
-#define PING_PRIVATE_H 
-
-#define IDENT_DEFAULT 0
-#define TIMO_DEFAULT 2
-
-struct ping_priv {
-  int   ident;
-  int   timo;
-  int   rrt;
-  int   sock;
-};
-
-struct ping_priv ping_priv_default (void);
-#endif /* Def: PING_PRIVATE_H */
@@ -1,32 +0,0 @@
-#ifndef SETUP_H
-#define SETUP_H
-
-#ifdef HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif /*HAVE_SYS_TIMES_H*/
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif /*TIME_WITH_SYS_TIME*/
-
-#ifndef  TRUE
-# define TRUE           1
-#endif /*TRUE*/
-#ifndef  FALSE
-# define FALSE          0 
-#endif /*FALSE*/
-
-#ifndef  EXIT_SUCCESS
-# define EXIT_SUCCESS   0
-#endif /*EXIT_SUCESS*/
-#ifndef  EXIT_FAILURE
-# define EXIT_FAILURE   1
-#endif /*EXIT_FAILURE*/ 
-
-#endif/*SETUP_H*/
@@ -1,169 +0,0 @@
-/**
- * SMTP module
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/ 
-
-#include <setup.h>
-#include <sock.h>
-#include <smtp.h>
-#include <util.h> 
-#include <stdarg.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#ifdef HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif /*HAVE_SYS_TIMES_H*/
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif /*TIME_WITH_SYS_TIME*/
-
-#include "memory.h"
- 
-#define  MSGBUF 2048 
-
-int smtp_cmd( CONN *C, char *format, ... ); 
-
-int
-mysmtp( SMTPDATA *S )
-{
-  CONN *C;
-  char buf[MSGBUF];
-  int ret  = 0;
-  struct timeval mytime;
-
-  C = (CONN*)xmalloc( sizeof( CONN ));
-  C->port    =   25;
-  C->timeout = ( S->timeout == 0 )?60:S->timeout; 
- 
-  /* set the rtt timer */
-  (void) gettimeofday( &mytime, (struct timezone *)NULL); 
-
-  if(( C->sock=JOEsocket( C, S->hostname ))    < 0 ){ JOEclose( C ); return -1;  } 
-  if(( ret = JOEreadline( C, buf, MSGBUF ))    < 0 ){ JOEclose( C ); return ret; }
-  if(( ret = smtp_cmd( C, "%s", "HELO dude" )) < 0 ){ JOEclose( C ); return ret; }
-  if(( ret = smtp_cmd( C, "%s", "QUIT"   ))    < 0 ){ JOEclose( C ); return ret; }
-  JOEclose( C );
-
-  S->rtt = elapsed_time( &mytime );
-  
-  return 1;
-}
-
-int
-smtp_cmd( CONN *C, char *format, ... )
-{
-  va_list args;
-  char buf[MSGBUF];
-  char rec[MSGBUF];
-  int  ret;
-  
-  bzero( buf, sizeof( buf ));
-  bzero( rec, sizeof( rec));  
-
-  va_start( args, format );
-  if(( vsnprintf( buf, MSGBUF-3, format, args )) < 0 ){
-    perror( "message too large" );
-    exit( 1 );
-  }
-  
-  (void)strcat( buf, "\015\012" );
-  
-  if( JOEsocket_write( C, buf, sizeof( buf )) < 0 )
-    return -1;
-
-  if(( ret = JOEreadline( C, rec, MSGBUF )) <= 0 ){ 
-    return -1; 
-  }
-  *rec='\0';
-
-  va_end( args );
-  if(( ret = atoi( rec )) > 400 ){ 
-    return -1; 
-  } else return 1;
-}
-
-int 
-pingsmtp( const char *hostname )
-{
-  SMTPDATA *S;
- 
-  S = (SMTPDATA*)xmalloc( sizeof( SMTPDATA ));
-  S->hostname = (char*)strdup( hostname );
-  S->timeout = 0;
- 
-  return mysmtp( S );
-}
-
-int 
-pingtsmtp( const char *hostname, int t )
-{
-  SMTPDATA *S;
- 
-  S = (SMTPDATA*)xmalloc( sizeof( SMTPDATA ));
-  S->hostname = (char*)strdup( hostname );
-  S->timeout = t;
- 
-  return mysmtp( S );
-}
-
-int
-tpingsmtp( const char *hostname )
-{
-  SMTPDATA *S;
-  int ret;
- 
-  S = (SMTPDATA*)xmalloc( sizeof( SMTPDATA ));
-  S->hostname = (char*)strdup( hostname );
-  S->timeout = 0;
- 
-  ret = mysmtp( S ); 
- 
-  if( ret > 0 ){ return S->rtt; }
-  else         { return ret; }
-}
- 
-int
-tpingtsmtp( const char *hostname, int t )
-{
-  SMTPDATA *S;
-  int ret;
- 
-  S = (SMTPDATA*)xmalloc( sizeof( SMTPDATA ));
-  S->hostname = (char*)strdup( hostname );
-  S->timeout = t;
- 
-  ret = mysmtp( S ); 
- 
-  if( ret > 0 ){ return S->rtt; }
-  else         { return ret; }
- 
-} 
@@ -1,39 +0,0 @@
-/**
- * SMTP header
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifndef  SMTP_H
-#define  SMTP_H
-
-typedef struct
-{
-  char   *hostname;
-  int    rtt;
-  int    timeout;
-} SMTPDATA;
-
-int mysmtp( SMTPDATA *S );
-
-int pingsmtp ( const char *hostname );
-int pingtsmtp( const char *hostname, int t );
-int tpingsmtp( const char *hostname );
-int tpingtsmtp( const char *hostname, int t ); 
-
-#endif /*SMTP_H*/
@@ -1,493 +0,0 @@
-/**
- * LIBPING socket library
- *
- * Copyright (C) 2000, 2001, 2002 by
- * Jeffrey Fulmer - <jdfulmer@armstrong.com>
- * This file is distributed as part of libping
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-#ifdef  HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/
-
-#include <stdio.h>
-#include <sock.h>
-#include <fcntl.h>
-
-#ifdef  HAVE_ARPA_INET_H
-# include <arpa/inet.h>
-#endif/*HAVE_ARPA_INET_H*/
- 
-#ifdef  HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif/*HAVE_SYS_SOCKET_H*/ 
-
-#ifdef  HAVE_NETINET_IN_H
-# include <netinet/in.h>
-#endif/*HAVE_NETINET_IN_H*/
- 
-#ifdef  HAVE_NETDB_H
-# include <netdb.h>
-#endif/*HAVE_NETDB_H*/
-
-#ifdef  HAVE_SSL
-# include <openssl/rand.h>
-#endif/*HAVE_SSL */
-
-#include <setup.h>
-#include <errno.h>
-#include <string.h>
-
-/** 
- * local prototypes 
- */
-int mknblock( int socket, int nonblock );
-ssize_t socket_write( int sock, const void *vbuf, size_t len );  
-ssize_t ssl_socket_write( CONN *C, const void *vbuf, size_t len );
-
-/**
- * JOEsocket
- * returns int, socket handle
- */
-int
-JOEsocket( CONN *C, const char *hn )
-{
-  int conn;
-  struct timeval timeout;
-  int res;
-  int herrno;
-  int error;
-  socklen_t          len;
-  struct linger      ling;
-  struct sockaddr_in cli; 
-  struct hostent     *hp;
-  struct hostent     hent; 
-  char hbf[9000]; 
-
-#if defined(_AIX)
-  char *aixbuf;
-  int  rc;
-#endif/*_AIX*/ 
-
-#ifdef  HAVE_SSL
-  int serr; 
-  char buf[1024]; 
-  C->ssl  = NULL;
-  C->ctx  = NULL;
-#endif/*HAVE_SSL*/
-
-  C->sock = -1;
-  
-  if( C->prot == HTTPS ){
-    #ifdef HAVE_SSL
-      SSL_load_error_strings();
-      SSLeay_add_ssl_algorithms();
-      C->ctx = SSL_CTX_new( SSLv3_client_method());
-      if( C->ctx == NULL ){ perror( "SSL: ctx is NULL" ); }
-      /* http://www.openssl.org/support/faq.html#USER1
-       * Perhaps someday I'll learn to read the FAQ
-       * first and then code second, but probably not.
-       * Not all OSes have /dev/urandom, we must seed
-       * the PRNG
-       */
-      memset( buf, 0, sizeof( buf ));
-      RAND_seed( buf, sizeof( buf ));
-      C->ssl = SSL_new( C->ctx );
-      SSL_set_connect_state( C->ssl );
-    #else
-      return -1;
-    #endif /* HAVE_SSL */
-  }
-
-  /* create a socket, return -1 on failure */
-  if(( C->sock = socket( AF_INET, SOCK_STREAM, 0 )) < 0 ){
-    return -1;
-  }
- 
-#if defined(__GLIBC__)
-  /* for systems using GNU libc */
-  if(( gethostbyname_r( hn, &hent, hbf, sizeof(hbf), &hp, &herrno ) < 0 )){
-    hp = NULL;
-  }
-#elif defined(sun)
-  /* Solaris 5++ */
-  hp = gethostbyname_r( hn, &hent, hbf, sizeof(hbf), &herrno );
-#elif defined(_AIX)
-  aixbuf = (char*)xmalloc( 9000 );
-  rc  = gethostbyname_r(hn, (struct hostent *)aixbuf,
-                       (struct hostent_data *)(aixbuf + sizeof(struct hostent)));
-  hp = (struct hostent*)aixbuf;
-#elif ( defined(hpux) || defined(__osf__) )
-  hp = gethostbyname( hn );
-  herrno = h_errno;
-#else
-  /* simply hoping that gethostbyname is thread-safe */
-  hp = gethostbyname( hn );
-  herrno = h_errno;
-#endif/*OS SPECIFICS*/ 
-
-  if( hp == NULL ) return -1;
-  bzero( &cli, sizeof( cli ));
-  bcopy( (char*)hp->h_addr, (char*)&cli.sin_addr, hp->h_length );
-  cli.sin_family = AF_INET;
-  cli.sin_port = htons( C->port );
-
-  ling.l_onoff  = 1;
-  ling.l_linger = 0;
-  if( setsockopt( C->sock, SOL_SOCKET, SO_LINGER, &ling, sizeof( ling )) < 0 ){ 
-    return -1;    
-  }
-
-  /**
-   * connect to the host 
-   * evaluate the server response and check for
-   * readability/writeability of the socket....
-   */ 
-  conn = connect( C->sock, (struct sockaddr *)&cli, sizeof(struct sockaddr_in));
-  if( conn < 0 ){
-    JOEclose( C );
-    return -1;
-  }
-  else if( conn == 0 ){
-    goto FINISH; /* immediate connection */
-  }
-  else{
-    /** 
-     * we have a connection, set the
-     * socket to non-blocking and test
-     * its integrity.
-     */
-    if(( mknblock( C->sock, TRUE )) < 0 ){
-      return -1;
-    }
-    FD_ZERO(&C->rset);
-    FD_ZERO(&C->wset);
-    FD_SET( C->sock, &C->rset );    
-    FD_SET( C->sock, &C->wset );    
-    memset((void *)&timeout, '\0', sizeof( struct timeval ));
-    /**
-     * the default timeout is set in init.c, it's
-     * value can be changed by the user in .siegerc,
-     * but we'll still use a ternary condition since
-     * you can't be too safe....
-     */ 
-    timeout.tv_sec  = (C->timeout > 0)?C->timeout:60;
-    timeout.tv_usec = 0;
-
-    if(( res = select( C->sock+1, &C->rset, &C->wset, NULL, &timeout )) < 1 ){
-      perror( "JOEsocket: connection timed out." );
-      close( C->sock );
-      return -1; 
-    }
-    if( FD_ISSET( C->sock, &C->rset) || FD_ISSET( C->sock, &C->wset )){
-      len = sizeof(error);
-      if( getsockopt( C->sock, SOL_SOCKET, SO_ERROR, &error, &len ) < 0 )
-        return(-1); 
-    }
-  } /* end of connect conditional */
-
-FINISH:
-  /**
-   * make the socket blocking again.
-   */
-  if(( mknblock( C->sock, FALSE )) < 0 ){
-    perror( "JOEsocket: unable to set socket to non-blocking." );
-    return -1;
-  } 
- 
-  /* if requested, encrypt the transaction  */
-  if( C->prot == HTTPS ){
-    #ifdef HAVE_SSL
-      /* currently a fatal error, should it be? */
-      if(( SSL_set_fd( C->ssl, C->sock )) < 0 ){
-        perror( "unable to create secure socket!" );
-        exit( 0 );
-      }
-      if(( serr = SSL_connect( C->ssl )) < 0 ){
-        int problem = SSL_get_error( C->ssl, serr );
-        fprintf( stderr, "SSL_connect: want to %s more...\n",
-               ( problem == SSL_ERROR_WANT_READ) ? "read" : "write");
-        return -1;
-      }
-      SSL_get_cipher( C->ssl );
-    #else
-      return -1;
-    #endif /* HAVE_SSL */
-  }
-  
-  return((C->sock>0)?C->sock:-1);
-}
-
-/**
- * makes the socket non-blocking,
- * calls select with timeout and
- * returns the socket to blocking.
- */
-int
-JOEsocket_check( CONN *C, SDSET test )
-{
-  int res;
-  struct timeval timeout;
- 
-  FD_ZERO(&C->rset);
-  FD_ZERO(&C->wset);
-  FD_SET( C->sock, &C->rset );
-  FD_SET( C->sock, &C->wset );
-  memset((void *)&timeout, '\0', sizeof( struct timeval ));
-
-  if(( mknblock( C->sock, TRUE )) < 0 ){
-    perror( "SIMBOTsocket: unable to set socket to non-blocking." );
-    return -1;
-  }
- 
-  timeout.tv_sec  = ( C->timeout > 0)?C->timeout:60;
-  timeout.tv_usec = 0;
- 
-  switch( test ){
-  case READ:
-    if(( res = select( C->sock+1, &C->rset, NULL, NULL, &timeout )) < 1 ){
-      close( C->sock );
-      return -1;
-    }
-    break;
-  case WRITE:
-    if(( res = select( C->sock+1, NULL, &C->wset, NULL, &timeout )) < 1 ){
-      close( C->sock );
-      return -1;
-    }
-    break;
-  case RDWR:
-    if(( res = select( C->sock+1, &C->rset, &C->wset, NULL, &timeout )) < 1 ){
-      close( C->sock );
-      return -1;
-    }
-    break;
-  }
- 
-  if(( mknblock( C->sock, FALSE )) < 0 ){
-    perror( "SIMBOTsocket: unable to set socket to non-blocking." );
-    return -1;
-  }
-  FD_CLR( C->sock, &C->rset );
- 
-  return 0;
-}
-
-/**
- * local function
- * set socket to non-blocking
- */
-int
-mknblock( int sock, int nonblock )
-{
-#if HAVE_FCNTL_H 
-  int flags;
-  int retval;
-
-  flags = fcntl( sock, F_GETFL, 0 );
-  if( flags < 0 ){
-    perror("fcntl");
-    return -1;
-  }
-  if( nonblock ){ 
-    flags |=  O_NDELAY;
-  }
-  else{
-    flags &= ~O_NDELAY;
-  }
-  retval = fcntl( sock, F_SETFL, flags);
-  if( retval < 0 ){
-    perror("fcntl");
-    return -1;
-  } 
-  return retval;
-#elif defined( FIONBIO )
-  ioctl_t status;
- 
-  status = nb ? 1 : 0;
-  return ioctl( sd, FIONBIO, &status );
-#else
-  return -1;
-#endif
-}  
-
-/**
- * local function
- * returns ssize_t
- * writes vbuf to sock
- */
-ssize_t
-socket_write( int sock, const void *vbuf, size_t len )
-{
-  size_t      n;
-  ssize_t     w;
-  const char *buf;
- 
-  buf = vbuf;
-  n   = len;
-  while( n > 0 ){
-    if(( w = write( sock, buf, n )) <= 0 ){
-      if( errno == EINTR )
-        w = 0;
-      else
-        return( -1 );
-    }
-    n    -= w;
-    buf += n;
-  }
-  return( len );
-}
-
-/**
- * local function
- * returns ssize_t
- * writes vbuf to sock
- */
-ssize_t
-ssl_socket_write( CONN *C, const void *vbuf, size_t len )
-{
-#ifdef HAVE_SSL
-  size_t      n;
-  ssize_t     w;
-  const char *buf;
-
-  buf = vbuf;
-  n   = len;
-  while( n > 0 ){
-    if(( w = SSL_write( C->ssl, buf, n )) <= 0 ){
-      if( errno == EINTR )
-        w = 0;
-      else
-        return( -1 );
-    }
-    n    -= w;
-    buf += n;
-  }
-  return( len );
-#else
-  perror( "protocol not supported" );
-  return -1;
-#endif/*HAVE_SSL*/
-}
-
-ssize_t
-JOEreadline( CONN *C, char *ptr, size_t len )
-{
-  int n;
- 
-  do{
-    n = read( C->sock, ptr, 1 );
-  } while( n > 0 && *ptr++ != '\n' );
- 
-  *ptr++=0;
-  return( n > 0 );
-} 
-
-ssize_t
-JOEsocket_read( CONN *C, void *vbuf, size_t len )
-{
-  size_t      n;
-  ssize_t     r;
-  char *buf;
-  
-  buf = vbuf;
-  n   = len;
-  
-  if( C->prot == HTTPS ){
-  #ifdef HAVE_SSL
-    while( n > 0 ){ 
-      if(( r = SSL_read( C->ssl, buf, n )) < 0 ){
-        if( errno == EINTR )
-          r = 0;
-        else
-          return( -1 );
-      }
-      else if( r == 0 ) break; 
-      n   -= r;
-      buf += r;
-    }   /* end of while    */
-  #endif/*HAVE_SSL*/
-  }  
-  else{
-    while( n > 0 ){
-      if(( r = read( C->sock, buf, n )) < 0 ){
-        if( errno == EINTR )
-          r = 0;
-        else
-          return( -1 );
-      }
-      else if( r == 0 ) break;
-      n   -= r;
-      buf += r;
-    } /* end of while */ 
-  }   /* end of else  */
-
-  return( len - n );  
-}  
-
-/**
- * returns void
- * socket_write wrapper function.
- */
-int
-JOEsocket_write( CONN *C, const void *buf, size_t len )
-{
-  int bytes;
-
-  if( C->prot == HTTPS ){
-    /* handle HTTPS protocol */
-    #ifdef HAVE_SSL
-    if(( bytes = ssl_socket_write( C, buf, len )) != len ){
-      perror( "JOEssl_socket_write: ERROR" );
-      return -1;
-    }
-    #else
-      perror( "JOEssl_socket_write: protocol NOT supported" );
-      return -1;
-    #endif/*HAVE_SSL*/
-  }
-  else{
-    /* assume HTTP */
-    if(( bytes = socket_write( C->sock, buf, len )) != len ){
-      perror( "JOEsocket_write: ERROR" );
-      return -1;
-    }
-  }
-
-  return 0;
-} 
-
-/**
- * returns void
- * frees ssl resources if using ssl and
- * closes the connection and the socket.
- */
-void
-JOEclose( CONN *C )
-{
-  #ifdef  HAVE_SSL
-    if( C->prot == HTTPS ){
-      SSL_shutdown( C->ssl );
-    }
-    SSL_free( C->ssl );
-    SSL_CTX_free( C->ctx );
-  #endif/*HAVE_SSL*/
-  close( C->sock ); 
-
-  return;
-} 
-
-
@@ -1,135 +0,0 @@
-/**
- * LIBPING socket header file
- *
- * Copyright (C) 2000, 2001, 2002 by
- * Jeffrey Fulmer - <jdfulmer@armstrong.com>
- * This file is distributed as part of libping
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-#ifndef SOCK_H
-#define SOCK_H
-
-#ifdef  HAVE_ARPA_INET_H
-# include <arpa/inet.h>
-#endif/*HAVE_ARPA_INET_H*/
- 
-#ifdef  HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif/*HAVE_SYS_SOCKET_H*/
-
-#ifdef  HAVE_UNISTD_H
-# include <unistd.h>
-#endif/*HAVE_UNISTD_H*/ 
- 
-#ifdef  HAVE_NETINET_IN_H
-# include <netinet/in.h>
-#endif/*HAVE_NETINET_IN_H*/
-
-#ifdef HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif /*HAVE_SYS_TIMES_H*/
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif/*TIME_WITH_SYS_TIME*/ 
- 
-#ifdef  HAVE_NETDB_H
-# include <netdb.h>
-#endif/*HAVE_NETDB_H*/ 
-
-#ifdef  HAVE_SSL
-# include <openssl/ssl.h>
-# include <openssl/err.h>
-# include <openssl/rsa.h>
-# include <openssl/crypto.h>
-# include <openssl/x509.h>
-# include <openssl/pem.h>
-#endif/*HAVE_SSL*/
-
-#include <url.h>
-
-typedef enum
-{
-  S_CONNECTING = 1,
-  S_READING    = 2,
-  S_WRITING    = 4,
-  S_DONE       = 8
-} STATUS; 
-
-typedef enum
-{
-  READ  = 0,
-  WRITE = 1,
-  RDWR  = 2
-} SDSET;  
-
-typedef struct
-{
-  int      sock;
-  int      port;
-  int      timeout;
-  STATUS   status;
-  PROTOCOL prot;
-#ifdef  HAVE_SSL
-  SSL      *ssl;
-  SSL_CTX  *ctx;
-#endif/*HAVE_SSL*/
-  fd_set   rset;
-  fd_set   wset;
-} CONN; 
-
-/**
- * create socket 
- * const char *hostname
- * const char *service
- */
-int JOEsocket( CONN *conn, const char *hostname );
-
-/**
- * checks the socket for both
- * readability, writeability or both.
- */
-int JOEsocket_check( CONN *C, SDSET S );
-
-/** 
- * write int sock 
- * from char *buf, 
- * unsigned int length 
- */
-int JOEsocket_write( CONN *conn, const void *b, size_t n );
-
-/** 
- * read int sock, 
- * into void *buf, 
- * size_t length 
- */
-ssize_t JOEread_byte( CONN *conn, void *buf, size_t len ); 
-ssize_t JOEreadline( CONN *C, char *ptr, size_t len ); 
-ssize_t JOEsocket_read( CONN *conn, void *buf, size_t len ); 
-
-/** 
- * close int socket 
- */
-void JOEclose( CONN *C );
-
-#endif /* SOCK_H */
-
@@ -1,331 +0,0 @@
-/**
- * URL Processing
- *
- * Copyright (C) 2000, 2001, 2002 by
- * Jeffrey Fulmer - <jdfulmer@armstrong.com>
- * This file is distributed as part of Siege 
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
- *
- */
-#ifdef  HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/
- 
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-#ifdef STDC_HEADERS
-# include <string.h>
-#else
-# ifndef HAVE_STRCHR
-#  define strchr index
-#  define strrchr rindex
-# endif
-char *strchr (), *strrchr ();
-# ifndef HAVE_MEMCPY
-#  define memcpy(d, s, n) bcopy ((s), (d), (n))
-#  define memmove(d, s, n) bcopy ((s), (d), (n))
-# endif
-#endif
-#include <errno.h>
-#include <url.h>
-#include <util.h>
-#include <setup.h>
-
-/*HARDCODED ALERT*/
-#define PLENGTH 84  /* length of the *prot[] array */
-
-/** 
- * ALERT: using hardcoded array lengths below,
- * if you change this array, then redefine PLENGTH
- * 
- * Currently http(prot[25]) and https(prot[26]) are 
- * the only supported protocols.  But all w3c supported 
- * protocols are listed for URL evaluation.
- */  
-static char *prot[] = {
-  "about:",      "addrbook:",  "acap:",      "afp:",
-  "afs:",        "callto:",    "chttp:",     "cid:",
-  "clsid:",      "data:",      "date:",      "DAV:",
-  "dns:",        "eid:",       "fax:",       "file:",
-  "finger:",     "freenet:",   "ftp:",       "gopher:",
-  "gsm:",        "h323:",      "h324:",      "hdl:",
-  "hnews:",      "http:",      "https:",     "iioploc:",
-  "ilu:",        "imap:",      "IOR:",       "irc:",
-  "isbn:",       "java:",      "JavaRMI:",   "javascript:",
-  "jdbc:",       "ldap:",      "lid:",       "lifn:",
-  "livescript:", "lrq:",       "mailto:",    "mailserver:",
-  "md5:",        "mid:",       "mocha:",     "modem:",
-  "news:",       "nfs:",       "nntp:",      "opaquelocktoken:"
-  "path:",       "phone:",     "pop:",       "pop3:",
-  "printer:",    "prospero:",  "res:",       "rtsp:",
-  "rvp:",        "rwhois:",    "rx:",        "sdp:",
-  "sip:",        "shttp:",     "snews:",     "STANF:",
-  "t120:",       "tel:",       "telephone:", "telnet:",
-  "tip:",        "tn3270:",    "tv:",        "uuid:",
-  "urn:",        "vemmi:",     "videotex:",  "view:",
-  "wais:",       "whois++:",   "whodp:",     "z39.50r:",
-  "z39.50s:"
-  
-};
-
-/**
- * int value of the length of the protocol 
- * string passed to the function.
- */     
-int
-protocol_length( char *url )
-{
-  int x;
-  /** 
-   * hardcoded protocol length!! see explanation above...
-   */
-  for( x = 0; x < PLENGTH; x ++ ){ 
-    if( strncasecmp( url, prot[x], strlen( prot[x] )) == 0 )
-      return strlen( prot[x] );
-  } 
-  return 0;	
-}
-
-/**
- * If a person edits an html file on the
- * Microsoft platform and copies it to a 
- * UNIX server, we are left to deal with 
- * ^M chars messing with our minds...
- */
-char *
-trim( char *str )
-{
-  char *s=str;
- 
-  if( str == NULL ) return NULL;
- 
-  /* advance the ptr */
-  while( *s ) s++;
- 
-  /* chomp the white space */
-  while( str < s && isspace( *( s-1 )))
-    *s-- = '\0';
- 
-  *s = '\0';
- 
-  return str; /* UNIX friendly */
-} 
-
-/**
- * boolean, returns true if the protocol is 
- * supported by siege, false if it is not.
- */ 
-int
-is_supported( char* url )
-{
-  if( strncasecmp( url, prot[25], strlen( prot[25] )) == 0 )
-    return TRUE;
-  if( strncasecmp( url, prot[26], strlen( prot[26] )) == 0 )
-    #ifdef HAVE_SSL
-      return TRUE;
-    #else
-      return FALSE;
-    #endif /* HAVE_SSL */
-  else
-    return FALSE;
-}
-
-/**
- * get_protocol
- * returns protocol char*
- */
-PROTOCOL
-get_protocol( const char *url )
-{
-  if( strncasecmp( url, prot[25], strlen( prot[25] )) == 0 )
-    return HTTP;
-  if( strncasecmp( url, prot[26], strlen( prot[26] )) == 0 )
-    #ifdef HAVE_SSL
-      return HTTPS;
-    #else
-      return HTTP;
-    #endif /* HAVE_SSL */
-  else
-    return UNSPRTD;
-}
-
-/**
- * get_default_port
- */
-int
-get_default_port( PROTOCOL p )
-{
-  if( p == HTTP )
-    return 80;
-  if( p == HTTPS )
-    #ifdef HAVE_SSL
-      return 443;
-    #else
-      return 80;
-    #endif /* HAVE_SSL */
-  else
-    return 80; 
-}
-
-char *
-url_encode( char *str )
-{
-  int size = 0;
-  char *ch, *bk;
-  char *p, *buf;
-  static char unsafe[]     = "<>{}#%|\"\\^~[]`@:\033";
-  static char char2hex[16] = "0123456789ABCDEF";
-
-  bk = ch  = str;
-  do{
-    if( strchr( unsafe, *ch ))
-      size += 2;
-    ch++; size ++;
-  } while( *ch );
-
-  buf = (char*)malloc( size +1 );
-  p   = buf;
-  ch  = bk;
-  do{
-    if( strchr( unsafe, *ch )){
-      const char c = *ch;
-      *p++ = '%';
-      *p++ = char2hex[(c >> 4) & 0xf];
-      *p++ = char2hex[c & 0xf];
-    }
-    else{
-      *p++ = *ch;
-    }
-    ch ++;
-  } while( *ch );
-
-  *p = '\0';
-  return( buf );
-}
-
-/**
- * process_post_data
- * populates URL->postdata with POST information
- * returns int
- */
-char *
-process_post_data( char *datap )
-{
-  for( ; isspace(*datap); datap++ ){
-    /* Advance past white space */
-  }
-  if( *datap == '<' ){
-    /* Get Data from file */
-    return NULL;
-  }
-  else{
-    return datap;
-  }
-}
-
-URL
-build_url( char *url )
-{
-  URL U;                   /* defined in setup.h  */
-  int one, two, thr, fou;  /* placement counters. */ 
-  char *post_cmd=NULL;     /* POST directive for server */
-  char *tmp;
-
-  post_cmd = strstr( url, " POST" ); 
-  if( post_cmd != NULL ){
-    /* How do we deal with handling the multi-headed url_t arrays */
-    U.calltype = URL_POST;
-    *post_cmd = 0;
-    post_cmd += 5;
-    U.postdata = (char*)strdup( process_post_data( post_cmd ));
-    U.postlen  = strlen( U.postdata );
-  }
-  else{
-    U.calltype   = URL_GET;
-    U.postdata   = NULL;
-    U.posttemp   = NULL;
-    U.postlen    = 0;
-  }
-  if(( one = protocol_length( url )) > 0 && is_supported( url ) == TRUE ){
-    one += 2;
-  }
-  else if(( one = protocol_length( url )) > 0 && is_supported( url ) == FALSE ){
-    U.protocol = UNSPRTD;
-    one += 2;
-    perror( "unsupported protocol" );
-  }
-  else{
-    /* we are dealing with who knows what */
-    tmp = (char*)strstr( url, "://" );
-    if( tmp != NULL ){
-      one = (strlen(url) - (strlen(tmp) - 3 ));
-    }
-    else{
-      one = 0;  /* no specified protocol, assuming http: */
-    }
-  }
-
-  two = one;
-  while( url[two] && url[two] != ':' && url[two] != '/' ) two++; 
-
-  if( url[two] == ':' ){
-    fou = two;
-    while( url[two] && url[two] != '/' ){
-      two++;
-    }
-  }
-  else{ fou = two; }
-  if( url[two] == '/' ){ thr = two; }
-  else                 { thr = strlen( url ); } 
-
-  /* here we piece it all together */
-  if( one == 0 ){
-    U.protocol = HTTP;
-  }
-  else{
-    U.protocol = get_protocol( url );
-  }
-  U.hostname   = (char*)strdup(substring( url, one, ( fou - one )));
-  if( fou == two ){
-    U.port = get_default_port( U.protocol );
-  }
-  else{
-    U.port = atoi(substring( url, fou+1, (thr-(fou+1))));
-  }
-  if(( U.pathname = (char *)strdup(substring( url, thr, strlen( url )))) == NULL ){
-    U.pathname = (char *)strdup( "/" ); 
-  }
-  U.pathname = (strlen(U.pathname)==0)?strcpy(U.pathname, "/"):U.pathname; 
-  trim( U.pathname );
-
-  free( url ); 
-  return( U );
-}
-
-/**
- * add_url
- * parses char * then populates and 
- * returns a URL with appropriate data.
- */
-URL
-add_url( char *url )
-{
-
-  return build_url( url );
-}
-
-
@@ -1,69 +0,0 @@
-/**
- * URL support
- *
- * Copyright (C) 2000, 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of Siege
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- * --
- */
-#ifndef  URL_H
-#define  URL_H
-
-typedef enum
-{
-  HTTP    = 1,
-  HTTPS   = 2,
-  ECHO    = 4,
-  SMTP    = 8,
-  POP3    = 16,
-  UNSPRTD = 32
-} PROTOCOL; 
-
-/**
- * enum DIRECTIVE
- * HTTP request directive
- */
-typedef enum
-{
-  URL_GET   = 0,
-  URL_POST  = 1
-} DIRECTIVE;
-
-/**
- * URL struct URL
- */
-typedef struct
-{
-  PROTOCOL protocol;       /* currently only http/https   */
-  char *hostname;          /* DNS entry or IP address     */
-  int  port;               /* tcp port num, defs: 80, 443 */
-  char *pathname;          /* path to http resource.      */
-  DIRECTIVE calltype;      /* request: GET/POST/HEAD etc. */
-  size_t postlen;
-  char *postdata;
-  char *posttemp;
-} URL;
-
-int  protocol_length( char *url ); 
-int  is_supported( char* url );
-int  get_default_port( PROTOCOL p );
-PROTOCOL get_protocol( const char *url );
-void insert_childid( URL *U, int mypid );
-char *process_post_data( char *datap );
-URL  build_url( char *url );
-URL  add_url( char *url );
-
-#endif/*URL_H*/
@@ -1,110 +0,0 @@
-/**
- * UTILITY module
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif /* HAVE_CONFIG_H */
-
-#include <util.h>
-
-#ifdef STDC_HEADERS
-# include <string.h>
-#else
-# ifndef HAVE_STRCHR
-#  define strchr index
-#  define strrchr rindex
-# endif /* HAVE_STRCHR */
-char *strchr (), *strrchr ();
-# ifndef HAVE_MEMCPY
-#  define memcpy(d, s, n) bcopy ((s), (d), (n))
-#  define memmove(d, s, n) bcopy ((s), (d), (n))
-# endif /* HAVE_MEMCPY  */
-#endif  /* STDC_HEADERS */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include "memory.h"
-
-/**
- * elapsed_time
- * returns an int value for the difference
- * between now and starttime in milliseconds.
- */
-int
-elapsed_time( struct timeval *starttime ){
-  struct timeval *newtime;
-  int elapsed;
-  newtime = (struct timeval*)malloc( sizeof(struct timeval));
-  gettimeofday(newtime,NULL);
-  elapsed = 0;
-  
-  if(( newtime->tv_usec - starttime->tv_usec) > 0 ){
-    elapsed += (newtime->tv_usec - starttime->tv_usec)/1000 ;
-  }
-  else{
-    elapsed += ( 1000000 + newtime->tv_usec - starttime->tv_usec ) /1000;
-    newtime->tv_sec--;
-  }
-  if(( newtime->tv_sec - starttime->tv_sec ) > 0 ){
-    elapsed += 1000 * ( newtime->tv_sec - starttime->tv_sec );
-  }
-  if( elapsed < 1 )
-    elapsed = 1;
-  
-  free( newtime );
-  return( elapsed );
-} 
-
-/**
- * substring        
- * returns a char pointer from int start 
- * to int length.
- */
-char * 
-substring (char *buffer, int start, int length)
-{
-  char *sub;
-  sub = xmalloc (sizeof (char) * (length + 1));
-	
-  if ((length < 1) || (start < 0) || (start > strlen (buffer)))
-    return NULL;
-
-  if (strlen (buffer) < length){
-    sub = (char*) strdup (buffer);
-    return buffer;
-  }
-
-  if (sub == NULL){
-    perror( "insufficient memory." );
-    exit( 1 );
-  }
-
-  memset (sub, 0, length + 1);
-
-  buffer += start;
-  memcpy (sub, buffer, length);
-
-  return sub;
-}
-
@@ -1,48 +0,0 @@
-/**
- * UTILITY header
- *
- * Copyright (C) 2001 Jeffrey Fulmer <jdfulmer@armstrong.com>
- * This file is part of LIBPING
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#ifndef UTIL_H
-#define UTIL_H
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif/*HAVE_CONFIG_H*/ 
-
-#ifdef  HAVE_SYS_TIMES_H
-# include <sys/times.h>
-#endif/*HAVE_SYS_TIMES_H*/
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif /*HAVE_SYS_TIME_H*/
-#endif  /*TIME_WITH_SYS_TIME*/  
-
-int elapsed_time( struct timeval *starttime );
-
-char * substring( char *, int, int );
-
-#endif  /* UTIL_H */
-