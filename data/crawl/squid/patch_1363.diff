@@ -1,5 +1,5 @@
 /*
- * $Id: aiops.cc,v 1.8 2001/03/17 13:31:16 hno Exp $
+ * $Id: aiops.cc,v 1.9 2001/08/20 06:55:31 hno Exp $
  *
  * DEBUG: section 43    AIOPS
  * AUTHOR: Stewart Forster <slf@connect.com.au>
@@ -49,15 +49,16 @@
 
 #define RIDICULOUS_LENGTH	4096
 
-enum _aio_thread_status {
+enum _squidaio_thread_status {
     _THREAD_STARTING = 0,
     _THREAD_WAITING,
     _THREAD_BUSY,
     _THREAD_FAILED,
     _THREAD_DONE
 };
+typedef enum _squidaio_thread_status squidaio_thread_status;
 
-enum _aio_request_type {
+enum _squidaio_request_type {
     _AIO_OP_NONE = 0,
     _AIO_OP_OPEN,
     _AIO_OP_READ,
@@ -68,10 +69,11 @@ enum _aio_request_type {
     _AIO_OP_OPENDIR,
     _AIO_OP_STAT
 };
+typedef enum _squidaio_request_type squidaio_request_type;
 
-typedef struct aio_request_t {
-    struct aio_request_t *next;
-    enum _aio_request_type request_type;
+typedef struct squidaio_request_t {
+    struct squidaio_request_t *next;
+    squidaio_request_type request_type;
     int cancelled;
     char *path;
     int oflag;
@@ -86,57 +88,57 @@ typedef struct aio_request_t {
     int err;
     struct stat *tmpstatp;
     struct stat *statp;
-    aio_result_t *resultp;
-} aio_request_t;
+    squidaio_result_t *resultp;
+} squidaio_request_t;
 
-typedef struct aio_request_queue_t {
+typedef struct squidaio_request_queue_t {
     pthread_mutex_t mutex;
     pthread_cond_t cond;
-    aio_request_t *volatile head;
-    aio_request_t *volatile *volatile tailp;
+    squidaio_request_t *volatile head;
+    squidaio_request_t *volatile *volatile tailp;
     unsigned long requests;
     unsigned long blocked;	/* main failed to lock the queue */
-} aio_request_queue_t;
+} squidaio_request_queue_t;
 
-typedef struct aio_thread_t aio_thread_t;
-struct aio_thread_t {
-    aio_thread_t *next;
+typedef struct squidaio_thread_t squidaio_thread_t;
+struct squidaio_thread_t {
+    squidaio_thread_t *next;
     pthread_t thread;
-    enum _aio_thread_status status;
-    struct aio_request_t *current_req;
+    squidaio_thread_status status;
+    struct squidaio_request_t *current_req;
     unsigned long requests;
 };
 
-int aio_cancel(aio_result_t *);
-int aio_open(const char *, int, mode_t, aio_result_t *);
-int aio_read(int, char *, int, off_t, int, aio_result_t *);
-int aio_write(int, char *, int, off_t, int, aio_result_t *);
-int aio_close(int, aio_result_t *);
-int aio_unlink(const char *, aio_result_t *);
-int aio_truncate(const char *, off_t length, aio_result_t *);
-int aio_opendir(const char *, aio_result_t *);
-aio_result_t *aio_poll_done();
-int aio_sync(void);
-
-static void aio_init(void);
-static void aio_queue_request(aio_request_t *);
-static void aio_cleanup_request(aio_request_t *);
-static void *aio_thread_loop(void *);
-static void aio_do_open(aio_request_t *);
-static void aio_do_read(aio_request_t *);
-static void aio_do_write(aio_request_t *);
-static void aio_do_close(aio_request_t *);
-static void aio_do_stat(aio_request_t *);
-static void aio_do_unlink(aio_request_t *);
-static void aio_do_truncate(aio_request_t *);
+int squidaio_cancel(squidaio_result_t *);
+int squidaio_open(const char *, int, mode_t, squidaio_result_t *);
+int squidaio_read(int, char *, int, off_t, int, squidaio_result_t *);
+int squidaio_write(int, char *, int, off_t, int, squidaio_result_t *);
+int squidaio_close(int, squidaio_result_t *);
+int squidaio_unlink(const char *, squidaio_result_t *);
+int squidaio_truncate(const char *, off_t length, squidaio_result_t *);
+int squidaio_opendir(const char *, squidaio_result_t *);
+squidaio_result_t *squidaio_poll_done();
+int squidaio_sync(void);
+
+static void squidaio_init(void);
+static void squidaio_queue_request(squidaio_request_t *);
+static void squidaio_cleanup_request(squidaio_request_t *);
+static void *squidaio_thread_loop(void *);
+static void squidaio_do_open(squidaio_request_t *);
+static void squidaio_do_read(squidaio_request_t *);
+static void squidaio_do_write(squidaio_request_t *);
+static void squidaio_do_close(squidaio_request_t *);
+static void squidaio_do_stat(squidaio_request_t *);
+static void squidaio_do_unlink(squidaio_request_t *);
+static void squidaio_do_truncate(squidaio_request_t *);
 #if AIO_OPENDIR
-static void *aio_do_opendir(aio_request_t *);
+static void *squidaio_do_opendir(squidaio_request_t *);
 #endif
-static void aio_debug(aio_request_t *);
-static void aio_poll_queues(void);
+static void squidaio_debug(squidaio_request_t *);
+static void squidaio_poll_queues(void);
 
-static aio_thread_t *threads = NULL;
-static int aio_initialised = 0;
+static squidaio_thread_t *threads = NULL;
+static int squidaio_initialised = 0;
 
 
 #define AIO_LARGE_BUFS  16384
@@ -145,25 +147,25 @@ static int aio_initialised = 0;
 #define AIO_TINY_BUFS	AIO_LARGE_BUFS >> 3
 #define AIO_MICRO_BUFS	128
 
-static MemPool *aio_large_bufs = NULL;	/* 16K */
-static MemPool *aio_medium_bufs = NULL;		/* 8K */
-static MemPool *aio_small_bufs = NULL;	/* 4K */
-static MemPool *aio_tiny_bufs = NULL;	/* 2K */
-static MemPool *aio_micro_bufs = NULL;	/* 128K */
+static MemPool *squidaio_large_bufs = NULL;	/* 16K */
+static MemPool *squidaio_medium_bufs = NULL;		/* 8K */
+static MemPool *squidaio_small_bufs = NULL;	/* 4K */
+static MemPool *squidaio_tiny_bufs = NULL;	/* 2K */
+static MemPool *squidaio_micro_bufs = NULL;	/* 128K */
 
 static int request_queue_len = 0;
-static MemPool *aio_request_pool = NULL;
-static MemPool *aio_thread_pool = NULL;
-static aio_request_queue_t request_queue;
+static MemPool *squidaio_request_pool = NULL;
+static MemPool *squidaio_thread_pool = NULL;
+static squidaio_request_queue_t request_queue;
 static struct {
-    aio_request_t *head, **tailp;
+    squidaio_request_t *head, **tailp;
 } request_queue2 = {
 
     NULL, &request_queue2.head
 };
-static aio_request_queue_t done_queue;
+static squidaio_request_queue_t done_queue;
 static struct {
-    aio_request_t *head, **tailp;
+    squidaio_request_t *head, **tailp;
 } done_requests = {
 
     NULL, &done_requests.head
@@ -175,32 +177,32 @@ static struct sched_param globsched;
 static pthread_t main_thread;
 
 static MemPool *
-aio_get_pool(int size)
+squidaio_get_pool(int size)
 {
     MemPool *p;
     if (size <= AIO_LARGE_BUFS) {
 	if (size <= AIO_MICRO_BUFS)
-	    p = aio_micro_bufs;
+	    p = squidaio_micro_bufs;
 	else if (size <= AIO_TINY_BUFS)
-	    p = aio_tiny_bufs;
+	    p = squidaio_tiny_bufs;
 	else if (size <= AIO_SMALL_BUFS)
-	    p = aio_small_bufs;
+	    p = squidaio_small_bufs;
 	else if (size <= AIO_MEDIUM_BUFS)
-	    p = aio_medium_bufs;
+	    p = squidaio_medium_bufs;
 	else
-	    p = aio_large_bufs;
+	    p = squidaio_large_bufs;
     } else
 	p = NULL;
     return p;
 }
 
 static void *
-aio_xmalloc(int size)
+squidaio_xmalloc(int size)
 {
     void *p;
     MemPool *pool;
 
-    if ((pool = aio_get_pool(size)) != NULL) {
+    if ((pool = squidaio_get_pool(size)) != NULL) {
 	p = memPoolAlloc(pool);
     } else
 	p = xmalloc(size);
@@ -209,47 +211,47 @@ aio_xmalloc(int size)
 }
 
 static char *
-aio_xstrdup(const char *str)
+squidaio_xstrdup(const char *str)
 {
     char *p;
     int len = strlen(str) + 1;
 
-    p = aio_xmalloc(len);
+    p = squidaio_xmalloc(len);
     strncpy(p, str, len);
 
     return p;
 }
 
 static void
-aio_xfree(void *p, int size)
+squidaio_xfree(void *p, int size)
 {
     MemPool *pool;
 
-    if ((pool = aio_get_pool(size)) != NULL) {
+    if ((pool = squidaio_get_pool(size)) != NULL) {
 	memPoolFree(pool, p);
     } else
 	xfree(p);
 }
 
 static void
-aio_xstrfree(char *str)
+squidaio_xstrfree(char *str)
 {
     MemPool *pool;
     int len = strlen(str) + 1;
 
-    if ((pool = aio_get_pool(len)) != NULL) {
+    if ((pool = squidaio_get_pool(len)) != NULL) {
 	memPoolFree(pool, str);
     } else
 	xfree(str);
 }
 
 static void
-aio_init(void)
+squidaio_init(void)
 {
     int i;
-    aio_thread_t *threadp;
+    squidaio_thread_t *threadp;
 
-    if (aio_initialised)
+    if (squidaio_initialised)
 	return;
 
     pthread_attr_init(&globattr);
@@ -291,38 +293,38 @@ aio_init(void)
     done_queue.blocked = 0;
 
     /* Create threads and get them to sit in their wait loop */
-    aio_thread_pool = memPoolCreate("aio_thread", sizeof(aio_thread_t));
+    squidaio_thread_pool = memPoolCreate("aio_thread", sizeof(squidaio_thread_t));
     for (i = 0; i < NUMTHREADS; i++) {
-	threadp = memPoolAlloc(aio_thread_pool);
+	threadp = memPoolAlloc(squidaio_thread_pool);
 	threadp->status = _THREAD_STARTING;
 	threadp->current_req = NULL;
 	threadp->requests = 0;
 	threadp->next = threads;
 	threads = threadp;
-	if (pthread_create(&threadp->thread, &globattr, aio_thread_loop, threadp)) {
+	if (pthread_create(&threadp->thread, &globattr, squidaio_thread_loop, threadp)) {
 	    fprintf(stderr, "Thread creation failed\n");
 	    threadp->status = _THREAD_FAILED;
 	    continue;
 	}
     }
 
     /* Create request pool */
-    aio_request_pool = memPoolCreate("aio_request", sizeof(aio_request_t));
-    aio_large_bufs = memPoolCreate("aio_large_bufs", AIO_LARGE_BUFS);
-    aio_medium_bufs = memPoolCreate("aio_medium_bufs", AIO_MEDIUM_BUFS);
-    aio_small_bufs = memPoolCreate("aio_small_bufs", AIO_SMALL_BUFS);
-    aio_tiny_bufs = memPoolCreate("aio_tiny_bufs", AIO_TINY_BUFS);
-    aio_micro_bufs = memPoolCreate("aio_micro_bufs", AIO_MICRO_BUFS);
-
-    aio_initialised = 1;
+    squidaio_request_pool = memPoolCreate("aio_request", sizeof(squidaio_request_t));
+    squidaio_large_bufs = memPoolCreate("squidaio_large_bufs", AIO_LARGE_BUFS);
+    squidaio_medium_bufs = memPoolCreate("squidaio_medium_bufs", AIO_MEDIUM_BUFS);
+    squidaio_small_bufs = memPoolCreate("squidaio_small_bufs", AIO_SMALL_BUFS);
+    squidaio_tiny_bufs = memPoolCreate("squidaio_tiny_bufs", AIO_TINY_BUFS);
+    squidaio_micro_bufs = memPoolCreate("squidaio_micro_bufs", AIO_MICRO_BUFS);
+
+    squidaio_initialised = 1;
 }
 
 
 static void *
-aio_thread_loop(void *ptr)
+squidaio_thread_loop(void *ptr)
 {
-    aio_thread_t *threadp = ptr;
-    aio_request_t *request;
+    squidaio_thread_t *threadp = ptr;
+    squidaio_request_t *request;
     sigset_t new;
 
     /*
@@ -370,30 +372,30 @@ aio_thread_loop(void *ptr)
 	if (!request->cancelled) {
 	    switch (request->request_type) {
 	    case _AIO_OP_OPEN:
-		aio_do_open(request);
+		squidaio_do_open(request);
 		break;
 	    case _AIO_OP_READ:
-		aio_do_read(request);
+		squidaio_do_read(request);
 		break;
 	    case _AIO_OP_WRITE:
-		aio_do_write(request);
+		squidaio_do_write(request);
 		break;
 	    case _AIO_OP_CLOSE:
-		aio_do_close(request);
+		squidaio_do_close(request);
 		break;
 	    case _AIO_OP_UNLINK:
-		aio_do_unlink(request);
+		squidaio_do_unlink(request);
 		break;
 	    case _AIO_OP_TRUNCATE:
-		aio_do_truncate(request);
+		squidaio_do_truncate(request);
 		break;
 #if AIO_OPENDIR			/* Opendir not implemented yet */
 	    case _AIO_OP_OPENDIR:
-		aio_do_opendir(request);
+		squidaio_do_opendir(request);
 		break;
 #endif
 	    case _AIO_OP_STAT:
-		aio_do_stat(request);
+		squidaio_do_stat(request);
 		break;
 	    default:
 		request->ret = -1;
@@ -413,13 +415,13 @@ aio_thread_loop(void *ptr)
 	threadp->requests++;
     }				/* while forever */
     return NULL;
-}				/* aio_thread_loop */
+}				/* squidaio_thread_loop */
 
 static void
-aio_queue_request(aio_request_t * request)
+squidaio_queue_request(squidaio_request_t * request)
 {
     static int high_start = 0;
-    debug(41, 9) ("aio_queue_request: %p type=%d result=%p\n",
+    debug(41, 9) ("squidaio_queue_request: %p type=%d result=%p\n",
 	request, request->request_type, request->resultp);
     /* Mark it as not executed (failing result, no error) */
     request->ret = -1;
@@ -464,7 +466,7 @@ aio_queue_request(aio_request_t * request)
 	if (++filter >= filter_limit) {
 	    filter_limit += filter;
 	    filter = 0;
-	    debug(43, 1) ("aio_queue_request: WARNING - Queue congestion\n");
+	    debug(43, 1) ("squidaio_queue_request: WARNING - Queue congestion\n");
 	}
     }
     /* Warn if out of threads */
@@ -482,9 +484,9 @@ aio_queue_request(aio_request_t * request)
 	    queue_low = request_queue_len;
 	if (squid_curtime >= (last_warn + 15) &&
 	    squid_curtime >= (high_start + 5)) {
-	    debug(43, 1) ("aio_queue_request: WARNING - Disk I/O overloading\n");
+	    debug(43, 1) ("squidaio_queue_request: WARNING - Disk I/O overloading\n");
 	    if (squid_curtime >= (high_start + 15))
-		debug(43, 1) ("aio_queue_request: Queue Length: current=%d, high=%d, low=%d, duration=%d\n",
+		debug(43, 1) ("squidaio_queue_request: Queue Length: current=%d, high=%d, low=%d, duration=%d\n",
 		    request_queue_len, queue_high, queue_low, squid_curtime - high_start);
 	    last_warn = squid_curtime;
 	}
@@ -493,17 +495,17 @@ aio_queue_request(aio_request_t * request)
     }
     /* Warn if seriously overloaded */
     if (request_queue_len > RIDICULOUS_LENGTH) {
-	debug(43, 0) ("aio_queue_request: Async request queue growing uncontrollably!\n");
-	debug(43, 0) ("aio_queue_request: Syncing pending I/O operations.. (blocking)\n");
-	aio_sync();
-	debug(43, 0) ("aio_queue_request: Synced\n");
+	debug(43, 0) ("squidaio_queue_request: Async request queue growing uncontrollably!\n");
+	debug(43, 0) ("squidaio_queue_request: Syncing pending I/O operations.. (blocking)\n");
+	squidaio_sync();
+	debug(43, 0) ("squidaio_queue_request: Synced\n");
     }
-}				/* aio_queue_request */
+}				/* squidaio_queue_request */
 
 static void
-aio_cleanup_request(aio_request_t * requestp)
+squidaio_cleanup_request(squidaio_request_t * requestp)
 {
-    aio_result_t *resultp = requestp->resultp;
+    squidaio_result_t *resultp = requestp->resultp;
     int cancelled = requestp->cancelled;
 
     /* Free allocated structures and copy data back to user space if the */
@@ -512,14 +514,14 @@ aio_cleanup_request(aio_request_t * requestp)
     case _AIO_OP_STAT:
 	if (!cancelled && requestp->ret == 0)
 	    xmemcpy(requestp->statp, requestp->tmpstatp, sizeof(struct stat));
-	aio_xfree(requestp->tmpstatp, sizeof(struct stat));
-	aio_xstrfree(requestp->path);
+	squidaio_xfree(requestp->tmpstatp, sizeof(struct stat));
+	squidaio_xstrfree(requestp->path);
 	break;
     case _AIO_OP_OPEN:
 	if (cancelled && requestp->ret >= 0)
 	    /* The open() was cancelled but completed */
 	    close(requestp->ret);
-	aio_xstrfree(requestp->path);
+	squidaio_xstrfree(requestp->path);
 	break;
     case _AIO_OP_CLOSE:
 	if (cancelled && requestp->ret < 0)
@@ -529,15 +531,15 @@ aio_cleanup_request(aio_request_t * requestp)
     case _AIO_OP_UNLINK:
     case _AIO_OP_TRUNCATE:
     case _AIO_OP_OPENDIR:
-	aio_xstrfree(requestp->path);
+	squidaio_xstrfree(requestp->path);
 	break;
     case _AIO_OP_READ:
 	if (!cancelled && requestp->ret > 0)
 	    xmemcpy(requestp->bufferp, requestp->tmpbufp, requestp->ret);
-	aio_xfree(requestp->tmpbufp, requestp->buflen);
+	squidaio_xfree(requestp->tmpbufp, requestp->buflen);
 	break;
     case _AIO_OP_WRITE:
-	aio_xfree(requestp->tmpbufp, requestp->buflen);
+	squidaio_xfree(requestp->tmpbufp, requestp->buflen);
 	break;
     default:
 	break;
@@ -546,80 +548,80 @@ aio_cleanup_request(aio_request_t * requestp)
 	resultp->aio_return = requestp->ret;
 	resultp->aio_errno = requestp->err;
     }
-    memPoolFree(aio_request_pool, requestp);
-}				/* aio_cleanup_request */
+    memPoolFree(squidaio_request_pool, requestp);
+}				/* squidaio_cleanup_request */
 
 
 int
-aio_cancel(aio_result_t * resultp)
+squidaio_cancel(squidaio_result_t * resultp)
 {
-    aio_request_t *request = resultp->_data;
+    squidaio_request_t *request = resultp->_data;
 
     if (request && request->resultp == resultp) {
-	debug(41, 9) ("aio_cancel: %p type=%d result=%p\n",
+	debug(41, 9) ("squidaio_cancel: %p type=%d result=%p\n",
 	    request, request->request_type, request->resultp);
 	request->cancelled = 1;
 	request->resultp = NULL;
 	resultp->_data = NULL;
 	return 0;
     }
     return 1;
-}				/* aio_cancel */
+}				/* squidaio_cancel */
 
 
 int
-aio_open(const char *path, int oflag, mode_t mode, aio_result_t * resultp)
+squidaio_open(const char *path, int oflag, mode_t mode, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
-    requestp->path = (char *) aio_xstrdup(path);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
+    requestp->path = (char *) squidaio_xstrdup(path);
     requestp->oflag = oflag;
     requestp->mode = mode;
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_OPEN;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_open(aio_request_t * requestp)
+squidaio_do_open(squidaio_request_t * requestp)
 {
     requestp->ret = open(requestp->path, requestp->oflag, requestp->mode);
     requestp->err = errno;
 }
 
 
 int
-aio_read(int fd, char *bufp, int bufs, off_t offset, int whence, aio_result_t * resultp)
+squidaio_read(int fd, char *bufp, int bufs, off_t offset, int whence, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
     requestp->fd = fd;
     requestp->bufferp = bufp;
-    requestp->tmpbufp = (char *) aio_xmalloc(bufs);
+    requestp->tmpbufp = (char *) squidaio_xmalloc(bufs);
     requestp->buflen = bufs;
     requestp->offset = offset;
     requestp->whence = whence;
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_READ;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_read(aio_request_t * requestp)
+squidaio_do_read(squidaio_request_t * requestp)
 {
     lseek(requestp->fd, requestp->offset, requestp->whence);
     requestp->ret = read(requestp->fd, requestp->tmpbufp, requestp->buflen);
@@ -628,15 +630,15 @@ aio_do_read(aio_request_t * requestp)
 
 
 int
-aio_write(int fd, char *bufp, int bufs, off_t offset, int whence, aio_result_t * resultp)
+squidaio_write(int fd, char *bufp, int bufs, off_t offset, int whence, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
     requestp->fd = fd;
-    requestp->tmpbufp = (char *) aio_xmalloc(bufs);
+    requestp->tmpbufp = (char *) squidaio_xmalloc(bufs);
     xmemcpy(requestp->tmpbufp, bufp, bufs);
     requestp->buflen = bufs;
     requestp->offset = offset;
@@ -645,150 +647,150 @@ aio_write(int fd, char *bufp, int bufs, off_t offset, int whence, aio_result_t *
     requestp->request_type = _AIO_OP_WRITE;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_write(aio_request_t * requestp)
+squidaio_do_write(squidaio_request_t * requestp)
 {
     requestp->ret = write(requestp->fd, requestp->tmpbufp, requestp->buflen);
     requestp->err = errno;
 }
 
 
 int
-aio_close(int fd, aio_result_t * resultp)
+squidaio_close(int fd, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
     requestp->fd = fd;
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_CLOSE;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_close(aio_request_t * requestp)
+squidaio_do_close(squidaio_request_t * requestp)
 {
     requestp->ret = close(requestp->fd);
     requestp->err = errno;
 }
 
 
 int
-aio_stat(const char *path, struct stat *sb, aio_result_t * resultp)
+squidaio_stat(const char *path, struct stat *sb, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
-    requestp->path = (char *) aio_xstrdup(path);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
+    requestp->path = (char *) squidaio_xstrdup(path);
     requestp->statp = sb;
-    requestp->tmpstatp = (struct stat *) aio_xmalloc(sizeof(struct stat));
+    requestp->tmpstatp = (struct stat *) squidaio_xmalloc(sizeof(struct stat));
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_STAT;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_stat(aio_request_t * requestp)
+squidaio_do_stat(squidaio_request_t * requestp)
 {
     requestp->ret = stat(requestp->path, requestp->tmpstatp);
     requestp->err = errno;
 }
 
 
 int
-aio_unlink(const char *path, aio_result_t * resultp)
+squidaio_unlink(const char *path, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
-    requestp->path = aio_xstrdup(path);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
+    requestp->path = squidaio_xstrdup(path);
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_UNLINK;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_unlink(aio_request_t * requestp)
+squidaio_do_unlink(squidaio_request_t * requestp)
 {
     requestp->ret = unlink(requestp->path);
     requestp->err = errno;
 }
 
 int
-aio_truncate(const char *path, off_t length, aio_result_t * resultp)
+squidaio_truncate(const char *path, off_t length, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
-    requestp->path = (char *) aio_xstrdup(path);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
+    requestp->path = (char *) squidaio_xstrdup(path);
     requestp->offset = length;
     requestp->resultp = resultp;
     requestp->request_type = _AIO_OP_TRUNCATE;
     requestp->cancelled = 0;
 
-    aio_queue_request(requestp);
+    squidaio_queue_request(requestp);
     return 0;
 }
 
 
 static void
-aio_do_truncate(aio_request_t * requestp)
+squidaio_do_truncate(squidaio_request_t * requestp)
 {
     requestp->ret = truncate(requestp->path, requestp->offset);
     requestp->err = errno;
 }
 
 
 #if AIO_OPENDIR
-/* XXX aio_opendir NOT implemented yet.. */
+/* XXX squidaio_opendir NOT implemented yet.. */
 
 int
-aio_opendir(const char *path, aio_result_t * resultp)
+squidaio_opendir(const char *path, squidaio_result_t * resultp)
 {
-    aio_request_t *requestp;
+    squidaio_request_t *requestp;
     int len;
 
-    if (!aio_initialised)
-	aio_init();
-    requestp = memPoolAlloc(aio_request_pool);
+    if (!squidaio_initialised)
+	squidaio_init();
+    requestp = memPoolAlloc(squidaio_request_pool);
     return -1;
 }
 
 static void
-aio_do_opendir(aio_request_t * requestp)
+squidaio_do_opendir(squidaio_request_t * requestp)
 {
     /* NOT IMPLEMENTED */
 }
 
 #endif
 
 static void
-aio_poll_queues(void)
+squidaio_poll_queues(void)
 {
     /* kick "overflow" request queue */
     if (request_queue2.head &&
@@ -802,7 +804,7 @@ aio_poll_queues(void)
     }
     /* poll done queue */
     if (done_queue.head && pthread_mutex_trylock(&done_queue.mutex) == 0) {
-	struct aio_request_t *requests = done_queue.head;
+	struct squidaio_request_t *requests = done_queue.head;
 	done_queue.head = NULL;
 	done_queue.tailp = &done_queue.head;
 	pthread_mutex_unlock(&done_queue.mutex);
@@ -829,63 +831,63 @@ aio_poll_queues(void)
 #endif
 }
 
-aio_result_t *
-aio_poll_done(void)
+squidaio_result_t *
+squidaio_poll_done(void)
 {
-    aio_request_t *request;
-    aio_result_t *resultp;
+    squidaio_request_t *request;
+    squidaio_result_t *resultp;
     int cancelled;
     int polled = 0;
 
   AIO_REPOLL:
     request = done_requests.head;
     if (request == NULL && !polled) {
-	aio_poll_queues();
+	squidaio_poll_queues();
 	polled = 1;
 	request = done_requests.head;
     }
     if (!request) {
 	return NULL;
     }
-    debug(41, 9) ("aio_poll_done: %p type=%d result=%p\n",
+    debug(41, 9) ("squidaio_poll_done: %p type=%d result=%p\n",
 	request, request->request_type, request->resultp);
     done_requests.head = request->next;
     if (!done_requests.head)
 	done_requests.tailp = &done_requests.head;
     resultp = request->resultp;
     cancelled = request->cancelled;
-    aio_debug(request);
+    squidaio_debug(request);
     debug(43, 5) ("DONE: %d -> %d\n", request->ret, request->err);
-    aio_cleanup_request(request);
+    squidaio_cleanup_request(request);
     if (cancelled)
 	goto AIO_REPOLL;
     return resultp;
-}				/* aio_poll_done */
+}				/* squidaio_poll_done */
 
 int
-aio_operations_pending(void)
+squidaio_operations_pending(void)
 {
     return request_queue_len + (done_requests.head ? 1 : 0);
 }
 
 int
-aio_sync(void)
+squidaio_sync(void)
 {
     /* XXX This might take a while if the queue is large.. */
     do {
-	aio_poll_queues();
+	squidaio_poll_queues();
     } while (request_queue_len > 0);
-    return aio_operations_pending();
+    return squidaio_operations_pending();
 }
 
 int
-aio_get_queue_len(void)
+squidaio_get_queue_len(void)
 {
     return request_queue_len;
 }
 
 static void
-aio_debug(aio_request_t * request)
+squidaio_debug(squidaio_request_t * request)
 {
     switch (request->request_type) {
     case _AIO_OP_OPEN:
@@ -1,6 +1,6 @@
 
 /*
- * $Id: async_io.cc,v 1.8 2001/01/12 00:37:32 wessels Exp $
+ * $Id: async_io.cc,v 1.9 2001/08/20 06:55:31 hno Exp $
  *
  * DEBUG: section 32    Asynchronous Disk I/O
  * AUTHOR: Pete Bentley <pete@demon.net>
@@ -46,19 +46,19 @@
 #define _AIO_OPENDIR	5
 #define _AIO_STAT	6
 
-typedef struct aio_ctrl_t {
-    struct aio_ctrl_t *next;
+typedef struct squidaio_ctrl_t {
+    struct squidaio_ctrl_t *next;
     int fd;
     int operation;
     AIOCB *done_handler;
     void *done_handler_data;
-    aio_result_t result;
+    squidaio_result_t result;
     char *bufp;
     FREE *free_func;
     dlink_node node;
-} aio_ctrl_t;
+} squidaio_ctrl_t;
 
-struct {
+static struct {
     int open;
     int close;
     int cancel;
@@ -67,17 +67,17 @@ struct {
     int stat;
     int unlink;
     int check_callback;
-} aio_counts;
+} squidaio_counts;
 
-typedef struct aio_unlinkq_t {
+typedef struct squidaio_unlinkq_t {
     char *path;
-    struct aio_unlinkq_t *next;
-} aio_unlinkq_t;
+    struct squidaio_unlinkq_t *next;
+} squidaio_unlinkq_t;
 
 static dlink_list used_list;
 static int initialised = 0;
 static OBJH aioStats;
-static MemPool *aio_ctrl_pool;
+static MemPool *squidaio_ctrl_pool;
 static void aioFDWasClosed(int fd);
 
 static void
@@ -92,8 +92,8 @@ aioInit(void)
 {
     if (initialised)
 	return;
-    aio_ctrl_pool = memPoolCreate("aio_ctrl", sizeof(aio_ctrl_t));
-    cachemgrRegister("aio_counts", "Async IO Function Counters",
+    squidaio_ctrl_pool = memPoolCreate("aio_ctrl", sizeof(squidaio_ctrl_t));
+    cachemgrRegister("squidaio_counts", "Async IO Function Counters",
 	aioStats, 0, 1);
     initialised = 1;
     comm_quick_poll_required();
@@ -102,58 +102,58 @@ aioInit(void)
 void
 aioDone(void)
 {
-    memPoolDestroy(aio_ctrl_pool);
+    memPoolDestroy(squidaio_ctrl_pool);
     initialised = 0;
 }
 
 void
 aioOpen(const char *path, int oflag, mode_t mode, AIOCB * callback, void *callback_data)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
 
     assert(initialised);
-    aio_counts.open++;
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    squidaio_counts.open++;
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
     ctrlp->done_handler_data = callback_data;
     ctrlp->operation = _AIO_OPEN;
     cbdataLock(callback_data);
     ctrlp->result.data = ctrlp;
-    aio_open(path, oflag, mode, &ctrlp->result);
+    squidaio_open(path, oflag, mode, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
     return;
 }
 
 void
 aioClose(int fd)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
 
     assert(initialised);
-    aio_counts.close++;
+    squidaio_counts.close++;
     aioCancel(fd);
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = fd;
     ctrlp->done_handler = NULL;
     ctrlp->done_handler_data = NULL;
     ctrlp->operation = _AIO_CLOSE;
     ctrlp->result.data = ctrlp;
-    aio_close(fd, &ctrlp->result);
+    squidaio_close(fd, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
     return;
 }
 
 void
 aioCancel(int fd)
 {
-    aio_ctrl_t *curr;
+    squidaio_ctrl_t *curr;
     AIOCB *done_handler;
     void *their_data;
     dlink_node *m, *next;
 
     assert(initialised);
-    aio_counts.cancel++;
+    squidaio_counts.cancel++;
     for (m = used_list.head; m; m = next) {
 	while (m) {
 	    curr = m->data;
@@ -164,7 +164,7 @@ aioCancel(int fd)
 	if (m == NULL)
 	    break;
 
-	aio_cancel(&curr->result);
+	squidaio_cancel(&curr->result);
 
 	if ((done_handler = curr->done_handler)) {
 	    their_data = curr->done_handler_data;
@@ -177,20 +177,20 @@ aioCancel(int fd)
 	}
 	next = m->next;
 	dlinkDelete(m, &used_list);
-	memPoolFree(aio_ctrl_pool, curr);
+	memPoolFree(squidaio_ctrl_pool, curr);
     }
 }
 
 
 void
 aioWrite(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callback_data, FREE * free_func)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
     int seekmode;
 
     assert(initialised);
-    aio_counts.write++;
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    squidaio_counts.write++;
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = fd;
     ctrlp->done_handler = callback;
     ctrlp->done_handler_data = callback_data;
@@ -205,20 +205,20 @@ aioWrite(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callba
     }
     cbdataLock(callback_data);
     ctrlp->result.data = ctrlp;
-    aio_write(fd, bufp, len, offset, seekmode, &ctrlp->result);
+    squidaio_write(fd, bufp, len, offset, seekmode, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
 }				/* aioWrite */
 
 
 void
 aioRead(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callback_data)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
     int seekmode;
 
     assert(initialised);
-    aio_counts.read++;
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    squidaio_counts.read++;
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = fd;
     ctrlp->done_handler = callback;
     ctrlp->done_handler_data = callback_data;
@@ -231,80 +231,80 @@ aioRead(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callbac
     }
     cbdataLock(callback_data);
     ctrlp->result.data = ctrlp;
-    aio_read(fd, bufp, len, offset, seekmode, &ctrlp->result);
+    squidaio_read(fd, bufp, len, offset, seekmode, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
     return;
 }				/* aioRead */
 
 void
 aioStat(char *path, struct stat *sb, AIOCB * callback, void *callback_data)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
 
     assert(initialised);
-    aio_counts.stat++;
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    squidaio_counts.stat++;
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
     ctrlp->done_handler_data = callback_data;
     ctrlp->operation = _AIO_STAT;
     cbdataLock(callback_data);
     ctrlp->result.data = ctrlp;
-    aio_stat(path, sb, &ctrlp->result);
+    squidaio_stat(path, sb, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
     return;
 }				/* aioStat */
 
 void
 aioUnlink(const char *path, AIOCB * callback, void *callback_data)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
     assert(initialised);
-    aio_counts.unlink++;
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    squidaio_counts.unlink++;
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
     ctrlp->done_handler_data = callback_data;
     ctrlp->operation = _AIO_UNLINK;
     cbdataLock(callback_data);
     ctrlp->result.data = ctrlp;
-    aio_unlink(path, &ctrlp->result);
+    squidaio_unlink(path, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
 }				/* aioUnlink */
 
 void
 aioTruncate(const char *path, off_t length, AIOCB * callback, void *callback_data)
 {
-    aio_ctrl_t *ctrlp;
+    squidaio_ctrl_t *ctrlp;
     assert(initialised);
-    aio_counts.unlink++;
-    ctrlp = memPoolAlloc(aio_ctrl_pool);
+    squidaio_counts.unlink++;
+    ctrlp = memPoolAlloc(squidaio_ctrl_pool);
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
     ctrlp->done_handler_data = callback_data;
     ctrlp->operation = _AIO_TRUNCATE;
     cbdataLock(callback_data);
     ctrlp->result.data = ctrlp;
-    aio_truncate(path, length, &ctrlp->result);
+    squidaio_truncate(path, length, &ctrlp->result);
     dlinkAdd(ctrlp, &ctrlp->node, &used_list);
 }				/* aioTruncate */
 
 
 int
 aioCheckCallbacks(SwapDir * SD)
 {
-    aio_result_t *resultp;
-    aio_ctrl_t *ctrlp;
+    squidaio_result_t *resultp;
+    squidaio_ctrl_t *ctrlp;
     AIOCB *done_handler;
     void *their_data;
     int retval = 0;
 
     assert(initialised);
-    aio_counts.check_callback++;
+    squidaio_counts.check_callback++;
     for (;;) {
-	if ((resultp = aio_poll_done()) == NULL)
+	if ((resultp = squidaio_poll_done()) == NULL)
 	    break;
-	ctrlp = (aio_ctrl_t *) resultp->data;
+	ctrlp = (squidaio_ctrl_t *) resultp->data;
 	if (ctrlp == NULL)
 	    continue;		/* XXX Should not happen */
 	dlinkDelete(&ctrlp->node, &used_list);
@@ -324,7 +324,7 @@ aioCheckCallbacks(SwapDir * SD)
 	    ctrlp->free_func(ctrlp->bufp);
 	if (ctrlp->operation == _AIO_CLOSE)
 	    aioFDWasClosed(ctrlp->fd);
-	memPoolFree(aio_ctrl_pool, ctrlp);
+	memPoolFree(squidaio_ctrl_pool, ctrlp);
     }
     return retval;
 }
@@ -333,15 +333,15 @@ void
 aioStats(StoreEntry * sentry)
 {
     storeAppendPrintf(sentry, "ASYNC IO Counters:\n");
-    storeAppendPrintf(sentry, "open\t%d\n", aio_counts.open);
-    storeAppendPrintf(sentry, "close\t%d\n", aio_counts.close);
-    storeAppendPrintf(sentry, "cancel\t%d\n", aio_counts.cancel);
-    storeAppendPrintf(sentry, "write\t%d\n", aio_counts.write);
-    storeAppendPrintf(sentry, "read\t%d\n", aio_counts.read);
-    storeAppendPrintf(sentry, "stat\t%d\n", aio_counts.stat);
-    storeAppendPrintf(sentry, "unlink\t%d\n", aio_counts.unlink);
-    storeAppendPrintf(sentry, "check_callback\t%d\n", aio_counts.check_callback);
-    storeAppendPrintf(sentry, "queue\t%d\n", aio_get_queue_len());
+    storeAppendPrintf(sentry, "open\t%d\n", squidaio_counts.open);
+    storeAppendPrintf(sentry, "close\t%d\n", squidaio_counts.close);
+    storeAppendPrintf(sentry, "cancel\t%d\n", squidaio_counts.cancel);
+    storeAppendPrintf(sentry, "write\t%d\n", squidaio_counts.write);
+    storeAppendPrintf(sentry, "read\t%d\n", squidaio_counts.read);
+    storeAppendPrintf(sentry, "stat\t%d\n", squidaio_counts.stat);
+    storeAppendPrintf(sentry, "unlink\t%d\n", squidaio_counts.unlink);
+    storeAppendPrintf(sentry, "check_callback\t%d\n", squidaio_counts.check_callback);
+    storeAppendPrintf(sentry, "queue\t%d\n", squidaio_get_queue_len());
 }
 
 /* Flush all pending I/O */
@@ -354,12 +354,12 @@ aioSync(SwapDir * SD)
     debug(32, 1) ("aioSync: flushing pending I/O operations\n");
     do {
 	aioCheckCallbacks(SD);
-    } while (aio_sync());
+    } while (squidaio_sync());
     debug(32, 1) ("aioSync: done\n");
 }
 
 int
 aioQueueSize(void)
 {
-    return memPoolInUseCount(aio_ctrl_pool);
+    return memPoolInUseCount(squidaio_ctrl_pool);
 }
@@ -25,30 +25,30 @@
 #define ASYNC_WRITE 0
 #define ASYNC_READ 1
 
-struct _aio_result_t {
+struct _squidaio_result_t {
     int aio_return;
     int aio_errno;
     void *_data;		/* Internal housekeeping */
     void *data;			/* Available to the caller */
 };
 
-typedef struct _aio_result_t aio_result_t;
+typedef struct _squidaio_result_t squidaio_result_t;
 
 typedef void AIOCB(int fd, void *, int aio_return, int aio_errno);
 
-int aio_cancel(aio_result_t *);
-int aio_open(const char *, int, mode_t, aio_result_t *);
-int aio_read(int, char *, int, off_t, int, aio_result_t *);
-int aio_write(int, char *, int, off_t, int, aio_result_t *);
-int aio_close(int, aio_result_t *);
-int aio_stat(const char *, struct stat *, aio_result_t *);
-int aio_unlink(const char *, aio_result_t *);
-int aio_truncate(const char *, off_t length, aio_result_t *);
-int aio_opendir(const char *, aio_result_t *);
-aio_result_t *aio_poll_done(void);
-int aio_operations_pending(void);
-int aio_sync(void);
-int aio_get_queue_len(void);
+int squidaio_cancel(squidaio_result_t *);
+int squidaio_open(const char *, int, mode_t, squidaio_result_t *);
+int squidaio_read(int, char *, int, off_t, int, squidaio_result_t *);
+int squidaio_write(int, char *, int, off_t, int, squidaio_result_t *);
+int squidaio_close(int, squidaio_result_t *);
+int squidaio_stat(const char *, struct stat *, squidaio_result_t *);
+int squidaio_unlink(const char *, squidaio_result_t *);
+int squidaio_truncate(const char *, off_t length, squidaio_result_t *);
+int squidaio_opendir(const char *, squidaio_result_t *);
+squidaio_result_t *squidaio_poll_done(void);
+int squidaio_operations_pending(void);
+int squidaio_sync(void);
+int squidaio_get_queue_len(void);
 
 void aioInit(void);
 void aioDone(void);
@@ -64,15 +64,15 @@ int aioCheckCallbacks(SwapDir *);
 void aioSync(SwapDir *);
 int aioQueueSize(void);
 
-struct _aioinfo_t {
+struct _squidaioinfo_t {
     int swaplog_fd;
     int l1;
     int l2;
     fileMap *map;
     int suggest;
 };
 
-struct _aiostate_t {
+struct _squidaiostate_t {
     int fd;
     struct {
 	unsigned int close_request:1;
@@ -103,13 +103,13 @@ struct _queued_read {
     void *callback_data;
 };
 
-typedef struct _aioinfo_t aioinfo_t;
-typedef struct _aiostate_t aiostate_t;
+typedef struct _squidaioinfo_t squidaioinfo_t;
+typedef struct _squidaiostate_t squidaiostate_t;
 
-/* The aio_state memory pools */
-extern MemPool *aio_state_pool;
-extern MemPool *aio_qread_pool;
-extern MemPool *aio_qwrite_pool;
+/* The squidaio_state memory pools */
+extern MemPool *squidaio_state_pool;
+extern MemPool *aufs_qread_pool;
+extern MemPool *aufs_qwrite_pool;
 
 extern void storeAufsDirMapBitReset(SwapDir *, sfileno);
 extern int storeAufsDirMapBitAllocate(SwapDir *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_aufs.cc,v 1.36 2001/07/11 22:29:50 hno Exp $
+ * $Id: store_dir_aufs.cc,v 1.37 2001/08/20 06:55:31 hno Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -66,9 +66,9 @@ struct _RebuildState {
 
 static int n_asyncufs_dirs = 0;
 static int *asyncufs_dir_index = NULL;
-MemPool *aio_state_pool = NULL;
-MemPool *aio_qread_pool = NULL;
-MemPool *aio_qwrite_pool = NULL;
+MemPool *squidaio_state_pool = NULL;
+MemPool *aufs_qread_pool = NULL;
+MemPool *aufs_qwrite_pool = NULL;
 static int asyncufs_initialised = 0;
 
 static char *storeAufsDirSwapSubDir(SwapDir *, int subdirn);
@@ -132,26 +132,26 @@ static int
 storeAufsDirMapBitTest(SwapDir * SD, int fn)
 {
     sfileno filn = fn;
-    aioinfo_t *aioinfo;
-    aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo;
+    aioinfo = (squidaioinfo_t *) SD->fsdata;
     return file_map_bit_test(aioinfo->map, filn);
 }
 
 static void
 storeAufsDirMapBitSet(SwapDir * SD, int fn)
 {
     sfileno filn = fn;
-    aioinfo_t *aioinfo;
-    aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo;
+    aioinfo = (squidaioinfo_t *) SD->fsdata;
     file_map_bit_set(aioinfo->map, filn);
 }
 
 void
 storeAufsDirMapBitReset(SwapDir * SD, int fn)
 {
     sfileno filn = fn;
-    aioinfo_t *aioinfo;
-    aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo;
+    aioinfo = (squidaioinfo_t *) SD->fsdata;
     /*
      * We have to test the bit before calling file_map_bit_reset.
      * file_map_bit_reset doesn't do bounds checking.  It assumes
@@ -166,7 +166,7 @@ storeAufsDirMapBitReset(SwapDir * SD, int fn)
 int
 storeAufsDirMapBitAllocate(SwapDir * SD)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) SD->fsdata;
     int fn;
     fn = file_map_allocate(aioinfo->map, aioinfo->suggest);
     file_map_bit_set(aioinfo->map, fn);
@@ -183,7 +183,7 @@ storeAufsDirMapBitAllocate(SwapDir * SD)
 static void
 storeAufsDirInitBitmap(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
 
     if (aioinfo->map == NULL) {
 	/* First time */
@@ -198,7 +198,7 @@ storeAufsDirInitBitmap(SwapDir * sd)
 static char *
 storeAufsDirSwapSubDir(SwapDir * sd, int subdirn)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
 
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
     assert(0 <= subdirn && subdirn < aioinfo->l1);
@@ -251,7 +251,7 @@ storeAufsDirVerifyDirectory(const char *path)
 static int
 storeAufsDirVerifyCacheDirs(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     int j;
     const char *path = sd->path;
 
@@ -268,7 +268,7 @@ storeAufsDirVerifyCacheDirs(SwapDir * sd)
 static void
 storeAufsDirCreateSwapSubDirs(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     int i, k;
     int should_exist;
     LOCAL_ARRAY(char, name, MAXPATHLEN);
@@ -319,7 +319,7 @@ storeAufsDirSwapLogFile(SwapDir * sd, const char *ext)
 static void
 storeAufsDirOpenSwapLog(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     char *path;
     int fd;
     path = storeAufsDirSwapLogFile(sd, NULL);
@@ -339,7 +339,7 @@ storeAufsDirOpenSwapLog(SwapDir * sd)
 static void
 storeAufsDirCloseSwapLog(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     if (aioinfo->swaplog_fd < 0)	/* not open */
 	return;
     file_close(aioinfo->swaplog_fd);
@@ -693,7 +693,7 @@ static int
 storeAufsDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 {
     SwapDir *SD = rb->sd;
-    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) SD->fsdata;
     int fd = -1;
     int used = 0;
     int dirs_opened = 0;
@@ -860,7 +860,7 @@ storeAufsDirRebuild(SwapDir * sd)
 static void
 storeAufsDirCloseTmpSwapLog(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeAufsDirSwapLogFile(sd, NULL));
     char *new_path = xstrdup(storeAufsDirSwapLogFile(sd, ".new"));
     int fd;
@@ -888,7 +888,7 @@ storeAufsDirCloseTmpSwapLog(SwapDir * sd)
 static FILE *
 storeAufsDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeAufsDirSwapLogFile(sd, NULL));
     char *clean_path = xstrdup(storeAufsDirSwapLogFile(sd, ".last-clean"));
     char *new_path = xstrdup(storeAufsDirSwapLogFile(sd, ".new"));
@@ -1105,7 +1105,7 @@ storeSwapLogDataFree(void *s)
 static void
 storeAufsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
     storeSwapLogData *s = memAllocate(MEM_SWAP_LOG_DATA);
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
@@ -1160,11 +1160,11 @@ storeAufsDirClean(int swap_index)
     int N0, N1, N2;
     int D0, D1, D2;
     SwapDir *SD;
-    aioinfo_t *aioinfo;
+    squidaioinfo_t *aioinfo;
     N0 = n_asyncufs_dirs;
     D0 = asyncufs_dir_index[swap_index % N0];
     SD = &Config.cacheSwap.swapDirs[D0];
-    aioinfo = (aioinfo_t *) SD->fsdata;
+    aioinfo = (squidaioinfo_t *) SD->fsdata;
     N1 = aioinfo->l1;
     D1 = (swap_index / N0) % N1;
     N2 = aioinfo->l2;
@@ -1232,7 +1232,7 @@ storeAufsDirCleanEvent(void *unused)
     assert(n_asyncufs_dirs);
     if (NULL == asyncufs_dir_index) {
 	SwapDir *sd;
-	aioinfo_t *aioinfo;
+	squidaioinfo_t *aioinfo;
 	/*
 	 * Initialize the little array that translates AUFS cache_dir
 	 * number into the Config.cacheSwap.swapDirs array index.
@@ -1243,7 +1243,7 @@ storeAufsDirCleanEvent(void *unused)
 	    if (!storeAufsDirIs(sd))
 		continue;
 	    asyncufs_dir_index[n++] = i;
-	    aioinfo = (aioinfo_t *) sd->fsdata;
+	    aioinfo = (squidaioinfo_t *) sd->fsdata;
 	    j += (aioinfo->l1 * aioinfo->l2);
 	}
 	assert(n == n_asyncufs_dirs);
@@ -1280,9 +1280,9 @@ storeAufsFilenoBelongsHere(int fn, int F0, int F1, int F2)
     int D1, D2;
     int L1, L2;
     int filn = fn;
-    aioinfo_t *aioinfo;
+    squidaioinfo_t *aioinfo;
     assert(F0 < Config.cacheSwap.n_configured);
-    aioinfo = (aioinfo_t *) Config.cacheSwap.swapDirs[F0].fsdata;
+    aioinfo = (squidaioinfo_t *) Config.cacheSwap.swapDirs[F0].fsdata;
     L1 = aioinfo->l1;
     L2 = aioinfo->l2;
     D1 = ((filn / L2) / L2) % L1;
@@ -1297,7 +1297,7 @@ storeAufsFilenoBelongsHere(int fn, int F0, int F1, int F2)
 int
 storeAufsDirValidFileno(SwapDir * SD, sfileno filn, int flag)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) SD->fsdata;
     if (filn < 0)
 	return 0;
     /*
@@ -1457,7 +1457,7 @@ storeAufsDirReplRemove(StoreEntry * e)
 void
 storeAufsDirStats(SwapDir * SD, StoreEntry * sentry)
 {
-    aioinfo_t *aioinfo = SD->fsdata;
+    squidaioinfo_t *aioinfo = SD->fsdata;
     int totl_kb = 0;
     int free_kb = 0;
     int totl_in = 0;
@@ -1543,7 +1543,7 @@ storeAufsDirReconfigure(SwapDir * sd, int index, char *path)
 void
 storeAufsDirDump(StoreEntry * entry, SwapDir * s)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) s->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) s->fsdata;
     storeAppendPrintf(entry, " %d %d %d",
 	s->max_size >> 10,
 	aioinfo->l1,
@@ -1557,7 +1557,7 @@ storeAufsDirDump(StoreEntry * entry, SwapDir * s)
 static void
 storeAufsDirFree(SwapDir * s)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *) s->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) s->fsdata;
     if (aioinfo->swaplog_fd > -1) {
 	file_close(aioinfo->swaplog_fd);
 	aioinfo->swaplog_fd = -1;
@@ -1571,7 +1571,7 @@ char *
 storeAufsDirFullPath(SwapDir * SD, sfileno filn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
-    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
+    squidaioinfo_t *aioinfo = (squidaioinfo_t *) SD->fsdata;
     int L1 = aioinfo->l1;
     int L2 = aioinfo->l2;
     if (!fullpath)
@@ -1626,7 +1626,7 @@ storeAufsDirParse(SwapDir * sd, int index, char *path)
     int size;
     int l1;
     int l2;
-    aioinfo_t *aioinfo;
+    squidaioinfo_t *aioinfo;
 
     i = GetInteger();
     size = i << 10;		/* Mbytes to kbytes */
@@ -1641,9 +1641,9 @@ storeAufsDirParse(SwapDir * sd, int index, char *path)
     if (l2 <= 0)
 	fatal("storeAufsDirParse: invalid level 2 directories value");
 
-    aioinfo = xmalloc(sizeof(aioinfo_t));
+    aioinfo = xmalloc(sizeof(squidaioinfo_t));
     if (aioinfo == NULL)
-	fatal("storeAufsDirParse: couldn't xmalloc() aioinfo_t!\n");
+	fatal("storeAufsDirParse: couldn't xmalloc() squidaioinfo_t!\n");
 
     sd->index = index;
     sd->path = xstrdup(path);
@@ -1692,9 +1692,9 @@ static void
 storeAufsDirDone(void)
 {
     aioDone();
-    memPoolDestroy(aio_state_pool);
-    memPoolDestroy(aio_qread_pool);
-    memPoolDestroy(aio_qwrite_pool);
+    memPoolDestroy(squidaio_state_pool);
+    memPoolDestroy(aufs_qread_pool);
+    memPoolDestroy(aufs_qwrite_pool);
     asyncufs_initialised = 0;
 }
 
@@ -1705,10 +1705,10 @@ storeFsSetup_aufs(storefs_entry_t * storefs)
     storefs->parsefunc = storeAufsDirParse;
     storefs->reconfigurefunc = storeAufsDirReconfigure;
     storefs->donefunc = storeAufsDirDone;
-    aio_state_pool = memPoolCreate("AUFS IO State data", sizeof(aiostate_t));
-    aio_qread_pool = memPoolCreate("AUFS Queued read data",
+    squidaio_state_pool = memPoolCreate("AUFS IO State data", sizeof(squidaiostate_t));
+    aufs_qread_pool = memPoolCreate("AUFS Queued read data",
 	sizeof(queued_read));
-    aio_qwrite_pool = memPoolCreate("AUFS Queued write data",
+    aufs_qwrite_pool = memPoolCreate("AUFS Queued write data",
 	sizeof(queued_write));
 
     asyncufs_initialised = 1;
@@ -55,9 +55,9 @@ storeAufsOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
 #endif
     CBDATA_INIT_TYPE_FREECB(storeIOState, storeAufsIOFreeEntry);
     sio = cbdataAlloc(storeIOState);
-    sio->fsstate = memPoolAlloc(aio_state_pool);
-    ((aiostate_t *) (sio->fsstate))->fd = -1;
-    ((aiostate_t *) (sio->fsstate))->flags.opening = 1;
+    sio->fsstate = memPoolAlloc(squidaio_state_pool);
+    ((squidaiostate_t *) (sio->fsstate))->fd = -1;
+    ((squidaiostate_t *) (sio->fsstate))->flags.opening = 1;
     sio->swap_filen = f;
     sio->swap_dirn = SD->index;
     sio->mode = O_RDONLY;
@@ -110,9 +110,9 @@ storeAufsCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * c
 #endif
     CBDATA_INIT_TYPE_FREECB(storeIOState, storeAufsIOFreeEntry);
     sio = cbdataAlloc(storeIOState);
-    sio->fsstate = memPoolAlloc(aio_state_pool);
-    ((aiostate_t *) (sio->fsstate))->fd = -1;
-    ((aiostate_t *) (sio->fsstate))->flags.opening = 1;
+    sio->fsstate = memPoolAlloc(squidaio_state_pool);
+    ((squidaiostate_t *) (sio->fsstate))->fd = -1;
+    ((squidaiostate_t *) (sio->fsstate))->flags.opening = 1;
     sio->swap_filen = filn;
     sio->swap_dirn = dirn;
     sio->mode = O_WRONLY | O_BINARY;
@@ -140,7 +140,7 @@ storeAufsCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * c
 void
 storeAufsClose(SwapDir * SD, storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsClose: dirno %d, fileno %08X, FD %d\n",
 	sio->swap_dirn, sio->swap_filen, aiostate->fd);
     if (storeAufsSomethingPending(sio)) {
@@ -155,7 +155,7 @@ storeAufsClose(SwapDir * SD, storeIOState * sio)
 void
 storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
 {
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     assert(sio->read.callback == NULL);
     assert(sio->read.callback_data == NULL);
     assert(!aiostate->flags.reading);
@@ -164,7 +164,7 @@ storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t of
 	debug(78, 3) ("storeAufsRead: queueing read because FD < 0\n");
 	assert(aiostate->flags.opening);
 	assert(aiostate->pending_reads == NULL);
-	q = memPoolAlloc(aio_qread_pool);
+	q = memPoolAlloc(aufs_qread_pool);
 	q->buf = buf;
 	q->size = size;
 	q->offset = offset;
@@ -193,14 +193,14 @@ storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t of
 void
 storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
 {
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsWrite: dirno %d, fileno %08X, FD %d\n",
 	sio->swap_dirn, sio->swap_filen, aiostate->fd);
     if (aiostate->fd < 0) {
 	/* disk file not opened yet */
 	struct _queued_write *q;
 	assert(aiostate->flags.opening);
-	q = memPoolAlloc(aio_qwrite_pool);
+	q = memPoolAlloc(aufs_qwrite_pool);
 	q->buf = buf;
 	q->size = size;
 	q->offset = offset;
@@ -212,7 +212,7 @@ storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t o
     if (aiostate->flags.writing) {
 	struct _queued_write *q;
 	debug(78, 3) ("storeAufsWrite: queuing write\n");
-	q = memPoolAlloc(aio_qwrite_pool);
+	q = memPoolAlloc(aufs_qwrite_pool);
 	q->buf = buf;
 	q->size = size;
 	q->offset = offset;
@@ -244,36 +244,36 @@ storeAufsUnlink(SwapDir * SD, StoreEntry * e)
 static int
 storeAufsKickWriteQueue(storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     struct _queued_write *q = linklistShift(&aiostate->pending_writes);
     if (NULL == q)
 	return 0;
     debug(78, 3) ("storeAufsKickWriteQueue: writing queued chunk of %d bytes\n",
 	q->size);
     storeAufsWrite(INDEXSD(sio->swap_dirn), sio, q->buf, q->size, q->offset, q->free_func);
-    memPoolFree(aio_qwrite_pool, q);
+    memPoolFree(aufs_qwrite_pool, q);
     return 1;
 }
 
 static int
 storeAufsKickReadQueue(storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     struct _queued_read *q = linklistShift(&(aiostate->pending_reads));
     if (NULL == q)
 	return 0;
     debug(78, 3) ("storeAufsKickReadQueue: reading queued request of %d bytes\n",
 	q->size);
     storeAufsRead(INDEXSD(sio->swap_dirn), sio, q->buf, q->size, q->offset, q->callback, q->callback_data);
-    memPoolFree(aio_qread_pool, q);
+    memPoolFree(aufs_qread_pool, q);
     return 1;
 }
 
 static void
 storeAufsOpenDone(int unused, void *my_data, int fd, int errflag)
 {
     storeIOState *sio = my_data;
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsOpenDone: FD %d, errflag %d\n", fd, errflag);
     Opening_FD--;
     aiostate->flags.opening = 0;
@@ -303,7 +303,7 @@ storeAufsReadDone(int fd, int errflag, size_t len, void *my_data)
 #endif
 {
     storeIOState *sio = my_data;
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     STRCB *callback = sio->read.callback;
     void *their_data = sio->read.callback_data;
     ssize_t rlen;
@@ -351,7 +351,7 @@ storeAufsWriteDone(int fd, int errflag, size_t len, void *my_data)
 {
     static int loop_detect = 0;
     storeIOState *sio = my_data;
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsWriteDone: dirno %d, fileno %08X, FD %d, len %d, err=%d\n",
 	sio->swap_dirn, sio->swap_filen, fd, len, errflag);
 #if ASYNC_WRITE
@@ -394,7 +394,7 @@ storeAufsIOCallback(storeIOState * sio, int errflag)
 {
     STIOCB *callback = sio->callback;
     void *their_data = sio->callback_data;
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     int fd = aiostate->fd;
     debug(78, 3) ("storeAufsIOCallback: errflag=%d\n", errflag);
     sio->callback = NULL;
@@ -420,7 +420,7 @@ storeAufsIOCallback(storeIOState * sio, int errflag)
 static int
 storeAufsSomethingPending(storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
+    squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
     if (aiostate->flags.reading)
 	return 1;
     if (aiostate->flags.writing)
@@ -441,5 +441,5 @@ storeAufsSomethingPending(storeIOState * sio)
 static void
 storeAufsIOFreeEntry(void *sio)
 {
-    memPoolFree(aio_state_pool, ((storeIOState *) sio)->fsstate);
+    memPoolFree(squidaio_state_pool, ((storeIOState *) sio)->fsstate);
 }