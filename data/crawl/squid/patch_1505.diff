@@ -21,6 +21,61 @@ Changes to Squid-2.1 ():
 	  potentially causing under-utilized cache digests
 	- Maintain refreshCheck statistics on per-protocol basis so we
 	  can tell why ICP or Digests return too many misses, etc.
+	- Fixed delay_pools.c class2/class3 typo (Simon Woods).
+	- Changed squid.conf's default access controls to deny all
+	  HTTP requests.  Admins must write ACL rules to specifically
+	  allow their local clients.
+	- Patched French error messages (Mathias HERBERTS).
+	- NextStep porting fixes by Mike Laster:
+		- use xstrdup() in cf_gen.c
+		- check for putenv() in configure
+		- #define S_ISDIR macro
+	- Added --disable-poll configure option (Henrik Nordstrom).
+	- Fixed internal URL hostname case bugs (Henrik Nordstrom).
+	- Patched ftp.c so we never cache autenticated FTP requests
+	  (Henrik Nordstrom).
+	- Fixed FTP authentication. We tried to unescape authentication
+	  given by basic authentication which is not URL escaped
+	  (Henrik Nordstrom).
+	- Fixed HTTP version for common logfile format (Henrik Nordstrom).
+	- Added 'redirect_rewrites_host_header' option to disable rewriting
+	  of Host header for redirector responses (Henrik Nordstrom).
+	- Allow semi-customized error message signatures (Henrik Nordstrom).
+	- Fixed bug with errors for unsupported requests (Henrik Nordstrom).
+	- Fixed handling of blank lines in ACL input files (Henrik
+	  Nordstrom).
+	- Changed proxy_auth ACL type to consist of a list of valid
+	  users. REQUIRED == any (same as ident ACL). ACL type user
+	  changed to ident since this is what it really is.
+	  (Henrik Nordstrom).
+	- Fixed long URL bugs; make sure 'log_uri' never exceeds
+	  MAX_URL bytes.
+	- Allow comments in external ACL files (Gerhard Wiesinger).
+	- Added 'range_offset_limit' configuration option.  Requests
+	  with ranges that start after this value will be passed
+	  on unmodified, and Squid will not cache the response
+	  (Henrik Nordstrom).
+	- Added Client HTTP Hit byte counters to 'counters' output
+	  (Douglas Swarin).
+	- Got Squid to compile with --enable-async-io on FreeBSD.
+	- Fixed infinite loop bug for cachemgr 'config' option.
+	- Fixed cachability bugs for replies with Pragma: no-cache.
+	- Made content-type multipart/x-mixed-replace uncachable.
+	- Y2K fix for parsing dates in "Wed Jun  9 01:29:59 1993 GMT"
+	  format (Richard Kettlewell).
+	- Fixed passing -s option to dnsserver processes (Alvaro Jose
+	  Fernandez Lago).
+	- Changed proxy_auth to work on internal objects and when in
+	  accelerator mode. (Henrik Nordstrom)
+	- Added login=user:password option to cache_peer directive to
+	  be used from a dial-up cache where the parent requires proxy
+	  authentication. (Henrik Nordstrom)
+	- If you want to "auto-login", then use a URL on the form
+	  http://username:password@server/.... Squid now picks this up
+	  when going direct, and turns it into basic WWW
+	  authentication.  It is also possible to do automatic login to
+	  certain servers by using a redirector to add the needed
+	  authentication information.  (Henrik Nordstrom)
 
 Changes to Squid-2.0 (October 2, 1998):
 
@@ -1,5 +1,8 @@
 Our Todo List
 
+()	dont re-sibling requests which came from a sibling
+()
+
 (1) is high priority, (5) is low priority
 (**) Means we need this for the real 1.2 release
 ==============================================================================
@@ -64,17 +64,15 @@ ac_help="$ac_help
                           is broken on some platforms.  If you think you are
                           smarter than the configure script, you may enable
                           poll with this option.
-"
+  --disable-poll          Disable the use of poll()."
 ac_help="$ac_help
   --disable-http-violations
                           This allows you to remove code which is known to
-                          violate the HTTP protocol specification.
-"
+                          violate the HTTP protocol specification."
 ac_help="$ac_help
   --enable-ipf-transparent
                           Enable Transparent Proxy support for systems
-                          using IP-Filter network address redirection.
-"
+                          using IP-Filter network address redirection."
 
 # Initialize some variables set by options.
 # The variables have the same names as the options, with
@@ -583,7 +581,7 @@ fi
 
 
 
-# From configure.in Revision: 1.158 
+# From configure.in Revision: 1.159.2.7 
 ac_aux_dir=
 for ac_dir in cfgaux $srcdir/cfgaux; do
   if test -f $ac_dir/install-sh; then
@@ -611,7 +609,7 @@ else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:615: checking host system type" >&5
+echo "configure:613: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -679,7 +677,7 @@ PRESET_CFLAGS="$CFLAGS"
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:683: checking for $ac_word" >&5
+echo "configure:681: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -708,7 +706,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:712: checking for $ac_word" >&5
+echo "configure:710: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -756,7 +754,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:760: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:758: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -766,11 +764,11 @@ ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext <<EOF
-#line 770 "configure"
+#line 768 "configure"
 #include "confdefs.h"
 main(){return(0);}
 EOF
-if { (eval echo configure:774: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:772: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -790,12 +788,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:794: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:792: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:799: checking whether we are using GNU C" >&5
+echo "configure:797: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -804,7 +802,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:808: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:806: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -819,7 +817,7 @@ if test $ac_cv_prog_gcc = yes; then
   ac_save_CFLAGS="$CFLAGS"
   CFLAGS=
   echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:823: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:821: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1085,13 +1083,23 @@ if test "${enable_async_io+set}" = set; then
   enableval="$enable_async_io"
    if test "$enableval" = "yes" ; then
     echo "Async I/O enabled"
+    async_io=yes
     cat >> confdefs.h <<\EOF
 #define USE_ASYNC_IO 1
 EOF
 
     ASYNC_OBJS='$(ASYNC_OBJS)'
     SQUID_PTHREAD_LIB='$(PTHREADLIB)'
     CFLAGS="$CFLAGS -D_REENTRANT"
+    case "$host" in
+    i386-unknown-freebsd*)
+    	if test "$GCC" = "yes" ; then
+	    if test -z "$PRESET_LDFLAGS"; then
+		LDFLAGS="$LDFLAGS -pthread"
+	    fi
+	fi
+	;;
+    esac
   fi
 
 fi
@@ -1319,10 +1327,17 @@ fi
 # Check whether --enable-poll or --disable-poll was given.
 if test "${enable_poll+set}" = set; then
   enableval="$enable_poll"
-   if test "$enableval" = "yes" ; then
+   
+  case "$enableval" in
+  yes)
     echo "Forcing poll() to be enabled"
     ac_cv_func_poll='yes'
-  fi
+    ;;
+  no)
+    echo "Forcing poll() to be disabled"
+    ac_cv_func_poll='no'
+    ;;
+  esac
 
 fi
 
@@ -1371,10 +1386,17 @@ case "$host" in
 		ac_cv_prog_CC="$CC"
 	fi
 	;;
+    *-hp-hpux*)
+	if test "$ac_cv_prog_CC" = "cc" ; then
+		echo "adding '-Ae' to cc args for $host"
+		CC="cc -Ae";
+		ac_cv_prog_CC="$CC"
+	fi
+	;;
 esac
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1378: checking how to run the C preprocessor" >&5
+echo "configure:1400: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -1389,13 +1411,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1393 "configure"
+#line 1415 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1399: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1421: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1406,13 +1428,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1410 "configure"
+#line 1432 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1416: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1438: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1445,7 +1467,7 @@ echo "$ac_t""$CPP" 1>&6
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:1449: checking for a BSD compatible install" >&5
+echo "configure:1471: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1497,7 +1519,7 @@ test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1501: checking for $ac_word" >&5
+echo "configure:1523: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1524,7 +1546,7 @@ else
 fi
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:1528: checking whether ln -s works" >&5
+echo "configure:1550: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1547,7 +1569,7 @@ fi
 # Extract the first word of "sh", so it can be a program name with args.
 set dummy sh; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1551: checking for $ac_word" >&5
+echo "configure:1573: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SH'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1579,7 +1601,7 @@ fi
 # Extract the first word of "false", so it can be a program name with args.
 set dummy false; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1583: checking for $ac_word" >&5
+echo "configure:1605: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_FALSE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1611,7 +1633,7 @@ fi
 # Extract the first word of "true", so it can be a program name with args.
 set dummy true; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1615: checking for $ac_word" >&5
+echo "configure:1637: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_TRUE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1643,7 +1665,7 @@ fi
 # Extract the first word of "rm", so it can be a program name with args.
 set dummy rm; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1647: checking for $ac_word" >&5
+echo "configure:1669: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_RM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1675,7 +1697,7 @@ fi
 # Extract the first word of "mv", so it can be a program name with args.
 set dummy mv; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1679: checking for $ac_word" >&5
+echo "configure:1701: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MV'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1707,7 +1729,7 @@ fi
 # Extract the first word of "mkdir", so it can be a program name with args.
 set dummy mkdir; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1711: checking for $ac_word" >&5
+echo "configure:1733: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MKDIR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1739,7 +1761,7 @@ fi
 # Extract the first word of "ln", so it can be a program name with args.
 set dummy ln; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1743: checking for $ac_word" >&5
+echo "configure:1765: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LN'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1771,7 +1793,7 @@ fi
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1775: checking for $ac_word" >&5
+echo "configure:1797: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1803,7 +1825,7 @@ fi
 # Extract the first word of "makedepend", so it can be a program name with args.
 set dummy makedepend; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1807: checking for $ac_word" >&5
+echo "configure:1829: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPEND'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1835,7 +1857,7 @@ fi
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1839: checking for $ac_word" >&5
+echo "configure:1861: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1885,20 +1907,20 @@ for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:1889: checking for $ac_hdr that defines DIR" >&5
+echo "configure:1911: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1894 "configure"
+#line 1916 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
 int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:1902: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1924: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -1923,15 +1945,15 @@ done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:1927: checking for opendir in -ldir" >&5
+echo "configure:1949: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1935 "configure"
+#line 1957 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1942,7 +1964,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:1968: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1964,15 +1986,15 @@ fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:1968: checking for opendir in -lx" >&5
+echo "configure:1990: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1976 "configure"
+#line 1998 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1983,7 +2005,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2006,20 +2028,20 @@ fi
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:2010: checking for ANSI C header files" >&5
+echo "configure:2032: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2015 "configure"
+#line 2037 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2023: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2045: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2036,7 +2058,7 @@ rm -f conftest*
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2040 "configure"
+#line 2062 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -2054,7 +2076,7 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2058 "configure"
+#line 2080 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -2075,7 +2097,7 @@ if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 2079 "configure"
+#line 2101 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -2086,7 +2108,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:2090: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2112: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -2141,6 +2163,7 @@ for ac_hdr in \
 	pwd.h \
 	regex.h \
 	resolv.h \
+	sched.h \
 	signal.h \
 	stdarg.h \
 	stddef.h \
@@ -2170,17 +2193,17 @@ for ac_hdr in \
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2174: checking for $ac_hdr" >&5
+echo "configure:2197: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2179 "configure"
+#line 2202 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2184: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2207: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2208,12 +2231,12 @@ done
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:2212: checking for working const" >&5
+echo "configure:2235: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2217 "configure"
+#line 2240 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -2262,7 +2285,7 @@ ccp = (char const *const *) p;
 
 ; return 0; }
 EOF
-if { (eval echo configure:2266: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2289: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -2283,14 +2306,14 @@ EOF
 fi
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:2287: checking whether byte ordering is bigendian" >&5
+echo "configure:2310: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 2294 "configure"
+#line 2317 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2301,11 +2324,11 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2305: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2328: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 2309 "configure"
+#line 2332 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2316,7 +2339,7 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2320: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2343: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
@@ -2336,7 +2359,7 @@ if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2340 "configure"
+#line 2363 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
@@ -2349,7 +2372,7 @@ main () {
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:2353: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2376: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
@@ -2374,20 +2397,20 @@ fi
 
 
 echo $ac_n "checking if ANSI prototypes work""... $ac_c" 1>&6
-echo "configure:2378: checking if ANSI prototypes work" >&5
+echo "configure:2401: checking if ANSI prototypes work" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ansi_prototypes'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2384 "configure"
+#line 2407 "configure"
 #include "confdefs.h"
 int foo(char *); int foo (char *bar) {return 1;}
 int main() {
 foo("bar")
 ; return 0; }
 EOF
-if { (eval echo configure:2391: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2414: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ansi_prototypes="yes"
 else
@@ -2409,13 +2432,13 @@ EOF
 fi
 
 echo $ac_n "checking for tm->tm_gmtoff""... $ac_c" 1>&6
-echo "configure:2413: checking for tm->tm_gmtoff" >&5
+echo "configure:2436: checking for tm->tm_gmtoff" >&5
 if eval "test \"`echo '$''{'ac_cv_have_tm_gmoff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2419 "configure"
+#line 2442 "configure"
 #include "confdefs.h"
 #include <time.h>
 #include <sys/time.h>
@@ -2424,7 +2447,7 @@ struct tm foo;
       foo.tm_gmtoff = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2428: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2451: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_tm_gmoff="yes"
 else
@@ -2446,13 +2469,13 @@ EOF
 fi
 
 echo $ac_n "checking for extended mallinfo""... $ac_c" 1>&6
-echo "configure:2450: checking for extended mallinfo" >&5
+echo "configure:2473: checking for extended mallinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ext_mallinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2456 "configure"
+#line 2479 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <malloc.h>
@@ -2461,7 +2484,7 @@ struct mallinfo foo;
       foo.mxfast = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2465: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2488: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ext_mallinfo="yes"
 else
@@ -2483,13 +2506,13 @@ EOF
 fi
 
 echo $ac_n "checking for struct rusage""... $ac_c" 1>&6
-echo "configure:2487: checking for struct rusage" >&5
+echo "configure:2510: checking for struct rusage" >&5
 if eval "test \"`echo '$''{'ac_cv_have_struct_rusage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2493 "configure"
+#line 2516 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TIME_H
@@ -2502,7 +2525,7 @@ int main() {
 struct rusage R;
 ; return 0; }
 EOF
-if { (eval echo configure:2506: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2529: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_struct_rusage="yes"
 else
@@ -2524,13 +2547,13 @@ EOF
 fi
 
 echo $ac_n "checking for ip->ip_hl""... $ac_c" 1>&6
-echo "configure:2528: checking for ip->ip_hl" >&5
+echo "configure:2551: checking for ip->ip_hl" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ip_hl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2534 "configure"
+#line 2557 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -2547,7 +2570,7 @@ struct iphdr ip;
       ip.ip_hl= 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2551: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2574: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ip_hl="yes"
 else
@@ -2569,15 +2592,15 @@ EOF
 fi
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:2573: checking size of int" >&5
+echo "configure:2596: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2581 "configure"
+#line 2604 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2588,7 +2611,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2592: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2615: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -2608,15 +2631,15 @@ EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:2612: checking size of long" >&5
+echo "configure:2635: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2620 "configure"
+#line 2643 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2627,7 +2650,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2631: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2654: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -2650,19 +2673,19 @@ EOF
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:2654: checking for working alloca.h" >&5
+echo "configure:2677: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2659 "configure"
+#line 2682 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:2666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2689: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -2683,12 +2706,12 @@ EOF
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:2687: checking for alloca" >&5
+echo "configure:2710: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2692 "configure"
+#line 2715 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -2711,7 +2734,7 @@ int main() {
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:2715: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2738: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -2743,12 +2766,12 @@ EOF
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:2747: checking whether alloca needs Cray hooks" >&5
+echo "configure:2770: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2752 "configure"
+#line 2775 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -2773,12 +2796,12 @@ echo "$ac_t""$ac_cv_os_cray" 1>&6
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2777: checking for $ac_func" >&5
+echo "configure:2800: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2782 "configure"
+#line 2805 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -2801,7 +2824,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2805: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2828: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -2828,15 +2851,15 @@ done
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:2832: checking stack direction for C alloca" >&5
+echo "configure:2855: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 2840 "configure"
+#line 2863 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -2855,7 +2878,7 @@ main ()
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:2859: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2882: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -2878,12 +2901,12 @@ fi
 
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:2882: checking for pid_t" >&5
+echo "configure:2905: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2887 "configure"
+#line 2910 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2911,12 +2934,12 @@ EOF
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:2915: checking for size_t" >&5
+echo "configure:2938: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2920 "configure"
+#line 2943 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2944,12 +2967,12 @@ EOF
 fi
 
 echo $ac_n "checking for ssize_t""... $ac_c" 1>&6
-echo "configure:2948: checking for ssize_t" >&5
+echo "configure:2971: checking for ssize_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ssize_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2953 "configure"
+#line 2976 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2977,12 +3000,12 @@ EOF
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:2981: checking for off_t" >&5
+echo "configure:3004: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2986 "configure"
+#line 3009 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3010,12 +3033,12 @@ EOF
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:3014: checking for mode_t" >&5
+echo "configure:3037: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3019 "configure"
+#line 3042 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3043,12 +3066,12 @@ EOF
 fi
 
 echo $ac_n "checking for fd_mask""... $ac_c" 1>&6
-echo "configure:3047: checking for fd_mask" >&5
+echo "configure:3070: checking for fd_mask" >&5
 if eval "test \"`echo '$''{'ac_cv_type_fd_mask'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3052 "configure"
+#line 3075 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3077,13 +3100,13 @@ fi
 
 
 echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
-echo "configure:3081: checking for socklen_t" >&5
+echo "configure:3104: checking for socklen_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_socklen_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 3087 "configure"
+#line 3110 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -3114,22 +3137,22 @@ EOF
 fi
 
 echo $ac_n "checking for main in -lnsl""... $ac_c" 1>&6
-echo "configure:3118: checking for main in -lnsl" >&5
+echo "configure:3141: checking for main in -lnsl" >&5
 ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3126 "configure"
+#line 3149 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3133: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3156: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3157,22 +3180,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lsocket""... $ac_c" 1>&6
-echo "configure:3161: checking for main in -lsocket" >&5
+echo "configure:3184: checking for main in -lsocket" >&5
 ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3169 "configure"
+#line 3192 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3176: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3199: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3204,22 +3227,22 @@ if test "x$ac_cv_enabled_dlmalloc" = "xyes" ; then
   echo "skipping libmalloc check (--enable-dlmalloc specified)"
 else
   echo $ac_n "checking for main in -lgnumalloc""... $ac_c" 1>&6
-echo "configure:3208: checking for main in -lgnumalloc" >&5
+echo "configure:3231: checking for main in -lgnumalloc" >&5
 ac_lib_var=`echo gnumalloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lgnumalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3216 "configure"
+#line 3239 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3223: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3246: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3262,22 +3285,22 @@ fi
 			*)
   
 				echo $ac_n "checking for main in -lmalloc""... $ac_c" 1>&6
-echo "configure:3266: checking for main in -lmalloc" >&5
+echo "configure:3289: checking for main in -lmalloc" >&5
 ac_lib_var=`echo malloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3274 "configure"
+#line 3297 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3304: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3310,22 +3333,22 @@ fi
 fi
 
 echo $ac_n "checking for main in -lbsd""... $ac_c" 1>&6
-echo "configure:3314: checking for main in -lbsd" >&5
+echo "configure:3337: checking for main in -lbsd" >&5
 ac_lib_var=`echo bsd'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3322 "configure"
+#line 3345 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3329: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3353,22 +3376,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lregex""... $ac_c" 1>&6
-echo "configure:3357: checking for main in -lregex" >&5
+echo "configure:3380: checking for main in -lregex" >&5
 ac_lib_var=`echo regex'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lregex  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3365 "configure"
+#line 3388 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3372: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3395: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3389,15 +3412,15 @@ else
 fi
 
 echo $ac_n "checking for gethostbyname in -lbind""... $ac_c" 1>&6
-echo "configure:3393: checking for gethostbyname in -lbind" >&5
+echo "configure:3416: checking for gethostbyname in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3401 "configure"
+#line 3424 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3408,7 +3431,7 @@ int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:3412: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3435: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3442,15 +3465,15 @@ if test $ac_cv_lib_bind_gethostbyname = "no" ; then
 		;;
 	*)
 		echo $ac_n "checking for inet_aton in -lresolv""... $ac_c" 1>&6
-echo "configure:3446: checking for inet_aton in -lresolv" >&5
+echo "configure:3469: checking for inet_aton in -lresolv" >&5
 ac_lib_var=`echo resolv'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3454 "configure"
+#line 3477 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3461,7 +3484,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3465: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3488: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3477,15 +3500,15 @@ fi
 if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for inet_aton in -l44bsd""... $ac_c" 1>&6
-echo "configure:3481: checking for inet_aton in -l44bsd" >&5
+echo "configure:3504: checking for inet_aton in -l44bsd" >&5
 ac_lib_var=`echo 44bsd'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-l44bsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3489 "configure"
+#line 3512 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3496,7 +3519,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3500: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3523: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3528,22 +3551,22 @@ else
 fi
 
 		echo $ac_n "checking for main in -lresolv""... $ac_c" 1>&6
-echo "configure:3532: checking for main in -lresolv" >&5
+echo "configure:3555: checking for main in -lresolv" >&5
 ac_lib_var=`echo resolv'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3540 "configure"
+#line 3563 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3547: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3570: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3574,22 +3597,22 @@ fi
     esac
 fi
 echo $ac_n "checking for main in -lm""... $ac_c" 1>&6
-echo "configure:3578: checking for main in -lm" >&5
+echo "configure:3601: checking for main in -lm" >&5
 ac_lib_var=`echo m'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3586 "configure"
+#line 3609 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3593: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3616: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3618,15 +3641,15 @@ fi
 
 
 echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
-echo "configure:3622: checking for crypt in -lcrypt" >&5
+echo "configure:3645: checking for crypt in -lcrypt" >&5
 ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3630 "configure"
+#line 3653 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3637,7 +3660,7 @@ int main() {
 crypt()
 ; return 0; }
 EOF
-if { (eval echo configure:3641: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3670,22 +3693,22 @@ fi
 
 
 echo $ac_n "checking for main in -lpthread""... $ac_c" 1>&6
-echo "configure:3674: checking for main in -lpthread" >&5
+echo "configure:3697: checking for main in -lpthread" >&5
 ac_lib_var=`echo pthread'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lpthread  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3682 "configure"
+#line 3705 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3689: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3712: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3735,6 +3758,11 @@ case "$host" in
 	*-ibm-aix*)
 		echo "Removing -lbsd for AIX..."
 		LIBS=`echo $LIBS | sed -e s/-lbsd//`
+		echo "disabling snprintf/vsnprintf for $host"
+		ac_cv_func_snprintf=no
+		ac_cv_func_vsnprintf=no
+		echo "disabling seteuid for $host"
+		ac_cv_func_seteuid=no
 		;;
 	*m88k*)
 		CFLAGS="$CFLAGS -D_SQUID_MOTOROLA_"
@@ -3788,6 +3816,11 @@ if test -z "$ac_cv_func_poll"; then
 			echo "disabling poll for $host..."
 			ac_cv_func_poll='no'
 			;;
+		powerpc-ibm-aix4.1.*)
+			# Mike Laster (mlaster@metavillage.com) 19981021
+			echo "disabling poll for $host..."
+			ac_cv_func_poll='no'
+			;;
 	esac
 fi
 
@@ -3810,6 +3843,7 @@ for ac_func in \
 	mktime \
 	mstats \
 	poll \
+	putenv \
 	random \
 	regcomp \
 	regexec \
@@ -3833,12 +3867,73 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3837: checking for $ac_func" >&5
+echo "configure:3871: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3876 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3899: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+if test "$async_io" = "yes" ; then
+	for ac_func in \
+		pthread_attr_setscope \
+		pthread_setschedparam \
+		pthread_attr_setschedparam \
+	
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:3932: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3842 "configure"
+#line 3937 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3861,7 +3956,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:3865: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3960: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3885,17 +3980,18 @@ else
 fi
 done
 
+fi
 
 echo $ac_n "checking if setresuid is implemented""... $ac_c" 1>&6
-echo "configure:3891: checking if setresuid is implemented" >&5
+echo "configure:3987: checking if setresuid is implemented" >&5
 if eval "test \"`echo '$''{'ac_cv_func_setresuid'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 3899 "configure"
+#line 3995 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -3908,7 +4004,7 @@ else
   }
   
 EOF
-if { (eval echo configure:3912: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4008: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_setresuid="yes"
 else
@@ -3933,7 +4029,7 @@ fi
 
 if test "$IPF_TRANSPARENT" ; then
     echo $ac_n "checking if IP-Filter header files are installed""... $ac_c" 1>&6
-echo "configure:3937: checking if IP-Filter header files are installed" >&5
+echo "configure:4033: checking if IP-Filter header files are installed" >&5
     if test "$ac_cv_header_ip_compat_h" = "no" ||
        test "$ac_cv_header_ip_fil_h" = "no" ||
        test "$ac_cv_header_ip_nat_h" = "no" ; then
@@ -3968,21 +4064,21 @@ if test -z "$USE_GNUREGEX" ; then
     esac
 fi
 echo $ac_n "checking if GNUregex needs to be compiled""... $ac_c" 1>&6
-echo "configure:3972: checking if GNUregex needs to be compiled" >&5
+echo "configure:4068: checking if GNUregex needs to be compiled" >&5
 if test -z "$USE_GNUREGEX"; then
 if test "$ac_cv_func_regcomp" = "no" || test "$USE_GNUREGEX" = "yes" ; then
 	USE_GNUREGEX="yes"
 else
 	cat > conftest.$ac_ext <<EOF
-#line 3978 "configure"
+#line 4074 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <regex.h>
 int main() {
 regex_t t; regcomp(&t,"",0);
 ; return 0; }
 EOF
-if { (eval echo configure:3986: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4082: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   USE_GNUREGEX="no"
 else
@@ -4013,12 +4109,12 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4017: checking for $ac_func" >&5
+echo "configure:4113: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4022 "configure"
+#line 4118 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4041,7 +4137,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4045: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4141: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4069,12 +4165,12 @@ done
 
 
 echo $ac_n "checking Default FD_SETSIZE value""... $ac_c" 1>&6
-echo "configure:4073: checking Default FD_SETSIZE value" >&5
+echo "configure:4169: checking Default FD_SETSIZE value" >&5
 if test "$cross_compiling" = yes; then
   DEFAULT_FD_SETSIZE=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4078 "configure"
+#line 4174 "configure"
 #include "confdefs.h"
 
 #if HAVE_STDIO_H
@@ -4098,7 +4194,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4102: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4198: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   DEFAULT_FD_SETSIZE=`cat conftestval`
 else
@@ -4117,12 +4213,12 @@ EOF
 
 
 echo $ac_n "checking Maximum number of filedescriptors we can open""... $ac_c" 1>&6
-echo "configure:4121: checking Maximum number of filedescriptors we can open" >&5
+echo "configure:4217: checking Maximum number of filedescriptors we can open" >&5
 if test "$cross_compiling" = yes; then
   SQUID_MAXFD=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4126 "configure"
+#line 4222 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -4181,7 +4277,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4185: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_MAXFD=`cat conftestval`
 else
@@ -4207,12 +4303,12 @@ if test "$SQUID_MAXFD" -lt 512 ; then
 fi
 
 echo $ac_n "checking Default UDP send buffer size""... $ac_c" 1>&6
-echo "configure:4211: checking Default UDP send buffer size" >&5
+echo "configure:4307: checking Default UDP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4216 "configure"
+#line 4312 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4231,7 +4327,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4235: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4331: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_SNDBUF=`cat conftestval`
 else
@@ -4250,12 +4346,12 @@ EOF
 
 
 echo $ac_n "checking Default UDP receive buffer size""... $ac_c" 1>&6
-echo "configure:4254: checking Default UDP receive buffer size" >&5
+echo "configure:4350: checking Default UDP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4259 "configure"
+#line 4355 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4274,7 +4370,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4278: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_RCVBUF=`cat conftestval`
 else
@@ -4293,12 +4389,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP send buffer size""... $ac_c" 1>&6
-echo "configure:4297: checking Default TCP send buffer size" >&5
+echo "configure:4393: checking Default TCP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4302 "configure"
+#line 4398 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4317,7 +4413,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4321: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_SNDBUF=`cat conftestval`
 else
@@ -4336,12 +4432,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP receive buffer size""... $ac_c" 1>&6
-echo "configure:4340: checking Default TCP receive buffer size" >&5
+echo "configure:4436: checking Default TCP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4345 "configure"
+#line 4441 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4360,7 +4456,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4364: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4460: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_RCVBUF=`cat conftestval`
 else
@@ -4379,19 +4475,19 @@ EOF
 
 
 echo $ac_n "checking if sys_errlist is already defined""... $ac_c" 1>&6
-echo "configure:4383: checking if sys_errlist is already defined" >&5
+echo "configure:4479: checking if sys_errlist is already defined" >&5
 if eval "test \"`echo '$''{'ac_cv_needs_sys_errlist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4388 "configure"
+#line 4484 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 int main() {
 char *s = sys_errlist0;
 ; return 0; }
 EOF
-if { (eval echo configure:4395: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4491: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_needs_sys_errlist="no"
 else
@@ -4413,16 +4509,16 @@ EOF
 fi
 
 echo $ac_n "checking for libresolv _dns_ttl_ hack""... $ac_c" 1>&6
-echo "configure:4417: checking for libresolv _dns_ttl_ hack" >&5
+echo "configure:4513: checking for libresolv _dns_ttl_ hack" >&5
 cat > conftest.$ac_ext <<EOF
-#line 4419 "configure"
+#line 4515 "configure"
 #include "confdefs.h"
 extern int _dns_ttl_;
 int main() {
 return _dns_ttl_;
 ; return 0; }
 EOF
-if { (eval echo configure:4426: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4522: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 cat >> confdefs.h <<\EOF
@@ -4438,12 +4534,12 @@ fi
 rm -f conftest*
 
 echo $ac_n "checking if inet_ntoa() actually works""... $ac_c" 1>&6
-echo "configure:4442: checking if inet_ntoa() actually works" >&5
+echo "configure:4538: checking if inet_ntoa() actually works" >&5
 if test "$cross_compiling" = yes; then
   INET_NTOA_RESULT="broken"
 else
   cat > conftest.$ac_ext <<EOF
-#line 4447 "configure"
+#line 4543 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4460,7 +4556,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4464: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4560: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   INET_NTOA_RESULT=`cat conftestval`
 else
@@ -4482,6 +4578,140 @@ else
 	sleep 10
 fi
 
+if test "$ac_cv_func_statvfs" = "yes" ; then
+echo $ac_n "checking for working statvfs() interface""... $ac_c" 1>&6
+echo "configure:4584: checking for working statvfs() interface" >&5
+cat > conftest.$ac_ext <<EOF
+#line 4586 "configure"
+#include "confdefs.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/statvfs.h>
+
+int main() {
+
+struct statvfs sfs;
+sfs.f_blocks = sfs.f_bfree = sfs.f_frsize = 
+sfs.f_files = sfs.f_ffree = 0;
+statvfs("/tmp", &sfs);
+
+; return 0; }
+EOF
+if { (eval echo configure:4603: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_func_statvfs=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_func_statvfs=no
+fi
+rm -f conftest*
+echo "$ac_t""$ac_cv_func_statvfs" 1>&6
+fi
+
+echo $ac_n "checking for _res.nsaddr_list""... $ac_c" 1>&6
+echo "configure:4617: checking for _res.nsaddr_list" >&5
+if eval "test \"`echo '$''{'ac_cv_have_res_nsaddr_list'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4622 "configure"
+#include "confdefs.h"
+
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+
+int main() {
+_res.nsaddr_list[0];
+; return 0; }
+EOF
+if { (eval echo configure:4645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_have_res_nsaddr_list="yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_have_res_nsaddr_list="no"
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_have_res_nsaddr_list" 1>&6
+if test $ac_cv_have_res_nsaddr_list = "yes" ; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_RES_NSADDR_LIST 1
+EOF
+
+fi
+
+if test $ac_cv_have_res_nsaddr_list = "no" ; then
+echo $ac_n "checking for _res.ns_list""... $ac_c" 1>&6
+echo "configure:4667: checking for _res.ns_list" >&5
+if eval "test \"`echo '$''{'ac_cv_have_res_ns_list'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4672 "configure"
+#include "confdefs.h"
+
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+
+int main() {
+_res.ns_list[0].addr;
+; return 0; }
+EOF
+if { (eval echo configure:4695: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_have_res_ns_list="yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_have_res_ns_list="no"
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_have_res_ns_list" 1>&6
+if test $ac_cv_have_res_ns_list = "yes" ; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_RES_NS_LIST 1
+EOF
+
+fi
+fi
+
 XTRA_OBJS=''
 if test "$ac_cv_lib_malloc_main" = "yes" ; then
 	if test -r /usr/lib/debug/malloc.o ; then
@@ -3,13 +3,13 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.159 1998/10/17 05:08:16 wessels Exp $
+dnl  $Id: configure.in,v 1.160 1998/11/12 06:29:26 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.159 $)dnl
+AC_REVISION($Revision: 1.160 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(cfgaux)
 
@@ -271,10 +271,20 @@ AC_ARG_ENABLE(async_io,
 [  --enable-async-io       Do ASYNC disk I/O using threads],
 [ if test "$enableval" = "yes" ; then
     echo "Async I/O enabled"
+    async_io=yes
     AC_DEFINE(USE_ASYNC_IO)
     ASYNC_OBJS='$(ASYNC_OBJS)'
     SQUID_PTHREAD_LIB='$(PTHREADLIB)'
     CFLAGS="$CFLAGS -D_REENTRANT"
+    case "$host" in
+    i386-unknown-freebsd*)
+    	if test "$GCC" = "yes" ; then
+	    if test -z "$PRESET_LDFLAGS"; then
+		LDFLAGS="$LDFLAGS -pthread"
+	    fi
+	fi
+	;;
+    esac
   fi
 ])
 AC_SUBST(ASYNC_OBJS)
@@ -429,19 +439,25 @@ AC_ARG_ENABLE(poll,
                           is broken on some platforms.  If you think you are
                           smarter than the configure script, you may enable
                           poll with this option.
-],
-[ if test "$enableval" = "yes" ; then
+  --disable-poll          Disable the use of poll().],
+[ 
+  case "$enableval" in
+  yes)
     echo "Forcing poll() to be enabled"
     ac_cv_func_poll='yes'
-  fi
+    ;;
+  no)
+    echo "Forcing poll() to be disabled"
+    ac_cv_func_poll='no'
+    ;;
+  esac
 ])
 
 dnl Disable HTTP violations
 AC_ARG_ENABLE(http-violations,
 [  --disable-http-violations
                           This allows you to remove code which is known to
-                          violate the HTTP protocol specification.
-],
+                          violate the HTTP protocol specification.],
 [ if test "$enableval" = "no" ; then
     echo "Disabling HTTP Violations"
     AC_DEFINE(HTTP_VIOLATIONS, 0)
@@ -454,8 +470,7 @@ dnl Enable IP-Filter Transparent Proxy
 AC_ARG_ENABLE(ipf-transparent,
 [  --enable-ipf-transparent
                           Enable Transparent Proxy support for systems
-                          using IP-Filter network address redirection.
-],
+                          using IP-Filter network address redirection.],
 [ if test "$enableval" = "yes" ; then
 	echo "IP-Filter Transparent Proxy enabled"
 	AC_DEFINE(IPF_TRANSPARENT)
@@ -473,6 +488,13 @@ case "$host" in
 		ac_cv_prog_CC="$CC"
 	fi
 	;;
+    *-hp-hpux*)
+	if test "$ac_cv_prog_CC" = "cc" ; then
+		echo "adding '-Ae' to cc args for $host"
+		CC="cc -Ae";
+		ac_cv_prog_CC="$CC"
+	fi
+	;;
 esac
 
 dnl Check for programs
@@ -542,6 +564,7 @@ AC_CHECK_HEADERS( \
 	pwd.h \
 	regex.h \
 	resolv.h \
+	sched.h \
 	signal.h \
 	stdarg.h \
 	stddef.h \
@@ -755,6 +778,15 @@ dnl Please change your configure script.  AIX doesn't need -lbsd.
 	*-ibm-aix*)
 		echo "Removing -lbsd for AIX..."
 		LIBS=`echo $LIBS | sed -e s/-lbsd//`
+dnl From: mlaster@metavillage.com (Mike Laster)
+dnl AIX 4.1.4.x does not have header files for snprintf/vsnprintf
+dnl So using the internal versions generates a load of warnings
+dnl during compile.
+		echo "disabling snprintf/vsnprintf for $host"
+		ac_cv_func_snprintf=no
+		ac_cv_func_vsnprintf=no
+		echo "disabling seteuid for $host"
+		ac_cv_func_seteuid=no
 		;;
 	*m88k*)
 		CFLAGS="$CFLAGS -D_SQUID_MOTOROLA_"
@@ -800,6 +832,11 @@ if test -z "$ac_cv_func_poll"; then
 			echo "disabling poll for $host..."
 			ac_cv_func_poll='no'
 			;;
+		[powerpc-ibm-aix4.1.*])
+			# Mike Laster (mlaster@metavillage.com) 19981021
+			echo "disabling poll for $host..."
+			ac_cv_func_poll='no'
+			;;
 	esac
 fi
 
@@ -823,6 +860,7 @@ AC_CHECK_FUNCS(\
 	mktime \
 	mstats \
 	poll \
+	putenv \
 	random \
 	regcomp \
 	regexec \
@@ -845,6 +883,14 @@ AC_CHECK_FUNCS(\
 	vsnprintf \
 )
 
+if test "$async_io" = "yes" ; then
+	AC_CHECK_FUNCS(\
+		pthread_attr_setscope \
+		pthread_setschedparam \
+		pthread_attr_setschedparam \
+	)
+fi
+
 dnl Yay!  Another Linux brokenness.  Its not good enough
 dnl to know that setresuid() exists, because RedHat 5.0 declares
 dnl setresuid() but doesn't implement it.
@@ -1162,6 +1208,77 @@ else
 	sleep 10
 fi
 
+if test "$ac_cv_func_statvfs" = "yes" ; then
+AC_MSG_CHECKING(for working statvfs() interface)
+AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/statvfs.h>
+],
+[
+struct statvfs sfs;
+sfs.f_blocks = sfs.f_bfree = sfs.f_frsize = 
+sfs.f_files = sfs.f_ffree = 0;
+statvfs("/tmp", &sfs);
+],
+  ac_cv_func_statvfs=yes,
+  ac_cv_func_statvfs=no)
+AC_MSG_RESULT($ac_cv_func_statvfs)
+fi
+
+AC_CACHE_CHECK(for _res.nsaddr_list, ac_cv_have_res_nsaddr_list,
+AC_TRY_COMPILE([
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+],
+[_res.nsaddr_list[[0]];],
+ac_cv_have_res_nsaddr_list="yes",
+ac_cv_have_res_nsaddr_list="no"))
+if test $ac_cv_have_res_nsaddr_list = "yes" ; then
+  AC_DEFINE(HAVE_RES_NSADDR_LIST)
+fi
+
+if test $ac_cv_have_res_nsaddr_list = "no" ; then
+AC_CACHE_CHECK(for _res.ns_list, ac_cv_have_res_ns_list,
+AC_TRY_COMPILE([
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+],
+[_res.ns_list[[0]].addr;],
+ac_cv_have_res_ns_list="yes",
+ac_cv_have_res_ns_list="no"))
+if test $ac_cv_have_res_ns_list = "yes" ; then
+  AC_DEFINE(HAVE_RES_NS_LIST)
+fi
+fi
+
 dnl Need the debugging version of malloc if available
 XTRA_OBJS=''
 if test "$ac_cv_lib_malloc_main" = "yes" ; then
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -15,9 +15,8 @@ tekkis j&auml;rgnev viga:
 Juurdep&auml;&auml;s keelatud.
 </STRONG>
 <P>
-Juurdep&auml;&auml;su kontrolli konfiguratsioon blokeeris teie p&auml;ringu.
-Palun kontakteeruge oma teenusepakkujaga, kui te arvate, et blokeerimine
-pole &otilde;ige.
+Juurdep&auml;&auml;su kontrolli konfiguratsioon blokeerib teie p&auml;ringut.
+Kui te arvate, et blokeering pole &otilde;ige, kontakteeruge palun teenuse pakkujaga.
 </UL>
 </P>
 
@@ -6,7 +6,7 @@
 <H2>Cache kasutamine keelatud</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -6,7 +6,7 @@
 <H2>Cache haldaja kasutamine blokeeritud</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -1,26 +1,26 @@
-<HTML><HEAD>
-<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
-</HEAD><BODY>
-<H1>VIGA</H1>
-<H2>P&auml;ring URLile ei saa vastust</H2>
-<HR>
-<P>
-Sooritades p&auml;ringut URLile:
-<A HREF="%U">%U</A>
-<P>
-tekkis j&auml;rgnev viga:
-<UL>
-<LI>
-<STRONG>
-&Uuml;hendus eba&otilde;nnestus.
-</STRONG>
-</UL>
-
-<P>
-S&uuml;steem vastas:
-<PRE><I>    %E</I></PRE>
-
-<P>
-Server v&otilde;i arvutiv&otilde;rk ei t&ouml;&ouml;ta. Palun korrake
-p&auml;ringut.
-</P>
+<HTML><HEAD>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
+</HEAD><BODY>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
+<HR>
+<P>
+Sooritades p&auml;ringut URLile
+<A HREF="%U">%U</A>
+<P>
+tekkis j&auml;rgnev viga:
+<UL>
+<LI>
+<STRONG>
+&Uuml;hendus eba&otilde;nnestus.
+</STRONG>
+</UL>
+
+<P>
+S&uuml;steem vastas:
+<PRE><I>    %E</I></PRE>
+
+<P>
+Server v&otilde;i arvutiv&otilde;rk ei t&ouml;&ouml;ta. Palun korrake
+p&auml;ringut.
+</P>
@@ -4,7 +4,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -17,6 +17,6 @@ Edastamine keelatud.
 </UL>
 
 <P>
-See cache ei edasta teie p&auml;ringut, kuna ta kasutab ainult naaber cache
-meetodit. Ilmselt on klient %i cache, mis on vigaselt konfigureeritud.
+Meie cache ei edasta teie p&auml;ringut, kuna ta kasutab andmete edastamisel
+ainult naaber cache meetodit. Ilmselt on %i vigaselt konfigureeritud cache.
 </P>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>FTP PUT eba&otilde;nnestus</H2>
 <HR>
 <P>
-PUT operatsioon URLil:
+PUT operatsioon URLil
 <A HREF="%U">%U</A>
 <P>
 Squid saatis j&auml;rgneva FTP k&auml;su:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut:
+Sooritades p&auml;ringut
 <PRE>
 %R
 </PRE>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -17,6 +17,6 @@ Wais edastaja puudub
 </UL>
 
 <P>
-Selles Caches on WAISi edastav host kirjeldamata!  Karju natuke administraatori
-peale.
+Selles Caches on WAISi edastav host kirjeldamata!  Kontakteeruge
+administraatoriga.
 </P>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ringule ei saabunud vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -21,6 +21,6 @@ S&uuml;steem vastas:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Lugejal katkes v&otilde;rgust andmete lugemisel kannatus. V&otilde;rk v&otilde;i
+Lugejal katkes v&otilde;rgust andmeid lugedes kannatus. V&otilde;rk v&otilde;i
 server v&otilde;ib olla maas v&otilde;i umbes. Proovige uuesti.
 </P>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URNile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URNile:
+Sooritades p&auml;ringut URNile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,14 +5,14 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
 <UL>
 <LI>
 <STRONG>
-Kirjutamise viga
+Viga kirjutamisel
 </STRONG>
 </UL>
 
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -17,5 +17,5 @@ Null pikkusega vastus
 </UL>
 
 <P>
-Squid ei saanud sugugi andmeid selle p&auml;ringu vastuseks...
+Squid ei saanud selle p&auml;ringu vastuseks midagi...
 </P>
@@ -1,23 +1,23 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
 Acc&egrave;s interdit.
 </STRONG>
 <P>
-La configuration du controle d'acc&egrave;s interdit votre requete d'etre
+La configuration du contr&ocirc;le d'acc&egrave;s interdit &agrave; votre requ&ecirc;te d'&ecirc;tre
 accept&eacute;e &agrave; cette heure-ci. Veuillez contacter votre
-prestataire de service si vous pensez que ceci n'a pas lieu d'etre.
+prestataire de service si vous pensez que ceci n'a pas lieu d'&ecirc;tre.
 </UL>
 </P>
 
@@ -1,27 +1,27 @@
 <HTML><HEAD>
-<TITLE>ERREUR: Acc&egrave;s interdit au cache</TITLE>
+<TITLE>ERREUR&nbsp;: Acc&egrave;s au cache interdit</TITLE>
 </HEAD>
 <BODY>
 <H1>ERREUR</H1>
-<H2>Acc&egrave;s interdit au cache</H2>
+<H2>Acc&egrave;s au cache interdit</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Acc&egrave;s interdit au cache.
+Acc&egrave;s au cache interdit.
 </STRONG>
 </UL>
 </P>
 
-<P>D&eacute;sol&eacute;, vous n'etes actuellement pas autoris&eacute;
+<P>D&eacute;sol&eacute;, vous n'&ecirc;tes actuellement pas autoris&eacute;
 &agrave; demander
 <PRE>    %U</PRE>
-&agrave; ce cache tant que vous ne vous etes pas identifi&eacute;.
+&agrave; ce cache tant que vous ne vous &ecirc;tes pas identifi&eacute;.
 </P>
 
 <P>
@@ -1,32 +1,32 @@
 <HTML><HEAD>
-<TITLE>ERREUR: Acc&egrave;s interdit au gestionnaire de cache</TITLE>
+<TITLE>ERREUR&nbsp;: Acc&egrave;s au gestionnaire de cache interdit</TITLE>
 </HEAD>
 <BODY>
 <H1>ERREUR</H1>
-<H2>Cache Manager Acc&egrave;s interdit</H2>
+<H2>Acc&egrave;s au gestionnaire de cache interdit</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Acc&egrave;s interdit au gestionnaire de cache.
+Acc&egrave;s au gestionnaire de cache interdit.
 </STRONG>
 </UL>
 </P>
 
-<P>D&eacute;sol&eacute, vous n'etes pas autoris&eacute;s &agrave; acc&eacute;der
+<P>D&eacute;sol&eacute, vous n'&ecirc;tes pas autoris&eacute; &agrave; acc&eacute;der &agrave;
 <PRE>    %U</PRE>
-&agrave; ce cache sans vous etre identifi&eacute;.
+au travers de ce gestionnaire de cache sans vous &ecirc;tre identifi&eacute;.
 </P>
 
 <P> Vous avez besoin de Netscape version 2.0 ou sup&eacute;rieure, ou
 Microsoft Internet Explorer 3.0, ou un navigateur conforme &agrave; HTTP/1.1
 pour que ceci fonctionne. Veuillez contacter l'<A HREF="mailto:%w">administrateur du cache</a>
 si vous avez des difficult&eacute;s &agrave; vous authentifier ou, si vous
-<em>etes</em> l'administrateur, lisez la documentation de Squid sur
+<em>&ecirc;tes</em> l'administrateur, lisez la documentation de Squid sur
 l'interface du gestionnaire de cache, et v&eacute;rifiez l'historique du
 cache pour des messages d'erreur plus d&eacute;taill&eacute;s.</P>
@@ -1,24 +1,24 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Impossible de relayer &agrave; cette heure.
+Impossible de relayer cette requ&ecirc;te en ce moment.
 </STRONG>
 </UL>
 
 <P>
-Cette requete n'a pu etre transmise au serveur d'origine ou &agrave; l'un
-des caches parents. La cause de cette erreur la plus probable est:
+Cette requ&ecirc;te n'a pu &ecirc;tre transmise au serveur d'origine ou &agrave; l'un
+des caches parents. La cause la plus probable de cette erreur est&nbsp;:
 <UL>
 <LI>L'administrateur du cache a interdit &agrave; ce cache de faire des
     connexions directes aux serveurs d'origine, et
@@ -1,26 +1,26 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-La connexion a &eacute;chou&eacute
+La connexion a &eacute;chou&eacute;
 </STRONG>
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
-La machine distante ou le r&eacute;seau peuvent etre hors service. Veuillez
-r&eacute;it&eacute;rer votre requete.
+La machine distante ou le r&eacute;seau sont peut-&ecirc;tre hors service. Veuillez
+r&eacute;it&eacute;rer votre requ&ecirc;te.
 </P>
@@ -1,27 +1,27 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <BLOCKQUOTE>
 Impossible d'associer une adresse IP &agrave; la machine
-<I>%H</I>
+<I>%H</I>.
 </BLOCKQUOTE>
 </UL>
 
 <P>
-Le serveur de noms retourna:
+Le serveur de noms a retourn&eacute;&nbsp;:
 <BLOCKQUOTE>
 %z
 </BLOCKQUOTE>
 
 <P>
-En d'autres termes:
+En d'autres termes&nbsp;:
 <PRE>
  Le cache n'a pas &eacute;t&eacute; en mesure de r&eacute;soudre le nom de
 machine pr&eacute;sent&eacute; dans l'URL.
@@ -1,22 +1,22 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Relayage interdit.
+Relais interdit.
 </STRONG>
 </UL>
 
 <P>
-Ce cache ne fera pas suivre votre requete car il devrait violer une relation
-hi&eacute;rarchique. Le client %i est peut-etre un cache mal configur&eacute.
+Ce cache ne fera pas suivre votre requ&ecirc;te car il tente de respecter une relation
+de voisinage. Le client %i est peut-&ecirc;tre un cache mal configur&eacute;.
 </P>
@@ -1,21 +1,21 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Le FTP est d&eacute;sactiv&eacute;
+Le FTP est d&eacute;sactiv&eacute;.
 </STRONG>
 </UL>
 
 <P>
-Ce cache ne supporte pas le FTP.
+Ce cache ne prend pas en compte le protocole FTP.
 </P>
@@ -1,25 +1,25 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
 Une erreur du protocole FTP est survenue
-en essayant de charger l'URL suivante:
+en essayant de charger l'URL suivante&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-Squid a envoy&eacute; la commande FTP suivante:
+Squid a envoy&eacute; la commande FTP suivante&nbsp;:
 <PRE><STRONG>
 	%f
 </STRONG></PRE>
-et recut alors la r&eacute;ponse
+et a re&ccedil;u la r&eacute;ponse&nbsp;:
 <PRE><STRONG>
 	%F
 </STRONG></PRE>
 <P>
-Ceci pourrait etre caus&eacute; par une URL FTP avec un chemin absolu (ce
-qui est en contradiction avec le RFC 1738). Si il s'agit bien de cette
-cause, alors le fichier peut etre trouv&eacute; &agrave; <A HREF="%B">%B</A>.
+Ceci pourrait &ecirc;tre d&ucirc; &agrave; une URL FTP contenant un chemin absolu&nbsp;(ce
+qui est en contradiction avec la RFC 1738). Dans ce cas,
+ le fichier peut &ecirc;tre r&eacute;cup&eacute;r&eacute; &agrave; l'URL&nbsp;: <A HREF="%B">%B</A>.
 </P>
 
@@ -1,8 +1,8 @@
 <HTML><HEAD>
-<TITLE>FTP PUT r&eacute;ussi: Fichier cr&eacute;e</TITLE>
+<TITLE>FTP PUT r&eacute;ussi&nbsp;: Fichier cr&eacute;&eacute;</TITLE>
 </HEAD><BODY>
-<H1>Operation r&eacute;ussie</H1>
-<H2>Fichier cr&eacute;e</H2>
+<H1>Op&eacute;ration r&eacute;ussie</H1>
+<H2>Fichier cr&eacute;&eacute;</H2>
 <HR>
 <P>
 </P>
@@ -1,23 +1,23 @@
 <HTML><HEAD>
-<TITLE>ERREUR: envoi FTP d&eacute;fectueux</TITLE>
+<TITLE>ERREUR&nbsp;: envoi FTP d&eacute;fectueux</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
 <H2>FTP PUT/envoi d&eacute;fectueux</H2>
 <HR>
 <P>
-En essayant d'envoyer (PUT) l'URL suivante:
+En essayant d'envoyer (PUT) l'URL suivante&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-Squid a envoy&eacute; la commande FTP suivante:
+Squid a envoy&eacute; la commande FTP suivante&nbsp;:
 <PRE><STRONG>
         %f
 </STRONG></PRE>
-et recut alors cette r&eacute;ponse
+et a re&ccedil;u la r&eacute;ponse&nbsp;:
 <PRE><STRONG>
         %F
 </STRONG></PRE>
 <P>
-En d'autres termes:
+En d'autres termes&nbsp;:
 <PRE>
 V&eacute;rifiez le chemin, les droits, l'espace disque et essayez &agrave; nouveau.
 </PRE>
@@ -1,7 +1,7 @@
 <HTML><HEAD>
-<TITLE>FTP PUT r&eacute;ussi: Fichier mis &agrave; jour</TITLE>
+<TITLE>FTP PUT r&eacute;ussi&nbsp;: Fichier mis &agrave; jour</TITLE>
 </HEAD><BODY>
-<H1>Operation r&eacute;ussie</H1>
+<H1>Op&eacute;ration r&eacute;ussie</H1>
 <H2>Fichier mis &agrave; jour</H2>
 <HR>
 <P>
@@ -1,31 +1,31 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de traiter la requete:
+En essayant de traiter la requ&ecirc;te&nbsp;:
 <PRE>
 %R
 </PRE>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Requete invalide
+Requ&ecirc;te invalide
 </STRONG>
 </UL>
 
 <P>
-Quelque chose est invalide dans la requete HTTP. Probl&egrave;mes envisageables:
+Quelque chose est invalide dans la requ&eacute;te HTTP. Probl&egrave;mes envisageables&nbsp;:
 <UL>
-<LI>M&eacute;thode de requete absente ou inconnue (GET, POST)
+<LI>M&eacute;thode de requ&ecirc;te absente ou inconnue (GET, POST)
 <LI>Absence d'URL
 <LI>Absence d'identifiant HTTP (HTTP/1.0)
-<LI>La requete est peut etre trop volumineuse
-<LI>Content-Length absent pour les requetes POST ou PUT
-<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine; les underscores ne sont pas autoris&eacute;s.
+<LI>La requ&ecirc;te est peut-&ecirc;tre trop volumineuse
+<LI>Champ <code>Content-Length</code> absent pour les requ&ecirc;tes POST ou PUT
+<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine, les soulign&eacute;s (underscores) ne sont pas autoris&eacute;s.
 </UL>
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,11 +17,11 @@ URL invalide
 </UL>
 
 <P>
-Quelque chose dans l'URL est incorrect.  Probl&egrave;mes envisageables:
+Quelque chose dans l'URL est incorrect.  Probl&egrave;mes envisageables&nbsp;:
 <UL>
-<LI>Protocole d'acc&egrave;s absent ou incorrect (il devrait etre de la forme `http://')
+<LI>Protocole d'acc&egrave;s absent ou incorrect (il devrait &ecirc;tre de la forme `http://')
 <LI>Nom de machine absent
 <LI>Double &eacute;chappement ill&eacute;gal dans le chemin de l'URL
-<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine; les underscores ne sont pas autoris&eacute;s
+<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine, les soulign&eacute;s (underscores) ne sont pas autoris&eacute;s
 </UL>
 </P>
@@ -1,22 +1,22 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Dur&eacute;e de vie de la connexion expir&eacute;e
+Dur&eacute;e de vie de la connexion d&eacute;pass&eacute;e
 </STRONG>
 </UL>
 
 <P>
-Squid a mit fin &agrave; cette requete car elle a exc&eacute;d&eacute; la
+Squid a mis fin &agrave; cette requ&ecirc;te car elle a exc&eacute;d&eacute; la
 dur&eacute;e de vie maximale.
 </P>
@@ -1,22 +1,22 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Pas de relai WAIS
+Pas de relais WAIS
 </STRONG>
 </UL>
 
 <P>
-Il n'y a pas de machine d&eacute;finie comme relai WAIS sur ce cache !
+Il n'y a pas de machine d&eacute;finie comme relais WAIS sur ce cache&nbsp;!
 Adressez-vous &agrave; votre administrateur.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -19,7 +19,7 @@ Aucun document valide n'a &eacute;t&eacute; trouv&eacute; dans le cache et la di
 
 <P>
 
-Vous avez formul&eacute; une requete avec la directive de controle
+Vous avez formul&eacute; une requ&ecirc;te avec la directive de contr&ocirc;le
 <code>only-if-cached</code>. Le document n'a pas &eacute;t&eacute; trouv&eacute; dans le cache,
 <em>ou</em> il n&eacute;cessite une revalidation, interdite par la directive
 <code>only-if-cached</code>.
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,10 +17,10 @@ Erreur de lecture
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
 Une erreur est survenue en essayant d'acc&eacute;der au r&eacute;seau.
-Veuillez r&eacute;it&eacute;rer votre requete.
+Veuillez r&eacute;it&eacute;rer votre requ&ecirc;te.
 </P>
@@ -1,28 +1,28 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-D&eacute;lai de lecture &eacute;coul&eacute;
+D&eacute;lai de lecture d&eacute;pass&eacute;
 </STRONG>
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
 Un d&eacute;lai critique s'est &eacute;coul&eacute; en attendant des
 donn&eacute;es du r&eacute;seau. Le r&eacute;seau ou le serveur sont
-peut-etre hors service ou d&eacute;faillants. Veuillez r&eacute;it&eacute;rer
-votre requete.
+peut-&ecirc;tre hors service ou d&eacute;faillants. Veuillez r&eacute;it&eacute;rer
+votre requ&ecirc;te.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,11 +17,11 @@ Erreur de socket
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;:
 <PRE><I>    %E</I></PRE>
 
 <P>
 Squid n'est pas en mesure de cr&eacute;er une socket TCP, probablement
 &agrave; cause d'une charge excessive. Veuillez r&eacute;it&eacute;rer votre
-requete.
+requ&ecirc;te.
 </P>
@@ -1,23 +1,23 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-M&eacute;thode et protocole de la requete non g&eacute;r&eacute;s
+Combinaison de m&eacute;thode et de protocole non g&eacute;r&eacute;e
 </STRONG>
 </UL>
 
 <P>
-Squid ne supporte pas toutes les m&eacute;thodes de requetes pour tous les
-protocoles. Par exemple, vous ne pouvez pas POSTer une requete Gopher.
+Squid ne permet pas toutes les m&eacute;thodes de requ&ecirc;tes pour tous les
+protocoles. Vous ne pouvez par exemple pas utiliser le protocole POST dans une requ&ecirc;te Gopher.
 </P>
 
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URN suivante n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URN suivante n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>Une URL de l'URN n'a pu etre charg&eacute;e</H2>
+<H2>Une URL de l'URN n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URN:
+En essayant de charger l'URN&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,5 +17,5 @@ Impossible de r&eacute;soudre l'URN
 </UL>
 
 <P>
-H&eacute; ! N'en esp&eacute;rez pas trop des URNs de %T :)
+H&eacute;&nbsp;! N'esp&eacute;rez pas trop des URNs de %T :)
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,10 +17,10 @@ Erreur d'&eacute;criture
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Une erreur s'est produite en acc&eacute;dant au r&eacute;seau. Veuillez
-r&eacute;it&eacute;rer votre requete.
+Une erreur s'est produite lors de l'acc&egrave;s au r&eacute;seau. Veuillez
+r&eacute;it&eacute;rer votre requ&ecirc;te.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,5 +17,5 @@ R&eacute;ponse de taille nulle
 </UL>
 
 <P>
-Squid n'a recu aucune donn&eacute;e pour cette requete.
+Squid n'a re&ccedil;u aucune donn&eacute;e pour cette requ&ecirc;te.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,11 +17,11 @@ L'erreur suivante fut rencontr&eacute;e:
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
-En d'autres termes:
+En d'autres termes&nbsp;:
 <PRE>
     @LONG_DESCRIPTION@
 </PRE>
@@ -19,4 +19,4 @@ Las reglas de control de acceso impiden que su petici
 permitida en este momento. Contacte con su proveedor de servicios
 si cree que esto es incorrecto.
 </UL>
-
+</P>
@@ -12,7 +12,7 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Imposibilidad de envar la peticin en este momento.
+Imposibilidad de enviar la peticin en este momento.
 </STRONG>
 </UL>
 
@@ -24,6 +24,6 @@ este error son:
 <LI>El administrador de la cach no permite que esta
     cach realice conexiones directas a los servidores
     origen, y
-<LI>Todas las cachs configuradas como padres estn siendo
-    inalcanzables.
+<LI>Todas las cachs configuradas como padres son inalcanzables
+en este momento.
 </UL>
@@ -22,4 +22,4 @@ El sistema ha devuelto el siguiente mensaje:
 
 <P>
 El equipo remoto o la red pueden estar fuera de servicio.
-Por favor, intnte de nuevo la peticin.
+Por favor, intente de nuevo la peticin en otro momento.
@@ -22,10 +22,11 @@ El programa dnsserver ha devuelto el siguiente mensaje:
 </BLOCKQUOTE>
 
 <P>
-Esto quiere decir que:
+Esto significa que:
 <PRE>
  La cach no ha sido capaz de resolver el nombre de mquina
  presente en la URL.
- Compruebe que la direccin es correcta.
+ Compruebe que la direccin sea correcta.
 </PRE>
+</P>
 
@@ -12,11 +12,12 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Tramitacin denegada.
+Reenvo denegado.
 </STRONG>
 </UL>
 
 <P>
-Esta cach no permitir hacer seguir su peticin porque trata de obligar a
+Esta cach no permite reenviar su peticin porque trata de obligar a
 mantener una relacin de hermandad.
 Quizs el cliente en %i es una cach que ha sido mal configurada.
+</P>
@@ -12,9 +12,10 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Servicio FTP deshabilitado.
+Servicio FTP deshabilitado
 </STRONG>
 </UL>
 
 <P>
-Esta cach no soporta el protocolo FTP.
+Esta cach no proporciona servicio cach para el protocolo FTP.
+</P>
@@ -7,18 +7,15 @@
 <P>
 Ha ocurrido un error de protocolo FTP:
 
-Mientras se intentaba traer el URL:
+mientras se intentaba traer el documento con URL:
 <A HREF="%U">%U</A>
 <P>
-Squid orden el siguiente comando FTP:
-<PRE><STRONG>
-	%f
-</STRONG></PRE>
+Squid envi la siguiente orden FTP:
+<BLOCKQUOTE><PRE><STRONG>%f</STRONG></PRE></BLOCKQUOTE>
 y recibi la siguiente respuesta:
-<PRE><STRONG>
-	%F
-</STRONG></PRE>
+<BLOCKQUOTE><PRE><STRONG>%F</STRONG></PRE></BLOCKQUOTE>
+<BLOCKQUOTE><PRE><STRONG>%g</STRONG></PRE></BLOCKQUOTE>
 <P>
-Esto puede ser causado por una URL de protocolo FTP con un camino
+Esto puede ser causado por una URL de protocolo FTP con una ruta
 de directorios absoluto(que no cumple el RFC 1738). Si esta es la
 causa, el fichero podra encontrarse en <A HREF="%B">%B</A>.
@@ -14,18 +14,19 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Peticin no valida.
+Peticin no vlida.
 </STRONG>
 </UL>
 
 <P>
 Algn aspecto de la peticin HTTP no es vlido. Posibles problemas:
 <UL>
-<LI>El mtodo de la peticin falta o es desconocido
-   (no es GET o POST)
+<LI>Falta o es desconocido el mtodo de la peticin (no es GET ni POST)
 <LI>Falta el URL
 <LI>Falta el identificador HTTP (HTTP/1.0)
-<LI>La peticin puede ser demasiado grande.
-<LI>Hay caracteres ilegales en el nombre de mquina.
-    Los subrayados no estn permitidos en dicha seccin.
+<LI>La peticin es demasiado grande.
+<LI>Hay caracteres ilegales en el nombre de mquina;
+    el carcter  subrayado (_) no est permitido.
 </UL>
+</P>
+
@@ -20,7 +20,9 @@ URL incorrecta.
 Algn aspecto del URL solicitado es incorrecto. Posibles problemas:
 <UL>
 <LI>Falta o es incorrecto el protocolo de acceso (debe ser `http://'' o similar)
-<LI>Falta el nombre de la mquina.
-<LI>Hay caracteres ilegales en el nombre de mquina.
-    Los subrayados no estn permitidos en dicha seccin.
+<LI>Falta el nombre de la mquina
+<LI>Hay un doble-escape ilegas en la ruta de la URL
+<LI>Hay caracteres ilegales en el nombre de mquina;
+    el caracter de subrayado no est permitido
 </UL>
+</P>
@@ -12,10 +12,12 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Ha expirado el tiempo de vida de la conexin.
+Ha expirado el tiempo de vida de la conexin
 </STRONG>
 </UL>
 
 <P>
-Squid ha dado por terminada una peticin porque se ha excedido
-el mximo tiempo de conexin permitido.
+Squid ha dado por terminada la peticin porque se ha excedido
+el tiempo de vida mximo para una conexin.
+</P>
+
@@ -12,10 +12,10 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-No hay un retransmisor de protocolo Wais.
+No hay una pasarela para protocolo Wais.
 </STRONG>
 </UL>
 
 <P>
-Esta cach no tiene definido ningn retransmisor para el protocolo WAIS !!
-Grteselo al administrador de la cach !!
+Esta cach no tiene definido ninguna pasarela para el protocolo WAIS !!
+Grteselo al administrador de la cach !
@@ -12,14 +12,16 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Error de lectura.
+Error de lectura
 </STRONG>
 </UL>
 
 <P>
 El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
+</P>
 
 <P>
-Algn problema ocurri mientras se intentaba leer los datos de la red.
-Por favor intntelo de nuevo.
+Ha ocurrido algn problema mientras se lean datos de la red.
+Por favor, intntelo de nuevo.
+</P>
@@ -12,7 +12,7 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Ha saltado la alarma de tiempo excesivo en la lectura.
+Se acab el tiempo mximo para lectura de datos de la red.
 </STRONG>
 </UL>
 
@@ -21,7 +21,6 @@ El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Mientras se esperaba a leer datos de la red ha saltado una alarma
-avisansdo de un exceso en el tiempo transcurrido para la lectura.
-La red o el servidor pueden estar congestionados.
-Por favor, intntelo de nuevo.
+Se acab el tiempo mximo de lectura mientras se lean datos de la red.
+La red o el servidor pueden estar congestionados. Por favor, intntelo de nuevo
+</P>
@@ -12,7 +12,7 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Fallo en el puerto (socket):
+Fallo en el puerto (socket)
 </STRONG>
 </UL>
 
@@ -18,4 +18,4 @@ M
 
 <P>
 Squid no admite todos los mtodos para todos los protocolos de acceso.
-Por ejemplo, Usted no puede hacer un POST a un servidor Gopher.
+Por ejemplo, no se puede hacer un POST a un servidor Gopher.
@@ -2,10 +2,10 @@
 <TITLE>ERROR: El URN solicitado no se ha podido conseguir</TITLE>
 </HEAD><BODY>
 <H1>ERROR</H1>
-<H2>No se ha podido obtener un URL para el URN solicitado</H2>
+<H2>No se ha podido obtener una URL para el URN solicitado</H2>
 <HR>
 <P>
-Mientras se trataba de obtener el URN:
+Mientras se intentaba obtener el URN:
 <A HREF="%U">%U</A>
 <P>
 Ha ocurrido el siguiente problema:
@@ -17,4 +17,5 @@ No se puede resolver el URN
 </UL>
 
 <P>
-No espere mucho sobre URNs en 1998 :)
+Hey, no espere mucho sobre URNs en %T :)
+</P>
@@ -21,5 +21,5 @@ El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Se ha producido un error mientras se intentaba escribir datos en la red.
+Se ha producido un error mientras se escriban datos en la red.
 Por favor, intntelo de nuevo.
@@ -17,4 +17,5 @@ Respuesta vac
 </UL>
 
 <P>
-Squid no ha recibido  ninguna informacin en respuesta a esta peticin.
+Squid no ha recibido ninguna informacin en respuesta a esta peticin.
+</P>
@@ -1,4 +1,5 @@
-Thank you to Javier Puche <javier.puche@rediris.es> for 
-creating these error pages in Spanish!
+Thanks to Javier Puche <javier.puche@rediris.es>,
+and Roberto Lumbreras <rover-squid@lander.es>
+for creating these error pages in Spanish!
 
 Note: character set is ISO-LATIN-1
@@ -21,8 +21,8 @@ El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Que significa que:
+Esto significa que:
 <PRE>
     @LONG_DESCRIPTION@
 </PRE>
-
+</P>
@@ -242,6 +242,16 @@
  */
 #undef fd_mask
 
+/*
+ * If _res structure has nsaddr_list member
+ */
+#undef HAVE_RES_NSADDR_LIST
+
+/*
+ * If _res structure has ns_list member
+ */
+#undef HAVE_RES_NS_LIST
+
 /* The number of bytes in a int.  */
 #undef SIZEOF_INT
 
@@ -302,6 +312,18 @@
 /* Define if you have the poll function.  */
 #undef HAVE_POLL
 
+/* Define if you have the pthread_attr_setschedparam function.  */
+#undef HAVE_PTHREAD_ATTR_SETSCHEDPARAM
+
+/* Define if you have the pthread_attr_setscope function.  */
+#undef HAVE_PTHREAD_ATTR_SETSCOPE
+
+/* Define if you have the pthread_setschedparam function.  */
+#undef HAVE_PTHREAD_SETSCHEDPARAM
+
+/* Define if you have the putenv function.  */
+#undef HAVE_PUTENV
+
 /* Define if you have the random function.  */
 #undef HAVE_RANDOM
 
@@ -461,6 +483,9 @@
 /* Define if you have the <resolv.h> header file.  */
 #undef HAVE_RESOLV_H
 
+/* Define if you have the <sched.h> header file.  */
+#undef HAVE_SCHED_H
+
 /* Define if you have the <signal.h> header file.  */
 #undef HAVE_SIGNAL_H
 
@@ -1,5 +1,5 @@
 /*
- * $Id: util.h,v 1.51 1998/07/22 20:36:31 wessels Exp $
+ * $Id: util.h,v 1.52 1998/11/12 06:30:12 wessels Exp $
  *
  * AUTHOR: Harvest Derived
  *
@@ -62,6 +62,7 @@ extern const char *mkhttpdlogtime(const time_t *);
 extern const char *mkrfc1123(time_t);
 extern char *uudecode(const char *);
 extern char *xstrdup(const char *);
+extern char *xstrndup(const char *, size_t);
 extern const char *xstrerror(void);
 extern const char *xbstrerror(int);
 extern int tvSubMsec(struct timeval, struct timeval);
@@ -1,10 +1,10 @@
 /*
- * $Id: version.h,v 1.120 1998/10/01 22:57:11 wessels Exp $
+ * $Id: version.h,v 1.121 1998/11/12 06:30:13 wessels Exp $
  *
  *  SQUID_VERSION - String for version id of this distribution
  */
 #ifndef SQUID_VERSION
-#define SQUID_VERSION	"2.1.PRE1"
+#define SQUID_VERSION	"2.1.PRE4"
 #endif
 
 #ifndef SQUID_RELEASE_TIME
@@ -1,5 +1,5 @@
 /*
- * $Id: radix.c,v 1.8 1998/09/23 17:14:22 wessels Exp $
+ * $Id: radix.c,v 1.9 1998/11/12 06:30:14 wessels Exp $
  *
  * DEBUG: section 53     Radix tree data structure implementation
  * AUTHOR: NetBSD Derived
@@ -118,7 +118,7 @@ struct radix_mask *rn_mkfreelist;
 struct radix_node_head *mask_rnhead;
 static char *addmask_key;
 static unsigned char normal_chars[] =
-{0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, -1};
+{0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xFF};
 static char *rn_zeros, *rn_ones;
 
 #define rn_masktop (mask_rnhead->rnh_treetop)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: rfc1123.c,v 1.20 1998/07/22 20:36:37 wessels Exp $
+ * $Id: rfc1123.c,v 1.21 1998/11/12 06:30:15 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -43,6 +43,9 @@
 #if HAVE_STDIO_H
 #include <stdio.h>
 #endif
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
 #if HAVE_STRING_H
 #include <string.h>
 #endif
@@ -152,7 +155,8 @@ parse_rfc1123(const char *str)
 	    return -1;
 	tm.tm_mday = make_num(s + 8);
 	tm.tm_mon = make_month(s + 4);
-	tm.tm_year = make_num(s + 22);
+	/* Y2K fix, richard.kettlewell@kewill.com */
+	tm.tm_year = atoi(s + 20) - 1900;
 	tm.tm_hour = make_num(s + 11);
 	tm.tm_min = make_num(s + 14);
 	tm.tm_sec = make_num(s + 17);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: util.c,v 1.64 1998/09/15 07:17:50 wessels Exp $
+ * $Id: util.c,v 1.65 1998/11/12 06:30:16 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -63,6 +63,9 @@
 #if HAVE_MATH_H
 #include <math.h>
 #endif
+#if HAVE_ASSERT_H
+#include <assert.h>
+#endif
 
 #include "util.h"
 #include "snprintf.h"
@@ -563,9 +566,7 @@ xcalloc(int n, size_t sz)
 char *
 xstrdup(const char *s)
 {
-    char *p = NULL;
     size_t sz;
-
     if (s == NULL) {
 	if (failure_notify) {
 	    (*failure_notify) ("xstrdup: tried to dup a NULL pointer!\n");
@@ -574,10 +575,24 @@ xstrdup(const char *s)
 	}
 	exit(1);
     }
+    /* copy string, including terminating character */
+    sz = strlen(s) + 1;
+    return memcpy(xmalloc(sz), s, sz);
+}
+
+/*
+ *  xstrndup() - string dup with length limit.
+ */
+char *
+xstrndup(const char *s, size_t n)
+{
+    size_t sz;
+    assert(s);
+    assert(n);
     sz = strlen(s) + 1;
-    p = xmalloc(sz);
-    memcpy(p, s, sz);		/* copy string, including terminating character */
-    return p;
+    if (sz > n)
+	sz = n;
+    return xstrncpy(xmalloc(sz), s, sz);
 }
 
 /*
@@ -647,13 +662,14 @@ tvSubDsec(struct timeval t1, struct timeval t2)
 char *
 xstrncpy(char *dst, const char *src, size_t n)
 {
+    char *r = dst;
     if (!n || !dst)
 	return dst;
     if (src)
 	while (--n != 0 && *src != '\0')
 	    *dst++ = *src++;
     *dst = '\0';
-    return dst;
+    return r;
 }
 
 /* returns the number of leading white spaces in str; handy in skipping ws */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: CacheDigest.cc,v 1.25 1998/07/22 20:36:40 wessels Exp $
+ * $Id: CacheDigest.cc,v 1.26 1998/11/12 06:27:48 wessels Exp $
  *
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -35,6 +35,8 @@
 
 #include "squid.h"
 
+#if USE_CACHE_DIGESTS
+
 /* local types */
 typedef struct {
     int bit_count;		/* total number of bits */
@@ -316,3 +318,5 @@ cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 	storeKeyText(key), bit_count,
 	hashed_keys[0], hashed_keys[1], hashed_keys[2], hashed_keys[3]);
 }
+
+#endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrRange.cc,v 1.15 1998/09/29 16:33:39 wessels Exp $
+ * $Id: HttpHdrRange.cc,v 1.16 1998/11/12 06:27:49 wessels Exp $
  *
  * DEBUG: section 64    HTTP Range Header
  * AUTHOR: Alex Rousskov
@@ -409,6 +409,21 @@ httpHdrRangeWillBeComplex(const HttpHdrRange * range)
     return 0;
 }
 
+/* hack: returns offset of first range spec */
+size_t
+httpHdrRangeFirstOffset(const HttpHdrRange * range)
+{
+    HttpHdrRangePos pos = HttpHdrRangeInitPos;
+    const HttpHdrRangeSpec *spec;
+    assert(range);
+    while ((spec = httpHdrRangeGetSpec(range, &pos))) {
+	if (!known_spec(spec->offset))	/* ignore unknowns */
+	    continue;
+	return spec->offset;
+    }
+    return 0;
+}
+
 /* generates a "unique" boundary string for multipart responses
  * the caller is responsible for cleaning the string */
 String
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.57 1998/09/29 16:33:40 wessels Exp $
+ * $Id: HttpHeader.cc,v 1.58 1998/11/12 06:27:50 wessels Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -89,7 +89,9 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] =
     {"Expires", HDR_EXPIRES, ftDate_1123},
     {"From", HDR_FROM, ftStr},
     {"Host", HDR_HOST, ftStr},
+    {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
     {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
+    {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
     {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
     {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
     {"Link", HDR_LINK, ftStr},
@@ -137,7 +139,7 @@ static http_hdr_type ListHeadersArr[] =
     HDR_CONTENT_ENCODING,
     HDR_CONTENT_LANGUAGE,
     HDR_CONNECTION,
-    /*  HDR_IF_MATCH, HDR_IF_NONE_MATCH, */
+    HDR_IF_MATCH, HDR_IF_NONE_MATCH,
     HDR_LINK, HDR_PRAGMA,
     /* HDR_TRANSFER_ENCODING, */
     HDR_UPGRADE,
@@ -185,7 +187,8 @@ static http_hdr_type ReplyHeadersArr[] =
 static HttpHeaderMask RequestHeadersMask;	/* set run-time using RequestHeaders */
 static http_hdr_type RequestHeadersArr[] =
 {
-    HDR_AUTHORIZATION, HDR_FROM, HDR_HOST, HDR_IF_MODIFIED_SINCE,
+    HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
+    HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
     HDR_IF_RANGE, HDR_MAX_FORWARDS, HDR_PROXY_CONNECTION,
     HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
     HDR_USER_AGENT, HDR_X_FORWARDED_FOR
@@ -308,15 +311,15 @@ httpHeaderClean(HttpHeader * hdr)
     HttpHeaderStats[hdr->owner].destroyedCount++;
     HttpHeaderStats[hdr->owner].busyDestroyedCount += hdr->entries.count > 0;
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
-	/* tmp hack to avoid coredumps */
-	if (e->id < 0 || e->id >= HDR_ENUM_END)
+	/* tmp hack to try to avoid coredumps */
+	if (e->id < 0 || e->id >= HDR_ENUM_END) {
 	    debug(55, 0) ("httpHeaderClean BUG: entry[%d] is invalid (%d). Ignored.\n",
 		pos, e->id);
-	else
-	    /* end of hack */
+	} else {
+	    statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
 	    /* yes, this destroy() leaves us in an incosistent state */
 	    httpHeaderEntryDestroy(e);
+	}
     }
     arrayClean(&hdr->entries);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpReply.cc,v 1.32 1998/10/15 23:40:04 wessels Exp $
+ * $Id: HttpReply.cc,v 1.33 1998/11/12 06:27:51 wessels Exp $
  *
  * DEBUG: section 58    HTTP Reply (Response)
  * AUTHOR: Alex Rousskov
@@ -266,7 +266,8 @@ httpReplyUpdateOnNotModified(HttpReply * rep, HttpReply * freshRep)
     /* clean cache */
     httpReplyHdrCacheClean(rep);
     /* update raw headers */
-    httpHeaderUpdate(&rep->header, &freshRep->header, &Denied304HeadersMask);
+    httpHeaderUpdate(&rep->header, &freshRep->header,
+	(const HttpHeaderMask *) &Denied304HeadersMask);
     /* init cache */
     httpReplyHdrCacheInit(rep);
 }
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.162 1998/11/11 20:04:09 glenn Exp $
+#  $Id: Makefile.in,v 1.163 1998/11/12 06:27:51 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -173,7 +173,7 @@ OBJS	 	= \
 
 SNMP_OBJS	= \
 		snmp_core.o \
-                snmp_agent.o
+		snmp_agent.o
 
 HTCP_OBJS	= htcp.o
 
@@ -234,7 +234,7 @@ squid.conf cf_parser.c: cf.data cf_gen
 	./cf_gen cf.data
 
 cf_gen: cf_gen.o
-	$(CC) -o $@ cf_gen.o
+	$(CC) -o $@ cf_gen.o $(STD_APP_LIBS)
 
 cf.data: cf.data.pre Makefile
 	sed "\
@@ -248,7 +248,7 @@ cf.data: cf.data.pre Makefile
 	s%@DEFAULT_PID_FILE@%$(DEFAULT_PID_FILE)%g;\
 	s%@DEFAULT_SWAP_DIR@%$(DEFAULT_SWAP_DIR)%g;\
 	s%@DEFAULT_ICON_DIR@%$(DEFAULT_ICON_DIR)%g;\
-        s%@DEFAULT_MIB_PATH@%$(DEFAULT_MIB_PATH)%g;\
+	s%@DEFAULT_MIB_PATH@%$(DEFAULT_MIB_PATH)%g;\
 	s%@DEFAULT_ERROR_DIR@%$(DEFAULT_ERROR_DIR)%g;\
 	s%@DEFAULT_PREFIX@%$(DEFAULT_PREFIX)%g;"\
 	< $(srcdir)/cf.data.pre >$@
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StatHist.cc,v 1.18 1998/10/19 22:36:56 wessels Exp $
+ * $Id: StatHist.cc,v 1.19 1998/11/12 06:27:52 wessels Exp $
  *
  * DEBUG: section 62    Generic Histogram
  * AUTHOR: Duane Wessels
@@ -273,7 +273,7 @@ statHistEnumDumper(StoreEntry * sentry, int idx, double val, double size, int co
 void
 statHistIntInit(StatHist * H, int n)
 {
-    statHistInit(H, n, Null, Null, 0, n - 1);
+    statHistInit(H, n, Null, Null, (double) 0, (double) n - 1);
 }
 
 void
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: access_log.cc,v 1.43 1998/09/30 02:53:17 wessels Exp $
+ * $Id: access_log.cc,v 1.44 1998/11/12 06:27:53 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -192,12 +192,13 @@ accessLogCommon(AccessLogEntry * al, MemBuf * mb)
 	client = fqdncache_gethostbyaddr(al->cache.caddr, 0);
     if (client == NULL)
 	client = inet_ntoa(al->cache.caddr);
-    memBufPrintf(mb, "%s %s - [%s] \"%s %s\" %d %d %s:%s",
+    memBufPrintf(mb, "%s %s - [%s] \"%s %s HTTP/%.1f\" %d %d %s:%s",
 	client,
 	al->cache.ident,
 	mkhttpdlogtime(&squid_curtime),
 	al->private.method_str,
 	al->url,
+	al->http.version,
 	al->http.code,
 	al->cache.size,
 	log_tags[al->cache.code],
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.186 1998/11/11 20:04:10 glenn Exp $
+ * $Id: acl.cc,v 1.187 1998/11/12 06:27:54 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -38,6 +38,7 @@
 
 static int aclFromFile = 0;
 static FILE *aclFile;
+static hash_table *proxy_auth_cache = NULL;
 
 static void aclParseDomainList(void *curlist);
 static void aclParseIpList(void *curlist);
@@ -50,13 +51,12 @@ static void aclParseIntRange(void *curlist);
 static char *strtokFile(void);
 static void aclDestroyAclList(acl_list * list);
 static void aclDestroyTimeList(acl_time_data * data);
-static void aclDestroyProxyAuth(acl_proxy_auth * p);
 static void aclDestroyIntRange(intrange *);
 static FREE aclFreeProxyAuthUser;
 static int aclMatchAcl(struct _acl *, aclCheck_t *);
 static int aclMatchIntegerRange(intrange * data, int i);
 static int aclMatchTime(acl_time_data * data, time_t when);
-static int aclMatchIdent(wordlist * data, const char *ident);
+static int aclMatchUser(wordlist * data, const char *ident);
 static int aclMatchIp(void *dataptr, struct in_addr c);
 static int aclMatchDomainList(void *dataptr, const char *);
 static int aclMatchIntegerRange(intrange * data, int i);
@@ -69,7 +69,8 @@ static IPH aclLookupDstIPDone;
 static IPH aclLookupDstIPforASNDone;
 static FQDNH aclLookupSrcFQDNDone;
 static FQDNH aclLookupDstFQDNDone;
-static void aclProxyAuthDone(void *data, char *result);
+static void aclLookupProxyAuthStart(aclCheck_t * checklist);
+static void aclLookupProxyAuthDone(void *data, char *result);
 static wordlist *aclDumpIpList(void *);
 static wordlist *aclDumpDomainList(void *data);
 static wordlist *aclDumpTimeSpecList(acl_time_data *);
@@ -78,12 +79,12 @@ static wordlist *aclDumpIntlistList(intlist * data);
 static wordlist *aclDumpIntRangeList(intrange * data);
 static wordlist *aclDumpProtoList(intlist * data);
 static wordlist *aclDumpMethodList(intlist * data);
-static wordlist *aclDumpProxyAuthList(acl_proxy_auth * data);
 static SPLAYCMP aclIpNetworkCompare;
 static SPLAYCMP aclHostDomainCompare;
 static SPLAYCMP aclDomainCompare;
 static SPLAYWALKEE aclDumpIpListWalkee;
 static SPLAYWALKEE aclDumpDomainListWalkee;
+static SPLAYFREE aclFreeIpData;
 
 #if USE_ARP_ACL
 static void aclParseArpList(void *curlist);
@@ -129,6 +130,12 @@ strtokFile(void)
 	/* skip leading and trailing white space */
 	t += strspn(buf, w_space);
 	t[strcspn(t, w_space)] = '\0';
+	/* skip comments */
+	if (*t == '#')
+	    goto strtok_again;
+	/* skip blank lines */
+	if (!*t)
+	    goto strtok_again;
 	return t;
     }
 }
@@ -160,8 +167,8 @@ aclStrToType(const char *s)
 	return ACL_URL_REGEX;
     if (!strcmp(s, "port"))
 	return ACL_URL_PORT;
-    if (!strcmp(s, "user"))
-	return ACL_USER;
+    if (!strcmp(s, "ident"))
+	return ACL_IDENT;
     if (!strncmp(s, "proto", 5))
 	return ACL_PROTO;
     if (!strcmp(s, "method"))
@@ -210,8 +217,8 @@ aclTypeToStr(squid_acl type)
 	return "url_regex";
     if (type == ACL_URL_PORT)
 	return "port";
-    if (type == ACL_USER)
-	return "user";
+    if (type == ACL_IDENT)
+	return "ident";
     if (type == ACL_PROTO)
 	return "proto";
     if (type == ACL_METHOD)
@@ -255,7 +262,7 @@ aclParseIntlist(void *curlist)
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(intlist));
+	q = memAllocate(MEM_INTLIST);
 	q->i = atoi(t);
 	*(Tail) = q;
 	Tail = &q->next;
@@ -290,7 +297,7 @@ aclParseProtoList(void *curlist)
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(intlist));
+	q = memAllocate(MEM_INTLIST);
 	q->i = (int) urlParseProtocol(t);
 	*(Tail) = q;
 	Tail = &q->next;
@@ -305,7 +312,7 @@ aclParseMethodList(void *curlist)
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(intlist));
+	q = memAllocate(MEM_INTLIST);
 	q->i = (int) urlParseMethod(t);
 	if (q->i == METHOD_PURGE)
 	    Config.onoff.enable_purge = 1;
@@ -372,7 +379,7 @@ aclParseIpData(const char *t)
     LOCAL_ARRAY(char, addr1, 256);
     LOCAL_ARRAY(char, addr2, 256);
     LOCAL_ARRAY(char, mask, 256);
-    acl_ip_data *q = xcalloc(1, sizeof(acl_ip_data));
+    acl_ip_data *q = memAllocate(MEM_ACL_IP_DATA);
     acl_ip_data *r;
     acl_ip_data **Q;
     struct hostent *hp;
@@ -408,7 +415,7 @@ aclParseIpData(const char *t)
 	Q = &q;
 	for (x = hp->h_addr_list; x != NULL && *x != NULL; x++) {
 	    if ((r = *Q) == NULL)
-		r = *Q = xcalloc(1, sizeof(struct _acl_ip_data));
+		r = *Q = memAllocate(MEM_ACL_IP_DATA);
 	    xmemcpy(&r->addr1.s_addr, *x, sizeof(r->addr1.s_addr));
 	    r->addr2.s_addr = 0;
 	    r->mask.s_addr = no_addr.s_addr;	/* 255.255.255.255 */
@@ -478,7 +485,7 @@ aclParseTimeSpec(void *curlist)
     int h1, m1, h2, m2;
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
-    q = xcalloc(1, sizeof(acl_time_data));
+    q = memAllocate(MEM_ACL_TIME_DATA);
     while ((t = strtokFile())) {
 	if (*t < '0' || *t > '9') {
 	    /* assume its day-of-week spec */
@@ -575,7 +582,7 @@ aclParseRegexList(void *curlist)
 		t, errbuf);
 	    continue;
 	}
-	q = xcalloc(1, sizeof(relist));
+	q = memAllocate(MEM_RELIST);
 	q->pattern = xstrdup(t);
 	q->regex = comp;
 	*(Tail) = q;
@@ -586,16 +593,9 @@ aclParseRegexList(void *curlist)
 static void
 aclParseWordList(void *curlist)
 {
-    wordlist **Tail;
-    wordlist *q = NULL;
     char *t = NULL;
-    for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
-    while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(wordlist));
-	q->key = xstrdup(t);
-	*(Tail) = q;
-	Tail = &q->next;
-    }
+    while ((t = strtokFile()))
+	wordlistAdd(curlist, t);
 }
 
 /**********************/
@@ -676,7 +676,7 @@ aclParseAclLine(acl ** head)
     }
     if ((A = aclFindByName(aclname)) == NULL) {
 	debug(28, 3) ("aclParseAclLine: Creating ACL '%s'\n", aclname);
-	A = xcalloc(1, sizeof(acl));
+	A = memAllocate(MEM_ACL);
 	xstrncpy(A->name, aclname, ACL_NAME_SZ);
 	A->type = acltype;
 	A->cfgline = xstrdup(config_input_line);
@@ -715,7 +715,7 @@ aclParseAclLine(acl ** head)
     case ACL_URL_PORT:
 	aclParseIntRange(&A->data);
 	break;
-    case ACL_USER:
+    case ACL_IDENT:
 	Config.onoff.ident_lookup = 1;
 	aclParseWordList(&A->data);
 	break;
@@ -729,13 +729,13 @@ aclParseAclLine(acl ** head)
 	aclParseRegexList(&A->data);
 	break;
     case ACL_PROXY_AUTH:
-	aclParseProxyAuth(&A->data);
-	break;
-#if SQUID_SNMP
-    case ACL_SNMP_COMMUNITY:
 	aclParseWordList(&A->data);
+	if (!proxy_auth_cache) {
+	    /* First time around, 7921 should be big enough */
+	    proxy_auth_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
+	    assert(proxy_auth_cache);
+	}
 	break;
-#endif
 #if USE_ARP_ACL
     case ACL_SRC_ARP:
 	aclParseArpList(&A->data);
@@ -851,7 +851,7 @@ aclParseAccessLine(acl_access ** head)
 	debug(28, 0) ("aclParseAccessLine: missing 'allow' or 'deny'.\n");
 	return;
     }
-    A = xcalloc(1, sizeof(acl_access));
+    A = memAllocate(MEM_ACL_ACCESS);
 
     if (!strcmp(t, "allow"))
 	A->allow = 1;
@@ -869,7 +869,7 @@ aclParseAccessLine(acl_access ** head)
      * by '!' for negation */
     Tail = &A->acl_list;
     while ((t = strtok(NULL, w_space))) {
-	L = xcalloc(1, sizeof(acl_list));
+	L = memAllocate(MEM_ACL_LIST);
 	L->op = 1;		/* defaults to non-negated */
 	if (*t == '!') {
 	    /* negated ACL */
@@ -901,7 +901,7 @@ aclParseAccessLine(acl_access ** head)
     for (B = *head, T = head; B; T = &B->next, B = B->next);
     *T = A;
     /* We lock _acl_access structures in aclCheck() */
-    cbdataAdd(A, MEM_NONE);
+    cbdataAdd(A, MEM_ACL_ACCESS);
 }
 
 /**************/
@@ -963,109 +963,159 @@ aclMatchRegex(relist * data, const char *word)
 }
 
 static int
-aclMatchIdent(wordlist * data, const char *ident)
+aclMatchUser(wordlist * data, const char *user)
 {
-    if (ident == NULL)
+    if (user == NULL)
 	return 0;
-    debug(28, 3) ("aclMatchIdent: checking '%s'\n", ident);
+    debug(28, 3) ("aclMatchUser: checking '%s'\n", user);
     while (data) {
-	debug(28, 3) ("aclMatchIdent: looking for '%s'\n", data->key);
-	if (strcmp(data->key, "REQUIRED") == 0 && *ident != '\0')
+	debug(28, 3) ("aclMatchUser: looking for '%s'\n", data->key);
+	if (strcmp(data->key, "REQUIRED") == 0 && *user != '\0')
 	    return 1;
-	if (strcmp(data->key, ident) == 0)
+	if (strcmp(data->key, user) == 0)
 	    return 1;
 	data = data->next;
     }
     return 0;
 }
 
-/* aclMatchProxyAuth can return three exit codes:
- * 0 : No such user; invalid Proxy-authorization: header;
- * ask for Proxy-Authorization: header
- * 1 : user validated OK
- * -1 : check the password for this user via an external authenticator
- */
-
 static int
-aclMatchProxyAuth(acl_proxy_auth * p, aclCheck_t * checklist)
+aclDecodeProxyAuth(const char *proxy_auth, char **user, char **password, char *buf, size_t bufsize)
 {
-    LOCAL_ARRAY(char, sent_user, USER_IDENT_SZ);
-    const char *s;
-    char *cleartext;
     char *sent_auth;
-    char *passwd = NULL;
-    acl_proxy_auth_user *u;
-    s = httpHeaderGetStr(&checklist->request->header, HDR_PROXY_AUTHORIZATION);
-    if (s == NULL)
+    char *cleartext;
+
+    if (proxy_auth == NULL)
 	return 0;
-    if (strlen(s) < SKIP_BASIC_SZ)
+    if (strlen(proxy_auth) < SKIP_BASIC_SZ)
 	return 0;
-    s += SKIP_BASIC_SZ;
-    sent_auth = xstrdup(s);	/* username and password */
+    proxy_auth += SKIP_BASIC_SZ;
+    sent_auth = xstrdup(proxy_auth);	/* username and password */
     /* Trim trailing \n before decoding */
     strtok(sent_auth, "\n");
+    /* Trim leading whitespace before decoding */
+    while (isspace(*proxy_auth))
+	proxy_auth++;
     cleartext = uudecode(sent_auth);
     xfree(sent_auth);
-    debug(28, 6) ("aclMatchProxyAuth: cleartext = '%s'\n", cleartext);
-    xstrncpy(sent_user, cleartext, USER_IDENT_SZ);
+    debug(28, 6) ("aclDecodeProxyAuth: cleartext = '%s'\n", cleartext);
+    xstrncpy(buf, cleartext, bufsize);
     xfree(cleartext);
-    if ((passwd = strchr(sent_user, ':')) != NULL)
-	*passwd++ = '\0';
-    if (passwd == NULL) {
-	debug(28, 1) ("aclMatchProxyAuth: no passwd in proxy authorization header\n");
+    *user = buf;
+    if ((*password = strchr(*user, ':')) != NULL)
+	*(*password)++ = '\0';
+    if (password == NULL) {
+	debug(28, 1) ("aclDecodeProxyAuth: no password in proxy authorization header\n");
 	return 0;
     }
-    debug(28, 5) ("aclMatchProxyAuth: checking user '%s'\n", sent_user);
-    /* copy username to checklist for logging on client-side */
-    xstrncpy(checklist->request->user_ident, sent_user, USER_IDENT_SZ);
+    return 1;
+}
 
-    /* see if we already know this user */
-    u = hash_lookup(p->hash, sent_user);
-    if (NULL == u) {
-	/* user not yet known, ask external authenticator */
-	debug(28, 4) ("aclMatchProxyAuth: user '%s' not yet known\n", sent_user);
-    } else {
-	/* user already known, check password with the cached one */
-	if ((0 == strcmp(u->passwd, passwd)) &&
-	    (u->expiretime > current_time.tv_sec)) {
+/* aclMatchProxyAuth can return three exit codes:
+ * 0 : No such user; invalid Proxy-authorization: header;
+ * ask for Proxy-Authorization: header
+ * 1 : user validated OK
+ * -1 : check the password for this user via an external authenticator
+ */
+
+static int
+aclMatchProxyAuth(const char *proxy_auth, acl_proxy_auth_user * auth_user, aclCheck_t * checklist)
+{
+    /* checklist is used to register user name when identified, nothing else */
+    LOCAL_ARRAY(char, login_buf, USER_IDENT_SZ);
+    char *user, *password;
+
+    if (!aclDecodeProxyAuth(proxy_auth, &user, &password, login_buf, sizeof(login_buf)))
+	/* No or invalid Proxy-Auth header */
+	return 0;
+
+    debug(28, 5) ("aclMatchProxyAuth: checking user '%s'\n", user);
+
+    if (!auth_user) {
+	/* see if we already know this user */
+	auth_user = hash_lookup(proxy_auth_cache, user);
+	if (!auth_user) {
+	    /* user not yet known, ask external authenticator */
+	    debug(28, 4) ("aclMatchProxyAuth: user '%s' not yet known\n", user);
+	    return -1;
+	} else if ((0 == strcmp(auth_user->passwd, password)) &&
+	    (auth_user->expiretime > current_time.tv_sec)) {
+	    /* user already known and valid */
 	    debug(28, 5) ("aclMatchProxyAuth: user '%s' previously validated\n",
-		sent_user);
+		user);
+	    /* copy username to request for logging on client-side */
+	    xstrncpy(checklist->request->user_ident, user, USER_IDENT_SZ);
 	    return 1;
+	} else {
+	    /* password mismatch/timeout */
+	    debug(28, 4) ("aclMatchProxyAuth: user '%s' password mismatch/timeout\n",
+		user);
+	    /* remove this user from the hash, making him unknown */
+	    hash_remove_link(proxy_auth_cache, (hash_link *) auth_user);
+	    aclFreeProxyAuthUser(auth_user);
+	    /* copy username to request for logging on client-side unless ident
+	     * is known (do not override ident with false proxy auth names) */
+	    if (!*checklist->request->user_ident)
+		xstrncpy(checklist->request->user_ident, user, USER_IDENT_SZ);
+	    return -1;
 	}
-	/* password mismatch/timeout */
-	debug(28, 4) ("aclMatchProxyAuth: user '%s' password mismatch/timeout\n",
-	    sent_user);
-	/* remove this user from the hash, making him unknown */
-	hash_remove_link(p->hash, (hash_link *) u);
-	aclFreeProxyAuthUser(u);
-    }
-
-    /* we've got an unknown user now */
-    if (checklist->auth_user == NULL) {
-	/* we must still check this user's password */
-	u = memAllocate(MEM_ACL_PROXY_AUTH_USER);
-	u->user = xstrdup(sent_user);
-	u->passwd = xstrdup(passwd);
-	u->passwd_ok = 0;
-	u->expiretime = 0;
-	checklist->auth_user = u;
-	debug(28, 4) ("aclMatchProxyAuth: going to ask authenticator\n");
-	return -1;
+	/* NOTREACHED */
+    } else {
+	/* Check result from external validation */
+	if (checklist->auth_user->passwd_ok != 1) {
+	    /* password was checked but did not match */
+	    assert(checklist->auth_user->passwd_ok == 0);
+	    debug(28, 4) ("aclMatchProxyAuth: authentication failed for user '%s'\n",
+		user);
+	    return 0;
+	}
+	debug(28, 4) ("aclMatchProxyAuth: user '%s' validated OK\n", user);
+	/* store validated user in hash, after filling in expiretime */
+	checklist->auth_user->expiretime = current_time.tv_sec + Config.authenticateTTL;
+	hash_join(proxy_auth_cache, (hash_link *) checklist->auth_user);
+
+	return 1;
     }
-    /* checklist->auth_user has just been checked, check result */
-    if (checklist->auth_user->passwd_ok == -1) {
-	/* password was checked but did not match */
-	debug(28, 4) ("aclMatchProxyAuth: authentication failed for user '%s'\n",
-	    sent_user);
-	return 0;
+
+    /* NOTREACHED */
+
+}
+
+static void
+aclLookupProxyAuthStart(aclCheck_t * checklist)
+{
+    LOCAL_ARRAY(char, login_buf, USER_IDENT_SZ);
+    const char *proxy_auth;
+    char *user, *password;
+    int ok;
+    acl_proxy_auth_user *auth_user;
+
+    assert(!checklist->auth_user);
+
+    if (!checklist->request->flags.accelerated) {
+	/* Proxy auth on proxy requests */
+	proxy_auth = httpHeaderGetStr(&checklist->request->header,
+	    HDR_PROXY_AUTHORIZATION);
+    } else {
+	/* WWW auth on accelerated requests */
+	proxy_auth = httpHeaderGetStr(&checklist->request->header,
+	    HDR_AUTHORIZATION);
     }
-    /* checklist->auth_user->passwd_ok == 1, passwd check OK */
-    debug(28, 4) ("aclMatchProxyAuth: user '%s' validated OK\n", sent_user);
-    /* store validated user in hash, after filling in expiretime */
-    checklist->auth_user->expiretime = current_time.tv_sec + p->timeout;
-    hash_join(p->hash, (hash_link *) checklist->auth_user);
+    ok = aclDecodeProxyAuth(proxy_auth, &user, &password, login_buf,
+	sizeof(login_buf));
+    assert(ok);			/* We should never get here unless the above succeeds in aclMatchProxyAuth */
 
-    return 1;
+    debug(28, 4) ("aclLookupProxyAuthStart: going to ask authenticator on %s\n", user);
+    /* we must still check this user's password */
+    auth_user = memAllocate(MEM_ACL_PROXY_AUTH_USER);
+    auth_user->user = xstrdup(user);
+    auth_user->passwd = xstrdup(password);
+    auth_user->passwd_ok = -1;
+    auth_user->expiretime = -1;
+    checklist->auth_user = auth_user;
+
+    authenticateStart(checklist->auth_user, aclLookupProxyAuthDone,
+	checklist);
 }
 
 static int
@@ -1140,12 +1190,12 @@ aclMatchTime(acl_time_data * data, time_t when)
 }
 
 static int
-aclMatchWordList(wordlist * w, const char *community)
+aclMatchWordList(wordlist * w, const char *word)
 {
-    debug(28, 3) ("aclMatchWordList: looking for '%s'\n", community);
+    debug(28, 3) ("aclMatchWordList: looking for '%s'\n", word);
     while (w != NULL) {
 	debug(28, 3) ("aclMatchWordList: checking '%s'\n", w->key);
-	if (!strcmp(w->key, community))
+	if (!strcmp(w->key, word))
 	    return 1;
 	w = w->next;
     }
@@ -1256,8 +1306,8 @@ aclMatchAcl(acl * ae, aclCheck_t * checklist)
     case ACL_URL_PORT:
 	return aclMatchIntegerRange(ae->data, r->port);
 	/* NOTREACHED */
-    case ACL_USER:
-	return aclMatchIdent(ae->data, checklist->ident);
+    case ACL_IDENT:
+	return aclMatchUser(ae->data, checklist->ident);
 	/* NOTREACHED */
     case ACL_PROTO:
 	return aclMatchInteger(ae->data, r->protocol);
@@ -1269,19 +1319,51 @@ aclMatchAcl(acl * ae, aclCheck_t * checklist)
 	return aclMatchRegex(ae->data, checklist->browser);
 	/* NOTREACHED */
     case ACL_PROXY_AUTH:
-	k = aclMatchProxyAuth(ae->data, checklist);
+	if (!r->flags.accelerated) {
+	    /* Proxy authorization on proxy requests */
+	    k = aclMatchProxyAuth(httpHeaderGetStr(&checklist->request->header,
+		    HDR_PROXY_AUTHORIZATION),
+		checklist->auth_user,
+		checklist);
+	} else if (r->flags.internal) {
+	    /* WWW authorization on accelerated internal requests */
+	    k = aclMatchProxyAuth(httpHeaderGetStr(&checklist->request->header,
+		    HDR_AUTHORIZATION),
+		checklist->auth_user,
+		checklist);
+	} else {
+#if AUTH_ON_ACCELERATION
+	    /* WWW authorization on accelerated requests */
+	    k = aclMatchProxyAuth(httpHeaderGetStr(&checklist->request->header,
+		    HDR_AUTHORIZATION),
+		checklist->auth_user,
+		checklist);
+#else
+	    debug(28, 1) ("aclMatchAcl: proxy_auth %s not applicable on accelerated requests.\n", ae->name);
+	    return -1;
+#endif
+	}
 	if (k == 0) {
 	    /* no such user OR we need a proxy authentication header */
 	    checklist->state[ACL_PROXY_AUTH] = ACL_PROXY_AUTH_NEEDED;
+	    /*
+	     * XXX This is a bit oddly done.. should perhaps use different
+	     * return codes here
+	     */
 	    return 0;
 	} else if (k == 1) {
-	    /* register that we used the proxy authentication header */
-	    checklist->state[ACL_PROXY_AUTH] = ACL_PROXY_AUTH_USED;
+	    /*
+	     * Authentication successful. Register that we used the proxy
+	     * authentication header so that it is not forwarded to the
+	     * next proxy
+	     */
 	    r->flags.used_proxy_auth = 1;
 	    return 1;
 	} else if (k == -1) {
-	    /* register that we need to check the password */
-	    checklist->state[ACL_PROXY_AUTH] = ACL_PROXY_AUTH_CHECK;
+	    /*
+	     * we need to validate the password
+	     */
+	    checklist->state[ACL_PROXY_AUTH] = ACL_LOOKUP_NEEDED;
 	    return 0;
 	}
 	/* NOTREACHED */
@@ -1372,7 +1454,6 @@ aclCheck(aclCheck_t * checklist)
 	debug(28, 3) ("aclCheck: checking '%s'\n", A->cfgline);
 	allow = A->allow;
 	match = aclMatchAclList(A->acl_list, checklist);
-
 	if (checklist->state[ACL_DST_IP] == ACL_LOOKUP_NEEDED) {
 	    checklist->state[ACL_DST_IP] = ACL_LOOKUP_PENDING;
 	    ipcache_nbgethostbyname(checklist->request->host,
@@ -1403,26 +1484,29 @@ aclCheck(aclCheck_t * checklist)
 		aclLookupDstFQDNDone,
 		checklist);
 	    return;
-	}
-	/* extra case for proxy_auth */
-	if (checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_CHECK) {
+	} else if (checklist->state[ACL_PROXY_AUTH] == ACL_LOOKUP_NEEDED) {
 	    debug(28, 3) ("aclCheck: checking password via authenticator\n");
-	    authenticateStart(checklist->auth_user, aclProxyAuthDone,
-		checklist);
+	    aclLookupProxyAuthStart(checklist);
+	    checklist->state[ACL_PROXY_AUTH] = ACL_LOOKUP_PENDING;
+	    return;
+	} else if (checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_NEEDED) {
+	    /* Special case. Client is required to resend the request
+	     * with authentication. The request is denied.
+	     */
+	    allow = ACCESS_REQ_PROXY_AUTH;
+	    match = -1;
+	} else if (checklist->state[ACL_IDENT] == ACL_LOOKUP_NEEDED) {
+	    debug(28, 3) ("aclCheck: Doing ident lookup\n");
+	    /* XXX how to do ident lookup? */
+	    checklist->state[ACL_IDENT] = ACL_LOOKUP_PENDING;
 	    return;
 	}
 	/*
 	 * We are done with this _acl_access entry.  Either the request
-	 * is allowed, denied, or we move on to the next entry.
+	 * is allowed, denied, requires authentication, or we move on to
+	 * the next entry.
 	 */
 	cbdataUnlock(A);
-	if (checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_NEEDED) {
-	    allow = ACCESS_REQ_PROXY_AUTH;
-	    debug(28, 3) ("aclCheck: match pending, returning %d\n", allow);
-	    aclCheckCallback(checklist, allow);
-	    return;
-	}
-	/* checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_USED */
 	if (match) {
 	    debug(28, 3) ("aclCheck: match found, returning %d\n", allow);
 	    aclCheckCallback(checklist, allow);
@@ -1499,15 +1583,16 @@ aclLookupDstFQDNDone(const char *fqdn, void *data)
 }
 
 static void
-aclProxyAuthDone(void *data, char *result)
+aclLookupProxyAuthDone(void *data, char *result)
 {
     aclCheck_t *checklist = data;
     checklist->state[ACL_PROXY_AUTH] = ACL_LOOKUP_DONE;
-    debug(28, 4) ("aclProxyAuthDone: result = %s\n", result);
+    debug(28, 4) ("aclLookupProxyAuthDone: result = %s\n",
+	result ? result : "NULL");
     if (result && (strncasecmp(result, "OK", 2) == 0))
 	checklist->auth_user->passwd_ok = 1;
     else
-	checklist->auth_user->passwd_ok = -1;
+	checklist->auth_user->passwd_ok = 0;
     aclCheck(checklist);
 }
 
@@ -1519,8 +1604,8 @@ aclChecklistCreate(const acl_access * A,
     const char *ident)
 {
     int i;
-    aclCheck_t *checklist = xcalloc(1, sizeof(aclCheck_t));
-    cbdataAdd(checklist, MEM_NONE);
+    aclCheck_t *checklist = memAllocate(MEM_ACLCHECK_T);
+    cbdataAdd(checklist, MEM_ACLCHECK_T);
     checklist->access_list = A;
     /*
      * aclCheck() makes sure checklist->access_list is a valid
@@ -1565,7 +1650,7 @@ aclDestroyTimeList(acl_time_data * data)
     acl_time_data *next = NULL;
     for (; data; data = next) {
 	next = data->next;
-	safe_free(data);
+	memFree(MEM_ACL_TIME_DATA, data);
     }
 }
 
@@ -1577,7 +1662,7 @@ aclDestroyRegexList(relist * data)
 	next = data->next;
 	regfree(&data->regex);
 	safe_free(data->pattern);
-	safe_free(data);
+	memFree(MEM_RELIST, data);
     }
 }
 
@@ -1591,12 +1676,9 @@ aclFreeProxyAuthUser(void *data)
 }
 
 static void
-aclDestroyProxyAuth(acl_proxy_auth * p)
+aclFreeIpData(void *p)
 {
-    hashFreeItems(p->hash, aclFreeProxyAuthUser);
-    hashFreeMemory(p->hash);
-    p->hash = NULL;
-    safe_free(p);
+    memFree(MEM_ACL_IP_DATA, p);
 }
 
 void
@@ -1610,17 +1692,18 @@ aclDestroyAcls(acl ** head)
 	switch (a->type) {
 	case ACL_SRC_IP:
 	case ACL_DST_IP:
-	case ACL_SRC_ARP:
-	    splay_destroy(a->data, xfree);
+	    splay_destroy(a->data, aclFreeIpData);
 	    break;
+	case ACL_SRC_ARP:
 	case ACL_DST_DOMAIN:
 	case ACL_SRC_DOMAIN:
 	    splay_destroy(a->data, xfree);
 	    break;
-	case ACL_USER:
 #if SQUID_SNMP
 	case ACL_SNMP_COMMUNITY:
 #endif
+	case ACL_IDENT:
+	case ACL_PROXY_AUTH:
 	    wordlistDestroy((wordlist **) & a->data);
 	    break;
 	case ACL_TIME:
@@ -1640,16 +1723,13 @@ aclDestroyAcls(acl ** head)
 	case ACL_URL_PORT:
 	    aclDestroyIntRange(a->data);
 	    break;
-	case ACL_PROXY_AUTH:
-	    aclDestroyProxyAuth(a->data);
-	    break;
 	case ACL_NONE:
 	default:
 	    assert(0);
 	    break;
 	}
 	safe_free(a->cfgline);
-	safe_free(a);
+	memFree(MEM_ACL, a);
     }
     *head = NULL;
 }
@@ -1660,7 +1740,7 @@ aclDestroyAclList(acl_list * list)
     acl_list *next = NULL;
     for (; list; list = next) {
 	next = list->next;
-	safe_free(list);
+	memFree(MEM_ACL_LIST, list);
     }
 }
 
@@ -1813,16 +1893,13 @@ aclDumpIpListWalkee(void *node, void *state)
     acl_ip_data *ip = node;
     MemBuf mb;
     wordlist **W = state;
-    while (*W != NULL)
-	W = &(*W)->next;
     memBufDefInit(&mb);
     memBufPrintf(&mb, "%s", inet_ntoa(ip->addr1));
     if (ip->addr2.s_addr != any_addr.s_addr)
 	memBufPrintf(&mb, "-%s", inet_ntoa(ip->addr2));
     if (ip->mask.s_addr != no_addr.s_addr)
 	memBufPrintf(&mb, "/%s", inet_ntoa(ip->mask));
-    *W = xcalloc(1, sizeof(wordlist));
-    (*W)->key = xstrdup(mb.buf);
+    wordlistAdd(W, mb.buf);
     memBufClean(&mb);
 }
 
@@ -1838,11 +1915,7 @@ static void
 aclDumpDomainListWalkee(void *node, void *state)
 {
     char *domain = node;
-    wordlist **W = state;
-    while (*W != NULL)
-	W = &(*W)->next;
-    *W = xcalloc(1, sizeof(wordlist));
-    (*W)->key = xstrdup(domain);
+    wordlistAdd(state, domain);
 }
 
 static wordlist *
@@ -1857,10 +1930,8 @@ static wordlist *
 aclDumpTimeSpecList(acl_time_data * t)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
     char buf[128];
     while (t != NULL) {
-	wordlist *w = xcalloc(1, sizeof(wordlist));
 	snprintf(buf, sizeof(buf), "%c%c%c%c%c%c%c %02d:%02d-%02d:%02d",
 	    t->weekbits & ACL_SUNDAY ? 'S' : '-',
 	    t->weekbits & ACL_MONDAY ? 'M' : '-',
@@ -1873,9 +1944,7 @@ aclDumpTimeSpecList(acl_time_data * t)
 	    t->start % 60,
 	    t->stop / 60,
 	    t->stop % 60);
-	w->key = xstrdup(buf);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, buf);
 	t = t->next;
     }
     return W;
@@ -1885,13 +1954,8 @@ static wordlist *
 aclDumpRegexList(relist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
-    wordlist *w;
     while (data != NULL) {
-	w = xcalloc(1, sizeof(wordlist));
-	w->key = xstrdup(data->pattern);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, data->pattern);
 	data = data->next;
     }
     return W;
@@ -1901,14 +1965,10 @@ static wordlist *
 aclDumpIntlistList(intlist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
     char buf[32];
     while (data != NULL) {
-	wordlist *w = xcalloc(1, sizeof(wordlist));
 	snprintf(buf, sizeof(buf), "%d", data->i);
-	w->key = xstrdup(buf);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, buf);
 	data = data->next;
     }
     return W;
@@ -1918,17 +1978,13 @@ static wordlist *
 aclDumpIntRangeList(intrange * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
     char buf[32];
     while (data != NULL) {
-	wordlist *w = xcalloc(1, sizeof(wordlist));
 	if (data->i == data->j)
 	    snprintf(buf, sizeof(buf), "%d", data->i);
 	else
 	    snprintf(buf, sizeof(buf), "%d-%d", data->i, data->j);
-	w->key = xstrdup(buf);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, buf);
 	data = data->next;
     }
     return W;
@@ -1938,13 +1994,8 @@ static wordlist *
 aclDumpProtoList(intlist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
-    wordlist *w;
     while (data != NULL) {
-	w = xcalloc(1, sizeof(wordlist));
-	w->key = xstrdup(ProtocolStr[data->i]);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, ProtocolStr[data->i]);
 	data = data->next;
     }
     return W;
@@ -1954,47 +2005,29 @@ static wordlist *
 aclDumpMethodList(intlist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
-    wordlist *w;
     while (data != NULL) {
-	w = xcalloc(1, sizeof(wordlist));
-	w->key = xstrdup(RequestMethodStr[data->i]);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, RequestMethodStr[data->i]);
 	data = data->next;
     }
     return W;
 }
 
-static wordlist *
-aclDumpProxyAuthList(acl_proxy_auth * data)
-{
-    wordlist *W = NULL;
-    wordlist **T = &W;
-    char buf[MAXPATHLEN];
-    wordlist *w = xcalloc(1, sizeof(wordlist));
-    assert(data != NULL);
-    snprintf(buf, sizeof(buf), "%d\n", data->timeout);
-    w->key = xstrdup(buf);
-    *T = w;
-    T = &w->next;
-    return W;
-}
-
 wordlist *
 aclDumpGeneric(const acl * a)
 {
+    debug(28, 3) ("aclDumpGeneric: %s type %d\n", a->name, a->type);
     switch (a->type) {
     case ACL_SRC_IP:
     case ACL_DST_IP:
 	return aclDumpIpList(a->data);
 	break;
     case ACL_SRC_DOMAIN:
     case ACL_DST_DOMAIN:
-    case ACL_USER:
 #if SQUID_SNMP
     case ACL_SNMP_COMMUNITY:
 #endif
+    case ACL_IDENT:
+    case ACL_PROXY_AUTH:
 	return aclDumpDomainList(a->data);
 	break;
     case ACL_TIME:
@@ -2018,9 +2051,6 @@ aclDumpGeneric(const acl * a)
     case ACL_METHOD:
 	return aclDumpMethodList(a->data);
 	break;
-    case ACL_PROXY_AUTH:
-	return aclDumpProxyAuthList(a->data);
-	break;
 #if USE_ARP_ACL
     case ACL_SRC_ARP:
 	return aclDumpArpList(a->data);
@@ -2252,8 +2282,7 @@ aclDumpArpListWalkee(void *node, void *state)
     snprintf(buf, sizeof(buf), "%02x:%02x:02x:02x:02x:02x",
 	arp->eth[0], arp->eth[1], arp->eth[2], arp->eth[3],
 	arp->eth[4], arp->eth[5]);
-    *W = xcalloc(1, sizeof(wordlist));
-    (*W)->key = xstrdup(buf);
+    wordlistAdd(state, buf);
 }
 
 static wordlist *
@@ -1,5 +1,5 @@
 /*
- * $Id: asn.cc,v 1.50 1998/10/21 06:54:18 wessels Exp $
+ * $Id: asn.cc,v 1.51 1998/11/12 06:27:55 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -151,7 +151,7 @@ asnInit(void)
     static int inited = 0;
     max_keylen = 40;
     if (0 == inited++)
-        rn_init();
+	rn_init();
     rn_inithead((void **) &AS_tree_head, 8);
     asnAclInitialize(Config.aclList);
     cachemgrRegister("asndb", "AS Number Database", asnStats, 0, 1);
@@ -300,7 +300,7 @@ asnAddNet(char *as_string, int as_number)
     char dbg1[32], dbg2[32];
     intlist **Tail = NULL;
     intlist *q = NULL;
-    as_info *as_info = NULL;
+    as_info *asinfo = NULL;
     struct in_addr in_a, in_m;
     long mask, addr;
     char *t;
@@ -332,34 +332,34 @@ asnAddNet(char *as_string, int as_number)
     store_m_int(mask, e->e_mask);
     rn = rn_lookup(e->e_addr, e->e_mask, AS_tree_head);
     if (rn != NULL) {
-	as_info = ((rtentry *) rn)->e_info;
-	if (intlistFind(as_info->as_number, as_number)) {
+	asinfo = ((rtentry *) rn)->e_info;
+	if (intlistFind(asinfo->as_number, as_number)) {
 	    debug(53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
 		dbg1, bitl, as_number);
 	} else {
 	    debug(53, 3) ("asnAddNet: Warning: Found a network with multiple AS numbers!\n");
-	    for (Tail = &as_info->as_number; *Tail; Tail = &(*Tail)->next);
+	    for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next);
 	    q = xcalloc(1, sizeof(intlist));
 	    q->i = as_number;
 	    *(Tail) = q;
-	    e->e_info = as_info;
+	    e->e_info = asinfo;
 	}
     } else {
 	q = xcalloc(1, sizeof(intlist));
 	q->i = as_number;
-	as_info = xmalloc(sizeof(as_info));
-	as_info->as_number = q;
+	asinfo = xmalloc(sizeof(asinfo));
+	asinfo->as_number = q;
 	rn = rn_addroute(e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
 	rn = rn_match(e->e_addr, AS_tree_head);
 	assert(rn != NULL);
-	e->e_info = as_info;
+	e->e_info = asinfo;
     }
     if (rn == 0) {
 	xfree(e);
 	debug(53, 3) ("asnAddNet: Could not add entry.\n");
 	return 0;
     }
-    e->e_info = as_info;
+    e->e_info = asinfo;
     return 1;
 }
 
@@ -409,17 +409,18 @@ printRadixNode(struct radix_node *rn, void *w)
     StoreEntry *sentry = w;
     rtentry *e = (rtentry *) rn;
     intlist *q;
-    as_info *as_info;
+    as_info *asinfo;
     struct in_addr addr;
     struct in_addr mask;
     assert(e);
+    assert(e->e_info);
     (void) get_m_int(addr.s_addr, e->e_addr);
     (void) get_m_int(mask.s_addr, e->e_mask);
     storeAppendPrintf(sentry, "%15s/%d\t",
 	inet_ntoa(addr), mask_len(ntohl(mask.s_addr)));
-    assert(as_info = e->e_info);
-    assert(as_info->as_number);
-    for (q = as_info->as_number; q; q = q->next)
+    asinfo = e->e_info;
+    assert(asinfo->as_number);
+    for (q = asinfo->as_number; q; q = q->next)
 	storeAppendPrintf(sentry, " %d", q->i);
     storeAppendPrintf(sentry, "\n");
     return 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.cc,v 1.8 1998/10/19 22:36:57 wessels Exp $
+ * $Id: authenticate.cc,v 1.9 1998/11/12 06:27:56 wessels Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -51,11 +51,13 @@ authenticateHandleReply(void *data, char *reply)
     authenticateStateData *r = data;
     int valid;
     char *t = NULL;
-    debug(29, 5) ("authenticateHandleReply: {%s}\n", reply);
-    if ((t = strchr(reply, ' ')))
-	*t = '\0';
-    if (*reply == '\0')
-	reply = NULL;
+    debug(29, 5) ("authenticateHandleReply: {%s}\n", reply ? reply : "<NULL>");
+    if (reply) {
+	if ((t = strchr(reply, ' ')))
+	    *t = '\0';
+	if (*reply == '\0')
+	    reply = NULL;
+    }
     valid = cbdataValid(r->data);
     cbdataUnlock(r->data);
     if (valid)
@@ -95,6 +97,7 @@ authenticateStart(acl_proxy_auth_user * auth_user, RH * handler, void *data)
     r = xcalloc(1, sizeof(authenticateStateData));
     cbdataAdd(r, MEM_NONE);
     r->handler = handler;
+    cbdataLock(data);
     r->data = data;
     r->auth_user = auth_user;
     snprintf(buf, 8192, "%s %s\n", r->auth_user->user, r->auth_user->passwd);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.309 1998/11/11 20:04:12 glenn Exp $
+ * $Id: cache_cf.cc,v 1.310 1998/11/12 06:27:57 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -87,31 +87,20 @@ wordlistDestroy(wordlist ** list)
     while ((w = *list) != NULL) {
 	*list = w->next;
 	safe_free(w->key);
-	safe_free(w);
+	memFree(MEM_WORDLIST, w);
     }
     *list = NULL;
 }
 
-void
+wordlist *
 wordlistAdd(wordlist ** list, const char *key)
 {
-    wordlist *p = NULL;
-    wordlist *q = NULL;
-
-    if (!(*list)) {
-	/* empty list */
-	*list = xcalloc(1, sizeof(wordlist));
-	(*list)->key = xstrdup(key);
-	(*list)->next = NULL;
-    } else {
-	p = *list;
-	while (p->next)
-	    p = p->next;
-	q = xcalloc(1, sizeof(wordlist));
-	q->key = xstrdup(key);
-	q->next = NULL;
-	p->next = q;
-    }
+    while (*list)
+	list = &(*list)->next;
+    *list = memAllocate(MEM_WORDLIST);
+    (*list)->key = xstrdup(key);
+    (*list)->next = NULL;
+    return *list;
 }
 
 void
@@ -130,7 +119,7 @@ intlistDestroy(intlist ** list)
     intlist *n = NULL;
     for (w = *list; w; w = n) {
 	n = w->next;
-	safe_free(w);
+	memFree(MEM_INTLIST, w);
     }
     *list = NULL;
 }
@@ -417,8 +406,10 @@ dump_acl(StoreEntry * entry, const char *name, acl * ae)
     wordlist *w;
     wordlist *v;
     while (ae != NULL) {
+	debug(3, 3) ("dump_acl: %s %s\n", name, ae->name);
 	v = w = aclDumpGeneric(ae);
 	while (v != NULL) {
+	    debug(3, 3) ("dump_acl: %s %s %s\n", name, ae->name, v->key);
 	    storeAppendPrintf(entry, "%s %s %s %s\n",
 		name,
 		ae->name,
@@ -538,7 +529,7 @@ parse_cachedir(cacheSwap * swap)
     int size;
     int l1;
     int l2;
-    int readonly = 0;
+    int read_only = 0;
     SwapDir *tmp = NULL;
     if ((path = strtok(NULL, w_space)) == NULL)
 	self_destruct();
@@ -556,7 +547,7 @@ parse_cachedir(cacheSwap * swap)
 	fatal("parse_cachedir: invalid level 2 directories value");
     if ((token = strtok(NULL, w_space)))
 	if (!strcasecmp(token, "read-only"))
-	    readonly = 1;
+	    read_only = 1;
     for (i = 0; i < swap->n_configured; i++) {
 	tmp = swap->swapDirs + i;
 	if (!strcmp(path, tmp->path)) {
@@ -568,10 +559,10 @@ parse_cachedir(cacheSwap * swap)
 		debug(3, 1) ("Cache dir '%s' size changed to %d KB\n",
 		    path, size);
 	    tmp->max_size = size;
-	    if (tmp->read_only != readonly)
+	    if (tmp->read_only != read_only)
 		debug(3, 1) ("Cache dir '%s' now %s\n",
-		    readonly ? "Read-Only" : "Read-Write");
-	    tmp->read_only = readonly;
+		    path, read_only ? "Read-Only" : "Read-Write");
+	    tmp->read_only = read_only;
 	    return;
 	}
     }
@@ -591,7 +582,7 @@ parse_cachedir(cacheSwap * swap)
     tmp->max_size = size;
     tmp->l1 = l1;
     tmp->l2 = l2;
-    tmp->read_only = readonly;
+    tmp->read_only = read_only;
     tmp->swaplog_fd = -1;
     swap->n_configured++;
 }
@@ -745,6 +736,8 @@ parse_peer(peer ** head)
 	} else if (!strcasecmp(token, "no-delay")) {
 	    p->options.no_delay = 1;
 #endif
+	} else if (!strncasecmp(token, "login=", 6)) {
+	    p->login = xstrdup(token + 6);
 	} else {
 	    debug(3, 0) ("parse_peer: token='%s'\n", token);
 	    self_destruct();
@@ -1,6 +1,6 @@
 
 #
-# $Id: cf.data.pre,v 1.123 1998/11/11 20:04:12 glenn Exp $
+# $Id: cf.data.pre,v 1.124 1998/11/12 06:27:57 wessels Exp $
 #
 #
 # SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -213,6 +213,7 @@ DOC_START
 		     no-digest
 		     no-netdb-exchange
 		     no-delay
+		     login=user:password
 
 		     use 'proxy-only' to specify that objects fetched
 		     from this cache should not be saved locally.
@@ -258,6 +259,9 @@ DOC_START
 		     use 'no-delay' to prevent access to this neighbor
 		     from influencing the delay pools.
 
+		     use 'login=user:password' if this is a personal/workgroup
+		     proxy and your parent requires proxy authentication.
+
 	NOTE: non-ICP neighbors must be specified as 'parent'.
 
 cache_peer hostname type 3128 3130
@@ -944,6 +948,18 @@ DOC_START
 redirect_children 5
 DOC_END
 
+NAME: redirect_rewrites_host_header
+TYPE: onoff
+DEFAULT: on
+LOC: Config.onoff.redir_rewrites_host
+DOC_START
+	By default Squid rewrites any Host: header in redirected requests.
+	If you are running a accelerator then this may not be a wanted effect
+	of a redirector.
+redirect_rewrites_host_header on
+DOC_END
+
+
 NAME: authenticate_program
 TYPE: wordlist
 LOC: Config.Program.authenticate
@@ -982,6 +998,19 @@ DOC_START
 authenticate_children 5
 DOC_END
 
+NAME: authenticate_ttl
+TYPE: int
+DEFAULT: 3600
+LOC: Config.authenticateTTL
+DOC_START
+	The time a checked username/password combination remains cached
+	(default 3600). If a wrong password is given for a cached user,
+	the user gets removed from the username/password cache forcing
+	a revalidation.
+
+authenticate_ttl 3600
+DOC_END
+
 COMMENT_START
  OPTIONS FOR TUNING THE CACHE
  -----------------------------------------------------------------------------
@@ -1103,21 +1132,21 @@ DOC_END
 NAME: quick_abort_min
 COMMENT: (KB)
 TYPE: kb_size_t
-DEFAULT: -1 kb
+DEFAULT: 16 KB
 LOC: Config.quickAbort.min
 DOC_NONE
 
 NAME: quick_abort_max
 COMMENT: (KB)
 TYPE: kb_size_t
-DEFAULT: 0 kb
+DEFAULT: 16 kb
 LOC: Config.quickAbort.max
 DOC_NONE
 
 NAME: quick_abort_pct
 COMMENT: (percent)
 TYPE: int
-DEFAULT: 0
+DEFAULT: 95
 LOC: Config.quickAbort.pct
 DOC_START
 	The cache can be configured to continue downloading aborted
@@ -1140,9 +1169,9 @@ DOC_START
 	If more than 'quick_abort_pct' of the transfer has completed,
 	it will finish the retrieval.
 
-quick_abort_min -1 KB
-quick_abort_max 0 KB
-quick_abort_pct 0
+quick_abort_min 16 KB
+quick_abort_max 16 KB
+quick_abort_pct 95
 DOC_END
 
 
@@ -1187,6 +1216,31 @@ DOC_START
 negative_dns_ttl 5 minutes
 DOC_END
 
+NAME: range_offset_limit
+COMMENT: (bytes)
+TYPE: b_size_t
+LOC: Config.rangeOffsetLimit
+DEFAULT: 0 KB
+DOC_START
+	Sets a upper limit on how far into the the file a Range request
+	may be to cause Squid to prefetch the whole file. If beyond this
+	limit then Squid forwards the Range request as it is and the result
+	is NOT cached.
+
+	This is to stop a far ahead range request (lets say start at 17MB)
+	from making Squid fetch the whole object up to that point before
+	sending anything to the client.
+
+	A value of -1 causes Squid to always fetch the object from the
+	beginning so that it may cache the result. (2.0 style)
+
+	A value of 0 causes Squid to never fetch more than the client
+	client requested. (default)
+
+range_offset_limit 0 KB
+DOC_END
+
+
 COMMENT_START
  TIMEOUTS
  -----------------------------------------------------------------------------
@@ -1363,9 +1417,9 @@ DOC_START
 	acl aclname proto    HTTP FTP ...
 	acl aclname method   GET POST ...
 	acl aclname browser  regexp
-	acl aclname user     username ...	# string match on ident output.
-						# use REQUIRED to accept any
-						# non-null ident.
+	acl aclname ident    username ...
+	  # string match on ident output.
+	  # use REQUIRED to accept any non-null ident.
 	acl aclname src_as   number ... 
 	acl aclname dst_as   number ...
 	  # Except for access control, AS numbers can be used for
@@ -1376,36 +1430,41 @@ DOC_START
 	  # cache_peer_access mycache.mydomain.net allow asexample
 	  # cache_peer_access mycache_mydomain.net deny all
 
-	acl aclname proxy_auth [ refresh ]
-	  # Use an EXTERNAL authentication program to check username/password
-	  # combinations (see authenticate_program).
-	  #
-	  # 'timeout' is the time a checked username/password combination
-	  # remains cached (default = 3600 secs). If a wrong password
-	  # is given for a cached user, the user gets removed from the
-	  # username/password cache forcing a revalidation.
-	  #
-	  # When using a proxy_auth ACL in an http_access rule, make sure
-	  # it is the *last* in the list and the only proxy_auth ACL in
-	  # the list.
+	acl aclname proxy_auth username ...
+	  # list of valid usernames
+	  # use REQUIRED to accept any valid username.
 	  #
 	  # NOTE: when a Proxy-Authentication header is sent but it is not
 	  # needed during ACL checking the username is NOT logged
 	  # in access.log.
+	  #
+	  # NOTE: proxy_auth requires a EXTERNAL authentication program
+	  # to check username/password combinations (see
+	  # authenticate_program).
+	  #
+	  # WARNING: proxy_auth can't be used in a transparent proxy. It
+	  # collides with any authentication done by origin servers. It may
+	  # seem like it works at first, but it doesn't.
 
 	acl aclname snmp_community string ...
 	  # Example:
 	  # 
 	  #	acl snmppublic snmp_community public
 
+
+Examples:
+acl myexample dst_as 1241
+acl password proxy_auth 300
+
+Defaults:
+NOCOMMENT_START
+acl all src 0.0.0.0/0.0.0.0
 acl manager proto cache_object
 acl localhost src 127.0.0.1/255.255.255.255
-acl all src 0.0.0.0/0.0.0.0
-acl myexample dst_as 1241
 acl SSL_ports port 443 563
 acl Safe_ports port 80 21 70 1025-65535
 acl CONNECT method CONNECT
-acl password proxy_auth 300
+NOCOMMENT_END
 DOC_END
 
 NAME: http_access
@@ -1433,14 +1492,17 @@ DOC_START
 	good idea to have an "deny all" or "allow all" entry at the end
 	of your access lists to avoid potential confusion.
 
-
-	Only allow access to the cache manager functions from the local host.
-http_access deny manager !localhost
-http_access deny CONNECT !SSL_ports
+Default configuration:
+NOCOMMENT_START
+http_access allow manager localhost
+http_access deny manager
 http_access deny !Safe_ports
-
-	Allow everything else
-http_access allow  all
+http_access deny CONNECT !SSL_ports
+#
+# INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS
+#
+http_access deny all
+NOCOMMENT_END
 DOC_END
 
 
@@ -1451,7 +1513,9 @@ DEFAULT: none
 DOC_START
 	Reply to all ICP queries we receive
 
-icp_access  allow  all
+NOCOMMENT_START
+icp_access allow all
+NOCOMMENT_END
 DOC_END
 
 
@@ -1472,8 +1536,9 @@ DOC_START
 
 	By default, allow all clients who passed the http_access rules
 	to fetch MISSES from us.
-
-miss_access allow  all
+NOCOMMENT_START
+miss_access allow all
+NOCOMMENT_END
 DOC_END
 
 
@@ -2616,4 +2681,16 @@ DOC_START
 uri_whitespace deny
 DOC_END
 
+NAME: persistent_client_posts
+TYPE: onoff
+LOC: Config.onoff.persistent_client_posts
+DEFAULT: on
+DOC_START
+	Turn this 'off' to disable persistent connections for POST
+	requests.  When you disable this, Squid reads all bytes
+	from the client request and sends them to the server.  This
+	makes Squid work with broken HTTP servers which expect the
+	additional CRLF pair from broken web clients.
+persistent_client_posts on
+DOC_END
 EOF
@@ -1,5 +1,5 @@
 /*
- * $Id: cf_gen.cc,v 1.28 1998/11/11 20:04:13 glenn Exp $
+ * $Id: cf_gen.cc,v 1.29 1998/11/12 06:27:58 wessels Exp $
  *
  * DEBUG: none
  * AUTHOR: Max Okumoto
@@ -65,6 +65,8 @@
 #include <assert.h>
 #endif
 
+#include "util.h"
+
 #define MAX_LINE	1024	/* longest configuration line */
 #define _PATH_PARSER		"cf_parser.c"
 #define _PATH_SQUID_CONF	"squid.conf"
@@ -73,6 +75,7 @@ enum State {
     sSTART,
     s1,
     sDOC,
+    sNOCOMMENT,
     sEXIT
 };
 
@@ -90,6 +93,7 @@ typedef struct Entry {
     char *comment;
     char *ifdef;
     Line *doc;
+    Line *nocomment;
     struct Entry *next;
 } Entry;
 
@@ -146,14 +150,14 @@ main(int argc, char *argv[])
 		    exit(1);
 		}
 		curr = calloc(1, sizeof(Entry));
-		curr->name = strdup(name);
+		curr->name = xstrdup(name);
 		state = s1;
 	    } else if (!strcmp(buff, "EOF")) {
 		state = sEXIT;
 	    } else if (!strcmp(buff, "COMMENT_START")) {
 		curr = calloc(1, sizeof(Entry));
-		curr->name = strdup("comment");
-		curr->loc = strdup("none");
+		curr->name = xstrdup("comment");
+		curr->loc = xstrdup("none");
 		state = sDOC;
 	    } else {
 		printf("Error on line %d\n", linenum);
@@ -170,35 +174,35 @@ main(int argc, char *argv[])
 		ptr = buff + 8;
 		while (isspace(*ptr))
 		    ptr++;
-		curr->comment = strdup(ptr);
+		curr->comment = xstrdup(ptr);
 	    } else if (!strncmp(buff, "DEFAULT:", 8)) {
 		ptr = buff + 8;
 		while (isspace(*ptr))
 		    ptr++;
-		curr->default_value = strdup(ptr);
+		curr->default_value = xstrdup(ptr);
 	    } else if (!strncmp(buff, "DEFAULT_IF_NONE:", 16)) {
 		ptr = buff + 16;
 		while (isspace(*ptr))
 		    ptr++;
-		curr->default_if_none = strdup(ptr);
+		curr->default_if_none = xstrdup(ptr);
 	    } else if (!strncmp(buff, "LOC:", 4)) {
 		if ((ptr = strtok(buff + 4, WS)) == NULL) {
 		    printf("Error on line %d\n", linenum);
 		    exit(1);
 		}
-		curr->loc = strdup(ptr);
+		curr->loc = xstrdup(ptr);
 	    } else if (!strncmp(buff, "TYPE:", 5)) {
 		if ((ptr = strtok(buff + 5, WS)) == NULL) {
 		    printf("Error on line %d\n", linenum);
 		    exit(1);
 		}
-		curr->type = strdup(ptr);
+		curr->type = xstrdup(ptr);
 	    } else if (!strncmp(buff, "IFDEF:", 6)) {
 		if ((ptr = strtok(buff + 6, WS)) == NULL) {
 		    printf("Error on line %d\n", linenum);
 		    exit(1);
 		}
-		curr->ifdef = strdup(ptr);
+		curr->ifdef = xstrdup(ptr);
 	    } else if (!strcmp(buff, "DOC_START")) {
 		state = sDOC;
 	    } else if (!strcmp(buff, "DOC_NONE")) {
@@ -229,14 +233,38 @@ main(int argc, char *argv[])
 		curr->next = entries;
 		entries = curr;
 		state = sSTART;
+	    } else if (!strcmp(buff, "NOCOMMENT_START")) {
+		state = sNOCOMMENT;
 	    } else {
 		Line *line = calloc(1, sizeof(Line));
-		line->data = strdup(buff);
+		line->data = xstrdup(buff);
 		line->next = curr->doc;
 		curr->doc = line;
 	    }
 	    break;
 
+	case sNOCOMMENT:
+	    if (!strcmp(buff, "NOCOMMENT_END")) {
+		Line *head = NULL;
+		Line *line = curr->nocomment;
+		/* reverse order of lines */
+		while (line != NULL) {
+		    Line *tmp;
+		    tmp = line->next;
+		    line->next = head;
+		    head = line;
+		    line = tmp;
+		}
+		curr->nocomment = head;
+		state = sDOC;
+	    } else {
+		Line *line = calloc(1, sizeof(Line));
+		line->data = xstrdup(buff);
+		line->next = curr->nocomment;
+		curr->nocomment = line;
+	    }
+	    break;
+
 	case sEXIT:
 	    assert(0);		/* should never get here */
 	    break;
@@ -327,6 +355,7 @@ gen_default(Entry * head, FILE * fp)
 	);
     for (entry = head; entry != NULL; entry = entry->next) {
 	assert(entry->name);
+	assert(entry != entry->next);
 
 	if (!strcmp(entry->name, "comment"))
 	    continue;
@@ -497,14 +526,19 @@ gen_conf(Entry * head, FILE * fp)
     for (entry = head; entry != NULL; entry = entry->next) {
 	Line *line;
 
-	if (strcmp(entry->name, "comment"))
+	if (!strcmp(entry->name, "comment"))
+	    (void) 0;
+	else
 	    fprintf(fp, "#  TAG: %s", entry->name);
 	if (entry->comment)
 	    fprintf(fp, "\t%s", entry->comment);
 	fprintf(fp, "\n");
 	for (line = entry->doc; line != NULL; line = line->next) {
 	    fprintf(fp, "#%s\n", line->data);
 	}
+	for (line = entry->nocomment; line != NULL; line = line->next) {
+	    fprintf(fp, "%s\n", line->data);
+	}
 	if (entry->doc != NULL) {
 	    fprintf(fp, "\n");
 	}
@@ -1,9 +1,8 @@
 
 
 
-
 /*
- * $Id: client.cc,v 1.77 1998/10/19 22:36:58 wessels Exp $
+ * $Id: client.cc,v 1.78 1998/11/12 06:27:59 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.421 1998/11/11 20:04:14 glenn Exp $
+ * $Id: client_side.cc,v 1.422 1998/11/12 06:28:00 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -80,6 +80,7 @@ static int checkAccelOnly(clientHttpRequest *);
 static int clientOnlyIfCached(clientHttpRequest * http);
 static STCB clientSendMoreData;
 static STCB clientCacheHit;
+static void clientSetKeepaliveFlag(clientHttpRequest *);
 static void clientInterpretRequestHeaders(clientHttpRequest *);
 static void clientProcessRequest(clientHttpRequest *);
 static void clientProcessExpired(void *data);
@@ -146,13 +147,29 @@ clientOnlyIfCached(clientHttpRequest * http)
 static HttpReply *
 clientConstructProxyAuthReply(clientHttpRequest * http)
 {
-    ErrorState *err = errorCon(ERR_CACHE_ACCESS_DENIED, HTTP_PROXY_AUTHENTICATION_REQUIRED);
+    ErrorState *err;
     HttpReply *rep;
+    if (!http->flags.accel) {
+	/* Proxy authorisation needed */
+	err = errorCon(ERR_CACHE_ACCESS_DENIED,
+	    HTTP_PROXY_AUTHENTICATION_REQUIRED);
+    } else {
+	/* WWW authorisation needed */
+	err = errorCon(ERR_CACHE_ACCESS_DENIED, HTTP_UNAUTHORIZED);
+    }
     err->request = requestLink(http->request);
     rep = errorBuildReply(err);
     errorStateFree(err);
     /* add Authenticate header */
-    httpHeaderPutStrf(&rep->header, HDR_PROXY_AUTHENTICATE, proxy_auth_challenge_fmt, Config.proxyAuthRealm);
+    if (!http->flags.accel) {
+	/* Proxy authorisation needed */
+	httpHeaderPutStrf(&rep->header, HDR_PROXY_AUTHENTICATE,
+	    proxy_auth_challenge_fmt, Config.proxyAuthRealm);
+    } else {
+	/* WWW Authorisation needed */
+	httpHeaderPutStrf(&rep->header, HDR_WWW_AUTHENTICATE,
+	    proxy_auth_challenge_fmt, Config.proxyAuthRealm);
+    }
     return rep;
 }
 
@@ -171,7 +188,8 @@ clientCreateStoreEntry(clientHttpRequest * h, method_t m, request_flags flags)
 #if DELAY_POOLS
     delaySetStoreClient(e, h, h->request->delay_id);
 #endif
-    storeClientCopy(e, 0, 0, CLIENT_SOCK_SZ, memAllocate(MEM_CLIENT_SOCK_BUF), clientSendMoreData, h);
+    storeClientCopy(e, 0, 0, CLIENT_SOCK_SZ,
+	memAllocate(MEM_CLIENT_SOCK_BUF), clientSendMoreData, h);
     return e;
 }
 
@@ -192,7 +210,8 @@ clientAccessCheckDone(int answer, void *data)
 	redirectStart(http, clientRedirectDone, http);
     } else if (answer == ACCESS_REQ_PROXY_AUTH) {
 	http->log_type = LOG_TCP_DENIED;
-	http->entry = clientCreateStoreEntry(http, http->request->method, null_request_flags);
+	http->entry = clientCreateStoreEntry(http, http->request->method,
+	    null_request_flags);
 	/* create appropriate response */
 	http->entry->mem_obj->reply = clientConstructProxyAuthReply(http);
 	httpReplySwapOut(http->entry->mem_obj->reply, http->entry);
@@ -202,7 +221,8 @@ clientAccessCheckDone(int answer, void *data)
 	debug(33, 5) ("AclMatchedName = %s\n",
 	    AclMatchedName ? AclMatchedName : "<null>");
 	http->log_type = LOG_TCP_DENIED;
-	http->entry = clientCreateStoreEntry(http, http->request->method, null_request_flags);
+	http->entry = clientCreateStoreEntry(http, http->request->method,
+	    null_request_flags);
 	page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName);
 	/* NOTE: don't use HTTP_UNAUTHORIZED because then the
 	 * stupid browser wants us to authenticate */
@@ -652,6 +672,7 @@ httpRequestFree(void *data)
 	    packerToMemInit(&p, &mb);
 	    httpHeaderPackInto(&request->header, &p);
 	    http->al.http.method = request->method;
+	    http->al.http.version = request->http_ver;
 	    http->al.headers.request = xstrdup(mb.buf);
 	    http->al.hier = request->hier;
 	    packerClean(&p);
@@ -762,15 +783,12 @@ clientInterpretRequestHeaders(clientHttpRequest * http)
 	request->flags.auth = 1;
     if (request->login[0] != '\0')
 	request->flags.auth = 1;
-    if (httpMsgIsPersistent(request->http_ver, req_hdr))
-	request->flags.proxy_keepalive = 1;
     if (httpHeaderHas(req_hdr, HDR_VIA)) {
 	String s = httpHeaderGetList(req_hdr, HDR_VIA);
 	/* ThisCache cannot be a member of Via header, "1.0 ThisCache" can */
 	if (strListIsSubstr(&s, ThisCache, ',')) {
-	    debug(33, 1) ("WARNING: Forwarding loop detected for '%s'\n",
-		http->uri);
-	    debug(33, 1) ("--> %s\n", strBuf(s));
+	    debugObj(33, 1, "WARNING: Forwarding loop detected for:\n",
+		request, (ObjPackMethod) & httpRequestPack);
 	    request->flags.loopdetect = 1;
 	}
 #if FORW_VIA_DB
@@ -812,6 +830,28 @@ clientInterpretRequestHeaders(clientHttpRequest * http)
 	request->flags.hierarchical ? "SET" : "NOT SET");
 }
 
+/*
+ * clientSetKeepaliveFlag() sets request->flags.proxy_keepalive.
+ * This is the client-side persistent connection flag.  We need
+ * to set this relatively early in the request processing
+ * to handle hacks for broken servers and clients.
+ */
+static void
+clientSetKeepaliveFlag(clientHttpRequest * http)
+{
+    request_t *request = http->request;
+    const HttpHeader *req_hdr = &request->header;
+    debug(33, 3) ("clientSetKeepaliveFlag: http_ver = %3.1f\n",
+	request->http_ver);
+    debug(33, 3) ("clientSetKeepaliveFlag: method = %s\n",
+	RequestMethodStr[request->method]);
+    if (httpMsgIsPersistent(request->http_ver, req_hdr))
+	request->flags.proxy_keepalive = 1;
+    if (request->method == METHOD_POST || request->method == METHOD_PUT)
+	if (!Config.onoff.persistent_client_posts)
+	    request->flags.proxy_keepalive = 0;
+}
+
 static int
 clientCheckContentLength(request_t * r)
 {
@@ -1087,10 +1127,12 @@ clientBuildReplyHeader(clientHttpRequest * http, HttpReply * rep)
 	http->lookup_type ? http->lookup_type : "NONE",
 	getMyHostname(), Config.Port.http->i);
 #endif
-    /* Only replies with valid Content-Length can be sent with keep-alive */
-    if (request->method != METHOD_HEAD &&
-	http->entry->mem_obj->reply->content_length < 0)
-	request->flags.proxy_keepalive = 0;
+    /*
+     * Clear keepalive for NON-HEAD requests with invalid content length
+     */
+    if (request->method != METHOD_HEAD)
+	if (http->entry->mem_obj->reply->content_length < 0)
+	    request->flags.proxy_keepalive = 0;
     /* Signal keep-alive if needed */
     httpHeaderPutStr(hdr,
 	http->flags.accel ? HDR_CONNECTION : HDR_PROXY_CONNECTION,
@@ -1856,7 +1898,7 @@ parseHttpRequestAbort(ConnStateData * conn, const char *uri)
     http->start = current_time;
     http->req_sz = conn->in.offset;
     http->uri = xstrdup(uri);
-    http->log_uri = xstrdup(uri);
+    http->log_uri = xstrndup(uri, MAX_URL);
     http->range_iter.boundary = StringNull;
     return http;
 }
@@ -1884,33 +1926,37 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     size_t header_sz;		/* size of headers, not including first line */
     size_t prefix_sz;		/* size of whole request (req-line + headers) */
     size_t url_sz;
+    size_t req_sz;
     method_t method;
     clientHttpRequest *http = NULL;
 #if IPF_TRANSPARENT
     struct natlookup natLookup;
     static int natfd = -1;
 #endif
 
-    /* Make sure a complete line has been received */
-    if ((t = strchr(conn->in.buf, '\n')) == NULL) {
-	debug(33, 5) ("Incomplete request line, waiting for more data\n");
+    if ((req_sz = headersEnd(conn->in.buf, conn->in.offset)) == 0) {
+	debug(33, 5) ("Incomplete request, waiting for end of headers\n");
 	*status = 0;
 	*prefix_p = NULL;
 	*method_p = METHOD_NONE;
 	return NULL;
     }
-    *req_line_sz_p = t - conn->in.buf;
-    /* Use xmalloc/xmemcpy instead of xstrdup because inbuf might
-     * contain NULL bytes; especially for POST data  */
-    inbuf = xmalloc(conn->in.offset + 1);
-    xmemcpy(inbuf, conn->in.buf, conn->in.offset);
-    *(inbuf + conn->in.offset) = '\0';
+    assert(req_sz <= conn->in.offset);
+    /* Use memcpy, not strdup! */
+    inbuf = xmalloc(req_sz + 1);
+    xmemcpy(inbuf, conn->in.buf, req_sz);
+    *(inbuf + req_sz) = '\0';
 
     /* pre-set these values to make aborting simpler */
     *prefix_p = inbuf;
     *method_p = METHOD_NONE;
     *status = -1;
 
+    /* Barf on NULL characters in the headers */
+    if (strlen(inbuf) != req_sz) {
+	debug(33, 1) ("parseHttpRequest: Requestheader contains NULL characters\n");
+	return parseHttpRequestAbort(conn, "error:invalid-request");
+    }
     /* Look for request method */
     if ((mstr = strtok(inbuf, "\t ")) == NULL) {
 	debug(33, 1) ("parseHttpRequest: Can't get request method\n");
@@ -1925,10 +1971,12 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     *method_p = method;
 
     /* look for URL+HTTP/x.x */
-    if ((url = strtok(NULL, "\r\n")) == NULL) {
+    if ((url = strtok(NULL, "\n")) == NULL) {
 	debug(33, 1) ("parseHttpRequest: Missing URL\n");
 	return parseHttpRequestAbort(conn, "error:missing-url");
     }
+    while (isspace(*url))
+	url++;
     t = url + strlen(url);
     assert(*t == '\0');
     token = NULL;
@@ -1950,27 +1998,19 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 	return parseHttpRequestAbort(conn, "error:missing-http-ident");
 #endif
     } else {
-debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
 	http_ver = (float) atof(token + 5);
     }
 
-    /* Check if headers are received */
-    req_hdr = t;
-    header_sz = headersEnd(req_hdr, conn->in.offset - (req_hdr - inbuf));
+    /*
+     * Process headers after request line
+     */
+    req_hdr = strtok(NULL, null_string);
+    header_sz = req_sz - (req_hdr - inbuf);
     if (0 == header_sz) {
 	debug(33, 3) ("parseHttpRequest: header_sz == 0\n");
 	*status = 0;
 	return NULL;
     }
-    /*
-     * Skip whitespace at the end of the first line, up to the
-     * first newline.
-     */
-    while (isspace(*req_hdr)) {
-	header_sz--;
-	if (*(req_hdr++) == '\n')
-	    break;
-    }
     assert(header_sz > 0);
     debug(33, 3) ("parseHttpRequest: req_hdr = {%s}\n", req_hdr);
     end = req_hdr + header_sz;
@@ -1995,11 +2035,6 @@ debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
     *(*prefix_p + prefix_sz) = '\0';
 
     debug(33, 5) ("parseHttpRequest: Request Header is\n%s\n", (*prefix_p) + *req_line_sz_p);
-    /* Assign http->uri */
-    if ((t = strchr(url, '\n')))	/* remove NL */
-	*t = '\0';
-    if ((t = strchr(url, '\r')))	/* remove CR */
-	*t = '\0';
     if ((t = strchr(url, '#')))	/* remove HTML anchors */
 	*t = '\0';
 
@@ -2008,6 +2043,7 @@ debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
 	/* prepend our name & port */
 	http->uri = xstrdup(internalLocalUri(NULL, url));
 	http->flags.internal = 1;
+	http->flags.accel = 1;
     }
     /* see if we running in Config2.Accel.on, if so got to convert it to URL */
     else if (Config2.Accel.on && *url == '/') {
@@ -2083,9 +2119,9 @@ debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
 	http->flags.accel = 0;
     }
     if (!stringHasWhitespace(http->uri))
-	http->log_uri = xstrdup(http->uri);
+	http->log_uri = xstrndup(http->uri, MAX_URL);
     else
-	http->log_uri = xstrdup(rfc1738_escape(http->uri));
+	http->log_uri = xstrndup(rfc1738_escape(http->uri), MAX_URL);
     debug(33, 5) ("parseHttpRequest: Complete request received\n");
     if (free_request)
 	safe_free(url);
@@ -2231,18 +2267,20 @@ clientReadRequest(int fd, void *data)
 			http->uri, prefix);
 		/* continue anyway? */
 	    }
+	    request->flags.accelerated = http->flags.accel;
 	    if (!http->flags.internal) {
 		if (internalCheck(strBuf(request->urlpath))) {
-		    if (0 == strcasecmp(request->host, getMyHostname())) {
+		    if (0 == strcasecmp(request->host, internalHostname())) {
 			if (request->port == Config.Port.http->i)
 			    http->flags.internal = 1;
 		    } else if (internalStaticCheck(strBuf(request->urlpath))) {
-			xstrncpy(request->host, getMyHostname(), SQUIDHOSTNAMELEN);
+			xstrncpy(request->host, internalHostname(), SQUIDHOSTNAMELEN);
 			request->port = Config.Port.http->i;
 			http->flags.internal = 1;
 		    }
 		}
 	    }
+	    request->flags.internal = http->flags.internal;
 	    safe_free(prefix);
 	    safe_free(http->log_uri);
 	    http->log_uri = xstrdup(urlCanonicalClean(request));
@@ -2267,14 +2305,22 @@ clientReadRequest(int fd, void *data)
 		break;
 	    }
 	    http->request = requestLink(request);
+	    /*
+	     * We need to set the keepalive flag before doing some
+	     * hacks for POST/PUT requests below.  Maybe we could
+	     * set keepalive flag even earlier.
+	     */
+	    clientSetKeepaliveFlag(http);
 	    /*
 	     * break here for NON-GET because most likely there is a
 	     * reqeust body following and we don't want to parse it
 	     * as though it was new request
 	     */
 	    if (request->method != METHOD_GET) {
 		int cont_len = httpHeaderGetInt(&request->header, HDR_CONTENT_LENGTH);
-		int copy_len = XMIN(cont_len, conn->in.offset);
+		int copy_len = conn->in.offset;
+		if (cont_len < copy_len && request->flags.proxy_keepalive)
+		    copy_len = cont_len;
 		if (copy_len > 0) {
 		    assert(conn->in.offset >= copy_len);
 		    request->body_sz = copy_len;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_select.cc,v 1.21 1998/10/19 22:36:58 wessels Exp $
+ * $Id: comm_select.cc,v 1.22 1998/11/12 06:28:01 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -744,10 +744,10 @@ examine_select(fd_set * readfds, fd_set * writefds)
     int fd = 0;
     fd_set read_x;
     fd_set write_x;
-    int num;
     struct timeval tv;
     close_handler *ch = NULL;
     fde *F = NULL;
+    struct stat sb;
     debug(5, 0) ("examine_select: Examining open file descriptors...\n");
     for (fd = 0; fd < Squid_MaxFD; fd++) {
 	FD_ZERO(&read_x);
@@ -760,8 +760,8 @@ examine_select(fd_set * readfds, fd_set * writefds)
 	else
 	    continue;
 	Counter.syscalls.selects++;
-	num = select(Squid_MaxFD, &read_x, &write_x, NULL, &tv);
-	if (num > -1) {
+	errno = 0;
+	if (!fstat(fd, &sb)) {
 	    debug(5, 5) ("FD %d is valid.\n", fd);
 	    continue;
 	}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: delay_pools.cc,v 1.5 1998/09/30 04:34:07 wessels Exp $
+ * $Id: delay_pools.cc,v 1.6 1998/11/12 06:28:02 wessels Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: David Luyer <luyer@ucs.uwa.edu.au>
@@ -405,7 +405,7 @@ delayBytesIn(delay_id d, int qty)
     }
     if (class == 2) {
 	delay_data.class2_aggregate -= qty;
-	delay_data.class3_individual[position] -= qty;
+	delay_data.class2_individual[position] -= qty;
 	return;
     }
     if (class == 3) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dns.cc,v 1.71 1998/10/19 22:36:59 wessels Exp $
+ * $Id: dns.cc,v 1.72 1998/11/12 06:28:03 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -59,10 +59,9 @@ dnsInit(void)
     wordlistAdd(&dnsservers->cmdline, Config.Program.dnsserver);
     if (Config.onoff.res_defnames)
 	wordlistAdd(&dnsservers->cmdline, "-D");
-    if (Config.dns_nameservers) {
+    for (w = Config.dns_nameservers; w != NULL; w = w->next) {
 	wordlistAdd(&dnsservers->cmdline, "-s");
-	for (w = Config.dns_nameservers; w != NULL; w = w->next)
-	    wordlistAdd(&dnsservers->cmdline, w->key);
+	wordlistAdd(&dnsservers->cmdline, w->key);
     }
     helperOpenServers(dnsservers);
     if (!init) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dnsserver.cc,v 1.52 1998/07/22 20:37:15 wessels Exp $
+ * $Id: dnsserver.cc,v 1.53 1998/11/12 06:28:03 wessels Exp $
  *
  * DEBUG: section 0     DNS Resolver
  * AUTHOR: Harvest Derived
@@ -289,7 +289,12 @@ main(int argc, char *argv[])
 		_res.options |= RES_INIT;
 		opt_s = 1;
 	    }
+#if HAVE_RES_NSADDR_LIST
 	    safe_inet_addr(optarg, &_res.nsaddr_list[_res.nscount++].sin_addr);
+#elif HAVE_RES_NS_LIST
+	    safe_inet_addr(optarg, &_res.ns_list[_res.nscount++].addr.sin_addr);
+#endif
+	    fprintf(stderr, "-s is not supported on this resolver\n");
 #else
 	    fprintf(stderr, "-s is not supported on this resolver\n");
 #endif /* HAVE_RES_INIT */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.136 1998/11/11 20:04:15 glenn Exp $
+ * $Id: enums.h,v 1.137 1998/11/12 06:28:04 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -97,7 +97,7 @@ typedef enum {
     ACL_URLPATH_REGEX,
     ACL_URL_REGEX,
     ACL_URL_PORT,
-    ACL_USER,
+    ACL_IDENT,
     ACL_PROTO,
     ACL_METHOD,
     ACL_BROWSER,
@@ -115,9 +115,7 @@ typedef enum {
     ACL_LOOKUP_NEEDED,
     ACL_LOOKUP_PENDING,
     ACL_LOOKUP_DONE,
-    ACL_PROXY_AUTH_NEEDED,
-    ACL_PROXY_AUTH_USED,
-    ACL_PROXY_AUTH_CHECK
+    ACL_PROXY_AUTH_NEEDED
 } acl_lookup_state;
 
 enum {
@@ -200,7 +198,9 @@ typedef enum {
     HDR_EXPIRES,
     HDR_FROM,
     HDR_HOST,
+    HDR_IF_MATCH,
     HDR_IF_MODIFIED_SINCE,
+    HDR_IF_NONE_MATCH,
     HDR_IF_RANGE,
     HDR_LAST_MODIFIED,
     HDR_LINK,
@@ -473,84 +473,91 @@ enum {
 
 typedef enum {
     MEM_NONE,
-    MEM_DONTFREE,
-    MEM_DISK_BUF,
-    MEM_STMEM_BUF,
     MEM_2K_BUF,
     MEM_4K_BUF,
     MEM_8K_BUF,
-    MEM_CLIENT_SOCK_BUF,
-    MEM_ACL_IP_DATA,
-    MEM_ACL_TIME_DATA,
-    MEM_ACL_NAME_LIST,
-    MEM_ACL_DENY_INFO_LIST,
+    MEM_ACCESSLOGENTRY,
     MEM_ACL,
-    MEM_ACL_LIST,
+    MEM_ACLCHECK_T,
     MEM_ACL_ACCESS,
+    MEM_ACL_DENY_INFO_LIST,
+    MEM_ACL_IP_DATA,
+    MEM_ACL_LIST,
+    MEM_ACL_NAME_LIST,
     MEM_ACL_PROXY_AUTH_USER,
-    MEM_ACLCHECK_T,
+    MEM_ACL_TIME_DATA,
     MEM_AIO_RESULT_T,
-    MEM_WORDLIST,
-    MEM_INTLIST,
-    MEM_USHORTLIST,
-    MEM_RELIST,
-    MEM_SQUIDCONFIG,
-    MEM_SQUIDCONFIG2,
+    MEM_CACHEMGR_PASSWD,
+#if USE_CACHE_DIGESTS
+    MEM_CACHE_DIGEST,
+#endif
+    MEM_CLIENTHTTPREQUEST,
+    MEM_CLIENT_INFO,
+    MEM_CLIENT_SOCK_BUF,
     MEM_CLOSE_HANDLER,
-    MEM_DREAD_CTRL,
+    MEM_COMMWRITESTATEDATA,
+    MEM_CONNSTATEDATA,
+#if USE_CACHE_DIGESTS
+    MEM_DIGEST_FETCH_STATE,
+#endif
+    MEM_DISK_BUF,
+    MEM_DLINK_LIST,
+    MEM_DLINK_NODE,
     MEM_DNSSERVER_T,
     MEM_DNSSTATDATA,
+    MEM_DOMAIN_PING,
+    MEM_DOMAIN_TYPE,
+    MEM_DONTFREE,
+    MEM_DREAD_CTRL,
     MEM_DWRITE_Q,
+    MEM_ERRORSTATE,
     MEM_FILEMAP,
     MEM_FQDNCACHE_ENTRY,
     MEM_FQDNCACHE_PENDING,
-    MEM_FWD_STATE,
     MEM_FWD_SERVER,
+    MEM_FWD_STATE,
     MEM_HASH_LINK,
     MEM_HASH_TABLE,
-    MEM_HTTP_REPLY,
-    MEM_HTTP_HDR_ENTRY,
+    MEM_HELPER,
+    MEM_HELPER_REQUEST,
+    MEM_HELPER_SERVER,
+    MEM_HIERARCHYLOGENTRY,
     MEM_HTTP_HDR_CC,
-    MEM_HTTP_HDR_RANGE_SPEC,
-    MEM_HTTP_HDR_RANGE,
     MEM_HTTP_HDR_CONTENT_RANGE,
+    MEM_HTTP_HDR_ENTRY,
+    MEM_HTTP_HDR_RANGE,
+    MEM_HTTP_HDR_RANGE_SPEC,
+    MEM_HTTP_REPLY,
     MEM_HTTP_STATE_DATA,
     MEM_ICPUDPDATA,
-    MEM_CLIENTHTTPREQUEST,
-    MEM_CONNSTATEDATA,
-    MEM_IPCACHE_PENDING,
+    MEM_ICP_COMMON_T,
+    MEM_ICP_PING_DATA,
+    MEM_INTLIST,
+    MEM_IOSTATS,
     MEM_IPCACHE_ENTRY,
-    MEM_DOMAIN_PING,
-    MEM_DOMAIN_TYPE,
-    MEM_DIGEST_FETCH_STATE,
-    MEM_PEER,
+    MEM_IPCACHE_PENDING,
+    MEM_MD5_DIGEST,
+    MEM_MEMOBJECT,
+    MEM_MEM_NODE,
+    MEM_NETDBENTRY,
     MEM_NET_DB_NAME,
     MEM_NET_DB_PEER,
-    MEM_NETDBENTRY,
-    MEM_ICP_PING_DATA,
-    MEM_PS_STATE,
-    MEM_HIERARCHYLOGENTRY,
+    MEM_PEER,
     MEM_PINGERECHODATA,
     MEM_PINGERREPLYDATA,
-    MEM_ICP_COMMON_T,
-    MEM_IOSTATS,
-    MEM_MEM_NODE,
-    MEM_STORE_CLIENT,
-    MEM_MEMOBJECT,
-    MEM_STOREENTRY,
-    MEM_SWAPDIR,
-    MEM_REQUEST_T,
-    MEM_ACCESSLOGENTRY,
-    MEM_CACHE_DIGEST,
-    MEM_CACHEMGR_PASSWD,
+    MEM_PS_STATE,
     MEM_REFRESH_T,
-    MEM_COMMWRITESTATEDATA,
-    MEM_ERRORSTATE,
-    MEM_DLINK_NODE,
-    MEM_DLINK_LIST,
+    MEM_RELIST,
+    MEM_REQUEST_T,
+    MEM_SQUIDCONFIG,
+    MEM_SQUIDCONFIG2,
     MEM_STATCOUNTERS,
-    MEM_CLIENT_INFO,
-    MEM_MD5_DIGEST,
+    MEM_STMEM_BUF,
+    MEM_STOREENTRY,
+    MEM_STORE_CLIENT,
+    MEM_SWAPDIR,
+    MEM_USHORTLIST,
+    MEM_WORDLIST,
     MEM_MAX
 } mem_type;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.142 1998/09/14 22:17:57 wessels Exp $
+ * $Id: errorpage.cc,v 1.143 1998/11/12 06:28:05 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -81,6 +81,8 @@ static int error_page_count = 0;
 static char *errorTryLoadText(const char *page_name, const char *dir);
 static char *errorLoadText(const char *page_name);
 static const char *errorFindHardText(err_type type);
+static ErrorDynamicPageInfo *errorDynamicPageInfoCreate(int id, const char *page_name);
+static void errorDynamicPageInfoDestroy(ErrorDynamicPageInfo * info);
 static MemBuf errorBuildContent(ErrorState * err);
 static const char *errorConvert(char token, ErrorState * err);
 static CWCB errorSendComplete;
@@ -106,12 +108,11 @@ errorInitialize(void)
 	/* hard-coded ? */
 	if ((text = errorFindHardText(i)))
 	    error_text[i] = xstrdup(text);
-	else
+	else if (i < ERR_MAX) {
 	    /* precompiled ? */
-	if (i < ERR_MAX)
 	    error_text[i] = errorLoadText(err_type_str[i]);
-	/* dynamic */
-	else {
+	} else {
+	    /* dynamic */
 	    ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
 	    assert(info && info->id == i && info->page_name);
 	    error_text[i] = errorLoadText(info->page_name);
@@ -120,6 +121,20 @@ errorInitialize(void)
     }
 }
 
+void
+errorClean(void)
+{
+    if (error_text) {
+	int i;
+	for (i = ERR_NONE + 1; i < error_page_count; i++)
+	    safe_free(error_text[i]);
+	safe_free(error_text);
+    }
+    while (ErrorDynamicPages.count)
+	errorDynamicPageInfoDestroy(stackPop(&ErrorDynamicPages));
+    error_page_count = 0;
+}
+
 static const char *
 errorFindHardText(err_type type)
 {
@@ -169,7 +184,8 @@ errorTryLoadText(const char *page_name, const char *dir)
 	text = NULL;
     }
     file_close(fd);
-    strcat(text, "%S");		/* add signature */
+    if (strstr(text, "%s") == NULL)
+	strcat(text, "%S");	/* add signature */
     return text;
 }
 
@@ -199,16 +215,15 @@ errorReservePageId(const char *page_name)
     return info->id;
 }
 
-void
-errorFree(void)
+static const char *
+errorPageName(int pageId)
 {
-    int i;
-    for (i = ERR_NONE + 1; i < error_page_count; i++)
-	safe_free(error_text[i]);
-    while (ErrorDynamicPages.count)
-	errorDynamicPageInfoDestroy(stackPop(&ErrorDynamicPages));
-    safe_free(error_text);
-    error_page_count = 0;
+    if (pageId >= ERR_NONE && pageId < ERR_MAX)		/* common case */
+	return err_type_str[pageId];
+    if (pageId >= ERR_MAX && pageId - ERR_MAX < ErrorDynamicPages.count)
+	return ((ErrorDynamicPageInfo *) ErrorDynamicPages.
+	    items[pageId - ERR_MAX])->page_name;
+    return "ERR_UNKNOWN";	/* should not happen */
 }
 
 /*
@@ -530,7 +545,7 @@ errorBuildReply(ErrorState * err)
      * X-CACHE-MISS entry should tell us who.
      */
     httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d",
-	err_type_str[err->page_id], err->xerrno);
+	errorPageName(err->page_id), err->xerrno);
     httpBodySet(&rep->body, &content);
     /* do not memBufClean() the content, it was absorbed by httpBody */
     return rep;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.30 1998/09/23 20:13:48 wessels Exp $
+ * $Id: forward.cc,v 1.31 1998/11/12 06:28:05 wessels Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -255,7 +255,6 @@ fwdDispatch(FwdState * fwdState)
     peer *p;
     request_t *request = fwdState->request;
     StoreEntry *entry = fwdState->entry;
-    ErrorState *err;
     debug(17, 5) ("fwdDispatch: FD %d: Fetching '%s %s'\n",
 	fwdState->client_fd,
 	RequestMethodStr[request->method],
@@ -299,9 +298,8 @@ fwdDispatch(FwdState * fwdState)
 	default:
 	    debug(17, 1) ("fwdDispatch: Cannot retrieve '%s'\n",
 		storeUrl(entry));
-	    err = errorCon(ERR_UNSUP_REQ, HTTP_BAD_REQUEST);
-	    err->request = requestLink(request);
-	    errorAppendEntry(entry, err);
+	    fwdFail(fwdState, ERR_UNSUP_REQ, HTTP_BAD_REQUEST, -1);
+	    comm_close(fwdState->server_fd);
 	    break;
 	}
     }
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: fqdncache.cc,v 1.121 1998/10/10 14:57:39 wessels Exp $
+ * $Id: fqdncache.cc,v 1.122 1998/11/12 06:28:06 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -233,6 +233,10 @@ fqdncacheParse(const char *inbuf)
     memset(&f, '\0', sizeof(f));
     f.expires = squid_curtime;
     f.status = FQDN_NEGATIVE_CACHED;
+    if (inbuf == NULL) {
+	debug(35, 1) ("fqdncacheParse: Got <NULL> reply\n");
+	return &f;
+    }
     token = strtok(buf, w_space);
     if (NULL == token) {
 	debug(35, 1) ("fqdncacheParse: Got <NULL>, expecting '$name'\n");
@@ -275,24 +279,22 @@ fqdncacheHandleReply(void *data, char *reply)
     generic_cbdata *c = data;
     fqdncache_entry *f = c->data;
     fqdncache_entry *x = NULL;
-    n = ++FqdncacheStats.replies;
     assert(f->status == FQDN_DISPATCHED);
     assert(f->locks);
     cbdataFree(c);
     c = NULL;
+    n = ++FqdncacheStats.replies;
     statHistCount(&Counter.dns.svc_time,
 	tvSubMsec(f->request_time, current_time));
-    if ((x = fqdncacheParse(reply)) == NULL) {
-	debug(35, 0) ("fqdncache_dnsHandleRead: fqdncacheParse failed?!\n");
-    } else {
-	f->name_count = x->name_count;
-	for (n = 0; n < (int) f->name_count; n++)
-	    f->names[n] = x->names[n];
-	f->error_message = x->error_message;
-	f->status = x->status;
-	f->expires = x->expires;
-	fqdncache_call_pending(f);
-    }
+    x = fqdncacheParse(reply);
+    assert(x);
+    f->name_count = x->name_count;
+    for (n = 0; n < (int) f->name_count; n++)
+	f->names[n] = x->names[n];
+    f->error_message = x->error_message;
+    f->status = x->status;
+    f->expires = x->expires;
+    fqdncache_call_pending(f);
     fqdncacheUnlockEntry(f);	/* unlock from FQDN_DISPATCHED */
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.253 1998/09/23 20:13:49 wessels Exp $
+ * $Id: ftp.cc,v 1.254 1998/11/12 06:28:07 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -138,14 +138,17 @@ typedef struct {
 
 typedef void (FTPSM) (FtpStateData *);
 
+#define FTP_LOGIN_ESCAPED 1
+#define FTP_LOGIN_NOT_ESCAPED 0
+
 /* Local functions */
 static CNCB ftpPasvCallback;
 static PF ftpDataRead;
 static PF ftpStateFree;
 static PF ftpTimeout;
 static PF ftpReadControlReply;
 static CWCB ftpWriteCommandCallback;
-static void ftpLoginParser(const char *, FtpStateData *);
+static void ftpLoginParser(const char *, FtpStateData *, int escaped);
 static wordlist *ftpParseControlReply(char *, size_t, int *, int *);
 static void ftpAppendSuccessHeader(FtpStateData * ftpState);
 static void ftpAuthRequired(HttpReply * reply, request_t * request, const char *realm);
@@ -287,18 +290,20 @@ ftpStateFree(int fdnotused, void *data)
 }
 
 static void
-ftpLoginParser(const char *login, FtpStateData * ftpState)
+ftpLoginParser(const char *login, FtpStateData * ftpState, int escaped)
 {
     char *s = NULL;
     xstrncpy(ftpState->user, login, MAX_URL);
     if ((s = strchr(ftpState->user, ':'))) {
 	*s = 0;
 	xstrncpy(ftpState->password, s + 1, MAX_URL);
-	rfc1738_unescape(ftpState->password);
+	if (escaped)
+	    rfc1738_unescape(ftpState->password);
     } else {
 	xstrncpy(ftpState->password, null_string, MAX_URL);
     }
-    rfc1738_unescape(ftpState->user);
+    if (escaped)
+	rfc1738_unescape(ftpState->user);
     if (ftpState->user[0] || ftpState->password[0])
 	return;
     xstrncpy(ftpState->user, "anonymous", MAX_URL);
@@ -869,7 +874,7 @@ ftpCheckAuth(FtpStateData * ftpState, const HttpHeader * req_hdr)
 {
     char *orig_user;
     const char *auth;
-    ftpLoginParser(ftpState->request->login, ftpState);
+    ftpLoginParser(ftpState->request->login, ftpState, FTP_LOGIN_ESCAPED);
     if (ftpState->user[0] && ftpState->password[0])
 	return 1;		/* name and passwd both in URL */
     if (!ftpState->user[0] && !ftpState->password[0])
@@ -879,8 +884,9 @@ ftpCheckAuth(FtpStateData * ftpState, const HttpHeader * req_hdr)
     /* URL has name, but no passwd */
     if (!(auth = httpHeaderGetAuth(req_hdr, HDR_AUTHORIZATION, "Basic")))
 	return 0;		/* need auth header */
+    ftpState->flags.authenticated = 1;
     orig_user = xstrdup(ftpState->user);
-    ftpLoginParser(auth, ftpState);
+    ftpLoginParser(auth, ftpState, FTP_LOGIN_NOT_ESCAPED);
     if (!strcmp(orig_user, ftpState->user)) {
 	xfree(orig_user);
 	return 1;		/* same username */
@@ -953,6 +959,8 @@ ftpStart(request_t * request, StoreEntry * entry, int fd)
     const char *url = storeUrl(entry);
     FtpStateData *ftpState = xcalloc(1, sizeof(FtpStateData));
     HttpReply *reply;
+    StoreEntry *pe = NULL;
+    const cache_key *key = NULL;
     cbdataAdd(ftpState, MEM_NONE);
     debug(9, 3) ("FtpStart: '%s'\n", url);
     Counter.server.all.requests++;
@@ -975,6 +983,10 @@ ftpStart(request_t * request, StoreEntry * entry, int fd)
 	    snprintf(realm, 8192, "ftp %s port %d",
 		ftpState->user, request->port);
 	}
+	/* eject any old cached object */
+	key = storeKeyPublic(entry->mem_obj->url, entry->mem_obj->method);
+	if ((pe = storeGet(key)) != NULL)
+	    storeRelease(pe);
 	/* create reply */
 	reply = entry->mem_obj->reply;
 	assert(reply != NULL);
@@ -1097,7 +1109,7 @@ ftpParseControlReply(char *buf, size_t len, int *codep, int *used)
 	if (linelen > 3)
 	    if (*s >= '0' && *s <= '9' && (*(s + 3) == '-' || *(s + 3) == ' '))
 		offset = 4;
-	list = xcalloc(1, sizeof(wordlist));
+	list = memAllocate(MEM_WORDLIST);
 	list->key = xmalloc(linelen - offset);
 	xstrncpy(list->key, s + offset, linelen - offset);
 	debug(9, 7) ("%d %s\n", code, list->key);
@@ -1333,20 +1345,14 @@ static void
 ftpReadType(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    wordlist *w;
-    wordlist **T;
     char *path;
     char *d;
     debug(9, 3) ("This is ftpReadType\n");
     if (code == 200) {
 	path = xstrdup(strBuf(ftpState->request->urlpath));
-	T = &ftpState->pathcomps;
 	for (d = strtok(path, "/"); d; d = strtok(NULL, "/")) {
 	    rfc1738_unescape(d);
-	    w = xcalloc(1, sizeof(wordlist));
-	    w->key = xstrdup(d);
-	    *T = w;
-	    T = &w->next;
+	    wordlistAdd(&ftpState->pathcomps, d);
 	}
 	xfree(path);
 	if (ftpState->pathcomps)
@@ -2195,6 +2201,7 @@ ftpAppendSuccessHeader(FtpStateData * ftpState)
     const char *filename = NULL;
     const char *t = NULL;
     StoreEntry *e = ftpState->entry;
+    StoreEntry *pe = NULL;
     http_reply *reply = e->mem_obj->reply;
     if (ftpState->flags.http_header_sent)
 	return;
@@ -2230,8 +2237,20 @@ ftpAppendSuccessHeader(FtpStateData * ftpState)
     storeBufferFlush(e);
     reply->hdr_sz = e->mem_obj->inmem_hi;
     storeTimestampsSet(e);
-    if (EBIT_TEST(e->flags, ENTRY_CACHABLE))
+    if (ftpState->flags.authenticated) {
+	/*
+	 * Authenticated requests can't be cached. Eject any old cached
+	 * object
+	 */
+	pe = storeGetPublic(e->mem_obj->url, e->mem_obj->method);
+	if (pe)
+	    storeRelease(pe);
+	storeRelease(e);
+    } else if (EBIT_TEST(e->flags, ENTRY_CACHABLE)) {
 	storeSetPublicKey(e);
+    } else {
+	storeRelease(e);
+    }
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.69 1998/10/17 04:53:40 rousskov Exp $
+ * $Id: globals.h,v 1.70 1998/11/12 06:28:08 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -132,12 +132,11 @@ extern const int CacheDigestHashFuncCount;	/* 4 */
 extern CacheDigest *store_digest;	/* NULL */
 extern const char *StoreDigestUrlPath;	/* "store_digest" */
 extern const char *StoreDigestMimeStr;	/* "application/cache-digest" */
+#if USE_CACHE_DIGESTS
 extern const Version CacheDigestVer;	/* { 4, 3 } */
+#endif
 extern const char *MultipartMsgBoundaryStr;	/* "Unique-Squid-Separator" */
 extern icpUdpData *IcpQueueHead;	/* NULL */
-#if DELAY_POOLS
-extern time_t delay_pools_last_update;	/* 0 */
-#endif
 #if HTTP_VIOLATIONS
 extern int refresh_nocache_hack;	/* 0 */
 #endif
@@ -45,6 +45,7 @@ helperOpenServers(helper * hlp)
     args[nargs++] = NULL;
     assert(nargs <= HELPER_MAX_ARGS);
     for (k = 0; k < hlp->n_to_start; k++) {
+	getCurrentTime();
 	rfd = wfd = -1;
 	x = ipcCreate(hlp->ipc_type,
 	    progname,
@@ -57,8 +58,8 @@ helperOpenServers(helper * hlp)
 	    continue;
 	}
 	hlp->n_running++;
-	srv = xcalloc(1, sizeof(*srv));
-	cbdataAdd(srv, MEM_NONE);
+	srv = memAllocate(MEM_HELPER_SERVER);
+	cbdataAdd(srv, MEM_HELPER_SERVER);
 	srv->flags.alive = 1;
 	srv->index = k;
 	srv->rfd = rfd;
@@ -91,7 +92,7 @@ helperOpenServers(helper * hlp)
 void
 helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
-    helper_request *r = xcalloc(1, sizeof(*r));
+    helper_request *r = memAllocate(MEM_HELPER_REQUEST);
     helper_server *srv;
     if (hlp == NULL) {
 	debug(29, 3) ("helperSubmit: hlp == NULL\n");
@@ -154,10 +155,11 @@ helperStats(StoreEntry * sentry, helper * hlp)
 void
 helperShutdown(helper * hlp)
 {
-    dlink_node *link;
+    dlink_node *link = hlp->servers.head;
     helper_server *srv;
-    for (link = hlp->servers.head; link; link = link->next) {
+    while (link) {
 	srv = link->data;
+	link = link->next;
 	if (!srv->flags.alive) {
 	    debug(34, 3) ("helperShutdown: %s #%d is NOT ALIVE.\n",
 		hlp->id_name, srv->index + 1);
@@ -182,8 +184,8 @@ helperShutdown(helper * hlp)
 helper *
 helperCreate(const char *name)
 {
-    helper *hlp = xcalloc(1, sizeof(*hlp));
-    cbdataAdd(hlp, MEM_NONE);
+    helper *hlp = memAllocate(MEM_HELPER);
+    cbdataAdd(hlp, MEM_HELPER);
     hlp->id_name = name;
     return hlp;
 }
@@ -273,16 +275,17 @@ helperHandleRead(int fd, void *data)
 	    hlp->stats.replies, REDIRECT_AV_FACTOR);
 	if (srv->flags.shutdown)
 	    comm_close(srv->wfd);
+	else
+	    helperKickQueue(hlp);
     } else {
 	commSetSelect(srv->rfd, COMM_SELECT_READ, helperHandleRead, srv, 0);
     }
-    helperKickQueue(hlp);
 }
 
 static void
 Enqueue(helper * hlp, helper_request * r)
 {
-    dlink_node *link = xcalloc(1, sizeof(*link));
+    dlink_node *link = memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
     hlp->stats.queue_size++;
     if (hlp->stats.queue_size < hlp->n_running)
@@ -307,7 +310,7 @@ Dequeue(helper * hlp)
     if ((link = hlp->queue.head)) {
 	r = link->data;
 	dlinkDelete(link, &hlp->queue);
-	safe_free(link);
+	memFree(MEM_DLINK_NODE, link);
 	hlp->stats.queue_size--;
     }
     return r;
@@ -374,5 +377,5 @@ helperRequestFree(helper_request * r)
 {
     cbdataUnlock(r->data);
     xfree(r->buf);
-    xfree(r);
+    memFree(MEM_HELPER_REQUEST, r);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.331 1998/10/19 22:37:01 wessels Exp $
+ * $Id: http.cc,v 1.332 1998/11/12 06:28:10 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -175,6 +175,7 @@ httpCachableReply(HttpStateData * httpState)
     HttpReply *rep = httpState->entry->mem_obj->reply;
     HttpHeader *hdr = &rep->header;
     const int cc_mask = (rep->cache_control) ? rep->cache_control->mask : 0;
+    const char *v;
     if (EBIT_TEST(cc_mask, CC_PRIVATE))
 	return 0;
     if (EBIT_TEST(cc_mask, CC_NO_CACHE))
@@ -196,6 +197,23 @@ httpCachableReply(HttpStateData * httpState)
      */
     if (httpHeaderHas(hdr, HDR_VARY))
 	return 0;
+    /* Pragma: no-cache in _replies_ is not documented in HTTP,
+     * but servers like "Active Imaging Webcast/2.0" sure do use it */
+    if (httpHeaderHas(hdr, HDR_PRAGMA)) {
+	String s = httpHeaderGetList(hdr, HDR_PRAGMA);
+	const int no_cache = strListIsMember(&s, "no-cache", ',');
+	stringClean(&s);
+	if (no_cache)
+	    return 0;
+    }
+    /*
+     * The "multipart/x-mixed-replace" content type is used for
+     * continuous push replies.  These are generally dynamic and
+     * probably should not be cachable
+     */
+    if ((v = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE)))
+	if (!strncasecmp(v, "multipart/x-mixed-replace", 25))
+	    return 0;
     switch (httpState->entry->mem_obj->reply->sline.status) {
 	/* Responses that are cacheable */
     case HTTP_OK:
@@ -592,7 +610,7 @@ httpBuildRequestHeader(request_t * request,
      *  the server and fetch only the requested content) 
      */
     we_do_ranges =
-	orig_request->range && orig_request->flags.cachable && !httpHdrRangeWillBeComplex(orig_request->range);
+	orig_request->range && orig_request->flags.cachable && !httpHdrRangeWillBeComplex(orig_request->range) && (Config.rangeOffsetLimit == -1 || httpHdrRangeFirstOffset(orig_request->range) <= Config.rangeOffsetLimit);
     debug(11, 8) ("httpBuildRequestHeader: range specs: %p, cachable: %d; we_do_ranges: %d\n",
 	orig_request->range, orig_request->flags.cachable, we_do_ranges);
 
@@ -604,13 +622,20 @@ httpBuildRequestHeader(request_t * request,
 	    continue;
 	switch (e->id) {
 	case HDR_PROXY_AUTHORIZATION:
-	    /* If we're not going to do proxy auth, then it must be passed on */
+	    /* If we're not doing proxy auth, then it must be passed on */
 	    if (!request->flags.used_proxy_auth)
 		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
 	    break;
+	case HDR_AUTHORIZATION:
+	    /* If we're not doing www auth, then it must be passed on */
+	    if (!request->flags.accelerated || !request->flags.used_proxy_auth)
+		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+	    else
+		request->flags.auth = 0;	/* We have used the authentication */
+	    break;
 	case HDR_HOST:
 	    /* Don't use client's Host: header for redirected requests */
-	    if (!request->flags.redirected)
+	    if (!request->flags.redirected || !Config.onoff.redir_rewrites_host)
 		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
 	    break;
 	case HDR_IF_MODIFIED_SINCE:
@@ -676,6 +701,20 @@ httpBuildRequestHeader(request_t * request,
 		orig_request->host, (int) orig_request->port);
 	}
     }
+    /* append Authorization if known in URL, not in header and going direct */
+    if (!httpHeaderHas(hdr_out, HDR_AUTHORIZATION)) {
+	if (!request->flags.proxying && *request->login) {
+	    httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
+		base64_encode(request->login));
+	}
+    }
+    /* append Proxy-Authorization if configured for peer, and proxying */
+    if (!httpHeaderHas(hdr_out, HDR_PROXY_AUTHORIZATION)) {
+	if (request->flags.proxying && request->peer_login) {
+	    httpHeaderPutStrf(hdr_out, HDR_PROXY_AUTHORIZATION, "Basic %s",
+		base64_encode(request->peer_login));
+	}
+    }
     /* append Cache-Control, add max-age if not there already */
     {
 	HttpHdrCc *cc = httpHeaderGetCc(hdr_in);
@@ -800,6 +839,7 @@ httpStart(FwdState * fwdState, int fd)
 	xstrncpy(proxy_req->host, httpState->peer->host, SQUIDHOSTNAMELEN);
 	proxy_req->port = httpState->peer->http_port;
 	proxy_req->flags = orig_req->flags;
+	proxy_req->peer_login = httpState->peer->login;
 	httpState->request = requestLink(proxy_req);
 	httpState->orig_request = requestLink(orig_req);
 	proxy_req->flags.proxying = 1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: internal.cc,v 1.14 1998/08/20 15:30:22 wessels Exp $
+ * $Id: internal.cc,v 1.15 1998/11/12 06:28:11 wessels Exp $
  *
  * DEBUG: section 76    Internal Squid Object handling
  * AUTHOR: Duane, Alex, Henrik
@@ -101,3 +101,12 @@ internalLocalUri(const char *dir, const char *name)
 {
     return internalRemoteUri(getMyHostname(), Config.Port.http->i, dir, name);
 }
+
+const char *
+internalHostname(void)
+{
+    LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
+    xstrncpy(host, getMyHostname(), SQUIDHOSTNAMELEN);
+    Tolower(host);
+    return host;
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipc.cc,v 1.11 1998/08/18 19:14:03 wessels Exp $
+ * $Id: ipc.cc,v 1.12 1998/11/12 06:28:12 wessels Exp $
  *
  * DEBUG: section 54    Interprocess Communication
  * AUTHOR: Duane Wessels
@@ -68,7 +68,9 @@ ipcCreate(int type, const char *prog, char *const args[], const char *name, int
     int fd;
     socklen_t len;
     int tmp_s;
+#if HAVE_PUTENV
     char *env_str;
+#endif
     int x;
 
 #if HAVE_POLL && defined(_SQUID_OSF_)
@@ -237,9 +239,11 @@ ipcCreate(int type, const char *prog, char *const args[], const char *name, int
 	    _exit(1);
 	}
     }
+#if HAVE_PUTENV
     env_str = xcalloc((tmp_s = strlen(Config.debugOptions) + 32), 1);
     snprintf(env_str, tmp_s, "SQUID_DEBUG=%s", Config.debugOptions);
     putenv(env_str);
+#endif
     dup2(crfd, 0);
     dup2(cwfd, 1);
     dup2(fileno(debug_log), 2);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.205 1998/10/19 04:44:38 wessels Exp $
+ * $Id: ipcache.cc,v 1.206 1998/11/12 06:28:13 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -265,11 +265,15 @@ ipcacheParse(const char *inbuf)
     int ipcount = 0;
     int ttl;
     char A[32][16];
-    xstrncpy(buf, inbuf, DNS_INBUF_SZ);
-    debug(14, 5) ("ipcacheParse: parsing:%s\n", buf);
     memset(&i, '\0', sizeof(i));
     i.expires = squid_curtime;
     i.status = IP_NEGATIVE_CACHED;
+    if (inbuf == NULL) {
+	debug(14, 1) ("ipcacheParse: Got <NULL> reply\n");
+	return &i;
+    }
+    xstrncpy(buf, inbuf, DNS_INBUF_SZ);
+    debug(14, 5) ("ipcacheParse: parsing:%s\n", buf);
     token = strtok(buf, w_space);
     if (NULL == token) {
 	debug(14, 1) ("ipcacheParse: Got <NULL>, expecting '$addr'\n");
@@ -332,15 +336,13 @@ ipcacheHandleReply(void *data, char *reply)
     c = NULL;
     n = ++IpcacheStats.replies;
     statHistCount(&Counter.dns.svc_time, tvSubMsec(i->request_time, current_time));
-    if ((x = ipcacheParse(reply)) == NULL) {
-	debug(14, 0) ("ipcache_dnsHandleRead: ipcacheParse failed?!\n");
-    } else {
-	i->status = x->status;
-	i->addrs = x->addrs;
-	i->error_message = x->error_message;
-	i->expires = x->expires;
-	ipcache_call_pending(i);
-    }
+    x = ipcacheParse(reply);
+    assert(x);
+    i->status = x->status;
+    i->addrs = x->addrs;
+    i->error_message = x->error_message;
+    i->expires = x->expires;
+    ipcache_call_pending(i);
     ipcacheUnlockEntry(i);	/* unlock from IP_DISPATCHED */
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.275 1998/11/11 20:04:16 glenn Exp $
+ * $Id: main.cc,v 1.276 1998/11/12 06:28:14 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -318,7 +318,7 @@ mainReconfigure(void)
     redirectShutdown();
     authenticateShutdown();
     storeDirCloseSwapLogs();
-    errorFree();
+    errorClean();
     parseConfigFile(ConfigFile);
     _db_init(Config.Log.log, Config.debugOptions);
     ipcache_restart();		/* clear stuck entries */
@@ -416,7 +416,6 @@ mainInitialize(void)
 #ifdef SQUID_SNMP
     snmpInit();
 #endif
- 
 
 #if MALLOC_DBG
     malloc_debug(0, malloc_debug_level);
@@ -715,7 +714,6 @@ SquidShutdown(void *unused)
 #if PURIFY || XMALLOC_TRACE
     configFreeMemory();
     storeFreeMemory();
-    dnsFreeMemory();
     /*stmemFreeMemory(); */
     netdbFreeMemory();
     ipcacheFreeMemory();
@@ -725,6 +723,8 @@ SquidShutdown(void *unused)
     httpHeaderCleanModule();
     statFreeMemory();
     eventFreeMemory();
+    mimeFreeMemory();
+    errorClean();
 #endif
     memClean();
 #if !XMALLOC_TRACE
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.34 1998/08/30 05:21:42 wessels Exp $
+ * $Id: mem.cc,v 1.35 1998/11/12 06:28:14 wessels Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -207,7 +207,9 @@ memInit(void)
     memDataInit(MEM_AIO_RESULT_T, "aio_result_t", sizeof(aio_result_t), 0);
     memDataInit(MEM_CACHEMGR_PASSWD, "cachemgr_passwd",
 	sizeof(cachemgr_passwd), 0);
+#if USE_CACHE_DIGESTS
     memDataInit(MEM_CACHE_DIGEST, "CacheDigest", sizeof(CacheDigest), 0);
+#endif
     memDataInit(MEM_CLIENTHTTPREQUEST, "clientHttpRequest",
 	sizeof(clientHttpRequest), 0);
     memDataInit(MEM_CLOSE_HANDLER, "close_handler", sizeof(close_handler), 0);
@@ -255,7 +257,9 @@ memInit(void)
     memDataInit(MEM_NETDBENTRY, "netdbEntry", sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, "net_db_name", sizeof(net_db_name), 0);
     memDataInit(MEM_NET_DB_PEER, "net_db_peer", sizeof(net_db_peer), 0);
+#if USE_CACHE_DIGESTS
     memDataInit(MEM_DIGEST_FETCH_STATE, "DigestFetchState", sizeof(DigestFetchState), 0);
+#endif
     memDataInit(MEM_PEER, "peer", sizeof(peer), 0);
     memDataInit(MEM_PINGERECHODATA, "pingerEchoData",
 	sizeof(pingerEchoData), 0);
@@ -278,6 +282,11 @@ memInit(void)
     memDataInit(MEM_WORDLIST, "wordlist", sizeof(wordlist), 0);
     memDataInit(MEM_CLIENT_INFO, "ClientInfo", sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, "MD5 digest", MD5_DIGEST_CHARS, 0);
+    memDataInit(MEM_HELPER, "helper", sizeof(helper), 0);
+    memDataInit(MEM_HELPER_REQUEST, "helper_request",
+	sizeof(helper_request), 0);
+    memDataInit(MEM_HELPER_SERVER, "helper_server",
+	sizeof(helper_server), 0);
     /* test that all entries are initialized */
     for (t = MEM_NONE, t++; t < MEM_MAX; t++) {
 	if (MEM_DONTFREE == t)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.81 1998/09/21 06:52:17 wessels Exp $
+ * $Id: mime.cc,v 1.82 1998/11/12 06:28:15 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -365,6 +365,22 @@ mimeInit(char *filename)
     debug(25, 1) ("Loaded Icons.\n");
 }
 
+void
+mimeFreeMemory(void)
+{
+    mimeEntry *m;
+    while ((m = MimeTable)) {
+	MimeTable = m->next;
+	safe_free(m->pattern);
+	safe_free(m->content_type);
+	safe_free(m->icon);
+	safe_free(m->content_encoding);
+	regfree(&m->compiled_pattern);
+	safe_free(m);
+    }
+    MimeTableTail = &MimeTable;
+}
+
 static void
 mimeLoadIconFile(const char *icon)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.258 1998/10/12 21:40:59 wessels Exp $
+ * $Id: neighbors.cc,v 1.259 1998/11/12 06:28:16 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -1116,6 +1116,8 @@ dump_peer_options(StoreEntry * sentry, peer * p)
     if (p->options.no_delay)
 	storeAppendPrintf(sentry, " no-delay");
 #endif
+    if (p->login)
+	storeAppendPrintf(sentry, " login=%s", p->login);
     if (p->mcast.ttl > 0)
 	storeAppendPrintf(sentry, " ttl=%d", p->mcast.ttl);
     storeAppendPrintf(sentry, "\n");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.131 1998/10/13 23:33:34 wessels Exp $
+ * $Id: net_db.cc,v 1.132 1998/11/12 06:28:17 wessels Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -75,7 +75,6 @@ static void netdbExchangeDone(void *);
  * remain persisitent, so _net_db_peer->peername points into this
  * linked list */
 static wordlist *peer_names = NULL;
-static wordlist **peer_names_tail = &peer_names;
 
 static void
 netdbHashInsert(netdbEntry * n, struct in_addr addr)
@@ -474,10 +473,7 @@ netdbPeerName(const char *name)
 	if (!strcmp(w->key, name))
 	    return w->key;
     }
-    w = xcalloc(1, sizeof(wordlist));
-    w->key = xstrdup(name);
-    *peer_names_tail = w;
-    peer_names_tail = &w->next;
+    w = wordlistAdd(&peer_names, name);
     return w->key;
 }
 
@@ -691,7 +687,6 @@ netdbFreeMemory(void)
     host_table = NULL;
     wordlistDestroy(&peer_names);
     peer_names = NULL;
-    peer_names_tail = &peer_names;
 #endif
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.56 1998/09/29 16:33:48 wessels Exp $
+ * $Id: peer_digest.cc,v 1.57 1998/11/12 06:28:18 wessels Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -47,10 +47,10 @@ static void peerDigestDisable(peer * p);
 static void peerDigestDelay(peer * p, int disable, time_t delay);
 static EVH peerDigestValidate;
 static void peerDigestRequest(peer * p);
-static void peerDigestFetchReply(void *data, char *buf, ssize_t size);
+static STCB peerDigestFetchReply;
 static void peerDigestRequest(peer * p);
-static void peerDigestSwapInHeaders(void *data, char *buf, ssize_t size);
-static void peerDigestSwapInCBlock(void *data, char *buf, ssize_t size);
+static STCB peerDigestSwapInHeaders;
+static STCB peerDigestSwapInCBlock;
 static STCB peerDigestSwapInMask;
 static int peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const char *step_name);
 static void peerDigestFetchFinish(DigestFetchState * fetch, char *buf, const char *err_msg);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.88 1998/10/13 23:33:35 wessels Exp $
+ * $Id: peer_select.cc,v 1.89 1998/11/12 06:28:19 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -306,8 +306,11 @@ peerSelectFoo(ps_state * psstate)
 	return;
     }
     if ((p = getSingleParent(request))) {
-	psstate->single_parent = p->in_addr;
-	debug(44, 3) ("peerSelect: found single parent, skipping ICP query\n");
+	code = SINGLE_PARENT;
+	debug(44, 3) ("peerSelectFoo: %s/%s\n", hier_strings[code], p->host);
+	hierarchyNote(&request->hier, code, &psstate->ping, p->host);
+	peerSelectCallback(psstate, p);
+	return;
     }
     if (!request->flags.hierarchical && direct != DIRECT_NO) {
 	debug(44, 3) ("peerSelectFoo: DIRECT for non-hierarchical request\n");
@@ -381,11 +384,6 @@ peerSelectFoo(ps_state * psstate)
 	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
 	hierarchyNote(&request->hier, code, &psstate->ping, p->host);
 	peerSelectCallback(psstate, p);
-    } else if ((p = whichPeer(&psstate->single_parent))) {
-	code = SINGLE_PARENT;
-	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
-	hierarchyNote(&request->hier, code, &psstate->ping, p->host);
-	peerSelectCallback(psstate, p);
     } else if (direct != DIRECT_NO) {
 	code = DIRECT;
 	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], request->host);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.284 1998/11/11 20:04:17 glenn Exp $
+ * $Id: protos.h,v 1.285 1998/11/12 06:28:20 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -89,7 +89,7 @@ extern void aioCheckCallbacks(void);
 extern int parseConfigFile(const char *file_name);
 extern void intlistDestroy(intlist **);
 extern int intlistFind(intlist * list, int i);
-extern void wordlistAdd(wordlist **, const char *);
+extern wordlist *wordlistAdd(wordlist **, const char *);
 extern void wordlistDestroy(wordlist **);
 extern void configFreeMemory(void);
 extern void wordlistCat(const wordlist *, MemBuf * mb);
@@ -329,6 +329,8 @@ extern int httpHdrRangeCanonize(HttpHdrRange * range, size_t clen);
 extern String httpHdrRangeBoundaryStr(clientHttpRequest * http);
 extern int httpHdrRangeIsComplex(const HttpHdrRange * range);
 extern int httpHdrRangeWillBeComplex(const HttpHdrRange * range);
+extern size_t httpHdrRangeFirstOffset(const HttpHdrRange * range);
+
 
 /* Http Content Range Header Field */
 extern HttpHdrContRange *httpHdrContRangeCreate();
@@ -483,7 +485,7 @@ extern void snmpConnectionShutdown(void);
 extern void snmpConnectionClose(void);
 extern void snmpDebugOid(int lvl, oid * Name, snint Len);
 extern void addr2oid(struct in_addr addr, oid * Dest);
-extern struct in_addr* oid2addr(oid * id); 
+extern struct in_addr *oid2addr(oid * id);
 variable_list *snmp_basicFn(variable_list *, snint *);
 variable_list *snmp_confFn(variable_list *, snint *);
 variable_list *snmp_sysFn(variable_list *, snint *);
@@ -555,6 +557,7 @@ extern size_t headersEnd(const char *, size_t);
 extern const char *mime_get_auth(const char *hdr, const char *auth_scheme, const char **auth_field);
 
 extern void mimeInit(char *filename);
+extern void mimeFreeMemory(void);
 extern char *mimeGetContentEncoding(const char *fn);
 extern char *mimeGetContentType(const char *fn);
 extern char *mimeGetIcon(const char *fn);
@@ -987,13 +990,13 @@ extern void useragentRotateLog(void);
 extern void logUserAgent(const char *, const char *);
 extern peer_t parseNeighborType(const char *s);
 
+extern void errorInitialize(void);
+extern void errorClean(void);
 extern HttpReply *errorBuildReply(ErrorState * err);
 extern void errorSend(int fd, ErrorState *);
 extern void errorAppendEntry(StoreEntry *, ErrorState *);
 extern void errorStateFree(ErrorState * err);
-extern void errorInitialize(void);
 extern int errorReservePageId(const char *page_name);
-extern void errorFree(void);
 extern ErrorState *errorCon(err_type type, http_status);
 
 extern void pconnPush(int, const char *host, u_short port);
@@ -1072,6 +1075,7 @@ extern int internalCheck(const char *urlpath);
 extern int internalStaticCheck(const char *urlpath);
 extern char *internalLocalUri(const char *dir, const char *name);
 extern char *internalRemoteUri(const char *, u_short, const char *, const char *);
+extern const char *internalHostname(void);
 
 #if USE_CARP
 extern void carpInit(void);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.75 1998/10/19 22:37:02 wessels Exp $
+ * $Id: redirect.cc,v 1.76 1998/11/12 06:28:22 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -55,12 +55,13 @@ redirectHandleReply(void *data, char *reply)
     redirectStateData *r = data;
     int valid;
     char *t;
-    assert(cbdataValid(data));
-    debug(29, 5) ("redirectHandleRead: {%s}\n", reply);
-    if ((t = strchr(reply, ' ')))
-	*t = '\0';
-    if (*reply == '\0')
-	reply = NULL;
+    debug(29, 5) ("redirectHandleRead: {%s}\n", reply ? reply : "<NULL>");
+    if (reply) {
+	if ((t = strchr(reply, ' ')))
+	    *t = '\0';
+	if (*reply == '\0')
+	    reply = NULL;
+    }
     valid = cbdataValid(r->data);
     cbdataUnlock(r->data);
     if (valid)
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: refresh.cc,v 1.43 1998/10/19 22:37:02 wessels Exp $
+ * $Id: refresh.cc,v 1.44 1998/11/12 06:28:23 wessels Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -267,7 +267,10 @@ refreshCheckICP(const StoreEntry * entry, request_t * request)
 int
 refreshCheckDigest(const StoreEntry * entry, time_t delta)
 {
-    return refreshCheck(entry, NULL, delta, &refreshCounts[rcCDigest]);
+    return refreshCheck(entry,
+	entry->mem_obj ? entry->mem_obj->request : NULL,
+	delta,
+	&refreshCounts[rcCDigest]);
 }
 
 time_t
@@ -1,5 +1,5 @@
 /*
- * $Id: snmp_core.cc,v 1.13 1998/11/11 20:04:19 glenn Exp $
+ * $Id: snmp_core.cc,v 1.14 1998/11/12 06:28:23 wessels Exp $
  *
  * DEBUG: section 49    SNMP support
  * AUTHOR: Glenn Chisholm
@@ -38,12 +38,12 @@
 #define MAX_PROTOSTAT 5
 
 struct _mib_tree_entry {
-	oid	*name;
-	int	len;
-	oid_ParseFn *parsefunction;
-	int	children;
-	struct _mib_tree_entry **leaves;
-	struct _mib_tree_entry *parent;
+    oid *name;
+    int len;
+    oid_ParseFn *parsefunction;
+    int children;
+    struct _mib_tree_entry **leaves;
+    struct _mib_tree_entry *parent;
 };
 
 struct _snmpUdpData {
@@ -64,19 +64,19 @@ extern void (*snmplib_debug_hook) (int, char *);
 
 static void snmpDecodePacket(snmp_request_t * rq);
 static void snmpConstructReponse(snmp_request_t * rq, struct snmp_session *Session);
-static struct snmp_pdu* snmpAgentResponse(struct snmp_pdu *PDU);
+static struct snmp_pdu *snmpAgentResponse(struct snmp_pdu *PDU);
 
 static void snmpUdpSend(int, const struct sockaddr_in *, void *, int);
 static void snmpUdpReply(int, void *);
 static void snmpAppendUdp(snmpUdpData *);
 
 
-static mib_tree_entry* snmpAddNode(oid *name, int len, oid_ParseFn *parsefunction, int children, ...);
-static oid_ParseFn *snmpTreeNext(oid *Current, snint CurrentLen, oid **Next, snint *NextLen);
-static mib_tree_entry* snmpTreeEntry(oid entry, snint len, mib_tree_entry *current);
+static mib_tree_entry *snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, int children,...);
+static oid_ParseFn *snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen);
+static mib_tree_entry *snmpTreeEntry(oid entry, snint len, mib_tree_entry * current);
 
-static oid* snmpCreateOid(int length, ...);
-static oid* snmpOidDup(oid * A, snint ALen);                       
+static oid *snmpCreateOid(int length,...);
+static oid *snmpOidDup(oid * A, snint ALen);
 static void snmpSnmplibDebug(int lvl, char *buf);
 
 
@@ -89,8 +89,8 @@ static void snmpSnmplibDebug(int lvl, char *buf);
  */
 
 /*
-	Turns the MIB into a Tree structure. Called during the startup process.
-*/
+ * Turns the MIB into a Tree structure. Called during the startup process.
+ */
 void
 snmpInit(void)
 {
@@ -348,64 +348,64 @@ snmpConnectionOpen(void)
     socklen_t len;
     int x;
 
-	debug(49, 5) ("snmpConnectionOpen: Called\n");
+    debug(49, 5) ("snmpConnectionOpen: Called\n");
     if ((port = Config.Port.snmp) > (u_short) 0) {
-        enter_suid();
-        theInSnmpConnection = comm_open(SOCK_DGRAM,
-            0,
-            Config.Addrs.snmp_incoming,
-            port,
-            COMM_NONBLOCKING,
-            "SNMP Port");
-        leave_suid();
-        if (theInSnmpConnection < 0)
-            fatal("Cannot open snmp Port");
-        commSetSelect(theInSnmpConnection, COMM_SELECT_READ, snmpHandleUdp, NULL, 0);
-        debug(1, 1) ("Accepting SNMP messages on port %d, FD %d.\n",
-            (int) port, theInSnmpConnection);
-        if (Config.Addrs.snmp_outgoing.s_addr != no_addr.s_addr) {
-            enter_suid();
-            theOutSnmpConnection = comm_open(SOCK_DGRAM,
-                0,
-                Config.Addrs.snmp_outgoing,
-                port,
-                COMM_NONBLOCKING,
-                "SNMP Port");
-            leave_suid();
-            if (theOutSnmpConnection < 0)
-                fatal("Cannot open Outgoing SNMP Port");
-            commSetSelect(theOutSnmpConnection,
-                COMM_SELECT_READ,
-                snmpHandleUdp,
-                NULL, 0);
-            debug(1, 1) ("Outgoing SNMP messages on port %d, FD %d.\n",
-                (int) port, theOutSnmpConnection);
-            fd_note(theOutSnmpConnection, "Outgoing SNMP socket");
-            fd_note(theInSnmpConnection, "Incoming SNMP socket");
-        } else {
-            theOutSnmpConnection = theInSnmpConnection;
-        }
-        memset(&theOutSNMPAddr, '\0', sizeof(struct in_addr));
-        len = sizeof(struct sockaddr_in);
-        memset(&xaddr, '\0', len);
-        x = getsockname(theOutSnmpConnection,
-            (struct sockaddr *) &xaddr, &len);
-        if (x < 0)
-            debug(51, 1) ("theOutSnmpConnection FD %d: getsockname: %s\n",
-                theOutSnmpConnection, xstrerror());
-        else 
-            theOutSNMPAddr = xaddr.sin_addr;
+	enter_suid();
+	theInSnmpConnection = comm_open(SOCK_DGRAM,
+	    0,
+	    Config.Addrs.snmp_incoming,
+	    port,
+	    COMM_NONBLOCKING,
+	    "SNMP Port");
+	leave_suid();
+	if (theInSnmpConnection < 0)
+	    fatal("Cannot open snmp Port");
+	commSetSelect(theInSnmpConnection, COMM_SELECT_READ, snmpHandleUdp, NULL, 0);
+	debug(1, 1) ("Accepting SNMP messages on port %d, FD %d.\n",
+	    (int) port, theInSnmpConnection);
+	if (Config.Addrs.snmp_outgoing.s_addr != no_addr.s_addr) {
+	    enter_suid();
+	    theOutSnmpConnection = comm_open(SOCK_DGRAM,
+		0,
+		Config.Addrs.snmp_outgoing,
+		port,
+		COMM_NONBLOCKING,
+		"SNMP Port");
+	    leave_suid();
+	    if (theOutSnmpConnection < 0)
+		fatal("Cannot open Outgoing SNMP Port");
+	    commSetSelect(theOutSnmpConnection,
+		COMM_SELECT_READ,
+		snmpHandleUdp,
+		NULL, 0);
+	    debug(1, 1) ("Outgoing SNMP messages on port %d, FD %d.\n",
+		(int) port, theOutSnmpConnection);
+	    fd_note(theOutSnmpConnection, "Outgoing SNMP socket");
+	    fd_note(theInSnmpConnection, "Incoming SNMP socket");
+	} else {
+	    theOutSnmpConnection = theInSnmpConnection;
+	}
+	memset(&theOutSNMPAddr, '\0', sizeof(struct in_addr));
+	len = sizeof(struct sockaddr_in);
+	memset(&xaddr, '\0', len);
+	x = getsockname(theOutSnmpConnection,
+	    (struct sockaddr *) &xaddr, &len);
+	if (x < 0)
+	    debug(51, 1) ("theOutSnmpConnection FD %d: getsockname: %s\n",
+		theOutSnmpConnection, xstrerror());
+	else
+	    theOutSNMPAddr = xaddr.sin_addr;
     }
 }
 
 void
 snmpConnectionShutdown(void)
 {
     if (theInSnmpConnection < 0)
-        return;
+	return;
     if (theInSnmpConnection != theOutSnmpConnection) {
-        debug(49, 1) ("FD %d Closing SNMP socket\n", theInSnmpConnection);
-        comm_close(theInSnmpConnection);
+	debug(49, 1) ("FD %d Closing SNMP socket\n", theInSnmpConnection);
+	comm_close(theInSnmpConnection);
     }
     /*
      * Here we set 'theInSnmpConnection' to -1 even though the SNMP 'in'
@@ -428,14 +428,14 @@ snmpConnectionClose(void)
 {
     snmpConnectionShutdown();
     if (theOutSnmpConnection > -1) {
-        debug(49, 1) ("FD %d Closing SNMP socket\n", theOutSnmpConnection);
-        comm_close(theOutSnmpConnection);
+	debug(49, 1) ("FD %d Closing SNMP socket\n", theOutSnmpConnection);
+	comm_close(theOutSnmpConnection);
     }
 }
 
 /*
-	Functions for handling the requests.
-*/
+ * Functions for handling the requests.
+ */
 
 /*
  * Accept the UDP packet
@@ -572,7 +572,7 @@ snmpAgentResponse(struct snmp_pdu *PDU)
 	    int NextOidNameLen = 0;
 
 	    ParseFn = snmpTreeNext(PDU->variables->name, PDU->variables->name_length,
-		&(NextOidName), (snint *) &NextOidNameLen);
+		&(NextOidName), (snint *) & NextOidNameLen);
 
 	    if (ParseFn == NULL) {
 		Answer->errstat = SNMP_ERR_NOSUCHNAME;
@@ -582,7 +582,7 @@ snmpAgentResponse(struct snmp_pdu *PDU)
 		xfree(PDU->variables->name);
 		PDU->variables->name = NextOidName;
 		PDU->variables->name_length = NextOidNameLen;
-		VarNew = (*ParseFn) (PDU->variables, (snint *) &Answer->errstat);
+		VarNew = (*ParseFn) (PDU->variables, (snint *) & Answer->errstat);
 	    }
 
 	    /* Was there an error? */
@@ -596,9 +596,9 @@ snmpAgentResponse(struct snmp_pdu *PDU)
 		Answer->variables = VarNew;
 	    }
 
-	}else{
-		snmp_free_pdu(Answer);
-		Answer = NULL;
+	} else {
+	    snmp_free_pdu(Answer);
+	    Answer = NULL;
 	}
     }
     return (Answer);
@@ -620,33 +620,33 @@ snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
     if (Current[count] == mibTreeEntry->name[count]) {
 	count++;
 	while ((mibTreeEntry) && (count < CurrentLen)) {
-	    mibTreeEntry = snmpTreeEntry(Current[count], count , mibTreeEntry);
+	    mibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
 	    count++;
 	}
 	debug(49, 5) ("snmpTreeNext: Past first\n");
 
 	if (mibTreeEntry->parsefunction) {
-	    while(!new_oid){
-		new_oid = snmpTreeEntry(Current[count]+1, count , mibTreeEntry->parent);
-		if(!new_oid){
+	    while (!new_oid) {
+		new_oid = snmpTreeEntry(Current[count] + 1, count, mibTreeEntry->parent);
+		if (!new_oid) {
 		    mibTreeEntry = mibTreeEntry->parent;
 		    count--;
 		}
 	    }
-	} 
+	}
 	debug(49, 5) ("snmpTreeNext: Past Second\n");
 
 	if ((!mibTreeEntry->parsefunction) && (mibTreeEntry)) {
 	    while (!mibTreeEntry->parsefunction) {
-		mibTreeEntry = snmpTreeEntry(1, count , mibTreeEntry);
+		mibTreeEntry = snmpTreeEntry(1, count, mibTreeEntry);
 		count++;
 	    }
 	}
 	debug(49, 5) ("snmpTreeNext: Past Third\n");
     }
-    if(mibTreeEntry){
-        *Next = snmpOidDup(mibTreeEntry->name, mibTreeEntry->len);
-        *NextLen = mibTreeEntry->len;
+    if (mibTreeEntry) {
+	*Next = snmpOidDup(mibTreeEntry->name, mibTreeEntry->len);
+	*NextLen = mibTreeEntry->len;
 	Fn = mibTreeEntry->parsefunction;
     }
     debug(49, 5) ("snmpTreeNext: return\n");
@@ -661,7 +661,7 @@ snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
 
     debug(49, 5) ("snmpTreeEntry: Called\n");
 
-    debug(49, 6) ("snmpTreeEntry: Oid: %d, Len: %d, Current : \n",entry, len);
+    debug(49, 6) ("snmpTreeEntry: Oid: %d, Len: %d, Current : \n", entry, len);
     snmpDebugOid(6, current->name, current->len);
 
     while ((!next) && (count < current->children)) {
@@ -672,22 +672,22 @@ snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
 	}
 	count++;
     }
-    if(next){
-    	debug(49, 6) ("snmpTreeEntry: Returned : \n");
-    	snmpDebugOid(6, next->name, next->len);
+    if (next) {
+	debug(49, 6) ("snmpTreeEntry: Returned : \n");
+	snmpDebugOid(6, next->name, next->len);
     }
     return (next);
 }
 
 /*
-	Send the UDP reply.
-*/
+ * Send the UDP reply.
+ */
 void
 snmpUdpSend(int fd, const struct sockaddr_in *to, void *msg, int len)
 {
     snmpUdpData *data = xcalloc(1, sizeof(snmpUdpData));
     debug(49, 5) ("snmpUdpSend: Queueing response for %s\n",
-        inet_ntoa(to->sin_addr));
+	inet_ntoa(to->sin_addr));
     data->address = *to;
     data->msg = msg;
     data->len = len;
@@ -704,29 +704,29 @@ snmpUdpReply(int fd, void *data)
     /* Disable handler, in case of errors. */
     commSetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
     while ((queue = snmpUdpHead) != NULL) {
-        debug(49, 5) ("snmpUdpReply: FD %d sending %d bytes to %s port %d\n",
-            fd,
-            queue->len,
-            inet_ntoa(queue->address.sin_addr),
-            ntohs(queue->address.sin_port));
-        x = comm_udp_sendto(fd,
-            &queue->address,
-            sizeof(struct sockaddr_in),
-            queue->msg,
-            queue->len);
-        if (x < 0) {
-            if (ignoreErrno(errno))
-                break;          /* don't de-queue */
-        }
-        snmpUdpHead = queue->next;
-        debug(49, 3) ("snmpUdpReply: freeing %p\n", queue->msg);
-        safe_free(queue->msg);
-        debug(49, 3) ("snmpUdpReply: freeing %p\n", queue);
-        safe_free(queue);
+	debug(49, 5) ("snmpUdpReply: FD %d sending %d bytes to %s port %d\n",
+	    fd,
+	    queue->len,
+	    inet_ntoa(queue->address.sin_addr),
+	    ntohs(queue->address.sin_port));
+	x = comm_udp_sendto(fd,
+	    &queue->address,
+	    sizeof(struct sockaddr_in),
+	    queue->msg,
+	    queue->len);
+	if (x < 0) {
+	    if (ignoreErrno(errno))
+		break;		/* don't de-queue */
+	}
+	snmpUdpHead = queue->next;
+	debug(49, 3) ("snmpUdpReply: freeing %p\n", queue->msg);
+	safe_free(queue->msg);
+	debug(49, 3) ("snmpUdpReply: freeing %p\n", queue);
+	safe_free(queue);
     }
     /* Reinstate handler if needed */
     if (snmpUdpHead) {
-        commSetSelect(fd, COMM_SELECT_WRITE, snmpUdpReply, snmpUdpHead, 0);
+	commSetSelect(fd, COMM_SELECT_WRITE, snmpUdpReply, snmpUdpHead, 0);
     }
 }
 
@@ -735,114 +735,112 @@ snmpAppendUdp(snmpUdpData * item)
 {
     item->next = NULL;
     if (snmpUdpHead == NULL) {
-        snmpUdpHead = item;
-        snmpUdpTail = item;
+	snmpUdpHead = item;
+	snmpUdpTail = item;
     } else if (snmpUdpTail == snmpUdpHead) {
-        snmpUdpTail = item;
-        snmpUdpHead->next = item;
+	snmpUdpTail = item;
+	snmpUdpHead->next = item;
     } else {
-        snmpUdpTail->next = item;
-        snmpUdpTail = item;
+	snmpUdpTail->next = item;
+	snmpUdpTail = item;
     }
 
 }
 
 /*
-        Utility functions
-*/
+ * Utility functions
+ */
 
 /*
-        Tree utility functions. 
-*/
+ * Tree utility functions. 
+ */
 
 /*
-        Adds a node to the MIB tree structure and adds the appropriate children
-*/
-mib_tree_entry*
-snmpAddNode(oid *name, int len, oid_ParseFn *parsefunction, int children,  ...)
+ * Adds a node to the MIB tree structure and adds the appropriate children
+ */
+mib_tree_entry *
+snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, int children,...)
 {
-        va_list args;
-        int loop;
-        mib_tree_entry *entry = NULL;
-
-        debug(49, 6) ("snmpAddNode: Children : %d, Oid : \n", children);
-        snmpDebugOid(6, name, len);
-
-        va_start(args, children);
-        entry = xmalloc(sizeof(mib_tree_entry));
-        entry->name = snmpOidDup(name, len);
-        entry->len = len;
-        entry->parsefunction = parsefunction;
-        entry->children = children;
-
-        if(children > 0){
-                entry->leaves = xmalloc(sizeof(mib_tree_entry*)*children);
-                for(loop = 0;loop < children;loop++){
-                        entry->leaves[loop] = va_arg(args, mib_tree_entry*);
-			entry->leaves[loop]->parent = entry;
-                }
-        }
-        return(entry);
+    va_list args;
+    int loop;
+    mib_tree_entry *entry = NULL;
+
+    debug(49, 6) ("snmpAddNode: Children : %d, Oid : \n", children);
+    snmpDebugOid(6, name, len);
+
+    va_start(args, children);
+    entry = xmalloc(sizeof(mib_tree_entry));
+    entry->name = snmpOidDup(name, len);
+    entry->len = len;
+    entry->parsefunction = parsefunction;
+    entry->children = children;
+
+    if (children > 0) {
+	entry->leaves = xmalloc(sizeof(mib_tree_entry *) * children);
+	for (loop = 0; loop < children; loop++) {
+	    entry->leaves[loop] = va_arg(args, mib_tree_entry *);
+	    entry->leaves[loop]->parent = entry;
+	}
+    }
+    return (entry);
 }
 /* End of tree utility functions */
 
 /* 
-        Returns the list of parameters in an oid[]
-*/
-oid*
-snmpCreateOid(int length, ...)
+ * Returns the list of parameters in an oid[]
+ */
+oid *
+snmpCreateOid(int length,...)
 {
-        va_list args;
-        oid     *new_oid;
-        int     loop;
-
-        va_start(args, length);
-        new_oid = xmalloc(sizeof(oid)*length);
-
-        if(length > 0){
-                for(loop = 0;loop < length;loop++){
-                        new_oid[loop] = va_arg(args, int);
-                }
-        }
-        return(new_oid);
+    va_list args;
+    oid *new_oid;
+    int loop;
+
+    va_start(args, length);
+    new_oid = xmalloc(sizeof(oid) * length);
+
+    if (length > 0) {
+	for (loop = 0; loop < length; loop++) {
+	    new_oid[loop] = va_arg(args, int);
+	}
+    }
+    return (new_oid);
 }
 
 /*
-        Allocate space for, and copy, an OID.  Returns new oid, or NULL.
+ * Allocate space for, and copy, an OID.  Returns new oid, or NULL.
  */
 oid *
 snmpOidDup(oid * A, snint ALen)
 {
     oid *Ans;
- 
-    Ans = (oid *) xmalloc(sizeof(oid) * ALen); 
+
+    Ans = (oid *) xmalloc(sizeof(oid) * ALen);
     if (Ans)
-        memcpy(Ans, A, (sizeof(oid) * ALen));
+	memcpy(Ans, A, (sizeof(oid) * ALen));
     return (Ans);
 }
 
 /*
-        Debug calls, prints out the OID for debugging purposes.
-*/
+ * Debug calls, prints out the OID for debugging purposes.
+ */
 void
 snmpDebugOid(int lvl, oid * Name, snint Len)
-{   
+{
     char mbuf[16], objid[1024];
     int x;
     objid[0] = '\0';
 
     for (x = 0; x < Len; x++) {
-        snprintf(mbuf, sizeof(mbuf), ".%u", (unsigned int) Name[x]);
-        strncat(objid, mbuf, sizeof(objid));
+	snprintf(mbuf, sizeof(mbuf), ".%u", (unsigned int) Name[x]);
+	strncat(objid, mbuf, sizeof(objid));
     }
-    
+
     debug(49, lvl) ("   oid = %s\n", objid);
 }
 
-static void     
+static void
 snmpSnmplibDebug(int lvl, char *buf)
-{           
+{
     debug(49, lvl) ("%s", buf);
-}           
-
-
+}
@@ -1,6 +1,8 @@
 
+
+
 /*
- * $Id: squid.h,v 1.177 1998/08/17 23:00:41 wessels Exp $
+ * $Id: squid.h,v 1.178 1998/11/12 06:28:24 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -222,6 +224,9 @@
 
 /* Make sure syslog goes after stdarg/varargs */
 #ifdef HAVE_SYSLOG_H
+#ifdef _SQUID_AIX_
+#define _XOPEN_EXTENDED_SOURCE
+#endif
 #include <syslog.h>
 #endif
 
@@ -300,6 +305,10 @@ struct rusage {
 #define cbdataAdd(a,b)	cbdataAddDbg(a,b,__FILE__,__LINE__)
 #endif
 
+#if defined(_SQUID_NEXT_) && !defined(S_ISDIR)
+#define S_ISDIR(mode) (((mode) & (_S_IFMT)) == (_S_IFDIR))
+#endif
+
 #ifdef USE_GNUREGEX
 #include "GNUregex.h"
 #elif HAVE_REGEX_H
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.297 1998/10/19 22:37:03 wessels Exp $
+ * $Id: stat.cc,v 1.298 1998/11/12 06:28:25 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -1009,6 +1009,8 @@ statCountersDump(StoreEntry * sentry)
 	(int) f->client_http.kbytes_in.kb);
     storeAppendPrintf(sentry, "client_http.kbytes_out = %d\n",
 	(int) f->client_http.kbytes_out.kb);
+    storeAppendPrintf(sentry, "client_http.hit_kbytes_out = %d\n",
+	(int) f->client_http.hit_kbytes_out.kb);
 
     storeAppendPrintf(sentry, "server.all.requests = %d\n",
 	(int) f->server.all.requests);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.469 1998/10/16 19:18:16 wessels Exp $
+ * $Id: store.cc,v 1.470 1998/11/12 06:28:27 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -1007,8 +1007,10 @@ storeFreeMemory(void)
     hashFreeItems(store_table, destroy_StoreEntry);
     hashFreeMemory(store_table);
     store_table = NULL;
+#if USE_CACHE_DIGEST
     if (store_digest)
 	cacheDigestDestroy(store_digest);
+#endif
     store_digest = NULL;
 }
 
@@ -1,5 +1,5 @@
 /*
- * $Id: store_digest.cc,v 1.30 1998/10/19 22:37:04 wessels Exp $
+ * $Id: store_digest.cc,v 1.31 1998/11/12 06:28:28 wessels Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -180,25 +180,60 @@ storeDigestReport(StoreEntry * e)
 
 #if USE_CACHE_DIGESTS
 
+/* should we digest this entry? used by storeDigestAdd() */
+static int
+storeDigestAddable(const StoreEntry * e)
+{
+    /* add some stats! XXX */
+
+    debug(71, 6) ("storeDigestAddable: checking entry, key: %s\n",
+	storeKeyText(e->key));
+
+    /* check various entry flags (mimics storeCheckCachable XXX) */
+    if (!EBIT_TEST(e->flags, ENTRY_CACHABLE)) {
+	debug(71, 6) ("storeDigestAddable: NO: not cachable\n");
+	return 0;
+    }
+    if (EBIT_TEST(e->flags, KEY_PRIVATE)) {
+	debug(71, 6) ("storeDigestAddable: NO: private key\n");
+	return 0;
+    }
+    if (EBIT_TEST(e->flags, ENTRY_NEGCACHED)) {
+	debug(71, 6) ("storeDigestAddable: NO: negative cached\n");
+	return 0;
+    }
+    if (EBIT_TEST(e->flags, RELEASE_REQUEST)) {
+	debug(71, 6) ("storeDigestAddable: NO: release requested\n");
+	return 0;
+    }
+    if (e->store_status == STORE_OK && EBIT_TEST(e->flags, ENTRY_BAD_LENGTH)) {
+	debug(71, 6) ("storeDigestAddable: NO: wrong content-length\n");
+	return 0;
+    }
+    /* do not digest huge objects */
+    if (e->swap_file_sz > Config.Store.maxObjectSize) {
+	debug(71, 6) ("storeDigestAddable: NO: too big\n");
+	return 0;
+    }
+    /* still here? check staleness */
+    /* Note: We should use the time of the next rebuild, not (cur_time+period) */
+    if (refreshCheckDigest(e, StoreDigestRebuildPeriod)) {
+	debug(71, 6) ("storeDigestAdd: entry expires within %d secs, ignoring\n",
+	    StoreDigestRebuildPeriod);
+	return 0;
+    }
+    /* idea: how about also skipping very fresh (thus, potentially unstable) 
+     * entries? Should be configurable through cd_refresh_pattern, of course */
+
+    return 1;
+}
+
 static void
 storeDigestAdd(const StoreEntry * entry)
 {
-    int good_entry = 0;
     assert(entry && store_digest);
-    debug(71, 6) ("storeDigestAdd: checking entry, key: %s\n",
-	storeKeyText(entry->key));
-    /* only public entries are digested */
-    if (!EBIT_TEST(entry->flags, KEY_PRIVATE)) {
-	/* if expires too soon, ignore */
-	/* Note: We should use the time of the next rebuild, not (cur_time+period) */
-	if (refreshCheckDigest(entry, StoreDigestRebuildPeriod)) {
-	    debug(71, 6) ("storeDigestAdd: entry expires within %d secs, ignoring\n",
-		StoreDigestRebuildPeriod);
-	} else {
-	    good_entry = 1;
-	}
-    }
-    if (good_entry) {
+
+    if (storeDigestAddable(entry)) {
 	sd_stats.add_count++;
 	if (cacheDigestTest(store_digest, entry->key))
 	    sd_stats.add_coll_count++;
@@ -1,7 +1,6 @@
 
-
 /*
- * $Id: structs.h,v 1.246 1998/11/11 20:04:20 glenn Exp $
+ * $Id: structs.h,v 1.247 1998/11/12 06:28:29 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -57,11 +56,6 @@ struct _acl_name_list {
     acl_name_list *next;
 };
 
-struct _acl_proxy_auth {
-    int timeout;		/* timeout value for cached usercode:password entries */
-    hash_table *hash;
-};
-
 struct _acl_proxy_auth_user {
     /* first two items must be same as hash_link */
     char *user;
@@ -259,6 +253,7 @@ struct _SquidConfig {
     int dnsChildren;
     int redirectChildren;
     int authenticateChildren;
+    int authenticateTTL;
     struct {
 	char *host;
 	u_short port;
@@ -341,6 +336,8 @@ struct _SquidConfig {
 	int reload_into_ims;
 #endif
 	int offline;
+	int redir_rewrites_host;
+	int persistent_client_posts;
     } onoff;
     acl *aclList;
     struct {
@@ -407,6 +404,7 @@ struct _SquidConfig {
     } comm_incoming;
     int max_open_disk_fds;
     int uri_whitespace;
+    size_t rangeOffsetLimit;
 };
 
 struct _SquidConfig2 {
@@ -729,6 +727,7 @@ struct _AccessLogEntry {
 	method_t method;
 	int code;
 	const char *content_type;
+	float version;
     } http;
     struct {
 	icp_opcode opcode;
@@ -887,6 +886,7 @@ struct _domain_type {
     domain_type *next;
 };
 
+#if USE_CACHE_DIGESTS
 struct _Version {
     short int current;		/* current version */
     short int required;		/* minimal version that can safely handle current version */
@@ -947,6 +947,8 @@ struct _PeerDigest {
     } stats;
 };
 
+#endif
+
 struct _peer {
     char *host;
     peer_t type;
@@ -1007,7 +1009,9 @@ struct _peer {
 	    unsigned int counting:1;
 	} flags;
     } mcast;
+#if USE_CACHE_DIGESTS
     PeerDigest digest;
+#endif
     int tcp_up;			/* 0 if a connect() fails */
     time_t last_fail_time;
     struct in_addr addresses[10];
@@ -1022,6 +1026,7 @@ struct _peer {
 	float load_factor;
     } carp;
 #endif
+    char *login;		/* Proxy authorization */
 };
 
 struct _net_db_name {
@@ -1073,7 +1078,6 @@ struct _ps_state {
      */
     struct sockaddr_in first_parent_miss;
     struct sockaddr_in closest_parent_miss;
-    struct sockaddr_in single_parent;
     ping_data ping;
     aclCheck_t *acl_checklist;
 };
@@ -1234,6 +1238,8 @@ struct _request_flags {
 #if HTTP_VIOLATIONS
     unsigned int nocache_hack:1;	/* for changing/ignoring no-cache requests */
 #endif
+    unsigned int accelerated:1;
+    unsigned int internal:1;
 };
 
 struct _request_t {
@@ -1263,6 +1269,7 @@ struct _request_t {
 #if DELAY_POOLS
     delay_id delay_id;
 #endif
+    char *peer_login;		/* Configured peer login:password */
 };
 
 struct _cachemgr_passwd {
@@ -1400,7 +1407,9 @@ struct _StatCounters {
 	kb_t memory;
 	int msgs_sent;
 	int msgs_recv;
+#if USE_CACHE_DIGESTS
 	cd_guess_stats guess;
+#endif
 	StatHist on_xition_count;
     } cd;
     struct {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.81 1998/11/11 20:04:21 glenn Exp $
+ * $Id: typedefs.h,v 1.82 1998/11/12 06:28:30 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -204,7 +204,7 @@ typedef void StatHistBinDumper(StoreEntry *, int idx, double val, double size, i
 /* append/vprintf's for Packer */
 typedef void (*append_f) (void *, const char *buf, int size);
 #ifdef __STDC__
-typedef void (*vprintf_f) (void *, const char *fmt,...);
+typedef void (*vprintf_f) (void *, const char *fmt, va_list args);
 #else
 typedef void (*vprintf_f) ();
 #endif